uint64_t RBPathStorageIsSingleElement(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 8) >> 3) & 1;
}

double RBSymbolUpdateNextTime(uint64_t a1)
{
  return *(double *)(a1 + 912);
}

uint64_t RBSymbolUpdateGroupCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 848);
}

uint64_t RBDisplayListGetState(uint64_t a1)
{
  return *(void *)(a1 + 280);
}

uint64_t RBDrawingStateGetIdentifier(uint64_t a1)
{
  return *(unsigned int *)(a1 + 64);
}

BOOL RBPathStorageIsEmpty(uint64_t a1)
{
  unint64_t v1 = *(unsigned int *)(a1 + 8);
  if (v1) {
    uint64_t v2 = *(void *)(a1 + 24);
  }
  else {
    uint64_t v2 = (v1 >> 8) & 0xFFF;
  }
  return v2 == 0;
}

uint64_t RBPathStorageAppendPath(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

RB::Path::Storage *RBPathStorageInit(RB::Path::Storage *result, const char *a2, const RB::Path::Storage *a3)
{
  if (a3)
  {
    return RB::Path::Storage::Storage(result, a2, a3);
  }
  else
  {
    *(void *)result = 0;
    if ((unint64_t)a2 <= 0x3F) {
      RB::precondition_failure((RB *)"invalid capacity", a2);
    }
    int v3 = a2 - 16;
    if ((unint64_t)(a2 - 16) >= 0xFFF) {
      int v3 = 4095;
    }
    int v4 = v3 << 20;
    unsigned int v5 = atomic_fetch_add_explicit(&RB::Path::Storage::_last_identifier, 1u, memory_order_relaxed) + 1;
    *((_DWORD *)result + 2) = v4;
    *((_DWORD *)result + 3) = v5;
  }
  return result;
}

void RBDrawingStateSetIdentifier(uint64_t a1, int a2, void *a3)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (a3)
  {
    uuid_clear((unsigned __int8 *)&v9);
    int v8 = a2;
    [a3 getUUIDBytes:&v9];
LABEL_3:
    return;
  }
  uint64_t v7 = *(void *)(a1 + 8);
  if (!*(void *)(v7 + 24)) {
    make_contents(*(void *)(a1 + 8));
  }
  if (*(void *)(v7 + 304))
  {
    uuid_clear((unsigned __int8 *)&v9);
    int v8 = a2;
    long long v9 = *(_OWORD *)(a1 + 68);
    goto LABEL_3;
  }
  *(_DWORD *)(a1 + 64) = a2;
}

uint64_t RBSymbolUpdateGroupSize(uint64_t a1, int a2)
{
  uint64_t v2 = a1 + 8;
  unsigned int v3 = *(_DWORD *)(a1 + 848) + ~a2;
  if (*(void *)(a1 + 840)) {
    uint64_t v2 = *(void *)(a1 + 840);
  }
  uint64_t v4 = *(void *)(v2 + 416 * v3 + 400);
  if (v4) {
    return *(void *)(v4 + 8);
  }
  else {
    return *(unsigned int *)(v2 + 416 * v3 + 384);
  }
}

uint64_t RB::Path::Mapper::add_rounded_rect(__n128 *this, float64x2_t *a2, float64x2_t *a3, int a4, float64x2_t *a5, float64x2_t a6, float64_t a7, float64_t a8, float64_t a9)
{
  float64x2_t v11 = *a3;
  float64x2_t v12 = a3[1];
  int64x2_t v13 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqzq_f64(*a3), (int8x16_t)vceqzq_f64(*a2)), vandq_s8((int8x16_t)vceqzq_f64(v12), (int8x16_t)vceqzq_f64(a2[1])));
  if ((vandq_s8((int8x16_t)v13, (int8x16_t)vdupq_laneq_s64(v13, 1)).u64[0] & 0x8000000000000000) != 0)
  {
    return RB::Path::Mapper::add_rect(this, *(CGRect *)a6.f64, a5, 0);
  }
  else
  {
    float64x2_t v144 = a2[1];
    float64x2_t v146 = *a2;
    a6.f64[1] = a7;
    v15.f64[0] = a8;
    v15.f64[1] = a9;
    float64x2_t v16 = vaddq_f64(a6, v15);
    float64x2_t v17 = vmaxnmq_f64(a6, v16);
    float64x2_t v149 = vminnmq_f64(a6, v16);
    double v18 = a3->f64[1];
    double v148 = v17.f64[1];
    double v142 = v149.f64[1] + v11.f64[1];
    double v138 = v17.f64[1] - v12.f64[0];
    float64x2_t v150 = v17;
    v19.f64[0] = v17.f64[0];
    v19.f64[1] = (v17.f64[1] - v12.f64[0] + v149.f64[1] + v11.f64[1]) * 0.5;
    double v145 = a3->f64[0];
    float64x2_t v147 = a3[1];
    RB::Path::Mapper::elt_moveto(this, a5, v19);
    if ((a4 & 0xFFFFFFFD) == 9)
    {
      double v135 = v18;
      float v20 = v18;
      float v21 = v147.f64[0];
      float v22 = a9;
      float v133 = fabsf(v22);
      float v23 = (float)(v133 - (float)(v21 + v20)) / (float)((float)(v21 + v20) * 0.52866);
      double v24 = 0.868407011;
      double v25 = 1.08849001;
      double v26 = 1.52866495;
      double v143 = 1.52866495;
      double v141 = 1.08849001;
      double v139 = 0.868407011;
      if (v23 < 1.0)
      {
        float v27 = 0.0;
        if (v23 >= 0.0) {
          float v27 = v23;
        }
        if (v27 > 1.0) {
          float v27 = 1.0;
        }
        float v28 = (float)(v27 * 0.12849) + 0.96;
        float v29 = (float)(v27 * 0.048407) + 0.82;
        double v26 = (float)((float)(v27 * 0.52866) + 1.0);
        double v25 = v28;
        double v24 = v29;
      }
      float v134 = v23;
      double v30 = v148 - v26 * v147.f64[0];
      v31.f64[0] = v150.f64[0];
      v31.f64[1] = v30;
      RB::Path::Mapper::elt_lineto(this, a5, v31);
      v32.f64[0] = v150.f64[0];
      v32.f64[1] = v148 - v25 * v147.f64[0];
      v33.f64[0] = v150.f64[0];
      v33.f64[1] = v148 - v24 * v147.f64[0];
      _D9 = 0x3FB32D64C0000000;
      _D3 = v144.f64[0];
      __asm { FMLS            D2, D9, V3.D[0] }
      _D14 = 0x3FE43532E0000000;
      _Q2.f64[1] = v148 - v147.f64[0] * 0.631493986;
      RB::Path::Mapper::elt_cubeto((uint64_t)this, a5, v32, v33, _Q2);
      _D10 = 0x3FC5A3C220000000;
      _D3 = v144.f64[0];
      __asm { FMLS            D0, D10, V3.D[0] }
      _D11 = 0x3FD7DC5940000000;
      _Q0.f64[1] = v148 - v147.f64[0] * 0.372824013;
      __asm { FMLS            D1, D11, V3.D[0] }
      _Q1.f64[1] = v148 - v147.f64[0] * 0.169060007;
      __asm { FMLS            D2, D14, V3.D[0] }
      _Q2.f64[1] = v148 - v147.f64[0] * 0.0749114007;
      RB::Path::Mapper::elt_cubeto((uint64_t)this, a5, _Q0, _Q1, _Q2);
      float v48 = v144.f64[0];
      float v49 = v144.f64[1];
      float v50 = a8;
      float v137 = fabsf(v50);
      float v51 = (float)(v137 - (float)(v49 + v48)) / (float)((float)(v49 + v48) * 0.52866);
      double v52 = 1.52866495;
      double v53 = 1.08849001;
      double v54 = 0.868407011;
      if (v51 < 1.0)
      {
        if (v51 < 0.0) {
          float v51 = 0.0;
        }
        if (v51 > 1.0) {
          float v51 = 1.0;
        }
        double v54 = (float)((float)(v51 * 0.048407) + 0.82);
        double v53 = (float)((float)(v51 * 0.12849) + 0.96);
        double v52 = (float)((float)(v51 * 0.52866) + 1.0);
      }
      v55.f64[1] = v150.f64[1];
      v55.f64[0] = v150.f64[0] - v54 * v144.f64[0];
      v56.f64[1] = v150.f64[1];
      v56.f64[0] = v150.f64[0] - v53 * v144.f64[0];
      v57.f64[1] = v150.f64[1];
      v57.f64[0] = v150.f64[0] - v52 * v144.f64[0];
      RB::Path::Mapper::elt_cubeto((uint64_t)this, a5, v55, v56, v57);
      v58.f64[1] = v150.f64[1];
      v58.f64[0] = v149.f64[0] + v52 * v144.f64[1];
      RB::Path::Mapper::elt_lineto(this, a5, v58);
      v59.f64[1] = v150.f64[1];
      v59.f64[0] = v149.f64[0] + v53 * v144.f64[1];
      v60.f64[1] = v150.f64[1];
      v60.f64[0] = v149.f64[0] + v54 * v144.f64[1];
      v61.f64[0] = v149.f64[0] + v144.f64[1] * 0.631493986;
      _D13 = v147.f64[1];
      _D9 = 0x3FB32D64C0000000;
      __asm { FMLS            D3, D9, V4.D[1] }
      v61.f64[1] = _D3;
      RB::Path::Mapper::elt_cubeto((uint64_t)this, a5, v59, v60, v61);
      v65.f64[0] = v149.f64[0] + v144.f64[1] * 0.372824013;
      _V5.D[1] = v147.f64[1];
      __asm { FMLS            D1, D10, V5.D[1] }
      v65.f64[1] = _D1;
      v68.f64[0] = v149.f64[0] + v144.f64[1] * 0.169060007;
      __asm { FMLS            D2, D11, V5.D[1] }
      v68.f64[1] = _D2;
      v70.f64[0] = v149.f64[0] + v144.f64[1] * 0.0749114007;
      __asm { FMLS            D3, D14, V5.D[1] }
      v70.f64[1] = _D3;
      RB::Path::Mapper::elt_cubeto((uint64_t)this, a5, v65, v68, v70);
      float v72 = v147.f64[1];
      float v73 = v145;
      float v74 = (float)(v133 - (float)(v73 + v72)) / (float)((float)(v73 + v72) * 0.52866);
      double v75 = 1.52866495;
      double v76 = 1.08849001;
      double v77 = 0.868407011;
      if (v74 < 1.0)
      {
        if (v74 < 0.0) {
          float v74 = 0.0;
        }
        if (v74 > 1.0) {
          float v74 = 1.0;
        }
        double v77 = (float)((float)(v74 * 0.048407) + 0.82);
        double v76 = (float)((float)(v74 * 0.12849) + 0.96);
        double v75 = (float)((float)(v74 * 0.52866) + 1.0);
      }
      v78.f64[0] = v149.f64[0];
      v78.f64[1] = v148 - v77 * v147.f64[1];
      v79.f64[0] = v149.f64[0];
      v79.f64[1] = v148 - v76 * v147.f64[1];
      v80.f64[0] = v149.f64[0];
      v80.f64[1] = v148 - v75 * v147.f64[1];
      RB::Path::Mapper::elt_cubeto((uint64_t)this, a5, v78, v79, v80);
      v81.f64[0] = v149.f64[0];
      v81.f64[1] = v149.f64[1] + v75 * v145;
      RB::Path::Mapper::elt_lineto(this, a5, v81);
      v82.f64[0] = v149.f64[0];
      v82.f64[1] = v149.f64[1] + v76 * v145;
      v83.f64[0] = v149.f64[0];
      v83.f64[1] = v149.f64[1] + v77 * v145;
      v84.f64[0] = vmlad_n_f64(v149.f64[0], 0.0749114007, v146.f64[0]);
      v84.f64[1] = v149.f64[1] + v145 * 0.631493986;
      RB::Path::Mapper::elt_cubeto((uint64_t)this, a5, v82, v83, v84);
      v85.f64[0] = vmlad_n_f64(v149.f64[0], 0.169060007, v146.f64[0]);
      v85.f64[1] = v149.f64[1] + v145 * 0.372824013;
      v86.f64[0] = vmlad_n_f64(v149.f64[0], 0.372824013, v146.f64[0]);
      v86.f64[1] = v149.f64[1] + v145 * 0.169060007;
      v87.f64[0] = vmlad_n_f64(v149.f64[0], 0.631493986, v146.f64[0]);
      v87.f64[1] = v149.f64[1] + v145 * 0.0749114007;
      RB::Path::Mapper::elt_cubeto((uint64_t)this, a5, v85, v86, v87);
      float v88 = v146.f64[0];
      float v89 = v146.f64[1];
      float v90 = (float)(v137 - (float)(v89 + v88)) / (float)((float)(v89 + v88) * 0.52866);
      double v91 = 1.52866495;
      double v92 = 1.08849001;
      double v93 = 0.868407011;
      if (v90 < 1.0)
      {
        if (v90 < 0.0) {
          float v90 = 0.0;
        }
        if (v90 > 1.0) {
          float v90 = 1.0;
        }
        double v93 = (float)((float)(v90 * 0.048407) + 0.82);
        double v92 = (float)((float)(v90 * 0.12849) + 0.96);
        double v91 = (float)((float)(v90 * 0.52866) + 1.0);
      }
      v94.f64[1] = v149.f64[1];
      v94.f64[0] = v149.f64[0] + v93 * v146.f64[0];
      v95.f64[1] = v149.f64[1];
      v95.f64[0] = v149.f64[0] + v92 * v146.f64[0];
      v96.f64[1] = v149.f64[1];
      v96.f64[0] = v149.f64[0] + v91 * v146.f64[0];
      RB::Path::Mapper::elt_cubeto((uint64_t)this, a5, v94, v95, v96);
      v97.f64[1] = v149.f64[1];
      v97.f64[0] = v150.f64[0] - v91 * v146.f64[1];
      RB::Path::Mapper::elt_lineto(this, a5, v97);
      v98.f64[1] = v149.f64[1];
      v99.f64[1] = v149.f64[1];
      v99.f64[0] = v150.f64[0] - v92 * v146.f64[1];
      v98.f64[0] = v150.f64[0] - v93 * v146.f64[1];
      float64x2_t v100 = v98;
      v98.f64[0] = v150.f64[0] - v146.f64[1] * 0.631493986;
      v98.f64[1] = v149.f64[1] + v135 * 0.0749114007;
      RB::Path::Mapper::elt_cubeto((uint64_t)this, a5, v99, v100, v98);
      v101.f64[0] = v150.f64[0] - v146.f64[1] * 0.372824013;
      v101.f64[1] = v149.f64[1] + v135 * 0.169060007;
      v102.f64[0] = v150.f64[0] - v146.f64[1] * 0.169060007;
      v102.f64[1] = v149.f64[1] + v135 * 0.372824013;
      v103.f64[0] = v150.f64[0] - v146.f64[1] * 0.0749114007;
      v103.f64[1] = v149.f64[1] + v135 * 0.631493986;
      RB::Path::Mapper::elt_cubeto((uint64_t)this, a5, v101, v102, v103);
      if (v134 < 1.0)
      {
        float v104 = 0.0;
        if (v134 >= 0.0) {
          float v104 = v134;
        }
        if (v104 > 1.0) {
          float v104 = 1.0;
        }
        double v139 = (float)((float)(v104 * 0.048407) + 0.82);
        double v141 = (float)((float)(v104 * 0.12849) + 0.96);
        double v143 = (float)((float)(v104 * 0.52866) + 1.0);
      }
      v107.f64[0] = v150.f64[0];
      v105.f64[0] = v150.f64[0];
      v105.f64[1] = v149.f64[1] + v139 * v135;
      v106.f64[0] = v150.f64[0];
      v106.f64[1] = v149.f64[1] + v141 * v135;
      v107.f64[1] = v149.f64[1] + v143 * v135;
      v108 = (RB::Path::Mapper *)this;
    }
    else
    {
      v110.f64[0] = v150.f64[0];
      v110.f64[1] = v138;
      RB::Path::Mapper::elt_lineto(this, a5, v110);
      _D10 = 0x3FDCA75DDD61E2A2;
      v112.f64[0] = v150.f64[0];
      v112.f64[1] = v148 - v147.f64[0] * 0.44771525;
      _D3 = v144.f64[0];
      __asm { FMLS            D2, D10, V3.D[0] }
      v115.f64[1] = v150.f64[1];
      v115.f64[0] = _D2;
      v116.f64[1] = v150.f64[1];
      v116.f64[0] = v150.f64[0] - v144.f64[0];
      RB::Path::Mapper::elt_cubeto((uint64_t)this, a5, v112, v115, v116);
      v117.f64[1] = v150.f64[1];
      v117.f64[0] = v149.f64[0] + v144.f64[1];
      RB::Path::Mapper::elt_lineto(this, a5, v117);
      _V0.D[1] = v144.f64[1];
      __asm { FMLA            D1, D10, V0.D[1] }
      v120.f64[1] = v150.f64[1];
      v120.f64[0] = _D1;
      _D1 = v147.f64[1];
      __asm { FMLS            D2, D10, V5.D[1] }
      v123.f64[0] = v149.f64[0];
      v123.f64[1] = _D2;
      v124.f64[0] = v149.f64[0];
      v124.f64[1] = v148 - v147.f64[1];
      RB::Path::Mapper::elt_cubeto((uint64_t)this, a5, v120, v123, v124);
      v125.f64[0] = v149.f64[0];
      v125.f64[1] = v149.f64[1] + v145;
      RB::Path::Mapper::elt_lineto(this, a5, v125);
      v126.f64[0] = v149.f64[0];
      v126.f64[1] = vmlad_n_f64(v149.f64[1], 0.44771525, v145);
      v127.f64[1] = v149.f64[1];
      v127.f64[0] = vmlad_n_f64(v149.f64[0], 0.44771525, v146.f64[0]);
      v128.f64[1] = v149.f64[1];
      v128.f64[0] = v149.f64[0] + v146.f64[0];
      RB::Path::Mapper::elt_cubeto((uint64_t)this, a5, v126, v127, v128);
      v129.f64[1] = v149.f64[1];
      v129.f64[0] = v150.f64[0] - v146.f64[1];
      RB::Path::Mapper::elt_lineto(this, a5, v129);
      v130.f64[1] = v149.f64[1];
      v107.f64[0] = v150.f64[0];
      _V1.D[1] = v146.f64[1];
      __asm { FMLS            D0, D10, V1.D[1] }
      v130.f64[0] = _D0;
      v106.f64[0] = v150.f64[0];
      v106.f64[1] = v149.f64[1] + v18 * 0.44771525;
      v107.f64[1] = v142;
      v108 = (RB::Path::Mapper *)this;
      float64x2_t v105 = v130;
    }
    RB::Path::Mapper::elt_cubeto((uint64_t)v108, a5, v105, v106, v107);
    return RB::Path::Mapper::elt_closepath((uint64_t)this);
  }
}

BOOL RB::Path::Storage::apply_elements_(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, unsigned char *, long long *))
{
  unint64_t v4 = 0;
  uint64_t v60 = *MEMORY[0x263EF8340];
  float64x2_t v58 = 0;
  uint64_t v59 = 0x400000000;
  unsigned int v5 = (void *)(a1 + 16);
  while (2)
  {
    unint64_t v6 = v4;
    unint64_t v7 = *(unsigned int *)(a1 + 8);
    if (v7) {
      unint64_t v8 = *(void *)(a1 + 24);
    }
    else {
      unint64_t v8 = (v7 >> 8) & 0xFFF;
    }
    if (v4 < v8)
    {
      long long v9 = v5;
      if (v7) {
        long long v9 = (void *)*v5;
      }
      ++v4;
      char v10 = *((unsigned char *)v9 + v6);
      uint64_t v11 = v10 & 0x1F;
      if (v10 < 0)
      {
        int v13 = 0;
        int v12 = 1;
        switch(v10 & 0x1F)
        {
          case 0x10:
          case 0x12:
          case 0x16:
          case 0x17:
            goto LABEL_13;
          case 0x11:
          case 0x15:
            goto LABEL_10;
          case 0x13:
            int v13 = 2;
            goto LABEL_13;
          case 0x14:
            int v13 = 3;
            goto LABEL_13;
          case 0x18:
            int v13 = 4;
            goto LABEL_13;
          default:
            if (v11 == 4) {
              goto LABEL_13;
            }
            goto LABEL_10;
        }
      }
      int v12 = 0;
LABEL_10:
      if (v11 >= 0x19)
      {
        unsigned __int8 v52 = v10 & 0x1F;
      }
      else
      {
        int v13 = v12;
LABEL_13:
        uint64_t v14 = __RBPathElementArgumentCount[v11];
        unsigned __int8 v52 = v10 & 0x1F;
        if (v14)
        {
          float64x2_t v15 = (float *)((char *)v9 + v4);
          if ((v10 & 0x40) != 0)
          {
            float64x2_t v16 = (double *)__dst;
            uint64_t v17 = v14;
            do
            {
              float v18 = *v15++;
              *v16++ = v18;
              --v17;
            }
            while (v17);
            v4 += 4 * v14;
          }
          else if ((v10 & 0x20) != 0)
          {
            float64x2_t v19 = (double *)__dst;
            uint64_t v20 = v14;
            do
            {
              int v21 = *(__int16 *)v15;
              float64x2_t v15 = (float *)((char *)v15 + 2);
              *v19++ = (double)v21;
              --v20;
            }
            while (v20);
            v4 += 2 * v14;
          }
          else
          {
            memcpy(__dst, v15, 8 * v14);
            v4 += 8 * v14;
          }
        }
        int v12 = v13;
      }
      switch(v12)
      {
        case 0:
          char v53 = 0;
          uint64_t v22 = v52;
          goto LABEL_40;
        case 1:
          float64x2_t v32 = (float *)((char *)v9 + v4);
          if ((v10 & 0x40) != 0)
          {
            for (uint64_t i = 0; i != 6; ++i)
              *((double *)&v54 + i) = v32[i];
            uint64_t v35 = 24;
          }
          else if ((v10 & 0x20) != 0)
          {
            for (uint64_t j = 0; j != 6; ++j)
              *((double *)&v54 + j) = (double)*((__int16 *)v32 + j);
            uint64_t v35 = 12;
          }
          else
          {
            long long v33 = *(_OWORD *)v32;
            long long v34 = *((_OWORD *)v32 + 2);
            long long v55 = *((_OWORD *)v32 + 1);
            long long v56 = v34;
            long long v54 = v33;
            uint64_t v35 = 48;
          }
          unint64_t v24 = v4 + v35;
          goto LABEL_78;
        case 2:
          LODWORD(v54) = *((unsigned __int8 *)v9 + v4);
          DWORD1(v54) = *((unsigned __int8 *)v9 + v4 + 1);
          uint64_t v36 = *(unsigned __int16 *)((char *)v9 + v4 + 2);
          unint64_t v24 = v4 + 4;
          *((void *)&v54 + 1) = v36;
          if (v36)
          {
            if (v59 < v36 && HIDWORD(v59) < v36) {
              RB::vector<std::unique_ptr<RB::RenderQueue,RB::RenderFrame::QueueDeleter>,4ul,unsigned int>::reserve_slow(v57, v36);
            }
            LODWORD(v59) = v36;
            v38 = v58;
            if (v58) {
              v39 = (double *)v58;
            }
            else {
              v39 = (double *)v57;
            }
            v40 = (float *)((char *)v9 + v24);
            if ((v10 & 0x40) != 0)
            {
              uint64_t v43 = v36;
              do
              {
                float v44 = *v40++;
                *v39++ = v44;
                --v43;
              }
              while (v43);
              size_t v41 = 4 * v36;
            }
            else if ((v10 & 0x20) != 0)
            {
              uint64_t v46 = v36;
              do
              {
                int v47 = *(__int16 *)v40;
                v40 = (float *)((char *)v40 + 2);
                *v39++ = (double)v47;
                --v46;
              }
              while (v46);
              size_t v41 = 2 * v36;
            }
            else
            {
              size_t v41 = 8 * v36;
              memcpy(v39, v40, v41);
              v38 = v58;
            }
            v24 += v41;
            if (!v38) {
              v38 = v57;
            }
            *(void *)&long long v55 = v38;
          }
          goto LABEL_78;
        case 3:
          LOWORD(v54) = *(_WORD *)((char *)v9 + v4);
          unint64_t v24 = v4 + 2;
          goto LABEL_78;
        case 4:
          LODWORD(v54) = *((unsigned __int8 *)v9 + v4);
          DWORD1(v54) = *((unsigned __int8 *)v9 + v4 + 1);
          uint64_t v23 = *(unsigned __int16 *)((char *)v9 + v4 + 2);
          unint64_t v24 = v4 + 4;
          *((void *)&v54 + 1) = v23;
          if (!v23) {
            goto LABEL_78;
          }
          unsigned int v25 = 2 * v23;
          if (v59 >= 2 * (int)v23 || HIDWORD(v59) >= v25)
          {
            LODWORD(v59) = 2 * v23;
            float v27 = v57;
            if (v58) {
              float v27 = v58;
            }
            *(void *)&long long v55 = v27;
LABEL_36:
            unint64_t v28 = 0;
            float v29 = v27 + 4;
            do
            {
              *((_DWORD *)v29 - 1) = *((unsigned __int8 *)v9 + v4 + 4);
              uint64_t v30 = *(void *)((char *)v9 + v4 + 5);
              *((_DWORD *)v29 + 2) = *(_DWORD *)((char *)v9 + v4 + 13);
              *(void *)float v29 = v30;
              v29 += 16;
              ++v28;
              v4 += 13;
            }
            while (v28 < *((void *)&v54 + 1));
            unint64_t v24 = v4 + 4;
            goto LABEL_78;
          }
          RB::vector<std::unique_ptr<RB::RenderQueue,RB::RenderFrame::QueueDeleter>,4ul,unsigned int>::reserve_slow(v57, 2 * v23);
          LODWORD(v59) = v25;
          float v27 = v58;
          if (!v58) {
            float v27 = v57;
          }
          *(void *)&long long v55 = v27;
          if (*((void *)&v54 + 1)) {
            goto LABEL_36;
          }
LABEL_78:
          char v53 = 1;
          uint64_t v22 = v52;
          unint64_t v4 = v24;
LABEL_79:
          float64x2_t v31 = &v54;
LABEL_80:
          if ((a3(a2, v22, __dst, v31) & 1) == 0) {
            break;
          }
          continue;
        default:
          uint64_t v22 = v52;
          if (v53) {
            goto LABEL_79;
          }
LABEL_40:
          float64x2_t v31 = 0;
          goto LABEL_80;
      }
    }
    break;
  }
  if (v58) {
    free(v58);
  }
  return v6 >= v8;
}

uint64_t RB::Path::Mapper::apply_callback(__n128 *this, int a2, uint64_t a3, float64x2_t *a4, float64x2_t a5)
{
  uint64_t v35 = v7;
  uint64_t v36 = v6;
  uint64_t v37 = v5;
  uint64_t v38 = v8;
  uint64_t v39 = v9;
  switch(a2)
  {
    case 0:
      RB::Path::Mapper::elt_moveto(this, a4, *(float64x2_t *)a3);
      return 1;
    case 1:
      RB::Path::Mapper::elt_lineto(this, a4, *(float64x2_t *)a3);
      return 1;
    case 2:
      RB::Path::Mapper::elt_quadto((uint64_t)this, a4, *(float64x2_t *)a3, *(float64x2_t *)(a3 + 16));
      return 1;
    case 3:
      RB::Path::Mapper::elt_cubeto((uint64_t)this, a4, *(float64x2_t *)a3, *(float64x2_t *)(a3 + 16), *(float64x2_t *)(a3 + 32));
      return 1;
    case 4:
      RB::Path::Mapper::elt_closepath((uint64_t)this);
      return 1;
    case 5:
    case 6:
      RB::Path::Mapper::add_rect(this, *(CGRect *)a3, a4, a2 == 5);
      return 1;
    case 7:
      RB::Path::Mapper::add_ellipse(this, *(CGRect *)a3, 0, (const CGAffineTransform *)a4);
      return 1;
    case 8:
    case 9:
      a5.f64[0] = *(float64_t *)a3;
      float64_t v13 = *(double *)(a3 + 8);
      double v14 = *(double *)(a3 + 16);
      double v15 = *(double *)(a3 + 24);
      double v16 = *(double *)(a3 + 32);
      double v17 = *(double *)(a3 + 40);
      double v18 = fabs(v14);
      double v19 = fabs(v15);
      if (v19 < v18) {
        double v18 = v19;
      }
      double v20 = v18 * 0.5;
      if (v16 < 0.0) {
        double v16 = 0.0;
      }
      if (v16 > v20) {
        double v16 = v20;
      }
      if (v17 < 0.0) {
        double v17 = 0.0;
      }
      if (v17 > v20) {
        double v17 = v20;
      }
      v34[0] = vdupq_lane_s64(*(uint64_t *)&v16, 0);
      v34[1] = v34[0];
      v33[0] = vdupq_lane_s64(*(uint64_t *)&v17, 0);
      v33[1] = v33[0];
      int v21 = (float64x2_t *)v34;
      uint64_t v22 = (float64x2_t *)v33;
      goto LABEL_15;
    case 10:
    case 11:
      long long v23 = *(_OWORD *)(a3 + 16);
      float64x2_t v31 = *(float64x2_t *)a3;
      long long v32 = v23;
      long long v24 = *(_OWORD *)(a3 + 48);
      long long v29 = *(_OWORD *)(a3 + 32);
      long long v30 = v24;
      RB::clamp_corner_radii((uint64_t)&v29, (double *)&v32);
      float64_t v13 = v31.f64[1];
      a5.f64[0] = v31.f64[0];
      double v15 = *((double *)&v32 + 1);
      double v14 = *(double *)&v32;
      v28[0] = v29;
      v28[1] = v30;
      v27[0] = v29;
      v27[1] = v30;
      int v21 = (float64x2_t *)v28;
      uint64_t v22 = (float64x2_t *)v27;
LABEL_15:
      RB::Path::Mapper::add_rounded_rect(this, v21, v22, a2, a4, a5, v13, v14, v15);
      break;
    case 12:
      RB::Path::Mapper::add_relative_arc(this, a4, *(float64x2_t *)a3, *(double *)(a3 + 16), *(double *)(a3 + 24), *(double *)(a3 + 32));
      break;
    case 13:
    case 14:
      RB::Path::Mapper::add_arc(this, a2 == 13, (CGAffineTransform *)a4, *(float64x2_t *)a3, *(double *)(a3 + 16), *(double *)(a3 + 24), *(double *)(a3 + 32));
      break;
    case 15:
      RB::Path::Mapper::add_arc_to_point(this, (int8x16_t *)a4, *(float64x2_t *)a3, *(float64x2_t *)(a3 + 16), *(double *)(a3 + 32));
      break;
    case 16:
      RB::Path::Mapper::pop((RB::Path::Mapper *)this);
      break;
    case 17:
      RB::Path::Mapper::push_affine((RB::Path::Mapper *)this, (const CGAffineTransform *)a4);
    case 18:
      RB::Path::Mapper::push_cut((RB::Path::Mapper *)this, *(double *)a3, *(double *)(a3 + 8));
    case 19:
      RB::Path::Mapper::push_stroke((uint64_t)this, (uint64_t)a4);
    case 20:
      RB::Path::Mapper::push_BOOLean();
    case 21:
      unint64_t v25 = this[20].n128_u64[1];
      if (v25) {
        (***(void (****)(void))(v25 + 16))(*(void *)(v25 + 16));
      }
      break;
    case 22:
      RB::Path::Mapper::push_dilate_glyph();
    case 23:
      RB::Path::Mapper::push_offset((RB::Path::Mapper *)this, *(double *)a3);
    case 24:
      RB::Path::Mapper::push_clip_stroke((uint64_t)this, (uint64_t)a4);
    default:
      return 1;
  }
  return 1;
}

uint64_t RB::Path::Mapper::elt_cubeto(uint64_t a1, float64x2_t *a2, float64x2_t a3, float64x2_t a4, float64x2_t a5)
{
  if (a2)
  {
    float64x2_t v5 = a2[1];
    a4 = vmlaq_laneq_f64(vmlaq_n_f64(a2[2], *a2, a4.f64[0]), v5, a4, 1);
    a5 = vmlaq_laneq_f64(vmlaq_n_f64(a2[2], *a2, a5.f64[0]), v5, a5, 1);
    a3 = vmlaq_laneq_f64(vmlaq_n_f64(a2[2], *a2, a3.f64[0]), v5, a3, 1);
  }
  uint64_t v6 = *(void *)(a1 + 328);
  if (!v6) {
    return RB::Path::Mapper::cubeto(a1, a3, a4, a5);
  }
  *(float64x2_t *)(v6 + 32) = a5;
  *(unsigned char *)(v6 + 64) = 0;
  return (*(uint64_t (**)(void))(**(void **)(v6 + 16) + 40))();
}

uint64_t RB::Path::Mapper::cubeto(uint64_t a1, float64x2_t a2, float64x2_t a3, float64x2_t a4)
{
  *(float64x2_t *)(a1 + 336) = a4;
  *(unsigned char *)(a1 + 368) = 0;
  unint64_t v4 = *(float64x2_t **)(a1 + 320);
  if (v4)
  {
    float64x2_t v5 = v4[1];
    a2 = vmlaq_laneq_f64(vmlaq_n_f64(v4[2], *v4, a2.f64[0]), v5, a2, 1);
    a3 = vmlaq_laneq_f64(vmlaq_n_f64(v4[2], *v4, a3.f64[0]), v5, a3, 1);
    a4 = vmlaq_laneq_f64(vmlaq_n_f64(v4[2], *v4, a4.f64[0]), v5, a4, 1);
  }
  return (*(uint64_t (**)(__n128, __n128, __n128))(**(void **)(a1 + 312) + 40))((__n128)a2, (__n128)a3, (__n128)a4);
}

void RBPathCopyCGPath::Accumulator::cubeto(uint64_t a1, __n128 a2, __n128 a3, __n128 a4)
{
}

uint64_t RB::Path::Mapper::elt_lineto(__n128 *a1, float64x2_t *a2, float64x2_t a3)
{
  if (a2) {
    a3 = vmlaq_laneq_f64(vmlaq_n_f64(a2[2], *a2, a3.f64[0]), a2[1], a3, 1);
  }
  unsigned int v3 = (__n128 *)a1[20].n128_u64[1];
  if (v3)
  {
    v3[2] = (__n128)a3;
    v3[4].n128_u8[0] = 0;
    unint64_t v5 = v3[1].n128_u64[0];
  }
  else
  {
    a1[21] = (__n128)a3;
    a1[23].n128_u8[0] = 0;
    unint64_t v4 = (float64x2_t *)a1[20].n128_u64[0];
    if (v4) {
      a3 = vmlaq_laneq_f64(vmlaq_n_f64(v4[2], *v4, a3.f64[0]), v4[1], a3, 1);
    }
    unint64_t v5 = a1[19].n128_u64[1];
  }
  return (*(uint64_t (**)(__n128))(*(void *)v5 + 24))((__n128)a3);
}

uint64_t RBPathApplyShape::$_0::__invoke<void *,RBPathElement,double const*,void const*>(void *a1, int a2, long long *a3, uint64_t *a4)
{
  switch(a2)
  {
    case 5:
    case 6:
    case 7:
      long long v5 = a3[1];
      long long v32 = *a3;
      long long v33 = v5;
      if (a4)
      {
        long long v6 = *((_OWORD *)a4 + 1);
        long long v29 = *(_OWORD *)a4;
        long long v30 = v6;
        long long v7 = *((_OWORD *)a4 + 2);
      }
      else
      {
        long long v15 = *(_OWORD *)(MEMORY[0x263F000D0] + 16);
        long long v29 = *MEMORY[0x263F000D0];
        long long v30 = v15;
        long long v7 = *(_OWORD *)(MEMORY[0x263F000D0] + 32);
      }
      long long v31 = v7;
      ((void (*)(void, BOOL, long long *))a1[1])(*a1, a2 == 7, &v29);
      goto LABEL_26;
    case 8:
    case 9:
      long long v8 = a3[1];
      long long v32 = *a3;
      long long v33 = v8;
      long long v34 = a3[2];
      LODWORD(v35) = a2 != 8;
      if (a4)
      {
        long long v9 = *((_OWORD *)a4 + 1);
        long long v29 = *(_OWORD *)a4;
        long long v30 = v9;
        long long v10 = *((_OWORD *)a4 + 2);
      }
      else
      {
        long long v25 = *(_OWORD *)(MEMORY[0x263F000D0] + 16);
        long long v29 = *MEMORY[0x263F000D0];
        long long v30 = v25;
        long long v10 = *(_OWORD *)(MEMORY[0x263F000D0] + 32);
      }
      long long v31 = v10;
      ((void (*)(void, uint64_t, long long *))a1[1])(*a1, 3, &v29);
      goto LABEL_26;
    case 10:
    case 11:
      long long v11 = a3[1];
      long long v32 = *a3;
      long long v33 = v11;
      long long v12 = a3[3];
      long long v34 = a3[2];
      long long v35 = v12;
      BOOL v36 = a2 != 10;
      if (a4)
      {
        long long v13 = *((_OWORD *)a4 + 1);
        long long v29 = *(_OWORD *)a4;
        long long v30 = v13;
        long long v14 = *((_OWORD *)a4 + 2);
      }
      else
      {
        long long v24 = *(_OWORD *)(MEMORY[0x263F000D0] + 16);
        long long v29 = *MEMORY[0x263F000D0];
        long long v30 = v24;
        long long v14 = *(_OWORD *)(MEMORY[0x263F000D0] + 32);
      }
      long long v31 = v14;
      ((void (*)(void, uint64_t, long long *))a1[1])(*a1, 4, &v29);
      goto LABEL_26;
    case 17:
      if (a4)
      {
        long long v16 = *((_OWORD *)a4 + 1);
        long long v30 = *(_OWORD *)a4;
        long long v31 = v16;
        long long v17 = *((_OWORD *)a4 + 2);
      }
      else
      {
        long long v26 = *(_OWORD *)(MEMORY[0x263F000D0] + 16);
        long long v30 = *MEMORY[0x263F000D0];
        long long v31 = v26;
        long long v17 = *(_OWORD *)(MEMORY[0x263F000D0] + 32);
      }
      long long v32 = v17;
      v39.info = (void *)a1[2];
      v39.callbacks = (RBPathCallbacks *)a1[3];
      *(void *)&long long v29 = RBPathGetNestedPath(v39);
      *((void *)&v29 + 1) = v27;
      ((void (*)(void, uint64_t, long long *))a1[1])(*a1, 5, &v29);
      goto LABEL_26;
    case 18:
      long long v30 = *a3;
      v37.info = (void *)a1[2];
      v37.callbacks = (RBPathCallbacks *)a1[3];
      *(void *)&long long v29 = RBPathGetNestedPath(v37);
      *((void *)&v29 + 1) = v18;
      ((void (*)(void, uint64_t, long long *))a1[1])(*a1, 7, &v29);
      goto LABEL_26;
    case 19:
      if (a4) {
        double v19 = a4;
      }
      else {
        double v19 = (uint64_t *)&default_stroke_transform;
      }
      uint64_t v20 = *v19;
      *(void *)&long long v30 = *(void *)a3;
      *((void *)&v30 + 1) = v20;
      long long v31 = *(long long *)((char *)a3 + 8);
      uint64_t v21 = v19[1];
      if (!v21 || (uint64_t v22 = (void *)v19[2]) == 0)
      {
        uint64_t v21 = 0;
        uint64_t v22 = &_ZZZ16RBPathApplyShapeENK3__0clIPv13RBPathElementPKdPKvEEDaT_T0_T1_T2_E4zero;
      }
      *(void *)&long long v32 = v21;
      *((void *)&v32 + 1) = v22;
      v38.info = (void *)a1[2];
      v38.callbacks = (RBPathCallbacks *)a1[3];
      *(void *)&long long v29 = RBPathGetNestedPath(v38);
      *((void *)&v29 + 1) = v23;
      ((void (*)(void, uint64_t, long long *))a1[1])(*a1, 6, &v29);
LABEL_26:
      *((unsigned char *)a1 + 32) = 1;
      break;
    default:
      return 0;
  }
  return 0;
}

float32x2_t RB::Path::BoundingRect::cubeto(float32x2_t *a1, float64x2_t a2, float64x2_t a3, float64x2_t a4, double a5, double a6, int32x4_t a7, int32x4_t a8, int32x4_t a9)
{
  float32x2_t v10 = vcvt_f32_f64(a2);
  float32x2_t v11 = vcvt_f32_f64(a3);
  float32x2_t v12 = vcvt_f32_f64(a4);
  *(float32x2_t *)&a4.f64[0] = a1[3];
  double v14 = COERCE_DOUBLE(vminnm_f32(*(float32x2_t *)&a4.f64[0], v12));
  float32x2_t v15 = vmaxnm_f32(*(float32x2_t *)&a4.f64[0], v12);
  *(int32x2_t *)a8.i8 = vcge_f32(v15, vmaxnm_f32(v10, v11));
  uint32x2_t v16 = (uint32x2_t)vand_s8(*(int8x8_t *)a8.i8, (int8x8_t)vcge_f32(vminnm_f32(v10, v11), *(float32x2_t *)&v14));
  *(uint32x2_t *)a7.i8 = vpmin_u32(v16, v16);
  if ((a7.i32[0] & 0x80000000) == 0) {
    double v14 = RB::Path::cubic_bounds_slow(a1[3], v10, v11, v12, (int32x4_t)a4, a7, a8, a9);
  }
  float32x2_t result = vminnm_f32(a1[1], *(float32x2_t *)&v14);
  float32x2_t v18 = vmaxnm_f32(a1[2], v15);
  a1[1] = result;
  a1[2] = v18;
  a1[3] = v12;
  return result;
}

void *RBPathGetNestedPath(RBPath a1)
{
  info = a1.info;
  if (*((unsigned char *)a1.callbacks + 2))
  {
    uint64_t v2 = (uint64_t (*)(void *))*((void *)a1.callbacks + 10);
    if (v2) {
      return (void *)v2(a1.info);
    }
LABEL_5:
    RB::Path::NestedCallbacks::get((RB::Path::NestedCallbacks *)a1.callbacks, (const RBPathCallbacks *)1);
    return info;
  }
  uint64_t v2 = (uint64_t (*)(void *))*((void *)a1.callbacks + 10);
  if (!v2) {
    goto LABEL_5;
  }
  return (void *)v2(a1.info);
}

uint64_t RB::Path::Mapper::elt_moveto(__n128 *a1, float64x2_t *a2, float64x2_t a3)
{
  if (a2) {
    a3 = vmlaq_laneq_f64(vmlaq_n_f64(a2[2], *a2, a3.f64[0]), a2[1], a3, 1);
  }
  unsigned int v3 = (__n128 *)a1[20].n128_u64[1];
  if (v3)
  {
    v3[2] = (__n128)a3;
    v3[4].n128_u8[0] = 0;
    unint64_t v5 = v3[1].n128_u64[0];
  }
  else
  {
    a1[21] = (__n128)a3;
    a1[23].n128_u8[0] = 0;
    unint64_t v4 = (float64x2_t *)a1[20].n128_u64[0];
    if (v4) {
      a3 = vmlaq_laneq_f64(vmlaq_n_f64(v4[2], *v4, a3.f64[0]), v4[1], a3, 1);
    }
    unint64_t v5 = a1[19].n128_u64[1];
  }
  return (*(uint64_t (**)(__n128))(*(void *)v5 + 16))((__n128)a3);
}

uint64_t RB::Path::AffineTransformer::cubeto(uint64_t a1, float64x2_t a2, float64x2_t a3, float64x2_t a4)
{
  return (*(uint64_t (**)(void, __n128, __n128, __n128))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8), (__n128)vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 48), *(float64x2_t *)(a1 + 16), a2.f64[0]), *(float64x2_t *)(a1 + 32), a2, 1), (__n128)vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 48), *(float64x2_t *)(a1 + 16), a3.f64[0]), *(float64x2_t *)(a1 + 32), a3, 1), (__n128)vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 48), *(float64x2_t *)(a1 + 16), a4.f64[0]), *(float64x2_t *)(a1 + 32), a4, 1));
}

void RBPathCopyCGPath::Accumulator::lineto(uint64_t a1, __n128 a2)
{
}

uint64_t RB::Path::Mapper::elt_closepath(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 328);
  if (!v1)
  {
    uint64_t v2 = this;
    if (*(unsigned char *)(this + 368)) {
      return this;
    }
    unsigned int v3 = (unsigned char *)(this + 368);
    this = (*(uint64_t (**)(void))(**(void **)(this + 312) + 8))(*(void *)(this + 312));
    *(_OWORD *)(v2 + 336) = *(_OWORD *)(v2 + 352);
    goto LABEL_4;
  }
  unsigned int v3 = (unsigned char *)(v1 + 64);
  if (!*(unsigned char *)(v1 + 64))
  {
    *(_OWORD *)(v1 + 32) = *(_OWORD *)(v1 + 48);
    this = (*(uint64_t (**)(void))(**(void **)(v1 + 16) + 8))(*(void *)(v1 + 16));
LABEL_4:
    *unsigned int v3 = 1;
  }
  return this;
}

void anonymous namespace'::ShapeBounds::apply_shape_callback(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (a2 <= 6)
  {
    uint64_t v42 = v8;
    uint64_t v43 = v7;
    uint64_t v44 = v6;
    uint64_t v45 = v5;
    uint64_t v46 = v3;
    uint64_t v47 = v4;
    if (((1 << a2) & 0x1B) != 0)
    {
      long long v11 = *(_OWORD *)(a3 + 16);
      long long v12 = *(_OWORD *)(a3 + 32);
      float64x2_t v36 = *(float64x2_t *)a3;
      long long v37 = v11;
      *(_OWORD *)RBPath v38 = v12;
      v13.f64[0] = RB::operator*(&v36, (float64x2_t *)a1);
      *(float64x2_t *)a1 = v13;
      *(float64x2_t *)(a1 + 16) = v14;
      *(float64x2_t *)(a1 + 32) = v15;
      int64x2_t v16 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v14, (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(v13, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v15));
      if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v16, 1), (int8x16_t)v16).u64[0] & 0x8000000000000000) != 0)
      {
        long long v30 = *(_OWORD *)(a3 + 64);
        *(_OWORD *)(a1 + 48) = *(_OWORD *)(a3 + 48);
        *(_OWORD *)(a1 + 64) = v30;
LABEL_11:
        *(unsigned char *)(a1 + 80) = 1;
        return;
      }
      CGFloat v18 = *(double *)(a3 + 48);
      CGFloat v17 = *(double *)(a3 + 56);
      CGFloat v19 = *(double *)(a3 + 64);
      v48.size.height = *(CGFloat *)(a3 + 72);
      *(float64x2_t *)&v41.a = v13;
      *(float64x2_t *)&v41.c = v14;
      *(float64x2_t *)&v41.tx = v15;
      v48.origin.x = v18;
      v48.origin.y = v17;
      v48.size.width = v19;
      CGRect v49 = CGRectApplyAffineTransform(v48, &v41);
LABEL_10:
      *(CGRect *)(a1 + 48) = v49;
      goto LABEL_11;
    }
    if (a2 == 5)
    {
      long long v31 = *(_OWORD *)(a3 + 32);
      long long v32 = *(_OWORD *)(a3 + 48);
      float64x2_t v36 = *(float64x2_t *)(a3 + 16);
      long long v37 = v31;
      *(_OWORD *)RBPath v38 = v32;
      *(double *)&long long v33 = RB::operator*(&v36, (float64x2_t *)a1);
      *(_OWORD *)a1 = v33;
      *(_OWORD *)(a1 + 16) = v34;
      *(_OWORD *)(a1 + 32) = v35;
      RBPathBoundingRect(*(RBPath *)a3, (const RB::AffineTransform *)a1);
      goto LABEL_10;
    }
    if (a2 == 6)
    {
      float v20 = *(double *)(a3 + 16);
      char v21 = rb_line_cap(*(_DWORD *)(a3 + 24));
      char v22 = rb_line_join((CGLineJoin)*(_DWORD *)(a3 + 28));
      double v23 = *(double *)(a3 + 32);
      *(void *)&v36.f64[0] = &unk_26C4EDBA0;
      *(float *)&v36.f64[1] = v20 * (float)(0.5 * RB::AffineTransform::scale((float64x2_t *)a1));
      float v24 = v23;
      LOBYTE(v37) = v21;
      BYTE1(v37) = v22;
      *((float *)&v37 + 1) = v24 * v24;
      *((int32x2_t *)&v37 + 1) = vdup_n_s32(0x7F800000u);
      *(void *)RBPath v38 = 0x7F0000007FLL;
      memset(&v38[8], 0, 40);
      char v39 = 1;
      int v40 = 0;
      RBPathMap(*(CGPathRef *)a3, *(void **)(a3 + 8), &v36, (float64x2_t *)a1);
      *(void *)(a1 + 48) = *(_OWORD *)&RB::Stroke::FixedWidthLineBounds::operator CGRect((float32x2_t *)&v36, v25, v26);
      *(void *)(a1 + 56) = v27;
      *(void *)(a1 + 64) = v28;
      *(void *)(a1 + 72) = v29;
      *(unsigned char *)(a1 + 80) = 1;
    }
  }
}

void RB::Stroke::FixedWidthLineBounds::cubeto(uint64_t a1, float64x2_t a2, float64x2_t a3, float64x2_t a4, double a5, int32x4_t a6, int32x4_t a7, int32x4_t a8, int32x4_t a9)
{
}

void RB::Stroke::LineBounds::cubeto(uint64_t a1, float32x2_t a2, float32x2_t a3, float32x2_t a4, float a5, int32x4_t a6, int32x4_t a7, int32x4_t a8, int32x4_t a9)
{
  double v14 = *(double *)(a1 + 24);
  double v15 = COERCE_DOUBLE(vsub_f32(a2, *(float32x2_t *)&v14));
  double v16 = COERCE_DOUBLE(vmul_f32(*(float32x2_t *)&v15, *(float32x2_t *)&v15));
  if (vaddv_f32(*(float32x2_t *)&v16) < 0.00001)
  {
    double v17 = COERCE_DOUBLE(vsub_f32(a3, *(float32x2_t *)&v14));
    double v15 = COERCE_DOUBLE(vsub_f32(a4, *(float32x2_t *)&v14));
    if (vaddv_f32(vmul_f32(*(float32x2_t *)&v17, *(float32x2_t *)&v17)) >= 0.00001) {
      double v15 = v17;
    }
  }
  double v18 = COERCE_DOUBLE(vsub_f32(a4, a3));
  if (vaddv_f32(vmul_f32(*(float32x2_t *)&v18, *(float32x2_t *)&v18)) < 0.00001)
  {
    double v19 = COERCE_DOUBLE(vsub_f32(a4, a2));
    double v16 = COERCE_DOUBLE(vsub_f32(a4, *(float32x2_t *)&v14));
    if (vaddv_f32(vmul_f32(*(float32x2_t *)&v19, *(float32x2_t *)&v19)) < 0.00001) {
      double v18 = v16;
    }
    else {
      double v18 = v19;
    }
  }
  if (*(unsigned char *)(a1 + 64))
  {
    *(double *)(a1 + 40) = v15;
    *(unsigned char *)(a1 + 64) = 0;
  }
  else
  {
    LODWORD(v16) = *(_DWORD *)(a1 + 56);
    RB::Stroke::LineBounds::add_join((float32x2_t *)a1, *(float32x2_t *)&v14, v16, *(float32x2_t *)(a1 + 48), *(float32x2_t *)&v15);
    double v14 = *(double *)(a1 + 24);
  }
  float32x2_t v20 = vminnm_f32(*(float32x2_t *)&v14, a4);
  float32x2_t v21 = vmaxnm_f32(*(float32x2_t *)&v14, a4);
  *(int32x2_t *)a6.i8 = vcge_f32(v21, vmaxnm_f32(a2, a3));
  uint32x2_t v22 = (uint32x2_t)vand_s8(*(int8x8_t *)a6.i8, (int8x8_t)vcge_f32(vminnm_f32(a2, a3), v20));
  if ((vpmin_u32(v22, v22).u32[0] & 0x80000000) == 0)
  {
    double v14 = RB::Path::cubic_bounds_slow(*(float32x2_t *)&v14, a2, a3, a4, a6, a7, a8, a9);
    float32x2_t v20 = *(float32x2_t *)&v14;
  }
  LODWORD(v14) = *(_DWORD *)(a1 + 56);
  if (*(float *)&v14 < a5) {
    *(float *)&double v14 = a5;
  }
  float32x2_t v23 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v14, 0);
  float32x2_t v24 = vminnm_f32(*(float32x2_t *)(a1 + 8), vsub_f32(v20, v23));
  float32x2_t v25 = vmaxnm_f32(*(float32x2_t *)(a1 + 16), vadd_f32(v23, v21));
  *(float32x2_t *)(a1 + 8) = v24;
  *(float32x2_t *)(a1 + 16) = v25;
  *(double *)(a1 + 24) = *(double *)&a4;
  *(float *)(a1 + 56) = a5;
  *(double *)(a1 + 48) = v18;
  float v26 = *(float *)(a1 + 68);
  if (v26 < a5) {
    float v26 = a5;
  }
  *(float *)(a1 + 68) = v26;
}

float32x2_t RB::Stroke::LineBounds::add_point(float32x2_t *a1, float32x2_t a2, double a3)
{
  float32x2_t v5 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 0);
  float32x2_t v6 = vsub_f32(a2, v5);
  float32x2_t v7 = vadd_f32(v5, a2);
  if (*(float *)&a3 > 0.0)
  {
    if (vmvn_s8((int8x8_t)vcgt_f32(a2, v6)).u8[0])
    {
      float32x2_t v16 = v7;
      __int32 v23 = v6.i32[1];
      float32x2_t v14 = a2;
      float v11 = nextafterf(v6.f32[0], -INFINITY);
      a2 = v14;
      float32x2_t v7 = v16;
      float32x2_t v6 = (float32x2_t)__PAIR64__(v23, LODWORD(v11));
    }
    float v8 = a2.f32[1];
    if (v6.f32[1] >= a2.f32[1])
    {
      float32x2_t v17 = v7;
      __int32 v20 = v6.i32[0];
      float32x2_t v15 = a2;
      float v12 = nextafterf(v6.f32[1], -INFINITY);
      a2 = v15;
      float32x2_t v7 = v17;
      float32x2_t v6 = (float32x2_t)__PAIR64__(LODWORD(v12), v20);
    }
    if (vmvn_s8((int8x8_t)vcgt_f32(v7, a2)).u8[0])
    {
      __int32 v19 = v7.i32[1];
      float32x2_t v21 = v6;
      float v13 = nextafterf(v7.f32[0], INFINITY);
      float32x2_t v6 = v21;
      float32x2_t v7 = (float32x2_t)__PAIR64__(v19, LODWORD(v13));
    }
    if (v7.f32[1] <= v8)
    {
      __int32 v18 = v7.i32[0];
      float32x2_t v22 = v6;
      float32x2_t v7 = (float32x2_t)__PAIR64__(COERCE_UNSIGNED_INT(nextafterf(v7.f32[1], INFINITY)), v18);
      float32x2_t v6 = v22;
    }
  }
  float32x2_t result = vminnm_f32(a1[1], v6);
  float32x2_t v10 = vmaxnm_f32(a1[2], v7);
  a1[1] = result;
  a1[2] = v10;
  return result;
}

float32x2_t RB::Stroke::LineBounds::add_join(float32x2_t *a1, float32x2_t a2, double a3, float32x2_t a4, float32x2_t a5)
{
  if (a1->i8[1])
  {
    if (a1->i8[1] == 2)
    {
      float32x2_t v5 = vmul_f32(a4, a4);
      v5.i32[0] = vadd_f32(v5, (float32x2_t)vdup_lane_s32((int32x2_t)v5, 1)).u32[0];
      float32x2_t v6 = vrsqrte_f32((float32x2_t)v5.u32[0]);
      float32x2_t v7 = vmul_f32(vrsqrts_f32((float32x2_t)v5.u32[0], vmul_f32(v6, v6)), v6);
      v5.i32[0] = vmul_f32(v7, vrsqrts_f32((float32x2_t)v5.u32[0], vmul_f32(v7, v7))).u32[0];
      float32x2_t v8 = vmul_f32(a5, a5);
      int32x2_t v9 = (int32x2_t)vmul_n_f32(a4, v5.f32[0]);
      v5.i32[0] = vadd_f32(v8, (float32x2_t)vdup_lane_s32((int32x2_t)v8, 1)).u32[0];
      float32x2_t v10 = vrsqrte_f32((float32x2_t)v5.u32[0]);
      float32x2_t v11 = vmul_f32(vrsqrts_f32((float32x2_t)v5.u32[0], vmul_f32(v10, v10)), v10);
      int32x2_t v12 = (int32x2_t)vmul_f32(v11, vrsqrts_f32((float32x2_t)v5.u32[0], vmul_f32(v11, v11)));
      int32x2_t v13 = (int32x2_t)vmul_n_f32(a5, *(float *)v12.i32);
      *(float *)v12.i32 = -*(float *)&v9.i32[1];
      float32x2_t v14 = vmul_n_f32((float32x2_t)vzip1_s32(v12, v9), *(float *)&a3);
      float32x2_t v15 = vsub_f32(a2, v14);
      float32x2_t v16 = vminnm_f32(a1[1], v15);
      float32x2_t v17 = vmaxnm_f32(a1[2], v15);
      float32x2_t v18 = vadd_f32(v14, a2);
      float32x2_t v19 = vminnm_f32(v16, v18);
      float32x2_t v20 = vmaxnm_f32(v17, v18);
      v17.f32[0] = -*(float *)&v13.i32[1];
      float32x2_t v21 = vmul_n_f32((float32x2_t)vzip1_s32((int32x2_t)v17, v13), *(float *)&a3);
      float32x2_t v22 = vsub_f32(a2, v21);
      float32x2_t v23 = vadd_f32(v21, a2);
      float32x2_t v24 = vminnm_f32(vminnm_f32(v19, v22), v23);
      float32x2_t result = vmaxnm_f32(vmaxnm_f32(v20, v22), v23);
      a1[1] = v24;
      a1[2] = result;
      return result;
    }
  }
  else
  {
    float32x2_t v26 = vmul_f32(a4, a4);
    v26.i32[0] = vadd_f32(v26, (float32x2_t)vdup_lane_s32((int32x2_t)v26, 1)).u32[0];
    float32x2_t v27 = vrsqrte_f32((float32x2_t)v26.u32[0]);
    float32x2_t v28 = vmul_f32(vrsqrts_f32((float32x2_t)v26.u32[0], vmul_f32(v27, v27)), v27);
    float32x2_t v29 = vmul_n_f32(a4, vmul_f32(v28, vrsqrts_f32((float32x2_t)v26.u32[0], vmul_f32(v28, v28))).f32[0]);
    float32x2_t v30 = vmul_f32(a5, a5);
    v30.i32[0] = vadd_f32(v30, (float32x2_t)vdup_lane_s32((int32x2_t)v30, 1)).u32[0];
    float32x2_t v31 = vrsqrte_f32((float32x2_t)v30.u32[0]);
    float32x2_t v32 = vmul_f32(vrsqrts_f32((float32x2_t)v30.u32[0], vmul_f32(v31, v31)), v31);
    float32x2_t v33 = vmul_n_f32(a5, vmul_f32(v32, vrsqrts_f32((float32x2_t)v30.u32[0], vmul_f32(v32, v32))).f32[0]);
    float v34 = vaddv_f32(vmul_f32(v33, v29));
    if (v34 < 0.99 && fabsf(v34) > 0.00001)
    {
      float v35 = v34 + 1.0;
      if ((float)(a1->f32[1] * v35) >= 2.0)
      {
        float v36 = v35;
        float32x2_t v37 = vrsqrte_f32((float32x2_t)LODWORD(v35));
        float32x2_t v38 = vmul_f32(vrsqrts_f32((float32x2_t)LODWORD(v36), vmul_f32(v37, v37)), v37);
        v38.f32[0] = vmul_f32(v38, vrsqrts_f32((float32x2_t)LODWORD(v36), vmul_f32(v38, v38))).f32[0];
        float32x2_t v39 = vadd_f32(v33, v29);
        float32x2_t v40 = vmul_f32(v39, v39);
        v40.i32[0] = vadd_f32(v40, (float32x2_t)vdup_lane_s32((int32x2_t)v40, 1)).u32[0];
        float32x2_t v41 = vrsqrte_f32((float32x2_t)v40.u32[0]);
        float32x2_t v42 = vmul_f32(vrsqrts_f32((float32x2_t)v40.u32[0], vmul_f32(v41, v41)), v41);
        int32x2_t v43 = (int32x2_t)vmul_f32(v42, vrsqrts_f32((float32x2_t)v40.u32[0], vmul_f32(v42, v42)));
        int32x2_t v44 = (int32x2_t)vmul_n_f32(v39, *(float *)v43.i32);
        *(float *)v43.i32 = -*(float *)&v44.i32[1];
        float32x2_t v45 = vmul_n_f32((float32x2_t)vzip1_s32(v43, v44), (float)(*(float *)&a3 * 1.4142) * v38.f32[0]);
        float32x2_t v46 = vsub_f32(a2, v45);
        float32x2_t v47 = vadd_f32(v45, a2);
        float32x2_t v48 = vminnm_f32(a1[1], vminnm_f32(v46, v47));
        float32x2_t v49 = vmaxnm_f32(a1[2], vmaxnm_f32(v46, v47));
        a1[1] = v48;
        a1[2] = v49;
      }
    }
  }
  return RB::Stroke::LineBounds::add_point(a1, a2, a3);
}

RB::Path::NestedCallbacks *RB::Path::NestedCallbacks::get(RB::Path::NestedCallbacks *this, const RBPathCallbacks *a2)
{
  {
    operator new();
  }
  uint64_t v4 = (os_unfair_lock_s *)(RB::Path::NestedCallbacks::get(RBPathCallbacks const*,unsigned long)::table + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(RB::Path::NestedCallbacks::get(RBPathCallbacks const*,unsigned long)::table + 24));
  float32x2_t v5 = *(RB::Path::NestedCallbacks ***)RB::Path::NestedCallbacks::get(RBPathCallbacks const*,unsigned long)::table;
  unint64_t v6 = *(void *)(RB::Path::NestedCallbacks::get(RBPathCallbacks const*,unsigned long)::table + 8);
  uint64_t v7 = *(void *)RB::Path::NestedCallbacks::get(RBPathCallbacks const*,unsigned long)::table + 24 * v6;
  if (!v6) {
    goto LABEL_21;
  }
  do
  {
    unint64_t v8 = v6 >> 1;
    int32x2_t v9 = &v5[3 * (v6 >> 1)];
    if (*v9 >= this) {
      char v10 = 1;
    }
    else {
      char v10 = -1;
    }
    if (*v9 == this)
    {
      float32x2_t v11 = (const RBPathCallbacks *)v9[1];
      BOOL v12 = v11 == a2;
      char v10 = v11 >= a2 ? 1 : -1;
      if (v12) {
        char v10 = 0;
      }
    }
    int32x2_t v13 = v9 + 3;
    v6 += ~v8;
    if (v10 < 0) {
      float32x2_t v5 = v13;
    }
    else {
      unint64_t v6 = v8;
    }
  }
  while (v6);
  if (v5 == (RB::Path::NestedCallbacks **)v7
    || (*v5 == this ? (BOOL v14 = v5[1] == (RB::Path::NestedCallbacks *)a2) : (BOOL v14 = 0), !v14))
  {
LABEL_21:
    operator new();
  }
  float32x2_t v16 = v5[2];
  os_unfair_lock_unlock(v4);
  return v16;
}

void RB::Stroke::LineBounds::lineto(float32x2_t *a1, float32x2_t a2, double a3)
{
  float v3 = *(float *)&a3;
  float32x2_t v6 = a1[3];
  float32x2_t v7 = vsub_f32(a2, v6);
  if (a1[8].i8[0])
  {
    a1[5] = v7;
    a1[8].i8[0] = 0;
  }
  else
  {
    LODWORD(a3) = a1[7].i32[0];
    RB::Stroke::LineBounds::add_join(a1, v6, a3, a1[6], v7);
  }
  a1[3] = a2;
  a1[7].f32[0] = v3;
  a1[6] = v7;
  float v8 = a1[8].f32[1];
  if (v8 < v3) {
    float v8 = v3;
  }
  a1[8].f32[1] = v8;
}

void RB::Stroke::FixedWidthLineBounds::lineto(float32x2_t *a1, float64x2_t a2, double a3)
{
  LODWORD(a3) = a1[1].i32[0];
  RB::Stroke::LineBounds::lineto(a1 + 2, vcvt_f32_f64(a2), a3);
}

uint64_t RB::Path::Mapper::lineto(uint64_t a1, float64x2_t a2)
{
  *(float64x2_t *)(a1 + 336) = a2;
  *(unsigned char *)(a1 + 368) = 0;
  uint64_t v2 = *(float64x2_t **)(a1 + 320);
  if (v2) {
    a2 = vmlaq_laneq_f64(vmlaq_n_f64(v2[2], *v2, a2.f64[0]), v2[1], a2, 1);
  }
  return (*(uint64_t (**)(__n128))(**(void **)(a1 + 312) + 24))((__n128)a2);
}

uint64_t RB::Path::AffineTransformer::lineto(uint64_t a1, float64x2_t a2)
{
  return (*(uint64_t (**)(void, __n128))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8), (__n128)vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 48), *(float64x2_t *)(a1 + 16), a2.f64[0]), *(float64x2_t *)(a1 + 32), a2, 1));
}

uint64_t anonymous namespace'::make_wrapped_path<RBPathCopyTransformedPath::TransformArgs>(RBPath,RBPathCopyTransformedPath::TransformArgs &&)::{lambda(void const*)#5}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

float64x2_t RB::Stroke::FixedWidthLineBounds::operator CGRect(float32x2_t *a1, double a2, int32x4_t a3)
{
  float32x2_t v3 = a1[3];
  *(float32x2_t *)a3.i8 = a1[4];
  uint32x2_t v4 = (uint32x2_t)vcgt_f32(*(float32x2_t *)a3.i8, v3);
  if ((vpmin_u32(v4, v4).u32[0] & 0x80000000) != 0) {
    return vcvtq_f64_f32(COERCE_FLOAT32X2_T(RB::Rect::from_bounds(v3, a3)));
  }
  else {
    return *(float64x2_t *)MEMORY[0x263F001A0];
  }
}

float RB::AffineTransform::scale(float64x2_t *this)
{
  float64x2_t v1 = *this;
  float64x2_t v2 = this[1];
  double v3 = this[1].f64[1];
  double v4 = this->f64[1];
  if (this->f64[0] == v3 && v4 == 0.0 && v2.f64[0] == 0.0
    || v3 == 0.0 && (v1.f64[0] == 0.0 ? (BOOL v5 = v4 == v2.f64[0]) : (BOOL v5 = 0), v5))
  {
    double v6 = fabs(v1.f64[0]);
    double v7 = fabs(v4);
    if (v4 != 0.0) {
      return v7;
    }
    return v6;
  }
  else
  {
    int64x2_t v9 = (int64x2_t)vmulq_f64(v1, v1);
    int64x2_t v10 = (int64x2_t)vmulq_f64(v2, v2);
    float32x2_t v11 = vcvt_f32_f64(vaddq_f64((float64x2_t)vzip1q_s64(v10, v9), (float64x2_t)vzip2q_s64(v10, v9)));
    float result = 1.0;
    if (v11.f32[1] != 1.0 || v11.f32[0] != 1.0) {
      return vaddv_f32(vsqrt_f32(v11)) * 0.5;
    }
  }
  return result;
}

uint64_t rb_line_join(CGLineJoin a1)
{
  if (a1 == kCGLineJoinBevel) {
    return 2;
  }
  else {
    return a1 != kCGLineJoinMiter;
  }
}

uint64_t rb_line_cap(unsigned int a1)
{
  if (a1 > 6) {
    return 0;
  }
  else {
    return rb_line_cap(RBLineCap)::types[a1];
  }
}

{
  if (a1 > 6) {
    return 0;
  }
  else {
    return dword_214219DD0[(char)a1];
  }
}

void RB::Stroke::FixedWidthLineBounds::moveto(uint64_t a1, float64x2_t a2, double a3)
{
  LODWORD(a3) = *(_DWORD *)(a1 + 8);
  RB::Stroke::LineBounds::moveto(a1 + 16, COERCE_DOUBLE(vcvt_f32_f64(a2)), a3);
}

void RB::Stroke::LineBounds::moveto(uint64_t a1, double a2, double a3)
{
  float v3 = *(float *)&a3;
  if (!*(unsigned char *)(a1 + 64))
  {
    LODWORD(a3) = *(_DWORD *)(a1 + 60);
    RB::Stroke::LineBounds::add_cap((float32x2_t *)a1, 0, *(float32x2_t *)(a1 + 32), a3, *(int8x8_t *)(a1 + 40));
    LODWORD(v6) = *(_DWORD *)(a1 + 56);
    RB::Stroke::LineBounds::add_cap((float32x2_t *)a1, 1, *(float32x2_t *)(a1 + 24), v6, *(int8x8_t *)(a1 + 48));
    *(unsigned char *)(a1 + 64) = 1;
  }
  *(double *)(a1 + 24) = a2;
  *(double *)(a1 + 32) = a2;
  *(float *)(a1 + 56) = v3;
  *(float *)(a1 + 60) = v3;
  float v7 = *(float *)(a1 + 68);
  if (v7 < v3) {
    float v7 = v3;
  }
  *(float *)(a1 + 68) = v7;
}

float32x2_t RB::Path::BoundingRect::lineto(float32x2_t *a1, float64x2_t a2)
{
  float32x2_t result = vcvt_f32_f64(a2);
  float32x2_t v3 = vmaxnm_f32(a1[2], result);
  a1[1] = vminnm_f32(a1[1], result);
  a1[2] = v3;
  a1[3] = result;
  return result;
}

void RBPathCopyCGPath::Accumulator::moveto(uint64_t a1, __n128 a2)
{
}

void RBPathCopyCGPath::Accumulator::closepath(CGMutablePathRef *this)
{
}

float32x2_t RB::Path::BoundingRect::moveto(float32x2_t *a1, float64x2_t a2)
{
  float32x2_t result = vcvt_f32_f64(a2);
  float32x2_t v3 = vmaxnm_f32(a1[2], result);
  a1[1] = vminnm_f32(a1[1], result);
  a1[2] = v3;
  a1[3] = result;
  return result;
}

uint64_t RB::Path::Mapper::moveto(uint64_t a1, float64x2_t a2)
{
  *(float64x2_t *)(a1 + 336) = a2;
  *(unsigned char *)(a1 + 368) = 0;
  float64x2_t v2 = *(float64x2_t **)(a1 + 320);
  if (v2) {
    a2 = vmlaq_laneq_f64(vmlaq_n_f64(v2[2], *v2, a2.f64[0]), v2[1], a2, 1);
  }
  return (*(uint64_t (**)(__n128))(**(void **)(a1 + 312) + 16))((__n128)a2);
}

__n128 RB::Path::Mapper::closepath(RB::Path::Mapper *this)
{
  if (!*((unsigned char *)this + 368))
  {
    (*(void (**)(void))(**((void **)this + 39) + 8))(*((void *)this + 39));
    __n128 result = *((__n128 *)this + 22);
    *((__n128 *)this + 21) = result;
    *((unsigned char *)this + 368) = 1;
  }
  return result;
}

uint64_t RB::Path::AffineTransformer::closepath(RB::Path::AffineTransformer *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 8))();
}

uint64_t RB::Path::AffineTransformer::moveto(uint64_t a1, float64x2_t a2)
{
  return (*(uint64_t (**)(void, __n128))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), (__n128)vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 48), *(float64x2_t *)(a1 + 16), a2.f64[0]), *(float64x2_t *)(a1 + 32), a2, 1));
}

void RB::Coverage::anonymous namespace'::simplify_shape_callback(void (****a1)(void, uint64_t *), int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  switch(a2)
  {
    case 0:
    case 1:
      long long v9 = *(_OWORD *)(a3 + 16);
      long long v10 = *(_OWORD *)(a3 + 32);
      float64x2_t v56 = *(float64x2_t *)a3;
      long long v57 = v9;
      long long v58 = v10;
      *(double *)&long long v11 = RB::operator*(&v56, (float64x2_t *)a1 + 1);
      *((_OWORD *)a1 + 1) = v11;
      *((_OWORD *)a1 + 2) = v12;
      *((_OWORD *)a1 + 3) = v13;
      BOOL v14 = *(double *)&v11 == 0.0;
      if (*((double *)&v12 + 1) != 0.0) {
        BOOL v14 = 0;
      }
      if (*(double *)&v12 == 0.0 && *((double *)&v11 + 1) == 0.0 || v14)
      {
        float32x2_t v17 = (uint64_t (***)(void, uint64_t *))*a1;
        float32x2_t v18 = (float64x2_t *)(a3 + 48);
        char v19 = *((unsigned char *)a1 + 64);
        float v20 = *((double *)a1 + 9);
        float32x2_t v21 = (float64x2_t *)(a1 + 2);
        if (a2) {
        else
        }
        *((unsigned char *)a1 + 96) = 1;
      }
      break;
    case 3:
      long long v22 = *(_OWORD *)(a3 + 16);
      long long v23 = *(_OWORD *)(a3 + 32);
      float64x2_t v56 = *(float64x2_t *)a3;
      long long v57 = v22;
      long long v58 = v23;
      *(double *)&long long v24 = RB::operator*(&v56, (float64x2_t *)a1 + 1);
      *((_OWORD *)a1 + 1) = v24;
      *((_OWORD *)a1 + 2) = v25;
      *((_OWORD *)a1 + 3) = v26;
      BOOL v27 = *(double *)&v24 == 0.0;
      if (*((double *)&v25 + 1) != 0.0) {
        BOOL v27 = 0;
      }
      if (*(double *)&v25 == 0.0 && *((double *)&v24 + 1) == 0.0 || v27)
      {
        float v30 = *((double *)a1 + 9);
        goto LABEL_33;
      }
      break;
    case 4:
      long long v32 = *(_OWORD *)(a3 + 16);
      long long v33 = *(_OWORD *)(a3 + 32);
      float64x2_t v56 = *(float64x2_t *)a3;
      long long v57 = v32;
      long long v58 = v33;
      *(double *)&long long v34 = RB::operator*(&v56, (float64x2_t *)a1 + 1);
      *((_OWORD *)a1 + 1) = v34;
      *((_OWORD *)a1 + 2) = v35;
      *((_OWORD *)a1 + 3) = v36;
      BOOL v37 = *(double *)&v34 == 0.0;
      if (*((double *)&v35 + 1) != 0.0) {
        BOOL v37 = 0;
      }
      if (*(double *)&v35 == 0.0 && *((double *)&v34 + 1) == 0.0 || v37)
      {
        float v40 = *((double *)a1 + 9);
        goto LABEL_33;
      }
      break;
    case 5:
      long long v41 = *(_OWORD *)(a3 + 32);
      long long v42 = *(_OWORD *)(a3 + 48);
      float64x2_t v56 = *(float64x2_t *)(a3 + 16);
      long long v57 = v41;
      long long v58 = v42;
      *(double *)&long long v43 = RB::operator*(&v56, (float64x2_t *)a1 + 1);
      *((_OWORD *)a1 + 1) = v43;
      *((_OWORD *)a1 + 2) = v44;
      *((_OWORD *)a1 + 3) = v45;
      break;
    case 6:
      if (*((unsigned __int8 *)a1 + 64) <= 1u)
      {
        a1[10] = (void (***)(void, uint64_t *))a3;
        double v46 = *(double *)(a3 + 16);
        if (v46 <= 0.0)
        {
          long long v55 = (void (***)(void, float64x2_t *, uint64_t, uint64_t, uint64_t, uint64_t))*a1;
          float64x2_t v56 = 0u;
          long long v57 = 0u;
          LODWORD(v58) = 1065353216;
          *(void *)((char *)&v58 + 4) = 0;
          BYTE12(v58) = 0;
          *(_WORD *)((char *)&v58 + 13) = 1;
          (**v55)(v55, &v56, a3, a4, a5, a6);
          *((unsigned char *)a1 + 96) = 1;
        }
        else
        {
          if (!*(void *)(a3 + 48))
          {
            if ((long long v47 = *((_OWORD *)a1 + 1),
                  long long v48 = *((_OWORD *)a1 + 2),
                  double v49 = *((double *)a1 + 5),
                  double v50 = *((double *)a1 + 3),
                  *(double *)&v47 == v49)
              && v50 == 0.0
              && *(double *)&v48 == 0.0
              || v49 == 0.0 && (*(double *)&v47 == 0.0 ? (BOOL v51 = v50 == *(double *)&v48) : (BOOL v51 = 0), v51))
            {
              double v52 = fabs(*(double *)&v47);
              double v53 = fabs(v50);
              if (v50 != 0.0) {
                double v52 = v53;
              }
              float v54 = v52;
              *((double *)a1 + 11) = v46 * v54;
            }
          }
          if (!*((unsigned char *)a1 + 96))
          {
LABEL_33:
            *((unsigned char *)a1 + 96) = v31;
          }
        }
      }
      break;
    default:
      return;
  }
}

double RB::DisplayList::Layer::compute_bounds_(RB::DisplayList::Layer *this, int32x2_t *a2)
{
  long long v20 = 0uLL;
  if ((*((_WORD *)this + 30) & 0x2001) != 0)
  {
    if (a2)
    {
      int32x2_t v3 = a2[1];
      uint32x2_t v4 = (uint32x2_t)vceq_s32(v3, (int32x2_t)0x8000000080000000);
      if ((vpmin_u32(v4, v4).u32[0] & 0x80000000) != 0)
      {
        int32x2_t v6 = vdup_n_s32(0x7F7FFFFFu);
        float32x2_t v5 = (float32x2_t)0x100000001000000;
      }
      else
      {
        float32x2_t v5 = vcvt_f32_s32(*a2);
        int32x2_t v6 = (int32x2_t)vcvt_f32_s32(v3);
      }
    }
    else
    {
      float32x2_t v5 = (float32x2_t)0xFEFFFFFFFEFFFFFFLL;
      int32x2_t v6 = (int32x2_t)0x7F7FFFFF7F7FFFFFLL;
    }
    *(float32x2_t *)&long long v20 = v5;
    *((int32x2_t *)&v20 + 1) = v6;
  }
  else
  {
    for (uint64_t i = *(void *)this; i; uint64_t i = *(void *)(i + 8))
    {
      unsigned int v8 = *(_WORD *)(i + 46) & 0x3F;
      BOOL v9 = v8 > 8;
      int v10 = (1 << v8) & 0x1AA;
      if (v9 || v10 == 0)
      {
        *(float32x2_t *)&double v12 = RB::DisplayList::Item::styled_bounds((RB::DisplayList::Item *)i, 1);
        RB::Rect::Union((float32x2_t *)&v20, v12, v13, v14, v15, v16, v17);
      }
    }
  }
  for (uint64_t j = *((void *)this + 2); j; uint64_t j = *(void *)(j + 8))
  {
    *(_OWORD *)(j + 16) = v20;
    (*(void (**)(uint64_t, long long *))(*(void *)j + 56))(j, &v20);
  }
  return *(double *)&v20;
}

float32x2_t RB::DisplayList::Item::styled_bounds(RB::DisplayList::Item *this, uint64_t a2)
{
  uint64_t v3 = *((void *)this + 2);
  if (v3)
  {
    (*(void (**)(uint64_t, RB::DisplayList::Item *, uint64_t))(*(void *)v3 + 48))(v3, this, a2);
  }
  else
  {
    *(double *)&float32x2_t result = (*(double (**)(RB::DisplayList::Item *, uint64_t))(*(void *)this + 144))(this, a2);
    v11[0] = result;
    v11[1] = v9;
    uint64_t v10 = *((void *)this + 3);
    if (v10)
    {
      RB::Rect::intersect(v11, *(double *)(v10 + 16), *(float32x2_t *)(v10 + 24), v5, v6, v7, v8);
      return v11[0];
    }
  }
  return result;
}

double RB::Coverage::Path::bounds(RBPath this)
{
  callbacks = this.callbacks;
  this.callbacks = (RBPathCallbacks *)*((void *)this.info + 1);
  if (this.callbacks == (RBPathCallbacks *)&empty_path_callbacks) {
    return 0.0;
  }
  info = this.info;
  uint64_t v3 = (float64x2_t *)*((void *)this.info + 2);
  if (v3)
  {
    v4.f64[0] = RB::operator*(v3, (float64x2_t *)callbacks);
    float64x2_t v19 = v4;
    long long v20 = v5;
    long long v21 = v6;
    this.callbacks = (RBPathCallbacks *)*((void *)info + 1);
  }
  else
  {
    long long v8 = *((_OWORD *)callbacks + 1);
    float64x2_t v19 = *(float64x2_t *)callbacks;
    long long v20 = v8;
    long long v21 = *((_OWORD *)callbacks + 2);
  }
  this.info = *(void **)info;
  *(void *)&v22.origin.CGFloat x = *(_OWORD *)&RBPathBoundingRect(this, (const RB::AffineTransform *)&v19);
  CGFloat y = v22.origin.y;
  CGFloat x = v22.origin.x;
  CGFloat height = v22.size.height;
  CGFloat width = v22.size.width;
  *(double *)&float32x2_t v7 = 0.0;
  if (!CGRectIsNull(v22))
  {
    v9.f64[0] = x;
    v9.f64[1] = y;
    float32x2_t v7 = vcvt_f32_f64(v9);
    v9.f64[0] = width;
    v9.f64[1] = height;
    float32x2_t v10 = vcvt_f32_f64(v9);
    if (*((unsigned char *)info + 29) == 3)
    {
      if (*((float *)info + 6) >= 0.0) {
        float v11 = *((float *)info + 6);
      }
      else {
        float v11 = 0.0;
      }
      *(float *)v12.i32 = v11 * RB::AffineTransform::scale((float64x2_t *)callbacks);
      *(int32x2_t *)v13.i8 = vcgt_f32((float32x2_t)vdup_n_s32(0x7F7FFFFFu), v10);
      float32x2_t v7 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(v13), (int8x8_t)vsub_f32(v7, (float32x2_t)vdup_lane_s32(v12, 0)), (int8x8_t)v7);
    }
  }
  return *(double *)&v7;
}

float64x2_t RBPathBoundingRect(RBPath a1, const RB::AffineTransform *a2)
{
  callbacks = a1.callbacks;
  info = (const CGPath *)a1.info;
  uint64_t v22 = *MEMORY[0x263EF8340];
  if (*((unsigned char *)a1.callbacks + 2))
  {
    int32x4_t v13 = (void (*)(void *, const RB::AffineTransform *, RBPathCallbacks *))*((void *)a1.callbacks + 8);
    if (v13)
    {
      v13(a1.info, a2, a1.callbacks);
      return result;
    }
    double v14 = (unsigned int (*)(void *, RBPathCallbacks *))*((void *)a1.callbacks + 6);
    if (!v14 || !v14(a1.info, a1.callbacks)) {
      goto LABEL_16;
    }
    goto LABEL_7;
  }
  long long v5 = (void (*)(void *))*((void *)a1.callbacks + 8);
  if (v5)
  {
    v5(a1.info);
    if (a2)
    {
      long long v10 = *((_OWORD *)a2 + 1);
      *(_OWORD *)&v16.a = *(_OWORD *)a2;
      *(_OWORD *)&v16.c = v10;
      *(_OWORD *)&v16.tCGFloat x = *((_OWORD *)a2 + 2);
      *(void *)&result.f64[0] = (unint64_t)CGRectApplyAffineTransform(*(CGRect *)result.f64, &v16);
    }
    return result;
  }
  float v11 = (uint64_t (*)(void *))*((void *)a1.callbacks + 6);
  if (v11 && (v11(a1.info) & 1) != 0)
  {
LABEL_7:
    if (a2)
    {
      long long v12 = *((_OWORD *)a2 + 1);
      long long v17 = *(_OWORD *)a2;
      long long v18 = v12;
      long long v19 = *((_OWORD *)a2 + 2);
    }
    else
    {
      long long v17 = xmmword_2142181C0;
      long long v18 = xmmword_2142181D0;
      long long v19 = 0uLL;
    }
    char v21 = 0;
    if (v21)
    {
      result.f64[0] = v20;
      return result;
    }
  }
LABEL_16:
  *(void *)&long long v17 = &unk_26C4ED830;
  *((int32x2_t *)&v17 + 1) = vdup_n_s32(0x7F800000u);
  *(void *)&long long v18 = 0x7F0000007FLL;
  RBPathMap(info, callbacks, (void (***)(void))&v17, (float64x2_t *)a2);
  if ((DWORD2(v17) & 0x7FFFFFFFu) > 0x7F7FFFFF)
  {
    return *(float64x2_t *)MEMORY[0x263F001A0];
  }
  else
  {
    v15.i64[0] = v18;
    return vcvtq_f64_f32(COERCE_FLOAT32X2_T(RB::Rect::from_bounds(*(float32x2_t *)((char *)&v17 + 8), v15)));
  }
}

void RB::Path::Storage::bounding_rect(RBPath this)
{
  info = (atomic_ullong *)this.info;
  if (!atomic_load_explicit((atomic_ullong *volatile)this.info, memory_order_acquire))
  {
    int v2 = *((_DWORD *)this.info + 2);
    if ((v2 & 8) == 0) {
      goto LABEL_3;
    }
    long long v10 = (unsigned __int8 *)this.info + 16;
    if (v2) {
      long long v10 = (unsigned __int8 *)*((void *)this.info + 2);
    }
    int v11 = *v10;
    if ((v11 - 69) >= 7 && (v11 - 37) >= 7 && (v11 - 5) > 6)
    {
LABEL_3:
      this.callbacks = (RBPathCallbacks *)&RB::Path::Storage::bounding_rect(void)const::callbacks;
      double BoundingRect = RBPathGetBoundingRect(this);
      unint64_t v7 = *((unsigned int *)info + 2);
      if (v7)
      {
        float v12 = BoundingRect;
        float v13 = v4;
        float v14 = v5;
        unint64_t v9 = 42;
        float v15 = v6;
      }
      else
      {
        unint64_t v8 = ((unint64_t)info + ((v7 >> 8) & 0xFFF) + 19) & 0xFFFFFFFFFFFFFFFCLL;
        if ((unint64_t)info + (v7 >> 20) - v8 + 16 < 0x10) {
          operator new[]();
        }
        unint64_t v9 = (v8 - (void)info) | 2;
        float v12 = BoundingRect;
        float v13 = v4;
        float v14 = v5;
        uint64_t v16 = (v8 - (void)info) | 2;
        float v15 = v6;
        if ((v9 & 2) == 0) {
          goto LABEL_18;
        }
      }
      uint64_t v16 = (uint64_t)info + v9;
LABEL_18:
      uint64_t v18 = 0;
      long long v17 = (float *)(v16 & 0xFFFFFFFFFFFFFFFCLL);
      *long long v17 = v12;
      v17[1] = v13;
      v17[2] = v14;
      v17[3] = v15;
      atomic_compare_exchange_strong(info, (unint64_t *)&v18, v9);
      if ((v9 & 1) != 0 && v18 && (v9 & 0xFFFFFFFFFFFFFFFCLL) != 0) {
        MEMORY[0x21669ABF0](v9 & 0xFFFFFFFFFFFFFFFCLL, 0x1000C8052888210);
      }
    }
  }
}

double RB::operator*(float64x2_t *a1, float64x2_t *a2)
{
  *(void *)&double result = *(_OWORD *)&vmlaq_laneq_f64(vmulq_n_f64(*a2, a1->f64[0]), a2[1], *a1, 1);
  return result;
}

double RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::bounds(uint64_t a1)
{
  v2.callbacks = *(RBPathCallbacks **)(a1 + 48);
  v2.info = (void *)(a1 + 56);
  return RB::Coverage::Path::bounds(v2);
}

uint64_t RB::Path::Storage::bounding_rect(void)const::$_2::__invoke(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 8) >> 3) & 1;
}

void RB::Rect::Union(float32x2_t *a1, double a2, int32x4_t a3, double a4, double a5, double a6, int32x4_t a7)
{
  uint32x2_t v7 = (uint32x2_t)vceqz_f32(*(float32x2_t *)a3.i8);
  if ((vpmax_u32(v7, v7).u32[0] & 0x80000000) == 0)
  {
    float32x2_t v9 = a1[1];
    uint32x2_t v10 = (uint32x2_t)vceqz_f32(v9);
    if ((vpmax_u32(v10, v10).u32[0] & 0x80000000) == 0)
    {
      *(int32x2_t *)a7.i8 = vcltz_f32(v9);
      int32x4_t v11 = vcltzq_s32(a7);
      float32x2_t v12 = (float32x2_t)vbsl_s8(*(int8x8_t *)v11.i8, (int8x8_t)vadd_f32(*a1, v9), (int8x8_t)*a1);
      float32x2_t v13 = vabs_f32(v9);
      *a1 = v12;
      a1[1] = (float32x2_t)(*(void *)&v9 & 0x7FFFFFFF7FFFFFFFLL);
      *(int32x2_t *)v11.i8 = vcltz_f32(*(float32x2_t *)a3.i8);
      float32x2_t v14 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(v11), (int8x8_t)vadd_f32(*(float32x2_t *)a3.i8, *(float32x2_t *)&a2), *(int8x8_t *)&a2);
      *(float32x2_t *)a3.i8 = vmaxnm_f32(vadd_f32(v12, v13), vadd_f32(v14, (float32x2_t)(a3.i64[0] & 0x7FFFFFFF7FFFFFFFLL)));
      a2 = RB::Rect::from_bounds(vminnm_f32(v12, v14), a3);
    }
    *(double *)a1 = a2;
    a1[1] = *(float32x2_t *)a3.i8;
  }
}

double RB::Rect::from_bounds(float32x2_t a1, int32x4_t a2)
{
  uint32x2_t v2 = (uint32x2_t)vcge_f32(*(float32x2_t *)a2.i8, a1);
  double v3 = 0.0;
  if ((vpmin_u32(v2, v2).u32[0] & 0x80000000) != 0)
  {
    float32x2_t v4 = vsub_f32(*(float32x2_t *)a2.i8, a1);
    *(int32x2_t *)a2.i8 = vcgt_f32(*(float32x2_t *)a2.i8, vadd_f32(v4, a1));
    uint32x2_t v5 = (uint32x2_t)vcgt_f32((float32x2_t)vdup_n_s32(0x7F800000u), (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(a2), (int8x8_t)vadd_s32((int32x2_t)v4, (int32x2_t)0x100000001), (int8x8_t)v4));
    return COERCE_DOUBLE(vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_s32(0, (int32x2_t)vpmin_u32(v5, v5)), 0), (int8x8_t)a1, (int8x8_t)0x100000001000000));
  }
  return v3;
}

void RB::Path::Object::$_13::__invoke(RBPath this)
{
  this.info = (char *)this.info + 16;
  RB::Path::Storage::bounding_rect(this);
}

double RBPathGetBoundingRect(RBPath a1)
{
  *(void *)&double result = *(_OWORD *)&RBPathBoundingRect(a1, 0);
  return result;
}

uint64_t RB::Path::NestedCallbacks::NestedCallbacks(RBPathCallbacks const*,unsigned long)::$_0::__invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v6[0] = a2;
  v6[1] = a3;
  uint64_t v4 = *(void *)(a4 + 88);
  v6[2] = *(void *)(a4 + 96);
  v6[3] = 0;
  char v7 = 0;
  LODWORD(result) = (*(uint64_t (**)(uint64_t, void *, uint64_t (*)(uint64_t, unsigned int)))(v4 + 24))(a1, v6, RB::Path::NestedCallbacks::apply_elements_callback);
  if (v7) {
    return 1;
  }
  else {
    return result;
  }
}

void RBPathMap(CGPathRef path, void *a2, void (***a3)(void), float64x2_t *a4)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  if (a2 == &RBPathCGPathCallbacks)
  {
    uint32x2_t v10 = a3;
    int32x4_t v11 = a4;
    if (a4)
    {
      int64x2_t v8 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(a4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*a4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(a4[2]));
      if (vandq_s8((int8x16_t)vdupq_laneq_s64(v8, 1), (int8x16_t)v8).i64[0] >= 0) {
        float32x2_t v9 = (void (__cdecl *)(void *, const CGPathElement *))RB::Path::Iterator::callback_0;
      }
      else {
        float32x2_t v9 = (void (__cdecl *)(void *, const CGPathElement *))RB::Path::Iterator::callback_1;
      }
    }
    else
    {
      float32x2_t v9 = (void (__cdecl *)(void *, const CGPathElement *))RB::Path::Iterator::callback_1;
    }
    CGPathApply(path, &v10, v9);
    (**a3)(a3);
  }
  else
  {
    uint32x2_t v10 = &unk_26C4ED9F0;
    RB::Heap::Heap((RB::Heap *)&v11, v12, 256, 0);
    uint64_t v13 = 0;
    float32x2_t v14 = a3;
    long long v16 = 0u;
    long long v17 = 0u;
    float v15 = a4;
    uint64_t v18 = 0;
    __int16 v19 = 1;
    RBPathApplyElements((uint64_t)path, (uint64_t)a2, (uint64_t)&v10, (uint64_t)RB::Path::Mapper::apply_callback);
    (**a3)(a3);
    RB::Path::Mapper::~Mapper((RB::Path::Mapper *)&v10);
  }
}

RB::Heap *RB::Heap::Heap(RB::Heap *this, char *a2, uint64_t a3, unint64_t a4)
{
  *((void *)this + 4) = 0;
  uint64_t v5 = 512;
  if (a4 > 0x200) {
    uint64_t v5 = a4;
  }
  if (!a4) {
    uint64_t v5 = 0x2000;
  }
  *(void *)this = v5;
  *((void *)this + 1) = 0;
  RB::Heap::reset(this, a2, a3);
  return this;
}

void RB::Heap::reset(RB::Heap *this, char *a2, uint64_t a3)
{
  double v6 = (RB::ObjectTable *)*((void *)this + 4);
  if (v6)
  {
    RB::ObjectTable::~ObjectTable(v6);
    *((void *)this + 4) = 0;
  }
  while (1)
  {
    int64x2_t v8 = (void *)*((void *)this + 1);
    if (!v8) {
      break;
    }
    char v7 = (void *)v8[1];
    *((void *)this + 1) = *v8;
    free(v7);
  }
  *((void *)this + 2) = a2;
  *((void *)this + 3) = &a2[a3];
}

uint64_t RBPathApplyShape(uint64_t a1, void *a2, char a3, uint64_t a4, void (*a5)(uint64_t, uint64_t, long long *))
{
  if (a2 != &RBPathCGPathCallbacks)
  {
    if (RBPathIsSingleElement(a1, (uint64_t)a2))
    {
      *(void *)&long long v15 = a4;
      *((void *)&v15 + 1) = a5;
      *(void *)&long long v16 = a1;
      *((void *)&v16 + 1) = a2;
      char v17 = 0;
      RBPathApplyElements(a1, (uint64_t)a2, (uint64_t)&v15, (uint64_t)RBPathApplyShape::$_0::__invoke<void *,RBPathElement,double const*,void const*>);
      return v17 != 0;
    }
    if (a3) {
      return 0;
    }
    uint64_t v14 = 0;
    if (!RBPathApplyElements(a1, (uint64_t)a2, (uint64_t)v13, (uint64_t)RBPathApplyShape::$_1::__invoke<void *,RBPathElement,double const*,void const*>)|| v14 != 2)
    {
      return 0;
    }
    long long v15 = v13[0];
    long long v16 = v13[1];
    uint64_t v12 = a4;
    uint64_t v11 = 2;
    goto LABEL_19;
  }
  uint64_t result = CGPathIsPrimitive();
  if (!result) {
    return result;
  }
  if ((CGPathIsRectWithTransform() & 1) == 0)
  {
    if (CGPathIsEllipseWithTransform())
    {
      uint64_t v11 = 1;
      goto LABEL_18;
    }
    uint64_t result = CGPathIsRoundedRectWithTransform();
    if (!result) {
      return result;
    }
    if (v18 != 0.0 || v19 != 0.0)
    {
      int v20 = 0;
      uint64_t v11 = 3;
      goto LABEL_18;
    }
  }
  uint64_t v11 = 0;
LABEL_18:
  uint64_t v12 = a4;
LABEL_19:
  a5(v12, v11, &v15);
  return 1;
}

uint64_t RBPathApplyElements(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(unsigned char *)(a2 + 2))
  {
    double v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a2 + 24);
    if (v6) {
      return v6(a1, a3, a4, a2);
    }
  }
  else
  {
    uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a2 + 24);
    if (v4) {
      return v4(a1, a3, a4);
    }
  }
  return 1;
}

uint64_t RB::Path::Storage::apply_elements(RB::Path::Storage *a1, RB::Path::Storage *this, void *a3)
{
  {
    RB::Path::Storage::append_storage(this, a1);
    return 1;
  }
  else if (a3 == RB::Path::NestedCallbacks::apply_elements_callback)
  {
    return RB::Path::NestedCallbacks::apply_elements_fast(a1, this, a3);
  }
  else if (a3 == RB::Path::NestedCallbacks::single_element_callback)
  {
    return RB::Path::NestedCallbacks::single_element_fast(a1, this, a3);
  }
  else if (a3 == RB::Path::Mapper::apply_callback && (*((_DWORD *)a1 + 2) & 0x20) != 0 && !*((unsigned char *)this + 369))
  {
    double v6 = (os_unfair_lock_s *)RB::Path::Storage::MapCache::shared(a1);
    return RB::Path::Storage::MapCache::apply(v6, (uint64_t)a1, this, (uint64_t)RB::Path::Mapper::apply_callback, 0);
  }
  else
  {
    return RB::Path::Storage::apply_elements_((uint64_t)a1, (uint64_t)this, (uint64_t (*)(uint64_t, uint64_t, unsigned char *, long long *))a3);
  }
}

uint64_t RBPathIsSingleElement(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 2))
  {
    uint32x2_t v2 = *(uint64_t (**)(void))(a2 + 48);
    if (v2)
    {
      return v2();
    }
  }
  else
  {
    uint32x2_t v2 = *(uint64_t (**)(void))(a2 + 48);
    if (v2)
    {
      return v2();
    }
  }
  v4[0] = 0;
  v4[1] = 0;
  char v6 = 0;
  uint64_t v5 = 0;
  RBPathApplyElements(a1, a2, (uint64_t)v4, (uint64_t)RB::Path::NestedCallbacks::single_element_callback);
  return v5 == 1;
}

void RB::Path::Mapper::~Mapper(RB::Path::Mapper *this)
{
  while (*((void *)this + 41))
    RB::Path::Mapper::pop(this);
  RB::Heap::~Heap((RB::Path::Mapper *)((char *)this + 8));
}

void RB::Heap::~Heap(RB::Heap *this)
{
  uint32x2_t v2 = (RB::ObjectTable *)*((void *)this + 4);
  if (v2)
  {
    RB::ObjectTable::~ObjectTable(v2);
    *((void *)this + 4) = 0;
  }
  double v3 = (uint64_t **)*((void *)this + 1);
  if (v3)
  {
    do
    {
      uint64_t v4 = *v3;
      free(v3[1]);
      double v3 = (uint64_t **)v4;
    }
    while (v4);
  }
}

uint64_t RB::Path::NestedCallbacks::apply_elements_fast(RB::Path::NestedCallbacks *this, const RB::Path::Storage *a2, void *a3)
{
  if ((*((unsigned char *)this + 8) & 0x20) == 0)
  {
    uint64_t v5 = *(void *)a2;
    char v6 = (uint64_t (*)(uint64_t))*((void *)a2 + 1);
LABEL_6:
    uint64_t v7 = *((void *)a2 + 2);
    return RB::Path::Storage::apply_elements_at_depth((uint64_t)this, v5, v6, v7);
  }
  uint64_t v5 = *(void *)a2;
  char v6 = (uint64_t (*)(uint64_t))*((void *)a2 + 1);
  if ((char *)v6 != (char *)RB::Path::Mapper::apply_callback) {
    goto LABEL_6;
  }
  if (*(unsigned char *)(v5 + 369))
  {
    char v6 = (uint64_t (*)(uint64_t))RB::Path::Mapper::apply_callback;
    goto LABEL_6;
  }
  float32x2_t v9 = (os_unfair_lock_s *)RB::Path::Storage::MapCache::shared(this);
  uint32x2_t v10 = *(RB::Path::Storage **)a2;
  uint64_t v11 = *((void *)a2 + 1);
  uint64_t v12 = (atomic_uint *)*((void *)a2 + 2);
  return RB::Path::Storage::MapCache::apply(v9, (uint64_t)this, v10, v11, v12);
}

uint64_t anonymous namespace'::make_wrapped_path<RBPathCopyTransformedPath::TransformArgs>(RBPath,RBPathCopyTransformedPath::TransformArgs &&)::{lambda(void const*)#4}::__invoke()
{
  return 1;
}

uint64_t anonymous namespace'::make_wrapped_path<RBPathCopyTransformedPath::TransformArgs>(RBPath,RBPathCopyTransformedPath::TransformArgs &&)::{lambda(void const*,void *,BOOL (*)(void const*,RBPathElement,double const*,void const))#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, _OWORD *))
{
  uint64_t v6 = a1 + 32;
  long long v7 = *(_OWORD *)(a1 + 48);
  v9[0] = *(_OWORD *)(a1 + 32);
  v9[1] = v7;
  v9[2] = *(_OWORD *)(a1 + 64);
  uint64_t result = a3(a2, 17, a1 + 32, v9);
  if (result)
  {
    uint64_t result = RBPathApplyElements(*(void *)(a1 + 16), *(void *)(a1 + 24), a2, (uint64_t)a3);
    if (result) {
      return a3(a2, 16, v6, 0);
    }
  }
  return result;
}

float32x2_t RB::Stroke::FixedWidthLineBounds::endpath(RB::Stroke::FixedWidthLineBounds *this, float32x2_t a2, double a3)
{
  return RB::Stroke::LineBounds::endpath((RB::Stroke::FixedWidthLineBounds *)((char *)this + 16), a2, a3);
}

float32x2_t RB::Stroke::LineBounds::endpath(RB::Stroke::LineBounds *this, float32x2_t result, double a3)
{
  if (!*((unsigned char *)this + 64))
  {
    LODWORD(a3) = *((_DWORD *)this + 15);
    RB::Stroke::LineBounds::add_cap((float32x2_t *)this, 0, *(float32x2_t *)((char *)this + 32), a3, *(int8x8_t *)((char *)this + 40));
    float32x2_t v4 = *(float32x2_t *)((char *)this + 24);
    LODWORD(v5) = *((_DWORD *)this + 14);
    int8x8_t v6 = *(int8x8_t *)((char *)this + 48);
    return RB::Stroke::LineBounds::add_cap((float32x2_t *)this, 1, v4, v5, v6);
  }
  return result;
}

float32x2_t RB::Stroke::LineBounds::add_cap(float32x2_t *a1, int a2, float32x2_t result, double a4, int8x8_t a5)
{
  switch(a1->i8[0])
  {
    case 0:
      return RB::Stroke::LineBounds::add_point(a1, result, a4);
    case 1:
    case 4:
      goto LABEL_8;
    case 2:
      if (a2) {
        unsigned int v5 = -1;
      }
      else {
        unsigned int v5 = 0;
      }
      float32x2_t v6 = (float32x2_t)vbsl_s8((int8x8_t)vdup_n_s32(v5), a5, (int8x8_t)vneg_f32((float32x2_t)a5));
      float32x2_t v7 = vmul_f32(v6, v6);
      v7.i32[0] = vadd_f32(v7, (float32x2_t)vdup_lane_s32((int32x2_t)v7, 1)).u32[0];
      float32x2_t v8 = vrsqrte_f32((float32x2_t)v7.u32[0]);
      float32x2_t v9 = vmul_f32(vrsqrts_f32((float32x2_t)v7.u32[0], vmul_f32(v8, v8)), v8);
      int32x2_t v10 = (int32x2_t)vmul_f32(v9, vrsqrts_f32((float32x2_t)v7.u32[0], vmul_f32(v9, v9)));
      float32x2_t v11 = vmul_n_f32(v6, *(float *)v10.i32);
      goto LABEL_12;
    case 3:
      goto LABEL_14;
    case 5:
      if ((a2 & 1) == 0) {
        goto LABEL_8;
      }
      goto LABEL_14;
    case 6:
      if (a2)
      {
LABEL_8:
        int8x8_t v12 = (int8x8_t)vneg_f32((float32x2_t)a5);
        if (a2) {
          unsigned int v13 = -1;
        }
        else {
          unsigned int v13 = 0;
        }
        float32x2_t v14 = (float32x2_t)vbsl_s8((int8x8_t)vdup_n_s32(v13), a5, v12);
        float32x2_t v15 = vmul_f32(v14, v14);
        v15.i32[0] = vadd_f32(v15, (float32x2_t)vdup_lane_s32((int32x2_t)v15, 1)).u32[0];
        float32x2_t v16 = vrsqrte_f32((float32x2_t)v15.u32[0]);
        float32x2_t v17 = vmul_f32(vrsqrts_f32((float32x2_t)v15.u32[0], vmul_f32(v16, v16)), v16);
        int32x2_t v10 = (int32x2_t)vmul_f32(v17, vrsqrts_f32((float32x2_t)v15.u32[0], vmul_f32(v17, v17)));
        float32x2_t v11 = vmul_n_f32(v14, *(float *)v10.i32);
        uint64_t result = vmla_n_f32(result, v11, *(float *)&a4);
LABEL_12:
        *(float *)v10.i32 = -v11.f32[1];
        float32x2_t v18 = vmul_n_f32((float32x2_t)vzip1_s32(v10, (int32x2_t)v11), *(float *)&a4);
        float32x2_t v19 = vadd_f32(v18, result);
        float32x2_t v20 = vminnm_f32(a1[1], v19);
        float32x2_t v21 = vmaxnm_f32(a1[2], v19);
        float32x2_t v22 = vsub_f32(result, v18);
        float32x2_t v23 = vminnm_f32(v20, v22);
      }
      else
      {
LABEL_14:
        int8x8_t v24 = (int8x8_t)vneg_f32((float32x2_t)a5);
        if (a2) {
          unsigned int v25 = -1;
        }
        else {
          unsigned int v25 = 0;
        }
        float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vdup_n_s32(v25), a5, v24);
        float32x2_t v27 = vmul_f32(v26, v26);
        v27.i32[0] = vadd_f32(v27, (float32x2_t)vdup_lane_s32((int32x2_t)v27, 1)).u32[0];
        float32x2_t v28 = vrsqrte_f32((float32x2_t)v27.u32[0]);
        float32x2_t v29 = vmul_f32(vrsqrts_f32((float32x2_t)v27.u32[0], vmul_f32(v28, v28)), v28);
        float32x2_t v30 = vmul_n_f32(v26, vmul_f32(v29, vrsqrts_f32((float32x2_t)v27.u32[0], vmul_f32(v29, v29))).f32[0]);
        float32x2_t v31 = vmla_n_f32(result, v30, *(float *)&a4);
        float32x2_t v32 = a1[2];
        float32x2_t v33 = vminnm_f32(a1[1], v31);
        float32x2_t v34 = vmaxnm_f32(v32, v31);
        v32.f32[0] = -v30.f32[1];
        float32x2_t v35 = vmul_n_f32((float32x2_t)vzip1_s32((int32x2_t)v32, (int32x2_t)v30), *(float *)&a4);
        float32x2_t v36 = vadd_f32(v35, result);
        float32x2_t v37 = vminnm_f32(v33, v36);
        float32x2_t v21 = vmaxnm_f32(v34, v36);
        float32x2_t v22 = vsub_f32(result, v35);
        float32x2_t v23 = vminnm_f32(v37, v22);
      }
      uint64_t result = vmaxnm_f32(v21, v22);
      a1[1] = v23;
      a1[2] = result;
      break;
    default:
      return result;
  }
  return result;
}

RB::Path::Storage::MapCache *RB::Path::Storage::append_storage(RB::Path::Storage::MapCache *this, const RB::Path::Storage *a2)
{
  unint64_t v2 = *((unsigned int *)a2 + 2);
  if (v2) {
    uint64_t v3 = *((void *)a2 + 3);
  }
  else {
    uint64_t v3 = (v2 >> 8) & 0xFFF;
  }
  if (!v3) {
    return this;
  }
  unsigned int v5 = this;
  uint64_t v6 = *(void *)this;
  if (*(void *)this)
  {
    *(void *)this = 0;
    if (v6)
    {
      this = (RB::Path::Storage::MapCache *)(v6 & 0xFFFFFFFFFFFFFFFCLL);
      if ((v6 & 0xFFFFFFFFFFFFFFFCLL) != 0) {
        this = (RB::Path::Storage::MapCache *)MEMORY[0x21669ABF0](this, 0x1000C8052888210);
      }
    }
  }
  unsigned int v7 = *((_DWORD *)v5 + 2);
  if ((v7 & 0x20) != 0)
  {
    float32x2_t v8 = (os_unfair_lock_s *)RB::Path::Storage::MapCache::shared(this);
    RB::Path::Storage::MapCache::remove(v8, v5);
    unsigned int v7 = *((_DWORD *)v5 + 2);
  }
  if (v7)
  {
    float32x2_t v9 = (const void *)*((void *)v5 + 7);
    if (v9)
    {
      *((void *)v5 + 7) = 0;
      CFRelease(v9);
      unsigned int v7 = *((_DWORD *)v5 + 2);
    }
  }
  if (v7)
  {
    if (*((void *)v5 + 3)) {
      goto LABEL_19;
    }
  }
  else if (((v7 >> 8) & 0xFFF) != 0)
  {
    goto LABEL_19;
  }
  if ((*((unsigned char *)a2 + 8) & 8) != 0)
  {
    unsigned int v10 = v7 | 8;
    goto LABEL_20;
  }
LABEL_19:
  unsigned int v10 = v7 & 0xFFFFFFF7;
LABEL_20:
  *((_DWORD *)v5 + 2) = v10;
  *((_DWORD *)v5 + 2) = *((_DWORD *)a2 + 2) & 0x26 | v10;
  unint64_t v11 = *((unsigned int *)a2 + 2);
  int8x8_t v12 = (char *)*((void *)a2 + 2);
  size_t v13 = *((void *)a2 + 3);
  float32x2_t v14 = (char *)a2 + 16;
  if (v11)
  {
    float32x2_t v14 = v12;
    size_t v15 = v13;
  }
  else
  {
    size_t v15 = (v11 >> 8) & 0xFFF;
  }
  int v16 = v10 & 1;
  if (v10)
  {
    uint64_t v17 = *((void *)v5 + 3);
    size_t v18 = *((void *)v5 + 4);
  }
  else
  {
    uint64_t v17 = (v10 >> 8) & 0xFFF;
    size_t v18 = v10 >> 20;
  }
  size_t v19 = v17 + v15;
  if (v18 < v17 + v15)
  {
    RB::Path::Storage::reserve_slow(v5, v17 + v15);
    int v16 = *((_DWORD *)v5 + 2) & 1;
  }
  float32x2_t v20 = (void *)((char *)v5 + 16);
  if (v16) {
    float32x2_t v20 = (void *)*v20;
  }
  this = (RB::Path::Storage::MapCache *)memcpy((char *)v20 + v17, v14, v15);
  int v21 = *((_DWORD *)v5 + 2);
  if (v21) {
    *((void *)v5 + 3) = v19;
  }
  else {
    *((_DWORD *)v5 + 2) = v21 & 0xFFF000FF | ((v19 & 0xFFF) << 8);
  }
  return this;
}

BOOL RB::Path::NestedCallbacks::NestedCallbacks(RBPathCallbacks const*,unsigned long)::$_1::__invoke(uint64_t a1, uint64_t a2)
{
  char v6 = 0;
  v4[1] = 0;
  uint64_t v5 = 0;
  uint64_t v2 = *(void *)(a2 + 88);
  v4[0] = *(void *)(a2 + 96);
  (*(void (**)(uint64_t, void *, BOOL (*)(uint64_t, int)))(v2 + 24))(a1, v4, RB::Path::NestedCallbacks::single_element_callback);
  return v5 == 1;
}

uint64_t RB::Path::Object::$_8::__invoke(uint64_t a1, RB::Path::Storage *a2, void *a3)
{
  return RB::Path::Storage::apply_elements((RB::Path::Storage *)(a1 + 16), a2, a3);
}

uint64_t RB::Path::Object::$_11::__invoke(RB::Path::Object::$_11 *this, const void *a2)
{
  return (*((unsigned __int8 *)this + 24) >> 3) & 1;
}

float32x2_t RB::Coverage::Primitive::bounds(float32x2_t *this, float64x2_t *a2, int8x16_t a3, int32x4_t a4, int8x16_t _Q2, int32x4_t a6)
{
  switch(this[5].i8[4])
  {
    case 1:
      return (float32x2_t)0x100000001000000;
    case 2:
    case 3:
    case 4:
    case 5:
    case 7:
      goto LABEL_2;
    case 6:
    case 8:
      if ((this[5].i8[6] & 1) == 0)
      {
        uint32x2_t v13 = (uint32x2_t)vceqz_f32(this[1]);
        unsigned __int32 v14 = vpmin_u32(v13, v13).u32[0];
        float32x2_t result = 0;
        if ((v14 & 0x80000000) != 0) {
          return result;
        }
      }
LABEL_2:
      if (this[5].i8[6]) {
        return (float32x2_t)0x100000001000000;
      }
      __asm { FMOV            V2.2S, #1.0 }
      _Q2.i32[0] = this[4].i32[0];
      *(float32x2_t *)a3.i8 = vmul_f32(*this, *(float32x2_t *)_Q2.i8);
      float32x2_t v10 = vmul_f32(this[1], *(float32x2_t *)_Q2.i8);
      *(float32x2_t *)_Q2.i8 = vadd_f32(v10, *(float32x2_t *)a3.i8);
      *(int32x2_t *)a6.i8 = vcltz_f32(v10);
      int32x4_t v11 = vcltzq_s32(a6);
      a3.i64[0] = vbslq_s8((int8x16_t)v11, _Q2, a3).u64[0];
      a4.i64[0] = *(void *)&v10 & 0x7FFFFFFF7FFFFFFFLL;
      _Q2.i32[0] = this[4].i32[1];
      if (*(float *)_Q2.i32 > 0.0)
      {
        v11.i32[0] = 1060439283;
        if (this[5].i8[4] != 8) {
          *(float *)v11.i32 = 0.5;
        }
        *(float *)_Q2.i32 = *(float *)_Q2.i32 * *(float *)v11.i32;
        *(int32x2_t *)v11.i8 = vcgt_f32((float32x2_t)vdup_n_s32(0x7F7FFFFFu), *(float32x2_t *)a4.i8);
        int32x4_t v11 = vcltzq_s32(v11);
        *(int8x8_t *)a3.i8 = vbsl_s8(*(int8x8_t *)v11.i8, (int8x8_t)vsub_f32(*(float32x2_t *)a3.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)_Q2.i8, 0)), *(int8x8_t *)a3.i8);
        *(int8x8_t *)a4.i8 = vbsl_s8(*(int8x8_t *)v11.i8, (int8x8_t)vmla_n_f32(*(float32x2_t *)a4.i8, (float32x2_t)0x4000000040000000, *(float *)_Q2.i32), *(int8x8_t *)a4.i8);
      }
      if ((this[5].i8[6] & 4) != 0)
      {
        *(float *)_Q2.i32 = this[5].f32[0] * 2.8;
      }
      else
      {
        if (this[5].i8[5] != 3) {
          return RB::operator*(a2, *(float32x2_t *)a3.i8, a4);
        }
        _Q2.i32[0] = this[5].i32[0];
      }
      *(int32x2_t *)v11.i8 = vcgt_f32((float32x2_t)vdup_n_s32(0x7F7FFFFFu), *(float32x2_t *)a4.i8);
      int8x8_t v15 = (int8x8_t)vcltzq_s32(v11).u64[0];
      *(int8x8_t *)a3.i8 = vbsl_s8(v15, (int8x8_t)vsub_f32(*(float32x2_t *)a3.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)_Q2.i8, 0)), *(int8x8_t *)a3.i8);
      *(int8x8_t *)a4.i8 = vbsl_s8(v15, (int8x8_t)vmla_n_f32(*(float32x2_t *)a4.i8, (float32x2_t)0x4000000040000000, *(float *)_Q2.i32), *(int8x8_t *)a4.i8);
      return RB::operator*(a2, *(float32x2_t *)a3.i8, a4);
    case 9:
    case 0xA:
    case 0xB:
      abort();
    default:
      return 0;
  }
}

void RB::Rect::intersect(float32x2_t *a1, double a2, float32x2_t a3, double a4, double a5, double a6, int32x4_t a7)
{
  float32x2_t v7 = a1[1];
  uint32x2_t v8 = (uint32x2_t)vceqz_f32(v7);
  if ((vpmax_u32(v8, v8).u32[0] & 0x80000000) == 0)
  {
    uint32x2_t v10 = (uint32x2_t)vceqz_f32(a3);
    if ((vpmax_u32(v10, v10).u32[0] & 0x80000000) == 0)
    {
      *(int32x2_t *)a7.i8 = vcltz_f32(v7);
      int32x4_t v11 = vcltzq_s32(a7);
      float32x2_t v12 = (float32x2_t)vbsl_s8(*(int8x8_t *)v11.i8, (int8x8_t)vadd_f32(*a1, v7), (int8x8_t)*a1);
      float32x2_t v13 = vabs_f32(v7);
      *a1 = v12;
      a1[1] = (float32x2_t)(*(void *)&v7 & 0x7FFFFFFF7FFFFFFFLL);
      *(int32x2_t *)v11.i8 = vcltz_f32(a3);
      float32x2_t v14 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(v11), (int8x8_t)vadd_f32(a3, *(float32x2_t *)&a2), *(int8x8_t *)&a2);
      float32x2_t v15 = vmaxnm_f32(v12, v14);
      float32x2_t v16 = vminnm_f32(vadd_f32(v12, v13), vadd_f32(v14, (float32x2_t)(*(void *)&a3 & 0x7FFFFFFF7FFFFFFFLL)));
      uint32x2_t v17 = (uint32x2_t)vcgtz_f32(vsub_f32(v16, v15));
      if ((vpmin_u32(v17, v17).u32[0] & 0x80000000) == 0)
      {
        *a1 = 0;
        a1[1] = 0;
        return;
      }
      a2 = RB::Rect::from_bounds_inner(v15, v16);
    }
    *(double *)a1 = a2;
    a1[1] = a3;
  }
}

double RB::Rect::from_bounds_inner(float32x2_t a1, float32x2_t a2)
{
  uint32x2_t v2 = (uint32x2_t)vcge_f32(a2, a1);
  double v3 = 0.0;
  if ((vpmin_u32(v2, v2).u32[0] & 0x80000000) != 0)
  {
    uint32x2_t v4 = (uint32x2_t)vcgt_f32((float32x2_t)vdup_n_s32(0x7F800000u), vsub_f32(a2, a1));
    if ((vpmin_u32(v4, v4).u32[0] & 0x80000000) != 0) {
      return *(double *)&a1;
    }
    else {
      return 7.29112205e-304;
    }
  }
  return v3;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::bounds(uint64_t a1, int8x16_t a2, int32x4_t a3, int8x16_t a4, int32x4_t a5)
{
  return RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), *(float64x2_t **)(a1 + 48), a2, a3, a4, a5);
}

float64x2_t RB::Coverage::anonymous namespace'::simplify_stroked_shape_callback(uint64_t (****a1)(void, uint64_t *), unsigned int a2, uint64_t a3)
{
  uint32x2_t v4 = a1[10];
  uint64_t v5 = (uint64_t)(a1 + 2);
  long long v44 = *((_OWORD *)a1 + 1);
  long long v45 = *((_OWORD *)a1 + 2);
  float64x2_t result = *((float64x2_t *)a1 + 3);
  float64x2_t v46 = result;
  if (a2 > 5) {
    goto LABEL_42;
  }
  if (((1 << a2) & 0x1B) != 0)
  {
    float64x2_t result = *(float64x2_t *)a3;
    long long v9 = *(_OWORD *)(a3 + 16);
    long long v10 = *(_OWORD *)(a3 + 32);
    float64x2_t v47 = result;
    long long v48 = v9;
    long long v49 = v10;
    if (result.f64[0] != *((double *)&v9 + 1) || result.f64[1] != 0.0 || *(double *)&v9 != 0.0)
    {
      if (*((double *)&v9 + 1) != 0.0) {
        goto LABEL_42;
      }
      if (result.f64[0] != 0.0 || result.f64[1] != *(double *)&v9) {
        goto LABEL_42;
      }
    }
    result.f64[0] = RB::operator*(&v47, (float64x2_t *)v5);
    *((float64x2_t *)a1 + 1) = result;
    *((_OWORD *)a1 + 2) = v12;
    *((_OWORD *)a1 + 3) = v13;
    *(void *)&result.f64[0] = v4[2];
    if (result.f64[0] >= 1.5)
    {
      if (*((_DWORD *)v4 + 7))
      {
        LOBYTE(v14) = 0;
        goto LABEL_35;
      }
      *(void *)&result.f64[0] = v4[4];
      BOOL v14 = result.f64[0] >= 1.41421354;
      if (a2)
      {
LABEL_35:
        switch(a2)
        {
          case 4u:
            if (*(_DWORD *)(a3 + 112)) {
              goto LABEL_42;
            }
            result.f64[0] = *(float64_t *)(a3 + 80);
            double v35 = *(double *)(a3 + 88);
            double v36 = *(double *)(a3 + 96);
            double v37 = *(double *)(a3 + 104);
            if (!v14 && (result.f64[0] == 0.0 || v35 == 0.0 || v36 == 0.0 || v37 == 0.0)) {
              goto LABEL_42;
            }
            float v38 = *((double *)a1 + 11);
            float v39 = *((double *)a1 + 9);
            break;
          case 3u:
            result.f64[0] = *(float64_t *)(a3 + 80);
            double v41 = *(double *)(a3 + 88);
            if (result.f64[0] != v41 || *(_DWORD *)(a3 + 96)) {
              goto LABEL_42;
            }
            float v42 = *((double *)a1 + 11);
            float v43 = *((double *)a1 + 9);
            break;
          case 1u:
            result.f64[0] = *(float64_t *)(a3 + 64);
            if (result.f64[0] != *(double *)(a3 + 72)) {
              goto LABEL_42;
            }
            float v33 = *((double *)a1 + 11);
            float v34 = *((double *)a1 + 9);
            goto LABEL_40;
          default:
            goto LABEL_42;
        }
        *((unsigned char *)a1 + 96) = v40;
        goto LABEL_42;
      }
    }
    else
    {
      BOOL v14 = 1;
      if (a2) {
        goto LABEL_35;
      }
    }
    if (!v14) {
      goto LABEL_35;
    }
    float v31 = *((double *)a1 + 11);
    float v32 = *((double *)a1 + 9);
LABEL_40:
    char v30 = 1;
    goto LABEL_41;
  }
  if (a2 == 2)
  {
    unsigned int v15 = *((unsigned __int8 *)a1 + 64);
    if (v15 > 1 || (unsigned int v16 = *((_DWORD *)v4 + 6), v16 > 2))
    {
      char v30 = 0;
LABEL_41:
      *((unsigned char *)a1 + 96) = v30;
      goto LABEL_42;
    }
    uint32x2_t v17 = (void (***)(void))*a1;
    *(float *)&unsigned int v18 = *((double *)a1 + 11);
    float64x2_t v19 = *((float64x2_t *)a1 + 1);
    float64x2_t v20 = *((float64x2_t *)a1 + 2);
    float64x2_t v21 = vmlaq_n_f64(vmlaq_n_f64(*((float64x2_t *)a1 + 3), v19, *(double *)a3), v20, *(double *)(a3 + 8));
    float32x2_t v22 = vcvt_f32_f64(vsubq_f64(vmlaq_n_f64(vmlaq_n_f64(*((float64x2_t *)a1 + 3), v19, *(double *)(a3 + 16)), v20, *(double *)(a3 + 24)), v21));
    *(float *)&unsigned int v23 = *((double *)a1 + 9);
    *(float32x2_t *)&v47.f64[0] = vcvt_f32_f64(v21);
    *(float32x2_t *)&v47.f64[1] = v22;
    long long v48 = 0uLL;
    LODWORD(v49) = 1065353216;
    *(void *)((char *)&v49 + 4) = __PAIR64__(v23, v18);
    BYTE12(v49) = v16 + 6;
    *(_WORD *)((char *)&v49 + 13) = v15;
    (**v17)();
    goto LABEL_40;
  }
  float64x2_t result = *(float64x2_t *)(a3 + 16);
  long long v24 = *(_OWORD *)(a3 + 32);
  long long v25 = *(_OWORD *)(a3 + 48);
  float64x2_t v47 = result;
  long long v48 = v24;
  long long v49 = v25;
  if (result.f64[0] == *((double *)&v24 + 1) && result.f64[1] == 0.0 && *(double *)&v24 == 0.0
    || *((double *)&v24 + 1) == 0.0
    && (result.f64[0] == 0.0 ? (BOOL v26 = result.f64[1] == *(double *)&v24) : (BOOL v26 = 0), v26))
  {
    *(double *)&long long v27 = RB::operator*(&v47, (float64x2_t *)v5);
    *((_OWORD *)a1 + 1) = v27;
    *((_OWORD *)a1 + 2) = v28;
    *((_OWORD *)a1 + 3) = v29;
  }
LABEL_42:
  if (!*((unsigned char *)a1 + 96))
  {
    *(_OWORD *)uint64_t v5 = v44;
    *(_OWORD *)(v5 + 16) = v45;
    float64x2_t result = v46;
    *(float64x2_t *)(v5 + 32) = v46;
  }
  return result;
}

double RB::Path::cubic_bounds_slow(float32x2_t a1, float32x2_t a2, float32x2_t a3, float32x2_t a4, int32x4_t a5, int32x4_t a6, int32x4_t a7, int32x4_t a8)
{
  __asm { FMOV            V4.2S, #-3.0 }
  *(float32x2_t *)a8.i8 = vmla_f32(vsub_f32(a4, vmla_f32(a1, _D4, a2)), _D4, a3);
  float32x2_t v15 = vadd_f32(vsub_f32(a1, vadd_f32(a2, a2)), a3);
  *(float32x2_t *)v8.i8 = vadd_f32(v15, v15);
  *(float32x2_t *)a5.i8 = vsub_f32(a2, a1);
  __asm { FMOV            V5.2S, #-4.0 }
  float32x2_t v17 = vmla_f32(vmul_f32(vmul_f32(*(float32x2_t *)a5.i8, _D5), *(float32x2_t *)a8.i8), *(float32x2_t *)v8.i8, *(float32x2_t *)v8.i8);
  *(int32x2_t *)a6.i8 = vcltz_f32(v17);
  if ((vpmin_u32(*(uint32x2_t *)a6.i8, *(uint32x2_t *)a6.i8).u32[0] & 0x80000000) != 0)
  {
    *(float32x2_t *)a5.i8 = vminnm_f32(a1, a4);
  }
  else
  {
    __asm { FMOV            V6.2S, #1.0 }
    *(float32x2_t *)v8.i8 = vmul_f32(vmla_f32(*(float32x2_t *)v8.i8, (float32x2_t)vorr_s8(vand_s8(*(int8x8_t *)v8.i8, (int8x8_t)0x8000000080000000), (int8x8_t)_D6), vsqrt_f32(v17)), (float32x2_t)0xBF000000BF000000);
    float32x2_t v19 = vrecpe_f32(*(float32x2_t *)a8.i8);
    float32x2_t v20 = vmul_f32(vrecps_f32(*(float32x2_t *)a8.i8, v19), v19);
    int8x8_t v21 = (int8x8_t)vmul_f32(vmul_f32(vrecps_f32(*(float32x2_t *)a8.i8, v20), *(float32x2_t *)v8.i8), v20);
    *(int8x8_t *)a8.i8 = vorr_s8(*(int8x8_t *)a6.i8, (int8x8_t)vceqz_f32(*(float32x2_t *)a8.i8));
    __asm { FMOV            V18.2S, #-1.0 }
    float32x2_t v23 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(a8), _D18, v21);
    float32x2_t v24 = vrecpe_f32(*(float32x2_t *)v8.i8);
    float32x2_t v25 = vmul_f32(vrecps_f32(*(float32x2_t *)v8.i8, v24), v24);
    *(int8x8_t *)a6.i8 = vorr_s8((int8x8_t)vceqz_f32(*(float32x2_t *)v8.i8), *(int8x8_t *)a6.i8);
    int8x16_t v26 = (int8x16_t)vcltzq_s32(a6);
    *(int8x8_t *)a5.i8 = vbsl_s8(*(int8x8_t *)v26.i8, _D18, (int8x8_t)vmul_f32(vrecps_f32(*(float32x2_t *)v8.i8, v25), vmul_f32(*(float32x2_t *)a5.i8, v25)));
    *(float32x2_t *)v26.i8 = vminnm_f32(v23, *(float32x2_t *)a5.i8);
    *(float32x2_t *)v8.i8 = vmaxnm_f32(v23, *(float32x2_t *)a5.i8);
    *(int32x2_t *)a8.i8 = vdup_n_s32(0x358637BDu);
    *(int32x2_t *)a5.i8 = vcgt_f32(*(float32x2_t *)a8.i8, *(float32x2_t *)v26.i8);
    int8x16_t v27 = (int8x16_t)vcltzq_s32(a5);
    float32x2_t v28 = (float32x2_t)vbslq_s8(v27, v8, v26).u64[0];
    *(float32x2_t *)a5.i8 = vminnm_f32(a1, a4);
    *(int8x8_t *)v9.i8 = vand_s8((int8x8_t)vcgt_f32(v28, *(float32x2_t *)a8.i8), (int8x8_t)vcgt_f32((float32x2_t)vdup_n_s32(0x3F7FFFEFu), v28));
    if ((vpmax_u32(*(uint32x2_t *)v9.i8, *(uint32x2_t *)v9.i8).u32[0] & 0x80000000) != 0)
    {
      v29.i64[0] = 0x4000000040000000;
      v29.i64[1] = 0x4000000040000000;
      float32x2_t v30 = (float32x2_t)vbslq_s8(v27, v29, v8).u64[0];
      *(float32x2_t *)v29.i8 = vsub_f32(_D6, v28);
      __asm { FMOV            V17.2S, #3.0 }
      *(float32x2_t *)v29.i8 = vminnm_f32(*(float32x2_t *)a5.i8, vmla_f32(vmul_f32(vmul_f32(v28, a4), vmul_f32(v28, v28)), *(float32x2_t *)v29.i8, vmla_f32(vmul_f32(vmul_f32(*(float32x2_t *)v29.i8, *(float32x2_t *)v29.i8), a1), vmla_f32(vmul_f32(v28, a3), a2, *(float32x2_t *)v29.i8), vmul_f32(v28, _D17))));
      a5.i64[0] = vbslq_s8((int8x16_t)vcltzq_s32(v9), v29, (int8x16_t)a5).u64[0];
      float32x2_t v32 = vsub_f32(_D6, v30);
      *(int32x2_t *)a7.i8 = vcgt_f32(v32, *(float32x2_t *)a8.i8);
      if ((vpmax_u32(*(uint32x2_t *)a7.i8, *(uint32x2_t *)a7.i8).u32[0] & 0x80000000) != 0) {
        *(int8x8_t *)a5.i8 = vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(a7), (int8x8_t)vminnm_f32(*(float32x2_t *)a5.i8, vmla_f32(vmul_f32(vmul_f32(v30, a4), vmul_f32(v30, v30)), v32, vmla_f32(vmul_f32(vmul_f32(v32, v32), a1), vmla_f32(vmul_f32(v30, a3), a2, v32), vmul_f32(v30, _D17)))), *(int8x8_t *)a5.i8);
      }
    }
  }
  return *(double *)a5.i64;
}

void RB::ObjectTable::~ObjectTable(const void ***this)
{
  uint32x2_t v2 = *this;
  uint64_t v3 = *((unsigned int *)this + 2);
  if (v3)
  {
    uint64_t v4 = 8 * v3;
    do
    {
      unint64_t v5 = (unint64_t)*v2;
      if (*v2)
      {
        if (v5) {
          (**(void (***)(unint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL))(v5 & 0xFFFFFFFFFFFFFFFELL);
        }
        else {
          CFRelease((CFTypeRef)v5);
        }
      }
      ++v2;
      v4 -= 8;
    }
    while (v4);
    uint32x2_t v2 = *this;
  }
  if (v2) {
    free(v2);
  }
}

void RB::Path::Mapper::push_affine(RB::Path::Mapper *this, const CGAffineTransform *a2)
{
}

void RB::Stroke::FixedWidthLineBounds::closepath(float32x2_t *this, double a2, double a3)
{
}

void RB::Stroke::LineBounds::closepath(float32x2_t *this, double a2, double a3)
{
  if (!this[8].i8[0])
  {
    LODWORD(a3) = this[7].i32[1];
    RB::Stroke::LineBounds::lineto(this, this[4], a3);
    LODWORD(v4) = this[7].i32[1];
    RB::Stroke::LineBounds::add_join(this, this[4], v4, this[6], this[5]);
    this[8].i8[0] = 1;
  }
}

uint64_t RB::Path::Mapper::add_relative_arc(__n128 *a1, float64x2_t *a2, float64x2_t a3, double a4, double a5, double a6)
{
  double v8 = a5;
  __double2 v10 = __sincos_stret(a5);
  v11.f64[0] = v10.__cosval;
  v11.f64[1] = v10.__sinval;
  float64x2_t v12 = vmlaq_n_f64(a3, v11, a4);
  unint64_t v13 = a1[20].n128_u64[1];
  if (v13) {
    BOOL v14 = (__n128 *)(v13 + 64);
  }
  else {
    BOOL v14 = a1 + 23;
  }
  float64x2_t v42 = v12;
  if (v14->n128_u8[0]) {
    uint64_t result = RB::Path::Mapper::elt_moveto(a1, a2, v12);
  }
  else {
    uint64_t result = RB::Path::Mapper::elt_lineto(a1, a2, v12);
  }
  v16.f64[0] = v10.__sinval;
  float64x2_t v17 = v42;
  if ((*(void *)&a6 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    float64x2_t v38 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&a4, 0);
    double v18 = dbl_214219B70[a6 < 0.0];
    double v19 = 1.0;
    if (a6 < 0.0) {
      double v19 = -1.0;
    }
    double v37 = v19;
    float64x2_t v36 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(dbl_214219B80[a6 < 0.0] * a4), 0);
    v16.f64[1] = v10.__cosval;
    for (uint64_t i = 1023; a6 > 0.0 && a6 > v18 || a6 < 0.0 && a6 < v18; --i)
    {
      if (!i) {
        return result;
      }
      *(void *)&v23.f64[0] = vdupq_laneq_s64((int64x2_t)v16, 1).u64[0];
      v23.f64[1] = -v16.f64[0];
      int8x16_t v43 = (int8x16_t)vmulq_n_f64(v23, v37);
      v16.f64[0] = -v16.f64[0];
      float64x2_t v24 = vmlaq_f64(v17, v36, v16);
      *(void *)&v25.f64[1] = v43.i64[1];
      v25.f64[0] = -*(double *)v43.i64;
      float64x2_t v40 = vmlaq_f64(a3, v38, (float64x2_t)vextq_s8(v43, v43, 8uLL));
      uint64_t result = RB::Path::Mapper::elt_cubeto((uint64_t)a1, a2, v24, vmlsq_f64(v40, v36, v25), v40);
      double v8 = v8 + v18;
      a6 = a6 - v18;
      float64x2_t v17 = v40;
      float64x2_t v16 = (float64x2_t)v43;
    }
    if (fabs(a6) > 0.00000999999975)
    {
      float64x2_t v44 = v17;
      float64x2_t v41 = v16;
      __double2 v26 = __sincos_stret(a6 * 0.5);
      __double2 v28 = __sincos_stret(v8 + a6);
      v27.f64[0] = v28.__cosval;
      v29.f64[0] = -v28.__sinval;
      v29.f64[1] = v28.__cosval;
      v27.f64[1] = v28.__sinval;
      float64x2_t v30 = vmlaq_f64(a3, v38, v27);
      double v31 = (4.0 - v26.__cosval * 4.0) * a4 / (v26.__sinval * 3.0);
      v32.f64[1] = v41.f64[1];
      v32.f64[0] = -v41.f64[0];
      float64x2_t v33 = vmlaq_n_f64(v44, v32, v31);
      float64x2_t v34 = vmlsq_lane_f64(v30, v29, v31, 0);
      return RB::Path::Mapper::elt_cubeto((uint64_t)a1, a2, v33, v34, v30);
    }
  }
  return result;
}

uint64_t RB::Path::NestedCallbacks::NestedCallbacks(RBPathCallbacks const*,unsigned long)::$_3::__invoke(uint64_t a1, uint64_t a2, unint64_t a3)
{
  return a1;
}

uint64_t anonymous namespace'::make_single_element_path<RBPathMakeRoundedRect::RoundedRectArgs>(RBPathMakeRoundedRect::RoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*,void *,BOOL (*)(void const*,RBPathElement,double const*,void const))#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, uint64_t))
{
  if (*(unsigned char *)(a1 + 72)) {
    uint64_t v4 = a1 + 80;
  }
  else {
    uint64_t v4 = 0;
  }
  if (*(unsigned char *)(a1 + 64)) {
    uint64_t v5 = 9;
  }
  else {
    uint64_t v5 = 8;
  }
  return a3(a2, v5, a1 + 16, v4);
}

double RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::bounds(uint64_t a1)
{
  v2.callbacks = *(RBPathCallbacks **)(a1 + 48);
  v2.info = (void *)(a1 + 56);
  return RB::Coverage::Path::bounds(v2);
}

void RB::Path::Mapper::push_cut(RB::Path::Mapper *this, double a2, double a3)
{
}

void *RB::Path::BufferedTransform::closepath(void *this)
{
  float64x2_t v1 = this;
  RBPath v2 = this + 1;
  uint64_t v3 = this[18];
  size_t v4 = v3 + 1;
  if (this[19] < (unint64_t)(v3 + 1))
  {
    this = RB::vector<unsigned char,128ul,unsigned long>::reserve_slow(this + 1, v4);
    uint64_t v3 = v1[18];
    size_t v4 = v3 + 1;
  }
  uint64_t v5 = (void *)v1[17];
  if (!v5) {
    uint64_t v5 = v2;
  }
  *((unsigned char *)v5 + v3) = 4;
  v1[18] = v4;
  return this;
}

uint64_t RBDrawingStateDrawDisplayList2(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "_drawInState:alpha:", a1);
}

uint64_t RBPathIsEmpty(uint64_t a1, uint64_t a2)
{
  if ((_UNKNOWN *)a2 == &empty_path_callbacks) {
    return 1;
  }
  if (*(unsigned char *)(a2 + 2))
  {
    RBPath v2 = *(uint64_t (**)(void))(a2 + 40);
    if (v2)
    {
      return v2();
    }
  }
  else
  {
    RBPath v2 = *(uint64_t (**)(void))(a2 + 40);
    if (v2)
    {
      return v2();
    }
  }
  char v4 = 1;
  RBPathApplyElements(a1, a2, (uint64_t)&v4, (uint64_t)RBPathIsEmpty::$_0::__invoke<void *,RBPathElement,double const*,void const*>);
  return v4 != 0;
}

uint64_t RB::Path::Storage::MapCache::apply(os_unfair_lock_s *a1, uint64_t a2, RB::Path::Storage *a3, uint64_t a4, atomic_uint *a5)
{
  os_unfair_lock_lock(a1);
  int32x4_t v9 = RB::UntypedTable::lookup((RB::UntypedTable *)&a1[2], (uint64_t *)*(unsigned int *)(a2 + 12), 0);
  if (!v9) {
    goto LABEL_11;
  }
  __double2 v10 = (uint64_t *)v9[2];
  uint64_t v11 = v9[3];
  if (!v10) {
    __double2 v10 = v9;
  }
  if (!v11) {
    goto LABEL_11;
  }
  float64x2_t v12 = (atomic_uint **)(v10 + 1);
  uint64_t v13 = 16 * v11;
  while (*(v12 - 1) != a5)
  {
    v12 += 2;
    v13 -= 16;
    if (!v13) {
      goto LABEL_11;
    }
  }
  BOOL v14 = *v12;
  if (!*v12)
  {
LABEL_11:
    os_unfair_lock_unlock(a1);
    operator new();
  }
  atomic_fetch_add_explicit(v14 + 2, 1u, memory_order_relaxed);
  os_unfair_lock_unlock(a1);
  uint64_t v15 = RB::Path::Storage::apply_elements((RB::Path::Storage *)(v14 + 4), a3);
  if (atomic_fetch_add_explicit(v14 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v14 + 8))(v14);
  }
  return v15;
}

void RB::Path::Mapper::pop(RB::Path::Mapper *this)
{
  float64x2_t v1 = (RB::Path::Mapper::StackItem *)*((void *)this + 41);
  if (v1)
  {
    uint64_t v3 = (void (***)(void))*((void *)v1 + 2);
    *((void *)this + 41) = *((void *)v1 + 1);
    (**v3)(v3);
    RB::Path::Mapper::StackItem::~StackItem(v1);
    *(void *)float64x2_t v1 = *((void *)this + 38);
    *((void *)this + 38) = v1;
  }
}

void RB::Path::Mapper::StackItem::~StackItem(RB::Path::Mapper::StackItem *this)
{
  switch(*((unsigned char *)this + 65))
  {
    case 0:
      float64x2_t v1 = (RB::Path::BooleanTransform *)*((void *)this + 2);
      if (v1)
      {
        unsigned int v2 = -221838953;
        goto LABEL_34;
      }
      break;
    case 1:
      uint64_t v3 = (RB::Path::BooleanTransform *)*((void *)this + 2);
      if (v3)
      {
        *(void *)uint64_t v3 = &unk_26C4ED930;
        char v4 = (void *)*((void *)v3 + 532);
        if (v4) {
          free(v4);
        }
        uint64_t v5 = (void *)*((void *)v3 + 17);
        if (v5) {
          free(v5);
        }
        float64x2_t v1 = v3;
        unsigned int v2 = -733151764;
        goto LABEL_34;
      }
      break;
    case 2:
      float64x2_t v1 = (RB::Path::BooleanTransform *)*((void *)this + 2);
      if (v1)
      {
        unsigned int v2 = 1875108758;
        goto LABEL_34;
      }
      break;
    case 3:
      char v6 = (RB::Path::BooleanTransform *)*((void *)this + 2);
      if (v6)
      {
        float32x2_t v7 = (void *)*((void *)v6 + 28);
        if (v7) {
          free(v7);
        }
        float64x2_t v1 = v6;
        unsigned int v2 = 548042431;
        goto LABEL_34;
      }
      break;
    case 4:
      double v8 = (RB::Path::BooleanTransform *)*((void *)this + 2);
      if (v8)
      {
        int32x4_t v9 = (void *)*((void *)v8 + 38);
        if (v9) {
          free(v9);
        }
        __double2 v10 = (void *)*((void *)v8 + 29);
        if (v10) {
          free(v10);
        }
        float64x2_t v1 = v8;
        unsigned int v2 = -986321111;
        goto LABEL_34;
      }
      break;
    case 5:
      uint64_t v11 = (RB::Path::BooleanTransform *)*((void *)this + 2);
      RB::Path::BooleanTransform::commit(v11);
      if (v11)
      {
        float64x2_t v12 = (const void *)*((void *)v11 + 4);
        if (v12) {
          CFRelease(v12);
        }
        *(void *)uint64_t v11 = &unk_26C4ED870;
        uint64_t v13 = (const void *)*((void *)v11 + 1);
        if (v13) {
          CFRelease(v13);
        }
        float64x2_t v1 = v11;
        unsigned int v14 = -217717331;
        goto LABEL_39;
      }
      break;
    case 6:
      uint64_t v15 = (RB::Path::BooleanTransform *)*((void *)this + 2);
      if (v15)
      {
        *(void *)uint64_t v15 = &unk_26C4ED930;
        float64x2_t v16 = (void *)*((void *)v15 + 532);
        if (v16) {
          free(v16);
        }
        float64x2_t v17 = (void *)*((void *)v15 + 17);
        if (v17) {
          free(v17);
        }
        float64x2_t v1 = v15;
        unsigned int v2 = -18588592;
LABEL_34:
        uint64_t v18 = v2 | 0x10A1C4000000000;
        goto LABEL_40;
      }
      break;
    case 7:
      double v19 = (RB::Path::BooleanTransform *)*((void *)this + 2);
      if (v19)
      {
        float32x2_t v20 = (void *)*((void *)v19 + 43);
        if (v20) {
          free(v20);
        }
        float64x2_t v1 = v19;
        unsigned int v14 = 590185972;
LABEL_39:
        uint64_t v18 = v14 | 0x10E1C4000000000;
LABEL_40:
        MEMORY[0x21669AC10](v1, v18);
      }
      break;
    default:
      return;
  }
}

void RB::Path::Cutter::endpath(__n128 *this)
{
  uint64_t v76 = *MEMORY[0x263EF8340];
  if (this[268].n128_f32[0] <= 0.0 && this[268].n128_f32[1] >= 1.0)
  {
    uint64_t v36 = this[267].n128_i64[1];
    RB::Path::BufferedTransform::apply(this, v36);
  }
  else
  {
    long long v73 = 0u;
    v71 = &unk_26C4E81C8;
    uint64_t v74 = 128;
    double v75 = 0.0;
    RB::Path::BufferedTransform::apply(this, (uint64_t)&v71);
    LODWORD(v2) = this[268].n128_u32[0];
    float v3 = this[268].n128_f32[1];
    unint64_t v41 = this[267].n128_u64[1];
    __n128 v42 = 0u;
    float64x2_t v43 = 0u;
    unint64_t v4 = this[9].n128_u64[0];
    if (this[8].n128_u64[1]) {
      uint64_t v5 = (unsigned __int8 *)this[8].n128_u64[1];
    }
    else {
      uint64_t v5 = &this->n128_u8[8];
    }
    __int16 v44 = 257;
    BOOL v45 = 0;
    if (v4)
    {
      uint64_t v6 = 0;
      double v7 = v75 * *(float *)&v2;
      double v8 = v75 * v3;
      if (this[266].n128_u64[0]) {
        int32x4_t v9 = (float64x2_t *)this[266].n128_u64[0];
      }
      else {
        int32x4_t v9 = (float64x2_t *)&this[10];
      }
      __n128 v10 = (__n128)vdupq_n_s64(0x3FD5555555555555uLL);
      float64x2_t v37 = (float64x2_t)v10;
      v10.n128_u32[0] = 0;
      double v11 = 1.0;
      double v38 = v75 * v3;
      while (1)
      {
        switch(*v5)
        {
          case 0u:
            float64x2_t v12 = *v9++;
            __n128 v42 = (__n128)v12;
            *((void *)&v2 + 1) = *(void *)&v12.f64[1];
            float64x2_t v43 = v12;
            __int16 v44 = 257;
            goto LABEL_61;
          case 1u:
            int v13 = 0;
            unint64_t v14 = 1;
            goto LABEL_17;
          case 2u:
            int v13 = 0;
            unint64_t v14 = 2;
            goto LABEL_17;
          case 3u:
            int v13 = 0;
            unint64_t v14 = 3;
            goto LABEL_17;
          default:
            unint64_t v14 = 0;
            int v13 = 1;
LABEL_17:
            uint64_t v15 = (uint64_t *)v73;
            if (!(void)v73) {
              uint64_t v15 = &v72;
            }
            double v16 = *(double *)&v15[v6];
            double v17 = v10.n128_f32[0];
            double v18 = 0.0;
            if (v7 > v17) {
              double v18 = fmax((v7 - v17) / v16, 0.0);
            }
            double v19 = v16 + v17;
            double v20 = 1.0;
            if (v8 < v16 + v17) {
              double v20 = fmin((v8 - v17) / v16, v11);
            }
            if ((_BYTE)v44)
            {
              BOOL v45 = v18 == 0.0;
              LOBYTE(v44) = 0;
            }
            if (v18 >= v20)
            {
              if (!v13)
              {
                __n128 v10 = (__n128)v9[v14 - 1];
                float64x2_t v43 = (float64x2_t)v10;
                goto LABEL_60;
              }
              __n128 v10 = v42;
              goto LABEL_59;
            }
            if (v14 >= 2)
            {
              if (v14 == 2)
              {
                float64x2_t v30 = *v9;
                float64x2_t v31 = v9[1];
                *(float64x2_t *)&v60[0].v = vmlaq_f64(*v9, v37, vsubq_f64(v43, *v9));
                *(float64x2_t *)&v69[0].v = v31;
                *(float64x2_t *)&v70[0].v = vmlaq_f64(v30, v37, vsubq_f64(v31, v30));
                CG::Cubic::Cubic((CG::Cubic *)&v46, (const Point *)&v43, v60, v70, v69);
                float64x2_t v32 = v47;
                float64x2_t v33 = v48;
                float64x2_t v34 = v49;
              }
              else
              {
                float64x2_t v32 = *v9;
                float64x2_t v33 = v9[1];
                float64x2_t v34 = v9[2];
              }
              *(float64x2_t *)&v69[0].v = v32;
              *(float64x2_t *)&v70[0].v = v43;
              *(float64x2_t *)&v67[0].v = v34;
              *(float64x2_t *)&v68[0].v = v33;
              if (v18 > 0.0 || v20 < v11)
              {
                CG::Cubic::Cubic((CG::Cubic *)v60, v70, v69, v68, v67);
                if (v18 > 0.00100000005) {
                  double v18 = CG::Cubic::index((float64x2_t *)v60, v18 * v16, 0.5);
                }
                if (v20 < 0.999000013) {
                  double v20 = CG::Cubic::index((float64x2_t *)v60, v20 * v16, 0.5);
                }
                if (v18 > 0.00100000005)
                {
                  CG::Cubic::split((float64x2_t *)v60, v18, &v46);
                  long long v64 = v57;
                  long long v65 = v58;
                  long long v66 = v59;
                  *(_OWORD *)&v60[0].v = v53;
                  float64x2_t v61 = v54;
                  float64x2_t v62 = v55;
                  float64x2_t v63 = v56;
                  double v20 = (v20 - v18) / (v11 - v18);
                }
                if (v20 < 0.999000013)
                {
                  CG::Cubic::split((float64x2_t *)v60, v20, &v46);
                  long long v64 = v50;
                  long long v65 = v51;
                  long long v66 = v52;
                  *(float64x2_t *)&v60[0].v = v46;
                  float64x2_t v61 = v47;
                  float64x2_t v62 = v48;
                  float64x2_t v63 = v49;
                }
                *(float64x2_t *)&v69[0].v = v61;
                *(_OWORD *)&v70[0].v = *(_OWORD *)&v60[0].v;
                *(float64x2_t *)&v67[0].v = v63;
                *(float64x2_t *)&v68[0].v = v62;
              }
              unint64_t v35 = v41;
              if (HIBYTE(v44))
              {
                HIBYTE(v44) = 0;
                (*(void (**)(unint64_t, __n128))(*(void *)v41 + 16))(v41, *(__n128 *)&v70[0].v);
                unint64_t v35 = v41;
              }
              (*(void (**)(unint64_t, __n128, __n128, __n128))(*(void *)v35 + 40))(v35, *(__n128 *)&v69[0].v, *(__n128 *)&v68[0].v, *(__n128 *)&v67[0].v);
              __n128 v10 = *(__n128 *)&v67[0].v;
LABEL_59:
              float64x2_t v43 = (float64x2_t)v10;
              goto LABEL_60;
            }
            double v21 = v7;
            float32x2_t v22 = &v9->f64[1];
            if (v13) {
              float64x2_t v23 = (double *)&v42;
            }
            else {
              float64x2_t v23 = (double *)v9;
            }
            if (v13) {
              float32x2_t v22 = &v42.n128_f64[1];
            }
            float64x2_t v24 = v43;
            double v25 = *v23 - v43.f64[0];
            double v26 = *v22 - v43.f64[1];
            unint64_t v27 = v41;
            if (HIBYTE(v44))
            {
              v28.n128_f64[0] = v43.f64[0] + v25 * v18;
              HIBYTE(v44) = 0;
              v28.n128_f64[1] = v43.f64[1] + v26 * v18;
              (*(void (**)(unint64_t, __n128))(*(void *)v41 + 16))(v41, v28);
              unint64_t v27 = v41;
            }
            v10.n128_f64[0] = v24.f64[0] + v25 * v20;
            *(double *)&long long v2 = v24.f64[1] + v26 * v20;
            __n128 v39 = v10;
            long long v40 = v2;
            v10.n128_f64[1] = *(double *)&v2;
            (*(void (**)(unint64_t, __n128))(*(void *)v27 + 24))(v27, v10);
            *((void *)&v2 + 1) = v39.n128_u64[1];
            v10.n128_u64[1] = *((void *)&v40 + 1);
            *(void *)&v43.f64[0] = v39.n128_u64[0];
            *(void *)&v43.f64[1] = v40;
            double v11 = 1.0;
            char v29 = v13 ^ 1;
            if (v20 != 1.0) {
              char v29 = 1;
            }
            double v7 = v21;
            double v8 = v38;
            if ((v29 & 1) == 0 && v45)
            {
              BOOL v45 = 0;
              (*(void (**)(unint64_t))(*(void *)v41 + 8))(v41);
            }
LABEL_60:
            v9 += v14;
            v10.n128_f32[0] = v19;
            ++v6;
LABEL_61:
            ++v5;
            if (!--v4) {
              goto LABEL_62;
            }
            break;
        }
      }
    }
LABEL_62:
    if ((void)v73) {
      free((void *)v73);
    }
  }
}

_DWORD *RB::Path::Storage::MapCache::Destination::cubeto(uint64_t a1, __n128 a2, __n128 a3, __n128 a4)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  v5[0] = a2;
  v5[1] = a3;
  v5[2] = a4;
  return RB::Path::Storage::append_element((RB::Path::Storage *)(*(void *)(a1 + 8) + 16), (const char *)3, (double *)v5, 0);
}

uint64_t ___ZNK3__0clEPKvPvPFbS2_13RBPathElementPKdS1_E_block_invoke(uint64_t a1, unsigned __int8 *a2, unsigned char *a3)
{
  uint64_t result = (*(uint64_t (**)(void, void, void, void))(a1 + 40))(*(void *)(a1 + 48), *a2, *((void *)a2 + 1), 0);
  if ((result & 1) == 0)
  {
    *a3 = 1;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
  return result;
}

uint64_t RB::Path::anonymous namespace'::append_element_callback(RB::Path::Storage *a1, const char *a2, double *a3, int *a4)
{
  return 1;
}

_DWORD *RB::Path::Storage::append_element(RB::Path::Storage *this, const char *a2, double *__src, int *a4)
{
  unsigned int v4 = a2;
  if (a2 >= 0x19) {
    RB::precondition_failure((RB *)"invalid path element: %d", a2, __src, a2);
  }
  double v7 = this;
  if ((int)a2 > 18)
  {
    if (a2 == 19)
    {
      if (a4 && (*a4 == 1 || a4[1] == 1)) {
        *((_DWORD *)this + 2) |= 4u;
      }
      unsigned int v4 = 0x13u;
    }
    else if (a2 == 24)
    {
      if (a4 && a4[1] == 1) {
        *((_DWORD *)this + 2) |= 4u;
      }
      unsigned int v4 = 0x18u;
    }
  }
  else if (((a2 - 8) < 2 {
          || (a2 - 10) < 2 && __src[6] == 0.0 && __src[7] == 0.0)
  }
         && __src[4] == 0.0)
  {
    if (__src[5] == 0.0) {
      unsigned int v4 = 6;
    }
    else {
      unsigned int v4 = a2;
    }
  }
  uint64_t v8 = *(void *)this;
  if (*(void *)this)
  {
    *(void *)this = 0;
    if (v8)
    {
      this = (RB::Path::Storage *)(v8 & 0xFFFFFFFFFFFFFFFCLL);
      if ((v8 & 0xFFFFFFFFFFFFFFFCLL) != 0) {
        this = (RB::Path::Storage *)MEMORY[0x21669ABF0](this, 0x1000C8052888210);
      }
    }
  }
  unsigned int v9 = *((_DWORD *)v7 + 2);
  if ((v9 & 0x20) != 0)
  {
    __n128 v10 = (os_unfair_lock_s *)RB::Path::Storage::MapCache::shared(this);
    RB::Path::Storage::MapCache::remove(v10, v7);
    unsigned int v9 = *((_DWORD *)v7 + 2);
  }
  if (v9)
  {
    double v11 = (const void *)*((void *)v7 + 7);
    if (v11)
    {
      *((void *)v7 + 7) = 0;
      CFRelease(v11);
      unsigned int v9 = *((_DWORD *)v7 + 2);
    }
  }
  uint64_t v12 = (v9 >> 8) & 0xFFF;
  if (v9) {
    uint64_t v13 = *((void *)v7 + 3);
  }
  else {
    uint64_t v13 = (v9 >> 8) & 0xFFF;
  }
  unsigned int v14 = RB::Path::Storage::append_element(RBPathElement,double const*,void const*)::elt_flags[4 * v4] | v9 & 0xFFFFFFF7 | (8 * (v13 == 0));
  *((_DWORD *)v7 + 2) = v14;
  size_t v15 = __RBPathElementArgumentCount[v4];
  if (__RBPathElementArgumentCount[v4])
  {
    char v16 = 96;
    double v17 = __src;
    uint64_t v18 = __RBPathElementArgumentCount[v4];
    while (1)
    {
      double v19 = fabs(*v17);
      if (v19 > 32767.0) {
        break;
      }
      if ((v16 & 0x20) != 0 && vabdd_f64(floor(v19 + 0.5), v19) > 0.00000999999975) {
        v16 &= ~0x20u;
      }
      ++v17;
      if (!--v18)
      {
        if (a4) {
          goto LABEL_46;
        }
        goto LABEL_68;
      }
    }
    char v16 = 0;
    if (!a4) {
      goto LABEL_68;
    }
  }
  else
  {
    char v16 = 96;
    if (!a4)
    {
LABEL_68:
      int v20 = 0;
LABEL_69:
      char v22 = v4;
      goto LABEL_77;
    }
  }
LABEL_46:
  int v20 = 0;
  int v21 = 3;
  char v22 = v4;
  switch(v4)
  {
    case 0x10u:
    case 0x12u:
    case 0x16u:
    case 0x17u:
      goto LABEL_77;
    case 0x11u:
    case 0x15u:
      goto LABEL_59;
    case 0x13u:
      unint64_t v23 = *((void *)a4 + 1);
      if (v23 >= 0x1000) {
        unint64_t v23 = 4096;
      }
      int v20 = 2;
      if (!v16 || !v23) {
        goto LABEL_76;
      }
      float64x2_t v24 = (double *)*((void *)a4 + 2);
      while (1)
      {
        double v25 = fabs(*v24);
        if (v25 > 32767.0) {
          break;
        }
        if ((v16 & 0x20) != 0 && vabdd_f64(floor(v25 + 0.5), v25) > 0.00000999999975) {
          v16 &= ~0x20u;
        }
        ++v24;
        if (!--v23) {
          goto LABEL_75;
        }
      }
      char v16 = 0;
LABEL_75:
      int v20 = 2;
      goto LABEL_76;
    case 0x14u:
      goto LABEL_71;
    case 0x18u:
      int v21 = 4;
LABEL_71:
      char v22 = v4 | 0x80;
      int v20 = v21;
      goto LABEL_77;
    default:
      if (v4 == 4) {
        goto LABEL_69;
      }
LABEL_59:
      int64x2_t v26 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(*((float64x2_t *)a4 + 1), (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*(float64x2_t *)a4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(*((float64x2_t *)a4 + 2)));
      if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v26, 1), (int8x16_t)v26).u64[0] & 0x8000000000000000) != 0) {
        goto LABEL_68;
      }
      if (!v16) {
        goto LABEL_72;
      }
      uint64_t v27 = 0;
      break;
  }
  while (1)
  {
    double v28 = fabs(*(double *)&a4[v27]);
    if (v28 > 32767.0) {
      break;
    }
    if ((v16 & 0x20) != 0 && vabdd_f64(floor(v28 + 0.5), v28) > 0.00000999999975) {
      v16 &= ~0x20u;
    }
    v27 += 2;
    if (v27 == 12) {
      goto LABEL_73;
    }
  }
LABEL_72:
  char v16 = 0;
LABEL_73:
  int v20 = 1;
LABEL_76:
  char v22 = v4 | 0x80;
LABEL_77:
  char v29 = v16 & 0x40;
  if ((v16 & 0x20) != 0) {
    char v29 = 32;
  }
  int v30 = v14 & 1;
  if (v14)
  {
    uint64_t v12 = *((void *)v7 + 3);
    unint64_t v31 = *((void *)v7 + 4);
  }
  else
  {
    unint64_t v31 = v9 >> 20;
  }
  char v32 = v29 | v22;
  uint64_t v33 = v12 + 1;
  if (v31 < v12 + 1)
  {
    RB::Path::Storage::reserve_slow(v7, v12 + 1);
    int v30 = *((_DWORD *)v7 + 2) & 1;
  }
  float64x2_t v34 = (char *)v7 + 16;
  unint64_t v35 = (char *)v7 + 16;
  if (v30) {
    unint64_t v35 = *(char **)v34;
  }
  v35[v12] = v32;
  int v36 = *((_DWORD *)v7 + 2);
  if (v36) {
    *((void *)v7 + 3) = v33;
  }
  else {
    *((_DWORD *)v7 + 2) = v36 & 0xFFF000FF | ((v33 & 0xFFF) << 8);
  }
  uint64_t result = RB::Path::Storage::push_values((uint64_t *)v7, v32, __src, v15);
  switch(v20)
  {
    case 1:
      char v40 = v32;
      unint64_t v41 = (uint64_t *)v7;
      __n128 v42 = (double *)a4;
      size_t v43 = 6;
      goto LABEL_166;
    case 2:
      unint64_t v44 = *((unsigned int *)v7 + 2);
      int v45 = *((_DWORD *)v7 + 2) & 1;
      if (v44)
      {
        uint64_t v46 = *((void *)v7 + 3);
        unint64_t v47 = *((void *)v7 + 4);
      }
      else
      {
        uint64_t v46 = (v44 >> 8) & 0xFFF;
        unint64_t v47 = v44 >> 20;
      }
      int v55 = *a4;
      uint64_t v56 = v46 + 1;
      if (v47 < v46 + 1)
      {
        RB::Path::Storage::reserve_slow(v7, v46 + 1);
        int v45 = *((_DWORD *)v7 + 2) & 1;
      }
      long long v57 = (char *)v7 + 16;
      if (v45) {
        long long v57 = *(char **)v34;
      }
      v57[v46] = v55;
      unsigned int v58 = *((_DWORD *)v7 + 2);
      if (v58)
      {
        *((void *)v7 + 3) = v56;
      }
      else
      {
        unsigned int v58 = v58 & 0xFFF000FF | ((v56 & 0xFFF) << 8);
        *((_DWORD *)v7 + 2) = v58;
      }
      int v65 = v58 & 1;
      if (v58)
      {
        uint64_t v66 = *((void *)v7 + 3);
        unint64_t v67 = *((void *)v7 + 4);
      }
      else
      {
        uint64_t v66 = (v58 >> 8) & 0xFFF;
        unint64_t v67 = v58 >> 20;
      }
      int v71 = a4[1];
      uint64_t v72 = v66 + 1;
      if (v67 < v66 + 1)
      {
        RB::Path::Storage::reserve_slow(v7, v66 + 1);
        int v65 = *((_DWORD *)v7 + 2) & 1;
      }
      long long v73 = (char *)v7 + 16;
      if (v65) {
        long long v73 = *(char **)v34;
      }
      v73[v66] = v71;
      unsigned int v74 = *((_DWORD *)v7 + 2);
      if (v74)
      {
        *((void *)v7 + 3) = v72;
      }
      else
      {
        unsigned int v74 = v74 & 0xFFF000FF | ((v72 & 0xFFF) << 8);
        *((_DWORD *)v7 + 2) = v74;
      }
      if (*((void *)a4 + 1) >= 0x1000uLL) {
        uint64_t v79 = 4096;
      }
      else {
        uint64_t v79 = *((void *)a4 + 1);
      }
      int v80 = v74 & 1;
      if (v74)
      {
        uint64_t v81 = *((void *)v7 + 3);
        unint64_t v82 = *((void *)v7 + 4);
      }
      else
      {
        uint64_t v81 = (v74 >> 8) & 0xFFF;
        unint64_t v82 = v74 >> 20;
      }
      uint64_t v87 = v81 + 2;
      if (v82 >= v81 + 2)
      {
        if (!v80) {
          goto LABEL_154;
        }
        goto LABEL_153;
      }
      RB::Path::Storage::reserve_slow(v7, v81 + 2);
      if (*((_DWORD *)v7 + 2)) {
LABEL_153:
      }
        float64x2_t v34 = *(char **)v34;
LABEL_154:
      *(_WORD *)&v34[v81] = v79;
      int v88 = *((_DWORD *)v7 + 2);
      if (v88) {
        *((void *)v7 + 3) = v87;
      }
      else {
        *((_DWORD *)v7 + 2) = v88 & 0xFFF000FF | ((v87 & 0xFFF) << 8);
      }
      __n128 v42 = (double *)*((void *)a4 + 2);
      char v40 = v32;
      unint64_t v41 = (uint64_t *)v7;
      size_t v43 = v79;
LABEL_166:
      uint64_t result = RB::Path::Storage::push_values(v41, v40, v42, v43);
      goto LABEL_167;
    case 3:
      unint64_t v48 = *((unsigned int *)v7 + 2);
      if (v48)
      {
        uint64_t v49 = *((void *)v7 + 3);
        unint64_t v50 = *((void *)v7 + 4);
      }
      else
      {
        uint64_t v49 = (v48 >> 8) & 0xFFF;
        unint64_t v50 = v48 >> 20;
      }
      uint64_t v59 = v49 + 2;
      if (v50 >= v49 + 2)
      {
        if ((*((_DWORD *)v7 + 2) & 1) == 0) {
          goto LABEL_108;
        }
        goto LABEL_107;
      }
      uint64_t result = RB::Path::Storage::reserve_slow(v7, v49 + 2);
      if (*((_DWORD *)v7 + 2)) {
LABEL_107:
      }
        float64x2_t v34 = *(char **)v34;
LABEL_108:
      *(_WORD *)&v34[v49] = *(_WORD *)a4;
      int v60 = *((_DWORD *)v7 + 2);
      if (v60) {
        *((void *)v7 + 3) = v59;
      }
      else {
        *((_DWORD *)v7 + 2) = v60 & 0xFFF000FF | ((v59 & 0xFFF) << 8);
      }
LABEL_167:
      if (v4 == 16 || v4 == 4)
      {
        return RB::Path::Storage::update_single_element(v7, v38, v39);
      }
      return result;
    case 4:
      unint64_t v51 = *((unsigned int *)v7 + 2);
      int v52 = *((_DWORD *)v7 + 2) & 1;
      if (v51)
      {
        uint64_t v53 = *((void *)v7 + 3);
        unint64_t v54 = *((void *)v7 + 4);
      }
      else
      {
        uint64_t v53 = (v51 >> 8) & 0xFFF;
        unint64_t v54 = v51 >> 20;
      }
      int v61 = *a4;
      uint64_t v62 = v53 + 1;
      if (v54 < v53 + 1)
      {
        uint64_t result = RB::Path::Storage::reserve_slow(v7, v53 + 1);
        int v52 = *((_DWORD *)v7 + 2) & 1;
      }
      float64x2_t v63 = (char *)v7 + 16;
      if (v52) {
        float64x2_t v63 = *(char **)v34;
      }
      v63[v53] = v61;
      unsigned int v64 = *((_DWORD *)v7 + 2);
      if (v64)
      {
        *((void *)v7 + 3) = v62;
      }
      else
      {
        unsigned int v64 = v64 & 0xFFF000FF | ((v62 & 0xFFF) << 8);
        *((_DWORD *)v7 + 2) = v64;
      }
      int v68 = v64 & 1;
      if (v64)
      {
        uint64_t v69 = *((void *)v7 + 3);
        unint64_t v70 = *((void *)v7 + 4);
      }
      else
      {
        uint64_t v69 = (v64 >> 8) & 0xFFF;
        unint64_t v70 = v64 >> 20;
      }
      int v75 = a4[1];
      uint64_t v76 = v69 + 1;
      if (v70 < v69 + 1)
      {
        uint64_t result = RB::Path::Storage::reserve_slow(v7, v69 + 1);
        int v68 = *((_DWORD *)v7 + 2) & 1;
      }
      double v77 = (char *)v7 + 16;
      if (v68) {
        double v77 = *(char **)v34;
      }
      v77[v69] = v75;
      unsigned int v78 = *((_DWORD *)v7 + 2);
      if (v78)
      {
        *((void *)v7 + 3) = v76;
      }
      else
      {
        unsigned int v78 = v78 & 0xFFF000FF | ((v76 & 0xFFF) << 8);
        *((_DWORD *)v7 + 2) = v78;
      }
      if (*((void *)a4 + 1) >= 0x800uLL) {
        uint64_t v83 = 2048;
      }
      else {
        uint64_t v83 = *((void *)a4 + 1);
      }
      int v84 = v78 & 1;
      if (v78)
      {
        uint64_t v85 = *((void *)v7 + 3);
        unint64_t v86 = *((void *)v7 + 4);
      }
      else
      {
        uint64_t v85 = (v78 >> 8) & 0xFFF;
        unint64_t v86 = v78 >> 20;
      }
      uint64_t v89 = v85 + 2;
      if (v86 < v85 + 2)
      {
        uint64_t result = RB::Path::Storage::reserve_slow(v7, v85 + 2);
        int v84 = *((_DWORD *)v7 + 2) & 1;
      }
      float v90 = (char *)v7 + 16;
      if (v84) {
        float v90 = *(char **)v34;
      }
      *(_WORD *)&v90[v85] = v83;
      unsigned int v91 = *((_DWORD *)v7 + 2);
      if (v91)
      {
        *((void *)v7 + 3) = v89;
        if (!v83) {
          goto LABEL_167;
        }
      }
      else
      {
        unsigned int v91 = v91 & 0xFFF000FF | ((v89 & 0xFFF) << 8);
        *((_DWORD *)v7 + 2) = v91;
        if (!v83) {
          goto LABEL_167;
        }
      }
      uint64_t v92 = 0;
      uint64_t v93 = 16 * v83;
      break;
    default:
      goto LABEL_167;
  }
  while (1)
  {
    if (v91)
    {
      uint64_t v94 = *((void *)v7 + 3);
      unint64_t v95 = *((void *)v7 + 4);
    }
    else
    {
      uint64_t v94 = (v91 >> 8) & 0xFFF;
      unint64_t v95 = v91 >> 20;
    }
    uint64_t v96 = *((void *)a4 + 2);
    int v97 = *(_DWORD *)(v96 + v92);
    uint64_t v98 = v94 + 1;
    if (v95 < v94 + 1)
    {
      uint64_t result = RB::Path::Storage::reserve_slow(v7, v94 + 1);
      unsigned int v91 = *((_DWORD *)v7 + 2);
    }
    float64x2_t v99 = (char *)v7 + 16;
    if (v91) {
      float64x2_t v99 = *(char **)v34;
    }
    v99[v94] = v97;
    unsigned int v100 = *((_DWORD *)v7 + 2);
    if (v100)
    {
      *((void *)v7 + 3) = v98;
    }
    else
    {
      unsigned int v100 = v100 & 0xFFF000FF | ((v98 & 0xFFF) << 8);
      *((_DWORD *)v7 + 2) = v100;
      if ((v100 & 1) == 0)
      {
        uint64_t v102 = (v100 >> 8) & 0xFFF;
        unint64_t v101 = v100 >> 20;
        goto LABEL_184;
      }
    }
    uint64_t v102 = *((void *)v7 + 3);
    unint64_t v101 = *((void *)v7 + 4);
LABEL_184:
    uint64_t v103 = v102 + 12;
    if (v101 < v102 + 12)
    {
      uint64_t result = RB::Path::Storage::reserve_slow(v7, v102 + 12);
      unsigned int v100 = *((_DWORD *)v7 + 2);
    }
    float v104 = (char *)v7 + 16;
    if (v100) {
      float v104 = *(char **)v34;
    }
    float64x2_t v105 = &v104[v102];
    uint64_t v106 = *(void *)(v96 + v92 + 4);
    *((_DWORD *)v105 + 2) = *(_DWORD *)(v96 + v92 + 12);
    *(void *)float64x2_t v105 = v106;
    unsigned int v91 = *((_DWORD *)v7 + 2);
    if (v91)
    {
      *((void *)v7 + 3) = v103;
    }
    else
    {
      unsigned int v91 = v91 & 0xFFF000FF | ((v103 & 0xFFF) << 8);
      *((_DWORD *)v7 + 2) = v91;
    }
    v92 += 16;
    if (v93 == v92) {
      goto LABEL_167;
    }
  }
}

uint64_t *RB::Path::Storage::push_values(uint64_t *this, char a2, double *__src, size_t __n)
{
  size_t v4 = __n;
  uint64_t v6 = this;
  if ((a2 & 0x40) != 0)
  {
    unint64_t v12 = *((unsigned int *)this + 2);
    if (v12)
    {
      uint64_t v13 = this[3];
      size_t v15 = this[4];
      size_t v14 = v13 + 4 * __n;
    }
    else
    {
      uint64_t v13 = (v12 >> 8) & 0xFFF;
      size_t v14 = v13 + 4 * __n;
      size_t v15 = v12 >> 20;
    }
    if (v15 < v14)
    {
      this = (uint64_t *)RB::Path::Storage::reserve_slow((RB::Path::Storage *)this, v14);
      LODWORD(v12) = *((_DWORD *)v6 + 2);
    }
    uint64_t v18 = v6 + 2;
    if (v12) {
      uint64_t v18 = (void *)*v18;
    }
    if (v4)
    {
      double v19 = (float *)((char *)v18 + v13);
      do
      {
        double v20 = *__src++;
        float v21 = v20;
        *v19++ = v21;
        --v4;
      }
      while (v4);
      goto LABEL_33;
    }
  }
  else
  {
    if ((a2 & 0x20) == 0)
    {
      size_t v7 = 8 * __n;
      unint64_t v8 = *((unsigned int *)this + 2);
      int v9 = this[1] & 1;
      if (v8)
      {
        uint64_t v10 = this[3];
        size_t v11 = this[4];
      }
      else
      {
        uint64_t v10 = (v8 >> 8) & 0xFFF;
        size_t v11 = v8 >> 20;
      }
      size_t v14 = v10 + v7;
      if (v11 < v10 + v7)
      {
        RB::Path::Storage::reserve_slow((RB::Path::Storage *)this, v10 + v7);
        int v9 = v6[1] & 1;
      }
      char v22 = v6 + 2;
      if (v9) {
        char v22 = (void *)*v22;
      }
      this = (uint64_t *)memcpy((char *)v22 + v10, __src, v7);
      int v23 = *((_DWORD *)v6 + 2);
      if ((v23 & 1) == 0)
      {
        *((_DWORD *)v6 + 2) = v23 & 0xFFF000FF | ((v14 & 0xFFF) << 8);
        return this;
      }
      goto LABEL_36;
    }
    unint64_t v12 = *((unsigned int *)this + 2);
    if (v12)
    {
      uint64_t v16 = this[3];
      size_t v17 = this[4];
      size_t v14 = v16 + 2 * __n;
    }
    else
    {
      uint64_t v16 = (v12 >> 8) & 0xFFF;
      size_t v14 = v16 + 2 * __n;
      size_t v17 = v12 >> 20;
    }
    if (v17 < v14)
    {
      this = (uint64_t *)RB::Path::Storage::reserve_slow((RB::Path::Storage *)this, v14);
      LODWORD(v12) = *((_DWORD *)v6 + 2);
    }
    float64x2_t v24 = v6 + 2;
    if (v12) {
      float64x2_t v24 = (void *)*v24;
    }
    if (v4)
    {
      double v25 = (_WORD *)((char *)v24 + v16);
      do
      {
        double v26 = *__src++;
        *v25++ = vcvtmd_s64_f64(v26 + 0.5);
        --v4;
      }
      while (v4);
LABEL_33:
      LODWORD(v12) = *((_DWORD *)v6 + 2);
    }
  }
  if ((v12 & 1) == 0)
  {
    *((_DWORD *)v6 + 2) = v12 & 0xFFF000FF | ((v14 & 0xFFF) << 8);
    return this;
  }
LABEL_36:
  v6[3] = v14;
  return this;
}

_DWORD *RB::Path::Storage::update_single_element(_DWORD *this, uint64_t a2, void *a3)
{
  int v3 = this[2];
  if ((v3 & 0x10) == 0)
  {
    size_t v4 = this;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    char v9 = 0;
    uint64_t v8 = 0;
    this = (_DWORD *)RB::Path::NestedCallbacks::single_element_fast((RB::Path::NestedCallbacks *)this, (const RB::Path::Storage *)&v6, a3);
    void v4[2] = v3 & 0xFFFFFFF7;
    if (!v7)
    {
      if (v8)
      {
        unsigned int v5 = v3 & 0xFFFFFFE7 | 0x10;
        if (v8 == 1) {
          unsigned int v5 = v3 | 8;
        }
        void v4[2] = v5;
      }
    }
  }
  return this;
}

BOOL RB::Path::Storage::apply_elements_at_depth(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  if (a4)
  {
    uint64_t v11 = 0;
    if (!RB::Path::NestedCallbacks::first_element(a1, &v11, a4)) {
      return 0;
    }
    size_t v14 = 0;
    uint64_t v15 = 0x400000000;
    uint64_t v8 = a4;
    while (RB::Path::Storage::Iterator::next(&v11, a1, __dst))
    {
      if (v13 <= 0x18u)
      {
        if (((1 << v13) & 0x1DE0000) != 0)
        {
          ++v8;
        }
        else if (v13 == 16)
        {
          if (v8 == a4) {
            break;
          }
          --v8;
        }
      }
      if ((a3(a2) & 1) == 0)
      {
        uint64_t v10 = 0;
        goto LABEL_18;
      }
    }
    uint64_t v10 = 1;
LABEL_18:
    if (v14) {
      free(v14);
    }
    return v10;
  }
  else
  {
    return RB::Path::Storage::apply_elements_(a1, a2, (uint64_t (*)(uint64_t, uint64_t, unsigned char *, long long *))a3);
  }
}

BOOL RB::Path::Storage::Iterator::next(uint64_t *a1, uint64_t a2, char *__dst)
{
  unint64_t v3 = *a1;
  unint64_t v4 = *(unsigned int *)(a2 + 8);
  if (v4) {
    unint64_t v5 = *(void *)(a2 + 24);
  }
  else {
    unint64_t v5 = (v4 >> 8) & 0xFFF;
  }
  if (v3 >= v5) {
    return v3 < v5;
  }
  uint64_t v10 = *(void *)(a2 + 16);
  uint64_t v8 = a2 + 16;
  uint64_t v9 = v10;
  if (v4) {
    uint64_t v11 = v9;
  }
  else {
    uint64_t v11 = v8;
  }
  uint64_t v12 = v3 + 1;
  *a1 = v3 + 1;
  char v13 = *(unsigned char *)(v11 + v3);
  uint64_t v14 = v13 & 0x1F;
  if (v13 < 0)
  {
    int v16 = 0;
    int v15 = 1;
    switch(v13 & 0x1F)
    {
      case 0x10:
      case 0x12:
      case 0x16:
      case 0x17:
        goto LABEL_13;
      case 0x11:
      case 0x15:
        goto LABEL_10;
      case 0x13:
        int v16 = 2;
        goto LABEL_13;
      case 0x14:
        int v16 = 3;
        goto LABEL_13;
      case 0x18:
        int v16 = 4;
        goto LABEL_13;
      default:
        if (v14 == 4) {
          goto LABEL_13;
        }
        goto LABEL_10;
    }
  }
  int v15 = 0;
LABEL_10:
  if (v14 >= 0x19)
  {
    char __dst[64] = v14;
    int v16 = v15;
  }
  else
  {
    int v16 = v15;
LABEL_13:
    uint64_t v17 = __RBPathElementArgumentCount[v14];
    char __dst[64] = v14;
    if (v17)
    {
      uint64_t v18 = (float *)(v11 + v12);
      if ((v13 & 0x40) != 0)
      {
        double v19 = (double *)__dst;
        uint64_t v20 = v17;
        do
        {
          float v21 = *v18++;
          *v19++ = v21;
          --v20;
        }
        while (v20);
        v12 += 4 * v17;
      }
      else if ((v13 & 0x20) != 0)
      {
        char v22 = (double *)__dst;
        uint64_t v23 = v17;
        do
        {
          int v24 = *(__int16 *)v18;
          uint64_t v18 = (float *)((char *)v18 + 2);
          *v22++ = (double)v24;
          --v23;
        }
        while (v23);
        v12 += 2 * v17;
      }
      else
      {
        memcpy(__dst, v18, 8 * v17);
        uint64_t v12 = *a1 + 8 * v17;
      }
      *a1 = v12;
    }
  }
  char v25 = 0;
  switch(v16)
  {
    case 0:
      goto LABEL_77;
    case 1:
      double v26 = (double *)(__dst + 72);
      uint64_t v27 = (float *)(v11 + v12);
      if ((v13 & 0x40) != 0)
      {
        for (uint64_t i = 0; i != 6; ++i)
          v26[i] = v27[i];
        uint64_t v30 = v12 + 24;
      }
      else if ((v13 & 0x20) != 0)
      {
        for (uint64_t j = 0; j != 6; ++j)
          v26[j] = (double)*((__int16 *)v27 + j);
        uint64_t v30 = v12 + 12;
      }
      else
      {
        long long v28 = *(_OWORD *)v27;
        long long v29 = *((_OWORD *)v27 + 2);
        *(_OWORD *)(__dst + 88) = *((_OWORD *)v27 + 1);
        *(_OWORD *)(__dst + 104) = v29;
        *(_OWORD *)double v26 = v28;
        uint64_t v30 = *a1 + 48;
      }
      goto LABEL_69;
    case 2:
      *a1 = v12 + 1;
      *((_DWORD *)__dst + 18) = *(unsigned __int8 *)(v11 + v12);
      uint64_t v31 = (*a1)++;
      *((_DWORD *)__dst + 19) = *(unsigned __int8 *)(v11 + v31);
      uint64_t v32 = *(unsigned __int16 *)(v11 + *a1);
      *a1 += 2;
      *((void *)__dst + 10) = v32;
      if (v32)
      {
        if (*((_DWORD *)__dst + 40) < v32 && *((_DWORD *)__dst + 41) < v32) {
          RB::vector<std::unique_ptr<RB::RenderQueue,RB::RenderFrame::QueueDeleter>,4ul,unsigned int>::reserve_slow(__dst + 120, v32);
        }
        *((_DWORD *)__dst + 40) = v32;
        float64x2_t v34 = (char *)*((void *)__dst + 19);
        if (v34) {
          unint64_t v35 = (double *)*((void *)__dst + 19);
        }
        else {
          unint64_t v35 = (double *)(__dst + 120);
        }
        uint64_t v36 = *a1;
        float64x2_t v37 = (float *)(v11 + *a1);
        if ((v13 & 0x40) != 0)
        {
          uint64_t v50 = v32;
          do
          {
            float v51 = *v37++;
            *v35++ = v51;
            --v50;
          }
          while (v50);
          uint64_t v38 = v36 + 4 * v32;
        }
        else if ((v13 & 0x20) != 0)
        {
          uint64_t v53 = v32;
          do
          {
            int v54 = *(__int16 *)v37;
            float64x2_t v37 = (float *)((char *)v37 + 2);
            *v35++ = (double)v54;
            --v53;
          }
          while (v53);
          uint64_t v38 = v36 + 2 * v32;
        }
        else
        {
          memcpy(v35, v37, 8 * v32);
          uint64_t v38 = *a1 + 8 * v32;
          float64x2_t v34 = (char *)*((void *)__dst + 19);
        }
        *a1 = v38;
        if (!v34) {
          float64x2_t v34 = __dst + 120;
        }
        *((void *)__dst + 11) = v34;
      }
      goto LABEL_76;
    case 3:
      *((_WORD *)__dst + 36) = *(_WORD *)(v11 + v12);
      uint64_t v30 = *a1 + 2;
LABEL_69:
      *a1 = v30;
      goto LABEL_76;
    case 4:
      *a1 = v12 + 1;
      *((_DWORD *)__dst + 18) = *(unsigned __int8 *)(v11 + v12);
      uint64_t v39 = (*a1)++;
      *((_DWORD *)__dst + 19) = *(unsigned __int8 *)(v11 + v39);
      uint64_t v40 = *(unsigned __int16 *)(v11 + *a1);
      *a1 += 2;
      *((void *)__dst + 10) = v40;
      if (!v40) {
        goto LABEL_76;
      }
      unsigned int v41 = 2 * v40;
      if (*((_DWORD *)__dst + 40) >= (2 * v40) || *((_DWORD *)__dst + 41) >= v41)
      {
        *((_DWORD *)__dst + 40) = v41;
        if (*((void *)__dst + 19)) {
          size_t v43 = (char *)*((void *)__dst + 19);
        }
        else {
          size_t v43 = __dst + 120;
        }
        *((void *)__dst + 11) = v43;
LABEL_52:
        unint64_t v44 = 0;
        uint64_t v45 = *a1;
        uint64_t v46 = v43 + 4;
        do
        {
          unint64_t v47 = (unsigned __int8 *)(v11 + v45);
          *((_DWORD *)v46 - 1) = *v47;
          uint64_t v48 = *(void *)(v47 + 1);
          *((_DWORD *)v46 + 2) = *(_DWORD *)(v47 + 9);
          *(void *)uint64_t v46 = v48;
          v46 += 16;
          uint64_t v45 = *a1 + 13;
          *a1 = v45;
          ++v44;
        }
        while (v44 < *((void *)__dst + 10));
        goto LABEL_76;
      }
      RB::vector<std::unique_ptr<RB::RenderQueue,RB::RenderFrame::QueueDeleter>,4ul,unsigned int>::reserve_slow(__dst + 120, 2 * v40);
      uint64_t v56 = *((void *)__dst + 10);
      *((_DWORD *)__dst + 40) = v41;
      size_t v43 = (char *)*((void *)__dst + 19);
      if (!v43) {
        size_t v43 = __dst + 120;
      }
      *((void *)__dst + 11) = v43;
      if (v56) {
        goto LABEL_52;
      }
LABEL_76:
      char v25 = 1;
LABEL_77:
      __dst[65] = v25;
      return v3 < v5;
    default:
      return v3 < v5;
  }
}

uint64_t RB::Path::NestedCallbacks::first_element(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  unsigned __int8 v9 = 0;
  BOOL v6 = RB::Path::Storage::Iterator::next_type(a2, a1, &v9);
  uint64_t result = 0;
  if (v6)
  {
    uint64_t v8 = 0;
    while (1)
    {
      if (v9 <= 0x18u)
      {
        if (((1 << v9) & 0x1DE0000) != 0)
        {
          if (++v8 == a3) {
            return 1;
          }
        }
        else if (v9 == 16)
        {
          return 0;
        }
      }
      if (!RB::Path::Storage::Iterator::next_type(a2, a1, &v9)) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t RB::Path::NestedCallbacks::single_element_fast(RB::Path::NestedCallbacks *this, const RB::Path::Storage *a2, void *a3)
{
  uint64_t v13 = 0;
  uint64_t v5 = *(void *)a2;
  if (*(void *)a2)
  {
    if (!RB::Path::NestedCallbacks::first_element((uint64_t)this, &v13, v5)) {
      return 0;
    }
    *((void *)a2 + 1) = v5;
  }
  unsigned __int8 v12 = 0;
  unint64_t v6 = *((void *)a2 + 2);
  uint64_t v7 = 1;
  if (v6 <= 1)
  {
    do
    {
      if (!RB::Path::Storage::Iterator::next_type(&v13, (uint64_t)this, &v12)) {
        break;
      }
      int v8 = v12;
      switch(v12)
      {
        case 0u:
        case 1u:
        case 2u:
        case 3u:
        case 0xCu:
        case 0xDu:
        case 0xEu:
        case 0xFu:
          if (*((void *)a2 + 1) == v5)
          {
            *((unsigned char *)a2 + 24) = 1;
            goto LABEL_9;
          }
          break;
        case 4u:
          if (*((void *)a2 + 1) == v5 && *((unsigned char *)a2 + 24))
          {
            *((unsigned char *)a2 + 24) = 0;
            goto LABEL_9;
          }
          break;
        case 0x10u:
          uint64_t v10 = *((void *)a2 + 1);
          *((void *)a2 + 1) = v10 - 1;
          if (v10 == v5) {
            return 0;
          }
          break;
        case 0x11u:
        case 0x12u:
        case 0x13u:
        case 0x14u:
        case 0x16u:
        case 0x17u:
        case 0x18u:
          uint64_t v9 = *((void *)a2 + 1);
          *((void *)a2 + 1) = v9 + 1;
          if (v9 == v5)
          {
            *((void *)a2 + 2) = ++v6;
            *((unsigned char *)a2 + 24) = v8 != 19;
          }
          break;
        default:
          if (*((void *)a2 + 1) == v5) {
LABEL_9:
          }
            *((void *)a2 + 2) = ++v6;
          break;
      }
    }
    while (v6 < 2);
    return 1;
  }
  return v7;
}

BOOL RB::Path::Storage::Iterator::next_type(uint64_t *a1, uint64_t a2, unsigned char *a3)
{
  unint64_t v3 = *a1;
  unint64_t v4 = *(unsigned int *)(a2 + 8);
  unint64_t v5 = (v4 >> 8) & 0xFFF;
  if (v4) {
    unint64_t v5 = *(void *)(a2 + 24);
  }
  if (v3 < v5)
  {
    uint64_t v8 = *(void *)(a2 + 16);
    uint64_t v6 = a2 + 16;
    uint64_t v7 = v8;
    if ((v4 & 1) == 0) {
      uint64_t v7 = v6;
    }
    *a1 = v3 + 1;
    uint64_t v9 = *(unsigned char *)(v7 + v3) & 0x1F;
    if ((*(unsigned char *)(v7 + v3) & 0x80) != 0)
    {
      int v11 = 0;
      int v10 = 1;
      switch(*(unsigned char *)(v7 + v3) & 0x1F)
      {
        case 0x10:
        case 0x12:
        case 0x16:
        case 0x17:
          goto LABEL_17;
        case 0x11:
        case 0x15:
          goto LABEL_8;
        case 0x13:
          int v11 = 2;
          goto LABEL_17;
        case 0x14:
          int v11 = 3;
          goto LABEL_17;
        case 0x18:
          int v11 = 4;
          goto LABEL_17;
        default:
          if (v9 == 4) {
            goto LABEL_17;
          }
          goto LABEL_8;
      }
    }
    int v10 = 0;
LABEL_8:
    if (v9 > 0x18)
    {
      uint64_t v12 = 0;
    }
    else
    {
      int v11 = v10;
LABEL_17:
      uint64_t v12 = __RBPathElementArgumentCount[v9];
      int v10 = v11;
    }
    if ((*(unsigned char *)(v7 + v3) & 0x40) != 0) {
      char v13 = 2;
    }
    else {
      char v13 = 3;
    }
    if ((*(unsigned char *)(v7 + v3) & 0x20) != 0) {
      char v14 = 1;
    }
    else {
      char v14 = v13;
    }
    uint64_t v15 = (v12 << v14) + v3 + 1;
    *a1 = v15;
    switch(v10)
    {
      case 1:
        uint64_t v16 = v15 + (6 << v14);
        goto LABEL_30;
      case 2:
        uint64_t v17 = v15 + ((unint64_t)*(unsigned __int16 *)(v15 + v7 + 2) << v14);
        goto LABEL_29;
      case 3:
        uint64_t v16 = v15 + 2;
        goto LABEL_30;
      case 4:
        uint64_t v17 = v15 + 13 * *(unsigned __int16 *)(v15 + v7 + 2);
LABEL_29:
        uint64_t v16 = v17 + 4;
LABEL_30:
        *a1 = v16;
        break;
      default:
        break;
    }
    *a3 = v9;
  }
  return v3 < v5;
}

uint64_t RBPathApplyShape::$_1::__invoke<void *,RBPathElement,double const*,void const*>(uint64_t a1, int a2, float64x2_t *a3, float64x2_t *a4)
{
  if (a2)
  {
    if (a2 == 1)
    {
      uint64_t v4 = *(void *)(a1 + 32);
      goto LABEL_6;
    }
    return 0;
  }
  if (*(void *)(a1 + 32) > 1uLL) {
    return 0;
  }
  uint64_t v4 = 0;
  *(void *)(a1 + 32) = 0;
LABEL_6:
  if (v4 != a2) {
    return 0;
  }
  float64x2_t v5 = *a3;
  if (a4) {
    float64x2_t v5 = vmlaq_laneq_f64(vmlaq_n_f64(a4[2], *a4, v5.f64[0]), a4[1], v5, 1);
  }
  *(void *)(a1 + 32) = v4 + 1;
  *(float64x2_t *)(a1 + 16 * v4) = v5;
  return 1;
}

void *RB::Path::Storage::reserve_slow(RB::Path::Storage *this, size_t a2)
{
  unint64_t v3 = *((unsigned int *)this + 2);
  if (v3) {
    unint64_t v4 = *((void *)this + 4);
  }
  else {
    unint64_t v4 = v3 >> 20;
  }
  unint64_t v5 = 2 * v4;
  if (v5 <= a2) {
    size_t v6 = a2;
  }
  else {
    size_t v6 = v5;
  }
  size_t v7 = malloc_good_size(v6);
  size_t v8 = v7;
  if (*((unsigned char *)this + 8))
  {
    uint64_t result = malloc_type_realloc(*((void **)this + 2), v7, 0x64C53627uLL);
    int v11 = result;
    if (result) {
      goto LABEL_15;
    }
LABEL_12:
    RB::precondition_failure((RB *)"allocation failure", v10);
  }
  uint64_t v9 = malloc_type_malloc(v7, 0x4E39F373uLL);
  if (!v9) {
    goto LABEL_12;
  }
  int v11 = v9;
  unint64_t v12 = *((unsigned int *)this + 2);
  if (v12)
  {
    char v14 = (char *)*((void *)this + 2);
    size_t v13 = *((void *)this + 3);
  }
  else
  {
    size_t v13 = (v12 >> 8) & 0xFFF;
    char v14 = (char *)this + 16;
  }
  uint64_t result = memcpy(v9, v14, v13);
  *((_DWORD *)this + 2) |= 1u;
  *((void *)this + 3) = v13;
  *((void *)this + 7) = 0;
LABEL_15:
  *((void *)this + 2) = v11;
  *((void *)this + 4) = v8;
  return result;
}

uint64_t RBPathIsEmpty::$_0::__invoke<void *,RBPathElement,double const*,void const*>(unsigned char *a1)
{
  *a1 = 0;
  return 0;
}

uint64_t RB::Path::Storage::MapCache::shared(RB::Path::Storage::MapCache *this)
{
  {
    operator new();
  }
  return RB::Path::Storage::MapCache::shared(void)::shared;
}

void RB::Path::Storage::MapCache::remove(os_unfair_lock_s *this, const RB::Path::Storage *a2)
{
  os_unfair_lock_lock(this);
  RB::UntypedTable::remove((RB::UntypedTable *)&this[2], (void *)*((unsigned int *)a2 + 3));
  os_unfair_lock_unlock(this);
}

uint64_t RB::UntypedTable::remove(RB::UntypedTable *this, void *a2)
{
  if (!*((void *)this + 7)) {
    return 0;
  }
  if (*((unsigned char *)this + 77))
  {
    return RB::UntypedTable::remove_ptr(this, a2);
  }
  uint64_t v5 = (*(uint64_t (**)(void *))this)(a2);
  size_t v6 = (void *)(*((void *)this + 6) + 8 * (*((void *)this + 8) & v5));
  size_t v7 = (void *)*v6;
  if (!*v6) {
    return 0;
  }
  uint64_t v8 = v5;
  while (1)
  {
    uint64_t v9 = v7;
    if (v7[3] == v8)
    {
      if ((*((unsigned int (**)(void, void *))this + 1))(v7[1], a2)) {
        break;
      }
    }
    size_t v7 = (void *)*v9;
    size_t v6 = v9;
    if (!*v9) {
      return 0;
    }
  }
  void *v6 = *v9;
  int v10 = (void (*)(void))*((void *)this + 2);
  if (v10) {
    v10(v9[1]);
  }
  int v11 = (void (*)(void))*((void *)this + 3);
  if (v11) {
    v11(v9[2]);
  }
  *uint64_t v9 = *((void *)this + 5);
  *((void *)this + 5) = v9;
  --*((void *)this + 7);
  return 1;
}

__n128 *RB::Path::BufferedTransform::apply(__n128 *result, uint64_t a2)
{
  uint64_t v2 = result[9].n128_i64[0];
  if (result[8].n128_u64[1]) {
    unint64_t v3 = (unsigned __int8 *)result[8].n128_u64[1];
  }
  else {
    unint64_t v3 = &result->n128_u8[8];
  }
  if (v2)
  {
    if (result[266].n128_u64[0]) {
      uint64_t v5 = (__n128 *)result[266].n128_u64[0];
    }
    else {
      uint64_t v5 = result + 10;
    }
    do
    {
      switch(*v3)
      {
        case 0u:
          __n128 v6 = *v5++;
          uint64_t result = (__n128 *)(*(uint64_t (**)(uint64_t, __n128))(*(void *)a2 + 16))(a2, v6);
          break;
        case 1u:
          __n128 v7 = *v5++;
          uint64_t result = (__n128 *)(*(uint64_t (**)(uint64_t, __n128))(*(void *)a2 + 24))(a2, v7);
          break;
        case 2u:
          __n128 v8 = *v5;
          __n128 v9 = v5[1];
          v5 += 2;
          uint64_t result = (__n128 *)(*(uint64_t (**)(uint64_t, __n128, __n128))(*(void *)a2 + 32))(a2, v8, v9);
          break;
        case 3u:
          uint64_t result = (__n128 *)(*(uint64_t (**)(uint64_t, __n128, __n128, __n128))(*(void *)a2 + 40))(a2, *v5, v5[1], v5[2]);
          v5 += 3;
          break;
        case 4u:
          uint64_t result = (__n128 *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
          break;
        default:
          break;
      }
      ++v3;
      --v2;
    }
    while (v2);
  }
  return result;
}

__n128 RB::Path::anonymous namespace'::Lengths::cubeto(uint64_t a1, float64x2_t a2, float64x2_t a3, float64x2_t a4)
{
  double v5 = RB::cubic_length<double>(*(float64x2_t *)(a1 + 1072), a2, a3, a4, 0.5);
  uint64_t v6 = *(void *)(a1 + 1040);
  size_t v7 = v6 + 1;
  if (*(void *)(a1 + 1048) < (unint64_t)(v6 + 1))
  {
    RB::vector<double,128ul,unsigned long>::reserve_slow((void *)(a1 + 8), v7);
    uint64_t v6 = *(void *)(a1 + 1040);
    size_t v7 = v6 + 1;
  }
  uint64_t v8 = *(void *)(a1 + 1032);
  if (!v8) {
    uint64_t v8 = a1 + 8;
  }
  *(double *)(v8 + 8 * v6) = v5;
  *(void *)(a1 + 1040) = v7;
  *(double *)(a1 + 1056) = *(double *)(a1 + 1056) + v5;
  __n128 result = (__n128)a4;
  *(float64x2_t *)(a1 + 1072) = a4;
  return result;
}

double RB::cubic_length<double>(float64x2_t a1, float64x2_t a2, float64x2_t a3, float64x2_t a4, double a5)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  float64x2_t v5 = vsubq_f64(a2, a1);
  int64x2_t v6 = (int64x2_t)vmulq_f64(v5, v5);
  float64x2_t v7 = vsubq_f64(a4, a3);
  int64x2_t v8 = (int64x2_t)vmulq_f64(v7, v7);
  float64x2_t v9 = vsqrtq_f64(vaddq_f64((float64x2_t)vzip1q_s64(v8, v6), (float64x2_t)vzip2q_s64(v8, v6)));
  double v10 = 0.0;
  if (COERCE_UNSIGNED_INT64(vaddvq_f64(v9)) >> 52 <= 0x7FE)
  {
    unint64_t v11 = 0;
    double v12 = v9.f64[1];
    double v13 = 1.0;
    uint64_t v14 = 1024;
    do
    {
      float64x2_t v15 = vsubq_f64(a3, a2);
      double v16 = sqrt(vaddvq_f64(vmulq_f64(v15, v15)));
      float64x2_t v17 = vsubq_f64(a4, a1);
      double v18 = sqrt(vaddvq_f64(vmulq_f64(v17, v17)));
      double v19 = v9.f64[0] + v12 + v16;
      if (v19 - v18 <= v13 * a5 || v11 >= 0x1D)
      {
        double v10 = v10 + (v18 + v19) * 0.5;
        if (!v11) {
          return v10;
        }
        --v11;
        float v21 = (float64x2_t *)&v34[6 * v11];
        a1 = *v21;
        a2 = v21[1];
        a3 = v21[2];
        a4 = v21[3];
        double v12 = v21[4].f64[0];
        v9.f64[0] = v21[4].f64[1];
        double v13 = v21[5].f64[0];
      }
      else
      {
        double v13 = v13 * 0.5;
        char v22 = (float64x2_t *)&v34[6 * v11];
        v22[5].f64[0] = v13;
        __asm { FMOV            V19.2D, #0.5 }
        v22[2] = vmulq_f64(vaddq_f64(a3, a4), _Q19);
        v22[3] = a4;
        __asm { FMOV            V18.2D, #2.0 }
        float64x2_t v28 = vaddq_f64(vmlaq_f64(a4, _Q18, a3), a2);
        __asm
        {
          FMOV            V22.2D, #3.0
          FMOV            V21.2D, #0.25
        }
        float64x2_t v31 = vaddq_f64(vmlaq_f64(a4, _Q22, vaddq_f64(a2, a3)), a1);
        __asm { FMOV            V22.2D, #0.125 }
        a4 = vmulq_f64(v31, _Q22);
        *char v22 = a4;
        v22[1] = vmulq_f64(v28, _Q21);
        a3 = vmulq_f64(vaddq_f64(vmlaq_f64(a3, _Q18, a2), a1), _Q21);
        a2 = vmulq_f64(vaddq_f64(a1, a2), _Q19);
        _Q18.f64[0] = v9.f64[0] * 0.5;
        double v12 = v12 * 0.5;
        float64x2_t v9 = vsubq_f64(a4, a3);
        v9.f64[0] = sqrt(vaddvq_f64(vmulq_f64(v9, v9)));
        v22[4].f64[0] = v9.f64[0];
        v22[4].f64[1] = _Q18.f64[0];
        ++v11;
      }
      --v14;
    }
    while (v14);
    return 1.0;
  }
  return v10;
}

_DWORD *RB::Path::Storage::MapCache::Destination::moveto(uint64_t a1, __n128 a2)
{
  uint64_t v4 = *MEMORY[0x263EF8340];
  __n128 v3 = a2;
  return RB::Path::Storage::append_element((RB::Path::Storage *)(*(void *)(a1 + 8) + 16), 0, v3.n128_f64, 0);
}

__n128 RB::Path::anonymous namespace'::Lengths::closepath(RB::Path::_anonymous_namespace_::Lengths *this)
{
  float64x2_t v2 = *((float64x2_t *)this + 68);
  float64x2_t v3 = *((float64x2_t *)this + 67);
  uint64_t v4 = (char *)this + 8;
  uint64_t v5 = *((void *)this + 130);
  size_t v6 = v5 + 1;
  if (*((void *)this + 131) < (unint64_t)(v5 + 1))
  {
    float64x2_t v11 = *((float64x2_t *)this + 67);
    float64x2_t v12 = *((float64x2_t *)this + 68);
    RB::vector<double,128ul,unsigned long>::reserve_slow((char *)this + 8, v6);
    float64x2_t v3 = v11;
    float64x2_t v2 = v12;
    uint64_t v5 = *((void *)this + 130);
    size_t v6 = v5 + 1;
  }
  float64x2_t v7 = vsubq_f64(v2, v3);
  double v8 = sqrt(vaddvq_f64(vmulq_f64(v7, v7)));
  float64x2_t v9 = (char *)*((void *)this + 129);
  if (!v9) {
    float64x2_t v9 = v4;
  }
  *(double *)&v9[8 * v5] = v8;
  *((void *)this + 130) = v6;
  *((double *)this + 132) = *((double *)this + 132) + v8;
  __n128 result = *((__n128 *)this + 68);
  *((__n128 *)this + 67) = result;
  return result;
}

__n128 *RB::Path::anonymous namespace'::Lengths::moveto(__n128 *result, __n128 a2)
{
  result[67] = a2;
  result[68] = a2;
  return result;
}

BOOL RB::Symbol::Animator::animating(os_unfair_lock_s *this)
{
  os_unfair_lock_lock(this);
  BOOL v2 = *(void *)&this[6]._os_unfair_lock_opaque != 0;
  os_unfair_lock_unlock(this);
  return v2;
}

uint64_t RBDrawingStateDrawDisplayList(uint64_t a1, void *a2, double a3)
{
  LODWORD(a3) = 1.0;
  return [a2 _drawInState:a1 alpha:a3];
}

RB::XML::Document *RBDrawingStateTranslateCTM(RB::XML::Document *a1, double a2, double a3)
{
  uint64_t v6 = *((void *)a1 + 1);
  RB::DisplayList::State::translate((uint64_t)a1, a2, a3);
  __n128 result = *(RB::XML::Document **)(v6 + 304);
  if (result)
  {
    return RB::XML::DisplayList::translate_ctm(result, a1, v7, a2, a3);
  }
  return result;
}

uint64_t RB::DisplayList::State::translate(uint64_t this, double a2, double a3)
{
  if (a2 != 0.0 || a3 != 0.0)
  {
    *(float64x2_t *)(this + 48) = vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(this + 48), *(float64x2_t *)(this + 16), a2), *(float64x2_t *)(this + 32), a3);
    *(void *)(this + 112) = 0;
    *(_DWORD *)(this + 148) = -1;
  }
  return this;
}

RB::XML::Document *RB::Symbol::Glyph::Layer::draw(uint64_t a1, __n128 *a2, unsigned int a3, float64x2_t *a4, RB::Symbol::Presentation *this, uint64_t a6, float a7, float32x2_t a8)
{
  if ((*(_DWORD *)(a1 + 84) & 0xC0000) == 0x40000)
  {
    double v16 = (void *)RB::Symbol::Presentation::shape(this);
    float64x2_t v17 = (RBFill *)RB::Symbol::Presentation::fill(this);
    RB::Symbol::Glyph::Layer::set_shape(a1, v16, a4, a8);
    (*(void (**)(uint64_t, RBFill *))(a6 + 16))(a6, v17);
    return (RB::XML::Document *)RBDrawingStateDrawShape(a2, (uint64_t)v16, v17, a3, a7);
  }
  else if ((*(_DWORD *)(a1 + 84) & 0xF00) == 0xA00)
  {
    double v19 = RBDrawingStateBeginLayer((RB::DisplayList::State *)a2, 0);
    uint64_t v20 = (_RBDrawingState *)v19;
    unsigned int v21 = (*(_DWORD *)(a1 + 84) >> 18) & 3;
    if (v21 >= 2)
    {
      if (v21 == 3)
      {
        float v22 = *(float *)(a1 + 60);
        if (v22 == 0.0)
        {
          double v23 = *(float *)(a1 + 56);
          float64x2_t v24 = vmulq_n_f64(*a4, v23);
          float64x2_t v25 = vmulq_n_f64(a4[1], v23);
          float64x2_t v26 = a4[2];
        }
        else
        {
          float64x2_t v38 = a4[1];
          float64x2_t v26 = vmlaq_f64(vmlaq_n_f64(a4[2], *a4, v22), (float64x2_t)0, v38);
          float v39 = *(float *)(a1 + 56);
          double v40 = v39;
          float64x2_t v24 = vmulq_n_f64(*a4, (float)-v39);
          float64x2_t v25 = vmulq_n_f64(v38, v40);
        }
        v45[0] = v24;
        v45[1] = v25;
        v45[2] = v26;
        RBDrawingStateConcatCTM((uint64_t)v19, (uint64_t)v45);
        RBDrawingStateDrawDisplayList((uint64_t)v20, *(void **)a1, v41);
      }
      else
      {
        uint64_t v32 = *(RB::Symbol::Glyph::Sublayers **)a1;
        float v33 = *(float *)(a1 + 60);
        if (v33 == 0.0)
        {
          double v34 = *(float *)(a1 + 56);
          float64x2_t v35 = vmulq_n_f64(*a4, v34);
          float64x2_t v36 = vmulq_n_f64(a4[1], v34);
          float64x2_t v37 = a4[2];
        }
        else
        {
          float64x2_t v42 = a4[1];
          float64x2_t v37 = vmlaq_f64(vmlaq_n_f64(a4[2], *a4, v33), (float64x2_t)0, v42);
          float v43 = *(float *)(a1 + 56);
          double v44 = v43;
          float64x2_t v35 = vmulq_n_f64(*a4, (float)-v43);
          float64x2_t v36 = vmulq_n_f64(v42, v44);
        }
        v46[0] = v35;
        v46[1] = v36;
        v46[2] = v37;
        RB::Symbol::Glyph::Sublayers::draw_layers(v32, v20, (const RB::AffineTransform *)v46, this);
      }
    }
    return RBDrawingStateDrawLayer((int8x16_t *)a2, (RB::DisplayList::State *)v20, a3, a7);
  }
  else
  {
    uint64_t v27 = RBDrawingStateInit((RB::DisplayList::State *)a2);
    RB::Symbol::Glyph::Layer::clip(a1, (__n128 *)v27, 0, a4, this, 1.0, a8);
    float64x2_t v28 = (void *)RB::Symbol::Presentation::shape(this);
    long long v29 = (RBFill *)RB::Symbol::Presentation::fill(this);
    [v28 setInfinite];
    (*(void (**)(uint64_t, RBFill *))(a6 + 16))(a6, v29);
    RBDrawingStateDrawShape((__n128 *)v27, (uint64_t)v28, v29, a3, a7);
    return (RB::XML::Document *)RBDrawingStateDestroy((RB::XML::Document *)v27, v30, v31);
  }
}

RB::XML::Document *RB::Symbol::Glyph::Layer::draw(uint64_t a1, __n128 *a2, unsigned int a3, float64x2_t *a4, RB::Symbol::Presentation *this, float a6, float a7, float a8, float a9, float a10, float32x2_t a11)
{
  if ((*(_DWORD *)(a1 + 84) & 0xC0000) == 0x40000)
  {
    float v22 = (void *)RB::Symbol::Presentation::shape(this);
    double v23 = (RBFill *)RB::Symbol::Presentation::fill(this);
    RB::Symbol::Glyph::Layer::set_shape(a1, v22, a4, a11);
    *(float *)&double v24 = a6;
    *(float *)&double v25 = a7;
    *(float *)&double v26 = a8;
    *(float *)&double v27 = a9;
    -[RBFill setColor:colorSpace:](v23, "setColor:colorSpace:", 1, v24, v25, v26, v27);
    return (RB::XML::Document *)RBDrawingStateDrawShape(a2, (uint64_t)v22, v23, a3, a10);
  }
  else
  {
    v29[0] = MEMORY[0x263EF8330];
    v29[1] = 3221225472;
    v29[2] = ___ZNK2RB6Symbol5Glyph5Layer4drawEP15_RBDrawingState7RBColorf11RBBlendModeRKNS_15AffineTransformEDv2_fRKNS0_12PresentationE_block_invoke;
    v29[3] = &__block_descriptor_48_e16_v16__0__RBFill_8l;
    float v30 = a6;
    float v31 = a7;
    float v32 = a8;
    float v33 = a9;
    return RB::Symbol::Glyph::Layer::draw(a1, a2, a3, a4, this, (uint64_t)v29, a10, a11);
  }
}

uint64_t RB::Symbol::Presentation::shape(RB::Symbol::Presentation *this)
{
  uint64_t v1 = *((void *)this + 251);
  if (!v1)
  {
    uint64_t v1 = objc_opt_new();

    *((void *)this + 251) = v1;
  }
  return v1;
}

uint64_t RB::Symbol::Presentation::fill(RB::Symbol::Presentation *this)
{
  uint64_t v1 = *((void *)this + 252);
  if (!v1)
  {
    uint64_t v1 = objc_opt_new();

    *((void *)this + 252) = v1;
  }
  return v1;
}

unint64_t rb_color_space(unsigned int a1)
{
  if (a1 >= 5) {
    return 0;
  }
  else {
    return (0x203000100uLL >> (8 * a1)) & 3 | ((0x101010100uLL >> (8 * a1)) << 8);
  }
}

atomic_uint *RBFillData::apply<RB::DestroyAny>(atomic_uint *result, uint64_t a2)
{
  if (*result == 5) {
    return RB::DestroyAny::operator()<RB::Fill::Custom>(a2, (uint64_t)(result + 4));
  }
  if (*result == 3)
  {
    __n128 result = (atomic_uint *)*((void *)result + 3);
    if (result)
    {
      if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
      }
    }
  }
  return result;
}

void RB::DisplayList::Builder::draw(RB::DisplayList::Layer ***this, const RB::DisplayList::Contents *x1_0, RB::DisplayList::State *a3, float a4, const RB::DisplayList::InvertiblePredicate *a5, RB::DisplayList::Item *a6)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  {
    uint64_t v34 = RB::debug_int((RB *)"RB_PRINT_TREE", (const char *)x1_0);
    unsigned int v35 = (v34 >> 1) & 1;
    if ((v34 & 0xFF00000000) == 0) {
      LOBYTE(v35) = 0;
    }
    RB::DisplayList::Builder::draw(RB::DisplayList::Contents const&,RB::DisplayList::State &,float,RB::DisplayList::InvertiblePredicate const*,void *)::print_tree = v35;
  }
  if (RB::DisplayList::Builder::draw(RB::DisplayList::Contents const&,RB::DisplayList::State &,float,RB::DisplayList::InvertiblePredicate const*,void *)::print_tree)
  {
    memset(__p, 0, 41);
    RB::SexpString::push(__p, "draw");
    if (a5)
    {
      RB::SexpString::push(__p, "predicate");
      RB::XML::Document::Document((RB::XML::Document *)&v37);
      RB::DisplayList::Predicate::xml_elements((uint64_t)a5, (RB::XML::Document *)&v37);
      RB::XML::Document::print_children((RB::XML::Document *)&v37, __p, 0);
      RB::SexpString::pop(__p);
      RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v39);
      if (v38) {
        free(v38);
      }
      uint64_t v12 = v37;
      if (v37)
      {
        int v13 = *(_DWORD *)(v37 + 8) - 1;
        *(_DWORD *)(v37 + 8) = v13;
        if (!v13) {
          (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
        }
      }
    }
    RB::DisplayList::Contents::print(x1_0, __p);
    RB::SexpString::pop(__p);
    RB::SexpString::newline(__p);
    if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v14 = __p;
    }
    else {
      uint64_t v14 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
    }
    fputs((const char *)v14, (FILE *)*MEMORY[0x263EF8348]);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
  }
  if (!this[1]) {
    RB::DisplayList::Builder::reset_contents((RB::DisplayList::Builder *)this);
  }
  float64x2_t v15 = this[4];
  if (!v15 || *((_DWORD *)*v15 + 14) != *((_DWORD *)a3 + 36)) {
    RB::precondition_failure((RB *)"current layer doesn't match drawing state", (const char *)x1_0);
  }
  RB::DisplayList::CachedTransform::CachedTransform((uint64_t)&v37, (uint64_t)this, (long long *)a3 + 1, *((void *)a3 + 12), *((void *)a3 + 13), 0);
  if (*((unsigned char *)this + 272))
  {
    float v43 = a5;
  }
  else
  {
    double v16 = RB::DisplayList::State::copy_metadata(a3, (RB::DisplayList::Contents *)this[1]);
    int v17 = *((_DWORD *)a3 + 16);
    v39[138] = v16;
    int v40 = v17;
    int v18 = *((unsigned __int8 *)this + 272);
    float v43 = a5;
    if (!v18)
    {
      unsigned int v21 = 0;
LABEL_26:
      BOOL v22 = 0;
      goto LABEL_27;
    }
  }
  uint64_t v19 = RB::DisplayList::Builder::crop_bounds((RB::DisplayList::Builder *)this, a3);
  uint32x2_t v20 = (uint32x2_t)vcge_f32((float32x2_t)(*(void *)(v19 + 8) & 0x7FFFFFFF7FFFFFFFLL), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  if (vpmax_u32(v20, v20).i32[0] >= 0) {
    unsigned int v21 = (float32x2_t *)v19;
  }
  else {
    unsigned int v21 = 0;
  }
  if (!*((unsigned char *)this + 272)) {
    goto LABEL_26;
  }
  BOOL v22 = *((unsigned char *)x1_0 + 400) != 0;
LABEL_27:
  double v23 = (RB::DisplayList::Item *)*((void *)x1_0 + 40);
  if (v23 && v23 != a6)
  {
    while (1)
    {
      if (v22 && ((*(uint64_t (**)(RB::DisplayList::Item *))(*(void *)v23 + 160))(v23) & 1) != 0) {
        goto LABEL_46;
      }
      if (v21)
      {
        float32x2_t v24 = RB::DisplayList::Item::styled_bounds(v23, 0);
        if (!RB::Rect::intersects(v21, v46, v24, v25, v26, v27, v28, v29)) {
          goto LABEL_46;
        }
      }
      char v44 = 0;
      if (!a5
        || (((*(unsigned int (**)(RB::DisplayList::Item *, const RB::DisplayList::InvertiblePredicate *))(*(void *)v23 + 192))(v23, a5) ^ (*((unsigned char *)a5 + 40) != 0)) & 1) != 0)
      {
        goto LABEL_45;
      }
      float v30 = (void *)*((void *)v23 + 2);
      if (v30) {
        break;
      }
LABEL_42:
      if (v44) {
        goto LABEL_45;
      }
LABEL_46:
      double v23 = (RB::DisplayList::Item *)*((void *)v23 + 1);
      if (!v23 || v23 == a6) {
        goto LABEL_48;
      }
    }
    while (1)
    {
      unsigned __int16 v31 = (*(uint64_t (**)(void *, const RB::DisplayList::InvertiblePredicate *))(*v30 + 64))(v30, a5);
      if (v31 >= 0x100u && !(*((unsigned char *)a5 + 40) ? v31 != 0 : v31 == 0)) {
        break;
      }
      float v30 = (void *)v30[4];
      if (!v30) {
        goto LABEL_42;
      }
    }
    char v44 = 1;
LABEL_45:
    float v33 = (RB::DisplayList::Item *)(*(uint64_t (**)(RB::DisplayList::Item *, RB::DisplayList::Layer ***, void))(*(void *)v23 + 24))(v23, this, 0);
    RB::DisplayList::Item::apply_alpha((uint64_t)v33, a4);
    (*(void (**)(RB::DisplayList::Item *, uint64_t *, uint64_t))(*(void *)v33 + 32))(v33, &v37, 1);
    RB::DisplayList::Builder::draw((RB::DisplayList::Builder *)this, v33, *this[4], 0);
    goto LABEL_46;
  }
LABEL_48:
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v42);
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v41);
  RB::Heap::~Heap((RB::Heap *)&v38);
}

void sub_2140FEB1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
}

uint64_t RBDrawingStateDrawShape(__n128 *a1, uint64_t a2, RBFill *a3, unsigned int a4, float a5)
{
  unint64_t v10 = a1->n128_u64[1];
  if (!*(void *)(v10 + 24)) {
    make_contents(a1->n128_i64[1]);
  }
  unsigned int v11 = rb_blend_mode(a4);
  if (!*(unsigned char *)(v10 + 288)
    || a5 != 0.0 && !RBFillIsClear(a3)
    || (uint64_t result = RB::may_discard_alpha(v11), (result & 1) == 0))
  {
    int v13 = (RB::Heap *)(*(void *)(v10 + 24) + 16);
    RB::DisplayList::State::copy_ctm(a1, v13);
    uint64_t v14 = a2;
    unsigned __int16 v15 = a1[9].n128_u16[6];
    v22[0] = v13;
    v22[1] = v16;
    float v23 = a5;
    unsigned int v24 = v11;
    unsigned __int16 v25 = v15;
    uint64_t v26 = -[RBShape shapeData]((uint64_t)a3);
    uint64_t v27 = RB::DisplayList::Builder::culling_bounds((RB::DisplayList::Builder *)(v10 + 16), (RB::DisplayList::State *)a1);
    int32x4_t v29 = 0;
    char v28 = *(unsigned char *)(v10 + 288);
    int v17 = (float32x2_t *)-[RBShape shapeData](v14);
    RBShapeData::apply<RB::DisplayList::ItemFactory>(v17, (uint64_t)v22, v18, v19, v20, v21);
    if (v29) {
      RB::DisplayList::Builder::draw((RB::DisplayList::Contents **)(v10 + 16), (int8x16_t *)v29, (int8x16_t *)a1);
    }
    uint64_t result = *(void *)(v10 + 304);
    if (result) {
      RB::XML::DisplayList::draw_shape((RB::XML::Document *)result);
    }
  }
  return result;
}

RB::DisplayList::Builder *RB::DisplayList::Builder::draw(RB::DisplayList::Builder *this, RB::DisplayList::Item *a2, RB::DisplayList::Layer *a3, char a4)
{
  if (a2)
  {
    uint64_t v6 = this;
    if (*((unsigned char *)this + 272))
    {
      uint64_t v7 = *((void *)a2 + 2);
      if (v7)
      {
        *((void *)a2 + 2) = 0;
        return (RB::DisplayList::Builder *)(*(uint64_t (**)(uint64_t, RB::DisplayList::Builder *, RB::DisplayList::Layer *))(*(void *)v7 + 40))(v7, v6, a3);
      }
      else
      {
        return (RB::DisplayList::Builder *)RB::DisplayList::Builder::null_style_draw(v6, a2, a3, a4);
      }
    }
    else
    {
      return (RB::DisplayList::Builder *)RB::DisplayList::Builder::append(this, a3, a2);
    }
  }
  return this;
}

uint64_t RB::DisplayList::Builder::append(RB::DisplayList::Builder *this, RB::DisplayList::Layer *a2, RB::DisplayList::Item *a3)
{
  unsigned int v5 = *((unsigned __int16 *)a3 + 23);
  if (((v5 >> 6) & 7) != 0)
  {
    if (((*((short float *)a3 + 22) != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) & (v5 >> 6)) != 0)
    {
      int v6 = 1;
    }
    else
    {
      int v7 = v5 & 0x3F;
      BOOL v8 = v7 != 2;
      if (v7 == 24) {
        BOOL v8 = 0;
      }
      BOOL v9 = v7 == 2 || v7 == 24;
      int v6 = (v5 >> 7) & 1;
      if (v9) {
        int v6 = v8;
      }
    }
    uint64_t v10 = *((void *)a3 + 3);
    if (!v10 || (*(unsigned char *)(v10 + 8) & 1) != 0)
    {
      if (!v6) {
        goto LABEL_17;
      }
    }
    else if (((v6 | ((unsigned __int16)(v5 & 0x100) >> 8)) & 1) == 0)
    {
      goto LABEL_17;
    }
    a3 = RB::DisplayList::Builder::ensure_layer(this, a3, 0.0, 4);
  }
LABEL_17:
  return RB::DisplayList::Layer::append(a2, this, a3);
}

uint64_t RB::DisplayList::Layer::append(RB::DisplayList::Layer *this, RB::DisplayList::Builder *a2, RB::DisplayList::Item *a3)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  if (!*((unsigned char *)a2 + 272)) {
    return RB::DisplayList::Layer::append_item(this, a3);
  }
  if (*((void *)this + 1)
    || ((v6 = *((_WORD *)a3 + 23) & 0x3F, v6 != 2) ? (BOOL v7 = v6 == 24) : (BOOL v7 = 1),
        v7 || (*((unsigned char *)this + 60) & 0x21) != 0))
  {
LABEL_8:
    if (*((void *)a3 + 3))
    {
      (*(void (**)(RB::DisplayList::Item *, void))(*(void *)a3 + 144))(a3, 0);
      unsigned __int16 v31 = 0;
      uint64_t v32 = 0;
      unint64_t v33 = 16;
      uint64_t v10 = (void *)*((void *)a3 + 3);
      if (v10)
      {
        double v11 = v8;
        double v12 = v9;
        char v13 = 1;
        do
        {
          while (((*(uint64_t (**)(unint64_t, double, double))(*(void *)(v10[1] & 0xFFFFFFFFFFFFFFFELL)
                                                                               + 32))(v10[1] & 0xFFFFFFFFFFFFFFFELL, v11, v12) & 1) != 0)
          {
            char v13 = 0;
            uint64_t v10 = (void *)*v10;
            if (!v10)
            {
              uint64_t v16 = v32;
              goto LABEL_21;
            }
          }
          uint64_t v14 = v10[1];
          uint64_t v15 = v32;
          uint64_t v16 = v32 + 1;
          if (v33 < v32 + 1)
          {
            _ZN2RB6vectorIDv4_DF16_Lm16EmE12reserve_slowEm(__dst, v32 + 1);
            uint64_t v15 = v32;
            uint64_t v16 = v32 + 1;
          }
          int v17 = v31;
          if (!v31) {
            int v17 = __dst;
          }
          *(void *)&v17[8 * v15] = v14 & 0xFFFFFFFFFFFFFFFELL;
          uint64_t v32 = v16;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
        if (v13) {
          goto LABEL_41;
        }
LABEL_21:
        int32x4_t v29 = 0;
        if (v16)
        {
          uint64_t v18 = *((void *)this + 1);
          if (!v18) {
            goto LABEL_33;
          }
          double v19 = *(const RB::DisplayList::ClipNode **)(v18 + 24);
          if (!v19) {
            goto LABEL_33;
          }
          int8x16_t v20 = v31;
          if (!v31) {
            int8x16_t v20 = __dst;
          }
          char v21 = 1;
          uint64_t v22 = 8 * v16;
          float v23 = v19;
          do
          {
            if (v23 && *v20 == (*((void *)v23 + 1) & 0xFFFFFFFFFFFFFFFELL)) {
              float v23 = *(const RB::DisplayList::ClipNode **)v23;
            }
            else {
              char v21 = 0;
            }
            ++v20;
            v22 -= 8;
          }
          while (v22);
          if ((v21 & (v23 == 0)) == 0)
          {
LABEL_33:
            uint64_t v24 = 8 * v16 - 8;
            do
            {
              unsigned __int16 v25 = v31;
              if (!v31) {
                unsigned __int16 v25 = __dst;
              }
              double v19 = (const RB::DisplayList::ClipNode *)RB::Heap::emplace<RB::DisplayList::ClipNode,RB::DisplayList::Clip const*&,RB::DisplayList::ClipNode*&>((size_t *)(*((void *)a2 + 1) + 16), (const RB::DisplayList::Clip **)&v25[v24], &v29);
              int32x4_t v29 = v19;
              v24 -= 8;
              --v16;
            }
            while (v16);
          }
        }
        else
        {
          double v19 = 0;
        }
        *((void *)a3 + 3) = v19;
LABEL_41:
        if (v31) {
          free(v31);
        }
      }
    }
    return RB::DisplayList::Layer::append_item(this, a3);
  }
  char v27 = RB::blend_into_zero(v6);
  *((_WORD *)a3 + 23) = *((_WORD *)a3 + 23) & 0xFFC0 | v27 & 0x3F;
  if ((v27 & 0x3F) != 1)
  {
    if (*((unsigned char *)a2 + 272)) {
      goto LABEL_8;
    }
    return RB::DisplayList::Layer::append_item(this, a3);
  }
  char v28 = **(uint64_t (***)(RB::DisplayList::Item *))a3;
  return v28(a3);
}

void sub_2140FF14C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27)
{
  if (a27) {
    free(a27);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::DisplayList::Layer::append_item(RB::DisplayList::Layer *this, RB::DisplayList::Item *a2)
{
  *((void *)a2 + 1) = 0;
  uint64_t v4 = *((void *)this + 1);
  if (v4) {
    unsigned int v5 = (RB::DisplayList::Layer *)(v4 + 8);
  }
  else {
    unsigned int v5 = this;
  }
  *(void *)unsigned int v5 = a2;
  *((void *)this + 1) = a2;
  unsigned int v6 = *((unsigned __int16 *)a2 + 23);
  if (((v6 >> 6) & 0x10) != 0)
  {
    if (((v6 >> 6) & 8) != 0 && *(unsigned char *)(*((void *)a2 + 6) + 67))
    {
      *((unsigned char *)this + 67) = *(unsigned char *)(*((void *)a2 + 6) + 67) - 1;
      unsigned int v6 = 0x2000;
    }
    else
    {
      unsigned int v6 = 16;
    }
    *((_DWORD *)this + 15) |= v6;
    LOWORD(v6) = *((_WORD *)a2 + 23);
  }
  if ((v6 & 0x2000) != 0)
  {
    *((_DWORD *)this + 15) |= 0x80u;
    LOWORD(v6) = *((_WORD *)a2 + 23);
  }
  int v7 = v6 & 0x3F;
  if (v7 != 2 && v7 != 24)
  {
    *((_DWORD *)this + 15) |= 0x100u;
    if ((RB::pdf_blend(*((_WORD *)a2 + 23) & 0x3F) & 1) == 0) {
      *((_DWORD *)this + 15) |= 0x1000u;
    }
  }
  unsigned int v9 = *((unsigned __int8 *)this + 65);
  int v10 = (*(uint64_t (**)(RB::DisplayList::Item *))(*(void *)a2 + 136))(a2);
  uint64_t result = RB::max_color_depth(v9, v10);
  *((unsigned char *)this + 65) = result;
  return result;
}

uint64_t RB::max_color_depth(unsigned int a1, int a2)
{
  if (a2 == 4 || a1 == 0) {
    unsigned int v3 = 0;
  }
  else {
    unsigned int v3 = a1;
  }
  unsigned int v4 = v3 | a2;
  if (!a2) {
    unsigned int v4 = a1;
  }
  if (a1 == 4) {
    return 4;
  }
  else {
    return v4;
  }
}

uint64_t RB::required_color_depth(RB *this, float a2, float a3)
{
  float v3 = a2 + 0.001;
  float v4 = a3 + -0.001;
  if (v4 > 1.251 || v3 < -0.75294) {
    unsigned int v6 = 4;
  }
  else {
    unsigned int v6 = 2;
  }
  if (v4 > 1.0 || v3 < 0.0) {
    return v6;
  }
  else {
    return 0;
  }
}

uint64_t RB::Fill::Color::required_depth(float16x4_t *this)
{
  float32x4_t v1 = (float32x4_t)vbicq_s8((int8x16_t)vcvtq_f32_f16(*this), (int8x16_t)vmovl_s16(vceq_f16(*this, (float16x4_t)0xF800F800F800F800)));
  return RB::required_color_depth((RB *)this, vminvq_f32(v1), vmaxvq_f32(v1));
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::required_depth(float16x4_t *a1)
{
  return RB::Fill::Color::required_depth(a1 + 11);
}

__n128 RB::DisplayList::State::copy_ctm(__n128 *this, RB::Heap *a2)
{
  if (!this[7].n128_u64[0])
  {
    unint64_t v3 = (*((void *)a2 + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
    if (v3 + 48 > *((void *)a2 + 3)) {
      unint64_t v3 = RB::Heap::alloc_slow((size_t *)a2, 0x30uLL, 15);
    }
    else {
      *((void *)a2 + 2) = v3 + 48;
    }
    __n128 result = this[1];
    __n128 v5 = this[3];
    *(__n128 *)(v3 + 16) = this[2];
    *(__n128 *)(v3 + 32) = v5;
    *(__n128 *)unint64_t v3 = result;
    this[7].n128_u64[0] = v3;
  }
  return result;
}

uint64_t rb_blend_mode(unsigned int a1)
{
  if (a1 <= 0x1B) {
    return rb_blend_mode(RBBlendMode)::cg_table[a1];
  }
  if (a1 - 1000 <= 0xD) {
    return rb_blend_mode(RBBlendMode)::custom_table[a1 - 1000];
  }
  if (a1 == 2000) {
    return 24;
  }
  return 2;
}

{
  if (a1 > 0x2F) {
    return 0;
  }
  else {
    return dword_214219D10[a1];
  }
}

RB::DisplayList::Builder *RB::DisplayList::Builder::draw(RB::DisplayList::Contents **this, int8x16_t *a2, int8x16_t *a3)
{
  if (!this[1]) {
    RB::DisplayList::Builder::reset_contents((RB::DisplayList::Builder *)this);
  }
  unsigned int v6 = (RB::DisplayList::Layer **)this[4];
  if (!v6 || (int v7 = *v6, *((_DWORD *)*v6 + 14) != a3[9].i32[0])) {
    RB::precondition_failure((RB *)"current layer doesn't match drawing state", a2->i8);
  }
  a2[1] = vextq_s8(a3[6], a3[6], 8uLL);
  if (!*((unsigned char *)this + 272))
  {
    a2[2].i64[0] = (uint64_t)RB::DisplayList::State::copy_metadata((RB::DisplayList::State *)a3, this[1]);
    a2[2].i32[2] = a3[4].i32[0];
    int v7 = *(RB::DisplayList::Layer **)this[4];
  }
  return RB::DisplayList::Builder::draw((RB::DisplayList::Builder *)this, (RB::DisplayList::Item *)a2, v7, 0);
}

void *RB::DisplayList::State::copy_metadata(RB::DisplayList::State *this, RB::DisplayList::Contents *a2)
{
  BOOL v2 = (void *)*((void *)this + 15);
  if (!v2)
  {
    unsigned int v9 = 0;
    LODWORD(v8) = *((_DWORD *)this + 38);
    RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)2>,RB::DisplayList::Metadata const*&,float>((RB::DisplayList::Contents *)((char *)a2 + 16), &v9, (float *)&v8);
    unsigned int v9 = v5;
    if (*((void *)this + 21) != 0x100000000) {
      unsigned int v9 = RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)4>,RB::DisplayList::Metadata const*&,RB::AnimationLayer &>((RB::DisplayList::Contents *)((char *)a2 + 16), &v9, (void *)this + 21);
    }
    if (*((void *)this + 20)) {
      unsigned int v9 = RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)3>,RB::DisplayList::Metadata const*&,RB::TextIdentity const*&>((RB::DisplayList::Contents *)((char *)a2 + 16), &v9, (uint64_t *)this + 20);
    }
    if (*((void *)this + 11))
    {
      uint64_t v8 = *((void *)this + 11);
      unsigned int v6 = RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)1>,RB::DisplayList::Metadata const*&,RB::Transition *&>((RB::DisplayList::Contents *)((char *)a2 + 16), &v9, &v8);
      RB::DisplayList::Metadata::Traits<(RB::DisplayList::Metadata::Type)1>::retain((_DWORD *)v6[1], (uint64_t)a2);
      unsigned int v9 = v6;
    }
    if (uuid_is_null((const unsigned __int8 *)this + 68))
    {
      BOOL v2 = v9;
    }
    else
    {
      BOOL v2 = (void *)((*((void *)a2 + 4) + 7) & 0xFFFFFFFFFFFFFFF8);
      if ((unint64_t)(v2 + 2) > *((void *)a2 + 5)) {
        BOOL v2 = (void *)RB::Heap::alloc_slow((size_t *)a2 + 2, 0x10uLL, 7);
      }
      else {
        *((void *)a2 + 4) = v2 + 2;
      }
      *BOOL v2 = v9;
      v2[1] = (char *)this + 68;
      v2[1] = RB::DisplayList::Contents::intern_uuid(a2, (const UUID *)((char *)this + 68));
    }
    *((void *)this + 15) = v2;
  }
  return v2;
}

uint64_t RB::DisplayList::Builder::culling_bounds(RB::DisplayList::Builder *this, RB::DisplayList::State *a2)
{
  if (!*((unsigned char *)this + 272)) {
    return 0;
  }
  uint64_t result = RB::DisplayList::Builder::crop_bounds(this, a2);
  uint32x2_t v3 = (uint32x2_t)vcge_f32((float32x2_t)(*(void *)(result + 8) & 0x7FFFFFFF7FFFFFFFLL), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  if (vpmax_u32(v3, v3).i32[0] < 0) {
    return 0;
  }
  return result;
}

void RBShapeData::apply<RB::DisplayList::ItemFactory>(float32x2_t *a1, uint64_t a2, double a3, double a4, int8x16_t a5, int32x4_t a6)
{
  switch(a1->i32[0])
  {
    case 1:
      RB::DisplayList::ItemFactory::operator()<RB::Coverage::Primitive>(a2, a1 + 2, a3, a4, a5, a6);
      break;
    case 2:
      RB::DisplayList::ItemFactory::operator()<RB::Coverage::Path>(a2, (RB::Coverage::Path *)&a1[2]);
      break;
    case 3:
      RB::DisplayList::ItemFactory::operator()<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(a2, (uint64_t)&a1[2]);
      break;
    case 4:
      RB::DisplayList::ItemFactory::operator()<RB::Coverage::Glyphs>(a2, (RB::Coverage::Glyphs *)&a1[2]);
      break;
    case 5:
      RB::DisplayList::ItemFactory::operator()<RB::Coverage::Stroke<RBStrokeRef>>(a2, &a1[2]);
      break;
    default:
      return;
  }
}

uint64_t RB::DisplayList::ItemFactory::operator()<RB::Coverage::Path>(uint64_t a1, RB::Coverage::Path *this)
{
  float v4 = *(float32x2_t **)(a1 + 40);
  if (!v4) {
    goto LABEL_3;
  }
  v12[0] = xmmword_2142181C0;
  v12[1] = xmmword_2142181D0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  v16.callbacks = (RBPathCallbacks *)v12;
  v16.info = this;
  double v5 = RB::Coverage::Path::bounds(v16);
  uint64_t result = RB::Rect::intersects(v4, v15, *(float32x2_t *)&v5, v6, v7, v8, v9, v10);
  if (result)
  {
LABEL_3:
    *(void *)&v12[0] = a1;
    *((void *)&v12[0] + 1) = this;
    return (uint64_t)RBFillData::apply<RB::DisplayList::ItemFactory::Inner<RB::Coverage::Path>>(*(void **)(a1 + 32), (uint64_t *)v12);
  }
  return result;
}

void *RBFillData::apply<RB::DisplayList::ItemFactory::Inner<RB::Coverage::Path>>(void *result, uint64_t *a2)
{
  switch(*(_DWORD *)result)
  {
    case 1:
      uint64_t result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Path>::operator()<RB::Fill::Color>(a2, (uint64_t)(result + 2));
      break;
    case 2:
      uint64_t result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Path>::operator()<RB::Fill::Gradient>(a2, result + 2);
      break;
    case 3:
      uint64_t result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Path>::operator()<RB::Fill::MeshGradient>(a2, (uint64_t)(result + 2));
      break;
    case 4:
      uint64_t result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Path>::operator()<RB::Fill::Image<RB::ImageTexture>>(a2, (const RB::ImageTexture *)(result + 2));
      break;
    case 5:
      uint64_t result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Path>::operator()<RB::Fill::Custom>(a2, (uint64_t)(result + 2));
      break;
    default:
      return result;
  }
  return result;
}

void *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Path>::operator()<RB::Fill::Color>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  if (*(unsigned char *)(*a1 + 48))
  {
    v6[0] = &unk_26C4EA4C0;
    v6[1] = a1;
    v6[2] = a2;
    RB::Coverage::Path::simplify(a1[1], (uint64_t)v6);
    uint64_t v4 = *a1;
  }
  uint64_t result = *(void **)(v4 + 56);
  if (!result)
  {
    uint64_t result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Color>,RB::Heap&,RB::Coverage::Path const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v4, *(size_t **)v4, a1[1], a2, (uint64_t *)(v4 + 8), (float *)(v4 + 16), (_DWORD *)(v4 + 20), (__int16 *)(v4 + 24));
    uint64_t v4 = *a1;
    *(void *)(*a1 + 56) = result;
  }
  if (*(unsigned char *)(v4 + 48)) {
    *((_WORD *)result + 23) |= 0x1000u;
  }
  return result;
}

void *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Color>,RB::Heap&,RB::Coverage::Path const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, size_t *a2, uint64_t a3, uint64_t a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16 = *((void *)this + 3);
  uint64_t v17 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 104 > v16) {
    uint64_t v17 = RB::Heap::alloc_slow((size_t *)this, 0x68uLL, 7);
  }
  else {
    *((void *)this + 2) = v17 + 104;
  }
  uint64_t result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  *uint64_t result = &unk_26C4E8EE0;
  return result;
}

uint64_t RB::DisplayList::Item::apply_alpha(uint64_t this, float a2)
{
  if (a2 != 1.0)
  {
    if ((*(_WORD *)(this + 46) & 0x23F) == 0x218)
    {
      uint32x2_t v3 = *(RB::DisplayList::Item ***)(this + 48);
      if (v3)
      {
        for (uint64_t i = *v3; i; uint64_t i = (RB::DisplayList::Item *)*((void *)i + 1))
          this = RB::DisplayList::Item::apply_alpha(i, a2);
      }
    }
    else
    {
      _H0 = *(_WORD *)(this + 44);
      __asm { FCVT            S0, H0 }
      _S0 = _S0 * a2;
      __asm { FCVT            H0, S0 }
      *(_WORD *)(this + 44) = LOWORD(_S0);
    }
  }
  return this;
}

void RB::UntypedTable::~UntypedTable(RB::UntypedTable *this)
{
  if ((*((void *)this + 2) || *((void *)this + 3)) && *((void *)this + 7))
  {
    unint64_t v2 = 0;
    int v3 = *((_DWORD *)this + 18);
    do
    {
      for (uint64_t i = *(void **)(*((void *)this + 6) + 8 * v2); i; uint64_t i = (void *)*i)
      {
        double v5 = (void (*)(void))*((void *)this + 2);
        if (v5) {
          v5(i[1]);
        }
        float32x2_t v6 = (void (*)(void))*((void *)this + 3);
        if (v6) {
          v6(i[2]);
        }
      }
      ++v2;
    }
    while (!(v2 >> v3));
  }
  if (*((_DWORD *)this + 18) >= 5u) {
    free(*((void **)this + 6));
  }
  if (*((unsigned char *)this + 76))
  {
    double v7 = (RB::Heap *)*((void *)this + 4);
    if (v7)
    {
      RB::Heap::~Heap(v7);
      MEMORY[0x21669AC10]();
    }
  }
}

uint64_t RB::Symbol::Glyph::Layer::set_shape(uint64_t a1, void *a2, float64x2_t *a3, float32x2_t a4)
{
  double v7 = *(uint64_t **)a1;
  uint32x2_t v8 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(a4, (float32x2_t)0x3F80000000000000));
  unsigned __int32 v9 = vpmax_u32(v8, v8).u32[0];
  float v10 = *(float *)(a1 + 76);
  if ((v9 & 0x80000000) == 0)
  {
    BOOL v11 = 0;
LABEL_5:
    if (v10 <= 0.0)
    {
      uint64_t v12 = *v7;
      uint64_t v13 = v7[1];
      float v14 = *(float *)(a1 + 60);
      if (v14 == 0.0)
      {
        double v15 = *(float *)(a1 + 56);
        float64x2_t v16 = vmulq_n_f64(*a3, v15);
        float64x2_t v17 = vmulq_n_f64(a3[1], v15);
        float64x2_t v18 = a3[2];
      }
      else
      {
        float64x2_t v45 = a3[1];
        float64x2_t v18 = vmlaq_f64(vmlaq_n_f64(a3[2], *a3, v14), (float64x2_t)0, v45);
        float v46 = *(float *)(a1 + 56);
        double v47 = v46;
        float64x2_t v16 = vmulq_n_f64(*a3, (float)-v46);
        float64x2_t v17 = vmulq_n_f64(v45, v47);
      }
      v54[0] = v16;
      v54[1] = v17;
      v54[2] = v18;
      return objc_msgSend(a2, "setRBPath:transform:", v12, v13, v54);
    }
    goto LABEL_8;
  }
  if (v10 > 0.0)
  {
LABEL_26:
    RB::Symbol::Glyph::Layer::copy_path(a1, 0, &v51, a4);
    uint64_t v35 = v51;
    uint64_t v34 = v52;
    float v36 = *(float *)(a1 + 60);
    if (v36 == 0.0)
    {
      double v37 = *(float *)(a1 + 56);
      float64x2_t v38 = vmulq_n_f64(*a3, v37);
      float64x2_t v39 = vmulq_n_f64(a3[1], v37);
      float64x2_t v40 = a3[2];
    }
    else
    {
      float64x2_t v41 = a3[1];
      float64x2_t v40 = vmlaq_f64(vmlaq_n_f64(a3[2], *a3, v36), (float64x2_t)0, v41);
      float v42 = *(float *)(a1 + 56);
      double v43 = v42;
      float64x2_t v38 = vmulq_n_f64(*a3, (float)-v42);
      float64x2_t v39 = vmulq_n_f64(v41, v43);
    }
    v50[0] = v38;
    v50[1] = v39;
    v50[2] = v40;
    objc_msgSend(a2, "setRBPath:transform:", v51, v52, v50);
    return RBPathRelease(v35, v34);
  }
  BOOL v11 = *((_DWORD *)v7 + 6) != 0;
  if (!*((_DWORD *)v7 + 6)) {
    goto LABEL_5;
  }
LABEL_8:
  if (v10 <= 0.0) {
    BOOL v11 = 1;
  }
  if (v11) {
    goto LABEL_26;
  }
  float64x2_t v19 = *a3;
  float64x2_t v20 = a3[1];
  double v21 = a3[1].f64[1];
  double v22 = a3->f64[1];
  if (a3->f64[0] != v21 || v22 != 0.0 || v20.f64[0] != 0.0)
  {
    if (v21 != 0.0) {
      goto LABEL_26;
    }
    if (v19.f64[0] != 0.0 || v22 != v20.f64[0]) {
      goto LABEL_26;
    }
  }
  double v24 = fabs(v19.f64[0]);
  double v25 = fabs(v22);
  double v26 = v22 == 0.0 ? v24 : v25;
  float v27 = v26;
  if (v27 != 1.0) {
    goto LABEL_26;
  }
  uint64_t v28 = *v7;
  uint64_t v29 = v7[1];
  float v30 = *(float *)(a1 + 60);
  if (v30 == 0.0)
  {
    float64x2_t v31 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(*(float *)(a1 + 56)), 0);
    float64x2_t v32 = a3[2];
    float64x2_t v33 = v31;
  }
  else
  {
    float64x2_t v32 = vmlaq_n_f64(vmlaq_f64(a3[2], (float64x2_t)0, v20), v19, v30);
    float v48 = *(float *)(a1 + 56);
    *(double *)&uint64_t v49 = v48;
    float64x2_t v31 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((float)-v48), 0);
    float64x2_t v33 = (float64x2_t)vdupq_lane_s64(v49, 0);
  }
  v53[0] = vmulq_f64(v31, v19);
  v53[1] = vmulq_f64(v33, v20);
  v53[2] = v32;
  return objc_msgSend(a2, "setStrokedRBPath:transform:lineWidth:lineCap:lineJoin:miterLimit:dashPhase:dashPattern:dashCount:", v28, v29, v53, ((__int16)*(_DWORD *)(a1 + 84) >> 12), ((int)(*(_DWORD *)(a1 + 84) << 14) >> 30), 0, v10, 10.0, 0.0, 0);
}

void sub_2140FFD04(_Unwind_Exception *a1)
{
  RBPathRelease(v2, v1);
  _Unwind_Resume(a1);
}

void sub_2140FFF14(_Unwind_Exception *a1)
{
  RBPathRelease(*(void *)(v1 + 32), *(void *)(v1 + 40));
  _Unwind_Resume(a1);
}

uint64_t RBPathRelease(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(uint64_t (**)(void))(a2 + 16);
  if (v2) {
    return v2();
  }
  return result;
}

void RBShapeData::apply<RB::DestroyAny>(int *a1)
{
  int v1 = *a1;
  if (*a1 == 5)
  {
    *((void *)a1 + 2) = &unk_26C4EDD28;
  }
  else if (v1 == 3)
  {
    *((void *)a1 + 2) = &unk_26C4EDD48;
    RBPathRelease(*((void *)a1 + 3), *((void *)a1 + 4));
  }
  else if (v1 == 2)
  {
    RBPathRelease(*((void *)a1 + 2), *((void *)a1 + 3));
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::GenericItem1(uint64_t a1, size_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  __asm { FCVT            H0, S0 }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F;
  *(void *)a1 = &unk_26C4EA680;
  *(void *)(a1 + 48) = a5;
  *(void *)(a1 + 56) = RBPathRetain(*(void *)a3, *(void *)(a3 + 8));
  *(void *)(a1 + 64) = v18;
  float64x2_t v19 = *(long long **)(a3 + 16);
  if (v19)
  {
    float64x2_t v20 = (_OWORD *)((a2[2] + 15) & 0xFFFFFFFFFFFFFFF0);
    if ((unint64_t)(v20 + 3) > a2[3]) {
      float64x2_t v20 = (_OWORD *)RB::Heap::alloc_slow(a2, 0x30uLL, 15);
    }
    else {
      a2[2] = (size_t)(v20 + 3);
    }
    long long v21 = *v19;
    long long v22 = v19[2];
    v20[1] = v19[1];
    v20[2] = v22;
    *float64x2_t v20 = v21;
  }
  else
  {
    float64x2_t v20 = 0;
  }
  *(void *)(a1 + 72) = v20;
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a3 + 24);
  *(_WORD *)(a1 + 84) = *(_WORD *)(a3 + 28);
  if (*(unsigned char *)(a4 + 9)) {
    __int16 v23 = *(_WORD *)(a4 + 8);
  }
  else {
    __int16 v23 = a7;
  }
  *(void *)(a1 + 88) = *(void *)a4;
  *(_WORD *)(a1 + 96) = v23;
  return a1;
}

void sub_2141000C0(_Unwind_Exception *a1)
{
  RBPathRelease(*(void *)(v1 + 56), *(void *)(v1 + 64));
  _Unwind_Resume(a1);
}

uint64_t RBPathRetain(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(uint64_t (**)(void))(a2 + 8);
  if (v2) {
    return v2();
  }
  return result;
}

uint64_t RB::Path::Object::$_6::__invoke(uint64_t this, const void *a2)
{
  return this;
}

uint64_t RB::DisplayList::Builder::null_style_draw(RB::DisplayList::Builder *this, RB::DisplayList::Item *a2, RB::DisplayList::Layer *a3, char a4)
{
  __int16 v7 = *((_WORD *)a2 + 23);
  if ((v7 & 0x200) == 0 || !*((unsigned char *)this + 272)) {
    goto LABEL_19;
  }
  uint64_t v9 = *((void *)a2 + 6);
  int v10 = *(_DWORD *)(v9 + 60);
  if ((v10 & 0x800) != 0)
  {
    if ((v7 & 0x3F) == 0x18 && !*(void *)(v9 + 16) && !*(unsigned char *)(v9 + 64) && *(float *)(v9 + 48) == 0.0)
    {
      float v42 = *(RB::DisplayList::Item **)v9;
      if (*(void *)v9)
      {
        double v43 = 0;
        char v44 = (const RB::DisplayList::ClipNode *)*((void *)a2 + 3);
        float64x2_t v45 = v44;
        do
        {
          *(void *)uint64_t v9 = *((void *)v42 + 1);
          _H0 = *((_WORD *)a2 + 22);
          __asm { FCVT            S0, H0; float }
          RB::DisplayList::Item::apply_alpha((uint64_t)v42, _S0);
          if (v43 != *((void **)v42 + 3))
          {
            double v43 = (void *)*((void *)v42 + 3);
            float64x2_t v45 = RB::DisplayList::Builder::join_clip_lists((uint64_t)this, v43, v44);
          }
          *((void *)v42 + 3) = v45;
          RB::DisplayList::Builder::append(this, a3, v42);
          float v42 = *(RB::DisplayList::Item **)v9;
        }
        while (*(void *)v9);
      }
      goto LABEL_16;
    }
    *(_DWORD *)(v9 + 60) = v10 & 0xFFFFF7FF;
    __int16 v7 = *((_WORD *)a2 + 23);
    if ((v7 & 0x3F) == 0x18)
    {
      __int16 v7 = v7 & 0xFFC0 | 2;
      *((_WORD *)a2 + 23) = v7;
    }
  }
  if (!*(void *)v9)
  {
    int v35 = *(_DWORD *)(v9 + 60);
    if ((v35 & 1) == 0 || *(unsigned char *)(v9 + 67) || *(float *)(v9 + 48) != 0.0) {
      goto LABEL_41;
    }
    float64x2_t v39 = *(void **)(v9 + 16);
    if (v39)
    {
      if (!v39[1] && !*(unsigned char *)(v9 + 64))
      {
        if ((*(unsigned int (**)(void *))(*v39 + 40))(v39) == 1)
        {
          float64x2_t v41 = v40;
          uint64_t v51 = v40;
          if (RB::ColorMatrix::is_identity(v40 + 1))
          {
            uint64_t v51 = 0;
            __int16 v7 = *((_WORD *)a2 + 23);
          }
          else
          {
            __int16 v7 = *((_WORD *)a2 + 23);
            if (v41)
            {
              int v48 = v7 & 0x3F;
              goto LABEL_64;
            }
          }
LABEL_63:
          int v48 = v7 & 0x3F;
          if (!v48) {
            return (**(uint64_t (***)(RB::DisplayList::Item *))a2)(a2);
          }
LABEL_64:
          uint64_t v49 = (size_t *)(*((void *)this + 1) + 16);
          int v53 = v48;
          _ZN2RB4Heap7emplaceINS_11DisplayList23BackdropColorMatrixItemEJRPKNS_6Filter11ColorMatrixERDF16_NS_9BlendModeEEEEPT_DpOT0_(v49, (uint64_t *)&v51, (__int16 *)a2 + 22, &v53);
          *(_OWORD *)(v50 + 24) = *(_OWORD *)((char *)a2 + 24);
          *(_DWORD *)(v50 + 40) = *((_DWORD *)a2 + 10);
          RB::DisplayList::Builder::append(this, a3, (RB::DisplayList::Item *)v50);
          *(void *)(v9 + 16) = 0;
          return (**(uint64_t (***)(RB::DisplayList::Item *))a2)(a2);
        }
        int v35 = *(_DWORD *)(v9 + 60);
      }
    }
    else if (!*(unsigned char *)(v9 + 64))
    {
      uint64_t v51 = 0;
      goto LABEL_63;
    }
LABEL_41:
    if ((v35 & 0x2001) != 0) {
      return RB::DisplayList::Builder::append(this, a3, a2);
    }
    char v36 = RB::DisplayList::Layer::effect_needs_zero_alpha((RB::DisplayList::Layer *)v9);
    if ((v36 & 1) == 0)
    {
      for (uint64_t i = *(void **)(v9 + 16); i; uint64_t i = (void *)i[1])
      {
        uint64_t v51 = 0;
        float32x2_t v52 = 0;
        (*(void (**)(void *, float16x4_t **))(*i + 56))(i, &v51);
        uint32x2_t v38 = (uint32x2_t)vcgtz_f32(v52);
        if ((vpmin_u32(v38, v38).u32[0] & 0x80000000) != 0) {
          return RB::DisplayList::Builder::append(this, a3, a2);
        }
      }
    }
    if (v36) {
      return RB::DisplayList::Builder::append(this, a3, a2);
    }
    return (**(uint64_t (***)(RB::DisplayList::Item *))a2)(a2);
  }
  RB::DisplayList::Builder::lower_color_filters(this, (RB::DisplayList::Layer *)v9, 1);
  _H1 = *((_WORD *)a2 + 22);
  __asm { FCVT            S1, H1 }
  _S0 = v17 * _S1;
  __asm { FCVT            H0, S0 }
  *((short float *)a2 + 22) = _H0;
  unsigned int v20 = *((_WORD *)a2 + 23) & 0x3F;
  if ((a4 & 1) == 0
    && _H0 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))
    && (v20 == 24 || v20 == 2)
    && *(float *)(v9 + 48) == 0.0)
  {
    int v21 = *(_DWORD *)(v9 + 60);
    if ((v21 & 1) == 0 && !*(unsigned char *)(v9 + 64) && (v21 & 0x11E) == 0 && !*(void *)(v9 + 16))
    {
      float v30 = (const RB::DisplayList::ClipNode *)*((void *)a2 + 3);
      if (!v30)
      {
LABEL_31:
        RB::DisplayList::Layer::append_layer_items((uint64_t)a3, (RB::DisplayList::Layer *)v9);
LABEL_16:
        uint64_t v28 = **(uint64_t (***)(RB::DisplayList::Item *))a2;
        return v28(a2);
      }
      if (*((unsigned char *)v30 + 8))
      {
        float64x2_t v31 = *(RB::DisplayList::Item **)v9;
        if (*(void *)v9)
        {
          uint64_t v32 = 0;
          float64x2_t v33 = (const RB::DisplayList::ClipNode *)*((void *)a2 + 3);
          do
          {
            uint64_t v34 = *((void *)v31 + 3);
            if (v32 != v34)
            {
              float64x2_t v33 = RB::DisplayList::Builder::join_clip_lists((uint64_t)this, *((void **)v31 + 3), v30);
              uint64_t v32 = v34;
            }
            *((void *)v31 + 3) = v33;
            float64x2_t v31 = (RB::DisplayList::Item *)*((void *)v31 + 1);
          }
          while (v31);
        }
        goto LABEL_31;
      }
    }
  }
  int may_discard_alpha = RB::may_discard_alpha(v20);
  uint64_t v23 = RB::DisplayList::Builder::merge_layer_item(this, (RB::DisplayList::Layer *)v9, may_discard_alpha ^ 1u);
  if (v23)
  {
    uint64_t v24 = v23;
    _H0 = *((_WORD *)a2 + 22);
    __asm { FCVT            S0, H0; float }
    RB::DisplayList::Item::apply_alpha(v23, _S0);
    *(_WORD *)(v24 + 46) = *(_WORD *)(v24 + 46) & 0xFFC0 | *((_WORD *)a2 + 23) & 0x3F;
    float v27 = (const RB::DisplayList::ClipNode *)*((void *)a2 + 3);
    if (v27) {
      *(void *)(v24 + 24) = RB::DisplayList::Builder::join_clip_lists((uint64_t)this, *(void **)(v24 + 24), v27);
    }
    RB::DisplayList::Builder::append(this, a3, (RB::DisplayList::Item *)v24);
    goto LABEL_16;
  }
LABEL_19:
  return RB::DisplayList::Builder::append(this, a3, a2);
}

void RB::DisplayList::Layer::~Layer(RB::DisplayList::Layer *this)
{
  for (uint64_t i = *(void *)this; i; uint64_t i = *(void *)(i + 8))
    (**(void (***)(uint64_t))i)(i);
  for (uint64_t j = *((void *)this + 2); j; uint64_t j = *(void *)(j + 8))
    (**(void (***)(uint64_t))j)(j);
}

void *RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Color>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4EA680;
  RBPathRelease(a1[7], a1[8]);
  return a1;
}

atomic_uint *RB::Path::Object::$_7::__invoke(atomic_uint *this, const void *a2)
{
  if (atomic_fetch_add_explicit(this + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)this + 8))();
  }
  return this;
}

void *RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Color>::copy(uint64_t a1, uint64_t a2, char a3)
{
  __int16 v4 = 0;
  double v5 = (RB::Heap *)(*(void *)(a2 + 8) + 16);
  __int16 v6 = *(_WORD *)(a1 + 46);
  if ((a3 & 2) != 0) {
    goto LABEL_9;
  }
  if ((*(_WORD *)(a1 + 46) & 0x1000) != 0 || *(unsigned char *)(a2 + 272) == 0) {
    goto LABEL_9;
  }
  v10[0] = &unk_26C4E7F70;
  v10[1] = v5;
  v10[2] = a1;
  v10[3] = a1 + 88;
  v10[4] = *(void *)(a1 + 48);
  uint64_t v11 = 0;
  RB::Coverage::Path::simplify(a1 + 56, (uint64_t)v10);
  uint64_t result = (void *)v11;
  if (!v11)
  {
    __int16 v6 = *(_WORD *)(a1 + 46);
    __int16 v4 = 4096;
LABEL_9:
    LODWORD(v10[0]) = v6 & 0x3F;
    uint64_t result = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage4PathENS_4Fill5ColorEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, (size_t *)v5, a1 + 56, a1 + 88, (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), v10);
    *((_OWORD *)result + 1) = *(_OWORD *)(a1 + 16);
    result[4] = *(void *)(a1 + 32);
    *((_DWORD *)result + 10) = *(_DWORD *)(a1 + 40);
    __int16 v9 = *((_WORD *)result + 23) | *(_WORD *)(a1 + 46) & 0x5800;
    *((_WORD *)result + 23) = v9;
    goto LABEL_10;
  }
  __int16 v9 = *(_WORD *)(v11 + 46);
  __int16 v4 = 4096;
LABEL_10:
  *((_WORD *)result + 23) = v9 | v4;
  return result;
}

uint64_t RB::Coverage::Path::simplify(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  if (result)
  {
    double v5 = *(long long **)(a1 + 16);
    char v6 = *(unsigned char *)(a1 + 29);
    double v7 = *(float *)(a1 + 24);
    uint64_t v10 = a2;
    if (v5)
    {
      long long v8 = *v5;
      long long v9 = v5[2];
      long long v12 = v5[1];
      long long v13 = v9;
      long long v11 = v8;
    }
    else
    {
      long long v11 = xmmword_2142181C0;
      long long v12 = xmmword_2142181D0;
      long long v13 = 0uLL;
    }
    char v14 = v6;
    double v15 = v7;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    char v18 = 0;
  }
  return result;
}

uint64_t RB::Coverage::anonymous namespace'::enable_path_primitives(RB::Coverage::_anonymous_namespace_ *this)
{
  {
    unsigned __int16 v3 = RB::debug_BOOL((RB *)"RB_PATH_PRIMITIVES", v2);
    if ((_BYTE)v3) {
      BOOL v4 = 0;
    }
    else {
      BOOL v4 = v3 >= 0x100u;
    }
    char v5 = !v4;
  }
}

void sub_214100930(_Unwind_Exception *a1)
{
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::has_no_effect(uint64_t a1)
{
  __asm { FCMP            H0, #0 }
  if (_ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  __asm { FCMP            H0, #0 }
  if (_NF ^ _VF | _ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  else {
    return 0;
  }
}

void RB::DisplayList::Builder::reset_contents(RB::DisplayList::Builder *this)
{
}

void sub_214100A58(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10F1C4040C62C24);
  _Unwind_Resume(a1);
}

RB::DisplayList::Contents *RB::DisplayList::Contents::Contents(RB::DisplayList::Contents *this, int a2)
{
  *((_DWORD *)this + 2) = 1;
  *(void *)this = &unk_26C4ECD98;
  RB::Heap::Heap((RB::DisplayList::Contents *)((char *)this + 16), (char *)this + 56, 256, 0);
  *((void *)this + 39) = 0;
  RB::DisplayList::Layer::Layer((uint64_t)this + 320, a2, 32);
  *((void *)this + 49) = 0;
  *((unsigned char *)this + 400) = 1;
  return this;
}

void sub_214100B04(_Unwind_Exception *a1)
{
  RB::Heap::~Heap(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::Layer::Layer(uint64_t this, int a2, int a3)
{
  *(void *)this = 0;
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)(this + 32) = 0;
  *(void *)(this + 40) = 0;
  *(void *)(this + 48) = 0xBF80000000000000;
  *(_DWORD *)(this + 56) = a2;
  *(_DWORD *)(this + 60) = a3;
  *(_DWORD *)(this + 64) = 0;
  return this;
}

uint64_t RB::Rect::intersects(float32x2_t *this, Rect a2, float32x2_t a3, float32x2_t a4, double a5, double a6, double a7, int32x4_t a8)
{
  uint32x2_t v8 = (uint32x2_t)vceqz_f32(a4);
  if ((vpmax_u32(v8, v8).u32[0] & 0x80000000) != 0) {
    return 0;
  }
  float32x2_t v9 = this[1];
  uint32x2_t v10 = (uint32x2_t)vceqz_f32(v9);
  if ((vpmax_u32(v10, v10).u32[0] & 0x80000000) != 0) {
    return 0;
  }
  *(int32x2_t *)a8.i8 = vcltz_f32(v9);
  int32x4_t v11 = vcltzq_s32(a8);
  float32x2_t v12 = (float32x2_t)vbsl_s8(*(int8x8_t *)v11.i8, (int8x8_t)vadd_f32(*this, v9), (int8x8_t)*this);
  *(int32x2_t *)v11.i8 = vcltz_f32(a4);
  float32x2_t v13 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(v11), (int8x8_t)vadd_f32(a4, a3), (int8x8_t)a3);
  uint32x2_t v14 = (uint32x2_t)vcgt_f32(vminnm_f32(vadd_f32(v12, vabs_f32(v9)), vadd_f32(v13, (float32x2_t)(*(void *)&a4 & 0x7FFFFFFF7FFFFFFFLL))), vmaxnm_f32(v12, v13));
  return vpmin_u32(v14, v14).u32[0] >> 31;
}

uint64_t RB::DisplayList::CachedTransform::CachedTransform(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4, uint64_t a5, int a6)
{
  *(void *)a1 = a2;
  int32x4_t v11 = (RB::Heap *)(a1 + 8);
  RB::Heap::Heap((RB::Heap *)(a1 + 8), (char *)(a1 + 48), 1024, 0);
  *(void *)(a1 + 1072) = a4;
  *(void *)(a1 + 1080) = a5;
  long long v12 = *a3;
  long long v13 = a3[1];
  *(_OWORD *)(a1 + 1120) = a3[2];
  *(_OWORD *)(a1 + 1104) = v13;
  *(_OWORD *)(a1 + 1088) = v12;
  *(void *)(a1 + 1136) = 0;
  *(_DWORD *)(a1 + 1144) = a6;
  *(void *)(a1 + 1148) = 0;
  *(_OWORD *)(a1 + 1168) = 0u;
  *(_OWORD *)(a1 + 1184) = 0u;
  *(int64x2_t *)(a1 + 1200) = vdupq_n_s64(0x7FF8000000000000uLL);
  *(void *)(a1 + 1216) = 0;
  *(_OWORD *)(a1 + 1232) = 0u;
  *(void *)(a1 + 1248) = 1;
  *(_OWORD *)(a1 + 1256) = 0u;
  *(_OWORD *)(a1 + 1272) = 0u;
  RB::UntypedTable::UntypedTable(a1 + 1288, 0, 0, 0, 0, v11);
  RB::UntypedTable::UntypedTable(a1 + 1368, 0, 0, 0, 0, v11);
  *(void *)(a1 + 1448) = 0;
  *(unsigned char *)(a1 + 1456) = 0;
  return a1;
}

void sub_214100CBC(_Unwind_Exception *a1)
{
  RB::UntypedTable::~UntypedTable(v2);
  RB::Heap::~Heap(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::UntypedTable::UntypedTable(uint64_t this, unint64_t (*a2)(RB *this, const void *a2), BOOL (*a3)(RB *this, RB *a2, const void *a3), void (*a4)(void *), void (*a5)(void *), RB::Heap *a6)
{
  if (a2) {
    char v6 = a2;
  }
  else {
    char v6 = RB::pointer_hash;
  }
  if (a3) {
    double v7 = a3;
  }
  else {
    double v7 = RB::pointer_compare;
  }
  *(void *)this = v6;
  *(void *)(this + 8) = v7;
  *(void *)(this + 16) = a4;
  *(void *)(this + 24) = a5;
  if (!a6) {
    operator new();
  }
  *(void *)(this + 32) = a6;
  *(_OWORD *)(this + 40) = 0u;
  *(_OWORD *)(this + 56) = 0u;
  *(_DWORD *)(this + 72) = 0;
  *(unsigned char *)(this + 76) = a6 == 0;
  if (a3) {
    BOOL v8 = a3 == RB::pointer_compare;
  }
  else {
    BOOL v8 = 1;
  }
  char v9 = v8;
  *(unsigned char *)(this + 77) = v9;
  return this;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::required_depth(float16x4_t *a1)
{
  return RB::Fill::Color::required_depth(a1 + 14);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::required_depth(float16x4_t *a1)
{
  return RB::Fill::Color::required_depth(a1 + 14);
}

void *RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)4>,RB::DisplayList::Metadata const*&,RB::AnimationLayer &>(RB::Heap *this, void *a2, void *a3)
{
  unint64_t v6 = *((void *)this + 3);
  uint64_t result = (void *)((*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(result + 2) > v6) {
    uint64_t result = (void *)RB::Heap::alloc_slow((size_t *)this, 0x10uLL, 7);
  }
  else {
    *((void *)this + 2) = result + 2;
  }
  *uint64_t result = *a2 | 4;
  result[1] = *a3;
  return result;
}

void *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage4PathENS_4Fill5ColorEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, size_t *a2, uint64_t a3, uint64_t a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14 = *((void *)this + 3);
  uint64_t v15 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 104 > v14) {
    uint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0x68uLL, 7);
  }
  else {
    *((void *)this + 2) = v15 + 104;
  }
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  uint64_t result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  *uint64_t result = &unk_26C4E8EE0;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  uint64_t result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  uint64_t result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

int *RB::DisplayList::Item::apply_transform(RB::DisplayList::Item *this, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  unsigned int v3 = a3;
  unint64_t v6 = *((void *)this + 2);
  if (v6) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = a3 == 0;
  }
  if (v7)
  {
    BOOL v8 = 0;
  }
  else
  {
    BOOL v8 = RB::DisplayList::CachedTransform::transform_style(a2, v6, a3);
    *((void *)this + 2) = v8;
  }
  unint64_t v9 = *((void *)this + 3);
  if (v9) {
    BOOL v10 = 0;
  }
  else {
    BOOL v10 = v3 == 0;
  }
  if (!v10)
  {
    if (v8) {
      unsigned int v11 = 0;
    }
    else {
      unsigned int v11 = v3;
    }
    *((void *)this + 3) = RB::DisplayList::CachedTransform::transform_clip(a2, v9, v11);
  }
  uint64_t result = RB::DisplayList::CachedTransform::transform_metadata(a2, *((const RB::DisplayList::Metadata **)this + 4), *((_DWORD *)this + 10));
  *((void *)this + 4) = result;
  *((_DWORD *)this + 10) = v13;
  return result;
}

int *RB::DisplayList::CachedTransform::transform_metadata(RB::DisplayList::CachedTransform *this, const RB::DisplayList::Metadata *a2, int a3)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(*(void *)this + 272) || !a2 && !*((void *)this + 142)) {
    return 0;
  }
  int v8 = *((_DWORD *)this + 287) != 0;
  if (*((const RB::DisplayList::Metadata **)this + 156) != a2 || *((unsigned __int8 *)this + 1256) != v8)
  {
    uint64_t v37 = 0;
    long long v35 = 0u;
    long long v36 = 0u;
    if (a2)
    {
      BOOL v10 = a2;
      do
      {
        uint64_t v11 = *(void *)v10;
        uint64_t v12 = *(void *)v10 & 7;
        if (*((void *)&v35 + v12)) {
          BOOL v10 = (const RB::DisplayList::Metadata *)*((void *)&v35 + v12);
        }
        *((void *)&v35 + v12) = v10;
        BOOL v10 = (const RB::DisplayList::Metadata *)(v11 & 0xFFFFFFFFFFFFFFF8);
      }
      while ((v11 & 0xFFFFFFFFFFFFFFF8) != 0);
    }
    int v13 = (uint64_t *)*((void *)this + 142);
    long long v32 = 0uLL;
    long long v33 = 0uLL;
    uint64_t v34 = 0;
    if (v13)
    {
      do
      {
        uint64_t v14 = *v13;
        uint64_t v15 = *v13 & 7;
        if (*((void *)&v32 + v15)) {
          int v13 = (uint64_t *)*((void *)&v32 + v15);
        }
        *((void *)&v32 + v15) = v13;
        int v13 = (uint64_t *)(v14 & 0xFFFFFFFFFFFFFFF8);
      }
      while ((v14 & 0xFFFFFFFFFFFFFFF8) != 0);
    }
    unint64_t v6 = 0;
    float64x2_t v31 = 0;
    uint64_t v16 = 4;
    while (2)
    {
      switch(v16)
      {
        case 0:
          if (a3 && (uint64_t v25 = v35) != 0
            || ((uint64_t v25 = v32, *((_DWORD *)this + 287)) ? (v26 = (void)v32 == 0) : (v26 = 1), !v26))
          {
            float v27 = *(const UUID **)(v25 + 8);
            if (v27)
            {
              uint64_t v28 = *(size_t **)(*(void *)this + 8);
              uint64_t v29 = (int *)((v28[4] + 7) & 0xFFFFFFFFFFFFFFF8);
              if ((unint64_t)(v29 + 4) > v28[5])
              {
                uint64_t v29 = (int *)RB::Heap::alloc_slow(v28 + 2, 0x10uLL, 7);
                unint64_t v6 = v31;
              }
              else
              {
                v28[4] = (size_t)(v29 + 4);
              }
              *(void *)uint64_t v29 = v6;
              *((void *)v29 + 1) = v27;
              *((void *)v29 + 1) = RB::DisplayList::Contents::intern_uuid((RB::DisplayList::Contents *)v28, v27);
              unint64_t v6 = v29;
            }
          }
          *((void *)this + 156) = a2;
          *((unsigned char *)this + 1256) = v8;
          *((void *)this + 158) = v6;
          return v6;
        case 1:
          if (*((void *)&v35 + 1))
          {
            uint64_t v17 = *(void *)(*((void *)&v35 + 1) + 8);
            uint64_t v30 = v17;
            uint64_t v18 = *((void *)&v32 + 1);
            if (!*((void *)&v32 + 1)) {
              goto LABEL_38;
            }
            if (v17 && !*(unsigned char *)(v17 + 13))
            {
LABEL_39:
              uint64_t v24 = *(void *)(*(void *)this + 8);
              unint64_t v6 = (int *)RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)1>,RB::DisplayList::Metadata const*&,RB::Transition *&>((RB::Heap *)(v24 + 16), &v31, &v30);
              RB::DisplayList::Metadata::Traits<(RB::DisplayList::Metadata::Type)1>::retain(*((_DWORD **)v6 + 1), v24);
              goto LABEL_40;
            }
          }
          else
          {
            uint64_t v18 = *((void *)&v32 + 1);
            if (!*((void *)&v32 + 1)) {
              goto LABEL_41;
            }
          }
          uint64_t v17 = *(void *)(v18 + 8);
          uint64_t v30 = v17;
LABEL_38:
          if (!v17) {
            goto LABEL_41;
          }
          goto LABEL_39;
        case 2:
          uint64_t v19 = v36;
          if (!(void)v36)
          {
            uint64_t v19 = v33;
            if (!(void)v33) {
              goto LABEL_41;
            }
          }
          RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)2>,RB::DisplayList::Metadata const*&,float>((RB::Heap *)(*(void *)(*(void *)this + 8) + 16), &v31, (float *)(v19 + 8));
          goto LABEL_35;
        case 3:
          uint64_t v21 = *((void *)&v36 + 1);
          if (*((void *)&v36 + 1) || (uint64_t v21 = *((void *)&v33 + 1)) != 0)
          {
            long long v22 = *(size_t **)(*(void *)this + 8);
            unint64_t v6 = (int *)RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)3>,RB::DisplayList::Metadata const*&,RB::TextIdentity const*&>((RB::Heap *)(v22 + 2), &v31, (uint64_t *)(v21 + 8));
            RB::DisplayList::Metadata::Traits<(RB::DisplayList::Metadata::Type)3>::retain(v6 + 2, v22);
LABEL_40:
            float64x2_t v31 = v6;
          }
          goto LABEL_41;
        case 4:
          uint64_t v23 = v37;
          if (!v37)
          {
            uint64_t v23 = v34;
            if (!v34) {
              goto LABEL_41;
            }
          }
          unsigned int v20 = (int *)RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)4>,RB::DisplayList::Metadata const*&,RB::AnimationLayer &>((RB::Heap *)(*(void *)(*(void *)this + 8) + 16), &v31, (void *)(v23 + 8));
LABEL_35:
          unint64_t v6 = v20;
          float64x2_t v31 = v20;
LABEL_41:
          --v16;
          continue;
        default:
          goto LABEL_41;
      }
    }
  }
  return (int *)*((void *)this + 158);
}

_OWORD *RB::DisplayList::CachedTransform::transform_ctm(float64x2_t *this, const RB::AffineTransform *a2)
{
  if (a2)
  {
    long long v3 = *((_OWORD *)a2 + 1);
    float64x2_t v17 = *(float64x2_t *)a2;
    long long v18 = v3;
    float64x2_t v19 = *((float64x2_t *)a2 + 2);
    float64x2_t v4 = v17;
    float64x2_t v5 = (float64x2_t)v3;
    float64x2_t v6 = v19;
  }
  else
  {
    float64x2_t v4 = (float64x2_t)xmmword_2142181C0;
    float64x2_t v5 = (float64x2_t)xmmword_2142181D0;
    float64x2_t v17 = (float64x2_t)xmmword_2142181C0;
    long long v18 = xmmword_2142181D0;
    float64x2_t v6 = 0uLL;
    float64x2_t v19 = 0u;
  }
  int64x2_t v7 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(this[74], v5), (int8x16_t)vceqq_f64(this[73], v4)), (int8x16_t)vceqq_f64(this[75], v6));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v7, 1), (int8x16_t)v7).u64[0] & 0x8000000000000000) != 0) {
    return *(_OWORD **)&this[76].f64[0];
  }
  long long v8 = v18;
  this[73] = v17;
  this[74] = (float64x2_t)v8;
  this[75] = v19;
  unint64_t v9 = *(size_t **)(*(void *)&this->f64[0] + 8);
  *(double *)&long long v10 = RB::operator*(&v17, this + 68);
  uint64_t result = (_OWORD *)((v9[4] + 15) & 0xFFFFFFFFFFFFFFF0);
  if ((unint64_t)(result + 3) > v9[5])
  {
    long long v15 = v11;
    long long v16 = v10;
    long long v14 = v12;
    uint64_t result = (_OWORD *)RB::Heap::alloc_slow(v9 + 2, 0x30uLL, 15);
    long long v12 = v14;
    long long v11 = v15;
    long long v10 = v16;
  }
  else
  {
    v9[4] = (size_t)(result + 3);
  }
  *uint64_t result = v10;
  result[1] = v11;
  result[2] = v12;
  *(void *)&this[76].f64[0] = result;
  return result;
}

uint64_t *RB::DisplayList::CachedTransform::transform_style(RB::DisplayList::CachedTransform *this, unint64_t a2, uint64_t a3)
{
  float64x2_t v4 = (const RB::DisplayList::Style *)a2;
  uint64_t v27 = *MEMORY[0x263EF8340];
  if (!a2 && (!a3 || !*((void *)this + 135))) {
    return 0;
  }
  float64x2_t v6 = (uint64_t *)(a3 | a2 | *((unsigned __int8 *)this + 1456));
  v23[0] = 0;
  int64x2_t v7 = RB::UntypedTable::lookup((RB::DisplayList::CachedTransform *)((char *)this + 1368), v6, v23);
  if (v6 != v23[0])
  {
    uint64_t v24 = 0;
    size_t v25 = 0;
    for (i = 8; v4; float64x2_t v4 = (const RB::DisplayList::Style *)*((void *)v4 + 4))
    {
      uint64_t v8 = *((void *)this + 181);
      if (v8)
      {
        unsigned __int16 v9 = (*(uint64_t (**)(const RB::DisplayList::Style *, void))(*(void *)v4 + 64))(v4, *((void *)this + 181));
        if (v9 >= 0x100u && (*(unsigned char *)(v8 + 40) ? v9 != 0 : v9 == 0)) {
          continue;
        }
      }
      size_t v11 = v25;
      size_t v12 = v25 + 1;
      if (i < v25 + 1)
      {
        RB::vector<RBDevice *,8ul,unsigned long>::reserve_slow(v23, v12);
        size_t v11 = v25;
        size_t v12 = v25 + 1;
      }
      int v13 = (void **)v24;
      if (!v24) {
        int v13 = v23;
      }
      v13[v11] = v4;
      size_t v25 = v12;
    }
    if (a3) {
      long long v14 = (uint64_t *)*((void *)this + 135);
    }
    else {
      long long v14 = 0;
    }
    if (v25)
    {
      size_t v15 = v25 - 1;
      do
      {
        long long v16 = (void **)v24;
        if (!v24) {
          long long v16 = v23;
        }
        float64x2_t v17 = (const RB::AffineTransform **)v16[v15];
        uint64_t v18 = (*((uint64_t (**)(const RB::AffineTransform **, void))*v17 + 3))(v17, *(void *)this);
        int64x2_t v7 = (uint64_t *)v18;
        if (v18)
        {
          uint64_t v19 = *((void *)this + 181);
          if (v19) {
            (*(void (**)(uint64_t, uint64_t, void))(*(void *)v18 + 72))(v18, v19, *((unsigned __int8 *)this + 1456));
          }
          v7[2] = (uint64_t)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)this, v17[2]);
          v7[3] = (uint64_t)RB::DisplayList::CachedTransform::transform_clip(this, (unint64_t)v17[3], a3);
          v7[5] = (uint64_t)RB::DisplayList::CachedTransform::transform_metadata(this, v17[5], *((_DWORD *)v17 + 12));
          *((_DWORD *)v7 + 12) = v20;
          *((_DWORD *)v7 + 13) = *((_DWORD *)v17 + 13) & 1;
          (*(void (**)(uint64_t *, RB::DisplayList::CachedTransform *, uint64_t))(*v7 + 32))(v7, this, a3);
          v7[4] = (uint64_t)v14;
          uint64_t v21 = *(void *)(*(void *)this + 8);
          v7[1] = *(void *)(v21 + 312);
          *(void *)(v21 + 312) = v7;
          long long v14 = v7;
        }
        else
        {
          int64x2_t v7 = v14;
        }
        --v15;
      }
      while (v15 != -1);
    }
    else
    {
      int64x2_t v7 = v14;
    }
    RB::UntypedTable::insert((size_t **)this + 171, (size_t *)v6, (size_t *)v7);
    if (v24) {
      free(v24);
    }
  }
  return v7;
}

void sub_2141016F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  if (a17) {
    free(a17);
  }
  _Unwind_Resume(exception_object);
}

const RB::DisplayList::ClipNode *RB::DisplayList::CachedTransform::transform_clip(RB::DisplayList::CachedTransform *this, unint64_t a2, unsigned int a3)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  unint64_t v4 = a3 | a2;
  if (*((void *)this + 159) == v4) {
    return (const RB::DisplayList::ClipNode *)*((void *)this + 160);
  }
  int64x2_t v7 = (const RB::DisplayList::ClipNode *)a2;
  long long v22 = 0;
  uint64_t v23 = 0;
  unint64_t v24 = 16;
  if (a2)
  {
    uint64_t v8 = 0;
    do
    {
      uint64_t v9 = v8 + 1;
      if (v24 < v8 + 1)
      {
        _ZN2RB6vectorIDv4_DF16_Lm16EmE12reserve_slowEm(__dst, v8 + 1);
        uint64_t v8 = v23;
        uint64_t v9 = v23 + 1;
      }
      long long v10 = v22;
      if (!v22) {
        long long v10 = __dst;
      }
      *(void *)&v10[8 * v8] = v7;
      uint64_t v23 = v9;
      int64x2_t v7 = *(const RB::DisplayList::ClipNode **)v7;
      uint64_t v8 = v9;
    }
    while (v7);
  }
  else
  {
    uint64_t v9 = 0;
  }
  if (a3) {
    float64x2_t v5 = (const RB::DisplayList::ClipNode *)*((void *)this + 134);
  }
  else {
    float64x2_t v5 = 0;
  }
  int v20 = v5;
  if (v9)
  {
    do
    {
      --v9;
      size_t v11 = v22;
      if (!v22) {
        size_t v11 = __dst;
      }
      uint64_t v12 = *(void *)&v11[8 * v9];
      if (!*(unsigned char *)(*(void *)this + 272)
        || (RB::DisplayList::ClipNode::elide_append((uint64_t *)&v20, (float32x2_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFFELL)) & 1) == 0)
      {
        int v13 = RB::UntypedTable::lookup((RB::DisplayList::CachedTransform *)((char *)this + 1288), (uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFFELL), 0);
        if (v13) {
          goto LABEL_34;
        }
        long long v14 = (size_t *)(*(uint64_t (**)(unint64_t, RB::DisplayList::CachedTransform *, void, void))(*(void *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFFELL) + 24))(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFFELL, this, 0, 0);
        int v13 = (uint64_t *)v14;
        if (v14)
        {
          uint64_t v15 = *(void *)(*(void *)this + 8);
          size_t v16 = *(void *)(v15 + 312);
          float64x2_t v17 = v14;
          do
          {
            size_t v18 = v16;
            size_t v16 = v17[1];
            *(void *)(v16 + 8) = v18;
            float64x2_t v17 = (size_t *)*v17;
          }
          while (v17);
          *(void *)(v15 + 312) = v16;
        }
        RB::UntypedTable::insert((size_t **)this + 161, (size_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFFELL), v14);
        if (v13)
        {
LABEL_34:
          do
          {
            int v20 = (const RB::DisplayList::ClipNode *)RB::Heap::emplace<RB::DisplayList::ClipNode,RB::DisplayList::Clip const*&,RB::DisplayList::ClipNode*&>((size_t *)(*(void *)(*(void *)this + 8) + 16), (const RB::DisplayList::Clip **)v13 + 1, &v20);
            int v13 = (uint64_t *)*v13;
          }
          while (v13);
        }
      }
    }
    while (v9);
    float64x2_t v5 = v20;
  }
  *((void *)this + 159) = v4;
  *((void *)this + 160) = v5;
  if (v22) {
    free(v22);
  }
  return v5;
}

void sub_214101950(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27)
{
  if (a27) {
    free(a27);
  }
  _Unwind_Resume(exception_object);
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Color>::copy(__n128 *a1, uint64_t a2)
{
  long long v3 = (RB::Heap *)(*(void *)(a2 + 8) + 16);
  int v6 = a1[2].n128_u16[7] & 0x3F;
  unint64_t v4 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill5ColorEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v3, v3, (RB::Coverage::Glyphs *)&a1[3].n128_i8[8], (uint64_t)&a1[7], (uint64_t *)&a1[3], &a1[2].n128_i16[6], &v6);
  __n128 result = a1[1];
  v4[1] = result;
  v4[2].n128_u64[0] = a1[2].n128_u64[0];
  v4[2].n128_u32[2] = a1[2].n128_u32[2];
  v4[2].n128_u16[7] |= a1[2].n128_u16[7] & 0x5800;
  return result;
}

void *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill5ColorEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, RB::Heap *a2, RB::Coverage::Glyphs *a3, uint64_t a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14 = *((void *)this + 3);
  uint64_t v15 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 128 > v14) {
    uint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0x80uLL, 7);
  }
  else {
    *((void *)this + 2) = v15 + 128;
  }
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  __n128 result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  *__n128 result = &unk_26C4E9340;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::GenericItem1(uint64_t a1, RB::Heap *a2, RB::Coverage::Glyphs *a3, uint64_t a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  __asm { FCVT            H0, S0 }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F;
  *(void *)a1 = &unk_26C4EAAE0;
  *(void *)(a1 + 48) = a5;
  RB::Coverage::Glyphs::Glyphs((RB::Coverage::Glyphs *)(a1 + 56), a3, a2);
  if (*(unsigned char *)(a4 + 9)) {
    __int16 v16 = *(_WORD *)(a4 + 8);
  }
  else {
    __int16 v16 = a7;
  }
  *(void *)(a1 + 112) = *(void *)a4;
  *(_WORD *)(a1 + 120) = v16;
  return a1;
}

__n128 RB::Coverage::Glyphs::Glyphs(RB::Coverage::Glyphs *this, const RB::Coverage::Glyphs *a2, RB::Heap *a3)
{
  unint64_t v4 = (__n128 *)RB::Coverage::Glyphs::Glyphs((uint64_t)this, a3, *(CFTypeRef *)a2, *((_DWORD *)a2 + 4), (const void *)(*((void *)a2 + 1) + 8 * *((unsigned int *)a2 + 4)), *((const void **)a2 + 1), *((_DWORD *)a2 + 5), *((unsigned char *)a2 + 52), *((double *)a2 + 3), *((float *)a2 + 12), *((unsigned char *)a2 + 53));
  __n128 result = *((__n128 *)a2 + 2);
  void v4[2] = result;
  return result;
}

uint64_t RB::Coverage::Glyphs::Glyphs(uint64_t a1, RB::Heap *this, CFTypeRef cf, unsigned int a4, const void *a5, const void *a6, int a7, char a8, double a9, float a10, char a11)
{
  *(void *)a1 = cf;
  unint64_t v20 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  unint64_t v21 = v20 + 10 * a4;
  if (v21 > *((void *)this + 3))
  {
    unint64_t v20 = RB::Heap::alloc_slow((size_t *)this, 10 * a4, 7);
    CFTypeRef v22 = *(CFTypeRef *)a1;
  }
  else
  {
    CFTypeRef v22 = cf;
    *((void *)this + 2) = v21;
  }
  *(void *)(a1 + 8) = v20;
  *(_DWORD *)(a1 + 16) = a4;
  *(_DWORD *)(a1 + 20) = a7;
  *(double *)(a1 + 24) = a9;
  *(void *)(a1 + 32) = 0x100000001000000;
  *(int32x2_t *)(a1 + 40) = vdup_n_s32(0x7F7FFFFFu);
  *(float *)(a1 + 48) = a10;
  *(unsigned char *)(a1 + 52) = a8;
  *(unsigned char *)(a1 + 53) = a11;
  uint64_t v23 = (unsigned int *)*((void *)this + 4);
  if (!v23)
  {
    RB::Heap::make_object_table((size_t *)this);
    uint64_t v23 = (unsigned int *)*((void *)this + 4);
  }
  RB::ObjectTable::retain(v23, v22);
  if (a4)
  {
    memmove((void *)(*(void *)(a1 + 8) + 8 * *(unsigned int *)(a1 + 16)), a5, 2 * a4);
    memmove(*(void **)(a1 + 8), a6, 8 * a4);
  }
  return a1;
}

{
  return RB::Coverage::Glyphs::Glyphs(a1, this, cf, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t RB::Heap::alloc_slow(size_t *this, size_t a2, uint64_t a3)
{
  size_t v5 = *this;
  size_t v6 = this[2];
  if (a2 + a3 + 23 <= *this)
  {
    uint64_t result = (v6 + a3) & ~a3;
    size_t v10 = result + a2;
    if (result + a2 > this[3])
    {
      size_t v11 = malloc_type_malloc(v5, 0xC90CD2B6uLL);
      if (!v11) {
        RB::precondition_failure((RB *)"memory allocation failed: %lu", v12, *this);
      }
      int v13 = v11;
      size_t v14 = *this;
      unint64_t v15 = (unint64_t)v11 + *this;
      this[2] = (size_t)v11;
      this[3] = v15;
      size_t v16 = (size_t)v11;
      if (!(v14 >> 16))
      {
        if (2 * v14 >= 0x10000) {
          size_t v17 = 0x10000;
        }
        else {
          size_t v17 = 2 * v14;
        }
        *this = malloc_good_size(v17);
        size_t v16 = this[2];
        unint64_t v15 = this[3];
      }
      size_t v18 = (void *)((v16 + 7) & 0xFFFFFFFFFFFFFFF8);
      this[2] = (size_t)(v18 + 2);
      if ((unint64_t)(v18 + 2) > v15) {
        RB::precondition_failure((RB *)"invalid heap state, %u, %u, %p, %p", v12, a2, a3, v18 + 2, v15);
      }
      *size_t v18 = this[1];
      v18[1] = v13;
      this[1] = (size_t)v18;
      uint64_t result = ((unint64_t)v18 + a3 + 16) & ~a3;
      size_t v10 = result + a2;
    }
    this[2] = v10;
  }
  else
  {
    int64x2_t v7 = (void *)((v6 + 7) & 0xFFFFFFFFFFFFFFF8);
    if ((unint64_t)(v7 + 2) > this[3]) {
      int64x2_t v7 = (void *)RB::Heap::alloc_slow((RB::Heap *)this, 0x10uLL, 7uLL);
    }
    else {
      this[2] = (size_t)(v7 + 2);
    }
    uint64_t result = (uint64_t)malloc_type_malloc(a2, 0xD6F0D335uLL);
    if (result)
    {
      *int64x2_t v7 = this[1];
      v7[1] = result;
      this[1] = (size_t)v7;
    }
  }
  return result;
}

unsigned int *RB::ObjectTable::retain(unsigned int *this, CFTypeRef cf)
{
  if (cf)
  {
    uint64_t v2 = (uint64_t)this;
    uint64_t v3 = this[2];
    int v4 = v3 - 16;
    if (v3 < 0x10) {
      int v4 = 0;
    }
    unsigned int v5 = -v4;
    if (v3 <= v5)
    {
LABEL_8:
      this = (unsigned int *)CFRetain(cf);
      uint64_t v9 = this;
      unsigned int v10 = *(_DWORD *)(v2 + 8);
      unsigned int v11 = v10 + 1;
      if (*(_DWORD *)(v2 + 12) < v10 + 1)
      {
        this = (unsigned int *)RB::vector<std::unique_ptr<RB::Symbol::Glyph::Layer,RB::Destroy<RB::Symbol::Glyph::Layer>>,0ul,unsigned int>::reserve_slow(v2, v11);
        unsigned int v10 = *(_DWORD *)(v2 + 8);
        unsigned int v11 = v10 + 1;
      }
      *(void *)(*(void *)v2 + 8 * v10) = v9;
      *(_DWORD *)(v2 + 8) = v11;
    }
    else
    {
      uint64_t v6 = v3 - v5;
      int64x2_t v7 = (const void **)(*(void *)this + 8 * v5);
      while (1)
      {
        CFTypeRef v8 = *v7++;
        if (v8 == cf) {
          break;
        }
        if (!--v6) {
          goto LABEL_8;
        }
      }
    }
  }
  return this;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  uint64_t result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

void *RB::Heap::make_object_table(size_t *this)
{
  uint64_t result = RB::Heap::emplace<RBImage>(this);
  this[4] = (size_t)result;
  return result;
}

void *RB::vector<std::unique_ptr<RB::Symbol::Glyph::Layer,RB::Destroy<RB::Symbol::Glyph::Layer>>,0ul,unsigned int>::reserve_slow(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1);
  }
  uint64_t result = RB::details::realloc_vector<unsigned int,8ul>(*(void **)a1, (_DWORD *)(a1 + 12), v3);
  *(void *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,8ul>(void *a1, _DWORD *a2, unsigned int a3)
{
  int v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(8 * a3);
    size_t v6 = v5 >> 3;
    if (*a2 != (v5 >> 3))
    {
      int64x2_t v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7) {
        RB::precondition_failure((RB *)"allocation failure", v8);
      }
      int v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

void *RB::Heap::emplace<RBImage>(size_t *a1)
{
  uint64_t v1 = (void *)((a1[2] + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(v1 + 2) > a1[3]) {
    uint64_t v1 = (void *)RB::Heap::alloc_slow(a1, 0x10uLL, 7);
  }
  else {
    a1[2] = (size_t)(v1 + 2);
  }
  *uint64_t v1 = 0;
  v1[1] = 0;
  return v1;
}

uint64_t ___ZNK2RB6Symbol12Presentation4drawEP15_RBDrawingStateU13block_pointerF7RBColor13RBSymbolStyleP8NSStringE_block_invoke(void *a1, void *a2, double a3, double a4, double a5, double a6)
{
  CFTypeRef v8 = (float32x2_t *)a1[7];
  float32x2_t v9 = *v8;
  if ((*(_DWORD *)(*(void *)v8 + 84) & 0xF00) == 0xC00 && *(void *)(*(void *)&v9 + 16))
  {
    uint64_t v10 = a1[6];
    v11.f64[0] = 0.0;
    v11.f64[1] = COERCE_FLOAT(HIDWORD(*(void *)&v8[7]));
    v34[0] = (float64x2_t)COERCE_UNSIGNED_INT64(COERCE_FLOAT(*(void *)&v8[7]));
    v34[1] = v11;
    uint64_t v35 = 0;
    uint64_t v36 = 0;
    v12.f64[0] = RB::Symbol::Presentation::Layer::transform(v8, v10);
    v33[0] = v12;
    v33[1] = v13;
    _OWORD v33[2] = v14;
    *(double *)&long long v15 = RB::operator*(v34, v33);
    uint64_t v16 = *(void *)(*(void *)a1[7] + 16);
    v32[0] = v15;
    v32[1] = v17;
    v32[2] = v18;
    LODWORD(v15) = 1065353216;
    LODWORD(v17) = 1065353216;
    LODWORD(v18) = 1065353216;
    LODWORD(v19) = 1065353216;
    return objc_msgSend(a2, "setImage:transform:interpolation:tintColor:flags:", v16, v32, 10, 0, *(double *)&v15, *(double *)&v17, *(double *)&v18, v19);
  }
  else
  {
    LODWORD(a6) = v8[2].i32[1];
    if (*(float *)&a6 == -32768.0)
    {
      uint64_t v21 = a1[4];
      uint64_t v22 = *(void *)(a1[5] + 8) + 48;
      int v23 = (*(_DWORD *)(*(void *)v8 + 84) >> 8) & 0xF;
      if (RB::Symbol::ResolvedColor::begin_update(v22, v23, *(void *)(*(void *)&v9 + 8), *(CGColorRef *)(*(void *)&v9 + 16)))
      {
        if (v23 == 10)
        {
          float v24 = 1.0;
          float v25 = 1.0;
          float v26 = 1.0;
          float v27 = 1.0;
        }
        else
        {
          float v24 = (*(float (**)(uint64_t, void, void))(v21 + 16))(v21, (*(_DWORD *)(*(void *)v8 + 84) >> 8) & 0xF, *(void *)(*(void *)v8 + 8));
        }
        RB::Symbol::ResolvedColor::commit_update(v22, v24, v25, v26, v27);
      }
      float64x2_t v31 = *(float32x2_t **)(a1[5] + 8);
      uint64_t v28 = v31 + 6;
      uint64_t v29 = (_DWORD *)&v31[6] + 1;
      uint64_t v30 = v31 + 7;
      LODWORD(a6) = v31[7].i32[1];
    }
    else
    {
      uint64_t v28 = v8 + 1;
      uint64_t v29 = (_DWORD *)&v8[1] + 1;
      uint64_t v30 = v8 + 2;
    }
    LODWORD(a5) = v30->i32[0];
    LODWORD(a4) = *v29;
    LODWORD(a3) = v28->i32[0];
    return objc_msgSend(a2, "setColor:colorSpace:", 1, a3, a4, a5, a6);
  }
}

uint64_t RB::Symbol::ResolvedColor::begin_update(uint64_t a1, int a2, uint64_t a3, CGColorRef color2)
{
  if (*(_DWORD *)(a1 + 16) == a2)
  {
    if (a2 != 9
      || CGColorEqualToColor(*(CGColorRef *)(a1 + 32), color2)
      && ([*(id *)(a1 + 24) isEqualToString:a3] & 1) != 0)
    {
      return 0;
    }
    *(_DWORD *)(a1 + 16) = 9;
    goto LABEL_9;
  }
  *(_DWORD *)(a1 + 16) = a2;
  if (a2 == 9)
  {
LABEL_9:
    *(void *)(a1 + 24) = a3;
    *(void *)(a1 + 32) = color2;
    return 1;
  }
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  return 1;
}

void RB::DisplayList::LayerItem::~LayerItem(RB::DisplayList::LayerItem *this)
{
  uint64_t v2 = (RB::DisplayList::Layer *)*((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v2) {
    RB::DisplayList::Layer::~Layer(v2);
  }
}

{
  RB::DisplayList::Layer *v2;
  uint64_t vars8;

  uint64_t v2 = (RB::DisplayList::Layer *)*((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v2) {
    RB::DisplayList::Layer::~Layer(v2);
  }
  JUMPOUT(0x21669AC10);
}

__n128 RB::DisplayList::LayerItem::copy(RB::DisplayList::LayerItem *this, RB::DisplayList::Builder *a2, unsigned int a3)
{
  if ((a3 & 4) != 0 && (*((_WORD *)this + 23) & 0x3F) != 0x18) {
    a3 &= ~4u;
  }
  uint64_t v9 = RB::DisplayList::Layer::copy(*((RB::DisplayList::Layer **)this + 6), a2, a3);
  if (v9)
  {
    size_t v6 = (RB::Heap *)(*((void *)a2 + 1) + 16);
    int v8 = *((_WORD *)this + 23) & 0x3F;
    int64x2_t v7 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList9LayerItemEJRKDF16_RKNS_9BlendModeERPNS2_5LayerEEEEPT_DpOT0_(v6, (__int16 *)this + 22, &v8, &v9);
    __n128 result = *((__n128 *)this + 1);
    v7[1] = result;
    v7[2].n128_u64[0] = *((void *)this + 4);
    v7[2].n128_u32[2] = *((_DWORD *)this + 10);
  }
  return result;
}

uint64_t RB::DisplayList::Builder::crop_bounds(RB::DisplayList::Builder *this, RB::DisplayList::State *a2)
{
  if (!*((void *)this + 1)) {
    RB::DisplayList::Builder::reset_contents(this);
  }
  uint64_t v4 = *((void *)this + 4);
  if (*((_DWORD *)a2 + 37) != *(_DWORD *)(v4 + 32))
  {
    long long v15 = *(_OWORD *)(v4 + 16);
    v12[0] = (float64x2_t)xmmword_2142181C0;
    v12[1] = (float64x2_t)xmmword_2142181D0;
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    size_t v5 = (RB::DisplayList::Style *)*((void *)a2 + 13);
    if (v5) {
      RB::DisplayList::Style::roi(v5, (float32x2_t *)&v15, v12);
    }
    uint64_t v6 = *((void *)a2 + 12);
    if (v6)
    {
      RB::Rect::move_identity((float32x2_t *)&v15, v12);
      RB::Rect::intersect((float32x2_t *)&v15, *(double *)(v6 + 16), *(float32x2_t *)(v6 + 24), v7, v8, v9, v10);
    }
    RB::Rect::move((float32x2_t *)&v15, v12, (float64x2_t *)a2 + 1);
    *((_OWORD *)a2 + 8) = v15;
    *((_DWORD *)a2 + 37) = *(_DWORD *)(*((void *)this + 4) + 32);
  }
  return (uint64_t)a2 + 128;
}

uint64_t RB::DisplayList::Layer::copy(RB::DisplayList::Layer *this, RB::DisplayList::Builder *a2, unsigned int a3)
{
  uint64_t layer = RB::DisplayList::Builder::make_layer(a2, *((_DWORD *)this + 15));
  *(_DWORD *)(layer + 48) = *((_DWORD *)this + 12);
  *(unsigned char *)(layer + 67) = *((unsigned char *)this + 67);
  if ((a3 & 1) == 0)
  {
    double v7 = *(void **)this;
    if (*(void *)this)
    {
      uint64_t v8 = a3 & 0xFFFFFFFE;
      int v9 = (a3 >> 2) & 1;
      do
      {
        int32x4_t v10 = (RB::DisplayList::Item *)(*(uint64_t (**)(void *, RB::DisplayList::Builder *, uint64_t))(*v7 + 24))(v7, a2, v8);
        if (v10) {
          RB::DisplayList::Builder::draw(a2, v10, (RB::DisplayList::Layer *)layer, v9);
        }
        double v7 = (void *)v7[1];
      }
      while (v7);
    }
  }
  for (unint64_t i = (void *)*((void *)this + 2); i; unint64_t i = (void *)i[1])
  {
    uint64_t v12 = (*(uint64_t (**)(void *, RB::DisplayList::Builder *))(*i + 16))(i, a2);
    if (v12) {
      RB::DisplayList::Layer::append_filter(layer, v12);
    }
  }
  *(unsigned char *)(layer + 64) = *((unsigned char *)this + 64);
  uint64_t v13 = *((void *)this + 3);
  *(void *)(layer + 24) = v13;
  int v14 = *((unsigned __int8 *)this + 64);
  if (v14 == 1)
  {
    uint64_t v16 = (size_t *)*((void *)a2 + 1);
    long long v17 = (long long *)*((void *)this + 3);
    uint64_t v15 = (v16[4] + 3) & 0xFFFFFFFFFFFFFFFCLL;
    if (v15 + 36 > v16[5]) {
      uint64_t v15 = RB::Heap::alloc_slow(v16 + 2, 0x24uLL, 3);
    }
    else {
      v16[4] = v15 + 36;
    }
    long long v18 = *v17;
    long long v19 = v17[1];
    *(_DWORD *)(v15 + 32) = *((_DWORD *)v17 + 8);
    *(_OWORD *)uint64_t v15 = v18;
    *(_OWORD *)(v15 + 16) = v19;
    goto LABEL_17;
  }
  if (v14 == 2)
  {
    uint64_t v15 = (*(uint64_t (**)(uint64_t, RB::DisplayList::Builder *))(*(void *)v13 + 16))(v13, a2);
LABEL_17:
    *(void *)(layer + 24) = v15;
  }
  return layer;
}

uint64_t _ZN2RB4Heap7emplaceINS_11DisplayList9LayerItemEJRKDF16_RKNS_9BlendModeERPNS2_5LayerEEEEPT_DpOT0_(RB::Heap *this, __int16 *a2, int *a3, uint64_t *a4)
{
  unint64_t v8 = *((void *)this + 3);
  uint64_t result = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (result + 56 > v8) {
    uint64_t result = RB::Heap::alloc_slow((size_t *)this, 0x38uLL, 7);
  }
  else {
    *((void *)this + 2) = result + 56;
  }
  __int16 v10 = *a2;
  int v11 = *a3;
  __int16 v12 = 512;
  uint64_t v13 = *a4;
  if (*a4)
  {
    if ((*(_WORD *)(v13 + 60) & 0x2001) != 0) {
      __int16 v12 = 1536;
    }
    else {
      __int16 v12 = 512;
    }
  }
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(void *)(result + 32) = 0;
  *(_WORD *)(result + 44) = v10;
  *(_WORD *)(result + 46) = v12 | v11 & 0x3F;
  *(void *)uint64_t result = &unk_26C4ECEF8;
  *(void *)(result + 48) = v13;
  return result;
}

void RB::DisplayList::LayerItem::apply_transform(RB::DisplayList::Layer **this, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)this, a2, a3);
  size_t v5 = this[6];
  RB::DisplayList::Layer::apply_transform(v5, a2);
}

void RB::DisplayList::Layer::apply_transform_(RB::DisplayList::Layer *this, const RB::DisplayList::CachedTransform *a2)
{
  v13[185] = *MEMORY[0x263EF8340];
  int v4 = *((_DWORD *)a2 + 286);
  int v5 = *((_DWORD *)this + 15);
  BOOL v6 = (v5 & 0x2001) == 0 || (*((_DWORD *)a2 + 286) & 1) == 0;
  double v7 = a2;
  if (!v6)
  {
    ++*((unsigned char *)this + 67);
    double v7 = a2;
    if (v5)
    {
      unsigned int v8 = v4 & 0xFFFFFFFE;
      double v7 = a2;
      if ((v4 & 0xFFFFFFFE) != v4)
      {
        MEMORY[0x270FA5388]();
        double v7 = (const RB::DisplayList::CachedTransform *)v13;
        bzero(v13, 0x5C0uLL);
        RB::DisplayList::CachedTransform::CachedTransform((RB::DisplayList::CachedTransform *)v13, (float64x2_t *)a2, 1.0, 1.0, v8);
      }
    }
  }
  int v9 = *(void **)this;
  if (*(void *)this)
  {
    do
    {
      (*(void (**)(void *, const RB::DisplayList::CachedTransform *, void))(*v9 + 32))(v9, v7, 0);
      int v9 = (void *)v9[1];
    }
    while (v9);
  }
  for (unint64_t i = (void *)*((void *)this + 2); i; unint64_t i = (void *)i[1])
    (*(void (**)(void *, const RB::DisplayList::CachedTransform *))(*i + 24))(i, v7);
  if (v7 != a2)
  {
    RB::UntypedTable::~UntypedTable((const RB::DisplayList::CachedTransform *)((char *)v7 + 1368));
    RB::UntypedTable::~UntypedTable((const RB::DisplayList::CachedTransform *)((char *)v7 + 1288));
    RB::Heap::~Heap((const RB::DisplayList::CachedTransform *)((char *)v7 + 8));
  }
  int v11 = *((unsigned __int8 *)this + 64);
  if (v11 == 2)
  {
    uint64_t v12 = (*(uint64_t (**)(void, const RB::DisplayList::CachedTransform *))(**((void **)this + 3) + 24))(*((void *)this + 3), a2);
    goto LABEL_18;
  }
  if (v11 == 1)
  {
    uint64_t v12 = RB::DisplayList::CachedTransform::transform_projection(a2, *((const RB::ProjectionMatrix **)this + 3));
LABEL_18:
    *((void *)this + 3) = v12;
  }
  *((unsigned char *)this + 66) = 0;
  *((_DWORD *)this + 13) = -1082130432;
}

void RB::DisplayList::Layer::apply_transform(RB::DisplayList::Layer *this, const RB::DisplayList::CachedTransform *a2)
{
  v18[14] = *MEMORY[0x263EF8340];
  float v4 = *((float *)this + 12);
  if (v4 == 0.0) {
    float v5 = 1.0;
  }
  else {
    float v5 = *((float *)this + 12);
  }
  int v6 = *((_DWORD *)this + 15);
  if (v5 == 1.0)
  {
    if ((v6 & 0x200) == 0)
    {
      RB::DisplayList::Layer::apply_transform_(this, a2);
      return;
    }
    goto LABEL_10;
  }
  if ((v6 & 0x200) != 0)
  {
LABEL_10:
    RB::DisplayList::CachedTransform::transform_scale(a2);
    float v8 = v7;
    for (unint64_t i = (void *)*((void *)this + 2); i; unint64_t i = (void *)i[1])
    {
      if ((*(unsigned int (**)(void *))(*i + 40))(i) == 5) {
        float v8 = RB::Filter::GaussianBlur::layer_scale((RB::Filter::GaussianBlur *)(i + 4), v8);
      }
    }
    RB::DisplayList::Layer::min_scale(this);
    unsigned int v11 = 0;
    do
    {
      float v12 = v8;
      float v8 = v8 + v8;
    }
    while (v8 <= v10 && v11++ < 3);
    float v4 = fminf(v12 * v5, 1.0);
    if ((float)(v12 * v5) <= 1.0) {
      float v5 = v12;
    }
    else {
      float v5 = 1.0 / v5;
    }
    *((float *)this + 12) = v4;
  }
  float v14 = 1.0;
  if (v4 != 0.0) {
    float v14 = v4;
  }
  RB::DisplayList::CachedTransform::CachedTransform((RB::DisplayList::CachedTransform *)&v15, (float64x2_t *)a2, v5, v14, *((_DWORD *)a2 + 286));
  RB::DisplayList::Layer::apply_transform_(this, (const RB::DisplayList::CachedTransform *)&v15);
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v18);
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v17);
  RB::Heap::~Heap((RB::Heap *)&v16);
}

void sub_214102AA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void RB::Rect::move(float32x2_t *this, float64x2_t *a2, float64x2_t *a3)
{
  float64x2_t v4 = *a3;
  float64x2_t v3 = a3[1];
  float64x2_t v5 = a3[2];
  int64x2_t v6 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v3, a2[1]), (int8x16_t)vceqq_f64(*a3, *a2)), (int8x16_t)vceqq_f64(v5, a2[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v6, 1), (int8x16_t)v6).u64[0] & 0x8000000000000000) == 0)
  {
    float32x2_t v10 = *this;
    uint64_t v11 = (uint64_t)this[1];
    float64x2_t v12 = vmulq_f64((float64x2_t)vextq_s8((int8x16_t)v3, (int8x16_t)v3, 8uLL), v4);
    double v13 = vsubq_f64(v12, (float64x2_t)vdupq_laneq_s64((int64x2_t)v12, 1)).f64[0];
    if (v13 != 0.0)
    {
      double v14 = 1.0 / v13;
      int8x16_t v15 = (int8x16_t)vmulq_n_f64(v4, v14);
      v16.f64[0] = vmuld_lane_f64(v14, v3, 1);
      double v17 = vmuld_lane_f64(v14 * v3.f64[0], v5, 1);
      double v18 = -(v14 * v3.f64[0]);
      float64x2_t v19 = (float64x2_t)vextq_s8(v15, v15, 8uLL);
      float64x2_t v20 = vmulq_f64(v19, v5);
      float64x2_t v21 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v20.f64[0], 0);
      v21.f64[0] = v17;
      v20.f64[0] = v16.f64[0] * v5.f64[0];
      float64x2_t v5 = vsubq_f64(v21, v20);
      v16.f64[1] = -*(double *)&v15.i64[1];
      v19.f64[0] = v18;
      float64x2_t v3 = v19;
      float64x2_t v4 = v16;
    }
    v28[0] = v4;
    v28[1] = v3;
    _OWORD v28[2] = v5;
    v22.f64[0] = RB::operator*(a2, v28);
    v29[0] = v22;
    v29[1] = (float64x2_t)v23;
    v29[2] = v24;
    v23.i64[0] = v11;
    *this = RB::operator*(v29, v10, v23);
    this[1] = v25;
    float64x2_t v26 = *a3;
    float64x2_t v27 = a3[2];
    a2[1] = a3[1];
    a2[2] = v27;
    *a2 = v26;
  }
}

uint64_t RB::DisplayList::ClipNode::elide_append(uint64_t *a1, float32x2_t *a2)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    uint32x2_t v3 = (uint32x2_t)vclez_f32(*(float32x2_t *)((*(void *)(v2 + 8) & 0xFFFFFFFFFFFFFFFELL) + 24));
    if ((vpmax_u32(v3, v3).u32[0] & 0x80000000) != 0)
    {
      return 1;
    }
    else
    {
      uint32x2_t v4 = (uint32x2_t)vclez_f32(a2[3]);
      uint64_t v2 = 0;
      if ((vpmax_u32(v4, v4).u32[0] & 0x80000000) != 0) {
        *a1 = 0;
      }
    }
  }
  return v2;
}

uint64_t RB::Fill::Color::matches(RB::Fill::Color *this, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::DisplayList::Predicate::matches_color(a2, this, a3);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::Fill::Color::matches((RB::Fill::Color *)(a1 + 112), a2, a3);
}

void *RB::DisplayList::GenericClip<RB::Coverage::Path>::copy(uint64_t a1, RB::DisplayList::CachedTransform *this, uint64_t a3, int a4)
{
  float v7 = (size_t *)(*(void *)(*(void *)this + 8) + 16);
  if (a4) {
    int v8 = *(unsigned char *)(a1 + 44) == 0;
  }
  else {
    int v8 = *(char *)(a1 + 44);
  }
  int v19 = v8;
  int v9 = RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)this, *(const RB::AffineTransform **)(a1 + 48));
  double v18 = v9;
  if ((*(unsigned char *)(a1 + 45) & 4) != 0)
  {
    char v11 = *(unsigned char *)(a1 + 45) & 4;
  }
  else if (*(unsigned char *)(*(void *)this + 272))
  {
    v14[0] = &unk_26C4ECC40;
    v14[1] = v7;
    v14[2] = a1;
    int v15 = v8;
    float64x2_t v16 = v9;
    uint64_t v17 = 0;
    RB::Coverage::Path::simplify(a1 + 56, (uint64_t)v14);
    uint64_t v10 = v17;
    char v11 = 4;
    if (v17) {
      goto LABEL_11;
    }
  }
  else
  {
    char v11 = 0;
  }
  uint64_t v10 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Path>,RB::Heap&,RB::Coverage::Path const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>(v7, v7, a1 + 56, (int *)(a1 + 88), &v19, (uint64_t *)&v18);
LABEL_11:
  *(void *)(v10 + 32) = RB::DisplayList::CachedTransform::transform_metadata(this, *(const RB::DisplayList::Metadata **)(a1 + 32), *(_DWORD *)(a1 + 40));
  *(_DWORD *)(v10 + 40) = v12;
  *(unsigned char *)(v10 + 45) |= v11;
  uint64_t result = (void *)((*((void *)this + 3) + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(result + 2) > *((void *)this + 4)) {
    uint64_t result = (void *)RB::Heap::alloc_slow((size_t *)this + 1, 0x10uLL, 7);
  }
  else {
    *((void *)this + 3) = result + 2;
  }
  *uint64_t result = a3;
  result[1] = v10;
  return result;
}

void RB::Symbol::ResolvedColor::commit_update(uint64_t a1, float a2, float a3, float a4, float a5)
{
  if (a5 == -32768.0)
  {
    int64x2_t v6 = *(CGColor **)(a1 + 32);
    if (v6)
    {
      double v7 = RBColorFromCGColor(v6, 0);
      *(_DWORD *)a1 = LODWORD(v7);
      *(_DWORD *)(a1 + 4) = v8;
      *(_DWORD *)(a1 + 8) = v9;
      *(_DWORD *)(a1 + 12) = v10;
      int v12 = *(const void **)(a1 + 32);
      char v11 = *(const void **)(a1 + 40);
      if (v11 != v12)
      {
        if (v11) {
          CFRelease(v11);
        }
        if (v12) {
          CFTypeRef v13 = CFRetain(v12);
        }
        else {
          CFTypeRef v13 = 0;
        }
        *(void *)(a1 + 40) = v13;
      }
      return;
    }
    a3 = 0.0;
    a2 = 1.0;
    a4 = 1.0;
    a5 = 1.0;
  }
  *(float *)a1 = a2;
  *(float *)(a1 + 4) = a3;
  *(float *)(a1 + 8) = a4;
  *(float *)(a1 + 12) = a5;
  double v14 = *(const void **)(a1 + 40);
  if (v14) {
    CFRelease(v14);
  }
  *(void *)(a1 + 40) = 0;
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Path>::contains(uint64_t a1, float32x2_t d0_0, float32x2_t a3)
{
  if (*(unsigned char *)(a1 + 44) != 1) {
    return 0;
  }
  if (*(float *)(a1 + 88) == 0.0) {
    return 1;
  }
  v13.callbacks = *(RBPathCallbacks **)(a1 + 48);
  v13.info = (void *)(a1 + 56);
  v11[0] = COERCE_FLOAT32X2_T(RB::Coverage::Path::bounds(v13));
  v11[1] = v6;
  return RB::Rect::intersects(v11, v12, d0_0, a3, v7, v8, v9, v10) ^ 1;
}

void RB::DisplayList::ItemFactory::operator()<RB::Coverage::Primitive>(uint64_t a1, float32x2_t *this, double a3, double a4, int8x16_t a5, int32x4_t a6)
{
  double v8 = *(float32x2_t **)(a1 + 40);
  if (!v8
    || (v15[0] = (float64x2_t)xmmword_2142181C0,
        v15[1] = (float64x2_t)xmmword_2142181D0,
        uint64_t v16 = 0,
        uint64_t v17 = 0,
        float32x2_t v9 = RB::Coverage::Primitive::bounds(this, v15, (int8x16_t)xmmword_2142181C0, (int32x4_t)xmmword_2142181D0, a5, a6), (RB::Rect::intersects(v8, v18, v9, v10, v11, v12, v13, v14) & 1) != 0))
  {
    *(void *)&v15[0].f64[0] = a1;
    *(void *)&v15[0].f64[1] = this;
    RBFillData::apply<RB::DisplayList::ItemFactory::Inner<RB::Coverage::Primitive>>(*(void *)(a1 + 32), (long long **)v15);
  }
}

void RBFillData::apply<RB::DisplayList::ItemFactory::Inner<RB::Coverage::Primitive>>(uint64_t a1, long long **a2)
{
  switch(*(_DWORD *)a1)
  {
    case 1:
      RB::DisplayList::ItemFactory::Inner<RB::Coverage::Primitive>::operator()<RB::Fill::Color>(a2, a1 + 16);
      break;
    case 2:
      RB::DisplayList::ItemFactory::Inner<RB::Coverage::Primitive>::operator()<RB::Fill::Gradient>(a2, (uint64_t *)(a1 + 16));
      break;
    case 3:
      RB::DisplayList::ItemFactory::Inner<RB::Coverage::Primitive>::operator()<RB::Fill::MeshGradient>(a2, a1 + 16);
      break;
    case 4:
      RB::DisplayList::ItemFactory::Inner<RB::Coverage::Primitive>::operator()<RB::Fill::Image<RB::ImageTexture>>(a2, (RB::ImageTexture *)(a1 + 16));
      break;
    case 5:
      RB::DisplayList::ItemFactory::Inner<RB::Coverage::Primitive>::operator()<RB::Fill::Custom>(a2, a1 + 16);
      break;
    default:
      return;
  }
}

void RB::DisplayList::ItemFactory::Inner<RB::Coverage::Primitive>::operator()<RB::Fill::Color>(long long **a1, uint64_t a2)
{
  uint32x2_t v3 = *a1;
  uint64_t v4 = *((void *)*a1 + 7);
  if (!v4)
  {
    RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Color>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v3, *(void *)v3, a1[1], a2, (uint64_t *)v3 + 1, (int *)v3 + 4, (_WORD *)v3 + 10, (__int16 *)v3 + 12);
    uint32x2_t v3 = *a1;
    *((void *)*a1 + 7) = v4;
  }
  if (*((unsigned char *)v3 + 48)) {
    *(_WORD *)(v4 + 46) |= 0x1000u;
  }
}

double RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Color>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, uint64_t a2, long long *a3, uint64_t a4, uint64_t *a5, int *a6, _WORD *a7, __int16 *a8)
{
  unint64_t v15 = *((void *)this + 3);
  unint64_t v16 = (*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v16 + 128 > v15) {
    unint64_t v16 = RB::Heap::alloc_slow((size_t *)this, 0x80uLL, 15);
  }
  else {
    *((void *)this + 2) = v16 + 128;
  }
  uint64_t v17 = *a5;
  _S0 = *a6;
  char v19 = *a7;
  __int16 v20 = *a8;
  __asm { FCVT            H0, S0 }
  *(void *)(v16 + 16) = 0;
  *(void *)(v16 + 24) = 0;
  *(_DWORD *)(v16 + 40) = 0;
  *(void *)(v16 + 32) = 0;
  *(_WORD *)(v16 + 44) = _S0;
  *(_WORD *)(v16 + 46) = v19 & 0x3F;
  *(void *)unint64_t v16 = &unk_26C4EB800;
  *(void *)(v16 + 48) = v17;
  long long v25 = *a3;
  long long v26 = a3[1];
  *(_OWORD *)(v16 + 95) = *(long long *)((char *)a3 + 31);
  *(_OWORD *)(v16 + 64) = v25;
  *(_OWORD *)(v16 + 80) = v26;
  if (*(unsigned char *)(a4 + 9)) {
    __int16 v27 = *(_WORD *)(a4 + 8);
  }
  else {
    __int16 v27 = v20;
  }
  double result = *(double *)a4;
  *(void *)(v16 + 112) = *(void *)a4;
  *(_WORD *)(v16 + 120) = v27;
  *(void *)unint64_t v16 = &unk_26C4EA060;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::has_no_effect(uint64_t a1)
{
  __asm { FCMP            H0, #0 }
  if (_ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  __asm { FCMP            H0, #0 }
  if (_NF ^ _VF | _ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  else {
    return 0;
  }
}

uint64_t RB::DisplayList::ItemFactory::operator()<RB::Coverage::Glyphs>(uint64_t a1, RB::Coverage::Glyphs *this)
{
  uint64_t v4 = *(float32x2_t **)(a1 + 40);
  if (!v4
    || (v12[0] = (float64x2_t)xmmword_2142181C0,
        v12[1] = (float64x2_t)xmmword_2142181D0,
        uint64_t v13 = 0,
        uint64_t v14 = 0,
        double v5 = RB::Coverage::Glyphs::bounds(this, v12, 0),
        uint64_t result = RB::Rect::intersects(v4, v15, *(float32x2_t *)&v5, v6, v7, v8, v9, v10),
        (result & 1) != 0))
  {
    *(void *)&v12[0].f64[0] = a1;
    *(void *)&v12[0].f64[1] = this;
    return (uint64_t)RBFillData::apply<RB::DisplayList::ItemFactory::Inner<RB::Coverage::Glyphs>>(*(void **)(a1 + 32), (RB::Coverage::Glyphs **)v12);
  }
  return result;
}

void *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Glyphs>::operator()<RB::Fill::Color>(RB::Coverage::Glyphs **a1, uint64_t a2)
{
  uint32x2_t v3 = *a1;
  uint64_t result = (void *)*((void *)*a1 + 7);
  if (!result)
  {
    uint64_t result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Color>,RB::Heap&,RB::Coverage::Glyphs const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v3, *(RB::Heap **)v3, a1[1], a2, (uint64_t *)v3 + 1, (float *)v3 + 4, (_DWORD *)v3 + 5, (__int16 *)v3 + 12);
    uint32x2_t v3 = *a1;
    *((void *)*a1 + 7) = result;
  }
  if (*((unsigned char *)v3 + 48)) {
    *((_WORD *)result + 23) |= 0x1000u;
  }
  return result;
}

void *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Color>,RB::Heap&,RB::Coverage::Glyphs const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, RB::Heap *a2, RB::Coverage::Glyphs *a3, uint64_t a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16 = *((void *)this + 3);
  uint64_t v17 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 128 > v16) {
    uint64_t v17 = RB::Heap::alloc_slow((size_t *)this, 0x80uLL, 7);
  }
  else {
    *((void *)this + 2) = v17 + 128;
  }
  uint64_t result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  *uint64_t result = &unk_26C4E9340;
  return result;
}

void *RBFillData::apply<RB::DisplayList::ItemFactory::Inner<RB::Coverage::Glyphs>>(void *result, RB::Coverage::Glyphs **a2)
{
  switch(*(_DWORD *)result)
  {
    case 1:
      uint64_t result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Glyphs>::operator()<RB::Fill::Color>(a2, (uint64_t)(result + 2));
      break;
    case 2:
      uint64_t result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Glyphs>::operator()<RB::Fill::Gradient>(a2, result + 2);
      break;
    case 3:
      uint64_t result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Glyphs>::operator()<RB::Fill::MeshGradient>(a2, (uint64_t)(result + 2));
      break;
    case 4:
      uint64_t result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Glyphs>::operator()<RB::Fill::Image<RB::ImageTexture>>(a2, (const RB::ImageTexture *)(result + 2));
      break;
    case 5:
      uint64_t result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Glyphs>::operator()<RB::Fill::Custom>(a2, (uint64_t)(result + 2));
      break;
    default:
      return result;
  }
  return result;
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Path>,RB::Heap&,RB::Coverage::Path const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>(size_t *a1, size_t *a2, uint64_t a3, int *a4, int *a5, uint64_t *a6)
{
  uint64_t v11 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v11 + 96 > a1[3]) {
    uint64_t v11 = RB::Heap::alloc_slow(a1, 0x60uLL, 7);
  }
  else {
    a1[2] = v11 + 96;
  }
  int v12 = *a4;
  int v13 = *a5;
  uint64_t v14 = *a6;
  *(void *)(v11 + 16) = 0;
  *(void *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(void *)(v11 + 32) = 0;
  *(_WORD *)(v11 + 44) = v13;
  *(void *)uint64_t v11 = &unk_26C4E8BE8;
  *(void *)(v11 + 48) = v14;
  *(void *)(v11 + 56) = RBPathRetain(*(void *)a3, *(void *)(a3 + 8));
  *(void *)(v11 + 64) = v15;
  unint64_t v16 = *(long long **)(a3 + 16);
  if (v16)
  {
    uint64_t v17 = (_OWORD *)((a2[2] + 15) & 0xFFFFFFFFFFFFFFF0);
    if ((unint64_t)(v17 + 3) > a2[3]) {
      uint64_t v17 = (_OWORD *)RB::Heap::alloc_slow(a2, 0x30uLL, 15);
    }
    else {
      a2[2] = (size_t)(v17 + 3);
    }
    long long v18 = *v16;
    long long v19 = v16[2];
    v17[1] = v16[1];
    v17[2] = v19;
    *uint64_t v17 = v18;
  }
  else
  {
    uint64_t v17 = 0;
  }
  *(void *)(v11 + 72) = v17;
  *(_DWORD *)(v11 + 80) = *(_DWORD *)(a3 + 24);
  *(_WORD *)(v11 + 84) = *(_WORD *)(a3 + 28);
  *(_DWORD *)(v11 + 88) = v12;
  RB::DisplayList::GenericClip<RB::Coverage::Path>::update_bounds(v11);
  return v11;
}

void sub_2141034E0(_Unwind_Exception *a1)
{
  RBPathRelease(*(void *)(v1 + 56), *(void *)(v1 + 64));
  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::Builder::lower_color_filters(RB::DisplayList::Builder *this, RB::DisplayList::Layer *a2, int a3)
{
  uint64_t result = *((void *)a2 + 2);
  if (result)
  {
    if (!*(void *)(result + 8) && (*((_WORD *)a2 + 30) & 0x2001) == 0)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
      if (result == 1)
      {
        double v8 = v7;
        uint64_t v9 = (uint64_t)(v7 + 2);
        if (*v7) {
          LOWORD(v10) = 256;
        }
        else {
          int v10 = ((*v7 & 2) << 7) | (*v7 >> 1) & 1;
        }
        uint64_t result = RB::DisplayList::Builder::can_lower_color_matrix((uint64_t *)a2, (uint64_t)(v7 + 2), (*v7 >> 2) & 1, v10, a3);
        if (result)
        {
          if (*v8) {
            LOWORD(v11) = 256;
          }
          else {
            int v11 = ((*v8 & 2) << 7) | (*v8 >> 1) & 1;
          }
          RB::DisplayList::Builder::lower_color_matrix((uint64_t)this, (void **)a2, v9, (*v8 >> 2) & 1, v11, a3);
          uint64_t result = (***((uint64_t (****)(void))a2 + 2))();
          *((void *)a2 + 2) = 0;
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::Item::has_no_effect(RB::DisplayList::Item *this)
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::has_no_effect(uint64_t a1)
{
  __asm { FCMP            H0, #0 }
  if (_ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  __asm { FCMP            H0, #0 }
  if (_NF ^ _VF | _ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  else {
    return 0;
  }
}

void RB::XML::DisplayList::draw_shape(RB::XML::Document *a1)
{
}

uint64_t RBFillIsClear(RBFill *a1)
{
  switch(a1->_data.type)
  {
    case 1:
      __asm { FCMP            H0, #0 }
      if (_ZF) {
        uint64_t result = 1;
      }
      else {
        uint64_t result = 0;
      }
      break;
    case 2:
    case 3:
    case 4:
    case 5:
      uint64_t result = 0;
      break;
    default:
      uint64_t result = 1;
      break;
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 168);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 101);
}

unint64_t RB::DisplayList::ItemFactory::Inner<RB::Coverage::Primitive>::operator()<RB::Fill::Gradient>(long long **a1, uint64_t *a2)
{
  uint32x2_t v3 = *a1;
  unint64_t result = *((void *)*a1 + 7);
  if (!result)
  {
    unint64_t result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(size_t **)v3, *(RB::Heap **)v3, a1[1], a2, (uint64_t *)v3 + 1, (int *)v3 + 4, (_WORD *)v3 + 10, (__int16 *)v3 + 12);
    uint32x2_t v3 = *a1;
    *((void *)*a1 + 7) = result;
  }
  if (*((unsigned char *)v3 + 48)) {
    *(_WORD *)(result + 46) |= 0x1000u;
  }
  return result;
}

void *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Path>::operator()<RB::Fill::Image<RB::ImageTexture>>(uint64_t *a1, const RB::ImageTexture *a2)
{
  uint64_t v4 = *a1;
  if (*(unsigned char *)(*a1 + 48))
  {
    v6[0] = &unk_26C4EA4E0;
    v6[1] = a1;
    v6[2] = a2;
    RB::Coverage::Path::simplify(a1[1], (uint64_t)v6);
    uint64_t v4 = *a1;
  }
  unint64_t result = *(void **)(v4 + 56);
  if (!result)
  {
    unint64_t result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Path const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v4, *(size_t **)v4, a1[1], a2, (uint64_t *)(v4 + 8), (float *)(v4 + 16), (_DWORD *)(v4 + 20), (__int16 *)(v4 + 24));
    uint64_t v4 = *a1;
    *(void *)(*a1 + 56) = result;
  }
  if (*(unsigned char *)(v4 + 48)) {
    *((_WORD *)result + 23) |= 0x1000u;
  }
  return result;
}

uint64_t RB::pdf_blend(unsigned int a1)
{
  return (a1 < 0x28) & (0xF3FF005004uLL >> a1);
}

unint64_t RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(size_t *a1, RB::Heap *a2, long long *a3, uint64_t *a4, uint64_t *a5, int *a6, _WORD *a7, __int16 *a8)
{
  unint64_t v15 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v15 + 176 > a1[3]) {
    unint64_t v15 = RB::Heap::alloc_slow(a1, 0xB0uLL, 15);
  }
  else {
    a1[2] = v15 + 176;
  }
  uint64_t v16 = *a5;
  _S0 = *a6;
  char v18 = *a7;
  __int16 v19 = *a8;
  __asm { FCVT            H0, S0 }
  *(void *)(v15 + 16) = 0;
  *(void *)(v15 + 24) = 0;
  *(_DWORD *)(v15 + 40) = 0;
  *(void *)(v15 + 32) = 0;
  *(_WORD *)(v15 + 44) = _S0;
  *(_WORD *)(v15 + 46) = v18 & 0x3F;
  *(void *)unint64_t v15 = &unk_26C4EBB48;
  *(void *)(v15 + 48) = v16;
  long long v24 = *a3;
  long long v25 = a3[1];
  *(_OWORD *)(v15 + 95) = *(long long *)((char *)a3 + 31);
  *(_OWORD *)(v15 + 64) = v24;
  *(_OWORD *)(v15 + 80) = v25;
  RB::Fill::Gradient::Gradient((uint64_t *)(v15 + 112), a4, v19, a2);
  *(void *)unint64_t v15 = &unk_26C4EA3A8;
  return v15;
}

void *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Path const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, size_t *a2, uint64_t a3, const RB::ImageTexture *a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16 = *((void *)this + 3);
  uint64_t v17 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 184 > v16) {
    uint64_t v17 = RB::Heap::alloc_slow((size_t *)this, 0xB8uLL, 7);
  }
  else {
    *((void *)this + 2) = v17 + 184;
  }
  unint64_t result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  *unint64_t result = &unk_26C4E8FF8;
  return result;
}

uint64_t *RB::Fill::Gradient::Gradient(uint64_t *a1, uint64_t *a2, __int16 a3, RB::Heap *this)
{
  uint64_t v8 = *a2;
  *a1 = *a2;
  uint64_t v9 = (char *)((*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8);
  int v10 = &v9[16 * v8];
  if ((unint64_t)v10 > *((void *)this + 3))
  {
    uint64_t v9 = (char *)RB::Heap::alloc_slow((size_t *)this, 16 * v8, 7);
    uint64_t v8 = *a1;
  }
  else
  {
    *((void *)this + 2) = v10;
  }
  a1[1] = (uint64_t)v9;
  a1[2] = 0;
  a1[3] = a2[3];
  a1[4] = a2[4];
  a1[5] = a2[5];
  *((_DWORD *)a1 + 12) = *((_DWORD *)a2 + 12);
  *((unsigned char *)a1 + 52) = *((unsigned char *)a2 + 52);
  if (*((unsigned char *)a2 + 54)) {
    __int16 v11 = *(_WORD *)((char *)a2 + 53);
  }
  else {
    __int16 v11 = a3;
  }
  *(_WORD *)((char *)a1 + 53) = v11;
  *(_WORD *)((char *)a1 + 55) = *(_WORD *)((char *)a2 + 55);
  if (v8) {
    memmove(v9, (const void *)a2[1], 16 * v8);
  }
  int v12 = (long long *)a2[2];
  if (v12)
  {
    int v13 = (_OWORD *)((*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0);
    if ((unint64_t)(v13 + 3) > *((void *)this + 3)) {
      int v13 = (_OWORD *)RB::Heap::alloc_slow((size_t *)this, 0x30uLL, 15);
    }
    else {
      *((void *)this + 2) = v13 + 3;
    }
    long long v14 = *v12;
    long long v15 = v12[2];
    v13[1] = v12[1];
    _OWORD v13[2] = v15;
    *int v13 = v14;
    a1[2] = (uint64_t)v13;
  }
  return a1;
}

uint64_t *RB::Fill::Gradient::Gradient(uint64_t *a1, uint64_t *a2, __int16 a3, RB::Heap *a4)
{
  return RB::Fill::Gradient::Gradient(a1, a2, a3, a4);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::GenericItem1(uint64_t a1, size_t *a2, uint64_t a3, const RB::ImageTexture *a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  __asm { FCVT            H0, S0 }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F;
  *(void *)a1 = &unk_26C4EA798;
  *(void *)(a1 + 48) = a5;
  *(void *)(a1 + 56) = RBPathRetain(*(void *)a3, *(void *)(a3 + 8));
  *(void *)(a1 + 64) = v18;
  __int16 v19 = *(long long **)(a3 + 16);
  if (v19)
  {
    __int16 v20 = (_OWORD *)((a2[2] + 15) & 0xFFFFFFFFFFFFFFF0);
    if ((unint64_t)(v20 + 3) > a2[3]) {
      __int16 v20 = (_OWORD *)RB::Heap::alloc_slow(a2, 0x30uLL, 15);
    }
    else {
      a2[2] = (size_t)(v20 + 3);
    }
    long long v21 = *v19;
    long long v22 = v19[2];
    v20[1] = v19[1];
    v20[2] = v22;
    *__int16 v20 = v21;
  }
  else
  {
    __int16 v20 = 0;
  }
  *(void *)(a1 + 72) = v20;
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a3 + 24);
  *(_WORD *)(a1 + 84) = *(_WORD *)(a3 + 28);
  RB::ImageTexture::ImageTexture((RB::ImageTexture *)(a1 + 88), a4, (RB::Heap *)a2);
  long long v23 = *((_OWORD *)a4 + 2);
  long long v24 = *((_OWORD *)a4 + 3);
  long long v25 = *((_OWORD *)a4 + 4);
  *(_OWORD *)(a1 + 168) = *((_OWORD *)a4 + 5);
  *(_OWORD *)(a1 + 104) = *((_OWORD *)a4 + 1);
  *(_OWORD *)(a1 + 152) = v25;
  *(_OWORD *)(a1 + 136) = v24;
  *(_OWORD *)(a1 + 120) = v23;
  if (!*(unsigned char *)(a1 + 181)) {
    *(_WORD *)(a1 + 180) = a7;
  }
  return a1;
}

void sub_214103D64(_Unwind_Exception *a1)
{
  RBPathRelease(*(void *)(v1 + 56), *(void *)(v1 + 64));
  _Unwind_Resume(a1);
}

void RB::Symbol::Animator::Animator(RB::Symbol::Animator *this)
{
  *(_DWORD *)this = 0;
  operator new();
}

uint64_t RB::Symbol::Animator::set_flips_rtl(RB::Symbol::Animator *this, int a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)this);
  int v4 = (((*(unsigned __int16 *)(*((void *)this + 1) + 88) | (*(unsigned __int8 *)(*((void *)this + 1) + 90) << 16)) & 0x20000) == 0) ^ a2;
  if ((v4 & 1) == 0)
  {
    RB::Symbol::Model::copy_on_write((uint64_t)this + 8);
    RB::Symbol::Model::set_flips_rtl(*((RB::Symbol::Model **)this + 1), a2);
    ++*((_DWORD *)this + 15);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this);
  return v4 ^ 1u;
}

void sub_214103F9C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

BOOL RB::Symbol::Animator::set_presentation_position(uint64_t a1, float32x2_t a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)a1);
  uint32x2_t v4 = (uint32x2_t)vceq_f32(*(float32x2_t *)(a1 + 48), a2);
  signed __int32 v5 = vpmin_u32(v4, v4).u32[0];
  if ((v5 & 0x80000000) == 0)
  {
    *(double *)(a1 + 48) = *(double *)&a2;
    ++*(_DWORD *)(a1 + 60);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
  return v5 >= 0;
}

uint64_t RB::Symbol::Animator::glyph(os_unfair_lock_s *this)
{
  os_unfair_lock_lock(this);
  uint64_t v2 = *(void *)(*(void *)&this[2]._os_unfair_lock_opaque + 16);
  os_unfair_lock_unlock(this);
  return v2;
}

atomic_uint *RBSymbolUpdateLayerDraw(uint64_t a1, RB::DisplayList::State *a2, uint64_t a3, char a4, float a5, float a6, float a7, float a8, float a9)
{
  unint64_t v16 = *(RB::Symbol::Presentation **)a1;
  uint64_t v17 = *(void *)a1 + 8;
  if (*(void *)(*(void *)a1 + 840)) {
    uint64_t v17 = *(void *)(*(void *)a1 + 840);
  }
  uint64_t v65 = v17;
  unsigned int v66 = *(_DWORD *)(*(void *)a1 + 848) + ~*(_DWORD *)(a1 + 8);
  uint64_t v18 = v17 + 416 * v66;
  uint64_t v19 = *(void *)(a1 + 16);
  __int16 v20 = *(void **)(v18 + 400);
  if (v20)
  {
    long long v21 = (_DWORD *)(*v20 + 8 * *(void *)(a1 + 16));
    LODWORD(v19) = *v21;
    unsigned int v22 = v21[1];
    BOOL v68 = v22 > 1;
  }
  else
  {
    BOOL v68 = 0;
    unsigned int v22 = 1;
  }
  long long v25 = RBDrawingStateInit(a2);
  unsigned int v61 = v19;
  unsigned int v67 = v19 + v22;
  if (a4)
  {
    uint64_t v26 = v65 + 416 * v66;
    unsigned int v27 = *(_DWORD *)(v26 + 384);
    if (v67 < v27)
    {
      uint64_t v63 = v18;
      unsigned int v64 = (unsigned int *)(v26 + 384);
      uint64_t v28 = v65 + 416 * v66;
      uint64_t v29 = v28 + 16;
      uint64_t v30 = (void *)(v28 + 376);
      unint64_t v31 = v19 + v22;
      uint64_t v32 = 120 * v31;
      uint64_t v62 = v28 + 16;
      do
      {
        if (*v30) {
          uint64_t v33 = *v30;
        }
        else {
          uint64_t v33 = v29;
        }
        uint64_t v34 = (float32x2_t *)(v33 + v32);
        uint64_t v35 = *(void *)(v33 + v32);
        if ((*(unsigned char *)(v35 + 86) & 0x40) != 0)
        {
          float v36 = *(float *)(v35 + 72);
          uint64_t v37 = v33 + v32;
          float v38 = v36 <= 0.0 ? *(float *)(v37 + 32) * *(float *)(v37 + 28) : *(float *)(v37 + 32);
          if (v38 > 0.0)
          {
            float64x2_t v39 = (RB::Symbol::Model **)v18;
            float64x2_t v40 = v30;
            RB::Symbol::Presentation::Layer::set_animation_layer((RB::Symbol::Presentation::Layer *)(v33 + v32), v25, v39);
            uint64_t v41 = a3;
            uint64_t v42 = v33 + v32;
            uint64_t v43 = *(void *)(v33 + v32);
            v44.f64[0] = RB::Symbol::Presentation::Layer::transform(v34, (uint64_t)v16);
            float64x2_t v69 = v44;
            long long v70 = v45;
            long long v71 = v46;
            double v47 = (_DWORD *)(v42 + 52);
            a3 = v41;
            LODWORD(v45) = 0;
            DWORD1(v45) = *v47;
            RB::Symbol::Glyph::Layer::clip(v43, (__n128 *)v25, 1, &v69, v16, v38, *(float32x2_t *)&v45);
            uint64_t v30 = v40;
            uint64_t v29 = v62;
            uint64_t v18 = v63;
            unsigned int v27 = *v64;
          }
        }
        ++v31;
        v32 += 120;
      }
      while (v31 < v27);
    }
  }
  if (v61 < v67)
  {
    uint64_t v48 = v65 + 416 * v66;
    uint64_t v49 = v48 + 16;
    uint64_t v50 = (uint64_t *)(v48 + 376);
    uint64_t v51 = 120 * v61;
    do
    {
      uint64_t v52 = *v50;
      if (!*v50) {
        uint64_t v52 = v49;
      }
      int v53 = (float *)(v52 + v51);
      float v54 = a9;
      if (v68) {
        float v54 = (float)(*(float *)(*(void *)v53 + 72) * (float)(a9 * v53[6])) * v53[8];
      }
      RB::Symbol::Presentation::Layer::set_animation_layer((RB::Symbol::Presentation::Layer *)v53, v25, (RB::Symbol::Model **)v18);
      uint64_t v55 = *(void *)v53;
      v56.f64[0] = RB::Symbol::Presentation::Layer::transform((float32x2_t *)v53, (uint64_t)v16);
      float64x2_t v69 = v56;
      long long v70 = v57;
      long long v71 = v58;
      v59.i32[0] = 0;
      v59.f32[1] = v53[13];
      RB::Symbol::Glyph::Layer::draw(v55, (__n128 *)v25, a3, &v69, v16, a5, a6, a7, a8, v54, v59);
      v51 += 120;
      --v22;
    }
    while (v22);
  }
  return RBDrawingStateDestroy((RB::XML::Document *)v25, v23, v24);
}

float64_t RB::Symbol::Presentation::Layer::transform(float32x2_t *a1, uint64_t a2)
{
  if (a2)
  {
    float64x2_t v3 = *(float64x2_t *)(a2 + 880);
    long long v33 = *(_OWORD *)(a2 + 864);
    float64x2_t v34 = v3;
    float64x2_t v35 = *(float64x2_t *)(a2 + 896);
    float64x2_t v4 = (float64x2_t)v33;
    float64x2_t v5 = v35;
  }
  else
  {
    float64x2_t v4 = (float64x2_t)xmmword_2142181C0;
    long long v33 = xmmword_2142181C0;
    float64x2_t v3 = (float64x2_t)xmmword_2142181D0;
    float64x2_t v5 = 0uLL;
  }
  float32x2_t v6 = a1[8];
  v6.f32[1] = v6.f32[1] + a1[14].f32[0];
  float64x2_t v7 = vcvtq_f64_f32(v6);
  float32x2_t v8 = a1[12];
  __asm { FMOV            V5.2S, #1.0 }
  uint32x2_t v14 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(v8, _D5));
  if ((vpmax_u32(v14, v14).u32[0] & 0x80000000) != 0)
  {
    float64x2_t v4 = vmulq_n_f64(v4, v8.f32[0]);
    float64x2_t v3 = vmulq_n_f64(v3, v8.f32[1]);
    long long v33 = (__int128)v4;
  }
  float64x2_t v15 = vaddq_f64(v5, v7);
  float v16 = a1[4].f32[1];
  float v17 = a1[5].f32[1];
  if (v16 != 1.0 || v17 != 0.0)
  {
    float32x2_t v18 = a1[9];
    float v19 = v18.f32[1];
    float64x2_t v20 = vmlaq_n_f64(vmlaq_n_f64(v15, v4, v18.f32[0]), v3, v18.f32[1]);
    float64x2_t v34 = v3;
    float64x2_t v35 = v20;
    if (v17 != 0.0)
    {
      __float2 v21 = __sincosf_stret(v17);
      *(double *)v22.i64 = (float)-v21.__sinval;
      int64x2_t v29 = (int64x2_t)vcvtq_f64_f32((float32x2_t)__PAIR64__(LODWORD(v21.__sinval), LODWORD(v21.__cosval)));
      int64x2_t v30 = vzip1q_s64(v22, v29);
      uint64_t v31 = 0;
      uint64_t v32 = 0;
      v4.f64[0] = RB::operator*((float64x2_t *)&v29, (float64x2_t *)&v33);
      float v16 = a1[4].f32[1];
      float32x2_t v18 = a1[9];
      float v19 = v18.f32[1];
    }
    float64x2_t v4 = vmulq_n_f64(v4, v16);
    float64x2_t v3 = vmulq_n_f64(v3, v16);
    float64x2_t v15 = vmlaq_n_f64(vmlaq_n_f64(v20, v4, (float)-v18.f32[0]), v3, (float)-v19);
    long long v33 = (__int128)v4;
  }
  float v23 = a1[6].f32[0];
  if (v23 != 0.0)
  {
    float64x2_t v24 = vmlaq_n_f64(vmlaq_n_f64(v15, v4, COERCE_FLOAT(*(void *)&a1[11])), v3, COERCE_FLOAT(HIDWORD(*(void *)&a1[11])));
    float64x2_t v34 = v3;
    float64x2_t v35 = v24;
    __float2 v25 = __sincosf_stret(v23);
    *(double *)v26.i64 = (float)-v25.__sinval;
    int64x2_t v29 = (int64x2_t)vcvtq_f64_f32((float32x2_t)__PAIR64__(LODWORD(v25.__sinval), LODWORD(v25.__cosval)));
    int64x2_t v30 = vzip1q_s64(v26, v29);
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    v4.f64[0] = RB::operator*((float64x2_t *)&v29, (float64x2_t *)&v33);
  }
  float v27 = a1[5].f32[0];
  if (v27 != 1.0) {
    *(void *)&v4.f64[0] = *(_OWORD *)&vmulq_n_f64(v4, v27);
  }
  return v4.f64[0];
}

uint64_t RB::Symbol::Presentation::Layer::set_animation_layer(RB::Symbol::Presentation::Layer *this, _RBDrawingState *a2, RB::Symbol::Model **a3)
{
  v5[0] = *(_DWORD *)(*(void *)this + 68);
  v5[1] = *(_DWORD *)(RB::Symbol::Model::glyph_info(*a3) + 400);
  return RB::DisplayList::State::set_animation_layer((uint64_t)a2, v5);
}

uint64_t RB::DisplayList::State::set_animation_layer(uint64_t a1, _DWORD *a2)
{
  if (*(_DWORD *)(a1 + 168) == *a2 && *(_DWORD *)(a1 + 172) == a2[1]) {
    return 0;
  }
  *(void *)(a1 + 168) = *(void *)a2;
  *(void *)(a1 + 120) = 0;
  return 1;
}

uint64_t RB::Symbol::Presentation::template_image@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  if (*(_DWORD *)(this + 848) != 1) {
    goto LABEL_31;
  }
  float64x2_t v3 = (RB::Symbol::Model **)this;
  int64x2_t v4 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(*(float64x2_t *)(this + 880), (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*(float64x2_t *)(this + 864), (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(*(float64x2_t *)(this + 896)));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v4, 1), (int8x16_t)v4).u64[0] & 0x8000000000000000) == 0) {
    goto LABEL_31;
  }
  uint64_t v5 = *(void *)(this + 840) ? *(void *)(this + 840) : this + 8;
  uint64_t v6 = RB::Symbol::Model::glyph_info(*(RB::Symbol::Model **)v5);
  this = RB::Symbol::Model::glyph_info(*v3);
  if (v6 != this || *(unsigned char *)(v5 + 410) != 0) {
    goto LABEL_31;
  }
  float32x2_t v8 = *(float32x2_t **)(v5 + 376);
  if (!v8) {
    float32x2_t v8 = (float32x2_t *)(v5 + 16);
  }
  unsigned int v9 = *(_DWORD *)(v5 + 384);
  if (v9)
  {
    int v10 = &v8[15 * v9];
    __int16 v11 = v8 + 8;
    float v12 = 0.0;
    __asm { FMOV            V1.2S, #1.0 }
    while (1)
    {
      float v17 = v11 - 8;
      float32x2_t v18 = v11[-8];
      float v19 = v11[-5].f32[0] * v11[-4].f32[0];
      float v20 = v19 * *(float *)(*(void *)&v18 + 72);
      if (v20 <= 0.0)
      {
        float v21 = v12;
      }
      else
      {
        if (v12 == 0.0)
        {
          float v21 = v19 * *(float *)(*(void *)&v18 + 72);
        }
        else
        {
          float v21 = 1.0;
          if (v12 != 1.0 || v20 != 1.0) {
            goto LABEL_31;
          }
        }
        if ((*(unsigned char *)(*(void *)&v18 + 85) & 0xF) != 0) {
          goto LABEL_31;
        }
        if (v11[-4].f32[1] != 1.0) {
          goto LABEL_31;
        }
        uint32x2_t v22 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(*v11));
        if ((vpmax_u32(v22, v22).u32[0] & 0x80000000) != 0) {
          goto LABEL_31;
        }
        uint32x2_t v23 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(v11[4], _D1));
        if ((vpmax_u32(v23, v23).u32[0] & 0x80000000) != 0 || *(float *)(*(void *)&v18 + 60) != 0.0) {
          goto LABEL_31;
        }
      }
      v11 += 15;
      float v12 = v21;
      if (&v17[15] == v10) {
        goto LABEL_29;
      }
    }
  }
  float v21 = 0.0;
LABEL_29:
  this = RB::Symbol::Glyph::has_template_image((os_unfair_lock_s *)v6, *(const RB::Symbol::Model **)v5);
  if (this)
  {
    this = [(id)RB::Symbol::Glyph::copied_glyph((RB::Symbol::Glyph *)v6) image];
    float v24 = *(float *)(v6 + 44);
    *(void *)a2 = this;
    *(double *)(a2 + 8) = v24;
    *(float *)(a2 + 16) = v21;
  }
  else
  {
LABEL_31:
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 16) = 0;
  }
  return this;
}

uint64_t RB::Symbol::Animator::style_mask(os_unfair_lock_s *this)
{
  os_unfair_lock_lock(this);
  uint64_t v2 = *(RB::Symbol::Model **)&this[2]._os_unfair_lock_opaque;
  if (v2) {
    uint64_t v3 = *(unsigned int *)(RB::Symbol::Model::glyph_info(v2) + 392);
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(void *)&this[6]._os_unfair_lock_opaque;
  if (v4)
  {
    uint64_t v5 = *(RB::Symbol::Animation **)&this[4]._os_unfair_lock_opaque;
    uint64_t v6 = 88 * v4;
    do
    {
      uint64_t v3 = RB::Symbol::Animation::style_mask(v5) | v3;
      uint64_t v5 = (RB::Symbol::Animation *)((char *)v5 + 88);
      v6 -= 88;
    }
    while (v6);
  }
  os_unfair_lock_unlock(this);
  return v3;
}

void sub_2141048D8(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::Symbol::Model::glyph_info(RB::Symbol::Model *this)
{
  uint64_t v3 = (RB::Symbol::Model *)((char *)this + 96);
  uint64_t result = *((void *)this + 12);
  if (!result)
  {
    uint64_t v4 = (os_unfair_lock_s *)RB::Symbol::GlyphCache::shared(0);
    uint64_t v5 = RB::Symbol::GlyphCache::ref(v4, *((void **)this + 2), *((unsigned __int8 *)this + 88), (*((unsigned char *)this + 90) & 2) != 0);
    std::unique_ptr<RB::Symbol::Glyph const,RB::Symbol::GlyphCache::Unref>::reset[abi:nn180100](v3, (uint64_t)v5);
    return *((void *)this + 12);
  }
  return result;
}

void std::unique_ptr<RB::Symbol::Glyph const,RB::Symbol::GlyphCache::Unref>::reset[abi:nn180100](RB::Symbol::GlyphCache *a1, uint64_t a2)
{
  uint64_t v2 = *(const RB::Symbol::Glyph **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    uint64_t v3 = (os_unfair_lock_s *)RB::Symbol::GlyphCache::shared(a1);
    RB::Symbol::GlyphCache::unref(v3, v2);
  }
}

uint64_t RB::Symbol::Glyph::has_template_image(os_unfair_lock_s *this, const RB::Symbol::Model *a2)
{
  uint64_t v3 = this + 102;
  os_unfair_lock_lock(this + 102);
  if (!BYTE1(this[103]._os_unfair_lock_opaque))
  {
    LOWORD(this[103]._os_unfair_lock_opaque) = 256;
    if (this[6]._os_unfair_lock_opaque == 1)
    {
      uint64_t v4 = (void *)[*(id *)&this->_os_unfair_lock_opaque knownAvailableVectorSizes];
      uint64_t v5 = v4;
      if (v4)
      {
        uint64_t v6 = [v4 count];
        [*(id *)&this->_os_unfair_lock_opaque pointSize];
        if (v6)
        {
          double v8 = v7;
          uint64_t v9 = 0;
          while (1)
          {
            objc_msgSend((id)objc_msgSend(v5, "objectAtIndexedSubscript:", v9), "doubleValue");
            if (v10 == v8) {
              break;
            }
            if (v6 == ++v9) {
              goto LABEL_10;
            }
          }
          LOWORD(this[103]._os_unfair_lock_opaque) = 257;
        }
      }
    }
  }
LABEL_10:
  uint64_t os_unfair_lock_opaque_low = LOBYTE(this[103]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v3);
  return os_unfair_lock_opaque_low;
}

void sub_214104A60(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

float32x2_t *RB::Symbol::Glyph::Glyph(uint64_t a1, long long *a2)
{
  uint64_t v2 = (float32x2_t *)a1;
  uint64_t v176 = *MEMORY[0x263EF8340];
  long long v3 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v3;
  *(_DWORD *)(a1 + 24) = *((_DWORD *)a2 + 4);
  *(_DWORD *)(a1 + 28) = 0;
  *(_OWORD *)(a1 + 32) = xmmword_214219990;
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)(a1 + 376) = 0;
  *(void *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 384) = xmmword_2142199A0;
  *(_DWORD *)(a1 + 400) = 0;
  *(unsigned char *)(a1 + 404) = *(unsigned char *)(a1 + 404) & 0xF0 | 3;
  *(_DWORD *)(a1 + 408) = 0;
  *(_WORD *)(a1 + 412) = 0;
  *(void *)(a1 + 416) = 0;
  if (!*(void *)a1) {
    return v2;
  }
  uint64_t v5 = (float32x2_t *)(a1 + 112);
  id v6 = *(id *)a1;
  if (!v2[3].i32[0]) {
    v2[3].i32[0] = [*(id *)a2 preferredRenderingMode];
  }
  [*(id *)v2 pointSize];
  *(float *)&double v7 = v7;
  v2[4].i32[0] = LODWORD(v7);
  if (objc_opt_respondsToSelector())
  {
    [*(id *)v2 glyphContinuousSize];
    *(float *)&double v8 = v8;
    v2[4].i32[1] = LODWORD(v8);
    [*(id *)v2 glyphContinuousWeight];
    *(float *)&double v9 = v9;
    v2[5].i32[0] = LODWORD(v9);
  }
  [*(id *)v2 scale];
  *(float *)&double v10 = v10;
  v2[5].i32[1] = LODWORD(v10);
  [*(id *)v2 alignmentRectUnrounded];
  v12.f64[1] = v11;
  v14.f64[1] = v13;
  v2[7] = vcvt_f32_f64(v12);
  v2[8] = vcvt_f32_f64(v14);
  if (v2[2].i8[4])
  {
    [*(id *)v2 contentBoundsUnrounded];
    float32_t v16 = v15 - (float)(COERCE_FLOAT(*(void *)&v2[8]) + COERCE_FLOAT(*(void *)&v2[7]));
    v2[7].f32[0] = v16;
  }
  [*(id *)v2 pointSize];
  double v18 = v17;
  [*(id *)v2 referencePointSize];
  double v20 = v19;
  [*(id *)v2 fontMatchingScaleFactor];
  v22.i64[0] = 1.0;
  BOOL v23 = v20 < 1.0 || v18 < 1.0;
  if (!v23) {
    *(double *)v22.i64 = v18 / v20;
  }
  double v24 = v21 * *(double *)v22.i64;
  *(float *)&double v24 = v24;
  v2[6].i32[0] = LODWORD(v24);
  LODWORD(v24) = v2[5].i32[1];
  *(float32x2_t *)v22.f32 = vmul_n_f32(v2[7], *(float *)&v24);
  __asm { FMOV            V2.2S, #1.0 }
  float32x2_t v29 = vdiv_f32(_D2, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v24, 0));
  float32x2_t v30 = vmul_f32(vrndp_f32(vmul_n_f32(v2[8], *(float *)&v24)), v29);
  v2[9] = vmul_f32((float32x2_t)*(_OWORD *)&vrndaq_f32(v22), v29);
  v2[10] = v30;
  char v31 = objc_opt_respondsToSelector();
  id v32 = (id)*v2;
  if ((v31 & 1) == 0)
  {
    [v32 contentBoundsUnrounded];
    double v39 = v38;
    [*(id *)v2 capHeightUnrounded];
    double v41 = v40;
    [*(id *)v2 baselineOffsetUnrounded];
    float v43 = -(COERCE_FLOAT(*(void *)&v2[7]) - v39 * 0.5);
    *(float *)&unsigned int v44 = v42 + v41 * 0.5;
    float32x2_t v35 = (float32x2_t)__PAIR64__(v44, LODWORD(v43));
    if (v2[2].i8[4])
    {
      v35.f32[0] = COERCE_FLOAT(*(void *)&v2[8]) - v43;
      LODWORD(v37) = HIDWORD(*(void *)&v2[8]);
      goto LABEL_19;
    }
LABEL_18:
    float v37 = v2[8].f32[1];
    goto LABEL_19;
  }
  [v32 metricCenter];
  v34.f64[1] = v33;
  float32x2_t v35 = vcvt_f32_f64(v34);
  if (!v2[2].i8[4]) {
    goto LABEL_18;
  }
  v36.i32[0] = vsub_f32(v2[8], v35).u32[0];
  v36.i32[1] = v35.i32[1];
  LODWORD(v37) = HIDWORD(*(void *)&v2[8]);
  float32x2_t v35 = v36;
LABEL_19:
  v35.f32[1] = v37 - v35.f32[1];
  v2[11] = v35;
  if (objc_opt_respondsToSelector())
  {
    [*(id *)v2 rotationAnchor];
    v46.f64[1] = v45;
    float32x2_t v47 = vcvt_f32_f64(v46);
    int v48 = v2[2].u8[4];
    if (v2[2].i8[4])
    {
      v49.i32[0] = vsub_f32(v2[8], v47).u32[0];
      v49.i32[1] = v47.i32[1];
      LODWORD(v50) = HIDWORD(*(void *)&v2[8]);
      float32x2_t v47 = v49;
    }
    else
    {
      float v50 = v2[8].f32[1];
    }
    v47.f32[1] = v50 - v47.f32[1];
  }
  else
  {
    float32x2_t v47 = v2[11];
    int v48 = v2[2].u8[4];
  }
  v2[13] = v47;
  if (v48) {
    float32x2_t v51 = v2[10];
  }
  else {
    v51.i32[0] = 0;
  }
  float v155 = v51.f32[0];
  __int32 v52 = v2[3].i32[0];
  switch(v52)
  {
    case 0:
    case 1:
      uint64_t v53 = [*(id *)v2 monochromeLayers];
      goto LABEL_56;
    case 2:
      uint64_t v53 = [*(id *)v2 multicolorLayers];
LABEL_56:
      float64x2_t v56 = (void *)v53;
      int v67 = 0;
      goto LABEL_61;
    case 3:
      goto LABEL_31;
    case 4:
      goto LABEL_52;
    default:
      if ((v52 - 128) >= 2)
      {
        if (v52 != 130)
        {
          int v67 = 0;
          float64x2_t v56 = 0;
          goto LABEL_63;
        }
LABEL_52:
        BOOL v68 = (RB::Symbol::_anonymous_namespace_ *)[*(id *)v2 paletteLayers];
        float64x2_t v56 = v68;
        __int32 v57 = v2[3].i32[0];
        if (v57 != 130) {
          goto LABEL_54;
        }
        v2[3].i32[0] = 4;
LABEL_59:
        int v67 = v70;
        goto LABEL_61;
      }
LABEL_31:
      float v54 = (RB::Symbol::_anonymous_namespace_ *)[*(id *)v2 hierarchicalLayers];
      float64x2_t v56 = v54;
      __int32 v57 = v2[3].i32[0];
      if (v57 == 129)
      {
        v2[3].i32[0] = 3;
        goto LABEL_59;
      }
      if (v57 != 128)
      {
LABEL_54:
        int v67 = 0;
        goto LABEL_62;
      }
      long long v165 = 0u;
      long long v166 = 0u;
      long long v167 = 0u;
      long long v168 = 0u;
      uint64_t v58 = [(RB::Symbol::_anonymous_namespace_ *)v54 countByEnumeratingWithState:&v165 objects:__dst count:16];
      if (!v58)
      {
LABEL_50:
        int v67 = 0;
        v2[3].i32[0] = 3;
        goto LABEL_63;
      }
      uint64_t v59 = *(void *)v166;
      uint64_t v150 = *(void *)v166;
LABEL_35:
      uint64_t v60 = 0;
      while (1)
      {
        if (*(void *)v166 != v59) {
          objc_enumerationMutation(v56);
        }
        unsigned int v61 = *(void **)(*((void *)&v165 + 1) + 8 * v60);
        if (objc_opt_respondsToSelector())
        {
          uint64_t v62 = (void *)[v61 tags];
          uint64_t v63 = v62;
          if (v62)
          {
            long long v163 = 0u;
            long long v164 = 0u;
            long long v161 = 0u;
            long long v162 = 0u;
            uint64_t v64 = [v62 countByEnumeratingWithState:&v161 objects:&v174 count:16];
            if (v64) {
              break;
            }
          }
        }
LABEL_48:
        if (++v60 == v58)
        {
          uint64_t v58 = [v56 countByEnumeratingWithState:&v165 objects:__dst count:16];
          uint64_t v5 = v2 + 14;
          if (!v58) {
            goto LABEL_50;
          }
          goto LABEL_35;
        }
      }
      uint64_t v65 = *(void *)v162;
LABEL_42:
      uint64_t v66 = 0;
      while (1)
      {
        if (*(void *)v162 != v65) {
          objc_enumerationMutation(v63);
        }
        if (objc_msgSend(*(id *)(*((void *)&v161 + 1) + 8 * v66), "isEqualToString:", @"_slash", v150)) {
          break;
        }
        if (v64 == ++v66)
        {
          uint64_t v64 = [v63 countByEnumeratingWithState:&v161 objects:&v174 count:16];
          uint64_t v59 = v150;
          if (!v64) {
            goto LABEL_48;
          }
          goto LABEL_42;
        }
      }
      float64x2_t v56 = 0;
      int v67 = 0;
      uint64_t v5 = v2 + 14;
LABEL_61:
      __int32 v57 = v2[3].i32[0];
LABEL_62:
      if (v57 == 1) {
        goto LABEL_65;
      }
LABEL_63:
      if (!objc_msgSend(v56, "count", v150))
      {
        float64x2_t v56 = (void *)[*(id *)v2 monochromeLayers];
        v2[3].i32[0] = 1;
      }
LABEL_65:
      long long v159 = 0u;
      long long v160 = 0u;
      long long v157 = 0u;
      long long v158 = 0u;
      uint64_t v71 = [v56 countByEnumeratingWithState:&v157 objects:v173 count:16];
      if (v71)
      {
        uint64_t v72 = *(void *)v158;
        while (2)
        {
          for (uint64_t i = 0; i != v71; ++i)
          {
            if (*(void *)v158 != v72) {
              objc_enumerationMutation(v56);
            }
            unsigned int v74 = *(void **)(*((void *)&v157 + 1) + 8 * i);
            unsigned __int32 v75 = v2[48].u32[0];
            if (v2[48].i32[1] < v75 + 1)
            {
              RB::vector<RB::Symbol::Glyph::Layer,3ul,unsigned int>::reserve_slow(v5, v75 + 1);
              unsigned __int32 v75 = v2[48].u32[0];
            }
            uint64_t v76 = (float32x2_t *)v2[47];
            if (!v76) {
              uint64_t v76 = v5;
            }
            RB::Symbol::Glyph::Layer::Layer((uint64_t)&v76[11 * v75], (uint64_t)*v2, v74, v2[3].i32[0]);
            unsigned __int32 v77 = v2[48].u32[0];
            v2[48].i32[0] = v77 + 1;
            if (v2[47]) {
              unsigned int v78 = (RB::Symbol::Glyph::Layer *)v2[47];
            }
            else {
              unsigned int v78 = (RB::Symbol::Glyph::Layer *)v5;
            }
            if ((*((unsigned char *)v78 + 88 * v77 + 86) & 0xC) == 0)
            {
              if (v77 != -1)
              {
                uint64_t v80 = 88 * (v77 + 1);
                do
                {
                  RB::Symbol::Glyph::Layer::~Layer(v78);
                  unsigned int v78 = (RB::Symbol::Glyph::Layer *)(v81 + 88);
                  v80 -= 88;
                }
                while (v80);
              }
              uint64_t v2 = (float32x2_t *)a1;
              *(_DWORD *)(a1 + 384) = 0;
              goto LABEL_86;
            }
          }
          uint64_t v71 = [v56 countByEnumeratingWithState:&v157 objects:v173 count:16];
          if (v71) {
            continue;
          }
          break;
        }
      }
      unsigned __int32 v79 = v2[48].u32[0];
      if (v79)
      {
        v170 = 0;
        size_t v171 = 0;
        unint64_t v172 = 32;
        float32x2_t v174 = 0;
        float32x2_t v175 = 0;
        goto LABEL_87;
      }
LABEL_86:
      v2[3].i32[0] = *((_DWORD *)a2 + 4);
      RB::Symbol::Glyph::make_legacy_layers((RB::Symbol::Glyph *)v2, v155);
      unsigned __int32 v79 = v2[48].u32[0];
      v170 = 0;
      size_t v171 = 0;
      unint64_t v172 = 32;
      float32x2_t v174 = 0;
      float32x2_t v175 = 0;
      if (v79)
      {
LABEL_87:
        int v151 = v67;
        v153 = v5;
        uint64_t v82 = 0;
        uint64_t v83 = 0;
        unsigned int v84 = 0;
        int v85 = 0;
        uint64_t v152 = v79;
        do
        {
          if (v2[47]) {
            float32x2_t v86 = v2[47];
          }
          else {
            float32x2_t v86 = (float32x2_t)v153;
          }
          uint64_t v87 = *(void *)&v86 + v82;
          unsigned int v88 = *(_DWORD *)(*(void *)&v86 + v82 + 84);
          if ((v88 & 0xF00) == 0x900)
          {
            int v89 = [*(id *)(v87 + 8) isEqualToString:@"tintColor"];
            unsigned int v88 = *(_DWORD *)(v87 + 84);
            if (v89)
            {
              v88 &= 0xFFFFF0FF;
              *(_DWORD *)(v87 + 84) = v88;
            }
          }
          int v90 = (v88 >> 8) & 0xF;
          if (v90 != 10)
          {
            v2[49].i32[0] |= 1 << v90;
            unsigned int v88 = *(_DWORD *)(v87 + 84);
          }
          unsigned int v91 = v2[50].u8[4];
          __int8 v92 = v91 & (((v88 & 0x800000) == 0) | 0xFE);
          v2[50].i8[4] = v92;
          if ((((*(_DWORD *)(v87 + 84) & 0x1000000) == 0) & (v91 >> 1)) != 0) {
            char v93 = 2;
          }
          else {
            char v93 = 0;
          }
          v2[50].i8[4] = v92 & 0xFD | v93;
          uint64_t v94 = *(void *)&v86 + v82;
          int v95 = *(_DWORD *)(v94 + 68);
          char v156 = *(unsigned char *)(v87 + 84);
          int v96 = *(_DWORD *)(v94 + 64);
          if ((v96 & 0x7FFFFFFFu) <= 0x7F7FFFFF)
          {
            unint64_t v97 = v171;
            size_t v98 = v171 + 1;
            if (v172 < v171 + 1)
            {
              RB::vector<RB::DisplayList::Item const*,32ul,unsigned long>::reserve_slow(__dst, v98);
              unint64_t v97 = v171;
              int v96 = *(_DWORD *)(v94 + 64);
              size_t v98 = v171 + 1;
            }
            float64x2_t v99 = v170;
            if (!v170) {
              float64x2_t v99 = __dst;
            }
            unsigned int v100 = &v99[8 * v97];
            *unsigned int v100 = v96;
            v100[1] = v83;
            size_t v171 = v98;
          }
          unint64_t v101 = *(int **)(v94 + 40);
          if (v101) {
            uint64_t v102 = *(int **)(v94 + 40);
          }
          else {
            uint64_t v102 = (int *)(v94 + 24);
          }
          unint64_t v103 = *(unsigned int *)(v94 + 48);
          if (RB::Symbol::tags_contains(v102, v103, 1u))
          {
            *(unsigned char *)(a1 + 404) |= 4u;
            unint64_t v101 = *(int **)(v94 + 40);
            unint64_t v103 = *(unsigned int *)(v94 + 48);
          }
          if (v101) {
            float v104 = v101;
          }
          else {
            float v104 = (int *)(v94 + 24);
          }
          uint64_t v2 = (float32x2_t *)a1;
          if (RB::Symbol::tags_contains(v104, v103, 2u))
          {
            *(unsigned char *)(a1 + 404) |= 8u;
            *(int8x8_t *)&double v109 = RB::Symbol::Glyph::Layer::content_bounds((float32x2_t **)v87, v105, v106, v107, v108);
            RB::Rect::Union(&v174, v109, v110, v111, v112, v113, v114);
          }
          v84 |= 1 << v95;
          v85 |= 1 << v156;
          ++v83;
          v82 += 88;
        }
        while (v152 != v83);
        float32x2_t v115 = v175;
        int v116 = v85 & 2;
        uint64_t v5 = v153;
        int v67 = v151;
        goto LABEL_118;
      }
      int v116 = 0;
      unsigned int v84 = 0;
      float32x2_t v115 = 0;
LABEL_118:
      uint32x2_t v117 = (uint32x2_t)vcgtz_f32(v115);
      if ((vpmin_u32(v117, v117).u32[0] & 0x80000000) != 0) {
        float32x2_t v118 = vmla_f32(v174, (float32x2_t)0x3F0000003F000000, v115);
      }
      else {
        float32x2_t v118 = v2[11];
      }
      v2[12] = v118;
      v115.i32[0] = v84;
      uint8x8_t v119 = (uint8x8_t)vcnt_s8((int8x8_t)v115);
      v119.i16[0] = vaddlv_u8(v119);
      v2[50].i32[0] = v119.i32[0];
      if (v84 != ~(-1 << v119.i8[0]) && v84 != 0)
      {
        int v121 = 0;
        int v122 = 0;
        do
        {
          if (v84)
          {
            if (v122 != v121)
            {
              float64x2_t v123 = *(void *)&v2[47] ? *(float32x2_t **)&v2[47] : v5;
              unsigned __int32 v124 = v2[48].u32[0];
              if (v124)
              {
                uint64_t v125 = 88 * v124;
                float64x2_t v126 = (_DWORD *)&v123[8] + 1;
                do
                {
                  if (*v126 == v122) {
                    *float64x2_t v126 = v121;
                  }
                  v126 += 22;
                  v125 -= 88;
                }
                while (v125);
              }
            }
            ++v121;
          }
          ++v122;
          BOOL v23 = v84 > 1;
          v84 >>= 1;
        }
        while (v23);
      }
      if (v171)
      {
        if (v170) {
          float64x2_t v127 = (int *)v170;
        }
        else {
          float64x2_t v127 = (int *)__dst;
        }
        std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *,false>(v127, (char *)&v127[2 * v171], (uint64_t)&v165, 126 - 2 * __clz(v171), 1);
        float64x2_t v128 = v170;
        if (!v170) {
          float64x2_t v128 = __dst;
        }
        uint64_t v2 = (float32x2_t *)a1;
        if (v171)
        {
          float64x2_t v129 = &v128[8 * v171];
          float64x2_t v130 = *(float32x2_t **)(a1 + 376);
          if (!v130) {
            float64x2_t v130 = v5;
          }
          __int32 v131 = *(_DWORD *)(a1 + 396);
          float v132 = INFINITY;
          do
          {
            float v133 = v132;
            float v132 = *(float *)v128;
            unsigned int v134 = *((_DWORD *)v128 + 1);
            if (*(float *)v128 != v133) {
              *(_DWORD *)(a1 + 396) = ++v131;
            }
            v130[11 * v134 + 10].i32[0] = v131;
            v128 += 8;
          }
          while (v128 != v129);
        }
      }
      if (v67)
      {
        __int32 v135 = v2[3].i32[0];
        if (v135 != 4)
        {
          if (v135 == 3 && v116)
          {
            v136 = *(void *)&v2[47] ? *(float32x2_t **)&v2[47] : v5;
            unsigned __int32 v137 = v2[48].u32[0];
            if (v137)
            {
              uint64_t v138 = 88 * v137;
              double v139 = (unsigned int *)&v136[10] + 1;
              while (1)
              {
                unsigned int v140 = *v139;
                if ((*v139 & 0xF00) == 0)
                {
                  if (*v139 == 1)
                  {
                    unsigned int v141 = v140 & 0xFFFFFF00;
                    goto LABEL_165;
                  }
                  if (!*v139)
                  {
                    unsigned int v141 = v140 & 0xFFFFFF00 | 1;
LABEL_165:
                    *double v139 = v141;
                  }
                }
                v139 += 22;
                v138 -= 88;
                if (!v138) {
                  goto LABEL_182;
                }
              }
            }
          }
          goto LABEL_182;
        }
        if ((v2[49].i16[0] & 0x1E0) != 0)
        {
          v2[49].i32[0] = 0;
          double v142 = *(void *)&v2[47] ? *(float32x2_t **)&v2[47] : v5;
          unsigned __int32 v143 = v2[48].u32[0];
          if (v143)
          {
            uint64_t v144 = 88 * v143;
            double v145 = (unsigned int *)&v142[10] + 1;
            while (1)
            {
              unsigned int v146 = *v145;
              int v147 = (*v145 >> 8) & 0xF;
              if ((v147 - 5) < 4) {
                break;
              }
              if (!v147)
              {
                unsigned int v146 = v146 & 0xFFFFF0FF | 0x500;
                goto LABEL_178;
              }
LABEL_179:
              int v148 = (v146 >> 8) & 0xF;
              if (v148 != 10) {
                v2[49].i32[0] |= 1 << v148;
              }
              v145 += 22;
              v144 -= 88;
              if (!v144) {
                goto LABEL_182;
              }
            }
            v146 &= 0xFFFFF0FF;
LABEL_178:
            *double v145 = v146;
            goto LABEL_179;
          }
        }
      }
LABEL_182:
      if (v170) {
        free(v170);
      }
      return v2;
  }
}

void sub_214105604(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, RB::Symbol::Glyph::Layer *a11, uint64_t a12)
{
  RB::vector<RB::Symbol::Glyph::Layer,3ul,unsigned int>::~vector(a11);
  _Unwind_Resume(a1);
}

uint64_t RB::Symbol::Glyph::Layer::Layer(uint64_t a1, uint64_t a2, void *a3, int a4)
{
  uint64_t v49 = *MEMORY[0x263EF8340];
  *(void *)(a1 + 8) = 0;
  double v7 = (id *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  double v42 = (const void **)(a1 + 16);
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0x400000000;
  *(void *)(a1 + 56) = 1065353216;
  *(void *)(a1 + 64) = 2139095040;
  *(void *)(a1 + 72) = 1065353216;
  unsigned int v8 = *(_DWORD *)(a1 + 84) & 0xFE000000 | 0x311A00;
  *(_DWORD *)(a1 + 80) = -1;
  *(_DWORD *)(a1 + 84) = v8;
  if (objc_opt_respondsToSelector())
  {
    double v9 = (RB::Symbol::GlyphCache *)[a3 tags];
    double v10 = v9;
    if (v9)
    {
      float64_t v11 = (RB::Symbol::GlyphCache *)RB::Symbol::GlyphCache::shared(v9);
      int v41 = a4;
      long long v45 = 0u;
      long long v46 = 0u;
      long long v43 = 0u;
      long long v44 = 0u;
      uint64_t v12 = [(RB::Symbol::GlyphCache *)v10 countByEnumeratingWithState:&v43 objects:v48 count:16];
      if (v12)
      {
        uint64_t v13 = *(void *)v44;
        do
        {
          for (uint64_t i = 0; i != v12; ++i)
          {
            if (*(void *)v44 != v13) {
              objc_enumerationMutation(v10);
            }
            unsigned int v15 = RB::Symbol::GlyphCache::intern_locked(v11, *(NSString **)(*((void *)&v43 + 1) + 8 * i));
            unsigned int v16 = *(_DWORD *)(a1 + 48);
            if (*(_DWORD *)(a1 + 52) < v16 + 1)
            {
              RB::vector<RB::Symbol::Tag,4ul,unsigned int>::reserve_slow(v7 + 2, v16 + 1);
              unsigned int v16 = *(_DWORD *)(a1 + 48);
            }
            double v17 = *(id **)(a1 + 40);
            if (!v17) {
              double v17 = v7 + 2;
            }
            *((_DWORD *)v17 + v16) = v15;
            ++*(_DWORD *)(a1 + 48);
          }
          uint64_t v12 = [(RB::Symbol::GlyphCache *)v10 countByEnumeratingWithState:&v43 objects:v48 count:16];
        }
        while (v12);
      }
      if (*(void *)(a1 + 40)) {
        uint64_t v18 = *(void *)(a1 + 40);
      }
      else {
        uint64_t v18 = (uint64_t)(v7 + 2);
      }
      unint64_t v19 = *(unsigned int *)(a1 + 48);
      unint64_t v20 = 126 - 2 * __clz(v19);
      if (v19) {
        uint64_t v21 = v20;
      }
      else {
        uint64_t v21 = 0;
      }
      std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *,false>(v18, (unsigned int *)(v18 + 4 * v19), (uint64_t)&__dst, v21, 1);
      a4 = v41;
      if (*(void *)(a1 + 40)) {
        float32x4_t v22 = *(int **)(a1 + 40);
      }
      else {
        float32x4_t v22 = (int *)(v7 + 2);
      }
      unint64_t v23 = *(unsigned int *)(a1 + 48);
      if (RB::Symbol::tags_contains(v22, v23, 1u))
      {
        int v24 = 0x100000;
      }
      else
      {
        if (!RB::Symbol::tags_contains(v22, v23, 2u)) {
          goto LABEL_28;
        }
        int v24 = 0x200000;
      }
      *(_DWORD *)(a1 + 84) = *(_DWORD *)(a1 + 84) & 0xFFCFFFFF | v24;
    }
  }
LABEL_28:
  if ([a3 referenceShape]) {
    operator new();
  }
  if ((*(unsigned char *)(a1 + 86) & 0xC) == 0 && [a3 sublayers]) {
    operator new();
  }
  if ((*(unsigned char *)(a1 + 86) & 0xC) != 0)
  {
    [a3 valueThreshold];
    *(float *)&double v25 = v25;
    *(_DWORD *)(a1 + 64) = LODWORD(v25);
    *(_DWORD *)(a1 + 68) = [a3 motionGroup];
    [a3 opacity];
    *(float *)&double v26 = v26;
    *(_DWORD *)(a1 + 72) = LODWORD(v26);
    if ([a3 isEraserLayer]) {
      int v27 = 0x400000;
    }
    else {
      int v27 = 0;
    }
    *(_DWORD *)(a1 + 84) = *(_DWORD *)(a1 + 84) & 0xFFBFFFFF | v27;
    if ([a3 alwaysPulses]) {
      int v28 = 0x800000;
    }
    else {
      int v28 = 0;
    }
    *(_DWORD *)(a1 + 84) = *(_DWORD *)(a1 + 84) & 0xFF7FFFFF | v28;
    if (objc_opt_respondsToSelector())
    {
      if ([a3 alwaysRotates]) {
        int v29 = 0x1000000;
      }
      else {
        int v29 = 0;
      }
      *(_DWORD *)(a1 + 84) = *(_DWORD *)(a1 + 84) & 0xFEFFFFFF | v29;
    }
    if (*(float *)(a1 + 72) > 0.0)
    {
      unsigned int v30 = *(_DWORD *)(a1 + 84) & 0xFFFFF0FF;
      *(_DWORD *)(a1 + 84) = v30;
      if ((a4 - 3) < 2)
      {
        unint64_t v31 = [a3 hierarchyLevel];
        if (v31)
        {
          if (a4 == 3)
          {
            *(unsigned char *)(a1 + 84) = v31;
          }
          else
          {
            int v36 = 4;
            if (v31 < 4) {
              int v36 = v31;
            }
            *(_DWORD *)(a1 + 84) = (*(_DWORD *)(a1 + 84) & 0xFFFFF0FF | (v36 << 8)) + 1024;
          }
        }
        return a1;
      }
      if (a4 != 2) {
        return a1;
      }
      *(_DWORD *)(a1 + 84) = v30 | 0x900;
      if (*(float *)(a1 + 76) <= 0.0)
      {
        if (objc_opt_respondsToSelector())
        {
          float v37 = (const void *)[a3 fillImage];
          if (v37)
          {
            *(_DWORD *)(a1 + 84) = *(_DWORD *)(a1 + 84) & 0xFFFFF0FF | 0xC00;
            RB::cf_ptr<void const*>::operator=(v42, v37);
            return a1;
          }
        }
        id v38 = (id)[a3 fillColorName];
        if (*v7 != v38)
        {

          *double v7 = v38;
        }
        float64_t v33 = (const void *)[a3 fillColor];
        double v39 = *v42;
        if (*v42 != v33)
        {
          if (v39) {
            CFRelease(v39);
          }
          if (v33) {
            goto LABEL_58;
          }
          goto LABEL_71;
        }
      }
      else
      {
        id v32 = (id)[a3 strokeColorName];
        if (*v7 != v32)
        {

          *double v7 = v32;
        }
        float64_t v33 = (const void *)[a3 strokeColor];
        float64x2_t v34 = *v42;
        if (*v42 != v33)
        {
          if (v34) {
            CFRelease(v34);
          }
          if (v33)
          {
LABEL_58:
            CFTypeRef v35 = CFRetain(v33);
LABEL_72:
            *double v42 = v35;
            return a1;
          }
LABEL_71:
          CFTypeRef v35 = 0;
          goto LABEL_72;
        }
      }
    }
  }
  return a1;
}

void sub_214105EDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, CFTypeRef *a11)
{
  float64x2_t v14 = *(void **)(v11 + 40);
  if (v14) {
    free(v14);
  }
  if (*a11) {
    CFRelease(*a11);
  }

  _Unwind_Resume(a1);
}

BOOL RB::Symbol::tags_contains(int *a1, unint64_t a2, unsigned int a3)
{
  if (a2 > 8)
  {
    double v7 = &a1[a2];
    if (a1 != v7)
    {
      unint64_t v8 = (uint64_t)(4 * a2) >> 2;
      do
      {
        unint64_t v9 = v8 >> 1;
        double v10 = (unsigned int *)&a1[v8 >> 1];
        unsigned int v12 = *v10;
        uint64_t v11 = (int *)(v10 + 1);
        v8 += ~(v8 >> 1);
        if (v12 < a3) {
          a1 = v11;
        }
        else {
          unint64_t v8 = v9;
        }
      }
      while (v8);
      if (a1 != v7) {
        return *a1 <= a3;
      }
    }
    return 0;
  }
  if (!a2) {
    return 0;
  }
  uint64_t v3 = 4 * a2 - 4;
  do
  {
    int v4 = *a1++;
    BOOL v5 = v4 == a3;
    BOOL v6 = v4 == a3 || v3 == 0;
    v3 -= 4;
  }
  while (!v6);
  return v5;
}

void RB::Path::Storage::~Storage(RB::Path::Storage *this)
{
  uint64_t v1 = this;
  uint64_t v2 = *(void *)this;
  if (*(void *)this)
  {
    *(void *)this = 0;
    if (v2)
    {
      this = (RB::Path::Storage *)(v2 & 0xFFFFFFFFFFFFFFFCLL);
      if ((v2 & 0xFFFFFFFFFFFFFFFCLL) != 0) {
        this = (RB::Path::Storage *)MEMORY[0x21669ABF0](this, 0x1000C8052888210);
      }
    }
  }
  int v3 = *((_DWORD *)v1 + 2);
  if ((v3 & 0x20) != 0)
  {
    int v4 = (os_unfair_lock_s *)RB::Path::Storage::MapCache::shared(this);
    RB::Path::Storage::MapCache::remove(v4, v1);
    int v3 = *((_DWORD *)v1 + 2);
  }
  if (v3)
  {
    BOOL v5 = (const void *)*((void *)v1 + 7);
    if (!v5 || (*((void *)v1 + 7) = 0, CFRelease(v5), (*((unsigned char *)v1 + 8) & 1) != 0)) {
      free(*((void **)v1 + 2));
    }
  }
}

uint64_t RB::Symbol::GlyphCache::shared(RB::Symbol::GlyphCache *this)
{
  {
    operator new();
  }
  return RB::Symbol::GlyphCache::shared(void)::shared_cache;
}

void sub_21410613C(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10B0C40EE9E74E3);
  _Unwind_Resume(a1);
}

RB::Path::Storage *RB::Path::Storage::Storage(RB::Path::Storage *this, const char *a2, const RB::Path::Storage *a3)
{
  *(void *)this = 0;
  if ((unint64_t)a2 <= 0x3F) {
    RB::precondition_failure((RB *)"invalid capacity", a2, a3);
  }
  unint64_t v4 = (unint64_t)(a2 - 16);
  if ((unint64_t)(a2 - 16) >= 0xFFF) {
    unint64_t v4 = 4095;
  }
  unsigned int add_explicit = atomic_fetch_add_explicit(&RB::Path::Storage::_last_identifier, 1u, memory_order_relaxed);
  *((_DWORD *)this + 2) = v4 << 20;
  *((_DWORD *)this + 3) = add_explicit + 1;
  *((_DWORD *)this + 2) = *((_DWORD *)a3 + 2) & 0x3E | ((unsigned __int16)v4 << 20);
  unint64_t v6 = *((unsigned int *)a3 + 2);
  unint64_t v8 = (const void *)*((void *)a3 + 2);
  size_t v9 = *((void *)a3 + 3);
  double v7 = (char *)a3 + 16;
  if (v6) {
    double v10 = v8;
  }
  else {
    double v10 = v7;
  }
  if (v6) {
    size_t v11 = v9;
  }
  else {
    size_t v11 = (v6 >> 8) & 0xFFF;
  }
  if (v4 < v11)
  {
    RB::Path::Storage::reserve_slow(this, v11);
    unsigned int v12 = (void *)((char *)this + 16);
    if (*((unsigned char *)this + 8)) {
      unsigned int v12 = (void *)*v12;
    }
  }
  else
  {
    unsigned int v12 = (void *)((char *)this + 16);
  }
  memcpy(v12, v10, v11);
  int v13 = *((_DWORD *)this + 2);
  if (v13) {
    *((void *)this + 3) = v11;
  }
  else {
    *((_DWORD *)this + 2) = v13 & 0xFFF000FF | ((v11 & 0xFFF) << 8);
  }
  return this;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *,false>(uint64_t result, unsigned int *a2, uint64_t a3, uint64_t a4, char a5)
{
  double v10 = (unsigned int *)result;
LABEL_2:
  size_t v11 = v10;
LABEL_3:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    double v10 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    unint64_t v15 = a2 - v11;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          unsigned int v22 = *(a2 - 1);
          unsigned int v23 = *v11;
          if (v22 < *v11)
          {
            *size_t v11 = v22;
            *(a2 - 1) = v23;
          }
          break;
        case 3uLL:
          uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(v11, v11 + 1, a2 - 1);
          break;
        case 4uLL:
          uint64_t result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(v11, v11 + 1, v11 + 2, a2 - 1);
          break;
        case 5uLL:
          uint64_t result = std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(v11, v11 + 1, v11 + 2, v11 + 3, a2 - 1);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v14 <= 95) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        return (uint64_t)std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *,RB::Symbol::Tag *>(v11, a2, a2, a3);
      }
      return result;
    }
    unint64_t v16 = v15 >> 1;
    double v17 = &v11[v15 >> 1];
    if ((unint64_t)v14 >= 0x201)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(v11, &v11[v15 >> 1], a2 - 1);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(v11 + 1, v17 - 1, a2 - 2);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(v11 + 2, &v11[v16 + 1], a2 - 3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(v17 - 1, v17, &v11[v16 + 1]);
      unsigned int v18 = *v11;
      *size_t v11 = *v17;
      *double v17 = v18;
      if (a5) {
        goto LABEL_14;
      }
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(&v11[v15 >> 1], v11, a2 - 1);
      if (a5) {
        goto LABEL_14;
      }
    }
    if (*(v11 - 1) >= *v11)
    {
      uint64_t result = (uint64_t)std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,RB::Symbol::Tag *,std::__less<void,void> &>(v11, (int *)a2);
      size_t v11 = (unsigned int *)result;
      goto LABEL_19;
    }
LABEL_14:
    unint64_t v19 = std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,RB::Symbol::Tag *,std::__less<void,void> &>(v11, a2);
    if ((v20 & 1) == 0) {
      goto LABEL_17;
    }
    BOOL v21 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(v11, v19);
    size_t v11 = v19 + 1;
    uint64_t result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(v19 + 1, a2);
    if (result)
    {
      a4 = -v13;
      a2 = v19;
      if (v21) {
        return result;
      }
      goto LABEL_2;
    }
    uint64_t v12 = v13 + 1;
    if (!v21)
    {
LABEL_17:
      uint64_t result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *,false>(v10, v19, a3, -v13, a5 & 1);
      size_t v11 = v19 + 1;
LABEL_19:
      a5 = 0;
      a4 = -v13;
      goto LABEL_3;
    }
  }
  int v24 = v11 + 1;
  BOOL v26 = v11 == a2 || v24 == a2;
  if (a5)
  {
    if (!v26)
    {
      uint64_t v27 = 0;
      int v28 = v11;
      do
      {
        unsigned int v30 = *v28;
        unsigned int v29 = v28[1];
        int v28 = v24;
        if (v29 < v30)
        {
          uint64_t v31 = v27;
          while (1)
          {
            *(unsigned int *)((char *)v11 + v31 + 4) = v30;
            if (!v31) {
              break;
            }
            unsigned int v30 = *(unsigned int *)((char *)v11 + v31 - 4);
            v31 -= 4;
            if (v29 >= v30)
            {
              id v32 = (unsigned int *)((char *)v11 + v31 + 4);
              goto LABEL_50;
            }
          }
          id v32 = v11;
LABEL_50:
          *id v32 = v29;
        }
        int v24 = v28 + 1;
        v27 += 4;
      }
      while (v28 + 1 != a2);
    }
  }
  else if (!v26)
  {
    do
    {
      unsigned int v34 = *v10;
      unsigned int v33 = v10[1];
      double v10 = v24;
      if (v33 < v34)
      {
        do
        {
          *int v24 = v34;
          unsigned int v34 = *(v24 - 2);
          --v24;
        }
        while (v33 < v34);
        *int v24 = v33;
      }
      int v24 = v10 + 1;
    }
    while (v10 + 1 != a2);
  }
  return result;
}

BOOL $_0::__invoke()
{
  uint64_t v2 = 0;
  int v3 = &v2;
  uint64_t v4 = 0x2020000000;
  char v5 = 0;
  CGPathApplyWithBlock2();
  BOOL v0 = *((unsigned char *)v3 + 24) == 0;
  _Block_object_dispose(&v2, 8);
  return v0;
}

void sub_2141066F0(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t RB::Path::Storage::Storage(uint64_t this, const char *a2)
{
  *(void *)this = 0;
  if ((unint64_t)a2 <= 0x3F) {
    RB::precondition_failure((RB *)"invalid capacity", a2);
  }
  int v2 = a2 - 16;
  if ((unint64_t)(a2 - 16) >= 0xFFF) {
    int v2 = 4095;
  }
  int v3 = v2 << 20;
  unsigned int v4 = atomic_fetch_add_explicit(&RB::Path::Storage::_last_identifier, 1u, memory_order_relaxed) + 1;
  *(_DWORD *)(this + 8) = v3;
  *(_DWORD *)(this + 12) = v4;
  return this;
}

uint64_t RB::Path::Storage::append_path(RB::Path::Storage *this, RBPath a2)
{
}

uint64_t *RB::Symbol::GlyphCache::ref(os_unfair_lock_s *a1, void *a2, unsigned int a3, unsigned __int8 a4)
{
  v9[0] = (uint64_t)a2;
  v9[1] = (33 * [a2 hash]) ^ a3;
  unsigned int v10 = a3;
  int v11 = a4;
  os_unfair_lock_lock(a1);
  double v7 = RB::UntypedTable::lookup((RB::UntypedTable *)&a1[12], v9, 0);
  if (!v7) {
    operator new();
  }
  ++*((_DWORD *)v7 + 7);
  os_unfair_lock_unlock(a1);
  return v7;
}

void sub_214106858(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v2, 0x10A0C40C1C8AB79);
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::UntypedTable::insert(size_t **this, size_t *a2, size_t *a3)
{
  if (!this[6]) {
    RB::UntypedTable::create_buckets((RB::UntypedTable *)this);
  }
  uint64_t v6 = ((uint64_t (*)(size_t *))*this)(a2);
  double v7 = (void *)this[6][(unint64_t)this[8] & v6];
  if (v7)
  {
    while (v7[3] != v6 || !((unsigned int (*)(void, size_t *))this[1])(v7[1], a2))
    {
      double v7 = (void *)*v7;
      if (!v7) {
        goto LABEL_7;
      }
    }
    uint64_t v14 = this[2];
    if (v14) {
      ((void (*)(void))v14)(v7[1]);
    }
    unint64_t v15 = this[3];
    if (v15) {
      ((void (*)(void))v15)(v7[2]);
    }
    uint64_t result = 0;
    v7[1] = a2;
    v7[2] = a3;
  }
  else
  {
LABEL_7:
    if ((unint64_t)this[7] + 1 > 4 << *((_DWORD *)this + 18)) {
      RB::UntypedTable::grow_buckets((RB::UntypedTable *)this);
    }
    unint64_t v8 = this[4];
    if (!v8) {
      operator new();
    }
    size_t v9 = (size_t **)this[5];
    if (v9)
    {
      this[5] = *v9;
    }
    else
    {
      size_t v9 = (size_t **)((v8[2] + 7) & 0xFFFFFFFFFFFFFFF8);
      if ((unint64_t)(v9 + 4) > v8[3]) {
        size_t v9 = (size_t **)RB::Heap::alloc_slow(v8, 0x20uLL, 7);
      }
      else {
        v8[2] = (size_t)(v9 + 4);
      }
    }
    v9[1] = a2;
    uint64_t v9[2] = a3;
    _OWORD v9[3] = (size_t *)v6;
    unsigned int v10 = this[7];
    uint64_t v11 = (unint64_t)this[8] & v6;
    uint64_t v12 = this[6];
    *size_t v9 = (size_t *)v12[v11];
    v12[v11] = (size_t)v9;
    this[7] = (size_t *)((char *)v10 + 1);
    return 1;
  }
  return result;
}

uint64_t *RB::Symbol::GlyphCache::intern_locked(RB::Symbol::GlyphCache *this, NSString *a2)
{
  unsigned int v4 = (size_t **)((char *)this + 128);
  uint64_t result = RB::UntypedTable::lookup((RB::Symbol::GlyphCache *)((char *)this + 128), (uint64_t *)a2, 0);
  if (!result)
  {
    uint64_t v6 = (size_t *)*((unsigned int *)this + 52);
    *((_DWORD *)this + 52) = v6 + 1;
    RB::UntypedTable::insert(v4, (size_t *)[(NSString *)a2 copy], v6);
    return (uint64_t *)v6;
  }
  return result;
}

uint64_t *RB::UntypedTable::lookup(RB::UntypedTable *this, uint64_t *a2, void **a3)
{
  if (*((void *)this + 7))
  {
    uint64_t v6 = (*(uint64_t (**)(uint64_t *))this)(a2);
    double v7 = *(uint64_t ***)(*((void *)this + 6) + 8 * (*((void *)this + 8) & v6));
    if (*((unsigned char *)this + 77))
    {
      if (v7)
      {
        while (v7[1] != a2)
        {
          double v7 = (uint64_t **)*v7;
          if (!v7) {
            goto LABEL_12;
          }
        }
        if (a3) {
          *a3 = a2;
        }
        return v7[2];
      }
    }
    else if (v7)
    {
      uint64_t v8 = v6;
      while (v7[3] != (uint64_t *)v8 || !(*((unsigned int (**)(uint64_t *, uint64_t *))this + 1))(v7[1], a2))
      {
        double v7 = (uint64_t **)*v7;
        if (!v7) {
          goto LABEL_12;
        }
      }
      if (a3) {
        *a3 = v7[1];
      }
      return v7[2];
    }
  }
LABEL_12:
  uint64_t result = 0;
  if (a3) {
    *a3 = 0;
  }
  return result;
}

uint64_t RB::Symbol::GlyphCache::GlyphCache(void)::$_0::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t RB::Symbol::GlyphCache::GlyphCache(void)::$_3::__invoke(void *a1, const char *a2)
{
  return [a1 isEqualToString:a2];
}

uint64_t RB::Symbol::GlyphCache::GlyphCache(void)::$_1::__invoke(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16) || *(unsigned __int8 *)(a1 + 20) != *(unsigned __int8 *)(a2 + 20)) {
    return 0;
  }
  uint64_t v2 = *(void **)a1;
  if (v2 == *(void **)a2) {
    return 1;
  }
  else {
    return objc_msgSend(v2, "isEqual:");
  }
}

uint64_t RB::RenderFrame::RenderFrame(RB::Device *,RB::Drawable *,unsigned int)::$_0::__invoke<RB::RenderFrame::RegionKey const*>(unsigned int *a1)
{
  return 33 * *a1 + a1[1];
}

unint64_t RB::pointer_hash(RB *this, const void *a2)
{
  unint64_t v2 = ((unint64_t)this + ~((void)this << 32)) ^ (((unint64_t)this + ~((void)this << 32)) >> 22);
  unint64_t v3 = 9 * ((v2 + ~(v2 << 13)) ^ ((v2 + ~(v2 << 13)) >> 8));
  unint64_t v4 = (v3 ^ (v3 >> 15)) + ~((v3 ^ (v3 >> 15)) << 27);
  return v4 ^ (v4 >> 31);
}

unint64_t RB::Device::Device(RBDevice *,objc_object  {objcproto9MTLDevice}*)::$_0::__invoke<RB::FormattedRenderState const*>(unsigned int *a1)
{
  return *a1 ^ (unint64_t)(33 * a1[2]);
}

BOOL RB::Device::Device(RBDevice *,objc_object  {objcproto9MTLDevice}*)::$_1::__invoke<RB::FormattedRenderState const*,RB::FormattedRenderState const>(_DWORD *a1, _DWORD *a2)
{
  return *a2 == *a1 && a1[1] == a2[1] && ((a2[2] ^ a1[2]) & 0xFBFFFFFF) == 0;
}

double RB::UntypedTable::create_buckets(RB::UntypedTable *this)
{
  if (!*((void *)this + 6))
  {
    *((_DWORD *)this + 18) = 4;
    *((void *)this + 8) = 15;
    unint64_t v2 = (size_t *)*((void *)this + 4);
    if (!v2) {
      operator new();
    }
    unint64_t v3 = (_OWORD *)((v2[2] + 7) & 0xFFFFFFFFFFFFFFF8);
    if ((unint64_t)(v3 + 8) > v2[3]) {
      unint64_t v3 = (_OWORD *)RB::Heap::alloc_slow(v2, 0x80uLL, 7);
    }
    else {
      v2[2] = (size_t)(v3 + 8);
    }
    *((void *)this + 6) = v3;
    double result = 0.0;
    v3[6] = 0u;
    v3[7] = 0u;
    v3[4] = 0u;
    v3[5] = 0u;
    v3[2] = 0u;
    v3[3] = 0u;
    *unint64_t v3 = 0u;
    v3[1] = 0u;
  }
  return result;
}

void RB::Symbol::Presentation::draw(uint64_t a1, RB::DisplayList::State *a2, uint64_t a3)
{
  uint64_t v73 = *MEMORY[0x263EF8340];
  unsigned int v5 = [(id)RBDrawingStateGetDisplayList((uint64_t)a2) profile];
  BOOL v6 = rb_profile_supports_porter_duff_blending(v5);
  v65[0] = 0;
  v65[1] = v65;
  v65[2] = 0x6012000000;
  v65[3] = __Block_byref_object_copy__0;
  v65[4] = __Block_byref_object_dispose__0;
  long long v66 = RBColorWhite;
  int v67 = 10;
  CFTypeRef cf = 0;
  uint64_t v9 = *(unsigned int *)(a1 + 848);
  if (v9)
  {
    BOOL v10 = v6;
    uint64_t v56 = a3;
    BOOL v55 = v6;
    do
    {
      uint64_t v11 = v9 - 1;
      if (*(void *)(a1 + 840)) {
        uint64_t v12 = *(void *)(a1 + 840);
      }
      else {
        uint64_t v12 = a1 + 8;
      }
      uint64_t v13 = v11;
      uint64_t v60 = (RB::Symbol::Model **)(v12 + 416 * v11);
      int v70 = 0;
      size_t v71 = 0;
      unint64_t v72 = 8;
      uint64_t v14 = v11;
      uint64_t v58 = v11;
      if (v10)
      {
        uint64_t v15 = v12;
        unint64_t v16 = RBDrawingStateBeginLayer(a2, 0);
        uint64_t v12 = v15;
      }
      else
      {
        uint64_t v17 = v12 + 416 * v11;
        int v18 = *(_DWORD *)(v17 + 384);
        unint64_t v16 = a2;
        if (v18)
        {
          size_t v7 = 0;
          uint64_t v19 = v17 + 16;
          uint64_t v57 = v12;
          char v20 = (uint64_t *)(v12 + 416 * v13 + 376);
          unsigned int v21 = v18 - 1;
          do
          {
            if (*v20) {
              uint64_t v22 = *v20;
            }
            else {
              uint64_t v22 = v19;
            }
            uint64_t v23 = v21;
            int v24 = (uint64_t *)(v22 + 120 * v21);
            if ((*(unsigned char *)(*v24 + 86) & 0x40) != 0)
            {
              uint64_t v25 = v22 + 120 * v21;
              float v26 = *(float *)(*v24 + 72) <= 0.0 ? *(float *)(v25 + 32) * *(float *)(v25 + 28) : *(float *)(v25 + 32);
              if (v26 > 0.0)
              {
                uint64_t v27 = a2;
                if (v7)
                {
                  int v28 = v70;
                  if (!v70) {
                    int v28 = __dst;
                  }
                  uint64_t v27 = *(RB::DisplayList::State **)&v28[8 * v7 - 8];
                }
                unsigned int v29 = RBDrawingStateInit(v27);
                LODWORD(v62.f64[0]) = *(_DWORD *)(*v24 + 68);
                HIDWORD(v62.f64[0]) = *(_DWORD *)(RB::Symbol::Model::glyph_info(*v60) + 400);
                RB::DisplayList::State::set_animation_layer((uint64_t)v29, &v62);
                uint64_t v30 = *v24;
                v31.f64[0] = RB::Symbol::Presentation::Layer::transform((float32x2_t *)(v22 + 120 * v21), a1);
                float64x2_t v62 = v31;
                long long v63 = v32;
                long long v64 = v33;
                LODWORD(v32) = 0;
                DWORD1(v32) = *(_DWORD *)(v22 + 120 * v21 + 52);
                RB::Symbol::Glyph::Layer::clip(v30, (__n128 *)v29, 1, &v62, (RB::Symbol::Presentation *)a1, v26, *(float32x2_t *)&v32);
                size_t v34 = v71;
                size_t v7 = v71 + 1;
                uint64_t v13 = v14;
                if (v72 < v71 + 1)
                {
                  RB::vector<RBDevice *,8ul,unsigned long>::reserve_slow(__dst, v7);
                  size_t v34 = v71;
                  size_t v7 = v71 + 1;
                }
                CFTypeRef v35 = v70;
                if (!v70) {
                  CFTypeRef v35 = __dst;
                }
                *(void *)&v35[8 * v34] = v29;
                size_t v71 = v7;
              }
            }
            --v21;
          }
          while (v23);
          unint64_t v16 = a2;
          a3 = v56;
          uint64_t v12 = v57;
          BOOL v10 = v55;
        }
      }
      uint64_t v36 = v12 + 416 * v13;
      if (*(void *)(v36 + 376)) {
        float v37 = *(float32x2_t **)(v36 + 376);
      }
      else {
        float v37 = (float32x2_t *)(v36 + 16);
      }
      uint64_t v38 = *(unsigned int *)(v36 + 384);
      if (v38)
      {
        uint64_t v39 = 120 * v38;
        do
        {
          float32x2_t v40 = *v37;
          if ((*(unsigned char *)(*(void *)v37 + 86) & 0x40) != 0)
          {
            float v41 = *(float *)(*(void *)&v40 + 72) <= 0.0 ? v37[4].f32[0] * v37[3].f32[1] : v37[4].f32[0];
            if (v41 > 0.0)
            {
              if (v10)
              {
                LODWORD(v62.f64[0]) = *(_DWORD *)(*(void *)&v40 + 68);
                HIDWORD(v62.f64[0]) = *(_DWORD *)(RB::Symbol::Model::glyph_info(*v60) + 400);
                RB::DisplayList::State::set_animation_layer((uint64_t)v16, &v62);
                uint64_t v42 = (uint64_t)*v37;
                v43.f64[0] = RB::Symbol::Presentation::Layer::transform(v37, a1);
                float64x2_t v62 = v43;
                long long v63 = v44;
                long long v64 = v45;
                v46.i32[0] = 0;
                v46.i32[1] = v37[6].i32[1];
                RB::Symbol::Glyph::Layer::draw(v42, (__n128 *)v16, 0x17u, &v62, (RB::Symbol::Presentation *)a1, 1.0, 1.0, 1.0, 1.0, v41, v46);
                uint64_t v13 = v14;
              }
              else
              {
                float32x2_t v47 = v70;
                if (!v70) {
                  float32x2_t v47 = __dst;
                }
                RBDrawingStateDestroy(*(RB::XML::Document **)&v47[8 * v71-- - 8], (const char *)v7, v8);
              }
            }
          }
          float v48 = (float)(v37[3].f32[0] * v37[4].f32[0]) * *(float *)(*(void *)v37 + 72);
          if (v48 > 0.0)
          {
            v61[0] = MEMORY[0x263EF8330];
            v61[1] = 3221225472;
            v61[2] = ___ZNK2RB6Symbol12Presentation4drawEP15_RBDrawingStateU13block_pointerF7RBColor13RBSymbolStyleP8NSStringE_block_invoke;
            v61[3] = &unk_2641F8660;
            v61[6] = a1;
            v61[7] = v37;
            v61[4] = a3;
            v61[5] = v65;
            uint64_t v49 = (__n128 *)v16;
            if (v71)
            {
              float v50 = v70;
              if (!v70) {
                float v50 = __dst;
              }
              uint64_t v49 = *(__n128 **)&v50[8 * v71 - 8];
            }
            LODWORD(v62.f64[0]) = *(_DWORD *)(*(void *)v37 + 68);
            HIDWORD(v62.f64[0]) = *(_DWORD *)(RB::Symbol::Model::glyph_info(*v60) + 400);
            RB::DisplayList::State::set_animation_layer((uint64_t)v49, &v62);
            uint64_t v51 = (uint64_t)*v37;
            v52.f64[0] = RB::Symbol::Presentation::Layer::transform(v37, a1);
            float64x2_t v62 = v52;
            long long v63 = v53;
            long long v64 = v54;
            LODWORD(v53) = 0;
            DWORD1(v53) = v37[6].i32[1];
            RB::Symbol::Glyph::Layer::draw(v51, v49, 0, &v62, (RB::Symbol::Presentation *)a1, (uint64_t)v61, v48, *(float32x2_t *)&v53);
            uint64_t v13 = v14;
          }
          v37 += 15;
          v39 -= 120;
        }
        while (v39);
      }
      if (v10) {
        RBDrawingStateDrawLayer((int8x16_t *)a2, v16, 0, 1.0);
      }
      uint64_t v9 = v58;
      if (v70) {
        free(v70);
      }
    }
    while (v13);
  }
  _Block_object_dispose(v65, 8);
  if (cf) {
    CFRelease(cf);
  }
}

void sub_214107268(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,CFTypeRef cf)
{
  float32x2_t v47 = *(void **)(v45 - 168);
  if (v47) {
    free(v47);
  }
  _Block_object_dispose(&a34, 8);
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(a1);
}

_RBDrawingState *RBDrawingStateInit(RB::DisplayList::State *a1)
{
  uint64_t v2 = *((void *)a1 + 1);
  if (!*(void *)(v2 + 24)) {
    make_contents(*((void *)a1 + 1));
  }
  RB::DisplayList::Builder::copy_state((RB::DisplayList::Builder *)(v2 + 16), a1);
  unsigned int v5 = v4;
  ++*(_DWORD *)(v2 + 352);
  BOOL v6 = *(RB::XML::DisplayList **)(v2 + 304);
  if (v6) {
    RB::XML::DisplayList::copy_state(v6, a1, v5, v3);
  }
  return v5;
}

double RB::DisplayList::Builder::copy_state(RB::DisplayList::Builder *this, RB::DisplayList::State *a2)
{
  unint64_t v4 = (RB::DisplayList::State *)*((void *)this + 2);
  if (v4) {
    *((void *)this + 2) = *(void *)v4;
  }
  else {
    unint64_t v4 = (RB::DisplayList::State *)malloc_type_malloc(0xB0uLL, 0x9E39E26DuLL);
  }
  return RB::DisplayList::State::State(v4, a2);
}

double RB::DisplayList::State::State(RB::DisplayList::State *this, const RB::DisplayList::State *a2)
{
  uint64_t v2 = *((void *)a2 + 1);
  *(void *)this = 0;
  *((void *)this + 1) = v2;
  long long v3 = *((_OWORD *)a2 + 1);
  long long v4 = *((_OWORD *)a2 + 3);
  *((_OWORD *)this + 2) = *((_OWORD *)a2 + 2);
  *((_OWORD *)this + 3) = v4;
  *((_OWORD *)this + 1) = v3;
  long long v5 = *((_OWORD *)a2 + 4);
  *((_DWORD *)this + 20) = *((_DWORD *)a2 + 20);
  *((_OWORD *)this + 4) = v5;
  uint64_t v6 = *((void *)a2 + 11);
  if (v6) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v6 + 8), 1u, memory_order_relaxed);
  }
  *((void *)this + 11) = v6;
  *((_OWORD *)this + 6) = *((_OWORD *)a2 + 6);
  *((_OWORD *)this + 7) = *((_OWORD *)a2 + 7);
  *((_OWORD *)this + 8) = *((_OWORD *)a2 + 8);
  double result = *((double *)a2 + 18);
  *((double *)this + 18) = result;
  *((_DWORD *)this + 38) = *((_DWORD *)a2 + 38);
  *((_WORD *)this + 78) = *((_WORD *)a2 + 78);
  *((void *)this + 20) = *((void *)a2 + 20);
  *((void *)this + 21) = *((void *)a2 + 21);
  return result;
}

atomic_uint *RBDrawingStateDestroy(RB::XML::Document *a1, const char *a2, _RBDrawingState *a3)
{
  uint64_t v3 = *((void *)a1 + 1);
  if (!*(_DWORD *)(v3 + 352)) {
    RB::precondition_failure((RB *)"invalid state delete", a2);
  }
  long long v5 = *(RB::XML::DisplayList **)(v3 + 304);
  if (v5) {
    RB::XML::DisplayList::destroy_state(v5, a1, a3);
  }
  double result = RB::DisplayList::Builder::delete_state((atomic_uint *)(v3 + 16), a1);
  --*(_DWORD *)(v3 + 352);
  return result;
}

atomic_uint *RB::DisplayList::Builder::delete_state(atomic_uint *this, const RB::DisplayList::State *a2)
{
  if (a2)
  {
    uint64_t v3 = this;
    this = (atomic_uint *)*((void *)a2 + 11);
    if (this)
    {
      if (atomic_fetch_add_explicit(this + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        this = (atomic_uint *)(*(uint64_t (**)(atomic_uint *))(*(void *)this + 8))(this);
      }
    }
    *(void *)a2 = *((void *)v3 + 2);
    *((void *)v3 + 2) = a2;
  }
  return this;
}

uint64_t make_contents(uint64_t result)
{
  if (!*(void *)(result + 24)) {
    RB::DisplayList::Builder::reset_contents((RB::DisplayList::Builder *)(result + 16));
  }
  return result;
}

uint64_t RBDrawingStateGetDisplayList(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

RB::XML::Document *RBDrawingStateClipShape2(__n128 *this, uint64_t a2, int a3, float a4)
{
  unint64_t v8 = this->n128_u64[1];
  uint64_t v9 = *(void *)(v8 + 24);
  if (!v9)
  {
    make_contents(this->n128_i64[1]);
    uint64_t v9 = *(void *)(v8 + 24);
  }
  uint64_t v10 = v9 + 16;
  RB::DisplayList::State::copy_ctm(this, (RB::Heap *)(v9 + 16));
  uint64_t v12 = v11;
  uint64_t v16 = v10;
  float v17 = a4;
  BOOL v18 = rb_clip_mode(a3);
  uint64_t v19 = v12;
  unsigned int v21 = 0;
  char v20 = *(unsigned char *)(v8 + 288);
  uint64_t v13 = -[RBShape shapeData](a2);
  RBShapeData::apply<RB::DisplayList::ClipFactory>(v13, (uint64_t)&v16, v14);
  RB::DisplayList::State::push((RB::DisplayList::State *)this, (RB::DisplayList::Builder *)(v8 + 16), v21);
  double result = *(RB::XML::Document **)(v8 + 304);
  if (result) {
    RB::XML::DisplayList::clip_shape(result);
  }
  return result;
}

uint64_t RB::DisplayList::ClipFactory::operator()<RB::Coverage::Path>(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    v5[0] = &unk_26C4E8988;
    v5[1] = a1;
    RB::Coverage::Path::simplify(a2, (uint64_t)v5);
  }
  uint64_t result = *(void *)(a1 + 32);
  if (!result)
  {
    uint64_t result = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Path>,RB::Heap&,RB::Coverage::Path const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(*(size_t **)a1, *(size_t **)a1, a2, (int *)(a1 + 8), (int *)(a1 + 12), (uint64_t *)(a1 + 16));
    *(void *)(a1 + 32) = result;
  }
  if (*(unsigned char *)(a1 + 24)) {
    *(unsigned char *)(result + 45) |= 4u;
  }
  return result;
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Path>,RB::Heap&,RB::Coverage::Path const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(size_t *a1, size_t *a2, uint64_t a3, int *a4, int *a5, uint64_t *a6)
{
  uint64_t v11 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v11 + 96 > a1[3]) {
    uint64_t v11 = RB::Heap::alloc_slow(a1, 0x60uLL, 7);
  }
  else {
    a1[2] = v11 + 96;
  }
  int v12 = *a4;
  int v13 = *a5;
  uint64_t v14 = *a6;
  *(void *)(v11 + 16) = 0;
  *(void *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(void *)(v11 + 32) = 0;
  *(_WORD *)(v11 + 44) = v13;
  *(void *)uint64_t v11 = &unk_26C4E8BE8;
  *(void *)(v11 + 48) = v14;
  *(void *)(v11 + 56) = RBPathRetain(*(void *)a3, *(void *)(a3 + 8));
  *(void *)(v11 + 64) = v15;
  uint64_t v16 = *(long long **)(a3 + 16);
  if (v16)
  {
    float v17 = (_OWORD *)((a2[2] + 15) & 0xFFFFFFFFFFFFFFF0);
    if ((unint64_t)(v17 + 3) > a2[3]) {
      float v17 = (_OWORD *)RB::Heap::alloc_slow(a2, 0x30uLL, 15);
    }
    else {
      a2[2] = (size_t)(v17 + 3);
    }
    long long v18 = *v16;
    long long v19 = v16[2];
    v17[1] = v16[1];
    v17[2] = v19;
    *float v17 = v18;
  }
  else
  {
    float v17 = 0;
  }
  *(void *)(v11 + 72) = v17;
  *(_DWORD *)(v11 + 80) = *(_DWORD *)(a3 + 24);
  *(_WORD *)(v11 + 84) = *(_WORD *)(a3 + 28);
  *(_DWORD *)(v11 + 88) = v12;
  RB::DisplayList::GenericClip<RB::Coverage::Path>::update_bounds(v11);
  return v11;
}

void sub_2141077C8(_Unwind_Exception *a1)
{
  RBPathRelease(*(void *)(v1 + 56), *(void *)(v1 + 64));
  _Unwind_Resume(a1);
}

void RB::DisplayList::GenericClip<RB::Coverage::Path>::update_bounds(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 44) == 1)
  {
    *(void *)(a1 + 16) = 0x100000001000000;
    *(int32x2_t *)(a1 + 24) = vdup_n_s32(0x7F7FFFFFu);
  }
  else if (!*(unsigned char *)(a1 + 44))
  {
    if (*(float *)(a1 + 88) == 0.0)
    {
      *(void *)(a1 + 16) = 0;
      *(void *)(a1 + 24) = 0;
    }
    else
    {
      v3.info = (void *)(a1 + 56);
      v3.callbacks = *(RBPathCallbacks **)(a1 + 48);
      *(double *)(a1 + 16) = RB::Coverage::Path::bounds(v3);
      *(void *)(a1 + 24) = v2;
    }
  }
}

uint64_t RB::DisplayList::State::push(RB::DisplayList::State *this, RB::DisplayList::Builder *a2, RB::DisplayList::Clip *a3)
{
  uint64_t v9 = a3;
  if (!*((unsigned char *)a2 + 272)) {
    goto LABEL_4;
  }
  uint64_t result = RB::DisplayList::ClipNode::elide_append((uint64_t *)this + 12, (float32x2_t *)a3);
  if (result) {
    return result;
  }
  if (!*((unsigned char *)a2 + 272))
  {
LABEL_4:
    *((void *)a3 + 4) = RB::DisplayList::State::copy_metadata(this, *((RB::DisplayList::Contents **)a2 + 1));
    *((_DWORD *)a3 + 10) = *((_DWORD *)this + 16);
  }
  uint64_t result = RB::Heap::emplace<RB::DisplayList::ClipNode,RB::DisplayList::Clip const*&,RB::DisplayList::ClipNode*&>((size_t *)(*((void *)a2 + 1) + 16), &v9, (const RB::DisplayList::ClipNode **)this + 12);
  *((void *)this + 12) = result;
  *((_DWORD *)this + 37) = -1;
  uint64_t v7 = *((void *)a2 + 1);
  unint64_t v8 = v9;
  *((void *)v9 + 1) = *(void *)(v7 + 312);
  *(void *)(v7 + 312) = v8;
  return result;
}

uint64_t RB::Heap::emplace<RB::DisplayList::ClipNode,RB::DisplayList::Clip const*&,RB::DisplayList::ClipNode*&>(size_t *a1, const RB::DisplayList::Clip **a2, const RB::DisplayList::ClipNode **a3)
{
  long long v5 = (RB::DisplayList::ClipNode *)((a1[2] + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)v5 + 32 > a1[3]) {
    long long v5 = (RB::DisplayList::ClipNode *)RB::Heap::alloc_slow(a1, 0x20uLL, 7);
  }
  else {
    a1[2] = (size_t)v5 + 32;
  }
  uint64_t v6 = *a2;
  uint64_t v7 = *a3;
  return RB::DisplayList::ClipNode::ClipNode(v5, v6, v7);
}

float32x2_t *RB::DisplayList::ClipNode::ClipNode(float32x2_t *a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6, double a7, double a8, int32x4_t a9)
{
  *a1 = (float32x2_t)a3;
  a1[1] = (float32x2_t)a2;
  *(_OWORD *)a1[2].f32 = *(_OWORD *)(a2 + 16);
  if (*(unsigned char *)(a2 + 45))
  {
    a2 |= 1uLL;
    a1[1] = (float32x2_t)a2;
  }
  if (a3)
  {
    uint64_t v10 = a1 + 2;
    if ((*(unsigned char *)(a3 + 8) & 1) == 0) {
      a1[1] = (float32x2_t)(a2 & 0xFFFFFFFFFFFFFFFELL);
    }
    RB::Rect::intersect(v10, *(double *)(a3 + 16), *(float32x2_t *)(a3 + 24), a6, a7, a8, a9);
  }
  return a1;
}

uint64_t RBShapeData::apply<RB::DisplayList::ClipFactory>(uint64_t result, uint64_t a2, int8x16_t a3)
{
  switch(*(_DWORD *)result)
  {
    case 1:
      uint64_t result = RB::DisplayList::ClipFactory::operator()<RB::Coverage::Primitive>(a2, (_OWORD *)(result + 16), a3);
      break;
    case 2:
      uint64_t result = RB::DisplayList::ClipFactory::operator()<RB::Coverage::Path>(a2, result + 16);
      break;
    case 3:
      uint64_t result = RB::DisplayList::ClipFactory::operator()<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(a2, result + 16);
      break;
    case 4:
      uint64_t result = RB::DisplayList::ClipFactory::operator()<RB::Coverage::Glyphs>(a2, (RB::Coverage::Glyphs *)(result + 16));
      break;
    case 5:
      uint64_t result = RB::DisplayList::ClipFactory::operator()<RB::Coverage::Stroke<RBStrokeRef>>(a2, result + 16);
      break;
    default:
      return result;
  }
  return result;
}

RB::XML::Document *RB::Symbol::Glyph::Layer::clip(uint64_t a1, __n128 *a2, int a3, float64x2_t *a4, RB::Symbol::Presentation *this, float a6, float32x2_t a7)
{
  if ((*(_DWORD *)(a1 + 84) & 0xC0000) == 0x40000)
  {
    uint64_t v14 = (void *)RB::Symbol::Presentation::shape(this);
    RB::Symbol::Glyph::Layer::set_shape(a1, v14, a4, a7);
    return RBDrawingStateClipShape2(a2, (uint64_t)v14, a3, a6);
  }
  else
  {
    uint64_t v16 = RBDrawingStateBeginLayer((RB::DisplayList::State *)a2, 0);
    float v17 = (_RBDrawingState *)v16;
    unsigned int v18 = (*(_DWORD *)(a1 + 84) >> 18) & 3;
    if (v18 >= 2)
    {
      if (v18 == 3)
      {
        float v19 = *(float *)(a1 + 60);
        if (v19 == 0.0)
        {
          double v20 = *(float *)(a1 + 56);
          float64x2_t v21 = vmulq_n_f64(*a4, v20);
          float64x2_t v22 = vmulq_n_f64(a4[1], v20);
          float64x2_t v23 = a4[2];
        }
        else
        {
          float64x2_t v30 = a4[1];
          float64x2_t v23 = vmlaq_f64(vmlaq_n_f64(a4[2], *a4, v19), (float64x2_t)0, v30);
          float v31 = *(float *)(a1 + 56);
          double v32 = v31;
          float64x2_t v21 = vmulq_n_f64(*a4, (float)-v31);
          float64x2_t v22 = vmulq_n_f64(v30, v32);
        }
        v37[0] = v21;
        v37[1] = v22;
        v37[2] = v23;
        RBDrawingStateConcatCTM((uint64_t)v16, (uint64_t)v37);
        RBDrawingStateDrawDisplayList((uint64_t)v17, *(void **)a1, v33);
      }
      else
      {
        int v24 = *(RB::Symbol::Glyph::Sublayers **)a1;
        float v25 = *(float *)(a1 + 60);
        if (v25 == 0.0)
        {
          double v26 = *(float *)(a1 + 56);
          float64x2_t v27 = vmulq_n_f64(*a4, v26);
          float64x2_t v28 = vmulq_n_f64(a4[1], v26);
          float64x2_t v29 = a4[2];
        }
        else
        {
          float64x2_t v34 = a4[1];
          float64x2_t v29 = vmlaq_f64(vmlaq_n_f64(a4[2], *a4, v25), (float64x2_t)0, v34);
          float v35 = *(float *)(a1 + 56);
          double v36 = v35;
          float64x2_t v27 = vmulq_n_f64(*a4, (float)-v35);
          float64x2_t v28 = vmulq_n_f64(v34, v36);
        }
        v38[0] = v27;
        v38[1] = v28;
        v38[2] = v29;
        RB::Symbol::Glyph::Sublayers::draw_layers(v24, v17, (const RB::AffineTransform *)v38, this);
      }
    }
    return (RB::XML::Document *)RBDrawingStateClipLayer(a2, (RB::DisplayList::State *)v17, a3, a6);
  }
}

BOOL rb_profile_supports_porter_duff_blending(unsigned int a1)
{
  return a1 > 3 || (a1 & 0xF) == 2;
}

void *RB::vector<RB::Symbol::Glyph::Layer,3ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  if (*((_DWORD *)__dst + 69) + (*((_DWORD *)__dst + 69) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *((_DWORD *)__dst + 69) + (*((_DWORD *)__dst + 69) >> 1);
  }
  uint64_t result = RB::details::realloc_vector<unsigned int,88ul>(*((void **)__dst + 33), __dst, 3u, (_DWORD *)__dst + 69, v3);
  *((void *)__dst + 33) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,88ul>(void *__src, void *__dst, unsigned int a3, _DWORD *a4, unsigned int a5)
{
  uint64_t v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      LODWORD(v9) = a3;
      memcpy(__dst, __src, 88 * a5);
      free(v7);
      int v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(88 * a5);
    unint64_t v9 = v8 / 0x58;
    if (*a4 != (v8 / 0x58))
    {
      uint64_t v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10) {
        RB::precondition_failure((RB *)"allocation failure", v11);
      }
      int v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, 88 * *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

BOOL RB::RenderFrame::RenderFrame(RB::Device *,RB::Drawable *,unsigned int)::$_1::__invoke<RB::RenderFrame::RegionKey const*,RB::RenderFrame::RegionKey const*>(void *a1, void *a2)
{
  return *a1 == *a2;
}

uint64_t RB::Symbol::Glyph::copied_glyph(RB::Symbol::Glyph *this)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 408);
  os_unfair_lock_lock((os_unfair_lock_t)this + 102);
  uint64_t v3 = *((void *)this + 52);
  if (!v3)
  {
    long long v4 = (void *)[*(id *)this copy];

    *((void *)this + 52) = v4;
    [v4 setVariableMinValue:INFINITY];
    [*((id *)this + 52) setVariableMaxValue:INFINITY];
    uint64_t v3 = *((void *)this + 52);
  }
  os_unfair_lock_unlock(v2);
  return v3;
}

void sub_214107E24(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

RB::Symbol::GlyphCache *RB::Symbol::GlyphCache::GlyphCache(RB::Symbol::GlyphCache *this)
{
  *(_DWORD *)this = 0;
  uint64_t v2 = (char *)this + 48;
  uint64_t v3 = (RB::Symbol::GlyphCache *)((char *)this + 8);
  RB::Heap::Heap((RB::Symbol::GlyphCache *)((char *)this + 8), 0, 0, 0);
  RB::UntypedTable::UntypedTable((uint64_t)v2, (unint64_t (*)(RB *, const void *))RB::Symbol::GlyphCache::GlyphCache(void)::$_0::__invoke, (BOOL (*)(RB *, RB *, const void *))RB::Symbol::GlyphCache::GlyphCache(void)::$_1::__invoke, 0, 0, v3);
  RB::UntypedTable::UntypedTable((uint64_t)this + 128, (unint64_t (*)(RB *, const void *))RB::Symbol::GlyphCache::GlyphCache(void)::$_2::__invoke, (BOOL (*)(RB *, RB *, const void *))RB::Symbol::GlyphCache::GlyphCache(void)::$_3::__invoke, (void (*)(void *))RB::Symbol::GlyphCache::GlyphCache(void)::$_4::__invoke, 0, v3);
  *((_DWORD *)this + 52) = 32;
  RB::UntypedTable::insert((size_t **)this + 16, (size_t *)@"_slash", (size_t *)1);
  RB::UntypedTable::insert((size_t **)this + 16, (size_t *)@"_badge", (size_t *)2);
  return this;
}

void sub_214107F3C(_Unwind_Exception *a1)
{
  RB::UntypedTable::~UntypedTable(v3);
  RB::UntypedTable::~UntypedTable(v2);
  RB::Heap::~Heap(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(unsigned int *a1, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3 = *a2;
  unsigned int v4 = *a1;
  unsigned int v5 = *a3;
  if (*a2 < *a1)
  {
    if (v5 < v3)
    {
      *a1 = v5;
      *a3 = v4;
      return 1;
    }
    *a1 = v3;
    *a2 = v4;
    if (*a3 >= v4) {
      return 1;
    }
    *a2 = *a3;
    *a3 = v4;
    return 2;
  }
  if (v5 < v3)
  {
    *a2 = v5;
    *a3 = v3;
    unsigned int v6 = *a1;
    if (*a2 >= *a1) {
      return 1;
    }
    *a1 = *a2;
    *a2 = v6;
    return 2;
  }
  return 0;
}

int8x8_t RB::Symbol::Glyph::Layer::content_bounds(float32x2_t **this, double a2, double a3, double a4, int32x4_t a5)
{
  int v6 = (*((_DWORD *)this + 21) >> 18) & 3;
  if (v6 == 3)
  {
    [(float32x2_t *)*this boundingRect];
    v15.f64[1] = v14;
    float32x2_t v7 = vcvt_f32_f64(v15);
  }
  else if (v6 == 2)
  {
    float32x2_t v7 = (*this)[35];
  }
  else
  {
    float32x2_t v7 = 0;
    if (v6 == 1)
    {
      v19.info = (void *)**this;
      v19.callbacks = (RBPathCallbacks *)(*this)[1];
      v8.f64[0] = RBPathGetBoundingRect(v19);
      v8.f64[1] = v9;
      float32x2_t v7 = vcvt_f32_f64(v8);
      *(void *)&v11.f64[1] = a5.i64[0];
      float32x2_t v10 = vcvt_f32_f64(v11);
      LODWORD(v11.f64[0]) = *((_DWORD *)this + 19);
      if (*(float *)v11.f64 > 0.0)
      {
        float v12 = *(float *)v11.f64 * 0.70711;
        *(float *)v11.f64 = *(float *)v11.f64 * 5.0;
        if ((*((unsigned char *)this + 86) & 3) != 0 || v12 >= *(float *)v11.f64) {
          *(float *)v11.f64 = v12;
        }
        *(float *)v11.f64 = *(float *)v11.f64 / *((float *)this + 14);
        *(int32x2_t *)a5.i8 = vcgt_f32((float32x2_t)vdup_n_s32(0x7F7FFFFFu), v10);
        a5.i64[0] = vcltzq_s32(a5).u64[0];
        float32x2_t v7 = (float32x2_t)vbsl_s8(*(int8x8_t *)a5.i8, (int8x8_t)vsub_f32(v7, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v11.f64[0], 0)), (int8x8_t)v7);
      }
    }
  }
  a5.i32[0] = *((_DWORD *)this + 15);
  int8x8_t v16 = (int8x8_t)vmul_n_f32(v7, *((float *)this + 14));
  v17.i32[1] = v16.i32[1];
  *(float *)v17.i32 = *(float *)a5.i32 - *(float *)v16.i32;
  return vbsl_s8((int8x8_t)vdup_lane_s32((int32x2_t)vmvn_s8((int8x8_t)vceq_f32(*(float32x2_t *)a5.i8, 0)), 0), v17, v16);
}

void std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *,false>(int *a1, char *a2, uint64_t a3, uint64_t a4, char a5)
{
LABEL_1:
  float64x2_t v11 = a1;
LABEL_2:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    a1 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = a2 - (char *)v11;
    unint64_t v15 = (a2 - (char *)v11) >> 3;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          if (std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a3, (uint64_t)(a2 - 8), (uint64_t)v11))
          {
            int v23 = *v11;
            *float64x2_t v11 = *((_DWORD *)a2 - 2);
            *((_DWORD *)a2 - 2) = v23;
            int v24 = v11[1];
            v11[1] = *((_DWORD *)a2 - 1);
            *((_DWORD *)a2 - 1) = v24;
          }
          break;
        case 3uLL:
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(v11, v11 + 2, (int *)a2 - 2, a3);
          break;
        case 4uLL:
          std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(v11, v11 + 2, v11 + 4, (int *)a2 - 2, a3);
          break;
        case 5uLL:
          std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(v11, v11 + 2, v11 + 4, v11 + 6, (int *)a2 - 2, a3);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v14 <= 191) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != (int *)a2)
      {
        std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *,std::pair<float,unsigned int> *>((char *)v11, a2, a2, a3);
      }
      return;
    }
    unint64_t v16 = v15 >> 1;
    int8x8_t v17 = &v11[2 * (v15 >> 1)];
    if ((unint64_t)v14 >= 0x401)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(v11, &v11[2 * (v15 >> 1)], (int *)a2 - 2, a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(v11 + 2, v17 - 2, (int *)a2 - 4, a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(v11 + 4, &v11[2 * v16 + 2], (int *)a2 - 6, a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(v17 - 2, v17, &v11[2 * v16 + 2], a3);
      int v18 = *v11;
      *float64x2_t v11 = *v17;
      *int8x8_t v17 = v18;
      int v19 = v11[1];
      v11[1] = v17[1];
      v17[1] = v19;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(&v11[2 * (v15 >> 1)], v11, (int *)a2 - 2, a3);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (!std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a3, (uint64_t)(v11 - 2), (uint64_t)v11))
    {
      float64x2_t v11 = (int *)std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,std::pair<float,unsigned int> *,std::__less<void,void> &>((unint64_t)v11, (float *)a2);
      goto LABEL_18;
    }
LABEL_13:
    double v20 = (int *)std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,std::pair<float,unsigned int> *,std::__less<void,void> &>((uint64_t)v11, (float *)a2);
    if ((v21 & 1) == 0) {
      goto LABEL_16;
    }
    BOOL v22 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(v11, v20, a3);
    float64x2_t v11 = v20 + 2;
    if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(v20 + 2, (int *)a2, a3))
    {
      a4 = -v13;
      a2 = (char *)v20;
      if (v22) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v12 = v13 + 1;
    if (!v22)
    {
LABEL_16:
      std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *,false>(a1, v20, a3, -v13, a5 & 1);
      float64x2_t v11 = v20 + 2;
LABEL_18:
      a5 = 0;
      a4 = -v13;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>((uint64_t)v11, (float *)a2, a3);
  }
  else
  {
    std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>((uint64_t)v11, (float *)a2, a3);
  }
}

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(int *a1, int *a2, int *a3, uint64_t a4)
{
  BOOL v8 = std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a4, (uint64_t)a2, (uint64_t)a1);
  uint64_t result = std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a4, (uint64_t)a3, (uint64_t)a2);
  if (v8)
  {
    int v10 = *a1;
    if (result)
    {
      *a1 = *a3;
      *a3 = v10;
      float64x2_t v11 = a3 + 1;
      uint64_t result = 1;
      uint64_t v12 = a1 + 1;
LABEL_9:
      unint64_t v15 = v11;
      goto LABEL_10;
    }
    *a1 = *a2;
    *a2 = v10;
    int v17 = a1[1];
    a1[1] = a2[1];
    a2[1] = v17;
    if (std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a4, (uint64_t)a3, (uint64_t)a2))
    {
      int v18 = *a2;
      *a2 = *a3;
      *a3 = v18;
      float64x2_t v11 = a3 + 1;
      uint64_t result = 2;
      uint64_t v12 = a2 + 1;
      goto LABEL_9;
    }
  }
  else
  {
    if (!result) {
      return result;
    }
    int v13 = *a2;
    *a2 = *a3;
    *a3 = v13;
    unint64_t v15 = a2 + 1;
    int v14 = a2[1];
    a2[1] = a3[1];
    a3[1] = v14;
    if (std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a4, (uint64_t)a2, (uint64_t)a1))
    {
      int v16 = *a1;
      *a1 = *a2;
      uint64_t v12 = a1 + 1;
      *a2 = v16;
      uint64_t result = 2;
LABEL_10:
      int v19 = *v12;
      *uint64_t v12 = *v15;
      *unint64_t v15 = v19;
      return result;
    }
  }
  return 1;
}

uint64_t RB::Symbol::Animator::set_variable_value(os_unfair_lock_s *this, float a2)
{
  os_unfair_lock_lock(this);
  if (*(float *)&this[14]._os_unfair_lock_opaque == a2
    || (unsigned int v4 = *(RB::Symbol::Model **)&this[2]._os_unfair_lock_opaque,
        *(float *)&this[14]._os_unfair_lock_opaque = a2,
        int v5 = RB::Symbol::Model::glyph_value_index(v4, a2),
        *(_DWORD *)(*(void *)&this[2]._os_unfair_lock_opaque + 80) == v5))
  {
    uint64_t v6 = 0;
  }
  else
  {
    RB::Symbol::Model::copy_on_write((uint64_t)&this[2]);
    *(_DWORD *)(*(void *)&this[2]._os_unfair_lock_opaque + 80) = v5;
    ++this[15]._os_unfair_lock_opaque;
    uint64_t v6 = 1;
  }
  os_unfair_lock_unlock(this);
  return v6;
}

void sub_21410871C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t RBSymbolUpdateTemplateImage(uint64_t a1, void *a2, float *a3)
{
  RB::Symbol::Presentation::template_image(a1, (uint64_t)v6);
  uint64_t result = v6[0];
  if (v6[0])
  {
    if (a2) {
      *a2 = v6[1];
    }
    if (a3)
    {
      *a3 = v7;
    }
    else if (v7 != 1.0)
    {
      return 0;
    }
  }
  return result;
}

uint64_t RBDrawingStateGetIdentifierNamespace2(uint64_t a1)
{
  uint64_t v4 = *MEMORY[0x263EF8340];
  *(_OWORD *)uint64_t v2 = *(_OWORD *)(a1 + 68);
  uuid_copy(dst, v2);
  return *(void *)dst;
}

double RBColorFromLinear(int8x16_t a1, float a2, float a3)
{
  int8x16_t v8 = a1;
  if (*(float *)a1.i32 <= 0.0) {
    *(float *)a1.i32 = -*(float *)a1.i32;
  }
  if (*(float *)a1.i32 <= 0.0031308) {
    *(float *)a1.i32 = *(float *)a1.i32 * 12.92;
  }
  else {
    *(float *)a1.i32 = (float)(powf(*(float *)a1.i32, 0.41667) * 1.055) + -0.055;
  }
  int8x16_t v7 = a1;
  float v3 = -a2;
  if (a2 > 0.0) {
    float v3 = a2;
  }
  if (v3 > 0.0031308) {
    powf(v3, 0.41667);
  }
  float v4 = -a3;
  if (a3 > 0.0) {
    float v4 = a3;
  }
  if (v4 > 0.0031308) {
    powf(v4, 0.41667);
  }
  v5.i64[0] = 0x8000000080000000;
  v5.i64[1] = 0x8000000080000000;
  *(void *)&double result = vbslq_s8(v5, v7, v8).u64[0];
  return result;
}

void anonymous namespace'::make_wrapped_path<RBPathCopyTransformedPath::TransformArgs>(RBPath,RBPathCopyTransformedPath::TransformArgs &&)::Info::~Info(void *a1)
{
  *a1 = &unk_26C4EE5B0;
  uint64_t v1 = *(void (**)(void))(a1[3] + 16);
  if (v1) {
    v1(a1[2]);
  }
  JUMPOUT(0x21669AC10);
}

BOOL RB::Symbol::Animator::set_rendering_mode(uint64_t a1, int a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)a1);
  int v4 = *(unsigned __int8 *)(*(void *)(a1 + 8) + 88);
  if (v4 != a2)
  {
    RB::Symbol::Model::copy_on_write(a1 + 8);
    RB::Symbol::Model::set_rendering_mode(*(void *)(a1 + 8), a2, *(float *)(a1 + 56));
    ++*(_DWORD *)(a1 + 60);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
  return v4 != a2;
}

void sub_214108A70(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::Symbol::Model::set_rendering_mode(uint64_t result, int a2, float a3)
{
  int v3 = *(unsigned __int16 *)(result + 88);
  int v4 = v3 | (*(unsigned __int8 *)(result + 90) << 16);
  if (a2 != v3)
  {
    uint64_t v6 = (RB::Symbol::Model *)result;
    *(unsigned char *)(result + 90) = BYTE2(v4);
    *(_WORD *)(result + 88) = v4 & 0xFF00 | a2;
    ++*(_DWORD *)(result + 84);
    std::unique_ptr<RB::Symbol::Glyph const,RB::Symbol::GlyphCache::Unref>::reset[abi:nn180100]((RB::Symbol::GlyphCache *)(result + 96), 0);
    double result = RB::Symbol::Model::glyph_value_index(v6, a3);
    *((_DWORD *)v6 + 20) = result;
  }
  return result;
}

BOOL RB::Symbol::Animator::set_size(uint64_t a1, float32x2_t a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)a1);
  uint32x2_t v4 = (uint32x2_t)vceq_f32(*(float32x2_t *)(*(void *)(a1 + 8) + 56), a2);
  signed __int32 v5 = vpmin_u32(v4, v4).u32[0];
  if ((v5 & 0x80000000) == 0)
  {
    RB::Symbol::Model::copy_on_write(a1 + 8);
    *(double *)(*(void *)(a1 + 8) + 56) = *(double *)&a2;
    ++*(_DWORD *)(a1 + 60);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
  return v5 >= 0;
}

void sub_214108BC4(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

BOOL RB::Symbol::Animator::set_position(uint64_t a1, float32x2_t a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)a1);
  uint32x2_t v4 = (uint32x2_t)vceq_f32(*(float32x2_t *)(*(void *)(a1 + 8) + 48), a2);
  signed __int32 v5 = vpmin_u32(v4, v4).u32[0];
  if ((v5 & 0x80000000) == 0)
  {
    RB::Symbol::Model::copy_on_write(a1 + 8);
    *(double *)(*(void *)(a1 + 8) + 48) = *(double *)&a2;
    ++*(_DWORD *)(a1 + 60);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
  return v5 >= 0;
}

void sub_214108CA0(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

BOOL RB::Symbol::Animator::set_anchor_point(uint64_t a1, float32x2_t a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)a1);
  uint32x2_t v4 = (uint32x2_t)vceq_f32(*(float32x2_t *)(*(void *)(a1 + 8) + 40), a2);
  signed __int32 v5 = vpmin_u32(v4, v4).u32[0];
  if ((v5 & 0x80000000) == 0)
  {
    RB::Symbol::Model::copy_on_write(a1 + 8);
    *(double *)(*(void *)(a1 + 8) + 40) = *(double *)&a2;
    ++*(_DWORD *)(a1 + 60);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
  return v5 >= 0;
}

void sub_214108D7C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

BOOL RB::Symbol::Animator::set_glyph(RB::Symbol::Animator *this, CUINamedVectorGlyph *a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)this);
  uint32x2_t v4 = *(CUINamedVectorGlyph **)(*((void *)this + 1) + 16);
  if (v4 != a2)
  {
    RB::Symbol::Model::copy_on_write((uint64_t)this + 8);
    RB::Symbol::Model::set_glyph(*((RB::Symbol::Model **)this + 1), a2, *((float *)this + 14));
    ++*((_DWORD *)this + 15);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this);
  return v4 != a2;
}

void sub_214108E58(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::Symbol::Model::copy_on_write(uint64_t result)
{
  if (*(_DWORD *)(*(void *)result + 8) != 1) {
    operator new();
  }
  __dmb(9u);
  return result;
}

void sub_214108F28(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10E1C403E811B8FLL);
  _Unwind_Resume(a1);
}

CUINamedVectorGlyph *RB::Symbol::Model::set_glyph(RB::Symbol::Model *this, CUINamedVectorGlyph *a2, float a3)
{
  double result = (CUINamedVectorGlyph *)*((void *)this + 2);
  if (result != a2)
  {

    *((void *)this + 2) = a2;
    ++*((_DWORD *)this + 21);
    std::unique_ptr<RB::Symbol::Glyph const,RB::Symbol::GlyphCache::Unref>::reset[abi:nn180100]((RB::Symbol::Model *)((char *)this + 96), 0);
    double result = (CUINamedVectorGlyph *)RB::Symbol::Model::glyph_value_index(this, a3);
    *((_DWORD *)this + 20) = result;
  }
  return result;
}

uint64_t RB::Symbol::Model::glyph_value_index(RB::Symbol::Model *this, float a2)
{
  if ((LODWORD(a2) & 0x7FFFFFFFu) > 0x7F7FFFFF) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = RB::Symbol::Model::glyph_info(this);
  uint64_t v4 = *(void *)(v3 + 376);
  if (!v4) {
    uint64_t v4 = v3 + 112;
  }
  unsigned int v5 = *(_DWORD *)(v3 + 384);
  if (!v5) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v7 = 88 * v5;
  int8x16_t v8 = (unsigned int *)(v4 + 80);
  do
  {
    unsigned int v9 = *v8;
    if (*v8 != -1 && v9 > result)
    {
      float v11 = *((float *)v8 - 4);
      if ((LODWORD(v11) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
      {
        BOOL v12 = v11 > a2;
        if (v11 <= 0.0) {
          BOOL v12 = v11 >= a2;
        }
        if (v12) {
          uint64_t result = result;
        }
        else {
          uint64_t result = v9;
        }
      }
    }
    v8 += 22;
    v7 -= 88;
  }
  while (v7);
  return result;
}

void RB::Symbol::Model::~Model(RB::Symbol::Model *this)
{
  *(void *)this = &unk_26C4EDC98;
  std::unique_ptr<RB::Symbol::Glyph const,RB::Symbol::GlyphCache::Unref>::reset[abi:nn180100]((RB::Symbol::Model *)((char *)this + 96), 0);
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2) {
    free(v2);
  }

  JUMPOUT(0x21669AC10);
}

{
  void *v2;

  *(void *)this = &unk_26C4EDC98;
  std::unique_ptr<RB::Symbol::Glyph const,RB::Symbol::GlyphCache::Unref>::reset[abi:nn180100]((RB::Symbol::Model *)((char *)this + 96), 0);
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2) {
    free(v2);
  }
}

void RB::Symbol::GlyphCache::unref(os_unfair_lock_s *this, const RB::Symbol::Glyph *a2)
{
  os_unfair_lock_lock(this);
  int v4 = *((_DWORD *)a2 + 7) - 1;
  *((_DWORD *)a2 + 7) = v4;
  if (!v4)
  {
    RB::UntypedTable::remove_ptr((RB::UntypedTable *)&this[12], a2);
    os_unfair_lock_unlock(this);
    RB::Symbol::Glyph::~Glyph((id *)a2);
    JUMPOUT(0x21669AC10);
  }
  os_unfair_lock_unlock(this);
}

void sub_214109190(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void RB::Symbol::Glyph::~Glyph(id *this)
{
  id v2 = this[47];
  if (v2) {
    uint64_t v3 = (RB::Symbol::Glyph::Layer *)this[47];
  }
  else {
    uint64_t v3 = (RB::Symbol::Glyph::Layer *)(this + 14);
  }
  if (*((_DWORD *)this + 96))
  {
    unint64_t v4 = 0;
    do
    {
      RB::Symbol::Glyph::Layer::~Layer(v3);
      ++v4;
      uint64_t v3 = (RB::Symbol::Glyph::Layer *)(v5 + 88);
    }
    while (v4 < *((unsigned int *)this + 96));
    id v2 = this[47];
  }
  if (v2) {
    free(v2);
  }
}

void sub_21410921C(_Unwind_Exception *a1)
{
  RB::vector<RB::Symbol::Glyph::Layer,3ul,unsigned int>::~vector((RB::Symbol::Glyph::Layer *)(v1 + 112));
  _Unwind_Resume(a1);
}

void RB::Symbol::Glyph::Layer::~Layer(RB::Symbol::Glyph::Layer *this)
{
  int v2 = (*((_DWORD *)this + 21) >> 18) & 3;
  switch(v2)
  {
    case 3:

      break;
    case 2:
      std::unique_ptr<RB::Symbol::Glyph::Sublayers>::reset[abi:nn180100]((uint64_t *)this, 0);
      break;
    case 1:
      uint64_t v3 = *(uint64_t **)this;
      *(void *)this = 0;
      if (v3) {
        std::default_delete<RB::Symbol::Glyph::Shape>::operator()[abi:nn180100]((uint64_t)this, v3);
      }
      break;
  }
  unint64_t v4 = (void *)*((void *)this + 5);
  if (v4) {
    free(v4);
  }
  uint64_t v5 = (const void *)*((void *)this + 2);
  if (v5) {
    CFRelease(v5);
  }
}

void std::default_delete<RB::Symbol::Glyph::Shape>::operator()[abi:nn180100](uint64_t a1, uint64_t *a2)
{
  if (a2)
  {
    uint64_t v3 = (void *)a2[2];
    if (v3) {
      free(v3);
    }
    RBPathRelease(*a2, a2[1]);
    JUMPOUT(0x21669AC10);
  }
}

uint64_t RB::Refcount<RB::Path::Object,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

void RB::Path::Object::~Object(RB::Path::Object *this)
{
  *(void *)this = &unk_26C4EDA30;
  RB::Path::Storage::~Storage((RB::Path::Object *)((char *)this + 16));
  JUMPOUT(0x21669AC10);
}

{
  *(void *)this = &unk_26C4EDA30;
  RB::Path::Storage::~Storage((RB::Path::Object *)((char *)this + 16));
}

uint64_t RB::UntypedTable::remove_ptr(RB::UntypedTable *this, void *a2)
{
  if (*((void *)this + 7))
  {
    unint64_t v4 = (void *)(*((void *)this + 6) + 8 * (*((void *)this + 8) & (*(uint64_t (**)(void *))this)(a2)));
    while (1)
    {
      uint64_t v5 = v4;
      unint64_t v4 = (void *)*v4;
      if (!v4) {
        break;
      }
      if ((void *)v4[1] == a2)
      {
        *uint64_t v5 = *v4;
        uint64_t v6 = (void (*)(void))*((void *)this + 2);
        if (v6) {
          v6(v4[1]);
        }
        uint64_t v7 = (void (*)(void))*((void *)this + 3);
        if (v7) {
          v7(v4[2]);
        }
        *unint64_t v4 = *((void *)this + 5);
        *((void *)this + 5) = v4;
        --*((void *)this + 7);
        return 1;
      }
    }
  }
  return 0;
}

float RB::Symbol::Animator::variable_value(os_unfair_lock_s *this)
{
  os_unfair_lock_lock(this);
  float v2 = *(float *)&this[14]._os_unfair_lock_opaque;
  os_unfair_lock_unlock(this);
  return v2;
}

void sub_21410974C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  float v11 = RB::vector<std::pair<RB::objc_ptr<RBSymbolAnimator *>,RB::objc_ptr<objc_object  {objcproto24RBSymbolAnimatorObserver}*>>,4ul,unsigned long>::~vector(v9);
  MEMORY[0x21669AC10](v11, 0x1020C40894D135BLL);
  RB::vector<std::pair<RB::objc_ptr<RBSymbolAnimator *>,RB::objc_ptr<objc_object  {objcproto24RBSymbolAnimatorObserver}*>>,4ul,unsigned long>::~vector(&a9);
  _Unwind_Resume(a1);
}

float32x2_t RB::DisplayList::LayerItem::bounds(RB::DisplayList::LayerItem *this)
{
  if (*((void *)this + 6) && RB::may_discard_alpha(*((_WORD *)this + 23) & 0x3F))
  {
    unint64_t v4 = (RB::DisplayList::Layer *)*((void *)this + 6);
    return RB::DisplayList::Layer::bounds(v4, v2, v3);
  }
  else
  {
    return (float32x2_t)0xFEFFFFFFFEFFFFFFLL;
  }
}

uint64_t RB::may_discard_alpha(unsigned int a1)
{
  return (a1 > 0x17) | (0x6FD64u >> a1) & 1;
}

uint64_t RB::Refcount<RB::Symbol::Model,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t RB::Symbol::Presentation::style_mask(RB::Symbol::Presentation *this)
{
  uint64_t v1 = (char *)this + 8;
  if (*((void *)this + 105)) {
    uint64_t v1 = (char *)*((void *)this + 105);
  }
  int v2 = *((_DWORD *)this + 212);
  if (!v2) {
    return 0;
  }
  uint64_t result = 0;
  unint64_t v4 = &v1[416 * v2];
  do
  {
    uint64_t v5 = (float *)(v1 + 16);
    if (*((void *)v1 + 47)) {
      uint64_t v5 = (float *)*((void *)v1 + 47);
    }
    int v6 = *((_DWORD *)v1 + 96);
    if (v6)
    {
      uint64_t v7 = &v5[30 * v6];
      do
      {
        if ((float)((float)(v5[6] * v5[8]) * *(float *)(*(void *)v5 + 72)) > 0.0 && v5[5] == -32768.0) {
          uint64_t result = (1 << (BYTE1(*(_DWORD *)(*(void *)v5 + 84)) & 0xF)) | result;
        }
        v5 += 30;
      }
      while (v5 != v7);
    }
    v1 += 416;
  }
  while (v1 != v4);
  return result;
}

double RBDrawingStateSetIdentifier2(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  *(void *)uu = a3;
  uint64_t v11 = a4;
  uuid_clear((unsigned __int8 *)&v9);
  int v8 = a2;
  if (uuid_is_null(uu)) {
    long long v9 = *(_OWORD *)(a1 + 68);
  }
  else {
    uuid_copy((unsigned __int8 *)&v9, uu);
  }
}

double anonymous namespace'::set_identity(_anonymous_namespace_ *this, _RBDrawingState *a2, const RB::Identity *a3)
{
  uint64_t v5 = (char *)this + 64;
  if (*((_DWORD *)this + 16) != *(_DWORD *)a2
    || (*(void *)((char *)this + 68) == *(void *)((char *)a2 + 4)
      ? (BOOL v6 = *(void *)((char *)this + 76) == *(void *)((char *)a2 + 12))
      : (BOOL v6 = 0),
        !v6))
  {
    uint64_t v7 = *((void *)this + 1);
    if (!*(void *)(v7 + 24)) {
      make_contents(*((void *)this + 1));
    }
    int v8 = *(RB::XML::Document **)(v7 + 304);
    if (v8) {
      RB::XML::DisplayList::set_identity(v8, (uint64_t)this, (uint64_t)v5, (uint64_t)a2);
    }
    *(void *)&double result = RB::DisplayList::State::set_identity((uint64_t)this, (uint64_t)a2).n128_u64[0];
  }
  return result;
}

__n128 RB::DisplayList::State::set_identity(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 68);
  *(_DWORD *)(a1 + 64) = *(_DWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 4);
  int32x4_t v3 = (__n128 *)(a2 + 4);
  if (v2 != v4 || *(void *)(a1 + 76) != v3->n128_u64[1])
  {
    __n128 result = *v3;
    *(__n128 *)(a1 + 68) = *v3;
    *(void *)(a1 + 120) = 0;
  }
  return result;
}

uint64_t RBSymbolUpdateLayerStyle(_DWORD *a1)
{
  uint64_t v1 = *(void *)a1 + 8;
  unsigned int v2 = *(_DWORD *)(*(void *)a1 + 848) + ~a1[2];
  if (*(void *)(*(void *)a1 + 840)) {
    uint64_t v1 = *(void *)(*(void *)a1 + 840);
  }
  uint64_t v3 = *((void *)a1 + 2);
  uint64_t v4 = *(void **)(v1 + 416 * v2 + 400);
  if (v4) {
    LODWORD(v3) = *(_DWORD *)(*v4 + 8 * *((void *)a1 + 2));
  }
  uint64_t v5 = v1 + 416 * v2;
  uint64_t v6 = v5 + 16;
  uint64_t v7 = *(void *)(v5 + 376);
  if (!v7) {
    uint64_t v7 = v6;
  }
  if (*(float *)(v7 + 120 * v3 + 20) == -32768.0) {
    return (*(_DWORD *)(*(void *)(v7 + 120 * v3) + 84) >> 8) & 0xF;
  }
  else {
    return 11;
  }
}

void ___ZN2RB6Device19RenderPipelineEntry6Loader13load_pipelineEv_block_invoke(uint64_t a1, void *a2)
{
}

void RB::Symbol::Presentation::~Presentation(RB::Symbol::Presentation *this)
{
  unsigned int v2 = (void *)*((void *)this + 258);
  unint64_t v3 = *((unsigned int *)this + 518);
  if (v3)
  {
    for (unint64_t i = 0; i < v3; ++i)
    {
      uint64_t v5 = (RB::Symbol::Glyph::Layer *)v2[i];
      v2[i] = 0;
      if (v5)
      {
        RB::Symbol::Glyph::Layer::~Layer(v5);
        unint64_t v3 = *((unsigned int *)this + 518);
      }
    }
    unsigned int v2 = (void *)*((void *)this + 258);
  }
  if (v2) {
    free(v2);
  }
  uint64_t v6 = (uint64_t *)*((void *)this + 256);
  if (*((_DWORD *)this + 514))
  {
    unint64_t v7 = 0;
    int v8 = v6 + 1;
    do
    {
      RBPathRelease(*(v8 - 1), *v8);
      ++v7;
      v8 += 2;
    }
    while (v7 < *((unsigned int *)this + 514));
    uint64_t v6 = (uint64_t *)*((void *)this + 256);
  }
  if (v6) {
    free(v6);
  }
  long long v9 = (void *)*((void *)this + 254);
  if (*((_DWORD *)this + 510))
  {
    unint64_t v10 = 0;
    do
    {
      uint64_t v11 = (atomic_uint *)v9[v10];
      if (v11 && atomic_fetch_add_explicit(v11 + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        (*(void (**)(atomic_uint *))(*(void *)v11 + 8))(v11);
      }
      ++v10;
    }
    while (v10 < *((unsigned int *)this + 510));
    long long v9 = (void *)*((void *)this + 254);
  }
  if (v9) {
    free(v9);
  }
  uint64_t v12 = *((void *)this + 253);
  *((void *)this + 253) = 0;
  if (v12) {
    std::default_delete<RB::vector<RB::Symbol::Presentation::KeyframeInfo,0ul,unsigned long>>::operator()[abi:nn180100]((uint64_t)this + 2024, v12);
  }

  RB::Heap::~Heap((RB::Symbol::Presentation *)((char *)this + 944));
  int v13 = (void *)*((void *)this + 105);
  if (v13) {
    int v14 = (char *)*((void *)this + 105);
  }
  else {
    int v14 = (char *)this + 8;
  }
  if (*((_DWORD *)this + 212))
  {
    unint64_t v15 = 0;
    do
    {
      *((void *)v14 + 49) = 0;
      int v16 = (void *)*((void *)v14 + 47);
      if (v16) {
        free(v16);
      }
      int v17 = (atomic_uint *)*((void *)v14 + 1);
      if (v17 && atomic_fetch_add_explicit(v17 + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        (*(void (**)(atomic_uint *))(*(void *)v17 + 8))(v17);
      }
      int v18 = *(atomic_uint **)v14;
      if (*(void *)v14 && atomic_fetch_add_explicit(v18 + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        (*(void (**)(atomic_uint *))(*(void *)v18 + 8))(v18);
      }
      ++v15;
      v14 += 416;
    }
    while (v15 < *((unsigned int *)this + 212));
    int v13 = (void *)*((void *)this + 105);
  }
  if (v13) {
    free(v13);
  }
  int v19 = *(atomic_uint **)this;
  if (*(void *)this)
  {
    if (atomic_fetch_add_explicit(v19 + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(atomic_uint *))(*(void *)v19 + 8))(v19);
    }
  }
}

void sub_214109FB4(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::Symbol::Presentation::shared(RB::Symbol::Presentation *this)
{
  {
    operator new();
  }
  return RB::Symbol::Presentation::shared(void)::shared;
}

void sub_21410A040(_Unwind_Exception *a1)
{
}

uint64_t RB::Refcount<RBPath anonymous namespace'::make_wrapped_path<RBPathCopyTransformedPath::TransformArgs>(RBPath,RBPathCopyTransformedPath::TransformArgs &&)::Info,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

float32x2_t RB::DisplayList::Layer::bounds(RB::DisplayList::Layer *this, double a2, int32x4_t a3)
{
  if (!*((unsigned char *)this + 66))
  {
    *((unsigned char *)this + 66) = 1;
    *((double *)this + 4) = RB::DisplayList::Layer::compute_bounds_(this, 0);
    *((void *)this + 5) = a3.i64[0];
  }
  int v4 = *((unsigned __int8 *)this + 64);
  if (*((float *)this + 12) == 0.0 && v4 == 0)
  {
    return *(float32x2_t *)((char *)this + 32);
  }
  else
  {
    long long v12 = 0uLL;
    switch(v4)
    {
      case 2:
        long long v12 = *((_OWORD *)this + 2);
        (*(void (**)(void, long long *))(**((void **)this + 3) + 40))(*((void *)this + 3), &v12);
        break;
      case 1:
        a3.i64[0] = *((void *)this + 5);
        *(float32x2_t *)&long long v12 = RB::operator*(*((void *)this + 3), *((double *)this + 4), a3);
        *((void *)&v12 + 1) = v7;
        break;
      case 0:
        long long v12 = *((_OWORD *)this + 2);
        break;
    }
    if (*((float *)this + 12) == 0.0) {
      float v8 = 1.0;
    }
    else {
      float v8 = *((float *)this + 12);
    }
    float32x2_t result = 0;
    if (v8 != 0.0)
    {
      uint32x2_t v9 = (uint32x2_t)vcge_f32((float32x2_t)(*((void *)&v12 + 1) & 0x7FFFFFFF7FFFFFFFLL), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
      if ((vpmax_u32(v9, v9).u32[0] & 0x80000000) != 0)
      {
        return (float32x2_t)0x100000001000000;
      }
      else
      {
        float32x2_t v10 = vrecpe_f32((float32x2_t)LODWORD(v8));
        float32x2_t v11 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v8), v10), v10);
        return vmul_n_f32(*(float32x2_t *)&v12, vmul_f32(v11, vrecps_f32((float32x2_t)LODWORD(v8), v11)).f32[0]);
      }
    }
  }
  return result;
}

uint64_t RB::Symbol::Animator::rendering_mode(os_unfair_lock_s *this)
{
  os_unfair_lock_lock(this);
  uint64_t v2 = *(unsigned __int8 *)(*(void *)&this[2]._os_unfair_lock_opaque + 88);
  os_unfair_lock_unlock(this);
  return v2;
}

float RBSymbolUpdateLayerDrawingOpacity(_DWORD *a1)
{
  uint64_t v1 = *(void *)a1 + 8;
  unsigned int v2 = *(_DWORD *)(*(void *)a1 + 848) + ~a1[2];
  if (*(void *)(*(void *)a1 + 840)) {
    uint64_t v1 = *(void *)(*(void *)a1 + 840);
  }
  unint64_t v3 = (_DWORD *)*((void *)a1 + 2);
  int v4 = *(void **)(v1 + 416 * v2 + 400);
  if (!v4) {
    goto LABEL_6;
  }
  unint64_t v3 = (_DWORD *)(*v4 + 8 * *((void *)a1 + 2));
  uint64_t v5 = v3[1];
  float result = 0.0;
  if (!v5) {
    return result;
  }
  LODWORD(v3) = *v3;
  if (v5 != 1)
  {
    uint64_t v10 = v1 + 416 * v2;
    uint64_t v11 = v10 + 16;
    uint64_t v12 = *(void *)(v10 + 376);
    if (!v12) {
      uint64_t v12 = v11;
    }
    while ((float)((float)(*(float *)(v12 + 120 * v3 + 24)
                          * *(float *)(v12 + 120 * v3 + 32))
                  * *(float *)(*(void *)(v12 + 120 * v3) + 72)) <= 0.0)
    {
      LODWORD(v3) = v3 + 1;
      if (!--v5) {
        return result;
      }
    }
    return 1.0;
  }
  else
  {
LABEL_6:
    uint64_t v7 = v1 + 416 * v2;
    uint64_t v8 = v7 + 16;
    uint64_t v9 = *(void *)(v7 + 376);
    if (!v9) {
      uint64_t v9 = v8;
    }
    return (float)(*(float *)(v9 + 120 * v3 + 24) * *(float *)(v9 + 120 * v3 + 32))
         * *(float *)(*(void *)(v9 + 120 * v3) + 72);
  }
}

void RB::CGContext::add_soft_mask(RB::CGContext::SoftMaskMode,RB::Rect,void const*,void (*)(RB::CGContext&,void const*))::$_2::__invoke(CGLayerRef *a1, CGContextRef context)
{
}

uint64_t RBDrawingStateBeginCGContext(uint64_t a1, int a2, float a3)
{
  [*(id *)(a1 + 8) deviceScale];
  return begin_cgcontext((_RBDrawingState *)a1, a3, v6, a2);
}

RB::XML::Document *RBDrawingStateScaleCTM(uint64_t a1, float64x2_t a2, double a3)
{
  double v4 = a2.f64[0];
  uint64_t v6 = *(void *)(a1 + 8);
  RB::DisplayList::State::scale((float64x2_t *)a1, a2, a3);
  float result = *(RB::XML::Document **)(v6 + 304);
  if (result)
  {
    return RB::XML::DisplayList::scale_ctm(result, (RB::XML::Document *)a1, v7, v4, a3);
  }
  return result;
}

float64x2_t RB::DisplayList::State::scale(float64x2_t *this, float64x2_t result, double a3)
{
  if (result.f64[0] != 1.0 || a3 != 1.0)
  {
    float result = vmulq_n_f64(this[1], result.f64[0]);
    float64x2_t v4 = vmulq_n_f64(this[2], a3);
    this[1] = result;
    this[2] = v4;
    this[7].f64[0] = 0.0;
    HIDWORD(this[9].f64[0]) = -1;
  }
  return result;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Color>::copy(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = (RB::Heap *)(*(void *)(a2 + 8) + 16);
  int v6 = *(_WORD *)(a1 + 46) & 0x3F;
  _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill5ColorEEEJRS0_RKS5_RKS7_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v3, (uint64_t)v3, (long long *)(a1 + 64), a1 + 112, (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), &v6);
  __n128 result = *(__n128 *)(a1 + 16);
  v5[1] = result;
  v5[2].n128_u64[0] = *(void *)(a1 + 32);
  v5[2].n128_u32[2] = *(_DWORD *)(a1 + 40);
  v5[2].n128_u16[7] |= *(_WORD *)(a1 + 46) & 0x5800;
  return result;
}

__n128 RB::DisplayList::GenericItemCopyVisitor<RB::Fill::Color>::visit_<RB::Coverage::Primitive>(void *a1, long long *a2)
{
  uint64_t v3 = a1[3];
  float64x2_t v4 = a1 + 4;
  uint64_t v5 = (RB::Heap *)a1[1];
  uint64_t v6 = a1[2];
  int v10 = *(_WORD *)(v6 + 46) & 0x3F;
  _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill5ColorEEEJRS0_RKS5_RKS7_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, (uint64_t)v5, a2, v3, v4, (__int16 *)(v6 + 44), &v10);
  a1[5] = v7;
  uint64_t v8 = (__n128 *)a1[2];
  __n128 result = v8[1];
  v7[1] = result;
  v7[2].n128_u64[0] = v8[2].n128_u64[0];
  v7[2].n128_u32[2] = v8[2].n128_u32[2];
  v7[2].n128_u16[7] |= v8[2].n128_u16[7] & 0x5800;
  return result;
}

double _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill5ColorEEEJRS0_RKS5_RKS7_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, uint64_t a2, long long *a3, uint64_t a4, uint64_t *a5, __int16 *a6, _WORD *a7)
{
  unint64_t v13 = *((void *)this + 3);
  unint64_t v14 = (*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v14 + 128 > v13) {
    unint64_t v14 = RB::Heap::alloc_slow((size_t *)this, 0x80uLL, 15);
  }
  else {
    *((void *)this + 2) = v14 + 128;
  }
  uint64_t v15 = *a5;
  __int16 v16 = *a6;
  char v17 = *a7;
  *(void *)(v14 + 16) = 0;
  *(void *)(v14 + 24) = 0;
  *(_DWORD *)(v14 + 40) = 0;
  *(void *)(v14 + 32) = 0;
  *(_WORD *)(v14 + 44) = v16;
  *(_WORD *)(v14 + 46) = v17 & 0x3F;
  *(void *)unint64_t v14 = &unk_26C4EB800;
  *(void *)(v14 + 48) = v15;
  long long v18 = *a3;
  long long v19 = a3[1];
  *(_OWORD *)(v14 + 95) = *(long long *)((char *)a3 + 31);
  *(_OWORD *)(v14 + 64) = v18;
  *(_OWORD *)(v14 + 80) = v19;
  if (*(unsigned char *)(a4 + 9)) {
    __int16 v20 = *(_WORD *)(a4 + 8);
  }
  else {
    __int16 v20 = 0;
  }
  double result = *(double *)a4;
  *(void *)(v14 + 112) = *(void *)a4;
  *(_WORD *)(v14 + 120) = v20;
  *(void *)unint64_t v14 = &unk_26C4EA060;
  return result;
}

void RBXMLRecorderMarkCGFrame(void *a1, CGContextRef c)
{
  if (RB::XMLRecorder::enabled)
  {
    ClipBoundingBoCGFloat x = CGContextGetClipBoundingBox(c);
    RBXMLRecorderMarkFrame(c, a1, 1, ClipBoundingBox.size.width, ClipBoundingBox.size.height);
  }
}

void RB::SurfacePool::AsyncCollection::~AsyncCollection()::$_0::__invoke(RB::SurfacePool *this)
{
  *((unsigned char *)this + 128) = 0;
  RB::SurfacePool::collect(this);
}

atomic_uint *anonymous namespace'::make_wrapped_path<RBPathCopyTransformedPath::TransformArgs>(RBPath,RBPathCopyTransformedPath::TransformArgs &&)::{lambda(void const*)#2}::__invoke(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t RB::prefs_int(const __CFString *this, const __CFString *a2)
{
  RB::Config::prefs_value(this, &v6);
  unsigned int v2 = v6;
  uint64_t v4 = RB::Config::int_value((const __CFString *)v6, v3);
  if (v2) {
    CFRelease(v2);
  }
  return v4;
}

CFPropertyListRef RB::Config::prefs_value@<X0>(const __CFString *this@<X0>, void *a2@<X8>)
{
  CFStringRef v5 = (const __CFString *)*MEMORY[0x263EFFE60];
  CFStringRef v6 = (const __CFString *)*MEMORY[0x263EFFE50];
  CFPropertyListRef result = CFPreferencesCopyValue(this, (CFStringRef)*MEMORY[0x263EFFE60], (CFStringRef)*MEMORY[0x263EFFE58], (CFStringRef)*MEMORY[0x263EFFE50]);
  *a2 = result;
  if (!result)
  {
    CFStringRef v8 = (const __CFString *)*MEMORY[0x263EFFE70];
    CFPropertyListRef result = CFPreferencesCopyValue(this, v5, (CFStringRef)*MEMORY[0x263EFFE70], v6);
    *a2 = result;
    if (!result)
    {
      CFStringRef v9 = (const __CFString *)*MEMORY[0x263EFFE48];
      CFPropertyListRef result = CFPreferencesCopyValue(this, (CFStringRef)*MEMORY[0x263EFFE48], v8, (CFStringRef)*MEMORY[0x263EFFE68]);
      *a2 = result;
      if (!result)
      {
        CFPropertyListRef result = CFPreferencesCopyValue(this, v9, v8, v6);
        *a2 = result;
      }
    }
  }
  return result;
}

float32x2_t **RB::Symbol::Presentation::Presentation(float32x2_t **a1, uint64_t a2, uint64_t a3, char a4, int a5, char a6, float32x2_t a7)
{
  uint64_t v118 = *MEMORY[0x263EF8340];
  *a1 = 0;
  a1[105] = 0;
  __uuid_t dst = a1 + 1;
  a1[106] = (float32x2_t *)0x200000000;
  float64x2_t v106 = (float64x2_t)xmmword_2142181D0;
  float64x2_t v108 = (float64x2_t)xmmword_2142181C0;
  *((_OWORD *)a1 + 54) = xmmword_2142181C0;
  *((_OWORD *)a1 + 55) = xmmword_2142181D0;
  a1[113] = 0;
  a1[112] = 0;
  a1[114] = (float32x2_t *)0x7FF0000000000000;
  *((_DWORD *)a1 + 233) = 0;
  *((unsigned char *)a1 + 936) = 0;
  a1[115] = 0;
  *((unsigned char *)a1 + 928) = 0;
  RB::Heap::Heap((RB::Heap *)(a1 + 118), (char *)a1 + 984, 1024, 0);
  a1[259] = 0;
  *(_OWORD *)(a1 + 255) = 0u;
  *(_OWORD *)(a1 + 257) = 0u;
  *(_OWORD *)(a1 + 251) = 0u;
  *(_OWORD *)(a1 + 253) = 0u;
  char v103 = a6;
  if ((atomic_load_explicit((atomic_uchar *volatile)&_ZGVZN2RB6Symbol12PresentationC1ERNS0_8AnimatorEDv2_fNSt3__18optionalIS4_EE21RBSymbolRenderingModejE13print_symbols, memory_order_acquire) & 1) == 0&& __cxa_guard_acquire(&_ZGVZN2RB6Symbol12PresentationC1ERNS0_8AnimatorEDv2_fNSt3__18optionalIS4_EE21RBSymbolRenderingModejE13print_symbols))
  {
    uint64_t v101 = RB::debug_int((RB *)"RB_PRINT_SYMBOLS", v100);
    if ((v101 & 0xFF00000000) != 0) {
      int v102 = v101;
    }
    else {
      int v102 = 0;
    }
    _ZZN2RB6Symbol12PresentationC1ERNS0_8AnimatorEDv2_fNSt3__18optionalIS4_EE21RBSymbolRenderingModejE13print_symbols = v102;
    __cxa_guard_release(&_ZGVZN2RB6Symbol12PresentationC1ERNS0_8AnimatorEDv2_fNSt3__18optionalIS4_EE21RBSymbolRenderingModejE13print_symbols);
  }
  os_unfair_lock_lock((os_unfair_lock_t)a2);
  long long v18 = *(float32x2_t **)(a2 + 8);
  int32x4_t v110 = (RB::Symbol::Model **)(a2 + 8);
  long long v19 = (RB::Symbol::Model *)*a1;
  if (*a1 == v18) {
    goto LABEL_9;
  }
  if (v19)
  {
    if (atomic_fetch_add_explicit((atomic_uint *volatile)v19 + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(RB::Symbol::Model *))(*(void *)v19 + 8))(v19);
    }
    long long v19 = *v110;
    if (!*v110) {
      goto LABEL_8;
    }
  }
  else
  {
    long long v19 = *(RB::Symbol::Model **)(a2 + 8);
    if (!v18) {
      goto LABEL_8;
    }
  }
  atomic_fetch_add_explicit((atomic_uint *volatile)v19 + 2, 1u, memory_order_relaxed);
LABEL_8:
  *a1 = (float32x2_t *)v19;
LABEL_9:
  int v20 = a6 & 7;
  if (a4 || v20)
  {
    float32x2_t v21 = *(float32x2_t *)((char *)v19 + 56);
    *(int32x2_t *)v15.i8 = vceq_f32(vabs_f32(v21), (float32x2_t)vdup_n_s32(0x7F800000u));
    uint32x2_t v22 = (uint32x2_t)vbic_s8(vorr_s8((int8x8_t)vcltz_f32(v21), (int8x8_t)vcgez_f32(v21)), *(int8x8_t *)v15.i8);
    *(uint32x2_t *)&v23.f64[0] = vpmin_u32(v22, v22);
    if ((LODWORD(v23.f64[0]) & 0x80000000) == 0) {
      float32x2_t v21 = *(float32x2_t *)(RB::Symbol::Model::glyph_info(v19) + 80);
    }
    if (a4)
    {
      HIDWORD(v23.f64[0]) = HIDWORD(a3);
      uint32x2_t v24 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(v21, (float32x2_t)a3));
      *(uint32x2_t *)v15.i8 = vpmax_u32(v24, v24);
      if (v15.i32[0] < 0)
      {
        float32x2_t v25 = vrecpe_f32(v21);
        float32x2_t v26 = vmul_f32(vrecps_f32(v21, v25), v25);
        float32x2_t v27 = vmul_f32(vrecps_f32(v21, v26), vmul_f32((float32x2_t)a3, v26));
        v16.i64[1] = 0;
        float64x2_t v108 = vmulq_n_f64((float64x2_t)xmmword_2142181C0, v27.f32[0]);
        int32x4_t v15 = (int32x4_t)xmmword_2142181D0;
        float64x2_t v23 = vmulq_n_f64((float64x2_t)xmmword_2142181D0, v27.f32[1]);
        float64x2_t v106 = v23;
      }
    }
    if (v20)
    {
      LODWORD(v23.f64[0]) = 0;
      v15.i32[0] = 0;
      v16.i32[1] = 1056964608;
      int32x2_t v28 = (int32x2_t)vmul_f32(v21, (float32x2_t)0x3F0000003F000000);
      v16.i32[0] = v103 & 1;
      v17.i32[0] = v16.i32[0];
      int8x8_t v29 = vbsl_s8((int8x8_t)vdup_lane_s32(vceq_s32(v17, *(int32x2_t *)&v23.f64[0]), 0), (int8x8_t)v28, (int8x8_t)vrev64_s32(v28));
      int8x16_t v30 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32(v16, v15), 0);
      float64x2_t v31 = (float64x2_t)vbslq_s8(v30, (int8x16_t)v106, (int8x16_t)xmmword_2142181C0);
      int32x4_t v32 = (int32x4_t)xmmword_214219A10;
      float64x2_t v33 = (float64x2_t)vbslq_s8(v30, (int8x16_t)v108, (int8x16_t)xmmword_214219A10);
      v32.i32[0] = v103 & 2;
      float64x2_t v34 = (float64x2_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32(v32, v15), 0), (int8x16_t)v33, (int8x16_t)vnegq_f64(v33));
      LODWORD(v33.f64[0]) = v103 & 4;
      float64x2_t v35 = (float64x2_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v33, v15), 0), (int8x16_t)v31, (int8x16_t)vnegq_f64(v31));
      int32x4_t v15 = (int32x4_t)v34;
      float64x2_t v36 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(v108, *(float *)v28.i32), v106, *(float *)&v28.i32[1]), v34, (float)-*(float *)v29.i32), v35, (float)-*(float *)&v29.i32[1]);
      float64x2_t v14 = v35;
    }
    else
    {
      float64x2_t v36 = 0uLL;
      float64x2_t v14 = v106;
      int32x4_t v15 = (int32x4_t)v108;
    }
    *((int32x4_t *)a1 + 54) = v15;
    *((float64x2_t *)a1 + 55) = v14;
    *((float64x2_t *)a1 + 56) = v36;
  }
  if ((v103 & 0x20) != 0) {
    *((unsigned char *)a1 + 936) = 1;
  }
  if ((v103 & 8) != 0
    || _ZZN2RB6Symbol12PresentationC1ERNS0_8AnimatorEDv2_fNSt3__18optionalIS4_EE21RBSymbolRenderingModejE13print_symbols >= 2)
  {
    operator new();
  }
  if (a5 != 255 && (*a1)[11].u8[0] != a5)
  {
    RB::Symbol::Model::copy_on_write((uint64_t)a1);
    RB::Symbol::Model::set_rendering_mode((uint64_t)*a1, a5, *(float *)(a2 + 56));
  }
  uint64_t v37 = *(void *)(a2 + 24);
  if (v37)
  {
    int v38 = 0;
    uint64_t v39 = v37 - 1;
    uint64_t v40 = 88 * v37;
    do
    {
      unsigned int v105 = v38;
      uint64_t v41 = v37 - 1;
      uint64_t v109 = *(void *)(a2 + 16);
      uint64_t v107 = v109 + 88 * (v37 - 1);
      uint64_t v42 = (double *)(v107 + 48);
      if ((*(void *)(v107 + 48) & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000 && v37 - 2 >= 0)
      {
        uint64_t v43 = v109 + 88 * v41;
        long long v44 = (_DWORD *)(v43 + 16);
        uint64_t v45 = (unsigned int *)(v43 + 12);
        uint64_t v46 = v40;
        uint64_t v47 = v39;
        while (1)
        {
          uint64_t v48 = *(void *)(a2 + 16) + v46;
          if ((*v44 >> *(_DWORD *)(v48 - 172)))
          {
            uint64_t v49 = (RB::Symbol::Animation *)(v48 - 176);
            float v50 = (const RB::Symbol::Model **)(v48 - 8);
            if ((unint64_t)v47 >= *(void *)(a2 + 24)) {
              float v50 = (const RB::Symbol::Model **)(a2 + 8);
            }
            double v51 = RB::Symbol::Animation::begin_time_after(v49, *(double *)(a2 + 40), *v50, v14.f64[0], *(double *)v15.i64);
            *uint64_t v42 = v51;
            unsigned int v52 = *v45 & 0xFFFFFDFF;
            *uint64_t v45 = v52;
            if ((*(void *)&v51 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL) {
              break;
            }
          }
          --v47;
          v46 -= 88;
          if (v47 <= 0) {
            goto LABEL_42;
          }
        }
        *uint64_t v45 = v52 | 0x4000;
      }
LABEL_42:
      RB::Symbol::Animation::will_apply(v107, *(double *)(a2 + 40));
      double v53 = *v42;
      v14.f64[0] = *(float64_t *)(a2 + 40);
      BOOL v54 = (*(void *)v42 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && v14.f64[0] < v53;
      int v38 = v105;
      if (v54)
      {
        *(_DWORD *)(v109 + 88 * v41 + 12) |= 0x8000u;
        *(void *)&v14.f64[0] = a1[114];
        if (v14.f64[0] <= v53) {
          double v53 = *((double *)a1 + 114);
        }
        *((double *)a1 + 114) = v53;
      }
      else if ((v105 >> *(_DWORD *)(v109 + 88 * v41 + 4)))
      {
        *(_DWORD *)(v109 + 88 * v41 + 12) |= 0x8000u;
      }
      else
      {
        int v38 = *(_DWORD *)(v109 + 88 * v41 + 16) | v105;
      }
      --v39;
      v40 -= 88;
      uint64_t v37 = v41;
    }
    while (v41);
  }
  BOOL v55 = (float *)(a1 + 115);
  double v113 = 0;
  HIDWORD(v56.f64[0]) = 64;
  uint64_t v114 = 0x4000000000;
  float32x2_t v115 = 0;
  uint64_t v116 = 0x4000000000;
  char v117 = 0;
  for (int i = *((_DWORD *)a1 + 233); ; *((_DWORD *)a1 + 233) = i)
  {
    if (i == 2)
    {
      if (a1[105]) {
        int v67 = (float32x2_t **)a1[105];
      }
      else {
        int v67 = __dst;
      }
      unsigned int v68 = *((_DWORD *)a1 + 212);
      if (v68)
      {
        uint64_t v69 = 416 * v68;
        do
        {
          RB::Symbol::Presentation::Symbol::make_layers(v67, a1);
          v67 += 52;
          v69 -= 416;
        }
        while (v69);
      }
LABEL_74:
      uint64_t v63 = *(void *)(a2 + 24);
      if (v63 < 1) {
        goto LABEL_85;
      }
      uint64_t v64 = 0;
      int v66 = 0;
      uint64_t v65 = 1;
LABEL_76:
      uint64_t v70 = 88 * v64;
      do
      {
        uint64_t v71 = *(void *)(a2 + 16);
        unint64_t v72 = (RB::Symbol::Animation *)(v71 + v70);
        unsigned int v73 = *(_DWORD *)(v71 + v70 + 12);
        if (v73 & 0x8000) == 0 && ((v73 >> *((_DWORD *)a1 + 233)))
        {
          unsigned int v74 = (const RB::Symbol::Model **)(v71 + v70 + 168);
          if ((unint64_t)(v64 + 1) >= *(void *)(a2 + 24)) {
            unsigned int v74 = (const RB::Symbol::Model **)(a2 + 8);
          }
          RB::Symbol::Animation::apply(v72, *(double *)(a2 + 40), *v74, (const RB::Symbol::Animator *)a2, (RB::Symbol::Presentation *)a1, (RB::Symbol::KeyframeStorage *)v112);
        }
        v64 += v65;
        BOOL v75 = v64 < v63;
        if (v66) {
          BOOL v75 = v64 >= 0;
        }
        v70 += 88 * (int)v65;
      }
      while (v75);
      goto LABEL_85;
    }
    if (i) {
      goto LABEL_74;
    }
    uint64_t v58 = (uint64_t)*a1;
    if ((((*a1)[11].u16[0] | ((*a1)[11].u8[2] << 16)) & 0x10000) == 0
      && (*a1)[11].i16[0] != 0xFF
      && *(void *)(v58 + 16) != 0)
    {
      unsigned int v60 = *((_DWORD *)a1 + 212);
      if (*((_DWORD *)a1 + 213) < v60 + 1)
      {
        RB::vector<RB::Symbol::Presentation::Symbol,2ul,unsigned int>::reserve_slow(__dst, v60 + 1);
        unsigned int v60 = *((_DWORD *)a1 + 212);
      }
      unsigned int v61 = a1[105];
      if (!v61) {
        unsigned int v61 = (float32x2_t *)__dst;
      }
      float64x2_t v62 = &v61[52 * v60];
      atomic_fetch_add_explicit((atomic_uint *volatile)(v58 + 8), 1u, memory_order_relaxed);
      *float64x2_t v62 = (float32x2_t)v58;
      v62[1] = 0;
      v62[47] = 0;
      v62[48] = (float32x2_t)0x300000000;
      v62[49] = 0;
      v62[50] = 0;
      *(__int32 *)((char *)&v62[50].i32[1] + 3) = 0;
      ++*((_DWORD *)a1 + 212);
    }
    uint64_t v63 = *(void *)(a2 + 24);
    if (v63 > 0)
    {
      uint64_t v64 = v63 - 1;
      uint64_t v65 = -1;
      int v66 = 1;
      goto LABEL_76;
    }
LABEL_85:
    int v76 = *((_DWORD *)a1 + 233);
    if (v76 == 2) {
      break;
    }
    int i = v76 + 1;
  }
  unsigned int v77 = *((_DWORD *)a1 + 212);
  if (v77 >= 2)
  {
    float64x2_t v56 = vaddq_f64(*((float64x2_t *)a1 + 56), vcvtq_f64_f32(vsub_f32((*a1)[6], vadd_f32(*(float32x2_t *)(a2 + 48), a7))));
    *((float64x2_t *)a1 + 56) = v56;
  }
  if (*((unsigned char *)a1 + 928))
  {
    RB::Symbol::Presentation::apply_interpolations((RB::Symbol::Presentation *)a1);
    unsigned int v77 = *((_DWORD *)a1 + 212);
  }
  unsigned int v78 = a1[105];
  if ((v103 & 0x10) != 0)
  {
    if (v78) {
      unsigned __int32 v79 = (RB::Symbol::Presentation::Symbol *)a1[105];
    }
    else {
      unsigned __int32 v79 = (RB::Symbol::Presentation::Symbol *)__dst;
    }
    if (v77)
    {
      uint64_t v80 = 416 * v77;
      do
      {
        RB::Symbol::Presentation::Symbol::merge_layers(v79, (size_t *)a1);
        unsigned __int32 v79 = (RB::Symbol::Presentation::Symbol *)((char *)v79 + 416);
        v80 -= 416;
      }
      while (v80);
      unsigned int v78 = a1[105];
      unsigned int v77 = *((_DWORD *)a1 + 212);
      goto LABEL_99;
    }
  }
  else
  {
LABEL_99:
    if (!v78) {
      unsigned int v78 = (float32x2_t *)__dst;
    }
    if (v77)
    {
      uint64_t v81 = &v78[52 * v77];
      do
      {
        uint64_t v82 = (float32x2_t *)v78[47];
        if (!v82) {
          uint64_t v82 = v78 + 2;
        }
        uint64_t v83 = v78[48].u32[0];
        if (v83)
        {
          float v84 = *v55;
          uint64_t v85 = 120 * v83;
          float32x2_t v86 = v82 + 13;
          do
          {
            float32x2_t v87 = *v86;
            v86 += 15;
            float v88 = fmaxf(v87.f32[0], v87.f32[1]);
            if (v84 < v88) {
              float v84 = v88;
            }
            *BOOL v55 = v84;
            v85 -= 120;
          }
          while (v85);
        }
        v78 += 52;
      }
      while (v78 != v81);
    }
  }
  *(float *)v56.f64 = *((float *)a1 + 230) + (float)((float)(*(float *)(a2 + 64) - *((float *)a1 + 230)) * 0.35);
  *((_DWORD *)a1 + 231) = LODWORD(v56.f64[0]);
  *(_DWORD *)(a2 + 64) = LODWORD(v56.f64[0]);
  uint64_t v89 = *(void *)(a2 + 24);
  if (v89)
  {
    uint64_t v90 = 0;
    int v91 = 0;
    unint64_t v92 = 0;
    while (1)
    {
      uint64_t v93 = *(void *)(a2 + 16);
      uint64_t v94 = v93 + v90;
      int v95 = *(_DWORD *)(v93 + v90 + 12);
      ++v92;
      if ((v95 & 0x2000) != 0)
      {
        double v97 = *(double *)(a2 + 40);
      }
      else
      {
        int v96 = (const RB::Symbol::Model **)(a2 + 8);
        if (v92 < *(void *)(a2 + 24)) {
          int v96 = (const RB::Symbol::Model **)(v94 + 168);
        }
        v56.f64[0] = RB::Symbol::Animation::end_time((RB::Symbol::Animation *)(v93 + v90), *v96, *(float32x2_t *)&v56.f64[0]);
        double v97 = *(double *)(a2 + 40);
        if (v97 >= v56.f64[0])
        {
          int v95 = *(_DWORD *)(v94 + 12) | 0x2000;
LABEL_123:
          *(_DWORD *)(v94 + 12) = v95;
          goto LABEL_124;
        }
        int v95 = *(_DWORD *)(v94 + 12);
        if (((unint64_t)a1[114] & 0x7FFFFFFFFFFFFFFFLL) >= 0x7FF0000000000000)
        {
          if (*((double *)a1 + 114) <= v56.f64[0]) {
            *(void *)&v56.f64[0] = a1[114];
          }
          a1[114] = *(float32x2_t **)&v56.f64[0];
          v95 |= 0x4000u;
          goto LABEL_123;
        }
      }
LABEL_124:
      *(_DWORD *)(v94 + 12) = v95 & 0xFFFF7FFF;
      *(double *)(v93 + v90 + 56) = v97;
      v91 |= (unsigned __int16)(v95 & 0x2000) >> 13;
      v90 += 88;
      if (v89 == v92) {
        goto LABEL_127;
      }
    }
  }
  LOBYTE(v91) = 0;
LABEL_127:
  if (_ZZN2RB6Symbol12PresentationC1ERNS0_8AnimatorEDv2_fNSt3__18optionalIS4_EE21RBSymbolRenderingModejE13print_symbols > 0
    && ((memset(__p, 0, 41),
         RB::Symbol::Presentation::print((RB::Symbol::Presentation *)a1, __p, (os_unfair_lock_t)a2, 1),
         (__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      ? (size_t v98 = __p)
      : (size_t v98 = (std::string *)__p[0].__r_.__value_.__r.__words[0]),
        printf("\n%s\n", (const char *)v98),
        SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0))
  {
    operator delete(__p[0].__r_.__value_.__l.__data_);
    if (v91) {
LABEL_133:
    }
      RB::Symbol::Animator::remove_finished_animations_locked((RB::Symbol::Animator *)a2);
  }
  else if (v91)
  {
    goto LABEL_133;
  }
  if (v115) {
    free(v115);
  }
  if (v113) {
    free(v113);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)a2);
  return a1;
}

void sub_21410B36C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, RB::Heap *a10, uint64_t *a11, uint64_t a12, char *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  __cxa_guard_abort(&_ZGVZN2RB6Symbol12PresentationC1ERNS0_8AnimatorEDv2_fNSt3__18optionalIS4_EE21RBSymbolRenderingModejE13print_symbols);
  RB::vector<std::unique_ptr<RB::Symbol::Glyph::Layer,RB::Destroy<RB::Symbol::Glyph::Layer>>,0ul,unsigned int>::~vector(v31 + 2064);
  RB::vector<RB::path_ptr,0ul,unsigned int>::~vector(v31 + 2048);
  RB::vector<RB::refcounted_ptr<RB::Symbol::Model const>,0ul,unsigned int>::~vector(v31 + 2032);
  uint64_t v33 = *a11;
  *a11 = 0;
  if (v33) {
    std::default_delete<RB::vector<RB::Symbol::Presentation::KeyframeInfo,0ul,unsigned long>>::operator()[abi:nn180100]((uint64_t)a11, v33);
  }

  RB::Heap::~Heap(a10);
  RB::vector<RB::Symbol::Presentation::Symbol,2ul,unsigned int>::~vector(a13);
  float64x2_t v34 = *(atomic_uint **)v31;
  if (*(void *)v31)
  {
    if (atomic_fetch_add_explicit(v34 + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(atomic_uint *))(*(void *)v34 + 8))(v34);
    }
  }
  _Unwind_Resume(a1);
}

void RB::Symbol::Presentation::Symbol::merge_layers(RB::Symbol::Presentation::Symbol *this, size_t *size)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  if (*((void *)this + 50)) {
    return;
  }
  uint64_t v3 = *((unsigned int *)this + 96);
  if (v3 < 2) {
    return;
  }
  if (v3 > 0x200)
  {
    CFStringRef v6 = (char *)malloc_type_malloc(8 * v3, 0x98DC86EBuLL);
    if (!v6) {
      goto LABEL_35;
    }
  }
  else
  {
    MEMORY[0x270FA5388](this, 8 * v3);
    CFStringRef v6 = (char *)&v26 - ((v5 + 15) & 0xFFFFFFFF0);
    bzero(v6, v5);
  }
  float32x2_t v27 = size;
  uint64_t v28 = v3;
  uint64_t v7 = 0;
  unsigned int v8 = 0;
  char v9 = 0;
  for (unsigned int i = 1; i < *((_DWORD *)this + 96); ++i)
  {
    uint64_t v11 = *((void *)this + 47)
        ? (RB::Symbol::Presentation::Symbol *)*((void *)this + 47)
        : (RB::Symbol::Presentation::Symbol *)((char *)this + 16);
    uint64_t v12 = (char *)v11 + 120 * v8;
    unint64_t v13 = (char *)v11 + 120 * i;
    uint64_t v14 = *(void *)v12;
    int v15 = *(_DWORD *)(*(void *)v12 + 84);
    uint64_t v16 = *(void *)v13;
    int v17 = *(_DWORD *)(*(void *)v13 + 84);
    if ((((unsigned __int16)v17 ^ (unsigned __int16)v15) & 0xF00) != 0
      || ((v17 | v15) & 0x400000) != 0 && (*(float *)(v14 + 72) != 0.0 || *(float *)(v16 + 72) != 0.0))
    {
      break;
    }
    if ((vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32(vceqq_f32(*(float32x4_t *)((char *)v11 + 120 * v8 + 8), *(float32x4_t *)((char *)v11 + 120 * i + 8))), 0xFuLL))) & 1) == 0)break; {
    if ((*(_DWORD *)(*(void *)v12 + 84) & 0xF00) == 0x900)
    }
    {
      if (!CGColorEqualToColor(*(CGColorRef *)(v14 + 16), *(CGColorRef *)(v16 + 16))
        || ![*(id *)(*(void *)v12 + 8) isEqualToString:*(void *)(*(void *)v13 + 8)])
      {
        break;
      }
      uint64_t v14 = *(void *)v12;
      int v15 = *(_DWORD *)(*(void *)v12 + 84);
    }
    if ((v15 & 0xF00) == 0xC00 && *(void *)(v14 + 16) != *(void *)(*(void *)v13 + 16)) {
      break;
    }
LABEL_20:
    ;
  }
  unsigned int v18 = i - v8;
  if (i != v8)
  {
    long long v19 = &v6[8 * v7++];
    *(_DWORD *)long long v19 = v8;
    *((_DWORD *)v19 + 1) = v18;
    v9 |= v18 > 1;
  }
  if (i != *((_DWORD *)this + 96))
  {
    unsigned int v8 = i;
    goto LABEL_20;
  }
  if (v9)
  {
    int v20 = v27;
    float32x2_t v21 = v27 + 118;
    size_t v22 = 8 * v7;
    float64x2_t v23 = (char *)((v27[120] + 3) & 0xFFFFFFFFFFFFFFFCLL);
    uint32x2_t v24 = &v23[8 * v7];
    if ((unint64_t)v24 > v27[121])
    {
      float64x2_t v23 = (char *)RB::Heap::alloc_slow(v27 + 118, 8 * v7, 3);
      size_t v22 = 8 * v7;
      int v20 = v27;
    }
    else
    {
      v27[120] = (size_t)v24;
    }
    memcpy(v23, v6, v22);
    float32x2_t v25 = (void *)((v20[120] + 7) & 0xFFFFFFFFFFFFFFF8);
    if ((unint64_t)(v25 + 2) > v20[121]) {
      float32x2_t v25 = (void *)RB::Heap::alloc_slow(v21, 0x10uLL, 7);
    }
    else {
      v20[120] = (size_t)(v25 + 2);
    }
    *float32x2_t v25 = v23;
    v25[1] = v7;
    *((void *)this + 50) = v25;
  }
  if (v28 >= 0x201) {
LABEL_35:
  }
    free(v6);
}

void sub_21410B75C(_Unwind_Exception *exception_object)
{
  if (*(void *)(v2 - 96) >= 0x201) {
    free(v1);
  }
  _Unwind_Resume(exception_object);
}

void RB::Symbol::Presentation::Symbol::make_layers(float32x2_t **this, float32x2_t **a2)
{
  uint64_t v4 = (float32x2_t *)RB::Symbol::Model::glyph_info((RB::Symbol::Model *)*this);
  float32x2_t v6 = v4[12];
  float32x2_t v5 = v4[13];
  float32x2_t v7 = v4[11];
  unsigned int v8 = (RB::Symbol::Model *)*this;
  float32x2_t v9 = (*this)[9];
  if (*this != *a2)
  {
    int v10 = (float32x2_t *)RB::Symbol::Model::glyph_info((RB::Symbol::Model *)*a2);
    unsigned int v8 = (RB::Symbol::Model *)*this;
    float32x2_t v9 = vneg_f32(vmla_f32(vsub_f32(vneg_f32(vmla_f32(vsub_f32(v9, (*a2)[6]), v10[10], (*a2)[5])), (*this)[6]), (*this)[5], v4[10]));
  }
  if (*((unsigned char *)this + 409))
  {
    int v11 = *((unsigned __int8 *)this + 408);
  }
  else
  {
    int v11 = *((unsigned __int8 *)v8 + 89);
    *((_WORD *)this + 204) = v11 | 0x100;
  }
  float v12 = 1.25;
  if (!v11) {
    float v12 = 1.0;
  }
  if ((v11 & 0x80u) == 0) {
    float v13 = v12;
  }
  else {
    float v13 = 0.5;
  }
  float32x2_t v14 = *(float32x2_t *)((char *)v8 + 56);
  float32x2_t v15 = *(float32x2_t *)((char *)v8 + 64);
  uint32x2_t v16 = (uint32x2_t)vbic_s8(vorr_s8((int8x8_t)vcltz_f32(v14), (int8x8_t)vcgez_f32(v14)), (int8x8_t)vceq_f32(vabs_f32(v14), (float32x2_t)vdup_n_s32(0x7F800000u)));
  if ((vpmin_u32(v16, v16).u32[0] & 0x80000000) != 0)
  {
    float32x2_t v17 = v4[10];
    uint32x2_t v18 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(v14, v17));
    if ((vpmax_u32(v18, v18).u32[0] & 0x80000000) != 0)
    {
      float32x2_t v19 = vrecpe_f32(v17);
      float32x2_t v20 = vmul_f32(vrecps_f32(v17, v19), v19);
      float32x2_t v15 = vmul_f32(vmul_f32(vmul_f32(v14, v15), v20), vrecps_f32(v17, v20));
    }
  }
  if (*((unsigned char *)a2 + 936)) {
    float v21 = v4[10].f32[1] - v4[8].f32[1];
  }
  else {
    float v21 = 0.0;
  }
  unsigned __int32 v22 = v4[48].u32[0];
  unsigned int v23 = v22 + *((_DWORD *)this + 96);
  if (*((_DWORD *)this + 97) < v23)
  {
    RB::vector<RB::Symbol::Presentation::Layer,3ul,unsigned int>::reserve_slow(this + 2, v23);
    unsigned __int32 v22 = v4[48].u32[0];
    if (v22) {
      goto LABEL_19;
    }
  }
  else if (v22)
  {
LABEL_19:
    unint64_t v24 = 0;
    uint64_t v25 = 88 * v22;
    __asm { FMOV            V0.4S, #1.0 }
    long long v50 = _Q0;
    __asm { FMOV            V15.2S, #1.0 }
    while (1)
    {
      if (v4[47]) {
        int32x4_t v32 = (float32x2_t *)v4[47];
      }
      else {
        int32x4_t v32 = v4 + 14;
      }
      unsigned int v33 = *((_DWORD *)this + 96);
      if (*((_DWORD *)this + 97) < v33 + 1)
      {
        RB::vector<RB::Symbol::Presentation::Layer,3ul,unsigned int>::reserve_slow(this + 2, v33 + 1);
        unsigned int v33 = *((_DWORD *)this + 96);
      }
      float64x2_t v34 = this[47];
      if (!v34) {
        float64x2_t v34 = (float32x2_t *)(this + 2);
      }
      float64x2_t v35 = (char *)&v34[15 * v33];
      *(void *)float64x2_t v35 = &v32[v24 / 8];
      *(_OWORD *)(v35 + 8) = RBColorNull;
      *(_OWORD *)(v35 + 24) = v50;
      *(_OWORD *)(v35 + 40) = xmmword_214219A20;
      *((_OWORD *)v35 + 4) = 0u;
      *((_OWORD *)v35 + 5) = 0u;
      *((void *)v35 + 12) = _D15;
      *((void *)v35 + 13) = 0;
      *((void *)v35 + 14) = 0;
      unsigned int v36 = *((_DWORD *)this + 96);
      *((_DWORD *)this + 96) = v36 + 1;
      if (this[47]) {
        uint64_t v37 = this[47];
      }
      else {
        uint64_t v37 = (float32x2_t *)(this + 2);
      }
      int v38 = &v37[15 * v36];
      v38[4].f32[1] = v13;
      v38[7] = v4[10];
      v38[8] = v9;
      v38[14].f32[0] = v21;
      v38[9] = v7;
      v38[10] = v6;
      v38[11] = v5;
      v38[12] = v15;
      unsigned __int32 v39 = RB::Symbol::Model::style_color_index((*(_DWORD *)(*(void *)v38 + 84) >> 8) & 0xF);
      if (v39 < (*this)[4].i32[0])
      {
        uint64_t v41 = *(void *)&(*this)[3] + 16 * v39;
        float v40 = *(float *)(v41 + 12);
        if (v40 != -32768.0)
        {
          uint64_t v42 = *(void *)v41;
          uint64_t v43 = (char *)&v37[15 * v36];
          *((_DWORD *)v43 + 4) = *(_DWORD *)(v41 + 8);
          *((void *)v43 + 1) = v42;
          *((float *)v43 + 5) = v40;
        }
      }
      long long v44 = (RB::Symbol::Model *)this[1];
      if (!v44) {
        long long v44 = (RB::Symbol::Model *)*this;
      }
      unsigned int v45 = *((_DWORD *)v44 + 20);
      unsigned int v46 = *(_DWORD *)(*(void *)v38 + 80);
      if ((v46 | v45) != 0xFFFFFFFF) {
        break;
      }
      v37[15 * v36 + 3].f32[0] = v37[15 * v36 + 3].f32[0]
                               * RB::Symbol::Model::alpha((RB::Symbol::Model *)*this, *(unsigned __int8 *)(*(void *)v38 + 84), v40);
LABEL_43:
      v24 += 88;
      if (v25 == v24) {
        return;
      }
    }
    uint64_t v47 = (RB::Symbol::Model *)*this;
    if (v45 >= v46)
    {
      unint64_t v49 = 0;
    }
    else
    {
      uint64_t v48 = RB::Symbol::Model::glyph_info((RB::Symbol::Model *)*this);
      float v40 = 0.3;
      if (*(_DWORD *)(v48 + 24) != 3)
      {
LABEL_42:
        v37[15 * v36 + 3] = vmul_n_f32(v37[15 * v36 + 3], v40);
        goto LABEL_43;
      }
      unint64_t v49 = 2;
    }
    float v40 = RB::Symbol::Model::alpha(v47, v49, v40);
    goto LABEL_42;
  }
}

float RB::Symbol::Model::alpha(RB::Symbol::Model *this, unint64_t a2, float a3)
{
  uint64_t v3 = 3;
  if (a2 < 3) {
    uint64_t v3 = a2;
  }
  LOBYTE(a3) = *((unsigned char *)this + v3 + 91);
  return (float)LODWORD(a3) * 0.0039216;
}

uint64_t RB::Symbol::Model::style_color_index(int a1)
{
  if ((a1 - 5) >= 4) {
    unsigned int v1 = -1;
  }
  else {
    unsigned int v1 = a1 - 4;
  }
  if (a1) {
    return v1;
  }
  else {
    return 0;
  }
}

void *RB::vector<RB::Symbol::Presentation::Layer,3ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  if (*((_DWORD *)__dst + 93) + (*((_DWORD *)__dst + 93) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *((_DWORD *)__dst + 93) + (*((_DWORD *)__dst + 93) >> 1);
  }
  CFPropertyListRef result = RB::details::realloc_vector<unsigned int,120ul>(*((void **)__dst + 45), __dst, 3u, (_DWORD *)__dst + 93, v3);
  *((void *)__dst + 45) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,120ul>(void *__src, void *__dst, unsigned int a3, _DWORD *a4, unsigned int a5)
{
  float32x2_t v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      LODWORD(v9) = a3;
      memcpy(__dst, __src, 120 * a5);
      free(v7);
      float v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(120 * a5);
    unint64_t v9 = v8 / 0x78;
    if (*a4 != (v8 / 0x78))
    {
      int v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10) {
        RB::precondition_failure((RB *)"allocation failure", v11);
      }
      float v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, 120 * *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

unint64_t RB::ColorMode::ColorMode(RBColorMode)::$_0::operator()(uint64_t a1, const char *a2)
{
  v13[1] = *MEMORY[0x263EF8340];
  uint64_t v2 = RB::debug_string((RB *)"RB_COLOR_MODE", a2);
  if (v2)
  {
    unsigned int v3 = v2;
    if (*v2)
    {
      unsigned int v4 = 0;
      uint64_t v5 = 0;
      while (1)
      {
        float32x2_t v6 = &v3[strspn(v3, "-,; ")];
        size_t v7 = strcspn(v6, "-,; ");
        if (!v7) {
          return v4 | (unint64_t)(v5 << 32);
        }
        size_t v9 = v7;
        size_t v10 = v7 + 1;
        if (v7 + 1 > 0x1000)
        {
          int v11 = (char *)malloc_type_malloc(v7 + 1, 0x576CDC83uLL);
        }
        else
        {
          MEMORY[0x270FA5388](v7, v8);
          int v11 = (char *)v13 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
          bzero(v11, v10);
        }
        memcpy(v11, v6, v9);
        v11[v9] = 0;
        if (strcasecmp(v11, "deep")
          && strcasecmp(v11, "wide")
          && strcasecmp(v11, "extended")
          && strcasecmp(v11, "fixed"))
        {
          if (!strcasecmp(v11, "linear"))
          {
            uint64_t v5 = v5 | 1;
LABEL_23:
            v4 |= 1u;
            goto LABEL_29;
          }
          if (!strcasecmp(v11, "nonlinear")) {
            goto LABEL_23;
          }
          if (!strcasecmp(v11, "5bpc"))
          {
            uint64_t v5 = v5 | 2;
          }
          else if (!strcasecmp(v11, "422"))
          {
            uint64_t v5 = v5 | 4;
          }
          else
          {
            if (strcasecmp(v11, "420"))
            {
              if (!strcasecmp(v11, "pq"))
              {
                uint64_t v5 = v5 | 0x20;
                v4 |= 0x20u;
              }
              else
              {
                fprintf((FILE *)*MEMORY[0x263EF8348], "Unknown RB_COLOR_MODE option: %s\n", v11);
              }
              goto LABEL_29;
            }
            uint64_t v5 = v5 | 8;
          }
          v4 |= 0xEu;
        }
LABEL_29:
        if (v10 > 0x1000) {
          free(v11);
        }
        unsigned int v3 = &v6[v9];
        if (!v6[v9]) {
          return v4 | (unint64_t)(v5 << 32);
        }
      }
    }
  }
  uint64_t v5 = 0;
  unsigned int v4 = 0;
  return v4 | (unint64_t)(v5 << 32);
}

void ___Z22RBXMLRecorderInstalledv_block_invoke(uint64_t a1, const char *a2)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  uint64_t v2 = RB::debug_int((RB *)"RB_XML_RECORDER", a2);
  if ((v2 & 0xFF00000000) != 0) {
    int v4 = v2;
  }
  else {
    int v4 = 0;
  }
  if (v4 >= 1)
  {
    RB::XMLRecorder::installed = 1;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x263F8C100], (uint64_t)"RBXMLRecorder installed.\n", 25);
    if (v4 != 1)
    {
      RBXMLRecorderStart();
      if (RB::XMLRecorder::enabled) {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x263F8C100], (uint64_t)"RBXMLRecorder logging enabled.\n", 31);
      }
      if (v4 >= 3)
      {
        if (os_variant_has_internal_diagnostics())
        {
          uint64_t v5 = NSTemporaryDirectory();
          RB::XMLRecorder::log_file = -[NSString copy](-[NSString stringByAppendingPathComponent:](v5, "stringByAppendingPathComponent:", objc_msgSend(NSString, "stringWithFormat:", @"rb-xml-%d.txt", getpid())), "copy");
          float32x2_t v6 = RB::misc_log((RB *)RB::XMLRecorder::log_file);
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412290;
            uint64_t v17 = RB::XMLRecorder::log_file;
            _os_log_impl(&dword_2140F5000, v6, OS_LOG_TYPE_DEFAULT, "Logging RenderBox frames to %@", buf, 0xCu);
          }
        }
      }
    }
  }
  size_t v7 = RB::debug_string((RB *)"RB_XML_SAVE_IMAGES", v3);
  if (v7)
  {
    if (*v7 == 47)
    {
      uint64_t v8 = [[NSString alloc] initWithUTF8String:v7];
      goto LABEL_17;
    }
    if (atoi(v7))
    {
      uint64_t v9 = objc_msgSend(NSString, "stringWithFormat:", @"rb-xml-%d", getpid());
      uint64_t v8 = [[(NSString *)NSTemporaryDirectory() stringByAppendingPathComponent:v9] copy];
LABEL_17:
      RB::XMLRecorder::resource_path = v8;
      if (!v8) {
        goto LABEL_19;
      }
      goto LABEL_18;
    }
    if (RB::XMLRecorder::resource_path) {
LABEL_18:
    }
      RB::XMLRecorder::image_names = objc_opt_new();
  }
LABEL_19:
  if (os_variant_has_internal_diagnostics())
  {
    unsigned int v11 = (unsigned __int16)RB::debug_BOOL((RB *)"RB_REDIRECT_OUTPUT", v10);
    if (v11 <= 0x100) {
      LOBYTE(v11) = 0;
    }
    if ((_BYTE)v11)
    {
      float v12 = NSTemporaryDirectory();
      float v13 = -[NSString stringByAppendingPathComponent:](v12, "stringByAppendingPathComponent:", objc_msgSend(NSString, "stringWithFormat:", @"rb-log-%d.txt", getpid()));
      close(1);
      openat(1, [(NSString *)v13 UTF8String], 521, 420);
      close(2);
      dup2(1, 2);
      setlinebuf((FILE *)*MEMORY[0x263EF8358]);
      float32x2_t v14 = (RB *)setlinebuf((FILE *)*MEMORY[0x263EF8348]);
      float32x2_t v15 = RB::misc_log(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        uint64_t v17 = (uint64_t)v13;
        _os_log_impl(&dword_2140F5000, v15, OS_LOG_TYPE_DEFAULT, "Redirected output to %@", buf, 0xCu);
      }
    }
  }
}

char *RB::debug_string(RB *this, const char *a2)
{
  RB::Config::debug_value(this, &v6);
  uint64_t v2 = v6;
  int v4 = RB::Config::string_value(v6, v3);
  if (v2) {
    CFRelease(v2);
  }
  return v4;
}

char *RB::Config::string_value(RB::Config *this, const void *a2)
{
  CFPropertyListRef result = (char *)MEMORY[0x270FA5388](this, a2);
  uint64_t v6 = *MEMORY[0x263EF8340];
  if (result)
  {
    CFStringRef v3 = (const __CFString *)result;
    CFTypeID v4 = CFGetTypeID(result);
    if (v4 != CFStringGetTypeID()) {
      return 0;
    }
    CFPropertyListRef result = (char *)CFStringGetCStringPtr(v3, 0x8000100u);
    if (result) {
      return result;
    }
    if (CFStringGetCString(v3, buffer, 4096, 0x8000100u)) {
      return strdup(buffer);
    }
    else {
      return 0;
    }
  }
  return result;
}

void RB::Device::Device(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  *(_DWORD *)(a1 + 8) = 1;
  *(void *)a1 = &unk_26C4EDB10;
  *(void *)(a1 + 16) = a2;
  *(void *)(a1 + 24) = a3;
  uint64_t v5 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, 0);
  *(void *)(a1 + 32) = dispatch_queue_create("com.apple.RenderBox.Device", v5);
  uint64_t v6 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, 0);
  *(void *)(a1 + 40) = dispatch_queue_create("com.apple.RenderBox.Encoder", v6);
  *(void *)(a1 + 248) = 0;
  *(void *)(a1 + 256) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_DWORD *)(a1 + 192) = 0;
  *(void *)(a1 + 264) = 2;
  *(void *)(a1 + 272) = RB::debug_byte_size((RB *)"RB_BUFFER_SIZE", (const char *)0x10000, 0x4000uLL, 0x400000uLL);
  *(_WORD *)(a1 + 280) = 256;
  *(unsigned char *)(a1 + 282) = 1;
  size_t v7 = (unsigned char *)(a1 + 283);
  *(unsigned char *)(a1 + 287) = 0;
  *(_DWORD *)(a1 + 283) = 0;
  *(void *)(a1 + 288) = 0x2000;
  *(unsigned char *)(a1 + 296) = 0;
  RB::Heap::Heap((RB::Heap *)(a1 + 304), 0, 0, 0x400uLL);
  *(void *)(a1 + 344) = a1 + 344;
  *(void *)(a1 + 352) = a1 + 344;
  *(void *)(a1 + 360) = 0;
  *(void *)(a1 + 368) = 0;
  *(void *)(a1 + 376) = a1 + 376;
  *(void *)(a1 + 384) = a1 + 376;
  *(void *)(a1 + 392) = 0;
  *(void *)(a1 + 400) = a1 + 400;
  *(void *)(a1 + 416) = 0;
  *(void *)(a1 + 424) = 0;
  *(void *)(a1 + 408) = a1 + 400;
  RB::UntypedTable::UntypedTable(a1 + 432, (unint64_t (*)(RB *, const void *))RB::Device::Device(RBDevice *,objc_object  {objcproto9MTLDevice}*)::$_0::__invoke<RB::FormattedRenderState const*>, (BOOL (*)(RB *, RB *, const void *))RB::Device::Device(RBDevice *,objc_object  {objcproto9MTLDevice}*)::$_1::__invoke<RB::FormattedRenderState const*,RB::FormattedRenderState const>, 0, (void (*)(void *))RB::Device::Device(RBDevice *,objc_object  {objcproto9MTLDevice}*)::$_2::__invoke<RB::Device::RenderPipelineEntry *>, (RB::Heap *)(a1 + 304));
  *(_OWORD *)(a1 + 512) = 0u;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_DWORD *)(a1 + 544) = 1065353216;
  *(_WORD *)(a1 + 552) = 0;
  *(_OWORD *)(a1 + 560) = 0u;
  *(_OWORD *)(a1 + 576) = 0u;
  *(_OWORD *)(a1 + 592) = 0u;
  *(_OWORD *)(a1 + 608) = 0u;
  *(_OWORD *)(a1 + 624) = 0u;
  *(_OWORD *)(a1 + 640) = 0u;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  *(_OWORD *)(a1 + 688) = 0u;
  *(_OWORD *)(a1 + 704) = 0u;
  *(_OWORD *)(a1 + 720) = 0u;
  *(_OWORD *)(a1 + 736) = 0u;
  *(_OWORD *)(a1 + 752) = 0u;
  *(_OWORD *)(a1 + 768) = 0u;
  *(_OWORD *)(a1 + 784) = 0u;
  uint64_t v51 = a1 + 432;
  RB::UntypedTable::UntypedTable(a1 + 800, 0, 0, 0, (void (*)(void *))RB::Device::Device(RBDevice *,objc_object  {objcproto9MTLDevice}*)::$_3::__invoke<RB::TextureCache *>, (RB::Heap *)(a1 + 304));
  uint64_t v48 = a1 + 400;
  uint64_t v49 = a1 + 376;
  uint64_t v50 = a1 + 344;
  uint64_t v47 = a1 + 880;
  RB::UntypedTable::UntypedTable(a1 + 880, 0, 0, 0, (void (*)(void *))RB::Device::Device(RBDevice *,objc_object  {objcproto9MTLDevice}*)::$_4::__invoke, (RB::Heap *)(a1 + 304));
  uint64_t v52 = a1 + 292;
  uint64_t v45 = a1 + 960;
  uint64_t v46 = a1 + 800;
  *(void *)(a1 + 976) = 0;
  *(_OWORD *)(a1 + 960) = 0u;
  for (uint64_t i = 1001; i != 1008; ++i)
  {
    if ((objc_msgSend(*(id *)(a1 + 24), "supportsFamily:", i, v45, v46, v47, v48, v49, v50, v51, v52) & 1) == 0) {
      break;
    }
    *size_t v7 = i + 24;
  }
  unsigned __int16 v10 = RB::debug_BOOL((RB *)"RB_USE_BINARY_ARCHIVE", v9);
  if (v10 >= 0x100u) {
    char v12 = v10 != 0;
  }
  else {
    char v12 = objc_msgSend((id)objc_msgSend(MEMORY[0x263F12800], "sharedCaptureManager"), "supportsDestination:", 2) ^ 1;
  }
  *(unsigned char *)(a1 + 282) = v12;
  uint64_t v13 = RB::debug_BOOL((RB *)"RB_LOG_PIPELINES", v11);
  char v15 = v13;
  uint64_t v16 = 256;
  if ((unsigned __int16)v13 <= 0x100u) {
    char v15 = 0;
  }
  *(unsigned char *)(a1 + 552) = v15 != 0;
  uint64_t v17 = -4;
  if (*(unsigned char *)(a1 + 283)) {
    uint64_t v16 = 4;
  }
  else {
    uint64_t v17 = -256;
  }
  uint64_t v18 = (v16 + 7) & v17;
  uint64_t v19 = (v18 + v16 + 16) & v17;
  MEMORY[0x270FA5388](v13, v14);
  float v21 = (uint64_t *)((char *)&v45 - v20);
  bzero((char *)&v45 - v20, v19 + 8);
  *float v21 = 0x3000200000001;
  unsigned __int32 v22 = (char *)v21 + v18;
  *(_OWORD *)unsigned __int32 v22 = xmmword_21421A6D0;
  *((_DWORD *)v22 + 4) = 4;
  *(void *)((char *)v21 + v19) = 0x7000600040005;
  uint64_t v24 = RB::Buffer::alloc((id *)a1, (RB::Device *)(v19 + 8), (uint64_t)v21, v23);
  if (!v24) {
    RB::precondition_failure((RB *)"unable to create quad buffer", v25);
  }
  *(void *)(a1 + 80) = v24;
  *(_OWORD *)(a1 + 88) = xmmword_21421A6E0;
  *(void *)(a1 + 104) = v24;
  *(void *)(a1 + 112) = v18;
  *(void *)(a1 + 120) = 20;
  *(void *)(a1 + 128) = v24;
  *(void *)(a1 + 136) = v19;
  *(void *)(a1 + 144) = 8;
  unsigned __int16 v26 = RB::debug_BOOL((RB *)"RB_STENCIL_BUFFER", v25);
  if ((_BYTE)v26) {
    BOOL v28 = 0;
  }
  else {
    BOOL v28 = v26 >= 0x100u;
  }
  char v29 = !v28;
  *(unsigned char *)(a1 + 281) = v29;
  __int16 v30 = RB::debug_BOOL((RB *)"RB_DEPTH_BUFFER", v27);
  int v32 = *(unsigned __int8 *)(a1 + 283);
  if ((v30 & 0xFF00) != 0) {
    char v33 = v30;
  }
  else {
    char v33 = *(unsigned char *)(a1 + 283);
  }
  *(unsigned char *)(a1 + 280) = v33 != 0;
  if (v32)
  {
    uint64_t v34 = 0;
    *(unsigned char *)(a1 + 284) = 1;
    while (1)
    {
      uint64_t v56 = 0;
      long long v54 = 0u;
      long long v55 = 0u;
      *(_OWORD *)__str = 0u;
      MTLPixelFormatGetInfoForDevice();
      if ((__str[8] & 2) == 0) {
        break;
      }
      v34 += 8;
      if (v34 == 24) {
        goto LABEL_28;
      }
    }
    *(unsigned char *)(a1 + 284) = 0;
  }
LABEL_28:
  unsigned __int16 v35 = RB::debug_BOOL((RB *)"RB_FRAGMENT_WRITES", v31);
  if (v35 >= 0x100u)
  {
    char v37 = v35 != 0;
  }
  else if (*v7 <= 3u)
  {
    char v37 = [*(id *)(a1 + 24) supportsFamily:3003];
  }
  else
  {
    char v37 = 1;
  }
  *(unsigned char *)(a1 + 285) = v37;
  unsigned __int16 v38 = RB::debug_BOOL((RB *)"RB_TEXTURE_SWIZZLE", v36);
  if (v38 >= 0x100u) {
    BOOL v40 = v38 != 0;
  }
  else {
    BOOL v40 = *v7 > 2u;
  }
  *(unsigned char *)(a1 + 286) = v40;
  uint64_t v41 = RB::debug_int((RB *)"RB_MAX_TEXTURE_SIZE", v39);
  if ((v41 & 0xFF00000000) == 0)
  {
    if (*v7 <= 2u) {
      LODWORD(v41) = 0x2000;
    }
    else {
      LODWORD(v41) = 0x4000;
    }
  }
  *(_DWORD *)(a1 + 288) = v41;
  unsigned __int16 v43 = RB::debug_BOOL((RB *)"RB_FUNCTION_POINTERS", v42);
  if (v43 >= 0x100u)
  {
    char v44 = v43 != 0;
  }
  else if (*v7 < 6u)
  {
    char v44 = 0;
  }
  else
  {
    char v44 = [a3 supportsFunctionPointersFromRender];
  }
  *(unsigned char *)(a1 + 287) = v44;
  operator new();
}

void sub_21410CCC0(_Unwind_Exception *a1)
{
  uint64_t v6 = *v3;
  *CFStringRef v3 = 0;
  size_t v7 = *(RB::UntypedTable **)(v4 - 200);
  if (v6) {
    std::default_delete<RB::SharedSurfaceGroup>::operator()[abi:nn180100]((uint64_t)v3, v6);
  }
  std::unique_ptr<RB::GlyphPathCache>::reset[abi:nn180100](*(uint64_t **)(v4 - 208), 0);
  RB::UntypedTable::~UntypedTable(*(RB::UntypedTable **)(v4 - 192));
  RB::UntypedTable::~UntypedTable(v7);
  uint64_t v9 = *(uint64_t **)(v4 - 176);
  uint64_t v8 = *(uint64_t **)(v4 - 168);
  unsigned __int16 v10 = *(uint64_t **)(v4 - 184);
  for (uint64_t i = 0; i != -192; i -= 8)

  for (uint64_t j = 0; j != -48; j -= 8)
  std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::~__hash_table(v1 + 512);
  RB::UntypedTable::~UntypedTable(*(RB::UntypedTable **)(v4 - 160));
  std::__list_imp<RB::refcounted_ptr<RB::Texture>>::clear(v10);
  std::__list_imp<RB::refcounted_ptr<RB::Texture>>::clear(v9);
  std::__list_imp<RB::refcounted_ptr<RB::Texture>>::clear(v8);
  RB::Heap::~Heap(v2);
  RB::vector<RB::Device::FrameContinuation,2ul,unsigned long>::~vector((char *)(v1 + 200));
  uint64_t v13 = *(_DWORD **)(v1 + 176);
  if (v13)
  {
    int v14 = v13[2] - 1;
    void v13[2] = v14;
    if (!v14) {
      (*(void (**)(_DWORD *))(*(void *)v13 + 8))(v13);
    }
  }
  char v15 = *(_DWORD **)(v1 + 168);
  if (v15)
  {
    int v16 = v15[2] - 1;
    float64x2_t v15[2] = v16;
    if (!v16) {
      (*(void (**)(_DWORD *))(*(void *)v15 + 8))(v15);
    }
  }
  uint64_t v17 = *(_DWORD **)(v1 + 160);
  if (v17)
  {
    int v18 = v17[2] - 1;
    v17[2] = v18;
    if (!v18) {
      (*(void (**)(_DWORD *))(*(void *)v17 + 8))(v17);
    }
  }

  _Unwind_Resume(a1);
}

uint64_t RB::debug_BOOL(RB *this, const char *a2)
{
  RB::Config::debug_value(this, &v7);
  uint64_t v2 = v7;
  uint64_t v4 = RB::Config::int_value((const __CFString *)v7, v3);
  if (v2) {
    CFRelease(v2);
  }
  if (v4) {
    BOOL v5 = (v4 & 0xFF00000000) != 0;
  }
  else {
    BOOL v5 = 0;
  }
  return v5 | (((v4 & 0xFF00000000) != 0) << 8);
}

uint64_t RB::debug_int(RB *this, const char *a2)
{
  RB::Config::debug_value(this, &v6);
  uint64_t v2 = v6;
  uint64_t v4 = RB::Config::int_value((const __CFString *)v6, v3);
  if (v2) {
    CFRelease(v2);
  }
  return v4;
}

void RB::Config::debug_value(RB::Config *this@<X0>, void *a2@<X8>)
{
  BOOL v5 = getenv((const char *)this);
  if (v5)
  {
    uint64_t v6 = (const UInt8 *)v5;
    size_t v7 = strlen(v5);
    *a2 = CFStringCreateWithBytesNoCopy(0, v6, v7, 0x8000100u, 1u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
  }
  else
  {
    {
      RB::Config::debug_value(char const*)::allow_defaults = RB::Config::debug_value(char const*)::$_0::operator()();
    }
    if (RB::Config::debug_value(char const*)::allow_defaults)
    {
      CFStringRef v8 = key;
      CFStringRef v9 = (const __CFString *)*MEMORY[0x263EFFE70];
      CFStringRef v10 = (const __CFString *)*MEMORY[0x263EFFE50];
      CFPropertyListRef v11 = CFPreferencesCopyValue(key, (CFStringRef)*MEMORY[0x263EFFE60], (CFStringRef)*MEMORY[0x263EFFE70], (CFStringRef)*MEMORY[0x263EFFE50]);
      *a2 = v11;
      if (!v11)
      {
        CFPropertyListRef v12 = CFPreferencesCopyValue(v8, (CFStringRef)*MEMORY[0x263EFFE48], v9, v10);
        *a2 = v12;
        if (!v12) {
          *a2 = CFPreferencesCopyValue(v8, @"com.apple.RenderBox", v9, v10);
        }
      }
      if (v8) {
        CFRelease(v8);
      }
    }
    else
    {
      *a2 = 0;
    }
  }
}

uint64_t RB::Config::int_value(const __CFString *this, const void *a2)
{
  if (!this) {
    goto LABEL_19;
  }
  CFTypeID v3 = CFGetTypeID(this);
  if (v3 != CFBooleanGetTypeID())
  {
    if (v3 == CFNumberGetTypeID())
    {
      int valuePtr = 0;
      if (CFNumberGetValue((CFNumberRef)this, kCFNumberIntType, &valuePtr))
      {
        Boolean Value = valuePtr;
        unsigned int v5 = valuePtr & 0xFFFFFF00;
        goto LABEL_8;
      }
    }
    else if (v3 == CFStringGetTypeID())
    {
      Boolean Value = 1;
      if (CFStringCompare(this, @"yes", 1uLL) == kCFCompareEqualTo) {
        goto LABEL_4;
      }
      Boolean Value = 1;
      if (CFStringCompare(this, @"true", 1uLL) == kCFCompareEqualTo)
      {
        unsigned int v5 = 0;
        uint64_t v6 = 0x100000000;
        return v6 | v5 | Value;
      }
      if (CFStringCompare(this, @"no", 1uLL) == kCFCompareEqualTo
        || CFStringCompare(this, @"false", 1uLL) == kCFCompareEqualTo)
      {
        Boolean Value = 0;
        goto LABEL_4;
      }
      if (CFStringGetLength(this) >= 1)
      {
        CharacterAtIndeCGFloat x = CFStringGetCharacterAtIndex(this, 0);
        if (CharacterAtIndex == 43 || CharacterAtIndex == 45 || (CharacterAtIndex - 48) <= 9)
        {
          IntBoolean Value = CFStringGetIntValue(this);
          Boolean Value = IntValue;
          unsigned int v5 = IntValue & 0xFFFFFF00;
          goto LABEL_8;
        }
      }
    }
LABEL_19:
    uint64_t v6 = 0;
    Boolean Value = 0;
    unsigned int v5 = 0;
    return v6 | v5 | Value;
  }
  Boolean Value = CFBooleanGetValue((CFBooleanRef)this);
LABEL_4:
  unsigned int v5 = 0;
LABEL_8:
  uint64_t v6 = 0x100000000;
  return v6 | v5 | Value;
}

BOOL RB::Config::debug_value(char const*)::$_0::operator()()
{
  CFStringRef v0 = (const __CFString *)CFPreferencesCopyValue(@"RBAllowDebuggingDefaults", (CFStringRef)*MEMORY[0x263EFFE48], (CFStringRef)*MEMORY[0x263EFFE70], (CFStringRef)*MEMORY[0x263EFFE50]);
  uint64_t v2 = RB::Config::int_value(v0, v1);
  if (v0) {
    CFRelease(v0);
  }
  return (v2 & 0xFF00000000) != 0 && v2 != 0;
}

uint64_t RB::Buffer::alloc(id *this, RB::Device *a2, uint64_t a3, const void *a4)
{
  if ([this[3] newBufferWithBytes:a3 length:a2 options:0]) {
    operator new();
  }
  return 0;
}

void sub_21410D33C(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10A1C40C08ACA79);
  _Unwind_Resume(a1);
}

uint64_t RB::Buffer::alloc(id *this, RB::Device *a2)
{
  if ([this[3] newBufferWithLength:a2 options:0]) {
    operator new();
  }
  return 0;
}

void sub_21410D3D4(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10A1C40C08ACA79);
  _Unwind_Resume(a1);
}

uint64_t RB::Buffer::Buffer(uint64_t a1, void *a2, uint64_t a3)
{
  *(void *)RB::Resource::Resource(a1, (uint64_t)a2) = &unk_26C4EDAE0;
  if (!a3) {
    a3 = [a2 length];
  }
  *(void *)(a1 + 48) = a3;
  *(void *)(a1 + 56) = [a2 contents];
  return a1;
}

void sub_21410D46C(_Unwind_Exception *a1)
{
  RB::Resource::~Resource(v1);
  _Unwind_Resume(a1);
}

void RB::SharedSurfaceGroup::SharedSurfaceGroup(RB::SharedSurfaceGroup *this, RB::Device *a2)
{
  *(void *)this = a2;
  operator new();
}

void sub_21410D4E4(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x1081C40A869C1B6);
  _Unwind_Resume(a1);
}

RB::Drawable *RB::Drawable::Drawable(RB::Drawable *this, intptr_t value)
{
  *((_DWORD *)this + 2) = 1;
  *((_DWORD *)this + 3) = value;
  *(void *)this = &unk_26C4EDD68;
  if (value) {
    dispatch_semaphore_t v3 = dispatch_semaphore_create(value);
  }
  else {
    dispatch_semaphore_t v3 = 0;
  }
  *((void *)this + 2) = v3;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0x3FB999999999999ALL;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *((void *)this + 41) = 0;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  return this;
}

const char *RB::debug_byte_size(RB *this, const char *a2, unint64_t a3, unint64_t a4)
{
  RB::Config::debug_value(this, &v10);
  size_t v7 = v10;
  CFStringRef v8 = RB::Config::byte_size_value((const __CFString *)v10, a2, a3, a4);
  if (v7) {
    CFRelease(v7);
  }
  return v8;
}

const char *RB::Config::byte_size_value(const __CFString *this, const char *a2, unint64_t a3, unint64_t a4)
{
  valuePtr[32] = *MEMORY[0x263EF8340];
  if (this)
  {
    CFTypeID v8 = CFGetTypeID(this);
    if (v8 == CFNumberGetTypeID())
    {
      valuePtr[0] = 0;
      if (CFNumberGetValue((CFNumberRef)this, kCFNumberLongType, valuePtr)) {
        return (const char *)valuePtr[0];
      }
    }
    else if (v8 == CFStringGetTypeID() && CFStringGetCString(this, (char *)valuePtr, 256, 0x8000100u))
    {
      return RB::parse_byte_size((RB *)valuePtr, a2, a3, a4);
    }
  }
  return a2;
}

uint64_t RBColorModeWorkingColorSpace(unsigned int a1)
{
  if (a1 > 0xF) {
    return 0;
  }
  else {
    return dword_21421A5E8[a1];
  }
}

uint64_t RB::Coverage::anonymous namespace'::visit_rounded_rect(void (***a1)(void, uint64_t *), float64x2_t *a2, int a3, uint64_t a4, unsigned int a5, float64_t a6, float64_t a7, float64_t a8, float64_t a9, float a10, float a11)
{
  char v11 = a5;
  v45.f64[0] = a6;
  v45.f64[1] = a7;
  v46.f64[0] = a8;
  v46.f64[1] = a9;
  if (a6 == a7 && a7 == a8 && a8 == a9 && a9 == a6)
  {
  }
  else
  {
    if (a3 && a5 > 1) {
      return 0;
    }
    if (a4)
    {
      long long v21 = *(_OWORD *)(a4 + 16);
      double v22 = *(double *)(a4 + 24);
      double v23 = *(double *)(a4 + 8);
      if (*(double *)a4 != v22 || v23 != 0.0 || *(double *)&v21 != 0.0)
      {
        uint64_t result = 0;
        if (v22 != 0.0) {
          return result;
        }
        if (*(double *)a4 != 0.0 || v23 != *(double *)&v21) {
          return result;
        }
      }
    }
    RB::clamp_corner_radii((uint64_t)&v45, a2[1].f64);
    if (RB::corners_are_uneven_pill(v45.f64, a2[1].f64)) {
      return 0;
    }
    float32x4_t v27 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v45), v46);
    float64x2_t v30 = a2[1];
    float32x2_t v28 = vcvt_f32_f64(*a2);
    *(float32x2_t *)&v30.f64[0] = vcvt_f32_f64(v30);
    *(int32x2_t *)v26.i8 = vcltz_f32(*(float32x2_t *)&v30.f64[0]);
    float32x2_t v29 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(v26), (int8x8_t)vadd_f32(*(float32x2_t *)&v30.f64[0], v28), (int8x8_t)v28);
    *(void *)&v30.f64[0] &= 0x7FFFFFFF7FFFFFFFuLL;
    if (a4)
    {
      float32x4_t v36 = v27;
      float32x2_t v29 = RB::operator*((float64x2_t *)a4, v29, (int32x4_t)v30);
      double v31 = *(double *)(a4 + 8);
      double v32 = fabs(*(double *)a4);
      double v33 = fabs(v31);
      if (v31 != 0.0) {
        double v32 = v33;
      }
      float v34 = v32;
      float32x4_t v27 = vmulq_n_f32(v36, v34);
    }
    if (a3 == 1)
    {
      float32x4_t v27 = vmulq_f32(v27, (float32x4_t)vdupq_n_s32(0x3FA33333u));
      char v35 = 4;
    }
    else if (a3)
    {
      char v35 = 2;
    }
    else
    {
      char v35 = 3;
    }
    v37[0] = v29;
    v37[1] = *(void *)&v30.f64[0];
    float32x4_t v38 = v27;
    int v39 = 1065353216;
    float v40 = a10;
    float v41 = a11;
    char v42 = v35;
    char v43 = v11;
    char v44 = 0;
    (**a1)(a1, v37);
    return 1;
  }
}

float64_t RB::clamp_corner_radii(uint64_t a1, double *a2)
{
  double v2 = fabs(*a2);
  double v3 = fabs(a2[1]);
  if (v2 >= v3) {
    *(double *)&uint64_t v4 = v2;
  }
  else {
    *(double *)&uint64_t v4 = v3;
  }
  float64x2_t v5 = (float64x2_t)vbicq_s8(*(int8x16_t *)a1, (int8x16_t)vcltzq_f64(*(float64x2_t *)a1));
  float64x2_t v6 = (float64x2_t)vdupq_lane_s64(v4, 0);
  float64x2_t v7 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v5, v6), (int8x16_t)v6, (int8x16_t)v5);
  float64x2_t v8 = (float64x2_t)vbicq_s8(*(int8x16_t *)(a1 + 16), (int8x16_t)vcltzq_f64(*(float64x2_t *)(a1 + 16)));
  float64x2_t v9 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v8, v6), (int8x16_t)v6, (int8x16_t)v8);
  *(float64x2_t *)a1 = v7;
  *(float64x2_t *)(a1 + 16) = v9;
  double v10 = v7.f64[1];
  double v11 = v2 - vaddvq_f64(v7);
  if (v7.f64[0] != v7.f64[1] && v11 < 0.0)
  {
    double v12 = v7.f64[1] - v7.f64[0];
    if (v7.f64[1] - v7.f64[0] <= 0.0)
    {
      if (v11 >= v12) {
        double v12 = v11;
      }
      v7.f64[0] = v12 + v7.f64[0];
      *(float64_t *)a1 = v7.f64[0];
    }
    else
    {
      double v12 = -v12;
      if (v11 >= v12) {
        double v12 = v11;
      }
      double v10 = v12 + v7.f64[1];
      *(double *)(a1 + 8) = v12 + v7.f64[1];
    }
    double v11 = v11 - v12;
  }
  if (v11 < 0.0)
  {
    float64_t v13 = v7.f64[0] * v11 / (v10 + v7.f64[0]);
    v7.f64[0] = v13 + v7.f64[0];
    double v10 = v10 + v11 - v13;
    *(float64_t *)a1 = v7.f64[0];
    *(double *)(a1 + 8) = v10;
  }
  double v14 = v9.f64[1];
  double v15 = v2 - vaddvq_f64(v9);
  if (v9.f64[1] != v9.f64[0] && v15 < 0.0)
  {
    double v16 = v9.f64[0] - v9.f64[1];
    if (v9.f64[0] - v9.f64[1] <= 0.0)
    {
      if (v15 >= v16) {
        double v16 = v15;
      }
      double v14 = v16 + v9.f64[1];
      *(double *)(a1 + 24) = v16 + v9.f64[1];
    }
    else
    {
      double v16 = -v16;
      if (v15 >= v16) {
        double v16 = v15;
      }
      v9.f64[0] = v16 + v9.f64[0];
      *(float64_t *)(a1 + 16) = v9.f64[0];
    }
    double v15 = v15 - v16;
  }
  if (v15 < 0.0)
  {
    double v17 = v14 * v15 / (v9.f64[0] + v14);
    double v14 = v17 + v14;
    v9.f64[0] = v9.f64[0] + v15 - v17;
    *(float64_t *)(a1 + 16) = v9.f64[0];
    *(double *)(a1 + 24) = v14;
  }
  double v18 = v3 - (v7.f64[0] + v14);
  if (v7.f64[0] != v14 && v18 < 0.0)
  {
    double v19 = v14 - v7.f64[0];
    if (v14 - v7.f64[0] <= 0.0)
    {
      if (v18 >= v19) {
        double v19 = v3 - (v7.f64[0] + v14);
      }
      v7.f64[0] = v19 + v7.f64[0];
      *(float64_t *)a1 = v7.f64[0];
    }
    else
    {
      double v19 = -v19;
      if (v18 >= v19) {
        double v19 = v3 - (v7.f64[0] + v14);
      }
      double v14 = v19 + v14;
      *(double *)(a1 + 24) = v14;
    }
    double v18 = v18 - v19;
  }
  if (v18 < 0.0)
  {
    float64_t v20 = v7.f64[0] * v18 / (v14 + v7.f64[0]);
    *(float64_t *)a1 = v20 + v7.f64[0];
    *(double *)(a1 + 24) = v14 + v18 - v20;
  }
  double v21 = v3 - (v10 + v9.f64[0]);
  if (v10 != v9.f64[0] && v21 < 0.0)
  {
    double v22 = v9.f64[0] - v10;
    if (v9.f64[0] - v10 <= 0.0)
    {
      if (v21 >= v22) {
        double v22 = v21;
      }
      double v10 = v22 + v10;
      *(double *)(a1 + 8) = v10;
    }
    else
    {
      double v22 = -v22;
      if (v21 >= v22) {
        double v22 = v21;
      }
      v9.f64[0] = v22 + v9.f64[0];
      *(float64_t *)(a1 + 16) = v9.f64[0];
    }
    double v21 = v21 - v22;
  }
  if (v21 < 0.0)
  {
    double v23 = v10 * v21 / (v9.f64[0] + v10);
    v9.f64[0] = v9.f64[0] + v21 - v23;
    *(double *)(a1 + 8) = v23 + v10;
    *(float64_t *)(a1 + 16) = v9.f64[0];
  }
  return v9.f64[0];
}

BOOL RB::corners_are_uneven_pill(double *a1, double *a2)
{
  double v2 = *a1;
  double v3 = a1[1];
  double v4 = v3 + *a1;
  double v6 = a1[2];
  double v5 = a1[3];
  if (v4 < v6 + v5) {
    double v4 = v6 + v5;
  }
  if (v5 + *a1 >= v6 + v3) {
    double v7 = v5 + *a1;
  }
  else {
    double v7 = v6 + v3;
  }
  BOOL result = 0;
  if (v4 * 1.52866495 > fabs(*a2) || v7 * 1.52866495 > fabs(a2[1]))
  {
    BOOL v8 = v3 == v6 && v2 == v3;
    BOOL v9 = v8 && v4 == v7;
    BOOL v10 = v9 && v5 == v2;
    if (!v10 || v6 != v5) {
      return 1;
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericClipCopyVisitor<RB::Coverage::Path>::visit(uint64_t a1, _OWORD *a2, int8x16_t a3)
{
  uint64_t result = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive&,float &,RB::ClipMode &,RB::AffineTransform const*&>(*(size_t **)(a1 + 8), a3, *(void *)(a1 + 8), a2, (unsigned __int32 *)(*(void *)(a1 + 16) + 88), (int *)(a1 + 24), (uint64_t *)(a1 + 32));
  *(void *)(a1 + 40) = result;
  return result;
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive&,float &,RB::ClipMode &,RB::AffineTransform const*&>(size_t *a1, int8x16_t a2, uint64_t a3, _OWORD *a4, unsigned __int32 *a5, int *a6, uint64_t *a7)
{
  uint64_t v11 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v11 + 128 > a1[3]) {
    uint64_t v11 = RB::Heap::alloc_slow(a1, 0x80uLL, 15);
  }
  else {
    a1[2] = v11 + 128;
  }
  a2.i32[0] = *a5;
  int v12 = *a6;
  uint64_t v13 = *a7;
  *(void *)(v11 + 16) = 0;
  *(void *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(void *)(v11 + 32) = 0;
  *(_WORD *)(v11 + 44) = v12;
  *(void *)uint64_t v11 = &unk_26C4E8E48;
  *(void *)(v11 + 48) = v13;
  int32x4_t v14 = *(int32x4_t *)a4;
  int8x16_t v15 = *((int8x16_t *)a4 + 1);
  int32x4_t v16 = *(int32x4_t *)((char *)a4 + 31);
  *(int32x4_t *)(v11 + 95) = v16;
  *(int32x4_t *)(v11 + 64) = v14;
  *(int8x16_t *)(v11 + 80) = v15;
  *(_DWORD *)(v11 + 112) = a2.i32[0];
  RB::DisplayList::GenericClip<RB::Coverage::Primitive>::update_bounds(v11, a2, v14, v15, v16);
  return v11;
}

void RB::DisplayList::GenericClip<RB::Coverage::Primitive>::update_bounds(uint64_t a1, int8x16_t a2, int32x4_t a3, int8x16_t a4, int32x4_t a5)
{
  if (*(unsigned char *)(a1 + 44) == 1)
  {
    *(void *)(a1 + 16) = 0x100000001000000;
    *(int32x2_t *)(a1 + 24) = vdup_n_s32(0x7F7FFFFFu);
  }
  else if (!*(unsigned char *)(a1 + 44))
  {
    a2.i32[0] = *(_DWORD *)(a1 + 112);
    if (*(float *)a2.i32 == 0.0)
    {
      *(void *)(a1 + 16) = 0;
      *(void *)(a1 + 24) = 0;
    }
    else
    {
      *(float32x2_t *)(a1 + 16) = RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), *(float64x2_t **)(a1 + 48), a2, a3, a4, a5);
      *(void *)(a1 + 24) = v6;
      if (*(float *)(a1 + 112) == 1.0)
      {
        if (RB::Coverage::Primitive::rectangular((RB::Coverage::Primitive *)(a1 + 64), *(int32x4_t **)(a1 + 48)))*(unsigned char *)(a1 + 45) |= 1u; {
      }
        }
    }
  }
}

uint64_t RB::Coverage::Primitive::rectangular(RB::Coverage::Primitive *this, int32x4_t *a2)
{
  unsigned int v2 = *((unsigned __int8 *)this + 44);
  if (v2 < 2) {
    return 1;
  }
  if ((*((unsigned char *)this + 46) & 5) != 0) {
    return 0;
  }
  unsigned int v5 = *((unsigned __int8 *)this + 45);
  if (v5 > 1) {
    return 0;
  }
  float v6 = *((float *)this + 9);
  if (v6 > 0.0 && v6 < fmaxf(COERCE_FLOAT(*((void *)this + 1)), COERCE_FLOAT(HIDWORD(*((void *)this + 1))))) {
    return 0;
  }
  uint64_t result = 0;
  switch(v2)
  {
    case 3u:
    case 4u:
      unsigned int v7 = vmaxvq_u32((uint32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(*((float32x4_t *)this + 1))));
      goto LABEL_10;
    case 5u:
    case 7u:
      return result;
    case 6u:
    case 8u:
      uint32x2_t v8 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(*(float32x2_t *)((char *)this + 8)));
      unsigned int v7 = vpmax_u32(v8, v8).u32[0];
LABEL_10:
      if ((v7 & 0x80000000) == 0) {
        goto LABEL_11;
      }
      return 0;
    case 9u:
    case 0xAu:
    case 0xBu:
      abort();
    default:
LABEL_11:
      int32x4_t v10 = *a2;
      int32x4_t v9 = a2[1];
      if (*(double *)&a2->i64[1] != 0.0 || *(double *)v9.i64 != 0.0)
      {
        uint64_t result = 0;
        if (*(double *)v10.i64 != 0.0 || *(double *)&v9.i64[1] != 0.0) {
          return result;
        }
      }
      if (v5 == 1) {
        return 1;
      }
      v10.i64[0] = *((void *)this + 1);
      *(float32x2_t *)&long long v11 = RB::operator*((float64x2_t *)a2, *(float32x2_t *)this, v10);
      *(void *)&long long v17 = v11;
      *((float32x2_t *)&v17 + 1) = v12;
      v14.i32[0] = *((_DWORD *)this + 9);
      if (*(float *)v14.i32 > 0.0)
      {
        *(float *)v14.i32 = *(float *)v14.i32 * 0.5;
        *(int32x2_t *)v13.i8 = vcgt_f32((float32x2_t)vdup_n_s32(0x7F7FFFFFu), v12);
        int8x16_t v15 = (int8x16_t)vcltzq_s32(v13);
        int8x8_t v16 = (int8x8_t)vmvnq_s8(v15).u64[0];
        *(int8x8_t *)&long long v11 = vorr_s8(vand_s8((int8x8_t)vsub_f32(*(float32x2_t *)&v11, (float32x2_t)vdup_lane_s32(v14, 0)), *(int8x8_t *)v15.i8), vand_s8(*(int8x8_t *)&v11, v16));
        *((int8x8_t *)&v11 + 1) = vorr_s8(vand_s8((int8x8_t)vmla_n_f32(v12, (float32x2_t)0x4000000040000000, *(float *)v14.i32), *(int8x8_t *)v15.i8), vand_s8((int8x8_t)v12, v16));
        long long v17 = v11;
      }
      LODWORD(v11) = 981668463;
      uint64_t result = RB::Rect::is_integral((float32x2_t *)&v17, *(int32x2_t *)&v11);
      break;
  }
  return result;
}

void RB::DisplayList::LayerTask::render(RB::DisplayList::LayerTask *this, int32x2_t *a2, char *a3, double a4, __n128 a5, double a6, double a7, double a8, int32x4_t a9)
{
  long long v11 = this;
  *((void *)a3 + 4) = this;
  a5.n128_u64[0] = *((void *)this + 7);
  *((void *)a3 + 5) = *((void *)this + 13);
  *((void *)a3 + 6) = a5.n128_u64[0];
  float32x2_t v12 = (int32x2_t *)(a3 + 56);
  *(_OWORD *)(a3 + 56) = *(_OWORD *)(a3 + 40);
  int32x2_t v13 = *(int32x2_t *)((char *)this + 64);
  a5.n128_u64[0] = (unint64_t)vsub_s32(v13, *(int32x2_t *)((char *)this + 104));
  __n128 v79 = a5;
  if ((*((unsigned char *)this + 128) & 2) != 0
    || (*(unsigned char *)(*((void *)this + 12) + 60) & 1) != 0 && !*((void *)this + 3))
  {
    int32x2_t v14 = *(int32x2_t *)(a3 + 64);
    a2[20] = v13;
    a2[21] = v14;
    uint64_t v15 = *((void *)this + 12);
    if (*(unsigned char *)(v15 + 60))
    {
      int8x8_t v16 = (int32x2_t *)*((void *)this + 2);
      if (!v16)
      {
        long long v17 = this;
        double v18 = this;
        while (1)
        {
          double v18 = (RB::DisplayList::LayerTask *)*((void *)v18 + 6);
          if (!v18) {
            break;
          }
          if (*((RB::DisplayList::LayerTask **)v18 + 3) == v17)
          {
            int8x8_t v16 = (int32x2_t *)*((void *)v18 + 2);
            long long v17 = v18;
            if (v16) {
              goto LABEL_13;
            }
          }
        }
        int8x8_t v16 = 0;
      }
LABEL_13:
      if (*(float *)(v15 + 48) == 0.0) {
        float v19 = 1.0;
      }
      else {
        float v19 = *(float *)(v15 + 48);
      }
      if (v16 && (int v20 = *(unsigned __int8 *)(v15 + 67)) != 0)
      {
        while (1)
        {
          float v21 = *(float *)(*(void *)&v16[12] + 48);
          if (v21 == 0.0) {
            float v21 = 1.0;
          }
          double v22 = (int32x2_t *)v16[2];
          if (!v22) {
            break;
          }
LABEL_21:
          float v19 = v21 * v19;
          int8x8_t v16 = v22;
          if (!--v20) {
            goto LABEL_29;
          }
        }
        double v23 = v16;
        while (1)
        {
          double v23 = (int32x2_t *)v23[6];
          if (!v23) {
            break;
          }
          if ((int32x2_t *)v23[3] == v16)
          {
            double v22 = (int32x2_t *)v23[2];
            int8x8_t v16 = v23;
            if (v22) {
              goto LABEL_21;
            }
          }
        }
      }
      else
      {
        double v22 = v16;
        if (v16)
        {
LABEL_29:
          if (*(void *)(*(void *)&v22[11] + 16))
          {
            int32x2_t v75 = vsub_s32(v22[8], v22[13]);
            int32x2_t v24 = *(int32x2_t *)(a3 + 64);
            uint32x2_t v25 = (uint32x2_t)vceq_s32(v24, (int32x2_t)0x8000000080000000);
            int8x8_t v26 = (int8x8_t)vdup_n_s32(0x7F7FFFFFu);
            float32x2_t v27 = (float32x2_t)v26;
            a9.i64[0] = 0x100000001000000;
            if ((vpmin_u32(v25, v25).u32[0] & 0x80000000) == 0)
            {
              *(float32x2_t *)a9.i8 = vcvt_f32_s32(*v12);
              float32x2_t v27 = vcvt_f32_s32(v24);
            }
            v24.i32[0] = 0;
            float v77 = v19;
            float v28 = 1.0 / v19;
            float32x2_t v83 = vmul_n_f32(*(float32x2_t *)a9.i8, v28);
            float32x2_t v84 = vmul_n_f32(v27, v28);
            *(int32x2_t *)a9.i8 = v22[15];
            uint32x2_t v29 = (uint32x2_t)vceq_s32(*(int32x2_t *)a9.i8, (int32x2_t)0x8000000080000000);
            int8x8_t v30 = (int8x8_t)vdup_lane_s32(vcgt_s32(v24, (int32x2_t)vpmin_u32(v29, v29)), 0);
            int8x8_t v31 = (int8x8_t)vcvt_f32_s32(*(int32x2_t *)a9.i8);
            RB::Rect::intersect(&v83, COERCE_DOUBLE(vbsl_s8(v30, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v22[14]))), (float32x2_t)vbsl_s8(v30, v26, v31), *(double *)&v30, *(double *)&v31, *(double *)&v22[14], a9);
            float32x2_t v32 = vmul_n_f32(v83, v77);
            *(float32x2_t *)&v80[0] = v32;
            *((float32x2_t *)&v80[0] + 1) = vmul_n_f32(v84, v77);
            v32.f32[0] = (float)v75.i32[0];
            float32x2_t v33 = RB::Rect::translate(&v83, v32, (float)v75.i32[1]);
            v33.f32[0] = (float)v79.n128_i32[0];
            RB::Rect::translate((float32x2_t *)v80, v33, (float)v79.n128_i32[1]);
            if (fabsf(v77 + -1.0) < 0.25) {
              unsigned int v34 = 1;
            }
            else {
              unsigned int v34 = 7;
            }
            if (v77 == 1.0) {
              uint64_t v35 = 0;
            }
            else {
              uint64_t v35 = v34;
            }
            RB::DisplayList::Layer::blit((uint64_t)a3, a2, *(int32x2_t **)(*(void *)&v22[11] + 16), 0, 0, v35, 0, 0, v83, v84, *(double *)v80, *(float32x2_t *)((char *)v80 + 8), (__n128)0, 1.0, 0, 0);
            *(float *)a2[15].i32 = *(float *)a2[15].i32 + 1.0;
          }
        }
      }
    }
    else
    {
      RB::RenderPass::fill((uint64_t)a2, *((float32x4_t *)this + 9));
    }
  }
  float32x4_t v36 = (void *)*((void *)v11 + 20);
  if (v36)
  {
    int8x8_t v37 = (int8x8_t)vdup_n_s32(0x7F7FFFFFu);
    while (1)
    {
      float32x4_t v38 = (const RB::DisplayList::Item *)v36[1];
      int v39 = (float32x2_t *)*((void *)v38 + 3);
      if (!v39) {
        break;
      }
      long long v93 = *(_OWORD *)v12->i8;
      RB::Bounds::Bounds(v92, v39[2], v39[3]);
      RB::Bounds::intersect((int32x2_t *)&v93, v92[0], v92[1]);
      int32x2_t v40 = *(int32x2_t *)((char *)&v93 + 8);
      uint32x2_t v41 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)&v93 + 8));
      if ((vpmax_u32(v41, v41).u32[0] & 0x80000000) == 0)
      {
        if (v39[1].i8[0]) {
          goto LABEL_49;
        }
        *(double *)&float32x2_t v42 = (*(double (**)(const RB::DisplayList::Item *, void))(*(void *)v38 + 144))(v38, 0);
        RB::Bounds::Bounds(v91, v42, v43);
        RB::Bounds::intersect((int32x2_t *)&v93, v91[0], v91[1]);
        int32x2_t v40 = *(int32x2_t *)((char *)&v93 + 8);
        uint32x2_t v44 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)&v93 + 8));
        if ((vpmax_u32(v44, v44).u32[0] & 0x80000000) == 0)
        {
          clip_indeCGFloat x = RB::DisplayList::LayerTask::find_clip_index(v11, v38);
          if ((clip_index & 0xFF00000000) != 0)
          {
            uint64_t v46 = *((void *)v11 + 26);
            uint64_t v47 = v46 + 48 * clip_index;
            int v49 = *(unsigned __int8 *)(v47 + 45);
            uint64_t v48 = (unsigned char *)(v47 + 45);
            if (v49)
            {
              uint64_t v50 = 1;
              goto LABEL_50;
            }
            unsigned int v74 = v12;
            unsigned int v78 = v11;
            float v53 = *(float *)a2[15].i32;
            long long v54 = (int32x2_t *)(v46 + 48 * clip_index);
            *(float *)a2[15].i32 = v53 + (float)(v54[5].i32[0] + ~v54[4].i32[1]);
            int32x2_t v55 = v54[3];
            a2[20] = vadd_s32(v54[2], (int32x2_t)v79.n128_u64[0]);
            a2[21] = v55;
            __n128 v52 = v79;
            uint64_t v56 = (void *)*((void *)v38 + 3);
            if (v56)
            {
              uint64_t v57 = v46 + 48 * clip_index;
              uint64_t v58 = (void *)(v57 + 8);
              int v76 = (unsigned int *)(v57 + 32);
              uint64_t v59 = 1;
              char v60 = 1;
              do
              {
                unint64_t v61 = v56[1] & 0xFFFFFFFFFFFFFFFELL;
                if ((*(unsigned char *)(v61 + 45) & 1) != 0 || (*v58 & v59) != 0) {
                  goto LABEL_75;
                }
                BOOL v62 = (v60 & 1) == 0;
                if (v60) {
                  unsigned int v63 = 21;
                }
                else {
                  unsigned int v63 = 22;
                }
                if (v62) {
                  unsigned int v64 = 20;
                }
                else {
                  unsigned int v64 = 19;
                }
                if (*(unsigned char *)(v61 + 44)) {
                  unsigned int v64 = 0;
                }
                if (*(unsigned char *)(v61 + 44) == 1) {
                  uint64_t v65 = v63;
                }
                else {
                  uint64_t v65 = v64;
                }
                if ((*(unsigned char *)(v61 + 45) & 2) != 0)
                {
                  task = (int32x2_t *)RB::DisplayList::LayerTask::find_task(v78, *(void *)(v61 + 48), *v76);
                  if (!task)
                  {
                    v67.i32[0] = 0;
                    int32x2_t v70 = a2[21];
                    uint32x2_t v71 = (uint32x2_t)vceq_s32(v70, (int32x2_t)0x8000000080000000);
                    int8x8_t v72 = (int8x8_t)vdup_lane_s32(vcgt_s32(v67, (int32x2_t)vpmin_u32(v71, v71)), 0);
                    float32x2_t v83 = (float32x2_t)vbsl_s8(v72, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(a2[20]));
                    float32x2_t v84 = (float32x2_t)vbsl_s8(v72, v37, (int8x8_t)vcvt_f32_s32(v70));
                    uint64_t v85 = 0;
                    uint64_t v86 = 0;
                    uint64_t v87 = 1065353216;
                    int v88 = 0;
                    __int16 v89 = 257;
                    v90 &= 0xF8u;
                    v80[0] = xmmword_2142181C0;
                    v80[1] = xmmword_2142181D0;
                    uint64_t v81 = 0;
                    uint64_t v82 = 0;
                    __int16 v95 = 0;
                    uint64_t v94 = 0;
                    RB::render_primitive((uint64_t)a2, (uint64_t)v80, (uint64_t)&v83, (uint64_t)&v94, 0, v65);
                    char v60 = 0;
                    __n128 v52 = v79;
                    goto LABEL_75;
                  }
                  RB::DisplayList::LayerTask::render(task, (uint64_t)a3, a2, 0, v65, v79.n128_f64[0], *(float *)(v61 + 56), v68, v69);
                }
                else
                {
                  (*(void (**)(unint64_t, char *, int32x2_t *, uint64_t, __n128))(*(void *)v61 + 56))(v56[1] & 0xFFFFFFFFFFFFFFFELL, a3, a2, v65, v52);
                }
                __n128 v52 = v79;
                char v60 = 0;
LABEL_75:
                v59 *= 2;
                uint64_t v56 = (void *)*v56;
              }
              while (v56);
            }
            uint64_t v50 = 1;
            *uint64_t v48 = 1;
            *(float *)a2[15].i32 = v53;
            int32x2_t v40 = *(int32x2_t *)((char *)&v93 + 8);
            long long v11 = v78;
            float32x2_t v12 = v74;
          }
          else
          {
LABEL_49:
            uint64_t v50 = 0;
LABEL_50:
            __n128 v52 = v79;
          }
          a2[20] = vadd_s32(*(int32x2_t *)&v93, (int32x2_t)v52.n128_u64[0]);
          a2[21] = v40;
LABEL_52:
          (*(void (**)(const RB::DisplayList::Item *, char *, int32x2_t *, uint64_t, void, __n128))(*(void *)v38 + 176))(v38, a3, a2, v50, *((_WORD *)v38 + 23) & 0x3F, v52);
          *(float *)a2[15].i32 = *(float *)a2[15].i32 + 1.0;
        }
      }
      float32x4_t v36 = (void *)*v36;
      if (!v36) {
        goto LABEL_79;
      }
    }
    uint64_t v50 = 0;
    int32x2_t v51 = *(int32x2_t *)(a3 + 64);
    a2[20] = vadd_s32(*(int32x2_t *)(a3 + 56), (int32x2_t)v79.n128_u64[0]);
    a2[21] = v51;
    __n128 v52 = v79;
    goto LABEL_52;
  }
LABEL_79:
  if (*((void *)v11 + 21)) {
    LOBYTE(v73) = 1;
  }
  else {
    int v73 = (*((unsigned __int8 *)v11 + 128) >> 2) & 1;
  }
  *((unsigned char *)v11 + 74) = v73;
  *((void *)a3 + 4) = 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::render(uint64_t a1, double a2, uint64_t a3, uint64_t a4, int a5, unsigned int a6)
{
  uint64_t v6 = *(void *)(a1 + 48);
  v7.i64[0] = SLODWORD(a2);
  v7.i64[1] = SHIDWORD(a2);
  long long v8 = *(_OWORD *)(v6 + 16);
  float64x2_t v9 = vaddq_f64(*(float64x2_t *)(v6 + 32), vcvtq_f64_s64(v7));
  v11[0] = *(_OWORD *)v6;
  v11[1] = v8;
  float32x2_t v11[2] = v9;
  LOWORD(v9.f64[0]) = *(_WORD *)(a1 + 44);
  __int16 v12 = *(_WORD *)(a1 + 112);
  int v13 = *(_DWORD *)(a1 + 114);
  short float v14 = *(short float *)(a1 + 118) * *(short float *)v9.f64;
  __int16 v15 = *(_WORD *)(a1 + 120);
  return RB::render_primitive(a4, (uint64_t)v11, a1 + 64, (uint64_t)&v12, a5, a6);
}

uint64_t RB::render_primitive(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, unsigned int a6)
{
  unsigned int v6 = a6;
  int v39 = 0;
  memset(v38, 0, sizeof(v38));
  int32x2_t v36 = 0;
  int32x2_t v37 = 0;
  uint64_t result = RB::Coverage::Primitive::set_globals(a3, (uint64_t)v40, (float32x2_t *)a1, a2, a6, &v39, (uint64_t)v38, (uint64_t)&v36);
  if (result)
  {
    uint32x2_t v41 = (RB::Buffer *)RB::Fill::Color::prepare(a4, *(unsigned __int8 *)(a1 + 124), v12);
    short float v13 = *(short float *)(a4 + 6);
    BOOL v14 = v6 == 24 || v6 == 2;
    LOWORD(v15) = COERCE_UNSIGNED_INT(1.0);
    if (v14 && v13 == v15) {
      unsigned int v17 = 0;
    }
    else {
      unsigned int v17 = v6;
    }
    if (v39 == 1) {
      unsigned int v6 = v17;
    }
    char v18 = (v39 == 1) & (v6 < 0x19) & ~(_BYTE)a5;
    if (v18) {
      int v19 = 2;
    }
    else {
      int v19 = 5;
    }
    if (v13 == v15 && ((v39 == 1) & (v6 < 0x19) & ~(_BYTE)a5) != 0)
    {
      if (v6 == 24 || v6 == 2) {
        LOBYTE(v6) = 0;
      }
      int v19 = 2;
    }
    if (v18)
    {
      RB::Coverage::set_plane((uint64_t)v35, (uint64_t)v40);
      *(RB::Buffer **)((char *)&v35[3] + 4) = v41;
      RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a1, (RB::Device *)0x24, 4uLL, 0, &v42);
      int v20 = v42;
      if (v42)
      {
        uint64_t v21 = *((void *)v42 + 7) + v43.i64[0];
        long long v22 = *(_OWORD *)v35;
        long long v23 = *(_OWORD *)&v35[2];
        *(_DWORD *)(v21 + 32) = v35[4];
        *(_OWORD *)uint64_t v21 = v22;
        *(_OWORD *)(v21 + 16) = v23;
      }
      else
      {
        float32x2_t v42 = 0;
        int64x2_t v43 = 0uLL;
      }
      *(_DWORD *)(a1 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a1, v20);
      int64x2_t v30 = v43;
    }
    else
    {
      RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a1, (RB::Device *)0x58, 4uLL, 0, v35);
      int32x2_t v24 = v35[0];
      if (v35[0])
      {
        uint32x2_t v25 = (char *)v35[1] + *((void *)v35[0] + 7);
        long long v26 = v40[0];
        *((_OWORD *)v25 + 1) = v40[1];
        long long v28 = v40[3];
        long long v27 = v40[4];
        long long v29 = v40[2];
        *((void *)v25 + 10) = v41;
        *((_OWORD *)v25 + 3) = v28;
        *((_OWORD *)v25 + 4) = v27;
        *((_OWORD *)v25 + 2) = v29;
        *(_OWORD *)uint32x2_t v25 = v26;
      }
      else
      {
        memset(v35, 0, 24);
      }
      *(_DWORD *)(a1 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a1, v24);
      int64x2_t v30 = *(int64x2_t *)&v35[1];
    }
    *(int32x2_t *)(a1 + 188) = vmovn_s64(v30);
    LODWORD(v35[0]) = v39 & 0xF;
    RB::Coverage::Primitive::set_coverage_state(a3, v35);
    int v31 = *(_DWORD *)(a1 + 136) == 2;
    if (a5) {
      int v32 = 0x10000;
    }
    else {
      int v32 = 0;
    }
    int v33 = v19 | v32 | (v31 << 17);
    uint64_t v34 = v6 & 0x3F;
    uint64_t result = (uint64_t)RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, (const char *)((v19 | v32) & 0xFFFF003F | (v31 << 17) | (((uint64_t)v35[0] & 0x3FF) << 6) | (unint64_t)(v34 << 32)), 4, (uint64_t)v38, 0, 1uLL, v36, v37);
    if (*((void *)&v38[1] + 1))
    {
      LODWORD(v35[0]) = (uint64_t)v35[0] & 0xFFFFFFF0 | 1;
      if (v13 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)) && (v34 == 24 || v34 == 2)) {
        uint64_t v34 = 0;
      }
      uint64_t result = (uint64_t)RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, (const char *)((LODWORD(v35[0]) << 6) & 0xFFC0 | v33 | (unint64_t)(v34 << 32)), 4, (uint64_t)&v38[1] + 8, 0, 1uLL, v36, v37);
    }
    *(void *)(a1 + 200) = 0;
    *(_DWORD *)(a1 + 196) = 0;
  }
  return result;
}

RB::Buffer *RB::RenderFrame::alloc_buffer_region@<X0>(RB::RenderFrame *this@<X0>, RB::Device *a2@<X1>, unint64_t a3@<X2>, char a4@<W3>, void *a5@<X8>)
{
  uint64_t result = *(RB::Buffer **)this;
  if (*((void *)result + 34) < (unint64_t)a2)
  {
    uint64_t v9 = RB::Buffer::alloc((id *)result, a2);
    uint64_t result = (RB::Buffer *)RB::RenderFrame::buffer_id(this, (RB::Buffer *)v9);
    *a5 = v9;
    a5[1] = 0;
    a5[2] = *(void *)(v9 + 48);
    int v10 = *(_DWORD *)(v9 + 8) - 1;
    *(_DWORD *)(v9 + 8) = v10;
    if (!v10)
    {
      long long v11 = *(uint64_t (**)(uint64_t))(*(void *)v9 + 8);
      return (RB::Buffer *)v11(v9);
    }
    return result;
  }
  uint64_t v13 = *((void *)this + 16);
  if (v13)
  {
    if (!a2)
    {
      a5[1] = 0;
      a5[2] = 0;
      *a5 = v13;
      return result;
    }
    uint64_t v14 = *((void *)this + 17);
    if ((a4 & 2) == 0)
    {
      unint64_t v15 = 4;
      if (!*((unsigned char *)result + 283)) {
        unint64_t v15 = 256;
      }
      if (v15 <= a3) {
        unint64_t v15 = a3;
      }
      uint64_t v14 = (v14 + v15 - 1) & -(uint64_t)v15;
    }
    unint64_t v16 = *(void *)(v13 + 48) - v14;
  }
  else
  {
    unint64_t v16 = 0;
    uint64_t v14 = 0;
  }
  if (v16 >= (unint64_t)a2)
  {
    int v18 = a4 & 1;
LABEL_28:
    if (v18)
    {
      *((unsigned char *)this + 144) = 1;
      *a5 = *((void *)this + 16);
      a5[1] = v14;
      a5[2] = v16;
    }
    else
    {
      *((void *)this + 17) = (char *)a2 + v14;
      *a5 = *((void *)this + 16);
      a5[1] = v14;
      a5[2] = a2;
    }
    return result;
  }
  RB::Device::alloc_shared_buffer(result, (uint64_t *)&v20);
  RB::RenderFrame::buffer_id(this, v20);
  if (a4)
  {
    uint64_t result = v20;
  }
  else
  {
    uint64_t result = v20;
    if (*((void *)this + 16) && v16 > *((void *)v20 + 6) - (void)a2)
    {
      int v17 = 0;
      *a5 = v20;
      a5[1] = 0;
      a5[2] = a2;
      goto LABEL_25;
    }
  }
  uint64_t v14 = 0;
  *((void *)this + 16) = result;
  *((void *)this + 17) = 0;
  unint64_t v16 = *((void *)result + 6);
  int v17 = 1;
LABEL_25:
  int v18 = a4 & 1;
  int v19 = *((_DWORD *)result + 2) - 1;
  *((_DWORD *)result + 2) = v19;
  if (!v19) {
    uint64_t result = (RB::Buffer *)(*(uint64_t (**)(RB::Buffer *))(*(void *)result + 8))(result);
  }
  if (v17) {
    goto LABEL_28;
  }
  return result;
}

void sub_21410EB6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _DWORD *a9)
{
  if (a9) {
    RB::RenderFrame::alloc_buffer_region(a9);
  }
  _Unwind_Resume(exception_object);
}

int32x2_t *RB::RenderPass::draw_indexed_primitives(int32x2_t *result, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, int32x2_t a7, int32x2_t a8)
{
  int32x2_t v17 = a7;
  int32x2_t v18 = a8;
  if (a5) {
    uint64_t v8 = a5;
  }
  else {
    uint64_t v8 = *(void *)(a4 + 16) >> 1;
  }
  if (a6 && v8)
  {
    if ((v8 | a6) >> 32) {
      RB::precondition_failure((RB *)"invalid index or instance count", a2, *(void *)&v17, *(void *)&v18);
    }
    uint64_t v13 = (id ***)result;
    uint64_t result = RB::Bounds::intersect(&v17, result[20], result[21]);
    uint32x2_t v14 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v18);
    if ((vpmax_u32(v14, v14).u32[0] & 0x80000000) == 0)
    {
      uint64_t v15 = RB::RenderPass::draw(v13, a2, (int8x8_t *)&v17, 0);
      *(unsigned char *)(v15 + 42) = a3;
      unint64_t v16 = *(RB::Buffer **)a4;
      *(_DWORD *)(v15 + 24) = *(void *)(a4 + 8);
      *(_DWORD *)(v15 + 28) = v8;
      *(_DWORD *)(v15 + 32) = a6;
      uint64_t result = (int32x2_t *)RB::RenderFrame::buffer_id((RB::RenderFrame *)**v13, v16);
      *(_DWORD *)(v15 + 36) = result;
      if (a3 == 4) {
        (**v13)[4] = (char *)(**v13)[4] + (v8 - 2) * a6;
      }
    }
  }
  return result;
}

uint64_t RB::RenderFrame::buffer_id(RB::RenderFrame *this, RB::Buffer *a2)
{
  if (!a2) {
    return 0;
  }
  RB::Resource::set_frame_id((uint64_t)a2, *((_DWORD *)this + 21), *((_DWORD *)this + 22));
  uint64_t v4 = *((unsigned int *)a2 + 10);
  if (!v4)
  {
    uint64_t v4 = *(void *)(*((void *)this + 12) + 8);
    ++*((_DWORD *)a2 + 2);
    unsigned int v5 = (void *)*((void *)this + 12);
    unint64_t v6 = v5[1];
    if (v6 >= v5[2]) {
      unsigned int v5 = (void *)RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::realloc_buffer((unint64_t *)this + 12, v5);
    }
    v5[v6 + 3] = a2;
    atomic_store(v6 + 1, v5 + 1);
    *((_DWORD *)a2 + 10) = v4;
    *((void *)this + 6) += *((void *)a2 + 6);
  }
  return v4;
}

void sub_21410ED50(_Unwind_Exception *exception_object)
{
  int v3 = *(_DWORD *)(v1 + 8) - 1;
  *(_DWORD *)(v1 + 8) = v3;
  if (!v3) {
    RB::TextureCache::prepare(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::Resource::set_frame_id(uint64_t this, int a2, int a3)
{
  do
  {
    if (*(_DWORD *)(this + 32) == a2) {
      break;
    }
    *(_DWORD *)(this + 32) = a2;
    *(_DWORD *)(this + 36) = a3;
    *(_DWORD *)(this + 40) = 0;
    this = *(void *)(this + 24);
  }
  while (this);
  return this;
}

int32x2_t *RB::Bounds::intersect(int32x2_t *result, int32x2_t a2, int32x2_t a3)
{
  int32x2_t v3 = result[1];
  uint32x2_t v4 = (uint32x2_t)vceqz_s32(v3);
  if ((vpmax_u32(v4, v4).u32[0] & 0x80000000) == 0)
  {
    uint32x2_t v5 = (uint32x2_t)vceqz_s32(a3);
    if ((vpmax_u32(v5, v5).u32[0] & 0x80000000) != 0)
    {
      *uint64_t result = a2;
      result[1] = a3;
    }
    else
    {
      int32x2_t v6 = vmax_s32(*result, a2);
      int32x2_t v7 = vsub_s32(vmin_s32(vadd_s32(*result, v3), vadd_s32(a3, a2)), v6);
      uint32x2_t v8 = (uint32x2_t)vcgtz_s32(v7);
      if ((vpmin_u32(v8, v8).u32[0] & 0x80000000) != 0)
      {
        *uint64_t result = v6;
        result[1] = v7;
      }
      else
      {
        *uint64_t result = 0;
        result[1] = 0;
      }
    }
  }
  return result;
}

uint64_t RB::RenderPass::draw(id ***a1, const char *a2, int8x8_t *a3, uint64_t a4)
{
  uint64_t v35 = a2;
  uint32x2_t v4 = (int32x2_t *)(a1 + 20);
  uint32x2_t v5 = (uint32x2_t)vcgt_s32((int32x2_t)vorr_s8((int8x8_t)a1[20], *a3), (int32x2_t)-1);
  if ((vpmax_u32(v5, v5).u32[0] & 0x80000000) == 0) {
    RB::precondition_failure((RB *)"invalid bounds or scissor", a2);
  }
  if (((unint64_t)a2 & 0x3F00000000) == 0x2B00000000) {
    RB::RenderState::simplify_plus_lighter((unsigned int *)&v35, (unint64_t)a1[2]);
  }
  uint64_t v9 = a1[19];
  if (!v9 || *(_DWORD *)v9 >= 0x400u && (RB::RenderFrame::flush_pass(**a1, (RB::RenderPass *)a1, 0), !a1[19])) {
    RB::RenderFrame::acquire_queue((uint64_t)**a1, (uint64_t *)a1 + 19);
  }
  uint32x2_t v10 = (uint32x2_t)vceqz_s32(*v4);
  if ((vpmin_u32(v10, v10).u32[0] & 0x80000000) != 0)
  {
    uint32x2_t v12 = (uint32x2_t)vceq_s32((int32x2_t)a1[21], (int32x2_t)a1[13]);
    unsigned __int32 v11 = vpmin_u32(v12, v12).u32[0] >> 31;
  }
  else
  {
    unsigned __int32 v11 = 0;
  }
  uint64_t v13 = 4;
  uint64_t v14 = 220;
  do
  {
    if (*(_DWORD *)((char *)a1 + v14)) {
      break;
    }
    v14 -= 12;
    --v13;
  }
  while (v13);
  uint64_t v15 = 3;
  uint64_t v16 = 31;
  do
  {
    if (LODWORD(a1[v16])) {
      break;
    }
    --v16;
    --v15;
  }
  while (v15);
  int32x2_t v17 = (size_t *)a1[19];
  if (*(_DWORD *)v17 == *((_DWORD *)v17 + 1)) {
    RB::RenderQueue::grow_ops((RB::RenderQueue *)v17);
  }
  if (v11) {
    uint64_t v18 = 3;
  }
  else {
    uint64_t v18 = 7;
  }
  uint64_t v19 = 72;
  if (v11) {
    uint64_t v19 = 49;
  }
  size_t v20 = v19 + a4 + 12 * v13 + 8 * v15;
  uint64_t v21 = (v18 + v17[4]) & ~v18;
  if (v21 + v20 > v17[5]) {
    uint64_t v21 = RB::Heap::alloc_slow(v17 + 2, v20, v18);
  }
  else {
    v17[4] = v21 + v20;
  }
  *(unsigned char *)(v21 + 48) = *(unsigned char *)(v21 + 48) & 0xFE | v11 ^ 1 | 4;
  *(unsigned char *)(v21 + 47) = v13;
  *(unsigned char *)(v21 + 46) = v15;
  size_t v22 = v17[1];
  uint64_t v23 = *(unsigned int *)v17;
  *(_DWORD *)int32x2_t v17 = v23 + 1;
  *(void *)(v22 + 8 * v23) = v21;
  if ((v11 & 1) == 0) {
    *(_OWORD *)((v21 + 56) & 0xFFFFFFFFFFFFFFF8) = *(_OWORD *)v4->i8;
  }
  if (v13)
  {
    unint64_t v24 = v21 + 49;
    if (*(unsigned char *)(v21 + 48)) {
      unint64_t v24 = ((v21 + 56) & 0xFFFFFFFFFFFFFFF8) + 16;
    }
    uint32x2_t v25 = a1 + 23;
    do
    {
      uint64_t v26 = (uint64_t)*v25;
      *(_DWORD *)(v24 + 8) = *((_DWORD *)v25 + 2);
      *(void *)unint64_t v24 = v26;
      v24 += 12;
      uint32x2_t v25 = (void **)((char *)v25 + 12);
      --v13;
    }
    while (v13);
  }
  if (v15)
  {
    unint64_t v27 = v21 + 49;
    if (*(unsigned char *)(v21 + 48)) {
      unint64_t v27 = ((v21 + 56) & 0xFFFFFFFFFFFFFFF8) + 16;
    }
    long long v28 = (void *)(v27 + 12 * *(unsigned __int8 *)(v21 + 47));
    long long v29 = (uint64_t *)(a1 + 29);
    do
    {
      uint64_t v30 = *v29++;
      *v28++ = v30;
      --v15;
    }
    while (v15);
  }
  int v31 = *((unsigned __int8 *)a1 + 177);
  *(unsigned char *)(v21 + 45) = v31;
  int v32 = *((unsigned __int8 *)a1 + 176);
  *(unsigned char *)(v21 + 43) = v32;
  *(unsigned char *)(v21 + 44) = *((_DWORD *)a1 + 45);
  *(void *)uint64_t v21 = v35;
  *(_DWORD *)(v21 + 8) = *a3;
  *(_DWORD *)(v21 + 12) = a3->i32[1];
  *(_DWORD *)(v21 + 16) = *(void *)&a3[1] + *(void *)a3;
  *(_DWORD *)(v21 + 20) = a3[1].i32[1] + a3->i32[1];
  *(_WORD *)(v21 + 40) = RB::RenderState::render_mask((unsigned int *)&v35, v31, v32);
  int v33 = **a1;
  v33[7] = (char *)v33[7]
         + (int)RB::RenderState::fill_rate((RB::RenderState *)v21, (*(_DWORD *)(v21 + 20) - *(_DWORD *)(v21 + 12)) * (*(_DWORD *)(v21 + 16) - *(_DWORD *)(v21 + 8)));
  return v21;
}

uint64_t RB::RenderState::fill_rate(RB::RenderState *this, int a2)
{
  return ((RB::RenderState::fill_rate(int)const::blend_rate[*((_DWORD *)this + 1) & 0x3FLL]
                       + RB::RenderState::fill_rate(int)const::function_rate[*(_DWORD *)this & 0x3FLL])
                      * a2);
}

uint64_t RB::RenderState::render_mask(unsigned int *a1, int a2, int a3)
{
  int v5 = BYTE1(v3);
  unsigned int v6 = *a1;
  if ((*a1 & 0x20000) != 0) {
    int v7 = 4;
  }
  else {
    int v7 = 2;
  }
  switch(v6 & 0x3F)
  {
    case 0u:
    case 1u:
      LOBYTE(v4) = v3 | 0x3F;
      int v5 = ((unsigned __int16)(v3 & 0xC000) >> 8) | 0x3F;
      return v4 | (v5 << 8);
    case 2u:
    case 3u:
    case 0x20u:
    case 0x22u:
      int v5 = v7 | ((unsigned __int16)(v3 & 0xFF00) >> 8);
      goto LABEL_25;
    case 4u:
    case 0xAu:
      int v5 = ((unsigned __int16)(v3 & 0xFF00) >> 8) | 0x10;
      goto LABEL_25;
    case 5u:
    case 6u:
    case 7u:
    case 8u:
      LOBYTE(v9) = v7 | v3;
      if ((*a1 & 0xC00) == 0x400) {
      if ((*a1 & 0x4000) != 0)
      }
      else {
        LOBYTE(v4) = v9;
      }
      if ((*a1 & 0x3C0) == 0x40) {
      goto LABEL_18;
      }
    case 9u:
    case 0xEu:
    case 0xFu:
    case 0x10u:
    case 0x18u:
    case 0x19u:
    case 0x1Bu:
      int v5 = ((unsigned __int16)(v3 & 0xFF00) >> 8) | 8;
LABEL_25:
      break;
    case 0xBu:
    case 0xCu:
    case 0xDu:
      unsigned int v10 = v3 & 0xFF00;
      LOBYTE(v4) = v3 | v7 | 0x10;
      if ((v6 & 0x10000) == 0) {
      goto LABEL_34;
      }
    case 0x11u:
      LOBYTE(v4) = v3 | 8;
      int v5 = ((unsigned __int16)(v3 & 0xFF00) >> 8) | 0x18;
      break;
    case 0x12u:
    case 0x13u:
    case 0x14u:
    case 0x15u:
    case 0x16u:
      LOBYTE(v4) = v3 | v7 | 0x10;
      if ((v6 & 0x10000) == 0) {
      LOBYTE(v4) = v4 | 8;
      }
      int v8 = v7 | ((unsigned __int16)(v3 & 0xFF00) >> 8);
      goto LABEL_9;
    case 0x1Au:
      int v8 = (unsigned __int16)(v3 & 0xFF00) >> 8;
      LOBYTE(v4) = v3 | 8;
LABEL_9:
      int v5 = v8 | 8;
      break;
    case 0x1Du:
    case 0x1Eu:
      unsigned int v10 = v3 & 0xFF00;
      int v4 = (v6 >> 12) & 0x10 | v7 | v3;
      goto LABEL_34;
    case 0x1Fu:
      unsigned int v10 = v3 & 0xFF00;
      if ((v6 & 0xF00000) == 0x400000) {
        LOBYTE(v4) = v3 | v7 | 0x10;
      }
      else {
      goto LABEL_34;
      }
    case 0x21u:
      LOBYTE(v4) = v7 | v3;
      break;
    case 0x23u:
      unsigned int v10 = v3 & 0xFF00;
      LOBYTE(v4) = v7 | v3;
      goto LABEL_34;
    case 0x24u:
      int v5 = v7 | ((unsigned __int16)(v3 & 0xFF00) >> 8);
      int v4 = (v6 >> 12) & 0x10 | v3;
      int v17 = (v6 >> 20) & 3;
      char v18 = v4 | 4;
      if (v17 == 1) {
        LOBYTE(v4) = v4 | 2;
      }
      if (v17 == 2) {
        LOBYTE(v4) = v18;
      }
      break;
    case 0x25u:
    case 0x26u:
    case 0x27u:
LABEL_18:
      unsigned int v10 = v3 & 0xFF00;
      if ((v6 & 0x10000) != 0) {
        LOBYTE(v4) = v4 | v7 | 0x10;
      }
LABEL_34:
      int v5 = v7 | (v10 >> 8);
      break;
    default:
      break;
  }
  unsigned int v11 = a1[1] & 0x3F;
  if (v11 - 19 < 4)
  {
    BOOL v12 = (v5 & v7) == 0;
    int v13 = v5 & ~v7 | 0x10;
    if (!v12) {
      int v5 = v13;
    }
    goto LABEL_41;
  }
  if (v11 != 23)
  {
LABEL_41:
    if (v11 > 0x17 || ((1 << v11) & 0xA80003) == 0) {
      LOBYTE(v4) = v5 & 0xFE | v4;
    }
    return v4 | (v5 << 8);
  }
  int v14 = v7 | 0x10;
  unsigned int v15 = v5 & (v7 ^ 0xFFFFFFE7) | 8;
  if ((v5 & v14) != 0) {
    int v5 = v15;
  }
  return v4 | (v5 << 8);
}

uint64_t RB::Coverage::Primitive::set_coverage_state(uint64_t result, _DWORD *a2)
{
  char v2 = *(unsigned char *)(result + 46);
  float v3 = *(float *)(result + 40);
  if (v3 > 0.0 && (v2 & 4) != 0)
  {
    unsigned int v7 = *a2 & 0xFFFFFFCF | 0x20;
LABEL_11:
    *a2 = v7;
    v2 &= 1u;
    goto LABEL_14;
  }
  unsigned int v5 = *(unsigned __int8 *)(result + 45);
  if (v3 <= 0.0 || v5 < 2)
  {
    unsigned int v7 = *a2 & 0xFFFFFFCF | (16 * (v5 == 1));
    goto LABEL_11;
  }
  unsigned int v7 = *a2 | 0x30;
  *a2 = v7;
  if (*(unsigned char *)(result + 45) == 3) {
    char v2 = (v2 & 1) == 0;
  }
LABEL_14:
  if (*(unsigned __int8 *)(result + 44) - 6 >= 3) {
    int v8 = (*(float *)(result + 36) > 0.0) << 6;
  }
  else {
    int v8 = 0;
  }
  unsigned int v9 = v7 & 0xFFFFFF3F;
  if (v2) {
    int v10 = 128;
  }
  else {
    int v10 = 0;
  }
  int v11 = v8 | v10 | v9;
  *a2 = v11;
  *a2 = v11 & 0xFFFFFEFF | (((*(unsigned __int8 *)(result + 46) >> 1) & 1) << 8);
  return result;
}

float16x4_t RB::Fill::Color::prepare(uint64_t a1, int a2, double a3)
{
  LOWORD(a3) = *(_WORD *)a1;
  if (*(short float *)a1 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(-1.0))
    && *(short float *)(a1 + 2) == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(-1.0)))
  {
    uint64_t v7 = 0x3C003C0000003C00;
    __int16 v8 = 0;
    RB::Fill::Color::prepare(&v7, *(float *)&a3);
  }
  else if (*(unsigned char *)(a1 + 9) && *(unsigned __int8 *)(a1 + 8) != a2)
  {
    unint64_t v5 = RB::Fill::Color::converted((__int16 *)a1, a2, *(uint16x4_t *)&a3);
    v6.i16[3] = 15360;
    v6.i32[0] = v5;
    v6.i16[2] = WORD2(v5);
    return vmul_f16((float16x4_t)vdup_n_s16(HIWORD(v5)), v6);
  }
  else
  {
    v3.i16[3] = 15360;
    v3.i32[0] = *(_DWORD *)a1;
    v3.i16[2] = *(_WORD *)(a1 + 4);
    return vmul_n_f16(v3, *(short float *)(a1 + 6));
  }
  return result;
}

void **RB::DisplayList::Layer::render_items(void **this, RB::CGContext *a2, char *a3)
{
  float16x4_t v3 = (void **)(a3 + 8);
  if (!a3) {
    float16x4_t v3 = this;
  }
  int v4 = *v3;
  if (*v3)
  {
    float16x4_t v6 = 0;
    uint64_t v7 = (int32x2_t *)((char *)a2 + 96);
    do
    {
      if (v6)
      {
        if (v6 == v4) {
          float16x4_t v6 = 0;
        }
      }
      else
      {
        __int16 v8 = (float32x2_t *)v4[3];
        if (!v8) {
          goto LABEL_24;
        }
        unsigned int v9 = (void *)v4[1];
        if (!v9) {
          goto LABEL_24;
        }
        int v10 = v4;
        do
        {
          float16x4_t v6 = v10;
          int v10 = v9;
          if ((float32x2_t *)v6[3] != v8) {
            break;
          }
          unsigned int v9 = (void *)v9[1];
          float16x4_t v6 = v10;
        }
        while (v9);
        if (v6 != v4)
        {
          double v11 = (*(double (**)(void *, void))(*v4 + 144))(v4, 0);
          double v24 = v11;
          float32x2_t v25 = v12;
          int v13 = (void *)v4[1];
          if (v13 != v6)
          {
            do
            {
              double v14 = (*(double (**)(void *, void))(*v13 + 144))(v13, 0);
              RB::Rect::Union((float32x2_t *)&v24, v14, v15, v16, v17, v18, v19);
              int v13 = (void *)v13[1];
            }
            while (v13 != v6);
            double v11 = v24;
            float32x2_t v12 = v25;
          }
          float v20 = *((float *)a2 + 33);
          unsigned int v21 = *((_DWORD *)a2 + 34);
          RB::Bounds::Bounds((int32x2_t *)&v23, *(float32x2_t *)&v11, v12);
          if (*((float32x2_t **)a2 + 11) == v8
            && RB::Bounds::contains(v7, *(int32x2_t *)&v23, *(int32x2_t *)((char *)&v23 + 8)))
          {
            int v22 = 1;
            if (!*((void *)a2 + 10) && *((float *)a2 + 33) == v20 && *((_DWORD *)a2 + 34) == v21) {
              goto LABEL_27;
            }
          }
          else
          {
            int v22 = 0;
          }
          RB::CGContext::update_state_slow((uint64_t)a2, 0, v8, v21, &v23, v22, v20);
        }
        else
        {
LABEL_24:
          float16x4_t v6 = 0;
        }
      }
LABEL_27:
      this = (void **)(*(uint64_t (**)(void *, RB::CGContext *))(*v4 + 184))(v4, a2);
      int v4 = (void *)v4[1];
    }
    while (v4);
  }
  return this;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::render(uint64_t a1, uint64_t a2)
{
  int v4 = *(float64x2_t **)(a1 + 48);
  unint64_t v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  unsigned int v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&float32x2_t v12 = (*(double (**)(uint64_t, void))(*(void *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)&v16, v12, v13);
  int v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5) {
    goto LABEL_10;
  }
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v16, *(int32x2_t *)((char *)&v16 + 8)))
  {
    int v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, &v16, v14, _S8);
    goto LABEL_11;
  }
  int v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4) {
    goto LABEL_10;
  }
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11) {
    goto LABEL_10;
  }
LABEL_11:
  RB::Coverage::Path::fill((RB::Coverage::Path *)(a1 + 56), (CGContextRef *)a2, (const RB::Fill::Color *)(a1 + 88));
}

void RB::Coverage::Path::fill(RB::Coverage::Path *this, CGContextRef *a2, const RB::Fill::Color *a3)
{
  if (*((void *)this + 1) != 0x21421C340)
  {
    float64x2_t v6 = 0uLL;
    memset(&v18, 0, sizeof(v18));
    uint64_t v7 = (float64x2_t *)*((void *)this + 2);
    float64x2_t v8 = (float64x2_t)xmmword_2142181D0;
    float64x2_t v9 = (float64x2_t)xmmword_2142181C0;
    if (v7)
    {
      float64x2_t v9 = *v7;
      float64x2_t v8 = v7[1];
      float64x2_t v6 = v7[2];
    }
    int64x2_t v10 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v8, (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqzq_f64(v6)), (int8x16_t)vceqq_f64(v9, (float64x2_t)xmmword_2142181C0));
    unint64_t v11 = vandq_s8((int8x16_t)vdupq_laneq_s64(v10, 1), (int8x16_t)v10).u64[0];
    if ((v11 & 0x8000000000000000) == 0)
    {
      *(float64x2_t *)&v17.c = v8;
      *(float64x2_t *)&v17.tCGFloat x = v6;
      *(float64x2_t *)&v17.a = v9;
      CGContextGetCTM(&v18, *a2);
      float32x2_t v12 = *a2;
      CGAffineTransform transform = v17;
      CGContextConcatCTM(v12, &transform);
    }
    int v13 = rb_clip_mode(*((unsigned __int8 *)this + 29));
    if (*((unsigned __int8 *)a2 + 140) != v13) {
      RB::CGContext::set_aliasing_mode_slow((uint64_t)a2, v13);
    }
    if (*((unsigned char *)a2 + 121) && *((unsigned char *)a3 + 9) && *((unsigned __int8 *)a2 + 120) != *((unsigned __int8 *)a3 + 8)
      || (v14.i16[0] = *((_WORD *)a2 + 56), *(short float *)v14.i16 != *(short float *)a3)
      || (v14.i16[0] = *((_WORD *)a2 + 57), *(short float *)v14.i16 != *((short float *)a3 + 1))
      || (v14.i16[0] = *((_WORD *)a2 + 58), *(short float *)v14.i16 != *((short float *)a3 + 2))
      || (v14.i16[0] = *((_WORD *)a2 + 59), *(short float *)v14.i16 != *((short float *)a3 + 3)))
    {
      RB::CGContext::set_fill_color_slow((RB::CGContext *)a2, a3, v14);
    }
    CGPathRef v15 = RBPathCopyCGPath(*(const CGPath **)this, *((void *)this + 1));
    if (v15)
    {
      CGPathRef v16 = v15;
      CGContextDrawPathDirect();
      CFRelease(v16);
    }
    if ((v11 & 0x8000000000000000) == 0)
    {
      CGAffineTransform transform = v18;
      CGContextSetCTM();
    }
  }
}

void sub_21410F9B8(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

CGPathRef RBPathCopyCGPath(const CGPath *a1, uint64_t a2)
{
  if ((*(unsigned char *)(a2 + 2) & 1) == 0)
  {
    int v4 = *(uint64_t (**)(const CGPath *))(a2 + 72);
    if (v4)
    {
      unint64_t v5 = (const CGPath *)v4(a1);
      if (v5) {
        goto LABEL_4;
      }
    }
LABEL_9:
    float64x2_t v8 = (void (**)(void))&unk_26C4EE4D0;
    CGMutablePathRef Mutable = CGPathCreateMutable();
    RBPathMap(a1, (void *)a2, &v8, 0);
    return Mutable;
  }
  uint64_t v7 = *(uint64_t (**)(const CGPath *, uint64_t))(a2 + 72);
  if (!v7) {
    goto LABEL_9;
  }
  unint64_t v5 = (const CGPath *)v7(a1, a2);
  if (!v5) {
    goto LABEL_9;
  }
LABEL_4:
  return CGPathRetain(v5);
}

void sub_21410FA8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

BOOL rb_clip_mode(int a1)
{
  return a1 == 1;
}

const CGPath *RB::Path::Storage::cgpath(RB::Path::Storage *this)
{
  if ((*((unsigned char *)this + 8) & 1) == 0) {
    return 0;
  }
  float16x4_t v3 = (atomic_ullong *)((char *)this + 56);
  float16x4_t result = (const CGPath *)atomic_load((unint64_t *)this + 7);
  if (!result)
  {
    float16x4_t result = RBPathCopyCGPath(this, (uint64_t)&RB::Path::Storage::cgpath(void)const::callbacks);
    uint64_t v4 = 0;
    atomic_compare_exchange_strong(v3, (unint64_t *)&v4, (unint64_t)result);
    if (v4)
    {
      CGPathRelease(result);
      return (const CGPath *)v4;
    }
  }
  return result;
}

const CGPath *RB::Path::Object::$_14::__invoke(RB::Path::Object::$_14 *this, const void *a2)
{
  return RB::Path::Storage::cgpath((RB::Path::Object::$_14 *)((char *)this + 16));
}

uint64_t RB::Coverage::Primitive::set_globals(uint64_t a1, uint64_t a2, float32x2_t *a3, uint64_t a4, unsigned int a5, int *a6, uint64_t a7, uint64_t a8)
{
  if ((*(unsigned char *)(a1 + 46) & 2) != 0) {
    int may_discard_alpha = RB::may_discard_alpha(a5);
  }
  else {
    int may_discard_alpha = RB::may_discard_shape(a5);
  }
  int v18 = may_discard_alpha;
  *a6 = *(unsigned __int8 *)(a1 + 44);
  *(_DWORD *)(a2 + 68) = a3[15].i32[0];
  *(void *)(a2 + 72) = 0x3C0000000000;
  int v19 = *(unsigned __int8 *)(a1 + 44);
  float64x2_t v20 = *(float64x2_t *)(a4 + 16);
  float64x2_t v21 = vmulq_n_f64(*(float64x2_t *)a4, *(float *)(a1 + 32));
  float32x4_t v22 = *(float32x4_t *)(a4 + 32);
  float64x2_t v157 = v21;
  float64x2_t v158 = v20;
  float32x4_t v159 = v22;
  if (*(float *)(a1 + 40) <= 0.0) {
    BOOL v23 = 0;
  }
  else {
    BOOL v23 = (*(unsigned char *)(a1 + 46) & 4) != 0 || *(unsigned __int8 *)(a1 + 45) > 1u;
  }
  float32x2_t v24 = *(float32x2_t *)a1;
  v17.i64[0] = *(void *)(a1 + 8);
  float v25 = *(float *)(a1 + 36);
  float32x4_t v26 = *(float32x4_t *)(a1 + 16);
  float64x2_t v27 = vabsq_f64(v21);
  v27.f64[0] = vpmaxq_f64(v27);
  double v28 = vpmaxq_f64(vabsq_f64(v20));
  if (v27.f64[0] < v28) {
    v27.f64[0] = v28;
  }
  *(float *)&uint64_t v16 = v27.f64[0];
  if ((v19 - 6) < 3)
  {
    float32x4_t v22 = (float32x4_t)vmlaq_n_f64(vmlaq_n_f64((float64x2_t)v22, v21, v24.f32[0]), v20, v24.f32[1]);
    float64x2_t v158 = v20;
    float32x4_t v159 = v22;
    *(float32x2_t *)&v20.f64[0] = vmul_f32(*(float32x2_t *)v17.i8, *(float32x2_t *)v17.i8);
    v22.f32[0] = sqrtf(vaddv_f32(*(float32x2_t *)&v20.f64[0]));
    float32x4_t v154 = v22;
    if (v22.f32[0] > 0.00001)
    {
      unsigned __int32 v29 = v22.i32[0];
      float32x2_t v30 = vrecpe_f32((float32x2_t)v22.u32[0]);
      float32x2_t v31 = vmul_f32(vrecps_f32((float32x2_t)v29, v30), v30);
      int32x2_t v32 = (int32x2_t)vmul_n_f32(*(float32x2_t *)v17.i8, vmul_f32(v31, vrecps_f32((float32x2_t)v29, v31)).f32[0]);
      v31.i32[0] = v32.i32[1];
      float64_t v33 = *(float *)&v32.i32[1];
      float32x2_t v34 = (float32x2_t)vdup_lane_s32(v32, 0);
      v34.f32[0] = -v31.f32[0];
      int64x2_t v35 = (int64x2_t)vcvtq_f64_f32(v34);
      *(void *)&v36.f64[0] = vdupq_laneq_s64(v35, 1).u64[0];
      v36.f64[1] = v33;
      float64x2_t v161 = v36;
      float64x2_t v162 = (float64x2_t)v35;
      v163[0] = 0uLL;
      float32x4_t v147 = v26;
      uint64_t v150 = v16;
      v20.f64[0] = RB::operator*(&v161, &v157);
      float32x4_t v26 = v147;
      uint64_t v16 = v150;
      float64x2_t v157 = v20;
      float64x2_t v158 = (float64x2_t)v22;
      float32x4_t v159 = v37;
      if (*(unsigned char *)(a1 + 44) != 7)
      {
        int v19 = 2;
LABEL_21:
        v39.i32[1] = 0;
        float32x2_t v40 = vrecpe_f32((float32x2_t)v16);
        double v28 = COERCE_DOUBLE(vmul_f32(vrecps_f32((float32x2_t)v16, v40), v40));
        *(float32x2_t *)&v27.f64[0] = vmul_f32(*(float32x2_t *)&v28, vrecps_f32((float32x2_t)v16, *(float32x2_t *)&v28));
        v22.f32[0] = 0.5 * *(float *)v27.f64;
        if ((float)(0.5 * *(float *)v27.f64) <= (float)(v25 * 0.5)) {
          v22.f32[0] = v25 * 0.5;
        }
        _S2 = 1.0;
        if ((float)(0.5 * *(float *)v27.f64) > (float)(v25 * 0.5)) {
          _S2 = v25 * *(float *)&v16;
        }
        __asm { FCVT            H2, S2 }
        *(_WORD *)(a2 + 76) = _H2;
        v24.i32[0] = 0;
        v24.f32[1] = -v22.f32[0];
        int32x4_t v17 = (int32x4_t)v154;
        *(float *)&v17.i32[1] = v22.f32[0] + v22.f32[0];
        int v47 = *(unsigned __int8 *)(a1 + 44);
        if (v47 != 6)
        {
          *(int32x2_t *)&v27.f64[0] = vcgt_f32((float32x2_t)vdup_n_s32(0x7F7FFFFFu), *(float32x2_t *)v17.i8);
          double v28 = COERCE_DOUBLE(vsub_f32(v24, (float32x2_t)v22.u32[0]));
          *(void *)&v27.f64[0] = vcltzq_s32((int32x4_t)v27).u64[0];
          float32x2_t v24 = (float32x2_t)vbsl_s8(*(int8x8_t *)&v27.f64[0], *(int8x8_t *)&v28, (int8x8_t)v24);
          v39.f32[0] = v22.f32[0] + v22.f32[0];
          *(int8x8_t *)v17.i8 = vbsl_s8(*(int8x8_t *)&v27.f64[0], (int8x8_t)vadd_f32(*(float32x2_t *)v17.i8, v39), *(int8x8_t *)v17.i8);
          if (v47 == 7) {
            float32x4_t v26 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v22.f32, 0);
          }
        }
        *a6 = v19;
        float v25 = 0.0;
LABEL_29:
        char v48 = v25 > 0.0 || v23;
        uint64_t v151 = v16;
        float32x2_t v153 = v24;
        int32x4_t v155 = v17;
        if (v19 != 2 || ((v18 ^ 1) & 1) != 0 || (v48 & 1) != 0)
        {
          if ((v19 - 2) > 2) {
            goto LABEL_65;
          }
        }
        else
        {
          float32x4_t v148 = v26;
          v22.i64[0] = v17.i64[0];
          *(float32x2_t *)&v161.f64[0] = RB::operator*(&v157, v24, (int32x4_t)v22);
          v161.f64[1] = v49;
          if (*(unsigned char *)(a1 + 45) == 1) {
            goto LABEL_42;
          }
          if ((v22.i64[1] = *(void *)&v157.f64[1], float64x2_t v20 = v158, v157.f64[1] == 0.0) && v158.f64[0] == 0.0
            || v157.f64[0] == 0.0 && (HIDWORD(v20.f64[0]) = HIDWORD(v158.f64[1]), v158.f64[1] == 0.0))
          {
            LODWORD(v20.f64[0]) = 1000593162;
            if ((RB::Rect::is_integral((float32x2_t *)&v161, *(int32x2_t *)&v20.f64[0]) & 1) != 0
              || (v50.i32[0] = 0,
                  int32x2_t v53 = (int32x2_t)a3[21],
                  uint32x2_t v54 = (uint32x2_t)vceq_s32(v53, (int32x2_t)0x8000000080000000),
                  int8x8_t v55 = (int8x8_t)vdup_lane_s32(vcgt_s32(v50, (int32x2_t)vpmin_u32(v54, v54)), 0),
                  int8x8_t v56 = (int8x8_t)vcvt_f32_s32(v53),
                  int8x8_t v57 = (int8x8_t)vdup_n_s32(0x7F7FFFFFu),
                  RB::Rect::contains((float32x2_t *)&v161, (float32x2_t)vbsl_s8(v55, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32((int32x2_t)a3[20])), (float32x2_t)vbsl_s8(v55, v57, v56), *(double *)&v57, *(double *)&v55, v51, v52)))
            {
LABEL_42:
              uint64_t v38 = 1;
              *a6 = 1;
              uint64_t v58 = ***(void ***)a3;
              *(void *)a7 = *(void *)(v58 + 80);
              *(_OWORD *)(a7 + 8) = *(_OWORD *)(v58 + 88);
              RB::Bounds::Bounds((int32x2_t *)&v160, *(float32x2_t *)&v161.f64[0], *(float32x2_t *)&v161.f64[1]);
              *(_OWORD *)a8 = v160;
              return v38;
            }
          }
          LODWORD(v16) = v151;
          float32x2_t v24 = v153;
          v17.i64[0] = v155.i64[0];
          float32x4_t v26 = v148;
        }
        if (*(unsigned char *)(a1 + 45) == 1) {
          char v75 = 1;
        }
        else {
          char v75 = v48;
        }
        if ((v75 & 1) == 0)
        {
          float64x2_t v76 = vmulq_n_f64(v157, *(float *)v17.i32);
          float64x2_t v77 = vmulq_n_f64(v158, *(float *)&v17.i32[1]);
          int64x2_t v78 = (int64x2_t)vmulq_f64(v76, v76);
          float32x4_t v22 = (float32x4_t)vmulq_f64(v77, v77);
          float64x2_t v20 = vaddq_f64((float64x2_t)vzip1q_s64((int64x2_t)v22, v78), (float64x2_t)vzip2q_s64((int64x2_t)v22, v78));
          if (v20.f64[0] >= v20.f64[1]) {
            v20.f64[0] = v20.f64[1];
          }
          if (v20.f64[0] < 6.25)
          {
            *a6 = 11;
            *(float32x2_t *)(a2 + 24) = vmul_f32(*(float32x2_t *)v17.i8, (float32x2_t)0x3F0000003F000000);
            float32x4_t v79 = 0uLL;
            *(_OWORD *)(a2 + 32) = 0u;
            *(_OWORD *)(a2 + 48) = 0u;
            goto LABEL_87;
          }
        }
LABEL_65:
        int32x2_t v80 = (int32x2_t)vmul_f32(*(float32x2_t *)v17.i8, (float32x2_t)0x3F0000003F000000);
        float32x4_t v79 = 0uLL;
        *(_OWORD *)(a2 + 32) = 0u;
        uint64_t v81 = (float32x4_t *)(a2 + 32);
        *(int32x2_t *)(a2 + 24) = v80;
        *(_OWORD *)(a2 + 48) = 0u;
        if ((v19 - 3) >= 3)
        {
          if ((v19 - 6) < 5) {
            abort();
          }
        }
        else
        {
          float32x4_t v22 = (float32x4_t)vdupq_n_s32(0x3C23D70Au);
          float32x4_t v79 = vmaxnmq_f32(v26, (float32x4_t)0);
          char v82 = (vminvq_u32((uint32x4_t)vcgtq_f32(v22, v79)) & 0x80000000) == 0 || v23;
          if (v82)
          {
            *uint64_t v81 = v79;
            float32x4_t v22 = (float32x4_t)vcgtq_f32(v22, vabdq_f32(v79, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v79.f32, 0)));
            if ((vminvq_u32((uint32x4_t)v22) & 0x80000000) != 0)
            {
              if (v19 != 4) {
                goto LABEL_86;
              }
              v87.f32[0] = *(float *)(a1 + 32) * (float)(v79.f32[0] * 0.78431);
              v87.f32[1] = v79.f32[0] * 0.78431;
              *(float *)v27.f64 = v79.f32[0] * 0.41464;
              *(float32x2_t *)&v27.f64[0] = vdiv_f32(vsub_f32((float32x2_t)v80, v87), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v27.f64[0], 0));
              __asm { FMOV            V2.2S, #1.0 }
              uint32x2_t v89 = (uint32x2_t)vand_s8((int8x8_t)vcgt_f32(*(float32x2_t *)&v27.f64[0], (float32x2_t)vdup_n_s32(0xB8D1B717)), (int8x8_t)vcgt_f32(_D2, *(float32x2_t *)&v27.f64[0]));
              double v28 = COERCE_DOUBLE(vpmax_u32(v89, v89));
              if ((LODWORD(v28) & 0x80000000) != 0)
              {
                float32x2_t v143 = vmaxnm_f32(*(float32x2_t *)&v27.f64[0], 0);
                *a6 = 10;
                float32x4_t v144 = *v81;
                v144.f32[1] = v79.f32[0] * 0.78431;
                *(int32x2_t *)&v144.u32[2] = vrev64_s32((int32x2_t)vsub_f32(_D2, vminnm_f32(v143, _D2)));
                *uint64_t v81 = v144;
              }
              else
              {
LABEL_86:
                *(float32x2_t *)(a2 + 24) = vsub_f32((float32x2_t)v80, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v79.f32, 0));
              }
            }
            else
            {
              *(float *)v80.i32 = fminf(*(float *)v17.i32, *(float *)&v17.i32[1]) * 0.5;
              float64x2_t v20 = (float64x2_t)vcgtq_f32(v79, (float32x4_t)vdupq_lane_s32(v80, 0));
              int v83 = vmaxvq_u32((uint32x4_t)v20);
              if (v19 == 4) {
                int v84 = 7;
              }
              else {
                int v84 = 6;
              }
              if (v19 == 4) {
                int v85 = 9;
              }
              else {
                int v85 = 8;
              }
              if (v83 >= 0) {
                int v86 = v84;
              }
              else {
                int v86 = v85;
              }
              *a6 = v86;
            }
          }
          else
          {
            *a6 = 2;
            float32x4_t v79 = 0uLL;
          }
        }
LABEL_87:
        float32x4_t v146 = v79;
        if (v23)
        {
          float v90 = *(float *)(a1 + 40);
          float32x2_t v91 = vrecpe_f32((float32x2_t)LODWORD(v90));
          float32x2_t v92 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v90), v91), v91);
          LODWORD(_S1) = vmul_f32(v92, vrecps_f32((float32x2_t)LODWORD(v90), v92)).u32[0];
          if ((*(unsigned char *)(a1 + 46) & 4) != 0)
          {
            _S1 = _S1 * 0.16956;
          }
          else if (*(unsigned char *)(a1 + 45) == 2)
          {
            _S1 = -_S1;
          }
          __asm { FCVT            H1, S1 }
          *(_WORD *)(a2 + 78) = _H1;
          if ((*(unsigned char *)(a1 + 46) & 4) == 0)
          {
            int v98 = *(unsigned __int8 *)(a1 + 45);
            float v99 = 0.0;
            if (v98 == 3) {
              float v96 = v90;
            }
            else {
              float v96 = 0.0;
            }
            if (v98 != 3) {
              float v99 = v90;
            }
LABEL_103:
            float v100 = v25 * 0.5;
            float v101 = -0.0;
            if (v25 > 0.0) {
              float v101 = v25 * 0.5;
            }
            float v102 = v96 + v101;
            if ((LODWORD(v102) & 0x7FFFFFFFu) >= 0x7F800000) {
              *(float *)&double v28 = 0.0;
            }
            else {
              *(float *)&double v28 = v102;
            }
            if ((LODWORD(v99) & 0x7FFFFFFFu) >= 0x7F800000) {
              float v103 = 0.0;
            }
            else {
              float v103 = v99;
            }
            if (v25 > 0.0)
            {
              if (*(unsigned char *)(a1 + 45) == 1)
              {
                *(float *)(a2 + 72) = v100;
              }
              else
              {
                float32x2_t v104 = vrecpe_f32((float32x2_t)v16);
                float32x2_t v105 = vmul_f32(vrecps_f32((float32x2_t)v16, v104), v104);
                float v106 = 0.5 * vmul_f32(v105, vrecps_f32((float32x2_t)v16, v105)).f32[0];
                BOOL v107 = v106 > v100;
                if (v106 > v100) {
                  float v100 = v106;
                }
                _S1 = 1.0;
                if (v107) {
                  _S1 = v25 * *(float *)&v16;
                }
                *(float *)(a2 + 72) = v100;
                __asm { FCVT            H0, S1 }
                *(_WORD *)(a2 + 76) = _H0;
              }
            }
            float32x2_t v110 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
            *(int32x2_t *)&v20.f64[0] = vcgt_f32(v110, *(float32x2_t *)v17.i8);
            int8x8_t v111 = (int8x8_t)vcltzq_s32((int32x4_t)v20).u64[0];
            float32x2_t v112 = (float32x2_t)vbsl_s8(v111, (int8x8_t)vsub_f32(v24, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v28, 0)), (int8x8_t)v24);
            int32x2_t v145 = *(int32x2_t *)&v28;
            int8x8_t v149 = v111;
            double v113 = COERCE_DOUBLE(vbsl_s8(v111, (int8x8_t)vmla_n_f32(*(float32x2_t *)v17.i8, (float32x2_t)0x4000000040000000, *(float *)&v28), *(int8x8_t *)v17.i8));
            *(double *)v22.i64 = v113;
            float32x2_t v114 = RB::operator*(&v157, v112, (int32x4_t)v22);
            int32x2_t v116 = (int32x2_t)RB::Bounds::Bounds((int32x2_t *)&v156, v114, v115);
            if (v18
              && ((*(unsigned char *)(a1 + 46) & 1) == 0
               || (RB::Bounds::contains((int32x2_t *)&v156, (int32x2_t)a3[20], (int32x2_t)a3[21]) & 1) != 0))
            {
              v117.i32[1] = HIDWORD(v151);
              if ((float)(vmuls_lane_f32(*(float *)&v151, *(float32x2_t *)v155.i8, 1) * *(float *)v155.i32) > 4096.0)
              {
                float32x4_t v118 = (float32x4_t)vdupq_lane_s32((int32x2_t)COERCE_UNSIGNED_INT(*(float *)v145.i32 + v103), 0);
                float32x4_t v119 = vaddq_f32(vmaxnmq_f32(vmulq_f32(vsubq_f32(v146, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a2 + 72), 0)), (float32x4_t)vdupq_n_s32(0x3E95F61Au)), (float32x4_t)0), v118);
                v118.f32[0] = fminf(*(float *)v155.i32, *(float *)&v155.i32[1]) * 0.5;
                if ((vminvq_u32((uint32x4_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v118.f32, 0), v119)) & 0x80000000) != 0)
                {
                  uint64_t v141 = ***(void ***)a3;
                  *(void *)a7 = *(void *)(v141 + 104);
                  *(_OWORD *)(a7 + 8) = *(_OWORD *)(v141 + 112);
                  if (v25 <= 0.0 && (*(unsigned char *)(a1 + 46) & 1) == 0)
                  {
                    *(void *)(a7 + 24) = *(void *)(v141 + 128);
                    *(_OWORD *)(a7 + 32) = *(_OWORD *)(v141 + 136);
                  }
                  *(float *)v117.i32 = *(float *)&v155.i32[1] + (float)(*(float *)v145.i32 * 2.0);
                  __asm { FMOV            V2.4S, #1.0 }
                  *(float32x4_t *)(a2 + 48) = vmulq_f32(vaddq_f32(v119, (float32x4_t)vdupq_lane_s32(v145, 0)), vdivq_f32(_Q2, (float32x4_t)vdupq_lane_s32(v117, 0)));
                  *(_OWORD *)a8 = v156;
                  return 1;
                }
              }
              *(_OWORD *)a8 = v156;
            }
            else
            {
              v116.i32[0] = 0;
              int v152 = *a6;
              int32x2_t v120 = (int32x2_t)a3[21];
              uint32x2_t v121 = (uint32x2_t)vceq_s32(v120, (int32x2_t)0x8000000080000000);
              int8x8_t v122 = (int8x8_t)vdup_lane_s32(vcgt_s32(v116, (int32x2_t)vpmin_u32(v121, v121)), 0);
              float32x2_t v123 = (float32x2_t)vbsl_s8(v122, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32((int32x2_t)a3[20]));
              int8x8_t v124 = vbsl_s8(v122, (int8x8_t)v110, (int8x8_t)vcvt_f32_s32(v120));
              float64x2_t v161 = v157;
              float64x2_t v162 = v158;
              v163[0] = v159;
              BOOL v125 = RB::AffineTransform::invert((RB::AffineTransform *)&v161);
              if (v125) {
                float64x2_t v126 = &v161;
              }
              else {
                float64x2_t v126 = &v157;
              }
              float64x2_t v127 = *v126;
              if (v125) {
                float64x2_t v128 = &v162;
              }
              else {
                float64x2_t v128 = &v158;
              }
              int32x4_t v129 = *(int32x4_t *)v128;
              if (v125) {
                float64x2_t v130 = (float32x4_t *)v163;
              }
              else {
                float64x2_t v130 = &v159;
              }
              float32x4_t v131 = *v130;
              float64x2_t v161 = v127;
              float64x2_t v162 = (float64x2_t)v129;
              v163[0] = v131;
              *(int8x8_t *)v129.i8 = v124;
              *(float32x2_t *)&long long v160 = RB::operator*(&v161, v123, v129);
              *((void *)&v160 + 1) = v132;
              RB::Rect::Union((float32x2_t *)&v160, *(double *)&v153, v155, v133, v134, v135, v136);
              *(float *)v137.i32 = fmaxf(*((float *)&v160 + 2), *((float *)&v160 + 3));
              uint64_t v138 = (void **)a3[21];
              *(float32x2_t *)a8 = a3[20];
              *(void *)(a8 + 8) = v138;
            }
            uint64_t v139 = ***(void ***)a3;
            *(void *)a7 = *(void *)(v139 + 80);
            *(_OWORD *)(a7 + 8) = *(_OWORD *)(v139 + 88);
            return 1;
          }
          float v96 = (float)(v90 * 2.8) + 1.0;
        }
        else
        {
          float32x2_t v94 = vrecpe_f32((float32x2_t)v16);
          float32x2_t v95 = vmul_f32(vrecps_f32((float32x2_t)v16, v94), v94);
          LODWORD(v96) = vmul_f32(v95, vrecps_f32((float32x2_t)v16, v95)).u32[0];
        }
        float v99 = 0.0;
        goto LABEL_103;
      }
LABEL_20:
      int v19 = 3;
      goto LABEL_21;
    }
    if (v19 == 7) {
      goto LABEL_20;
    }
    *a6 = 0;
    if ((may_discard_alpha & 1) == 0) {
      goto LABEL_46;
    }
    return 0;
  }
  if (v19 != 1)
  {
    if (v19) {
      goto LABEL_29;
    }
    if (may_discard_alpha) {
      return 0;
    }
  }
LABEL_46:
  LODWORD(v20.f64[0]) = 0;
  int32x2_t v59 = (int32x2_t)a3[21];
  uint32x2_t v60 = (uint32x2_t)vceq_s32(v59, (int32x2_t)0x8000000080000000);
  int8x8_t v61 = (int8x8_t)vdup_lane_s32(vcgt_s32(*(int32x2_t *)&v20.f64[0], (int32x2_t)vpmin_u32(v60, v60)), 0);
  float32x2_t v62 = (float32x2_t)vbsl_s8(v61, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32((int32x2_t)a3[20]));
  int8x8_t v63 = vbsl_s8(v61, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v59));
  float64x2_t v161 = v157;
  float64x2_t v162 = v158;
  v163[0] = v159;
  BOOL v64 = RB::AffineTransform::invert((RB::AffineTransform *)&v161);
  if (v64) {
    uint64_t v65 = &v161;
  }
  else {
    uint64_t v65 = &v157;
  }
  float64x2_t v66 = *v65;
  if (v64) {
    int32x2_t v67 = &v162;
  }
  else {
    int32x2_t v67 = &v158;
  }
  int32x4_t v68 = *(int32x4_t *)v67;
  if (v64) {
    __n128 v69 = (float32x4_t *)v163;
  }
  else {
    __n128 v69 = &v159;
  }
  float32x4_t v70 = *v69;
  float64x2_t v161 = v66;
  float64x2_t v162 = (float64x2_t)v68;
  v163[0] = v70;
  *(int8x8_t *)v68.i8 = v63;
  *(float32x2_t *)&double v71 = RB::operator*(&v161, v62, v68);
  uint64_t v38 = 1;
  uint64_t v73 = ***(void ***)a3;
  *(void *)a7 = *(void *)(v73 + 80);
  *(_OWORD *)(a7 + 8) = *(_OWORD *)(v73 + 88);
  unsigned int v74 = (void **)a3[21];
  *(float32x2_t *)a8 = a3[20];
  *(void *)(a8 + 8) = v74;
  return v38;
}

float32x2_t RB::operator*(float64x2_t *a1, float32x2_t result, int32x4_t a3)
{
  uint32x2_t v3 = (uint32x2_t)vcge_f32(vabs_f32(*(float32x2_t *)a3.i8), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  if ((vpmax_u32(v3, v3).u32[0] & 0x80000000) != 0) {
    return result;
  }
  uint32x2_t v4 = (uint32x2_t)vclez_f32(*(float32x2_t *)a3.i8);
  if ((vpmax_u32(v4, v4).u32[0] & 0x80000000) != 0)
  {
    float64x2_t v11 = vcvtq_f64_f32(result);
    return vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(a1[2], *a1, v11.f64[0]), a1[1], v11, 1));
  }
  float64x2_t v5 = *a1;
  if (a1->f64[1] != 0.0)
  {
    float64x2_t v6 = a1[1];
    goto LABEL_12;
  }
  float64x2_t v6 = a1[1];
  if (v6.f64[0] != 0.0)
  {
LABEL_12:
    float64x2_t v12 = vcvtq_f64_f32(result);
    *(float32x2_t *)&v12.f64[0] = vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(a1[2], v5, v12.f64[0]), v6, v12, 1));
    float64x2_t v13 = vcvtq_f64_f32(vadd_f32((float32x2_t)a3.u32[0], result));
    *(float32x2_t *)&v13.f64[0] = vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(a1[2], v5, v13.f64[0]), v6, v13, 1));
    float64x2_t v14 = vcvtq_f64_f32(vadd_f32(*(float32x2_t *)a3.i8, result));
    a3.i32[0] = 0;
    *(float32x2_t *)&v14.f64[0] = vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(a1[2], v5, v14.f64[0]), v6, v14, 1));
    float64x2_t v15 = vcvtq_f64_f32(vadd_f32(*(float32x2_t *)a3.i8, result));
    float32x2_t v16 = vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(a1[2], v5, v15.f64[0]), v6, v15, 1));
    float32x2_t v10 = vminnm_f32(vminnm_f32(*(float32x2_t *)&v12.f64[0], *(float32x2_t *)&v13.f64[0]), vminnm_f32(*(float32x2_t *)&v14.f64[0], v16));
    *(float32x2_t *)a3.i8 = vmaxnm_f32(vmaxnm_f32(*(float32x2_t *)&v12.f64[0], *(float32x2_t *)&v13.f64[0]), vmaxnm_f32(*(float32x2_t *)&v14.f64[0], v16));
    goto LABEL_13;
  }
  if (v5.f64[0] != 1.0 || v6.f64[1] != 1.0)
  {
    v5.f64[1] = a1[1].f64[1];
    float32x2_t v8 = vcvt_f32_f64(vmlaq_f64(a1[2], vcvtq_f64_f32(result), v5));
    float32x2_t v9 = vcvt_f32_f64(vmlaq_f64(a1[2], vcvtq_f64_f32(vadd_f32(*(float32x2_t *)a3.i8, result)), v5));
    float32x2_t v10 = vminnm_f32(v8, v9);
    *(float32x2_t *)a3.i8 = vmaxnm_f32(v8, v9);
LABEL_13:
    *(double *)&float16x4_t result = RB::Rect::from_bounds(v10, a3);
    return result;
  }
  return vadd_f32(result, vcvt_f32_f64(a1[2]));
}

float32x2_t RB::Bounds::Bounds(int32x2_t *a1, float32x2_t a2, float32x2_t a3)
{
  float32x2_t v3 = vrndm_f32(a2);
  float32x2_t result = vsub_f32(vrndp_f32(vadd_f32(a3, a2)), v3);
  uint32x2_t v5 = (uint32x2_t)vcgt_f32((float32x2_t)vdup_n_s32(0x4E800000u), result);
  if ((vpmin_u32(v5, v5).u32[0] & 0x80000000) != 0)
  {
    *a1 = vcvt_s32_f32(v3);
    uint32x2_t v6 = (uint32x2_t)vcgtz_f32(result);
    if ((vpmin_u32(v6, v6).u32[0] & 0x80000000) != 0)
    {
      float32x2_t result = (float32x2_t)vcvt_s32_f32(result);
      a1[1] = (int32x2_t)result;
    }
    else
    {
      a1[1] = 0;
    }
  }
  else
  {
    float32x2_t result = (float32x2_t)vdup_n_s32(0xC0000001);
    *a1 = (int32x2_t)result;
    a1[1] = (int32x2_t)0x8000000080000000;
  }
  return result;
}

BOOL RB::may_discard_shape(int a1)
{
  return (a1 - 24) < 0xFFFFFFFB;
}

uint64_t RB::Coverage::anonymous namespace'::set_primitive_rect(uint64_t result, float32x2_t *a2, float64x2_t *a3, int a4, double a5, double a6)
{
  float64x2_t v6 = a3[1];
  float64x2_t v7 = vmlaq_n_f64(vmlaq_n_f64(a3[2], *a3, *(float *)&a5), v6, *((float *)&a5 + 1));
  float32x2_t v8 = a2[14];
  v8.i32[1] = vneg_f32(v8).i32[1];
  *(float32x2_t *)float32x2_t result = vmul_f32(v8, vcvt_f32_f64(vmulq_n_f64(*a3, *(float *)&a6)));
  *(float32x2_t *)(result + 8) = vmul_f32(v8, vcvt_f32_f64(vmulq_n_f64(v6, *((float *)&a6 + 1))));
  float32x2_t v9 = vmla_f32((float32x2_t)0x3F800000BF800000, vcvt_f32_f64(v7), v8);
  float32x2_t v10 = vrecpe_f32((float32x2_t)HIDWORD(a6));
  float32x2_t v11 = vmul_f32(vrecps_f32((float32x2_t)HIDWORD(a6), v10), v10);
  float32x2_t v12 = vmul_f32(v11, vrecps_f32((float32x2_t)HIDWORD(a6), v11));
  *(_DWORD *)(result + 64) = vmul_f32(v12, *(float32x2_t *)&a6).u32[0];
  _D2 = vmul_n_f32(*(float32x2_t *)(result + 24), v12.f32[0]);
  *(float32x2_t *)(result + 16) = v9;
  *(float32x2_t *)(result + 24) = _D2;
  *(float *)(result + 72) = *(float *)(result + 72) * v12.f32[0];
  _D2.i16[0] = *(_WORD *)(result + 78);
  __asm { FCVT            S2, H2 }
  _S1 = vmuls_lane_f32(_D2.f32[0], *(float32x2_t *)&a6, 1);
  __asm { FCVT            H1, S1 }
  *(_WORD *)(result + 78) = LOWORD(_S1);
  if ((a4 - 6) < 4)
  {
    float32x4_t v19 = vmulq_n_f32(*(float32x4_t *)(result + 32), v12.f32[0]);
LABEL_5:
    *(float32x4_t *)(result + 32) = v19;
    return result;
  }
  if ((a4 - 3) < 3)
  {
    *(float *)(result + 32) = *(float *)(result + 32) * v12.f32[0];
    return result;
  }
  if (a4 == 10)
  {
    int8x16_t v20 = *(int8x16_t *)(result + 32);
    *(float32x2_t *)v19.f32 = vmul_n_f32(*(float32x2_t *)v20.i8, v12.f32[0]);
    v19.i64[1] = vextq_s8(v20, v20, 8uLL).u64[0];
    goto LABEL_5;
  }
  return result;
}

uint64_t RB::Bounds::contains(int32x2_t *a1, int32x2_t a2, int32x2_t a3)
{
  int32x2_t v3 = a1[1];
  uint32x2_t v4 = (uint32x2_t)vceqz_s32(v3);
  if ((vpmax_u32(v4, v4).u32[0] & 0x80000000) != 0) {
    return 0;
  }
  int8x8_t v5 = (int8x8_t)vcge_s32(a2, *a1);
  uint32x2_t v6 = (uint32x2_t)vcge_s32(vadd_s32(*a1, v3), vadd_s32(a3, a2));
  uint32x2_t v7 = (uint32x2_t)vcltz_s32(vshl_n_s32((int32x2_t)vand_s8((int8x8_t)vdup_n_s32(vpmin_u32(v6, v6).i32[0] < 0), v5), 0x1FuLL));
  return vpmin_u32(v7, v7).u32[0] >> 31;
}

uint64_t RB::Rect::is_integral(float32x2_t *this, int32x2_t a2)
{
  float32x2_t v2 = (float32x2_t)vdup_lane_s32(a2, 0);
  uint32x2_t v3 = (uint32x2_t)vcge_f32(v2, vabd_f32(*this, vrndm_f32(*this)));
  if ((vpmin_u32(v3, v3).u32[0] & 0x80000000) == 0) {
    return 0;
  }
  float32x2_t v5 = vadd_f32(this[1], *this);
  uint32x2_t v6 = (uint32x2_t)vcge_f32(v2, vabd_f32(v5, vrndm_f32(v5)));
  return vpmin_u32(v6, v6).u32[0] >> 31;
}

uint64_t RB::Rect::contains(float32x2_t *a1, float32x2_t a2, float32x2_t a3, double a4, double a5, double a6, int32x4_t a7)
{
  float32x2_t v7 = a1[1];
  uint32x2_t v8 = (uint32x2_t)vceqz_f32(v7);
  if ((vpmax_u32(v8, v8).u32[0] & 0x80000000) != 0) {
    return 0;
  }
  *(int32x2_t *)a7.i8 = vcltz_f32(v7);
  int32x4_t v9 = vcltzq_s32(a7);
  float32x2_t v10 = (float32x2_t)vbsl_s8(*(int8x8_t *)v9.i8, (int8x8_t)vadd_f32(*a1, v7), (int8x8_t)*a1);
  *(int32x2_t *)v9.i8 = vcltz_f32(a3);
  float32x2_t v11 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(v9), (int8x8_t)vadd_f32(a3, a2), (int8x8_t)a2);
  uint32x2_t v12 = (uint32x2_t)vcge_f32(v11, v10);
  if ((vpmin_u32(v12, v12).u32[0] & 0x80000000) == 0) {
    return 0;
  }
  uint32x2_t v14 = (uint32x2_t)vcge_f32(vadd_f32(v10, (float32x2_t)(*(void *)&v7 & 0x7FFFFFFF7FFFFFFFLL)), vadd_f32(v11, vabs_f32(a3)));
  return vpmin_u32(v14, v14).u32[0] >> 31;
}

void RB::CGContext::update_state_slow(uint64_t a1, float64x2_t *a2, float32x2_t *a3, unsigned int a4, _OWORD *a5, int a6, float a7)
{
  char v7 = a6;
  if (a6)
  {
    int v13 = *(unsigned __int8 *)(a1 + 141);
    goto LABEL_10;
  }
  uint32x2_t v14 = (float64x2_t **)(a1 + 80);
  if (*(unsigned char *)(a1 + 141))
  {
    CGContextRestoreGState(*(CGContextRef *)a1);
    int v13 = *(_DWORD *)(a1 + 416);
    if (v13)
    {
      uint64_t v15 = a1 + 152;
      if (*(void *)(a1 + 408)) {
        uint64_t v15 = *(void *)(a1 + 408);
      }
      unint64_t v16 = v15 + ((unint64_t)(v13 - 1) << 6);
      *(_OWORD *)v48[0].i8 = *(_OWORD *)v16;
      int32x2_t v17 = *(int32x2_t *)(v16 + 16);
      unint64_t v18 = *(void *)(v16 + 24);
      uint64_t v19 = *(void *)(v16 + 32);
      __int16 v20 = *(_WORD *)(v16 + 40);
      uint64_t v21 = *(void *)(v16 + 42);
      __int16 v22 = *(_WORD *)(v16 + 50);
      float v23 = *(float *)(v16 + 52);
      int v24 = *(_DWORD *)(v16 + 56);
      char v25 = *(unsigned char *)(v16 + 60);
      int v13 = *(unsigned __int8 *)(v16 + 61);
    }
    else
    {
      char v25 = 0;
      __int16 v22 = 0;
      __int16 v20 = 0;
      int32x2_t v17 = vdup_n_s32(0xC0000001);
      *(_OWORD *)v48[0].i8 = 0uLL;
      uint64_t v21 = 0x3C00000000000000;
      unint64_t v18 = 0x8000000080000000;
      int v24 = 2;
      float v23 = 1.0;
      uint64_t v19 = 0x3C00000000000000;
    }
    *(_OWORD *)uint32x2_t v14 = *(_OWORD *)v48[0].i8;
    *(int32x2_t *)(a1 + 96) = v17;
    *(void *)(a1 + 104) = v18;
    *(void *)(a1 + 112) = v19;
    *(_WORD *)(a1 + 120) = v20;
    *(void *)(a1 + 122) = v21;
    *(_WORD *)(a1 + 130) = v22;
    *(float *)(a1 + 132) = v23;
    *(_DWORD *)(a1 + 136) = v24;
    *(unsigned char *)(a1 + 140) = v25;
    *(unsigned char *)(a1 + 141) = v13;
LABEL_10:
    uint32x2_t v14 = (float64x2_t **)(a1 + 80);
    if (v13) {
      goto LABEL_12;
    }
  }
  CGContextSaveGState(*(CGContextRef *)a1);
  *(unsigned char *)(a1 + 141) = 1;
LABEL_12:
  if (v7) {
    goto LABEL_36;
  }
  *(int32x2_t *)(a1 + 96) = vdup_n_s32(0xC0000001);
  *(void *)(a1 + 88) = a3;
  *(void *)(a1 + 104) = 0x8000000080000000;
  if (*(void *)(a1 + 80))
  {
    long long v26 = *(_OWORD *)(a1 + 48);
    long long v45 = *(_OWORD *)(a1 + 32);
    long long v46 = v26;
    long long v47 = *(_OWORD *)(a1 + 64);
    CGContextSetCTM();
    *(void *)(a1 + 80) = 0;
  }
  float64x2_t v27 = a5;
  if (!a3)
  {
    char v29 = 0;
    char v28 = 0;
    goto LABEL_30;
  }
  char v28 = 0;
  char v29 = 0;
  float32x2_t v30 = a3;
  do
  {
    unint64_t v31 = *(void *)&v30[1] & 0xFFFFFFFFFFFFFFFELL;
    if (*(unsigned char *)(v31 + 44) == 1)
    {
      char v28 = 1;
    }
    else if (*(unsigned char *)(v31 + 45))
    {
      if (*(unsigned char *)(a1 + 140) != 1)
      {
        *(unsigned char *)(a1 + 140) = 1;
        CGContextSetShouldAntialias(*(CGContextRef *)a1, 0);
      }
      v49.origin.CGFloat x = COERCE_FLOAT(*(void *)(v31 + 16));
      v49.origin.CGFloat y = COERCE_FLOAT(HIDWORD(*(void *)(v31 + 16)));
      v49.size.CGFloat width = COERCE_FLOAT(*(void *)(v31 + 24));
      v49.size.CGFloat height = COERCE_FLOAT(HIDWORD(*(void *)(v31 + 24)));
      CGContextClipToRect(*(CGContextRef *)a1, v49);
    }
    else if ((*(float (**)(unint64_t))(*(void *)v31 + 104))(*(void *)&v30[1] & 0xFFFFFFFFFFFFFFFELL) == 1.0)
    {
      (*(void (**)(unint64_t, uint64_t))(*(void *)v31 + 88))(v31, a1);
    }
    else
    {
      char v29 = 1;
    }
    float32x2_t v30 = (float32x2_t *)*v30;
  }
  while (v30);
  if ((v28 & 1) == 0)
  {
LABEL_30:
    if ((v29 & 1) == 0) {
      goto LABEL_36;
    }
  }
  *(_OWORD *)(a1 + 96) = *v27;
  *(_OWORD *)v48[0].i8 = *v27;
  RB::Bounds::Bounds(v44, a3[2], a3[3]);
  RB::Bounds::intersect(v48, v44[0], v44[1]);
  ClipBoundingBoCGFloat x = CGContextGetClipBoundingBox((CGContextRef)*(void *)a1);
  CGFloat y = ClipBoundingBox.origin.y;
  CGFloat height = ClipBoundingBox.size.height;
  RB::Bounds::Bounds(v43, vcvt_f32_f64((float64x2_t)ClipBoundingBox.origin), vcvt_f32_f64((float64x2_t)ClipBoundingBox.size));
  RB::Bounds::intersect(v48, v43[0], v43[1]);
  *(int32x2_t *)v34.i8 = vcgtz_s32(v48[1]);
  *(uint32x2_t *)v34.i8 = vpmin_u32(*(uint32x2_t *)v34.i8, *(uint32x2_t *)v34.i8);
  if (v34.i32[0] < 0)
  {
    v34.i32[0] = 0;
    uint32x2_t v35 = (uint32x2_t)vceq_s32(v48[1], (int32x2_t)0x8000000080000000);
    int8x8_t v36 = (int8x8_t)vdup_lane_s32(vcgt_s32(*(int32x2_t *)v34.i8, (int32x2_t)vpmin_u32(v35, v35)), 0);
    int8x8_t v37 = vbsl_s8(v36, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v48[1]));
    float32x2_t v38 = (float32x2_t)vbsl_s8(v36, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v48[0]));
    if (v28)
    {
      float32x2_t v42 = a3;
      *(int8x8_t *)v34.i8 = v37;
      RB::CGContext::add_soft_mask(a1, 2, (uint64_t)&v42, (void (*)(CGContextRef *, uint64_t))RB::CGContext::add_soft_mask<RB::CGContext::update_state_slow(RB::AffineTransform const*,RB::DisplayList::ClipNode const*,float,RB::BlendMode,RB::Bounds const&,BOOL)::$_0>(RB::CGContext::SoftMaskMode,RB::Rect,RB::CGContext::update_state_slow(RB::AffineTransform const*,RB::DisplayList::ClipNode const*,float,RB::BlendMode,RB::Bounds const&,BOOL)::$_0 const&)::{lambda(RB::CGContext&,void const*)#1}::__invoke, v38, v34);
    }
    if (v29)
    {
      float32x2_t v42 = a3;
      *(int8x8_t *)v34.i8 = v37;
      RB::CGContext::add_soft_mask(a1, 0, (uint64_t)&v42, (void (*)(CGContextRef *, uint64_t))RB::CGContext::add_soft_mask<RB::CGContext::update_state_slow(RB::AffineTransform const*,RB::DisplayList::ClipNode const*,float,RB::BlendMode,RB::Bounds const&,BOOL)::$_1>(RB::CGContext::SoftMaskMode,RB::Rect,RB::CGContext::update_state_slow(RB::AffineTransform const*,RB::DisplayList::ClipNode const*,float,RB::BlendMode,RB::Bounds const&,BOOL)::$_1 const&)::{lambda(RB::CGContext&,void const*)#1}::__invoke, v38, v34);
    }
  }
LABEL_36:
  if (*v14 != a2)
  {
    *(void *)(a1 + 80) = a2;
    if (a2) {
      RB::operator*(a2, (float64x2_t *)(a1 + 32));
    }
    CGContextSetCTM();
  }
  if (*(float *)(a1 + 132) != a7)
  {
    *(float *)(a1 + 132) = a7;
    CGContextSetAlpha(*(CGContextRef *)a1, a7);
  }
  if (*(_DWORD *)(a1 + 136) != a4)
  {
    *(_DWORD *)(a1 + 136) = a4;
    float32x2_t v39 = *(CGContext **)a1;
    CGBlendMode v40 = RB::cg_blend_mode(a4);
    CGContextSetBlendMode(v39, v40);
  }
}

double RB::CGContext::set_fill_color_slow(RB::CGContext *this, const RB::Fill::Color *a2, uint16x4_t a3)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  uint64_t v5 = *(void *)a2;
  *((_WORD *)this + 60) = *((_WORD *)a2 + 4);
  *((void *)this + 14) = v5;
  a3.i16[0] = *(_WORD *)a2;
  _ZF = *(short float *)a2 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(-1.0))
     && *((short float *)a2 + 1) == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(-1.0));
  if (_ZF && (RB::CGContext::display_list_context(this, a2) & 1) == 0)
  {
    *((void *)this + 14) = 0x3C003C0000003C00;
    *((_WORD *)this + 60) = 0;
  }
  int v7 = *((unsigned __int8 *)this + 8);
  CGFloat components = *(CGFloat *)a2;
  v18.i16[0] = *((_WORD *)a2 + 4);
  RB::Fill::Color::convert((uint64_t)&components, v7, a3);
  _Q0 = (uint64x2_t)vdupq_n_s64(*(unint64_t *)&components);
  _H1 = LOWORD(components);
  _S2 = HIWORD(*(void *)&components);
  __asm { FCVT            D1, H1 }
  CGFloat components = _D1;
  *(int32x2_t *)_Q0.i8 = vmovn_s64((int64x2_t)vshlq_u64(_Q0, (uint64x2_t)xmmword_21421A500));
  _Q0.i32[0] = vuzp1_s16(*(int16x4_t *)_Q0.i8, *(int16x4_t *)_Q0.i8).u32[0];
  LOWORD(_D1) = _Q0.i16[1];
  __asm
  {
    FCVT            D1, H1
    FCVT            D0, H0
  }
  _Q0.i64[1] = _D1;
  uint64x2_t v18 = _Q0;
  __asm { FCVT            D0, H2 }
  uint64_t v19 = _Q0.i64[0];
  CGContextSetFillColor(*(CGContextRef *)this, &components);
  return result;
}

void RB::Fill::Color::convert(uint64_t a1, int a2, uint16x4_t a3)
{
  __int16 v3 = a2;
  if (*(unsigned char *)(a1 + 9))
  {
    uint64_t v5 = (RB::Shader::Tables *)*(unsigned __int8 *)(a1 + 8);
    if (v5 == a2) {
      return;
    }
    a3.i32[0] = *(_DWORD *)a1;
    a3.i16[2] = *(_WORD *)(a1 + 4);
    double v6 = RB::Fill::Color::convert_color(v5, a2, a3);
    *(_DWORD *)a1 = LODWORD(v6);
    *(_WORD *)(a1 + 4) = WORD2(v6);
  }
  *(_WORD *)(a1 + 8) = v3 | 0x100;
}

uint64_t RB::DisplayList::LayerTask::find_clip_index(RB::DisplayList::LayerTask *this, const RB::DisplayList::Item *a2)
{
  unint64_t v2 = *((unsigned int *)this + 50);
  if (!v2) {
    goto LABEL_9;
  }
  __int16 v3 = (void *)*((void *)this + 24);
  uint32x2_t v4 = &v3[2 * v2];
  do
  {
    unint64_t v5 = v2 >> 1;
    double v6 = &v3[2 * (v2 >> 1)];
    unint64_t v8 = *v6;
    int v7 = v6 + 2;
    v2 += ~(v2 >> 1);
    if (v8 < (unint64_t)a2) {
      __int16 v3 = v7;
    }
    else {
      unint64_t v2 = v5;
    }
  }
  while (v2);
  if (v3 != v4 && (const RB::DisplayList::Item *)*v3 == a2)
  {
    int v9 = *((_DWORD *)v3 + 2);
    unsigned int v11 = v9 & 0xFFFFFF00;
    int v9 = v9;
    uint64_t v10 = 0x100000000;
  }
  else
  {
LABEL_9:
    int v9 = 0;
    uint64_t v10 = 0;
    unsigned int v11 = 0;
  }
  return v10 | v11 | v9;
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Primitive>::render(uint64_t a1, double a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5 = *(void *)(a1 + 48);
  v6.i64[0] = SLODWORD(a2);
  v6.i64[1] = SHIDWORD(a2);
  long long v7 = *(_OWORD *)(v5 + 16);
  float64x2_t v8 = vaddq_f64(*(float64x2_t *)(v5 + 32), vcvtq_f64_s64(v6));
  v10[0] = *(_OWORD *)v5;
  v10[1] = v7;
  v10[2] = v8;
  return RB::render_primitive_coverage(a4, (uint64_t)v10, a1 + 64, a5, *(float *)(a1 + 112));
}

uint64_t RB::render_primitive_coverage(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, float a5)
{
}

BOOL RB::AffineTransform::invert(RB::AffineTransform *this)
{
  int8x16_t v1 = *((int8x16_t *)this + 1);
  float64x2_t v2 = vmulq_f64((float64x2_t)vextq_s8(v1, v1, 8uLL), *(float64x2_t *)this);
  double v3 = vsubq_f64(v2, (float64x2_t)vdupq_laneq_s64((int64x2_t)v2, 1)).f64[0];
  if (v3 != 0.0)
  {
    float64x2_t v4 = *((float64x2_t *)this + 2);
    float64x2_t v5 = (float64x2_t)vextq_s8((int8x16_t)v4, (int8x16_t)v4, 8uLL);
    v6.f64[0] = *((float64_t *)this + 2);
    v6.f64[1] = *((float64_t *)this + 1);
    float64x2_t v7 = vmulq_n_f64(v6, 1.0 / v3);
    float64x2_t v8 = vmulq_n_f64((float64x2_t)vextq_s8(v1, *(int8x16_t *)this, 8uLL), 1.0 / v3);
    float64x2_t v9 = vnegq_f64(vmulq_f64(v4, v8));
    v4.f64[0] = v8.f64[0];
    v4.f64[1] = vnegq_f64(v7).f64[1];
    v8.f64[0] = -v7.f64[0];
    *(float64x2_t *)this = v4;
    *((float64x2_t *)this + 1) = v8;
    *((float64x2_t *)this + 2) = vmlaq_f64(v9, v7, v5);
  }
  return v3 != 0.0;
}

uint64_t RB::anonymous namespace'::render_coverage(uint64_t a1, uint64_t a2, uint64_t a3, char a4, unsigned int a5, _OWORD *a6, float a7)
{
  _S8 = a7;
  int v29 = 0;
  memset(v28, 0, sizeof(v28));
  long long v27 = 0uLL;
  uint64_t v12 = RB::Coverage::Primitive::set_globals(a3, (uint64_t)v30, (float32x2_t *)a1, a2, a5, &v29, (uint64_t)v28, (uint64_t)&v27);
  if (v12)
  {
    __asm { FCVT            H0, S8 }
    LOWORD(v31) = _H0;
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a1, (RB::Device *)0x54, 4uLL, 0, &v32);
    uint64x2_t v18 = v32;
    if (v32)
    {
      uint64_t v19 = *((void *)v32 + 7) + v33.i64[0];
      long long v20 = v30[0];
      *(_OWORD *)(v19 + 16) = v30[1];
      long long v21 = v30[4];
      long long v22 = v30[3];
      long long v23 = v30[2];
      *(_DWORD *)(v19 + 80) = v31;
      *(_OWORD *)(v19 + 48) = v22;
      *(_OWORD *)(v19 + 64) = v21;
      *(_OWORD *)(v19 + 32) = v23;
      *(_OWORD *)uint64_t v19 = v20;
    }
    else
    {
      int32x2_t v32 = 0;
      int64x2_t v33 = 0uLL;
    }
    *(_DWORD *)(a1 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a1, v18);
    *(int32x2_t *)(a1 + 188) = vmovn_s64(v33);
    LODWORD(v32) = v29 & 0xF;
    RB::Coverage::Primitive::set_coverage_state(a3, &v32);
    if (*(_DWORD *)(a1 + 136) == 2) {
      int v24 = 131076;
    }
    else {
      int v24 = 4;
    }
    uint64_t v25 = a4 & 0x3F;
    RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, (const char *)(v24 & 0xFFFF003F | (((unsigned __int16)v32 & 0x3FF) << 6) | ((unint64_t)(v25 & 0x3F) << 32)), 4, (uint64_t)v28, 0, 1uLL, *(int32x2_t *)&v27, *(int32x2_t *)((char *)&v27 + 8));
    if (*((void *)&v28[1] + 1))
    {
      LODWORD(v32) = v32 & 0xFFFFFFF0 | 1;
      RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, (const char *)((v25 << 32) | (v32 << 6) & 0xFFC0 | v24), 4, (uint64_t)&v28[1] + 8, 0, 1uLL, *(int32x2_t *)&v27, *(int32x2_t *)((char *)&v27 + 8));
    }
    *(void *)(a1 + 200) = 0;
    *(_DWORD *)(a1 + 196) = 0;
    if (a6) {
      *a6 = v27;
    }
  }
  return v12;
}

__int16 RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::render@<H0>(uint64_t a1@<X0>, double a2@<D0>, uint64_t a3@<X1>, uint64_t a4@<X2>, char a5@<W3>, int a6@<W4>)
{
  float64x2_t v6 = *(float64x2_t **)(a1 + 48);
  v7.i64[0] = SLODWORD(a2);
  v7.i64[1] = SHIDWORD(a2);
  float64x2_t v8 = v6[1];
  float64x2_t v9 = vaddq_f64(v6[2], vcvtq_f64_s64(v7));
  v11[0] = *v6;
  v11[1] = v8;
  float32x2_t v11[2] = v9;
  LOWORD(v9.f64[0]) = *(_WORD *)(a1 + 44);
  __int16 v12 = *(_WORD *)(a1 + 112);
  int v13 = *(_DWORD *)(a1 + 114);
  short float v14 = *(short float *)(a1 + 118) * *(short float *)v9.f64;
  __int16 v15 = *(_WORD *)(a1 + 120);
  RB::render_glyphs(a4, v11, (float32x2_t *)(a1 + 56), (uint64_t)&v12, a5, a6);
  return result;
}

void RB::render_glyphs(uint64_t a1, float64x2_t *a2, float32x2_t *a3, uint64_t a4, char a5, int a6)
{
  v14[0] = &unk_26C4EE760;
  v14[1] = a4;
  char v15 = a5;
  int v16 = a6;
  if (a3[2].i32[0] < 2u)
  {
    char v12 = 0;
  }
  else
  {
    BOOL v10 = a6 != 2 && a6 != 24;
    char v12 = *(short float *)(a4 + 6) != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)) || (a3[6].i8[5] & 1) != 0 || v10;
  }
  BOOL may_discard_shape = RB::may_discard_shape(a6);
}

char *RB::RenderQueue::grow_ops(RB::RenderQueue *this)
{
  unsigned int v2 = *((_DWORD *)this + 1);
  if (v2)
  {
    unsigned int v3 = v2 + (v2 >> 1);
    size_t v4 = 8 * v3;
    if (v2 == 64)
    {
      float64x2_t v5 = malloc_type_malloc(v4, 0xCCA35843uLL);
      __int16 result = (char *)memcpy(v5, *((const void **)this + 1), v4);
    }
    else
    {
      __int16 result = (char *)malloc_type_realloc(*((void **)this + 1), 8 * (v2 + (v2 >> 1)), 0xD0DD158AuLL);
      float64x2_t v5 = result;
    }
    if (!v5) {
      abort();
    }
    *((void *)this + 1) = v5;
    *((_DWORD *)this + 1) = v3;
  }
  else
  {
    *((_DWORD *)this + 1) = 64;
    unint64_t v7 = *((void *)this + 5);
    __int16 result = (char *)((*((void *)this + 4) + 7) & 0xFFFFFFFFFFFFFFF8);
    if ((unint64_t)(result + 512) > v7) {
      __int16 result = (char *)RB::Heap::alloc_slow((size_t *)this + 2, 0x200uLL, 7);
    }
    else {
      *((void *)this + 4) = result + 512;
    }
    *((void *)this + 1) = result;
  }
  return result;
}

void RB::RenderFrame::acquire_queue(uint64_t a1, uint64_t *a2)
{
  if (!*a2)
  {
    size_t v4 = (os_unfair_lock_s *)(a1 + 232);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 232));
    int v6 = *(_DWORD *)(a1 + 280);
    if (v6)
    {
      uint64_t v7 = a1 + 240;
      uint64_t v8 = *(void *)(a1 + 272);
      if (!v8) {
        uint64_t v8 = a1 + 240;
      }
      unsigned int v9 = v6 - 1;
      uint64_t v10 = *(void *)(v8 + 8 * v9);
      *(void *)(v8 + 8 * v9) = *a2;
      *a2 = v10;
      *(_DWORD *)(a1 + 280) = v9;
      if (*(void *)(a1 + 272)) {
        uint64_t v7 = *(void *)(a1 + 272);
      }
      uint64_t v11 = *(void *)(v7 + 8 * v9);
      *(void *)(v7 + 8 * v9) = 0;
      if (v11) {
        RB::RenderFrame::QueueDeleter::operator()(v5, v11);
      }
      os_unfair_lock_unlock(v4);
    }
    else
    {
      os_unfair_lock_unlock(v4);
      char v12 = (char *)malloc_type_malloc(0x2020uLL, 0x10B00405DA38DC0uLL);
      *(void *)char v12 = 0;
      *((void *)v12 + 1) = 0;
      int v13 = RB::Heap::Heap((RB::Heap *)(v12 + 16), v12 + 56, 8064, 0);
      uint64_t v14 = *a2;
      *a2 = (uint64_t)v12;
      if (v14)
      {
        RB::RenderFrame::QueueDeleter::operator()((uint64_t)v13, v14);
      }
    }
  }
}

void RB::Device::alloc_shared_buffer(RB::Device *this@<X0>, uint64_t *a2@<X8>)
{
  size_t v4 = 0;
  *a2 = 0;
  unsigned int v5 = *((_DWORD *)this + 48);
  for (uint64_t i = (uint64_t *)((char *)this + 344);
        *((void *)this + 45);
        std::__list_imp<RB::refcounted_ptr<RB::Texture>>::__delete_node[abi:nn180100]<>((int)i, v11))
  {
    uint64_t v7 = *((void *)this + 44);
    uint64_t v8 = *(id **)(v7 + 16);
    if (*((_DWORD *)v8 + 8) > v5) {
      break;
    }
    if (v4 != v8)
    {
      if (!v4
        || (int v9 = *((_DWORD *)v4 + 2) - 1, (*((_DWORD *)v4 + 2) = v9) != 0)
        || ((*((void (**)(id *))*v4 + 1))(v4), (uint64_t v8 = *(id **)(v7 + 16)) != 0))
      {
        ++*((_DWORD *)v8 + 2);
      }
      *a2 = (uint64_t)v8;
      size_t v4 = v8;
    }
    int v10 = RB::Resource::set_volatile(v4, 0);
    uint64_t v11 = (uint64_t *)*((void *)this + 44);
    char v12 = (uint64_t *)v11[1];
    if (v10 != 2)
    {
      if (v11 != v12)
      {
        uint64_t v16 = *v12;
        uint64_t v17 = *v11;
        *(void *)(v17 + 8) = *(void *)(v16 + 8);
        **(void **)(v16 + 8) = v17;
        uint64_t v18 = *i;
        *(void *)(v18 + 8) = v11;
        *uint64_t v11 = v18;
        *uint64_t i = v16;
        *(void *)(v16 + 8) = i;
      }
      RB::Resource::set_frame_id((uint64_t)v4, 0, 0);
      return;
    }
    uint64_t v13 = *v11;
    *(void *)(v13 + 8) = v12;
    *(void *)v11[1] = v13;
    --*((void *)this + 45);
  }
  uint64_t v14 = (RB *)RB::Buffer::alloc((id *)this, *((RB::Device **)this + 34));
  *a2 = (uint64_t)v14;
  if (v4 && (int v15 = *((_DWORD *)v4 + 2) - 1, (*((_DWORD *)v4 + 2) = v15) == 0))
  {
    (*((void (**)(id *))*v4 + 1))(v4);
    uint64_t v14 = (RB *)*a2;
    if (*a2) {
      goto LABEL_15;
    }
  }
  else if (v14)
  {
LABEL_15:
    std::list<RB::refcounted_ptr<RB::Buffer>>::push_back(i, a2);
    *((void *)this + 46) += *((void *)this + 34);
    return;
  }
  uint64_t v19 = RB::error_log(v14);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
    RB::Device::alloc_shared_buffer((uint64_t *)this + 34, v19);
  }
}

void sub_2141117EC(_Unwind_Exception *exception_object)
{
  unsigned int v3 = *v1;
  if (*v1)
  {
    int v4 = v3[2] - 1;
    v3[2] = v4;
    if (!v4) {
      (*(void (**)(_DWORD *))(*(void *)v3 + 8))(v3);
    }
  }
  _Unwind_Resume(exception_object);
}

void *std::list<RB::refcounted_ptr<RB::Buffer>>::push_back(uint64_t *a1, uint64_t *a2)
{
  __int16 result = operator new(0x18uLL);
  uint64_t v5 = *a2;
  if (*a2) {
    ++*(_DWORD *)(v5 + 8);
  }
  result[1] = a1;
  result[2] = v5;
  uint64_t v6 = *a1;
  *__int16 result = *a1;
  *(void *)(v6 + 8) = result;
  *a1 = (uint64_t)result;
  ++a1[2];
  return result;
}

uint64_t RB::cg_blend_mode(unsigned int a1)
{
  if (a1 <= 0x2C && ((0x70C01FFA004uLL >> a1) & 1) == 0) {
    return dword_21421C240[a1];
  }
  if (a1) {
    return 0;
  }
  return 17;
}

void *RB::DisplayList::Builder::clear_caches(RB::DisplayList::Builder *this)
{
  for (__int16 result = (void *)*((void *)this + 2); result; __int16 result = (void *)*((void *)this + 2))
  {
    *((void *)this + 2) = *result;
    free(result);
  }
  return result;
}

void *RB::details::realloc_vector<unsigned int,16ul>(void *__src, void *__dst, unsigned int a3, _DWORD *a4, unsigned int a5)
{
  uint64_t v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      LODWORD(v9) = a3;
      memcpy(__dst, __src, 16 * a5);
      free(v7);
      char v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(16 * a5);
    size_t v9 = v8 >> 4;
    if (*a4 != (v8 >> 4))
    {
      int v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10) {
        RB::precondition_failure((RB *)"allocation failure", v11);
      }
      char v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, 16 * *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

void RBPathCopyTransformedPath(uint64_t a1, void *a2)
{
  if (a2 != &empty_path_callbacks) {
    operator new();
  }
}

void sub_214111BE0(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10E1C404703BB35);
  _Unwind_Resume(a1);
}

void ___ZN2RB6Device19RenderPipelineEntry6Loader7load_fnENS2_8FunctionE_block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(id **)(a1 + 32);
  int v4 = *(_DWORD *)(a1 + 40);
  if (v4 == 1)
  {
    RB::Device::RenderPipelineEntry::Loader::fragment_fn(v3, a2);
  }
  else if (!v4)
  {
    RB::Device::RenderPipelineEntry::Loader::vertex_fn(v3, a2);
  }
}

void RB::Device::RenderPipelineEntry::Loader::finished(void)::$_0::__invoke(uint64_t a1)
{
}

uint64_t RB::SurfacePool::shared(RB::SurfacePool *this)
{
  if (RB::SurfacePool::_shared_once != -1) {
    dispatch_once_f(&RB::SurfacePool::_shared_once, 0, (dispatch_function_t)RB::SurfacePool::shared(void)::$_0::__invoke<void *>);
  }
  return RB::SurfacePool::_shared_pool;
}

void sub_214112820(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,id a31,id a32,uint64_t a33,id a34,uint64_t a35,uint64_t a36,id a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,id a48)
{
  if (*(unsigned char *)(v50 - 200)) {
    os_unfair_lock_unlock(*(os_unfair_lock_t *)(v50 - 208));
  }

  _Unwind_Resume(a1);
}

uint64_t RBXMLRecorderInstalled(void)
{
  if (RBXMLRecorderInstalled(void)::once != -1) {
    dispatch_once(&RBXMLRecorderInstalled(void)::once, &__block_literal_global);
  }
  return RB::XMLRecorder::installed;
}

uint64_t RB::DisplayList::LayerItem::required_depth(RB::DisplayList::LayerItem *this)
{
  unsigned int v2 = (RB::DisplayList::Layer *)*((void *)this + 6);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = RB::DisplayList::Layer::output_depth(v2);
  uint64_t v4 = *((void *)this + 6);
  if (*(unsigned char *)(v4 + 64) != 2) {
    return v3;
  }
  uint64_t v5 = *(uint64_t (**)(void))(**(void **)(v4 + 24) + 88);
  return v5();
}

uint64_t RB::DisplayList::Layer::output_depth(RB::DisplayList::Layer *this)
{
  uint64_t result = *((unsigned __int8 *)this + 65);
  for (uint64_t i = (void *)*((void *)this + 2); i; uint64_t i = (void *)i[1])
    uint64_t result = (*(uint64_t (**)(void *, void))(*i + 72))(i, result);
  return result;
}

float32x2_t *RB::DisplayList::Builder::set_crop(float32x2_t *result, float32x2_t a2, float32x2_t a3)
{
  uint32x2_t v3 = (uint32x2_t)vand_s8((int8x8_t)vceq_f32(result[31], a3), (int8x8_t)vceq_f32(result[30], a2));
  if ((vpmin_u32(v3, v3).u32[0] & 0x80000000) == 0)
  {
    result[30] = a2;
    result[31] = a3;
    int v4 = result->i32[0] + 1;
    result->i32[0] = v4;
    result[32].i32[0] = v4;
  }
  return result;
}

uint64_t begin_cgcontext(_RBDrawingState *a1, float a2, double a3, int a4)
{
  uint64_t v8 = *((void *)a1 + 1);
  unsigned int v9 = *(_DWORD *)(v8 + 344);
  if (*(_DWORD *)(v8 + 348) < v9 + 1)
  {
    RB::vector<std::pair<RB::cf_ptr<CGContext *>,RB::ContextDelegate *>,1ul,unsigned int>::reserve_slow((void *)(v8 + 320), v9 + 1);
    unsigned int v9 = *(_DWORD *)(v8 + 344);
  }
  uint64_t v10 = *(void *)(v8 + 336);
  if (!v10) {
    uint64_t v10 = v8 + 320;
  }
  uint64_t v11 = (void *)(v10 + 16 * v9);
  *uint64_t v11 = 0;
  v11[1] = 0;
  uint64_t v12 = *(unsigned int *)(v8 + 344);
  *(_DWORD *)(v8 + 344) = v12 + 1;
  uint64_t v13 = *(void *)(v8 + 336);
  if (!v13) {
    uint64_t v13 = v8 + 320;
  }
  uint64_t v14 = v13 + 16 * v12;
  RB::ContextDelegate::borrow_context((uint64_t *)v14);
  RB::ContextDelegate::begin(*(RB::ContextDelegate **)(v14 + 8), a1, a2, a3, a4);
  return *(void *)v14;
}

uint64_t RB::ContextDelegate::begin(RB::ContextDelegate *this, _RBDrawingState *a2, float a3, double a4, int a5)
{
  RBDrawingStateGetCTM((uint64_t)a2, (uint64_t)v13);
  long long v10 = v13[1];
  long long v11 = v13[2];
  *((_OWORD *)this + 24) = v13[0];
  *((_OWORD *)this + 25) = v10;
  *((_OWORD *)this + 26) = v11;
  *((void *)this + 54) = a2;
  *((void *)this + 55) = 0;
  *((float *)this + 114) = a3;
  *((double *)this + 56) = a4;
  *((_DWORD *)this + 115) = a5;
  *((_DWORD *)this + 116) = 0;
  *((void *)this + 59) = 0;
  uint64_t result = RBDrawingStateGetDefaultColorSpace((uint64_t)a2);
  *((_DWORD *)this + 132) = result;
  return result;
}

uint64_t rb_color_space(__int16 a1)
{
  if ((a1 & 0xFF00) == 0) {
    return 0;
  }
  if ((a1 - 1) > 4u) {
    return 2;
  }
  return dword_214219E40[(char)(a1 - 1)];
}

uint64_t RBDrawingStateGetDefaultColorSpace(uint64_t a1)
{
  return rb_color_space(*(_WORD *)(a1 + 156));
}

__n128 RBDrawingStateGetCTM@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  long long v2 = *(_OWORD *)(a1 + 32);
  *(_OWORD *)a2 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)(a2 + 16) = v2;
  __n128 result = *(__n128 *)(a1 + 48);
  *(__n128 *)(a2 + 32) = result;
  return result;
}

void RB::ContextDelegate::borrow_context(uint64_t *a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&RB::ContextDelegate::_contexts_lock);
  uint64_t v2 = RB::ContextDelegate::_contexts;
  if (!RB::ContextDelegate::_contexts || (uint64_t v3 = *(void *)(RB::ContextDelegate::_contexts + 136)) == 0)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&RB::ContextDelegate::_contexts_lock);
    operator new();
  }
  if (*(void *)(RB::ContextDelegate::_contexts + 128)) {
    uint64_t v2 = *(void *)(RB::ContextDelegate::_contexts + 128);
  }
  uint64_t v4 = v2 + 16 * v3;
  uint64_t v5 = *a1;
  *a1 = *(void *)(v4 - 16);
  *(void *)(v4 - 16) = v5;
  uint64_t v6 = a1[1];
  a1[1] = *(void *)(v4 - 8);
  *(void *)(v4 - 8) = v6;
  uint64_t v7 = RB::ContextDelegate::_contexts;
  uint64_t v8 = *(void *)(RB::ContextDelegate::_contexts + 128);
  uint64_t v9 = *(void *)(RB::ContextDelegate::_contexts + 136) - 1;
  *(void *)(RB::ContextDelegate::_contexts + 136) = v9;
  if (v8) {
    uint64_t v7 = v8;
  }
  long long v10 = *(const void **)(v7 + 16 * v9);
  if (v10) {
    CFRelease(v10);
  }
  CGContextResetState();
  os_unfair_lock_unlock((os_unfair_lock_t)&RB::ContextDelegate::_contexts_lock);
}

void sub_214112F84(_Unwind_Exception *a1)
{
}

void std::unique_lock<RB::spin_lock>::unlock(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8))
  {
    os_unfair_lock_unlock(*(os_unfair_lock_t *)a1);
    *(unsigned char *)(a1 + 8) = 0;
  }
  else
  {
    std::__throw_system_error(1, "unique_lock::unlock: not locked");
    RB::Device::shared_surfaces(v2);
  }
}

uint64_t RB::Device::shared_surfaces(RB::Device *this)
{
  return *((void *)this + 122);
}

void sub_21411309C(_Unwind_Exception *a1)
{
}

void sub_214113278(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  MEMORY[0x21669AC10](v12, 0x10A0C4070508A9ALL);
  uint64_t v14 = a11;
  a11 = 0;
  if (v14) {
    std::default_delete<RB::XML::Document>::operator()[abi:nn180100]((uint64_t)&a11, v14);
  }
  uint64_t v15 = a12;
  if (a12)
  {
    if (atomic_fetch_add_explicit((atomic_uint *volatile)(a12 + 8), 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
    }
  }
  _Unwind_Resume(a1);
}

void sub_214113568(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  MEMORY[0x21669AC10](v4, 0x10A0C4070508A9ALL);
  uint64_t v6 = v7;
  uint64_t v7 = 0;
  if (v6) {
    std::default_delete<RB::XML::Document>::operator()[abi:nn180100]((uint64_t)va, v6);
  }
  RB::DisplayList::Builder::~Builder((RB::DisplayList::Builder *)va1);
  _Unwind_Resume(a1);
}

void sub_21411371C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  MEMORY[0x21669AC10](v12, 0x10A0C4070508A9ALL);
  uint64_t v14 = a12;
  a12 = 0;
  if (v14) {
    std::default_delete<RB::XML::Document>::operator()[abi:nn180100]((uint64_t)&a12, v14);
  }
  _Unwind_Resume(a1);
}

double RB::DisplayList::Builder::move_contents@<D0>(RB::DisplayList::Builder *this@<X0>, const char *a2@<X1>, void *a3@<X8>)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v5 = *((void *)this + 1);
  if (v5
    && **((void **)this + 4) != v5 + 320
    && *((RB::DisplayList::Builder **)this + 33) == (RB::DisplayList::Builder *)((char *)this + 48))
  {
    RB::precondition_failure((RB *)"moving contents with an active layer or saved state", a2);
  }
  *((_DWORD *)this + 1) = 0;
  *((void *)this + 4) = 0;
  uint64_t v6 = (void *)*((void *)this + 3);
  if (v6)
  {
    do
      uint64_t v6 = (void *)*v6;
    while (v6);
    *((void *)this + 3) = 0;
  }
  *((_OWORD *)this + 4) = xmmword_2142181C0;
  *((_OWORD *)this + 5) = xmmword_2142181D0;
  *((void *)this + 12) = 0;
  *((void *)this + 13) = 0;
  long long v9 = 0uLL;
  int v10 = 0;
  uuid_clear((unsigned __int8 *)&v9 + 4);
  *((_OWORD *)this + 7) = v9;
  *((_DWORD *)this + 32) = v10;
  uint64_t v7 = (atomic_uint *)*((void *)this + 17);
  *((void *)this + 17) = 0;
  if (v7 && atomic_fetch_add_explicit(v7 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v7 + 8))(v7);
  }
  double result = 0.0;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_DWORD *)this + 48) = *((_DWORD *)this + 1) + 1;
  *a3 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  return result;
}

void RB::DisplayList::render(RB::DisplayList *this, const RB::DisplayList::Contents *a2, RB::CGContext *a3, void *a4)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  if (*((unsigned char *)this + 400))
  {
    RB::DisplayList::Builder::Builder((RB::DisplayList::Builder *)v23);
    RB::DisplayList::Builder::set_optimized((uint64_t)v23, 1);
    RB::DisplayList::Builder::draw((RB::DisplayList::Layer ***)v23, this, v24, 1.0, 0, a3);
    if (*(unsigned char *)(v23[0].__r_.__value_.__l.__size_ + 400)) {
      RB::precondition_failure((RB *)"internal error", v7);
    }
    RB::DisplayList::render((RB::DisplayList *)v23[0].__r_.__value_.__l.__size_, a2, 0, v8);
    RB::DisplayList::Builder::~Builder((RB::DisplayList::Builder *)v23);
  }
  else
  {
    {
      uint64_t v18 = RB::debug_int((RB *)"RB_PRINT_TREE", v17);
      char v19 = v18 & 1;
      if ((v18 & 0xFF00000000) == 0) {
        char v19 = 0;
      }
      RB::DisplayList::render(RB::DisplayList::Contents const&,RB::CGContext &,void *)::print_tree = v19;
    }
    if (RB::DisplayList::render(RB::DisplayList::Contents const&,RB::CGContext &,void *)::print_tree)
    {
      memset(v23, 0, 41);
      RB::SexpString::push(v23, "render-cg");
      ClipBoundingBoCGFloat x = CGContextGetClipBoundingBox((CGContextRef)*(void *)a2);
      CGFloat y = ClipBoundingBox.origin.y;
      CGFloat height = ClipBoundingBox.size.height;
      v20[0] = vcvt_f32_f64((float64x2_t)ClipBoundingBox.origin);
      v20[1] = vcvt_f32_f64((float64x2_t)ClipBoundingBox.size);
      RB::Rect::operator std::string(v20, __p);
      if (v22 >= 0) {
        uint64_t v11 = __p;
      }
      else {
        uint64_t v11 = (void **)__p[0];
      }
      RB::SexpString::print(v23, 0, (const char *)v11);
      if (v22 < 0) {
        operator delete(__p[0]);
      }
      RB::DisplayList::Contents::print(this, v23);
      RB::SexpString::pop(v23);
      RB::SexpString::newline(v23);
      if ((v23[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v12 = v23;
      }
      else {
        uint64_t v12 = (std::string *)v23[0].__r_.__value_.__r.__words[0];
      }
      fputs((const char *)v12, (FILE *)*MEMORY[0x263EF8348]);
      if (SHIBYTE(v23[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v23[0].__r_.__value_.__l.__data_);
      }
    }
    if (*((void *)this + 42)
      || *((unsigned char *)this + 384)
      || (int v13 = *((_DWORD *)this + 95), (v13 & 1) != 0)
      || !RB::CGContext::compatible_layer_flags(a2, v13))
    {
      RB::CGContext::reset_ctm((uint64_t)a2);
      CGRect v27 = CGContextGetClipBoundingBox((CGContextRef)*(void *)a2);
      CGFloat v14 = v27.origin.y;
      CGFloat v15 = v27.size.height;
      v23[0].__r_.__value_.__l.__data_ = (std::string::pointer)vcvt_f32_f64((float64x2_t)v27.origin);
      v23[0].__r_.__value_.__r.__words[1] = (std::string::size_type)vcvt_f32_f64((float64x2_t)v27.size);
      RB::DisplayList::Layer::make_cgimage((RB::DisplayList *)((char *)this + 320), a2, (float32x2_t *)v23, (char *)a3, (CGImage **)__p);
      uint64_t v16 = __p[0];
      if (__p[0])
      {
        v28.origin.CGFloat x = *(float *)&v23[0].__r_.__value_.__l.__data_;
        v28.origin.CGFloat y = *((float *)v23[0].__r_.__value_.__r.__words + 1);
        v28.size.CGFloat width = *(float *)&v23[0].__r_.__value_.__r.__words[1];
        v28.size.CGFloat height = *((float *)&v23[0].__r_.__value_.__r.__words[1] + 1);
        CGContextDrawImage(*(CGContextRef *)a2, v28, (CGImageRef)__p[0]);
        CFRelease(v16);
      }
    }
    else
    {
      RB::DisplayList::Layer::render_items((void **)this + 40, a2, (char *)a3);
    }
  }
}

void sub_214113C24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
}

void RB::DisplayList::Builder::~Builder(RB::DisplayList::Builder *this)
{
  uint64_t v2 = (char *)this + 48;
  uint64_t v3 = (char *)*((void *)this + 33);
  if (v3) {
    BOOL v4 = v3 == v2;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    do
    {
      *((void *)this + 33) = *(void *)v3;
      uint64_t v8 = (atomic_uint *)*((void *)v3 + 11);
      if (v8 && atomic_fetch_add_explicit(v8 + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        (*(void (**)(atomic_uint *))(*(void *)v8 + 8))(v8);
      }
      *(void *)uint64_t v3 = *((void *)this + 2);
      *((void *)this + 2) = v3;
      uint64_t v3 = (char *)*((void *)this + 33);
      if (v3) {
        BOOL v9 = v3 == v2;
      }
      else {
        BOOL v9 = 1;
      }
    }
    while (!v9);
  }
  uint64_t v5 = (atomic_uint *)*((void *)this + 17);
  if (v5 && atomic_fetch_add_explicit(v5 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v5 + 8))(v5);
  }
  while (1)
  {
    uint64_t v6 = (void *)*((void *)this + 2);
    if (!v6) {
      break;
    }
    *((void *)this + 2) = *v6;
    free(v6);
  }
  uint64_t v7 = (atomic_uint *)*((void *)this + 1);
  if (v7)
  {
    if (atomic_fetch_add_explicit(v7 + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(atomic_uint *))(*(void *)v7 + 8))(v7);
    }
  }
}

void RB::DisplayList::Contents::~Contents(RB::DisplayList::Contents *this)
{
  RB::DisplayList::Contents::~Contents(this);
  JUMPOUT(0x21669AC10);
}

{
  uint64_t v2;
  uint64_t v3;

  *(void *)this = &unk_26C4ECD98;
  uint64_t v2 = *((void *)this + 39);
  if (v2)
  {
    do
    {
      uint64_t v3 = *(void *)(v2 + 8);
      (**(void (***)(uint64_t))v2)(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  RB::DisplayList::Layer::~Layer((RB::DisplayList::Contents *)((char *)this + 320));
  RB::Heap::~Heap((RB::DisplayList::Contents *)((char *)this + 16));
}

void RB::DisplayList::Contents::finalize(RB::DisplayList::Contents *this)
{
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2 && *v2)
  {
    global_queue = dispatch_get_global_queue(0, 0);
    dispatch_async_f(global_queue, this, (dispatch_function_t)RB::DisplayList::Contents::finalize(void)::$_0::__invoke);
  }
  else
  {
    BOOL v4 = *(void (**)(void))(*(void *)this + 24);
    v4();
  }
}

int32x2_t *RB::DisplayList::Builder::Builder(int32x2_t *this)
{
  this[4] = 0;
  *(_OWORD *)this->i8 = 0u;
  *(_OWORD *)this[2].i8 = 0u;
  uint64_t v2 = RB::DisplayList::State::State((RB::DisplayList::State *)&this[6], 0);
  __int32 v3 = this->i32[0];
  this[28] = 0;
  this[29] = 0;
  this[30] = (int32x2_t)0x100000001000000;
  this[31] = vdup_n_s32(0x7F7FFFFFu);
  this[32].i32[0] = v3;
  this[33] = (int32x2_t)v2;
  this[34].i8[0] = 0;
  return this;
}

void sub_214114000(_Unwind_Exception *a1)
{
  while (1)
  {
    BOOL v4 = *(void **)(v1 + 16);
    if (!v4) {
      break;
    }
    *(void *)(v1 + 16) = *v4;
    free(v4);
  }
  RB::DisplayList::Builder::Builder(v2);
  _Unwind_Resume(a1);
}

RB::DisplayList::State *RB::DisplayList::State::State(RB::DisplayList::State *this, int a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((_OWORD *)this + 1) = xmmword_2142181C0;
  *((_OWORD *)this + 2) = xmmword_2142181D0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  uuid_clear((unsigned __int8 *)this + 68);
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = RB::AffineTransform::identity(v4);
  *((void *)this + 15) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 17) = 0;
  *((_DWORD *)this + 36) = a2;
  *(void *)((char *)this + 148) = 0x7FC00000FFFFFFFFLL;
  *((_WORD *)this + 78) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 21) = 0x100000000;
  return this;
}

void sub_2141140C0(_Unwind_Exception *exception_object)
{
  if (*v1) {
    RB::DisplayList::State::State(*v1);
  }
  _Unwind_Resume(exception_object);
}

long long *RB::AffineTransform::identity(RB::AffineTransform *this)
{
  {
    RB::AffineTransform::identity(void)::identitCGFloat y = xmmword_2142181C0;
    unk_26ACDE3C0 = xmmword_2142181D0;
    qword_26ACDE3D0 = 0;
    unk_26ACDE3D8 = 0;
  }
  return &RB::AffineTransform::identity(void)::identity;
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Path>::~GenericClip(uint64_t a1)
{
  return a1;
}

uint64_t RB::DisplayList::Builder::set_optimized(uint64_t this, int a2)
{
  *(unsigned char *)(this + 272) = a2;
  uint64_t v2 = *(void *)(this + 8);
  if (v2 && (!a2 || !*(void *)(v2 + 320))) {
    *(unsigned char *)(v2 + 400) = a2 ^ 1;
  }
  return this;
}

uint64_t RB::CGContext::compatible_layer_flags(RB::CGContext *this, __int16 a2)
{
  if ((a2 & 0x10) != 0) {
    return 0;
  }
  if ((a2 & 0x100) == 0) {
    return 1;
  }
  int Type = *((_DWORD *)this + 36);
  if (Type < 0)
  {
    int Type = CGContextGetType();
    *((_DWORD *)this + 36) = Type;
  }
  if (Type == 4)
  {
    if (CGBitmapContextGetAlphaInfo(*(CGContextRef *)this) != kCGImageAlphaOnly) {
      return 1;
    }
  }
  else if (Type != 2 && (Type != 1 || (a2 & 0x1000) == 0))
  {
    return 1;
  }
  return 0;
}

void sub_21411429C(_Unwind_Exception *a1)
{
}

uint64_t RB::DisplayList::Contents::apply_transform(RB::DisplayList::Contents *this, const Transform *a2)
{
  return RB::DisplayList::Layer::apply_transform((uint64_t)this + 320, a2, this);
}

uint64_t RB::DisplayList::Layer::apply_transform(uint64_t this, const Transform *a2, RB::DisplayList::Contents *a3)
{
  uint64_t v5 = this;
  if (*(unsigned char *)(this + 64) == 2)
  {
    this = (*(uint64_t (**)(void, RB::DisplayList::Contents *, const Transform *))(**(void **)(this + 24)
                                                                                             + 80))(*(void *)(this + 24), a3, a2);
    *(void *)(v5 + 24) = this;
  }
  for (uint64_t i = *(void **)v5; i; uint64_t i = (void *)i[1])
    this = (*(uint64_t (**)(void *, const Transform *, RB::DisplayList::Contents *))(*i + 200))(i, a2, a3);
  return this;
}

void RB::DisplayList::Transform::apply_to_color(RB::DisplayList::Transform *this, RB::Fill::Color *a2, uint32x4_t a3)
{
  if (*((void *)this + 4)) {
    __int32 v3 = (RB::DisplayList::Transform *)*((void *)this + 4);
  }
  else {
    __int32 v3 = this;
  }
  uint64_t v4 = *((unsigned int *)this + 10);
  if (v4)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 32 * v4;
    do
    {
      int v8 = *(_DWORD *)((char *)v3 + v6);
      if (v8 == 2)
      {
        int v13 = (char *)v3 + v6;
        if (RB::Fill::Color::matches((float16x4_t *)((char *)v3 + v6 + 8), (float16x4_t *)a2, *(uint16x4_t *)a3.i8))
        {
          uint64_t v14 = *((unsigned __int16 *)v13 + 11);
          uint64_t v15 = *(unsigned int *)(v13 + 18);
          short float v16 = *((short float *)v13 + 12);
          unsigned int v12 = *((unsigned __int16 *)v13 + 13);
          if (*((short float *)v13 + 7) == COERCE_SHORT_FLOAT(-2048)) {
            short float v16 = *((short float *)a2 + 3) * *((short float *)v13 + 12);
          }
          v17.i32[0] = *(_DWORD *)(v13 + 18);
          v17.i16[2] = *((_WORD *)v13 + 11);
          *(short float *)&v17.i16[3] = v16;
          a3 = (uint32x4_t)vmovl_s16(vceq_f16(v17, (float16x4_t)0xF800F800F800F800));
          a3.i32[0] = vmaxvq_u32(a3);
          if (a3.i32[0] < 0)
          {
LABEL_16:
            if (v12 >= 0x100) {
              RB::Fill::Color::convert((uint64_t)a2, v12, *(uint16x4_t *)a3.i8);
            }
            goto LABEL_18;
          }
          *(_DWORD *)a2 = v15;
          *((_WORD *)a2 + 2) = (v15 | (unint64_t)(v14 << 32)) >> 32;
          *((short float *)a2 + 3) = v16;
          goto LABEL_15;
        }
      }
      else if (v8 == 1)
      {
        uint64_t v9 = *(unsigned int *)((char *)v3 + v6 + 8);
        unint64_t v10 = v9 | ((unint64_t)*(unsigned __int16 *)((char *)v3 + v6 + 12) << 32);
        v11.i32[0] = *(_DWORD *)((char *)v3 + v6 + 8);
        unsigned int v12 = *(unsigned __int16 *)((char *)v3 + v6 + 16);
        *(short float *)a3.i16 = *((short float *)a2 + 3) * *(short float *)((char *)v3 + v6 + 14);
        v11.i16[2] = *(_WORD *)((char *)v3 + v6 + 12);
        v11.i16[3] = a3.i16[0];
        if ((vmaxvq_u32((uint32x4_t)vmovl_s16(vceq_f16(v11, (float16x4_t)0xF800F800F800F800))) & 0x80000000) != 0) {
          goto LABEL_16;
        }
        *(_WORD *)a2 = v9;
        *((_WORD *)a2 + 1) = WORD1(v10);
        *((_WORD *)a2 + 2) = WORD2(v10);
        *((_WORD *)a2 + 3) = a3.i16[0];
LABEL_15:
        *((_WORD *)a2 + 4) = v12;
      }
LABEL_18:
      v6 += 32;
    }
    while (v7 != v6);
  }
}

uint64_t RB::DisplayList::Predicate::matches_color(RB::DisplayList::Predicate *this, const RB::Fill::Color *a2, uint16x4_t a3)
{
  if (*((void *)this + 3)) {
    __int32 v3 = (RB::DisplayList::Predicate *)*((void *)this + 3);
  }
  else {
    __int32 v3 = this;
  }
  uint64_t v4 = *((unsigned int *)this + 8);
  if (!v4) {
    return 1;
  }
  uint64_t v6 = (RB::DisplayList::Predicate **)((char *)v3 + 8);
  uint64_t v7 = 24 * v4;
  while (1)
  {
    int v8 = *((_DWORD *)v6 - 2);
    if (v8 != 3) {
      break;
    }
    uint64_t v9 = *v6;
    if (RB::DisplayList::Predicate::matches_color(*v6, a2) == (*((unsigned char *)v9 + 40) != 0)) {
      return 0;
    }
LABEL_11:
    v6 += 3;
    v7 -= 24;
    if (!v7) {
      return 1;
    }
  }
  if (v8 != 2 || (RB::Fill::Color::matches((float16x4_t *)v6, (float16x4_t *)a2, a3) & 1) != 0) {
    goto LABEL_11;
  }
  return 0;
}

uint64_t RB::Fill::Color::matches(float16x4_t *this, float16x4_t *a2, uint16x4_t a3)
{
  float16x4_t v3 = *this;
  if ((vminvq_u32((uint32x4_t)vmovl_s16(vceq_f16(*this, (float16x4_t)0xF800F800F800F800))) & 0x80000000) != 0) {
    return 1;
  }
  int8x16_t v5 = (int8x16_t)vcvtq_f32_f16(v3);
  if (a2[1].i8[1])
  {
    unsigned int v6 = this[1].u16[0];
    if (v6 >= 0x100)
    {
      int v7 = a2[1].u8[0];
      if (v7 != v6)
      {
        a3.i16[2] = this->i16[2];
        __int32 v17 = v5.i32[3];
        float16x4_t v18 = *this;
        a3.i32[0] = this->i32[0];
        _D0 = RB::Fill::Color::convert_color((RB::Shader::Tables *)this[1].i16[0], v7, a3);
        __asm { FCVT            S1, H0 }
        int8x16_t v14 = vextq_s8(vextq_s8(_Q1, _Q1, 4uLL), (int8x16_t)vcvtq_f32_f16((float16x4_t)vext_s8(*(int8x8_t *)&_D0, *(int8x8_t *)&_D0, 2uLL)), 0xCuLL);
        float16x4_t v3 = v18;
        v14.i32[3] = v17;
        int8x16_t v5 = v14;
      }
    }
  }
  float32x4_t v15 = vcvtq_f32_f16(*a2);
  return vminvq_u32((uint32x4_t)vcgtq_f32((float32x4_t)vdupq_n_s32(0x3B008081u), vabdq_f32((float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vceq_f16(v3, (float16x4_t)0xF800F800F800F800)), (int8x16_t)v15, v5), v15))) >> 31;
}

double RB::Fill::Color::convert_color(RB::Shader::Tables *a1, int a2, uint16x4_t a3)
{
  float16x4_t v3 = (float16x4_t)a3;
  if (a1 == a2) {
    return *(double *)&v3;
  }
  char v4 = a2;
  char v5 = (char)a1;
  if (a1)
  {
    uint16x4_t v6 = vshr_n_u16(a3, 3uLL);
    __int16 v21 = v6.i16[0];
    uint64_t v23 = *(void *)&v6 & 0xFFF0FFF0FFF0FFFLL;
    a1 = (RB::Shader::Tables *)RB::Shader::Tables::shared(a1);
    v7.i64[0] = WORD1(v23);
    v7.i64[1] = WORD2(v23);
    v8.i64[0] = 0xFFFFLL;
    v8.i64[1] = 0xFFFFLL;
    int8x16_t v9 = vandq_s8(v7, v8);
    unint64_t v10 = (__int16 *)((char *)a1 + 2 * v9.i64[0] + 0x2000);
    v9.i16[0] = *((_WORD *)a1 + (v21 & 0xFFF) + 4096);
    v9.i16[1] = *v10;
    v9.i16[2] = *((_WORD *)a1 + v9.i64[1] + 4096);
    float16x4_t v3 = (float16x4_t)vorr_s8(*(int8x8_t *)v9.i8, vand_s8((int8x8_t)v3, (int8x8_t)0x8000800080008000));
  }
  if ((v5 & 0xFE) == 0 && (v4 & 0xFE) == 2)
  {
    float32x4_t v11 = vcvtq_f32_f16(v3);
    float32x4_t v12 = vmlaq_n_f32(vmulq_lane_f32((float32x4_t)xmmword_21421CBE0, *(float32x2_t *)v11.f32, 1), (float32x4_t)xmmword_21421CBD0, v11.f32[0]);
    float32x4_t v13 = (float32x4_t)xmmword_21421CBF0;
LABEL_10:
    float16x4_t v3 = vcvt_f16_f32(vmlaq_laneq_f32(v12, v13, v11, 2));
    goto LABEL_11;
  }
  if ((v5 & 0xFE) == 2 && (v4 & 0xFE) == 0)
  {
    float32x4_t v11 = vcvtq_f32_f16(v3);
    float32x4_t v12 = vmlaq_n_f32(vmulq_lane_f32((float32x4_t)xmmword_21421CBB0, *(float32x2_t *)v11.f32, 1), (float32x4_t)xmmword_21421CBA0, v11.f32[0]);
    float32x4_t v13 = (float32x4_t)xmmword_21421CBC0;
    goto LABEL_10;
  }
LABEL_11:
  if (v4)
  {
    uint16x4_t v14 = vshr_n_u16((uint16x4_t)v3, 3uLL);
    __int16 v22 = v14.i16[0];
    uint64_t v24 = *(void *)&v14 & 0xFFF0FFF0FFF0FFFLL;
    uint64_t v15 = RB::Shader::Tables::shared(a1);
    v16.i64[0] = WORD1(v24);
    v16.i64[1] = WORD2(v24);
    v17.i64[0] = 0xFFFFLL;
    v17.i64[1] = 0xFFFFLL;
    int8x16_t v18 = vandq_s8(v16, v17);
    char v19 = (__int16 *)(v15 + 2 * v18.i64[0]);
    v18.i16[0] = *(_WORD *)(v15 + 2 * (v22 & 0xFFF));
    v18.i16[1] = *v19;
    v18.i16[2] = *(_WORD *)(v15 + 2 * v18.i64[1]);
    float16x4_t v3 = (float16x4_t)vorr_s8(*(int8x8_t *)v18.i8, vand_s8((int8x8_t)v3, (int8x8_t)0x8000800080008000));
  }
  return *(double *)&v3;
}

uint64_t RB::Shader::Tables::shared(RB::Shader::Tables *this)
{
  {
    RB::Shader::Tables::shared(void)::tables = (uint64_t)RB::Shader::Tables::shared(void)::$_0::operator()();
  }
  return RB::Shader::Tables::shared(void)::tables;
}

void sub_214114874(_Unwind_Exception *a1)
{
}

void RB::Fill::Color::apply_transform(RB::Fill::Color *this, const RB::DisplayList::Transform *a2, RB::Heap *a3, uint32x4_t a4)
{
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::apply_transform(uint64_t a1, const RB::DisplayList::Transform *a2, uint64_t a3)
{
  char v5 = (RB::Heap *)(a3 + 16);
  RB::Coverage::Glyphs::apply_transform((RB::Coverage::Glyphs *)(a1 + 56), a2, (RB::Heap *)(a3 + 16));
  RB::Fill::Color::apply_transform((RB::Fill::Color *)(a1 + 112), a2, v5, v6);
}

void RB::Coverage::Glyphs::apply_transform(RB::Coverage::Glyphs *this, const RB::DisplayList::Transform *a2, RB::Heap *a3)
{
  CFTypeRef v6 = *(CFTypeRef *)this;
  if (*(void *)this) {
    CFRetain(*(CFTypeRef *)this);
  }
  CFTypeRef cf = v6;
  RB::DisplayList::Transform::apply_to_font((uint64_t)a2, (CGFont **)&cf, (const CGGlyph *)(*((void *)this + 1) + 8 * *((unsigned int *)this + 4)), *((float **)this + 1), *((unsigned int *)this + 4));
  CFTypeRef v7 = cf;
  if (cf != *(CFTypeRef *)this)
  {
    *(void *)this = cf;
    CFTypeRef cf = 0;
    int8x16_t v8 = (RB::ObjectTable *)*((void *)a3 + 4);
    if (!v8)
    {
      RB::Heap::make_object_table((size_t *)a3);
      int8x16_t v8 = (RB::ObjectTable *)*((void *)a3 + 4);
    }
    RB::ObjectTable::adopt(v8, v7);
    CFTypeRef v7 = cf;
  }
  if (v7) {
    CFRelease(v7);
  }
}

void sub_2141149A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void RB::DisplayList::Transform::apply_to_font(uint64_t a1, CGFont **a2, const CGGlyph *a3, float *a4, size_t a5)
{
  float32x2_t v38 = a3;
  v40[1] = *MEMORY[0x263EF8340];
  if (*(void *)(a1 + 32)) {
    uint64_t v5 = *(void *)(a1 + 32);
  }
  else {
    uint64_t v5 = a1;
  }
  uint64_t v6 = *(unsigned int *)(a1 + 40);
  if (v6)
  {
    uint64_t v39 = a5 & 0x6000000000000000;
    size_t v9 = 8 * a5;
    uint64_t v10 = v5 + 32 * v6;
    int8x8_t v37 = a4;
    while (1)
    {
      if (*(_DWORD *)v5 != 3) {
        goto LABEL_33;
      }
      float32x4_t v11 = (os_unfair_lock_s *)RB::FontMixer::shared((RB::FontMixer *)a1);
      RB::FontMixer::mix(v11, *a2, *(CGFont **)(v5 + 8), *(_DWORD *)(v5 + 16), v40);
      float32x4_t v13 = (CGFont *)v40[0];
      if (!v40[0]) {
        goto LABEL_33;
      }
      if (a5)
      {
        uint16x4_t v14 = *a2;
        if ((CGFont *)v40[0] != *a2)
        {
          int v15 = *(_DWORD *)(v5 + 20);
          if ((v15 & 7) != 0 && !v39) {
            break;
          }
        }
      }
LABEL_31:
      uint32x2_t v35 = (CGFont *)v40[0];
      v40[0] = *a2;
      a1 = v40[0];
      *a2 = v35;
      if (a1) {
        CFRelease((CFTypeRef)a1);
      }
LABEL_33:
      v5 += 32;
      if (v5 == v10) {
        return;
      }
    }
    if (v9 > 0x1000)
    {
      int8x16_t v16 = (char *)malloc_type_malloc(v9, 0x10D38B7uLL);
      if (!v16)
      {
LABEL_30:
        free(v16);
        goto LABEL_31;
      }
      float32x4_t v13 = (CGFont *)v40[0];
      uint16x4_t v14 = *a2;
    }
    else
    {
      MEMORY[0x270FA5388](a1, v12);
      int8x16_t v16 = (char *)&v36 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v16, v9);
    }
    if (CGFontGetGlyphAdvances(v14, v38, a5, (int *)v16))
    {
      int8x16_t v17 = (int *)&v16[4 * a5];
      if (CGFontGetGlyphAdvances(v13, v38, a5, v17))
      {
        int UnitsPerEm = CGFontGetUnitsPerEm(*a2);
        int v19 = CGFontGetUnitsPerEm(v13);
        uint64_t v20 = 0;
        float32x2_t v21 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT((float)UnitsPerEm));
        float32x2_t v22 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)UnitsPerEm), v21), v21);
        LODWORD(v23) = vmul_f32(v22, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)UnitsPerEm), v22)).u32[0];
        float32x2_t v24 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v19));
        float32x2_t v25 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v19), v24), v24);
        LODWORD(v26) = vmul_f32(v25, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v19), v25)).u32[0];
        float v27 = 0.0;
        if ((v15 & 2) != 0) {
          float v28 = 1.0;
        }
        else {
          float v28 = 0.0;
        }
        if (v15) {
          float v28 = 0.5;
        }
        do
        {
          float v27 = (float)(v27 + (float)(v23 * (float)*(int *)&v16[4 * v20])) - (float)(v26 * (float)v17[v20]);
          ++v20;
        }
        while (a5 > v20);
        uint64_t v29 = 0;
        float v30 = v27 * v28;
        float v31 = 0.0;
        int32x2_t v32 = v37;
        do
        {
          float v33 = -(float)((float)(v26 * (float)v17[v29]) - (float)(v23 * (float)*(int *)&v16[4 * v29]));
          uint64_t v34 = *(void *)v32;
          if ((v15 & 4) != 0)
          {
            *int32x2_t v32 = (float)(v30 - v31) + *(float *)&v34;
            float v31 = v33 + v31;
          }
          else
          {
            *int32x2_t v32 = *(float *)&v34 + (float)(v33 * v28);
          }
          ++v29;
          v32 += 2;
        }
        while (a5 > v29);
      }
    }
    if (v9 <= 0x1000) {
      goto LABEL_31;
    }
    goto LABEL_30;
  }
}

void sub_214114C74(_Unwind_Exception *exception_object)
{
  if (v1 > 0x1000) {
    free(v2);
  }
  uint64_t v5 = *(const void **)(v3 - 112);
  if (v5) {
    CFRelease(v5);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::ColorMode::pixel_format(unsigned __int8 *a1, uint64_t a2, char a3, unsigned char *a4, BOOL *a5, _DWORD *a6)
{
  if ((a3 & 0x20) != 0) {
    int v6 = 0;
  }
  else {
    int v6 = *a1;
  }
  int v7 = *((_DWORD *)a1 + 1);
  int v8 = v7 & 1;
  if (a4) {
    *a4 = v8 == 0;
  }
  if (a5) {
    *a5 = v8 == 0;
  }
  if (a6)
  {
    *a6 = 0;
    int v7 = *((_DWORD *)a1 + 1);
    if ((v7 & 0x10) != 0)
    {
      *a6 = 4;
      return 10;
    }
  }
  else if ((v7 & 0x10) != 0)
  {
    return 10;
  }
  if ((v6 - 1) < 3)
  {
    if (a2 && (a3 & 8) == 0 && *(unsigned __int8 *)(a2 + 283) >= 3u) {
      return RB::ColorMode::pixel_format(RB::Device const*,unsigned int,RB::ColorSpace *,RB::ColorSpace *,unsigned int *)const::formats[v8 | (2 * (a3 & 1u))];
    }
    if (a4 && v6 == 2)
    {
      BOOL v10 = v8 == 0;
      if (v8) {
        char v11 = 2;
      }
      else {
        char v11 = 3;
      }
      *a4 = v11;
      uint64_t v12 = 2147483655;
      uint64_t v13 = 2147483656;
      goto LABEL_40;
    }
    if ((a3 & 8) == 0 && v6 == 1 && (a3 & 1) == 0 && !v8) {
      return 94;
    }
    goto LABEL_38;
  }
  if (v6)
  {
LABEL_38:
    if ((v7 & 0x20) == 0)
    {
      uint64_t v12 = 2147483651;
      BOOL v10 = (a3 & 0x1B) == 8;
      uint64_t v13 = 115;
      goto LABEL_40;
    }
    if (a4) {
      *a4 = 5;
    }
    if (v8) {
      return 2147483660;
    }
    else {
      return 2147483659;
    }
  }
  if ((a3 & 0x1A) == 8)
  {
    if ((a3 & 1) == 0)
    {
      BOOL v14 = v8 == 0;
      if (v8) {
        uint64_t v15 = 2147483650;
      }
      else {
        uint64_t v15 = 2147483649;
      }
      uint64_t v16 = 2147483653;
      if (v14) {
        uint64_t v16 = 43;
      }
      if ((v7 & 2) != 0) {
        return v16;
      }
      else {
        return v15;
      }
    }
LABEL_66:
    if (v8) {
      return 81;
    }
    else {
      return 80;
    }
  }
  if ((a3 & 0x1A) != 2 || !a2 || (a3 & 1) != 0 || *(unsigned __int8 *)(a2 + 283) < 3u) {
    goto LABEL_66;
  }
  if ((a3 & 4) == 0 && (v7 & 8) != 0)
  {
    BOOL v10 = v8 == 0;
    uint64_t v13 = 520;
    uint64_t v12 = 500;
    goto LABEL_40;
  }
  if ((a3 & 4) == 0 && (v7 & 4) != 0)
  {
    BOOL v10 = v8 == 0;
    uint64_t v13 = 522;
    uint64_t v12 = 502;
LABEL_40:
    if (v10) {
      return v12;
    }
    else {
      return v13;
    }
  }
  if ((v7 & 2) != 0)
  {
    if (v8) {
      return 2147483652;
    }
    else {
      return 40;
    }
  }
  uint64_t result = v8 ? 523 : 542;
  if ((a3 & 4) != 0) {
    goto LABEL_66;
  }
  return result;
}

uint64_t RB::ColorMode::ColorMode(uint64_t a1, int a2)
{
  *(unsigned char *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  int v3 = 0;
  switch(a2)
  {
    case -1:
      abort();
    case 1:
    case 6:
    case 7:
    case 8:
      int v3 = 1;
      *(_DWORD *)(a1 + 4) = 1;
      goto LABEL_6;
    case 2:
    case 13:
      int v3 = 1;
      *(_DWORD *)(a1 + 4) = 1;
      goto LABEL_5;
    case 3:
LABEL_7:
      int v4 = v3 | 2;
      goto LABEL_15;
    case 4:
LABEL_9:
      int v4 = v3 | 4;
      goto LABEL_15;
    case 5:
LABEL_8:
      int v4 = v3 | 0xC;
      goto LABEL_15;
    case 9:
      int v4 = 16;
      goto LABEL_15;
    case 10:
      int v4 = 17;
LABEL_15:
      *(_DWORD *)(a1 + 4) = v4;
      break;
    case 11:
    case 12:
      int v3 = 0;
LABEL_5:
      *(unsigned char *)a1 = 4;
LABEL_6:
      switch(a2)
      {
        case 3:
        case 6:
          goto LABEL_7;
        case 4:
        case 7:
          goto LABEL_9;
        case 5:
        case 8:
          goto LABEL_8;
        case 12:
        case 13:
          int v4 = v3 | 0x20;
          goto LABEL_15;
        default:
          goto LABEL_16;
      }
      break;
    case 14:
      goto LABEL_12;
    case 15:
      *(_DWORD *)(a1 + 4) = 1;
LABEL_12:
      *(unsigned char *)a1 = 2;
      break;
    default:
      break;
  }
LABEL_16:
  {
    if (v8)
    {
      RB::ColorMode::ColorMode(RBColorMode)::overrides = RB::ColorMode::ColorMode(RBColorMode)::$_0::operator()(v8, v9);
      dword_26ACDE168 = v10;
    }
  }
  char v5 = dword_26ACDE168;
  int v6 = BYTE1(dword_26ACDE168);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 4) & ~RB::ColorMode::ColorMode(RBColorMode)::overrides | HIDWORD(RB::ColorMode::ColorMode(RBColorMode)::overrides);
  if (v6) {
    *(unsigned char *)a1 = v5;
  }
  return a1;
}

void sub_214115008(_Unwind_Exception *a1)
{
}

BOOL RB::SharedSurfaceGroup::preflight_subsurface(RB::SharedSurfaceGroup *a1, int32x2_t a2)
{
  int v2 = vmul_lane_s32(a2, a2, 1).u32[0];
  int v3 = (RB::SharedSurfaceGroup *)RB::SharedSurfaceGroup::max_subsurface_area(a1);
  if (v2 > (int)v3) {
    return 0;
  }
  uint32x2_t v5 = (uint32x2_t)vcgt_s32(a2, vdup_n_s32(RB::SharedSurfaceGroup::max_subsurface_size(v3)));
  return vpmax_u32(v5, v5).i32[0] >= 0;
}

uint64_t RB::SharedSurfaceGroup::max_subsurface_area(RB::SharedSurfaceGroup *this)
{
  {
    uint64_t v3 = RB::prefs_int(@"RBMaxSubsurfaceArea", v2);
    if ((v3 & 0xFF00000000) != 0) {
      int v4 = v3;
    }
    else {
      int v4 = 0x10000;
    }
    RB::SharedSurfaceGroup::max_subsurface_area(void)::value = v4;
  }
  return RB::SharedSurfaceGroup::max_subsurface_area(void)::value;
}

void sub_2141150F8(_Unwind_Exception *a1)
{
}

RBDevice *current_device_locked(RBLayer *a1)
{
  uint64_t result = (RBDevice *)*((void *)a1 + 5);
  if (!result)
  {
    uint64_t v3 = (void *)[(RBLayer *)a1 delegate];
    if ((objc_opt_respondsToSelector() & 1) == 0
      || (uint64_t result = (RBDevice *)[v3 RBLayerDefaultDevice:a1]) == 0)
    {
      return +[RBDevice sharedDefaultDevice];
    }
  }
  return result;
}

void sub_214115384(_Unwind_Exception *a1)
{
}

RB::XML::Document *RBDrawingStateConcatCTM(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  long long v5 = *(_OWORD *)(a2 + 16);
  long long v6 = *(_OWORD *)(a2 + 32);
  float64x2_t v11 = *(float64x2_t *)a2;
  long long v12 = v5;
  long long v13 = v6;
  RB::DisplayList::State::concat((float64x2_t *)a1, &v11);
  uint64_t result = *(RB::XML::Document **)(v4 + 304);
  if (result)
  {
    long long v9 = *(_OWORD *)(a2 + 16);
    long long v10 = *(_OWORD *)(a2 + 32);
    float64x2_t v11 = *(float64x2_t *)a2;
    long long v12 = v9;
    long long v13 = v10;
    return RB::XML::DisplayList::concat_ctm(result, (RB::XML::Document *)a1, &v11, v7);
  }
  return result;
}

void RB::DisplayList::State::concat(float64x2_t *this, float64x2_t *a2)
{
  int64x2_t v2 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(a2[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*a2, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(a2[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v2, 1), (int8x16_t)v2).u64[0] & 0x8000000000000000) == 0)
  {
    v4.f64[0] = RB::operator*(a2, this + 1);
    this[1] = v4;
    this[2] = v5;
    this[3] = v6;
    this[7].f64[0] = 0.0;
    HIDWORD(this[9].f64[0]) = -1;
  }
}

void RBXMLRecorderMarkFrame(const void *a1, void *a2, int a3, double a4, double a5)
{
  v31[19] = *MEMORY[0x263EF8340];
  {
    if (os_variant_has_internal_diagnostics())
    {
      uint64_t v22 = RB::debug_int((RB *)"RB_SAVE_ARCHIVES", v21);
      if ((v22 & 0xFF00000000) != 0) {
        int v23 = v22;
      }
      else {
        int v23 = 0;
      }
    }
    else
    {
      int v23 = 0;
    }
    RBXMLRecorderMarkFrame(objc_object *,objc_object  {objcproto22_RBDisplayListContents}*,CGSize,RB::ColorSpace)::save_archives = v23;
  }
  if (RBXMLRecorderMarkFrame(objc_object *,objc_object  {objcproto22_RBDisplayListContents}*,CGSize,RB::ColorSpace)::save_archives >= 1)
  {
    snprintf_l(v28, 0x100uLL, 0, "RBDisplayList-%d.rbar", ++RBXMLRecorderMarkFrame(objc_object *,objc_object  {objcproto22_RBDisplayListContents}*,CGSize,RB::ColorSpace)::counter);
    RBArchiveToFile(a2, v28, RBXMLRecorderMarkFrame(objc_object *,objc_object  {objcproto22_RBDisplayListContents}*,CGSize,RB::ColorSpace)::save_archives == 1);
  }
  if (RB::XMLRecorder::enabled)
  {
    uint64_t v10 = objc_msgSend(a2, "_rb_xml_document");
    if (v10)
    {
      std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v28);
      RB::XML::Document::print(v10, v28, (~a3 << 31), a4, a5);
      float64x2_t v11 = (objc_class *)objc_opt_class();
      long long v12 = (__CFString *)NSStringFromClass(v11);
      if ([(__CFString *)v12 isEqualToString:@"__NSCFType"])
      {
        CFTypeID v13 = CFGetTypeID(a1);
        long long v12 = (id)CFCopyTypeIDDescription(v13);
      }
      double v14 = CACurrentMediaTime();
      if (RB::XMLRecorder::log_file)
      {
        uint64_t v15 = fopen((const char *)[(id)RB::XMLRecorder::log_file UTF8String], "a");
        if (v15)
        {
          uint64_t v16 = (const char *)[(__CFString *)v12 UTF8String];
          std::stringbuf::str[abi:nn180100]<std::allocator<char>>((uint64_t)v29, __p);
          if (v27 >= 0) {
            int8x16_t v17 = __p;
          }
          else {
            int8x16_t v17 = (void **)__p[0];
          }
          fprintf(v15, "** %s %p: frame at time %f **\n\n%s\n", v16, a1, v14, (const char *)v17);
          if (v27 < 0) {
            operator delete(__p[0]);
          }
          fclose(v15);
        }
      }
      else
      {
        snprintf((char *)__p, 0x100uLL, "\n** %s %p frame at time %f: **\n\n", (const char *)[(__CFString *)v12 UTF8String], a1, v14);
        size_t v18 = strlen((const char *)__p);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x263F8C100], (uint64_t)__p, v18);
        std::stringbuf::str[abi:nn180100]<std::allocator<char>>((uint64_t)v29, v24);
        if ((v25 & 0x80u) == 0) {
          int v19 = v24;
        }
        else {
          int v19 = (void **)v24[0];
        }
        if ((v25 & 0x80u) == 0) {
          uint64_t v20 = v25;
        }
        else {
          uint64_t v20 = (uint64_t)v24[1];
        }
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x263F8C100], (uint64_t)v19, v20);
        if ((char)v25 < 0) {
          operator delete(v24[0]);
        }
        std::ostream::flush();
      }
      *(void *)float v28 = *MEMORY[0x263F8C2C8];
      *(void *)&v28[*(void *)(*(void *)v28 - 24)] = *(void *)(MEMORY[0x263F8C2C8] + 24);
      v29[0] = MEMORY[0x263F8C318] + 16;
      if (v30 < 0) {
        operator delete((void *)v29[8]);
      }
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      MEMORY[0x21669ABE0](v31);
    }
  }
}

void sub_214115AE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,char a52)
{
}

uint64_t RB::Surface::queue_id(RB::Surface *this, _CAImageQueue *a2)
{
  if (!a2) {
    return 0;
  }
  float64x2_t v4 = (char *)this + 64;
  float64x2_t v5 = (char *)*((void *)this + 12);
  uint64_t v6 = *((void *)this + 13);
  if (!v5) {
    float64x2_t v5 = (char *)this + 64;
  }
  if (v6)
  {
    int v7 = v5 + 8;
    uint64_t v8 = 16 * v6;
    while (*((_CAImageQueue **)v7 - 1) != a2)
    {
      v7 += 16;
      v8 -= 16;
      if (!v8) {
        goto LABEL_8;
      }
    }
    return *(void *)v7;
  }
  else
  {
LABEL_8:
    uint64_t v9 = CAImageQueueRegisterIOSurfaceBuffer();
    uint64_t v10 = *((void *)this + 13);
    size_t v11 = v10 + 1;
    if (*((void *)this + 14) < (unint64_t)(v10 + 1))
    {
      uint64_t v10 = *((void *)this + 13);
      size_t v11 = v10 + 1;
    }
    long long v12 = (char *)*((void *)this + 12);
    if (!v12) {
      long long v12 = v4;
    }
    CFTypeID v13 = &v12[16 * v10];
    *(void *)CFTypeID v13 = a2;
    *((void *)v13 + 1) = v9;
    *((void *)this + 13) = v11;
  }
  return v9;
}

uint64_t RB::SharedSurfaceGroup::max_subsurface_size(RB::SharedSurfaceGroup *this)
{
  {
    uint64_t v3 = RB::prefs_int(@"RBMaxSubsurfaceSize", v2);
    if ((v3 & 0xFF00000000) != 0) {
      int v4 = v3;
    }
    else {
      int v4 = 512;
    }
    RB::SharedSurfaceGroup::max_subsurface_size(void)::value = v4;
  }
  if (RB::SharedSurfaceGroup::max_subsurface_size(void)::value >= 2048) {
    return 2048;
  }
  else {
    return RB::SharedSurfaceGroup::max_subsurface_size(void)::value;
  }
}

void sub_214115C8C(_Unwind_Exception *a1)
{
}

uint64_t RB::RenderParams::RenderParams(uint64_t result, uint64_t a2, uint64_t a3, char a4, char a5, char a6, char a7, double a8, float a9)
{
  *(void *)uint64_t result = a2;
  *(void *)(result + 8) = a3;
  *(double *)(result + 16) = a8;
  *(float *)(result + 24) = a9;
  *(unsigned char *)(result + 28) = a4;
  *(unsigned char *)(result + 29) = a5;
  *(unsigned char *)(result + 30) = a6;
  char v9 = *(unsigned char *)(result + 31) & 0xFE | a7;
  *(unsigned char *)(result + 31) = v9;
  *(unsigned char *)(result + 31) = v9 & 0xF1 | (2 * (*(unsigned char *)(*(void *)a2 + 283) != 0));
  return result;
}

void RB::SurfacePool::collect_async(os_unfair_lock_s *this)
{
  os_unfair_lock_lock(this);
  if (LOBYTE(this[32]._os_unfair_lock_opaque))
  {
    os_unfair_lock_unlock(this);
  }
  else
  {
    LOBYTE(this[32]._os_unfair_lock_opaque) = 1;
    os_unfair_lock_unlock(this);
    CFStringRef v2 = *(NSObject **)&this[2]._os_unfair_lock_opaque;
    dispatch_async_f(v2, this, (dispatch_function_t)RB::SurfacePool::AsyncCollection::~AsyncCollection()::$_0::__invoke);
  }
}

void RB::DisplayList::render(const RB::DisplayList::Contents *a1, long long *a2, uint64_t a3, int a4, uint64_t a5, int32x2_t a6, int32x2_t a7, __n128 a8)
{
  v23[37] = *(float32x2_t *)MEMORY[0x263EF8340];
  uint32x2_t v9 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, a7);
  if ((vpmax_u32(v9, v9).u32[0] & 0x80000000) == 0)
  {
    v20[0] = (int32x2_t)a1;
    v20[1] = (int32x2_t)a5;
    void v20[2] = a6;
    v20[3] = a7;
    v20[4] = 0;
    int v21 = a4;
    __n128 v22 = a8;
    if (*((unsigned char *)a1 + 400))
    {
      RB::DisplayList::Builder::Builder((RB::DisplayList::Builder *)v23);
      RB::DisplayList::Builder::set_optimized((uint64_t)v23, 1);
      v14.i32[0] = 0;
      uint32x2_t v15 = (uint32x2_t)vceq_s32(a7, (int32x2_t)0x8000000080000000);
      int8x8_t v16 = (int8x8_t)vdup_lane_s32(vcgt_s32(v14, (int32x2_t)vpmin_u32(v15, v15)), 0);
      RB::DisplayList::Builder::set_crop(v23, (float32x2_t)vbsl_s8(v16, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(a6)), (float32x2_t)vbsl_s8(v16, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(a7)));
      RB::DisplayList::Builder::draw((RB::DisplayList::Layer ***)v23, a1, *(RB::DisplayList::State **)&v23[33], 1.0, 0, 0);
      RB::DisplayList::Builder::move_contents((RB::DisplayList::Builder *)v23, v17, &v19);
      size_t v18 = (atomic_uint *)v19;
      v20[0] = v19;
      RB::DisplayList::Builder::~Builder((RB::DisplayList::Builder *)v23);
    }
    else
    {
      size_t v18 = 0;
    }
    RB::DisplayList::render_many(a2, a3, 1uLL, v20);
    if (v18)
    {
      if (atomic_fetch_add_explicit(v18 + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        (*(void (**)(atomic_uint *))(*(void *)v18 + 8))(v18);
      }
    }
  }
}

void sub_214115F00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  RB::DisplayList::Builder::~Builder((RB::DisplayList::Builder *)va);
  _Unwind_Resume(a1);
}

void *ensure_drawable_locked(void *result)
{
  if (!result[6])
  {
    [result maxDrawableCount];
    operator new();
  }
  return result;
}

void sub_21411607C(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x1081C40A869C1B6);
  _Unwind_Resume(a1);
}

uint64_t RBColorModeHasExtendedRange(unsigned int a1)
{
  return (a1 < 0xE) & (0x3804u >> a1);
}

void RB::Drawable::reset_statistics(os_unfair_lock_s *this, uint64_t a2, double a3)
{
  uint64_t v6 = this + 8;
  os_unfair_lock_lock(this + 8);
  BOOL v7 = a3 <= 1.0 && a3 > 0.0;
  double v8 = 0.1;
  *(void *)&this[10]._os_unfair_lock_opaque = a2;
  p_os_unfair_lock_opaque = (double *)&this[10]._os_unfair_lock_opaque;
  if (v7) {
    double v8 = a3;
  }
  p_os_unfair_lock_opaque[1] = v8;
  *((_OWORD *)p_os_unfair_lock_opaque + 1) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 2) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 3) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 4) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 5) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 6) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 7) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 8) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 9) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 10) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 11) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 12) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 13) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 14) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 15) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 16) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 17) = 0u;
  os_unfair_lock_unlock(v6);
}

void RB::Drawable::set_delegate(uint64_t a1, uint64_t a2)
{
  int v4 = (os_unfair_lock_s *)(a1 + 32);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
  *(void *)(a1 + 328) = a2;
  os_unfair_lock_unlock(v4);
}

RB::ContextDelegate *RB::ContextDelegate::ContextDelegate(RB::ContextDelegate *this)
{
  *(void *)this = &unk_26C4ED160;
  *((void *)this + 1) = objc_opt_new();
  *((void *)this + 2) = objc_opt_new();
  *((void *)this + 44) = 0;
  *((void *)this + 45) = 0;
  *((void *)this + 46) = 4;
  *((_OWORD *)this + 24) = xmmword_2142181C0;
  *((_OWORD *)this + 25) = xmmword_2142181D0;
  *((_OWORD *)this + 26) = 0u;
  *((_OWORD *)this + 30) = xmmword_2142181C0;
  *((_OWORD *)this + 31) = xmmword_2142181D0;
  *((_OWORD *)this + 32) = 0u;
  *((void *)this + 67) = 0;
  *((void *)this + 69) = 0;
  *((void *)this + 68) = 0;
  return this;
}

void sub_214116374(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

float16x4_t *RB::Shader::Tables::shared(void)::$_0::operator()()
{
  CFStringRef v0 = (float16x4_t *)mmap(0, 0x6000uLL, 3, 4098, -1, 0);
  if (v0 == (float16x4_t *)-1) {
    RB::precondition_failure((RB *)"memory allocation failed", v1);
  }
  CFStringRef v2 = v0;
  uint64_t v3 = v0 + 1024;
  unint64_t v4 = -4;
  float32x4_t v35 = (float32x4_t)vdupq_n_s32(0x3ED555C5u);
  float32x4_t v36 = (float32x4_t)vdupq_n_s32(0x414EB852u);
  float32x4_t v33 = (float32x4_t)vdupq_n_s32(0xBD6147AE);
  float32x4_t v34 = (float32x4_t)vdupq_n_s32(0x3F870A3Du);
  float32x4_t v31 = (float32x4_t)vdupq_n_s32(0x3D9E8391u);
  float32x4_t v32 = (float32x4_t)vdupq_n_s32(0x3B4D2E1Cu);
  float32x4_t v29 = (float32x4_t)vdupq_n_s32(0x3D55891Au);
  float32x4_t v30 = (float32x4_t)vdupq_n_s32(0x3F72A76Fu);
  float32x4_t v27 = (float32x4_t)vdupq_n_s32(0x3D25AEE6u);
  float32x4_t v28 = (float32x4_t)vdupq_n_s32(0x4019999Au);
  float32x4_t v25 = (float32x4_t)vdupq_n_s32(0x4196D000u);
  float32x4_t v26 = (float32x4_t)vdupq_n_s32(0x3E232010u);
  float32x4_t v23 = (float32x4_t)vdupq_n_s32(0x41958000u);
  float32x4_t v24 = (float32x4_t)vdupq_n_s32(0x3F560000u);
  __asm { FMOV            V1.4S, #1.0 }
  float32x4_t v21 = (float32x4_t)vdupq_n_s32(0x429DB000u);
  float32x4_t v22 = _Q1;
  uint64_t v10 = v0;
  do
  {
    v4 += 4;
    int8x8_t v11 = vorr_s8((int8x8_t)vdup_n_s32(v4), (int8x8_t)0x300000002);
    v12.i16[0] = v4;
    v12.i16[1] = v4 | 1;
    v12.i16[2] = v11.i16[0];
    v12.i16[3] = v11.i16[2];
    float32x4_t v13 = vcvtq_f32_f16((float16x4_t)(*(void *)&vshl_n_s16(v12, 3uLL) | 0x4000400040004));
    int8x16_t v38 = (int8x16_t)vmulq_f32(v13, v36);
    float32x4_t v40 = v13;
    float32x4_t v14 = (float32x4_t)_simd_log2_f4((simd_float4)v13);
    float32x4_t v39 = (float32x4_t)vbslq_s8((int8x16_t)vcgeq_f32(v32, v40), v38, (int8x16_t)vmlaq_f32(v33, v34, (float32x4_t)_simd_exp2_f4((simd_float4)vmulq_f32(v14, v35))));
    float32x4_t v15 = (float32x4_t)_simd_log2_f4((simd_float4)vmlaq_f32(v29, v30, v40));
    float32x4_t v37 = (float32x4_t)vbslq_s8((int8x16_t)vcgeq_f32(v27, v40), (int8x16_t)vmulq_f32(v40, v31), (int8x16_t)_simd_exp2_f4((simd_float4)vmulq_f32(v15, v28)));
    float32x4_t v16 = (float32x4_t)_simd_log2_f4((simd_float4)v40);
    float32x4_t v17 = (float32x4_t)_simd_exp2_f4((simd_float4)vmulq_f32(v16, v26));
    float32x4_t v18 = (float32x4_t)_simd_log2_f4((simd_float4)vdivq_f32(vmlaq_f32(v24, v25, v17), vmlaq_f32(v22, v23, v17)));
    float32x4_t v19 = (float32x4_t)_simd_exp2_f4((simd_float4)vmulq_f32(v18, v21));
    *uint64_t v10 = vcvt_f16_f32(v39);
    v10[1024] = vcvt_f16_f32(v37);
    v10[2048] = vcvt_f16_f32(v19);
    ++v10;
  }
  while (v4 < 0xFFC);
  v2->i16[0] = 0;
  v2[480].i16[0] = COERCE_UNSIGNED_INT(1.0);
  v3->i16[0] = 0;
  v3[480].i16[0] = COERCE_UNSIGNED_INT(1.0);
  return v2;
}

RB::XML::Document *RBDrawingStateDrawLayer(int8x16_t *a1, RB::DisplayList::State *a2, unsigned int a3, float a4)
{
  double v8 = (atomic_uint *)a1->i64[1];
  if (!*((void *)v8 + 3)) {
    make_contents(a1->i64[1]);
  }
  if (v8 != *((atomic_uint **)a2 + 1)) {
    RB::precondition_failure((RB *)"display list mismatch", (const char *)a2);
  }
  uint64_t v9 = RB::DisplayList::Builder::end_layer((RB::DisplayList::Builder *)(v8 + 4), a2);
  RB::DisplayList::Builder::delete_state(v8 + 4, a2);
  int v10 = rb_blend_mode(a3);
  RB::DisplayList::Builder::draw_layer((uint64_t)(v8 + 4), v9, a1, v10, a4);
  uint64_t result = (RB::XML::Document *)*((void *)v8 + 38);
  if (result)
  {
    return (RB::XML::Document *)RB::XML::DisplayList::draw_layer(result, a3, a4);
  }
  return result;
}

uint64_t RB::DisplayList::Builder::end_layer(RB::DisplayList::Builder *this, const RB::DisplayList::State *a2)
{
  CFStringRef v2 = (void *)*((void *)this + 4);
  if (!v2 || (uint64_t v3 = *v2, *(_DWORD *)(*v2 + 56) != *((_DWORD *)a2 + 36))) {
    RB::precondition_failure((RB *)"current layer doesn't match drawing state", (const char *)a2);
  }
  uint64_t v4 = v2[1];
  *CFStringRef v2 = *((void *)this + 3);
  *((void *)this + 3) = v2;
  *((void *)this + 4) = v4;
  return v3;
}

RB::DisplayList::Builder *RB::DisplayList::Builder::draw_layer(uint64_t a1, uint64_t a2, int8x16_t *a3, int a4, float a5)
{
  uint64_t v16 = a2;
  float v15 = a5;
  int v7 = *(_DWORD *)(a2 + 60);
  if ((v7 & 0x800) != 0) {
    a4 = 24;
  }
  int v14 = a4;
  if ((v7 & 0x400) != 0)
  {
    uint64_t v9 = (atomic_uint *)a3[5].i64[1];
    a3[5].i64[1] = 0;
    uint64_t v10 = a3[7].i64[1];
    a3[7].i64[1] = 0;
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
  }
  RB::Heap::emplace<RB::DisplayList::LayerItem,float &,RB::BlendMode &,RB::DisplayList::Layer *&>((size_t *)(*(void *)(a1 + 8) + 16), &v15, &v14, &v16);
  uint64_t result = RB::DisplayList::Builder::draw((RB::DisplayList::Contents **)a1, v11, a3);
  if ((*(unsigned char *)(v16 + 61) & 4) != 0)
  {
    float32x4_t v13 = (atomic_uint *)a3[5].i64[1];
    a3[5].i64[1] = (uint64_t)v9;
    a3[7].i64[1] = v10;
    uint64_t v9 = v13;
  }
  if (v9)
  {
    if (atomic_fetch_add_explicit(v9 + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      return (RB::DisplayList::Builder *)(*(uint64_t (**)(atomic_uint *))(*(void *)v9 + 8))(v9);
    }
  }
  return result;
}

void sub_21411690C(_Unwind_Exception *exception_object)
{
  if (v1) {
    RB::DisplayList::Builder::draw_layer(v1);
  }
  _Unwind_Resume(exception_object);
}

double RB::Heap::emplace<RB::DisplayList::LayerItem,float &,RB::BlendMode &,RB::DisplayList::Layer *&>(size_t *a1, float *a2, int *a3, uint64_t *a4)
{
  uint64_t v7 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v7 + 56 > a1[3]) {
    uint64_t v7 = RB::Heap::alloc_slow(a1, 0x38uLL, 7);
  }
  else {
    a1[2] = v7 + 56;
  }
  float v8 = *a2;
  int v9 = *a3;
  uint64_t v10 = *a4;
  *(void *)&double result = RB::DisplayList::LayerItem::LayerItem(v7, v9, v10, v8);
  return result;
}

__int16 RB::DisplayList::LayerItem::LayerItem@<H0>(uint64_t a1@<X0>, char a2@<W1>, uint64_t a3@<X2>, float _S0@<S0>)
{
  __int16 v4 = 512;
  if (a3)
  {
    if ((*(_WORD *)(a3 + 60) & 0x2001) != 0) {
      __int16 v4 = 1536;
    }
    else {
      __int16 v4 = 512;
    }
  }
  __asm { FCVT            H0, S0 }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = result;
  *(_WORD *)(a1 + 46) = v4 | a2 & 0x3F;
  *(void *)a1 = &unk_26C4ECEF8;
  *(void *)(a1 + 48) = a3;
  return result;
}

_DWORD *RB::DisplayList::Predicate::add_color(_DWORD *this, const RB::Fill::Color *a2)
{
  uint64_t v3 = this;
  int v4 = this[8];
  if (this[9] < (v4 + 1))
  {
    this = RB::vector<RB::DisplayList::Predicate::Term,1ul,unsigned int>::reserve_slow(this, v4 + 1);
    int v4 = v3[8];
  }
  float64x2_t v5 = (_DWORD *)*((void *)v3 + 3);
  if (!v5) {
    float64x2_t v5 = v3;
  }
  uint64_t v6 = &v5[6 * v4];
  _DWORD *v6 = 2;
  uint64_t v7 = *(void *)a2;
  *((_WORD *)v6 + 8) = *((_WORD *)a2 + 4);
  *((void *)v6 + 1) = v7;
  ++v3[8];
  return this;
}

BOOL RB::Symbol::Animator::remove_all_animations(os_unfair_lock_s *this)
{
  os_unfair_lock_lock(this);
  uint64_t v2 = *(void *)&this[6]._os_unfair_lock_opaque;
  if (v2)
  {
    uint64_t v3 = *(RB::Symbol::Animation **)&this[4]._os_unfair_lock_opaque;
    uint64_t v4 = 88 * v2;
    do
    {
      RB::Symbol::Animation::send_completion(v3, 0);
      uint64_t v3 = (RB::Symbol::Animation *)((char *)v3 + 88);
      v4 -= 88;
    }
    while (v4);
    uint64_t v5 = *(void *)&this[6]._os_unfair_lock_opaque;
    if (v5)
    {
      uint64_t v6 = 88 * v5;
      uint64_t v7 = (atomic_uint **)(*(void *)&this[4]._os_unfair_lock_opaque + 80);
      do
      {
        float v8 = *v7;
        if (*v7 && atomic_fetch_add_explicit(v8 + 2, 0xFFFFFFFF, memory_order_release) == 1)
        {
          __dmb(9u);
          (*(void (**)(atomic_uint *))(*(void *)v8 + 8))(v8);
        }
        uint64_t v9 = (uint64_t)*(v7 - 1);
        *(v7 - 1) = 0;
        if (v9) {
          std::default_delete<RB::Symbol::Animation::Timing>::operator()[abi:nn180100]((uint64_t)(v7 - 1), v9);
        }

        v7 += 11;
        v6 -= 88;
      }
      while (v6);
    }
    *(void *)&this[6]._os_unfair_lock_opaque = 0;
    ++this[15]._os_unfair_lock_opaque;
  }
  os_unfair_lock_unlock(this);
  return v2 != 0;
}

void sub_214116C6C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

RB::DisplayList::State *RBDrawingStateBeginLayer(RB::DisplayList::State *a1, _RBDrawingState *a2)
{
  uint64_t v4 = (void *)*((void *)a1 + 1);
  if (!v4[3]) {
    make_contents(*((void *)a1 + 1));
  }
  unsigned int v5 = (a2 >> 1) & 4;
  if ((a2 & 4) != 0) {
    unsigned int v5 = 2;
  }
  uint64_t v6 = (LayerState *)RB::DisplayList::Builder::begin_layer((RB::DisplayList::Builder *)(v4 + 2), a1, a2 & 1 | (8 * ((a2 >> 1) & 1)) & 0xFFFFF3FF | (((a2 >> 4) & 3) << 10) | v5);
  uint64_t v7 = RB::DisplayList::Builder::copy_state((RB::DisplayList::Builder *)(v4 + 2), v6, (atomic_uint **)a1);
  float v8 = (RB::XML::DisplayList *)v4[38];
  if (v8) {
    RB::XML::DisplayList::begin_layer(v8, a1, a2);
  }
  return v7;
}

int32x2_t *RB::DisplayList::Builder::begin_layer(RB::DisplayList::Builder *this, const RB::DisplayList::State *a2, int a3)
{
  if (!*((void *)this + 1)) {
    RB::DisplayList::Builder::reset_contents(this);
  }
  uint64_t v5 = *((void *)this + 4);
  if (!v5 || *(_DWORD *)(*(void *)v5 + 56) != *((_DWORD *)a2 + 36)) {
    RB::precondition_failure((RB *)"current layer doesn't match drawing state", (const char *)a2);
  }
  LODWORD(v18[0].f64[0]) = a3;
  uint64_t v6 = (size_t *)(*((void *)this + 1) + 16);
  ++*((_DWORD *)this + 1);
  uint64_t v7 = RB::Heap::emplace<RB::DisplayList::Layer,unsigned int,int>(v6, (int *)this + 1, (int *)v18);
  float v8 = (size_t *)*((void *)this + 1);
  int v9 = *(_DWORD *)this + 1;
  *(_DWORD *)this = v9;
  uint64_t v10 = (int32x2_t *)*((void *)this + 3);
  if (v10)
  {
    *((int32x2_t *)this + 3) = *v10;
  }
  else
  {
    uint64_t v10 = (int32x2_t *)((v8[4] + 7) & 0xFFFFFFFFFFFFFFF8);
    if ((unint64_t)&v10[5] > v8[5])
    {
      uint64_t v10 = (int32x2_t *)RB::Heap::alloc_slow(v8 + 2, 0x28uLL, 7);
      int v9 = *(_DWORD *)this;
    }
    else
    {
      v8[4] = (size_t)&v10[5];
    }
  }
  v10[2] = (int32x2_t)0x100000001000000;
  *uint64_t v10 = (int32x2_t)v7;
  v10[1] = 0;
  _OWORD v10[3] = vdup_n_s32(0x7F7FFFFFu);
  v10[4].i32[0] = v9;
  long long v21 = *(_OWORD *)(*((void *)this + 4) + 16);
  v18[0] = (float64x2_t)xmmword_2142181C0;
  v18[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  int8x8_t v11 = (RB::DisplayList::Style *)*((void *)a2 + 13);
  if (v11) {
    RB::DisplayList::Style::roi(v11, (float32x2_t *)&v21, v18);
  }
  uint64_t v12 = *((void *)a2 + 12);
  if (v12)
  {
    RB::Rect::move_identity((float32x2_t *)&v21, v18);
    RB::Rect::intersect((float32x2_t *)&v21, *(double *)(v12 + 16), *(float32x2_t *)(v12 + 24), v13, v14, v15, v16);
  }
  RB::Rect::move_identity((float32x2_t *)&v21, v18);
  *(_OWORD *)v10[2].i8 = v21;
  v10[1] = *(int32x2_t *)((char *)this + 32);
  *((void *)this + 4) = v10;
  return v10;
}

uint64_t RB::DisplayList::Builder::make_layer(RB::DisplayList::Builder *this, int a2)
{
  int v6 = a2;
  uint64_t v2 = (int *)((char *)this + 4);
  int v3 = *((_DWORD *)this + 1);
  uint64_t v4 = (size_t *)(*((void *)this + 1) + 16);
  *uint64_t v2 = v3 + 1;
  return RB::Heap::emplace<RB::DisplayList::Layer,unsigned int,int>(v4, v2, &v6);
}

uint64_t RB::Heap::emplace<RB::DisplayList::Layer,unsigned int,int>(size_t *a1, int *a2, int *a3)
{
  uint64_t v5 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 72 > a1[3]) {
    uint64_t v5 = RB::Heap::alloc_slow(a1, 0x48uLL, 7);
  }
  else {
    a1[2] = v5 + 72;
  }
  int v6 = *a2;
  int v7 = *a3;
  return RB::DisplayList::Layer::Layer(v5, v6, v7);
}

int8x16_t RB::Rect::move_identity(float32x2_t *this, float64x2_t *a2)
{
  int8x16_t result = vandq_s8(vandq_s8((int8x16_t)vceqq_f64(a2[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*a2, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(a2[2]));
  int32x4_t v2 = (int32x4_t)vdupq_laneq_s64((int64x2_t)result, 1);
  result.i64[0] = vandq_s8((int8x16_t)v2, result).u64[0];
  if ((result.i64[0] & 0x8000000000000000) == 0)
  {
    *(float32x2_t *)v2.i8 = this[1];
    *this = RB::operator*(a2, *this, v2);
    this[1] = v6;
    int8x16_t result = (int8x16_t)xmmword_2142181D0;
    *a2 = (float64x2_t)xmmword_2142181C0;
    a2[1] = (float64x2_t)xmmword_2142181D0;
    a2[2].f64[0] = 0.0;
    a2[2].f64[1] = 0.0;
  }
  return result;
}

RB::DisplayList::State *RB::DisplayList::Builder::copy_state(RB::DisplayList::Builder *this, LayerState *a2, atomic_uint **a3)
{
  int v5 = *(_DWORD *)(*(void *)a2 + 56);
  float32x2_t v6 = (RB::DisplayList::State *)*((void *)this + 2);
  if (v6) {
    *((void *)this + 2) = *(void *)v6;
  }
  else {
    float32x2_t v6 = (RB::DisplayList::State *)malloc_type_malloc(0xB0uLL, 0x9E39E26DuLL);
  }
  RB::DisplayList::State::State(v6, v5, (const RB::DisplayList::State *)a3);
  if ((*(unsigned char *)(*(void *)a2 + 61) & 4) != 0)
  {
    int v7 = (atomic_uint *)*((void *)v6 + 11);
    float v8 = a3[11];
    if (v7 != v8)
    {
      if (v7)
      {
        if (atomic_fetch_add_explicit(v7 + 2, 0xFFFFFFFF, memory_order_release) == 1)
        {
          __dmb(9u);
          (*(void (**)(atomic_uint *))(*(void *)v7 + 8))(v7);
        }
        float v8 = a3[11];
      }
      if (v8) {
        atomic_fetch_add_explicit(v8 + 2, 1u, memory_order_relaxed);
      }
      *((void *)v6 + 11) = v8;
    }
  }
  return v6;
}

RB::DisplayList::State *RB::DisplayList::State::State(RB::DisplayList::State *this, int a2, const RB::DisplayList::State *a3)
{
  uint64_t v6 = *((void *)a3 + 1);
  *(void *)this = 0;
  *((void *)this + 1) = v6;
  long long v7 = *((_OWORD *)a3 + 1);
  long long v8 = *((_OWORD *)a3 + 3);
  *((_OWORD *)this + 2) = *((_OWORD *)a3 + 2);
  *((_OWORD *)this + 3) = v8;
  *((_OWORD *)this + 1) = v7;
  *((_DWORD *)this + 16) = 0;
  uuid_clear((unsigned __int8 *)this + 68);
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = *((void *)a3 + 14);
  *((void *)this + 15) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 17) = 0;
  *((_DWORD *)this + 36) = a2;
  *((_DWORD *)this + 37) = -1;
  *((_DWORD *)this + 38) = *((_DWORD *)a3 + 38);
  *((_WORD *)this + 78) = *((_WORD *)a3 + 78);
  *((void *)this + 20) = 0;
  *((void *)this + 21) = *((void *)a3 + 21);
  return this;
}

void RB::XML::DisplayList::begin_layer(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3)
{
}

void *RB::DisplayList::Predicate::clear(void *this)
{
  uint64_t v1 = this;
  if (this[3]) {
    this = (void *)this[3];
  }
  uint64_t v2 = *((unsigned int *)v1 + 8);
  if (v2)
  {
    uint64_t v3 = 24 * v2;
    do
    {
      RB::DisplayList::Predicate::Term::~Term((RB::DisplayList::Predicate::Term *)this);
      this = (void *)(v4 + 24);
      v3 -= 24;
    }
    while (v3);
  }
  *((_DWORD *)v1 + 8) = 0;
  return this;
}

void RB::DisplayList::Predicate::Term::~Term(RB::DisplayList::Predicate::Term *this)
{
  if (*(_DWORD *)this == 3)
  {
    uint64_t v1 = *((void *)this + 1);
    if (v1)
    {
      uint64_t v2 = *(void **)(v1 + 24);
      if (v2) {
        uint64_t v3 = *(RB::DisplayList::Predicate::Term **)(v1 + 24);
      }
      else {
        uint64_t v3 = (RB::DisplayList::Predicate::Term *)*((void *)this + 1);
      }
      if (*(_DWORD *)(v1 + 32))
      {
        unint64_t v4 = 0;
        do
        {
          RB::DisplayList::Predicate::Term::~Term(v3);
          ++v4;
          uint64_t v3 = (RB::DisplayList::Predicate::Term *)(v5 + 24);
        }
        while (v4 < *(unsigned int *)(v1 + 32));
        uint64_t v2 = *(void **)(v1 + 24);
      }
      if (v2) {
        free(v2);
      }
      MEMORY[0x21669AC10](v1, 0x1020C4057BCEDDBLL);
    }
  }
}

const void **RB::CGContext::add_soft_mask(RB::CGContext::SoftMaskMode,RB::Rect,void const*,void (*)(RB::CGContext&,void const*))::$_3::__invoke(const void **result)
{
  if (result)
  {
    uint64_t v1 = *result;
    if (v1) {
      CFRelease(v1);
    }
    JUMPOUT(0x21669AC10);
  }
  return result;
}

void sub_2141176BC(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t anonymous namespace'::AllLayers::shared(_anonymous_namespace_::AllLayers *this)
{
  {
    operator new();
  }
}

void sub_21411774C(_Unwind_Exception *a1)
{
}

void RB::Fill::Gradient::fill(uint64_t a1, RB::CGContext *a2, double a3, double a4, double a5, double a6, int8x16_t a7, int8x16_t a8, int8x16_t a9)
{
  uint64_t v10 = (float32x2_t *)a1;
  uint64_t v156 = *MEMORY[0x263EF8340];
  unint64_t v12 = *(void *)a1;
  uint64_t v11 = *(void *)(a1 + 8);
  int v13 = *(_DWORD *)(a1 + 48);
  unint64_t v14 = (unint64_t)a2 + 8;
  double v15 = (unsigned __int8 *)(a1 + 53);
  if (!*(unsigned char *)(a1 + 54)) {
    double v15 = (unsigned __int8 *)a2 + 8;
  }
  *(void *)&CGFloat x = *v15;
  uint64_t v139 = (float32x2_t *)a1;
  if (v12 < 2) {
    goto LABEL_10;
  }
  if ((v13 & 0xF00) == 0x400)
  {
    uint64_t v121 = 0;
    float v122 = *(float *)(v11 + 8);
    uint64_t v123 = 1;
    uint64_t v124 = 24;
    do
    {
      float v125 = *(float *)(v11 + v124);
      if (v125 <= v122) {
        ++v121;
      }
      else {
        v121 += 16;
      }
      ++v123;
      v124 += 16;
      float v122 = v125;
    }
    while (v12 != v123);
    unint64_t v126 = v121 + 1;
    if (v121 + 1 == v12 || v126 >> 60)
    {
      uint64_t v20 = 0;
      int v137 = 0;
      LOWORD(v13) = 0;
      goto LABEL_11;
    }
    v143.CGFloat x = x;
    if (16 * v126 <= 0x1000)
    {
      MEMORY[0x270FA5388](a1, 16 * v126);
      float64x2_t v130 = (char *)&v133 - ((v132 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v130, v132);
      int v137 = 0;
    }
    else
    {
      int32x4_t v129 = (char *)malloc_type_malloc(16 * v126, 0xA39D62EAuLL);
      int v137 = 1;
      if (!v129)
      {
        uint64_t v20 = 0;
        goto LABEL_113;
      }
      float64x2_t v130 = v129;
    }
    {
      LOWORD(v13) = 0;
      *(void *)&CGFloat x = *(unsigned __int8 *)v14;
      unint64_t v12 = v126;
      uint64_t v20 = (uint64_t)v130;
      uint64_t v11 = (uint64_t)v130;
      goto LABEL_11;
    }
    uint64_t v20 = (uint64_t)v130;
LABEL_113:
    LOWORD(v13) = 0;
    CGFloat x = v143.x;
    goto LABEL_11;
  }
  if ((v13 & 0xF00) != 0x200)
  {
LABEL_10:
    uint64_t v20 = 0;
    int v137 = 0;
    goto LABEL_11;
  }
  double v17 = x;
  if (v18 != v12)
  {
    unint64_t v19 = v18;
    if (!(v18 >> 60))
    {
      if (16 * v18 <= 0x1000)
      {
        MEMORY[0x270FA5388](v18, 16 * v18);
        float64x2_t v128 = (char *)&v133 - ((v131 + 15) & 0xFFFFFFFFFFFFFFF0);
        bzero(v128, v131);
        int v137 = 0;
      }
      else
      {
        float64x2_t v127 = (char *)malloc_type_malloc(16 * v18, 0xE67B2199uLL);
        int v137 = 1;
        if (!v127)
        {
          uint64_t v20 = 0;
          goto LABEL_9;
        }
        float64x2_t v128 = v127;
      }
      *(void *)&CGFloat x = *(unsigned __int8 *)v14;
      LOWORD(v13) = 256;
      unint64_t v12 = v19;
      uint64_t v20 = (uint64_t)v128;
      uint64_t v11 = (uint64_t)v128;
      uint64_t v10 = v139;
      goto LABEL_11;
    }
  }
  uint64_t v20 = 0;
  int v137 = 0;
LABEL_9:
  LOWORD(v13) = 0;
  uint64_t v10 = v139;
  CGFloat x = v17;
LABEL_11:
  unsigned __int32 v136 = v10[6].u32[0];
  int v21 = (v136 >> 3) & 0x18;
  int v152 = 0;
  uint64_t v153 = 0;
  uint64_t v154 = 0;
  int8x8_t v149 = 0;
  size_t v150 = 0;
  uint64_t v151 = 0;
  v147[0] = (uint64_t)&v152;
  v147[1] = (uint64_t)&v149;
  char v148 = *(unsigned char *)v14;
  int v22 = v10[6].u8[4];
  double v135 = a2;
  if (v22 == 4)
  {
    double v23 = x;
    float v24 = RB::Fill::Gradient::angular_location_function((RB::Fill::Gradient *)v10);
    CGFloat x = v23;
    float v25 = v24;
    float v27 = v26;
  }
  else
  {
    float v27 = 0.0;
    float v25 = 1.0;
  }
  unsigned int v28 = 0x3010200u >> v21;
  uint64_t v138 = v20;
  if (!v12) {
    goto LABEL_51;
  }
  unint64_t v134 = v14;
  uint64_t v140 = (uint64_t)v146.i64 + 4;
  uint64_t v141 = (uint64_t)v155 + 4;
  unint64_t v29 = v12 - 2;
  int v30 = v13 & 0xF00;
  unint64_t v31 = 1;
  int64x2_t v32 = vdupq_n_s64(0x10000000000uLL);
  int64x2_t v142 = v32;
  CGPoint v143 = (CGPoint)vdupq_n_s64(*(void *)&x << 32);
  for (unint64_t i = v12; ; unint64_t i = v35)
  {
    unint64_t v34 = v31 - 1;
    unint64_t v35 = i - 1;
    if (v25 <= 0.0) {
      unint64_t v34 = i - 1;
    }
    uint64_t v36 = v11 + 16 * v34;
    float v37 = *(float *)(v36 + 8) * v25;
    *(float *)v32.i32 = v37 + v27;
    v38.i64[0] = WORD1(*(void *)v36);
    v38.i64[1] = (unsigned __int16)WORD2(*(void *)v36);
    v39.i64[0] = 0xFFFFLL;
    v39.i64[1] = 0xFFFFLL;
    a7.i64[1] = (unint64_t)(unsigned __int16)HIWORD(*(void *)v36) << 16;
    v40.i64[0] = vshlq_n_s64(v38, 0x30uLL).u64[0];
    v40.i64[1] = vorrq_s8(a7, vandq_s8(*(int8x16_t *)&v38, v39)).i64[1];
    v41.i64[1] = v142.i64[1];
    v39.i64[1] = *(void *)&v143.y;
    v39.i64[0] = (unint64_t)(unsigned __int16)*(void *)v36 << 32;
    v41.i64[0] = COERCE_UNSIGNED_INT(v37 + v27);
    v155[0] = vorrq_s8(v40, vorrq_s8(v39, v41));
    if ((float)(v37 + v27) >= 0.0)
    {
      if (*(float *)v32.i32 > 1.0)
      {
        if (v31 != 1)
        {
          if (v25 > 0.0) {
            unint64_t i = v31 - 2;
          }
          uint64_t v49 = v11 + 16 * i;
          float v50 = *(float *)(v49 + 8) * v25;
          v51.i64[0] = WORD1(*(void *)v49);
          v51.i64[1] = (unsigned __int16)WORD2(*(void *)v49);
          v52.i64[0] = 0xFFFFLL;
          v52.i64[1] = 0xFFFFLL;
          a8.i64[1] = (unint64_t)(unsigned __int16)HIWORD(*(void *)v49) << 16;
          v53.i64[0] = vshlq_n_s64(v51, 0x30uLL).u64[0];
          v53.i64[1] = vorrq_s8(a8, vandq_s8(*(int8x16_t *)&v51, v52)).i64[1];
          v54.i64[1] = v142.i64[1];
          v52.i64[1] = *(void *)&v143.y;
          v52.i64[0] = (unint64_t)(unsigned __int16)*(void *)v49 << 32;
          v54.i64[0] = COERCE_UNSIGNED_INT(v50 + v27);
          int8x16_t v146 = vorrq_s8(v53, vorrq_s8(v52, v54));
          if ((float)(v50 + v27) <= 1.0) {
            RB::Fill::Color::mix(v141, v140, v28, (float)((float)((float)(v50 + v27) - 1.0) / (float)(v37 - v50)) + 1.0);
          }
        }
        LODWORD(v155[0]) = 1065353216;
        v32.i32[0] = 1.0;
      }
    }
    else
    {
      if (v31 < v12)
      {
        unint64_t v42 = i - 2;
        if (v25 > 0.0) {
          unint64_t v42 = v31;
        }
        uint64_t v43 = v11 + 16 * v42;
        float v44 = *(float *)(v43 + 8) * v25;
        v45.i64[0] = WORD1(*(void *)v43);
        v45.i64[1] = (unsigned __int16)WORD2(*(void *)v43);
        v46.i64[0] = 0xFFFFLL;
        v46.i64[1] = 0xFFFFLL;
        a9.i64[1] = (unint64_t)(unsigned __int16)HIWORD(*(void *)v43) << 16;
        v47.i64[0] = vshlq_n_s64(v45, 0x30uLL).u64[0];
        v47.i64[1] = vorrq_s8(a9, vandq_s8(*(int8x16_t *)&v45, v46)).i64[1];
        v48.i64[1] = v142.i64[1];
        v46.i64[1] = *(void *)&v143.y;
        v46.i64[0] = (unint64_t)(unsigned __int16)*(void *)v43 << 32;
        v48.i64[0] = COERCE_UNSIGNED_INT(v44 + v27);
        int8x16_t v146 = vorrq_s8(v47, vorrq_s8(v46, v48));
        if ((float)(v44 + v27) >= 0.0) {
          RB::Fill::Color::mix(v141, v140, v28, *(float *)v32.i32 / (float)(v37 - v44));
        }
      }
      LODWORD(v155[0]) = 0;
      v32.i64[0] = 0;
    }
    unint64_t v14 = v14 & 0xFFFFFFFFFFFF0000 | WORD6(v155[0]);
    *(double *)v32.i64 = RB::Fill::Gradient::fill(RB::CGContext &,RB::Bounds)const::$_0::operator()(v147, *(uint64_t *)((char *)v155 + 4), v14, *(double *)v32.i64);
    if (v30 != 256 || v31 >= v12) {
      break;
    }
    v32.i32[0] = v155[0];
    *(double *)v32.i64 = RB::Fill::Gradient::fill(RB::CGContext &,RB::Bounds)const::$_0::operator()(v147, 0, 0, *(double *)v32.i64);
    if (v12 == v31)
    {
      uint64_t v20 = v138;
      uint64_t v10 = v139;
      unint64_t v14 = v134;
      if (v12 < 2) {
        goto LABEL_51;
      }
      goto LABEL_42;
    }
LABEL_37:
    ++v31;
  }
  if (v12 != v31) {
    goto LABEL_37;
  }
  uint64_t v20 = v138;
  uint64_t v10 = v139;
  unint64_t v14 = v134;
  if (v30 != 256 || v12 <= 1) {
    goto LABEL_51;
  }
LABEL_42:
  unint64_t v55 = v12 - 1;
  if (v25 > 0.0) {
    unint64_t v55 = 0;
  }
  float v56 = v27 + (float)(*(float *)(v11 + 16 * v55 + 8) * v25);
  int8x8_t v57 = v149 + 1;
  uint64_t v58 = (float64x2_t *)(v152 + 6);
  uint64_t v59 = 1;
  __asm { FMOV            V0.2D, #0.5 }
  do
  {
    uint64_t v65 = v59 - 1;
    if (v25 <= 0.0) {
      uint64_t v66 = v29;
    }
    else {
      uint64_t v66 = v59;
    }
    if (v25 <= 0.0) {
      uint64_t v65 = v29 + 1;
    }
    float v67 = v27 + (float)(*(float *)(v11 + 16 * v66 + 8) * v25);
    *int8x8_t v57 = (float)(v56 + (float)((float)(v67 - v56) * *(float *)(v11 + 16 * v65 + 12)));
    v57 += 2;
    float64x2_t v68 = v58[-2];
    float64x2_t v69 = v58[2];
    v58[-1] = vmlaq_f64(v58[-3], _Q0, vsubq_f64(v58[1], v58[-3]));
    *uint64_t v58 = vmlaq_f64(v68, _Q0, vsubq_f64(v69, v68));
    v58 += 4;
    --v29;
    ++v59;
    float v56 = v67;
  }
  while (v59 != v12);
LABEL_51:
  if ((v136 & 0x40) != 0)
  {
    float32x4_t v70 = v152;
    uint64_t v153 = 0;
    uint64_t v154 = 0;
    uint64_t v151 = 0;
    int v152 = 0;
    double v72 = v149;
    size_t v71 = v150;
    int8x8_t v149 = 0;
    size_t v150 = 0;
    if (v71)
    {
      uint64_t v73 = 0;
      CGPoint v143 = (CGPoint)xmmword_214219FD0;
      unsigned int v74 = v72;
      char v75 = v70;
      do
      {
        if (++v73 >= v71)
        {
          double v83 = *v74;
          *(float *)&double v83 = *v74;
          _D1 = *(void *)v75;
          _D2 = *((void *)v75 + 1);
          __asm
          {
            FCVT            H2, D2
            FCVT            H1, D1
          }
          uint64_t v86 = _D1;
          uint64_t v87 = _D2;
          _Q1 = *((_OWORD *)v75 + 1);
          _D2 = *((void *)v75 + 3);
          __asm
          {
            FCVT            H2, D2
            FCVT            H1, D1
          }
          WORD1(_Q1) = _D2;
          *(void *)&_Q1 = vmovl_u16(*(uint16x4_t *)&_Q1).u64[0];
          v90.i64[0] = _Q1;
          v90.i64[1] = DWORD1(_Q1);
          v91.i64[0] = 0xFFFFLL;
          v91.i64[1] = 0xFFFFLL;
          int64x2_t v92 = (int64x2_t)vshlq_u64((uint64x2_t)vandq_s8(v90, v91), (uint64x2_t)v143);
          unint64_t v93 = v20 & 0xFFFFFFFFFFFF0000 | *(unsigned __int8 *)v14;
          uint64_t v20 = v93 | 0x100;
          RB::Fill::Gradient::fill(RB::CGContext &,RB::Bounds)const::$_0::operator()(v147, vorrq_s8((int8x16_t)vdupq_laneq_s64(v92, 1), (int8x16_t)v92).u64[0] | (v87 << 16) | v86, v93 | 0x100, v83);
        }
        else
        {
          _Q1 = *(_OWORD *)v75;
          _Q0 = *((_OWORD *)v75 + 1);
          _D2 = *((void *)v75 + 1);
          __asm
          {
            FCVT            H2, D2
            FCVT            H1, D1
          }
          WORD1(_Q1) = _D2;
          __int16 v79 = *(unsigned __int8 *)v14 | 0x100;
          __asm { FCVT            H2, D0 }
          WORD2(_Q1) = _D2;
          *(CGFloat *)&_Q0 = v75[3];
          __asm { FCVT            H0, D0 }
          WORD3(_Q1) = _Q0;
          *(void *)&v155[0] = _Q1;
          WORD4(v155[0]) = v79;
          _Q1 = *((_OWORD *)v75 + 2);
          _Q0 = *((_OWORD *)v75 + 3);
          _D2 = *((void *)v75 + 5);
          __asm
          {
            FCVT            H2, D2
            FCVT            H1, D1
          }
          WORD1(_Q1) = _D2;
          __asm { FCVT            H2, D0 }
          WORD2(_Q1) = _D2;
          *(CGFloat *)&_Q0 = v75[7];
          __asm { FCVT            H0, D0 }
          WORD3(_Q1) = _Q0;
          v146.i64[0] = _Q1;
          v146.i16[4] = v79;
          *(CGFloat *)&_Q0 = *v74;
          *(float *)&_Q0 = *v74;
          *(float *)&_Q1 = v74[1];
        }
        v75 += 4;
        ++v74;
      }
      while (v71 != v73);
LABEL_60:
      free(v72);
    }
    else if (v72)
    {
      goto LABEL_60;
    }
    uint64_t v20 = v138;
    uint64_t v10 = v139;
    if (v70) {
      free(v70);
    }
  }
  float32x2_t v94 = v135;
  BOOL v95 = RB::CGContext::printing_context(v135);
  float v96 = RB::cg_color_space((RB *)*(unsigned __int8 *)v14, !v95);
  double v97 = CGGradientCreateWithColorComponents(v96, v152, v149, v150);
  if (v10[2])
  {
    RB::CGContext::save(v94);
    int v98 = *(CGContext **)v94;
    float v99 = (_OWORD *)v10[2];
    long long v100 = v99[1];
    *(_OWORD *)&v145.a = *v99;
    *(_OWORD *)&v145.c = v100;
    *(_OWORD *)&v145.tCGFloat x = v99[2];
    CGContextConcatCTM(v98, &v145);
  }
  switch(v10[6].i8[4])
  {
    case 0:
      CGPoint v101 = (CGPoint)vcvtq_f64_f32(v10[3]);
      CGPoint v102 = (CGPoint)vcvtq_f64_f32(v10[4]);
      CGFloat y = v101.y;
      CGFloat v104 = v102.y;
      CGContextDrawLinearGradient(*(CGContextRef *)v94, v97, v101, v102, 3u);
      break;
    case 1:
      CGPoint v105 = (CGPoint)vcvtq_f64_f32(v10[3]);
      CGPoint v106 = (CGPoint)vcvtq_f64_f32(v10[4]);
      CGFloat v107 = v105.y;
      CGFloat v108 = v106.y;
      CGContextDrawRadialGradient(*(CGContextRef *)v94, v97, v105, v10[5].f32[0], v106, v10[5].f32[1], 3u);
      break;
    case 2:
      float v109 = v10[5].f32[0];
      goto LABEL_73;
    case 4:
      float v110 = v10[5].f32[0];
      float v109 = v10[5].f32[1];
      float v111 = vabds_f32(v109, v110);
      if (v111 <= 6.2832)
      {
        if (v109 < v110) {
          float v110 = v10[5].f32[1];
        }
        float v109 = (float)(v110 + -3.1416) + (float)(v111 * 0.5);
      }
LABEL_73:
      float32x2_t v112 = v10[3];
      BOOL v113 = RB::CGContext::printing_context(v94);
      double v114 = v109;
      CGPoint v115 = (CGPoint)vcvtq_f64_f32(v112);
      if (v113)
      {
        CGPoint v143 = v115;
        ClipBoundingBoCGFloat x = CGContextGetClipBoundingBox((CGContextRef)*(void *)v94);
        CGFloat v116 = ClipBoundingBox.origin.y;
        CGFloat height = ClipBoundingBox.size.height;
        *(float32x2_t *)v146.i8 = vcvt_f32_f64((float64x2_t)ClipBoundingBox.origin);
        v146.u64[1] = (unint64_t)vcvt_f32_f64((float64x2_t)ClipBoundingBox.size);
        RB::CGContext::begin_bitmap((int8x8_t *)v94, (float32x2_t *)&v146, 0, 0, 0, 0, &v144);
        if (v144)
        {
          __asm { FMOV            V0.2S, #1.0 }
          RB::CGContext::CGContext(v155, v144, *(unsigned __int8 *)v14, _D0);
          CGContextDrawConicGradient(*(CGContextRef *)&v155[0], v97, v143, v114);
          Image = CGBitmapContextCreateImage(*(CGContextRef *)&v155[0]);
          if (Image)
          {
            v158.origin.CGFloat x = *(float *)v146.i32;
            v158.origin.CGFloat y = *(float *)&v146.i32[1];
            v158.size.CGFloat width = *(float *)&v146.i32[2];
            v158.size.CGFloat height = *(float *)&v146.i32[3];
            CGContextDrawImage(*(CGContextRef *)v94, v158, Image);
            CFRelease(Image);
          }
          RB::CGContext::~CGContext((RB::CGContext *)v155);
          if (v144) {
            CFRelease(v144);
          }
        }
      }
      else
      {
        CGFloat v120 = v115.y;
        CGContextDrawConicGradient(*(CGContextRef *)v94, v97, v115, v114);
      }
      break;
    default:
      break;
  }
  if (v10[2]) {
    RB::CGContext::restore(v94);
  }
  if (v97) {
    CFRelease(v97);
  }
  if (v149) {
    free(v149);
  }
  if (v152) {
    free(v152);
  }
  if (v137) {
    free((void *)v20);
  }
}

void sub_2141181C0(_Unwind_Exception *exception_object)
{
  *(void *)(v1 + 32) = v2;
  if (*(_DWORD *)(v1 + 28)) {
    free(*(void **)(v1 + 32));
  }
  _Unwind_Resume(exception_object);
}

CGLayer *RB::CGContext::add_soft_mask(uint64_t a1, int a2, uint64_t a3, void (*a4)(CGContextRef *, uint64_t), float32x2_t a5, int32x4_t a6)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  *(float32x2_t *)a6.i8 = vrndp_f32(vadd_f32(*(float32x2_t *)a6.i8, a5));
  double v34 = RB::Rect::from_bounds(vrndm_f32(a5), a6);
  CGSize v11 = (CGSize)vcvtq_f64_f32(v10);
  CGFloat height = v11.height;
  int8x16_t result = CGLayerCreateWithContext(0, v11, 0);
  if (result)
  {
    Context = CGLayerGetContext(result);
    CGContextTranslateCTM(Context, (float)-*(float *)&v34, (float)-*((float *)&v34 + 1));
    RB::CGContext::CGContext((uint64_t)c, Context, (RB *)*(unsigned __int8 *)(a1 + 8), *(double *)(a1 + 16));
    int Type = *(_DWORD *)(a1 + 144);
    if (Type < 0)
    {
      int Type = CGContextGetType();
      *(_DWORD *)(a1 + 144) = Type;
    }
    int v40 = Type;
    if (CGContextGetSoftMask())
    {
      CGSoftMaskGetMatrix();
      float64x2_t v32 = v37;
      float64x2_t v33 = (float64x2_t)v36;
      float64x2_t v31 = v38;
      CGSoftMaskGetBounds();
      float v17 = v16;
      float v19 = v18;
      int8x16_t v30 = (int8x16_t)vmlaq_n_f64(vmlaq_n_f64(v38, (float64x2_t)v36, (float)-v17), v37, (float)-v19);
      float64x2_t v38 = (float64x2_t)v30;
      if (RB::AffineTransform::invert((RB::AffineTransform *)&v36)) {
        unint64_t v20 = -1;
      }
      else {
        unint64_t v20 = 0;
      }
      int8x16_t v21 = (int8x16_t)vdupq_n_s64(v20);
      v35[0] = (float64x2_t)vbslq_s8(v21, (int8x16_t)v36, (int8x16_t)v33);
      v35[1] = (float64x2_t)vbslq_s8(v21, (int8x16_t)v37, (int8x16_t)v32);
      v35[2] = (float64x2_t)vbslq_s8(v21, (int8x16_t)v38, v30);
      float64x2_t v22 = *(float64x2_t *)(a1 + 48);
      float64x2_t v23 = vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 64), *(float64x2_t *)(a1 + 32), *(float *)&v34), v22, *((float *)&v34 + 1));
      long long v36 = *(_OWORD *)(a1 + 32);
      float64x2_t v37 = v22;
      float64x2_t v38 = v23;
      v24.f64[0] = RB::operator*(v35, (float64x2_t *)&v36);
      int64x2_t v27 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v25, v32), (int8x16_t)vceqq_f64(v24, v33)), (int8x16_t)vceqq_f64(v26, v31));
      if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v27, 1), (int8x16_t)v27).u64[0] & 0x8000000000000000) == 0)
      {
        long long v36 = xmmword_26C4EF060;
        *(void *)&v37.f64[0] = off_26C4EF070;
        operator new();
      }
      CGContextSetSoftMask();
      if (a2 == 2)
      {
        *(void *)&long long v36 = 0x3C003C003C003C00;
        WORD4(v36) = 0;
        uint16x4_t v28 = (uint16x4_t)vmvn_s8((int8x8_t)vceq_f16((float16x4_t)c[14], (float16x4_t)0x3C003C003C003C00));
        v28.i16[0] = vmaxv_u16(v28);
        if (v28.i8[0]) {
          RB::CGContext::set_fill_color_slow((RB::CGContext *)c, (const RB::Fill::Color *)&v36, v28);
        }
        unint64_t v29 = c[0];
        ClipBoundingBoCGFloat x = CGContextGetClipBoundingBox(c[0]);
        CGContextFillRect(v29, ClipBoundingBox);
      }
    }
    a4(c, a3);
    long long v36 = xmmword_26C4EF078;
    *(void *)&v37.f64[0] = off_26C4EF088;
    operator new();
  }
  return result;
}

void sub_2141186CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,CGContextRef a45)
{
  RB::CGContext::~CGContext(&a45);
  CFRelease(v45);
  _Unwind_Resume(a1);
}

void render_contents(CGContext *a1, NSDictionary *a2, const RB::DisplayList::Contents *a3, _RBDrawingState *a4)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  id v8 = [(NSDictionary *)a2 objectForKeyedSubscript:@"disablePassthrough"];
  if (v8 && ([v8 BOOLValue] & 1) != 0
    || (LODWORD(v28[0].f64[0]) = 0,
        LODWORD(v27.a) = 0,
        int v9 = (RB::DisplayList::State *)RB::ContextDelegate::state_ref((uint64_t)a1, (float *)v28, &v27),
        (float32x2_t v10 = (int8x16_t *)v9) == 0))
  {
    id v18 = [(NSDictionary *)a2 objectForKeyedSubscript:RBDisplayListRenderColorSpace];
    if (v18) {
      unsigned int v19 = [v18 unsignedIntValue];
    }
    else {
      unsigned int v19 = 0;
    }
    id v20 = [(NSDictionary *)a2 objectForKeyedSubscript:RBDisplayListRenderRasterizationScale];
    if (v20)
    {
      [v20 floatValue];
      if (*(float *)v22.i32 <= 0.0) {
        RB::precondition_failure((RB *)"invalid rasterization scale: %g", v21, *(float *)v22.i32);
      }
      int32x2_t v23 = vdup_lane_s32(v22, 0);
    }
    else
    {
      CGContextGetCTM(&v27, a1);
      v28[0] = *(float64x2_t *)&v27.a;
      v28[1] = *(float64x2_t *)&v27.c;
      _OWORD v28[2] = *(float64x2_t *)&v27.tx;
      int32x2_t v23 = RB::AffineTransform::scale2(v28);
    }
    __int16 v24 = rb_color_space(v19);
    if ((v24 & 0xFF00) != 0) {
      unsigned __int8 v25 = v24;
    }
    else {
      unsigned __int8 v25 = 1;
    }
    RB::CGContext::CGContext(v28, a1, v25, *(double *)&v23);
    RB::DisplayList::render(a3, (const RB::DisplayList::Contents *)v28, 0, v26);
    RB::CGContext::~CGContext((RB::CGContext *)v28);
  }
  else
  {
    BOOL v11 = *(float *)v28[0].f64 == 1.0 && LODWORD(v27.a) == 0;
    int v12 = !v11;
    int v13 = (uint64_t *)v9;
    if (!v11) {
      int v13 = (uint64_t *)RBDrawingStateBeginLayer(v9, 0);
    }
    uint64_t v14 = v13[1];
    if (!*(void *)(v14 + 24)) {
      make_contents(v13[1]);
    }
    RB::DisplayList::Builder::draw((RB::DisplayList::Layer ***)(v14 + 16), a3, (RB::DisplayList::State *)v13, 1.0, 0, 0);
    double v16 = *(RB::XML::DisplayList **)(v14 + 304);
    if (v16) {
      BOOL v17 = a4 == 0;
    }
    else {
      BOOL v17 = 1;
    }
    if (!v17) {
      RB::XML::DisplayList::draw_list(v16, (RB::XML::Document *)v13, a4, v15, 1.0);
    }
    if (v12) {
      RBDrawingStateDrawLayer(v10, (RB::DisplayList::State *)v13, LODWORD(v27.a), *(float *)v28[0].f64);
    }
  }
}

void sub_214118A04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  RB::CGContext::~CGContext((RB::CGContext *)va);
  _Unwind_Resume(a1);
}

uint64_t RB::ContextDelegate::state_ref(uint64_t a1, float *a2, _DWORD *a3)
{
  uint64_t result = CGContextGetDelegate();
  if (result)
  {
    if ((uint64_t (*)())CGContextDelegateGetCallback() == RB::ContextDelegate::get_bounds
      && (uint64_t Info = CGContextDelegateGetInfo(), *(void *)(Info + 432)))
    {
      uint64_t v7 = Info;
      GState = (const char *)CGContextGetGState();
      uint64_t RenderingState = CGContextGetRenderingState();
      RB::ContextDelegate::update(v7, GState, RenderingState, 0);
      if (a2)
      {
        CGGStateGetAlpha();
        float v11 = v10;
        if (!*(void *)(v7 + 360)) {
          float v11 = *(float *)(v7 + 456) * v11;
        }
        *a2 = v11;
      }
      if (a3)
      {
        unsigned int CompositeOperation = CGGStateGetCompositeOperation();
        if (CompositeOperation > 0x1B) {
          int v13 = 0;
        }
        else {
        *a3 = v13;
        }
      }
      return *(void *)(v7 + 440);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void RB::CGContext::~CGContext(CGContextRef *this)
{
  if (*((unsigned char *)this + 141)) {
    CGContextRestoreGState(*this);
  }
  CGContextRef v2 = this[110];
  if (v2) {
    free(v2);
  }
  CGContextRef v3 = this[51];
  if (v3) {
    free(v3);
  }
}

void sub_214118B64(_Unwind_Exception *exception_object)
{
  CGContextRef v3 = *(void **)(v1 + 880);
  if (v3) {
    free(v3);
  }
  unint64_t v4 = *(void **)(v1 + 408);
  if (v4) {
    free(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::CGContext::CGContext(uint64_t a1, CGContextRef c, RB *a3, double a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  *(void *)a1 = c;
  *(unsigned char *)(a1 + 8) = (_BYTE)a3;
  *(double *)(a1 + 16) = a4;
  CGContextGetCTM(&v16, c);
  long long v6 = *(_OWORD *)&v16.c;
  long long v7 = *(_OWORD *)&v16.tx;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)&v16.a;
  *(_OWORD *)(a1 + 48) = v6;
  *(_OWORD *)(a1 + 64) = v7;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(int32x2_t *)(a1 + 96) = vdup_n_s32(0xC0000001);
  *(void *)(a1 + 104) = 0x8000000080000000;
  *(void *)(a1 + 112) = 0x3C00000000000000;
  *(_WORD *)(a1 + 120) = 0;
  *(void *)(a1 + 122) = 0x3C00000000000000;
  *(_WORD *)(a1 + 130) = 0;
  *(void *)(a1 + 132) = 0x23F800000;
  *(_WORD *)(a1 + 140) = 0;
  *(_DWORD *)(a1 + 144) = -1;
  *(void *)(a1 + 408) = 0;
  *(void *)(a1 + 416) = 0x400000000;
  *(void *)(a1 + 880) = 0;
  *(void *)(a1 + 888) = 0x400000000;
  CGContextSetAlpha(*(CGContextRef *)a1, 1.0);
  CGContextSetBlendMode(*(CGContextRef *)a1, kCGBlendModeNormal);
  CGContextSetShouldAntialias(*(CGContextRef *)a1, 1);
  CGContextSetFontSize(*(CGContextRef *)a1, 1.0);
  id v8 = *(CGContext **)a1;
  long long v9 = *(_OWORD *)(MEMORY[0x263F000D0] + 16);
  *(_OWORD *)&v15.a = *MEMORY[0x263F000D0];
  *(_OWORD *)&v15.c = v9;
  *(_OWORD *)&v15.tCGFloat x = *(_OWORD *)(MEMORY[0x263F000D0] + 32);
  CGContextSetTextMatrix(v8, &v15);
  double v10 = *(CGContext **)a1;
  float v11 = RB::cg_color_space(a3, 1);
  CGContextSetFillColorSpace(v10, v11);
  int v12 = *(CGContext **)a1;
  int v13 = RB::cg_color_space(a3, 1);
  CGContextSetStrokeColorSpace(v12, v13);
  *(_OWORD *)&v16.a = xmmword_21421A538;
  *(_OWORD *)&v16.c = unk_21421A548;
  CGContextSetFillColor(*(CGContextRef *)a1, &v16.a);
  CGContextSetStrokeColor(*(CGContextRef *)a1, &v16.a);
  return a1;
}

void sub_214118D20(_Unwind_Exception *exception_object)
{
}

uint64_t RB::extended_srgb_colorspace(RB *this)
{
  uint64_t v1 = &color_symbols(void)::flag;
  {
    uint64_t v1 = &color_symbols(void)::flag;
    if (v3)
    {
      RB::extended_srgb_colorspace(void)::r = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x263F00238]);
      uint64_t v1 = &color_symbols(void)::flag;
    }
  }
  return *((void *)v1 + 92);
}

RB *RB::cg_color_space(RB *result, char a2)
{
  switch((int)result)
  {
    case 0:
      if (a2)
      {
        uint64_t result = (RB *)RB::extended_linear_srgb_colorspace(result);
      }
      else
      {
        uint64_t result = (RB *)RB::linear_srgb_colorspace(result);
      }
      break;
    case 1:
      if (a2)
      {
        uint64_t result = (RB *)RB::extended_srgb_colorspace(result);
      }
      else
      {
        uint64_t result = (RB *)RB::srgb_colorspace(result);
      }
      break;
    case 2:
      if (a2)
      {
        uint64_t result = (RB *)RB::extended_linear_display_p3_colorspace(result);
      }
      else
      {
        uint64_t result = (RB *)RB::linear_display_p3_colorspace(result);
      }
      break;
    case 3:
      if (a2)
      {
        uint64_t result = (RB *)RB::extended_display_p3_colorspace(result);
      }
      else
      {
        uint64_t result = (RB *)RB::display_p3_colorspace(result);
      }
      break;
    case 4:
      abort();
    case 5:
      uint64_t result = (RB *)RB::pq_colorspace(result);
      break;
    default:
      return result;
  }
  return result;
}

uint64_t RB::ContextDelegate::draw_glyphs(uint64_t a1, size_t a2, const char *a3, uint64_t a4, unsigned __int16 *a5, float64x2_t *a6, unint64_t a7)
{
  unint64_t v7 = a7;
  long long v9 = a5;
  size_t v79 = a2;
  uint64_t v90 = *MEMORY[0x263EF8340];
  int v12 = a5;
  if (a7)
  {
    uint64_t v13 = 2 * a7;
    int v12 = a5;
    while ((__int16)*v12 != -1)
    {
      ++v12;
      v13 -= 2;
      if (!v13)
      {
        int v12 = &a5[a7];
        break;
      }
    }
  }
  if (a7 != v12 - a5)
  {
    RB::ContextDelegate::draw_glyphs_removing_invalid(a1, v79, (uint64_t)a3, a4, a5, a6, a7);
    return 0;
  }
  unsigned int TextDrawingMode = CGGStateGetTextDrawingMode();
  if ((TextDrawingMode & 0xFFFFFFFB) != 3)
  {
    unsigned int v15 = TextDrawingMode;
    uint64_t Info = CGContextDelegateGetInfo();
    RB::ContextDelegate::update(Info, a3, v79, 1);
    float64x2_t v17 = *(float64x2_t *)(a4 + 16);
    float64x2_t v18 = *(float64x2_t *)(a4 + 32);
    v86[0] = *(float64x2_t *)a4;
    v86[1] = v17;
    v86[2] = v18;
    uint64_t CTM = CGGStateGetCTM();
    float64x2_t v20 = *(float64x2_t *)(CTM + 16);
    float64x2_t v21 = *(float64x2_t *)(CTM + 32);
    v85[0] = *(float64x2_t *)CTM;
    v85[1] = v20;
    v85[2] = v21;
    v22.f64[0] = RB::operator*(v86, v85);
    float64x2_t v87 = v22;
    float64x2_t v88 = v23;
    float64x2_t v89 = v24;
    v25.f64[0] = RB::operator*(&v87, (float64x2_t *)(Info + 384));
    float64x2_t v76 = v26;
    float64x2_t v77 = v25;
    float64x2_t v75 = v27;
    Font = (RB *)CGGStateGetFont();
    CGGStateGetFontSize();
    float64x2_t v81 = v28;
    if (v15 <= 5)
    {
      int v29 = 1 << v15;
      if (((1 << v15) & 0x15) == 0)
      {
        int v42 = 34;
        goto LABEL_28;
      }
      int FontRenderingStyle = CGGStateGetFontRenderingStyle();
      int v31 = MEMORY[0x21669A710](v79);
      CGGStateGetFontDilation();
      unint64_t v33 = v32;
      unint64_t v35 = v34;
      uint64_t ShouldDrawBitmapRuns = CGGStateGetShouldDrawBitmapRuns();
      LODWORD(v80.f64[0]) = ShouldDrawBitmapRuns;
      if ((*(unsigned char *)(Info + 460) & 4) != 0) {
        int v38 = v31 & FontRenderingStyle & 0xFFFFFFF7;
      }
      else {
        int v38 = v31 & FontRenderingStyle;
      }
      if (v7 >> 60)
      {
LABEL_27:
        int v29 = 1 << v15;
        int v42 = 38;
LABEL_28:
        if ((v29 & v42) != 0)
        {
          float v56 = *(RB::DisplayList::State **)(Info + 440);
          float64x2_t v57 = *(float64x2_t *)(MEMORY[0x263F000D0] + 16);
          v83[0] = *(float64x2_t *)MEMORY[0x263F000D0];
          v83[1] = v57;
          v83[2] = *(float64x2_t *)(MEMORY[0x263F000D0] + 32);
          objc_msgSend(*(id *)(Info + 8), "setEOFill:", 0, RBDrawingStateSetCTM(v56, v83));
          if ([*(id *)(Info + 8) renderingMode] >= 2) {
            [*(id *)(Info + 8) setRenderingModeArgument:*(float *)(Info + 556)];
          }
          v82[3] = v77;
          v82[4] = v76;
          v82[5] = v75;
          CGGStateGetAdjustedLineWidth();
          double v59 = v58;
          uint64_t LineCap = CGGStateGetLineCap();
          uint64_t LineJoin = CGGStateGetLineJoin();
          CGGStateGetMiterLimit();
          double v63 = v62;
          v87.f64[0] = 0.0;
          v86[0].f64[0] = 0.0;
          if (CGGStateGetLineDash()) {
            uint64_t Pattern = CGDashGetPattern();
          }
          else {
            uint64_t Pattern = 0;
          }
          LODWORD(v80.f64[0]) = CGFontGetUnitsPerEm(Font);
          if ((*(unsigned char *)(Info + 460) & 8) != 0)
          {
            CFDictionaryRef path_cache_for_stroking = 0;
            if (!v7) {
              return 0;
            }
          }
          else
          {
            CFDictionaryRef path_cache_for_stroking = (const __CFDictionary *)RB::cg_font_get_path_cache_for_stroking(Font, v65);
            if (!v7) {
              return 0;
            }
          }
          double v67 = v81.f64[0] / (double)SLODWORD(v80.f64[0]);
          float64x2_t v68 = vmulq_n_f64(v76, v67);
          float64x2_t v69 = vmulq_n_f64(v77, v67);
          float64x2_t v73 = v69;
          float64x2_t v74 = v68;
          float32x4_t v70 = &a6->f64[1];
          do
          {
            v69.f64[0] = *(v70 - 1);
            float64x2_t v80 = v69;
            v69.f64[0] = *v70;
            float64x2_t v81 = v69;
            RB::cg_font_get_glyph_path(Font, (CGFont *)*v9, path_cache_for_stroking, v85);
            if (*(void *)&v85[0].f64[0])
            {
              size_t v71 = *(void **)(Info + 8);
              v82[0] = v73;
              v82[1] = v74;
              v82[2] = vmlaq_n_f64(vmlaq_n_f64(v75, v77, v80.f64[0]), v76, v81.f64[0]);
              [v71 setStrokedPath:*(void *)&v85[0].f64[0] transform:v82 lineWidth:LineCap lineCap:LineJoin lineJoin:Pattern miterLimit:*(void *)&v87.f64[0] dashPhase:v59 dashPattern:v63 dashCount:v86[0].f64[0]];
              StrokeColor = (CGColor *)CGGStateGetStrokeColor();
              RB::ContextDelegate::set_color_in_shape(Info, StrokeColor, (int)a3, v79, 1);
              if (*(void *)&v85[0].f64[0]) {
                CFRelease(*(CFTypeRef *)&v85[0].f64[0]);
              }
            }
            ++v9;
            v70 += 2;
            --v7;
          }
          while (v7);
        }
        return 0;
      }
      unint64_t v39 = 16 * v7;
      if (16 * v7 > 0x1000)
      {
        int v40 = (float64x2_t *)malloc_type_malloc(16 * v7, 0xB2ACC368uLL);
        if (!v40)
        {
LABEL_26:
          free(v40);
          goto LABEL_27;
        }
      }
      else
      {
        MEMORY[0x270FA5388](ShouldDrawBitmapRuns, v37);
        int v40 = (float64x2_t *)((char *)&v73 - ((v39 + 15) & 0xFFFFFFFFFFFFFFF0));
        bzero(v40, 16 * v7);
      }
      float64x2_t v87 = vmulq_n_f64(v77, v81.f64[0]);
      float64x2_t v88 = vmulq_n_f64(v76, v81.f64[0]);
      float64x2_t v89 = v75;
      uint64_t v43 = *(RB::DisplayList::State **)(Info + 440);
      v84[0] = v87;
      v84[1] = v88;
      v84[2] = v75;
      if (objc_msgSend(*(id *)(Info + 8), "renderingMode", RBDrawingStateSetCTM(v43, v84)) >= 2)
      {
        float v46 = *(float *)(Info + 556);
        float v47 = RB::AffineTransform::scale(&v87);
        float32x2_t v48 = vrecpe_f32((float32x2_t)LODWORD(v47));
        float32x2_t v49 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v47), v48), v48);
        objc_msgSend(*(id *)(Info + 8), "setRenderingModeArgument:", (float)(v46 * vmul_f32(v49, vrecps_f32((float32x2_t)LODWORD(v47), v49)).f32[0]));
      }
      if (v7)
      {
        float v50 = (__n128 *)v40;
        int64x2_t v51 = a6;
        unint64_t v52 = v7;
        double v53 = 1.0 / v81.f64[0];
        do
        {
          float64x2_t v54 = *v51++;
          __n128 v45 = (__n128)vmulq_n_f64(v54, v53);
          *v50++ = v45;
          --v52;
        }
        while (v52);
      }
      v44.n128_u64[0] = v33;
      v45.n128_u64[0] = v35;
      [(RBShape *)*(void *)(Info + 8) setGlyphs:v40 positions:v7 count:Font font:v38 renderingStyle:SLOBYTE(v80.f64[0]) dilation:v44 shouldDrawBitmapRuns:v45];
      [*(id *)(Info + 8) setEOFill:0];
      FillColor = (CGColor *)CGGStateGetFillColor();
      RB::ContextDelegate::set_color_in_shape(Info, FillColor, (int)a3, v79, 1);
      if (v39 <= 0x1000) {
        goto LABEL_27;
      }
      goto LABEL_26;
    }
  }
  return 0;
}

void sub_214119418(_Unwind_Exception *exception_object)
{
  if (v2 > 0x1000) {
    free(v1);
  }
  _Unwind_Resume(exception_object);
}

double RBDrawingStateSetCTM(RB::DisplayList::State *this, float64x2_t *a2)
{
  unint64_t v4 = *(RB::XML::Document **)(*((void *)this + 1) + 304);
  float64x2_t v5 = *a2;
  if (v4)
  {
    float64x2_t v9 = *((float64x2_t *)this + 2);
    float64x2_t v22 = *((float64x2_t *)this + 1);
    float64x2_t v23 = v9;
    float64x2_t v24 = *((float64x2_t *)this + 3);
    float64x2_t v10 = a2[1];
    float64x2_t v11 = a2[2];
    int64x2_t v12 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v23, v10), (int8x16_t)vceqq_f64(v22, v5)), (int8x16_t)vceqq_f64(v24, v11));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v12, 1), (int8x16_t)v12).u64[0] & 0x8000000000000000) == 0)
    {
      v20[0] = v5;
      v20[1] = v10;
      void v20[2] = v11;
      v19[0] = (float64x2_t)RB::AffineTransform::inverse((RB::AffineTransform *)&v22);
      v19[1] = v13;
      v19[2] = v14;
      v15.f64[0] = RB::operator*(v20, v19);
      v21[0] = v15;
      v21[1] = v16;
      v21[2] = v17;
      RB::XML::DisplayList::concat_ctm(v4, this, v21, v18);
      float64x2_t v5 = *a2;
    }
  }
  float64x2_t v6 = a2[1];
  float64x2_t v7 = a2[2];
  float64x2_t v22 = v5;
  float64x2_t v23 = v6;
  float64x2_t v24 = v7;
  *(void *)&double result = RB::DisplayList::State::set_ctm(this, (const RB::AffineTransform *)&v22).n128_u64[0];
  return result;
}

__n128 RB::DisplayList::State::set_ctm(RB::DisplayList::State *this, const RB::AffineTransform *a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *((_OWORD *)a2 + 2);
  *((_OWORD *)this + 2) = *((_OWORD *)a2 + 1);
  *((_OWORD *)this + 3) = v3;
  *((__n128 *)this + 1) = result;
  *((void *)this + 14) = 0;
  *((_DWORD *)this + 37) = -1;
  return result;
}

void RB::ContextDelegate::update(uint64_t a1, const char *a2, uint64_t a3, char a4)
{
  if (!*(void *)(a1 + 432)) {
    RB::precondition_failure((RB *)"inactive drawing context", a2);
  }
  uint64_t ClipStack = CGGStateGetClipStack();
  uint64_t SoftMask = CGGStateGetSoftMask();
  uint64_t Style = CGGStateGetStyle();
  int Identifier = CGClipStackGetIdentifier();
  uint64_t v73 = SoftMask;
  if (SoftMask)
  {
    int v11 = CGSoftMaskGetIdentifier();
    if (Style) {
      goto LABEL_4;
    }
LABEL_7:
    uint64_t AllowsAntialiasing = CGRenderingStateGetAllowsAntialiasing();
    int v12 = 0;
    goto LABEL_8;
  }
  int v11 = 0;
  if (!Style) {
    goto LABEL_7;
  }
LABEL_4:
  int v12 = CGStyleGetIdentifier();
  uint64_t AllowsAntialiasing = CGRenderingStateGetAllowsAntialiasing();
  Baseuint64_t CTM = (float64x2_t *)CGRenderingStateGetBaseCTM();
  int64x2_t v15 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(*(float64x2_t *)(a1 + 496), BaseCTM[1]), (int8x16_t)vceqq_f64(*(float64x2_t *)(a1 + 480), *BaseCTM)), (int8x16_t)vceqq_f64(*(float64x2_t *)(a1 + 512), BaseCTM[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v15, 1), (int8x16_t)v15).u64[0] & 0x8000000000000000) == 0) {
    *(_DWORD *)(a1 + 476) = 0;
  }
LABEL_8:
  if (*(_DWORD *)(a1 + 464) == Identifier
    && (!ClipStack || *(unsigned __int8 *)(a1 + 468) == AllowsAntialiasing)
    && *(_DWORD *)(a1 + 472) == v11
    && *(_DWORD *)(a1 + 476) == v12)
  {
    if (!*(void *)(a1 + 440))
    {
      float64x2_t v16 = RBDrawingStateInit(*(RB::DisplayList::State **)(a1 + 432));
      *(void *)(a1 + 440) = v16;
      if (!*(_DWORD *)(a1 + 528))
      {
        uint64_t v17 = 1;
        RBDrawingStateSetDefaultColorSpace((uint64_t)v16, 1u);
        if ((AllowsAntialiasing & 1) == 0) {
          goto LABEL_66;
        }
        goto LABEL_63;
      }
    }
    goto LABEL_58;
  }
  uint64_t v18 = *(void *)(a1 + 440);
  if (v18) {
    RBDrawingStateAssign(v18, *(void *)(a1 + 432));
  }
  else {
    *(void *)(a1 + 440) = RBDrawingStateInit(*(RB::DisplayList::State **)(a1 + 432));
  }
  uint64_t v71 = a3;
  char v72 = a4;
  if (!*(_DWORD *)(a1 + 528)) {
    RBDrawingStateSetDefaultColorSpace(*(void *)(a1 + 440), 1u);
  }
  *(_DWORD *)(a1 + 464) = Identifier;
  *(unsigned char *)(a1 + 468) = AllowsAntialiasing;
  *(_DWORD *)(a1 + 472) = v11;
  *(_DWORD *)(a1 + 476) = v12;
  if ((CGClipStackIsInfinite() & 1) == 0)
  {
    CGClipStackGetRect();
    double x = v85.origin.x;
    double y = v85.origin.y;
    double width = v85.size.width;
    double height = v85.size.height;
    if (!CGRectIsInfinite(v85))
    {
      objc_msgSend(*(id *)(a1 + 8), "setRect:", x, y, width, height);
      [*(id *)(a1 + 8) setAntialiased:AllowsAntialiasing];
      RBDrawingStateClipShape(*(__n128 **)(a1 + 440), *(void *)(a1 + 8), 0);
    }
    uint64_t Count = CGClipStackGetCount();
    if (Count)
    {
      uint64_t v24 = Count;
      for (uint64_t i = 0; i != v24; ++i)
      {
        CGClipStackGetClipAtIndex();
        if (AllowsAntialiasing) {
          uint64_t ShouldAntialias = CGClipGetShouldAntialias();
        }
        else {
          uint64_t ShouldAntialias = 0;
        }
        unsigned int Mode = CGClipGetMode();
        switch(CGClipGetType())
        {
          case 0u:
            if (Mode > 1)
            {
              if (Mode == 2)
              {
                CGClipGetRect();
                CGPathRef v50 = CGPathCreateWithRect(v86, 0);
                CGClipGetStroke();
                RB::ContextDelegate::set_stroked_clip(a1, (uint64_t)v50);
                if (v50) {
                  CFRelease(v50);
                }
              }
            }
            else
            {
              float64x2_t v28 = *(void **)(a1 + 8);
              CGClipGetRect();
              objc_msgSend(v28, "setRect:");
            }
            goto LABEL_45;
          case 2u:
            uint64_t Path = CGClipGetPath();
            if (Mode > 1)
            {
              if (Mode == 2)
              {
                CGClipGetStroke();
                RB::ContextDelegate::set_stroked_clip(a1, Path);
              }
            }
            else
            {
              objc_msgSend(*(id *)(a1 + 8), "setPath:", Path, v71);
              [*(id *)(a1 + 8) setEOFill:Mode == 1];
            }
LABEL_45:
            objc_msgSend(*(id *)(a1 + 8), "setAntialiased:", ShouldAntialias, v71);
            RBDrawingStateClipShape(*(__n128 **)(a1 + 440), *(void *)(a1 + 8), 0);
            break;
          case 3u:
            CGClipGetMask();
            uint64_t Image = CGClipMaskGetImage();
            if (Image)
            {
              uint64_t v31 = Image;
              CGClipMaskGetRect();
              *(float *)&double v32 = v32;
              *(float *)&double v33 = v33;
              *(float *)v34.i32 = *(double *)v34.i64;
              *(float *)&double v35 = v35;
              float32x2_t v75 = (float32x2_t)__PAIR64__(LODWORD(v33), LODWORD(v32));
              *(double *)&unint64_t v36 = *(float *)v34.i32;
              v34.i32[1] = LODWORD(v35);
              int32x4_t v74 = v34;
              *(double *)v34.i64 = (float)-*(float *)&v35;
              *((float *)&v32 + 1) = *(float *)&v33 + *(float *)&v35;
              v37.f64[0] = 0.0;
              *(void *)&v37.f64[1] = v34.i64[0];
              float64x2_t v82 = (float64x2_t)v36;
              float64x2_t v83 = v37;
              float64x2_t v84 = vcvtq_f64_f32(*(float32x2_t *)&v32);
              CGClipMaskGetMatrix();
              float64x2_t v79 = (float64x2_t)v78[3];
              long long v80 = v78[4];
              long long v81 = v78[5];
              int v38 = *(void **)(a1 + 16);
              *(double *)&long long v39 = RB::operator*(&v82, &v79);
              v78[0] = v39;
              v78[1] = v40;
              v78[2] = v41;
              LODWORD(v39) = 1065353216;
              LODWORD(v40) = 1065353216;
              LODWORD(v41) = 1065353216;
              LODWORD(v42) = 1065353216;
              objc_msgSend(v38, "setImage:transform:interpolation:tintColor:flags:", v31, v78, 1, 0, *(double *)&v39, *(double *)&v40, *(double *)&v41, v42);
              uint64_t v43 = *(void **)(a1 + 8);
              float32x2_t v44 = RB::operator*(&v79, v75, v74);
              objc_msgSend(v43, "setRect:", v44.f32[0], v44.f32[1], v45, v46);
              [*(id *)(a1 + 8) setAntialiased:ShouldAntialias];
              float v47 = RBDrawingStateBeginLayer(*(RB::DisplayList::State **)(a1 + 440), 0);
              RBDrawingStateDrawShape((__n128 *)v47, *(void *)(a1 + 8), *(RBFill **)(a1 + 16), 0, 1.0);
              RBDrawingStateClipLayer(*(__n128 **)(a1 + 440), v47, 0, 1.0);
            }
            break;
          case 4u:
            CGClipGetTextClipping();
            uint64_t v48 = CGTextClippingCreatePath();
            if (v48)
            {
              float32x2_t v49 = (const void *)v48;
              if (Mode > 1)
              {
                if (Mode == 2)
                {
                  CGClipGetStroke();
                  RB::ContextDelegate::set_stroked_clip(a1, (uint64_t)v49);
                }
              }
              else
              {
                [*(id *)(a1 + 8) setPath:v48];
                [*(id *)(a1 + 8) setEOFill:Mode == 1];
              }
              objc_msgSend(*(id *)(a1 + 8), "setAntialiased:", ShouldAntialias, v71);
              RBDrawingStateClipShape(*(__n128 **)(a1 + 440), *(void *)(a1 + 8), 0);
              CFRelease(v49);
            }
            break;
          default:
            continue;
        }
      }
    }
  }
  if (v73) {
    RB::ContextDelegate::clip_soft_mask(a1);
  }
  a4 = v72;
  if (!Style) {
    goto LABEL_58;
  }
  int64x2_t v51 = (_OWORD *)CGRenderingStateGetBaseCTM();
  long long v52 = v51[1];
  long long v53 = v51[2];
  *(_OWORD *)(a1 + 480) = *v51;
  *(_OWORD *)(a1 + 496) = v52;
  *(_OWORD *)(a1 + 512) = v53;
  float64x2_t v54 = *(RB::DisplayList::State **)(a1 + 440);
  v55.f64[0] = RB::operator*((float64x2_t *)(a1 + 480), (float64x2_t *)(a1 + 384));
  v77[0] = v55;
  v77[1] = v56;
  v77[2] = v57;
  RBDrawingStateSetCTM(v54, v77);
  int Type = CGStyleGetType();
  if (Type == 4)
  {
    RB::ContextDelegate::add_color_matrix_style(a1);
    if ((AllowsAntialiasing & 1) == 0) {
      goto LABEL_65;
    }
    goto LABEL_63;
  }
  if (Type != 3)
  {
    if (Type == 1)
    {
      RB::ContextDelegate::add_shadow_style(a1);
      if ((AllowsAntialiasing & 1) == 0) {
        goto LABEL_65;
      }
      goto LABEL_63;
    }
LABEL_58:
    if (!AllowsAntialiasing) {
      goto LABEL_65;
    }
    goto LABEL_63;
  }
  RB::ContextDelegate::add_gaussian_blur_style(a1);
  if ((AllowsAntialiasing & 1) == 0)
  {
LABEL_65:
    uint64_t v17 = 1;
    goto LABEL_66;
  }
LABEL_63:
  if (!CGGStateGetShouldAntialias()) {
    goto LABEL_65;
  }
  uint64_t v17 = *(unsigned int *)(a1 + 552);
LABEL_66:
  objc_msgSend(*(id *)(a1 + 8), "setRenderingMode:", v17, v71);
  if ((a4 & 1) == 0)
  {
    uint64_t CTM = CGGStateGetCTM();
    long long v60 = *(_OWORD *)(CTM + 16);
    long long v61 = *(_OWORD *)(CTM + 32);
    float64x2_t v79 = *(float64x2_t *)CTM;
    long long v80 = v60;
    long long v81 = v61;
    v62.f64[0] = RB::operator*(&v79, (float64x2_t *)(a1 + 384));
    float64x2_t v82 = v62;
    float64x2_t v83 = v63;
    float64x2_t v84 = v64;
    uint64_t v65 = *(RB::DisplayList::State **)(a1 + 440);
    v76[0] = v62;
    v76[1] = v63;
    v76[2] = v64;
    RBDrawingStateSetCTM(v65, v76);
    if (v17 >= 2)
    {
      float v66 = *(float *)(a1 + 556);
      float v67 = RB::AffineTransform::scale(&v82);
      float32x2_t v68 = vrecpe_f32((float32x2_t)LODWORD(v67));
      float32x2_t v69 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v67), v68), v68);
      objc_msgSend(*(id *)(a1 + 8), "setRenderingModeArgument:", (float)(v66 * vmul_f32(v69, vrecps_f32((float32x2_t)LODWORD(v67), v69)).f32[0]));
    }
  }
  float32x4_t v70 = *(void **)(a1 + 544);
  if (v70) {
    RBDrawingStateSetAttribute(*(RB::DisplayList::State **)(a1 + 440), v70, 1);
  }
}

void sub_214119C60(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void RB::ContextDelegate::set_color_in_shape(uint64_t a1, CGColorRef color, int a3, uint64_t a4, int a5)
{
  CGPatternRef Pattern = CGColorGetPattern(color);
  if (Pattern)
  {
    float64x2_t v9 = Pattern;
    uint64_t CTM = CGGStateGetCTM();
    float64x2_t v11 = *(float64x2_t *)(CTM + 16);
    long long v12 = *(_OWORD *)(CTM + 32);
    float64x2_t v173 = *(float64x2_t *)CTM;
    float64x2_t v174 = v11;
    v175[0] = v12;
    v13.f64[0] = RB::operator*(&v173, (float64x2_t *)(a1 + 384));
    float64x2_t v170 = v13;
    float64x2_t v171 = v14;
    float64x2_t v172 = v15;
    Baseuint64_t CTM = CGRenderingStateGetBaseCTM();
    float64x2_t v17 = *(float64x2_t *)(BaseCTM + 16);
    long long v18 = *(_OWORD *)(BaseCTM + 32);
    float64x2_t v173 = *(float64x2_t *)BaseCTM;
    float64x2_t v174 = v17;
    v175[0] = v18;
    v19.f64[0] = RB::operator*(&v173, (float64x2_t *)(a1 + 384));
    float64x2_t v167 = v19;
    float64x2_t v168 = v20;
    float64x2_t v169 = v21;
    uint64_t Shading = CGPatternGetShading();
    if (Shading)
    {
      float64x2_t v23 = (CGShading *)Shading;
      CGPatternGetMatrix();
      float64x2_t v164 = v173;
      float64x2_t v165 = v174;
      float64x2_t v166 = (float64x2_t)v175[0];
      int64x2_t v24 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v168, v171), (int8x16_t)vceqq_f64(v167, v170)), (int8x16_t)vceqq_f64(v169, v172));
      if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v24, 1), (int8x16_t)v24).u64[0] & 0x8000000000000000) == 0)
      {
        v25.f64[0] = RB::operator*(&v164, &v167);
        float64x2_t v161 = v25;
        float64x2_t v162 = v26;
        float64x2_t v163 = v27;
        float64x2_t v173 = v170;
        float64x2_t v174 = v171;
        v175[0] = v172;
        BOOL v28 = RB::AffineTransform::invert((RB::AffineTransform *)&v173);
        int v29 = &v173;
        if (!v28) {
          int v29 = &v170;
        }
        float64x2_t v30 = *v29;
        if (v28) {
          uint64_t v31 = &v174;
        }
        else {
          uint64_t v31 = &v171;
        }
        float64x2_t v32 = *v31;
        if (v28) {
          double v33 = (float64x2_t *)v175;
        }
        else {
          double v33 = &v172;
        }
        float64x2_t v34 = *v33;
        float64x2_t v173 = v30;
        float64x2_t v174 = v32;
        v175[0] = v34;
        v35.f64[0] = RB::operator*(&v161, &v173);
        float64x2_t v164 = v35;
        float64x2_t v165 = v36;
        float64x2_t v166 = v37;
      }
      if (a5)
      {
        if (RB::ContextDelegate::draw_shading_in_shape(a1, a3, v23, &v164)) {
          return;
        }
      }
      else
      {
        CGShadingGetBounds();
        if (CGRectIsInfinite(v178)
          && (RB::ContextDelegate::set_shading((RB::ContextDelegate *)a1, v23, (const RB::AffineTransform *)&v164) & 1) != 0)
        {
          return;
        }
      }
    }
    int IsColored = CGPatternIsColored();
    int v46 = 1065353216;
    int v47 = 1065353216;
    int v48 = 1065353216;
    float v49 = 1.0;
    if ((IsColored & 1) == 0)
    {
      PatternBaseColor = (CGColor *)CGColorGetPatternBaseColor();
      if (PatternBaseColor)
      {
        double v51 = RBColorFromCGColor2(PatternBaseColor, *(_DWORD *)(a1 + 528));
        int v46 = LODWORD(v51);
        int v47 = v52;
        int v48 = v53;
        float v49 = v54;
      }
    }
    float v55 = CGColorGetAlpha(color) * v49;
    CGGStateGetPatternPhase();
    double v57 = v56;
    double v59 = v58;
    uint64_t Image = (CGImage *)CGPatternGetImage();
    if (Image)
    {
      float64x2_t v62 = Image;
      *(float *)&long long v61 = v57;
      long long v154 = v61;
      float Width = (float)CGImageGetWidth(Image);
      float Height = (float)CGImageGetHeight(v62);
      CGPatternGetMatrix();
      float64x2_t v164 = v173;
      float64x2_t v165 = v174;
      float64x2_t v166 = (float64x2_t)v175[0];
      v66.i32[0] = v154;
      float v63 = v59;
      v66.f32[1] = Height + v63;
      v67.f64[0] = 0.0;
      v67.f64[1] = (float)-Height;
      float64x2_t v173 = (float64x2_t)COERCE_UNSIGNED_INT64(Width);
      float64x2_t v174 = v67;
      v175[0] = vcvtq_f64_f32(v66);
      v68.f64[0] = RB::operator*(&v173, &v164);
      HIDWORD(v72) = HIDWORD(v171.f64[0]);
      float64x2_t v161 = v68;
      float64x2_t v162 = v69;
      float64x2_t v163 = v70;
      HIDWORD(v73) = HIDWORD(v172.f64[0]);
      int64x2_t v74 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v168, v171), (int8x16_t)vceqq_f64(v167, v170)), (int8x16_t)vceqq_f64(v169, v172));
      int8x16_t v75 = (int8x16_t)vdupq_laneq_s64(v74, 1);
      if ((vandq_s8(v75, (int8x16_t)v74).u64[0] & 0x8000000000000000) == 0)
      {
        v76.f64[0] = RB::operator*(&v161, &v167);
        v160[0] = v76;
        v160[1] = v77;
        v160[2] = v78;
        float64x2_t v173 = v170;
        float64x2_t v174 = v171;
        v175[0] = v172;
        BOOL v79 = RB::AffineTransform::invert((RB::AffineTransform *)&v173);
        if (v79) {
          long long v80 = &v173;
        }
        else {
          long long v80 = &v170;
        }
        float64x2_t v81 = *v80;
        if (v79) {
          float64x2_t v82 = &v174;
        }
        else {
          float64x2_t v82 = &v171;
        }
        float64x2_t v83 = *v82;
        if (v79) {
          float64x2_t v84 = (float64x2_t *)v175;
        }
        else {
          float64x2_t v84 = &v172;
        }
        float64x2_t v85 = *v84;
        float64x2_t v173 = v81;
        float64x2_t v174 = v83;
        v175[0] = v85;
        v68.f64[0] = RB::operator*(v160, &v173);
        float64x2_t v161 = v68;
        float64x2_t v162 = v69;
        float64x2_t v163 = v70;
      }
      CGRect v86 = *(void **)(a1 + 16);
      v159[0] = v68;
      v159[1] = v69;
      v159[2] = v70;
      v75.i32[0] = v46;
      LODWORD(v73) = v47;
      LODWORD(v72) = v48;
      *(float *)&double v71 = v55;
      objc_msgSend(v86, "setTiledImage:transform:sourceRect:interpolation:tintColor:flags:", v62, v159, 1, IsColored ^ 1u, 0.0, 0.0, 1.0, 1.0, *(double *)v75.i64, v73, v72, v71, v154);
      if (a5)
      {
        float64x2_t v87 = *(__n128 **)(a1 + 440);
        uint64_t v88 = *(void *)(a1 + 8);
        float64x2_t v89 = *(RBFill **)(a1 + 16);
        CGGStateGetAlpha();
        float v91 = v90;
        if (!*(void *)(a1 + 360)) {
          float v91 = *(float *)(a1 + 456) * v91;
        }
        unsigned int CompositeOperation = CGGStateGetCompositeOperation();
        if (CompositeOperation > 0x1B) {
          unsigned int v93 = 0;
        }
        else {
        RBDrawingStateDrawShape(v87, v88, v89, v93, v91);
        }
      }
    }
    else
    {
      [*(id *)(a1 + 8) boundingRect];
      v95.f64[1] = v94;
      v97.f64[1] = v96;
      *(float32x2_t *)v98.i8 = vcvt_f32_f64(v97);
      *(float32x2_t *)&v160[0].f64[0] = RB::operator*(&v170, vcvt_f32_f64(v95), v98);
      v160[0].f64[1] = v99;
      RBDrawingStateGetDeviceClipBoundingBox(*(void *)(a1 + 440));
      v101.f64[1] = v100;
      v103.f64[1] = v102;
      RB::Rect::intersect((float32x2_t *)v160, COERCE_DOUBLE(vcvt_f32_f64(v101)), vcvt_f32_f64(v103), v103.f64[0], v102, v104, v105);
      RB::Bounds::Bounds(&v157, *(float32x2_t *)&v160[0].f64[0], *(float32x2_t *)&v160[0].f64[1]);
      size_t v107 = v158.i32[0];
      size_t v108 = v158.i32[1];
      if (IsColored)
      {
        uint32_t v109 = 8194;
        float v110 = (CGColorSpace *)RB::srgb_colorspace(v106);
      }
      else
      {
        float v110 = 0;
        uint32_t v109 = 7;
      }
      float v111 = CGBitmapContextCreate(0, v107, v108, 8uLL, 0, v110, v109);
      if (v111)
      {
        float32x2_t v112 = v111;
        CGContextTranslateCTM(v111, (double)-v157.i32[0], (double)-v157.i32[1]);
        int32x2_t v113 = vneg_s32(v157);
        v114.i64[0] = v113.i32[0];
        v114.i64[1] = v113.i32[1];
        v156[3] = v167;
        v156[4] = v168;
        v156[5] = vaddq_f64(v169, vcvtq_f64_s64(v114));
        CGContextSetBaseCTM();
        v177.double width = v57;
        v177.double height = v59;
        CGContextSetPatternPhase(v112, v177);
        CGPoint v115 = (RB *)CGContextSetCompositeOperation();
        if (IsColored) {
          CGFloat v116 = 0;
        }
        else {
          CGFloat v116 = (CGColorSpace *)RB::srgb_colorspace(v115);
        }
        int32x2_t v117 = CGColorSpaceCreatePattern(v116);
        float32x4_t v118 = CGColorCreateWithPattern(v117, v9, RB::ContextDelegate::set_color_in_shape(CGColor *,CGGState *,CGRenderingState *,BOOL)::components);
        CGContextSetFillColorWithColor(v112, v118);
        v119.i32[0] = 0;
        uint32x2_t v120 = (uint32x2_t)vceq_s32(v158, (int32x2_t)0x8000000080000000);
        int8x8_t v121 = (int8x8_t)vdup_lane_s32(vcgt_s32(v119, (int32x2_t)vpmin_u32(v120, v120)), 0);
        int8x8_t v122 = (int8x8_t)vdup_n_s32(0x7F7FFFFFu);
        int8x8_t v123 = vbsl_s8(v121, v122, (int8x8_t)vcvt_f32_s32(v158));
        int8x8_t v124 = vbsl_s8(v121, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v157));
        v179.origin.double x = *(float *)v124.i32;
        v179.origin.double y = *(float *)&v124.i32[1];
        v179.size.double width = *(float *)v123.i32;
        v179.size.double height = *(float *)&v123.i32[1];
        CGContextFillRect(v112, v179);
        v125.i32[0] = 0;
        uint32x2_t v126 = (uint32x2_t)vceq_s32(v158, (int32x2_t)0x8000000080000000);
        int8x8_t v127 = (int8x8_t)vdup_lane_s32(vcgt_s32(v125, (int32x2_t)vpmin_u32(v126, v126)), 0);
        float32x2_t v128 = (float32x2_t)vbsl_s8(v127, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v157));
        float32x2_t v129 = (float32x2_t)vbsl_s8(v127, v122, (int8x8_t)vcvt_f32_s32(v158));
        float v130 = -v129.f32[1];
        v128.i32[1] = vadd_f32(v128, v129).i32[1];
        *(double *)&unint64_t v131 = v129.f32[0];
        v132.f64[0] = 0.0;
        v132.f64[1] = v130;
        float64x2_t v164 = (float64x2_t)v131;
        float64x2_t v165 = v132;
        float64x2_t v166 = vcvtq_f64_f32(v128);
        float64x2_t v173 = v170;
        float64x2_t v174 = v171;
        v175[0] = v172;
        BOOL v133 = RB::AffineTransform::invert((RB::AffineTransform *)&v173);
        if (v133) {
          unint64_t v134 = &v173;
        }
        else {
          unint64_t v134 = &v170;
        }
        float64x2_t v135 = *v134;
        unsigned __int32 v136 = &v174;
        if (!v133) {
          unsigned __int32 v136 = &v171;
        }
        float64x2_t v137 = *v136;
        uint64_t v138 = &v172;
        if (v133) {
          uint64_t v138 = (float64x2_t *)v175;
        }
        float64x2_t v139 = *v138;
        float64x2_t v161 = v135;
        float64x2_t v162 = v137;
        float64x2_t v163 = v139;
        v140.f64[0] = RB::operator*(&v164, &v161);
        float64x2_t v164 = v140;
        float64x2_t v165 = v141;
        float64x2_t v166 = v142;
        CGImageRef v143 = CGBitmapContextCreateImage(v112);
        float32x4_t v144 = *(void **)(a1 + 16);
        v156[0] = v164;
        v156[1] = v165;
        v156[2] = v166;
        LODWORD(v145) = v48;
        *(float *)&double v146 = v55;
        objc_msgSend(v144, "setImage:transform:interpolation:tintColor:flags:", v143, v156, 1, IsColored ^ 1u, COERCE_DOUBLE(__PAIR64__(HIDWORD(v166.f64[0]), v46)), COERCE_DOUBLE(__PAIR64__(HIDWORD(v165.f64[0]), v47)), v145, v146);
        if (a5)
        {
          float32x4_t v147 = *(__n128 **)(a1 + 440);
          uint64_t v148 = *(void *)(a1 + 8);
          int8x8_t v149 = *(RBFill **)(a1 + 16);
          CGGStateGetAlpha();
          float v151 = v150;
          if (!*(void *)(a1 + 360)) {
            float v151 = *(float *)(a1 + 456) * v151;
          }
          unsigned int v152 = CGGStateGetCompositeOperation();
          if (v152 > 0x1B) {
            unsigned int v153 = 0;
          }
          else {
          RBDrawingStateDrawShape(v147, v148, v149, v153, v151);
          }
        }
        if (v143) {
          CFRelease(v143);
        }
        if (v118) {
          CFRelease(v118);
        }
        if (v117) {
          CFRelease(v117);
        }
        CFRelease(v112);
      }
    }
  }
  else
  {
    objc_msgSend(*(id *)(a1 + 16), "setColor:", RBColorFromCGColor2(color, *(_DWORD *)(a1 + 528)));
    if (a5)
    {
      int v38 = *(__n128 **)(a1 + 440);
      uint64_t v39 = *(void *)(a1 + 8);
      long long v40 = *(RBFill **)(a1 + 16);
      CGGStateGetAlpha();
      float v42 = v41;
      if (!*(void *)(a1 + 360)) {
        float v42 = *(float *)(a1 + 456) * v42;
      }
      unsigned int v43 = CGGStateGetCompositeOperation();
      if (v43 > 0x1B) {
        unsigned int v44 = 0;
      }
      else {
      RBDrawingStateDrawShape(v38, v39, v40, v44, v42);
      }
    }
  }
}

void sub_21411A504(_Unwind_Exception *a1)
{
  if (v1)
  {
    CFRelease(v1);
    if (!v3) {
      goto LABEL_6;
    }
  }
  else if (!v3)
  {
LABEL_6:
    CFRelease(v2);
    _Unwind_Resume(a1);
  }
  CFRelease(v3);
  goto LABEL_6;
}

float32x4_t RBColorFromComponents2(CGColorSpace *a1, float64x2_t *a2, unsigned int a3)
{
  CFStringRef Name = CGColorSpaceGetName(a1);
  if (Name)
  {
    {
      CFStringRef v33 = Name;
      CFStringRef Name = v33;
      if (v23)
      {
        uint64_t v24 = *MEMORY[0x263F00238];
        RBColorFromComponents2::named_spaces[0] = *MEMORY[0x263F002D8];
        *(void *)algn_26ACDE2F8 = v24;
        word_26ACDE300 = 769;
        uint64_t v25 = *MEMORY[0x263F00230];
        qword_26ACDE308 = *MEMORY[0x263F002C8];
        unk_26ACDE310 = v25;
        word_26ACDE318 = 768;
        uint64_t v26 = *MEMORY[0x263F00200];
        qword_26ACDE320 = *MEMORY[0x263F001E8];
        unk_26ACDE328 = v26;
        word_26ACDE330 = 771;
        uint64_t v27 = *MEMORY[0x263F00218];
        qword_26ACDE338 = *MEMORY[0x263F002B0];
        unk_26ACDE340 = v27;
        word_26ACDE348 = 770;
        uint64_t v28 = *MEMORY[0x263F00208];
        qword_26ACDE350 = *MEMORY[0x263F00250];
        unk_26ACDE358 = v28;
        word_26ACDE360 = 257;
        uint64_t v29 = *MEMORY[0x263F00220];
        qword_26ACDE368 = *MEMORY[0x263F002B8];
        unk_26ACDE370 = v29;
        word_26ACDE378 = 256;
        CFStringRef Name = v33;
      }
    }
    uint64_t v8 = 0;
    while (Name != (CFStringRef)RBColorFromComponents2::named_spaces[v8]
         && Name != (CFStringRef)RBColorFromComponents2::named_spaces[v8 + 1])
    {
      v8 += 3;
      if (v8 == 18) {
        goto LABEL_7;
      }
    }
    int v11 = BYTE1(RBColorFromComponents2::named_spaces[v8 + 2]);
    if (v11 == 3)
    {
      *(float32x2_t *)v7.f32 = vcvt_f32_f64(*a2);
      float32_t v19 = a2[1].f64[0];
      v7.f32[2] = v19;
      float32x4_t v32 = v7;
    }
    else
    {
      if (v11 != 1) {
        abort();
      }
      int32x2_t v12 = *(int32x2_t *)&a2->f64[0];
      *(float *)v12.i32 = a2->f64[0];
      float32x4_t v32 = (float32x4_t)vdupq_lane_s32(v12, 0);
    }
    long long v18 = (RB::Shader::Tables *)LOBYTE(RBColorFromComponents2::named_spaces[v8 + 2]);
  }
  else
  {
LABEL_7:
    {
      if (v30)
      {
        uint64_t v31 = RB::extended_linear_srgb_colorspace(v30);
        RBColorFromComponents2::CGAffineTransform transform = MEMORY[0x216699820](v31, 0);
      }
    }
    if (CGColorTransformConvertColorComponents())
    {
      *(float32x2_t *)v9.f32 = vcvt_f32_f64(v34);
      float32_t v10 = v35;
      v9.f32[2] = v10;
      float32x4_t v32 = v9;
    }
    else
    {
      __asm { FMOV            V0.4S, #1.0 }
      float32x4_t v32 = _Q0;
    }
    CGColorSpaceGetNumberOfComponents(a1);
    long long v18 = 0;
  }
  __int16 v20 = rb_color_space(a3);
  if ((v20 & 0xFF00) != 0) {
    unsigned __int8 v21 = v20;
  }
  else {
    unsigned __int8 v21 = 1;
  }
  if (v18 != v21) {
    return vcvtq_f32_f16(COERCE_FLOAT16X4_T(RB::Fill::Color::convert_color(v18, v21, (uint16x4_t)vcvt_f16_f32(v32))));
  }
  return v32;
}

void sub_21411A880(_Unwind_Exception *a1)
{
}

double RBColorFromCGColor2(CGColor *a1, unsigned int a2)
{
  ColorSpace = CGColorGetColorSpace(a1);
  Components = (float64x2_t *)CGColorGetComponents(a1);
  *(void *)&double result = RBColorFromComponents2(ColorSpace, Components, a2).u64[0];
  return result;
}

void sub_21411AAB0(_Unwind_Exception *exception_object)
{
  if (v1 >= 0x201) {
    free(v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::CGContext::add_soft_mask<RB::CGContext::update_state_slow(RB::AffineTransform const*,RB::DisplayList::ClipNode const*,float,RB::BlendMode,RB::Bounds const&,BOOL)::$_0>(RB::CGContext::SoftMaskMode,RB::Rect,RB::CGContext::update_state_slow(RB::AffineTransform const*,RB::DisplayList::ClipNode const*,float,RB::BlendMode,RB::Bounds const&,BOOL)::$_0 const&)::{lambda(RB::CGContext&,void const*)#1}::__invoke(uint64_t result, void *a2)
{
  unint64_t v2 = (void *)*a2;
  if (*a2)
  {
    uint64_t v3 = result;
    do
    {
      unint64_t v4 = (unsigned char *)(v2[1] & 0xFFFFFFFFFFFFFFFELL);
      if (v4[44] == 1)
      {
        _S0 = (*(float (**)(unint64_t))(*(void *)v4 + 104))(v2[1] & 0xFFFFFFFFFFFFFFFELL);
        __asm { FCVT            H0, S0 }
        int v10 = 0;
        __int16 v11 = 0;
        __int16 v12 = LOWORD(_S0);
        __int16 v13 = 0;
        double result = (*(uint64_t (**)(unsigned char *, uint64_t, int *))(*(void *)v4 + 96))(v4, v3, &v10);
      }
      unint64_t v2 = (void *)*v2;
    }
    while (v2);
  }
  return result;
}

float RB::DisplayList::GenericClip<RB::Coverage::Path>::cg_alpha(uint64_t a1)
{
  return *(float *)(a1 + 88);
}

void RB::DisplayList::GenericClip<RB::Coverage::Path>::fill(uint64_t a1, CGContextRef *a2, RB::Fill::Color *a3)
{
  memset(&v10, 0, sizeof(v10));
  float64x2_t v6 = *(float64x2_t **)(a1 + 48);
  int64x2_t v7 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v6[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v6, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v6[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v7, 1), (int8x16_t)v7).u64[0] & 0x8000000000000000) != 0)
  {
    RB::Coverage::Path::fill((RB::Coverage::Path *)(a1 + 56), a2, a3);
  }
  else
  {
    CGContextGetCTM(&v10, *a2);
    uint64_t v8 = *a2;
    float64x2_t v9 = v6[1];
    *(float64x2_t *)&transform.a = *v6;
    *(float64x2_t *)&transform.c = v9;
    *(float64x2_t *)&transform.tdouble x = v6[2];
    CGContextConcatCTM(v8, &transform);
    RB::Coverage::Path::fill((RB::Coverage::Path *)(a1 + 56), a2, a3);
    CGAffineTransform transform = v10;
    CGContextSetCTM();
  }
}

double RB::Fill::Gradient::fill(RB::CGContext &,RB::Bounds)const::$_0::operator()(uint64_t *a1, uint64_t a2, __int16 a3, double a4)
{
  float v4 = *(float *)&a4;
  uint64_t v35 = a2;
  __int16 v36 = a3;
  RB::Fill::Color::convert((uint64_t)&v35, *((unsigned __int8 *)a1 + 16), *(uint16x4_t *)&a4);
  float64x2_t v6 = (void *)a1[1];
  double v7 = v4;
  uint64_t v8 = v6[1];
  unint64_t v9 = v8 + 1;
  if (v6[2] < (unint64_t)(v8 + 1))
  {
    RB::vector<unsigned long,0ul,unsigned long>::reserve_slow(a1[1], v9);
    uint64_t v8 = v6[1];
    unint64_t v9 = v8 + 1;
  }
  *(double *)(*v6 + 8 * v8) = v7;
  v6[1] = v9;
  CGAffineTransform v10 = (void *)*a1;
  _H0 = v35;
  __asm { FCVT            D8, H0 }
  uint64_t v18 = *(void *)(*a1 + 8);
  unint64_t v17 = *(void *)(*a1 + 16);
  unint64_t v19 = v18 + 1;
  if (v17 < v18 + 1)
  {
    RB::vector<unsigned long,0ul,unsigned long>::reserve_slow(*a1, v19);
    uint64_t v18 = v10[1];
    __int16 v20 = (void *)*a1;
    unint64_t v17 = *(void *)(*a1 + 16);
    unint64_t v19 = v18 + 1;
  }
  else
  {
    __int16 v20 = (void *)*a1;
  }
  *(void *)(*v10 + 8 * v18) = _D8;
  v10[1] = v19;
  _H0 = WORD1(v35);
  __asm { FCVT            D8, H0 }
  uint64_t v23 = v20[1];
  unint64_t v24 = v23 + 1;
  if (v17 < v23 + 1)
  {
    RB::vector<unsigned long,0ul,unsigned long>::reserve_slow((uint64_t)v20, v24);
    uint64_t v23 = v20[1];
    uint64_t v25 = (void *)*a1;
    unint64_t v17 = *(void *)(*a1 + 16);
    unint64_t v24 = v23 + 1;
  }
  else
  {
    uint64_t v25 = v20;
  }
  *(void *)(*v20 + 8 * v23) = _D8;
  v20[1] = v24;
  _H0 = WORD2(v35);
  __asm { FCVT            D8, H0 }
  uint64_t v28 = v25[1];
  unint64_t v29 = v28 + 1;
  if (v17 < v28 + 1)
  {
    RB::vector<unsigned long,0ul,unsigned long>::reserve_slow((uint64_t)v25, v29);
    uint64_t v28 = v25[1];
    float64x2_t v30 = (void *)*a1;
    unint64_t v17 = v30[2];
    unint64_t v29 = v28 + 1;
  }
  else
  {
    float64x2_t v30 = v25;
  }
  *(void *)(*v25 + 8 * v28) = _D8;
  v25[1] = v29;
  _H8 = HIWORD(v35);
  uint64_t v32 = v30[1];
  unint64_t v33 = v32 + 1;
  if (v17 < v32 + 1)
  {
    RB::vector<unsigned long,0ul,unsigned long>::reserve_slow((uint64_t)v30, v33);
    uint64_t v32 = v30[1];
    unint64_t v33 = v32 + 1;
  }
  __asm { FCVT            D0, H8 }
  *(double *)(*v30 + 8 * v32) = result;
  v30[1] = v33;
  return result;
}

void *RB::vector<unsigned long,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1) <= a2) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1);
  }
  double result = RB::details::realloc_vector<unsigned long,8ul>(*(void **)a1, (size_t *)(a1 + 16), v3);
  *(void *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,8ul>(void *a1, size_t *a2, uint64_t a3)
{
  float v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(8 * a3);
    size_t v6 = v5 >> 3;
    if (v5 >> 3 != *a2)
    {
      double v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7) {
        RB::precondition_failure((RB *)"allocation failure", v8);
      }
      float v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

void RB::Fill::Color::mix(uint64_t a1, uint64_t a2, int a3, float a4)
{
  *(float *)v4.i32 = 1.0 - a4;
  *(float *)&v4.i32[1] = a4;
  RB::Fill::Color::mix(a1, a2, a3, v4, (int8x8_t)v4);
}

void RB::Fill::Color::mix(uint64_t a1, uint64_t a2, int a3, uint16x4_t a4, int8x8_t _D1)
{
  _D16 = a4;
  if (!*(unsigned char *)(a1 + 9) || !*(unsigned char *)(a2 + 9))
  {
    short float v15 = *(short float *)(a1 + 6);
    short float v16 = *(short float *)(a2 + 6);
    float16x4_t v17 = *(float16x4_t *)a1;
    double v18 = *(double *)a1;
    *((short float *)&v18 + 3) = v15;
    float16x4_t v19 = *(float16x4_t *)a2;
    double v20 = *(double *)a2;
    *((short float *)&v20 + 3) = v16;
    float16x4_t v21 = *(float16x4_t *)a1;
    v21.i16[3] = COERCE_UNSIGNED_INT(1.0);
    double v22 = COERCE_DOUBLE(vmul_lane_f16(v21, *(float16x4_t *)&v18, 3));
    v19.i16[3] = COERCE_UNSIGNED_INT(1.0);
    double v23 = COERCE_DOUBLE(vmul_lane_f16(v19, *(float16x4_t *)&v20, 3));
    if (v15 == v16)
    {
      double v23 = v20;
      *(double *)&float16x4_t v24 = v18;
    }
    else
    {
      *(double *)&float16x4_t v24 = v22;
    }
    __asm { FCVT            H7, S16 }
    _S2 = _D16.i32[1];
    __asm { FCVT            H2, S2 }
    int8x8_t v27 = (int8x8_t)vmla_n_f16(vmul_n_f16(*(float16x4_t *)&v23, *(short float *)&_S2), v24, _H7);
    _ZF = v15 == v16;
    int8x8_t v28 = v27;
    if (!_ZF)
    {
      __asm { FCMP            H5, #0 }
      _ZF = _ZF || _H5 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0));
      int8x8_t v28 = v27;
      if (!_ZF)
      {
        short float v31 = COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)) / _H5;
        *(short float *)v28.i16 = v31 * *(short float *)v27.i16;
        int8x8_t v28 = vext_s8(vext_s8(v28, v28, 2uLL), (int8x8_t)vmul_n_f16((float16x4_t)vext_s8(v27, (int8x8_t)v17, 2uLL), v31), 6uLL);
      }
    }
    v17.i16[3] = *(_WORD *)(a1 + 6);
    v28.i16[3] = v27.i16[3];
    int8x8_t v32 = vbsl_s8((int8x8_t)vceq_f16(v17, (float16x4_t)0xF800F800F800F800), (int8x8_t)v17, v28);
    goto LABEL_55;
  }
  int v8 = *(unsigned __int8 *)(a2 + 8);
  if (*(unsigned __int8 *)(a1 + 8) != v8
    || *(short float *)a1 != *(short float *)a2
    || *(short float *)(a1 + 2) != *(short float *)(a2 + 2)
    || *(short float *)(a1 + 4) != *(short float *)(a2 + 4))
  {
    int v33 = 0;
    switch(a3)
    {
      case 0:
        int v33 = 0;
        break;
      case 1:
        int v33 = 0;
        v8 |= 1u;
        break;
      case 2:
        goto LABEL_24;
      case 3:
        int v33 = 1;
LABEL_24:
        v8 &= 0xFEu;
        break;
      default:
        int v33 = 0;
        int v8 = 0;
        break;
    }
    a4.i16[0] = *(_WORD *)a1;
    a4.i16[2] = *(_WORD *)(a1 + 2);
    unsigned __int16 v34 = *(_WORD *)(a1 + 4);
    uint64_t v35 = *(unsigned __int16 *)(a1 + 6);
    unsigned int v36 = *(unsigned __int16 *)(a1 + 8);
    uint16x4_t v78 = _D16;
    if (v36 >= 0x100)
    {
      if (v8 == v36) {
        goto LABEL_29;
      }
      a4.i16[1] = *(_WORD *)(a1 + 2);
      a4.i16[2] = *(_WORD *)(a1 + 4);
      double v37 = RB::Fill::Color::convert_color((RB::Shader::Tables *)*(_WORD *)(a1 + 8), v8, a4);
      _D16 = v78;
      unsigned __int16 v34 = WORD2(v37);
      a4 = (uint16x4_t)vmovl_u16(*(uint16x4_t *)&v37).u64[0];
    }
    LOWORD(v36) = v8 | 0x100;
LABEL_29:
    unint64_t v38 = a4.u16[0] | ((unint64_t)a4.u16[2] << 16) | (v35 << 48) | ((unint64_t)v34 << 32);
    unint64_t v82 = v38;
    unsigned __int16 v83 = v36;
    a4.i16[0] = *(_WORD *)a2;
    a4.i16[2] = *(_WORD *)(a2 + 2);
    unsigned __int16 v39 = *(_WORD *)(a2 + 4);
    uint64_t v40 = *(unsigned __int16 *)(a2 + 6);
    unsigned int v41 = *(unsigned __int16 *)(a2 + 8);
    if (v41 >= 0x100)
    {
      if (v8 == v41) {
        goto LABEL_33;
      }
      a4.i16[1] = *(_WORD *)(a2 + 2);
      a4.i16[2] = *(_WORD *)(a2 + 4);
      double v42 = RB::Fill::Color::convert_color((RB::Shader::Tables *)*(_WORD *)(a2 + 8), v8, a4);
      _D16 = v78;
      unsigned __int16 v39 = WORD2(v42);
      a4 = (uint16x4_t)vmovl_u16(*(uint16x4_t *)&v42).u64[0];
    }
    LOWORD(v41) = v8 | 0x100;
LABEL_33:
    unint64_t v43 = a4.u16[0] | ((unint64_t)a4.u16[2] << 16) | (v40 << 48) | ((unint64_t)v39 << 32);
    unint64_t v80 = v43;
    __int16 v81 = v41;
    if (v33)
    {
      RB::Fill::Color::convert_to_oklab((RB::Fill::Color *)&v82);
      double v44 = RB::Fill::Color::convert_to_oklab((RB::Fill::Color *)&v80);
      float16x4_t v46 = (float16x4_t)v82;
      float16x4_t v47 = (float16x4_t)v82;
      v47.i16[3] = HIWORD(v82);
      float16x4_t v48 = (float16x4_t)v80;
      float16x4_t v49 = (float16x4_t)v80;
      v49.i16[3] = HIWORD(v80);
      v46.i16[3] = COERCE_UNSIGNED_INT(1.0);
      double v50 = COERCE_DOUBLE(vmul_lane_f16(v46, v47, 3));
      v48.i16[3] = COERCE_UNSIGNED_INT(1.0);
      double v51 = COERCE_DOUBLE(vmul_lane_f16(v48, v49, 3));
      if (*((short float *)&v82 + 3) == *((short float *)&v80 + 3))
      {
        double v51 = *(double *)&v49;
        double v50 = *(double *)&v47;
      }
      _S6 = v78.i32[0];
      __asm { FCVT            H4, S6 }
      _S6 = v78.i32[1];
      __asm { FCVT            H6, S6 }
      float16x4_t v55 = vmla_n_f16(vmul_n_f16(*(float16x4_t *)&v51, *(short float *)&_S6), *(float16x4_t *)&v50, _H4);
      if (*((short float *)&v82 + 3) != *((short float *)&v80 + 3))
      {
        __asm { FCMP            H1, #0 }
        if (!_ZF && *(short float *)_D1.i16 != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
        {
          *(short float *)&double v44 = COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)) / *(short float *)_D1.i16;
          *(short float *)_D1.i16 = *(short float *)&v44 * *(short float *)v55.i16;
          int8x8_t v57 = vext_s8(vext_s8(_D1, _D1, 2uLL), (int8x8_t)vmul_n_f16((float16x4_t)vext_s8((int8x8_t)v55, *(int8x8_t *)&v44, 2uLL), *(short float *)&v44), 6uLL);
          v57.i16[3] = v55.i16[3];
          float16x4_t v55 = (float16x4_t)v57;
        }
      }
      _D0 = vmul_f16(v55, vmul_f16(v55, v55));
      _H3 = -15714;
      __asm { FMLA            H1, H3, V0.H[1] }
      _H3 = 13156;
      __asm { FMLA            H1, H3, V0.H[2] }
      float16x4_t v63 = vmul_f16((float16x4_t)vext_s8((int8x8_t)_D0, (int8x8_t)_D0, 2uLL), (float16x4_t)1054194081);
      float16x4_t v64 = (float16x4_t)vdup_lane_s16((int16x4_t)v63, 0);
      v64.i16[0] = vmulh_lane_f16(COERCE_SHORT_FLOAT(16696), _D0, 1);
      v63.i16[0] = vmulh_lane_f16(COERCE_SHORT_FLOAT(-19082), _D0, 2);
      int16x4_t v65 = (int16x4_t)vmovl_u16((uint16x4_t)vadd_f16(vmla_n_f16(v64, (float16x4_t)2622274835, *(short float *)_D0.i16), v63)).u64[0];
      LOBYTE(v36) = v83;
      v55.i16[0] = _H1;
      *(__int32 *)((char *)v55.i32 + 2) = vuzp1_s16(v65, v65).u32[0];
      if (v83 < 0x100u) {
        goto LABEL_54;
      }
    }
    else
    {
      _D1.i16[1] = WORD1(v35);
      float16x4_t v66 = (float16x4_t)v38;
      float16x4_t v67 = (float16x4_t)v43;
      float16x4_t v68 = (float16x4_t)v38;
      v68.i16[3] = v35;
      float16x4_t v69 = (float16x4_t)v43;
      v69.i16[3] = v40;
      v66.i16[3] = COERCE_UNSIGNED_INT(1.0);
      double v70 = COERCE_DOUBLE(vmul_lane_f16(v66, v68, 3));
      v67.i16[3] = COERCE_UNSIGNED_INT(1.0);
      double v71 = COERCE_DOUBLE(vmul_lane_f16(v67, v69, 3));
      if (*(short float *)&v35 == *(short float *)&v40)
      {
        double v71 = *(double *)&v69;
        double v70 = *(double *)&v68;
      }
      __asm { FCVT            H5, S16 }
      _S6 = _D16.i32[1];
      __asm { FCVT            H6, S6 }
      float16x4_t v55 = vmla_n_f16(vmul_n_f16(*(float16x4_t *)&v71, *(short float *)&_S6), *(float16x4_t *)&v70, _H5);
      if (*(short float *)&v35 != *(short float *)&v40)
      {
        __asm { FCMP            H1, #0 }
        if (!_ZF && *(short float *)_D1.i16 != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
        {
          *(short float *)a4.i16 = COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)) / *(short float *)_D1.i16;
          *(short float *)_D1.i16 = *(short float *)a4.i16 * *(short float *)v55.i16;
          int8x8_t v75 = vext_s8(vext_s8(_D1, _D1, 2uLL), (int8x8_t)vmul_n_f16((float16x4_t)vext_s8((int8x8_t)v55, (int8x8_t)a4, 2uLL), *(short float *)a4.i16), 6uLL);
          v75.i16[3] = v55.i16[3];
          float16x4_t v55 = (float16x4_t)v75;
        }
      }
    }
    int v76 = *(unsigned __int8 *)(a1 + 8);
    if (v76 != v36)
    {
      __int16 v79 = v55.i16[3];
      *(double *)&float16x4_t v77 = RB::Fill::Color::convert_color((RB::Shader::Tables *)v36, v76, (uint16x4_t)v55);
      v77.i16[3] = v79;
      float16x4_t v55 = v77;
    }
LABEL_54:
    int8x8_t v32 = vbsl_s8((int8x8_t)vceq_f16(*(float16x4_t *)a1, (float16x4_t)0xF800F800F800F800), *(int8x8_t *)a1, (int8x8_t)v55);
LABEL_55:
    *(int8x8_t *)a1 = v32;
    return;
  }
  short float v9 = *(short float *)(a1 + 6);
  if (v9 != COERCE_SHORT_FLOAT(-2048))
  {
    __asm { FCVT            H1, S16 }
    _S2 = _D16.i32[1];
    __asm { FCVT            H2, S2 }
    *(short float *)(a1 + 6) = (short float)(v9 * _H1) + (short float)(*(short float *)(a2 + 6) * *(short float *)&_S2);
  }
}

BOOL RB::CGContext::printing_context(RB::CGContext *this)
{
  int Type = *((_DWORD *)this + 36);
  if (Type < 0)
  {
    int Type = CGContextGetType();
    *((_DWORD *)this + 36) = Type;
  }
  return (Type - 1) < 2;
}

void *RBSymbolUpdateLayerPath(_DWORD *a1, float64x2_t *a2, char a3)
{
  uint16x4_t v4 = *(RB::Symbol::Presentation **)a1;
  uint64_t v5 = *(void *)a1 + 8;
  unsigned int v6 = *(_DWORD *)(*(void *)a1 + 848) + ~a1[2];
  if (*(void *)(*(void *)a1 + 840)) {
    uint64_t v5 = *(void *)(*(void *)a1 + 840);
  }
  double v7 = (_DWORD *)*((void *)a1 + 2);
  int v8 = *(void **)(v5 + 416 * v6 + 400);
  if (v8)
  {
    double v7 = (_DWORD *)(*v8 + 8 * *((void *)a1 + 2));
    if (v7[1] != 1) {
      goto LABEL_39;
    }
    LODWORD(v7) = *v7;
  }
  uint64_t v9 = v5 + 416 * v6;
  if (*(void *)(v9 + 376)) {
    uint64_t v10 = *(void *)(v9 + 376);
  }
  else {
    uint64_t v10 = v9 + 16;
  }
  __int16 v11 = (float32x2_t *)(v10 + 120 * v7);
  int v12 = (*(_DWORD *)(*(void *)v11 + 84) >> 18) & 3;
  switch(v12)
  {
    case 3:
      goto LABEL_39;
    case 2:
      if ((a3 & 2) == 0) {
        goto LABEL_39;
      }
      break;
    case 0:
      __int16 v13 = &RBPathEmpty;
      return *(void **)v13;
  }
  unsigned int v14 = v7;
  if (a3)
  {
    unsigned int v15 = *(_DWORD *)(v5 + 416 * v6 + 384);
    if ((int)v7 + 1 < v15)
    {
      char v16 = 0;
      int v17 = -v15;
      uint64_t v18 = (v7 + 1);
      while (2)
      {
        uint64_t v19 = 0;
        double v20 = (float *)(v10 + 32 + 120 * v18);
        while (1)
        {
          uint64_t v21 = *((void *)v20 - 4);
          if ((*(unsigned char *)(v21 + 86) & 0x40) != 0)
          {
            float v22 = *(float *)(v21 + 72) <= 0.0 ? *v20 * *(v20 - 1) : *v20;
            if (v22 > 0.0) {
              break;
            }
          }
          ++v19;
          v20 += 30;
          if (!(v17 + v18 + v19))
          {
            if ((v16 & 1) == 0) {
              goto LABEL_31;
            }
            goto LABEL_29;
          }
        }
        if (v22 != 1.0) {
          goto LABEL_39;
        }
        uint64_t v23 = v18 + v19 + 1;
        int v24 = v17 + v18 + v19;
        char v16 = 1;
        uint64_t v18 = v23;
        if (v24 != -1) {
          continue;
        }
        break;
      }
LABEL_29:
      if ((a3 & 2) != 0) {
        operator new();
      }
      goto LABEL_39;
    }
  }
LABEL_31:
  v25.f64[0] = RB::Symbol::Presentation::Layer::transform(v11, (uint64_t)v4);
  float64x2_t v38 = v25;
  float64x2_t v39 = v26;
  float64x2_t v40 = v27;
  v28.f64[0] = RB::Symbol::Glyph::Layer::content_transform(*(RB::Symbol::Glyph::Layer **)v11, &v38);
  float64x2_t v38 = v28;
  float64x2_t v39 = v29;
  float64x2_t v40 = v30;
  if (a2)
  {
    *a2 = v28;
    a2[1] = v29;
    a2[2] = v30;
    goto LABEL_33;
  }
  int64x2_t v35 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v29, (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(v28, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v30));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v35, 1), (int8x16_t)v35).u64[0] & 0x8000000000000000) == 0)
  {
LABEL_39:
    __int16 v13 = &RBPathNull;
    return *(void **)v13;
  }
LABEL_33:
  uint64_t v31 = (uint64_t)*v11;
  int v32 = (*(_DWORD *)(*(void *)v11 + 84) >> 18) & 3;
  if (v32 == 2) {
    operator new();
  }
  if (v32 != 1) {
    goto LABEL_39;
  }
  LOBYTE(v37) = 0;
  v33.i32[0] = 0;
  v33.i32[1] = *(_DWORD *)(v10 + 120 * v14 + 52);
  RB::Symbol::Glyph::Layer::copy_path(v31, &v37, (uint64_t *)&v41, v33);
  if ((_BYTE)v37) {
    RB::Symbol::Presentation::take_path(v4, &v41);
  }
  info = v41._p.info;
  RBPathRelease((uint64_t)v41._p.info, (uint64_t)v41._p.callbacks);
  return info;
}

void sub_21411B97C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, atomic_uint *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (a11)
  {
    if (atomic_fetch_add_explicit(a11 + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(atomic_uint *))(*(void *)a11 + 8))(a11);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::Symbol::Glyph::Layer::copy_path@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X1>, uint64_t *a3@<X8>, float32x2_t a4@<D0>)
{
  if ((*(_DWORD *)(a1 + 84) & 0xC0000) != 0x40000
    || *(float *)(a1 + 76) > 0.0
    || (uint32x2_t v5 = (uint32x2_t)vceq_f32(a4, (float32x2_t)0x3F80000000000000), (vpmin_u32(v5, v5).u32[0] & 0x80000000) == 0))
  {
    operator new();
  }
  if (a2) {
    *a2 = 0;
  }
  uint64_t result = RBPathRetain(**(void **)a1, *(void *)(*(void *)a1 + 8));
  *a3 = result;
  a3[1] = v7;
  return result;
}

void sub_21411BBEC(_Unwind_Exception *exception_object)
{
  if (atomic_fetch_add_explicit((atomic_uint *volatile)(v1 + 8), 0xFFFFFFFF, memory_order_release) == 1) {
    RB::Symbol::Glyph::Layer::copy_path(v1);
  }
  _Unwind_Resume(exception_object);
}

double RB::Symbol::Glyph::Layer::content_transform(RB::Symbol::Glyph::Layer *this, float64x2_t *a2)
{
  if (*((float *)this + 15) == 0.0) {
    *(void *)&double result = *(_OWORD *)&vmulq_n_f64(*a2, *((float *)this + 14));
  }
  else {
    *(void *)&double result = *(_OWORD *)&vmulq_n_f64(*a2, (float)-*((float *)this + 14));
  }
  return result;
}

void *RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1) <= a2) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1);
  }
  double result = RB::details::realloc_vector<unsigned long,24ul>(*(void **)a1, (unint64_t *)(a1 + 16), v3);
  *(void *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,24ul>(void *a1, unint64_t *a2, uint64_t a3)
{
  uint16x4_t v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(24 * a3);
    unint64_t v6 = v5 / 0x18;
    if (v5 / 0x18 != *a2)
    {
      uint64_t v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7) {
        RB::precondition_failure((RB *)"allocation failure", v8);
      }
      uint16x4_t v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

uint64_t ___ZN2RB11SurfacePool7collectEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(RB::SurfacePool **)(a1 + 32);
  *((void *)v1 + 15) = 0x7FF0000000000000;
  return RB::SurfacePool::collect(v1);
}

void RB::DisplayList::Transform::Term::~Term(RB::DisplayList::Transform::Term *this)
{
  if (*(_DWORD *)this == 3)
  {
    uint64_t v1 = (const void *)*((void *)this + 1);
    if (v1) {
      CFRelease(v1);
    }
  }
}

void RBDrawingStateEndCGContext(uint64_t a1, const char *a2, _RBDrawingState *a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  int v4 = *(_DWORD *)(v3 + 344);
  if (!v4) {
    RB::precondition_failure((RB *)"no active CGContext", a2);
  }
  uint64_t v5 = *(void *)(v3 + 336);
  if (!v5) {
    uint64_t v5 = v3 + 320;
  }
  uint64_t v6 = v5 + 16 * (v4 - 1);
  RB::ContextDelegate::end(*(RB::ContextDelegate **)(v6 + 8), a2, a3);
  RB::ContextDelegate::release_context((void *)v6);
  unsigned int v7 = *(_DWORD *)(v3 + 344) - 1;
  *(_DWORD *)(v3 + 344) = v7;
  uint64_t v8 = *(void *)(v3 + 336);
  if (!v8) {
    uint64_t v8 = v3 + 320;
  }
  uint64_t v9 = *(const void **)(v8 + 16 * v7);
  if (v9)
  {
    CFRelease(v9);
  }
}

void RB::ContextDelegate::end(RB::ContextDelegate *this, const char *a2, _RBDrawingState *a3)
{
  int v4 = (RB::XML::Document *)*((void *)this + 55);
  if (v4)
  {
    RBDrawingStateDestroy(v4, a2, a3);
    *((void *)this + 55) = 0;
  }
  *((void *)this + 54) = 0;
  uint64_t v5 = (const void *)*((void *)this + 68);
  if (v5) {
    CFRelease(v5);
  }
  *((void *)this + 68) = 0;
  *((void *)this + 69) = 0;
}

void RB::ContextDelegate::release_context(void *a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&RB::ContextDelegate::_contexts_lock);
  uint64_t v2 = RB::ContextDelegate::_contexts;
  if (!RB::ContextDelegate::_contexts) {
    operator new();
  }
  uint64_t v3 = *(void *)(RB::ContextDelegate::_contexts + 136);
  uint64_t v4 = RB::ContextDelegate::_contexts;
  if (*(void *)(RB::ContextDelegate::_contexts + 144) < (unint64_t)(v3 + 1))
  {
    RB::vector<std::pair<RB::cf_ptr<CGContext *>,RB::ContextDelegate *>,8ul,unsigned long>::reserve_slow((void *)RB::ContextDelegate::_contexts, v3 + 1);
    uint64_t v3 = *(void *)(v2 + 136);
    uint64_t v4 = RB::ContextDelegate::_contexts;
  }
  uint64_t v5 = *(void *)(v2 + 128);
  if (!v5) {
    uint64_t v5 = v2;
  }
  uint64_t v6 = (void *)(v5 + 16 * v3);
  void *v6 = 0;
  v6[1] = 0;
  ++*(void *)(v2 + 136);
  uint64_t v7 = *(void *)(v4 + 136);
  if (*(void *)(v4 + 128)) {
    uint64_t v4 = *(void *)(v4 + 128);
  }
  uint64_t v8 = v4 + 16 * v7;
  uint64_t v9 = *(void *)(v8 - 16);
  *(void *)(v8 - 16) = *a1;
  *a1 = v9;
  uint64_t v10 = *(void *)(v8 - 8);
  *(void *)(v8 - 8) = a1[1];
  a1[1] = v10;
  os_unfair_lock_unlock((os_unfair_lock_t)&RB::ContextDelegate::_contexts_lock);
}

void sub_21411C298(_Unwind_Exception *a1)
{
}

uint64_t RB::pixel_format_required_depth(RB *this, MTLPixelFormat a2)
{
  uint64_t v2 = RB::pixel_format_traits((unint64_t)this, a2);
  uint64_t v3 = *((unsigned __int16 *)v2 + 2);
  unint64_t v4 = *v2 | (unint64_t)(v3 << 32);
  unsigned int v5 = (v3 >> 2) & 3;
  if ((v4 & 0x200000000) != 0) {
    return 4;
  }
  else {
    return v5;
  }
}

void RB::SurfacePool::collect(RB::SurfacePool *this)
{
  uint64_t v88 = *MEMORY[0x263EF8340];
  double v2 = CACurrentMediaTime();
  float64x2_t v85 = 0;
  size_t v86 = 0;
  unint64_t v87 = 8;
  os_unfair_lock_lock((os_unfair_lock_t)this);
  unint64_t v3 = *((void *)this + 10);
  if (v3)
  {
    unint64_t v4 = 0;
    double v5 = INFINITY;
    do
    {
      if (*((void *)this + 9)) {
        uint64_t v6 = (char *)*((void *)this + 9);
      }
      else {
        uint64_t v6 = (char *)this + 40;
      }
      uint64_t v7 = &v6[16 * v4];
      double v9 = *((double *)v7 + 1);
      uint64_t v8 = v7 + 8;
      double v10 = v9;
      if (v2 >= v9)
      {
        uint64_t v11 = *(void *)&v6[16 * v4];
        *(void *)&v6[16 * v4] = 0;
        int v12 = (char *)*((void *)this + 9);
        if (!v12) {
          int v12 = (char *)this + 40;
        }
        unint64_t v13 = v3 - 1;
        unsigned int v14 = (double *)&v12[16 * v13];
        uint64_t v15 = 16 * v13;
        *(double *)&v6[16 * v4] = *v14;
        *unsigned int v14 = 0.0;
        *uint64_t v8 = *((void *)v14 + 1);
        v14[1] = v10;
        *((void *)this + 10) = v13;
        char v16 = (char *)*((void *)this + 9);
        if (!v16) {
          char v16 = (char *)this + 40;
        }
        int v17 = *(const void **)&v16[v15];
        if (v17) {
          CFRelease(v17);
        }
        uint64_t v18 = *((void *)this + 3);
        if (v18)
        {
          uint64_t v19 = (uint64_t *)*((void *)this + 2);
          double v20 = &v19[v18];
          do
          {
            uint64_t v21 = *v19;
            unint64_t v22 = *(void *)(*v19 + 104);
            if (v22)
            {
              unint64_t v23 = 0;
              do
              {
                uint64_t v24 = *(void *)(v21 + 96);
                if (!v24) {
                  uint64_t v24 = v21 + 64;
                }
                float64x2_t v25 = (void *)(v24 + 16 * v23);
                if (*v25 == v11)
                {
                  uint64_t v26 = v24 + 16 * v22;
                  uint64_t v27 = v25[1];
                  uint64_t v28 = *(void *)(v26 - 8);
                  *float64x2_t v25 = *(void *)(v26 - 16);
                  v25[1] = v28;
                  *(void *)(v26 - 16) = v11;
                  *(void *)(v26 - 8) = v27;
                  uint64_t v21 = *v19;
                  unint64_t v22 = *(void *)(*v19 + 104) - 1;
                  *(void *)(*v19 + 104) = v22;
                }
                else
                {
                  ++v23;
                }
              }
              while (v23 < v22);
            }
            ++v19;
          }
          while (v19 != v20);
        }
        size_t v29 = v86;
        size_t v30 = v86 + 1;
        if (v87 < v86 + 1)
        {
          RB::vector<RBDevice *,8ul,unsigned long>::reserve_slow(__dst, v30);
          size_t v29 = v86;
          size_t v30 = v86 + 1;
        }
        uint64_t v31 = v85;
        if (!v85) {
          uint64_t v31 = __dst;
        }
        size_t v86 = v30;
        *(void *)&v31[8 * v29] = v11;
        unint64_t v3 = *((void *)this + 10);
      }
      else
      {
        if (v10 < v5) {
          double v5 = v10;
        }
        ++v4;
      }
    }
    while (v4 < v3);
  }
  else
  {
    double v5 = INFINITY;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this);
  int v32 = v85;
  if (v85) {
    float32x2_t v33 = v85;
  }
  else {
    float32x2_t v33 = __dst;
  }
  if (v86)
  {
    uint64_t v34 = 8 * v86;
    do
    {
      CAImageQueueInvalidate();
      v33 += 8;
      v34 -= 8;
    }
    while (v34);
    int v32 = v85;
    size_t v35 = v86;
    unsigned int v36 = v85 ? v85 : __dst;
    if (v86)
    {
      size_t v37 = 0;
      do
      {
        float64x2_t v38 = (const void *)v36[v37];
        if (v38)
        {
          CFRelease(v38);
          size_t v35 = v86;
        }
        ++v37;
      }
      while (v37 < v35);
      int v32 = v85;
    }
  }
  if (v32) {
    free(v32);
  }
  float64x2_t v85 = 0;
  size_t v86 = 0;
  unint64_t v87 = 8;
  os_unfair_lock_lock((os_unfair_lock_t)this);
  uint64_t v39 = *((void *)this + 3);
  float64x2_t v40 = (double *)&unk_214219000;
  if (v39)
  {
    uint64_t v41 = *((void *)this + 2);
    uint64_t v42 = v41 + 8 * v39;
    do
    {
      unint64_t v43 = *(void *)(*(void *)v41 + 120);
      if (v43 >= 2)
      {
        double v44 = v85;
        if (!v85) {
          double v44 = __dst;
        }
        if (v86)
        {
          uint64_t v45 = 8 * v86;
          while (*v44 != v43)
          {
            ++v44;
            v45 -= 8;
            if (!v45) {
              goto LABEL_61;
            }
          }
          if (v2 - *(double *)(*(void *)v41 + 128) < 1.0 && v2 + 0.1 < v5) {
            double v5 = v2 + 0.1;
          }
        }
        else
        {
LABEL_61:
          CFRetain(*(CFTypeRef *)(*(void *)v41 + 120));
          size_t v46 = v86;
          size_t v47 = v86 + 1;
          if (v87 < v86 + 1)
          {
            RB::vector<RBDevice *,8ul,unsigned long>::reserve_slow(__dst, v47);
            size_t v46 = v86;
            size_t v47 = v86 + 1;
          }
          float16x4_t v48 = v85;
          if (!v85) {
            float16x4_t v48 = __dst;
          }
          *(void *)&v48[8 * v46] = v43;
          size_t v86 = v47;
        }
      }
      v41 += 8;
    }
    while (v41 != v42);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this);
  float16x4_t v49 = v85;
  if (v85) {
    double v50 = v85;
  }
  else {
    double v50 = __dst;
  }
  if (v86)
  {
    uint64_t v51 = 8 * v86;
    do
    {
      LastUpdateHostTime = (RB *)CAImageQueueGetLastUpdateHostTime();
      double v53 = CACurrentMediaTime();
      if (v53 - RB::time_seconds(LastUpdateHostTime) > 1.0) {
        CAImageQueueConsumeUnconsumedInRange();
      }
      CAImageQueueCollect();
      v50 += 8;
      v51 -= 8;
    }
    while (v51);
    float16x4_t v49 = v85;
    size_t v54 = v86;
    if (v85) {
      float16x4_t v55 = v85;
    }
    else {
      float16x4_t v55 = __dst;
    }
    if (v86)
    {
      size_t v56 = 0;
      do
      {
        int8x8_t v57 = *(const void **)&v55[8 * v56];
        if (v57)
        {
          CFRelease(v57);
          size_t v54 = v86;
        }
        ++v56;
      }
      while (v56 < v54);
      float16x4_t v49 = v85;
    }
  }
  if (v49) {
    free(v49);
  }
  os_unfair_lock_lock((os_unfair_lock_t)this);
  unint64_t v60 = *((void *)this + 3);
  if (v60)
  {
    uint64_t v61 = 0;
    float64x2_t v62 = (uint64_t *)*((void *)this + 2);
    uint64_t v63 = 8 * v60;
    do
    {
      uint64_t v64 = *v62++;
      if (*(void *)(v64 + 120)) {
        ++v61;
      }
      v63 -= 8;
    }
    while (v63);
    *(_OWORD *)((char *)this + 136) = 0u;
    unint64_t v65 = 0;
    unint64_t v66 = 3 * v61;
    unint64_t v67 = 6 * v61;
    while (1)
    {
      uint64_t v68 = *((void *)this + 2) + 8 * v65;
      uint64_t v69 = *(void *)v68;
      if (!*(void *)(*(void *)v68 + 120))
      {
        unint64_t v72 = v60 - v61;
        if (v66 >= v72) {
          double v73 = 10.0;
        }
        else {
          double v73 = 0.2;
        }
        if (v67 < v72) {
          double v73 = 0.0;
        }
        if (*(double *)(v69 + 128) + v73 + 0.01 <= v2)
        {
          if (atomic_fetch_add_explicit((atomic_uint *volatile)(v69 + 8), 0xFFFFFFFF, memory_order_release) == 1)
          {
            __dmb(9u);
            double v58 = (RB *)(*(uint64_t (**)(uint64_t))(*(void *)v69 + 8))(v69);
          }
          uint64_t v75 = *((void *)this + 3) - 1;
          *((void *)this + 3) = v75;
          unint64_t v76 = v75 - v65;
          if (v76) {
            double v58 = (RB *)memmove((void *)v68, (const void *)(v68 + 8), 8 * v76);
          }
          goto LABEL_102;
        }
        if (!*(unsigned char *)(v69 + 140)) {
          goto LABEL_122;
        }
        if (!IOSurfaceIsInUse(*(IOSurfaceRef *)(v69 + 48)))
        {
          *(unsigned char *)(v69 + 140) = 0;
          uint64_t v69 = *(void *)v68;
LABEL_122:
          if (!*(unsigned char *)(v69 + 45))
          {
            RB::Surface::set_volatile(v69, 1u);
            uint64_t v69 = *(void *)v68;
          }
          unint64_t v77 = *((void *)this + 3) - v61;
          if (v66 >= v77) {
            double v78 = 10.0;
          }
          else {
            double v78 = 0.2;
          }
          if (v67 < v77) {
            double v78 = 0.0;
          }
          if (v78 + *(double *)(v69 + 128) < v5) {
            double v5 = v78 + *(double *)(v69 + 128);
          }
          goto LABEL_98;
        }
        int v74 = *(unsigned __int8 *)(v69 + 140);
        uint64_t v69 = *(void *)v68;
        if (!v74) {
          goto LABEL_122;
        }
        if (v2 - *(double *)(v69 + 128) < 1.0 && v2 + 0.1 < v5) {
          double v5 = v2 + 0.1;
        }
      }
LABEL_98:
      uint64_t v70 = *(void *)(v69 + 24);
      double v58 = (RB *)RB::pixel_format_bytes_per_pixel(*(RB **)(v69 + 32), v59);
      if (*(unsigned char *)(*(void *)v68 + 45)) {
        double v71 = (char *)this + 144;
      }
      else {
        double v71 = (char *)this + 136;
      }
      *(void *)v71 += (int)v70 * (uint64_t)SHIDWORD(v70) * v58;
      ++v65;
LABEL_102:
      unint64_t v60 = *((void *)this + 3);
      if (v65 >= v60)
      {
        int8x16_t v79 = *(int8x16_t *)((char *)this + 136);
        float64x2_t v40 = (double *)&unk_214219000;
        goto LABEL_133;
      }
    }
  }
  int8x16_t v79 = 0uLL;
  *(_OWORD *)((char *)this + 136) = 0u;
LABEL_133:
  *(int8x16_t *)((char *)this + 152) = vbslq_s8((int8x16_t)vcgtq_u64(*(uint64x2_t *)((char *)this + 152), (uint64x2_t)v79), *(int8x16_t *)((char *)this + 152), v79);
  if (v5 < *((double *)this + 15))
  {
    double v80 = 100000000.0;
    if (v5 - v2 >= v40[474]) {
      double v80 = (v5 - v2) * 1000000000.0;
    }
    dispatch_time_t v81 = dispatch_time(0, (uint64_t)v80);
    unint64_t v82 = *((void *)this + 1);
    v83[0] = MEMORY[0x263EF8330];
    v83[1] = 3221225472;
    v83[2] = ___ZN2RB11SurfacePool7collectEv_block_invoke;
    float64x2_t v83[3] = &__block_descriptor_40_e5_v8__0l;
    v83[4] = this;
    dispatch_after(v81, v82, v83);
    *((double *)this + 15) = v5;
  }
  if (RB::verbose_mode(v58)) {
    RB::SurfacePool::print_locked(this, 0);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this);
}

void sub_21411CA08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23)
{
  CFRelease(v24);
  os_unfair_lock_unlock(v23);
  RB::vector<RB::cf_ptr<_CAImageQueue *>,8ul,unsigned long>::~vector(&a14);
  _Unwind_Resume(a1);
}

double RB::time_seconds(RB *this)
{
  uint64_t v1 = &color_symbols(void)::flag;
  {
    uint64_t v7 = this;
    uint64_t v1 = &color_symbols(void)::flag;
    int v4 = v3;
    this = v7;
    if (v4)
    {
      mach_timebase_info(&info);
      LODWORD(v5) = info.numer;
      LODWORD(v6) = info.denom;
      *(double *)&RB::time_seconds(unsigned long long)::time_scale = (double)v5 * 0.000000001 / (double)v6;
      uint64_t v1 = &color_symbols(void)::flag;
      this = v7;
    }
  }
  return *((double *)v1 + 76) * (double)(unint64_t)this;
}

uint64_t RB::Device::make_render_pipeline_descriptor(uint64_t a1, unsigned int a2, uint64_t *a3, uint64_t *a4, void *a5, uint64_t a6, id *a7)
{
  v61[4] = *MEMORY[0x263EF8340];
  uint64_t v58 = a1;
  unsigned int v59 = a2;
  int v52 = RB::RenderState::uses_shader_blending((RB::RenderState *)&v58);
  uint64_t v11 = objc_msgSend((id)objc_msgSend(a5, "colorAttachments"), "objectAtIndexedSubscript:", 0);
  [v11 setPixelFormat:v59 & 0x3FF];
  unsigned int v13 = v59;
  if ((v59 & 0x200000) != 0)
  {
    unsigned int v14 = objc_msgSend((id)objc_msgSend(a5, "colorAttachments"), "objectAtIndexedSubscript:", 2);
    unint64_t v16 = [v11 pixelFormat];
    unint64_t v18 = v16;
    if ((v59 & 0x4000000) == 0)
    {
      uint64_t v19 = RB::pixel_format_traits(v16, v17);
      if (v19[8]) {
        unint64_t v18 = v19[8];
      }
    }
    [v14 setPixelFormat:v18];
    unsigned int v13 = v59;
    if ((v59 & 0x100000) == 0) {
      goto LABEL_3;
    }
  }
  else
  {
    unsigned int v14 = 0;
    if ((v59 & 0x100000) == 0)
    {
LABEL_3:
      uint64_t v15 = 0;
      goto LABEL_9;
    }
  }
  uint64_t v15 = objc_msgSend((id)objc_msgSend(a5, "colorAttachments"), "objectAtIndexedSubscript:", 1);
  [v15 setPixelFormat:65];
  unsigned int v13 = v59;
LABEL_9:
  unint64_t v20 = (v13 >> 10) & 0x3FF;
  uint64_t v21 = RB::pixel_format_traits(v20, v12);
  if (((*v21 | ((unint64_t)*((unsigned __int16 *)v21 + 2) << 32)) & 0x4000000000) != 0)
  {
    [a5 setStencilAttachmentPixelFormat:(v13 >> 10) & 0x3FF];
    unsigned int v13 = v59;
    unint64_t v20 = ((unint64_t)v59 >> 10) & 0x3FF;
    uint64_t v21 = RB::pixel_format_traits(v20, v22);
  }
  if (((*v21 | ((unint64_t)*((unsigned __int16 *)v21 + 2) << 32)) & 0x8000000000) != 0)
  {
    [a5 setDepthAttachmentPixelFormat:v20];
    unsigned int v13 = v59;
  }
  if ((v13 & 0x8000000) != 0)
  {
    [a5 setSupportAddingFragmentBinaryFunctions:1];
    unsigned int v13 = v59;
  }
  id v23 = (id)objc_opt_new();
  float16x4_t v49 = v15;
  double v50 = a7;
  uint64_t v55 = v58;
  unint64_t v56 = v59 | ((unint64_t)v57 << 32);
  [v23 setConstantValue:&v55 type:36 atIndex:0];
  if (a6)
  {
    uint64_t v24 = HIDWORD(v55);
    uint64_t v26 = v56;
    uint64_t v25 = HIDWORD(v56);
    v61[0] = [NSNumber numberWithUnsignedInt:v55];
    v61[1] = [NSNumber numberWithUnsignedInt:v24];
    v61[2] = [NSNumber numberWithUnsignedInt:v26];
    v61[3] = [NSNumber numberWithUnsignedInt:v25];
    RB::JSONPipelineData::set_const(a6, 0, 36, [MEMORY[0x263EFF8C0] arrayWithObjects:v61 count:4]);
  }
  if (!a3) {
    goto LABEL_31;
  }
  v54[0] = &v58;
  v54[1] = a3;
  v54[2] = a4;
  uint64_t v27 = (uint64_t *)v23;
  _OWORD v54[3] = v27;
  if (*v28)
  {
    size_t v29 = (void *)[MEMORY[0x263F128B8] functionDescriptor];
    size_t v30 = v53;
    if (!v53) {
      goto LABEL_35;
    }
    [a5 setVertexFunction:v53];
    if (a6 && *(void **)a6 != v29)
    {

      *(void *)a6 = v29;
    }
  }
  int v32 = v28[2];
  uint64_t v31 = (uint64_t)(v28 + 2);
  if (v32)
  {
    float32x2_t v33 = (void *)[MEMORY[0x263F128B8] functionDescriptor];
    uint64_t v34 = v53;
    if (v53)
    {
      [a5 setFragmentFunction:v53];
      if (a6)
      {
        size_t v35 = *(void **)(a6 + 8);
        if (v35 != v33)
        {

          *(void *)(a6 + 8) = v33;
        }
      }

      goto LABEL_30;
    }
LABEL_35:

    uint64_t v42 = 0;
    goto LABEL_69;
  }
LABEL_30:

LABEL_31:
  unsigned int v36 = v59;
  if ((v59 & 0x100000) != 0)
  {
    uint64_t v37 = 0;
    int v38 = 1;
    int v39 = 0;
    int v40 = 0;
    uint64_t v41 = v49;
    switch(v58 & 0x3F)
    {
      case 0:
      case 1:
        int v40 = 0;
        int v39 = 1;
        uint64_t v37 = 12;
        goto LABEL_44;
      case 2:
      case 3:
      case 5:
      case 6:
      case 7:
      case 8:
      case 0xBLL:
      case 0xCLL:
      case 0xDLL:
      case 0x1DLL:
      case 0x1ELL:
      case 0x1FLL:
      case 0x20:
        goto LABEL_40;
      case 4:
      case 0xALL:
        int v38 = 0;
        uint64_t v37 = 0;
        goto LABEL_40;
      case 9:
      case 0xELL:
      case 0xFLL:
      case 0x10:
      case 0x18:
      case 0x19:
      case 0x1ALL:
      case 0x1BLL:
        int v39 = 0;
        int v40 = BYTE4(v58) & 0x3F;
LABEL_34:
        uint64_t v37 = 4;
        goto LABEL_44;
      case 0x11:
        int v38 = 0;
        goto LABEL_39;
      case 0x12:
      case 0x13:
      case 0x14:
      case 0x15:
      case 0x16:
LABEL_39:
        uint64_t v37 = 4;
        goto LABEL_40;
      case 0x17:
      case 0x1CLL:
      case 0x21:
        goto LABEL_44;
      default:
        uint64_t v41 = v49;
LABEL_40:
        switch(BYTE4(v58) & 0x3F)
        {
          case 0x13:
          case 0x15:
            int v39 = 0;
            v37 |= 8uLL;
            int v40 = 19;
            break;
          case 0x14:
          case 0x16:
            int v39 = 0;
            v37 |= 8uLL;
            int v40 = 20;
            break;
          case 0x17:
            int v39 = 0;
            int v40 = 19;
            goto LABEL_34;
          default:
            int v40 = 0;
            int v39 = v38;
            break;
        }
LABEL_44:
        [v41 setWriteMask:v37];
        if (v37)
        {
          if (v52) {
            unsigned int v43 = 48;
          }
          else {
            unsigned int v43 = v40;
          }
        }
        if (v39)
        {
          unsigned int v36 = v59;
          goto LABEL_51;
        }
        [v11 setWriteMask:0];
        size_t v47 = v50;
        [v14 setWriteMask:0];
        break;
    }
  }
  else
  {
LABEL_51:
    if ((v58 & 0x20000) != 0) {
      double v44 = v14;
    }
    else {
      double v44 = v11;
    }
    if ((v58 & 0x20000) != 0) {
      uint64_t v45 = v11;
    }
    else {
      uint64_t v45 = v14;
    }
    if (v52) {
      unsigned int v46 = 48;
    }
    else {
      unsigned int v46 = BYTE4(v58) & 0x3F;
    }
    size_t v47 = v50;
    if ((v58 & 0x3F) != 0) {
      [v45 setWriteMask:0];
    }
  }
  if (a4)
  {
    unint64_t v60 = a4;
    objc_msgSend(a5, "setBinaryArchives:", objc_msgSend(MEMORY[0x263EFF8C0], "arrayWithObjects:count:", &v60, 1));
  }
  objc_msgSend(a5, "setLabel:", objc_msgSend(NSString, "stringWithUTF8String:", RB::RenderState::name((RB::RenderState *)&v58)));
  if (v47 && *v47 != v23)
  {

    *size_t v47 = v23;
  }
  uint64_t v42 = 1;
LABEL_69:

  return v42;
}

void sub_21411D108(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t RB::pixel_format_bytes_per_pixel(RB *this, MTLPixelFormat a2)
{
  double v2 = RB::pixel_format_traits((unint64_t)this, a2);
  unsigned int v3 = *((unsigned __int8 *)v2 + 6);
  if (v3 <= 1) {
    unsigned int v3 = 1;
  }
  if (*((unsigned char *)v2 + 7)) {
    return *((unsigned __int8 *)v2 + 7);
  }
  else {
    return v3;
  }
}

unsigned int *RB::pixel_format_traits(unint64_t this, MTLPixelFormat a2)
{
  if ((this & 0x80000000) != 0)
  {
    if ((this & 0xFFFFFFFF7FFFFFFFLL) < 0xD) {
                            + 40 * (this & 0xFFFFFFFF7FFFFFFFLL));
    }
    return (unsigned int *)&RB::pixel_format_traits(MTLPixelFormat)::default_traits;
  }
  if (RB::pixel_format_traits(MTLPixelFormat)::once != -1) {
    dispatch_once_f(&RB::pixel_format_traits(MTLPixelFormat)::once, 0, (dispatch_function_t)RB::pixel_format_traits(MTLPixelFormat)::$_0::__invoke);
  }
  unint64_t v3 = 124;
  double result = (unsigned int *)RB::pixel_format_traits(MTLPixelFormat)::sorted_traits;
  do
  {
    unint64_t v5 = v3 >> 1;
    unint64_t v6 = &result[10 * (v3 >> 1)];
    unsigned int v8 = *v6;
    uint64_t v7 = v6 + 10;
    v3 += ~(v3 >> 1);
    if (v8 < this) {
      double result = v7;
    }
    else {
      unint64_t v3 = v5;
    }
  }
  while (v3);
  if ((unint64_t)result >= RB::pixel_format_traits(MTLPixelFormat)::sorted_traits + 4960 || *result != this) {
    return (unsigned int *)&RB::pixel_format_traits(MTLPixelFormat)::default_traits;
  }
  return result;
}

uint64_t RB::FormattedRenderState::uber_globals(RB::RenderState *a1, uint64_t a2, int a3)
{
  *(_DWORD *)a2 = *(_DWORD *)a1;
  *(_DWORD *)(a2 + 4) = *((_DWORD *)a1 + 1) & 0x3F | (a3 << 6);
  *(_DWORD *)(a2 + 8) = *((_DWORD *)a1 + 2);
  unint64_t v5 = (unsigned int *)(a2 + 12);
  uint64_t v6 = *(void *)a1;
  unsigned int v7 = *((_DWORD *)a1 + 2);
  int v8 = RB::RenderState::uses_shader_blending(a1);
  int v10 = *(_DWORD *)a1;
  *(void *)(a2 + 16) = *(void *)(v11 + 4);
  *(_DWORD *)(a2 + 24) = *((_DWORD *)v11 + 3);
  *(_WORD *)(a2 + 28) = (unint64_t)(v10 & 0x3F) - 17 < 6;
  if (((0x7DE07C39EFuLL >> v10) & 1) != 0 && (*((_DWORD *)a1 + 1) & 0x3Fu) - 19 <= 4) {
    *(_WORD *)(a2 + 24) = 1;
  }
  return result;
}

uint64_t RB::RenderState::uses_shader_blending(RB::RenderState *this)
{
  unsigned int v1 = *(_DWORD *)this & 0x3F;
  if (v1 < 0x21 && ((0x18000000FuLL >> v1) & 1) != 0) {
    return v1 == 0;
  }
  unsigned int v2 = *((_DWORD *)this + 1) & 0x3F;
  if (v2 > 0x18 || (*((_DWORD *)this + 1) & 0x3D | 2) == 0x16 && v1 - 18 < 5) {
    return 1;
  }
  if ((*(_DWORD *)this & 0x10000) != 0) {
    goto LABEL_17;
  }
  int v4 = *(_DWORD *)this;
  unsigned int v5 = *(_DWORD *)this & 0x3F;
  if (v5 > 0x26) {
    goto LABEL_17;
  }
  if (((1 << v5) & 0x7FFF81C00CLL) != 0) {
    return 0;
  }
  if (((1 << v5) & 0x1F0) == 0) {
    goto LABEL_17;
  }
  if ((*(_DWORD *)this & 0x3C0) == 0x40) {
    return 0;
  }
  uint64_t result = 0;
  if ((v4 & 0x4000) == 0 && (v4 & 0xC00) != 0x400)
  {
LABEL_17:
    BOOL v6 = v2 >= 0x19;
    unsigned int v7 = (0x1429Bu >> v2) & 1;
    if (v6) {
      return 1;
    }
    else {
      return v7;
    }
  }
  return result;
}

uint64_t RB::anonymous namespace'::make_derived_state(unsigned int *a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t v17 = a2;
  unsigned int v18 = a3;
  *a1 = *a1 & 0xFFFFFFFC | a4 | (2 * ((BYTE4(a2) & 0x3Fu) - 21 < 2));
  if (RB::RenderState::can_discard_shape((RB::RenderState *)&v17)) {
    int v5 = 4;
  }
  else {
    int v5 = 0;
  }
  *a1 = *a1 & 0xFFFFFFFB | v5;
  if (RB::RenderState::can_discard_alpha((RB::RenderState *)&v17)) {
    int v7 = 8;
  }
  else {
    int v7 = 0;
  }
  unsigned int v8 = *a1 & 0xFFFFFFF7 | v7;
  *a1 = v8;
  unsigned int v9 = v18;
  int v10 = RB::pixel_format_traits(v18 & 0x3FF, v6);
  unint64_t v11 = *v10 | ((unint64_t)*((unsigned __int16 *)v10 + 2) << 32);
  BOOL v12 = (v11 & 0xA00000000) == 0;
  unsigned int v13 = v8 & 0xFFFFFFEF | (16 * ((v11 & 0xA00000000) != 0));
  *a1 = v13;
  int v14 = (16 * *((unsigned __int16 *)v10 + 2)) & 0x20;
  if (v12) {
    int v14 = 0;
  }
  *a1 = v14 | v13 & 0xFFFFFFDF;
  uint64_t result = RB::RenderState::reads_tables((RB::RenderState *)&v17, (v9 >> 25) & 1);
  if (result) {
    int v16 = 64;
  }
  else {
    int v16 = 0;
  }
  *a1 = v16 & 0xFFFFFFC0 | *a1 & 0x3F;
  return result;
}

BOOL RB::RenderState::can_discard_shape(RB::RenderState *this)
{
  return (*((_DWORD *)this + 1) & 0x3Fu) - 24 <= 0xFFFFFFFA && (*(_DWORD *)this & 0x3Fu) - 23 < 0xFFFFFFFA;
}

BOOL RB::RenderState::can_discard_alpha(RB::RenderState *this)
{
  return ((*((_DWORD *)this + 1) & 0x3Fu) >= 0x18 || ((0xF9029Bu >> (*((_DWORD *)this + 1) & 0x3F)) & 1) == 0)
      && (*(_DWORD *)this & 0x3Fu) - 23 < 0xFFFFFFFA;
}

uint64_t RB::anonymous namespace'::set_blend_state(void *a1, unsigned int a2, int a3)
{
  if (a2 - 25 > 0xFFFFFFE7)
  {
    uint64_t v6 = *v5;
    uint64_t v7 = v5[1];
    unsigned int v8 = v5 + 2;
    uint64_t v9 = v5[3];
    int v10 = v5 + 4;
    uint64_t v11 = v5[5];
    if (a3)
    {
      uint64_t v12 = 0;
    }
    else
    {
      uint64_t v12 = v9;
    }
    if (a3)
    {
      uint64_t v13 = 0;
    }
    else
    {
      uint64_t v13 = v11;
    }
    if (a3) {
      uint64_t v14 = v7;
    }
    else {
      uint64_t v14 = v6;
    }
    uint64_t v15 = *v8;
    uint64_t v16 = *v10;
    [a1 setBlendingEnabled:1];
    [a1 setRgbBlendOperation:v14];
    [a1 setAlphaBlendOperation:v7];
    [a1 setSourceRGBBlendFactor:v15];
    [a1 setSourceAlphaBlendFactor:v12];
    [a1 setDestinationRGBBlendFactor:v16];
    return [a1 setDestinationAlphaBlendFactor:v13];
  }
  else
  {
    return [a1 setBlendingEnabled:0];
  }
}

const char *RB::RenderState::name(RB::RenderState *this)
{
  if ((*(_DWORD *)this & 0x3Fu) > 0x27) {
    return "plane_color";
  }
  else {
    return off_2641F9B10[*(_DWORD *)this & 0x3F];
  }
}

void RB::RenderQueue::encode(unsigned int *a1, uint64_t a2)
{
  uint64_t v143 = *MEMORY[0x263EF8340];
  RB::DirectRenderCommandEncoder::reset(v119, **(void ***)(a2 + 40));
  uint64_t v117 = *(void *)(a2 + 48);
  int v118 = *(_DWORD *)(a2 + 56);
  LODWORD(v117) = v117 & 0xFFFFFFC0 | 0x27;
  int32x2_t v4 = *(int32x2_t *)(a2 + 64);
  double v104 = (int32x2_t *)(a2 + 64);
  long long v140 = 0u;
  long long v141 = 0u;
  long long v142 = 0u;
  uint64_t v138 = 0;
  uint64_t v139 = 0;
  uint64_t v137 = 0;
  if (*a1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    uint64_t v106 = 0;
    int v7 = 0;
    int v8 = 0;
    int32x4_t v98 = (void *)(a2 + 112);
    int v9 = *(unsigned __int8 *)(a2 + 131);
    int v10 = -1;
    int v100 = 1;
    int32x2_t v11 = vdup_n_s32(0xC0000001);
    int32x2_t v111 = 0;
    float64x2_t v103 = a1;
    while (1)
    {
      uint64_t v110 = v5;
      uint64_t v12 = *(unsigned int **)(*((void *)a1 + 1) + 8 * v5);
      if (v9 && (*(unsigned char *)(*(void *)a2 + 292) & 4) != 0)
      {
        [**(id **)(a2 + 40) endEncoding];
        uint64_t v13 = *(id **)(a2 + 40);

        *uint64_t v13 = 0;
        objc_msgSend((id)objc_msgSend((id)objc_msgSend(*(id *)(a2 + 24), "colorAttachments"), "objectAtIndexedSubscript:", 1), "setLoadAction:", 1);
        if (*(unsigned char *)(a2 + 130)) {
          objc_msgSend((id)objc_msgSend((id)objc_msgSend(*(id *)(a2 + 24), "colorAttachments"), "objectAtIndexedSubscript:", 2), "setLoadAction:", 1);
        }
        if (*(unsigned char *)(a2 + 128)) {
          objc_msgSend((id)objc_msgSend(*(id *)(a2 + 24), "stencilAttachment"), "setLoadAction:", 1);
        }
        if (*(unsigned char *)(a2 + 129)) {
          objc_msgSend((id)objc_msgSend(*(id *)(a2 + 24), "depthAttachment"), "setLoadAction:", 1);
        }
        id v14 = (id)[*(id *)(a2 + 16) renderCommandEncoderWithDescriptor:*(void *)(a2 + 24)];
        uint64_t v15 = *(id **)(a2 + 40);
        if (*v15 != v14)
        {

          *uint64_t v15 = v14;
          id v14 = **(id **)(a2 + 40);
        }
        RB::DirectRenderCommandEncoder::reset(v119, v14);
        if (*(void *)(a2 + 32)) {
          objc_msgSend(**(id **)(a2 + 40), "setLabel:");
        }
        int v8 = 0;
        int v7 = 0;
        uint64_t v106 = 0;
        LODWORD(v117) = v117 & 0xFFFFFFC0 | 0x27;
        int32x2_t v4 = *(int32x2_t *)(a2 + 64);
        long long v140 = 0u;
        long long v141 = 0u;
        long long v142 = 0u;
        uint64_t v138 = 0;
        uint64_t v139 = 0;
        uint64_t v137 = 0;
        *(unsigned char *)(a2 + 131) = 0;
        int32x2_t v111 = 0;
        int v100 = 1;
        int v10 = -1;
      }
      if (v12[12])
      {
        unsigned int v18 = (int32x2_t *)((unint64_t)(v12 + 14) & 0xFFFFFFFFFFFFFFF8);
        int32x2_t v19 = *v18;
        uint64_t v17 = v18 + 1;
        int32x2_t v16 = v19;
      }
      else
      {
        int32x2_t v16 = 0;
        uint64_t v17 = (int32x2_t *)(a2 + 64);
      }
      int32x2_t v20 = *v17;
      uint32x2_t v21 = (uint32x2_t)vceq_s32(v16, v111);
      if ((vpmin_u32(v21, v21).u32[0] & 0x80000000) == 0
        || (uint32x2_t v22 = (uint32x2_t)vceq_s32(v20, v4), (vpmin_u32(v22, v22).u32[0] & 0x80000000) == 0))
      {
        *(void *)&long long v23 = v16.i32[0];
        *((void *)&v23 + 1) = v16.i32[1];
        long long v24 = v23;
        int32x2_t v112 = v16;
        *(void *)&long long v23 = v20.i32[0];
        *((void *)&v23 + 1) = v20.i32[1];
        *(_OWORD *)__str = v24;
        long long v136 = v23;
        v120(v119[0], sel_setScissorRect_, __str);
        int32x2_t v4 = v20;
        int32x2_t v111 = v112;
      }
      unsigned int v25 = *((unsigned __int8 *)v12 + 45);
      unsigned int v26 = *((unsigned __int8 *)v12 + 43);
      if (v25 != v7 || v26 != v8)
      {
        uint64_t v27 = RB::Device::depth_stencil_state(*(void *)a2, v25, v26);
        v122(v119[0], sel_setDepthStencilState_, v27);
        int v7 = *((unsigned __int8 *)v12 + 45);
        int v8 = *((unsigned __int8 *)v12 + 43);
      }
      if ((_BYTE)v8 && v10 != *((unsigned __int8 *)v12 + 44))
      {
        v123(v119[0], sel_setStencilReferenceValue_);
        int v10 = *((unsigned __int8 *)v12 + 44);
      }
      int v105 = v8;
      unsigned int v28 = *v12;
      if ((*v12 & 0x3F) != 0x27) {
        break;
      }
      unint64_t v29 = (unint64_t)v12 + 49;
      if (v12[12]) {
        unint64_t v29 = ((unint64_t)(v12 + 14) & 0xFFFFFFFFFFFFFFF8) + 16;
      }
      uint64_t v30 = v29 + 12 * *((unsigned __int8 *)v12 + 47) + 8 * *((unsigned __int8 *)v12 + 46);
      uint64_t v31 = *(void *)v30;
      long long v113 = *(_OWORD *)(v30 + 16);
      long long v107 = *(_OWORD *)(v30 + 48);
      long long v108 = *(_OWORD *)(v30 + 32);
      int v32 = *(_DWORD *)(v30 + 64);
      int v33 = *(_DWORD *)(v30 + 68);
      BOOL v34 = (*(unsigned char *)(a2 + 72) & 1) == 0;
      if ((*(_DWORD *)(a2 + 56) & 0x100000) != 0) {
        unint64_t v35 = 16777619
      }
            * ((16777619
              * ((16777619 * (*(_DWORD *)(a2 + 56) & 0x3FF ^ 0x811C9DC5)) ^ ((unint64_t)*(unsigned int *)(a2 + 56) >> 10) & 0x3FF)) ^ 0x41);
      else {
        unint64_t v35 = 16777619
      }
            * ((16777619 * (*(_DWORD *)(a2 + 56) & 0x3FF ^ 0x811C9DC5)) ^ ((unint64_t)*(unsigned int *)(a2 + 56) >> 10) & 0x3FF);
      if (!v6)
      {
        uint64_t v6 = objc_opt_new();
      }
      [v6 setFlags:(v28 >> 15) & 2 | v34];
      [v6 setBlendMode:rb_blend_mode(v12[1] & 0x3F)];
      LODWORD(v36) = v32;
      [v6 setAlpha:v36];
      [v6 setCommandBuffer:*(void *)(a2 + 16)];
      [v6 setDescriptor:*(void *)(a2 + 24)];
      [v6 setFormatKey:v35];
      [v6 setEncoder:**(void **)(a2 + 40)];
      objc_msgSend(v6, "setSize:", (double)v104->i32[0], (double)(int)HIDWORD(*(unint64_t *)v104));
      *(void *)&long long v37 = v111.u32[0];
      *((void *)&v37 + 1) = v111.u32[1];
      long long v38 = v37;
      *(void *)&long long v37 = v4.u32[0];
      *((void *)&v37 + 1) = v4.u32[1];
      v116[0] = v38;
      v116[1] = v37;
      [v6 setBounds:v116];
      v115[0] = v113;
      v115[1] = v108;
      v115[2] = v107;
      int v39 = (void *)MEMORY[0x21669B110]([v6 setCTM:v115]);
      (*(void (**)(uint64_t, void *))(v31 + 16))(v31, v6);
      if ((v33 & 8) != 0)
      {
        if (![v6 encoder])
        {
          float64x2_t v97 = "drawing op didn't return render pass encoder";
LABEL_147:
          RB::precondition_failure((RB *)v97, v40);
        }
        id v72 = (id)[v6 encoder];
        double v73 = *(id **)(a2 + 40);
        if (*v73 != v72)
        {

          *double v73 = v72;
          id v72 = **(id **)(a2 + 40);
        }
        RB::DirectRenderCommandEncoder::reset(v119, v72);
      }
      else if ([v6 encoder] != **(void **)(a2 + 40))
      {
        float64x2_t v97 = "drawing op changed render pass encoder";
        goto LABEL_147;
      }
      uint64_t v106 = 0;
      long long v140 = 0u;
      long long v141 = 0u;
      long long v142 = 0u;
      uint64_t v138 = 0;
      uint64_t v139 = 0;
      uint64_t v137 = 0;
      LODWORD(v117) = v117 & 0xFFFFFFC0 | 0x27;
      int v100 = 1;
      int32x2_t v4 = (int32x2_t)0x8000000080000000;
      int v7 = 3;
      int v10 = -1;
      int v8 = 8;
      int32x2_t v111 = v11;
LABEL_112:
      int v9 = (*(unsigned char *)(a2 + 131) | *((unsigned char *)v12 + 41));
      *(unsigned char *)(a2 + 131) |= *((unsigned char *)v12 + 41);
      uint64_t v5 = v110 + 1;
      a1 = v103;
      if (v110 + 1 >= (unint64_t)*v103) {
        goto LABEL_138;
      }
    }
    int v101 = v7;
    int v102 = v10;
    uint64_t v41 = *((unsigned __int8 *)v12 + 47);
    int64x2_t v114 = v6;
    if (*((unsigned char *)v12 + 47))
    {
      uint64_t v42 = 0;
      unint64_t v43 = (unint64_t)v12 + 49;
      if (v12[12]) {
        unint64_t v43 = ((unint64_t)(v12 + 14) & 0xFFFFFFFFFFFFFFF8) + 16;
      }
      double v44 = (unsigned int *)(v43 + 4);
      uint64_t v45 = (_DWORD *)&v140 + 1;
      do
      {
        uint64_t v46 = *(v44 - 1);
        if (v46)
        {
          if (v46 == *(v45 - 1))
          {
            uint64_t v47 = *v44;
            if (v47 != *v45)
            {
              char v48 = RB::RenderQueue::encode(RB::RenderQueue::EncoderState &)::buffer_masks[v42];
              if (v48)
              {
                v126(v119[0], sel_setVertexBufferOffset_atIndex_);
                uint64_t v47 = *v44;
              }
              if ((v48 & 2) != 0)
              {
                v129(v119[0], sel_setFragmentBufferOffset_atIndex_, v47, v42);
                LODWORD(v47) = *v44;
              }
              *uint64_t v45 = v47;
            }
          }
          else
          {
            uint64_t v49 = *(void *)(*(void *)(a2 + 96) + 8 * v46 + 24);
            char v50 = RB::RenderQueue::encode(RB::RenderQueue::EncoderState &)::buffer_masks[v42];
            if (v50)
            {
              if (v49) {
                uint64_t v51 = *(void *)(v49 + 16);
              }
              else {
                uint64_t v51 = 0;
              }
              v125(v119[0], sel_setVertexBuffer_offset_atIndex_, v51, *v44, v42);
            }
            if ((v50 & 2) != 0)
            {
              if (v49) {
                uint64_t v52 = *(void *)(v49 + 16);
              }
              else {
                uint64_t v52 = 0;
              }
              v128(v119[0], sel_setFragmentBuffer_offset_atIndex_, v52, *v44, v42);
            }
            *(void *)(v45 - 1) = *(void *)(v44 - 1);
            v45[1] = v44[1];
          }
        }
        ++v42;
        v45 += 3;
        v44 += 3;
      }
      while (v41 != v42);
    }
    uint64_t v109 = *(void *)v12;
    unint64_t v53 = *(unsigned int *)(a2 + 56);
    uint64_t v54 = *((unsigned __int8 *)v12 + 46);
    if (*((unsigned char *)v12 + 46))
    {
      uint64_t v55 = 0;
      unint64_t v56 = (unint64_t)v12 + 49;
      if (v12[12]) {
        unint64_t v56 = ((unint64_t)(v12 + 14) & 0xFFFFFFFFFFFFFFF8) + 16;
      }
      unsigned int v57 = (unsigned char *)(v56 + 12 * *((unsigned __int8 *)v12 + 47) + 4);
      uint64_t v58 = (char *)&v137 + 4;
      while (1)
      {
        uint64_t v59 = *((unsigned int *)v57 - 1);
        if (!v59) {
          goto LABEL_81;
        }
        unint64_t v60 = *(void *)(*(void *)(a2 + 80) + 8 * v59 + 24) & 0xFFFFFFFFFFFFFFFELL;
        if (!v60) {
          goto LABEL_81;
        }
        if (!v55) {
          break;
        }
        if (v55 == 1)
        {
          char v61 = 24;
          uint64_t v62 = 4278190079;
LABEL_73:
          unint64_t v53 = ((((unint64_t)*(unsigned __int8 *)(v60 + 77) >> 2) & 1) << v61) | v53 & v62;
        }
        if (v59 != *((_DWORD *)v58 - 1))
        {
          v130(v119[0], sel_setFragmentTexture_atIndex_, *(id *)(v60 + 16), v55);
          int v64 = 0;
          *uint64_t v58 = 0;
          MTLPixelFormat v63 = (unint64_t)*v57;
LABEL_78:
          if (v63 != v64)
          {
            uint64_t v65 = RB::Device::sampler_state(*(void *)a2, v63, v60);
            v131(v119[0], sel_setFragmentSamplerState_atIndex_, v65, v55);
            LOBYTE(v64) = *v57;
          }
          *((_DWORD *)v58 - 1) = *((_DWORD *)v57 - 1);
          *uint64_t v58 = v64;
          goto LABEL_81;
        }
        MTLPixelFormat v63 = (unint64_t)*v57;
        int v64 = *v58;
        if (v63 != v64) {
          goto LABEL_78;
        }
LABEL_81:
        ++v55;
        v57 += 8;
        v58 += 8;
        if (v54 == v55) {
          goto LABEL_82;
        }
      }
      char v61 = 23;
      uint64_t v62 = 4286578687;
      goto LABEL_73;
    }
LABEL_82:
    uint64_t v66 = v109;
    BOOL v67 = v117 == v109 && HIDWORD(v117) == HIDWORD(v109);
    int v10 = v102;
    if (v67 && ((v118 ^ v53) & 0xFBFFFFFF) == 0)
    {
      BOOL v70 = 0;
      int v7 = v101;
      int v8 = v105;
LABEL_91:
      uint64_t v6 = v114;
      if (!v106)
      {
        if (RB::RenderState::reads_noise((RB::RenderState *)v12))
        {
          id v71 = RB::Device::noise_texture(*(RB::Device **)a2);
          v130(v119[0], sel_setFragmentTexture_atIndex_, v71, 3);
          LODWORD(v106) = 1;
        }
        else
        {
          LODWORD(v106) = 0;
        }
      }
      if (!HIDWORD(v106))
      {
        if (RB::RenderState::reads_tables((RB::RenderState *)v12, (*(unsigned char *)(a2 + 72) & 1) == 0))
        {
          uint64_t v74 = RB::Device::tables_buffer(*(RB::Device **)a2);
          v128(v119[0], sel_setFragmentBuffer_offset_atIndex_, *(void *)(v74 + 16), 0, 4);
          HIDWORD(v106) = 1;
        }
        else
        {
          HIDWORD(v106) = 0;
        }
      }
      if (*(unsigned char *)(*(void *)a2 + 292))
      {
        uint64_t v132 = v66;
        int v133 = v53;
        RB::FormattedRenderState::ID::formatted((uint64_t)&v132, (uint64_t)v134);
        uint64_t v75 = "";
        if (v70) {
          uint64_t v75 = "U/";
        }
        snprintf(__str, 0x100uLL, "Draw [%d] %s%s P:%d,%ux%u@%u S:%d,%u D:%d T:%d B:%d", v110, v75, v134, *((unsigned __int8 *)v12 + 42), v12[8], v12[7], v12[6], *((unsigned __int8 *)v12 + 43), *((unsigned __int8 *)v12 + 44), *((unsigned __int8 *)v12 + 45), *((unsigned __int8 *)v12 + 46), *((unsigned __int8 *)v12 + 47));
        unint64_t v76 = (void *)[[NSString alloc] initWithCString:__str encoding:1];
        [**(id **)(a2 + 40) insertDebugSignpost:v76];
      }
      uint64_t v77 = v12[9];
      if (v77) {
        ((void (*)(id, char *, void, void, void, void, void, void))v119[2])(v119[0], sel_drawIndexedPrimitives_indexCount_indexType_indexBuffer_indexBufferOffset_instanceCount_, *((unsigned __int8 *)v12 + 42), v12[7], 0, *(void *)(*(void *)(*(void *)(a2 + 96) + 8 * v77 + 24) + 16), v12[6], v12[8]);
      }
      else {
        ((void (*)(id, char *, void, void, void, void))v119[1])(v119[0], sel_drawPrimitives_vertexStart_vertexCount_instanceCount_, *((unsigned __int8 *)v12 + 42), v12[6], v12[7], v12[8]);
      }
      goto LABEL_112;
    }
    uint64_t v117 = v109;
    int v118 = v53;
    unint64_t v99 = v99 & 0xFFFFFFFF00000000 | v53;
    uint64_t v68 = RB::Device::render_pipeline_state(*(void *)a2, v109, v53, v98);
    int v7 = v101;
    int v8 = v105;
    uint64_t v69 = v68;
    if (v68)
    {
      BOOL v70 = *((unsigned char *)v68 + 49) != 0;
      if (*((unsigned char *)v68 + 49))
      {
        double v78 = (const char *)*(unsigned int *)(a2 + 8);
        uint64_t v79 = RB::RenderState::custom_shader_signature((RB::RenderState *)&v117);
        id v80 = RB::Device::RenderPipelineEntry::function_table(v69, v78, v98, v79);
        RB::FormattedRenderState::uber_globals((RB::RenderState *)&v117, (uint64_t)__str, v81);
        v124(v119[0], sel_setVertexBytes_length_atIndex_, __str, 32, 5);
        v127(v119[0], sel_setFragmentBytes_length_atIndex_, __str, 32, 5);
        if (*(unsigned char *)(*(void *)a2 + 287)) {
          [v119[0] setFragmentVisibleFunctionTable:v80 atBufferIndex:6];
        }
        if (v100)
        {
          uint64_t v82 = *(void *)(*(void *)(a2 + 96) + 32);
          if (v82)
          {
            uint64_t v83 = 0;
            float64x2_t v84 = (int *)&v140;
            do
            {
              int v85 = *v84;
              v84 += 3;
              if (!v85)
              {
                if ((v83 & 0x7FFFFFFFFFFFFFFELL) == 2
                  || (v125(v119[0], sel_setVertexBuffer_offset_atIndex_, *(void *)(v82 + 16), 0, v83), v83 != 1))
                {
                  v128(v119[0], sel_setFragmentBuffer_offset_atIndex_, *(void *)(v82 + 16), 0, v83);
                }
              }
              ++v83;
            }
            while (v83 != 4);
            if (!HIDWORD(v106)) {
              v128(v119[0], sel_setFragmentBuffer_offset_atIndex_, *(void *)(v82 + 16), 0, 4);
            }
          }
        }
        uint64_t v86 = 0;
        char v87 = 1;
        do
        {
          char v88 = v87;
          unint64_t v89 = (unint64_t)(&v137 + v86);
          if (!*(unsigned char *)(v89 + 4))
          {
            uint64_t v90 = RB::Device::sampler_state(*(void *)a2, (MTLPixelFormat)2uLL, 0);
            v131(v119[0], sel_setFragmentSamplerState_atIndex_, v90, v86);
            *(unsigned char *)(v89 | 4) = 2;
          }
          char v87 = 0;
          uint64_t v86 = 1;
        }
        while ((v88 & 1) != 0);
        int v7 = v101;
        uint64_t v66 = v109;
        if ((*v12 & 0x3F) == 0x21 && ((*v12 >> 6) & 7) - 3 <= 1)
        {
          unint64_t v91 = (unint64_t)v12 + 49;
          if (v12[12]) {
            unint64_t v91 = ((unint64_t)(v12 + 14) & 0xFFFFFFFFFFFFFFF8) + 16;
          }
          v130(v119[0], sel_setFragmentTexture_atIndex_, *(id *)((*(void *)(*(void *)(a2 + 80)+ 8 * *(unsigned int *)(v91 + 12 * *((unsigned __int8 *)v12 + 47))+ 24) & 0xFFFFFFFFFFFFFFFELL)+ 16), 1);
          v130(v119[0], sel_setFragmentTexture_atIndex_, 0, 0);
          LODWORD(v137) = 0;
          LODWORD(v138) = 0;
        }
        int v100 = 0;
        int v10 = v102;
      }
      *((_DWORD *)v69 + 10) = *(_DWORD *)(a2 + 12);
      v121(v119[0], sel_setRenderPipelineState_, v69[3]);
      goto LABEL_91;
    }
    uint64_t v6 = v114;
LABEL_138:
    if (v7 | v8)
    {
      uint64_t v92 = RB::Device::depth_stencil_state(*(void *)a2, 0, 0);
      v122(v119[0], sel_setDepthStencilState_, v92);
    }
    if (v10 != -1) {
      ((void (*)(id, char *, uint64_t))v123)(v119[0], sel_setStencilReferenceValue_, 0xFFFFFFFFLL);
    }
  }
  else
  {
    uint64_t v6 = 0;
    int32x2_t v111 = 0;
  }
  int32x2_t v93 = *v104;
  uint32x2_t v94 = (uint32x2_t)vceqz_s32(v111);
  if ((vpmin_u32(v94, v94).u32[0] & 0x80000000) == 0
    || (uint32x2_t v95 = (uint32x2_t)vceq_s32(v4, v93), (vpmin_u32(v95, v95).u32[0] & 0x80000000) == 0))
  {
    memset(__str, 0, sizeof(__str));
    *(void *)&long long v96 = v93.u32[0];
    *((void *)&v96 + 1) = v93.u32[1];
    long long v136 = v96;
    v120(v119[0], sel_setScissorRect_, __str);
  }
}

void sub_21411E5E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,id a51)
{
  _Unwind_Resume(a1);
}

uint64_t RB::RenderState::reads_tables(RB::RenderState *this, int a2)
{
  unsigned int v2 = *(_DWORD *)this;
  LOBYTE(v3) = 1;
  switch(*(_DWORD *)this & 0x3F)
  {
    case 0:
    case 1:
      return v3 & 1;
    case 3:
    case 7:
    case 0xD:
    case 0x15:
      int v4 = HIBYTE(v2) & 3;
      int v5 = a2 ^ 1 | HIBYTE(v2);
      if (v4 == (a2 ^ 1)) {
        LOBYTE(v3) = 0;
      }
      else {
        LOBYTE(v3) = v5;
      }
      break;
    case 6:
    case 0xC:
    case 0x13:
    case 0x14:
      int v3 = (v2 >> 20) & 1;
      break;
    case 0x1D:
    case 0x1E:
      int v3 = (v2 >> 21) & 1;
      break;
    case 0x21:
    case 0x22:
    case 0x23:
      LOBYTE(v3) = (*(_DWORD *)this & 0x1C0) == 64;
      if ((v2 & 0x700000) != 0) {
        LOBYTE(v3) = 1;
      }
      break;
    case 0x25:
      int v3 = (v2 >> 20) & 1;
      if ((v2 & 0x40) == 0) {
        LOBYTE(v3) = 0;
      }
      break;
    default:
      LOBYTE(v3) = 0;
      break;
  }
  return v3 & 1;
}

uint64_t RB::RenderState::reads_noise(RB::RenderState *this)
{
  unsigned int v1 = *(_DWORD *)this;
  int v2 = *(_DWORD *)this & 0x3F;
  uint64_t result = 1;
  switch(v2)
  {
    case 0:
    case 1:
    case 6:
    case 12:
    case 19:
    case 20:
      return result;
    case 3:
    case 7:
    case 13:
    case 21:
      uint64_t result = (v1 >> 29) & 1;
      break;
    case 8:
    case 22:
      uint64_t result = (v1 >> 20) & 1;
      break;
    case 29:
    case 30:
      uint64_t result = (v1 >> 27) & 1;
      break;
    case 31:
      uint64_t result = (v1 >> 25) & 1;
      break;
    case 33:
    case 34:
    case 35:
      uint64_t result = (v1 >> 23) & 1;
      break;
    case 36:
      uint64_t result = (v1 >> 22) & 1;
      break;
    case 37:
    case 38:
      uint64_t result = (v1 >> 6) & 1;
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t *RB::Device::render_pipeline_state(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  uint64_t v79 = *MEMORY[0x263EF8340];
  uint64_t v65 = a2;
  int v66 = a3;
  uint64_t v6 = (RB::UntypedTable *)(a1 + 432);
  int v7 = RB::UntypedTable::lookup((RB::UntypedTable *)(a1 + 432), &v65, 0);
  int v8 = v7;
  if (!v7 || !v7[3])
  {
    int v9 = (RB::_anonymous_namespace_ *)MEMORY[0x21669B110]();
    int v10 = v9;
    id v11 = 0;
    id v64 = 0;
    if (*(void *)(a1 + 48)
        ? (id v11 = 0)
        : (0, id v11 = v12),
          *(id *)(a1 + 48),
          (*(void *)(a1 + 48) = library) != 0))
    {
      if (*(unsigned char *)(a1 + 282) && !*(void *)(a1 + 56))
      {
        if (!v11)
        {
          if (bundle)
          {

            id v11 = bundle;
          }
          else
          {
            id v11 = 0;
          }
        }

        *(void *)(a1 + 56) = library_archive;
        if (!library_archive) {
          *(unsigned char *)(a1 + 282) = 0;
        }
      }
      int32x2_t v16 = (RB::_anonymous_namespace_ *)RB::RenderState::custom_shader_signature((RB::RenderState *)&v65);
      if (!v16)
      {
        uint64_t v20 = 0;
        goto LABEL_25;
      }
      uint64_t v18 = a4[1];
      if (v18)
      {
        uint64_t v19 = *a4 + 24;
        while (1)
        {
          uint64_t v20 = *(void *)v19;
          if ((*(_DWORD *)(*(void *)v19 + 4) | (8 * **(_DWORD **)v19)) == v16) {
            break;
          }
          v19 += 8;
          if (!--v18) {
            goto LABEL_22;
          }
        }
LABEL_25:
          && RB::RenderState::uber_compatible((RB::RenderState *)&v65))
        {
          if (v20 && !*(unsigned char *)(v20 + 104)) {
            goto LABEL_57;
          }
          int v68 = v66 & 0x67FFFFF | (*(unsigned __int8 *)(a1 + 287) << 27);
          long long v23 = RB::UntypedTable::lookup(v6, &v67, 0);
          uint32x2_t v21 = v23;
          if (v23)
          {
              operator new();
            *((_DWORD *)v21 + 11) = *(_DWORD *)(a1 + 192);
            goto LABEL_90;
          }
          long long v24 = objc_opt_new();
          uint64_t render_pipeline_descriptor = RB::Device::make_render_pipeline_descriptor(v67, v68, *(uint64_t **)(a1 + 48), *(uint64_t **)(a1 + 56), v24, 0, 0);
          if (render_pipeline_descriptor)
          {
            id v63 = 0;
            uint64_t v26 = *(void *)(a1 + 56);
            double v27 = RB::current_time_seconds((RB *)render_pipeline_descriptor);
            uint64_t v28 = 4 * (v26 != 0);
            uint64_t v62 = 0;
            unint64_t v29 = (void *)[*(id *)(a1 + 24) newRenderPipelineStateWithDescriptor:v24 options:v28 reflection:0 error:&v62];

            id v63 = v29;
            double v32 = RB::current_time_seconds(v30);
            if (!v26) {
            if (v63)
            }
            {
LABEL_40:
              if (RB::verbose_mode(v31))
              {
                if (v28) {
                  int v33 = "loaded";
                }
                else {
                  int v33 = "built";
                }
                BOOL v34 = RB::RenderState::name((RB::RenderState *)&v67);
                uint64_t v77 = v67;
                int v78 = v68;
                RB::FormattedRenderState::ID::formatted((uint64_t)&v77, (uint64_t)buf);
                printf("%s render pipeline %s-%s (%.2f ms)\n", v33, v34, (const char *)buf, (v32 - v27) * 1000.0);
                fflush((FILE *)*MEMORY[0x263EF8358]);
              }
              operator new();
            }
            if (*(void *)(a1 + 56))
            {
              if ((int)v31 < 2)
              {
                uint64_t v58 = v24;
              }
              else
              {
                uint64_t v58 = objc_opt_new();

                uint64_t v31 = (RB *)RB::Device::make_render_pipeline_descriptor(v67, v68, *(uint64_t **)(a1 + 48), 0, v58, 0, 0);
                if (v31)
                {
                  double v27 = RB::current_time_seconds(v31);
                  uint64_t v59 = (void *)[*(id *)(a1 + 24) newRenderPipelineStateWithDescriptor:v58 options:0 reflection:0 error:&v62];

                  id v63 = v59;
                  double v32 = RB::current_time_seconds(v60);
                }
                uint64_t v28 = 0;
              }
              if (v63) {
                goto LABEL_40;
              }
              long long v24 = v58;
            }
            if (*(unsigned char *)(a1 + 552))
            {
              std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::__emplace_unique_key_args<RB::FormattedRenderState,RB::FormattedRenderState const&>(a1 + 512, (unsigned int *)&v67, (uint64_t)&v67);
              if (v35) {
                BOOL v36 = 0;
              }
              else {
                BOOL v36 = *(unsigned char *)(a1 + 553) == 0;
              }
              char v37 = !v36;
              *(unsigned char *)(a1 + 553) = v37;
            }
          }
          else
          {
          }
        }
        if (!v20)
        {
          int v39 = *(uint64_t **)(a1 + 56);
          char v38 = 1;
LABEL_59:
          int v40 = objc_opt_new();
          uint64_t v41 = RB::Device::make_render_pipeline_descriptor(v65, v66, *(uint64_t **)(a1 + 48), v39, v40, 0, 0);
          if (v41)
          {
            if ((v38 & 1) == 0)
            {
              uint64_t v76 = *(void *)(v20 + 8);
              uint64_t v41 = objc_msgSend((id)objc_msgSend(v40, "fragmentLinkedFunctions"), "setPrivateFunctions:", objc_msgSend(MEMORY[0x263EFF8C0], "arrayWithObjects:count:", &v76, 1));
            }
            id v63 = 0;
            double v42 = RB::current_time_seconds((RB *)v41);
            unint64_t v43 = (void *)[*(id *)(a1 + 24) newRenderPipelineStateWithDescriptor:v40 options:4 * (v39 != 0) reflection:0 error:&v63];

            id v64 = v43;
            double v46 = RB::current_time_seconds(v44);
            if (!v39)
            {
LABEL_70:
              if (!v43)
              {
                char v51 = 1;
LABEL_76:
                if (*(unsigned char *)(a1 + 552))
                {
                  uint64_t v45 = (RB *)std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::__emplace_unique_key_args<RB::FormattedRenderState,RB::FormattedRenderState const&>(a1 + 512, (unsigned int *)&v65, (uint64_t)&v65);
                  if (v52) {
                    BOOL v53 = 0;
                  }
                  else {
                    BOOL v53 = *(unsigned char *)(a1 + 553) == 0;
                  }
                  char v54 = !v53;
                  *(unsigned char *)(a1 + 553) = v54;
                }
                if ((v51 & 1) == 0)
                {
                  double v55 = v46 - v42;
                  if (v55 > 0.5)
                  {
                    unint64_t v56 = RB::error_log(v45);
                    if (os_log_type_enabled(v56, OS_LOG_TYPE_FAULT))
                    {
                      char v61 = RB::RenderState::name((RB::RenderState *)&v65);
                      uint64_t v77 = v65;
                      int v78 = v66;
                      RB::FormattedRenderState::ID::formatted((uint64_t)&v77, (uint64_t)&v67);
                      *(_DWORD *)buf = 136315650;
                      BOOL v70 = v61;
                      __int16 v71 = 2080;
                      id v72 = &v67;
                      __int16 v73 = 2048;
                      double v74 = v55;
                      _os_log_fault_impl(&dword_2140F5000, v56, OS_LOG_TYPE_FAULT, "building pipeline %s-%s took %f seconds", buf, 0x20u);
                    }
                  }
                  operator new();
                }
                goto LABEL_85;
              }
              uint64_t v47 = "built";
LABEL_72:
              uint64_t v45 = (RB *)RB::verbose_mode(v45);
              if (v45)
              {
                char v50 = RB::RenderState::name((RB::RenderState *)&v65);
                uint64_t v67 = v65;
                int v68 = v66;
                RB::FormattedRenderState::ID::formatted((uint64_t)&v67, (uint64_t)buf);
                printf("%s render pipeline %s-%s (%.2f ms)\n", v47, v50, (const char *)buf, (v46 - v42) * 1000.0);
                uint64_t v45 = (RB *)fflush((FILE *)*MEMORY[0x263EF8358]);
              }
              char v51 = 0;
              goto LABEL_76;
            }
            if (v43)
            {
              uint64_t v47 = "loaded";
              goto LABEL_72;
            }
            char v48 = (RB *)RB::Device::make_render_pipeline_descriptor(v65, v66, *(uint64_t **)(a1 + 48), 0, v40, 0, 0);
            if (v48)
            {
              if ((v38 & 1) == 0)
              {
                uint64_t v75 = *(void *)(v20 + 8);
                char v48 = (RB *)objc_msgSend((id)objc_msgSend(v40, "fragmentLinkedFunctions"), "setPrivateFunctions:", objc_msgSend(MEMORY[0x263EFF8C0], "arrayWithObjects:count:", &v75, 1));
              }
              double v42 = RB::current_time_seconds(v48);
              unint64_t v43 = (void *)[*(id *)(a1 + 24) newRenderPipelineStateWithDescriptor:v40 options:0 reflection:0 error:&v63];

              id v64 = v43;
              double v46 = RB::current_time_seconds(v49);
              goto LABEL_70;
            }
          }
LABEL_85:
          uint32x2_t v21 = 0;

          goto LABEL_90;
        }
LABEL_57:
        char v38 = 0;
        int v39 = 0;
        goto LABEL_59;
      }
LABEL_22:
      RB::non_fatal_precondition_failure((RB *)"missing custom function: %u", v17, v16);
    }
    uint32x2_t v21 = 0;
LABEL_90:

    return v21;
  }
  *((_DWORD *)v7 + 11) = *(_DWORD *)(a1 + 192);
  return v8;
}

void sub_21411F0D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id a14, id a15)
{
  _Unwind_Resume(a1);
}

uint64_t RB::RenderState::custom_shader_signature(RB::RenderState *this)
{
  uint64_t result = 0;
  unsigned int v3 = *(_DWORD *)this & 0x3F;
  if (v3 > 0x1D)
  {
    if (v3 == 38)
    {
      LODWORD(result) = (*(_DWORD *)this >> 8) & 7;
    }
    else
    {
      if (v3 != 30) {
        return result;
      }
      LODWORD(result) = 1;
    }
    return result | (8 * (*((_DWORD *)this + 1) >> 6));
  }
  if (v3 == 8 || v3 == 22) {
    return result | (8 * (*((_DWORD *)this + 1) >> 6));
  }
  return result;
}

uint64_t RB::Device::depth_stencil_state(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v3 = a2;
  unint64_t v4 = a1 + ((unint64_t)a2 << 6) + 8 * a3;
  uint64_t v5 = *(void *)(v4 + 608);
  if (v5) {
    return v5;
  }
  uint64_t v8 = a3;
  int v9 = objc_opt_new();
  uint64_t v11 = *((void *)v10 + 1);
  uint64_t v13 = *((unsigned int *)v10 + 6);
  uint64_t v12 = *((unsigned int *)v10 + 7);
  [v9 setStencilCompareFunction:*(void *)v10];
  [v9 setStencilFailureOperation:0];
  [v9 setDepthFailureOperation:0];
  [v9 setDepthStencilPassOperation:v11];
  [v9 setReadMask:v13];
  [v9 setWriteMask:v12];
  id v14 = objc_opt_new();
  [v14 setFrontFaceStencil:v9];
  [v14 setBackFaceStencil:v9];
  switch(a2)
  {
    case 0u:
      uint64_t v16 = 7;
      goto LABEL_8;
    case 1u:
      uint64_t v16 = 6;
LABEL_8:
      [v14 setDepthCompareFunction:v16];
      uint64_t v15 = 0;
      goto LABEL_9;
    case 2u:
      [v14 setDepthCompareFunction:6];
      uint64_t v15 = 1;
LABEL_9:
      [v14 setDepthWriteEnabled:v15];
      break;
  }
  uint64_t v5 = [*(id *)(a1 + 24) newDepthStencilStateWithDescriptor:v14];

  *(void *)(v4 + 608) = v5;
  if (!v5) {
    RB::precondition_failure((RB *)"unable to allocate depth-stencil state: %d, %d", v17, v3, v8);
  }

  return v5;
}

void sub_21411F3A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t RB::anonymous namespace'::use_uber_shader(RB::_anonymous_namespace_ *this)
{
  {
    uint64_t v3 = RB::debug_int((RB *)"RB_UBER_SHADER", v2);
    if ((v3 & 0xFF00000000) != 0) {
      int v4 = v3;
    }
    else {
      int v4 = 1;
    }
  }
}

void sub_21411F43C(_Unwind_Exception *a1)
{
}

uint64_t RB::Device::RenderPipelineEntry::Queue::shared(RB::Device::RenderPipelineEntry::Queue *this)
{
  {
    operator new();
  }
  return RB::Device::RenderPipelineEntry::Queue::shared(void)::shared_queue;
}

void sub_21411F4CC(_Unwind_Exception *a1)
{
}

BOOL RB::RenderState::uber_compatible(RB::RenderState *this)
{
  unsigned int v1 = *(_DWORD *)this & 0x3F;
  if (v1 < 2 || v1 == 39) {
    return 0;
  }
  if (v1 == 34) {
    return (*(_DWORD *)this & 0x180) == 0;
  }
  return 1;
}

id RB::Device::RenderPipelineEntry::function_table(uint64_t *a1, const char *a2, void *a3, uint64_t a4)
{
  v68[1] = *MEMORY[0x263EF8340];
  if ((*((unsigned char *)a1 + 11) & 8) == 0) {
    return 0;
  }
  int v5 = (int)a2;
  uint64_t v6 = (RB::RenderState *)a1;
  if (a4 && (uint64_t v7 = a3[1]) != 0)
  {
    uint64_t v8 = (unsigned int **)(*a3 + 24);
    while (1)
    {
      int v9 = *v8;
      unsigned int v10 = **v8;
      if (((*v8)[1] | (8 * v10)) == a4) {
        break;
      }
      ++v8;
      if (!--v7) {
        goto LABEL_8;
      }
    }
    if (!*((unsigned char *)v9 + 104)) {
      RB::precondition_failure((RB *)"missing binary function: %u", a2, a4);
    }
  }
  else
  {
LABEL_8:
    unsigned int v10 = 0;
    int v9 = 0;
  }
  uint64_t v11 = a1[4];
  if (!v11) {
    operator new();
  }
  uint64_t v12 = (uint64_t *)(v11 + 8);
  uint64_t v13 = *(unsigned int *)(v11 + 16);
  if (v13)
  {
    uint64_t v14 = 0;
    uint64_t v15 = *v12;
    uint64_t v16 = *v12 + 8;
    while (1)
    {
      uint64_t v17 = v15 + 80 * v14;
      int v20 = *(_DWORD *)(v17 + 72);
      uint64_t v18 = (_DWORD *)(v17 + 72);
      int v19 = v20;
      if (v20 == a2) {
        break;
      }
      if (v19 - *((_DWORD *)a1 + 11) <= 0)
      {
        LODWORD(v21) = 0;
        *uint64_t v18 = a2;
        uint64_t v30 = v15 + 80 * v14;
        *(_OWORD *)(v30 + 8) = 0u;
        *(_OWORD *)(v30 + 24) = 0u;
        *(_OWORD *)(v30 + 40) = 0u;
        *(_OWORD *)(v30 + 56) = 0u;
LABEL_30:
        LODWORD(v13) = v14;
        goto LABEL_31;
      }
LABEL_25:
      ++v14;
      v16 += 80;
      if (v14 == v13) {
        goto LABEL_26;
      }
    }
    if (v10)
    {
      uint64_t v21 = 0;
      while (1)
      {
        int v22 = *(_DWORD *)(v16 + 4 * v21);
        if (v22 == v10 || v22 == 0) {
          goto LABEL_30;
        }
        if (++v21 == 16) {
          goto LABEL_25;
        }
      }
    }
    uint64_t v31 = (id *)(v15 + 80 * v14);
    return *v31;
  }
LABEL_26:
  unsigned int v24 = *(_DWORD *)(v11 + 16);
  if (*(_DWORD *)(v11 + 20) < (v13 + 1))
  {
    RB::vector<RB::Device::RenderPipelineEntry::Functions::Table,0ul,unsigned int>::reserve_slow(v11 + 8, v13 + 1);
    unsigned int v24 = *(_DWORD *)(v11 + 16);
  }
  unsigned int v25 = (_OWORD *)(*(void *)(v11 + 8) + 80 * v24);
  v25[3] = 0u;
  v25[4] = 0u;
  v25[1] = 0u;
  v25[2] = 0u;
  *unsigned int v25 = 0u;
  unsigned int v26 = *(_DWORD *)(v11 + 16);
  *(_DWORD *)(v11 + 16) = v26 + 1;
  uint64_t v27 = *(void *)(v11 + 8);
  uint64_t v21 = objc_opt_new();
  [(id)v21 setFunctionCount:16];
  uint64_t v28 = [*((id *)v6 + 3) newVisibleFunctionTableWithDescriptor:v21 stage:2];
  uint64_t v29 = v27 + 80 * v26;

  *(void *)uint64_t v29 = v28;
  *(_DWORD *)(v29 + 72) = v5;
  *(_OWORD *)(v29 + 8) = 0u;
  *(_OWORD *)(v29 + 24) = 0u;
  *(_OWORD *)(v29 + 40) = 0u;
  *(_OWORD *)(v29 + 56) = 0u;

  LODWORD(v21) = 0;
  uint64_t v6 = (RB::RenderState *)a1;
  uint64_t v15 = *(void *)(v11 + 8);
LABEL_31:
  uint64_t v31 = (id *)(v15 + 80 * v13);
  if (v10 && *(_DWORD *)(v15 + 80 * v13 + 8 + 4 * v21) != v10)
  {
    uint64_t v61 = v15 + 80 * v13 + 8;
    double v32 = *(_DWORD **)(v11 + 24);
    unint64_t v33 = *(unsigned int *)(v11 + 32);
    BOOL v34 = &v32[4 * v33];
    if (v33)
    {
      do
      {
        unint64_t v35 = v33 >> 1;
        BOOL v36 = &v32[4 * (v33 >> 1)];
        unsigned int v38 = *v36;
        char v37 = v36 + 4;
        v33 += ~(v33 >> 1);
        if (v38 < v10) {
          double v32 = v37;
        }
        else {
          unint64_t v33 = v35;
        }
      }
      while (v33);
      if (v32 != v34)
      {
        if (*v32 == v10)
        {
          id v39 = (id)*((void *)v32 + 1);
          uint64_t v40 = v61;
LABEL_55:
          [*v31 setFunction:v39 atIndex:v21];
          *(_DWORD *)(v40 + 4 * v21) = v10;
          return *v31;
        }
        BOOL v34 = v32;
      }
    }
    uint64_t v41 = objc_opt_new();
    v68[0] = *((void *)v9 + 1);
    objc_msgSend(v41, "setFragmentAdditionalBinaryFunctions:", objc_msgSend(MEMORY[0x263EFF8C0], "arrayWithObjects:count:", v68, 1));
    id v64 = 0;
    double v42 = (void *)[*((id *)v6 + 3) newRenderPipelineStateWithAdditionalBinaryFunctions:v41 error:&v64];
    unint64_t v43 = v42;
    if (v42)
    {
      uint64_t v59 = (void *)*((void *)v6 + 3);
      unint64_t v60 = v41;
      *((void *)v6 + 3) = v42;
      double v44 = (void *)[v42 functionHandleWithFunction:*((void *)v9 + 1) stage:2];
      id v63 = v44;
      if (!v44) {
        RB::precondition_failure((RB *)"unable to link function", v45);
      }
      id v58 = v44;
      uint64_t v46 = *(void *)(v11 + 24);
      unsigned int v47 = *(_DWORD *)(v11 + 32);
      if (*(_DWORD *)(v11 + 36) < v47 + 1)
      {
        RB::vector<RBColor,0ul,unsigned int>::reserve_slow(v11 + 24, v47 + 1);
        uint64_t v48 = *(void *)(v11 + 24);
        unsigned int v47 = *(_DWORD *)(v11 + 32);
      }
      else
      {
        uint64_t v48 = *(void *)(v11 + 24);
      }
      unint64_t v49 = ((uint64_t)v34 - v46) >> 4;
      if (v47 > v49)
      {
        memmove((void *)(v48 + 16 * v49 + 16), (const void *)(v48 + 16 * v49), 16 * (v47 - v49));
        unsigned int v47 = *(_DWORD *)(v11 + 32);
      }
      uint64_t v50 = v48 + 16 * v49;
      *(_DWORD *)uint64_t v50 = v10;
      *(void *)(v50 + 8) = v58;
      *(_DWORD *)(v11 + 32) = v47 + 1;

      if (RB::verbose_mode(v51))
      {
        char v52 = (const char *)objc_msgSend((id)objc_msgSend(*((id *)v9 + 1), "label"), "UTF8String");
        int v53 = *v9;
        char v54 = RB::RenderState::name(v6);
        int v55 = *((_DWORD *)v6 + 2);
        uint64_t v65 = *(void *)v6;
        int v66 = v55;
        RB::FormattedRenderState::ID::formatted((uint64_t)&v65, (uint64_t)buf);
        printf("added function %s (@%d) to %s-%s\n", v52, v53, v54, (const char *)buf);
      }
      uint64_t v41 = v60;
      uint64_t v40 = v61;
      unint64_t v56 = v59;
    }
    else
    {
      uint64_t v40 = v61;
      unsigned int v57 = RB::error_log(0);
      if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR)) {
        RB::Device::RenderPipelineEntry::function_table([v64 localizedDescription], buf, v57);
      }
      unint64_t v56 = 0;
      id v63 = 0;
    }

    id v39 = v63;
    if (!v43) {
      return 0;
    }
    goto LABEL_55;
  }
  return *v31;
}

void sub_21411FA54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id a13, id a14, id a15)
{
  _Unwind_Resume(a1);
}

uint64_t RB::Device::sampler_state(uint64_t a1, MTLPixelFormat a2, uint64_t a3)
{
  uint64_t v3 = a1 + 8 * a2;
  uint64_t v4 = *(void *)(v3 + 560);
  if (!v4)
  {
    unsigned int v5 = a2;
    if (a2 == 4)
    {
      if (a3) {
        unint64_t v7 = *(void *)(a3 + 56);
      }
      else {
        unint64_t v7 = 0;
      }
      if (*(unsigned __int8 *)(a1 + 283) >= *((unsigned __int8 *)RB::pixel_format_traits(v7, a2) + 10)) {
        unsigned int v5 = 4;
      }
      else {
        unsigned int v5 = 2;
      }
    }
    else if (a2 == 3)
    {
      if (a3 && *(unsigned __int8 *)(a3 + 76) > 1u) {
        unsigned int v5 = 3;
      }
      else {
        unsigned int v5 = 2;
      }
    }
    uint64_t v8 = objc_opt_new();
    uint64_t v9 = v5;
    char v11 = *v10;
    uint64_t v13 = *((void *)v10 + 2);
    uint64_t v12 = *((void *)v10 + 3);
    [v8 setSAddressMode:0];
    [v8 setTAddressMode:0];
    [v8 setNormalizedCoordinates:v11 & 1];
    [v8 setMinFilter:v13];
    [v8 setMagFilter:v13];
    [v8 setMipFilter:v12];
    [v8 setLodAverage:1];
    uint64_t v4 = [*(id *)(a1 + 24) newSamplerStateWithDescriptor:v8];

    *(void *)(v3 + 560) = v4;
    if (!v4) {
      RB::precondition_failure((RB *)"unable to allocate sampler state: %d", v14, v9);
    }
  }
  return v4;
}

void sub_21411FC20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t RB::DirectRenderCommandEncoder::reset(void *a1, void *a2)
{
  *a1 = a2;
  a1[1] = [a2 methodForSelector:sel_drawPrimitives_vertexStart_vertexCount_instanceCount_];
  a1[2] = [a2 methodForSelector:sel_drawIndexedPrimitives_indexCount_indexType_indexBuffer_indexBufferOffset_instanceCount_];
  a1[3] = [a2 methodForSelector:sel_setScissorRect_];
  a1[4] = [a2 methodForSelector:sel_setRenderPipelineState_];
  a1[5] = [a2 methodForSelector:sel_setDepthStencilState_];
  a1[6] = [a2 methodForSelector:sel_setStencilReferenceValue_];
  a1[7] = [a2 methodForSelector:sel_setVertexBytes_length_atIndex_];
  a1[8] = [a2 methodForSelector:sel_setVertexBuffer_offset_atIndex_];
  a1[9] = [a2 methodForSelector:sel_setVertexBufferOffset_atIndex_];
  a1[10] = [a2 methodForSelector:sel_setFragmentBytes_length_atIndex_];
  a1[11] = [a2 methodForSelector:sel_setFragmentBuffer_offset_atIndex_];
  a1[12] = [a2 methodForSelector:sel_setFragmentBufferOffset_atIndex_];
  a1[13] = [a2 methodForSelector:sel_setFragmentTexture_atIndex_];
  uint64_t result = [a2 methodForSelector:sel_setFragmentSamplerState_atIndex_];
  a1[14] = result;
  return result;
}

uint64_t RB::Device::RenderPipelineEntry::Loader::Loader(uint64_t a1, atomic_uint *this, uint64_t a3, int a4, uint64_t a5)
{
  *(void *)a1 = 0;
  if (this) {
    atomic_fetch_add_explicit(this + 2, 1u, memory_order_relaxed);
  }
  *(void *)(a1 + 8) = this;
  *(void *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 24) = a4;
  id v7 = (id)RB::Device::library((RB::Device *)this);
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 32) = v7;
  *(unsigned char *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 56) = 0u;
  if (a5)
  {
    uint64_t v8 = *(void **)(a5 + 8);
    if (v8)
    {

      *(void *)(a1 + 40) = v8;
    }
  }
  return a1;
}

void sub_21411FE04(_Unwind_Exception *a1)
{
  uint64_t v3 = *(atomic_uint **)(v1 + 8);
  if (v3)
  {
    if (atomic_fetch_add_explicit(v3 + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(atomic_uint *))(*(void *)v3 + 8))(v3);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t RB::Device::library(RB::Device *this)
{
  uint64_t result = *((void *)this + 6);
  if (!result)
  {
    uint64_t v3 = (RB::_anonymous_namespace_ *)MEMORY[0x21669B110]();

    *((void *)this + 6) = library;
    return *((void *)this + 6);
  }
  return result;
}

void sub_21411FEE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void RB::Device::RenderPipelineEntry::Loader::vertex_fn(id *this, uint64_t a2)
{
  if (a2)
  {
    [this[6] setVertexFunction:a2];
    RB::Device::RenderPipelineEntry::Loader::load_fn((RB::Device::RenderPipelineEntry::Loader *)this, (Function *)1);
  }
  else
  {
    RB::Device::RenderPipelineEntry::Loader::finished((RB::Device::RenderPipelineEntry::Loader *)this);
  }
}

void RB::Device::RenderPipelineEntry::Loader::finished(RB::Device::RenderPipelineEntry::Loader *this)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  *((unsigned char *)this + 80) = 1;
  int v2 = (RB *)RB::verbose_mode(this);
  if (v2)
  {
    double v3 = RB::current_time_seconds(v2) - *((double *)this + 9);
    if (*((void *)this + 8)) {
      uint64_t v4 = "finished";
    }
    else {
      uint64_t v4 = "failed";
    }
    unsigned int v5 = RB::RenderState::name((RB::Device::RenderPipelineEntry::Loader *)((char *)this + 16));
    int v6 = *((_DWORD *)this + 6);
    uint64_t v7 = *((void *)this + 2);
    int v8 = v6;
    RB::FormattedRenderState::ID::formatted((uint64_t)&v7, (uint64_t)v9);
    printf("%s building render pipeline %s-%s (%.2f ms)\n", v4, v5, v9, v3 * 1000.0);
    fflush((FILE *)*MEMORY[0x263EF8358]);
  }
  dispatch_async_f(*(dispatch_queue_t *)(*((void *)this + 1) + 40), this, (dispatch_function_t)RB::Device::RenderPipelineEntry::Loader::finished(void)::$_0::__invoke);
}

uint64_t RB::verbose_mode(RB *this)
{
  uint64_t v1 = &color_symbols(void)::flag;
  {
    uint64_t v1 = &color_symbols(void)::flag;
    if (v3)
    {
      uint64_t v5 = RB::debug_int((RB *)"RB_VERBOSE", v4);
      if ((v5 & 0xFF00000000) != 0) {
        int v6 = v5;
      }
      else {
        int v6 = 0;
      }
      RB::verbose_mode(void)::value = v6;
      uint64_t v1 = &color_symbols(void)::flag;
    }
  }
  return *((unsigned int *)v1 + 10);
}

void RB::Device::RenderPipelineEntry::Loader::fragment_fn(id *this, uint64_t a2)
{
  if (a2)
  {
    [this[6] setFragmentFunction:a2];
    int v3 = (void *)*((void *)this[1] + 3);
    id v4 = this[6];
    v5[0] = MEMORY[0x263EF8330];
    v5[1] = 3221225472;
    void v5[2] = ___ZN2RB6Device19RenderPipelineEntry6Loader13load_pipelineEv_block_invoke;
    _OWORD v5[3] = &__block_descriptor_40_e46_v24__0___MTLRenderPipelineState__8__NSError_16l;
    v5[4] = this;
    [v3 newRenderPipelineStateWithDescriptor:v4 completionHandler:v5];
  }
  else
  {
    RB::Device::RenderPipelineEntry::Loader::finished((RB::Device::RenderPipelineEntry::Loader *)this);
  }
}

void RB::Device::RenderPipelineEntry::Queue::enqueue(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)a1);
  id v4 = *(void **)(a1 + 16);
  if (!v4) {
    id v4 = (void *)(a1 + 8);
  }
  *id v4 = a2;
  *(void *)(a1 + 16) = a2;
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

uint64_t RB::Device::RenderPipelineEntry::RenderPipelineEntry(uint64_t a1, uint64_t a2, int a3, id *a4)
{
  *(void *)a1 = a2;
  *(_DWORD *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = 0;
  id v5 = *a4;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 24) = v5;
  *(_WORD *)(a1 + 48) = 0;
  return a1;
}

void sub_214120240(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 + 16);
  *(void *)(v1 + 16) = 0;
  if (v3) {
    RB::Device::RenderPipelineEntry::DeleteLoader::operator()((uint64_t)exception_object, v3);
  }
  _Unwind_Resume(exception_object);
}

void RB::DisplayList::Transform::clear(RB::DisplayList::Transform *this)
{
  if (*((void *)this + 4)) {
    int v2 = (RB::DisplayList::Transform *)*((void *)this + 4);
  }
  else {
    int v2 = this;
  }
  uint64_t v3 = *((unsigned int *)this + 10);
  if (v3)
  {
    id v4 = (CFTypeRef *)((char *)v2 + 8);
    uint64_t v5 = 32 * v3;
    do
    {
      if (*((_DWORD *)v4 - 2) == 3 && *v4) {
        CFRelease(*v4);
      }
      v4 += 4;
      v5 -= 32;
    }
    while (v5);
  }
  *((_DWORD *)this + 10) = 0;
}

void RB::Device::RenderPipelineEntry::Loader::pipeline(RB::Device::RenderPipelineEntry::Loader *this, void *a2)
{
  uint64_t v3 = (void *)*((void *)this + 8);
  if (v3 != a2)
  {

    *((void *)this + 8) = a2;
  }
  RB::Device::RenderPipelineEntry::Loader::finished(this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::render(uint64_t a1, int32x2_t *a2)
{
  id v4 = *(float64x2_t **)(a1 + 48);
  uint64_t v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  unsigned int v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&float32x2_t v12 = (*(double (**)(uint64_t, void))(*(void *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)&v17, v12, v13);
  int v14 = 0;
  if ((float32x2_t *)a2[11] != v5) {
    goto LABEL_10;
  }
  if (!RB::Bounds::contains(a2 + 12, *(int32x2_t *)&v17, *(int32x2_t *)((char *)&v17 + 8)))
  {
    int v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow((uint64_t)a2, v4, v5, v11, &v17, v14, _S8);
    goto LABEL_11;
  }
  int v14 = 1;
  if ((float64x2_t *)a2[10] != v4) {
    goto LABEL_10;
  }
  v15.i32[0] = a2[16].i32[1];
  if (*(float *)v15.i32 != _S8 || a2[17].i32[0] != v11) {
    goto LABEL_10;
  }
LABEL_11:
  RB::Coverage::Glyphs::fill((float32x2_t **)(a1 + 56), (RB::CGContext *)a2, (const RB::Fill::Color *)(a1 + 112), v15);
}

double RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::bounds(uint64_t a1, char a2)
{
  return RB::Coverage::Glyphs::bounds((RB::Coverage::Glyphs *)(a1 + 56), *(float64x2_t **)(a1 + 48), a2);
}

void RB::anonymous namespace'::render_glyphs(BOOL a1, uint64_t a2, float64x2_t *a3, float32x2_t *this, char a5, int a6)
{
  uint64_t v64 = *MEMORY[0x263EF8340];
  if (this[2].i32[0])
  {
    uint64_t v11 = a1;
    if (!a6
      || (double v12 = RB::Coverage::Glyphs::bounds((RB::Coverage::Glyphs *)this, a3, 0),
          RB::Bounds::Bounds(v60, *(float32x2_t *)&v12, v13),
          a1 = RB::Bounds::intersects(v14, *(int32x2_t *)(a2 + 160), *(int32x2_t *)(a2 + 168))))
    {
      BOOL v15 = (this[2].i32[1] & 8) == 0;
      int64x2_t v16 = *(int64x2_t *)a3;
      float64x2_t v56 = a3[1];
      int64x2_t v57 = v16;
      double v18 = RB::max_cached_glyph_mask_area((RB *)a1);
      *(double *)v19.i64 = -*(double *)&v57.i64[1];
      double v20 = fabs(vaddvq_f64(vmulq_f64((float64x2_t)vzip1q_s64(v19, v57), v56)));
      char v21 = v20 > v18 || v15;
      if ((v21 & 1) != 0 || this[6].u8[4] >= 2u)
      {
        return;
      }
      float32x2_t v62 = 0;
      float32x2_t v63 = 0;
      uint64_t v22 = this[2].u32[0];
      if (v22 > 0x80)
      {
        unsigned int v24 = (char *)malloc_type_malloc(32 * v22, 0x3AECBCuLL);
        if (!v24)
        {
LABEL_70:
          free(v24);
          return;
        }
      }
      else
      {
        MEMORY[0x270FA5388](v17, 32 * v22);
        unsigned int v24 = (char *)&v54 - ((v23 + 15) & 0x3FFFFFFFF0);
        bzero(v24, v23);
      }
      v60[0] = (int32x2_t)v24;
      v60[1] = (int32x2_t)&v61;
      v60[2] = (int32x2_t)&v62;
      unint64_t v61 = 0;
      if (v61)
      {
        unsigned int v26 = RB::pixel_format_traits(*(void *)(a2 + 88), v25);
        uint64_t v29 = *((unsigned __int16 *)v26 + 2);
        uint64_t v30 = *v26;
        if (a5) {
          int v31 = 1;
        }
        else {
          int v31 = (**(uint64_t (***)(uint64_t))v11)(v11) ^ 1;
        }
        if (v31 && ((v30 | (v29 << 32)) & 0x4000000000) != 0 && ((a6 ^ 1) & 1) == 0)
        {
          *(unsigned char *)(a2 + 176) = 1;
          *(_DWORD *)(a2 + 180) = 1;
        }
        int v55 = a6 ^ 1;
        *(void *)&v56.f64[0] = v30 | (v29 << 32);
        unint64_t v32 = v61;
        if (v61)
        {
          unint64_t v33 = 0;
          v57.i64[0] = (uint64_t)(v24 + 24);
          while (v32)
          {
            unint64_t v34 = 0;
            unint64_t v35 = 0;
            BOOL v36 = v24;
            unint64_t v37 = v32;
            do
            {
              if (!v36[24])
              {
                if (v35) {
                  unsigned int v38 = v35;
                }
                else {
                  unsigned int v38 = *(RB::Buffer **)v36;
                }
                if (v35) {
                  uint64_t v39 = v34;
                }
                else {
                  uint64_t v39 = 1;
                }
                if (v35) {
                  unint64_t v40 = v34 + 1;
                }
                else {
                  unint64_t v40 = v34;
                }
                if (*(RB::Buffer **)v36 == v35)
                {
                  unint64_t v34 = v40;
                }
                else
                {
                  unint64_t v35 = v38;
                  unint64_t v34 = v39;
                }
              }
              v36 += 32;
              --v37;
            }
            while (v37);
            unint64_t v41 = v32;
            if (v34)
            {
              RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)(16 * v34), 4uLL, 0, v59);
              if (v59[0])
              {
                unint64_t v42 = v61;
                if (v61)
                {
                  uint64_t v43 = 0;
                  uint64_t v44 = *(void *)(v59[0] + 56) + v59[1];
                  uint64_t v45 = (unsigned char *)v57.i64[0];
                  do
                  {
                    if (!*v45 && *((RB::Buffer **)v45 - 3) == v35)
                    {
                      *(_OWORD *)(v44 + 16 * v43++) = *((_OWORD *)v45 - 1);
                      *uint64_t v45 = 1;
                    }
                    v45 += 32;
                    --v42;
                  }
                  while (v42);
                }
                RB::Bounds::Bounds(v58, v62, v63);
                if (v31) {
                  RB::render_masks_accumulate((int32x2_t *)a2, v58, v34, (uint64_t)v59, v35);
                }
                else {
                  (*(void (**)(uint64_t, uint64_t, unint64_t, void *, RB::Buffer *, double, double))(*(void *)v11 + 8))(v11, a2, v34, v59, v35, *(double *)v58, *(double *)&v58[1]);
                }
                v33 += v34;
              }
              unint64_t v32 = v61;
              unint64_t v41 = v33;
              if (v33 != v61) {
                continue;
              }
            }
            if (v41)
            {
              unint64_t v46 = 0;
              unsigned int v47 = (_DWORD **)v24;
              do
              {
                uint64_t v48 = *v47;
                if (*v47)
                {
                  int v49 = v48[2] - 1;
                  v48[2] = v49;
                  if (!v49)
                  {
                    (*(void (**)(_DWORD *))(*(void *)v48 + 8))(v48);
                    unint64_t v41 = v61;
                  }
                }
                ++v46;
                v47 += 4;
              }
              while (v46 < v41);
            }
            break;
          }
        }
        if (v31)
        {
          if ((*(void *)&v56.f64[0] & 0x4000000000) != 0) {
            char v50 = v55;
          }
          else {
            char v50 = 1;
          }
          if ((v50 & 1) == 0)
          {
            *(unsigned char *)(a2 + 176) = 6;
            *(_DWORD *)(a2 + 180) = 0;
          }
          if (a6)
          {
            v27.n128_u64[0] = (unint64_t)v62;
            v28.n128_u64[0] = (unint64_t)v63;
          }
          else
          {
            v27.n128_u32[0] = 0;
            int32x2_t v51 = *(int32x2_t *)(a2 + 168);
            uint32x2_t v52 = (uint32x2_t)vceq_s32(v51, (int32x2_t)0x8000000080000000);
            int8x8_t v53 = (int8x8_t)vdup_lane_s32(vcgt_s32((int32x2_t)v27.n128_u64[0], (int32x2_t)vpmin_u32(v52, v52)), 0);
            v28.n128_u64[0] = (unint64_t)vbsl_s8(v53, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v51));
            v27.n128_u64[0] = (unint64_t)vbsl_s8(v53, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(*(int32x2_t *)(a2 + 160)));
          }
          (*(void (**)(uint64_t, uint64_t, __n128, __n128))(*(void *)v11 + 16))(v11, a2, v27, v28);
          if ((v50 & 1) == 0)
          {
            *(unsigned char *)(a2 + 176) = 0;
            *(_DWORD *)(a2 + 180) = 0;
          }
        }
      }
      if (v22 >= 0x81) {
        goto LABEL_70;
      }
    }
  }
}

void sub_2141208C4(_Unwind_Exception *exception_object)
{
  if (v2 >= 0x81) {
    free(v1);
  }
  _Unwind_Resume(exception_object);
}

double RB::Coverage::Glyphs::bounds(RB::Coverage::Glyphs *this, float64x2_t *a2, char a3)
{
  int v4 = *((_DWORD *)this + 4);
  float32x2_t v5 = 0;
  if (v4 && *(void *)this)
  {
    double v8 = RB::Coverage::Glyphs::glyph_bounds(this, 0, v4);
    float32x2_t v5 = RB::operator*(a2, *(float32x2_t *)&v8, v9);
    float32x2_t v11 = v10;
    *(int32x2_t *)v12.i8 = vcgtz_f32(v10);
    if ((vpmin_u32(*(uint32x2_t *)v12.i8, *(uint32x2_t *)v12.i8).u32[0] & 0x80000000) != 0
      && (a3 & 2) == 0
      && (*((_DWORD *)this + 5) & 8) != 0)
    {
      *(int32x2_t *)v12.i8 = vcgt_f32((float32x2_t)vdup_n_s32(0x7F7FFFFFu), v10);
      __asm { FMOV            V1.2S, #-1.0 }
      int8x8_t v18 = (int8x8_t)vcltzq_s32(v12).u64[0];
      float32x2_t v5 = (float32x2_t)vbsl_s8(v18, (int8x8_t)vadd_f32(v5, _D1), (int8x8_t)v5);
      float32x2_t v11 = (float32x2_t)vbsl_s8(v18, (int8x8_t)vadd_f32(v11, (float32x2_t)0x4000000040000000), (int8x8_t)v11);
    }
    if (*((unsigned char *)this + 52) == 3)
    {
      if (*((float *)this + 12) >= 0.0) {
        float v19 = *((float *)this + 12);
      }
      else {
        float v19 = 0.0;
      }
      *(float *)v20.i32 = v19 * RB::AffineTransform::scale(a2);
      *(int32x2_t *)v21.i8 = vcgt_f32((float32x2_t)vdup_n_s32(0x7F7FFFFFu), v11);
      float32x2_t v5 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(v21), (int8x8_t)vsub_f32(v5, (float32x2_t)vdup_lane_s32(v20, 0)), (int8x8_t)v5);
    }
  }
  return *(double *)&v5;
}

double RB::Coverage::Glyphs::glyph_bounds(RB::Coverage::Glyphs *this, unsigned int a2, int a3)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  int v3 = a3 + a2;
  unsigned int v4 = *((_DWORD *)this + 4);
  if (v4 < a3 + a2) {
    int v3 = *((_DWORD *)this + 4);
  }
  double v5 = 0.0;
  if (v4 > a2 && v3 != a2)
  {
    double v8 = *(CGFont **)this;
    if (v8)
    {
      size_t v10 = v3 - a2;
      if (!a2 && v10 == v4)
      {
        uint32x2_t v11 = (uint32x2_t)vcge_f32((float32x2_t)(*((void *)this + 5) & 0x7FFFFFFF7FFFFFFFLL), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
        if ((vpmax_u32(v11, v11).u32[0] & 0x80000000) == 0) {
          return *((double *)this + 4);
        }
      }
      int32x4_t v12 = (float32x2_t *)(*((void *)this + 1) + 8 * a2);
      uint64_t UnitsPerEm = CGFontGetUnitsPerEm(v8);
      float32x2_t v14 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(int)UnitsPerEm));
      float32x2_t v15 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(int)UnitsPerEm), v14), v14);
      *(float32x2_t *)&long long v16 = vmul_f32(v15, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(int)UnitsPerEm), v15));
      *(_OWORD *)v40[0].i8 = v16;
      if (v10 <= 0x80)
      {
        MEMORY[0x270FA5388](UnitsPerEm, 32 * v10);
        uint64_t v17 = (CGRect *)((char *)v40 - ((v19 + 15) & 0x3FFFFFFFF0));
        bzero(v17, v19);
        int v18 = 0;
      }
      else
      {
        uint64_t v17 = (CGRect *)malloc_type_malloc(32 * v10, 0x63A26599uLL);
        int v18 = 1;
        if (!v17) {
          goto LABEL_29;
        }
      }
      if (CGFontGetGlyphBBoxes(*(CGFontRef *)this, (const CGGlyph *)(*((void *)this + 1) + 8 * *((unsigned int *)this + 4) + 2 * a2), v10, v17))
      {
        unint64_t v21 = 0;
        char v22 = 0;
        float32x2_t v23 = (float32x2_t)vdup_lane_s32(v40[0], 0);
        if (v10 <= 1) {
          uint64_t v24 = 1;
        }
        else {
          uint64_t v24 = v10;
        }
        uint64_t v25 = 32 * v24;
        float32x2_t v26 = (float32x2_t)vdup_n_s32(0x7F800000u);
        v20.i64[0] = 0x7F0000007FLL;
        do
        {
          float32x2_t v27 = vcvt_f32_f64((float64x2_t)v17[v21 / 0x20].size);
          uint32x2_t v28 = (uint32x2_t)vcgtz_f32(v27);
          if ((vpmin_u32(v28, v28).u32[0] & 0x80000000) != 0)
          {
            float32x2_t v29 = vmla_f32(*v12, vcvt_f32_f64((float64x2_t)v17[v21 / 0x20].origin), v23);
            float32x2_t v26 = vminnm_f32(v26, v29);
            *(float32x2_t *)v20.i8 = vmaxnm_f32(*(float32x2_t *)v20.i8, vmla_f32(v29, v27, v23));
            char v22 = 1;
          }
          v21 += 32;
          ++v12;
        }
        while (v25 != v21);
        double v5 = 0.0;
        uint64_t v30 = 0;
        if ((v22 & 1) == 0)
        {
          if (!a2)
          {
LABEL_36:
            if (v10 == *((_DWORD *)this + 4))
            {
              *((double *)this + 4) = v5;
              *((void *)this + 5) = v30;
            }
          }
LABEL_38:
          if (v18) {
            free(v17);
          }
          return v5;
        }
LABEL_35:
        double v5 = RB::Rect::from_bounds(v26, v20);
        uint64_t v30 = v38;
        if (!a2) {
          goto LABEL_36;
        }
        goto LABEL_38;
      }
LABEL_29:
      if (v10 <= 1) {
        uint64_t v31 = 1;
      }
      else {
        uint64_t v31 = v10;
      }
      float32x2_t v32 = (float32x2_t)vdup_n_s32(0x7F800000u);
      float32x2_t v33 = (float32x2_t)0x7F0000007FLL;
      do
      {
        float32x2_t v34 = *v12++;
        float32x2_t v32 = vminnm_f32(v32, v34);
        float32x2_t v33 = vmaxnm_f32(v33, v34);
        --v31;
      }
      while (v31);
      *(CGRect *)((char *)&v20 - 8) = CGFontGetFontBBox((CGFontRef)*(void *)this);
      *(void *)&v35.f64[1] = v20.i64[0];
      v37.f64[1] = v36;
      *(float32x2_t *)v20.i8 = vcvt_f32_f64(v37);
      *(float32x2_t *)&v37.f64[0] = vmul_n_f32(vcvt_f32_f64(v35), *(float *)v40[0].i32);
      float32x2_t v26 = vadd_f32(*(float32x2_t *)&v37.f64[0], v32);
      *(float32x2_t *)v20.i8 = vadd_f32(vmla_n_f32(v33, *(float32x2_t *)v20.i8, *(float *)v40[0].i32), *(float32x2_t *)&v37.f64[0]);
      goto LABEL_35;
    }
  }
  return v5;
}

void sub_214120CB8(_Unwind_Exception *exception_object)
{
  if (v2) {
    free(v1);
  }
  _Unwind_Resume(exception_object);
}

int32x2_t *RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Fill::Color const&,BOOL,RB::BlendMode)::Renderer::draw_mask(uint64_t a1, uint64_t a2, float32x2_t a3, double a4)
{
  *(float *)&double v8 = RB::Coverage::set_plane((float32x2_t *)&v17, (float32x2_t *)a2, a3, a4);
  *(float16x4_t *)&v18[12] = RB::Fill::Color::prepare(*(void *)(a1 + 8), *(unsigned __int8 *)(a2 + 124), v8);
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)0x24, 4uLL, 0, &v19);
  int32x4_t v9 = v19;
  if (v19)
  {
    uint64_t v10 = *((void *)v19 + 7) + v20.i64[0];
    long long v11 = v17;
    long long v12 = *(_OWORD *)v18;
    *(_DWORD *)(v10 + 32) = *(_DWORD *)&v18[16];
    *(_OWORD *)uint64_t v10 = v11;
    *(_OWORD *)(v10 + 16) = v12;
  }
  else
  {
    size_t v19 = 0;
    int64x2_t v20 = 0uLL;
  }
  *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v9);
  *(int32x2_t *)(a2 + 188) = vmovn_s64(v20);
  uint64_t v13 = 18;
  if (*(_DWORD *)(a2 + 136) == 2) {
    uint64_t v13 = 131090;
  }
  float32x2_t v14 = (const char *)(v13 | ((unint64_t)*(unsigned __int8 *)(a1 + 16) << 16) | ((unint64_t)(*(_DWORD *)(a1 + 20) & 0x3F) << 32));
  RB::Bounds::Bounds(v16, a3, *(float32x2_t *)&a4);
  return RB::RenderPass::draw_indexed_primitives((int32x2_t *)a2, v14, 4, ***(void ***)a2 + 80, 0, 1uLL, v16[0], v16[1]);
}

BOOL RB::Bounds::intersects(int32x2_t *a1, int32x2_t a2, int32x2_t a3)
{
  uint32x2_t v3 = (uint32x2_t)vceqz_s32(a3);
  if ((vpmax_u32(v3, v3).u32[0] & 0x80000000) != 0) {
    return 0;
  }
  int32x2_t v4 = a1[1];
  uint32x2_t v5 = (uint32x2_t)vceqz_s32(v4);
  if ((vpmax_u32(v5, v5).u32[0] & 0x80000000) != 0) {
    return 0;
  }
  uint32x2_t v6 = (uint32x2_t)vcge_s32(vmax_s32(*a1, a2), vmin_s32(vadd_s32(*a1, v4), vadd_s32(a3, a2)));
  return vpmax_u32(v6, v6).i32[0] >= 0;
}

float32_t RB::Coverage::set_plane(float32x2_t *a1, float32x2_t *a2, float32x2_t a3, double a4)
{
  v4.f64[0] = 0.0;
  *(double *)&unint64_t v5 = *(float *)&a4;
  v4.f64[1] = *((float *)&a4 + 1);
  float32x2_t v6 = a2[14];
  v6.i32[1] = vneg_f32(v6).i32[1];
  *a1 = vmul_f32(v6, vcvt_f32_f64((float64x2_t)v5));
  a1[1] = vmul_f32(v6, vcvt_f32_f64(v4));
  a1[2] = vmla_f32((float32x2_t)0x3F800000BF800000, a3, v6);
  float32_t result = a2[15].f32[0];
  a1[3].f32[0] = result;
  return result;
}

double RB::max_cached_glyph_mask_area(RB *this)
{
  uint64_t v1 = &color_symbols(void)::flag;
  {
    uint64_t v1 = &color_symbols(void)::flag;
    if (v3)
    {
      uint64_t v5 = RB::debug_float((RB *)"RB_MAX_GLYPH_MASK_AREA", v4);
      double v6 = *(float *)&v5;
      if ((v5 & 0xFF00000000) == 0) {
        double v6 = 20000.0;
      }
      RB::max_cached_glyph_mask_area(void)::max_cached_area = *(void *)&v6;
      uint64_t v1 = &color_symbols(void)::flag;
    }
  }
  return *((double *)v1 + 16);
}

int32x2_t *RB::render_masks_accumulate(int32x2_t *result, int32x2_t *a2, unint64_t a3, uint64_t a4, RB::Buffer *a5)
{
  if (a5)
  {
    int32x4_t v9 = result;
    __int32 v10 = result[17].i32[0];
    float32x2_t v17 = (float32x2_t)result[14];
    __int32 v11 = result[15].i32[0];
    result[24].i32[1] = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)result, *(RB::Buffer **)a4);
    v9[25] = vmovn_s64(*(int64x2_t *)(a4 + 8));
    __int32 v12 = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v9, a5);
    v9[26].i32[1] = 0;
    v9[27].i32[0] = 0;
    v9[26].i32[0] = v12;
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v9, (RB::Device *)0x1C, 4uLL, 0, &v18);
    uint64_t v13 = v18;
    if (v18)
    {
      float32x2_t v14 = vneg_f32(v17);
      v14.i32[0] = 0;
      uint64_t v15 = *((void *)v18 + 7) + v19.i64[0];
      *(void *)uint64_t v15 = v17.u32[0];
      *(float32x2_t *)(v15 + 8) = v14;
      *(void *)(v15 + 16) = 0x3F800000BF800000;
      *(_DWORD *)(v15 + 24) = v11;
    }
    else
    {
      int v18 = 0;
      int64x2_t v19 = 0uLL;
    }
    v9[23].i32[0] = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v9, v13);
    *(int32x2_t *)((char *)v9 + 188) = vmovn_s64(v19);
    if (v10 == 2) {
      uint64_t v16 = 0xF00020009;
    }
    else {
      uint64_t v16 = 0xF00000009;
    }
    float32_t result = RB::RenderPass::draw_indexed_primitives(v9, (const char *)v16, 4, ***(void ***)v9 + 80, 0, a3, *a2, a2[1]);
    *(int32x2_t *)((char *)&v9[24] + 4) = 0;
    *(int32x2_t *)((char *)&v9[25] + 4) = 0;
    *(int32x2_t *)((char *)&v9[26] + 4) = 0;
  }
  return result;
}

void sub_21412109C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 200) = 0;
  *(_DWORD *)(v1 + 196) = 0;
  _Unwind_Resume(a1);
}

void RB::anonymous namespace'::render_glyph_masks<RB::anonymous namespace'::render_glyphs(RB::anonymous namespace'::GlyphRenderer const&,RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,BOOL,BOOL)::$_0>(uint64_t *a1, RB::Device ****a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v72 = *MEMORY[0x263EF8340];
  RB::Device::glyph_lock(***a2);
  float64x2_t v8 = vmulq_f64(a4[1], (float64x2_t)xmmword_2142181F0);
  float64x2_t v9 = vmulq_f64(a4[2], (float64x2_t)xmmword_2142181F0);
  float64x2_t v69 = vmulq_f64(*a4, (float64x2_t)xmmword_2142181F0);
  float64x2_t v70 = v8;
  float64x2_t v71 = v9;
  if (!CGGlyphLockAccessCustomized()) {
    return;
  }
  uint64_t QuantizationLevel = CGGlyphLockGetQuantizationLevel();
  if (!QuantizationLevel) {
    return;
  }
  uint64_t v11 = *(unsigned int *)(a3 + 16);
  if (v11 > 0x100)
  {
    float32x2_t v14 = (float64x2_t *)malloc_type_malloc(16 * v11, 0x437EC846uLL);
    uint64_t v13 = v14;
    if (!v14)
    {
LABEL_52:
      free(v13);
      return;
    }
  }
  else
  {
    MEMORY[0x270FA5388](QuantizationLevel, 16 * v11);
    uint64_t v13 = (float64x2_t *)((char *)&v60 - ((v12 + 15) & 0x1FFFFFFFF0));
    bzero(v13, v12);
  }
  uint64_t v15 = *(unsigned int *)(a3 + 16);
  if (v15)
  {
    uint64_t v16 = *(float32x2_t **)(a3 + 8);
    float32x2_t v17 = v13;
    uint64_t v18 = *(unsigned int *)(a3 + 16);
    do
    {
      float32x2_t v19 = *v16++;
      *v17++ = vcvtq_f64_f32(v19);
      --v18;
    }
    while (v18);
    uint64_t v20 = 4 * v15;
    if (v15 >= 0x401)
    {
      unint64_t v21 = (char *)malloc_type_malloc(4 * v15, 0xEBB51928uLL);
      uint64_t v64 = v21;
      int v63 = 0;
      uint64_t v15 = *(unsigned int *)(a3 + 16);
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v20 = 0;
  }
  MEMORY[0x270FA5388](v14, v20);
  uint64_t v64 = (char *)&v60 - ((v22 + 15) & 0x7FFFFFFF0);
  bzero(v64, v22);
  int v63 = 1;
LABEL_13:
  if (v15 >= 0x201)
  {
    uint64_t v24 = (char *)malloc_type_malloc(8 * v15, 0x2A006B26uLL);
  }
  else
  {
    MEMORY[0x270FA5388](v21, 8 * v15);
    uint64_t v24 = (char *)&v60 - ((v23 + 15) & 0xFFFFFFFF0);
    bzero(v24, v23);
  }
  if (v64 && v24)
  {
    uint64_t GlyphIdentifiers = CGFontGetGlyphIdentifiers();
    uint64_t v26 = *(unsigned int *)(a3 + 16);
    uint64_t v62 = v26;
    if (v26 >= 0x201)
    {
      uint32x2_t v28 = (char *)malloc_type_malloc(8 * v26, 0x7A5FF13DuLL);
      if (!v28)
      {
LABEL_46:
        free(v28);
        goto LABEL_47;
      }
    }
    else
    {
      MEMORY[0x270FA5388](GlyphIdentifiers, 8 * v26);
      uint32x2_t v28 = (char *)&v60 - ((v27 + 15) & 0xFFFFFFFF0);
      bzero(v28, v27);
    }
    if (CGGlyphLockLockGlyphBitmaps())
    {
      unint64_t v60 = v13;
      uint64_t v61 = v11;
      unint64_t v29 = *(unsigned int *)(a3 + 16);
      if (v29)
      {
        uint64_t v30 = 0;
        while (1)
        {
          uint64_t v31 = *(_DWORD **)&v28[8 * v30];
          if (!v31[5] || !v31[6]) {
            goto LABEL_43;
          }
          RB::RenderFrame::cached_region((uint64_t)**a2, 1u, v31[9], (uint64_t)&v67);
          uint64_t v38 = v67;
          if (v67) {
            goto LABEL_39;
          }
          RB::RenderFrame::alloc_buffer_region((RB::RenderFrame *)**a2, (RB::Device *)(v31[6] * v31[5]), 0, 2, &v65);
          uint64_t v67 = v65;
          int64x2_t v68 = v66;
          if (v65) {
            break;
          }
LABEL_42:
          unint64_t v29 = *(unsigned int *)(a3 + 16);
LABEL_43:
          if (++v30 >= v29) {
            goto LABEL_44;
          }
        }
        unint64_t v40 = v31 + 10;
        int v41 = v31[7];
        uint64_t v42 = (int)v31[8];
        if (v41 == 16)
        {
          unsigned int v43 = v31[6];
          if (v43)
          {
            unsigned int v44 = 0;
            uint64_t v45 = *(void *)(v65 + 56) + v66.i64[0];
            LODWORD(v46) = v31[5];
            do
            {
              if (v46)
              {
                unint64_t v47 = 0;
                do
                {
                  *(unsigned char *)(v45 + v47) = *((unsigned __int16 *)v40 + v47) >> 7;
                  ++v47;
                  unint64_t v46 = v31[5];
                }
                while (v47 < v46);
                unsigned int v43 = v31[6];
                v45 += v47;
              }
              unint64_t v40 = (_DWORD *)((char *)v40 + v42);
              ++v44;
            }
            while (v44 < v43);
          }
        }
        else
        {
          if (v41 != 8) {
            RB::precondition_failure((RB *)"unknown CG glyph mask format: %d", v39, v40, v31[7]);
          }
          CGBlt_copyBytes();
        }
        RB::RenderFrame::set_cached_region((uint64_t)**a2, 1u, v31[9], (uint64_t)&v67);
        uint64_t v38 = v67;
LABEL_39:
        v33.i64[0] = *(void *)(v31 + 5);
        uint64_t v48 = &v24[8 * v30];
        int v49 = *(_DWORD *)v48;
        int v50 = *((_DWORD *)v48 + 1);
        int v52 = v31[3];
        int v51 = v31[4];
        uint64_t v53 = *a1;
        uint64_t v54 = (void *)a1[1];
        uint64_t v55 = (*v54)++;
        if (v38) {
          ++*(_DWORD *)(v38 + 8);
        }
        int v56 = v51 + v50;
        uint64_t v57 = v53 + 32 * v55;
        int v58 = -v56;
        *(void *)uint64_t v57 = v38;
        *(unsigned char *)(v57 + 24) = 0;
        v32.i16[0] = v52 + v49;
        v32.i16[1] = v58;
        *(int16x4_t *)(v57 + 8) = vuzp1_s16(vzip1_s16(v32, *(int16x4_t *)v33.i8), *(int16x4_t *)v33.i8);
        *(int32x2_t *)(v57 + 16) = vmovn_s64(v68);
        *(float *)&double v59 = (float)(__int16)(v52 + v49);
        *(float *)&double v34 = (float)(__int16)v58;
        v33.i32[1] = v33.u16[2];
        *(float32x2_t *)v33.i8 = vcvt_f32_s32(vshr_n_s32(vshl_n_s32(*(int32x2_t *)v33.i8, 0x10uLL), 0x10uLL));
        *((float *)&v59 + 1) = *(float *)&v34;
        RB::Rect::Union((float32x2_t *)a1[2], v59, v33, v34, v35, v36, v37);
        goto LABEL_42;
      }
LABEL_44:
      uint64_t v13 = v60;
      LODWORD(v11) = v61;
      CGGlyphLockUnlock();
    }
    if (v62 >= 0x201) {
      goto LABEL_46;
    }
  }
LABEL_47:
  if (v15 >= 0x201) {
    free(v24);
  }
  if ((v63 & 1) == 0) {
    free(v64);
  }
  if (v11 >= 0x101) {
    goto LABEL_52;
  }
}

void sub_2141215CC()
{
}

void sub_2141215D4(_Unwind_Exception *exception_object)
{
  if (*(void *)(v4 - 240) >= 0x201) {
    free(v2);
  }
  if (v3 >= 0x201) {
    free(v1);
  }
  if ((*(_DWORD *)(v4 - 228) & 1) == 0) {
    free(*(void **)(v4 - 224));
  }
  if (*(void *)(v4 - 248) >= 0x101) {
    free(*(void **)(v4 - 256));
  }
  _Unwind_Resume(exception_object);
}

uint64_t *RB::RenderFrame::cached_region@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  unint64_t v6 = __PAIR64__(a3, a2);
  float32_t result = RB::UntypedTable::lookup((RB::UntypedTable *)(a1 + 152), (uint64_t *)&v6, 0);
  if (result)
  {
    *(void *)a4 = result[1];
    *(_OWORD *)(a4 + 8) = *((_OWORD *)result + 1);
  }
  else
  {
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    *(void *)(a4 + 16) = 0;
  }
  return result;
}

uint64_t RB::RenderFrame::set_cached_region(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v5 = *(RB::Heap **)(a1 + 184);
  if (!v5) {
    operator new();
  }
  unint64_t v8 = __PAIR64__(a3, a2);
  RB::Heap::emplace<RB::RenderFrame::RegionEntry,RB::RenderFrame::RegionKey,RB::BufferRegion const&>(v5, &v8, a4);
  return RB::UntypedTable::insert((size_t **)(a1 + 152), v6, v6);
}

void sub_214121770(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x1030C4075D23742);
  _Unwind_Resume(a1);
}

__n128 RB::Heap::emplace<RB::RenderFrame::RegionEntry,RB::RenderFrame::RegionKey,RB::BufferRegion const&>(RB::Heap *this, unint64_t *a2, uint64_t a3)
{
  unint64_t v6 = *((void *)this + 3);
  uint64_t v7 = (__n128 *)((*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)v7[2].n128_u64 > v6) {
    uint64_t v7 = (__n128 *)RB::Heap::alloc_slow((size_t *)this, 0x20uLL, 7);
  }
  else {
    *((void *)this + 2) = v7 + 2;
  }
  unint64_t v8 = *(void *)a3;
  __n128 result = *(__n128 *)(a3 + 8);
  v7->n128_u64[0] = *a2;
  v7->n128_u64[1] = v8;
  v7[1] = result;
  return result;
}

uint64_t RB::Device::glyph_lock(RB::Device *this)
{
  uint64_t result = *((void *)this + 121);
  if (!result)
  {
    uint64_t result = CGGlyphLockCreate();
    *((void *)this + 121) = result;
  }
  return result;
}

void RB::Coverage::Glyphs::show(float32x2_t **this, uint64_t size, int a3)
{
  v15[1] = *MEMORY[0x263EF8340];
  uint64_t v6 = *((unsigned int *)this + 4);
  if (v6 > 0x100)
  {
    unint64_t v8 = (CGPoint *)malloc_type_malloc(16 * v6, 0x6E40C33uLL);
    if (!v8)
    {
LABEL_13:
      free(v8);
      return;
    }
  }
  else
  {
    MEMORY[0x270FA5388](this, 16 * v6);
    unint64_t v8 = (CGPoint *)((char *)v15 - ((v7 + 15) & 0x1FFFFFFFF0));
    bzero(v8, v7);
  }
  uint64_t v9 = *((unsigned int *)this + 4);
  if (v9)
  {
    __int32 v10 = this[1];
    uint64_t v11 = (float64x2_t *)v8;
    do
    {
      float32x2_t v12 = *v10++;
      *v11++ = vcvtq_f64_f32(v12);
      --v9;
    }
    while (v9);
  }
  int v13 = rb_clip_mode(*((unsigned __int8 *)this + 52));
  if (*(unsigned __int8 *)(size + 140) != v13) {
    RB::CGContext::set_aliasing_mode_slow(size, v13);
  }
  CGContextSetFont(*(CGContextRef *)size, (CGFontRef)*this);
  CGContextSetFontRenderingStyle();
  if (a3) {
    CGTextDrawingMode v14 = kCGTextClip;
  }
  else {
    CGTextDrawingMode v14 = kCGTextFill;
  }
  CGContextSetTextDrawingMode(*(CGContextRef *)size, v14);
  CGContextSetShouldDrawBitmapRuns();
  CGContextShowGlyphsAtPositions(*(CGContextRef *)size, (const CGGlyph *)&this[1][*((unsigned int *)this + 4)], v8, *((unsigned int *)this + 4));
  if (v6 >= 0x101) {
    goto LABEL_13;
  }
}

void RB::Coverage::Glyphs::fill(float32x2_t **this, RB::CGContext *a2, const RB::Fill::Color *a3, uint16x4_t a4)
{
  if (*((_DWORD *)this + 4) < 2u
    || ((a4.i32[0] = 1.0, *((short float *)a3 + 3) == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
      ? (_ZF = *((float *)a2 + 33) == 1.0)
      : (_ZF = 0),
        _ZF ? (BOOL v8 = *((_DWORD *)a2 + 34) == 2) : (BOOL v8 = 0),
        v8))
  {
    if (*((unsigned char *)a2 + 121)) {
      BOOL v17 = *((unsigned char *)a3 + 9) == 0;
    }
    else {
      BOOL v17 = 1;
    }
    if (!v17 && *((unsigned __int8 *)a2 + 120) != *((unsigned __int8 *)a3 + 8)
      || (a4.i16[0] = *((_WORD *)a2 + 56), *(short float *)a4.i16 != *(short float *)a3)
      || (a4.i16[0] = *((_WORD *)a2 + 57), *(short float *)a4.i16 != *((short float *)a3 + 1))
      || (a4.i16[0] = *((_WORD *)a2 + 58), *(short float *)a4.i16 != *((short float *)a3 + 2))
      || (a4.i16[0] = *((_WORD *)a2 + 59), *(short float *)a4.i16 != *((short float *)a3 + 3)))
    {
      RB::CGContext::set_fill_color_slow(a2, a3, a4);
    }
    RB::Coverage::Glyphs::show(this, (uint64_t)a2, 0);
  }
  else
  {
    RB::CGContext::save(a2);
    _H1 = *((_WORD *)a3 + 3);
    __asm { FCVT            S1, H1 }
    RB::CGContext::set_alpha(a2, *((float *)a2 + 33) * _S1);
    v18[0] = (float64x2_t)xmmword_2142181C0;
    v18[1] = (float64x2_t)xmmword_2142181D0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    double v14 = RB::Coverage::Glyphs::bounds((RB::Coverage::Glyphs *)this, v18, 0);
    RB::Bounds::Bounds(v21, *(float32x2_t *)&v14, v15);
    RB::CGContext::begin_layer((uint64_t)a2, 1.0, v21[0], v21[1]);
    v18[0].f64[0] = *(float64_t *)a3;
    LOWORD(v18[0].f64[1]) = *((_WORD *)a3 + 4);
    HIWORD(v18[0].f64[0]) = COERCE_UNSIGNED_INT(1.0);
    if (*((unsigned char *)a2 + 121) && BYTE1(v18[0].f64[1]) && *((unsigned __int8 *)a2 + 120) != LOBYTE(v18[0].f64[1])
      || (v16.i16[0] = *((_WORD *)a2 + 56), *(short float *)v16.i16 != *(short float *)v18[0].f64)
      || (v16.i16[0] = *((_WORD *)a2 + 57), *(short float *)v16.i16 != *((short float *)v18[0].f64 + 1))
      || (v16.i16[0] = *((_WORD *)a2 + 58), *(short float *)v16.i16 != *((short float *)v18[0].f64 + 2))
      || (v16.i16[0] = *((_WORD *)a2 + 59), *(short float *)v16.i16 != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))))
    {
      RB::CGContext::set_fill_color_slow(a2, (const RB::Fill::Color *)v18, v16);
    }
    RB::Coverage::Glyphs::show(this, (uint64_t)a2, 0);
    RB::CGContext::end_layer((CGContextRef *)a2);
    RB::CGContext::restore(a2);
  }
}

uint64_t RB::debug_float(RB *this, const char *a2)
{
  RB::Config::debug_value(this, &v6);
  int v2 = v6;
  uint64_t v4 = RB::Config::float_value((const __CFString *)v6, v3);
  if (v2) {
    CFRelease(v2);
  }
  return v4;
}

uint64_t RB::Config::float_value(const __CFString *this, const void *a2)
{
  DoubleBoolean Value = 0.0;
  if (!this) {
    goto LABEL_8;
  }
  CFTypeID v4 = CFGetTypeID(this);
  if (v4 != CFNumberGetTypeID())
  {
    if (v4 == CFStringGetTypeID())
    {
      DoubleBoolean Value = CFStringGetDoubleValue(this);
      goto LABEL_7;
    }
LABEL_8:
    uint64_t v5 = 0;
    return v5 | LODWORD(DoubleValue);
  }
  float valuePtr = 0.0;
  if (!CFNumberGetValue((CFNumberRef)this, kCFNumberFloatType, &valuePtr)) {
    goto LABEL_8;
  }
  DoubleBoolean Value = valuePtr;
LABEL_7:
  uint64_t v5 = 0x100000000;
  return v5 | LODWORD(DoubleValue);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::render(float32x2_t *a1, uint64_t a2)
{
  CFTypeID v4 = (float64x2_t *)a1[6];
  uint64_t v5 = (float32x2_t *)a1[3];
  _H0 = a1[5].i16[2];
  __asm { FCVT            S8, H0 }
  unsigned int v11 = a1[5].i16[3] & 0x3F;
  *(double *)&float32x2_t v12 = (*(double (**)(float32x2_t *, void))(*(void *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v25, v12, v13);
  int v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5) {
    goto LABEL_10;
  }
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v25[0].f64[0], *(int32x2_t *)&v25[0].f64[1]))
  {
    int v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v25, v14, _S8);
    goto LABEL_11;
  }
  int v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4) {
    goto LABEL_10;
  }
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11) {
    goto LABEL_10;
  }
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::Primitive::clip(a1 + 8, (CGContext **)a2);
  v25[0] = (float64x2_t)xmmword_2142181C0;
  v25[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  float32x2_t v18 = RB::Coverage::Primitive::bounds(a1 + 8, v25, (int8x16_t)xmmword_2142181C0, (int32x4_t)xmmword_2142181D0, v16, v17);
  RB::Bounds::Bounds(v28, v18, v19);
  RB::Fill::Gradient::fill((uint64_t)&a1[14], (RB::CGContext *)a2, *(double *)v28, *(double *)&v28[1], v20, v21, v22, v23, v24);
  RB::CGContext::restore((RB::CGContext *)a2);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::bounds(uint64_t a1, int8x16_t a2, int32x4_t a3, int8x16_t a4, int32x4_t a5)
{
  return RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), *(float64x2_t **)(a1 + 48), a2, a3, a4, a5);
}

void RB::Coverage::Primitive::clip(float32x2_t *this, CGContext **a2)
{
  if (this[5].i8[4] == 1) {
    return;
  }
  if (!this[5].i8[4])
  {
    unsigned int v3 = *a2;
LABEL_4:
    double v4 = *MEMORY[0x263F001A8];
    double v5 = *(double *)(MEMORY[0x263F001A8] + 8);
    double v6 = *(double *)(MEMORY[0x263F001A8] + 16);
    double v7 = *(double *)(MEMORY[0x263F001A8] + 24);
LABEL_5:
    CGContextClipToRect(v3, *(CGRect *)&v4);
    return;
  }
  if ((this[5].i8[6] & 5) != 0)
  {
    RB::Coverage::Primitive::make_image_mask(this, (RB::CGContext *)a2, &mask);
    CGImageRef v9 = mask;
    unsigned int v3 = *a2;
    if (!mask) {
      goto LABEL_4;
    }
    v33.origin.double x = v28;
    v33.origin.double y = v29;
    v33.size.double width = v30;
    v33.size.double height = v31;
    CGContextClipToMask(v3, v33, mask);
    CFRelease(v9);
  }
  else
  {
    int v10 = rb_clip_mode(this[5].u8[5]);
    if (*((unsigned __int8 *)a2 + 140) != v10) {
      RB::CGContext::set_aliasing_mode_slow((uint64_t)a2, v10);
    }
    if (this[5].i8[4] == 2)
    {
      LODWORD(v11) = this[4].i32[1];
      if (*(float *)&v11 == 0.0)
      {
        __asm { FMOV            V2.2S, #1.0 }
        _D2.i32[0] = this[4].i32[0];
        float32x2_t v22 = vmul_f32(*this, _D2);
        float32x2_t v23 = vmul_f32(this[1], _D2);
        unsigned int v3 = *a2;
        double v4 = v22.f32[0];
        double v5 = v22.f32[1];
        double v6 = v23.f32[0];
        double v7 = v23.f32[1];
        goto LABEL_5;
      }
    }
    RB::Coverage::Primitive::add_path(this, a2, v11, v12, v13, v14, v15, v16);
    float v25 = this[4].f32[1];
    if (v25 != 0.0)
    {
      CGContextReplacePathWithStrokedPath(*a2);
    }
    uint64_t v26 = *a2;
    CGContextClip(v26);
  }
}

void sub_214121FC4(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

atomic_uint *anonymous namespace'::make_single_element_path<RBPathMakeRoundedRect::RoundedRectArgs>(RBPathMakeRoundedRect::RoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*)#2}::__invoke(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void anonymous namespace'::make_single_element_path<RBPathMakeRoundedRect::RoundedRectArgs>(RBPathMakeRoundedRect::RoundedRectArgs &&,CGAffineTransform const*)::Info::~Info()
{
}

uint64_t RB::Refcount<RBPath anonymous namespace'::make_single_element_path<RBPathMakeRoundedRect::RoundedRectArgs>(RBPathMakeRoundedRect::RoundedRectArgs &&,CGAffineTransform const*)::Info,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::render(float32x2_t *a1, int32x2_t *a2)
{
  double v4 = (float64x2_t *)a1[6];
  double v5 = (float32x2_t *)a1[3];
  _H0 = a1[5].i16[2];
  __asm { FCVT            S8, H0 }
  unsigned int v11 = a1[5].i16[3] & 0x3F;
  *(double *)&float32x2_t v12 = (*(double (**)(float32x2_t *, void))(*(void *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)&v17, v12, v13);
  int v14 = 0;
  if ((float32x2_t *)a2[11] != v5) {
    goto LABEL_10;
  }
  if (!RB::Bounds::contains(a2 + 12, *(int32x2_t *)&v17, *(int32x2_t *)((char *)&v17 + 8)))
  {
    int v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow((uint64_t)a2, v4, v5, v11, &v17, v14, _S8);
    goto LABEL_11;
  }
  int v14 = 1;
  if ((float64x2_t *)a2[10] != v4) {
    goto LABEL_10;
  }
  LODWORD(v15) = a2[16].i32[1];
  if (*(float *)&v15 != _S8 || a2[17].i32[0] != v11) {
    goto LABEL_10;
  }
LABEL_11:
  RB::Coverage::Primitive::fill(a1 + 8, (RB::CGContext *)a2, (const RB::Fill::Color *)&a1[14], v15);
}

void RB::Coverage::Primitive::fill(float32x2_t *this, RB::CGContext *a2, const RB::Fill::Color *a3, double a4)
{
  if (!this[5].i8[4]) {
    return;
  }
  if (this[5].i8[4] == 1)
  {
    if (*((unsigned char *)a2 + 121)) {
      _ZF = *((unsigned char *)a3 + 9) == 0;
    }
    else {
      _ZF = 1;
    }
    if (!_ZF && *((unsigned __int8 *)a2 + 120) != *((unsigned __int8 *)a3 + 8)
      || (LOWORD(a4) = *((_WORD *)a2 + 56), *(short float *)&a4 != *(short float *)a3)
      || (LOWORD(a4) = *((_WORD *)a2 + 57), *(short float *)&a4 != *((short float *)a3 + 1))
      || (LOWORD(a4) = *((_WORD *)a2 + 58), *(short float *)&a4 != *((short float *)a3 + 2))
      || (LOWORD(a4) = *((_WORD *)a2 + 59), *(short float *)&a4 != *((short float *)a3 + 3)))
    {
      RB::CGContext::set_fill_color_slow(a2, a3, *(uint16x4_t *)&a4);
    }
    if ((this[5].i8[6] & 2) != 0) {
      CGContextBeginTransparencyLayer(*(CGContextRef *)a2, 0);
    }
    BOOL v8 = *(CGContext **)a2;
    ClipBoundingBodouble x = CGContextGetClipBoundingBox((CGContextRef)*(void *)a2);
    CGImageRef v9 = v8;
    goto LABEL_16;
  }
  if ((this[5].i8[6] & 5) == 0)
  {
    LODWORD(a4) = this[4].i32[1];
    if (*(float *)&a4 == 0.0)
    {
      if (*((unsigned char *)a2 + 121) && *((unsigned char *)a3 + 9) && *((unsigned __int8 *)a2 + 120) != *((unsigned __int8 *)a3 + 8)
        || (LOWORD(a4) = *((_WORD *)a2 + 56), *(short float *)&a4 != *(short float *)a3)
        || (LOWORD(a4) = *((_WORD *)a2 + 57), *(short float *)&a4 != *((short float *)a3 + 1))
        || (LOWORD(a4) = *((_WORD *)a2 + 58), *(short float *)&a4 != *((short float *)a3 + 2))
        || (LOWORD(a4) = *((_WORD *)a2 + 59), *(short float *)&a4 != *((short float *)a3 + 3)))
      {
        RB::CGContext::set_fill_color_slow(a2, a3, *(uint16x4_t *)&a4);
      }
      CGPathDrawingMode v17 = kCGPathFill;
    }
    else
    {
      if (*((unsigned char *)a2 + 131) && *((unsigned char *)a3 + 9) && *((unsigned __int8 *)a2 + 130) != *((unsigned __int8 *)a3 + 8)
        || *((short float *)a2 + 61) != *(short float *)a3
        || *((short float *)a2 + 62) != *((short float *)a3 + 1)
        || *((short float *)a2 + 63) != *((short float *)a3 + 2)
        || *((short float *)a2 + 64) != *((short float *)a3 + 3))
      {
        RB::CGContext::set_stroke_color_slow(a2, a3, *(uint16x4_t *)&a4);
        LODWORD(a4) = this[4].i32[1];
      }
      CGPathDrawingMode v17 = kCGPathStroke;
    }
    int v18 = rb_clip_mode(this[5].u8[5]);
    if (*((unsigned __int8 *)a2 + 140) != v18) {
      RB::CGContext::set_aliasing_mode_slow((uint64_t)a2, v18);
    }
    if (this[5].i8[4] != 2)
    {
      RB::Coverage::Primitive::add_path(this, (CGContextRef *)a2, v19, v20, v21, v22, v23, v24);
      if ((this[5].i8[6] & 2) != 0) {
        CGContextBeginTransparencyLayer(*(CGContextRef *)a2, 0);
      }
      CGContextDrawPath(*(CGContextRef *)a2, v17);
      goto LABEL_17;
    }
    if ((this[5].i8[6] & 2) != 0) {
      CGContextBeginTransparencyLayer(*(CGContextRef *)a2, 0);
    }
    __asm { FMOV            V0.2S, #1.0 }
    _D0.i32[0] = this[4].i32[0];
    float32x2_t v29 = vmul_f32(*this, _D0);
    float32x2_t v30 = vmul_f32(this[1], _D0);
    CGImageRef v9 = *(CGContext **)a2;
    ClipBoundingBox.origin.double x = v29.f32[0];
    ClipBoundingBox.origin.double y = v29.f32[1];
    ClipBoundingBox.size.double width = v30.f32[0];
    ClipBoundingBox.size.double height = v30.f32[1];
    if (this[4].f32[1] != 0.0)
    {
      CGContextStrokeRect(v9, ClipBoundingBox);
LABEL_17:
      if ((this[5].i8[6] & 2) != 0)
      {
        int v10 = *(CGContext **)a2;
        CGContextEndTransparencyLayer(v10);
      }
      return;
    }
LABEL_16:
    CGContextFillRect(v9, ClipBoundingBox);
    goto LABEL_17;
  }
  RB::Coverage::Primitive::make_image_mask(this, a2, &v31);
  float32x2_t v12 = v31;
  if (v31)
  {
    if (*((unsigned char *)a2 + 121) && *((unsigned char *)a3 + 9) && *((unsigned __int8 *)a2 + 120) != *((unsigned __int8 *)a3 + 8)
      || (v11.i16[0] = *((_WORD *)a2 + 56), *(short float *)v11.i16 != *(short float *)a3)
      || (v11.i16[0] = *((_WORD *)a2 + 57), *(short float *)v11.i16 != *((short float *)a3 + 1))
      || (v11.i16[0] = *((_WORD *)a2 + 58), *(short float *)v11.i16 != *((short float *)a3 + 2))
      || (v11.i16[0] = *((_WORD *)a2 + 59), *(short float *)v11.i16 != *((short float *)a3 + 3)))
    {
      RB::CGContext::set_fill_color_slow(a2, a3, v11);
    }
    if ((this[5].i8[6] & 2) != 0) {
      CGContextBeginTransparencyLayer(*(CGContextRef *)a2, 0);
    }
    CGContextSaveGState(*(CGContextRef *)a2);
    CGFloat v13 = v32;
    CGFloat v14 = v33;
    CGFloat v15 = v34;
    CGFloat v16 = v35;
    v38.origin.double x = v32;
    v38.origin.double y = v33;
    v38.size.double width = v34;
    v38.size.double height = v35;
    CGContextClipToMask(*(CGContextRef *)a2, v38, v12);
    v39.origin.double x = v13;
    v39.origin.double y = v14;
    v39.size.double width = v15;
    v39.size.double height = v16;
    CGContextFillRect(*(CGContextRef *)a2, v39);
    CGContextRestoreGState(*(CGContextRef *)a2);
    if ((this[5].i8[6] & 2) != 0) {
      CGContextEndTransparencyLayer(*(CGContextRef *)a2);
    }
    CFRelease(v12);
  }
}

void sub_214122558(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

void RB::Coverage::Primitive::add_path(float32x2_t *this, CGContextRef *a2, double a3, double a4, double a5, double a6, double a7, int32x4_t a8)
{
  int v8 = this[5].u8[4];
  float v11 = this[4].f32[0];
  __asm { FMOV            V3.2S, #1.0 }
  _D3.f32[0] = v11;
  float32x2_t v17 = vmul_f32(*this, _D3);
  float32x2_t v18 = vmul_f32(this[1], _D3);
  switch(this[5].i8[4])
  {
    case 0:
      float v33 = *a2;
      double v34 = *MEMORY[0x263F001A0];
      double v35 = *(double *)(MEMORY[0x263F001A0] + 8);
      double v36 = *(double *)(MEMORY[0x263F001A0] + 16);
      double v37 = *(double *)(MEMORY[0x263F001A0] + 24);
      goto LABEL_17;
    case 1:
      CGRect v38 = *a2;
      *(CGRect *)&double v34 = CGContextGetClipBoundingBox(*a2);
      float v33 = v38;
      goto LABEL_17;
    case 2:
      goto LABEL_14;
    case 3:
    case 4:
      float32x4_t v26 = *(float32x4_t *)this[2].f32;
      int32x4_t v27 = vceqzq_f32(v26);
      if ((vminvq_u32((uint32x4_t)v27) & 0x80000000) != 0)
      {
LABEL_14:
        float v33 = *a2;
        double v34 = v17.f32[0];
        double v35 = v17.f32[1];
        double v36 = v18.f32[0];
        double v37 = v18.f32[1];
LABEL_17:
        CGContextAddRect(v33, *(CGRect *)&v34);
      }
      else
      {
        v27.i32[0] = 3;
        a8.i32[0] = this[5].u8[4];
        float32x4_t v28 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vceqq_s32(a8, v27)), 0), (int8x16_t)vmulq_f32(v26, (float32x4_t)vdupq_n_s32(0x3F48C8C9u)), (int8x16_t)v26);
        BOOL v29 = v8 != 3;
        if (v11 != 1.0
          || (vminvq_u32((uint32x4_t)vceqq_f32(v28, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 0))) & 0x80000000) != 0)
        {
          uint64_t RoundedRect = RBPathMakeRoundedRect(v17.f32[0], v17.f32[1], v18.f32[0], v18.f32[1], (float)(v11 * v28.f32[0]), v28.f32[0], v29, 0);
          uint64_t v32 = v31;
          RBPathRelease(0, 0x21421C340);
        }
        else
        {
          uint64_t RoundedRect = RBPathMakeUnevenRoundedRect(v17.f32[0], v17.f32[1], v18.f32[0], v18.f32[1], v28.f32[0], v28.f32[1], v28.f32[2], v28.f32[3], v29, 0);
          uint64_t v32 = v44;
          RBPathRelease(0, 0x21421C340);
        }
        uint64_t v45 = (const CGPath *)RoundedRect;
        unint64_t v46 = *a2;
        unint64_t v47 = RBPathCopyCGPath(v45, v32);
        CGContextAddPath(v46, v47);
        if (v47) {
          CFRelease(v47);
        }
        RBPathRelease((uint64_t)v45, v32);
      }
      break;
    case 5:
      CGRect v39 = *a2;
      double v40 = v17.f32[0];
      double v41 = v17.f32[1];
      double v42 = v18.f32[0];
      double v43 = v18.f32[1];
      CGContextAddEllipseInRect(v39, *(CGRect *)&v40);
      break;
    case 6:
    case 7:
    case 8:
      double v19 = *a2;
      if (v8 == 7) {
        int v20 = 1;
      }
      else {
        int v20 = 2;
      }
      if (v8 == 6) {
        CGLineCap v21 = kCGLineCapButt;
      }
      else {
        CGLineCap v21 = v20;
      }
      CGContextSetLineCap(v19, v21);
      CGContextMoveToPoint(*a2, COERCE_FLOAT(*this), COERCE_FLOAT(HIDWORD(*(unint64_t *)this)));
      double v22 = *a2;
      float32x2_t v23 = vadd_f32(this[1], *this);
      double v24 = v23.f32[0];
      double v25 = v23.f32[1];
      CGContextAddLineToPoint(v22, v24, v25);
      break;
    case 9:
    case 0xA:
    case 0xB:
      abort();
    default:
      return;
  }
}

void sub_214122874(_Unwind_Exception *a1)
{
  RBPathRelease(v1, v2);
  _Unwind_Resume(a1);
}

uint64_t RBPathMakeRoundedRect(double a1, double a2, double a3, double a4, double a5, double a6, uint64_t a7, _OWORD *a8)
{
  if (a5 == 0.0 && a6 == 0.0) {
  if (!CGRectIsNull(*(CGRect *)&a1))
  }
  {
    if (a8)
    {
      long long v10 = a8[1];
      *(_OWORD *)&v11.a = *a8;
      *(_OWORD *)&v11.c = v10;
      *(_OWORD *)&v11.tdouble x = a8[2];
      if (!CGAffineTransformIsIdentity(&v11)) {
        operator new();
      }
    }
    operator new();
  }
  return 0;
}

__n128 RB::CGContext::restore(RB::CGContext *this)
{
  CGContextRestoreGState(*(CGContextRef *)this);
  uint64_t v2 = (char *)this + 152;
  if (*((void *)this + 51)) {
    uint64_t v2 = (char *)*((void *)this + 51);
  }
  uint64_t v3 = (*((_DWORD *)this + 104) - 1);
  double v4 = &v2[64 * v3];
  long long v6 = *((_OWORD *)v4 + 1);
  __n128 result = *((__n128 *)v4 + 2);
  long long v7 = *(_OWORD *)v4;
  *(_OWORD *)((char *)this + 126) = *(_OWORD *)(v4 + 46);
  *((_OWORD *)this + 6) = v6;
  *((__n128 *)this + 7) = result;
  *((_OWORD *)this + 5) = v7;
  *((_DWORD *)this + 104) = v3;
  return result;
}

void RB::CGContext::save(RB::CGContext *this)
{
  uint64_t v2 = (char *)this + 152;
  unsigned int v3 = *((_DWORD *)this + 104);
  if (*((_DWORD *)this + 105) < v3 + 1)
  {
    RB::vector<RB::CGContext::GState,4ul,unsigned int>::reserve_slow((char *)this + 152, v3 + 1);
    unsigned int v3 = *((_DWORD *)this + 104);
  }
  double v4 = (char *)*((void *)this + 51);
  if (!v4) {
    double v4 = v2;
  }
  double v5 = &v4[64 * (unint64_t)v3];
  long long v6 = *((_OWORD *)this + 5);
  long long v7 = *((_OWORD *)this + 6);
  long long v8 = *((_OWORD *)this + 8);
  *((_OWORD *)v5 + 2) = *((_OWORD *)this + 7);
  *((_OWORD *)v5 + 3) = v8;
  *(_OWORD *)double v5 = v6;
  *((_OWORD *)v5 + 1) = v7;
  ++*((_DWORD *)this + 104);
  CGContextSaveGState(*(CGContextRef *)this);
  *((unsigned char *)this + 141) = 1;
}

uint64_t __copy_helper_block_e8_32c38_ZTSN2RB14refcounted_ptrINS_6DeviceEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 32);
  if (v2) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 8), 1u, memory_order_relaxed);
  }
  *(void *)(result + 32) = v2;
  return result;
}

_DWORD *RB::DisplayList::Transform::add_color_from_to(_DWORD *this, const RB::Fill::Color *a2, const RB::Fill::Color *a3)
{
  double v5 = this;
  int v6 = this[10];
  if (this[11] < (v6 + 1))
  {
    this = RB::vector<RB::DisplayList::Transform::Term,1ul,unsigned int>::reserve_slow(this, v6 + 1);
    int v6 = v5[10];
  }
  long long v7 = (_DWORD *)*((void *)v5 + 4);
  if (!v7) {
    long long v7 = v5;
  }
  long long v8 = &v7[8 * v6];
  *long long v8 = 2;
  uint64_t v9 = *(void *)a2;
  *((_WORD *)v8 + 8) = *((_WORD *)a2 + 4);
  *((void *)v8 + 1) = v9;
  uint64_t v10 = *(void *)a3;
  *((_WORD *)v8 + 13) = *((_WORD *)a3 + 4);
  *(void *)((char *)v8 + 18) = v10;
  ++v5[10];
  return this;
}

void RB::RenderFrame::~RenderFrame(RB::RenderFrame *this)
{
  RB::RenderFrame::will_render(this);
  RB::RenderFrame::end_encoding((id *)this);
  uint64_t v2 = *(void *)this;
  if (*(void *)this) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 8), 1u, memory_order_relaxed);
  }
  unsigned int v3 = (os_unfair_lock_s *)*((void *)this + 1);
  if (v3) {
    atomic_fetch_add_explicit((atomic_uint *volatile)&v3[2], 1u, memory_order_relaxed);
  }
  id v4 = *((id *)this + 3);
  double v5 = v4;
  int v6 = *((_DWORD *)this + 21);
  long long v7 = (void *)*((void *)this + 2);
  uint64_t v35 = MEMORY[0x263EF8330];
  uint64_t v36 = 3321888768;
  double v37 = ___ZN2RB11RenderFrameD2Ev_block_invoke;
  CGRect v38 = &__block_descriptor_60_e8_32c40_ZTSN2RB14refcounted_ptrINS_8DrawableEEE40c38_ZTSN2RB14refcounted_ptrINS_6DeviceEEE48c59_ZTSN2RB8objc_ptrIPU22objcproto11RBEncodable11objc_objectEE_e28_v16__0___MTLCommandBuffer__8l;
  if (v3) {
    atomic_fetch_add_explicit((atomic_uint *volatile)&v3[2], 1u, memory_order_relaxed);
  }
  CGRect v39 = v3;
  if (v2) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 8), 1u, memory_order_relaxed);
  }
  uint64_t v40 = v2;
  int v42 = v6;
  id v41 = v4;
  [v7 addCompletedHandler:&v35];
  long long v8 = (void *)*((void *)this + 2);
  if (*((unsigned char *)this + 80))
  {
    uint64_t v9 = objc_msgSend(v8, "commitAndWaitUntilSubmitted", v35, v36, v37, v38);
  }
  else
  {
    objc_msgSend(v8, "commit", v35, v36, v37, v38);
    uint64_t v9 = 0;
  }
  if ((*((unsigned char *)this + 80) & 1) != 0 && (v9 & 1) == 0) {
    uint64_t v9 = [*((id *)this + 2) waitUntilScheduled];
  }
  if (v3)
  {
    double v10 = RB::current_time_seconds((RB *)v9);
    RB::Drawable::submit_frame(v3, (const unint64_t *)this + 4, v10 - *((double *)this + 9));
  }
  [(id)RB::Device::capture_scope((RB::Device *)v2) endScope];
  if (RB::Device::prune_caches((dispatch_queue_t *)v2)) {
    [*(id *)(v2 + 16) collectResources];
  }

  uint64_t v11 = v40;
  if (v40 && atomic_fetch_add_explicit((atomic_uint *volatile)(v40 + 8), 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  float32x2_t v12 = v39;
  if (v39 && atomic_fetch_add_explicit((atomic_uint *volatile)&v39[2], 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(os_unfair_lock_s *))(*(void *)&v12->_os_unfair_lock_opaque + 8))(v12);
  }

  if (v3 && atomic_fetch_add_explicit((atomic_uint *volatile)&v3[2], 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(os_unfair_lock_s *))(*(void *)&v3->_os_unfair_lock_opaque + 8))(v3);
    if (!v2) {
      goto LABEL_30;
    }
  }
  else if (!v2)
  {
    goto LABEL_30;
  }
  if (atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 8), 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
LABEL_30:

  CGFloat v13 = (void *)*((void *)this + 34);
  if (v13) {
    CGFloat v14 = (char *)*((void *)this + 34);
  }
  else {
    CGFloat v14 = (char *)this + 240;
  }
  unint64_t v15 = *((unsigned int *)this + 70);
  if (v15)
  {
    for (unint64_t i = 0; i < v15; ++i)
    {
      uint64_t v17 = *(void *)&v14[8 * i];
      *(void *)&v14[8 * i] = 0;
      if (v17)
      {
        RB::RenderFrame::QueueDeleter::operator()((uint64_t)v13, v17);
        unint64_t v15 = *((unsigned int *)this + 70);
      }
    }
    CGFloat v13 = (void *)*((void *)this + 34);
  }
  if (v13) {
    free(v13);
  }
  RB::UntypedTable::~UntypedTable((RB::RenderFrame *)((char *)this + 152));
  float32x2_t v18 = (void *)*((void *)this + 15);
  if (v18)
  {
    do
    {
      double v19 = (void *)*v18;
      operator delete(v18);
      float32x2_t v18 = v19;
    }
    while (v19);
  }
  *((void *)this + 15) = 0;
  int v20 = RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::buffer::~buffer(*((void **)this + 14));
  free(v20);
  CGLineCap v21 = (void *)*((void *)this + 13);
  uint64_t v22 = v21[1];
  if (v22)
  {
    float32x2_t v23 = v21 + 3;
    do
    {
      uint64_t v25 = *v23++;
      uint64_t v24 = v25;
      if (v25)
      {
        float32x4_t v26 = (_DWORD *)(v24 & 0xFFFFFFFFFFFFFFFELL);
        int v27 = *(_DWORD *)((v24 & 0xFFFFFFFFFFFFFFFELL) + 8) - 1;
        v26[2] = v27;
        if (!v27) {
          (*(void (**)(_DWORD *))(*(void *)v26 + 8))(v26);
        }
      }
      --v22;
    }
    while (v22);
  }
  float32x4_t v28 = RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::buffer::~buffer(v21);
  free(v28);
  BOOL v29 = (void *)*((void *)this + 12);
  uint64_t v30 = v29[1];
  if (v30)
  {
    uint64_t v31 = (_DWORD **)(v29 + 3);
    do
    {
      uint64_t v32 = *v31;
      if (*v31)
      {
        int v33 = v32[2] - 1;
        v32[2] = v33;
        if (!v33) {
          (*(void (**)(_DWORD *))(*(void *)v32 + 8))(v32);
        }
      }
      ++v31;
      --v30;
    }
    while (v30);
  }
  double v34 = RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::buffer::~buffer(v29);
  free(v34);
}

void sub_2141230D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, atomic_uint *a13, atomic_uint *a14, id a15)
{
  if (a14 && atomic_fetch_add_explicit(a14 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)a14 + 8))(a14);
  }
  if (a13 && atomic_fetch_add_explicit(a13 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)a13 + 8))(a13);
  }

  if (v17 && atomic_fetch_add_explicit(v17 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v17 + 8))(v17);
    if (!v16) {
      goto LABEL_12;
    }
  }
  else if (!v16)
  {
    goto LABEL_12;
  }
  if (atomic_fetch_add_explicit(v16 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v16 + 8))(v16);
  }
LABEL_12:

  RB::vector<std::unique_ptr<RB::RenderQueue,RB::RenderFrame::QueueDeleter>,4ul,unsigned int>::~vector(v15 + 240);
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)(v15 + 152));
  int v20 = *(void **)(v15 + 120);
  if (v20)
  {
    do
    {
      CGLineCap v21 = (void *)*v20;
      operator delete(v20);
      int v20 = v21;
    }
    while (v21);
  }
  *(void *)(v15 + 120) = 0;
  RB::shared_vector<RB::Function const*>::~shared_vector((void **)(v15 + 112));
  RB::shared_vector<RB::RenderFrame::TextureRef>::~shared_vector(v15 + 104);
  RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::~shared_vector(v15 + 96);

  _Unwind_Resume(a1);
}

void *RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::buffer::~buffer(void *a1)
{
  if (*a1)
  {
    uint64_t v2 = (void *)RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::buffer::~buffer();
    free(v2);
  }
  return a1;
}

uint64_t RB::Device::capture_scope(RB::Device *this)
{
  uint64_t result = *((void *)this + 9);
  if (!result)
  {
    unsigned int v3 = objc_msgSend((id)objc_msgSend(MEMORY[0x263F12800], "sharedCaptureManager"), "newCaptureScopeWithCommandQueue:", RB::Device::command_queue((id *)this));

    *((void *)this + 9) = v3;
    if (v3)
    {
      [v3 setLabel:@"RenderBox"];
      return *((void *)this + 9);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void RB::DisplayList::render_many(long long *a1, uint64_t a2, unint64_t a3, int32x2_t *a4)
{
  uint64_t v63 = *MEMORY[0x263EF8340];
  uint64_t v51 = a2;
  if (!a3) {
    return;
  }
  long long v7 = a1[1];
  long long v56 = *a1;
  long long v57 = v7;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  RB::Heap::Heap((RB::Heap *)v61, v62, 1024, 0);
  {
    uint64_t v45 = RB::debug_int((RB *)"RB_PRINT_TREE", v44);
    char v46 = v45 & 1;
    if ((v45 & 0xFF00000000) == 0) {
      char v46 = 0;
    }
    RB::DisplayList::render_many(RB::RenderParams const&,objc_object  {objcproto10MTLTexture}*({block_pointer})(void),unsigned long,RB::DisplayList::Renderable const*)::print_tree = v46;
  }
  if (RB::DisplayList::render_many(RB::RenderParams const&,objc_object  {objcproto10MTLTexture}*({block_pointer})(void),unsigned long,RB::DisplayList::Renderable const*)::print_tree)
  {
    memset(__dst, 0, 41);
    RB::SexpString::push(__dst, "render");
    long long v8 = a4 + 3;
    int32x2_t v9 = vdup_n_s32(0x7F7FFFFFu);
    unint64_t v10 = a3;
    do
    {
      RB::SexpString::push(__dst, "root-layer");
      uint32x2_t v11 = (uint32x2_t)vceq_s32(*v8, (int32x2_t)0x8000000080000000);
      if ((vpmin_u32(v11, v11).u32[0] & 0x80000000) != 0)
      {
        float32x2_t v12 = (float32x2_t)0x100000001000000;
        CGFloat v13 = (_DWORD *)v9;
      }
      else
      {
        float32x2_t v12 = vcvt_f32_s32(v8[-1]);
        CGFloat v13 = (_DWORD *)vcvt_f32_s32(*v8);
      }
      v48[0] = (_DWORD *)v12;
      v48[1] = v13;
      RB::Rect::operator std::string(v48, __p);
      if (v50 >= 0) {
        CGFloat v14 = __p;
      }
      else {
        CGFloat v14 = (void **)__p[0];
      }
      RB::SexpString::print(__dst, 0, (const char *)v14);
      if (v50 < 0) {
        operator delete(__p[0]);
      }
      RB::DisplayList::Contents::print(*(RB::DisplayList::Contents **)&v8[-3], __dst);
      RB::SexpString::pop(__dst);
      v8 += 8;
      --v10;
    }
    while (v10);
    RB::SexpString::pop(__dst);
    RB::SexpString::newline(__dst);
    if ((__dst[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v15 = __dst;
    }
    else {
      uint64_t v15 = (std::string *)__dst[0].__r_.__value_.__r.__words[0];
    }
    fputs((const char *)v15, (FILE *)*MEMORY[0x263EF8348]);
    if (SHIBYTE(__dst[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst[0].__r_.__value_.__l.__data_);
    }
  }
  uint64_t v53 = 0;
  uint64_t v54 = 0;
  unint64_t v55 = 8;
  if (a3 == 1 && (uint32x2_t v16 = (uint32x2_t)vceq_s32(a4[3], (int32x2_t)a1[1]), (vpmin_u32(v16, v16).u32[0] & 0x80000000) != 0)) {
    int v17 = a4[5].i32[0];
  }
  else {
    int v17 = 1;
  }
  int v47 = v17;
  double v19 = (_DWORD *)RB::Heap::emplace<RB::DisplayList::RootTexture,objc_object  {objcproto10MTLTexture}*({block_pointer}&)(void),RB::RenderPass::InitialState &>((RB::Heap *)v61, &v51, &v47);
  if (a3 <= 1) {
    uint64_t v22 = 1;
  }
  else {
    uint64_t v22 = a3;
  }
  float32x2_t v23 = (__n128 *)&a4[6];
  do
  {
    uint64_t v24 = v23[-3].n128_i64[0];
    if (!v24) {
      uint64_t v24 = RB::DisplayList::Contents::empty_contents(0);
    }
    if (*(unsigned char *)(v24 + 400)) {
      RB::precondition_failure((RB *)"unable to render unoptimized content", v18);
    }
    unint64_t v25 = v23[-3].n128_u64[1];
    uint64_t v26 = v24 + 320;
    if (v25) {
      int v27 = (uint64_t *)(v25 + 8);
    }
    else {
      int v27 = (uint64_t *)v26;
    }
    uint64_t v28 = *v27;
    unsigned __int32 v29 = v23[-1].n128_u32[2];
    if (!v28)
    {
      if (v29 != 2) {
        goto LABEL_51;
      }
      unsigned int v30 = v47 == 2;
LABEL_37:
      uint64_t v31 = v23;
      goto LABEL_38;
    }
    unsigned int v30 = v47 == 2;
    if (v29 == 2) {
      goto LABEL_37;
    }
    uint64_t v31 = 0;
LABEL_38:
    RB::DisplayList::Layer::make_task(v26, (MTLPixelFormat)&v56, 0, v30, v28, v31, (uint64_t *)v48, v23[-2].n128_f64[0], v23[-2].n128_f64[1], v20, v21);
    uint64_t v32 = v48[0];
    RB::RenderTask::set_texture(v48[0], v19, v23[-1].n128_f64[0]);
    if (v32) {
      ++v32[2];
    }
    uint64_t v33 = v54;
    float32x2_t v18 = (const char *)(v54 + 1);
    if (v55 < v54 + 1)
    {
      RB::vector<RBDevice *,8ul,unsigned long>::reserve_slow(__dst, (size_t)v18);
      uint64_t v33 = v54;
    }
    if (v53) {
      double v34 = (std::string *)v53;
    }
    else {
      double v34 = __dst;
    }
    if (v32)
    {
      int v35 = v32[2];
      v34->__r_.__value_.__r.__words[v33] = (std::string::size_type)v32;
      uint64_t v54 = v33 + 1;
      if (!v35)
      {
        (*(void (**)(_DWORD *))(*(void *)v32 + 8))(v32);
        int v35 = v32[2];
      }
      v32[2] = v35 - 1;
      if (v35 == 1) {
        (*(void (**)(_DWORD *))(*(void *)v32 + 8))(v32);
      }
    }
    else
    {
      v34->__r_.__value_.__r.__words[v33] = 0;
      uint64_t v54 = v33 + 1;
    }
LABEL_51:
    v23 += 4;
    --v22;
  }
  while (v22);
  if (v54)
  {
    if (v53) {
      uint64_t v36 = (RB::RenderTask **)v53;
    }
    else {
      uint64_t v36 = (RB::RenderTask **)__dst;
    }
    RB::RenderTask::schedule_many(v54, v36, *(double *)&v57);
    (*(void (**)(_DWORD *, long long *))(*(void *)v19 + 32))(v19, &v56);
LABEL_58:
    int v37 = v19[2] - 1;
    v19[2] = v37;
    if (!v37) {
      (*(void (**)(_DWORD *))(*(void *)v19 + 8))(v19);
    }
    CGRect v38 = v53;
    unint64_t v39 = v54;
    if (v53) {
      uint64_t v40 = (std::string *)v53;
    }
    else {
      uint64_t v40 = __dst;
    }
    if (v54)
    {
      unint64_t v41 = 0;
      do
      {
        int v42 = (_DWORD *)*((void *)&v40->__r_.__value_.__l.__data_ + v41);
        if (v42)
        {
          int v43 = v42[2] - 1;
          v42[2] = v43;
          if (!v43)
          {
            (*(void (**)(_DWORD *))(*(void *)v42 + 8))(v42);
            unint64_t v39 = v54;
          }
        }
        ++v41;
      }
      while (v41 < v39);
      goto LABEL_69;
    }
  }
  else
  {
    if (v19) {
      goto LABEL_58;
    }
LABEL_69:
    CGRect v38 = v53;
  }
  if (v38) {
    free(v38);
  }
  RB::Heap::~Heap((RB::Heap *)v61);
}

void sub_214123848(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  RB::Heap::~Heap(v25);
  _Unwind_Resume(a1);
}

void RB::DisplayList::Layer::make_task(uint64_t a1@<X0>, MTLPixelFormat a2@<X1>, __n128 *a3@<X2>, unsigned int a4@<W3>, uint64_t a5@<X4>, __n128 *a6@<X5>, uint64_t *a7@<X8>, double a8@<D0>, double a9@<D1>, double a10@<D2>, int32x2_t a11@<D3>)
{
  uint64_t v148 = a6;
  int8x8_t v149 = a7;
  char v12 = a4;
  v179[129] = *MEMORY[0x263EF8340];
  CGFloat v14 = (uint64_t *)(a2 + 8);
  uint64_t v139 = *(void *)(a2 + 8);
  int v138 = *(unsigned __int8 *)(a2 + 28);
  double v145 = (unsigned __int8 *)(a2 + 28);
  double v146 = (RB::DisplayList::Layer *)a1;
  v175.n128_f64[0] = a8;
  v175.n128_f64[1] = a9;
  BOOL v174 = (a4 & 2) != 0;
  __n128 v15 = v175;
  __n128 v173 = v175;
  int v16 = *(_DWORD *)(a1 + 60);
  if ((v16 & 0x20) != 0)
  {
    *(unsigned char *)(a2 + 28) = *(unsigned char *)(a2 + 29);
    if (((a4 >> 1) & 1) == 0) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  if ((v16 & 8) != 0)
  {
    unsigned __int8 v19 = 1;
    uint64_t v21 = 25;
    uint64_t v22 = v146;
  }
  else
  {
    if ((v16 & 2) != 0)
    {
      unsigned __int8 v19 = *(unsigned char *)(a2 + 29) & 0xFE;
      int v20 = 1;
    }
    else
    {
      char v18 = *(unsigned char *)(a2 + 29);
      if ((v16 & 4) != 0) {
        unsigned __int8 v19 = v18 | 1;
      }
      else {
        unsigned __int8 v19 = *(unsigned char *)(a2 + 29);
      }
      int v20 = (v16 & 4) == 0 && (v18 & 1) == 0;
    }
    uint64_t v22 = v146;
    unsigned int v23 = RB::DisplayList::Layer::max_depth(v146);
    int v24 = RB::max_color_depth(v23, *(unsigned __int8 *)(a2 + 30));
    uint64_t v21 = RB::color_depth_layer_format(v24, v20, **(void **)a2);
  }
  *CGFloat v14 = v21;
  *double v145 = v19;
  a1 = RB::DisplayList::Layer::compute_roi(v22, (int32x2_t *)&v175, (int32x2_t *)&v173, &v174, a3, v15);
  if (!a1)
  {
    *CGFloat v14 = v139;
    *double v145 = v138;
LABEL_24:
    *int8x8_t v149 = 0;
    return;
  }
  if (v174) {
LABEL_17:
  }
    a1 = RB::Bounds::inset((int32x2_t *)&v175, 0xFFFFFFFF, 0xFFFFFFFF, v15.n128_f64[0], a9, a10, a11);
LABEL_18:
  uint32x2_t v25 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)&v175.n128_i8[8]);
  if ((vpmax_u32(v25, v25).u32[0] & 0x80000000) != 0) {
    goto LABEL_24;
  }
  uint32x2_t v26 = (uint32x2_t)vcgt_s32(*(int32x2_t *)&v175.n128_i8[8], (int32x2_t)0x800000008000);
  if ((vpmax_u32(v26, v26).u32[0] & 0x80000000) != 0) {
    goto LABEL_24;
  }
  *int8x8_t v149 = 0;
  int v152 = *((_DWORD *)v146 + 15);
  if ((v152 & 0x10) != 0)
  {
    MEMORY[0x270FA5388](a1, a2);
    memset(v136, 0, 96);
    unsigned int v153 = (int *)v136;
    RB::BoundsAccumulator::reset((RB::BoundsAccumulator *)v136);
    if (v12)
    {
      RB::BoundsAccumulator::add(v153, (int32x2_t *)&v175);
      int v27 = 1;
      if (a5) {
        goto LABEL_22;
      }
    }
    else
    {
      int v27 = 0;
      if (a5) {
        goto LABEL_22;
      }
    }
  }
  else
  {
    unsigned int v153 = 0;
    int v27 = v12 & 1;
    if (a5)
    {
LABEL_22:
      BOOL v28 = v148 != 0;
LABEL_28:
      unsigned __int32 v29 = 0;
      int v140 = 2 * v27;
      long long v142 = (char *)v179;
      uint64_t v143 = (RB::Heap *)(a2 + 80);
      int8x8_t v30 = (int8x8_t)vdup_n_s32(0x7F7FFFFFu);
      char v31 = v152;
      long long v141 = v14;
      while (1)
      {
        LODWORD(v32) = 6 * *(void *)(a2 + 16) * HIDWORD(*(void *)(a2 + 16));
        if ((int)v32 <= 0x400000) {
          uint64_t v32 = 0x400000;
        }
        else {
          uint64_t v32 = v32;
        }
        uint64_t v154 = v32;
        int v172 = 0;
        v35.n128_f64[0] = RB::Heap::emplace<RB::DisplayList::LayerTask,RB::DisplayList::Layer const&,MTLPixelFormat &,RB::ColorSpace &,RB::Bounds &,RB::Bounds &,BOOL &>(v143, (uint64_t)v146, v14, v145, (uint64_t)&v175, (uint64_t *)&v173, (char *)&v174);
        if (!v29)
        {
          v33[8].n128_u8[0] = (v33[8].n128_u8[0] & 0xFD | v140) ^ 2;
          if (v28)
          {
            __n128 v35 = *v148;
            uint64_t v148 = 0;
            v33[9] = v35;
          }
          else
          {
            uint64_t v148 = 0;
          }
        }
        double v150 = v33 + 10;
        float64x2_t v168 = (size_t *)a2;
        float64x2_t v169 = &v171;
        float64x2_t v170 = &v172;
        float64x2_t v171 = v33 + 10;
        n128_u64 = v33[12].n128_u64;
        int32x4_t v155 = (int *)v33;
        if (a5)
        {
          uint64_t v36 = 0;
          float32x4_t v144 = v33 + 13;
          while (v36 < v154 && v172 <= 19999)
          {
            v35.n128_u64[1] = v175.n128_u64[1];
            __n128 v176 = v175;
            int v37 = *(float32x2_t **)(a5 + 24);
            if (v37)
            {
              RB::Bounds::Bounds(v167, v37[2], v37[3]);
              RB::Bounds::intersect((int32x2_t *)&v176, v167[0], v167[1]);
              uint64_t v38 = *(void *)&v37[1] & 1;
              v35.n128_u64[0] = (unint64_t)vcgtz_s32(*(int32x2_t *)&v176.n128_i8[8]);
              if ((vpmin_u32((uint32x2_t)v35.n128_u64[0], (uint32x2_t)v35.n128_u64[0]).u32[0] & 0x80000000) != 0
                && !v38)
              {
                *(double *)&float32x2_t v39 = (*(double (**)(uint64_t, void))(*(void *)a5 + 144))(a5, 0);
                RB::Bounds::Bounds(v166, v39, v40);
                RB::Bounds::intersect((int32x2_t *)&v176, v166[0], v166[1]);
                LODWORD(v38) = 0;
              }
            }
            else
            {
              LODWORD(v38) = 1;
            }
            uint32x2_t v41 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)&v176.n128_i8[8]);
            v35.n128_u64[0] = (unint64_t)vpmax_u32(v41, v41);
            unsigned __int32 v42 = v35.n128_u32[0];
            if ((v35.n128_u32[0] & 0x80000000) == 0 && v38)
            {
              if ((*(_WORD *)(a5 + 46) & 0x200) == 0) {
                goto LABEL_50;
              }
              *(double *)&float32x2_t v43 = (*(double (**)(uint64_t, void))(*(void *)a5 + 144))(a5, 0);
              RB::Bounds::Bounds(v165, v43, v44);
              RB::Bounds::intersect((int32x2_t *)&v176, v165[0], v165[1]);
              v35.n128_u64[0] = (unint64_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)&v176.n128_i8[8]);
              v35.n128_u64[0] = (unint64_t)vpmax_u32((uint32x2_t)v35.n128_u64[0], (uint32x2_t)v35.n128_u64[0]);
              unsigned __int32 v42 = v35.n128_u32[0];
            }
            if ((v42 & 0x80000000) != 0)
            {
              a5 = *(void *)(a5 + 8);
              if (!a5) {
                break;
              }
            }
            else
            {
LABEL_50:
              if ((*(_WORD *)(a5 + 46) & 0x200) != 0)
              {
                uint64_t v45 = *(void *)(a5 + 48);
                if ((*(_WORD *)(v45 + 60) & 0x2001) != 0)
                {
                  if ((v31 & 0x10) != 0)
                  {
                    v158[0] = v176;
                    v164[0] = 0;
                    v164[1] = 0;
                    if (RB::DisplayList::Layer::compute_roi((RB::DisplayList::Layer *)v45, (int32x2_t *)v158, v164, (BOOL *)&v161, &v175, v176))
                    {
                      v35.n128_u32[0] = 0;
                      float v46 = *(float *)(v45 + 48);
                      if (v46 == 0.0) {
                        float v46 = 1.0;
                      }
                      float v47 = v46;
                      float32x2_t v48 = vrecpe_f32((float32x2_t)LODWORD(v46));
                      float32x2_t v49 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v47), v48), v48);
                      v49.i32[0] = vmul_f32(v49, vrecps_f32((float32x2_t)LODWORD(v47), v49)).u32[0];
                      uint32x2_t v50 = (uint32x2_t)vceq_s32(*(int32x2_t *)&v158[0].n128_i8[8], (int32x2_t)0x8000000080000000);
                      int8x8_t v51 = (int8x8_t)vdup_lane_s32(vcgt_s32((int32x2_t)v35.n128_u64[0], (int32x2_t)vpmin_u32(v50, v50)), 0);
                      *(float32x2_t *)&double v52 = RB::Bounds::Bounds(v163, vmul_n_f32((float32x2_t)vbsl_s8(v51, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32((int32x2_t)v158[0].n128_u64[0])), v49.f32[0]), vmul_n_f32((float32x2_t)vbsl_s8(v51, v30, (int8x8_t)vcvt_f32_s32(*(int32x2_t *)&v158[0].n128_i8[8])), v49.f32[0]));
                      if (RB::BoundsAccumulator::intersects((RB::BoundsAccumulator *)v153, v163, v52, v53, v54, v55, v56, v57))
                      {
                        break;
                      }
                    }
                  }
                  else if (v150->n128_u64[0])
                  {
                    break;
                  }
                }
                if (*(unsigned char *)(v45 + 64) == 2
                  && ((*(uint64_t (**)(void, __n128 *, int *))(**(void **)(v45 + 24) + 112))(*(void *)(v45 + 24), &v176, v153) & 1) != 0)
                {
                  break;
                }
              }
              uint64_t v58 = *(void *)(a5 + 8);
              if ((v31 & 0x10) != 0) {
                RB::BoundsAccumulator::add(v153, (int32x2_t *)&v176);
              }
              __int16 v59 = *(_WORD *)(a5 + 46);
              if ((v59 & 0x200) != 0)
              {
                uint64_t v61 = *(void *)(a5 + 48);
                if (RB::may_discard_alpha(v59 & 0x3F)) {
                  uint64_t v62 = 0;
                }
                else {
                  uint64_t v62 = 2;
                }
                RB::DisplayList::Layer::make_task(v164, v61, a2, &v175, v62, 0, 0, v176.n128_f64[0], v176.n128_f64[1]);
                if (v164[0])
                {
                  if ((atomic_load_explicit((atomic_uchar *volatile)&_ZGVZNK2RB11DisplayList5Layer9make_taskERNS0_11RenderStateENS_6BoundsEPKS4_jPKNS0_4ItemEPKDv4_fE12allow_inline, memory_order_acquire) & 1) == 0&& __cxa_guard_acquire(&_ZGVZNK2RB11DisplayList5Layer9make_taskERNS0_11RenderStateENS_6BoundsEPKS4_jPKNS0_4ItemEPKDv4_fE12allow_inline))
                  {
                    unsigned __int16 v110 = RB::debug_BOOL((RB *)"RB_INLINE_LAYERS", v63);
                    if ((_BYTE)v110) {
                      BOOL v111 = 0;
                    }
                    else {
                      BOOL v111 = v110 >= 0x100u;
                    }
                    char v112 = !v111;
                    _ZZNK2RB11DisplayList5Layer9make_taskERNS0_11RenderStateENS_6BoundsEPKS4_jPKNS0_4ItemEPKDv4_fE12allow_inline = v112;
                    __cxa_guard_release(&_ZGVZNK2RB11DisplayList5Layer9make_taskERNS0_11RenderStateENS_6BoundsEPKS4_jPKNS0_4ItemEPKDv4_fE12allow_inline);
                  }
                  int32x2_t v64 = v164[0];
                  if ((*(unsigned char *)(a2 + 31) & 2) == 0) {
                    goto LABEL_86;
                  }
                  if (!_ZZNK2RB11DisplayList5Layer9make_taskERNS0_11RenderStateENS_6BoundsEPKS4_jPKNS0_4ItemEPKDv4_fE12allow_inline) {
                    goto LABEL_86;
                  }
                  char v65 = *(unsigned char *)(*(void *)v164 + 128);
                  if ((v65 & 8) != 0) {
                    goto LABEL_86;
                  }
                  if (*(void *)(*(void *)v164 + 24)) {
                    goto LABEL_86;
                  }
                  uint64_t v67 = (int *)(v61 + 60);
                  unsigned int v66 = *(_DWORD *)(v61 + 60);
                  if ((v66 & 0x10) != 0 || (v66 & 1) != 0 && *(unsigned char *)(v61 + 67)) {
                    goto LABEL_86;
                  }
                  if ((v66 & 6) != 0)
                  {
                    int v68 = (v66 >> 2) & 1;
                    if ((v66 & 2) != 0) {
                      int v68 = 0;
                    }
                    if (v68 != *((unsigned __int8 *)v155 + 72)) {
                      goto LABEL_86;
                    }
                  }
                  if ((*((_DWORD *)v146 + 15) ^ *(_DWORD *)(v61 + 60)) & 8 | *(_DWORD *)(v61 + 60) & 0x80
                    || *(unsigned char *)(v61 + 64)
                    || *(float *)(v61 + 48) != 0.0)
                  {
                    goto LABEL_86;
                  }
                  unint64_t v99 = *(void **)(v61 + 16);
                  uint64_t v137 = (uint64_t *)(v61 + 16);
                  float v151 = (int *)(v61 + 60);
                  if (v99)
                  {
                    while (1)
                    {
                      int v100 = (*(uint64_t (**)(void *))(*v99 + 88))(v99);
                      uint64_t v67 = v151;
                      if (!v100) {
                        break;
                      }
                      unint64_t v99 = (void *)v99[1];
                      if (!v99)
                      {
                        char v65 = *(unsigned char *)(*(void *)&v64 + 128);
                        goto LABEL_122;
                      }
                    }
LABEL_86:
                    uint64_t v69 = RB::RenderTask::bytes(*(RB::RenderTask **)&v64, (MTLPixelFormat)v63);
                    RB::DisplayList::LayerTask::add_task((uint64_t)v155, a5, 0, (uint64_t *)v164);
                    v36 += v69;
                    uint64_t v60 = a5;
                    if (v64)
                    {
LABEL_87:
                      int v70 = *(_DWORD *)(*(void *)&v64 + 8) - 1;
                      *(_DWORD *)(*(void *)&v64 + 8) = v70;
                      if (!v70) {
                        (*(void (**)(int32x2_t))(**(void **)&v64 + 8))(v64);
                      }
                    }
                  }
                  else
                  {
LABEL_122:
                    int v101 = v143;
                    if (v65)
                    {
                      v158[0] = v176;
                      float64x2_t v103 = *(float32x2_t **)(a5 + 24);
                      if (v103)
                      {
                        RB::Bounds::Bounds(v162, v103[2], v103[3]);
                        RB::Bounds::intersect((int32x2_t *)v158, v162[0], v162[1]);
                        uint64_t v67 = v151;
                      }
                    }
                    else
                    {
                      unint64_t v102 = *(void *)(*(void *)&v64 + 56);
                      v158[0].n128_u64[0] = *(void *)(*(void *)&v64 + 104);
                      v158[0].n128_u64[1] = v102;
                    }
                    int v161 = *v67 & 1;
                    int v160 = 1;
                    int v159 = 0;
                    v163[0] = 0;
                    double v104 = v101;
                    int v105 = v101;
                    uint64_t v106 = v67;
                    RB::Heap::emplace<RB::DisplayList::SpillItem,RB::Shader::SpillMode,unsigned int &,int,RB::BlendMode,RB::Bounds &,decltype(nullptr)>(v104, &v161, v67, &v160, &v159, v158);
                    float v151 = (int *)v107;
                    v163[0].i32[0] = 2;
                    int v161 = *(_WORD *)(a5 + 46) & 0x3F;
                    _ZN2RB4Heap7emplaceINS_11DisplayList9SpillItemEJNS_6Shader9SpillModeERjRKDF16_RKNS_9BlendModeERNS_6BoundsERPNS2_11LayerFilterEEEEPT_DpOT0_(v105, (int *)v163, v106, (__int16 *)(a5 + 44), &v161, v158, v137);
                    uint64_t v60 = v108;
                    *(void *)(v108 + 24) = *(void *)(a5 + 24);
                    _ZZNK2RB11DisplayList5Layer9make_taskERNS0_11RenderStateENS_6BoundsEPKS4_jPKNS0_4ItemEPKDv4_fENK3__2clES9_((uint64_t *)&v168, (uint64_t)v151);
                    uint64_t v109 = v155;
                    int32x2_t v64 = v164[0];
                    RB::DisplayList::LayerTask::append_task(v155, *(void *)v164, (void **)&v171, (unsigned int *)&v172);
                    *((unsigned char *)v109 + 128) |= 8u;
                    if (v64) {
                      goto LABEL_87;
                    }
                  }
                  char v31 = v152;
                }
                else
                {
                  uint64_t v60 = a5;
                }
                if (*(unsigned char *)(v61 + 64) == 2)
                {
                  *(void *)(a2 + 32) = v155;
                  (*(void (**)(void, MTLPixelFormat, __n128 *, double, double))(**(void **)(v61 + 24)
                                                                                           + 104))(*(void *)(v61 + 24), a2, &v175, v176.n128_f64[0], v176.n128_f64[1]);
                  *(void *)(a2 + 32) = 0;
                  v36 += *(void *)(a2 + 72);
                  *(void *)(a2 + 72) = 0;
                }
                goto LABEL_93;
              }
              uint64_t v60 = a5;
LABEL_93:
              if ((v38 & 1) == 0)
              {
                float64x2_t v71 = *(void **)(v60 + 24);
                if (v71)
                {
                  float v151 = (int *)v58;
                  uint64_t v72 = 1;
                  uint64_t v73 = -1;
                  char v74 = 1;
                  do
                  {
                    uint64_t v75 = (unsigned char *)(v71[1] & 0xFFFFFFFFFFFFFFFELL);
                    if ((v75[45] & 1) == 0)
                    {
                      v35.n128_u32[0] = 0;
                      uint32x2_t v76 = (uint32x2_t)vceq_s32(*(int32x2_t *)&v176.n128_i8[8], (int32x2_t)0x8000000080000000);
                      int8x8_t v77 = (int8x8_t)vdup_lane_s32(vcgt_s32((int32x2_t)v35.n128_u64[0], (int32x2_t)vpmin_u32(v76, v76)), 0);
                      if (((*(uint64_t (**)(unsigned char *, double, double))(*(void *)v75 + 32))(v75, COERCE_DOUBLE(vbsl_s8(v77, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32((int32x2_t)v176.n128_u64[0]))), COERCE_DOUBLE(vbsl_s8(v77, v30, (int8x8_t)vcvt_f32_s32(*(int32x2_t *)&v176.n128_i8[8])))) & 1) == 0)
                      {
                        char v74 = 0;
                        v73 &= ~v72;
                      }
                    }
                    v72 *= 2;
                    float64x2_t v71 = (void *)*v71;
                  }
                  while (v71);
                  if ((v74 & 1) == 0)
                  {
                    unsigned int v78 = v155[54];
                    if (v78
                      && (unint64_t v79 = v144->n128_u64[0],
                          unsigned int v80 = v78 - 1,
                          *(void *)(v144->n128_u64[0] + 48 * (v78 - 1)) == *(void *)(v60 + 24)))
                    {
                      int v81 = v14;
                      int v85 = (int32x2_t *)(v79 + 48 * v80);
                      int32x2_t v86 = v85[3];
                      v85 += 3;
                      RB::Bounds::Union(v85 - 1, (int32x2_t)v176.n128_u64[0], *(int32x2_t *)&v176.n128_i8[8]);
                      int32x2_t v87 = vmul_s32(vzip1_s32(*v85, v86), vzip2_s32(*v85, v86));
                      signed __int32 v84 = vsub_s32(v87, vdup_lane_s32(v87, 1)).u32[0];
                      *(_DWORD *)(v79 + 48 * v80 + 40) = v172;
                      uint64_t v82 = v155;
                      int v83 = v155[54];
                    }
                    else
                    {
                      int v81 = v14;
                      uint64_t v82 = v155;
                      if (v155[55] < v78 + 1)
                      {
                        RB::vector<RB::DisplayList::LayerTask::ClipInfo,0ul,unsigned int>::reserve_slow((uint64_t)v144, v78 + 1);
                        uint64_t v82 = v155;
                        unsigned int v78 = v155[54];
                      }
                      RB::DisplayList::LayerTask::ClipInfo::ClipInfo(*((void *)v82 + 26) + 48 * v78, a2, *(void **)(v60 + 24), v172, v176.n128_f64[0], v176.n128_f64[1]);
                      int v83 = v82[54] + 1;
                      v82[54] = v83;
                      signed __int32 v84 = vmul_lane_s32(*(int32x2_t *)&v176.n128_i8[8], *(int32x2_t *)&v176.n128_i8[8], 1).u32[0];
                    }
                    uint64_t v88 = *((void *)v82 + 26);
                    unsigned int v89 = v83 - 1;
                    int v90 = *(unsigned __int8 *)(v88 + 48 * (v83 - 1) + 44);
                    unsigned int v91 = v82[50];
                    unsigned int v92 = v91 + 1;
                    if (v82[51] < v91 + 1)
                    {
                      RB::vector<RBColor,0ul,unsigned int>::reserve_slow((uint64_t)n128_u64, v92);
                      CGFloat v14 = v81;
                      unsigned int v91 = v155[50];
                      uint64_t v88 = *((void *)v155 + 26);
                      unsigned int v92 = v91 + 1;
                      unsigned int v93 = v155[54] - 1;
                    }
                    else
                    {
                      unsigned int v93 = v89;
                      CGFloat v14 = v81;
                    }
                    uint32x2_t v94 = v155;
                    uint64_t v95 = *((void *)v155 + 24) + 16 * v91;
                    *(void *)uint64_t v95 = v60;
                    *(_DWORD *)(v95 + 8) = v89;
                    v94[50] = v92;
                    v36 += v90 * (uint64_t)v84;
                    *(void *)(v88 + 48 * v93 + 8) &= v73;
                  }
                  char v31 = v152;
                  uint64_t v58 = (uint64_t)v151;
                }
              }
              (*(void (**)(uint64_t, MTLPixelFormat))(*(void *)v60 + 168))(v60, a2);
              if ((*(_WORD *)(v60 + 46) & 0x4000) != 0) {
                *((unsigned char *)v155 + 128) |= 0x10u;
              }
              long long v96 = (__n128 *)((v168[12] + 7) & 0xFFFFFFFFFFFFFFF8);
              if ((unint64_t)v96[1].n128_u64 > v168[13]) {
                long long v96 = (__n128 *)RB::Heap::alloc_slow(v168 + 10, 0x10uLL, 7);
              }
              else {
                v168[12] = (size_t)v96[1].n128_u64;
              }
              v96->n128_u64[0] = 0;
              v96->n128_u64[1] = v60;
              float64x2_t v97 = v169;
              int32x4_t v98 = v170;
              (*v169)->n128_u64[0] = (unint64_t)v96;
              *float64x2_t v97 = v96;
              ++*v98;
              a5 = v58;
              if (!v58) {
                break;
              }
            }
          }
        }
        long long v113 = (unsigned int *)v155;
        if (v155[54])
        {
          int v114 = *(_DWORD *)(*(void *)a2 + 92) + 1;
          *(_DWORD *)(*(void *)a2 + 92) = v114;
          RB::Heap::Heap((RB::Heap *)&v176, v142, 1024, 0);
          RB::UntypedTable::UntypedTable((uint64_t)v158, 0, 0, 0, 0, (RB::Heap *)&v176);
          unsigned int v115 = v113[54];
          if (v115)
          {
            uint64_t v116 = *((void *)v155 + 26);
            uint64_t v117 = v116 + 48 * v115;
            do
            {
              if (!*(_DWORD *)(v116 + 32))
              {
                *(_DWORD *)(v116 + 32) = v114;
                int v118 = *(void **)v116;
                if (*(void *)v116)
                {
                  uint64_t v119 = 1;
                  do
                  {
                    if ((*(void *)(v116 + 8) & v119) == 0)
                    {
                      unint64_t v120 = v118[1] & 0xFFFFFFFFFFFFFFFELL;
                      if ((*(unsigned char *)(v120 + 45) & 2) != 0)
                      {
                        int8x8_t v121 = *(uint64_t **)(v120 + 48);
                        int8x8_t v122 = RB::UntypedTable::lookup((RB::UntypedTable *)v158, v121, 0);
                        if (v122)
                        {
                          RB::Bounds::Union((int32x2_t *)v122, *(int32x2_t *)(v116 + 16), *(int32x2_t *)(v116 + 24));
                        }
                        else
                        {
                          int8x8_t v123 = (size_t *)(((unint64_t)v177 + 7) & 0xFFFFFFFFFFFFFFF8);
                          if ((unint64_t)(v123 + 2) > v178) {
                            int8x8_t v123 = (size_t *)RB::Heap::alloc_slow(v176.n128_u64, 0x10uLL, 7);
                          }
                          else {
                            CGSize v177 = v123 + 2;
                          }
                          *(_OWORD *)int8x8_t v123 = *(_OWORD *)(v116 + 16);
                          RB::UntypedTable::insert((size_t **)v158, (size_t *)v121, v123);
                        }
                      }
                      else
                      {
                        (*(void (**)(unint64_t, MTLPixelFormat))(*(void *)v120 + 48))(v120, a2);
                      }
                    }
                    v119 *= 2;
                    int v118 = (void *)*v118;
                  }
                  while (v118);
                }
              }
              v116 += 48;
            }
            while (v116 != v117);
          }
          long long v113 = (unsigned int *)v155;
          v156[0] = v155;
          v156[1] = &v175;
          v156[2] = a2;
          int v157 = v114;
          RB::UntypedTable::for_each((uint64_t)v158, (void (*)(const void *, const void *, void *))_ZZNK2RB5TableIPKNS_11DisplayList5LayerEPNS_6BoundsEE8for_eachIZNKS2_9make_taskERNS1_11RenderStateES5_PKS5_jPKNS1_4ItemEPKDv4_fE3__4EEvT_ENUlPKvSM_PvE_8__invokeESM_SM_SN_, v156);
          RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v158);
          RB::Heap::~Heap((RB::Heap *)&v176);
          CGFloat v14 = v141;
          char v31 = v152;
        }
        unint64_t v124 = v113[46];
        if (v124) {
          std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *,false>(*((void *)v113 + 22), (unint64_t *)(*((void *)v113 + 22) + 24 * v124), (uint64_t)&v176, 126 - 2 * __clz(v124), 1);
        }
        unint64_t v125 = v113[50];
        if (v125) {
          _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEELb0EEEvT1_SL_T0_NS_15iterator_traitsISL_E15difference_typeEb(*n128_u64, *n128_u64 + 16 * v125, 126 - 2 * __clz(v125), 1);
        }
        uint32x2_t v126 = (_DWORD *)*v149;
        if (*v149) {
          break;
        }
        *int8x8_t v149 = (uint64_t)v113;
        if ((v31 & 0x10) != 0) {
          goto LABEL_167;
        }
LABEL_168:
        BOOL v28 = v148 != 0;
        unsigned __int32 v29 = v113;
        if (!(a5 | (unint64_t)v148)) {
          goto LABEL_169;
        }
      }
      v35.n128_f64[0] = RB::RenderTask::set_continuation(*v149, (uint64_t)v113);
      *int8x8_t v149 = (uint64_t)v113;
      int v127 = v126[2] - 1;
      v126[2] = v127;
      if (!v127) {
        (*(void (**)(_DWORD *, double))(*(void *)v126 + 8))(v126, v35.n128_f64[0]);
      }
      if ((v31 & 0x10) == 0) {
        goto LABEL_168;
      }
LABEL_167:
      v35.n128_f64[0] = RB::BoundsAccumulator::reset((RB::BoundsAccumulator *)v153);
      goto LABEL_168;
    }
  }
  a5 = *(void *)v146;
  BOOL v28 = v148 != 0;
  if (*(void *)v146 | (unint64_t)v148) {
    goto LABEL_28;
  }
  v35.n128_f64[0] = RB::Heap::emplace<RB::DisplayList::LayerTask,RB::DisplayList::Layer const&,MTLPixelFormat &,RB::ColorSpace &,RB::Bounds &,RB::Bounds &,BOOL &>((RB::Heap *)(a2 + 80), (uint64_t)v146, v14, v145, (uint64_t)&v175, (uint64_t *)&v173, (char *)&v174);
  long long v113 = v135;
  *int8x8_t v149 = (uint64_t)v135;
  *((unsigned char *)v135 + 128) = (v135[32] & 0xFD | (2 * v27)) ^ 2;
LABEL_169:
  float32x2_t v128 = v146;
  float32x2_t v129 = (void *)*((void *)v146 + 2);
  if (v129)
  {
    do
    {
      if ((*(unsigned int (**)(void *, __n128))(*v129 + 40))(v129, v35) == 5)
      {
        uint64_t v130 = *(void *)(v34 + 32);
        if (v130)
        {
          if ((*(_WORD *)(v130 + 46) & 0x200) != 0)
          {
            RB::DisplayList::Layer::make_task(v158, *(void *)(v130 + 48), a2, &v175, 0, 0, 0, v175.n128_f64[0], v175.n128_f64[1]);
            RB::DisplayList::LayerTask::add_task((uint64_t)v113, v130, 0, (uint64_t *)v158);
            unint64_t v131 = v158[0].n128_u64[0];
            if (v158[0].n128_u64[0])
            {
              int v132 = *(_DWORD *)(v158[0].n128_u64[0] + 8) - 1;
              *(_DWORD *)(v158[0].n128_u64[0] + 8) = v132;
              if (!v132) {
                (*(void (**)(unint64_t))(*(void *)v131 + 8))(v131);
              }
            }
          }
        }
      }
      float32x2_t v129 = (void *)v129[1];
    }
    while (v129);
    float32x2_t v128 = v146;
    uint64_t v133 = *((void *)v146 + 2);
    long long v113 = (unsigned int *)*v149;
  }
  else
  {
    uint64_t v133 = 0;
  }
  *((void *)v113 + 21) = v133;
  if ((*((unsigned char *)v128 + 60) & 0x20) != 0)
  {
    if ((*(unsigned char *)(a2 + 31) & 4) != 0)
    {
      if (RB::RenderParams::srgb_alpha((RB::RenderParams *)a2, v34)) {
        char v134 = 4;
      }
      else {
        char v134 = 0;
      }
    }
    else
    {
      char v134 = 0;
    }
    *((unsigned char *)v113 + 128) = v113[32] & 0xFB | v134;
  }
  *CGFloat v14 = v139;
  *double v145 = v138;
}

void sub_214124924(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&_ZGVZNK2RB11DisplayList5Layer9make_taskERNS0_11RenderStateENS_6BoundsEPKS4_jPKNS0_4ItemEPKDv4_fE12allow_inline);
  unsigned int v3 = *(_DWORD **)(v1 + 328);
  if (v3)
  {
    int v4 = v3[2] - 1;
    v3[2] = v4;
    if (!v4) {
      (*(void (**)(_DWORD *))(*(void *)v3 + 8))(v3);
    }
  }
  double v5 = **(_DWORD ***)(v1 + 104);
  if (v5)
  {
    int v6 = v5[2] - 1;
    void v5[2] = v6;
    if (!v6) {
      (*(void (**)(_DWORD *))(*(void *)v5 + 8))(v5);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t RB::Coverage::Primitive::contains(uint64_t a1, uint64_t a2, float32x2_t a3, float32x2_t a4)
{
  long long v6 = *(_OWORD *)(a2 + 16);
  long long v7 = *(_OWORD *)(a2 + 32);
  v15[0] = vmulq_n_f64(*(float64x2_t *)a2, *(float *)(a1 + 32));
  v15[1] = v6;
  void v15[2] = v7;
  int v8 = *(unsigned __int8 *)(a1 + 44);
  if (!*(unsigned char *)(a1 + 44)) {
    return 0;
  }
  if (v8 == 1) {
    return 1;
  }
  char v11 = *(unsigned char *)(a1 + 46);
  if ((v11 & 4) != 0) {
    return 0;
  }
  uint64_t result = 0;
  if ((v11 & 1) == 0 && *(float *)(a1 + 36) <= 0.0)
  {
    if (*(unsigned __int8 *)(a1 + 45) <= 1u)
    {
      if ((v8 - 3) >= 3)
      {
        if (v8 == 2) {
          return RB::Rect::contains(a1, (uint64_t)v15, a3, a4);
        }
        if ((v8 - 9) < 3) {
          abort();
        }
      }
      else
      {
        float v12 = vmaxvq_f32(*(float32x4_t *)(a1 + 16));
        long long v14 = *(_OWORD *)a1;
        if (RB::Rect::inset((float32x2_t *)&v14, 0, v12)
          && (RB::Rect::contains((uint64_t)&v14, (uint64_t)v15, a3, a4) & 1) != 0)
        {
          return 1;
        }
        long long v13 = *(_OWORD *)a1;
        if (RB::Rect::inset((float32x2_t *)&v13, (float32x2_t)__PAIR64__(DWORD1(v13), LODWORD(v12)), 0.0)
          && (RB::Rect::contains((uint64_t)&v13, (uint64_t)v15, a3, a4) & 1) != 0)
        {
          return 1;
        }
      }
    }
    return 0;
  }
  return result;
}

BOOL RB::Rect::inset(float32x2_t *this, float32x2_t a2, float32_t a3)
{
  float32x2_t v3 = this[1];
  uint32x2_t v4 = (uint32x2_t)vceq_f32(v3, (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  int32x2_t v5 = (int32x2_t)vpmax_u32(v4, v4);
  if (v5.i32[0] < 0) {
    return 1;
  }
  a2.f32[1] = a3;
  float32x2_t v6 = vmla_f32(v3, (float32x2_t)0xC0000000C0000000, a2);
  uint32x2_t v7 = (uint32x2_t)vcltz_f32(v6);
  int32x2_t v8 = (int32x2_t)vpmax_u32(v7, v7);
  v5.i32[0] = -1;
  __int32 v9 = v8.i32[0];
  int8x8_t v10 = (int8x8_t)vdup_lane_s32(vcgt_s32(v8, v5), 0);
  BOOL v11 = v9 >= 0;
  *this = vadd_f32(*this, (float32x2_t)vbsl_s8(v10, (int8x8_t)a2, (int8x8_t)vmul_f32(v6, (float32x2_t)0x3F0000003F000000)));
  this[1] = (float32x2_t)vand_s8((int8x8_t)v6, v10);
  return v11;
}

uint64_t RB::Rect::contains(uint64_t a1, uint64_t a2, float32x2_t a3, float32x2_t a4)
{
  v31[4] = *(float32x2_t *)MEMORY[0x263EF8340];
  int32x4_t v7 = *(int32x4_t *)a2;
  long long v6 = *(_OWORD *)(a2 + 16);
  if (*(double *)(a2 + 8) == 0.0 && *(double *)&v6 == 0.0 || *(double *)v7.i64 == 0.0 && *((double *)&v6 + 1) == 0.0)
  {
    v7.i64[0] = *(void *)(a1 + 8);
    float32x2_t v8 = RB::operator*((float64x2_t *)a2, *(float32x2_t *)a1, v7);
    uint32x2_t v11 = (uint32x2_t)vceqz_f32(v9);
    if ((vpmax_u32(v11, v11).u32[0] & 0x80000000) == 0
      && (*(int32x2_t *)v10.i8 = vcltz_f32(v9),
          int32x4_t v12 = vcltzq_s32(v10),
          float32x2_t v13 = (float32x2_t)vbsl_s8(*(int8x8_t *)v12.i8, (int8x8_t)vadd_f32(v8, v9), (int8x8_t)v8),
          *(int32x2_t *)v12.i8 = vcltz_f32(a4),
          float32x2_t v14 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(v12), (int8x8_t)vadd_f32(a4, a3), (int8x8_t)a3),
          *(int32x2_t *)v12.i8 = vcge_f32(v14, v13),
          (vpmin_u32(*(uint32x2_t *)v12.i8, *(uint32x2_t *)v12.i8).u32[0] & 0x80000000) != 0))
    {
      uint32x2_t v27 = (uint32x2_t)vcge_f32(vadd_f32(v13, (float32x2_t)(*(void *)&v9 & 0x7FFFFFFF7FFFFFFFLL)), vadd_f32(v14, vabs_f32(a4)));
      unsigned __int32 v15 = vpmin_u32(v27, v27).u32[0] >> 31;
    }
    else
    {
      LOBYTE(v15) = 0;
    }
  }
  else
  {
    for (unint64_t i = 0; i != 4; ++i)
      v31[i] = vadd_f32((float32x2_t)vand_s8((int8x8_t)a4, (int8x8_t)vcltz_s32(vshl_n_s32((int32x2_t)__PAIR64__(i > 1, (i - 1) < 2), 0x1FuLL))), a3);
    float32x2_t v19 = v31[0];
    int32x2_t v20 = (int32x2_t)vsub_f32(v31[0], v29[0]);
    *(float *)v16.i32 = -*(float *)&v20.i32[1];
    LOBYTE(v15) = 0;
    if (vaddv_f32(vmul_f32((float32x2_t)vzip1_s32(v16, v20), v30)) <= 0.0)
    {
      unint64_t v21 = 0;
      do
      {
        unint64_t v22 = 0;
        do
        {
          unint64_t v23 = v22;
          if (v22 == 3) {
            break;
          }
          int v24 = &v29[v22];
          int32x2_t v25 = (int32x2_t)vsub_f32(v19, v24[1]);
          int32x2_t v16 = (int32x2_t)v24[5];
          *(float *)v17.i32 = -*(float *)&v25.i32[1];
          unint64_t v22 = v23 + 1;
        }
        while (vaddv_f32(vmul_f32((float32x2_t)vzip1_s32(v17, v25), (float32x2_t)v16)) <= 0.0);
        if (v23 <= 2) {
          break;
        }
        LOBYTE(v15) = v21 > 2;
        if (v21 == 3) {
          break;
        }
        float32x2_t v19 = v31[v21 + 1];
        int32x2_t v26 = (int32x2_t)vsub_f32(v19, v29[0]);
        *(float *)v16.i32 = -*(float *)&v26.i32[1];
        ++v21;
      }
      while (vaddv_f32(vmul_f32((float32x2_t)vzip1_s32(v16, v26), v30)) <= 0.0);
    }
  }
  return v15 & 1;
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Primitive>::contains@<X0>(uint64_t a1@<X0>, char w8_0@<W8>, int8x16_t a3@<Q0>, int32x4_t a4@<Q1>, int8x16_t a5@<Q2>, int32x4_t a6@<Q3>)
{
  float32x2_t v6 = *(float32x2_t *)a4.i8;
  float32x2_t v7 = *(float32x2_t *)a3.i8;
  if (*(unsigned char *)(a1 + 44) == 1)
  {
    a3.i32[0] = *(_DWORD *)(a1 + 112);
    if (*(float *)a3.i32 == 0.0)
    {
      w8_0 = 1;
    }
    else
    {
      v16[0] = RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), *(float64x2_t **)(a1 + 48), a3, a4, a5, a6);
      v16[1] = v11;
      w8_0 = RB::Rect::intersects(v16, v18, v7, v6, v12, v13, v14, v15) ^ 1;
    }
    return w8_0 & 1;
  }
  if (*(unsigned char *)(a1 + 44)) {
    return w8_0 & 1;
  }
  if (*(float *)(a1 + 112) != 1.0)
  {
    w8_0 = 0;
    return w8_0 & 1;
  }
  uint64_t v8 = *(void *)(a1 + 48);
  uint64_t v9 = a1 + 64;
  return RB::Coverage::Primitive::contains(v9, v8, *(float32x2_t *)a3.i8, *(float32x2_t *)a4.i8);
}

void *RB::vector<RBColor,0ul,unsigned int>::reserve_slow(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1);
  }
  uint64_t result = RB::details::realloc_vector<unsigned int,16ul>(*(void **)a1, (_DWORD *)(a1 + 12), v3);
  *(void *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,16ul>(void *a1, _DWORD *a2, unsigned int a3)
{
  uint32x2_t v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(16 * a3);
    size_t v6 = v5 >> 4;
    if (*a2 != (v5 >> 4))
    {
      float32x2_t v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7) {
        RB::precondition_failure((RB *)"allocation failure", v8);
      }
      uint32x2_t v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

uint64_t RB::DisplayList::LayerTask::ClipInfo::ClipInfo(uint64_t a1, MTLPixelFormat a2, void *a3, int a4, double a5, double a6)
{
  *(void *)a1 = a3;
  *(void *)(a1 + 8) = -1;
  *(double *)(a1 + 16) = a5;
  *(double *)(a1 + 24) = a6;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = a4;
  *(_DWORD *)(a1 + 40) = a4;
  *(_WORD *)(a1 + 44) = 0;
  if (a3)
  {
    float32x2_t v7 = a3;
    int v8 = 0;
    unint64_t v9 = *(void *)(a2 + 8);
    do
    {
      unint64_t v10 = v7[1] & 0xFFFFFFFFFFFFFFFELL;
      if ((*(unsigned char *)(v10 + 45) & 2) != 0)
      {
        if ((*(unsigned char *)(*(void *)(v10 + 48) + 60) & 8) != 0) {
          int v11 = 1;
        }
        else {
          int v11 = *((unsigned __int8 *)RB::pixel_format_traits(v9, a2) + 6);
        }
        v8 += v11;
        *(unsigned char *)(a1 + 44) = v8;
      }
      float32x2_t v7 = (void *)*v7;
    }
    while (v7);
  }
  return a1;
}

void *RB::vector<RB::DisplayList::LayerTask::ClipInfo,0ul,unsigned int>::reserve_slow(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1);
  }
  uint64_t result = RB::details::realloc_vector<unsigned int,48ul>(*(void **)a1, (_DWORD *)(a1 + 12), v3);
  *(void *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,48ul>(void *a1, _DWORD *a2, unsigned int a3)
{
  uint32x2_t v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(48 * a3);
    unint64_t v6 = v5 / 0x30;
    if (*a2 != (v5 / 0x30))
    {
      float32x2_t v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7) {
        RB::precondition_failure((RB *)"allocation failure", v8);
      }
      uint32x2_t v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

double RB::Heap::emplace<RB::DisplayList::LayerTask,RB::DisplayList::Layer const&,MTLPixelFormat &,RB::ColorSpace &,RB::Bounds &,RB::Bounds &,BOOL &>(RB::Heap *this, uint64_t a2, uint64_t *a3, unsigned __int8 *a4, uint64_t a5, uint64_t *a6, char *a7)
{
  unint64_t v14 = *((void *)this + 3);
  unint64_t v15 = (*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v15 + 224 > v14) {
    unint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0xE0uLL, 15);
  }
  else {
    *((void *)this + 2) = v15 + 224;
  }
  uint64_t v16 = *a3;
  unsigned __int8 v17 = *a4;
  double result = *(double *)a5;
  uint64_t v19 = *(void *)(a5 + 8);
  uint64_t v20 = *a6;
  uint64_t v21 = a6[1];
  char v22 = *a7;
  *(_DWORD *)(v15 + 8) = 1;
  *(_OWORD *)(v15 + 16) = 0u;
  *(_OWORD *)(v15 + 32) = 0u;
  *(void *)(v15 + 56) = v19;
  *(void *)(v15 + 64) = 0;
  *(_WORD *)(v15 + 72) = v17;
  *(unsigned char *)(v15 + 74) = 0;
  *(void *)(v15 + 80) = v16;
  *(void *)(v15 + 88) = 0;
  *(void *)unint64_t v15 = &unk_26C4E7018;
  *(void *)(v15 + 96) = a2;
  *(double *)(v15 + 104) = result;
  *(void *)(v15 + 112) = v20;
  *(void *)(v15 + 120) = v21;
  *(unsigned char *)(v15 + 128) = *(unsigned char *)(v15 + 128) & 0xE0 | v22;
  *(_OWORD *)(v15 + 144) = 0u;
  *(_OWORD *)(v15 + 160) = 0u;
  *(_OWORD *)(v15 + 176) = 0u;
  *(_OWORD *)(v15 + 192) = 0u;
  *(_OWORD *)(v15 + 208) = 0u;
  return result;
}

uint64_t RB::Heap::emplace<RB::DisplayList::RootTexture,objc_object  {objcproto10MTLTexture}*({block_pointer}&)(void),RB::RenderPass::InitialState &>(RB::Heap *this, uint64_t *a2, int *a3)
{
  unint64_t v6 = *((void *)this + 3);
  uint64_t result = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (result + 48 > v6) {
    uint64_t result = RB::Heap::alloc_slow((size_t *)this, 0x30uLL, 7);
  }
  else {
    *((void *)this + 2) = result + 48;
  }
  uint64_t v8 = *a2;
  int v9 = *a3;
  *(_DWORD *)(result + 8) = 1;
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(void *)uint64_t result = &unk_26C4EA5C0;
  *(void *)(result + 32) = v8;
  *(_DWORD *)(result + 40) = v9;
  *(_WORD *)(result + 44) = 0;
  return result;
}

void RB::DisplayList::LayerTask::~LayerTask(RB::DisplayList::LayerTask *this)
{
  uint64_t v2 = (void *)*((void *)this + 26);
  if (v2) {
    free(v2);
  }
  unsigned int v3 = (void *)*((void *)this + 24);
  if (v3) {
    free(v3);
  }
  uint32x2_t v4 = (void *)*((void *)this + 22);
  if (v4) {
    free(v4);
  }
  *(void *)this = &unk_26C4E8828;
  size_t v5 = (_DWORD *)*((void *)this + 11);
  if (v5)
  {
    int v6 = v5[2] - 1;
    void v5[2] = v6;
    if (!v6) {
      (*(void (**)(_DWORD *))(*(void *)v5 + 8))(v5);
    }
  }
  float32x2_t v7 = (_DWORD *)*((void *)this + 5);
  if (v7)
  {
    int v8 = v7[2] - 1;
    v7[2] = v8;
    if (!v8) {
      (*(void (**)(_DWORD *))(*(void *)v7 + 8))(v7);
    }
  }
  int v9 = (_DWORD *)*((void *)this + 4);
  if (v9)
  {
    int v10 = v9[2] - 1;
    uint64_t v9[2] = v10;
    if (!v10) {
      (*(void (**)(_DWORD *))(*(void *)v9 + 8))(v9);
    }
  }
  int v11 = (_DWORD *)*((void *)this + 3);
  if (v11)
  {
    int v12 = v11[2] - 1;
    float32x2_t v11[2] = v12;
    if (!v12) {
      (*(void (**)(_DWORD *))(*(void *)v11 + 8))(v11);
    }
  }
}

{
  uint64_t vars8;

  RB::DisplayList::LayerTask::~LayerTask(this);
  JUMPOUT(0x21669AC10);
}

void RB::Texture::~Texture(RB::Texture *this)
{
  *(void *)this = &unk_26C4EDD98;
  uint64_t v2 = (_DWORD *)*((void *)this + 3);
  if (v2)
  {
    int v3 = v2[2] - 1;
    v2[2] = v3;
    if (!v3) {
      (*(void (**)(_DWORD *))(*(void *)v2 + 8))(v2);
    }
  }

  JUMPOUT(0x21669AC10);
}

{
  _DWORD *v2;
  int v3;

  *(void *)this = &unk_26C4EDD98;
  uint64_t v2 = (_DWORD *)*((void *)this + 3);
  if (v2)
  {
    int v3 = v2[2] - 1;
    v2[2] = v3;
    if (!v3) {
      (*(void (**)(_DWORD *))(*(void *)v2 + 8))(v2);
    }
  }
}

_DWORD *RB::DisplayList::RootTexture::finalize(RB::DisplayList::RootTexture *this)
{
  *(void *)this = &unk_26C4ED180;
  uint64_t result = (_DWORD *)*((void *)this + 2);
  if (result)
  {
    int v2 = result[2] - 1;
    result[2] = v2;
    if (!v2) {
      return (_DWORD *)(*(uint64_t (**)(void))(*(void *)result + 8))();
    }
  }
  return result;
}

void RB::DisplayList::RootTexture::render(RB::DisplayList::RootTexture *this, void *a2)
{
  do
  {
    RB::RenderTaskTexture::render_dependencies(this, a2);
    if (!RB::DisplayList::RootTexture::make_texture((uint64_t)this, (MTLPixelFormat)a2)) {
      break;
    }
    RB::RenderPass::RenderPass(v17, a2, *((void *)this + 2), 0, *((unsigned int *)this + 10), 0);
    RB::RenderPass::set_label(v17, &cfstr_RbRootLayer.isa);
    uint64_t v5 = *((void *)this + 3);
    if (v5)
    {
      MTLPixelFormat v6 = 5;
      uint64_t v7 = *((void *)this + 3);
      do
      {
        v6 |= ((unint64_t)*(unsigned __int8 *)(v7 + 128) >> 1) & 8 | ((unint64_t)*(unsigned __int8 *)(v7 + 128) >> 2) & 2;
        uint64_t v7 = *(void *)(v7 + 48);
      }
      while (v7 && *(_DWORD *)(v5 + 12) == *(_DWORD *)(v7 + 12));
    }
    else
    {
      MTLPixelFormat v6 = MTLPixelFormatInvalid;
    }
    if (!RB::RenderPass::set_extra_attachments((uint64_t)v17, v6, v4))
    {
      RB::RenderPass::~RenderPass((RB::RenderPass *)v17);
      return;
    }
    int v8 = (__n128 *)*((void *)this + 3);
    if (v8 && *((_DWORD *)this + 10) == 2)
    {
      RB::RenderPass::set_clear_color((uint64_t)v17, v8[9]);
      v8[8].n128_u8[0] &= ~2u;
      int v8 = (__n128 *)*((void *)this + 3);
    }
    *((_DWORD *)this + 10) = 1;
    RB::RenderTaskTexture::render_all_tasks(this, (RB::RenderPass *)v17, a2);
    if (!*((void *)this + 3) && *((unsigned char *)this + 44))
    {
      if (*((unsigned char *)this + 45))
      {
        int v12 = (int32x2_t *)*((void *)this + 2);
        double v13 = (void *)v12[8];
        v17[20] = 0;
        v17[21] = v13;
        RB::RenderPass::resolve_framebuffer((RB::RenderPass *)v17, v12, v12, (const RB::RenderTask *)v8, (int32x2_t)v13, v9, v10, v11);
      }
      else
      {
        if ((*(uint64_t (**)(void))(*((void *)this + 4) + 16))()) {
          operator new();
        }
        unint64_t v14 = RB::error_log(0);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          RB::DisplayList::RootTexture::render(&v15, v16, v14);
        }
      }
    }
    RB::RenderPass::~RenderPass((RB::RenderPass *)v17);
  }
  while (*((void *)this + 3));
}

void sub_2141257B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  RB::RenderPass::~RenderPass((RB::RenderPass *)va);
  _Unwind_Resume(a1);
}

void *RB::RenderTaskTexture::render_dependencies(void *this, void *a2)
{
  uint64_t v2 = this[3];
  if (v2)
  {
    int v4 = *(_DWORD *)(v2 + 12);
    do
    {
      if (*(_DWORD *)(v2 + 12) != v4) {
        break;
      }
      for (uint64_t i = *(void *)(v2 + 32); i; uint64_t i = *(void *)(i + 40))
      {
        this = *(void **)(i + 88);
        if (this)
        {
          if (!this[2]) {
            this = (void *)(*(uint64_t (**)(void *, void *))(*this + 32))(this, a2);
          }
        }
      }
      uint64_t v2 = *(void *)(v2 + 48);
    }
    while (v2);
  }
  return this;
}

void RB::RenderTaskTexture::render_all_tasks(RB::RenderTaskTexture *this, RB::RenderPass *a2, void *a3)
{
  uint64_t v4 = *((void *)this + 3);
  if (v4)
  {
    LOBYTE(v7) = 0;
    do
    {
      uint64_t v8 = *(void *)(v4 + 48);
      (*(void (**)(uint64_t, RB::RenderPass *, void *))(*(void *)v4 + 32))(v4, a2, a3);
      BOOL v7 = v7 || *(unsigned char *)(v4 + 74) != 0;
      uint64_t v9 = *(void *)(v4 + 32);
      *(void *)(v4 + 32) = 0;
      if (v9)
      {
        do
        {
          uint64_t v10 = *(void *)(v9 + 40);
          *(void *)(v9 + 40) = 0;
          *(void *)(v9 + 16) = 0;
          int v11 = *(_DWORD *)(v9 + 8) - 1;
          *(_DWORD *)(v9 + 8) = v11;
          if (!v11) {
            (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
          }
          uint64_t v9 = v10;
        }
        while (v10);
      }
      if (!v8) {
        break;
      }
      uint64_t v4 = v8;
    }
    while (*(_DWORD *)(v8 + 12) == *(_DWORD *)(*((void *)this + 3) + 12));
    if (v7)
    {
      do
      {
        uint64_t v19 = *(void *)a2;
        unint64_t v21 = 0;
        uint64_t v22 = 0;
        uint64_t v20 = 0;
        uint64_t v12 = *((void *)this + 3);
        if (v12 == v8)
        {
          BOOL v13 = 0;
        }
        else
        {
          BOOL v13 = 0;
          do
          {
            if (*(unsigned char *)(v12 + 74))
            {
              *(unsigned char *)(v12 + 74) = 0;
              (*(void (**)(uint64_t, RB::RenderPass *, uint64_t *, void *))(*(void *)v12 + 40))(v12, a2, &v19, a3);
              BOOL v13 = v13 || *(unsigned char *)(v12 + 74) != 0;
            }
            uint64_t v12 = *(void *)(v12 + 48);
          }
          while (v12 != v8);
        }
        RB::Filter::RenderGroup::resolve((RB::Filter::RenderGroup *)&v19, a2);
        unint64_t v14 = v20;
        unint64_t v15 = v21;
        if (v21)
        {
          unint64_t v16 = 0;
          unsigned __int8 v17 = (uint64_t *)((char *)v20 + 8);
          do
          {
            uint64_t v18 = *v17;
            *unsigned __int8 v17 = 0;
            if (v18)
            {
              (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
              unint64_t v15 = v21;
            }
            ++v16;
            v17 += 7;
          }
          while (v16 < v15);
          unint64_t v14 = v20;
        }
        if (v14) {
          free(v14);
        }
      }
      while (v13);
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  *((void *)this + 3) = v8;
}

void sub_214125AFC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  RB::Filter::RenderGroup::~RenderGroup((RB::Filter::RenderGroup *)va);
  _Unwind_Resume(a1);
}

void RB::RenderTask::schedule_many(uint64_t a1, RB::RenderTask **a2, double a3)
{
  int v3 = a2;
  uint64_t v4 = a1;
  uint64_t v44 = *MEMORY[0x263EF8340];
  unsigned __int32 v42 = 0;
  uint64_t v43 = 0x2000000000;
  __p[0].__r_.__value_.__r.__words[0] = 0;
  if (a1)
  {
    uint64_t v5 = __p;
    MTLPixelFormat v6 = (std::string::size_type *)a2;
    uint64_t v7 = a1;
    do
    {
      std::string::size_type v8 = *v6++;
      v5->__r_.__value_.__r.__words[0] = v8;
      *(void *)(v8 + 48) = 0;
      *(_DWORD *)(v8 + 12) = 0;
      uint64_t v5 = (std::string *)(v8 + 48);
      --v7;
    }
    while (v7);
    std::string::size_type v9 = __p[0].__r_.__value_.__r.__words[0];
    if (__p[0].__r_.__value_.__r.__words[0])
    {
      unsigned int v10 = 0;
      do
      {
        __p[0].__r_.__value_.__r.__words[0] = *(void *)(v9 + 48);
        if (!__p[0].__r_.__value_.__r.__words[0]) {
          uint64_t v5 = __p;
        }
        unsigned int v11 = *(_DWORD *)(v9 + 12);
        if (v10 <= v11)
        {
          unsigned int v12 = v10 + 1;
          if (HIDWORD(v43) < v10 + 1)
          {
            RB::vector<RB::RenderTask *,32ul,unsigned int>::reserve_slow(__dst, v12);
            unsigned int v10 = v43;
            unsigned int v11 = *(_DWORD *)(v9 + 12);
            unsigned int v12 = v43 + 1;
          }
          BOOL v13 = v42;
          if (!v42) {
            BOOL v13 = __dst;
          }
          *(void *)&v13[8 * v10] = 0;
          LODWORD(v43) = v12;
          unsigned int v10 = v12;
        }
        unint64_t v14 = v42;
        if (!v42) {
          unint64_t v14 = __dst;
        }
        *(void *)(v9 + 48) = *(void *)&v14[8 * v11];
        *(void *)&v14[8 * v11] = v9;
        std::string::size_type v15 = *(void *)(v9 + 32);
        if (v15)
        {
          do
          {
            int v16 = *(_DWORD *)(v9 + 12) + 1;
            v5->__r_.__value_.__r.__words[0] = v15;
            *(void *)(v15 + 48) = 0;
            uint64_t v5 = (std::string *)(v15 + 48);
            *(_DWORD *)(v15 + 12) = v16;
            std::string::size_type v17 = v15;
            std::string::size_type v15 = *(void *)(v15 + 40);
          }
          while (v15);
        }
        else
        {
          std::string::size_type v17 = 0;
        }
        std::string::size_type v18 = *(void *)(v9 + 24);
        if (v18)
        {
          if (!v17) {
            std::string::size_type v17 = v9;
          }
          int v19 = *(_DWORD *)(v17 + 12) + 1;
          v5->__r_.__value_.__r.__words[0] = v18;
          *(void *)(v18 + 48) = 0;
          uint64_t v20 = (std::string *)(v18 + 48);
          HIDWORD(v20[-2].__r_.__value_.__r.__words[1]) = v19;
          uint64_t v5 = v20;
        }
        std::string::size_type v9 = __p[0].__r_.__value_.__r.__words[0];
      }
      while (__p[0].__r_.__value_.__r.__words[0]);
      if (v10)
      {
        uint64_t v21 = 0;
        uint64_t v22 = v10;
        while (1)
        {
          RB::BinPacker::BinPacker((RB::BinPacker *)__p, SLODWORD(a3), SHIDWORD(a3));
          int v24 = v42;
          if (!v42) {
            int v24 = __dst;
          }
          uint64_t v25 = *(void *)&v24[8 * v21];
          if (v25)
          {
            do
            {
              uint64_t v26 = *(void *)(v25 + 48);
              uint64_t v27 = *(void *)(v25 + 88);
              if (v27)
              {
                *(void *)(v25 + 48) = *(void *)(v27 + 24);
                *(void *)(v27 + 24) = v25;
              }
              else
              {
                RB::BinPacker::add((uint64_t)__p, *(void *)(v25 + 56), HIDWORD(*(void *)(v25 + 56)), (void *)v25, *(void *)(v25 + 80) ^ ((unint64_t)*(unsigned __int8 *)(v25 + 72) << 16));
              }
              uint64_t v25 = v26;
            }
            while (v26);
          }
          RB::BinPacker::pack((RB::BinPacker *)__p, v23);
          uint64_t v28 = v40;
          if (v40) {
            break;
          }
LABEL_42:
          RB::Heap::~Heap((RB::Heap *)__p);
          if (++v21 == v22) {
            goto LABEL_43;
          }
        }
        while (1)
        {
          (*(void (**)(uint64_t *__return_ptr, double))(**(void **)(*(void *)(v28 + 16) + 16) + 48))(v38, *(double *)v28);
          uint64_t v29 = *(void *)(v28 + 16);
          uint64_t v30 = v38[0];
          if (v29) {
            break;
          }
          if (v38[0]) {
            goto LABEL_39;
          }
LABEL_41:
          uint64_t v28 = *(void *)(v28 + 24);
          if (!v28) {
            goto LABEL_42;
          }
        }
        do
        {
          uint64_t v31 = *(void *)(v29 + 16);
          RB::RenderTask::set_texture((_DWORD *)v31, (_DWORD *)v30, *(double *)(v29 + 32));
          uint64_t v30 = v38[0];
          *(void *)(v31 + 48) = *(void *)(v38[0] + 24);
          *(void *)(v30 + 24) = v31;
          uint64_t v29 = *(void *)(v29 + 40);
        }
        while (v29);
LABEL_39:
        int v32 = *(_DWORD *)(v30 + 8) - 1;
        *(_DWORD *)(v30 + 8) = v32;
        if (!v32) {
          (*(void (**)(uint64_t))(*(void *)v30 + 8))(v30);
        }
        goto LABEL_41;
      }
    }
  }
LABEL_43:
  if ((atomic_load_explicit((atomic_uchar *volatile)&_ZGVZN2RB10RenderTask13schedule_manyEmPKPS0_Dv2_iPvE11print_tasks, memory_order_acquire) & 1) == 0&& __cxa_guard_acquire(&_ZGVZN2RB10RenderTask13schedule_manyEmPKPS0_Dv2_iPvE11print_tasks))
  {
    uint64_t v35 = RB::debug_int((RB *)"RB_PRINT_TASKS", v34);
    if ((v35 & 0xFF00000000) != 0) {
      int v36 = v35;
    }
    else {
      int v36 = 0;
    }
    _ZZN2RB10RenderTask13schedule_manyEmPKPS0_Dv2_iPvE11print_tasks = v36;
    __cxa_guard_release(&_ZGVZN2RB10RenderTask13schedule_manyEmPKPS0_Dv2_iPvE11print_tasks);
  }
  if (_ZZN2RB10RenderTask13schedule_manyEmPKPS0_Dv2_iPvE11print_tasks >= 1)
  {
    memset(__p, 0, 41);
    RB::SexpString::push(__p, "tasks");
    for (; v4; --v4)
      RB::RenderTask::print(*v3++, __p);
    RB::SexpString::pop(__p);
    RB::SexpString::newline(__p);
    if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v33 = __p;
    }
    else {
      uint64_t v33 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
    }
    fputs((const char *)v33, (FILE *)*MEMORY[0x263EF8358]);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
  }
  if (v42) {
    free(v42);
  }
}

void sub_214125F04(_Unwind_Exception *a1)
{
  if (STACK[0x590]) {
    free((void *)STACK[0x590]);
  }
  _Unwind_Resume(a1);
}

double RB::BinPacker::BinPacker(RB::BinPacker *this, int a2, int a3)
{
  uint64_t v5 = RB::Heap::Heap(this, (char *)this + 40, 1024, 0);
  *((_DWORD *)v5 + 266) = (a2 & 0xFFFFFFC0) + 64;
  *((_DWORD *)v5 + 267) = (a3 & 0xFFFFFFC0) + 64;
  *((void *)v5 + 134) = 0x8000000080;
  *((_DWORD *)v5 + 270) = 0;
  double result = 0.0;
  *((_OWORD *)v5 + 68) = 0u;
  *((unsigned char *)v5 + 1104) = 0;
  return result;
}

void RB::BinPacker::pack(RB::BinPacker *this, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x270FA5388](this, a2);
  uint64_t v20 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(v2 + 1088);
  if (v3)
  {
    uint64_t v4 = v2;
    int v5 = *(_DWORD *)(v2 + 1072);
    int v6 = *(int *)(v2 + 1064) >> 1;
    if (v6 >= v5)
    {
      int v7 = *(_DWORD *)(v2 + 1080) + (*(int *)(v2 + 1080) >> 2);
      int v8 = *(_DWORD *)(v2 + 1068);
      int v9 = *(_DWORD *)(v2 + 1076);
      do
      {
        v8 >>= 1;
        if (v8 < v9) {
          break;
        }
        if (v8 * v6 < v7) {
          break;
        }
        *(_DWORD *)(v2 + 1064) = v6;
        *(_DWORD *)(v2 + 1068) = v8;
        v6 >>= 1;
      }
      while (v6 >= v5);
    }
    unsigned int v10 = (uint64_t *)(v2 + 1088);
    unsigned int v11 = (uint64_t *)(v2 + 1088);
    do
    {
      while (1)
      {
        int v12 = *(_DWORD *)(v3 + 4);
        if (*(_DWORD *)v3 <= *(_DWORD *)(v4 + 1064) && v12 <= *(_DWORD *)(v4 + 1068)) {
          break;
        }
        uint64_t v13 = *(void *)(v3 + 8);
        LODWORD(v16[0]) = ((*(_DWORD *)v3 - 1) & 0xFFFFFFC0) + 64;
        LODWORD(v17) = ((v12 - 1) & 0xFFFFFFC0) + 64;
        v18[0] = v13;
        uint64_t v14 = RB::Heap::emplace<RB::BinPacker::bin,int &,int &,unsigned long &>((RB::Heap *)v4, v16, (int *)&v17, v18);
        *(void *)(v14 + 24) = *(void *)(v4 + 1096);
        *(void *)(v4 + 1096) = v14;
        RB::BinPacker::append_packed((RB::Heap *)v4, v3, 0, 0);
        uint64_t v3 = *(void *)(v3 + 24);
        *unsigned int v11 = v3;
        if (!v3) {
          goto LABEL_13;
        }
      }
      unsigned int v11 = (uint64_t *)(v3 + 24);
      uint64_t v3 = *(void *)(v3 + 24);
    }
    while (v3);
LABEL_13:
    if (*v10)
    {
      if (*(unsigned char *)(v4 + 1104))
      {
        RB::Heap::Heap((RB::Heap *)v18, v19, 4096, 0);
        RB::UntypedTable::UntypedTable((uint64_t)v16, 0, 0, 0, 0, (RB::Heap *)v18);
        while (1)
        {
          uint64_t v15 = *v10;
          if (!*v10) {
            break;
          }
          *unsigned int v10 = *(void *)(v15 + 24);
          *(void *)(v15 + 24) = RB::UntypedTable::lookup((RB::UntypedTable *)v16, *(uint64_t **)(v15 + 8), 0);
          RB::UntypedTable::insert(v16, *(size_t **)(v15 + 8), (size_t *)v15);
        }
        uint64_t v17 = v4;
        RB::UntypedTable::for_each((uint64_t)v16, (void (*)(const void *, const void *, void *))RB::Table<unsigned long,RB::BinPacker::item *>::for_each<RB::BinPacker::pack(void)::$_0>(RB::BinPacker::pack(void)::$_0)const::{lambda(void const*,void const*,void *)#1}::__invoke, &v17);
        RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v16);
        RB::Heap::~Heap((RB::Heap *)v18);
      }
      else
      {
        RB::BinPacker::pack((RB::Heap *)v4, *v10);
      }
    }
  }
}

_DWORD *RB::RenderTask::set_texture(_DWORD *result, _DWORD *a2, double a3)
{
  if (result)
  {
    int v5 = result;
    while (1)
    {
      double result = (_DWORD *)*((void *)v5 + 11);
      if (result != a2) {
        break;
      }
LABEL_9:
      *((double *)v5 + 8) = a3;
      int v5 = (_DWORD *)*((void *)v5 + 3);
      if (!v5) {
        return result;
      }
    }
    if (result && (int v6 = result[2] - 1, (result[2] = v6) == 0))
    {
      double result = (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(void *)result + 8))(result);
      if (!a2) {
        goto LABEL_8;
      }
    }
    else if (!a2)
    {
LABEL_8:
      *((void *)v5 + 11) = a2;
      goto LABEL_9;
    }
    ++a2[2];
    goto LABEL_8;
  }
  return result;
}

void RB::RenderPass::~RenderPass(RB::RenderPass *this)
{
  RB::RenderFrame::flush_pass(**(id ***)this, this, 1);

  uint64_t v2 = *((void *)this + 19);
  *((void *)this + 19) = 0;
  if (v2) {
    RB::RenderFrame::QueueDeleter::operator()((uint64_t)this + 152, v2);
  }

  for (uint64_t i = 80; i != -16; i -= 24)
  {
    uint64_t v4 = *(_DWORD **)((char *)this + i);
    if (v4)
    {
      int v5 = v4[2] - 1;
      void v4[2] = v5;
      if (!v5) {
        (*(void (**)(_DWORD *))(*(void *)v4 + 8))(v4);
      }
    }
  }
}

void sub_214126378(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void *)(v1 + 152);
  *(void *)(v1 + 152) = 0;
  if (v3) {
    RB::RenderFrame::QueueDeleter::operator()(v1 + 152, v3);
  }

  std::array<RB::RenderPass::AttachmentData,4ul>::~array(v1 + 8);
  _Unwind_Resume(a1);
}

void *RB::Texture::finalize(RB::Texture *this)
{
  uint64_t v2 = (RB::Device *)*((void *)this + 6);
  if (!v2) {
    return (void *)(*(uint64_t (**)(RB::Texture *))(*(void *)this + 24))(this);
  }
  *((void *)this + 6) = 0;
  return RB::Device::recycle_texture(v2, this);
}

void *RB::Device::recycle_texture(RB::Device *this, RB::Texture *a2)
{
  ++*((_DWORD *)a2 + 2);
  uint64_t v4 = (char *)this + 376;
  double result = operator new(0x18uLL);
  result[1] = v4;
  result[2] = a2;
  uint64_t v6 = *((void *)this + 47);
  *double result = v6;
  *(void *)(v6 + 8) = result;
  *((void *)this + 47) = result;
  ++*((void *)this + 49);
  *((void *)this + 53) += *((unsigned int *)a2 + 18);
  return result;
}

void RB::RenderFrame::flush_pass(id *this, RB::RenderPass *a2, int a3)
{
  uint64_t v6 = (_DWORD **)((char *)a2 + 152);
  if (!*((void *)a2 + 19))
  {
    if (*((_DWORD *)a2 + 32) != 2)
    {
      if (a3)
      {
        RB::RenderFrame::end_encoding(this);
      }
      return;
    }
    RB::RenderFrame::acquire_queue((uint64_t)this, (uint64_t *)a2 + 19);
  }
  RB::RenderFrame::will_render((RB::RenderFrame *)this);
  int v7 = *v6;
  std::string::size_type *v6 = 0;
  if ((a3 & 1) == 0 && *v7 >= 0x400u) {
    *((_DWORD *)this + 20) |= 2u;
  }
  RB::RenderFrame::EncoderData::EncoderData((uint64_t)(v7 + 2030), (atomic_ullong *)this, (uint64_t)a2, a3);
  *((_DWORD *)a2 + 32) = 1;
  *((unsigned char *)a2 + 132) = 0;
  int v8 = *((void *)*this + 5);
  if (((_BYTE)this[10] & 2) != 0)
  {
    dispatch_async_f(v8, v7, (dispatch_function_t)RB::RenderFrame::flush_pass(RB::RenderPass &,BOOL)::$_0::__invoke);
    if (!a3) {
      return;
    }
  }
  else
  {
    dispatch_sync_f(v8, v7, (dispatch_function_t)RB::RenderFrame::flush_pass(RB::RenderPass &,BOOL)::$_0::__invoke);
    if (!a3) {
      return;
    }
  }
  this[8] = (char *)this[8] + 1;
}

void sub_214126590(_Unwind_Exception *exception_object)
{
  if (v1) {
    RB::RenderFrame::QueueDeleter::operator()((uint64_t)exception_object, v1);
  }
  _Unwind_Resume(exception_object);
}

void RB::RenderFrame::will_render(RB::RenderFrame *this)
{
  uint64_t v1 = (void *)*((void *)this + 15);
  if (v1)
  {
    if ((*((unsigned char *)this + 80) & 2) != 0) {
      operator new();
    }
    *((void *)this + 15) = 0;
    uint64_t v2 = v1;
    v4[0] = this;
    v4[1] = v1;
    do
    {
      *(unsigned char *)(v2[1] + 77) &= ~8u;
      uint64_t v2 = (void *)*v2;
    }
    while (v2);
    RB::RenderFrame::will_render(void)::Encoder::operator()((uint64_t)v4);
    do
    {
      uint64_t v3 = (void *)*v1;
      operator delete(v1);
      uint64_t v1 = v3;
    }
    while (v3);
  }
}

void sub_2141266A8(_Unwind_Exception *a1)
{
  do
  {
    uint64_t v3 = (void *)*v1;
    operator delete(v1);
    uint64_t v1 = v3;
  }
  while (v3);
  _Unwind_Resume(a1);
}

uint64_t RB::RenderFrame::EncoderData::EncoderData(uint64_t a1, atomic_ullong *a2, uint64_t a3, int a4)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = *(id *)(a3 + 144);
  *(void *)(a1 + 16) = *(id *)(a3 + 256);
  unint64_t explicit = atomic_load_explicit(a2 + 13, memory_order_acquire);
  *(void *)(a1 + 24) = explicit;
  *(void *)(a1 + 32) = atomic_load_explicit((atomic_ullong *volatile)(explicit + 8), memory_order_acquire);
  unint64_t v10 = atomic_load_explicit(a2 + 12, memory_order_acquire);
  *(void *)(a1 + 40) = v10;
  *(void *)(a1 + 48) = atomic_load_explicit((atomic_ullong *volatile)(v10 + 8), memory_order_acquire);
  unint64_t v11 = atomic_load_explicit(a2 + 14, memory_order_acquire);
  *(void *)(a1 + 56) = v11;
  *(void *)(a1 + 64) = atomic_load_explicit((atomic_ullong *volatile)(v11 + 8), memory_order_acquire);
  if (*(_DWORD *)(a3 + 136) == 2) {
    uint64_t v12 = 131111;
  }
  else {
    uint64_t v12 = 39;
  }
  unint64_t v13 = *(void *)(a3 + 16);
  unint64_t v14 = *(void *)(a3 + 88);
  char v15 = *(unsigned char *)(*(void *)a3 + 31);
  *(void *)(a1 + 72) = v12;
  int v16 = *(_DWORD *)(a1 + 80) & 0xFFFFFC00 | v13 & 0x3FF;
  *(_DWORD *)(a1 + 80) = v16;
  if (v13 > 0x3FF || (*(_DWORD *)(a1 + 80) = v16 & 0xFFF003FF | ((v14 & 0x3FF) << 10), v14 >= 0x400)) {
    RB::precondition_failure((RB *)"invalid pixel format", v8);
  }
  int v17 = v13 & 0x3FF | ((((v15 & 8) >> 3) & 1) << 26) | ((v14 & 0x3FF) << 10);
  *(_DWORD *)(a1 + 80) = v17;
  *(void *)(a1 + 88) = *(void *)(a3 + 104);
  *(unsigned char *)(a1 + 96) = *(unsigned char *)(a3 + 124);
  BOOL v18 = *(_DWORD *)(a3 + 128) == 2;
  int v19 = *(unsigned char *)(a1 + 97) & 0xFE | v18;
  *(unsigned char *)(a1 + 97) = *(unsigned char *)(a1 + 97) & 0xFE | v18;
  unsigned int v20 = v19 & 0xFFFFFFFD | (2
                          * ((*((unsigned __int16 *)RB::pixel_format_traits(*(void *)(a3 + 88), (MTLPixelFormat)v8) + 2) >> 7) & 1));
  *(unsigned char *)(a1 + 97) = v20;
  unsigned int v22 = v20 & 0xFFFFFFFB | (4
                          * ((*((unsigned __int16 *)RB::pixel_format_traits(*(void *)(a3 + 88), v21) + 2) >> 6) & 1));
  *(unsigned char *)(a1 + 97) = v22;
  if (a4) {
    char v23 = 16;
  }
  else {
    char v23 = 0;
  }
  *(unsigned char *)(a1 + 97) = v23 | (8 * (*(void *)(a3 + 56) != 0)) | v22 & 0xE7;
  *(unsigned char *)(a1 + 98) = *(unsigned char *)(a3 + 132);
  int v24 = v17 | ((*(void *)(a3 + 32) != 0) << 20);
  *(_DWORD *)(a1 + 80) = v24;
  int v25 = v24 | ((*(void *)(a3 + 56) != 0) << 21) | 0x400000;
  *(_DWORD *)(a1 + 80) = v25;
  *(_DWORD *)(a1 + 80) = (v25 & 0xFDFFFFFF | ((*(unsigned char *)(a3 + 124) & 1) << 25)) ^ 0x2000000;
  return a1;
}

void sub_2141268B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t RB::RenderPass::RenderPass(uint64_t a1, uint64_t a2, int32x2_t *a3, unsigned int a4, int a5, uint64_t a6)
{
  *(void *)a1 = a2;
  for (uint64_t i = 8; i != 104; i += 24)
  {
    uint64_t v11 = a1 + i;
    *(void *)uint64_t v11 = 0;
    *(void *)(v11 + 8) = 0;
    *(_DWORD *)(v11 + 16) = 0;
  }
  int32x2_t v12 = vshl_s32(vadd_s32(a3[8], vdup_n_s32(~(-1 << a4))), vneg_s32(vdup_n_s32(a4)));
  *(int32x2_t *)(a1 + 104) = v12;
  *(float32x2_t *)(a1 + 112) = vdiv_f32((float32x2_t)0x4000000040000000, vcvt_f32_s32(v12));
  __int8 v13 = a3[10].i8[0];
  *(void *)(a1 + 152) = 0;
  *(_DWORD *)(a1 + 120) = 1065353216;
  *(unsigned char *)(a1 + 124) = v13;
  *(_DWORD *)(a1 + 128) = a5;
  *(unsigned char *)(a1 + 132) = 0;
  *(_DWORD *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  unint64_t v14 = (id *)(a1 + 144);
  *(void *)(a1 + 160) = 0;
  *(int32x2_t *)(a1 + 168) = v12;
  *(_WORD *)(a1 + 176) = 0;
  *(_DWORD *)(a1 + 180) = 0;
  *(void *)(a1 + 256) = 0;
  id v15 = (id)[MEMORY[0x263F129A0] renderPassDescriptor];
  if (*v14 != v15)
  {

    *unint64_t v14 = v15;
  }
  RB::RenderPass::set_attachment((uint64_t **)a1, MTLPixelFormatInvalid, (RB::Resource *)a3, a4, a6);
  *(void *)(a1 + 248) = 0;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  return a1;
}

void sub_214126A14(_Unwind_Exception *a1)
{
  uint64_t v6 = *(void *)(v2 + 152);
  *(void *)(v2 + 152) = 0;
  if (v6) {
    RB::RenderFrame::QueueDeleter::operator()(v3, v6);
  }

  std::array<RB::RenderPass::AttachmentData,4ul>::~array(v1);
  _Unwind_Resume(a1);
}

void RB::RenderPass::set_label(id *this, NSString *a2)
{
  if (*(unsigned char *)(**(void **)*this + 292))
  {
    uint64_t v3 = [(NSString *)a2 copy];

    this[32] = (id)v3;
  }
}

void RB::RenderFrame::QueueDeleter::operator()(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 4) >= 0x41u) {
    free(*(void **)(a2 + 8));
  }
  RB::Heap::~Heap((RB::Heap *)(a2 + 16));
  free((void *)a2);
}

void RB::Drawable::submit_frame(os_unfair_lock_s *this, const unint64_t *a2, double a3)
{
  uint64_t v6 = this + 8;
  os_unfair_lock_lock(this + 8);
  uint64_t v7 = *(void *)&this[10]._os_unfair_lock_opaque;
  if (v7)
  {
    if (!*(void *)&this[14]._os_unfair_lock_opaque)
    {
      *(double *)&this[18]._os_unfair_lock_opaque = a3;
      *(double *)&this[34]._os_unfair_lock_opaque = a3;
      *(double *)&this[50]._os_unfair_lock_opaque = a3;
      *(double *)&this[66]._os_unfair_lock_opaque = a3;
      if ((v7 & 4) == 0) {
        goto LABEL_19;
      }
      goto LABEL_9;
    }
    *(double *)&this[18]._os_unfair_lock_opaque = *(double *)&this[18]._os_unfair_lock_opaque + a3;
    double v8 = *(double *)&this[34]._os_unfair_lock_opaque;
    if (v8 > a3) {
      double v8 = a3;
    }
    *(double *)&this[34]._os_unfair_lock_opaque = v8;
    double v9 = *(double *)&this[50]._os_unfair_lock_opaque;
    if (v9 < a3) {
      double v9 = a3;
    }
    *(double *)&this[50]._os_unfair_lock_opaque = v9;
    *(double *)&this[66]._os_unfair_lock_opaque = a3
                                                + (*(double *)&this[66]._os_unfair_lock_opaque - a3)
                                                * *(double *)&this[12]._os_unfair_lock_opaque;
  }
  if ((v7 & 4) == 0) {
    goto LABEL_19;
  }
LABEL_9:
  double v10 = (double)a2[2] * 0.00000000519565863
      + (double)a2[3] * 1.98319745e-11
      + (double)a2[4] * 0.000100953793
      + (double)a2[1] * 4.31643348e-11
      + (double)*a2 * 0.00000000753195849;
  if (*(void *)&this[14]._os_unfair_lock_opaque)
  {
    *(double *)&this[22]._os_unfair_lock_opaque = *(double *)&this[22]._os_unfair_lock_opaque + v10;
    double v11 = *(double *)&this[38]._os_unfair_lock_opaque;
    if (v10 < v11) {
      double v11 = v10;
    }
    *(double *)&this[38]._os_unfair_lock_opaque = v11;
    double v12 = *(double *)&this[54]._os_unfair_lock_opaque;
    if (v12 < v10) {
      double v12 = v10;
    }
    *(double *)&this[54]._os_unfair_lock_opaque = v12;
    double v10 = v10 + (*(double *)&this[70]._os_unfair_lock_opaque - v10) * *(double *)&this[12]._os_unfair_lock_opaque;
  }
  else
  {
    *(double *)&this[22]._os_unfair_lock_opaque = v10;
    *(double *)&this[38]._os_unfair_lock_opaque = v10;
    *(double *)&this[54]._os_unfair_lock_opaque = v10;
  }
  *(double *)&this[70]._os_unfair_lock_opaque = v10;
LABEL_19:
  uint64_t v13 = *(void *)&this[14]._os_unfair_lock_opaque;
  if ((v7 & 8) != 0)
  {
    unint64_t v14 = 0;
    id v15 = this + 40;
    while (1)
    {
      double v16 = (double)a2[v14 / 2];
      p_os_unfair_lock_opaque = (double *)&v15[v14]._os_unfair_lock_opaque;
      if (v13) {
        break;
      }
      *(p_os_unfair_lock_opaque - 8) = v16;
      double *p_os_unfair_lock_opaque = v16;
      p_os_unfair_lock_opaque[8] = v16;
LABEL_28:
      p_os_unfair_lock_opaque[16] = v16;
      v14 += 2;
      if (v14 == 10) {
        goto LABEL_29;
      }
    }
    *(p_os_unfair_lock_opaque - 8) = *(p_os_unfair_lock_opaque - 8) + v16;
    double v18 = *(double *)&v15[v14]._os_unfair_lock_opaque;
    if (v18 <= v16)
    {
      double v19 = v16;
      if (v18 < v16)
      {
LABEL_27:
        p_os_unfair_lock_opaque = (double *)&v15[v14]._os_unfair_lock_opaque;
        *(double *)&v15[v14 + 16]._os_unfair_lock_opaque = v19;
        double v16 = v16
            + (*(double *)&v15[v14 + 32]._os_unfair_lock_opaque - v16) * *(double *)&this[12]._os_unfair_lock_opaque;
        goto LABEL_28;
      }
    }
    else
    {
      *(double *)&v15[v14]._os_unfair_lock_opaque = v16;
      double v18 = v16;
    }
    double v19 = v18;
    goto LABEL_27;
  }
LABEL_29:
  *(void *)&this[14]._os_unfair_lock_opaque = v13 + 1;
  os_unfair_lock_unlock(v6);
}

void RB::RenderFrame::end_encoding(id *this)
{
  if (((_BYTE)this[10] & 2) != 0)
  {
    uint64_t v3 = *((void *)*this + 5);
    dispatch_sync_f(v3, this, (dispatch_function_t)RB::RenderFrame::end_encoding(void)::$_0::__invoke);
  }
  else
  {
    id v2 = this[36];
    if (v2)
    {
      [v2 endEncoding];

      this[36] = 0;
    }
  }
}

unint64_t _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEELb0EEEvT1_SL_T0_NS_15iterator_traitsISL_E15difference_typeEb(unint64_t result, unint64_t a2, uint64_t a3, char a4)
{
  unint64_t v9 = result;
  while (2)
  {
    unint64_t v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v9 = v10;
          uint64_t v11 = a2 - v10;
          unint64_t v12 = (uint64_t)(a2 - v10) >> 4;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                unint64_t v40 = *(void *)(a2 - 16);
                unint64_t v41 = *(void *)v10;
                if (v40 < *(void *)v10)
                {
                  *(void *)unint64_t v10 = v40;
                  *(void *)(a2 - 16) = v41;
                  int v42 = *(_DWORD *)(v10 + 8);
                  *(_DWORD *)(v10 + 8) = *(_DWORD *)(a2 - 8);
                  *(_DWORD *)(a2 - 8) = v42;
                }
                break;
              case 3uLL:
                double result = (unint64_t)_ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEjT1_SL_SL_T0_((unint64_t *)v10, (unint64_t *)(v10 + 16), (unint64_t *)(a2 - 16));
                break;
              case 4uLL:
                double result = (unint64_t)_ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEvT1_SL_SL_SL_T0_(v10, v10 + 16, v10 + 32, a2 - 16);
                break;
              case 5uLL:
                double result = (unint64_t)_ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEvT1_SL_SL_SL_T0_(v10, v10 + 16, v10 + 32, v10 + 48);
                unint64_t v43 = *(void *)(a2 - 16);
                unint64_t v44 = *(void *)(v10 + 48);
                if (v43 < v44)
                {
                  *(void *)(v10 + 48) = v43;
                  *(void *)(a2 - 16) = v44;
                  int v45 = *(_DWORD *)(v10 + 56);
                  *(_DWORD *)(v10 + 56) = *(_DWORD *)(a2 - 8);
                  *(_DWORD *)(a2 - 8) = v45;
                  unint64_t v46 = *(void *)(v10 + 48);
                  unint64_t v47 = *(void *)(v10 + 32);
                  if (v46 < v47)
                  {
                    *(void *)(v10 + 32) = v46;
                    *(void *)(v10 + 48) = v47;
                    int v48 = *(_DWORD *)(v10 + 40);
                    int v49 = *(_DWORD *)(v10 + 56);
                    *(_DWORD *)(v10 + 40) = v49;
                    *(_DWORD *)(v10 + 56) = v48;
                    unint64_t v50 = *(void *)(v10 + 16);
                    if (v46 < v50)
                    {
                      *(void *)(v10 + 16) = v46;
                      *(void *)(v10 + 32) = v50;
                      int v51 = *(_DWORD *)(v10 + 24);
                      *(_DWORD *)(v10 + 24) = v49;
                      *(_DWORD *)(v10 + 40) = v51;
                      unint64_t v52 = *(void *)v10;
                      if (v46 < *(void *)v10)
                      {
                        *(void *)unint64_t v10 = v46;
                        *(void *)(v10 + 16) = v52;
                        int v53 = *(_DWORD *)(v10 + 8);
                        *(_DWORD *)(v10 + 8) = v49;
                        *(_DWORD *)(v10 + 24) = v53;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 383)
          {
            unint64_t v54 = v10 + 16;
            BOOL v56 = v10 == a2 || v54 == a2;
            if (a4)
            {
              if (!v56)
              {
                uint64_t v57 = 0;
                unint64_t v58 = v10;
                do
                {
                  unint64_t v59 = v54;
                  unint64_t v60 = *(void *)(v58 + 16);
                  unint64_t v61 = *(void *)v58;
                  if (v60 < *(void *)v58)
                  {
                    int v62 = *(_DWORD *)(v58 + 24);
                    uint64_t v63 = v57;
                    while (1)
                    {
                      uint64_t v64 = v10 + v63;
                      *(void *)(v64 + 16) = v61;
                      *(_DWORD *)(v64 + 24) = *(_DWORD *)(v10 + v63 + 8);
                      if (!v63) {
                        break;
                      }
                      unint64_t v61 = *(void *)(v64 - 16);
                      v63 -= 16;
                      if (v60 >= v61)
                      {
                        uint64_t v65 = v10 + v63 + 16;
                        goto LABEL_84;
                      }
                    }
                    uint64_t v65 = v10;
LABEL_84:
                    *(void *)uint64_t v65 = v60;
                    *(_DWORD *)(v65 + 8) = v62;
                  }
                  unint64_t v54 = v59 + 16;
                  v57 += 16;
                  unint64_t v58 = v59;
                }
                while (v59 + 16 != a2);
              }
            }
            else if (!v56)
            {
              unsigned int v92 = (_DWORD *)(v10 + 24);
              do
              {
                unint64_t v93 = v54;
                unint64_t v94 = *(void *)(v9 + 16);
                unint64_t v95 = *(void *)v9;
                if (v94 < *(void *)v9)
                {
                  int v96 = *(_DWORD *)(v9 + 24);
                  float64x2_t v97 = v92;
                  do
                  {
                    int32x4_t v98 = v97;
                    *((void *)v97 - 1) = v95;
                    int v99 = *(v97 - 4);
                    v97 -= 4;
                    *int32x4_t v98 = v99;
                    unint64_t v95 = *((void *)v98 - 5);
                  }
                  while (v94 < v95);
                  *((void *)v97 - 1) = v94;
                  *float64x2_t v97 = v96;
                }
                unint64_t v54 = v93 + 16;
                v92 += 4;
                unint64_t v9 = v93;
              }
              while (v93 + 16 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v66 = (v12 - 2) >> 1;
              int64_t v67 = v66;
              do
              {
                int64_t v68 = v67;
                if (v66 >= v67)
                {
                  uint64_t v69 = (2 * v67) | 1;
                  unint64_t v70 = v10 + 16 * v69;
                  if (2 * v68 + 2 < (uint64_t)v12)
                  {
                    unint64_t v72 = *(void *)(v70 + 16);
                    BOOL v71 = *(void *)v70 >= v72;
                    if (*(void *)v70 < v72) {
                      v70 += 16;
                    }
                    else {
                      unint64_t v72 = *(void *)v70;
                    }
                    if (!v71) {
                      uint64_t v69 = 2 * v68 + 2;
                    }
                  }
                  else
                  {
                    unint64_t v72 = *(void *)v70;
                  }
                  unint64_t v73 = v10 + 16 * v68;
                  unint64_t v74 = *(void *)v73;
                  if (v72 >= *(void *)v73)
                  {
                    int v75 = *(_DWORD *)(v73 + 8);
                    do
                    {
                      double result = v73;
                      unint64_t v73 = v70;
                      *(void *)double result = v72;
                      *(_DWORD *)(result + 8) = *(_DWORD *)(v70 + 8);
                      if (v66 < v69) {
                        break;
                      }
                      double result = (2 * v69) | 1;
                      unint64_t v70 = v10 + 16 * result;
                      uint64_t v69 = 2 * v69 + 2;
                      if (v69 < (uint64_t)v12)
                      {
                        unint64_t v72 = *(void *)v70;
                        if (*(void *)v70 >= *(void *)(v70 + 16))
                        {
                          uint64_t v69 = result;
                        }
                        else
                        {
                          unint64_t v72 = *(void *)(v70 + 16);
                          v70 += 16;
                        }
                      }
                      else
                      {
                        unint64_t v72 = *(void *)v70;
                        uint64_t v69 = result;
                      }
                    }
                    while (v72 >= v74);
                    *(void *)unint64_t v73 = v74;
                    *(_DWORD *)(v73 + 8) = v75;
                  }
                }
                int64_t v67 = v68 - 1;
              }
              while (v68);
              uint64_t v76 = (unint64_t)v11 >> 4;
              do
              {
                uint64_t v77 = 0;
                unint64_t v78 = *(void *)v10;
                int v79 = *(_DWORD *)(v10 + 8);
                unint64_t v80 = v10;
                do
                {
                  uint64_t v81 = v80 + 16 * v77 + 16;
                  uint64_t v82 = (2 * v77) | 1;
                  uint64_t v77 = 2 * v77 + 2;
                  if (v77 >= v76)
                  {
                    unint64_t v83 = *(void *)v81;
                    uint64_t v77 = v82;
                  }
                  else
                  {
                    unint64_t v83 = *(void *)v81;
                    double result = *(void *)(v81 + 16);
                    if (*(void *)v81 >= result)
                    {
                      uint64_t v77 = v82;
                    }
                    else
                    {
                      unint64_t v83 = *(void *)(v81 + 16);
                      v81 += 16;
                    }
                  }
                  *(void *)unint64_t v80 = v83;
                  *(_DWORD *)(v80 + 8) = *(_DWORD *)(v81 + 8);
                  unint64_t v80 = v81;
                }
                while (v77 <= (uint64_t)((unint64_t)(v76 - 2) >> 1));
                if (v81 == a2 - 16)
                {
                  *(void *)uint64_t v81 = v78;
                  *(_DWORD *)(v81 + 8) = v79;
                }
                else
                {
                  *(void *)uint64_t v81 = *(void *)(a2 - 16);
                  *(_DWORD *)(v81 + 8) = *(_DWORD *)(a2 - 8);
                  *(void *)(a2 - 16) = v78;
                  *(_DWORD *)(a2 - 8) = v79;
                  uint64_t v84 = v81 - v10 + 16;
                  if (v84 >= 17)
                  {
                    unint64_t v85 = (((unint64_t)v84 >> 4) - 2) >> 1;
                    uint64_t v86 = v10 + 16 * v85;
                    uint64_t v87 = *(void *)v86;
                    unint64_t v88 = *(void *)v81;
                    if (*(void *)v86 < *(void *)v81)
                    {
                      int v89 = *(_DWORD *)(v81 + 8);
                      do
                      {
                        uint64_t v90 = v81;
                        uint64_t v81 = v86;
                        *(void *)uint64_t v90 = v87;
                        *(_DWORD *)(v90 + 8) = *(_DWORD *)(v86 + 8);
                        if (!v85) {
                          break;
                        }
                        unint64_t v85 = (v85 - 1) >> 1;
                        uint64_t v86 = v10 + 16 * v85;
                        uint64_t v87 = *(void *)v86;
                      }
                      while (*(void *)v86 < v88);
                      *(void *)uint64_t v81 = v88;
                      *(_DWORD *)(v81 + 8) = v89;
                    }
                  }
                }
                a2 -= 16;
              }
              while (v76-- > 2);
            }
            return result;
          }
          unint64_t v13 = v12 >> 1;
          unint64_t v14 = v10 + 16 * (v12 >> 1);
          if ((unint64_t)v11 >= 0x801)
          {
            _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEjT1_SL_SL_T0_((unint64_t *)v9, (unint64_t *)(v9 + 16 * (v12 >> 1)), (unint64_t *)(a2 - 16));
            _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEjT1_SL_SL_T0_((unint64_t *)(v9 + 16), (unint64_t *)(v14 - 16), (unint64_t *)(a2 - 32));
            _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEjT1_SL_SL_T0_((unint64_t *)(v9 + 32), (unint64_t *)(v9 + 16 + 16 * v13), (unint64_t *)(a2 - 48));
            double result = (unint64_t)_ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEjT1_SL_SL_T0_((unint64_t *)(v14 - 16), (unint64_t *)v14, (unint64_t *)(v9 + 16 + 16 * v13));
            unint64_t v15 = *(void *)v9;
            *(void *)unint64_t v9 = *(void *)v14;
            *(void *)unint64_t v14 = v15;
            LODWORD(v15) = *(_DWORD *)(v9 + 8);
            *(_DWORD *)(v9 + 8) = *(_DWORD *)(v14 + 8);
            *(_DWORD *)(v14 + 8) = v15;
          }
          else
          {
            double result = (unint64_t)_ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEjT1_SL_SL_T0_((unint64_t *)(v9 + 16 * (v12 >> 1)), (unint64_t *)v9, (unint64_t *)(a2 - 16));
          }
          --a3;
          unint64_t v16 = *(void *)v9;
          if ((a4 & 1) != 0 || *(void *)(v9 - 16) < v16) {
            break;
          }
          if (v16 >= *(void *)(a2 - 16))
          {
            unint64_t v31 = v9 + 16;
            do
            {
              unint64_t v10 = v31;
              if (v31 >= a2) {
                break;
              }
              v31 += 16;
            }
            while (v16 >= *(void *)v10);
          }
          else
          {
            unint64_t v10 = v9;
            do
            {
              unint64_t v30 = *(void *)(v10 + 16);
              v10 += 16;
            }
            while (v16 >= v30);
          }
          unint64_t v32 = a2;
          if (v10 < a2)
          {
            unint64_t v32 = a2;
            do
            {
              unint64_t v33 = *(void *)(v32 - 16);
              v32 -= 16;
            }
            while (v16 < v33);
          }
          int v34 = *(_DWORD *)(v9 + 8);
          if (v10 < v32)
          {
            unint64_t v35 = *(void *)v10;
            unint64_t v36 = *(void *)v32;
            do
            {
              *(void *)unint64_t v10 = v36;
              *(void *)unint64_t v32 = v35;
              int v37 = *(_DWORD *)(v10 + 8);
              *(_DWORD *)(v10 + 8) = *(_DWORD *)(v32 + 8);
              *(_DWORD *)(v32 + 8) = v37;
              do
              {
                unint64_t v38 = *(void *)(v10 + 16);
                v10 += 16;
                unint64_t v35 = v38;
              }
              while (v16 >= v38);
              do
              {
                unint64_t v39 = *(void *)(v32 - 16);
                v32 -= 16;
                unint64_t v36 = v39;
              }
              while (v16 < v39);
            }
            while (v10 < v32);
          }
          BOOL v4 = v10 - 16 >= v9;
          BOOL v5 = v10 - 16 == v9;
          if (v10 - 16 != v9)
          {
            *(void *)unint64_t v9 = *(void *)(v10 - 16);
            *(_DWORD *)(v9 + 8) = *(_DWORD *)(v10 - 8);
          }
          a4 = 0;
          *(void *)(v10 - 16) = v16;
          *(_DWORD *)(v10 - 8) = v34;
        }
        uint64_t v17 = 0;
        int v18 = *(_DWORD *)(v9 + 8);
        do
        {
          unint64_t v19 = *(void *)(v9 + v17 + 16);
          v17 += 16;
        }
        while (v19 < v16);
        unint64_t v20 = v9 + v17;
        MTLPixelFormat v21 = (unint64_t *)a2;
        if (v17 == 16)
        {
          MTLPixelFormat v21 = (unint64_t *)a2;
          do
          {
            if (v20 >= (unint64_t)v21) {
              break;
            }
            unint64_t v23 = *(v21 - 2);
            v21 -= 2;
          }
          while (v23 >= v16);
        }
        else
        {
          do
          {
            unint64_t v22 = *(v21 - 2);
            v21 -= 2;
          }
          while (v22 >= v16);
        }
        if (v20 >= (unint64_t)v21)
        {
          unint64_t v10 = v9 + v17;
        }
        else
        {
          unint64_t v24 = *v21;
          unint64_t v10 = v9 + v17;
          int v25 = v21;
          do
          {
            *(void *)unint64_t v10 = v24;
            *int v25 = v19;
            int v26 = *(_DWORD *)(v10 + 8);
            *(_DWORD *)(v10 + 8) = *((_DWORD *)v25 + 2);
            *((_DWORD *)v25 + 2) = v26;
            do
            {
              unint64_t v27 = *(void *)(v10 + 16);
              v10 += 16;
              unint64_t v19 = v27;
            }
            while (v27 < v16);
            do
            {
              unint64_t v28 = *(v25 - 2);
              v25 -= 2;
              unint64_t v24 = v28;
            }
            while (v28 >= v16);
          }
          while (v10 < (unint64_t)v25);
        }
        if (v10 - 16 != v9)
        {
          *(void *)unint64_t v9 = *(void *)(v10 - 16);
          *(_DWORD *)(v9 + 8) = *(_DWORD *)(v10 - 8);
        }
        *(void *)(v10 - 16) = v16;
        *(_DWORD *)(v10 - 8) = v18;
        if (v20 >= (unint64_t)v21) {
          break;
        }
LABEL_33:
        double result = _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEELb0EEEvT1_SL_T0_NS_15iterator_traitsISL_E15difference_typeEb(v9, v10 - 16, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v29 = _ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEbT1_SL_T0_(v9, v10 - 16);
      double result = _ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEbT1_SL_T0_(v10, a2);
      if (result) {
        break;
      }
      if (!v29) {
        goto LABEL_33;
      }
    }
    a2 = v10 - 16;
    if (!v29) {
      continue;
    }
    return result;
  }
}

uint64_t RB::UntypedTable::for_each(uint64_t this, void (*a2)(const void *, const void *, void *), void *a3)
{
  if (*(void *)(this + 56))
  {
    uint64_t v5 = this;
    unint64_t v6 = 0;
    int v7 = *(_DWORD *)(this + 72);
    do
    {
      for (uint64_t i = *(void **)(*(void *)(v5 + 48) + 8 * v6); i; uint64_t i = (void *)*i)
        this = ((uint64_t (*)(void, void, void *))a2)(i[1], i[2], a3);
      ++v6;
    }
    while (!(v6 >> v7));
  }
  return this;
}

unint64_t RB::RenderParams::srgb_alpha(RB::RenderParams *this, MTLPixelFormat a2)
{
  if (*((unsigned char *)this + 28)) {
    return 0;
  }
  uint64_t v3 = RB::pixel_format_traits(*((void *)this + 1), a2);
  unint64_t v4 = *v3 | ((unint64_t)*((unsigned __int16 *)v3 + 2) << 32);
  if ((v4 & 0x100000000) == 0) {
    return 0;
  }
  if ((v4 & 0x1000000000) != 0) {
    return 1;
  }
  return (v4 >> 33) & ((*((unsigned char *)this + 31) & 1) == 0);
}

uint64_t RB::RenderPass::set_clear_color(uint64_t result, __n128 a2)
{
  if (*(_DWORD *)(result + 128) == 2)
  {
    double v2 = a2.n128_f32[0];
    double v3 = a2.n128_f32[1];
    double v4 = a2.n128_f32[2];
    double v5 = a2.n128_f32[3];
    unint64_t v6 = objc_msgSend((id)objc_msgSend(*(id *)(result + 144), "colorAttachments"), "objectAtIndexedSubscript:", 0);
    return objc_msgSend(v6, "setClearColor:", v2, v3, v4, v5);
  }
  return result;
}

unint64_t *_ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEvT1_SL_SL_SL_T0_(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  double result = _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEjT1_SL_SL_T0_((unint64_t *)a1, (unint64_t *)a2, (unint64_t *)a3);
  unint64_t v9 = *(void *)a3;
  if (*(void *)a4 < *(void *)a3)
  {
    *(void *)a3 = *(void *)a4;
    *(void *)a4 = v9;
    int v10 = *(_DWORD *)(a3 + 8);
    *(_DWORD *)(a3 + 8) = *(_DWORD *)(a4 + 8);
    *(_DWORD *)(a4 + 8) = v10;
    unint64_t v11 = *(void *)a2;
    if (*(void *)a3 < *(void *)a2)
    {
      *(void *)a2 = *(void *)a3;
      *(void *)a3 = v11;
      int v12 = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(a3 + 8);
      *(_DWORD *)(a3 + 8) = v12;
      unint64_t v13 = *(void *)a1;
      if (*(void *)a2 < *(void *)a1)
      {
        *(void *)a1 = *(void *)a2;
        *(void *)a2 = v13;
        int v14 = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
        *(_DWORD *)(a2 + 8) = v14;
      }
    }
  }
  return result;
}

unint64_t *_ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEjT1_SL_SL_T0_(unint64_t *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *result;
  unint64_t v5 = *a3;
  if (*a2 >= *result)
  {
    if (v5 < v3)
    {
      *a2 = v5;
      *a3 = v3;
      int v7 = *((_DWORD *)a2 + 2);
      *((_DWORD *)a2 + 2) = *((_DWORD *)a3 + 2);
      *((_DWORD *)a3 + 2) = v7;
      unint64_t v8 = *result;
      if (*a2 < *result)
      {
        *double result = *a2;
        *a2 = v8;
        int v9 = *((_DWORD *)result + 2);
        *((_DWORD *)result + 2) = *((_DWORD *)a2 + 2);
        *((_DWORD *)a2 + 2) = v9;
      }
    }
  }
  else if (v5 >= v3)
  {
    *double result = v3;
    *a2 = v4;
    int v10 = *((_DWORD *)result + 2);
    *((_DWORD *)result + 2) = *((_DWORD *)a2 + 2);
    *((_DWORD *)a2 + 2) = v10;
    if (*a3 < v4)
    {
      *a2 = *a3;
      *a3 = v4;
      *((_DWORD *)a2 + 2) = *((_DWORD *)a3 + 2);
      *((_DWORD *)a3 + 2) = v10;
    }
  }
  else
  {
    *double result = v5;
    *a3 = v4;
    int v6 = *((_DWORD *)result + 2);
    *((_DWORD *)result + 2) = *((_DWORD *)a3 + 2);
    *((_DWORD *)a3 + 2) = v6;
  }
  return result;
}

void sub_214127968(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_2141279CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_214127B40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_unfair_lock_t lock, char a11)
{
  MEMORY[0x21669AC10](v11, 0x10A0C405E99A6A3);
  if (a11) {
    os_unfair_lock_unlock(lock);
  }
  _Unwind_Resume(a1);
}

void sub_214127C50(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10B1C40F2BC6277);
  _Unwind_Resume(a1);
}

void _ZZZ38__RBLayer_displayWithBounds_callback__EUb_EN3__08__invokeIPvEEDajyT_(uint64_t ReleasedImageInfo, uint64_t a2, uint64_t a3)
{
  int v5 = ReleasedImageInfo;
  if ((atomic_load_explicit((atomic_uchar *volatile)&_ZGVZZZ38__RBLayer_displayWithBounds_callback__EUb_ENK3__0clIPvEEDajyT_E9log_stats, memory_order_acquire) & 1) == 0)
  {
    ReleasedImageuint64_t Info = __cxa_guard_acquire(&_ZGVZZZ38__RBLayer_displayWithBounds_callback__EUb_ENK3__0clIPvEEDajyT_E9log_stats);
    if (ReleasedImageInfo)
    {
      unsigned int v10 = (unsigned __int16)RB::debug_BOOL((RB *)"RB_PRINT_FRAME_STATS", v9);
      if (v10 <= 0x100) {
        LOBYTE(v10) = 0;
      }
      _ZZZZ38__RBLayer_displayWithBounds_callback__EUb_ENK3__0clIPvEEDajyT_E9log_stats = v10 != 0;
      __cxa_guard_release(&_ZGVZZZ38__RBLayer_displayWithBounds_callback__EUb_ENK3__0clIPvEEDajyT_E9log_stats);
    }
  }
  if (v5)
  {
    if (_ZZZZ38__RBLayer_displayWithBounds_callback__EUb_ENK3__0clIPvEEDajyT_E9log_stats)
    {
      ReleasedImageuint64_t Info = CAImageQueueGetReleasedImageInfo();
      if (ReleasedImageInfo)
      {
        if (*(unsigned char *)(ReleasedImageInfo + 16)) {
          int v6 = ", flushed";
        }
        else {
          int v6 = "";
        }
        if (*(unsigned char *)(ReleasedImageInfo + 17)) {
          int v7 = ", consumed";
        }
        else {
          int v7 = "";
        }
        ReleasedImageuint64_t Info = printf("RBLayer frame: count %u (%.1f F), id %llx%s%s\n", *(_DWORD *)ReleasedImageInfo, (double)*(unsigned int *)ReleasedImageInfo * (60.0 * *(double *)(ReleasedImageInfo + 32)), a2, v6, v7);
      }
    }
  }
  unint64_t v8 = (os_unfair_lock_s *)RB::SurfacePool::shared((RB::SurfacePool *)ReleasedImageInfo);
  RB::SurfacePool::dealloc(v8, *(RB::Surface **)a3, *(_CAImageQueue **)(a3 + 8));
  JUMPOUT(0x21669AC10);
}

void sub_214127DB8(_Unwind_Exception *a1)
{
}

void RB::SurfacePool::dealloc(os_unfair_lock_t lock, RB::Surface *a2, _CAImageQueue *a3)
{
  if (!a2) {
    return;
  }
  if (a3) {
    uint64_t v6 = (uint64_t)a3;
  }
  else {
    uint64_t v6 = 1;
  }
  if (v6 == *((void *)a2 + 15))
  {
    os_unfair_lock_lock(lock);
    CFTimeInterval v8 = CACurrentMediaTime();
    *((void *)a2 + 15) = 0;
    *((CFTimeInterval *)a2 + 16) = v8;
    if (!a3) {
      *((unsigned char *)a2 + 140) = 1;
    }
    int v9 = (os_unfair_lock_t *)RB::allocating_pool();
    if (*v9 == lock) {
      goto LABEL_16;
    }
    if (*((unsigned char *)a2 + 140))
    {
      if (IOSurfaceIsInUse(*((IOSurfaceRef *)a2 + 6)))
      {
        if (*((unsigned char *)a2 + 140))
        {
LABEL_16:
          uint64_t v10 = *(void *)&lock[4]._os_unfair_lock_opaque;
          uint64_t v11 = *(void *)&lock[6]._os_unfair_lock_opaque;
          if (v11)
          {
            uint64_t v12 = 8 * v11;
            unint64_t v13 = *(RB::Surface ***)&lock[4]._os_unfair_lock_opaque;
            while (*v13 != a2)
            {
              ++v13;
              v12 -= 8;
              if (!v12)
              {
                unint64_t v13 = (RB::Surface **)(v10 + 8 * v11);
                break;
              }
            }
          }
          else
          {
            unint64_t v13 = *(RB::Surface ***)&lock[4]._os_unfair_lock_opaque;
          }
          uint64_t v14 = ((uint64_t)v13 - v10) >> 3;
          if (v14 != v11)
          {
            unint64_t v15 = (uint64_t *)(v10 + 8 * v14);
            uint64_t v16 = *v15;
            *unint64_t v15 = 0;
            uint64_t v17 = ((uint64_t)v15 - *(void *)&lock[4]._os_unfair_lock_opaque) >> 3;
            uint64_t v18 = *(void *)&lock[6]._os_unfair_lock_opaque - 1;
            *(void *)&lock[6]._os_unfair_lock_opaque = v18;
            uint64_t v19 = v18 - v17;
            if (v19)
            {
              memmove(v15, v15 + 1, 8 * v19);
              uint64_t v17 = *(void *)&lock[6]._os_unfair_lock_opaque;
            }
            unint64_t v20 = v17 + 1;
            if (*(void *)&lock[8]._os_unfair_lock_opaque < (unint64_t)(v17 + 1))
            {
              RB::vector<unsigned long,0ul,unsigned long>::reserve_slow((uint64_t)&lock[4], v20);
              uint64_t v17 = *(void *)&lock[6]._os_unfair_lock_opaque;
              unint64_t v20 = v17 + 1;
            }
            *(void *)(*(void *)&lock[4]._os_unfair_lock_opaque + 8 * v17) = v16;
            *(void *)&lock[6]._os_unfair_lock_opaque = v20;
          }
          RB::SurfacePool::remove_watched_queue_locked((RB::SurfacePool *)lock, a3, 1);
          if (*v9 == lock || LOBYTE(lock[32]._os_unfair_lock_opaque))
          {
            int v7 = 0;
          }
          else
          {
            int v7 = 1;
            LOBYTE(lock[32]._os_unfair_lock_opaque) = 1;
          }
          os_unfair_lock_unlock(lock);
          goto LABEL_33;
        }
      }
      else
      {
        *((unsigned char *)a2 + 140) = 0;
      }
    }
    RB::SurfacePool::set_surface_volatile((uint64_t)lock, a2, 1u);
    goto LABEL_16;
  }
  int v7 = 0;
LABEL_33:
  if (atomic_fetch_add_explicit((atomic_uint *volatile)a2 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(RB::Surface *))(*(void *)a2 + 8))(a2);
  }
  if (v7)
  {
    MTLPixelFormat v21 = *(NSObject **)&lock[2]._os_unfair_lock_opaque;
    dispatch_async_f(v21, lock, (dispatch_function_t)RB::SurfacePool::AsyncCollection::~AsyncCollection()::$_0::__invoke);
  }
}

void sub_214128074(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, _Unwind_Exception *a11)
{
  unint64_t v13 = (_Unwind_Exception *)a1;
  if (v12)
  {
    RB::SurfacePool::dealloc(v12, a1, a2, (uint64_t)&a11);
    unint64_t v13 = a11;
  }
  os_unfair_lock_unlock(v11);
  _Unwind_Resume(v13);
}

uint64_t RB::SurfacePool::set_surface_volatile(uint64_t this, RB::Surface *a2, uint32_t a3)
{
  if (*((unsigned __int8 *)a2 + 45) != a3)
  {
    uint64_t v5 = this;
    this = RB::Surface::set_volatile((uint64_t)a2, a3);
    if (*((unsigned __int8 *)a2 + 45) == a3)
    {
      uint64_t v7 = (int)*((void *)a2 + 3) * (uint64_t)(int)HIDWORD(*((void *)a2 + 3));
      this = RB::pixel_format_bytes_per_pixel(*((RB **)a2 + 4), v6);
      uint64_t v8 = v7 * this;
      if (a3)
      {
        uint64_t v9 = *(void *)(v5 + 136) - v8;
        unint64_t v10 = *(void *)(v5 + 144) + v8;
        *(void *)(v5 + 136) = v9;
        *(void *)(v5 + 144) = v10;
        uint64_t v11 = (unint64_t *)(v5 + 160);
      }
      else
      {
        uint64_t v12 = *(void *)(v5 + 144) - v8;
        unint64_t v10 = *(void *)(v5 + 136) + v8;
        *(void *)(v5 + 136) = v10;
        *(void *)(v5 + 144) = v12;
        uint64_t v11 = (unint64_t *)(v5 + 152);
      }
      if (*v11 > v10) {
        unint64_t v10 = *v11;
      }
      *uint64_t v11 = v10;
    }
  }
  return this;
}

uint64_t RB::Surface::set_volatile(uint64_t this, uint32_t a2)
{
  if (*(unsigned __int8 *)(this + 45) != a2)
  {
    char v2 = a2;
    uint64_t v3 = this;
    uint32_t oldState = 0;
    this = IOSurfaceSetPurgeable(*(IOSurfaceRef *)(this + 48), a2, &oldState);
    if (!this) {
      *(unsigned char *)(v3 + 45) = v2;
    }
  }
  return this;
}

void RB::RenderFrame::flush_pass(RB::RenderPass &,BOOL)::$_0::__invoke(RB::RenderQueue *this)
{
  uint64_t v2 = *((void *)this + 1015);
  RB::RenderFrame::encode(v2, (uint64_t)this + 8120, this);

  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 232));
  unsigned int v3 = *(_DWORD *)(v2 + 280);
  unsigned int v4 = v3 + 1;
  if (*(_DWORD *)(v2 + 284) < v3 + 1)
  {
    RB::vector<std::unique_ptr<RB::RenderQueue,RB::RenderFrame::QueueDeleter>,4ul,unsigned int>::reserve_slow((void *)(v2 + 240), v4);
    unsigned int v3 = *(_DWORD *)(v2 + 280);
    unsigned int v4 = v3 + 1;
  }
  uint64_t v5 = *(void *)(v2 + 272);
  if (!v5) {
    uint64_t v5 = v2 + 240;
  }
  *(_DWORD *)(v2 + 280) = v4;
  *(void *)(v5 + 8 * v3) = this;
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 232));
}

void sub_214128278(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v2);
  RB::RenderFrame::QueueDeleter::operator()(v4, v1);
  _Unwind_Resume(a1);
}

void RB::RenderFrame::encode(uint64_t a1, uint64_t a2, RB::RenderQueue *this)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  MTLPixelFormat v6 = (id *)(a1 + 288);
  if (!*(void *)(a1 + 288))
  {
    id v7 = (id)[*(id *)(a1 + 16) renderCommandEncoderWithDescriptor:*(void *)(a2 + 8)];
    id v8 = *(id *)(a1 + 288);
    if (v8 != v7)
    {

      id v7 = v7;
      id *v6 = v7;
    }
    *(unsigned char *)(a1 + 296) = 0;
    if (*(void *)(a2 + 16)) {
      objc_msgSend(v7, "setLabel:");
    }
    if (*(unsigned char *)(*(void *)a1 + 292))
    {
      uint64_t v13 = *(void *)(a2 + 88);
      int v9 = *(_DWORD *)(a2 + 80);
      uint64_t v14 = *(void *)(a2 + 72);
      int v15 = v9;
      RB::FormattedRenderState::ID::formatted((uint64_t)&v14, (uint64_t)v16);
      snprintf(__str, 0x100uLL, "Encoder [%d, %d] %s C:%d D:%d S:%d F:%d", v13, HIDWORD(v13), v16, *(unsigned __int8 *)(a2 + 96), (*(unsigned __int8 *)(a2 + 97) >> 1) & 1, (*(unsigned __int8 *)(a2 + 97) >> 2) & 1, (*(unsigned __int8 *)(a2 + 97) >> 4) & 1);
      unint64_t v10 = (void *)[[NSString alloc] initWithCString:__str encoding:1];
      [*v6 insertDebugSignpost:v10];
    }
    objc_msgSend((id)objc_msgSend((id)objc_msgSend(*(id *)(a2 + 8), "colorAttachments"), "objectAtIndexedSubscript:", 0), "setLoadAction:", 1);
  }
  *(unsigned char *)(a1 + 296) |= *(unsigned char *)(a2 + 98);
  if (*(_DWORD *)this)
  {
    RB::RenderQueue::schedule(this, *(void *)a1, (*(unsigned __int8 *)(a2 + 97) >> 1) & 1);
    *(void *)__str = *(void *)a1;
    uint64_t v18 = *(void *)(a1 + 84);
    uint64_t v19 = *(void *)(a1 + 16);
    long long v20 = *(_OWORD *)(a2 + 8);
    uint64_t v11 = *(void *)(a2 + 72);
    MTLPixelFormat v21 = v6;
    uint64_t v22 = v11;
    int v23 = *(_DWORD *)(a2 + 80);
    uint64_t v24 = *(void *)(a2 + 88);
    char v25 = *(unsigned char *)(a2 + 96);
    long long v12 = *(_OWORD *)(a2 + 40);
    long long v26 = *(_OWORD *)(a2 + 24);
    long long v27 = v12;
    long long v28 = *(_OWORD *)(a2 + 56);
    LOBYTE(v11) = *(unsigned char *)(a2 + 97);
    BOOL v29 = (v11 & 4) != 0;
    BOOL v30 = (v11 & 2) != 0;
    BOOL v31 = (v11 & 8) != 0;
    char v32 = *(unsigned char *)(a1 + 296);
    RB::RenderQueue::encode((unsigned int *)this, (uint64_t)__str);
    if (*((_DWORD *)this + 1) >= 0x41u) {
      free(*((void **)this + 1));
    }
    *(void *)this = 0;
    *((void *)this + 1) = 0;
    RB::Heap::reset((RB::RenderQueue *)((char *)this + 16), (char *)this + 56, 8064);
    *(unsigned char *)(a1 + 296) = v32;
  }
  if ((*(unsigned char *)(a2 + 97) & 0x10) != 0)
  {
    if (*v6)
    {
      [*v6 endEncoding];

      id *v6 = 0;
    }
  }
}

void sub_214128520(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void RB::RenderQueue::schedule(RB::RenderQueue *this, size_t size, int a3)
{
  uint64_t v4 = this;
  uint64_t v157 = *MEMORY[0x263EF8340];
  {
    if (this)
    {
      uint64_t v145 = RB::debug_int((RB *)"RB_SCHEDULER", v144);
      if (*(unsigned char *)(size + 283)) {
        int v146 = 5;
      }
      else {
        int v146 = 7;
      }
      if ((v145 & 0xFF00000000) != 0) {
        int v146 = v145;
      }
      RB::RenderQueue::schedule(RB::Device *,BOOL)::default_enabled_passes = v146;
    }
  }
  {
    if (this)
    {
      uint64_t v148 = RB::debug_int((RB *)"RB_PRINT_QUEUE", v147);
      if ((v148 & 0xFF00000000) != 0) {
        int v149 = v148;
      }
      else {
        int v149 = 0;
      }
      RB::RenderQueue::schedule(RB::Device *,BOOL)::verbositdouble y = v149;
    }
  }
  unsigned int v5 = RB::RenderQueue::schedule(RB::Device *,BOOL)::default_enabled_passes;
  if (!a3) {
    unsigned int v5 = RB::RenderQueue::schedule(RB::Device *,BOOL)::default_enabled_passes & 0xFFFFFFFE;
  }
  uint64_t v6 = *(unsigned int *)v4;
  if (v6 >= 2) {
    unsigned int v7 = v5;
  }
  else {
    unsigned int v7 = 0;
  }
  if (!(v7 | RB::RenderQueue::schedule(RB::Device *,BOOL)::verbosity)) {
    return;
  }
  if (v6 > 0x800)
  {
    int v9 = (char *)malloc_type_malloc(16 * v6, 0xE1815A1EuLL);
    if (!v9) {
      goto LABEL_169;
    }
  }
  else
  {
    MEMORY[0x270FA5388](this, 16 * v6);
    int v9 = (char *)&v150 - ((v8 + 15) & 0x1FFFFFFFF0);
    bzero(v9, v8);
  }
  unint64_t v10 = *(unsigned int *)v4;
  uint64_t v151 = v6;
  if (v7)
  {
    int v24 = 0;
    if (v10)
    {
      unint64_t v25 = 0;
      unint64_t v26 = v10;
      do
      {
        if (v25 >= v10)
        {
          uint64_t v27 = 0;
        }
        else
        {
          uint64_t v27 = 0;
          unint64_t v28 = v25;
          while (1)
          {
            uint64_t v29 = *(void *)(*((void *)v4 + 1) + 8 * v28);
            char v30 = *(unsigned char *)(v29 + 48);
            *(unsigned char *)(v29 + 48) = v30 & 0xFD;
            if ((*(_DWORD *)v29 & 0x3F) == 0x27) {
              break;
            }
            char v31 = *(unsigned char *)(v29 + 40);
            if (v31) {
              BOOL v32 = 0;
            }
            else {
              BOOL v32 = *(unsigned char *)(v29 + 41) == 2;
            }
            if (v32)
            {
              *(unsigned char *)(v29 + 45) = 2;
              *(_WORD *)(v29 + 40) = 8736;
              *(unsigned char *)(v29 + 48) = v30 | 2;
              ++v27;
            }
            else if (!*(unsigned char *)(v29 + 45))
            {
              *(unsigned char *)(v29 + 45) = 1;
              *(unsigned char *)(v29 + 40) = v31 | 0x20;
            }
            if (++v28 >= *(unsigned int *)v4) {
              goto LABEL_47;
            }
          }
          unint64_t v26 = v28;
        }
LABEL_47:
        if (v25 < v26)
        {
          uint64_t v33 = v27 + v25;
          uint64_t v34 = v27 + v25;
          do
          {
            uint64_t v35 = *(void *)(*((void *)v4 + 1) + 8 * v25);
            uint64_t v36 = v33 - 1;
            if ((*(unsigned char *)(v35 + 48) & 2) != 0) {
              uint64_t v37 = v34;
            }
            else {
              uint64_t v37 = v34 + 1;
            }
            if ((*(unsigned char *)(v35 + 48) & 2) != 0) {
              --v33;
            }
            else {
              uint64_t v36 = v34;
            }
            if ((*(unsigned char *)(v35 + 48) & 2) != 0) {
              int v38 = -(int)v25;
            }
            else {
              LOWORD(v38) = v25;
            }
            int v39 = 84696351;
            if (*(unsigned char *)(v35 + 48)) {
              int v39 = 16777619
            }
                  * ((16777619
                    * ((16777619
                      * ((16777619 * (*(void *)((v35 + 56) & 0xFFFFFFFFFFFFFFF8) ^ 0x50C5D1F)) ^ HIDWORD(*(void *)((v35 + 56) & 0xFFFFFFFFFFFFFFF8)))) ^ *(void *)(((v35 + 56) & 0xFFFFFFFFFFFFFFF8) + 8))) ^ HIDWORD(*(void *)(((v35 + 56) & 0xFFFFFFFFFFFFFFF8) + 8)));
            int v40 = (16777619
                 * (((*(unsigned __int8 *)(v35 + 45) << 16) | (*(unsigned __int8 *)(v35 + 44) << 8) | *(unsigned __int8 *)(v35 + 43)) ^ v39)) ^ *(_DWORD *)(v35 + 36);
            if (*(unsigned char *)(v35 + 47))
            {
              unint64_t v41 = (int *)(v35 + 49);
              if (*(unsigned char *)(v35 + 48)) {
                unint64_t v41 = (int *)(((v35 + 56) & 0xFFFFFFFFFFFFFFF8) + 16);
              }
              uint64_t v42 = *(unsigned __int8 *)(v35 + 47);
              do
              {
                int v43 = *v41;
                v41 += 3;
                int v40 = v43 ^ (16777619 * v40);
                --v42;
              }
              while (v42);
            }
            uint64_t v44 = *(unsigned __int8 *)(v35 + 46);
            if (*(unsigned char *)(v35 + 46))
            {
              if (*(unsigned char *)(v35 + 48)) {
                unint64_t v45 = ((v35 + 56) & 0xFFFFFFFFFFFFFFF8) + 16;
              }
              else {
                unint64_t v45 = v35 + 49;
              }
              unint64_t v46 = (unsigned __int8 *)(v45 + 12 * *(unsigned __int8 *)(v35 + 47) + 4);
              do
              {
                int v47 = 33 * *((_DWORD *)v46 - 1);
                int v48 = *v46;
                v46 += 8;
                int v40 = (v47 + v48) ^ (16777619 * v40);
                --v44;
              }
              while (v44);
            }
            int v49 = &v9[16 * v36];
            *((_DWORD *)v49 + 2) = (16777619 * v40) ^ *(_DWORD *)v35;
            *(void *)int v49 = v35;
            *((_WORD *)v49 + 6) = v38;
            *((_WORD *)v49 + 7) = *(_WORD *)(v35 + 40);
            ++v25;
            uint64_t v34 = v37;
          }
          while (v25 != v26);
        }
        while (1)
        {
          unint64_t v10 = *(unsigned int *)v4;
          if (v26 >= v10) {
            break;
          }
          uint64_t v50 = *(void *)(*((void *)v4 + 1) + 8 * v26);
          if ((*(_DWORD *)v50 & 0x3F) != 0x27) {
            break;
          }
          int v51 = 84696351;
          if (*(unsigned char *)(v50 + 48)) {
            int v51 = 16777619
          }
                * ((16777619
                  * ((16777619
                    * ((16777619 * (*(void *)((v50 + 56) & 0xFFFFFFFFFFFFFFF8) ^ 0x50C5D1F)) ^ HIDWORD(*(void *)((v50 + 56) & 0xFFFFFFFFFFFFFFF8)))) ^ *(void *)(((v50 + 56) & 0xFFFFFFFFFFFFFFF8) + 8))) ^ HIDWORD(*(void *)(((v50 + 56) & 0xFFFFFFFFFFFFFFF8) + 8)));
          int v52 = (16777619
               * (((*(unsigned __int8 *)(v50 + 45) << 16) | (*(unsigned __int8 *)(v50 + 44) << 8) | *(unsigned __int8 *)(v50 + 43)) ^ v51)) ^ *(_DWORD *)(v50 + 36);
          if (*(unsigned char *)(v50 + 47))
          {
            int v53 = (int *)(v50 + 49);
            if (*(unsigned char *)(v50 + 48)) {
              int v53 = (int *)(((v50 + 56) & 0xFFFFFFFFFFFFFFF8) + 16);
            }
            uint64_t v54 = *(unsigned __int8 *)(v50 + 47);
            do
            {
              int v55 = *v53;
              v53 += 3;
              int v52 = v55 ^ (16777619 * v52);
              --v54;
            }
            while (v54);
          }
          uint64_t v56 = *(unsigned __int8 *)(v50 + 46);
          if (*(unsigned char *)(v50 + 46))
          {
            if (*(unsigned char *)(v50 + 48)) {
              unint64_t v57 = ((v50 + 56) & 0xFFFFFFFFFFFFFFF8) + 16;
            }
            else {
              unint64_t v57 = v50 + 49;
            }
            unint64_t v58 = (unsigned __int8 *)(v57 + 12 * *(unsigned __int8 *)(v50 + 47) + 4);
            do
            {
              int v59 = 33 * *((_DWORD *)v58 - 1);
              int v60 = *v58;
              v58 += 8;
              int v52 = (v59 + v60) ^ (16777619 * v52);
              --v56;
            }
            while (v56);
          }
          unint64_t v61 = &v9[16 * v26];
          *((_DWORD *)v61 + 2) = (16777619 * v52) ^ *(_DWORD *)v50;
          *(void *)unint64_t v61 = v50;
          *((_WORD *)v61 + 6) = v26;
          *((_WORD *)v61 + 7) = *(_WORD *)(v50 + 40);
          ++v26;
        }
        unint64_t v25 = v26;
        v24 += v27;
        unint64_t v26 = *(unsigned int *)v4;
      }
      while (v25 < v10);
    }
    if (RB::RenderQueue::schedule(RB::Device *,BOOL)::verbosity > 1)
    {
      puts("\n== after depth partition ==");
    }
  }
  else
  {
    if (v10)
    {
      unint64_t v11 = 0;
      do
      {
        uint64_t v12 = *(void *)(*((void *)v4 + 1) + 8 * v11);
        int v13 = 84696351;
        if (*(unsigned char *)(v12 + 48)) {
          int v13 = 16777619
        }
              * ((16777619
                * ((16777619
                  * ((16777619 * (*(void *)((v12 + 56) & 0xFFFFFFFFFFFFFFF8) ^ 0x50C5D1F)) ^ HIDWORD(*(void *)((v12 + 56) & 0xFFFFFFFFFFFFFFF8)))) ^ *(void *)(((v12 + 56) & 0xFFFFFFFFFFFFFFF8) + 8))) ^ HIDWORD(*(void *)(((v12 + 56) & 0xFFFFFFFFFFFFFFF8) + 8)));
        int v14 = (16777619
             * (((*(unsigned __int8 *)(v12 + 45) << 16) | (*(unsigned __int8 *)(v12 + 44) << 8) | *(unsigned __int8 *)(v12 + 43)) ^ v13)) ^ *(_DWORD *)(v12 + 36);
        if (*(unsigned char *)(v12 + 47))
        {
          int v15 = (int *)(v12 + 49);
          if (*(unsigned char *)(v12 + 48)) {
            int v15 = (int *)(((v12 + 56) & 0xFFFFFFFFFFFFFFF8) + 16);
          }
          uint64_t v16 = *(unsigned __int8 *)(v12 + 47);
          do
          {
            int v17 = *v15;
            v15 += 3;
            int v14 = v17 ^ (16777619 * v14);
            --v16;
          }
          while (v16);
        }
        uint64_t v18 = *(unsigned __int8 *)(v12 + 46);
        if (*(unsigned char *)(v12 + 46))
        {
          if (*(unsigned char *)(v12 + 48)) {
            unint64_t v19 = ((v12 + 56) & 0xFFFFFFFFFFFFFFF8) + 16;
          }
          else {
            unint64_t v19 = v12 + 49;
          }
          long long v20 = (unsigned __int8 *)(v19 + 12 * *(unsigned __int8 *)(v12 + 47) + 4);
          do
          {
            int v21 = 33 * *((_DWORD *)v20 - 1);
            int v22 = *v20;
            v20 += 8;
            int v14 = (v21 + v22) ^ (16777619 * v14);
            --v18;
          }
          while (v18);
        }
        int v23 = &v9[16 * v11];
        *((_DWORD *)v23 + 2) = (16777619 * v14) ^ *(_DWORD *)v12;
        *(void *)int v23 = v12;
        *((_WORD *)v23 + 6) = v11;
        *((_WORD *)v23 + 7) = *(_WORD *)(v12 + 40);
        ++v11;
      }
      while (v11 < *(unsigned int *)v4);
    }
    if (RB::RenderQueue::schedule(RB::Device *,BOOL)::verbosity > 1)
    {
      puts("\n== before scheduling ==");
    }
    int v24 = 0;
  }
  unsigned int v62 = *(_DWORD *)v4;
  if (v24 >= *(_DWORD *)v4) {
    goto LABEL_160;
  }
  unsigned int v153 = v9 + 15;
  uint64_t v154 = v9 - 8;
  uint64_t v63 = v9 + 16;
  int v152 = v9 + 8;
  do
  {
    uint64_t v64 = v24;
    if (v24 + 80 >= (unint64_t)v62) {
      uint64_t v65 = v62 - v24;
    }
    else {
      uint64_t v65 = 64;
    }
    int64_t v66 = &v9[16 * v24];
    if ((v7 & 2) != 0)
    {
      uint64_t v67 = (int)v65 - 1;
      *(_WORD *)&v66[16 * v67 + 12] = v65 + v24 - 1;
      uint64_t v68 = (v65 - 2);
      if ((int)v65 >= 2)
      {
        uint64_t v69 = 0;
        unint64_t v70 = &v154[16 * v24 + 16 * v65];
        BOOL v71 = &v63[16 * v24 + 16 * v68];
        int v72 = v65;
        unint64_t v73 = &v153[16 * v24];
        while (1)
        {
          unint64_t v74 = (int32x2_t **)&v66[16 * v68];
          *((_WORD *)v74 + 6) = v65 + v64 - 1;
          int v75 = (_WORD *)v74 + 6;
          LOWORD(v76) = v65 + v64 - 1;
          if (v68 >= v65 - 1) {
            goto LABEL_118;
          }
          int v77 = v72;
          int32x2_t v78 = (*v74)[1];
          int32x2_t v79 = (*v74)[2];
          unint64_t v80 = v70;
          int v81 = v69;
          LOWORD(v76) = v65 + v64 - 1;
          int v82 = v68;
          while (1)
          {
            unint64_t v83 = (int32x2_t *)*((void *)v80 - 1);
            *(int32x2_t *)v84.i8 = vsub_s32(v83[1], v79);
            v84.u64[1] = (unint64_t)vsub_s32(v78, v83[2]);
            if ((vminvq_u32((uint32x4_t)vcltzq_s32(v84)) & 0x80000000) != 0) {
              break;
            }
LABEL_107:
            int v82 = v65 + v81 - 1;
            v80 += 16;
            ++v81;
            ++v77;
            if (v81 == 1) {
              goto LABEL_118;
            }
          }
          unint64_t v76 = *(void *)v80;
          uint64_t v85 = HIBYTE(*(void *)v80);
          uint64_t v86 = v74[1];
          if (((v85 | HIWORD(*(void *)v80)) & ((unint64_t)v86 >> 56)) != 0)
          {
            unint64_t v87 = HIDWORD(v76);
LABEL_110:
            LOWORD(v76) = v87 - 1;
            *int v75 = v87 - 1;
            goto LABEL_118;
          }
          if (((((unint64_t)v86 >> 56) | ((unint64_t)v86 >> 48)) & v85) == 0) {
            break;
          }
          LOWORD(v76) = WORD2(v76) - 1;
          *int v75 = WORD2(v76) - 1;
          if (v82 + 2 < (int)v65)
          {
            unint64_t v88 = v74[1];
            unint64_t v89 = (unint64_t)v88 >> 56;
            uint64_t v90 = (int)v65 + v81;
            unint64_t v91 = (unint64_t)v88 >> 32;
            unint64_t v76 = (unint64_t)v88 >> 32;
            unsigned int v92 = &v73[16 * v77];
            while (1)
            {
              if (((*v92 | *(v92 - 1)) & v89) != 0)
              {
                unint64_t v93 = *(int32x2_t **)(v92 - 15);
                *(int32x2_t *)v94.i8 = vsub_s32(v78, v93[2]);
                v94.u64[1] = (unint64_t)vsub_s32(v93[1], v79);
                if ((vminvq_u32((uint32x4_t)vcltzq_s32(v94)) & 0x80000000) != 0) {
                  break;
                }
              }
              ++v90;
              v92 += 16;
              if (v90 >= v65) {
                goto LABEL_118;
              }
            }
            LODWORD(v87) = *(__int16 *)(v92 - 3);
            if ((int)v87 <= (__int16)v91) {
              goto LABEL_110;
            }
          }
LABEL_118:
          int32x4_t v155 = *v74;
          int v156 = *((_DWORD *)v74 + 2);
          __int16 v95 = *((_WORD *)v74 + 7);
          if (v65 == 2)
          {
            LODWORD(v96) = 1;
          }
          else
          {
            float64x2_t v97 = v71;
            uint64_t v96 = 1;
            while (*((__int16 *)v97 + 6) < (__int16)v76)
            {
              *((_OWORD *)v97 - 1) = *(_OWORD *)v97;
              v97 += 16;
              if (v67 == ++v96)
              {
                LODWORD(v96) = v65 - 1;
                break;
              }
            }
          }
          int32x4_t v98 = &v74[2 * (int)v96 - 2];
          *int32x4_t v98 = v155;
          *((_DWORD *)v98 + 2) = v156;
          *((_WORD *)v98 + 6) = v76;
          *((_WORD *)v98 + 7) = v95;
          --v72;
          --v69;
          v70 -= 16;
          v71 -= 16;
          BOOL v99 = v68-- <= 0;
          if (v99) {
            goto LABEL_126;
          }
        }
        unint64_t v76 = (unint64_t)v86 >> 32;
        goto LABEL_107;
      }
    }
LABEL_126:
    if ((v7 & 4) == 0) {
      goto LABEL_159;
    }
    int v100 = &v9[16 * v64];
    *((_WORD *)v100 + 6) = v64;
    if ((int)v65 < 2) {
      goto LABEL_159;
    }
    uint64_t v101 = 0;
    int v102 = -1;
    uint64_t v103 = 1;
    double v104 = &v152[16 * v64];
    int v105 = &v63[16 * v64];
    do
    {
      int v106 = v103;
      uint64_t v107 = (int32x2_t **)&v66[16 * v103];
      *((_WORD *)v107 + 6) = v64;
      uint64_t v108 = (_WORD *)v107 + 6;
      uint64_t v109 = *v107;
      int32x2_t v110 = (*v107)[1];
      int32x2_t v111 = (*v107)[2];
      unsigned int v112 = v102;
      int v113 = v101;
      uint64_t v114 = v101;
      LOWORD(v115) = v64;
      while (1)
      {
        uint64_t v116 = (int32x2_t **)&v66[16 * v114];
        *(int32x2_t *)v117.i8 = vsub_s32((*v116)[1], v111);
        v117.u64[1] = (unint64_t)vsub_s32(v110, (*v116)[2]);
        if ((vminvq_u32((uint32x4_t)vcltzq_s32(v117)) & 0x80000000) != 0) {
          break;
        }
LABEL_134:
        uint64_t v120 = v114-- + 1;
        --v113;
        --v112;
        if (v120 <= 1) {
          goto LABEL_146;
        }
      }
      unint64_t v115 = (unint64_t)v116[1];
      unsigned __int8 v118 = *((unsigned char *)v107 + 15) | *((unsigned char *)v107 + 14);
      if ((v118 & HIBYTE(v115)) != 0)
      {
        unint64_t v121 = HIDWORD(v115);
LABEL_137:
        LOWORD(v115) = v121 + 1;
        _WORD *v108 = v121 + 1;
        goto LABEL_146;
      }
      uint64_t v119 = v107[1];
      if (((HIBYTE(v115) | HIWORD(v115)) & ((unint64_t)v119 >> 56)) == 0)
      {
        unint64_t v115 = (unint64_t)v119 >> 32;
        goto LABEL_134;
      }
      LODWORD(v115) = (__int16)(WORD2(v115) + 1);
      _WORD *v108 = WORD2(v115) + 1;
      if ((int)v114 + 1 >= 2)
      {
        int8x8_t v122 = &v104[16 * v112];
        int8x8_t v123 = v122;
        while (1)
        {
          uint64_t v125 = *(void *)v123;
          v123 -= 16;
          uint64_t v124 = v125;
          if ((HIBYTE(v125) & v118) != 0)
          {
            uint32x2_t v126 = (int32x2_t *)*((void *)v122 - 1);
            *(int32x2_t *)v127.i8 = vsub_s32(v126[1], v111);
            v127.u64[1] = (unint64_t)vsub_s32(v110, v126[2]);
            if ((vminvq_u32((uint32x4_t)vcltzq_s32(v127)) & 0x80000000) != 0) {
              break;
            }
          }
          int8x8_t v122 = v123;
          BOOL v128 = __OFSUB__(v113--, 1);
          if ((v113 < 0) ^ v128 | (v113 == 0)) {
            goto LABEL_146;
          }
        }
        if ((int)v115 <= SWORD2(v124))
        {
          unint64_t v121 = v124 << 16 >> 48;
          goto LABEL_137;
        }
      }
LABEL_146:
      ++v103;
      unsigned int v129 = *((_DWORD *)v107 + 2);
      __int16 v130 = *((_WORD *)v107 + 7);
      unint64_t v131 = v105;
      uint64_t v132 = v101;
      while (*(__int16 *)&v66[16 * v132 + 12] > (__int16)v115)
      {
        long long v133 = *(_OWORD *)&v66[16 * v132];
        uint64_t v134 = v132-- + 1;
        *(_OWORD *)unint64_t v131 = v133;
        v131 -= 16;
        --v106;
        if (v134 <= 1)
        {
LABEL_155:
          LODWORD(v132) = -1;
          goto LABEL_156;
        }
      }
      float64x2_t v135 = &v100[16 * v106];
      while (1)
      {
        long long v136 = &v66[16 * v132];
        if (*((unsigned __int16 *)v136 + 6) != (unsigned __int16)v115
          || v129 <= *(_DWORD *)&v66[16 * v132 + 8])
        {
          break;
        }
        *(_OWORD *)float64x2_t v135 = *(_OWORD *)v136;
        v135 -= 16;
        BOOL v99 = (int)v132 <= 0;
        LODWORD(v132) = v132 - 1;
        if (v99) {
          goto LABEL_155;
        }
      }
LABEL_156:
      uint64_t v137 = &v66[16 * (int)v132 + 16];
      *(void *)uint64_t v137 = v109;
      *((_DWORD *)v137 + 2) = v129;
      *((_WORD *)v137 + 6) = v115;
      *((_WORD *)v137 + 7) = v130;
      ++v102;
      ++v101;
      v105 += 16;
    }
    while (v103 != v65);
LABEL_159:
    int v24 = v65 + v64;
    unsigned int v62 = *(_DWORD *)v4;
  }
  while (v24 < *(_DWORD *)v4);
LABEL_160:
  if (v62)
  {
    uint64_t v138 = 0;
    uint64_t v139 = v9;
    do
    {
      uint64_t v140 = *(void *)v139;
      v139 += 16;
      *(void *)(*((void *)v4 + 1) + v138) = v140;
      v138 += 8;
    }
    while (8 * v62 != v138);
  }
  unsigned int v141 = v151;
  if (RB::RenderQueue::schedule(RB::Device *,BOOL)::verbosity > 0)
  {
    if (RB::RenderQueue::schedule(RB::Device *,BOOL)::verbosity == 1) {
      long long v142 = "render pass";
    }
    else {
      long long v142 = "after scheduling";
    }
    printf("\n== %s ==\n", v142);
  }
  if (v141 >= 0x801) {
LABEL_169:
  }
    free(v9);
}

void sub_214129134(_Unwind_Exception *a1)
{
}

BOOL RB::RenderPass::set_extra_attachments(uint64_t a1, MTLPixelFormat a2, __n128 a3)
{
  unsigned __int8 v3 = a2;
  unsigned int v5 = **(RB::Device ****)a1;
  uint64_t v6 = *v5;
  int v7 = *((unsigned __int8 *)*v5 + 283);
  if (((a2 & 1) != 0 || *((unsigned char *)*v5 + 283)) && !*(void *)(a1 + 32))
  {
    a3.n128_u64[0] = *(void *)(a1 + 104);
    a3 = RB::Device::alloc_shared_texture(v6, (RB *)0x41, 1u, 0, 4, (int32x2_t **)&v20, a3);
    if (v20)
    {
      RB::RenderPass::set_attachment((uint64_t **)a1, MTLPixelFormatA8Unorm, v20, 0, 0);
      unint64_t v10 = v20;
      if (v20)
      {
        int v11 = *((_DWORD *)v20 + 2) - 1;
        *((_DWORD *)v20 + 2) = v11;
        if (!v11) {
          (*(void (**)(RB::Resource *))(*(void *)v10 + 8))(v10);
        }
      }
    }
    else if (v3)
    {
      return 0;
    }
  }
  unsigned int v8 = v3;
  if (((v3 & 2) != 0 || v7) && !*(void *)(a1 + 56))
  {
    if (!*(void *)(a1 + 8)) {
      goto LABEL_28;
    }
    uint64_t v12 = *(RB **)(a1 + 16);
    if ((*(unsigned char *)(*(void *)a1 + 31) & 8) == 0)
    {
      int v13 = RB::pixel_format_traits(*(void *)(a1 + 16), a2);
      if (v13[8]) {
        uint64_t v12 = (RB *)v13[8];
      }
    }
    a3.n128_u64[0] = *(void *)(a1 + 104);
    RB::Device::alloc_shared_texture(v6, v12, 1u, *(unsigned char *)(a1 + 124), 5, (int32x2_t **)&v20, a3);
    if (v20)
    {
      RB::RenderPass::set_attachment((uint64_t **)a1, (MTLPixelFormat)2uLL, v20, 0, 0);
      int v14 = v20;
      if (v20)
      {
        int v15 = *((_DWORD *)v20 + 2) - 1;
        *((_DWORD *)v20 + 2) = v15;
        if (!v15) {
          (*(void (**)(RB::Resource *))(*(void *)v14 + 8))(v14);
        }
      }
    }
    else
    {
LABEL_28:
      if ((v8 & 2) != 0) {
        return 0;
      }
    }
  }
  if ((v8 & 0xC) == 0 && !v7 || *(void *)(a1 + 80)) {
    return 1;
  }
  uint64_t v16 = (RB *)RB::Device::depth_stencil_format(v6, (v8 & 8) != 0, (v8 >> 2) & 1);
  v17.n128_u64[0] = *(void *)(a1 + 104);
  RB::Device::alloc_shared_texture(v6, v16, 1u, 1, 3, (int32x2_t **)&v20, v17);
  if (v20)
  {
    RB::RenderPass::set_attachment((uint64_t **)a1, (MTLPixelFormat)3uLL, v20, 0, 0);
    uint64_t v18 = v20;
    if (v20)
    {
      int v19 = *((_DWORD *)v20 + 2) - 1;
      *((_DWORD *)v20 + 2) = v19;
      if (!v19) {
        (*(void (**)(RB::Resource *))(*(void *)v18 + 8))(v18);
      }
    }
    return 1;
  }
  return (v8 & 0xC) == 0;
}

void sub_2141293D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _DWORD *a10)
{
  if (a10) {
    RB::RenderFrame::alloc_buffer_region(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::RenderPass::set_attachment(uint64_t **a1, MTLPixelFormat a2, RB::Resource *this, unsigned int a4, uint64_t a5)
{
  uint64_t v5 = a5;
  int v8 = a2;
  if (!a5) {
    uint64_t v5 = *((void *)this + 7);
  }
  switch((int)a2)
  {
    case 0:
      unint64_t v10 = objc_msgSend((id)objc_msgSend(a1[18], "colorAttachments"), "objectAtIndexedSubscript:", 0);
      [v10 setTexture:*((void *)this + 2)];
      [v10 setLevel:a4];
      int v11 = *((_DWORD *)a1 + 32);
      if (v11 == 2) {
        uint64_t v12 = 2;
      }
      else {
        uint64_t v12 = v11 != 0;
      }
      [v10 setLoadAction:v12];
      [v10 setStoreAction:*((unsigned __int8 *)this + 78) != 2];
      if (*((_DWORD *)a1 + 32) == 2)
      {
        char v13 = *((unsigned char *)a1 + 132) | 2;
        goto LABEL_15;
      }
      break;
    case 1:
      int v19 = objc_msgSend((id)objc_msgSend(a1[18], "colorAttachments"), "objectAtIndexedSubscript:", 1);
      [v19 setTexture:*((void *)this + 2)];
      [v19 setLevel:a4];
      [v19 setLoadAction:2];
      [v19 setStoreAction:((unint64_t)*(unsigned __int8 *)(*(void *)**a1 + 292) >> 2) & 1];
      objc_msgSend(v19, "setClearColor:", 0.0, 0.0, 0.0, 0.0);
      char v13 = *((unsigned char *)a1 + 132) | 0x18;
LABEL_15:
      *((unsigned char *)a1 + 132) = v13;
      break;
    case 2:
      int v14 = objc_msgSend((id)objc_msgSend(a1[18], "colorAttachments"), "objectAtIndexedSubscript:", 2);
      [v14 setTexture:*((void *)this + 2)];
      [v14 setLevel:a4];
      [v14 setLoadAction:0];
      [v14 setStoreAction:0];
      break;
    case 3:
      int v15 = RB::pixel_format_traits(*((void *)this + 7), a2);
      if (((*v15 | ((unint64_t)*((unsigned __int16 *)v15 + 2) << 32)) & 0x4000000000) != 0)
      {
        uint64_t v16 = (void *)[a1[18] stencilAttachment];
        [v16 setTexture:*((void *)this + 2)];
        [v16 setLevel:a4];
        [v16 setLoadAction:2];
        [v16 setStoreAction:((unint64_t)*(unsigned __int8 *)(*(void *)**a1 + 292) >> 2) & 1];
        [v16 setClearStencil:0];
        *((unsigned char *)a1 + 132) |= 1u;
        int v15 = RB::pixel_format_traits(*((void *)this + 7), v17);
      }
      if (((*v15 | ((unint64_t)*((unsigned __int16 *)v15 + 2) << 32)) & 0x8000000000) != 0)
      {
        uint64_t v18 = (void *)[a1[18] depthAttachment];
        [v18 setTexture:*((void *)this + 2)];
        [v18 setLevel:a4];
        [v18 setLoadAction:2];
        [v18 setStoreAction:((unint64_t)*(unsigned __int8 *)(*(void *)**a1 + 292) >> 2) & 1];
        [v18 setClearDepth:0.0];
      }
      break;
    default:
      break;
  }
  int v20 = v8;
  int v21 = (RB::Resource **)&a1[3 * v8 + 1];
  int v22 = *v21;
  if (*v21 != this)
  {
    if (v22)
    {
      int v23 = *((_DWORD *)v22 + 2) - 1;
      *((_DWORD *)v22 + 2) = v23;
      if (!v23) {
        (*(void (**)(RB::Resource *))(*(void *)v22 + 8))(v22);
      }
    }
    if (this) {
      ++*((_DWORD *)this + 2);
    }
    *int v21 = this;
  }
  uint64_t v24 = (uint64_t)&a1[3 * v20 + 1];
  *(void *)(v24 + 8) = v5;
  *(_DWORD *)(v24 + 16) = a4;
  uint64_t v25 = **a1;
  int v26 = *(_DWORD *)(v25 + 84);
  int v27 = *(_DWORD *)(v25 + 88);
  return RB::Resource::set_frame_id((uint64_t)this, v26, v27);
}

__n128 RB::Device::alloc_shared_texture@<Q0>(void *a1@<X0>, RB *a2@<X1>, unsigned int a3@<W2>, __int8 a4@<W3>, int a5@<W4>, int32x2_t **a6@<X8>, __n128 a7@<Q0>)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  *a6 = 0;
  char v13 = a1 + 47;
  for (uint64_t i = (uint64_t *)a1[48]; ; uint64_t i = (uint64_t *)a1[48])
  {
    while (1)
    {
      if (i == v13) {
        goto LABEL_15;
      }
      int v15 = (int32x2_t *)i[2];
      if ((RB *)v15[7] == a2)
      {
        uint32x2_t v16 = (uint32x2_t)vceq_s32(v15[8], (int32x2_t)a7.n128_u64[0]);
        if ((vpmin_u32(v16, v16).u32[0] & 0x80000000) != 0 && v15[9].u8[4] == a3 && v15[9].u8[6] == a5) {
          break;
        }
      }
      uint64_t i = (uint64_t *)i[1];
    }
    ++v15[1].i32[0];
    *a6 = v15;
    uint64_t v17 = *i;
    *(void *)(v17 + 8) = i[1];
    *(void *)i[1] = v17;
    --a1[49];
    std::__list_imp<RB::refcounted_ptr<RB::Texture>>::__delete_node[abi:nn180100]<>((int)v13, i);
    a1[53] -= v15[9].u32[0];
    uint64_t v18 = (id *)v15;
    if ((v15[9].i8[5] & 2) != 0) {
      uint64_t v18 = (id *)v15[3];
    }
    if (RB::Resource::set_volatile(v18, 0) != 2) {
      break;
    }
    *a6 = 0;
    int v20 = v15[1].i32[0] - 1;
    v15[1].i32[0] = v20;
    if (!v20) {
      (*(void (**)(int32x2_t *))(*(void *)v15 + 8))(v15);
    }
  }
  v15[9].i8[5] = 0;
  v15[10].i8[0] = a4;
  int v21 = *a6;
  if (*a6)
  {
LABEL_16:
    v21[6] = (int32x2_t)a1;
    return result;
  }
LABEL_15:
  int v22 = (RB *)RB::Texture::alloc((uint64_t)a1, (unint64_t)a2, a3, a5, 0, buf, a7);
  int v21 = *(int32x2_t **)buf;
  *a6 = *(int32x2_t **)buf;
  if (v21) {
    goto LABEL_16;
  }
  int v23 = RB::error_log(v22);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
  {
    uint64_t v25 = RB::pixel_format_name(a2, v24);
    *(_DWORD *)buf = 136316162;
    *(void *)&uint8_t buf[4] = v25;
    __int16 v28 = 1024;
    unsigned __int32 v29 = a7.n128_u32[0];
    __int16 v30 = 1024;
    unsigned __int32 v31 = a7.n128_u32[1];
    __int16 v32 = 1024;
    unsigned int v33 = a3;
    __int16 v34 = 1024;
    int v35 = a5;
    _os_log_fault_impl(&dword_2140F5000, v23, OS_LOG_TYPE_FAULT, "unable to create texture: %s, [%d, %d, %u], %d", buf, 0x24u);
  }
  return result;
}

void sub_21412998C(_Unwind_Exception *exception_object)
{
  if (*v1) {
    RB::Device::alloc_shared_texture(*v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::Resource::set_volatile(id *this, uint64_t a2)
{
  uint64_t v2 = a2;
  if (*((unsigned __int8 *)this + 44) != a2)
  {
    if (*((unsigned char *)this + 45))
    {
      if (a2) {
        uint64_t v4 = 3;
      }
      else {
        uint64_t v4 = 2;
      }
      uint64_t v5 = [this[2] setPurgeableState:v4];
      if ((v2 & 1) == 0 && [this[2] setPurgeableState:1] != 2) {
        return 2;
      }
    }
    else
    {
      uint64_t v5 = 2;
    }
    *((unsigned char *)this + 44) = v2;
    if (v5 == 4) {
      return 1;
    }
    else {
      return v2;
    }
  }
  return v2;
}

void std::__list_imp<RB::refcounted_ptr<RB::Texture>>::__delete_node[abi:nn180100]<>(int a1, void *__p)
{
  unsigned __int8 v3 = (_DWORD *)__p[2];
  if (v3)
  {
    int v4 = v3[2] - 1;
    v3[2] = v4;
    if (!v4) {
      (*(void (**)(_DWORD *))(*(void *)v3 + 8))(v3);
    }
  }
  operator delete(__p);
}

uint64_t RB::Device::depth_stencil_format(RB::Device *this, char a2, int a3)
{
  if (a2)
  {
    BOOL v3 = 1;
    if (!a3) {
      goto LABEL_3;
    }
LABEL_6:
    int v4 = !v3;
    goto LABEL_7;
  }
  BOOL v3 = *((unsigned char *)this + 280) != 0;
  if (a3) {
    goto LABEL_6;
  }
LABEL_3:
  int v4 = !v3;
  if (!*((unsigned char *)this + 281))
  {
    uint64_t v5 = 0;
    int v4 = 1;
    goto LABEL_8;
  }
LABEL_7:
  uint64_t v5 = 253;
LABEL_8:
  BOOL v6 = !v3;
  uint64_t v7 = 252;
  if (v6) {
    uint64_t v7 = v5;
  }
  if (v4) {
    return v7;
  }
  else {
    return 260;
  }
}

uint64_t RB::DisplayList::RootTexture::make_texture(uint64_t a1, MTLPixelFormat a2)
{
  if (*(void *)(a1 + 16)) {
    return 1;
  }
  unint64_t v5 = *(void *)(a2 + 8);
  uint64_t v6 = **(void **)a2;
  uint64_t v7 = RB::pixel_format_traits(v5, a2);
  if (((*v7 | ((unint64_t)*((unsigned __int16 *)v7 + 2) << 32)) & 0x10000000000) != 0)
  {
    *(unsigned char *)(a1 + 44) = 1;
    *(unsigned char *)(a1 + 45) = (v7[1] & 0x200) != 0;
  }
  else if (*(unsigned __int8 *)(a2 + 28) >= 2u)
  {
    *(unsigned char *)(a1 + 44) = 1;
  }
  else if (!*(unsigned char *)(a1 + 44))
  {
    goto LABEL_11;
  }
  if (!*(unsigned char *)(a1 + 45))
  {
    if (*(unsigned char *)(*(void *)(a1 + 24) + 73))
    {
      unsigned __int8 v9 = 1;
    }
    else
    {
      unsigned __int8 v9 = 1;
      if (*(unsigned char *)(v6 + 285))
      {
        if (*(_DWORD *)(a1 + 40) == 1) {
          unsigned __int8 v9 = 1;
        }
        else {
          unsigned __int8 v9 = 2;
        }
      }
    }
    if (v7[8]) {
      uint64_t v12 = (RB *)v7[8];
    }
    else {
      uint64_t v12 = (RB *)v5;
    }
    v8.n128_u64[0] = *(void *)(a2 + 16);
    __n128 v13 = RB::Device::alloc_shared_texture((void *)v6, v12, 1u, *(unsigned char *)(a2 + 29), v9, &v17, v8);
    int v14 = *(int32x2_t **)(a1 + 16);
    int v15 = v17;
    *(void *)(a1 + 16) = v17;
    uint64_t v17 = v14;
    if (v14)
    {
      int v16 = v14[1].i32[0] - 1;
      v14[1].i32[0] = v16;
      if (!v16)
      {
        (*(void (**)(int32x2_t *, __n128))(*(void *)v14 + 8))(v14, v13);
        int v15 = *(int32x2_t **)(a1 + 16);
      }
    }
    if (v15)
    {
      if ((*(unsigned char *)(a2 + 31) & 8) != 0) {
        *(unsigned char *)(*(void *)(a1 + 16) + 77) |= 4u;
      }
      return 1;
    }
    return 0;
  }
LABEL_11:
  if ((*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))()) {
    operator new();
  }
  unint64_t v10 = RB::error_log(0);
  BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v11)
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_2140F5000, v10, OS_LOG_TYPE_DEFAULT, "RBDrawable: no surface, dropping frame", buf, 2u);
    return 0;
  }
  return result;
}

void sub_214129D4C(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10A1C401006C202);
  _Unwind_Resume(a1);
}

uint64_t RB::Surface::texture(RB::Surface *this, MTLPixelFormat a2)
{
  uint64_t v2 = *((void *)this + 7);
  if (!v2)
  {
    if (*((void *)this + 2))
    {
      unint64_t v4 = *((void *)this + 4);
      int v12 = HIDWORD(*((void *)this + 3));
      int v5 = *((void *)this + 3);
      uint64_t v6 = RB::pixel_format_traits(v4, a2);
      if (((*v6 | ((unint64_t)*((unsigned __int16 *)v6 + 2) << 32)) & 0x10000000000) != 0)
      {
        unint64_t v9 = v4 - 2147483649u;
        unint64_t v4 = 23;
        uint64_t v8 = 7;
        switch(v9)
        {
          case 0uLL:
          case 1uLL:
            v5 *= 3;
            unint64_t v4 = 10;
            goto LABEL_13;
          case 2uLL:
            v5 *= 3;
            unint64_t v4 = 25;
            goto LABEL_13;
          case 3uLL:
          case 4uLL:
          case 5uLL:
            break;
          case 6uLL:
          case 7uLL:
            unint64_t v4 = 80;
            goto LABEL_13;
          case 8uLL:
          case 9uLL:
            unint64_t v4 = 70;
            goto LABEL_13;
          case 0xAuLL:
          case 0xBuLL:
            unint64_t v4 = 115;
LABEL_13:
            uint64_t v8 = 7;
            break;
          default:
            RB::precondition_failure((RB *)"unhandled resolved format: %d", v7, 23);
        }
      }
      else
      {
        uint64_t v8 = 5;
      }
      unint64_t v10 = (void *)[MEMORY[0x263F12A50] texture2DDescriptorWithPixelFormat:v4 width:v5 height:v12 mipmapped:0];
      [v10 setUsage:v8];
      uint64_t v2 = [*(id *)(*((void *)this + 2) + 24) newTextureWithDescriptor:v10 iosurface:*((void *)this + 6) plane:0];

      *((void *)this + 7) = v2;
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t RB::Texture::alloc@<X0>(uint64_t result@<X0>, unint64_t a2@<X1>, unsigned int a3@<W2>, int a4@<W4>, int a5@<W5>, void *a6@<X8>, __n128 a7@<Q0>)
{
  uint64_t v8 = (const float *)(result + 288);
  int32x2_t v9 = (int32x2_t)vld1_dup_f32(v8);
  uint32x2_t v10 = (uint32x2_t)vand_s8((int8x8_t)vcge_s32(v9, (int32x2_t)a7.n128_u64[0]), (int8x8_t)vcgtz_s32((int32x2_t)a7.n128_u64[0]));
  if ((vpmin_u32(v10, v10).u32[0] & 0x80000000) != 0)
  {
    uint64_t v15 = result;
    __n128 v27 = a7;
    unsigned int v16 = RB::max_mipmap_levels((int32x2_t)a7.n128_u64[0]);
    if (a3 <= 1) {
      unsigned int v17 = 1;
    }
    else {
      unsigned int v17 = a3;
    }
    if (v17 >= v16) {
      uint64_t v18 = v16;
    }
    else {
      uint64_t v18 = v17;
    }
    int v19 = (void *)[MEMORY[0x263F12A50] texture2DDescriptorWithPixelFormat:a2 width:v27.n128_i32[0] height:v27.n128_i32[1] mipmapped:v18 > 1];
    int v21 = v19;
    if (v18 >= 2) {
      [v19 setMipmapLevelCount:v18];
    }
    switch(a5)
    {
      case 0:
        goto LABEL_18;
      case 1:
        uint64_t v22 = 17040130;
        goto LABEL_17;
      case 2:
        uint64_t v22 = 33686018;
        goto LABEL_17;
      case 3:
        uint64_t v22 = 16908802;
        goto LABEL_17;
      case 4:
        uint64_t v22 = 50463234;
        goto LABEL_17;
      default:
        uint64_t v22 = 84148994;
LABEL_17:
        objc_msgSend(v21, "setSwizzle:", v22, *(_OWORD *)&v27);
LABEL_18:
        switch(a4)
        {
          case 0:
          case 6:
            MTLPixelFormat v24 = RB::pixel_format_traits(a2, v20);
            uint64_t v23 = 0;
            if (((*v24 | ((unint64_t)*((unsigned __int16 *)v24 + 2) << 32)) & 0x40000000000) != 0) {
              uint64_t v25 = 17;
            }
            else {
              uint64_t v25 = 1;
            }
            goto LABEL_30;
          case 1:
            int v26 = RB::pixel_format_traits(a2, v20);
            if (((*v26 | ((unint64_t)*((unsigned __int16 *)v26 + 2) << 32)) & 0x40000000000) != 0) {
              uint64_t v25 = 21;
            }
            else {
              uint64_t v25 = 5;
            }
            uint64_t v23 = 2;
LABEL_30:
            objc_msgSend(v21, "setUsage:", v25, *(_OWORD *)&v27);
            goto LABEL_31;
          case 2:
          case 3:
          case 4:
          case 5:
            [v21 setUsage:4];
            [v21 setStorageMode:2];
            if (!*(unsigned char *)(v15 + 283) || (*(unsigned char *)(v15 + 292) & 4) != 0) {
              goto LABEL_32;
            }
            uint64_t v23 = 3;
LABEL_31:
            objc_msgSend(v21, "setStorageMode:", v23, *(_OWORD *)&v27);
LABEL_32:
            uint64_t result = objc_msgSend(*(id *)(v15 + 24), "newTextureWithDescriptor:", v21, *(_OWORD *)&v27);
            if (result) {
              operator new();
            }
            return result;
          default:
            goto LABEL_32;
        }
    }
  }
  *a6 = 0;
  return result;
}

void sub_21412A144(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10A1C401006C202);
  _Unwind_Resume(a1);
}

uint64_t RB::Texture::Texture(uint64_t a1, void *a2, char a3, int a4, char a5)
{
  uint32x2_t v10 = (void *)RB::Resource::Resource(a1, (uint64_t)a2);
  *uint32x2_t v10 = &unk_26C4EDCF8;
  v10[6] = 0;
  *(void *)(a1 + 56) = [a2 pixelFormat];
  unsigned int v11 = [a2 width];
  *(void *)(a1 + 64) = __PAIR64__([a2 height], v11);
  *(_DWORD *)(a1 + 72) = 0;
  *(unsigned char *)(a1 + 76) = [a2 mipmapLevelCount];
  *(unsigned char *)(a1 + 77) = 0;
  *(unsigned char *)(a1 + 78) = a4;
  *(unsigned char *)(a1 + 79) = a5;
  *(unsigned char *)(a1 + 80) = a3;
  if ([a2 storageMode] != 3)
  {
    unsigned __int32 v13 = vmul_lane_s32(*(int32x2_t *)(a1 + 64), *(int32x2_t *)(a1 + 64), 1).u32[0];
    int v14 = RB::pixel_format_traits(*(void *)(a1 + 56), v12);
    if (*((unsigned char *)v14 + 6)) {
      int v15 = v13 * *((unsigned __int8 *)v14 + 6);
    }
    else {
      int v15 = 4 * v13;
    }
    *(_DWORD *)(a1 + 72) = v15;
  }
  if (a4 == 6) {
    *(unsigned char *)(a1 + 45) = 0;
  }
  return a1;
}

void sub_21412A264(_Unwind_Exception *a1)
{
  RB::Resource::~Resource(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::Resource::Resource(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 8) = 1;
  *(void *)uint64_t result = &unk_26C4EDD98;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  *(void *)(result + 16) = a2;
  *(void *)(result + 37) = 0;
  *(unsigned char *)(result + 45) = 1;
  return result;
}

uint64_t RB::max_mipmap_levels(int32x2_t a1)
{
  uint32x2_t v1 = (uint32x2_t)vcgt_s32(a1, (int32x2_t)0x100000001);
  uint64_t result = 1;
  if ((vpmax_u32(v1, v1).u32[0] & 0x80000000) != 0)
  {
    do
    {
      uint32x2_t v3 = (uint32x2_t)vcgt_s32(a1, (int32x2_t)0x300000003);
      a1 = vshr_n_s32(a1, 1uLL);
      uint64_t result = (result + 1);
    }
    while ((vpmax_u32(v3, v3).u32[0] & 0x80000000) != 0);
  }
  return result;
}

uint64_t ___ZN2RB18SharedSurfaceGroup21render_updates_deviceEv_block_invoke(uint64_t a1, MTLPixelFormat a2)
{
  return RB::Surface::texture(*(RB::Surface **)(a1 + 32), a2);
}

uint64_t RB::SurfacePool::alloc(os_unfair_lock_t lock, uint64_t a2, uint64_t a3, int a4, int a5, _CAImageQueue *a6, int32x2_t a7, int8x8_t a8)
{
  if ((a3 & 0x80000000) != 0)
  {
    if (!RB::Device::valid_texture_size_nonnative(a2, a3, a7)) {
      return 0;
    }
  }
  else
  {
    unsigned int v16 = (const float *)(a2 + 288);
    int32x2_t v17 = (int32x2_t)vld1_dup_f32(v16);
    uint32x2_t v18 = (uint32x2_t)vand_s8((int8x8_t)vcge_s32(v17, a7), (int8x8_t)vcgtz_s32(a7));
    if ((vpmin_u32(v18, v18).u32[0] & 0x80000000) == 0) {
      return 0;
    }
  }
  if (a6)
  {
    int v21 = (uint64_t *)RB::allocating_pool();
    uint64_t v22 = *v21;
    *int v21 = (uint64_t)lock;
    int v23 = RB::SurfacePool::wait_image_queue(lock, a6);
    *int v21 = v22;
    if (!v23) {
      return 0;
    }
  }
  os_unfair_lock_t locka = lock;
  char v42 = 1;
  os_unfair_lock_lock(lock);
  os_unfair_lock_t v24 = lock + 4;
  uint64_t v25 = *(void *)&lock[6]._os_unfair_lock_opaque;
  if (!v25)
  {
LABEL_47:
    std::unique_lock<RB::spin_lock>::unlock((uint64_t)&locka);
    operator new();
  }
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t v38 = 0;
  while (1)
  {
    --v25;
    uint64_t v26 = *(void *)&v24->_os_unfair_lock_opaque;
    uint64_t v27 = *(void *)(*(void *)&v24->_os_unfair_lock_opaque + 8 * v25);
    if (*(void *)(v27 + 120)) {
      goto LABEL_23;
    }
    uint32x2_t v28 = (uint32x2_t)vceq_s32(*(int32x2_t *)(v27 + 24), a7);
    if ((vpmin_u32(v28, v28).u32[0] & 0x80000000) != 0
      && *(void *)(v27 + 32) == a3
      && *(unsigned __int8 *)(v27 + 44) == a4
      && *(_DWORD *)(v27 + 40) == a5
      && *(void *)(v27 + 16) == a2)
    {
      break;
    }
LABEL_16:
    if (!*(unsigned char *)(v27 + 45))
    {
      if (!*(unsigned char *)(v27 + 140)) {
        goto LABEL_22;
      }
      if (!IOSurfaceIsInUse(*(IOSurfaceRef *)(v27 + 48)))
      {
        *(unsigned char *)(v27 + 140) = 0;
LABEL_22:
        RB::SurfacePool::set_surface_volatile((uint64_t)lock, *(RB::Surface **)(v26 + 8 * v25), 1u);
        goto LABEL_23;
      }
      if (!*(unsigned char *)(v27 + 140)) {
        goto LABEL_22;
      }
    }
LABEL_23:
    if (!v25)
    {
      uint64_t v25 = v40;
      if (HIDWORD(v39)) {
        goto LABEL_48;
      }
      if (v39)
      {
        uint64_t v25 = v38;
        RB::SurfacePool::set_surface_volatile((uint64_t)lock, *(RB::Surface **)(*(void *)&lock[4]._os_unfair_lock_opaque + 8 * v38), 0);
        goto LABEL_48;
      }
      goto LABEL_47;
    }
  }
  if (!*(unsigned char *)(v27 + 140)) {
    goto LABEL_30;
  }
  if (IOSurfaceIsInUse(*(IOSurfaceRef *)(v27 + 48)))
  {
    int v29 = *(unsigned __int8 *)(v27 + 140);
    uint64_t v27 = *(void *)(v26 + 8 * v25);
    if (!v29) {
      goto LABEL_30;
    }
    goto LABEL_16;
  }
  *(unsigned char *)(v27 + 140) = 0;
  uint64_t v27 = *(void *)(v26 + 8 * v25);
LABEL_30:
  if (*(unsigned char *)(v27 + 45))
  {
    uint64_t v30 = v38;
    if (!v39) {
      uint64_t v30 = v25;
    }
    uint64_t v38 = v30;
    LODWORD(v39) = 1;
    goto LABEL_23;
  }
  if (!a6) {
    goto LABEL_48;
  }
  unsigned __int32 v31 = (_CAImageQueue **)(v27 + 64);
  uint64_t v32 = *(void *)(v27 + 104);
  if (*(void *)(v27 + 96)) {
    unsigned __int32 v31 = *(_CAImageQueue ***)(v27 + 96);
  }
  if (!v32)
  {
LABEL_41:
    uint64_t v34 = v40;
    if (!HIDWORD(v39)) {
      uint64_t v34 = v25;
    }
    uint64_t v40 = v34;
    HIDWORD(v39) = 1;
    goto LABEL_23;
  }
  uint64_t v33 = 16 * v32;
  while (*v31 != a6)
  {
    v31 += 2;
    v33 -= 16;
    if (!v33) {
      goto LABEL_41;
    }
  }
LABEL_48:
  uint64_t v35 = *(void *)&v24->_os_unfair_lock_opaque;
  RB::Surface::set_padding(*(void *)(*(void *)&v24->_os_unfair_lock_opaque + 8 * v25), a8);
  double v36 = CACurrentMediaTime();
  if (a6) {
    uint64_t v37 = (uint64_t)a6;
  }
  else {
    uint64_t v37 = 1;
  }
  *(void *)(*(void *)(v35 + 8 * v25) + 120) = v37;
  uint64_t v19 = *(void *)(v35 + 8 * v25);
  *(double *)(v19 + 128) = v36;
  atomic_fetch_add_explicit((atomic_uint *volatile)(v19 + 8), 1u, memory_order_relaxed);
  if (v42) {
    os_unfair_lock_unlock(locka);
  }
  return v19;
}

void sub_21412A798(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, os_unfair_lock_t lock, char a14)
{
  MEMORY[0x21669AC10](v14, 0x10A1C409A7C8455);
  if (a14) {
    os_unfair_lock_unlock(lock);
  }
  _Unwind_Resume(a1);
}

void std::unique_lock<RB::spin_lock>::lock(uint64_t a1)
{
  uint64_t v2 = *(os_unfair_lock_s **)a1;
  if (v2)
  {
    if (!*(unsigned char *)(a1 + 8))
    {
      os_unfair_lock_lock(v2);
      *(unsigned char *)(a1 + 8) = 1;
      return;
    }
  }
  else
  {
    std::__throw_system_error(1, "unique_lock::lock: references null mutex");
  }
  std::__throw_system_error(11, "unique_lock::lock: already locked");
  RB::Surface::Surface(v3, v4, v5);
}

uint64_t RB::Surface::Surface(uint64_t a1, uint64_t a2, RB *this, int a4, int a5, double a6)
{
  *(_DWORD *)(a1 + 8) = 1;
  *(void *)a1 = &unk_26C4EDCC8;
  *(void *)(a1 + 16) = a2;
  *(double *)(a1 + 24) = a6;
  *(void *)(a1 + 32) = this;
  *(_DWORD *)(a1 + 40) = a5;
  *(unsigned char *)(a1 + 44) = a4;
  *(void *)(a1 + 48) = 0;
  uint64_t v8 = (CFTypeRef *)(a1 + 48);
  *(void *)(a1 + 56) = 0;
  *(unsigned char *)(a1 + 45) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 2;
  char v9 = a5 & 0x87;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 133) = 0;
  switch(a4)
  {
    case 0:
      v9 |= 8u;
      break;
    case 1:
      char v10 = 72;
      goto LABEL_7;
    case 2:
      v9 |= 0x10u;
      break;
    case 3:
      char v10 = 80;
LABEL_7:
      v9 |= v10;
      break;
    case 4:
      abort();
    case 5:
      v9 |= 0x20u;
      break;
    default:
      break;
  }
  iosurface = RB::create_iosurface(this, (MTLPixelFormat)LODWORD(a6), HIDWORD(a6), v9);
  if (*v8) {
    CFRelease(*v8);
  }
  *(void *)(a1 + 48) = iosurface;
  return a1;
}

void sub_21412A988(_Unwind_Exception *a1)
{
  if (*v3) {
    free(*v3);
  }
  RB::Surface::Surface(v2, v1);
  _Unwind_Resume(a1);
}

uint64_t RB::Surface::set_padding(uint64_t result, int8x8_t a2)
{
  v2.i32[0] = *(unsigned __int16 *)(result + 136);
  v2.i32[1] = *(unsigned __int16 *)(result + 138);
  int16x4_t v3 = (int16x4_t)vmvn_s8((int8x8_t)vceq_s32(v2, (int32x2_t)vand_s8(a2, (int8x8_t)0xFFFF0000FFFFLL)));
  if ((vmaxv_u16((uint16x4_t)vuzp1_s16(v3, v3)) & 0x8000) != 0)
  {
    uint64_t v4 = result;
    RB::Surface::destroy_queue_ids(result);
    uint64_t result = IOSurfaceSetBulkAttachments2();
    *(_WORD *)(v4 + 138) = a2.i16[2];
    *(_WORD *)(v4 + 136) = a2.i16[0];
  }
  return result;
}

__IOSurface *RB::create_iosurface(RB *this, MTLPixelFormat a2, uint64_t a3, char a4)
{
  MTLPixelFormat v6 = a2;
  v69[1] = *MEMORY[0x263EF8340];
  uint64_t v8 = RB::pixel_format_traits((unint64_t)this, a2);
  char v9 = v8;
  if (((*v8 | ((unint64_t)*((unsigned __int16 *)v8 + 2) << 32)) & 0x30000000000) == 0x10000000000) {
    char v10 = a4 | 2;
  }
  else {
    char v10 = a4;
  }
  if (this == (RB *)10) {
    unsigned int v11 = 1093677112;
  }
  else {
    unsigned int v11 = 0;
  }
  if ((v10 & 4) != 0) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = v8[3];
  }
  if ((v10 & 3) == 0 && v12 != 0 && v12 != 1599226420)
  {
    Default = (RB::_anonymous_namespace_ *)CAIOSurfaceCreateDefault();
    unint64_t v41 = Default;
    if (Default) {
      goto LABEL_60;
    }
  }
  int32x2_t v17 = (void *)[MEMORY[0x263EFF9A0] dictionary];
  if ((uint64_t)this > 539)
  {
    switch((unint64_t)this)
    {
      case 0x21CuLL:
        goto LABEL_38;
      case 0x21DuLL:
        goto LABEL_42;
      case 0x21EuLL:
        goto LABEL_34;
      case 0x21FuLL:
      case 0x220uLL:
      case 0x221uLL:
      case 0x222uLL:
      case 0x223uLL:
      case 0x224uLL:
      case 0x225uLL:
        goto LABEL_51;
      case 0x226uLL:
      case 0x227uLL:
        if (!plane_dict) {
          return 0;
        }
        if (!v21) {
          return 0;
        }
        uint64_t v22 = *(void *)v68 + v69[0];
        if (__CFADD__(*(void *)v68, v69[0])) {
          return 0;
        }
        v64[0] = plane_dict;
        v64[1] = v21;
        uint64_t v23 = [MEMORY[0x263EFF8C0] arrayWithObjects:v64 count:2];
        [v17 setObject:v23 forKeyedSubscript:*MEMORY[0x263F0EF00]];
        goto LABEL_46;
      default:
        if ((unint64_t)this - 0x80000001 < 2)
        {
          uint64_t v22 = 0;
          MTLPixelFormat v6 = (unint64_t)(3 * v6);
          uint64_t v24 = 1;
          goto LABEL_53;
        }
        if (this != (RB *)2147483651) {
          goto LABEL_51;
        }
        uint64_t v22 = 0;
        MTLPixelFormat v6 = (unint64_t)(3 * v6);
        uint64_t v24 = 2;
        break;
    }
    goto LABEL_53;
  }
  if ((uint64_t)this > 519)
  {
    if (this != (RB *)520)
    {
      if (this != (RB *)522)
      {
        if (this != (RB *)523) {
          goto LABEL_51;
        }
LABEL_34:
        if (!v27) {
          return 0;
        }
        if (!v28) {
          return 0;
        }
        uint64_t v22 = *(void *)v68 + v69[0];
        if (__CFADD__(*(void *)v68, v69[0])) {
          return 0;
        }
        v65[0] = v27;
        v65[1] = v28;
        uint64_t v29 = [MEMORY[0x263EFF8C0] arrayWithObjects:v65 count:2];
        [v17 setObject:v29 forKeyedSubscript:*MEMORY[0x263F0EF00]];
        goto LABEL_46;
      }
      goto LABEL_42;
    }
  }
  else if (this != (RB *)500)
  {
    if (this != (RB *)502)
    {
      if (this != (RB *)503)
      {
LABEL_51:
        uint64_t v24 = *((unsigned __int8 *)v9 + 6);
        if (*((unsigned char *)v9 + 6))
        {
          uint64_t v22 = 0;
          goto LABEL_53;
        }
        return 0;
      }
      goto LABEL_34;
    }
LABEL_42:
    if (!v37) {
      return 0;
    }
    if (!v38) {
      return 0;
    }
    uint64_t v22 = *(void *)v68 + v69[0];
    if (__CFADD__(*(void *)v68, v69[0])) {
      return 0;
    }
    v66[0] = v37;
    v66[1] = v38;
    uint64_t v39 = [MEMORY[0x263EFF8C0] arrayWithObjects:v66 count:2];
    [v17 setObject:v39 forKeyedSubscript:*MEMORY[0x263F0EF00]];
    goto LABEL_46;
  }
LABEL_38:
  if (!v32) {
    return 0;
  }
  if (!v33) {
    return 0;
  }
  uint64_t v22 = *(void *)v68 + v69[0];
  if (__CFADD__(*(void *)v68, v69[0])) {
    return 0;
  }
  v67[0] = v32;
  v67[1] = v33;
  uint64_t v34 = [MEMORY[0x263EFF8C0] arrayWithObjects:v67 count:2];
  [v17 setObject:v34 forKeyedSubscript:*MEMORY[0x263F0EF00]];
LABEL_46:
  uint64_t v24 = 0;
LABEL_53:
  uint64_t v42 = [NSNumber numberWithUnsignedInt:v6];
  [v17 setObject:v42 forKeyedSubscript:*MEMORY[0x263F0EF50]];
  uint64_t v43 = [NSNumber numberWithUnsignedInt:a3];
  [v17 setObject:v43 forKeyedSubscript:*MEMORY[0x263F0EDF8]];
  if (v12)
  {
    uint64_t v44 = [NSNumber numberWithUnsignedInt:v12];
    [v17 setObject:v44 forKeyedSubscript:*MEMORY[0x263F0EE48]];
  }
  if (v24)
  {
    uint64_t v45 = [NSNumber numberWithUnsignedInt:v24];
    [v17 setObject:v45 forKeyedSubscript:*MEMORY[0x263F0ED48]];
  }
  if (v22)
  {
    uint64_t v46 = [NSNumber numberWithUnsignedLong:v22];
    [v17 setObject:v46 forKeyedSubscript:*MEMORY[0x263F0ED30]];
  }
  uint64_t v47 = [NSNumber numberWithBool:v10 & 1];
  [v17 setObject:v47 forKeyedSubscript:*MEMORY[0x263F0EE50]];
  Default = IOSurfaceCreate((CFDictionaryRef)v17);
  unint64_t v41 = Default;
LABEL_60:
  if ((v10 & 0x78) == 0 || v41 == 0) {
    return v41;
  }
  if ((v10 & 8) != 0)
  {
    unint64_t v51 = *v9 | ((unint64_t)*((unsigned __int16 *)v9 + 2) << 32);
    if ((v51 & 0x200000000) != 0)
    {
      if ((v10 & 0x40) == 0)
      {
        {
          if (v56)
          {
            unint64_t v57 = (CGColorSpace *)RB::extended_linear_srgb_colorspace(v56);
          }
        }
          goto LABEL_92;
        return v41;
      }
    }
    else if ((v51 & 0xA00000000) == 0)
    {
      {
        if (v58)
        {
          int v59 = (CGColorSpace *)RB::srgb_colorspace(v58);
        }
      }
        goto LABEL_92;
      return v41;
    }
    goto LABEL_91;
  }
  if ((v10 & 0x10) == 0)
  {
    if ((v10 & 0x20) == 0) {
      return v41;
    }
    {
      if (v54)
      {
        int v55 = (CGColorSpace *)RB::pq_colorspace(v54);
      }
    }
      return v41;
LABEL_92:
    IOSurfaceSetValue(v41, (CFStringRef)*MEMORY[0x263F0EDA0], v49);
    return v41;
  }
  unint64_t v53 = *v9 | ((unint64_t)*((unsigned __int16 *)v9 + 2) << 32);
  if ((v53 & 0x200000000) != 0)
  {
    if ((v10 & 0x40) != 0)
    {
LABEL_90:
LABEL_91:
      int v49 = (const void *)v52;
      if (!v52) {
        return v41;
      }
      goto LABEL_92;
    }
    {
      if (v60)
      {
        unint64_t v61 = (CGColorSpace *)RB::extended_linear_display_p3_colorspace(v60);
      }
    }
      goto LABEL_92;
  }
  else
  {
    if ((v53 & 0xA00000000) != 0) {
      goto LABEL_90;
    }
    {
      if (v62)
      {
        uint64_t v63 = (CGColorSpace *)RB::display_p3_colorspace(v62);
      }
    }
      goto LABEL_92;
  }
  return v41;
}

void sub_21412B168(_Unwind_Exception *a1)
{
}

uint64_t RB::Surface::destroy_queue_ids(uint64_t this)
{
  uint64_t v1 = this;
  uint64_t v2 = *(void *)(this + 104);
  if (*(void *)(this + 96)) {
    uint64_t v3 = *(void *)(this + 96);
  }
  else {
    uint64_t v3 = this + 64;
  }
  if (v2)
  {
    uint64_t v4 = v3 + 16 * v2;
    do
    {
      v3 += 16;
      this = CAImageQueueUnregisterBuffer();
    }
    while (v3 != v4);
  }
  *(void *)(v1 + 104) = 0;
  return this;
}

uint64_t RB::SurfacePool::wait_image_queue(os_unfair_lock_s *this, _CAImageQueue *a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  os_unfair_lock_lock(this);
  RB::SurfacePool::remove_watched_queue_locked((RB::SurfacePool *)this, a2, 0);
  os_unfair_lock_unlock(this);
  if (CAImageQueueCollect()) {
    return 1;
  }
  LastUpdateHostTime = (RB *)CAImageQueueGetLastUpdateHostTime();
  double v6 = RB::time_seconds(LastUpdateHostTime);
  double v7 = CACurrentMediaTime();
  if (v7 - v6 > 0.2)
  {
    uint64_t v8 = (RB *)CAImageQueueConsumeUnconsumedInRange();
    if (!v8 || (uint64_t v8 = (RB *)CAImageQueueCollect()) == 0)
    {
      char v9 = RB::error_log(v8);
      BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
      uint64_t result = 0;
      if (v10)
      {
        int v15 = 134217984;
        unsigned int v16 = a2;
        unsigned int v11 = "RBLayer: stale image queue, %p";
LABEL_19:
        _os_log_impl(&dword_2140F5000, v9, OS_LOG_TYPE_DEFAULT, v11, (uint8_t *)&v15, 0xCu);
        return 0;
      }
      return result;
    }
    return 1;
  }
  if (CAImageQueueCollect()) {
    return 1;
  }
  useconds_t v12 = 100;
  while (1)
  {
    CAImageQueueSetFlags();
    CAImageQueueSetFlags();
    if (CACurrentMediaTime() - v7 >= 0.1) {
      break;
    }
    usleep(v12);
    if (2 * v12 >= 0x7D0) {
      useconds_t v12 = 2000;
    }
    else {
      v12 *= 2;
    }
    if (CAImageQueueCollect()) {
      return 1;
    }
  }
  char v9 = RB::error_log(v13);
  BOOL v14 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v14)
  {
    int v15 = 134217984;
    unsigned int v16 = a2;
    unsigned int v11 = "RBLayer: full image queue, %p";
    goto LABEL_19;
  }
  return result;
}

void sub_21412B410(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void RB::SurfacePool::remove_watched_queue_locked(RB::SurfacePool *this, _CAImageQueue *a2, int a3)
{
  unint64_t v3 = *((void *)this + 13);
  if (v3)
  {
    unint64_t v7 = 0;
    uint64_t v8 = MEMORY[0x263EF83A0];
    do
    {
      uint64_t v9 = *((void *)this + 12);
      if (*(_CAImageQueue **)(v9 + 16 * v7) == a2)
      {
        uint64_t v10 = v9 + 16 * v7;
        unsigned int v11 = *(void **)(v10 + 8);
        uint64_t v12 = v9 + 16 * v3;
        *(_OWORD *)uint64_t v10 = *(_OWORD *)(v12 - 16);
        *(void *)(v12 - 16) = a2;
        *(void *)(v12 - 8) = v11;
        --*((void *)this + 13);
        if (a3)
        {
          id v13 = v11;
          if ([v13 retainCount] == 1) {
            id v14 = v13;
          }
          else {
            dispatch_async_f(v8, v13, (dispatch_function_t)RB::SurfacePool::remove_watched_queue_locked(_CAImageQueue *,BOOL)::$_0::__invoke);
          }
        }
      }
      else
      {
        ++v7;
      }
      unint64_t v3 = *((void *)this + 13);
    }
    while (v7 < v3);
  }
}

uint64_t RB::anonymous namespace'::extended_srgb_data(RB::_anonymous_namespace_ *this)
{
  {
    if (v2)
    {
      unint64_t v3 = (CGColorSpace *)RB::extended_srgb_colorspace(v2);
    }
  }
}

void sub_21412B55C(_Unwind_Exception *a1)
{
}

uint64_t RB::srgb_colorspace(RB *this)
{
  uint64_t v1 = &color_symbols(void)::flag;
  {
    uint64_t v1 = &color_symbols(void)::flag;
    if (v3)
    {
      RB::srgb_colorspace(void)::r = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x263F002D8]);
      uint64_t v1 = &color_symbols(void)::flag;
    }
  }
  return *((void *)v1 + 77);
}

id __copy_helper_block_e8_32c40_ZTSN2RB14refcounted_ptrINS_8DrawableEEE40c38_ZTSN2RB14refcounted_ptrINS_6DeviceEEE48c59_ZTSN2RB8objc_ptrIPU22objcproto11RBEncodable11objc_objectEE(void *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 32);
  if (v3) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v3 + 8), 1u, memory_order_relaxed);
  }
  a1[4] = v3;
  uint64_t v4 = *(void *)(a2 + 40);
  if (v4) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
  }
  a1[5] = v4;
  id result = *(id *)(a2 + 48);
  a1[6] = result;
  return result;
}

void sub_21412B648(_Unwind_Exception *a1)
{
  uint64_t v4 = *(atomic_uint **)(v1 + 40);
  if (v4) {
    __copy_helper_block_e8_32c40_ZTSN2RB14refcounted_ptrINS_8DrawableEEE40c38_ZTSN2RB14refcounted_ptrINS_6DeviceEEE48c59_ZTSN2RB8objc_ptrIPU22objcproto11RBEncodable11objc_objectEE_cold_2(v4);
  }
  __copy_helper_block_e8_32c40_ZTSN2RB14refcounted_ptrINS_8DrawableEEE40c38_ZTSN2RB14refcounted_ptrINS_6DeviceEEE48c59_ZTSN2RB8objc_ptrIPU22objcproto11RBEncodable11objc_objectEE_cold_1(v2);
  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::Builder::merge_layer_item(RB::DisplayList::Builder *this, RB::DisplayList::Layer *a2, int a3)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)a2;
  if (!*(void *)a2) {
    return 0;
  }
  if (*(void *)(v3 + 8)) {
    return 0;
  }
  __int16 v5 = *(_WORD *)(v3 + 46);
  if ((v5 & 0x1C0) != 0 || !RB::may_discard_dest(v5 & 0x3F)) {
    return 0;
  }
  if (!*(void *)(v3 + 24))
  {
LABEL_13:
    if ((a3 & 8) == 0 || (*(unsigned int (**)(uint64_t))(*(void *)v3 + 80))(v3))
    {
      char v9 = 1;
      if ((a3 & 1) == 0 && !*((unsigned char *)a2 + 64) && !*((void *)a2 + 2) && *((float *)a2 + 12) == 0.0)
      {
        unsigned int v10 = *((_DWORD *)a2 + 15);
        int v11 = (v10 >> 3) & 1;
        if ((a3 & 2) != 0) {
          LOBYTE(v11) = 0;
        }
        if ((v10 & 0x2207) != 0) {
          char v9 = 1;
        }
        else {
          char v9 = v11;
        }
      }
      int v26 = a3;
      if ((*(_WORD *)(v3 + 46) & 0x200) != 0)
      {
        if (v9)
        {
          uint64_t v12 = *(void *)(v3 + 48);
          if (!v12
            || !RB::DisplayList::Builder::merge_layer_item(RB::DisplayList::Layer &,unsigned int)::$_0::operator()(&v26, (uint64_t)a2, *(void *)(v3 + 48)))
          {
            return 0;
          }
          RB::DisplayList::Layer::move_filters(v12, a2);
          if ((*((unsigned char *)a2 + 61) & 2) != 0) {
            *(_DWORD *)(v12 + 60) |= 0x200u;
          }
          float v13 = *(float *)(v12 + 48);
          float v14 = *((float *)a2 + 12);
          if (v13 != 0.0 || v14 != 0.0)
          {
            if (v14 != 0.0 && *(void *)(v3 + 24))
            {
              unsigned int v15 = *((_DWORD *)a2 + 12);
              float32x2_t v16 = vrecpe_f32((float32x2_t)LODWORD(v14));
              float32x2_t v17 = vmul_f32(vrecps_f32((float32x2_t)v15, v16), v16);
              *(double *)&unint64_t v18 = vmul_f32(v17, vrecps_f32((float32x2_t)v15, v17)).f32[0];
              *(void *)&long long v19 = 0;
              *((void *)&v19 + 1) = v18;
              v23[0] = v18;
              v23[1] = v19;
              uint64_t v24 = 0;
              uint64_t v25 = 0;
              RB::DisplayList::CachedTransform::CachedTransform((uint64_t)v27, (uint64_t)this, v23, 0, 0, 0);
              *(void *)(v3 + 24) = RB::DisplayList::CachedTransform::transform_clip((RB::DisplayList::CachedTransform *)v27, *(void *)(v3 + 24), 0);
              RB::DisplayList::CachedTransform::~CachedTransform((RB::DisplayList::CachedTransform *)v27);
              float v13 = *(float *)(v12 + 48);
              float v14 = *((float *)a2 + 12);
            }
            if (v13 == 0.0) {
              float v13 = 1.0;
            }
            if (v14 == 0.0) {
              float v14 = 1.0;
            }
            *(float *)(v12 + 48) = v14 * v13;
          }
          if (*((unsigned char *)a2 + 64))
          {
            *(unsigned char *)(v12 + 64) = *((unsigned char *)a2 + 64);
            *(void *)(v12 + 24) = *((void *)a2 + 3);
          }
          int v20 = *((_DWORD *)a2 + 15);
          if ((v20 & 0x2000) != 0)
          {
            char v21 = *(unsigned char *)(v12 + 67);
            if (v21)
            {
              v20 &= ~0x2000u;
              *((_DWORD *)a2 + 15) = v20;
              *(unsigned char *)(v12 + 67) = v21 - 1;
            }
          }
          *(_DWORD *)(v12 + 60) |= v20;
        }
      }
      else if (v9)
      {
        return 0;
      }
      *(void *)a2 = 0;
      return v3;
    }
    return 0;
  }
  uint64_t result = 0;
  if ((a3 & 4) == 0 && !*((unsigned char *)a2 + 64))
  {
    uint64_t v8 = (void *)*((void *)a2 + 2);
    if (v8)
    {
      while (((*(uint64_t (**)(void *))(*v8 + 64))(v8) & 1) != 0)
      {
        uint64_t v8 = (void *)v8[1];
        if (!v8) {
          goto LABEL_13;
        }
      }
      return 0;
    }
    goto LABEL_13;
  }
  return result;
}

void sub_21412B92C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  RB::DisplayList::CachedTransform::~CachedTransform((RB::DisplayList::CachedTransform *)va);
  _Unwind_Resume(a1);
}

unint64_t RB::may_discard_dest(unsigned int a1)
{
  return (a1 > 0x2F) | (0x7FFFFFAEFE47uLL >> a1) & 1;
}

void RB::Device::make_render_pipeline_descriptor(RB::FormattedRenderState,objc_object  {objcproto10MTLLibrary}*,objc_object  {objcproto16MTLBinaryArchive}*,MTLRenderPipelineDescriptor *,RB::JSONPipelineData *,RB::objc_ptr<MTLFunctionConstantValues *> *)::$_0::operator()<RB::anonymous namespace'::shader_description::Fn,MTLFunctionDescriptor *>(uint64_t **a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, void *a4@<X3>, RB **a5@<X8>)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  [a4 setName:*(void *)a3];
  if (*(unsigned char *)(a3 + 8))
  {
    int v10 = *((_DWORD *)*a1 + 2);
    uint64_t v16 = **a1;
    int v17 = v10;
    RB::FormattedRenderState::ID::formatted((uint64_t)&v16, (uint64_t)v18);
    snprintf(__str, 0x100uLL, "%c%s", a2, v18);
    objc_msgSend(a4, "setSpecializedName:", objc_msgSend(NSString, "stringWithUTF8String:", __str));
    [a4 setConstantValues:a1[3]];
  }
  if (a1[2])
  {
    unsigned int v15 = a1[2];
    objc_msgSend(a4, "setBinaryArchives:", objc_msgSend(MEMORY[0x263EFF8C0], "arrayWithObjects:count:", &v15, 1));
  }
  unsigned int v11 = 0;
  *(void *)__str = 0;
  do
  {
    uint64_t v12 = (RB *)[a1[1] newFunctionWithDescriptor:a4 error:__str];

    if (v12) {
      BOOL v13 = 1;
    }
    else {
      BOOL v13 = v11 >= 2;
    }
    ++v11;
  }
  while (!v13);
  if (a2 == 118) {
    float v14 = "vertex function";
  }
  else {
    float v14 = "fragment function";
  }
  *a5 = v12;
}

void sub_21412BB00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void RB::anonymous namespace'::check_error(RB *a1, void *a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  uint64_t v15 = a4;
  int v16 = a5;
  if (a1)
  {
    unint64_t v7 = (RB *)RB::verbose_mode(a1);
    if (a2 && v7)
    {
      uint64_t v8 = RB::error_log(v7);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        char v9 = RB::RenderState::name((RB::RenderState *)&v15);
        uint64_t v17 = v15;
        int v18 = v16;
        RB::FormattedRenderState::ID::formatted((uint64_t)&v17, (uint64_t)&v19);
        uint64_t v10 = [a2 localizedDescription];
        *(_DWORD *)buf = 136315906;
        uint64_t v22 = a3;
        __int16 v23 = 2080;
        uint64_t v24 = v9;
        __int16 v25 = 2080;
        int v26 = &v19;
        __int16 v27 = 2112;
        uint64_t v28 = v10;
        _os_log_error_impl(&dword_2140F5000, v8, OS_LOG_TYPE_ERROR, "shader warning: %s, %s-%s: %@", buf, 0x2Au);
      }
    }
  }
  else
  {
    unsigned int v11 = RB::RenderState::name((RB::RenderState *)&v15);
    uint64_t v19 = v15;
    int v20 = v16;
    RB::FormattedRenderState::ID::formatted((uint64_t)&v19, (uint64_t)buf);
    if (a2)
    {
      uint64_t v14 = objc_msgSend((id)objc_msgSend(a2, "localizedDescription"), "UTF8String");
      RB::non_fatal_precondition_failure((RB *)"%s error: %s-%s: %s", v13, a3, v11, buf, v14);
    }
    else
    {
      RB::non_fatal_precondition_failure((RB *)"%s error: %s-%s: nil", v12, a3, v11, buf);
    }
  }
}

uint64_t RB::FormattedRenderState::ID::formatted@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = 0;
  for (uint64_t i = 0; i != 12; ++i)
  {
    if (i % 3u == 2)
    {
      int v7 = *(unsigned __int8 *)(this + i);
      uint64_t v6 = v2 + 1;
      *(unsigned char *)(a2 + v2) = RB::FormattedRenderState::ID::formatted(void)const::table[((unint64_t)(v7 | (*(unsigned __int8 *)(this + i - 1) << 8)) >> 6) & 0x3F];
      unint64_t v4 = v7 & 0x3F;
      uint64_t v5 = 2;
    }
    else
    {
      if (i % 3u == 1)
      {
        unint64_t v4 = ((unint64_t)(*(unsigned __int8 *)(this + i) | (*(unsigned __int8 *)(this + i - 1) << 8)) >> 4) & 0x3F;
      }
      else
      {
        if (i % 3u) {
          continue;
        }
        unint64_t v4 = (unint64_t)*(unsigned __int8 *)(this + i) >> 2;
      }
      uint64_t v5 = 1;
      uint64_t v6 = v2;
    }
    v2 += v5;
    *(unsigned char *)(a2 + v6) = RB::FormattedRenderState::ID::formatted(void)const::table[v4];
  }
  *(unsigned char *)(a2 + v2) = 0;
  return this;
}

char **RB::SharedSurfaceGroup::render_updates_device(os_unfair_lock_s *this)
{
  uint64_t v98 = *MEMORY[0x263EF8340];
  uint64_t v93 = 0;
  unsigned int v92 = 0;
  uint64_t v2 = this + 4;
  os_unfair_lock_lock(this + 4);
  uint64_t v3 = this + 6;
  unint64_t v74 = (RB::Device **)this;
  unint64_t v4 = *(os_unfair_lock_s **)&this[8]._os_unfair_lock_opaque;
  if (v4 != &this[6])
  {
    do
    {
      uint64_t v5 = (os_unfair_lock_s *)(*(void *)&v4[4]._os_unfair_lock_opaque + 112);
      os_unfair_lock_lock(v5);
      uint64_t v6 = *(atomic_uint **)&v4[4]._os_unfair_lock_opaque;
      if (!v6[32] && !v6[36]) {
        goto LABEL_8;
      }
      int v7 = v93;
      if (HIDWORD(v93) < (v93 + 1))
      {
        RB::vector<RB::DisplayList::Interpolator::Contents::AnimationTableItem,0ul,unsigned int>::reserve_slow((uint64_t)&v92, v93 + 1);
        int v7 = v93;
        uint64_t v6 = *(atomic_uint **)&v4[4]._os_unfair_lock_opaque;
        uint64_t v8 = v92;
        char v9 = &v92[40 * v93];
        if (!v6)
        {
          int v10 = v93;
          int v11 = v93;
          goto LABEL_7;
        }
      }
      else
      {
        uint64_t v8 = v92;
        char v9 = &v92[40 * v93];
      }
      atomic_fetch_add_explicit(v6 + 2, 1u, memory_order_relaxed);
      int v10 = v93;
      int v11 = v93;
LABEL_7:
      *(void *)char v9 = v6;
      uint64_t v12 = &v8[40 * v7];
      *(_OWORD *)(v12 + 8) = 0u;
      *(_OWORD *)(v12 + 24) = 0u;
      LODWORD(v93) = v11 + 1;
      BOOL v13 = &v8[40 * v10];
      uint64_t v14 = *(void *)&v4[4]._os_unfair_lock_opaque;
      uint64_t v15 = *((void *)v13 + 1);
      *((void *)v13 + 1) = *(void *)(v14 + 120);
      *(void *)(v14 + 120) = v15;
      LODWORD(v15) = *((_DWORD *)v13 + 4);
      *((_DWORD *)v13 + 4) = *(_DWORD *)(v14 + 128);
      *(_DWORD *)(v14 + 128) = v15;
      LODWORD(v15) = *((_DWORD *)v13 + 5);
      *((_DWORD *)v13 + 5) = *(_DWORD *)(v14 + 132);
      *(_DWORD *)(v14 + 132) = v15;
      int v16 = &v92[40 * (v93 - 1)];
      uint64_t v17 = *(void *)&v4[4]._os_unfair_lock_opaque;
      uint64_t v18 = *((void *)v16 + 3);
      *((void *)v16 + 3) = *(void *)(v17 + 136);
      *(void *)(v17 + 136) = v18;
      LODWORD(v18) = *((_DWORD *)v16 + 8);
      *((_DWORD *)v16 + 8) = *(_DWORD *)(v17 + 144);
      *(_DWORD *)(v17 + 144) = v18;
      LODWORD(v18) = *((_DWORD *)v16 + 9);
      *((_DWORD *)v16 + 9) = *(_DWORD *)(v17 + 148);
      *(_DWORD *)(v17 + 148) = v18;
      *(unsigned char *)(*(void *)&v4[4]._os_unfair_lock_opaque + 172) = 1;
LABEL_8:
      os_unfair_lock_unlock(v5);
      unint64_t v4 = *(os_unfair_lock_s **)&v4[2]._os_unfair_lock_opaque;
    }
    while (v4 != v3);
  }
  os_unfair_lock_unlock(v2);
  if (!v93)
  {
    RB::Drawable::end_frame(v74[1], 0.0);
    uint32_t v65 = 0;
    char v64 = 0;
    goto LABEL_56;
  }
  uint64_t v19 = RB::RenderFrame::RenderFrame((RB::RenderFrame *)v96, *v74, v74[1], 1u);
  if (!v93)
  {
LABEL_53:
    char v64 = 0;
    goto LABEL_54;
  }
  LOBYTE(v21) = 0;
  uint64_t v22 = v92;
  __int16 v23 = &v92[40 * v93];
  *(void *)&long long v82 = v91;
  *(void *)&long long v81 = v23;
  do
  {
    uint64_t v24 = *((unsigned int *)v22 + 4);
    if (!v24) {
      goto LABEL_27;
    }
    if (v24 >= 0x41)
    {
      int v26 = (int32x2_t *)malloc_type_malloc(v24 << 6, 0xE5EE567EuLL);
      if (!v26) {
        goto LABEL_26;
      }
    }
    else
    {
      MEMORY[0x270FA5388](v19, v24 << 6);
      int v26 = (int32x2_t *)((char *)&v71 - ((v25 + 15) & 0x7FFFFFFFF0));
      bzero(v26, v25);
    }
    char v27 = (char)v21;
    uint64_t v28 = *((unsigned int *)v22 + 4);
    if (v28)
    {
      unint64_t v29 = 0;
      uint64_t v30 = v28 << 6;
      do
      {
        unint64_t v31 = *((void *)v22 + 1) + v29;
        int v32 = *(_DWORD *)(v31 + 52);
        uint64_t v33 = objc_msgSend(*(id *)v31, "_rb_contents");
        int32x2_t v34 = vdup_n_s32(v32 << 30 >> 31);
        int32x2_t v36 = *(int32x2_t *)(v31 + 8);
        int32x2_t v35 = *(int32x2_t *)(v31 + 16);
        if ((v32 & 4) != 0) {
          int v37 = 2;
        }
        else {
          int v37 = 1;
        }
        long long v38 = *(_OWORD *)(v31 + 32);
        uint64_t v39 = &v26[v29 / 8];
        int32x2_t *v39 = (int32x2_t)v33;
        v39[1] = 0;
        v39[2] = v34;
        v39[3] = v35;
        v39[4] = v36;
        v39[5].i32[0] = v37;
        *(_OWORD *)v39[6].i8 = v38;
        v29 += 64;
      }
      while (v30 != v29);
    }
    char v21 = *(const RB::Surface **)(*(void *)v22 + 24);
    RB::RenderParams::RenderParams((RB::RenderParams *)v95, (RB::RenderFrame *)v96, v21, *(float *)(*(void *)v22 + 64));
    v90[0] = MEMORY[0x263EF8330];
    v90[1] = 3221225472;
    v91[0] = ___ZN2RB18SharedSurfaceGroup21render_updates_deviceEv_block_invoke;
    v91[1] = &__block_descriptor_40_e19____MTLTexture__8__0l;
    int32x2_t v91[2] = v21;
    RB::DisplayList::render_many(v95, (uint64_t)v90, *((unsigned int *)v22 + 4), v26);
    LOBYTE(v21) = v27;
    __int16 v23 = (char *)v81;
    if (v24 >= 0x41) {
LABEL_26:
    }
      free(v26);
LABEL_27:
    LODWORD(v21) = (v21 & 1) != 0 || *((_DWORD *)v22 + 8) != 0;
    v22 += 40;
  }
  while (v22 != v23);
  if ((v21 & 1) == 0) {
    goto LABEL_53;
  }
  char v40 = *((unsigned char *)*v74 + 292);
  if (v93)
  {
    int v72 = (int)v21;
    unint64_t v41 = 0;
    uint64_t v42 = v92;
    uint64_t v43 = &v92[40 * v93];
    int32x2_t v79 = &v94;
    __asm { FMOV            V12.2S, #1.0 }
    long long v78 = xmmword_2142181C0;
    long long v77 = xmmword_2142181D0;
    int v75 = &off_214218000;
    unint64_t v73 = v43;
    do
    {
      int v49 = *(const RB::Surface **)(*(void *)v42 + 24);
      uint64_t v50 = RB::pixel_format_traits(*((void *)v49 + 4), v20);
      if (((*v50 | ((unint64_t)*((unsigned __int16 *)v50 + 2) << 32)) & 0x40000000000) != 0
        && !RB::disable_workaround((RB *)"blit-planar-texture", v51))
      {
        if (v41) {
          [v41 endEncoding];
        }
        RB::RenderParams::RenderParams((RB::RenderParams *)&v83, (RB::RenderFrame *)v96, v49, *(float *)(*(void *)v42 + 64));
        operator new();
      }
      if (!v41)
      {
        RB::RenderFrame::end_encoding(v96);
        blit_encoder = (void *)RB::RenderFrame::make_blit_encoder((RB::RenderFrame *)v96);
        unint64_t v41 = blit_encoder;
        if (v40) {
          [blit_encoder setLabel:@"RB: Shared surface blit"];
        }
      }
      uint64_t v53 = RB::Surface::texture(v49, (MTLPixelFormat)v51);
      uint64_t v55 = *((unsigned int *)v42 + 8);
      if (v55)
      {
        uint64_t v56 = v53;
        unint64_t v76 = v42;
        unint64_t v57 = (void *)*((void *)v42 + 3);
        uint64_t v58 = 48 * v55;
        do
        {
          *(void *)&long long v54 = v57[2];
          long long v81 = v54;
          *(void *)&long long v54 = v57[3];
          long long v80 = v54;
          *(void *)&long long v54 = v57[4];
          long long v82 = v54;
          if (v40)
          {
            snprintf((char *)v95, 0x100uLL, "Blit [%d %d, %d] [%d, %d, %d] [%d %d] [%d %d] [%d %d]", *(void *)(*(void *)(*v57 + 24) + 32), *(void *)(*(void *)(*v57 + 24) + 24), HIDWORD(*(void *)(*(void *)(*v57 + 24) + 24)), *((void *)v49 + 4), *((void *)v49 + 3), HIDWORD(*((void *)v49 + 3)), v81, DWORD1(v81), v82, DWORD1(v82), v80, DWORD1(v80));
            int v59 = (void *)[[NSString alloc] initWithCString:v95 encoding:1];
            [v41 insertDebugSignpost:v59];
          }
          uint64_t v60 = RB::Surface::texture(*(RB::Surface **)(*v57 + 24), v20);
          *(void *)&long long v61 = (int)v81;
          *((void *)&v61 + 1) = SDWORD1(v81);
          long long v62 = v61;
          *(void *)&long long v61 = (int)v80;
          *((void *)&v61 + 1) = SDWORD1(v80);
          long long v63 = v61;
          long long v88 = v62;
          *(void *)&long long v61 = (int)v82;
          *((void *)&v61 + 1) = SDWORD1(v82);
          uint64_t v89 = 0;
          long long v86 = v61;
          uint64_t v87 = 1;
          long long v84 = v63;
          uint64_t v85 = 0;
          [v41 copyFromTexture:v60 sourceSlice:0 sourceLevel:0 sourceOrigin:&v88 sourceSize:&v86 toTexture:v56 destinationSlice:0 destinationLevel:0 destinationOrigin:&v84];
          if ((v40 & 4) != 0)
          {
            [v41 endEncoding];
            unint64_t v41 = 0;
          }
          v57 += 6;
          v58 -= 48;
        }
        while (v58);
        uint64_t v42 = v76;
        uint64_t v43 = v73;
      }
      v42 += 40;
    }
    while (v42 != v43);
    char v64 = v72;
    if (v41) {
      [v41 endEncoding];
    }
  }
  else
  {
    char v64 = 1;
  }
LABEL_54:
  uint32_t v65 = v97;
  RB::RenderFrame::~RenderFrame((RB::RenderFrame *)v96);
LABEL_56:
  if (v93)
  {
    int64_t v66 = v92;
    uint64_t v67 = 40 * v93;
    do
    {
      uint64_t v68 = (os_unfair_lock_s *)(*(void *)v66 + 112);
      os_unfair_lock_lock(v68);
      uint64_t v69 = *(os_unfair_lock_s **)v66;
      *(unsigned char *)(*(void *)v66 + 172) = 0;
      if (v65) {
        v69[42]._os_unfair_lock_opaque = v65;
      }
      os_unfair_lock_unlock(v68);
      v66 += 40;
      v67 -= 40;
    }
    while (v67);
  }
  if (v64) {
    operator new();
  }
  return RB::vector<RB::SharedSurfaceGroup::render_updates_device(void)::SurfaceData,0ul,unsigned int>::~vector(&v92);
}

void sub_21412C75C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v3);
  os_unfair_lock_unlock(v2);
  RB::vector<RB::SharedSurfaceGroup::render_updates_device(void)::SurfaceData,0ul,unsigned int>::~vector((char **)(v1 + 528));
  _Unwind_Resume(a1);
}

RB::RenderFrame *RB::RenderFrame::RenderFrame(RB::RenderFrame *this, RB::Device *a2, RB::Drawable *a3, int a4)
{
  *(void *)this = a2;
  *((void *)this + 1) = a3;
  *((void *)this + 2) = 0;
  int v7 = (id *)((char *)this + 16);
  *((void *)this + 3) = 0;
  double v8 = RB::current_time_seconds(this);
  *((double *)this + 9) = v8;
  int v9 = *((_DWORD *)a2 + 47) + 1;
  *((_DWORD *)a2 + 47) = v9;
  *((_DWORD *)this + 20) = a4;
  *((_DWORD *)this + 21) = v9;
  *((void *)this + 11) = (uint64_t)(v8 * 60.0 + 0.5);
  size_t v10 = malloc_good_size(0x58uLL);
  int v11 = malloc_type_malloc(v10, 0x10E729FFuLL);
  if (!v11) {
    RB::precondition_failure((RB *)"memory allocation failed", v12);
  }
  BOOL v13 = (char *)this + 96;
  *int v11 = 0;
  v11[1] = 0;
  float32x2_t v11[2] = (v10 - 24) >> 3;
  *((void *)this + 12) = v11;
  size_t v14 = malloc_good_size(0x58uLL);
  uint64_t v15 = malloc_type_malloc(v14, 0x10E729FFuLL);
  if (!v15) {
    RB::precondition_failure((RB *)"memory allocation failed", v16);
  }
  uint64_t v17 = (char *)this + 104;
  *uint64_t v15 = 0;
  v15[1] = 0;
  void v15[2] = (v14 - 24) >> 3;
  *((void *)this + 13) = v15;
  size_t v18 = malloc_good_size(0x58uLL);
  uint64_t v19 = malloc_type_malloc(v18, 0x10E729FFuLL);
  if (!v19) {
    RB::precondition_failure((RB *)"memory allocation failed", v20);
  }
  *uint64_t v19 = 0;
  v19[1] = 0;
  v19[2] = (v18 - 24) >> 3;
  *((void *)this + 15) = 0;
  *((void *)this + 14) = v19;
  *((unsigned char *)this + 144) = 0;
  *((void *)this + 16) = 0;
  RB::UntypedTable::UntypedTable((uint64_t)this + 152, (unint64_t (*)(RB *, const void *))RB::RenderFrame::RenderFrame(RB::Device *,RB::Drawable *,unsigned int)::$_0::__invoke<RB::RenderFrame::RegionKey const*>, (BOOL (*)(RB *, RB *, const void *))RB::RenderFrame::RenderFrame(RB::Device *,RB::Drawable *,unsigned int)::$_1::__invoke<RB::RenderFrame::RegionKey const*,RB::RenderFrame::RegionKey const*>, 0, (void (*)(void *))RB::RenderFrame::RenderFrame(RB::Device *,RB::Drawable *,unsigned int)::$_2::__invoke<RB::RenderFrame::RegionEntry const*>, 0);
  *((_DWORD *)this + 58) = 0;
  *((void *)this + 34) = 0;
  *((void *)this + 35) = 0x400000000;
  *((void *)this + 36) = 0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((void *)this + 8) = 0;
  [(id)RB::Device::capture_scope(a2) beginScope];
  if (*((unsigned char *)a2 + 292))
  {
    char v21 = objc_opt_new();
    [v21 setErrorOptions:1];
    id v22 = (id)[RB::Device::command_queue((id *)a2) commandBufferWithDescriptor:v21];
    if (*v7 != v22)
    {

      *int v7 = v22;
    }

    id v23 = *v7;
  }
  else
  {
    id v23 = (id)[RB::Device::command_queue((id *)a2) commandBuffer];
    if (*v7 != v23)
    {

      id v23 = v23;
      *int v7 = v23;
    }
  }
  [v23 enqueue];
  uint64_t v24 = *(void **)v13;
  unint64_t v25 = *(void *)(*(void *)v13 + 8);
  if (v25 >= *(void *)(*(void *)v13 + 16)) {
    uint64_t v24 = (void *)RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::realloc_buffer((unint64_t *)this + 12, v24);
  }
  v24[v25 + 3] = 0;
  atomic_store(v25 + 1, v24 + 1);
  int v26 = *(void **)v17;
  unint64_t v27 = *(void *)(*(void *)v17 + 8);
  if (v27 >= *(void *)(*(void *)v17 + 16)) {
    int v26 = (void *)RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::realloc_buffer((unint64_t *)this + 13, v26);
  }
  v26[v27 + 3] = 0;
  atomic_store(v27 + 1, v26 + 1);
  return this;
}

void sub_21412CBAC(_Unwind_Exception *a1)
{
  RB::vector<std::unique_ptr<RB::RenderQueue,RB::RenderFrame::QueueDeleter>,4ul,unsigned int>::~vector(v1 + 240);
  RB::UntypedTable::~UntypedTable(v4);
  int v7 = *v5;
  if (*v5)
  {
    do
    {
      double v8 = (void *)*v7;
      operator delete(v7);
      int v7 = v8;
    }
    while (v8);
  }
  *uint64_t v5 = 0;
  RB::shared_vector<RB::Function const*>::~shared_vector((void **)(v1 + 112));
  RB::shared_vector<RB::RenderFrame::TextureRef>::~shared_vector(v3);
  RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::~shared_vector(v2);

  _Unwind_Resume(a1);
}

id RB::Device::command_queue(id *this)
{
  if (!this[8])
  {
    uint64_t v2 = (void *)[this[3] newCommandQueue];

    this[8] = v2;
    if (!v2) {
      RB::precondition_failure((RB *)"unable to create command queue", v3);
    }
    this[124] = (id)[v2 getGPUPriority];
    this[123] = (id)[v2 getBackgroundGPUPriority];
  }
  if (*((unsigned char *)this + 296))
  {
    unint64_t v4 = (__int16 *)((char *)this + 295);
  }
  else
  {
    unint64_t v4 = &RB::Device::default_gpu_priority;
    if (!HIBYTE(RB::Device::default_gpu_priority)) {
      goto LABEL_9;
    }
  }
  id v5 = (id)*(unsigned __int8 *)v4;
  if (this[124] != v5)
  {
    this[124] = v5;
    objc_msgSend(this[8], "setGPUPriority:");
  }
LABEL_9:
  if (*((unsigned char *)this + 294))
  {
    uint64_t v6 = (__int16 *)((char *)this + 293);
  }
  else
  {
    uint64_t v6 = &RB::Device::default_bg_gpu_priority;
    if (!HIBYTE(RB::Device::default_bg_gpu_priority)) {
      return this[8];
    }
  }
  id v7 = (id)*(unsigned __int8 *)v6;
  if (this[123] != v7)
  {
    this[123] = v7;
    objc_msgSend(this[8], "setBackgroundGPUPriority:");
  }
  return this[8];
}

void *RB::vector<RB::DisplayList::Interpolator::Contents::AnimationTableItem,0ul,unsigned int>::reserve_slow(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1);
  }
  uint64_t result = RB::details::realloc_vector<unsigned int,40ul>(*(void **)a1, (_DWORD *)(a1 + 12), v3);
  *(void *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,40ul>(void *a1, _DWORD *a2, unsigned int a3)
{
  unint64_t v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(40 * a3);
    unint64_t v6 = v5 / 0x28;
    if (*a2 != (v5 / 0x28))
    {
      id v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7) {
        RB::precondition_failure((RB *)"allocation failure", v8);
      }
      unint64_t v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

RB::RenderParams *RB::RenderParams::RenderParams(RB::RenderParams *this, RB::RenderFrame *a2, const RB::Surface *a3, float a4)
{
  uint64_t v8 = *((void *)a3 + 4);
  uint64_t v9 = *((void *)a3 + 3);
  unsigned __int8 v10 = *((unsigned char *)a3 + 44);
  char v11 = RB::color_space_to_srgb(v10);
  char v13 = RB::pixel_format_required_depth(*((RB **)a3 + 4), v12);
  unsigned int v15 = *((unsigned __int16 *)RB::pixel_format_traits(*((void *)a3 + 4), v14) + 2);
  *(void *)this = a2;
  *((void *)this + 1) = v8;
  *((void *)this + 2) = v9;
  *((float *)this + 6) = a4;
  *((unsigned char *)this + 28) = v10;
  *((unsigned char *)this + 29) = v11;
  *((unsigned char *)this + 30) = v13;
  int v16 = *((unsigned char *)this + 31) & 0xFE | (v15 >> 1) & 1;
  *((unsigned char *)this + 31) = *((unsigned char *)this + 31) & 0xFE | ((v15 & 2) != 0);
  LOBYTE(v15) = v16 & 0xF1 | (2 * (*(unsigned char *)(*(void *)a2 + 283) != 0));
  *((unsigned char *)this + 31) = v15;
  *((unsigned char *)this + 31) = v15 & 0xF7 | (8 * ((*((unsigned char *)a3 + 40) & 4) != 0));
  return this;
}

unint64_t RB::color_space_to_srgb(unsigned int a1)
{
  unint64_t v1 = 0x10001000100uLL >> (8 * a1);
  if (a1 >= 6) {
    LOBYTE(v1) = 0;
  }
  return v1 & 1;
}

char **RB::vector<RB::SharedSurfaceGroup::render_updates_device(void)::SurfaceData,0ul,unsigned int>::~vector(char **a1)
{
  uint64_t v2 = *a1;
  if (*((_DWORD *)a1 + 2))
  {
    unint64_t v3 = 0;
    do
    {
      unint64_t v4 = &v2[40 * v3];
      size_t v5 = (atomic_uint **)*((void *)v4 + 3);
      if (*((_DWORD *)v4 + 8))
      {
        unint64_t v6 = 0;
        do
        {
          id v7 = *v5;
          if (*v5 && atomic_fetch_add_explicit(v7 + 2, 0xFFFFFFFF, memory_order_release) == 1)
          {
            __dmb(9u);
            (*(void (**)(atomic_uint *))(*(void *)v7 + 8))(v7);
          }
          ++v6;
          v5 += 6;
        }
        while (v6 < *((unsigned int *)v4 + 8));
        size_t v5 = (atomic_uint **)*((void *)v4 + 3);
      }
      if (v5) {
        free(v5);
      }
      uint64_t v8 = &v2[40 * v3];
      char v11 = (void **)*((void *)v8 + 1);
      unsigned __int8 v10 = v8 + 8;
      uint64_t v9 = v11;
      if (*((_DWORD *)v10 + 2))
      {
        unint64_t v12 = 0;
        do
        {
          char v13 = *v9;
          v9 += 8;

          ++v12;
        }
        while (v12 < *((unsigned int *)v10 + 2));
        uint64_t v9 = *(void ***)v10;
      }
      if (v9) {
        free(v9);
      }
      MTLPixelFormat v14 = *(atomic_uint **)v4;
      if (*(void *)v4 && atomic_fetch_add_explicit(v14 + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        (*(void (**)(atomic_uint *))(*(void *)v14 + 8))(v14);
      }
      ++v3;
    }
    while (v3 < *((unsigned int *)a1 + 2));
    uint64_t v2 = *a1;
  }
  if (v2) {
    free(v2);
  }
  return a1;
}

uint64_t RB::Device::prune_caches(void)::$_2::__invoke(uint64_t *a1)
{
  uint64_t v2 = *a1;
  unsigned __int8 v4 = 0;
  v5[0] = *((unsigned int *)a1 + 2);
  v5[1] = &v4;
  uint64_t result = RB::UntypedTable::remove_if (v2 + 432, (BOOL (*)(const void *, const void *, void *))_ZZN2RB5TableIPKNS_20FormattedRenderStateEPNS_6Device19RenderPipelineEntryEE9remove_ifIZZNS4_12prune_cachesEvENK3__1clEvEUlT_PT0_E_EEvSA_ENUlPKvSF_PvE_8__invokeESF_SF_SG_, v5);
  *(unsigned char *)a1[2] = (*(unsigned __int8 *)a1[2] | v4) != 0;
  return result;
}

uint64_t RB::Device::prune_caches(dispatch_queue_t *this)
{
  uint64_t v59 = *MEMORY[0x263EF8340];
  uint64_t v2 = *((unsigned int *)this + 48);
  unsigned __int8 v55 = 0;
  uint64_t v3 = (uint64_t)(RB::current_time_seconds((RB *)this) * 60.0 + 0.5);
  uint64_t v4 = (v3 - 30);
  dispatch_queue_t v5 = this[45];
  if ((unint64_t)this[46] <= 0x4000000) {
    unsigned int v6 = v3 - 600;
  }
  else {
    unsigned int v6 = v3 - 30;
  }
  for (i = (char *)(this + 43); v5; dispatch_queue_t v5 = this[45])
  {
    uint64_t v8 = (uint64_t *)this[44];
    uint64_t v9 = v8[2];
    if (*(_DWORD *)(v9 + 36) > v6) {
      break;
    }
    this[46] = (dispatch_queue_t)((char *)this[46] - *(void *)(v9 + 48));
    uint64_t v10 = *v8;
    *(void *)(v10 + 8) = v8[1];
    *(void *)v8[1] = v10;
    this[45] = (dispatch_queue_t)((char *)v5 - 1);
    std::__list_imp<RB::refcounted_ptr<RB::Texture>>::__delete_node[abi:nn180100]<>(this + 344, v8);
  }
  dispatch_queue_t v11 = this[44];
  if (v11 != (dispatch_queue_t)i)
  {
    do
    {
      Class isa = v11[2].isa;
      if (*((_DWORD *)isa + 8) - (int)v2 > 0) {
        break;
      }
      RB::Resource::set_volatile((id *)isa, 1);
      dispatch_queue_t v11 = (dispatch_queue_t)v11[1].isa;
    }
    while (v11 != (dispatch_queue_t)i);
    dispatch_queue_t v5 = this[45];
  }
  if (v5) {
    unsigned __int8 v55 = 1;
  }
  if ((unint64_t)this[53] <= 0x8000000) {
    unsigned int v13 = v3 - 600;
  }
  else {
    unsigned int v13 = v3 - 30;
  }
  MTLPixelFormat v14 = (char *)(this + 47);
  while (1)
  {
    dispatch_queue_t v15 = this[49];
    if (!v15) {
      break;
    }
    int v16 = (uint64_t *)this[48];
    uint64_t v17 = v16[2];
    if (*(_DWORD *)(v17 + 36) > v13) {
      break;
    }
    this[53] = (dispatch_queue_t)((char *)this[53] - *(unsigned int *)(v17 + 72));
    uint64_t v18 = *v16;
    *(void *)(v18 + 8) = v16[1];
    *(void *)v16[1] = v18;
    this[49] = (dispatch_queue_t)((char *)v15 - 1);
    std::__list_imp<RB::refcounted_ptr<RB::Texture>>::__delete_node[abi:nn180100]<>(this + 376, v16);
  }
  dispatch_queue_t v19 = this[48];
  if (v19 != (dispatch_queue_t)v14)
  {
    do
    {
      Class v20 = v19[2].isa;
      if (*((_DWORD *)v20 + 8) - (int)v2 > 0) {
        break;
      }
      if ((*((unsigned char *)v20 + 77) & 2) != 0) {
        Class v20 = (Class)*((void *)v20 + 3);
      }
      RB::Resource::set_volatile((id *)v20, 1);
      dispatch_queue_t v19 = (dispatch_queue_t)v19[1].isa;
    }
    while (v19 != (dispatch_queue_t)v14);
    dispatch_queue_t v15 = this[49];
  }
  if (v15) {
    unsigned __int8 v55 = 1;
  }
  if (this[52])
  {
    context = (RB::Device *)&context;
    p_context = &context;
    long long v54 = 0;
    char v21 = (RB::Device *)this[51];
    if (v21 == (RB::Device *)(this + 50)) {
      goto LABEL_42;
    }
    do
    {
      id v23 = (RB::Device *)*((void *)v21 + 1);
      id v22 = (_DWORD *)*((void *)v21 + 2);
      if (v22) {
        ++v22[2];
      }
      if (v22[9] <= v4)
      {
        uint64_t v24 = p_context;
        if (p_context != (RB::Device **)v21 && v23 != (RB::Device *)p_context)
        {
          uint64_t v26 = *(void *)v21;
          *(void *)(v26 + 8) = v23;
          **((void **)v21 + 1) = v26;
          unint64_t v27 = *v24;
          *((void *)v27 + 1) = v21;
          *(void *)char v21 = v27;
          *uint64_t v24 = v21;
          *((void *)v21 + 1) = v24;
          this[52] = (dispatch_queue_t)((char *)this[52] - 1);
          ++v54;
        }
      }
      int v28 = v22[2] - 1;
      void v22[2] = v28;
      if (!v28) {
        (*(void (**)(_DWORD *))(*(void *)v22 + 8))(v22);
      }
      char v21 = v23;
    }
    while (v23 != (RB::Device *)(this + 50));
    if (this[52]) {
LABEL_42:
    }
      unsigned __int8 v55 = 1;
    std::__list_imp<RB::refcounted_ptr<RB::Texture>>::clear((uint64_t *)&context);
  }
  context = (RB::Device *)(v2 | (v4 << 32));
  p_context = (RB::Device **)(((v3 - 600) | (unint64_t)(v3 << 32)) - 0x200000000);
  RB::UntypedTable::remove_if ((uint64_t)(this + 100), (BOOL (*)(const void *, const void *, void *))RB::Table<unsigned long,RB::TextureCache *>::remove_if<RB::Device::prune_caches(void)::$_0>(RB::Device::prune_caches(void)::$_0)::{lambda(void const*,void const*,void *)#1}::__invoke, &context);
  if (this[107]) {
    unsigned __int8 v55 = 1;
  }
  context = (RB::Device *)this;
  LODWORD(p_context) = v3 - 600;
  long long v54 = &v55;
  dispatch_sync_f(this[5], &context, (dispatch_function_t)RB::Device::prune_caches(void)::$_2::__invoke);
  LODWORD(v49) = v3 - 600;
  RB::UntypedTable::remove_if ((uint64_t)(this + 110), (BOOL (*)(const void *, const void *, void *))RB::Table<RB::CustomShader::Library *,RB::FunctionLibrary *>::remove_if<RB::Device::prune_caches(void)::$_3>(RB::Device::prune_caches(void)::$_3)::{lambda(void const*,void const*,void *)#1}::__invoke, &v49);
  unint64_t v29 = (os_unfair_lock_s *)this[122];
  if (v29 && RB::SharedSurfaceGroup::prune_caches(v29, v3)) {
    unsigned __int8 v55 = 1;
  }
  uint64_t v30 = (RB::GlyphPathCache *)this[120];
  if (v30)
  {
    uint64_t v30 = (RB::GlyphPathCache *)RB::GlyphPathCache::prune(v30, v3);
    if (v30) {
      unsigned __int8 v55 = 1;
    }
  }
  if (*((unsigned char *)this + 553))
  {
    int v49 = 0;
    uint64_t v50 = 0;
    unint64_t v51 = 0;
    dispatch_queue_t v31 = this[66];
    if (v31)
    {
      uint64_t v32 = 0;
      do
      {
        v48.__r_.__value_.__l.__data_ = (std::string::pointer)v31[2].isa;
        LODWORD(v48.__r_.__value_.__r.__words[1]) = v31[3].isa;
        if (v51 < v32 + 1)
        {
          RB::vector<RB::FormattedRenderState,0ul,unsigned long>::reserve_slow((uint64_t)&v49, v32 + 1);
          uint64_t v32 = v50;
        }
        uint64_t v33 = (char *)v49 + 12 * v32;
        *(void *)uint64_t v33 = v48.__r_.__value_.__r.__words[0];
        *((_DWORD *)v33 + 2) = v48.__r_.__value_.__r.__words[1];
        uint64_t v32 = ++v50;
        dispatch_queue_t v31 = (dispatch_queue_t)v31->isa;
      }
      while (v31);
      dispatch_queue_t v31 = (dispatch_queue_t)v49;
      int32x2_t v34 = (char *)v49 + 12 * v32;
      if (v32 >= 129)
      {
        int32x2_t v35 = std::get_temporary_buffer[abi:nn180100]<RB::FormattedRenderState>(v32);
        uint64_t v37 = v36;
LABEL_62:
        std::__stable_sort<std::_ClassicAlgPolicy,RB::Device::prune_caches(void)::$_4 &,RB::FormattedRenderState *>((uint64_t)v31, v34, v32, (uint64_t)v35, v37);
        if (v35) {
          operator delete(v35);
        }
        memset(&v48, 0, sizeof(v48));
        std::string::append(&v48, "RenderBox pipelines:", 0x14uLL);
        if (v50)
        {
          long long v38 = (char *)v49;
          uint64_t v39 = (char *)v49 + 12 * v50;
          do
          {
            uint64_t v40 = *(void *)v38;
            int v41 = *((_DWORD *)v38 + 2);
            std::string::push_back(&v48, 32);
            uint64_t v56 = v40;
            int v57 = v41;
            RB::FormattedRenderState::ID::formatted((uint64_t)&v56, (uint64_t)__s);
            size_t v42 = strlen(__s);
            std::string::append(&v48, __s, v42);
            v38 += 12;
          }
          while (v38 != v39);
        }
        std::string::push_back(&v48, 10);
        if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v43 = &v48;
        }
        else {
          uint64_t v43 = (std::string *)v48.__r_.__value_.__r.__words[0];
        }
        if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          size_t size = HIBYTE(v48.__r_.__value_.__r.__words[2]);
        }
        else {
          size_t size = v48.__r_.__value_.__l.__size_;
        }
        uint64_t v45 = (FILE **)MEMORY[0x263EF8358];
        fwrite(v43, 1uLL, size, (FILE *)*MEMORY[0x263EF8358]);
        fflush(*v45);
        *((unsigned char *)this + 553) = 0;
        if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v48.__r_.__value_.__l.__data_);
        }
        uint64_t v30 = (RB::GlyphPathCache *)v49;
        if (v49) {
          free(v49);
        }
        goto LABEL_77;
      }
    }
    else
    {
      int32x2_t v34 = 0;
      uint64_t v32 = 0;
    }
    int32x2_t v35 = 0;
    uint64_t v37 = 0;
    goto LABEL_62;
  }
LABEL_77:
  uint64_t v46 = (os_unfair_lock_s *)RB::Device::RenderPipelineEntry::Queue::shared(v30);
  os_unfair_lock_lock(v46);
  RB::Device::RenderPipelineEntry::Queue::load_next_locked((RB::Device::RenderPipelineEntry::Queue *)v46);
  os_unfair_lock_unlock(v46);
  return v55;
}

void sub_21412D6D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16)
{
  if (a16) {
    free(a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::UntypedTable::remove_if (uint64_t this, BOOL (*a2)(const void *, const void *, void *), void *a3)
{
  if (*(void *)(this + 56))
  {
    dispatch_queue_t v5 = (void *)this;
    unint64_t v6 = 0;
    int v7 = *(_DWORD *)(this + 72);
    do
    {
      uint64_t v8 = (void **)(v5[6] + 8 * v6);
      while (1)
      {
        uint64_t v9 = *v8;
        if (!*v8) {
          break;
        }
        this = ((uint64_t (*)(void, void, void *))a2)(v9[1], v9[2], a3);
        if (this)
        {
          *uint64_t v8 = (void *)*v9;
          uint64_t v10 = (uint64_t (*)(void))v5[2];
          if (v10) {
            this = v10(v9[1]);
          }
          dispatch_queue_t v11 = (uint64_t (*)(void))v5[3];
          if (v11) {
            this = v11(v9[2]);
          }
          *uint64_t v9 = v5[5];
          void v5[5] = v9;
          --v5[7];
        }
        else
        {
          uint64_t v8 = (void **)v9;
        }
      }
      ++v6;
    }
    while (!(v6 >> v7));
  }
  return this;
}

BOOL _ZZN2RB5TableIPKNS_20FormattedRenderStateEPNS_6Device19RenderPipelineEntryEE9remove_ifIZZNS4_12prune_cachesEvENK3__1clEvEUlT_PT0_E_EEvSA_ENUlPKvSF_PvE_8__invokeESF_SF_SG_(RB *a1, uint64_t *a2, int *a3)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  if (a2[2] || *((unsigned char *)a2 + 49)) {
    return 0;
  }
  int v7 = *a3;
  if (*((unsigned char *)a2 + 48)) {
    int v8 = -60;
  }
  else {
    int v8 = -1200;
  }
  unsigned int v9 = v8 + v7;
  unsigned int v10 = *((_DWORD *)a2 + 10);
  BOOL v4 = v10 <= v8 + v7;
  if (v10 <= v8 + v7 && RB::verbose_mode(a1))
  {
    dispatch_queue_t v11 = RB::RenderState::name((RB::RenderState *)a2);
    int v12 = *((_DWORD *)a2 + 2);
    uint64_t v16 = *a2;
    int v17 = v12;
    RB::FormattedRenderState::ID::formatted((uint64_t)&v16, (uint64_t)v18);
    printf("deleted render pipeline %s-%s\n", v11, v18);
    fflush((FILE *)*MEMORY[0x263EF8358]);
  }
  unsigned int v13 = (char *)*((void *)a3 + 1);
  if (*v13) {
    BOOL v14 = 1;
  }
  else {
    BOOL v14 = v10 > v9;
  }
  char v15 = v14;
  *unsigned int v13 = v15;
  return v4;
}

uint64_t RB::SharedSurfaceGroup::prune_caches(os_unfair_lock_s *this, int a2)
{
  BOOL v4 = this + 4;
  os_unfair_lock_lock(this + 4);
  RB::SharedSurfaceGroup::collect_removed_locked((RB::SharedSurfaceGroup *)this);
  uint64_t v5 = RB::SharedSurfaceGroup::prune_caches_locked((uint64_t)this, a2);
  os_unfair_lock_unlock(v4);
  return v5;
}

void sub_21412D960(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::SharedSurfaceGroup::prune_caches_locked(uint64_t this, int a2)
{
  uint64_t v2 = this;
  uint64_t v3 = (char *)(this + 24);
  BOOL v4 = *(uint64_t **)(this + 32);
  if (v4 == (uint64_t *)(this + 24))
  {
    char v6 = 0;
  }
  else
  {
    char v6 = 0;
    uint64_t v7 = 0;
    int v8 = 0;
    do
    {
      uint64_t v9 = v4[2];
      if (*(_DWORD *)(v9 + 104))
      {
        this = RB::BinAllocator::free_space(v9 + 32);
        int v10 = this;
        if (!v7 || (int)this > v8)
        {
          this = RB::SharedSurface::is_idle((os_unfair_lock_s *)v4[2], a2);
          if (this)
          {
            uint64_t v7 = v4[2];
            int v8 = v10;
          }
          else
          {
            char v6 = 1;
          }
        }
        BOOL v4 = (uint64_t *)v4[1];
      }
      else
      {
        uint64_t v11 = *v4;
        int v12 = (uint64_t *)v4[1];
        *(void *)(v11 + 8) = v12;
        *(void *)v4[1] = v11;
        --*(void *)(v2 + 40);
        std::__list_imp<RB::refcounted_ptr<RB::SharedSurface>>::__delete_node[abi:nn180100]<>((int)v3, v4);
        *(unsigned char *)(v2 + 60) = 1;
        BOOL v4 = v12;
      }
    }
    while (v4 != (uint64_t *)v3);
    if (v7)
    {
      this = +[RBDevice isRunningInBackground];
      if ((this & 1) == 0)
      {
        int v13 = vmul_lane_s32(*(int32x2_t *)(v7 + 32), *(int32x2_t *)(v7 + 32), 1).u32[0];
        uint64_t v14 = *(void *)(v2 + 32);
        if ((char *)v14 == v3)
        {
          int v15 = 0;
        }
        else
        {
          int v15 = 0;
          do
          {
            this = *(void *)(v14 + 16);
            if (this != v7)
            {
              uint64_t v16 = *(void *)(this + 24);
              uint64_t v17 = *(void *)(v7 + 24);
              if (*(void *)(v16 + 32) == *(void *)(v17 + 32)
                && *(unsigned __int8 *)(v16 + 44) == *(unsigned __int8 *)(v17 + 44)
                && *(_DWORD *)(v16 + 40) == *(_DWORD *)(v17 + 40)
                && *(float *)(this + 64) == *(float *)(v7 + 64))
              {
                unsigned __int32 v18 = vmul_lane_s32(*(int32x2_t *)(this + 32), *(int32x2_t *)(this + 32), 1).u32[0];
                this = RB::BinAllocator::free_space(this + 32);
                int v15 = v15 - this + v18;
              }
            }
            uint64_t v14 = *(void *)(v14 + 8);
          }
          while ((char *)v14 != v3);
        }
        if (v13 - (v13 >> 2) <= v15) {
          int v19 = v15;
        }
        else {
          int v19 = v13 - (v13 >> 2);
        }
        if (v8 > v19) {
          RB::SharedSurfaceGroup::relocate_surface((RB::SharedSurfaceGroup *)v2, (int32x2_t *)v7, v8 > v13 - (v13 >> 3));
        }
      }
    }
  }
  if (RB::verbose_mode((RB *)this) && *(void *)(v2 + 40) && *(unsigned char *)(v2 + 60))
  {
    char v38 = v6;
    Class v20 = (RB *)puts("\n** Shared surfaces **\n");
    for (uint64_t i = *(void *)(v2 + 32); (char *)i != v3; uint64_t i = *(void *)(i + 8))
    {
      id v22 = *(int32x2_t **)(i + 16);
      unsigned __int32 v23 = vmul_lane_s32(v22[4], v22[4], 1).u32[0];
      int v24 = v23 - RB::BinAllocator::free_space((uint64_t)&v22[4]);
      unint64_t v25 = *(int32x2_t **)(i + 16);
      int v26 = vmul_lane_s32(v25[4], v25[4], 1).u32[0];
      IOSurfaceID ID = IOSurfaceGetID(*(IOSurfaceRef *)(*(void *)&v25[3] + 48));
      uint64_t v28 = *(void *)(i + 16);
      int v29 = HIDWORD(*(void *)(v28 + 32));
      int v30 = *(void *)(v28 + 32);
      uint64_t v32 = RB::pixel_format_name(*(RB **)(*(void *)(v28 + 24) + 32), v31);
      Class v20 = (RB *)printf("  %08x  %4d x %4d  %-16s -- %d%% used, %d/%d (%d+%d).\n", ID, v30, v29, v32, (int)(float)((float)((float)((float)v24 * 100.0) / (float)v26) + 0.5), v24, v26, *(_DWORD *)(*(void *)(i + 16) + 80), *(_DWORD *)(*(void *)(i + 16) + 108) + *(_DWORD *)(*(void *)(i + 16) + 96));
    }
    int v33 = RB::verbose_mode(v20);
    int32x2_t v34 = (FILE **)MEMORY[0x263EF8358];
    char v6 = v38;
    if (v33 > 1)
    {
      memset(&v39, 0, sizeof(v39));
      std::string::append(&v39, "\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n", 0x28uLL);
      std::string::append(&v39, "<display-list xmlns=\"http://www.apple.com/RenderBox/1.0\">\n", 0x3AuLL);
      std::string::append(&v39, "  <transform scale=\"0.5\"/>\n", 0x1BuLL);
      for (uint64_t j = *(void *)(v2 + 32); (char *)j != v3; uint64_t j = *(void *)(j + 8))
        RB::BinAllocator::print(*(void *)(j + 16) + 32, &v39);
      std::string::append(&v39, "</display-list>\n", 0x10uLL);
      uint64_t v36 = (v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &v39
          : (std::string *)v39.__r_.__value_.__r.__words[0];
      fputs((const char *)v36, *v34);
      if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v39.__r_.__value_.__l.__data_);
      }
    }
    fflush(*v34);
    *(unsigned char *)(v2 + 60) = 0;
  }
  return v6 & 1;
}

void sub_21412DD10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::BinAllocator::free_space(uint64_t this)
{
  uint64_t v1 = *(unsigned int *)(this + 24);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = this;
  LODWORD(this) = 0;
  uint64_t v3 = *(void *)(v2 + 16);
  uint64_t v4 = 32 * v1;
  uint64_t v5 = (__int16 *)(v3 + 6);
  do
  {
    this = (this + *(v5 - 1) * *v5);
    v5 += 16;
    v4 -= 32;
  }
  while (v4);
  return this;
}

BOOL RB::SharedSurface::is_idle(os_unfair_lock_s *this, int a2)
{
  uint64_t v4 = this + 28;
  os_unfair_lock_lock(this + 28);
  BOOL v5 = !LOBYTE(this[43]._os_unfair_lock_opaque)
    && !this[32]._os_unfair_lock_opaque
    && !this[36]._os_unfair_lock_opaque
    && !this[40]._os_unfair_lock_opaque
    && !this[24]._os_unfair_lock_opaque
    && !this[27]._os_unfair_lock_opaque
    && this[42]._os_unfair_lock_opaque < a2 - 12;
  os_unfair_lock_unlock(v4);
  return v5;
}

void RB::SharedSurfaceGroup::collect_removed_locked(RB::SharedSurfaceGroup *this)
{
  int v10 = 0;
  uint64_t v11 = 0;
  uint64_t v1 = (char *)this + 24;
  uint64_t v2 = (char *)*((void *)this + 4);
  if (v2 != (char *)this + 24)
  {
    do
    {
      uint64_t v3 = *((void *)v2 + 2);
      int v4 = *(_DWORD *)(v3 + 96);
      if (v4)
      {
        *(_DWORD *)(v3 + 108) += v4;
        unsigned int v5 = v11;
        if (HIDWORD(v11) < (v11 + 1))
        {
          RB::vector<std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>,0ul,unsigned int>::reserve_slow((uint64_t)&v10, v11 + 1);
          unsigned int v5 = v11;
        }
        char v6 = (char *)v10 + 24 * v5;
        v6[1] = 0;
        void v6[2] = 0;
        void *v6 = v3;
        LODWORD(v6) = v11;
        LODWORD(v11) = v11 + 1;
        uint64_t v7 = *((void *)v2 + 2);
        int v8 = (char *)v10 + 24 * v6;
        uint64_t v9 = *(void *)(v7 + 88);
        *(void *)(v7 + 88) = *((void *)v8 + 1);
        *((void *)v8 + 1) = v9;
        LODWORD(v9) = *(_DWORD *)(v7 + 96);
        *(_DWORD *)(v7 + 96) = *((_DWORD *)v8 + 4);
        *((_DWORD *)v8 + 4) = v9;
        LODWORD(v9) = *(_DWORD *)(v7 + 100);
        *(_DWORD *)(v7 + 100) = *((_DWORD *)v8 + 5);
        *((_DWORD *)v8 + 5) = v9;
      }
      uint64_t v2 = (char *)*((void *)v2 + 1);
    }
    while (v2 != v1);
    if (v11) {
      operator new();
    }
  }
  if (v10) {
    free(v10);
  }
}

void sub_21412E010(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char *a11)
{
}

void *RB::vector<std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>,0ul,unsigned int>::reserve_slow(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1);
  }
  uint64_t result = RB::details::realloc_vector<unsigned int,24ul>(*(void **)a1, (_DWORD *)(a1 + 12), v3);
  *(void *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,24ul>(void *a1, _DWORD *a2, unsigned int a3)
{
  int v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(24 * a3);
    unint64_t v6 = v5 / 0x18;
    if (*a2 != (v5 / 0x18))
    {
      uint64_t v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7) {
        RB::precondition_failure((RB *)"allocation failure", v8);
      }
      int v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

uint64_t RB::anonymous namespace'::shared_surface_queue(RB::_anonymous_namespace_ *this)
{
  uint64_t v1 = &color_symbols(void)::flag;
  {
    uint64_t v1 = &color_symbols(void)::flag;
    if (v3)
    {
      int v4 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, 0);
      uint64_t v1 = &color_symbols(void)::flag;
    }
  }
  return *((void *)v1 + 34);
}

void RB::Device::install_render_pipeline_state(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v11 = a2;
  int v12 = a3;
  size_t v5 = RB::UntypedTable::lookup((RB::UntypedTable *)(a1 + 432), &v11, 0);
  if (v5)
  {
    unint64_t v6 = v5;
    if (v5[2] == a4)
    {
      uint64_t v7 = v5[3];
      _OWORD v5[3] = *(void *)(a4 + 64);
      *(void *)(a4 + 64) = v7;
      *((_DWORD *)v5 + 10) = (uint64_t)(RB::current_time_seconds((RB *)v5) * 60.0 + 0.5);
      uint64_t v9 = v6[2];
      void v6[2] = 0;
      if (v9) {
        RB::Device::RenderPipelineEntry::DeleteLoader::operator()((uint64_t)v8, v9);
      }
      int v10 = (os_unfair_lock_s *)RB::Device::RenderPipelineEntry::Queue::shared(v8);
      RB::Device::RenderPipelineEntry::Queue::retire_and_load_next(v10);
    }
  }
}

void RB::Device::RenderPipelineEntry::DeleteLoader::operator()(uint64_t a1, uint64_t a2)
{
  if (a2)
  {

    int v3 = *(atomic_uint **)(a2 + 8);
    if (v3 && atomic_fetch_add_explicit(v3 + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(atomic_uint *))(*(void *)v3 + 8))(v3);
    }
    JUMPOUT(0x21669AC10);
  }
}

void RB::Device::RenderPipelineEntry::Loader::start_loading(RB::Device::RenderPipelineEntry::Loader *this)
{
  v12[1] = *MEMORY[0x263EF8340];
  if (!*((void *)this + 6))
  {
    uint64_t v2 = (void *)MEMORY[0x21669B110]();
    int v3 = objc_opt_new();

    uint64_t v4 = *((void *)this + 2);
    *((void *)this + 6) = v3;
    if (RB::Device::make_render_pipeline_descriptor(v4, *((_DWORD *)this + 6), 0, 0, v3, 0, (id *)this + 7))
    {
      if (*((void *)this + 5))
      {
        v12[0] = *((void *)this + 5);
        objc_msgSend((id)objc_msgSend(*((id *)this + 6), "fragmentLinkedFunctions"), "setPrivateFunctions:", objc_msgSend(MEMORY[0x263EFF8C0], "arrayWithObjects:count:", v12, 1));
      }
      RB::Device::RenderPipelineEntry::Loader::load_fn(this, 0);
      *((double *)this + 9) = RB::current_time_seconds(v5);
      if (RB::verbose_mode(v6))
      {
        uint64_t v7 = RB::RenderState::name((RB::Device::RenderPipelineEntry::Loader *)((char *)this + 16));
        int v8 = *((_DWORD *)this + 6);
        uint64_t v9 = *((void *)this + 2);
        int v10 = v8;
        RB::FormattedRenderState::ID::formatted((uint64_t)&v9, (uint64_t)v11);
        printf("started building render pipeline %s-%s\n", v7, v11);
        fflush((FILE *)*MEMORY[0x263EF8358]);
      }
    }
    else
    {
      RB::Device::RenderPipelineEntry::Loader::finished(this);
    }
  }
}

void sub_21412E444(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double RB::current_time_seconds(RB *this)
{
  uint64_t v1 = (RB *)mach_absolute_time();
  return RB::time_seconds(v1);
}

void RB::Device::RenderPipelineEntry::Loader::load_fn(RB::Device::RenderPipelineEntry::Loader *this, Function *a2)
{
  while (1)
  {
    int v3 = (int)a2;
    uint64_t v4 = a2
    size_t v5 = *v4;
    if (*v4) {
      break;
    }
    LODWORD(a2) = 1;
    if (v3)
    {
      unint64_t v6 = *(void **)(*((void *)this + 1) + 24);
      uint64_t v7 = *((void *)this + 6);
      v12[0] = MEMORY[0x263EF8330];
      v12[1] = 3221225472;
      void v12[2] = ___ZN2RB6Device19RenderPipelineEntry6Loader13load_pipelineEv_block_invoke;
      v12[3] = &__block_descriptor_40_e46_v24__0___MTLRenderPipelineState__8__NSError_16l;
      v12[4] = this;
      [v6 newRenderPipelineStateWithDescriptor:v7 completionHandler:v12];
      return;
    }
  }
  int v8 = objc_opt_new();
  [v8 setName:v5];
  if (*((unsigned char *)v4 + 8)) {
    [v8 setConstantValues:*((void *)this + 7)];
  }
  uint64_t v9 = (void *)*((void *)this + 4);
  v10[0] = MEMORY[0x263EF8330];
  v10[1] = 3221225472;
  v10[2] = ___ZN2RB6Device19RenderPipelineEntry6Loader7load_fnENS2_8FunctionE_block_invoke;
  _OWORD v10[3] = &__block_descriptor_44_e35_v24__0___MTLFunction__8__NSError_16l;
  v10[4] = this;
  int v11 = v3;
  [v9 newFunctionWithDescriptor:v8 completionHandler:v10];
}

void sub_21412E5E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void RB::Device::RenderPipelineEntry::Queue::retire_and_load_next(os_unfair_lock_s *this)
{
  os_unfair_lock_lock(this);
  --this[1]._os_unfair_lock_opaque;
  RB::Device::RenderPipelineEntry::Queue::load_next_locked((RB::Device::RenderPipelineEntry::Queue *)this);
  os_unfair_lock_unlock(this);
}

void RB::Device::RenderPipelineEntry::Queue::load_next_locked(RB::Device::RenderPipelineEntry::Queue *this)
{
  for (uint64_t i = (uint64_t *)*((void *)this + 1); i; uint64_t i = (uint64_t *)*((void *)this + 1))
  {
    unsigned int v3 = *((_DWORD *)this + 1);
    if (v3 > 3) {
      break;
    }
    uint64_t v4 = *i;
    *((void *)this + 1) = *i;
    if (!v4) {
      *((void *)this + 2) = 0;
    }
    *((_DWORD *)this + 1) = v3 + 1;
    dispatch_async_f(*(dispatch_queue_t *)(i[1] + 40), i, (dispatch_function_t)RB::Device::RenderPipelineEntry::Queue::load_next_locked(void)::$_0::__invoke);
  }
}

void ___ZN2RB18SharedSurfaceGroup16schedule_updatesEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = (RB::SharedSurfaceGroup *)RB::Device::shared_surfaces(*(RB::Device **)(a1 + 32));
  *((void *)v1 + 6) = 0;
  RB::SharedSurfaceGroup::render_updates(v1);
}

uint64_t RBSymbolUpdateLayerColorName(void *a1)
{
  unsigned int v1 = *(_DWORD *)(*a1 + 848) + ~*((_DWORD *)a1 + 2);
  uint64_t v2 = *(void *)(*a1 + 840);
  if (!v2) {
    uint64_t v2 = *a1 + 8;
  }
  uint64_t v3 = a1[2];
  uint64_t v4 = *(void **)(v2 + 416 * v1 + 400);
  if (v4) {
    LODWORD(v3) = *(_DWORD *)(*v4 + 8 * a1[2]);
  }
  uint64_t v5 = v2 + 416 * v1;
  uint64_t v6 = v5 + 16;
  uint64_t v7 = *(void *)(v5 + 376);
  if (!v7) {
    uint64_t v7 = v6;
  }
  uint64_t v8 = *(void *)(v7 + 120 * v3);
  if ((*(_DWORD *)(v8 + 84) & 0xF00) == 0x900) {
    return *(void *)(v8 + 8);
  }
  else {
    return 0;
  }
}

void ___ZN2RB11RenderFrameD2Ev_block_invoke(uint64_t a1, void *a2)
{
  [a2 GPUEndTime];
  double v5 = v4;
  [a2 GPUStartTime];
  uint64_t v7 = *(RB::Drawable **)(a1 + 32);
  if (v7) {
    RB::Drawable::end_frame(v7, v5 - v6);
  }
  RB::Device::retire_frame_id(*(os_unfair_lock_s **)(a1 + 40), *(_DWORD *)(a1 + 56));
  if ([a2 status] == 5)
  {
    uint64_t v8 = *(atomic_uchar **)(a1 + 40);
    uint64_t v9 = (void *)[a2 error];
    int v10 = *(void **)(a1 + 48);
    RB::Device::command_buffer_error(v8, v9, v10);
  }
}

void RB::Drawable::end_frame(RB::Drawable *this, double a2)
{
  *((double *)this + 3) = *((double *)this + 3) + a2;
  double v4 = (os_unfair_lock_s *)((char *)this + 32);
  os_unfair_lock_lock((os_unfair_lock_t)this + 8);
  uint64_t v5 = *((void *)this + 5);
  uint64_t v6 = *((void *)this + 8);
  if ((v5 & 2) != 0)
  {
    if (v6)
    {
      *((double *)this + 10) = *((double *)this + 10) + a2;
      double v7 = *((double *)this + 18);
      if (v7 > a2) {
        double v7 = a2;
      }
      *((double *)this + 18) = v7;
      double v8 = *((double *)this + 26);
      if (v8 < a2) {
        double v8 = a2;
      }
      *((double *)this + 26) = v8;
      *((double *)this + 34) = a2 + (*((double *)this + 34) - a2) * *((double *)this + 6);
    }
    else
    {
      *((double *)this + 10) = a2;
      *((double *)this + 18) = a2;
      *((double *)this + 26) = a2;
      *((double *)this + 34) = a2;
    }
  }
  *((void *)this + 8) = v6 + 1;
  id v9 = *((id *)this + 41);

  os_unfair_lock_unlock(v4);
  int v10 = *((void *)this + 2);
  if (v10) {
    dispatch_semaphore_signal(v10);
  }
  if (v5 && v9) {
    [v9 _RBDrawableStatisticsDidChange];
  }
}

void sub_21412E9A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void RB::Device::retire_frame_id(os_unfair_lock_s *this, uint32_t os_unfair_lock_opaque)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  int v33 = 0;
  unint64_t v34 = 0;
  unint64_t v35 = 2;
  double v4 = this + 46;
  os_unfair_lock_lock(this + 46);
  if ((int)(os_unfair_lock_opaque - this[48]._os_unfair_lock_opaque) < 1) {
    os_unfair_lock_opaque = this[48]._os_unfair_lock_opaque;
  }
  else {
    this[48]._os_unfair_lock_opaque = os_unfair_lock_opaque;
  }
  unint64_t v5 = *(void *)&this[64]._os_unfair_lock_opaque;
  if (v5)
  {
    unint64_t v6 = 0;
    do
    {
      double v7 = *(os_unfair_lock_s **)&this[62]._os_unfair_lock_opaque;
      if (v7) {
        double v8 = *(os_unfair_lock_s **)&this[62]._os_unfair_lock_opaque;
      }
      else {
        double v8 = this + 50;
      }
      id v9 = (char *)&v8[6 * v6];
      int v10 = *(_DWORD *)v9;
      if ((int)(*(_DWORD *)v9 - os_unfair_lock_opaque) < 1)
      {
        unint64_t v11 = v34;
        unint64_t v12 = v34 + 1;
        if (v35 < v34 + 1)
        {
          RB::vector<RB::Device::FrameContinuation,2ul,unsigned long>::reserve_slow(v32, v12);
          unint64_t v11 = v34;
          int v10 = *(_DWORD *)v9;
          double v7 = *(os_unfair_lock_s **)&this[62]._os_unfair_lock_opaque;
          unint64_t v5 = *(void *)&this[64]._os_unfair_lock_opaque;
          unint64_t v12 = v34 + 1;
        }
        int v13 = v33;
        if (!v33) {
          int v13 = v32;
        }
        uint64_t v14 = &v13[24 * v11];
        *(_DWORD *)uint64_t v14 = v10;
        int v15 = (char *)&v8[6 * v6];
        *(_OWORD *)(v14 + 8) = *(_OWORD *)(v15 + 8);
        *((void *)v15 + 1) = 0;
        *((void *)v15 + 2) = 0;
        unint64_t v34 = v12;
        if (!v7) {
          double v7 = this + 50;
        }
        uint64_t v16 = (char *)&v7[6 * v5];
        int v17 = *(_DWORD *)v9;
        *(_DWORD *)id v9 = *((_DWORD *)v16 - 6);
        *((_DWORD *)v16 - 6) = v17;
        uint64_t v18 = *((void *)v15 + 1);
        *((void *)v15 + 1) = *((void *)v16 - 2);
        *((void *)v16 - 2) = v18;
        uint64_t v19 = *((void *)v15 + 2);
        *((void *)v15 + 2) = *((void *)v16 - 1);
        *((void *)v16 - 1) = v19;
        Class v20 = *(os_unfair_lock_s **)&this[62]._os_unfair_lock_opaque;
        uint64_t v21 = *(void *)&this[64]._os_unfair_lock_opaque - 1;
        *(void *)&this[64]._os_unfair_lock_opaque = v21;
        if (!v20) {
          Class v20 = this + 50;
        }
        id v22 = (char *)&v20[6 * v21];

        unint64_t v5 = *(void *)&this[64]._os_unfair_lock_opaque;
      }
      else
      {
        ++v6;
      }
    }
    while (v6 < v5);
  }
  os_unfair_lock_unlock(v4);
  unsigned __int32 v23 = v33;
  int v24 = v32;
  if (v33) {
    int v24 = v33;
  }
  if (v34)
  {
    unint64_t v25 = v24 + 16;
    uint64_t v26 = 24 * v34;
    do
    {
      unint64_t v27 = *(v25 - 1);
      uint64_t v28 = (void (**)(void))*v25;
      if (v27) {
        dispatch_async(v27, v28);
      }
      else {
        v28[2](*v25);
      }
      v25 += 3;
      v26 -= 24;
    }
    while (v26);
    unsigned __int32 v23 = v33;
    int v29 = v32;
    if (v33) {
      int v29 = v33;
    }
    if (v34)
    {
      unint64_t v30 = 0;
      MTLPixelFormat v31 = (id *)(v29 + 16);
      do
      {

        ++v30;
        v31 += 3;
      }
      while (v30 < v34);
      unsigned __int32 v23 = v33;
    }
  }
  if (v23) {
    free(v23);
  }
}

void sub_21412EC20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  os_unfair_lock_unlock(v9);
  RB::vector<RB::Device::FrameContinuation,2ul,unsigned long>::~vector(&a9);
  _Unwind_Resume(a1);
}

void RB::SharedSurfaceGroup::render_updates(RB::SharedSurfaceGroup *this)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 16);
  os_unfair_lock_lock((os_unfair_lock_t)this + 4);
  for (uint64_t i = (void *)*((void *)this + 4); i != (void *)((char *)this + 24); uint64_t i = (void *)i[1])
  {
    double v4 = (os_unfair_lock_s *)(i[2] + 112);
    os_unfair_lock_lock(v4);
    uint64_t v5 = i[2];
    if (*(unsigned char *)(v5 + 172) || *(_DWORD *)(v5 + 128))
    {
      os_unfair_lock_unlock(v4);
LABEL_11:
      os_unfair_lock_unlock(v2);
      RB::Drawable::begin_frame(*((RB::Drawable **)this + 1));
      double v7 = *(NSObject **)(*(void *)this + 32);
      dispatch_sync_f(v7, this, (dispatch_function_t)RB::SharedSurfaceGroup::render_updates(void)::$_0::__invoke);
      return;
    }
    int v6 = *(_DWORD *)(v5 + 144);
    os_unfair_lock_unlock(v4);
    if (v6) {
      goto LABEL_11;
    }
  }
  os_unfair_lock_unlock(v2);
}

NSObject *RB::Drawable::begin_frame(RB::Drawable *this)
{
  uint64_t result = *((void *)this + 2);
  if (result) {
    return dispatch_semaphore_wait(result, 0xFFFFFFFFFFFFFFFFLL);
  }
  return result;
}

atomic_uint *__destroy_helper_block_e8_32c40_ZTSN2RB14refcounted_ptrINS_8DrawableEEE40c38_ZTSN2RB14refcounted_ptrINS_6DeviceEEE48c59_ZTSN2RB8objc_ptrIPU22objcproto11RBEncodable11objc_objectEE(uint64_t a1)
{
  uint64_t v2 = *(atomic_uint **)(a1 + 40);
  if (v2 && atomic_fetch_add_explicit(v2 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
  }
  uint64_t result = *(atomic_uint **)(a1 + 32);
  if (result && atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    double v4 = *(uint64_t (**)(void))(*(void *)result + 8);
    return (atomic_uint *)v4();
  }
  return result;
}

atomic_uint *__destroy_helper_block_e8_32c38_ZTSN2RB14refcounted_ptrINS_6DeviceEEE(uint64_t a1)
{
  uint64_t result = *(atomic_uint **)(a1 + 32);
  if (result)
  {
    if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
    }
  }
  return result;
}

void RB::SharedSurfaceGroup::collect_removed_locked(void)::$_0::operator() const(void *)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
}

uint64_t std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(uint64_t result, float *a2, uint64_t a3)
{
  if ((float *)result != a2)
  {
    uint64_t v4 = result;
    uint64_t v5 = result + 8;
    if ((float *)(result + 8) != a2)
    {
      double v7 = (float *)(result + 12);
      do
      {
        double v8 = (float *)v5;
        uint64_t result = std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a3, v5, v4);
        if (result)
        {
          float v9 = *v8;
          unsigned int v10 = *(_DWORD *)(v4 + 12);
          unint64_t v11 = v7;
          float v12 = *(float *)v4;
          do
          {
            *(v11 - 1) = v12;
            *unint64_t v11 = *(v11 - 2);
            float v12 = *(v11 - 5);
            if (v9 == v12) {
              int v13 = 0;
            }
            else {
              int v13 = -127;
            }
            if (v9 > v12) {
              int v13 = 1;
            }
            if (v9 < v12) {
              int v13 = -1;
            }
            if (!v13)
            {
              unsigned int v14 = *((_DWORD *)v11 - 4);
              BOOL v15 = v10 == v14;
              if (v10 < v14) {
                LOBYTE(v13) = -1;
              }
              else {
                LOBYTE(v13) = 1;
              }
              if (v15) {
                LOBYTE(v13) = 0;
              }
            }
            v11 -= 2;
          }
          while (v13 != 129 && (v13 & 0x80) != 0);
          *(v11 - 1) = v9;
          *(_DWORD *)unint64_t v11 = v10;
        }
        uint64_t v5 = (uint64_t)(v8 + 2);
        v7 += 2;
        uint64_t v4 = (uint64_t)v8;
      }
      while (v8 + 2 != a2);
    }
  }
  return result;
}

uint64_t std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(uint64_t result, float *a2, uint64_t a3)
{
  if ((float *)result != a2)
  {
    uint64_t v4 = result;
    uint64_t v5 = result + 8;
    if ((float *)(result + 8) != a2)
    {
      uint64_t v7 = 0;
      uint64_t v8 = result;
      do
      {
        float v9 = (float *)v5;
        uint64_t result = std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a3, v5, v8);
        if (result)
        {
          float v10 = *v9;
          unsigned int v11 = *(_DWORD *)(v8 + 12);
          uint64_t v12 = v7;
          float v13 = *(float *)v8;
          while (1)
          {
            uint64_t v14 = v4 + v12;
            *(float *)(v14 + 8) = v13;
            *(_DWORD *)(v14 + 12) = *(_DWORD *)(v4 + v12 + 4);
            if (!v12) {
              break;
            }
            float v13 = *(float *)(v14 - 8);
            if (v10 == v13) {
              int v15 = 0;
            }
            else {
              int v15 = -127;
            }
            if (v10 > v13) {
              int v15 = 1;
            }
            if (v10 < v13) {
              int v15 = -1;
            }
            if (!v15)
            {
              unsigned int v16 = *(_DWORD *)(v4 + v12 - 4);
              BOOL v17 = v11 == v16;
              if (v11 < v16) {
                LOBYTE(v15) = -1;
              }
              else {
                LOBYTE(v15) = 1;
              }
              if (v17) {
                LOBYTE(v15) = 0;
              }
            }
            v12 -= 8;
            if (v15 == 129 || (v15 & 0x80) == 0)
            {
              uint64_t v18 = v4 + v12 + 8;
              goto LABEL_24;
            }
          }
          uint64_t v18 = v4;
LABEL_24:
          *(float *)uint64_t v18 = v10;
          *(_DWORD *)(v18 + 4) = v11;
        }
        uint64_t v5 = (uint64_t)(v9 + 2);
        v7 += 8;
        uint64_t v8 = (uint64_t)v9;
      }
      while (v9 + 2 != a2);
    }
  }
  return result;
}

BOOL std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(float *)a2 == *(float *)a3) {
    int v3 = 0;
  }
  else {
    int v3 = -127;
  }
  if (*(float *)a2 > *(float *)a3) {
    int v3 = 1;
  }
  if (*(float *)a2 < *(float *)a3) {
    int v3 = -1;
  }
  if (!v3)
  {
    unsigned int v4 = *(_DWORD *)(a2 + 4);
    unsigned int v5 = *(_DWORD *)(a3 + 4);
    BOOL v6 = v4 == v5;
    LOBYTE(v3) = v4 < v5 ? -1 : 1;
    if (v6) {
      LOBYTE(v3) = 0;
    }
  }
  return v3 != 129 && (v3 & 0x80u) != 0;
}

float RB::RenderPass::fill(uint64_t a1, float32x4_t a2)
{
  *(float16x4_t *)&v10[12] = vcvt_f16_f32(a2);
  RB::Coverage::set_plane((float32x2_t *)&v9, a1, *(int32x2_t *)&v10[12]);
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a1, (RB::Device *)0x24, 4uLL, 0, &v11);
  int v3 = v11;
  if (v11)
  {
    uint64_t v4 = *((void *)v11 + 7) + v12.i64[0];
    long long v5 = v9;
    long long v6 = *(_OWORD *)v10;
    *(_DWORD *)(v4 + 32) = *(_DWORD *)&v10[16];
    *(_OWORD *)uint64_t v4 = v5;
    *(_OWORD *)(v4 + 16) = v6;
  }
  else
  {
    unsigned int v11 = 0;
    int64x2_t v12 = 0uLL;
  }
  *(_DWORD *)(a1 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a1, v3);
  *(int32x2_t *)(a1 + 188) = vmovn_s64(v12);
  if (*(_DWORD *)(a1 + 136) == 2) {
    uint64_t v7 = 131074;
  }
  else {
    uint64_t v7 = 2;
  }
  RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, (const char *)v7, 4, ***(void ***)a1 + 80, 0, 1uLL, 0, *(int32x2_t *)(a1 + 104));
  float result = *(float *)(a1 + 120) + 1.0;
  *(float *)(a1 + 120) = result;
  return result;
}

float32_t RB::Coverage::set_plane(float32x2_t *a1, uint64_t a2, int32x2_t a3)
{
  a3.i32[0] = 0;
  int32x2_t v3 = *(int32x2_t *)(a2 + 168);
  uint32x2_t v4 = (uint32x2_t)vceq_s32(v3, (int32x2_t)0x8000000080000000);
  int8x8_t v5 = (int8x8_t)vdup_lane_s32(vcgt_s32(a3, (int32x2_t)vpmin_u32(v4, v4)), 0);
  float32x2_t v6 = (float32x2_t)vbsl_s8(v5, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(*(int32x2_t *)(a2 + 160)));
  int8x8_t v7 = vbsl_s8(v5, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v3));
  v8.f64[0] = 0.0;
  *(double *)&unint64_t v9 = *(float *)v7.i32;
  v8.f64[1] = *(float *)&v7.i32[1];
  float32x2_t v10 = *(float32x2_t *)(a2 + 112);
  v10.i32[1] = vneg_f32(v10).i32[1];
  *a1 = vmul_f32(v10, vcvt_f32_f64((float64x2_t)v9));
  a1[1] = vmul_f32(v10, vcvt_f32_f64(v8));
  a1[2] = vmla_f32((float32x2_t)0x3F800000BF800000, v6, v10);
  float32_t result = *(float *)(a2 + 120);
  a1[3].f32[0] = result;
  return result;
}

void anonymous namespace'::make_single_element_path<RBPathMakeEllipse::EllipseArgs>(RBPathMakeEllipse::EllipseArgs &&,CGAffineTransform const*)::Info::~Info()
{
}

uint64_t RBPathEqualToPath(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  float32x2_t v6 = (RBPathCallbacks *)a2;
  int8x8_t v7 = (void *)a1;
  uint64_t v18 = *MEMORY[0x263EF8340];
  if ((void *)a2 != a4)
  {
    if ((_UNKNOWN *)a2 == &empty_path_callbacks)
    {
      if (a1 != 1)
      {
        a1 = a3;
        a2 = (uint64_t)a4;
LABEL_20:
        return RBPathIsEmpty(a1, a2);
      }
      return a3 == 1 && a4 == &empty_path_callbacks;
    }
    else
    {
      if (a4 != &empty_path_callbacks)
      {
LABEL_4:
        RB::Path::Storage::Storage((uint64_t)&v14, (const char *)0x440);
        unint64_t v17 = 0;
        v20.mach_timebase_info info = v7;
        v20.callbacks = v6;
        RB::Path::Storage::append_path((RB::Path::Storage *)&v14, v20);
        if (RBPathApplyElements(a3, (uint64_t)a4, (uint64_t)&v14, (uint64_t)RBPathEqualToPath::$_0::__invoke<void *,RBPathElement,double const*,void const*>))
        {
          if (v15) {
            unint64_t v8 = v16;
          }
          else {
            unint64_t v8 = ((unint64_t)v15 >> 8) & 0xFFF;
          }
          BOOL v9 = v17 >= v8;
        }
        else
        {
          BOOL v9 = 0;
        }
        RB::Path::Storage::~Storage((RB::Path::Storage *)&v14);
        return v9;
      }
      if (a3 != 1) {
        goto LABEL_20;
      }
      return 0;
    }
  }
  if (a1 == a3) {
    return 1;
  }
  if (*(unsigned char *)(a2 + 2))
  {
    int64x2_t v12 = *(uint64_t (**)(void))(a2 + 32);
    if (!v12) {
      goto LABEL_4;
    }
    return v12();
  }
  else
  {
    float32x2_t v10 = *(uint64_t (**)(void))(a2 + 32);
    if (!v10) {
      goto LABEL_4;
    }
    return v10();
  }
}

void sub_21412F4C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t RB::anonymous namespace'::load_library(void *a1, void *a2)
{
  uint64_t v4 = [a1 URLForResource:@"default" withExtension:@"metallib"];
  if (!v4)
  {
    uint64_t v9 = objc_msgSend((id)objc_msgSend(a1, "bundlePath"), "UTF8String");
    RB::precondition_failure((RB *)"unable to find default.metallib in %s", v10, v9);
  }
  id v12 = 0;
  uint64_t v6 = [a2 newLibraryWithURL:v4 error:&v12];
  if (v12) {
    BOOL v7 = 1;
  }
  else {
    BOOL v7 = v6 == 0;
  }
  if (v7)
  {
    if (v12) {
      unsigned int v11 = (const char *)objc_msgSend((id)objc_msgSend(v12, "localizedDescription"), "UTF8String");
    }
    else {
      unsigned int v11 = "unknown error";
    }
    RB::non_fatal_precondition_failure((RB *)"unable to load shader library: %s", v5, v11);
  }
  return v6;
}

uint64_t RB::anonymous namespace'::load_library_archive(void *a1, void *a2)
{
  uint64_t v3 = [a1 URLForResource:@"archive" withExtension:@"metallib"];
  if (!v3) {
    return 0;
  }
  uint64_t v4 = v3;
  int8x8_t v5 = objc_opt_new();
  [v5 setUrl:v4];
  objc_msgSend(v5, "setOptions:", objc_msgSend(v5, "options") | 0x20);
  id v10 = 0;
  uint64_t v7 = [a2 newBinaryArchiveWithDescriptor:v5 error:&v10];
  if (v10 || !v7)
  {
    if (v10) {
      uint64_t v9 = (const char *)objc_msgSend((id)objc_msgSend(v10, "localizedDescription"), "UTF8String");
    }
    else {
      uint64_t v9 = "unknown error";
    }
    RB::non_fatal_precondition_failure((RB *)"unable to load binary archive: %s", v6, v9);
  }

  return v7;
}

void sub_21412F678(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void init_background_notifications(void *a1)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v2 = (void *)[MEMORY[0x263F08A00] defaultCenter];
  [v2 addObserver:a1 selector:sel_didEnterBackground_ name:@"UIApplicationDidEnterBackgroundNotification" object:0];
  [v2 addObserver:a1 selector:sel_willEnterForeground_ name:@"UIApplicationWillEnterForegroundNotification" object:0];
  uint64_t v3 = proc_pidoriginatorinfo();
  if (v3)
  {
    is_running_in_background = 0;
  }
  else
  {
    uint64_t v4 = RB::error_log((RB *)v3);
    uint64_t v3 = os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
    if (v3) {
      init_background_notifications(v4);
    }
  }
  int8x8_t v5 = RB::misc_log((RB *)v3);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67109120;
    int v7 = is_running_in_background;
    _os_log_impl(&dword_2140F5000, v5, OS_LOG_TYPE_INFO, "RBDevice: initialized bg state: %{BOOL}d", buf, 8u);
  }
}

uint64_t RB::misc_log(RB *this)
{
  unsigned int v1 = &color_symbols(void)::flag;
  {
    unsigned int v1 = &color_symbols(void)::flag;
    if (v3)
    {
      RB::misc_log(void)::log = (uint64_t)os_log_create("com.apple.renderbox", "misc");
      unsigned int v1 = &color_symbols(void)::flag;
    }
  }
  return *((void *)v1 + 54);
}

void RB::SharedSurfaceGroup::collect_removed_locked(void)::$_0::__invoke(void *context)
{
  uint64_t v2 = *((unsigned int *)context + 4);
  if (v2)
  {
    uint64_t v3 = 24 * v2;
    uint64_t v4 = context[1] + 8;
    do
    {
      RB::SharedSurface::update_removes(v4);
      v4 += 24;
      v3 -= 24;
    }
    while (v3);
  }
  dispatch_sync_f(*(dispatch_queue_t *)(*(void *)*context + 32), context, (dispatch_function_t)RB::SharedSurfaceGroup::collect_removed_locked(void)::$_0::operator() const(void *)::{lambda(void *)#1}::__invoke);
  int8x8_t v5 = (char *)context[1];
  if (*((_DWORD *)context + 4))
  {
    unint64_t v6 = 0;
    do
    {
      int v7 = &v5[24 * v6];
      id v10 = (id *)*((void *)v7 + 1);
      uint64_t v9 = v7 + 8;
      uint64_t v8 = v10;
      if (*((_DWORD *)v9 + 2))
      {
        unint64_t v11 = 0;
        id v12 = v8 + 4;
        do
        {

          float v13 = (atomic_uint *)*(v12 - 4);
          if (v13 && atomic_fetch_add_explicit(v13 + 2, 0xFFFFFFFF, memory_order_release) == 1)
          {
            __dmb(9u);
            (*(void (**)(atomic_uint *))(*(void *)v13 + 8))(v13);
          }
          ++v11;
          v12 += 7;
        }
        while (v11 < *((unsigned int *)v9 + 2));
        uint64_t v8 = *(id **)v9;
      }
      if (v8) {
        free(v8);
      }
      ++v6;
    }
    while (v6 < *((unsigned int *)context + 4));
    int8x8_t v5 = (char *)context[1];
  }
  if (v5) {
    free(v5);
  }
  JUMPOUT(0x21669AC10);
}

void RB::SharedSurface::update_removes(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)a1;
  unint64_t v3 = *(unsigned int *)(a1 + 8);
  unint64_t v4 = 126 - 2 * __clz(v3);
  if (v3) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  std::__introsort<std::_ClassicAlgPolicy,RB::SharedSurface::update_removes(RB::vector<RB::SharedSurface::Remove,0ul,unsigned int> &)::$_0 &,RB::SharedSurface::Remove*,false>(v2, (uint64_t)&v2[7 * v3], v5, 1);
  uint64_t v6 = *(unsigned int *)(a1 + 8);
  if (v6)
  {
    int v7 = 0;
    unsigned int v8 = 0;
    unsigned __int8 v9 = 0;
    uint64_t v10 = 56 * v6;
    unint64_t v11 = (RB::SharedSurfaceTimestamp *)(*(void *)a1 + 32);
    do
    {
      id v12 = *(void **)v11;
      if (*(void *)v11)
      {
        unsigned int v13 = *((_DWORD *)v11 + 4);
        if (v12 != v7) {
          goto LABEL_8;
        }
        if (v13 != v8)
        {
          if (((v13 < v8) & v9) != 0)
          {
LABEL_13:

            *(void *)unint64_t v11 = 0;
            goto LABEL_14;
          }
LABEL_8:
          unsigned __int8 v9 = RB::SharedSurfaceTimestamp::test(v11);
          unsigned int v8 = v13;
          int v7 = v12;
          goto LABEL_14;
        }
        if (v9) {
          goto LABEL_13;
        }
        unsigned __int8 v9 = 0;
      }
LABEL_14:
      unint64_t v11 = (RB::SharedSurfaceTimestamp *)((char *)v11 + 56);
      v10 -= 56;
    }
    while (v10);
  }
}

void std::__introsort<std::_ClassicAlgPolicy,RB::SharedSurface::update_removes(RB::vector<RB::SharedSurface::Remove,0ul,unsigned int> &)::$_0 &,RB::SharedSurface::Remove*,false>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = a2;
  iuint64_t i = a1;
  uint64_t v190 = *MEMORY[0x263EF8340];
  v183 = (uint64_t *)a2;
  v184 = a1;
  while (1)
  {
    uint64_t v10 = v8 - (void)ii;
    unint64_t v11 = 0x6DB6DB6DB6DB6DB7 * ((v8 - (uint64_t)ii) >> 3);
    if (v5 || !v4)
    {
      switch(v11)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          v183 = (uint64_t *)(v8 - 56);
          unint64_t v70 = *(void *)(v8 - 24);
          unint64_t v71 = ii[4];
          if (v70 < v71 || v70 == v71 && *(_DWORD *)(v8 - 8) > *((_DWORD *)ii + 12)) {
            std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<RB::SharedSurface::Remove *&,RB::SharedSurface::Remove *&>(&v184, (uint64_t *)&v183);
          }
          break;
        case 3uLL:
          v183 = (uint64_t *)(v8 - 56);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::SharedSurface::update_removes(RB::vector<RB::SharedSurface::Remove,0ul,unsigned int> &)::$_0 &,RB::SharedSurface::Remove*>((uint64_t)ii, (uint64_t)(ii + 7), v8 - 56);
          break;
        case 4uLL:
          v183 = (uint64_t *)(v8 - 56);
          std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,RB::SharedSurface::update_removes(RB::vector<RB::SharedSurface::Remove,0ul,unsigned int> &)::$_0 &,RB::SharedSurface::Remove*>((uint64_t)ii, (uint64_t)(ii + 7), (uint64_t)(ii + 14), v8 - 56);
          break;
        case 5uLL:
          v183 = (uint64_t *)(v8 - 56);
          std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,RB::SharedSurface::update_removes(RB::vector<RB::SharedSurface::Remove,0ul,unsigned int> &)::$_0 &,RB::SharedSurface::Remove*,0>((uint64_t)ii, (uint64_t)(ii + 7), (uint64_t)(ii + 14), (uint64_t)(ii + 21), v8 - 56);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v10 <= 1343)
    {
      int v72 = ii + 7;
      BOOL v74 = ii == (uint64_t *)v8 || v72 == (uint64_t *)v8;
      if (a4)
      {
        if (v74) {
          return;
        }
        uint64_t v75 = 0;
        unint64_t v76 = ii;
        while (1)
        {
          long long v77 = v76;
          unint64_t v76 = v72;
          unint64_t v78 = v77[11];
          unint64_t v79 = v77[4];
          if (v78 < v79) {
            break;
          }
          if (v78 == v79)
          {
            unsigned int v80 = *((_DWORD *)v77 + 26);
            if (v80 > *((_DWORD *)v77 + 12)) {
              goto LABEL_130;
            }
          }
LABEL_144:
          int v72 = v76 + 7;
          v75 += 56;
          if (v76 + 7 == (uint64_t *)v8) {
            return;
          }
        }
        unsigned int v80 = *((_DWORD *)v77 + 26);
LABEL_130:
        uint64_t v81 = *v76;
        *unint64_t v76 = 0;
        long long v188 = *((_OWORD *)v77 + 4);
        int v189 = *((_DWORD *)v77 + 20);
        v77[11] = 0;
        uint64_t v82 = v77[12];
        for (uint64_t i = v75; ; i -= 56)
        {
          long long v84 = (char *)ii + i;
          uint64_t v85 = *(uint64_t *)((char *)ii + i + 56);
          *((void *)v84 + 7) = *(uint64_t *)((char *)ii + i);
          *(void *)long long v84 = v85;
          *((_OWORD *)v84 + 4) = *(_OWORD *)((char *)ii + i + 8);
          *((_DWORD *)v84 + 20) = *(_DWORD *)((char *)ii + i + 24);
          uint64_t v86 = *(uint64_t *)((char *)ii + i + 88);
          *((void *)v84 + 11) = *(uint64_t *)((char *)ii + i + 32);
          *((void *)v84 + 4) = v86;
          uint64_t v87 = *(uint64_t *)((char *)ii + i + 96);
          *((void *)v84 + 12) = *(uint64_t *)((char *)ii + i + 40);
          *((void *)v84 + 5) = v87;
          LODWORD(v86) = *(_DWORD *)((char *)ii + i + 104);
          *((_DWORD *)v84 + 26) = *(_DWORD *)((char *)ii + i + 48);
          *((_DWORD *)v84 + 12) = v86;
          if (!i)
          {
            uint64_t v89 = ii;
            goto LABEL_141;
          }
          unint64_t v88 = *((void *)v84 - 3);
          if (v78 >= v88 && (v78 != v88 || v80 <= *(_DWORD *)((char *)ii + i - 8))) {
            break;
          }
        }
        uint64_t v89 = (uint64_t *)((char *)ii + i);
LABEL_141:
        uint64_t v90 = (atomic_uint *)*v89;
        *uint64_t v89 = v81;
        long long v91 = v188;
        *((_DWORD *)v84 + 6) = v189;
        *(_OWORD *)(v84 + 8) = v91;
        unsigned int v92 = (void *)v89[4];
        v89[4] = v78;
        v89[5] = v82;
        *((_DWORD *)v89 + 12) = v80;

        if (v90 && atomic_fetch_add_explicit(v90 + 2, 0xFFFFFFFF, memory_order_release) == 1)
        {
          __dmb(9u);
          (*(void (**)(atomic_uint *))(*(void *)v90 + 8))(v90);
        }
        goto LABEL_144;
      }
      if (v74) {
        return;
      }
      for (uint64_t j = ii + 5; ; j += 7)
      {
        float64x2_t v169 = ii;
        iuint64_t i = v72;
        unint64_t v170 = v169[11];
        unint64_t v171 = v169[4];
        if (v170 < v171) {
          break;
        }
        if (v170 == v171)
        {
          unsigned int v172 = *((_DWORD *)v169 + 26);
          if (v172 > *((_DWORD *)v169 + 12)) {
            goto LABEL_210;
          }
        }
LABEL_220:
        int v72 = ii + 7;
        if (ii + 7 == (uint64_t *)v8) {
          return;
        }
      }
      unsigned int v172 = *((_DWORD *)v169 + 26);
LABEL_210:
      uint64_t v173 = *ii;
      *iuint64_t i = 0;
      long long v188 = *((_OWORD *)v169 + 4);
      int v189 = *((_DWORD *)v169 + 20);
      v169[11] = 0;
      uint64_t v174 = v169[12];
      for (k = j; ; k -= 7)
      {
        uint64_t v176 = k[2];
        k[2] = *(k - 5);
        *(k - 5) = v176;
        *(_OWORD *)(k + 3) = *((_OWORD *)k - 2);
        *((_DWORD *)k + 10) = *((_DWORD *)k - 4);
        uint64_t v177 = k[6];
        k[6] = *(k - 1);
        *(k - 1) = v177;
        uint64_t v178 = k[7];
        k[7] = *k;
        uint64_t *k = v178;
        LODWORD(v177) = *((_DWORD *)k + 16);
        *((_DWORD *)k + 16) = *((_DWORD *)k + 2);
        *((_DWORD *)k + 2) = v177;
        unint64_t v179 = *(k - 8);
        if (v170 >= v179 && (v170 != v179 || v172 <= *((_DWORD *)k - 12))) {
          break;
        }
      }
      v180 = (atomic_uint *)*(k - 5);
      *(k - 5) = v173;
      long long v181 = v188;
      *((_DWORD *)k - 4) = v189;
      *((_OWORD *)k - 2) = v181;
      v182 = (void *)*(k - 1);
      *(k - 1) = v170;
      uint64_t *k = v174;
      *((_DWORD *)k + 2) = v172;

      if (v180 && atomic_fetch_add_explicit(v180 + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        (*(void (**)(atomic_uint *))(*(void *)v180 + 8))(v180);
      }
      goto LABEL_220;
    }
    if (!a3) {
      break;
    }
    unint64_t v12 = v11 >> 1;
    uint64_t v13 = v8 - 56;
    if ((unint64_t)v10 >= 0x1C01)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::SharedSurface::update_removes(RB::vector<RB::SharedSurface::Remove,0ul,unsigned int> &)::$_0 &,RB::SharedSurface::Remove*>((uint64_t)ii, (uint64_t)&ii[7 * (v11 >> 1)], v13);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::SharedSurface::update_removes(RB::vector<RB::SharedSurface::Remove,0ul,unsigned int> &)::$_0 &,RB::SharedSurface::Remove*>((uint64_t)(v184 + 7), (uint64_t)&v184[7 * v12 - 7], (uint64_t)(v183 - 14));
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::SharedSurface::update_removes(RB::vector<RB::SharedSurface::Remove,0ul,unsigned int> &)::$_0 &,RB::SharedSurface::Remove*>((uint64_t)(v184 + 14), (uint64_t)&v184[7 * v12 + 7], (uint64_t)(v183 - 21));
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::SharedSurface::update_removes(RB::vector<RB::SharedSurface::Remove,0ul,unsigned int> &)::$_0 &,RB::SharedSurface::Remove*>((uint64_t)&v184[7 * v12 - 7], (uint64_t)&v184[7 * v12], (uint64_t)&v184[7 * v12 + 7]);
      *(void *)&long long v188 = &v184[7 * v12];
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<RB::SharedSurface::Remove *&,RB::SharedSurface::Remove *&>(&v184, (uint64_t *)&v188);
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::SharedSurface::update_removes(RB::vector<RB::SharedSurface::Remove,0ul,unsigned int> &)::$_0 &,RB::SharedSurface::Remove*>((uint64_t)&ii[7 * (v11 >> 1)], (uint64_t)ii, v13);
    }
    --a3;
    uint64_t v14 = v184;
    if (a4)
    {
      unint64_t v15 = v184[4];
    }
    else
    {
      unint64_t v15 = *(v184 - 3);
      unint64_t v16 = v184[4];
      if (v15 >= v16)
      {
        if (v15 != v16)
        {
          unsigned int v29 = *((_DWORD *)v184 + 12);
LABEL_58:
          unint64_t v44 = (unint64_t)v183;
          unint64_t v185 = (unint64_t)v183;
          uint64_t v45 = *v184;
          uint64_t *v184 = 0;
          long long v188 = *(_OWORD *)(v14 + 1);
          int v189 = *((_DWORD *)v14 + 6);
          v14[4] = 0;
          unint64_t v46 = *(void *)(v44 - 24);
          if (v16 < v46 || v16 == v46 && v29 > *(_DWORD *)(v44 - 8))
          {
            unint64_t v47 = v14[11];
            if (v16 >= v47)
            {
              long long v54 = v14 + 18;
              do
              {
                if (v16 == v47 && v29 > *((_DWORD *)v54 - 10)) {
                  break;
                }
                unint64_t v55 = *v54;
                v54 += 7;
                unint64_t v47 = v55;
              }
              while (v16 >= v55);
              m = v54 - 11;
            }
            else
            {
              m = v14 + 7;
            }
          }
          else
          {
            for (m = v14 + 7; (unint64_t)m < v44; m += 7)
            {
              unint64_t v49 = m[4];
              if (v16 < v49 || v16 == v49 && v29 > *((_DWORD *)m + 12)) {
                break;
              }
            }
          }
          uint64_t v56 = v14[5];
          *(void *)&long long v186 = m;
          if ((unint64_t)m < v44)
          {
            for (unint64_t n = v44 - 80; v16 < v46 || v16 == v46 && v29 > *(_DWORD *)(n + 72); n -= 56)
            {
              unint64_t v58 = *(void *)n;
              unint64_t v46 = v58;
            }
            unint64_t v44 = n + 24;
            goto LABEL_91;
          }
          while ((unint64_t)m < v44)
          {
            std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<RB::SharedSurface::Remove *&,RB::SharedSurface::Remove *&>((uint64_t **)&v186, (uint64_t *)&v185);
            unint64_t v59 = *(void *)(v186 + 88);
            if (v16 >= v59)
            {
              uint64_t v60 = (void *)(v186 + 144);
              do
              {
                if (v16 == v59 && v29 > *((_DWORD *)v60 - 10)) {
                  break;
                }
                unint64_t v61 = *v60;
                v60 += 7;
                unint64_t v59 = v61;
              }
              while (v16 >= v61);
              m = v60 - 11;
            }
            else
            {
              m = (uint64_t *)(v186 + 56);
            }
            *(void *)&long long v186 = m;
            unint64_t v44 = v185;
            do
            {
              do
              {
                v44 -= 56;
                unint64_t v62 = *(void *)(v44 + 32);
              }
              while (v16 < v62);
            }
            while (v16 == v62 && v29 > *(_DWORD *)(v44 + 48));
LABEL_91:
            unint64_t v185 = v44;
          }
          if (m - 7 != v14)
          {
            uint64_t v63 = *v14;
            *uint64_t v14 = *(m - 7);
            *(m - 7) = v63;
            long long v64 = *((_OWORD *)m - 3);
            *((_DWORD *)v14 + 6) = *((_DWORD *)m - 8);
            *(_OWORD *)(v14 + 1) = v64;
            uint64_t v65 = v14[4];
            v14[4] = *(m - 3);
            *(m - 3) = v65;
            *(void *)&long long v64 = v14[5];
            v14[5] = *(m - 2);
            *(m - 2) = v64;
            LODWORD(v65) = *((_DWORD *)v14 + 12);
            *((_DWORD *)v14 + 12) = *((_DWORD *)m - 2);
            *((_DWORD *)m - 2) = v65;
          }
          int64_t v66 = (atomic_uint *)*(m - 7);
          *(m - 7) = v45;
          long long v67 = v188;
          *((_DWORD *)m - 8) = v189;
          *((_OWORD *)m - 3) = v67;
          uint64_t v68 = (void *)*(m - 3);
          *(m - 3) = v16;
          *(m - 2) = v56;
          *((_DWORD *)m - 2) = v29;
          iuint64_t i = (uint64_t *)v186;

          if (v66)
          {
            unsigned int add_explicit = atomic_fetch_add_explicit(v66 + 2, 0xFFFFFFFF, memory_order_release);
            BOOL v4 = add_explicit != 0;
            BOOL v5 = add_explicit == 1;
            if (add_explicit == 1)
            {
              __dmb(9u);
              (*(void (**)(atomic_uint *))(*(void *)v66 + 8))(v66);
            }
          }
          goto LABEL_110;
        }
        unsigned int v29 = *((_DWORD *)v184 + 12);
        if (*((_DWORD *)v184 - 2) <= v29) {
          goto LABEL_58;
        }
      }
      else
      {
        unint64_t v15 = v184[4];
      }
    }
    uint64_t v17 = 0;
    unint64_t v18 = (unint64_t)v183;
    uint64_t v19 = *v184;
    uint64_t *v184 = 0;
    long long v188 = *(_OWORD *)(v14 + 1);
    int v189 = *((_DWORD *)v14 + 6);
    v14[4] = 0;
    uint64_t v20 = v14[5];
    unsigned int v21 = *((_DWORD *)v14 + 12);
    while (1)
    {
      unint64_t v22 = v14[v17 + 11];
      if (v22 >= v15 && (v22 != v15 || LODWORD(v14[v17 + 13]) <= v21)) {
        break;
      }
      v17 += 7;
    }
    uint64_t v23 = a4;
    uint64_t v24 = a3;
    unint64_t v25 = (unint64_t)&v14[v17 + 7];
    *(void *)&long long v186 = v25;
    if (v17 * 8)
    {
      unint64_t v26 = *(void *)(v18 - 24);
      if (v26 >= v15)
      {
        unint64_t v30 = v18 - 80;
        do
        {
          if (v26 == v15 && *(_DWORD *)(v30 + 72) > v21) {
            break;
          }
          unint64_t v31 = *(void *)v30;
          v30 -= 56;
          unint64_t v26 = v31;
        }
        while (v31 >= v15);
        unint64_t v18 = v30 + 24;
      }
      else
      {
        v18 -= 56;
      }
    }
    else if (v25 < v18)
    {
      unint64_t v27 = v18 - 56;
      unint64_t v28 = *(void *)(v18 - 24);
      if (v28 >= v15)
      {
        unint64_t v50 = v18 - 80;
        do
        {
          unint64_t v51 = v50 + 24;
          if (v28 == v15)
          {
            if (*(_DWORD *)(v50 + 72) > v21 || v25 >= v51) {
              goto LABEL_23;
            }
          }
          else if (v25 >= v51)
          {
            break;
          }
          v27 -= 56;
          unint64_t v53 = *(void *)v50;
          v50 -= 56;
          unint64_t v28 = v53;
        }
        while (v53 >= v15);
        unint64_t v18 = v50 + 24;
      }
      else
      {
LABEL_23:
        unint64_t v18 = v27;
      }
    }
    unint64_t v185 = v18;
    iuint64_t i = (uint64_t *)v25;
    if (v25 < v18)
    {
      do
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<RB::SharedSurface::Remove *&,RB::SharedSurface::Remove *&>((uint64_t **)&v186, (uint64_t *)&v185);
        for (iuint64_t i = (uint64_t *)(v186 + 56); ; ii += 7)
        {
          unint64_t v32 = ii[4];
          if (v32 >= v15 && (v32 != v15 || *((_DWORD *)ii + 12) <= v21)) {
            break;
          }
        }
        *(void *)&long long v186 = ii;
        unint64_t v33 = *(void *)(v185 - 24);
        if (v33 >= v15)
        {
          unint64_t v35 = v185 - 80;
          do
          {
            if (v33 == v15 && *(_DWORD *)(v35 + 72) > v21) {
              break;
            }
            unint64_t v36 = *(void *)v35;
            v35 -= 56;
            unint64_t v33 = v36;
          }
          while (v36 >= v15);
          unint64_t v34 = v35 + 24;
        }
        else
        {
          unint64_t v34 = v185 - 56;
        }
        unint64_t v185 = v34;
      }
      while ((unint64_t)ii < v34);
    }
    if (ii - 7 != v14)
    {
      uint64_t v37 = *v14;
      *uint64_t v14 = *(ii - 7);
      *(ii - 7) = v37;
      long long v38 = *((_OWORD *)ii - 3);
      *((_DWORD *)v14 + 6) = *((_DWORD *)ii - 8);
      *(_OWORD *)(v14 + 1) = v38;
      uint64_t v39 = v14[4];
      v14[4] = *(ii - 3);
      *(ii - 3) = v39;
      *(void *)&long long v38 = v14[5];
      v14[5] = *(ii - 2);
      *(ii - 2) = v38;
      LODWORD(v39) = *((_DWORD *)v14 + 12);
      *((_DWORD *)v14 + 12) = *((_DWORD *)ii - 2);
      *((_DWORD *)ii - 2) = v39;
    }
    uint64_t v40 = (atomic_uint *)*(ii - 7);
    *(ii - 7) = v19;
    long long v41 = v188;
    *((_DWORD *)ii - 8) = v189;
    *((_OWORD *)ii - 3) = v41;
    size_t v42 = (void *)*(ii - 3);
    *(ii - 3) = v15;
    *(ii - 2) = v20;
    *((_DWORD *)ii - 2) = v21;

    if (v40 && atomic_fetch_add_explicit(v40 + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(atomic_uint *))(*(void *)v40 + 8))(v40);
    }
    BOOL v4 = v25 >= v18;
    a3 = v24;
    a4 = v23;
    if (!v4) {
      goto LABEL_51;
    }
    BOOL v43 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,RB::SharedSurface::update_removes(RB::vector<RB::SharedSurface::Remove,0ul,unsigned int> &)::$_0 &,RB::SharedSurface::Remove*>((uint64_t)v184, (uint64_t)(ii - 7));
    if (!std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,RB::SharedSurface::update_removes(RB::vector<RB::SharedSurface::Remove,0ul,unsigned int> &)::$_0 &,RB::SharedSurface::Remove*>((uint64_t)ii, (uint64_t)v183))
    {
      if (v43) {
        goto LABEL_111;
      }
LABEL_51:
      std::__introsort<std::_ClassicAlgPolicy,RB::SharedSurface::update_removes(RB::vector<RB::SharedSurface::Remove,0ul,unsigned int> &)::$_0 &,RB::SharedSurface::Remove*,false>(v184, ii - 7, a3, v23 & 1);
LABEL_110:
      a4 = 0;
LABEL_111:
      v184 = ii;
      goto LABEL_112;
    }
    if (v43) {
      return;
    }
    v183 = ii - 7;
    iuint64_t i = v184;
LABEL_112:
    uint64_t v8 = (uint64_t)v183;
  }
  if (ii != (uint64_t *)v8)
  {
    int64_t v93 = (v11 - 2) >> 1;
    int64_t v94 = v93;
    while (2)
    {
      int64_t v95 = v94;
      if (v93 >= v94)
      {
        uint64_t v96 = (2 * v94) | 1;
        uint32_t v97 = &ii[7 * v96];
        if (2 * v95 + 2 < (uint64_t)v11)
        {
          unint64_t v98 = ii[7 * v96 + 4];
          unint64_t v99 = v97[11];
          if (v98 < v99 || v98 == v99 && LODWORD(ii[7 * v96 + 6]) > *((_DWORD *)v97 + 26))
          {
            v97 += 7;
            uint64_t v96 = 2 * v95 + 2;
          }
        }
        int v100 = &ii[7 * v95];
        unint64_t v103 = v100[4];
        int v102 = v100 + 4;
        unint64_t v101 = v103;
        unint64_t v104 = v97[4];
        BOOL v105 = v104 == v103;
        if (v104 >= v103)
        {
          if (v105)
          {
            unsigned int v106 = ii[7 * v95 + 6];
            if (*((_DWORD *)v97 + 12) <= v106) {
              goto LABEL_158;
            }
          }
          else
          {
            unsigned int v106 = ii[7 * v95 + 6];
LABEL_158:
            uint64_t v107 = 0;
            uint64_t v108 = &ii[7 * v95];
            uint64_t v109 = *v108;
            uint64_t *v108 = 0;
            long long v110 = *(_OWORD *)(v108 + 1);
            int v189 = *((_DWORD *)v108 + 6);
            long long v188 = v110;
            *int v102 = 0;
            uint64_t v111 = v108[5];
            while (1)
            {
              uint64_t *v108 = *v97;
              *uint32_t v97 = v107;
              long long v112 = *(_OWORD *)(v97 + 1);
              *((_DWORD *)v108 + 6) = *((_DWORD *)v97 + 6);
              *(_OWORD *)(v108 + 1) = v112;
              uint64_t v113 = v108[4];
              v108[4] = v97[4];
              v97[4] = v113;
              *(void *)&long long v112 = v108[5];
              v108[5] = v97[5];
              v97[5] = v112;
              LODWORD(v113) = *((_DWORD *)v108 + 12);
              *((_DWORD *)v108 + 12) = *((_DWORD *)v97 + 12);
              *((_DWORD *)v97 + 12) = v113;
              if (v93 < v96) {
                break;
              }
              uint64_t v114 = 2 * v96;
              uint64_t v115 = (2 * v96) | 1;
              uint64_t v116 = &ii[7 * v115];
              uint64_t v117 = v114 + 2;
              if (v117 < (uint64_t)v11)
              {
                unint64_t v118 = ii[7 * v115 + 4];
                unint64_t v119 = v116[11];
                if (v118 < v119 || v118 == v119 && LODWORD(ii[7 * v115 + 6]) > *((_DWORD *)v116 + 26))
                {
                  v116 += 7;
                  uint64_t v115 = v117;
                }
              }
              unint64_t v120 = v116[4];
              if (v120 < v101 || v120 == v101 && *((_DWORD *)v116 + 12) > v106) {
                break;
              }
              uint64_t v107 = *v97;
              uint64_t v108 = v97;
              uint32_t v97 = v116;
              uint64_t v96 = v115;
            }
            unint64_t v121 = (atomic_uint *)*v97;
            *uint32_t v97 = v109;
            long long v122 = v188;
            *((_DWORD *)v97 + 6) = v189;
            *(_OWORD *)(v97 + 1) = v122;
            int8x8_t v123 = (void *)v97[4];
            v97[4] = v101;
            v97[5] = v111;
            *((_DWORD *)v97 + 12) = v106;

            if (v121 && atomic_fetch_add_explicit(v121 + 2, 0xFFFFFFFF, memory_order_release) == 1)
            {
              __dmb(9u);
              (*(void (**)(atomic_uint *))(*(void *)v121 + 8))(v121);
            }
          }
        }
      }
      int64_t v94 = v95 - 1;
      if (v95) {
        continue;
      }
      break;
    }
    int64_t v124 = v10 / 0x38uLL;
    while (2)
    {
      uint64_t v125 = 0;
      uint64_t v126 = *ii;
      *iuint64_t i = 0;
      int v127 = *((_DWORD *)ii + 6);
      long long v186 = *(_OWORD *)(ii + 1);
      int v187 = v127;
      uint64_t v128 = ii[4];
      ii[4] = 0;
      uint64_t v129 = ii[5];
      int v130 = *((_DWORD *)ii + 12);
      unint64_t v131 = ii;
      do
      {
        uint64_t v132 = v131;
        uint64_t v133 = v125 + 1;
        v131 += 7 * v125 + 7;
        uint64_t v134 = 2 * v125;
        uint64_t v125 = (2 * v125) | 1;
        int64_t v135 = v134 + 2;
        if (v135 < v124)
        {
          unint64_t v136 = v132[7 * v133 + 4];
          unint64_t v137 = v131[11];
          if (v136 < v137 || v136 == v137 && LODWORD(v132[7 * v133 + 6]) > *((_DWORD *)v131 + 26))
          {
            v131 += 7;
            uint64_t v125 = v135;
          }
        }
        uint64_t v138 = *v132;
        *uint64_t v132 = *v131;
        *unint64_t v131 = v138;
        long long v139 = *(_OWORD *)(v131 + 1);
        *((_DWORD *)v132 + 6) = *((_DWORD *)v131 + 6);
        *(_OWORD *)(v132 + 1) = v139;
        uint64_t v140 = v132[4];
        v132[4] = v131[4];
        v131[4] = v140;
        *(void *)&long long v139 = v132[5];
        v132[5] = v131[5];
        v131[5] = v139;
        LODWORD(v140) = *((_DWORD *)v132 + 12);
        *((_DWORD *)v132 + 12) = *((_DWORD *)v131 + 12);
        *((_DWORD *)v131 + 12) = v140;
      }
      while (v125 <= (uint64_t)((unint64_t)(v124 - 2) >> 1));
      unsigned int v141 = (long long *)(v131 + 1);
      uint64_t v142 = v8 - 56;
      uint64_t v143 = (atomic_uint *)*v131;
      if (v131 == (uint64_t *)(v8 - 56))
      {
        *unint64_t v131 = v126;
        long long v163 = v186;
        *((_DWORD *)v131 + 6) = v187;
        *unsigned int v141 = v163;
        int v146 = (void *)v131[4];
        v131[4] = v128;
        v131[5] = v129;
        *((_DWORD *)v131 + 12) = v130;
      }
      else
      {
        *unint64_t v131 = *(void *)(v8 - 56);
        *(void *)(v8 - 56) = v143;
        long long v144 = *(_OWORD *)(v8 - 48);
        *((_DWORD *)v131 + 6) = *(_DWORD *)(v8 - 32);
        *unsigned int v141 = v144;
        uint64_t v145 = v131[4];
        v131[4] = *(void *)(v8 - 24);
        *(void *)(v8 - 24) = v145;
        v131[5] = *(void *)(v8 - 16);
        *((_DWORD *)v131 + 12) = *(_DWORD *)(v8 - 8);
        uint64_t v143 = *(atomic_uint **)(v8 - 56);
        *(void *)(v8 - 56) = v126;
        *(_OWORD *)(v8 - 48) = v186;
        *(_DWORD *)(v8 - 32) = v187;
        int v146 = *(void **)(v8 - 24);
        *(void *)(v8 - 24) = v128;
        *(void *)(v8 - 16) = v129;
        *(_DWORD *)(v8 - 8) = v130;
        uint64_t v147 = (char *)v131 - (char *)ii + 56;
        if (v147 >= 57)
        {
          unint64_t v148 = (v147 / 0x38uLL - 2) >> 1;
          unint64_t v149 = ii[7 * v148 + 4];
          uint64_t v150 = (void *)v131[4];
          if (v149 < (unint64_t)v150)
          {
            unsigned int v151 = *((_DWORD *)v131 + 12);
            goto LABEL_185;
          }
          if ((void *)v149 == v150)
          {
            unsigned int v151 = *((_DWORD *)v131 + 12);
            if (LODWORD(ii[7 * v148 + 6]) > v151)
            {
LABEL_185:
              int v152 = 0;
              unsigned int v153 = (atomic_uint *)*v131;
              *unint64_t v131 = 0;
              long long v154 = *v141;
              int v189 = *((_DWORD *)v131 + 6);
              long long v188 = v154;
              v131[4] = 0;
              uint64_t v155 = v131[5];
              while (1)
              {
                int v156 = v131;
                unint64_t v131 = &ii[7 * v148];
                *int v156 = *v131;
                *unint64_t v131 = (uint64_t)v152;
                long long v157 = *(_OWORD *)(v131 + 1);
                *((_DWORD *)v156 + 6) = *((_DWORD *)v131 + 6);
                *(_OWORD *)(v156 + 1) = v157;
                int32x2_t v158 = (void **)(v131 + 4);
                uint64_t v159 = v156[4];
                v156[4] = v131[4];
                v131[4] = v159;
                uint64_t v160 = v156[5];
                v156[5] = v131[5];
                v131[5] = v160;
                int v161 = *((_DWORD *)v156 + 12);
                *((_DWORD *)v156 + 12) = *((_DWORD *)v131 + 12);
                *((_DWORD *)v131 + 12) = v161;
                if (!v148) {
                  break;
                }
                unint64_t v148 = (v148 - 1) >> 1;
                unint64_t v162 = ii[7 * v148 + 4];
                if (v162 >= (unint64_t)v150 && ((void *)v162 != v150 || LODWORD(ii[7 * v148 + 6]) <= v151)) {
                  break;
                }
                int v152 = (atomic_uint *)*v131;
              }
              float64x2_t v164 = (atomic_uint *)*v131;
              *unint64_t v131 = (uint64_t)v153;
              long long v165 = v188;
              *((_DWORD *)v131 + 6) = v189;
              *(_OWORD *)(v131 + 1) = v165;
              float64x2_t v166 = *v158;
              *int32x2_t v158 = v150;
              v131[5] = v155;
              *((_DWORD *)v131 + 12) = v151;

              if (v164 && atomic_fetch_add_explicit(v164 + 2, 0xFFFFFFFF, memory_order_release) == 1)
              {
                __dmb(9u);
                (*(void (**)(atomic_uint *))(*(void *)v164 + 8))(v164);
              }
            }
          }
        }
      }

      if (v143 && atomic_fetch_add_explicit(v143 + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        (*(void (**)(atomic_uint *))(*(void *)v143 + 8))(v143);
      }
      uint64_t v8 = v142;
      if (v124-- <= 2) {
        return;
      }
      continue;
    }
  }
}

void sub_214130AD0(_Unwind_Exception *a1)
{
  if (v2) {
    std::__introsort<std::_ClassicAlgPolicy,RB::SharedSurface::update_removes(RB::vector<RB::SharedSurface::Remove,0ul,unsigned int> &)::$_0 &,RB::SharedSurface::Remove*,false>(v2);
  }
  _Unwind_Resume(a1);
}

uint64_t RB::SharedSurfaceTimestamp::test(RB::SharedSurfaceTimestamp *this)
{
  if (!*(void *)this) {
    return 1;
  }
  if (CACurrentMediaTime() > *((double *)this + 1)) {
    goto LABEL_6;
  }
  unsigned int v2 = *((_DWORD *)this + 4);
  if (v2 > [*(id *)this commitId]) {
    return 0;
  }
  uint64_t result = [*(id *)this waitForCommitId:*((unsigned int *)this + 4) timeout:0.0];
  if (result)
  {
LABEL_6:

    *(void *)this = 0;
    return 1;
  }
  return result;
}

uint64_t RB::BinAllocator::BinAllocator(uint64_t a1, double a2)
{
  *(double *)a1 = a2;
  *(double *)(a1 + 8) = a2;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v3 = (void *)(a1 + 16);
  RB::vector<RB::BinAllocator::Shelf,0ul,unsigned int>::reserve_slow(a1 + 16, 1u);
  uint64_t v4 = *v3 + 32 * *(unsigned int *)(a1 + 24);
  *(_WORD *)uint64_t v4 = 0;
  *(int16x4_t *)(v4 + 2) = vuzp1_s16(*(int16x4_t *)&a2, vdup_lane_s16(*(int16x4_t *)&a2, 0));
  *(void *)(v4 + 24) = 0;
  *(void *)(v4 + 16) = 0;
  RB::vector<RB::Animation::TermOrArg,0ul,unsigned int>::reserve_slow(v4 + 16, 1u);
  *(_DWORD *)(*(void *)(v4 + 16) + 4 * (*(_DWORD *)(v4 + 24))++) = LOWORD(a2) << 16;
  ++*(_DWORD *)(a1 + 24);
  return a1;
}

uint64_t RB::SharedSurfaceGroup::add_subsurface(os_unfair_lock_s *this, atomic_uint *a2, uint64_t a3, int a4, int a5, void *a6, unsigned __int32 a7, void (**a8)(void, void), double a9, float a10, __n128 a11)
{
  uint64_t v85 = *MEMORY[0x263EF8340];
  if ((a7 & 1) == 0)
  {
    int v20 = vmul_lane_s32(*(int32x2_t *)&a9, *(int32x2_t *)&a9, 1).u32[0];
    unsigned int v21 = (RB::SharedSurfaceGroup *)RB::SharedSurfaceGroup::max_subsurface_area((RB::SharedSurfaceGroup *)this);
    if (v20 > (int)v21) {
      return 0;
    }
    uint32x2_t v22 = (uint32x2_t)vcgt_s32(*(int32x2_t *)&a9, vdup_n_s32(RB::SharedSurfaceGroup::max_subsurface_size(v21)));
    if ((vpmax_u32(v22, v22).u32[0] & 0x80000000) != 0) {
      return 0;
    }
  }
  if (a2[8]) {
    RB::SharedSurfaceGroup::cancel_async_updates(this, a2);
  }
  if (!RB::SharedSurfaceGroup::wait_for_allocations((RB::SharedSurfaceGroup *)this, (RB::SharedSurfaceClient *)a2))return 0; {
  unint64_t v58 = a8;
  }
  unint64_t v73 = 0;
  uint64_t v23 = this + 4;
  os_unfair_lock_lock(this + 4);
  unint64_t v26 = *(os_unfair_lock_s **)&this[8]._os_unfair_lock_opaque;
  if (v26 == &this[6])
  {
    int32x2_t v32 = (int32x2_t)0x10000000100;
LABEL_21:
    for (int i = v32.i32[0]; i < SLODWORD(a9); v32.i32[0] = i)
      i *= 2;
    int32x2_t v35 = v32;
    for (int j = v32.i32[1]; j < SHIDWORD(a9); v35.i32[1] = j)
      j *= 2;
    int32x2_t v61 = v35;
    uint64_t v37 = (os_unfair_lock_s *)RB::SurfacePool::shared((RB::SurfacePool *)v24);
    if (RB::SurfacePool::alloc(v37, *(void *)&this->_os_unfair_lock_opaque, a3, a4, a5, 0, v61, 0)) {
      operator new();
    }
    os_unfair_lock_unlock(v23);
    return 0;
  }
  char v27 = 0;
  *(void *)&long long v25 = 0x10000000100;
  long long v60 = v25;
  while (1)
  {
    uint64_t v28 = *(void *)&v26[4]._os_unfair_lock_opaque;
    uint64_t v29 = *(void *)(v28 + 24);
    if (*(void *)(v29 + 32) != a3
      || *(unsigned __int8 *)(v29 + 44) != a4
      || *(_DWORD *)(v29 + 40) != a5
      || *(float *)(v28 + 64) != a10)
    {
      goto LABEL_15;
    }
    int32x2_t v30 = *(int32x2_t *)(v28 + 32);
    uint64_t v24 = RB::BinAllocator::alloc((int32x2_t *)(v28 + 32), &v73, *(int32x2_t *)&a9);
    *((void *)&v31 + 1) = *((void *)&v60 + 1);
    *(int32x2_t *)&long long v31 = vmax_s32(*(int32x2_t *)&v60, v30);
    long long v60 = v31;
    if (v24) {
      break;
    }
    char v27 = 1;
LABEL_15:
    unint64_t v26 = *(os_unfair_lock_s **)&v26[2]._os_unfair_lock_opaque;
    if (v26 == &this[6])
    {
      uint64_t v23 = this + 4;
      int32x2_t v32 = (int32x2_t)v60;
      if ((v27 & 1) == 0) {
        goto LABEL_21;
      }
      goto LABEL_17;
    }
  }
  ++*(_DWORD *)(v28 + 104);
  uint64_t v48 = *(void *)&v26[4]._os_unfair_lock_opaque;
  uint64_t v23 = this + 4;
  int32x2_t v32 = (int32x2_t)v31;
  if (!v48)
  {
LABEL_17:
    uint32x2_t v33 = (uint32x2_t)vcgt_s32((int32x2_t)0x80000000800, v32);
    if ((vpmax_u32(v33, v33).u32[0] & 0x80000000) != 0)
    {
      if (v32.i32[1] <= v32.i32[0]) {
        v32.i32[1] *= 2;
      }
      else {
        v32.i32[0] *= 2;
      }
    }
    goto LABEL_21;
  }
  unsigned int add_explicit = atomic_fetch_add_explicit((atomic_uint *volatile)&this[14], 1u, memory_order_relaxed);
  atomic_fetch_add_explicit(a2 + 6, 1u, memory_order_relaxed);
  atomic_fetch_add_explicit(a2 + 2, 1u, memory_order_relaxed);
  unint64_t v39 = v73;
  unsigned int v40 = *(_DWORD *)(v48 + 80);
  if (*(_DWORD *)(v48 + 84) < v40 + 1)
  {
    RB::vector<RB::BinAllocator::Shelf,0ul,unsigned int>::reserve_slow(v48 + 72, v40 + 1);
    unsigned int v40 = *(_DWORD *)(v48 + 80);
  }
  unsigned int v41 = add_explicit + 1;
  uint64_t v42 = *(void *)(v48 + 72) + 32 * v40;
  *(void *)uint64_t v42 = a2;
  *(void *)(v42 + 8) = v39;
  *(double *)(v42 + 16) = a9;
  *(_DWORD *)(v42 + 24) = v41;
  *(unsigned char *)(v42 + 28) = (a7 & 2) != 0;
  *(unsigned char *)(v42 + 29) = 0;
  ++*(_DWORD *)(v48 + 80);
  LOBYTE(this[15]._os_unfair_lock_opaque) = 1;
  os_unfair_lock_unlock(this + 4);
  uint64_t v70 = 0;
  id v67 = (id)v48;
  unint64_t v68 = v73;
  double v69 = a9;
  unsigned int v71 = v41;
  BOOL v72 = (a7 & 2) != 0;
  os_unfair_lock_lock((os_unfair_lock_t)(v48 + 112));
  id v43 = a6;
  unint64_t v44 = v73;
  if ((a7 & 8) != 0)
  {
    unint64_t v49 = (void (**)(void, void))[v58 copy];
    unint64_t v46 = this + 4;
    atomic_fetch_add_explicit(a2 + 2, 1u, memory_order_relaxed);
    BOOL v74 = a2;
    id v75 = v67;
    unint64_t v76 = v68;
    double v77 = v69;
    uint64_t v78 = 0;
    unsigned int v79 = v71;
    BOOL v80 = v72;
    id v67 = 0;
    unint64_t v58 = v49;
    id v81 = v49;
    id v82 = v43;
    *(void *)&long long v83 = v44;
    *((double *)&v83 + 1) = a9;
    *(__n128 *)&v84[8] = a11;
    unsigned int v50 = *(_DWORD *)(v48 + 160);
    unsigned int v51 = *(_DWORD *)(v48 + 164);
    uint64_t v52 = a2;
    *(_DWORD *)&v84[24] = v41;
    *(_DWORD *)&v84[28] = a7;
    if (v51 < v50 + 1)
    {
      RB::vector<RB::SharedSurface::AsyncUpdate,0ul,unsigned int>::reserve_slow(v48 + 152, v50 + 1);
      unsigned int v50 = *(_DWORD *)(v48 + 160);
      uint64_t v52 = v74;
      unint64_t v46 = this + 4;
    }
    uint64_t v53 = *(void *)(v48 + 152) + 144 * v50;
    *(void *)uint64_t v53 = v52;
    BOOL v74 = 0;
    *(void *)(v53 + 8) = v75;
    *(void *)(v53 + 16) = v76;
    *(double *)(v53 + 24) = v77;
    *(void *)(v53 + 32) = 0;
    *(_DWORD *)(v53 + 56) = v79;
    *(unsigned char *)(v53 + 60) = v80;
    id v75 = 0;
    *(void *)(v53 + 64) = v81;
    id v81 = 0;
    *(void *)(v53 + 80) = v82;
    id v82 = 0;
    long long v54 = v83;
    long long v55 = *(_OWORD *)v84;
    *(_OWORD *)(v53 + 120) = *(_OWORD *)&v84[16];
    *(_OWORD *)(v53 + 104) = v55;
    *(_OWORD *)(v53 + 88) = v54;
    ++*(_DWORD *)(v48 + 160);

    RB::SharedSubsurface::~SharedSubsurface(&v75);
    uint64_t v56 = v74;
    if (v74 && atomic_fetch_add_explicit(v74 + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(atomic_uint *))(*(void *)v56 + 8))(v56);
    }
    atomic_fetch_add_explicit(a2 + 8, 1u, memory_order_relaxed);
  }
  else
  {
    unsigned int v45 = *(_DWORD *)(v48 + 128);
    unint64_t v46 = this + 4;
    if (*(_DWORD *)(v48 + 132) < v45 + 1)
    {
      RB::vector<RB::SharedSurface::Update,0ul,unsigned int>::reserve_slow(v48 + 120, v45 + 1);
      unsigned int v45 = *(_DWORD *)(v48 + 128);
    }
    unint64_t v47 = (__n128 *)(*(void *)(v48 + 120) + ((unint64_t)v45 << 6));
    v47->n128_u64[0] = (unint64_t)v43;
    v47->n128_u64[1] = v44;
    v47[1].n128_f64[0] = a9;
    v47[2] = a11;
    v47[3].n128_u32[0] = v41;
    v47[3].n128_u32[1] = a7;
    ++*(_DWORD *)(v48 + 128);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)(v48 + 112));
  if ((a7 & 8) != 0)
  {
    os_unfair_lock_lock(v46);
    if (BYTE1(this[15]._os_unfair_lock_opaque))
    {
      os_unfair_lock_unlock(v46);
    }
    else
    {
      BYTE1(this[15]._os_unfair_lock_opaque) = 1;
      os_unfair_lock_unlock(v46);
      v63[0] = MEMORY[0x263EF8330];
      v63[1] = 3221225472;
      long long v64 = ___ZN2RB18SharedSurfaceGroup14add_subsurfaceERNS_19SharedSurfaceClientE14MTLPixelFormatNS_10ColorSpaceEjDv2_ifPU33objcproto22_RBDisplayListContents11objc_objectjDv4_fU13block_pointerFvRNS_16SharedSubsurfaceEE_block_invoke;
      uint64_t v65 = &__block_descriptor_40_e5_v8__0l;
      int64_t v66 = this;
      if ([MEMORY[0x263F158F8] currentPhase] + 1 >= 4) {
        v64((RB::_anonymous_namespace_ *)v63);
      }
      else {
        [MEMORY[0x263F158F8] addCommitHandler:v63 forPhase:3];
      }
    }
  }
  else
  {
    ((void (**)(void, id *))v58)[2](v58, &v67);
  }
  RB::SharedSubsurface::~SharedSubsurface(&v67);
  return v48;
}

void sub_214131384(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_unfair_lock_t lock, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,id a31)
{
  RB::SharedSurface::AsyncUpdate::~AsyncUpdate(&a31);

  os_unfair_lock_unlock(v31);
  RB::SharedSubsurface::~SharedSubsurface(&a23);
  _Unwind_Resume(a1);
}

void *RB::vector<RB::BinAllocator::Shelf,0ul,unsigned int>::reserve_slow(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1);
  }
  uint64_t result = RB::details::realloc_vector<unsigned int,32ul>(*(void **)a1, (_DWORD *)(a1 + 12), v3);
  *(void *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,32ul>(void *a1, _DWORD *a2, unsigned int a3)
{
  uint64_t v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(32 * a3);
    size_t v6 = v5 >> 5;
    if (*a2 != (v5 >> 5))
    {
      int v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7) {
        RB::precondition_failure((RB *)"allocation failure", v8);
      }
      uint64_t v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

uint64_t RB::BinAllocator::alloc(int32x2_t *a1, _DWORD *a2, int32x2_t a3)
{
  uint32x2_t v3 = (uint32x2_t)vcgt_s32(a3, a1[1]);
  if ((vpmax_u32(v3, v3).u32[0] & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v5 = a1[3].u32[0];
  if (v5)
  {
    unint64_t v6 = 0;
    uint64_t v36 = (uint64_t)&a1[2];
    __int32 v7 = a3.i32[1];
    unsigned int v8 = (a3.i32[1] + 15) & 0xFFFFFFF0;
    int v9 = a3.i32[1] >> 1;
    __int32 v10 = a3.i32[0];
    int v11 = a3.i16[0];
    long long v12 = 0uLL;
    int32x2_t v13 = a1[2];
    unsigned int v14 = v5;
    __int32 v38 = a3.i32[0];
    int v39 = a3.i32[1] >> 1;
    while (1)
    {
      unint64_t v15 = (__int16 *)(*(void *)&v13 + 32 * v6);
      int v16 = (unsigned __int16)v15[3];
      if (v16 == (unsigned __int16)v15[1])
      {
        int v17 = v15[2] - v8;
        if (v17 >= v9)
        {
          __int16 v18 = *v15;
          *v15 += v8;
          void v15[2] = v17;
          long long v40 = v12;
          if (a1[3].i32[1] < v14 + 1)
          {
            RB::vector<RB::BinAllocator::Shelf,0ul,unsigned int>::reserve_slow(v36, v14 + 1);
            int32x2_t v13 = a1[2];
            unsigned int v14 = a1[3].u32[0];
          }
          BOOL v19 = v14 > v6;
          unint64_t v20 = v14 - v6;
          if (v19) {
            memmove((void *)(*(void *)&v13 + 32 * v6 + 32), (const void *)(*(void *)&v13 + 32 * v6), 32 * v20);
          }
          unint64_t v21 = *(void *)&v13 + 32 * v6;
          a3.i16[0] = v16;
          a3.i16[1] = v8;
          int16x4_t v22 = vdup_lane_s16((int16x4_t)a3, 0);
          v22.i16[1] = v8;
          *(_WORD *)unint64_t v21 = v18;
          *(int16x4_t *)(v21 + 2) = v22;
          *(void *)(v21 + 24) = 0;
          *(void *)(v21 + 16) = 0;
          RB::vector<RB::Animation::TermOrArg,0ul,unsigned int>::reserve_slow(v21 + 16, 1u);
          *(_DWORD *)(*(void *)(v21 + 16) + 4 * (*(_DWORD *)(v21 + 24))++) = v16 << 16;
          unsigned int v14 = a1[3].i32[0] + 1;
          a1[3].i32[0] = v14;
          int32x2_t v13 = a1[2];
          unint64_t v15 = (__int16 *)(*(void *)&v13 + 32 * v6);
          long long v12 = v40;
          __int32 v10 = v38;
          int v9 = v39;
        }
      }
      __int32 v23 = v15[2];
      unsigned int v24 = v23 - v7;
      if (v23 - v7 >= 0 && (v24 < 0x11 || (int)(v24 * v10) < 4096 || v15[3] == v15[1]) && v15[4] >= v11)
      {
        uint64_t v25 = *((unsigned int *)v15 + 6);
        if (v25)
        {
          uint64_t v26 = 0;
          __int16 v27 = 0;
          uint64_t v28 = *((void *)v15 + 2);
          while (1)
          {
            uint64_t v29 = (__int16 *)(v28 + v26);
            int v30 = *(__int16 *)(v28 + v26 + 2);
            if (v30 >= v11) {
              break;
            }
            if (v27 <= v30) {
              __int16 v27 = *(_WORD *)(v28 + v26 + 2);
            }
            v26 += 4;
            if (4 * v25 == v26) {
              goto LABEL_25;
            }
          }
          int v32 = *v29;
          v29[1] = v30 - v11;
          if (v30 == v11)
          {
            uint64_t v33 = (v25 - 1);
            *((_DWORD *)v15 + 6) = v33;
            if (v33 != v26 >> 2) {
              memmove((void *)(v28 + 4 * (v26 >> 2)), (const void *)(v28 + 4 * (v26 >> 2) + 4), 4 * (v33 - (v26 >> 2)));
            }
          }
          else
          {
            *(_WORD *)(v28 + v26) = v32 + v11;
          }
          __int16 v34 = v15[3] - v11;
          _OWORD v15[3] = v34;
          v15[4] = v34;
          *a2 = v32;
          LODWORD(v35) = v32;
          HIDWORD(v35) = *v15;
          *(void *)a2 = v35;
          return 1;
        }
        __int16 v27 = 0;
LABEL_25:
        v15[4] = v27;
      }
      a3.i32[0] = v15[4];
      a3.i32[1] = v23;
      *(int32x2_t *)&long long v12 = vmax_s32(*(int32x2_t *)&v12, a3);
      if (++v6 == v5) {
        goto LABEL_34;
      }
    }
  }
  *(void *)&long long v12 = 0;
LABEL_34:
  uint64_t result = 0;
  a1[1] = (int32x2_t)v12;
  return result;
}

void RB::SharedSubsurface::~SharedSubsurface(id *this)
{
}

void sub_2141317E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void RB::SharedSubsurface::reset(RB::SharedSubsurface *this)
{
  if (*(void *)this)
  {
    unsigned int v2 = *(os_unfair_lock_s **)(*(void *)this + 16);
    if (v2) {
      RB::SharedSurfaceGroup::remove_subsurface(v2, this, 1);
    }
  }
}

void *RB::vector<RB::Animation::TermOrArg,0ul,unsigned int>::reserve_slow(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1);
  }
  uint64_t result = RB::details::realloc_vector<unsigned int,4ul>(*(void **)a1, (_DWORD *)(a1 + 12), v3);
  *(void *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,4ul>(void *a1, _DWORD *a2, unsigned int a3)
{
  uint64_t v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(4 * a3);
    size_t v6 = v5 >> 2;
    if (*a2 != (v5 >> 2))
    {
      __int32 v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7) {
        RB::precondition_failure((RB *)"allocation failure", v8);
      }
      uint64_t v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

void *RB::vector<RB::SharedSurface::Update,0ul,unsigned int>::reserve_slow(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1);
  }
  uint64_t result = RB::details::realloc_vector<unsigned int,64ul>(*(void **)a1, (_DWORD *)(a1 + 12), v3);
  *(void *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,64ul>(void *a1, _DWORD *a2, unsigned int a3)
{
  uint64_t v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size((unint64_t)a3 << 6);
    size_t v6 = v5 >> 6;
    if (*a2 != (v5 >> 6))
    {
      __int32 v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7) {
        RB::precondition_failure((RB *)"allocation failure", v8);
      }
      uint64_t v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

uint64_t RB::SharedSurfaceGroup::wait_for_allocations(RB::SharedSurfaceGroup *this, RB::SharedSurfaceClient *a2)
{
  unsigned int v3 = 0;
  uint64_t v4 = (os_unfair_lock_s *)((char *)this + 16);
  unsigned int v24 = (char *)this + 24;
  int v5 = 1;
  useconds_t v21 = 100;
  lock = (os_unfair_lock_s *)((char *)this + 16);
  while (1)
  {
    int v6 = *((_DWORD *)a2 + 7);
    if ((v6 + *((_DWORD *)a2 + 6)) < 3)
    {
      int v18 = 1;
      int v17 = 1;
      return v18 & v17;
    }
    if (((v6 == 0) & ~v5) != 0) {
      break;
    }
    if (v5)
    {
      unsigned int v23 = v3;
    }
    else
    {
      usleep(v21);
      unsigned int v23 = v21 + v3;
      v21 += v21 >> 1;
    }
    os_unfair_lock_lock(v4);
    for (uint64_t i = *((void *)this + 4); (char *)i != v24; uint64_t i = *(void *)(i + 8))
    {
      uint64_t v8 = *(void *)(i + 16);
      if (*(_DWORD *)(v8 + 96))
      {
        unsigned int v9 = 0;
        do
        {
          uint64_t v10 = *(void *)(v8 + 88);
          uint64_t v11 = v10 + 56 * v9;
          if (*(RB::SharedSurfaceClient **)v11 == a2
            && RB::SharedSurfaceTimestamp::test((RB::SharedSurfaceTimestamp *)(v10 + 56 * v9 + 32)))
          {
            atomic_fetch_add_explicit((atomic_uint *volatile)(*(void *)v11 + 28), 0xFFFFFFFF, memory_order_relaxed);
            uint64_t v13 = v10 + 56 * v9;
            v12.n128_u64[0] = *(void *)(v13 + 16);
            RB::BinAllocator::dealloc(v8 + 32, *(double *)(v13 + 8), v12);
            --*(_DWORD *)(v8 + 104);
            uint64_t v14 = *(void *)(v8 + 88) + 56 * v9;

            unint64_t v15 = *(atomic_uint **)v14;
            if (*(void *)v14 && atomic_fetch_add_explicit(v15 + 2, 0xFFFFFFFF, memory_order_release) == 1)
            {
              __dmb(9u);
              (*(void (**)(atomic_uint *))(*(void *)v15 + 8))(v15);
            }
            uint64_t v16 = (*(_DWORD *)(v8 + 96) - 1);
            *(_DWORD *)(v8 + 96) = v16;
            if (v9 != v16) {
              memmove((void *)v14, (const void *)(v14 + 56), 56 * (v16 - v9));
            }
          }
          else
          {
            ++v9;
          }
        }
        while (v9 < *(_DWORD *)(v8 + 96));
      }
    }
    uint64_t v4 = lock;
    os_unfair_lock_unlock(lock);
    int v5 = 0;
    int v18 = 0;
    unsigned int v3 = v23;
    if (v23 >= 0x3D090) {
      return v18 & v17;
    }
  }
  int v17 = 0;
  int v18 = 1;
  return v18 & v17;
}

void sub_214131C08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_unfair_lock_t lock)
{
}

void sub_214131DB0(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    os_unfair_lock_unlock(v2);
  }
  _Unwind_Resume(exception_object);
}

void RB::SharedSurfaceGroup::schedule_updates(RB::SharedSurfaceGroup *this)
{
  unint64_t v1 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) - 224;
  if (*((void *)this + 6) != v1)
  {
    if ([MEMORY[0x263F158F8] currentPhase] + 1 >= 4)
    {
      RB::SharedSurfaceGroup::render_updates(this);
    }
    else
    {
      *((void *)this + 6) = v1;
      unsigned int v3 = *(atomic_uint **)this;
      if (v3) {
        atomic_fetch_add_explicit(v3 + 2, 1u, memory_order_relaxed);
      }
      v5[0] = MEMORY[0x263EF8330];
      v5[1] = 3321888768;
      void v5[2] = ___ZN2RB18SharedSurfaceGroup16schedule_updatesEv_block_invoke;
      _OWORD v5[3] = &__block_descriptor_40_e8_32c38_ZTSN2RB14refcounted_ptrINS_6DeviceEEE_e5_v8__0l;
      if (v3) {
        atomic_fetch_add_explicit(v3 + 2, 1u, memory_order_relaxed);
      }
      int v6 = v3;
      [MEMORY[0x263F158F8] addCommitHandler:v5 forPhase:3];
      uint64_t v4 = v6;
      if (v6 && atomic_fetch_add_explicit(v6 + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        (*(void (**)(atomic_uint *))(*(void *)v4 + 8))(v4);
        if (!v3) {
          return;
        }
      }
      else if (!v3)
      {
        return;
      }
      if (atomic_fetch_add_explicit(v3 + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        (*(void (**)(atomic_uint *))(*(void *)v3 + 8))(v3);
      }
    }
  }
}

void sub_214131F68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a14) {
    RB::SharedSurfaceGroup::schedule_updates(a14);
  }
  RB::SharedSurfaceGroup::schedule_updates(v14 == 0, v14);
  _Unwind_Resume(a1);
}

uint64_t RB::SharedSubsurface::contents(RB::SharedSubsurface *this)
{
  if (*(void *)this) {
    return *(void *)(*(void *)(*(void *)this + 24) + 48);
  }
  else {
    return 0;
  }
}

id RB::SharedSurfaceTimestamp::attach(uint64_t a1, id a2)
{
  id result = *(id *)a1;
  if (result != a2)
  {

    id result = a2;
    *(_DWORD *)(a1 + 16) = 0;
    *(void *)a1 = result;
    *(void *)(a1 + 8) = 0;
  }
  return result;
}

RB::SharedSurface *RB::SharedSurface::SharedSurface(RB::SharedSurface *this, RB::SharedSurfaceGroup *a2, RB::Surface *a3, float a4)
{
  *((_DWORD *)this + 2) = 1;
  *(void *)this = &unk_26C4ED130;
  *((void *)this + 2) = a2;
  *((void *)this + 3) = a3;
  int v6 = (RB *)RB::BinAllocator::BinAllocator((char *)this + 32, *((double *)a3 + 3));
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((float *)this + 16) = a4;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 100) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(void *)((char *)this + 165) = 0;
  *((_DWORD *)this + 42) = (uint64_t)(RB::current_time_seconds(v6) * 60.0 + 0.5);
  return this;
}

void sub_2141322C8(_Unwind_Exception *a1)
{
  RB::vector<RB::SharedSurface::AsyncUpdate,0ul,unsigned int>::~vector(v2 + 152);
  RB::vector<RB::SharedSurface::Copy,0ul,unsigned int>::~vector(v2 + 136);
  RB::vector<RB::SharedSurface::Update,0ul,unsigned int>::~vector(v4);
  RB::vector<RB::SharedSurface::Remove,0ul,unsigned int>::~vector(v2 + 88);
  RB::vector<RB::SharedSurface::Allocation,0ul,unsigned int>::~vector(v3);
  RB::BinAllocator::~BinAllocator(v1);
  _Unwind_Resume(a1);
}

void RB::SharedSurfaceGroup::remove_subsurface(os_unfair_lock_s *this, RB::SharedSubsurface *a2, int a3)
{
  if (*(void *)a2)
  {
    if (a3)
    {
      int v6 = (void *)*((void *)a2 + 3);
      if (v6)
      {
        *((_DWORD *)a2 + 10) = [v6 commitId] + 1;
        *((CFTimeInterval *)a2 + 4) = CACurrentMediaTime() + 0.0666666667;
      }
    }
    os_unfair_lock_lock(this + 4);
    uint64_t v8 = *(void *)a2;
    *(void *)a2 = 0;
    int v9 = *(_DWORD *)(v8 + 80);
    if (v9)
    {
      uint64_t v10 = 0;
      uint64_t v11 = *(void *)(v8 + 72);
      int v12 = *(_DWORD *)(v8 + 80);
      while (*(_DWORD *)(v11 + v10 + 24) != *((_DWORD *)a2 + 12))
      {
        v10 += 32;
        if (!--v12) {
          goto LABEL_9;
        }
      }
      uint64_t v13 = *(atomic_uint **)(v11 + v10);
      *(void *)(v11 + v10) = 0;
      uint64_t v14 = *(void *)(v8 + 72);
      unint64_t v15 = (uint64_t *)(v14 + v10);
      uint64_t v16 = (uint64_t *)(v14 + 32 * (v9 - 1));
      uint64_t v17 = *v15;
      *unint64_t v15 = 0;
      *(_OWORD *)uint64_t v25 = *(_OWORD *)(v15 + 1);
      *(void *)&v25[14] = *(uint64_t *)((char *)v15 + 22);
      *unint64_t v15 = *v16;
      long long v18 = *(_OWORD *)(v16 + 1);
      *(uint64_t *)((char *)v15 + 22) = *(uint64_t *)((char *)v16 + 22);
      *(_OWORD *)(v15 + 1) = v18;
      *uint64_t v16 = v17;
      *(uint64_t *)((char *)v16 + 22) = *(void *)&v25[14];
      *(_OWORD *)(v16 + 1) = *(_OWORD *)v25;
      LODWORD(v16) = *(_DWORD *)(v8 + 80) - 1;
      *(_DWORD *)(v8 + 80) = v16;
      BOOL v19 = *(atomic_uint **)(*(void *)(v8 + 72) + 32 * v16);
      if (v19 && atomic_fetch_add_explicit(v19 + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        (*(void (**)(atomic_uint *))(*(void *)v19 + 8))(v19);
      }
    }
    else
    {
LABEL_9:
      uint64_t v13 = 0;
    }
    atomic_fetch_add_explicit(v13 + 6, 0xFFFFFFFF, memory_order_relaxed);
    if (a3)
    {
      atomic_fetch_add_explicit(v13 + 7, 1u, memory_order_relaxed);
      *(void *)&v25[8] = *((void *)a2 + 1);
      *(void *)&v25[16] = *((void *)a2 + 2);
      int v26 = *((_DWORD *)a2 + 12);
      uint64_t v20 = *((void *)a2 + 3);
      *((void *)a2 + 3) = 0;
      uint64_t v21 = *((void *)a2 + 4);
      int v22 = *((_DWORD *)a2 + 10);
      unsigned int v23 = *(_DWORD *)(v8 + 96);
      if (*(_DWORD *)(v8 + 100) < v23 + 1)
      {
        RB::vector<RB::SharedSurface::Remove,0ul,unsigned int>::reserve_slow(v8 + 88, v23 + 1);
        unsigned int v23 = *(_DWORD *)(v8 + 96);
      }
      uint64_t v24 = *(void *)(v8 + 88) + 56 * v23;
      *(void *)uint64_t v24 = v13;
      *(void *)uint64_t v25 = 0;
      *(_OWORD *)(v24 + 8) = *(_OWORD *)&v25[8];
      *(_DWORD *)(v24 + 24) = v26;
      *(void *)(v24 + 32) = v20;
      *(void *)(v24 + 40) = v21;
      *(_DWORD *)(v24 + 48) = v22;
      ++*(_DWORD *)(v8 + 96);

      uint64_t v13 = 0;
    }
    else
    {
      v7.n128_u64[0] = *((void *)a2 + 2);
      RB::BinAllocator::dealloc(v8 + 32, *((double *)a2 + 1), v7);
      --*(_DWORD *)(v8 + 104);
    }
    LOBYTE(this[15]._os_unfair_lock_opaque) = 1;
    objc_msgSend(*(id *)(*(void *)&this->_os_unfair_lock_opaque + 16), "collectResources", *(void *)v25);
    if (v13 && atomic_fetch_add_explicit(v13 + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(atomic_uint *))(*(void *)v13 + 8))(v13);
    }
    os_unfair_lock_unlock(this + 4);
  }
}

void sub_2141325F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  RB::SharedSurface::Remove::~Remove((id *)&a9);
  os_unfair_lock_unlock(v9);
  _Unwind_Resume(a1);
}

void RB::SharedSurfaceGroup::commit_removed(uint64_t a1, uint64_t **a2)
{
  lock = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  unsigned int v6 = *((_DWORD *)a2 + 2);
  if (v6)
  {
    __n128 v7 = *a2;
    uint64_t v25 = (uint64_t)&(*a2)[3 * v6];
    do
    {
      uint64_t v8 = *v7;
      uint64_t v9 = *((unsigned int *)v7 + 4);
      *(_DWORD *)(*v7 + 108) -= v9;
      if (v9)
      {
        uint64_t v10 = 56 * v9;
        uint64_t v11 = v7[1] + 32;
        do
        {
          if (*(void *)v11)
          {
            unsigned int v12 = *(_DWORD *)(v8 + 96);
            if (*(_DWORD *)(v8 + 100) < v12 + 1)
            {
              RB::vector<RB::SharedSurface::Remove,0ul,unsigned int>::reserve_slow(v8 + 88, v12 + 1);
              unsigned int v12 = *(_DWORD *)(v8 + 96);
            }
            uint64_t v13 = *(void *)(v8 + 88) + 56 * v12;
            *(void *)(v13 + 48) = 0;
            *(_OWORD *)(v13 + 16) = 0u;
            *(_OWORD *)(v13 + 32) = 0u;
            *(_OWORD *)uint64_t v13 = 0u;
            LODWORD(v13) = *(_DWORD *)(v8 + 96);
            *(_DWORD *)(v8 + 96) = v13 + 1;
            uint64_t v14 = *(void *)(v8 + 88) + 56 * v13;
            uint64_t v15 = *(void *)(v11 - 32);
            *(void *)(v11 - 32) = 0;
            long long v26 = *(_OWORD *)(v11 - 24);
            int v27 = *(_DWORD *)(v11 - 8);
            uint64_t v16 = *(void *)v11;
            *(void *)uint64_t v11 = 0;
            uint64_t v17 = *(void *)(v11 + 8);
            int v18 = *(_DWORD *)(v11 + 16);
            *(void *)(v11 - 32) = *(void *)v14;
            *(void *)uint64_t v14 = 0;
            long long v19 = *(_OWORD *)(v14 + 8);
            *(_DWORD *)(v11 - 8) = *(_DWORD *)(v14 + 24);
            *(_OWORD *)(v11 - 24) = v19;
            uint64_t v20 = *(void *)v11;
            *(void *)uint64_t v11 = *(void *)(v14 + 32);
            *(void *)(v14 + 32) = v20;
            *(void *)(v11 + 8) = *(void *)(v14 + 40);
            *(_DWORD *)(v11 + 16) = *(_DWORD *)(v14 + 48);
            uint64_t v21 = *(atomic_uint **)v14;
            *(void *)uint64_t v14 = v15;
            *(_OWORD *)(v14 + 8) = v26;
            *(_DWORD *)(v14 + 24) = v27;
            int v22 = *(void **)(v14 + 32);
            *(void *)(v14 + 32) = v16;
            *(void *)(v14 + 40) = v17;
            *(_DWORD *)(v14 + 48) = v18;

            if (v21 && atomic_fetch_add_explicit(v21 + 2, 0xFFFFFFFF, memory_order_release) == 1)
            {
              __dmb(9u);
              uint64_t v4 = (RB *)(*(uint64_t (**)(atomic_uint *))(*(void *)v21 + 8))(v21);
            }
          }
          else
          {
            atomic_fetch_add_explicit((atomic_uint *volatile)(*(void *)(v11 - 32) + 28), 0xFFFFFFFF, memory_order_relaxed);
            v5.n128_u64[0] = *(void *)(v11 - 16);
            RB::BinAllocator::dealloc(v8 + 32, *(double *)(v11 - 24), v5);
            --*(_DWORD *)(v8 + 104);
            *(unsigned char *)(a1 + 60) = 1;
          }
          v11 += 56;
          v10 -= 56;
        }
        while (v10);
      }
      v7 += 3;
    }
    while (v7 != (uint64_t *)v25);
  }
  double v23 = RB::current_time_seconds(v4);
  RB::SharedSurfaceGroup::prune_caches_locked(a1, (uint64_t)(v23 * 60.0 + 0.5));
  os_unfair_lock_unlock(lock);
}

void sub_2141329A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_unfair_lock_t lock)
{
}

void *RB::vector<RB::SharedSurface::Remove,0ul,unsigned int>::reserve_slow(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1);
  }
  id result = RB::details::realloc_vector<unsigned int,56ul>(*(void **)a1, (_DWORD *)(a1 + 12), v3);
  *(void *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,56ul>(void *a1, _DWORD *a2, unsigned int a3)
{
  uint64_t v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(56 * a3);
    unint64_t v6 = v5 / 0x38;
    if (*a2 != (v5 / 0x38))
    {
      __n128 v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7) {
        RB::precondition_failure((RB *)"allocation failure", v8);
      }
      uint64_t v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

void sub_214132BDC(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x80C40B8603338);
  _Unwind_Resume(a1);
}

__n128 _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEvT1_SG_SG_SG_S9_(unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4)
{
  _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEjT1_SG_SG_S9_(a1, a2, a3);
  if (*a4 < (unint64_t)*a3)
  {
    uint64_t v9 = *((void *)a3 + 4);
    __n128 result = *(__n128 *)a3;
    long long v10 = *((_OWORD *)a3 + 1);
    unsigned int v11 = a4[8];
    long long v12 = *((_OWORD *)a4 + 1);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *((_OWORD *)a3 + 1) = v12;
    a3[8] = v11;
    *(__n128 *)a4 = result;
    *((_OWORD *)a4 + 1) = v10;
    a4[8] = v9;
    if (*a3 < (unint64_t)*a2)
    {
      uint64_t v13 = *((void *)a2 + 4);
      __n128 result = *(__n128 *)a2;
      long long v14 = *((_OWORD *)a2 + 1);
      unsigned int v15 = a3[8];
      long long v16 = *((_OWORD *)a3 + 1);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_OWORD *)a2 + 1) = v16;
      a2[8] = v15;
      *(__n128 *)a3 = result;
      *((_OWORD *)a3 + 1) = v14;
      a3[8] = v13;
      if (*a2 < (unint64_t)*a1)
      {
        uint64_t v17 = *((void *)a1 + 4);
        __n128 result = *(__n128 *)a1;
        long long v18 = *((_OWORD *)a1 + 1);
        unsigned int v19 = a2[8];
        long long v20 = *((_OWORD *)a2 + 1);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *((_OWORD *)a1 + 1) = v20;
        a1[8] = v19;
        *(__n128 *)a2 = result;
        *((_OWORD *)a2 + 1) = v18;
        a2[8] = v17;
      }
    }
  }
  return result;
}

void _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsELb0EEEvT1_SG_S9_NS_15iterator_traitsISG_E15difference_typeEb(unsigned int *a1, unsigned int *a2, uint64_t a3, char a4)
{
  while (2)
  {
    long long v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = (char *)a2 - (char *)v10;
          unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * (((char *)a2 - (char *)v10) >> 3);
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                unsigned int v47 = *(a2 - 10);
                unint64_t v46 = a2 - 10;
                if (v47 < (unint64_t)*v10)
                {
                  uint64_t v143 = *((void *)v10 + 4);
                  long long v127 = *(_OWORD *)v10;
                  long long v136 = *((_OWORD *)v10 + 1);
                  long long v48 = *(_OWORD *)v46;
                  long long v49 = *((_OWORD *)v46 + 1);
                  v10[8] = v46[8];
                  *(_OWORD *)long long v10 = v48;
                  *((_OWORD *)v10 + 1) = v49;
                  v46[8] = v143;
                  *(_OWORD *)unint64_t v46 = v127;
                  *((_OWORD *)v46 + 1) = v136;
                }
                break;
              case 3uLL:
                _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEjT1_SG_SG_S9_(v10, v10 + 10, a2 - 10);
                break;
              case 4uLL:
                _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEvT1_SG_SG_SG_S9_(v10, v10 + 10, v10 + 20, a2 - 10);
                break;
              case 5uLL:
                unsigned int v50 = v10 + 10;
                unsigned int v51 = v10 + 20;
                uint64_t v52 = v10 + 30;
                _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEvT1_SG_SG_SG_S9_(v10, v10 + 10, v10 + 20, v10 + 30);
                unsigned int v54 = *(a2 - 10);
                uint64_t v53 = a2 - 10;
                if (v54 < (unint64_t)v10[30])
                {
                  long long v55 = *(_OWORD *)v52;
                  long long v137 = *(_OWORD *)(v10 + 34);
                  unsigned int v56 = *((void *)v10 + 19);
                  long long v58 = *(_OWORD *)v53;
                  long long v57 = *((_OWORD *)v53 + 1);
                  v10[38] = v53[8];
                  *(_OWORD *)uint64_t v52 = v58;
                  *(_OWORD *)(v10 + 34) = v57;
                  v53[8] = v56;
                  *(_OWORD *)uint64_t v53 = v55;
                  *((_OWORD *)v53 + 1) = v137;
                  if (*v52 < (unint64_t)*v51)
                  {
                    uint64_t v59 = *((void *)v10 + 14);
                    long long v61 = *(_OWORD *)v51;
                    long long v60 = *((_OWORD *)v10 + 6);
                    long long v62 = *(_OWORD *)(v10 + 34);
                    *(_OWORD *)unsigned int v51 = *(_OWORD *)v52;
                    *((_OWORD *)v10 + 6) = v62;
                    v10[28] = v10[38];
                    *(_OWORD *)uint64_t v52 = v61;
                    *(_OWORD *)(v10 + 34) = v60;
                    v10[38] = v59;
                    if (*v51 < (unint64_t)*v50)
                    {
                      uint64_t v63 = *((void *)v10 + 9);
                      long long v65 = *(_OWORD *)v50;
                      long long v64 = *(_OWORD *)(v10 + 14);
                      long long v66 = *((_OWORD *)v10 + 6);
                      *(_OWORD *)unsigned int v50 = *(_OWORD *)v51;
                      *(_OWORD *)(v10 + 14) = v66;
                      v10[18] = v10[28];
                      *(_OWORD *)unsigned int v51 = v65;
                      *((_OWORD *)v10 + 6) = v64;
                      v10[28] = v63;
                      if (v10[10] < (unint64_t)*v10)
                      {
                        uint64_t v144 = *((void *)v10 + 4);
                        long long v128 = *(_OWORD *)v10;
                        long long v138 = *((_OWORD *)v10 + 1);
                        long long v67 = *(_OWORD *)(v10 + 14);
                        *(_OWORD *)long long v10 = *(_OWORD *)v50;
                        *((_OWORD *)v10 + 1) = v67;
                        v10[8] = v10[18];
                        *(_OWORD *)unsigned int v50 = v128;
                        *(_OWORD *)(v10 + 14) = v138;
                        v10[18] = v144;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 959)
          {
            unint64_t v68 = v10 + 10;
            BOOL v70 = v10 == a2 || v68 == a2;
            if (a4)
            {
              if (!v70)
              {
                uint64_t v71 = 0;
                BOOL v72 = v10;
                do
                {
                  unint64_t v73 = v68;
                  unint64_t v74 = v72[10] | ((unint64_t)*((unsigned __int16 *)v72 + 22) << 32);
                  unint64_t v75 = v72[10];
                  if (v75 < *v72)
                  {
                    *(_OWORD *)uint64_t v129 = *(_OWORD *)((char *)v72 + 46);
                    *(_OWORD *)&v129[16] = *(_OWORD *)((char *)v72 + 62);
                    uint64_t v76 = v71;
                    while (1)
                    {
                      double v77 = (char *)v10 + v76;
                      long long v78 = *(_OWORD *)((char *)v10 + v76 + 16);
                      *(_OWORD *)(v77 + 40) = *(_OWORD *)((char *)v10 + v76);
                      *(_OWORD *)(v77 + 56) = v78;
                      *((_DWORD *)v77 + 18) = *(unsigned int *)((char *)v10 + v76 + 32);
                      if (!v76) {
                        break;
                      }
                      v76 -= 40;
                      if (v75 >= *((unsigned int *)v77 - 10))
                      {
                        uint64_t v79 = (uint64_t)v10 + v76 + 40;
                        goto LABEL_81;
                      }
                    }
                    uint64_t v79 = (uint64_t)v10;
LABEL_81:
                    *(_DWORD *)uint64_t v79 = v74;
                    *(_WORD *)(v79 + 4) = WORD2(v74);
                    *(_OWORD *)(v79 + 20) = *(_OWORD *)&v129[14];
                    *(_OWORD *)(v79 + 6) = *(_OWORD *)v129;
                  }
                  unint64_t v68 = v73 + 10;
                  v71 += 40;
                  BOOL v72 = v73;
                }
                while (v73 + 10 != a2);
              }
            }
            else if (!v70)
            {
              do
              {
                uint64_t v115 = v68;
                unint64_t v116 = a1[10] | ((unint64_t)*((unsigned __int16 *)a1 + 22) << 32);
                unint64_t v117 = a1[10];
                if (v117 < *a1)
                {
                  *(_OWORD *)uint64_t v132 = *(_OWORD *)((char *)a1 + 46);
                  *(_OWORD *)&v132[16] = *(_OWORD *)((char *)a1 + 62);
                  unint64_t v118 = v115;
                  do
                  {
                    long long v119 = *(_OWORD *)(v118 - 6);
                    *(_OWORD *)unint64_t v118 = *(_OWORD *)(v118 - 10);
                    *((_OWORD *)v118 + 1) = v119;
                    v118[8] = *(v118 - 2);
                    unint64_t v120 = *(v118 - 20);
                    v118 -= 10;
                  }
                  while (v117 < v120);
                  *unint64_t v118 = v116;
                  *((_WORD *)v118 + 2) = WORD2(v116);
                  *(_OWORD *)(v118 + 5) = *(_OWORD *)&v132[14];
                  *(_OWORD *)((char *)v118 + 6) = *(_OWORD *)v132;
                }
                unint64_t v68 = v115 + 10;
                a1 = v115;
              }
              while (v115 + 10 != a2);
            }
            return;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v80 = (v12 - 2) >> 1;
              int64_t v81 = v80;
              do
              {
                int64_t v82 = v81;
                if (v80 >= v81)
                {
                  uint64_t v83 = (2 * v81) | 1;
                  long long v84 = &v10[10 * v83];
                  if (2 * v82 + 2 < (uint64_t)v12)
                  {
                    unint64_t v85 = *v84;
                    unsigned int v87 = v84[10];
                    BOOL v86 = v85 >= v87;
                    if (v85 < v87) {
                      v84 += 10;
                    }
                    else {
                      unsigned int v87 = *v84;
                    }
                    if (!v86) {
                      uint64_t v83 = 2 * v82 + 2;
                    }
                  }
                  else
                  {
                    unsigned int v87 = *v84;
                  }
                  unint64_t v88 = &v10[10 * v82];
                  unint64_t v89 = *v88 | ((unint64_t)*((unsigned __int16 *)v88 + 2) << 32);
                  unint64_t v90 = *v88;
                  if (v90 <= v87)
                  {
                    *(_OWORD *)int v130 = *(_OWORD *)((char *)v88 + 6);
                    *(_OWORD *)&v130[16] = *(_OWORD *)((char *)v88 + 22);
                    do
                    {
                      long long v91 = v88;
                      unint64_t v88 = v84;
                      long long v92 = *(_OWORD *)v84;
                      long long v93 = *((_OWORD *)v84 + 1);
                      v91[8] = v84[8];
                      *(_OWORD *)long long v91 = v92;
                      *((_OWORD *)v91 + 1) = v93;
                      if (v80 < v83) {
                        break;
                      }
                      uint64_t v94 = (2 * v83) | 1;
                      long long v84 = &v10[10 * v94];
                      uint64_t v83 = 2 * v83 + 2;
                      if (v83 < (uint64_t)v12)
                      {
                        unsigned int v95 = *v84;
                        if (*v84 >= (unint64_t)v84[10])
                        {
                          uint64_t v83 = v94;
                        }
                        else
                        {
                          unsigned int v95 = v84[10];
                          v84 += 10;
                        }
                      }
                      else
                      {
                        unsigned int v95 = *v84;
                        uint64_t v83 = v94;
                      }
                    }
                    while (v90 <= v95);
                    *unint64_t v88 = v89;
                    *((_WORD *)v88 + 2) = WORD2(v89);
                    *(_OWORD *)(v88 + 5) = *(_OWORD *)&v130[14];
                    *(_OWORD *)((char *)v88 + 6) = *(_OWORD *)v130;
                  }
                }
                int64_t v81 = v82 - 1;
              }
              while (v82);
              int64_t v96 = v11 / 0x28uLL;
              do
              {
                uint64_t v97 = 0;
                uint64_t v145 = *((void *)v10 + 4);
                long long v131 = *(_OWORD *)v10;
                long long v139 = *((_OWORD *)v10 + 1);
                unint64_t v98 = v10;
                do
                {
                  unint64_t v99 = &v98[10 * v97 + 10];
                  uint64_t v100 = (2 * v97) | 1;
                  uint64_t v101 = 2 * v97 + 2;
                  if (v101 < v96 && *v99 < (unint64_t)v99[10])
                  {
                    v99 += 10;
                    uint64_t v100 = v101;
                  }
                  long long v102 = *(_OWORD *)v99;
                  long long v103 = *((_OWORD *)v99 + 1);
                  v98[8] = v99[8];
                  *(_OWORD *)unint64_t v98 = v102;
                  *((_OWORD *)v98 + 1) = v103;
                  unint64_t v98 = v99;
                  uint64_t v97 = v100;
                }
                while (v100 <= (uint64_t)((unint64_t)(v96 - 2) >> 1));
                a2 -= 10;
                if (v99 == a2)
                {
                  v99[8] = v145;
                  *(_OWORD *)unint64_t v99 = v131;
                  *((_OWORD *)v99 + 1) = v139;
                }
                else
                {
                  long long v104 = *(_OWORD *)a2;
                  long long v105 = *((_OWORD *)a2 + 1);
                  v99[8] = a2[8];
                  *(_OWORD *)unint64_t v99 = v104;
                  *((_OWORD *)v99 + 1) = v105;
                  a2[8] = v145;
                  *(_OWORD *)a2 = v131;
                  *((_OWORD *)a2 + 1) = v139;
                  uint64_t v106 = (char *)v99 - (char *)v10 + 40;
                  if (v106 >= 41)
                  {
                    unint64_t v107 = (v106 / 0x28uLL - 2) >> 1;
                    uint64_t v108 = &v10[10 * v107];
                    uint64_t v109 = *v99;
                    unint64_t v110 = v109 | ((unint64_t)*((unsigned __int16 *)v99 + 2) << 32);
                    if (*v108 < (unint64_t)v109)
                    {
                      *(_OWORD *)int8x8_t v123 = *(_OWORD *)((char *)v99 + 6);
                      *(_OWORD *)&v123[16] = *(_OWORD *)((char *)v99 + 22);
                      do
                      {
                        uint64_t v111 = v99;
                        unint64_t v99 = v108;
                        long long v112 = *(_OWORD *)v108;
                        long long v113 = *((_OWORD *)v108 + 1);
                        v111[8] = v108[8];
                        *(_OWORD *)uint64_t v111 = v112;
                        *((_OWORD *)v111 + 1) = v113;
                        if (!v107) {
                          break;
                        }
                        unint64_t v107 = (v107 - 1) >> 1;
                        uint64_t v108 = &v10[10 * v107];
                      }
                      while (*v108 < (unint64_t)v110);
                      *unint64_t v99 = v110;
                      *((_WORD *)v99 + 2) = WORD2(v110);
                      *(_OWORD *)(v99 + 5) = *(_OWORD *)&v123[14];
                      *(_OWORD *)((char *)v99 + 6) = *(_OWORD *)v123;
                    }
                  }
                }
              }
              while (v96-- > 2);
            }
            return;
          }
          unint64_t v13 = v12 >> 1;
          long long v14 = &v10[10 * (v12 >> 1)];
          if ((unint64_t)v11 >= 0x1401)
          {
            _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEjT1_SG_SG_S9_(a1, &a1[10 * (v12 >> 1)], a2 - 10);
            uint64_t v15 = 5 * v13;
            long long v16 = &a1[10 * v13 - 10];
            _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEjT1_SG_SG_S9_(a1 + 10, v16, a2 - 20);
            uint64_t v17 = &a1[2 * v15 + 10];
            _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEjT1_SG_SG_S9_(a1 + 20, v17, a2 - 30);
            _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEjT1_SG_SG_S9_(v16, v14, v17);
            uint64_t v140 = *((void *)a1 + 4);
            long long v124 = *(_OWORD *)a1;
            long long v133 = *((_OWORD *)a1 + 1);
            long long v18 = *(_OWORD *)v14;
            long long v19 = *((_OWORD *)v14 + 1);
            a1[8] = v14[8];
            *(_OWORD *)a1 = v18;
            *((_OWORD *)a1 + 1) = v19;
            v14[8] = v140;
            *(_OWORD *)long long v14 = v124;
            *((_OWORD *)v14 + 1) = v133;
          }
          else
          {
            _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEjT1_SG_SG_S9_(&a1[10 * (v12 >> 1)], a1, a2 - 10);
          }
          --a3;
          unint64_t v20 = *a1 | ((unint64_t)*((unsigned __int16 *)a1 + 2) << 32);
          if (a4) {
            break;
          }
          unint64_t v21 = *a1;
          if (*(a1 - 10) < v21) {
            goto LABEL_12;
          }
          *(_OWORD *)long long v122 = *(_OWORD *)((char *)a1 + 6);
          *(_OWORD *)&v122[16] = *(_OWORD *)((char *)a1 + 22);
          if (v21 >= *(a2 - 10))
          {
            uint64_t v37 = a1 + 10;
            do
            {
              long long v10 = v37;
              if (v37 >= a2) {
                break;
              }
              v37 += 10;
            }
            while (v21 >= *v10);
          }
          else
          {
            long long v10 = a1;
            do
            {
              unsigned int v36 = v10[10];
              v10 += 10;
            }
            while (v21 >= v36);
          }
          unint64_t v38 = (unint64_t)a2;
          if (v10 < a2)
          {
            unint64_t v38 = (unint64_t)a2;
            do
            {
              unsigned int v39 = *(_DWORD *)(v38 - 40);
              v38 -= 40;
            }
            while (v21 < v39);
          }
          while ((unint64_t)v10 < v38)
          {
            uint64_t v142 = *((void *)v10 + 4);
            long long v126 = *(_OWORD *)v10;
            long long v135 = *((_OWORD *)v10 + 1);
            long long v40 = *(_OWORD *)v38;
            long long v41 = *(_OWORD *)(v38 + 16);
            v10[8] = *(_DWORD *)(v38 + 32);
            *(_OWORD *)long long v10 = v40;
            *((_OWORD *)v10 + 1) = v41;
            *(_DWORD *)(v38 + 32) = v142;
            *(_OWORD *)unint64_t v38 = v126;
            *(_OWORD *)(v38 + 16) = v135;
            do
            {
              unsigned int v42 = v10[10];
              v10 += 10;
            }
            while (v21 >= v42);
            do
            {
              unsigned int v43 = *(_DWORD *)(v38 - 40);
              v38 -= 40;
            }
            while (v21 < v43);
          }
          BOOL v4 = v10 - 10 >= a1;
          BOOL v5 = v10 - 10 == a1;
          if (v10 - 10 != a1)
          {
            long long v44 = *(_OWORD *)(v10 - 10);
            long long v45 = *(_OWORD *)(v10 - 6);
            a1[8] = *(v10 - 2);
            *(_OWORD *)a1 = v44;
            *((_OWORD *)a1 + 1) = v45;
          }
          a4 = 0;
          *(v10 - 10) = v20;
          *((_WORD *)v10 - 18) = WORD2(v20);
          *(_OWORD *)(v10 - 5) = *(_OWORD *)&v122[14];
          *(_OWORD *)((char *)v10 - 34) = *(_OWORD *)v122;
        }
        unint64_t v21 = *a1;
LABEL_12:
        uint64_t v22 = 0;
        *(_OWORD *)unint64_t v121 = *(_OWORD *)((char *)a1 + 6);
        *(_OWORD *)&v121[16] = *(_OWORD *)((char *)a1 + 22);
        do
        {
          unint64_t v23 = a1[v22 + 10];
          v22 += 10;
        }
        while (v23 < v21);
        uint64_t v24 = &a1[v22];
        uint64_t v25 = a2;
        if (v22 == 10)
        {
          uint64_t v25 = a2;
          do
          {
            if (v24 >= v25) {
              break;
            }
            unsigned int v27 = *(v25 - 10);
            v25 -= 10;
          }
          while (v27 >= v21);
        }
        else
        {
          do
          {
            unsigned int v26 = *(v25 - 10);
            v25 -= 10;
          }
          while (v26 >= v21);
        }
        long long v10 = &a1[v22];
        if (v24 < v25)
        {
          unint64_t v28 = (unint64_t)v25;
          do
          {
            uint64_t v141 = *((void *)v10 + 4);
            long long v125 = *(_OWORD *)v10;
            long long v134 = *((_OWORD *)v10 + 1);
            long long v29 = *(_OWORD *)v28;
            long long v30 = *(_OWORD *)(v28 + 16);
            v10[8] = *(_DWORD *)(v28 + 32);
            *(_OWORD *)long long v10 = v29;
            *((_OWORD *)v10 + 1) = v30;
            *(_DWORD *)(v28 + 32) = v141;
            *(_OWORD *)unint64_t v28 = v125;
            *(_OWORD *)(v28 + 16) = v134;
            do
            {
              unsigned int v31 = v10[10];
              v10 += 10;
            }
            while (v31 < v21);
            do
            {
              unsigned int v32 = *(_DWORD *)(v28 - 40);
              v28 -= 40;
            }
            while (v32 >= v21);
          }
          while ((unint64_t)v10 < v28);
        }
        if (v10 - 10 != a1)
        {
          long long v33 = *(_OWORD *)(v10 - 10);
          long long v34 = *(_OWORD *)(v10 - 6);
          a1[8] = *(v10 - 2);
          *(_OWORD *)a1 = v33;
          *((_OWORD *)a1 + 1) = v34;
        }
        *(v10 - 10) = v20;
        *((_WORD *)v10 - 18) = WORD2(v20);
        *(_OWORD *)(v10 - 5) = *(_OWORD *)&v121[14];
        *(_OWORD *)((char *)v10 - 34) = *(_OWORD *)v121;
        if (v24 >= v25) {
          break;
        }
LABEL_31:
        _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsELb0EEEvT1_SG_S9_NS_15iterator_traitsISG_E15difference_typeEb(a1, v10 - 10, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v35 = _ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEbT1_SG_S9_(a1, v10 - 10);
      if (_ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEbT1_SG_S9_(v10, a2))
      {
        break;
      }
      if (!v35) {
        goto LABEL_31;
      }
    }
    a2 = v10 - 10;
    if (!v35) {
      continue;
    }
    break;
  }
}

unsigned int *_ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEjT1_SG_SG_S9_(unsigned int *result, unsigned int *a2, unsigned int *a3)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *a3;
  if (v3 >= *result)
  {
    if (v4 < v3)
    {
      uint64_t v10 = *((void *)a2 + 4);
      long long v11 = *(_OWORD *)a2;
      long long v12 = *((_OWORD *)a2 + 1);
      unsigned int v13 = a3[8];
      long long v14 = *((_OWORD *)a3 + 1);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_OWORD *)a2 + 1) = v14;
      a2[8] = v13;
      *(_OWORD *)a3 = v11;
      *((_OWORD *)a3 + 1) = v12;
      a3[8] = v10;
      if (*a2 < (unint64_t)*result)
      {
        uint64_t v15 = *((void *)result + 4);
        long long v16 = *(_OWORD *)result;
        long long v17 = *((_OWORD *)result + 1);
        unsigned int v18 = a2[8];
        long long v19 = *((_OWORD *)a2 + 1);
        *(_OWORD *)__n128 result = *(_OWORD *)a2;
        *((_OWORD *)result + 1) = v19;
        result[8] = v18;
        *(_OWORD *)a2 = v16;
        *((_OWORD *)a2 + 1) = v17;
        a2[8] = v15;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      uint64_t v20 = *((void *)result + 4);
      long long v21 = *(_OWORD *)result;
      long long v22 = *((_OWORD *)result + 1);
      unsigned int v23 = a2[8];
      long long v24 = *((_OWORD *)a2 + 1);
      *(_OWORD *)__n128 result = *(_OWORD *)a2;
      *((_OWORD *)result + 1) = v24;
      result[8] = v23;
      *(_OWORD *)a2 = v21;
      *((_OWORD *)a2 + 1) = v22;
      a2[8] = v20;
      if (*a3 >= (unint64_t)*a2) {
        return result;
      }
      uint64_t v5 = *((void *)a2 + 4);
      long long v6 = *(_OWORD *)a2;
      long long v7 = *((_OWORD *)a2 + 1);
      unsigned int v25 = a3[8];
      long long v26 = *((_OWORD *)a3 + 1);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_OWORD *)a2 + 1) = v26;
      a2[8] = v25;
    }
    else
    {
      uint64_t v5 = *((void *)result + 4);
      long long v6 = *(_OWORD *)result;
      long long v7 = *((_OWORD *)result + 1);
      unsigned int v8 = a3[8];
      long long v9 = *((_OWORD *)a3 + 1);
      *(_OWORD *)__n128 result = *(_OWORD *)a3;
      *((_OWORD *)result + 1) = v9;
      result[8] = v8;
    }
    *(_OWORD *)a3 = v6;
    *((_OWORD *)a3 + 1) = v7;
    a3[8] = v5;
  }
  return result;
}

void RB::SurfacePool::shared(void)::$_0::__invoke<void *>()
{
}

RB::SurfacePool *RB::SurfacePool::SurfacePool(RB::SurfacePool *this)
{
  *(_DWORD *)this = 0;
  uint64_t v2 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, 0);
  *((void *)this + 1) = dispatch_queue_create("com.apple.RenderBox.SurfacePool", v2);
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 2;
  *((void *)this + 12) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((void *)this + 15) = 0x7FF0000000000000;
  *((unsigned char *)this + 128) = 0;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  return this;
}

uint64_t RB::Refcount<RBPath anonymous namespace'::make_single_element_path<RBPathMakeEllipse::EllipseArgs>(RBPathMakeEllipse::EllipseArgs &&,CGAffineTransform const*)::Info,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

void *RB::vector<RB::Device::RenderPipelineEntry::Functions::Table,0ul,unsigned int>::reserve_slow(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1);
  }
  __n128 result = RB::details::realloc_vector<unsigned int,80ul>(*(void **)a1, (_DWORD *)(a1 + 12), v3);
  *(void *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,80ul>(void *a1, _DWORD *a2, unsigned int a3)
{
  unint64_t v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(80 * a3);
    unint64_t v6 = v5 / 0x50;
    if (*a2 != (v5 / 0x50))
    {
      long long v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7) {
        RB::precondition_failure((RB *)"allocation failure", v8);
      }
      unint64_t v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

void RB::pixel_format_traits(MTLPixelFormat)::$_0::__invoke()
{
  CFStringRef v0 = (unsigned int *)malloc_type_malloc(0x1360uLL, 0x1000040891685FDuLL);
  RB::pixel_format_traits(MTLPixelFormat)::sorted_traits = (uint64_t)v0;
  _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsELb0EEEvT1_SG_S9_NS_15iterator_traitsISG_E15difference_typeEb(v0, v0 + 1240, 12, 1);
}

atomic_uint *anonymous namespace'::make_single_element_path<RBPathMakeEllipse::EllipseArgs>(RBPathMakeEllipse::EllipseArgs &&,CGAffineTransform const*)::{lambda(void const*)#2}::__invoke(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

BOOL RB::Path::Storage::operator==(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2) {
    uint64_t v3 = *(void *)(a1 + 24);
  }
  else {
    uint64_t v3 = (v2 >> 8) & 0xFFF;
  }
  unint64_t v4 = *(unsigned int *)(a2 + 8);
  uint64_t v5 = (v4 >> 8) & 0xFFF;
  if (v4) {
    uint64_t v5 = *(void *)(a2 + 24);
  }
  if (v3 != v5 || ((v4 ^ v2) & 0x3E) != 0) {
    return 0;
  }
  if (v2)
  {
    long long v7 = *(const void **)(a1 + 16);
    size_t v8 = *(void *)(a1 + 24);
  }
  else
  {
    long long v7 = (const void *)(a1 + 16);
    size_t v8 = (v2 >> 8) & 0xFFF;
  }
  long long v11 = *(const void **)(a2 + 16);
  long long v9 = (const void *)(a2 + 16);
  uint64_t v10 = v11;
  if (v4) {
    long long v9 = v10;
  }
  return memcmp(v7, v9, v8) == 0;
}

uint64_t RB::anonymous namespace'::find_bundle(RB::_anonymous_namespace_ *this)
{
  v13[1] = *MEMORY[0x263EF8340];
  uint64_t v1 = (char *)dyld_image_path_containing_address();
  if (!v1) {
    goto LABEL_11;
  }
  unint64_t v2 = v1;
  uint64_t v3 = strstr(v1, "/RenderBox.framework");
  if (!v3) {
    goto LABEL_11;
  }
  int64_t v5 = v3 - v2;
  size_t v6 = v3 - v2 + 21;
  if (v6 > 0x1000)
  {
    long long v7 = (char *)malloc_type_malloc(v3 - v2 + 21, 0xD312ABBEuLL);
    if (!v7)
    {
      uint64_t v10 = 0;
      goto LABEL_10;
    }
  }
  else
  {
    MEMORY[0x270FA5388](v3, v4);
    long long v7 = (char *)v13 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v7, v6);
  }
  size_t v8 = v5 + 20;
  memcpy(v7, v2, v8);
  v7[v8] = 0;
  uint64_t v9 = [NSURL fileURLWithFileSystemRepresentation:v7 isDirectory:1 relativeToURL:0];
  uint64_t v10 = v9;
  if (v6 <= 0x1000)
  {
    if (v9) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
LABEL_10:
  free(v7);
  if (v10) {
    goto LABEL_12;
  }
LABEL_11:
  uint64_t v10 = [NSURL fileURLWithFileSystemRepresentation:"/System/Library/PrivateFrameworks/RenderBox.framework" isDirectory:1 relativeToURL:0];
  if (v10)
  {
LABEL_12:
    uint64_t result = [MEMORY[0x263F086E0] bundleWithURL:v10];
    if (result) {
      return result;
    }
  }
  uint64_t result = [MEMORY[0x263F086E0] bundleWithIdentifier:@"com.apple.RenderBox"];
  if (!result) {
    RB::precondition_failure((RB *)"unable to find bundle: com.apple.RenderBox", v12);
  }
  return result;
}

RB::ImageTexture *RB::ImageTexture::ImageTexture(RB::ImageTexture *this, const RB::ImageTexture *a2, RB::Heap *a3)
{
  uint64_t v4 = *(const void **)a2;
  *(void *)this = *(void *)a2;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((_WORD *)this + 6) = *((_WORD *)a2 + 6);
  int64_t v5 = (unsigned int *)*((void *)a3 + 4);
  if (!v5)
  {
    RB::Heap::make_object_table((size_t *)a3);
    int64_t v5 = (unsigned int *)*((void *)a3 + 4);
  }
  RB::ObjectTable::retain(v5, v4);
  return this;
}

RB::ImageTexture *RB::ImageTexture::ImageTexture(RB::ImageTexture *this, CGImage *a2, const void *a3)
{
  *(void *)this = a3;
  *((_DWORD *)this + 2) = a2;
  *((_WORD *)this + 6) = 0;
  RB::ImageTexture::update_image((unint64_t)this, a2);
  return this;
}

unint64_t RB::ImageTexture::update_image(unint64_t this, CGImage *a2)
{
  *(_WORD *)(this + 12) = 0;
  unint64_t v2 = (unsigned char *)(this + 12);
  unint64_t v3 = this;
  switch(*(_DWORD *)(this + 8))
  {
    case 0:
      uint64_t v4 = *(RB **)this;
      *(unsigned char *)(this + 13) = RB::cg_image_required_depth(*(RB **)this, a2);
      this = RB::cg_image_has_alpha(v4, v5);
      *(unsigned char *)(v3 + 12) = this ^ 1;
      break;
    case 1:
      __int16 v11 = 0;
      OSType PixelFormat = IOSurfaceGetPixelFormat(*(IOSurfaceRef *)this);
      this = RB::pixel_format_from_four_cc(PixelFormat, MTLPixelFormatInvalid, v2, (unsigned char *)&v11 + 1, (char *)&v11);
      goto LABEL_6;
    case 2:
      this = RBSurfaceIsOpaque(*(void *)this);
      *(unsigned char *)(v3 + 12) = this;
      break;
    case 4:
      this = [*(id *)this pixelFormat];
LABEL_6:
      size_t v8 = (RB *)this;
      if (this)
      {
        if (*v2)
        {
          BOOL v9 = 1;
        }
        else
        {
          uint64_t v10 = RB::pixel_format_traits(this, v7);
          BOOL v9 = ((*v10 | ((unint64_t)*((unsigned __int16 *)v10 + 2) << 32)) & 0x100000000) == 0;
        }
        *(unsigned char *)(v3 + 12) = v9;
        this = RB::pixel_format_required_depth(v8, v7);
        *(unsigned char *)(v3 + 13) = this;
      }
      break;
    default:
      return this;
  }
  return this;
}

uint64_t RB::cg_image_required_depth(RB *this, CGImage *a2)
{
  ColorSpace = CGImageGetColorSpace(this);
  if (CGColorSpaceUsesExtendedRange(ColorSpace)) {
    return 4;
  }
  BOOL v5 = CGImageGetBitsPerComponent(this) > 8;
  if (CGColorSpaceIsWideGamutRGB(ColorSpace)) {
    return v5 | 2u;
  }
  else {
    return v5;
  }
}

BOOL RB::cg_image_has_alpha(RB *this, CGImage *a2)
{
  return (CGImageHasAlpha() & 1) != 0 || CGImageIsMask(this) || CGImageGetMask() || CGImageGetMaskingColors() != 0;
}

uint64_t rb_interpolation_mode(unsigned int a1)
{
  if (a1 > 0xC) {
    return 1;
  }
  else {
    return byte_214219E08[a1];
  }
}

{
  if (a1 > 9) {
    return 1;
  }
  else {
    return dword_214219E18[(char)a1];
  }
}

uint64_t RB::Path::Mapper::add_ellipse(__n128 *this, CGRect a2, int a3, const CGAffineTransform *a4)
{
  CGRect v14 = CGRectStandardize(a2);
  double v7 = v14.size.width * 0.5;
  v13.a = v7;
  double v8 = -0.5;
  if (!a3) {
    double v8 = 0.5;
  }
  v13.b = 0.0;
  v13.c = 0.0;
  v13.d = v14.size.height * v8;
  v13.tdouble x = v7 + v14.origin.x;
  v13.tdouble y = v14.origin.y + v14.size.height * 0.5;
  if (a4)
  {
    CGAffineTransform t1 = v13;
    long long v9 = *(_OWORD *)&a4->c;
    *(_OWORD *)&t2.a = *(_OWORD *)&a4->a;
    *(_OWORD *)&t2.c = v9;
    *(_OWORD *)&t2.tdouble x = *(_OWORD *)&a4->tx;
    CGAffineTransformConcat(&v13, &t1, &t2);
  }
  RB::Path::Mapper::elt_moveto(this, (float64x2_t *)&v13, (float64x2_t)xmmword_2142181C0);
  RB::Path::Mapper::elt_cubeto((uint64_t)this, (float64x2_t *)&v13, (float64x2_t)xmmword_214219AE0, (float64x2_t)xmmword_214219AF0, (float64x2_t)xmmword_2142181D0);
  RB::Path::Mapper::elt_cubeto((uint64_t)this, (float64x2_t *)&v13, (float64x2_t)xmmword_214219B00, (float64x2_t)xmmword_214219B10, (float64x2_t)xmmword_214219A10);
  RB::Path::Mapper::elt_cubeto((uint64_t)this, (float64x2_t *)&v13, (float64x2_t)xmmword_214219B20, (float64x2_t)xmmword_214219B30, (float64x2_t)xmmword_214219B40);
  RB::Path::Mapper::elt_cubeto((uint64_t)this, (float64x2_t *)&v13, (float64x2_t)xmmword_214219B50, (float64x2_t)xmmword_214219B60, (float64x2_t)xmmword_2142181C0);
  return RB::Path::Mapper::elt_closepath((uint64_t)this);
}

void *RB::Path::BufferedTransform::cubeto(void *result, __n128 a2, __n128 a3, __n128 a4)
{
  uint64_t v4 = result;
  BOOL v5 = result + 1;
  uint64_t v6 = result[18];
  size_t v7 = v6 + 1;
  if (result[19] < (unint64_t)(v6 + 1))
  {
    __n128 v15 = a3;
    __n128 v17 = a4;
    __n128 v13 = a2;
    uint64_t result = RB::vector<unsigned char,128ul,unsigned long>::reserve_slow(result + 1, v7);
    a2 = v13;
    a3 = v15;
    a4 = v17;
    uint64_t v6 = v4[18];
    size_t v7 = v6 + 1;
  }
  double v8 = (void *)v4[17];
  if (!v8) {
    double v8 = v5;
  }
  *((unsigned char *)v8 + v6) = 3;
  v4[18] = v7;
  unint64_t v9 = v4[533];
  unint64_t v10 = v9 + 6;
  if (v9 <= 0xFFFFFFFFFFFFFFF9 && v4[534] < v10)
  {
    __n128 v16 = a3;
    __n128 v18 = a4;
    __n128 v14 = a2;
    uint64_t result = RB::vector<double,512ul,unsigned long>::reserve_slow(v4 + 20, v9 + 6);
    a2 = v14;
    a3 = v16;
    a4 = v18;
  }
  v4[533] = v10;
  __int16 v11 = (void *)v4[532];
  if (!v11) {
    __int16 v11 = v4 + 20;
  }
  long long v12 = (__n128 *)&v11[v9];
  *long long v12 = a2;
  v12[1] = a3;
  void v12[2] = a4;
  return result;
}

void *RB::Path::BufferedTransform::moveto(void *result, __n128 a2)
{
  unint64_t v2 = result;
  unint64_t v3 = result + 1;
  uint64_t v4 = result[18];
  size_t v5 = v4 + 1;
  if (result[19] < (unint64_t)(v4 + 1))
  {
    __n128 v10 = a2;
    uint64_t result = RB::vector<unsigned char,128ul,unsigned long>::reserve_slow(result + 1, v5);
    a2 = v10;
    uint64_t v4 = v2[18];
    size_t v5 = v4 + 1;
  }
  uint64_t v6 = (void *)v2[17];
  if (!v6) {
    uint64_t v6 = v3;
  }
  *((unsigned char *)v6 + v4) = 0;
  v2[18] = v5;
  unint64_t v7 = v2[533];
  unint64_t v8 = v7 + 2;
  if (v7 <= 0xFFFFFFFFFFFFFFFDLL && v2[534] < v8)
  {
    __n128 v11 = a2;
    uint64_t result = RB::vector<double,512ul,unsigned long>::reserve_slow(v2 + 20, v7 + 2);
    a2 = v11;
  }
  v2[533] = v8;
  unint64_t v9 = (void *)v2[532];
  if (!v9) {
    unint64_t v9 = v2 + 20;
  }
  *(__n128 *)&v9[v7] = a2;
  return result;
}

float set_rounded_rect(uint64_t a1, int a2, float64x2_t a3, float64_t a4, float64x2_t a5, double a6, double a7, double a8, double a9)
{
  float v11 = 1.0;
  char v12 = 2;
  if (a7 > 0.0 && a8 > 0.0)
  {
    if (a6 >= a5.f64[0]) {
      double v13 = a5.f64[0];
    }
    else {
      double v13 = a6;
    }
    double v14 = v13 * 0.5;
    if (v14 < a7) {
      a7 = v14;
    }
    if (v14 < a8) {
      a8 = v14;
    }
    if (a2 == 1)
    {
      a7 = a7 * 1.27499998;
      a8 = a8 * 1.27499998;
      char v12 = 4;
    }
    else
    {
      if (a2) {
        abort();
      }
      if (a5.f64[0] == a6 && (a7 == v14 ? (BOOL v15 = a8 == v14) : (BOOL v15 = 0), v15)) {
        char v12 = 5;
      }
      else {
        char v12 = 3;
      }
    }
    if (a7 == a8)
    {
      double v16 = 1.0;
    }
    else
    {
      double v17 = a7 / a8;
      double v16 = 1.0 / (a7 / a8);
      float v11 = v17;
    }
    a3.f64[0] = v16 * a3.f64[0];
    a5.f64[0] = v16 * a5.f64[0];
  }
  a3.f64[1] = a4;
  a5.f64[1] = a6;
  float32x2_t v18 = vcvt_f32_f64(a3);
  float32x2_t v19 = vcvt_f32_f64(a5);
  *(float *)a3.f64 = a8;
  int32x4_t v23 = vdupq_lane_s32(*(int32x2_t *)&a3.f64[0], 0);
  int v20 = *(_DWORD *)(a1 + 428);
  RBShapeData::apply<RB::DestroyAny>((int *)(a1 + 16));
  float result = a9;
  float v22 = *(double *)(a1 + 432);
  *(float32x2_t *)(a1 + 32) = v18;
  *(float32x2_t *)(a1 + 40) = v19;
  *(int32x4_t *)(a1 + 48) = v23;
  *(float *)(a1 + 64) = v11;
  *(float *)(a1 + 68) = result;
  *(float *)(a1 + 72) = v22;
  *(unsigned char *)(a1 + 76) = v12;
  *(unsigned char *)(a1 + 77) = v20;
  *(unsigned char *)(a1 + 78) &= 0xF8u;
  *(_DWORD *)(a1 + 16) = 1;
  return result;
}

uint64_t RB::Fill::Gradient::Gradient(uint64_t a1, RB::Heap *this, char a3, unint64_t a4, uint64_t a5, __int16 a6, uint64_t a7, int a8, double a9, double a10, float a11, float a12)
{
  *(void *)a1 = a4;
  unint64_t v23 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  unint64_t v24 = v23 + 16 * a4;
  if (v24 > *((void *)this + 3)) {
    unint64_t v23 = RB::Heap::alloc_slow((size_t *)this, 16 * a4, 7);
  }
  else {
    *((void *)this + 2) = v24;
  }
  *(void *)(a1 + 8) = v23;
  *(void *)(a1 + 16) = 0;
  *(double *)(a1 + 24) = a9;
  *(double *)(a1 + 32) = a10;
  *(float *)(a1 + 40) = a11;
  *(float *)(a1 + 44) = a12;
  *(_DWORD *)(a1 + 48) = a8;
  *(unsigned char *)(a1 + 52) = a3;
  *(_WORD *)(a1 + 53) = a6;
  *(_WORD *)(a1 + 55) = 1;
  if (!a7)
  {
    if ((a8 & 0xF00) == 0x200 || (a8 & 0xF00) == 0x100) {
      *(_DWORD *)(a1 + 48) = a8 & 0xFFFFF0FF;
    }
LABEL_29:
    if (!a4) {
      goto LABEL_71;
    }
    unint64_t v47 = 0;
    int v48 = a8 & 0xF00;
    float v49 = -INFINITY;
    float v50 = INFINITY;
    __asm { FMOV            V6.2S, #1.0 }
    float32x2_t v52 = (float32x2_t)vdup_n_s32(0x437F0000u);
    int8x8_t v53 = (int8x8_t)vdup_n_s32(0x437F8000u);
    while (1)
    {
      uint64_t v54 = *(void *)(a1 + 8);
      uint64_t v55 = 16 * v47;
      float32x4_t v56 = *(float32x4_t *)(a5 + 16 * v47);
      *(float16x4_t *)(v54 + 16 * v47) = vcvt_f16_f32(v56);
      _ZF = v56.f32[3] != 1.0 || *(unsigned char *)(a1 + 55) == 0;
      char v58 = !_ZF;
      *(unsigned char *)(a1 + 55) = v58;
      float v59 = fminf(fminf(v56.f32[0], v56.f32[2]), v56.f32[1]);
      if (v59 < v50) {
        float v50 = v59;
      }
      float v60 = fmaxf(fmaxf(v56.f32[0], v56.f32[2]), v56.f32[1]);
      if (v49 < v60) {
        float v49 = v60;
      }
      int v61 = *(_DWORD *)(a1 + 48);
      if ((v61 & 0x10000) != 0) {
        break;
      }
      uint64_t v62 = *(void *)a1 - 1;
      float32x2_t v63 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(unint64_t)v62));
      float32x2_t v64 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(unint64_t)v62), v63), v63);
      float v65 = (float)v47
          * vmul_f32(v64, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(unint64_t)v62), v64)).f32[0];
LABEL_49:
      *(float *)(v54 + 16 * v47 + 8) = v65;
      int v67 = v61 & 0xF00;
      if (v67 == 256)
      {
        unint64_t v68 = v47 + 1;
        if (v47 + 1 >= a4)
        {
          *(_DWORD *)(v54 + 16 * v47 + 12) = 1056964608;
        }
        else
        {
          float v81 = (*(double *)(a7 + 16 * v47 + 8) - *(double *)(a7 + 16 * v47))
              / (*(double *)(a7 + 16 * v47 + 16) - *(double *)(a7 + 16 * v47));
          *(float *)(v54 + 16 * v47 + 12) = v81;
        }
      }
      else if (v67 == 512)
      {
        unint64_t v68 = v47 + 1;
        if (v47 + 1 >= a4)
        {
          *(_DWORD *)(v54 + 16 * v47 + 12) = -65536;
        }
        else
        {
          double v69 = (double *)(a7 + 40 * v47);
          float v70 = v69[1];
          uint64_t v71 = v69 + 2;
          v72.f64[0] = v69[4];
          float v73 = v69[3];
          if (v70 < 0.0) {
            float v70 = 0.0;
          }
          if (v70 <= 1.0) {
            float v74 = (float)(v70 * 255.0) + 0.5;
          }
          else {
            float v74 = 255.5;
          }
          int v75 = (int)v74;
          if (v73 >= 0.0) {
            float v76 = v73;
          }
          else {
            float v76 = 0.0;
          }
          if (v76 <= 1.0) {
            float v77 = (float)(v76 * 255.0) + 0.5;
          }
          else {
            float v77 = 255.5;
          }
          unint64_t v23 = (int)v77;
          v72.f64[1] = *v71;
          float32x2_t v78 = vcvt_f32_f64(v72);
          float32x2_t v79 = (float32x2_t)vbic_s8((int8x8_t)v78, (int8x8_t)vcltz_f32(v78));
          uint32x2_t v80 = vshl_u32((uint32x2_t)vcvt_s32_f32((float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v79, _D6), v53, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v52, v79))), (uint32x2_t)0x800000018);
          *(_DWORD *)(v54 + 16 * v47 + 12) = v80.i32[0] | (v23 << 16) | v75 | v80.i32[1];
        }
      }
      else
      {
        unint64_t v68 = v47 + 1;
      }
      unint64_t v47 = v68;
      if (v68 == a4) {
        goto LABEL_72;
      }
    }
    if (v48 == 512)
    {
      uint64_t v55 = 40 * v47;
    }
    else if (v48 != 256)
    {
      double v66 = *(double *)(a7 + 8 * v47);
LABEL_48:
      float v65 = v66;
      goto LABEL_49;
    }
    double v66 = *(double *)(a7 + v55);
    goto LABEL_48;
  }
  unsigned int v25 = a8 & 0xFFFFF0FF;
  *(_DWORD *)(a1 + 48) = a8 & 0xFFFFF0FF;
  if (a4)
  {
    unint64_t v26 = 0;
    unint64_t v27 = 0;
    uint64_t v28 = 0;
    float v29 = 1.0 / (float)(a4 - 1);
    int v30 = a8 & 0xF00;
    uint64_t v31 = a7 + 8;
    unint64_t v32 = 1;
    float32x4_t v33 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    int8x16_t v34 = (int8x16_t)vdupq_n_s32(0x437F8000u);
    __asm { FMOV            V5.4S, #1.0 }
    while (1)
    {
      if (v30 == 512) {
        unint64_t v23 = v27;
      }
      else {
        unint64_t v23 = v32 - 1;
      }
      if (v30 == 256) {
        unint64_t v23 = v26;
      }
      float v39 = v29 * (float)(v32 - 1);
      float v40 = *(double *)(a7 + 8 * v23);
      if (vabds_f32(v40, v39) > 0.001)
      {
        v25 |= 0x10000u;
        *(_DWORD *)(a1 + 48) = v25;
      }
      if (v30 == 256)
      {
        if (v32 >= a4) {
          goto LABEL_22;
        }
        float v41 = *(double *)(v31 + 8 * v26);
        if (fabsf((float)((float)(v29 * -0.5) - v39) + v41) <= 0.001) {
          goto LABEL_22;
        }
        int v42 = 256;
      }
      else
      {
        int v42 = a8 & 0xF00;
        if (v30 == 512)
        {
          if (v32 >= a4) {
            goto LABEL_22;
          }
          float32x4_t v43 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(v31 + v28)), *(float64x2_t *)(v31 + v28 + 16));
          float32x4_t v44 = (float32x4_t)vbicq_s8((int8x16_t)v43, (int8x16_t)vcltzq_f32(v43));
          v45.i64[0] = 0x3F0000003F000000;
          v45.i64[1] = 0x3F0000003F000000;
          int16x8_t v46 = (int16x8_t)vcvtq_s32_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v44, _Q5), v34, (int8x16_t)vmlaq_f32(v45, v33, v44)));
          *(int16x4_t *)v46.i8 = vmovn_s32((int32x4_t)v46);
          if (vmovn_s16(v46).u32[0] == -65536) {
            goto LABEL_22;
          }
          int v42 = 512;
        }
      }
      v25 |= v42;
      *(_DWORD *)(a1 + 48) = v25;
LABEL_22:
      if (((v25 ^ (a8 | 0x10000)) & 0x10F00) != 0)
      {
        v28 += 40;
        v27 += 5;
        v26 += 2;
        _ZF = a4 == v32++;
        if (!_ZF) {
          continue;
        }
      }
      goto LABEL_29;
    }
  }
LABEL_71:
  float v50 = INFINITY;
  float v49 = -INFINITY;
LABEL_72:
  *(unsigned char *)(a1 + 56) = RB::required_color_depth((RB *)v23, v50, v49);
  return a1;
}

uint64_t RB::Fill::Gradient::Gradient(uint64_t a1, RB::Heap *a2, char a3, unint64_t a4, uint64_t a5, __int16 a6, uint64_t a7, int a8, double a9, double a10, float a11, float a12)
{
  return RB::Fill::Gradient::Gradient(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
}

uint64_t set_gradient_color(uint64_t a1, uint64_t a2, float *a3, unsigned int a4)
{
  if (a2)
  {
    if (a2 != 1) {
      return 0;
    }
  }
  else
  {
    a3 = (float *)&RBColorClear;
  }
  -[RBFill _setColor:colorSpace:](a1, a4, *a3, a3[1], a3[2], a3[3]);
  return 1;
}

char *RB::Path::Storage::MapCache::MapCache(void)::$_0::__invoke(char *result)
{
  if (result)
  {
    uint64_t v1 = result;
    unint64_t v2 = (char *)*((void *)result + 2);
    if (v2) {
      unint64_t v3 = v2;
    }
    else {
      unint64_t v3 = v1;
    }
    if (*((void *)v1 + 3))
    {
      unint64_t v4 = 0;
      size_t v5 = (atomic_uint **)(v3 + 8);
      do
      {
        uint64_t v6 = *v5;
        if (*v5 && atomic_fetch_add_explicit(v6 + 2, 0xFFFFFFFF, memory_order_release) == 1)
        {
          __dmb(9u);
          (*(void (**)(atomic_uint *))(*(void *)v6 + 8))(v6);
        }
        ++v4;
        v5 += 2;
      }
      while (v4 < *((void *)v1 + 3));
      unint64_t v2 = (char *)*((void *)v1 + 2);
    }
    if (v2) {
      free(v2);
    }
    JUMPOUT(0x21669AC10);
  }
  return result;
}

unint64_t std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,std::pair<float,unsigned int> *,std::__less<void,void> &>(uint64_t a1, float *a2)
{
  uint64_t v2 = 0;
  float v3 = *(float *)a1;
  unsigned int v4 = *(_DWORD *)(a1 + 4);
  do
  {
    float v5 = *(float *)(a1 + v2 + 8);
    if (v5 == v3) {
      int v6 = 0;
    }
    else {
      int v6 = -127;
    }
    if (v5 > v3) {
      int v6 = 1;
    }
    if (v5 < v3) {
      int v6 = -1;
    }
    if (!v6)
    {
      unsigned int v7 = *(_DWORD *)(a1 + v2 + 12);
      BOOL v8 = v7 == v4;
      LOBYTE(v6) = v7 < v4 ? -1 : 1;
      if (v8) {
        LOBYTE(v6) = 0;
      }
    }
    v2 += 8;
  }
  while (v6 != 129 && (v6 & 0x80) != 0);
  unint64_t v9 = a1 + v2;
  if (v2 == 8)
  {
    while (v9 < (unint64_t)a2)
    {
      __n128 v10 = a2 - 2;
      float v15 = *(a2 - 2);
      if (v15 == v3) {
        int v16 = 0;
      }
      else {
        int v16 = -127;
      }
      if (v15 > v3) {
        int v16 = 1;
      }
      if (v15 < v3) {
        int v16 = -1;
      }
      if (!v16)
      {
        unsigned int v17 = *((_DWORD *)a2 - 1);
        BOOL v18 = v17 == v4;
        LOBYTE(v16) = v17 < v4 ? -1 : 1;
        if (v18) {
          LOBYTE(v16) = 0;
        }
      }
      a2 -= 2;
      if (v16 != 129)
      {
        a2 = v10;
        if ((v16 & 0x80) != 0) {
          goto LABEL_52;
        }
      }
    }
    __n128 v10 = a2;
  }
  else
  {
    while (1)
    {
      __n128 v10 = a2 - 2;
      float v11 = *(a2 - 2);
      if (v11 == v3) {
        int v12 = 0;
      }
      else {
        int v12 = -127;
      }
      if (v11 > v3) {
        int v12 = 1;
      }
      if (v11 < v3) {
        int v12 = -1;
      }
      if (!v12)
      {
        unsigned int v13 = *((_DWORD *)a2 - 1);
        BOOL v14 = v13 == v4;
        LOBYTE(v12) = v13 < v4 ? -1 : 1;
        if (v14) {
          LOBYTE(v12) = 0;
        }
      }
      a2 -= 2;
      if (v12 != 129)
      {
        a2 = v10;
        if ((v12 & 0x80) != 0) {
          break;
        }
      }
    }
  }
LABEL_52:
  if (v9 >= (unint64_t)v10)
  {
    unint64_t v20 = a1 + v2;
  }
  else
  {
    float v19 = *v10;
    unint64_t v20 = a1 + v2;
    long long v21 = v10;
    do
    {
      *(float *)unint64_t v20 = v19;
      *long long v21 = v5;
      int v22 = *(_DWORD *)(v20 + 4);
      *(float *)(v20 + 4) = v21[1];
      *((_DWORD *)v21 + 1) = v22;
      unint64_t v23 = v20;
      do
      {
        float v24 = *(float *)(v20 + 8);
        v20 += 8;
        float v5 = v24;
        BOOL v25 = v24 < v3;
        BOOL v26 = v24 <= v3;
        if (v24 == v3) {
          int v27 = 0;
        }
        else {
          int v27 = -127;
        }
        if (!v26) {
          int v27 = 1;
        }
        if (v25) {
          int v27 = -1;
        }
        if (!v27)
        {
          unsigned int v28 = *(_DWORD *)(v23 + 12);
          BOOL v29 = v28 == v4;
          if (v28 < v4) {
            char v30 = -1;
          }
          else {
            char v30 = 1;
          }
          if (v29) {
            LOBYTE(v27) = 0;
          }
          else {
            LOBYTE(v27) = v30;
          }
        }
        if (v27 == 129) {
          break;
        }
        unint64_t v23 = v20;
      }
      while ((v27 & 0x80) != 0);
      while (1)
      {
        uint64_t v31 = v21 - 2;
        float v19 = *(v21 - 2);
        if (v19 == v3) {
          int v32 = 0;
        }
        else {
          int v32 = -127;
        }
        if (v19 > v3) {
          int v32 = 1;
        }
        if (v19 < v3) {
          int v32 = -1;
        }
        if (!v32)
        {
          unsigned int v33 = *((_DWORD *)v21 - 1);
          BOOL v34 = v33 == v4;
          if (v33 < v4) {
            char v35 = -1;
          }
          else {
            char v35 = 1;
          }
          if (v34) {
            LOBYTE(v32) = 0;
          }
          else {
            LOBYTE(v32) = v35;
          }
        }
        long long v21 = v31;
        if (v32 != 129)
        {
          long long v21 = v31;
          if ((v32 & 0x80) != 0) {
            break;
          }
        }
      }
      long long v21 = v31;
    }
    while (v20 < (unint64_t)v31);
  }
  if (v20 - 8 != a1)
  {
    *(_DWORD *)a1 = *(_DWORD *)(v20 - 8);
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(v20 - 4);
  }
  *(float *)(v20 - 8) = v3;
  *(_DWORD *)(v20 - 4) = v4;
  return v20 - 8;
}

CFDataRef RB::ProtobufEncoder::take_data@<X0>(RB::ProtobufEncoder *this@<X0>, CFDataRef *a2@<X8>)
{
  if (*((unsigned char *)this + 48))
  {
    CFDataRef result = 0;
  }
  else
  {
    unsigned int v4 = *(const UInt8 **)this;
    CFIndex v5 = *((void *)this + 1);
    *((void *)this + 1) = 0;
    *((void *)this + 2) = 0;
    *(void *)this = 0;
    CFDataRef result = CFDataCreateWithBytesNoCopy(0, v4, v5, (CFAllocatorRef)*MEMORY[0x263EFFB18]);
  }
  *a2 = result;
  return result;
}

uint64_t *RB::Encoder::local_namespace(RB::Encoder *this)
{
  {
    RB::Encoder::local_namespace(void)::local_ns = RB::Encoder::local_namespace(void)::$_0::operator()();
    *(void *)algn_26ACDE158 = v2;
  }
  return &RB::Encoder::local_namespace(void)::local_ns;
}

void sub_2141350F8(_Unwind_Exception *a1)
{
}

uint64_t RB::Encoder::local_namespace(void)::$_0::operator()()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  uuid_clear(uu);
  MEMORY[0x21669B510](uu);
  return *(void *)uu;
}

void *RB::ProtobufEncoder::encode_varint(void *this, unint64_t a2)
{
  unint64_t v2 = a2;
  float v3 = this;
  if (a2 > 0x7F)
  {
    unsigned __int8 v5 = 70 - __clz(a2);
    uint64_t v6 = (((v5 - ((unsigned __int16)(37 * v5) >> 8)) >> 1) + ((37 * v5) >> 8)) >> 2;
    unint64_t v4 = this[1];
  }
  else
  {
    unint64_t v4 = this[1];
    if (this[2] > v4)
    {
      *(unsigned char *)(*this + v4) = a2;
      ++this[1];
      return this;
    }
    uint64_t v6 = 1;
  }
  size_t v7 = v4 + v6;
  if (v4 < v4 + v6 && this[2] < v7) {
    this = RB::vector<unsigned char,0ul,unsigned long>::reserve_slow((uint64_t)this, v7);
  }
  v3[1] = v7;
  BOOL v8 = (unsigned char *)(*v3 + v4);
  do
  {
    BOOL v9 = v2 > 0x7F;
    char v10 = v2 > 0x7F;
    char v11 = v2 & 0x7F;
    v2 >>= 7;
    *v8++ = v11 | (v10 << 7);
  }
  while (v9);
  return this;
}

void *RB::ProtobufEncoder::encode_fixed32(void *this, int a2)
{
  float v3 = this;
  unint64_t v4 = this[1];
  unint64_t v5 = v4 + 4;
  if (v4 <= 0xFFFFFFFFFFFFFFFBLL && this[2] < v5) {
    this = RB::vector<unsigned char,0ul,unsigned long>::reserve_slow((uint64_t)this, v4 + 4);
  }
  v3[1] = v5;
  *(_DWORD *)(*v3 + v4) = a2;
  return this;
}

void *RB::ProtobufEncoder::encode_fixed64(void *this, uint64_t a2)
{
  float v3 = this;
  unint64_t v4 = this[1];
  unint64_t v5 = v4 + 8;
  if (v4 <= 0xFFFFFFFFFFFFFFF7 && this[2] < v5) {
    this = RB::vector<unsigned char,0ul,unsigned long>::reserve_slow((uint64_t)this, v4 + 8);
  }
  v3[1] = v5;
  *(void *)(*v3 + v4) = a2;
  return this;
}

void *RB::ProtobufEncoder::encode_data(RB::ProtobufEncoder *this, const void *a2, unint64_t a3)
{
  CFDataRef result = RB::ProtobufEncoder::encode_varint(this, a3);
  if (a3)
  {
    unint64_t v7 = *((void *)this + 1);
    unint64_t v8 = v7 + a3;
    if (v7 < v7 + a3 && *((void *)this + 2) < v8) {
      RB::vector<unsigned char,0ul,unsigned long>::reserve_slow((uint64_t)this, v7 + a3);
    }
    *((void *)this + 1) = v8;
    BOOL v9 = (void *)(*(void *)this + v7);
    return memcpy(v9, a2, a3);
  }
  return result;
}

void *RB::ProtobufEncoder::begin_length_delimited(void *this)
{
  uint64_t v1 = this;
  uint64_t v2 = this[1];
  unint64_t v3 = v2 + 1;
  if (v2 != -1 && this[2] < v3) {
    this = RB::vector<unsigned char,0ul,unsigned long>::reserve_slow((uint64_t)this, v2 + 1);
  }
  v1[1] = v3;
  uint64_t v4 = v1[4];
  if (v1[5] < (unint64_t)(v4 + 1))
  {
    this = RB::vector<unsigned long,0ul,unsigned long>::reserve_slow((uint64_t)(v1 + 3), v4 + 1);
    uint64_t v4 = v1[4];
  }
  *(void *)(v1[3] + 8 * v4) = v2;
  ++v1[4];
  return this;
}

void *RB::ProtobufEncoder::end_length_delimited(void *this)
{
  uint64_t v1 = this;
  uint64_t v2 = this[4] - 1;
  uint64_t v3 = *(void *)(this[3] + 8 * v2);
  this[4] = v2;
  size_t v4 = this[1];
  uint64_t v5 = v3 + 1;
  unint64_t v6 = v4 - (v3 + 1);
  if (v6 > 0x7F)
  {
    char v7 = __clz(v6);
    uint64_t v8 = (((70 - v7 - ((unsigned __int16)(37 * (70 - v7)) >> 8)) >> 1)
        + ((37 * (70 - v7)) >> 8)) >> 2;
    size_t v9 = v4 + v8 - 1;
    if (v4 < v9 && this[2] < v9)
    {
      uint64_t v15 = v4 + v8 - 1;
      uint64_t v14 = v8;
      RB::vector<unsigned char,0ul,unsigned long>::reserve_slow((uint64_t)this, v9);
      uint64_t v8 = v14;
      uint64_t v5 = v3 + 1;
      size_t v9 = v15;
    }
    v1[1] = v9;
    this = memmove((void *)(*v1 + v3 + v8), (const void *)(*v1 + v5), v6);
    char v10 = (unsigned char *)(*v1 + v3);
    do
    {
      BOOL v11 = v6 > 0x7F;
      char v12 = v6 > 0x7F;
      char v13 = v6 & 0x7F;
      v6 >>= 7;
      *v10++ = v13 | (v12 << 7);
    }
    while (v11);
  }
  else
  {
    *(unsigned char *)(*this + v3) = v6;
  }
  return this;
}

void *RB::ProtobufEncoder::packed_uint32_field(void *this, uint64_t a2, unsigned int *a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v4 = a4;
    unint64_t v6 = this;
    RB::ProtobufEncoder::encode_varint(this, (8 * a2) | 2);
    RB::ProtobufEncoder::begin_length_delimited(v6);
    do
    {
      unsigned int v7 = *a3++;
      RB::ProtobufEncoder::encode_varint(v6, v7);
      --v4;
    }
    while (v4);
    return RB::ProtobufEncoder::end_length_delimited(v6);
  }
  return this;
}

void *RB::ProtobufEncoder::packed_fixed32_field(void *this, uint64_t a2, const unsigned int *a3, uint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = this;
    RB::ProtobufEncoder::encode_varint(this, (8 * a2) | 2);
    size_t v7 = 4 * a4;
    RB::ProtobufEncoder::encode_varint(v6, 4 * a4);
    size_t v8 = v6[1];
    size_t v9 = v8 + 4 * a4;
    if (v8 < v9 && v6[2] < v9) {
      RB::vector<unsigned char,0ul,unsigned long>::reserve_slow((uint64_t)v6, v9);
    }
    v6[1] = v9;
    char v10 = (void *)(*v6 + v8);
    return memcpy(v10, a3, v7);
  }
  return this;
}

void *RB::ProtobufEncoder::packed_fixed64_field(void *this, uint64_t a2, const unint64_t *a3, uint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = this;
    RB::ProtobufEncoder::encode_varint(this, (8 * a2) | 2);
    size_t v7 = 8 * a4;
    RB::ProtobufEncoder::encode_varint(v6, 8 * a4);
    size_t v8 = v6[1];
    size_t v9 = v8 + 8 * a4;
    if (v8 < v9 && v6[2] < v9) {
      RB::vector<unsigned char,0ul,unsigned long>::reserve_slow((uint64_t)v6, v9);
    }
    v6[1] = v9;
    char v10 = (void *)(*v6 + v8);
    return memcpy(v10, a3, v7);
  }
  return this;
}

void *RB::ProtobufEncoder::float2_field(void *result, uint64_t a2, double a3)
{
  uint32x2_t v3 = (uint32x2_t)vceqz_f32(*(float32x2_t *)&a3);
  if ((vpmin_u32(v3, v3).u32[0] & 0x80000000) == 0)
  {
    uint64_t v4 = result;
    RB::ProtobufEncoder::encode_varint(result, (8 * a2) | 2);
    RB::ProtobufEncoder::begin_length_delimited(v4);
    if (*(float *)&a3 != 0.0)
    {
      RB::ProtobufEncoder::encode_varint(v4, 0xDuLL);
      RB::ProtobufEncoder::encode_fixed32(v4, SLODWORD(a3));
    }
    if (*((float *)&a3 + 1) != 0.0)
    {
      RB::ProtobufEncoder::encode_varint(v4, 0x15uLL);
      RB::ProtobufEncoder::encode_fixed32(v4, SHIDWORD(a3));
    }
    return RB::ProtobufEncoder::end_length_delimited(v4);
  }
  return result;
}

void *RB::ProtobufEncoder::float3_field(void *result, uint64_t a2, float32x4_t a3)
{
  uint32x4_t v3 = (uint32x4_t)vceqzq_f32(a3);
  v3.i32[3] = v3.i32[2];
  if ((vminvq_u32(v3) & 0x80000000) == 0)
  {
    uint64_t v4 = result;
    RB::ProtobufEncoder::encode_varint(result, (8 * a2) | 2);
    RB::ProtobufEncoder::begin_length_delimited(v4);
    if (a3.f32[0] != 0.0)
    {
      RB::ProtobufEncoder::encode_varint(v4, 0xDuLL);
      RB::ProtobufEncoder::encode_fixed32(v4, a3.i32[0]);
    }
    if (a3.f32[1] != 0.0)
    {
      RB::ProtobufEncoder::encode_varint(v4, 0x15uLL);
      RB::ProtobufEncoder::encode_fixed32(v4, a3.i32[1]);
    }
    if (a3.f32[2] != 0.0)
    {
      RB::ProtobufEncoder::encode_varint(v4, 0x1DuLL);
      RB::ProtobufEncoder::encode_fixed32(v4, a3.i32[2]);
    }
    return RB::ProtobufEncoder::end_length_delimited(v4);
  }
  return result;
}

void *RB::ProtobufEncoder::float4_field(void *result, uint64_t a2, float32x4_t a3)
{
  if ((vminvq_u32((uint32x4_t)vceqzq_f32(a3)) & 0x80000000) == 0)
  {
    uint32x4_t v3 = result;
    RB::ProtobufEncoder::encode_varint(result, (8 * a2) | 2);
    RB::ProtobufEncoder::begin_length_delimited(v3);
    if (a3.f32[0] != 0.0)
    {
      RB::ProtobufEncoder::encode_varint(v3, 0xDuLL);
      RB::ProtobufEncoder::encode_fixed32(v3, a3.i32[0]);
    }
    if (a3.f32[1] != 0.0)
    {
      RB::ProtobufEncoder::encode_varint(v3, 0x15uLL);
      RB::ProtobufEncoder::encode_fixed32(v3, a3.i32[1]);
    }
    float v4 = a3.f32[3];
    if (a3.f32[2] != 0.0)
    {
      RB::ProtobufEncoder::encode_varint(v3, 0x1DuLL);
      RB::ProtobufEncoder::encode_fixed32(v3, a3.i32[2]);
      float v4 = a3.f32[3];
    }
    int v5 = LODWORD(v4);
    if (v4 != 0.0)
    {
      RB::ProtobufEncoder::encode_varint(v3, 0x25uLL);
      RB::ProtobufEncoder::encode_fixed32(v3, v5);
    }
    return RB::ProtobufEncoder::end_length_delimited(v3);
  }
  return result;
}

void *RB::ProtobufEncoder::color_field(void *result, uint64_t a2, double a3)
{
  if (a3 != 1.08420217e-19)
  {
    float v4 = result;
    RB::ProtobufEncoder::encode_varint(result, (8 * a2) | 1);
    return RB::ProtobufEncoder::encode_fixed64(v4, *(uint64_t *)&a3);
  }
  return result;
}

void *RB::Encoder::shared_field_f(RB::Encoder *this, uint64_t a2, uint64_t *a3)
{
  RB::ProtobufEncoder::encode_varint(this, (8 * a2) | 2);
  RB::ProtobufEncoder::begin_length_delimited(this);
  size_t v7 = 0;
  int v5 = RB::UntypedTable::lookup((RB::Encoder *)((char *)this + 80), a3, &v7);
  if (v7 != a3) {
    *((unsigned char *)this + 48) = 1;
  }
  RB::ProtobufEncoder::encode_varint(this, 8uLL);
  RB::ProtobufEncoder::encode_varint(this, (unint64_t)v5);
  return RB::ProtobufEncoder::end_length_delimited(this);
}

uint64_t *RB::Encoder::prepare_image(uint64_t *result, uint64_t a2, uint64_t *a3)
{
  if (a3)
  {
    uint64_t v3 = (uint64_t)result;
    if ((*((unsigned char *)result + 164) & 1) == 0)
    {
      uint64_t v4 = result[7];
      if (v4)
      {
        CFDataRef theData = 0;
        CFDataRef result = RB::UntypedTable::lookup((RB::UntypedTable *)(result + 10), a3, (void **)&theData);
        if (a3 != (uint64_t *)theData)
        {
          size_t v7 = *(size_t **)(v3 + 72);
          *(void *)(v3 + 72) = (char *)v7 + 1;
          RB::UntypedTable::insert((size_t **)(v3 + 80), (size_t *)a3, v7);
          RB::ProtobufEncoder::encode_varint((void *)v3, 0x7AuLL);
          RB::ProtobufEncoder::begin_length_delimited((void *)v3);
          if (v7)
          {
            RB::ProtobufEncoder::encode_varint((void *)v3, 8uLL);
            RB::ProtobufEncoder::encode_varint((void *)v3, (unint64_t)v7);
          }
          RB::ProtobufEncoder::encode_varint((void *)v3, 0x12uLL);
          RB::ProtobufEncoder::begin_length_delimited((void *)v3);
          (*(void (**)(CFDataRef *__return_ptr, uint64_t, uint64_t, uint64_t *))(*(void *)v4 + 32))(&theData, v4, a2, a3);
          if (theData)
          {
            BytePtr = CFDataGetBytePtr(theData);
            CFIndex Length = CFDataGetLength(theData);
            if (Length)
            {
              RB::ProtobufEncoder::encode_varint((void *)v3, 0xAuLL);
              RB::ProtobufEncoder::encode_data((RB::ProtobufEncoder *)v3, BytePtr, Length);
            }
            if (theData) {
              CFRelease(theData);
            }
          }
          else
          {
            *(unsigned char *)(v3 + 48) = 1;
          }
          RB::ProtobufEncoder::end_length_delimited((void *)v3);
          return RB::ProtobufEncoder::end_length_delimited((void *)v3);
        }
      }
      else
      {
        *((unsigned char *)result + 48) = 1;
      }
    }
  }
  return result;
}

void sub_214135C40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

RB::Encoder *RB::Encoder::image_field(RB::Encoder *result, uint64_t a2, int a3, uint64_t *a4)
{
  if (a4) {
    return (RB::Encoder *)RB::Encoder::shared_field_f(result, a2, a4);
  }
  return result;
}

uint64_t RB::Encoder::prepare_glyphs(RB::Encoder *this, CGFont *a2, unint64_t a3, const unsigned __int16 *a4)
{
  if (!*((void *)this + 8)) {
    operator new();
  }
  unsigned int Identifier = CGFontGetIdentifier();
  uint64_t v7 = *((void *)this + 8) + 16;
  unsigned int v13 = Identifier;
  uint64_t v14 = &v13;
  uint64_t v8 = std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(v7, &v13, (uint64_t)&std::piecewise_construct, &v14);
  uint64_t v9 = v8;
  if (a2 && !*(void *)(v8 + 24)) {
    *(void *)(v8 + 24) = CFRetain(a2);
  }
  uint64_t result = CGFontIndexSetAddIndexes();
  if ((*((unsigned char *)this + 164) & 1) == 0)
  {
    int v11 = *((_DWORD *)this + 40);
    if (*(_DWORD *)(v9 + 56) != v11)
    {
      *(_DWORD *)(v9 + 56) = v11;
      uint64_t v12 = *((void *)this + 9);
      *((void *)this + 9) = v12 + 1;
      *(void *)(v9 + 64) = v12;
    }
  }
  return result;
}

void RB::Encoder::prepare_fonts(RB::Encoder *this)
{
  uint64_t v1 = *((void *)this + 8);
  if (v1)
  {
    if ((*((unsigned char *)this + 164) & 1) == 0)
    {
      for (uint64_t i = *(uint64_t **)(v1 + 32); i; uint64_t i = (uint64_t *)*i)
      {
        RB::Encoder::FontSet::Font::ensure_data((RB::Encoder::FontSet::Font *)(i + 3), this);
        if (*((_DWORD *)i + 14) == *((_DWORD *)this + 40) && i[4])
        {
          RB::ProtobufEncoder::encode_varint(this, 0x7AuLL);
          RB::ProtobufEncoder::begin_length_delimited(this);
          unint64_t v4 = i[8];
          if (v4)
          {
            RB::ProtobufEncoder::encode_varint(this, 8uLL);
            RB::ProtobufEncoder::encode_varint(this, v4);
          }
          RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
          RB::ProtobufEncoder::begin_length_delimited(this);
          BytePtr = CFDataGetBytePtr((CFDataRef)i[4]);
          CFIndex Length = CFDataGetLength((CFDataRef)i[4]);
          if (Length)
          {
            unint64_t v7 = Length;
            RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
            RB::ProtobufEncoder::encode_data(this, BytePtr, v7);
          }
          RB::ProtobufEncoder::end_length_delimited(this);
          RB::ProtobufEncoder::end_length_delimited(this);
        }
        else
        {
          *((unsigned char *)this + 48) = 1;
        }
      }
    }
  }
}

void RB::Encoder::FontSet::Font::ensure_data(RB::Encoder::FontSet::Font *this, RB::Encoder *a2)
{
  v26[1] = *(char **)MEMORY[0x263EF8340];
  if (*((void *)this + 1)) {
    return;
  }
  uint64_t v2 = *((void *)a2 + 7);
  if (!v2) {
    return;
  }
  if (!(*(unsigned int (**)(uint64_t, void))(*(void *)v2 + 8))(v2, *(void *)this)) {
    goto LABEL_35;
  }
  int FontSubsetFormat = CGFontGetFontSubsetFormat();
  if (!FontSubsetFormat) {
    goto LABEL_35;
  }
  int v5 = FontSubsetFormat;
  if (FontSubsetFormat != 1)
  {
    Propertdouble y = (const void *)CGFontGetProperty();
    if (Property)
    {
      FontSubset = CFRetain(Property);
      if (FontSubset) {
        goto LABEL_32;
      }
    }
  }
  v26[0] = 0;
  CFStringRef Name = (const char *)CGFontIndexSetGetName();
  PostScriptCFStringRef Name = (const char *)CGFontGetPostScriptName();
  asprintf(v26, "%s+%s", Name, PostScriptName);
  *((void *)this + 3) = CGFontIndexMapCreate();
  FontSubset = (const void *)CGFontCreateFontSubset();
  free(v26[0]);
  BOOL v10 = v5 == 1;
  if (!FontSubset) {
    BOOL v10 = 1;
  }
  if (!v10)
  {
    uint64_t Count = CGFontIndexSetGetCount();
    uint64_t v13 = Count;
    if (Count < 0)
    {
LABEL_32:
      (*(void (**)(char **__return_ptr, uint64_t, void, const void *, void, void))(*(void *)v2 + 24))(v26, v2, *(void *)this, FontSubset, *((void *)this + 2), *((void *)this + 3));
      float v24 = (char *)*((void *)this + 1);
      *((char **)this + 1) = v26[0];
      v26[0] = v24;
      if (v24) {
        CFRelease(v24);
      }
      CFRelease(FontSubset);
      goto LABEL_35;
    }
    unint64_t v14 = 2 * Count;
    if ((unint64_t)(2 * Count) > 0x1000)
    {
      uint64_t v15 = (char *)malloc_type_malloc(2 * Count, 0xF07D14F5uLL);
      unint64_t v20 = (__int16 *)malloc_type_malloc(2 * v13, 0x5FE3BA16uLL);
      BOOL v18 = v20;
      int v19 = 1;
      if (!v15 || !v20)
      {
LABEL_28:
        free(v18);
LABEL_29:
        if (v19) {
          free(v15);
        }
        goto LABEL_31;
      }
    }
    else
    {
      MEMORY[0x270FA5388](Count, v12);
      uint64_t v15 = (char *)v26 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v15, 2 * v13);
      MEMORY[0x270FA5388](v16, v17);
      BOOL v18 = (__int16 *)v15;
      bzero(v15, 2 * v13);
      int v19 = 0;
    }
    CGFontIndexSetGetIndexes();
    CGFontIndexMapGetValues();
    if (!v13) {
      goto LABEL_29;
    }
    uint64_t v21 = 0;
    char v22 = 0;
    do
    {
      while (v18[v21] == -1)
      {
        v18[v21] = v21 + 1;
        char v22 = 1;
        if (v13 - 1 == v21++) {
          goto LABEL_26;
        }
      }
      ++v21;
    }
    while (v13 != v21);
    if ((v22 & 1) == 0) {
      goto LABEL_27;
    }
LABEL_26:
    CGFontIndexMapAddIndexes();
LABEL_27:
    if (v14 <= 0x1000) {
      goto LABEL_29;
    }
    goto LABEL_28;
  }
LABEL_31:
  if (FontSubset) {
    goto LABEL_32;
  }
LABEL_35:
  if (!*((void *)this + 1))
  {
    (*(void (**)(char **__return_ptr, uint64_t, void))(*(void *)v2 + 16))(v26, v2, *(void *)this);
    BOOL v25 = (char *)*((void *)this + 1);
    *((char **)this + 1) = v26[0];
    v26[0] = v25;
    if (v25) {
      CFRelease(v25);
    }
  }
}

void sub_214136260(_Unwind_Exception *a1)
{
  if (v3 > 0x1000)
  {
    free(v4);
    free(v2);
  }
  CFRelease(v1);
  _Unwind_Resume(a1);
}

void RB::Encoder::FontSet::Font::~Font(RB::Encoder::FontSet::Font *this)
{
  if (*((void *)this + 2)) {
    CGFontIndexSetRelease();
  }
  if (*((void *)this + 3)) {
    CGFontIndexMapRelease();
  }
  uint64_t v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  if (*(void *)this) {
    CFRelease(*(CFTypeRef *)this);
  }
}

void sub_214136304(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  if (*(void *)v1) {
    CFRelease(*(CFTypeRef *)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *RB::Encoder::cgfont_field(RB::Encoder *this, uint64_t a2, CGFont *a3)
{
  if (!a3) {
    return 0;
  }
  if (*((void *)this + 8))
  {
    unsigned int Identifier = CGFontGetIdentifier();
    unint64_t v6 = (void *)(*((void *)this + 8) + 16);
    unsigned int v11 = Identifier;
    uint64_t result = std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::find<unsigned int>(v6, &v11);
    if (result)
    {
      uint64_t v8 = (uint64_t)result;
      uint64_t v9 = (RB::Encoder::FontSet::Font *)(result + 3);
      RB::ProtobufEncoder::encode_varint(this, (8 * a2) | 2);
      RB::ProtobufEncoder::begin_length_delimited(this);
      unint64_t v10 = *(void *)(v8 + 64);
      RB::ProtobufEncoder::encode_varint(this, 8uLL);
      RB::ProtobufEncoder::encode_varint(this, v10);
      RB::ProtobufEncoder::end_length_delimited(this);
      RB::Encoder::FontSet::Font::ensure_data(v9, this);
      return *(uint64_t **)(v8 + 48);
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *((unsigned char *)this + 48) = 1;
  return result;
}

uint64_t RB::ProtobufDecoder::decode_varint(RB::ProtobufDecoder *this)
{
  uint64_t v3 = *(void *)this;
  unint64_t v2 = *((void *)this + 1);
  if (*(void *)this >= v2)
  {
LABEL_5:
    uint64_t result = 0;
    *((unsigned char *)this + 56) = 1;
    *(void *)this = v2;
  }
  else
  {
    char v4 = 0;
    uint64_t result = 0;
    uint64_t v6 = v2 - v3;
    uint64_t v7 = v3 + 1;
    while (1)
    {
      *(void *)this = v7;
      result |= (unint64_t)(*(unsigned char *)(v7 - 1) & 0x7F) << v4;
      if ((*(unsigned char *)(v7 - 1) & 0x80) == 0) {
        break;
      }
      v4 += 7;
      ++v7;
      if (!--v6) {
        goto LABEL_5;
      }
    }
  }
  return result;
}

uint64_t RB::ProtobufDecoder::decode_data(RB::ProtobufDecoder *this)
{
  uint64_t v2 = RB::ProtobufDecoder::decode_varint(this);
  uint64_t result = *(void *)this;
  unint64_t v4 = *((void *)this + 1);
  if (__CFADD__(*(void *)this, v2) || *(void *)this + v2 > v4)
  {
    uint64_t result = 0;
    *((unsigned char *)this + 56) = 1;
  }
  else
  {
    unint64_t v4 = *(void *)this + v2;
  }
  *(void *)this = v4;
  return result;
}

uint64_t RB::ProtobufDecoder::begin_message(RB::ProtobufDecoder *this)
{
  uint64_t v2 = *((void *)this + 5);
  unint64_t v3 = v2 + 1;
  if (*((void *)this + 6) < (unint64_t)(v2 + 1))
  {
    RB::vector<unsigned long,0ul,unsigned long>::reserve_slow((uint64_t)this + 32, v3);
    uint64_t v2 = *((void *)this + 5);
    unint64_t v3 = v2 + 1;
  }
  *(void *)(*((void *)this + 4) + 8 * v2) = *((void *)this + 1);
  *((void *)this + 5) = v3;
  uint64_t result = RB::ProtobufDecoder::decode_varint(this);
  unint64_t v5 = *((void *)this + 1);
  unint64_t v6 = *(void *)this + result;
  if (__CFADD__(*(void *)this, result) || v6 > v5)
  {
    *((unsigned char *)this + 56) = 1;
    *(void *)this = v5;
  }
  else
  {
    *((void *)this + 1) = v6;
  }
  return result;
}

uint64_t RB::ProtobufDecoder::next_field(RB::ProtobufDecoder *this)
{
  unint64_t v3 = *(void *)this;
  unint64_t v2 = *((void *)this + 1);
  if (*(void *)this >= v2)
  {
    uint64_t result = 0;
    *((void *)this + 2) = 0;
  }
  else
  {
    uint64_t result = *((void *)this + 2);
    if (result)
    {
      unint64_t v5 = *((void *)this + 3);
      if (v3 < v5) {
        return result;
      }
      if (v3 > v5)
      {
        *((unsigned char *)this + 56) = 1;
        *(void *)this = v2;
      }
      *((void *)this + 2) = 0;
    }
    uint64_t result = RB::ProtobufDecoder::decode_varint(this);
    if ((result & 0x7FFFFFFF8) == 0)
    {
      uint64_t result = 0;
      *((unsigned char *)this + 56) = 1;
      *(void *)this = *((void *)this + 1);
    }
  }
  return result;
}

uint64_t RB::ProtobufDecoder::end_message(uint64_t this)
{
  if (!*(unsigned char *)(this + 56) && *(void *)this <= *(void *)(this + 8)) {
    *(void *)(this + 8) = *(void *)(*(void *)(this + 32) + 8 * *(void *)(this + 40) - 8);
  }
  --*(void *)(this + 40);
  return this;
}

uint64_t RB::ProtobufDecoder::begin_packed(RB::ProtobufDecoder *a1, int a2, unint64_t a3)
{
  uint64_t v6 = RB::ProtobufDecoder::decode_varint(a1);
  unint64_t v7 = *((void *)a1 + 1);
  unint64_t v8 = *(void *)a1 + v6;
  if (__CFADD__(*(void *)a1, v6) || !v6 || v8 > v7)
  {
    uint64_t result = 0;
    *((unsigned char *)a1 + 56) = 1;
    *(void *)a1 = v7;
  }
  else
  {
    *((void *)a1 + 2) = a2 & 0xFFFFFFF8 | a3;
    *((void *)a1 + 3) = v8;
    return 1;
  }
  return result;
}

RB::ProtobufDecoder *RB::ProtobufDecoder::skip_field(RB::ProtobufDecoder *result, uint64_t a2)
{
  if (a2)
  {
    switch(a2 & 7)
    {
      case 0:
        uint64_t result = (RB::ProtobufDecoder *)RB::ProtobufDecoder::decode_varint(result);
        break;
      case 1:
        uint64_t v2 = *(void *)result + 8;
        goto LABEL_7;
      case 2:
        uint64_t result = (RB::ProtobufDecoder *)RB::ProtobufDecoder::decode_data(result);
        break;
      case 5:
        uint64_t v2 = *(void *)result + 4;
LABEL_7:
        *(void *)uint64_t result = v2;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t RB::ProtobufDecoder::BOOL_field(RB::ProtobufDecoder *this, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  switch(a2 & 7)
  {
    case 0:
      return RB::ProtobufDecoder::decode_varint(this) != 0;
    case 1:
      unint64_t v3 = *(void *)this + 8;
      if (v3 > *((void *)this + 1)) {
        goto LABEL_9;
      }
      BOOL v4 = **(void **)this == 0;
      goto LABEL_12;
    case 2:
      uint64_t result = RB::ProtobufDecoder::begin_packed(this, a2, 0);
      if (result) {
        return RB::ProtobufDecoder::decode_varint(this) != 0;
      }
      return result;
    case 5:
      unint64_t v3 = *(void *)this + 4;
      if (v3 <= *((void *)this + 1))
      {
        BOOL v4 = **(_DWORD **)this == 0;
LABEL_12:
        uint64_t result = !v4;
      }
      else
      {
LABEL_9:
        uint64_t result = 0;
      }
LABEL_15:
      *(void *)this = v3;
      break;
    default:
      uint64_t result = 0;
      *((unsigned char *)this + 56) = 1;
      unint64_t v3 = *((void *)this + 1);
      goto LABEL_15;
  }
  return result;
}

uint64_t RB::ProtobufDecoder::uint_field(uint64_t **this, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  switch(a2 & 7)
  {
    case 0:
      goto LABEL_7;
    case 1:
      unint64_t v3 = (unint64_t)(*this + 1);
      if (v3 > (unint64_t)this[1]) {
        goto LABEL_11;
      }
      uint64_t result = **this;
      break;
    case 2:
      int v5 = RB::ProtobufDecoder::begin_packed((RB::ProtobufDecoder *)this, a2, 0);
      uint64_t result = 0;
      if (v5)
      {
LABEL_7:
        return RB::ProtobufDecoder::decode_varint((RB::ProtobufDecoder *)this);
      }
      return result;
    case 5:
      unint64_t v3 = (unint64_t)*this + 4;
      if (v3 <= (unint64_t)this[1]) {
        uint64_t result = *(unsigned int *)*this;
      }
      else {
LABEL_11:
      }
        uint64_t result = 0;
      break;
    default:
      uint64_t result = 0;
      *((unsigned char *)this + 56) = 1;
      unint64_t v3 = (unint64_t)this[1];
      break;
  }
  *this = (uint64_t *)v3;
  return result;
}

float RB::ProtobufDecoder::float_field(RB::ProtobufDecoder *a1, uint64_t a2)
{
  float v2 = 0.0;
  if (a2)
  {
    int v4 = a2 & 7;
    if (v4 == 1)
    {
      unint64_t v5 = *(void *)a1 + 8;
      if (v5 <= *((void *)a1 + 1)) {
        float v2 = **(double **)a1;
      }
      goto LABEL_11;
    }
    if (v4 == 5) {
      goto LABEL_6;
    }
    if (v4 != 2)
    {
      *((unsigned char *)a1 + 56) = 1;
      unint64_t v5 = *((void *)a1 + 1);
LABEL_11:
      *(void *)a1 = v5;
      return v2;
    }
    if (RB::ProtobufDecoder::begin_packed(a1, a2, 5uLL))
    {
LABEL_6:
      unint64_t v5 = *(void *)a1 + 4;
      if (v5 <= *((void *)a1 + 1)) {
        float v2 = **(float **)a1;
      }
      goto LABEL_11;
    }
  }
  return v2;
}

double RB::ProtobufDecoder::double_field(RB::ProtobufDecoder *a1, uint64_t a2)
{
  double v2 = 0.0;
  if (a2)
  {
    int v4 = a2 & 7;
    if (v4 == 1) {
      goto LABEL_6;
    }
    if (v4 == 5)
    {
      unint64_t v5 = *(void *)a1 + 4;
      if (v5 <= *((void *)a1 + 1)) {
        double v2 = **(float **)a1;
      }
      goto LABEL_11;
    }
    if (v4 != 2)
    {
      *((unsigned char *)a1 + 56) = 1;
      unint64_t v5 = *((void *)a1 + 1);
LABEL_11:
      *(void *)a1 = v5;
      return v2;
    }
    if (RB::ProtobufDecoder::begin_packed(a1, a2, 1uLL))
    {
LABEL_6:
      unint64_t v5 = *(void *)a1 + 8;
      if (v5 <= *((void *)a1 + 1)) {
        double v2 = **(double **)a1;
      }
      goto LABEL_11;
    }
  }
  return v2;
}

__n128 RB::ProtobufDecoder::float2_field(RB::ProtobufDecoder *this, char a2, __n128 a3)
{
  if ((a2 & 7) == 2)
  {
    RB::ProtobufDecoder::begin_message(this);
    uint64_t field = RB::ProtobufDecoder::next_field(this);
    if (field)
    {
      unint64_t v6 = field;
      *(void *)&long long v5 = 0;
      long long v11 = v5;
      while (1)
      {
        if ((v6 >> 3) == 2)
        {
          float v9 = RB::ProtobufDecoder::float_field(this, v6);
          long long v8 = v11;
          *((float *)&v8 + 1) = v9;
        }
        else
        {
          if ((v6 >> 3) != 1)
          {
            RB::ProtobufDecoder::skip_field(this, v6);
            goto LABEL_10;
          }
          float v7 = RB::ProtobufDecoder::float_field(this, v6);
          long long v8 = v11;
          *(float *)&long long v8 = v7;
        }
        long long v11 = v8;
LABEL_10:
        unint64_t v6 = RB::ProtobufDecoder::next_field(this);
        if (!v6) {
          goto LABEL_13;
        }
      }
    }
    *(void *)&long long v5 = 0;
    long long v11 = v5;
LABEL_13:
    if (!*((unsigned char *)this + 56) && *(void *)this <= *((void *)this + 1)) {
      *((void *)this + 1) = *(void *)(*((void *)this + 4) + 8 * *((void *)this + 5) - 8);
    }
    --*((void *)this + 5);
  }
  else
  {
    *((unsigned char *)this + 56) = 1;
    *(void *)this = *((void *)this + 1);
    a3.n128_u64[0] = 0;
    return a3;
  }
  return (__n128)v11;
}

__n128 RB::ProtobufDecoder::float3_field(RB::ProtobufDecoder *this, char a2)
{
  if ((a2 & 7) == 2)
  {
    RB::ProtobufDecoder::begin_message(this);
    uint64_t field = RB::ProtobufDecoder::next_field(this);
    if (field)
    {
      unint64_t v4 = field;
      long long v11 = 0u;
      while (1)
      {
        unint64_t v5 = v4 >> 3;
        if ((v4 >> 3) == 3)
        {
          float v8 = RB::ProtobufDecoder::float_field(this, v4);
          long long v7 = v11;
          *((float *)&v7 + 2) = v8;
        }
        else if (v5 == 2)
        {
          float v9 = RB::ProtobufDecoder::float_field(this, v4);
          long long v7 = v11;
          *((float *)&v7 + 1) = v9;
        }
        else
        {
          if (v5 != 1)
          {
            RB::ProtobufDecoder::skip_field(this, v4);
            goto LABEL_12;
          }
          float v6 = RB::ProtobufDecoder::float_field(this, v4);
          long long v7 = v11;
          *(float *)&long long v7 = v6;
        }
        long long v11 = v7;
LABEL_12:
        unint64_t v4 = RB::ProtobufDecoder::next_field(this);
        if (!v4) {
          goto LABEL_15;
        }
      }
    }
    long long v11 = 0u;
LABEL_15:
    if (!*((unsigned char *)this + 56) && *(void *)this <= *((void *)this + 1)) {
      *((void *)this + 1) = *(void *)(*((void *)this + 4) + 8 * *((void *)this + 5) - 8);
    }
    --*((void *)this + 5);
  }
  else
  {
    *((unsigned char *)this + 56) = 1;
    *(void *)this = *((void *)this + 1);
    return (__n128)0;
  }
  return (__n128)v11;
}

__n128 RB::ProtobufDecoder::float4_field(RB::ProtobufDecoder *this, char a2)
{
  if ((a2 & 7) == 2)
  {
    RB::ProtobufDecoder::begin_message(this);
    uint64_t field = RB::ProtobufDecoder::next_field(this);
    if (field)
    {
      unint64_t v4 = field;
      long long v11 = 0u;
      do
      {
        switch((v4 >> 3))
        {
          case 1u:
            float v5 = RB::ProtobufDecoder::float_field(this, v4);
            long long v6 = v11;
            *(float *)&long long v6 = v5;
            goto LABEL_10;
          case 2u:
            float v7 = RB::ProtobufDecoder::float_field(this, v4);
            long long v6 = v11;
            *((float *)&v6 + 1) = v7;
            goto LABEL_10;
          case 3u:
            float v8 = RB::ProtobufDecoder::float_field(this, v4);
            long long v6 = v11;
            *((float *)&v6 + 2) = v8;
            goto LABEL_10;
          case 4u:
            float v9 = RB::ProtobufDecoder::float_field(this, v4);
            long long v6 = v11;
            *((float *)&v6 + 3) = v9;
LABEL_10:
            long long v11 = v6;
            break;
          default:
            RB::ProtobufDecoder::skip_field(this, v4);
            break;
        }
        unint64_t v4 = RB::ProtobufDecoder::next_field(this);
      }
      while (v4);
    }
    else
    {
      long long v11 = 0u;
    }
    if (!*((unsigned char *)this + 56) && *(void *)this <= *((void *)this + 1)) {
      *((void *)this + 1) = *(void *)(*((void *)this + 4) + 8 * *((void *)this + 5) - 8);
    }
    --*((void *)this + 5);
  }
  else
  {
    *((unsigned char *)this + 56) = 1;
    *(void *)this = *((void *)this + 1);
    return (__n128)0;
  }
  return (__n128)v11;
}

double RB::ProtobufDecoder::color_field(unint64_t *a1, uint64_t a2)
{
  if (a2)
  {
    if ((a2 & 7) != 1)
    {
      if ((a2 & 7) != 2)
      {
        *((unsigned char *)a1 + 56) = 1;
        unint64_t v3 = a1[1];
        double v4 = 1.08420217e-19;
LABEL_10:
        *a1 = v3;
        return v4;
      }
      if (!RB::ProtobufDecoder::begin_packed((RB::ProtobufDecoder *)a1, a2, 1uLL)) {
        return 1.08420217e-19;
      }
    }
    unint64_t v3 = *a1 + 8;
    if (v3 <= a1[1]) {
      double v4 = *(double *)*a1;
    }
    else {
      double v4 = 0.0;
    }
    goto LABEL_10;
  }
  return 1.08420217e-19;
}

uint64_t RB::ProtobufDecoder::data_field(RB::ProtobufDecoder *this, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  if ((a2 & 7) == 2) {
    return RB::ProtobufDecoder::decode_data(this);
  }
  uint64_t result = 0;
  *((unsigned char *)this + 56) = 1;
  *(void *)this = *((void *)this + 1);
  return result;
}

char *RB::Decoder::push_shared(char *this, char a2)
{
  double v2 = this;
  if ((a2 & 7) == 2)
  {
    RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
    this = (char *)RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)v2);
    if (this)
    {
      unint64_t v3 = (unint64_t)this;
      unint64_t v4 = 0;
      uint64_t v5 = 0;
      unint64_t v6 = 0;
      do
      {
        switch((v3 >> 3))
        {
          case 1u:
            unint64_t v4 = RB::ProtobufDecoder::uint_field((uint64_t **)v2, v3);
            break;
          case 2u:
            long long v10 = *(_OWORD *)v2;
            RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)v2, v3);
            unint64_t v6 = v3;
            uint64_t v5 = 2;
            break;
          case 3u:
            long long v10 = *(_OWORD *)v2;
            RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)v2, v3);
            unint64_t v6 = v3;
            uint64_t v5 = 3;
            break;
          case 4u:
            long long v10 = *(_OWORD *)v2;
            RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)v2, v3);
            unint64_t v6 = v3;
            uint64_t v5 = 4;
            break;
          case 5u:
            long long v10 = *(_OWORD *)v2;
            RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)v2, v3);
            unint64_t v6 = v3;
            uint64_t v5 = 5;
            break;
          case 6u:
            long long v10 = *(_OWORD *)v2;
            RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)v2, v3);
            unint64_t v6 = v3;
            uint64_t v5 = 6;
            break;
          default:
            RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)v2, v3);
            break;
        }
        this = (char *)RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)v2);
        unint64_t v3 = (unint64_t)this;
      }
      while (this);
      if (v5)
      {
        char v7 = v2[228];
        uint64_t v8 = *((void *)v2 + 21);
        if (v7)
        {
          if (v8) {
            char v7 = v4 > *(void *)(*((void *)v2 + 20) + 40 * v8 - 40);
          }
          else {
            char v7 = 1;
          }
        }
        v2[228] = v7;
        if (*((void *)v2 + 22) < (unint64_t)(v8 + 1))
        {
          this = (char *)RB::vector<RB::Decoder::SharedField,0ul,unsigned long>::reserve_slow((uint64_t)(v2 + 160), v8 + 1);
          uint64_t v8 = *((void *)v2 + 21);
        }
        uint64_t v9 = *((void *)v2 + 20) + 40 * v8;
        *(void *)uint64_t v9 = v4;
        *(void *)(v9 + 8) = v5;
        *(_OWORD *)(v9 + 16) = v10;
        *(void *)(v9 + 32) = v6;
        ++*((void *)v2 + 21);
      }
    }
    if (!v2[56] && *(void *)v2 <= *((void *)v2 + 1)) {
      *((void *)v2 + 1) = *(void *)(*((void *)v2 + 4) + 8 * *((void *)v2 + 5) - 8);
    }
    --*((void *)v2 + 5);
  }
  else
  {
    this[56] = 1;
    *(void *)this = *((void *)this + 1);
  }
  return this;
}

void RB::Decoder::saved_shared_field(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  if (!*(unsigned char *)(a1 + 228))
  {
    unint64_t v8 = *(void *)(a1 + 160);
    unint64_t v9 = *(void *)(a1 + 168);
    unint64_t v10 = 126 - 2 * __clz(v9);
    if (v9) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = 0;
    }
    std::__introsort<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *,false>(v8, v8 + 40 * v9, v11, 1);
    *(unsigned char *)(a1 + 228) = 1;
  }
  unint64_t v12 = *(void *)(a1 + 168);
  if (!v12) {
    goto LABEL_16;
  }
  uint64_t v13 = *(void **)(a1 + 160);
  unint64_t v14 = &v13[5 * v12];
  do
  {
    unint64_t v15 = v12 >> 1;
    uint64_t v16 = &v13[5 * (v12 >> 1)];
    unint64_t v18 = *v16;
    uint64_t v17 = v16 + 5;
    v12 += ~(v12 >> 1);
    if (v18 < a3) {
      uint64_t v13 = v17;
    }
    else {
      unint64_t v12 = v15;
    }
  }
  while (v12);
  if (v13 != v14 && *v13 == a3 && v13[1] == a2)
  {
    long long v19 = *((_OWORD *)v13 + 1);
    *(void *)(a4 + 16) = v13[4];
    *(_OWORD *)a4 = v19;
  }
  else
  {
LABEL_16:
    *(void *)(a4 + 16) = 0;
  }
}

void *RB::Decoder::decode_image(RB::Decoder *this)
{
  uint64_t v2 = *((void *)this + 9);
  if (v2 && (uint64_t v3 = RB::ProtobufDecoder::next_field(this)) != 0)
  {
    uint64_t field = v3;
    int v5 = 0;
    CFTypeRef v6 = 0;
    do
    {
      if ((field & 0x7FFFFFFF8) == 8)
      {
        if ((field & 7) == 2)
        {
          uint64_t v7 = RB::ProtobufDecoder::decode_data(this);
          uint64_t v9 = v8;
        }
        else
        {
          uint64_t v7 = 0;
          uint64_t v9 = 0;
          *((unsigned char *)this + 56) = 1;
          *(void *)this = *((void *)this + 1);
        }
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)v2 + 16))(&v12, v2, v7, v9);
        CFTypeRef v10 = cf;
        if (cf)
        {
          int v5 = v12;
          CFTypeRef cf = 0;
          RB::ObjectTable::adopt((RB::Decoder *)((char *)this + 184), v10);
          if (cf) {
            CFRelease(cf);
          }
          CFTypeRef v6 = v10;
        }
        else
        {
          *((unsigned char *)this + 56) = 1;
          *(void *)this = *((void *)this + 1);
        }
      }
      else
      {
        RB::ProtobufDecoder::skip_field(this, field);
      }
      uint64_t field = RB::ProtobufDecoder::next_field(this);
    }
    while (field);
  }
  else
  {
    CFTypeRef v6 = 0;
    int v5 = 0;
  }
  uint64_t result = RB::Heap::emplace<RBImage>(*((size_t **)this + 8));
  *(_DWORD *)uint64_t result = v5;
  result[1] = v6;
  return result;
}

void sub_2141372DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::Decoder::image_field(RB::ProtobufDecoder *this, char a2)
{
  if (!*((void *)this + 9)) {
    return 0;
  }
  if ((a2 & 7) != 2) {
    goto LABEL_29;
  }
  RB::ProtobufDecoder::begin_message(this);
  uint64_t field = RB::ProtobufDecoder::next_field(this);
  if (field)
  {
    unint64_t v4 = field;
    unint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      if ((v4 >> 3) == 2)
      {
        long long v13 = *(_OWORD *)this;
        RB::ProtobufDecoder::skip_field(this, v4);
        unint64_t v6 = v4;
      }
      else if ((v4 >> 3) == 1)
      {
        unint64_t v5 = RB::ProtobufDecoder::uint_field((uint64_t **)this, v4);
      }
      else
      {
        RB::ProtobufDecoder::skip_field(this, v4);
      }
      unint64_t v4 = RB::ProtobufDecoder::next_field(this);
    }
    while (v4);
    if (v5 >> 61)
    {
      uint64_t v7 = 0;
      goto LABEL_23;
    }
  }
  else
  {
    unint64_t v5 = 0;
    unint64_t v6 = 0;
  }
  v15[0] = 0;
  uint64_t v7 = RB::UntypedTable::lookup((RB::ProtobufDecoder *)((char *)this + 80), (uint64_t *)(v5 | 0x4000000000000000), v15);
  if ((void *)(v5 | 0x4000000000000000) != v15[0])
  {
    long long v9 = v13;
    if (!v6)
    {
      RB::Decoder::saved_shared_field((uint64_t)this, 2, v5, (uint64_t)v15);
      LOBYTE(v6) = v16;
      if (!v16)
      {
LABEL_22:
        RB::UntypedTable::insert((size_t **)this + 10, (size_t *)(v5 | 0x4000000000000000), (size_t *)v7);
        goto LABEL_23;
      }
      long long v9 = *(_OWORD *)v15;
    }
    long long v10 = *(_OWORD *)this;
    *(_OWORD *)this = v9;
    if ((v6 & 7) == 2)
    {
      long long v14 = v10;
      RB::ProtobufDecoder::begin_message(this);
      uint64_t v11 = RB::Decoder::decode_image(this);
      long long v10 = v14;
      uint64_t v7 = v11;
      --*((void *)this + 5);
    }
    else
    {
      *((unsigned char *)this + 56) = 1;
    }
    *(_OWORD *)this = v10;
    goto LABEL_22;
  }
LABEL_23:
  if (!*((unsigned char *)this + 56) && *(void *)this <= *((void *)this + 1)) {
    *((void *)this + 1) = *(void *)(*((void *)this + 4) + 8 * *((void *)this + 5) - 8);
  }
  --*((void *)this + 5);
  if (!v7)
  {
LABEL_29:
    uint64_t result = 0;
    uint64_t v12 = *((void *)this + 1);
    *((unsigned char *)this + 56) = 1;
    *(void *)this = v12;
    return result;
  }
  return *v7;
}

CFTypeRef RB::Decoder::decode_cgfont(RB::Decoder *this)
{
  uint64_t v1 = *((void *)this + 9);
  if (!v1) {
    return 0;
  }
  uint64_t field = RB::ProtobufDecoder::next_field(this);
  if (!field) {
    return 0;
  }
  uint64_t v4 = field;
  CFTypeRef v5 = 0;
  do
  {
    if ((v4 & 0x7FFFFFFF8) == 8)
    {
      if ((v4 & 7) == 2)
      {
        uint64_t v6 = RB::ProtobufDecoder::decode_data(this);
        uint64_t v8 = v7;
      }
      else
      {
        uint64_t v6 = 0;
        uint64_t v8 = 0;
        *((unsigned char *)this + 56) = 1;
        *(void *)this = *((void *)this + 1);
      }
      (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)v1 + 8))(&cf, v1, v6, v8);
      CFTypeRef v9 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        RB::ObjectTable::adopt((RB::Decoder *)((char *)this + 184), v9);
        if (cf) {
          CFRelease(cf);
        }
        CFTypeRef v5 = v9;
      }
      else
      {
        *((unsigned char *)this + 56) = 1;
        *(void *)this = *((void *)this + 1);
      }
    }
    else
    {
      RB::ProtobufDecoder::skip_field(this, v4);
    }
    uint64_t v4 = RB::ProtobufDecoder::next_field(this);
  }
  while (v4);
  return v5;
}

void sub_214137608(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *RB::Decoder::cgfont_field(RB::ProtobufDecoder *this, char a2)
{
  if (!*((void *)this + 9)) {
    return 0;
  }
  if ((a2 & 7) != 2)
  {
LABEL_28:
    uint64_t v7 = 0;
    uint64_t v12 = *((void *)this + 1);
    *((unsigned char *)this + 56) = 1;
    *(void *)this = v12;
    return v7;
  }
  RB::ProtobufDecoder::begin_message(this);
  uint64_t field = RB::ProtobufDecoder::next_field(this);
  if (!field)
  {
    unint64_t v5 = 0;
    unint64_t v6 = 0;
    goto LABEL_15;
  }
  unint64_t v4 = field;
  unint64_t v5 = 0;
  unint64_t v6 = 0;
  do
  {
    if ((v4 >> 3) == 2)
    {
      long long v13 = *(_OWORD *)this;
      RB::ProtobufDecoder::skip_field(this, v4);
      unint64_t v6 = v4;
    }
    else if ((v4 >> 3) == 1)
    {
      unint64_t v5 = RB::ProtobufDecoder::uint_field((uint64_t **)this, v4);
    }
    else
    {
      RB::ProtobufDecoder::skip_field(this, v4);
    }
    unint64_t v4 = RB::ProtobufDecoder::next_field(this);
  }
  while (v4);
  if (!(v5 >> 61))
  {
LABEL_15:
    v15[0] = 0;
    uint64_t v7 = RB::UntypedTable::lookup((RB::ProtobufDecoder *)((char *)this + 80), (uint64_t *)(v5 | 0x6000000000000000), v15);
    if ((void *)(v5 | 0x6000000000000000) == v15[0]) {
      goto LABEL_23;
    }
    long long v8 = v13;
    if (!v6)
    {
      RB::Decoder::saved_shared_field((uint64_t)this, 3, v5, (uint64_t)v15);
      LOBYTE(v6) = v16;
      if (!v16)
      {
LABEL_22:
        RB::UntypedTable::insert((size_t **)this + 10, (size_t *)(v5 | 0x6000000000000000), (size_t *)v7);
        goto LABEL_23;
      }
      long long v8 = *(_OWORD *)v15;
    }
    long long v9 = *(_OWORD *)this;
    *(_OWORD *)this = v8;
    if ((v6 & 7) == 2)
    {
      long long v14 = v9;
      RB::ProtobufDecoder::begin_message(this);
      long long v10 = (uint64_t *)RB::Decoder::decode_cgfont(this);
      long long v9 = v14;
      uint64_t v7 = v10;
      --*((void *)this + 5);
    }
    else
    {
      *((unsigned char *)this + 56) = 1;
    }
    *(_OWORD *)this = v9;
    goto LABEL_22;
  }
  uint64_t v7 = 0;
LABEL_23:
  if (!*((unsigned char *)this + 56) && *(void *)this <= *((void *)this + 1)) {
    *((void *)this + 1) = *(void *)(*((void *)this + 4) + 8 * *((void *)this + 5) - 8);
  }
  --*((void *)this + 5);
  if (!v7) {
    goto LABEL_28;
  }
  return v7;
}

int8x16_t RB::Decoder::affine_transform_field(size_t **this, char a2)
{
  float64x2_t v8 = (float64x2_t)xmmword_2142181C0;
  float64x2_t v9 = (float64x2_t)xmmword_2142181D0;
  float64x2_t v10 = 0uLL;
  if ((a2 & 7) == 2)
  {
    RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
    RB::AffineTransform::decode((RB::AffineTransform *)&v8, (RB::ProtobufDecoder *)this);
    if (!*((unsigned char *)this + 56) && *this <= this[1]) {
      this[1] = (size_t *)this[4][(void)this[5] - 1];
    }
    this[5] = (size_t *)((char *)this[5] - 1);
  }
  else
  {
    *((unsigned char *)this + 56) = 1;
    *this = this[1];
  }
  uint64_t v3 = (float64x2_t *)this[25];
  if (!v3
    || (int8x16_t result = vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v3[1], v9), (int8x16_t)vceqq_f64(*v3, v8)), (int8x16_t)vceqq_f64(v3[2], v10)), result.i64[0] = vandq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)result, 1), result).u64[0], (result.i64[0] & 0x8000000000000000) == 0))
  {
    unint64_t v5 = this[8];
    unint64_t v6 = (v5[2] + 15) & 0xFFFFFFFFFFFFFFF0;
    if (v6 + 48 > v5[3]) {
      unint64_t v6 = RB::Heap::alloc_slow(this[8], 0x30uLL, 15);
    }
    else {
      void v5[2] = v6 + 48;
    }
    int8x16_t result = (int8x16_t)v8;
    float64x2_t v7 = v10;
    *(float64x2_t *)(v6 + 16) = v9;
    *(float64x2_t *)(v6 + 32) = v7;
    *(int8x16_t *)unint64_t v6 = result;
    this[25] = (size_t *)v6;
  }
  return result;
}

atomic_uint *RB::Refcount<RB::Encoder::FontSet,std::atomic<unsigned int>>::release(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t RB::Refcount<RB::Encoder::FontSet,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

void RB::Encoder::FontSet::~FontSet(RB::Encoder::FontSet *this)
{
  *(void *)this = &unk_26C4E8710;
  std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::~__hash_table((uint64_t)this + 16);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26C4E8710;
  std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::~__hash_table((uint64_t)this + 16);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__deallocate_node(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      uint64_t v3 = (void *)*v2;
      RB::Encoder::FontSet::Font::~Font((RB::Encoder::FontSet::Font *)(v2 + 3));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void std::__introsort<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *,false>(unint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
  while (2)
  {
    unint64_t v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = a2 - v10;
          unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(a2 - v10) >> 3);
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                unint64_t v46 = *(void *)(a2 - 40);
                unint64_t v45 = a2 - 40;
                if (v46 < *(void *)v10)
                {
                  uint64_t v144 = *(void *)(v10 + 32);
                  long long v125 = *(_OWORD *)v10;
                  long long v134 = *(_OWORD *)(v10 + 16);
                  long long v47 = *(_OWORD *)v45;
                  long long v48 = *(_OWORD *)(v45 + 16);
                  *(void *)(v10 + 32) = *(void *)(v45 + 32);
                  *(_OWORD *)unint64_t v10 = v47;
                  *(_OWORD *)(v10 + 16) = v48;
                  *(void *)(v45 + 32) = v144;
                  *(_OWORD *)unint64_t v45 = v125;
                  *(_OWORD *)(v45 + 16) = v134;
                }
                break;
              case 3uLL:
                std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>((long long *)v10, (unint64_t *)(v10 + 40), (unint64_t *)(a2 - 40));
                break;
              case 4uLL:
                std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>(v10, v10 + 40, v10 + 80, a2 - 40);
                break;
              case 5uLL:
                float v49 = (long long *)(v10 + 40);
                float v50 = (long long *)(v10 + 80);
                unsigned int v51 = (long long *)(v10 + 120);
                std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>(v10, v10 + 40, v10 + 80, v10 + 120);
                unint64_t v53 = *(void *)(a2 - 40);
                unint64_t v52 = a2 - 40;
                if (v53 < *(void *)(v10 + 120))
                {
                  long long v54 = *v51;
                  long long v135 = *(_OWORD *)(v10 + 136);
                  uint64_t v55 = *(void *)(v10 + 152);
                  long long v57 = *(_OWORD *)v52;
                  long long v56 = *(_OWORD *)(v52 + 16);
                  *(void *)(v10 + 152) = *(void *)(v52 + 32);
                  *unsigned int v51 = v57;
                  *(_OWORD *)(v10 + 136) = v56;
                  *(void *)(v52 + 32) = v55;
                  *(_OWORD *)unint64_t v52 = v54;
                  *(_OWORD *)(v52 + 16) = v135;
                  if (*(void *)v51 < *(void *)v50)
                  {
                    uint64_t v58 = *(void *)(v10 + 112);
                    long long v60 = *v50;
                    long long v59 = *(_OWORD *)(v10 + 96);
                    long long v61 = *(_OWORD *)(v10 + 136);
                    *float v50 = *v51;
                    *(_OWORD *)(v10 + 96) = v61;
                    *(void *)(v10 + 112) = *(void *)(v10 + 152);
                    *unsigned int v51 = v60;
                    *(_OWORD *)(v10 + 136) = v59;
                    *(void *)(v10 + 152) = v58;
                    if (*(void *)v50 < *(void *)v49)
                    {
                      uint64_t v62 = *(void *)(v10 + 72);
                      long long v64 = *v49;
                      long long v63 = *(_OWORD *)(v10 + 56);
                      long long v65 = *(_OWORD *)(v10 + 96);
                      *float v49 = *v50;
                      *(_OWORD *)(v10 + 56) = v65;
                      *(void *)(v10 + 72) = *(void *)(v10 + 112);
                      *float v50 = v64;
                      *(_OWORD *)(v10 + 96) = v63;
                      *(void *)(v10 + 112) = v62;
                      if (*(void *)(v10 + 40) < *(void *)v10)
                      {
                        uint64_t v145 = *(void *)(v10 + 32);
                        long long v126 = *(_OWORD *)v10;
                        long long v136 = *(_OWORD *)(v10 + 16);
                        long long v66 = *(_OWORD *)(v10 + 56);
                        *(_OWORD *)unint64_t v10 = *v49;
                        *(_OWORD *)(v10 + 16) = v66;
                        *(void *)(v10 + 32) = *(void *)(v10 + 72);
                        *float v49 = v126;
                        *(_OWORD *)(v10 + 56) = v136;
                        *(void *)(v10 + 72) = v145;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 959)
          {
            unint64_t v67 = v10 + 40;
            BOOL v69 = v10 == a2 || v67 == a2;
            if (a4)
            {
              if (!v69)
              {
                uint64_t v70 = 0;
                unint64_t v71 = v10;
                do
                {
                  unint64_t v72 = v67;
                  unint64_t v73 = *(void *)(v71 + 40);
                  if (v73 < *(void *)v71)
                  {
                    long long v127 = *(_OWORD *)(v71 + 48);
                    long long v137 = *(_OWORD *)(v71 + 64);
                    uint64_t v74 = v70;
                    while (1)
                    {
                      uint64_t v75 = v10 + v74;
                      long long v76 = *(_OWORD *)(v10 + v74 + 16);
                      *(_OWORD *)(v75 + 40) = *(_OWORD *)(v10 + v74);
                      *(_OWORD *)(v75 + 56) = v76;
                      *(void *)(v75 + 72) = *(void *)(v10 + v74 + 32);
                      if (!v74) {
                        break;
                      }
                      v74 -= 40;
                      if (v73 >= *(void *)(v75 - 40))
                      {
                        uint64_t v77 = v10 + v74 + 40;
                        goto LABEL_80;
                      }
                    }
                    uint64_t v77 = v10;
LABEL_80:
                    *(void *)uint64_t v77 = v73;
                    *(_OWORD *)(v77 + 24) = v137;
                    *(_OWORD *)(v77 + 8) = v127;
                  }
                  unint64_t v67 = v72 + 40;
                  v70 += 40;
                  unint64_t v71 = v72;
                }
                while (v72 + 40 != a2);
              }
            }
            else if (!v69)
            {
              do
              {
                unint64_t v112 = v67;
                unint64_t v113 = *(void *)(a1 + 40);
                if (v113 < *(void *)a1)
                {
                  long long v130 = *(_OWORD *)(a1 + 48);
                  long long v140 = *(_OWORD *)(a1 + 64);
                  do
                  {
                    long long v114 = *(_OWORD *)(v67 - 24);
                    *(_OWORD *)unint64_t v67 = *(_OWORD *)(v67 - 40);
                    *(_OWORD *)(v67 + 16) = v114;
                    *(void *)(v67 + 32) = *(void *)(v67 - 8);
                    unint64_t v115 = *(void *)(v67 - 80);
                    v67 -= 40;
                  }
                  while (v113 < v115);
                  *(void *)unint64_t v67 = v113;
                  *(_OWORD *)(v67 + 24) = v140;
                  *(_OWORD *)(v67 + 8) = v130;
                }
                unint64_t v67 = v112 + 40;
                a1 = v112;
              }
              while (v112 + 40 != a2);
            }
            return;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v78 = (v12 - 2) >> 1;
              int64_t v79 = v78;
              do
              {
                int64_t v80 = v79;
                if (v78 >= v79)
                {
                  uint64_t v81 = (2 * v79) | 1;
                  unint64_t v82 = v10 + 40 * v81;
                  if (2 * v80 + 2 < (uint64_t)v12)
                  {
                    unint64_t v84 = *(void *)(v82 + 40);
                    BOOL v83 = *(void *)v82 >= v84;
                    if (*(void *)v82 > v84) {
                      unint64_t v84 = *(void *)v82;
                    }
                    if (!v83)
                    {
                      v82 += 40;
                      uint64_t v81 = 2 * v80 + 2;
                    }
                  }
                  else
                  {
                    unint64_t v84 = *(void *)v82;
                  }
                  unint64_t v85 = v10 + 40 * v80;
                  unint64_t v86 = *(void *)v85;
                  if (v84 >= *(void *)v85)
                  {
                    long long v128 = *(_OWORD *)(v85 + 8);
                    long long v138 = *(_OWORD *)(v85 + 24);
                    do
                    {
                      unint64_t v87 = v85;
                      unint64_t v85 = v82;
                      long long v88 = *(_OWORD *)v82;
                      long long v89 = *(_OWORD *)(v82 + 16);
                      *(void *)(v87 + 32) = *(void *)(v82 + 32);
                      *(_OWORD *)unint64_t v87 = v88;
                      *(_OWORD *)(v87 + 16) = v89;
                      if (v78 < v81) {
                        break;
                      }
                      uint64_t v90 = (2 * v81) | 1;
                      unint64_t v82 = v10 + 40 * v90;
                      uint64_t v81 = 2 * v81 + 2;
                      if (v81 < (uint64_t)v12)
                      {
                        unint64_t v93 = *(void *)v82;
                        unint64_t v91 = *(void *)(v82 + 40);
                        BOOL v92 = *(void *)v82 >= v91;
                        if (*(void *)v82 <= v91) {
                          unint64_t v93 = *(void *)(v82 + 40);
                        }
                        if (*(void *)v82 < v91) {
                          v82 += 40;
                        }
                        if (v92) {
                          uint64_t v81 = v90;
                        }
                      }
                      else
                      {
                        unint64_t v93 = *(void *)v82;
                        uint64_t v81 = v90;
                      }
                    }
                    while (v93 >= v86);
                    *(void *)unint64_t v85 = v86;
                    *(_OWORD *)(v85 + 24) = v138;
                    *(_OWORD *)(v85 + 8) = v128;
                  }
                }
                int64_t v79 = v80 - 1;
              }
              while (v80);
              int64_t v94 = v11 / 0x28uLL;
              do
              {
                uint64_t v95 = 0;
                uint64_t v146 = *(void *)(v10 + 32);
                long long v129 = *(_OWORD *)v10;
                long long v139 = *(_OWORD *)(v10 + 16);
                unint64_t v96 = v10;
                do
                {
                  uint64_t v97 = v96 + 40 * v95 + 40;
                  uint64_t v98 = (2 * v95) | 1;
                  uint64_t v99 = 2 * v95 + 2;
                  if (v99 < v94 && *(void *)v97 < *(void *)(v97 + 40))
                  {
                    v97 += 40;
                    uint64_t v98 = v99;
                  }
                  long long v100 = *(_OWORD *)v97;
                  long long v101 = *(_OWORD *)(v97 + 16);
                  *(void *)(v96 + 32) = *(void *)(v97 + 32);
                  *(_OWORD *)unint64_t v96 = v100;
                  *(_OWORD *)(v96 + 16) = v101;
                  unint64_t v96 = v97;
                  uint64_t v95 = v98;
                }
                while (v98 <= (uint64_t)((unint64_t)(v94 - 2) >> 1));
                a2 -= 40;
                if (v97 == a2)
                {
                  *(void *)(v97 + 32) = v146;
                  *(_OWORD *)uint64_t v97 = v129;
                  *(_OWORD *)(v97 + 16) = v139;
                }
                else
                {
                  long long v102 = *(_OWORD *)a2;
                  long long v103 = *(_OWORD *)(a2 + 16);
                  *(void *)(v97 + 32) = *(void *)(a2 + 32);
                  *(_OWORD *)uint64_t v97 = v102;
                  *(_OWORD *)(v97 + 16) = v103;
                  *(void *)(a2 + 32) = v146;
                  *(_OWORD *)a2 = v129;
                  *(_OWORD *)(a2 + 16) = v139;
                  uint64_t v104 = v97 - v10 + 40;
                  if (v104 >= 41)
                  {
                    unint64_t v105 = (v104 / 0x28uLL - 2) >> 1;
                    uint64_t v106 = v10 + 40 * v105;
                    unint64_t v107 = *(void *)v97;
                    if (*(void *)v106 < *(void *)v97)
                    {
                      long long v118 = *(_OWORD *)(v97 + 8);
                      long long v121 = *(_OWORD *)(v97 + 24);
                      do
                      {
                        uint64_t v108 = v97;
                        uint64_t v97 = v106;
                        long long v109 = *(_OWORD *)v106;
                        long long v110 = *(_OWORD *)(v106 + 16);
                        *(void *)(v108 + 32) = *(void *)(v106 + 32);
                        *(_OWORD *)uint64_t v108 = v109;
                        *(_OWORD *)(v108 + 16) = v110;
                        if (!v105) {
                          break;
                        }
                        unint64_t v105 = (v105 - 1) >> 1;
                        uint64_t v106 = v10 + 40 * v105;
                      }
                      while (*(void *)v106 < v107);
                      *(void *)uint64_t v97 = v107;
                      *(_OWORD *)(v97 + 24) = v121;
                      *(_OWORD *)(v97 + 8) = v118;
                    }
                  }
                }
              }
              while (v94-- > 2);
            }
            return;
          }
          unint64_t v13 = v12 >> 1;
          unint64_t v14 = v10 + 40 * (v12 >> 1);
          if ((unint64_t)v11 >= 0x1401)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>((long long *)a1, (unint64_t *)(a1 + 40 * (v12 >> 1)), (unint64_t *)(a2 - 40));
            uint64_t v15 = 5 * v13;
            uint64_t v16 = (unint64_t *)(a1 + 40 * v13 - 40);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>((long long *)(a1 + 40), v16, (unint64_t *)(a2 - 80));
            uint64_t v17 = (unint64_t *)(a1 + 40 + 8 * v15);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>((long long *)(a1 + 80), v17, (unint64_t *)(a2 - 120));
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>((long long *)v16, (unint64_t *)v14, v17);
            uint64_t v141 = *(void *)(a1 + 32);
            long long v122 = *(_OWORD *)a1;
            long long v131 = *(_OWORD *)(a1 + 16);
            long long v18 = *(_OWORD *)v14;
            long long v19 = *(_OWORD *)(v14 + 16);
            *(void *)(a1 + 32) = *(void *)(v14 + 32);
            *(_OWORD *)a1 = v18;
            *(_OWORD *)(a1 + 16) = v19;
            *(void *)(v14 + 32) = v141;
            *(_OWORD *)unint64_t v14 = v122;
            *(_OWORD *)(v14 + 16) = v131;
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>((long long *)(a1 + 40 * (v12 >> 1)), (unint64_t *)a1, (unint64_t *)(a2 - 40));
          }
          --a3;
          unint64_t v20 = *(void *)a1;
          if ((a4 & 1) != 0 || *(void *)(a1 - 40) < v20) {
            break;
          }
          long long v117 = *(_OWORD *)(a1 + 8);
          long long v120 = *(_OWORD *)(a1 + 24);
          if (v20 >= *(void *)(a2 - 40))
          {
            unint64_t v36 = a1 + 40;
            do
            {
              unint64_t v10 = v36;
              if (v36 >= a2) {
                break;
              }
              v36 += 40;
            }
            while (v20 >= *(void *)v10);
          }
          else
          {
            unint64_t v10 = a1;
            do
            {
              unint64_t v35 = *(void *)(v10 + 40);
              v10 += 40;
            }
            while (v20 >= v35);
          }
          unint64_t v37 = a2;
          if (v10 < a2)
          {
            unint64_t v37 = a2;
            do
            {
              unint64_t v38 = *(void *)(v37 - 40);
              v37 -= 40;
            }
            while (v20 < v38);
          }
          while (v10 < v37)
          {
            uint64_t v143 = *(void *)(v10 + 32);
            long long v124 = *(_OWORD *)v10;
            long long v133 = *(_OWORD *)(v10 + 16);
            long long v39 = *(_OWORD *)v37;
            long long v40 = *(_OWORD *)(v37 + 16);
            *(void *)(v10 + 32) = *(void *)(v37 + 32);
            *(_OWORD *)unint64_t v10 = v39;
            *(_OWORD *)(v10 + 16) = v40;
            *(void *)(v37 + 32) = v143;
            *(_OWORD *)unint64_t v37 = v124;
            *(_OWORD *)(v37 + 16) = v133;
            do
            {
              unint64_t v41 = *(void *)(v10 + 40);
              v10 += 40;
            }
            while (v20 >= v41);
            do
            {
              unint64_t v42 = *(void *)(v37 - 40);
              v37 -= 40;
            }
            while (v20 < v42);
          }
          BOOL v4 = v10 - 40 >= a1;
          BOOL v5 = v10 - 40 == a1;
          if (v10 - 40 != a1)
          {
            long long v43 = *(_OWORD *)(v10 - 40);
            long long v44 = *(_OWORD *)(v10 - 24);
            *(void *)(a1 + 32) = *(void *)(v10 - 8);
            *(_OWORD *)a1 = v43;
            *(_OWORD *)(a1 + 16) = v44;
          }
          a4 = 0;
          *(void *)(v10 - 40) = v20;
          *(_OWORD *)(v10 - 32) = v117;
          *(_OWORD *)(v10 - 16) = v120;
        }
        uint64_t v21 = 0;
        long long v116 = *(_OWORD *)(a1 + 8);
        long long v119 = *(_OWORD *)(a1 + 24);
        do
        {
          unint64_t v22 = *(void *)(a1 + v21 + 40);
          v21 += 40;
        }
        while (v22 < v20);
        unint64_t v23 = a1 + v21;
        unint64_t v24 = a2;
        if (v21 == 40)
        {
          unint64_t v24 = a2;
          do
          {
            if (v23 >= v24) {
              break;
            }
            unint64_t v26 = *(void *)(v24 - 40);
            v24 -= 40;
          }
          while (v26 >= v20);
        }
        else
        {
          do
          {
            unint64_t v25 = *(void *)(v24 - 40);
            v24 -= 40;
          }
          while (v25 >= v20);
        }
        unint64_t v10 = a1 + v21;
        if (v23 < v24)
        {
          unint64_t v27 = v24;
          do
          {
            uint64_t v142 = *(void *)(v10 + 32);
            long long v123 = *(_OWORD *)v10;
            long long v132 = *(_OWORD *)(v10 + 16);
            long long v28 = *(_OWORD *)v27;
            long long v29 = *(_OWORD *)(v27 + 16);
            *(void *)(v10 + 32) = *(void *)(v27 + 32);
            *(_OWORD *)unint64_t v10 = v28;
            *(_OWORD *)(v10 + 16) = v29;
            *(void *)(v27 + 32) = v142;
            *(_OWORD *)unint64_t v27 = v123;
            *(_OWORD *)(v27 + 16) = v132;
            do
            {
              unint64_t v30 = *(void *)(v10 + 40);
              v10 += 40;
            }
            while (v30 < v20);
            do
            {
              unint64_t v31 = *(void *)(v27 - 40);
              v27 -= 40;
            }
            while (v31 >= v20);
          }
          while (v10 < v27);
        }
        if (v10 - 40 != a1)
        {
          long long v32 = *(_OWORD *)(v10 - 40);
          long long v33 = *(_OWORD *)(v10 - 24);
          *(void *)(a1 + 32) = *(void *)(v10 - 8);
          *(_OWORD *)a1 = v32;
          *(_OWORD *)(a1 + 16) = v33;
        }
        *(void *)(v10 - 40) = v20;
        *(_OWORD *)(v10 - 32) = v116;
        *(_OWORD *)(v10 - 16) = v119;
        if (v23 >= v24) {
          break;
        }
LABEL_30:
        std::__introsort<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *,false>(a1, v10 - 40, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v34 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>(a1, v10 - 40);
      if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>(v10, a2))
      {
        break;
      }
      if (!v34) {
        goto LABEL_30;
      }
    }
    a2 = v10 - 40;
    if (!v34) {
      continue;
    }
    break;
  }
}

long long *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>(long long *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *a3;
  if (*a2 >= *(void *)result)
  {
    if (v4 < v3)
    {
      long long v10 = *(_OWORD *)a2;
      long long v11 = *((_OWORD *)a2 + 1);
      uint64_t v12 = a2[4];
      uint64_t v13 = a3[4];
      long long v14 = *((_OWORD *)a3 + 1);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_OWORD *)a2 + 1) = v14;
      a2[4] = v13;
      a3[4] = v12;
      *(_OWORD *)a3 = v10;
      *((_OWORD *)a3 + 1) = v11;
      if (*a2 < *(void *)result)
      {
        long long v15 = *result;
        long long v16 = result[1];
        uint64_t v17 = *((void *)result + 4);
        uint64_t v18 = a2[4];
        long long v19 = *((_OWORD *)a2 + 1);
        *int8x16_t result = *(_OWORD *)a2;
        result[1] = v19;
        *((void *)result + 4) = v18;
        a2[4] = v17;
        *(_OWORD *)a2 = v15;
        *((_OWORD *)a2 + 1) = v16;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      long long v20 = *result;
      long long v21 = result[1];
      uint64_t v22 = *((void *)result + 4);
      uint64_t v23 = a2[4];
      long long v24 = *((_OWORD *)a2 + 1);
      *int8x16_t result = *(_OWORD *)a2;
      result[1] = v24;
      *((void *)result + 4) = v23;
      a2[4] = v22;
      *(_OWORD *)a2 = v20;
      *((_OWORD *)a2 + 1) = v21;
      if (*a3 >= *a2) {
        return result;
      }
      long long v5 = *(_OWORD *)a2;
      long long v6 = *((_OWORD *)a2 + 1);
      uint64_t v7 = a2[4];
      uint64_t v25 = a3[4];
      long long v26 = *((_OWORD *)a3 + 1);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_OWORD *)a2 + 1) = v26;
      a2[4] = v25;
    }
    else
    {
      long long v5 = *result;
      long long v6 = result[1];
      uint64_t v7 = *((void *)result + 4);
      uint64_t v8 = a3[4];
      long long v9 = *((_OWORD *)a3 + 1);
      *int8x16_t result = *(_OWORD *)a3;
      result[1] = v9;
      *((void *)result + 4) = v8;
    }
    a3[4] = v7;
    *(_OWORD *)a3 = v5;
    *((_OWORD *)a3 + 1) = v6;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(0xCCCCCCCCCCCCCCCDLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      long long v6 = (long long *)(a2 - 40);
      if (*(void *)(a2 - 40) < *(void *)a1)
      {
        long long v7 = *(_OWORD *)a1;
        long long v8 = *(_OWORD *)(a1 + 16);
        uint64_t v9 = *(void *)(a1 + 32);
        uint64_t v10 = *(void *)(a2 - 8);
        long long v11 = *(_OWORD *)(a2 - 24);
        *(_OWORD *)a1 = *v6;
        *(_OWORD *)(a1 + 16) = v11;
        *(void *)(a1 + 32) = v10;
        *(void *)(a2 - 8) = v9;
        long long *v6 = v7;
        *(_OWORD *)(a2 - 24) = v8;
      }
      return result;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>((long long *)a1, (unint64_t *)(a1 + 40), (unint64_t *)(a2 - 40));
      return 1;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>(a1, a1 + 40, a1 + 80, a2 - 40);
      return 1;
    case 5uLL:
      long long v21 = (void *)(a1 + 40);
      uint64_t v22 = (void *)(a1 + 80);
      uint64_t v23 = (long long *)(a1 + 120);
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>(a1, a1 + 40, a1 + 80, a1 + 120);
      unint64_t v25 = *(void *)(a2 - 40);
      uint64_t v24 = a2 - 40;
      if (v25 >= *(void *)(a1 + 120)) {
        return 1;
      }
      long long v26 = *v23;
      long long v27 = *(_OWORD *)(a1 + 136);
      uint64_t v28 = *(void *)(a1 + 152);
      uint64_t v29 = *(void *)(v24 + 32);
      long long v30 = *(_OWORD *)(v24 + 16);
      *uint64_t v23 = *(_OWORD *)v24;
      *(_OWORD *)(a1 + 136) = v30;
      *(void *)(a1 + 152) = v29;
      *(void *)(v24 + 32) = v28;
      *(_OWORD *)uint64_t v24 = v26;
      *(_OWORD *)(v24 + 16) = v27;
      if (*(void *)v23 >= *v22) {
        return 1;
      }
      uint64_t v31 = *(void *)(a1 + 112);
      long long v33 = *(_OWORD *)v22;
      long long v32 = *(_OWORD *)(a1 + 96);
      long long v34 = *(_OWORD *)(a1 + 136);
      *(_OWORD *)uint64_t v22 = *v23;
      *(_OWORD *)(a1 + 96) = v34;
      *(void *)(a1 + 112) = *(void *)(a1 + 152);
      *uint64_t v23 = v33;
      *(_OWORD *)(a1 + 136) = v32;
      *(void *)(a1 + 152) = v31;
      if (*v22 >= *v21) {
        return 1;
      }
      uint64_t v35 = *(void *)(a1 + 72);
      long long v37 = *(_OWORD *)v21;
      long long v36 = *(_OWORD *)(a1 + 56);
      long long v38 = *(_OWORD *)(a1 + 96);
      *(_OWORD *)long long v21 = *(_OWORD *)v22;
      *(_OWORD *)(a1 + 56) = v38;
      *(void *)(a1 + 72) = *(void *)(a1 + 112);
      *(_OWORD *)uint64_t v22 = v37;
      *(_OWORD *)(a1 + 96) = v36;
      *(void *)(a1 + 112) = v35;
      if (*(void *)(a1 + 40) >= *(void *)a1) {
        return 1;
      }
      uint64_t v39 = *(void *)(a1 + 32);
      long long v41 = *(_OWORD *)a1;
      long long v40 = *(_OWORD *)(a1 + 16);
      long long v42 = *(_OWORD *)(a1 + 56);
      *(_OWORD *)a1 = *(_OWORD *)v21;
      *(_OWORD *)(a1 + 16) = v42;
      *(void *)(a1 + 32) = *(void *)(a1 + 72);
      *(_OWORD *)long long v21 = v41;
      *(_OWORD *)(a1 + 56) = v40;
      BOOL result = 1;
      *(void *)(a1 + 72) = v39;
      return result;
    default:
      uint64_t v12 = (void *)(a1 + 80);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>((long long *)a1, (unint64_t *)(a1 + 40), (unint64_t *)(a1 + 80));
      uint64_t v13 = a1 + 120;
      if (a1 + 120 == a2) {
        return 1;
      }
      uint64_t v14 = 0;
      int v15 = 0;
      break;
  }
  while (1)
  {
    unint64_t v16 = *(void *)v13;
    if (*(void *)v13 < *v12)
    {
      long long v43 = *(_OWORD *)(v13 + 8);
      long long v44 = *(_OWORD *)(v13 + 24);
      uint64_t v17 = v14;
      while (1)
      {
        uint64_t v18 = a1 + v17;
        long long v19 = *(_OWORD *)(a1 + v17 + 96);
        *(_OWORD *)(v18 + 120) = *(_OWORD *)(a1 + v17 + 80);
        *(_OWORD *)(v18 + 136) = v19;
        *(void *)(v18 + 152) = *(void *)(a1 + v17 + 112);
        if (v17 == -80) {
          break;
        }
        v17 -= 40;
        if (v16 >= *(void *)(v18 + 40))
        {
          uint64_t v20 = a1 + v17 + 120;
          goto LABEL_13;
        }
      }
      uint64_t v20 = a1;
LABEL_13:
      *(void *)uint64_t v20 = v16;
      *(_OWORD *)(v20 + 8) = v43;
      *(_OWORD *)(v20 + 24) = v44;
      if (++v15 == 8) {
        return v13 + 40 == a2;
      }
    }
    uint64_t v12 = (void *)v13;
    v14 += 40;
    v13 += 40;
    if (v13 == a2) {
      return 1;
    }
  }
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>((long long *)a1, (unint64_t *)a2, (unint64_t *)a3);
  if (*(void *)a4 < *(void *)a3)
  {
    __n128 result = *(__n128 *)a3;
    long long v9 = *(_OWORD *)(a3 + 16);
    uint64_t v10 = *(void *)(a3 + 32);
    uint64_t v11 = *(void *)(a4 + 32);
    long long v12 = *(_OWORD *)(a4 + 16);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_OWORD *)(a3 + 16) = v12;
    *(void *)(a3 + 32) = v11;
    *(void *)(a4 + 32) = v10;
    *(__n128 *)a4 = result;
    *(_OWORD *)(a4 + 16) = v9;
    if (*(void *)a3 < *(void *)a2)
    {
      __n128 result = *(__n128 *)a2;
      long long v13 = *(_OWORD *)(a2 + 16);
      uint64_t v14 = *(void *)(a2 + 32);
      uint64_t v15 = *(void *)(a3 + 32);
      long long v16 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)(a2 + 16) = v16;
      *(void *)(a2 + 32) = v15;
      *(void *)(a3 + 32) = v14;
      *(__n128 *)a3 = result;
      *(_OWORD *)(a3 + 16) = v13;
      if (*(void *)a2 < *(void *)a1)
      {
        __n128 result = *(__n128 *)a1;
        long long v17 = *(_OWORD *)(a1 + 16);
        uint64_t v18 = *(void *)(a1 + 32);
        uint64_t v19 = *(void *)(a2 + 32);
        long long v20 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v20;
        *(void *)(a1 + 32) = v19;
        *(void *)(a2 + 32) = v18;
        *(__n128 *)a2 = result;
        *(_OWORD *)(a2 + 16) = v17;
      }
    }
  }
  return result;
}

void *RB::vector<unsigned char,0ul,unsigned long>::reserve_slow(uint64_t a1, size_t a2)
{
  if (*(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1);
  }
  __n128 result = RB::details::realloc_vector<unsigned long,1ul>(*(void **)a1, (size_t *)(a1 + 16), v3);
  *(void *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,1ul>(void *a1, size_t *a2, size_t size)
{
  uint64_t v4 = a1;
  if (size)
  {
    size_t v5 = malloc_good_size(size);
    if (v5 != *a2)
    {
      size_t v6 = v5;
      long long v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7) {
        RB::precondition_failure((RB *)"allocation failure", v8);
      }
      uint64_t v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(uint64_t a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v7 <= v6) {
        unint64_t v4 = v6 % v7;
      }
    }
    else
    {
      unint64_t v4 = (v7 - 1) & v6;
    }
    long long v9 = *(uint64_t **)(*(void *)a1 + 8 * v4);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = *(void *)i)
      {
        unint64_t v11 = *(void *)(i + 8);
        if (v11 == v6)
        {
          if (*(_DWORD *)(i + 16) == v6) {
            return i;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v4) {
            break;
          }
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(a1, *a2, a4, (uint64_t)v21);
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v4 = v6 % v7;
      }
      else {
        unint64_t v4 = v6;
      }
    }
    else
    {
      unint64_t v4 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void **)(*(void *)a1 + 8 * v4);
  if (v18)
  {
    *(void *)v21[0] = *v18;
    *uint64_t v18 = v21[0];
  }
  else
  {
    *(void *)v21[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v21[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v21[0])
    {
      unint64_t v19 = *(void *)(*(void *)v21[0] + 8);
      if ((v7 & (v7 - 1)) != 0)
      {
        if (v19 >= v7) {
          v19 %= v7;
        }
      }
      else
      {
        v19 &= v7 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v19) = v21[0];
    }
  }
  uint64_t i = v21[0];
  v21[0] = 0;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,void *>>>>::reset[abi:nn180100](v21, 0);
  return i;
}

void sub_214138B24(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,void *>>>>::reset[abi:nn180100]((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _DWORD **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  uint8x8_t v8 = operator new(0x48uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  *uint8x8_t v8 = 0;
  v8[1] = a2;
  uint64_t result = std::pair<unsigned int const,RB::Encoder::FontSet::Font>::pair[abi:nn180100]<unsigned int &&>((uint64_t)(v8 + 2), *a3);
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_214138B94(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,void *>>>>::reset[abi:nn180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::__throw_bad_array_new_length[abi:nn180100]()
{
}

uint64_t std::pair<unsigned int const,RB::Encoder::FontSet::Font>::pair[abi:nn180100]<unsigned int &&>(uint64_t a1, _DWORD *a2)
{
  *(_DWORD *)a1 = *a2;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 24) = CGFontIndexSetCreate();
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  return a1;
}

void sub_214138C14(_Unwind_Exception *exception_object)
{
  unint64_t v4 = *(const void **)(v1 + 16);
  if (v4) {
    CFRelease(v4);
  }
  if (*v2) {
    CFRelease(*v2);
  }
  _Unwind_Resume(exception_object);
}

void std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(void *)&v4) {
    goto LABEL_16;
  }
  if (prime < *(void *)&v4)
  {
    unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      unint64_t v5 = std::__next_prime(v5);
    }
    else
    {
      uint64_t v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2) {
        unint64_t v5 = v7;
      }
    }
    if (prime <= v5) {
      size_t prime = v5;
    }
    if (prime < *(void *)&v4)
    {
LABEL_16:
      std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__do_rehash<true>(a1, prime);
    }
  }
}

void std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    int8x8_t v4 = operator new(8 * a2);
    unint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0;
    *(void *)(a1 + 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    uint64_t v7 = *(void **)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2) {
          v8 %= a2;
        }
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v8) = a1 + 16;
      unint64_t v11 = (void *)*v7;
      if (*v7)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2) {
              v12 %= a2;
            }
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(void *)(*(void *)a1 + 8 * v12))
            {
              *(void *)(*(void *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            *uint64_t v7 = *v11;
            *unint64_t v11 = **(void **)(*(void *)a1 + 8 * v12);
            **(void **)(*(void *)a1 + 8 * v12) = v11;
            unint64_t v11 = v7;
          }
          unint64_t v12 = v8;
LABEL_24:
          uint64_t v7 = v11;
          unint64_t v11 = (void *)*v11;
          unint64_t v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    uint64_t v10 = *(void **)a1;
    *(void *)a1 = 0;
    if (v10) {
      operator delete(v10);
    }
    *(void *)(a1 + 8) = 0;
  }
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,void *>>>>::reset[abi:nn180100](uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16)) {
      RB::Encoder::FontSet::Font::~Font((RB::Encoder::FontSet::Font *)(v2 + 24));
    }
    operator delete((void *)v2);
  }
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::find<unsigned int>(void *a1, unsigned int *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (*(void *)&v2 <= v3) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (v2.i32[0] - 1) & v3;
  }
  uint64_t v6 = *(uint64_t ***)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  for (uint64_t result = *v6; result; uint64_t result = (uint64_t *)*result)
  {
    unint64_t v8 = result[1];
    if (v8 == v3)
    {
      if (*((_DWORD *)result + 4) == v3) {
        return result;
      }
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(void *)&v2) {
          v8 %= *(void *)&v2;
        }
      }
      else
      {
        v8 &= *(void *)&v2 - 1;
      }
      if (v8 != v5) {
        return 0;
      }
    }
  }
  return result;
}

void *RB::vector<RB::Decoder::SharedField,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1) <= a2) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1);
  }
  uint64_t result = RB::details::realloc_vector<unsigned long,40ul>(*(void **)a1, (unint64_t *)(a1 + 16), v3);
  *(void *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,40ul>(void *a1, unint64_t *a2, uint64_t a3)
{
  uint8x8_t v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(40 * a3);
    unint64_t v6 = v5 / 0x28;
    if (v5 / 0x28 != *a2)
    {
      uint64_t v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7) {
        RB::precondition_failure((RB *)"allocation failure", v8);
      }
      uint8x8_t v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

uint64_t RB::Path::Accumulator::Accumulator(uint64_t a1, uint64_t a2, uint64_t *a3, float64x2_t *a4, float a5, float32x2_t a6, float32x2_t a7)
{
  if (RBPathGetBezierOrder(*a3, a3[1]) == 1) {
    char v14 = 2;
  }
  else {
    char v14 = 4;
  }
  *(void *)a1 = &unk_26C4ED7F0;
  *(void *)(a1 + 8) = a2;
  RB::Path::Flattener::Flattener(a1 + 16, (void (***)(void))a1, a5, a6, a7);
  *(void *)(a1 + 248) = 0;
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 264) = 4;
  *(void *)(a1 + 272) = 0;
  *(unsigned char *)(a1 + 280) = 0;
  *(unsigned char *)(a1 + 281) = v14;
  *(void *)(a1 + 288) = -1;
  *(_DWORD *)(a1 + 296) = 0;
  v15.i64[0] = *(void *)(a1 + 48);
  RB::Rect::from_bounds(*(float32x2_t *)(a1 + 40), v15);
  RB::Coverage::Path::map((uint64_t)a3, (void (***)(void))(a1 + 16), a4);
  if (*(unsigned char *)(a1 + 280)) {
    RB::Path::Accumulator::commit_buffer((RB::Path::Accumulator *)a1);
  }
  return a1;
}

void sub_214139170(_Unwind_Exception *a1)
{
  RB::Path::Accumulator::~Accumulator(v1);
  _Unwind_Resume(a1);
}

void RB::Path::Accumulator::~Accumulator(RB::Path::Accumulator *this)
{
  if (*((unsigned char *)this + 280)) {
    RB::Path::Accumulator::commit_buffer(this);
  }
  int8x8_t v2 = (void *)*((void *)this + 31);
  if (v2) {
    free(v2);
  }
}

void sub_2141391C4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)(v1 + 248);
  if (v3) {
    free(v3);
  }
  _Unwind_Resume(exception_object);
}

void *RB::Path::Accumulator::new_buffer(RB::RenderFrame **this)
{
  uint64_t result = RB::RenderFrame::alloc_buffer_region(this[1], (RB::Device *)0x200, 0, 1, &v10);
  uint64_t v3 = v10;
  if (v10)
  {
    uint8x8_t v4 = this[32];
    size_t v5 = (size_t)v4 + 1;
    if (this[33] < (RB::RenderFrame *)((char *)v4 + 1))
    {
      uint64_t result = RB::vector<RB::Path::Buffer,4ul,unsigned long>::reserve_slow(this + 15, v5);
      uint8x8_t v4 = this[32];
      uint64_t v3 = v10;
      size_t v5 = (size_t)v4 + 1;
    }
    unint64_t v6 = this[31];
    if (!v6) {
      unint64_t v6 = (RB::RenderFrame *)(this + 15);
    }
    uint64_t v7 = (char *)v6 + 32 * (void)v4;
    char v8 = *((unsigned char *)this + 281);
    *(void *)uint64_t v7 = v3;
    *(_OWORD *)(v7 + 8) = v11;
    *((_DWORD *)v7 + 6) = 0;
    v7[28] = v8;
    this[32] = (RB::RenderFrame *)v5;
    if (this[36] == this[34]) {
      uint64_t v9 = 0;
    }
    else {
      uint64_t v9 = -1;
    }
    this[36] = (RB::RenderFrame *)v9;
    this[37] = 0;
    this[34] = 0;
    *((unsigned char *)this + 280) = 1;
    *((_DWORD *)this + 76) = 0;
  }
  return result;
}

char *RB::Path::Accumulator::push_back(char *this, double a2, double a3)
{
  size_t v5 = this;
  if (this[281] == 2)
  {
    if (this[280])
    {
      uint64_t v6 = *((void *)this + 34);
      uint64_t v7 = 8 * v6;
      char v8 = (char *)*((void *)this + 31);
      uint64_t v9 = *((void *)this + 32);
      if (v8) {
        uint64_t v10 = (char *)*((void *)this + 31);
      }
      else {
        uint64_t v10 = this + 120;
      }
      uint64_t v11 = v9 - 1;
      if ((unint64_t)(8 * v6 + 24) <= *(void *)&v10[32 * v9 - 16])
      {
LABEL_9:
        if (!v8) {
          char v8 = (char *)(v5 + 15);
        }
        unint64_t v12 = (double *)(*(void *)(*(void *)&v8[32 * v11] + 56) + *(void *)&v8[32 * v11 + 8] + v7);
        if (v6)
        {
          if (v5[36] != v6)
          {
LABEL_19:
            *unint64_t v12 = a3;
            ++v5[34];
            return this;
          }
          *(int32x2_t *)unint64_t v12 = vdup_n_s32(0x7F800000u);
          float v13 = v12 + 1;
          uint64_t v14 = 2;
        }
        else
        {
          uint64_t v14 = 1;
          float v13 = v12;
        }
        v12 += v14;
        *float v13 = a2;
        v5[34] += v14;
        goto LABEL_19;
      }
      RB::Path::Accumulator::commit_buffer((RB::Path::Accumulator *)this);
    }
    this = (char *)RB::Path::Accumulator::new_buffer((RB::RenderFrame **)v5);
    uint64_t v6 = v5[34];
    char v8 = (char *)v5[31];
    uint64_t v11 = v5[32] - 1;
    uint64_t v7 = 8 * v6;
    goto LABEL_9;
  }
  return (char *)RB::Path::FlattenedConsumer::push_back((uint64_t)this);
}

unsigned char *RB::Path::Accumulator::push_back(unsigned char *this, unsigned int a2, float32x2_t a3, double a4, double a5, double a6)
{
  uint64_t v11 = (uint64_t)this;
  if (!this[280]) {
    goto LABEL_8;
  }
  if (this[281] != 4
    || ((uint64_t v12 = *((void *)this + 34), v13 = 32 * v12, v14 = *((void *)this + 31), v15 = *((void *)this + 32), v14)
      ? (unint64_t v16 = (char *)*((void *)this + 31))
      : (unint64_t v16 = this + 120),
        uint64_t v17 = v15 - 1,
        (unint64_t)(32 * v12 + 64) > *(void *)&v16[32 * v15 - 16]))
  {
    RB::Path::Accumulator::commit_buffer((RB::Path::Accumulator *)this);
LABEL_8:
    *(unsigned char *)(v11 + 281) = 4;
    this = RB::Path::Accumulator::new_buffer((RB::RenderFrame **)v11);
    uint64_t v12 = *(void *)(v11 + 272);
    uint64_t v14 = *(void *)(v11 + 248);
    uint64_t v17 = *(void *)(v11 + 256) - 1;
    uint64_t v13 = 32 * v12;
  }
  if (!v14) {
    uint64_t v14 = v11 + 120;
  }
  uint64_t v18 = *(void *)(*(void *)(v14 + 32 * v17) + 56) + *(void *)(v14 + 32 * v17 + 8) + v13;
  if (!v12
    || (uint32x2_t v19 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(*(float32x2_t *)(v18 - 8), a3)),
        (vpmax_u32(v19, v19).u32[0] & 0x80000000) != 0))
  {
    *(_DWORD *)uint64_t v18 = *(_DWORD *)(v11 + 296);
    *(_DWORD *)(v18 + 4) = 0;
    int32x2_t v20 = vdup_n_s32(0x7F800000u);
    *(int32x2_t *)(v18 + 8) = v20;
    *(int32x2_t *)(v18 + 16) = v20;
    *(double *)(v18 + 24) = *(double *)&a3;
    v18 += 32;
    ++*(void *)(v11 + 272);
  }
  *(_DWORD *)uint64_t v18 = *(_DWORD *)(v11 + 296);
  *(float *)(v18 + 4) = 1.0 / (float)a2;
  *(double *)(v18 + 8) = a4;
  *(double *)(v18 + 16) = a5;
  *(double *)(v18 + 24) = a6;
  ++*(void *)(v11 + 272);
  *(_DWORD *)(v11 + 296) += a2;
  unsigned int v21 = *(_DWORD *)(v11 + 304);
  if (v21 <= a2) {
    unsigned int v21 = a2;
  }
  *(_DWORD *)(v11 + 304) = v21;
  return this;
}

uint64_t RB::Path::Accumulator::pop_back(RB::Path::Accumulator *this)
{
  if (!*((unsigned char *)this + 280)) {
    return 0;
  }
  uint64_t v1 = *((void *)this + 34);
  if (!v1) {
    return 0;
  }
  *((void *)this + 34) = v1 - 1;
  if (*((unsigned char *)this + 281) == 4)
  {
    int8x8_t v2 = (char *)this + 120;
    if (*((void *)this + 31)) {
      int8x8_t v2 = (char *)*((void *)this + 31);
    }
    uint64_t v3 = (int *)(*(void *)(*(void *)&v2[32 * *((void *)this + 32) - 32] + 56)
               + *(void *)&v2[32 * *((void *)this + 32) - 24]
               + 32 * (v1 - 1));
    int v4 = *(v3 - 8);
    int v5 = *v3;
    if (v4 == v5) {
      *((void *)this + 34) = v1 - 2;
    }
    *((_DWORD *)this + 74) = v5;
  }
  return 1;
}

uint64_t RB::Path::Accumulator::commit_buffer(RB::Path::Accumulator *this)
{
  uint64_t v2 = *((void *)this + 32);
  if (*((void *)this + 31)) {
    uint64_t v3 = (char *)*((void *)this + 31);
  }
  else {
    uint64_t v3 = (char *)this + 120;
  }
  uint64_t v4 = v2 - 1;
  uint64_t v5 = (uint64_t)&v3[32 * v2 - 32];
  int v6 = *(unsigned __int8 *)(v5 + 28);
  if (v6 == 4)
  {
    if (*((_DWORD *)this + 76) != 1) {
      goto LABEL_9;
    }
    RB::Path::Accumulator::convert_to_lines((uint64_t)this, (uint64_t)&v3[32 * v2 - 32]);
    int v6 = *(unsigned __int8 *)(v5 + 28);
  }
  if (v6 == 2)
  {
    uint64_t v7 = *((void *)this + 34);
    uint64_t v8 = 8 * v7;
    int v9 = v7 - 1;
    goto LABEL_10;
  }
LABEL_9:
  uint64_t v10 = *((void *)this + 34);
  *(_DWORD *)(*(void *)(*(void *)v5 + 56) + *(void *)(v5 + 8)) = v10 - 1;
  uint64_t v8 = 32 * v10;
  int v9 = *((_DWORD *)this + 74);
LABEL_10:
  *(_DWORD *)&v3[32 * v4 + 24] = v9;
  uint64_t result = RB::RenderFrame::commit_buffer_region_size(*((void *)this + 1), v5, v8);
  *((unsigned char *)this + 280) = 0;
  if (!v8) {
    --*((void *)this + 32);
  }
  return result;
}

uint64_t RB::Path::Accumulator::convert_to_lines(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  uint64_t v3 = *(void *)(*(void *)a2 + 56);
  uint64_t v4 = *(void *)(result + 272);
  *(void *)(result + 272) = 0;
  if (v4)
  {
    uint64_t v5 = 0;
    uint64_t v6 = v3 + v2;
    uint64_t v7 = (float *)(v2 + v3 + 24);
    int32x2_t v8 = vdup_n_s32(0x7F800000u);
    do
    {
      if (v5 && *(v7 - 5) == 0.0)
      {
        uint64_t v9 = *(void *)(result + 272);
        *(void *)(result + 272) = v9 + 1;
        *(int32x2_t *)(v6 + 8 * v9) = v8;
      }
      uint64_t v10 = *(void *)v7;
      v7 += 8;
      uint64_t v11 = *(void *)(result + 272);
      *(void *)(result + 272) = v11 + 1;
      *(void *)(v6 + 8 * v11) = v10;
      ++v5;
    }
    while (v4 != v5);
  }
  *(unsigned char *)(a2 + 28) = 2;
  return result;
}

BOOL RB::Path::Accumulator::cull_subpath(RB::Path::Accumulator *this)
{
  uint64_t v1 = *((void *)this + 36);
  if ((v1 & 0x8000000000000000) == 0)
  {
    *((void *)this + 34) = v1;
    *((_DWORD *)this + 74) = *((_DWORD *)this + 75);
    *((void *)this + 36) = -1;
  }
  return v1 >= 0;
}

uint64_t RB::Path::Accumulator::begin_subpath(uint64_t this)
{
  *(void *)(this + 288) = *(void *)(this + 272);
  *(_DWORD *)(this + 300) = *(_DWORD *)(this + 296);
  return this;
}

void *RB::vector<RB::Path::Buffer,4ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 18) + (*((void *)__dst + 18) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 18) + (*((void *)__dst + 18) >> 1);
  }
  uint64_t result = RB::details::realloc_vector<unsigned long,32ul>(*((void **)__dst + 16), __dst, 4uLL, (size_t *)__dst + 18, v3);
  *((void *)__dst + 16) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,32ul>(void *__src, void *__dst, size_t a3, size_t *a4, size_t a5)
{
  uint64_t v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      size_t v9 = a3;
      memcpy(__dst, __src, 32 * a5);
      free(v7);
      uint64_t v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(32 * a5);
    size_t v9 = v8 >> 5;
    if (v8 >> 5 != *a4)
    {
      uint64_t v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10) {
        RB::precondition_failure((RB *)"allocation failure", v11);
      }
      uint64_t v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, 32 * *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

int32x2_t RB::Coverage::Glyphs::Glyphs(RB::Coverage::Glyphs *this, const RB::Coverage::Glyphs *a2, RB::Heap *a3, unsigned int a4, unsigned int a5)
{
  uint64_t v5 = (int32x2_t *)RB::Coverage::Glyphs::Glyphs((uint64_t)this, a3, *(CFTypeRef *)a2, a5, (const void *)(*((void *)a2 + 1) + 8 * *((unsigned int *)a2 + 4) + 2 * a4), (const void *)(*((void *)a2 + 1) + 8 * a4), *((_DWORD *)a2 + 5), *((unsigned char *)a2 + 52), *((double *)a2 + 3), *((float *)a2 + 12), *((unsigned char *)a2 + 53));
  int32x2_t result = vdup_n_s32(0x7F7FFFFFu);
  void v5[4] = (int32x2_t)0x100000001000000;
  void v5[5] = result;
  return result;
}

void RB::Coverage::Glyphs::disable_subpixel_quantization(RB::Coverage::Glyphs *this, float64x2_t *a2, double a3, double a4, int64x2_t a5)
{
  int v5 = *((_DWORD *)this + 5);
  if ((v5 & 8) != 0)
  {
    uint64_t v8 = *((void *)this + 1);
    float64x2_t v9 = a2[1];
    v17[0] = *a2;
    v17[1] = v9;
    v17[2] = a2[2];
    if (RB::AffineTransform::invert((RB::AffineTransform *)v17)) {
      uint64_t v10 = (float64x2_t *)v17;
    }
    else {
      uint64_t v10 = a2;
    }
    if (*((_DWORD *)this + 4))
    {
      unint64_t v11 = 0;
      float64x2_t v14 = v10[1];
      float64x2_t v15 = *v10;
      do
      {
        float32x2_t v12 = *(float32x2_t *)(v8 + 8 * v11);
        *(float32x2_t *)(v8 + 8 * v11++) = vadd_f32(v12, vcvt_f32_f64(vmlaq_n_f64(vmulq_n_f64(v15, *(float *)v13.i32), v14, *(float *)&v13.i32[1])));
      }
      while (v11 < *((unsigned int *)this + 4));
    }
    *((_DWORD *)this + 5) &= ~8u;
  }
}

float32x2_t *RB::Coverage::anonymous namespace'::QuantizationLevel::QuantizationLevel(float32x2_t *this, float64x2_t *a2, char a3, double a4, double a5, int64x2_t a6)
{
  *this = 0;
  this[1] = 0;
  if ((a3 & 8) != 0)
  {
    *(double *)a6.i64 = -a2->f64[1];
    double v7 = fabs(vaddvq_f64(vmulq_f64((float64x2_t)vzip1q_s64(a6, *(int64x2_t *)a2), a2[1])));
    if (v7 <= RB::max_cached_glyph_mask_area((RB *)this))
    {
      QuantizationLevelWithuint64_t Style = CGFontGetQuantizationLevelWithStyle();
      v9.f32[0] = (float)(int)QuantizationLevelWithStyle;
      v9.f32[1] = (float)SHIDWORD(QuantizationLevelWithStyle);
      float32x2_t v10 = vrecpe_f32(v9);
      float32x2_t v11 = vmul_f32(vrecps_f32(v9, v10), v10);
      *this = v9;
      this[1] = vmul_f32(v11, vrecps_f32(v9, v11));
    }
  }
  return this;
}

int8x8_t RB::Coverage::anonymous namespace'::QuantizationLevel::offset(float32x2_t *a1, float64x2_t *a2, float32x2_t a3)
{
  uint32x2_t v3 = (uint32x2_t)vceqz_f32(*a1);
  if ((vpmax_u32(v3, v3).u32[0] & 0x80000000) != 0)
  {
    return 0;
  }
  else
  {
    float32x4_t v4 = (float32x4_t)vcvtq_f64_f32(a3);
    float64x2_t v5 = a2[1];
    *(float32x2_t *)v4.f32 = vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(a2[2], *a2, *(double *)v4.i64), v5, (float64x2_t)v4, 1));
    float64x2_t v6 = vaddq_f64(v5, *a2);
    *(int32x2_t *)&v6.f64[0] = vcltz_f32(vcvt_f32_f64(v6));
    *(void *)&v6.f64[0] = vcltzq_s32((int32x4_t)v6).u64[0];
    *(int8x8_t *)v4.f32 = vbsl_s8(*(int8x8_t *)&v6.f64[0], (int8x8_t)*(_OWORD *)&vnegq_f32(v4), *(int8x8_t *)v4.f32);
    *(float32x2_t *)&v5.f64[0] = vadd_f32(*(float32x2_t *)v4.f32, (float32x2_t)vdup_n_s32(0x3A83126Fu));
    float32x2_t v7 = vrndm_f32(*(float32x2_t *)&v5.f64[0]);
    *(float32x2_t *)v4.f32 = vmla_f32(vsub_f32(v7, *(float32x2_t *)v4.f32), vrnd_f32(vmul_f32(vsub_f32(*(float32x2_t *)&v5.f64[0], v7), *a1)), a1[1]);
    return vbsl_s8(*(int8x8_t *)&v6.f64[0], (int8x8_t)*(_OWORD *)&vnegq_f32(v4), *(int8x8_t *)v4.f32);
  }
}

float32x2_t RB::Coverage::Glyphs::resolved_dilation(float32x2_t *this, float a2)
{
}

float32x2_t RB::Coverage::anonymous namespace'::font_dilation_parameters(__int16 a1, float32x2_t a2, float a3)
{
  if ((a1 & 2) != 0)
  {
    switch(((a1 & 0x70u) - 16) >> 4)
    {
      case 1u:
LABEL_5:
        float32x2_t v3 = (float32x2_t)0x3C248B653C02D7B6;
        break;
      case 2u:
LABEL_7:
        float32x2_t v3 = (float32x2_t)0x3C77CED93C463F14;
        break;
      case 3u:
        float32x2_t v3 = (float32x2_t)0x3CA8826B3C8AC5C1;
        break;
      case 4u:
        float32x2_t v3 = (float32x2_t)0x3AEBEDFA3AA3D70ALL;
        break;
      case 5u:
        float32x2_t v3 = (float32x2_t)0x3C570A3D3DD70A3DLL;
        break;
      case 6u:
LABEL_6:
        float32x2_t v3 = vmul_f32(a2, (float32x2_t)vdup_n_s32(0x3E99999Au));
        break;
      default:
        float32x2_t v3 = 0;
        break;
    }
  }
  else
  {
    float32x2_t v3 = 0;
    switch(((a1 & 0xD80u) - 128) >> 7)
    {
      case 0u:
        goto LABEL_5;
      case 1u:
        float32x2_t v3 = (float32x2_t)0x3C4E2D1F3C248B65;
        break;
      case 2u:
        goto LABEL_7;
      case 7u:
      case 8u:
        goto LABEL_6;
      default:
        break;
    }
  }
  return vminnm_f32(vmul_n_f32(v3, a3), (float32x2_t)vdup_n_s32(0x3E99999Au));
}

uint64_t RB::Coverage::Glyphs::can_mix(RB::Coverage::Glyphs *this, const RB::DisplayList::Interpolator::Op *a2, const RB::Coverage::Glyphs *a3)
{
  uint64_t v3 = *(void *)a2 >> 36;
  unsigned int v4 = *((_DWORD *)this + 4);
  if (v4 >= v3) {
    uint64_t v5 = v3;
  }
  else {
    uint64_t v5 = v4;
  }
  if (*((_DWORD *)a3 + 4) < v3) {
    LODWORD(v3) = *((_DWORD *)a3 + 4);
  }
  if (v5 != v3
    || ((*((_DWORD *)a3 + 5) ^ *((_DWORD *)this + 5)) & 0xFFFFFFF7) != 0
    || *((unsigned __int8 *)this + 52) != *((unsigned __int8 *)a3 + 52))
  {
    return 0;
  }
  v24[0] = 0;
  v24[1] = 0;
  float32x2_t v9 = (os_unfair_lock_s *)RB::FontMixer::shared(this);
  uint64_t result = RB::FontMixer::can_mix(v9, *(CGFont **)this, *(CGFont **)a3, (uint64_t *)v24);
  if (result)
  {
    unsigned __int32 v11 = *((float *)this + 12) == *((float *)a3 + 12);
    if (v5)
    {
      uint64_t v12 = *((void *)this + 1);
      uint64_t v13 = *((unsigned int *)a2 + 3);
      float64x2_t v14 = (unsigned __int16 *)(v12 + 8 * *((unsigned int *)this + 4) + 2 * v13);
      uint64_t v15 = *((void *)a3 + 1);
      uint64_t v16 = *((unsigned int *)a2 + 5);
      uint64_t v17 = (unsigned __int16 *)(v15 + 8 * *((unsigned int *)a3 + 4) + 2 * v16);
      uint64_t v18 = (float32x2_t *)(v12 + 8 * v13);
      uint32x2_t v19 = (float32x2_t *)(v15 + 8 * v16);
      while (1)
      {
        unsigned int v21 = *v14++;
        unint64_t v20 = v21;
        unsigned int v22 = *v17++;
        uint64_t result = RB::FontMixer::GlyphEquality::operator()(v24, (void *)v20, (void *)v22);
        if (!result) {
          break;
        }
        if (v11)
        {
          uint32x2_t v23 = (uint32x2_t)vceq_f32(*v18, *v19);
          unsigned __int32 v11 = vpmin_u32(v23, v23).u32[0] >> 31;
        }
        else
        {
          unsigned __int32 v11 = 0;
        }
        ++v19;
        ++v18;
        if (!--v5) {
          goto LABEL_17;
        }
      }
    }
    else
    {
LABEL_17:
      if (v11)
      {
        if (*(void *)this == *(void *)a3) {
          return 4;
        }
        else {
          return 2;
        }
      }
      else
      {
        return 1;
      }
    }
  }
  return result;
}

void RB::Coverage::Glyphs::mix(float32x2_t *this, const RB::DisplayList::Interpolator::State *a2, const RB::Coverage::Glyphs *a3, float64x2_t *a4, float64x2_t *a5, float64x2_t *a6, RB::Heap *a7)
{
  float64x2_t v14 = (os_unfair_lock_s *)RB::FontMixer::shared((RB::FontMixer *)this);
  RB::FontMixer::mix(v14, *(CGFont **)this, *(CGFont **)a3, *((_DWORD *)a2 + 4), &v58);
  float64_t v15 = v58.f64[0];
  if (*(void *)&v58.f64[0])
  {
    *this = *(float32x2_t *)&v58.f64[0];
    v58.f64[0] = 0.0;
    uint64_t v16 = (RB::ObjectTable *)*((void *)a7 + 4);
    if (!v16)
    {
      RB::Heap::make_object_table((size_t *)a7);
      uint64_t v16 = (RB::ObjectTable *)*((void *)a7 + 4);
    }
    RB::ObjectTable::adopt(v16, *(CFTypeRef *)&v15);
    if (*(void *)&v58.f64[0]) {
      CFRelease(*(CFTypeRef *)&v58.f64[0]);
    }
  }
  if ((**((void **)a2 + 1) & 0xBLL) == 2) {
    unsigned int v17 = ((*((_DWORD *)a3 + 5) | this[2].i32[1]) >> 3) & 1;
  }
  else {
    unsigned int v17 = 0;
  }
  float64x2_t v18 = a4[1];
  float64x2_t v58 = *a4;
  float64x2_t v59 = v18;
  float64x2_t v60 = a4[2];
  float64x2_t v19 = a5[1];
  float64x2_t v55 = *a5;
  float64x2_t v56 = v19;
  float64x2_t v57 = a5[2];
  unint64_t v20 = (float64x2_t *)*((void *)a2 + 4);
  if (v20)
  {
    v21.f64[0] = RB::operator*(&v58, v20);
    float64x2_t v58 = v21;
    float64x2_t v59 = v22;
    float64x2_t v60 = v23;
    v24.f64[0] = RB::operator*(&v55, *((float64x2_t **)a2 + 4));
    float64x2_t v55 = v24;
    float64x2_t v56 = v25;
    float64x2_t v57 = v26;
    long long v27 = (float64x2_t *)*((void *)a2 + 4);
    float64x2_t v28 = a6[1];
    float64x2_t v52 = *a6;
    float64x2_t v53 = v28;
    float64x2_t v54 = a6[2];
    if (v27)
    {
      v29.f64[0] = RB::operator*(&v52, v27);
      float64x2_t v52 = v29;
      float64x2_t v53 = v30;
      float64x2_t v54 = v31;
    }
  }
  else
  {
    float64x2_t v32 = a6[1];
    float64x2_t v52 = *a6;
    float64x2_t v53 = v32;
    float64x2_t v54 = a6[2];
  }
  RB::AffineTransform::invert((RB::AffineTransform *)&v52);
  v51[0] = 0;
  v51[1] = 0;
  v50[0] = 0;
  v50[1] = 0;
  if (v17)
  {
  }
  if (this[2].i32[0])
  {
    uint64_t v39 = 0;
    float32x2_t v40 = this[1];
    uint64_t v41 = *((void *)a3 + 1) + 8 * *(unsigned int *)(*((void *)a2 + 1) + 20);
    while (1)
    {
      float32x2_t v42 = *(float32x2_t *)(*(void *)&v40 + 8 * v39);
      float32x2_t v43 = *(float32x2_t *)(v41 + 8 * v39);
      uint32x2_t v44 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(v42, v43));
      if ((vpmax_u32(v44, v44).u32[0] & 0x80000000) != 0) {
        break;
      }
      if (v17) {
        goto LABEL_19;
      }
LABEL_20:
      if (++v39 >= (unint64_t)this[2].u32[0]) {
        goto LABEL_24;
      }
    }
    float32x2_t v46 = vcvt_f32_f64(vmlaq_n_f64(vmulq_n_f64(v58, v42.f32[0]), v59, v42.f32[1]));
    float32x2_t v47 = vmla_n_f32(v46, vsub_f32(vcvt_f32_f64(vmlaq_n_f64(vmulq_n_f64(v55, v43.f32[0]), v56, v43.f32[1])), v46), COERCE_FLOAT(*((void *)a2 + 2)));
    float32x2_t v42 = vcvt_f32_f64(vmlaq_n_f64(vmulq_n_f64(v52, v47.f32[0]), v53, v47.f32[1]));
    *(float32x2_t *)(*(void *)&v40 + 8 * v39) = v42;
    if (!v17) {
      goto LABEL_20;
    }
LABEL_19:
    float32x2_t v49 = v42;
    *(float32x2_t *)(*(void *)&v40 + 8 * v39) = vadd_f32(v49, vcvt_f32_f64(vmlaq_n_f64(vmulq_n_f64(v52, v45.f32[0]), v53, v45.f32[1])));
    goto LABEL_20;
  }
LABEL_24:
  this[3] = vmla_n_f32(this[3], vsub_f32(*(float32x2_t *)((char *)a3 + 24), this[3]), COERCE_FLOAT(*((void *)a2 + 2)));
  this[6].f32[0] = this[6].f32[0] + (float)((float)(*((float *)a3 + 12) - this[6].f32[0]) * *((float *)a2 + 4));
  this[4] = (float32x2_t)0x100000001000000;
  this[5] = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
  if (v17) {
    this[2].i32[1] &= ~8u;
  }
}

void sub_21413A0A8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(const void **)(v1 - 128);
  if (v3) {
    CFRelease(v3);
  }
  _Unwind_Resume(exception_object);
}

RB::DisplayList::Item *RB::Coverage::Glyphs::project_control_points(float32x2_t *this, RB::DisplayList::Builder *a2, const RB::Path::Projection *a3, RB::DisplayList::Item *a4, const RB::Fill::Color *a5, float64x2_t *a6, float64x2_t *a7)
{
  if (!this[2].i32[0]) {
    return a4;
  }
  if (*((_OWORD *)a4 + 1) == 0)
  {
    double v41 = 1.0 / (double)CGFontGetUnitsPerEm(*(CGFontRef *)this);
    Capfloat Height = (double)CGFontGetCapHeight(*(CGFontRef *)this);
    if (a6) {
      float v17 = RB::AffineTransform::scale(a6);
    }
    else {
      float v17 = 1.0;
    }
    double v18 = v41 * (0.333333333 * CapHeight * v17);
    RB::Path::Builder::Builder((RB::Path::Builder *)v53);
    RB::Path::ProjectPointsTransform::ProjectPointsTransform((uint64_t)v52, (uint64_t)v53, (uint64_t)a3, a7, v18);
    float v19 = RB::AffineTransform::scale(a7);
    if (a6) {
      float v20 = RB::AffineTransform::scale(a6);
    }
    else {
      float v20 = 1.0;
    }
    if (this[2].i32[0])
    {
      float32x2_t v21 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT(v20 * v19));
      float32x2_t v22 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(v20 * v19), v21), v21);
      unint64_t v23 = 0;
      uint32x2_t v25 = (uint32x2_t)vceqz_f32(v24);
      __n128 v39 = (__n128)vcvtq_f64_f32(v24);
      unsigned __int32 v40 = vpmin_u32(v25, v25).u32[0];
      do
      {
        Glyphuint64_t Path = (const CGPath *)CGFontCreateGlyphPath();
        long long v27 = GlyphPath;
        if (GlyphPath)
        {
          uint64_t v28 = *(void *)(*(void *)&this[1] + 8 * v23);
          if (a6)
          {
            float64x2_t v29 = a6[1];
            float64x2_t v49 = *a6;
            float64x2_t v50 = v29;
            float64x2_t v51 = a6[2];
            float64x2_t v30 = v49;
            float64x2_t v31 = v51;
          }
          else
          {
            float64x2_t v31 = 0uLL;
            float64x2_t v29 = (float64x2_t)xmmword_2142181D0;
            float64x2_t v30 = (float64x2_t)xmmword_2142181C0;
          }
          float64x2_t v49 = vmulq_n_f64(v30, v41);
          float64x2_t v50 = vmulq_n_f64(v29, v41);
          float64x2_t v51 = vmlaq_n_f64(vmlaq_n_f64(v31, v30, *(float *)&v28), v29, *((float *)&v28 + 1));
          if ((v40 & 0x80000000) != 0)
          {
            RB::Path::normalized_map(GlyphPath, v52, &v49);
          }
          else
          {
            RB::Path::Dilator::Dilator((uint64_t)&v43, (uint64_t)v52, v39);
            RB::Path::normalized_map(v27, (void (***)(void))&v43, &v49);
            RB::Path::Dilator::endpath((RB::Path::Dilator *)&v43);
          }
          CFRelease(v27);
        }
        ++v23;
      }
      while (v23 < this[2].u32[0]);
    }
    uint64_t v32 = RB::Path::Builder::operator RBPath((uint64_t)v53);
    __int8 v33 = this[6].i8[4];
    __int32 v34 = this[6].i32[0];
    float32x2_t v43 = (RB::AffineTransform *)RBPathRetain(v32, v35);
    uint64_t v44 = v36;
    uint64_t v45 = 0;
    __int32 v46 = v34;
    char v47 = 0;
    __int8 v48 = v33;
    uint64_t v37 = *((void *)a2 + 1);
    *(void *)&v49.f64[0] = RB::AffineTransform::identity(v43);
    int v42 = *((_WORD *)a4 + 23) & 0x3F;
    unint64_t v12 = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage4PathENS_4Fill5ColorEEEJRS5_RKS7_PKNS_15AffineTransformERDF16_NS_9BlendModeEEEEPT_DpOT0_((size_t *)(v37 + 16), (uint64_t *)&v43, (uint64_t)a5, (uint64_t *)&v49, (__int16 *)a4 + 22, &v42);
    *(void *)(v12 + 8) = 0;
    *(_OWORD *)(v12 + 16) = *((_OWORD *)a4 + 1);
    *(void *)(v12 + 32) = *((void *)a4 + 4);
    *(_DWORD *)(v12 + 40) = *((_DWORD *)a4 + 10);
    RBPathRelease((uint64_t)v43, v44);
    uint64_t v38 = v54;
    if (v54 && atomic_fetch_add_explicit((atomic_uint *volatile)(v54 + 8), 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(uint64_t))(*(void *)v38 + 8))(v38);
    }
    return (RB::DisplayList::Item *)v12;
  }
  return RB::DisplayList::Item::project(a4, a2, a3, a7);
}

void sub_21413A440(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  float32x2_t v24 = *(atomic_uint **)(v22 + 8);
  if (v24)
  {
    if (atomic_fetch_add_explicit(v24 + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(atomic_uint *))(*(void *)v24 + 8))(v24);
    }
  }
  _Unwind_Resume(exception_object);
}

unint64_t _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage4PathENS_4Fill5ColorEEEJRS5_RKS7_PKNS_15AffineTransformERDF16_NS_9BlendModeEEEEPT_DpOT0_(size_t *a1, uint64_t *a2, uint64_t a3, uint64_t *a4, __int16 *a5, _WORD *a6)
{
  unint64_t v11 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v11 + 104 > a1[3]) {
    unint64_t v11 = RB::Heap::alloc_slow(a1, 0x68uLL, 7);
  }
  else {
    a1[2] = v11 + 104;
  }
  uint64_t v12 = *a4;
  __int16 v13 = *a5;
  char v14 = *a6;
  *(void *)(v11 + 16) = 0;
  *(void *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(void *)(v11 + 32) = 0;
  *(_WORD *)(v11 + 44) = v13;
  *(_WORD *)(v11 + 46) = v14 & 0x3F;
  *(void *)unint64_t v11 = &unk_26C4EA680;
  *(void *)(v11 + 48) = v12;
  *(void *)(v11 + 56) = RBPathRetain(*a2, a2[1]);
  *(void *)(v11 + 64) = v15;
  uint64_t v16 = *(uint64_t *)((char *)a2 + 22);
  *(void *)(v11 + 72) = a2[2];
  *(void *)(v11 + 78) = v16;
  LOWORD(v16) = *(_WORD *)(a3 + 8);
  *(void *)(v11 + 88) = *(void *)a3;
  *(_WORD *)(v11 + 96) = v16;
  *(void *)unint64_t v11 = &unk_26C4E8EE0;
  return v11;
}

void RB::Coverage::Glyphs::clip(float32x2_t **this, RB::CGContext *a2)
{
}

uint64_t RB::Coverage::Glyphs::prepare_encode(uint64_t this, RB::Encoder *a2)
{
  if (*(void *)this) {
    return RB::Encoder::prepare_glyphs(a2, *(CGFont **)this, *(unsigned int *)(this + 16), (const unsigned __int16 *)(*(void *)(this + 8) + 8 * *(unsigned int *)(this + 16)));
  }
  return this;
}

void *RB::Coverage::Glyphs::encode(CGFont **this, RB::Encoder *a2)
{
  if (*this) {
    unsigned int v4 = RB::Encoder::cgfont_field(a2, 1, *this);
  }
  else {
    unsigned int v4 = 0;
  }
  uint64_t v5 = *((unsigned int *)this + 4);
  if (v5)
  {
    unint64_t v6 = 0;
    float32x2_t v7 = this[1];
    uint64_t v8 = (char *)v7 + 8 * v5;
    do
    {
      unsigned int v9 = *(unsigned __int16 *)&v8[2 * v6];
      if (v4)
      {
        unsigned int Value = CGFontIndexMapGetValue();
        if (Value != 0xFFFF) {
          unsigned int v9 = Value;
        }
      }
      uint64_t v18 = *((void *)v7 + v6);
      RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      if (v9)
      {
        RB::ProtobufEncoder::encode_varint(a2, 8uLL);
        RB::ProtobufEncoder::encode_varint(a2, v9);
      }
      float v11 = *((float *)&v18 + 1);
      if (*(float *)&v18 != 0.0)
      {
        RB::ProtobufEncoder::encode_varint(a2, 0x15uLL);
        RB::ProtobufEncoder::encode_fixed32(a2, v18);
        float v11 = *((float *)&v18 + 1);
      }
      int v12 = LODWORD(v11);
      if (v11 != 0.0)
      {
        RB::ProtobufEncoder::encode_varint(a2, 0x1DuLL);
        RB::ProtobufEncoder::encode_fixed32(a2, v12);
      }
      RB::ProtobufEncoder::end_length_delimited(a2);
      ++v6;
    }
    while (v6 < *((unsigned int *)this + 4));
  }
  unint64_t v13 = *((unsigned int *)this + 5);
  if (v13)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x18uLL);
    RB::ProtobufEncoder::encode_varint(a2, v13);
  }
  if (*((unsigned char *)this + 53))
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x20uLL);
    RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  }
  unint64_t v14 = *((unsigned __int8 *)this + 52);
  RB::ProtobufEncoder::encode_varint(a2, 0x28uLL);
  RB::ProtobufEncoder::encode_varint(a2, v14);
  int v15 = *((int *)this + 12);
  if (*(float *)&v15 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x35uLL);
    RB::ProtobufEncoder::encode_fixed32(a2, v15);
  }
  double v16 = *((double *)this + 3);
  return RB::ProtobufEncoder::float2_field(a2, 7, v16);
}

void RB::Coverage::Glyphs::decode(RB::Coverage::Glyphs *this, size_t **a2)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  *(_OWORD *)float64x2_t v29 = 0u;
  unint64_t v30 = 128;
  while (1)
  {
    unint64_t field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
    char v6 = field;
    if (!field) {
      break;
    }
    switch((field >> 3))
    {
      case 1u:
        float32x2_t v7 = RB::Decoder::cgfont_field((RB::ProtobufDecoder *)a2, field);
        *(void *)this = v7;
        uint64_t v8 = a2[8];
        unsigned int v9 = (unsigned int *)v8[4];
        if (!v9)
        {
          RB::Heap::make_object_table(a2[8]);
          unsigned int v9 = (unsigned int *)v8[4];
        }
        RB::ObjectTable::retain(v9, v7);
        break;
      case 2u:
        float v11 = v29[1];
        if ((void *)v30 < (char *)v29[1] + 1)
        {
          float v11 = v29[1];
        }
        int v12 = v29[0];
        if (!v29[0]) {
          int v12 = v28;
        }
        unint64_t v13 = &v12[16 * (void)v11];
        *unint64_t v13 = 0;
        v13[1] = 0;
        unint64_t v14 = v29[1]++;
        if (v29[0]) {
          int v15 = v29[0];
        }
        else {
          int v15 = v28;
        }
        if ((v6 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
          unint64_t v16 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
          if (v16)
          {
            float v17 = (float *)&v15[16 * (void)v14];
            do
            {
              unint64_t v18 = v16 >> 3;
              if ((v16 >> 3) == 3)
              {
                _OWORD v17[3] = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)a2, v16);
              }
              else if (v18 == 2)
              {
                v17[2] = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)a2, v16);
              }
              else if (v18 == 1)
              {
                *(_WORD *)float v17 = RB::ProtobufDecoder::uint_field((uint64_t **)a2, v16);
              }
              else
              {
                RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)a2, v16);
              }
              unint64_t v16 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
            }
            while (v16);
          }
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((unsigned char *)a2 + 56) = 1;
          *a2 = a2[1];
        }
        break;
      case 3u:
        *((_DWORD *)this + 5) = RB::ProtobufDecoder::uint_field((uint64_t **)a2, field);
        break;
      case 4u:
        *((unsigned char *)this + 53) = *((unsigned char *)this + 53) & 0xFE | RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)a2, field);
        break;
      case 5u:
        unint64_t v10 = RB::ProtobufDecoder::uint_field((uint64_t **)a2, field);
        if (v10 <= 3) {
          *((unsigned char *)this + 52) = v10;
        }
        break;
      case 6u:
        *((float *)this + 12) = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)a2, field);
        break;
      case 7u:
        *((void *)this + 3) = RB::ProtobufDecoder::float2_field((RB::ProtobufDecoder *)a2, field, v5).n128_u64[0];
        break;
      default:
        RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)a2, field);
        break;
    }
  }
  float v19 = v29[1];
  if (v29[1])
  {
    *((_DWORD *)this + 4) = v29[1];
    float v20 = a2[8];
    float32x2_t v21 = (void *)((v20[2] + 7) & 0xFFFFFFFFFFFFFFF8);
    uint64_t v22 = (char *)v21 + 10 * v19;
    if ((unint64_t)v22 > v20[3])
    {
      float32x2_t v21 = (void *)RB::Heap::alloc_slow(a2[8], 10 * v19, 7);
      uint64_t v27 = *((unsigned int *)this + 4);
      float v19 = v29[1];
      *((void *)this + 1) = v21;
      if (!v19) {
        goto LABEL_41;
      }
      unint64_t v23 = &v21[v27];
    }
    else
    {
      void v20[2] = (size_t)v22;
      *((void *)this + 1) = v21;
      unint64_t v23 = &v21[v19];
    }
    uint64_t v24 = 0;
    do
    {
      uint32x2_t v25 = v29[0];
      if (!v29[0]) {
        uint32x2_t v25 = v28;
      }
      float64x2_t v26 = &v25[v24];
      *v23++ = *(_WORD *)v26;
      *v21++ = *((void *)v26 + 1);
      v24 += 16;
      float v19 = (char *)v19 - 1;
    }
    while (v19);
  }
LABEL_41:
  if (v29[0]) {
    free(v29[0]);
  }
}

void sub_21413AB20(_Unwind_Exception *a1)
{
  if (STACK[0x800]) {
    free((void *)STACK[0x800]);
  }
  _Unwind_Resume(a1);
}

void RB::Coverage::Glyphs::attributes(float **this, RB::XML::Element *a2)
{
  uint64_t v2 = *this;
  if (*this)
  {
    v3[0] = &unk_26C4ED460;
    v3[1] = CGFontRetain((CGFontRef)v2);
    RB::XML::Element::set<RB::XML::Value::Font>();
  }
  RB::XML::Value::FloatArray::FloatArray<float>(v3, this[1], 2 * *((unsigned int *)this + 4));
  RB::XML::Element::set<RB::XML::Value::FloatArray>();
}

void sub_21413ADB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
}

void RB::XML::Element::set<RB::XML::Value::Font>()
{
}

void sub_21413AED0(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

void RB::XML::Element::set<RB::XML::Value::GlyphArray>()
{
}

void sub_21413AF8C(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10B1C405BD735CELL);
  _Unwind_Resume(a1);
}

void RB::XML::Value::GlyphArray::~GlyphArray(RB::XML::Value::GlyphArray *this)
{
  *(void *)this = &unk_26C4ED2A8;
  uint64_t v2 = (void *)*((void *)this + 5);
  if (v2) {
    free(v2);
  }
  uint64_t v3 = (const void *)*((void *)this + 4);
  if (v3) {
    CFRelease(v3);
  }
  *(void *)this = &unk_26C4ED6E0;
  unsigned int v4 = (void *)*((void *)this + 1);
  if (v4) {
    free(v4);
  }
}

{
  void *v2;
  const void *v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_26C4ED2A8;
  uint64_t v2 = (void *)*((void *)this + 5);
  if (v2) {
    free(v2);
  }
  uint64_t v3 = (const void *)*((void *)this + 4);
  if (v3) {
    CFRelease(v3);
  }
  *(void *)this = &unk_26C4ED6E0;
  unsigned int v4 = (void *)*((void *)this + 1);
  if (v4) {
    free(v4);
  }
  JUMPOUT(0x21669AC10);
}

void RB::XML::Element::set<RB::XML::Value::FloatArray>()
{
}

void sub_21413B134(_Unwind_Exception *a1)
{
  if (*v2) {
    free(*v2);
  }
  MEMORY[0x21669AC10](v1, 0x1081C404FE48876);
  _Unwind_Resume(a1);
}

void RB::XML::Element::set<RB::XML::Value::Int>()
{
}

void RB::XML::Element::set<RB::XML::Value::Vec2>()
{
}

void RB::XML::Element::set<RB::XML::Value::Bool>()
{
}

double RBShapeGetFontQuantizationLevel(uint64_t a1, char a2)
{
  float64x2_t v2 = *(float64x2_t *)(a1 + 16);
  int64x2_t v3 = *(int64x2_t *)(a1 + 32);
  v5[0] = *(float64x2_t *)a1;
  v5[1] = v2;
  void v5[2] = (float64x2_t)v3;
  *(void *)&double result = *(_OWORD *)&vcvtq_f64_f32(v6[0]);
  return result;
}

double RBShapeGetPredictedFontQuantizationError(float64x2_t *a1, float64x2_t a2, float64_t a3, float64x2_t a4, float64_t a5)
{
  a2.f64[1] = a3;
  float32x2_t v5 = vcvt_f32_f64(a2);
  float32x2_t v6 = vrecpe_f32(v5);
  float32x2_t v7 = vmul_f32(vrecps_f32(v5, v6), v6);
  v12[0] = v5;
  v12[1] = vmul_f32(v7, vrecps_f32(v5, v7));
  a4.f64[1] = a5;
  float64x2_t v8 = a1[1];
  float64x2_t v9 = a1[2];
  v11[0] = *a1;
  v11[1] = v8;
  float32x2_t v11[2] = v9;
  return result;
}

double RBShapeGetFontDilationParameters(float64x2_t a1, float64_t a2, uint64_t a3, float64x2_t *a4, __int16 a5)
{
  a1.f64[1] = a2;
  float32x2_t v6 = vcvt_f32_f64(a1);
  float64x2_t v7 = a4[1];
  float64x2_t v8 = a4[2];
  v11[0] = *a4;
  v11[1] = v7;
  float32x2_t v11[2] = v8;
  float v9 = RB::AffineTransform::scale(v11);
  return result;
}

RB::XML::Value::GlyphArray *RB::XML::Value::GlyphArray::GlyphArray(RB::XML::Value::GlyphArray *this, CGFontRef font, const unsigned __int16 *a3, unint64_t a4)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_26C4ED2A8;
  CGFontRef v7 = CGFontRetain(font);
  *((void *)this + 5) = 0;
  *((void *)this + 4) = v7;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  if (a4)
  {
    RB::vector<unsigned short,0ul,unsigned long>::reserve_slow((uint64_t)this + 40, a4);
    unint64_t v9 = *((void *)this + 6);
    do
    {
      unint64_t v10 = v9 + 1;
      if (*((void *)this + 7) < v9 + 1)
      {
        RB::vector<unsigned short,0ul,unsigned long>::reserve_slow((uint64_t)this + 40, v10);
        unint64_t v9 = *((void *)this + 6);
        unint64_t v10 = v9 + 1;
      }
      __int16 v11 = *a3++;
      *(_WORD *)(*((void *)this + 5) + 2 * v9) = v11;
      *((void *)this + 6) = v10;
      unint64_t v9 = v10;
      --a4;
    }
    while (a4);
  }
  return this;
}

void sub_21413B580(_Unwind_Exception *exception_object)
{
  if (*v3) {
    free(*v3);
  }
  float32x2_t v5 = (const void *)v1[4];
  if (v5) {
    CFRelease(v5);
  }
  *uint64_t v1 = v2;
  float32x2_t v6 = (void *)v1[1];
  if (v6) {
    free(v6);
  }
  _Unwind_Resume(exception_object);
}

void *RB::vector<unsigned short,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1) <= a2) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1);
  }
  double result = RB::details::realloc_vector<unsigned long,2ul>(*(void **)a1, (size_t *)(a1 + 16), v3);
  *(void *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,2ul>(void *a1, size_t *a2, uint64_t a3)
{
  unsigned int v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(2 * a3);
    size_t v6 = v5 >> 1;
    if (v5 >> 1 != *a2)
    {
      CGFontRef v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7) {
        RB::precondition_failure((RB *)"allocation failure", v8);
      }
      unsigned int v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

void RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Color>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4EA680;
  RBPathRelease(a1[7], a1[8]);
  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::type_id()
{
  return 4202497;
}

uint64_t RB::DisplayList::Item::atom_count(RB::DisplayList::Item *this)
{
  return 0xFFFFFFFFLL;
}

uint64_t RB::DisplayList::Item::copy_atoms(RB::DisplayList::Item *this, RB::DisplayList::Builder *a2, unsigned int a3, unsigned int a4, uint64_t a5)
{
  return (*(uint64_t (**)(RB::DisplayList::Item *, RB::DisplayList::Builder *, uint64_t))(*(void *)this + 24))(this, a2, a5);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::atom_position(uint64_t a1)
{
  v4.callbacks = *(RBPathCallbacks **)(a1 + 48);
  v4.mach_timebase_info info = (void *)(a1 + 56);
  double v1 = RB::Coverage::Path::bounds(v4);
  return vmla_f32(*(float32x2_t *)&v1, (float32x2_t)0x3F0000003F000000, v2);
}

uint64_t RB::DisplayList::Item::atom_bounds(RB::DisplayList::Item *this)
{
  return (*(uint64_t (**)(RB::DisplayList::Item *, void))(*(void *)this + 144))(this, 0);
}

uint64_t RB::DisplayList::Item::copy_shadow()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::make_clip(uint64_t a1, uint64_t a2, int a3, void *a4, float a5)
{
  int v22 = a3;
  _H1 = *(_WORD *)(a1 + 94);
  __asm { FCVT            S1, H1 }
  unint64_t v13 = (size_t *)(*(void *)(a2 + 8) + 16);
  _H2 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S2, H2 }
  float v21 = (float)(_S1 * a5) * _S2;
  uint64_t v16 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Path>,RB::Heap&,RB::Coverage::Path&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v13, v13, a1 + 56, (int *)&v21, &v22, (uint64_t *)(a1 + 48));
  uint64_t v17 = a4[5];
  size_t v18 = v17 + 1;
  if (a4[6] < (unint64_t)(v17 + 1))
  {
    RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v18);
    uint64_t v17 = a4[5];
    size_t v18 = v17 + 1;
  }
  float v19 = (void *)a4[4];
  if (!v19) {
    float v19 = a4;
  }
  v19[v17] = v16;
  a4[5] = v18;
  return (**(uint64_t (***)(uint64_t))a1)(a1);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::can_append_color_matrix()
{
  return 1;
}

double RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::append_color_matrix(uint64_t a1, float16x4_t *a2, int a3, __int16 a4, uint16x4_t a5)
{
  *(void *)&double result = RB::Fill::Color::append_color_matrix((short float *)(a1 + 88), a2, a3, a4, a5);
  return result;
}

uint64_t RB::DisplayList::Item::append_blur(RB::DisplayList::Item *this, float a2, const RB::AffineTransform *a3)
{
  return 0;
}

unint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::append_alpha_gradient(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  int v8 = *(_WORD *)(a1 + 46) & 0x3F;
  RBPath v4 = (size_t *)(*(void *)(a2 + 8) + 16);
  short float v7 = *(short float *)(a1 + 94) * *(short float *)(a1 + 44);
  unint64_t v5 = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage4PathENS_4Fill8GradientEEEJRS5_RKS7_RPKNS_15AffineTransformEDF16_RNS_9BlendModeEEEEPT_DpOT0_(v4, (uint64_t *)(a1 + 56), a3, (uint64_t *)(a1 + 48), (__int16 *)&v7, &v8);
  *(_OWORD *)(v5 + 16) = *(_OWORD *)(a1 + 16);
  *(void *)(v5 + 32) = *(void *)(a1 + 32);
  *(_DWORD *)(v5 + 40) = *(_DWORD *)(a1 + 40);
  (**(void (***)(uint64_t))a1)(a1);
  return v5;
}

float RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::min_scale(uint64_t a1)
{
  float result = RB::Coverage::Path::min_scale((RB::Coverage::Path *)(a1 + 56), *(const RB::AffineTransform **)(a1 + 48));
  if (result < 0.0) {
    return 0.0;
  }
  return result;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::render(uint64_t a1, int a2, RB::RenderPass *a3, double a4, char a5, int a6)
{
  v23[5] = *(int32x2_t **)MEMORY[0x263EF8340];
  uint64_t v9 = *(void *)(a1 + 48);
  v10.i64[0] = SLODWORD(a4);
  v10.i64[1] = SHIDWORD(a4);
  long long v11 = *(_OWORD *)(v9 + 16);
  float64x2_t v12 = vaddq_f64(*(float64x2_t *)(v9 + 32), vcvtq_f64_s64(v10));
  v14[0] = *(_OWORD *)v9;
  v14[1] = v11;
  void v14[2] = v12;
  short float v13 = *(short float *)(a1 + 44);
  RB::Path::ImmediateRenderer::ImmediateRenderer((RB::Path::ImmediateRenderer *)v19, a3, (const RB::AffineTransform *)v14, (const RB::Coverage::Path *)(a1 + 56));
  __int16 v15 = *(_WORD *)(a1 + 88);
  int v16 = *(_DWORD *)(a1 + 90);
  short float v17 = *(short float *)(a1 + 94) * v13;
  __int16 v18 = *(_WORD *)(a1 + 96);
  RB::Path::Renderer::render(v23, (uint64_t)&v15, a5, a6);
  if (v22) {
    RB::Path::Accumulator::commit_buffer((RB::Path::Accumulator *)&v20);
  }
  if (v21) {
    free(v21);
  }
}

void sub_21413BAB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
  if (a49) {
    free(a49);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::Fill::Color::matches((RB::Fill::Color *)(a1 + 88), a2, a3);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::apply_transform(uint64_t a1, const RB::DisplayList::Transform *a2, uint64_t a3, uint32x4_t a4)
{
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::prepare_mix(float64x2_t **a1, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Interpolator::Op *a3, float64x2_t **a4)
{
  float result = (unint64_t *)(*(uint64_t (**)(float64x2_t **))&(*a4)[1].f64[0])(a4);
  if (result == 4202497)
  {
    float result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      float result = (unint64_t *)RB::can_mix(a1[6], a4[6], v10);
      int v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        float result = (unint64_t *)RB::Coverage::Path::can_mix(a1 + 7, a3, a4 + 7);
        if ((_BYTE)result)
        {
          unsigned __int8 v12 = result;
          can_midouble x = RB::Fill::Color::can_mix((RB::Fill::Color *)(a1 + 11), (const RB::Fill::Color *)(a4 + 11));
          return RB::DisplayList::Interpolator::Op::set_type((unint64_t *)a3, v11, v12, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8 = (*(uint64_t (**)(CGAffineTransform **, void, void, void, uint64_t))&(*a1)[1].a)(a1, *(void *)&a4->f64[0], *(unsigned int *)(*(void *)(a2 + 8) + 12), **(void **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v25[0] = v10;
  v25[1] = v11;
  float64x2_t v25[2] = v12;
  *(void *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v25);
  short float v13 = (RB::Heap *)(*(void *)(*(void *)&a4->f64[0] + 8) + 16);
  RB::Fill::Color::mix(v8 + 88, a3 + 88, 3, *(float *)(a2 + 16));
  v14.f64[0] = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  float64x2_t v22 = v14;
  long long v23 = v15;
  long long v24 = v16;
  v17.f64[0] = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  v21[0] = v17;
  v21[1] = v18;
  int32x2_t v21[2] = v19;
  RB::Coverage::Path::mix((RBPath *)(v8 + 56), (const RB::DisplayList::Interpolator::State *)a2, (RBPath *)(a3 + 56), &v22, v21, *(float64x2_t **)(v8 + 48), v13);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(unsigned char *)(*(void *)&a4->f64[0] + 272))
  {
    *(void *)&v22.f64[0] = &unk_26C4E7F70;
    *(void *)&v22.f64[1] = v13;
    *(void *)&long long v23 = v8;
    *((void *)&v23 + 1) = v8 + 88;
    long long v24 = *(unint64_t *)(v8 + 48);
    RB::Coverage::Path::simplify(v8 + 56, (uint64_t)&v22);
    if (*((void *)&v24 + 1))
    {
      *(void *)uint64_t v8 = &unk_26C4EA680;
      RBPathRelease(*(void *)(v8 + 56), *(void *)(v8 + 64));
      uint64_t v8 = *((void *)&v24 + 1);
    }
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

void *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::encode(uint64_t a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Path>(this, 1, (RBPath *)(a1 + 56));
  RB::Encoder::typed_message_field<RB::Fill::Color>(this, 2, (RB::Fill::Color *)(a1 + 88));
  RBPath v4 = *(float64x2_t **)(a1 + 48);
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::print(const RB::AffineTransform **a1, std::string *this)
{
}

void RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Color>::~GenericItem()
{
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::type_id()
{
  return 4198401;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::atom_position(uint64_t a1, int8x16_t a2, int32x4_t a3, int8x16_t a4, int32x4_t a5)
{
  float32x2_t v5 = RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), *(float64x2_t **)(a1 + 48), a2, a3, a4, a5);
  return vmla_f32(v5, (float32x2_t)0x3F0000003F000000, v6);
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Color>::copy_shadow(__n128 *a1, uint64_t a2, uint64_t a3)
{
  if ((*(unsigned char *)(a3 + 88) & 0x10) == 0)
  {
    _H0 = a1[7].n128_u16[3];
    __asm { FCVT            S0, H0 }
    float v30 = _S0;
    if ((RB::DisplayList::Item::clip_affects_blurred_bounds((RB::DisplayList::Item *)a1, *(float *)(a3 + 64)) & 1) == 0)
    {
      memset(v27, 0, sizeof(v27));
      int v28 = 1065353216;
      v29[0] = 0;
      *(_DWORD *)((char *)v29 + 7) = 0;
      short float v13 = *(float64x2_t **)(a3 + 16);
      float64x2_t v14 = (float64x2_t *)a1[3].n128_u64[0];
      float64x2_t v15 = *v14;
      float64x2_t v16 = v14[2];
      float64x2_t v32 = v14[1];
      float64x2_t v33 = v16;
      float64x2_t v31 = v15;
      if (RB::AffineTransform::invert((RB::AffineTransform *)&v31)) {
        float64x2_t v17 = &v31;
      }
      else {
        float64x2_t v17 = v14;
      }
      float64x2_t v18 = v17[1];
      float64x2_t v19 = v17[2];
      v26[0] = *v17;
      v26[1] = v18;
      v26[2] = v19;
      v20.f64[0] = RB::operator*(v13, v26);
      float64x2_t v31 = v20;
      float64x2_t v32 = v21;
      float64x2_t v33 = v22;
      if (RB::Coverage::Primitive::make_shadow((RB::Coverage::Primitive *)&a1[4], &v31, *(float *)(a3 + 64), &v30, (*(_DWORD *)(a3 + 88) >> 2) & 1, (RB::Coverage::Primitive *)v27))
      {
        _H1 = a1[2].n128_u16[6];
        __asm { FCVT            S1, H1 }
        RB::DisplayList::ShadowStyle::make_primitive(a3, a2, v27, a1[3].n128_i64[0], a1[2].n128_u16[7] & 0x3F, v30, _S1);
        __n128 result = a1[1];
        v25[1] = result;
        v25[2].n128_u64[0] = a1[2].n128_u64[0];
        v25[2].n128_u32[2] = a1[2].n128_u32[2];
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::make_clip(uint64_t a1, uint64_t a2, int a3, void *a4, int8x16_t a5)
{
  int v22 = a3;
  _H1 = *(_WORD *)(a1 + 118);
  __asm { FCVT            S1, H1 }
  short float v13 = (size_t *)(*(void *)(a2 + 8) + 16);
  _H2 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S2, H2 }
  *(float *)a5.i32 = (float)(_S1 * *(float *)a5.i32) * _S2;
  __int32 v21 = a5.i32[0];
  uint64_t v16 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v13, a5, (uint64_t)v13, (_OWORD *)(a1 + 64), (unsigned __int32 *)&v21, &v22, (uint64_t *)(a1 + 48));
  uint64_t v17 = a4[5];
  size_t v18 = v17 + 1;
  if (a4[6] < (unint64_t)(v17 + 1))
  {
    RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v18);
    uint64_t v17 = a4[5];
    size_t v18 = v17 + 1;
  }
  float64x2_t v19 = (void *)a4[4];
  if (!v19) {
    float64x2_t v19 = a4;
  }
  v19[v17] = v16;
  a4[5] = v18;
  return (**(uint64_t (***)(uint64_t))a1)(a1);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::can_append_color_matrix()
{
  return 1;
}

double RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::append_color_matrix(uint64_t a1, float16x4_t *a2, int a3, __int16 a4, uint16x4_t a5)
{
  *(void *)&double result = RB::Fill::Color::append_color_matrix((short float *)(a1 + 112), a2, a3, a4, a5);
  return result;
}

BOOL RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Color>::append_blur(uint64_t a1, float64x2_t *a2, int8x16_t a3, int32x4_t a4, int8x16_t a5, int32x4_t a6)
{
  float v7 = *(float *)a3.i32;
  uint64_t v9 = *(void **)(a1 + 24);
  if (!v9) {
    return RB::Coverage::Primitive::append_blur((RB::Coverage::Primitive *)(a1 + 64), v7, *(float64x2_t **)(a1 + 48), a2);
  }
  float32x2_t v10 = RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), *(float64x2_t **)(a1 + 48), a3, a4, a5, a6);
  double v14 = *(double *)&v10;
  double v15 = v11;
  v10.f32[0] = -ceilf(v7 * 2.8);
  RB::Rect::inset((float32x2_t *)&v14, v10, v10.f32[0]);
  int v12 = RB::DisplayList::ClipNode::contains(v9, v14, v15);
  BOOL result = 0;
  if (v12) {
    return RB::Coverage::Primitive::append_blur((RB::Coverage::Primitive *)(a1 + 64), v7, *(float64x2_t **)(a1 + 48), a2);
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::append_alpha_gradient(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v9 = *(_WORD *)(a1 + 46) & 0x3F;
  RBPath v4 = (RB::Heap *)(*(void *)(a2 + 8) + 16);
  short float v8 = *(short float *)(a1 + 118) * *(short float *)(a1 + 44);
  _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill8GradientEEEJRS5_RKS7_RPKNS_15AffineTransformEDF16_RNS_9BlendModeEEEEPT_DpOT0_(v4, (long long *)(a1 + 64), a3, (uint64_t *)(a1 + 48), (__int16 *)&v8, &v9);
  uint64_t v6 = v5;
  *(_OWORD *)(v5 + 16) = *(_OWORD *)(a1 + 16);
  *(void *)(v5 + 32) = *(void *)(a1 + 32);
  *(_DWORD *)(v5 + 40) = *(_DWORD *)(a1 + 40);
  (**(void (***)(uint64_t))a1)(a1);
  return v6;
}

float RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::min_scale(uint64_t a1)
{
  float result = 0.0;
  if (*(unsigned __int8 *)(a1 + 108) >= 2u && *(unsigned char *)(a1 + 109) == 1) {
    return 1.0;
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::Fill::Color::matches((RB::Fill::Color *)(a1 + 112), a2, a3);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::apply_transform(uint64_t a1, const RB::DisplayList::Transform *a2, uint64_t a3, uint32x4_t a4)
{
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::prepare_mix(float64x2_t **a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, float64x2_t **a4)
{
  float result = (unint64_t *)(*(uint64_t (**)(float64x2_t **))&(*a4)[1].f64[0])(a4);
  if (result == 4198401)
  {
    float result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      float result = (unint64_t *)RB::can_mix(a1[6], a4[6], v10);
      int v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        float result = (unint64_t *)RB::Coverage::Primitive::can_mix((uint64_t)(a1 + 8), (uint64_t)a3, (uint64_t)(a4 + 8));
        if ((_BYTE)result)
        {
          unsigned __int8 v12 = result;
          can_midouble x = RB::Fill::Color::can_mix((RB::Fill::Color *)(a1 + 14), (const RB::Fill::Color *)(a4 + 14));
          return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v12, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8 = (*(uint64_t (**)(CGAffineTransform **, void, void, void, uint64_t))&(*a1)[1].a)(a1, *(void *)&a4->f64[0], *(unsigned int *)(*(void *)(a2 + 8) + 12), **(void **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v16[0] = v10;
  v16[1] = v11;
  float32x2_t v16[2] = v12;
  *(void *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v16);
  RB::Fill::Color::mix(v8 + 112, a3 + 112, 3, *(float *)(a2 + 16));
  RB::operator*((float64x2_t *)a1[6], a4 + 68);
  double v13 = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  RB::Coverage::Primitive::mix(v8 + 64, a2, a3 + 64, v13, v14);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(unsigned char *)(*(void *)&a4->f64[0] + 272)) {
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

void *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::encode(float32x4_t *a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Primitive>(this, 1, a1 + 4);
  RB::Encoder::typed_message_field<RB::Fill::Color>(this, 2, (RB::Fill::Color *)&a1[7]);
  RBPath v4 = (float64x2_t *)a1[3].i64[0];
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::print(const RB::AffineTransform **a1, std::string *this)
{
}

void *RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 6) + (*((void *)__dst + 6) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 6) + (*((void *)__dst + 6) >> 1);
  }
  float result = RB::details::realloc_vector<unsigned long,8ul>(*((void **)__dst + 4), __dst, 4uLL, (size_t *)__dst + 6, v3);
  *((void *)__dst + 4) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,8ul>(void *__src, void *__dst, size_t a3, size_t *a4, size_t a5)
{
  float v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      size_t v9 = a3;
      memcpy(__dst, __src, 8 * a5);
      free(v7);
      long long v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(8 * a5);
    size_t v9 = v8 >> 3;
    if (v8 >> 3 != *a4)
    {
      long long v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10) {
        RB::precondition_failure((RB *)"allocation failure", v11);
      }
      long long v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, 8 * *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

void RB::DisplayList::GenericClip<RB::Coverage::Primitive>::~GenericClip()
{
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Primitive>::type_id()
{
  return 4098;
}

void *RB::DisplayList::GenericClip<RB::Coverage::Primitive>::copy(uint64_t a1, RB::DisplayList::CachedTransform *this, uint64_t a3, int a4)
{
  float v7 = (size_t *)(*(void *)(*(void *)this + 8) + 16);
  int v8 = *(char *)(a1 + 44);
  if (a4) {
    int v8 = *(unsigned char *)(a1 + 44) == 0;
  }
  int v15 = v8;
  int32x4_t v14 = RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)this, *(const RB::AffineTransform **)(a1 + 48));
  if ((*(unsigned char *)(a1 + 45) & 4) != 0) {
    char v10 = *(unsigned char *)(a1 + 45) & 4;
  }
  else {
    char v10 = 4 * *(unsigned char *)(*(void *)this + 272);
  }
  uint64_t v11 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v7, v9, (uint64_t)v7, (_OWORD *)(a1 + 64), (unsigned __int32 *)(a1 + 112), &v15, (uint64_t *)&v14);
  *(void *)(v11 + 32) = RB::DisplayList::CachedTransform::transform_metadata(this, *(const RB::DisplayList::Metadata **)(a1 + 32), *(_DWORD *)(a1 + 40));
  *(_DWORD *)(v11 + 40) = v12;
  *(unsigned char *)(v11 + 45) |= v10;
  float result = (void *)((*((void *)this + 3) + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(result + 2) > *((void *)this + 4)) {
    float result = (void *)RB::Heap::alloc_slow((size_t *)this + 1, 0x10uLL, 7);
  }
  else {
    *((void *)this + 3) = result + 2;
  }
  *float result = a3;
  result[1] = v11;
  return result;
}

float RB::DisplayList::GenericClip<RB::Coverage::Primitive>::min_scale(uint64_t a1)
{
  float result = 0.0;
  if (*(unsigned __int8 *)(a1 + 108) >= 2u && *(unsigned char *)(a1 + 109) == 1) {
    return 1.0;
  }
  return result;
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Primitive>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned __int8 *)(a1 + 44) != *(unsigned __int8 *)(a3 + 44)) {
    return 0;
  }
  can_midouble x = RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a3 + 48), (const RB::AffineTransform *)a3);
  if (!can_mix) {
    return 0;
  }
  unsigned __int8 v6 = can_mix;
  v9[1] = 0;
  uint64_t v9[2] = 0;
  v9[0] = 0xFFFFFFF000000000;
  int v10 = 0;
  uint64_t v11 = 1;
  int v12 = 0;
  unsigned int v7 = RB::Coverage::Primitive::can_mix(a1 + 64, (uint64_t)v9, a3 + 64);
  if (v7 >= v6) {
    return v6;
  }
  else {
    return v7;
  }
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Primitive>::mix(uint64_t a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  int v8 = (size_t *)(*(void *)(*(void *)&a4->f64[0] + 8) + 16);
  RB::mix(*(CGAffineTransform **)(a1 + 48), *(float64x2_t **)(a3 + 48), (const RB::AffineTransform *)a3, *(float *)(a2 + 16));
  v24[0] = v9;
  v24[1] = v10;
  v24[2] = v11;
  float v23 = *(float *)(a1 + 112) + (float)((float)(*(float *)(a3 + 112) - *(float *)(a1 + 112)) * *(float *)(a2 + 16));
  int v22 = *(char *)(a1 + 44);
  __int32 v21 = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v24);
  uint64_t v13 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v8, v12, (uint64_t)v8, (_OWORD *)(a1 + 64), (unsigned __int32 *)&v23, &v22, (uint64_t *)&v21);
  RB::Coverage::Primitive::mix(v13 + 64, a2, a3 + 64, v14, v15);
  RB::DisplayList::GenericClip<RB::Coverage::Primitive>::update_bounds(v13, v16, v17, v18, v19);
  return v13;
}

float RB::DisplayList::GenericClip<RB::Coverage::Primitive>::cg_alpha(uint64_t a1)
{
  return *(float *)(a1 + 112);
}

void *RB::DisplayList::GenericClip<RB::Coverage::Primitive>::encode(float32x4_t *a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Primitive>(this, 1, a1 + 4);
  RBPath v4 = (float64x2_t *)a1[3].i64[0];
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x12uLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  int v6 = a1[7].i32[0];
  if (*(float *)&v6 != 1.0)
  {
    RB::ProtobufEncoder::encode_varint(this, 0x1DuLL);
    RB::ProtobufEncoder::encode_fixed32(this, v6);
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Clip::encode(a1, this);
}

void RB::DisplayList::GenericClip<RB::Coverage::Primitive>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "clip");
  RB::DisplayList::Clip::print((RB::DisplayList::Clip *)a1, this);
  float v4 = *(float *)(a1 + 112);
  if (v4 != 1.0) {
    RB::SexpString::printf(this, 0, "(alpha %g)", v4);
  }
  RB::SexpString::print_ctm(this, *(const RB::AffineTransform **)(a1 + 48));
  RB::XML::print_attributes<RB::Coverage::Primitive>();
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>(size_t *a1, uint64_t a2, uint64_t a3, int *a4, _DWORD *a5, uint64_t *a6)
{
  uint64_t v11 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v11 + 152 > a1[3]) {
    uint64_t v11 = RB::Heap::alloc_slow(a1, 0x98uLL, 7);
  }
  else {
    a1[2] = v11 + 152;
  }
  int v12 = *a4;
  char v13 = *a5;
  uint64_t v14 = *a6;
  *(void *)(v11 + 16) = 0;
  *(void *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(void *)(v11 + 32) = 0;
  *(unsigned char *)(v11 + 44) = v13;
  *(unsigned char *)(v11 + 45) = 0;
  *(void *)uint64_t v11 = &unk_26C4E8DB0;
  *(void *)(v11 + 48) = v14;
  *(void *)(v11 + 56) = &unk_26C4EDD48;
  RB::Coverage::StrokeablePath::StrokeablePath(v11 + 64, a3 + 8, a2);
  long long v15 = *(_OWORD *)(a3 + 56);
  *(_OWORD *)(v11 + 112) = v15;
  *(unsigned char *)(v11 + 128) = *(unsigned char *)(a3 + 72);
  *(_WORD *)(v11 + 129) = *(_WORD *)(a3 + 73);
  *(unsigned char *)(v11 + 131) = *(unsigned char *)(a3 + 75);
  *(unsigned char *)(v11 + 132) = *(unsigned char *)(a3 + 76);
  LODWORD(v15) = *(_DWORD *)(a3 + 80);
  *(_DWORD *)(v11 + 136) = v15;
  *(_DWORD *)(v11 + 144) = v12;
  RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::update_bounds(v11, *(double *)&v15, v16);
  return v11;
}

void sub_21413CDF0(_Unwind_Exception *a1)
{
  v1[7] = v2;
  RBPathRelease(v1[8], v1[9]);
  _Unwind_Resume(a1);
}

void RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::update_bounds(uint64_t a1, double a2, int32x4_t a3)
{
  if (*(unsigned char *)(a1 + 44) == 1)
  {
    *(void *)(a1 + 16) = 0x100000001000000;
    *(int32x2_t *)(a1 + 24) = vdup_n_s32(0x7F7FFFFFu);
  }
  else if (!*(unsigned char *)(a1 + 44))
  {
    LODWORD(a2) = *(_DWORD *)(a1 + 144);
    if (*(float *)&a2 == 0.0)
    {
      *(void *)(a1 + 16) = 0;
      *(void *)(a1 + 24) = 0;
    }
    else
    {
      *(float32x2_t *)(a1 + 16) = RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, *(float64x2_t **)(a1 + 48), a2, a3);
      *(void *)(a1 + 24) = v4;
    }
  }
}

void *RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::~GenericClip(void *a1)
{
  a1[7] = &unk_26C4EDD48;
  RBPathRelease(a1[8], a1[9]);
  return a1;
}

void RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::~GenericClip(void *a1)
{
  a1[7] = &unk_26C4EDD48;
  RBPathRelease(a1[8], a1[9]);
  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::type_id()
{
  return 12290;
}

void *RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::copy(uint64_t a1, RB::DisplayList::CachedTransform *this, uint64_t a3, int a4)
{
  unsigned int v7 = (uint64_t (**)(void, long long *))(*(void *)(*(void *)this + 8) + 16);
  if (a4) {
    int v8 = *(unsigned char *)(a1 + 44) == 0;
  }
  else {
    int v8 = *(char *)(a1 + 44);
  }
  int v19 = v8;
  long long v9 = RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)this, *(const RB::AffineTransform **)(a1 + 48));
  int8x16_t v18 = v9;
  if ((*(unsigned char *)(a1 + 45) & 4) != 0)
  {
    char v11 = *(unsigned char *)(a1 + 45) & 4;
  }
  else if (*(unsigned char *)(*(void *)this + 272))
  {
    v14[0] = (uint64_t (**)(void, long long *))&unk_26C4ECC60;
    v14[1] = v7;
    void v14[2] = (uint64_t (**)(void, long long *))a1;
    int v15 = v8;
    int32x4_t v16 = v9;
    uint64_t v17 = 0;
    RB::Coverage::StrokeablePath::simplify(a1 + 64, a1 + 56, v14);
    uint64_t v10 = v17;
    char v11 = 4;
    if (v17) {
      goto LABEL_11;
    }
  }
  else
  {
    char v11 = 0;
  }
  uint64_t v10 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>((size_t *)v7, (uint64_t)v7, a1 + 56, (int *)(a1 + 144), &v19, (uint64_t *)&v18);
LABEL_11:
  *(void *)(v10 + 32) = RB::DisplayList::CachedTransform::transform_metadata(this, *(const RB::DisplayList::Metadata **)(a1 + 32), *(_DWORD *)(a1 + 40));
  *(_DWORD *)(v10 + 40) = v12;
  *(unsigned char *)(v10 + 45) |= v11;
  float result = (void *)((*((void *)this + 3) + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(result + 2) > *((void *)this + 4)) {
    float result = (void *)RB::Heap::alloc_slow((size_t *)this + 1, 0x10uLL, 7);
  }
  else {
    *((void *)this + 3) = result + 2;
  }
  *float result = a3;
  result[1] = v10;
  return result;
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::contains(uint64_t a1, double d0_0, int32x4_t a3)
{
  if (*(unsigned char *)(a1 + 44) != 1) {
    return 0;
  }
  float32x2_t v3 = *(float32x2_t *)&d0_0;
  LODWORD(d0_0) = *(_DWORD *)(a1 + 144);
  if (*(float *)&d0_0 == 0.0) {
    return 1;
  }
  float32x2_t v5 = *(float32x2_t *)a3.i8;
  v11[0] = RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, *(float64x2_t **)(a1 + 48), d0_0, a3);
  v11[1] = v6;
  return RB::Rect::intersects(v11, v12, v3, v5, v7, v8, v9, v10) ^ 1;
}

float RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::min_scale(uint64_t a1)
{
  float result = 0.0;
  if (!*(unsigned char *)(a1 + 128) && *(unsigned char *)(a1 + 132) == 1) {
    return 1.0;
  }
  return result;
}

void RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::render(uint64_t a1, double a2, uint64_t a3, uint64_t a4, int a5)
{
  float32x2_t v5 = *(float64x2_t **)(a1 + 48);
  v6.i64[0] = SLODWORD(a2);
  v6.i64[1] = SHIDWORD(a2);
  float64x2_t v7 = v5[1];
  float64x2_t v8 = vaddq_f64(v5[2], vcvtq_f64_s64(v6));
  v10[0] = *v5;
  v10[1] = v7;
  v10[2] = v8;
  float v9 = *(float *)(a1 + 144);
  int v11 = *(unsigned __int8 *)(a1 + 128);
  __int16 v12 = *(_WORD *)(a1 + 129);
  int v13 = *(unsigned __int8 *)(a1 + 131);
  char v14 = *(unsigned char *)(a1 + 132);
  int v15 = *(_DWORD *)(a1 + 136);
  int v16 = 1065353216;
  uint64_t v17 = 1;
  uint64_t v18 = 0;
  if (v11 == 1) {
    abort();
  }
  RB::render_stroke_coverage(a4, v10, a1 + 56, (uint64_t)&v11, a5, v9);
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned __int8 *)(a1 + 44) != *(unsigned __int8 *)(a3 + 44)) {
    return 0;
  }
  can_midouble x = RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a3 + 48), (const RB::AffineTransform *)a3);
  if (!can_mix) {
    return 0;
  }
  unsigned __int8 v7 = can_mix;
  if (*(unsigned __int8 *)(a1 + 128) == *(unsigned __int8 *)(a3 + 128)
    && *(unsigned __int8 *)(a1 + 129) == *(unsigned __int8 *)(a3 + 129)
    && *(unsigned __int8 *)(a1 + 130) == *(unsigned __int8 *)(a3 + 130)
    && *(unsigned __int8 *)(a1 + 131) == *(unsigned __int8 *)(a3 + 131)
    && *(unsigned __int8 *)(a1 + 132) == *(unsigned __int8 *)(a3 + 132)
    && *(float *)(a1 + 136) == *(float *)(a3 + 136))
  {
    LOBYTE(result) = RB::Coverage::StrokeablePath::can_mix(a1 + 64, a3 + 64, v6);
  }
  else
  {
    LOBYTE(result) = 0;
  }
  if (result >= v7) {
    return v7;
  }
  else {
    return result;
  }
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::mix(uint64_t a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  float64x2_t v8 = (size_t *)(*(void *)(*(void *)&a4->f64[0] + 8) + 16);
  RB::mix(*(CGAffineTransform **)(a1 + 48), *(float64x2_t **)(a3 + 48), (const RB::AffineTransform *)a3, *(float *)(a2 + 16));
  v19[0] = v9;
  v19[1] = v10;
  v19[2] = v11;
  float v18 = *(float *)(a1 + 144) + (float)((float)(*(float *)(a3 + 144) - *(float *)(a1 + 144)) * *(float *)(a2 + 16));
  int v17 = *(char *)(a1 + 44);
  int v16 = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v19);
  uint64_t v12 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,float,RB::ClipMode const&,RB::AffineTransform const*>(v8, (uint64_t)v8, a1 + 56, (int *)&v18, &v17, (uint64_t *)&v16);
  LODWORD(v13) = *(_DWORD *)(a2 + 16);
  RB::Coverage::StrokeablePath::mix(v12 + 64, (RB *)v8, a3 + 64, *(void *)(a1 + 48), *(void *)(a3 + 48), (uint64_t)v19, v13);
  *(float *)(v12 + 136) = *(float *)(v12 + 136)
                        + (float)((float)(*(float *)(a3 + 136) - *(float *)(v12 + 136)) * *(float *)(a2 + 16));
  *(int32x2_t *)v14.i8 = vdup_n_s32(0x7F7FFFFFu);
  *(void *)(v12 + 112) = 0x100000001000000;
  *(void *)(v12 + 120) = v14.i64[0];
  RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::update_bounds(v12, 7.29112205e-304, v14);
  return v12;
}

float RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::cg_alpha(uint64_t a1)
{
  return *(float *)(a1 + 144);
}

void *RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::encode(uint64_t a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(this, 1, a1 + 56);
  uint64_t v4 = *(float64x2_t **)(a1 + 48);
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x12uLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  int v6 = *(int *)(a1 + 144);
  if (*(float *)&v6 != 1.0)
  {
    RB::ProtobufEncoder::encode_varint(this, 0x1DuLL);
    RB::ProtobufEncoder::encode_fixed32(this, v6);
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Clip::encode((void *)a1, this);
}

void RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "clip");
  RB::DisplayList::Clip::print((RB::DisplayList::Clip *)a1, this);
  float v4 = *(float *)(a1 + 144);
  if (v4 != 1.0) {
    RB::SexpString::printf(this, 0, "(alpha %g)", v4);
  }
  RB::SexpString::print_ctm(this, *(const RB::AffineTransform **)(a1 + 48));
  RB::XML::print_attributes<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>();
}

void RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::generate(uint64_t a1, void (**a2)(void), uint64_t a3, uint64_t a4, float64x2_t a5, float32x2_t a6, double a7)
{
}

float32x2_t RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(uint64_t a1, float64x2_t *a2, double a3, int32x4_t a4)
{
  a4.i64[0] = *(void *)(a1 + 64);
  uint32x2_t v6 = (uint32x2_t)vcge_f32((float32x2_t)(a4.i64[0] & 0x7FFFFFFF7FFFFFFFLL), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  if ((vpmax_u32(v6, v6).u32[0] & 0x80000000) != 0)
  {
    RB::Coverage::StrokeablePath::bounds(a1 + 8, a1);
    *(float32x2_t *)(a1 + 56) = v7;
    *(void *)(a1 + 64) = a4.i64[0];
  }
  else
  {
    float32x2_t v7 = *(float32x2_t *)(a1 + 56);
  }
  return RB::operator*(a2, v7, a4);
}

uint64_t RB::DisplayList::GenericClipCopyVisitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::visit(uint64_t a1, _OWORD *a2, int8x16_t a3)
{
  uint64_t result = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive&,float &,RB::ClipMode &,RB::AffineTransform const*&>(*(size_t **)(a1 + 8), a3, *(void *)(a1 + 8), a2, (unsigned __int32 *)(*(void *)(a1 + 16) + 144), (int *)(a1 + 24), (uint64_t *)(a1 + 32));
  *(void *)(a1 + 40) = result;
  return result;
}

uint64_t RB::DisplayList::GenericClipCopyVisitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::visit(uint64_t a1, uint64_t a2)
{
  uint64_t result = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>(*(size_t **)(a1 + 8), *(void *)(a1 + 8), a2, (int *)(*(void *)(a1 + 16) + 144), (_DWORD *)(a1 + 24), (uint64_t *)(a1 + 32));
  *(void *)(a1 + 40) = result;
  return result;
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,float,RB::ClipMode const&,RB::AffineTransform const*>(size_t *a1, uint64_t a2, uint64_t a3, int *a4, _DWORD *a5, uint64_t *a6)
{
  uint64_t v11 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v11 + 152 > a1[3]) {
    uint64_t v11 = RB::Heap::alloc_slow(a1, 0x98uLL, 7);
  }
  else {
    a1[2] = v11 + 152;
  }
  int v12 = *a4;
  char v13 = *a5;
  uint64_t v14 = *a6;
  *(void *)(v11 + 16) = 0;
  *(void *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(void *)(v11 + 32) = 0;
  *(unsigned char *)(v11 + 44) = v13;
  *(unsigned char *)(v11 + 45) = 0;
  *(void *)uint64_t v11 = &unk_26C4E8DB0;
  *(void *)(v11 + 48) = v14;
  *(void *)(v11 + 56) = &unk_26C4EDD48;
  RB::Coverage::StrokeablePath::StrokeablePath(v11 + 64, a3 + 8, a2);
  long long v15 = *(_OWORD *)(a3 + 56);
  *(_OWORD *)(v11 + 112) = v15;
  *(unsigned char *)(v11 + 128) = *(unsigned char *)(a3 + 72);
  *(_WORD *)(v11 + 129) = *(_WORD *)(a3 + 73);
  *(unsigned char *)(v11 + 131) = *(unsigned char *)(a3 + 75);
  *(unsigned char *)(v11 + 132) = *(unsigned char *)(a3 + 76);
  LODWORD(v15) = *(_DWORD *)(a3 + 80);
  *(_DWORD *)(v11 + 136) = v15;
  *(_DWORD *)(v11 + 144) = v12;
  RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::update_bounds(v11, *(double *)&v15, v16);
  return v11;
}

void sub_21413D7C0(_Unwind_Exception *a1)
{
  v1[7] = v2;
  RBPathRelease(v1[8], v1[9]);
  _Unwind_Resume(a1);
}

void *RB::Encoder::typed_message_field<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(RB::ProtobufEncoder *a1, uint64_t a2, uint64_t a3)
{
  RB::ProtobufEncoder::encode_varint(a1, (8 * a2) | 2);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::ProtobufEncoder::encode_varint(a1, 0x1AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::Coverage::StrokeablePath::encode(a3 + 8, a3, a1);
  RB::ProtobufEncoder::end_length_delimited(a1);
  return RB::ProtobufEncoder::end_length_delimited(a1);
}

void RB::XML::print_attributes<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>()
{
}

void sub_21413D940(_Unwind_Exception *exception_object)
{
  int v3 = v1[2] - 1;
  v1[2] = v3;
  if (!v3) {
    (*(void (**)(_DWORD *))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

_DWORD *RB::Refcount<RB::XML::Element,unsigned int>::release(_DWORD *result)
{
  int v1 = result[2] - 1;
  result[2] = v1;
  if (!v1) {
    return (_DWORD *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t RB::Refcount<RB::XML::Element,unsigned int>::finalize(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

void RB::XML::Element::~Element(RB::XML::Element *this)
{
  *(void *)this = &unk_26C4ED780;
  uint64_t v2 = (std::__shared_weak_count **)*((void *)this + 6);
  unint64_t v3 = *((void *)this + 7);
  if (v3)
  {
    unint64_t v4 = 0;
    int64x2_t v5 = v2 + 2;
    do
    {
      if (*v5)
      {
        std::__shared_weak_count::__release_shared[abi:nn180100](*v5);
        unint64_t v3 = *((void *)this + 7);
      }
      ++v4;
      v5 += 3;
    }
    while (v4 < v3);
    uint64_t v2 = (std::__shared_weak_count **)*((void *)this + 6);
  }
  if (v2) {
    free(v2);
  }
  float32x2_t v7 = (void *)*((void *)this + 3);
  unint64_t v6 = *((void *)this + 4);
  if (v6)
  {
    for (unint64_t i = 0; i < v6; ++i)
    {
      long long v9 = (_DWORD *)v7[i];
      if (v9)
      {
        int v10 = v9[2] - 1;
        uint64_t v9[2] = v10;
        if (!v10)
        {
          (*(void (**)(_DWORD *))(*(void *)v9 + 8))(v9);
          unint64_t v6 = *((void *)this + 4);
        }
      }
    }
    float32x2_t v7 = (void *)*((void *)this + 3);
  }
  if (v7) {
    free(v7);
  }
}

{
  std::__shared_weak_count **v2;
  unint64_t v3;
  unint64_t v4;
  std::__shared_weak_count **v5;
  unint64_t v6;
  void *v7;
  unint64_t i;
  _DWORD *v9;
  int v10;
  uint64_t vars8;

  *(void *)this = &unk_26C4ED780;
  uint64_t v2 = (std::__shared_weak_count **)*((void *)this + 6);
  unint64_t v3 = *((void *)this + 7);
  if (v3)
  {
    unint64_t v4 = 0;
    int64x2_t v5 = v2 + 2;
    do
    {
      if (*v5)
      {
        std::__shared_weak_count::__release_shared[abi:nn180100](*v5);
        unint64_t v3 = *((void *)this + 7);
      }
      ++v4;
      v5 += 3;
    }
    while (v4 < v3);
    uint64_t v2 = (std::__shared_weak_count **)*((void *)this + 6);
  }
  if (v2) {
    free(v2);
  }
  float32x2_t v7 = (void *)*((void *)this + 3);
  unint64_t v6 = *((void *)this + 4);
  if (v6)
  {
    for (unint64_t i = 0; i < v6; ++i)
    {
      long long v9 = (_DWORD *)v7[i];
      if (v9)
      {
        int v10 = v9[2] - 1;
        uint64_t v9[2] = v10;
        if (!v10)
        {
          (*(void (**)(_DWORD *))(*(void *)v9 + 8))(v9);
          unint64_t v6 = *((void *)this + 4);
        }
      }
    }
    float32x2_t v7 = (void *)*((void *)this + 3);
  }
  if (v7) {
    free(v7);
  }
  JUMPOUT(0x21669AC10);
}

void std::__shared_weak_count::__release_shared[abi:nn180100](std::__shared_weak_count *a1)
{
  if (!atomic_fetch_add(&a1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

void *RB::Encoder::typed_message_field<RB::Coverage::Primitive>(RB::Encoder *a1, uint64_t a2, float32x4_t *a3)
{
  RB::ProtobufEncoder::encode_varint(a1, (8 * a2) | 2);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::ProtobufEncoder::encode_varint(a1, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::Coverage::Primitive::encode(a3, a1);
  RB::ProtobufEncoder::end_length_delimited(a1);
  return RB::ProtobufEncoder::end_length_delimited(a1);
}

void RB::XML::print_attributes<RB::Coverage::Primitive>()
{
}

void sub_21413DDBC(_Unwind_Exception *exception_object)
{
  int v3 = v1[2] - 1;
  v1[2] = v3;
  if (!v3) {
    (*(void (**)(_DWORD *))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

__n128 _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill8GradientEEEJRS5_RKS7_RPKNS_15AffineTransformEDF16_RNS_9BlendModeEEEEPT_DpOT0_(RB::Heap *this, long long *a2, uint64_t a3, uint64_t *a4, __int16 *a5, _WORD *a6)
{
  unint64_t v12 = *((void *)this + 3);
  unint64_t v13 = (*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v13 + 176 > v12) {
    unint64_t v13 = RB::Heap::alloc_slow((size_t *)this, 0xB0uLL, 15);
  }
  else {
    *((void *)this + 2) = v13 + 176;
  }
  uint64_t v14 = *a4;
  __int16 v15 = *a5;
  char v16 = *a6;
  *(void *)(v13 + 16) = 0;
  *(void *)(v13 + 24) = 0;
  *(_DWORD *)(v13 + 40) = 0;
  *(void *)(v13 + 32) = 0;
  *(_WORD *)(v13 + 44) = v15;
  *(_WORD *)(v13 + 46) = v16 & 0x3F;
  *(void *)unint64_t v13 = &unk_26C4EBB48;
  *(void *)(v13 + 48) = v14;
  long long v17 = *a2;
  long long v18 = a2[2];
  *(_OWORD *)(v13 + 80) = a2[1];
  *(_OWORD *)(v13 + 96) = v18;
  *(_OWORD *)(v13 + 64) = v17;
  __n128 result = *(__n128 *)a3;
  long long v20 = *(_OWORD *)(a3 + 16);
  long long v21 = *(_OWORD *)(a3 + 48);
  *(_OWORD *)(v13 + 144) = *(_OWORD *)(a3 + 32);
  *(_OWORD *)(v13 + 160) = v21;
  *(__n128 *)(v13 + 112) = result;
  *(_OWORD *)(v13 + 128) = v20;
  *(void *)unint64_t v13 = &unk_26C4EA3A8;
  return result;
}

void RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Gradient>::~GenericItem()
{
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::type_id()
{
  return 8392705;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Gradient>::copy(uint64_t a1, uint64_t a2)
{
  int v3 = (size_t *)(*(void *)(a2 + 8) + 16);
  int v6 = *(_WORD *)(a1 + 46) & 0x3F;
  unint64_t v4 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill8GradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v3, (RB::Heap *)v3, (long long *)(a1 + 64), (uint64_t *)(a1 + 112), (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), &v6);
  __n128 result = *(__n128 *)(a1 + 16);
  v4[1] = result;
  v4[2].n128_u64[0] = *(void *)(a1 + 32);
  v4[2].n128_u32[2] = *(_DWORD *)(a1 + 40);
  v4[2].n128_u16[7] |= *(_WORD *)(a1 + 46) & 0x5800;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  __n128 result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::atom_position(uint64_t a1, int8x16_t a2, int32x4_t a3, int8x16_t a4, int32x4_t a5)
{
  float32x2_t v5 = RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), *(float64x2_t **)(a1 + 48), a2, a3, a4, a5);
  return vmla_f32(v5, (float32x2_t)0x3F0000003F000000, v6);
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Gradient>::copy_shadow(__n128 *a1, uint64_t a2, uint64_t a3)
{
  if ((*(unsigned char *)(a3 + 88) & 0x10) == 0)
  {
    float v28 = 0.0;
    if (RB::Fill::Gradient::get_alpha((RB::Fill::Gradient *)&a1[7], &v28)
      && (RB::DisplayList::Item::clip_affects_blurred_bounds((RB::DisplayList::Item *)a1, *(float *)(a3 + 64)) & 1) == 0)
    {
      memset(v25, 0, sizeof(v25));
      int v26 = 1065353216;
      v27[0] = 0;
      *(_DWORD *)((char *)v27 + 7) = 0;
      float32x2_t v7 = *(float64x2_t **)(a3 + 16);
      float64x2_t v8 = (float64x2_t *)a1[3].n128_u64[0];
      float64x2_t v9 = *v8;
      float64x2_t v10 = v8[2];
      float64x2_t v30 = v8[1];
      float64x2_t v31 = v10;
      float64x2_t v29 = v9;
      if (RB::AffineTransform::invert((RB::AffineTransform *)&v29)) {
        uint64_t v11 = &v29;
      }
      else {
        uint64_t v11 = v8;
      }
      float64x2_t v12 = v11[1];
      float64x2_t v13 = v11[2];
      v24[0] = *v11;
      v24[1] = v12;
      v24[2] = v13;
      v14.f64[0] = RB::operator*(v7, v24);
      float64x2_t v29 = v14;
      float64x2_t v30 = v15;
      float64x2_t v31 = v16;
      if (RB::Coverage::Primitive::make_shadow((RB::Coverage::Primitive *)&a1[4], &v29, *(float *)(a3 + 64), &v28, (*(_DWORD *)(a3 + 88) >> 2) & 1, (RB::Coverage::Primitive *)v25))
      {
        _H1 = a1[2].n128_u16[6];
        __asm { FCVT            S1, H1 }
        RB::DisplayList::ShadowStyle::make_primitive(a3, a2, v25, a1[3].n128_i64[0], a1[2].n128_u16[7] & 0x3F, v28, _S1);
        __n128 result = a1[1];
        v23[1] = result;
        v23[2].n128_u64[0] = a1[2].n128_u64[0];
        v23[2].n128_u32[2] = a1[2].n128_u32[2];
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::make_clip(uint64_t a1, uint64_t a2, unsigned int a3, void *a4, float a5)
{
  float v22 = 0.0;
  unsigned int v23 = a3;
  if (RB::Fill::Gradient::get_alpha((RB::Fill::Gradient *)(a1 + 112), &v22))
  {
    uint64_t v11 = (size_t *)(*(void *)(a2 + 8) + 16);
    _Q0.n128_u16[0] = *(_WORD *)(a1 + 44);
    __asm { FCVT            S0, H0 }
    _Q0.n128_f32[0] = _Q0.n128_f32[0] * (float)(a5 * v22);
    unsigned __int32 v21 = _Q0.n128_u32[0];
    uint64_t v16 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v11, (int8x16_t)_Q0, (uint64_t)v11, (_OWORD *)(a1 + 64), &v21, (int *)&v23, (uint64_t *)(a1 + 48));
    uint64_t v17 = a4[5];
    size_t v18 = v17 + 1;
    if (a4[6] < (unint64_t)(v17 + 1))
    {
      RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v18);
      uint64_t v17 = a4[5];
      size_t v18 = v17 + 1;
    }
    int v19 = (void *)a4[4];
    if (!v19) {
      int v19 = a4;
    }
    v19[v17] = v16;
    a4[5] = v18;
    return (**(uint64_t (***)(uint64_t))a1)(a1);
  }
  else
  {
    _Q0.n128_f32[0] = a5;
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, _Q0);
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::can_append_color_matrix()
{
  return 1;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::append_color_matrix(uint64_t a1, float16x4_t *a2, uint64_t a3, __int16 a4)
{
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Gradient>::append_blur()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::append_alpha_gradient()
{
  return 0;
}

float RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::min_scale(uint64_t a1)
{
  float result = 0.0;
  if (*(unsigned __int8 *)(a1 + 108) >= 2u && *(unsigned char *)(a1 + 109) == 1) {
    return 1.0;
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::has_no_effect(uint64_t a1)
{
  __asm { FCMP            H0, #0 }
  if (_ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  else {
    return 0;
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::render(float32x2_t *a1, double a2, uint64_t a3, uint64_t a4, int a5, unsigned int a6)
{
  float32x2_t v6 = (float64x2_t *)a1[6];
  v7.i64[0] = SLODWORD(a2);
  v7.i64[1] = SHIDWORD(a2);
  float64x2_t v8 = v6[1];
  _Q0 = vaddq_f64(v6[2], vcvtq_f64_s64(v7));
  v15[0] = *v6;
  v15[1] = v8;
  void v15[2] = _Q0;
  LOWORD(_Q0.f64[0]) = a1[5].i16[2];
  __asm { FCVT            S0, H0 }
  return RB::render_primitive(a4, v15, (uint64_t)&a1[8], a1 + 14, a5, a6, *(float *)_Q0.f64);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 112), a2);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, float64x2_t **a4)
{
  float result = (unint64_t *)(*(uint64_t (**)(float64x2_t **))&(*a4)[1].f64[0])(a4);
  if (result == 8392705)
  {
    float result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      float result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), a4[6], v10);
      int v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        float result = (unint64_t *)RB::Coverage::Primitive::can_mix(a1 + 64, (uint64_t)a3, (uint64_t)(a4 + 8));
        if ((_BYTE)result)
        {
          unsigned __int8 v13 = result;
          can_midouble x = RB::Fill::Gradient::can_mix((uint64_t *)(a1 + 112), (uint64_t)(a4 + 14), v12);
          return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v13, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8 = (*(uint64_t (**)(CGAffineTransform **, void, void, void, uint64_t))&(*a1)[1].a)(a1, *(void *)&a4->f64[0], *(unsigned int *)(*(void *)(a2 + 8) + 12), **(void **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v17[0] = v10;
  v17[1] = v11;
  v17[2] = v12;
  *(void *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v17);
  LODWORD(v13) = *(_DWORD *)(a2 + 16);
  RB::Fill::Gradient::mix((RB::Fill::Gradient *)(v8 + 112), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::Gradient *)(a3 + 112), v13, (RB::Heap *)(*(void *)(*(void *)&a4->f64[0] + 8) + 16));
  RB::operator*((float64x2_t *)a1[6], a4 + 68);
  double v14 = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  RB::Coverage::Primitive::mix(v8 + 64, a2, a3 + 64, v14, v15);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(unsigned char *)(*(void *)&a4->f64[0] + 272)) {
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

void *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::encode(float32x4_t *a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Primitive>(this, 1, a1 + 4);
  RB::Encoder::typed_message_field<RB::Fill::Gradient>(this, 2, (RB::Fill::Gradient *)&a1[7]);
  unint64_t v4 = (float64x2_t *)a1[3].i64[0];
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::print(const RB::AffineTransform **a1, std::string *this)
{
}

unint64_t _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill8GradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(size_t *a1, RB::Heap *a2, long long *a3, uint64_t *a4, uint64_t *a5, __int16 *a6, _WORD *a7)
{
  unint64_t v13 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v13 + 176 > a1[3]) {
    unint64_t v13 = RB::Heap::alloc_slow(a1, 0xB0uLL, 15);
  }
  else {
    a1[2] = v13 + 176;
  }
  uint64_t v14 = *a5;
  __int16 v15 = *a6;
  char v16 = *a7;
  *(void *)(v13 + 16) = 0;
  *(void *)(v13 + 24) = 0;
  *(_DWORD *)(v13 + 40) = 0;
  *(void *)(v13 + 32) = 0;
  *(_WORD *)(v13 + 44) = v15;
  *(_WORD *)(v13 + 46) = v16 & 0x3F;
  *(void *)unint64_t v13 = &unk_26C4EBB48;
  *(void *)(v13 + 48) = v14;
  long long v17 = *a3;
  long long v18 = a3[1];
  *(_OWORD *)(v13 + 95) = *(long long *)((char *)a3 + 31);
  *(_OWORD *)(v13 + 64) = v17;
  *(_OWORD *)(v13 + 80) = v18;
  RB::Fill::Gradient::Gradient((uint64_t *)(v13 + 112), a4, 0, a2);
  *(void *)unint64_t v13 = &unk_26C4EA3A8;
  return v13;
}

__n128 RB::DisplayList::GenericItemCopyVisitor<RB::Fill::Gradient>::visit_<RB::Coverage::Primitive>(void *a1, long long *a2)
{
  int v3 = (uint64_t *)a1[3];
  unint64_t v4 = a1 + 4;
  int64x2_t v5 = (size_t *)a1[1];
  uint64_t v6 = a1[2];
  int v10 = *(_WORD *)(v6 + 46) & 0x3F;
  int64x2_t v7 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill8GradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, (RB::Heap *)v5, a2, v3, v4, (__int16 *)(v6 + 44), &v10);
  a1[5] = v7;
  uint64_t v8 = (__n128 *)a1[2];
  __n128 result = v8[1];
  v7[1] = result;
  v7[2].n128_u64[0] = v8[2].n128_u64[0];
  v7[2].n128_u32[2] = v8[2].n128_u32[2];
  v7[2].n128_u16[7] |= v8[2].n128_u16[7] & 0x5800;
  return result;
}

__n128 RB::DisplayList::GenericItemCopyVisitor<RB::Fill::Gradient>::visit_<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(void *a1, uint64_t a2)
{
  int v3 = (uint64_t *)a1[3];
  unint64_t v4 = a1 + 4;
  int64x2_t v5 = (RB::Heap *)a1[1];
  uint64_t v6 = a1[2];
  int v10 = *(_WORD *)(v6 + 46) & 0x3F;
  int64x2_t v7 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill8GradientEEEJRS0_RKS7_RKS9_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, v5, a2, v3, v4, (__int16 *)(v6 + 44), &v10);
  a1[5] = v7;
  uint64_t v8 = (__n128 *)a1[2];
  __n128 result = v8[1];
  v7[1] = result;
  v7[2].n128_u64[0] = v8[2].n128_u64[0];
  v7[2].n128_u32[2] = v8[2].n128_u32[2];
  v7[2].n128_u16[7] |= v8[2].n128_u16[7] & 0x5800;
  return result;
}

void *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill8GradientEEEJRS0_RKS7_RKS9_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, RB::Heap *a2, uint64_t a3, uint64_t *a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14 = *((void *)this + 3);
  uint64_t v15 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 208 > v14) {
    uint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0xD0uLL, 7);
  }
  else {
    *((void *)this + 2) = v15 + 208;
  }
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  __n128 result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  *__n128 result = &unk_26C4E9F48;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::GenericItem1(uint64_t a1, RB::Heap *a2, uint64_t a3, uint64_t *a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  __asm { FCVT            H0, S0 }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F;
  *(void *)a1 = &unk_26C4EB6E8;
  *(void *)(a1 + 48) = a5;
  *(void *)(a1 + 56) = &unk_26C4EDD48;
  RB::Coverage::StrokeablePath::StrokeablePath(a1 + 64, a3 + 8, a2);
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a3 + 56);
  *(unsigned char *)(a1 + 128) = *(unsigned char *)(a3 + 72);
  *(_WORD *)(a1 + 129) = *(_WORD *)(a3 + 73);
  *(unsigned char *)(a1 + 131) = *(unsigned char *)(a3 + 75);
  *(unsigned char *)(a1 + 132) = *(unsigned char *)(a3 + 76);
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a3 + 80);
  RB::Fill::Gradient::Gradient((uint64_t *)(a1 + 144), a4, a7, a2);
  return a1;
}

void sub_21413EB10(_Unwind_Exception *a1)
{
  v1[7] = v2;
  RBPathRelease(v1[8], v1[9]);
  _Unwind_Resume(a1);
}

void *RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4EB6E8;
  a1[7] = &unk_26C4EDD48;
  RBPathRelease(a1[8], a1[9]);
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4EB6E8;
  a1[7] = &unk_26C4EDD48;
  RBPathRelease(a1[8], a1[9]);
  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::type_id()
{
  return 8400897;
}

void *RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::copy(uint64_t a1, uint64_t a2, char a3)
{
  __int16 v4 = 0;
  int64x2_t v5 = (uint64_t (**)(void, long long *))(*(void *)(a2 + 8) + 16);
  __int16 v6 = *(_WORD *)(a1 + 46);
  if ((a3 & 2) != 0) {
    goto LABEL_9;
  }
  if ((*(_WORD *)(a1 + 46) & 0x1000) != 0 || *(unsigned char *)(a2 + 272) == 0) {
    goto LABEL_9;
  }
  v10[0] = (uint64_t (**)(void, long long *))&unk_26C4E7FD0;
  v10[1] = v5;
  v10[2] = (uint64_t (**)(void, long long *))a1;
  float64x2_t v10[3] = (uint64_t (**)(void, long long *))(a1 + 144);
  v10[4] = *(uint64_t (***)(void, long long *))(a1 + 48);
  uint64_t v11 = 0;
  RB::Coverage::StrokeablePath::simplify(a1 + 64, a1 + 56, v10);
  __n128 result = (void *)v11;
  if (!v11)
  {
    __int16 v6 = *(_WORD *)(a1 + 46);
    __int16 v4 = 4096;
LABEL_9:
    LODWORD(v10[0]) = v6 & 0x3F;
    __n128 result = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill8GradientEEEJRS0_RKS7_RKS9_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_((RB::Heap *)v5, (RB::Heap *)v5, a1 + 56, (uint64_t *)(a1 + 144), (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), v10);
    *((_OWORD *)result + 1) = *(_OWORD *)(a1 + 16);
    result[4] = *(void *)(a1 + 32);
    *((_DWORD *)result + 10) = *(_DWORD *)(a1 + 40);
    __int16 v9 = *((_WORD *)result + 23) | *(_WORD *)(a1 + 46) & 0x5800;
    *((_WORD *)result + 23) = v9;
    goto LABEL_10;
  }
  __int16 v9 = *(_WORD *)(v11 + 46);
  __int16 v4 = 4096;
LABEL_10:
  *((_WORD *)result + 23) = v9 | v4;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  __n128 result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::atom_position(uint64_t a1, double a2, int32x4_t a3)
{
  float32x2_t v3 = RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, *(float64x2_t **)(a1 + 48), a2, a3);
  return vmla_f32(v3, (float32x2_t)0x3F0000003F000000, v4);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::make_clip(uint64_t a1, uint64_t a2, unsigned int a3, void *a4, float a5)
{
  float v24 = 0.0;
  unsigned int v25 = a3;
  if (RB::Fill::Gradient::get_alpha((RB::Fill::Gradient *)(a1 + 144), &v24))
  {
    uint64_t v11 = (size_t *)(*(void *)(a2 + 8) + 16);
    _H0 = *(_WORD *)(a1 + 44);
    __asm { FCVT            S0, H0 }
    float v23 = _S0 * (float)(a5 * v24);
    uint64_t v18 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath>&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v11, (uint64_t)v11, a1 + 56, (int *)&v23, &v25, (uint64_t *)(a1 + 48));
    uint64_t v19 = a4[5];
    size_t v20 = v19 + 1;
    if (a4[6] < (unint64_t)(v19 + 1))
    {
      RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v20);
      uint64_t v19 = a4[5];
      size_t v20 = v19 + 1;
    }
    unsigned __int32 v21 = (void *)a4[4];
    if (!v21) {
      unsigned __int32 v21 = a4;
    }
    v21[v19] = v18;
    a4[5] = v20;
    return (**(uint64_t (***)(uint64_t))a1)(a1);
  }
  else
  {
    v10.n128_f32[0] = a5;
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, v10);
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::can_append_color_matrix()
{
  return 1;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::append_color_matrix(uint64_t a1, float16x4_t *a2, uint64_t a3, __int16 a4)
{
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 200);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::bounds(uint64_t a1, double a2, int32x4_t a3)
{
  return RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, *(float64x2_t **)(a1 + 48), a2, a3);
}

float RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::min_scale(uint64_t a1)
{
  float result = 0.0;
  if (!*(unsigned char *)(a1 + 128) && *(unsigned char *)(a1 + 132) == 1) {
    return 1.0;
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::has_no_effect(uint64_t a1)
{
  __asm { FCMP            H0, #0 }
  if (_ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  else {
    return 0;
  }
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::render(uint64_t a1, double a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  uint64_t v6 = *(void *)(a1 + 48);
  v7.i64[0] = SLODWORD(a2);
  v7.i64[1] = SHIDWORD(a2);
  long long v8 = *(_OWORD *)(v6 + 16);
  float64x2_t v9 = vaddq_f64(*(float64x2_t *)(v6 + 32), vcvtq_f64_s64(v7));
  v16[0] = *(_OWORD *)v6;
  v16[1] = v8;
  float32x2_t v16[2] = v9;
  _H0 = *(_WORD *)(a1 + 44);
  int v17 = *(unsigned __int8 *)(a1 + 128);
  __int16 v18 = *(_WORD *)(a1 + 129);
  int v19 = *(unsigned __int8 *)(a1 + 131);
  char v20 = *(unsigned char *)(a1 + 132);
  int v21 = *(_DWORD *)(a1 + 136);
  int v22 = 1065353216;
  uint64_t v23 = 1;
  uint64_t v24 = 0;
  if (v17 == 1) {
    abort();
  }
  __asm { FCVT            S0, H0 }
  RB::render_stroke(a4, (uint64_t (**)(void, void *, __n128, __n128))v16, a1 + 56, (uint64_t)&v17, (uint64_t (**)(void, void *, __n128, __n128))(a1 + 144), a5, a6, _S0);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 144), a2);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, uint64_t a4)
{
  float result = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)a4 + 16))(a4);
  if (result == 8400897)
  {
    float result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      float result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a4 + 48), v10);
      int v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        if (*(unsigned __int8 *)(a1 + 128) == *(unsigned __int8 *)(a4 + 128)
          && *(unsigned __int8 *)(a1 + 129) == *(unsigned __int8 *)(a4 + 129)
          && *(unsigned __int8 *)(a1 + 130) == *(unsigned __int8 *)(a4 + 130)
          && *(unsigned __int8 *)(a1 + 131) == *(unsigned __int8 *)(a4 + 131)
          && *(unsigned __int8 *)(a1 + 132) == *(unsigned __int8 *)(a4 + 132)
          && *(float *)(a1 + 136) == *(float *)(a4 + 136))
        {
          float result = (unint64_t *)RB::Coverage::StrokeablePath::can_mix(a1 + 64, a4 + 64, v12);
          if ((_BYTE)result)
          {
            unsigned __int8 v14 = result;
            can_midouble x = RB::Fill::Gradient::can_mix((uint64_t *)(a1 + 144), a4 + 144, v13);
            return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v14, can_mix);
          }
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8 = (*(uint64_t (**)(CGAffineTransform **, void, void, void, uint64_t))&(*a1)[1].a)(a1, *(void *)&a4->f64[0], *(unsigned int *)(*(void *)(a2 + 8) + 12), **(void **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v26[0] = v10;
  v26[1] = v11;
  v26[2] = v12;
  *(void *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v26);
  unint64_t v13 = (RB::Heap *)(*(void *)(*(void *)&a4->f64[0] + 8) + 16);
  LODWORD(v14) = *(_DWORD *)(a2 + 16);
  RB::Fill::Gradient::mix((RB::Fill::Gradient *)(v8 + 144), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::Gradient *)(a3 + 144), v14, v13);
  *(double *)&long long v15 = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  long long v23 = v15;
  long long v24 = v16;
  long long v25 = v17;
  *(double *)&long long v18 = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  v22[0] = v18;
  v22[1] = v19;
  void v22[2] = v20;
  LODWORD(v18) = *(_DWORD *)(a2 + 16);
  RB::Coverage::StrokeablePath::mix(v8 + 64, v13, a3 + 64, (uint64_t)&v23, (uint64_t)v22, *(void *)(v8 + 48), *(CGFloat *)&v18);
  *(float *)(v8 + 136) = *(float *)(v8 + 136)
                       + (float)((float)(*(float *)(a3 + 136) - *(float *)(v8 + 136)) * *(float *)(a2 + 16));
  *(void *)(v8 + 112) = 0x100000001000000;
  *(int32x2_t *)(v8 + 120) = vdup_n_s32(0x7F7FFFFFu);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(unsigned char *)(*(void *)&a4->f64[0] + 272))
  {
    *(void *)&long long v23 = &unk_26C4E7FD0;
    *((void *)&v23 + 1) = v13;
    *(void *)&long long v24 = v8;
    *((void *)&v24 + 1) = v8 + 144;
    long long v25 = *(unint64_t *)(v8 + 48);
    RB::Coverage::StrokeablePath::simplify(v8 + 64, v8 + 56, (uint64_t (***)(void, long long *))&v23);
    if (*((void *)&v25 + 1))
    {
      *(void *)uint64_t v8 = &unk_26C4EB6E8;
      *(void *)(v8 + 56) = &unk_26C4EDD48;
      RBPathRelease(*(void *)(v8 + 64), *(void *)(v8 + 72));
      uint64_t v8 = *((void *)&v25 + 1);
    }
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

void *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::encode(void *a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(this, 1, (uint64_t)(a1 + 7));
  RB::Encoder::typed_message_field<RB::Fill::Gradient>(this, 2, (RB::Fill::Gradient *)(a1 + 18));
  float32x2_t v4 = (float64x2_t *)a1[6];
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::print(const RB::AffineTransform **a1, std::string *this)
{
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath>&,float &,RB::ClipMode &,RB::AffineTransform const*&>(size_t *a1, uint64_t a2, uint64_t a3, int *a4, _DWORD *a5, uint64_t *a6)
{
  uint64_t v11 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v11 + 152 > a1[3]) {
    uint64_t v11 = RB::Heap::alloc_slow(a1, 0x98uLL, 7);
  }
  else {
    a1[2] = v11 + 152;
  }
  int v12 = *a4;
  char v13 = *a5;
  uint64_t v14 = *a6;
  *(void *)(v11 + 16) = 0;
  *(void *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(void *)(v11 + 32) = 0;
  *(unsigned char *)(v11 + 44) = v13;
  *(unsigned char *)(v11 + 45) = 0;
  *(void *)uint64_t v11 = &unk_26C4E8DB0;
  *(void *)(v11 + 48) = v14;
  *(void *)(v11 + 56) = &unk_26C4EDD48;
  RB::Coverage::StrokeablePath::StrokeablePath(v11 + 64, a3 + 8, a2);
  long long v15 = *(_OWORD *)(a3 + 56);
  *(_OWORD *)(v11 + 112) = v15;
  *(unsigned char *)(v11 + 128) = *(unsigned char *)(a3 + 72);
  *(_WORD *)(v11 + 129) = *(_WORD *)(a3 + 73);
  *(unsigned char *)(v11 + 131) = *(unsigned char *)(a3 + 75);
  *(unsigned char *)(v11 + 132) = *(unsigned char *)(a3 + 76);
  LODWORD(v15) = *(_DWORD *)(a3 + 80);
  *(_DWORD *)(v11 + 136) = v15;
  *(_DWORD *)(v11 + 144) = v12;
  RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::update_bounds(v11, *(double *)&v15, v16);
  return v11;
}

void sub_21413F618(_Unwind_Exception *a1)
{
  v1[7] = v2;
  RBPathRelease(v1[8], v1[9]);
  _Unwind_Resume(a1);
}

void *RB::Encoder::typed_message_field<RB::Fill::Gradient>(RB::Encoder *a1, uint64_t a2, RB::Fill::Gradient *a3)
{
  RB::ProtobufEncoder::encode_varint(a1, (8 * a2) | 2);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::ProtobufEncoder::encode_varint(a1, 0x12uLL);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::Fill::Gradient::encode(a3, a1);
  RB::ProtobufEncoder::end_length_delimited(a1);
  return RB::ProtobufEncoder::end_length_delimited(a1);
}

void RB::XML::print_attributes<RB::Fill::Gradient>()
{
}

void sub_21413F790(_Unwind_Exception *exception_object)
{
  int v3 = v1[2] - 1;
  v1[2] = v3;
  if (!v3) {
    (*(void (**)(_DWORD *))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void *RB::Encoder::typed_message_field<RB::Fill::Color>(RB::Encoder *a1, uint64_t a2, RB::Fill::Color *a3)
{
  RB::ProtobufEncoder::encode_varint(a1, (8 * a2) | 2);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::ProtobufEncoder::encode_varint(a1, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::Fill::Color::encode(a3, a1);
  RB::ProtobufEncoder::end_length_delimited(a1);
  return RB::ProtobufEncoder::end_length_delimited(a1);
}

void RB::XML::print_attributes<RB::Fill::Color>()
{
}

void sub_21413F934(_Unwind_Exception *exception_object)
{
  int v3 = v1[2] - 1;
  v1[2] = v3;
  if (!v3) {
    (*(void (**)(_DWORD *))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

__n128 RB::DisplayList::GenericItemCopyVisitor<RB::Fill::Color>::visit_<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[3];
  float32x2_t v4 = a1 + 4;
  int64x2_t v5 = (RB::Heap *)a1[1];
  uint64_t v6 = a1[2];
  int v10 = *(_WORD *)(v6 + 46) & 0x3F;
  int64x2_t v7 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill5ColorEEEJRS0_RKS7_RKS9_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, (uint64_t)v5, a2, v3, v4, (__int16 *)(v6 + 44), &v10);
  a1[5] = v7;
  uint64_t v8 = (__n128 *)a1[2];
  __n128 result = v8[1];
  v7[1] = result;
  v7[2].n128_u64[0] = v8[2].n128_u64[0];
  v7[2].n128_u32[2] = v8[2].n128_u32[2];
  v7[2].n128_u16[7] |= v8[2].n128_u16[7] & 0x5800;
  return result;
}

void *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill5ColorEEEJRS0_RKS7_RKS9_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14 = *((void *)this + 3);
  uint64_t v15 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 160 > v14) {
    uint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0xA0uLL, 7);
  }
  else {
    *((void *)this + 2) = v15 + 160;
  }
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  __n128 result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  *__n128 result = &unk_26C4E9C00;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::GenericItem1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  __asm { FCVT            H0, S0 }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F;
  *(void *)a1 = &unk_26C4EB3A0;
  *(void *)(a1 + 48) = a5;
  *(void *)(a1 + 56) = &unk_26C4EDD48;
  RB::Coverage::StrokeablePath::StrokeablePath(a1 + 64, a3 + 8, a2);
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a3 + 56);
  *(unsigned char *)(a1 + 128) = *(unsigned char *)(a3 + 72);
  *(_WORD *)(a1 + 129) = *(_WORD *)(a3 + 73);
  *(unsigned char *)(a1 + 131) = *(unsigned char *)(a3 + 75);
  *(unsigned char *)(a1 + 132) = *(unsigned char *)(a3 + 76);
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a3 + 80);
  if (*(unsigned char *)(a4 + 9)) {
    __int16 v17 = *(_WORD *)(a4 + 8);
  }
  else {
    __int16 v17 = a7;
  }
  *(void *)(a1 + 144) = *(void *)a4;
  *(_WORD *)(a1 + 152) = v17;
  return a1;
}

void *RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4EB3A0;
  a1[7] = &unk_26C4EDD48;
  RBPathRelease(a1[8], a1[9]);
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4EB3A0;
  a1[7] = &unk_26C4EDD48;
  RBPathRelease(a1[8], a1[9]);
  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::type_id()
{
  return 4206593;
}

void *RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::copy(uint64_t a1, uint64_t a2, char a3)
{
  __int16 v4 = 0;
  int64x2_t v5 = (uint64_t (**)(void, long long *))(*(void *)(a2 + 8) + 16);
  __int16 v6 = *(_WORD *)(a1 + 46);
  if ((a3 & 2) != 0) {
    goto LABEL_9;
  }
  if ((*(_WORD *)(a1 + 46) & 0x1000) != 0 || *(unsigned char *)(a2 + 272) == 0) {
    goto LABEL_9;
  }
  v10[0] = (uint64_t (**)(void, long long *))&unk_26C4E7F70;
  v10[1] = v5;
  v10[2] = (uint64_t (**)(void, long long *))a1;
  float64x2_t v10[3] = (uint64_t (**)(void, long long *))(a1 + 144);
  v10[4] = *(uint64_t (***)(void, long long *))(a1 + 48);
  uint64_t v11 = 0;
  RB::Coverage::StrokeablePath::simplify(a1 + 64, a1 + 56, v10);
  __n128 result = (void *)v11;
  if (!v11)
  {
    __int16 v6 = *(_WORD *)(a1 + 46);
    __int16 v4 = 4096;
LABEL_9:
    LODWORD(v10[0]) = v6 & 0x3F;
    __n128 result = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill5ColorEEEJRS0_RKS7_RKS9_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_((RB::Heap *)v5, (uint64_t)v5, a1 + 56, a1 + 144, (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), v10);
    *((_OWORD *)result + 1) = *(_OWORD *)(a1 + 16);
    result[4] = *(void *)(a1 + 32);
    *((_DWORD *)result + 10) = *(_DWORD *)(a1 + 40);
    __int16 v9 = *((_WORD *)result + 23) | *(_WORD *)(a1 + 46) & 0x5800;
    *((_WORD *)result + 23) = v9;
    goto LABEL_10;
  }
  __int16 v9 = *(_WORD *)(v11 + 46);
  __int16 v4 = 4096;
LABEL_10:
  *((_WORD *)result + 23) = v9 | v4;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  __n128 result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::atom_position(uint64_t a1, double a2, int32x4_t a3)
{
  float32x2_t v3 = RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, *(float64x2_t **)(a1 + 48), a2, a3);
  return vmla_f32(v3, (float32x2_t)0x3F0000003F000000, v4);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::make_clip(uint64_t a1, uint64_t a2, int a3, void *a4, float a5)
{
  int v22 = a3;
  _H1 = *(_WORD *)(a1 + 150);
  __asm { FCVT            S1, H1 }
  char v13 = (size_t *)(*(void *)(a2 + 8) + 16);
  _H2 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S2, H2 }
  float v21 = (float)(_S1 * a5) * _S2;
  uint64_t v16 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath>&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v13, (uint64_t)v13, a1 + 56, (int *)&v21, &v22, (uint64_t *)(a1 + 48));
  uint64_t v17 = a4[5];
  size_t v18 = v17 + 1;
  if (a4[6] < (unint64_t)(v17 + 1))
  {
    RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v18);
    uint64_t v17 = a4[5];
    size_t v18 = v17 + 1;
  }
  long long v19 = (void *)a4[4];
  if (!v19) {
    long long v19 = a4;
  }
  v19[v17] = v16;
  a4[5] = v18;
  return (**(uint64_t (***)(uint64_t))a1)(a1);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::can_append_color_matrix()
{
  return 1;
}

double RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::append_color_matrix(uint64_t a1, float16x4_t *a2, int a3, __int16 a4, uint16x4_t a5)
{
  *(void *)&double result = RB::Fill::Color::append_color_matrix((short float *)(a1 + 144), a2, a3, a4, a5);
  return result;
}

void *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::append_alpha_gradient(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  int v8 = *(_WORD *)(a1 + 46) & 0x3F;
  float32x2_t v4 = (RB::Heap *)(*(void *)(a2 + 8) + 16);
  short float v7 = *(short float *)(a1 + 150) * *(short float *)(a1 + 44);
  int64x2_t v5 = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill8GradientEEEJRS7_RKS9_RPKNS_15AffineTransformEDF16_RNS_9BlendModeEEEEPT_DpOT0_(v4, a1 + 56, a3, (uint64_t *)(a1 + 48), (__int16 *)&v7, &v8);
  *((_OWORD *)v5 + 1) = *(_OWORD *)(a1 + 16);
  void v5[4] = *(void *)(a1 + 32);
  *((_DWORD *)v5 + 10) = *(_DWORD *)(a1 + 40);
  (**(void (***)(uint64_t))a1)(a1);
  return v5;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::required_depth(float16x4_t *a1)
{
  return RB::Fill::Color::required_depth(a1 + 18);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::bounds(uint64_t a1, double a2, int32x4_t a3)
{
  return RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, *(float64x2_t **)(a1 + 48), a2, a3);
}

float RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::min_scale(uint64_t a1)
{
  float result = 0.0;
  if (!*(unsigned char *)(a1 + 128) && *(unsigned char *)(a1 + 132) == 1) {
    return 1.0;
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::has_no_effect(uint64_t a1)
{
  __asm { FCMP            H0, #0 }
  if (_ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  __asm { FCMP            H0, #0 }
  if (_NF ^ _VF | _ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  else {
    return 0;
  }
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::render(uint64_t a1, double a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  __int16 v6 = *(float64x2_t **)(a1 + 48);
  v7.i64[0] = SLODWORD(a2);
  v7.i64[1] = SHIDWORD(a2);
  float64x2_t v8 = v6[1];
  float64x2_t v9 = vaddq_f64(v6[2], vcvtq_f64_s64(v7));
  v11[0] = *v6;
  v11[1] = v8;
  float32x2_t v11[2] = v9;
  short float v10 = *(short float *)(a1 + 44);
  int v14 = *(unsigned __int8 *)(a1 + 128);
  __int16 v15 = *(_WORD *)(a1 + 129);
  int v16 = *(unsigned __int8 *)(a1 + 131);
  char v17 = *(unsigned char *)(a1 + 132);
  int v18 = *(_DWORD *)(a1 + 136);
  int v19 = 1065353216;
  uint64_t v20 = 1;
  uint64_t v21 = 0;
  if (v14 == 1) {
    abort();
  }
  LOWORD(v12) = *(_WORD *)(a1 + 144);
  *(_DWORD *)((char *)&v12 + 2) = *(_DWORD *)(a1 + 146);
  *((short float *)&v12 + 3) = *(short float *)(a1 + 150) * v10;
  __int16 v13 = *(_WORD *)(a1 + 152);
  RB::render_stroke(a4, v11, a1 + 56, (uint64_t)&v14, &v12, a5, a6);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::Fill::Color::matches((RB::Fill::Color *)(a1 + 144), a2, a3);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::apply_transform(uint64_t a1, const RB::DisplayList::Transform *a2, uint64_t a3, uint32x4_t a4)
{
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, uint64_t a4)
{
  float result = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)a4 + 16))(a4);
  if (result == 4206593)
  {
    float result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      float result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a4 + 48), v10);
      int v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        if (*(unsigned __int8 *)(a1 + 128) == *(unsigned __int8 *)(a4 + 128)
          && *(unsigned __int8 *)(a1 + 129) == *(unsigned __int8 *)(a4 + 129)
          && *(unsigned __int8 *)(a1 + 130) == *(unsigned __int8 *)(a4 + 130)
          && *(unsigned __int8 *)(a1 + 131) == *(unsigned __int8 *)(a4 + 131)
          && *(unsigned __int8 *)(a1 + 132) == *(unsigned __int8 *)(a4 + 132)
          && *(float *)(a1 + 136) == *(float *)(a4 + 136))
        {
          float result = (unint64_t *)RB::Coverage::StrokeablePath::can_mix(a1 + 64, a4 + 64, v12);
          if ((_BYTE)result)
          {
            unsigned __int8 v13 = result;
            can_midouble x = RB::Fill::Color::can_mix((RB::Fill::Color *)(a1 + 144), (const RB::Fill::Color *)(a4 + 144));
            return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v13, can_mix);
          }
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8 = (*(uint64_t (**)(CGAffineTransform **, void, void, void, uint64_t))&(*a1)[1].a)(a1, *(void *)&a4->f64[0], *(unsigned int *)(*(void *)(a2 + 8) + 12), **(void **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v25[0] = v10;
  v25[1] = v11;
  long long v25[2] = v12;
  *(void *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v25);
  unsigned __int8 v13 = (RB *)(*(void *)(*(void *)&a4->f64[0] + 8) + 16);
  RB::Fill::Color::mix(v8 + 144, a3 + 144, 3, *(float *)(a2 + 16));
  *(double *)&long long v14 = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  long long v22 = v14;
  long long v23 = v15;
  long long v24 = v16;
  *(double *)&long long v17 = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  v21[0] = v17;
  v21[1] = v18;
  int32x2_t v21[2] = v19;
  LODWORD(v17) = *(_DWORD *)(a2 + 16);
  RB::Coverage::StrokeablePath::mix(v8 + 64, v13, a3 + 64, (uint64_t)&v22, (uint64_t)v21, *(void *)(v8 + 48), *(CGFloat *)&v17);
  *(float *)(v8 + 136) = *(float *)(v8 + 136)
                       + (float)((float)(*(float *)(a3 + 136) - *(float *)(v8 + 136)) * *(float *)(a2 + 16));
  *(void *)(v8 + 112) = 0x100000001000000;
  *(int32x2_t *)(v8 + 120) = vdup_n_s32(0x7F7FFFFFu);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(unsigned char *)(*(void *)&a4->f64[0] + 272))
  {
    *(void *)&long long v22 = &unk_26C4E7F70;
    *((void *)&v22 + 1) = v13;
    *(void *)&long long v23 = v8;
    *((void *)&v23 + 1) = v8 + 144;
    long long v24 = *(unint64_t *)(v8 + 48);
    RB::Coverage::StrokeablePath::simplify(v8 + 64, v8 + 56, (uint64_t (***)(void, long long *))&v22);
    if (*((void *)&v24 + 1))
    {
      *(void *)uint64_t v8 = &unk_26C4EB3A0;
      *(void *)(v8 + 56) = &unk_26C4EDD48;
      RBPathRelease(*(void *)(v8 + 64), *(void *)(v8 + 72));
      uint64_t v8 = *((void *)&v24 + 1);
    }
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

void *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::encode(void *a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(this, 1, (uint64_t)(a1 + 7));
  RB::Encoder::typed_message_field<RB::Fill::Color>(this, 2, (RB::Fill::Color *)(a1 + 18));
  float32x2_t v4 = (float64x2_t *)a1[6];
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::print(const RB::AffineTransform **a1, std::string *this)
{
}

void *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill8GradientEEEJRS7_RKS9_RPKNS_15AffineTransformEDF16_RNS_9BlendModeEEEEPT_DpOT0_(RB::Heap *this, uint64_t a2, _OWORD *a3, uint64_t *a4, __int16 *a5, _DWORD *a6)
{
  unint64_t v12 = *((void *)this + 3);
  uint64_t v13 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v13 + 208 > v12) {
    uint64_t v13 = RB::Heap::alloc_slow((size_t *)this, 0xD0uLL, 7);
  }
  else {
    *((void *)this + 2) = v13 + 208;
  }
  _H0 = *a5;
  __asm { FCVT            S0, H0 }
  float result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::GenericItem1(v13, a2, a3, *a4, *a6, _S0);
  *float result = &unk_26C4E9F48;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::GenericItem1(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4, char a5, float _S0)
{
  __asm { FCVT            H0, S0 }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a5 & 0x3F;
  *(void *)a1 = &unk_26C4EB6E8;
  *(void *)(a1 + 48) = a4;
  *(void *)(a1 + 56) = &unk_26C4EDD48;
  *(void *)(a1 + 64) = RBPathRetain(*(void *)(a2 + 8), *(void *)(a2 + 16));
  *(void *)(a1 + 72) = v14;
  long long v15 = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 96) = v15;
  long long v16 = *(_OWORD *)(a2 + 68);
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 124) = v16;
  long long v18 = a3[2];
  long long v17 = a3[3];
  long long v19 = a3[1];
  *(_OWORD *)(a1 + 144) = *a3;
  *(_OWORD *)(a1 + 160) = v19;
  *(_OWORD *)(a1 + 176) = v18;
  *(_OWORD *)(a1 + 192) = v17;
  return a1;
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Path>,RB::Heap&,RB::Coverage::Path&,float &,RB::ClipMode &,RB::AffineTransform const*&>(size_t *a1, size_t *a2, uint64_t a3, int *a4, int *a5, uint64_t *a6)
{
  uint64_t v11 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v11 + 96 > a1[3]) {
    uint64_t v11 = RB::Heap::alloc_slow(a1, 0x60uLL, 7);
  }
  else {
    a1[2] = v11 + 96;
  }
  int v12 = *a4;
  int v13 = *a5;
  uint64_t v14 = *a6;
  *(void *)(v11 + 16) = 0;
  *(void *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(void *)(v11 + 32) = 0;
  *(_WORD *)(v11 + 44) = v13;
  *(void *)uint64_t v11 = &unk_26C4E8BE8;
  *(void *)(v11 + 48) = v14;
  *(void *)(v11 + 56) = RBPathRetain(*(void *)a3, *(void *)(a3 + 8));
  *(void *)(v11 + 64) = v15;
  long long v16 = *(long long **)(a3 + 16);
  if (v16)
  {
    long long v17 = (_OWORD *)((a2[2] + 15) & 0xFFFFFFFFFFFFFFF0);
    if ((unint64_t)(v17 + 3) > a2[3]) {
      long long v17 = (_OWORD *)RB::Heap::alloc_slow(a2, 0x30uLL, 15);
    }
    else {
      a2[2] = (size_t)(v17 + 3);
    }
    long long v18 = *v16;
    long long v19 = v16[2];
    v17[1] = v16[1];
    v17[2] = v19;
    *long long v17 = v18;
  }
  else
  {
    long long v17 = 0;
  }
  *(void *)(v11 + 72) = v17;
  *(_DWORD *)(v11 + 80) = *(_DWORD *)(a3 + 24);
  *(_WORD *)(v11 + 84) = *(_WORD *)(a3 + 28);
  *(_DWORD *)(v11 + 88) = v12;
  RB::DisplayList::GenericClip<RB::Coverage::Path>::update_bounds(v11);
  return v11;
}

void sub_2141408CC(_Unwind_Exception *a1)
{
  RBPathRelease(*(void *)(v1 + 56), *(void *)(v1 + 64));
  _Unwind_Resume(a1);
}

void RB::DisplayList::GenericClip<RB::Coverage::Path>::~GenericClip(uint64_t a1)
{
  RBPathRelease(*(void *)(a1 + 56), *(void *)(a1 + 64));
  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Path>::type_id()
{
  return 8194;
}

float RB::DisplayList::GenericClip<RB::Coverage::Path>::min_scale(uint64_t a1)
{
  return RB::Coverage::Path::min_scale((RB::Coverage::Path *)(a1 + 56), *(const RB::AffineTransform **)(a1 + 48));
}

void RB::DisplayList::GenericClip<RB::Coverage::Path>::render(uint64_t a1, int a2, RB::RenderPass *a3, double a4, int a5)
{
  v16[5] = *(int32x2_t **)MEMORY[0x263EF8340];
  uint64_t v6 = *(void *)(a1 + 48);
  v7.i64[0] = SLODWORD(a4);
  v7.i64[1] = SHIDWORD(a4);
  long long v8 = *(_OWORD *)(v6 + 16);
  float64x2_t v9 = vaddq_f64(*(float64x2_t *)(v6 + 32), vcvtq_f64_s64(v7));
  v11[0] = *(_OWORD *)v6;
  v11[1] = v8;
  float32x2_t v11[2] = v9;
  float v10 = *(float *)(a1 + 88);
  RB::Path::ImmediateRenderer::ImmediateRenderer((RB::Path::ImmediateRenderer *)v12, a3, (const RB::AffineTransform *)v11, (const RB::Coverage::Path *)(a1 + 56));
  RB::Path::Renderer::render_coverage(v16, a5, v10);
  if (v15) {
    RB::Path::Accumulator::commit_buffer((RB::Path::Accumulator *)&v13);
  }
  if (v14) {
    free(v14);
  }
}

void sub_214140A1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
  if (a47) {
    free(a47);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Path>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned __int8 *)(a1 + 44) != *(unsigned __int8 *)(a3 + 44)) {
    return 0;
  }
  can_midouble x = RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a3 + 48), (const RB::AffineTransform *)a3);
  if (!can_mix) {
    return 0;
  }
  unsigned __int8 v6 = can_mix;
  v9[1] = 0;
  uint64_t v9[2] = 0;
  v9[0] = 0xFFFFFFF000000000;
  int v10 = 0;
  uint64_t v11 = 1;
  int v12 = 0;
  unsigned int v7 = RB::Coverage::Path::can_mix((float64x2_t **)(a1 + 56), (const RB::DisplayList::Interpolator::Op *)v9, (float64x2_t **)(a3 + 56));
  if (v7 >= v6) {
    return v6;
  }
  else {
    return v7;
  }
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Path>::mix(uint64_t a1, float *a2, uint64_t a3, float64x2_t *a4)
{
  long long v8 = (size_t *)(*(void *)(*(void *)&a4->f64[0] + 8) + 16);
  RB::mix(*(CGAffineTransform **)(a1 + 48), *(float64x2_t **)(a3 + 48), (const RB::AffineTransform *)a3, a2[4]);
  v17[0] = v9;
  v17[1] = v10;
  v17[2] = v11;
  float v16 = *(float *)(a1 + 88) + (float)((float)(*(float *)(a3 + 88) - *(float *)(a1 + 88)) * a2[4]);
  int v15 = *(char *)(a1 + 44);
  uint64_t v14 = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v17);
  uint64_t v12 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Path>,RB::Heap&,RB::Coverage::Path const&,float,RB::ClipMode const&,RB::AffineTransform const*>(v8, v8, a1 + 56, (int *)&v16, &v15, (uint64_t *)&v14);
  RB::Coverage::Path::mix((RBPath *)(v12 + 56), (const RB::DisplayList::Interpolator::State *)a2, (RBPath *)(a3 + 56), *(float64x2_t **)(a1 + 48), *(float64x2_t **)(a3 + 48), v17, (RB::Heap *)v8);
  RB::DisplayList::GenericClip<RB::Coverage::Path>::update_bounds(v12);
  return v12;
}

void *RB::DisplayList::GenericClip<RB::Coverage::Path>::encode(uint64_t a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Path>(this, 1, (RBPath *)(a1 + 56));
  float32x2_t v4 = *(float64x2_t **)(a1 + 48);
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x12uLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  int v6 = *(int *)(a1 + 88);
  if (*(float *)&v6 != 1.0)
  {
    RB::ProtobufEncoder::encode_varint(this, 0x1DuLL);
    RB::ProtobufEncoder::encode_fixed32(this, v6);
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Clip::encode((void *)a1, this);
}

void RB::DisplayList::GenericClip<RB::Coverage::Path>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "clip");
  RB::DisplayList::Clip::print((RB::DisplayList::Clip *)a1, this);
  float v4 = *(float *)(a1 + 88);
  if (v4 != 1.0) {
    RB::SexpString::printf(this, 0, "(alpha %g)", v4);
  }
  RB::SexpString::print_ctm(this, *(const RB::AffineTransform **)(a1 + 48));
  RB::XML::print_attributes<RB::Coverage::Path>();
}

uint64_t RB::DisplayList::GenericClipCopyVisitor<RB::Coverage::Path>::visit(uint64_t a1, uint64_t a2)
{
  uint64_t result = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>(*(size_t **)(a1 + 8), *(void *)(a1 + 8), a2, (int *)(*(void *)(a1 + 16) + 88), (_DWORD *)(a1 + 24), (uint64_t *)(a1 + 32));
  *(void *)(a1 + 40) = result;
  return result;
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Path>,RB::Heap&,RB::Coverage::Path const&,float,RB::ClipMode const&,RB::AffineTransform const*>(size_t *a1, size_t *a2, uint64_t a3, int *a4, int *a5, uint64_t *a6)
{
  uint64_t v11 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v11 + 96 > a1[3]) {
    uint64_t v11 = RB::Heap::alloc_slow(a1, 0x60uLL, 7);
  }
  else {
    a1[2] = v11 + 96;
  }
  int v12 = *a4;
  int v13 = *a5;
  uint64_t v14 = *a6;
  *(void *)(v11 + 16) = 0;
  *(void *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(void *)(v11 + 32) = 0;
  *(_WORD *)(v11 + 44) = v13;
  *(void *)uint64_t v11 = &unk_26C4E8BE8;
  *(void *)(v11 + 48) = v14;
  *(void *)(v11 + 56) = RBPathRetain(*(void *)a3, *(void *)(a3 + 8));
  *(void *)(v11 + 64) = v15;
  float v16 = *(long long **)(a3 + 16);
  if (v16)
  {
    long long v17 = (_OWORD *)((a2[2] + 15) & 0xFFFFFFFFFFFFFFF0);
    if ((unint64_t)(v17 + 3) > a2[3]) {
      long long v17 = (_OWORD *)RB::Heap::alloc_slow(a2, 0x30uLL, 15);
    }
    else {
      a2[2] = (size_t)(v17 + 3);
    }
    long long v18 = *v16;
    long long v19 = v16[2];
    v17[1] = v16[1];
    v17[2] = v19;
    *long long v17 = v18;
  }
  else
  {
    long long v17 = 0;
  }
  *(void *)(v11 + 72) = v17;
  *(_DWORD *)(v11 + 80) = *(_DWORD *)(a3 + 24);
  *(_WORD *)(v11 + 84) = *(_WORD *)(a3 + 28);
  *(_DWORD *)(v11 + 88) = v12;
  RB::DisplayList::GenericClip<RB::Coverage::Path>::update_bounds(v11);
  return v11;
}

void sub_214140F14(_Unwind_Exception *a1)
{
  RBPathRelease(*(void *)(v1 + 56), *(void *)(v1 + 64));
  _Unwind_Resume(a1);
}

void *RB::Encoder::typed_message_field<RB::Coverage::Path>(RB::Encoder *a1, uint64_t a2, RBPath *a3)
{
  RB::ProtobufEncoder::encode_varint(a1, (8 * a2) | 2);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::ProtobufEncoder::encode_varint(a1, 0x12uLL);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::Coverage::Path::encode(a3, a1);
  RB::ProtobufEncoder::end_length_delimited(a1);
  return RB::ProtobufEncoder::end_length_delimited(a1);
}

void RB::XML::print_attributes<RB::Coverage::Path>()
{
}

void sub_21414108C(_Unwind_Exception *exception_object)
{
  int v3 = v1[2] - 1;
  v1[2] = v3;
  if (!v3) {
    (*(void (**)(_DWORD *))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

unint64_t _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage4PathENS_4Fill8GradientEEEJRS5_RKS7_RPKNS_15AffineTransformEDF16_RNS_9BlendModeEEEEPT_DpOT0_(size_t *a1, uint64_t *a2, _OWORD *a3, uint64_t *a4, __int16 *a5, _WORD *a6)
{
  unint64_t v11 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v11 + 152 > a1[3]) {
    unint64_t v11 = RB::Heap::alloc_slow(a1, 0x98uLL, 7);
  }
  else {
    a1[2] = v11 + 152;
  }
  uint64_t v12 = *a4;
  __int16 v13 = *a5;
  char v14 = *a6;
  *(void *)(v11 + 16) = 0;
  *(void *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(void *)(v11 + 32) = 0;
  *(_WORD *)(v11 + 44) = v13;
  *(_WORD *)(v11 + 46) = v14 & 0x3F;
  *(void *)unint64_t v11 = &unk_26C4EA9C8;
  *(void *)(v11 + 48) = v12;
  *(void *)(v11 + 56) = RBPathRetain(*a2, a2[1]);
  *(void *)(v11 + 64) = v15;
  uint64_t v16 = *(uint64_t *)((char *)a2 + 22);
  *(void *)(v11 + 72) = a2[2];
  *(void *)(v11 + 78) = v16;
  long long v17 = a3[2];
  long long v18 = a3[3];
  long long v19 = a3[1];
  *(_OWORD *)(v11 + 88) = *a3;
  *(_OWORD *)(v11 + 136) = v18;
  *(_OWORD *)(v11 + 120) = v17;
  *(_OWORD *)(v11 + 104) = v19;
  *(void *)unint64_t v11 = &unk_26C4E9228;
  return v11;
}

void *RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Gradient>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4EA9C8;
  RBPathRelease(a1[7], a1[8]);
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Gradient>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4EA9C8;
  RBPathRelease(a1[7], a1[8]);
  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::type_id()
{
  return 8396801;
}

void *RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Gradient>::copy(uint64_t a1, uint64_t a2, char a3)
{
  __int16 v4 = 0;
  int64x2_t v5 = (RB::Heap *)(*(void *)(a2 + 8) + 16);
  __int16 v6 = *(_WORD *)(a1 + 46);
  if ((a3 & 2) != 0) {
    goto LABEL_9;
  }
  if ((*(_WORD *)(a1 + 46) & 0x1000) != 0 || *(unsigned char *)(a2 + 272) == 0) {
    goto LABEL_9;
  }
  v10[0] = &unk_26C4E7FD0;
  v10[1] = v5;
  v10[2] = a1;
  float64x2_t v10[3] = a1 + 88;
  v10[4] = *(void *)(a1 + 48);
  uint64_t v11 = 0;
  RB::Coverage::Path::simplify(a1 + 56, (uint64_t)v10);
  uint64_t result = (void *)v11;
  if (!v11)
  {
    __int16 v6 = *(_WORD *)(a1 + 46);
    __int16 v4 = 4096;
LABEL_9:
    LODWORD(v10[0]) = v6 & 0x3F;
    uint64_t result = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage4PathENS_4Fill8GradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, (size_t *)v5, a1 + 56, (uint64_t *)(a1 + 88), (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), v10);
    *((_OWORD *)result + 1) = *(_OWORD *)(a1 + 16);
    result[4] = *(void *)(a1 + 32);
    *((_DWORD *)result + 10) = *(_DWORD *)(a1 + 40);
    __int16 v9 = *((_WORD *)result + 23) | *(_WORD *)(a1 + 46) & 0x5800;
    *((_WORD *)result + 23) = v9;
    goto LABEL_10;
  }
  __int16 v9 = *(_WORD *)(v11 + 46);
  __int16 v4 = 4096;
LABEL_10:
  *((_WORD *)result + 23) = v9 | v4;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  uint64_t result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::atom_position(uint64_t a1)
{
  v4.callbacks = *(RBPathCallbacks **)(a1 + 48);
  v4.mach_timebase_info info = (void *)(a1 + 56);
  double v1 = RB::Coverage::Path::bounds(v4);
  return vmla_f32(*(float32x2_t *)&v1, (float32x2_t)0x3F0000003F000000, v2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::make_clip(uint64_t a1, uint64_t a2, unsigned int a3, void *a4, float a5)
{
  float v24 = 0.0;
  unsigned int v25 = a3;
  if (RB::Fill::Gradient::get_alpha((RB::Fill::Gradient *)(a1 + 88), &v24))
  {
    uint64_t v11 = (size_t *)(*(void *)(a2 + 8) + 16);
    _H0 = *(_WORD *)(a1 + 44);
    __asm { FCVT            S0, H0 }
    float v23 = _S0 * (float)(a5 * v24);
    uint64_t v18 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Path>,RB::Heap&,RB::Coverage::Path&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v11, v11, a1 + 56, (int *)&v23, (int *)&v25, (uint64_t *)(a1 + 48));
    uint64_t v19 = a4[5];
    size_t v20 = v19 + 1;
    if (a4[6] < (unint64_t)(v19 + 1))
    {
      RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v20);
      uint64_t v19 = a4[5];
      size_t v20 = v19 + 1;
    }
    uint64_t v21 = (void *)a4[4];
    if (!v21) {
      uint64_t v21 = a4;
    }
    v21[v19] = v18;
    a4[5] = v20;
    return (**(uint64_t (***)(uint64_t))a1)(a1);
  }
  else
  {
    v10.n128_f32[0] = a5;
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, v10);
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::can_append_color_matrix()
{
  return 1;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::append_color_matrix(uint64_t a1, float16x4_t *a2, uint64_t a3, __int16 a4)
{
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 144);
}

double RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::bounds(uint64_t a1)
{
  v2.callbacks = *(RBPathCallbacks **)(a1 + 48);
  v2.mach_timebase_info info = (void *)(a1 + 56);
  return RB::Coverage::Path::bounds(v2);
}

float RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::min_scale(uint64_t a1)
{
  float result = RB::Coverage::Path::min_scale((RB::Coverage::Path *)(a1 + 56), *(const RB::AffineTransform **)(a1 + 48));
  if (result < 0.0) {
    return 0.0;
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::has_no_effect(uint64_t a1)
{
  __asm { FCMP            H0, #0 }
  if (_ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  else {
    return 0;
  }
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::render(uint64_t a1, int a2, RB::RenderPass *a3, double a4, char a5, int a6)
{
  v24[5] = *(int32x2_t **)MEMORY[0x263EF8340];
  uint64_t v9 = *(void *)(a1 + 48);
  v10.i64[0] = SLODWORD(a4);
  v10.i64[1] = SHIDWORD(a4);
  long long v11 = *(_OWORD *)(v9 + 16);
  float64x2_t v12 = vaddq_f64(*(float64x2_t *)(v9 + 32), vcvtq_f64_s64(v10));
  v19[0] = *(_OWORD *)v9;
  v19[1] = v11;
  v19[2] = v12;
  _H8 = *(_WORD *)(a1 + 44);
  RB::Path::ImmediateRenderer::ImmediateRenderer((RB::Path::ImmediateRenderer *)v20, a3, (const RB::AffineTransform *)v19, (const RB::Coverage::Path *)(a1 + 56));
  __asm { FCVT            S0, H8 }
  RB::Path::Renderer::render(v24, a1 + 88, (uint64_t)v19, a5, a6, _S0);
  if (v23) {
    RB::Path::Accumulator::commit_buffer((RB::Path::Accumulator *)&v21);
  }
  if (v22) {
    free(v22);
  }
}

void sub_2141416CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
  if (a47) {
    free(a47);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 88), a2);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Interpolator::Op *a3, float64x2_t **a4)
{
  float result = (unint64_t *)(*(uint64_t (**)(float64x2_t **))&(*a4)[1].f64[0])(a4);
  if (result == 8396801)
  {
    float result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      float result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), a4[6], v10);
      int v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        float result = (unint64_t *)RB::Coverage::Path::can_mix((float64x2_t **)(a1 + 56), a3, a4 + 7);
        if ((_BYTE)result)
        {
          unsigned __int8 v13 = result;
          can_midouble x = RB::Fill::Gradient::can_mix((uint64_t *)(a1 + 88), (uint64_t)(a4 + 11), v12);
          return RB::DisplayList::Interpolator::Op::set_type((unint64_t *)a3, v11, v13, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8 = (*(uint64_t (**)(CGAffineTransform **, void, void, void, uint64_t))&(*a1)[1].a)(a1, *(void *)&a4->f64[0], *(unsigned int *)(*(void *)(a2 + 8) + 12), **(void **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v26[0] = v10;
  v26[1] = v11;
  v26[2] = v12;
  *(void *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v26);
  unsigned __int8 v13 = (RB::Heap *)(*(void *)(*(void *)&a4->f64[0] + 8) + 16);
  LODWORD(v14) = *(_DWORD *)(a2 + 16);
  RB::Fill::Gradient::mix((RB::Fill::Gradient *)(v8 + 88), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::Gradient *)(a3 + 88), v14, v13);
  v15.f64[0] = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  float64x2_t v23 = v15;
  long long v24 = v16;
  long long v25 = v17;
  v18.f64[0] = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  v22[0] = v18;
  v22[1] = v19;
  void v22[2] = v20;
  RB::Coverage::Path::mix((RBPath *)(v8 + 56), (const RB::DisplayList::Interpolator::State *)a2, (RBPath *)(a3 + 56), &v23, v22, *(float64x2_t **)(v8 + 48), v13);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(unsigned char *)(*(void *)&a4->f64[0] + 272))
  {
    *(void *)&v23.f64[0] = &unk_26C4E7FD0;
    *(void *)&v23.f64[1] = v13;
    *(void *)&long long v24 = v8;
    *((void *)&v24 + 1) = v8 + 88;
    long long v25 = *(unint64_t *)(v8 + 48);
    RB::Coverage::Path::simplify(v8 + 56, (uint64_t)&v23);
    if (*((void *)&v25 + 1))
    {
      *(void *)uint64_t v8 = &unk_26C4EA9C8;
      RBPathRelease(*(void *)(v8 + 56), *(void *)(v8 + 64));
      uint64_t v8 = *((void *)&v25 + 1);
    }
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

void *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::encode(uint64_t a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Path>(this, 1, (RBPath *)(a1 + 56));
  RB::Encoder::typed_message_field<RB::Fill::Gradient>(this, 2, (RB::Fill::Gradient *)(a1 + 88));
  RBPath v4 = *(float64x2_t **)(a1 + 48);
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::print(const RB::AffineTransform **a1, std::string *this)
{
}

void *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage4PathENS_4Fill8GradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, size_t *a2, uint64_t a3, uint64_t *a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14 = *((void *)this + 3);
  uint64_t v15 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 152 > v14) {
    uint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0x98uLL, 7);
  }
  else {
    *((void *)this + 2) = v15 + 152;
  }
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  float result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  *float result = &unk_26C4E9228;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::GenericItem1(uint64_t a1, size_t *a2, uint64_t a3, uint64_t *a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  __asm { FCVT            H0, S0 }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F;
  *(void *)a1 = &unk_26C4EA9C8;
  *(void *)(a1 + 48) = a5;
  *(void *)(a1 + 56) = RBPathRetain(*(void *)a3, *(void *)(a3 + 8));
  *(void *)(a1 + 64) = v18;
  float64x2_t v19 = *(long long **)(a3 + 16);
  if (v19)
  {
    float64x2_t v20 = (_OWORD *)((a2[2] + 15) & 0xFFFFFFFFFFFFFFF0);
    if ((unint64_t)(v20 + 3) > a2[3]) {
      float64x2_t v20 = (_OWORD *)RB::Heap::alloc_slow(a2, 0x30uLL, 15);
    }
    else {
      a2[2] = (size_t)(v20 + 3);
    }
    long long v21 = *v19;
    long long v22 = v19[2];
    v20[1] = v19[1];
    void v20[2] = v22;
    *float64x2_t v20 = v21;
  }
  else
  {
    float64x2_t v20 = 0;
  }
  *(void *)(a1 + 72) = v20;
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a3 + 24);
  *(_WORD *)(a1 + 84) = *(_WORD *)(a3 + 28);
  RB::Fill::Gradient::Gradient((uint64_t *)(a1 + 88), a4, a7, (RB::Heap *)a2);
  return a1;
}

void sub_214141D08(_Unwind_Exception *a1)
{
  RBPathRelease(*(void *)(v1 + 56), *(void *)(v1 + 64));
  _Unwind_Resume(a1);
}

void *RB::vector<RB::Coverage::anonymous namespace'::PositionedGlyph,128ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 258) + (*((void *)__dst + 258) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 258) + (*((void *)__dst + 258) >> 1);
  }
  float result = RB::details::realloc_vector<unsigned long,16ul>(*((void **)__dst + 256), __dst, 0x80uLL, (size_t *)__dst + 258, v3);
  *((void *)__dst + 256) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,16ul>(void *__src, void *__dst, size_t a3, size_t *a4, size_t a5)
{
  unsigned int v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      size_t v9 = a3;
      memcpy(__dst, __src, 16 * a5);
      free(v7);
      long long v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(16 * a5);
    size_t v9 = v8 >> 4;
    if (v8 >> 4 != *a4)
    {
      long long v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10) {
        RB::precondition_failure((RB *)"allocation failure", v11);
      }
      long long v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, 16 * *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_214141E9C(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Font *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Font>,std::allocator<RB::XML::Value::Font>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Font *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Font>,std::allocator<RB::XML::Value::Font>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::GlyphArray,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_214141F8C(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::GlyphArray *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::GlyphArray>,std::allocator<RB::XML::Value::GlyphArray>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::GlyphArray *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::GlyphArray>,std::allocator<RB::XML::Value::GlyphArray>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

RB::XML::Value::GlyphArray *RB::XML::Value::GlyphArray::GlyphArray(RB::XML::Value::GlyphArray *this, const RB::XML::Value::GlyphArray *a2)
{
  uint64_t v4 = 0;
  *(void *)this = &unk_26C4ED6E0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  uint64_t v5 = *((void *)a2 + 2);
  if (v5)
  {
    long long v10 = (uint64_t *)*((void *)a2 + 1);
    RB::vector<unsigned long,0ul,unsigned long>::reserve_slow((uint64_t)this + 8, *((void *)a2 + 2));
    long long v11 = (void *)(*((void *)this + 1) + 8 * *((void *)this + 2));
    uint64_t v12 = v5;
    do
    {
      uint64_t v13 = *v10++;
      *v11++ = v13;
      --v12;
    }
    while (v12);
    uint64_t v4 = *((void *)this + 2);
  }
  *((void *)this + 2) = v4 + v5;
  *(void *)this = &unk_26C4ED2A8;
  CFTypeRef v6 = (CFTypeRef)*((void *)a2 + 4);
  if (v6) {
    CFTypeRef v6 = CFRetain(v6);
  }
  uint64_t v7 = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 4) = v6;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  unint64_t v8 = *((void *)a2 + 6);
  if (v8)
  {
    unint64_t v14 = (__int16 *)*((void *)a2 + 5);
    RB::vector<unsigned short,0ul,unsigned long>::reserve_slow((uint64_t)this + 40, v8);
    uint64_t v7 = *((void *)this + 6);
    uint64_t v15 = (_WORD *)(*((void *)this + 5) + 2 * v7);
    unint64_t v16 = v8;
    do
    {
      __int16 v17 = *v14++;
      *v15++ = v17;
      --v16;
    }
    while (v16);
  }
  *((void *)this + 6) = v7 + v8;
  return this;
}

void sub_21414213C(_Unwind_Exception *exception_object)
{
  if (*v3) {
    free(*v3);
  }
  uint64_t v5 = (const void *)v1[4];
  if (v5) {
    CFRelease(v5);
  }
  *uint64_t v1 = v2;
  CFTypeRef v6 = (void *)v1[1];
  if (v6) {
    free(v6);
  }
  _Unwind_Resume(exception_object);
}

void *RB::XML::Value::FloatArray::FloatArray<float>(void *a1, float *a2, unint64_t a3)
{
  *a1 = &unk_26C4ED280;
  a1[1] = 0;
  uint64_t v4 = (uint64_t)(a1 + 1);
  a1[2] = 0;
  a1[3] = 0;
  if (a3)
  {
    unint64_t v6 = a3;
    RB::vector<unsigned long,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 1), a3);
    unint64_t v8 = a1[2];
    do
    {
      unint64_t v9 = v8 + 1;
      if (a1[3] < v8 + 1)
      {
        RB::vector<unsigned long,0ul,unsigned long>::reserve_slow(v4, v9);
        unint64_t v8 = a1[2];
        unint64_t v9 = v8 + 1;
      }
      float v10 = *a2++;
      *(double *)(a1[1] + 8 * v8) = v10;
      a1[2] = v9;
      unint64_t v8 = v9;
      --v6;
    }
    while (v6);
  }
  return a1;
}

void sub_214142240(_Unwind_Exception *exception_object)
{
  if (*v1) {
    free(*v1);
  }
  _Unwind_Resume(exception_object);
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::FloatArray,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_2141422C4(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::FloatArray *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::FloatArray>,std::allocator<RB::XML::Value::FloatArray>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::FloatArray *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::FloatArray>,std::allocator<RB::XML::Value::FloatArray>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Int,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_2141423B4(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Int *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Int>,std::allocator<RB::XML::Value::Int>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Int *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Int>,std::allocator<RB::XML::Value::Int>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Vec2,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_2141424A4(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Vec2 *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Vec2>,std::allocator<RB::XML::Value::Vec2>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Vec2 *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Vec2>,std::allocator<RB::XML::Value::Vec2>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Bool,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_214142594(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Bool *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Bool>,std::allocator<RB::XML::Value::Bool>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Bool *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Bool>,std::allocator<RB::XML::Value::Bool>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t RB::Rect::contains(float32x2_t *a1, float32x2_t a2, double a3, double a4, double a5, int32x4_t a6)
{
  float32x2_t v6 = a1[1];
  *(int32x2_t *)a6.i8 = vcltz_f32(v6);
  float32x2_t v7 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(a6), (int8x8_t)vadd_f32(*a1, v6), (int8x8_t)*a1);
  uint32x2_t v8 = (uint32x2_t)vand_s8((int8x8_t)vcgt_f32(vadd_f32(v7, (float32x2_t)(*(void *)&v6 & 0x7FFFFFFF7FFFFFFFLL)), a2), (int8x8_t)vcge_f32(a2, v7));
  return vpmin_u32(v8, v8).u32[0] >> 31;
}

float32x2_t RB::anonymous namespace'::TransformedRect::TransformedRect(uint64_t a1, float64x2_t *a2, float32x2_t a3, int8x8_t a4)
{
  for (unint64_t i = 0; i != 4; ++i)
    *(float32x2_t *)(a1 + 8 * i) = vadd_f32((float32x2_t)vand_s8(a4, (int8x8_t)vcltz_s32(vshl_n_s32((int32x2_t)__PAIR64__(i > 1, (i - 1) < 2), 0x1FuLL))), a3);
  for (uint64_t j = 0; j != 32; j += 8)
  {
    float64x2_t v6 = vcvtq_f64_f32(*(float32x2_t *)(a1 + j));
    float64x2_t v7 = a2[1];
    *(float32x2_t *)(a1 + j) = vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(a2[2], *a2, v6.f64[0]), v7, v6, 1));
  }
  uint64_t v8 = 0;
  uint64_t v9 = 3;
  do
  {
    *(float32x2_t *)(a1 + 8 * v9 + 32) = vsub_f32(*(float32x2_t *)(a1 + 8 * v8), *(float32x2_t *)(a1 + 8 * v9));
    uint64_t v9 = v8++;
  }
  while (v8 != 4);
  v7.f64[0] = -a2->f64[1];
  *(double *)&float32x2_t result = vaddvq_f64(vmulq_f64((float64x2_t)vzip1q_s64((int64x2_t)v7, *(int64x2_t *)a2), a2[1]))
                     * vmul_lane_f32((float32x2_t)a4, (float32x2_t)a4, 1).f32[0];
  if (*(double *)&result < 0.0)
  {
    uint64_t v11 = 0;
    uint64_t v12 = a1 + 32;
    do
    {
      float32x2_t result = vneg_f32(*(float32x2_t *)(v12 + v11));
      *(double *)(v12 + v11) = *(double *)&result;
      v11 += 8;
    }
    while (v11 != 32);
  }
  return result;
}

float32x2_t RB::Rect::translate(float32x2_t *this, float32x2_t result, float32_t a3)
{
  float32x2_t v3 = this[1];
  uint32x2_t v4 = (uint32x2_t)vclez_f32(v3);
  if ((vpmax_u32(v4, v4).u32[0] & 0x80000000) == 0)
  {
    uint32x2_t v5 = (uint32x2_t)vceq_f32(v3, (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
    if ((vpmax_u32(v5, v5).u32[0] & 0x80000000) == 0)
    {
      result.f32[1] = a3;
      float32x2_t result = vadd_f32(*this, result);
      *this = result;
    }
  }
  return result;
}

float32x2_t RB::Rect::round_outwards_by_scale(float32x2_t *this, float a2, int32x4_t a3)
{
  float32x2_t v4 = vmul_n_f32(*this, a2);
  *(float32x2_t *)a3.i8 = vmul_n_f32(this[1], a2);
  *this = v4;
  this[1] = *(float32x2_t *)a3.i8;
  *(float32x2_t *)a3.i8 = vrndp_f32(vadd_f32(*(float32x2_t *)a3.i8, v4));
  double v5 = RB::Rect::from_bounds(vrndm_f32(v4), a3);
  float32x2_t v6 = vrecpe_f32((float32x2_t)LODWORD(a2));
  float32x2_t v7 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(a2), v6), v6);
  LODWORD(v8) = vmul_f32(v7, vrecps_f32((float32x2_t)LODWORD(a2), v7)).u32[0];
  float32x2_t result = vmul_n_f32(*(float32x2_t *)&v5, v8);
  *this = result;
  this[1] = vmul_n_f32(v10, v8);
  return result;
}

int32x2_t RB::AffineTransform::scale2(float64x2_t *this)
{
  float64x2_t v1 = *this;
  float64x2_t v2 = this[1];
  double v3 = this[1].f64[1];
  double v4 = this->f64[1];
  if (this->f64[0] == v3 && v4 == 0.0 && v2.f64[0] == 0.0
    || v3 == 0.0 && (v1.f64[0] == 0.0 ? (_ZF = v4 == v2.f64[0]) : (_ZF = 0), _ZF))
  {
    double v6 = fabs(v1.f64[0]);
    double v7 = fabs(v4);
    if (v4 != 0.0) {
      double v6 = v7;
    }
    *(float *)&double v6 = v6;
    return vdup_lane_s32(*(int32x2_t *)&v6, 0);
  }
  else
  {
    int64x2_t v9 = (int64x2_t)vmulq_f64(v1, v1);
    int64x2_t v10 = (int64x2_t)vmulq_f64(v2, v2);
    float32x2_t v11 = vcvt_f32_f64(vaddq_f64((float64x2_t)vzip1q_s64(v9, v10), (float64x2_t)vzip2q_s64(v9, v10)));
    BOOL v12 = v11.f32[1] == 1.0 && v11.f32[0] == 1.0;
    int8x8_t v13 = (int8x8_t)vsqrt_f32(v11);
    if (v12) {
      unsigned int v14 = -1;
    }
    else {
      unsigned int v14 = 0;
    }
    __asm { FMOV            V2.2S, #1.0 }
    return (int32x2_t)vbsl_s8((int8x8_t)vdup_n_s32(v14), _D2, v13);
  }
}

BOOL RB::AffineTransform::is_uniform(float64x2_t *this)
{
  int64x2_t v1 = (int64x2_t)vmulq_f64(*this, *this);
  int64x2_t v2 = (int64x2_t)vmulq_f64(this[1], this[1]);
  *(float32x2_t *)v1.i8 = vcvt_f32_f64(vaddq_f64((float64x2_t)vzip1q_s64(v1, v2), (float64x2_t)vzip2q_s64(v1, v2)));
  return fabsf(vsub_f32(*(float32x2_t *)v1.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v1.i8, 1)).f32[0]) < 0.001;
}

uint64_t RB::can_mix(RB *this, const RB::AffineTransform *a2, const RB::AffineTransform *a3)
{
  int64x2_t v3 = *(int64x2_t *)this;
  float64x2_t v4 = *((float64x2_t *)this + 1);
  int64x2_t v6 = *(int64x2_t *)a2;
  float64x2_t v5 = *((float64x2_t *)a2 + 1);
  int64x2_t v7 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4, v5), (int8x16_t)vceqq_f64(*(float64x2_t *)this, *(float64x2_t *)a2)), (int8x16_t)vceqq_f64(*((float64x2_t *)this + 2), *((float64x2_t *)a2 + 2)));
  int64x2_t v8 = (int64x2_t)vandq_s8((int8x16_t)vdupq_laneq_s64(v7, 1), (int8x16_t)v7);
  if (v8.i64[0] < 0) {
    return 4;
  }
  *(double *)v8.i64 = -*(double *)&v3.i64[1];
  double v9 = vaddvq_f64(vmulq_f64((float64x2_t)vzip1q_s64(v8, v3), v4));
  v4.f64[0] = -*(double *)&v6.i64[1];
  double v10 = vaddvq_f64(vmulq_f64((float64x2_t)vzip1q_s64((int64x2_t)v4, v6), v5));
  if (v9 > 0.0 && v10 > 0.0) {
    return 1;
  }
  if (v10 < 0.0) {
    return v9 < 0.0;
  }
  return 0;
}

CGAffineTransform *RB::mix(CGAffineTransform *this, float64x2_t *a2, const RB::AffineTransform *a3, float a4)
{
  float64x2_t v6 = *(float64x2_t *)&this->a;
  float64x2_t v7 = *(float64x2_t *)&this->c;
  float64x2_t v9 = *a2;
  float64x2_t v8 = a2[1];
  int64x2_t v10 = (int64x2_t)vandq_s8((int8x16_t)vceqq_f64(v7, v8), (int8x16_t)vceqq_f64(*(float64x2_t *)&this->a, *a2));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v10, 1), (int8x16_t)v10).u64[0] & 0x8000000000000000) == 0)
  {
    CGFloat v11 = a2->f64[1];
    if (v6.f64[1] != 0.0 || v7.f64[0] != 0.0 || v9.f64[1] != 0.0 || v8.f64[0] != 0.0)
    {
      CGFloat v12 = a2[1].f64[1];
      if (v6.f64[0] != 0.0 || v7.f64[1] != 0.0 || v9.f64[0] != 0.0 || v8.f64[1] != 0.0)
      {
        float64x2_t v17 = *a2;
        float64x2_t v18 = a2[1];
        *(_OWORD *)&transform.a = *(_OWORD *)&this->a;
        *(float64x2_t *)&transform.c = v7;
        *(_OWORD *)&transform.tdouble x = *(_OWORD *)&this->tx;
        memset(&v24, 0, sizeof(v24));
        CGAffineTransformDecompose(&v24, &transform);
        v21.a = v17.f64[0];
        v21.b = v11;
        v21.c = v18.f64[0];
        v21.d = v12;
        *(float64x2_t *)&v21.tdouble x = a2[2];
        memset(&v22, 0, sizeof(v22));
        CGAffineTransformDecompose(&v22, &v21);
        double width = v24.scale.width;
        double height = v24.scale.height;
        if ((v24.scale.width >= 0.0 || v22.scale.height >= 0.0) && (v24.scale.height >= 0.0 || v22.scale.width >= 0.0))
        {
          rotatiounint64_t n = v24.rotation;
        }
        else
        {
          double width = -v24.scale.width;
          double height = -v24.scale.height;
          v24.scale.double width = -v24.scale.width;
          v24.scale.double height = -v24.scale.height;
          rotatiounint64_t n = dbl_214218250[v24.rotation < 0.0] + v24.rotation;
          v24.rotatiounint64_t n = rotation;
        }
        if (rotation == 0.0)
        {
          v24.rotatiounint64_t n = 6.28318531;
          rotatiounint64_t n = 6.28318531;
        }
        double v16 = v22.rotation;
        if (v22.rotation == 0.0)
        {
          v22.rotatiounint64_t n = 6.28318531;
          double v16 = 6.28318531;
        }
        if (vabdd_f64(rotation, v16) > 3.14159265)
        {
          if (rotation <= v16)
          {
            double v16 = v16 + -6.28318531;
            v22.rotatiounint64_t n = v16;
          }
          else
          {
            rotatiounint64_t n = rotation + -6.28318531;
            v24.rotatiounint64_t n = rotation;
          }
        }
        components.scale.double width = width + (v22.scale.width - width) * a4;
        components.scale.double height = height + (v22.scale.height - height) * a4;
        components.horizontalShear = v24.horizontalShear + (v22.horizontalShear - v24.horizontalShear) * a4;
        components.rotatiounint64_t n = rotation + (v16 - rotation) * a4;
        components.translatiounint64_t n = (CGVector)vmlaq_n_f64((float64x2_t)v24.translation, vsubq_f64((float64x2_t)v22.translation, (float64x2_t)v24.translation), a4);
        return CGAffineTransformMakeWithComponents(&v20, &components);
      }
    }
  }
  return this;
}

uint64_t RB::can_mix(float64x2_t *this, float64x2_t *a2, const RB::AffineTransform *a3)
{
  if (this == a2) {
    return 4;
  }
  float64x2_t v3 = (float64x2_t)xmmword_2142181C0;
  float64x2_t v4 = (float64x2_t)xmmword_2142181D0;
  float64x2_t v5 = 0uLL;
  float64x2_t v6 = 0uLL;
  float64x2_t v7 = (float64x2_t)xmmword_2142181D0;
  float64x2_t v8 = (float64x2_t)xmmword_2142181C0;
  if (this)
  {
    float64x2_t v8 = *this;
    float64x2_t v7 = this[1];
    float64x2_t v6 = this[2];
  }
  if (a2)
  {
    float64x2_t v3 = *a2;
    float64x2_t v4 = a2[1];
    float64x2_t v5 = a2[2];
  }
  int64x2_t v9 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v7, v4), (int8x16_t)vceqq_f64(v6, v5)), (int8x16_t)vceqq_f64(v8, v3));
  int64x2_t v10 = (int64x2_t)vandq_s8((int8x16_t)vdupq_laneq_s64(v9, 1), (int8x16_t)v9);
  if (v10.i64[0] < 0) {
    return 4;
  }
  *(double *)v10.i64 = -v8.f64[1];
  float64x2_t v11 = (float64x2_t)vzip1q_s64(v10, (int64x2_t)v8);
  double v12 = vaddvq_f64(vmulq_f64(v11, v7));
  v11.f64[0] = -v3.f64[1];
  double v13 = vaddvq_f64(vmulq_f64((float64x2_t)vzip1q_s64((int64x2_t)v11, (int64x2_t)v3), v4));
  if (v12 > 0.0 && v13 > 0.0) {
    return 1;
  }
  if (v13 < 0.0) {
    return v12 < 0.0;
  }
  return 0;
}

CGFloat RB::mix(RB *this, const RB::AffineTransform ***a2, const RB::AffineTransform **a3, const RB::AffineTransform *a4, CGFloat result)
{
  float64x2_t v5 = *a2;
  if (*a2 == a3) {
    return result;
  }
  if (!v5)
  {
    *(_OWORD *)&v18.a = xmmword_2142181C0;
    *(_OWORD *)&v18.c = xmmword_2142181D0;
    *(_OWORD *)&v18.tdouble x = 0uLL;
    if (a3) {
      goto LABEL_4;
    }
LABEL_6:
    long long v15 = xmmword_2142181C0;
    long long v16 = xmmword_2142181D0;
    long long v17 = 0uLL;
    goto LABEL_7;
  }
  long long v8 = *((_OWORD *)v5 + 1);
  *(_OWORD *)&v18.a = *(_OWORD *)v5;
  *(_OWORD *)&v18.c = v8;
  *(_OWORD *)&v18.tdouble x = *((_OWORD *)v5 + 2);
  if (!a3) {
    goto LABEL_6;
  }
LABEL_4:
  long long v9 = *((_OWORD *)a3 + 1);
  long long v15 = *(_OWORD *)a3;
  long long v16 = v9;
  long long v17 = *((_OWORD *)a3 + 2);
LABEL_7:
  RB::mix(&v18, (float64x2_t *)&v15, (const RB::AffineTransform *)a3, *(float *)&result);
  *(_OWORD *)&v18.a = v10;
  *(_OWORD *)&v18.c = v11;
  *(_OWORD *)&v18.tdouble x = v12;
  double v13 = (const RB::AffineTransform **)((*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0);
  if ((unint64_t)(v13 + 6) > *((void *)this + 3)) {
    double v13 = (const RB::AffineTransform **)RB::Heap::alloc_slow((size_t *)this, 0x30uLL, 15);
  }
  else {
    *((void *)this + 2) = v13 + 6;
  }
  long long v14 = *(_OWORD *)&v18.c;
  *(_OWORD *)double v13 = *(_OWORD *)&v18.a;
  *((_OWORD *)v13 + 1) = v14;
  float32x2_t result = v18.tx;
  *((_OWORD *)v13 + 2) = *(_OWORD *)&v18.tx;
  *a2 = v13;
  return result;
}

void *RB::Rect::operator std::string@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  snprintf_l(__s, 0x100uLL, 0, "[%g %g; %g %g]",
    COERCE_FLOAT(*a1),
    COERCE_FLOAT(HIDWORD(*a1)),
    COERCE_FLOAT(a1[1]),
    COERCE_FLOAT(HIDWORD(a1[1])));
  return std::string::basic_string[abi:nn180100]<0>(a2, __s);
}

void *RB::AffineTransform::operator std::string@<X0>(double *a1@<X0>, void *a2@<X8>)
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  snprintf_l(__s, 0x100uLL, 0, "[%g %g; %g %g; %g %g]", *a1, a1[1], a1[2], a1[3], a1[4], a1[5]);
  return std::string::basic_string[abi:nn180100]<0>(a2, __s);
}

double *RB::AffineTransform::encode(double *this, RB::ProtobufEncoder *a2)
{
  float64x2_t v3 = this;
  *(float *)&int v4 = *this;
  if (*(float *)&v4 == 1.0)
  {
    double v5 = this[1];
  }
  else
  {
    RB::ProtobufEncoder::encode_varint(a2, 0xDuLL);
    this = (double *)RB::ProtobufEncoder::encode_fixed32(a2, v4);
    double v5 = v3[1];
  }
  *(float *)&int v6 = v5;
  if (*(float *)&v6 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x15uLL);
    this = (double *)RB::ProtobufEncoder::encode_fixed32(a2, v6);
  }
  *(float *)&int v7 = v3[2];
  if (*(float *)&v7 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x1DuLL);
    this = (double *)RB::ProtobufEncoder::encode_fixed32(a2, v7);
  }
  *(float *)&int v8 = v3[3];
  if (*(float *)&v8 != 1.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x25uLL);
    this = (double *)RB::ProtobufEncoder::encode_fixed32(a2, v8);
  }
  *(float *)&int v9 = v3[4];
  if (*(float *)&v9 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x2DuLL);
    this = (double *)RB::ProtobufEncoder::encode_fixed32(a2, v9);
  }
  *(float *)&int v10 = v3[5];
  if (*(float *)&v10 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x35uLL);
    return (double *)RB::ProtobufEncoder::encode_fixed32(a2, v10);
  }
  return this;
}

unint64_t RB::AffineTransform::decode(RB::AffineTransform *this, RB::ProtobufDecoder *a2)
{
  unint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    unint64_t v5 = result;
    do
    {
      switch((v5 >> 3))
      {
        case 1u:
          *(double *)this = RB::ProtobufDecoder::float_field(a2, v5);
          break;
        case 2u:
          *((double *)this + 1) = RB::ProtobufDecoder::float_field(a2, v5);
          break;
        case 3u:
          *((double *)this + 2) = RB::ProtobufDecoder::float_field(a2, v5);
          break;
        case 4u:
          *((double *)this + 3) = RB::ProtobufDecoder::float_field(a2, v5);
          break;
        case 5u:
          *((double *)this + 4) = RB::ProtobufDecoder::float_field(a2, v5);
          break;
        case 6u:
          *((double *)this + 5) = RB::ProtobufDecoder::float_field(a2, v5);
          break;
        default:
          RB::ProtobufDecoder::skip_field(a2, v5);
          break;
      }
      unint64_t result = RB::ProtobufDecoder::next_field(a2);
      unint64_t v5 = result;
    }
    while (result);
  }
  return result;
}

void *std::string::basic_string[abi:nn180100]<0>(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    int v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v4;
    int v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((unsigned char *)v6 + v5) = 0;
  return a1;
}

std::string *RB::SexpString::newline(std::string *this)
{
  if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
  {
    if (!this->__r_.__value_.__l.__size_) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  if (*((unsigned char *)&this->__r_.__value_.__s + 23)) {
LABEL_3:
  }
    std::string::push_back(this, 10);
LABEL_4:
  this[1].__r_.__value_.__s.__data_[16] = 0;
  this[1].__r_.__value_.__l.__size_ = 0;
  unint64_t result = std::string::append(this, 2 * this[1].__r_.__value_.__r.__words[0], 32);
  this[1].__r_.__value_.__l.__size_ += 2 * this[1].__r_.__value_.__r.__words[0];
  return result;
}

size_t RB::SexpString::push(std::string *this, const char *a2)
{
  RB::SexpString::newline(this);
  std::string::push_back(this, 40);
  size_t v4 = strlen(a2);
  std::string::append(this, a2, v4);
  size_t result = strlen(a2);
  uint64_t v6 = result + this[1].__r_.__value_.__l.__size_ + 1;
  ++this[1].__r_.__value_.__r.__words[0];
  this[1].__r_.__value_.__l.__size_ = v6;
  return result;
}

void RB::SexpString::pop(std::string *this)
{
}

std::string *RB::SexpString::print(std::string *this, char a2, const char *__s)
{
  size_t v6 = strlen(__s);
  size_t v7 = v6;
  if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
  {
    if (!this->__r_.__value_.__l.__size_) {
      goto LABEL_8;
    }
  }
  else if (!*((unsigned char *)&this->__r_.__value_.__s + 23))
  {
    goto LABEL_8;
  }
  if ((a2 & 1) != 0
    || this[1].__r_.__value_.__s.__data_[16]
    || (std::string::size_type size = this[1].__r_.__value_.__l.__size_) != 0 && v6 + size - 79 <= 0xFFFFFFFFFFFFFFAFLL)
  {
    RB::SexpString::newline(this);
  }
  else
  {
    std::string::push_back(this, 32);
    ++this[1].__r_.__value_.__l.__size_;
  }
LABEL_8:
  size_t v8 = strlen(__s);
  size_t result = std::string::append(this, __s, v8);
  this[1].__r_.__value_.__l.__size_ += v7;
  this[1].__r_.__value_.__s.__data_[16] = 0;
  return result;
}

void RB::SexpString::vprintf(std::string *this, char a2, const char *a3, va_list a4)
{
  __s = 0;
  vasprintf(&__s, a3, a4);
  if (__s)
  {
    RB::SexpString::print(this, a2, __s);
    free(__s);
  }
}

void RB::SexpString::printf(std::string *this, char a2, const char *a3, ...)
{
  va_start(va, a3);
  RB::SexpString::vprintf(this, a2, a3, va);
}

void RB::SexpString::print_ctm(std::string *this, const RB::AffineTransform *a2)
{
  if (a2)
  {
    RB::AffineTransform::operator std::string((double *)a2, __p);
    if (v5 >= 0) {
      float64x2_t v3 = __p;
    }
    else {
      float64x2_t v3 = (void **)__p[0];
    }
    RB::SexpString::printf(this, 0, "(CTM %s)", (const char *)v3);
    if (v5 < 0) {
      operator delete(__p[0]);
    }
  }
}

float64x2_t **RB::Path::Iterator::callback_0(float64x2_t **this, double **a2, const CGPathElement *a3)
{
  switch(*(_DWORD *)a2)
  {
    case 0:
      this = (float64x2_t **)(*(uint64_t (**)(float64x2_t *, float64x2_t))(*(void *)&(*this)->f64[0] + 16))(*this, vmlaq_n_f64(vmlaq_n_f64(this[1][2], *this[1], *a2[1]), this[1][1], a2[1][1]));
      break;
    case 1:
      this = (float64x2_t **)(*(uint64_t (**)(float64x2_t *, float64x2_t))(*(void *)&(*this)->f64[0] + 24))(*this, vmlaq_n_f64(vmlaq_n_f64(this[1][2], *this[1], *a2[1]), this[1][1], a2[1][1]));
      break;
    case 2:
      float64x2_t v3 = a2[1];
      size_t v4 = this[1];
      this = (float64x2_t **)(*(uint64_t (**)(float64x2_t *, float64x2_t, float64x2_t))(*(void *)&(*this)->f64[0]
                                                                                                + 32))(*this, vmlaq_n_f64(vmlaq_n_f64(v4[2], *v4, *v3), v4[1], v3[1]), vmlaq_n_f64(vmlaq_n_f64(v4[2], *v4, v3[2]), v4[1], v3[3]));
      break;
    case 3:
      char v5 = a2[1];
      size_t v6 = this[1];
      this = (float64x2_t **)(*(uint64_t (**)(float64x2_t *, float64x2_t, float64x2_t, float64x2_t))(*(void *)&(*this)->f64[0] + 40))(*this, vmlaq_n_f64(vmlaq_n_f64(v6[2], *v6, *v5), v6[1], v5[1]), vmlaq_n_f64(vmlaq_n_f64(v6[2], *v6, v5[2]), v6[1], v5[3]), vmlaq_n_f64(vmlaq_n_f64(v6[2], *v6, v5[4]), v6[1], v5[5]));
      break;
    case 4:
      this = (float64x2_t **)(*(uint64_t (**)(void))(*(void *)&(*this)->f64[0] + 8))();
      break;
    default:
      return this;
  }
  return this;
}

uint64_t RB::Path::Iterator::callback_1(uint64_t this, void *a2, const CGPathElement *a3)
{
  switch(*(_DWORD *)a2)
  {
    case 0:
      this = (*(uint64_t (**)(__n128))(**(void **)this + 16))(*(__n128 *)a2[1]);
      break;
    case 1:
      this = (*(uint64_t (**)(__n128))(**(void **)this + 24))(*(__n128 *)a2[1]);
      break;
    case 2:
      this = (*(uint64_t (**)(__n128, __n128))(**(void **)this + 32))(*(__n128 *)a2[1], *(__n128 *)(a2[1] + 16));
      break;
    case 3:
      this = (*(uint64_t (**)(__n128, __n128, __n128))(**(void **)this + 40))(*(__n128 *)a2[1], *(__n128 *)(a2[1] + 16), *(__n128 *)(a2[1] + 32));
      break;
    case 4:
      this = (*(uint64_t (**)(void))(**(void **)this + 8))();
      break;
    default:
      return this;
  }
  return this;
}

float64_t RB::Path::Orientation::endpath(float64x2_t *this)
{
  float64x2_t v1 = this[1];
  float64x2_t v2 = this[2];
  int8x16_t v3 = (int8x16_t)vceqq_f64(v1, v2);
  int64x2_t v4 = (int64x2_t)vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v3), 1), v3);
  if (v4.i64[0] < 0)
  {
    *(double *)v4.i64 = -v2.f64[1];
    this->f64[1] = vaddvq_f64(vmulq_f64((float64x2_t)vzip1q_s64(v4, (int64x2_t)v2), v1)) + this->f64[1];
    this[2] = v1;
  }
  return v1.f64[0];
}

float64_t RB::Path::Orientation::closepath(float64x2_t *this)
{
  float64x2_t v1 = this[1];
  float64x2_t v2 = this[2];
  int8x16_t v3 = (int8x16_t)vceqq_f64(v1, v2);
  int64x2_t v4 = (int64x2_t)vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v3), 1), v3);
  if (v4.i64[0] < 0)
  {
    *(double *)v4.i64 = -v2.f64[1];
    this->f64[1] = vaddvq_f64(vmulq_f64((float64x2_t)vzip1q_s64(v4, (int64x2_t)v2), v1)) + this->f64[1];
    this[2] = v1;
  }
  return v1.f64[0];
}

float64_t RB::Path::Orientation::lineto(uint64_t a1, float64x2_t a2, double a3, int64x2_t a4)
{
  *(double *)a4.i64 = -*(double *)(a1 + 40);
  float64x2_t v4 = vmulq_f64((float64x2_t)vzip1q_s64(a4, *(int64x2_t *)(a1 + 32)), a2);
  *(double *)(a1 + 8) = v4.f64[1] + *(double *)(a1 + 8) + v4.f64[0];
  *(float64x2_t *)(a1 + 32) = a2;
  return a2.f64[0];
}

float64x2_t *RB::Path::Orientation::moveto(float64x2_t *result, float64x2_t a2)
{
  float64x2_t v2 = result[1];
  float64x2_t v3 = result[2];
  int8x16_t v4 = (int8x16_t)vceqq_f64(v2, v3);
  int64x2_t v5 = (int64x2_t)vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v4), 1), v4);
  if (v5.i64[0] < 0)
  {
    *(double *)v5.i64 = -v3.f64[1];
    result->f64[1] = vaddvq_f64(vmulq_f64((float64x2_t)vzip1q_s64(v5, (int64x2_t)v3), v2)) + result->f64[1];
  }
  result[1] = a2;
  result[2] = a2;
  return result;
}

double RB::Path::Orientation::quadto(uint64_t a1, float64x2_t a2, float64x2_t a3, double a4, int64x2_t a5, double a6, int64x2_t a7)
{
  *(double *)a5.i64 = -*(double *)(a1 + 40);
  float64x2_t v7 = vmulq_f64((float64x2_t)vzip1q_s64(a5, *(int64x2_t *)(a1 + 32)), a2);
  *(double *)a7.i64 = -a2.f64[1];
  double result = vaddvq_f64(vmulq_f64((float64x2_t)vzip1q_s64(a7, (int64x2_t)a2), a3))
         + *(double *)(a1 + 8)
         + v7.f64[1]
         + v7.f64[0];
  *(double *)(a1 + 8) = result;
  *(float64x2_t *)(a1 + 32) = a3;
  return result;
}

float64_t RB::Path::Orientation::cubeto(uint64_t a1, float64x2_t a2, float64x2_t a3, float64x2_t a4, double a5, int64x2_t a6, double a7, int64x2_t a8)
{
  *(double *)a6.i64 = -*(double *)(a1 + 40);
  float64x2_t v8 = vmulq_f64((float64x2_t)vzip1q_s64(a6, *(int64x2_t *)(a1 + 32)), a2);
  *(double *)a8.i64 = -a2.f64[1];
  float64x2_t v9 = vmulq_f64((float64x2_t)vzip1q_s64(a8, (int64x2_t)a2), a3);
  *(double *)a8.i64 = -a3.f64[1];
  float64x2_t v10 = vmulq_f64((float64x2_t)vzip1q_s64(a8, (int64x2_t)a3), a4);
  float64_t result = vaddq_f64(vaddq_f64(v9, (float64x2_t)vdupq_laneq_s64((int64x2_t)v9, 1)), vaddq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v10, 1), v10)).f64[0]+ *(double *)(a1 + 8)+ v8.f64[1]+ v8.f64[0];
  *(float64_t *)(a1 + 8) = result;
  *(float64x2_t *)(a1 + 32) = a4;
  return result;
}

void *RB::Path::Reverser::begin_subpath(void *this)
{
  if (!this[19] && !this[535])
  {
    float64x2_t v1 = this + 22;
    if (this[536])
    {
      uint64_t v2 = 0;
    }
    else
    {
      int8x16_t v4 = this + 22;
      int64x2_t v5 = this;
      _ZN2RB6vectorIDv2_dLm256EmE12reserve_slowEm(this + 22, 1uLL);
      float64x2_t v1 = v4;
      this = v5;
      uint64_t v2 = v5[535];
    }
    if (this[534]) {
      float64x2_t v1 = (void *)this[534];
    }
    float64x2_t v3 = &v1[2 * v2];
    *float64x2_t v3 = 0;
    v3[1] = 0;
    ++this[535];
  }
  return this;
}

uint64_t RB::Path::Reverser::flush_subpath(uint64_t this, char a2)
{
  uint64_t v2 = this;
  if (*(void *)(this + 152))
  {
    uint64_t v4 = this + 176;
    if (*(void *)(this + 4272)) {
      uint64_t v4 = *(void *)(this + 4272);
    }
    uint64_t v5 = v4 + 16 * *(void *)(this + 4280);
    __n128 v7 = *(__n128 *)(v5 - 16);
    uint64_t v6 = v5 - 16;
    this = (*(uint64_t (**)(void, __n128))(**(void **)(this + 8) + 16))(*(void *)(this + 8), v7);
    uint64_t v8 = *(void *)(v2 + 152);
    if (v8)
    {
      float64x2_t v9 = (__n128 *)(v6 - 16);
      uint64_t v10 = v8 - 1;
      do
      {
        uint64_t v11 = *(void *)(v2 + 144);
        if (!v11) {
          uint64_t v11 = v2 + 16;
        }
        uint64_t v12 = *(unsigned __int8 *)(v11 + v10);
        switch(v12)
        {
          case 3:
            this = (*(uint64_t (**)(void, __n128, __n128, __n128))(**(void **)(v2 + 8) + 40))(*(void *)(v2 + 8), *v9, v9[-1], v9[-2]);
            break;
          case 2:
            this = (*(uint64_t (**)(void, __n128, __n128))(**(void **)(v2 + 8) + 32))(*(void *)(v2 + 8), *v9, v9[-1]);
            break;
          case 1:
            this = (*(uint64_t (**)(void, __n128))(**(void **)(v2 + 8) + 24))(*(void *)(v2 + 8), *v9);
            break;
        }
        v9 -= v12;
        --v10;
      }
      while (v10 != -1);
    }
    if (a2) {
      this = (*(uint64_t (**)(void))(**(void **)(v2 + 8) + 8))(*(void *)(v2 + 8));
    }
  }
  *(void *)(v2 + 4280) = 0;
  *(void *)(v2 + 152) = 0;
  return this;
}

uint64_t RB::Path::Reverser::endpath(RB::Path::Reverser *this)
{
  RB::Path::Reverser::flush_subpath((uint64_t)this, 0);
  uint64_t v2 = (uint64_t (*)(void))***((void ***)this + 1);
  return v2();
}

uint64_t RB::Path::Reverser::closepath(RB::Path::Reverser *this)
{
  return RB::Path::Reverser::flush_subpath((uint64_t)this, 1);
}

__n128 RB::Path::Reverser::moveto(void *a1, __n128 a2)
{
  RB::Path::Reverser::flush_subpath((uint64_t)a1, 0);
  uint64_t v3 = a1[535];
  if (a1[536] < (unint64_t)(v3 + 1))
  {
    _ZN2RB6vectorIDv2_dLm256EmE12reserve_slowEm(a1 + 22, v3 + 1);
    uint64_t v3 = a1[535];
  }
  uint64_t v4 = (void *)a1[534];
  if (!v4) {
    uint64_t v4 = a1 + 22;
  }
  __n128 result = a2;
  *(__n128 *)&v4[2 * v3] = a2;
  ++a1[535];
  return result;
}

void *RB::Path::Reverser::lineto(void *a1, __n128 a2)
{
  __n128 result = RB::Path::Reverser::begin_subpath(a1);
  uint64_t v4 = a1[535];
  if (a1[536] < (unint64_t)(v4 + 1))
  {
    __n128 result = _ZN2RB6vectorIDv2_dLm256EmE12reserve_slowEm(a1 + 22, v4 + 1);
    uint64_t v4 = a1[535];
  }
  uint64_t v5 = (void *)a1[534];
  if (!v5) {
    uint64_t v5 = a1 + 22;
  }
  *(__n128 *)&v5[2 * v4] = a2;
  ++a1[535];
  uint64_t v6 = a1[19];
  if (a1[20] < (unint64_t)(v6 + 1))
  {
    __n128 result = RB::vector<unsigned char,128ul,unsigned long>::reserve_slow(a1 + 2, v6 + 1);
    uint64_t v6 = a1[19];
  }
  __n128 v7 = (void *)a1[18];
  if (!v7) {
    __n128 v7 = a1 + 2;
  }
  *((unsigned char *)v7 + v6) = 1;
  ++a1[19];
  return result;
}

void *RB::Path::Reverser::quadto(void *a1, __n128 a2, __n128 a3)
{
  __n128 result = RB::Path::Reverser::begin_subpath(a1);
  uint64_t v5 = a1[535];
  if (a1[536] < (unint64_t)(v5 + 1))
  {
    __n128 result = _ZN2RB6vectorIDv2_dLm256EmE12reserve_slowEm(a1 + 22, v5 + 1);
    uint64_t v5 = a1[535];
  }
  uint64_t v6 = (void *)a1[534];
  if (!v6) {
    uint64_t v6 = a1 + 22;
  }
  *(__n128 *)&v6[2 * v5] = a2;
  uint64_t v7 = a1[535];
  uint64_t v8 = v7 + 1;
  a1[535] = v7 + 1;
  if (a1[536] < (unint64_t)(v7 + 2))
  {
    __n128 result = _ZN2RB6vectorIDv2_dLm256EmE12reserve_slowEm(a1 + 22, v7 + 2);
    uint64_t v8 = a1[535];
  }
  float64x2_t v9 = (void *)a1[534];
  if (!v9) {
    float64x2_t v9 = a1 + 22;
  }
  *(__n128 *)&v9[2 * v8] = a3;
  ++a1[535];
  uint64_t v10 = a1[19];
  if (a1[20] < (unint64_t)(v10 + 1))
  {
    __n128 result = RB::vector<unsigned char,128ul,unsigned long>::reserve_slow(a1 + 2, v10 + 1);
    uint64_t v10 = a1[19];
  }
  uint64_t v11 = (void *)a1[18];
  if (!v11) {
    uint64_t v11 = a1 + 2;
  }
  *((unsigned char *)v11 + v10) = 2;
  ++a1[19];
  return result;
}

void *RB::Path::Reverser::cubeto(void *a1, __n128 a2, __n128 a3, __n128 a4)
{
  __n128 result = RB::Path::Reverser::begin_subpath(a1);
  uint64_t v6 = a1[535];
  if (a1[536] < (unint64_t)(v6 + 1))
  {
    __n128 result = _ZN2RB6vectorIDv2_dLm256EmE12reserve_slowEm(a1 + 22, v6 + 1);
    uint64_t v6 = a1[535];
  }
  uint64_t v7 = (void *)a1[534];
  if (!v7) {
    uint64_t v7 = a1 + 22;
  }
  *(__n128 *)&v7[2 * v6] = a2;
  uint64_t v8 = a1[535];
  uint64_t v9 = v8 + 1;
  a1[535] = v8 + 1;
  if (a1[536] < (unint64_t)(v8 + 2))
  {
    __n128 result = _ZN2RB6vectorIDv2_dLm256EmE12reserve_slowEm(a1 + 22, v8 + 2);
    uint64_t v9 = a1[535];
  }
  uint64_t v10 = (void *)a1[534];
  if (!v10) {
    uint64_t v10 = a1 + 22;
  }
  *(__n128 *)&v10[2 * v9] = a3;
  uint64_t v11 = a1[535];
  uint64_t v12 = v11 + 1;
  a1[535] = v11 + 1;
  if (a1[536] < (unint64_t)(v11 + 2))
  {
    __n128 result = _ZN2RB6vectorIDv2_dLm256EmE12reserve_slowEm(a1 + 22, v11 + 2);
    uint64_t v12 = a1[535];
  }
  double v13 = (void *)a1[534];
  if (!v13) {
    double v13 = a1 + 22;
  }
  *(__n128 *)&v13[2 * v12] = a4;
  ++a1[535];
  uint64_t v14 = a1[19];
  if (a1[20] < (unint64_t)(v14 + 1))
  {
    __n128 result = RB::vector<unsigned char,128ul,unsigned long>::reserve_slow(a1 + 2, v14 + 1);
    uint64_t v14 = a1[19];
  }
  long long v15 = (void *)a1[18];
  if (!v15) {
    long long v15 = a1 + 2;
  }
  *((unsigned char *)v15 + v14) = 3;
  ++a1[19];
  return result;
}

void RB::Path::normalized_map(const CGPath *a1, void (***a2)(void), float64x2_t *a3)
{
  uint64_t v11 = (void (**)(void))&unk_26C4E7060;
  long long v12 = 0u;
  long long v13 = 0u;
  uint64_t v14 = 0;
  mach_timebase_info info = &v11;
  long long v16 = 0;
  CGPathApply(a1, &info, (CGPathApplierFunction)RB::Path::Iterator::callback_1);
  (*v11)(&v11);
  if (a3)
  {
    float64x2_t v8 = *a3;
    float64x2_t v7 = a3[1];
    *(double *)v6.i64 = -a3->f64[1];
    if (vaddvq_f64(vmulq_f64((float64x2_t)vzip1q_s64(v6, *(int64x2_t *)a3), v7)) < 0.0)
    {
      if (*(double *)&v12 >= 0.0) {
        goto LABEL_12;
      }
      goto LABEL_8;
    }
    if (*(double *)&v12 >= 0.0)
    {
LABEL_8:
      mach_timebase_info info = a2;
      long long v16 = a3;
      int64x2_t v10 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v7, (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(v8, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(a3[2]));
      if (vandq_s8((int8x16_t)vdupq_laneq_s64(v10, 1), (int8x16_t)v10).i64[0] >= 0) {
        uint64_t v9 = (void (__cdecl *)(void *, const CGPathElement *))RB::Path::Iterator::callback_0;
      }
      else {
        uint64_t v9 = (void (__cdecl *)(void *, const CGPathElement *))RB::Path::Iterator::callback_1;
      }
      goto LABEL_11;
    }
  }
  else if (*(double *)&v12 >= 0.0)
  {
    mach_timebase_info info = a2;
    long long v16 = 0;
    uint64_t v9 = (void (__cdecl *)(void *, const CGPathElement *))RB::Path::Iterator::callback_1;
LABEL_11:
    CGPathApply(a1, &info, v9);
    (**a2)(a2);
    return;
  }
LABEL_12:
  RB::Path::reverse_map((uint64_t)a1, (uint64_t)a2);
}

void RB::Path::reverse_map(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (const CGPath *)MEMORY[0x270FA5388](a1, a2);
  uint64_t v13 = *MEMORY[0x263EF8340];
  v8[0] = &unk_26C4E7120;
  v8[1] = v4;
  *(_OWORD *)uint64_t v9 = 0u;
  uint64_t v10 = 128;
  *(_OWORD *)uint64_t v11 = 0u;
  uint64_t v12 = 256;
  v7[0] = v8;
  v7[1] = v3;
  uint64_t v5 = (void (__cdecl *)(void *, const CGPathElement *))RB::Path::Iterator::callback_1;
  if (v3)
  {
    int64x2_t v6 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v3[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v3, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v3[2]));
    uint64_t v5 = (void (__cdecl *)(void *, const CGPathElement *))RB::Path::Iterator::callback_1;
    if (vandq_s8((int8x16_t)vdupq_laneq_s64(v6, 1), (int8x16_t)v6).i64[0] >= 0) {
      uint64_t v5 = (void (__cdecl *)(void *, const CGPathElement *))RB::Path::Iterator::callback_0;
    }
  }
  CGPathApply(v2, v7, v5);
  (*(void (**)(void *))v8[0])(v8);
  if (v11[0]) {
    free(v11[0]);
  }
  if (v9[0]) {
    free(v9[0]);
  }
}

void *_ZN2RB6vectorIDv2_dLm256EmE12reserve_slowEm(void *__dst, size_t a2)
{
  if (*((void *)__dst + 514) + (*((void *)__dst + 514) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 514) + (*((void *)__dst + 514) >> 1);
  }
  __n128 result = RB::details::realloc_vector<unsigned long,16ul>(*((void **)__dst + 512), __dst, 0x100uLL, (size_t *)__dst + 514, v3);
  *((void *)__dst + 512) = result;
  return result;
}

void *RB::vector<unsigned char,128ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 18) + (*((void *)__dst + 18) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 18) + (*((void *)__dst + 18) >> 1);
  }
  __n128 result = RB::details::realloc_vector<unsigned long,1ul>(*((void **)__dst + 16), __dst, 0x80uLL, (size_t *)__dst + 18, v3);
  *((void *)__dst + 16) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,1ul>(void *__src, void *__dst, size_t a3, size_t *a4, size_t __n)
{
  float64x2_t v7 = __src;
  if (__n <= a3)
  {
    if (__src)
    {
      size_t v9 = a3;
      memcpy(__dst, __src, __n);
      free(v7);
      uint64_t v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(__n);
    if (v8 != *a4)
    {
      size_t v9 = v8;
      uint64_t v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10) {
        RB::precondition_failure((RB *)"allocation failure", v11);
      }
      uint64_t v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

RB::Symbol::Model *RB::Symbol::Model::Model(RB::Symbol::Model *this, const RB::Symbol::Model *a2)
{
  *((_DWORD *)this + 2) = 1;
  *(void *)this = &unk_26C4EDC98;
  id v4 = *((id *)a2 + 2);
  *((void *)this + 3) = 0;
  *((void *)this + 2) = v4;
  *((void *)this + 4) = 0;
  int v5 = *((_DWORD *)a2 + 8);
  if (v5)
  {
    uint64_t v13 = (long long *)*((void *)a2 + 3);
    RB::vector<RBColor,0ul,unsigned int>::reserve_slow((uint64_t)this + 24, *((_DWORD *)a2 + 8));
    uint64_t v14 = (_OWORD *)(*((void *)this + 3) + 16 * *((unsigned int *)this + 8));
    int v15 = v5;
    do
    {
      long long v16 = *v13++;
      *v14++ = v16;
      --v15;
    }
    while (v15);
    int v6 = *((_DWORD *)this + 8);
  }
  else
  {
    int v6 = 0;
  }
  *((_DWORD *)this + 8) = v6 + v5;
  *((void *)this + 5) = *((void *)a2 + 5);
  *((void *)this + 6) = *((void *)a2 + 6);
  *((void *)this + 7) = *((void *)a2 + 7);
  *((_OWORD *)this + 4) = *((_OWORD *)a2 + 4);
  *((void *)this + 10) = *((void *)a2 + 10);
  unsigned int v7 = *(unsigned __int16 *)((char *)this + 89);
  int v8 = *((unsigned __int8 *)a2 + 88) | (v7 << 8);
  *((_WORD *)this + 44) = v8;
  v7 >>= 8;
  *((unsigned char *)this + 90) = v7;
  int v9 = v8 & 0xFF00FF | (*((unsigned __int8 *)a2 + 89) << 8);
  *((unsigned char *)this + 90) = v7;
  *((_WORD *)this + 44) = v9;
  v9 &= ~0x10000u;
  int v10 = v9 | ((*((unsigned char *)a2 + 90) & 1) << 16);
  *((_WORD *)this + 44) = v9;
  *((unsigned char *)this + 90) = BYTE2(v10);
  unsigned int v11 = v10 & 0xFFFDFFFF | (((*((unsigned __int8 *)a2 + 90) >> 1) & 1) << 17);
  *((_WORD *)this + 44) = v9;
  *((unsigned char *)this + 90) = BYTE2(v11);
  *(_DWORD *)((char *)this + 91) = *(_DWORD *)((char *)a2 + 91);
  *((void *)this + 12) = 0;
  return this;
}

void sub_2141444EC(_Unwind_Exception *a1)
{
  if (*v2) {
    free(*v2);
  }

  _Unwind_Resume(a1);
}

void RB::Symbol::Model::set_flips_rtl(RB::Symbol::Model *this, int a2)
{
  int v2 = *((unsigned __int16 *)this + 44) | (*((unsigned __int8 *)this + 90) << 16);
  if (((((v2 & 0x20000) == 0) ^ a2) & 1) == 0)
  {
    if (a2) {
      char v3 = 2;
    }
    else {
      char v3 = 0;
    }
    unsigned int v4 = v2 & 0xFFFDFFFF;
    *((_WORD *)this + 44) = v4;
    *((unsigned char *)this + 90) = BYTE2(v4) | v3;
    ++*((_DWORD *)this + 21);
    std::unique_ptr<RB::Symbol::Glyph const,RB::Symbol::GlyphCache::Unref>::reset[abi:nn180100]((RB::Symbol::Model *)((char *)this + 96), 0);
  }
}

atomic_uint *RB::Refcount<RB::Symbol::Model,std::atomic<unsigned int>>::release(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

float32x2_t RB::GlyphPathCache::glyph_dilation(float32x2_t *this, float64x2_t *a2, const RB::AffineTransform *a3)
{
  float v4 = RB::AffineTransform::scale(a2);
  float v5 = log2f(v4);
  float32x2_t v6 = vrecpe_f32((float32x2_t)1050989506);
  float32x2_t v7 = vmul_f32(vrecps_f32((float32x2_t)1050989506, v6), v6);
  float v12 = exp2f(floorf(v5 * vmul_f32(v7, vrecps_f32((float32x2_t)1050989506, v7)).f32[0]) * 0.32193);
  float32x2_t v8 = RB::Coverage::Glyphs::resolved_dilation(this, v12);
  float32x2_t v9 = vrecpe_f32((float32x2_t)LODWORD(v12));
  float32x2_t v10 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v12), v9), v9);
  return vmul_n_f32(v8, vmul_f32(v10, vrecps_f32((float32x2_t)LODWORD(v12), v10)).f32[0]);
}

uint64_t *RB::GlyphPathCache::lookup_glyph(uint64_t a1, int a2, int a3, float64x2_t *this, float32x2_t a5, uint64_t a6, int a7)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  uint32x2_t v12 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(a5));
  unsigned __int32 v13 = vpmax_u32(v12, v12).u32[0];
  float v14 = RB::AffineTransform::scale(this);
  if ((v13 & 0x80000000) != 0)
  {
    float v16 = log2f(v14);
    float32x2_t v17 = vrecpe_f32((float32x2_t)1050989506);
    float32x2_t v18 = vmul_f32(vrecps_f32((float32x2_t)1050989506, v17), v17);
    float v15 = exp2f(floorf(v16 * vmul_f32(v18, vrecps_f32((float32x2_t)1050989506, v18)).f32[0]) * 0.32193);
  }
  else
  {
    v27[0] = 0;
    frexpf(v14, v27);
    float v15 = ldexpf(1.0, v27[0]);
  }
  float v19 = v15;
  LODWORD(v28[0]) = CGFontGetIdentifier();
  *((float *)v28 + 1) = v19;
  v28[1] = (uint64_t)a5;
  char v29 = a7;
  __int16 v30 = a3;
  int v20 = a5.i32[0] ^ a3 ^ a5.i32[1] ^ LODWORD(v19) ^ (LODWORD(v28[0]) << 8);
  if (a7) {
    int v20 = -v20 ^ a7;
  }
  unsigned int v21 = 9 * ((v20 + ~(v20 << 15)) ^ ((v20 + ~(v20 << 15)) >> 10));
  unsigned int v31 = ((v21 ^ (v21 >> 6)) + ~((v21 ^ (v21 >> 6)) << 11)) ^ (((v21 ^ (v21 >> 6)) + ~((v21 ^ (v21 >> 6)) << 11)) >> 16);
  CGAffineTransformComponents v22 = RB::UntypedTable::lookup((RB::UntypedTable *)(a1 + 8), v28, 0);
  if (!v22)
  {
    ++*(void *)(a1 + 112);
    operator new();
  }
  ++*(void *)(a1 + 104);
  unsigned int v23 = *(_DWORD *)(*(void *)a6 + 88);
  *((_DWORD *)v22 + 20) = v23;
  if (v23 >= *(_DWORD *)(a1 + 96)) {
    unsigned int v23 = *(_DWORD *)(a1 + 96);
  }
  *(_DWORD *)(a1 + 96) = v23;
  float64x2_t v24 = this[1];
  *this = vmulq_n_f64(*this, *((float *)v22 + 6));
  this[1] = vmulq_n_f64(v24, *((float *)v22 + 6));
  return v22;
}

void sub_214144AE0(_Unwind_Exception *exception_object)
{
  char v3 = *(const void **)(v1 - 152);
  if (v3) {
    CFRelease(v3);
  }
  _Unwind_Resume(exception_object);
}

BOOL RB::GlyphPathCache::prune(RB::GlyphPathCache *this, int a2)
{
  char v3 = this;
  int v10 = 0;
  float v4 = (char *)this + 8;
  unsigned int v5 = 384;
  while (1)
  {
    if (v5 != 384)
    {
      unint64_t v6 = *((void *)v3 + 11);
      if (!(v6 >> 17)) {
        break;
      }
    }
    int v10 = a2 - v5;
    if (*((_DWORD *)v3 + 24) <= a2 - v5)
    {
      *((_DWORD *)v3 + 24) = -1;
      v11[0] = v3;
      v11[1] = &v10;
      this = (RB::GlyphPathCache *)RB::UntypedTable::remove_if ((uint64_t)v4, (BOOL (*)(const void *, const void *, void *))RB::Table<RB::GlyphPathCacheDetails::GlyphKey const*,RB::GlyphPathCache::Path *>::remove_if<RB::GlyphPathCache::prune::$_0>(RB::GlyphPathCache::prune::$_0)::{lambda(void const*,void const*,void *)#1}::__invoke, v11);
    }
    BOOL v7 = v5 > 1;
    v5 >>= 1;
    if (!v7)
    {
      unint64_t v6 = *((void *)v3 + 11);
      break;
    }
  }
  if (v6)
  {
    int v8 = RB::verbose_mode(this);
    unint64_t v6 = *((void *)v3 + 11);
    if (v8 >= 1)
    {
      printf("\n== glyph path cache ==\n  %d bytes; %d paths; %d/%d misses/hits (%g ratio)\n\n",
        v6,
        *((void *)v3 + 8),
        *((void *)v3 + 14),
        *((void *)v3 + 13),
        (double)*((unint64_t *)v3 + 14) / (double)*((unint64_t *)v3 + 13));
      unint64_t v6 = *((void *)v3 + 11);
    }
  }
  return v6 != 0;
}

uint64_t RB::anonymous namespace'::GlyphSegments::begin_subpath(uint64_t this)
{
  *(void *)(this + 16) = *(void *)(*(void *)(this + 8) + 8);
  *(_DWORD *)(this + 28) = *(_DWORD *)(this + 24);
  return this;
}

uint64_t RB::anonymous namespace'::GlyphSegments::cull_subpath(RB::_anonymous_namespace_::GlyphSegments *this)
{
  uint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  if (*(void *)(v2 + 8) < v3 && *(void *)(v2 + 16) < v3) {
    RB::vector<RB::Shader::Path::CubicSegment,0ul,unsigned long>::reserve_slow(*((void *)this + 1), v3);
  }
  *(void *)(v2 + 8) = v3;
  *((_DWORD *)this + 6) = *((_DWORD *)this + 7);
  return 1;
}

BOOL RB::anonymous namespace'::GlyphSegments::pop_back(RB::_anonymous_namespace_::GlyphSegments *this)
{
  uint64_t v1 = *((void *)this + 1);
  uint64_t v2 = *(void *)(v1 + 8);
  if (v2) {
    *(void *)(v1 + 8) = v2 - 1;
  }
  return v2 != 0;
}

float RB::anonymous namespace'::GlyphSegments::push_back(uint64_t a1, unsigned int a2, float32x2_t a3, double a4, double a5, double a6)
{
  uint32x2_t v12 = *(void **)(a1 + 8);
  uint64_t v13 = v12[1];
  if (!v13
    || (uint32x2_t v14 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(*(float32x2_t *)(*v12 + 32 * v13 - 8), a3)),
        (vpmax_u32(v14, v14).u32[0] & 0x80000000) != 0))
  {
    int v15 = *(_DWORD *)(a1 + 24);
    if (v12[2] < (unint64_t)(v13 + 1))
    {
      RB::vector<RB::Shader::Path::CubicSegment,0ul,unsigned long>::reserve_slow(*(void *)(a1 + 8), v13 + 1);
      uint64_t v13 = v12[1];
    }
    uint64_t v16 = *v12 + 32 * v13;
    *(_DWORD *)uint64_t v16 = v15;
    *(_DWORD *)(v16 + 4) = 0;
    int32x2_t v17 = vdup_n_s32(0x7F800000u);
    *(int32x2_t *)(v16 + 8) = v17;
    *(int32x2_t *)(v16 + 16) = v17;
    *(double *)(v16 + 24) = *(double *)&a3;
    ++v12[1];
    uint32x2_t v12 = *(void **)(a1 + 8);
    uint64_t v13 = v12[1];
  }
  int v18 = *(_DWORD *)(a1 + 24);
  if (v12[2] < (unint64_t)(v13 + 1))
  {
    RB::vector<RB::Shader::Path::CubicSegment,0ul,unsigned long>::reserve_slow((uint64_t)v12, v13 + 1);
    uint64_t v13 = v12[1];
  }
  float result = 1.0 / (float)a2;
  uint64_t v20 = *v12 + 32 * v13;
  *(_DWORD *)uint64_t v20 = v18;
  *(float *)(v20 + 4) = result;
  *(double *)(v20 + 8) = a4;
  *(double *)(v20 + 16) = a5;
  *(double *)(v20 + 24) = a6;
  ++v12[1];
  *(_DWORD *)(a1 + 24) += a2;
  return result;
}

void *RB::vector<RB::Shader::Path::CubicSegment,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1) <= a2) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1);
  }
  float result = RB::details::realloc_vector<unsigned long,32ul>(*(void **)a1, (size_t *)(a1 + 16), v3);
  *(void *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,32ul>(void *a1, size_t *a2, uint64_t a3)
{
  float v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(32 * a3);
    size_t v6 = v5 >> 5;
    if (v5 >> 5 != *a2)
    {
      BOOL v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7) {
        RB::precondition_failure((RB *)"allocation failure", v8);
      }
      float v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

BOOL RB::Table<RB::GlyphPathCacheDetails::GlyphKey const*,RB::GlyphPathCache::Path *>::remove_if<RB::GlyphPathCache::prune(unsigned int)::$_0>(RB::GlyphPathCache::prune(unsigned int)::$_0)::{lambda(void const*,void const*,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  unsigned int v3 = *(_DWORD *)(a2 + 80);
  uint64_t v4 = *a3;
  unsigned int v5 = *(_DWORD *)a3[1];
  if (v3 > v5)
  {
    unsigned int v6 = *(_DWORD *)(v4 + 96);
    if (v3 < v6) {
      unsigned int v6 = *(_DWORD *)(a2 + 80);
    }
    *(_DWORD *)(v4 + 96) = v6;
  }
  else
  {
    *(void *)(v4 + 88) -= 32 * *(void *)(a2 + 56);
  }
  return v3 <= v5;
}

void RB::ObjcEncoderDelegate::encode_metadata(id *this@<X0>, CFTypeRef *a2@<X8>)
{
  *a2 = 0;
  if (objc_opt_respondsToSelector())
  {
    uint64_t v4 = (void *)MEMORY[0x21669B110]();
    unsigned int v5 = (const void *)[this[1] encodedMetadata];
    if (v5) {
      *a2 = CFRetain(v5);
    }
  }
}

void sub_214144F68(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::ObjcEncoderDelegate::should_encode_subset_font(RB::ObjcEncoderDelegate *this, CGFont *a2)
{
  if ((objc_opt_respondsToSelector() & 1) == 0) {
    return 0;
  }
  uint64_t v4 = (void *)*((void *)this + 1);
  return [v4 shouldEncodeFontSubset:a2];
}

void RB::ObjcEncoderDelegate::encode_font(id *this@<X0>, CGFont *a2@<X1>, CFTypeRef *a3@<X8>)
{
  *a3 = 0;
  if (objc_opt_respondsToSelector())
  {
    unsigned int v6 = (void *)MEMORY[0x21669B110]();
    uint64_t v8 = 0;
    BOOL v7 = (const void *)[this[1] encodedCGFontData:a2 error:&v8];
    if (v7) {
      *a3 = CFRetain(v7);
    }
  }
}

void sub_21414506C(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void RB::ObjcEncoderDelegate::encode_font_subset(uint64_t a1@<X0>, uint64_t a2@<X1>, const __CFData *a3@<X2>, uint64_t a4@<X4>, CFTypeRef *a5@<X8>)
{
  *a5 = 0;
  if (objc_opt_respondsToSelector())
  {
    int v10 = (void *)MEMORY[0x21669B110]();
    RBEncoderCreateFontData(a3, a4, (CFDataRef *)&cf);
    if (cf)
    {
      uint64_t v14 = 0;
      unsigned int v11 = (const void *)[*(id *)(a1 + 8) encodedFontData:cf cgFont:a2 error:&v14];
      if (v11) {
        *a5 = CFRetain(v11);
      }
      if (cf) {
        CFRelease(cf);
      }
    }
  }
  else if (objc_opt_respondsToSelector())
  {
    uint32x2_t v12 = (void *)MEMORY[0x21669B110]();
    CFTypeRef cf = 0;
    uint64_t v13 = (const void *)[*(id *)(a1 + 8) encodedFontSubsetData:a3 cgFont:a2 error:&cf];
    if (v13) {
      *a5 = CFRetain(v13);
    }
  }
}

void sub_2141451B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void RBEncoderCreateFontData(CFDataRef theData@<X1>, uint64_t a2@<X3>, CFDataRef *a3@<X8>)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  char v29 = 0;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v26 = 0u;
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  if (Length)
  {
    RB::ProtobufEncoder::encode_varint(&v26, 0xAuLL);
    RB::ProtobufEncoder::encode_data((RB::ProtobufEncoder *)&v26, BytePtr, Length);
  }
  uint64_t v8 = (void *)CGFontCopyName();
  if (v8)
  {
    float32x2_t v9 = (void *)MEMORY[0x21669B110]();
    int v10 = (const char *)[v8 UTF8String];
    size_t v11 = strlen(v10);
    if (v11)
    {
      unint64_t v12 = v11;
      RB::ProtobufEncoder::encode_varint(&v26, 0x12uLL);
      RB::ProtobufEncoder::encode_data((RB::ProtobufEncoder *)&v26, v10, v12);
    }
  }
  if (a2)
  {
    uint64_t Count = CGFontIndexSetGetCount();
    uint64_t v15 = Count;
    if (Count)
    {
      if ((Count & 0x8000000000000000) == 0)
      {
        unint64_t v16 = 2 * Count;
        if ((unint64_t)(2 * Count) > 0x1000)
        {
          int32x2_t v17 = (char *)malloc_type_malloc(2 * Count, 0x3A45EF90uLL);
          CGAffineTransformComponents v22 = (unsigned __int16 *)malloc_type_malloc(2 * v15, 0xC4D51AF7uLL);
          uint64_t v20 = v22;
          int v21 = 1;
          if (!v17 || !v22)
          {
LABEL_23:
            free(v20);
LABEL_24:
            if (v21) {
              free(v17);
            }
            goto LABEL_26;
          }
        }
        else
        {
          MEMORY[0x270FA5388](Count, v14);
          int32x2_t v17 = (char *)&v26 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
          bzero(v17, 2 * v15);
          MEMORY[0x270FA5388](v18, v19);
          uint64_t v20 = (unsigned __int16 *)v17;
          bzero(v17, 2 * v15);
          int v21 = 0;
        }
        CGFontIndexSetGetIndexes();
        CGFontIndexMapGetValues();
        uint64_t v23 = 0;
        do
        {
          if (v20[v23] != *(unsigned __int16 *)&v17[2 * v23])
          {
            RB::ProtobufEncoder::encode_varint(&v26, 0x1AuLL);
            RB::ProtobufEncoder::begin_length_delimited(&v26);
            unint64_t v24 = *(unsigned __int16 *)&v17[2 * v23];
            if (*(_WORD *)&v17[2 * v23])
            {
              RB::ProtobufEncoder::encode_varint(&v26, 8uLL);
              RB::ProtobufEncoder::encode_varint(&v26, v24);
            }
            unint64_t v25 = v20[v23];
            if (v20[v23])
            {
              RB::ProtobufEncoder::encode_varint(&v26, 0x10uLL);
              RB::ProtobufEncoder::encode_varint(&v26, v25);
            }
            RB::ProtobufEncoder::end_length_delimited(&v26);
          }
          ++v23;
        }
        while (v15 != v23);
        if (v16 <= 0x1000) {
          goto LABEL_24;
        }
        goto LABEL_23;
      }
    }
  }
LABEL_26:
  RB::ProtobufEncoder::take_data((RB::ProtobufEncoder *)&v26, a3);
  if (v8) {
    CFRelease(v8);
  }
  if (*((void *)&v27 + 1)) {
    free(*((void **)&v27 + 1));
  }
  if ((void)v26) {
    free((void *)v26);
  }
}

void sub_2141454BC(_Unwind_Exception *a1)
{
  free(v2);
  if (v1) {
    CFRelease(v1);
  }
  RB::ProtobufEncoder::~ProtobufEncoder((RB::ProtobufEncoder *)(v3 - 144));
  _Unwind_Resume(a1);
}

void RB::ObjcEncoderDelegate::encode_image(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, CFTypeRef *a4@<X8>)
{
  *a4 = 0;
  if (objc_opt_respondsToSelector())
  {
    uint64_t v8 = (void *)MEMORY[0x21669B110]();
    uint64_t v10 = 0;
    float32x2_t v9 = (const void *)objc_msgSend(*(id *)(a1 + 8), "encodedImageData:error:", a2, a3, &v10);
    if (v9) {
      *a4 = CFRetain(v9);
    }
  }
}

void sub_2141455C8(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void RB::ObjcEncoderDelegate::encode_shader_library(id *this@<X0>, const void *a2@<X1>, CFTypeRef *a3@<X8>)
{
  *a3 = 0;
  if (objc_opt_respondsToSelector())
  {
    unsigned int v6 = (void *)MEMORY[0x21669B110]();
    uint64_t v8 = 0;
    BOOL v7 = (const void *)[this[1] encodedShaderLibraryData:a2 error:&v8];
    if (v7) {
      *a3 = CFRetain(v7);
    }
  }
}

void sub_21414566C(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void RB::ObjcEncoderDelegate::font_set(id *this@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  uint64_t v4 = (void *)MEMORY[0x21669B110]();
  if (objc_opt_respondsToSelector())
  {
    unsigned int v5 = (void *)[this[1] encoderSet];
    unsigned int v6 = v5;
    if (v5)
    {
      [v5 commit];
      uint64_t v7 = v6[1];
      if (v7) {
        atomic_fetch_add_explicit((atomic_uint *volatile)(v7 + 8), 1u, memory_order_relaxed);
      }
      *a2 = v7;
    }
  }
}

void sub_21414570C(_Unwind_Exception *exception_object)
{
  if (v1) {
    RB::ObjcEncoderDelegate::font_set(v1);
  }
  _Unwind_Resume(exception_object);
}

void RB::ObjcDecoderDelegate::decode_metadata(id *this, const void *a2, uint64_t a3)
{
  if (objc_opt_respondsToSelector())
  {
    unsigned int v6 = (void *)MEMORY[0x21669B110]();
    objc_msgSend(this[1], "decodedMetadata:", objc_msgSend(MEMORY[0x263EFF8F8], "dataWithBytes:length:", a2, a3));
  }
}

void RB::ObjcDecoderDelegate::decode_cgfont(id *this@<X0>, const void *a2@<X1>, uint64_t a3@<X2>, CFTypeRef *a4@<X8>)
{
  *a4 = 0;
  if (objc_opt_respondsToSelector())
  {
    uint64_t v8 = (void *)MEMORY[0x21669B110]();
    uint64_t v10 = 0;
    float32x2_t v9 = (const void *)objc_msgSend(this[1], "decodedCGFontWithData:error:", objc_msgSend(MEMORY[0x263EFF8F8], "dataWithBytes:length:", a2, a3), &v10);
    if (v9) {
      *a4 = CFRetain(v9);
    }
  }
}

void sub_214145860(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void RB::ObjcDecoderDelegate::decode_image(id *this@<X0>, const void *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0;
  if (objc_opt_respondsToSelector())
  {
    uint64_t v8 = (void *)MEMORY[0x21669B110]();
    uint64_t v11 = 0;
    int v10 = 0;
    float32x2_t v9 = (const void *)objc_msgSend(this[1], "decodedImageContentsWithData:type:error:", objc_msgSend(MEMORY[0x263EFF8F8], "dataWithBytes:length:", a2, a3), &v10, &v11);
    *(_DWORD *)a4 = v10;
    if (v9) {
      *(void *)(a4 + 8) = CFRetain(v9);
    }
  }
}

void sub_214145938(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void RB::ObjcDecoderDelegate::decode_shader_library(id *this@<X0>, const void *a2@<X1>, uint64_t a3@<X2>, CFTypeRef *a4@<X8>)
{
  *a4 = 0;
  if (objc_opt_respondsToSelector())
  {
    uint64_t v8 = (void *)MEMORY[0x21669B110]();
    uint64_t v10 = 0;
    float32x2_t v9 = (const void *)objc_msgSend(this[1], "decodedShaderLibraryWithData:error:", objc_msgSend(MEMORY[0x263EFF8F8], "dataWithBytes:length:", a2, a3), &v10);
    if (v9) {
      *a4 = CFRetain(v9);
    }
  }
}

void sub_2141459FC(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_214145C24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
}

void RB::Encoder::~Encoder(RB::Encoder *this)
{
  RB::UntypedTable::~UntypedTable((RB::Encoder *)((char *)this + 80));
  uint64_t v2 = (atomic_uint *)*((void *)this + 8);
  if (v2 && atomic_fetch_add_explicit(v2 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 3);
  if (v3) {
    free(v3);
  }
  if (*(void *)this) {
    free(*(void **)this);
  }
}

void sub_214145FEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2141462D8(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_2141463B0(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

void sub_2141464F8(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

void sub_2141466B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void RB::ProtobufEncoder::~ProtobufEncoder(RB::ProtobufEncoder *this)
{
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2) {
    free(v2);
  }
  if (*(void *)this) {
    free(*(void **)this);
  }
}

CGFontRef RBDecoderCreateCGFontWithData(void *a1)
{
  CGMutablePathRef Mutable = 0;
  uint64_t v3 = 0;
  CFIndex v4 = 0;
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  uint64_t v20 = (uint64_t *)[a1 bytes];
  int v21 = (uint64_t *)((char *)v20 + [a1 length]);
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  char v26 = 0;
  while (1)
  {
    unint64_t field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)&v20);
    if (!field) {
      break;
    }
    unint64_t v8 = field >> 3;
    if ((field >> 3) == 3)
    {
      if ((field & 7) == 2)
      {
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)&v20);
        unint64_t v9 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)&v20);
        uint64_t v10 = -1;
        for (i = -1; v9; unint64_t v9 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)&v20))
        {
          if ((v9 >> 3) == 2)
          {
            uint64_t i = RB::ProtobufDecoder::uint_field(&v20, v9);
          }
          else if ((v9 >> 3) == 1)
          {
            uint64_t v10 = RB::ProtobufDecoder::uint_field(&v20, v9);
          }
          else
          {
            RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)&v20, v9);
          }
        }
        RB::ProtobufDecoder::end_message((uint64_t)&v20);
        if ((v10 & 0x8000000000000000) == 0 && (i & 0x8000000000000000) == 0)
        {
          if (!Mutable) {
            CGMutablePathRef Mutable = CFDictionaryCreateMutable(0, 0, 0, 0);
          }
          CFDictionarySetValue(Mutable, (const void *)i, (const void *)v10);
        }
      }
      else
      {
        char v26 = 1;
        uint64_t v20 = v21;
      }
    }
    else if (v8 == 2)
    {
      uint64_t v3 = (const UInt8 *)RB::ProtobufDecoder::data_field((RB::ProtobufDecoder *)&v20, field);
      CFIndex v4 = v12;
    }
    else if (v8 == 1)
    {
      uint64_t v5 = RB::ProtobufDecoder::data_field((RB::ProtobufDecoder *)&v20, field);
      uint64_t v6 = v13;
    }
    else
    {
      RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)&v20, field);
    }
  }
  if (v6)
  {
    uint64_t v14 = (void *)MEMORY[0x21669B110](0);
    uint64_t v15 = CGDataProviderCreateWithCFData((CFDataRef)objc_msgSend(a1, "subdataWithRange:", v5 - objc_msgSend(a1, "bytes", v20), v6));
    CGFontRef v16 = CGFontCreateWithDataProvider(v15);
    if (v15) {
      CFRelease(v15);
    }
    if (v16)
    {
      if (v4)
      {
        CFStringRef v17 = CFStringCreateWithBytes(0, v3, v4, 0x8000100u, 1u);
      }
      else
      {
        if (!Mutable) {
          goto LABEL_36;
        }
        CFStringRef v17 = 0;
      }
      uint64_t v18 = -[RBDecodedFontMetadata initWithFontUID:glyphMap:]([RBDecodedFontMetadata alloc], v17, Mutable);
      objc_setAssociatedObject(v16, "RBDecodedFontMetadata", v18, (void *)0x301);

      if (v17) {
        CFRelease(v17);
      }
    }
  }
  else
  {
    CGFontRef v16 = 0;
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
LABEL_36:
  if (v23) {
    free(v23);
  }
  return v16;
}

void sub_214146B34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  CFRelease(v14);
  if (v13) {
    CFRelease(v13);
  }
  if (a13) {
    free(a13);
  }
  _Unwind_Resume(a1);
}

RBArchiveDelegateImpl *RBArchiveDelegate(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = [[RBArchiveDelegateImpl alloc] initWithFlags:a1];
    return v1;
  }
  else
  {
    {
      RBArchiveDelegate::shared = [[RBArchiveDelegateImpl alloc] initWithFlags:0];
    }
    return (RBArchiveDelegateImpl *)RBArchiveDelegate::shared;
  }
}

void sub_214146C68(_Unwind_Exception *a1)
{
}

void RBArchiveToFile(void *a1, unsigned char *a2, uint64_t a3)
{
  uint64_t v6 = (void *)MEMORY[0x21669B110]();
  uint64_t v7 = RBArchiveDelegate(a3);
  archive_to_file(a1, a2, (uint64_t)v7);
}

void archive_to_file(void *a1, unsigned char *a2, uint64_t a3)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v6 = (NSString *)[NSString stringWithUTF8String:a2];
  if (*a2 != 47) {
    uint64_t v6 = [(NSString *)NSTemporaryDirectory() stringByAppendingPathComponent:v6];
  }
  uint64_t v7 = (void *)[a1 encodedDataForDelegate:a3 error:0];
  if (v7)
  {
    unint64_t v8 = (RB *)[v7 writeToFile:v6 atomically:0];
    if (v8)
    {
      unint64_t v9 = RB::misc_log(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = (objc_class *)objc_opt_class();
        int v11 = 138412802;
        CFIndex v12 = NSStringFromClass(v10);
        __int16 v13 = 2048;
        uint64_t v14 = a1;
        __int16 v15 = 2112;
        CGFontRef v16 = v6;
        _os_log_impl(&dword_2140F5000, v9, OS_LOG_TYPE_DEFAULT, "serialized %@:%p to %@", (uint8_t *)&v11, 0x20u);
      }
    }
  }
}

void RBArchiveToFileWithMetadata(void *a1, uint64_t a2, unsigned char *a3, uint64_t a4)
{
  unint64_t v8 = (void *)MEMORY[0x21669B110]();
  unint64_t v9 = [[RBArchiveDelegateImpl alloc] initWithFlags:a4];
  uint64_t v10 = v9;
  if (a2) {
    [(RBArchiveDelegateImpl *)v9 decodedMetadata:a2];
  }
  archive_to_file(a1, a3, (uint64_t)v10);
}

void sub_214146EA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t RB::ObjcDecoderDelegate::display_list_contents(RB::ObjcDecoderDelegate *this)
{
  return *((void *)this + 2);
}

uint64_t RB::Coverage::StrokeablePath::simplify(uint64_t a1, uint64_t a2, uint64_t (***a3)(void, long long *))
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  if (result)
  {
    float v7 = *(float *)(a1 + 24);
    if (v7 <= 0.0)
    {
      long long v24 = 0u;
      long long v25 = 0u;
      LODWORD(v26) = 1065353216;
      *(void *)((char *)&v26 + 4) = 0;
      BYTE12(v26) = 0;
      *(_WORD *)((char *)&v26 + 13) = 1;
      return (**a3)(a3, &v24);
    }
    else if (!*(void *)(a1 + 32))
    {
      if ((uint64_t v8 = *(void *)(a1 + 16)) == 0
        || (long long v9 = *(_OWORD *)(v8 + 16), v10 = *(double *)(v8 + 24), v11 = *(double *)(v8 + 8), *(double *)v8 == v10)
        && v11 == 0.0
        && *(double *)&v9 == 0.0
        || v10 == 0.0 && (*(double *)v8 == 0.0 ? (BOOL v12 = v11 == *(double *)&v9) : (BOOL v12 = 0), v12))
      {
        v17[0] = 0;
        v17[1] = 0;
        *(double *)&v17[2] = v7;
        int v18 = rb_line_cap(*(unsigned __int8 *)(a2 + 73));
        int v19 = RBStrokeRef::clip(*(unsigned __int8 *)(a2 + 74));
        double v20 = *(float *)(a2 + 80);
        uint64_t v22 = 0;
        uint64_t v23 = 0;
        uint64_t v21 = 0;
        __int16 v13 = *(long long **)(a1 + 16);
        char v14 = *(unsigned char *)(a2 + 76);
        *(void *)&long long v24 = a3;
        if (v13)
        {
          long long v15 = *v13;
          long long v16 = v13[2];
          long long v26 = v13[1];
          long long v27 = v16;
          long long v25 = v15;
        }
        else
        {
          long long v25 = xmmword_2142181C0;
          long long v26 = xmmword_2142181D0;
          long long v27 = 0uLL;
        }
        char v28 = v14;
        char v32 = 0;
        uint64_t v29 = 0;
        uint64_t v30 = v17;
        double v31 = *(float *)(a1 + 24);
      }
    }
  }
  return result;
}

uint64_t RB::Coverage::anonymous namespace'::visit_rect(uint64_t (***a1)(void, uint64_t *), float64x2_t *a2, float64x2_t *a3, char a4, float a5, float a6)
{
  if (CGRectIsInfinite(*(CGRect *)a2->f64))
  {
    uint64_t v17 = 0x100000001000000;
    int32x2_t v18 = vdup_n_s32(0x7F7FFFFFu);
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 1065353216;
    float v22 = 0.0;
    __int16 v23 = 257;
  }
  else
  {
    float64x2_t v15 = a2[1];
    float32x2_t v13 = vcvt_f32_f64(*a2);
    *(float32x2_t *)&v15.f64[0] = vcvt_f32_f64(v15);
    *(int32x2_t *)v12.i8 = vcltz_f32(*(float32x2_t *)&v15.f64[0]);
    float32x2_t v14 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(v12), (int8x8_t)vadd_f32(*(float32x2_t *)&v15.f64[0], v13), (int8x8_t)v13);
    *(void *)&v15.f64[0] &= 0x7FFFFFFF7FFFFFFFuLL;
    if (a3) {
      float32x2_t v14 = RB::operator*(a3, v14, (int32x4_t)v15);
    }
    uint64_t v17 = (uint64_t)v14;
    int32x2_t v18 = *(int32x2_t *)&v15.f64[0];
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    LODWORD(v21) = 1065353216;
    *((float *)&v21 + 1) = a5;
    float v22 = a6;
    LOBYTE(v23) = 2;
    HIBYTE(v23) = a4;
  }
  char v24 = 0;
  return (**a1)(a1, &v17);
}

uint64_t RB::Coverage::anonymous namespace'::visit_ellipse(uint64_t (***a1)(void, uint64_t *), float64x2_t *a2, float64x2_t *a3, char a4, float a5, float a6)
{
  if (CGRectIsInfinite(*(CGRect *)a2->f64))
  {
    uint64_t v20 = 0x100000001000000;
    int32x2_t v21 = vdup_n_s32(0x7F7FFFFFu);
    int32x4_t v22 = 0uLL;
    unint64_t v23 = 1065353216;
    float v24 = 0.0;
    __int16 v25 = 257;
  }
  else
  {
    float64x2_t v15 = a2[1];
    float32x2_t v13 = vcvt_f32_f64(*a2);
    *(float32x2_t *)&v15.f64[0] = vcvt_f32_f64(v15);
    *(int32x2_t *)v12.i8 = vcltz_f32(*(float32x2_t *)&v15.f64[0]);
    float32x2_t v14 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(v12), (int8x8_t)vadd_f32(*(float32x2_t *)&v15.f64[0], v13), (int8x8_t)v13);
    *(void *)&v15.f64[0] &= 0x7FFFFFFF7FFFFFFFuLL;
    if (a3) {
      float32x2_t v14 = RB::operator*(a3, v14, (int32x4_t)v15);
    }
    *(float *)&unsigned int v16 = *(float *)v15.f64 / *((float *)v15.f64 + 1);
    float v17 = 1.0 / (float)(*(float *)v15.f64 / *((float *)v15.f64 + 1));
    v14.f32[0] = v17 * v14.f32[0];
    v18.i32[1] = HIDWORD(v15.f64[0]);
    *(float *)v18.i32 = v17 * *(float *)v15.f64;
    *(float *)v15.f64 = vmuls_lane_f32(0.5, *(float32x2_t *)&v15.f64[0], 1);
    uint64_t v20 = (uint64_t)v14;
    int32x2_t v21 = v18;
    int32x4_t v22 = vdupq_lane_s32(*(int32x2_t *)&v15.f64[0], 0);
    unint64_t v23 = __PAIR64__(LODWORD(a5), v16);
    float v24 = a6;
    LOBYTE(v25) = 5;
    HIBYTE(v25) = a4;
  }
  char v26 = 0;
  return (**a1)(a1, &v20);
}

uint64_t RB::Coverage::anonymous namespace'::visit_rounded_rect(void (***a1)(void, uint64_t *), float64x2_t *a2, int a3, float64x2_t *a4, unsigned int a5, float64_t a6, float64_t a7, float a8, float a9)
{
  if (CGRectIsInfinite(*(CGRect *)a2->f64))
  {
    uint64_t v35 = 0x100000001000000;
    int32x2_t v36 = vdup_n_s32(0x7F7FFFFFu);
    int32x4_t v37 = 0uLL;
    unint64_t v38 = 1065353216;
    float v39 = 0.0;
    __int16 v40 = 257;
  }
  else
  {
    v18.f64[0] = a6;
    v17.i32[1] = HIDWORD(a7);
    if (a3 && a5 > 1) {
      return 0;
    }
    float64x2_t v21 = a2[1];
    float32x2_t v20 = vcvt_f32_f64(*a2);
    *(float32x2_t *)&v21.f64[0] = vcvt_f32_f64(v21);
    *(int32x2_t *)v16.i8 = vcltz_f32(*(float32x2_t *)&v21.f64[0]);
    float32x2_t v22 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(v16), (int8x8_t)vadd_f32(*(float32x2_t *)&v21.f64[0], v20), (int8x8_t)v20);
    v18.f64[1] = a7;
    float32x2_t v23 = vabs_f32(*(float32x2_t *)&v21.f64[0]);
    *(float *)v17.i32 = fminf(v23.f32[0], v23.f32[1]) * 0.5;
    *(float32x2_t *)&v18.f64[0] = vminnm_f32(vmaxnm_f32(vcvt_f32_f64(v18), 0), (float32x2_t)vdup_lane_s32(v17, 0));
    if (a4)
    {
      *(float32x2_t *)&v21.f64[0] = v23;
      float32x2_t v34 = *(float32x2_t *)&v18.f64[0];
      float32x2_t v22 = RB::operator*(a4, v22, (int32x4_t)v21);
      float32x2_t v26 = vmaxnm_f32(v34, 0);
      *(float32x2_t *)&v18.f64[0] = vabs_f32(vcvt_f32_f64(vmlaq_n_f64(vmulq_n_f64(*a4, v26.f32[0]), a4[1], v26.f32[1])));
    }
    else
    {
      uint64_t v25 = *(void *)&v21.f64[0] & 0x7FFFFFFF7FFFFFFFLL;
    }
    float v27 = 1.0;
    char v28 = 2;
    if (*(float *)v18.f64 > 0.0 && *((float *)v18.f64 + 1) > 0.0)
    {
      double v29 = COERCE_DOUBLE(vmul_f32(*(float32x2_t *)&v18.f64[0], (float32x2_t)vdup_n_s32(0x3FA33333u)));
      int32x2_t v30 = vceq_f32((float32x2_t)vzip1_s32(*(int32x2_t *)&v18.f64[0], (int32x2_t)v25), (float32x2_t)vzip2_s32(*(int32x2_t *)&v18.f64[0], (int32x2_t)v25));
      if ((((float)(0.5 * *(float *)&v25) == *(float *)v18.f64) & v30.i32[1] & v30.i32[0]) != 0) {
        char v31 = 5;
      }
      else {
        char v31 = 3;
      }
      if (a3) {
        char v28 = 2;
      }
      else {
        char v28 = v31;
      }
      if (a3 == 1)
      {
        char v28 = 4;
        v18.f64[0] = v29;
      }
      float v27 = vdiv_f32(*(float32x2_t *)&v18.f64[0], (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v18.f64[0], 1)).f32[0];
      v22.f32[0] = (float)(1.0 / v27) * v22.f32[0];
      *(float *)&uint64_t v25 = (float)(1.0 / v27) * *(float *)&v25;
    }
    uint64_t v35 = (uint64_t)v22;
    int32x2_t v36 = (int32x2_t)v25;
    int32x4_t v37 = vdupq_lane_s32(*(int32x2_t *)&v18.f64[0], 1);
    unint64_t v38 = __PAIR64__(LODWORD(a8), LODWORD(v27));
    float v39 = a9;
    LOBYTE(v40) = v28;
    HIBYTE(v40) = a5;
  }
  char v41 = 0;
  (**a1)(a1, &v35);
  return 1;
}

uint64_t RB::Coverage::anonymous namespace'::visit_stroked_path()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v58 = *MEMORY[0x263EF8340];
  if (v3 > 1) {
    return 0;
  }
  int v4 = v3;
  uint64_t v5 = v2;
  uint64_t v6 = v1;
  uint64_t v7 = v0;
  if (v2)
  {
    float32x2_t v8 = (float32x2_t)RB::AffineTransform::scale2(v2);
    uint64_t v9 = 0;
    if (vabds_f32(v8.f32[0], v8.f32[1]) >= 0.0001) {
      return v9;
    }
    float v10 = vaddv_f32(v8) * 0.5;
    if (v10 == 0.0) {
      return v9;
    }
  }
  else
  {
    float v10 = 1.0;
  }
  unint64_t v11 = v6[6] << (v6[6] & 1);
  if (v11 >> 62) {
    return 0;
  }
  unint64_t v13 = 4 * v11;
  if (4 * v11 <= 0x1000)
  {
    MEMORY[0x270FA5388]();
    float32x2_t v14 = (char *)&v40 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v14, 4 * v11);
    if (v11) {
      goto LABEL_12;
    }
LABEL_27:
    unint64_t v29 = 0;
LABEL_28:
    char v30 = rb_line_cap(*((_DWORD *)v6 + 6));
    int v31 = rb_line_join((CGLineJoin)*((_DWORD *)v6 + 7));
    char v32 = v31;
    if (!v31)
    {
      if (*((double *)v6 + 4) <= 0.0) {
        char v32 = 2;
      }
      else {
        char v32 = 0;
      }
    }
    RB::Heap::Heap((RB::Heap *)v56, v57, 4096, 0);
    float v33 = *((double *)v6 + 2) * v10;
    float v34 = *((double *)v6 + 5);
    long long v40 = RBPathNull;
    char v41 = v5;
    float v42 = v33;
    float v43 = v34;
    unint64_t v44 = v29;
    uint64_t v45 = v14;
    BOOL v35 = rb_clip_mode(v4);
    double v36 = *((double *)v6 + 4);
    __int32 v46 = &unk_26C4EDD48;
    RB::Coverage::StrokeablePath::StrokeablePath(&v47, &v40, v56);
    float v37 = v36;
    uint64_t v48 = 0x100000001000000;
    int32x2_t v49 = vdup_n_s32(0x7F7FFFFFu);
    char v50 = 0;
    char v51 = v30;
    char v52 = v32;
    char v53 = 15;
    BOOL v54 = v35;
    float v55 = v37;
    RBPathRelease(v40, *((uint64_t *)&v40 + 1));
    uint64_t v39 = *v6;
    uint64_t v38 = v6[1];
    RBPathRelease(v47, *((uint64_t *)&v47 + 1));
    *(void *)&long long v47 = v39;
    *((void *)&v47 + 1) = v38;
    (*(void (**)(uint64_t, void **))(*(void *)v7 + 8))(v7, &v46);
    long long v47 = RBPathEmpty;
    __int32 v46 = &unk_26C4EDD48;
    RBPathRelease(RBPathEmpty, *((uint64_t *)&RBPathEmpty + 1));
    RB::Heap::~Heap((RB::Heap *)v56);
    uint64_t v9 = 1;
    goto LABEL_34;
  }
  float32x2_t v14 = (char *)malloc_type_malloc(4 * v11, 0x3637ABACuLL);
  if (!v11) {
    goto LABEL_27;
  }
LABEL_12:
  if (v14)
  {
    uint64_t v16 = v6[6];
    if (v16)
    {
      int32x2_t v17 = (double *)v6[7];
      uint64_t v18 = 8 * v16;
      uint64_t v19 = 8 * v16;
      float32x2_t v20 = (float *)v14;
      float64x2_t v21 = v17;
      do
      {
        double v22 = *v21++;
        float v23 = v22;
        *v20++ = v23;
        v19 -= 8;
      }
      while (v19);
      if (v11 != v16)
      {
        float v24 = (float *)&v14[4 * v16];
        do
        {
          double v25 = *v17++;
          float v26 = v25;
          *v24++ = v26;
          v18 -= 8;
        }
        while (v18);
      }
    }
    uint64_t v27 = 0;
    if (v11 <= 1) {
      uint64_t v28 = 1;
    }
    else {
      uint64_t v28 = v11;
    }
    do
    {
      *(float *)&v14[4 * v27] = *(float *)&v14[4 * v27] * v10;
      ++v27;
    }
    while (v28 != v27);
    if (RB::Stroke::Dasher::prepare_pattern(v11, v14, v15)) {
      unint64_t v29 = v11;
    }
    else {
      unint64_t v29 = 0;
    }
    goto LABEL_28;
  }
  uint64_t v9 = 0;
LABEL_34:
  if (v13 > 0x1000) {
    free(v14);
  }
  return v9;
}

void sub_2141478DC(_Unwind_Exception *exception_object)
{
  if (v1 > 0x1000) {
    free(v2);
  }
  _Unwind_Resume(exception_object);
}

float64x2_t CG::Quadratic::Quadratic(CG::Quadratic *this, const Point *a2, const Point *a3, const Point *a4)
{
  *(_OWORD *)this = *(_OWORD *)&a2->v;
  *((_OWORD *)this + 1) = *(_OWORD *)&a3->v;
  *((_OWORD *)this + 2) = *(_OWORD *)&a4->v;
  float64x2_t v4 = *((float64x2_t *)this + 1);
  float64x2_t v5 = vsubq_f64(v4, *(float64x2_t *)this);
  *((double *)this + 6) = v5.f64[0] + v5.f64[0];
  *((double *)this + 7) = v5.f64[1] + v5.f64[1];
  float64x2_t result = vsubq_f64(*((float64x2_t *)this + 2), vaddq_f64(v4, v5));
  *((float64x2_t *)this + 4) = result;
  return result;
}

double CG::Quadratic::start_point(CG::Quadratic *this)
{
  return *(double *)this;
}

double CG::Quadratic::end_point(CG::Quadratic *this)
{
  return *((double *)this + 4);
}

double CG::Quadratic::derivative(float64x2_t *this, double a2)
{
  *(void *)&double result = *(_OWORD *)&vmlaq_n_f64(this[3], this[4], a2 + a2);
  return result;
}

double *CG::Quadratic::length(double *this, int a2)
{
  if (a2 <= 32
    && (*this - this[2] + this[4] - this[2]) * (*this - this[2] + this[4] - this[2])
     + (this[1] - this[3] + this[5] - this[3]) * (this[1] - this[3] + this[5] - this[3]) >= 4.0)
  {
    int v2 = a2;
    CG::Quadratic::split((CG::Quadratic *)this, 0.5, (uint64_t)v3);
    CG::Quadratic::length((CG::Quadratic *)v3, ++v2);
    return (double *)CG::Quadratic::length((CG::Quadratic *)&v4, v2);
  }
  return this;
}

double CG::Quadratic::split@<D0>(CG::Quadratic *this@<X0>, double a2@<D0>, uint64_t a3@<X8>)
{
  double v3 = *((double *)this + 2);
  double v4 = *((double *)this + 3);
  double v5 = *((double *)this + 1);
  double v6 = (v3 - *(double *)this) * a2;
  double v7 = (v4 - v5) * a2;
  double v8 = v6 + *(double *)this;
  double v9 = v7 + v5;
  double v10 = *((double *)this + 4);
  double v11 = *((double *)this + 5);
  double v12 = v3 + (v10 - v3) * a2;
  double v13 = v4 + (v11 - v4) * a2;
  double v14 = (v12 - v8) * a2;
  double v15 = (v13 - (v7 + v5)) * a2;
  double v16 = v15 + v7 + v5;
  double v17 = v7 + v7;
  double v18 = v15 - v7;
  double v19 = v12 - (v14 + v8);
  *(void *)a3 = *(void *)this;
  *(double *)(a3 + 8) = v5;
  *(double *)(a3 + 16) = v8;
  *(double *)(a3 + 24) = v9;
  *(double *)(a3 + 32) = v14 + v8;
  *(double *)(a3 + 40) = v16;
  *(double *)(a3 + 48) = v6 + v6;
  *(double *)(a3 + 56) = v17;
  *(double *)(a3 + 64) = v14 - v6;
  *(double *)(a3 + 72) = v18;
  *(double *)(a3 + 80) = v14 + v8;
  *(double *)(a3 + 88) = v16;
  double result = v11 - (v13 + v13 - v16);
  *(double *)(a3 + 96) = v12;
  *(double *)(a3 + 104) = v13;
  *(double *)(a3 + 112) = v10;
  *(double *)(a3 + 120) = v11;
  *(double *)(a3 + 128) = v19 + v19;
  *(double *)(a3 + 136) = v13 - v16 + v13 - v16;
  *(double *)(a3 + 144) = v10 - (v12 + v19);
  *(double *)(a3 + 152) = result;
  return result;
}

double *CG::Quadratic::index(double *this, double a2)
{
  if (a2 > 0.0)
  {
    double v3 = (CG::Quadratic *)this;
    this = CG::Quadratic::length(this, 0);
    if (v4 > a2)
    {
      double v5 = 1.0;
      double v6 = 0.0;
      do
      {
        CG::Quadratic::split(v3, (v6 + v5) * 0.5, (uint64_t)v8);
        this = CG::Quadratic::length(v8, 0);
        if (v7 <= a2) {
          double v6 = (v6 + v5) * 0.5;
        }
        else {
          double v5 = (v6 + v5) * 0.5;
        }
      }
      while (v5 - v6 > 0.0001);
    }
  }
  return this;
}

uint64_t RB::BinPacker::add(uint64_t this, unsigned int a2, unsigned int a3, void *a4, uint64_t a5)
{
  uint64_t v5 = (int)a2 * (uint64_t)(int)a3;
  if (v5 == (int)v5)
  {
    uint64_t v10 = this;
    if (*(unsigned char *)(this + 1104))
    {
      LOBYTE(v11) = 1;
    }
    else
    {
      uint64_t v11 = *(void *)(this + 1088);
      if (v11) {
        LOBYTE(v11) = *(void *)(v11 + 8) != a5;
      }
    }
    *(unsigned char *)(this + 1104) = v11;
    unint64_t v12 = *(void *)(this + 24);
    this = (*(void *)(this + 16) + 7) & 0xFFFFFFFFFFFFFFF8;
    if (this + 32 > v12) {
      this = RB::Heap::alloc_slow((size_t *)v10, 0x20uLL, 7);
    }
    else {
      *(void *)(v10 + 16) = this + 32;
    }
    *(_DWORD *)this = a2;
    *(_DWORD *)(this + 4) = a3;
    *(void *)(this + 8) = a5;
    *(void *)(this + 16) = a4;
    *(void *)(this + 24) = *(void *)(v10 + 1088);
    *(void *)(v10 + 1088) = this;
    *(int32x2_t *)(v10 + 1072) = vmax_s32(*(int32x2_t *)(v10 + 1072), (int32x2_t)__PAIR64__(a3, a2));
    int v13 = *(_DWORD *)(v10 + 1080);
    BOOL v14 = __OFADD__(v13, v5);
    int v15 = v13 + v5;
    if (v14) {
      int v15 = 0x7FFFFFFF;
    }
    *(_DWORD *)(v10 + 1080) = v15;
  }
  return this;
}

uint64_t RB::Heap::emplace<RB::BinPacker::bin,int &,int &,unsigned long &>(RB::Heap *this, _DWORD *a2, int *a3, uint64_t *a4)
{
  unint64_t v8 = *((void *)this + 3);
  uint64_t result = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (result + 32 > v8) {
    uint64_t result = RB::Heap::alloc_slow((size_t *)this, 0x20uLL, 7);
  }
  else {
    *((void *)this + 2) = result + 32;
  }
  int v10 = *a3;
  uint64_t v11 = *a4;
  *(_DWORD *)uint64_t result = *a2;
  *(_DWORD *)(result + 4) = v10;
  *(void *)(result + 8) = v11;
  *(void *)(result + 16) = 0;
  return result;
}

__n128 RB::BinPacker::append_packed(RB::Heap *this, uint64_t a2, int a3, int a4)
{
  unint64_t v8 = *((void *)this + 3);
  unint64_t v9 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v9 + 48 > v8) {
    unint64_t v9 = RB::Heap::alloc_slow((size_t *)this, 0x30uLL, 7);
  }
  else {
    *((void *)this + 2) = v9 + 48;
  }
  __n128 result = *(__n128 *)a2;
  long long v11 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)unint64_t v9 = *(_OWORD *)a2;
  *(_OWORD *)(v9 + 16) = v11;
  *(_DWORD *)(v9 + 32) = a3;
  *(_DWORD *)(v9 + 36) = a4;
  uint64_t v12 = *((void *)this + 137);
  *(void *)(v9 + 40) = *(void *)(v12 + 16);
  *(void *)(v12 + 16) = v9;
  return result;
}

void RB::BinPacker::pack(RB::Heap *this, uint64_t a2)
{
  uint64_t v30 = a2;
  if (a2)
  {
    uint64_t v2 = a2;
    int v4 = *((int *)this + 266) >> 1;
    int v5 = *((_DWORD *)this + 267);
    double v6 = &v30;
    do
    {
      while (*(_DWORD *)v2 <= v4)
      {
        double v6 = (uint64_t *)(v2 + 24);
        uint64_t v2 = *(void *)(v2 + 24);
        if (!v2) {
          goto LABEL_9;
        }
      }
      if (*(_DWORD *)(v2 + 4) + v5 > *((_DWORD *)this + 267))
      {
        int v7 = *((_DWORD *)this + 266);
        uint64_t v8 = *(void *)(v2 + 8);
        int v32 = *((_DWORD *)this + 267);
        int v33 = v7;
        uint64_t v31 = v8;
        uint64_t v9 = RB::Heap::emplace<RB::BinPacker::bin,int &,int &,unsigned long &>(this, &v33, &v32, &v31);
        int v5 = 0;
        *(void *)(v9 + 24) = *((void *)this + 137);
        *((void *)this + 137) = v9;
      }
      RB::BinPacker::append_packed(this, v2, 0, v5);
      v5 += *(_DWORD *)(v2 + 4);
      uint64_t v2 = *(void *)(v2 + 24);
      uint64_t *v6 = v2;
    }
    while (v2);
LABEL_9:
    if (v30)
    {
      unint64_t v10 = 0;
      uint64_t v11 = v30;
      do
      {
        ++v10;
        uint64_t v11 = *(void *)(v11 + 24);
      }
      while (v11);
      uint64_t v13 = v12;
      uint64_t v30 = v12;
      int v14 = *(_DWORD *)(v12 + 4);
      if (v14 + v5 > *((_DWORD *)this + 267))
      {
        int v15 = *((_DWORD *)this + 266);
        uint64_t v16 = *(void *)(v12 + 8);
        int v32 = *((_DWORD *)this + 267);
        int v33 = v15;
        uint64_t v31 = v16;
        uint64_t v17 = RB::Heap::emplace<RB::BinPacker::bin,int &,int &,unsigned long &>(this, &v33, &v32, &v31);
        int v5 = 0;
        *(void *)(v17 + 24) = *((void *)this + 137);
        *((void *)this + 137) = v17;
        int v14 = *(_DWORD *)(v13 + 4);
      }
      int v18 = 0;
      uint64_t v19 = 0;
      int v20 = v14 + v5;
      while (1)
      {
        int v21 = *(_DWORD *)v13 + v18;
        if (v21 > *((_DWORD *)this + 266)) {
          break;
        }
        if (!v19 && v21 > v4) {
          uint64_t v19 = (*(_DWORD *)(v13 + 4) + v5);
        }
        RB::BinPacker::append_packed(this, v13, v18, v5);
        v18 += *(_DWORD *)v13;
        uint64_t v13 = *(void *)(v13 + 24);
        if (!v13) {
          return;
        }
      }
      while (1)
      {
        int v22 = (int)v19 >= v20 ? v20 : v19;
        int v23 = *(_DWORD *)(v13 + 4);
        if (v23 + v22 > *((_DWORD *)this + 267)) {
          break;
        }
        if (v20 <= (int)v19) {
          goto LABEL_28;
        }
        uint64_t v27 = (v23 + v19);
        int v28 = v4;
LABEL_29:
        int v29 = 0;
        while (*(_DWORD *)v13 + v29 <= v4)
        {
          RB::BinPacker::append_packed(this, v13, v29 + v28, v19);
          v29 += *(_DWORD *)v13;
          uint64_t v13 = *(void *)(v13 + 24);
          if (!v13) {
            return;
          }
        }
        uint64_t v19 = v27;
      }
      int v24 = *((_DWORD *)this + 266);
      uint64_t v25 = *(void *)(v13 + 8);
      int v32 = *((_DWORD *)this + 267);
      int v33 = v24;
      uint64_t v31 = v25;
      uint64_t v26 = RB::Heap::emplace<RB::BinPacker::bin,int &,int &,unsigned long &>(this, &v33, &v32, &v31);
      uint64_t v19 = 0;
      int v20 = 0;
      *(void *)(v26 + 24) = *((void *)this + 137);
      *((void *)this + 137) = v26;
      int v23 = *(_DWORD *)(v13 + 4);
LABEL_28:
      int v28 = 0;
      uint64_t v27 = v19;
      LODWORD(v19) = v20;
      v20 += v23;
      goto LABEL_29;
    }
  }
}

BOOL RB::BinPacker::pack(RB::BinPacker::item *)::$_0::__invoke(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a1 + 4) > *(_DWORD *)(a2 + 4);
}

void RB::Table<unsigned long,RB::BinPacker::item *>::for_each<RB::BinPacker::pack(void)::$_0>(RB::BinPacker::pack(void)::$_0)const::{lambda(void const*,void const*,void *)#1}::__invoke(uint64_t a1, uint64_t a2, RB::Heap **a3)
{
}

uint64_t RB::anonymous namespace'::list_sort_1<RB::BinPacker::item,&RB::BinPacker::item::_next>(uint64_t a1, unint64_t a2, unsigned int (*a3)(uint64_t, uint64_t))
{
  uint64_t v3 = a1;
  if (a2 >= 2)
  {
    unint64_t v6 = a2 >> 1;
    uint64_t v7 = a1;
    uint64_t v8 = (a2 >> 1) - 1;
    if (a2 >> 1 != 1)
    {
      uint64_t v7 = a1;
      do
      {
        uint64_t v7 = *(void *)(v7 + 24);
        --v8;
      }
      while (v8);
    }
    uint64_t v9 = *(void *)(v7 + 24);
    *(void *)(v7 + 24) = 0;
    if (a3(v3, v10))
    {
      uint64_t v11 = *(void *)(v3 + 24);
      uint64_t v12 = v10;
    }
    else
    {
      uint64_t v12 = *(void *)(v10 + 24);
      uint64_t v11 = v3;
      uint64_t v3 = v10;
    }
    BOOL v13 = v12 != 0;
    uint64_t v14 = v3;
    if (v12) {
      BOOL v15 = v11 == 0;
    }
    else {
      BOOL v15 = 1;
    }
    if (!v15)
    {
      do
      {
        if (a3(v11, v12))
        {
          *(void *)(v14 + 24) = v11;
          uint64_t v16 = *(void *)(v11 + 24);
          uint64_t v17 = v12;
          uint64_t v14 = v11;
          uint64_t v11 = v16;
        }
        else
        {
          *(void *)(v14 + 24) = v12;
          uint64_t v17 = *(void *)(v12 + 24);
          uint64_t v16 = v11;
          uint64_t v14 = v12;
          uint64_t v12 = v17;
        }
        BOOL v13 = v17 != 0;
        if (v17) {
          BOOL v18 = v16 == 0;
        }
        else {
          BOOL v18 = 1;
        }
      }
      while (!v18);
      uint64_t v12 = v17;
      uint64_t v11 = v16;
    }
    if (v13) {
      uint64_t v19 = v12;
    }
    else {
      uint64_t v19 = v11;
    }
    *(void *)(v14 + 24) = v19;
  }
  return v3;
}

uint64_t *RB::Coverage::StrokeablePath::StrokeablePath(uint64_t *a1, uint64_t a2, size_t *a3)
{
  *a1 = RBPathRetain(*(void *)a2, *(void *)(a2 + 8));
  a1[1] = v6;
  a1[2] = 0;
  a1[3] = *(void *)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 32);
  a1[4] = v7;
  a1[5] = 0;
  uint64_t v8 = *(long long **)(a2 + 16);
  if (v8)
  {
    uint64_t v9 = (_OWORD *)((a3[2] + 15) & 0xFFFFFFFFFFFFFFF0);
    if ((unint64_t)(v9 + 3) > a3[3]) {
      uint64_t v9 = (_OWORD *)RB::Heap::alloc_slow(a3, 0x30uLL, 15);
    }
    else {
      a3[2] = (size_t)(v9 + 3);
    }
    long long v10 = *v8;
    long long v11 = v8[2];
    v9[1] = v8[1];
    uint64_t v9[2] = v11;
    *uint64_t v9 = v10;
    a1[2] = (uint64_t)v9;
    uint64_t v7 = a1[4];
  }
  if (v7)
  {
    uint64_t v12 = (char *)((a3[2] + 3) & 0xFFFFFFFFFFFFFFFCLL);
    BOOL v13 = &v12[4 * v7];
    if ((unint64_t)v13 > a3[3])
    {
      uint64_t v12 = (char *)RB::Heap::alloc_slow(a3, 4 * v7, 3);
      uint64_t v7 = a1[4];
      if (!v7) {
        goto LABEL_9;
      }
    }
    else
    {
      a3[2] = (size_t)v13;
    }
    memmove(v12, *(const void **)(a2 + 40), 4 * v7);
LABEL_9:
    a1[5] = (uint64_t)v12;
  }
  return a1;
}

void sub_214148260(_Unwind_Exception *a1)
{
  RBPathRelease(*v1, v1[1]);
  _Unwind_Resume(a1);
}

void RB::Coverage::StrokeablePath::bounds(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 8) != 0x21421C340)
  {
    uint64_t v3 = *(long long **)(a1 + 16);
    if (v3)
    {
      long long v4 = *v3;
      long long v5 = v3[2];
      long long v22 = v3[1];
      long long v23 = v5;
      long long v21 = v4;
    }
    else
    {
      long long v21 = xmmword_2142181C0;
      long long v22 = xmmword_2142181D0;
      long long v23 = 0uLL;
    }
    float v6 = *(float *)(a1 + 24);
    __int16 v7 = *(_WORD *)(a2 + 73);
    float v8 = *(float *)(a2 + 80);
    long long v10 = (void (**)(void))&unk_26C4EDBA0;
    float v11 = v6 * (float)(0.5 * RB::AffineTransform::scale((float64x2_t *)&v21));
    __int16 v12 = v7;
    float v13 = v8 * v8;
    float32x2_t v14 = (float32x2_t)vdup_n_s32(0x7F800000u);
    uint64_t v15 = 0x7F0000007FLL;
    long long v16 = 0u;
    long long v17 = 0u;
    uint64_t v18 = 0;
    char v19 = 1;
    int v20 = 0;
    RBPathMap(*(CGPathRef *)a1, *(void **)(a1 + 8), &v10, *(float64x2_t **)(a1 + 16));
    v9.i64[0] = v15;
    RB::Rect::from_bounds(v14, v9);
  }
}

void RB::Coverage::StrokeablePath::map(uint64_t a1, uint64_t a2, void (**a3)(void), float64x2_t a4, float32x2_t a5, double a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 8) != 0x21421C340)
  {
    float v14 = *(float *)(a1 + 24);
    float v15 = v14 * 0.70711;
    if (!*(unsigned char *)(a2 + 74))
    {
      float v16 = (float)(v14 * 0.5) * fmaxf(*(float *)(a2 + 80), 1.0);
      if (v15 < v16) {
        float v15 = v16;
      }
    }
    long long v17 = *(_OWORD *)(a8 + 16);
    float64x2_t v46 = *(float64x2_t *)a8;
    long long v47 = v17;
    float64x2_t v48 = *(float64x2_t *)(a8 + 32);
    if (RB::AffineTransform::invert((RB::AffineTransform *)&v46)) {
      uint64_t v18 = &v46;
    }
    else {
      uint64_t v18 = (float64x2_t *)a8;
    }
    int32x4_t v19 = (int32x4_t)v18[1];
    float64x2_t v20 = v18[2];
    float64x2_t v46 = *v18;
    long long v47 = (__int128)v19;
    float64x2_t v48 = v20;
    *(double *)v19.i64 = a6;
    float32x2_t v21 = RB::operator*(&v46, a5, v19);
    double v44 = *(double *)&v21;
    float32x2_t v45 = v22;
    v21.f32[0] = -v15;
    BOOL v23 = RB::Rect::inset((float32x2_t *)&v44, v21, -v15);
    int v24 = *(_OWORD **)(a1 + 16);
    if (v24)
    {
      long long v25 = *v24;
      long long v26 = v24[1];
      float64x2_t v27 = *((float64x2_t *)v24 + 2);
    }
    else
    {
      long long v25 = xmmword_2142181C0;
      long long v26 = xmmword_2142181D0;
      float64x2_t v27 = 0uLL;
    }
    int v28 = *(const CGPath **)a1;
    int v29 = *(void **)(a1 + 8);
    float64x2_t v46 = (float64x2_t)v25;
    long long v47 = v26;
    float64x2_t v48 = vaddq_f64(v27, a4);
    double v30 = v44;
    float32x2_t v31 = v45;
    char v32 = *(unsigned char *)(a2 + 73);
    char v33 = *(unsigned char *)(a2 + 74);
    float v34 = *(float *)(a2 + 80);
    uint64_t v35 = *(void *)(a1 + 32);
    float v36 = *(float *)(a1 + 24);
    int v37 = *(_DWORD *)(a1 + 28);
    float v38 = RB::bezier_flatness((RB *)v23);
    float v39 = RB::AffineTransform::scale((float64x2_t *)a8);
    float32x2_t v40 = vrecpe_f32((float32x2_t)LODWORD(v39));
    float32x2_t v41 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v39), v40), v40);
    LODWORD(v42) = v37;
    RB::Stroke::flatten_points(v28, v29, &v46, a3, v32, v33, v35, v30, v31, v36, v34, v42, v38 * vmul_f32(v41, vrecps_f32((float32x2_t)LODWORD(v39), v41)).f32[0]);
  }
}

uint64_t RB::Coverage::StrokeablePath::can_mix(uint64_t a1, uint64_t a2, const RB::AffineTransform *a3)
{
  if (*(void *)(a1 + 32) != *(void *)(a2 + 32)) {
    return 0;
  }
  can_midouble x = RB::can_mix(*(float64x2_t **)(a1 + 16), *(float64x2_t **)(a2 + 16), a3);
  unsigned __int8 v6 = can_mix;
  if (*(float *)(a1 + 24) == *(float *)(a2 + 24) && *(float *)(a1 + 28) == *(float *)(a2 + 28))
  {
    uint64_t v9 = *(void *)(a1 + 32);
    if (!v9) {
      goto LABEL_7;
    }
    long long v10 = *(float **)(a1 + 40);
    float v11 = *(float **)(a2 + 40);
    uint64_t v12 = 4 * v9;
    while (*v10 == *v11)
    {
      ++v10;
      ++v11;
      v12 -= 4;
      if (!v12) {
        goto LABEL_7;
      }
    }
  }
  if ((can_mix & 0xFE) != 0) {
    unsigned __int8 v6 = 2;
  }
  else {
    unsigned __int8 v6 = can_mix;
  }
LABEL_7:
  if (!v6) {
    return 0;
  }
  CanMidouble x = RBPathCanMix(*(RBPath *)a1, *(RBPath *)a2);
  if (CanMix >= v6) {
    return v6;
  }
  else {
    return CanMix;
  }
}

float32_t RB::Coverage::StrokeablePath::mix(uint64_t a1, RB *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, CGFloat a7)
{
  float v13 = (const RB::AffineTransform ***)(a1 + 16);
  uint64_t v12 = *(float64x2_t **)(a1 + 16);
  if (v12)
  {
    v14.f64[0] = RB::operator*((float64x2_t *)a4, v12);
    float64x2_t v44 = v14;
    long long v45 = v15;
    long long v46 = v16;
  }
  else
  {
    long long v17 = *(_OWORD *)(a4 + 16);
    float64x2_t v44 = *(float64x2_t *)a4;
    long long v45 = v17;
    long long v46 = *(_OWORD *)(a4 + 32);
  }
  uint64_t v18 = *(float64x2_t **)(a3 + 16);
  if (v18)
  {
    v19.f64[0] = RB::operator*((float64x2_t *)a5, v18);
    float64x2_t v41 = v19;
    long long v42 = v20;
    long long v43 = v21;
    float32x2_t v22 = *(const RB::AffineTransform ***)(a3 + 16);
  }
  else
  {
    float32x2_t v22 = 0;
    long long v23 = *(_OWORD *)(a5 + 16);
    float64x2_t v41 = *(float64x2_t *)a5;
    long long v42 = v23;
    long long v43 = *(_OWORD *)(a5 + 32);
  }
  RB::mix(a2, v13, v22, (const RB::AffineTransform *)a4, a7);
  if (*v13)
  {
    v24.f64[0] = RB::operator*((float64x2_t *)a6, (float64x2_t *)*v13);
    float64x2_t v38 = v24;
    long long v39 = v25;
    long long v40 = v26;
  }
  else
  {
    long long v27 = *(_OWORD *)(a6 + 16);
    float64x2_t v38 = *(float64x2_t *)a6;
    long long v39 = v27;
    long long v40 = *(_OWORD *)(a6 + 32);
  }
  RBPathMix(*(RBPath *)a1, *(RBPath *)a3, *(float *)&a7, &v44, &v41, &v38, &v37);
  uint64_t v28 = *(void *)a1;
  uint64_t v29 = *(void *)(a1 + 8);
  *(_OWORD *)a1 = v37;
  *(void *)&long long v37 = v28;
  *((void *)&v37 + 1) = v29;
  RBPathRelease(v28, v29);
  float32x2_t v30 = vmla_n_f32(*(float32x2_t *)(a1 + 24), vsub_f32(*(float32x2_t *)(a3 + 24), *(float32x2_t *)(a1 + 24)), *(float *)&a7);
  *(float32x2_t *)(a1 + 24) = v30;
  uint64_t v31 = *(void *)(a1 + 32);
  if (v31)
  {
    char v32 = *(float **)(a1 + 40);
    char v33 = *(float **)(a3 + 40);
    do
    {
      float v34 = *v33++;
      v30.f32[0] = *v32 + (float)((float)(v34 - *v32) * *(float *)&a7);
      *v32++ = v30.f32[0];
      --v31;
    }
    while (v31);
  }
  return v30.f32[0];
}

void RB::Coverage::StrokeablePath::add_path(size_t size@<X1>, uint64_t a2@<X0>, CGContextRef *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  if (*(void *)(a2 + 8) == 0x21421C340)
  {
    CGContextBeginPath(*a3);
    *(void *)a4 = 0;
    *(_DWORD *)(a4 + 8) = 2;
    return;
  }
  unint64_t v8 = *(void *)(a2 + 32);
  if (v8 >> 61)
  {
    uint64_t v9 = 0;
    long long v10 = *(float **)(a2 + 40);
    float v11 = &v10[v8];
    BOOL v12 = 1;
  }
  else
  {
    BOOL v12 = 8 * v8 <= 0x1000;
    if (8 * v8 > 0x1000)
    {
      uint64_t v9 = (char *)malloc_type_malloc(8 * v8, 0xD1F95696uLL);
      unint64_t v8 = *(void *)(a2 + 32);
      if (!v8) {
        goto LABEL_12;
      }
    }
    else
    {
      MEMORY[0x270FA5388](a2, 8 * v8);
      uint64_t v9 = (char *)v41 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v9, v13);
      if (!v8) {
        goto LABEL_12;
      }
    }
    long long v10 = *(float **)(a2 + 40);
    float v11 = &v10[v8];
  }
  float64x2_t v14 = (double *)v9;
  do
  {
    float v15 = *v10++;
    *v14++ = v15;
  }
  while (v10 != v11);
LABEL_12:
  unsigned int v16 = *(unsigned __int8 *)(size + 73);
  if (v16 < 3)
  {
    CGContextSetLineWidth(*a3, *(float *)(a2 + 24));
    long long v17 = *a3;
    CGLineJoin v18 = RBStrokeRef::clip(*(unsigned __int8 *)(size + 74));
    CGContextSetLineJoin(v17, v18);
    float64x2_t v19 = *a3;
    CGLineCap v20 = cg_line_cap(*(unsigned __int8 *)(size + 73));
    CGContextSetLineCap(v19, v20);
    CGContextSetLineDash(*a3, *(float *)(a2 + 28), (const CGFloat *)v9, *(void *)(a2 + 32));
    CGContextSetMiterLimit(*a3, *(float *)(size + 80));
    CGPathRef v21 = RBPathCopyCGPath(*(const CGPath **)a2, *(void *)(a2 + 8));
    CGPathRef v22 = v21;
    long long v23 = *(_OWORD **)(a2 + 16);
    if (v23)
    {
      long long v24 = v23[1];
      v42[0] = *v23;
      v42[1] = v24;
      v42[2] = v23[2];
      uint64_t v25 = MEMORY[0x21669A520](v21, v42);
      if (v22) {
        CFRelease(v22);
      }
      int v26 = 2;
      CGPathRef v22 = (CGPathRef)v25;
      if (!v25) {
        goto LABEL_17;
      }
    }
    else
    {
      int v26 = 2;
      if (!v21) {
        goto LABEL_17;
      }
    }
LABEL_22:
    *(void *)a4 = CFRetain(v22);
    *(_DWORD *)(a4 + 8) = v26;
    CFRelease(v22);
    if (v12) {
      return;
    }
    goto LABEL_23;
  }
  long long v27 = *(const CGPath **)a2;
  uint64_t v28 = *(void *)(a2 + 8);
  uint64_t v29 = rb_line_cap(v16);
  uint64_t v30 = RBStrokeRef::clip(*(unsigned __int8 *)(size + 74));
  uint64_t v31 = RBPathCopyStrokedPath((uint64_t)v27, v28, v29, v30, (uint64_t *)v9, *(void *)(a2 + 32));
  char v33 = (const CGPath *)v31;
  uint64_t v34 = (uint64_t)v32;
  uint64_t v35 = *(_OWORD **)(a2 + 16);
  if (v35)
  {
    long long v36 = v35[1];
    v41[0] = *v35;
    v41[1] = v36;
    v41[2] = v35[2];
    RBPathCopyTransformedPath(v31, v32);
    float64x2_t v38 = v37;
    uint64_t v40 = v39;
    RBPathRelease(0, 0x21421C340);
    RBPathRelease((uint64_t)v33, v34);
    char v33 = v38;
    uint64_t v34 = v40;
  }
  CGPathRef v22 = RBPathCopyCGPath(v33, v34);
  RBPathRelease((uint64_t)v33, v34);
  int v26 = 0;
  if (v22) {
    goto LABEL_22;
  }
LABEL_17:
  *(void *)a4 = 0;
  *(_DWORD *)(a4 + 8) = v26;
  if (v12) {
    return;
  }
LABEL_23:
  free(v9);
}

void sub_214148AF4(_Unwind_Exception *a1)
{
  RBPathRelease(v3, v2);
  if ((v4 & 1) == 0) {
    free(v1);
  }
  _Unwind_Resume(a1);
}

void RB::Coverage::StrokeablePath::clip(uint64_t a1, size_t size, uint64_t a3)
{
  int v6 = *(unsigned __int8 *)(size + 76);
  if (*(unsigned __int8 *)(a3 + 140) != v6) {
    RB::CGContext::set_aliasing_mode_slow(a3, v6);
  }
  RB::Coverage::StrokeablePath::add_path(size, a1, (CGContextRef *)a3, (uint64_t)&v8);
  __int16 v7 = v8;
  if (v8)
  {
    CGContextBeginPath(*(CGContextRef *)a3);
    CGContextAddPath(*(CGContextRef *)a3, v7);
  }
  if (v9 == 2) {
    CGContextReplacePathWithStrokedPath(*(CGContextRef *)a3);
  }
  CGContextClip(*(CGContextRef *)a3);
  if (v7)
  {
    CFRelease(v7);
  }
}

void sub_214148C08(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

void RB::Coverage::StrokeablePath::fill(uint64_t a1, size_t size, uint64_t a3, uint64_t a4)
{
  int v8 = *(unsigned __int8 *)(size + 76);
  if (*(unsigned __int8 *)(a3 + 140) != v8) {
    RB::CGContext::set_aliasing_mode_slow(a3, v8);
  }
  RB::Coverage::StrokeablePath::add_path(size, a1, (CGContextRef *)a3, (uint64_t)&v12);
  CGPathDrawingMode v10 = mode;
  if (mode == kCGPathStroke)
  {
    if (*(unsigned char *)(a3 + 131) && *(unsigned char *)(a4 + 9) && *(unsigned __int8 *)(a3 + 130) != *(unsigned __int8 *)(a4 + 8)
      || (v9.i16[0] = *(_WORD *)(a3 + 122), *(short float *)v9.i16 != *(short float *)a4)
      || (v9.i16[0] = *(_WORD *)(a3 + 124), *(short float *)v9.i16 != *(short float *)(a4 + 2))
      || (v9.i16[0] = *(_WORD *)(a3 + 126), *(short float *)v9.i16 != *(short float *)(a4 + 4))
      || (v9.i16[0] = *(_WORD *)(a3 + 128), *(short float *)v9.i16 != *(short float *)(a4 + 6)))
    {
      RB::CGContext::set_stroke_color_slow((RB::CGContext *)a3, (const RB::Fill::Color *)a4, v9);
    }
  }
  else if (*(unsigned char *)(a3 + 121) && *(unsigned char *)(a4 + 9) && *(unsigned __int8 *)(a3 + 120) != *(unsigned __int8 *)(a4 + 8) {
         || (v9.i16[0] = *(_WORD *)(a3 + 112), *(short float *)v9.i16 != *(short float *)a4)
  }
         || (v9.i16[0] = *(_WORD *)(a3 + 114), *(short float *)v9.i16 != *(short float *)(a4 + 2))
         || (v9.i16[0] = *(_WORD *)(a3 + 116), *(short float *)v9.i16 != *(short float *)(a4 + 4))
         || (v9.i16[0] = *(_WORD *)(a3 + 118), *(short float *)v9.i16 != *(short float *)(a4 + 6)))
  {
    RB::CGContext::set_fill_color_slow((RB::CGContext *)a3, (const RB::Fill::Color *)a4, v9);
  }
  float v11 = v12;
  if (v12)
  {
    CGContextDrawPathDirect();
    CFRelease(v11);
  }
  else
  {
    CGContextDrawPath(*(CGContextRef *)a3, v10);
  }
}

void sub_214148DC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void *RB::Coverage::StrokeablePath::encode(uint64_t a1, uint64_t a2, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RBPathEncode(*(RBPath *)a1, this);
  RB::ProtobufEncoder::end_length_delimited(this);
  int v6 = *(float64x2_t **)(a1 + 16);
  if (v6)
  {
    int64x2_t v7 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v6[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v6, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v6[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v7, 1), (int8x16_t)v7).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x12uLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v6->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  int v8 = *(int *)(a1 + 24);
  if (*(float *)&v8 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(this, 0x1DuLL);
    RB::ProtobufEncoder::encode_fixed32(this, v8);
  }
  int v9 = rb_line_cap(*(unsigned __int8 *)(a2 + 73));
  if (v9)
  {
    int v10 = v9;
    RB::ProtobufEncoder::encode_varint(this, 0x20uLL);
    RB::ProtobufEncoder::encode_varint(this, v10);
  }
  int v11 = RBStrokeRef::clip(*(unsigned __int8 *)(a2 + 74));
  if (v11)
  {
    int v12 = v11;
    RB::ProtobufEncoder::encode_varint(this, 0x28uLL);
    RB::ProtobufEncoder::encode_varint(this, v12);
  }
  if (*(unsigned char *)(a2 + 76) == 1)
  {
    RB::ProtobufEncoder::encode_varint(this, 0x30uLL);
    RB::ProtobufEncoder::encode_varint(this, 1uLL);
  }
  int v13 = *(int *)(a2 + 80);
  if (*(float *)&v13 != 10.0)
  {
    RB::ProtobufEncoder::encode_varint(this, 0x3DuLL);
    RB::ProtobufEncoder::encode_fixed32(this, v13);
  }
  __n128 result = RB::ProtobufEncoder::packed_fixed32_field(this, 8, *(const unsigned int **)(a1 + 40), *(void *)(a1 + 32));
  int v15 = *(int *)(a1 + 28);
  if (*(float *)&v15 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(this, 0x4DuLL);
    return RB::ProtobufEncoder::encode_fixed32(this, v15);
  }
  return result;
}

void RB::Coverage::StrokeablePath::decode(uint64_t a1, uint64_t a2, size_t **this)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  CGPathRef v22 = 0;
  long long v23 = 0;
  unint64_t v24 = 16;
  while (1)
  {
    unint64_t field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
    if (!field) {
      break;
    }
    switch((field >> 3))
    {
      case 1u:
        if ((field & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
          RBPathDecode((RB::Decoder *)this);
        }
        *((unsigned char *)this + 56) = 1;
        *this = this[1];
        break;
      case 2u:
        RB::Decoder::affine_transform_field(this, field);
        *(void *)(a1 + 16) = v14;
        break;
      case 3u:
        *(float *)(a1 + 24) = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)this, field);
        break;
      case 4u:
        unsigned int v9 = RB::ProtobufDecoder::uint_field((uint64_t **)this, field);
        *(unsigned char *)(a2 + 73) = rb_line_cap(v9);
        break;
      case 5u:
        CGLineJoin v8 = RB::ProtobufDecoder::uint_field((uint64_t **)this, field);
        *(unsigned char *)(a2 + 74) = rb_line_join(v8);
        break;
      case 6u:
        *(unsigned char *)(a2 + 76) = RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)this, field);
        break;
      case 7u:
        *(float *)(a2 + 80) = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)this, field);
        break;
      case 8u:
        float v10 = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)this, field);
        int v11 = v23;
        int v12 = (RB::Stroke::Dasher *)((char *)v23 + 1);
        if (v24 < (unint64_t)v23 + 1)
        {
          RB::vector<float,16ul,unsigned long>::reserve_slow(__dst, (size_t)v12);
          int v11 = v23;
          int v12 = (RB::Stroke::Dasher *)((char *)v23 + 1);
        }
        int v13 = v22;
        if (!v22) {
          int v13 = __dst;
        }
        *(float *)&v13[4 * (void)v11] = v10;
        long long v23 = v12;
        break;
      case 9u:
        *(float *)(a1 + 28) = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)this, field);
        break;
      default:
        RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, field);
        break;
    }
  }
  if (v23)
  {
    if (v22) {
      int v15 = (float *)v22;
    }
    else {
      int v15 = (float *)__dst;
    }
    if (RB::Stroke::Dasher::validate_pattern(v23, v15, v7))
    {
      unsigned int v16 = v23;
      *(void *)(a1 + 32) = v23;
      long long v17 = this[8];
      CGLineJoin v18 = (char *)((v17[2] + 3) & 0xFFFFFFFFFFFFFFFCLL);
      float64x2_t v19 = &v18[4 * (void)v16];
      if ((unint64_t)v19 > v17[3])
      {
        CGLineJoin v18 = (char *)RB::Heap::alloc_slow(v17, 4 * (void)v16, 3);
        unsigned int v16 = *(RB::Stroke::Dasher **)(a1 + 32);
        if (v16) {
          goto LABEL_27;
        }
      }
      else
      {
        v17[2] = (size_t)v19;
        if (v16)
        {
LABEL_27:
          if (v22) {
            CGLineCap v20 = v22;
          }
          else {
            CGLineCap v20 = __dst;
          }
          memmove(v18, v20, 4 * (void)v16);
        }
      }
      *(void *)(a1 + 40) = v18;
      goto LABEL_33;
    }
    *((unsigned char *)this + 56) = 1;
    *this = this[1];
  }
LABEL_33:
  if (v22) {
    free(v22);
  }
}

void sub_214149244(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  if (a19) {
    free(a19);
  }
  _Unwind_Resume(exception_object);
}

void RB::Coverage::StrokeablePath::attributes(uint64_t *a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  long long v5 = &unk_26C4ED488;
  v6[0] = (void *)RBPathRetain(v2, v3);
  v6[1] = v4;
  RB::XML::Element::set<RB::XML::Value::Path>();
}

void sub_214149510(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12)
{
  if (a11) {
    free(a11);
  }
  _Unwind_Resume(exception_object);
}

void RB::XML::Element::set<RB::XML::Value::Path>()
{
}

void sub_214149610(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0xE1C40672A944CLL);
  _Unwind_Resume(a1);
}

void RB::XML::Element::set<RB::XML::Value::Transform>()
{
}

void RB::XML::Element::set<RB::XML::Value::Float>()
{
}

void RB::XML::Element::set<RB::XML::Value::LineCap>()
{
}

void RB::XML::Element::set<RB::XML::Value::LineJoin>()
{
}

void RB::Stroke::FixedWidthLineBounds::quadto(float32x2_t *a1, float64x2_t a2, float64x2_t a3, double a4, double a5, int32x4_t a6, int32x4_t a7, int32x4_t a8, int32x4_t a9)
{
}

void *RB::vector<float,16ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 10) + (*((void *)__dst + 10) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 10) + (*((void *)__dst + 10) >> 1);
  }
  __n128 result = RB::details::realloc_vector<unsigned long,4ul>(*((void **)__dst + 8), __dst, 0x10uLL, (size_t *)__dst + 10, v3);
  *((void *)__dst + 8) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,4ul>(void *__src, void *__dst, size_t a3, size_t *a4, size_t a5)
{
  int64x2_t v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      size_t v9 = a3;
      memcpy(__dst, __src, 4 * a5);
      free(v7);
      int v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(4 * a5);
    size_t v9 = v8 >> 2;
    if (v8 >> 2 != *a4)
    {
      float v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10) {
        RB::precondition_failure((RB *)"allocation failure", v11);
      }
      int v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, 4 * *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Path,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_214149AA8(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Path *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Path>,std::allocator<RB::XML::Value::Path>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Path *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Path>,std::allocator<RB::XML::Value::Path>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Transform,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_214149B98(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Transform *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Transform>,std::allocator<RB::XML::Value::Transform>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Transform *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Transform>,std::allocator<RB::XML::Value::Transform>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Float,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_214149C88(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Float *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Float>,std::allocator<RB::XML::Value::Float>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Float *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Float>,std::allocator<RB::XML::Value::Float>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::LineCap,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_214149D78(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::LineCap *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::LineCap>,std::allocator<RB::XML::Value::LineCap>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::LineCap *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::LineCap>,std::allocator<RB::XML::Value::LineCap>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::LineJoin,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_214149E68(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::LineJoin *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::LineJoin>,std::allocator<RB::XML::Value::LineJoin>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::LineJoin *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::LineJoin>,std::allocator<RB::XML::Value::LineJoin>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void RB::DisplayList::interpolated_bounds(RB::DisplayList *this, const RB::DisplayList::Interpolator::Layer *a2, float a3, uint64_t a4, const RB::DisplayList::Contents *a5, const RB::DisplayList::Contents *a6)
{
  if (RB::DisplayList::Interpolator::Layer::is_fade(this))
  {
    float32x2_t v18 = 0;
    uint64_t v19 = 0;
    double v20 = 0.0;
    if (a4)
    {
      double v20 = COERCE_DOUBLE(RB::DisplayList::Layer::bounds((RB::DisplayList::Layer *)(a4 + 320), v12, v13));
      uint64_t v19 = v13.i64[0];
    }
    float32x2_t v21 = 0;
    if (a5)
    {
      float32x2_t v21 = RB::DisplayList::Layer::bounds((const RB::DisplayList::Contents *)((char *)a5 + 320), 0.0, v13);
      float32x2_t v18 = *(float32x2_t *)v13.i8;
    }
    v24[0] = v21;
    v24[1] = v18;
    v13.i64[0] = v19;
    RB::Rect::Union(v24, v20, v13, v14, v15, v16, v17);
    return;
  }
  if (!a4)
  {
    CGPathRef v22 = 0;
    if (a5) {
      goto LABEL_9;
    }
LABEL_11:
    long long v23 = 0;
    goto LABEL_12;
  }
  CGPathRef v22 = *(RB::DisplayList::Item **)(a4 + 320);
  if (!a5) {
    goto LABEL_11;
  }
LABEL_9:
  long long v23 = (const RB::DisplayList::Item *)*((void *)a5 + 40);
LABEL_12:
  RB::DisplayList::interpolated_bounds(this, a2, a3, v22, v23, v11);
}

void RB::DisplayList::interpolated_bounds(RB::DisplayList *this, const RB::DisplayList::Interpolator::Layer *a2, float a3, RB::DisplayList::Item *a4, const RB::DisplayList::Item *a5, const RB::DisplayList::Item *a6)
{
  int v8 = (int)a2;
  v223[14] = *MEMORY[0x263EF8340];
  v130[0] = 0;
  v130[1] = 0;
  if (RB::DisplayList::Interpolator::Layer::is_fade(this))
  {
    for (; *(double *)&a4 != 0.0; a4 = *((RB::DisplayList::Item **)a4 + 1))
    {
      *(float32x2_t *)&double v13 = RB::DisplayList::Item::styled_bounds(a4, 0);
      RB::Rect::Union(v130, v13, v14, v15, v16, v17, v18);
    }
    while (a5)
    {
      *(float32x2_t *)&double v19 = RB::DisplayList::Item::styled_bounds(a5, 0);
      RB::Rect::Union(v130, v19, v20, v21, v22, v23, v24);
      a5 = (const RB::DisplayList::Item *)*((void *)a5 + 1);
    }
  }
  else if (*((unsigned char *)this + 248))
  {
    RB::DisplayList::Builder::Builder((RB::DisplayList::Builder *)&v174);
    if (*((unsigned char *)this + 248))
    {
      size_t v204 = 0;
      v203 = 0;
      unint64_t v205 = 32;
      size_t v198 = 0;
      v197 = 0;
      unint64_t v199 = 32;
      if (*(double *)&a4 != 0.0)
      {
        size_t v26 = 0;
        long long v27 = a4;
        do
        {
          size_t v28 = v26 + 1;
          if (v205 < v26 + 1)
          {
            RB::vector<RB::DisplayList::Item const*,32ul,unsigned long>::reserve_slow(__dst, v28);
            size_t v26 = v204;
            size_t v28 = v204 + 1;
          }
          uint64_t v29 = v203;
          if (!v203) {
            uint64_t v29 = __dst;
          }
          v29[v26] = v27;
          size_t v204 = v28;
          long long v27 = (RB::DisplayList::Item *)*((void *)v27 + 1);
          size_t v26 = v28;
        }
        while (v27);
      }
      if (a5)
      {
        size_t v30 = v198;
        uint64_t v31 = a5;
        do
        {
          size_t v32 = v30 + 1;
          if (v199 < v30 + 1)
          {
            RB::vector<RB::DisplayList::Item const*,32ul,unsigned long>::reserve_slow(v190, v32);
            size_t v30 = v198;
            size_t v32 = v198 + 1;
          }
          char v33 = v197;
          if (!v197) {
            char v33 = v190;
          }
          v33[v30] = v31;
          size_t v198 = v32;
          uint64_t v31 = (const RB::DisplayList::Item *)*((void *)v31 + 1);
          size_t v30 = v32;
        }
        while (v31);
      }
      v154[0] = (float32x2_t)a4;
      v154[1] = 0;
      uint64_t v157 = 1;
      uint64_t v158 = 1;
      uint64_t v159 = 0;
      uint64_t v160 = 1;
      uint64_t v161 = 1;
      uint64_t v162 = 0;
      uint64_t v163 = 0;
      uint64_t v164 = 0;
      char v165 = 0;
      uint64_t v166 = 0;
      uint64_t v167 = 0;
      __int16 v168 = 256;
      if (*(double *)&a4 == 0.0) {
        int v34 = 0;
      }
      else {
        int v34 = (*(uint64_t (**)(RB::DisplayList::Item *))(*(void *)a4 + 40))(a4);
      }
      BOOL v156 = v34 != -1;
      if (v34 == -1) {
        int v38 = 1;
      }
      else {
        int v38 = v34;
      }
      int v155 = v38;
      v139[0] = (float32x2_t)a5;
      v139[1] = 0;
      uint64_t v142 = 1;
      uint64_t v143 = 1;
      uint64_t v144 = 0;
      uint64_t v145 = 1;
      uint64_t v146 = 1;
      uint64_t v147 = 0;
      uint64_t v148 = 0;
      uint64_t v149 = 0;
      char v150 = 0;
      uint64_t v151 = 0;
      uint64_t v152 = 0;
      __int16 v153 = 256;
      if (a5) {
        int v39 = (*(uint64_t (**)(const RB::DisplayList::Item *))(*(void *)a5 + 40))(a5);
      }
      else {
        int v39 = 0;
      }
      BOOL v141 = v39 != -1;
      if (v39 == -1) {
        int v40 = 1;
      }
      else {
        int v40 = v39;
      }
      int v140 = v40;
      if (*((void *)this + 22)) {
        float64x2_t v41 = (char *)*((void *)this + 22);
      }
      else {
        float64x2_t v41 = (char *)this + 16;
      }
      int v42 = *((_DWORD *)this + 46);
      if (v42)
      {
        uint64_t v43 = &v41[40 * v42];
        HIDWORD(v44) = 0;
        do
        {
          uint64_t v45 = *(void *)v41 & 0xFLL;
          if (v45 == 1 || v45 == 8)
          {
            uint64_t v47 = *(void *)v41 & 0xFLL;
          }
          else
          {
            size_t v51 = *((unsigned int *)v41 + 2);
            uint64_t v47 = *(void *)v41 & 0xFLL;
            if (v204 > v51)
            {
              char v52 = v203;
              if (!v203) {
                char v52 = __dst;
              }
              if (v45 == 9)
              {
                int v53 = 0;
              }
              else if (*((_DWORD *)v41 + 3) == -1)
              {
                int v53 = 0;
              }
              else
              {
                int v53 = *((_DWORD *)v41 + 3);
              }
              RB::DisplayList::AtomizedItems::reset((uint64_t)v154, (const RB::DisplayList::Item *)v52[v51], v51, v53);
              uint64_t v47 = *(void *)v41 & 0xFLL;
            }
          }
          if (v47)
          {
            size_t v48 = *((unsigned int *)v41 + 4);
            if (v198 > v48)
            {
              int32x2_t v49 = v197;
              if (!v197) {
                int32x2_t v49 = v190;
              }
              if (v45 == 9)
              {
                int v50 = 0;
              }
              else if (*((_DWORD *)v41 + 5) == -1)
              {
                int v50 = 0;
              }
              else
              {
                int v50 = *((_DWORD *)v41 + 5);
              }
              RB::DisplayList::AtomizedItems::reset((uint64_t)v139, (const RB::DisplayList::Item *)v49[v48], v48, v50);
            }
          }
          long long v131 = *(RB::DisplayList::Interpolator::Contents **)this;
          long long v132 = v41;
          float v133 = a3;
          float v134 = a3;
          int v135 = 2139095040;
          char v136 = v8;
          char v137 = 0;
          uint64_t v138 = 0;
          *(float *)&double v44 = a3 - *((float *)v41 + 9);
          RB::DisplayList::Interpolator::Contents::animation_time(v131, *((_DWORD *)v41 + 8), 0, v44, *(double *)v25.i64);
          *(float *)v25.i32 = 1.0 - *(float *)&v44;
          if (v8) {
            *(float *)&double v44 = 1.0 - *(float *)&v44;
          }
          float v58 = fmaxf(*(float *)&v44, 0.0);
          float v133 = v58;
          float64x2_t v59 = v132;
          switch(*(_DWORD *)v132 & 0xF)
          {
            case 0:
              RB::DisplayList::AtomizedItems::effect_bounds((RB::DisplayList::AtomizedItems *)v154, this, (const RB::DisplayList::Interpolator::State *)&v131, 2u);
              goto LABEL_80;
            case 1:
            case 8:
              RB::DisplayList::AtomizedItems::effect_bounds((RB::DisplayList::AtomizedItems *)v139, this, (const RB::DisplayList::Interpolator::State *)&v131, 1u);
              goto LABEL_80;
            case 2:
            case 6:
              if (v58 > 1.0) {
                goto LABEL_77;
              }
              RB::DisplayList::AtomizedItems::atom_bounds((RB::DisplayList::AtomizedItems *)v154, *(void *)v132 >> 36);
              double v206 = v73;
              uint64_t v207 = v74;
              RB::DisplayList::AtomizedItems::atom_bounds((RB::DisplayList::AtomizedItems *)v139, *(void *)v132 >> 36);
              *(void *)&v169[0] = v75;
              *((void *)&v169[0] + 1) = v76;
              double v172 = 0.0;
              float32x2_t v173 = 0;
              if (!(*(unsigned int (**)(void, RB::DisplayList::Interpolator::Contents **, double *, long long *, void))(**(void **)v154 + 224))(*(void *)v154, &v131, &v206, v169, *(void *)v139))goto LABEL_77; {
              if (RB::DisplayList::AtomizedItems::mix_clip_bounds(v154, (const RB::DisplayList::Interpolator::State *)&v131, (RB::Rect *)&v172, (float32x2_t **)v139))
              }
              {
                RB::Rect::intersect((float32x2_t *)&v206, v172, v173, v77, v78, v79, v80);
                v81.i64[0] = v207;
                RB::Rect::Union(v130, v206, v81, v82, v83, v84, v85);
              }
              else
              {
LABEL_77:
                if (!v175) {
                  RB::DisplayList::Builder::reset_contents((RB::DisplayList::Builder *)&v174);
                }
                v169[0] = xmmword_2142181C0;
                v169[1] = xmmword_2142181D0;
                uint64_t v170 = 0;
                uint64_t v171 = 0;
                RB::DisplayList::CachedTransform::CachedTransform((uint64_t)&v206, (uint64_t)&v174, v169, 0, 0, 0);
                unint64_t v86 = (RB::DisplayList::Item *)RB::DisplayList::AtomizedItems::mix((RB::DisplayList::AtomizedItems *)v154, (const RB::DisplayList::Interpolator::State *)&v131, (const RB::DisplayList::AtomizedItems *)v139, (RB::DisplayList::CachedTransform *)&v206);
                unint64_t v87 = RB::DisplayList::AtomizedItems::mix_clip_style((RB::DisplayList::AtomizedItems *)v154, (const RB::DisplayList::Interpolator::State *)&v131, (const RB::DisplayList::AtomizedItems *)v139, (RB::DisplayList::CachedTransform *)&v206);
                *((void *)v86 + 2) = v88;
                *((void *)v86 + 3) = v87;
                *(float32x2_t *)&double v89 = RB::DisplayList::Item::styled_bounds(v86, 0);
                RB::Rect::Union(v130, v89, v90, v91, v92, v93, v94);
                (**(void (***)(RB::DisplayList::Item *))v86)(v86);
                RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v223);
                RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v222);
                RB::Heap::~Heap((RB::Heap *)&v207);
              }
              break;
            case 3:
            case 7:
              long long v66 = RB::DisplayList::AtomizedItems::styled_bounds(v154);
              *(float32x2_t *)v67.i8 = v66[1];
              RB::Rect::Union(v130, *(double *)v66, v67, v68, v69, v70, v71);
              unint64_t v72 = RB::DisplayList::AtomizedItems::styled_bounds(v139);
              goto LABEL_76;
            case 4:
            case 5:
              unint64_t v72 = RB::DisplayList::AtomizedItems::styled_bounds(v139);
LABEL_76:
              double v60 = *(double *)v72;
              *(float32x2_t *)v61.i8 = v72[1];
LABEL_80:
              RB::Rect::Union(v130, v60, v61, v62, v63, v64, v65);
              break;
            case 9:
              uint64_t v207 = 0;
              double v206 = 0.0;
              if (*((_DWORD *)v132 + 3))
              {
                unsigned int v95 = 0;
                do
                {
                  unsigned int v96 = v95 + *((_DWORD *)v59 + 2);
                  uint64_t v97 = v203;
                  if (!v203) {
                    uint64_t v97 = __dst;
                  }
                  *(float32x2_t *)&double v98 = RB::DisplayList::Item::styled_bounds((RB::DisplayList::Item *)v97[v96], 0);
                  RB::Rect::Union((float32x2_t *)&v206, v98, v99, v100, v101, v102, v103);
                  ++v95;
                  float64x2_t v59 = v132;
                }
                while (v95 < *((_DWORD *)v132 + 3));
              }
              if (*((_DWORD *)v59 + 5))
              {
                unsigned int v104 = 0;
                do
                {
                  unsigned int v105 = v104 + *((_DWORD *)v59 + 4);
                  uint64_t v106 = v197;
                  if (!v197) {
                    uint64_t v106 = v190;
                  }
                  *(float32x2_t *)&double v107 = RB::DisplayList::Item::styled_bounds((RB::DisplayList::Item *)v106[v105], 0);
                  RB::Rect::Union((float32x2_t *)&v206, v107, v108, v109, v110, v111, v112);
                  ++v104;
                  float64x2_t v59 = v132;
                }
                while (v104 < *((_DWORD *)v132 + 5));
              }
              v25.i64[0] = v207;
              RB::Rect::Union(v130, v206, v25, v54, v55, v56, v57);
              break;
            default:
              break;
          }
          v41 += 40;
        }
        while (v41 != v43);
      }
      if (v197) {
        free(v197);
      }
      if (v203) {
        free(v203);
      }
    }
    RB::DisplayList::Builder::~Builder((RB::DisplayList::Builder *)&v174);
  }
  else
  {
    __dst[3] = 0x100000000;
    std::string __dst[2] = 0;
    int v202 = 0;
    uint64_t v35 = *(RB::DisplayList::Interpolator::Contents **)this;
    int v201 = *(_DWORD *)(*(void *)this + 16);
    __dst[1] = 0;
    __dst[0] = 0xFFFFFFF100000000;
    *(float *)&double v11 = a3;
    RB::DisplayList::Interpolator::Contents::animation_time(v35, v201, 0, v11, v12);
    v190[0] = *(void *)this;
    v190[1] = __dst;
    if (v8) {
      float v36 = 1.0 - v36;
    }
    float v191 = v36;
    float v192 = a3;
    int v193 = 2139095040;
    char v194 = v8;
    char v195 = 0;
    uint64_t v196 = 0;
    double v206 = *(double *)&a4;
    uint64_t v207 = 0;
    uint64_t v210 = 1;
    uint64_t v211 = 1;
    uint64_t v212 = 0;
    uint64_t v213 = 1;
    uint64_t v214 = 1;
    uint64_t v215 = 0;
    uint64_t v217 = 0;
    uint64_t v216 = 0;
    char v218 = 0;
    uint64_t v220 = 0;
    uint64_t v219 = 0;
    __int16 v221 = 256;
    if (*(double *)&a4 == 0.0) {
      int v37 = 0;
    }
    else {
      int v37 = (*(uint64_t (**)(RB::DisplayList::Item *))(*(void *)a4 + 40))(a4);
    }
    BOOL v209 = v37 != -1;
    if (v37 == -1) {
      int v113 = 1;
    }
    else {
      int v113 = v37;
    }
    unsigned int v208 = v113;
    if (v113)
    {
      do
      {
        long long v114 = RB::DisplayList::AtomizedItems::transition((RB::DisplayList::AtomizedItems *)&v206, this);
        if (!RB::Transition::empty_transition(v114, 2))
        {
          RB::DisplayList::AtomizedItems::effect_bounds((RB::DisplayList::AtomizedItems *)&v206, this, (const RB::DisplayList::Interpolator::State *)v190, 2u);
          RB::Rect::Union(v130, v115, v116, v117, v118, v119, v120);
        }
        RB::DisplayList::AtomizedItems::advance(&v206, 1);
      }
      while (HIDWORD(v207) < v208);
    }
    uint64_t v174 = a5;
    uint64_t v175 = 0;
    uint64_t v178 = 1;
    uint64_t v179 = 1;
    uint64_t v180 = 0;
    uint64_t v181 = 1;
    uint64_t v182 = 1;
    uint64_t v183 = 0;
    uint64_t v184 = 0;
    uint64_t v185 = 0;
    char v186 = 0;
    uint64_t v188 = 0;
    uint64_t v187 = 0;
    __int16 v189 = 256;
    if (a5) {
      int v121 = (*(uint64_t (**)(const RB::DisplayList::Item *))(*(void *)a5 + 40))(a5);
    }
    else {
      int v121 = 0;
    }
    BOOL v177 = v121 != -1;
    if (v121 == -1) {
      int v122 = 1;
    }
    else {
      int v122 = v121;
    }
    unsigned int v176 = v122;
    if (v122)
    {
      do
      {
        __dst[0] = __dst[0] & 0xFFFFFFFFFFFFFFF0 | 1;
        long long v123 = RB::DisplayList::AtomizedItems::transition((RB::DisplayList::AtomizedItems *)&v174, this);
        if (RB::Transition::empty_transition(v123, 1)) {
          __dst[0] = __dst[0] & 0xFFFFFFFFFFFFFFF0 | 8;
        }
        RB::DisplayList::AtomizedItems::effect_bounds((RB::DisplayList::AtomizedItems *)&v174, this, (const RB::DisplayList::Interpolator::State *)v190, 1u);
        RB::Rect::Union(v130, v124, v125, v126, v127, v128, v129);
        RB::DisplayList::AtomizedItems::advance(&v174, 1);
      }
      while (HIDWORD(v175) < v176);
    }
  }
}

void sub_21414A918(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
  if (STACK[0x3C0]) {
    free((void *)STACK[0x3C0]);
  }
  if (STACK[0x4D8]) {
    free((void *)STACK[0x4D8]);
  }
  RB::DisplayList::Builder::~Builder((RB::DisplayList::Builder *)&a61);
  _Unwind_Resume(a1);
}

void RB::DisplayList::apply_interpolator(RB::DisplayList *this, const RB::DisplayList::Interpolator::Layer *x1_0, double a3, unsigned int a4, RB::DisplayList::Layer *a5, float64x2_t *a6, double a7, float32x2_t *a8, const RB::Rect *a9, const RB::DisplayList::Item *a10, const RB::DisplayList::Item *a11, const RB::AffineTransform *a12)
{
  int v14 = (int)x1_0;
  float v15 = *(float *)&a3;
  double v110 = a11;
  uint64_t v204 = *MEMORY[0x263EF8340];
  double v17 = *(RB::DisplayList::Builder **)&a6->f64[0];
  int v113 = a5;
  long long v114 = v17;
  float v115 = *(float *)&a7;
  v112[0] = this;
  v112[1] = a8;
  v112[2] = &v113;
  v112[3] = a6;
  double v111 = &v113;
  if (*((unsigned char *)this + 248) && *((_DWORD *)this + 46))
  {
    if (a8)
    {
      MEMORY[0x270FA5388](this, x1_0);
      int32x4_t v20 = (float32x2_t *)v107;
      *(float32x2_t *)v21.i8 = a8[1];
      *(float32x2_t *)&a3 = RB::operator*(a6 + 68, *a8, v21);
      *(double *)double v107 = a3;
      *(double *)&v107[1] = a7;
      if (!*((unsigned char *)this + 248)) {
        return;
      }
    }
    else
    {
      int32x4_t v20 = 0;
    }
    int32x4_t v108 = a8;
    double v109 = v20;
    size_t v202 = 0;
    int v201 = 0;
    unint64_t v203 = 32;
    size_t v183 = 0;
    uint64_t v182 = 0;
    unint64_t v184 = 32;
    if (a9)
    {
      size_t v29 = 0;
      size_t v30 = a9;
      do
      {
        size_t v31 = v29 + 1;
        if (v203 < v29 + 1)
        {
          RB::vector<RB::DisplayList::Item const*,32ul,unsigned long>::reserve_slow(&v185, v31);
          size_t v29 = v202;
          size_t v31 = v202 + 1;
        }
        size_t v32 = v201;
        if (!v201) {
          size_t v32 = &v185;
        }
        v32[v29] = v30;
        size_t v202 = v31;
        size_t v30 = (const RB::Rect *)*((void *)v30 + 1);
        size_t v29 = v31;
      }
      while (v30);
    }
    if (a10)
    {
      size_t v33 = v183;
      int v34 = a10;
      do
      {
        size_t v35 = v33 + 1;
        if (v184 < v33 + 1)
        {
          RB::vector<RB::DisplayList::Item const*,32ul,unsigned long>::reserve_slow(&v166, v35);
          size_t v33 = v183;
          size_t v35 = v183 + 1;
        }
        float v36 = v182;
        if (!v182) {
          float v36 = &v166;
        }
        v36[v33] = v34;
        size_t v183 = v35;
        int v34 = (const RB::DisplayList::Item *)*((void *)v34 + 1);
        size_t v33 = v35;
      }
      while (v34);
    }
    int v140 = a9;
    uint64_t v141 = 0;
    uint64_t v143 = 1;
    uint64_t v144 = 1;
    uint64_t v145 = 0;
    uint64_t v146 = 1;
    uint64_t v147 = 1;
    uint64_t v148 = 0;
    uint64_t v149 = 0;
    uint64_t v150 = 0;
    char v151 = 0;
    uint64_t v152 = 0;
    uint64_t v153 = 0;
    __int16 v154 = 256;
    if (a9) {
      int v37 = (*(uint64_t (**)(const RB::Rect *))(*(void *)a9 + 40))(a9);
    }
    else {
      int v37 = 0;
    }
    BYTE4(v142) = v37 != -1;
    if (v37 == -1) {
      int v38 = 1;
    }
    else {
      int v38 = v37;
    }
    LODWORD(v142) = v38;
    double v124 = a10;
    int32x4_t v125 = 0;
    uint64_t v128 = 1;
    uint64_t v129 = 1;
    uint64_t v130 = 0;
    uint64_t v131 = 1;
    uint64_t v132 = 1;
    uint64_t v133 = 0;
    uint64_t v134 = 0;
    uint64_t v135 = 0;
    char v136 = 0;
    uint64_t v137 = 0;
    uint64_t v138 = 0;
    __int16 v139 = 256;
    if (a10) {
      int v39 = (*(uint64_t (**)(const RB::DisplayList::Item *))(*(void *)a10 + 40))(a10);
    }
    else {
      int v39 = 0;
    }
    LOBYTE(v127) = v39 != -1;
    if (v39 == -1) {
      int v40 = 1;
    }
    else {
      int v40 = v39;
    }
    float v126 = *(float *)&v40;
    if (*((void *)this + 22)) {
      float64x2_t v41 = (char *)*((void *)this + 22);
    }
    else {
      float64x2_t v41 = (char *)this + 16;
    }
    uint64_t v42 = *((unsigned int *)this + 46);
    if (v42)
    {
      uint64_t v43 = 40 * v42;
      while (2)
      {
        uint64_t v44 = *(void *)v41 & 0xFLL;
        if (v44 == 1 || v44 == 8)
        {
          uint64_t v46 = *(void *)v41 & 0xFLL;
        }
        else
        {
          size_t v50 = *((unsigned int *)v41 + 2);
          uint64_t v46 = *(void *)v41 & 0xFLL;
          if (v202 > v50)
          {
            size_t v51 = v201;
            if (!v201) {
              size_t v51 = &v185;
            }
            if (v44 == 9)
            {
              int v52 = 0;
            }
            else if (*((_DWORD *)v41 + 3) == -1)
            {
              int v52 = 0;
            }
            else
            {
              int v52 = *((_DWORD *)v41 + 3);
            }
            RB::DisplayList::AtomizedItems::reset((uint64_t)&v140, v51[v50], v50, v52);
            uint64_t v46 = *(void *)v41 & 0xFLL;
          }
        }
        if (v46)
        {
          size_t v47 = *((unsigned int *)v41 + 4);
          if (v183 > v47)
          {
            size_t v48 = v182;
            if (!v182) {
              size_t v48 = &v166;
            }
            if (v44 == 9)
            {
              int v49 = 0;
            }
            else if (*((_DWORD *)v41 + 5) == -1)
            {
              int v49 = 0;
            }
            else
            {
              int v49 = *((_DWORD *)v41 + 5);
            }
            RB::DisplayList::AtomizedItems::reset((uint64_t)&v124, v48[v47], v47, v49);
          }
        }
        int32x4_t v116 = *(RB::DisplayList::Interpolator::Contents **)this;
        double v117 = v41;
        float v118 = v15;
        float v119 = v15;
        int v120 = 2139095040;
        char v121 = v14;
        char v122 = 0;
        long long v123 = 0;
        *(float *)&a3 = v15 - *((float *)v41 + 9);
        RB::DisplayList::Interpolator::Contents::animation_time(v116, *((_DWORD *)v41 + 8), 0, a3, a7);
        *(float *)&a7 = 1.0 - *(float *)&a3;
        if (v14) {
          *(float *)&a3 = 1.0 - *(float *)&a3;
        }
        float v118 = fmaxf(*(float *)&a3, 0.0);
        long long v123 = v110;
        char v53 = 0;
        unsigned int v54 = 2;
        double v55 = &v140;
        switch(*(_DWORD *)v117 & 0xF)
        {
          case 0:
            goto LABEL_87;
          case 1:
          case 4:
          case 5:
          case 8:
            char v53 = (*(void *)v117 & 0xFLL) != 1;
            unsigned int v54 = 1;
            double v55 = &v124;
LABEL_87:
            RB::DisplayList::apply_interpolator(RB::DisplayList::Interpolator::Layer const&,float,BOOL,unsigned int,RB::DisplayList::Layer &,float,RB::DisplayList::CachedTransform &,RB::Rect const*,RB::DisplayList::Item const*,RB::DisplayList::Item const*,RB::AffineTransform const*)::$_1::operator()((uint64_t)v112, (float32x2_t *)v55, (uint64_t)&v116, v54, v53);
            goto LABEL_115;
          case 2:
          case 3:
            uint64_t v76 = RB::DisplayList::AtomizedItems::mix((RB::DisplayList::AtomizedItems *)&v140, (const RB::DisplayList::Interpolator::State *)&v116, (const RB::DisplayList::AtomizedItems *)&v124, (RB::DisplayList::CachedTransform *)a6);
            uint64_t v77 = v76;
            _S0 = v118;
            if (v118 < 0.0) {
              _S0 = 0.0;
            }
            if (_S0 > 1.0) {
              _S0 = 1.0;
            }
            __asm { FCVT            H0, S0 }
            *(short float *)(v76 + 44) = *((short float *)v140 + 22)
                                       + (short float)((short float)(*((short float *)v124 + 22)
                                                                   - *((short float *)v140 + 22))
                                                     * _H0);
            double v83 = RB::DisplayList::AtomizedItems::mix_clip_style((RB::DisplayList::AtomizedItems *)&v140, (const RB::DisplayList::Interpolator::State *)&v116, (const RB::DisplayList::AtomizedItems *)&v124, (RB::DisplayList::CachedTransform *)a6);
            *(void *)(v77 + 16) = v84;
            *(void *)(v77 + 24) = v83;
            *(void *)(v77 + 32) = RB::DisplayList::CachedTransform::transform_metadata((RB::DisplayList::CachedTransform *)a6, *((const RB::DisplayList::Metadata **)v124 + 4), *((_DWORD *)v124 + 10));
            *(_DWORD *)(v77 + 40) = v85;
            if (v109
              && (float32x2_t v86 = RB::DisplayList::Item::styled_bounds((RB::DisplayList::Item *)v77, 0),
                  !RB::Rect::intersects(v109, v207, v86, v87, v88, v89, v90, v91)))
            {
              (**(void (***)(uint64_t))v77)(v77);
            }
            else
            {
              RB::DisplayList::Item::apply_alpha(v77, v115);
              RB::DisplayList::Builder::draw(v114, (RB::DisplayList::Item *)v77, v113, 0);
            }
            goto LABEL_115;
          case 6:
          case 7:
            double v56 = RB::DisplayList::AtomizedItems::mix_clip_style((RB::DisplayList::AtomizedItems *)&v140, (const RB::DisplayList::Interpolator::State *)&v116, (const RB::DisplayList::AtomizedItems *)&v124, (RB::DisplayList::CachedTransform *)a6);
            uint64_t v58 = v57;
            uint64_t v59 = RB::DisplayList::AtomizedItems::mix((RB::DisplayList::AtomizedItems *)&v140, (const RB::DisplayList::Interpolator::State *)&v116, (const RB::DisplayList::AtomizedItems *)&v124, (RB::DisplayList::CachedTransform *)a6);
            *(void *)(v59 + 16) = v58;
            *(void *)(v59 + 24) = v56;
            *(void *)(v59 + 32) = RB::DisplayList::CachedTransform::transform_metadata((RB::DisplayList::CachedTransform *)a6, *(const RB::DisplayList::Metadata **)(v59 + 32), *(_DWORD *)(v59 + 40));
            *(_DWORD *)(v59 + 40) = v60;
            if (v109)
            {
              float32x2_t v61 = RB::DisplayList::Item::styled_bounds((RB::DisplayList::Item *)v59, 0);
              if ((RB::Rect::intersects(v109, v205, v61, v62, v63, v64, v65, v66) & 1) == 0)
              {
                (**(void (***)(uint64_t))v59)(v59);
                uint64_t v59 = 0;
              }
            }
            int32x4_t v67 = (RB::DisplayList::Builder **)(*(void *)v117 & 0xFFFFFFF00000000FLL);
            int8x16_t v163 = vextq_s8(*(int8x16_t *)(v117 + 8), *(int8x16_t *)(v117 + 8), 8uLL);
            uint64_t v164 = 0x100000000;
            uint64_t v165 = 0;
            v155[0] = v116;
            v155[1] = &v162;
            int v158 = 2139095040;
            char v160 = 0;
            uint64_t v161 = v123;
            uint64_t v162 = v67;
            float v157 = v119;
            float v156 = 1.0 - v118;
            char v159 = v121 ^ 1;
            uint64_t v68 = RB::DisplayList::AtomizedItems::mix((RB::DisplayList::AtomizedItems *)&v124, (const RB::DisplayList::Interpolator::State *)v155, (const RB::DisplayList::AtomizedItems *)&v140, (RB::DisplayList::CachedTransform *)a6);
            *(void *)(v68 + 16) = v58;
            *(void *)(v68 + 24) = v56;
            *(void *)(v68 + 32) = RB::DisplayList::CachedTransform::transform_metadata((RB::DisplayList::CachedTransform *)a6, *(const RB::DisplayList::Metadata **)(v68 + 32), *(_DWORD *)(v68 + 40));
            *(_DWORD *)(v68 + 40) = v69;
            if (v109)
            {
              float32x2_t v70 = RB::DisplayList::Item::styled_bounds((RB::DisplayList::Item *)v68, 0);
              if ((RB::Rect::intersects(v109, v206, v70, v71, v72, v73, v74, v75) & 1) == 0)
              {
                (**(void (***)(uint64_t))v68)(v68);
                uint64_t v68 = 0;
              }
            }
            RB::DisplayList::apply_interpolator(RB::DisplayList::Interpolator::Layer const&,float,BOOL,unsigned int,RB::DisplayList::Layer &,float,RB::DisplayList::CachedTransform &,RB::Rect const*,RB::DisplayList::Item const*,RB::DisplayList::Item const*,RB::AffineTransform const*)::$_2::operator()((RB::DisplayList::Builder *)&v111, (uint64_t)&v116, (RB::DisplayList::Item *)v59, (RB::DisplayList::Item *)v68, *(void *)&a6->f64[0]);
            goto LABEL_115;
          case 9:
            unsigned int v92 = *((_DWORD *)v117 + 3);
            if (v92 != 1 || *((_DWORD *)v117 + 5) != 1)
            {
              uint64_t v162 = (RB::DisplayList::Builder **)a6;
              v163.i64[0] = (uint64_t)v108;
              _ZZZN2RB11DisplayList18apply_interpolatorERKNS0_12Interpolator5LayerEfbjRNS0_5LayerEfRNS0_15CachedTransformEPKNS_4RectEPKNS0_4ItemESE_PKNS_15AffineTransformEENK3__3clINS_6vectorISE_Lm32EmEESL_EEDaRNS1_5StateERNS0_13AtomizedItemsESQ_RKT_RKT0_ENKUljjST_E_clISL_EESM_jjST_(&v162, *((_DWORD *)v117 + 2), v92, (uint64_t)&v185);
              double v98 = v99;
              _ZZZN2RB11DisplayList18apply_interpolatorERKNS0_12Interpolator5LayerEfbjRNS0_5LayerEfRNS0_15CachedTransformEPKNS_4RectEPKNS0_4ItemESE_PKNS_15AffineTransformEENK3__3clINS_6vectorISE_Lm32EmEESL_EEDaRNS1_5StateERNS0_13AtomizedItemsESQ_RKT_RKT0_ENKUljjST_E_clISL_EESM_jjST_(&v162, *((_DWORD *)v117 + 4), *((_DWORD *)v117 + 5), (uint64_t)&v166);
              double v101 = v100;
              goto LABEL_113;
            }
            if (v108
              && (double v93 = RB::DisplayList::AtomizedItems::styled_bounds((float32x2_t *)&v140),
                  !RB::Rect::intersects(v108, v208, *v93, v93[1], v94, v95, v96, v97)))
            {
              double v98 = 0;
            }
            else
            {
              double v98 = (RB::DisplayList::Item *)RB::DisplayList::AtomizedItems::copy((RB::DisplayList::AtomizedItems *)&v140, *(RB::DisplayList::Builder **)&a6->f64[0], (v142 - HIDWORD(v141)), 4);
              (*(void (**)(RB::DisplayList::Item *, float64x2_t *, uint64_t))(*(void *)v98 + 32))(v98, a6, 1);
              if (!v108) {
                goto LABEL_119;
              }
            }
            double v102 = RB::DisplayList::AtomizedItems::styled_bounds((float32x2_t *)&v124);
            if (RB::Rect::intersects(v108, v209, *v102, v102[1], v103, v104, v105, v106))
            {
LABEL_119:
              double v101 = (RB::DisplayList::Item *)RB::DisplayList::AtomizedItems::copy((RB::DisplayList::AtomizedItems *)&v124, *(RB::DisplayList::Builder **)&a6->f64[0], (LODWORD(v126) - HIDWORD(v125)), 4);
              (*(void (**)(RB::DisplayList::Item *, float64x2_t *, uint64_t))(*(void *)v101 + 32))(v101, a6, 1);
              goto LABEL_113;
            }
            double v101 = 0;
LABEL_113:
            RB::DisplayList::apply_interpolator(RB::DisplayList::Interpolator::Layer const&,float,BOOL,unsigned int,RB::DisplayList::Layer &,float,RB::DisplayList::CachedTransform &,RB::Rect const*,RB::DisplayList::Item const*,RB::DisplayList::Item const*,RB::AffineTransform const*)::$_2::operator()((RB::DisplayList::Builder *)&v111, (uint64_t)&v116, v98, v101, *(void *)&a6->f64[0]);
LABEL_115:
            v41 += 40;
            v43 -= 40;
            if (!v43) {
              break;
            }
            continue;
          default:
            goto LABEL_115;
        }
        break;
      }
    }
    if (v182) {
      free(v182);
    }
    if (v201) {
      free(v201);
    }
  }
  else
  {
    uint64_t v142 = 0;
    uint64_t v143 = 0x100000000;
    uint64_t v144 = a4;
    int v140 = (const RB::Rect *)0xFFFFFFF100000000;
    uint64_t v141 = 0;
    RB::DisplayList::Interpolator::Contents::animation_time(*(RB::DisplayList::Interpolator::Contents **)this, a4, 0, a3, a7);
    double v124 = *(const RB::DisplayList::Item **)this;
    int32x4_t v125 = &v140;
    if (v14) {
      float v22 = 1.0 - v22;
    }
    float v126 = v22;
    float v127 = v15;
    LODWORD(v128) = 2139095040;
    WORD2(v128) = v14;
    uint64_t v129 = (uint64_t)v110;
    uint64_t v185 = a9;
    uint64_t v186 = 0;
    uint64_t v189 = 1;
    uint64_t v190 = 1;
    uint64_t v191 = 0;
    uint64_t v192 = 1;
    uint64_t v193 = 1;
    uint64_t v194 = 0;
    uint64_t v196 = 0;
    uint64_t v195 = 0;
    char v197 = 0;
    uint64_t v199 = 0;
    uint64_t v198 = 0;
    __int16 v200 = 256;
    if (a9) {
      int v23 = (*(uint64_t (**)(const RB::Rect *))(*(void *)a9 + 40))(a9);
    }
    else {
      int v23 = 0;
    }
    BOOL v188 = v23 != -1;
    if (v23 == -1) {
      int v24 = 1;
    }
    else {
      int v24 = v23;
    }
    unsigned int v187 = v24;
    if (v24)
    {
      do
      {
        int32x4_t v25 = RB::DisplayList::AtomizedItems::transition((RB::DisplayList::AtomizedItems *)&v185, this);
        if (RB::Transition::empty_transition(v25, 2)) {
          RB::DisplayList::AtomizedItems::advance(&v185, 1);
        }
        else {
          RB::DisplayList::apply_interpolator(RB::DisplayList::Interpolator::Layer const&,float,BOOL,unsigned int,RB::DisplayList::Layer &,float,RB::DisplayList::CachedTransform &,RB::Rect const*,RB::DisplayList::Item const*,RB::DisplayList::Item const*,RB::AffineTransform const*)::$_1::operator()((uint64_t)v112, (float32x2_t *)&v185, (uint64_t)&v124, 2u, 0);
        }
      }
      while (HIDWORD(v186) < v187);
    }
    uint64_t v166 = a10;
    uint64_t v167 = 0;
    uint64_t v170 = 1;
    uint64_t v171 = 1;
    uint64_t v172 = 0;
    uint64_t v173 = 1;
    uint64_t v174 = 1;
    uint64_t v175 = 0;
    uint64_t v177 = 0;
    uint64_t v176 = 0;
    char v178 = 0;
    uint64_t v180 = 0;
    uint64_t v179 = 0;
    __int16 v181 = 256;
    if (a10) {
      int v26 = (*(uint64_t (**)(const RB::DisplayList::Item *))(*(void *)a10 + 40))(a10);
    }
    else {
      int v26 = 0;
    }
    BOOL v169 = v26 != -1;
    if (v26 == -1) {
      int v27 = 1;
    }
    else {
      int v27 = v26;
    }
    unsigned int v168 = v27;
    if (v27)
    {
      do
      {
        int v140 = (const RB::Rect *)((unint64_t)v140 & 0xFFFFFFFFFFFFFFF0 | 1);
        size_t v28 = RB::DisplayList::AtomizedItems::transition((RB::DisplayList::AtomizedItems *)&v166, this);
        if (RB::Transition::empty_transition(v28, 1)) {
          int v140 = (const RB::Rect *)((unint64_t)v140 & 0xFFFFFFFFFFFFFFF0 | 8);
        }
        RB::DisplayList::apply_interpolator(RB::DisplayList::Interpolator::Layer const&,float,BOOL,unsigned int,RB::DisplayList::Layer &,float,RB::DisplayList::CachedTransform &,RB::Rect const*,RB::DisplayList::Item const*,RB::DisplayList::Item const*,RB::AffineTransform const*)::$_1::operator()((uint64_t)v112, (float32x2_t *)&v166, (uint64_t)&v124, 1u, 0);
      }
      while (HIDWORD(v167) < v168);
    }
  }
}

void sub_21414B420(_Unwind_Exception *exception_object)
{
  size_t v3 = *(void **)(v1 + 704);
  if (v3) {
    free(v3);
  }
  char v4 = *(void **)(v1 + 984);
  if (v4) {
    free(v4);
  }
  _Unwind_Resume(exception_object);
}

_DWORD *RB::DisplayList::apply_interpolator(RB::DisplayList::Interpolator::Layer const&,float,BOOL,unsigned int,RB::DisplayList::Layer &,float,RB::DisplayList::CachedTransform &,RB::Rect const*,RB::DisplayList::Item const*,RB::DisplayList::Item const*,RB::AffineTransform const*)::$_1::operator()(uint64_t a1, float32x2_t *this, uint64_t a3, unsigned int a4, char a5)
{
  v43[14] = *MEMORY[0x263EF8340];
  uint64_t v10 = **(void **)(a3 + 8) >> 36;
  unsigned int v11 = this[2].i32[0] - this[1].i32[1];
  if (v11 >= v10) {
    uint64_t v12 = v10;
  }
  else {
    uint64_t v12 = v11;
  }
  double v13 = *(float32x2_t **)(a1 + 8);
  if (v13)
  {
    int v14 = RB::DisplayList::AtomizedItems::styled_bounds(this);
    int v19 = RB::Rect::intersects(v13, v44, *v14, v14[1], v15, v16, v17, v18);
    if (v19 & 1) != 0 || (a5)
    {
      if (!v19) {
        return RB::DisplayList::AtomizedItems::advance(this, v12);
      }
    }
    else if ((RB::DisplayList::AtomizedItems::effects_change_geometry((RB::DisplayList::AtomizedItems *)this, *(const RB::DisplayList::Interpolator::Layer **)a1, (const RB::DisplayList::Interpolator::State *)a3, a4) & 1) == 0)
    {
      return RB::DisplayList::AtomizedItems::advance(this, v12);
    }
  }
  uint64_t v20 = RB::DisplayList::AtomizedItems::copy((RB::DisplayList::AtomizedItems *)this, **(RB::DisplayList::Builder ***)(a1 + 24), v12, 4);
  if ((a5 & 1) == 0 && (*(_WORD *)(*(void *)this + 46) & 0x800) == 0)
  {
    if (RB::DisplayList::AtomizedItems::effects_change_geometry((RB::DisplayList::AtomizedItems *)this, *(const RB::DisplayList::Interpolator::Layer **)a1, (const RB::DisplayList::Interpolator::State *)a3, a4))
    {
      uint64_t v21 = *(void *)(a1 + 24);
      long long v22 = *(_OWORD *)(v21 + 1104);
      float64x2_t v39 = *(float64x2_t *)(v21 + 1088);
      long long v40 = v22;
      long long v41 = *(_OWORD *)(v21 + 1120);
      int v23 = *(float64x2_t **)(a3 + 32);
      if (v23)
      {
        v24.f64[0] = RB::operator*(&v39, v23);
        float64x2_t v39 = v24;
        long long v40 = v25;
        long long v41 = v26;
      }
      (*(void (**)(uint64_t, float64x2_t *))(*(void *)v20 + 128))(v20, &v39);
    }
    float64x2_t v33 = (float64x2_t)xmmword_2142181C0;
    float64x2_t v34 = (float64x2_t)xmmword_2142181D0;
    char v37 = 0;
    float64x2_t v35 = 0uLL;
    LOBYTE(v36) = 0;
    float v38 = 1.0;
    RB::DisplayList::AtomizedItems::apply_effects((uint64_t)this, *(const RB::DisplayList::Interpolator::Layer **)a1, a3, a4, (RB::DisplayList::Item *)v20, (uint64_t)&v33);
    RB::DisplayList::Item::apply_alpha(v20, v38);
    int64x2_t v27 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v34, (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(v33, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v35));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v27, 1), (int8x16_t)v27).u64[0] & 0x8000000000000000) == 0)
    {
      RB::DisplayList::CachedTransform::CachedTransform((uint64_t)&v39, **(void **)(a1 + 24), (long long *)&v33, 0, 0, 0);
      (*(void (**)(uint64_t, float64x2_t *, void))(*(void *)v20 + 32))(v20, &v39, 0);
      RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v43);
      RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v42);
      RB::Heap::~Heap((RB::Heap *)&v39.f64[1]);
    }
    if (v37)
    {
      float v28 = v36;
      if (v36 > 512.0) {
        float v28 = 512.0;
      }
      *(float *)v39.f64 = v28;
      unint64_t v29 = RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>,float &>((size_t *)(*(void *)(**(void **)(a1 + 24) + 8) + 16), (float *)&v39);
      *(void *)(v29 + 16) = RB::AffineTransform::identity((RB::AffineTransform *)v29);
      uint64_t v30 = *(void *)(**(void **)(a1 + 24) + 8);
      *(void *)(v29 + 8) = *(void *)(v30 + 312);
      *(void *)(v30 + 312) = v29;
      *(void *)(v29 + 32) = *(void *)(v20 + 16);
      *(_DWORD *)(v29 + 52) |= 1u;
      *(void *)(v20 + 16) = v29;
    }
  }
  if (v20)
  {
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)v20 + 32))(v20, *(void *)(a1 + 24), 1);
    if ((a4 & 2) != 0) {
      *(_WORD *)(v20 + 46) |= 0x800u;
    }
    uint64_t v31 = *(void *)(a1 + 16);
    RB::DisplayList::Item::apply_alpha(v20, *(float *)(v31 + 16));
    RB::DisplayList::Builder::draw(*(RB::DisplayList::Builder **)(v31 + 8), (RB::DisplayList::Item *)v20, *(RB::DisplayList::Layer **)v31, 0);
  }
  return RB::DisplayList::AtomizedItems::advance(this, v12);
}

void sub_21414B7F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  RB::DisplayList::CachedTransform::~CachedTransform((RB::DisplayList::CachedTransform *)va);
  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::Item::mix_bounds(RB::DisplayList::Item *this, const State *a2, float32x2_t *a3, float32x2_t *a4, const RB::DisplayList::Item *a5, double a6, int32x4_t a7)
{
  uint64_t v8 = *(void *)&a2->var0;
  *(float32x2_t *)a7.i8 = vadd_f32(a3[1], *a3);
  *(float32x2_t *)a7.i8 = vmla_n_f32(*(float32x2_t *)a7.i8, vadd_f32(vsub_f32(*a4, *(float32x2_t *)a7.i8), a4[1]), *(float *)&v8);
  *(double *)a3 = RB::Rect::from_bounds(vmla_n_f32(*a3, vsub_f32(*a4, *a3), *(float *)&v8), a7);
  a3[1] = v9;
  return 1;
}

uint64_t RB::DisplayList::Clip::mix_bounds(double a1, int32x4_t a2, uint64_t a3, uint64_t a4, float32x2_t *a5, float32x2_t *a6)
{
  uint64_t v7 = *(void *)(a4 + 16);
  *(float32x2_t *)a2.i8 = vadd_f32(a5[1], *a5);
  *(float32x2_t *)a2.i8 = vmla_n_f32(*(float32x2_t *)a2.i8, vadd_f32(vsub_f32(*a6, *(float32x2_t *)a2.i8), a6[1]), *(float *)&v7);
  *(double *)a5 = RB::Rect::from_bounds(vmla_n_f32(*a5, vsub_f32(*a6, *a5), *(float *)&v7), a2);
  a5[1] = v8;
  return 1;
}

uint64_t RB::DisplayList::Layer::can_mix(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(void *)(a1 + 16)) {
    return 0;
  }
  BOOL v5 = !*(unsigned char *)(a1 + 64) && *(void *)(a3 + 16) == 0;
  BOOL v6 = v5 && *(unsigned char *)(a3 + 64) == 0;
  if (!v6
    || ((*(_DWORD *)(a3 + 60) ^ *(_DWORD *)(a1 + 60)) & 0x224F) != 0
    || *(unsigned __int8 *)(a1 + 67) != *(unsigned __int8 *)(a3 + 67))
  {
    return 0;
  }
  uint64_t v7 = *(void *)a1;
  float32x2_t v8 = *(const RB::DisplayList::Item **)a3;
  if (!(*(void *)a1 | *(void *)a3)) {
    return a4;
  }
  for (i = 0; v7; uint64_t v7 = *(void *)(v7 + 8))
    i |= 1 << *(_WORD *)(v7 + 46);
  for (; v8; float32x2_t v8 = (const RB::DisplayList::Item *)*((void *)v8 + 1))
    i |= 1 << *((_WORD *)v8 + 23);
  if ((i & 3) != 0) {
    return 0;
  }
  uint64_t v12 = RB::DisplayList::Interpolator::Contents::make_layer<RB::DisplayList::Layer::can_mix(RB::DisplayList::Interpolator::Contents&,RB::DisplayList::Layer const&,RB::Mixable)::$_2>(a2, *(_DWORD *)(a1 + 56), *(unsigned int *)(a3 + 56), a1, (const RB::DisplayList::Item **)a3);
  if (!v12) {
    return 0;
  }
  float v13 = *(float *)(v12 + 8);
  if (*(float *)(a2 + 72) > v13) {
    float v13 = *(float *)(a2 + 72);
  }
  *(float *)(a2 + 72) = v13;
  if (a4 < 4u)
  {
    if (a4 != 3)
    {
      if (a4 < 2u) {
        return a4;
      }
      int v14 = *(_DWORD *)(v12 + 192);
      a4 = 2;
      goto LABEL_32;
    }
    int v14 = *(_DWORD *)(v12 + 192);
    unsigned int v15 = 3;
  }
  else
  {
    int v14 = *(_DWORD *)(v12 + 192);
    if (v14 == 32) {
      unsigned int v15 = a4;
    }
    else {
      unsigned int v15 = 3;
    }
  }
  if ((v14 & 0xFFFFFECF) != 0) {
    a4 = 2;
  }
  else {
    a4 = v15;
  }
LABEL_32:
  if ((v14 & 0x44) != 0) {
    return 1;
  }
  if (*(unsigned char *)(v12 + 250))
  {
    if ((v14 & 3) != 0 || *(unsigned char *)(v12 + 248) == 0) {
      return 1;
    }
  }
  return a4;
}

uint64_t RB::DisplayList::Interpolator::Contents::make_layer<RB::DisplayList::Layer::can_mix(RB::DisplayList::Interpolator::Contents&,RB::DisplayList::Layer const&,RB::Mixable)::$_2>(unint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, const RB::DisplayList::Item **a5)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  uint64_t v8 = a1 + 32;
  unint64_t v9 = a2 | (unint64_t)(a3 << 32);
  unint64_t v17 = v9;
  uint64_t v10 = std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,RB::pair_hash<unsigned int,unsigned int>,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::equal_to<std::pair<unsigned int,unsigned int>>,RB::pair_hash<unsigned int,unsigned int>,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>>>::find<std::pair<unsigned int,unsigned int>>((void *)(a1 + 32), (unsigned int *)&v17);
  if (v10) {
    return v10[3];
  }
  int v18 = 0;
  int v19 = 0;
  uint64_t v20 = 0x400000000;
  int v21 = 0;
  long long v22 = 0;
  uint64_t v23 = 0x200000000;
  int v24 = 1;
  unint64_t v17 = a1;
  RB::DisplayList::make_interpolator((RB::DisplayList *)&v17, *(RB::DisplayList::Interpolator::Layer **)a4, *a5, v11);
  if ((_BYTE)v24)
  {
    BOOL is_fade = RB::DisplayList::Interpolator::Layer::is_fade((RB::DisplayList::Interpolator::Layer *)&v17);
    if (BYTE1(v24)) {
      BOOL v14 = 0;
    }
    else {
      BOOL v14 = is_fade;
    }
    if (!v14) {
LABEL_13:
    }
      operator new();
  }
  else if (BYTE1(v24))
  {
    goto LABEL_13;
  }
  if (HIBYTE(v24) || (*(unsigned char *)(a4 + 61) & 4) != 0) {
    goto LABEL_13;
  }
  uint64_t v12 = 0;
  v16[0] = v9;
  v16[1] = 0;
  std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,RB::pair_hash<unsigned int,unsigned int>,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::equal_to<std::pair<unsigned int,unsigned int>>,RB::pair_hash<unsigned int,unsigned int>,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>>>::__emplace_unique_key_args<std::pair<unsigned int,unsigned int>,std::pair<std::pair<unsigned int,unsigned int>,RB::DisplayList::Interpolator::Layer*>>(v8, (unsigned int *)v16, v16);
  if (v22) {
    free(v22);
  }
  if (v19) {
    free(v19);
  }
  return v12;
}

void sub_21414BBA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  RB::DisplayList::Interpolator::Layer::~Layer((RB::DisplayList::Interpolator::Layer *)va);
  _Unwind_Resume(a1);
}

RB::DisplayList::Layer *RB::DisplayList::Layer::mix(RB::DisplayList::Layer *this, const RB::DisplayList::Interpolator::State *a2, const RB::DisplayList::Layer *a3, RB::DisplayList::Builder **a4)
{
  v35[14] = *MEMORY[0x263EF8340];
  uint64_t v8 = RB::DisplayList::Layer::copy(this, *a4, 1u);
  uint64_t v10 = (RB::DisplayList::Layer *)v8;
  unsigned int v11 = (const RB::DisplayList::Item *)*((void *)a2 + 4);
  float v12 = *(float *)(v8 + 48);
  float v13 = *((float *)a3 + 12);
  if (v12 != 0.0 || v13 != 0.0)
  {
    if (v12 == 0.0) {
      float v15 = 1.0;
    }
    else {
      float v15 = *(float *)(v8 + 48);
    }
    if (v13 == 0.0) {
      float v17 = 1.0;
    }
    else {
      float v17 = *((float *)a3 + 12);
    }
    if (v15 == v17)
    {
      BOOL v14 = 0;
      double v16 = (const RB::DisplayList::Item **)a3;
      if (!v11) {
        goto LABEL_13;
      }
    }
    else
    {
      BOOL v14 = (RB::DisplayList::Layer *)RB::DisplayList::Layer::copy(a3, *a4, 4u);
      *(void *)&long long v27 = 0;
      *((double *)&v27 + 1) = (float)(v15 / v17);
      v30[0] = *((unint64_t *)&v27 + 1);
      v30[1] = v27;
      uint64_t v31 = 0;
      uint64_t v32 = 0;
      RB::DisplayList::CachedTransform::CachedTransform((uint64_t)v33, (uint64_t)*a4, v30, 0, 0, 0);
      RB::DisplayList::Layer::apply_transform_(v14, (const RB::DisplayList::CachedTransform *)v33);
      RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v35);
      RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v34);
      RB::Heap::~Heap((RB::Heap *)&v33[0].f64[1]);
      *((_DWORD *)v14 + 12) = 1065353216;
      double v16 = (const RB::DisplayList::Item **)v14;
      if (!*((void *)a2 + 4)) {
        goto LABEL_13;
      }
    }
    MEMORY[0x270FA5388](v8, v9);
    unsigned int v11 = (const RB::DisplayList::Item *)v29;
    float64x2_t v19 = vmulq_n_f64(*(float64x2_t *)(v18 + 16), v15);
    long long v20 = *(_OWORD *)(v18 + 32);
    v29[0] = vmulq_n_f64(*(float64x2_t *)v18, v15);
    v29[1] = v19;
    v29[2] = v20;
    goto LABEL_13;
  }
  BOOL v14 = 0;
  float v15 = 1.0;
  double v16 = (const RB::DisplayList::Item **)a3;
LABEL_13:
  RB::DisplayList::CachedTransform::CachedTransform((RB::DisplayList::CachedTransform *)v33, (float64x2_t *)a4, 1.0, v15, 0);
  int v21 = (void *)(*(void *)a2 + 32);
  *(void *)&v30[0] = *((unsigned int *)this + 14) | ((unint64_t)*((unsigned int *)a3 + 14) << 32);
  long long v22 = std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,RB::pair_hash<unsigned int,unsigned int>,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::equal_to<std::pair<unsigned int,unsigned int>>,RB::pair_hash<unsigned int,unsigned int>,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>>>::find<std::pair<unsigned int,unsigned int>>(v21, (unsigned int *)v30);
  if (v22)
  {
    uint64_t v25 = (RB::DisplayList *)v22[3];
    if (v25)
    {
      LODWORD(v23) = *((_DWORD *)a2 + 5);
      LODWORD(v24) = 1.0;
      RB::DisplayList::apply_interpolator(v25, (const RB::DisplayList::Interpolator::Layer *)*((unsigned __int8 *)a2 + 28), v23, *(_DWORD *)(*((void *)a2 + 1) + 32), v10, v33, v24, 0, *(const RB::Rect **)this, *v16, v11, v28);
    }
  }
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v35);
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v34);
  RB::Heap::~Heap((RB::Heap *)&v33[0].f64[1]);
  if (v14) {
    RB::DisplayList::Layer::~Layer(v14);
  }
  return v10;
}

void sub_21414BE48(_Unwind_Exception *a1)
{
  RB::DisplayList::CachedTransform::~CachedTransform((RB::DisplayList::CachedTransform *)(v1 + 48));
  if (v2) {
    RB::DisplayList::Layer::~Layer(v2);
  }
  _Unwind_Resume(a1);
}

void RB::DisplayList::CachedTransform::~CachedTransform(RB::DisplayList::CachedTransform *this)
{
}

uint64_t RB::DisplayList::LayerItem::prepare_mix(RB::DisplayList::LayerItem *this, RB::DisplayList::Interpolator::Contents *a2, RB::DisplayList::Interpolator::Op *a3, const RB::DisplayList::Item *a4)
{
  uint64_t result = (*(uint64_t (**)(const RB::DisplayList::Item *))(*(void *)a4 + 16))(a4);
  if (!result)
  {
    uint64_t result = RB::DisplayList::Item::may_mix(this, a2, a4, v9);
    if ((_BYTE)result)
    {
      unsigned __int8 v11 = result;
      int v12 = *((_DWORD *)a2 + 4);
      uint64_t v13 = *((void *)a2 + 1);
      animatiounint64_t n = (const RB::Animation *)RB::DisplayList::find_animation(this, a4, v10);
      if (animation)
      {
        float v15 = animation;
        *((_DWORD *)a2 + 4) = RB::DisplayList::Interpolator::Contents::intern_animation(a2, animation);
        *((void *)a2 + 1) = v15;
      }
      uint64_t result = RB::DisplayList::Layer::can_mix(*((void *)this + 6), (unint64_t)a2, *((void *)a4 + 6), v11);
      if ((_BYTE)result) {
        uint64_t result = (uint64_t)RB::DisplayList::Interpolator::Op::set_type((unint64_t *)a3, result);
      }
      *((_DWORD *)a2 + 4) = v12;
      *((void *)a2 + 1) = v13;
    }
  }
  return result;
}

double RB::DisplayList::LayerItem::mix(RB::DisplayList::Layer **this, const RB::DisplayList::Interpolator::State *a2, const RB::DisplayList::Layer **a3, RB::DisplayList::Builder **a4)
{
  float v17 = RB::DisplayList::Layer::mix(this[6], a2, a3[6], a4);
  uint64_t v8 = (size_t *)(*((void *)*a4 + 1) + 16);
  _S2 = *((_DWORD *)a2 + 4);
  __asm { FCVT            H2, S2 }
  short float v16 = *((short float *)this + 22)
      + (short float)((short float)(*((short float *)a3 + 22) - *((short float *)this + 22)) * *(short float *)&_S2);
  int v15 = *((_WORD *)this + 23) & 0x3F;
  return _ZN2RB4Heap7emplaceINS_11DisplayList9LayerItemEJRDF16_RKNS_9BlendModeERPNS2_5LayerEEEEPT_DpOT0_(v8, (__int16 *)&v16, &v15, (uint64_t *)&v17);
}

double _ZN2RB4Heap7emplaceINS_11DisplayList9LayerItemEJRDF16_RKNS_9BlendModeERPNS2_5LayerEEEEPT_DpOT0_(size_t *a1, __int16 *a2, int *a3, uint64_t *a4)
{
  uint64_t v7 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v7 + 56 > a1[3]) {
    uint64_t v7 = RB::Heap::alloc_slow(a1, 0x38uLL, 7);
  }
  else {
    a1[2] = v7 + 56;
  }
  _H0 = *a2;
  __asm { FCVT            S0, H0 }
  int v14 = *a3;
  uint64_t v15 = *a4;
  *(void *)&double result = RB::DisplayList::LayerItem::LayerItem(v7, v14, v15, _S0);
  return result;
}

uint64_t RB::DisplayList::LayerItem::mix_bounds(RB::DisplayList::LayerItem *this, const RB::DisplayList::Interpolator::State *a2, float32x2_t *a3, const RB::Rect *a4, const RB::DisplayList::Item *a5)
{
  uint64_t v10 = *(unsigned int *)(*((void *)this + 6) + 56);
  unsigned __int8 v11 = (void *)(*(void *)a2 + 32);
  unint64_t v27 = v10 | ((unint64_t)*(unsigned int *)(*((void *)a5 + 6) + 56) << 32);
  int v12 = std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,RB::pair_hash<unsigned int,unsigned int>,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::equal_to<std::pair<unsigned int,unsigned int>>,RB::pair_hash<unsigned int,unsigned int>,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>>>::find<std::pair<unsigned int,unsigned int>>(v11, (unsigned int *)&v27);
  if (v12
    && (uint64_t v18 = (RB::DisplayList *)v12[3]) != 0
    && !RB::DisplayList::Interpolator::Layer::is_fade((RB::DisplayList::Interpolator::Layer *)v12[3]))
  {
    uint64_t v21 = *((void *)this + 6);
    float v22 = *(float *)(v21 + 48);
    float v23 = 1.0;
    if (v22 == 0.0) {
      float v22 = 1.0;
    }
    uint64_t v24 = *((void *)a5 + 6);
    if (*(float *)(v24 + 48) != 0.0) {
      float v23 = *(float *)(v24 + 48);
    }
    if (v22 != v23) {
      return 0;
    }
    RB::DisplayList::interpolated_bounds(v18, (const RB::DisplayList::Interpolator::Layer *)*((unsigned __int8 *)a2 + 28), *((float *)a2 + 5), *(RB::DisplayList::Item **)v21, *(const RB::DisplayList::Item **)v24, v19);
    *a3 = v25;
    a3[1] = v26;
  }
  else
  {
    v13.i64[0] = *((void *)a4 + 1);
    RB::Rect::Union(a3, *(double *)a4, v13, v14, v15, v16, v17);
  }
  return 1;
}

uint64_t RB::DisplayList::LayerItem::atom_position(RB::DisplayList::LayerItem *this, int a2)
{
  uint64_t v2 = 0;
  if (!a2)
  {
    char v4 = (void *)**((void **)this + 6);
    if (v4)
    {
      float32x2_t v5 = (float32x2_t)vdup_n_s32(0x7F800000u);
      do
      {
        float32x2_t v6 = (float32x2_t)(*(uint64_t (**)(void *, void))(*v4 + 56))(v4, 0);
        if (v7) {
          float32x2_t v5 = vminnm_f32(v5, v6);
        }
        char v4 = (void *)v4[1];
      }
      while (v4);
      uint32x2_t v8 = (uint32x2_t)vbic_s8(vorr_s8((int8x8_t)vcltz_f32(v5), (int8x8_t)vcgez_f32(v5)), (int8x8_t)vceq_f32(vabs_f32(v5), (float32x2_t)vdup_n_s32(0x7F800000u)));
      int32x2_t v9 = (int32x2_t)vpmin_u32(v8, v8);
      if (v9.i32[0] < 0)
      {
        v9.i32[0] = *(_DWORD *)(*((void *)this + 6) + 48);
        if (*(float *)v9.i32 == 0.0) {
          return (uint64_t)v5;
        }
        else {
          return (uint64_t)vdiv_f32(v5, (float32x2_t)vdup_lane_s32(v9, 0));
        }
      }
    }
  }
  return v2;
}

uint64_t RB::DisplayList::LayerClip::can_mix(RB::DisplayList::LayerClip *this, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Clip *a3)
{
  if (*((unsigned __int8 *)this + 44) != *((unsigned __int8 *)a3 + 44)) {
    return 0;
  }
  float v3 = *((float *)this + 14);
  float v4 = *((float *)a3 + 14);
  uint64_t v5 = *((void *)this + 6);
  uint64_t v6 = *((void *)a3 + 6);
  if (v3 == v4) {
    uint64_t v7 = 4;
  }
  else {
    uint64_t v7 = 2;
  }
  return RB::DisplayList::Layer::can_mix(v5, (unint64_t)a2, v6, v7);
}

uint64_t RB::DisplayList::LayerClip::mix(RB::DisplayList::Layer **this, const RB::DisplayList::Interpolator::State *a2, const RB::DisplayList::Layer **a3, RB::DisplayList::Builder **a4)
{
  int32x4_t v13 = RB::DisplayList::Layer::mix(this[6], a2, a3[6], a4);
  float v12 = *((float *)this + 14) + (float)((float)(*((float *)a3 + 14) - *((float *)this + 14)) * *((float *)a2 + 4));
  v8.n128_f32[0] = v12;
  int32x2_t v9 = (size_t *)(*((void *)*a4 + 1) + 16);
  unsigned int v11 = *((char *)this + 44);
  return RB::Heap::emplace<RB::DisplayList::LayerClip,RB::DisplayList::Layer *&,float &,RB::ClipMode const&>(v9, (uint64_t *)&v13, (unsigned __int32 *)&v12, &v11, v8);
}

uint64_t RB::Heap::emplace<RB::DisplayList::LayerClip,RB::DisplayList::Layer *&,float &,RB::ClipMode const&>(size_t *a1, uint64_t *a2, unsigned __int32 *a3, unsigned int *a4, __n128 a5)
{
  unint64_t v8 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v8 + 64 > a1[3]) {
    unint64_t v8 = RB::Heap::alloc_slow(a1, 0x40uLL, 7);
  }
  else {
    a1[2] = v8 + 64;
  }
  uint64_t v9 = *a2;
  a5.n128_u32[0] = *a3;
  uint64_t v10 = *a4;
  return RB::DisplayList::LayerClip::LayerClip(v8, v9, v10, a5);
}

uint64_t RB::DisplayList::LayerClip::mix_bounds(RB::DisplayList::LayerClip *this, const RB::DisplayList::Interpolator::State *a2, float32x2_t *a3, const RB::Rect *a4, const RB::DisplayList::Clip *a5)
{
  uint64_t v10 = *(unsigned int *)(*((void *)this + 6) + 56);
  unsigned int v11 = (void *)(*(void *)a2 + 32);
  unint64_t v27 = v10 | ((unint64_t)*(unsigned int *)(*((void *)a5 + 6) + 56) << 32);
  float v12 = std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,RB::pair_hash<unsigned int,unsigned int>,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::equal_to<std::pair<unsigned int,unsigned int>>,RB::pair_hash<unsigned int,unsigned int>,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>>>::find<std::pair<unsigned int,unsigned int>>(v11, (unsigned int *)&v27);
  if (v12
    && (uint64_t v18 = (RB::DisplayList *)v12[3]) != 0
    && !RB::DisplayList::Interpolator::Layer::is_fade((RB::DisplayList::Interpolator::Layer *)v12[3]))
  {
    uint64_t v21 = *((void *)this + 6);
    float v22 = *(float *)(v21 + 48);
    float v23 = 1.0;
    if (v22 == 0.0) {
      float v22 = 1.0;
    }
    uint64_t v24 = *((void *)a5 + 6);
    if (*(float *)(v24 + 48) != 0.0) {
      float v23 = *(float *)(v24 + 48);
    }
    if (v22 != v23) {
      return 0;
    }
    RB::DisplayList::interpolated_bounds(v18, (const RB::DisplayList::Interpolator::Layer *)*((unsigned __int8 *)a2 + 28), *((float *)a2 + 5), *(RB::DisplayList::Item **)v21, *(const RB::DisplayList::Item **)v24, v19);
    *a3 = v25;
    a3[1] = v26;
  }
  else
  {
    v13.i64[0] = *((void *)a4 + 1);
    RB::Rect::Union(a3, *(double *)a4, v13, v14, v15, v16, v17);
  }
  return 1;
}

uint64_t RB::DisplayList::Clip::can_mix()
{
  return 0;
}

float RB::DisplayList::Clip::cg_alpha(RB::DisplayList::Clip *this)
{
  return 1.0;
}

unint64_t RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>,float &>(size_t *a1, float *a2)
{
  unint64_t v3 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 96 > a1[3]) {
    unint64_t v3 = RB::Heap::alloc_slow(a1, 0x60uLL, 7);
  }
  else {
    a1[2] = v3 + 96;
  }
  *(void *)(v3 + 48) = 0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(void *)unint64_t v3 = &unk_26C4E8A50;
  RB::Filter::GaussianBlur::GaussianBlur(v3 + 56, *a2, 0, 0, 0);
  return v3;
}

uint64_t RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>::~FilterStyle(uint64_t a1)
{
  uint64_t v2 = *(void (****)(void))(a1 + 88);
  *(void *)(a1 + 88) = 0;
  if (v2) {
    (**v2)(v2);
  }
  return a1;
}

void RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>::~FilterStyle(uint64_t a1)
{
  uint64_t v2 = *(void (****)(void))(a1 + 88);
  *(void *)(a1 + 88) = 0;
  if (v2) {
    (**v2)(v2);
  }
  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>::type_id()
{
  return 20482;
}

unint64_t RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>::copy(uint64_t a1, RB::DisplayList::Builder *a2)
{
  return RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>,RB::Filter::GaussianBlur const&,RB::DisplayList::Builder &>((size_t *)(*((void *)a2 + 1) + 16), (RB::Filter::GaussianBlur *)(a1 + 56), a2);
}

RB::DisplayList::Builder *RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>::draw(float *a1, RB::DisplayList::Builder *this, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  if (a1[14] <= 0.0
    || (uint64_t v10 = (float64x2_t *)*((void *)a1 + 2),
        unsigned int v11 = (const RB::DisplayList::ClipNode *)*((void *)a1 + 3),
        float v12 = (RB::DisplayList::LayerFilter *)RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>,RB::Filter::GaussianBlur const&,RB::DisplayList::Builder &>((size_t *)(*((void *)this + 1) + 16), (RB::Filter::GaussianBlur *)(a1 + 14), this), result = RB::DisplayList::Builder::apply_filter_(this, a4, v12, v10, v11), (a4 = result) != 0))
  {
    *((void *)a4 + 2) = *((void *)a1 + 4);
    return RB::DisplayList::Builder::draw(this, a4, a3, a5);
  }
  return result;
}

double RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>::bounds(uint64_t a1, const RB::DisplayList::Item *a2, uint64_t a3)
{
  v15[0] = RB::DisplayList::Style::next_bounds((RB::DisplayList::Style *)a1, a2, a3);
  v15[1] = v4;
  v12[0] = (float64x2_t)xmmword_2142181C0;
  v12[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  RB::Rect::move(v15, v12, *(float64x2_t **)(a1 + 16));
  RB::Filter::GaussianBlur::dod((RB::Filter::GaussianBlur *)(a1 + 56), v15, v5);
  RB::Rect::move_identity(v15, v12);
  uint64_t v10 = *(void *)(a1 + 24);
  if (v10) {
    RB::Rect::intersect(v15, *(double *)(v10 + 16), *(float32x2_t *)(v10 + 24), v6, v7, v8, v9);
  }
  return *(double *)v15;
}

double RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>::map_roi(uint64_t a1, float32x2_t *this, float64x2_t *a3)
{
  float32x2_t v4 = (RB::Filter::GaussianBlur *)(a1 + 56);
  RB::Rect::move(this, a3, *(float64x2_t **)(a1 + 16));
  return RB::Filter::GaussianBlur::dod(v4, this, v5);
}

uint64_t RB::DisplayList::Style::matches(RB::DisplayList::Style *this, const Predicate *a2)
{
  return 0;
}

uint64_t RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>::can_mix(float32x2_t *a1, RB::DisplayList::Interpolator::Contents *a2, float32x2_t *a3)
{
  unint64_t v3 = a1 + 7;
  if (a3) {
    float32x2_t v4 = a3 + 7;
  }
  else {
    float32x2_t v4 = 0;
  }
  return RB::Filter::GaussianBlur::can_mix(v3, a2, v4);
}

float32x2_t *RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>::mix(uint64_t a1, const RB::DisplayList::Interpolator::State *a2, float32x2_t *a3, RB::DisplayList::Builder **a4)
{
  double v7 = (float32x2_t *)RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>,RB::Filter::GaussianBlur const&,RB::DisplayList::Builder &>((size_t *)(*((void *)*a4 + 1) + 16), (RB::Filter::GaussianBlur *)(a1 + 56), *a4);
  if (a3) {
    uint64_t v10 = a3 + 7;
  }
  else {
    uint64_t v10 = 0;
  }
  RB::Filter::GaussianBlur::mix(v7 + 7, a2, v10, (const RB::DisplayList::CachedTransform *)a4, v8, v9);
  return v7;
}

uint64_t RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>::prepare_encode(RB::DisplayList::Style *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::prepare_encode(a1, a2);
  return RB::Filter::GaussianBlur::prepare_encode((uint64_t)a1 + 56);
}

void *RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>::encode(uint64_t a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode((void *)a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x32uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::Filter::GaussianBlur::encode((int *)(a1 + 56), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "filter");
  RB::Filter::GaussianBlur::print((RB::Filter::GaussianBlur *)(a1 + 7), this);
  RB::DisplayList::Style::print(a1, this);
  RB::SexpString::pop(this);
}

unint64_t RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>,RB::Filter::GaussianBlur const&,RB::DisplayList::Builder &>(size_t *a1, RB::Filter::GaussianBlur *a2, RB::DisplayList::Builder *a3)
{
  unint64_t v5 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 96 > a1[3]) {
    unint64_t v5 = RB::Heap::alloc_slow(a1, 0x60uLL, 7);
  }
  else {
    a1[2] = v5 + 96;
  }
  *(void *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(void *)unint64_t v5 = &unk_26C4E8A50;
  RB::Filter::GaussianBlur::GaussianBlur((RB::Filter::GaussianBlur *)(v5 + 56), a2, a3);
  return v5;
}

void *RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>,RB::Filter::GaussianBlur const&,RB::DisplayList::Builder &>(size_t *a1, RB::Filter::GaussianBlur *a2, RB::DisplayList::Builder *a3)
{
  unint64_t v5 = (void *)((a1[2] + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(v5 + 9) > a1[3]) {
    unint64_t v5 = (void *)RB::Heap::alloc_slow(a1, 0x48uLL, 7);
  }
  else {
    a1[2] = (size_t)(v5 + 9);
  }
  void v5[2] = 0;
  float64x2_t v5[3] = 0;
  *unint64_t v5 = &unk_26C4EBF30;
  RB::Filter::GaussianBlur::GaussianBlur((RB::Filter::GaussianBlur *)(v5 + 4), a2, a3);
  return v5;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::~GenericFilter(uint64_t a1)
{
  uint64_t v2 = *(void (****)(void))(a1 + 64);
  *(void *)(a1 + 64) = 0;
  if (v2) {
    (**v2)(v2);
  }
  return a1;
}

void RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::~GenericFilter(uint64_t a1)
{
  uint64_t v2 = *(void (****)(void))(a1 + 64);
  *(void *)(a1 + 64) = 0;
  if (v2) {
    (**v2)(v2);
  }
  JUMPOUT(0x21669AC10);
}

void *RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::copy(uint64_t a1, RB::DisplayList::Builder *a2)
{
  return RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>,RB::Filter::GaussianBlur const&,RB::DisplayList::Builder &>((size_t *)(*((void *)a2 + 1) + 16), (RB::Filter::GaussianBlur *)(a1 + 32), a2);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::apply_transform(float32x2_t *a1, float64x2_t *a2)
{
  return RB::Filter::GaussianBlur::apply_transform(a1 + 4, a2);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::append(uint64_t a1, int a2, uint64_t a3)
{
  return RB::Filter::GaussianBlur::append(a1 + 32, a2, a3);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::filter_data()
{
  return 5;
}

double RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::roi(uint64_t a1, float32x2_t *a2, int32x4_t a3)
{
  return RB::Filter::GaussianBlur::dod((RB::Filter::GaussianBlur *)(a1 + 32), a2, a3);
}

double RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::dod(uint64_t a1, float32x2_t *a2, int32x4_t a3)
{
  return RB::Filter::GaussianBlur::dod((RB::Filter::GaussianBlur *)(a1 + 32), a2, a3);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::commutes_with_clip(uint64_t a1)
{
  return RB::Filter::GaussianBlur::commutes_with_clip((RB::Filter::GaussianBlur *)(a1 + 32));
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::required_depth(uint64_t a1, unsigned int a2)
{
  return RB::Filter::GaussianBlur::required_depth(a1 + 32, a2);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::can_discard_color()
{
  return 1;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::can_render_inline()
{
  return 0;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::prepare(uint64_t a1)
{
  return RB::Filter::GaussianBlur::prepare(a1 + 32);
}

void RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::render(uint64_t a1, uint64_t a2, id ***a3, int32x2_t a4)
{
}

void RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::render(uint64_t a1, float64x2_t *a2, CFTypeRef *a3)
{
}

void RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::print(uint64_t a1, std::string *a2)
{
}

uint64_t *std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,RB::pair_hash<unsigned int,unsigned int>,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::equal_to<std::pair<unsigned int,unsigned int>>,RB::pair_hash<unsigned int,unsigned int>,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>>>::find<std::pair<unsigned int,unsigned int>>(void *a1, unsigned int *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  unint64_t v5 = 33 * v3 + v4;
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = 33 * v3 + v4;
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = (*(void *)&v2 - 1) & v5;
  }
  double v8 = *(uint64_t ***)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  for (double result = *v8; result; double result = (uint64_t *)*result)
  {
    unint64_t v10 = result[1];
    if (v5 == v10)
    {
      if (*((_DWORD *)result + 4) == v3 && *((_DWORD *)result + 5) == v4) {
        return result;
      }
    }
    else
    {
      if (v6.u32[0] > 1uLL)
      {
        if (v10 >= *(void *)&v2) {
          v10 %= *(void *)&v2;
        }
      }
      else
      {
        v10 &= *(void *)&v2 - 1;
      }
      if (v10 != v7) {
        return 0;
      }
    }
  }
  return result;
}

{
  int8x8_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint8x8_t v6;
  unint64_t v7;
  uint64_t **v8;
  uint64_t *result;
  unint64_t v10;

  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  unint64_t v5 = 33 * v3 + v4;
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = 33 * v3 + v4;
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = (*(void *)&v2 - 1) & v5;
  }
  double v8 = *(uint64_t ***)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  for (double result = *v8; result; double result = (uint64_t *)*result)
  {
    unint64_t v10 = result[1];
    if (v10 == v5)
    {
      if (*((_DWORD *)result + 4) == v3 && *((_DWORD *)result + 5) == v4) {
        return result;
      }
    }
    else
    {
      if (v6.u32[0] > 1uLL)
      {
        if (v10 >= *(void *)&v2) {
          v10 %= *(void *)&v2;
        }
      }
      else
      {
        v10 &= *(void *)&v2 - 1;
      }
      if (v10 != v7) {
        return 0;
      }
    }
  }
  return result;
}

void *RB::vector<RB::DisplayList::Item const*,32ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 34) + (*((void *)__dst + 34) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 34) + (*((void *)__dst + 34) >> 1);
  }
  double result = RB::details::realloc_vector<unsigned long,8ul>(*((void **)__dst + 32), __dst, 0x20uLL, (size_t *)__dst + 34, v3);
  *((void *)__dst + 32) = result;
  return result;
}

RB::DisplayList::Builder *RB::DisplayList::apply_interpolator(RB::DisplayList::Interpolator::Layer const&,float,BOOL,unsigned int,RB::DisplayList::Layer &,float,RB::DisplayList::CachedTransform &,RB::Rect const*,RB::DisplayList::Item const*,RB::DisplayList::Item const*,RB::AffineTransform const*)::$_2::operator()(RB::DisplayList::Builder *result, uint64_t a2, RB::DisplayList::Item *a3, RB::DisplayList::Item *this, uint64_t a5)
{
  uint64_t v8 = (uint64_t)result;
  uint64_t v21 = a3;
  if (a3 && this)
  {
    if (RB::may_discard_alpha(*((_WORD *)a3 + 23) & 0x3F))
    {
      _ZN2RB4Heap7emplaceINS_11DisplayList14CrossFadeStyleEJRPNS2_4ItemERfRDF16_EEEPT_DpOT0_((RB::Heap *)(*(void *)(a5 + 8) + 16), (uint64_t *)&v21, (float *)(a2 + 16), (__int16 *)this + 22);
      unsigned int v11 = v10;
      float v12 = RB::AffineTransform::identity(v10);
      uint64_t v13 = *(void *)(a5 + 8);
      *((void *)v11 + 1) = *(void *)(v13 + 312);
      *((void *)v11 + 2) = v12;
      *(void *)(v13 + 312) = v11;
      *((_DWORD *)v11 + 13) |= 1u;
      *((void *)v11 + 4) = *((void *)this + 2);
      *((void *)this + 2) = v11;
      uint64_t v14 = *(RB::DisplayList::Layer ***)v8;
      RB::DisplayList::Item::apply_alpha((uint64_t)this, *((float *)v14 + 4));
      return RB::DisplayList::Builder::draw(v14[1], this, *v14, 0);
    }
    goto LABEL_6;
  }
  if (a3)
  {
LABEL_6:
    float v15 = 1.0 - *(float *)(a2 + 16);
    if (v15 < 0.0) {
      float v15 = 0.0;
    }
    if (v15 > 1.0) {
      float v15 = 1.0;
    }
    RB::DisplayList::Item::apply_alpha((uint64_t)a3, v15);
    double v16 = *(RB::DisplayList::Layer ***)v8;
    RB::DisplayList::Item::apply_alpha((uint64_t)a3, *(float *)(*(void *)v8 + 16));
    double result = RB::DisplayList::Builder::draw(v16[1], a3, *v16, 0);
  }
  if (this)
  {
    float v17 = *(float *)(a2 + 16);
    if (v17 < 0.0) {
      float v17 = 0.0;
    }
    if (v17 > 1.0) {
      float v17 = 1.0;
    }
    RB::DisplayList::Item::apply_alpha((uint64_t)this, v17);
    uint64_t v18 = *(RB::DisplayList::Layer ***)v8;
    RB::DisplayList::Item::apply_alpha((uint64_t)this, *((float *)v18 + 4));
    long long v20 = *v18;
    float64x2_t v19 = v18[1];
    return RB::DisplayList::Builder::draw(v19, this, v20, 0);
  }
  return result;
}

void _ZZZN2RB11DisplayList18apply_interpolatorERKNS0_12Interpolator5LayerEfbjRNS0_5LayerEfRNS0_15CachedTransformEPKNS_4RectEPKNS0_4ItemESE_PKNS_15AffineTransformEENK3__3clINS_6vectorISE_Lm32EmEESL_EEDaRNS1_5StateERNS0_13AtomizedItemsESQ_RKT_RKT0_ENKUljjST_E_clISL_EESM_jjST_(RB::DisplayList::Builder ***a1, unsigned int w1_0, unsigned int a3, uint64_t a4)
{
  float32x2_t v25 = 0;
  if (a3)
  {
    int v7 = 0;
    uint64_t v8 = 0;
    uint64_t layer = 0;
    uint64_t v10 = a3;
    do
    {
      uint64_t v11 = *(void *)(a4 + 256);
      if (!v11) {
        uint64_t v11 = a4;
      }
      uint64_t v12 = *(void *)(v11 + 8 * w1_0);
      uint64_t v13 = (float32x2_t *)a1[1];
      if (!v13
        || (float32x2_t v14 = RB::DisplayList::Item::styled_bounds(*(RB::DisplayList::Item **)(v11 + 8 * w1_0), 0),
            RB::Rect::intersects(v13, v26, v14, v15, v16, v17, v18, v19)))
      {
        long long v20 = (RB::DisplayList::Item *)(*(uint64_t (**)(uint64_t, RB::DisplayList::Builder *, void))(*(void *)v12 + 24))(v12, **a1, 0);
        (*(void (**)(RB::DisplayList::Item *, RB::DisplayList::Builder **, uint64_t))(*(void *)v20 + 32))(v20, *a1, 1);
        if (!layer)
        {
          uint64_t layer = (RB::DisplayList::Layer *)RB::DisplayList::Builder::make_layer(**a1, 0);
          float32x2_t v25 = layer;
          int v7 = *((_DWORD *)v20 + 10);
          uint64_t v8 = *((void *)v20 + 4);
        }
        *((void *)v20 + 4) = 0;
        *((_DWORD *)v20 + 10) = 0;
        RB::DisplayList::Builder::draw(**a1, v20, layer, 0);
      }
      ++w1_0;
      --v10;
    }
    while (v10);
    if (layer)
    {
      uint64_t v21 = (size_t *)(*((void *)**a1 + 1) + 16);
      int v23 = 2;
      int v24 = 1;
      RB::Heap::emplace<RB::DisplayList::LayerItem,int,RB::BlendMode,RB::DisplayList::Layer *&>(v21, &v24, &v23, (uint64_t *)&v25);
      if (v22)
      {
        *(_DWORD *)(v22 + 40) = v7;
        *(void *)(v22 + 32) = v8;
      }
    }
  }
}

float _ZN2RB4Heap7emplaceINS_11DisplayList14CrossFadeStyleEJRPNS2_4ItemERfRDF16_EEEPT_DpOT0_(RB::Heap *this, uint64_t *a2, float *a3, __int16 *a4)
{
  unint64_t v8 = *((void *)this + 3);
  unint64_t v9 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v9 + 72 > v8) {
    unint64_t v9 = RB::Heap::alloc_slow((size_t *)this, 0x48uLL, 7);
  }
  else {
    *((void *)this + 2) = v9 + 72;
  }
  uint64_t v10 = *a2;
  float result = *a3;
  _H1 = *a4;
  __asm { FCVT            S1, H1 }
  *(void *)(v9 + 48) = 0;
  *(void *)(v9 + 56) = v10;
  *(_OWORD *)(v9 + 16) = 0u;
  *(_OWORD *)(v9 + 32) = 0u;
  *(void *)unint64_t v9 = &unk_26C4EC1A0;
  *(float *)(v9 + 64) = result;
  *(_DWORD *)(v9 + 68) = _S1;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::LayerItem,int,RB::BlendMode,RB::DisplayList::Layer *&>(size_t *a1, int *a2, int *a3, uint64_t *a4)
{
  uint64_t v7 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v7 + 56 > a1[3]) {
    uint64_t v7 = RB::Heap::alloc_slow(a1, 0x38uLL, 7);
  }
  else {
    a1[2] = v7 + 56;
  }
  float v8 = (float)*a2;
  int v9 = *a3;
  uint64_t v10 = *a4;
  *(void *)&double result = RB::DisplayList::LayerItem::LayerItem(v7, v9, v10, v8);
  return result;
}

void RB::DisplayList::Interpolator::Layer::~Layer(RB::DisplayList::Interpolator::Layer *this)
{
  int8x8_t v2 = (void *)*((void *)this + 29);
  if (v2) {
    free(v2);
  }
  size_t v3 = (void *)*((void *)this + 22);
  if (v3) {
    free(v3);
  }
}

uint64_t RB::DisplayList::Interpolator::Layer::Layer(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *(_DWORD *)(a1 + 8) = *((_DWORD *)a2 + 2);
  *(void *)a1 = v4;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0x400000000;
  *(void *)(a1 + 176) = a2[22];
  a2[22] = 0;
  *(_DWORD *)(a1 + 184) = *((_DWORD *)a2 + 46);
  *((_DWORD *)a2 + 46) = 0;
  LODWORD(v4) = *(_DWORD *)(a1 + 188);
  *(_DWORD *)(a1 + 188) = *((_DWORD *)a2 + 47);
  *((_DWORD *)a2 + 47) = v4;
  RB::vector<RB::DisplayList::Interpolator::Op,4ul,unsigned int>::swap_inline((long long *)(a1 + 16), (long long *)a2 + 1);
  *(_DWORD *)(a1 + 192) = *((_DWORD *)a2 + 48);
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 240) = 0x200000000;
  *(void *)(a1 + 232) = a2[29];
  a2[29] = 0;
  *(_DWORD *)(a1 + 240) = *((_DWORD *)a2 + 60);
  *((_DWORD *)a2 + 60) = 0;
  int v5 = *(_DWORD *)(a1 + 244);
  *(_DWORD *)(a1 + 244) = *((_DWORD *)a2 + 61);
  *((_DWORD *)a2 + 61) = v5;
  RB::vector<RB::Rect,2ul,unsigned int>::swap_inline((long long *)(a1 + 200), (long long *)(a2 + 25));
  *(_DWORD *)(a1 + 248) = *((_DWORD *)a2 + 62);
  return a1;
}

void sub_21414D320(_Unwind_Exception *exception_object)
{
  size_t v3 = *(void **)(v1 + 232);
  if (v3) {
    free(v3);
  }
  uint64_t v4 = *(void **)(v1 + 176);
  if (v4) {
    free(v4);
  }
  _Unwind_Resume(exception_object);
}

long long *RB::vector<RB::DisplayList::Interpolator::Op,4ul,unsigned int>::swap_inline(long long *result, long long *a2)
{
  uint64_t v2 = *((void *)a2 + 20);
  uint64_t v3 = *((void *)result + 20);
  if (v2) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4)
  {
    long long v18 = a2[6];
    long long v19 = a2[7];
    long long v20 = a2[8];
    long long v21 = a2[9];
    long long v14 = a2[2];
    long long v15 = a2[3];
    long long v16 = a2[4];
    long long v17 = a2[5];
    long long v12 = *a2;
    long long v13 = a2[1];
    long long v5 = result[1];
    *a2 = *result;
    a2[1] = v5;
    long long v6 = result[2];
    long long v7 = result[3];
    long long v8 = result[5];
    a2[4] = result[4];
    a2[5] = v8;
    a2[2] = v6;
    a2[3] = v7;
    long long v9 = result[6];
    long long v10 = result[7];
    long long v11 = result[9];
    a2[8] = result[8];
    a2[9] = v11;
    a2[6] = v9;
    a2[7] = v10;
    result[6] = v18;
    result[7] = v19;
    result[8] = v20;
    result[9] = v21;
    result[2] = v14;
    result[3] = v15;
    result[4] = v16;
    result[5] = v17;
    *double result = v12;
    result[1] = v13;
    if (v3)
    {
      if (v2) {
        return result;
      }
    }
    else
    {
      *((void *)result + 20) = 0;
      if (v2) {
        return result;
      }
    }
    *((void *)a2 + 20) = 0;
  }
  return result;
}

long long *RB::vector<RB::Rect,2ul,unsigned int>::swap_inline(long long *result, long long *a2)
{
  uint64_t v2 = *((void *)a2 + 4);
  uint64_t v3 = *((void *)result + 4);
  if (v2) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4)
  {
    long long v6 = *a2;
    long long v5 = a2[1];
    long long v7 = result[1];
    *a2 = *result;
    a2[1] = v7;
    *double result = v6;
    result[1] = v5;
    if (v3)
    {
      if (v2) {
        return result;
      }
    }
    else
    {
      *((void *)result + 4) = 0;
      if (v2) {
        return result;
      }
    }
    *((void *)a2 + 4) = 0;
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,RB::pair_hash<unsigned int,unsigned int>,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::equal_to<std::pair<unsigned int,unsigned int>>,RB::pair_hash<unsigned int,unsigned int>,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>>>::__emplace_unique_key_args<std::pair<unsigned int,unsigned int>,std::pair<std::pair<unsigned int,unsigned int>,RB::DisplayList::Interpolator::Layer*>>(uint64_t a1, unsigned int *a2, void *a3)
{
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  unint64_t v8 = 33 * v6 + v7;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = 33 * v6 + v7;
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
    long long v11 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v11)
    {
      long long v12 = *v11;
      if (*v11)
      {
        do
        {
          unint64_t v13 = v12[1];
          if (v13 == v8)
          {
            if (*((_DWORD *)v12 + 4) == v6 && *((_DWORD *)v12 + 5) == v7) {
              return v12;
            }
          }
          else
          {
            if (v10.u32[0] > 1uLL)
            {
              if (v13 >= v9) {
                v13 %= v9;
              }
            }
            else
            {
              v13 &= v9 - 1;
            }
            if (v13 != v3) {
              break;
            }
          }
          long long v12 = (void *)*v12;
        }
        while (v12);
      }
    }
  }
  long long v15 = (void *)(a1 + 16);
  long long v12 = operator new(0x20uLL);
  *long long v12 = 0;
  v12[1] = v8;
  uint64_t v16 = a3[1];
  float64x2_t v12[2] = *a3;
  v12[3] = v16;
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v9 || (float)(v18 * (float)v9) < v17)
  {
    BOOL v19 = 1;
    if (v9 >= 3) {
      BOOL v19 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v9);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__rehash<true>(a1, v22);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v23 = *(void *)a1;
  int v24 = *(void **)(*(void *)a1 + 8 * v3);
  if (v24)
  {
    *long long v12 = *v24;
LABEL_42:
    *int v24 = v12;
    goto LABEL_43;
  }
  *long long v12 = *v15;
  *long long v15 = v12;
  *(void *)(v23 + 8 * v3) = v15;
  if (*v12)
  {
    unint64_t v25 = *(void *)(*v12 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v25 >= v9) {
        v25 %= v9;
      }
    }
    else
    {
      v25 &= v9 - 1;
    }
    int v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_42;
  }
LABEL_43:
  ++*(void *)(a1 + 24);
  return v12;
}

void sub_21414D6F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,void *>>>::operator()[abi:nn180100](v11, v10);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,void *>>>::operator()[abi:nn180100](uint64_t a1, char *__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    unint64_t v3 = __p + 24;
    uint64_t v4 = *((void *)__p + 3);
    *((void *)__p + 3) = 0;
    if (v4) {
      std::default_delete<RB::DisplayList::Interpolator::Layer>::operator()[abi:nn180100]((uint64_t)v3, v4);
    }
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

void std::default_delete<RB::DisplayList::Interpolator::Layer>::operator()[abi:nn180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    unint64_t v3 = *(void **)(a2 + 232);
    if (v3) {
      free(v3);
    }
    uint64_t v4 = *(void **)(a2 + 176);
    if (v4) {
      free(v4);
    }
    JUMPOUT(0x21669AC10);
  }
}

uint64_t RB::JSONPipeline::make_pipeline_set(RB::Device *a1, unint64_t a2)
{
  RB::JSONPipeline::JSONPipeline((RB::JSONPipeline *)v13);
  for (uint64_t i = *(uint64_t ***)(a2 + 16); i; uint64_t i = (uint64_t **)*i)
  {
    uint64_t v6 = (uint64_t)i[2];
    uint64_t v7 = *((unsigned int *)i + 6);
    unint64_t v8 = objc_opt_new();
    RB::JSONPipelineData::JSONPipelineData((RB::JSONPipelineData *)v12);
    unint64_t v9 = (uint64_t *)RB::Device::library(a1);
    unint64_t v2 = v2 & 0xFFFFFFFF00000000 | v7;
    RB::Device::make_render_pipeline_descriptor(v6, v2, v9, 0, v8, (uint64_t)v12, 0);
    a2 = a2 & 0xFFFFFFFF00000000 | v7;
    RB::JSONPipeline::add_pipeline_state(v13, v6, a2, v8, (uint64_t)v12);
  }
  uint64_t v10 = RB::JSONPipeline::finalize((RB::JSONPipeline *)v13);

  return v10;
}

void sub_21414D8F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  RB::JSONPipeline::~JSONPipeline((id *)va);
  _Unwind_Resume(a1);
}

void RB::JSONPipeline::add_pipeline_state(void **a1, char a2, __int16 a3, void *a4, uint64_t a5)
{
  uint64_t v47 = *MEMORY[0x263EF8340];
  id v9 = *(id *)a5;
  if (!*(void *)a5)
  {
LABEL_7:
    id v39 = 0;
    goto LABEL_8;
  }
  uint64_t v10 = (void *)[*(id *)a5 specializedName];
  uint64_t v11 = v10;
  if (!v10)
  {
    unint64_t v13 = (void *)[v9 name];
    if (v13)
    {

      id v39 = v13;
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  snprintf_l(v46, 0x100uLL, 0, "alias:%s#%s", (const char *)[v10 UTF8String], (const char *)objc_msgSend(v10, "UTF8String"));
  id v39 = (id)[[NSString alloc] initWithUTF8String:v46];

  if ((objc_msgSend(a1[2], "containsObject:") & 1) == 0)
  {
    objc_msgSend(a1[2], "addObject:");
    long long v12 = *a1;
    v45[0] = v11;
    v44[0] = @"label";
    v44[1] = @"function";
    v45[1] = [v9 name];
    v45[2] = v11;
    int32x2_t v44[2] = @"specialized_name";
    v44[3] = @"constant_values";
    _OWORD v45[3] = *(void *)(a5 + 16);
    objc_msgSend(v12, "addObject:", objc_msgSend(NSDictionary, "dictionaryWithObjects:forKeys:count:", v45, v44, 4));
  }
LABEL_8:
  long long v14 = *(void **)(a5 + 8);
  if (!v14)
  {
LABEL_14:
    id v40 = 0;
    goto LABEL_15;
  }
  long long v15 = (void *)[*(id *)(a5 + 8) specializedName];
  uint64_t v16 = v15;
  if (!v15)
  {
    float v18 = (void *)[v14 name];
    if (v18)
    {

      id v40 = v18;
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  snprintf_l(v46, 0x100uLL, 0, "alias:%s#%s", (const char *)[v15 UTF8String], (const char *)objc_msgSend(v15, "UTF8String"));
  id v40 = (id)[[NSString alloc] initWithUTF8String:v46];

  if ((objc_msgSend(a1[3], "containsObject:") & 1) == 0)
  {
    objc_msgSend(a1[3], "addObject:");
    float v17 = *a1;
    v43[0] = v16;
    v42[0] = @"label";
    v42[1] = @"function";
    v43[1] = [v14 name];
    int32x2_t v43[2] = v16;
    v42[2] = @"specialized_name";
    _OWORD v42[3] = @"constant_values";
    v43[3] = *(void *)(a5 + 16);
    objc_msgSend(v17, "addObject:", objc_msgSend(NSDictionary, "dictionaryWithObjects:forKeys:count:", v43, v42, 4));
  }
LABEL_15:
  id v41 = (id)objc_opt_new();
  uint64_t v20 = *((unsigned __int8 *)RB::pixel_format_traits(a3 & 0x3FF, v19) + 8);
  unsigned int v21 = a2 & 0x3F;
  if (v21 > 0x20)
  {
    if (v21 == 33)
    {
LABEL_22:
      if (v20 <= 4) {
        uint64_t v20 = 4;
      }
      else {
        uint64_t v20 = v20;
      }
      goto LABEL_31;
    }
    if (v21 != 34) {
      goto LABEL_25;
    }
    uint64_t v22 = 4;
LABEL_33:
    if (v20)
    {
      uint64_t v25 = objc_msgSend(NSString, "stringWithFormat:", @"supportsFamily(apple%d) && !supportsFamily(apple%d)", v20, v22);
      goto LABEL_35;
    }
    int v24 = @"!supportsFamily(apple%d)";
LABEL_32:
    uint64_t v25 = objc_msgSend(NSString, "stringWithFormat:", v24, v22);
LABEL_35:
    [v41 setObject:v25 forKeyedSubscript:@"enable"];
    goto LABEL_36;
  }
  if ((a2 & 0x3F) == 0)
  {
    int v23 = [a4 supportAddingFragmentBinaryFunctions];
    uint64_t v22 = 6;
    if (v23)
    {
      if (v20 <= 6) {
        uint64_t v20 = 6;
      }
      else {
        uint64_t v20 = v20;
      }
      goto LABEL_31;
    }
    goto LABEL_33;
  }
  if (v21 == 1) {
    goto LABEL_22;
  }
LABEL_25:
  if (v20)
  {
LABEL_31:
    int v24 = @"supportsFamily(apple%d)";
    uint64_t v22 = v20;
    goto LABEL_32;
  }
LABEL_36:
  [v41 setObject:v39 forKeyedSubscript:@"vertex_function"];
  if (v40) {
    [v41 setObject:v40 forKeyedSubscript:@"fragment_function"];
  }
  Rect v26 = objc_opt_new();
  unint64_t v27 = 0;
  uint64_t v28 = MEMORY[0x263EFFA78];
  do
  {
    unint64_t v29 = objc_msgSend((id)objc_msgSend(a4, "colorAttachments"), "objectAtIndexedSubscript:", v27);
    if ([v29 pixelFormat])
    {
      uint64_t v30 = objc_opt_new();
      while ([v26 count] < v27)
        [v26 addObject:v28];
      [v29 pixelFormat];
      objc_msgSend(v30, "setObject:forKeyedSubscript:", objc_msgSend(NSString, "stringWithUTF8String:", MTLPixelFormatGetName() + 14), @"pixel_format");
      if ([v29 isBlendingEnabled])
      {
        objc_msgSend(v30, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithBool:", objc_msgSend(v29, "isBlendingEnabled")), @"blending_enabled");
        unint64_t v31 = [v29 sourceRGBBlendFactor];
        if (v31 > 8) {
          goto LABEL_65;
        }
        [v30 setObject:*((void *)&RB::JSONPipeline::blend_factor_name(MTLBlendFactor)const::names + v31) forKeyedSubscript:@"source_rgb_blend_factor"];
        unint64_t v32 = [v29 destinationRGBBlendFactor];
        if (v32 > 8) {
          goto LABEL_65;
        }
        [v30 setObject:*((void *)&RB::JSONPipeline::blend_factor_name(MTLBlendFactor)const::names + v32) forKeyedSubscript:@"destination_rgb_blend_factor"];
        unint64_t v33 = [v29 rgbBlendOperation];
        if (v33 > 4
          || ([v30 setObject:*((void *)&RB::JSONPipeline::blend_operation_name(MTLBlendOperation)const::names + v33) forKeyedSubscript:@"rgb_blend_operation"], unint64_t v34 = objc_msgSend(v29, "sourceAlphaBlendFactor"), v34 > 8)|| (objc_msgSend(v30, "setObject:forKeyedSubscript:", *((void *)&RB::JSONPipeline::blend_factor_name(MTLBlendFactor)const::names + v34), @"source_alpha_blend_factor"), v35 = objc_msgSend(v29, "destinationAlphaBlendFactor"), v35 > 8)|| (objc_msgSend(v30, "setObject:forKeyedSubscript:", *((void *)&RB::JSONPipeline::blend_factor_name(MTLBlendFactor)const::names + v35), @"destination_alpha_blend_factor"), v36 = objc_msgSend(v29, "alphaBlendOperation"),
              v36 >= 5))
        {
LABEL_65:
          abort();
        }
        [v30 setObject:*((void *)&RB::JSONPipeline::blend_operation_name(MTLBlendOperation)const::names + v36) forKeyedSubscript:@"alpha_blend_operation"];
      }
      if ([v29 writeMask] != 15)
      {
        char v37 = (RB::JSONPipeline *)[v29 writeMask];
        objc_msgSend(v30, "setObject:forKeyedSubscript:", RB::JSONPipeline::color_write_mask_name(v37, (uint64_t)v37), @"write_mask");
      }
      [v26 addObject:v30];
    }
    ++v27;
  }
  while (v27 != 8);
  [v41 setObject:v26 forKeyedSubscript:@"color_attachments"];
  if ([a4 stencilAttachmentPixelFormat])
  {
    [a4 stencilAttachmentPixelFormat];
    objc_msgSend(v41, "setObject:forKeyedSubscript:", objc_msgSend(NSString, "stringWithUTF8String:", MTLPixelFormatGetName() + 14), @"stencil_attachment_pixel_format");
  }
  if ([a4 depthAttachmentPixelFormat])
  {
    [a4 depthAttachmentPixelFormat];
    objc_msgSend(v41, "setObject:forKeyedSubscript:", objc_msgSend(NSString, "stringWithUTF8String:", MTLPixelFormatGetName() + 14), @"depth_attachment_pixel_format");
  }
  if ([a4 supportAddingFragmentBinaryFunctions]) {
    [v41 setObject:MEMORY[0x263EFFA88] forKeyedSubscript:@"support_adding_fragment_binary_functions"];
  }
  if ([a4 maxFragmentCallStackDepth] != 1) {
    objc_msgSend(v41, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInteger:", objc_msgSend(a4, "maxFragmentCallStackDepth")), @"max_fragment_call_stack_depth");
  }
  [a1[1] addObject:v41];
}

void sub_21414E09C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12, id a13, id a14)
{
  _Unwind_Resume(a1);
}

void RB::JSONPipelineData::~JSONPipelineData(id *this)
{
}

uint64_t RB::JSONPipeline::finalize(RB::JSONPipeline *this)
{
  uint64_t v9[2] = *MEMORY[0x263EF8340];
  uint64_t v6 = @"specialized_functions";
  uint64_t v7 = *(void *)this;
  v8[0] = @"libraries";
  v9[0] = [NSDictionary dictionaryWithObjects:&v7 forKeys:&v6 count:1];
  v8[1] = @"pipelines";
  uint64_t v2 = *((void *)this + 1);
  uint64_t v4 = @"render_pipelines";
  uint64_t v5 = v2;
  v9[1] = [NSDictionary dictionaryWithObjects:&v5 forKeys:&v4 count:1];
  return [NSDictionary dictionaryWithObjects:v9 forKeys:v8 count:2];
}

void RB::JSONPipeline::~JSONPipeline(id *this)
{
}

RB::JSONPipeline *RB::JSONPipeline::JSONPipeline(RB::JSONPipeline *this)
{
  *(void *)this = objc_opt_new();
  *((void *)this + 1) = objc_opt_new();
  *((void *)this + 2) = objc_opt_new();
  *((void *)this + 3) = objc_opt_new();
  return this;
}

void sub_21414E2E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__CFString *RB::JSONPipeline::color_write_mask_name(RB::JSONPipeline *this, uint64_t a2)
{
  if (!a2) {
    return @"None";
  }
  char v2 = a2;
  if (a2 == 15) {
    return @"All";
  }
  uint64_t v4 = (void *)[MEMORY[0x263F089D8] string];
  unint64_t v3 = v4;
  if ((v2 & 8) != 0)
  {
    if ([v4 length]) {
      [v3 appendString:@" "];
    }
    [v3 appendString:@"Red"];
    if ((v2 & 4) == 0)
    {
LABEL_7:
      if ((v2 & 2) == 0) {
        goto LABEL_8;
      }
      goto LABEL_16;
    }
  }
  else if ((v2 & 4) == 0)
  {
    goto LABEL_7;
  }
  if ([v3 length]) {
    [v3 appendString:@" "];
  }
  [v3 appendString:@"Green"];
  if ((v2 & 2) == 0)
  {
LABEL_8:
    if ((v2 & 1) == 0) {
      return (__CFString *)v3;
    }
    goto LABEL_19;
  }
LABEL_16:
  if ([v3 length]) {
    [v3 appendString:@" "];
  }
  [v3 appendString:@"Blue"];
  if (v2)
  {
LABEL_19:
    if ([v3 length]) {
      [v3 appendString:@" "];
    }
    [v3 appendString:@"Alpha"];
  }
  return (__CFString *)v3;
}

RB::JSONPipelineData *RB::JSONPipelineData::JSONPipelineData(RB::JSONPipelineData *this)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = objc_opt_new();
  return this;
}

void sub_21414E474(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void RB::JSONPipelineData::set_const(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v13[1] = *MEMORY[0x263EF8340];
  unint64_t v8 = objc_opt_new();
  id v9 = v8;
  if (a3 != 36) {
    abort();
  }
  [v8 setObject:@"FunctionConstantIndex" forKeyedSubscript:@"id_type"];
  long long v12 = @"data";
  v13[0] = [NSNumber numberWithInt:a2];
  objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(NSDictionary, "dictionaryWithObjects:forKeys:count:", v13, &v12, 1), @"id");
  [v9 setObject:@"ConstantUInt4" forKeyedSubscript:@"value_type"];
  uint64_t v10 = @"data";
  uint64_t v11 = a4;
  objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(NSDictionary, "dictionaryWithObjects:forKeys:count:", &v11, &v10, 1), @"value");
  [*(id *)(a1 + 16) addObject:v9];
}

void sub_21414E5DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

float64x2_t CG::Cubic::Cubic(CG::Cubic *this, const Point *a2, const Point *a3, const Point *a4, const Point *a5)
{
  *(_OWORD *)this = *(_OWORD *)&a2->v;
  *((_OWORD *)this + 1) = *(_OWORD *)&a3->v;
  *((_OWORD *)this + 2) = *(_OWORD *)&a4->v;
  *((_OWORD *)this + 3) = *(_OWORD *)&a5->v;
  float64x2_t v5 = *((float64x2_t *)this + 1);
  float64x2_t v6 = vsubq_f64(v5, *(float64x2_t *)this);
  *((double *)this + 8) = 3.0 * v6.f64[0];
  *((double *)this + 9) = vmuld_lane_f64(3.0, v6, 1);
  float64x2_t v7 = *((float64x2_t *)this + 2);
  float64x2_t v8 = *((float64x2_t *)this + 3);
  float64x2_t v9 = vsubq_f64(v7, v5);
  float64x2_t v10 = vsubq_f64(v9, v6);
  *((double *)this + 10) = 3.0 * v10.f64[0];
  *((double *)this + 11) = vmuld_lane_f64(3.0, v10, 1);
  float64x2_t result = vaddq_f64(vsubq_f64(vsubq_f64(v6, v7), vaddq_f64(v9, v9)), v8);
  *((float64x2_t *)this + 6) = result;
  return result;
}

double CG::Cubic::evaluate(float64x2_t *this, double a2)
{
  *(void *)&double result = *(_OWORD *)&vmlaq_n_f64(*this, vmlaq_n_f64(this[4], vmlaq_n_f64(this[5], this[6], a2), a2), a2);
  return result;
}

double CG::Cubic::derivative(CG::Cubic *this, double a2)
{
  if (a2 == 0.0) {
    return CG::Cubic::tangent_at_0(this);
  }
  if (a2 == 1.0) {
    return CG::Cubic::tangent_at_1(this);
  }
  __asm { FMOV            V3.2D, #2.0 }
  *(void *)&double result = *(_OWORD *)&vmlaq_n_f64(*((float64x2_t *)this + 4), vmlaq_f64(vmulq_n_f64(*((float64x2_t *)this + 6), a2 * 3.0), _Q3, *((float64x2_t *)this + 5)), a2);
  return result;
}

double CG::Cubic::tangent_at_0(CG::Cubic *this)
{
  double v1 = *(double *)this;
  double v2 = *((double *)this + 1);
  double result = *((double *)this + 2) - *(double *)this;
  if (result * result + (*((double *)this + 3) - v2) * (*((double *)this + 3) - v2) <= 0.00000001)
  {
    double result = *((double *)this + 4) - v1;
    if (result * result + (*((double *)this + 5) - v2) * (*((double *)this + 5) - v2) <= 0.00000001) {
      return *((double *)this + 6) - v1;
    }
  }
  return result;
}

double CG::Cubic::tangent_at_1(CG::Cubic *this)
{
  double v1 = *((double *)this + 6);
  double v2 = *((double *)this + 7);
  double result = v1 - *((double *)this + 4);
  if (result * result + (v2 - *((double *)this + 5)) * (v2 - *((double *)this + 5)) <= 0.00000001)
  {
    double result = v1 - *((double *)this + 2);
    if (result * result + (v2 - *((double *)this + 3)) * (v2 - *((double *)this + 3)) <= 0.00000001) {
      return v1 - *(double *)this;
    }
  }
  return result;
}

BOOL CG::Cubic::is_flat_(float64x2_t *this, double a2)
{
  __asm { FMOV            V3.2D, #3.0 }
  float64x2_t v7 = this[3];
  float64x2_t v8 = vmlaq_f64(vsubq_f64(*this, v7), _Q3, vsubq_f64(this[1], *this));
  float64x2_t v9 = vmlaq_f64(vsubq_f64(v7, *this), _Q3, vsubq_f64(this[2], v7));
  float64x2_t v10 = vmulq_f64(v8, v8);
  float64x2_t v11 = vmulq_f64(v9, v9);
  return vaddvq_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v11, v10), (int8x16_t)v11, (int8x16_t)v10)) < a2;
}

double CG::Cubic::length(float64x2_t *this, double a2)
{
  return RB::cubic_length<double>(*this, this[1], this[2], this[3], a2);
}

double CG::Cubic::index(float64x2_t *this, double a2, double a3)
{
  return RB::cubic_index<double>(*this, this[1], this[2], this[3], a2, a3);
}

double RB::cubic_index<double>(float64x2_t a1, float64x2_t a2, float64x2_t a3, float64x2_t a4, double a5, double a6)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  double v6 = 0.0;
  if (a5 != 0.0)
  {
    float64x2_t v7 = vsubq_f64(a2, a1);
    int64x2_t v8 = (int64x2_t)vmulq_f64(v7, v7);
    float64x2_t v9 = vsubq_f64(a4, a3);
    int64x2_t v10 = (int64x2_t)vmulq_f64(v9, v9);
    float64x2_t v11 = vsqrtq_f64(vaddq_f64((float64x2_t)vzip1q_s64(v10, v8), (float64x2_t)vzip2q_s64(v10, v8)));
    if (COERCE_UNSIGNED_INT64(vaddvq_f64(v11)) >> 52 <= 0x7FE)
    {
      unint64_t v12 = 0;
      double v13 = v11.f64[1];
      double v14 = 1.0;
      uint64_t v15 = 1024;
      double v16 = 0.0;
      while (1)
      {
        float64x2_t v17 = vsubq_f64(a3, a2);
        double v18 = sqrt(vaddvq_f64(vmulq_f64(v17, v17)));
        float64x2_t v19 = vsubq_f64(a4, a1);
        double v20 = sqrt(vaddvq_f64(vmulq_f64(v19, v19)));
        double v21 = v11.f64[0] + v13 + v18;
        if (v12 > 0x1C
          || ((double v22 = vabdd_f64(v13, v18) + vabdd_f64(v18, v11.f64[0]), v21 - v20 <= v14 * a6)
            ? (_NF = v22 < a6)
            : (_NF = 0),
              _NF))
        {
          double v35 = (v21 + v20) * 0.5;
          double v36 = v35 + v16;
          if (v35 + v16 >= a5) {
            return fmin(v14 * (a5 - v16) / v35 + v6, 1.0);
          }
          if (!v12) {
            return 1.0;
          }
          --v12;
          double v6 = v14 + v6;
          char v37 = (float64x2_t *)&v39[6 * v12];
          a1 = *v37;
          a2 = v37[1];
          a3 = v37[2];
          a4 = v37[3];
          double v13 = v37[4].f64[0];
          v11.f64[0] = v37[4].f64[1];
          double v14 = v37[5].f64[0];
          double v16 = v36;
        }
        else
        {
          double v14 = v14 * 0.5;
          int v24 = (float64x2_t *)&v39[6 * v12];
          v24[5].f64[0] = v14;
          __asm { FMOV            V21.2D, #0.5 }
          float32x2_t v24[2] = vmulq_f64(vaddq_f64(a3, a4), _Q21);
          float64x2_t v24[3] = a4;
          __asm
          {
            FMOV            V20.2D, #2.0
            FMOV            V24.2D, #3.0
          }
          float64x2_t v31 = vmlaq_f64(vaddq_f64(a1, a4), _Q24, vaddq_f64(a2, a3));
          __asm { FMOV            V23.2D, #0.25 }
          float64x2_t v33 = vmulq_f64(vaddq_f64(vmlaq_f64(a4, _Q20, a3), a2), _Q23);
          __asm { FMOV            V3.2D, #0.125 }
          a4 = vmulq_f64(v31, _Q3);
          *int v24 = a4;
          v24[1] = v33;
          a3 = vmulq_f64(vaddq_f64(vmlaq_f64(a3, _Q20, a2), a1), _Q23);
          a2 = vmulq_f64(vaddq_f64(a1, a2), _Q21);
          _Q20.f64[0] = v11.f64[0] * 0.5;
          double v13 = v13 * 0.5;
          float64x2_t v11 = vsubq_f64(a4, a3);
          v11.f64[0] = sqrt(vaddvq_f64(vmulq_f64(v11, v11)));
          v24[4].f64[0] = v11.f64[0];
          v24[4].f64[1] = _Q20.f64[0];
          ++v12;
        }
        if (!--v15) {
          return 1.0;
        }
      }
    }
  }
  return v6;
}

float64x2_t CG::Cubic::split@<Q0>(float64x2_t *this@<X0>, double a2@<D0>, float64x2_t *a3@<X8>)
{
  float64x2_t v4 = *this;
  float64x2_t v3 = this[1];
  float64x2_t v5 = vmulq_n_f64(vsubq_f64(v3, *this), a2);
  float64x2_t v6 = vaddq_f64(v5, *this);
  float64x2_t v7 = this[2];
  float64x2_t v8 = this[3];
  float64x2_t v9 = vmlaq_n_f64(v3, vsubq_f64(v7, v3), a2);
  float64x2_t v10 = vmlaq_n_f64(v7, vsubq_f64(v8, v7), a2);
  float64x2_t v11 = vmulq_n_f64(vsubq_f64(v9, v6), a2);
  float64x2_t v12 = vaddq_f64(v11, v6);
  float64x2_t v13 = vmlaq_n_f64(v9, vsubq_f64(v10, v9), a2);
  a3[1] = v6;
  a3[2] = v12;
  float64x2_t v14 = vsubq_f64(v5, v12);
  float64x2_t v15 = vmlaq_n_f64(v12, vsubq_f64(v13, v12), a2);
  *a3 = v4;
  __asm { FMOV            V0.2D, #3.0 }
  a3[3] = v15;
  a3[4] = vmulq_f64(v5, _Q0);
  a3[5] = vmulq_f64(vsubq_f64(v11, v5), _Q0);
  a3[6] = vaddq_f64(vsubq_f64(v14, vaddq_f64(v11, v11)), v15);
  a3[7] = v15;
  a3[8] = v13;
  a3[9] = v10;
  a3[10] = v8;
  float64x2_t v21 = vsubq_f64(v13, v15);
  float64x2_t v22 = vsubq_f64(v10, v13);
  a3[11] = vmulq_f64(v21, _Q0);
  a3[12] = vmulq_f64(vsubq_f64(v22, v21), _Q0);
  float64x2_t result = vaddq_f64(vsubq_f64(vsubq_f64(v8, v10), vaddq_f64(v22, v22)), v21);
  a3[13] = result;
  return result;
}

double CG::Cubic::inflection_points_classic(CG::Cubic *this)
{
  double v1 = *((double *)this + 12);
  if (v1 == 0.0
    || ((double v2 = *((double *)this + 10), v3 = v1 * 3.0, v4 = -v2, v2 < 0.0) ? (v5 = v3 <= v4) : (v5 = 1),
        v5 && (v2 > 0.0 ? (BOOL v6 = v3 < v4) : (BOOL v6 = 0), !v6)))
  {
    char v7 = 1;
    double result = -1.0;
  }
  else
  {
    char v7 = 0;
    double result = v4 / v3;
  }
  double v9 = *((double *)this + 13);
  if (v9 != 0.0)
  {
    double v10 = *((double *)this + 11);
    double v11 = v9 * 3.0;
    double v12 = -v10;
    BOOL v13 = v10 >= 0.0 || v11 <= v12;
    if (!v13 || (v10 > 0.0 ? (BOOL v14 = v11 < v12) : (BOOL v14 = 0), v14))
    {
      double v15 = v12 / v11;
      if (v7)
      {
        return v15;
      }
      else if (vabdd_f64(result, v15) >= 0.000001 && result >= v15)
      {
        return v15;
      }
    }
  }
  return result;
}

uint64_t CG::Cubic::is_near(float64x2_t *this, const Point *a2, double a3, double a4)
{
  double v4 = a4 * a4;
  float64x2_t v5 = this[4];
  float64x2_t v6 = this[5];
  float64x2_t v7 = this[6];
  float64x2_t v8 = vsubq_f64(*this, *(float64x2_t *)&a2->v);
  float64x2_t v9 = vmlaq_f64(v8, (float64x2_t)0, vmlaq_f64(v5, (float64x2_t)0, vmlaq_f64(v6, (float64x2_t)0, v7)));
  float64x2_t v10 = vmulq_f64(v9, v9);
  if (vaddvq_f64(v10) < a4 * a4) {
    return 1;
  }
  float64x2_t v11 = vaddq_f64(vaddq_f64(v5, v8), vaddq_f64(v6, v7));
  float64x2_t v12 = vmulq_f64(v11, v11);
  if (vaddvq_f64(v12) < v4) {
    return 1;
  }
  float64x2_t v13 = vmlaq_n_f64(v8, vmlaq_n_f64(v5, vmlaq_n_f64(v6, v7, a3), a3), a3);
  float64x2_t v14 = vmulq_f64(v13, v13);
  double v15 = vaddvq_f64(v14);
  if (v15 < v4) {
    return 1;
  }
  float64x2_t v17 = vaddq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v14, 1), v14);
  if ((vmovn_s64((int64x2_t)vbicq_s8(vmvnq_s8((int8x16_t)vcgeq_f64(v17, vaddq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v10, 1), v10))), (int8x16_t)vcgeq_f64(v17, vaddq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v12, 1), v12)))).u8[0] & 1) == 0)return 0; {
  double v18 = &color_symbols(void)::flag;
  }
  {
    double v40 = v15;
    double v41 = v4;
    float64x2_t v39 = v5;
    float64x2_t v37 = v7;
    float64x2_t v38 = v6;
    double v35 = a3;
    float64x2_t v36 = v8;
    a3 = v35;
    float64x2_t v8 = v36;
    float64x2_t v7 = v37;
    float64x2_t v6 = v38;
    float64x2_t v5 = v39;
    double v18 = &color_symbols(void)::flag;
    double v15 = v40;
    double v4 = v41;
    if (v34)
    {
      CG::Cubic::is_near(CG::Point const&,double,double)const::G = 0x3FE3C6EF372FE950;
      a3 = v35;
      float64x2_t v8 = v36;
      float64x2_t v7 = v37;
      float64x2_t v6 = v38;
      float64x2_t v5 = v39;
      double v18 = &color_symbols(void)::flag;
      double v15 = v40;
      double v4 = v41;
    }
  }
  double v19 = *((double *)v18 + 8);
  double v20 = 1.0 - v19;
  if (a3 <= 0.5)
  {
    double v21 = a3;
    double v24 = a3 + v20 * (1.0 - a3);
    float64x2_t v25 = vmlaq_n_f64(v8, vmlaq_n_f64(v5, vmlaq_n_f64(v6, v7, v24), v24), v24);
    float64x2_t v26 = vmulq_f64(v25, v25);
    double v23 = v15;
    double v15 = vaddvq_f64(v26);
    a3 = v24;
    if (v15 >= v4) {
      goto LABEL_12;
    }
    return 1;
  }
  double v21 = a3 - v20 * a3;
  float64x2_t v22 = vmlaq_n_f64(v8, vmlaq_n_f64(v5, vmlaq_n_f64(v6, v7, v21), v21), v21);
  double v23 = vaddvq_f64(vmulq_f64(v22, v22));
  if (v23 < v4) {
    return 1;
  }
LABEL_12:
  double v27 = 1.0;
  if ((a3 + v21) * 0.00000003 >= 1.0) {
    return 0;
  }
  double v28 = 0.0;
  uint64_t result = 0;
  do
  {
    if (v15 >= v23)
    {
      double v27 = a3;
      float64x2_t v30 = vmlaq_n_f64(v8, vmlaq_n_f64(v5, vmlaq_n_f64(v6, v7, v28 + v19 * (v21 - v28)), v28 + v19 * (v21 - v28)), v28 + v19 * (v21 - v28));
      double v15 = vaddvq_f64(vmulq_f64(v30, v30));
      a3 = v28 + v19 * (v21 - v28);
      if (v15 <= v4) {
        return 1;
      }
    }
    else
    {
      double v28 = v21;
      double v21 = v27 + v19 * (a3 - v27);
      float64x2_t v29 = vmlaq_n_f64(v8, vmlaq_n_f64(v5, vmlaq_n_f64(v6, v7, v21), v21), v21);
      double v23 = vaddvq_f64(vmulq_f64(v29, v29));
      if (v23 <= v4) {
        return 1;
      }
    }
    double v31 = v15;
    double v32 = a3;
    double v33 = (v21 + a3) * 0.00000003;
    double v15 = v23;
    double v23 = v31;
    a3 = v21;
    double v21 = v32;
  }
  while (v27 - v28 > v33);
  return result;
}

void RBShapeData::~RBShapeData(RBShapeData *this)
{
  this->type = 0;
}

uint64_t RBShapeData::set_rendering_mode(uint64_t result, char a2)
{
  uint64_t v2 = result;
  switch(*(_DWORD *)result)
  {
    case 1:
      uint64_t v3 = result + 16;
      uint64_t result = RB::Coverage::Primitive::set_rendering_mode(v3, a2);
      break;
    case 2:
      *(unsigned char *)(result + 45) = a2;
      break;
    case 3:
      uint64_t result = rb_clip_mode(a2);
      *(unsigned char *)(v2 + 92) = result;
      break;
    case 5:
      uint64_t result = rb_clip_mode(a2);
      *(unsigned char *)(v2 + 52) = result;
      break;
    default:
      return result;
  }
  return result;
}

id *RBStrokeRef::map(id *result, uint64_t a2, uint64_t (**a3)(void), float64x2_t a4, float32x2_t a5, double a6, uint64_t a7, uint64_t a8)
{
  if (*result)
  {
    float64x2_t v13 = result;
    float64x2_t v34 = a4;
    int32x4_t v14 = *(int32x4_t *)(a8 + 16);
    float64x2_t v37 = *(float64x2_t *)a8;
    int32x4_t v38 = v14;
    float64x2_t v39 = *(float64x2_t *)(a8 + 32);
    if (RB::AffineTransform::invert((RB::AffineTransform *)&v37)) {
      double v15 = &v37;
    }
    else {
      double v15 = (float64x2_t *)a8;
    }
    int32x4_t v16 = (int32x4_t)v15[1];
    float64x2_t v17 = v15[2];
    float64x2_t v37 = *v15;
    int32x4_t v38 = v16;
    float64x2_t v39 = v17;
    *(double *)v16.i64 = a6;
    double v35 = COERCE_DOUBLE(RB::operator*(&v37, a5, v16));
    float32x2_t v36 = v18;
    [*v13 borderWidth];
    v20.f32[0] = -v19;
    RB::Rect::inset((float32x2_t *)&v35, v20, v20.f32[0]);
    uint64_t v21 = objc_opt_respondsToSelector();
    float v22 = 1.0;
    if (v21)
    {
      uint64_t v21 = objc_msgSend(*v13, "maxLineWidth", *(_OWORD *)&v34);
      float v22 = v23;
    }
    id v24 = *v13;
    double v25 = v35;
    float32x2_t v26 = v36;
    char v27 = *(unsigned char *)(a2 + 33);
    char v28 = *(unsigned char *)(a2 + 34);
    float v29 = *(float *)(a2 + 40);
    float v30 = RB::bezier_flatness((RB *)v21);
    float v31 = RB::AffineTransform::scale((float64x2_t *)a8);
    float32x2_t v32 = vrecpe_f32((float32x2_t)LODWORD(v31));
    float32x2_t v33 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v31), v32), v32);
    return (id *)RB::Stroke::flatten_points(v24, a3, v27, v28, v34, v25, v26, v29, v30 * vmul_f32(v33, vrecps_f32((float32x2_t)LODWORD(v31), v33)).f32[0], v22);
  }
  return result;
}

void **RBStrokeRef::map(void **result, __n128 a2, float32x2_t a3, double a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float64x2_t v8 = *result;
  if (*result)
  {
    int32x4_t v13 = *(int32x4_t *)(a8 + 16);
    float64x2_t v35 = *(float64x2_t *)a8;
    int32x4_t v36 = v13;
    float64x2_t v37 = *(float64x2_t *)(a8 + 32);
    if (RB::AffineTransform::invert((RB::AffineTransform *)&v35)) {
      int32x4_t v14 = &v35;
    }
    else {
      int32x4_t v14 = (float64x2_t *)a8;
    }
    int32x4_t v15 = (int32x4_t)v14[1];
    float64x2_t v16 = v14[2];
    float64x2_t v35 = *v14;
    int32x4_t v36 = v15;
    float64x2_t v37 = v16;
    *(double *)v15.i64 = a4;
    float32x2_t v45 = RB::operator*(&v35, a3, v15);
    float32x2_t v46 = v17;
    [v8 borderWidth];
    v19.f32[0] = -v18;
    RB::Rect::inset(&v45, v19, v19.f32[0]);
    uint64_t v20 = [v8 imageCount];
    int v21 = [v8 seed];
    if (v21) {
      int v22 = v21;
    }
    else {
      int v22 = 90911;
    }
    *(float32x2_t *)&v37.f64[0] = vadd_f32(v46, v45);
    LOBYTE(v37.f64[1]) = 0;
    __asm { FMOV            V0.2S, #1.0 }
    uint64_t v38 = _D0;
    uint64_t v39 = 1065353216;
    uint64_t v40 = 0;
    uint64_t v41 = 0;
    uint64_t v42 = 1065353216;
    int v43 = v22;
    int v44 = 0;
    char v28 = (RB *)objc_msgSend(v8, "rotatesImage", *(_OWORD *)&a2, &unk_26C4EDB68, a6, v20, *(void *)&v45, *(_OWORD *)&v37);
    LOBYTE(v37.f64[1]) = (_BYTE)v28;
    float v29 = RB::bezier_flatness(v28);
    float v30 = RB::AffineTransform::scale((float64x2_t *)a8);
    float32x2_t v31 = vrecpe_f32((float32x2_t)LODWORD(v30));
    float32x2_t v32 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v30), v31), v31);
    return (void **)RB::Stroke::flatten_particles(v8, &v35, v34, -5.48612406e303, (float32x2_t)0x7F7FFFFF7F7FFFFFLL, v29 * vmul_f32(v32, vrecps_f32((float32x2_t)LODWORD(v30), v32)).f32[0], 1.0);
  }
  return result;
}

uint64_t RBStrokeRef::can_mix(void *a1, void *a2)
{
  return 4 * (*a1 == *a2);
}

void *RBStrokeRef::prepare(void **this, uint64_t **a2)
{
  uint64_t result = *this;
  if (result)
  {
    uint64_t result = (void *)[result image];
    if (result)
    {
      v9[0] = 0;
      __asm { FMOV            V0.2S, #1.0 }
      v9[1] = _D0;
      uint64_t v9[2] = 0;
      void v9[3] = 0;
      long long v10 = xmmword_214218320;
      long long v11 = xmmword_214218320;
      int v12 = 1065353216;
      uint64_t v13 = 0x3C003C003C003C00;
      int v14 = 50331648;
      return (void *)RBMakeCachedImageTexture(a2, (CGImage *)result, (const RB::Fill::ImageData *)v9, 0, 0);
    }
  }
  return result;
}

uint64_t *RBStrokeRef::texture(id *this, uint64_t **a2, unint64_t *a3, float *a4)
{
  id v4 = *this;
  if (!*this) {
    return 0;
  }
  *a3 = [*this imageCount];
  [v4 imageScale];
  *(_DWORD *)a4 = v7;
  uint64_t result = (uint64_t *)[v4 image];
  if (result)
  {
    v14[0] = 0;
    __asm { FMOV            V0.2S, #1.0 }
    v14[1] = _D0;
    void v14[2] = 0;
    _OWORD v14[3] = 0;
    long long v15 = xmmword_214218320;
    long long v16 = xmmword_214218320;
    int v17 = 1065353216;
    uint64_t v18 = 0x3C003C003C003C00;
    int v19 = 0;
    return RBGetCachedImageTexture(a2, (CGImage *)result, (const RB::Fill::ImageData *)v14, 0, 0);
  }
  return result;
}

uint64_t *RBStrokeRef::prepare_encode(uint64_t *result, uint64_t a2, uint64_t *a3)
{
  if (*(unsigned char *)(a2 + 32) == 1)
  {
    uint64_t result = (uint64_t *)*result;
    if (result)
    {
      id v4 = (uint64_t *)[result image];
      return RB::Encoder::prepare_image(a3, 0, v4);
    }
  }
  return result;
}

void RBStrokeRef::encode(id *a1, uint64_t a2, RB::ProtobufEncoder *this)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  id v6 = *a1;
  if (v6)
  {
    int v21 = 0;
    unint64_t v22 = 0;
    long long v25 = 0u;
    uint64_t v23 = 64;
    uint64_t v26 = 384;
    [v6 applyFunction:RBStrokeRef::encode(RB::Coverage::Stroke<RBStrokeRef> const&,RB::Encoder &)const::$_0::__invoke info:v20];
    unint64_t v7 = v22;
    if (v22)
    {
      float64x2_t v8 = v21;
      RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
      if (v8) {
        float64x2_t v9 = v8;
      }
      else {
        float64x2_t v9 = v20;
      }
      RB::ProtobufEncoder::encode_data(this, v9, v7);
    }
    if (*((void *)&v25 + 1))
    {
      if ((void)v25) {
        long long v10 = (const unsigned int *)v25;
      }
      else {
        long long v10 = (const unsigned int *)&v24;
      }
      RB::ProtobufEncoder::packed_fixed32_field(this, 2, v10, *((uint64_t *)&v25 + 1));
    }
    if ((void)v25) {
      free((void *)v25);
    }
    if (v21) {
      free(v21);
    }
  }
  if (*(unsigned char *)(a2 + 36) == 1)
  {
    RB::ProtobufEncoder::encode_varint(this, 0x18uLL);
    RB::ProtobufEncoder::encode_varint(this, 1uLL);
  }
  if (*(unsigned char *)(a2 + 32) == 1)
  {
    RB::ProtobufEncoder::encode_varint(this, 0x2AuLL);
    RB::ProtobufEncoder::begin_length_delimited(this);
    int v14 = rb_alpha_blend_mode(*(unsigned __int8 *)(a2 + 35));
    if (v14)
    {
      RB::ProtobufEncoder::encode_varint(this, 8uLL);
      RB::ProtobufEncoder::encode_varint(this, v14);
    }
    id v15 = *a1;
    if (*a1)
    {
      RB::Encoder::image_field(this, 2, 0, (uint64_t *)[*a1 image]);
      unint64_t v16 = [v15 imageCount];
      if (v16 != 1)
      {
        RB::ProtobufEncoder::encode_varint(this, 0x18uLL);
        RB::ProtobufEncoder::encode_varint(this, v16);
      }
      [v15 imageScale];
      int v18 = LODWORD(v17);
      if (v17 != 1.0)
      {
        RB::ProtobufEncoder::encode_varint(this, 0x25uLL);
        RB::ProtobufEncoder::encode_fixed32(this, v18);
      }
      if ([v15 rotatesImage])
      {
        RB::ProtobufEncoder::encode_varint(this, 0x28uLL);
        RB::ProtobufEncoder::encode_varint(this, 1uLL);
      }
      uint64_t v19 = [v15 seed];
      if (v19)
      {
        RB::ProtobufEncoder::encode_varint(this, 0x31uLL);
        RB::ProtobufEncoder::encode_fixed64(this, v19);
      }
    }
  }
  else
  {
    if (*(unsigned char *)(a2 + 32)) {
      return;
    }
    RB::ProtobufEncoder::encode_varint(this, 0x22uLL);
    RB::ProtobufEncoder::begin_length_delimited(this);
    int v11 = rb_line_cap(*(unsigned __int8 *)(a2 + 33));
    if (v11 != 1)
    {
      RB::ProtobufEncoder::encode_varint(this, 8uLL);
      RB::ProtobufEncoder::encode_varint(this, v11);
    }
    int v12 = RBStrokeRef::clip(*(unsigned __int8 *)(a2 + 34));
    if (v12 != 1)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x10uLL);
      RB::ProtobufEncoder::encode_varint(this, v12);
    }
    int v13 = *(int *)(a2 + 40);
    if (*(float *)&v13 != 10.0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1DuLL);
      RB::ProtobufEncoder::encode_fixed32(this, v13);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
}

void sub_21414F650(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  RBStrokeRef::encode(RB::Coverage::Stroke<RBStrokeRef> const&,RB::Encoder &)const::StrokeData::~StrokeData((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t RBStrokeRef::encode(RB::Coverage::Stroke<RBStrokeRef> const&,RB::Encoder &)const::StrokeData::~StrokeData(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 1624);
  if (v2) {
    free(v2);
  }
  uint64_t v3 = *(void **)(a1 + 64);
  if (v3) {
    free(v3);
  }
  return a1;
}

void RBStrokeRef::decode(id *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  id v6 = objc_opt_new();
  uint64_t v7 = 0;
  float64x2_t v8 = 0;
  long long v32 = 0u;
  unint64_t v33 = 384;
  while (1)
  {
    unint64_t field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a3);
    char v10 = field;
    if (!field) {
      break;
    }
    switch((field >> 3))
    {
      case 1u:
        uint64_t v22 = RB::ProtobufDecoder::data_field((RB::ProtobufDecoder *)a3, field);
        if (v22)
        {
          uint64_t v7 = v23;
          float64x2_t v8 = (unsigned __int8 *)v22;
        }
        break;
      case 2u:
        float v11 = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)a3, field);
        uint64_t v12 = *((void *)&v32 + 1);
        size_t v13 = *((void *)&v32 + 1) + 1;
        if (v33 < *((void *)&v32 + 1) + 1)
        {
          RB::vector<float,384ul,unsigned long>::reserve_slow(__dst, v13);
          uint64_t v12 = *((void *)&v32 + 1);
          size_t v13 = *((void *)&v32 + 1) + 1;
        }
        int v14 = (unsigned char *)v32;
        if (!(void)v32) {
          int v14 = __dst;
        }
        *(float *)&v14[4 * v12] = v11;
        *((void *)&v32 + 1) = v13;
        break;
      case 3u:
        *(unsigned char *)(a2 + 36) = RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)a3, field);
        break;
      case 4u:
        *(unsigned char *)(a2 + 32) = 0;
        [v6 setStrokeType:0];
        id v15 = v6;
        if ((v10 & 7) != 2) {
          goto LABEL_38;
        }
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a3);
        for (unint64_t i = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a3);
              i;
              unint64_t i = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a3))
        {
          unint64_t v17 = i >> 3;
          if ((i >> 3) == 3)
          {
            *(float *)&double v18 = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)a3, i);
            [v15 setMiterLimit:v18];
          }
          else if (v17 == 2)
          {
            objc_msgSend(v15, "setLineJoin:", RB::ProtobufDecoder::uint_field((uint64_t **)a3, i));
          }
          else if (v17 == 1)
          {
            objc_msgSend(v15, "setLineCap:", RB::ProtobufDecoder::uint_field((uint64_t **)a3, i));
          }
          else
          {
            RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)a3, i);
          }
        }
        goto LABEL_34;
      case 5u:
        *(unsigned char *)(a2 + 32) = 1;
        [v6 setStrokeType:1];
        id v15 = v6;
        if ((v10 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a3);
          for (unint64_t j = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a3);
                j;
                unint64_t j = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a3))
          {
            switch((j >> 3))
            {
              case 1u:
                objc_msgSend(v15, "setBlendMode:", RB::ProtobufDecoder::uint_field((uint64_t **)a3, j));
                break;
              case 2u:
                if (!RB::Decoder::image_field((RB::ProtobufDecoder *)a3, j)) {
                  [v15 setImage:v20];
                }
                break;
              case 3u:
                objc_msgSend(v15, "setImageCount:", RB::ProtobufDecoder::uint_field((uint64_t **)a3, j));
                break;
              case 4u:
                *(float *)&double v21 = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)a3, j);
                [v15 setImageScale:v21];
                break;
              case 5u:
                objc_msgSend(v15, "setRotatesImage:", RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)a3, j));
                break;
              case 6u:
                objc_msgSend(v15, "setSeed:", RB::ProtobufDecoder::uint_field((uint64_t **)a3, j));
                break;
              default:
                RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)a3, j);
                break;
            }
          }
LABEL_34:
          RB::ProtobufDecoder::end_message(a3);
        }
        else
        {
LABEL_38:
          *(unsigned char *)(a3 + 56) = 1;
          *(void *)a3 = *(void *)(a3 + 8);
        }

        break;
      default:
        RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)a3, field);
        break;
    }
  }
  if (v7)
  {
    uint64_t v24 = (void)v32 ? (unsigned char *)v32 : __dst;
    unint64_t v25 = *((void *)&v32 + 1);
    while (1)
    {
      unsigned int v27 = *v8++;
      unint64_t v26 = v27;
      if (v25 < (unint64_t)v27 >> 5) {
        break;
      }
      unint64_t v28 = v26 >> 5;
      if ((v26 & 0x1F) <= 0xF && RB::Stroke::element_args(RBStrokeElement)::elts[v26 & 0x1F] <= v28) {
        objc_msgSend(v6, "addElement:args:");
      }
      v25 -= v28;
      v24 += 4 * v28;
      if (!--v7)
      {
        if (!v25) {
          goto LABEL_51;
        }
        goto LABEL_50;
      }
    }
    *(unsigned char *)(a3 + 56) = 1;
    *(void *)a3 = *(void *)(a3 + 8);
    if (v25)
    {
LABEL_50:
      *(unsigned char *)(a3 + 56) = 1;
      *(void *)a3 = *(void *)(a3 + 8);
    }
  }
LABEL_51:
  if (*(unsigned char *)(a2 + 32))
  {
    if (*(unsigned char *)(a2 + 32) == 1)
    {
      *(unsigned char *)(a2 + 35) = rb_alpha_blend_mode([v6 blendMode]);
      if (![v6 image])
      {
        *(unsigned char *)(a3 + 56) = 1;
        *(void *)a3 = *(void *)(a3 + 8);
      }
    }
  }
  else
  {
    *(unsigned char *)(a2 + 33) = rb_line_cap([v6 lineCap]);
    *(unsigned char *)(a2 + 34) = rb_line_join((CGLineJoin)[v6 lineJoin]);
    [v6 miterLimit];
    *(_DWORD *)(a2 + 40) = v29;
  }
  id v30 = (id)[v6 commit];
  if (*a1 != v30)
  {

    *a1 = v30;
  }
  if ((void)v32) {
    free((void *)v32);
  }
}

void sub_21414FB6C(_Unwind_Exception *a1)
{
  if (STACK[0x608]) {
    free((void *)STACK[0x608]);
  }

  _Unwind_Resume(a1);
}

id *RBStrokeRef::attributes(id *result)
{
  if (*result)
  {
    *result;
    RB::XML::Element::set<RB::XML::Value::Stroke>();
  }
  return result;
}

void sub_21414FF80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id a11, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void RB::XML::Element::set<RB::XML::Value::Stroke>()
{
}

void sub_214150068(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x81C40803F642BLL);
  _Unwind_Resume(a1);
}

void RB::XML::Element::set<RB::XML::Value::StrokeType>()
{
}

void RB::XML::Element::set<RB::XML::Value::Image>()
{
}

void sub_214150204(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10C1C404DF0DBB8);
  _Unwind_Resume(a1);
}

void RB::XML::Element::set<RB::XML::Value::AlphaBlendMode>()
{
}

void set_rounded_rect(uint64_t a1, int a2, float64_t a3, float64_t a4, float64_t a5, float64_t a6, float64_t a7, float64_t a8, float64_t a9, float64_t a10, double a11)
{
  v34.f64[0] = a3;
  v34.f64[1] = a4;
  v35.f64[0] = a5;
  v35.f64[1] = a6;
  v32.f64[0] = a7;
  v32.f64[1] = a8;
  v33.f64[0] = a9;
  v33.f64[1] = a10;
  RB::clamp_corner_radii((uint64_t)&v32, v35.f64);
  float64x2_t v19 = v33;
  float64x2_t v20 = v32;
  float64x2_t v21 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v32.f64[0], 0);
  int64x2_t v22 = (int64x2_t)vandq_s8((int8x16_t)vceqq_f64(v32, v21), (int8x16_t)vceqq_f64(v33, v21));
  float64x2_t v23 = (float64x2_t)vandq_s8((int8x16_t)v22, (int8x16_t)vdupq_laneq_s64(v22, 1));
  if ((*(void *)&v23.f64[0] & 0x8000000000000000) != 0)
  {
    v19.f64[0] = v34.f64[0];
    v23.f64[0] = v35.f64[0];
    set_rounded_rect(a1, a2, v19, v34.f64[1], v23, v35.f64[1], v32.f64[0], v32.f64[0], a11);
  }
  else
  {
    if (a2)
    {
      if (a2 != 1) {
        abort();
      }
      float64x2_t v24 = (float64x2_t)vdupq_n_s64(0x3FF4666660000000uLL);
      float64x2_t v19 = vmulq_f64(v33, v24);
      float64x2_t v20 = vmulq_f64(v32, v24);
      char v25 = 4;
    }
    else
    {
      char v25 = 3;
    }
    float32x2_t v26 = vcvt_f32_f64(v34);
    float32x2_t v27 = vcvt_f32_f64(v35);
    float32x4_t v31 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v20), v19);
    int v28 = *(_DWORD *)(a1 + 428);
    RBShapeData::apply<RB::DestroyAny>((int *)(a1 + 16));
    float v29 = a11;
    float v30 = *(double *)(a1 + 432);
    *(float32x2_t *)(a1 + 32) = v26;
    *(float32x2_t *)(a1 + 40) = v27;
    *(float32x4_t *)(a1 + 48) = v31;
    *(_DWORD *)(a1 + 64) = 1065353216;
    *(float *)(a1 + 68) = v29;
    *(float *)(a1 + 72) = v30;
    *(unsigned char *)(a1 + 76) = v25;
    *(unsigned char *)(a1 + 77) = v28;
    *(unsigned char *)(a1 + 78) &= 0xF8u;
    *(_DWORD *)(a1 + 16) = 1;
  }
}

void sub_214151318(_Unwind_Exception *exception_object)
{
  if (v2) {
    free(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_2141515B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

unint64_t RBShapeData::decode(RBShapeData *this, RB::Decoder *a2)
{
  unint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    unint64_t v5 = result;
    id v6 = &this->data[12];
    int32x2_t v7 = vdup_n_s32(0x7F7FFFFFu);
    while (2)
    {
      switch((v5 >> 3))
      {
        case 1u:
          RBShapeData::apply<RB::DestroyAny>(&this->type);
          *(_OWORD *)id v6 = 0u;
          *(_OWORD *)&this->data[28] = 0u;
          *(void *)&this->data[44] = 1065353216;
          *(_DWORD *)&this->data[52] = 0;
          *(_WORD *)&this->data[56] = 2;
          this->data[58] &= 0xF8u;
          this->type = 1;
          if ((v5 & 7) != 2) {
            goto LABEL_18;
          }
          RB::ProtobufDecoder::begin_message(a2);
          RB::Coverage::Primitive::decode((float32x4_t *)&this->data[12], a2);
          goto LABEL_15;
        case 2u:
          RBShapeData::apply<RB::DestroyAny>(&this->type);
          this->type = 0;
          *(_OWORD *)id v6 = RBPathEmpty;
          *(void *)&this->data[28] = 0;
          *(void *)&this->data[34] = 0;
          this->type = 2;
          if ((v5 & 7) != 2) {
            goto LABEL_18;
          }
          RB::ProtobufDecoder::begin_message(a2);
          RB::Coverage::Path::decode((RB::Coverage::Path *)&this->data[12], a2);
          goto LABEL_15;
        case 3u:
          *(_OWORD *)float64x2_t v9 = RBPathEmpty;
          memset(&v9[2], 0, 32);
          uint64_t v8 = *((void *)a2 + 8);
          RBShapeData::apply<RB::DestroyAny>(&this->type);
          this->type = 0;
          *(void *)&this->data[12] = &unk_26C4EDD48;
          RB::Coverage::StrokeablePath::StrokeablePath(&this->data[20], v9, v8);
          *(void *)&this->data[68] = 0x100000001000000;
          *(int32x2_t *)&this->data[76] = v7;
          *(_DWORD *)&this->data[84] = 251658752;
          LOBYTE(this[1].type) = 0;
          *(_DWORD *)this[1].data = 1092616192;
          this->type = 3;
          RBPathRelease(v9[0], v9[1]);
          if ((v5 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message(a2);
            RB::Coverage::StrokeablePath::decode((uint64_t)&this->data[20], (uint64_t)&this->data[12], (size_t **)a2);
            RB::ProtobufDecoder::end_message((uint64_t)a2);
          }
          else
          {
            *((unsigned char *)a2 + 56) = 1;
            *(void *)a2 = *((void *)a2 + 1);
          }
          goto LABEL_16;
        case 4u:
          RBShapeData::apply<RB::DestroyAny>(&this->type);
          this->type = 0;
          *(void *)&this->data[12] = &unk_26C4EDD28;
          *(void *)&this->data[20] = 0;
          *(void *)&this->data[28] = 0x100000001000000;
          *(int32x2_t *)&this->data[36] = v7;
          *(_DWORD *)&this->data[44] = 251658752;
          this->data[48] = 0;
          *(_DWORD *)&this->data[52] = 1092616192;
          this->type = 5;

          if ((v5 & 7) != 2) {
            goto LABEL_18;
          }
          RB::ProtobufDecoder::begin_message(a2);
          RBStrokeRef::decode((id *)&this->data[20], (uint64_t)&this->data[12], (uint64_t)a2);
          goto LABEL_15;
        case 5u:
          RBShapeData::apply<RB::DestroyAny>(&this->type);
          *(_OWORD *)id v6 = 0u;
          *(_OWORD *)&this->data[28] = 0u;
          *(void *)&this->data[44] = 0x100000001000000;
          *(int32x2_t *)&this->data[52] = v7;
          *(_DWORD *)&this->data[60] = 0;
          *(_WORD *)&this->data[64] = 0;
          this->type = 4;
          if ((v5 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message(a2);
            RB::Coverage::Glyphs::decode((RB::Coverage::Glyphs *)&this->data[12], (size_t **)a2);
LABEL_15:
            RB::ProtobufDecoder::end_message((uint64_t)a2);
          }
          else
          {
LABEL_18:
            *((unsigned char *)a2 + 56) = 1;
            *(void *)a2 = *((void *)a2 + 1);
          }
LABEL_16:
          unint64_t result = RB::ProtobufDecoder::next_field(a2);
          unint64_t v5 = result;
          if (!result) {
            return result;
          }
          continue;
        default:
          RB::ProtobufDecoder::skip_field(a2, v5);
          goto LABEL_16;
      }
    }
  }
  return result;
}

void sub_214151920(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

char *RBStrokeRef::encode(RB::Coverage::Stroke<RBStrokeRef> const&,RB::Encoder &)const::$_0::__invoke(char *result, unsigned __int8 *a2, int *a3, void *__dst)
{
  if (result)
  {
    int32x2_t v7 = result;
    uint64_t v8 = 0;
    do
    {
      unsigned int v10 = *a2++;
      uint64_t v9 = v10;
      if (v10 > 0xFuLL) {
        uint64_t v11 = 0;
      }
      else {
        uint64_t v11 = RB::Stroke::element_args(RBStrokeElement)::elts[v9];
      }
      uint64_t v12 = __dst[9];
      if (__dst[10] < (unint64_t)(v12 + 1))
      {
        unint64_t result = (char *)RB::vector<unsigned char,64ul,unsigned long>::reserve_slow(__dst, v12 + 1);
        uint64_t v12 = __dst[9];
      }
      size_t v13 = (void *)__dst[8];
      if (!v13) {
        size_t v13 = __dst;
      }
      *((unsigned char *)v13 + v12) = v9 | (32 * v11);
      ++__dst[9];
      v8 += v11;
      --v7;
    }
    while (v7);
    if (v8)
    {
      uint64_t v14 = __dst[204];
      if (__dst[205] < (unint64_t)(v14 + v8))
      {
        unint64_t result = (char *)RB::vector<float,384ul,unsigned long>::reserve_slow(__dst + 11, v14 + v8);
        uint64_t v14 = __dst[204];
      }
      id v15 = (char *)__dst[203];
      if (!v15) {
        id v15 = (char *)(__dst + 11);
      }
      unint64_t v16 = &v15[4 * v14];
      uint64_t v17 = v8;
      do
      {
        int v18 = *a3++;
        *(_DWORD *)unint64_t v16 = v18;
        v16 += 4;
        --v17;
      }
      while (v17);
      __dst[204] = v14 + v8;
    }
  }
  return result;
}

void *RB::vector<unsigned char,64ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 10) + (*((void *)__dst + 10) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 10) + (*((void *)__dst + 10) >> 1);
  }
  unint64_t result = RB::details::realloc_vector<unsigned long,1ul>(*((void **)__dst + 8), __dst, 0x40uLL, (size_t *)__dst + 10, v3);
  *((void *)__dst + 8) = result;
  return result;
}

void *RB::vector<float,384ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 194) + (*((void *)__dst + 194) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 194) + (*((void *)__dst + 194) >> 1);
  }
  unint64_t result = RB::details::realloc_vector<unsigned long,4ul>(*((void **)__dst + 192), __dst, 0x180uLL, (size_t *)__dst + 194, v3);
  *((void *)__dst + 192) = result;
  return result;
}

id *RB::Coverage::Stroke<RBStrokeRef>::generate(uint64_t a1, uint64_t (**a2)(void), float64x2_t a3, float32x2_t a4, double a5, uint64_t a6, uint64_t a7)
{
  return RBStrokeRef::map((id *)(a1 + 8), a1, a2, a3, a4, a5, a7, a7);
}

void **RB::Coverage::Stroke<RBStrokeRef>::generate(uint64_t a1, uint64_t a2, __n128 a3, float32x2_t a4, double a5, uint64_t a6, uint64_t a7)
{
  return RBStrokeRef::map((void **)(a1 + 8), a3, a4, a5, a2, a2, a7, a7);
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Stroke,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_214151B8C(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Stroke *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Stroke>,std::allocator<RB::XML::Value::Stroke>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Stroke *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Stroke>,std::allocator<RB::XML::Value::Stroke>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::StrokeType,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_214151C7C(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::StrokeType *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::StrokeType>,std::allocator<RB::XML::Value::StrokeType>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::StrokeType *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::StrokeType>,std::allocator<RB::XML::Value::StrokeType>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Image,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_214151D6C(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Image *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Image>,std::allocator<RB::XML::Value::Image>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Image *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Image>,std::allocator<RB::XML::Value::Image>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::AlphaBlendMode,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_214151E5C(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::AlphaBlendMode *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::AlphaBlendMode>,std::allocator<RB::XML::Value::AlphaBlendMode>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::AlphaBlendMode *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::AlphaBlendMode>,std::allocator<RB::XML::Value::AlphaBlendMode>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

float32x2_t RB::Coverage::Stroke<RBStrokeRef>::bounds(void *a1, float64x2_t *a2, double a3, int32x4_t a4)
{
  a4.i64[0] = a1[3];
  uint32x2_t v6 = (uint32x2_t)vcge_f32((float32x2_t)(a4.i64[0] & 0x7FFFFFFF7FFFFFFFLL), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  if ((vpmax_u32(v6, v6).u32[0] & 0x80000000) != 0)
  {
    uint64_t v8 = (void *)a1[1];
    if (v8)
    {
      [v8 boundingRect];
      *(void *)&v9.f64[1] = a4.i64[0];
      float32x2_t v7 = vcvt_f32_f64(v9);
      v11.f64[1] = v10;
      *(float32x2_t *)a4.i8 = vcvt_f32_f64(v11);
    }
    else
    {
      a4.i64[0] = 0;
      float32x2_t v7 = 0;
    }
    a1[2] = v7;
    a1[3] = a4.i64[0];
  }
  else
  {
    float32x2_t v7 = (float32x2_t)a1[2];
  }
  return RB::operator*(a2, v7, a4);
}

BOOL RB::pixel_formats_support_view_copy(RB *this, RB *a2, MTLPixelFormat a3)
{
  if (this == a2) {
    return 1;
  }
  uint32x2_t v6 = RB::pixel_format_traits((unint64_t)this, (MTLPixelFormat)a2);
  BOOL result = 1;
  if ((~((unint64_t)*((unsigned __int16 *)v6 + 2) << 32) & 0x3000000000) != 0 || (RB *)v6[6] != a2)
  {
    uint64_t v8 = RB::pixel_format_traits((unint64_t)a2, v7);
    if ((~((unint64_t)*((unsigned __int16 *)v8 + 2) << 32) & 0x3000000000) != 0 || (RB *)v8[6] != this) {
      return 0;
    }
  }
  return result;
}

uint64_t RB::pixel_format_from_four_cc(int a1, MTLPixelFormat a2, unsigned char *a3, unsigned char *a4, char *a5)
{
  unint64_t v6 = 0;
  *a3 = 1;
  *a4 = 1;
  *a5 = 0;
  unsigned int v7 = (a2 >> 1) & 1;
  int v8 = (a2 >> 2) & 1;
  if (a1 > 1882468911)
  {
    if (a1 > 2016686641)
    {
      if (a1 > 2019964015)
      {
        if (a1 > 2021078067)
        {
          if (a1 > 2037741157)
          {
            if (a1 != 2037741158 && a1 != 2037741171) {
              return v6;
            }
            BOOL v15 = (a2 & 2) == 0;
            uint64_t v16 = 501;
            goto LABEL_100;
          }
          if (a1 != 2021078068)
          {
            int v12 = 2021078128;
            goto LABEL_40;
          }
          goto LABEL_79;
        }
        if (a1 == 2019964016)
        {
LABEL_60:
          BOOL v15 = (a2 & 2) == 0;
          uint64_t v16 = 504;
          goto LABEL_100;
        }
        if (a1 != 2021077552)
        {
          if (a1 != 2021077554) {
            return v6;
          }
          goto LABEL_89;
        }
LABEL_87:
        BOOL v15 = (a2 & 2) == 0;
        uint64_t v16 = 505;
        goto LABEL_100;
      }
      if (a1 > 2019963439)
      {
        if (a1 == 2019963440) {
          goto LABEL_87;
        }
        if (a1 != 2019963442)
        {
          if (a1 != 2019963956) {
            return v6;
          }
          goto LABEL_79;
        }
      }
      else if (a1 != 2016686642)
      {
        if (a1 != 2016687156)
        {
          int v12 = 2016687216;
LABEL_40:
          if (a1 != v12) {
            return v6;
          }
          goto LABEL_60;
        }
LABEL_79:
        BOOL v15 = (a2 & 2) == 0;
        uint64_t v16 = 507;
        goto LABEL_100;
      }
LABEL_89:
      BOOL v15 = (a2 & 2) == 0;
      uint64_t v16 = 506;
      goto LABEL_100;
    }
    if (a1 > 1886859823)
    {
      if (a1 > 1999843441)
      {
        if (a1 == 1999843442)
        {
          if ((a2 & 4) != 0) {
            unint64_t v6 = 554;
          }
          else {
            unint64_t v6 = 0;
          }
          goto LABEL_136;
        }
        if (a1 == 1999908961)
        {
          *a3 = 0;
          BOOL v18 = (a2 & 4) == 0;
          uint64_t v19 = 552;
LABEL_127:
          if (v18) {
            unint64_t v6 = 0;
          }
          else {
            unint64_t v6 = v19;
          }
LABEL_132:
          char v14 = 1;
          if ((a2 & 0x20) == 0) {
            goto LABEL_136;
          }
          goto LABEL_133;
        }
        if (a1 != 2016686640) {
          return v6;
        }
        goto LABEL_87;
      }
      if (a1 != 1886859824)
      {
        if (a1 != 1886859826)
        {
          int v13 = 1886860340;
          goto LABEL_68;
        }
LABEL_88:
        BOOL v15 = (a2 & 2) == 0;
        uint64_t v16 = 509;
        goto LABEL_100;
      }
    }
    else if (a1 > 1885745711)
    {
      if (a1 != 1885745712)
      {
        if (a1 != 1885745714)
        {
          int v13 = 1885746228;
          goto LABEL_68;
        }
        goto LABEL_88;
      }
    }
    else if (a1 != 1882468912)
    {
      if (a1 != 1882468914)
      {
        int v13 = 1882469428;
LABEL_68:
        if (a1 != v13) {
          return v6;
        }
        BOOL v15 = (a2 & 2) == 0;
        uint64_t v16 = 510;
        goto LABEL_100;
      }
      goto LABEL_88;
    }
    BOOL v15 = (a2 & 2) == 0;
    uint64_t v16 = 508;
    goto LABEL_100;
  }
  if (a1 <= 1278226487)
  {
    if (a1 > 875704949)
    {
      if (a1 > 875836533)
      {
        if (a1 != 875836534)
        {
          if (a1 == 1093677112)
          {
            int v8 = 0;
            *a3 = 0;
            char v14 = 1;
            unint64_t v6 = 1;
            if ((a2 & 0x20) == 0) {
              goto LABEL_136;
            }
            goto LABEL_133;
          }
          if (a1 != 1111970369) {
            return v6;
          }
          *a3 = 0;
          char v14 = 1;
          unint64_t v6 = 80;
          goto LABEL_120;
        }
      }
      else
      {
        if (a1 == 875704950)
        {
LABEL_64:
          BOOL v15 = (a2 & 2) == 0;
          uint64_t v16 = 502;
          goto LABEL_100;
        }
        if (a1 == 875836468)
        {
          int v8 = 0;
          *a3 = 0;
          char v14 = 1;
          unint64_t v6 = 42;
          if ((a2 & 0x20) == 0) {
            goto LABEL_136;
          }
          goto LABEL_133;
        }
        if (a1 != 875836518) {
          return v6;
        }
      }
      BOOL v15 = (a2 & 2) == 0;
      uint64_t v16 = 503;
    }
    else
    {
      if (a1 <= 875704421)
      {
        if (a1 == 843264104)
        {
          *a3 = 0;
          if ((a2 & 8) != 0)
          {
            int v8 = 0;
            *a5 = 4;
            char v14 = 3;
            unint64_t v6 = 65;
            if ((a2 & 0x20) == 0) {
              goto LABEL_136;
            }
            goto LABEL_133;
          }
        }
        else
        {
          if (a1 != 843264310)
          {
            int v9 = 846624121;
            BOOL v10 = (a2 & 2) == 0;
            uint64_t v11 = 562;
            goto LABEL_19;
          }
          *a3 = 0;
          if ((a2 & 8) != 0)
          {
            int v8 = 0;
            *a5 = 4;
            char v14 = 3;
            unint64_t v6 = 60;
            if ((a2 & 0x20) == 0) {
              goto LABEL_136;
            }
            goto LABEL_133;
          }
        }
        goto LABEL_131;
      }
      if (a1 != 875704422 && a1 != 875704438)
      {
        if (a1 != 875704934) {
          return v6;
        }
        goto LABEL_64;
      }
      BOOL v15 = (a2 & 2) == 0;
      uint64_t v16 = 500;
    }
LABEL_100:
    if (v15) {
      unint64_t v6 = 0;
    }
    else {
      unint64_t v6 = v16;
    }
LABEL_137:
    if (a2)
    {
      if (v7)
      {
        uint64_t v20 = *(unsigned int *)((char *)RB::pixel_format_traits(v6, a2) + 18);
        if (v20)
        {
          *a4 = 0;
          return v20;
        }
      }
    }
    return v6;
  }
  if (a1 > 1378955370)
  {
    if (a1 > 1380411456)
    {
      if (a1 <= 1647534391)
      {
        if (a1 != 1380411457)
        {
          int v9 = 1599226420;
          BOOL v10 = (a2 & 2) == 0;
          uint64_t v11 = 542;
LABEL_19:
          if (v10) {
            uint64_t v11 = 0;
          }
          if (a1 == v9) {
            return v11;
          }
          else {
            return 0;
          }
        }
        int v8 = 0;
        *a3 = 0;
        char v14 = 1;
        unint64_t v6 = 115;
        if ((a2 & 0x20) == 0) {
          goto LABEL_136;
        }
        goto LABEL_133;
      }
      if (a1 != 1647534392)
      {
        if (a1 != 1815162994) {
          return v6;
        }
        int v8 = 0;
        *a3 = 0;
        char v14 = 1;
        unint64_t v6 = 94;
        if ((a2 & 0x20) == 0) {
          goto LABEL_136;
        }
        goto LABEL_133;
      }
      *a3 = 0;
      BOOL v18 = (a2 & 4) == 0;
      uint64_t v19 = 550;
      goto LABEL_127;
    }
    if (a1 == 1378955371)
    {
      int v8 = 0;
      *a3 = 0;
      char v14 = 1;
      unint64_t v6 = 90;
      if ((a2 & 0x20) == 0) {
        goto LABEL_136;
      }
      goto LABEL_133;
    }
    if (a1 != 1380401729)
    {
      if (a1 != 1380410945) {
        return v6;
      }
      int v8 = 0;
      *a3 = 0;
      char v14 = 1;
      unint64_t v6 = 125;
      if ((a2 & 0x20) == 0) {
        goto LABEL_136;
      }
      goto LABEL_133;
    }
    *a3 = 0;
    char v14 = 1;
    unint64_t v6 = 70;
LABEL_120:
    int v8 = 1;
    if ((a2 & 0x20) == 0) {
      goto LABEL_136;
    }
    goto LABEL_133;
  }
  if (a1 <= 1278555700)
  {
    if (a1 == 1278226488)
    {
      if ((a2 & 0x18) != 8) {
        return (a2 & 0x10) >> 4;
      }
      *a5 = 3;
      unsigned int v7 = (a2 >> 6) & 1;
      unint64_t v6 = 10;
      goto LABEL_137;
    }
    if (a1 == 1278226742)
    {
      if ((a2 & 8) != 0)
      {
        if ((a2 & 0x10) != 0) {
          char v17 = 2;
        }
        else {
          char v17 = 3;
        }
        *a5 = v17;
        return 20;
      }
      return 0;
    }
    if (a1 != 1278555445) {
      return v6;
    }
    int v8 = 0;
    *a3 = 0;
    char v14 = 1;
    unint64_t v6 = 43;
    if ((a2 & 0x20) == 0)
    {
LABEL_136:
      unsigned int v7 = v8;
      goto LABEL_137;
    }
LABEL_133:
    if ((a2 & 8) == 0) {
      return 0;
    }
    *a5 = v14;
    *a3 = 1;
    goto LABEL_136;
  }
  if (a1 == 1278555701) {
    return 40;
  }
  if (a1 == 1279340600 || a1 == 1279342648)
  {
    *a3 = 0;
    if ((a2 & 8) != 0)
    {
      *a5 = 4;
      int v8 = (a2 >> 6) & 1;
      char v14 = 3;
      unint64_t v6 = 30;
      if ((a2 & 0x20) == 0) {
        goto LABEL_136;
      }
      goto LABEL_133;
    }
LABEL_131:
    unint64_t v6 = 0;
    int v8 = 0;
    goto LABEL_132;
  }
  return v6;
}

char *RB::pixel_format_name(RB *this, MTLPixelFormat a2)
{
  if ((unint64_t)this - 0x80000001 >= 0xA) {
    return (char *)(MTLPixelFormatGetName() + 14);
  }
  else {
    return off_2641F84D0[(void)this - 0x80000001];
  }
}

uint64_t RB::anonymous namespace'::create_plane_dict(RB::_anonymous_namespace_ *this, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6, unint64_t *a7)
{
  v17[7] = *MEMORY[0x263EF8340];
  uint64_t v12 = *MEMORY[0x263F0EE70];
  unint64_t v13 = MEMORY[0x21669A8B0](*MEMORY[0x263F0EE70], a3 * (unint64_t)this, a3, a4, a5, a6, a7);
  uint64_t result = 0;
  *a5 = a2 * v13;
  if (is_mul_ok(a2, v13))
  {
    uint64_t v15 = *MEMORY[0x263F0EF10];
    *a5 = MEMORY[0x21669A8B0](*MEMORY[0x263F0EF10]);
    v16[0] = *MEMORY[0x263F0EF20];
    v17[0] = [NSNumber numberWithUnsignedInt:this];
    v16[1] = *MEMORY[0x263F0EEE8];
    v17[1] = [NSNumber numberWithUnsignedInt:a2];
    void v16[2] = v12;
    v17[2] = [NSNumber numberWithUnsignedLong:v13];
    _OWORD v16[3] = *MEMORY[0x263F0EF08];
    void v17[3] = [NSNumber numberWithUnsignedLong:a4];
    v16[4] = v15;
    v17[4] = [NSNumber numberWithUnsignedLong:*a5];
    v16[5] = *MEMORY[0x263F0EEC0];
    v17[5] = [NSNumber numberWithUnsignedInt:1];
    v16[6] = *MEMORY[0x263F0EE68];
    v17[6] = [NSNumber numberWithUnsignedInt:a3];
    return [NSDictionary dictionaryWithObjects:v17 forKeys:v16 count:7];
  }
  return result;
}

uint64_t RB::anonymous namespace'::extended_p3_data(RB::_anonymous_namespace_ *this)
{
  {
    if (v2)
    {
      size_t v3 = (CGColorSpace *)RB::extended_display_p3_colorspace(v2);
    }
  }
}

void sub_2141529A0(_Unwind_Exception *a1)
{
}

uint64_t RB::ColorMode::output_space(RB::ColorMode *this)
{
  if ((*((_DWORD *)this + 1) & 0x20) != 0) {
    return 5;
  }
  else {
    return (*((_DWORD *)this + 1) & 1) == 0;
  }
}

uint64_t RB::color_depth_layer_format(int a1, int a2, uint64_t a3)
{
  if ((a1 - 1) >= 3)
  {
    uint64_t v5 = 80;
    if (a2) {
      uint64_t v5 = 81;
    }
    if (a1) {
      return 115;
    }
    else {
      return v5;
    }
  }
  else if (a3)
  {
    uint64_t v3 = 552;
    if (a2) {
      uint64_t v3 = 553;
    }
    if (*(unsigned __int8 *)(a3 + 283) <= 2u) {
      return 115;
    }
    else {
      return v3;
    }
  }
  else
  {
    return 115;
  }
}

BOOL _ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEbT1_SG_S9_(unsigned int *a1, unsigned int *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 3;
  BOOL result = 1;
  switch(0xCCCCCCCCCCCCCCCDLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      unint64_t v6 = a2 - 10;
      if (*(a2 - 10) < (unint64_t)*a1)
      {
        uint64_t v7 = *((void *)a1 + 4);
        long long v8 = *(_OWORD *)a1;
        long long v9 = *((_OWORD *)a1 + 1);
        unsigned int v10 = *(a2 - 2);
        long long v11 = *(_OWORD *)(a2 - 6);
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *((_OWORD *)a1 + 1) = v11;
        a1[8] = v10;
        *(_OWORD *)unint64_t v6 = v8;
        *(_OWORD *)(a2 - 6) = v9;
        *(a2 - 2) = v7;
      }
      return result;
    case 3uLL:
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEjT1_SG_SG_S9_(a1, a1 + 10, a2 - 10);
      return 1;
    case 4uLL:
      _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEvT1_SG_SG_SG_S9_(a1, a1 + 10, a1 + 20, a2 - 10);
      return 1;
    case 5uLL:
      int64x2_t v22 = a1 + 10;
      float64x2_t v23 = a1 + 20;
      float64x2_t v24 = a1 + 30;
      _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEvT1_SG_SG_SG_S9_(a1, a1 + 10, a1 + 20, a1 + 30);
      unsigned int v26 = *(a2 - 10);
      char v25 = a2 - 10;
      if (v26 >= (unint64_t)a1[30]) {
        return 1;
      }
      uint64_t v27 = *((void *)a1 + 19);
      long long v28 = *(_OWORD *)v24;
      long long v29 = *(_OWORD *)(a1 + 34);
      unsigned int v30 = v25[8];
      long long v31 = *((_OWORD *)v25 + 1);
      *(_OWORD *)float64x2_t v24 = *(_OWORD *)v25;
      *(_OWORD *)(a1 + 34) = v31;
      a1[38] = v30;
      *(_OWORD *)char v25 = v28;
      *((_OWORD *)v25 + 1) = v29;
      v25[8] = v27;
      if (*v24 >= (unint64_t)*v23) {
        return 1;
      }
      uint64_t v32 = *((void *)a1 + 14);
      long long v34 = *(_OWORD *)v23;
      long long v33 = *((_OWORD *)a1 + 6);
      long long v35 = *(_OWORD *)(a1 + 34);
      *(_OWORD *)float64x2_t v23 = *(_OWORD *)v24;
      *((_OWORD *)a1 + 6) = v35;
      a1[28] = a1[38];
      *(_OWORD *)float64x2_t v24 = v34;
      *(_OWORD *)(a1 + 34) = v33;
      a1[38] = v32;
      if (*v23 >= (unint64_t)*v22) {
        return 1;
      }
      uint64_t v36 = *((void *)a1 + 9);
      long long v38 = *(_OWORD *)v22;
      long long v37 = *(_OWORD *)(a1 + 14);
      long long v39 = *((_OWORD *)a1 + 6);
      *(_OWORD *)int64x2_t v22 = *(_OWORD *)v23;
      *(_OWORD *)(a1 + 14) = v39;
      a1[18] = a1[28];
      *(_OWORD *)float64x2_t v23 = v38;
      *((_OWORD *)a1 + 6) = v37;
      a1[28] = v36;
      if (a1[10] >= (unint64_t)*a1) {
        return 1;
      }
      uint64_t v40 = *((void *)a1 + 4);
      long long v42 = *(_OWORD *)a1;
      long long v41 = *((_OWORD *)a1 + 1);
      long long v43 = *(_OWORD *)(a1 + 14);
      *(_OWORD *)a1 = *(_OWORD *)v22;
      *((_OWORD *)a1 + 1) = v43;
      a1[8] = a1[18];
      *(_OWORD *)int64x2_t v22 = v42;
      *(_OWORD *)(a1 + 14) = v41;
      BOOL result = 1;
      a1[18] = v40;
      return result;
    default:
      uint64_t v12 = a1 + 20;
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEjT1_SG_SG_S9_(a1, a1 + 10, a1 + 20);
      unint64_t v13 = a1 + 30;
      if (a1 + 30 == a2) {
        return 1;
      }
      uint64_t v14 = 0;
      int v15 = 0;
      break;
  }
  while (1)
  {
    unint64_t v16 = *v13 | ((unint64_t)*((unsigned __int16 *)v13 + 2) << 32);
    unint64_t v17 = *v13;
    if (v17 < *v12)
    {
      *(_OWORD *)int v44 = *(_OWORD *)((char *)v13 + 6);
      *(_OWORD *)&v44[16] = *(_OWORD *)((char *)v13 + 22);
      uint64_t v18 = v14;
      while (1)
      {
        uint64_t v19 = (char *)a1 + v18;
        long long v20 = *(_OWORD *)((char *)a1 + v18 + 96);
        *(_OWORD *)(v19 + 120) = *(_OWORD *)((char *)a1 + v18 + 80);
        *(_OWORD *)(v19 + 136) = v20;
        *((_DWORD *)v19 + 38) = *(unsigned int *)((char *)a1 + v18 + 112);
        if (v18 == -80) {
          break;
        }
        v18 -= 40;
        if (v17 >= *((unsigned int *)v19 + 10))
        {
          uint64_t v21 = (uint64_t)a1 + v18 + 120;
          goto LABEL_12;
        }
      }
      uint64_t v21 = (uint64_t)a1;
LABEL_12:
      *(_DWORD *)uint64_t v21 = v16;
      *(_WORD *)(v21 + 4) = WORD2(v16);
      *(_OWORD *)(v21 + 6) = *(_OWORD *)v44;
      *(_OWORD *)(v21 + 20) = *(_OWORD *)&v44[14];
      if (++v15 == 8) {
        return v13 + 10 == a2;
      }
    }
    uint64_t v12 = v13;
    v14 += 40;
    v13 += 10;
    if (v13 == a2) {
      return 1;
    }
  }
}

void sub_214152E2C(_Unwind_Exception *a1)
{
}

void sub_214152EC0(_Unwind_Exception *a1)
{
}

void sub_214153000(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10B1C404EFE7174);
  _Unwind_Resume(a1);
}

void sub_2141530F0(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v2, 0x10B1C404EFE7174);

  _Unwind_Resume(a1);
}

void sub_2141531F0(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v2, 0x10B1C404EFE7174);

  _Unwind_Resume(a1);
}

void sub_2141532E4(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10B1C404EFE7174);
  _Unwind_Resume(a1);
}

void sub_2141533D4(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v2, 0x10B1C404EFE7174);

  _Unwind_Resume(a1);
}

uint64_t RB::CustomShader::Closure::operator=(uint64_t a1, atomic_uint **a2)
{
  uint64_t v4 = *(atomic_uint **)a1;
  uint64_t v5 = *a2;
  if (v4 != *a2)
  {
    if (v4)
    {
      if (atomic_fetch_add_explicit(v4 + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        (*(void (**)(atomic_uint *))(*(void *)v4 + 8))(v4);
      }
      uint64_t v5 = *a2;
    }
    if (v5) {
      atomic_fetch_add_explicit(v5 + 2, 1u, memory_order_relaxed);
    }
    *(void *)a1 = v5;
  }
  unint64_t v6 = (const RB::CustomShader::Value *)(a2 + 1);
  uint64_t v7 = *(void *)(a1 + 112);
  if (*(void *)(a1 + 104)) {
    long long v8 = *(const void ***)(a1 + 104);
  }
  else {
    long long v8 = (const void **)(a1 + 8);
  }
  if (v7)
  {
    uint64_t v9 = 24 * v7;
    do
    {
      RB::CustomShader::Value::reset_data(v8);
      v8 += 3;
      v9 -= 24;
    }
    while (v9);
  }
  *(void *)(a1 + 112) = 0;
  unsigned int v10 = (const RB::CustomShader::Value *)a2[13];
  unint64_t v11 = (unint64_t)a2[14];
  if (v10) {
    uint64_t v12 = v10;
  }
  else {
    uint64_t v12 = v6;
  }
  if (*(void *)(a1 + 120) < v11)
  {
    RB::vector<RB::CustomShader::Value,4ul,unsigned long>::reserve_slow((void *)(a1 + 8), v11);
    uint64_t v13 = *(void *)(a1 + 112);
  }
  else
  {
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    if (!v11) {
      goto LABEL_25;
    }
  }
  uint64_t v15 = *(void *)(a1 + 104);
  if (!v15) {
    uint64_t v15 = a1 + 8;
  }
  unint64_t v16 = (RB::CustomShader::Value *)(v15 + 24 * v13);
  unint64_t v17 = v11;
  do
  {
    uint64_t v18 = RB::CustomShader::Value::Value(v16, v12);
    uint64_t v12 = (const RB::CustomShader::Value *)((char *)v12 + 24);
    unint64_t v16 = (RB::CustomShader::Value *)(v18 + 24);
    --v17;
  }
  while (v17);
  uint64_t v14 = *(void *)(a1 + 112);
LABEL_25:
  *(void *)(a1 + 112) = v14 + v11;
  return a1;
}

void sub_214153EA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,atomic_uint *a27)
{
  if (a27) {
    -[RBEncoderSet addDisplayList:](a27);
  }
  if (a22) {
    free(a22);
  }
  if (a19) {
    free(a19);
  }
  long long v29 = *(atomic_uint **)(v27 - 56);
  if (v29)
  {
    if (atomic_fetch_add_explicit(v29 + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(atomic_uint *))(*(void *)v29 + 8))(v29);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_214154220(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  RB::Heap::~Heap((RB::Heap *)va);

  _Unwind_Resume(a1);
}

void sub_214154670(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id a13, id a14, id a15)
{
  _Unwind_Resume(a1);
}

void sub_2141546CC()
{
}

void sub_2141546D4()
{
}

void sub_2141546DC()
{
}

id __copy_helper_block_e8_40c48_ZTSN2RB8objc_ptrIU13block_pointerFvP7NSErrorEEE(uint64_t a1, uint64_t a2)
{
  id result = *(id *)(a2 + 40);
  *(void *)(a1 + 40) = result;
  return result;
}

void __destroy_helper_block_e8_40c48_ZTSN2RB8objc_ptrIU13block_pointerFvP7NSErrorEEE(uint64_t a1)
{
}

id __copy_helper_block_e8_32c30_ZTSN2RB8objc_ptrIP8RBDeviceEE40c30_ZTSN2RB8objc_ptrIP8RBShaderEE48c48_ZTSN2RB8objc_ptrIU13block_pointerFvP7NSErrorEEE56c61_ZTSN2RB8objc_ptrIPU28objcproto17OS_dispatch_queue8NSObjectEE(void *a1, id *a2)
{
  a1[4] = a2[4];
  a1[5] = a2[5];
  a1[6] = a2[6];
  id result = a2[7];
  a1[7] = result;
  return result;
}

void sub_21415483C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_32c30_ZTSN2RB8objc_ptrIP8RBDeviceEE40c30_ZTSN2RB8objc_ptrIP8RBShaderEE48c48_ZTSN2RB8objc_ptrIU13block_pointerFvP7NSErrorEEE56c61_ZTSN2RB8objc_ptrIPU28objcproto17OS_dispatch_queue8NSObjectEE(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
}

void *RB::vector<RB::CustomShader::Value,4ul,unsigned long>::reserve_slow(void *__dst, unint64_t a2)
{
  if (*((void *)__dst + 14) + (*((void *)__dst + 14) >> 1) <= a2) {
    unint64_t v3 = a2;
  }
  else {
    unint64_t v3 = *((void *)__dst + 14) + (*((void *)__dst + 14) >> 1);
  }
  id result = RB::details::realloc_vector<unsigned long,24ul>(*((void **)__dst + 12), __dst, 4uLL, (unint64_t *)__dst + 14, v3);
  *((void *)__dst + 12) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,24ul>(void *__src, void *__dst, unint64_t a3, unint64_t *a4, unint64_t a5)
{
  uint64_t v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      unint64_t v9 = a3;
      memcpy(__dst, __src, 24 * a5);
      free(v7);
      uint64_t v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(24 * a5);
    unint64_t v9 = v8 / 0x18;
    if (v8 / 0x18 != *a4)
    {
      unsigned int v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10) {
        RB::precondition_failure((RB *)"allocation failure", v11);
      }
      uint64_t v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, 24 * *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

uint64_t ___ZN2RB19ObjcEncoderDelegate16encode_message_fIZ41__RBShader_encodedDataForDelegate_error__E3__2Z41__RBShader_encodedDataForDelegate_error__E3__3EEP6NSDataRKT_RKT0__block_invoke(uint64_t result)
{
  uint64_t v1 = *(void ***)(result + 32);
  if (v1)
  {
    if (*v1) {
      free(*v1);
    }
    JUMPOUT(0x21669AC10);
  }
  return result;
}

void RB::Decoder::~Decoder(RB::Decoder *this)
{
  RB::ObjectTable::~ObjectTable((RB::Decoder *)((char *)this + 184));
  uint64_t v2 = (void *)*((void *)this + 20);
  if (v2) {
    free(v2);
  }
  RB::UntypedTable::~UntypedTable((RB::Decoder *)((char *)this + 80));
  unint64_t v3 = (void *)*((void *)this + 4);
  if (v3) {
    free(v3);
  }
}

uint64_t RB::render_primitive(uint64_t a1, float64x2_t *a2, uint64_t a3, float32x2_t *a4, int a5, unsigned int a6, float a7)
{
  unsigned int v7 = a6;
  int v33 = 0;
  memset(v32, 0, sizeof(v32));
  int32x2_t v30 = 0;
  int32x2_t v31 = 0;
  uint64_t result = RB::Coverage::Primitive::set_globals(a3, (uint64_t)v34, (float32x2_t *)a1, (uint64_t)a2, a6, &v33, (uint64_t)v32, (uint64_t)&v30);
  if (result)
  {
    if (a7 == 1.0) {
      int is_opaque = RB::Fill::Gradient::is_opaque(a4);
    }
    else {
      int is_opaque = 0;
    }
    if (v33 == 1)
    {
      BOOL v17 = v7 == 2 || v7 == 24;
      int v18 = is_opaque ^ 1;
      if (!v17) {
        int v18 = 1;
      }
      if (!v18) {
        LOBYTE(v7) = 0;
      }
    }
    *(float *)&double v15 = a7;
    RB::Fill::Gradient::set_gradient(a4, (uint64_t)v35, a1, a2, v15);
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a1, (RB::Device *)0x88, 4uLL, 0, &v37);
    uint64_t v19 = v37;
    if (v37)
    {
      uint64_t v20 = *((void *)v37 + 7) + v38.i64[0];
      long long v21 = v34[4];
      long long v23 = v34[1];
      long long v22 = v34[2];
      *(_OWORD *)(v20 + 48) = v34[3];
      *(_OWORD *)(v20 + 64) = v21;
      *(_OWORD *)(v20 + 16) = v23;
      *(_OWORD *)(v20 + 32) = v22;
      long long v25 = v35[1];
      long long v24 = v35[2];
      long long v26 = v35[0];
      *(void *)(v20 + 128) = v36;
      *(_OWORD *)(v20 + 96) = v25;
      *(_OWORD *)(v20 + 112) = v24;
      *(_OWORD *)(v20 + 80) = v26;
      *(_OWORD *)uint64_t v20 = v34[0];
    }
    else
    {
      long long v37 = 0;
      int64x2_t v38 = 0uLL;
    }
    *(_DWORD *)(a1 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a1, v19);
    *(int32x2_t *)(a1 + 188) = vmovn_s64(v38);
    unsigned int v29 = v33 & 0xF;
    RB::Coverage::Primitive::set_coverage_state(a3, &v29);
    if (*(_DWORD *)(a1 + 136) == 2) {
      int v27 = 131078;
    }
    else {
      int v27 = 6;
    }
    if (a5) {
      int v28 = 0x10000;
    }
    else {
      int v28 = 0;
    }
    LODWORD(v37) = (v27 | v28) & 0xFFFF003F | ((v29 & 0x3FF) << 6);
    HIDWORD(v37) = v7 & 0x3F;
    RB::Fill::Gradient::set_fill_state((uint64_t)a4, (int *)&v37, a1, a7);
    uint64_t result = (uint64_t)RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, (const char *)v37, 4, (uint64_t)v32, 0, 1uLL, v30, v31);
    if (*((void *)&v32[1] + 1))
    {
      unsigned int v29 = v29 & 0xFFFFFFF0 | 1;
      LODWORD(v37) = (v29 << 6) & 0xFFC0 | v37 & 0xFFFF003F;
      if (is_opaque && ((BYTE4(v37) & 0x3F) == 0x18 || (BYTE4(v37) & 0x3F) == 2)) {
        HIDWORD(v37) &= 0xFFFFFFC0;
      }
      uint64_t result = (uint64_t)RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, (const char *)v37, 4, (uint64_t)&v32[1] + 8, 0, 1uLL, v30, v31);
    }
    *(void *)(a1 + 196) = 0;
    *(_DWORD *)(a1 + 204) = 0;
    *(void *)(a1 + 220) = 0;
    *(_DWORD *)(a1 + 228) = 0;
  }
  return result;
}

void RB::render_primitive(uint64_t a1, float64x2_t *a2, uint64_t a3, RB::Fill::MeshGradient *a4, int a5, unsigned int a6, float a7)
{
  uint64_t v14 = RB::pixel_format_traits(*(void *)(a1 + 88), (MTLPixelFormat)a2);
  if (((*v14 | ((unint64_t)*((unsigned __int16 *)v14 + 2) << 32)) & 0x4000000000) != 0)
  {
    *(unsigned char *)(a1 + 176) = 1;
    *(_DWORD *)(a1 + 180) = 1;
    long long v15 = 0uLL;
    {
      *(unsigned char *)(a1 + 176) = 6;
      *(_DWORD *)(a1 + 180) = 0;
      RB::render_mesh_gradient((RB::RenderPass *)a1, a2, a4, 0, a5, a6, (int32x2_t *)&v15, a7);
    }
    *(unsigned char *)(a1 + 176) = 0;
    *(_DWORD *)(a1 + 180) = 0;
  }
  else
  {
    long long v15 = 0uLL;
      RB::render_mesh_gradient((RB::RenderPass *)a1, a2, a4, 0, a5, a6, (int32x2_t *)&v15, a7);
  }
}

uint64_t RB::render_primitive(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, unsigned int a7)
{
  int v42 = 0;
  memset(v41, 0, sizeof(v41));
  int32x2_t v39 = 0;
  int32x2_t v40 = 0;
  uint64_t result = RB::Coverage::Primitive::set_globals(a3, a4, (float32x2_t *)a1, a2, a7, &v42, (uint64_t)v41, (uint64_t)&v39);
  if (!result) {
    return result;
  }
  if (v42 == 1)
  {
    if (a7 != 24 && a7 != 2 || (*(_DWORD *)(a4 + 160) & 0x100) == 0) {
      unsigned int v15 = a7;
    }
    else {
      unsigned int v15 = 0;
    }
    if (!a6 && v15 <= 0x18 && (*(_DWORD *)(a4 + 160) & 7) == 0)
    {
      if (v15 == 24 || v15 == 2) {
        char v18 = 0;
      }
      else {
        char v18 = v15;
      }
      if ((*(_DWORD *)(a4 + 160) & 0x100) != 0) {
        LOBYTE(v15) = v18;
      }
      else {
        LOBYTE(v15) = a7;
      }
      RB::Coverage::set_plane((uint64_t)v37, a4);
      RB::Fill::set_image_stretch(&v37[28], a4 + 80);
      RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a1, (RB::Device *)0x3C, 4uLL, 0, &v43);
      uint64_t v19 = v43;
      if (v43)
      {
        uint64_t v20 = (_OWORD *)(*((void *)v43 + 7) + v44.i64[0]);
        long long v21 = *(_OWORD *)v37;
        long long v22 = *(_OWORD *)&v37[16];
        long long v23 = v38[0];
        *(_OWORD *)((char *)v20 + 44) = *(_OWORD *)((char *)v38 + 12);
        v20[1] = v22;
        void v20[2] = v23;
        *uint64_t v20 = v21;
      }
      else
      {
        long long v43 = 0;
        int64x2_t v44 = 0uLL;
      }
      *(_DWORD *)(a1 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a1, v19);
      *(int32x2_t *)(a1 + 188) = vmovn_s64(v44);
      int v34 = 3;
      goto LABEL_36;
    }
  }
  else
  {
    LOBYTE(v15) = a7;
  }
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a1, (RB::Device *)0xA4, 4uLL, 0, v37);
  long long v24 = *(RB::Buffer **)v37;
  if (*(void *)v37)
  {
    uint64_t v25 = *(void *)(*(void *)v37 + 56) + *(void *)&v37[8];
    long long v26 = *(_OWORD *)(a4 + 32);
    long long v27 = *(_OWORD *)a4;
    *(_OWORD *)(v25 + 16) = *(_OWORD *)(a4 + 16);
    *(_OWORD *)(v25 + 32) = v26;
    long long v28 = *(_OWORD *)(a4 + 96);
    long long v30 = *(_OWORD *)(a4 + 48);
    long long v29 = *(_OWORD *)(a4 + 64);
    *(_OWORD *)(v25 + 80) = *(_OWORD *)(a4 + 80);
    *(_OWORD *)(v25 + 96) = v28;
    *(_OWORD *)(v25 + 48) = v30;
    *(_OWORD *)(v25 + 64) = v29;
    long long v32 = *(_OWORD *)(a4 + 128);
    long long v31 = *(_OWORD *)(a4 + 144);
    long long v33 = *(_OWORD *)(a4 + 112);
    *(_DWORD *)(v25 + 160) = *(_DWORD *)(a4 + 160);
    *(_OWORD *)(v25 + 128) = v32;
    *(_OWORD *)(v25 + 144) = v31;
    *(_OWORD *)(v25 + 112) = v33;
    *(_OWORD *)uint64_t v25 = v27;
  }
  else
  {
    memset(v37, 0, 24);
  }
  *(_DWORD *)(a1 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a1, v24);
  *(int32x2_t *)(a1 + 188) = vmovn_s64(*(int64x2_t *)&v37[8]);
  int v34 = 7;
LABEL_36:
  LODWORD(v43) = v42 & 0xF;
  RB::Coverage::Primitive::set_coverage_state(a3, &v43);
  if (*(_DWORD *)(a1 + 136) == 2) {
    int v35 = 0x20000;
  }
  else {
    int v35 = 2;
  }
  if (a6) {
    int v36 = 0x10000;
  }
  else {
    int v36 = 0;
  }
  *(_DWORD *)long long v37 = (v35 | v34 | v36) & 0xFFFF003F | (((unsigned __int16)v43 & 0x3FF) << 6);
  *(_DWORD *)&v37[4] = v15 & 0x3F;
  RB::RenderState::set_image((int *)v37, a4 + 80, *(unsigned __int8 *)(a1 + 124));
  uint64_t result = (uint64_t)RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, *(const char **)v37, 4, (uint64_t)v41, 0, 1uLL, v39, v40);
  if (*((void *)&v41[1] + 1))
  {
    LODWORD(v43) = v43 & 0xFFFFFFF0 | 1;
    *(_DWORD *)long long v37 = (v43 << 6) & 0xFFC0 | *(_DWORD *)v37 & 0xFFFF003F;
    if ((*(unsigned char *)(a4 + 161) & 1) != 0 && ((v37[4] & 0x3F) == 0x18 || (v37[4] & 0x3F) == 2)) {
      *(_DWORD *)&v37[4] &= 0xFFFFFFC0;
    }
    uint64_t result = (uint64_t)RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, *(const char **)v37, 4, (uint64_t)&v41[1] + 8, 0, 1uLL, v39, v40);
  }
  *(void *)(a1 + 200) = 0;
  *(_DWORD *)(a1 + 196) = 0;
  return result;
}

void RB::render_primitive(RB::RenderPass *a1, float64x2_t *a2, uint64_t a3, RB::Fill::Custom *this, int a5, unsigned int a6, float a7)
{
  uint64_t v14 = RB::Fill::Custom::function(this, (uint64_t **)a1);
  if (v14)
  {
    unsigned int v15 = (Function *)v14;
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a1, (RB::Device *)(*((unsigned int *)v14 + 20) + 108), 4uLL, 0, &v25);
    if (v25)
    {
      unint64_t v16 = (float32x2_t *)(*((void *)v25 + 7) + v26.i64[0]);
      int v24 = 0;
      memset(v23, 0, sizeof(v23));
      int32x2_t v21 = 0;
      int32x2_t v22 = 0;
      if (RB::Coverage::Primitive::set_globals(a3, (uint64_t)v16, (float32x2_t *)a1, (uint64_t)a2, a6, &v24, (uint64_t)v23, (uint64_t)&v21))
      {
        if (RB::Fill::Custom::set_custom((uint64_t)this, v16 + 10, (uint64_t)v15, (uint64_t)&v16[13] + 4, (uint64_t)a1, a2, a7))
        {
          *((_DWORD *)a1 + 46) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a1, v25);
          *(int32x2_t *)((char *)a1 + 188) = vmovn_s64(v26);
          unsigned int v20 = v24 & 0xF;
          RB::Coverage::Primitive::set_coverage_state(a3, &v20);
          if (*((_DWORD *)a1 + 34) == 2) {
            int v17 = 131080;
          }
          else {
            int v17 = 8;
          }
          if (a5) {
            int v18 = 0x10000;
          }
          else {
            int v18 = 0;
          }
          LODWORD(v19) = (v17 | v18) & 0xFFFF003F | ((v20 & 0x3FF) << 6);
          HIDWORD(v19) = a6 & 0x3F;
          RB::Fill::Custom::set_fill_state(this, (RB::RenderState *)&v19, v15, (unint64_t **)a1);
          RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, v19, 4, (uint64_t)v23, 0, 1uLL, v21, v22);
          if (*((void *)&v23[1] + 1))
          {
            unsigned int v20 = v20 & 0xFFFFFFF0 | 1;
            LODWORD(v19) = (v20 << 6) & 0xFFC0 | v19 & 0xFFFF003F;
            RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, v19, 4, (uint64_t)&v23[1] + 8, 0, 1uLL, v21, v22);
          }
          *((void *)a1 + 25) = 0;
          *((_DWORD *)a1 + 49) = 0;
          RB::Fill::Custom::reset_custom(this, a1);
        }
      }
    }
  }
}

double CG::LineSegment::index(float64x2_t *this, double a2)
{
  double v2 = 0.0;
  if (a2 > 0.0)
  {
    float64x2_t v3 = vsubq_f64(this[1], *this);
    double v4 = sqrt(vaddvq_f64(vmulq_f64(v3, v3)));
    if (v4 <= a2) {
      return 1.0;
    }
    else {
      return a2 / v4;
    }
  }
  return v2;
}

__n128 CG::LineSegment::split@<Q0>(float64x2_t *this@<X0>, double a2@<D0>, uint64_t a3@<X8>)
{
  float64x2_t v3 = vmlaq_n_f64(*this, vsubq_f64(this[1], *this), a2);
  __n128 result = (__n128)this[1];
  *(float64x2_t *)a3 = *this;
  *(float64x2_t *)(a3 + 16) = v3;
  *(float64x2_t *)(a3 + 32) = v3;
  *(__n128 *)(a3 + 48) = result;
  return result;
}

BOOL RB::Filter::ColorMatrix::append(uint64_t a1, int a2, float16x4_t *a3)
{
  if (a2 == 1)
  {
    RB::operator*(a3 + 1, (float16x4_t *)(a1 + 8), (float16x4_t *)v7);
    long long v5 = v7[1];
    *(_OWORD *)(a1 + 8) = v7[0];
    *(_OWORD *)(a1 + 24) = v5;
    *(void *)(a1 + 40) = v8;
  }
  return a2 == 1;
}

BOOL RB::Filter::ColorMatrix::can_discard_color(RB::Filter::ColorMatrix *this, BOOL *a2)
{
  float64x2_t v3 = (RB::Filter::ColorMatrix *)((char *)this + 8);
  is_alpha_identitdouble y = RB::ColorMatrix::is_alpha_identity((RB::Filter::ColorMatrix *)((char *)this + 8));
  *a2 = is_alpha_identity;
  return is_alpha_identity || !RB::ColorMatrix::is_alpha_color_dependent(v3);
}

uint64_t RB::Filter::ColorMatrix::can_mix(float16x4_t *this, RB::DisplayList::Interpolator::Contents *a2, float16x4_t *a3)
{
  if (!a3) {
    return 2;
  }
  if (this->i32[0] != a3->i32[0]) {
    return 0;
  }
  if (RB::ColorMatrix::operator==(this + 1, a3 + 1)) {
    return 4;
  }
  return 2;
}

float16x4_t RB::Filter::ColorMatrix::mix(float16x4_t *this, const RB::DisplayList::Interpolator::State *a2, const RB::Filter::ColorMatrix *a3, const RB::DisplayList::CachedTransform *a4)
{
  if (a3)
  {
    long long v6 = *(_OWORD *)((char *)a3 + 24);
    long long v21 = *(_OWORD *)((char *)a3 + 8);
    long long v22 = v6;
    float16x4_t v23 = *(float16x4_t *)((char *)a3 + 40);
  }
  else
  {
    RB::ColorMatrix::set_identity((RB::ColorMatrix *)&v21);
  }
  _S0 = *((_DWORD *)a2 + 4);
  __asm { FCVT            H0, S0 }
  float16x4_t v12 = this[2];
  float16x4_t v13 = *(float16x4_t *)((char *)&v21 + 8);
  this[1] = vmla_n_f16(this[1], vsub_f16(*(float16x4_t *)&v21, this[1]), *(short float *)&_S0);
  _S0 = *((_DWORD *)a2 + 4);
  __asm { FCVT            H0, S0 }
  this[2] = vmla_n_f16(v12, vsub_f16(v13, v12), *(short float *)&_S0);
  _S0 = *((_DWORD *)a2 + 4);
  __asm { FCVT            H0, S0 }
  float16x4_t v16 = this[4];
  float16x4_t v17 = *(float16x4_t *)((char *)&v22 + 8);
  this[3] = vmla_n_f16(this[3], vsub_f16(*(float16x4_t *)&v22, this[3]), *(short float *)&_S0);
  _S0 = *((_DWORD *)a2 + 4);
  __asm { FCVT            H0, S0 }
  this[4] = vmla_n_f16(v16, vsub_f16(v17, v16), *(short float *)&_S0);
  _S1 = *((_DWORD *)a2 + 4);
  __asm { FCVT            H1, S1 }
  float16x4_t result = vmla_n_f16(this[5], vsub_f16(v23, this[5]), *(short float *)&_S1);
  this[5] = result;
  return result;
}

int32x2_t RB::Filter::ColorMatrix::dod(RB::Filter::ColorMatrix *this, int32x2_t *a2)
{
  __asm { FCMP            H0, #0 }
  if (!_ZF)
  {
    int32x2_t result = vdup_n_s32(0x7F7FFFFFu);
    *a2 = (int32x2_t)0x100000001000000;
    a2[1] = result;
  }
  return result;
}

uint64_t RB::Filter::ColorMatrix::set_globals(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, int32x2_t a5)
{
  RB::Coverage::set_plane((float32x2_t *)a3, a2, a5);
  if (RB::ColorMatrix::is_diagonal((float16x4_t *)(a1 + 8)))
  {
    double v8 = *(double *)(a1 + 8);
    WORD1(v8) = WORD1(*(void *)(a1 + 16));
    WORD2(v8) = WORD2(*(void *)(a1 + 24));
    HIWORD(v8) = HIWORD(*(void *)(a1 + 32));
    if ((*(unsigned char *)a1 & 4) != 0)
    {
      *a4 = *a4 & 0xFFFFFFF3 | (4 * (*a4 & 1));
    }
    else
    {
      float16x4_t v9 = (float16x4_t)vdup_lane_s16(*(int16x4_t *)(a1 + 32), 3);
      v9.i16[3] = COERCE_UNSIGNED_INT(1.0);
      double v10 = COERCE_DOUBLE(vmul_f16(*(float16x4_t *)&v8, v9));
      if ((*a4 & 5) == 1) {
        double v10 = v8;
      }
      if ((*a4 & 8) == 0) {
        double v8 = v10;
      }
    }
    unsigned __int8 v13 = 0;
    *(double *)(a3 + 28) = v8;
  }
  else if (RB::ColorMatrix::is_alpha_multiply((float16x4_t *)(a1 + 8), (*(_DWORD *)a1 & 4) != 0))
  {
    v11.n64_u64[0] = RB::ColorMatrix::alpha_multiply_color((RB::ColorMatrix *)(a1 + 8), (*(_DWORD *)a1 & 4) != 0).n64_u64[0];
    if ((*(unsigned char *)a1 & 4) != 0)
    {
      *a4 = *a4 & 0xFFFFFFF3 | (4 * (*a4 & 1));
    }
    else if ((*a4 & 8) == 0 && (*a4 & 5) != 1)
    {
      float16x4_t v12 = (float16x4_t)vdup_lane_s16((int16x4_t)v11.n64_u64[0], 3);
      v12.i16[3] = COERCE_UNSIGNED_INT(1.0);
      v11.n64_u64[0] = (unint64_t)vmul_f16(v12, (float16x4_t)v11.n64_u64[0]);
    }
    *(__n64 *)(a3 + 28) = v11;
    return 1;
  }
  else
  {
    for (uint64_t i = 0; i != 40; i += 8)
      *(void *)(a3 + 28 + i) = *(void *)(a1 + i + 8);
    if (RB::ColorMatrix::has_alpha((float16x4_t *)(a1 + 8)))
    {
      unsigned int v15 = *a4 & 0xFFFFFFF3;
      int v16 = ((8 * (*a4 & 1)) | v15) ^ 8;
      if ((*(unsigned char *)a1 & 4) != 0) {
        int v16 = (4 * (*a4 & 1)) | v15;
      }
      *a4 = v16;
      return 4;
    }
    else if ((vmaxv_u16((uint16x4_t)vmvn_s8((int8x8_t)vceqz_f16(*(float16x4_t *)(a1 + 40)))) & 0x8000) != 0)
    {
      return 3;
    }
    else
    {
      return 2;
    }
  }
  return v13;
}

int32x2_t *RB::Filter::ColorMatrix::render(_DWORD *a1, MTLPixelFormat a2, uint64_t a3, uint64_t a4)
{
  int v18 = 0;
  char v8 = RB::Filter::ColorMatrix::set_globals((uint64_t)a1, a2, (uint64_t)v16, &v18, v7);
  __int16 v9 = v18;
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)0x44, 4uLL, 0, &v19);
  double v10 = v19;
  if (v19)
  {
    uint64_t v11 = *((void *)v19 + 7) + v20.i64[0];
    long long v13 = v16[2];
    long long v12 = v16[3];
    long long v14 = v16[1];
    *(_DWORD *)(v11 + 64) = v17;
    *(_OWORD *)(v11 + 32) = v13;
    *(_OWORD *)(v11 + 48) = v12;
    *(_OWORD *)(v11 + 16) = v14;
    *(_OWORD *)uint64_t v11 = v16[0];
  }
  else
  {
    uint64_t v19 = 0;
    int64x2_t v20 = 0uLL;
  }
  *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v10);
  *(int32x2_t *)(a2 + 188) = vmovn_s64(v20);
  return RB::RenderPass::draw_indexed_primitives((int32x2_t *)a2, (const char *)(a4 & 0xFFFFFFFF00000000 | a4 & 0xFFFFF | ((unsigned __int16)(v9 & 0xFF8F | (16 * (v8 & 0xF))) << 20)), 4, ***(void ***)a2 + 80, 0, 1uLL, (int32x2_t)0xC0000001C0000001, (int32x2_t)0x7FFFFFFF7FFFFFFFLL);
}

uint64_t RB::Filter::anonymous namespace'::set_color_fill_state(_DWORD *a1, MTLPixelFormat a2, char a3)
{
  uint64_t v4 = *(unsigned __int8 *)(a2 + 124);
  if (a3 & 1) != 0 && (v4)
  {
    *a1 |= 3u;
    return v4 & 0xFE;
  }
  else if ((a3 & 2) != 0 && (v4 & 1) == 0)
  {
    if (RB::RenderParams::srgb_alpha(*(RB::RenderParams **)a2, a2)) {
      int v5 = 2;
    }
    else {
      int v5 = 3;
    }
    *a1 |= v5;
    return v4 | 1;
  }
  return v4;
}

uint64_t RB::Filter::ColorMatrix::render(float16x4_t *a1, uint64_t a2, MTLPixelFormat a3)
{
  uint64_t result = RB::ColorMatrix::is_identity(a1 + 1);
  if ((result & 1) == 0)
  {
    if (*(_DWORD *)(a3 + 136) == 2) {
      uint64_t v7 = 131101;
    }
    else {
      uint64_t v7 = 29;
    }
    return (uint64_t)RB::Filter::ColorMatrix::render(a1, a3, v6, v7);
  }
  return result;
}

uint64_t RB::Filter::ColorMatrix::render(uint64_t result, MTLPixelFormat a2, uint64_t a3, int a4, int a5, float32_t a6)
{
  char v7 = a4;
  double v10 = (uint64_t *)result;
  uint64_t v18 = *MEMORY[0x263EF8340];
  if (a4 != 24 && a4 != 2 || (uint64_t result = RB::ColorMatrix::is_identity((float16x4_t *)(result + 8)), (result & 1) == 0))
  {
    uint64_t v11 = 29;
    if (*(_DWORD *)(a2 + 136) == 2) {
      uint64_t v11 = 131101;
    }
    uint64_t v12 = v7 & 0x3F;
    uint64_t v13 = 0x10000;
    if (!a5) {
      uint64_t v13 = 0;
    }
    uint64_t v14 = v13 | v11;
    if (a6 != 1.0)
    {
      MEMORY[0x270FA5388](result, a2);
      uint64_t v15 = 0;
      LODWORD(v15) = *(_DWORD *)v10;
      v16[0] = *(_OWORD *)(v10 + 1);
      v16[1] = *(_OWORD *)(v10 + 3);
      uint64_t v17 = v10[5];
      RB::ColorMatrix::multiply_color((float16x4_t *)v16, 1.0, 1.0, 1.0, a6, (v15 >> 2) & 1);
      double v10 = &v15;
    }
    return (uint64_t)RB::Filter::ColorMatrix::render(v10, a2, a3, v14 | (v12 << 32));
  }
  return result;
}

void *RB::Filter::ColorMatrix::encode(RB::Filter::ColorMatrix *this, RB::Encoder *a2)
{
  uint64_t v4 = (void *)((char *)this + 8);
  RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ColorMatrix::encode(v4, a2);
  uint64_t result = RB::ProtobufEncoder::end_length_delimited(a2);
  int v6 = *(_DWORD *)this;
  if ((*(_DWORD *)this & 1) == 0)
  {
    if ((v6 & 2) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    RB::ProtobufEncoder::encode_varint(a2, 0x18uLL);
    uint64_t result = RB::ProtobufEncoder::encode_varint(a2, 1uLL);
    if ((*(_DWORD *)this & 4) == 0) {
      return result;
    }
    goto LABEL_7;
  }
  RB::ProtobufEncoder::encode_varint(a2, 0x10uLL);
  uint64_t result = RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  int v6 = *(_DWORD *)this;
  if ((*(_DWORD *)this & 2) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v6 & 4) == 0) {
    return result;
  }
LABEL_7:
  RB::ProtobufEncoder::encode_varint(a2, 0x20uLL);
  return RB::ProtobufEncoder::encode_varint(a2, 1uLL);
}

unint64_t RB::Filter::ColorMatrix::decode(RB::Filter::ColorMatrix *this, RB::Decoder *a2)
{
  unint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    unint64_t v5 = result;
    do
    {
      switch((v5 >> 3))
      {
        case 1u:
          if ((v5 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message(a2);
            RB::ColorMatrix::decode((RB::Filter::ColorMatrix *)((char *)this + 8), a2);
            RB::ProtobufDecoder::end_message((uint64_t)a2);
          }
          else
          {
            *((unsigned char *)a2 + 56) = 1;
            *(void *)a2 = *((void *)a2 + 1);
          }
          break;
        case 2u:
          int v6 = *(_DWORD *)this | RB::ProtobufDecoder::BOOL_field(a2, v5);
          goto LABEL_15;
        case 3u:
          if (RB::ProtobufDecoder::BOOL_field(a2, v5)) {
            int v7 = 2;
          }
          else {
            int v7 = 0;
          }
          goto LABEL_14;
        case 4u:
          if (RB::ProtobufDecoder::BOOL_field(a2, v5)) {
            int v7 = 4;
          }
          else {
            int v7 = 0;
          }
LABEL_14:
          int v6 = *(_DWORD *)this | v7;
LABEL_15:
          *(_DWORD *)this = v6;
          break;
        default:
          RB::ProtobufDecoder::skip_field(a2, v5);
          break;
      }
      unint64_t result = RB::ProtobufDecoder::next_field(a2);
      unint64_t v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::Filter::ColorMatrix::print(float16x4_t *this, std::string *a2)
{
  if (this->i32[0])
  {
    RB::SexpString::push(a2, "color-matrix");
    if (this->i32[0])
    {
      uint64_t v4 = "linear";
    }
    else
    {
      if ((this->i32[0] & 2) == 0) {
        goto LABEL_7;
      }
      uint64_t v4 = "non-linear";
    }
    RB::SexpString::print(a2, 0, v4);
  }
LABEL_7:
  RB::ColorMatrix::print(this + 1, a2);
  if (this->i32[0])
  {
    RB::SexpString::pop(a2);
  }
}

uint64_t RB::Filter::LuminanceCurve::can_discard_color(RB::Filter::LuminanceCurve *this, BOOL *a2)
{
  *a2 = 1;
  return 1;
}

uint64_t RB::Filter::LuminanceCurve::can_mix(float32x4_t *this, RB::DisplayList::Interpolator::Contents *a2, float32x4_t *a3)
{
  if (a3)
  {
    if (this->i32[0] == a3->i32[0])
    {
      if ((vminvq_u32((uint32x4_t)vceqq_f32(this[1], a3[1])) & 0x80000000) == 0) {
        unsigned int v3 = 2;
      }
      else {
        unsigned int v3 = 4;
      }
      can_midouble x = RB::Fill::Color::can_mix((RB::Fill::Color *)&this[2], (const RB::Fill::Color *)&a3[2]);
      if (can_mix >= v3) {
        return v3;
      }
      else {
        return can_mix;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    __asm { FCMP            H0, #0 }
    if (_ZF) {
      return 4;
    }
    else {
      return 2;
    }
  }
}

__int16 RB::Filter::LuminanceCurve::mix@<H0>(float32x4_t *this@<X0>, const RB::DisplayList::Interpolator::State *a2@<X1>, float32x4_t *a3@<X2>, const RB::DisplayList::CachedTransform *a4@<X3>)
{
  if (a3)
  {
    this[1] = vmlaq_n_f32(this[1], vsubq_f32(a3[1], this[1]), COERCE_FLOAT(*((_OWORD *)a2 + 1)));
    RB::Fill::Color::mix((uint64_t)&this[2], (uint64_t)&a3[2], 0, *((float *)a2 + 4));
  }
  else
  {
    _S1 = *((_DWORD *)a2 + 4);
    __asm { FCVT            H1, S1 }
    *(short float *)&__int16 result = *(short float *)&this[2].i16[3]
                            - (short float)(*(short float *)&this[2].i16[3] * *(short float *)&_S1);
    this[2].i16[3] = result;
  }
  return result;
}

int32x2_t *RB::Filter::LuminanceCurve::render(int32x2_t *result, uint64_t a2, MTLPixelFormat a3)
{
  __asm { FCMP            H0, #0 }
  if (!_ZF)
  {
    __int16 v9 = (int32x4_t *)result;
    int v33 = 80;
    if ((v9->i8[0] & 4) != 0) {
      unsigned int v12 = (4 * (v33 & 1)) | v33 & 0xFFFFFFF3;
    }
    else {
      unsigned int v12 = ((8 * (v33 & 1)) | v33 & 0xFFFFFFF3) ^ 8;
    }
    if (*(_DWORD *)(a3 + 136) == 2) {
      int v13 = 131101;
    }
    else {
      int v13 = 29;
    }
    uint64_t v14 = (const char *)(v13 | (v12 << 20));
    int32x4_t v15 = v9[1];
    v11.i32[0] = HIDWORD(v9[1].i64[0]);
    float v16 = COERCE_FLOAT(v9[1].i64[1]);
    *(float *)&unsigned int v27 = vsubq_f32((float32x4_t)vdupq_laneq_s32(v15, 3), (float32x4_t)v15).f32[0]
                   + (float)((float)(*(float *)v11.i32 - v16) * 3.0);
    __int32 v28 = v15.i32[0];
    float v17 = (float)((float)(v16 + *(float *)v15.i32) - (float)(*(float *)v11.i32 + *(float *)v11.i32)) * 3.0;
    *(float *)v11.i32 = (float)(*(float *)v11.i32 - *(float *)v15.i32) * 3.0;
    float v25 = v17;
    __int32 v26 = v11.i32[0];
    RB::Coverage::set_plane((float32x2_t *)&v29, a3, v11);
    v18.i64[0] = __PAIR64__(LODWORD(v25), v27);
    v18.i64[1] = __PAIR64__(v28, v26);
    *(float16x4_t *)&v30[12] = vcvt_f16_f32(v18);
    float16x4_t v19 = RB::Fill::Color::prepare((uint64_t)v9[2].i64, v10, *(double *)&v30[12]);
    *(_DWORD *)&v30[20] = v19.i32[0];
    *(_WORD *)&v30[24] = v19.i16[2];
    *(short float *)&v30[26] = COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)) - *(short float *)&v19.i16[3];
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a3, (RB::Device *)0x44, 4uLL, 0, &v34);
    int64x2_t v20 = v34;
    if (v34)
    {
      uint64_t v21 = *((void *)v34 + 7) + v35.i64[0];
      long long v23 = *(_OWORD *)&v30[16];
      long long v22 = v31;
      long long v24 = *(_OWORD *)v30;
      *(_DWORD *)(v21 + 64) = v32;
      *(_OWORD *)(v21 + 32) = v23;
      *(_OWORD *)(v21 + 48) = v22;
      *(_OWORD *)(v21 + 16) = v24;
      *(_OWORD *)uint64_t v21 = v29;
    }
    else
    {
      int v34 = 0;
      int64x2_t v35 = 0uLL;
    }
    *(_DWORD *)(a3 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a3, v20);
    *(int32x2_t *)(a3 + 188) = vmovn_s64(v35);
    return RB::RenderPass::draw_indexed_primitives((int32x2_t *)a3, v14, 4, ***(void ***)a3 + 80, 0, 1uLL, (int32x2_t)0xC0000001C0000001, (int32x2_t)0x7FFFFFFF7FFFFFFFLL);
  }
  return result;
}

void *RB::Filter::LuminanceCurve::encode(float32x4_t *this, RB::Encoder *a2)
{
  RB::ProtobufEncoder::float4_field(a2, 1, this[1]);
  RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::Fill::Color::encode((RB::Fill::Color *)&this[2], a2);
  __int16 result = RB::ProtobufEncoder::end_length_delimited(a2);
  __int32 v5 = this->i32[0];
  if ((this->i32[0] & 1) == 0)
  {
    if ((v5 & 2) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    RB::ProtobufEncoder::encode_varint(a2, 0x20uLL);
    __int16 result = RB::ProtobufEncoder::encode_varint(a2, 1uLL);
    if ((this->i32[0] & 4) == 0) {
      return result;
    }
    goto LABEL_7;
  }
  RB::ProtobufEncoder::encode_varint(a2, 0x18uLL);
  __int16 result = RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  __int32 v5 = this->i32[0];
  if ((this->i32[0] & 2) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v5 & 4) == 0) {
    return result;
  }
LABEL_7:
  RB::ProtobufEncoder::encode_varint(a2, 0x28uLL);
  return RB::ProtobufEncoder::encode_varint(a2, 1uLL);
}

unint64_t RB::Filter::LuminanceCurve::decode(__n128 *this, RB::Decoder *a2)
{
  unint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    unint64_t v5 = result;
    do
    {
      switch((v5 >> 3))
      {
        case 1u:
          this[1] = RB::ProtobufDecoder::float4_field(a2, v5);
          break;
        case 2u:
          if ((v5 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message(a2);
            RB::Fill::Color::decode((uint64_t)&this[2], a2);
            RB::ProtobufDecoder::end_message((uint64_t)a2);
          }
          else
          {
            *((unsigned char *)a2 + 56) = 1;
            *(void *)a2 = *((void *)a2 + 1);
          }
          break;
        case 3u:
          unsigned __int32 v6 = this->n128_u32[0] | RB::ProtobufDecoder::BOOL_field(a2, v5);
          goto LABEL_16;
        case 4u:
          if (RB::ProtobufDecoder::BOOL_field(a2, v5)) {
            int v7 = 2;
          }
          else {
            int v7 = 0;
          }
          goto LABEL_15;
        case 5u:
          if (RB::ProtobufDecoder::BOOL_field(a2, v5)) {
            int v7 = 4;
          }
          else {
            int v7 = 0;
          }
LABEL_15:
          unsigned __int32 v6 = this->n128_u32[0] | v7;
LABEL_16:
          this->n128_u32[0] = v6;
          break;
        default:
          RB::ProtobufDecoder::skip_field(a2, v5);
          break;
      }
      unint64_t result = RB::ProtobufDecoder::next_field(a2);
      unint64_t v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::Filter::LuminanceCurve::print(RB::Filter::LuminanceCurve *this, std::string *a2)
{
  RB::SexpString::push(a2, "luminance-curve");
  if (*(_DWORD *)this)
  {
    uint64_t v4 = "linear";
    goto LABEL_5;
  }
  if ((*(_DWORD *)this & 2) != 0)
  {
    uint64_t v4 = "non-linear";
LABEL_5:
    RB::SexpString::print(a2, 0, v4);
  }
  RB::SexpString::printf(a2, 1, "(curve %g %g %g %g)", *((float *)this + 4), *((float *)this + 5), *((float *)this + 6), *((float *)this + 7));
  short float v5 = COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0));
  if (*((short float *)this + 16) != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))
    || *((short float *)this + 17) != v5
    || *((short float *)this + 18) != v5
    || *((short float *)this + 19) != v5)
  {
    RB::Fill::Color::print((RB::Filter::LuminanceCurve *)((char *)this + 32), a2);
  }
  RB::SexpString::pop(a2);
}

uint64_t RB::Filter::RGBACurves::can_mix(float32x4_t *a1, uint64_t a2, float32x4_t *a3)
{
  if (!a3) {
    return 2;
  }
  if (a1->i32[0] != a3->i32[0]) {
    return 0;
  }
  if ((vminvq_u32((uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f32(a1[2], a3[2]), (int8x16_t)vceqq_f32(a1[1], a3[1])), vandq_s8((int8x16_t)vceqq_f32(a1[3], a3[3]), (int8x16_t)vceqq_f32(a1[4], a3[4])))) & 0x80000000) == 0)return 2; {
  return 4;
  }
}

__n128 RB::Filter::RGBACurves::mix(float32x4_t *a1, uint64_t a2, float32x4_t *a3)
{
  if (a3)
  {
    float32x4_t v3 = a3[1];
    float32x4_t v4 = a3[2];
    float32x4_t v5 = a3[3];
    float32x4_t v6 = a3[4];
  }
  else
  {
    float32x4_t v3 = (float32x4_t)xmmword_214219930;
    float32x4_t v4 = (float32x4_t)xmmword_214219930;
    float32x4_t v5 = (float32x4_t)xmmword_214219930;
    float32x4_t v6 = (float32x4_t)xmmword_214219930;
  }
  float32x4_t v7 = a1[2];
  a1[1] = vmlaq_n_f32(a1[1], vsubq_f32(v3, a1[1]), COERCE_FLOAT(*(_OWORD *)(a2 + 16)));
  a1[2] = vmlaq_n_f32(v7, vsubq_f32(v4, v7), COERCE_FLOAT(*(_OWORD *)(a2 + 16)));
  float32x4_t v8 = a1[4];
  a1[3] = vmlaq_n_f32(a1[3], vsubq_f32(v5, a1[3]), COERCE_FLOAT(*(_OWORD *)(a2 + 16)));
  __n128 result = *(__n128 *)(a2 + 16);
  a1[4] = vmlaq_n_f32(v8, vsubq_f32(v6, v8), result.n128_f32[0]);
  return result;
}

int32x2_t *RB::Filter::RGBACurves::render(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  int v6 = *a1;
  float32x4_t v4 = (const float *)(a1 + 4);
  char v5 = v6;
  float32x4x4_t v31 = vld4q_f32(v4);
  float32x4_t v25 = v31.val[0];
  int v7 = *(_DWORD *)(a3 + 136);
  __asm { FMOV            V1.4S, #3.0 }
  float32x4_t v24 = vmlaq_f32(vsubq_f32(v31.val[3], v31.val[0]), _Q1, vsubq_f32(v31.val[1], v31.val[2]));
  float32x4_t v22 = vmulq_f32(vsubq_f32(v31.val[1], v31.val[0]), _Q1);
  float32x4_t v23 = vmulq_f32(vsubq_f32(vaddq_f32(v31.val[2], v31.val[0]), vaddq_f32(v31.val[1], v31.val[1])), _Q1);
  RB::Coverage::set_plane((float32x2_t *)&v26, a3, *(int32x2_t *)v22.f32);
  *(float16x8_t *)&v27[12] = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v24), v23);
  *(float16x8_t *)&v27[28] = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v22), v25);
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a3, (RB::Device *)0x44, 4uLL, 0, &v29);
  int v13 = v29;
  if (v29)
  {
    uint64_t v14 = *((void *)v29 + 7) + v30.i64[0];
    long long v15 = *(_OWORD *)&v27[32];
    long long v16 = *(_OWORD *)&v27[16];
    long long v17 = *(_OWORD *)v27;
    *(_DWORD *)(v14 + 64) = v28;
    *(_OWORD *)(v14 + 32) = v16;
    *(_OWORD *)(v14 + 48) = v15;
    *(_OWORD *)(v14 + 16) = v17;
    *(_OWORD *)uint64_t v14 = v26;
  }
  else
  {
    long long v29 = 0;
    int64x2_t v30 = 0uLL;
  }
  uint64_t v18 = 29;
  if (v7 == 2) {
    uint64_t v18 = 131101;
  }
  uint64_t v19 = 100663296;
  if ((v5 & 4) == 0) {
    uint64_t v19 = 109051904;
  }
  int64x2_t v20 = (const char *)(v18 | v19);
  *(_DWORD *)(a3 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a3, v13);
  *(int32x2_t *)(a3 + 188) = vmovn_s64(v30);
  return RB::RenderPass::draw_indexed_primitives((int32x2_t *)a3, v20, 4, ***(void ***)a3 + 80, 0, 1uLL, (int32x2_t)0xC0000001C0000001, (int32x2_t)0x7FFFFFFF7FFFFFFFLL);
}

void *RB::Filter::RGBACurves::encode(float32x4_t *this, RB::Encoder *a2)
{
  RB::ProtobufEncoder::float4_field(a2, 1, this[1]);
  RB::ProtobufEncoder::float4_field(a2, 2, this[2]);
  RB::ProtobufEncoder::float4_field(a2, 3, this[3]);
  __n128 result = RB::ProtobufEncoder::float4_field(a2, 4, this[4]);
  __int32 v5 = this->i32[0];
  if ((this->i32[0] & 1) == 0)
  {
    if ((v5 & 2) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    RB::ProtobufEncoder::encode_varint(a2, 0x30uLL);
    __n128 result = RB::ProtobufEncoder::encode_varint(a2, 1uLL);
    if ((this->i32[0] & 4) == 0) {
      return result;
    }
    goto LABEL_7;
  }
  RB::ProtobufEncoder::encode_varint(a2, 0x28uLL);
  __n128 result = RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  __int32 v5 = this->i32[0];
  if ((this->i32[0] & 2) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v5 & 4) == 0) {
    return result;
  }
LABEL_7:
  RB::ProtobufEncoder::encode_varint(a2, 0x38uLL);
  return RB::ProtobufEncoder::encode_varint(a2, 1uLL);
}

unint64_t RB::Filter::RGBACurves::decode(__n128 *this, RB::Decoder *a2)
{
  unint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    unint64_t v5 = result;
    do
    {
      switch((v5 >> 3))
      {
        case 1u:
          this[1] = RB::ProtobufDecoder::float4_field(a2, v5);
          break;
        case 2u:
          this[2] = RB::ProtobufDecoder::float4_field(a2, v5);
          break;
        case 3u:
          this[3] = RB::ProtobufDecoder::float4_field(a2, v5);
          break;
        case 4u:
          this[4] = RB::ProtobufDecoder::float4_field(a2, v5);
          break;
        case 5u:
          unsigned __int32 v6 = this->n128_u32[0] | RB::ProtobufDecoder::BOOL_field(a2, v5);
          goto LABEL_17;
        case 6u:
          if (RB::ProtobufDecoder::BOOL_field(a2, v5)) {
            int v7 = 2;
          }
          else {
            int v7 = 0;
          }
          goto LABEL_16;
        case 7u:
          if (RB::ProtobufDecoder::BOOL_field(a2, v5)) {
            int v7 = 4;
          }
          else {
            int v7 = 0;
          }
LABEL_16:
          unsigned __int32 v6 = this->n128_u32[0] | v7;
LABEL_17:
          this->n128_u32[0] = v6;
          break;
        default:
          RB::ProtobufDecoder::skip_field(a2, v5);
          break;
      }
      unint64_t result = RB::ProtobufDecoder::next_field(a2);
      unint64_t v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::Filter::RGBACurves::print(RB::Filter::RGBACurves *this, std::string *a2)
{
  RB::SexpString::push(a2, "rgba-curves");
  if (*(_DWORD *)this)
  {
    float32x4_t v4 = "linear";
  }
  else
  {
    if ((*(_DWORD *)this & 2) == 0) {
      goto LABEL_6;
    }
    float32x4_t v4 = "non-linear";
  }
  RB::SexpString::print(a2, 0, v4);
LABEL_6:
  RB::SexpString::printf(a2, 1, "(red-curve %g %g %g %g)", *((float *)this + 4), *((float *)this + 5), *((float *)this + 6), *((float *)this + 7));
  RB::SexpString::printf(a2, 1, "(green-curve %g %g %g %g)", *((float *)this + 8), *((float *)this + 9), *((float *)this + 10), *((float *)this + 11));
  RB::SexpString::printf(a2, 1, "(blue-curve %g %g %g %g)", *((float *)this + 12), *((float *)this + 13), *((float *)this + 14), *((float *)this + 15));
  RB::SexpString::printf(a2, 1, "(alpha-curve %g %g %g %g)", *((float *)this + 16), *((float *)this + 17), *((float *)this + 18), *((float *)this + 19));
  RB::SexpString::pop(a2);
}

void RB::Filter::Custom::apply_transform(uint64_t a1, float64x2_t *a2)
{
  *(double *)&long long v3 = RB::operator*((float64x2_t *)(a1 + 144), a2 + 68);
  *(_OWORD *)(a1 + 144) = v3;
  *(_OWORD *)(a1 + 160) = v4;
  *(_OWORD *)(a1 + 176) = v5;
}

BOOL RB::Filter::Custom::can_mix(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  return a3
      && *a1 == *(_DWORD *)a3
      && RB::CustomShader::Closure::can_mix((RB::CustomShader::Closure *)(a1 + 2), (const Closure *)(a3 + 8));
}

void RB::Filter::Custom::mix(RB::Filter::Custom *this, const RB::DisplayList::Interpolator::State *a2, const RB::Filter::Custom *a3, const RB::DisplayList::CachedTransform *a4)
{
  if (a3)
  {
    RB::CustomShader::Closure::mix((RB::Filter::Custom *)((char *)this + 8), (const RB::Filter::Custom *)((char *)a3 + 8), *((float *)a2 + 4));
    RB::mix((CGAffineTransform *)this + 3, (float64x2_t *)a3 + 9, v7, *((float *)a2 + 4));
    *((_OWORD *)this + 9) = v8;
    *((int32x4_t *)this + 10) = v9;
    *((_OWORD *)this + 11) = v10;
    *(void *)&long long v8 = *((void *)this + 24);
    *(void *)&long long v10 = *((void *)a3 + 24);
    uint64_t v11 = *((void *)a2 + 2);
    *(float32x2_t *)v9.i8 = vadd_f32(*(float32x2_t *)((char *)this + 200), *(float32x2_t *)&v8);
    *(float32x2_t *)v9.i8 = vmla_n_f32(*(float32x2_t *)v9.i8, vadd_f32(vsub_f32(*(float32x2_t *)&v10, *(float32x2_t *)v9.i8), *(float32x2_t *)((char *)a3 + 200)), *(float *)&v11);
    *((double *)this + 24) = RB::Rect::from_bounds(vmla_n_f32(*(float32x2_t *)&v8, vsub_f32(*(float32x2_t *)&v10, *(float32x2_t *)&v8), *(float *)&v11), v9);
    *((void *)this + 25) = v12;
  }
}

uint64_t RB::Filter::Custom::prepare(uint64_t a1, uint64_t **a2)
{
  return RB::CustomShader::Closure::prepare(a1 + 8, a2);
}

Function *RB::Filter::Custom::render(uint64_t a1, uint64_t **a2, double a3, float a4, uint64_t a5, uint64_t a6)
{
  _S8 = a4;
  uint64_t v11 = (void *)(a1 + 8);
  uint64_t v10 = *(void *)(a1 + 8);
  uint64_t v12 = v11 + 1;
  uint64_t v13 = v11[14];
  if (v11[13]) {
    uint64_t v12 = (void *)v11[13];
  }
  uint64_t v14 = **a2;
  *(void *)long long v41 = v12;
  *(void *)&v41[8] = v13;
  unint64_t result = (Function *)RB::CustomShader::Function::function(v10, v14, 1u, v41);
  if (result)
  {
    long long v16 = result;
    RB::RenderFrame::add_function(**a2, result);
    unint64_t result = (Function *)RB::RenderFrame::alloc_buffer_region((RB::RenderFrame *)**a2, (RB::Device *)(*((unsigned int *)v16 + 20) + 56), 4uLL, 0, &v39);
    if (v39)
    {
      uint64_t v18 = *((void *)v39 + 7) + v40.i64[0];
      RB::Coverage::set_plane((float32x2_t *)v18, (uint64_t)a2, v17);
      long long v19 = *(_OWORD *)(a1 + 160);
      *(_OWORD *)long long v41 = *(_OWORD *)(a1 + 144);
      *(_OWORD *)&v41[16] = v19;
      long long v42 = *(_OWORD *)(a1 + 176);
      BOOL v20 = RB::AffineTransform::invert((RB::AffineTransform *)v41);
      if (v20) {
        uint64_t v21 = (float64x2_t *)v41;
      }
      else {
        uint64_t v21 = (float64x2_t *)(a1 + 144);
      }
      float64x2_t v22 = *v21;
      if (v20) {
        float32x4_t v23 = (float64x2_t *)&v41[16];
      }
      else {
        float32x4_t v23 = (float64x2_t *)(a1 + 160);
      }
      float64x2_t v24 = *v23;
      float32x4_t v25 = (float64x2_t *)(a1 + 176);
      if (v20) {
        float32x4_t v25 = (float64x2_t *)&v42;
      }
      long long v26 = a2[13];
      v27.i64[0] = (int)v26;
      v27.i64[1] = SHIDWORD(v26);
      __asm { FMOV            V6.2D, #0.5 }
      int64x2_t v33 = (int64x2_t)vmulq_f64(vcvtq_f64_s64(v27), _Q6);
      float64x2_t v34 = vmulq_n_f64(v22, *(double *)v33.i64);
      _Q0 = vmlaq_f64(vaddq_f64(vmlaq_n_f64(*v25, v22, (double)-LODWORD(a3)), v34), v24, vaddq_f64((float64x2_t)vdupq_laneq_s64(v33, 1), (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)-HIDWORD(a3)), 0)));
      *(float32x2_t *)(v18 + 28) = vcvt_f32_f64(v34);
      *(float32x2_t *)(v18 + 36) = vcvt_f32_f64(vmulq_n_f64(v24, -*(double *)&v33.i64[1]));
      *(float32x2_t *)(v18 + 44) = vcvt_f32_f64(_Q0);
      __asm { FCVT            H0, S8 }
      *(_WORD *)(v18 + 52) = LOWORD(_Q0.f64[0]);
      memset(v41, 0, 24);
      int64x2_t v38 = 0;
      unint64_t result = (Function *)RB::CustomShader::Closure::marshal_args(v11, (uint64_t)a2, (uint64_t)v16, (_OWORD *)(a1 + 192), v18 + 56, (uint64_t)v41, &v38);
      if (result)
      {
        *((_DWORD *)a2 + 55) = RB::RenderFrame::buffer_id((RB::RenderFrame *)**a2, *(RB::Buffer **)v41);
        a2[28] = (uint64_t *)vmovn_s64(*(int64x2_t *)&v41[8]);
        *((_DWORD *)a2 + 46) = RB::RenderFrame::buffer_id((RB::RenderFrame *)**a2, v39);
        *(uint64_t **)((char *)a2 + 188) = (uint64_t *)vmovn_s64(v40);
        if (v38) {
          *((_DWORD *)a2 + 58) = RB::RenderFrame::texture_id((RB::RenderFrame *)**a2, (uint64_t)v38);
        }
        int v37 = 0;
        unint64_t result = (Function *)RB::RenderPass::draw_indexed_primitives((int32x2_t *)a2, (const char *)((a6 & 0xFFFFF | (((16 * *(_DWORD *)a1) & 0x80 | v37 & 0xEF3 | (4 * (v37 & 1u)) | (*((_DWORD *)v16 + 25) >> 31 << 8)) << 20)) ^ 0x10000000 | ((unint64_t)(BYTE4(a6) & 0x3Fu | (*(_DWORD *)v16 << 6)) << 32)), 4, *(void *)**a2 + 80, 0, 1uLL, (int32x2_t)0xC0000001C0000001, (int32x2_t)0x7FFFFFFF7FFFFFFFLL);
        *(uint64_t **)((char *)a2 + 220) = 0;
        *(uint64_t **)((char *)a2 + 228) = 0;
        *((unsigned char *)a2 + 236) = 0;
      }
    }
  }
  return result;
}

Function *RB::Filter::Custom::render(uint64_t a1, double a2, uint64_t a3, uint64_t a4)
{
  if (*(_DWORD *)(a4 + 136) == 2) {
    uint64_t v4 = 131102;
  }
  else {
    uint64_t v4 = 30;
  }
  return RB::Filter::Custom::render(a1, (uint64_t **)a4, a2, 1.0, a4, v4);
}

uint64_t *RB::Filter::Custom::prepare_encode(RB::Filter::Custom *this, RB::Encoder *a2)
{
  return RB::CustomShader::Closure::prepare_encode((RB::Filter::Custom *)((char *)this + 8), a2);
}

void *RB::Filter::Custom::encode(RB::Filter::Custom *this, RB::Encoder *a2)
{
  uint64_t v4 = (RB::CustomShader::Function **)((char *)this + 8);
  RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::CustomShader::Closure::encode(v4, a2);
  unint64_t result = RB::ProtobufEncoder::end_length_delimited(a2);
  int64x2_t v6 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(*((float64x2_t *)this + 10), (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*((float64x2_t *)this + 9), (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(*((float64x2_t *)this + 11)));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v6, 1), (int8x16_t)v6).u64[0] & 0x8000000000000000) == 0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::AffineTransform::encode((double *)this + 18, a2);
    unint64_t result = RB::ProtobufEncoder::end_length_delimited(a2);
  }
  int v7 = *(_DWORD *)this;
  if (*(_DWORD *)this)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x18uLL);
    unint64_t result = RB::ProtobufEncoder::encode_varint(a2, 1uLL);
    int v7 = *(_DWORD *)this;
  }
  if ((v7 & 8) != 0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x20uLL);
    unint64_t result = RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  }
  uint32x2_t v8 = (uint32x2_t)vcgtz_f32(*(float32x2_t *)((char *)this + 200));
  if ((vpmin_u32(v8, v8).u32[0] & 0x80000000) != 0)
  {
    float32x4_t v9 = *((float32x4_t *)this + 12);
    return RB::ProtobufEncoder::float4_field(a2, 5, v9);
  }
  return result;
}

unint64_t RB::Filter::Custom::decode(__n128 *this, RB::Decoder *a2)
{
  unint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    unint64_t v5 = result;
    do
    {
      switch((v5 >> 3))
      {
        case 1u:
          if ((v5 & 7) != 2) {
            goto LABEL_19;
          }
          RB::ProtobufDecoder::begin_message(a2);
          RB::CustomShader::Closure::decode((RB::CustomShader::Closure *)&this->n128_i8[8], a2);
          goto LABEL_9;
        case 2u:
          if ((v5 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message(a2);
            RB::AffineTransform::decode((RB::AffineTransform *)&this[9], a2);
LABEL_9:
            RB::ProtobufDecoder::end_message((uint64_t)a2);
          }
          else
          {
LABEL_19:
            *((unsigned char *)a2 + 56) = 1;
            *(void *)a2 = *((void *)a2 + 1);
          }
          break;
        case 3u:
          unsigned __int32 v6 = this->n128_u32[0] | RB::ProtobufDecoder::BOOL_field(a2, v5);
          goto LABEL_15;
        case 4u:
          this->n128_u32[0] &= ~8u;
          if (RB::ProtobufDecoder::BOOL_field(a2, v5)) {
            int v7 = 8;
          }
          else {
            int v7 = 0;
          }
          unsigned __int32 v6 = this->n128_u32[0] | v7;
LABEL_15:
          this->n128_u32[0] = v6;
          break;
        case 5u:
          this[12] = RB::ProtobufDecoder::float4_field(a2, v5);
          break;
        default:
          RB::ProtobufDecoder::skip_field(a2, v5);
          break;
      }
      unint64_t result = RB::ProtobufDecoder::next_field(a2);
      unint64_t v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::Filter::Custom::print(float32x2_t *this, std::string *a2)
{
  RB::SexpString::push(a2, "custom-filter");
  RB::SexpString::print(a2, 0, "#:type color");
  float32x2_t v4 = this[1];
  if (v4) {
    RB::SexpString::printf(a2, 0, "#:shader %s", (const char *)[*(id *)(*(void *)&v4 + 24) UTF8String]);
  }
  float32x2_t v5 = this[25];
  uint32x2_t v6 = (uint32x2_t)vcgtz_f32(v5);
  if ((vpmin_u32(v6, v6).u32[0] & 0x80000000) != 0) {
    RB::SexpString::printf(a2, 0, "#: bounds (%g %g; %g %g)",
  }
      COERCE_FLOAT(*(void *)&this[24]),
      COERCE_FLOAT(HIDWORD(*(void *)&this[24])),
      v5.f32[0],
      v5.f32[1]);
  __int32 v7 = this->i32[0];
  if (this->i32[0])
  {
    RB::SexpString::print(a2, 0, "linear");
    __int32 v7 = this->i32[0];
  }
  if ((v7 & 8) != 0) {
    RB::SexpString::print(a2, 0, "dither");
  }
  float32x2_t v8 = this[25];
  uint32x2_t v9 = (uint32x2_t)vcgtz_f32(v8);
  if ((vpmin_u32(v9, v9).u32[0] & 0x80000000) != 0) {
    RB::SexpString::printf(a2, 0, "(bounds %g %g %g %g)", COERCE_FLOAT(*(void *)&this[24]), COERCE_FLOAT(HIDWORD(*(void *)&this[24])), v8.f32[0], v8.f32[1]);
  }
  RB::SexpString::pop(a2);
}

void sub_214157218(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  if (a19) {
    free(a19);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&devices_lock);
  _Unwind_Resume(a1);
}

uint64_t collect_resources(uint64_t result)
{
  int v1 = 1;
  atomic_compare_exchange_strong((atomic_uint *volatile)(result + 16), (unsigned int *)&v1, 0);
  if (v1 == 1)
  {
    double v2 = (void *)result;
    unint64_t result = RB::Device::prune_caches(*(dispatch_queue_t **)(result + 8));
    if (result)
    {
      return [v2 collectResources];
    }
  }
  return result;
}

uint64_t render_image(uint64_t a1, void *a2, uint64_t a3, double a4, double a5, double a6, double a7)
{
  make_image_provider(a1, a2, a3, &v12, a4, a5, a6, a7);
  float32x2_t v8 = v12;
  if (!v12) {
    return 0;
  }
  if ((objc_msgSend((id)objc_msgSend(a2, "objectForKeyedSubscript:", RBImageRendererDeferRendering), "BOOLValue") & 1) == 0) {
    RB::ImageProvider::start_rendering((RB::ImageProvider *)v8);
  }
  RB::ImageProvider::make_cgimage((RB::ImageProvider *)v8, &v11);
  uint64_t v9 = v11;
  if (atomic_fetch_add_explicit(v8 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v8 + 8))(v8);
  }
  return v9;
}

void sub_21415747C(_Unwind_Exception *exception_object)
{
  if (atomic_fetch_add_explicit(v1 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void render_image_async(uint64_t a1, void *a2, uint64_t a3, NSObject *a4, uint64_t a5, double a6, double a7, double a8, double a9)
{
  make_image_provider(a1, a2, a3, &v16, a6, a7, a8, a9);
  uint64_t v11 = v16;
  if (v16)
  {
    v14[0] = MEMORY[0x263EF8330];
    v14[1] = 3221225472;
    void v14[2] = ___ZL18render_image_asyncP8RBDevice6CGRectP12NSDictionaryU13block_pointerFvP13RBDisplayListEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvP7CGImageE_block_invoke_2;
    _OWORD v14[3] = &unk_2641F85A0;
    void v14[4] = a5;
    uint64_t v12 = [v14 copy];

    *(void *)(v11 + 32) = v12;
    uint64_t v13 = *(NSObject **)(v11 + 40);
    if (v13 != a4)
    {

      *(void *)(v11 + 40) = a4;
    }
    RB::ImageProvider::start_rendering((RB::ImageProvider *)v11);
    if (atomic_fetch_add_explicit((atomic_uint *volatile)(v11 + 8), 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    }
  }
  else
  {
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = ___ZL18render_image_asyncP8RBDevice6CGRectP12NSDictionaryU13block_pointerFvP13RBDisplayListEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvP7CGImageE_block_invoke;
    block[3] = &unk_2641F8578;
    block[4] = a5;
    dispatch_async(a4, block);
  }
}

void sub_214157644(_Unwind_Exception *exception_object)
{
  if (atomic_fetch_add_explicit((atomic_uint *volatile)(v1 + 8), 0xFFFFFFFF, memory_order_release) == 1) {
    render_image_async(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_214157D70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

void sub_214157E78(_Unwind_Exception *a1)
{
}

void *make_image_provider@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>, double a5@<D0>, double a6@<D1>, double a7@<D2>, double a8@<D3>)
{
  uint64_t v14 = a1;
  if (a1 && +[RBDevice isRunningInBackground])
  {
    unint64_t result = objc_msgSend((id)objc_msgSend(a2, "objectForKeyedSubscript:", RBImageRendererBackgroundGPUMode), "intValue");
    if (!result) {
      goto LABEL_14;
    }
    if (result == 1) {
      uint64_t v14 = 0;
    }
  }
  unint64_t result = (void *)[a2 objectForKeyedSubscript:RBImageRendererScale];
  if (result)
  {
    unint64_t result = (void *)[result doubleValue];
    double v18 = v17;
    if (v17 <= 0.0) {
      goto LABEL_14;
    }
  }
  else
  {
    double v18 = 1.0;
  }
  double v19 = ceil(v18 * a7);
  if (v19 > 0.0)
  {
    double v20 = ceil(v18 * a8);
    if (v20 > 0.0)
    {
      uint64_t v21 = (void *)[a2 objectForKeyedSubscript:RBImageRendererColorMode];
      if (v21) {
        uint64_t v22 = [v21 intValue];
      }
      else {
        uint64_t v22 = 0;
      }
      RB::ColorMode::ColorMode(v34, v22);
      float32x4_t v23 = objc_opt_new();
      [v23 setProfile:1];
      [v23 setDefaultColorSpace:rb_color_space(((v34[4] & 1) == 0) | 0x100u)];
      objc_msgSend(v23, "setContentRect:", *MEMORY[0x263F00148], *(double *)(MEMORY[0x263F00148] + 8), v19, v20);
      *(double *)int64x2_t v33 = v18;
      v33[1] = 0;
      _OWORD v33[2] = 0;
      *(double *)&float64x2_t v33[3] = v18;
      *(double *)&v33[4] = -(a5 * v18);
      *(double *)&v33[5] = -(a6 * v18);
      [v23 concat:v33];
      (*(void (**)(uint64_t, void *))(a3 + 16))(a3, v23);
      uint64_t v24 = objc_msgSend(v23, "_rb_contents");
      if (v24)
      {
        int v25 = RB::DisplayList::Layer::output_depth((RB::DisplayList::Layer *)(v24 + 320));
        v34[0] = RB::max_color_depth(v34[0], v25);
      }
      long long v32 = RBColorClear;
      long long v26 = (void *)[a2 objectForKeyedSubscript:RBImageRendererBackgroundColor];
      if (v26)
      {
        [v26 getValue:&v32 size:16];
      }
      else
      {
        int v28 = (void *)[a2 objectForKeyedSubscript:RBImageRendererOpaque];
        if (v28)
        {
          if ([v28 BOOLValue]) {
            char v27 = 24;
          }
          else {
            char v27 = 25;
          }
LABEL_25:
          long long v29 = (void *)[a2 objectForKeyedSubscript:RBImageRendererPromotesFramebuffer];
          if (v29 && ![v29 BOOLValue]) {
            v27 |= 0x20u;
          }
          __int16 v31 = 0;
          if (v14) {
            uint64_t v30 = *(void *)(v14 + 8);
          }
          else {
            uint64_t v30 = 0;
          }
          RB::ColorMode::pixel_format(v34, v30, v27, (unsigned char *)&v31 + 1, (BOOL *)&v31, 0);
          [v23 moveContents];
          operator new();
        }
      }
      char v27 = 25;
      goto LABEL_25;
    }
  }
LABEL_14:
  *a4 = 0;
  return result;
}

void sub_2141581D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL18render_image_asyncP8RBDevice6CGRectP12NSDictionaryU13block_pointerFvP13RBDisplayListEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvP7CGImageE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void ___ZL18render_image_asyncP8RBDevice6CGRectP12NSDictionaryU13block_pointerFvP13RBDisplayListEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvP7CGImageE_block_invoke_2(uint64_t a1, RB::ImageProvider *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  RB::ImageProvider::make_cgimage(this, &cf);
  (*(void (**)(uint64_t, CFTypeRef))(v2 + 16))(v2, cf);
  if (cf) {
    CFRelease(cf);
  }
}

void sub_2141582A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void *RB::vector<RBDevice *,8ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 10) + (*((void *)__dst + 10) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 10) + (*((void *)__dst + 10) >> 1);
  }
  unint64_t result = RB::details::realloc_vector<unsigned long,8ul>(*((void **)__dst + 8), __dst, 8uLL, (size_t *)__dst + 10, v3);
  *((void *)__dst + 8) = result;
  return result;
}

uint64_t std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      size_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  float32x2_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t *std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::__emplace_unique_impl<RB::FormattedRenderState::ID>(void *a1, uint64_t *a2)
{
  float32x2_t v4 = operator new(0x20uLL);
  uint64_t v5 = *a2;
  void v4[2] = *a2;
  int v6 = *((_DWORD *)a2 + 2);
  *((_DWORD *)v4 + 6) = v6;
  *float32x2_t v4 = 0;
  v4[1] = (33 * v6) ^ v5;
  inserted = std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::__node_insert_unique(a1, (uint64_t)v4);
  if ((v8 & 1) == 0) {
    operator delete(v4);
  }
  return inserted;
}

void sub_21415842C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::__node_insert_unique(void *a1, uint64_t a2)
{
  uint64_t v2 = (void *)a2;
  float32x2_t v4 = (_DWORD *)(a2 + 16);
  unint64_t v5 = (33 * *(_DWORD *)(a2 + 24)) ^ *(_DWORD *)(a2 + 16);
  *((void *)v4 - 1) = v5;
  int v6 = std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::__node_insert_unique_prepare[abi:nn180100]((uint64_t)a1, v5, v4);
  if (v6) {
    return v6;
  }
  std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::__node_insert_unique_perform[abi:nn180100](a1, v2);
  return v2;
}

uint64_t *std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::__node_insert_unique_prepare[abi:nn180100](uint64_t a1, unint64_t a2, _DWORD *a3)
{
  unint64_t v3 = *(void *)(a1 + 8);
  if (v3)
  {
    uint8x8_t v4 = (uint8x8_t)vcnt_s8((int8x8_t)v3);
    v4.i16[0] = vaddlv_u8(v4);
    if (v4.u32[0] > 1uLL) {
      uint64_t v5 = v3 <= a2 ? a2 % v3 : a2;
    }
    else {
      uint64_t v5 = (v3 - 1) & a2;
    }
    int v6 = *(uint64_t ***)(*(void *)a1 + 8 * v5);
    if (v6)
    {
      for (uint64_t i = *v6; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v8 = i[1];
        if (v8 == a2)
        {
          if (*a3 == *((_DWORD *)i + 4)
            && *((_DWORD *)i + 5) == a3[1]
            && ((a3[2] ^ *((_DWORD *)i + 6)) & 0xFBFFFFFF) == 0)
          {
            return i;
          }
        }
        else
        {
          if (v4.u32[0] > 1uLL)
          {
            if (v8 >= v3) {
              v8 %= v3;
            }
          }
          else
          {
            v8 &= v3 - 1;
          }
          if (v8 != v5) {
            break;
          }
        }
      }
    }
  }
  float v9 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v10 = *(float *)(a1 + 32);
  if (!v3 || (float)(v10 * (float)v3) < v9)
  {
    uint64_t v11 = 2 * v3;
    BOOL v12 = v3 < 3 || (v3 & (v3 - 1)) != 0;
    size_t v13 = v12 | v11;
    unint64_t v14 = vcvtps_u32_f32(v9 / v10);
    if (v13 <= v14) {
      size_t v15 = v14;
    }
    else {
      size_t v15 = v13;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__rehash<true>(a1, v15);
  }
  return 0;
}

void *std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::__node_insert_unique_perform[abi:nn180100](void *result, void *a2)
{
  int8x8_t v2 = (int8x8_t)result[1];
  unint64_t v3 = a2[1];
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    if (v3 >= *(void *)&v2) {
      v3 %= *(void *)&v2;
    }
  }
  else
  {
    v3 &= *(void *)&v2 - 1;
  }
  uint64_t v5 = *(void **)(*result + 8 * v3);
  if (v5)
  {
    *a2 = *v5;
LABEL_13:
    *uint64_t v5 = a2;
    goto LABEL_14;
  }
  *a2 = result[2];
  result[2] = a2;
  *(void *)(*result + 8 * v3) = result + 2;
  if (*a2)
  {
    unint64_t v6 = *(void *)(*a2 + 8);
    if (v4.u32[0] > 1uLL)
    {
      if (v6 >= *(void *)&v2) {
        v6 %= *(void *)&v2;
      }
    }
    else
    {
      v6 &= *(void *)&v2 - 1;
    }
    uint64_t v5 = (void *)(*result + 8 * v6);
    goto LABEL_13;
  }
LABEL_14:
  ++result[3];
  return result;
}

uint64_t std::unordered_set<RB::FormattedRenderState>::unordered_set(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__rehash<true>(a1, *(void *)(a2 + 8));
  for (uint64_t i = *(unsigned int **)(a2 + 16); i; uint64_t i = *(unsigned int **)i)
    std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::__emplace_unique_key_args<RB::FormattedRenderState,RB::FormattedRenderState const&>(a1, i + 4, (uint64_t)(i + 4));
  return a1;
}

void sub_2141586F4(_Unwind_Exception *a1)
{
  std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::__emplace_unique_key_args<RB::FormattedRenderState,RB::FormattedRenderState const&>(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  unsigned int v6 = *a2;
  unsigned int v7 = a2[2];
  unint64_t v8 = (33 * v7) ^ *a2;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      uint64_t v3 = (33 * v7) ^ v6;
      if (v8 >= v9) {
        uint64_t v3 = v8 % v9;
      }
    }
    else
    {
      uint64_t v3 = v8 & (v9 + 0xFFFFFFFF);
    }
    uint64_t v11 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v11)
    {
      BOOL v12 = *v11;
      if (*v11)
      {
        do
        {
          unint64_t v13 = v12[1];
          if (v13 == v8)
          {
            if (*((_DWORD *)v12 + 4) == v6
              && *((_DWORD *)v12 + 5) == a2[1]
              && ((*((_DWORD *)v12 + 6) ^ v7) & 0xFBFFFFFF) == 0)
            {
              return v12;
            }
          }
          else
          {
            if (v10.u32[0] > 1uLL)
            {
              if (v13 >= v9) {
                v13 %= v9;
              }
            }
            else
            {
              v13 &= v9 - 1;
            }
            if (v13 != v3) {
              break;
            }
          }
          BOOL v12 = (void *)*v12;
        }
        while (v12);
      }
    }
  }
  BOOL v12 = operator new(0x20uLL);
  *BOOL v12 = 0;
  v12[1] = v8;
  float64x2_t v12[2] = *(void *)a3;
  *((_DWORD *)v12 + 6) = *(_DWORD *)(a3 + 8);
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v9 || (float)(v15 * (float)v9) < v14)
  {
    BOOL v16 = 1;
    if (v9 >= 3) {
      BOOL v16 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v9);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__rehash<true>(a1, v19);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        uint64_t v3 = v8 % v9;
      }
      else {
        uint64_t v3 = v8;
      }
    }
    else
    {
      uint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v20 = *(void *)a1;
  uint64_t v21 = *(void **)(*(void *)a1 + 8 * v3);
  if (v21)
  {
    *BOOL v12 = *v21;
LABEL_40:
    *uint64_t v21 = v12;
    goto LABEL_41;
  }
  *BOOL v12 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v12;
  *(void *)(v20 + 8 * v3) = a1 + 16;
  if (*v12)
  {
    unint64_t v22 = *(void *)(*v12 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v22 >= v9) {
        v22 %= v9;
      }
    }
    else
    {
      v22 &= v9 - 1;
    }
    uint64_t v21 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_40;
  }
LABEL_41:
  ++*(void *)(a1 + 24);
  return v12;
}

void sub_214158950(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void RBStrokeBoundingRect(void *a1, float *a2)
{
  int v4 = [a1 strokeType];
  if (v4 == 1)
  {
    uint8x8_t v10 = (CGImage *)[a1 image];
    if (v10)
    {
      uint64_t v11 = v10;
      float Width = (float)CGImageGetWidth(v10);
      float v13 = Width / (float)(unint64_t)[a1 imageCount];
      size_t Height = CGImageGetHeight(v11);
      if (v13 < (float)Height) {
        float v13 = (float)Height;
      }
      [a1 imageScale];
      float v16 = (float)(v15 * 0.5) * v13;
    }
    else
    {
      float v16 = 0.0;
    }
    unint64_t v22 = (uint64_t (**)(void))&unk_26C4E8288;
    __int16 v23 = 256;
    float v24 = 0.0;
    float32x2_t v25 = (float32x2_t)vdup_n_s32(0x7F800000u);
    uint64_t v26 = 0x7F0000007FLL;
    long long v27 = 0u;
    long long v28 = 0u;
    uint64_t v29 = 0;
    char v30 = 1;
    float v31 = 0.0;
    float v32 = v16;
    __asm { FMOV            V0.2S, #1.0 }
    *(void *)&v33[1] = _D0;
    *(void *)&float64x2_t v33[3] = 1065353216;
    long long v34 = 0u;
    uint64_t v35 = 1065353216;
    RB::Stroke::stroke_particles(a1, &v22, (float64x2_t)0);
    if (!a2) {
      goto LABEL_16;
    }
    float v9 = v31;
    goto LABEL_15;
  }
  if (!v4)
  {
    char v5 = rb_line_cap([a1 lineCap]);
    int v6 = rb_line_join((CGLineJoin)[a1 lineJoin]);
    [a1 miterLimit];
    unint64_t v22 = (uint64_t (**)(void))&unk_26C4E8248;
    LOBYTE(v23) = v5;
    HIBYTE(v23) = v6;
    float v24 = v7 * v7;
    float32x2_t v25 = (float32x2_t)vdup_n_s32(0x7F800000u);
    uint64_t v26 = 0x7F0000007FLL;
    long long v27 = 0u;
    long long v28 = 0u;
    uint64_t v29 = 0;
    char v30 = 1;
    float v31 = 0.0;
    *(void *)int64x2_t v33 = 0x3F80000000000000;
    RB::Stroke::stroke_points(a1, &v22, (float64x2_t)0);
    if (!a2)
    {
LABEL_16:
      v8.i64[0] = v26;
      RB::Rect::from_bounds(v25, v8);
      return;
    }
    float v9 = v31;
    if (!v6) {
      float v9 = v31 * 1.4142;
    }
LABEL_15:
    *a2 = v9;
    goto LABEL_16;
  }
}

void *RB::vector<float,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1) <= a2) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1);
  }
  unint64_t result = RB::details::realloc_vector<unsigned long,4ul>(*(void **)a1, (size_t *)(a1 + 16), v3);
  *(void *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,4ul>(void *a1, size_t *a2, uint64_t a3)
{
  int v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(4 * a3);
    size_t v6 = v5 >> 2;
    if (v5 >> 2 != *a2)
    {
      float v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7) {
        RB::precondition_failure((RB *)"allocation failure", v8);
      }
      int v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

float32x2_t RB::Stroke::Bounds<RB::Stroke::Point,RBStrokeBoundingRect::$_0>::endpath(uint64_t a1, float32x2_t a2, double a3)
{
  return RB::Stroke::LineBounds::endpath((RB::Stroke::LineBounds *)(a1 + 8), a2, a3);
}

void RB::Stroke::Bounds<RB::Stroke::Point,RBStrokeBoundingRect::$_0>::closepath(float32x2_t *a1, double a2, double a3)
{
}

void RB::Stroke::Bounds<RB::Stroke::Point,RBStrokeBoundingRect::$_0>::moveto(uint64_t a1, _DWORD *a2, double a3, double a4)
{
  LODWORD(a4) = *a2;
  RB::Stroke::LineBounds::moveto(a1 + 8, a3, a4);
}

void RB::Stroke::Bounds<RB::Stroke::Point,RBStrokeBoundingRect::$_0>::lineto(float32x2_t *a1, _DWORD *a2, float32x2_t a3, double a4)
{
  LODWORD(a4) = *a2;
  RB::Stroke::LineBounds::lineto(a1 + 1, a3, a4);
}

void RB::Stroke::Bounds<RB::Stroke::Point,RBStrokeBoundingRect::$_0>::quadto(float32x2_t *a1, float *a2, float32x2_t a3, float32x2_t a4, double a5, double a6, int32x4_t a7, int32x4_t a8, int32x4_t a9, int32x4_t a10)
{
}

void RB::Stroke::Bounds<RB::Stroke::Point,RBStrokeBoundingRect::$_0>::cubeto(uint64_t a1, float *a2, float32x2_t a3, float32x2_t a4, float32x2_t a5, double a6, int32x4_t a7, int32x4_t a8, int32x4_t a9, int32x4_t a10)
{
}

float32x2_t RB::Stroke::Bounds<RB::Stroke::Particle,RBStrokeBoundingRect::$_1>::endpath(uint64_t a1, float32x2_t a2, double a3)
{
  return RB::Stroke::LineBounds::endpath((RB::Stroke::LineBounds *)(a1 + 8), a2, a3);
}

void RB::Stroke::Bounds<RB::Stroke::Particle,RBStrokeBoundingRect::$_1>::closepath(float32x2_t *a1, double a2, double a3)
{
}

float RB::Stroke::Bounds<RB::Stroke::Particle,RBStrokeBoundingRect::$_1>::moveto(uint64_t a1, uint64_t a2, double a3)
{
  double v3 = *(double *)(a2 + 8);
  *(float *)&double v3 = vaddv_f32(*(float32x2_t *)&v3) * 1.4142;
  float v4 = *(float *)(a2 + 4);
  if (v4 < 1.0) {
    float v4 = 1.0;
  }
  *(float *)&double v3 = (float)(*(float *)&v3 * v4)
                * (float)(COERCE_FLOAT(HIDWORD(*(void *)(a2 + 24)))
                        + (float)(*(float *)(a1 + 80) + COERCE_FLOAT(*(void *)(a2 + 24))));
  RB::Stroke::LineBounds::moveto(a1 + 8, a3, v3);
  return result;
}

float RB::Stroke::Bounds<RB::Stroke::Particle,RBStrokeBoundingRect::$_1>::lineto(float32x2_t *a1, uint64_t a2, float32x2_t a3)
{
  double v3 = *(double *)(a2 + 8);
  *(float *)&double v3 = vaddv_f32(*(float32x2_t *)&v3) * 1.4142;
  float v4 = *(float *)(a2 + 4);
  if (v4 < 1.0) {
    float v4 = 1.0;
  }
  *(float *)&double v3 = (float)(*(float *)&v3 * v4)
                * (float)(COERCE_FLOAT(HIDWORD(*(void *)(a2 + 24)))
                        + (float)(a1[10].f32[0] + COERCE_FLOAT(*(void *)(a2 + 24))));
  RB::Stroke::LineBounds::lineto(a1 + 1, a3, v3);
  return result;
}

float RB::Stroke::Bounds<RB::Stroke::Particle,RBStrokeBoundingRect::$_1>::quadto(float32x2_t *a1, float32x2_t *a2, float32x2_t a3, float32x2_t a4, double a5, double a6, int32x4_t a7, int32x4_t a8, int32x4_t a9, int32x4_t a10)
{
  float v10 = vaddv_f32(a2[1]) * 1.4142;
  LODWORD(a6) = a2->i32[1];
  if (*(float *)&a6 < 1.0) {
    *(float *)&a6 = 1.0;
  }
  float v11 = v10 * *(float *)&a6;
  *(float32x2_t *)a7.i8 = a2[3];
  a8.i32[0] = a7.i32[1];
  *(float *)&a6 = *(float *)&a7.i32[1] + (float)(a1[10].f32[0] + *(float *)a7.i32);
  RB::Stroke::LineBounds::quadto(a1 + 1, a3, a4, v11 * *(float *)&a6, a6, a7, a8, a9, a10);
  return result;
}

float RB::Stroke::Bounds<RB::Stroke::Particle,RBStrokeBoundingRect::$_1>::cubeto(uint64_t a1, float32x2_t *a2, float32x2_t a3, float32x2_t a4, float32x2_t a5, double a6, int32x4_t a7, int32x4_t a8, int32x4_t a9, int32x4_t a10)
{
  float v10 = vaddv_f32(a2[1]) * 1.4142;
  a7.i32[0] = a2->i32[1];
  if (*(float *)a7.i32 < 1.0) {
    *(float *)a7.i32 = 1.0;
  }
  float v11 = v10 * *(float *)a7.i32;
  *(float32x2_t *)a8.i8 = a2[3];
  a9.i32[0] = a8.i32[1];
  *(float *)a7.i32 = *(float *)&a8.i32[1] + (float)(*(float *)(a1 + 80) + *(float *)a8.i32);
  RB::Stroke::LineBounds::cubeto(a1 + 8, a3, a4, a5, v11 * *(float *)a7.i32, a7, a8, a9, a10);
  return result;
}

uint64_t RB::Symbol::GlyphCache::tag(os_unfair_lock_s *a1, unsigned int a2)
{
  os_unfair_lock_lock(a1);
  uint64_t v6 = 0;
  v7[0] = &v6;
  v7[1] = a2;
  RB::UntypedTable::for_each((uint64_t)&a1[32], (void (*)(const void *, const void *, void *))RB::Table<NSString *,unsigned int>::for_each<RB::Symbol::GlyphCache::tag(RB::Symbol::Tag)::$_0>(RB::Symbol::GlyphCache::tag(RB::Symbol::Tag)::$_0)const::{lambda(void const*,void const*,void *)#1}::__invoke, v7);
  uint64_t v4 = v6;
  os_unfair_lock_unlock(a1);
  return v4;
}

void sub_2141596EC(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::Symbol::anonymous namespace'::contains_slash_or_badge_layer(RB::Symbol::_anonymous_namespace_ *this, NSArray *a2)
{
  int8x8_t v2 = this;
  uint64_t v27 = *MEMORY[0x263EF8340];
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  uint64_t result = [(RB::Symbol::_anonymous_namespace_ *)this countByEnumeratingWithState:&v21 objects:v26 count:16];
  if (result)
  {
    uint64_t v4 = result;
    uint64_t v5 = *(void *)v22;
    uint64_t v15 = *(void *)v22;
    float v16 = v2;
    do
    {
      for (uint64_t i = 0; i != v4; ++i)
      {
        if (*(void *)v22 != v5) {
          objc_enumerationMutation(v2);
        }
        float v7 = *(void **)(*((void *)&v21 + 1) + 8 * i);
        if (objc_opt_respondsToSelector())
        {
          int32x4_t v8 = (void *)[v7 tags];
          if (v8)
          {
            float v9 = v8;
            long long v19 = 0u;
            long long v20 = 0u;
            long long v17 = 0u;
            long long v18 = 0u;
            uint64_t v10 = [v8 countByEnumeratingWithState:&v17 objects:v25 count:16];
            if (v10)
            {
              uint64_t v11 = v10;
              uint64_t v12 = *(void *)v18;
              while (2)
              {
                for (uint64_t j = 0; j != v11; ++j)
                {
                  if (*(void *)v18 != v12) {
                    objc_enumerationMutation(v9);
                  }
                  float v14 = *(void **)(*((void *)&v17 + 1) + 8 * j);
                  if ((objc_msgSend(v14, "isEqualToString:", @"_slash", v15, v16) & 1) != 0
                    || ([v14 isEqualToString:@"_badge"] & 1) != 0)
                  {
                    return 1;
                  }
                }
                uint64_t v11 = [v9 countByEnumeratingWithState:&v17 objects:v25 count:16];
                uint64_t v5 = v15;
                int8x8_t v2 = v16;
                if (v11) {
                  continue;
                }
                break;
              }
            }
          }
        }
      }
      uint64_t v4 = [(RB::Symbol::_anonymous_namespace_ *)v2 countByEnumeratingWithState:&v21 objects:v26 count:16];
      uint64_t result = 0;
    }
    while (v4);
  }
  return result;
}

void RB::Symbol::Glyph::make_legacy_layers(RB::Symbol::Glyph *this, float a2)
{
  int v4 = *((_DWORD *)this + 6);
  switch(v4)
  {
    case 0:
    case 1:
      uint64_t v5 = 1;
      goto LABEL_13;
    case 2:
      uint64_t v5 = [*(id *)this numberOfMulticolorLayers];
      goto LABEL_13;
    case 3:
      goto LABEL_5;
    case 4:
      goto LABEL_8;
    default:
      if ((v4 - 128) >= 2)
      {
        if (v4 != 130)
        {
          uint64_t v5 = 0;
          goto LABEL_13;
        }
        *((_DWORD *)this + 6) = 4;
LABEL_8:
        uint64_t v6 = [*(id *)this numberOfPaletteLayers];
      }
      else
      {
        *((_DWORD *)this + 6) = 3;
LABEL_5:
        uint64_t v6 = [*(id *)this numberOfHierarchyLayers];
      }
      uint64_t v5 = v6;
      if (!v6)
      {
        uint64_t v5 = 1;
        *((_DWORD *)this + 6) = 1;
      }
LABEL_13:
      float v7 = objc_opt_new();
      id v8 = v7;
      id v85 = v8;
      id v86 = v7;
      switch(*((_DWORD *)this + 6))
      {
        case 0:
        case 1:
          [v8 translateByX:0.0 Y:*((float *)this + 17)];
          v9.i32[0] = *((_DWORD *)this + 11);
          float32x2_t v10 = vrecpe_f32(v9);
          float32x2_t v11 = vmul_f32(vrecps_f32(v9, v10), v10);
          v11.f32[0] = vmul_f32(v11, vrecps_f32(v9, v11)).f32[0];
          [v8 scaleByX:v11.f32[0] Y:(float)-v11.f32[0]];
          uint64_t v12 = (void *)RB::Symbol::Glyph::copied_glyph(this);
          LODWORD(v13) = 1.0;
          objc_msgSend(v12, "drawInContext:", objc_msgSend(v7, "beginCGContextWithAlpha:", v13));
          [v7 endCGContext];
          float v14 = (char *)this + 112;
          int v15 = *((_DWORD *)this + 96);
          if (*((_DWORD *)this + 97) < (v15 + 1))
          {
            RB::vector<RB::Symbol::Glyph::Layer,3ul,unsigned int>::reserve_slow((char *)this + 112, v15 + 1);
            int v15 = *((_DWORD *)this + 96);
          }
          float v16 = (char *)*((void *)this + 47);
          if (!v16) {
            float v16 = (char *)this + 112;
          }
          long long v17 = &v16[88 * v15];
          *((void *)v17 + 5) = 0;
          *((void *)v17 + 1) = 0;
          *((void *)v17 + 2) = 0;
          *((void *)v17 + 6) = 0x400000000;
          *((void *)v17 + 7) = 1065353216;
          *((void *)v17 + 8) = 2139095040;
          *((void *)v17 + 9) = 1065353216;
          unsigned int v18 = *((_DWORD *)v17 + 21) & 0xFE000000 | 0x311A00;
          *((_DWORD *)v17 + 20) = -1;
          *((_DWORD *)v17 + 21) = v18;
          int v19 = *((_DWORD *)this + 96);
          *((_DWORD *)this + 96) = v19 + 1;
          long long v20 = (char *)*((void *)this + 47);
          uint64_t v21 = [v86 moveContents];
          if (v20) {
            long long v22 = v20;
          }
          else {
            long long v22 = v14;
          }
          long long v23 = &v22[88 * v19];
          *(void *)long long v23 = v21;
          int v24 = *((_DWORD *)v23 + 21);
          *((float *)v23 + 15) = a2;
          *((_DWORD *)v23 + 21) = v24 & 0xFFF3F000 | 0xC0000;
          break;
        case 2:
          if (v5)
          {
            for (uint64_t i = 0; i != v5; ++i)
            {
              [v8 translateByX:0.0 Y:*((float *)this + 17)];
              v26.i32[0] = *((_DWORD *)this + 11);
              float32x2_t v27 = vrecpe_f32(v26);
              float32x2_t v28 = vmul_f32(vrecps_f32(v26, v27), v27);
              v28.f32[0] = vmul_f32(v28, vrecps_f32(v26, v28)).f32[0];
              [v8 scaleByX:v28.f32[0] Y:(float)-v28.f32[0]];
              uint64_t v88 = 0;
              double v89 = &v88;
              uint64_t v90 = 0x4812000000;
              int32x4_t v91 = __Block_byref_object_copy_;
              unsigned int v92 = __Block_byref_object_dispose_;
              double v93 = " 0";
              int v94 = 10;
              id v95 = 0;
              CFTypeRef cf = 0;
              uint64_t v29 = (void *)RB::Symbol::Glyph::copied_glyph(this);
              LODWORD(v30) = 1.0;
              uint64_t v31 = [v7 beginCGContextWithAlpha:v30];
              v87[0] = MEMORY[0x263EF8330];
              v87[1] = 3221225472;
              v87[2] = ___ZN2RB6Symbol5Glyph18make_legacy_layersEf_block_invoke_12;
              v87[3] = &unk_2641F85F0;
              v87[4] = &v88;
              [v29 drawMulticolorLayerAtIndex:i inContext:v31 withColorResolver:v87];
              [v7 endCGContext];
              int v32 = *((_DWORD *)v89 + 12);
              int v33 = *((_DWORD *)this + 96);
              if (*((_DWORD *)this + 97) < (v33 + 1))
              {
                RB::vector<RB::Symbol::Glyph::Layer,3ul,unsigned int>::reserve_slow((char *)this + 112, v33 + 1);
                int v33 = *((_DWORD *)this + 96);
              }
              long long v34 = (char *)*((void *)this + 47);
              if (!v34) {
                long long v34 = (char *)this + 112;
              }
              uint64_t v35 = &v34[88 * v33];
              *((void *)v35 + 5) = 0;
              *((void *)v35 + 1) = 0;
              *((void *)v35 + 2) = 0;
              *((void *)v35 + 6) = 0x400000000;
              *((void *)v35 + 7) = 1065353216;
              *((void *)v35 + 8) = 2139095040;
              *((void *)v35 + 9) = 1065353216;
              unsigned int v36 = *((_DWORD *)v35 + 21) & 0xFE000000 | 0x311A00;
              *((_DWORD *)v35 + 20) = -1;
              *((_DWORD *)v35 + 21) = v36;
              int v37 = *((_DWORD *)this + 96);
              *((_DWORD *)this + 96) = v37 + 1;
              int64x2_t v38 = (char *)*((void *)this + 47);
              uint64_t v39 = [v86 moveContents];
              if (v38) {
                int64x2_t v40 = v38;
              }
              else {
                int64x2_t v40 = (char *)this + 112;
              }
              long long v41 = &v40[88 * v37];
              *(void *)long long v41 = v39;
              int v42 = *((_DWORD *)v41 + 21);
              *((float *)v41 + 15) = a2;
              *((_DWORD *)v41 + 21) = v42 & 0xFFF3F000 | ((v32 & 0xF) << 8) | 0xC0000;
              long long v43 = v89;
              uint64_t v44 = *((void *)v41 + 1);
              *((void *)v41 + 1) = v89[7];
              v43[7] = v44;
              float32x2_t v45 = v89;
              uint64_t v46 = *((void *)v41 + 2);
              *((void *)v41 + 2) = v89[8];
              v45[8] = v46;
              _Block_object_dispose(&v88, 8);
              if (cf) {
                CFRelease(cf);
              }

              id v8 = v85;
            }
          }
          break;
        case 3:
          if (v5)
          {
            for (uint64_t j = 0; j != v5; ++j)
            {
              [v8 translateByX:0.0 Y:*((float *)this + 17)];
              v66.i32[0] = *((_DWORD *)this + 11);
              float32x2_t v67 = vrecpe_f32(v66);
              float32x2_t v68 = vmul_f32(vrecps_f32(v66, v67), v67);
              v68.f32[0] = vmul_f32(v68, vrecps_f32(v66, v68)).f32[0];
              [v8 scaleByX:v68.f32[0] Y:(float)-v68.f32[0]];
              uint64_t v88 = 0;
              double v89 = &v88;
              uint64_t v90 = 0x2020000000;
              LODWORD(v91) = -1;
              int v69 = (void *)RB::Symbol::Glyph::copied_glyph(this);
              LODWORD(v70) = 1.0;
              uint64_t v71 = [v7 beginCGContextWithAlpha:v70];
              v98[0] = MEMORY[0x263EF8330];
              v98[1] = 3221225472;
              v98[2] = ___ZN2RB6Symbol5Glyph18make_legacy_layersEf_block_invoke;
              v98[3] = &unk_2641F85C8;
              v98[4] = &v88;
              [v69 drawHierarchyLayerAtIndex:j inContext:v71 withColorResolver:v98];
              [v7 endCGContext];
              int v72 = *((_DWORD *)v89 + 6);
              int v73 = *((_DWORD *)this + 96);
              if (*((_DWORD *)this + 97) < (v73 + 1))
              {
                RB::vector<RB::Symbol::Glyph::Layer,3ul,unsigned int>::reserve_slow((char *)this + 112, v73 + 1);
                int v73 = *((_DWORD *)this + 96);
              }
              double v74 = (char *)*((void *)this + 47);
              if (!v74) {
                double v74 = (char *)this + 112;
              }
              int32x4_t v75 = &v74[88 * v73];
              *((void *)v75 + 5) = 0;
              *((void *)v75 + 1) = 0;
              *((void *)v75 + 2) = 0;
              *((void *)v75 + 6) = 0x400000000;
              *((void *)v75 + 7) = 1065353216;
              *((void *)v75 + 8) = 2139095040;
              *((void *)v75 + 9) = 1065353216;
              unsigned int v76 = *((_DWORD *)v75 + 21) & 0xFE000000 | 0x311A00;
              *((_DWORD *)v75 + 20) = -1;
              *((_DWORD *)v75 + 21) = v76;
              int v77 = *((_DWORD *)this + 96);
              *((_DWORD *)this + 96) = v77 + 1;
              double v78 = (char *)*((void *)this + 47);
              uint64_t v79 = [v86 moveContents];
              int v80 = v72;
              if (v78) {
                int32x4_t v81 = v78;
              }
              else {
                int32x4_t v81 = (char *)this + 112;
              }
              double v82 = &v81[88 * v77];
              *(void *)double v82 = v79;
              int v83 = *((_DWORD *)v82 + 21);
              *((float *)v82 + 15) = a2;
              unsigned int v84 = v83 & 0xFFF3F000;
              if (v72 < 0) {
                int v80 = 2560;
              }
              *((_DWORD *)v82 + 21) = v84 | v80 | 0xC0000;
              _Block_object_dispose(&v88, 8);
            }
          }
          break;
        case 4:
          if (v5)
          {
            for (uint64_t k = 0; k != v5; ++k)
            {
              [v8 translateByX:0.0 Y:*((float *)this + 17)];
              v48.i32[0] = *((_DWORD *)this + 11);
              float32x2_t v49 = vrecpe_f32(v48);
              float32x2_t v50 = vmul_f32(vrecps_f32(v48, v49), v49);
              v50.f32[0] = vmul_f32(v50, vrecps_f32(v48, v50)).f32[0];
              [v8 scaleByX:v50.f32[0] Y:(float)-v50.f32[0]];
              uint64_t v88 = 0;
              double v89 = &v88;
              uint64_t v90 = 0x2020000000;
              LODWORD(v91) = 10;
              size_t v51 = (void *)RB::Symbol::Glyph::copied_glyph(this);
              LODWORD(v52) = 1.0;
              uint64_t v53 = [v7 beginCGContextWithAlpha:v52];
              v97[0] = MEMORY[0x263EF8330];
              v97[1] = 3221225472;
              v97[2] = ___ZN2RB6Symbol5Glyph18make_legacy_layersEf_block_invoke_2;
              v97[3] = &unk_2641F85C8;
              v97[4] = &v88;
              [v51 drawPaletteLayerAtIndex:k inContext:v53 withColorResolver:v97];
              [v7 endCGContext];
              int v54 = *((_DWORD *)v89 + 6);
              int v55 = *((_DWORD *)this + 96);
              if (*((_DWORD *)this + 97) < (v55 + 1))
              {
                RB::vector<RB::Symbol::Glyph::Layer,3ul,unsigned int>::reserve_slow((char *)this + 112, v55 + 1);
                int v55 = *((_DWORD *)this + 96);
              }
              double v56 = (char *)*((void *)this + 47);
              if (!v56) {
                double v56 = (char *)this + 112;
              }
              uint64_t v57 = &v56[88 * v55];
              *((void *)v57 + 5) = 0;
              *((void *)v57 + 1) = 0;
              *((void *)v57 + 2) = 0;
              *((void *)v57 + 6) = 0x400000000;
              *((void *)v57 + 7) = 1065353216;
              *((void *)v57 + 8) = 2139095040;
              *((void *)v57 + 9) = 1065353216;
              unsigned int v58 = *((_DWORD *)v57 + 21) & 0xFE000000 | 0x311A00;
              *((_DWORD *)v57 + 20) = -1;
              *((_DWORD *)v57 + 21) = v58;
              int v59 = *((_DWORD *)this + 96);
              *((_DWORD *)this + 96) = v59 + 1;
              int v60 = (char *)*((void *)this + 47);
              uint64_t v61 = [v86 moveContents];
              if (v60) {
                float32x2_t v62 = v60;
              }
              else {
                float32x2_t v62 = (char *)this + 112;
              }
              double v63 = &v62[88 * v59];
              *(void *)double v63 = v61;
              int v64 = *((_DWORD *)v63 + 21);
              *((float *)v63 + 15) = a2;
              *((_DWORD *)v63 + 21) = v64 & 0xFFF3F000 | ((v54 & 0xF) << 8) | 0xC0000;
              _Block_object_dispose(&v88, 8);
            }
          }
          break;
        default:
          break;
      }

      return;
  }
}

void sub_21415A1BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id a14, id a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  _Unwind_Resume(a1);
}

BOOL RB::Symbol::Glyph::Layer::contains(uint64_t a1, unsigned int a2)
{
  int8x8_t v2 = (int *)(a1 + 24);
  if (*(void *)(a1 + 40)) {
    int8x8_t v2 = *(int **)(a1 + 40);
  }
  return RB::Symbol::tags_contains(v2, *(unsigned int *)(a1 + 48), a2);
}

RB::Symbol::Glyph::Layer *RB::vector<RB::Symbol::Glyph::Layer,3ul,unsigned int>::~vector(RB::Symbol::Glyph::Layer *a1)
{
  uint64_t v1 = a1;
  int8x8_t v2 = (void *)*((void *)a1 + 33);
  if (v2) {
    a1 = (RB::Symbol::Glyph::Layer *)*((void *)a1 + 33);
  }
  if (*((_DWORD *)v1 + 68))
  {
    unint64_t v3 = 0;
    do
    {
      RB::Symbol::Glyph::Layer::~Layer(a1);
      ++v3;
      a1 = (RB::Symbol::Glyph::Layer *)(v4 + 88);
    }
    while (v3 < *((unsigned int *)v1 + 68));
    int8x8_t v2 = (void *)*((void *)v1 + 33);
  }
  if (v2) {
    free(v2);
  }
  return v1;
}

CGColorRef ___ZN2RB6Symbol5Glyph18make_legacy_layersEf_block_invoke(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8);
  if ((*(_DWORD *)(v3 + 24) & 0x80000000) != 0) {
    *(_DWORD *)(v3 + 24) = a3;
  }
  return CGColorGetConstantColor((CFStringRef)*MEMORY[0x263F002F8]);
}

CGColorRef ___ZN2RB6Symbol5Glyph18make_legacy_layersEf_block_invoke_2(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(_DWORD *)(v3 + 24) == 10)
  {
    int v4 = 4;
    if (a3 < 4) {
      int v4 = a3;
    }
    int v5 = v4 + 4;
    if (!a3) {
      int v5 = 0;
    }
    *(_DWORD *)(v3 + 24) = v5;
  }
  return CGColorGetConstantColor((CFStringRef)*MEMORY[0x263F002F8]);
}

__n128 __Block_byref_object_copy_(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  __n128 result = *(__n128 *)(a2 + 56);
  *(__n128 *)(a1 + 56) = result;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
  int8x8_t v2 = *(const void **)(a1 + 64);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(void **)(a1 + 56);
}

uint64_t RB::Symbol::Glyph::make_legacy_layers(float)::Info::~Info(uint64_t a1)
{
  int8x8_t v2 = *(const void **)(a1 + 16);
  if (v2) {
    CFRelease(v2);
  }

  return a1;
}

CGColorRef ___ZN2RB6Symbol5Glyph18make_legacy_layersEf_block_invoke_12(uint64_t a1, void *a2, CFTypeRef cf)
{
  if (a2)
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 48) = 9;
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
    float v7 = *(void **)(v6 + 56);
    if (v7 != a2)
    {

      *(void *)(v6 + 56) = a2;
      uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
    }
    CFTypeRef v8 = *(CFTypeRef *)(v6 + 64);
    if (v8 != cf)
    {
      if (v8) {
        CFRelease(v8);
      }
      if (cf) {
        CFTypeRef v9 = CFRetain(cf);
      }
      else {
        CFTypeRef v9 = 0;
      }
      *(void *)(v6 + 64) = v9;
    }
  }
  CFStringRef v10 = (const __CFString *)*MEMORY[0x263F002F8];
  return CGColorGetConstantColor(v10);
}

const void **RB::cf_ptr<void const*>::operator=(const void **a1, CFTypeRef cf)
{
  CFTypeRef v3 = *a1;
  if (v3 != cf)
  {
    if (v3) {
      CFRelease(v3);
    }
    if (cf) {
      CFTypeRef v5 = CFRetain(cf);
    }
    else {
      CFTypeRef v5 = 0;
    }
    *a1 = v5;
  }
  return a1;
}

void *RB::Symbol::Glyph::Layer::remove(void *result, unsigned int a2)
{
  int8x8_t v2 = (char *)(result + 3);
  if (result[5]) {
    int8x8_t v2 = (char *)result[5];
  }
  uint64_t v3 = *((unsigned int *)result + 12);
  if (v3)
  {
    int v4 = v2;
    unint64_t v5 = *((unsigned int *)result + 12);
    do
    {
      unint64_t v6 = v5 >> 1;
      float v7 = &v4[4 * (v5 >> 1)];
      unsigned int v9 = *(_DWORD *)v7;
      CFTypeRef v8 = v7 + 4;
      v5 += ~(v5 >> 1);
      if (v9 < a2) {
        int v4 = v8;
      }
      else {
        unint64_t v5 = v6;
      }
    }
    while (v5);
    if (v4 != &v2[4 * v3] && *(_DWORD *)v4 == a2)
    {
      uint64_t v10 = v4 - v2;
      uint64_t v11 = (v3 - 1);
      *((_DWORD *)result + 12) = v11;
      if (v11 != v10 >> 2) {
        return memmove(&v2[4 * (v10 >> 2)], &v2[4 * (v10 >> 2) + 4], 4 * (v11 - (v10 >> 2)));
      }
    }
  }
  return result;
}

void *RB::Symbol::Glyph::Layer::mix_layers(uint64_t a1, uint64_t a2, uint64_t a3, float64x2_t *a4, float64x2_t *a5, RB::Symbol::Presentation *a6, char a7, id *a8, float a9, unsigned char *a10)
{
  int v18 = *(_DWORD *)(a2 + 84) & 0xC0000;
  if (a7)
  {
    if (v18 != 0x40000
      || (*(_DWORD *)(a3 + 84) & 0xC0000) != 0x40000
      || *(float *)(a2 + 76) > 0.0 != *(float *)(a3 + 76) > 0.0)
    {
      id v19 = *a8;
      if (!*a8)
      {
        id v19 = (id)objc_opt_new();

        *a8 = v19;
      }
      State = (__n128 *)RBDisplayListGetState((uint64_t)v19);
      RB::Symbol::Glyph::Layer::draw(a2, State, 0, a4, a6, 1.0, 1.0, 1.0, 1.0, 1.0, (float32x2_t)0x3F80000000000000);
      uint64_t v21 = (void *)[*a8 moveContents];
      long long v22 = (__n128 *)RBDisplayListGetState((uint64_t)*a8);
      RB::Symbol::Glyph::Layer::draw(a3, v22, 0, a5, a6, 1.0, 1.0, 1.0, 1.0, 1.0, (float32x2_t)0x3F80000000000000);
      long long v23 = (void *)[*a8 moveContents];
      int v24 = [[RBDisplayListInterpolator alloc] initWithFrom:v21 to:v23 options:0];
      uint64_t v25 = RBDisplayListGetState((uint64_t)*a8);
      *(float *)&double v26 = a9;
      [(RBDisplayListInterpolator *)v24 drawInState:v25 by:v26];
      *(void *)a1 = [*a8 moveContents];
      *(_DWORD *)(a1 + 84) |= 0xC0000u;
      *a10 = 1;

      goto LABEL_25;
    }
    if (*(float *)(a2 + 60) == *(float *)(a3 + 60))
    {
      v43.mach_timebase_info info = **(void ***)a3;
      v43.callbacks = *(RBPathCallbacks **)(*(void *)a3 + 8);
      if (RBPathCanMix(*(RBPath *)*(void *)a2, v43)) {
        operator new();
      }
    }
  }
  else if (v18 == 0x40000 {
         && (*(_DWORD *)(a3 + 84) & 0xC0000) == 0x40000
  }
         && *(float *)(a2 + 56) == *(float *)(a3 + 56)
         && *(float *)(a2 + 60) == *(float *)(a3 + 60)
         && *(float *)(a2 + 76) > 0.0 == *(float *)(a3 + 76) > 0.0)
  {
    int64x2_t v27 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(a4[1], a5[1]), (int8x16_t)vceqq_f64(*a4, *a5)), (int8x16_t)vceqq_f64(a4[2], a5[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v27, 1), (int8x16_t)v27).u64[0] & 0x8000000000000000) != 0)
    {
      if (RBPathEqualToPath(**(void **)a2, *(void *)(*(void *)a2 + 8), **(void **)a3, *(void **)(*(void *)a3 + 8)))operator new(); {
    }
      }
  }
  uint64_t v28 = (uint64_t)*a8;
  if (!*a8)
  {
    uint64_t v28 = objc_opt_new();

    *a8 = (id)v28;
  }
  uint64_t v29 = (RB::DisplayList::State *)RBDisplayListGetState(v28);
  double v30 = RBDrawingStateBeginLayer(v29, 0);
  float v31 = 0.0;
  if (a9 >= 0.0) {
    float v31 = a9;
  }
  if (v31 <= 1.0) {
    float v32 = v31;
  }
  else {
    float v32 = 1.0;
  }
  RB::Symbol::Glyph::Layer::draw(a2, (__n128 *)v30, 0, a4, a6, 1.0, 1.0, 1.0, 1.0, 1.0 - v32, (float32x2_t)0x3F80000000000000);
  RB::Symbol::Glyph::Layer::draw(a3, (__n128 *)v30, 0x3EFu, a5, a6, 1.0, 1.0, 1.0, 1.0, v32, (float32x2_t)0x3F80000000000000);
  RBDrawingStateDrawLayer((int8x16_t *)v29, v30, 0, 1.0);
  *(void *)a1 = [*a8 moveContents];
  *(_DWORD *)(a1 + 84) |= 0xC0000u;
  *a10 = 1;
LABEL_25:
  *(_DWORD *)(a1 + 84) = *(_DWORD *)(a1 + 84) & 0xFFFFF0FF | (((*(_DWORD *)(a2 + 84) >> 8) & 0xF) << 8);
  int v33 = *(void **)(a2 + 8);
  long long v34 = *(void **)(a1 + 8);
  if (v34 != v33)
  {

    *(void *)(a1 + 8) = v33;
  }
  uint64_t v35 = *(const void **)(a2 + 16);
  unsigned int v36 = *(const void **)(a1 + 16);
  if (v36 != v35)
  {
    if (v36) {
      CFRelease(v36);
    }
    if (v35) {
      CFTypeRef v37 = CFRetain(v35);
    }
    else {
      CFTypeRef v37 = 0;
    }
    *(void *)(a1 + 16) = v37;
  }
  *(float *)(a1 + 72) = *(float *)(a2 + 72) + (float)((float)(*(float *)(a3 + 72) - *(float *)(a2 + 72)) * a9);
  unsigned int v38 = *(_DWORD *)(a1 + 84) & 0xFF7FFFFF | (((*(_DWORD *)(a2 + 84) >> 23) & 1) << 23);
  *(_DWORD *)(a1 + 84) = v38;
  unsigned int v39 = v38 & 0xFEFFFFFF | ((HIBYTE(*(_DWORD *)(a2 + 84)) & 1) << 24);
  *(_DWORD *)(a1 + 84) = v39;
  *(_DWORD *)(a1 + 84) = v39 & 0xFFBFFFFF | (((*(_DWORD *)(a2 + 84) >> 22) & 1) << 22);
  if (*(void *)(a2 + 40)) {
    uint64_t v40 = *(void *)(a2 + 40);
  }
  else {
    uint64_t v40 = a2 + 24;
  }
  if (*(void *)(a3 + 40)) {
    uint64_t v41 = *(void *)(a3 + 40);
  }
  else {
    uint64_t v41 = a3 + 24;
  }
  return RB::Symbol::tags_intersect((void *)(a1 + 24), v40, *(unsigned int *)(a2 + 48), v41, *(unsigned int *)(a3 + 48));
}

void sub_21415AB58(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10E0C403B0E517ALL);
  _Unwind_Resume(a1);
}

uint64_t *RB::Symbol::Glyph::Shape::Shape(uint64_t *a1, uint64_t a2)
{
  *a1 = RBPathRetain(*(void *)a2, *(void *)(a2 + 8));
  a1[1] = v4;
  a1[2] = 0;
  a1[3] = 0;
  unsigned int v5 = *(_DWORD *)(a2 + 24);
  if (v5)
  {
    CFTypeRef v8 = *(long long **)(a2 + 16);
    RB::vector<RBColor,0ul,unsigned int>::reserve_slow((uint64_t)(a1 + 2), v5);
    unsigned int v9 = (_OWORD *)(a1[2] + 16 * *((unsigned int *)a1 + 6));
    unsigned int v10 = v5;
    do
    {
      long long v11 = *v8++;
      *v9++ = v11;
      --v10;
    }
    while (v10);
    int v6 = *((_DWORD *)a1 + 6);
  }
  else
  {
    int v6 = 0;
  }
  *((_DWORD *)a1 + 6) = v6 + v5;
  return a1;
}

void sub_21415AC44(_Unwind_Exception *a1)
{
  if (*v2) {
    free(*v2);
  }
  RBPathRelease(*v1, v1[1]);
  _Unwind_Resume(a1);
}

_DWORD *RB::Symbol::anonymous namespace'::mix_path_keyframes(_DWORD *result, uint64_t a2, uint64_t a3, __n128 a4)
{
  uint64_t v5 = *(unsigned int *)(a2 + 24);
  if (v5 == *(_DWORD *)(a3 + 24))
  {
    float v7 = result;
    if (v5)
    {
      CFTypeRef v8 = *(int **)(a2 + 16);
      unsigned int v9 = *(int **)(a3 + 16);
      uint64_t v10 = v5;
      while (1)
      {
        int v12 = *v8;
        v8 += 4;
        int v11 = v12;
        int v13 = *v9;
        v9 += 4;
        if (v11 != v13) {
          break;
        }
        if (!--v10) {
          goto LABEL_6;
        }
      }
    }
    else
    {
LABEL_6:
      if (result[7] < v5)
      {
        __n128 v29 = a4;
        __n128 result = RB::vector<RBColor,0ul,unsigned int>::reserve_slow((uint64_t)(result + 4), v5);
        a4 = v29;
        LODWORD(v5) = *(_DWORD *)(a2 + 24);
        if (!v5) {
          return result;
        }
      }
      else if (!v5)
      {
        return result;
      }
      uint64_t v14 = 0;
      unint64_t v15 = 0;
      float32x2_t v16 = (float32x2_t)vdup_lane_s32((int32x2_t)a4.n128_u64[0], 0);
      do
      {
        uint64_t v17 = *(void *)(a2 + 16);
        uint64_t v18 = *(void *)(a3 + 16);
        int v19 = *(_DWORD *)(v18 + v14);
        if (*(_DWORD *)(v17 + v14) != v19)
        {
          uint64_t v20 = v17 + v14;
          uint64_t v21 = v18 + v14;
          float32x2_t v22 = *(float32x2_t *)(v20 + 4);
          float32x2_t v23 = *(float32x2_t *)(v21 + 4);
          float v24 = *(float *)(v20 + 12);
          float v25 = *(float *)(v21 + 12);
          unsigned int v26 = v7[6];
          if (v7[7] < v26 + 1)
          {
            __n128 v28 = a4;
            __n128 result = RB::vector<RBColor,0ul,unsigned int>::reserve_slow((uint64_t)(v7 + 4), v26 + 1);
            a4 = v28;
            unsigned int v26 = v7[6];
          }
          uint64_t v27 = *((void *)v7 + 2) + 16 * v26;
          *(_DWORD *)uint64_t v27 = v19;
          *(float32x2_t *)(v27 + 4) = vmla_f32(v22, v16, vsub_f32(v23, v22));
          *(float *)(v27 + 12) = v24 + (float)((float)(v25 - v24) * a4.n128_f32[0]);
          ++v7[6];
          LODWORD(v5) = *(_DWORD *)(a2 + 24);
        }
        ++v15;
        v14 += 16;
      }
      while (v15 < v5);
    }
  }
  return result;
}

void *RB::Symbol::tags_intersect(void *__dst, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  if (a3 && a5)
  {
    uint64_t v9 = (uint64_t)__dst;
    uint64_t v10 = 0;
    unsigned int v11 = 0;
    unint64_t v12 = 0;
    do
    {
      unsigned int v13 = *(_DWORD *)(a2 + 4 * v10);
      unsigned int v14 = *(_DWORD *)(a4 + 4 * v12);
      if (v13 == v14)
      {
        unsigned int v15 = *(_DWORD *)(v9 + 24);
        if (*(_DWORD *)(v9 + 28) < v15 + 1)
        {
          __uuid_t dst = RB::vector<RB::Symbol::Tag,4ul,unsigned int>::reserve_slow((void *)v9, v15 + 1);
          unsigned int v15 = *(_DWORD *)(v9 + 24);
        }
        uint64_t v16 = *(void *)(v9 + 16);
        if (!v16) {
          uint64_t v16 = v9;
        }
        *(_DWORD *)(v16 + 4 * v15) = v13;
        ++*(_DWORD *)(v9 + 24);
        ++v11;
        ++v12;
      }
      else if (v13 < v14)
      {
        ++v11;
      }
      else
      {
        ++v12;
      }
      if (a3 <= v11) {
        break;
      }
      uint64_t v10 = v11;
    }
    while (v12 < a5);
  }
  return __dst;
}

_DWORD *RB::Symbol::tags_merge(_DWORD *__dst, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v7 = (uint64_t)__dst;
  unsigned int v8 = __dst[6];
  if (v8) {
    BOOL v9 = a3 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (!v9)
  {
    unsigned int v17 = 0;
    unint64_t v18 = 0;
    while (1)
    {
      uint64_t v19 = *(void *)(v7 + 16);
      if (v19) {
        uint64_t v20 = *(void *)(v7 + 16);
      }
      else {
        uint64_t v20 = v7;
      }
      unsigned int v21 = *(_DWORD *)(v20 + 4 * v17);
      unsigned int v22 = *(_DWORD *)(a2 + 4 * v18);
      if (v21 == v22)
      {
        ++v17;
      }
      else
      {
        if (v21 < v22)
        {
          ++v17;
          goto LABEL_36;
        }
        if (v22 != a4)
        {
          if (*(_DWORD *)(v7 + 28) < v8 + 1)
          {
            __uuid_t dst = RB::vector<RB::Symbol::Tag,4ul,unsigned int>::reserve_slow((void *)v7, v8 + 1);
            uint64_t v19 = *(void *)(v7 + 16);
            unsigned int v8 = *(_DWORD *)(v7 + 24);
          }
          if (v19) {
            uint64_t v23 = v19;
          }
          else {
            uint64_t v23 = v7;
          }
          if (v17 < v8) {
            __uuid_t dst = memmove((void *)(v23 + 4 * v17 + 4), (const void *)(v23 + 4 * v17), 4 * (v8 - (unint64_t)v17));
          }
          *(_DWORD *)(v23 + 4 * v17) = v22;
          unsigned int v8 = *(_DWORD *)(v7 + 24) + 1;
          *(_DWORD *)(v7 + 24) = v8;
        }
      }
      ++v18;
LABEL_36:
      if (v17 >= v8 || v18 >= a3) {
        goto LABEL_7;
      }
    }
  }
  unint64_t v18 = 0;
LABEL_7:
  unint64_t v10 = a3 - v18;
  if (a3 > v18)
  {
    unsigned int v11 = v8 + a3 - v18;
    if (*(_DWORD *)(v7 + 28) < v11) {
      __uuid_t dst = RB::vector<RB::Symbol::Tag,4ul,unsigned int>::reserve_slow((void *)v7, v11);
    }
    unint64_t v12 = (int *)(a2 + 4 * v18);
    do
    {
      int v14 = *v12++;
      int v13 = v14;
      if (v14 != a4)
      {
        unsigned int v15 = *(_DWORD *)(v7 + 24);
        if (*(_DWORD *)(v7 + 28) < v15 + 1)
        {
          __uuid_t dst = RB::vector<RB::Symbol::Tag,4ul,unsigned int>::reserve_slow((void *)v7, v15 + 1);
          unsigned int v15 = *(_DWORD *)(v7 + 24);
        }
        uint64_t v16 = *(void *)(v7 + 16);
        if (!v16) {
          uint64_t v16 = v7;
        }
        *(_DWORD *)(v16 + 4 * v15) = v13;
        ++*(_DWORD *)(v7 + 24);
      }
      --v10;
    }
    while (v10);
  }
  return __dst;
}

unsigned int *RB::Symbol::tags_subtract(unsigned int *result, uint64_t a2, unint64_t a3)
{
  unsigned int v3 = result[6];
  if (v3) {
    BOOL v4 = a3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    uint64_t v7 = result;
    unsigned int v8 = 0;
    unint64_t v9 = 0;
    do
    {
      unint64_t v10 = (unsigned int *)*((void *)v7 + 2);
      if (!v10) {
        unint64_t v10 = v7;
      }
      __n128 result = &v10[v8];
      unsigned int v11 = *(_DWORD *)(a2 + 4 * v9);
      if (*result == v11)
      {
        uint64_t v12 = v3 - 1;
        v7[6] = v12;
        unsigned int v3 = v8;
        if (v8 != v12)
        {
          __n128 result = (unsigned int *)memmove(result, result + 1, 4 * (v12 - v8));
          unsigned int v3 = v7[6];
        }
      }
      else if (*result < v11)
      {
        ++v8;
        continue;
      }
      ++v9;
    }
    while (v8 < v3 && v9 < a3);
  }
  return result;
}

void RB::Symbol::Glyph::Sublayers::draw_layers(RB::Symbol::Glyph::Sublayers *this, _RBDrawingState *a2, const RB::AffineTransform *a3, const RB::Symbol::Presentation *a4)
{
  int v5 = (int)a3;
  uint64_t v33 = *MEMORY[0x263EF8340];
  unsigned int v8 = [(id)RBDrawingStateGetDisplayList((uint64_t)a2) profile];
  BOOL v11 = rb_profile_supports_porter_duff_blending(v8);
  double v30 = 0;
  size_t v31 = 0;
  unint64_t v32 = 8;
  if (v11)
  {
    uint64_t v12 = RBDrawingStateBeginLayer((RB::DisplayList::State *)a2, 0);
  }
  else
  {
    int v13 = *((_DWORD *)this + 68);
    uint64_t v12 = (RB::DisplayList::State *)a2;
    if (v13)
    {
      size_t v9 = 0;
      unsigned int v14 = v13 - 1;
      do
      {
        unsigned int v15 = (RB::Symbol::Glyph::Sublayers *)*((void *)this + 33);
        if (!v15) {
          unsigned int v15 = this;
        }
        uint64_t v16 = v14;
        unsigned int v17 = (char *)v15 + 88 * v14;
        if ((v17[86] & 0x40) != 0)
        {
          unint64_t v18 = (RB::DisplayList::State *)a2;
          if (v9)
          {
            uint64_t v19 = v30;
            if (!v30) {
              uint64_t v19 = v29;
            }
            unint64_t v18 = *(RB::DisplayList::State **)&v19[8 * v9 - 8];
          }
          uint64_t v20 = RBDrawingStateInit(v18);
          RB::Symbol::Glyph::Layer::clip((int)v17, (RB::DisplayList::State *)v20, 1, v5, a4);
          size_t v21 = v31;
          size_t v9 = v31 + 1;
          if (v32 < v31 + 1)
          {
            RB::vector<RBDevice *,8ul,unsigned long>::reserve_slow(v29, v9);
            size_t v21 = v31;
            size_t v9 = v31 + 1;
          }
          unsigned int v22 = v30;
          if (!v30) {
            unsigned int v22 = v29;
          }
          *(void *)&v22[8 * v21] = v20;
          size_t v31 = v9;
        }
        --v14;
      }
      while (v16);
      uint64_t v12 = (RB::DisplayList::State *)a2;
    }
  }
  if (*((void *)this + 33)) {
    uint64_t v23 = (RB::Symbol::Glyph::Sublayers *)*((void *)this + 33);
  }
  else {
    uint64_t v23 = this;
  }
  unsigned int v24 = *((_DWORD *)this + 68);
  if (v24)
  {
    uint64_t v25 = 88 * v24;
    do
    {
      if ((*((unsigned char *)v23 + 86) & 0x40) != 0)
      {
        if (v11)
        {
          RB::Symbol::Glyph::Layer::draw((int)v23, v12, 23, v5, a4);
        }
        else
        {
          unsigned int v26 = v30;
          if (!v30) {
            unsigned int v26 = v29;
          }
          RBDrawingStateDestroy(*(RB::XML::Document **)&v26[8 * v31-- - 8], (const char *)v9, v10);
        }
      }
      if (*((float *)v23 + 18) > 0.0)
      {
        uint64_t v27 = v12;
        if (v31)
        {
          __n128 v28 = v30;
          if (!v30) {
            __n128 v28 = v29;
          }
          uint64_t v27 = *(RB::DisplayList::State **)&v28[8 * v31 - 8];
        }
        RB::Symbol::Glyph::Layer::draw((int)v23, v27, 0, v5, a4);
      }
      uint64_t v23 = (RB::Symbol::Glyph::Sublayers *)((char *)v23 + 88);
      v25 -= 88;
    }
    while (v25);
  }
  if (v11) {
    RBDrawingStateDrawLayer((int8x16_t *)a2, v12, 0, 1.0);
  }
  if (v30) {
    free(v30);
  }
}

void sub_21415B3A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  if (a17) {
    free(a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZNK2RB6Symbol5Glyph5Layer4drawEP15_RBDrawingState7RBColorf11RBBlendModeRKNS_15AffineTransformEDv2_fRKNS0_12PresentationE_block_invoke(_DWORD *a1, void *a2, double a3, double a4, double a5, double a6)
{
  LODWORD(a3) = a1[8];
  LODWORD(a4) = a1[9];
  LODWORD(a5) = a1[10];
  LODWORD(a6) = a1[11];
  return objc_msgSend(a2, "setColor:colorSpace:", 1, a3, a4, a5, a6);
}

uint64_t RB::Symbol::Glyph::Layer::append_path(uint64_t *a1, RB::Path::Storage *this, float32x2_t a3)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  unsigned int v4 = *((_DWORD *)a1 + 21);
  uint64_t result = 1;
  switch((v4 >> 18) & 3)
  {
    case 1u:
      uint32x2_t v7 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(a3, (float32x2_t)0x3F80000000000000));
      unsigned __int32 v8 = vpmax_u32(v7, v7).u32[0];
      float v9 = *((float *)a1 + 19);
      if (v9 <= 0.0)
      {
        if ((v8 & 0x80000000) != 0 && (uint64_t v13 = *a1, v14 = *(unsigned int *)(*a1 + 24), v14))
        {
          int32x2_t v16 = (int32x2_t)0x100000000;
          uint64_t v17 = v14;
          uint64_t v18 = *(void *)(v13 + 16);
          if (a3.f32[0] == 0.0) {
            a3.i32[0] = a3.i32[1];
          }
          else {
            v16.i32[0] = 1;
          }
          double __src = a3.f32[0];
          RB::Path::Storage::append_element(this, (const char *)0x18, &__src, (int *)&v16);
          int v10 = 1;
        }
        else
        {
          int v10 = 0;
        }
      }
      else
      {
        float32x2_t v15 = a3;
        int v10 = v8 >> 31;
        int32x2_t v16 = vshl_s32((int32x2_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xE00000010), (int32x2_t)0xFFFFFFE2FFFFFFE4);
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        double __src = (float)(v9 / *((float *)a1 + 14));
        long long v21 = xmmword_2142199B0;
        RB::Path::Storage::append_element(this, (const char *)0x13, &__src, (int *)&v16);
        if ((v8 & 0x80000000) != 0)
        {
          float64x2_t v19 = vcvtq_f64_f32(v15);
          RB::Path::Storage::append_element(this, (const char *)0x12, v19.f64, 0);
        }
      }
      RB::Path::Storage::append_path(this, *(RBPath *)*a1);
      if (*((float *)a1 + 19) <= 0.0)
      {
        if (!v10) {
          return 1;
        }
      }
      else if (v10)
      {
        RB::Path::Storage::append_element(this, (const char *)0x10, 0, 0);
      }
      RB::Path::Storage::append_element(this, (const char *)0x10, 0, 0);
      return 1;
    case 2u:
      BOOL v11 = (RBPath *)*a1;
      unsigned int v12 = *(_DWORD *)(*a1 + 272);
      return RB::Symbol::Glyph::Sublayers::append_path((RB::Symbol::Glyph::Sublayers **)v11, this, v12);
    case 3u:
      return 0;
    default:
      return result;
  }
}

uint64_t RB::Symbol::Glyph::Sublayers::append_path(RB::Symbol::Glyph::Sublayers **this, RB::Path::Storage *a2, unsigned int a3)
{
  if (!a3) {
    return 1;
  }
  int v5 = (RB::Symbol::Glyph::Sublayers *)this;
  if (a3 != 1)
  {
    HIWORD(v52) = 2;
    RB::Path::Storage::append_element(a2, (const char *)0x14, 0, (int *)((char *)&v52 + 2));
    unsigned int v10 = a3;
    do
    {
      if ((--v10 & 0x80000000) != 0)
      {
        signed int v15 = 0;
LABEL_47:
        if (v15 < a3)
        {
          if ((v10 & 0x80000000) != 0) {
            int v34 = -1;
          }
          else {
            int v34 = v10;
          }
          uint64_t v35 = 88 * (v34 + 1);
          unsigned int v36 = ~v34 + a3;
          float64x2_t v37 = (float64x2_t)xmmword_2142181C0;
          do
          {
            unsigned int v38 = (RB::Symbol::Glyph::Sublayers *)*((void *)v5 + 33);
            if (!v38) {
              unsigned int v38 = v5;
            }
            unsigned int v39 = (float *)((char *)v38 + v35);
            if (*(float *)((char *)v38 + v35 + 72) > 0.0)
            {
              float v41 = v39[14];
              float v40 = v39[15];
              if (v41 == 1.0 && v40 == 0.0)
              {
                char appended = RB::Symbol::Glyph::Layer::append_path((int)v38 + (int)v35, a2);
                float64x2_t v37 = (float64x2_t)xmmword_2142181C0;
                if ((appended & 1) == 0) {
                  return 0;
                }
              }
              else
              {
                *(double *)&uint64_t v43 = v41;
                if (v40 == 0.0)
                {
                  float64x2_t v44 = (float64x2_t)vdupq_lane_s64(v43, 0);
                  float64x2_t v45 = 0uLL;
                  float64x2_t v46 = v44;
                }
                else
                {
                  float64x2_t v45 = vmulq_n_f64(v37, v40);
                  float64x2_t v44 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((float)-v41), 0);
                  float64x2_t v46 = (float64x2_t)vdupq_lane_s64(v43, 0);
                }
                float64x2_t v53 = vmulq_f64(v44, v37);
                float64x2_t v54 = vmulq_f64(v46, (float64x2_t)xmmword_2142181D0);
                float64x2_t v55 = v45;
                RB::Path::Storage::append_element(a2, (const char *)0x11, 0, (int *)&v53);
                if (!RB::Symbol::Glyph::Layer::append_path((int)v39, a2)) {
                  return 0;
                }
                RB::Path::Storage::append_element(a2, (const char *)0x10, 0, 0);
                float64x2_t v37 = (float64x2_t)xmmword_2142181C0;
              }
            }
            v35 += 88;
            --v36;
          }
          while (v36);
        }
        RB::Path::Storage::append_element(a2, (const char *)0x10, 0, 0);
        return 1;
      }
      BOOL v11 = (RB::Symbol::Glyph::Sublayers *)*((void *)v5 + 33);
      if (!v11) {
        BOOL v11 = v5;
      }
      float v12 = *((float *)v11 + 22 * v10 + 18);
      if (v12 > 0.0 && v12 != 1.0) {
        return 0;
      }
    }
    while ((*((unsigned char *)v11 + 88 * v10 + 86) & 0x40) == 0);
    uint64_t v14 = (uint64_t)v11 + 88 * v10 - 16;
    signed int v15 = v10 + 1;
    int v16 = v10;
    while (1)
    {
      int v17 = v16;
      BOOL v18 = __OFSUB__(v16--, 1);
      if (v16 < 0 != v18) {
        break;
      }
      float v19 = *(float *)v14;
      int v20 = *(_DWORD *)(v14 + 12) & 0x400000;
      v14 -= 88;
      if (v19 > 0.0 || v20 == 0)
      {
        signed int v22 = v16 + 1;
        goto LABEL_32;
      }
    }
    signed int v22 = 0;
LABEL_32:
    LOWORD(v52) = 3;
    RB::Path::Storage::append_element(a2, (const char *)0x14, 0, &v52);
    if (RB::Symbol::Glyph::Sublayers::append_path(v5, a2, v22))
    {
      if (v22 < v15)
      {
        uint64_t v23 = v17 & ~(v17 >> 31);
        uint64_t v24 = 88 * v23;
        do
        {
          RB::Path::Storage::append_element(a2, (const char *)0x15, 0, 0);
          uint64_t v25 = (RB::Symbol::Glyph::Sublayers *)*((void *)v5 + 33);
          if (!v25) {
            uint64_t v25 = v5;
          }
          int v26 = v25 + v24;
          float v28 = *(float *)((char *)v25 + v24 + 56);
          float v27 = *(float *)((char *)v25 + v24 + 60);
          if (v28 == 1.0 && v27 == 0.0)
          {
            RB::Symbol::Glyph::Layer::append_path(v25 + v24, a2);
          }
          else
          {
            *(double *)&uint64_t v29 = v28;
            if (v27 == 0.0)
            {
              float64x2_t v30 = (float64x2_t)vdupq_lane_s64(v29, 0);
              float64x2_t v31 = 0uLL;
              float64x2_t v32 = v30;
              float64x2_t v33 = (float64x2_t)xmmword_2142181C0;
            }
            else
            {
              float64x2_t v33 = (float64x2_t)xmmword_2142181C0;
              float64x2_t v31 = vmulq_n_f64((float64x2_t)xmmword_2142181C0, v27);
              float64x2_t v30 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((float)-v28), 0);
              float64x2_t v32 = (float64x2_t)vdupq_lane_s64(v29, 0);
            }
            float64x2_t v53 = vmulq_f64(v30, v33);
            float64x2_t v54 = vmulq_f64(v32, (float64x2_t)xmmword_2142181D0);
            float64x2_t v55 = v31;
            RB::Path::Storage::append_element(a2, (const char *)0x11, 0, (int *)&v53);
            if (RB::Symbol::Glyph::Layer::append_path(v26, a2)) {
              RB::Path::Storage::append_element(a2, (const char *)0x10, 0, 0);
            }
          }
          ++v23;
          v24 += 88;
        }
        while (v23 < v15);
      }
      RB::Path::Storage::append_element(a2, (const char *)0x10, 0, 0);
      goto LABEL_47;
    }
    return 0;
  }
  if (this[33]) {
    int v5 = this[33];
  }
  float v6 = *((float *)v5 + 18);
  if (v6 <= 0.0) {
    return 1;
  }
  if (v6 != 1.0) {
    return 0;
  }
  float v8 = *((float *)v5 + 14);
  float v7 = *((float *)v5 + 15);
  if (v8 != 1.0 || v7 != 0.0)
  {
    if (v7 == 0.0)
    {
      float64x2_t v48 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(v8), 0);
      float64x2_t v49 = 0uLL;
      float64x2_t v50 = v48;
    }
    else
    {
      float64x2_t v49 = vmulq_n_f64((float64x2_t)xmmword_2142181C0, v7);
      *(double *)&uint64_t v51 = v8;
      float64x2_t v48 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((float)-v8), 0);
      float64x2_t v50 = (float64x2_t)vdupq_lane_s64(v51, 0);
    }
    float64x2_t v53 = vmulq_f64(v48, (float64x2_t)xmmword_2142181C0);
    float64x2_t v54 = vmulq_f64(v50, (float64x2_t)xmmword_2142181D0);
    float64x2_t v55 = v49;
    RB::Path::Storage::append_element(a2, (const char *)0x11, 0, (int *)&v53);
    uint64_t v47 = RB::Symbol::Glyph::Layer::append_path((int)v5, a2);
    if (v47) {
      RB::Path::Storage::append_element(a2, (const char *)0x10, 0, 0);
    }
    return v47;
  }
  return RB::Symbol::Glyph::Layer::append_path((int)v5, a2);
}

void RB::Symbol::Glyph::Sublayers::print(RB::Symbol::Glyph::Sublayers *this, std::string *a2)
{
  RB::SexpString::push(a2, "sublayers");
  unsigned int v4 = (RB::Symbol::Glyph::Sublayers *)*((void *)this + 33);
  if (!v4) {
    unsigned int v4 = this;
  }
  unsigned int v5 = *((_DWORD *)this + 68);
  if (v5)
  {
    uint64_t v6 = 88 * v5;
    float v7 = (float *)((char *)v4 + 84);
    do
    {
      if ((*(_DWORD *)v7 & 0x400000) != 0) {
        float v8 = "eraser-layer";
      }
      else {
        float v8 = "layer";
      }
      RB::SexpString::push(a2, v8);
      float v9 = *(v7 - 3);
      if (v9 != 1.0) {
        RB::SexpString::printf(a2, 0, "(alpha %.2g)", v9);
      }
      if ((*(_DWORD *)v7 & 0xC0000) == 0x80000) {
        RB::Symbol::Glyph::Sublayers::print(*(RB::Symbol::Glyph::Sublayers **)(v7 - 21), (RB::SexpString *)a2);
      }
      RB::SexpString::pop(a2);
      v7 += 22;
      v6 -= 88;
    }
    while (v6);
  }
  RB::SexpString::pop(a2);
}

unint64_t std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,std::pair<float,unsigned int> *,std::__less<void,void> &>(unint64_t a1, float *a2)
{
  float v2 = *(float *)a1;
  unsigned int v3 = *(_DWORD *)(a1 + 4);
  float v4 = *(a2 - 2);
  if (*(float *)a1 == v4) {
    int v5 = 0;
  }
  else {
    int v5 = -127;
  }
  if (*(float *)a1 > v4) {
    int v5 = 1;
  }
  if (*(float *)a1 < v4) {
    int v5 = -1;
  }
  if (!v5)
  {
    unsigned int v6 = *((_DWORD *)a2 - 1);
    BOOL v7 = v3 == v6;
    LOBYTE(v5) = v3 < v6 ? -1 : 1;
    if (v7) {
      LOBYTE(v5) = 0;
    }
  }
  if (v5 == 129 || (v5 & 0x80) == 0)
  {
    unint64_t v15 = a1 + 8;
    do
    {
      unint64_t v9 = v15;
      if (v15 >= (unint64_t)a2) {
        break;
      }
      if (v2 == *(float *)v15) {
        int v16 = 0;
      }
      else {
        int v16 = -127;
      }
      if (v2 > *(float *)v15) {
        int v16 = 1;
      }
      if (v2 < *(float *)v15) {
        int v16 = -1;
      }
      if (!v16)
      {
        unsigned int v17 = *(_DWORD *)(v15 + 4);
        BOOL v18 = v3 == v17;
        LOBYTE(v16) = v3 < v17 ? -1 : 1;
        if (v18) {
          LOBYTE(v16) = 0;
        }
      }
      v15 += 8;
    }
    while (v16 == 129 || (v16 & 0x80) == 0);
  }
  else
  {
    unint64_t v8 = a1;
    while (1)
    {
      unint64_t v9 = v8 + 8;
      float v10 = *(float *)(v8 + 8);
      if (v2 == v10) {
        int v11 = 0;
      }
      else {
        int v11 = -127;
      }
      if (v2 > v10) {
        int v11 = 1;
      }
      if (v2 < v10) {
        int v11 = -1;
      }
      if (!v11)
      {
        unsigned int v12 = *(_DWORD *)(v8 + 12);
        BOOL v13 = v3 == v12;
        if (v3 < v12) {
          char v14 = -1;
        }
        else {
          char v14 = 1;
        }
        if (v13) {
          LOBYTE(v11) = 0;
        }
        else {
          LOBYTE(v11) = v14;
        }
      }
      unint64_t v8 = v9;
      if (v11 != 129)
      {
        unint64_t v8 = v9;
        if ((v11 & 0x80) != 0) {
          break;
        }
      }
    }
  }
  if (v9 >= (unint64_t)a2)
  {
    float v19 = a2;
  }
  else
  {
    float v19 = a2;
    do
    {
      float v20 = *(v19 - 2);
      v19 -= 2;
      BOOL v21 = v2 < v20;
      BOOL v22 = v2 <= v20;
      if (v2 == v20) {
        int v23 = 0;
      }
      else {
        int v23 = -127;
      }
      if (!v22) {
        int v23 = 1;
      }
      if (v21) {
        int v23 = -1;
      }
      if (!v23)
      {
        unsigned int v24 = *((_DWORD *)a2 - 1);
        BOOL v25 = v3 == v24;
        LOBYTE(v23) = v3 < v24 ? -1 : 1;
        if (v25) {
          LOBYTE(v23) = 0;
        }
      }
      if (v23 == 129) {
        break;
      }
      a2 = v19;
    }
    while ((v23 & 0x80) != 0);
  }
  if (v9 < (unint64_t)v19)
  {
    float v26 = *(float *)v9;
    float v27 = *v19;
    do
    {
      *(float *)unint64_t v9 = v27;
      *float v19 = v26;
      int v28 = *(_DWORD *)(v9 + 4);
      *(float *)(v9 + 4) = v19[1];
      *((_DWORD *)v19 + 1) = v28;
      unint64_t v29 = v9;
      while (1)
      {
        unint64_t v9 = v29 + 8;
        float v26 = *(float *)(v29 + 8);
        if (v2 == v26) {
          int v30 = 0;
        }
        else {
          int v30 = -127;
        }
        if (v2 > v26) {
          int v30 = 1;
        }
        if (v2 < v26) {
          int v30 = -1;
        }
        if (!v30)
        {
          unsigned int v31 = *(_DWORD *)(v29 + 12);
          BOOL v32 = v3 == v31;
          if (v3 < v31) {
            char v33 = -1;
          }
          else {
            char v33 = 1;
          }
          if (v32) {
            LOBYTE(v30) = 0;
          }
          else {
            LOBYTE(v30) = v33;
          }
        }
        unint64_t v29 = v9;
        if (v30 != 129)
        {
          unint64_t v29 = v9;
          if ((v30 & 0x80) != 0) {
            break;
          }
        }
      }
      int v34 = v19;
      do
      {
        float v35 = *(v19 - 2);
        v19 -= 2;
        float v27 = v35;
        BOOL v36 = v2 < v35;
        BOOL v37 = v2 <= v35;
        if (v2 == v35) {
          int v38 = 0;
        }
        else {
          int v38 = -127;
        }
        if (!v37) {
          int v38 = 1;
        }
        if (v36) {
          int v38 = -1;
        }
        if (!v38)
        {
          unsigned int v39 = *((_DWORD *)v34 - 1);
          BOOL v40 = v3 == v39;
          if (v3 < v39) {
            char v41 = -1;
          }
          else {
            char v41 = 1;
          }
          if (v40) {
            LOBYTE(v38) = 0;
          }
          else {
            LOBYTE(v38) = v41;
          }
        }
        if (v38 == 129) {
          break;
        }
        int v34 = v19;
      }
      while ((v38 & 0x80) != 0);
    }
    while (v9 < (unint64_t)v19);
  }
  if (v9 - 8 != a1)
  {
    *(_DWORD *)a1 = *(_DWORD *)(v9 - 8);
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(v9 - 4);
  }
  *(float *)(v9 - 8) = v2;
  *(_DWORD *)(v9 - 4) = v3;
  return v9;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(int *a1, int *a2, uint64_t a3)
{
  uint64_t v6 = ((char *)a2 - (char *)a1) >> 3;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a3, (uint64_t)(a2 - 2), (uint64_t)a1))
      {
        int v8 = *a1;
        *a1 = *(a2 - 2);
        *(a2 - 2) = v8;
        int v9 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v9;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(a1, a1 + 2, a2 - 2, a3);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(a1, a1 + 2, a1 + 4, a2 - 2, a3);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2, a3);
      return 1;
    default:
      float v10 = (float *)(a1 + 4);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(a1, a1 + 2, a1 + 4, a3);
      uint64_t v11 = (uint64_t)(a1 + 6);
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (1)
  {
    if (std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a3, v11, (uint64_t)v10))
    {
      float v14 = *(float *)v11;
      unsigned int v15 = *(_DWORD *)(v11 + 4);
      uint64_t v16 = v12;
      float v17 = *v10;
      while (1)
      {
        BOOL v18 = (float *)((char *)a1 + v16);
        v18[6] = v17;
        *((_DWORD *)v18 + 7) = *(int *)((char *)a1 + v16 + 20);
        if (v16 == -16) {
          break;
        }
        float v17 = v18[2];
        if (v14 == v17) {
          int v19 = 0;
        }
        else {
          int v19 = -127;
        }
        if (v14 > v17) {
          int v19 = 1;
        }
        if (v14 < v17) {
          int v19 = -1;
        }
        if (!v19)
        {
          unsigned int v20 = *(int *)((char *)a1 + v16 + 12);
          BOOL v21 = v15 == v20;
          if (v15 < v20) {
            LOBYTE(v19) = -1;
          }
          else {
            LOBYTE(v19) = 1;
          }
          if (v21) {
            LOBYTE(v19) = 0;
          }
        }
        v16 -= 8;
        if (v19 == 129 || (v19 & 0x80) == 0)
        {
          uint64_t v22 = (uint64_t)a1 + v16 + 24;
          goto LABEL_26;
        }
      }
      uint64_t v22 = (uint64_t)a1;
LABEL_26:
      *(float *)uint64_t v22 = v14;
      *(_DWORD *)(v22 + 4) = v15;
      if (++v13 == 8) {
        return v11 + 8 == (void)a2;
      }
    }
    float v10 = (float *)v11;
    v12 += 8;
    v11 += 8;
    if ((int *)v11 == a2) {
      return 1;
    }
  }
}

float std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(int *a1, int *a2, int *a3, int *a4, uint64_t a5)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(a1, a2, a3, a5);
  if (std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a5, (uint64_t)a4, (uint64_t)a3))
  {
    int v11 = *a3;
    *a3 = *a4;
    *a4 = v11;
    int v12 = a3[1];
    a3[1] = a4[1];
    a4[1] = v12;
    if (std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a5, (uint64_t)a3, (uint64_t)a2))
    {
      int v13 = *a2;
      *a2 = *a3;
      *a3 = v13;
      int v14 = a2[1];
      a2[1] = a3[1];
      a3[1] = v14;
      if (std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a5, (uint64_t)a2, (uint64_t)a1))
      {
        float result = *(float *)a1;
        *a1 = *a2;
        *(float *)a2 = result;
        int v15 = a1[1];
        a1[1] = a2[1];
        a2[1] = v15;
      }
    }
  }
  return result;
}

float std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(int *a1, int *a2, int *a3, int *a4, int *a5, uint64_t a6)
{
  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(a1, a2, a3, a4, a6);
  if (std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a6, (uint64_t)a5, (uint64_t)a4))
  {
    int v13 = *a4;
    *a4 = *a5;
    *a5 = v13;
    int v14 = a4[1];
    a4[1] = a5[1];
    a5[1] = v14;
    if (std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a6, (uint64_t)a4, (uint64_t)a3))
    {
      int v15 = *a3;
      *a3 = *a4;
      *a4 = v15;
      int v16 = a3[1];
      a3[1] = a4[1];
      a4[1] = v16;
      if (std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a6, (uint64_t)a3, (uint64_t)a2))
      {
        int v17 = *a2;
        *a2 = *a3;
        *a3 = v17;
        int v18 = a2[1];
        a2[1] = a3[1];
        a3[1] = v18;
        if (std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a6, (uint64_t)a2, (uint64_t)a1))
        {
          float result = *(float *)a1;
          *a1 = *a2;
          *(float *)a2 = result;
          int v19 = a1[1];
          a1[1] = a2[1];
          a2[1] = v19;
        }
      }
    }
  }
  return result;
}

char *std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *,std::pair<float,unsigned int> *>(char *a1, char *a2, char *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    uint64_t v8 = a2 - a1;
    uint64_t v9 = (a2 - a1) >> 3;
    if (a2 - a1 >= 9)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      uint64_t v12 = (uint64_t)&a1[8 * v10];
      do
      {
        std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>((BOOL)a1, a4, v9, v12);
        v12 -= 8;
        --v11;
      }
      while (v11);
    }
    int v13 = a2;
    if (a2 != a3)
    {
      int v14 = a2;
      do
      {
        if (std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a4, (uint64_t)v14, (uint64_t)a1))
        {
          int v15 = *(_DWORD *)v14;
          *(_DWORD *)int v14 = *(_DWORD *)a1;
          *(_DWORD *)a1 = v15;
          int v16 = *((_DWORD *)v14 + 1);
          *((_DWORD *)v14 + 1) = *((_DWORD *)a1 + 1);
          *((_DWORD *)a1 + 1) = v16;
          std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>((BOOL)a1, a4, v9, (uint64_t)a1);
        }
        v14 += 8;
      }
      while (v14 != a3);
      int v13 = a3;
    }
    if (v8 >= 9)
    {
      uint64_t v17 = (unint64_t)v8 >> 3;
      int v18 = a2 - 8;
      do
      {
        int v19 = *(_DWORD *)a1;
        int v20 = *((_DWORD *)a1 + 1);
        BOOL v21 = (char *)std::__floyd_sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(a1, a4, v17);
        if (v18 == v21)
        {
          *(_DWORD *)BOOL v21 = v19;
          *((_DWORD *)v21 + 1) = v20;
        }
        else
        {
          *(_DWORD *)BOOL v21 = *(_DWORD *)v18;
          *((_DWORD *)v21 + 1) = *((_DWORD *)v18 + 1);
          *(_DWORD *)int v18 = v19;
          *((_DWORD *)v18 + 1) = v20;
          std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>((BOOL)a1, (uint64_t)(v21 + 8), a4, (v21 + 8 - a1) >> 3);
        }
        v18 -= 8;
      }
      while (v17-- > 2);
    }
    return v13;
  }
  return a3;
}

BOOL std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(BOOL result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = a3 - 2;
  if (a3 >= 2)
  {
    uint64_t v5 = a4;
    BOOL v6 = result;
    uint64_t v7 = v4 >> 1;
    if ((uint64_t)(v4 >> 1) >= (a4 - result) >> 3)
    {
      uint64_t v10 = (a4 - result) >> 2;
      uint64_t v11 = v10 + 1;
      uint64_t v12 = (float *)(result + 8 * (v10 + 1));
      uint64_t v13 = v10 + 2;
      if (v10 + 2 < a3
        && std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a2, result + 8 * (v10 + 1), (uint64_t)(v12 + 2)))
      {
        v12 += 2;
        uint64_t v11 = v13;
      }
      float result = std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a2, (uint64_t)v12, v5);
      if (!result)
      {
        float v14 = *(float *)v5;
        unsigned int v21 = *(_DWORD *)(v5 + 4);
        float v15 = *v12;
        do
        {
          int v16 = (float *)v5;
          uint64_t v5 = (uint64_t)v12;
          *int v16 = v15;
          v16[1] = v12[1];
          if (v7 < v11) {
            break;
          }
          uint64_t v17 = (2 * v11) | 1;
          uint64_t v12 = (float *)(v6 + 8 * v17);
          uint64_t v11 = 2 * v11 + 2;
          if (v11 >= a3)
          {
            uint64_t v11 = v17;
          }
          else
          {
            float result = std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a2, v6 + 8 * v17, (uint64_t)(v12 + 2));
            if (result) {
              v12 += 2;
            }
            else {
              uint64_t v11 = v17;
            }
          }
          float v15 = *v12;
          if (*v12 == v14) {
            int v18 = 0;
          }
          else {
            int v18 = -127;
          }
          if (*v12 > v14) {
            int v18 = 1;
          }
          if (*v12 < v14) {
            int v18 = -1;
          }
          if (!v18)
          {
            unsigned int v19 = *((_DWORD *)v12 + 1);
            BOOL v20 = v19 == v21;
            if (v19 < v21) {
              LOBYTE(v18) = -1;
            }
            else {
              LOBYTE(v18) = 1;
            }
            if (v20) {
              LOBYTE(v18) = 0;
            }
          }
        }
        while (v18 == 129 || (v18 & 0x80) == 0);
        *(float *)uint64_t v5 = v14;
        *(_DWORD *)(v5 + 4) = v21;
      }
    }
  }
  return result;
}

_DWORD *std::__floyd_sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = a3 - 2;
  if (a3 < 2) {
    uint64_t v7 = a3 - 1;
  }
  uint64_t v8 = v7 >> 1;
  do
  {
    uint64_t v9 = &a1[2 * v6 + 2];
    uint64_t v10 = (2 * v6) | 1;
    uint64_t v11 = 2 * v6 + 2;
    if (v11 < a3
      && std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a2, (uint64_t)&a1[2 * v6 + 2], (uint64_t)&a1[2 * v6 + 4]))
    {
      v9 += 2;
      uint64_t v10 = v11;
    }
    *a1 = *v9;
    a1[1] = v9[1];
    a1 = v9;
    uint64_t v6 = v10;
  }
  while (v10 <= v8);
  return v9;
}

BOOL std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(BOOL result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    BOOL v6 = result;
    unint64_t v7 = v4 >> 1;
    uint64_t v8 = (float *)(result + 8 * (v4 >> 1));
    uint64_t v9 = (float *)(a2 - 8);
    float result = std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a3, (uint64_t)v8, a2 - 8);
    if (result)
    {
      float v10 = *(float *)(a2 - 8);
      unsigned int v11 = *(_DWORD *)(a2 - 4);
      float v12 = *v8;
      do
      {
        uint64_t v13 = v9;
        uint64_t v9 = v8;
        *uint64_t v13 = v12;
        v13[1] = v8[1];
        if (!v7) {
          break;
        }
        unint64_t v7 = (v7 - 1) >> 1;
        uint64_t v8 = (float *)(v6 + 8 * v7);
        float v12 = *v8;
        if (*v8 == v10) {
          int v14 = 0;
        }
        else {
          int v14 = -127;
        }
        if (*v8 > v10) {
          int v14 = 1;
        }
        if (*v8 < v10) {
          int v14 = -1;
        }
        if (!v14)
        {
          unsigned int v15 = *((_DWORD *)v8 + 1);
          BOOL v16 = v15 == v11;
          if (v15 < v11) {
            LOBYTE(v14) = -1;
          }
          else {
            LOBYTE(v14) = 1;
          }
          if (v16) {
            LOBYTE(v14) = 0;
          }
        }
      }
      while (v14 != 129 && (v14 & 0x80) != 0);
      *uint64_t v9 = v10;
      *((_DWORD *)v9 + 1) = v11;
    }
  }
  return result;
}

unsigned int *std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,RB::Symbol::Tag *,std::__less<void,void> &>(unsigned int *a1, int *a2)
{
  unsigned int v2 = *a1;
  if (*a1 >= *(a2 - 1))
  {
    uint64_t v5 = (int *)(a1 + 1);
    do
    {
      unsigned int v3 = (unsigned int *)v5;
      if (v5 >= a2) {
        break;
      }
      ++v5;
    }
    while (v2 >= *v3);
  }
  else
  {
    unsigned int v3 = a1;
    do
    {
      unsigned int v4 = v3[1];
      ++v3;
    }
    while (v2 >= v4);
  }
  if (v3 < (unsigned int *)a2)
  {
    do
      unsigned int v6 = *--a2;
    while (v2 < v6);
  }
  if (v3 < (unsigned int *)a2)
  {
    unsigned int v7 = *v3;
    unsigned int v8 = *a2;
    do
    {
      *unsigned int v3 = v8;
      *a2 = v7;
      do
      {
        unsigned int v9 = v3[1];
        ++v3;
        unsigned int v7 = v9;
      }
      while (v2 >= v9);
      do
      {
        unsigned int v10 = *--a2;
        unsigned int v8 = v10;
      }
      while (v2 < v10);
    }
    while (v3 < (unsigned int *)a2);
  }
  if (v3 - 1 != a1) {
    *a1 = *(v3 - 1);
  }
  *(v3 - 1) = v2;
  return v3;
}

unsigned int *std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,RB::Symbol::Tag *,std::__less<void,void> &>(unsigned int *a1, unsigned int *a2)
{
  uint64_t v2 = 0;
  unsigned int v3 = *a1;
  do
    unsigned int v4 = a1[++v2];
  while (v4 < v3);
  uint64_t v5 = &a1[v2];
  unsigned int v6 = &a1[v2 - 1];
  if (v2 == 1)
  {
    do
    {
      if (v5 >= a2) {
        break;
      }
      unsigned int v8 = *--a2;
    }
    while (v8 >= v3);
  }
  else
  {
    do
      unsigned int v7 = *--a2;
    while (v7 >= v3);
  }
  if (v5 < a2)
  {
    unsigned int v9 = *a2;
    unsigned int v10 = &a1[v2];
    unsigned int v11 = a2;
    do
    {
      *unsigned int v10 = v9;
      *unsigned int v11 = v4;
      do
      {
        unsigned int v12 = v10[1];
        ++v10;
        unsigned int v4 = v12;
      }
      while (v12 < v3);
      do
      {
        unsigned int v13 = *--v11;
        unsigned int v9 = v13;
      }
      while (v13 >= v3);
    }
    while (v10 < v11);
    unsigned int v6 = v10 - 1;
  }
  if (v6 != a1) {
    *a1 = *v6;
  }
  unsigned int *v6 = v3;
  return v6;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(unsigned int *a1, unsigned int *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unsigned int v6 = *(a2 - 1);
      unsigned int v7 = *a1;
      if (v6 < *a1)
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      unsigned int v8 = a1 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(a1, a1 + 1, a1 + 2);
      unsigned int v9 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v10 = 0;
      uint64_t v11 = 12;
      break;
  }
  while (1)
  {
    unsigned int v12 = *v9;
    unsigned int v13 = *v8;
    if (*v9 < *v8)
    {
      uint64_t v14 = v11;
      while (1)
      {
        *(unsigned int *)((char *)a1 + v14) = v13;
        uint64_t v15 = v14 - 4;
        if (v14 == 4) {
          break;
        }
        unsigned int v13 = *(unsigned int *)((char *)a1 + v14 - 8);
        v14 -= 4;
        if (v12 >= v13)
        {
          BOOL v16 = (unsigned int *)((char *)a1 + v15);
          goto LABEL_12;
        }
      }
      BOOL v16 = a1;
LABEL_12:
      *BOOL v16 = v12;
      if (++v10 == 8) {
        return v9 + 1 == a2;
      }
    }
    unsigned int v8 = v9;
    v11 += 4;
    if (++v9 == a2) {
      return 1;
    }
  }
}

uint64_t std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(a1, a2, a3);
  unsigned int v9 = *a3;
  if (*a4 < *a3)
  {
    *a3 = *a4;
    *a4 = v9;
    unsigned int v10 = *a2;
    if (*a3 < *a2)
    {
      *a2 = *a3;
      *a3 = v10;
      unsigned int v11 = *a1;
      if (*a2 < *a1)
      {
        *a1 = *a2;
        *a2 = v11;
      }
    }
  }
  return result;
}

uint64_t std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4, unsigned int *a5)
{
  uint64_t result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(a1, a2, a3, a4);
  unsigned int v11 = *a4;
  if (*a5 < *a4)
  {
    *a4 = *a5;
    *a5 = v11;
    unsigned int v12 = *a3;
    if (*a4 < *a3)
    {
      *a3 = *a4;
      *a4 = v12;
      unsigned int v13 = *a2;
      if (*a3 < *a2)
      {
        *a2 = *a3;
        *a3 = v13;
        unsigned int v14 = *a1;
        if (*a2 < *a1)
        {
          *a1 = *a2;
          *a2 = v14;
        }
      }
    }
  }
  return result;
}

unsigned int *std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *,RB::Symbol::Tag *>(unsigned int *a1, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    unsigned int v6 = a2;
    uint64_t v8 = (char *)a2 - (char *)a1;
    uint64_t v9 = a2 - a1;
    if ((char *)a2 - (char *)a1 >= 5)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      unsigned int v12 = &a1[v10];
      do
      {
        std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>((uint64_t)a1, a4, v9, v12--);
        --v11;
      }
      while (v11);
    }
    unsigned int v13 = v6;
    if (v6 != a3)
    {
      unsigned int v14 = v6;
      do
      {
        unsigned int v15 = *v14;
        if (*v14 < *a1)
        {
          *unsigned int v14 = *a1;
          *a1 = v15;
          std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>((uint64_t)a1, a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      unsigned int v13 = a3;
    }
    if (v8 >= 5)
    {
      uint64_t v16 = (unint64_t)v8 >> 2;
      do
      {
        uint64_t v17 = 0;
        unsigned int v18 = *a1;
        unsigned int v19 = a1;
        do
        {
          BOOL v20 = &v19[v17 + 1];
          uint64_t v21 = (2 * v17) | 1;
          uint64_t v17 = 2 * v17 + 2;
          if (v17 >= v16)
          {
            unsigned int v22 = *v20;
            uint64_t v17 = v21;
          }
          else
          {
            unsigned int v22 = *v20;
            unsigned int v23 = v20[1];
            if (*v20 <= v23) {
              unsigned int v22 = v20[1];
            }
            if (*v20 >= v23) {
              uint64_t v17 = v21;
            }
            else {
              ++v20;
            }
          }
          *unsigned int v19 = v22;
          unsigned int v19 = v20;
        }
        while (v17 <= (uint64_t)((unint64_t)(v16 - 2) >> 1));
        if (v20 == --v6)
        {
          *BOOL v20 = v18;
        }
        else
        {
          *BOOL v20 = *v6;
          unsigned int *v6 = v18;
          uint64_t v24 = (char *)v20 - (char *)a1 + 4;
          if (v24 >= 5)
          {
            unint64_t v25 = (((unint64_t)v24 >> 2) - 2) >> 1;
            float v26 = &a1[v25];
            unsigned int v27 = *v26;
            unsigned int v28 = *v20;
            if (*v26 < *v20)
            {
              do
              {
                *BOOL v20 = v27;
                BOOL v20 = v26;
                if (!v25) {
                  break;
                }
                unint64_t v25 = (v25 - 1) >> 1;
                float v26 = &a1[v25];
                unsigned int v27 = *v26;
              }
              while (*v26 < v28);
              *BOOL v20 = v28;
            }
          }
        }
      }
      while (v16-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(uint64_t result, uint64_t a2, uint64_t a3, unsigned int *a4)
{
  if (a3 >= 2)
  {
    uint64_t v4 = (uint64_t)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 2)
    {
      uint64_t v6 = v4 >> 1;
      uint64_t v7 = (v4 >> 1) + 1;
      uint64_t v8 = (unsigned int *)(result + 4 * v7);
      uint64_t v9 = v6 + 2;
      if (v9 >= a3)
      {
        unsigned int v10 = *v8;
      }
      else
      {
        unsigned int v10 = *v8;
        unsigned int v11 = v8[1];
        if (*v8 <= v11) {
          unsigned int v10 = v8[1];
        }
        if (*v8 < v11)
        {
          ++v8;
          uint64_t v7 = v9;
        }
      }
      unsigned int v12 = *a4;
      if (v10 >= *a4)
      {
        do
        {
          *a4 = v10;
          a4 = v8;
          if (v5 < v7) {
            break;
          }
          uint64_t v13 = (2 * v7) | 1;
          uint64_t v8 = (unsigned int *)(result + 4 * v13);
          uint64_t v7 = 2 * v7 + 2;
          if (v7 >= a3)
          {
            unsigned int v10 = *v8;
            uint64_t v7 = v13;
          }
          else
          {
            unsigned int v10 = *v8;
            unsigned int v14 = v8[1];
            if (*v8 <= v14) {
              unsigned int v10 = v8[1];
            }
            if (*v8 >= v14) {
              uint64_t v7 = v13;
            }
            else {
              ++v8;
            }
          }
        }
        while (v10 >= v12);
        *a4 = v12;
      }
    }
  }
  return result;
}

atomic_uint *RB::Refcount<RB::Path::Object,std::atomic<unsigned int>>::release(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t RB::Table<NSString *,unsigned int>::for_each<RB::Symbol::GlyphCache::tag(RB::Symbol::Tag)::$_0>(RB::Symbol::GlyphCache::tag(RB::Symbol::Tag)::$_0)const::{lambda(void const*,void const*,void *)#1}::__invoke(uint64_t result, int a2, uint64_t a3)
{
  if (*(_DWORD *)(a3 + 8) == a2) {
    **(void **)a3 = result;
  }
  return result;
}

uint64_t *std::unique_ptr<RB::Symbol::Glyph::Sublayers>::reset[abi:nn180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *uint64_t result = a2;
  if (v2)
  {
    unsigned int v3 = *(void **)(v2 + 264);
    if (v3) {
      uint64_t v4 = *(RB::Symbol::Glyph::Layer **)(v2 + 264);
    }
    else {
      uint64_t v4 = (RB::Symbol::Glyph::Layer *)v2;
    }
    if (*(_DWORD *)(v2 + 272))
    {
      unint64_t v5 = 0;
      do
      {
        RB::Symbol::Glyph::Layer::~Layer(v4);
        ++v5;
        uint64_t v4 = (RB::Symbol::Glyph::Layer *)(v6 + 88);
      }
      while (v5 < *(unsigned int *)(v2 + 272));
      unsigned int v3 = *(void **)(v2 + 264);
    }
    if (v3) {
      free(v3);
    }
    JUMPOUT(0x21669AC10);
  }
  return result;
}

void *RB::vector<RB::Symbol::Tag,4ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  if (*((_DWORD *)__dst + 7) + (*((_DWORD *)__dst + 7) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *((_DWORD *)__dst + 7) + (*((_DWORD *)__dst + 7) >> 1);
  }
  uint64_t result = RB::details::realloc_vector<unsigned int,4ul>(*((void **)__dst + 2), __dst, 4u, (_DWORD *)__dst + 7, v3);
  *((void *)__dst + 2) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,4ul>(void *__src, void *__dst, unsigned int a3, _DWORD *a4, unsigned int a5)
{
  uint64_t v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      LODWORD(v9) = a3;
      memcpy(__dst, __src, 4 * a5);
      free(v7);
      unsigned int v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(4 * a5);
    size_t v9 = v8 >> 2;
    if (*a4 != (v8 >> 2))
    {
      unsigned int v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10) {
        RB::precondition_failure((RB *)"allocation failure", v11);
      }
      unsigned int v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, 4 * *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

uint64_t RB::DisplayList::ClipNode::contains(void *a1, double a2, double a3)
{
  if (!a1) {
    return 1;
  }
  unint64_t v5 = a1;
  do
  {
    uint64_t result = (*(uint64_t (**)(unint64_t, double, double))(*(void *)(v5[1] & 0xFFFFFFFFFFFFFFFELL)
                                                                         + 32))(v5[1] & 0xFFFFFFFFFFFFFFFELL, a2, a3);
    if (!result) {
      break;
    }
    unint64_t v5 = (void *)*v5;
  }
  while (v5);
  return result;
}

void RB::DisplayList::Clip::print(RB::DisplayList::Clip *this, std::string *a2)
{
  if (*((_DWORD *)this + 10)) {
    RB::SexpString::printf(a2, 0, "(identifier %u)", *((_DWORD *)this + 10));
  }
  if (*((unsigned char *)this + 44) == 1)
  {
    RB::SexpString::print(a2, 0, "inverse");
  }
}

uint64_t RB::DisplayList::LayerClip::LayerClip(uint64_t a1, RB::DisplayList::Layer *this, int a3, double a4, int32x4_t a5)
{
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 44) = a3;
  *(void *)a1 = &unk_26C4ECE60;
  *(void *)(a1 + 48) = this;
  *(_DWORD *)(a1 + 56) = LODWORD(a4);
  *(unsigned char *)(a1 + 45) = 2;
  if (a3 == 1)
  {
    float32x2_t v7 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
    float32x2_t v6 = (float32x2_t)0x100000001000000;
LABEL_7:
    *(float32x2_t *)(a1 + 16) = v6;
    *(float32x2_t *)(a1 + 24) = v7;
    return a1;
  }
  if (!a3)
  {
    if (this)
    {
      float32x2_t v6 = RB::DisplayList::Layer::bounds(this, a4, a5);
    }
    else
    {
      float32x2_t v6 = 0;
      float32x2_t v7 = 0;
    }
    goto LABEL_7;
  }
  return a1;
}

void sub_21415D1E0(_Unwind_Exception *exception_object)
{
  unsigned int v3 = *(RB::DisplayList::Layer **)(v1 + 48);
  *(void *)(v1 + 48) = 0;
  if (v3) {
    RB::DisplayList::Layer::~Layer(v3);
  }
  _Unwind_Resume(exception_object);
}

void *RB::DisplayList::LayerClip::copy(uint64_t a1, size_t *a2, uint64_t a3, uint64_t a4, double a5, int32x4_t a6)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  size_t v10 = *a2;
  int v11 = *(unsigned __int8 *)(*a2 + 272);
  if (*(unsigned char *)(*a2 + 272))
  {
    LODWORD(a5) = *(_DWORD *)(a1 + 56);
    if (*(float *)&a5 == 0.0) {
      return (void *)a3;
    }
  }
  unsigned int v12 = *(RB::DisplayList::Layer **)(a1 + 48);
  if (v12)
  {
    unsigned int v12 = (RB::DisplayList::Layer *)RB::DisplayList::Layer::copy(v12, (RB::DisplayList::Builder *)*a2, 0);
    uint64_t v13 = v12;
    int v11 = *(unsigned __int8 *)(v10 + 272);
  }
  else
  {
    uint64_t v13 = 0;
  }
  BOOL v40 = v13;
  if (a4) {
    uint64_t v14 = *(unsigned char *)(a1 + 44) == 0;
  }
  else {
    uint64_t v14 = *(char *)(a1 + 44);
  }
  int v39 = v14;
  if (!v11)
  {
LABEL_25:
    uint64_t v24 = *(void *)(v10 + 8);
    unint64_t v25 = (size_t *)(v24 + 16);
    if (!v13)
    {
      if (v14) {
        return (void *)a3;
      }
      memset(v41, 0, sizeof(v41));
      LODWORD(v42) = 1065353216;
      *(void *)((char *)&v42 + 4) = 0;
      *(_DWORD *)((char *)&v42 + 11) = 0;
      int v38 = 1;
      BOOL v37 = RB::AffineTransform::identity(v12);
      uint64_t v34 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive&,int,RB::ClipMode &,RB::AffineTransform const*>(v25, v33, (uint64_t)v25, v41, &v38, &v39, (uint64_t *)&v37);
      float v35 = (void *)((a2[3] + 7) & 0xFFFFFFFFFFFFFFF8);
      if ((unint64_t)(v35 + 2) > a2[4]) {
        float v35 = (void *)RB::Heap::alloc_slow(a2 + 1, 0x10uLL, 7);
      }
      else {
        a2[3] = (size_t)(v35 + 2);
      }
      *float v35 = a3;
      v35[1] = v34;
      return v35;
    }
    uint64_t v26 = RB::Heap::emplace<RB::DisplayList::LayerClip,RB::DisplayList::Layer *&,float const&,RB::ClipMode &>((size_t *)(v24 + 16), &v40, (_DWORD *)(a1 + 56), &v39, a5, a6);
    *(void *)(v26 + 32) = RB::DisplayList::CachedTransform::transform_metadata((RB::DisplayList::CachedTransform *)a2, *(const RB::DisplayList::Metadata **)(a1 + 32), *(_DWORD *)(a1 + 40));
    *(_DWORD *)(v26 + 40) = v27;
    RB::DisplayList::Layer::apply_transform(*(RB::DisplayList::Layer **)(v26 + 48), (const RB::DisplayList::CachedTransform *)a2);
    if (*(unsigned char *)(v10 + 272)) {
      RB::DisplayList::Layer::discard_color(*(void *)(v26 + 48));
    }
    if (v39 == 1)
    {
      float32x2_t v32 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
      float32x2_t v31 = (float32x2_t)0x100000001000000;
    }
    else
    {
      if (v39)
      {
LABEL_39:
        float v35 = (void *)((a2[3] + 7) & 0xFFFFFFFFFFFFFFF8);
        if ((unint64_t)(v35 + 2) > a2[4]) {
          float v35 = (void *)RB::Heap::alloc_slow(a2 + 1, 0x10uLL, 7);
        }
        else {
          a2[3] = (size_t)(v35 + 2);
        }
        *float v35 = a3;
        v35[1] = v26;
        return v35;
      }
      int v30 = *(RB::DisplayList::Layer **)(v26 + 48);
      if (v30)
      {
        float32x2_t v31 = RB::DisplayList::Layer::bounds(v30, v28, v29);
      }
      else
      {
        float32x2_t v31 = 0;
        float32x2_t v32 = 0;
      }
    }
    *(float32x2_t *)(v26 + 16) = v31;
    *(float32x2_t *)(v26 + 24) = v32;
    goto LABEL_39;
  }
  unsigned int v12 = RB::DisplayList::Builder::simplify_clip_layer((RB::DisplayList::Builder *)v10, v13, v14);
  BOOL v40 = v12;
  if (!v15)
  {
    uint64_t v13 = v12;
    goto LABEL_25;
  }
  uint64_t v16 = v15;
  for (uint64_t i = (void *)v15[3]; i; uint64_t i = (void *)*i)
    a3 = (*(uint64_t (**)(unint64_t, size_t *, uint64_t, uint64_t))(*(void *)(i[1] & 0xFFFFFFFFFFFFFFFELL)
                                                                                 + 24))(i[1] & 0xFFFFFFFFFFFFFFFELL, a2, a3, a4);
  _OWORD v16[3] = 0;
  (*(void (**)(void *, size_t *, void))(*v16 + 32))(v16, a2, 0);
  long long v42 = 0uLL;
  uint64_t v43 = 4;
  float v18 = *(float *)(a1 + 56);
  unsigned int v19 = (uint64_t *)v41;
  (*(void (**)(void *, size_t, uint64_t, _OWORD *, float))(*v16 + 88))(v16, v10, v14, v41, v18);
  BOOL v20 = (void *)v42;
  if ((void)v42) {
    unsigned int v19 = (uint64_t *)v42;
  }
  if (*((void *)&v42 + 1))
  {
    uint64_t v21 = 8 * *((void *)&v42 + 1);
    do
    {
      uint64_t v22 = *v19;
      unsigned int v23 = (void *)((a2[3] + 7) & 0xFFFFFFFFFFFFFFF8);
      if ((unint64_t)(v23 + 2) > a2[4]) {
        unsigned int v23 = (void *)RB::Heap::alloc_slow(a2 + 1, 0x10uLL, 7);
      }
      else {
        a2[3] = (size_t)(v23 + 2);
      }
      *unsigned int v23 = a3;
      v23[1] = v22;
      ++v19;
      a3 = (uint64_t)v23;
      v21 -= 8;
    }
    while (v21);
    BOOL v20 = (void *)v42;
    a3 = (uint64_t)v23;
  }
  if (v20) {
    free(v20);
  }
  return (void *)a3;
}

void sub_21415D58C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  if (a17) {
    free(a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::Heap::emplace<RB::DisplayList::LayerClip,RB::DisplayList::Layer *&,float const&,RB::ClipMode &>(size_t *a1, RB::DisplayList::Layer **a2, _DWORD *a3, int *a4, double a5, int32x4_t a6)
{
  uint64_t v9 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v9 + 64 > a1[3]) {
    uint64_t v9 = RB::Heap::alloc_slow(a1, 0x40uLL, 7);
  }
  else {
    a1[2] = v9 + 64;
  }
  size_t v10 = *a2;
  LODWORD(a5) = *a3;
  int v11 = *a4;
  return RB::DisplayList::LayerClip::LayerClip(v9, v10, v11, a5, a6);
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive&,int,RB::ClipMode &,RB::AffineTransform const*>(size_t *a1, int8x16_t a2, uint64_t a3, _OWORD *a4, int *a5, int *a6, uint64_t *a7)
{
  uint64_t v11 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v11 + 128 > a1[3]) {
    uint64_t v11 = RB::Heap::alloc_slow(a1, 0x80uLL, 15);
  }
  else {
    a1[2] = v11 + 128;
  }
  *(float *)a2.i32 = (float)*a5;
  int v12 = *a6;
  uint64_t v13 = *a7;
  *(void *)(v11 + 16) = 0;
  *(void *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(void *)(v11 + 32) = 0;
  *(_WORD *)(v11 + 44) = v12;
  *(void *)uint64_t v11 = &unk_26C4E8E48;
  *(void *)(v11 + 48) = v13;
  int32x4_t v14 = *(int32x4_t *)a4;
  int8x16_t v15 = *((int8x16_t *)a4 + 1);
  int32x4_t v16 = *(int32x4_t *)((char *)a4 + 31);
  *(int32x4_t *)(v11 + 95) = v16;
  *(int32x4_t *)(v11 + 64) = v14;
  *(int8x16_t *)(v11 + 80) = v15;
  *(_DWORD *)(v11 + 112) = a2.i32[0];
  RB::DisplayList::GenericClip<RB::Coverage::Primitive>::update_bounds(v11, a2, v14, v15, v16);
  return v11;
}

RB::DisplayList::Layer *RB::DisplayList::LayerClip::contains(uint64_t a1, double d0_0, int32x4_t a3)
{
  if (*(unsigned char *)(a1 + 44) != 1) {
    return 0;
  }
  float32x2_t v3 = *(float32x2_t *)&d0_0;
  LODWORD(d0_0) = *(_DWORD *)(a1 + 56);
  if (*(float *)&d0_0 == 0.0) {
    return (RB::DisplayList::Layer *)1;
  }
  uint64_t result = *(RB::DisplayList::Layer **)(a1 + 48);
  if (result)
  {
    float32x2_t v5 = *(float32x2_t *)a3.i8;
    v11[0] = RB::DisplayList::Layer::bounds(result, d0_0, a3);
    v11[1] = v6;
    return (RB::DisplayList::Layer *)(RB::Rect::intersects(v11, v12, v3, v5, v7, v8, v9, v10) ^ 1);
  }
  return result;
}

double RB::DisplayList::LayerClip::min_scale(RB::DisplayList::LayerClip *this)
{
  uint64_t v1 = (RB::DisplayList::Layer *)*((void *)this + 6);
  if (!v1) {
    return 0.0;
  }
  RB::DisplayList::Layer::min_scale(v1);
  return result;
}

void RB::DisplayList::LayerClip::print(RB::DisplayList::Layer **this, std::string *a2)
{
  RB::SexpString::push(a2, "clip-layer");
  RB::DisplayList::Clip::print((RB::DisplayList::Clip *)this, a2);
  float v4 = *((float *)this + 14);
  if (v4 != 1.0) {
    RB::SexpString::printf(a2, 1, "(alpha %g)", v4);
  }
  RB::DisplayList::Layer::print(this[6], a2);
  RB::SexpString::pop(a2);
}

uint64_t RB::DisplayList::ItemClip::ItemClip(uint64_t a1, RB::DisplayList::Item *this, int a3, float a4)
{
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 44) = a3;
  *(unsigned char *)(a1 + 45) = 0;
  *(void *)a1 = &unk_26C4ECDC8;
  *(void *)(a1 + 48) = this;
  if (this)
  {
    RB::DisplayList::Item::apply_alpha((uint64_t)this, a4);
    char v7 = *(unsigned char *)(a1 + 45) & 0xFE;
  }
  else
  {
    char v7 = 0;
  }
  *(unsigned char *)(a1 + 45) = v7;
  if (a3 == 1)
  {
    int32x2_t v9 = vdup_n_s32(0x7F7FFFFFu);
    uint64_t v8 = 0x100000001000000;
LABEL_10:
    *(void *)(a1 + 16) = v8;
    *(int32x2_t *)(a1 + 24) = v9;
    return a1;
  }
  if (!a3)
  {
    if (this)
    {
      (*(void (**)(RB::DisplayList::Item *, void))(*(void *)this + 144))(this, 0);
    }
    else
    {
      uint64_t v8 = 0;
      int32x2_t v9 = 0;
    }
    goto LABEL_10;
  }
  return a1;
}

void sub_21415D904(_Unwind_Exception *exception_object)
{
  float32x2_t v3 = *(void (****)(void))(v1 + 48);
  *(void *)(v1 + 48) = 0;
  if (v3) {
    (**v3)(v3);
  }
  _Unwind_Resume(exception_object);
}

void *RB::DisplayList::ItemClip::copy(uint64_t a1, size_t *a2, uint64_t a3, int a4)
{
  int8x16_t v15 = (RB::DisplayList::Item *)(*(uint64_t (**)(void, size_t, void))(**(void **)(a1 + 48) + 24))(*(void *)(a1 + 48), *a2, 0);
  (*(void (**)(RB::DisplayList::Item *, size_t *, void))(*(void *)v15 + 32))(v15, a2, 0);
  uint64_t v8 = (size_t *)(*(void *)(*a2 + 8) + 16);
  int v9 = *(char *)(a1 + 44);
  if (a4) {
    int v9 = *(unsigned char *)(a1 + 44) == 0;
  }
  int v13 = v9;
  int v14 = 1;
  uint64_t v10 = RB::Heap::emplace<RB::DisplayList::ItemClip,RB::DisplayList::Item *&,int,RB::ClipMode>(v8, &v15, &v14, &v13);
  *(void *)(v10 + 32) = RB::DisplayList::CachedTransform::transform_metadata((RB::DisplayList::CachedTransform *)a2, *(const RB::DisplayList::Metadata **)(a1 + 32), *(_DWORD *)(a1 + 40));
  *(_DWORD *)(v10 + 40) = v11;
  double result = (void *)((a2[3] + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(result + 2) > a2[4]) {
    double result = (void *)RB::Heap::alloc_slow(a2 + 1, 0x10uLL, 7);
  }
  else {
    a2[3] = (size_t)(result + 2);
  }
  *double result = a3;
  result[1] = v10;
  return result;
}

uint64_t RB::Heap::emplace<RB::DisplayList::ItemClip,RB::DisplayList::Item *&,int,RB::ClipMode>(size_t *a1, RB::DisplayList::Item **a2, int *a3, int *a4)
{
  uint64_t v7 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v7 + 56 > a1[3]) {
    uint64_t v7 = RB::Heap::alloc_slow(a1, 0x38uLL, 7);
  }
  else {
    a1[2] = v7 + 56;
  }
  uint64_t v8 = *a2;
  float v9 = (float)*a3;
  int v10 = *a4;
  return RB::DisplayList::ItemClip::ItemClip(v7, v8, v10, v9);
}

uint64_t RB::DisplayList::ItemClip::contains(uint64_t a1, float32x2_t d0_0, float32x2_t a3)
{
  if (*(unsigned char *)(a1 + 44) != 1) {
    return 0;
  }
  v11[0] = COERCE_FLOAT32X2_T((*(double (**)(void, void))(**(void **)(a1 + 48) + 144))(*(void *)(a1 + 48), 0));
  v11[1] = v5;
  return RB::Rect::intersects(v11, v12, d0_0, a3, v6, v7, v8, v9) ^ 1;
}

void RB::DisplayList::ItemClip::print(RB::DisplayList::ItemClip *this, std::string *a2)
{
  RB::SexpString::push(a2, "clip-item");
  RB::DisplayList::Clip::print(this, a2);
  (*(void (**)(void))(**((void **)this + 6) + 256))();
  RB::SexpString::pop(a2);
}

void RB::DisplayList::LayerClip::~LayerClip(RB::DisplayList::LayerClip *this)
{
  uint64_t v2 = (RB::DisplayList::Layer *)*((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v2) {
    RB::DisplayList::Layer::~Layer(v2);
  }
}

{
  RB::DisplayList::Layer *v2;
  uint64_t vars8;

  uint64_t v2 = (RB::DisplayList::Layer *)*((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v2) {
    RB::DisplayList::Layer::~Layer(v2);
  }
  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::LayerClip::type_id(RB::DisplayList::LayerClip *this)
{
  return 0;
}

void RB::DisplayList::ItemClip::~ItemClip(RB::DisplayList::ItemClip *this)
{
  uint64_t v2 = (void (***)(void))*((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v2) {
    (**v2)(v2);
  }
}

{
  void (***v2)(void);
  uint64_t vars8;

  uint64_t v2 = (void (***)(void))*((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v2) {
    (**v2)(v2);
  }
  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::ItemClip::type_id(RB::DisplayList::ItemClip *this)
{
  return 1;
}

uint64_t RB::DisplayList::ItemClip::min_scale(RB::DisplayList::ItemClip *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 6) + 152))();
}

__CFString *contents_debug_description(void *a1)
{
  uint64_t v1 = (RB::DisplayList::Contents *)objc_msgSend(a1, "_rb_contents");
  if (!v1) {
    return @"(display-list)";
  }
  memset(__p, 0, 41);
  RB::DisplayList::Contents::print(v1, __p);
  if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v2 = __p;
  }
  else {
    uint64_t v2 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
  }
  uint64_t v3 = [NSString stringWithUTF8String:v2];
  if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p[0].__r_.__value_.__l.__data_);
  }
  return (__CFString *)v3;
}

void sub_21415DE9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t RBDrawingStateSetDefaultColorSpace(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  unint64_t result = rb_color_space(a2);
  *(_WORD *)(a1 + 156) = result;
  uint64_t v6 = *(void *)(v4 + 304);
  if (v6) {
    *(_DWORD *)(v6 + 120) = a2;
  }
  return result;
}

BOOL RBDrawingStateHasLinearColors(uint64_t a1)
{
  unsigned int v1 = *(unsigned __int16 *)(a1 + 156);
  return (v1 & 1) == 0 && v1 > 0xFF;
}

void sub_21415E02C(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10A0C4070508A9ALL);
  _Unwind_Resume(a1);
}

size_t *RBDrawingStateAssign(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 != *(void *)(a2 + 8)) {
    RB::precondition_failure((RB *)"display list mismatch", (const char *)a2);
  }
  RB::DisplayList::State::operator=(a1, a2);
  unint64_t result = *(size_t **)(v2 + 304);
  if (result)
  {
    return RB::XML::DisplayList::copy_state((RB::XML::DisplayList *)result, (RB::XML::Document *)a2, (_RBDrawingState *)a1, v5);
  }
  return result;
}

uint64_t RBDrawingStateClipLayer(__n128 *a1, RB::DisplayList::State *a2, int a3, float a4)
{
  double v8 = (atomic_uint *)a1->n128_u64[1];
  if (!*((void *)v8 + 3)) {
    make_contents(a1->n128_i64[1]);
  }
  if (v8 != *((atomic_uint **)a2 + 1)) {
    RB::precondition_failure((RB *)"display list mismatch", (const char *)a2);
  }
  int32x4_t v9 = (RB::DisplayList::Layer *)RB::DisplayList::Builder::end_layer((RB::DisplayList::Builder *)(v8 + 4), a2);
  RB::DisplayList::Builder::delete_state(v8 + 4, a2);
  BOOL v10 = rb_clip_mode(a3);
  v11.n128_f32[0] = a4;
  RB::DisplayList::Builder::clip_layer((RB::DisplayList::Builder *)(v8 + 4), v9, a1, v10, v11);
  uint64_t result = *((void *)v8 + 38);
  if (result)
  {
    RB::XML::DisplayList::clip_layer();
  }
  return result;
}

__n128 RB::AffineTransform::inverse(RB::AffineTransform *this)
{
  long long v2 = *((_OWORD *)this + 1);
  v5[0] = *(_OWORD *)this;
  v5[1] = v2;
  void v5[2] = *((_OWORD *)this + 2);
  if (RB::AffineTransform::invert((RB::AffineTransform *)v5)) {
    uint64_t v3 = (RB::AffineTransform *)v5;
  }
  else {
    uint64_t v3 = this;
  }
  return *(__n128 *)v3;
}

void RBDrawingStateGetClipBoundingBox(uint64_t a1)
{
  float32x2_t v3 = COERCE_FLOAT32X2_T(RB::DisplayList::State::clip_bounds((RB::DisplayList::State *)a1));
  float32x2_t v23 = v3;
  float32x2_t v24 = v2;
  uint32x2_t v4 = (uint32x2_t)vclez_f32(v2);
  if ((vpmax_u32(v4, v4).u32[0] & 0x80000000) == 0)
  {
    float32x2_t v5 = v2;
    float32x2_t v6 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
    uint32x2_t v7 = (uint32x2_t)vcge_f32(vabs_f32(v2), v6);
    if ((vpmax_u32(v7, v7).u32[0] & 0x80000000) == 0)
    {
      int32x4_t v8 = *(int32x4_t *)(a1 + 32);
      float64x2_t v25 = *(float64x2_t *)(a1 + 16);
      int32x4_t v26 = v8;
      long long v27 = *(_OWORD *)(a1 + 48);
      BOOL v9 = RB::AffineTransform::invert((RB::AffineTransform *)&v25);
      if (v9) {
        BOOL v10 = &v25;
      }
      else {
        BOOL v10 = (float64x2_t *)(a1 + 16);
      }
      float64x2_t v11 = *v10;
      if (v9) {
        Rect v12 = &v26;
      }
      else {
        Rect v12 = (int32x4_t *)(a1 + 32);
      }
      int32x4_t v13 = *v12;
      if (v9) {
        int v14 = &v27;
      }
      else {
        int v14 = (long long *)(a1 + 48);
      }
      long long v15 = *v14;
      float64x2_t v25 = v11;
      int32x4_t v26 = v13;
      long long v27 = v15;
      *(float32x2_t *)v13.i8 = v5;
      float32x2_t v23 = RB::operator*(&v25, v3, v13);
      float32x2_t v24 = v16;
    }
    uint64_t v17 = RB::DisplayList::Builder::crop_bounds((RB::DisplayList::Builder *)(*(void *)(a1 + 8) + 16), (RB::DisplayList::State *)a1);
    uint32x2_t v22 = (uint32x2_t)vcge_f32((float32x2_t)(*(void *)(v17 + 8) & 0x7FFFFFFF7FFFFFFFLL), v6);
    if ((vpmax_u32(v22, v22).u32[0] & 0x80000000) == 0) {
      RB::Rect::intersect(&v23, *(double *)v17, *(float32x2_t *)(v17 + 8), v18, v19, v20, v21);
    }
  }
}

void RBDrawingStateGetDeviceClipBoundingBox(uint64_t a1)
{
  v13[0] = COERCE_FLOAT32X2_T(RB::DisplayList::State::clip_bounds((RB::DisplayList::State *)a1));
  v13[1] = v2;
  uint32x2_t v3 = (uint32x2_t)vclez_f32(v2);
  if ((vpmax_u32(v3, v3).u32[0] & 0x80000000) == 0)
  {
    uint32x2_t v4 = (float32x2_t *)RB::DisplayList::Builder::crop_bounds((RB::DisplayList::Builder *)(*(void *)(a1 + 8) + 16), (RB::DisplayList::State *)a1);
    uint32x2_t v6 = (uint32x2_t)vcge_f32((float32x2_t)(*(void *)&v4[1] & 0x7FFFFFFF7FFFFFFFLL), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
    if ((vpmax_u32(v6, v6).u32[0] & 0x80000000) == 0)
    {
      *(float32x2_t *)v5.i8 = v4[1];
      *(float32x2_t *)&double v7 = RB::operator*((float64x2_t *)(a1 + 16), *v4, v5);
      RB::Rect::intersect(v13, v7, v8, v9, v10, v11, v12);
    }
  }
}

RB::XML::Document *RBDrawingStateRotateCTM(uint64_t a1, double a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  __double2 v6 = __sincos_stret(a2);
  v5.f64[0] = v6.__cosval;
  v7.f64[0] = -v6.__sinval;
  v7.f64[1] = v6.__cosval;
  v5.f64[1] = v6.__sinval;
  v10[0] = v5;
  v10[1] = v7;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  RB::DisplayList::State::concat((float64x2_t *)a1, v10);
  uint64_t result = *(RB::XML::Document **)(v4 + 304);
  if (result) {
    return RB::XML::DisplayList::rotate_ctm(result, (RB::XML::Document *)a1, v8, a2);
  }
  return result;
}

id RBDrawingStateGetIdentifierNamespace(uint64_t a1)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  long long v2 = *(_OWORD *)(a1 + 68);
  return (id)[objc_alloc(MEMORY[0x263F08C38]) initWithUUIDBytes:&v2];
}

RBTransition *RBDrawingStateGetTransition(uint64_t a1)
{
  uint64_t v1 = RBDrawingStateCopyTransition(a1);
  return v1;
}

RBTransition *RBDrawingStateCopyTransition(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  if (v1 && *(unsigned char *)(v1 + 12))
  {
    uint64_t v2 = objc_opt_new();
    -[RBTransition setTransition:](v2, v1);
    return (RBTransition *)v2;
  }
  else
  {
    uint64_t v4 = +[RBTransition defaultTransition];
    return v4;
  }
}

uint64_t *RBDrawingStateSetTransition(uint64_t *result, uint64_t a2)
{
  if (!a2) {
    return result;
  }
  uint64_t v2 = result;
  uint64_t result = (uint64_t *)-[RBDecodedFontMetadata fontUID](a2);
  uint64_t v3 = (_RBDrawingState *)result;
  uint64_t v4 = (uint64_t *)v2[11];
  if (!*((unsigned char *)result + 13))
  {
LABEL_11:
    if (v4 == result) {
      return result;
    }
    goto LABEL_12;
  }
  if (v4)
  {
    if (*((unsigned char *)v4 + 12))
    {
      if (*((unsigned char *)v4 + 13)) {
        BOOL v5 = v4 == result;
      }
      else {
        BOOL v5 = 1;
      }
      if (v5) {
        return result;
      }
      goto LABEL_12;
    }
    goto LABEL_11;
  }
LABEL_12:
  RB::DisplayList::State::set_transition((RB::DisplayList::State *)v2, (const RB::Transition *)result);
  uint64_t v7 = v2[1];
  if (!*(void *)(v7 + 24)) {
    make_contents(v2[1]);
  }
  uint64_t result = *(uint64_t **)(v7 + 304);
  if (result)
  {
    RB::XML::DisplayList::transition((RB::XML::DisplayList *)result, (RB::XML::Document *)v2, v3, v6);
  }
  return result;
}

uint64_t RBDrawingStateSetAttribute(RB::DisplayList::State *this, void *cf, int a3)
{
  __double2 v6 = (void *)*((void *)this + 1);
  if (v6[3])
  {
    if (a3)
    {
LABEL_3:
      if (a3 == 1)
      {
        uint64_t result = RB::DisplayList::State::set_text_run(this, cf, (RB::DisplayList::Builder *)(v6 + 2));
        if ((result & 1) == 0) {
          return result;
        }
      }
      goto LABEL_8;
    }
  }
  else
  {
    make_contents(*((void *)this + 1));
    if (a3) {
      goto LABEL_3;
    }
  }
  [cf floatValue];
  uint64_t result = RB::DisplayList::State::set_numeric_value((uint64_t)this, v8);
  if (!result) {
    return result;
  }
LABEL_8:
  uint64_t result = v6[38];
  if (result)
  {
    RB::XML::DisplayList::attribute_value((RB::XML::Document *)result);
  }
  return result;
}

uint64_t RBDrawingStateGetAttribute(uint64_t result, int a2, double a3)
{
  if (a2 == 1) {
    return [NSNumber numberWithBool:*(void *)(result + 160) != 0];
  }
  if (!a2)
  {
    LODWORD(a3) = *(_DWORD *)(result + 152);
    return [NSNumber numberWithFloat:a3];
  }
  return result;
}

RB::XML::Document *RBDrawingStateClipShape(__n128 *a1, uint64_t a2, int a3)
{
  return RBDrawingStateClipShape2(a1, a2, a3, 1.0);
}

RB::DisplayList::Builder *RBDrawingStateDrawMetal(uint64_t *a1, unsigned int a2, int a3, void *a4, float64_t a5, float64_t a6, double a7, float64_t a8, float a9)
{
  uint64_t v14 = a1[1];
  if (!*(void *)(v14 + 24)) {
    make_contents(a1[1]);
  }
  unsigned int v15 = rb_blend_mode(a2);
  int v16 = v15;
  BOOL v17 = a9 != 0.0 || *(unsigned char *)(v14 + 288) == 0;
  if (v17 || (uint64_t result = (RB::DisplayList::Builder *)RB::may_discard_alpha(v15), (result & 1) == 0))
  {
    double v19 = (RB::DisplayList::Builder *)(v14 + 16);
    double v20 = (float32x2_t *)RB::DisplayList::Builder::culling_bounds(v19, (RB::DisplayList::State *)a1);
    v25.f64[0] = a5;
    v25.f64[1] = a6;
    float32x2_t v26 = vcvt_f32_f64(v25);
    v27.f64[0] = a7;
    v27.f64[1] = a8;
    float32x2_t v28 = vcvt_f32_f64(v27);
    *(float32x2_t *)&long long v33 = v26;
    *((float32x2_t *)&v33 + 1) = v28;
    if (!v20) {
      return RB::DisplayList::Builder::draw_custom((uint64_t)v19, a4, a3, &v33, (__n128 *)a1, v16, a9);
    }
    uint64_t result = (RB::DisplayList::Builder *)RB::Rect::intersects(v20, v21, v26, v28, a7, v22, v23, v24);
    if (result) {
      return RB::DisplayList::Builder::draw_custom((uint64_t)v19, a4, a3, &v33, (__n128 *)a1, v16, a9);
    }
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddPredicateStyle(__n128 *this, uint64_t a2)
{
  uint64_t v4 = (void *)this->n128_u64[1];
  if (!v4[3]) {
    make_contents(this->n128_i64[1]);
  }
  if (a2) {
    BOOL v5 = (char *)(a2 + 8);
  }
  else {
    BOOL v5 = 0;
  }
  RB::DisplayList::State::add_predicate(this, (RB::DisplayList::Builder *)(v4 + 2), (const RB::DisplayList::Predicate *)v5, v5[40]);
  uint64_t result = (RB::XML::DisplayList *)v4[38];
  if (result)
  {
    RB::XML::DisplayList::add_predicate_style(result, (RB::XML::Document *)this, (_RBDrawingState *)v5, v6);
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddTransformStyle(__n128 *this, uint64_t a2)
{
  uint64_t v4 = (void *)this->n128_u64[1];
  if (!v4[3]) {
    make_contents(this->n128_i64[1]);
  }
  if (a2) {
    BOOL v5 = (const RB::DisplayList::Transform *)(a2 + 8);
  }
  else {
    BOOL v5 = 0;
  }
  RB::DisplayList::State::add_transform(this, (RB::DisplayList::Builder *)(v4 + 2), v5);
  uint64_t result = (RB::XML::DisplayList *)v4[38];
  if (result)
  {
    RB::XML::DisplayList::add_transform_style(result, (RB::XML::Document *)this, (_RBDrawingState *)v5, v6);
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddAnimationStyle2(__n128 *a1, const RB::Animation *a2, uint64_t a3, uint64_t a4, const UUID *a5)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  *(void *)src = a3;
  uint64_t v12 = a4;
  float v8 = (void *)a1->n128_u64[1];
  if (!v8[3]) {
    make_contents(a1->n128_i64[1]);
  }
  uuid_copy(dst, src);
  if (a2) {
    a2 = (const RB::Animation *)-[RBAnimation rb_animation]((uint64_t)a2);
  }
  RB::DisplayList::State::add_animation(a1, (RB::DisplayList::Builder *)(v8 + 2), a2, (UUID *)dst, (int)a5);
  uint64_t result = (RB::XML::DisplayList *)v8[38];
  if (result) {
    RB::XML::DisplayList::add_animation_style(result, (RB::XML::Document *)a1, (_RBDrawingState *)a2, (const RB::Animation *)dst, a5);
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddAnimationStyle(__n128 *a1, const RB::Animation *a2, uint64_t a3, uint64_t a4)
{
  return RBDrawingStateAddAnimationStyle2(a1, a2, a3, a4, (const UUID *)0x111);
}

RB::XML::Document *RBDrawingStateAddShadowStyle3(__n128 *a1, unsigned int a2, unsigned int a3, char a4, double a5, float a6, float64_t a7, float64_t a8, float a9, float a10, float a11, float a12)
{
  _S10 = a12;
  _S11 = a11;
  _S12 = a10;
  _S13 = a9;
  float64_t v46 = a7;
  float64_t v47 = a8;
  float v42 = a9;
  float v43 = a10;
  float v44 = a11;
  float v45 = a12;
  double v22 = (void *)a1->n128_u64[1];
  if (!v22[3]) {
    make_contents(a1->n128_i64[1]);
  }
  LOWORD(v23) = rb_color_space(a2);
  LOBYTE(v24) = BYTE1(v23);
  if (!BYTE1(v23))
  {
    unsigned int v23 = a1[9].n128_u16[6];
    unsigned int v24 = v23 >> 8;
  }
  __asm
  {
    FCVT            H0, S13
    FCVT            H1, S12
    FCVT            H2, S11
    FCVT            H3, S10
  }
  LOWORD(v40) = _H0;
  WORD1(v40) = _H1;
  WORD2(v40) = _H2;
  HIWORD(v40) = _H3;
  __int16 v41 = v23 | (v24 << 8);
  v34.f64[0] = a7;
  v34.f64[1] = a8;
  double v35 = COERCE_DOUBLE(vcvt_f32_f64(v34));
  int v36 = rb_blend_mode(a3);
  float v33 = a5;
  RB::DisplayList::State::add_shadow(a1, (RB::DisplayList::Builder *)(v22 + 2), &v40, v36, a4 & 0x1F, v33, a6, v35);
  uint64_t result = (RB::XML::Document *)v22[38];
  if (result) {
    RB::XML::DisplayList::add_shadow_style(result);
  }
  return result;
}

RB::XML::Document *RBDrawingStateAddShadowStyle2(__n128 *a1, unsigned int a2, unsigned int a3, char a4, double a5, float64_t a6, float64_t a7, float a8, float a9, float a10, float a11)
{
  return RBDrawingStateAddShadowStyle3(a1, a2, a3, a4, a5, 0.5, a6, a7, a8, a9, a10, a11);
}

RB::XML::Document *RBDrawingStateAddShadowStyle(__n128 *a1, unsigned int a2, char a3, double a4, float64_t a5, float64_t a6, float a7, float a8, float a9, float a10)
{
  return RBDrawingStateAddShadowStyle3(a1, 0, a2, a3, a4, 0.5, a5, a6, a7, a8, a9, a10);
}

RB::XML::DisplayList *RBDrawingStateAddProjectionStyle(__n128 *this, RB::ProjectionMatrix *a2)
{
  uint64_t v4 = (void *)this->n128_u64[1];
  if (!v4[3]) {
    make_contents(this->n128_i64[1]);
  }
  RB::DisplayList::State::add_projection_matrix(this, (RB::DisplayList::Builder *)(v4 + 2), a2);
  uint64_t result = (RB::XML::DisplayList *)v4[38];
  if (result)
  {
    RB::XML::DisplayList::add_projection_style(result, (RB::XML::Document *)this, (_RBDrawingState *)a2, v5);
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddRotationStyle(__n128 *a1, double a2, float64_t a3, float64_t a4)
{
  uint64_t v6 = a1->n128_i64[1];
  double v10 = a3;
  double v11 = a4;
  if (!*(void *)(v6 + 24))
  {
    make_contents(v6);
    a3 = v10;
    a4 = v11;
  }
  v7.f64[0] = a3;
  v7.f64[1] = a4;
  v12.n128_f64[0] = a2;
  *(float32x2_t *)&v12.n128_i8[8] = vcvt_f32_f64(v7);
  RB::DisplayList::State::add_geometry_style<RB::GeometryStyle::Rotation>(a1, v6 + 16, &v12);
  uint64_t result = *(RB::XML::DisplayList **)(v6 + 304);
  if (result)
  {
    v13.double x = v10;
    v13.double y = v11;
    RB::XML::DisplayList::add_rotation_style(result, (RB::XML::Document *)a1, v8, a2, v13);
  }
  return result;
}

double RB::DisplayList::State::add_geometry_style<RB::GeometryStyle::Rotation>(__n128 *a1, uint64_t a2, __n128 *a3)
{
  if (!*(unsigned char *)(a2 + 272) || (double result = a3->n128_f64[0], a3->n128_f64[0] != 0.0))
  {
    RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>,RB::GeometryStyle::Rotation>((RB::Heap *)(*(void *)(a2 + 8) + 16), a3);
    *(void *)&double result = RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)a2, v6).n128_u64[0];
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddScaleStyle(__n128 *a1, float64x2_t a2, float64_t a3, float64_t a4, float64_t a5)
{
  uint64_t v6 = a1->n128_i64[1];
  double v12 = a4;
  double v13 = a5;
  unint64_t v10 = *(void *)&a2.f64[0];
  double v11 = a3;
  if (!*(void *)(v6 + 24))
  {
    make_contents(v6);
    *(void *)&a2.f64[0] = v10;
    a3 = v11;
    a4 = v12;
    a5 = v13;
  }
  a2.f64[1] = a3;
  v7.f64[0] = a4;
  v7.f64[1] = a5;
  v14[0] = vcvt_f32_f64(a2);
  v14[1] = vcvt_f32_f64(v7);
  RB::DisplayList::State::add_geometry_style<RB::GeometryStyle::Scale>(a1, v6 + 16, v14);
  double result = *(RB::XML::DisplayList **)(v6 + 304);
  if (result)
  {
    *(void *)&v15.double width = v10;
    v15.double height = v11;
    v16.double x = v12;
    v16.double y = v13;
    RB::XML::DisplayList::add_scale_style(result, (RB::XML::Document *)a1, v8, v15, v16);
  }
  return result;
}

uint32x2_t RB::DisplayList::State::add_geometry_style<RB::GeometryStyle::Scale>(__n128 *a1, uint64_t a2, float32x2_t *a3)
{
  if (!*(unsigned char *)(a2 + 272)) {
    goto LABEL_3;
  }
  __asm { FMOV            V1.2S, #1.0 }
  uint32x2_t v10 = (uint32x2_t)vceq_f32(*a3, _D1);
  uint32x2_t result = vpmin_u32(v10, v10);
  if ((result.i32[0] & 0x80000000) == 0)
  {
LABEL_3:
    RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>,RB::GeometryStyle::Scale>((RB::Heap *)(*(void *)(a2 + 8) + 16), (__n128 *)a3);
    return (uint32x2_t)RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)a2, v12).n128_u64[0];
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddTranslationStyle(__n128 *a1, float64x2_t a2, float64_t a3)
{
  uint64_t v4 = a1->n128_i64[1];
  unint64_t v7 = *(void *)&a2.f64[0];
  double v8 = a3;
  if (!*(void *)(v4 + 24))
  {
    make_contents(v4);
    *(void *)&a2.f64[0] = v7;
    a3 = v8;
  }
  a2.f64[1] = a3;
  float32x2_t v9 = vcvt_f32_f64(a2);
  RB::DisplayList::State::add_geometry_style<RB::GeometryStyle::Translation>(a1, v4 + 16, &v9);
  uint32x2_t result = *(RB::XML::DisplayList **)(v4 + 304);
  if (result)
  {
    *(void *)&v10.double width = v7;
    v10.double height = v8;
    RB::XML::DisplayList::add_translation_style(result, (RB::XML::Document *)a1, v5, v10);
  }
  return result;
}

uint32x2_t RB::DisplayList::State::add_geometry_style<RB::GeometryStyle::Translation>(__n128 *a1, uint64_t a2, float32x2_t *a3)
{
  if (!*(unsigned char *)(a2 + 272)
    || (uint32x2_t v5 = (uint32x2_t)vceqz_f32(*a3), result = vpmin_u32(v5, v5), (result.i32[0] & 0x80000000) == 0))
  {
    RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>,RB::GeometryStyle::Translation>((RB::Heap *)(*(void *)(a2 + 8) + 16), a3);
    return (uint32x2_t)RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)a2, v7).n128_u64[0];
  }
  return result;
}

RB::XML::Document *RBDrawingStateAddRotation3DStyle(__n128 *a1, double a2, __n128 a3, float a4, float a5, __n128 a6, float a7, float a8, double a9, double a10)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  uint64_t v20 = a1->n128_i64[1];
  float v30 = a7;
  float v31 = a8;
  float v28 = a5;
  __n128 v29 = a6;
  __n128 v26 = a3;
  float v27 = a4;
  if (!*(void *)(v20 + 24))
  {
    make_contents(v20);
    a3 = v26;
    a4 = v27;
    a5 = v28;
    a6 = v29;
    a7 = v30;
    a8 = v31;
  }
  __n128 v21 = a3;
  v21.n128_f32[1] = a4;
  v21.n128_f32[2] = a5;
  __n128 v22 = a6;
  v22.n128_f32[1] = a7;
  v22.n128_f32[2] = a8;
  float v23 = a9;
  float v24 = a10;
  v32[0] = a2;
  __n128 v33 = v21;
  __n128 v34 = v22;
  float v35 = v23;
  float v36 = v24;
  RB::DisplayList::State::add_geometry_style<RB::GeometryStyle::Rotation3D>(a1, v20 + 16, v32);
  uint32x2_t result = *(RB::XML::Document **)(v20 + 304);
  if (result) {
    RB::XML::DisplayList::add_rotation3d_style(result);
  }
  return result;
}

double RB::DisplayList::State::add_geometry_style<RB::GeometryStyle::Rotation3D>(__n128 *a1, uint64_t a2, double *a3)
{
  if (!*(unsigned char *)(a2 + 272) || (double result = *a3, *a3 != 0.0))
  {
    RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>,RB::GeometryStyle::Rotation3D>((RB::Heap *)(*(void *)(a2 + 8) + 16), (uint64_t)a3);
    *(void *)&double result = RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)a2, v6).n128_u64[0];
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddAffineTransformStyle(__n128 *a1, float64x2_t *a2)
{
  unint64_t v4 = a1->n128_u64[1];
  if (!*(void *)(v4 + 24)) {
    make_contents(a1->n128_i64[1]);
  }
  float64x2_t v5 = a2[1];
  float64x2_t v6 = a2[2];
  v10[0] = *a2;
  v10[1] = v5;
  float64x2_t v10[2] = v6;
  v9[0] = (float64x2_t)v10[0];
  v9[1] = v5;
  uint64_t v9[2] = v6;
  RB::DisplayList::State::add_geometry_style<RB::GeometryStyle::Affine>(a1, v4 + 16, v9);
  double result = *(RB::XML::DisplayList **)(v4 + 304);
  if (result) {
    RB::XML::DisplayList::add_affine_transform_style(result, (RB::XML::Document *)a1, (_RBDrawingState *)v10, v7);
  }
  return result;
}

double RB::DisplayList::State::add_geometry_style<RB::GeometryStyle::Affine>(__n128 *a1, uint64_t a2, float64x2_t *a3)
{
  if (!*(unsigned char *)(a2 + 272)
    || (int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(a3[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*a3, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(a3[2])), *(void *)&result = vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0], (*(void *)&result & 0x8000000000000000) == 0))
  {
    RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>,RB::GeometryStyle::Affine>((RB::Heap *)(*(void *)(a2 + 8) + 16), (uint64_t)a3);
    *(void *)&double result = RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)a2, v7).n128_u64[0];
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddPathProjectionStyle(RB::XML::Document *a1, char *a2, void *a3, uint64_t a4, const RB::AffineTransform *a5, __n128 a6, double a7, double a8, double a9)
{
  if (a6.n128_f64[0] == a8 && a7 == a9) {
    RB::precondition_failure((RB *)"invalid zero-length vector: (%f, %f), (%f, %f)", a2, a6.n128_u64[0], *(void *)&a7, *(void *)&a8, *(void *)&a9);
  }
  CGSize v15 = (void *)*((void *)a1 + 1);
  double v26 = a8;
  double v27 = a9;
  unint64_t v24 = a6.n128_u64[0];
  double v25 = a7;
  if (!v15[3])
  {
    make_contents((uint64_t)v15);
    a6.n128_u64[0] = v24;
    a7 = v25;
    a8 = v26;
    a9 = v27;
  }
  a6.n128_f64[1] = a7;
  v16.n128_f64[0] = a8;
  v16.n128_f64[1] = a9;
  long long v17 = *(_OWORD *)(a4 + 16);
  CGPoint v18 = *(CGPoint *)(a4 + 32);
  float64x2_t v28 = *(float64x2_t *)a4;
  long long v29 = v17;
  CGPoint v30 = v18;
  RB::DisplayList::State::add_path_projection((uint64_t)a1, (RB::DisplayList::Builder *)(v15 + 2), (uint64_t)a2, (uint64_t)a3, &v28, (int)a5, a6, v16);
  double result = (RB::XML::DisplayList *)v15[38];
  if (result)
  {
    long long v20 = *(_OWORD *)(a4 + 16);
    CGPoint v21 = *(CGPoint *)(a4 + 32);
    float64x2_t v28 = *(float64x2_t *)a4;
    long long v29 = v20;
    CGPoint v30 = v21;
    v31.callbacks = (RBPathCallbacks *)&v28;
    unint64_t v22 = v24;
    *(double *)&long long v20 = v25;
    v21.double x = v26;
    double v23 = v27;
    v31.mach_timebase_info info = a3;
    RB::XML::DisplayList::add_path_projection_style(result, a1, (_RBDrawingState *)a2, *(CGPoint *)((char *)&v20 - 8), v21, v31, a5);
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddBlurFilter(__n128 *a1, _RBDrawingState *a2, double a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7)
{
  uint64_t v10 = a1->n128_i64[1];
  double v21 = a6;
  double v22 = a7;
  double v19 = a4;
  double v20 = a5;
  if (!*(void *)(v10 + 24))
  {
    make_contents(v10);
    a4 = v19;
    a5 = v20;
    a6 = v21;
    a7 = v22;
  }
  float32x2_t v25 = 0;
  float32x2_t v26 = 0;
  v27.origin.double x = a4;
  v27.origin.double y = a5;
  v27.size.double width = a6;
  v27.size.double height = a7;
  BOOL IsInfinite = CGRectIsInfinite(v27);
  double v12 = 0;
  if (!IsInfinite)
  {
    v28.origin.double x = v19;
    v28.origin.double y = v20;
    v28.size.double width = v21;
    v28.size.double height = v22;
    if (CGRectIsNull(v28))
    {
      double v12 = 0;
    }
    else
    {
      v13.f64[0] = v19;
      v13.f64[1] = v20;
      v14.f64[0] = v21;
      v14.f64[1] = v22;
      float32x2_t v25 = vcvt_f32_f64(v13);
      float32x2_t v26 = vcvt_f32_f64(v14);
      double v12 = (const RB::Rect *)&v25;
    }
  }
  float v15 = a3;
  RB::Filter::GaussianBlur::GaussianBlur((uint64_t)v23, v15, 0, v12, (int)a2);
  double v16 = RB::DisplayList::State::add_filter_style<RB::Filter::GaussianBlur>(a1, v10 + 16, v23);
  long long v17 = v24;
  unint64_t v24 = 0;
  if (v17) {
    (**v17)(v17, v16);
  }
  double result = *(RB::XML::DisplayList **)(v10 + 304);
  if (result)
  {
    v29.origin.double x = v19;
    v29.origin.double y = v20;
    v29.size.double width = v21;
    v29.size.double height = v22;
    RB::XML::DisplayList::add_blur_filter(result, (RB::XML::Document *)a1, a2, a3, v29);
  }
  return result;
}

void sub_21415FB40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  if (a22) {
    RBDrawingStateAddBlurFilter_cold_1();
  }
  _Unwind_Resume(exception_object);
}

double RB::DisplayList::State::add_filter_style<RB::Filter::GaussianBlur>(__n128 *a1, uint64_t a2, _DWORD *a3)
{
  if (!*(unsigned char *)(a2 + 272) || (LODWORD(result) = *a3, *(float *)a3 > 0.0))
  {
    RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>,RB::Filter::GaussianBlur>((RB::Heap *)(*(void *)(a2 + 8) + 16), (uint64_t)a3);
    *(void *)&double result = RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)a2, v6).n128_u64[0];
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddVariableBlurFilter(uint64_t a1, _RBDrawingState *a2, RBFill *a3, double a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  double v12 = *(void **)(a1 + 8);
  double v29 = a7;
  double v30 = a8;
  double v27 = a5;
  double v28 = a6;
  if (!v12[3])
  {
    make_contents((uint64_t)v12);
    a5 = v27;
    a6 = v28;
    a7 = v29;
    a8 = v30;
  }
  float32x2_t v42 = 0;
  float32x2_t v43 = 0;
  v44.origin.double x = a5;
  v44.origin.double y = a6;
  v44.size.double width = a7;
  v44.size.double height = a8;
  BOOL IsInfinite = CGRectIsInfinite(v44);
  float64x2_t v14 = 0;
  if (!IsInfinite)
  {
    v45.origin.double x = v27;
    v45.origin.double y = v28;
    v45.size.double width = v29;
    v45.size.double height = v30;
    BOOL IsInfinite = CGRectIsNull(v45);
    if (IsInfinite)
    {
      float64x2_t v14 = 0;
    }
    else
    {
      v15.f64[0] = v27;
      v15.f64[1] = v28;
      v16.f64[0] = v29;
      v16.f64[1] = v30;
      float32x2_t v42 = vcvt_f32_f64(v15);
      float32x2_t v43 = vcvt_f32_f64(v16);
      float64x2_t v14 = (const RB::Rect *)&v42;
    }
  }
  uint64_t v17 = v12[3] + 16;
  CGPoint v18 = RB::AffineTransform::identity((RB::AffineTransform *)IsInfinite);
  __int16 v19 = *(_WORD *)(a1 + 156);
  v36[0] = v17;
  v36[1] = v18;
  v36[2] = 0x23F800000;
  __int16 v37 = v19;
  uint64_t v38 = -[RBShape shapeData]((uint64_t)a2);
  uint64_t v39 = RB::DisplayList::Builder::culling_bounds((RB::DisplayList::Builder *)(v12 + 2), (RB::DisplayList::State *)a1);
  char v40 = 0;
  __int16 v41 = 0;
  memset(v31, 0, sizeof(v31));
  uint64_t v32 = 1065353216;
  int v33 = 0;
  __int16 v34 = 1;
  char v35 = 0;
  RB::DisplayList::ItemFactory::operator()<RB::Coverage::Primitive>((uint64_t)v36, (float32x2_t *)v31, COERCE_DOUBLE(1065353216), v20, v21, v22);
  float v23 = a4;
  RB::Filter::GaussianBlur::GaussianBlur((uint64_t)v31, v23, v41, v14, (int)a3);
  double v24 = RB::DisplayList::State::add_filter_style<RB::Filter::GaussianBlur>((__n128 *)a1, (uint64_t)(v12 + 2), v31);
  float32x2_t v25 = (void (***)(void, double))v32;
  uint64_t v32 = 0;
  if (v25) {
    (**v25)(v25, v24);
  }
  double result = (RB::XML::DisplayList *)v12[38];
  if (result)
  {
    v46.origin.double x = v27;
    v46.origin.double y = v28;
    v46.size.double width = v29;
    v46.size.double height = v30;
    RB::XML::DisplayList::add_variable_blur_filter(result, (RB::XML::Document *)a1, a2, a4, a3, v46);
  }
  return result;
}

void sub_21415FE08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  if (a21) {
    RBDrawingStateAddBlurFilter_cold_1();
  }
  _Unwind_Resume(exception_object);
}

RB::XML::DisplayList *RBDrawingStateAddVariableBlurLayer(__n128 *a1, RB::DisplayList::State *a2, _RBDrawingState *a3, float a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  unint64_t v20 = a1->n128_u64[1];
  if (!*(void *)(v20 + 24)) {
    make_contents(a1->n128_i64[1]);
  }
  int8x16_t v21 = (RB::DisplayList::Builder *)(v20 + 16);
  int32x4_t v22 = (RB::DisplayList::Layer *)RB::DisplayList::Builder::end_layer(v21, a2);
  RB::DisplayList::Builder::delete_state((atomic_uint *)v21, a2);
  double v23 = a7;
  double v24 = a8;
  double v25 = a9;
  double v26 = a10;
  return add_variable_blur_layer(a1, v22, a5, a4, a6, *(CGRect *)&v23, a3);
}

RB::XML::DisplayList *add_variable_blur_layer(__n128 *a1, RB::DisplayList::Layer *a2, double a3, float a4, double a5, CGRect a6, _RBDrawingState *a7)
{
  float64x2_t v13 = (void *)a1->n128_u64[1];
  float64_t width = a6.size.width;
  float64_t height = a6.size.height;
  float64_t x = a6.origin.x;
  float64_t y = a6.origin.y;
  if (!v13[3])
  {
    make_contents((uint64_t)v13);
    a6.origin.float64_t x = x;
    a6.origin.float64_t y = y;
    a6.size.float64_t width = width;
    a6.size.float64_t height = height;
  }
  float32x2_t v32 = 0;
  float32x2_t v33 = 0;
  float64x2_t v14 = 0;
  if (!CGRectIsInfinite(a6))
  {
    v34.origin.float64_t x = x;
    v34.origin.float64_t y = y;
    v34.size.float64_t width = width;
    v34.size.float64_t height = height;
    if (CGRectIsNull(v34))
    {
      float64x2_t v14 = 0;
    }
    else
    {
      v15.f64[0] = x;
      v15.f64[1] = y;
      v16.f64[0] = width;
      v16.f64[1] = height;
      float32x2_t v32 = vcvt_f32_f64(v15);
      float32x2_t v33 = vcvt_f32_f64(v16);
      float64x2_t v14 = (const RB::Rect *)&v32;
    }
  }
  float64x2_t v17 = (float64x2_t)a1[2];
  v31[0] = (float64x2_t)a1[1];
  v31[1] = v17;
  _OWORD v31[2] = (float64x2_t)a1[3];
  RB::AffineTransform::invert((RB::AffineTransform *)v31);
  double v18 = 0.125;
  if (a3 != 0.0) {
    double v18 = a3;
  }
  float v19 = v18;
  layer_item = RB::DisplayList::Builder::make_layer_item((RB::DisplayList::Builder *)(v13 + 2), a2, 2, v31, a4, v19);
  float v21 = a5;
  RB::Filter::GaussianBlur::GaussianBlur((uint64_t)v29, v21, (RB::DisplayList::Item *)layer_item, v14, (int)a7);
  double v22 = RB::DisplayList::State::add_filter_style<RB::Filter::GaussianBlur>(a1, (uint64_t)(v13 + 2), v29);
  double v23 = v30;
  double v30 = 0;
  if (v23) {
    (**v23)(v23, v22);
  }
  double result = (RB::XML::DisplayList *)v13[38];
  if (result)
  {
    v35.origin.float64_t x = x;
    v35.origin.float64_t y = y;
    v35.size.float64_t width = width;
    v35.size.float64_t height = height;
    RB::XML::DisplayList::add_variable_blur_layer(result, (_RBDrawingState *)a1, a7, a3, a4, a5, v35);
  }
  return result;
}

void sub_2141600C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  if (a22) {
    RBDrawingStateAddBlurFilter_cold_1();
  }
  _Unwind_Resume(exception_object);
}

RB::XML::Document *RBDrawingStateAddAlphaThresholdFilter2(__n128 *a1, unsigned int a2, float a3, float a4, float a5, float a6, float a7, float a8)
{
  _S8 = a8;
  _S9 = a7;
  _S10 = a6;
  _S11 = a5;
  float64x2_t v14 = (void *)a1->n128_u64[1];
  if (!v14[3]) {
    make_contents(a1->n128_i64[1]);
  }
  LOWORD(v15) = rb_color_space(a2);
  LOWORD(v20) = BYTE1(v15);
  if (!BYTE1(v15))
  {
    unsigned int v15 = a1[9].n128_u16[6];
    unsigned int v20 = v15 >> 8;
  }
  __asm
  {
    FCVT            H1, S11
    FCVT            H2, S10
    FCVT            H3, S9
    FCVT            H4, S8
  }
  RB::DisplayList::State::add_alpha_threshold(a1, (RB::DisplayList::Builder *)(v14 + 2), ((unint64_t)_S3 << 32) | ((unint64_t)_S4 << 48) | ((unint64_t)_S2 << 16) | _S1, v15 | (unsigned __int16)((_WORD)v20 << 8), COERCE_DOUBLE(__PAIR64__(LODWORD(a4), LODWORD(a3))));
  double result = (RB::XML::Document *)v14[38];
  if (result)
  {
    RB::XML::DisplayList::add_alpha_threshold_filter(result);
  }
  return result;
}

RB::XML::Document *RBDrawingStateAddAlphaThresholdFilter(__n128 *a1, float a2, float a3, float a4, float a5, float a6, float a7)
{
  return RBDrawingStateAddAlphaThresholdFilter2(a1, 0, a2, a3, a4, a5, a6, a7);
}

uint64_t RBDrawingStateAddAlphaGradientFilter2(__n128 *a1, unint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, int a6)
{
  double v12 = (void *)a1->n128_u64[1];
  if (!v12[3]) {
    make_contents(a1->n128_i64[1]);
  }
  unsigned __int16 v13 = rb_color_space(a4);
  RB::DisplayList::State::add_alpha_gradient(a1, (RB::DisplayList::Builder *)(v12 + 2), a2, a3, v13, a5, a6);
  uint64_t result = v12[38];
  if (result)
  {
    RB::XML::DisplayList::add_alpha_gradient_filter(result, (uint64_t)a1);
  }
  return result;
}

uint64_t RBDrawingStateAddAlphaGradientFilter(__n128 *a1, unint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  return RBDrawingStateAddAlphaGradientFilter2(a1, a2, a3, 0, a4, a5);
}

RB::XML::DisplayList *RBDrawingStateAddDistanceFilter(__n128 *a1, _RBDrawingState *a2, double a3, double a4)
{
  double v8 = (void *)a1->n128_u64[1];
  uint64_t v9 = v8[3];
  if (!v9)
  {
    make_contents(a1->n128_i64[1]);
    uint64_t v9 = v8[3];
  }
  *(float *)&unsigned int v10 = a3;
  *(float *)&unsigned int v11 = a4;
  unint64_t v14 = __PAIR64__(v11, v10);
  int v15 = (int)a2;
  RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::Distance>,RB::Filter::Distance>((RB::Heap *)(v9 + 16), (uint64_t *)&v14);
  RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)(v8 + 2), v12);
  uint64_t result = (RB::XML::DisplayList *)v8[38];
  if (result) {
    RB::XML::DisplayList::add_distance_filter(result, (RB::XML::Document *)a1, a2, a3, a4);
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddColorMatrixFilter(__n128 *a1, float *a2, const float *a3)
{
  unint64_t v6 = a1->n128_u64[1];
  if (!*(void *)(v6 + 24)) {
    make_contents(a1->n128_i64[1]);
  }
  RB::ColorMatrix::set_color_matrix((float16x4_t *)v12, a2);
  v8.i32[0] = (int)a3;
  long long v9 = v12[0];
  long long v10 = v12[1];
  uint64_t v11 = v13;
  RB::DisplayList::State::add_filter_style<RB::Filter::ColorMatrix>(a1, v6 + 16, &v8);
  uint64_t result = *(RB::XML::DisplayList **)(v6 + 304);
  if (result) {
    RB::XML::DisplayList::add_color_matrix_filter(result, (RB::XML::Document *)a1, (_RBDrawingState *)a2, a3);
  }
  return result;
}

double RB::DisplayList::State::add_filter_style<RB::Filter::ColorMatrix>(__n128 *a1, uint64_t a2, float16x4_t *a3)
{
  if (!*(unsigned char *)(a2 + 272) || (RB::ColorMatrix::is_identity(a3 + 1) & 1) == 0)
  {
    RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::ColorMatrix>,RB::Filter::ColorMatrix>((RB::Heap *)(*(void *)(a2 + 8) + 16), (uint64_t)a3);
    *(void *)&double result = RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)a2, v7).n128_u64[0];
  }
  return result;
}

RB::XML::Document *RBDrawingStateAddColorMultiplyFilter2(__n128 *a1, unsigned int a2, int a3, float a4, float a5, float a6, float a7)
{
  unint64_t v14 = (void *)a1->n128_u64[1];
  if (!v14[3]) {
    make_contents(a1->n128_i64[1]);
  }
  v18.n128_u32[0] = a3 & 0xFFFFFFFB;
  *(unint64_t *)((char *)v18.n128_u64 + 4) = color_filter_color(a2, a3 & 0xFFFFFFFB, (uint64_t)a1, a4, a5, a6, a7);
  v18.n128_u16[6] = v15;
  RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>,RB::ColorStyle::ColorMultiply>((RB::Heap *)(v14[3] + 16), &v18);
  RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)(v14 + 2), v16);
  double result = (RB::XML::Document *)v14[38];
  if (result) {
    RB::XML::DisplayList::add_color_multiply_filter(result);
  }
  return result;
}

uint64_t color_filter_color(unsigned int a1, unsigned int a2, uint64_t a3, float a4, float a5, float a6, float a7)
{
  _S8 = a7;
  _S9 = a6;
  _S10 = a5;
  _S11 = a4;
  int v13 = rb_color_space(a1);
  int v15 = BYTE1(v13);
  if (BYTE1(v13))
  {
    int v16 = v13;
  }
  else
  {
    int v15 = HIBYTE(*(unsigned __int16 *)(a3 + 156));
    int v16 = *(unsigned __int16 *)(a3 + 156);
  }
  __asm
  {
    FCVT            H0, S11
    FCVT            H1, S10
    FCVT            H2, S9
    FCVT            H3, S8
  }
  LOWORD(v27) = _D0.i16[0];
  WORD1(v27) = _H1;
  WORD2(v27) = _H2;
  HIWORD(v27) = _H3;
  __int16 v28 = v16 | (unsigned __int16)((_WORD)v15 << 8);
  if (v15)
  {
    unsigned __int8 v24 = v16 & 0xFE;
    int v25 = (a2 >> 1) & 1 | v16;
    if ((a2 & 1) == 0) {
      unsigned __int8 v24 = v25;
    }
    RB::Fill::Color::convert((uint64_t)&v27, v24, _D0);
  }
  return v27;
}

RB::XML::Document *RBDrawingStateAddColorMultiplyFilter(__n128 *a1, int a2, float a3, float a4, float a5, float a6)
{
  return RBDrawingStateAddColorMultiplyFilter2(a1, 0, a2, a3, a4, a5, a6);
}

RB::XML::Document *RBDrawingStateAddAlphaMultiplyFilter2(__n128 *a1, unsigned int a2, int a3, float a4, float a5, float a6, float a7)
{
  unint64_t v14 = (void *)a1->n128_u64[1];
  if (!v14[3]) {
    make_contents(a1->n128_i64[1]);
  }
  v18.n128_u32[0] = a3 & 0xFFFFFFFB;
  *(unint64_t *)((char *)v18.n128_u64 + 4) = color_filter_color(a2, a3 & 0xFFFFFFFB, (uint64_t)a1, a4, a5, a6, a7);
  v18.n128_u16[6] = v15;
  RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>,RB::ColorStyle::AlphaMultiply>((RB::Heap *)(v14[3] + 16), &v18);
  RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)(v14 + 2), v16);
  double result = (RB::XML::Document *)v14[38];
  if (result) {
    RB::XML::DisplayList::add_alpha_multiply_filter(result);
  }
  return result;
}

RB::XML::Document *RBDrawingStateAddAlphaMultiplyFilter(__n128 *a1, int a2, float a3, float a4, float a5, float a6)
{
  return RBDrawingStateAddAlphaMultiplyFilter2(a1, 0, a2, a3, a4, a5, a6);
}

RB::XML::DisplayList *RBDrawingStateAddHueRotationFilter(__n128 *a1, int a2, double a3)
{
  unint64_t v6 = a1->n128_u64[1];
  if (!*(void *)(v6 + 24)) {
    make_contents(a1->n128_i64[1]);
  }
  unint64_t v7 = (_RBDrawingState *)(a2 & 0xFFFFFFFB);
  float v8 = a3;
  v10[0] = v7;
  *(float *)&v10[1] = v8;
  RB::DisplayList::State::add_color_style<RB::ColorStyle::HueRotation>(a1, v6 + 16, (uint64_t)v10);
  double result = *(RB::XML::DisplayList **)(v6 + 304);
  if (result) {
    RB::XML::DisplayList::add_hue_rotation_filter(result, (RB::XML::Document *)a1, v7, a3);
  }
  return result;
}

double RB::DisplayList::State::add_color_style<RB::ColorStyle::HueRotation>(__n128 *a1, uint64_t a2, uint64_t a3)
{
  if (!*(unsigned char *)(a2 + 272) || (LODWORD(result) = *(_DWORD *)(a3 + 4), *(float *)&result != 0.0))
  {
    RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>,RB::ColorStyle::HueRotation>((RB::Heap *)(*(void *)(a2 + 8) + 16), (void *)a3);
    *(void *)&double result = RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)a2, v6).n128_u64[0];
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddSaturationFilter(__n128 *a1, int a2, float a3)
{
  unint64_t v6 = a1->n128_u64[1];
  if (!*(void *)(v6 + 24)) {
    make_contents(a1->n128_i64[1]);
  }
  unint64_t v7 = (_RBDrawingState *)(a2 & 0xFFFFFFFB);
  v9[0] = v7;
  *(float *)&v9[1] = a3;
  RB::DisplayList::State::add_color_style<RB::ColorStyle::Saturation>(a1, v6 + 16, (uint64_t)v9);
  double result = *(RB::XML::DisplayList **)(v6 + 304);
  if (result) {
    RB::XML::DisplayList::add_saturation_filter(result, (RB::XML::Document *)a1, v7, a3);
  }
  return result;
}

double RB::DisplayList::State::add_color_style<RB::ColorStyle::Saturation>(__n128 *a1, uint64_t a2, uint64_t a3)
{
  LODWORD(result) = *(_DWORD *)(a3 + 4);
  if (*(unsigned char *)(a2 + 272)) {
    BOOL v4 = *(float *)&result == 1.0;
  }
  else {
    BOOL v4 = 0;
  }
  if (!v4)
  {
    RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>,RB::ColorStyle::Saturation>((RB::Heap *)(*(void *)(a2 + 8) + 16), (void *)a3);
    *(void *)&double result = RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)a2, v7).n128_u64[0];
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddBrightnessFilter(__n128 *a1, int a2, float a3)
{
  unint64_t v6 = a1->n128_u64[1];
  if (!*(void *)(v6 + 24)) {
    make_contents(a1->n128_i64[1]);
  }
  unint64_t v7 = (_RBDrawingState *)(a2 & 0xFFFFFFFB);
  v9[0] = v7;
  *(float *)&v9[1] = a3;
  RB::DisplayList::State::add_color_style<RB::ColorStyle::Brightness>(a1, v6 + 16, (uint64_t)v9);
  double result = *(RB::XML::DisplayList **)(v6 + 304);
  if (result) {
    RB::XML::DisplayList::add_brightness_filter(result, (RB::XML::Document *)a1, v7, a3);
  }
  return result;
}

double RB::DisplayList::State::add_color_style<RB::ColorStyle::Brightness>(__n128 *a1, uint64_t a2, uint64_t a3)
{
  if (!*(unsigned char *)(a2 + 272) || (LODWORD(result) = *(_DWORD *)(a3 + 4), *(float *)&result != 0.0))
  {
    RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>,RB::ColorStyle::Brightness>((RB::Heap *)(*(void *)(a2 + 8) + 16), (void *)a3);
    *(void *)&double result = RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)a2, v6).n128_u64[0];
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddContrastFilter(__n128 *a1, int a2, float a3)
{
  unint64_t v6 = a1->n128_u64[1];
  if (!*(void *)(v6 + 24)) {
    make_contents(a1->n128_i64[1]);
  }
  unint64_t v7 = (_RBDrawingState *)(a2 & 0xFFFFFFFB);
  v9[0] = v7;
  *(float *)&v9[1] = a3;
  RB::DisplayList::State::add_color_style<RB::ColorStyle::Contrast>(a1, v6 + 16, (uint64_t)v9);
  double result = *(RB::XML::DisplayList **)(v6 + 304);
  if (result) {
    RB::XML::DisplayList::add_contrast_filter(result, (RB::XML::Document *)a1, v7, a3);
  }
  return result;
}

double RB::DisplayList::State::add_color_style<RB::ColorStyle::Contrast>(__n128 *a1, uint64_t a2, uint64_t a3)
{
  LODWORD(result) = *(_DWORD *)(a3 + 4);
  if (*(unsigned char *)(a2 + 272)) {
    BOOL v4 = *(float *)&result == 1.0;
  }
  else {
    BOOL v4 = 0;
  }
  if (!v4)
  {
    RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>,RB::ColorStyle::Contrast>((RB::Heap *)(*(void *)(a2 + 8) + 16), (void *)a3);
    *(void *)&double result = RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)a2, v7).n128_u64[0];
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddLuminanceToAlphaFilter(__n128 *a1, int a2)
{
  BOOL v4 = (void *)a1->n128_u64[1];
  uint64_t v5 = v4[3];
  if (!v5)
  {
    make_contents(a1->n128_i64[1]);
    uint64_t v5 = v4[3];
  }
  unint64_t v6 = (_RBDrawingState *)(a2 & 0xFFFFFFFB);
  int v9 = (int)v6;
  RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>,RB::ColorStyle::LuminanceToAlpha>((RB::Heap *)(v5 + 16), &v9);
  RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)(v4 + 2), v7);
  double result = (RB::XML::DisplayList *)v4[38];
  if (result) {
    RB::XML::DisplayList::add_luminance_to_alpha_filter(result, (RB::XML::Document *)a1, v6);
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddColorInvertFilter(__n128 *a1, int a2, float a3)
{
  unint64_t v6 = a1->n128_u64[1];
  if (!*(void *)(v6 + 24)) {
    make_contents(a1->n128_i64[1]);
  }
  unint64_t v7 = (_RBDrawingState *)(a2 & 0xFFFFFFFB);
  v9[0] = v7;
  *(float *)&v9[1] = a3;
  RB::DisplayList::State::add_color_style<RB::ColorStyle::ColorInvert>(a1, v6 + 16, (uint64_t)v9);
  double result = *(RB::XML::DisplayList **)(v6 + 304);
  if (result) {
    RB::XML::DisplayList::add_color_invert_filter(result, (RB::XML::Document *)a1, v7, a3);
  }
  return result;
}

double RB::DisplayList::State::add_color_style<RB::ColorStyle::ColorInvert>(__n128 *a1, uint64_t a2, uint64_t a3)
{
  if (!*(unsigned char *)(a2 + 272) || (LODWORD(result) = *(_DWORD *)(a3 + 4), *(float *)&result != 0.0))
  {
    RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>,RB::ColorStyle::ColorInvert>((RB::Heap *)(*(void *)(a2 + 8) + 16), (void *)a3);
    *(void *)&double result = RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)a2, v6).n128_u64[0];
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddGrayscaleFilter(__n128 *a1, int a2, float a3)
{
  unint64_t v6 = (void *)a1->n128_u64[1];
  uint64_t v7 = v6[3];
  if (!v7)
  {
    make_contents(a1->n128_i64[1]);
    uint64_t v7 = v6[3];
  }
  float v8 = (_RBDrawingState *)(a2 & 0xFFFFFFFB);
  v11.n128_u32[0] = v8;
  *(unint64_t *)((char *)v11.n128_u64 + 4) = 0x3C003C003C003C00;
  v11.n128_u16[6] = 0;
  float v12 = a3;
  int v13 = 0;
  RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>,RB::ColorStyle::ColorMonochrome>((RB::Heap *)(v7 + 16), &v11);
  RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)(v6 + 2), v9);
  double result = (RB::XML::DisplayList *)v6[38];
  if (result) {
    RB::XML::DisplayList::add_grayscale_filter(result, (RB::XML::Document *)a1, v8, a3);
  }
  return result;
}

RB::XML::Document *RBDrawingStateAddColorMonochromeFilter2(__n128 *a1, unsigned int a2, int a3, float a4, float a5, float a6, float a7, float a8, float a9)
{
  __n128 v18 = (void *)a1->n128_u64[1];
  if (!v18[3]) {
    make_contents(a1->n128_i64[1]);
  }
  v22.n128_u32[0] = a3 & 0xFFFFFFFB;
  *(unint64_t *)((char *)v22.n128_u64 + 4) = color_filter_color(a2, a3 & 0xFFFFFFFB, (uint64_t)a1, a5, a6, a7, a8);
  v22.n128_u16[6] = v19;
  float v23 = a4;
  float v24 = a9;
  RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>,RB::ColorStyle::ColorMonochrome>((RB::Heap *)(v18[3] + 16), &v22);
  RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)(v18 + 2), v20);
  double result = (RB::XML::Document *)v18[38];
  if (result) {
    RB::XML::DisplayList::add_color_monochrome_filter(result);
  }
  return result;
}

RB::XML::Document *RBDrawingStateAddColorMonochromeFilter(__n128 *a1, int a2, float a3, float a4, float a5, float a6, float a7, float a8)
{
  return RBDrawingStateAddColorMonochromeFilter2(a1, 0, a2, a3, a4, a5, a6, a7, a8);
}

RB::XML::Document *RBDrawingStateAddLuminanceCurveFilter2(__n128 *a1, long long *a2, unsigned int a3, int a4, float a5, float a6, float a7, float a8)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  int v16 = (void *)a1->n128_u64[1];
  if (!v16[3]) {
    make_contents(a1->n128_i64[1]);
  }
  unsigned int v17 = a4 & 0xFFFFFFFB;
  uint64_t v18 = color_filter_color(a3, v17, (uint64_t)a1, a5, a6, a7, a8);
  long long v19 = *a2;
  v23[0] = v17;
  long long v24 = v19;
  uint64_t v25 = v18;
  __int16 v26 = v20;
  RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>,RB::Filter::LuminanceCurve>((RB::Heap *)(v16[3] + 16), (uint64_t)v23);
  RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)(v16 + 2), v21);
  double result = (RB::XML::Document *)v16[38];
  if (result) {
    RB::XML::DisplayList::add_luminance_curve_filter(result);
  }
  return result;
}

RB::XML::Document *RBDrawingStateAddLuminanceCurveFilter(__n128 *a1, long long *a2, int a3, float a4, float a5, float a6, float a7)
{
  return RBDrawingStateAddLuminanceCurveFilter2(a1, a2, 0, a3, a4, a5, a6, a7);
}

RB::XML::DisplayList *RBDrawingStateAddRGBACurvesFilter(__n128 *a1, _RBDrawingState *a2, const float *a3)
{
  unint64_t v6 = (void *)a1->n128_u64[1];
  uint64_t v7 = v6[3];
  if (!v7)
  {
    make_contents(a1->n128_i64[1]);
    uint64_t v7 = v6[3];
  }
  long long v8 = *(_OWORD *)a2;
  long long v9 = *((_OWORD *)a2 + 1);
  long long v10 = *((_OWORD *)a2 + 2);
  long long v11 = *((_OWORD *)a2 + 3);
  v14[0] = a3;
  long long v15 = v8;
  long long v16 = v9;
  long long v17 = v10;
  long long v18 = v11;
  RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::RGBACurves>,RB::Filter::RGBACurves>((RB::Heap *)(v7 + 16), (uint64_t)v14);
  RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)(v6 + 2), v12);
  double result = (RB::XML::DisplayList *)v6[38];
  if (result) {
    RB::XML::DisplayList::add_rgba_curves_filter(result, (RB::XML::Document *)a1, a2, a3);
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddShaderFilter(__n128 *a1, char *a2, float64x2_t *a3, const CGRect *a4, CGFloat a5, CGFloat a6)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  long long v10 = (void *)a1->n128_u64[1];
  if (!v10[3]) {
    make_contents(a1->n128_i64[1]);
  }
  long long v26 = 0uLL;
  if (a3)
  {
    float32x2_t v11 = vcvt_f32_f64(a3[1]);
    *(float32x2_t *)&long long v26 = vcvt_f32_f64(*a3);
    *((float32x2_t *)&v26 + 1) = v11;
  }
  int v12 = a4 & 0xF;
  if ((a4 & 0xF) == 0 || v12 == 2)
  {
    unsigned int v20 = (a4 >> 2) & 4 | (a4 >> 3) & 0x18 | v12;
    float v21 = (RB::CustomShader::Closure *)-[RBShape shapeData]((uint64_t)a2);
    v22.f64[0] = a5;
    v22.f64[1] = a6;
    RB::DisplayList::State::add_custom_effect(a1, (RB::DisplayList::Builder *)(v10 + 2), v21, 0, &v26, v20, COERCE_DOUBLE(vcvt_f32_f64(v22)), 0.0);
  }
  else
  {
    if (v12 != 1) {
      RB::precondition_failure((RB *)"invalid shader filter type", a2);
    }
    int v13 = (const RB::CustomShader::Closure *)-[RBShape shapeData]((uint64_t)a2);
    unsigned int v27 = (a4 >> 1) & 8 | (a4 >> 5) & 1;
    RB::CustomShader::Closure::Closure((RB::CustomShader::Closure *)&v28, v13);
    long long v32 = xmmword_2142181C0;
    long long v33 = xmmword_2142181D0;
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    long long v36 = v26;
    unint64_t v14 = (RB::DisplayList::Style *)RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::Custom>,RB::Filter::Custom>((size_t *)(v10[3] + 16), (uint64_t)&v27);
    __n128 v15 = RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)(v10 + 2), v14);
    long long v16 = v30;
    if (v30) {
      long long v17 = (const void **)v30;
    }
    else {
      long long v17 = (const void **)&v29;
    }
    if (v31)
    {
      for (unint64_t i = 0; i < v31; ++i)
      {
        RB::CustomShader::Value::reset_data(v17);
        v17 += 3;
      }
      long long v16 = v30;
    }
    if (v16) {
      free(v16);
    }
    uint64_t v19 = v28;
    if (v28 && atomic_fetch_add_explicit((atomic_uint *volatile)(v28 + 8), 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(uint64_t, __n128))(*(void *)v19 + 8))(v19, v15);
    }
  }
  double result = (RB::XML::DisplayList *)v10[38];
  if (result)
  {
    v38.float64_t width = a5;
    v38.float64_t height = a6;
    RB::XML::DisplayList::add_shader_filter(result, (_RBDrawingState *)a1, (_RBDrawingState *)a2, 0, v38, (const CGSize *)a3, a4);
  }
  return result;
}

void sub_214161594(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  RB::Filter::Custom::~Custom((RB::Filter::Custom *)va);
  _Unwind_Resume(a1);
}

void RB::Filter::Custom::~Custom(RB::Filter::Custom *this)
{
  uint64_t v2 = (const void **)((char *)this + 16);
  uint64_t v3 = (const void **)*((void *)this + 14);
  if (v3) {
    BOOL v4 = v3;
  }
  else {
    BOOL v4 = v2;
  }
  if (*((void *)this + 15))
  {
    unint64_t v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < *((void *)this + 15));
    uint64_t v3 = (const void **)*((void *)this + 14);
  }
  if (v3) {
    free(v3);
  }
  unint64_t v6 = (atomic_uint *)*((void *)this + 1);
  if (v6)
  {
    if (atomic_fetch_add_explicit(v6 + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(atomic_uint *))(*(void *)v6 + 8))(v6);
    }
  }
}

void RBDrawingStateAddShaderFilterLayer(__n128 *a1, RB::DisplayList::State *a2, _RBDrawingState *a3, const CGSize *a4, const CGRect *a5, double a6, double a7, double a8, double a9)
{
  unint64_t v18 = a1->n128_u64[1];
  if (!*(void *)(v18 + 24)) {
    make_contents(a1->n128_i64[1]);
  }
  uint64_t v19 = (RB::DisplayList::Builder *)(v18 + 16);
  unsigned int v20 = (RB::DisplayList::Layer *)RB::DisplayList::Builder::end_layer(v19, a2);
  RB::DisplayList::Builder::delete_state((atomic_uint *)v19, a2);
  double v21 = a6;
  double v22 = a7;
  double v23 = a8;
  double v24 = a9;
  add_shader_filter_layer(a1, a3, v20, *(CGSize *)&v21, *(CGSize *)&v23, a4, a5);
}

void add_shader_filter_layer(__n128 *a1, _RBDrawingState *a2, RB::DisplayList::Layer *a3, CGSize a4, CGSize a5, const CGSize *a6, const CGRect *a7)
{
  CGSize v27 = a5;
  int v12 = (void *)a1->n128_u64[1];
  if (!v12[3])
  {
    CGFloat width = a4.width;
    CGFloat height = a4.height;
    CGFloat v19 = a5.width;
    CGFloat v21 = a5.height;
    make_contents(a1->n128_i64[1]);
    a5.CGFloat width = v19;
    a5.CGFloat height = v21;
    a4.CGFloat width = width;
    a4.CGFloat height = height;
  }
  long long v26 = 0uLL;
  if (a6)
  {
    float32x2_t v13 = vcvt_f32_f64((float64x2_t)a6[1]);
    *(float32x2_t *)&long long v26 = vcvt_f32_f64(*(float64x2_t *)a6);
    *((float32x2_t *)&v26 + 1) = v13;
  }
  if ((a7 & 0xF) != 0)
  {
    RB::DisplayList::Layer::~Layer(a3);
  }
  else
  {
    float64_t v22 = a4.width;
    float64_t v24 = a4.height;
    CGFloat v18 = a5.width;
    CGFloat v20 = a5.height;
    unint64_t v14 = (RB::CustomShader::Closure *)-[RBShape shapeData]((uint64_t)a2);
    v15.f64[0] = v22;
    v15.f64[1] = v24;
    v16.f64[0] = v18;
    v16.f64[1] = v20;
    RB::DisplayList::State::add_custom_effect(a1, (RB::DisplayList::Builder *)(v12 + 2), v14, (uint64_t)a3, &v26, (a7 >> 3) & 0x18 | (a7 >> 2) & 4, COERCE_DOUBLE(vcvt_f32_f64(v15)), COERCE_DOUBLE(vcvt_f32_f64(v16)));
    long long v17 = (RB::XML::DisplayList *)v12[38];
    if (v17)
    {
      v29.CGFloat width = v22;
      v29.CGFloat height = v24;
      RB::XML::DisplayList::add_shader_filter(v17, (_RBDrawingState *)a1, a2, (RBShader *)&v27, v29, a6, a7);
    }
  }
}

uint64_t encode_contents(RB::DisplayList::Contents *a1, void *a2, void *a3)
{
  if (a1)
  {
    v4[0] = &unk_26C4ED1F0;
    v4[1] = a2;
    unint64_t v5 = a1;
    unint64_t v6 = a1;
    RB::ObjcEncoderDelegate::encode_message_f<NSData * RB::ObjcEncoderDelegate::encode_message<RB::DisplayList::Contents>(RB::DisplayList::Contents const&)::{lambda(RB::DisplayList::Contents&)#1},NSData * RB::ObjcEncoderDelegate::encode_message<RB::DisplayList::Contents>(RB::DisplayList::Contents const&)::{lambda(RB::DisplayList::Contents&)#2}>(v4, &v6, &v5);
  }
  if (a3 && !*a3) {
    *a3 = [MEMORY[0x263F087E8] errorWithDomain:@"RBCodableError" code:-1 userInfo:0];
  }
  return 0;
}

void sub_214161A78(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10A0C4070508A9ALL);
  _Unwind_Resume(a1);
}

void sub_214162058(_Unwind_Exception *a1)
{
}

void sub_2141627A0(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10A0C4070508A9ALL);
  _Unwind_Resume(a1);
}

void sub_214162880(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10F1C4040C62C24);
  _Unwind_Resume(a1);
}

void sub_214162B20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, atomic_uint *a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35)
{
  uint64_t v36 = a10;
  a10 = 0;
  if (v36) {
    std::default_delete<RB::XML::Document>::operator()[abi:nn180100]((uint64_t)&a10, v36);
  }
  uint64_t v37 = a14;
  RB::Decoder::~Decoder((RB::Decoder *)&a15);
  if (v37)
  {
    if (atomic_fetch_add_explicit(v37 + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(atomic_uint *))(*(void *)v37 + 8))(v37);
    }
  }
  _Unwind_Resume(a1);
}

void sub_214162D20(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_214162E64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_214162EC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_214162F3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_214162FA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_214163008(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *RB::vector<std::pair<RB::cf_ptr<CGContext *>,RB::ContextDelegate *>,1ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  if (*((_DWORD *)__dst + 7) + (*((_DWORD *)__dst + 7) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *((_DWORD *)__dst + 7) + (*((_DWORD *)__dst + 7) >> 1);
  }
  double result = RB::details::realloc_vector<unsigned int,16ul>(*((void **)__dst + 2), __dst, 1u, (_DWORD *)__dst + 7, v3);
  *((void *)__dst + 2) = result;
  return result;
}

RB::CustomShader::Closure *RB::CustomShader::Closure::Closure(RB::CustomShader::Closure *this, const RB::CustomShader::Closure *a2)
{
  uint64_t v3 = *(void *)a2;
  if (*(void *)a2) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v3 + 8), 1u, memory_order_relaxed);
  }
  *(void *)this = v3;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((void *)this + 15) = 4;
  unint64_t v4 = *((void *)a2 + 14);
  if (*((void *)a2 + 13)) {
    unint64_t v5 = (const RB::CustomShader::Value *)*((void *)a2 + 13);
  }
  else {
    unint64_t v5 = (const RB::CustomShader::Closure *)((char *)a2 + 8);
  }
  if (v4 >= 5)
  {
    RB::vector<RB::CustomShader::Value,4ul,unsigned long>::reserve_slow((char *)this + 8, *((void *)a2 + 14));
    unint64_t v6 = (char *)*((void *)this + 13);
    uint64_t v7 = *((void *)this + 14);
  }
  else
  {
    unint64_t v6 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    if (!v4) {
      goto LABEL_13;
    }
  }
  if (!v6) {
    unint64_t v6 = (char *)this + 8;
  }
  long long v9 = (RB::CustomShader::Value *)&v6[24 * v7];
  unint64_t v10 = v4;
  do
  {
    uint64_t v11 = RB::CustomShader::Value::Value(v9, v5);
    unint64_t v5 = (const RB::CustomShader::Value *)((char *)v5 + 24);
    long long v9 = (RB::CustomShader::Value *)(v11 + 24);
    --v10;
  }
  while (v10);
  uint64_t v8 = *((void *)this + 14);
LABEL_13:
  *((void *)this + 14) = v8 + v4;
  return this;
}

void sub_214163184(_Unwind_Exception *exception_object)
{
  unint64_t v5 = *(void **)(v1 + 104);
  if (v5) {
    uint64_t v2 = *(const void ***)(v1 + 104);
  }
  if (*(void *)(v1 + 112))
  {
    unint64_t v6 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v2);
      ++v6;
      v2 += 3;
    }
    while (v6 < *(void *)(v1 + 112));
    unint64_t v5 = *v3;
  }
  if (v5) {
    free(v5);
  }
  uint64_t v7 = *(atomic_uint **)v1;
  if (*(void *)v1)
  {
    if (atomic_fetch_add_explicit(v7 + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(atomic_uint *))(*(void *)v7 + 8))(v7);
    }
  }
  _Unwind_Resume(exception_object);
}

void *RB::vector<RB::DisplayList::Transform::Term,1ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  if (*((_DWORD *)__dst + 11) + (*((_DWORD *)__dst + 11) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *((_DWORD *)__dst + 11) + (*((_DWORD *)__dst + 11) >> 1);
  }
  double result = RB::details::realloc_vector<unsigned int,32ul>(*((void **)__dst + 4), __dst, 1u, (_DWORD *)__dst + 11, v3);
  *((void *)__dst + 4) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,32ul>(void *__src, void *__dst, unsigned int a3, _DWORD *a4, unsigned int a5)
{
  uint64_t v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      LODWORD(v9) = a3;
      memcpy(__dst, __src, 32 * a5);
      free(v7);
      int v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(32 * a5);
    size_t v9 = v8 >> 5;
    if (*a4 != (v8 >> 5))
    {
      unint64_t v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10) {
        RB::precondition_failure((RB *)"allocation failure", v11);
      }
      int v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, 32 * *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

atomic_uint *RB::Refcount<RB::Transition,std::atomic<unsigned int>>::release(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t RB::Refcount<RB::Transition,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

void RB::Transition::~Transition(RB::Transition *this)
{
  *(void *)this = &unk_26C4E8430;
  uint64_t v2 = (void *)*((void *)this + 10);
  if (v2) {
    free(v2);
  }
  unsigned int v3 = (void *)*((void *)this + 5);
  if (v3) {
    free(v3);
  }
}

{
  void *v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_26C4E8430;
  uint64_t v2 = (void *)*((void *)this + 10);
  if (v2) {
    free(v2);
  }
  unsigned int v3 = (void *)*((void *)this + 5);
  if (v3) {
    free(v3);
  }
  JUMPOUT(0x21669AC10);
}

atomic_uint *RB::Refcount<RB::DisplayList::Interpolator::Object,std::atomic<unsigned int>>::release(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t RB::Refcount<RB::DisplayList::Interpolator::Object,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

void RB::DisplayList::Interpolator::Object::~Object(RB::DisplayList::Interpolator::Object *this)
{
  *(void *)this = &unk_26C4E7F20;
  uint64_t v2 = (void *)*((void *)this + 47);
  if (v2) {
    free(v2);
  }
  unsigned int v3 = (void *)*((void *)this + 40);
  if (v3) {
    free(v3);
  }
  unint64_t v4 = (void *)*((void *)this + 16);
  if (v4) {
    free(v4);
  }
  unint64_t v5 = (void *)*((void *)this + 14);
  if (v5) {
    free(v5);
  }
  unint64_t v6 = (void *)*((void *)this + 12);
  if (v6) {
    free(v6);
  }
  std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,RB::pair_hash<unsigned int,unsigned int>,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::equal_to<std::pair<unsigned int,unsigned int>>,RB::pair_hash<unsigned int,unsigned int>,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>>>::~__hash_table((uint64_t)this + 48);
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  uint64_t vars8;

  *(void *)this = &unk_26C4E7F20;
  uint64_t v2 = (void *)*((void *)this + 47);
  if (v2) {
    free(v2);
  }
  unsigned int v3 = (void *)*((void *)this + 40);
  if (v3) {
    free(v3);
  }
  unint64_t v4 = (void *)*((void *)this + 16);
  if (v4) {
    free(v4);
  }
  unint64_t v5 = (void *)*((void *)this + 14);
  if (v5) {
    free(v5);
  }
  unint64_t v6 = (void *)*((void *)this + 12);
  if (v6) {
    free(v6);
  }
  std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,RB::pair_hash<unsigned int,unsigned int>,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::equal_to<std::pair<unsigned int,unsigned int>>,RB::pair_hash<unsigned int,unsigned int>,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>>>::~__hash_table((uint64_t)this + 48);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,RB::pair_hash<unsigned int,unsigned int>,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::equal_to<std::pair<unsigned int,unsigned int>>,RB::pair_hash<unsigned int,unsigned int>,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,RB::pair_hash<unsigned int,unsigned int>,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::equal_to<std::pair<unsigned int,unsigned int>>,RB::pair_hash<unsigned int,unsigned int>,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,RB::pair_hash<unsigned int,unsigned int>,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::equal_to<std::pair<unsigned int,unsigned int>>,RB::pair_hash<unsigned int,unsigned int>,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>>>::__deallocate_node(int a1, void *__p)
{
  if (__p)
  {
    uint64_t v2 = __p;
    do
    {
      unsigned int v3 = (void *)*v2;
      uint64_t v4 = v2[3];
      v2[3] = 0;
      if (v4) {
        std::default_delete<RB::DisplayList::Interpolator::Layer>::operator()[abi:nn180100]((uint64_t)(v2 + 3), v4);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void std::default_delete<RB::XML::Document>::operator()[abi:nn180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    RB::UntypedTable::~UntypedTable((RB::UntypedTable *)(a2 + 32));
    unsigned int v3 = *(void **)(a2 + 8);
    if (v3) {
      free(v3);
    }
    uint64_t v4 = *(_DWORD **)a2;
    if (*(void *)a2)
    {
      int v5 = v4[2] - 1;
      id v4[2] = v5;
      if (!v5) {
        (*(void (**)(_DWORD *))(*(void *)v4 + 8))(v4);
      }
    }
    JUMPOUT(0x21669AC10);
  }
}

uint64_t RB::DisplayList::ClipFactory::operator()<RB::Coverage::Primitive>(uint64_t a1, _OWORD *a2, int8x16_t a3)
{
  uint64_t result = *(void *)(a1 + 32);
  if (!result)
  {
    uint64_t result = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive&,float &,RB::ClipMode &,RB::AffineTransform const*&>(*(size_t **)a1, a3, *(void *)a1, a2, (unsigned __int32 *)(a1 + 8), (int *)(a1 + 12), (uint64_t *)(a1 + 16));
    *(void *)(a1 + 32) = result;
  }
  if (*(unsigned char *)(a1 + 24)) {
    *(unsigned char *)(result + 45) |= 4u;
  }
  return result;
}

uint64_t RB::DisplayList::ClipFactory::operator()<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    v5[0] = (uint64_t (**)(void, long long *))&unk_26C4E89A8;
    v5[1] = (uint64_t (**)(void, long long *))a1;
    RB::Coverage::StrokeablePath::simplify(a2 + 8, a2, v5);
  }
  uint64_t result = *(void *)(a1 + 32);
  if (!result)
  {
    uint64_t result = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(*(size_t **)a1, *(void *)a1, a2, (int *)(a1 + 8), (_DWORD *)(a1 + 12), (uint64_t *)(a1 + 16));
    *(void *)(a1 + 32) = result;
  }
  if (*(unsigned char *)(a1 + 24)) {
    *(unsigned char *)(result + 45) |= 4u;
  }
  return result;
}

uint64_t RB::DisplayList::ClipFactory::operator()<RB::Coverage::Glyphs>(uint64_t a1, RB::Coverage::Glyphs *a2)
{
  uint64_t result = *(void *)(a1 + 32);
  if (!result)
  {
    uint64_t result = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Glyphs>,RB::Heap&,RB::Coverage::Glyphs const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(*(size_t **)a1, *(RB::Heap **)a1, a2, (int *)(a1 + 8), (int *)(a1 + 12), (uint64_t *)(a1 + 16));
    *(void *)(a1 + 32) = result;
  }
  if (*(unsigned char *)(a1 + 24)) {
    *(unsigned char *)(result + 45) |= 4u;
  }
  return result;
}

uint64_t RB::DisplayList::ClipFactory::operator()<RB::Coverage::Stroke<RBStrokeRef>>(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a1 + 32);
  if (!result)
  {
    uint64_t result = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(*(size_t **)a1, *(void *)a1, a2, (int *)(a1 + 8), (_DWORD *)(a1 + 12), (uint64_t *)(a1 + 16));
    *(void *)(a1 + 32) = result;
  }
  if (*(unsigned char *)(a1 + 24)) {
    *(unsigned char *)(result + 45) |= 4u;
  }
  return result;
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(size_t *a1, uint64_t a2, uint64_t a3, int *a4, _DWORD *a5, uint64_t *a6)
{
  uint64_t v11 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v11 + 152 > a1[3]) {
    uint64_t v11 = RB::Heap::alloc_slow(a1, 0x98uLL, 7);
  }
  else {
    a1[2] = v11 + 152;
  }
  int v12 = *a4;
  char v13 = *a5;
  uint64_t v14 = *a6;
  *(void *)(v11 + 16) = 0;
  *(void *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(void *)(v11 + 32) = 0;
  *(unsigned char *)(v11 + 44) = v13;
  *(unsigned char *)(v11 + 45) = 0;
  *(void *)uint64_t v11 = &unk_26C4E8DB0;
  *(void *)(v11 + 48) = v14;
  *(void *)(v11 + 56) = &unk_26C4EDD48;
  RB::Coverage::StrokeablePath::StrokeablePath(v11 + 64, a3 + 8, a2);
  long long v15 = *(_OWORD *)(a3 + 56);
  *(_OWORD *)(v11 + 112) = v15;
  *(unsigned char *)(v11 + 128) = *(unsigned char *)(a3 + 72);
  *(_WORD *)(v11 + 129) = *(_WORD *)(a3 + 73);
  *(unsigned char *)(v11 + 131) = *(unsigned char *)(a3 + 75);
  *(unsigned char *)(v11 + 132) = *(unsigned char *)(a3 + 76);
  LODWORD(v15) = *(_DWORD *)(a3 + 80);
  *(_DWORD *)(v11 + 136) = v15;
  *(_DWORD *)(v11 + 144) = v12;
  RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::update_bounds(v11, *(double *)&v15, v16);
  return v11;
}

void sub_214163A00(_Unwind_Exception *a1)
{
  v1[7] = v2;
  RBPathRelease(v1[8], v1[9]);
  _Unwind_Resume(a1);
}

void RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::clip(uint64_t a1, CGContextRef *a2)
{
  memset(&v8, 0, sizeof(v8));
  uint64_t v4 = *(float64x2_t **)(a1 + 48);
  int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) != 0)
  {
    RB::Coverage::StrokeablePath::clip(a1 + 64, a1 + 56, (uint64_t)a2);
  }
  else
  {
    CGContextGetCTM(&v8, *a2);
    unint64_t v6 = *a2;
    float64x2_t v7 = v4[1];
    *(float64x2_t *)&transform.a = *v4;
    *(float64x2_t *)&transform.c = v7;
    *(float64x2_t *)&transform.tfloat64_t x = v4[2];
    CGContextConcatCTM(v6, &transform);
    RB::Coverage::StrokeablePath::clip(a1 + 64, a1 + 56, (uint64_t)a2);
    CGAffineTransform transform = v8;
    CGContextSetCTM();
  }
}

void RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::fill(uint64_t a1, CGContextRef *a2, uint64_t a3)
{
  memset(&v10, 0, sizeof(v10));
  unint64_t v6 = *(float64x2_t **)(a1 + 48);
  int64x2_t v7 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v6[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v6, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v6[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v7, 1), (int8x16_t)v7).u64[0] & 0x8000000000000000) != 0)
  {
    RB::Coverage::StrokeablePath::fill(a1 + 64, a1 + 56, (uint64_t)a2, a3);
  }
  else
  {
    CGContextGetCTM(&v10, *a2);
    CGAffineTransform v8 = *a2;
    float64x2_t v9 = v6[1];
    *(float64x2_t *)&transform.a = *v6;
    *(float64x2_t *)&transform.c = v9;
    *(float64x2_t *)&transform.tfloat64_t x = v6[2];
    CGContextConcatCTM(v8, &transform);
    RB::Coverage::StrokeablePath::fill(a1 + 64, a1 + 56, (uint64_t)a2, a3);
    CGAffineTransform transform = v10;
    CGContextSetCTM();
  }
}

void RB::DisplayList::GenericClip<RB::Coverage::Primitive>::clip(float32x2_t *a1, CGContext **a2)
{
  memset(&v8, 0, sizeof(v8));
  uint64_t v4 = (float64x2_t *)a1[6];
  int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) != 0)
  {
    RB::Coverage::Primitive::clip(a1 + 8, a2);
  }
  else
  {
    CGContextGetCTM(&v8, *a2);
    unint64_t v6 = *a2;
    float64x2_t v7 = v4[1];
    *(float64x2_t *)&transform.a = *v4;
    *(float64x2_t *)&transform.c = v7;
    *(float64x2_t *)&transform.tfloat64_t x = v4[2];
    CGContextConcatCTM(v6, &transform);
    RB::Coverage::Primitive::clip(a1 + 8, a2);
    CGAffineTransform transform = v8;
    CGContextSetCTM();
  }
}

void RB::DisplayList::GenericClip<RB::Coverage::Primitive>::fill(float32x2_t *a1, RB::CGContext *a2, RB::Fill::Color *a3)
{
  memset(&v12, 0, sizeof(v12));
  unint64_t v6 = (float64x2_t *)a1[6];
  int64x2_t v7 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v6[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v6, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v6[2]));
  *(void *)&double v8 = vandq_s8((int8x16_t)vdupq_laneq_s64(v7, 1), (int8x16_t)v7).u64[0];
  if ((*(void *)&v8 & 0x8000000000000000) != 0)
  {
    RB::Coverage::Primitive::fill(a1 + 8, a2, a3, v8);
  }
  else
  {
    CGContextGetCTM(&v12, *(CGContextRef *)a2);
    float64x2_t v9 = *(CGContext **)a2;
    float64x2_t v10 = v6[1];
    *(float64x2_t *)&transform.a = *v6;
    *(float64x2_t *)&transform.c = v10;
    *(float64x2_t *)&transform.tfloat64_t x = v6[2];
    CGContextConcatCTM(v9, &transform);
    RB::Coverage::Primitive::fill(a1 + 8, a2, a3, v11);
    CGAffineTransform transform = v12;
    CGContextSetCTM();
  }
}

uint64_t RB::DisplayList::ClipFactory::Visitor<RB::Coverage::Path>::visit(uint64_t a1, _OWORD *a2, int8x16_t a3)
{
  uint64_t result = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive&,float &,RB::ClipMode &,RB::AffineTransform const*&>(**(size_t ***)(a1 + 8), a3, **(void **)(a1 + 8), a2, (unsigned __int32 *)(*(void *)(a1 + 8) + 8), (int *)(*(void *)(a1 + 8) + 12), (uint64_t *)(*(void *)(a1 + 8) + 16));
  *(void *)(*(void *)(a1 + 8) + 32) = result;
  return result;
}

uint64_t RB::DisplayList::ClipFactory::Visitor<RB::Coverage::Path>::visit(uint64_t a1, uint64_t a2)
{
  uint64_t result = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(**(size_t ***)(a1 + 8), **(void **)(a1 + 8), a2, (int *)(*(void *)(a1 + 8) + 8), (_DWORD *)(*(void *)(a1 + 8) + 12), (uint64_t *)(*(void *)(a1 + 8) + 16));
  *(void *)(*(void *)(a1 + 8) + 32) = result;
  return result;
}

void RB::DisplayList::GenericClip<RB::Coverage::Path>::clip(uint64_t a1, CGContextRef *a2)
{
  memset(&v8, 0, sizeof(v8));
  uint64_t v4 = *(float64x2_t **)(a1 + 48);
  int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) != 0)
  {
    RB::Coverage::Path::clip((RB::Coverage::Path *)(a1 + 56), a2);
  }
  else
  {
    CGContextGetCTM(&v8, *a2);
    unint64_t v6 = *a2;
    float64x2_t v7 = v4[1];
    *(float64x2_t *)&transform.a = *v4;
    *(float64x2_t *)&transform.c = v7;
    *(float64x2_t *)&transform.tfloat64_t x = v4[2];
    CGContextConcatCTM(v6, &transform);
    RB::Coverage::Path::clip((RB::Coverage::Path *)(a1 + 56), a2);
    CGAffineTransform transform = v8;
    CGContextSetCTM();
  }
}

uint64_t RB::DisplayList::ClipFactory::Visitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::visit(uint64_t a1, _OWORD *a2, int8x16_t a3)
{
  uint64_t result = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive&,float &,RB::ClipMode &,RB::AffineTransform const*&>(**(size_t ***)(a1 + 8), a3, **(void **)(a1 + 8), a2, (unsigned __int32 *)(*(void *)(a1 + 8) + 8), (int *)(*(void *)(a1 + 8) + 12), (uint64_t *)(*(void *)(a1 + 8) + 16));
  *(void *)(*(void *)(a1 + 8) + 32) = result;
  return result;
}

uint64_t RB::DisplayList::ClipFactory::Visitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::visit(uint64_t a1, uint64_t a2)
{
  uint64_t result = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(**(size_t ***)(a1 + 8), **(void **)(a1 + 8), a2, (int *)(*(void *)(a1 + 8) + 8), (_DWORD *)(*(void *)(a1 + 8) + 12), (uint64_t *)(*(void *)(a1 + 8) + 16));
  *(void *)(*(void *)(a1 + 8) + 32) = result;
  return result;
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Glyphs>,RB::Heap&,RB::Coverage::Glyphs const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(size_t *a1, RB::Heap *a2, RB::Coverage::Glyphs *a3, int *a4, int *a5, uint64_t *a6)
{
  uint64_t v11 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v11 + 120 > a1[3]) {
    uint64_t v11 = RB::Heap::alloc_slow(a1, 0x78uLL, 7);
  }
  else {
    a1[2] = v11 + 120;
  }
  int v12 = *a4;
  int v13 = *a5;
  uint64_t v14 = *a6;
  *(void *)(v11 + 16) = 0;
  *(void *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(void *)(v11 + 32) = 0;
  *(_WORD *)(v11 + 44) = v13;
  *(void *)uint64_t v11 = &unk_26C4E8C80;
  *(void *)(v11 + 48) = v14;
  RB::Coverage::Glyphs::Glyphs((RB::Coverage::Glyphs *)(v11 + 56), a3, a2);
  *(_DWORD *)(v11 + 112) = v12;
  RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::update_bounds(v11);
  return v11;
}

void RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::update_bounds(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 44) == 1)
  {
    *(void *)(a1 + 16) = 0x100000001000000;
    *(int32x2_t *)(a1 + 24) = vdup_n_s32(0x7F7FFFFFu);
  }
  else if (!*(unsigned char *)(a1 + 44))
  {
    if (*(float *)(a1 + 112) == 0.0)
    {
      *(void *)(a1 + 16) = 0;
      *(void *)(a1 + 24) = 0;
    }
    else
    {
      *(double *)(a1 + 16) = RB::Coverage::Glyphs::bounds((RB::Coverage::Glyphs *)(a1 + 56), *(float64x2_t **)(a1 + 48), 0);
      *(void *)(a1 + 24) = v2;
    }
  }
}

void RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::~GenericClip()
{
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::type_id()
{
  return 20482;
}

void *RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::copy(uint64_t a1, RB::DisplayList::CachedTransform *this, uint64_t a3, int a4)
{
  float64x2_t v7 = (size_t *)(*(void *)(*(void *)this + 8) + 16);
  int v8 = *(char *)(a1 + 44);
  if (a4) {
    int v8 = *(unsigned char *)(a1 + 44) == 0;
  }
  int v14 = v8;
  int v13 = RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)this, *(const RB::AffineTransform **)(a1 + 48));
  if ((*(unsigned char *)(a1 + 45) & 4) != 0) {
    char v9 = *(unsigned char *)(a1 + 45) & 4;
  }
  else {
    char v9 = 4 * *(unsigned char *)(*(void *)this + 272);
  }
  uint64_t v10 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Glyphs>,RB::Heap&,RB::Coverage::Glyphs const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(v7, (RB::Heap *)v7, (RB::Coverage::Glyphs *)(a1 + 56), (int *)(a1 + 112), &v14, (uint64_t *)&v13);
  *(void *)(v10 + 32) = RB::DisplayList::CachedTransform::transform_metadata(this, *(const RB::DisplayList::Metadata **)(a1 + 32), *(_DWORD *)(a1 + 40));
  *(_DWORD *)(v10 + 40) = v11;
  *(unsigned char *)(v10 + 45) |= v9;
  uint64_t result = (void *)((*((void *)this + 3) + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(result + 2) > *((void *)this + 4)) {
    uint64_t result = (void *)RB::Heap::alloc_slow((size_t *)this + 1, 0x10uLL, 7);
  }
  else {
    *((void *)this + 3) = result + 2;
  }
  *uint64_t result = a3;
  result[1] = v10;
  return result;
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::contains(uint64_t a1, float32x2_t d0_0, float32x2_t a3)
{
  if (*(unsigned char *)(a1 + 44) != 1) {
    return 0;
  }
  if (*(float *)(a1 + 112) == 0.0) {
    return 1;
  }
  v11[0] = COERCE_FLOAT32X2_T(RB::Coverage::Glyphs::bounds((RB::Coverage::Glyphs *)(a1 + 56), *(float64x2_t **)(a1 + 48), 0));
  v11[1] = v6;
  return RB::Rect::intersects(v11, v12, d0_0, a3, v7, v8, v9, v10) ^ 1;
}

double RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::min_scale()
{
  return 0.0;
}

__n128 RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::render(float32x2_t *a1, double a2, uint64_t a3, uint64_t a4, int a5)
{
  int64x2_t v5 = (float64x2_t *)a1[6];
  v6.i64[0] = SLODWORD(a2);
  v6.i64[1] = SHIDWORD(a2);
  float64x2_t v7 = v5[1];
  float64x2_t v8 = vaddq_f64(v5[2], vcvtq_f64_s64(v6));
  v10[0] = *v5;
  v10[1] = v7;
  _DWORD v10[2] = v8;
  RB::render_glyphs_coverage(a4, v10, a1 + 7, a5, a1[14].f32[0]);
  return result;
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned __int8 *)(a1 + 44) != *(unsigned __int8 *)(a3 + 44)) {
    return 0;
  }
  can_mifloat64_t x = RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a3 + 48), (const RB::AffineTransform *)a3);
  if (!can_mix) {
    return 0;
  }
  unsigned __int8 v6 = can_mix;
  v9[1] = 0;
  _DWORD v9[2] = 0;
  v9[0] = 0xFFFFFFF000000000;
  int v10 = 0;
  uint64_t v11 = 1;
  int v12 = 0;
  unsigned int v7 = RB::Coverage::Glyphs::can_mix((RB::Coverage::Glyphs *)(a1 + 56), (const RB::DisplayList::Interpolator::Op *)v9, (const RB::Coverage::Glyphs *)(a3 + 56));
  if (v7 >= v6) {
    return v6;
  }
  else {
    return v7;
  }
}

float32x2_t *RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::mix(uint64_t a1, float *a2, uint64_t a3, float64x2_t *a4)
{
  float64x2_t v8 = (size_t *)(*(void *)(*(void *)&a4->f64[0] + 8) + 16);
  RB::mix(*(CGAffineTransform **)(a1 + 48), *(float64x2_t **)(a3 + 48), (const RB::AffineTransform *)a3, a2[4]);
  v17[0] = v9;
  v17[1] = v10;
  v17[2] = v11;
  float v16 = *(float *)(a1 + 112) + (float)((float)(*(float *)(a3 + 112) - *(float *)(a1 + 112)) * a2[4]);
  int v15 = *(char *)(a1 + 44);
  int v14 = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v17);
  int v12 = (float32x2_t *)RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Glyphs>,RB::Heap&,RB::Coverage::Glyphs const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(v8, (RB::Heap *)v8, (RB::Coverage::Glyphs *)(a1 + 56), (int *)&v16, &v15, (uint64_t *)&v14);
  RB::Coverage::Glyphs::mix(v12 + 7, (const RB::DisplayList::Interpolator::State *)a2, (const RB::Coverage::Glyphs *)(a3 + 56), *(float64x2_t **)(a1 + 48), *(float64x2_t **)(a3 + 48), v17, (RB::Heap *)v8);
  RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::update_bounds((uint64_t)v12);
  return v12;
}

void RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::clip(uint64_t a1, RB::CGContext *a2)
{
  memset(&v8, 0, sizeof(v8));
  uint64_t v4 = *(float64x2_t **)(a1 + 48);
  int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) != 0)
  {
    RB::Coverage::Glyphs::clip((float32x2_t **)(a1 + 56), a2);
  }
  else
  {
    CGContextGetCTM(&v8, *(CGContextRef *)a2);
    unsigned __int8 v6 = *(CGContext **)a2;
    float64x2_t v7 = v4[1];
    *(float64x2_t *)&transform.a = *v4;
    *(float64x2_t *)&transform.c = v7;
    *(float64x2_t *)&transform.tfloat64_t x = v4[2];
    CGContextConcatCTM(v6, &transform);
    RB::Coverage::Glyphs::clip((float32x2_t **)(a1 + 56), a2);
    CGAffineTransform transform = v8;
    CGContextSetCTM();
  }
}

void RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::fill(uint64_t a1, RB::CGContext *a2, RB::Fill::Color *a3)
{
  memset(&v12, 0, sizeof(v12));
  unsigned __int8 v6 = *(float64x2_t **)(a1 + 48);
  int64x2_t v7 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v6[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v6, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v6[2]));
  uint16x4_t v8 = (uint16x4_t)vandq_s8((int8x16_t)vdupq_laneq_s64(v7, 1), (int8x16_t)v7).u64[0];
  if ((*(void *)&v8 & 0x8000000000000000) != 0)
  {
    RB::Coverage::Glyphs::fill((float32x2_t **)(a1 + 56), a2, a3, v8);
  }
  else
  {
    CGContextGetCTM(&v12, *(CGContextRef *)a2);
    float64x2_t v9 = *(CGContext **)a2;
    float64x2_t v10 = v6[1];
    *(float64x2_t *)&transform.a = *v6;
    *(float64x2_t *)&transform.c = v10;
    *(float64x2_t *)&transform.tfloat64_t x = v6[2];
    CGContextConcatCTM(v9, &transform);
    RB::Coverage::Glyphs::fill((float32x2_t **)(a1 + 56), a2, a3, v11);
    CGAffineTransform transform = v12;
    CGContextSetCTM();
  }
}

float RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::cg_alpha(uint64_t a1)
{
  return *(float *)(a1 + 112);
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::prepare_encode(uint64_t a1, RB::Encoder *a2)
{
  return RB::Coverage::Glyphs::prepare_encode(a1 + 56, a2);
}

void *RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::encode(uint64_t a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Glyphs>(this, 1, (CGFont **)(a1 + 56));
  uint64_t v4 = *(float64x2_t **)(a1 + 48);
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x12uLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  int v6 = *(int *)(a1 + 112);
  if (*(float *)&v6 != 1.0)
  {
    RB::ProtobufEncoder::encode_varint(this, 0x1DuLL);
    RB::ProtobufEncoder::encode_fixed32(this, v6);
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Clip::encode((void *)a1, this);
}

void RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "clip");
  RB::DisplayList::Clip::print((RB::DisplayList::Clip *)a1, this);
  float v4 = *(float *)(a1 + 112);
  if (v4 != 1.0) {
    RB::SexpString::printf(this, 0, "(alpha %g)", v4);
  }
  RB::SexpString::print_ctm(this, *(const RB::AffineTransform **)(a1 + 48));
  RB::XML::print_attributes<RB::Coverage::Glyphs>();
}

void *RB::Encoder::typed_message_field<RB::Coverage::Glyphs>(RB::Encoder *a1, uint64_t a2, CGFont **a3)
{
  RB::ProtobufEncoder::encode_varint(a1, (8 * a2) | 2);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::ProtobufEncoder::encode_varint(a1, 0x2AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::Coverage::Glyphs::encode(a3, a1);
  RB::ProtobufEncoder::end_length_delimited(a1);
  return RB::ProtobufEncoder::end_length_delimited(a1);
}

void RB::XML::print_attributes<RB::Coverage::Glyphs>()
{
}

void sub_21416496C(_Unwind_Exception *exception_object)
{
  int v3 = v1[2] - 1;
  v1[2] = v3;
  if (!v3) {
    (*(void (**)(_DWORD *))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(size_t *a1, uint64_t a2, uint64_t a3, int *a4, _DWORD *a5, uint64_t *a6)
{
  uint64_t v10 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v10 + 112 > a1[3]) {
    uint64_t v10 = RB::Heap::alloc_slow(a1, 0x70uLL, 7);
  }
  else {
    a1[2] = v10 + 112;
  }
  int v11 = *a4;
  char v12 = *a5;
  uint64_t v13 = *a6;
  *(void *)(v10 + 16) = 0;
  *(void *)(v10 + 24) = 0;
  *(_DWORD *)(v10 + 40) = 0;
  *(void *)(v10 + 32) = 0;
  *(unsigned char *)(v10 + 44) = v12;
  *(unsigned char *)(v10 + 45) = 0;
  *(void *)uint64_t v10 = &unk_26C4E8D18;
  *(void *)(v10 + 48) = v13;
  *(void *)(v10 + 56) = &unk_26C4EDD28;
  *(void *)(v10 + 64) = *(id *)(a3 + 8);
  long long v14 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(v10 + 72) = v14;
  *(unsigned char *)(v10 + 88) = *(unsigned char *)(a3 + 32);
  *(_WORD *)(v10 + 89) = *(_WORD *)(a3 + 33);
  *(unsigned char *)(v10 + 91) = *(unsigned char *)(a3 + 35);
  *(unsigned char *)(v10 + 92) = *(unsigned char *)(a3 + 36);
  LODWORD(v14) = *(_DWORD *)(a3 + 40);
  *(_DWORD *)(v10 + 96) = v14;
  *(_DWORD *)(v10 + 104) = v11;
  RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::update_bounds(v10, *(double *)&v14, v15);
  return v10;
}

void sub_214164AD0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 56) = v2;

  _Unwind_Resume(a1);
}

void RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::update_bounds(uint64_t a1, double a2, int32x4_t a3)
{
  if (*(unsigned char *)(a1 + 44) == 1)
  {
    *(void *)(a1 + 16) = 0x100000001000000;
    *(int32x2_t *)(a1 + 24) = vdup_n_s32(0x7F7FFFFFu);
  }
  else if (!*(unsigned char *)(a1 + 44))
  {
    LODWORD(a2) = *(_DWORD *)(a1 + 104);
    if (*(float *)&a2 == 0.0)
    {
      *(void *)(a1 + 16) = 0;
      *(void *)(a1 + 24) = 0;
    }
    else
    {
      *(float32x2_t *)(a1 + 16) = RB::Coverage::Stroke<RBStrokeRef>::bounds((void *)(a1 + 56), *(float64x2_t **)(a1 + 48), a2, a3);
      *(void *)(a1 + 24) = v4;
    }
  }
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::~GenericClip(uint64_t a1)
{
  *(void *)(a1 + 56) = &unk_26C4EDD28;

  return a1;
}

void RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::~GenericClip(uint64_t a1)
{
  *(void *)(a1 + 56) = &unk_26C4EDD28;

  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::type_id()
{
  return 16386;
}

void *RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::copy(uint64_t a1, RB::DisplayList::CachedTransform *this, uint64_t a3, int a4)
{
  int64x2_t v7 = (size_t *)(*(void *)(*(void *)this + 8) + 16);
  int v8 = *(char *)(a1 + 44);
  if (a4) {
    int v8 = *(unsigned char *)(a1 + 44) == 0;
  }
  int v14 = v8;
  uint64_t v13 = RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)this, *(const RB::AffineTransform **)(a1 + 48));
  if ((*(unsigned char *)(a1 + 45) & 4) != 0) {
    char v9 = *(unsigned char *)(a1 + 45) & 4;
  }
  else {
    char v9 = 4 * *(unsigned char *)(*(void *)this + 272);
  }
  uint64_t v10 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>(v7, (uint64_t)v7, a1 + 56, (int *)(a1 + 104), &v14, (uint64_t *)&v13);
  *(void *)(v10 + 32) = RB::DisplayList::CachedTransform::transform_metadata(this, *(const RB::DisplayList::Metadata **)(a1 + 32), *(_DWORD *)(a1 + 40));
  *(_DWORD *)(v10 + 40) = v11;
  *(unsigned char *)(v10 + 45) |= v9;
  __n128 result = (void *)((*((void *)this + 3) + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(result + 2) > *((void *)this + 4)) {
    __n128 result = (void *)RB::Heap::alloc_slow((size_t *)this + 1, 0x10uLL, 7);
  }
  else {
    *((void *)this + 3) = result + 2;
  }
  *__n128 result = a3;
  result[1] = v10;
  return result;
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::contains(uint64_t a1, double d0_0, int32x4_t a3)
{
  if (*(unsigned char *)(a1 + 44) != 1) {
    return 0;
  }
  float32x2_t v3 = *(float32x2_t *)&d0_0;
  LODWORD(d0_0) = *(_DWORD *)(a1 + 104);
  if (*(float *)&d0_0 == 0.0) {
    return 1;
  }
  float32x2_t v5 = *(float32x2_t *)a3.i8;
  v11[0] = RB::Coverage::Stroke<RBStrokeRef>::bounds((void *)(a1 + 56), *(float64x2_t **)(a1 + 48), d0_0, a3);
  v11[1] = v6;
  return RB::Rect::intersects(v11, v12, v3, v5, v7, v8, v9, v10) ^ 1;
}

float RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::min_scale(uint64_t a1)
{
  float result = 0.0;
  if (!*(unsigned char *)(a1 + 88) && *(unsigned char *)(a1 + 92) == 1) {
    return 1.0;
  }
  return result;
}

void RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::render(uint64_t a1, double a2, uint64_t a3, uint64_t ***a4, int a5)
{
  double v7 = *(float64x2_t **)(a1 + 48);
  v8.i64[0] = SLODWORD(a2);
  v8.i64[1] = SHIDWORD(a2);
  float64x2_t v9 = v7[1];
  float64x2_t v10 = vaddq_f64(v7[2], vcvtq_f64_s64(v8));
  v13[0] = *v7;
  v13[1] = v9;
  float32x2_t v13[2] = v10;
  uint64_t v11 = a1 + 56;
  float v12 = *(float *)(a1 + 104);
  RB::Coverage::Stroke<RBStrokeRef>::get_info((uint64_t *)(a1 + 56), a4, (uint64_t)v14);
  RB::render_stroke_coverage((uint64_t)a4, v13, v11, (uint64_t)v14, a5, v12);
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned __int8 *)(a1 + 44) != *(unsigned __int8 *)(a3 + 44)) {
    return 0;
  }
  can_mifloat64_t x = RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a3 + 48), (const RB::AffineTransform *)a3);
  if (!can_mix) {
    return 0;
  }
  unsigned __int8 v6 = can_mix;
  if (*(unsigned __int8 *)(a1 + 88) == *(unsigned __int8 *)(a3 + 88)
    && *(unsigned __int8 *)(a1 + 89) == *(unsigned __int8 *)(a3 + 89)
    && *(unsigned __int8 *)(a1 + 90) == *(unsigned __int8 *)(a3 + 90)
    && *(unsigned __int8 *)(a1 + 91) == *(unsigned __int8 *)(a3 + 91)
    && *(unsigned __int8 *)(a1 + 92) == *(unsigned __int8 *)(a3 + 92)
    && *(float *)(a1 + 96) == *(float *)(a3 + 96))
  {
    LOBYTE(result) = RBStrokeRef::can_mix((void *)(a1 + 64), (void *)(a3 + 64));
  }
  else
  {
    LOBYTE(result) = 0;
  }
  if (result >= v6) {
    return v6;
  }
  else {
    return result;
  }
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::mix(uint64_t a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  int64x2_t v8 = (size_t *)(*(void *)(*(void *)&a4->f64[0] + 8) + 16);
  RB::mix(*(CGAffineTransform **)(a1 + 48), *(float64x2_t **)(a3 + 48), (const RB::AffineTransform *)a3, *(float *)(a2 + 16));
  v18[0] = v9;
  v18[1] = v10;
  float64x2_t v18[2] = v11;
  float v17 = *(float *)(a1 + 104) + (float)((float)(*(float *)(a3 + 104) - *(float *)(a1 + 104)) * *(float *)(a2 + 16));
  int v16 = *(char *)(a1 + 44);
  int32x4_t v15 = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v18);
  uint64_t v12 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,float,RB::ClipMode const&,RB::AffineTransform const*>(v8, (uint64_t)v8, a1 + 56, (int *)&v17, &v16, (uint64_t *)&v15);
  *(float *)(v12 + 96) = *(float *)(v12 + 96)
                       + (float)((float)(*(float *)(a3 + 96) - *(float *)(v12 + 96)) * *(float *)(a2 + 16));
  *(int32x2_t *)v13.i8 = vdup_n_s32(0x7F7FFFFFu);
  *(void *)(v12 + 72) = 0x100000001000000;
  *(void *)(v12 + 80) = v13.i64[0];
  RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::update_bounds(v12, 7.29112205e-304, v13);
  return v12;
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::clip(uint64_t a1, CGContextRef *a2)
{
  memset(&v9, 0, sizeof(v9));
  uint64_t v4 = *(float64x2_t **)(a1 + 48);
  int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) != 0) {
    return RBStrokeRef::clip(a1 + 64);
  }
  CGContextGetCTM(&v9, *a2);
  unsigned __int8 v6 = *a2;
  float64x2_t v7 = v4[1];
  *(float64x2_t *)&transform.a = *v4;
  *(float64x2_t *)&transform.c = v7;
  *(float64x2_t *)&transform.tfloat64_t x = v4[2];
  CGContextConcatCTM(v6, &transform);
  RBStrokeRef::clip(a1 + 64);
  CGAffineTransform transform = v9;
  return CGContextSetCTM();
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::fill(uint64_t a1, CGContextRef *a2)
{
  memset(&v9, 0, sizeof(v9));
  uint64_t v4 = *(float64x2_t **)(a1 + 48);
  int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) != 0) {
    return RBStrokeRef::clip(a1 + 64);
  }
  CGContextGetCTM(&v9, *a2);
  unsigned __int8 v6 = *a2;
  float64x2_t v7 = v4[1];
  *(float64x2_t *)&transform.a = *v4;
  *(float64x2_t *)&transform.c = v7;
  *(float64x2_t *)&transform.tfloat64_t x = v4[2];
  CGContextConcatCTM(v6, &transform);
  RBStrokeRef::clip(a1 + 64);
  CGAffineTransform transform = v9;
  return CGContextSetCTM();
}

float RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::cg_alpha(uint64_t a1)
{
  return *(float *)(a1 + 104);
}

uint64_t *RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::prepare_encode(uint64_t a1, uint64_t *a2)
{
  return RBStrokeRef::prepare_encode((uint64_t *)(a1 + 64), a1 + 56, a2);
}

void *RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::encode(uint64_t a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Stroke<RBStrokeRef>>(this, 1, a1 + 56);
  uint64_t v4 = *(float64x2_t **)(a1 + 48);
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x12uLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  int v6 = *(int *)(a1 + 104);
  if (*(float *)&v6 != 1.0)
  {
    RB::ProtobufEncoder::encode_varint(this, 0x1DuLL);
    RB::ProtobufEncoder::encode_fixed32(this, v6);
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Clip::encode((void *)a1, this);
}

void RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "clip");
  RB::DisplayList::Clip::print((RB::DisplayList::Clip *)a1, this);
  float v4 = *(float *)(a1 + 104);
  if (v4 != 1.0) {
    RB::SexpString::printf(this, 0, "(alpha %g)", v4);
  }
  RB::SexpString::print_ctm(this, *(const RB::AffineTransform **)(a1 + 48));
  RB::XML::print_attributes<RB::Coverage::Stroke<RBStrokeRef>>();
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>(size_t *a1, uint64_t a2, uint64_t a3, int *a4, _DWORD *a5, uint64_t *a6)
{
  uint64_t v10 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v10 + 112 > a1[3]) {
    uint64_t v10 = RB::Heap::alloc_slow(a1, 0x70uLL, 7);
  }
  else {
    a1[2] = v10 + 112;
  }
  int v11 = *a4;
  char v12 = *a5;
  uint64_t v13 = *a6;
  *(void *)(v10 + 16) = 0;
  *(void *)(v10 + 24) = 0;
  *(_DWORD *)(v10 + 40) = 0;
  *(void *)(v10 + 32) = 0;
  *(unsigned char *)(v10 + 44) = v12;
  *(unsigned char *)(v10 + 45) = 0;
  *(void *)uint64_t v10 = &unk_26C4E8D18;
  *(void *)(v10 + 48) = v13;
  *(void *)(v10 + 56) = &unk_26C4EDD28;
  *(void *)(v10 + 64) = *(id *)(a3 + 8);
  long long v14 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(v10 + 72) = v14;
  *(unsigned char *)(v10 + 88) = *(unsigned char *)(a3 + 32);
  *(_WORD *)(v10 + 89) = *(_WORD *)(a3 + 33);
  *(unsigned char *)(v10 + 91) = *(unsigned char *)(a3 + 35);
  *(unsigned char *)(v10 + 92) = *(unsigned char *)(a3 + 36);
  LODWORD(v14) = *(_DWORD *)(a3 + 40);
  *(_DWORD *)(v10 + 96) = v14;
  *(_DWORD *)(v10 + 104) = v11;
  RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::update_bounds(v10, *(double *)&v14, v15);
  return v10;
}

void sub_2141654DC(_Unwind_Exception *a1)
{
  *(void *)(v1 + 56) = v2;

  _Unwind_Resume(a1);
}

uint64_t *RB::Coverage::Stroke<RBStrokeRef>::get_info(uint64_t *result, uint64_t ***a2, uint64_t a3)
{
  *(_DWORD *)a3 = *((unsigned __int8 *)result + 32);
  *(_WORD *)(a3 + 4) = *(_WORD *)((char *)result + 33);
  int v4 = *((unsigned __int8 *)result + 35);
  *(_DWORD *)(a3 + 20) = 1065353216;
  *(_DWORD *)(a3 + 8) = v4;
  *(unsigned char *)(a3 + 12) = *((unsigned char *)result + 36);
  *(_DWORD *)(a3 + 16) = *((_DWORD *)result + 10);
  uint64_t v5 = a3 + 20;
  *(void *)(a3 + 24) = 1;
  int v6 = (unint64_t *)(a3 + 24);
  *(void *)(v5 + 12) = 0;
  if (*((unsigned char *)result + 32) == 1)
  {
    uint64_t result = RBStrokeRef::texture((id *)result + 1, *a2, v6, (float *)v5);
    *(void *)(a3 + 32) = result;
  }
  return result;
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,float,RB::ClipMode const&,RB::AffineTransform const*>(size_t *a1, uint64_t a2, uint64_t a3, int *a4, _DWORD *a5, uint64_t *a6)
{
  uint64_t v10 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v10 + 112 > a1[3]) {
    uint64_t v10 = RB::Heap::alloc_slow(a1, 0x70uLL, 7);
  }
  else {
    a1[2] = v10 + 112;
  }
  int v11 = *a4;
  char v12 = *a5;
  uint64_t v13 = *a6;
  *(void *)(v10 + 16) = 0;
  *(void *)(v10 + 24) = 0;
  *(_DWORD *)(v10 + 40) = 0;
  *(void *)(v10 + 32) = 0;
  *(unsigned char *)(v10 + 44) = v12;
  *(unsigned char *)(v10 + 45) = 0;
  *(void *)uint64_t v10 = &unk_26C4E8D18;
  *(void *)(v10 + 48) = v13;
  *(void *)(v10 + 56) = &unk_26C4EDD28;
  *(void *)(v10 + 64) = *(id *)(a3 + 8);
  long long v14 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(v10 + 72) = v14;
  *(unsigned char *)(v10 + 88) = *(unsigned char *)(a3 + 32);
  *(_WORD *)(v10 + 89) = *(_WORD *)(a3 + 33);
  *(unsigned char *)(v10 + 91) = *(unsigned char *)(a3 + 35);
  *(unsigned char *)(v10 + 92) = *(unsigned char *)(a3 + 36);
  LODWORD(v14) = *(_DWORD *)(a3 + 40);
  *(_DWORD *)(v10 + 96) = v14;
  *(_DWORD *)(v10 + 104) = v11;
  RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::update_bounds(v10, *(double *)&v14, v15);
  return v10;
}

void sub_214165694(_Unwind_Exception *a1)
{
  *(void *)(v1 + 56) = v2;

  _Unwind_Resume(a1);
}

void *RB::Encoder::typed_message_field<RB::Coverage::Stroke<RBStrokeRef>>(RB::ProtobufEncoder *a1, uint64_t a2, uint64_t a3)
{
  RB::ProtobufEncoder::encode_varint(a1, (8 * a2) | 2);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::ProtobufEncoder::encode_varint(a1, 0x22uLL);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RBStrokeRef::encode((id *)(a3 + 8), a3, a1);
  RB::ProtobufEncoder::end_length_delimited(a1);
  return RB::ProtobufEncoder::end_length_delimited(a1);
}

void RB::XML::print_attributes<RB::Coverage::Stroke<RBStrokeRef>>()
{
}

void sub_214165814(_Unwind_Exception *exception_object)
{
  int v3 = v1[2] - 1;
  v1[2] = v3;
  if (!v3) {
    (*(void (**)(_DWORD *))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::DisplayList::ItemFactory::operator()<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(uint64_t a1, uint64_t x1_0)
{
  int v4 = *(float32x2_t **)(a1 + 40);
  if (!v4
    || (v12[0] = (float64x2_t)xmmword_2142181C0,
        v12[1] = (float64x2_t)xmmword_2142181D0,
        uint64_t v13 = 0,
        uint64_t v14 = 0,
        float32x2_t v5 = RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(x1_0, v12, 1.0, (int32x4_t)xmmword_2142181D0),
        uint64_t result = RB::Rect::intersects(v4, v15, v5, v6, v7, v8, v9, v10),
        (result & 1) != 0))
  {
    *(void *)&v12[0].f64[0] = a1;
    *(void *)&v12[0].f64[1] = x1_0;
    return (uint64_t)RBFillData::apply<RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>>(*(void **)(a1 + 32), (uint64_t)v12);
  }
  return result;
}

uint64_t RB::DisplayList::ItemFactory::operator()<RB::Coverage::Stroke<RBStrokeRef>>(uint64_t a1, void *x1_0)
{
  int v4 = *(float32x2_t **)(a1 + 40);
  if (!v4
    || (v12[0] = (float64x2_t)xmmword_2142181C0,
        v12[1] = (float64x2_t)xmmword_2142181D0,
        uint64_t v13 = 0,
        uint64_t v14 = 0,
        float32x2_t v5 = RB::Coverage::Stroke<RBStrokeRef>::bounds(x1_0, v12, 1.0, (int32x4_t)xmmword_2142181D0),
        uint64_t result = RB::Rect::intersects(v4, v15, v5, v6, v7, v8, v9, v10),
        (result & 1) != 0))
  {
    *(void *)&v12[0].f64[0] = a1;
    *(void *)&v12[0].f64[1] = x1_0;
    return (uint64_t)RBFillData::apply<RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RBStrokeRef>>>(*(void **)(a1 + 32), (uint64_t *)v12);
  }
  return result;
}

void *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Path>::operator()<RB::Fill::Gradient>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a1;
  if (*(unsigned char *)(*a1 + 48))
  {
    v6[0] = &unk_26C4EA520;
    v6[1] = a1;
    float32x2_t v6[2] = a2;
    RB::Coverage::Path::simplify(a1[1], (uint64_t)v6);
    uint64_t v4 = *a1;
  }
  uint64_t result = *(void **)(v4 + 56);
  if (!result)
  {
    uint64_t result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Path const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v4, *(size_t **)v4, a1[1], a2, (uint64_t *)(v4 + 8), (float *)(v4 + 16), (_DWORD *)(v4 + 20), (__int16 *)(v4 + 24));
    uint64_t v4 = *a1;
    *(void *)(*a1 + 56) = result;
  }
  if (*(unsigned char *)(v4 + 48)) {
    *((_WORD *)result + 23) |= 0x1000u;
  }
  return result;
}

void *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Path>::operator()<RB::Fill::MeshGradient>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  if (*(unsigned char *)(*a1 + 48))
  {
    v6[0] = &unk_26C4E7968;
    v6[1] = a1;
    float32x2_t v6[2] = a2;
    RB::Coverage::Path::simplify(a1[1], (uint64_t)v6);
    uint64_t v4 = *a1;
  }
  uint64_t result = *(void **)(v4 + 56);
  if (!result)
  {
    uint64_t result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Path const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v4, *(size_t **)v4, a1[1], a2, (uint64_t *)(v4 + 8), (float *)(v4 + 16), (_DWORD *)(v4 + 20), (__int16 *)(v4 + 24));
    uint64_t v4 = *a1;
    *(void *)(*a1 + 56) = result;
  }
  if (*(unsigned char *)(v4 + 48)) {
    *((_WORD *)result + 23) |= 0x1000u;
  }
  return result;
}

void *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Path>::operator()<RB::Fill::Custom>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  if (*(unsigned char *)(*a1 + 48))
  {
    v6[0] = &unk_26C4EA500;
    v6[1] = a1;
    float32x2_t v6[2] = a2;
    RB::Coverage::Path::simplify(a1[1], (uint64_t)v6);
    uint64_t v4 = *a1;
  }
  uint64_t result = *(void **)(v4 + 56);
  if (!result)
  {
    uint64_t result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Path const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v4, *(size_t **)v4, a1[1], a2, (uint64_t *)(v4 + 8), (float *)(v4 + 16), (_DWORD *)(v4 + 20));
    uint64_t v4 = *a1;
    *(void *)(*a1 + 56) = result;
  }
  if (*(unsigned char *)(v4 + 48)) {
    *((_WORD *)result + 23) |= 0x1000u;
  }
  return result;
}

void RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Path,RB::Fill::Color>::visit(uint64_t a1, long long *a2)
{
  uint64_t v2 = *(RB::Heap ****)(a1 + 8);
  int v3 = *v2;
  RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Color>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, (uint64_t)**v2, a2, *(void *)(a1 + 16), (uint64_t *)*v2 + 1, (int *)*v2 + 4, (_WORD *)*v2 + 10, (__int16 *)*v2 + 12);
  v3[7] = v4;
}

RB::Heap *RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Path,RB::Fill::Color>::visit(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(RB::Heap ****)(a1 + 8);
  int v3 = *v2;
  uint64_t result = (RB::Heap *)RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, (uint64_t)**v2, a2, *(void *)(a1 + 16), (uint64_t *)*v2 + 1, (float *)*v2 + 4, (_DWORD *)*v2 + 5, (__int16 *)*v2 + 12);
  v3[7] = result;
  return result;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::render(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(float64x2_t **)(a1 + 48);
  float32x2_t v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  unsigned int v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&float32x2_t v12 = (*(double (**)(uint64_t, void))(*(void *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v23, v12, v13);
  int v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5) {
    goto LABEL_10;
  }
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v23[0].f64[0], *(int32x2_t *)&v23[0].f64[1]))
  {
    int v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v23, v14, _S8);
    goto LABEL_11;
  }
  int v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4) {
    goto LABEL_10;
  }
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11) {
    goto LABEL_10;
  }
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::StrokeablePath::clip(a1 + 64, a1 + 56, a2);
  v23[0] = (float64x2_t)xmmword_2142181C0;
  v23[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  float32x2_t v16 = RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, v23, 1.0, (int32x4_t)xmmword_2142181D0);
  RB::Bounds::Bounds(v26, v16, v17);
  RB::Fill::Gradient::fill(a1 + 144, (RB::CGContext *)a2, *(double *)v26, *(double *)&v26[1], v18, v19, v20, v21, v22);
  RB::CGContext::restore((RB::CGContext *)a2);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::render(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(float64x2_t **)(a1 + 48);
  float32x2_t v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  unsigned int v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&float32x2_t v12 = (*(double (**)(uint64_t, void))(*(void *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)&v16, v12, v13);
  int v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5) {
    goto LABEL_10;
  }
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v16, *(int32x2_t *)((char *)&v16 + 8)))
  {
    int v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, &v16, v14, _S8);
    goto LABEL_11;
  }
  int v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4) {
    goto LABEL_10;
  }
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11) {
    goto LABEL_10;
  }
LABEL_11:
  RB::Coverage::StrokeablePath::fill(a1 + 64, a1 + 56, a2, a1 + 144);
}

void *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16 = *((void *)this + 3);
  uint64_t v17 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 160 > v16) {
    uint64_t v17 = RB::Heap::alloc_slow((size_t *)this, 0xA0uLL, 7);
  }
  else {
    *((void *)this + 2) = v17 + 160;
  }
  uint64_t result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  *uint64_t result = &unk_26C4E9C00;
  return result;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::render(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(float64x2_t **)(a1 + 48);
  float32x2_t v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  unsigned int v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&float32x2_t v12 = (*(double (**)(uint64_t, void))(*(void *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v23, v12, v13);
  int v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5) {
    goto LABEL_10;
  }
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v23[0], *(int32x2_t *)((char *)v23 + 8)))
  {
    int v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v23, v14, _S8);
    goto LABEL_11;
  }
  int v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4) {
    goto LABEL_10;
  }
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11) {
    goto LABEL_10;
  }
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::Path::clip((RB::Coverage::Path *)(a1 + 56), (CGContextRef *)a2);
  v23[0] = xmmword_2142181C0;
  v23[1] = xmmword_2142181D0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  v27.callbacks = (RBPathCallbacks *)v23;
  v27.mach_timebase_info info = (void *)(a1 + 56);
  double v16 = RB::Coverage::Path::bounds(v27);
  RB::Bounds::Bounds(v26, *(float32x2_t *)&v16, v17);
  RB::Fill::Gradient::fill(a1 + 88, (RB::CGContext *)a2, *(double *)v26, *(double *)&v26[1], v18, v19, v20, v21, v22);
  RB::CGContext::restore((RB::CGContext *)a2);
}

void *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Path const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, size_t *a2, uint64_t a3, uint64_t *a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16 = *((void *)this + 3);
  uint64_t v17 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 152 > v16) {
    uint64_t v17 = RB::Heap::alloc_slow((size_t *)this, 0x98uLL, 7);
  }
  else {
    *((void *)this + 2) = v17 + 152;
  }
  uint64_t result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  *uint64_t result = &unk_26C4E9228;
  return result;
}

unint64_t RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Path,RB::Fill::Gradient>::visit(uint64_t a1, long long *a2)
{
  uint64_t v2 = *(size_t ****)(a1 + 8);
  int v3 = *v2;
  unint64_t result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, (RB::Heap *)**v2, a2, *(uint64_t **)(a1 + 16), (uint64_t *)*v2 + 1, (int *)*v2 + 4, (_WORD *)*v2 + 10, (__int16 *)*v2 + 12);
  v3[7] = (size_t *)result;
  return result;
}

RB::Heap *RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Path,RB::Fill::Gradient>::visit(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(RB::Heap ****)(a1 + 8);
  int v3 = *v2;
  unint64_t result = (RB::Heap *)RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, **v2, a2, *(uint64_t **)(a1 + 16), (uint64_t *)*v2 + 1, (float *)*v2 + 4, (_DWORD *)*v2 + 5, (__int16 *)*v2 + 12);
  v3[7] = result;
  return result;
}

void *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, RB::Heap *a2, uint64_t a3, uint64_t *a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16 = *((void *)this + 3);
  uint64_t v17 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 208 > v16) {
    uint64_t v17 = RB::Heap::alloc_slow((size_t *)this, 0xD0uLL, 7);
  }
  else {
    *((void *)this + 2) = v17 + 208;
  }
  unint64_t result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  *unint64_t result = &unk_26C4E9F48;
  return result;
}

void *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Path const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, size_t *a2, uint64_t a3, uint64_t a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16 = *((void *)this + 3);
  uint64_t v17 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 136 > v16) {
    uint64_t v17 = RB::Heap::alloc_slow((size_t *)this, 0x88uLL, 7);
  }
  else {
    *((void *)this + 2) = v17 + 136;
  }
  unint64_t result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  *unint64_t result = &unk_26C4E73F0;
  return result;
}

unint64_t RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Path,RB::Fill::MeshGradient>::visit(uint64_t a1, long long *a2)
{
  uint64_t v2 = *(size_t ****)(a1 + 8);
  int v3 = *v2;
  unint64_t result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, (RB::Heap *)**v2, a2, *(void *)(a1 + 16), (uint64_t *)*v2 + 1, (int *)*v2 + 4, (__int16 *)*v2 + 10, (__int16 *)*v2 + 12);
  v3[7] = (size_t *)result;
  return result;
}

RB::Heap *RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Path,RB::Fill::MeshGradient>::visit(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(RB::Heap ****)(a1 + 8);
  int v3 = *v2;
  unint64_t result = (RB::Heap *)RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, **v2, a2, *(void *)(a1 + 16), (uint64_t *)*v2 + 1, (float *)*v2 + 4, (_DWORD *)*v2 + 5, (__int16 *)*v2 + 12);
  v3[7] = result;
  return result;
}

unint64_t RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(size_t *a1, RB::Heap *a2, long long *a3, uint64_t a4, uint64_t *a5, int *a6, __int16 *a7, __int16 *a8)
{
  unint64_t v15 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v15 + 160 > a1[3]) {
    unint64_t v15 = RB::Heap::alloc_slow(a1, 0xA0uLL, 15);
  }
  else {
    a1[2] = v15 + 160;
  }
  uint64_t v16 = *a5;
  _S0 = *a6;
  __int16 v18 = *a7;
  __int16 v19 = *a8;
  __asm { FCVT            H0, S0 }
  *(void *)(v15 + 16) = 0;
  *(void *)(v15 + 24) = 0;
  *(_DWORD *)(v15 + 40) = 0;
  *(void *)(v15 + 32) = 0;
  *(_WORD *)(v15 + 44) = _S0;
  *(_WORD *)(v15 + 46) = v18 & 0x3F | 0x4000;
  *(void *)unint64_t v15 = &unk_26C4E7E08;
  *(void *)(v15 + 48) = v16;
  long long v24 = *a3;
  long long v25 = a3[1];
  *(_OWORD *)(v15 + 95) = *(long long *)((char *)a3 + 31);
  *(_OWORD *)(v15 + 64) = v24;
  *(_OWORD *)(v15 + 80) = v25;
  RB::Fill::MeshGradient::MeshGradient(v15 + 112, a4, v19, a2);
  *(void *)unint64_t v15 = &unk_26C4E7850;
  return v15;
}

void *RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::MeshGradient>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4E7E08;
  uint64_t v2 = (atomic_uint *)a1[15];
  if (v2 && atomic_fetch_add_explicit(v2 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::MeshGradient>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4E7E08;
  uint64_t v1 = (atomic_uint *)a1[15];
  if (v1 && atomic_fetch_add_explicit(v1 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::type_id()
{
  return 20975617;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::MeshGradient>::copy(uint64_t a1, uint64_t a2)
{
  int v3 = (size_t *)(*(void *)(a2 + 8) + 16);
  int v6 = *(_WORD *)(a1 + 46) & 0x3F;
  uint64_t v4 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill12MeshGradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v3, (RB::Heap *)v3, (long long *)(a1 + 64), a1 + 112, (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), (__int16 *)&v6);
  __n128 result = *(__n128 *)(a1 + 16);
  v4[1] = result;
  v4[2].n128_u64[0] = *(void *)(a1 + 32);
  v4[2].n128_u32[2] = *(_DWORD *)(a1 + 40);
  v4[2].n128_u16[7] |= *(_WORD *)(a1 + 46) & 0x5800;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  __n128 result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::atom_position(uint64_t a1, int8x16_t a2, int32x4_t a3, int8x16_t a4, int32x4_t a5)
{
  float32x2_t v5 = RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), *(float64x2_t **)(a1 + 48), a2, a3, a4, a5);
  return vmla_f32(v5, (float32x2_t)0x3F0000003F000000, v6);
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::MeshGradient>::copy_shadow(__n128 *a1, uint64_t a2, uint64_t a3)
{
  if ((*(unsigned char *)(a3 + 88) & 0x10) == 0)
  {
    float v28 = 0.0;
    if (RB::Fill::MeshGradient::get_alpha((RB::Fill::MeshGradient *)&a1[7], &v28))
    {
      if ((RB::DisplayList::Item::clip_affects_blurred_bounds((RB::DisplayList::Item *)a1, *(float *)(a3 + 64)) & 1) == 0)
      {
        memset(v25, 0, sizeof(v25));
        int v26 = 1065353216;
        v27[0] = 0;
        *(_DWORD *)((char *)v27 + 7) = 0;
        double v7 = *(float64x2_t **)(a3 + 16);
        double v8 = (float64x2_t *)a1[3].n128_u64[0];
        float64x2_t v9 = *v8;
        float64x2_t v10 = v8[2];
        float64x2_t v30 = v8[1];
        float64x2_t v31 = v10;
        float64x2_t v29 = v9;
        if (RB::AffineTransform::invert((RB::AffineTransform *)&v29)) {
          unsigned int v11 = &v29;
        }
        else {
          unsigned int v11 = v8;
        }
        float64x2_t v12 = v11[1];
        float64x2_t v13 = v11[2];
        v24[0] = *v11;
        v24[1] = v12;
        float32x2_t v24[2] = v13;
        v14.f64[0] = RB::operator*(v7, v24);
        float64x2_t v29 = v14;
        float64x2_t v30 = v15;
        float64x2_t v31 = v16;
        if (RB::Coverage::Primitive::make_shadow((RB::Coverage::Primitive *)&a1[4], &v29, *(float *)(a3 + 64), &v28, (*(_DWORD *)(a3 + 88) >> 2) & 1, (RB::Coverage::Primitive *)v25))
        {
          _H1 = a1[2].n128_u16[6];
          __asm { FCVT            S1, H1 }
          RB::DisplayList::ShadowStyle::make_primitive(a3, a2, v25, a1[3].n128_i64[0], a1[2].n128_u16[7] & 0x3F, v28, _S1);
          __n128 result = a1[1];
          v23[1] = result;
          v23[2].n128_u64[0] = a1[2].n128_u64[0];
          v23[2].n128_u32[2] = a1[2].n128_u32[2];
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::can_make_clip()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::make_clip(uint64_t a1, uint64_t a2, unsigned int a3, void *a4, float a5)
{
  float v22 = 0.0;
  unsigned int v23 = a3;
  if (RB::Fill::MeshGradient::get_alpha((RB::Fill::MeshGradient *)(a1 + 112), &v22))
  {
    unsigned int v11 = (size_t *)(*(void *)(a2 + 8) + 16);
    _Q0.n128_u16[0] = *(_WORD *)(a1 + 44);
    __asm { FCVT            S0, H0 }
    _Q0.n128_f32[0] = _Q0.n128_f32[0] * (float)(a5 * v22);
    unsigned __int32 v21 = _Q0.n128_u32[0];
    uint64_t v16 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v11, (int8x16_t)_Q0, (uint64_t)v11, (_OWORD *)(a1 + 64), &v21, (int *)&v23, (uint64_t *)(a1 + 48));
    uint64_t v17 = a4[5];
    size_t v18 = v17 + 1;
    if (a4[6] < (unint64_t)(v17 + 1))
    {
      RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v18);
      uint64_t v17 = a4[5];
      size_t v18 = v17 + 1;
    }
    __int16 v19 = (void *)a4[4];
    if (!v19) {
      __int16 v19 = a4;
    }
    v19[v17] = v16;
    a4[5] = v18;
    return (**(uint64_t (***)(uint64_t))a1)(a1);
  }
  else
  {
    _Q0.n128_f32[0] = a5;
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, _Q0);
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::can_append_color_matrix()
{
  return 1;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::append_color_matrix(uint64_t a1, float16x4_t *a2, uint64_t a3, __int16 a4)
{
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::MeshGradient>::append_blur()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 152);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::bounds(uint64_t a1, int8x16_t a2, int32x4_t a3, int8x16_t a4, int32x4_t a5)
{
  return RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), *(float64x2_t **)(a1 + 48), a2, a3, a4, a5);
}

float RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::min_scale(uint64_t a1)
{
  float result = 0.0;
  if (*(unsigned __int8 *)(a1 + 108) >= 2u && *(unsigned char *)(a1 + 109) == 1) {
    return 1.0;
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::has_no_effect(uint64_t a1)
{
  __asm { FCMP            H0, #0 }
  if (_ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  else {
    return 0;
  }
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::render(uint64_t a1, double a2, uint64_t a3, uint64_t a4, int a5, unsigned int a6)
{
  float32x2_t v6 = *(float64x2_t **)(a1 + 48);
  v7.i64[0] = SLODWORD(a2);
  v7.i64[1] = SHIDWORD(a2);
  float64x2_t v8 = v6[1];
  _Q0 = vaddq_f64(v6[2], vcvtq_f64_s64(v7));
  v14[0] = *v6;
  v14[1] = v8;
  float32x2_t v14[2] = _Q0;
  LOWORD(_Q0.f64[0]) = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  RB::render_primitive(a4, v14, a1 + 64, (RB::Fill::MeshGradient *)(a1 + 112), a5, a6, *(float *)_Q0.f64);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::render(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(float64x2_t **)(a1 + 48);
  float32x2_t v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  unsigned int v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&float32x2_t v12 = (*(double (**)(uint64_t, void))(*(void *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v20, v12, v13);
  int v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5) {
    goto LABEL_10;
  }
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v20[0].f64[0], *(int32x2_t *)&v20[0].f64[1]))
  {
    int v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v20, v14, _S8);
    goto LABEL_11;
  }
  int v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4) {
    goto LABEL_10;
  }
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11) {
    goto LABEL_10;
  }
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::Primitive::clip((float32x2_t *)(a1 + 64), (CGContext **)a2);
  v20[0] = (float64x2_t)xmmword_2142181C0;
  v20[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  float32x2_t v18 = RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), v20, (int8x16_t)xmmword_2142181C0, (int32x4_t)xmmword_2142181D0, v16, v17);
  RB::Bounds::Bounds(v23, v18, v19);
  RB::Fill::MeshGradient::fill((int32x2_t *)(a1 + 112), (int8x8_t *)a2, v23[0], v23[1]);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 112), a2);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::prepare_mix(float64x2_t **a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, float64x2_t **a4)
{
  float result = (unint64_t *)(*(uint64_t (**)(float64x2_t **))&(*a4)[1].f64[0])(a4);
  if (result == 20975617)
  {
    float result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      float result = (unint64_t *)RB::can_mix(a1[6], a4[6], v10);
      int v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        float result = (unint64_t *)RB::Coverage::Primitive::can_mix((uint64_t)(a1 + 8), (uint64_t)a3, (uint64_t)(a4 + 8));
        if ((_BYTE)result)
        {
          unsigned __int8 v13 = result;
          can_mifloat64_t x = RB::Fill::MeshGradient::can_mix((RB::Fill::MeshGradient *)(a1 + 14), (const RB::Fill::MeshGradient *)(a4 + 14), v12);
          return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v13, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8 = (*(uint64_t (**)(CGAffineTransform **, void, void, void, uint64_t))&(*a1)[1].a)(a1, *(void *)&a4->f64[0], *(unsigned int *)(*(void *)(a2 + 8) + 12), **(void **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v17[0] = v10;
  v17[1] = v11;
  v17[2] = v12;
  *(void *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v17);
  LODWORD(v13) = *(_DWORD *)(a2 + 16);
  RB::Fill::MeshGradient::mix((RB::Fill::MeshGradient *)(v8 + 112), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::MeshGradient *)(a3 + 112), v13, (RB::Heap *)(*(void *)(*(void *)&a4->f64[0] + 8) + 16));
  RB::operator*((float64x2_t *)a1[6], a4 + 68);
  double v14 = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  RB::Coverage::Primitive::mix(v8 + 64, a2, a3 + 64, v14, v15);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(unsigned char *)(*(void *)&a4->f64[0] + 272)) {
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

void *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::encode(float32x4_t *a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Primitive>(this, 1, a1 + 4);
  RB::Encoder::typed_message_field<RB::Fill::MeshGradient>(this, 2, (RB::Fill::MeshGradient *)&a1[7]);
  uint64_t v4 = (float64x2_t *)a1[3].i64[0];
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::print(const RB::AffineTransform **a1, std::string *this)
{
}

unint64_t _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill12MeshGradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(size_t *a1, RB::Heap *a2, long long *a3, uint64_t a4, uint64_t *a5, __int16 *a6, __int16 *a7)
{
  unint64_t v13 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v13 + 160 > a1[3]) {
    unint64_t v13 = RB::Heap::alloc_slow(a1, 0xA0uLL, 15);
  }
  else {
    a1[2] = v13 + 160;
  }
  uint64_t v14 = *a5;
  __int16 v15 = *a6;
  __int16 v16 = *a7;
  *(void *)(v13 + 16) = 0;
  *(void *)(v13 + 24) = 0;
  *(_DWORD *)(v13 + 40) = 0;
  *(void *)(v13 + 32) = 0;
  *(_WORD *)(v13 + 44) = v15;
  *(_WORD *)(v13 + 46) = v16 & 0x3F | 0x4000;
  *(void *)unint64_t v13 = &unk_26C4E7E08;
  *(void *)(v13 + 48) = v14;
  long long v17 = *a3;
  long long v18 = a3[1];
  *(_OWORD *)(v13 + 95) = *(long long *)((char *)a3 + 31);
  *(_OWORD *)(v13 + 64) = v17;
  *(_OWORD *)(v13 + 80) = v18;
  RB::Fill::MeshGradient::MeshGradient(v13 + 112, a4, 0, a2);
  *(void *)unint64_t v13 = &unk_26C4E7850;
  return v13;
}

__n128 RB::DisplayList::GenericItemCopyVisitor<RB::Fill::MeshGradient>::visit_<RB::Coverage::Primitive>(void *a1, long long *a2)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1 + 4;
  int64x2_t v5 = (size_t *)a1[1];
  uint64_t v6 = a1[2];
  int v10 = *(_WORD *)(v6 + 46) & 0x3F;
  int64x2_t v7 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill12MeshGradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, (RB::Heap *)v5, a2, v3, v4, (__int16 *)(v6 + 44), (__int16 *)&v10);
  a1[5] = v7;
  uint64_t v8 = (__n128 *)a1[2];
  __n128 result = v8[1];
  v7[1] = result;
  v7[2].n128_u64[0] = v8[2].n128_u64[0];
  v7[2].n128_u32[2] = v8[2].n128_u32[2];
  v7[2].n128_u16[7] |= v8[2].n128_u16[7] & 0x5800;
  return result;
}

__n128 RB::DisplayList::GenericItemCopyVisitor<RB::Fill::MeshGradient>::visit_<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1 + 4;
  int64x2_t v5 = (RB::Heap *)a1[1];
  uint64_t v6 = a1[2];
  int v10 = *(_WORD *)(v6 + 46) & 0x3F;
  int64x2_t v7 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill12MeshGradientEEEJRS0_RKS7_RKS9_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, v5, a2, v3, v4, (__int16 *)(v6 + 44), &v10);
  a1[5] = v7;
  uint64_t v8 = (__n128 *)a1[2];
  __n128 result = v8[1];
  v7[1] = result;
  v7[2].n128_u64[0] = v8[2].n128_u64[0];
  v7[2].n128_u32[2] = v8[2].n128_u32[2];
  v7[2].n128_u16[7] |= v8[2].n128_u16[7] & 0x5800;
  return result;
}

void *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill12MeshGradientEEEJRS0_RKS7_RKS9_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, RB::Heap *a2, uint64_t a3, uint64_t a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14 = *((void *)this + 3);
  uint64_t v15 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 192 > v14) {
    uint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0xC0uLL, 7);
  }
  else {
    *((void *)this + 2) = v15 + 192;
  }
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  __n128 result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  *__n128 result = &unk_26C4E7738;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::GenericItem1(uint64_t a1, RB::Heap *a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  __asm { FCVT            H0, S0 }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F | 0x4000;
  *(void *)a1 = &unk_26C4E7CF0;
  *(void *)(a1 + 48) = a5;
  *(void *)(a1 + 56) = &unk_26C4EDD48;
  RB::Coverage::StrokeablePath::StrokeablePath(a1 + 64, a3 + 8, a2);
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a3 + 56);
  *(unsigned char *)(a1 + 128) = *(unsigned char *)(a3 + 72);
  *(_WORD *)(a1 + 129) = *(_WORD *)(a3 + 73);
  *(unsigned char *)(a1 + 131) = *(unsigned char *)(a3 + 75);
  *(unsigned char *)(a1 + 132) = *(unsigned char *)(a3 + 76);
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a3 + 80);
  RB::Fill::MeshGradient::MeshGradient(a1 + 144, a4, a7, a2);
  return a1;
}

void sub_2141673B8(_Unwind_Exception *a1)
{
  v1[7] = v2;
  RBPathRelease(v1[8], v1[9]);
  _Unwind_Resume(a1);
}

void *RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4E7CF0;
  uint64_t v2 = (atomic_uint *)a1[19];
  if (v2 && atomic_fetch_add_explicit(v2 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
  }
  a1[7] = &unk_26C4EDD48;
  RBPathRelease(a1[8], a1[9]);
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4E7CF0;
  uint64_t v2 = (atomic_uint *)a1[19];
  if (v2 && atomic_fetch_add_explicit(v2 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
  }
  a1[7] = &unk_26C4EDD48;
  RBPathRelease(a1[8], a1[9]);
  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::type_id()
{
  return 20983809;
}

void *RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::copy(uint64_t a1, uint64_t a2, char a3)
{
  __int16 v4 = 0;
  int64x2_t v5 = (uint64_t (**)(void, long long *))(*(void *)(a2 + 8) + 16);
  __int16 v6 = *(_WORD *)(a1 + 46);
  if ((a3 & 2) != 0) {
    goto LABEL_9;
  }
  if ((*(_WORD *)(a1 + 46) & 0x1000) != 0 || *(unsigned char *)(a2 + 272) == 0) {
    goto LABEL_9;
  }
  v10[0] = (uint64_t (**)(void, long long *))&unk_26C4E7F50;
  v10[1] = v5;
  _DWORD v10[2] = (uint64_t (**)(void, long long *))a1;
  float64x2_t v10[3] = (uint64_t (**)(void, long long *))(a1 + 144);
  v10[4] = *(uint64_t (***)(void, long long *))(a1 + 48);
  uint64_t v11 = 0;
  RB::Coverage::StrokeablePath::simplify(a1 + 64, a1 + 56, v10);
  __n128 result = (void *)v11;
  if (!v11)
  {
    __int16 v6 = *(_WORD *)(a1 + 46);
    __int16 v4 = 4096;
LABEL_9:
    LODWORD(v10[0]) = v6 & 0x3F;
    __n128 result = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill12MeshGradientEEEJRS0_RKS7_RKS9_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_((RB::Heap *)v5, (RB::Heap *)v5, a1 + 56, a1 + 144, (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), v10);
    *((_OWORD *)result + 1) = *(_OWORD *)(a1 + 16);
    result[4] = *(void *)(a1 + 32);
    *((_DWORD *)result + 10) = *(_DWORD *)(a1 + 40);
    __int16 v9 = *((_WORD *)result + 23) | *(_WORD *)(a1 + 46) & 0x5800;
    *((_WORD *)result + 23) = v9;
    goto LABEL_10;
  }
  __int16 v9 = *(_WORD *)(v11 + 46);
  __int16 v4 = 4096;
LABEL_10:
  *((_WORD *)result + 23) = v9 | v4;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  __n128 result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::atom_position(uint64_t a1, double a2, int32x4_t a3)
{
  float32x2_t v3 = RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, *(float64x2_t **)(a1 + 48), a2, a3);
  return vmla_f32(v3, (float32x2_t)0x3F0000003F000000, v4);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::can_make_clip()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::make_clip(uint64_t a1, uint64_t a2, unsigned int a3, void *a4, float a5)
{
  float v24 = 0.0;
  unsigned int v25 = a3;
  if (RB::Fill::MeshGradient::get_alpha((RB::Fill::MeshGradient *)(a1 + 144), &v24))
  {
    uint64_t v11 = (size_t *)(*(void *)(a2 + 8) + 16);
    _H0 = *(_WORD *)(a1 + 44);
    __asm { FCVT            S0, H0 }
    float v23 = _S0 * (float)(a5 * v24);
    uint64_t v18 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath>&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v11, (uint64_t)v11, a1 + 56, (int *)&v23, &v25, (uint64_t *)(a1 + 48));
    uint64_t v19 = a4[5];
    size_t v20 = v19 + 1;
    if (a4[6] < (unint64_t)(v19 + 1))
    {
      RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v20);
      uint64_t v19 = a4[5];
      size_t v20 = v19 + 1;
    }
    uint64_t v21 = (void *)a4[4];
    if (!v21) {
      uint64_t v21 = a4;
    }
    v21[v19] = v18;
    a4[5] = v20;
    return (**(uint64_t (***)(uint64_t))a1)(a1);
  }
  else
  {
    v10.n128_f32[0] = a5;
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, v10);
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::can_append_color_matrix()
{
  return 1;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::append_color_matrix(uint64_t a1, float16x4_t *a2, uint64_t a3, __int16 a4)
{
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 184);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::bounds(uint64_t a1, double a2, int32x4_t a3)
{
  return RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, *(float64x2_t **)(a1 + 48), a2, a3);
}

float RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::min_scale(uint64_t a1)
{
  float result = 0.0;
  if (!*(unsigned char *)(a1 + 128) && *(unsigned char *)(a1 + 132) == 1) {
    return 1.0;
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::has_no_effect(uint64_t a1)
{
  __asm { FCMP            H0, #0 }
  if (_ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  else {
    return 0;
  }
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::render(uint64_t a1, double a2, uint64_t a3, void *a4, char a5, int a6)
{
  uint64_t v6 = *(void *)(a1 + 48);
  v7.i64[0] = SLODWORD(a2);
  v7.i64[1] = SHIDWORD(a2);
  long long v8 = *(_OWORD *)(v6 + 16);
  float64x2_t v9 = vaddq_f64(*(float64x2_t *)(v6 + 32), vcvtq_f64_s64(v7));
  v16[0] = *(_OWORD *)v6;
  v16[1] = v8;
  _OWORD v16[2] = v9;
  _H0 = *(_WORD *)(a1 + 44);
  int v17 = *(unsigned __int8 *)(a1 + 128);
  __int16 v18 = *(_WORD *)(a1 + 129);
  int v19 = *(unsigned __int8 *)(a1 + 131);
  char v20 = *(unsigned char *)(a1 + 132);
  int v21 = *(_DWORD *)(a1 + 136);
  int v22 = 1065353216;
  uint64_t v23 = 1;
  uint64_t v24 = 0;
  if (v17 == 1) {
    abort();
  }
  __asm { FCVT            S0, H0 }
  RB::render_stroke(a4, (uint64_t (**)(void, void *, __n128, __n128))v16, a1 + 56, (uint64_t)&v17, (uint64_t (**)(void, void *, __n128, __n128))(a1 + 144), a5, a6, _S0);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::render(int32x2_t *a1, uint64_t a2)
{
  float32x2_t v4 = (float64x2_t *)a1[6];
  int64x2_t v5 = (float32x2_t *)a1[3];
  _H0 = a1[5].i16[2];
  __asm { FCVT            S8, H0 }
  unsigned int v11 = a1[5].i16[3] & 0x3F;
  *(double *)&float32x2_t v12 = (*(double (**)(int32x2_t *, void))(*(void *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v18, v12, v13);
  int v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5) {
    goto LABEL_10;
  }
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v18[0].f64[0], *(int32x2_t *)&v18[0].f64[1]))
  {
    int v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v18, v14, _S8);
    goto LABEL_11;
  }
  int v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4) {
    goto LABEL_10;
  }
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11) {
    goto LABEL_10;
  }
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::StrokeablePath::clip((uint64_t)&a1[8], (size_t)&a1[7], a2);
  v18[0] = (float64x2_t)xmmword_2142181C0;
  v18[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  float32x2_t v16 = RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds((uint64_t)&a1[7], v18, 1.0, (int32x4_t)xmmword_2142181D0);
  RB::Bounds::Bounds(v21, v16, v17);
  RB::Fill::MeshGradient::fill(a1 + 18, (int8x8_t *)a2, v21[0], v21[1]);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 144), a2);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, uint64_t a4)
{
  float result = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)a4 + 16))(a4);
  if (result == 20983809)
  {
    float result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      float result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a4 + 48), v10);
      int v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        if (*(unsigned __int8 *)(a1 + 128) == *(unsigned __int8 *)(a4 + 128)
          && *(unsigned __int8 *)(a1 + 129) == *(unsigned __int8 *)(a4 + 129)
          && *(unsigned __int8 *)(a1 + 130) == *(unsigned __int8 *)(a4 + 130)
          && *(unsigned __int8 *)(a1 + 131) == *(unsigned __int8 *)(a4 + 131)
          && *(unsigned __int8 *)(a1 + 132) == *(unsigned __int8 *)(a4 + 132)
          && *(float *)(a1 + 136) == *(float *)(a4 + 136))
        {
          float result = (unint64_t *)RB::Coverage::StrokeablePath::can_mix(a1 + 64, a4 + 64, v12);
          if ((_BYTE)result)
          {
            unsigned __int8 v14 = result;
            can_mifloat64_t x = RB::Fill::MeshGradient::can_mix((RB::Fill::MeshGradient *)(a1 + 144), (const RB::Fill::MeshGradient *)(a4 + 144), v13);
            return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v14, can_mix);
          }
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8 = (*(uint64_t (**)(CGAffineTransform **, void, void, void, uint64_t))&(*a1)[1].a)(a1, *(void *)&a4->f64[0], *(unsigned int *)(*(void *)(a2 + 8) + 12), **(void **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v27[0] = v10;
  v27[1] = v11;
  long long v27[2] = v12;
  *(void *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v27);
  float32x2_t v13 = (RB::Heap *)(*(void *)(*(void *)&a4->f64[0] + 8) + 16);
  LODWORD(v14) = *(_DWORD *)(a2 + 16);
  RB::Fill::MeshGradient::mix((RB::Fill::MeshGradient *)(v8 + 144), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::MeshGradient *)(a3 + 144), v14, v13);
  *(double *)&long long v15 = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  long long v24 = v15;
  long long v25 = v16;
  long long v26 = v17;
  *(double *)&long long v18 = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  v23[0] = v18;
  v23[1] = v19;
  int32x2_t v23[2] = v20;
  LODWORD(v18) = *(_DWORD *)(a2 + 16);
  RB::Coverage::StrokeablePath::mix(v8 + 64, v13, a3 + 64, (uint64_t)&v24, (uint64_t)v23, *(void *)(v8 + 48), *(CGFloat *)&v18);
  *(float *)(v8 + 136) = *(float *)(v8 + 136)
                       + (float)((float)(*(float *)(a3 + 136) - *(float *)(v8 + 136)) * *(float *)(a2 + 16));
  *(void *)(v8 + 112) = 0x100000001000000;
  *(int32x2_t *)(v8 + 120) = vdup_n_s32(0x7F7FFFFFu);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(unsigned char *)(*(void *)&a4->f64[0] + 272))
  {
    *(void *)&long long v24 = &unk_26C4E7F50;
    *((void *)&v24 + 1) = v13;
    *(void *)&long long v25 = v8;
    *((void *)&v25 + 1) = v8 + 144;
    long long v26 = *(unint64_t *)(v8 + 48);
    RB::Coverage::StrokeablePath::simplify(v8 + 64, v8 + 56, (uint64_t (***)(void, long long *))&v24);
    if (*((void *)&v26 + 1))
    {
      *(void *)uint64_t v8 = &unk_26C4E7CF0;
      int v21 = *(atomic_uint **)(v8 + 152);
      if (v21 && atomic_fetch_add_explicit(v21 + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        (*(void (**)(atomic_uint *))(*(void *)v21 + 8))(v21);
      }
      *(void *)(v8 + 56) = &unk_26C4EDD48;
      RBPathRelease(*(void *)(v8 + 64), *(void *)(v8 + 72));
      uint64_t v8 = *((void *)&v26 + 1);
    }
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

void *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::encode(void *a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(this, 1, (uint64_t)(a1 + 7));
  RB::Encoder::typed_message_field<RB::Fill::MeshGradient>(this, 2, (RB::Fill::MeshGradient *)(a1 + 18));
  float32x2_t v4 = (float64x2_t *)a1[6];
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::print(const RB::AffineTransform **a1, std::string *this)
{
}

void *RB::Encoder::typed_message_field<RB::Fill::MeshGradient>(RB::Encoder *a1, uint64_t a2, RB::Fill::MeshGradient *a3)
{
  RB::ProtobufEncoder::encode_varint(a1, (8 * a2) | 2);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::ProtobufEncoder::encode_varint(a1, 0x2AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::Fill::MeshGradient::encode(a3, a1);
  RB::ProtobufEncoder::end_length_delimited(a1);
  return RB::ProtobufEncoder::end_length_delimited(a1);
}

void RB::XML::print_attributes<RB::Fill::MeshGradient>()
{
}

void sub_214168128(_Unwind_Exception *exception_object)
{
  int v3 = v1[2] - 1;
  v1[2] = v3;
  if (!v3) {
    (*(void (**)(_DWORD *))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, RB::Heap *a2, uint64_t a3, uint64_t a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16 = *((void *)this + 3);
  uint64_t v17 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 192 > v16) {
    uint64_t v17 = RB::Heap::alloc_slow((size_t *)this, 0xC0uLL, 7);
  }
  else {
    *((void *)this + 2) = v17 + 192;
  }
  float result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  *float result = &unk_26C4E7738;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::GenericItem1(uint64_t a1, size_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  __asm { FCVT            H0, S0 }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F | 0x4000;
  *(void *)a1 = &unk_26C4E79A8;
  *(void *)(a1 + 48) = a5;
  *(void *)(a1 + 56) = RBPathRetain(*(void *)a3, *(void *)(a3 + 8));
  *(void *)(a1 + 64) = v18;
  long long v19 = *(long long **)(a3 + 16);
  if (v19)
  {
    long long v20 = (_OWORD *)((a2[2] + 15) & 0xFFFFFFFFFFFFFFF0);
    if ((unint64_t)(v20 + 3) > a2[3]) {
      long long v20 = (_OWORD *)RB::Heap::alloc_slow(a2, 0x30uLL, 15);
    }
    else {
      a2[2] = (size_t)(v20 + 3);
    }
    long long v21 = *v19;
    long long v22 = v19[2];
    v20[1] = v19[1];
    float64x2_t v20[2] = v22;
    *long long v20 = v21;
  }
  else
  {
    long long v20 = 0;
  }
  *(void *)(a1 + 72) = v20;
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a3 + 24);
  *(_WORD *)(a1 + 84) = *(_WORD *)(a3 + 28);
  RB::Fill::MeshGradient::MeshGradient(a1 + 88, a4, a7, (RB::Heap *)a2);
  return a1;
}

void sub_214168334(_Unwind_Exception *a1)
{
  RBPathRelease(*(void *)(v1 + 56), *(void *)(v1 + 64));
  _Unwind_Resume(a1);
}

void *RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::MeshGradient>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4E79A8;
  uint64_t v2 = (atomic_uint *)a1[12];
  if (v2 && atomic_fetch_add_explicit(v2 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
  }
  RBPathRelease(a1[7], a1[8]);
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::MeshGradient>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4E79A8;
  uint64_t v2 = (atomic_uint *)a1[12];
  if (v2 && atomic_fetch_add_explicit(v2 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
  }
  RBPathRelease(a1[7], a1[8]);
  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::type_id()
{
  return 20979713;
}

void *RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::MeshGradient>::copy(uint64_t a1, uint64_t a2, char a3)
{
  __int16 v4 = 0;
  int64x2_t v5 = (RB::Heap *)(*(void *)(a2 + 8) + 16);
  __int16 v6 = *(_WORD *)(a1 + 46);
  if ((a3 & 2) != 0) {
    goto LABEL_9;
  }
  if ((*(_WORD *)(a1 + 46) & 0x1000) != 0 || *(unsigned char *)(a2 + 272) == 0) {
    goto LABEL_9;
  }
  v10[0] = &unk_26C4E7F50;
  v10[1] = v5;
  _DWORD v10[2] = a1;
  float64x2_t v10[3] = a1 + 88;
  v10[4] = *(void *)(a1 + 48);
  uint64_t v11 = 0;
  RB::Coverage::Path::simplify(a1 + 56, (uint64_t)v10);
  float result = (void *)v11;
  if (!v11)
  {
    __int16 v6 = *(_WORD *)(a1 + 46);
    __int16 v4 = 4096;
LABEL_9:
    LODWORD(v10[0]) = v6 & 0x3F;
    float result = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage4PathENS_4Fill12MeshGradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, (size_t *)v5, a1 + 56, a1 + 88, (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), v10);
    *((_OWORD *)result + 1) = *(_OWORD *)(a1 + 16);
    result[4] = *(void *)(a1 + 32);
    *((_DWORD *)result + 10) = *(_DWORD *)(a1 + 40);
    __int16 v9 = *((_WORD *)result + 23) | *(_WORD *)(a1 + 46) & 0x5800;
    *((_WORD *)result + 23) = v9;
    goto LABEL_10;
  }
  __int16 v9 = *(_WORD *)(v11 + 46);
  __int16 v4 = 4096;
LABEL_10:
  *((_WORD *)result + 23) = v9 | v4;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  float result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::atom_position(uint64_t a1)
{
  v4.callbacks = *(RBPathCallbacks **)(a1 + 48);
  v4.mach_timebase_info info = (void *)(a1 + 56);
  double v1 = RB::Coverage::Path::bounds(v4);
  return vmla_f32(*(float32x2_t *)&v1, (float32x2_t)0x3F0000003F000000, v2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::can_make_clip()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::make_clip(uint64_t a1, uint64_t a2, unsigned int a3, void *a4, float a5)
{
  float v24 = 0.0;
  unsigned int v25 = a3;
  if (RB::Fill::MeshGradient::get_alpha((RB::Fill::MeshGradient *)(a1 + 88), &v24))
  {
    uint64_t v11 = (size_t *)(*(void *)(a2 + 8) + 16);
    _H0 = *(_WORD *)(a1 + 44);
    __asm { FCVT            S0, H0 }
    float v23 = _S0 * (float)(a5 * v24);
    uint64_t v18 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Path>,RB::Heap&,RB::Coverage::Path&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v11, v11, a1 + 56, (int *)&v23, (int *)&v25, (uint64_t *)(a1 + 48));
    uint64_t v19 = a4[5];
    size_t v20 = v19 + 1;
    if (a4[6] < (unint64_t)(v19 + 1))
    {
      RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v20);
      uint64_t v19 = a4[5];
      size_t v20 = v19 + 1;
    }
    long long v21 = (void *)a4[4];
    if (!v21) {
      long long v21 = a4;
    }
    v21[v19] = v18;
    a4[5] = v20;
    return (**(uint64_t (***)(uint64_t))a1)(a1);
  }
  else
  {
    v10.n128_f32[0] = a5;
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, v10);
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::can_append_color_matrix()
{
  return 1;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::append_color_matrix(uint64_t a1, float16x4_t *a2, uint64_t a3, __int16 a4)
{
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 128);
}

double RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::bounds(uint64_t a1)
{
  v2.callbacks = *(RBPathCallbacks **)(a1 + 48);
  v2.mach_timebase_info info = (void *)(a1 + 56);
  return RB::Coverage::Path::bounds(v2);
}

float RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::min_scale(uint64_t a1)
{
  float result = RB::Coverage::Path::min_scale((RB::Coverage::Path *)(a1 + 56), *(const RB::AffineTransform **)(a1 + 48));
  if (result < 0.0) {
    return 0.0;
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::has_no_effect(uint64_t a1)
{
  __asm { FCMP            H0, #0 }
  if (_ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  else {
    return 0;
  }
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::render(uint64_t a1, int a2, RB::RenderPass *a3, double a4, char a5, int a6)
{
  v24[5] = *(int32x2_t **)MEMORY[0x263EF8340];
  uint64_t v9 = *(void *)(a1 + 48);
  v10.i64[0] = SLODWORD(a4);
  v10.i64[1] = SHIDWORD(a4);
  long long v11 = *(_OWORD *)(v9 + 16);
  float64x2_t v12 = vaddq_f64(*(float64x2_t *)(v9 + 32), vcvtq_f64_s64(v10));
  v19[0] = *(_OWORD *)v9;
  v19[1] = v11;
  v19[2] = v12;
  _H8 = *(_WORD *)(a1 + 44);
  RB::Path::ImmediateRenderer::ImmediateRenderer((RB::Path::ImmediateRenderer *)v20, a3, (const RB::AffineTransform *)v19, (const RB::Coverage::Path *)(a1 + 56));
  __asm { FCVT            S0, H8 }
  RB::Path::Renderer::render(v24, a1 + 88, (uint64_t)v19, a5, a6, _S0);
  if (v23) {
    RB::Path::Accumulator::commit_buffer((RB::Path::Accumulator *)&v21);
  }
  if (v22) {
    free(v22);
  }
}

void sub_2141688C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
  if (a47) {
    free(a47);
  }
  _Unwind_Resume(exception_object);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::render(int32x2_t *a1, uint64_t a2)
{
  RBPath v4 = (float64x2_t *)a1[6];
  int64x2_t v5 = (float32x2_t *)a1[3];
  _H0 = a1[5].i16[2];
  __asm { FCVT            S8, H0 }
  unsigned int v11 = a1[5].i16[3] & 0x3F;
  *(double *)&float32x2_t v12 = (*(double (**)(int32x2_t *, void))(*(void *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v18, v12, v13);
  int v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5) {
    goto LABEL_10;
  }
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v18[0], *(int32x2_t *)((char *)v18 + 8)))
  {
    int v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v18, v14, _S8);
    goto LABEL_11;
  }
  int v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4) {
    goto LABEL_10;
  }
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11) {
    goto LABEL_10;
  }
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::Path::clip((RB::Coverage::Path *)&a1[7], (CGContextRef *)a2);
  v18[0] = xmmword_2142181C0;
  v18[1] = xmmword_2142181D0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  v22.callbacks = (RBPathCallbacks *)v18;
  v22.mach_timebase_info info = &a1[7];
  double v16 = RB::Coverage::Path::bounds(v22);
  RB::Bounds::Bounds(v21, *(float32x2_t *)&v16, v17);
  RB::Fill::MeshGradient::fill(a1 + 11, (int8x8_t *)a2, v21[0], v21[1]);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 88), a2);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::prepare_mix(float64x2_t **a1, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Interpolator::Op *a3, float64x2_t **a4)
{
  float result = (unint64_t *)(*(uint64_t (**)(float64x2_t **))&(*a4)[1].f64[0])(a4);
  if (result == 20979713)
  {
    float result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      float result = (unint64_t *)RB::can_mix(a1[6], a4[6], v10);
      int v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        float result = (unint64_t *)RB::Coverage::Path::can_mix(a1 + 7, a3, a4 + 7);
        if ((_BYTE)result)
        {
          unsigned __int8 v13 = result;
          can_mifloat64_t x = RB::Fill::MeshGradient::can_mix((RB::Fill::MeshGradient *)(a1 + 11), (const RB::Fill::MeshGradient *)(a4 + 11), v12);
          return RB::DisplayList::Interpolator::Op::set_type((unint64_t *)a3, v11, v13, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8 = (*(uint64_t (**)(CGAffineTransform **, void, void, void, uint64_t))&(*a1)[1].a)(a1, *(void *)&a4->f64[0], *(unsigned int *)(*(void *)(a2 + 8) + 12), **(void **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v27[0] = v10;
  v27[1] = v11;
  long long v27[2] = v12;
  *(void *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v27);
  unsigned __int8 v13 = (RB::Heap *)(*(void *)(*(void *)&a4->f64[0] + 8) + 16);
  LODWORD(v14) = *(_DWORD *)(a2 + 16);
  RB::Fill::MeshGradient::mix((RB::Fill::MeshGradient *)(v8 + 88), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::MeshGradient *)(a3 + 88), v14, v13);
  v15.f64[0] = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  float64x2_t v24 = v15;
  long long v25 = v16;
  long long v26 = v17;
  v18.f64[0] = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  v23[0] = v18;
  v23[1] = v19;
  int32x2_t v23[2] = v20;
  RB::Coverage::Path::mix((RBPath *)(v8 + 56), (const RB::DisplayList::Interpolator::State *)a2, (RBPath *)(a3 + 56), &v24, v23, *(float64x2_t **)(v8 + 48), v13);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(unsigned char *)(*(void *)&a4->f64[0] + 272))
  {
    *(void *)&v24.f64[0] = &unk_26C4E7F50;
    *(void *)&v24.f64[1] = v13;
    *(void *)&long long v25 = v8;
    *((void *)&v25 + 1) = v8 + 88;
    long long v26 = *(unint64_t *)(v8 + 48);
    RB::Coverage::Path::simplify(v8 + 56, (uint64_t)&v24);
    if (*((void *)&v26 + 1))
    {
      *(void *)uint64_t v8 = &unk_26C4E79A8;
      uint64_t v21 = *(atomic_uint **)(v8 + 96);
      if (v21 && atomic_fetch_add_explicit(v21 + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        (*(void (**)(atomic_uint *))(*(void *)v21 + 8))(v21);
      }
      RBPathRelease(*(void *)(v8 + 56), *(void *)(v8 + 64));
      uint64_t v8 = *((void *)&v26 + 1);
    }
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

void *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::encode(uint64_t a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Path>(this, 1, (RBPath *)(a1 + 56));
  RB::Encoder::typed_message_field<RB::Fill::MeshGradient>(this, 2, (RB::Fill::MeshGradient *)(a1 + 88));
  RBPath v4 = *(float64x2_t **)(a1 + 48);
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::print(const RB::AffineTransform **a1, std::string *this)
{
}

void *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage4PathENS_4Fill12MeshGradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, size_t *a2, uint64_t a3, uint64_t a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14 = *((void *)this + 3);
  uint64_t v15 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 136 > v14) {
    uint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0x88uLL, 7);
  }
  else {
    *((void *)this + 2) = v15 + 136;
  }
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  float result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  *float result = &unk_26C4E73F0;
  return result;
}

RB::Heap *RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::visit(uint64_t a1, long long *a2)
{
  RBPath v2 = *(RB::Heap ****)(a1 + 8);
  int v3 = *v2;
  float result = (RB::Heap *)RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, **v2, a2, *(RB::ImageTexture **)(a1 + 16), (uint64_t *)*v2 + 1, (float *)*v2 + 4, (_DWORD *)*v2 + 5, (__int16 *)*v2 + 12);
  v3[7] = result;
  return result;
}

RB::Heap *RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::visit(uint64_t a1, uint64_t a2)
{
  RBPath v2 = *(RB::Heap ****)(a1 + 8);
  int v3 = *v2;
  float result = (RB::Heap *)RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, **v2, a2, *(const RB::ImageTexture **)(a1 + 16), (uint64_t *)*v2 + 1, (float *)*v2 + 4, (_DWORD *)*v2 + 5, (__int16 *)*v2 + 12);
  v3[7] = result;
  return result;
}

void *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, RB::Heap *a2, long long *a3, RB::ImageTexture *a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16 = *((void *)this + 3);
  uint64_t v17 = (*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v17 + 208 > v16) {
    uint64_t v17 = RB::Heap::alloc_slow((size_t *)this, 0xD0uLL, 15);
  }
  else {
    *((void *)this + 2) = v17 + 208;
  }
  float result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  *float result = &unk_26C4EA178;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::GenericItem1(uint64_t a1, RB::Heap *a2, long long *a3, RB::ImageTexture *a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  __asm { FCVT            H0, S0 }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F;
  *(void *)a1 = &unk_26C4EB918;
  *(void *)(a1 + 48) = a5;
  long long v16 = *a3;
  long long v17 = a3[1];
  *(_OWORD *)(a1 + 95) = *(long long *)((char *)a3 + 31);
  *(_OWORD *)(a1 + 64) = v16;
  *(_OWORD *)(a1 + 80) = v17;
  RB::ImageTexture::ImageTexture((RB::ImageTexture *)(a1 + 112), a4, a2);
  long long v18 = *((_OWORD *)a4 + 2);
  long long v19 = *((_OWORD *)a4 + 3);
  long long v20 = *((_OWORD *)a4 + 4);
  *(_OWORD *)(a1 + 192) = *((_OWORD *)a4 + 5);
  long long v21 = *((_OWORD *)a4 + 1);
  *(_OWORD *)(a1 + 160) = v19;
  *(_OWORD *)(a1 + 176) = v20;
  *(_OWORD *)(a1 + 128) = v21;
  *(_OWORD *)(a1 + 144) = v18;
  if (!*(unsigned char *)(a1 + 205)) {
    *(_WORD *)(a1 + 204) = a7;
  }
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::~GenericItem()
{
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::type_id()
{
  return 12587009;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::copy(uint64_t a1, uint64_t a2)
{
  int v3 = (RB::Heap *)(*(void *)(a2 + 8) + 16);
  int v6 = *(_WORD *)(a1 + 46) & 0x3F;
  RBPath v4 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill5ImageINS_12ImageTextureEEEEEJRS0_RKS5_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v3, v3, (long long *)(a1 + 64), (RB::ImageTexture *)(a1 + 112), (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), &v6);
  __n128 result = *(__n128 *)(a1 + 16);
  v4[1] = result;
  v4[2].n128_u64[0] = *(void *)(a1 + 32);
  v4[2].n128_u32[2] = *(_DWORD *)(a1 + 40);
  v4[2].n128_u16[7] |= *(_WORD *)(a1 + 46) & 0x5800;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  __n128 result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::atom_position(uint64_t a1, int8x16_t a2, int32x4_t a3, int8x16_t a4, int32x4_t a5)
{
  float32x2_t v5 = RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), *(float64x2_t **)(a1 + 48), a2, a3, a4, a5);
  return vmla_f32(v5, (float32x2_t)0x3F0000003F000000, v6);
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::copy_shadow(__n128 *this, uint64_t a2, uint64_t a3)
{
  if ((*(unsigned char *)(a3 + 88) & 0x10) == 0)
  {
    if (this[7].n128_u8[12])
    {
      float v28 = 1.0;
      if ((RB::DisplayList::Item::clip_affects_blurred_bounds((RB::DisplayList::Item *)this, *(float *)(a3 + 64)) & 1) == 0)
      {
        memset(v25, 0, sizeof(v25));
        int v26 = 1065353216;
        v27[0] = 0;
        *(_DWORD *)((char *)v27 + 7) = 0;
        int64x2_t v7 = *(float64x2_t **)(a3 + 16);
        uint64_t v8 = (float64x2_t *)this[3].n128_u64[0];
        float64x2_t v9 = *v8;
        float64x2_t v10 = v8[2];
        float64x2_t v30 = v8[1];
        float64x2_t v31 = v10;
        float64x2_t v29 = v9;
        if (RB::AffineTransform::invert((RB::AffineTransform *)&v29)) {
          long long v11 = &v29;
        }
        else {
          long long v11 = v8;
        }
        float64x2_t v12 = v11[1];
        float64x2_t v13 = v11[2];
        v24[0] = *v11;
        v24[1] = v12;
        float32x2_t v24[2] = v13;
        v14.f64[0] = RB::operator*(v7, v24);
        float64x2_t v29 = v14;
        float64x2_t v30 = v15;
        float64x2_t v31 = v16;
        if (RB::Coverage::Primitive::make_shadow((RB::Coverage::Primitive *)&this[4], &v29, *(float *)(a3 + 64), &v28, (*(_DWORD *)(a3 + 88) >> 2) & 1, (RB::Coverage::Primitive *)v25))
        {
          _H1 = this[2].n128_u16[6];
          __asm { FCVT            S1, H1 }
          RB::DisplayList::ShadowStyle::make_primitive(a3, a2, v25, this[3].n128_i64[0], this[2].n128_u16[7] & 0x3F, v28, _S1);
          __n128 result = this[1];
          v23[1] = result;
          v23[2].n128_u64[0] = this[2].n128_u64[0];
          v23[2].n128_u32[2] = this[2].n128_u32[2];
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::make_clip(uint64_t a1, uint64_t a2, unsigned int a3, void *a4, int8x16_t a5)
{
  unsigned int v20 = a3;
  if (*(unsigned char *)(a1 + 124))
  {
    int64x2_t v7 = (size_t *)(*(void *)(a2 + 8) + 16);
    _H1 = *(_WORD *)(a1 + 44);
    __asm { FCVT            S1, H1 }
    *(float *)a5.i32 = _S1 * *(float *)a5.i32;
    __int32 v19 = a5.i32[0];
    uint64_t v14 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v7, a5, (uint64_t)v7, (_OWORD *)(a1 + 64), (unsigned __int32 *)&v19, (int *)&v20, (uint64_t *)(a1 + 48));
    uint64_t v15 = a4[5];
    size_t v16 = v15 + 1;
    if (a4[6] < (unint64_t)(v15 + 1))
    {
      RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v16);
      uint64_t v15 = a4[5];
      size_t v16 = v15 + 1;
    }
    long long v17 = (void *)a4[4];
    if (!v17) {
      long long v17 = a4;
    }
    v17[v15] = v14;
    a4[5] = v16;
    return (**(uint64_t (***)(uint64_t))a1)(a1);
  }
  else
  {
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, (__n128)a5);
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::can_append_color_matrix(int a1, float16x4_t *a2, char a3, __int16 a4)
{
  return RB::Fill::ImageData::can_append_color_matrix(a1 + 128, a2, a3, a4);
}

float16x4_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::append_color_matrix(uint64_t a1, RB::ColorMatrix *a2, int a3)
{
  return RB::Fill::ImageData::append_color_matrix(a1 + 128, a2, a3);
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::append_blur()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 125);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::bounds(uint64_t a1, int8x16_t a2, int32x4_t a3, int8x16_t a4, int32x4_t a5)
{
  return RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), *(float64x2_t **)(a1 + 48), a2, a3, a4, a5);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::min_scale(uint64_t a1)
{
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::has_no_effect(uint64_t a1)
{
  __asm { FCMP            H0, #0 }
  if (_ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  else {
    return 0;
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::prepare(uint64_t a1, uint64_t **a2)
{
  return RB::ImageTexture::prepare(a1 + 112, a2, (const RB::Fill::ImageData *)(a1 + 128), *(float64x2_t **)(a1 + 48), 0);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::render(uint64_t a1, double a2, uint64_t a3, uint64_t a4, int a5, unsigned int a6)
{
  float64x2_t v10 = *(float64x2_t **)(a1 + 48);
  v11.i64[0] = SLODWORD(a2);
  v11.i64[1] = SHIDWORD(a2);
  float64x2_t v12 = v10[1];
  _Q0 = vaddq_f64(v10[2], vcvtq_f64_s64(v11));
  v20[0] = *v10;
  v20[1] = v12;
  float64x2_t v20[2] = _Q0;
  uint64_t v14 = a1 + 64;
  LOWORD(_Q0.f64[0]) = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  RB::Fill::Image<RB::ImageTexture>::set_image(a1 + 112, (uint64_t)&v22, (uint64_t ***)a4, v20, *(float *)_Q0.f64);
  uint64_t result = RB::render_primitive(a4, (uint64_t)v20, v14, (uint64_t)v21, a1 + 128, a5, a6);
  *(_DWORD *)(a4 + 232) = 0;
  *(unsigned char *)(a4 + 236) = 0;
  return result;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::render(float32x2_t *a1, uint64_t a2)
{
  RBPath v4 = (float64x2_t *)a1[6];
  float32x2_t v5 = (float32x2_t *)a1[3];
  _H0 = a1[5].i16[2];
  __asm { FCVT            S8, H0 }
  unsigned int v11 = a1[5].i16[3] & 0x3F;
  *(double *)&float32x2_t v12 = (*(double (**)(float32x2_t *, void))(*(void *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v22, v12, v13);
  int v14 = 0;
  if (*(float32x2_t **)(a2 + 88) == v5)
  {
    if (RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v22[0].f64[0], *(int32x2_t *)&v22[0].f64[1]))
    {
      int v14 = 1;
      if (*(float64x2_t **)(a2 + 80) == v4 && *(float *)(a2 + 132) == _S8 && *(_DWORD *)(a2 + 136) == v11) {
        goto LABEL_11;
      }
    }
    else
    {
      int v14 = 0;
    }
  }
  RB::CGContext::update_state_slow(a2, v4, v5, v11, v22, v14, _S8);
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::Primitive::clip(a1 + 8, (CGContext **)a2);
  v22[0] = (float64x2_t)xmmword_2142181C0;
  v22[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  float32x2_t v18 = RB::Coverage::Primitive::bounds(a1 + 8, v22, (int8x16_t)xmmword_2142181C0, (int32x4_t)xmmword_2142181D0, v16, v17);
  RB::Bounds::Bounds((int32x2_t *)&v25, v18, v19);
  uint16x4_t v20 = v25;
  long long v21 = (RB *)RB::ImageTexture::cg_image((RB::ImageTexture *)&a1[14]);
  if (v21) {
    RB::Fill::ImageData::fill(&a1[16], a2, v21, v20);
  }
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::Fill::ImageData::matches((RB::Fill::ImageData *)(a1 + 128), a2, a3);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::apply_transform(uint64_t a1, const RB::DisplayList::Transform *a2, uint64_t a3, uint32x4_t a4)
{
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, uint64_t a4)
{
  uint64_t result = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)a4 + 16))(a4);
  if (result == 12587009)
  {
    uint64_t result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      uint64_t result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a4 + 48), v10);
      int v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        uint64_t result = (unint64_t *)RB::Coverage::Primitive::can_mix(a1 + 64, (uint64_t)a3, a4 + 64);
        if ((_BYTE)result)
        {
          unsigned __int8 v12 = result;
          can_mifloat64_t x = RB::ImageTexture::can_mix((RB::ImageTexture *)(a1 + 112), (const RB::ImageTexture *)(a4 + 112));
          if (can_mix)
          {
            unsigned __int8 v14 = can_mix;
            unsigned int v15 = RB::Fill::ImageData::can_mix((float32x2_t *)(a1 + 128), (float32x2_t *)(a4 + 128));
            if (v15 >= v14) {
              unsigned __int8 v16 = v14;
            }
            else {
              unsigned __int8 v16 = v15;
            }
          }
          else
          {
            unsigned __int8 v16 = 0;
          }
          return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v12, v16);
        }
      }
    }
  }
  return result;
}

float32x4_t *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8 = (float32x4_t *)(*(uint64_t (**)(CGAffineTransform **, void, void, void, uint64_t))&(*a1)[1].a)(a1, *(void *)&a4->f64[0], *(unsigned int *)(*(void *)(a2 + 8) + 12), **(void **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v16[0] = v10;
  v16[1] = v11;
  _OWORD v16[2] = v12;
  v8[3].i64[0] = (uint64_t)RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v16);
  RB::Fill::ImageData::mix(v8 + 8, *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (float32x4_t *)(a3 + 128), *(float *)(a2 + 16));
  RB::operator*((float64x2_t *)a1[6], a4 + 68);
  double v13 = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  RB::Coverage::Primitive::mix((uint64_t)&v8[4], a2, a3 + 64, v13, v14);
  if ((v8[2].i16[7] & 0x1000) == 0 && *(unsigned char *)(*(void *)&a4->f64[0] + 272)) {
    v8[2].i16[7] |= 0x1000u;
  }
  return v8;
}

uint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::prepare_encode(uint64_t a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode((uint64_t *)a1, a2);
  return RB::ImageTexture::prepare_encode((uint64_t **)(a1 + 112), a2);
}

void *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::encode(float32x4_t *a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Primitive>(this, 1, a1 + 4);
  RB::Encoder::typed_message_field<RB::Fill::Image<RB::ImageTexture>>(this, 2, (uint64_t)&a1[7]);
  RBPath v4 = (float64x2_t *)a1[3].i64[0];
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::print(const RB::AffineTransform **a1, std::string *this)
{
}

void *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill5ImageINS_12ImageTextureEEEEEJRS0_RKS5_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, RB::Heap *a2, long long *a3, RB::ImageTexture *a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14 = *((void *)this + 3);
  uint64_t v15 = (*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v15 + 208 > v14) {
    uint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0xD0uLL, 15);
  }
  else {
    *((void *)this + 2) = v15 + 208;
  }
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  uint64_t result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  *uint64_t result = &unk_26C4EA178;
  return result;
}

uint64_t RB::Fill::Image<RB::ImageTexture>::set_image(uint64_t a1, uint64_t a2, uint64_t ***a3, float64x2_t *a4, float a5)
{
  uint64_t v10 = a1 + 16;
  long long v11 = (char *)RB::ImageTexture::texture((CGImage **)a1, *a3, (const RB::Fill::ImageData *)(a1 + 16), a4, 0);
  uint64_t result = RB::Fill::set_image(a2, (uint64_t)a3, v11, a4, v10, a5);
  if (a5 == 1.0) {
    int v13 = *(unsigned __int8 *)(a1 + 12) << 8;
  }
  else {
    int v13 = 0;
  }
  *(_DWORD *)(a2 + 80) = *(_DWORD *)(a2 + 80) & 0xFFFFFEFF | v13;
  return result;
}

__n128 RB::DisplayList::GenericItemCopyVisitor<RB::Fill::Image<RB::ImageTexture>>::visit_<RB::Coverage::Primitive>(void *a1, long long *a2)
{
  int v3 = (RB::ImageTexture *)a1[3];
  RBPath v4 = a1 + 4;
  int64x2_t v5 = (RB::Heap *)a1[1];
  uint64_t v6 = a1[2];
  int v10 = *(_WORD *)(v6 + 46) & 0x3F;
  int64x2_t v7 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill5ImageINS_12ImageTextureEEEEEJRS0_RKS5_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, v5, a2, v3, v4, (__int16 *)(v6 + 44), &v10);
  a1[5] = v7;
  uint64_t v8 = (__n128 *)a1[2];
  __n128 result = v8[1];
  v7[1] = result;
  v7[2].n128_u64[0] = v8[2].n128_u64[0];
  v7[2].n128_u32[2] = v8[2].n128_u32[2];
  v7[2].n128_u16[7] |= v8[2].n128_u16[7] & 0x5800;
  return result;
}

__n128 RB::DisplayList::GenericItemCopyVisitor<RB::Fill::Image<RB::ImageTexture>>::visit_<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(void *a1, uint64_t a2)
{
  int v3 = (const RB::ImageTexture *)a1[3];
  RBPath v4 = a1 + 4;
  int64x2_t v5 = (RB::Heap *)a1[1];
  uint64_t v6 = a1[2];
  int v10 = *(_WORD *)(v6 + 46) & 0x3F;
  int64x2_t v7 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill5ImageINS_12ImageTextureEEEEEJRS0_RKS7_RKSB_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, v5, a2, v3, v4, (__int16 *)(v6 + 44), &v10);
  a1[5] = v7;
  uint64_t v8 = (__n128 *)a1[2];
  __n128 result = v8[1];
  v7[1] = result;
  v7[2].n128_u64[0] = v8[2].n128_u64[0];
  v7[2].n128_u32[2] = v8[2].n128_u32[2];
  v7[2].n128_u16[7] |= v8[2].n128_u16[7] & 0x5800;
  return result;
}

void *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill5ImageINS_12ImageTextureEEEEEJRS0_RKS7_RKSB_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, RB::Heap *a2, uint64_t a3, const RB::ImageTexture *a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14 = *((void *)this + 3);
  uint64_t v15 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 240 > v14) {
    uint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0xF0uLL, 7);
  }
  else {
    *((void *)this + 2) = v15 + 240;
  }
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  __n128 result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  *__n128 result = &unk_26C4E9D18;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::GenericItem1(uint64_t a1, RB::Heap *a2, uint64_t a3, const RB::ImageTexture *a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  __asm { FCVT            H0, S0 }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F;
  *(void *)a1 = &unk_26C4EB4B8;
  *(void *)(a1 + 48) = a5;
  *(void *)(a1 + 56) = &unk_26C4EDD48;
  RB::Coverage::StrokeablePath::StrokeablePath(a1 + 64, a3 + 8, a2);
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a3 + 56);
  *(unsigned char *)(a1 + 128) = *(unsigned char *)(a3 + 72);
  *(_WORD *)(a1 + 129) = *(_WORD *)(a3 + 73);
  *(unsigned char *)(a1 + 131) = *(unsigned char *)(a3 + 75);
  *(unsigned char *)(a1 + 132) = *(unsigned char *)(a3 + 76);
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a3 + 80);
  RB::ImageTexture::ImageTexture((RB::ImageTexture *)(a1 + 144), a4, a2);
  long long v18 = *((_OWORD *)a4 + 2);
  long long v19 = *((_OWORD *)a4 + 3);
  long long v20 = *((_OWORD *)a4 + 4);
  *(_OWORD *)(a1 + 224) = *((_OWORD *)a4 + 5);
  long long v21 = *((_OWORD *)a4 + 1);
  *(_OWORD *)(a1 + 192) = v19;
  *(_OWORD *)(a1 + 208) = v20;
  *(_OWORD *)(a1 + 160) = v21;
  *(_OWORD *)(a1 + 176) = v18;
  if (!*(unsigned char *)(a1 + 237)) {
    *(_WORD *)(a1 + 236) = a7;
  }
  return a1;
}

void sub_21416A0AC(_Unwind_Exception *a1)
{
  v1[7] = v2;
  RBPathRelease(v1[8], v1[9]);
  _Unwind_Resume(a1);
}

void *RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4EB4B8;
  a1[7] = &unk_26C4EDD48;
  RBPathRelease(a1[8], a1[9]);
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4EB4B8;
  a1[7] = &unk_26C4EDD48;
  RBPathRelease(a1[8], a1[9]);
  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::type_id()
{
  return 12595201;
}

void *RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::copy(uint64_t a1, uint64_t a2, char a3)
{
  __int16 v4 = 0;
  int64x2_t v5 = (uint64_t (**)(void, long long *))(*(void *)(a2 + 8) + 16);
  __int16 v6 = *(_WORD *)(a1 + 46);
  if ((a3 & 2) != 0) {
    goto LABEL_9;
  }
  if ((*(_WORD *)(a1 + 46) & 0x1000) != 0 || *(unsigned char *)(a2 + 272) == 0) {
    goto LABEL_9;
  }
  v10[0] = (uint64_t (**)(void, long long *))&unk_26C4E7F90;
  v10[1] = v5;
  _DWORD v10[2] = (uint64_t (**)(void, long long *))a1;
  float64x2_t v10[3] = (uint64_t (**)(void, long long *))(a1 + 144);
  v10[4] = *(uint64_t (***)(void, long long *))(a1 + 48);
  uint64_t v11 = 0;
  RB::Coverage::StrokeablePath::simplify(a1 + 64, a1 + 56, v10);
  __n128 result = (void *)v11;
  if (!v11)
  {
    __int16 v6 = *(_WORD *)(a1 + 46);
    __int16 v4 = 4096;
LABEL_9:
    LODWORD(v10[0]) = v6 & 0x3F;
    __n128 result = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill5ImageINS_12ImageTextureEEEEEJRS0_RKS7_RKSB_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_((RB::Heap *)v5, (RB::Heap *)v5, a1 + 56, (const RB::ImageTexture *)(a1 + 144), (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), v10);
    *((_OWORD *)result + 1) = *(_OWORD *)(a1 + 16);
    result[4] = *(void *)(a1 + 32);
    *((_DWORD *)result + 10) = *(_DWORD *)(a1 + 40);
    __int16 v9 = *((_WORD *)result + 23) | *(_WORD *)(a1 + 46) & 0x5800;
    *((_WORD *)result + 23) = v9;
    goto LABEL_10;
  }
  __int16 v9 = *(_WORD *)(v11 + 46);
  __int16 v4 = 4096;
LABEL_10:
  *((_WORD *)result + 23) = v9 | v4;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  __n128 result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::atom_position(uint64_t a1, double a2, int32x4_t a3)
{
  float32x2_t v3 = RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, *(float64x2_t **)(a1 + 48), a2, a3);
  return vmla_f32(v3, (float32x2_t)0x3F0000003F000000, v4);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::make_clip(uint64_t a1, uint64_t a2, unsigned int a3, void *a4, __n128 a5)
{
  unsigned int v20 = a3;
  if (*(unsigned char *)(a1 + 156))
  {
    int64x2_t v7 = (size_t *)(*(void *)(a2 + 8) + 16);
    _H1 = *(_WORD *)(a1 + 44);
    __asm { FCVT            S1, H1 }
    float v19 = _S1 * a5.n128_f32[0];
    uint64_t v14 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath>&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v7, (uint64_t)v7, a1 + 56, (int *)&v19, &v20, (uint64_t *)(a1 + 48));
    uint64_t v15 = a4[5];
    size_t v16 = v15 + 1;
    if (a4[6] < (unint64_t)(v15 + 1))
    {
      RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v16);
      uint64_t v15 = a4[5];
      size_t v16 = v15 + 1;
    }
    int32x4_t v17 = (void *)a4[4];
    if (!v17) {
      int32x4_t v17 = a4;
    }
    v17[v15] = v14;
    a4[5] = v16;
    return (**(uint64_t (***)(uint64_t))a1)(a1);
  }
  else
  {
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, a5);
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::can_append_color_matrix(int a1, float16x4_t *a2, char a3, __int16 a4)
{
  return RB::Fill::ImageData::can_append_color_matrix(a1 + 160, a2, a3, a4);
}

float16x4_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::append_color_matrix(uint64_t a1, RB::ColorMatrix *a2, int a3)
{
  return RB::Fill::ImageData::append_color_matrix(a1 + 160, a2, a3);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 157);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::bounds(uint64_t a1, double a2, int32x4_t a3)
{
  return RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, *(float64x2_t **)(a1 + 48), a2, a3);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::min_scale(uint64_t a1)
{
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::has_no_effect(uint64_t a1)
{
  __asm { FCMP            H0, #0 }
  if (_ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  else {
    return 0;
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::prepare(uint64_t a1, uint64_t **a2)
{
  return RB::ImageTexture::prepare(a1 + 144, a2, (const RB::Fill::ImageData *)(a1 + 160), *(float64x2_t **)(a1 + 48), 0);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::render(uint64_t a1, double a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  __int16 v6 = *(float64x2_t **)(a1 + 48);
  v7.i64[0] = SLODWORD(a2);
  v7.i64[1] = SHIDWORD(a2);
  float64x2_t v8 = v6[1];
  float64x2_t v9 = vaddq_f64(v6[2], vcvtq_f64_s64(v7));
  v21[0] = *v6;
  v21[1] = v8;
  int32x2_t v21[2] = v9;
  _H0 = *(_WORD *)(a1 + 44);
  int v24 = *(unsigned __int8 *)(a1 + 128);
  __int16 v25 = *(_WORD *)(a1 + 129);
  int v26 = *(unsigned __int8 *)(a1 + 131);
  char v27 = *(unsigned char *)(a1 + 132);
  int v28 = *(_DWORD *)(a1 + 136);
  int v29 = 1065353216;
  uint64_t v30 = 1;
  uint64_t v31 = 0;
  if (v24 == 1) {
    abort();
  }
  uint64_t v15 = a1 + 56;
  __asm { FCVT            S0, H0 }
  RB::Fill::Image<RB::ImageTexture>::set_image(a1 + 144, (uint64_t)&v23, (uint64_t ***)a4, v21, _S0);
  RB::render_stroke(a4, v21, v15, (uint64_t)&v24, &v22, a1 + 160, a5, a6);
  *(_DWORD *)(a4 + 232) = 0;
  *(unsigned char *)(a4 + 236) = 0;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::render(uint64_t a1, uint64_t a2)
{
  float32x2_t v4 = *(float64x2_t **)(a1 + 48);
  int64x2_t v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  unsigned int v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&float32x2_t v12 = (*(double (**)(uint64_t, void))(*(void *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v20, v12, v13);
  int v14 = 0;
  if (*(float32x2_t **)(a2 + 88) == v5)
  {
    if (RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v20[0].f64[0], *(int32x2_t *)&v20[0].f64[1]))
    {
      int v14 = 1;
      if (*(float64x2_t **)(a2 + 80) == v4 && *(float *)(a2 + 132) == _S8 && *(_DWORD *)(a2 + 136) == v11) {
        goto LABEL_11;
      }
    }
    else
    {
      int v14 = 0;
    }
  }
  RB::CGContext::update_state_slow(a2, v4, v5, v11, v20, v14, _S8);
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::StrokeablePath::clip(a1 + 64, a1 + 56, a2);
  v20[0] = (float64x2_t)xmmword_2142181C0;
  v20[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  float32x2_t v16 = RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, v20, 1.0, (int32x4_t)xmmword_2142181D0);
  RB::Bounds::Bounds((int32x2_t *)&v23, v16, v17);
  uint16x4_t v18 = v23;
  float v19 = (RB *)RB::ImageTexture::cg_image((RB::ImageTexture *)(a1 + 144));
  if (v19) {
    RB::Fill::ImageData::fill((void *)(a1 + 160), a2, v19, v18);
  }
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::Fill::ImageData::matches((RB::Fill::ImageData *)(a1 + 160), a2, a3);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::apply_transform(uint64_t a1, const RB::DisplayList::Transform *a2, uint64_t a3, uint32x4_t a4)
{
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, uint64_t a4)
{
  __n128 result = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)a4 + 16))(a4);
  if (result == 12595201)
  {
    __n128 result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      __n128 result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a4 + 48), v10);
      int v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        if (*(unsigned __int8 *)(a1 + 128) == *(unsigned __int8 *)(a4 + 128)
          && *(unsigned __int8 *)(a1 + 129) == *(unsigned __int8 *)(a4 + 129)
          && *(unsigned __int8 *)(a1 + 130) == *(unsigned __int8 *)(a4 + 130)
          && *(unsigned __int8 *)(a1 + 131) == *(unsigned __int8 *)(a4 + 131)
          && *(unsigned __int8 *)(a1 + 132) == *(unsigned __int8 *)(a4 + 132)
          && *(float *)(a1 + 136) == *(float *)(a4 + 136))
        {
          __n128 result = (unint64_t *)RB::Coverage::StrokeablePath::can_mix(a1 + 64, a4 + 64, v12);
          if ((_BYTE)result)
          {
            unsigned __int8 v13 = result;
            can_mifloat64_t x = RB::ImageTexture::can_mix((RB::ImageTexture *)(a1 + 144), (const RB::ImageTexture *)(a4 + 144));
            if (can_mix)
            {
              unsigned __int8 v15 = can_mix;
              unsigned int v16 = RB::Fill::ImageData::can_mix((float32x2_t *)(a1 + 160), (float32x2_t *)(a4 + 160));
              if (v16 >= v15) {
                unsigned __int8 v17 = v15;
              }
              else {
                unsigned __int8 v17 = v16;
              }
            }
            else
            {
              unsigned __int8 v17 = 0;
            }
            return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v13, v17);
          }
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8 = (*(uint64_t (**)(CGAffineTransform **, void, void, void, uint64_t))&(*a1)[1].a)(a1, *(void *)&a4->f64[0], *(unsigned int *)(*(void *)(a2 + 8) + 12), **(void **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v25[0] = v10;
  v25[1] = v11;
  long long v25[2] = v12;
  *(void *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v25);
  unsigned __int8 v13 = (RB *)(*(void *)(*(void *)&a4->f64[0] + 8) + 16);
  RB::Fill::ImageData::mix((float32x4_t *)(v8 + 160), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (float32x4_t *)(a3 + 160), *(float *)(a2 + 16));
  *(double *)&long long v14 = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  long long v22 = v14;
  long long v23 = v15;
  long long v24 = v16;
  *(double *)&long long v17 = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  v21[0] = v17;
  v21[1] = v18;
  int32x2_t v21[2] = v19;
  LODWORD(v17) = *(_DWORD *)(a2 + 16);
  RB::Coverage::StrokeablePath::mix(v8 + 64, v13, a3 + 64, (uint64_t)&v22, (uint64_t)v21, *(void *)(v8 + 48), *(CGFloat *)&v17);
  *(float *)(v8 + 136) = *(float *)(v8 + 136)
                       + (float)((float)(*(float *)(a3 + 136) - *(float *)(v8 + 136)) * *(float *)(a2 + 16));
  *(void *)(v8 + 112) = 0x100000001000000;
  *(int32x2_t *)(v8 + 120) = vdup_n_s32(0x7F7FFFFFu);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(unsigned char *)(*(void *)&a4->f64[0] + 272))
  {
    *(void *)&long long v22 = &unk_26C4E7F90;
    *((void *)&v22 + 1) = v13;
    *(void *)&long long v23 = v8;
    *((void *)&v23 + 1) = v8 + 144;
    long long v24 = *(unint64_t *)(v8 + 48);
    RB::Coverage::StrokeablePath::simplify(v8 + 64, v8 + 56, (uint64_t (***)(void, long long *))&v22);
    if (*((void *)&v24 + 1))
    {
      *(void *)uint64_t v8 = &unk_26C4EB4B8;
      *(void *)(v8 + 56) = &unk_26C4EDD48;
      RBPathRelease(*(void *)(v8 + 64), *(void *)(v8 + 72));
      uint64_t v8 = *((void *)&v24 + 1);
    }
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

uint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::prepare_encode(uint64_t a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode((uint64_t *)a1, a2);
  return RB::ImageTexture::prepare_encode((uint64_t **)(a1 + 144), a2);
}

void *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::encode(RB::DisplayList::Item *a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(this, 1, (uint64_t)a1 + 56);
  RB::Encoder::typed_message_field<RB::Fill::Image<RB::ImageTexture>>(this, 2, (uint64_t)a1 + 144);
  float32x2_t v4 = (float64x2_t *)*((void *)a1 + 6);
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode(a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::print(const RB::AffineTransform **a1, std::string *this)
{
}

void *RB::Encoder::typed_message_field<RB::Fill::Image<RB::ImageTexture>>(RB::Encoder *a1, uint64_t a2, uint64_t a3)
{
  RB::ProtobufEncoder::encode_varint(a1, (8 * a2) | 2);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::ProtobufEncoder::encode_varint(a1, 0x1AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::ImageTexture::encode((RB::ImageTexture *)a3, a1);
  RB::Fill::ImageData::encode((RB::Fill::ImageData *)(a3 + 16), a1, v5, v6);
  RB::ProtobufEncoder::end_length_delimited(a1);
  return RB::ProtobufEncoder::end_length_delimited(a1);
}

void RB::XML::print_attributes<RB::Fill::Image<RB::ImageTexture>>()
{
}

void sub_21416AE54(_Unwind_Exception *exception_object)
{
  int v3 = v1[2] - 1;
  v1[2] = v3;
  if (!v3) {
    (*(void (**)(_DWORD *))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, RB::Heap *a2, uint64_t a3, const RB::ImageTexture *a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16 = *((void *)this + 3);
  uint64_t v17 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 240 > v16) {
    uint64_t v17 = RB::Heap::alloc_slow((size_t *)this, 0xF0uLL, 7);
  }
  else {
    *((void *)this + 2) = v17 + 240;
  }
  __n128 result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  *__n128 result = &unk_26C4E9D18;
  return result;
}

void *RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4EA798;
  RBPathRelease(a1[7], a1[8]);
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4EA798;
  RBPathRelease(a1[7], a1[8]);
  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::type_id()
{
  return 12591105;
}

void *RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::copy(uint64_t a1, uint64_t a2, char a3)
{
  __int16 v4 = 0;
  int32x4_t v5 = (RB::Heap *)(*(void *)(a2 + 8) + 16);
  __int16 v6 = *(_WORD *)(a1 + 46);
  if ((a3 & 2) != 0) {
    goto LABEL_9;
  }
  if ((*(_WORD *)(a1 + 46) & 0x1000) != 0 || *(unsigned char *)(a2 + 272) == 0) {
    goto LABEL_9;
  }
  v10[0] = &unk_26C4E7F90;
  v10[1] = v5;
  _DWORD v10[2] = a1;
  float64x2_t v10[3] = a1 + 88;
  v10[4] = *(void *)(a1 + 48);
  uint64_t v11 = 0;
  RB::Coverage::Path::simplify(a1 + 56, (uint64_t)v10);
  __n128 result = (void *)v11;
  if (!v11)
  {
    __int16 v6 = *(_WORD *)(a1 + 46);
    __int16 v4 = 4096;
LABEL_9:
    LODWORD(v10[0]) = v6 & 0x3F;
    __n128 result = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage4PathENS_4Fill5ImageINS_12ImageTextureEEEEEJRS0_RKS5_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, (size_t *)v5, a1 + 56, (const RB::ImageTexture *)(a1 + 88), (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), v10);
    *((_OWORD *)result + 1) = *(_OWORD *)(a1 + 16);
    result[4] = *(void *)(a1 + 32);
    *((_DWORD *)result + 10) = *(_DWORD *)(a1 + 40);
    __int16 v9 = *((_WORD *)result + 23) | *(_WORD *)(a1 + 46) & 0x5800;
    *((_WORD *)result + 23) = v9;
    goto LABEL_10;
  }
  __int16 v9 = *(_WORD *)(v11 + 46);
  __int16 v4 = 4096;
LABEL_10:
  *((_WORD *)result + 23) = v9 | v4;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  __n128 result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::atom_position(uint64_t a1)
{
  v4.callbacks = *(RBPathCallbacks **)(a1 + 48);
  v4.mach_timebase_info info = (void *)(a1 + 56);
  double v1 = RB::Coverage::Path::bounds(v4);
  return vmla_f32(*(float32x2_t *)&v1, (float32x2_t)0x3F0000003F000000, v2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::make_clip(uint64_t a1, uint64_t a2, unsigned int a3, void *a4, __n128 a5)
{
  unsigned int v20 = a3;
  if (*(unsigned char *)(a1 + 100))
  {
    int64x2_t v7 = (size_t *)(*(void *)(a2 + 8) + 16);
    _H1 = *(_WORD *)(a1 + 44);
    __asm { FCVT            S1, H1 }
    float v19 = _S1 * a5.n128_f32[0];
    uint64_t v14 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Path>,RB::Heap&,RB::Coverage::Path&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v7, v7, a1 + 56, (int *)&v19, (int *)&v20, (uint64_t *)(a1 + 48));
    uint64_t v15 = a4[5];
    size_t v16 = v15 + 1;
    if (a4[6] < (unint64_t)(v15 + 1))
    {
      RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v16);
      uint64_t v15 = a4[5];
      size_t v16 = v15 + 1;
    }
    uint64_t v17 = (void *)a4[4];
    if (!v17) {
      uint64_t v17 = a4;
    }
    v17[v15] = v14;
    a4[5] = v16;
    return (**(uint64_t (***)(uint64_t))a1)(a1);
  }
  else
  {
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, a5);
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::can_append_color_matrix(int a1, float16x4_t *a2, char a3, __int16 a4)
{
  return RB::Fill::ImageData::can_append_color_matrix(a1 + 104, a2, a3, a4);
}

float16x4_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::append_color_matrix(uint64_t a1, RB::ColorMatrix *a2, int a3)
{
  return RB::Fill::ImageData::append_color_matrix(a1 + 104, a2, a3);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::append_alpha_gradient()
{
  return 0;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::min_scale(const RB::AffineTransform **a1)
{
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::has_no_effect(uint64_t a1)
{
  __asm { FCMP            H0, #0 }
  if (_ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  else {
    return 0;
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::prepare(uint64_t a1, uint64_t **a2)
{
  return RB::ImageTexture::prepare(a1 + 88, a2, (const RB::Fill::ImageData *)(a1 + 104), *(float64x2_t **)(a1 + 48), 0);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::render(uint64_t a1, int a2, RB::RenderPass *a3, double a4, char a5, int a6)
{
  v27[5] = *(int32x2_t **)MEMORY[0x263EF8340];
  long long v10 = *(float64x2_t **)(a1 + 48);
  v11.i64[0] = SLODWORD(a4);
  v11.i64[1] = SHIDWORD(a4);
  float64x2_t v12 = v10[1];
  float64x2_t v13 = vaddq_f64(v10[2], vcvtq_f64_s64(v11));
  v20[0] = *v10;
  v20[1] = v12;
  float64x2_t v20[2] = v13;
  _H8 = *(_WORD *)(a1 + 44);
  RB::Path::ImmediateRenderer::ImmediateRenderer((RB::Path::ImmediateRenderer *)v23, a3, (const RB::AffineTransform *)v20, (const RB::Coverage::Path *)(a1 + 56));
  __asm { FCVT            S0, H8 }
  RB::Fill::Image<RB::ImageTexture>::set_image(a1 + 88, (uint64_t)&v22, (uint64_t ***)a3, v20, _S0);
  RB::Path::Renderer::render(v27, (uint64_t)v21, a5, a6);
  *((_DWORD *)a3 + 58) = 0;
  *((unsigned char *)a3 + 236) = 0;
  if (v26) {
    RB::Path::Accumulator::commit_buffer((RB::Path::Accumulator *)&v24);
  }
  if (v25) {
    free(v25);
  }
}

void sub_21416B470(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,void *a61)
{
  if (a61) {
    free(a61);
  }
  _Unwind_Resume(a1);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::render(uint64_t a1, uint64_t a2)
{
  RBPath v4 = *(float64x2_t **)(a1 + 48);
  int32x4_t v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  unsigned int v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&float32x2_t v12 = (*(double (**)(uint64_t, void))(*(void *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v20, v12, v13);
  int v14 = 0;
  if (*(float32x2_t **)(a2 + 88) == v5)
  {
    if (RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v20[0], *(int32x2_t *)((char *)v20 + 8)))
    {
      int v14 = 1;
      if (*(float64x2_t **)(a2 + 80) == v4 && *(float *)(a2 + 132) == _S8 && *(_DWORD *)(a2 + 136) == v11) {
        goto LABEL_11;
      }
    }
    else
    {
      int v14 = 0;
    }
  }
  RB::CGContext::update_state_slow(a2, v4, v5, v11, v20, v14, _S8);
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::Path::clip((RB::Coverage::Path *)(a1 + 56), (CGContextRef *)a2);
  v20[0] = xmmword_2142181C0;
  v20[1] = xmmword_2142181D0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  v24.callbacks = (RBPathCallbacks *)v20;
  v24.mach_timebase_info info = (void *)(a1 + 56);
  double v16 = RB::Coverage::Path::bounds(v24);
  RB::Bounds::Bounds((int32x2_t *)&v23, *(float32x2_t *)&v16, v17);
  uint16x4_t v18 = v23;
  float v19 = (RB *)RB::ImageTexture::cg_image((RB::ImageTexture *)(a1 + 88));
  if (v19) {
    RB::Fill::ImageData::fill((void *)(a1 + 104), a2, v19, v18);
  }
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::Fill::ImageData::matches((RB::Fill::ImageData *)(a1 + 104), a2, a3);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::apply_transform(uint64_t a1, const RB::DisplayList::Transform *a2, uint64_t a3, uint32x4_t a4)
{
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Interpolator::Op *a3, uint64_t a4)
{
  __n128 result = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)a4 + 16))(a4);
  if (result == 12591105)
  {
    __n128 result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      __n128 result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a4 + 48), v10);
      int v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        __n128 result = (unint64_t *)RB::Coverage::Path::can_mix((float64x2_t **)(a1 + 56), a3, (float64x2_t **)(a4 + 56));
        if ((_BYTE)result)
        {
          unsigned __int8 v12 = result;
          can_mifloat64_t x = RB::ImageTexture::can_mix((RB::ImageTexture *)(a1 + 88), (const RB::ImageTexture *)(a4 + 88));
          if (can_mix)
          {
            unsigned __int8 v14 = can_mix;
            unsigned int v15 = RB::Fill::ImageData::can_mix((float32x2_t *)(a1 + 104), (float32x2_t *)(a4 + 104));
            if (v15 >= v14) {
              unsigned __int8 v16 = v14;
            }
            else {
              unsigned __int8 v16 = v15;
            }
          }
          else
          {
            unsigned __int8 v16 = 0;
          }
          return RB::DisplayList::Interpolator::Op::set_type((unint64_t *)a3, v11, v12, v16);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8 = (*(uint64_t (**)(CGAffineTransform **, void, void, void, uint64_t))&(*a1)[1].a)(a1, *(void *)&a4->f64[0], *(unsigned int *)(*(void *)(a2 + 8) + 12), **(void **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v25[0] = v10;
  v25[1] = v11;
  long long v25[2] = v12;
  *(void *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v25);
  float32x2_t v13 = (RB::Heap *)(*(void *)(*(void *)&a4->f64[0] + 8) + 16);
  RB::Fill::ImageData::mix((float32x4_t *)(v8 + 104), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (float32x4_t *)(a3 + 104), *(float *)(a2 + 16));
  v14.f64[0] = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  float64x2_t v22 = v14;
  long long v23 = v15;
  long long v24 = v16;
  v17.f64[0] = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  v21[0] = v17;
  v21[1] = v18;
  int32x2_t v21[2] = v19;
  RB::Coverage::Path::mix((RBPath *)(v8 + 56), (const RB::DisplayList::Interpolator::State *)a2, (RBPath *)(a3 + 56), &v22, v21, *(float64x2_t **)(v8 + 48), v13);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(unsigned char *)(*(void *)&a4->f64[0] + 272))
  {
    *(void *)&v22.f64[0] = &unk_26C4E7F90;
    *(void *)&v22.f64[1] = v13;
    *(void *)&long long v23 = v8;
    *((void *)&v23 + 1) = v8 + 88;
    long long v24 = *(unint64_t *)(v8 + 48);
    RB::Coverage::Path::simplify(v8 + 56, (uint64_t)&v22);
    if (*((void *)&v24 + 1))
    {
      *(void *)uint64_t v8 = &unk_26C4EA798;
      RBPathRelease(*(void *)(v8 + 56), *(void *)(v8 + 64));
      uint64_t v8 = *((void *)&v24 + 1);
    }
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

uint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::prepare_encode(uint64_t a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode((uint64_t *)a1, a2);
  return RB::ImageTexture::prepare_encode((uint64_t **)(a1 + 88), a2);
}

void *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::encode(uint64_t a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Path>(this, 1, (RBPath *)(a1 + 56));
  RB::Encoder::typed_message_field<RB::Fill::Image<RB::ImageTexture>>(this, 2, a1 + 88);
  RBPath v4 = *(float64x2_t **)(a1 + 48);
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::print(const RB::AffineTransform **a1, std::string *this)
{
}

void *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage4PathENS_4Fill5ImageINS_12ImageTextureEEEEEJRS0_RKS5_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, size_t *a2, uint64_t a3, const RB::ImageTexture *a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14 = *((void *)this + 3);
  uint64_t v15 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 184 > v14) {
    uint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0xB8uLL, 7);
  }
  else {
    *((void *)this + 2) = v15 + 184;
  }
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  __n128 result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  *__n128 result = &unk_26C4E8FF8;
  return result;
}

void *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Path const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, size_t *a2, uint64_t a3, uint64_t a4, uint64_t *a5, float *a6, _DWORD *a7)
{
  unint64_t v14 = *((void *)this + 3);
  uint64_t v15 = (*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v15 + 304 > v14) {
    uint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0x130uLL, 15);
  }
  else {
    *((void *)this + 2) = v15 + 304;
  }
  __n128 result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::GenericItem1(v15, a2, a3, a4, *a5, *a7, *a6);
  *__n128 result = &unk_26C4E9110;
  return result;
}

unint64_t RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Path,RB::Fill::Custom>::visit(uint64_t a1, long long *a2)
{
  float32x2_t v2 = *(size_t ****)(a1 + 8);
  int v3 = *v2;
  unint64_t result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, (uint64_t)**v2, a2, *(void *)(a1 + 16), (uint64_t *)*v2 + 1, (int *)*v2 + 4, (_WORD *)*v2 + 10);
  v3[7] = (size_t *)result;
  return result;
}

RB::Heap *RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Path,RB::Fill::Custom>::visit(uint64_t a1, uint64_t a2)
{
  float32x2_t v2 = *(RB::Heap ****)(a1 + 8);
  int v3 = *v2;
  unint64_t result = (RB::Heap *)RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, (uint64_t)**v2, a2, *(void *)(a1 + 16), (uint64_t *)*v2 + 1, (float *)*v2 + 4, (_DWORD *)*v2 + 5);
  v3[7] = result;
  return result;
}

unint64_t RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(size_t *a1, uint64_t a2, long long *a3, uint64_t a4, uint64_t *a5, int *a6, _WORD *a7)
{
  unint64_t v12 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v12 + 320 > a1[3]) {
    unint64_t v12 = RB::Heap::alloc_slow(a1, 0x140uLL, 15);
  }
  else {
    a1[2] = v12 + 320;
  }
  uint64_t v13 = *a5;
  _S0 = *a6;
  char v15 = *a7;
  __asm { FCVT            H0, S0 }
  *(void *)(v12 + 16) = 0;
  *(void *)(v12 + 24) = 0;
  *(_DWORD *)(v12 + 40) = 0;
  *(void *)(v12 + 32) = 0;
  *(_WORD *)(v12 + 44) = _S0;
  *(_WORD *)(v12 + 46) = v15 & 0x3F;
  *(void *)unint64_t v12 = &unk_26C4EBA30;
  *(void *)(v12 + 48) = v13;
  long long v20 = *a3;
  long long v21 = a3[1];
  *(_OWORD *)(v12 + 95) = *(long long *)((char *)a3 + 31);
  *(_OWORD *)(v12 + 64) = v20;
  *(_OWORD *)(v12 + 80) = v21;
  RB::Fill::Custom::Custom((RB::CustomShader::Closure *)(v12 + 112), a4);
  *(void *)unint64_t v12 = &unk_26C4EA290;
  return v12;
}

void *RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Custom>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4EBA30;
  float32x2_t v2 = (const void **)(a1 + 15);
  int v3 = (const void **)a1[27];
  if (v3) {
    RBPath v4 = v3;
  }
  else {
    RBPath v4 = v2;
  }
  if (a1[28])
  {
    unint64_t v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[28]);
    int v3 = (const void **)a1[27];
  }
  if (v3) {
    free(v3);
  }
  __int16 v6 = (atomic_uint *)a1[14];
  if (v6 && atomic_fetch_add_explicit(v6 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v6 + 8))(v6);
  }
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Custom>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4EBA30;
  float32x2_t v2 = (const void **)(a1 + 15);
  int v3 = (const void **)a1[27];
  if (v3) {
    RBPath v4 = v3;
  }
  else {
    RBPath v4 = v2;
  }
  if (a1[28])
  {
    unint64_t v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[28]);
    int v3 = (const void **)a1[27];
  }
  if (v3) {
    free(v3);
  }
  __int16 v6 = (atomic_uint *)a1[14];
  if (v6 && atomic_fetch_add_explicit(v6 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v6 + 8))(v6);
  }
  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::type_id()
{
  return 16781313;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Custom>::copy(uint64_t a1, uint64_t a2)
{
  int v3 = (size_t *)(*(void *)(a2 + 8) + 16);
  int v6 = *(_WORD *)(a1 + 46) & 0x3F;
  RBPath v4 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill6CustomEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v3, (uint64_t)v3, (long long *)(a1 + 64), a1 + 112, (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), &v6);
  __n128 result = *(__n128 *)(a1 + 16);
  v4[1] = result;
  v4[2].n128_u64[0] = *(void *)(a1 + 32);
  v4[2].n128_u32[2] = *(_DWORD *)(a1 + 40);
  v4[2].n128_u16[7] |= *(_WORD *)(a1 + 46) & 0x5800;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  __n128 result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::atom_position(uint64_t a1, int8x16_t a2, int32x4_t a3, int8x16_t a4, int32x4_t a5)
{
  float32x2_t v5 = RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), *(float64x2_t **)(a1 + 48), a2, a3, a4, a5);
  return vmla_f32(v5, (float32x2_t)0x3F0000003F000000, v6);
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Custom>::copy_shadow()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::can_append_color_matrix()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Custom>::append_blur()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::required_depth()
{
  return 0;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::bounds(uint64_t a1, int8x16_t a2, int32x4_t a3, int8x16_t a4, int32x4_t a5)
{
  return RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), *(float64x2_t **)(a1 + 48), a2, a3, a4, a5);
}

float RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::min_scale(uint64_t a1)
{
  float result = 0.0;
  if (*(unsigned __int8 *)(a1 + 108) >= 2u && *(unsigned char *)(a1 + 109) == 1) {
    return 1.0;
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::has_no_effect(uint64_t a1)
{
  __asm { FCMP            H0, #0 }
  if (_ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  else {
    return 0;
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::prepare(uint64_t a1, const RB::RenderParams *a2)
{
  return RB::Fill::Custom::prepare((RB::Fill::Custom *)(a1 + 112), a2, *(const RB::AffineTransform **)(a1 + 48));
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::render(uint64_t a1, int a2, RB::RenderPass *a3, double a4, int a5, unsigned int a6)
{
  float32x2_t v6 = *(float64x2_t **)(a1 + 48);
  v7.i64[0] = SLODWORD(a4);
  v7.i64[1] = SHIDWORD(a4);
  float64x2_t v8 = v6[1];
  _Q0 = vaddq_f64(v6[2], vcvtq_f64_s64(v7));
  v14[0] = *v6;
  v14[1] = v8;
  float32x2_t v14[2] = _Q0;
  LOWORD(_Q0.f64[0]) = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  RB::render_primitive(a3, v14, a1 + 64, (RB::Fill::Custom *)(a1 + 112), a5, a6, *(float *)_Q0.f64);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::render(float32x2_t *a1, uint64_t a2)
{
  RBPath v4 = (float64x2_t *)a1[6];
  float32x2_t v5 = (float32x2_t *)a1[3];
  _H0 = a1[5].i16[2];
  __asm { FCVT            S8, H0 }
  unsigned int v11 = a1[5].i16[3] & 0x3F;
  *(double *)&float32x2_t v12 = (*(double (**)(float32x2_t *, void))(*(void *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v20, v12, v13);
  int v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5) {
    goto LABEL_10;
  }
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v20[0].f64[0], *(int32x2_t *)&v20[0].f64[1]))
  {
    int v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v20, v14, _S8);
    goto LABEL_11;
  }
  int v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4) {
    goto LABEL_10;
  }
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11) {
    goto LABEL_10;
  }
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::Primitive::clip(a1 + 8, (CGContext **)a2);
  v20[0] = (float64x2_t)xmmword_2142181C0;
  v20[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  float32x2_t v18 = RB::Coverage::Primitive::bounds(a1 + 8, v20, (int8x16_t)xmmword_2142181C0, (int32x4_t)xmmword_2142181D0, v16, v17);
  RB::Bounds::Bounds(&v23, v18, v19);
  RBStrokeRef::clip(&a1[14]);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 112), a2);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::prepare_mix(float64x2_t **a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, float64x2_t **a4)
{
  float result = (unint64_t *)(*(uint64_t (**)(float64x2_t **))&(*a4)[1].f64[0])(a4);
  if (result == 16781313)
  {
    float result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      float result = (unint64_t *)RB::can_mix(a1[6], a4[6], v10);
      int v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        float result = (unint64_t *)RB::Coverage::Primitive::can_mix((uint64_t)(a1 + 8), (uint64_t)a3, (uint64_t)(a4 + 8));
        if ((_BYTE)result)
        {
          unsigned __int8 v12 = result;
          can_mifloat64_t x = RB::Fill::Custom::can_mix((RB::Fill::Custom *)(a1 + 14), (const RB::Fill::Custom *)(a4 + 14));
          return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v12, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8 = (*(uint64_t (**)(CGAffineTransform **, void, void, void, uint64_t))&(*a1)[1].a)(a1, *(void *)&a4->f64[0], *(unsigned int *)(*(void *)(a2 + 8) + 12), **(void **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v16[0] = v10;
  v16[1] = v11;
  _OWORD v16[2] = v12;
  *(void *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v16);
  RB::Fill::Custom::mix((RB::Fill::Custom *)(v8 + 112), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::Custom *)(a3 + 112), *(float *)(a2 + 16), (RB::Heap *)(*(void *)(*(void *)&a4->f64[0] + 8) + 16));
  RB::operator*((float64x2_t *)a1[6], a4 + 68);
  double v13 = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  RB::Coverage::Primitive::mix(v8 + 64, a2, a3 + 64, v13, v14);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(unsigned char *)(*(void *)&a4->f64[0] + 272)) {
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::prepare_encode(uint64_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode(a1, a2);
  return RB::Fill::Custom::prepare_encode((RB::Fill::Custom *)(a1 + 14), a2);
}

void *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::encode(float32x4_t *a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Primitive>(this, 1, a1 + 4);
  RB::Encoder::typed_message_field<RB::Fill::Custom>(this, 2, (RB::Fill::Custom *)&a1[7]);
  RBPath v4 = (float64x2_t *)a1[3].i64[0];
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::print(const RB::AffineTransform **a1, std::string *this)
{
}

unint64_t _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill6CustomEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(size_t *a1, uint64_t a2, long long *a3, uint64_t a4, uint64_t *a5, __int16 *a6, _WORD *a7)
{
  unint64_t v12 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v12 + 320 > a1[3]) {
    unint64_t v12 = RB::Heap::alloc_slow(a1, 0x140uLL, 15);
  }
  else {
    a1[2] = v12 + 320;
  }
  uint64_t v13 = *a5;
  __int16 v14 = *a6;
  char v15 = *a7;
  *(void *)(v12 + 16) = 0;
  *(void *)(v12 + 24) = 0;
  *(_DWORD *)(v12 + 40) = 0;
  *(void *)(v12 + 32) = 0;
  *(_WORD *)(v12 + 44) = v14;
  *(_WORD *)(v12 + 46) = v15 & 0x3F;
  *(void *)unint64_t v12 = &unk_26C4EBA30;
  *(void *)(v12 + 48) = v13;
  long long v16 = *a3;
  long long v17 = a3[1];
  *(_OWORD *)(v12 + 95) = *(long long *)((char *)a3 + 31);
  *(_OWORD *)(v12 + 64) = v16;
  *(_OWORD *)(v12 + 80) = v17;
  RB::Fill::Custom::Custom((RB::CustomShader::Closure *)(v12 + 112), a4);
  *(void *)unint64_t v12 = &unk_26C4EA290;
  return v12;
}

__n128 RB::DisplayList::GenericItemCopyVisitor<RB::Fill::Custom>::visit_<RB::Coverage::Primitive>(void *a1, long long *a2)
{
  uint64_t v3 = a1[3];
  RBPath v4 = a1 + 4;
  int64x2_t v5 = (size_t *)a1[1];
  uint64_t v6 = a1[2];
  int v10 = *(_WORD *)(v6 + 46) & 0x3F;
  int64x2_t v7 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill6CustomEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, (uint64_t)v5, a2, v3, v4, (__int16 *)(v6 + 44), &v10);
  a1[5] = v7;
  uint64_t v8 = (__n128 *)a1[2];
  __n128 result = v8[1];
  v7[1] = result;
  v7[2].n128_u64[0] = v8[2].n128_u64[0];
  v7[2].n128_u32[2] = v8[2].n128_u32[2];
  v7[2].n128_u16[7] |= v8[2].n128_u16[7] & 0x5800;
  return result;
}

__n128 RB::DisplayList::GenericItemCopyVisitor<RB::Fill::Custom>::visit_<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[3];
  RBPath v4 = a1 + 4;
  int64x2_t v5 = (RB::Heap *)a1[1];
  uint64_t v6 = a1[2];
  int v10 = *(_WORD *)(v6 + 46) & 0x3F;
  int64x2_t v7 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill6CustomEEEJRS0_RKS7_RKS9_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, (uint64_t)v5, a2, v3, v4, (__int16 *)(v6 + 44), &v10);
  a1[5] = v7;
  uint64_t v8 = (__n128 *)a1[2];
  __n128 result = v8[1];
  v7[1] = result;
  v7[2].n128_u64[0] = v8[2].n128_u64[0];
  v7[2].n128_u32[2] = v8[2].n128_u32[2];
  v7[2].n128_u16[7] |= v8[2].n128_u16[7] & 0x5800;
  return result;
}

void *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill6CustomEEEJRS0_RKS7_RKS9_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14 = *((void *)this + 3);
  uint64_t v15 = (*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v15 + 352 > v14) {
    uint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0x160uLL, 15);
  }
  else {
    *((void *)this + 2) = v15 + 352;
  }
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  __n128 result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::GenericItem1(v15, a2, a3, a4, *a5, *a7, _S0);
  *__n128 result = &unk_26C4E9E30;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::GenericItem1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, float _S0)
{
  __asm { FCVT            H0, S0 }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F;
  *(void *)a1 = &unk_26C4EB5D0;
  *(void *)(a1 + 48) = a5;
  *(void *)(a1 + 56) = &unk_26C4EDD48;
  RB::Coverage::StrokeablePath::StrokeablePath(a1 + 64, a3 + 8, a2);
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a3 + 56);
  *(unsigned char *)(a1 + 128) = *(unsigned char *)(a3 + 72);
  *(_WORD *)(a1 + 129) = *(_WORD *)(a3 + 73);
  *(unsigned char *)(a1 + 131) = *(unsigned char *)(a3 + 75);
  *(unsigned char *)(a1 + 132) = *(unsigned char *)(a3 + 76);
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a3 + 80);
  RB::Fill::Custom::Custom((RB::CustomShader::Closure *)(a1 + 144), a4);
  return a1;
}

void sub_21416CAF4(_Unwind_Exception *a1)
{
  v1[7] = v2;
  RBPathRelease(v1[8], v1[9]);
  _Unwind_Resume(a1);
}

void *RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4EB5D0;
  uint64_t v2 = (const void **)(a1 + 19);
  uint64_t v3 = (const void **)a1[31];
  if (v3) {
    RBPath v4 = v3;
  }
  else {
    RBPath v4 = v2;
  }
  if (a1[32])
  {
    unint64_t v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[32]);
    uint64_t v3 = (const void **)a1[31];
  }
  if (v3) {
    free(v3);
  }
  uint64_t v6 = (atomic_uint *)a1[18];
  if (v6 && atomic_fetch_add_explicit(v6 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v6 + 8))(v6);
  }
  a1[7] = &unk_26C4EDD48;
  RBPathRelease(a1[8], a1[9]);
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4EB5D0;
  uint64_t v2 = (const void **)(a1 + 19);
  uint64_t v3 = (const void **)a1[31];
  if (v3) {
    RBPath v4 = v3;
  }
  else {
    RBPath v4 = v2;
  }
  if (a1[32])
  {
    unint64_t v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[32]);
    uint64_t v3 = (const void **)a1[31];
  }
  if (v3) {
    free(v3);
  }
  uint64_t v6 = (atomic_uint *)a1[18];
  if (v6 && atomic_fetch_add_explicit(v6 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v6 + 8))(v6);
  }
  a1[7] = &unk_26C4EDD48;
  RBPathRelease(a1[8], a1[9]);
  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::type_id()
{
  return 16789505;
}

void *RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::copy(uint64_t a1, uint64_t a2, char a3)
{
  __int16 v4 = 0;
  unint64_t v5 = (uint64_t (**)(void, long long *))(*(void *)(a2 + 8) + 16);
  __int16 v6 = *(_WORD *)(a1 + 46);
  if ((a3 & 2) != 0) {
    goto LABEL_9;
  }
  if ((*(_WORD *)(a1 + 46) & 0x1000) != 0 || *(unsigned char *)(a2 + 272) == 0) {
    goto LABEL_9;
  }
  v10[0] = (uint64_t (**)(void, long long *))&unk_26C4E7FB0;
  v10[1] = v5;
  _DWORD v10[2] = (uint64_t (**)(void, long long *))a1;
  float64x2_t v10[3] = (uint64_t (**)(void, long long *))(a1 + 144);
  v10[4] = *(uint64_t (***)(void, long long *))(a1 + 48);
  uint64_t v11 = 0;
  RB::Coverage::StrokeablePath::simplify(a1 + 64, a1 + 56, v10);
  __n128 result = (void *)v11;
  if (!v11)
  {
    __int16 v6 = *(_WORD *)(a1 + 46);
    __int16 v4 = 4096;
LABEL_9:
    LODWORD(v10[0]) = v6 & 0x3F;
    __n128 result = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill6CustomEEEJRS0_RKS7_RKS9_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_((RB::Heap *)v5, (uint64_t)v5, a1 + 56, a1 + 144, (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), v10);
    *((_OWORD *)result + 1) = *(_OWORD *)(a1 + 16);
    result[4] = *(void *)(a1 + 32);
    *((_DWORD *)result + 10) = *(_DWORD *)(a1 + 40);
    __int16 v9 = *((_WORD *)result + 23) | *(_WORD *)(a1 + 46) & 0x5800;
    *((_WORD *)result + 23) = v9;
    goto LABEL_10;
  }
  __int16 v9 = *(_WORD *)(v11 + 46);
  __int16 v4 = 4096;
LABEL_10:
  *((_WORD *)result + 23) = v9 | v4;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  __n128 result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::atom_position(uint64_t a1, double a2, int32x4_t a3)
{
  float32x2_t v3 = RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, *(float64x2_t **)(a1 + 48), a2, a3);
  return vmla_f32(v3, (float32x2_t)0x3F0000003F000000, v4);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::can_append_color_matrix()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::required_depth()
{
  return 0;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::bounds(uint64_t a1, double a2, int32x4_t a3)
{
  return RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, *(float64x2_t **)(a1 + 48), a2, a3);
}

float RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::min_scale(uint64_t a1)
{
  float result = 0.0;
  if (!*(unsigned char *)(a1 + 128) && *(unsigned char *)(a1 + 132) == 1) {
    return 1.0;
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::has_no_effect(uint64_t a1)
{
  __asm { FCMP            H0, #0 }
  if (_ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  else {
    return 0;
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::prepare(uint64_t a1, const RB::RenderParams *a2)
{
  return RB::Fill::Custom::prepare((RB::Fill::Custom *)(a1 + 144), a2, *(const RB::AffineTransform **)(a1 + 48));
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::render(uint64_t a1, int a2, uint64_t **a3, double a4, int a5, int a6)
{
  uint64_t v6 = *(void *)(a1 + 48);
  v7.i64[0] = SLODWORD(a4);
  v7.i64[1] = SHIDWORD(a4);
  long long v8 = *(_OWORD *)(v6 + 16);
  float64x2_t v9 = vaddq_f64(*(float64x2_t *)(v6 + 32), vcvtq_f64_s64(v7));
  v16[0] = *(_OWORD *)v6;
  v16[1] = v8;
  _OWORD v16[2] = v9;
  _H0 = *(_WORD *)(a1 + 44);
  int v17 = *(unsigned __int8 *)(a1 + 128);
  __int16 v18 = *(_WORD *)(a1 + 129);
  int v19 = *(unsigned __int8 *)(a1 + 131);
  char v20 = *(unsigned char *)(a1 + 132);
  int v21 = *(_DWORD *)(a1 + 136);
  int v22 = 1065353216;
  uint64_t v23 = 1;
  uint64_t v24 = 0;
  if (v17 == 1) {
    abort();
  }
  __asm { FCVT            S0, H0 }
  RB::render_stroke(a3, (uint64_t (**)(void, void *, __n128, __n128))v16, a1 + 56, (uint64_t)&v17, (RB::Fill::Custom *)(a1 + 144), a5, a6, _S0);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::render(uint64_t a1, uint64_t a2)
{
  float32x2_t v4 = *(float64x2_t **)(a1 + 48);
  unint64_t v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  unsigned int v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&float32x2_t v12 = (*(double (**)(uint64_t, void))(*(void *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v18, v12, v13);
  int v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5) {
    goto LABEL_10;
  }
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v18[0].f64[0], *(int32x2_t *)&v18[0].f64[1]))
  {
    int v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v18, v14, _S8);
    goto LABEL_11;
  }
  int v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4) {
    goto LABEL_10;
  }
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11) {
    goto LABEL_10;
  }
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::StrokeablePath::clip(a1 + 64, a1 + 56, a2);
  v18[0] = (float64x2_t)xmmword_2142181C0;
  v18[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  float32x2_t v16 = RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, v18, 1.0, (int32x4_t)xmmword_2142181D0);
  RB::Bounds::Bounds(&v21, v16, v17);
  RBStrokeRef::clip(a1 + 144);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 144), a2);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, uint64_t a4)
{
  float result = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)a4 + 16))(a4);
  if (result == 16789505)
  {
    float result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      float result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a4 + 48), v10);
      int v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        if (*(unsigned __int8 *)(a1 + 128) == *(unsigned __int8 *)(a4 + 128)
          && *(unsigned __int8 *)(a1 + 129) == *(unsigned __int8 *)(a4 + 129)
          && *(unsigned __int8 *)(a1 + 130) == *(unsigned __int8 *)(a4 + 130)
          && *(unsigned __int8 *)(a1 + 131) == *(unsigned __int8 *)(a4 + 131)
          && *(unsigned __int8 *)(a1 + 132) == *(unsigned __int8 *)(a4 + 132)
          && *(float *)(a1 + 136) == *(float *)(a4 + 136))
        {
          float result = (unint64_t *)RB::Coverage::StrokeablePath::can_mix(a1 + 64, a4 + 64, v12);
          if ((_BYTE)result)
          {
            unsigned __int8 v13 = result;
            can_mifloat64_t x = RB::Fill::Custom::can_mix((RB::Fill::Custom *)(a1 + 144), (const RB::Fill::Custom *)(a4 + 144));
            return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v13, can_mix);
          }
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8 = (*(uint64_t (**)(CGAffineTransform **, void, void, void, uint64_t))&(*a1)[1].a)(a1, *(void *)&a4->f64[0], *(unsigned int *)(*(void *)(a2 + 8) + 12), **(void **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v30[0] = v10;
  v30[1] = v11;
  long long v30[2] = v12;
  *(void *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v30);
  unsigned __int8 v13 = (RB::Heap *)(*(void *)(*(void *)&a4->f64[0] + 8) + 16);
  int v14 = (atomic_uint **)(v8 + 144);
  RB::Fill::Custom::mix((RB::Fill::Custom *)(v8 + 144), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::Custom *)(a3 + 144), *(float *)(a2 + 16), v13);
  *(double *)&long long v15 = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  long long v27 = v15;
  long long v28 = v16;
  long long v29 = v17;
  *(double *)&long long v18 = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  v26[0] = v18;
  v26[1] = v19;
  int32x2_t v26[2] = v20;
  LODWORD(v18) = *(_DWORD *)(a2 + 16);
  RB::Coverage::StrokeablePath::mix(v8 + 64, v13, a3 + 64, (uint64_t)&v27, (uint64_t)v26, *(void *)(v8 + 48), *(CGFloat *)&v18);
  *(float *)(v8 + 136) = *(float *)(v8 + 136)
                       + (float)((float)(*(float *)(a3 + 136) - *(float *)(v8 + 136)) * *(float *)(a2 + 16));
  *(void *)(v8 + 112) = 0x100000001000000;
  *(int32x2_t *)(v8 + 120) = vdup_n_s32(0x7F7FFFFFu);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(unsigned char *)(*(void *)&a4->f64[0] + 272))
  {
    *(void *)&long long v27 = &unk_26C4E7FB0;
    *((void *)&v27 + 1) = v13;
    *(void *)&long long v28 = v8;
    *((void *)&v28 + 1) = v8 + 144;
    long long v29 = *(unint64_t *)(v8 + 48);
    RB::Coverage::StrokeablePath::simplify(v8 + 64, v8 + 56, (uint64_t (***)(void, long long *))&v27);
    if (*((void *)&v29 + 1))
    {
      *(void *)uint64_t v8 = &unk_26C4EB5D0;
      int32x2_t v21 = *(void **)(v8 + 248);
      if (v21) {
        int v22 = *(const void ***)(v8 + 248);
      }
      else {
        int v22 = (const void **)(v8 + 152);
      }
      if (*(void *)(v8 + 256))
      {
        unint64_t v23 = 0;
        do
        {
          RB::CustomShader::Value::reset_data(v22);
          ++v23;
          v22 += 3;
        }
        while (v23 < *(void *)(v8 + 256));
        int32x2_t v21 = *(void **)(v8 + 248);
      }
      if (v21) {
        free(v21);
      }
      uint64_t v24 = *v14;
      if (*v14 && atomic_fetch_add_explicit(v24 + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        (*(void (**)(atomic_uint *))(*(void *)v24 + 8))(v24);
      }
      *(void *)(v8 + 56) = &unk_26C4EDD48;
      RBPathRelease(*(void *)(v8 + 64), *(void *)(v8 + 72));
      uint64_t v8 = *((void *)&v29 + 1);
    }
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::prepare_encode(uint64_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode(a1, a2);
  return RB::Fill::Custom::prepare_encode((RB::Fill::Custom *)(a1 + 18), a2);
}

void *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::encode(void *a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(this, 1, (uint64_t)(a1 + 7));
  RB::Encoder::typed_message_field<RB::Fill::Custom>(this, 2, (RB::Fill::Custom *)(a1 + 18));
  float32x2_t v4 = (float64x2_t *)a1[6];
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::print(const RB::AffineTransform **a1, std::string *this)
{
}

void *RB::Encoder::typed_message_field<RB::Fill::Custom>(RB::Encoder *a1, uint64_t a2, RB::Fill::Custom *a3)
{
  RB::ProtobufEncoder::encode_varint(a1, (8 * a2) | 2);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::ProtobufEncoder::encode_varint(a1, 0x22uLL);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::Fill::Custom::encode(a3, a1);
  RB::ProtobufEncoder::end_length_delimited(a1);
  return RB::ProtobufEncoder::end_length_delimited(a1);
}

void RB::XML::print_attributes<RB::Fill::Custom>()
{
}

void sub_21416D854(_Unwind_Exception *exception_object)
{
  int v3 = v1[2] - 1;
  v1[2] = v3;
  if (!v3) {
    (*(void (**)(_DWORD *))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, float *a6, _DWORD *a7)
{
  unint64_t v14 = *((void *)this + 3);
  uint64_t v15 = (*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v15 + 352 > v14) {
    uint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0x160uLL, 15);
  }
  else {
    *((void *)this + 2) = v15 + 352;
  }
  float result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::GenericItem1(v15, a2, a3, a4, *a5, *a7, *a6);
  *float result = &unk_26C4E9E30;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::GenericItem1(uint64_t a1, size_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, float _S0)
{
  __asm { FCVT            H0, S0 }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F;
  *(void *)a1 = &unk_26C4EA8B0;
  *(void *)(a1 + 48) = a5;
  *(void *)(a1 + 56) = RBPathRetain(*(void *)a3, *(void *)(a3 + 8));
  *(void *)(a1 + 64) = v16;
  long long v17 = *(long long **)(a3 + 16);
  if (v17)
  {
    long long v18 = (_OWORD *)((a2[2] + 15) & 0xFFFFFFFFFFFFFFF0);
    if ((unint64_t)(v18 + 3) > a2[3]) {
      long long v18 = (_OWORD *)RB::Heap::alloc_slow(a2, 0x30uLL, 15);
    }
    else {
      a2[2] = (size_t)(v18 + 3);
    }
    long long v19 = *v17;
    long long v20 = v17[2];
    v18[1] = v17[1];
    float64x2_t v18[2] = v20;
    *long long v18 = v19;
  }
  else
  {
    long long v18 = 0;
  }
  *(void *)(a1 + 72) = v18;
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a3 + 24);
  *(_WORD *)(a1 + 84) = *(_WORD *)(a3 + 28);
  RB::Fill::Custom::Custom((RB::CustomShader::Closure *)(a1 + 96), a4);
  return a1;
}

void sub_21416DA5C(_Unwind_Exception *a1)
{
  RBPathRelease(*(void *)(v1 + 56), *(void *)(v1 + 64));
  _Unwind_Resume(a1);
}

void *RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Custom>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4EA8B0;
  uint64_t v2 = (const void **)(a1 + 13);
  int v3 = (const void **)a1[25];
  if (v3) {
    float32x2_t v4 = v3;
  }
  else {
    float32x2_t v4 = v2;
  }
  if (a1[26])
  {
    unint64_t v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[26]);
    int v3 = (const void **)a1[25];
  }
  if (v3) {
    free(v3);
  }
  uint64_t v6 = (atomic_uint *)a1[12];
  if (v6 && atomic_fetch_add_explicit(v6 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v6 + 8))(v6);
  }
  RBPathRelease(a1[7], a1[8]);
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Custom>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4EA8B0;
  uint64_t v2 = (const void **)(a1 + 13);
  int v3 = (const void **)a1[25];
  if (v3) {
    float32x2_t v4 = v3;
  }
  else {
    float32x2_t v4 = v2;
  }
  if (a1[26])
  {
    unint64_t v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[26]);
    int v3 = (const void **)a1[25];
  }
  if (v3) {
    free(v3);
  }
  uint64_t v6 = (atomic_uint *)a1[12];
  if (v6 && atomic_fetch_add_explicit(v6 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v6 + 8))(v6);
  }
  RBPathRelease(a1[7], a1[8]);
  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::type_id()
{
  return 16785409;
}

void *RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Custom>::copy(uint64_t a1, uint64_t a2, char a3)
{
  __int16 v4 = 0;
  unint64_t v5 = (RB::Heap *)(*(void *)(a2 + 8) + 16);
  __int16 v6 = *(_WORD *)(a1 + 46);
  if ((a3 & 2) != 0) {
    goto LABEL_9;
  }
  if ((*(_WORD *)(a1 + 46) & 0x1000) != 0 || *(unsigned char *)(a2 + 272) == 0) {
    goto LABEL_9;
  }
  v10[0] = &unk_26C4E7FB0;
  v10[1] = v5;
  _DWORD v10[2] = a1;
  float64x2_t v10[3] = a1 + 96;
  v10[4] = *(void *)(a1 + 48);
  uint64_t v11 = 0;
  RB::Coverage::Path::simplify(a1 + 56, (uint64_t)v10);
  float result = (void *)v11;
  if (!v11)
  {
    __int16 v6 = *(_WORD *)(a1 + 46);
    __int16 v4 = 4096;
LABEL_9:
    LODWORD(v10[0]) = v6 & 0x3F;
    float result = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage4PathENS_4Fill6CustomEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, (size_t *)v5, a1 + 56, a1 + 96, (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), v10);
    *((_OWORD *)result + 1) = *(_OWORD *)(a1 + 16);
    result[4] = *(void *)(a1 + 32);
    *((_DWORD *)result + 10) = *(_DWORD *)(a1 + 40);
    __int16 v9 = *((_WORD *)result + 23) | *(_WORD *)(a1 + 46) & 0x5800;
    *((_WORD *)result + 23) = v9;
    goto LABEL_10;
  }
  __int16 v9 = *(_WORD *)(v11 + 46);
  __int16 v4 = 4096;
LABEL_10:
  *((_WORD *)result + 23) = v9 | v4;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  float result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::atom_position(uint64_t a1)
{
  v4.callbacks = *(RBPathCallbacks **)(a1 + 48);
  v4.mach_timebase_info info = (void *)(a1 + 56);
  double v1 = RB::Coverage::Path::bounds(v4);
  return vmla_f32(*(float32x2_t *)&v1, (float32x2_t)0x3F0000003F000000, v2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::can_append_color_matrix()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::required_depth()
{
  return 0;
}

double RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::bounds(uint64_t a1)
{
  v2.callbacks = *(RBPathCallbacks **)(a1 + 48);
  v2.mach_timebase_info info = (void *)(a1 + 56);
  return RB::Coverage::Path::bounds(v2);
}

float RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::min_scale(uint64_t a1)
{
  float result = RB::Coverage::Path::min_scale((RB::Coverage::Path *)(a1 + 56), *(const RB::AffineTransform **)(a1 + 48));
  if (result < 0.0) {
    return 0.0;
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::has_no_effect(uint64_t a1)
{
  __asm { FCMP            H0, #0 }
  if (_ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  else {
    return 0;
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::prepare(uint64_t a1, const RB::RenderParams *a2)
{
  return RB::Fill::Custom::prepare((RB::Fill::Custom *)(a1 + 96), a2, *(const RB::AffineTransform **)(a1 + 48));
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::render(uint64_t a1, int a2, RB::RenderPass *a3, double a4, char a5, int a6)
{
  v24[5] = *(int32x2_t **)MEMORY[0x263EF8340];
  uint64_t v9 = *(void *)(a1 + 48);
  v10.i64[0] = SLODWORD(a4);
  v10.i64[1] = SHIDWORD(a4);
  long long v11 = *(_OWORD *)(v9 + 16);
  float64x2_t v12 = vaddq_f64(*(float64x2_t *)(v9 + 32), vcvtq_f64_s64(v10));
  v19[0] = *(_OWORD *)v9;
  v19[1] = v11;
  v19[2] = v12;
  _H8 = *(_WORD *)(a1 + 44);
  RB::Path::ImmediateRenderer::ImmediateRenderer((RB::Path::ImmediateRenderer *)v20, a3, (const RB::AffineTransform *)v19, (const RB::Coverage::Path *)(a1 + 56));
  __asm { FCVT            S0, H8 }
  RB::Path::Renderer::render(v24, a1 + 96, (uint64_t)v19, a5, a6, _S0);
  if (v23) {
    RB::Path::Accumulator::commit_buffer((RB::Path::Accumulator *)&v21);
  }
  if (v22) {
    free(v22);
  }
}

void sub_21416DF64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
  if (a47) {
    free(a47);
  }
  _Unwind_Resume(exception_object);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::render(uint64_t a1, uint64_t a2)
{
  RBPath v4 = *(float64x2_t **)(a1 + 48);
  unint64_t v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  unsigned int v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&float32x2_t v12 = (*(double (**)(uint64_t, void))(*(void *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v18, v12, v13);
  int v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5) {
    goto LABEL_10;
  }
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v18[0], *(int32x2_t *)((char *)v18 + 8)))
  {
    int v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v18, v14, _S8);
    goto LABEL_11;
  }
  int v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4) {
    goto LABEL_10;
  }
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11) {
    goto LABEL_10;
  }
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::Path::clip((RB::Coverage::Path *)(a1 + 56), (CGContextRef *)a2);
  v18[0] = xmmword_2142181C0;
  v18[1] = xmmword_2142181D0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  v22.callbacks = (RBPathCallbacks *)v18;
  v22.mach_timebase_info info = (void *)(a1 + 56);
  double v16 = RB::Coverage::Path::bounds(v22);
  RB::Bounds::Bounds(&v21, *(float32x2_t *)&v16, v17);
  RBStrokeRef::clip(a1 + 96);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 96), a2);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::prepare_mix(float64x2_t **a1, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Interpolator::Op *a3, float64x2_t **a4)
{
  float result = (unint64_t *)(*(uint64_t (**)(float64x2_t **))&(*a4)[1].f64[0])(a4);
  if (result == 16785409)
  {
    float result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      float result = (unint64_t *)RB::can_mix(a1[6], a4[6], v10);
      int v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        float result = (unint64_t *)RB::Coverage::Path::can_mix(a1 + 7, a3, a4 + 7);
        if ((_BYTE)result)
        {
          unsigned __int8 v12 = result;
          can_mifloat64_t x = RB::Fill::Custom::can_mix((RB::Fill::Custom *)(a1 + 12), (const RB::Fill::Custom *)(a4 + 12));
          return RB::DisplayList::Interpolator::Op::set_type((unint64_t *)a3, v11, v12, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8 = (*(uint64_t (**)(CGAffineTransform **, void, void, void, uint64_t))&(*a1)[1].a)(a1, *(void *)&a4->f64[0], *(unsigned int *)(*(void *)(a2 + 8) + 12), **(void **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v30[0] = v10;
  v30[1] = v11;
  long long v30[2] = v12;
  *(void *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v30);
  float32x2_t v13 = (RB::Heap *)(*(void *)(*(void *)&a4->f64[0] + 8) + 16);
  int v14 = (atomic_uint **)(v8 + 96);
  RB::Fill::Custom::mix((RB::Fill::Custom *)(v8 + 96), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::Custom *)(a3 + 96), *(float *)(a2 + 16), v13);
  v15.f64[0] = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  float64x2_t v27 = v15;
  long long v28 = v16;
  long long v29 = v17;
  v18.f64[0] = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  v26[0] = v18;
  v26[1] = v19;
  int32x2_t v26[2] = v20;
  RB::Coverage::Path::mix((RBPath *)(v8 + 56), (const RB::DisplayList::Interpolator::State *)a2, (RBPath *)(a3 + 56), &v27, v26, *(float64x2_t **)(v8 + 48), v13);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(unsigned char *)(*(void *)&a4->f64[0] + 272))
  {
    *(void *)&v27.f64[0] = &unk_26C4E7FB0;
    *(void *)&v27.f64[1] = v13;
    *(void *)&long long v28 = v8;
    *((void *)&v28 + 1) = v8 + 96;
    long long v29 = *(unint64_t *)(v8 + 48);
    RB::Coverage::Path::simplify(v8 + 56, (uint64_t)&v27);
    if (*((void *)&v29 + 1))
    {
      *(void *)uint64_t v8 = &unk_26C4EA8B0;
      int32x2_t v21 = *(void **)(v8 + 200);
      if (v21) {
        RBPath v22 = *(const void ***)(v8 + 200);
      }
      else {
        RBPath v22 = (const void **)(v8 + 104);
      }
      if (*(void *)(v8 + 208))
      {
        unint64_t v23 = 0;
        do
        {
          RB::CustomShader::Value::reset_data(v22);
          ++v23;
          v22 += 3;
        }
        while (v23 < *(void *)(v8 + 208));
        int32x2_t v21 = *(void **)(v8 + 200);
      }
      if (v21) {
        free(v21);
      }
      uint64_t v24 = *v14;
      if (*v14 && atomic_fetch_add_explicit(v24 + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        (*(void (**)(atomic_uint *))(*(void *)v24 + 8))(v24);
      }
      RBPathRelease(*(void *)(v8 + 56), *(void *)(v8 + 64));
      uint64_t v8 = *((void *)&v29 + 1);
    }
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::prepare_encode(uint64_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode(a1, a2);
  return RB::Fill::Custom::prepare_encode((RB::Fill::Custom *)(a1 + 12), a2);
}

void *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::encode(uint64_t a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Path>(this, 1, (RBPath *)(a1 + 56));
  RB::Encoder::typed_message_field<RB::Fill::Custom>(this, 2, (RB::Fill::Custom *)(a1 + 96));
  RBPath v4 = *(float64x2_t **)(a1 + 48);
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::print(const RB::AffineTransform **a1, std::string *this)
{
}

void *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage4PathENS_4Fill6CustomEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, size_t *a2, uint64_t a3, uint64_t a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14 = *((void *)this + 3);
  uint64_t v15 = (*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v15 + 304 > v14) {
    uint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0x130uLL, 15);
  }
  else {
    *((void *)this + 2) = v15 + 304;
  }
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  float result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::GenericItem1(v15, a2, a3, a4, *a5, *a7, _S0);
  *float result = &unk_26C4E9110;
  return result;
}

void *RBFillData::apply<RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>>(void *result, uint64_t a2)
{
  switch(*(_DWORD *)result)
  {
    case 1:
      float result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::operator()<RB::Fill::Color>(a2, (uint64_t (**)(void, long long *))result + 2);
      break;
    case 2:
      float result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::operator()<RB::Fill::Gradient>(a2, (uint64_t (**)(void, long long *))result + 2);
      break;
    case 3:
      float result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::operator()<RB::Fill::MeshGradient>(a2, (uint64_t (**)(void, long long *))result + 2);
      break;
    case 4:
      float result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::operator()<RB::Fill::Image<RB::ImageTexture>>(a2, (uint64_t (**)(void, long long *))result + 2);
      break;
    case 5:
      float result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::operator()<RB::Fill::Custom>(a2, (uint64_t (**)(void, long long *))result + 2);
      break;
    default:
      return result;
  }
  return result;
}

void *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::operator()<RB::Fill::Color>(uint64_t a1, uint64_t (**a2)(void, long long *))
{
  RBPath v4 = *(uint64_t (**)(void, long long *))a1;
  if (*(unsigned char *)(*(void *)a1 + 48))
  {
    v6[0] = (uint64_t (**)(void, long long *))&unk_26C4EA540;
    v6[1] = (uint64_t (**)(void, long long *))a1;
    float32x2_t v6[2] = a2;
    RB::Coverage::StrokeablePath::simplify(*(void *)(a1 + 8) + 8, *(void *)(a1 + 8), v6);
    RBPath v4 = *(uint64_t (**)(void, long long *))a1;
  }
  float result = (void *)*((void *)v4 + 7);
  if (!result)
  {
    float result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v4, *(void *)v4, *(void *)(a1 + 8), (uint64_t)a2, (uint64_t *)v4 + 1, (float *)v4 + 4, (_DWORD *)v4 + 5, (__int16 *)v4 + 12);
    RBPath v4 = *(uint64_t (**)(void, long long *))a1;
    *(void *)(*(void *)a1 + 56) = result;
  }
  if (*((unsigned char *)v4 + 48)) {
    *((_WORD *)result + 23) |= 0x1000u;
  }
  return result;
}

void *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::operator()<RB::Fill::Gradient>(uint64_t a1, uint64_t (**a2)(void, long long *))
{
  RBPath v4 = *(uint64_t (**)(void, long long *))a1;
  if (*(unsigned char *)(*(void *)a1 + 48))
  {
    v6[0] = (uint64_t (**)(void, long long *))&unk_26C4EA5A0;
    v6[1] = (uint64_t (**)(void, long long *))a1;
    float32x2_t v6[2] = a2;
    RB::Coverage::StrokeablePath::simplify(*(void *)(a1 + 8) + 8, *(void *)(a1 + 8), v6);
    RBPath v4 = *(uint64_t (**)(void, long long *))a1;
  }
  float result = (void *)*((void *)v4 + 7);
  if (!result)
  {
    float result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v4, *(RB::Heap **)v4, *(void *)(a1 + 8), (uint64_t *)a2, (uint64_t *)v4 + 1, (float *)v4 + 4, (_DWORD *)v4 + 5, (__int16 *)v4 + 12);
    RBPath v4 = *(uint64_t (**)(void, long long *))a1;
    *(void *)(*(void *)a1 + 56) = result;
  }
  if (*((unsigned char *)v4 + 48)) {
    *((_WORD *)result + 23) |= 0x1000u;
  }
  return result;
}

void *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::operator()<RB::Fill::MeshGradient>(uint64_t a1, uint64_t (**a2)(void, long long *))
{
  RBPath v4 = *(uint64_t (**)(void, long long *))a1;
  if (*(unsigned char *)(*(void *)a1 + 48))
  {
    v6[0] = (uint64_t (**)(void, long long *))&unk_26C4E7988;
    v6[1] = (uint64_t (**)(void, long long *))a1;
    float32x2_t v6[2] = a2;
    RB::Coverage::StrokeablePath::simplify(*(void *)(a1 + 8) + 8, *(void *)(a1 + 8), v6);
    RBPath v4 = *(uint64_t (**)(void, long long *))a1;
  }
  float result = (void *)*((void *)v4 + 7);
  if (!result)
  {
    float result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v4, *(RB::Heap **)v4, *(void *)(a1 + 8), (uint64_t)a2, (uint64_t *)v4 + 1, (float *)v4 + 4, (_DWORD *)v4 + 5, (__int16 *)v4 + 12);
    RBPath v4 = *(uint64_t (**)(void, long long *))a1;
    *(void *)(*(void *)a1 + 56) = result;
  }
  if (*((unsigned char *)v4 + 48)) {
    *((_WORD *)result + 23) |= 0x1000u;
  }
  return result;
}

void *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::operator()<RB::Fill::Image<RB::ImageTexture>>(uint64_t a1, uint64_t (**a2)(void, long long *))
{
  RBPath v4 = *(uint64_t (**)(void, long long *))a1;
  if (*(unsigned char *)(*(void *)a1 + 48))
  {
    v6[0] = (uint64_t (**)(void, long long *))&unk_26C4EA560;
    v6[1] = (uint64_t (**)(void, long long *))a1;
    float32x2_t v6[2] = a2;
    RB::Coverage::StrokeablePath::simplify(*(void *)(a1 + 8) + 8, *(void *)(a1 + 8), v6);
    RBPath v4 = *(uint64_t (**)(void, long long *))a1;
  }
  float result = (void *)*((void *)v4 + 7);
  if (!result)
  {
    float result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v4, *(RB::Heap **)v4, *(void *)(a1 + 8), (const RB::ImageTexture *)a2, (uint64_t *)v4 + 1, (float *)v4 + 4, (_DWORD *)v4 + 5, (__int16 *)v4 + 12);
    RBPath v4 = *(uint64_t (**)(void, long long *))a1;
    *(void *)(*(void *)a1 + 56) = result;
  }
  if (*((unsigned char *)v4 + 48)) {
    *((_WORD *)result + 23) |= 0x1000u;
  }
  return result;
}

void *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::operator()<RB::Fill::Custom>(uint64_t a1, uint64_t (**a2)(void, long long *))
{
  RBPath v4 = *(uint64_t (**)(void, long long *))a1;
  if (*(unsigned char *)(*(void *)a1 + 48))
  {
    v6[0] = (uint64_t (**)(void, long long *))&unk_26C4EA580;
    v6[1] = (uint64_t (**)(void, long long *))a1;
    float32x2_t v6[2] = a2;
    RB::Coverage::StrokeablePath::simplify(*(void *)(a1 + 8) + 8, *(void *)(a1 + 8), v6);
    RBPath v4 = *(uint64_t (**)(void, long long *))a1;
  }
  float result = (void *)*((void *)v4 + 7);
  if (!result)
  {
    float result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v4, *(void *)v4, *(void *)(a1 + 8), (uint64_t)a2, (uint64_t *)v4 + 1, (float *)v4 + 4, (_DWORD *)v4 + 5);
    RBPath v4 = *(uint64_t (**)(void, long long *))a1;
    *(void *)(*(void *)a1 + 56) = result;
  }
  if (*((unsigned char *)v4 + 48)) {
    *((_WORD *)result + 23) |= 0x1000u;
  }
  return result;
}

void RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::visit(uint64_t a1, long long *a2)
{
  RBPath v2 = *(RB::Heap ****)(a1 + 8);
  int v3 = *v2;
  RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Color>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, (uint64_t)**v2, a2, *(void *)(a1 + 16), (uint64_t *)*v2 + 1, (int *)*v2 + 4, (_WORD *)*v2 + 10, (__int16 *)*v2 + 12);
  v3[7] = v4;
}

RB::Heap *RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::visit(uint64_t a1, uint64_t a2)
{
  RBPath v2 = *(RB::Heap ****)(a1 + 8);
  int v3 = *v2;
  float result = (RB::Heap *)RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, (uint64_t)**v2, a2, *(void *)(a1 + 16), (uint64_t *)*v2 + 1, (float *)*v2 + 4, (_DWORD *)*v2 + 5, (__int16 *)*v2 + 12);
  v3[7] = result;
  return result;
}

unint64_t RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::visit(uint64_t a1, long long *a2)
{
  RBPath v2 = *(size_t ****)(a1 + 8);
  int v3 = *v2;
  unint64_t result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, (RB::Heap *)**v2, a2, *(uint64_t **)(a1 + 16), (uint64_t *)*v2 + 1, (int *)*v2 + 4, (_WORD *)*v2 + 10, (__int16 *)*v2 + 12);
  v3[7] = (size_t *)result;
  return result;
}

RB::Heap *RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::visit(uint64_t a1, uint64_t a2)
{
  RBPath v2 = *(RB::Heap ****)(a1 + 8);
  int v3 = *v2;
  unint64_t result = (RB::Heap *)RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, **v2, a2, *(uint64_t **)(a1 + 16), (uint64_t *)*v2 + 1, (float *)*v2 + 4, (_DWORD *)*v2 + 5, (__int16 *)*v2 + 12);
  v3[7] = result;
  return result;
}

unint64_t RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::visit(uint64_t a1, long long *a2)
{
  RBPath v2 = *(size_t ****)(a1 + 8);
  int v3 = *v2;
  unint64_t result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, (RB::Heap *)**v2, a2, *(void *)(a1 + 16), (uint64_t *)*v2 + 1, (int *)*v2 + 4, (__int16 *)*v2 + 10, (__int16 *)*v2 + 12);
  v3[7] = (size_t *)result;
  return result;
}

RB::Heap *RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::visit(uint64_t a1, uint64_t a2)
{
  RBPath v2 = *(RB::Heap ****)(a1 + 8);
  int v3 = *v2;
  unint64_t result = (RB::Heap *)RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, **v2, a2, *(void *)(a1 + 16), (uint64_t *)*v2 + 1, (float *)*v2 + 4, (_DWORD *)*v2 + 5, (__int16 *)*v2 + 12);
  v3[7] = result;
  return result;
}

RB::Heap *RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::visit(uint64_t a1, long long *a2)
{
  RBPath v2 = *(RB::Heap ****)(a1 + 8);
  int v3 = *v2;
  unint64_t result = (RB::Heap *)RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, **v2, a2, *(RB::ImageTexture **)(a1 + 16), (uint64_t *)*v2 + 1, (float *)*v2 + 4, (_DWORD *)*v2 + 5, (__int16 *)*v2 + 12);
  v3[7] = result;
  return result;
}

RB::Heap *RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::visit(uint64_t a1, uint64_t a2)
{
  RBPath v2 = *(RB::Heap ****)(a1 + 8);
  int v3 = *v2;
  unint64_t result = (RB::Heap *)RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, **v2, a2, *(const RB::ImageTexture **)(a1 + 16), (uint64_t *)*v2 + 1, (float *)*v2 + 4, (_DWORD *)*v2 + 5, (__int16 *)*v2 + 12);
  v3[7] = result;
  return result;
}

unint64_t RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::visit(uint64_t a1, long long *a2)
{
  RBPath v2 = *(size_t ****)(a1 + 8);
  int v3 = *v2;
  unint64_t result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, (uint64_t)**v2, a2, *(void *)(a1 + 16), (uint64_t *)*v2 + 1, (int *)*v2 + 4, (_WORD *)*v2 + 10);
  v3[7] = (size_t *)result;
  return result;
}

RB::Heap *RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::visit(uint64_t a1, uint64_t a2)
{
  RBPath v2 = *(RB::Heap ****)(a1 + 8);
  int v3 = *v2;
  unint64_t result = (RB::Heap *)RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, (uint64_t)**v2, a2, *(void *)(a1 + 16), (uint64_t *)*v2 + 1, (float *)*v2 + 4, (_DWORD *)*v2 + 5);
  v3[7] = result;
  return result;
}

void *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Glyphs>::operator()<RB::Fill::Gradient>(RB::Coverage::Glyphs **a1, uint64_t *a2)
{
  int v3 = *a1;
  unint64_t result = (void *)*((void *)*a1 + 7);
  if (!result)
  {
    unint64_t result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Glyphs const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v3, *(RB::Heap **)v3, a1[1], a2, (uint64_t *)v3 + 1, (float *)v3 + 4, (_DWORD *)v3 + 5, (__int16 *)v3 + 12);
    int v3 = *a1;
    *((void *)*a1 + 7) = result;
  }
  if (*((unsigned char *)v3 + 48)) {
    *((_WORD *)result + 23) |= 0x1000u;
  }
  return result;
}

void *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Glyphs>::operator()<RB::Fill::MeshGradient>(RB::Coverage::Glyphs **a1, uint64_t a2)
{
  int v3 = *a1;
  unint64_t result = (void *)*((void *)*a1 + 7);
  if (!result)
  {
    unint64_t result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Glyphs const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v3, *(RB::Heap **)v3, a1[1], a2, (uint64_t *)v3 + 1, (float *)v3 + 4, (_DWORD *)v3 + 5, (__int16 *)v3 + 12);
    int v3 = *a1;
    *((void *)*a1 + 7) = result;
  }
  if (*((unsigned char *)v3 + 48)) {
    *((_WORD *)result + 23) |= 0x1000u;
  }
  return result;
}

void *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Glyphs>::operator()<RB::Fill::Image<RB::ImageTexture>>(RB::Coverage::Glyphs **a1, const RB::ImageTexture *a2)
{
  int v3 = *a1;
  unint64_t result = (void *)*((void *)*a1 + 7);
  if (!result)
  {
    unint64_t result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Glyphs const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v3, *(RB::Heap **)v3, a1[1], a2, (uint64_t *)v3 + 1, (float *)v3 + 4, (_DWORD *)v3 + 5, (__int16 *)v3 + 12);
    int v3 = *a1;
    *((void *)*a1 + 7) = result;
  }
  if (*((unsigned char *)v3 + 48)) {
    *((_WORD *)result + 23) |= 0x1000u;
  }
  return result;
}

void *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Glyphs>::operator()<RB::Fill::Custom>(RB::Coverage::Glyphs **a1, uint64_t a2)
{
  int v3 = *a1;
  unint64_t result = (void *)*((void *)*a1 + 7);
  if (!result)
  {
    unint64_t result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Glyphs const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v3, *(RB::Heap **)v3, a1[1], a2, (uint64_t *)v3 + 1, (float *)v3 + 4, (_DWORD *)v3 + 5);
    int v3 = *a1;
    *((void *)*a1 + 7) = result;
  }
  if (*((unsigned char *)v3 + 48)) {
    *((_WORD *)result + 23) |= 0x1000u;
  }
  return result;
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Color>::~GenericItem()
{
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::type_id()
{
  return 4214785;
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Color>::atom_count(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Color>::copy_atoms(uint64_t a1, uint64_t a2)
{
  MEMORY[0x270FA5388](a1, a2);
  unsigned int v5 = v4;
  unsigned int v7 = v6;
  uint64_t v8 = v3;
  uint64_t v9 = v2;
  uint64_t v16 = *MEMORY[0x263EF8340];
  if (v6 || v2[4].n128_u32[2] != v4)
  {
    RB::Heap::Heap((RB::Heap *)v14, v15, 4096, 0);
    RB::Coverage::Glyphs::Glyphs((RB::Coverage::Glyphs *)v13, (const RB::Coverage::Glyphs *)&v9[3].n128_i8[8], (RB::Heap *)v14, v7, v5);
    long long v10 = (RB::Heap *)(*(void *)(v8 + 8) + 16);
    int v12 = v9[2].n128_u16[7] & 0x3F;
    long long v11 = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill5ColorEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v10, v10, (RB::Coverage::Glyphs *)v13, (uint64_t)&v9[7], (uint64_t *)&v9[3], &v9[2].n128_i16[6], &v12);
    *((__n128 *)v11 + 1) = v9[1];
    v11[4] = v9[2].n128_u64[0];
    if (!*(unsigned char *)(v8 + 272)) {
      RB::DisplayList::Contents::copy_atoms(*(RB::DisplayList::Contents **)(v8 + 8), (const RB::DisplayList::Metadata **)v11 + 4, v7, v5);
    }
    *((_DWORD *)v11 + 10) = v9[2].n128_u32[2];
    RB::Heap::~Heap((RB::Heap *)v14);
  }
  else
  {
    RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Color>::copy(v2, v3);
  }
}

void sub_21416F140(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  RB::Heap::~Heap((RB::Heap *)va);
  _Unwind_Resume(a1);
}

float32x2_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Color>::atom_position(uint64_t a1, unsigned int a2)
{
  float64x2_t v2 = vcvtq_f64_f32(*(float32x2_t *)(*(void *)(a1 + 64) + 8 * a2));
  return vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(*(void *)(a1 + 48) + 32), *(float64x2_t *)*(void *)(a1 + 48), v2.f64[0]), *(float64x2_t *)(*(void *)(a1 + 48) + 16), v2, 1));
}

float32x2_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Color>::atom_bounds(uint64_t a1, unsigned int a2, int a3)
{
  double v4 = RB::Coverage::Glyphs::glyph_bounds((RB::Coverage::Glyphs *)(a1 + 56), a2, a3);
  unsigned int v6 = *(float64x2_t **)(a1 + 48);
  return RB::operator*(v6, *(float32x2_t *)&v4, v5);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::make_clip(uint64_t a1, uint64_t a2, int a3, void *a4, float a5)
{
  int v22 = a3;
  _H1 = *(_WORD *)(a1 + 118);
  __asm { FCVT            S1, H1 }
  float32x2_t v13 = (size_t *)(*(void *)(a2 + 8) + 16);
  _H2 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S2, H2 }
  float v21 = (float)(_S1 * a5) * _S2;
  uint64_t v16 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Glyphs>,RB::Heap&,RB::Coverage::Glyphs const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(v13, (RB::Heap *)v13, (RB::Coverage::Glyphs *)(a1 + 56), (int *)&v21, &v22, (uint64_t *)(a1 + 48));
  uint64_t v17 = a4[5];
  size_t v18 = v17 + 1;
  if (a4[6] < (unint64_t)(v17 + 1))
  {
    RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v18);
    uint64_t v17 = a4[5];
    size_t v18 = v17 + 1;
  }
  float64x2_t v19 = (void *)a4[4];
  if (!v19) {
    float64x2_t v19 = a4;
  }
  v19[v17] = v16;
  a4[5] = v18;
  return (**(uint64_t (***)(uint64_t))a1)(a1);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::can_append_color_matrix()
{
  return 1;
}

double RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::append_color_matrix(uint64_t a1, float16x4_t *a2, int a3, __int16 a4, uint16x4_t a5)
{
  *(void *)&double result = RB::Fill::Color::append_color_matrix((short float *)(a1 + 112), a2, a3, a4, a5);
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::append_alpha_gradient(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v9 = *(_WORD *)(a1 + 46) & 0x3F;
  double v4 = (RB::Heap *)(*(void *)(a2 + 8) + 16);
  short float v8 = *(short float *)(a1 + 118) * *(short float *)(a1 + 44);
  _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill8GradientEEEJRS5_RKS7_RPKNS_15AffineTransformEDF16_RNS_9BlendModeEEEEPT_DpOT0_(v4, (long long *)(a1 + 56), a3, (uint64_t *)(a1 + 48), (__int16 *)&v8, &v9);
  uint64_t v6 = v5;
  *(_OWORD *)(v5 + 16) = *(_OWORD *)(a1 + 16);
  *(void *)(v5 + 32) = *(void *)(a1 + 32);
  *(_DWORD *)(v5 + 40) = *(_DWORD *)(a1 + 40);
  (**(void (***)(uint64_t))a1)(a1);
  return v6;
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Color>::disable_subpixel_quantization(uint64_t a1, float64x2_t *a2)
{
  float64x2_t v2 = (RB::Coverage::Glyphs *)(a1 + 56);
  v3.f64[0] = RB::operator*(*(float64x2_t **)(a1 + 48), a2);
  v6[0] = v3;
  v6[1] = v4;
  float32x2_t v6[2] = (float64x2_t)v5;
  RB::Coverage::Glyphs::disable_subpixel_quantization(v2, v6, v3.f64[0], v4.f64[0], v5);
}

double RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::min_scale()
{
  return 0.0;
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::prepare_mix(float64x2_t **a1, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Interpolator::Op *a3, float64x2_t **a4)
{
  double result = (unint64_t *)(*(uint64_t (**)(float64x2_t **))&(*a4)[1].f64[0])(a4);
  if (result == 4214785)
  {
    double result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      double result = (unint64_t *)RB::can_mix(a1[6], a4[6], v10);
      int v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        double result = (unint64_t *)RB::Coverage::Glyphs::can_mix((RB::Coverage::Glyphs *)(a1 + 7), a3, (const RB::Coverage::Glyphs *)(a4 + 7));
        if ((_BYTE)result)
        {
          unsigned __int8 v12 = result;
          can_mifloat64_t x = RB::Fill::Color::can_mix((RB::Fill::Color *)(a1 + 14), (const RB::Fill::Color *)(a4 + 14));
          return RB::DisplayList::Interpolator::Op::set_type((unint64_t *)a3, v11, v12, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8 = (*(uint64_t (**)(CGAffineTransform **, void, void, void, uint64_t))&(*a1)[1].a)(a1, *(void *)&a4->f64[0], *(unsigned int *)(*(void *)(a2 + 8) + 12), **(void **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v23[0] = v10;
  v23[1] = v11;
  int32x2_t v23[2] = v12;
  *(void *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v23);
  float32x2_t v13 = (RB::Heap *)(*(void *)(*(void *)&a4->f64[0] + 8) + 16);
  RB::Fill::Color::mix(v8 + 112, a3 + 112, 3, *(float *)(a2 + 16));
  v14.f64[0] = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  v22[0] = v14;
  v22[1] = v15;
  float64x2_t v22[2] = v16;
  v17.f64[0] = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  v21[0] = v17;
  v21[1] = v18;
  int32x2_t v21[2] = v19;
  RB::Coverage::Glyphs::mix((float32x2_t *)(v8 + 56), (const RB::DisplayList::Interpolator::State *)a2, (const RB::Coverage::Glyphs *)(a3 + 56), v22, v21, *(float64x2_t **)(v8 + 48), v13);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(unsigned char *)(*(void *)&a4->f64[0] + 272)) {
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

RB::DisplayList::Item *RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Color>::project(RB::DisplayList::Item *a1, RB::DisplayList::Builder *a2, const RB::Path::Projection *a3, float64x2_t *a4)
{
  if (*((_DWORD *)a3 + 12) & 0x1E) == 4 || (*((_DWORD *)a3 + 12) & 0x1E) == 6 && (*((unsigned char *)a1 + 109)) {
    return RB::Coverage::Glyphs::project_control_points((float32x2_t *)a1 + 7, a2, a3, a1, (RB::DisplayList::Item *)((char *)a1 + 112), *((float64x2_t **)a1 + 6), a4);
  }
  else {
    return RB::DisplayList::Item::project(a1, a2, a3, a4);
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::prepare_encode(uint64_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode(a1, a2);
  return RB::Coverage::Glyphs::prepare_encode((uint64_t)(a1 + 7), a2);
}

void *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::encode(uint64_t a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Glyphs>(this, 1, (CGFont **)(a1 + 56));
  RB::Encoder::typed_message_field<RB::Fill::Color>(this, 2, (RB::Fill::Color *)(a1 + 112));
  float64x2_t v4 = *(float64x2_t **)(a1 + 48);
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::print(const RB::AffineTransform **a1, std::string *this)
{
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::atom_position(uint64_t a1)
{
  double v1 = RB::Coverage::Glyphs::bounds((RB::Coverage::Glyphs *)(a1 + 56), *(float64x2_t **)(a1 + 48), 0);
  return vmla_f32(*(float32x2_t *)&v1, (float32x2_t)0x3F0000003F000000, v2);
}

__n128 _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill8GradientEEEJRS5_RKS7_RPKNS_15AffineTransformEDF16_RNS_9BlendModeEEEEPT_DpOT0_(RB::Heap *this, long long *a2, uint64_t a3, uint64_t *a4, __int16 *a5, _WORD *a6)
{
  unint64_t v12 = *((void *)this + 3);
  unint64_t v13 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v13 + 176 > v12) {
    unint64_t v13 = RB::Heap::alloc_slow((size_t *)this, 0xB0uLL, 7);
  }
  else {
    *((void *)this + 2) = v13 + 176;
  }
  uint64_t v14 = *a4;
  __int16 v15 = *a5;
  char v16 = *a6;
  *(void *)(v13 + 16) = 0;
  *(void *)(v13 + 24) = 0;
  *(_DWORD *)(v13 + 40) = 0;
  *(void *)(v13 + 32) = 0;
  *(_WORD *)(v13 + 44) = v15;
  *(_WORD *)(v13 + 46) = v16 & 0x3F;
  *(void *)unint64_t v13 = &unk_26C4EAE28;
  *(void *)(v13 + 48) = v14;
  long long v17 = *a2;
  long long v18 = a2[1];
  long long v19 = a2[2];
  *(void *)(v13 + 104) = *((void *)a2 + 6);
  *(_OWORD *)(v13 + 88) = v19;
  *(_OWORD *)(v13 + 72) = v18;
  *(_OWORD *)(v13 + 56) = v17;
  __n128 result = *(__n128 *)a3;
  long long v21 = *(_OWORD *)(a3 + 16);
  long long v22 = *(_OWORD *)(a3 + 48);
  *(_OWORD *)(v13 + 144) = *(_OWORD *)(a3 + 32);
  *(_OWORD *)(v13 + 160) = v22;
  *(__n128 *)(v13 + 112) = result;
  *(_OWORD *)(v13 + 128) = v21;
  *(void *)unint64_t v13 = &unk_26C4E9688;
  return result;
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Gradient>::~GenericItem()
{
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::type_id()
{
  return 8409089;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Gradient>::copy(__n128 *a1, uint64_t a2)
{
  float64x2_t v3 = (RB::Heap *)(*(void *)(a2 + 8) + 16);
  int v6 = a1[2].n128_u16[7] & 0x3F;
  float64x2_t v4 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill8GradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v3, v3, (RB::Coverage::Glyphs *)&a1[3].n128_i8[8], (uint64_t *)&a1[7], (uint64_t *)&a1[3], &a1[2].n128_i16[6], &v6);
  __n128 result = a1[1];
  v4[1] = result;
  v4[2].n128_u64[0] = a1[2].n128_u64[0];
  v4[2].n128_u32[2] = a1[2].n128_u32[2];
  v4[2].n128_u16[7] |= a1[2].n128_u16[7] & 0x5800;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  __n128 result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Gradient>::atom_count(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Gradient>::copy_atoms(uint64_t a1, uint64_t a2)
{
  MEMORY[0x270FA5388](a1, a2);
  unsigned int v5 = v4;
  unsigned int v7 = v6;
  uint64_t v8 = v3;
  int v9 = v2;
  uint64_t v16 = *MEMORY[0x263EF8340];
  if (v6 || v2[4].n128_u32[2] != v4)
  {
    RB::Heap::Heap((RB::Heap *)v14, v15, 4096, 0);
    RB::Coverage::Glyphs::Glyphs((RB::Coverage::Glyphs *)v13, (const RB::Coverage::Glyphs *)&v9[3].n128_i8[8], (RB::Heap *)v14, v7, v5);
    long long v10 = (RB::Heap *)(*(void *)(v8 + 8) + 16);
    int v12 = v9[2].n128_u16[7] & 0x3F;
    long long v11 = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill8GradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v10, v10, (RB::Coverage::Glyphs *)v13, (uint64_t *)&v9[7], (uint64_t *)&v9[3], &v9[2].n128_i16[6], &v12);
    *((__n128 *)v11 + 1) = v9[1];
    v11[4] = v9[2].n128_u64[0];
    if (!*(unsigned char *)(v8 + 272)) {
      RB::DisplayList::Contents::copy_atoms(*(RB::DisplayList::Contents **)(v8 + 8), (const RB::DisplayList::Metadata **)v11 + 4, v7, v5);
    }
    *((_DWORD *)v11 + 10) = v9[2].n128_u32[2];
    RB::Heap::~Heap((RB::Heap *)v14);
  }
  else
  {
    RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Gradient>::copy(v2, v3);
  }
}

void sub_21416FBDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  RB::Heap::~Heap((RB::Heap *)va);
  _Unwind_Resume(a1);
}

float32x2_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Gradient>::atom_position(uint64_t a1, unsigned int a2)
{
  float64x2_t v2 = vcvtq_f64_f32(*(float32x2_t *)(*(void *)(a1 + 64) + 8 * a2));
  return vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(*(void *)(a1 + 48) + 32), *(float64x2_t *)*(void *)(a1 + 48), v2.f64[0]), *(float64x2_t *)(*(void *)(a1 + 48) + 16), v2, 1));
}

float32x2_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Gradient>::atom_bounds(uint64_t a1, unsigned int a2, int a3)
{
  double v4 = RB::Coverage::Glyphs::glyph_bounds((RB::Coverage::Glyphs *)(a1 + 56), a2, a3);
  unsigned int v6 = *(float64x2_t **)(a1 + 48);
  return RB::operator*(v6, *(float32x2_t *)&v4, v5);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::make_clip(uint64_t a1, uint64_t a2, unsigned int a3, void *a4, float a5)
{
  float v24 = 0.0;
  unsigned int v25 = a3;
  if (RB::Fill::Gradient::get_alpha((RB::Fill::Gradient *)(a1 + 112), &v24))
  {
    long long v11 = (size_t *)(*(void *)(a2 + 8) + 16);
    _H0 = *(_WORD *)(a1 + 44);
    __asm { FCVT            S0, H0 }
    float v23 = _S0 * (float)(a5 * v24);
    uint64_t v18 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Glyphs>,RB::Heap&,RB::Coverage::Glyphs const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(v11, (RB::Heap *)v11, (RB::Coverage::Glyphs *)(a1 + 56), (int *)&v23, (int *)&v25, (uint64_t *)(a1 + 48));
    uint64_t v19 = a4[5];
    size_t v20 = v19 + 1;
    if (a4[6] < (unint64_t)(v19 + 1))
    {
      RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v20);
      uint64_t v19 = a4[5];
      size_t v20 = v19 + 1;
    }
    long long v21 = (void *)a4[4];
    if (!v21) {
      long long v21 = a4;
    }
    v21[v19] = v18;
    a4[5] = v20;
    return (**(uint64_t (***)(uint64_t))a1)(a1);
  }
  else
  {
    v10.n128_f32[0] = a5;
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, v10);
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::can_append_color_matrix()
{
  return 1;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::append_color_matrix(uint64_t a1, float16x4_t *a2, uint64_t a3, __int16 a4)
{
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::append_alpha_gradient()
{
  return 0;
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Gradient>::disable_subpixel_quantization(uint64_t a1, float64x2_t *a2)
{
  float64x2_t v2 = (RB::Coverage::Glyphs *)(a1 + 56);
  v3.f64[0] = RB::operator*(*(float64x2_t **)(a1 + 48), a2);
  v6[0] = v3;
  v6[1] = v4;
  float32x2_t v6[2] = (float64x2_t)v5;
  RB::Coverage::Glyphs::disable_subpixel_quantization(v2, v6, v3.f64[0], v4.f64[0], v5);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 168);
}

double RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::bounds(uint64_t a1, char a2)
{
  return RB::Coverage::Glyphs::bounds((RB::Coverage::Glyphs *)(a1 + 56), *(float64x2_t **)(a1 + 48), a2);
}

double RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::min_scale()
{
  return 0.0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::has_no_effect(uint64_t a1)
{
  __asm { FCMP            H0, #0 }
  if (_ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  else {
    return 0;
  }
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::render(float32x2_t *a1, int a2, uint64_t a3, double a4, char a5, int a6)
{
  unsigned int v6 = (float64x2_t *)a1[6];
  v7.i64[0] = SLODWORD(a4);
  v7.i64[1] = SHIDWORD(a4);
  float64x2_t v8 = v6[1];
  _Q0 = vaddq_f64(v6[2], vcvtq_f64_s64(v7));
  v14[0] = *v6;
  v14[1] = v8;
  float32x2_t v14[2] = _Q0;
  LOWORD(_Q0.f64[0]) = a1[5].i16[2];
  __asm { FCVT            S0, H0 }
  RB::render_glyphs(a3, v14, a1 + 7, a1 + 14, a5, a6, *(float *)_Q0.f64);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::render(uint64_t a1, uint64_t a2)
{
  float64x2_t v4 = *(float64x2_t **)(a1 + 48);
  int64x2_t v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  unsigned int v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&float32x2_t v12 = (*(double (**)(uint64_t, void))(*(void *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v23, v12, v13);
  int v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5) {
    goto LABEL_10;
  }
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v23[0].f64[0], *(int32x2_t *)&v23[0].f64[1]))
  {
    int v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v23, v14, _S8);
    goto LABEL_11;
  }
  int v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4) {
    goto LABEL_10;
  }
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11) {
    goto LABEL_10;
  }
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::Glyphs::clip((float32x2_t **)(a1 + 56), (RB::CGContext *)a2);
  v23[0] = (float64x2_t)xmmword_2142181C0;
  v23[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  double v16 = RB::Coverage::Glyphs::bounds((RB::Coverage::Glyphs *)(a1 + 56), v23, 0);
  RB::Bounds::Bounds(v26, *(float32x2_t *)&v16, v17);
  RB::Fill::Gradient::fill(a1 + 112, (RB::CGContext *)a2, *(double *)v26, *(double *)&v26[1], v18, v19, v20, v21, v22);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 112), a2);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::apply_transform(uint64_t a1, const RB::DisplayList::Transform *a2, uint64_t a3)
{
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Interpolator::Op *a3, float64x2_t **a4)
{
  __n128 result = (unint64_t *)(*(uint64_t (**)(float64x2_t **))&(*a4)[1].f64[0])(a4);
  if (result == 8409089)
  {
    __n128 result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      __n128 result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), a4[6], v10);
      int v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        __n128 result = (unint64_t *)RB::Coverage::Glyphs::can_mix((RB::Coverage::Glyphs *)(a1 + 56), a3, (const RB::Coverage::Glyphs *)(a4 + 7));
        if ((_BYTE)result)
        {
          unsigned __int8 v13 = result;
          can_mifloat64_t x = RB::Fill::Gradient::can_mix((uint64_t *)(a1 + 112), (uint64_t)(a4 + 14), v12);
          return RB::DisplayList::Interpolator::Op::set_type((unint64_t *)a3, v11, v13, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::mix(CGAffineTransform **a1, uint64_t a2, float64x2_t **a3, float64x2_t *a4)
{
  uint64_t v8 = (*(uint64_t (**)(CGAffineTransform **, void, void, void, uint64_t))&(*a1)[1].a)(a1, *(void *)&a4->f64[0], *(unsigned int *)(*(void *)(a2 + 8) + 12), **(void **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], a3[6], v9, *(float *)(a2 + 16));
  v24[0] = v10;
  v24[1] = v11;
  float32x2_t v24[2] = v12;
  *(void *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v24);
  unsigned __int8 v13 = (RB::Heap *)(*(void *)(*(void *)&a4->f64[0] + 8) + 16);
  LODWORD(v14) = *(_DWORD *)(a2 + 16);
  RB::Fill::Gradient::mix((RB::Fill::Gradient *)(v8 + 112), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::Gradient *)(a3 + 14), v14, v13);
  v15.f64[0] = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  v23[0] = v15;
  v23[1] = v16;
  float64x2_t v23[2] = v17;
  v18.f64[0] = RB::operator*(a3[6], a4 + 68);
  v22[0] = v18;
  v22[1] = v19;
  float64x2_t v22[2] = v20;
  RB::Coverage::Glyphs::mix((float32x2_t *)(v8 + 56), (const RB::DisplayList::Interpolator::State *)a2, (const RB::Coverage::Glyphs *)(a3 + 7), v23, v22, *(float64x2_t **)(v8 + 48), v13);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(unsigned char *)(*(void *)&a4->f64[0] + 272)) {
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::prepare_encode(uint64_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode(a1, a2);
  return RB::Coverage::Glyphs::prepare_encode((uint64_t)(a1 + 7), a2);
}

void *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::encode(uint64_t a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Glyphs>(this, 1, (CGFont **)(a1 + 56));
  RB::Encoder::typed_message_field<RB::Fill::Gradient>(this, 2, (RB::Fill::Gradient *)(a1 + 112));
  float64x2_t v4 = *(float64x2_t **)(a1 + 48);
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::print(const RB::AffineTransform **a1, std::string *this)
{
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::atom_position(uint64_t a1)
{
  double v1 = RB::Coverage::Glyphs::bounds((RB::Coverage::Glyphs *)(a1 + 56), *(float64x2_t **)(a1 + 48), 0);
  return vmla_f32(*(float32x2_t *)&v1, (float32x2_t)0x3F0000003F000000, v2);
}

void *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill8GradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, RB::Heap *a2, RB::Coverage::Glyphs *a3, uint64_t *a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14 = *((void *)this + 3);
  uint64_t v15 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 176 > v14) {
    uint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0xB0uLL, 7);
  }
  else {
    *((void *)this + 2) = v15 + 176;
  }
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  __n128 result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  *__n128 result = &unk_26C4E9688;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::GenericItem1(uint64_t a1, RB::Heap *a2, RB::Coverage::Glyphs *a3, uint64_t *a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  __asm { FCVT            H0, S0 }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F;
  *(void *)a1 = &unk_26C4EAE28;
  *(void *)(a1 + 48) = a5;
  RB::Coverage::Glyphs::Glyphs((RB::Coverage::Glyphs *)(a1 + 56), a3, a2);
  RB::Fill::Gradient::Gradient((uint64_t *)(a1 + 112), a4, a7, a2);
  return a1;
}

void *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Glyphs const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, RB::Heap *a2, RB::Coverage::Glyphs *a3, uint64_t *a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16 = *((void *)this + 3);
  uint64_t v17 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 176 > v16) {
    uint64_t v17 = RB::Heap::alloc_slow((size_t *)this, 0xB0uLL, 7);
  }
  else {
    *((void *)this + 2) = v17 + 176;
  }
  __n128 result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  *__n128 result = &unk_26C4E9688;
  return result;
}

void *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Glyphs const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, RB::Heap *a2, RB::Coverage::Glyphs *a3, uint64_t a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16 = *((void *)this + 3);
  uint64_t v17 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 160 > v16) {
    uint64_t v17 = RB::Heap::alloc_slow((size_t *)this, 0xA0uLL, 7);
  }
  else {
    *((void *)this + 2) = v17 + 160;
  }
  __n128 result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  *__n128 result = &unk_26C4E7508;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::GenericItem1(uint64_t a1, RB::Heap *a2, RB::Coverage::Glyphs *a3, uint64_t a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  __asm { FCVT            H0, S0 }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F | 0x4000;
  *(void *)a1 = &unk_26C4E7AC0;
  *(void *)(a1 + 48) = a5;
  RB::Coverage::Glyphs::Glyphs((RB::Coverage::Glyphs *)(a1 + 56), a3, a2);
  RB::Fill::MeshGradient::MeshGradient(a1 + 112, a4, a7, a2);
  return a1;
}

void *RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4E7AC0;
  float32x2_t v2 = (atomic_uint *)a1[15];
  if (v2 && atomic_fetch_add_explicit(v2 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4E7AC0;
  double v1 = (atomic_uint *)a1[15];
  if (v1 && atomic_fetch_add_explicit(v1 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::type_id()
{
  return 20992001;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::copy(__n128 *a1, uint64_t a2)
{
  float64x2_t v3 = (RB::Heap *)(*(void *)(a2 + 8) + 16);
  int v6 = a1[2].n128_u16[7] & 0x3F;
  float64x2_t v4 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill12MeshGradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v3, v3, (RB::Coverage::Glyphs *)&a1[3].n128_i8[8], (uint64_t)&a1[7], (uint64_t *)&a1[3], &a1[2].n128_i16[6], &v6);
  __n128 result = a1[1];
  v4[1] = result;
  v4[2].n128_u64[0] = a1[2].n128_u64[0];
  v4[2].n128_u32[2] = a1[2].n128_u32[2];
  v4[2].n128_u16[7] |= a1[2].n128_u16[7] & 0x5800;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  __n128 result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::atom_count(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::copy_atoms(uint64_t a1, uint64_t a2)
{
  MEMORY[0x270FA5388](a1, a2);
  unsigned int v5 = v4;
  unsigned int v7 = v6;
  uint64_t v8 = v3;
  int v9 = v2;
  uint64_t v16 = *MEMORY[0x263EF8340];
  if (v6 || v2[4].n128_u32[2] != v4)
  {
    RB::Heap::Heap((RB::Heap *)v14, v15, 4096, 0);
    RB::Coverage::Glyphs::Glyphs((RB::Coverage::Glyphs *)v13, (const RB::Coverage::Glyphs *)&v9[3].n128_i8[8], (RB::Heap *)v14, v7, v5);
    long long v10 = (RB::Heap *)(*(void *)(v8 + 8) + 16);
    int v12 = v9[2].n128_u16[7] & 0x3F;
    long long v11 = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill12MeshGradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v10, v10, (RB::Coverage::Glyphs *)v13, (uint64_t)&v9[7], (uint64_t *)&v9[3], &v9[2].n128_i16[6], &v12);
    *((__n128 *)v11 + 1) = v9[1];
    v11[4] = v9[2].n128_u64[0];
    if (!*(unsigned char *)(v8 + 272)) {
      RB::DisplayList::Contents::copy_atoms(*(RB::DisplayList::Contents **)(v8 + 8), (const RB::DisplayList::Metadata **)v11 + 4, v7, v5);
    }
    *((_DWORD *)v11 + 10) = v9[2].n128_u32[2];
    RB::Heap::~Heap((RB::Heap *)v14);
  }
  else
  {
    RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::copy(v2, v3);
  }
}

void sub_214170B58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  RB::Heap::~Heap((RB::Heap *)va);
  _Unwind_Resume(a1);
}

float32x2_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::atom_position(uint64_t a1, unsigned int a2)
{
  float64x2_t v2 = vcvtq_f64_f32(*(float32x2_t *)(*(void *)(a1 + 64) + 8 * a2));
  return vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(*(void *)(a1 + 48) + 32), *(float64x2_t *)*(void *)(a1 + 48), v2.f64[0]), *(float64x2_t *)(*(void *)(a1 + 48) + 16), v2, 1));
}

float32x2_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::atom_bounds(uint64_t a1, unsigned int a2, int a3)
{
  double v4 = RB::Coverage::Glyphs::glyph_bounds((RB::Coverage::Glyphs *)(a1 + 56), a2, a3);
  unsigned int v6 = *(float64x2_t **)(a1 + 48);
  return RB::operator*(v6, *(float32x2_t *)&v4, v5);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::can_make_clip()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::make_clip(uint64_t a1, uint64_t a2, unsigned int a3, void *a4, float a5)
{
  float v24 = 0.0;
  unsigned int v25 = a3;
  if (RB::Fill::MeshGradient::get_alpha((RB::Fill::MeshGradient *)(a1 + 112), &v24))
  {
    long long v11 = (size_t *)(*(void *)(a2 + 8) + 16);
    _H0 = *(_WORD *)(a1 + 44);
    __asm { FCVT            S0, H0 }
    float v23 = _S0 * (float)(a5 * v24);
    uint64_t v18 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Glyphs>,RB::Heap&,RB::Coverage::Glyphs const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(v11, (RB::Heap *)v11, (RB::Coverage::Glyphs *)(a1 + 56), (int *)&v23, (int *)&v25, (uint64_t *)(a1 + 48));
    uint64_t v19 = a4[5];
    size_t v20 = v19 + 1;
    if (a4[6] < (unint64_t)(v19 + 1))
    {
      RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v20);
      uint64_t v19 = a4[5];
      size_t v20 = v19 + 1;
    }
    int8x16_t v21 = (void *)a4[4];
    if (!v21) {
      int8x16_t v21 = a4;
    }
    v21[v19] = v18;
    a4[5] = v20;
    return (**(uint64_t (***)(uint64_t))a1)(a1);
  }
  else
  {
    v10.n128_f32[0] = a5;
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, v10);
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::can_append_color_matrix()
{
  return 1;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::append_color_matrix(uint64_t a1, float16x4_t *a2, uint64_t a3, __int16 a4)
{
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::append_alpha_gradient()
{
  return 0;
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::disable_subpixel_quantization(uint64_t a1, float64x2_t *a2)
{
  float64x2_t v2 = (RB::Coverage::Glyphs *)(a1 + 56);
  v3.f64[0] = RB::operator*(*(float64x2_t **)(a1 + 48), a2);
  v6[0] = v3;
  v6[1] = v4;
  float32x2_t v6[2] = (float64x2_t)v5;
  RB::Coverage::Glyphs::disable_subpixel_quantization(v2, v6, v3.f64[0], v4.f64[0], v5);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 152);
}

double RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::bounds(uint64_t a1, char a2)
{
  return RB::Coverage::Glyphs::bounds((RB::Coverage::Glyphs *)(a1 + 56), *(float64x2_t **)(a1 + 48), a2);
}

double RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::min_scale()
{
  return 0.0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::has_no_effect(uint64_t a1)
{
  __asm { FCMP            H0, #0 }
  if (_ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  else {
    return 0;
  }
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::render(float32x2_t *a1, int a2, uint64_t a3, double a4, char a5, int a6)
{
  unsigned int v6 = (float64x2_t *)a1[6];
  v7.i64[0] = SLODWORD(a4);
  v7.i64[1] = SHIDWORD(a4);
  float64x2_t v8 = v6[1];
  _Q0 = vaddq_f64(v6[2], vcvtq_f64_s64(v7));
  v14[0] = *v6;
  v14[1] = v8;
  float32x2_t v14[2] = _Q0;
  LOWORD(_Q0.f64[0]) = a1[5].i16[2];
  __asm { FCVT            S0, H0 }
  RB::render_glyphs(a3, v14, a1 + 7, (uint64_t)&a1[14], a5, a6, *(float *)_Q0.f64);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::render(uint64_t a1, uint64_t a2)
{
  float64x2_t v4 = *(float64x2_t **)(a1 + 48);
  int64x2_t v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  unsigned int v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&float32x2_t v12 = (*(double (**)(uint64_t, void))(*(void *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v18, v12, v13);
  int v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5) {
    goto LABEL_10;
  }
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v18[0].f64[0], *(int32x2_t *)&v18[0].f64[1]))
  {
    int v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v18, v14, _S8);
    goto LABEL_11;
  }
  int v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4) {
    goto LABEL_10;
  }
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11) {
    goto LABEL_10;
  }
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::Glyphs::clip((float32x2_t **)(a1 + 56), (RB::CGContext *)a2);
  v18[0] = (float64x2_t)xmmword_2142181C0;
  v18[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  double v16 = RB::Coverage::Glyphs::bounds((RB::Coverage::Glyphs *)(a1 + 56), v18, 0);
  RB::Bounds::Bounds(v21, *(float32x2_t *)&v16, v17);
  RB::Fill::MeshGradient::fill((int32x2_t *)(a1 + 112), (int8x8_t *)a2, v21[0], v21[1]);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 112), a2);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::apply_transform(uint64_t a1, const RB::DisplayList::Transform *a2, uint64_t a3)
{
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::prepare_mix(float64x2_t **a1, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Interpolator::Op *a3, float64x2_t **a4)
{
  __n128 result = (unint64_t *)(*(uint64_t (**)(float64x2_t **))&(*a4)[1].f64[0])(a4);
  if (result == 20992001)
  {
    __n128 result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      __n128 result = (unint64_t *)RB::can_mix(a1[6], a4[6], v10);
      int v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        __n128 result = (unint64_t *)RB::Coverage::Glyphs::can_mix((RB::Coverage::Glyphs *)(a1 + 7), a3, (const RB::Coverage::Glyphs *)(a4 + 7));
        if ((_BYTE)result)
        {
          unsigned __int8 v13 = result;
          can_mifloat64_t x = RB::Fill::MeshGradient::can_mix((RB::Fill::MeshGradient *)(a1 + 14), (const RB::Fill::MeshGradient *)(a4 + 14), v12);
          return RB::DisplayList::Interpolator::Op::set_type((unint64_t *)a3, v11, v13, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::mix(CGAffineTransform **a1, uint64_t a2, float64x2_t **a3, float64x2_t *a4)
{
  uint64_t v8 = (*(uint64_t (**)(CGAffineTransform **, void, void, void, uint64_t))&(*a1)[1].a)(a1, *(void *)&a4->f64[0], *(unsigned int *)(*(void *)(a2 + 8) + 12), **(void **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], a3[6], v9, *(float *)(a2 + 16));
  v24[0] = v10;
  v24[1] = v11;
  float32x2_t v24[2] = v12;
  *(void *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v24);
  unsigned __int8 v13 = (RB::Heap *)(*(void *)(*(void *)&a4->f64[0] + 8) + 16);
  LODWORD(v14) = *(_DWORD *)(a2 + 16);
  RB::Fill::MeshGradient::mix((RB::Fill::MeshGradient *)(v8 + 112), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::MeshGradient *)(a3 + 14), v14, v13);
  v15.f64[0] = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  v23[0] = v15;
  v23[1] = v16;
  float64x2_t v23[2] = v17;
  v18.f64[0] = RB::operator*(a3[6], a4 + 68);
  v22[0] = v18;
  v22[1] = v19;
  float64x2_t v22[2] = v20;
  RB::Coverage::Glyphs::mix((float32x2_t *)(v8 + 56), (const RB::DisplayList::Interpolator::State *)a2, (const RB::Coverage::Glyphs *)(a3 + 7), v23, v22, *(float64x2_t **)(v8 + 48), v13);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(unsigned char *)(*(void *)&a4->f64[0] + 272)) {
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::prepare_encode(uint64_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode(a1, a2);
  return RB::Coverage::Glyphs::prepare_encode((uint64_t)(a1 + 7), a2);
}

void *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::encode(uint64_t a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Glyphs>(this, 1, (CGFont **)(a1 + 56));
  RB::Encoder::typed_message_field<RB::Fill::MeshGradient>(this, 2, (RB::Fill::MeshGradient *)(a1 + 112));
  float64x2_t v4 = *(float64x2_t **)(a1 + 48);
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::print(const RB::AffineTransform **a1, std::string *this)
{
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::atom_position(uint64_t a1)
{
  double v1 = RB::Coverage::Glyphs::bounds((RB::Coverage::Glyphs *)(a1 + 56), *(float64x2_t **)(a1 + 48), 0);
  return vmla_f32(*(float32x2_t *)&v1, (float32x2_t)0x3F0000003F000000, v2);
}

void *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill12MeshGradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, RB::Heap *a2, RB::Coverage::Glyphs *a3, uint64_t a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14 = *((void *)this + 3);
  uint64_t v15 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 160 > v14) {
    uint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0xA0uLL, 7);
  }
  else {
    *((void *)this + 2) = v15 + 160;
  }
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  __n128 result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  *__n128 result = &unk_26C4E7508;
  return result;
}

void *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Glyphs const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, RB::Heap *a2, RB::Coverage::Glyphs *a3, const RB::ImageTexture *a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16 = *((void *)this + 3);
  uint64_t v17 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 208 > v16) {
    uint64_t v17 = RB::Heap::alloc_slow((size_t *)this, 0xD0uLL, 7);
  }
  else {
    *((void *)this + 2) = v17 + 208;
  }
  __n128 result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  *__n128 result = &unk_26C4E9458;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::GenericItem1(uint64_t a1, RB::Heap *a2, RB::Coverage::Glyphs *a3, const RB::ImageTexture *a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  __asm { FCVT            H0, S0 }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F;
  *(void *)a1 = &unk_26C4EABF8;
  *(void *)(a1 + 48) = a5;
  RB::Coverage::Glyphs::Glyphs((RB::Coverage::Glyphs *)(a1 + 56), a3, a2);
  RB::ImageTexture::ImageTexture((RB::ImageTexture *)(a1 + 112), a4, a2);
  long long v17 = *((_OWORD *)a4 + 2);
  long long v18 = *((_OWORD *)a4 + 3);
  long long v19 = *((_OWORD *)a4 + 4);
  *(_OWORD *)(a1 + 192) = *((_OWORD *)a4 + 5);
  long long v20 = *((_OWORD *)a4 + 1);
  *(_OWORD *)(a1 + 160) = v18;
  *(_OWORD *)(a1 + 176) = v19;
  *(_OWORD *)(a1 + 128) = v20;
  *(_OWORD *)(a1 + 144) = v17;
  if (!*(unsigned char *)(a1 + 205)) {
    *(_WORD *)(a1 + 204) = a7;
  }
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::~GenericItem()
{
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::type_id()
{
  return 12603393;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::copy(__n128 *a1, uint64_t a2)
{
  float64x2_t v3 = (RB::Heap *)(*(void *)(a2 + 8) + 16);
  int v6 = a1[2].n128_u16[7] & 0x3F;
  float64x2_t v4 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill5ImageINS_12ImageTextureEEEEEJRS0_RKS5_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v3, v3, (RB::Coverage::Glyphs *)&a1[3].n128_i8[8], (const RB::ImageTexture *)&a1[7], (uint64_t *)&a1[3], &a1[2].n128_i16[6], &v6);
  __n128 result = a1[1];
  v4[1] = result;
  v4[2].n128_u64[0] = a1[2].n128_u64[0];
  v4[2].n128_u32[2] = a1[2].n128_u32[2];
  v4[2].n128_u16[7] |= a1[2].n128_u16[7] & 0x5800;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  __n128 result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::atom_count(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::copy_atoms(uint64_t a1, uint64_t a2)
{
  MEMORY[0x270FA5388](a1, a2);
  unsigned int v5 = v4;
  unsigned int v7 = v6;
  uint64_t v8 = v3;
  int v9 = v2;
  uint64_t v16 = *MEMORY[0x263EF8340];
  if (v6 || v2[4].n128_u32[2] != v4)
  {
    RB::Heap::Heap((RB::Heap *)v14, v15, 4096, 0);
    RB::Coverage::Glyphs::Glyphs((RB::Coverage::Glyphs *)v13, (const RB::Coverage::Glyphs *)&v9[3].n128_i8[8], (RB::Heap *)v14, v7, v5);
    long long v10 = (RB::Heap *)(*(void *)(v8 + 8) + 16);
    int v12 = v9[2].n128_u16[7] & 0x3F;
    long long v11 = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill5ImageINS_12ImageTextureEEEEEJRS0_RKS5_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v10, v10, (RB::Coverage::Glyphs *)v13, (const RB::ImageTexture *)&v9[7], (uint64_t *)&v9[3], &v9[2].n128_i16[6], &v12);
    *((__n128 *)v11 + 1) = v9[1];
    v11[4] = v9[2].n128_u64[0];
    if (!*(unsigned char *)(v8 + 272)) {
      RB::DisplayList::Contents::copy_atoms(*(RB::DisplayList::Contents **)(v8 + 8), (const RB::DisplayList::Metadata **)v11 + 4, v7, v5);
    }
    *((_DWORD *)v11 + 10) = v9[2].n128_u32[2];
    RB::Heap::~Heap((RB::Heap *)v14);
  }
  else
  {
    RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::copy(v2, v3);
  }
}

void sub_214171884(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  RB::Heap::~Heap((RB::Heap *)va);
  _Unwind_Resume(a1);
}

float32x2_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::atom_position(uint64_t a1, unsigned int a2)
{
  float64x2_t v2 = vcvtq_f64_f32(*(float32x2_t *)(*(void *)(a1 + 64) + 8 * a2));
  return vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(*(void *)(a1 + 48) + 32), *(float64x2_t *)*(void *)(a1 + 48), v2.f64[0]), *(float64x2_t *)(*(void *)(a1 + 48) + 16), v2, 1));
}

float32x2_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::atom_bounds(uint64_t a1, unsigned int a2, int a3)
{
  double v4 = RB::Coverage::Glyphs::glyph_bounds((RB::Coverage::Glyphs *)(a1 + 56), a2, a3);
  unsigned int v6 = *(float64x2_t **)(a1 + 48);
  return RB::operator*(v6, *(float32x2_t *)&v4, v5);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::make_clip(uint64_t a1, uint64_t a2, unsigned int a3, void *a4, __n128 a5)
{
  unsigned int v20 = a3;
  if (*(unsigned char *)(a1 + 124))
  {
    unsigned int v7 = (size_t *)(*(void *)(a2 + 8) + 16);
    _H1 = *(_WORD *)(a1 + 44);
    __asm { FCVT            S1, H1 }
    float v19 = _S1 * a5.n128_f32[0];
    uint64_t v14 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Glyphs>,RB::Heap&,RB::Coverage::Glyphs const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(v7, (RB::Heap *)v7, (RB::Coverage::Glyphs *)(a1 + 56), (int *)&v19, (int *)&v20, (uint64_t *)(a1 + 48));
    uint64_t v15 = a4[5];
    size_t v16 = v15 + 1;
    if (a4[6] < (unint64_t)(v15 + 1))
    {
      RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v16);
      uint64_t v15 = a4[5];
      size_t v16 = v15 + 1;
    }
    long long v17 = (void *)a4[4];
    if (!v17) {
      long long v17 = a4;
    }
    v17[v15] = v14;
    a4[5] = v16;
    return (**(uint64_t (***)(uint64_t))a1)(a1);
  }
  else
  {
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, a5);
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::can_append_color_matrix(int a1, float16x4_t *a2, char a3, __int16 a4)
{
  return RB::Fill::ImageData::can_append_color_matrix(a1 + 128, a2, a3, a4);
}

float16x4_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::append_color_matrix(uint64_t a1, RB::ColorMatrix *a2, int a3)
{
  return RB::Fill::ImageData::append_color_matrix(a1 + 128, a2, a3);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::append_alpha_gradient()
{
  return 0;
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::disable_subpixel_quantization(uint64_t a1, float64x2_t *a2)
{
  float64x2_t v2 = (RB::Coverage::Glyphs *)(a1 + 56);
  v3.f64[0] = RB::operator*(*(float64x2_t **)(a1 + 48), a2);
  v6[0] = v3;
  v6[1] = v4;
  float32x2_t v6[2] = (float64x2_t)v5;
  RB::Coverage::Glyphs::disable_subpixel_quantization(v2, v6, v3.f64[0], v4.f64[0], v5);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 125);
}

double RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::bounds(uint64_t a1, char a2)
{
  return RB::Coverage::Glyphs::bounds((RB::Coverage::Glyphs *)(a1 + 56), *(float64x2_t **)(a1 + 48), a2);
}

float RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::min_scale(uint64_t a1)
{
  return fmaxf(RB::Fill::ImageData::min_scale((RB::Fill::ImageData *)(a1 + 128), *(const RB::AffineTransform **)(a1 + 48)), 0.0);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::has_no_effect(uint64_t a1)
{
  __asm { FCMP            H0, #0 }
  if (_ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  else {
    return 0;
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::prepare(uint64_t a1, uint64_t **a2)
{
  return RB::ImageTexture::prepare(a1 + 112, a2, (const RB::Fill::ImageData *)(a1 + 128), *(float64x2_t **)(a1 + 48), 0);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::render(float32x2_t *a1, double a2, uint64_t a3, uint64_t a4, char a5, int a6)
{
  long long v10 = (float64x2_t *)a1[6];
  v11.i64[0] = SLODWORD(a2);
  v11.i64[1] = SHIDWORD(a2);
  float64x2_t v12 = v10[1];
  _Q0 = vaddq_f64(v10[2], vcvtq_f64_s64(v11));
  v19[0] = *v10;
  v19[1] = v12;
  v19[2] = _Q0;
  uint64_t v14 = a1 + 7;
  LOWORD(_Q0.f64[0]) = a1[5].i16[2];
  __asm { FCVT            S0, H0 }
  RB::Fill::Image<RB::ImageTexture>::set_image((uint64_t)&a1[14], (uint64_t)v20, (uint64_t ***)a4, v19, *(float *)_Q0.f64);
  RB::render_glyphs(a4, v19, v14, (uint64_t)v20, (uint64_t)&a1[16], a5, a6);
  *(_DWORD *)(a4 + 232) = 0;
  *(unsigned char *)(a4 + 236) = 0;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::render(uint64_t a1, uint64_t a2)
{
  float64x2_t v4 = *(float64x2_t **)(a1 + 48);
  int64x2_t v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  unsigned int v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&float32x2_t v12 = (*(double (**)(uint64_t, void))(*(void *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v20, v12, v13);
  int v14 = 0;
  if (*(float32x2_t **)(a2 + 88) == v5)
  {
    if (RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v20[0].f64[0], *(int32x2_t *)&v20[0].f64[1]))
    {
      int v14 = 1;
      if (*(float64x2_t **)(a2 + 80) == v4 && *(float *)(a2 + 132) == _S8 && *(_DWORD *)(a2 + 136) == v11) {
        goto LABEL_11;
      }
    }
    else
    {
      int v14 = 0;
    }
  }
  RB::CGContext::update_state_slow(a2, v4, v5, v11, v20, v14, _S8);
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::Glyphs::clip((float32x2_t **)(a1 + 56), (RB::CGContext *)a2);
  v20[0] = (float64x2_t)xmmword_2142181C0;
  v20[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  double v16 = RB::Coverage::Glyphs::bounds((RB::Coverage::Glyphs *)(a1 + 56), v20, 0);
  RB::Bounds::Bounds((int32x2_t *)&v23, *(float32x2_t *)&v16, v17);
  uint16x4_t v18 = v23;
  float v19 = (RB *)RB::ImageTexture::cg_image((RB::ImageTexture *)(a1 + 112));
  if (v19) {
    RB::Fill::ImageData::fill((void *)(a1 + 128), a2, v19, v18);
  }
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::Fill::ImageData::matches((RB::Fill::ImageData *)(a1 + 128), a2, a3);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::apply_transform(uint64_t a1, const RB::DisplayList::Transform *a2, uint64_t a3)
{
  int64x2_t v5 = (RB::Heap *)(a3 + 16);
  RB::Coverage::Glyphs::apply_transform((RB::Coverage::Glyphs *)(a1 + 56), a2, (RB::Heap *)(a3 + 16));
  RB::Fill::ImageData::apply_transform((RB::Fill::ImageData *)(a1 + 128), a2, v5, v6);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Interpolator::Op *a3, uint64_t a4)
{
  __n128 result = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)a4 + 16))(a4);
  if (result == 12603393)
  {
    __n128 result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      __n128 result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a4 + 48), v10);
      int v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        __n128 result = (unint64_t *)RB::Coverage::Glyphs::can_mix((RB::Coverage::Glyphs *)(a1 + 56), a3, (const RB::Coverage::Glyphs *)(a4 + 56));
        if ((_BYTE)result)
        {
          unsigned __int8 v12 = result;
          can_mifloat64_t x = RB::ImageTexture::can_mix((RB::ImageTexture *)(a1 + 112), (const RB::ImageTexture *)(a4 + 112));
          if (can_mix)
          {
            unsigned __int8 v14 = can_mix;
            unsigned int v15 = RB::Fill::ImageData::can_mix((float32x2_t *)(a1 + 128), (float32x2_t *)(a4 + 128));
            if (v15 >= v14) {
              unsigned __int8 v16 = v14;
            }
            else {
              unsigned __int8 v16 = v15;
            }
          }
          else
          {
            unsigned __int8 v16 = 0;
          }
          return RB::DisplayList::Interpolator::Op::set_type((unint64_t *)a3, v11, v12, v16);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8 = (*(uint64_t (**)(CGAffineTransform **, void, void, void, uint64_t))&(*a1)[1].a)(a1, *(void *)&a4->f64[0], *(unsigned int *)(*(void *)(a2 + 8) + 12), **(void **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v23[0] = v10;
  v23[1] = v11;
  float64x2_t v23[2] = v12;
  *(void *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v23);
  float32x2_t v13 = (RB::Heap *)(*(void *)(*(void *)&a4->f64[0] + 8) + 16);
  RB::Fill::ImageData::mix((float32x4_t *)(v8 + 128), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (float32x4_t *)(a3 + 128), *(float *)(a2 + 16));
  v14.f64[0] = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  v22[0] = v14;
  v22[1] = v15;
  float64x2_t v22[2] = v16;
  v17.f64[0] = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  v21[0] = v17;
  v21[1] = v18;
  int32x2_t v21[2] = v19;
  RB::Coverage::Glyphs::mix((float32x2_t *)(v8 + 56), (const RB::DisplayList::Interpolator::State *)a2, (const RB::Coverage::Glyphs *)(a3 + 56), v22, v21, *(float64x2_t **)(v8 + 48), v13);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(unsigned char *)(*(void *)&a4->f64[0] + 272)) {
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

uint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::prepare_encode(uint64_t a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode((uint64_t *)a1, a2);
  RB::Coverage::Glyphs::prepare_encode(a1 + 56, a2);
  return RB::ImageTexture::prepare_encode((uint64_t **)(a1 + 112), a2);
}

void *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::encode(uint64_t a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Glyphs>(this, 1, (CGFont **)(a1 + 56));
  RB::Encoder::typed_message_field<RB::Fill::Image<RB::ImageTexture>>(this, 2, a1 + 112);
  float64x2_t v4 = *(float64x2_t **)(a1 + 48);
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::print(const RB::AffineTransform **a1, std::string *this)
{
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::atom_position(uint64_t a1)
{
  double v1 = RB::Coverage::Glyphs::bounds((RB::Coverage::Glyphs *)(a1 + 56), *(float64x2_t **)(a1 + 48), 0);
  return vmla_f32(*(float32x2_t *)&v1, (float32x2_t)0x3F0000003F000000, v2);
}

void *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill5ImageINS_12ImageTextureEEEEEJRS0_RKS5_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, RB::Heap *a2, RB::Coverage::Glyphs *a3, const RB::ImageTexture *a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14 = *((void *)this + 3);
  uint64_t v15 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 208 > v14) {
    uint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0xD0uLL, 7);
  }
  else {
    *((void *)this + 2) = v15 + 208;
  }
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  __n128 result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  *__n128 result = &unk_26C4E9458;
  return result;
}

void *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Glyphs const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, RB::Heap *a2, RB::Coverage::Glyphs *a3, uint64_t a4, uint64_t *a5, float *a6, _DWORD *a7)
{
  unint64_t v14 = *((void *)this + 3);
  uint64_t v15 = (*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v15 + 320 > v14) {
    uint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0x140uLL, 15);
  }
  else {
    *((void *)this + 2) = v15 + 320;
  }
  __n128 result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::GenericItem1(v15, a2, a3, a4, *a5, *a7, *a6);
  *__n128 result = &unk_26C4E9570;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::GenericItem1(uint64_t a1, RB::Heap *a2, RB::Coverage::Glyphs *a3, uint64_t a4, uint64_t a5, char a6, float _S0)
{
  __asm { FCVT            H0, S0 }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F;
  *(void *)a1 = &unk_26C4EAD10;
  *(void *)(a1 + 48) = a5;
  RB::Coverage::Glyphs::Glyphs((RB::Coverage::Glyphs *)(a1 + 56), a3, a2);
  RB::Fill::Custom::Custom((RB::CustomShader::Closure *)(a1 + 112), a4);
  return a1;
}

void *RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Custom>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4EAD10;
  float32x2_t v2 = (const void **)(a1 + 15);
  float64x2_t v3 = (const void **)a1[27];
  if (v3) {
    float64x2_t v4 = v3;
  }
  else {
    float64x2_t v4 = v2;
  }
  if (a1[28])
  {
    unint64_t v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[28]);
    float64x2_t v3 = (const void **)a1[27];
  }
  if (v3) {
    free(v3);
  }
  uint32x4_t v6 = (atomic_uint *)a1[14];
  if (v6 && atomic_fetch_add_explicit(v6 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v6 + 8))(v6);
  }
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Custom>::~GenericItem(void *a1)
{
  *a1 = &unk_26C4EAD10;
  float32x2_t v2 = (const void **)(a1 + 15);
  float64x2_t v3 = (const void **)a1[27];
  if (v3) {
    float64x2_t v4 = v3;
  }
  else {
    float64x2_t v4 = v2;
  }
  if (a1[28])
  {
    unint64_t v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[28]);
    float64x2_t v3 = (const void **)a1[27];
  }
  if (v3) {
    free(v3);
  }
  uint32x4_t v6 = (atomic_uint *)a1[14];
  if (v6 && atomic_fetch_add_explicit(v6 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v6 + 8))(v6);
  }
  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::type_id()
{
  return 16797697;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Custom>::copy(__n128 *a1, uint64_t a2)
{
  float64x2_t v3 = (RB::Heap *)(*(void *)(a2 + 8) + 16);
  int v6 = a1[2].n128_u16[7] & 0x3F;
  float64x2_t v4 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill6CustomEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v3, v3, (RB::Coverage::Glyphs *)&a1[3].n128_i8[8], (uint64_t)&a1[7], (uint64_t *)&a1[3], &a1[2].n128_i16[6], &v6);
  __n128 result = a1[1];
  v4[1] = result;
  v4[2].n128_u64[0] = a1[2].n128_u64[0];
  v4[2].n128_u32[2] = a1[2].n128_u32[2];
  v4[2].n128_u16[7] |= a1[2].n128_u16[7] & 0x5800;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  __n128 result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Custom>::atom_count(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Custom>::copy_atoms(uint64_t a1, uint64_t a2)
{
  MEMORY[0x270FA5388](a1, a2);
  unsigned int v5 = v4;
  unsigned int v7 = v6;
  uint64_t v8 = v3;
  int v9 = v2;
  uint64_t v16 = *MEMORY[0x263EF8340];
  if (v6 || v2[4].n128_u32[2] != v4)
  {
    RB::Heap::Heap((RB::Heap *)v14, v15, 4096, 0);
    RB::Coverage::Glyphs::Glyphs((RB::Coverage::Glyphs *)v13, (const RB::Coverage::Glyphs *)&v9[3].n128_i8[8], (RB::Heap *)v14, v7, v5);
    long long v10 = (RB::Heap *)(*(void *)(v8 + 8) + 16);
    int v12 = v9[2].n128_u16[7] & 0x3F;
    long long v11 = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill6CustomEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v10, v10, (RB::Coverage::Glyphs *)v13, (uint64_t)&v9[7], (uint64_t *)&v9[3], &v9[2].n128_i16[6], &v12);
    *((__n128 *)v11 + 1) = v9[1];
    v11[4] = v9[2].n128_u64[0];
    if (!*(unsigned char *)(v8 + 272)) {
      RB::DisplayList::Contents::copy_atoms(*(RB::DisplayList::Contents **)(v8 + 8), (const RB::DisplayList::Metadata **)v11 + 4, v7, v5);
    }
    *((_DWORD *)v11 + 10) = v9[2].n128_u32[2];
    RB::Heap::~Heap((RB::Heap *)v14);
  }
  else
  {
    RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Custom>::copy(v2, v3);
  }
}

void sub_21417283C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  RB::Heap::~Heap((RB::Heap *)va);
  _Unwind_Resume(a1);
}

float32x2_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Custom>::atom_position(uint64_t a1, unsigned int a2)
{
  float64x2_t v2 = vcvtq_f64_f32(*(float32x2_t *)(*(void *)(a1 + 64) + 8 * a2));
  return vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(*(void *)(a1 + 48) + 32), *(float64x2_t *)*(void *)(a1 + 48), v2.f64[0]), *(float64x2_t *)(*(void *)(a1 + 48) + 16), v2, 1));
}

float32x2_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Custom>::atom_bounds(uint64_t a1, unsigned int a2, int a3)
{
  double v4 = RB::Coverage::Glyphs::glyph_bounds((RB::Coverage::Glyphs *)(a1 + 56), a2, a3);
  unsigned int v6 = *(float64x2_t **)(a1 + 48);
  return RB::operator*(v6, *(float32x2_t *)&v4, v5);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::can_append_color_matrix()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::append_alpha_gradient()
{
  return 0;
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Custom>::disable_subpixel_quantization(uint64_t a1, float64x2_t *a2)
{
  float64x2_t v2 = (RB::Coverage::Glyphs *)(a1 + 56);
  v3.f64[0] = RB::operator*(*(float64x2_t **)(a1 + 48), a2);
  v6[0] = v3;
  v6[1] = v4;
  float32x2_t v6[2] = (float64x2_t)v5;
  RB::Coverage::Glyphs::disable_subpixel_quantization(v2, v6, v3.f64[0], v4.f64[0], v5);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::required_depth()
{
  return 0;
}

double RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::bounds(uint64_t a1, char a2)
{
  return RB::Coverage::Glyphs::bounds((RB::Coverage::Glyphs *)(a1 + 56), *(float64x2_t **)(a1 + 48), a2);
}

double RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::min_scale()
{
  return 0.0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::has_no_effect(uint64_t a1)
{
  __asm { FCMP            H0, #0 }
  if (_ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  else {
    return 0;
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::prepare(uint64_t a1, const RB::RenderParams *a2)
{
  return RB::Fill::Custom::prepare((RB::Fill::Custom *)(a1 + 112), a2, *(const RB::AffineTransform **)(a1 + 48));
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::render(float32x2_t *a1, double a2, uint64_t a3, uint64_t a4, char a5, int a6)
{
  unsigned int v6 = (float64x2_t *)a1[6];
  v7.i64[0] = SLODWORD(a2);
  v7.i64[1] = SHIDWORD(a2);
  float64x2_t v8 = v6[1];
  _Q0 = vaddq_f64(v6[2], vcvtq_f64_s64(v7));
  v14[0] = *v6;
  v14[1] = v8;
  float32x2_t v14[2] = _Q0;
  LOWORD(_Q0.f64[0]) = a1[5].i16[2];
  __asm { FCVT            S0, H0 }
  RB::render_glyphs(a4, v14, a1 + 7, (uint64_t)&a1[14], a5, a6, *(float *)_Q0.f64);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::render(uint64_t a1, uint64_t a2)
{
  float64x2_t v4 = *(float64x2_t **)(a1 + 48);
  int64x2_t v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  unsigned int v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&float32x2_t v12 = (*(double (**)(uint64_t, void))(*(void *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v18, v12, v13);
  int v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5) {
    goto LABEL_10;
  }
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v18[0].f64[0], *(int32x2_t *)&v18[0].f64[1]))
  {
    int v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v18, v14, _S8);
    goto LABEL_11;
  }
  int v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4) {
    goto LABEL_10;
  }
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11) {
    goto LABEL_10;
  }
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::Glyphs::clip((float32x2_t **)(a1 + 56), (RB::CGContext *)a2);
  v18[0] = (float64x2_t)xmmword_2142181C0;
  v18[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  double v16 = RB::Coverage::Glyphs::bounds((RB::Coverage::Glyphs *)(a1 + 56), v18, 0);
  RB::Bounds::Bounds(&v21, *(float32x2_t *)&v16, v17);
  RBStrokeRef::clip(a1 + 112);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 112), a2);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::apply_transform(uint64_t a1, const RB::DisplayList::Transform *a2, uint64_t a3)
{
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::prepare_mix(float64x2_t **a1, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Interpolator::Op *a3, float64x2_t **a4)
{
  __n128 result = (unint64_t *)(*(uint64_t (**)(float64x2_t **))&(*a4)[1].f64[0])(a4);
  if (result == 16797697)
  {
    __n128 result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      __n128 result = (unint64_t *)RB::can_mix(a1[6], a4[6], v10);
      int v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        __n128 result = (unint64_t *)RB::Coverage::Glyphs::can_mix((RB::Coverage::Glyphs *)(a1 + 7), a3, (const RB::Coverage::Glyphs *)(a4 + 7));
        if ((_BYTE)result)
        {
          unsigned __int8 v12 = result;
          can_mifloat64_t x = RB::Fill::Custom::can_mix((RB::Fill::Custom *)(a1 + 14), (const RB::Fill::Custom *)(a4 + 14));
          return RB::DisplayList::Interpolator::Op::set_type((unint64_t *)a3, v11, v12, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::mix(CGAffineTransform **a1, uint64_t a2, float64x2_t **a3, float64x2_t *a4)
{
  uint64_t v8 = (*(uint64_t (**)(CGAffineTransform **, void, void, void, uint64_t))&(*a1)[1].a)(a1, *(void *)&a4->f64[0], *(unsigned int *)(*(void *)(a2 + 8) + 12), **(void **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], a3[6], v9, *(float *)(a2 + 16));
  v23[0] = v10;
  v23[1] = v11;
  float64x2_t v23[2] = v12;
  *(void *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v23);
  float32x2_t v13 = (RB::Heap *)(*(void *)(*(void *)&a4->f64[0] + 8) + 16);
  RB::Fill::Custom::mix((RB::Fill::Custom *)(v8 + 112), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::Custom *)(a3 + 14), *(float *)(a2 + 16), v13);
  v14.f64[0] = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  v22[0] = v14;
  v22[1] = v15;
  float64x2_t v22[2] = v16;
  v17.f64[0] = RB::operator*(a3[6], a4 + 68);
  v21[0] = v17;
  v21[1] = v18;
  int32x2_t v21[2] = v19;
  RB::Coverage::Glyphs::mix((float32x2_t *)(v8 + 56), (const RB::DisplayList::Interpolator::State *)a2, (const RB::Coverage::Glyphs *)(a3 + 7), v22, v21, *(float64x2_t **)(v8 + 48), v13);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(unsigned char *)(*(void *)&a4->f64[0] + 272)) {
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::prepare_encode(uint64_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode(a1, a2);
  RB::Coverage::Glyphs::prepare_encode((uint64_t)(a1 + 7), a2);
  return RB::Fill::Custom::prepare_encode((RB::Fill::Custom *)(a1 + 14), a2);
}

void *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::encode(uint64_t a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Glyphs>(this, 1, (CGFont **)(a1 + 56));
  RB::Encoder::typed_message_field<RB::Fill::Custom>(this, 2, (RB::Fill::Custom *)(a1 + 112));
  float64x2_t v4 = *(float64x2_t **)(a1 + 48);
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::print(const RB::AffineTransform **a1, std::string *this)
{
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::atom_position(uint64_t a1)
{
  double v1 = RB::Coverage::Glyphs::bounds((RB::Coverage::Glyphs *)(a1 + 56), *(float64x2_t **)(a1 + 48), 0);
  return vmla_f32(*(float32x2_t *)&v1, (float32x2_t)0x3F0000003F000000, v2);
}

void *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill6CustomEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, RB::Heap *a2, RB::Coverage::Glyphs *a3, uint64_t a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14 = *((void *)this + 3);
  uint64_t v15 = (*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v15 + 320 > v14) {
    uint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0x140uLL, 15);
  }
  else {
    *((void *)this + 2) = v15 + 320;
  }
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  __n128 result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::GenericItem1(v15, a2, a3, a4, *a5, *a7, _S0);
  *__n128 result = &unk_26C4E9570;
  return result;
}

void *RBFillData::apply<RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RBStrokeRef>>>(void *result, uint64_t *a2)
{
  switch(*(_DWORD *)result)
  {
    case 1:
      __n128 result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RBStrokeRef>>::operator()<RB::Fill::Color>(a2, (uint64_t)(result + 2));
      break;
    case 2:
      __n128 result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RBStrokeRef>>::operator()<RB::Fill::Gradient>(a2, result + 2);
      break;
    case 3:
      __n128 result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RBStrokeRef>>::operator()<RB::Fill::MeshGradient>(a2, (uint64_t)(result + 2));
      break;
    case 4:
      __n128 result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RBStrokeRef>>::operator()<RB::Fill::Image<RB::ImageTexture>>(a2, (const RB::ImageTexture *)(result + 2));
      break;
    case 5:
      __n128 result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RBStrokeRef>>::operator()<RB::Fill::Custom>(a2, (uint64_t)(result + 2));
      break;
    default:
      return result;
  }
  return result;
}

void *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RBStrokeRef>>::operator()<RB::Fill::Color>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  __n128 result = *(void **)(*a1 + 56);
  if (!result)
  {
    __n128 result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v3, *(void *)v3, a1[1], a2, (uint64_t *)(v3 + 8), (float *)(v3 + 16), (_DWORD *)(v3 + 20), (__int16 *)(v3 + 24));
    uint64_t v3 = *a1;
    *(void *)(*a1 + 56) = result;
  }
  if (*(unsigned char *)(v3 + 48)) {
    *((_WORD *)result + 23) |= 0x1000u;
  }
  return result;
}

void *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RBStrokeRef>>::operator()<RB::Fill::Gradient>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a1;
  __n128 result = *(void **)(*a1 + 56);
  if (!result)
  {
    __n128 result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v3, *(RB::Heap **)v3, a1[1], a2, (uint64_t *)(v3 + 8), (float *)(v3 + 16), (_DWORD *)(v3 + 20), (__int16 *)(v3 + 24));
    uint64_t v3 = *a1;
    *(void *)(*a1 + 56) = result;
  }
  if (*(unsigned char *)(v3 + 48)) {
    *((_WORD *)result + 23) |= 0x1000u;
  }
  return result;
}

void *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RBStrokeRef>>::operator()<RB::Fill::MeshGradient>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  __n128 result = *(void **)(*a1 + 56);
  if (!result)
  {
    __n128 result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v3, *(RB::Heap **)v3, a1[1], a2, (uint64_t *)(v3 + 8), (float *)(v3 + 16), (_DWORD *)(v3 + 20), (__int16 *)(v3 + 24));
    uint64_t v3 = *a1;
    *(void *)(*a1 + 56) = result;
  }
  if (*(unsigned char *)(v3 + 48)) {
    *((_WORD *)result + 23) |= 0x1000u;
  }
  return result;
}

void *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RBStrokeRef>>::operator()<RB::Fill::Image<RB::ImageTexture>>(uint64_t *a1, const RB::ImageTexture *a2)
{
  uint64_t v3 = *a1;
  __n128 result = *(void **)(*a1 + 56);
  if (!result)
  {
    __n128 result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v3, *(RB::Heap **)v3, a1[1], a2, (uint64_t *)(v3 + 8), (float *)(v3 + 16), (_DWORD *)(v3 + 20), (__int16 *)(v3 + 24));
    uint64_t v3 = *a1;
    *(void *)(*a1 + 56) = result;
  }
  if (*(unsigned char *)(v3 + 48)) {
    *((_WORD *)result + 23) |= 0x1000u;
  }
  return result;
}

void *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RBStrokeRef>>::operator()<RB::Fill::Custom>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  __n128 result = *(void **)(*a1 + 56);
  if (!result)
  {
    __n128 result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v3, *(void *)v3, a1[1], a2, (uint64_t *)(v3 + 8), (float *)(v3 + 16), (_DWORD *)(v3 + 20));
    uint64_t v3 = *a1;
    *(void *)(*a1 + 56) = result;
  }
  if (*(unsigned char *)(v3 + 48)) {
    *((_WORD *)result + 23) |= 0x1000u;
  }
  return result;
}

void *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16 = *((void *)this + 3);
  uint64_t v17 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 120 > v16) {
    uint64_t v17 = RB::Heap::alloc_slow((size_t *)this, 0x78uLL, 7);
  }
  else {
    *((void *)this + 2) = v17 + 120;
  }
  __n128 result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::GenericItem1(v17, *a6, a2, a3, a4, *a5, *a7, *a8);
  *__n128 result = &unk_26C4E97A0;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::GenericItem1(uint64_t a1, float _S0, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7, __int16 a8)
{
  __asm { FCVT            H0, S0 }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a7 & 0x3F;
  *(void *)a1 = &unk_26C4EAF40;
  *(void *)(a1 + 48) = a6;
  *(void *)(a1 + 56) = &unk_26C4EDD28;
  *(void *)(a1 + 64) = *(id *)(a4 + 8);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a4 + 16);
  *(unsigned char *)(a1 + 88) = *(unsigned char *)(a4 + 32);
  *(_WORD *)(a1 + 89) = *(_WORD *)(a4 + 33);
  *(unsigned char *)(a1 + 91) = *(unsigned char *)(a4 + 35);
  *(unsigned char *)(a1 + 92) = *(unsigned char *)(a4 + 36);
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(a4 + 40);
  if (*(unsigned char *)(a5 + 9)) {
    __int16 v17 = *(_WORD *)(a5 + 8);
  }
  else {
    __int16 v17 = a8;
  }
  *(void *)(a1 + 104) = *(void *)a5;
  *(_WORD *)(a1 + 112) = v17;
  return a1;
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::~GenericItem(uint64_t a1)
{
  *(void *)a1 = &unk_26C4EAF40;
  *(void *)(a1 + 56) = &unk_26C4EDD28;

  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::~GenericItem(uint64_t a1)
{
  *(void *)a1 = &unk_26C4EAF40;
  *(void *)(a1 + 56) = &unk_26C4EDD28;

  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::type_id()
{
  return 4210689;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::copy(__n128 *a1, uint64_t a2, char a3)
{
  unsigned __int16 v4 = a1[2].n128_u16[7];
  if (*(unsigned char *)(a2 + 272)) {
    BOOL v5 = (a3 & 2 | v4 & 0x1000) == 0;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5) {
    __int16 v6 = 4096;
  }
  else {
    __int16 v6 = 0;
  }
  int64x2_t v7 = (RB::Heap *)(*(void *)(a2 + 8) + 16);
  int v10 = v4 & 0x3F;
  uint64_t v8 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeI11RBStrokeRefEENS_4Fill5ColorEEEJRS0_RKS7_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v7, (uint64_t)v7, (uint64_t)&a1[3].n128_i64[1], (uint64_t)&a1[6].n128_i64[1], (uint64_t *)&a1[3], &a1[2].n128_i16[6], &v10);
  __n128 result = a1[1];
  v8[1] = result;
  v8[2].n128_u64[0] = a1[2].n128_u64[0];
  v8[2].n128_u32[2] = a1[2].n128_u32[2];
  v8[2].n128_u16[7] |= a1[2].n128_u16[7] & 0x5800 | v6;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  __n128 result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::atom_position(uint64_t a1, double a2, int32x4_t a3)
{
  float32x2_t v3 = RB::Coverage::Stroke<RBStrokeRef>::bounds((void *)(a1 + 56), *(float64x2_t **)(a1 + 48), a2, a3);
  return vmla_f32(v3, (float32x2_t)0x3F0000003F000000, v4);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::make_clip(uint64_t a1, uint64_t a2, int a3, void *a4, float a5)
{
  int v22 = a3;
  _H1 = *(_WORD *)(a1 + 110);
  __asm { FCVT            S1, H1 }
  float32x2_t v13 = (size_t *)(*(void *)(a2 + 8) + 16);
  _H2 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S2, H2 }
  float v21 = (float)(_S1 * a5) * _S2;
  uint64_t v16 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef>&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v13, (uint64_t)v13, a1 + 56, (int *)&v21, &v22, (uint64_t *)(a1 + 48));
  uint64_t v17 = a4[5];
  size_t v18 = v17 + 1;
  if (a4[6] < (unint64_t)(v17 + 1))
  {
    RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v18);
    uint64_t v17 = a4[5];
    size_t v18 = v17 + 1;
  }
  float64x2_t v19 = (void *)a4[4];
  if (!v19) {
    float64x2_t v19 = a4;
  }
  v19[v17] = v16;
  a4[5] = v18;
  return (**(uint64_t (***)(uint64_t))a1)(a1);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::can_append_color_matrix()
{
  return 1;
}

double RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::append_color_matrix(uint64_t a1, float16x4_t *a2, int a3, __int16 a4, uint16x4_t a5)
{
  *(void *)&double result = RB::Fill::Color::append_color_matrix((short float *)(a1 + 104), a2, a3, a4, a5);
  return result;
}

unint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::append_alpha_gradient(uint64_t a1, uint64_t a2, long long *a3)
{
  int v8 = *(_WORD *)(a1 + 46) & 0x3F;
  float32x2_t v4 = (size_t *)(*(void *)(a2 + 8) + 16);
  short float v7 = *(short float *)(a1 + 110) * *(short float *)(a1 + 44);
  unint64_t v5 = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeI11RBStrokeRefEENS_4Fill8GradientEEEJRS7_RKS9_RPKNS_15AffineTransformEDF16_RNS_9BlendModeEEEEPT_DpOT0_(v4, a1 + 56, a3, (uint64_t *)(a1 + 48), (__int16 *)&v7, &v8);
  *(_OWORD *)(v5 + 16) = *(_OWORD *)(a1 + 16);
  *(void *)(v5 + 32) = *(void *)(a1 + 32);
  *(_DWORD *)(v5 + 40) = *(_DWORD *)(a1 + 40);
  (**(void (***)(uint64_t))a1)(a1);
  return v5;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::required_depth(float16x4_t *a1)
{
  return RB::Fill::Color::required_depth(a1 + 13);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::bounds(uint64_t a1, double a2, int32x4_t a3)
{
  return RB::Coverage::Stroke<RBStrokeRef>::bounds((void *)(a1 + 56), *(float64x2_t **)(a1 + 48), a2, a3);
}

float RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::min_scale(uint64_t a1)
{
  float result = 0.0;
  if (!*(unsigned char *)(a1 + 88) && *(unsigned char *)(a1 + 92) == 1) {
    return 1.0;
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::has_no_effect(uint64_t a1)
{
  __asm { FCMP            H0, #0 }
  if (_ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  __asm { FCMP            H0, #0 }
  if (_NF ^ _VF | _ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  else {
    return 0;
  }
}

void **RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::prepare(void **result, uint64_t **a2)
{
  if (*((unsigned char *)result + 88) == 1) {
    return (void **)RBStrokeRef::prepare(result + 8, a2);
  }
  return result;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::render(uint64_t a1, double a2, uint64_t a3, uint64_t ***a4, int a5, int a6)
{
  int v10 = *(float64x2_t **)(a1 + 48);
  v11.i64[0] = SLODWORD(a2);
  v11.i64[1] = SHIDWORD(a2);
  float64x2_t v12 = v10[1];
  float64x2_t v13 = vaddq_f64(v10[2], vcvtq_f64_s64(v11));
  v16[0] = *v10;
  v16[1] = v12;
  _OWORD v16[2] = v13;
  uint64_t v14 = a1 + 56;
  short float v15 = *(short float *)(a1 + 44);
  RB::Coverage::Stroke<RBStrokeRef>::get_info((uint64_t *)(a1 + 56), a4, (uint64_t)v19);
  LOWORD(v17) = *(_WORD *)(a1 + 104);
  *(_DWORD *)((char *)&v17 + 2) = *(_DWORD *)(a1 + 106);
  *((short float *)&v17 + 3) = *(short float *)(a1 + 110) * v15;
  __int16 v18 = *(_WORD *)(a1 + 112);
  RB::render_stroke((uint64_t)a4, v16, v14, (uint64_t)v19, &v17, a5, a6);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::render(uint64_t a1, uint64_t a2)
{
  float32x2_t v4 = *(float64x2_t **)(a1 + 48);
  unint64_t v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  unsigned int v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&float32x2_t v12 = (*(double (**)(uint64_t, void))(*(void *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)&v17, v12, v13);
  int v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5) {
    goto LABEL_10;
  }
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v17, *(int32x2_t *)((char *)&v17 + 8)))
  {
    int v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, &v17, v14, _S8);
    return RBStrokeRef::clip(a1 + 64);
  }
  int v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4) {
    goto LABEL_10;
  }
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11) {
    goto LABEL_10;
  }
  return RBStrokeRef::clip(a1 + 64);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::Fill::Color::matches((RB::Fill::Color *)(a1 + 104), a2, a3);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::apply_transform(uint64_t a1, const RB::DisplayList::Transform *a2, uint64_t a3, uint32x4_t a4)
{
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, uint64_t a4)
{
  float result = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)a4 + 16))(a4);
  if (result == 4210689)
  {
    float result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      float result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a4 + 48), v10);
      int v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        if (*(unsigned __int8 *)(a1 + 88) == *(unsigned __int8 *)(a4 + 88)
          && *(unsigned __int8 *)(a1 + 89) == *(unsigned __int8 *)(a4 + 89)
          && *(unsigned __int8 *)(a1 + 90) == *(unsigned __int8 *)(a4 + 90)
          && *(unsigned __int8 *)(a1 + 91) == *(unsigned __int8 *)(a4 + 91)
          && *(unsigned __int8 *)(a1 + 92) == *(unsigned __int8 *)(a4 + 92)
          && *(float *)(a1 + 96) == *(float *)(a4 + 96))
        {
          float result = (unint64_t *)RBStrokeRef::can_mix((void *)(a1 + 64), (void *)(a4 + 64));
          if ((_BYTE)result)
          {
            unsigned __int8 v12 = result;
            can_mifloat64_t x = RB::Fill::Color::can_mix((RB::Fill::Color *)(a1 + 104), (const RB::Fill::Color *)(a4 + 104));
            return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v12, can_mix);
          }
        }
      }
    }
  }
  return result;
}