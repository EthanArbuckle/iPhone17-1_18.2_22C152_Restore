void sub_1002BB428(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1002BB348);
  }
  _Unwind_Resume(a1);
}

void sub_1002C0400(uint64_t a1)
{
  v2 = +[IDSFoundationLog QRAllocator_oversized];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    CFStringRef v5 = @"YES";
    if (!*(unsigned char *)(a1 + 64)) {
      CFStringRef v5 = @"NO";
    }
    uint64_t v6 = *(void *)(a1 + 48);
    uint64_t v7 = *(void *)(a1 + 56);
    int v8 = 138413314;
    uint64_t v9 = v3;
    __int16 v10 = 2112;
    uint64_t v11 = v4;
    __int16 v12 = 2112;
    uint64_t v13 = v6;
    __int16 v14 = 2112;
    CFStringRef v15 = v5;
    __int16 v16 = 2112;
    uint64_t v17 = v7;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Full allocate response payload for RequestID: %@ IDSSessionID: %@ QRSessionID: %@ from cache: %@ with payload %@", (uint8_t *)&v8, 0x34u);
  }
}

uint64_t sub_1002C34FC(uint64_t a1)
{
  if ([*(id *)(a1 + 32) snapshotWithSignature:*(void *)(a1 + 40) delay:0 events:0 payload:*(void *)(a1 + 48) actions:&stru_100987E88 reply:*(double *)(a1 + 56)])
  {
    v2 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138412290;
      uint64_t v8 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SymptomReporter: Sent snapshot for signature %@", buf, 0xCu);
    }

    uint64_t result = os_log_shim_legacy_logging_enabled();
    if (result)
    {
      uint64_t result = _IDSShouldLogTransport();
      if (result)
      {
        _IDSLogTransport();
        uint64_t result = _IDSShouldLog();
        if (result) {
          return _IDSLogV();
        }
      }
    }
  }
  else
  {
    CFStringRef v5 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138412290;
      uint64_t v8 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "SymptomReporter: Failed to send snapshot for signature %@", buf, 0xCu);
    }

    uint64_t result = os_log_shim_legacy_logging_enabled();
    if (result)
    {
      uint64_t result = _IDSShouldLogTransport();
      if (result)
      {
        _IDSLogTransport();
        uint64_t result = _IDSShouldLog();
        if (result) {
          return _IDSLogV();
        }
      }
    }
  }
  return result;
}

void sub_1002C371C(id a1, NSDictionary *a2)
{
  v2 = a2;
  uint64_t v3 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    CFStringRef v5 = v2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "SymptomReporter: got response from diagnosticReporter - %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      _IDSLogTransport();
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
  }
}

void sub_1002C5A90(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = [a3 allObjects];
  [*(id *)(a1 + 32) setObject:v6 forKeyedSubscript:v5];
}

id sub_1002C7658(uint64_t a1)
{
  return [*(id *)(a1 + 32) _invalidateSession:*(void *)(a1 + 40) isExpiryPurging:*(unsigned __int8 *)(a1 + 48)];
}

id sub_1002C79B0(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _discardAllocation:*(void *)(a1 + 40)];
}

void sub_1002C96B8(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(a1 + 40))
  {
    if (v2) {
      return;
    }
    uint64_t v3 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "enable push handler", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
    {
      _IDSLogTransport();
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
    uint64_t v4 = +[IDSPushHandler sharedInstanceWithPortName:@"com.apple.identityservicesd.aps"];
    uint64_t v5 = *(void *)(a1 + 32);
    id v6 = *(void **)(v5 + 8);
    *(void *)(v5 + 8) = v4;

    id v7 = objc_alloc((Class)NSSet);
    id v8 = objc_msgSend(v7, "initWithObjects:", kIDSQuickRelayPushTopic, 0);
    id v9 = objc_alloc((Class)NSSet);
    __int16 v10 = +[NSNumber numberWithInteger:200];
    uint64_t v11 = +[NSNumber numberWithInteger:255];
    id v12 = objc_msgSend(v9, "initWithObjects:", v10, v11, 0);

    uint64_t v13 = *(void *)(a1 + 32);
    __int16 v14 = *(void **)(v13 + 8);
    CFStringRef v15 = im_primary_queue();
    [v14 addListener:v13 topics:v8 commands:v12 queue:v15];
  }
  else
  {
    if (!v2) {
      return;
    }
    __int16 v16 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v19 = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "disable push handler", v19, 2u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
    objc_msgSend(*(id *)(*(void *)(a1 + 32) + 8), "removeListener:");
    uint64_t v17 = *(void *)(a1 + 32);
    id v8 = *(id *)(v17 + 8);
    *(void *)(v17 + 8) = 0;
  }
}

id sub_1002CA7B4(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _sendKeepAliveRequest:*(void *)(a1 + 40)];
}

uint64_t sub_1002CAFA4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1002CAFB4(uint64_t a1)
{
}

void sub_1002CAFBC(void *a1, void *a2, void *a3)
{
  id v10 = a2;
  uint64_t v5 = a3;
  if (a1[6] >= v5[2])
  {
    id v6 = *(void **)(*(void *)(a1[5] + 8) + 40);
    if (!v6)
    {
      uint64_t v7 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [*(id *)(a1[4] + 64) count]);
      uint64_t v8 = *(void *)(a1[5] + 8);
      id v9 = *(void **)(v8 + 40);
      *(void *)(v8 + 40) = v7;

      id v6 = *(void **)(*(void *)(a1[5] + 8) + 40);
    }
    [v6 addObject:v10];
  }
}

id sub_1002CB248(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _cleanupResponses];
}

void sub_1002CB43C(id a1)
{
}

void sub_1002CB724(uint64_t a1)
{
  uint64_t v3 = [*(id *)(a1 + 32) block];
  uint64_t v2 = [*(id *)(a1 + 32) _isFinishedBlock];
  v3[2](v3, v2, [*(id *)(a1 + 32) attempts]);
}

void sub_1002CB8E0(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
    [WeakRetained _run];
  }
}

void sub_1002CBB60(uint64_t a1)
{
  *(void *)&long long v2 = -1;
  *((void *)&v2 + 1) = -1;
  *(_OWORD *)(a1 + 96) = v2;
  *(_OWORD *)(a1 + 112) = v2;
  *(_OWORD *)(a1 + 64) = v2;
  *(_OWORD *)(a1 + 80) = v2;
  *(_OWORD *)(a1 + 32) = v2;
  *(_OWORD *)(a1 + 48) = v2;
  *(_OWORD *)a1 = v2;
  *(_OWORD *)(a1 + 16) = v2;
  bzero((void *)(a1 + 128), 0x1F80uLL);
  *(_WORD *)(a1 + 8200) = 1024;
  *(void *)(a1 + 0x2000) = 0;
}

uint64_t sub_1002CBBB0(uint64_t a1, _WORD *a2)
{
  uint64_t v4 = (_WORD *)(a1 + 8200);
  unsigned __int16 v5 = *(_WORD *)(a1 + 8200) + 1;
  uint64_t v6 = v5 >> 6;
  unint64_t v7 = *(void *)(a1 + 8 * v6);
  if (~v7 >> (*(_WORD *)(a1 + 8200) + 1))
  {
    unint64_t v8 = v5 & 0x3F;
    unint64_t v9 = v7 >> v5;
    unsigned int v10 = __clz(__rbit64(~(v7 >> v5)));
    if (v9 == -1) {
      uint64_t v11 = 0xFFFFFFFFLL;
    }
    else {
      uint64_t v11 = v10;
    }
    __int16 v12 = v11 + v8 + ((*(_WORD *)(a1 + 8200) + 1) & 0xFFC0);
    *a2 = v12;
    *(void *)(a1 + 8 * v6) = (1 << (v11 + v8)) | v7;
    uint64_t v13 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = (unsigned __int16)*v4;
      *(_DWORD *)buf = 67110400;
      *(_DWORD *)v42 = v14;
      *(_WORD *)&v42[4] = 1024;
      *(_DWORD *)&v42[6] = v6;
      __int16 v43 = 1024;
      int v44 = v8;
      __int16 v45 = 1024;
      *(_DWORD *)v46 = v11 + v8;
      *(_WORD *)&v46[4] = 2048;
      *(void *)&v46[6] = v9;
      __int16 v47 = 1024;
      int v48 = v11;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "found in cur (last = %u) - index=%d shift=%d newShift=%d (cur=%llu, ffsll(~cur)=%d)", buf, 0x2Au);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      unint64_t v37 = v9;
      uint64_t v38 = v11;
      unint64_t v35 = v8;
      uint64_t v36 = (v11 + v8);
      uint64_t v33 = (unsigned __int16)*v4;
      uint64_t v34 = v6;
      _IDSLogV();
    }
    *uint64_t v4 = v12;
    unint64_t v15 = *(void *)(a1 + 0x2000) + 1;
    *(void *)(a1 + 0x2000) = v15;
LABEL_25:
    if (v15 >= 0xB5)
    {
      uint32_t v22 = arc4random_uniform(0x64u);
      unsigned int v23 = +[IDSAutoBugCapture isSupported];
      unsigned int v24 = v22 < 5 ? v23 : 0;
      if (v24 == 1)
      {
        if (qword_100A4C568 != -1) {
          dispatch_once(&qword_100A4C568, &stru_100987F68);
        }
        os_unfair_lock_lock((os_unfair_lock_t)&dword_100A4C560);
        v25 = (void *)qword_100A4C558;
        if (!qword_100A4C558
          || (+[NSDate date],
              v26 = objc_claimAutoreleasedReturnValue(),
              BOOL v27 = [v25 compare:v26] == (id)1,
              v26,
              !v27))
        {
          uint64_t v28 = +[NSDate dateWithTimeIntervalSinceNow:](NSDate, "dateWithTimeIntervalSinceNow:", 259200.0, v33, v34, v35, v36, v37, v38);
          v29 = (void *)qword_100A4C558;
          qword_100A4C558 = v28;

          +[NSString stringWithFormat:@"Number of allocated ports passed high watermark!"];
          v39[0] = _NSConcreteStackBlock;
          v39[1] = 3221225472;
          v39[2] = sub_1002CC194;
          v39[3] = &unk_100980830;
          id v30 = (id)objc_claimAutoreleasedReturnValue();
          id v40 = v30;
          +[IDSAutoBugCapture triggerCaptureWithEvent:209 context:v30 completion:v39];
        }
        os_unfair_lock_unlock((os_unfair_lock_t)&dword_100A4C560);
      }
    }
    return 0;
  }
  else
  {
    int v16 = 0;
    char v17 = 0;
LABEL_12:
    ++v16;
    do
    {
      uint64_t v6 = (v6 + 1) & 0x3FF;
      uint64_t v18 = *(void *)(a1 + 8 * v6);
      if (v18 != -1)
      {
        unint64_t v19 = __clz(__rbit64(~v18));
        *a2 = v19 | ((_WORD)v6 << 6);
        *(void *)(a1 + 8 * v6) = (1 << v19) | v18;
        v20 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          int v21 = (unsigned __int16)*v4;
          *(_DWORD *)buf = 67110144;
          *(_DWORD *)v42 = v21;
          *(_WORD *)&v42[4] = 1024;
          *(_DWORD *)&v42[6] = v6;
          __int16 v43 = 1024;
          int v44 = v19;
          __int16 v45 = 2048;
          *(void *)v46 = v18;
          *(_WORD *)&v46[8] = 1024;
          *(_DWORD *)&v46[10] = v19;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "found (last = %u) - at index=%d newShift=%d (cur=%llu, ffsll(~cur)=%d)", buf, 0x24u);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
        {
          uint64_t v36 = v18;
          unint64_t v37 = v19;
          uint64_t v34 = v6;
          unint64_t v35 = v19;
          uint64_t v33 = (unsigned __int16)*v4;
          _IDSLogV();
        }
        *uint64_t v4 = v19 | ((_WORD)v6 << 6);
        ++*(void *)(a1 + 0x2000);
        char v17 = 1;
        if (v16 == 1023) {
          goto LABEL_24;
        }
        goto LABEL_12;
      }
      ++v16;
    }
    while (v16 != 1024);
    if (v17)
    {
LABEL_24:
      unint64_t v15 = *(void *)(a1 + 0x2000);
      goto LABEL_25;
    }
    v32 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315138;
      *(void *)v42 = "int IDSPortMap_GetNextAvailablePort(struct IDSPortMap *, uint16_t *)";
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "[Fatal error encountered] %s: ran out of ports to allocate, aborting!!!", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      _IDSLogTransport();
    }
    if (!isRunningTests()) {
      abort();
    }
    throwsIDSAbortException();
    return 1;
  }
}

void sub_1002CC188(id a1)
{
  dword_100A4C560 = 0;
}

void sub_1002CC194(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  unint64_t v7 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    uint64_t v10 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Finished capturing AutoBugCapture diagnostics for %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
}

uint64_t sub_1002CC2C4(uint64_t result, unsigned int a2)
{
  uint64_t v2 = a2 >> 6;
  uint64_t v3 = *(void *)(result + 8 * v2);
  if ((v3 & (1 << a2)) != 0)
  {
    uint64_t v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "can't allocated used port", v5, 2u);
    }

    uint64_t result = os_log_shim_legacy_logging_enabled();
    if (result)
    {
      uint64_t result = _IDSShouldLog();
      if (result) {
        return _IDSLogV();
      }
    }
  }
  else
  {
    *(void *)(result + 8 * v2) = v3 | (1 << a2);
    ++*(void *)(result + 0x2000);
  }
  return result;
}

uint64_t sub_1002CC3B8(uint64_t result, unsigned int a2)
{
  uint64_t v2 = a2 >> 6;
  uint64_t v3 = *(void *)(result + 8 * v2);
  if ((v3 & (1 << a2)) != 0)
  {
    *(void *)(result + 8 * v2) = v3 & ~(1 << a2);
    --*(void *)(result + 0x2000);
  }
  else
  {
    uint64_t v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "can't release unallocated port", v5, 2u);
    }

    uint64_t result = os_log_shim_legacy_logging_enabled();
    if (result)
    {
      uint64_t result = _IDSShouldLog();
      if (result) {
        return _IDSLogV();
      }
    }
  }
  return result;
}

void sub_1002CD290(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) registrationKeychainManager];
  uint64_t v3 = IDSRegistrationServiceTypeStewie;
  uint64_t v4 = [*(id *)(a1 + 40) uniqueIdentifier];
  id v5 = [v2 registrationWithServiceType:v3 registrationType:0 value:v4];

  id v6 = [*(id *)(a1 + 32) userStore];
  unint64_t v7 = [v6 authenticationCertificateForUser:*(void *)(a1 + 40)];

  uint64_t v8 = +[IDSFoundationLog stewieProvisioning];
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = *(void *)(a1 + 40);
    CFStringRef v10 = @"YES";
    int v15 = 138412802;
    if (!v7) {
      CFStringRef v10 = @"NO";
    }
    uint64_t v16 = v9;
    __int16 v17 = 2112;
    CFStringRef v18 = v10;
    __int16 v19 = 2112;
    v20 = v5;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Found existing information for phone user { user: %@, hasAuthCert: %@, registration: %@ }", (uint8_t *)&v15, 0x20u);
  }

  if (v7
    && ([*(id *)(a1 + 40) uniqueIdentifier],
        uint64_t v11 = objc_claimAutoreleasedReturnValue(),
        v11,
        v11))
  {
    __int16 v12 = [*(id *)(a1 + 32) createPhoneInfoForUser:*(void *)(a1 + 40) cert:v7];
    uint64_t v13 = [*(id *)(a1 + 32) phoneInfos];
    int v14 = [*(id *)(a1 + 40) uniqueIdentifier];
    [v13 setObject:v12 forKeyedSubscript:v14];

    [v5 removeFromKeychain];
  }
  else
  {
    if (!v5)
    {
      id v5 = sub_1002CD498(*(void **)(a1 + 32), *(void **)(a1 + 40));
    }
    sub_1002CD600(*(void **)(a1 + 32), v5);
  }
  sub_1002CD718(*(void **)(a1 + 32));
}

IDSRegistration *sub_1002CD498(void *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    uint64_t v4 = objc_alloc_init(IDSRegistration);
    [(IDSRegistration *)v4 setServiceType:IDSRegistrationServiceTypeStewie];
    [(IDSRegistration *)v4 setRegistrationType:0];
    id v5 = [v3 uniqueIdentifier];
    [(IDSRegistration *)v4 setUserUniqueIdentifier:v5];

    id v6 = [a1 pushHandler];
    unint64_t v7 = [v6 pushToken];
    [(IDSRegistration *)v4 setPushToken:v7];

    uint64_t v8 = +[IDSFoundationLog stewieProvisioning];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 138412546;
      id v11 = v3;
      __int16 v12 = 2112;
      uint64_t v13 = v4;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Created registration for user { user: %@, registration: %@ }", (uint8_t *)&v10, 0x16u);
    }
  }
  else
  {
    uint64_t v4 = 0;
  }

  return v4;
}

void sub_1002CD600(void *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    uint64_t v4 = +[IDSFoundationLog stewieProvisioning];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      id v9 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "PNRing registration { registration: %@ }", (uint8_t *)&v8, 0xCu);
    }

    id v5 = [a1 inProgressRegistrations];
    id v6 = [v3 userUniqueIdentifier];
    [v5 setObject:v3 forKeyedSubscript:v6];

    unint64_t v7 = [a1 registrationController];
    [v7 registerInfo:v3];
  }
}

void sub_1002CD718(void *a1)
{
  if (a1)
  {
    uint64_t v2 = [a1 inProgressRegistrations];
    id v3 = [v2 count];

    uint64_t v4 = +[IDSFoundationLog stewieProvisioning];
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (v3)
    {
      if (!v5)
      {
LABEL_9:

        return;
      }
      id v6 = [a1 inProgressRegistrations];
      unint64_t v7 = [a1 phoneInfos];
      int v10 = 138412546;
      id v11 = v6;
      __int16 v12 = 2112;
      uint64_t v13 = v7;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "In progress registrations, waiting to conclude { inProgress: %@, finished: %@ }", (uint8_t *)&v10, 0x16u);
    }
    else
    {
      if (v5)
      {
        int v8 = [a1 phoneInfos];
        int v10 = 138412290;
        id v11 = v8;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Obtained phone infos for all users { phoneInfos: %@ }", (uint8_t *)&v10, 0xCu);
      }
      id v9 = [a1 phoneInfos];
      uint64_t v4 = [v9 allValues];

      id v6 = [a1 delegate];
      [v6 phoneNumberManager:a1 phoneNumberInfosChanged:v4];
    }

    goto LABEL_9;
  }
}

void sub_1002CD924(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1 && v3)
  {
    BOOL v5 = +[IDSFoundationLog stewieProvisioning];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 138412290;
      int v10 = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Cancelling in progress registration { registration: %@ }", (uint8_t *)&v9, 0xCu);
    }

    id v6 = [a1 inProgressRegistrations];
    unint64_t v7 = [v4 userUniqueIdentifier];
    [v6 setObject:0 forKeyedSubscript:v7];

    int v8 = [a1 registrationController];
    [v8 cancelActionsForRegistrationInfo:v4];

    [v4 removeFromKeychain];
  }
}

void sub_1002CE2F8(uint64_t a1, int *a2, int *a3)
{
  uint64_t v5 = a1 - 32000;
  if ((unint64_t)(a1 - 32000) >= 0x18)
  {
    int v7 = a1;
    int v6 = 20;
  }
  else
  {
    int v6 = dword_100794830[v5];
    int v7 = dword_100794890[v5];
  }
  id v21 = +[FTNetworkSupport sharedInstance];
  unsigned int v8 = [v21 validNetworkActive];
  unsigned int v9 = [v21 validNetworkEnabled];
  unsigned int v10 = [v21 validNetworkReachable];
  if (([v21 allowAnyNetwork] & 1) != 0
    || (+[FTDeviceSupport sharedInstance],
        id v11 = objc_claimAutoreleasedReturnValue(),
        unsigned int v12 = [v11 nonWifiFaceTimeAvailable],
        v11,
        v12))
  {
    int v13 = v9 & v8;
    if (v10) {
      int v14 = v6;
    }
    else {
      int v14 = 1;
    }
    if (v10) {
      int v15 = v7;
    }
    else {
      int v15 = 0;
    }
    if (v13 == 1) {
      int v16 = v14;
    }
    else {
      int v16 = 13;
    }
    if (v13 == 1) {
      int v17 = v15;
    }
    else {
      int v17 = 0;
    }
    if (a2) {
LABEL_19:
    }
      *a2 = v16;
  }
  else
  {
    int v18 = v9 & v8;
    if (v10) {
      int v19 = v6;
    }
    else {
      int v19 = 1;
    }
    if (v10) {
      int v20 = v7;
    }
    else {
      int v20 = 0;
    }
    if (v18 == 1) {
      int v16 = v19;
    }
    else {
      int v16 = 1;
    }
    if (v18 == 1) {
      int v17 = v20;
    }
    else {
      int v17 = 25;
    }
    if (a2) {
      goto LABEL_19;
    }
  }
  if (a3) {
    *a3 = v17;
  }
}

void sub_1002CE7D8(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init((Class)NSMutableArray);
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  uint64_t v27 = a1;
  id obj = [*(id *)(a1 + 32) endpoints];
  id v5 = [obj countByEnumeratingWithState:&v29 objects:v41 count:16];
  v26 = v4;
  if (!v5) {
    goto LABEL_19;
  }
  id v6 = v5;
  uint64_t v7 = *(void *)v30;
  do
  {
    for (i = 0; i != v6; i = (char *)i + 1)
    {
      if (*(void *)v30 != v7) {
        objc_enumerationMutation(obj);
      }
      unsigned int v9 = *(void **)(*((void *)&v29 + 1) + 8 * i);
      unsigned int v10 = [v9 URI];
      id v11 = [v10 prefixedURI];

      unsigned int v12 = [v9 pushToken];
      int v13 = [v3 objectForKey:v11];
      int v14 = v13;
      if (v13 && ([v13 optedIn] & 1) != 0)
      {
        int v15 = [v14 verifiedPushTokens];
        unsigned int v16 = [v15 containsObject:v12];

        if (v16)
        {
          id v4 = v26;
          [v26 addObject:v9];
          int v17 = +[IDSFoundationLog delivery_keyTransparency];
          if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_17;
          }
          int v18 = [*(id *)(v27 + 32) service];
          *(_DWORD *)buf = 138412802;
          uint64_t v36 = v18;
          __int16 v37 = 2112;
          uint64_t v38 = v11;
          __int16 v39 = 2112;
          id v40 = v12;
          int v19 = v17;
          int v20 = "Recipient endpoint is opted into KT and this endpoint is verified. Will send to this endpoint. { service"
                ": %@, uri: %@, token: %@ }";
LABEL_15:
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v20, buf, 0x20u);
        }
        else
        {
          int v17 = +[IDSFoundationLog delivery_keyTransparency];
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            int v18 = [*(id *)(v27 + 32) service];
            *(_DWORD *)buf = 138412802;
            uint64_t v36 = v18;
            __int16 v37 = 2112;
            uint64_t v38 = v11;
            __int16 v39 = 2112;
            id v40 = v12;
            int v19 = v17;
            int v20 = "Recipient endpoint is opted into KT and is not verified, will not send to this endpoint. { service: %@"
                  ", uri: %@, token: %@ }";
            goto LABEL_15;
          }
        }
        id v4 = v26;
        goto LABEL_17;
      }
      [v4 addObject:v9];
      int v17 = +[IDSFoundationLog delivery_keyTransparency];
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        id v21 = [*(id *)(v27 + 32) service];
        *(_DWORD *)buf = 138412802;
        uint64_t v36 = v21;
        __int16 v37 = 2112;
        uint64_t v38 = v11;
        __int16 v39 = 2112;
        id v40 = v12;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Recipient endpoint is not opted into KT. Will send to this endpoint. { service: %@, uri: %@, token: %@ }", buf, 0x20u);
      }
LABEL_17:
    }
    id v6 = [obj countByEnumeratingWithState:&v29 objects:v41 count:16];
  }
  while (v6);
LABEL_19:

  if ([v4 count])
  {
    [*(id *)(v27 + 32) setEndpoints:v4];
    [*(id *)(v27 + 40) fulfillWithValue:*(void *)(v27 + 32)];
  }
  else
  {
    uint64_t v22 = IDSSendErrorDomain;
    uint64_t v23 = *(void *)(v27 + 32);
    CFStringRef v33 = @"IDSPipelineParameter";
    uint64_t v34 = v23;
    unsigned int v24 = +[NSDictionary dictionaryWithObjects:&v34 forKeys:&v33 count:1];
    v25 = +[NSError errorWithDomain:v22 code:38 userInfo:v24];

    [*(id *)(v27 + 40) failWithError:v25];
    id v4 = v26;
  }
}

dispatch_queue_t sub_1002CEC94()
{
  v0 = dispatch_queue_attr_make_with_autorelease_frequency((dispatch_queue_attr_t)&_dispatch_queue_attr_concurrent, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t v1 = dispatch_queue_create("IDSAsyncMapperQueue", v0);

  return v1;
}

uint64_t sub_1002CEF28(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1002CEF40(uint64_t a1, void *a2)
{
  id v3 = a2;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  id v4 = [v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v13;
    do
    {
      for (i = 0; i != v5; i = (char *)i + 1)
      {
        if (*(void *)v13 != v6) {
          objc_enumerationMutation(v3);
        }
        unsigned int v8 = *(void **)(*((void *)&v12 + 1) + 8 * i);
        unsigned int v9 = [v3 objectForKeyedSubscript:v8];
        objc_msgSend(*(id *)(a1 + 32), "replaceObjectAtIndex:withObject:", objc_msgSend(v8, "unsignedIntegerValue"), v9);
      }
      id v5 = [v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
    }
    while (v5);
  }
  uint64_t v10 = *(void *)(a1 + 40);
  id v11 = [*(id *)(a1 + 32) copy];
  (*(void (**)(uint64_t, id))(v10 + 16))(v10, v11);
}

void sub_1002CF414(uint64_t a1)
{
  dispatch_group_enter(*(dispatch_group_t *)(a1 + 32));
  uint64_t v2 = *(void *)(a1 + 72);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 48);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_1002CF500;
  v7[3] = &unk_100987FE0;
  id v8 = *(id *)(a1 + 56);
  id v9 = *(id *)(a1 + 64);
  int8x16_t v6 = *(int8x16_t *)(a1 + 32);
  id v5 = (id)v6.i64[0];
  int8x16_t v10 = vextq_s8(v6, v6, 8uLL);
  (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(v2 + 16))(v2, v3, v4, v7);
}

void sub_1002CF500(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_1002CF5C8;
  v7[3] = &unk_10097E5A8;
  uint64_t v4 = *(NSObject **)(a1 + 32);
  id v8 = *(id *)(a1 + 40);
  id v9 = v3;
  id v5 = *(void **)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 48);
  id v11 = v5;
  id v6 = v3;
  dispatch_barrier_async(v4, v7);
}

void sub_1002CF5C8(uint64_t a1)
{
  id v3 = *(void **)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    [*(id *)(a1 + 32) setObject:v2 forKey:*(void *)(a1 + 48)];
  }
  else
  {
    uint64_t v4 = +[NSNull null];
    [v3 setObject:v4 forKey:*(void *)(a1 + 48)];
  }
  id v5 = *(NSObject **)(a1 + 56);

  dispatch_group_leave(v5);
}

void sub_1002CF644(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  id v2 = [*(id *)(a1 + 32) copy];
  (*(void (**)(uint64_t, id))(v1 + 16))(v1, v2);
}

void sub_1002D07D0(void *a1, char a2)
{
  if (a2)
  {
    id v3 = +[IDSFoundationLog IDSOffGridMessenger];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = a1[4];
      uint64_t v5 = a1[5];
      uint64_t v6 = a1[6];
      int v14 = 138412802;
      uint64_t v15 = v4;
      __int16 v16 = 2112;
      uint64_t v17 = v5;
      __int16 v18 = 2112;
      uint64_t v19 = v6;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Successfully saved client donated handles {destinationURIs: %@, fromURI: %@, options: %@}", (uint8_t *)&v14, 0x20u);
    }

    (*(void (**)(void))(a1[7] + 16))();
  }
  else
  {
    uint64_t v7 = IDSOffGridDeliveryErrorDomain;
    NSErrorUserInfoKey v20 = NSLocalizedDescriptionKey;
    CFStringRef v21 = @"Failed to save donated handles";
    id v8 = +[NSDictionary dictionaryWithObjects:&v21 forKeys:&v20 count:1];
    id v9 = +[NSError errorWithDomain:v7 code:2 userInfo:v8];

    uint64_t v10 = +[IDSFoundationLog IDSOffGridMessenger];
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = a1[4];
      uint64_t v12 = a1[5];
      uint64_t v13 = a1[6];
      int v14 = 138412802;
      uint64_t v15 = v11;
      __int16 v16 = 2112;
      uint64_t v17 = v12;
      __int16 v18 = 2112;
      uint64_t v19 = v13;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Failed to save client donated handles {destinationURIs: %@, fromURI: %@, options: %@}", (uint8_t *)&v14, 0x20u);
    }

    (*(void (**)(void))(a1[7] + 16))();
  }
}

id sub_1002D12B0(id a1, IDSURI *a2)
{
  return [(IDSURI *)a2 tokenFreeURI];
}

void sub_1002D12B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, void *a9)
{
  id v11 = a9;
  uint64_t v12 = +[IDSFoundationLog IDSOffGridMessenger];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v13 = @"NO";
    if (a6) {
      CFStringRef v13 = @"YES";
    }
    *(_DWORD *)buf = 138412546;
    CFStringRef v41 = v13;
    __int16 v42 = 2112;
    id v43 = v11;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Received query result with success {%@} and result {%@}", buf, 0x16u);
  }

  if (a6)
  {
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    id obj = *(id *)(a1 + 40);
    id v14 = [obj countByEnumeratingWithState:&v33 objects:v37 count:16];
    if (v14)
    {
      id v16 = v14;
      uint64_t v17 = *(void *)v34;
      *(void *)&long long v15 = 138412290;
      long long v31 = v15;
      do
      {
        for (i = 0; i != v16; i = (char *)i + 1)
        {
          if (*(void *)v34 != v17) {
            objc_enumerationMutation(obj);
          }
          uint64_t v19 = *(void **)(*((void *)&v33 + 1) + 8 * i);
          objc_msgSend(v19, "tokenFreeURI", v31);
          NSErrorUserInfoKey v20 = (__CFString *)objc_claimAutoreleasedReturnValue();
          CFStringRef v21 = [v11 objectForKeyedSubscript:v20];
          uint64_t v22 = [v21 firstObject];
          uint64_t v23 = [v22 shortHandle];

          unsigned int v24 = [*(id *)(a1 + 32) objectForKey:v19];
          v25 = v24;
          if (v24)
          {
            if (v23)
            {
              [v24 setShortHandle:v23];
              uint64_t v26 = 1;
            }
            else
            {
              uint64_t v27 = +[IDSFoundationLog IDSOffGridMessenger];
              if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = v31;
                CFStringRef v41 = v20;
                _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Missing short handle for %@ - returning status invalid", buf, 0xCu);
              }

              uint64_t v26 = 2;
            }
            [v25 setStatus:v26];
            [*(id *)(a1 + 32) setObject:v25 forKey:v19];
          }
        }
        id v16 = [obj countByEnumeratingWithState:&v33 objects:v37 count:16];
      }
      while (v16);
    }

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  else
  {
    uint64_t v28 = IDSOffGridDeliveryErrorDomain;
    NSErrorUserInfoKey v38 = NSLocalizedDescriptionKey;
    CFStringRef v39 = @"Failed to query due to unsuccessful request";
    long long v29 = +[NSDictionary dictionaryWithObjects:&v39 forKeys:&v38 count:1];
    long long v30 = +[NSError errorWithDomain:v28 code:6 userInfo:v29];

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
}

void sub_1002D2048(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [*(id *)(a1 + 32) senderURI];
  uint64_t v5 = [v3 objectForKey:v4];

  uint64_t v6 = +[IDSFoundationLog IDSOffGridMessenger];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = [*(id *)(a1 + 32) senderURI];
    *(_DWORD *)buf = 138412546;
    v58 = v7;
    __int16 v59 = 2112;
    v60 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Sender URI %@ has result %@", buf, 0x16u);
  }
  if (!v5 || [v5 status] != (id)1)
  {
    uint64_t v19 = [*(id *)(a1 + 32) senderURI];
    NSErrorUserInfoKey v20 = [v19 prefixedURI];
    id v11 = +[NSString stringWithFormat:@"Failed to query for sender handle %@.", v20];

    uint64_t v21 = *(void *)(a1 + 48);
    id v22 = objc_alloc((Class)NSError);
    uint64_t v23 = IDSOffGridDeliveryErrorDomain;
    NSErrorUserInfoKey v55 = NSLocalizedDescriptionKey;
    v56 = v11;
    __int16 v18 = +[NSDictionary dictionaryWithObjects:&v56 forKeys:&v55 count:1];
    unsigned int v24 = v22;
    uint64_t v25 = v23;
    uint64_t v26 = 7;
LABEL_13:
    id v27 = [v24 initWithDomain:v25 code:v26 userInfo:v18];
    (*(void (**)(uint64_t, void, void, id))(v21 + 16))(v21, 0, 0, v27);

    goto LABEL_14;
  }
  id v8 = [v5 shortHandle];

  if (!v8)
  {
    NSErrorUserInfoKey v38 = [*(id *)(a1 + 32) senderURI];
    CFStringRef v39 = [v38 prefixedURI];
    id v11 = +[NSString stringWithFormat:@"No short handle for sender handle %@.", v39];

    uint64_t v21 = *(void *)(a1 + 48);
    id v40 = objc_alloc((Class)NSError);
    uint64_t v41 = IDSOffGridDeliveryErrorDomain;
    NSErrorUserInfoKey v53 = NSLocalizedDescriptionKey;
    v54 = v11;
    __int16 v18 = +[NSDictionary dictionaryWithObjects:&v54 forKeys:&v53 count:1];
    unsigned int v24 = v40;
    uint64_t v25 = v41;
    uint64_t v26 = 9;
    goto LABEL_13;
  }
  id v9 = [v5 shortHandle];
  [*(id *)(a1 + 32) setSenderShortHandle:v9];

  uint64_t v10 = [*(id *)(a1 + 32) recipientURI];
  id v11 = [v3 objectForKey:v10];

  uint64_t v12 = +[IDSFoundationLog IDSOffGridMessenger];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v13 = [*(id *)(a1 + 32) recipientURI];
    *(_DWORD *)buf = 138412546;
    v58 = v13;
    __int16 v59 = 2112;
    v60 = v11;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Recipient URI %@ has result %@", buf, 0x16u);
  }
  if (!v11 || [v11 status] != (id)1)
  {
    uint64_t v28 = [*(id *)(a1 + 32) recipientURI];
    long long v29 = [v28 prefixedURI];
    __int16 v18 = +[NSString stringWithFormat:@"Failed to query for recipient handle %@.", v29];

    uint64_t v30 = *(void *)(a1 + 48);
    id v31 = objc_alloc((Class)NSError);
    uint64_t v32 = IDSOffGridDeliveryErrorDomain;
    NSErrorUserInfoKey v51 = NSLocalizedDescriptionKey;
    v52 = v18;
    long long v33 = +[NSDictionary dictionaryWithObjects:&v52 forKeys:&v51 count:1];
    long long v34 = v31;
    uint64_t v35 = v32;
    uint64_t v36 = 8;
LABEL_16:
    id v37 = [v34 initWithDomain:v35 code:v36 userInfo:v33];
    (*(void (**)(uint64_t, void, void, id))(v30 + 16))(v30, 0, 0, v37);

    goto LABEL_14;
  }
  id v14 = [v11 shortHandle];

  if (!v14)
  {
    __int16 v42 = [*(id *)(a1 + 32) recipientURI];
    id v43 = [v42 prefixedURI];
    __int16 v18 = +[NSString stringWithFormat:@"No short handle for recipient handle %@.", v43];

    uint64_t v30 = *(void *)(a1 + 48);
    id v44 = objc_alloc((Class)NSError);
    uint64_t v45 = IDSOffGridDeliveryErrorDomain;
    NSErrorUserInfoKey v49 = NSLocalizedDescriptionKey;
    v50 = v18;
    long long v33 = +[NSDictionary dictionaryWithObjects:&v50 forKeys:&v49 count:1];
    long long v34 = v44;
    uint64_t v35 = v45;
    uint64_t v36 = 9;
    goto LABEL_16;
  }
  long long v15 = [v11 shortHandle];
  [*(id *)(a1 + 32) setRecipientShortHandle:v15];

  uint64_t v16 = *(void *)(a1 + 32);
  uint64_t v17 = *(void **)(*(void *)(a1 + 40) + 8);
  v46[0] = _NSConcreteStackBlock;
  v46[1] = 3221225472;
  v46[2] = sub_1002D2620;
  v46[3] = &unk_100988078;
  id v48 = *(id *)(a1 + 48);
  id v47 = *(id *)(a1 + 32);
  [v17 sendOffGridMessage:v16 completion:v46];

  __int16 v18 = v48;
LABEL_14:
}

void sub_1002D2620(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  if (!v5 && (a2 & 1) == 0)
  {
    uint64_t v6 = +[NSString stringWithFormat:@"OffGrid message send resulted in an unknown error."];
    id v7 = objc_alloc((Class)NSError);
    uint64_t v8 = IDSOffGridDeliveryErrorDomain;
    NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
    long long v15 = v6;
    id v9 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
    id v5 = [v7 initWithDomain:v8 code:12 userInfo:v9];
  }
  uint64_t v12 = a1 + 32;
  uint64_t v10 = *(void **)(a1 + 32);
  uint64_t v11 = *(void *)(v12 + 8);
  CFStringRef v13 = [v10 identifier];
  (*(void (**)(uint64_t, void *, void *, id))(v11 + 16))(v11, v10, v13, v5);
}

void sub_1002D2968(uint64_t a1, void *a2)
{
  id v3 = a2;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  id v4 = *(id *)(a1 + 32);
  id v5 = [v4 countByEnumeratingWithState:&v21 objects:v27 count:16];
  if (v5)
  {
    id v7 = v5;
    uint64_t v8 = *(void *)v22;
    *(void *)&long long v6 = 138412290;
    long long v17 = v6;
    do
    {
      for (i = 0; i != v7; i = (char *)i + 1)
      {
        if (*(void *)v22 != v8) {
          objc_enumerationMutation(v4);
        }
        uint64_t v10 = *(void *)(*((void *)&v21 + 1) + 8 * i);
        uint64_t v11 = objc_msgSend(v3, "objectForKey:", v10, v17);
        uint64_t v12 = v11;
        if (v11 && [v11 status] == (id)1)
        {
          CFStringRef v13 = *(void **)(a1 + 40);
          NSErrorUserInfoKey v14 = [v12 shortHandle];
          [v13 addObject:v14];
        }
        else
        {
          NSErrorUserInfoKey v14 = +[IDSFoundationLog IDSOffGridMessenger];
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = v17;
            uint64_t v26 = v10;
            _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "FetchRequest: Could not find short handle for %@", buf, 0xCu);
          }
        }
      }
      id v7 = [v4 countByEnumeratingWithState:&v21 objects:v27 count:16];
    }
    while (v7);
  }

  uint64_t v15 = *(void *)(a1 + 40);
  uint64_t v16 = *(void **)(*(void *)(a1 + 48) + 8);
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472;
  v18[2] = sub_1002D2BAC;
  v18[3] = &unk_100988078;
  id v20 = *(id *)(a1 + 56);
  id v19 = *(id *)(a1 + 32);
  [v16 sendFetchRequestForHandles:v15 completion:v18];
}

uint64_t sub_1002D2BAC(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

uint64_t sub_1002D4100(uint64_t a1)
{
  if (*(unsigned char *)(*(void *)(a1 + 32) + 57))
  {
    id v2 = [objc_alloc((Class)CBPeripheralManager) initWithDelegate:*(void *)(a1 + 32) queue:*(void *)(*(void *)(a1 + 32) + 88)];
    uint64_t v3 = *(void *)(a1 + 32);
    id v4 = *(void **)(v3 + 16);
    *(void *)(v3 + 16) = v2;
  }
  else
  {
    id v5 = [objc_alloc((Class)CBCentralManager) initWithDelegate:*(void *)(a1 + 32) queue:*(void *)(*(void *)(a1 + 32) + 88)];
    uint64_t v6 = *(void *)(a1 + 32);
    id v4 = *(void **)(v6 + 8);
    *(void *)(v6 + 8) = v5;
  }

  id v7 = [objc_alloc((Class)CBScalablePipeManager) initWithDelegate:*(void *)(a1 + 32) queue:*(void *)(*(void *)(a1 + 32) + 88)];
  uint64_t v8 = *(void *)(a1 + 32);
  uint64_t v9 = *(void *)(v8 + 24);
  *(void *)(v8 + 24) = v7;

  return _objc_release_x1(v7, v9);
}

id sub_1002D4224(uint64_t a1)
{
  id v2 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    CFStringRef v17 = @"com.apple.ids";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Unregister endpoint identifier: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      CFStringRef v15 = @"com.apple.ids";
      _IDSLogTransport();
      if (_IDSShouldLog())
      {
        CFStringRef v15 = @"com.apple.ids";
        _IDSLogV();
      }
    }
  }
  uint64_t v3 = a1 + 32;
  objc_msgSend(*(id *)(*(void *)(a1 + 32) + 24), "unregisterEndpoint:", @"com.apple.ids", v15);
  id v4 = *(void **)(*(void *)(a1 + 32) + 24);
  *(void *)(*(void *)v3 + 24) = 0;

  id v5 = *(void **)(*(void *)(a1 + 32) + 32);
  *(void *)(*(void *)v3 + 32) = 0;

  uint64_t v6 = *(id **)(a1 + 32);
  if (*((unsigned char *)v6 + 57))
  {
    id v7 = [v6 nanoRegistryPluginManager];
    [v7 notifyWatchDidStopAdvertisingWithPeripheralManager:*(void *)(*(void *)(a1 + 32) + 16)];

    uint64_t v8 = (id *)(*(void *)(a1 + 32) + 16);
    uint64_t v9 = 16;
  }
  else
  {
    uint64_t v8 = v6 + 1;
    uint64_t v9 = 8;
  }
  [*v8 setDelegate:0];
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void **)(v10 + v9);
  *(void *)(v10 + v9) = 0;

  [*(id *)(*(void *)(a1 + 32) + 40) removeAllObjects];
  if (![*(id *)(*(void *)(a1 + 32) + 40) count])
  {
    uint64_t v12 = *(void *)(a1 + 32);
    CFStringRef v13 = *(void **)(v12 + 40);
    *(void *)(v12 + 40) = 0;
  }
  [*(id *)(*(void *)(a1 + 32) + 64) removeAllObjects];
  return [*(id *)(*(void *)(a1 + 32) + 112) removeAllObjects];
}

id sub_1002D44BC(uint64_t a1)
{
  return [*(id *)(a1 + 32) _connectNow];
}

id sub_1002D4588(void *a1)
{
  id v2 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = a1[5];
    *(_DWORD *)buf = 138412546;
    uint64_t v7 = v3;
    __int16 v8 = 2112;
    uint64_t v9 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "removing a link %@ with linkID %@", buf, 0x16u);
  }

  id result = (id)os_log_shim_legacy_logging_enabled();
  if (result)
  {
    id result = (id)_IDSShouldLogTransport();
    if (result)
    {
      _IDSLogTransport();
      id result = (id)_IDSShouldLog();
      if (result) {
        id result = (id)_IDSLogV();
      }
    }
  }
  if (a1[5]) {
    return objc_msgSend(*(id *)(a1[6] + 64), "removeObjectForKey:");
  }
  return result;
}

void sub_1002D4778(uint64_t a1)
{
  uint64_t v1 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    id v2 = *(IDSBTLink **)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    v46 = v2;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "update paired device UUID to %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      uint64_t v34 = *(void *)(a1 + 32);
      _IDSLogTransport();
      if (_IDSShouldLog())
      {
        uint64_t v34 = *(void *)(a1 + 32);
        _IDSLogV();
      }
    }
  }
  uint64_t v3 = *(void *)(a1 + 40);
  if (!*(unsigned char *)(v3 + 57))
  {
    if (*(unsigned char *)(v3 + 80))
    {
      [*(id *)(v3 + 8) cancelPeripheralConnection:*(void *)(v3 + 32)];
      *(unsigned char *)(*(void *)(a1 + 40) + 80) = 0;
      uint64_t v3 = *(void *)(a1 + 40);
    }
    uint64_t v4 = *(void **)(v3 + 32);
    *(void *)(v3 + 32) = 0;

    uint64_t v3 = *(void *)(a1 + 40);
  }
  objc_msgSend(*(id *)(v3 + 64), "removeAllObjects", v34);
  [*(id *)(*(void *)(a1 + 40) + 112) removeAllObjects];
  NSErrorUserInfoKey v38 = (IDSBTLink *)[*(id *)(*(void *)(a1 + 40) + 48) copy];
  id v5 = [*(id *)(a1 + 32) copy];
  uint64_t v6 = *(void **)(*(void *)(a1 + 40) + 48);
  *(void *)(*(void *)(a1 + 40) + 48) = v5;

  IMSetDomainValueForKey();
  uint64_t v7 = *(void **)(a1 + 32);
  if (v7 && ([v7 isEqualToString:@"LOCAL-SETUP-STARTED"] & 1) == 0)
  {
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    id obj = *(id *)(*(void *)(a1 + 40) + 40);
    id v8 = [obj countByEnumeratingWithState:&v41 objects:v49 count:16];
    if (v8)
    {
      uint64_t v9 = *(void *)v42;
      while (2)
      {
        for (i = 0; i != v8; i = (char *)i + 1)
        {
          if (*(void *)v42 != v9) {
            objc_enumerationMutation(obj);
          }
          uint64_t v11 = *(void **)(*((void *)&v41 + 1) + 8 * i);
          uint64_t v12 = objc_msgSend(v11, "peer", v35);
          CFStringRef v13 = [v12 identifier];
          NSErrorUserInfoKey v14 = [v13 UUIDString];

          CFStringRef v15 = OSLogHandleForTransportCategory();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412290;
            v46 = v14;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "processing pending pipe %@", buf, 0xCu);
          }

          if (os_log_shim_legacy_logging_enabled())
          {
            if (_IDSShouldLogTransport())
            {
              uint64_t v36 = v14;
              _IDSLogTransport();
              if (_IDSShouldLog())
              {
                uint64_t v36 = v14;
                _IDSLogV();
              }
            }
          }
          if (objc_msgSend(*(id *)(a1 + 32), "isEqualToString:", v14, v36))
          {
            __int16 v18 = OSLogHandleForTransportCategory();
            if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138412290;
              v46 = v14;
              _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "pending pipe %@ matches to paired device", buf, 0xCu);
            }

            if (os_log_shim_legacy_logging_enabled())
            {
              if (_IDSShouldLogTransport())
              {
                uint64_t v35 = v14;
                _IDSLogTransport();
                if (_IDSShouldLog())
                {
                  uint64_t v35 = v14;
                  _IDSLogV();
                }
              }
            }
            id v19 = [[IDSBTLink alloc] initWithPipe:v11 useSkywalkChannel:*(unsigned __int8 *)(*(void *)(a1 + 40) + 58) withDeviceUniqueID:0 cbuuid:v14];
            id v20 = OSLogHandleForIDSCategory();
            if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138412290;
              v46 = v19;
              _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "BTLink %@ created", buf, 0xCu);
            }

            if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
            {
              uint64_t v35 = v19;
              _IDSLogV();
            }
            if (v19)
            {
              [*(id *)(*(void *)(a1 + 40) + 64) setObject:v19 forKey:v14];
              long long v21 = OSLogHandleForTransportCategory();
              if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 138412290;
                v46 = v19;
                _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "linkDidConnect:%@", buf, 0xCu);
              }

              if (os_log_shim_legacy_logging_enabled())
              {
                if (_IDSShouldLogTransport())
                {
                  uint64_t v35 = v19;
                  _IDSLogTransport();
                  if (_IDSShouldLog())
                  {
                    uint64_t v35 = v19;
                    _IDSLogV();
                  }
                }
              }
              id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 40) + 96));
              [WeakRetained manager:*(void *)(a1 + 40) linkDidConnect:v19];
            }
            else
            {
              long long v23 = OSLogHandleForTransportCategory();
              if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 138412290;
                v46 = v14;
                _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "could not create a BTLink for %@", buf, 0xCu);
              }

              if (os_log_shim_legacy_logging_enabled())
              {
                if (_IDSShouldLogTransport())
                {
                  uint64_t v35 = v14;
                  _IDSLogTransport();
                  if (_IDSShouldLog())
                  {
                    uint64_t v35 = v14;
                    _IDSLogV();
                  }
                }
              }
            }

            int v17 = 0;
            goto LABEL_60;
          }
          uint64_t v16 = OSLogHandleForTransportCategory();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412290;
            v46 = v14;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "pending pipe %@ doesn't match to paired device - releasing it", buf, 0xCu);
          }

          if (os_log_shim_legacy_logging_enabled())
          {
            if (_IDSShouldLogTransport())
            {
              uint64_t v35 = v14;
              _IDSLogTransport();
              if (_IDSShouldLog())
              {
                uint64_t v35 = v14;
                _IDSLogV();
              }
            }
          }
        }
        id v8 = [obj countByEnumeratingWithState:&v41 objects:v49 count:16];
        if (v8) {
          continue;
        }
        break;
      }
    }
    int v17 = 1;
LABEL_60:

    unsigned int v24 = [(IDSBTLink *)v38 isEqualToString:@"LOCAL-SETUP-STARTED"];
    [*(id *)(*(void *)(a1 + 40) + 40) removeAllObjects];
    if (![*(id *)(*(void *)(a1 + 40) + 40) count])
    {
      uint64_t v25 = *(void *)(a1 + 40);
      uint64_t v26 = *(void **)(v25 + 40);
      *(void *)(v25 + 40) = 0;
    }
    id v27 = *(unsigned char **)(a1 + 40);
    if ((v17 & (v24 ^ 1)) != 0 && !v27[57])
    {
      uint64_t v28 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v29 = *(void *)(a1 + 32);
        *(_DWORD *)buf = 138412546;
        v46 = v38;
        __int16 v47 = 2112;
        uint64_t v48 = v29;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Change paired device from %@ to %@.", buf, 0x16u);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLogTransport())
        {
          uint64_t v35 = v38;
          uint64_t v37 = *(void *)(a1 + 32);
          _IDSLogTransport();
          if (_IDSShouldLog())
          {
            uint64_t v35 = v38;
            uint64_t v37 = *(void *)(a1 + 32);
            _IDSLogV();
          }
        }
      }
      *(unsigned char *)(*(void *)(a1 + 40) + 56) = 0;
      *(unsigned char *)(*(void *)(a1 + 40) + 81) = 0;
      id v30 = objc_loadWeakRetained((id *)(*(void *)(a1 + 40) + 96));
      char v31 = objc_opt_respondsToSelector();

      if (v31)
      {
        id v32 = objc_loadWeakRetained((id *)(*(void *)(a1 + 40) + 96));
        [v32 manager:*(void *)(a1 + 40) didPairedDeviceChange:1];
      }
      objc_msgSend(*(id *)(a1 + 40), "obliterateConnectionInfo", v35, v37);
      [*(id *)(a1 + 40) stop];
      [*(id *)(a1 + 40) start];
      id v27 = *(unsigned char **)(a1 + 40);
    }
    if (!v27[57] && !v27[80] && v27[56])
    {
      long long v33 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "Pipe is registered but not connecting, connect now.", buf, 2u);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLogTransport())
        {
          _IDSLogTransport();
          if (_IDSShouldLog()) {
            _IDSLogV();
          }
        }
      }
      objc_msgSend(*(id *)(a1 + 40), "_connectNow", v35);
    }
  }
}

void sub_1002D52F8(uint64_t a1)
{
  id v2 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "obliterateConnectionInfo called", v7, 2u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      _IDSLogTransport();
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
  }
  uint64_t v3 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v3 + 57))
  {
    if (*(unsigned char *)(v3 + 80))
    {
      [*(id *)(v3 + 8) cancelPeripheralConnection:*(void *)(v3 + 32)];
      *(unsigned char *)(*(void *)(a1 + 32) + 80) = 0;
      uint64_t v3 = *(void *)(a1 + 32);
    }
    uint64_t v4 = *(void **)(v3 + 32);
    *(void *)(v3 + 32) = 0;

    uint64_t v3 = *(void *)(a1 + 32);
  }
  [*(id *)(v3 + 64) removeAllObjects];
  [*(id *)(*(void *)(a1 + 32) + 112) removeAllObjects];
  IMSetDomainValueForKey();
  [*(id *)(*(void *)(a1 + 32) + 40) removeAllObjects];
  if (![*(id *)(*(void *)(a1 + 32) + 40) count])
  {
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = *(void **)(v5 + 40);
    *(void *)(v5 + 40) = 0;
  }
}

void sub_1002D5510(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(void *)(v1 + 24))
  {
    uint64_t v3 = *(void **)(v1 + 48);
    if (v3)
    {
      if (([v3 isEqualToString:@"LOCAL-SETUP-STARTED"] & 1) == 0)
      {
        uint64_t v4 = +[IDSLinkPreferencesManager sharedInstance];
        uint64_t v5 = [v4 accumulativePreferencesForAllServices];

        uint64_t v6 = [v5 objectForKey:@"PacketsPerSecond"];
        uint64_t v7 = [v5 objectForKey:@"InputBytesPerSecond"];
        long long v21 = [v5 objectForKey:@"OutputBytesPerSecond"];
        id v8 = [v5 objectForKey:@"Intent"];
        if ([v8 isEqualToString:@"forceBTClassic"]
          && [v6 unsignedIntValue] <= 0xC7)
        {

          uint64_t v6 = &off_1009D1CB0;
        }
        id v9 = [objc_alloc((Class)NSUUID) initWithUUIDString:*(void *)(*(void *)(a1 + 32) + 48)];
        if (v9)
        {
          uint64_t v10 = OSLogHandleForTransportCategory();
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v11 = *(void *)(a1 + 40);
            *(_DWORD *)buf = 138544386;
            uint64_t v23 = v11;
            __int16 v24 = 1024;
            unsigned int v25 = [v6 unsignedIntValue];
            __int16 v26 = 1024;
            unsigned int v27 = [v7 unsignedIntValue];
            __int16 v28 = 1024;
            unsigned int v29 = [v21 unsignedIntValue];
            __int16 v30 = 2114;
            char v31 = v8;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "setLinkRequirementsForPeer: service: %{public}@, pps: %d input bps: %d output bps: %d intent: %{public}@", buf, 0x28u);
          }

          if (os_log_shim_legacy_logging_enabled())
          {
            if (_IDSShouldLogTransport())
            {
              uint64_t v12 = *(void *)(a1 + 40);
              id v13 = [v6 unsignedIntValue];
              id v14 = [v7 unsignedIntValue];
              id v20 = [v21 unsignedIntValue];
              _IDSLogTransport();
              if (_IDSShouldLog())
              {
                objc_msgSend(v6, "unsignedIntValue", v12, v13, v14, v20, v8);
                [v7 unsignedIntValue];
                [v21 unsignedIntValue];
                _IDSLogV();
              }
            }
          }
          CFStringRef v15 = &stru_10099BE78;
          if (*(void *)(a1 + 40)) {
            CFStringRef v15 = *(__CFString **)(a1 + 40);
          }
          uint64_t v16 = *(void **)(*(void *)(a1 + 32) + 24);
          int v17 = v15;
          objc_msgSend(v16, "setLinkRequirementsForPeer:withClientName:packetsPerSecond:inputBytesPerSecond:outputBytesPerSecond:", v9, v17, objc_msgSend(v6, "unsignedIntValue"), objc_msgSend(v7, "unsignedIntValue"), objc_msgSend(v21, "unsignedIntValue"));
        }
        else
        {
          __int16 v18 = OSLogHandleForTransportCategory();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v19 = *(void *)(*(void *)(a1 + 32) + 48);
            *(_DWORD *)buf = 138412290;
            uint64_t v23 = v19;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "setLinkRequirementsForPeer failed due to invalid pipe identifier:%@.", buf, 0xCu);
          }

          if (os_log_shim_legacy_logging_enabled())
          {
            if (_IDSShouldLogTransport())
            {
              _IDSLogTransport();
              if (_IDSShouldLog()) {
                _IDSLogV();
              }
            }
          }
        }
      }
    }
  }
}

void sub_1002D59E8(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  id v2 = [@"com.apple.ids.datagram" stringByAppendingFormat:@".%@", @"default"];
  [v1 startDatagramLinkWithEndpointIdentifier:v2];
}

void sub_1002D5ACC(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  id v2 = [@"com.apple.ids.datagram" stringByAppendingFormat:@".%@", @"default"];
  [v1 stopDatagramLinkWithEndpointIdentifier:v2];
}

void sub_1002D5BD4(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  id v2 = [@"com.apple.ids.datagram" stringByAppendingFormat:@".%@", *(void *)(a1 + 40)];
  [v1 startDatagramLinkWithEndpointIdentifier:v2];
}

void sub_1002D5CD4(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  id v2 = [@"com.apple.ids.datagram" stringByAppendingFormat:@".%@", *(void *)(a1 + 40)];
  [v1 stopDatagramLinkWithEndpointIdentifier:v2];
}

BOOL sub_1002DA728()
{
  v0 = +[IDSPairingManager sharedInstance];
  uint64_t v1 = [v0 pairedDeviceProductVersion];

  [v1 floatValue];
  BOOL v3 = v2 >= 11.0 && v2 > 0.0;

  return v3;
}

void sub_1002DB408(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1002DB438(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v2 = WeakRetained;
    [WeakRetained _annouceAvailabilityForCloudMessaging];
    id WeakRetained = v2;
  }
}

uint64_t sub_1002DC27C(uint64_t a1)
{
  uint64_t result = 0;
  if (a1 <= 500)
  {
    if (a1 <= 200)
    {
      if (a1 > 109)
      {
        switch(a1)
        {
          case 110:
            return 3;
          case 120:
            return 4;
          case 200:
            return 5;
        }
      }
      else
      {
        switch(a1)
        {
          case 0:
            return result;
          case 100:
            return 1;
          case 101:
            return 2;
        }
      }
    }
    else if (a1 <= 299)
    {
      switch(a1)
      {
        case 201:
          return 6;
        case 202:
          return 14;
        case 250:
          return 7;
      }
    }
    else if (a1 > 399)
    {
      if (a1 == 400) {
        return 10;
      }
      if (a1 == 500) {
        return 11;
      }
    }
    else
    {
      if (a1 == 300) {
        return 8;
      }
      if (a1 == 301) {
        return 9;
      }
    }
    goto LABEL_34;
  }
  if (a1 <= 799)
  {
    switch(a1)
    {
      case 501:
        return result;
      case 600:
        return 12;
      case 601:
        return 13;
    }
LABEL_34:
    BOOL v3 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      int v5 = a1;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "IDSEncryptionErrorType unknown/unhandled error type: %d", buf, 8u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      _IDSLogTransport();
    }
    return a1;
  }
  switch(a1)
  {
    case 800:
      uint64_t result = 15;
      break;
    case 801:
      uint64_t result = 16;
      break;
    case 802:
      uint64_t result = 17;
      break;
    case 803:
      uint64_t result = 18;
      break;
    case 804:
      uint64_t result = 19;
      break;
    default:
      switch(a1)
      {
        case 900:
          uint64_t result = 21;
          break;
        case 901:
          uint64_t result = 20;
          break;
        case 902:
          uint64_t result = 23;
          break;
        case 903:
          uint64_t result = 22;
          break;
        default:
          goto LABEL_34;
      }
      break;
  }
  return result;
}

uint64_t sub_1002DC598(void *a1)
{
  id v1 = a1;
  id v2 = v1;
  if (!v1)
  {
LABEL_8:
    uint64_t v6 = 0;
    goto LABEL_9;
  }
  BOOL v3 = [v1 domain];
  unsigned __int8 v4 = [v3 isEqualToString:IDSEncryptionErrorDomain];

  if ((v4 & 1) == 0)
  {
    uint64_t v7 = +[IDSFoundationLog encryptionController];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      sub_10071DE54((uint64_t)v2, v7);
    }

    goto LABEL_8;
  }
  int v5 = (char *)[v2 code];
  if ((unint64_t)(v5 - 2) > 0x14) {
    uint64_t v6 = 600;
  }
  else {
    uint64_t v6 = qword_1007948F0[(void)(v5 - 2)];
  }
LABEL_9:

  return v6;
}

uint64_t sub_1002DC660(void *a1)
{
  id v1 = a1;
  id v2 = v1;
  if (!v1)
  {
LABEL_12:
    uint64_t v6 = 0;
    goto LABEL_13;
  }
  BOOL v3 = [v1 domain];
  unsigned __int8 v4 = [v3 isEqualToString:IDSDecryptionErrorDomain];

  if ((v4 & 1) == 0)
  {
    uint64_t v7 = +[IDSFoundationLog encryptionController];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      sub_10071DE54((uint64_t)v2, v7);
    }

    goto LABEL_12;
  }
  uint64_t v5 = (uint64_t)[v2 code];
  uint64_t v6 = 200;
  if (v5 <= 14)
  {
    if (v5 != 2)
    {
      if (v5 != 5) {
        goto LABEL_13;
      }
LABEL_16:
      uint64_t v6 = 202;
      goto LABEL_13;
    }
    id v13 = [v2 userInfo];
    uint64_t v10 = [v13 objectForKeyedSubscript:NSUnderlyingErrorKey];

    if (v10)
    {
      id v14 = [v10 domain];
      if ([v14 isEqualToString:IDSPeerIDManagerErrorDomain])
      {
        if ([v10 code] == (id)3)
        {

LABEL_30:
          uint64_t v6 = 202;
          goto LABEL_32;
        }
        id v15 = [v10 code];

        if (v15 == (id)4) {
          goto LABEL_30;
        }
      }
      else
      {
      }
    }
    uint64_t v6 = 601;
    goto LABEL_32;
  }
  switch(v5)
  {
    case 15:
      id v9 = [v2 userInfo];
      uint64_t v10 = [v9 objectForKeyedSubscript:NSUnderlyingErrorKey];

      if (v10)
      {
        uint64_t v11 = [v10 domain];
        if ([v11 isEqualToString:@"com.apple.messageprotection"])
        {
          id v12 = [v10 code];

          if (v12 == (id)5) {
            uint64_t v6 = 202;
          }
          else {
            uint64_t v6 = 200;
          }
          goto LABEL_32;
        }
      }
      uint64_t v6 = 200;
LABEL_32:

      break;
    case 17:
      goto LABEL_16;
    case 18:
      uint64_t v6 = 901;
      break;
  }
LABEL_13:

  return v6;
}

uint64_t sub_1002DC868(void *a1)
{
  id v1 = a1;
  if ([v1 isEqualToString:IDSNGMDeviceIdentityIdentifier])
  {
    uint64_t v2 = 4;
  }
  else if ([v1 isEqualToString:IDSSecondaryIdentityIdentifier])
  {
    uint64_t v2 = 5;
  }
  else
  {
    uint64_t v2 = 1;
  }

  return v2;
}

void sub_1002DC924(id a1)
{
  id v1 = objc_alloc_init(IDSEncryptionController);
  uint64_t v2 = qword_100A4C578;
  qword_100A4C578 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

id sub_1002DD0D0(unint64_t a1)
{
  if (a1 > 3)
  {
    id v2 = 0;
  }
  else
  {
    id v2 = *(id *)*(&off_100988250 + a1);
  }
  return v2;
}

void sub_1002DD26C(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = *(void **)(a1 + 32);
  uint64_t v8 = *(void *)(a1 + 40);
  id v10 = a5;
  id v11 = a4;
  id v12 = a3;
  id v13 = a2;
  id v14 = [v9 pushToken];
  (*(void (**)(uint64_t, id, BOOL, id, id, id, id))(v8 + 16))(v8, v14, v13 != 0, v13, v12, v11, v10);
}

uint64_t sub_1002DD4CC(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, void, BOOL))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), a2 != 0);
}

uint64_t sub_1002DD698(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, void, BOOL))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), a2 != 0);
}

void sub_1002DD8A8(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = *(void **)(a1 + 32);
  uint64_t v8 = *(void *)(a1 + 40);
  id v10 = a5;
  id v11 = a4;
  id v12 = a3;
  id v13 = a2;
  id v15 = [v9 sendingPushToken];
  id v14 = [v15 rawToken];
  (*(void (**)(uint64_t, void *, BOOL, id, id, id, id))(v8 + 16))(v8, v14, v13 != 0, v13, v12, v11, v10);
}

uint64_t sub_1002DDAA0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void, void, BOOL, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), 0, a2 != 0, a2, a3, a4);
}

uint64_t sub_1002DDCCC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void, void, BOOL, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 32)
                                                                                             + 16))(*(void *)(a1 + 32), 0, a2 != 0, a2, a3, a4, a5);
}

void sub_1002DE694(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1002DE6AC(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 32) + 32) fullDeviceIdentityContainer];
  BOOL v3 = +[IDSPeerIDManager sharedInstance];
  unsigned __int8 v4 = [v3 endpointForPushToken:*(void *)(a1 + 40) URI:*(void *)(a1 + 48) service:*(void *)(a1 + 56) fromURI:*(void *)(a1 + 64)];

  uint64_t v5 = [v4 publicDeviceIdentityContainer];
  if (!v4)
  {
    uint64_t v6 = +[IDSPublicIdentityCache sharedInstance];
    uint64_t v7 = [*(id *)(a1 + 40) rawToken];
    uint64_t v8 = *(void *)(a1 + 48);
    uint64_t v9 = *(void *)(a1 + 56);
    id v22 = 0;
    uint64_t v10 = [v6 identityForToken:v7 uri:v8 service:v9 error:&v22];
    id v11 = v22;

    uint64_t v5 = (void *)v10;
  }
  if (v2) {
    BOOL v12 = v5 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (!v12)
  {
    id v13 = +[IDSFoundationLog encryptionController];
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = *(void *)(a1 + 64);
      uint64_t v15 = *(void *)(a1 + 72);
      uint64_t v17 = *(void *)(a1 + 40);
      uint64_t v16 = *(void *)(a1 + 48);
      *(_DWORD *)buf = 138413571;
      uint64_t v24 = v14;
      __int16 v25 = 2112;
      uint64_t v26 = v15;
      __int16 v27 = 2113;
      __int16 v28 = v2;
      __int16 v29 = 2112;
      uint64_t v30 = v16;
      __int16 v31 = 2112;
      uint64_t v32 = v17;
      __int16 v33 = 2113;
      uint64_t v34 = v5;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Calling into markForStateReset with ourURI: %@, ourPushToken: %@, ourSigningIdentity: %{private}@, theirURI: %@, theirPushToken: %@, theirPublicDeviceIdentity: %{private}@", buf, 0x3Eu);
    }

    __int16 v18 = [*(id *)(a1 + 64) prefixedURI];
    uint64_t v19 = [*(id *)(a1 + 72) rawToken];
    id v20 = [*(id *)(a1 + 48) prefixedURI];
    long long v21 = [*(id *)(a1 + 40) rawToken];
    *(unsigned char *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) = [v5 markForStateResetWithOurURI:v18 ourPushToken:v19 ourSigningIdentity:v2 theirURI:v20 theirPushToken:v21];
  }
}

uint64_t sub_1002DEA0C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_1002DEB6C(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  uint64_t v9 = *(void *)(a1 + 40);
  id v10 = a5;
  id v11 = a4;
  id v12 = a3;
  id v13 = a2;
  uint64_t v14 = [IDSDecryptionMetadata alloc];
  unint64_t v15 = *(void *)(a1 + 48);
  if (v15 > 3) {
    uint64_t v16 = 2;
  }
  else {
    uint64_t v16 = qword_100794998[v15];
  }
  id v17 = [v10 usedLastResortCache];
  id v18 = [v10 usedCachedData];

  uint64_t v19 = [(IDSDecryptionMetadata *)v14 initWithEncryptionType:v16 usedLastResortCache:v17 usedCachedData:v18];
  (*(void (**)(uint64_t, id, id, id, IDSDecryptionMetadata *))(v9 + 16))(v9, v13, v12, v11, v19);
}

void sub_1002DEDE8(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  uint64_t v9 = *(void *)(a1 + 40);
  id v10 = a5;
  id v11 = a4;
  id v12 = a3;
  id v13 = a2;
  uint64_t v14 = [IDSDecryptionMetadata alloc];
  unint64_t v15 = *(void *)(a1 + 48);
  if (v15 > 3) {
    uint64_t v16 = 2;
  }
  else {
    uint64_t v16 = qword_100794998[v15];
  }
  id v17 = [v10 usedLastResortCache];
  id v18 = [v10 usedCachedData];
  id v20 = [v10 additionalDecryptionResult];

  uint64_t v19 = [(IDSDecryptionMetadata *)v14 initWithEncryptionType:v16 usedLastResortCache:v17 usedCachedData:v18 additionalDecryptionResult:v20];
  (*(void (**)(uint64_t, id, id, id, IDSDecryptionMetadata *))(v9 + 16))(v9, v13, v12, v11, v19);
}

id sub_1002DF1B0(void *a1)
{
  LOWORD(v2) = 1;
  return +[IDSEncryptionHelpers logEncryptionErrorForToken:deviceID:forURI:fromURI:forService:messageData:type:encrypt:remote:priority:](IDSEncryptionHelpers, "logEncryptionErrorForToken:deviceID:forURI:fromURI:forService:messageData:type:encrypt:remote:priority:", a1[4], a1[5], a1[6], a1[7], a1[8], a1[9], a1[10], v2, 200);
}

id sub_1002DF360(void *a1)
{
  LOWORD(v2) = 256;
  return +[IDSEncryptionHelpers logEncryptionErrorForToken:deviceID:forURI:fromURI:forService:messageData:type:encrypt:remote:priority:](IDSEncryptionHelpers, "logEncryptionErrorForToken:deviceID:forURI:fromURI:forService:messageData:type:encrypt:remote:priority:", a1[4], a1[5], a1[6], a1[7], a1[8], a1[9], a1[10], v2, 200);
}

void sub_1002DF8B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va1, a13);
  va_start(va, a13);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1002DF900(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1002DF910(uint64_t a1)
{
}

void sub_1002DF918(uint64_t a1)
{
  uint64_t v2 = (id *)(a1 + 32);
  BOOL v3 = [*(id *)(a1 + 32) OTRController];
  unsigned __int8 v4 = [*v2 OTRToken];
  id v5 = [v3 copySessionObjectForToken:v4];

  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 40);
    id v19 = 0;
    uint64_t v7 = [v5 signAndProtectMessage:v6 withError:&v19];
    id v8 = v19;
    uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 8);
    id v10 = *(void **)(v9 + 40);
    *(void *)(v9 + 40) = v7;

    if (v8)
    {
      id v11 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        id v21 = v8;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "   OTR encryption failed with error: %@", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        _IDSLogV();
      }
      uint64_t v12 = *(void *)(*(void *)(a1 + 48) + 8);
      id v13 = *(void **)(v12 + 40);
      *(void *)(v12 + 40) = 0;

      *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 0;
    }
  }
  else
  {
    uint64_t v14 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      unint64_t v15 = [*(id *)(a1 + 32) OTRToken];
      *(_DWORD *)buf = 138412290;
      id v21 = v15;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Could not find OTR session for token: %@", buf, 0xCu);
    }
    if (os_log_shim_legacy_logging_enabled())
    {
      uint64_t v16 = [*(id *)(a1 + 32) OTRToken];
      _IDSWarnV();

      uint64_t v17 = objc_msgSend(*(id *)(a1 + 32), "OTRToken", v16);
      _IDSLogV();

      uint64_t v18 = objc_msgSend(*(id *)(a1 + 32), "OTRToken", v17);
      _IDSLogTransport();
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 0;
  }
}

void sub_1002DFF44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va1, a13);
  va_start(va, a13);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1002DFF90(uint64_t a1)
{
  uint64_t v2 = (id *)(a1 + 32);
  BOOL v3 = [*(id *)(a1 + 32) OTRController];
  unsigned __int8 v4 = [*v2 OTRToken];
  id v5 = [v3 copySessionObjectForToken:v4];

  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 40);
    id v19 = 0;
    uint64_t v7 = [v5 verifyAndExposeMessage:v6 withError:&v19];
    id v8 = v19;
    uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 8);
    id v10 = *(void **)(v9 + 40);
    *(void *)(v9 + 40) = v7;

    if (v8)
    {
      id v11 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        id v21 = v8;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "   OTR decryption failed with error: %@", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        _IDSLogV();
      }
      uint64_t v12 = *(void *)(*(void *)(a1 + 48) + 8);
      id v13 = *(void **)(v12 + 40);
      *(void *)(v12 + 40) = 0;

      *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 0;
    }
  }
  else
  {
    uint64_t v14 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      unint64_t v15 = [*(id *)(a1 + 32) OTRToken];
      *(_DWORD *)buf = 138412290;
      id v21 = v15;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Could not find OTR session for token: %@", buf, 0xCu);
    }
    if (os_log_shim_legacy_logging_enabled())
    {
      uint64_t v16 = [*(id *)(a1 + 32) OTRToken];
      _IDSWarnV();

      uint64_t v17 = objc_msgSend(*(id *)(a1 + 32), "OTRToken", v16);
      _IDSLogV();

      uint64_t v18 = objc_msgSend(*(id *)(a1 + 32), "OTRToken", v17);
      _IDSLogTransport();
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 0;
  }
}

void sub_1002E0A88(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) connectionInfoWithState:1];
  if (!v2)
  {
    uint64_t v2 = [*(id *)(a1 + 32) connectionInfoWithState:0];
    if (!v2)
    {
      uint64_t v2 = objc_alloc_init(_IDSSessionConnectionInfo);
      BOOL v3 = *(void **)(*(void *)(a1 + 32) + 16);
      if (!v3)
      {
        id v4 = objc_alloc_init((Class)NSMutableArray);
        uint64_t v5 = *(void *)(a1 + 32);
        uint64_t v6 = *(void **)(v5 + 16);
        *(void *)(v5 + 16) = v4;

        BOOL v3 = *(void **)(*(void *)(a1 + 32) + 16);
      }
      [v3 addObject:v2];
    }
  }
  id v7 = [objc_alloc((Class)NSKeyedUnarchiver) initForReadingFromData:*(void *)(a1 + 40) error:0];
  [v7 setDecodingFailurePolicy:0];
  [v7 _enableStrictSecureDecodingMode];
  uint64_t v8 = objc_opt_class();
  uint64_t v9 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", v8, objc_opt_class(), 0);
  id v10 = [v7 decodeObjectOfClasses:v9 forKey:@"connectionData"];
  id v11 = [v7 decodeObjectOfClasses:v9 forKey:@"skeData"];
  uint64_t v12 = [v7 decodeObjectOfClasses:v9 forKey:@"callInfoData"];
  id v13 = [v7 decodeObjectOfClass:objc_opt_class() forKey:@"cn"];
  [(_IDSSessionConnectionInfo *)v2 setRemoteSKEData:v11];
  [(_IDSSessionConnectionInfo *)v2 setRemoteICEData:v10];
  [(_IDSSessionConnectionInfo *)v2 setRemoteCallInfoData:v12];
  [(_IDSSessionConnectionInfo *)v2 setPeerCN:v13];
  [v7 finishDecoding];
}

void sub_1002E0CB4(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, long long buf)
{
  if (a2 == 1)
  {
    id v12 = objc_begin_catch(a1);
    id v13 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      uint64_t v14 = *(void *)(v11 + 40);
      LODWORD(buf) = 138412546;
      *(void *)((char *)&buf + 4) = v14;
      WORD6(buf) = 2112;
      *(void *)((char *)&buf + 14) = v12;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Exception caught unarchiving DDResult data: %@   Exception: %@", (uint8_t *)&buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      _IDSLogTransport();
    }

    objc_end_catch();
    JUMPOUT(0x1002E0C74);
  }
  _Unwind_Resume(a1);
}

void sub_1002E1008(uint64_t a1)
{
  uint64_t v2 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v3 = *(unsigned __int8 *)(a1 + 56);
    id v4 = objc_retainBlock(*(id *)(a1 + 40));
    uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
    *(_DWORD *)buf = 67109634;
    unsigned int v33 = v3;
    __int16 v34 = 2048;
    id v35 = v4;
    __int16 v36 = 2112;
    uint64_t v37 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "_connectionQueue: createConnectionData: requiresWifi = %d, dataReadyHandler = %p, _connection = %@", buf, 0x1Cu);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v6 = *(unsigned __int8 *)(a1 + 56);
    id v25 = objc_retainBlock(*(id *)(a1 + 40));
    uint64_t v27 = *(void *)(*(void *)(a1 + 32) + 8);
    uint64_t v23 = v6;
    _IDSLogV();
  }
  objc_msgSend(*(id *)(a1 + 32), "connectionInfoWithState:", 0, v23, v25, v27);
  id v7 = (_IDSSessionConnectionInfo *)objc_claimAutoreleasedReturnValue();
  if (!v7) {
    id v7 = objc_alloc_init(_IDSSessionConnectionInfo);
  }
  v28[0] = _NSConcreteStackBlock;
  v28[1] = 3221225472;
  v28[2] = sub_1002E140C;
  v28[3] = &unk_1009882A0;
  uint64_t v8 = v7;
  uint64_t v9 = *(void *)(a1 + 32);
  __int16 v29 = v8;
  uint64_t v30 = v9;
  id v31 = *(id *)(a1 + 48);
  id v10 = objc_retainBlock(v28);
  -[_IDSSessionConnectionInfo setCallID:](v8, "setCallID:", [*(id *)(*(void *)(a1 + 32) + 8) initializeNewCall]);
  [(_IDSSessionConnectionInfo *)v8 setState:1];
  uint64_t v11 = *(void **)(*(void *)(a1 + 32) + 16);
  if (!v11)
  {
    id v12 = objc_alloc_init((Class)NSMutableArray);
    uint64_t v13 = *(void *)(a1 + 32);
    uint64_t v14 = *(void **)(v13 + 16);
    *(void *)(v13 + 16) = v12;

    uint64_t v11 = *(void **)(*(void *)(a1 + 32) + 16);
  }
  [v11 addObject:v8];
  unint64_t v15 = sub_1002E1D24(v8);
  uint64_t v16 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v17 = [(_IDSSessionConnectionInfo *)v8 callID];
    uint64_t v18 = [(_IDSSessionConnectionInfo *)v8 peerCN];
    *(_DWORD *)buf = 67109378;
    unsigned int v33 = v17;
    __int16 v34 = 2112;
    id v35 = v18;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "_connectionQueue: calling inviteDictionaryForCallID for callID = %d, [connectionInfo peerCN] = %@ ", buf, 0x12u);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    id v19 = (id)[(_IDSSessionConnectionInfo *)v8 callID];
    [(_IDSSessionConnectionInfo *)v8 peerCN];
    v26 = id v24 = v19;
    _IDSLogV();
  }
  id v20 = [(_IDSSessionConnectionInfo *)v8 peerCN];

  if (v20)
  {
    id v21 = *(void **)(*(void *)(a1 + 32) + 8);
    id v22 = [(_IDSSessionConnectionInfo *)v8 peerCN];
    objc_msgSend(v21, "setPeerCN:callID:", v22, -[_IDSSessionConnectionInfo callID](v8, "callID"));
  }
  objc_msgSend(*(id *)(*(void *)(a1 + 32) + 8), "inviteDictionaryForCallID:remoteInviteDictionary:nonCellularCandidateTimeout:block:queue:", -[_IDSSessionConnectionInfo callID](v8, "callID"), v15, v10, *(void *)(*(void *)(a1 + 32) + 24), 0.0);
}

void sub_1002E140C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412546;
    id v42 = v5;
    __int16 v43 = 2112;
    id v44 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "   AV Response: %@   Error: %@", buf, 0x16u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    id v35 = v5;
    id v36 = v6;
    _IDSLogV();
  }
  if (!qword_100A4C6B8)
  {
    uint64_t v8 = (void **)IMWeakLinkSymbol();
    if (v8) {
      uint64_t v9 = *v8;
    }
    else {
      uint64_t v9 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C6B8, v9);
  }
  if (!qword_100A4C6C0)
  {
    id v10 = (void **)IMWeakLinkSymbol();
    if (v10) {
      uint64_t v11 = *v10;
    }
    else {
      uint64_t v11 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C6C0, v11);
  }
  if (!qword_100A4C6C8)
  {
    id v12 = (void **)IMWeakLinkSymbol();
    if (v12) {
      uint64_t v13 = *v12;
    }
    else {
      uint64_t v13 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C6C8, v13);
  }
  if (qword_100A4C6C0)
  {
    uint64_t v14 = [v5 objectForKey:qword_100A4C6B8];
  }
  else
  {
    uint64_t v14 = 0;
  }
  unint64_t v15 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    id v42 = v14;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Got connection data: %p", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    id v35 = v14;
    _IDSLogV();
  }
  if (v6)
  {
    uint64_t v16 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      id v42 = v6;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Connection data error: %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      id v35 = v6;
      _IDSLogTransport();
    }
  }
  if (!qword_100A4C6C0
    || (objc_msgSend(v5, "objectForKey:"), (unsigned int v17 = objc_claimAutoreleasedReturnValue()) == 0))
  {
    uint64_t v18 = objc_msgSend(*(id *)(a1 + 32), "remoteSKEData", v35, v36);
    if (v18)
    {
    }
    else
    {
      id v20 = [*(id *)(a1 + 32) remoteICEData];
      BOOL v21 = v20 == 0;

      if (!v21)
      {
LABEL_43:
        unsigned int v17 = 0;
        goto LABEL_44;
      }
    }
    id v19 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "skeData was nil", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      _IDSLogTransport();
    }
    goto LABEL_43;
  }
LABEL_44:
  if (!qword_100A4C6C8
    || (objc_msgSend(v5, "objectForKey:"), (id v22 = objc_claimAutoreleasedReturnValue()) == 0))
  {
    uint64_t v23 = objc_msgSend(*(id *)(a1 + 32), "remoteCallInfoData", v35);
    if (v23)
    {
    }
    else
    {
      id v25 = [*(id *)(a1 + 32) remoteCallInfoData];
      BOOL v26 = v25 == 0;

      if (!v26)
      {
LABEL_53:
        id v22 = 0;
        goto LABEL_54;
      }
    }
    id v24 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "callInfoData was nil", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      _IDSLogTransport();
    }
    goto LABEL_53;
  }
LABEL_54:
  [*(id *)(a1 + 32) setLocalSKEData:v17];
  [*(id *)(a1 + 32) setLocalICEData:v14];
  [*(id *)(a1 + 32) setLocalCallInfoData:v22];
  if (v6)
  {
    [*(id *)(a1 + 32) setState:4];
    objc_msgSend(*(id *)(*(void *)(a1 + 40) + 8), "stopCallID:", objc_msgSend(*(id *)(a1 + 32), "callID"));
  }
  uint64_t v27 = objc_msgSend(*(id *)(a1 + 32), "localCN", v35);
  unint64_t v28 = v14;
  unint64_t v29 = v17;
  id v30 = v22;
  id v31 = v27;
  if (v28 | v29)
  {
    id v32 = [objc_alloc((Class)NSKeyedArchiver) initRequiringSecureCoding:0];
    [v32 encodeObject:v28 forKey:@"connectionData"];
    [v32 encodeObject:v29 forKey:@"skeData"];
    [v32 encodeObject:v30 forKey:@"callInfoData"];
    [v32 encodeObject:v31 forKey:@"cn"];
    unsigned int v33 = [v32 encodedData];
  }
  else
  {
    unsigned int v33 = 0;
  }

  if (*(void *)(a1 + 48))
  {
    __int16 v34 = im_primary_queue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1002E1D0C;
    block[3] = &unk_100981860;
    id v40 = *(id *)(a1 + 48);
    id v38 = v33;
    id v39 = v6;
    dispatch_async(v34, block);
  }
}

uint64_t sub_1002E1D0C(void *a1)
{
  return (*(uint64_t (**)(void, void, void))(a1[6] + 16))(a1[6], a1[4], a1[5]);
}

id sub_1002E1D24(void *a1)
{
  id v1 = a1;
  if (!qword_100A4C6B8)
  {
    uint64_t v2 = (void **)IMWeakLinkSymbol();
    if (v2) {
      unsigned int v3 = *v2;
    }
    else {
      unsigned int v3 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C6B8, v3);
  }
  if (!qword_100A4C6C0)
  {
    id v4 = (void **)IMWeakLinkSymbol();
    if (v4) {
      id v5 = *v4;
    }
    else {
      id v5 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C6C0, v5);
  }
  if (!qword_100A4C6C8)
  {
    id v6 = (void **)IMWeakLinkSymbol();
    if (v6) {
      id v7 = *v6;
    }
    else {
      id v7 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C6C8, v7);
  }
  uint64_t v8 = [v1 remoteSKEData];
  if (v8)
  {
  }
  else
  {
    Mutable = [v1 remoteICEData];

    if (!Mutable) {
      goto LABEL_26;
    }
  }
  Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  id v10 = [v1 remoteSKEData];
  if (v10) {
    CFDictionarySetValue((CFMutableDictionaryRef)Mutable, (const void *)qword_100A4C6C0, v10);
  }

  uint64_t v11 = [v1 remoteICEData];
  if (v11) {
    CFDictionarySetValue((CFMutableDictionaryRef)Mutable, (const void *)qword_100A4C6B8, v11);
  }

  id v12 = [v1 remoteCallInfoData];
  if (v12) {
    CFDictionarySetValue((CFMutableDictionaryRef)Mutable, (const void *)qword_100A4C6C8, v12);
  }

LABEL_26:

  return Mutable;
}

void sub_1002E1FA0(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) connectionInfoWithState:1];
  if (!v2)
  {
    uint64_t v2 = [*(id *)(a1 + 32) connectionInfoWithState:0];
  }
  unsigned int v3 = sub_1002E1D24(v2);
  uint64_t v4 = *(unsigned __int8 *)(*(void *)(a1 + 32) + 73);
  id v5 = objc_alloc_init((Class)qword_100A4C6E0);
  [v5 setIsKeyExchangeEnabled:1];
  [v5 setIsAudioEnabled:v4];
  [v5 setIsVideoEnabled:0];
  [v5 setIsDTLSEnabled:1];
  if (_IMWillLog()) {
    _IMAlwaysLog();
  }
  if (MarcoShouldLogCheckpoints()) {
    MarcoNoteCheckpoint();
  }
  [v2 setState:2];
  id v6 = [v2 peerCN];

  if (v6)
  {
    id v7 = *(void **)(*(void *)(a1 + 32) + 8);
    uint64_t v8 = [v2 peerCN];
    objc_msgSend(v7, "setPeerCN:callID:", v8, objc_msgSend(v2, "callID"));
  }
  objc_msgSend(*(id *)(*(void *)(a1 + 32) + 8), "setPeerProtocolVersion:forCallID:", *(_DWORD *)(a1 + 48) > 1u, objc_msgSend(v2, "callID"));
  uint64_t v9 = *(void **)(*(void *)(a1 + 32) + 8);
  unsigned int v10 = [v2 callID];
  uint64_t v11 = *(unsigned __int8 *)(a1 + 52);
  id v17 = 0;
  [v9 startConnectionWithCallID:v10 usingInviteData:v3 isCaller:v11 relayResponseDict:0 didOriginateRelayRequest:0 capabilities:v5 error:&v17];
  id v12 = v17;
  if (v12) {
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  uint64_t v13 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = *(void *)(a1 + 32);
    uint64_t v16 = *(void *)(v14 + 8);
    uint64_t v15 = *(void *)(v14 + 16);
    *(_DWORD *)buf = 138413570;
    uint64_t v19 = v16;
    __int16 v20 = 2112;
    id v21 = v5;
    __int16 v22 = 2112;
    uint64_t v23 = v2;
    __int16 v24 = 2112;
    id v25 = v12;
    __int16 v26 = 2112;
    uint64_t v27 = v15;
    __int16 v28 = 2112;
    unint64_t v29 = v3;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Calling startConnectionWithCallID %@, %@, connectionInfo = %@, startError = %@, connectionInfos = %@, [connectionInfo remoteInviteData] = %@", buf, 0x3Eu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
}

void sub_1002E2334(uint64_t a1)
{
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v3 = [v2 countByEnumeratingWithState:&v8 objects:v12 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v9;
    do
    {
      for (i = 0; i != v4; i = (char *)i + 1)
      {
        if (*(void *)v9 != v5) {
          objc_enumerationMutation(v2);
        }
        id v7 = *(void **)(*((void *)&v8 + 1) + 8 * i);
        objc_msgSend(v7, "setState:", 4, (void)v8);
        objc_msgSend(*(id *)(*(void *)(a1 + 32) + 8), "stopCallID:", objc_msgSend(v7, "callID"));
      }
      id v4 = [v2 countByEnumeratingWithState:&v8 objects:v12 count:16];
    }
    while (v4);
  }
}

id sub_1002E24EC(uint64_t a1)
{
  id v2 = *(void **)(*(void *)(a1 + 32) + 8);
  if (v2)
  {
    if (*(void *)(a1 + 40))
    {
      return _objc_msgSend(v2, "sendData:forCallID:encrypted:");
    }
    id v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "No data to send, bailing...", v6, 2u);
    }

    id result = (id)os_log_shim_legacy_logging_enabled();
    if (result)
    {
      id result = (id)_IDSShouldLog();
      if (result) {
        return (id)_IDSLogV();
      }
    }
  }
  else
  {
    id v3 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "No connection, bailing...", buf, 2u);
    }

    id result = (id)os_log_shim_legacy_logging_enabled();
    if (result)
    {
      id result = (id)_IDSShouldLog();
      if (result) {
        return (id)_IDSLogV();
      }
    }
  }
  return result;
}

void sub_1002E27FC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 32));
  char v3 = objc_opt_respondsToSelector();

  if (v3)
  {
    id v4 = im_primary_queue();
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    v6[2] = sub_1002E28CC;
    v6[3] = &unk_10097E440;
    uint64_t v5 = *(void **)(a1 + 40);
    v6[4] = *(void *)(a1 + 32);
    id v7 = v5;
    dispatch_async(v4, v6);
  }
}

void sub_1002E28CC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 32));
  [WeakRetained connection:*(void *)(a1 + 32) receivedData:*(void *)(a1 + 40)];
}

void sub_1002E29CC(uint64_t a1)
{
  if (qword_100A4C590)
  {
    id v2 = objc_msgSend(*(id *)(a1 + 32), "objectForKey:");
  }
  else
  {
    id v2 = 0;
  }
  if (qword_100A4C580)
  {
    char v3 = objc_msgSend(*(id *)(a1 + 32), "objectForKey:");
    id v4 = (id *)(a1 + 40);
    *(void *)(*(void *)(a1 + 40) + 40) = [v3 integerValue];
  }
  else
  {
    id v4 = (id *)(a1 + 40);
    *(void *)(*(void *)(a1 + 40) + 40) = 0;
  }
  uint64_t v5 = [*v4 connectionInfoForCallID:*((void *)*v4 + 5)];
  if (qword_100A4C588)
  {
    id v6 = objc_msgSend(*(id *)(a1 + 32), "objectForKey:");
    *(void *)(*(void *)(a1 + 40) + 48) = [v6 integerValue];
  }
  else
  {
    *((void *)*v4 + 6) = 0;
  }
  if (qword_100A4C598)
  {
    id v7 = objc_msgSend(*(id *)(a1 + 32), "objectForKey:");
    *(void *)(*(void *)(a1 + 40) + 56) = [v7 integerValue];
  }
  else
  {
    *((void *)*v4 + 7) = 0;
  }
  if (qword_100A4C5A0)
  {
    long long v8 = objc_msgSend(*(id *)(a1 + 32), "objectForKey:");
    *(void *)(*(void *)(a1 + 40) + 64) = [v8 integerValue];
  }
  else
  {
    *((void *)*v4 + 8) = 0;
  }
  long long v9 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = *(unsigned __int8 *)(a1 + 48);
    uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 40);
    *(_DWORD *)buf = 67109634;
    int v22 = v10;
    __int16 v23 = 1024;
    *(_DWORD *)__int16 v24 = v11;
    *(_WORD *)&v24[4] = 2112;
    *(void *)&v24[6] = v2;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "didStartSession %d for callID %d, error = %@", buf, 0x18u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  if (v5)
  {
    uint64_t v12 = *(void *)(a1 + 40);
    if (*(unsigned char *)(a1 + 48))
    {
      *(unsigned char *)(v12 + 72) = 1;
      [v5 setState:3];
      uint64_t v13 = im_primary_queue();
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_1002E2E80;
      block[3] = &unk_10097E4D0;
      void block[4] = *v4;
      dispatch_async(v13, block);
    }
    else
    {
      *(unsigned char *)(v12 + 72) = 0;
      [v5 setState:4];
      id v17 = im_primary_queue();
      v19[0] = _NSConcreteStackBlock;
      v19[1] = 3221225472;
      v19[2] = sub_1002E2E28;
      v19[3] = &unk_10097E440;
      v19[4] = *v4;
      id v20 = v2;
      dispatch_async(v17, v19);
    }
  }
  else
  {
    uint64_t v14 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = *((void *)*v4 + 5);
      uint64_t v16 = *((void *)*v4 + 2);
      *(_DWORD *)buf = 67109378;
      int v22 = v15;
      __int16 v23 = 2112;
      *(void *)__int16 v24 = v16;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "didStartSession returned a callID we do not recognize %d, what we have %@", buf, 0x12u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
  }
}

void sub_1002E2E28(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 32));
  [WeakRetained connection:*(void *)(a1 + 32) didStart:0 error:*(void *)(a1 + 40)];
}

void sub_1002E2E80(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 32));
  [WeakRetained connection:*(void *)(a1 + 32) didStart:1 error:0];
}

void sub_1002E2F84(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) connectionInfoForCallID:*(void *)(a1 + 48)];
  if (v2)
  {
    *(unsigned char *)(*(void *)(a1 + 32) + 72) = 0;
    char v3 = im_primary_queue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1002E3168;
    block[3] = &unk_10097E440;
    void block[4] = *(void *)(a1 + 32);
    id v8 = *(id *)(a1 + 40);
    dispatch_async(v3, block);
  }
  else
  {
    id v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 48);
      uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 16);
      *(_DWORD *)buf = 67109378;
      int v10 = v5;
      __int16 v11 = 2112;
      uint64_t v12 = v6;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "didStopWithCallID returned a callID we do not recognize %d, what we have %@", buf, 0x12u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
  }
}

void sub_1002E3168(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 32));
  [WeakRetained connectionDidStop:*(void *)(a1 + 32) error:*(void *)(a1 + 40)];
}

void sub_1002E31F0(id a1)
{
  qword_100A4C6D0 = IMWeakLinkClass();
  qword_100A4C6E0 = IMWeakLinkClass();
  if (!qword_100A4C5A8)
  {
    id v1 = (void **)IMWeakLinkSymbol();
    if (v1) {
      id v2 = *v1;
    }
    else {
      id v2 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C5A8, v2);
  }
  if (!qword_100A4C5B0)
  {
    char v3 = (void **)IMWeakLinkSymbol();
    if (v3) {
      id v4 = *v3;
    }
    else {
      id v4 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C5B0, v4);
  }
  if (!qword_100A4C5B8)
  {
    uint64_t v5 = (void **)IMWeakLinkSymbol();
    if (v5) {
      uint64_t v6 = *v5;
    }
    else {
      uint64_t v6 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C5B8, v6);
  }
  if (!qword_100A4C5C0)
  {
    id v7 = (void **)IMWeakLinkSymbol();
    if (v7) {
      id v8 = *v7;
    }
    else {
      id v8 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C5C0, v8);
  }
  if (!qword_100A4C5C8)
  {
    long long v9 = (void **)IMWeakLinkSymbol();
    if (v9) {
      int v10 = *v9;
    }
    else {
      int v10 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C5C8, v10);
  }
  if (!qword_100A4C5D0)
  {
    __int16 v11 = (void **)IMWeakLinkSymbol();
    if (v11) {
      uint64_t v12 = *v11;
    }
    else {
      uint64_t v12 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C5D0, v12);
  }
  if (!qword_100A4C5D8)
  {
    uint64_t v13 = (void **)IMWeakLinkSymbol();
    if (v13) {
      uint64_t v14 = *v13;
    }
    else {
      uint64_t v14 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C5D8, v14);
  }
  if (!qword_100A4C5E0)
  {
    uint64_t v15 = (void **)IMWeakLinkSymbol();
    if (v15) {
      uint64_t v16 = *v15;
    }
    else {
      uint64_t v16 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C5E0, v16);
  }
  if (!qword_100A4C5E8)
  {
    id v17 = (void **)IMWeakLinkSymbol();
    if (v17) {
      uint64_t v18 = *v17;
    }
    else {
      uint64_t v18 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C5E8, v18);
  }
  if (!qword_100A4C5F0)
  {
    uint64_t v19 = (void **)IMWeakLinkSymbol();
    if (v19) {
      id v20 = *v19;
    }
    else {
      id v20 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C5F0, v20);
  }
  if (!qword_100A4C5F8)
  {
    id v21 = (void **)IMWeakLinkSymbol();
    if (v21) {
      int v22 = *v21;
    }
    else {
      int v22 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C5F8, v22);
  }
  if (!qword_100A4C600)
  {
    __int16 v23 = (void **)IMWeakLinkSymbol();
    if (v23) {
      __int16 v24 = *v23;
    }
    else {
      __int16 v24 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C600, v24);
  }
  if (!qword_100A4C608)
  {
    id v25 = (void **)IMWeakLinkSymbol();
    if (v25) {
      __int16 v26 = *v25;
    }
    else {
      __int16 v26 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C608, v26);
  }
  if (!qword_100A4C610)
  {
    uint64_t v27 = (void **)IMWeakLinkSymbol();
    if (v27) {
      __int16 v28 = *v27;
    }
    else {
      __int16 v28 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C610, v28);
  }
  if (!qword_100A4C618)
  {
    unint64_t v29 = (void **)IMWeakLinkSymbol();
    if (v29) {
      id v30 = *v29;
    }
    else {
      id v30 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C618, v30);
  }
  if (!qword_100A4C620)
  {
    id v31 = (void **)IMWeakLinkSymbol();
    if (v31) {
      id v32 = *v31;
    }
    else {
      id v32 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C620, v32);
  }
  if (!qword_100A4C628)
  {
    unsigned int v33 = (void **)IMWeakLinkSymbol();
    if (v33) {
      __int16 v34 = *v33;
    }
    else {
      __int16 v34 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C628, v34);
  }
  if (!qword_100A4C630)
  {
    id v35 = (void **)IMWeakLinkSymbol();
    if (v35) {
      id v36 = *v35;
    }
    else {
      id v36 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C630, v36);
  }
  if (!qword_100A4C638)
  {
    uint64_t v37 = (void **)IMWeakLinkSymbol();
    if (v37) {
      id v38 = *v37;
    }
    else {
      id v38 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C638, v38);
  }
  if (!qword_100A4C640)
  {
    id v39 = (void **)IMWeakLinkSymbol();
    if (v39) {
      id v40 = *v39;
    }
    else {
      id v40 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C640, v40);
  }
  if (!qword_100A4C588)
  {
    long long v41 = (void **)IMWeakLinkSymbol();
    if (v41) {
      id v42 = *v41;
    }
    else {
      id v42 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C588, v42);
  }
  if (!qword_100A4C590)
  {
    __int16 v43 = (void **)IMWeakLinkSymbol();
    if (v43) {
      id v44 = *v43;
    }
    else {
      id v44 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C590, v44);
  }
  if (!qword_100A4C580)
  {
    uint64_t v45 = (void **)IMWeakLinkSymbol();
    if (v45) {
      v46 = *v45;
    }
    else {
      v46 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C580, v46);
  }
  if (!qword_100A4C598)
  {
    __int16 v47 = (void **)IMWeakLinkSymbol();
    if (v47) {
      uint64_t v48 = *v47;
    }
    else {
      uint64_t v48 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C598, v48);
  }
  if (!qword_100A4C5A0)
  {
    NSErrorUserInfoKey v49 = (void **)IMWeakLinkSymbol();
    if (v49) {
      v50 = *v49;
    }
    else {
      v50 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C5A0, v50);
  }
  if (!qword_100A4C648)
  {
    NSErrorUserInfoKey v51 = (void **)IMWeakLinkSymbol();
    if (v51) {
      v52 = *v51;
    }
    else {
      v52 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C648, v52);
  }
  if (!qword_100A4C660)
  {
    NSErrorUserInfoKey v53 = (void **)IMWeakLinkSymbol();
    if (v53) {
      v54 = *v53;
    }
    else {
      v54 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C660, v54);
  }
  if (!qword_100A4C650)
  {
    NSErrorUserInfoKey v55 = (void **)IMWeakLinkSymbol();
    if (v55) {
      v56 = *v55;
    }
    else {
      v56 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C650, v56);
  }
  if (!qword_100A4C658)
  {
    v57 = (void **)IMWeakLinkSymbol();
    if (v57) {
      v58 = *v57;
    }
    else {
      v58 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C658, v58);
  }
  if (!qword_100A4C678)
  {
    __int16 v59 = (void **)IMWeakLinkSymbol();
    if (v59) {
      v60 = *v59;
    }
    else {
      v60 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C678, v60);
  }
  if (!qword_100A4C668)
  {
    v61 = (void **)IMWeakLinkSymbol();
    if (v61) {
      v62 = *v61;
    }
    else {
      v62 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C668, v62);
  }
  if (!qword_100A4C670)
  {
    v63 = (void **)IMWeakLinkSymbol();
    if (v63) {
      v64 = *v63;
    }
    else {
      v64 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C670, v64);
  }
  if (!qword_100A4C680)
  {
    v65 = (void **)IMWeakLinkSymbol();
    if (v65) {
      v66 = *v65;
    }
    else {
      v66 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C680, v66);
  }
  if (!qword_100A4C688)
  {
    v67 = (void **)IMWeakLinkSymbol();
    if (v67) {
      v68 = *v67;
    }
    else {
      v68 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C688, v68);
  }
  if (!qword_100A4C690)
  {
    v69 = (void **)IMWeakLinkSymbol();
    if (v69) {
      v70 = *v69;
    }
    else {
      v70 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C690, v70);
  }
  if (!qword_100A4C698)
  {
    v71 = (void **)IMWeakLinkSymbol();
    if (v71) {
      v72 = *v71;
    }
    else {
      v72 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C698, v72);
  }
  if (!qword_100A4C6A0)
  {
    v73 = (void **)IMWeakLinkSymbol();
    if (v73) {
      v74 = *v73;
    }
    else {
      v74 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C6A0, v74);
  }
  if (!qword_100A4C6A8)
  {
    v75 = (void **)IMWeakLinkSymbol();
    if (v75) {
      v76 = *v75;
    }
    else {
      v76 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C6A8, v76);
  }
  if (!qword_100A4C6B0)
  {
    v77 = (void **)IMWeakLinkSymbol();
    if (v77) {
      v78 = *v77;
    }
    else {
      v78 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C6B0, v78);
  }
}

void sub_1002E40D8(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1002E428C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1002E4314(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1002E4B4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, os_unfair_lock_t lock)
{
}

void sub_1002E58C4(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2588692];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setServiceName:*(void *)(a1 + 40)];
    [v2 setActiveParticipants:*(void *)(a1 + 48)];
    [v2 setMissingPrekeys:*(void *)(a1 + 56)];
    [*(id *)(a1 + 32) _submitAWDMetric:v2 withContainer:v3];
  }
}

void sub_1002E5A24(uint64_t a1)
{
  id v5 = [*(id *)(a1 + 32) _metricContainerForMetricType:2588693];
  if (v5)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setServiceName:*(void *)(a1 + 40)];
    [v2 setTimeDelta:*(void *)(a1 + 48)];
    uint64_t v3 = *(void *)(a1 + 56);
    if (v3 >= 1) {
      uint64_t v4 = ((int)v3 - 1) / 3u;
    }
    else {
      uint64_t v4 = 0;
    }
    [v2 setActiveParticipantBucket:v4];
    [*(id *)(a1 + 32) _submitAWDMetric:v2 withContainer:v5];
  }
}

void sub_1002E5BA0(uint64_t a1)
{
  id v5 = [*(id *)(a1 + 32) _metricContainerForMetricType:2588695];
  if (v5)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setServiceName:*(void *)(a1 + 40)];
    [v2 setTimeDelta:*(void *)(a1 + 48)];
    uint64_t v3 = *(void *)(a1 + 56);
    if (v3 >= 1) {
      uint64_t v4 = ((int)v3 - 1) / 3u;
    }
    else {
      uint64_t v4 = 0;
    }
    [v2 setActiveParticipantBucket:v4];
    [*(id *)(a1 + 32) _submitAWDMetric:v2 withContainer:v5];
  }
}

void sub_1002E684C(id a1)
{
  id v1 = objc_alloc_init(IDSTransportLevelAgent);
  id v2 = (void *)qword_100A4C6F0;
  qword_100A4C6F0 = (uint64_t)v1;

  uint64_t v3 = dispatch_get_global_queue(-32768, 0);
  [(id)qword_100A4C6F0 setInterface:NEVirtualInterfaceCreate()];

  if ([(id)qword_100A4C6F0 interface])
  {
    [(id)qword_100A4C6F0 interface];
    uint64_t v4 = (const void *)NEVirtualInterfaceCopyName();
    id v5 = CFAutorelease(v4);
    [(id)qword_100A4C6F0 interface];
    NEVirtualInterfaceSetReadAutomatically();
    [(id)qword_100A4C6F0 interface];
    int IPPayloadHandler = NEVirtualInterfaceSetReadIPPayloadHandler();
    [(id)qword_100A4C6F0 interface];
    int v7 = NEVirtualInterfaceSetMTU();
    [(id)qword_100A4C6F0 interface];
    [@"fe80::ce81:b1c:bd2c:69e%" stringByAppendingString:v5];
    int v8 = NEVirtualInterfaceAddAddress();
    [(id)qword_100A4C6F0 interface];
    int v9 = NEVirtualInterfaceSetRankNever();
    [(id)qword_100A4C6F0 interface];
    int updated = NEVirtualInterfaceUpdateAdHocService();
    __int16 v11 = +[IDSFoundationLog Multiplexer];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v12 = @"YES";
      if (IPPayloadHandler) {
        CFStringRef v13 = @"YES";
      }
      else {
        CFStringRef v13 = @"NO";
      }
      *(_DWORD *)id v35 = 138413570;
      *(void *)&v35[4] = v5;
      if (v7) {
        CFStringRef v14 = @"YES";
      }
      else {
        CFStringRef v14 = @"NO";
      }
      *(void *)&v35[14] = v13;
      *(_WORD *)&v35[12] = 2112;
      if (v8) {
        CFStringRef v15 = @"YES";
      }
      else {
        CFStringRef v15 = @"NO";
      }
      *(_WORD *)&v35[22] = 2112;
      CFStringRef v36 = v14;
      if (v9) {
        CFStringRef v16 = @"YES";
      }
      else {
        CFStringRef v16 = @"NO";
      }
      *(_WORD *)uint64_t v37 = 2112;
      if (!updated) {
        CFStringRef v12 = @"NO";
      }
      *(void *)&v37[2] = v15;
      __int16 v38 = 2112;
      CFStringRef v39 = v16;
      __int16 v40 = 2112;
      CFStringRef v41 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Created interface %@ for IDS Nexus %@ %@ %@ %@ %@", v35, 0x3Eu);
    }

    id v17 = +[NSUUID UUID];
    [(id)qword_100A4C6F0 setAgentUUID:v17];

    [(id)qword_100A4C6F0 setActive:1];
    uint64_t v18 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    uint64_t v19 = dispatch_queue_attr_make_initially_inactive(v18);
    id v20 = dispatch_queue_create("IDSTransportLevelAgentQueue", (dispatch_queue_attr_t)v19);

    id v21 = IDSRealTimeContext();
    nw_queue_context_target_dispatch_queue();

    dispatch_activate(v20);
    id v22 = [objc_alloc((Class)NWNetworkAgentRegistration) initWithNetworkAgentClass:objc_opt_class() queue:v20];
    [(id)qword_100A4C6F0 setRegistration:v22];

    __int16 v23 = [(id)qword_100A4C6F0 registration];
    LOBYTE(v19) = [v23 registerNetworkAgent:qword_100A4C6F0];

    __int16 v24 = +[IDSFoundationLog Multiplexer];
    BOOL v25 = os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT);
    if (v19)
    {
      if (v25)
      {
        uint64_t v26 = qword_100A4C6F0;
        uint64_t v27 = [(id)qword_100A4C6F0 agentUUID];
        __int16 v28 = [(id)qword_100A4C6F0 registration];
        if ([v28 isRegistered]) {
          CFStringRef v29 = @"YES";
        }
        else {
          CFStringRef v29 = @"NO";
        }
        id v30 = objc_msgSend((id)qword_100A4C6F0, "registration", *(_OWORD *)v35, *(void *)&v35[16], v36, *(void *)v37);
        id v31 = [v30 registeredUUID];
        *(_DWORD *)id v35 = 134218754;
        *(void *)&v35[4] = v26;
        *(_WORD *)&v35[12] = 2112;
        *(void *)&v35[14] = v27;
        *(_WORD *)&v35[22] = 2112;
        CFStringRef v36 = v29;
        *(_WORD *)uint64_t v37 = 2112;
        *(void *)&v37[2] = v31;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Registered IDS Nexus Agent (%p) %@ (isRegistered %@ registrationUUID %@)", v35, 0x2Au);
      }
      id v32 = [(id)qword_100A4C6F0 registration];
      unsigned __int8 v33 = [v32 addNetworkAgentToInterfaceNamed:v5];

      if ((v33 & 1) == 0)
      {
        __int16 v34 = +[IDSFoundationLog Multiplexer];
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)id v35 = 0;
          _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "addNetworkAgentToInterfaceNamed failed", v35, 2u);
        }
      }
    }
    else
    {
      if (v25)
      {
        *(_WORD *)id v35 = 0;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "registerNetworkAgent failed", v35, 2u);
      }

      IDSNetworkingLogDump();
    }
  }
  else
  {
    id v5 = +[IDSFoundationLog Multiplexer];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v35 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "NEVirtualInterfaceCreate failed", v35, 2u);
    }
  }
}

void sub_1002E7974(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2555935];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setLinkType:*(unsigned int *)(a1 + 40)];
    [v2 setCurrentRTT:*(void *)(a1 + 48)];
    [v2 setBandwidth:*(void *)(a1 + 56)];
    [*(id *)(a1 + 32) _submitAWDMetric:v2 withContainer:v3];
  }
}

void sub_1002E8DE8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = +[IMRGLog registration];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    id v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Responding to local device info query: %@", buf, 0xCu);
  }

  id v5 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    id v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Responding to local device info query: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      _IDSLogTransport();
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32));
}

void sub_1002E9B28(uint64_t a1, int a2)
{
  uint64_t v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v5 = @"NO";
    if (a2) {
      CFStringRef v5 = @"YES";
    }
    *(_DWORD *)buf = 138412290;
    CFStringRef v71 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Done with outgoing network availability check; networkOkForSession: %@",
      buf,
      0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    CFStringRef v6 = @"NO";
    if (a2) {
      CFStringRef v6 = @"YES";
    }
    CFStringRef v46 = v6;
    _IDSLogV();
  }
  id v7 = objc_msgSend(*(id *)(a1 + 32), "sharedState", v46);
  BOOL v8 = [v7 state] == 8;

  if (v8)
  {
    int v9 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = [*(id *)(a1 + 32) sharedState];
      __int16 v11 = [v10 uniqueID];
      *(_DWORD *)buf = 138412290;
      CFStringRef v71 = v11;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Session %@ has ended; NOT sending remote invitations!",
        buf,
        0xCu);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      CFStringRef v12 = [*(id *)(a1 + 32) sharedState];
      uint64_t v48 = [v12 uniqueID];
      _IDSLogV();

LABEL_42:
    }
  }
  else
  {
    if (a2)
    {
      CFStringRef v13 = +[IDSFoundationLog IDSDSession];
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v14 = [*(id *)(a1 + 32) sharedState];
        unsigned int v15 = [v14 isScreenSharingSession];
        CFStringRef v16 = @"NO";
        if (v15) {
          CFStringRef v16 = @"YES";
        }
        *(_DWORD *)buf = 138412290;
        CFStringRef v71 = v16;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Creating connection data, isScreenSharingSession: %@", buf, 0xCu);
      }
      id v17 = +[IDSDAccountController sharedInstance];
      uint64_t v18 = [*(id *)(a1 + 32) sharedState];
      uint64_t v19 = [v18 accountID];
      id v20 = [v17 accountWithUniqueID:v19];
      CFStringRef v12 = [v20 _registrationCert];

      id v21 = self;
      id v22 = [v21 sharedState];
      LODWORD(v18) = [v22 isScreenSharingSession];

      __int16 v23 = [*(id *)(a1 + 32) sharedState];
      __int16 v24 = v23;
      if (v18)
      {
        BOOL v25 = [v23 connection];
        v65[0] = _NSConcreteStackBlock;
        v65[1] = 3221225472;
        v65[2] = sub_1002EA494;
        v65[3] = &unk_1009883C8;
        uint64_t v26 = *(void **)(a1 + 40);
        v65[4] = *(void *)(a1 + 32);
        id v66 = v26;
        id v67 = *(id *)(a1 + 48);
        id v68 = *(id *)(a1 + 56);
        char v69 = *(unsigned char *)(a1 + 72);
        [v25 createConnectionData:0 handler:v65];
      }
      else
      {
        unsigned int v31 = [v23 enableQuickRelay];

        if (v31)
        {
          NSErrorUserInfoKey v53 = +[IDSQuickRelayAllocator sharedInstance];
          __int16 v59 = [*(id *)(a1 + 32) sharedState];
          v58 = [v59 destinations];
          v52 = [v58 allObjects];
          v57 = [*(id *)(a1 + 32) sharedState];
          NSErrorUserInfoKey v51 = [v57 uniqueID];
          v56 = [*(id *)(a1 + 32) sharedState];
          NSErrorUserInfoKey v55 = [v56 fromURI];
          v50 = [v55 prefixedURI];
          v54 = +[IDSDAccountController sharedInstance];
          id v32 = [*(id *)(a1 + 32) sharedState];
          unsigned __int8 v33 = [v32 accountID];
          __int16 v34 = [v54 accountWithUniqueID:v33];
          id v35 = [v34 service];
          CFStringRef v36 = [v35 identifier];
          uint64_t v37 = [*(id *)(a1 + 32) sharedState];
          __int16 v38 = [v37 getQuickRelayAllocateOptions:&off_1009D1CF8];
          id v39 = [v53 setupNewAllocation:v52 sessionID:v51 fromIdentity:v12 fromURI:v50 fromService:v36 options:v38 connectReadyHandler:0];

          [*(id *)(a1 + 32) _sendInvitationMessageToDestinations:*(void *)(a1 + 40) withOptions:*(void *)(a1 + 48) contextData:*(void *)(a1 + 56) declineOnError:*(unsigned __int8 *)(a1 + 72) connectionData:0];
        }
        else
        {
          __int16 v40 = +[IDSUTunController sharedInstance];
          CFStringRef v41 = [*(id *)(a1 + 32) sharedState];
          id v42 = [v41 uniqueID];
          __int16 v43 = [*(id *)(a1 + 32) sharedState];
          id v44 = [v43 participantID];
          v60[0] = _NSConcreteStackBlock;
          v60[1] = 3221225472;
          v60[2] = sub_1002EA66C;
          v60[3] = &unk_1009883C8;
          v60[4] = *(void *)(a1 + 32);
          id v61 = *(id *)(a1 + 40);
          id v62 = *(id *)(a1 + 48);
          id v63 = *(id *)(a1 + 56);
          char v64 = *(unsigned char *)(a1 + 72);
          [v40 createConnectionDataForDevice:v42 localPartyID:v44 dataReadyHandler:v60];
        }
      }
      uint64_t v45 = [*(id *)(a1 + 32) sharedState];
      [v45 setInvitationTimer];

      goto LABEL_42;
    }
    uint64_t v27 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Network availability check indicated that we should not attempt to send remote invitation(s)", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
    if (![*(id *)(a1 + 64) count]
      || ([*(id *)(a1 + 32) sharedState],
          __int16 v28 = objc_claimAutoreleasedReturnValue(),
          unsigned int v29 = [v28 forceInternetInvitation],
          v28,
          v29))
    {
      id v30 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412546;
        CFStringRef v71 = @"IDSDSession";
        __int16 v72 = 1024;
        int v73 = 13;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "%@: sendInvitationWithOptions could not find active Wifi connection, ending session with reason %d", buf, 0x12u);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLogTransport())
        {
          CFStringRef v47 = @"IDSDSession";
          uint64_t v49 = 13;
          _IDSLogTransport();
          if (_IDSShouldLog())
          {
            CFStringRef v47 = @"IDSDSession";
            uint64_t v49 = 13;
            _IDSLogV();
          }
        }
      }
      CFStringRef v12 = objc_msgSend(*(id *)(a1 + 32), "delegate", v47, v49);
      [v12 endSessionWithReason:13];
      goto LABEL_42;
    }
  }
}

void sub_1002EA494(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = +[IDSFoundationLog IDSDSession];
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  if (!v5 || v6)
  {
    if (v8)
    {
      CFStringRef v13 = [*(id *)(a1 + 32) sharedState];
      unsigned int v14 = [v13 isScreenSharingSession];
      CFStringRef v15 = @"NO";
      if (v14) {
        CFStringRef v15 = @"YES";
      }
      int v17 = 138412546;
      id v18 = v6;
      __int16 v19 = 2112;
      CFStringRef v20 = v15;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Failed to get connection data with error %@, isScreenSharingSession %@", (uint8_t *)&v17, 0x16u);
    }
    CFStringRef v16 = [*(id *)(a1 + 32) delegate];
    [v16 endSessionWithReason:8];
  }
  else
  {
    if (v8)
    {
      int v9 = self;
      int v10 = [v9 sharedState];
      unsigned int v11 = [v10 isScreenSharingSession];
      CFStringRef v12 = @"NO";
      if (v11) {
        CFStringRef v12 = @"YES";
      }
      int v17 = 138412546;
      id v18 = v5;
      __int16 v19 = 2112;
      CFStringRef v20 = v12;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Got connection data %@, isScreenSharingSession %@", (uint8_t *)&v17, 0x16u);
    }
    [*(id *)(a1 + 32) _sendInvitationMessageToDestinations:*(void *)(a1 + 40) withOptions:*(void *)(a1 + 48) contextData:*(void *)(a1 + 56) declineOnError:*(unsigned __int8 *)(a1 + 64) connectionData:v5];
  }
}

void sub_1002EA66C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = +[IDSFoundationLog IDSDSession];
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  if (!v5 || v6)
  {
    if (v8)
    {
      CFStringRef v12 = [*(id *)(a1 + 32) sharedState];
      unsigned int v13 = [v12 isScreenSharingSession];
      CFStringRef v14 = @"NO";
      if (v13) {
        CFStringRef v14 = @"YES";
      }
      int v18 = 138412546;
      id v19 = v6;
      __int16 v20 = 2112;
      CFStringRef v21 = v14;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Failed to get connection data with error %@, isScreenSharingSession %@", (uint8_t *)&v18, 0x16u);
    }
    CFStringRef v15 = [*(id *)(a1 + 32) sharedState];
    unsigned int v16 = [v15 state];

    if (v16 < 4)
    {
      int v17 = [*(id *)(a1 + 32) delegate];
      [v17 endSessionWithReason:8];
    }
    else
    {
      int v17 = +[IDSFoundationLog IDSDSession];
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v18) = 0;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Not ending this session as it's still being connected or already connected", (uint8_t *)&v18, 2u);
      }
    }
  }
  else
  {
    if (v8)
    {
      int v9 = [*(id *)(a1 + 32) sharedState];
      unsigned int v10 = [v9 isScreenSharingSession];
      CFStringRef v11 = @"NO";
      if (v10) {
        CFStringRef v11 = @"YES";
      }
      int v18 = 138412546;
      id v19 = v5;
      __int16 v20 = 2112;
      CFStringRef v21 = v11;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Got connection data %@, isScreenSharingSession %@", (uint8_t *)&v18, 0x16u);
    }
    [*(id *)(a1 + 32) _sendInvitationMessageToDestinations:*(void *)(a1 + 40) withOptions:*(void *)(a1 + 48) contextData:*(void *)(a1 + 56) declineOnError:*(unsigned __int8 *)(a1 + 64) connectionData:v5];
  }
}

void sub_1002EB5F0(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v33 = a3;
  id v8 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  if (WeakRetained)
  {
    unsigned int v10 = [*(id *)(a1 + 32) sharedState];
    unsigned int v11 = [v10 enableQuickRelay];

    CFStringRef v12 = +[IDSFoundationLog IDSDSession];
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v13 = [*(id *)(a1 + 32) sharedState];
      unsigned int v14 = [v13 isScreenSharingSession];
      CFStringRef v15 = @"NO";
      if (v14) {
        CFStringRef v16 = @"YES";
      }
      else {
        CFStringRef v16 = @"NO";
      }
      *(_DWORD *)buf = 138412802;
      CFStringRef v35 = v16;
      __int16 v36 = 2112;
      if (v11) {
        CFStringRef v15 = @"YES";
      }
      CFStringRef v37 = v15;
      __int16 v38 = 2112;
      id v39 = v7;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Sent message {isScreenSharingSession: %@, isLegacyOverride: %@, destinations: %@}", buf, 0x20u);
    }
    int v17 = [*(id *)(a1 + 32) sharedState];
    unsigned int v18 = [v17 isScreenSharingSession];

    if (v18 | v11)
    {
      id v19 = objc_msgSend(v7, "__imSetFromArray");
      __int16 v20 = [*(id *)(a1 + 32) sharedState];
      [v20 setDestinations:v19];
    }
    if ([v7 count])
    {
      objc_msgSend(v7, "__imArrayByApplyingBlock:", &stru_100988410);
      CFStringRef v21 = (__CFString *)objc_claimAutoreleasedReturnValue();
      id v22 = [v8 objectForKey:IDSRegistrationPropertyIsC2KEquipment];
      BOOL v23 = [v22 count] != 0;

      __int16 v24 = *(void **)(a1 + 40);
      BOOL v25 = [*(id *)(a1 + 32) sharedState];
      uint64_t v26 = [v25 uniqueID];
      uint64_t v27 = +[NSSet setWithArray:v21];
      [v24 session:v26 invitationSentToTokens:v27 shouldBreakBeforeMake:v23];

      *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
      __int16 v28 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v29 = [*(id *)(a1 + 32) sharedState];
        id v30 = [v29 uniqueID];
        *(_DWORD *)buf = 138412546;
        CFStringRef v35 = v30;
        __int16 v36 = 2112;
        CFStringRef v37 = v21;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "session %@ invitation sent to tokens %@", buf, 0x16u);
      }
      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        unsigned int v31 = [*(id *)(a1 + 32) sharedState];
        id v32 = [v31 uniqueID];
        _IDSLogV();
      }
    }
  }
}

id sub_1002EB97C(id a1, IDSURI *a2)
{
  id v2 = a2;
  id v3 = [(IDSURI *)v2 pushToken];
  if (v3)
  {
    uint64_t v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      unsigned int v10 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "pulled out token %@ from destination", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      id v8 = v3;
      _IDSLogV();
    }
    id v5 = [(IDSURI *)v3 rawToken];
  }
  else
  {
    id v6 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      unsigned int v10 = v2;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "skipping destination %@, can't find token", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    id v5 = 0;
  }

  return v5;
}

void sub_1002EBB7C(uint64_t a1, void *a2)
{
  if ([a2 lastCall] && !*(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24))
  {
    id v3 = *(void **)(a1 + 32);
    id v6 = [*(id *)(a1 + 40) sharedState];
    uint64_t v4 = [v6 uniqueID];
    id v5 = +[NSSet set];
    [v3 session:v4 invitationSentToTokens:v5 shouldBreakBeforeMake:0];
  }
}

void sub_1002ED9E8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = v6;
  if (!v5 || v6)
  {
    CFStringRef v12 = +[IDSFoundationLog IDSDSession];
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      id v19 = v7;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Failed to get legacy connection data with error %@", buf, 0xCu);
    }

    unsigned int v13 = [*(id *)(a1 + 32) sharedState];
    unsigned int v14 = [v13 isScreenSharingSession];

    if (v14)
    {
      CFStringRef v15 = [*(id *)(a1 + 32) delegate];
      [v15 handleAVConferenceError:v7];
    }
    CFStringRef v16 = [*(id *)(a1 + 32) delegate];
    [v16 endSessionWithReason:8];
  }
  else
  {
    id v8 = [*(id *)(a1 + 32) sharedState];
    int v9 = [v8 connection];
    unsigned int v10 = [*(id *)(a1 + 32) sharedState];
    id v11 = [v10 peerProtocolVersion];
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 3221225472;
    v17[2] = sub_1002EDBCC;
    v17[3] = &unk_100981208;
    v17[4] = *(void *)(a1 + 32);
    [v9 startConnectionAsInitiator:0 peerProtocolVersion:v11 errorHandler:v17];

    [*(id *)(a1 + 32) _sendAcceptMessageWithContext:*(void *)(a1 + 40) connectionData:v5];
  }
}

void sub_1002EDBCC(uint64_t a1, void *a2)
{
  if (a2)
  {
    id v2 = *(void **)(a1 + 32);
    id v3 = a2;
    id v4 = [v2 delegate];
    [v4 handleAVConferenceError:v3];
  }
}

void sub_1002EE4D8(uint64_t a1)
{
  id v1 = *(_OWORD **)(a1 + 32);
  *(_OWORD *)((char *)v1 + 44) = 0u;
  v1[1] = 0u;
  v1[2] = 0u;
  *id v1 = 0u;
  free(*(void **)(a1 + 32));
}

id sub_1002F0618(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  id v6 = [a2 objectForKey:v5];
  if (objc_opt_isKindOfClass())
  {
    id v7 = v6;
  }
  else
  {
    if (v6)
    {
      id v8 = +[IMRGLog registration];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
        sub_10071E710((uint64_t)v5, a1, v8);
      }
    }
    id v7 = 0;
  }

  return v7;
}

void sub_1002F06D4(uint64_t a1, void *a2)
{
  if (a2)
  {
    id v2 = *(void **)(a1 + 32);
    id v3 = a2;
    id v4 = [v2 delegate];
    [v4 handleAVConferenceError:v3];
  }
}

void sub_1002F132C(id *a1)
{
  uint64_t v2 = IDSDSessionMessageContext;
  id v3 = [a1[4] objectForKey:IDSDSessionMessageContext];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v4 = [a1[4] objectForKey:v2];
    uint64_t v5 = +[NSData _IDSDataFromBase64String:v4];
LABEL_5:
    id v19 = (id)v5;
    goto LABEL_7;
  }
  id v4 = [a1[4] objectForKey:v2];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v5 = [a1[4] objectForKey:v2];
    goto LABEL_5;
  }
  id v19 = 0;
LABEL_7:

  id v6 = objc_alloc_init((Class)IMMessageContext);
  [v6 setShouldBoost:1];
  id v7 = +[IDSDaemon sharedInstance];
  id v8 = [a1[5] sharedState];
  int v9 = [v8 pushTopic];
  unsigned int v10 = [v7 broadcasterForTopic:v9 entitlement:kIDSSessionEntitlement command:0 messageContext:v6];

  id v11 = [a1[5] sharedState];
  CFStringRef v12 = [v11 uniqueID];
  unsigned int v13 = [a1[6] prefixedURI];
  [v10 sessionCancelReceived:v12 fromID:v13 withData:v19];

  uint64_t v14 = objc_opt_class();
  CFStringRef v15 = sub_1002F0618(v14, a1[4], IDSDSessionMessageRemoteEndReason);
  CFStringRef v16 = v15;
  if (v15) {
    uint64_t v17 = (uint64_t)[v15 intValue];
  }
  else {
    uint64_t v17 = 5;
  }
  unsigned int v18 = [a1[5] delegate];
  [v18 endSessionWithReason:v17];
}

void sub_1002F1728(id a1)
{
  id v1 = objc_alloc_init(IDSDGroupContextController);
  uint64_t v2 = qword_100A4C700;
  qword_100A4C700 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_1002F19B8(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 state];
  if (v4 == (id)1)
  {
    id v8 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v9 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Failed to get Context", v9, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    id v6 = [v3 error];
    id v7 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
    goto LABEL_15;
  }
  if (!v4)
  {
    uint64_t v5 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Got Context", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    id v6 = [v3 value];
    id v7 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
LABEL_15:
    v7();
  }
}

void sub_1002F1D24(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = v6;
  if (!v5 || v6)
  {
    unsigned int v13 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138543618;
      id v24 = v7;
      __int16 v25 = 2114;
      id v26 = v5;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Upsert group -- Failed {error: %{public}@, context: %{public}@}", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    (*(void (**)(void, void))(*(void *)(a1 + 48) + 16))(*(void *)(a1 + 48), 0);
  }
  else
  {
    id v8 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      id v24 = v5;
      __int16 v25 = 2112;
      id v26 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Got Deaemon Group Context %@, error %@", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      id v17 = v5;
      uint64_t v18 = 0;
      _IDSLogV();
    }
    if (*(void *)(a1 + 32))
    {
      int v9 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Updating Group", buf, 2u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        _IDSLogV();
      }
      uint64_t v10 = *(void *)(a1 + 32);
      id v11 = objc_msgSend(*(id *)(a1 + 40), "participants", v17, v18);
      CFStringRef v12 = [*(id *)(a1 + 40) sharedApplicationData];
      v21[0] = _NSConcreteStackBlock;
      v21[1] = 3221225472;
      v21[2] = sub_1002F21C8;
      v21[3] = &unk_100982998;
      id v22 = *(id *)(a1 + 48);
      [v5 updateGroup:v10 withParticipants:v11 sharedApplicationData:v12 completion:v21];
    }
    else
    {
      uint64_t v14 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Creating New Group", buf, 2u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        _IDSLogV();
      }
      CFStringRef v15 = objc_msgSend(*(id *)(a1 + 40), "participants", v17, v18);
      CFStringRef v16 = [*(id *)(a1 + 40) sharedApplicationData];
      v19[0] = _NSConcreteStackBlock;
      v19[1] = 3221225472;
      v19[2] = sub_1002F21D8;
      v19[3] = &unk_100982998;
      id v20 = *(id *)(a1 + 48);
      [v5 createGroupWithParticipants:v15 sharedApplicationData:v16 completion:v19];
    }
  }
}

uint64_t sub_1002F21C8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1002F21D8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    id v9 = v5;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "New Group Created %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32));
}

void sub_1002F24C0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = v6;
  if (!v5 || v6)
  {
    id v9 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138543618;
      uint64_t v14 = v7;
      __int16 v15 = 2114;
      uint64_t v16 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Failed to fetch group by groupID {error: %{public}@, groupID: %{public}@}", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    (*(void (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), 0);
  }
  else
  {
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    v11[2] = sub_1002F2694;
    v11[3] = &unk_100982998;
    uint64_t v8 = *(void *)(a1 + 32);
    id v12 = *(id *)(a1 + 40);
    [v5 fetchGroupWithGroupID:v8 completion:v11];
  }
}

uint64_t sub_1002F2694(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1002F2764(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = v6;
  if (!v5 || v6)
  {
    id v9 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138543618;
      uint64_t v14 = v7;
      __int16 v15 = 2114;
      uint64_t v16 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Failed to get public data representation {error: %{public}@, group: %{public}@}", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    (*(void (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), 0);
  }
  else
  {
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    v11[2] = sub_1002F2938;
    v11[3] = &unk_1009884F8;
    uint64_t v8 = *(void *)(a1 + 32);
    id v12 = *(id *)(a1 + 40);
    [v5 _publicDataRepresentationForGroup:v8 completion:v11];
  }
}

uint64_t sub_1002F2938(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1002F2A08(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = v6;
  if (!v5 || v6)
  {
    id v9 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138543362;
      unsigned int v13 = v7;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Failed to get group from public data representation -- missing context {error: %{public}@}", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40));
  }
  else
  {
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_1002F2BC8;
    v10[3] = &unk_100982998;
    uint64_t v8 = *(void *)(a1 + 32);
    id v11 = *(id *)(a1 + 40);
    [v5 _groupFromPublicDataRepresentation:v8 completion:v10];
  }
}

uint64_t sub_1002F2BC8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1002F2C98(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = v6;
  if (!v5 || v6)
  {
    id v9 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138543362;
      unsigned int v13 = v7;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Failed to get participnats for cypher -- missing context {error: %{public}@}", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40));
  }
  else
  {
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_1002F2E58;
    v10[3] = &unk_100988520;
    uint64_t v8 = *(void *)(a1 + 32);
    id v11 = *(id *)(a1 + 40);
    [v5 _participantsForCypher:v8 completion:v10];
  }
}

uint64_t sub_1002F2E58(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1002F2F4C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = v6;
  if (!v5 || v6)
  {
    uint64_t v10 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138543362;
      uint64_t v14 = v7;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Failed to validate cached group -- missing context {error: %{public}@}", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))(*(void *)(a1 + 48));
  }
  else
  {
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v9 = *(void *)(a1 + 40);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    v11[2] = sub_1002F3114;
    v11[3] = &unk_100980658;
    id v12 = *(id *)(a1 + 48);
    [v5 _validateCachedGroup:v8 isParentOfGroup:v9 completion:v11];
  }
}

uint64_t sub_1002F3114(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1002F31E0(uint64_t a1, void *a2)
{
  if (a2)
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    v5[2] = sub_1002F32A0;
    v5[3] = &unk_100982998;
    uint64_t v3 = *(void *)(a1 + 32);
    id v6 = *(id *)(a1 + 40);
    [a2 fetchLatestGroupWithStableID:v3 completion:v5];
  }
  else
  {
    id v4 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
    v4();
  }
}

uint64_t sub_1002F32A0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1002F3344(uint64_t a1, void *a2)
{
  if (a2)
  {
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472;
    v4[2] = sub_1002F3400;
    v4[3] = &unk_100988548;
    id v5 = *(id *)(a1 + 32);
    [a2 _fetchAllLocalKnownGroups:v4];
  }
  else
  {
    uint64_t v3 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
    v3();
  }
}

void sub_1002F3400(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (a2)
  {
    id v5 = [a2 allObjects];
    (*(void (**)(uint64_t, id))(v2 + 16))(v2, v5);
  }
  else
  {
    uint64_t v3 = *(void (**)(uint64_t, void *))(v2 + 16);
    uint64_t v4 = *(void *)(a1 + 32);
    v3(v4, &__NSArray0__struct);
  }
}

void sub_1002F3534(uint64_t a1, void *a2)
{
  if (a2)
  {
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472;
    v4[2] = sub_1002F35F0;
    v4[3] = &unk_10097E7F0;
    id v5 = *(id *)(a1 + 32);
    [a2 _dropLocalCache:v4];
  }
  else
  {
    uint64_t v3 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
    v3();
  }
}

uint64_t sub_1002F35F0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1002F36C0(uint64_t a1, void *a2)
{
  if (a2)
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    v5[2] = sub_1002F3780;
    v5[3] = &unk_10097E7F0;
    uint64_t v3 = *(void *)(a1 + 32);
    id v6 = *(id *)(a1 + 40);
    [a2 _dropLocalCacheForGroupID:v3 compeltion:v5];
  }
  else
  {
    uint64_t v4 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
    v4();
  }
}

uint64_t sub_1002F3780(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1002F388C(id a1, ENGroupContext *a2, NSError *a3)
{
  uint64_t v4 = a2;
  id v5 = a3;
  id v6 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412546;
    uint64_t v10 = v4;
    __int16 v11 = 2112;
    id v12 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Noting registration identity update {context: %@, error: %@}", buf, 0x16u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    id v7 = v4;
    uint64_t v8 = v5;
    _IDSLogV();
  }
  [(ENGroupContext *)v4 _noteRegistrationIdentityUpdate];
}

uint64_t sub_1002F3A5C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1002F3E0C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    uint64_t v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Core Data Load Failed", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    id v5 = [*(id *)(a1 + 32) seal];
    [v5 failWithError:v3];
  }
  else
  {
    id v6 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v7 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Core Data Load sucdeeded", v7, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    id v5 = [*(id *)(a1 + 32) seal];
    [v5 fulfillWithValue:*(void *)(a1 + 40)];
  }
}

id sub_1002F5FEC(uint64_t a1)
{
  id v1 = +[NSString stringWithFormat:@"disable-live-delivery-%@", a1];
  uint64_t v2 = +[IDSServerBag sharedInstance];
  id v3 = [v2 objectForKey:v1];

  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    id v4 = [v3 BOOLValue];
  }
  else {
    id v4 = 0;
  }

  return v4;
}

id sub_1002F60A4()
{
  v0 = +[IDSServerBag sharedInstance];
  id v1 = [v0 objectForKey:@"disable-live-delivery-all"];

  if (v1 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    id v2 = [v1 BOOLValue];
  }
  else {
    id v2 = 0;
  }

  return v2;
}

id sub_1002F6128(id a1, NSDictionary *a2)
{
  id v2 = [(NSDictionary *)a2 _stringForKey:IDSDevicePropertyIdentitiesURI];
  id v3 = [v2 _stripFZIDPrefix];

  return v3;
}

id sub_1002F6184(id a1, NSDictionary *a2)
{
  id v2 = [(NSDictionary *)a2 _stringForKey:IDSDevicePropertyIdentitiesURI];
  id v3 = [v2 _stripFZIDPrefix];

  return v3;
}

id sub_1002F61E0(uint64_t a1)
{
  return [*(id *)(a1 + 32) enableCloudConnection];
}

void sub_1002F61E8(id a1)
{
  int v1 = IMGetDomainBoolForKey();
  byte_100A4C708 = v1;
  if (v1)
  {
    id v2 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)id v3 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "**** Local IDS connectivity is disabled, only using cloud ****", v3, 2u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      _IDSLogTransport();
    }
  }
}

id sub_1002F70F8(id a1, id a2)
{
  return [a2 objectForKey:IDSDevicePairedDeviceID];
}

uint64_t sub_1002F710C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1002F711C(uint64_t a1)
{
}

void sub_1002F7124(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  im_assert_primary_base_queue();
  id v7 = +[IDSDAccountController sharedInstance];
  uint64_t v8 = [*(id *)(a1 + 32) accountUUID];
  uint64_t v9 = [v7 accountWithUniqueID:v8];

  if (v9)
  {
    uint64_t v10 = *(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 40);
    unsigned int v11 = [*(id *)(a1 + 40) containsObject:v6];
    unsigned int v12 = [*(id *)(a1 + 48) containsObject:v6];
    unsigned int v13 = v12;
    if (v10 || (v11 & 1) != 0 || !v12)
    {
      BOOL v23 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v24 = @"NO";
        *(_DWORD *)buf = 138413314;
        id v67 = v5;
        if (v10) {
          CFStringRef v25 = @"YES";
        }
        else {
          CFStringRef v25 = @"NO";
        }
        if (v11) {
          CFStringRef v26 = @"YES";
        }
        else {
          CFStringRef v26 = @"NO";
        }
        if (!v13) {
          CFStringRef v24 = @"YES";
        }
        __int16 v68 = 2112;
        id v69 = v6;
        __int16 v70 = 2112;
        CFStringRef v71 = v25;
        __int16 v72 = 2112;
        CFStringRef v73 = v26;
        __int16 v74 = 2112;
        CFStringRef v75 = v24;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Fallback won't sent for %@ %@  alreadyFailed %@ alreadySending %@ alreadyComplete %@", buf, 0x34u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        goto LABEL_36;
      }
    }
    else
    {
      unsigned __int8 v14 = [*(id *)(a1 + 32) localDelivery];
      if (!v6
        || (v14 & 1) != 0
        || ([v5 isEqualToString:IDSDefaultPairedDevice] & 1) != 0
        || [v5 localizedCaseInsensitiveContainsString:@"__localURI__"])
      {
        __int16 v15 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v16 = [*(id *)(a1 + 32) localDelivery];
          CFStringRef v17 = @"NO";
          *(_DWORD *)buf = 138412802;
          id v67 = v5;
          __int16 v68 = 2112;
          if (v16) {
            CFStringRef v17 = @"YES";
          }
          id v69 = v6;
          __int16 v70 = 2112;
          CFStringRef v71 = v17;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Ignoring request to fallback for %@ %@ forcedLocal %@", buf, 0x20u);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
        {
          [*(id *)(a1 + 32) localDelivery];
LABEL_36:
          _IDSLogV();
        }
      }
      else
      {
        uint64_t v27 = +[IDSTrafficMonitor sharedInstance];
        __int16 v28 = [v9 service];
        unsigned int v29 = [v28 identifier];
        id v30 = [v9 service];
        unsigned __int8 v31 = objc_msgSend(v27, "noteOutgoingFallbackMessageForService:serviceType:requestor:", v29, objc_msgSend(v30, "adHocServiceType"), 0);

        if (v31)
        {
          v55[0] = _NSConcreteStackBlock;
          v55[1] = 3221225472;
          v55[2] = sub_1002F7B08;
          v55[3] = &unk_100988658;
          id v56 = *(id *)(a1 + 32);
          id v32 = v5;
          id v57 = v32;
          CFStringRef v53 = (const __CFString *)v6;
          v58 = (__CFString *)v53;
          id v59 = *(id *)(a1 + 48);
          id v60 = *(id *)(a1 + 40);
          long long v64 = *(_OWORD *)(a1 + 96);
          id v33 = *(id *)(a1 + 56);
          uint64_t v34 = *(void *)(a1 + 112);
          id v61 = v33;
          uint64_t v65 = v34;
          id v62 = *(id *)(a1 + 64);
          id v63 = *(id *)(a1 + 88);
          v54 = objc_retainBlock(v55);
          id v35 = [*(id *)(a1 + 32) copy];
          __int16 v36 = +[IDSURI URIWithPrefixedURI:v32];
          CFStringRef v37 = +[NSArray arrayWithObject:v36];
          [v35 setFinalDestinationURIs:v37];

          [v35 setWantsResponse:1];
          if ([v35 priority] == (id)200) {
            [v35 setPriority:300];
          }
          __int16 v38 = OSLogHandleForTransportCategory();
          if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
          {
            id v39 = [*(id *)(a1 + 32) messageUUID];
            __int16 v40 = [v9 uniqueID];
            *(_DWORD *)buf = 138413058;
            id v67 = v39;
            __int16 v68 = 2112;
            id v69 = v32;
            __int16 v70 = 2112;
            CFStringRef v71 = v53;
            __int16 v72 = 2112;
            CFStringRef v73 = v40;
            _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "Initiating fallback send for message %@ to %@ %@ from account %@", buf, 0x2Au);
          }
          if (os_log_shim_legacy_logging_enabled())
          {
            if (_IDSShouldLogTransport())
            {
              CFStringRef v41 = [*(id *)(a1 + 32) messageUUID];
              [v9 uniqueID];
              v52 = CFStringRef v50 = v53;
              CFStringRef v47 = v41;
              id v49 = v32;
              _IDSLogTransport();

              if (_IDSShouldLog())
              {
                id v42 = objc_msgSend(*(id *)(a1 + 32), "messageUUID", v41, v32, v53, v52);
                [v9 uniqueID];
                v52 = CFStringRef v50 = v53;
                CFStringRef v47 = v42;
                id v49 = v32;
                _IDSLogV();
              }
            }
          }
          objc_msgSend(*(id *)(a1 + 40), "addObject:", v53, v47, v49, v50, v52);
          [v9 _sendRemotelyWithSendParameters:v35 data:*(void *)(a1 + 72) protobuf:*(void *)(a1 + 80) willSendBlock:0 completionBlock:v54];
        }
        else
        {
          __int16 v43 = OSLogHandleForTransportCategory();
          if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
          {
            unsigned int v44 = [*(id *)(a1 + 32) localDelivery];
            CFStringRef v45 = @"NO";
            *(_DWORD *)buf = 138412802;
            id v67 = v5;
            __int16 v68 = 2112;
            if (v44) {
              CFStringRef v45 = @"YES";
            }
            id v69 = v6;
            __int16 v70 = 2112;
            CFStringRef v71 = v45;
            _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "Ignoring request to fallback for %@ %@ forcedLocal %@ due to budget restrictions.", buf, 0x20u);
          }

          if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
          {
            CFStringRef v46 = [*(id *)(a1 + 32) localDelivery] ? @"YES" : @"NO";
            NSErrorUserInfoKey v51 = v46;
            _IDSLogTransport();
            if (_IDSShouldLog())
            {
              objc_msgSend(*(id *)(a1 + 32), "localDelivery", v5, v6, v51);
              goto LABEL_36;
            }
          }
        }
      }
    }
  }
  else
  {
    uint64_t v18 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      id v19 = [*(id *)(a1 + 32) accountUUID];
      *(_DWORD *)buf = 138412290;
      id v67 = v19;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "(Account) No account found for ID: %@", buf, 0xCu);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      uint64_t v48 = [*(id *)(a1 + 32) accountUUID];
      _IDSLogV();
    }
    IMLogBacktrace();
    id v20 = objc_alloc((Class)NSError);
    id v21 = [v20 initWithDomain:IDSSendErrorDomain code:2 userInfo:0];
    if (*(void *)(a1 + 88))
    {
      id v22 = objc_alloc_init((Class)IDSDeliveryContext);
      [v22 setResponseError:v21];
      [v22 setIdsResponseCode:2];
      [v22 setLastCall:1];
      (*(void (**)(void))(*(void *)(a1 + 88) + 16))(*(void *)(a1 + 88));
    }
  }
}

void sub_1002F7A90(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1002F79E8);
  }
  _Unwind_Resume(a1);
}

void sub_1002F7B08(uint64_t a1, void *a2)
{
  id v3 = a2;
  im_assert_primary_base_queue();
  id v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = [*(id *)(a1 + 32) messageUUID];
    uint64_t v7 = *(void *)(a1 + 40);
    uint64_t v6 = *(void *)(a1 + 48);
    id v8 = [v3 idsResponseCode];
    id v9 = [v3 responseError];
    unsigned int v10 = [v3 lastCall];
    CFStringRef v11 = @"NO";
    uint64_t v12 = *(void *)(a1 + 56);
    uint64_t v13 = *(void *)(a1 + 64);
    if (v10) {
      CFStringRef v11 = @"YES";
    }
    *(_DWORD *)buf = 138414082;
    id v58 = v5;
    __int16 v59 = 2112;
    uint64_t v60 = v7;
    __int16 v61 = 2112;
    uint64_t v62 = v6;
    __int16 v63 = 2048;
    id v64 = v8;
    __int16 v65 = 2112;
    id v66 = v9;
    __int16 v67 = 2112;
    CFStringRef v68 = v11;
    __int16 v69 = 2112;
    uint64_t v70 = v12;
    __int16 v71 = 2112;
    uint64_t v72 = v13;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Fallback send of %@ to %@ %@ completed with responseCode %ld error %@ lastCall %@ - current pending sends local %@ fallback %@", buf, 0x52u);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    unsigned __int8 v14 = [*(id *)(a1 + 32) messageUUID];
    uint64_t v15 = *(void *)(a1 + 40);
    uint64_t v16 = *(void *)(a1 + 48);
    id v17 = [v3 idsResponseCode];
    uint64_t v18 = [v3 responseError];
    unsigned int v19 = [v3 lastCall];
    CFStringRef v20 = @"NO";
    if (v19) {
      CFStringRef v20 = @"YES";
    }
    uint64_t v55 = *(void *)(a1 + 56);
    uint64_t v56 = *(void *)(a1 + 64);
    CFStringRef v53 = v18;
    CFStringRef v54 = v20;
    uint64_t v51 = v16;
    id v52 = v17;
    id v49 = v14;
    uint64_t v50 = v15;
    _IDSLogV();
  }
  if (objc_msgSend(v3, "lastCall", v49, v50, v51, v52, v53, v54, v55, v56))
  {
    id v21 = [v3 idsResponseCode];
    if (v21)
    {
      if (*(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 40))
      {
LABEL_23:
        BOOL v39 = v21 == 0;
        id v40 = [*(id *)(a1 + 56) count];
        uint64_t v41 = (uint64_t)[*(id *)(a1 + 64) count];
        [*(id *)(a1 + 64) removeObject:*(void *)(a1 + 48)];
        if (v39) {
          [*(id *)(a1 + 56) removeObject:*(void *)(a1 + 48)];
        }
        BOOL v42 = v40 != (id)-v41;
        id v43 = [*(id *)(a1 + 56) count];
        if ((char *)[*(id *)(a1 + 64) count] + (void)v43) {
          BOOL v44 = 0;
        }
        else {
          BOOL v44 = v42;
        }
        if (v44)
        {
          if (*(void *)(a1 + 88))
          {
            id v45 = objc_alloc_init((Class)IDSDeliveryContext);
            [v45 setIdsResponseCode:*(void *)(*(void *)(*(void *)(a1 + 104) + 8) + 24)];
            [v45 setResponseError:*(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 40)];
            [v45 setLastCall:1];
            CFStringRef v46 = [v3 endpointState];
            [v45 setEndpointState:v46];

            (*(void (**)(void))(*(void *)(a1 + 88) + 16))();
          }
          uint64_t v47 = *(void *)(*(void *)(a1 + 96) + 8);
          uint64_t v48 = *(void **)(v47 + 40);
          *(void *)(v47 + 40) = 0;
        }
        goto LABEL_32;
      }
      *(void *)(*(void *)(*(void *)(a1 + 104) + 8) + 24) = [v3 idsResponseCode];
      uint64_t v22 = [v3 responseError];
      uint64_t v23 = *(void *)(*(void *)(a1 + 96) + 8);
      id v24 = *(id *)(v23 + 40);
      *(void *)(v23 + 40) = v22;
    }
    else
    {
      CFStringRef v25 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Overwriting previous local failure with remote success", buf, 2u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        _IDSLogV();
      }
      *(void *)(*(void *)(*(void *)(a1 + 104) + 8) + 24) = 0;
      uint64_t v26 = *(void *)(*(void *)(a1 + 96) + 8);
      uint64_t v27 = *(void **)(v26 + 40);
      *(void *)(v26 + 40) = 0;

      if (![*(id *)(a1 + 48) isEqualToString:IDSDeviceDefaultPairedDeviceUniqueID]) {
        goto LABEL_23;
      }
      id v24 = objc_msgSend(objc_alloc((Class)IDSLocalDeliveryMessageSentMetric), "initWithService:isToDefaultPairedDevice:messageSize:linkType:priority:", *(void *)(a1 + 72), 1, *(void *)(a1 + 112), 4, objc_msgSend(*(id *)(a1 + 32), "priority"));
      __int16 v28 = +[IDSCoreAnalyticsLogger defaultLogger];
      [v28 logMetric:v24];

      unsigned int v29 = +[IDSAWDLogging sharedInstance];
      objc_msgSend(v29, "messageSentForService:isToDefaultPairedDevice:messageSize:linkType:priority:", *(void *)(a1 + 72), 1, *(void *)(a1 + 112), 4, objc_msgSend(*(id *)(a1 + 32), "priority"));

      id v30 = +[IDSUTunDeliveryController sharedInstance];
      unsigned __int8 v31 = [*(id *)(a1 + 32) messageUUID];
      id v32 = JWUUIDPushObjectToString();
      [v30 cancelMessageID:v32];

      if ([*(id *)(a1 + 80) adHocServiceType] == 2)
      {
        id v33 = objc_alloc((Class)IDSLocalDeliveryMessageDeliveredMetric);
        uint64_t v34 = [*(id *)(a1 + 80) identifier];
        id v35 = [v33 initWithService:v34 isToDefaultPairedDevice:1 messageSize:0 linkType:4 deliveryError:0 RTT:0 priority:0];

        __int16 v36 = +[IDSCoreAnalyticsLogger defaultLogger];
        [v36 logMetric:v35];

        CFStringRef v37 = +[IDSAWDLogging sharedInstance];
        __int16 v38 = [*(id *)(a1 + 80) identifier];
        [v37 messageDeliveredForService:v38 isToDefaultPairedDevice:1 messageSize:0 linkType:4 deliveryError:0 RTT:0 priority:0];
      }
    }

    goto LABEL_23;
  }
LABEL_32:
}

void sub_1002F8154(uint64_t a1, void *a2)
{
  id v3 = a2;
  im_assert_primary_base_queue();
  id v4 = [v3 idsResponseCode];
  id v5 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = [*(id *)(a1 + 32) messageUUID];
    id v7 = [v3 deviceID];
    uint64_t v9 = *(void *)(a1 + 48);
    uint64_t v8 = *(void *)(a1 + 56);
    uint64_t v10 = *(void *)(a1 + 40);
    uint64_t v11 = [*(id *)(a1 + 32) accountUUID];
    uint64_t v12 = (void *)v11;
    CFStringRef v13 = @"NO";
    *(_DWORD *)buf = 138414082;
    *(void *)&uint8_t buf[4] = v6;
    if (!v4) {
      CFStringRef v13 = @"YES";
    }
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v7;
    __int16 v46 = 2112;
    CFStringRef v47 = v13;
    __int16 v48 = 2048;
    id v49 = v4;
    __int16 v50 = 2112;
    uint64_t v51 = v10;
    __int16 v52 = 2112;
    uint64_t v53 = v9;
    __int16 v54 = 2112;
    uint64_t v55 = v8;
    __int16 v56 = 2112;
    uint64_t v57 = v11;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "IDSUTunDeliveryController sendMessage %@ deviceID %@ succeeded? %@ response %ld topic: %@ - current pending sends local %@ fallback %@ account %@", buf, 0x52u);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    unsigned __int8 v14 = [*(id *)(a1 + 32) messageUUID];
    uint64_t v15 = [v3 deviceID];
    if (v4) {
      CFStringRef v16 = @"NO";
    }
    else {
      CFStringRef v16 = @"YES";
    }
    uint64_t v17 = *(void *)(a1 + 40);
    uint64_t v18 = *(void *)(a1 + 48);
    uint64_t v19 = *(void *)(a1 + 56);
    [*(id *)(a1 + 32) accountUUID];
    v44 = uint64_t v43 = v19;
    uint64_t v41 = v17;
    uint64_t v42 = v18;
    CFStringRef v39 = v16;
    id v40 = v4;
    CFStringRef v37 = v14;
    __int16 v38 = v15;
    _IDSLogV();
  }
  if (v4)
  {
    if (*(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 40)) {
      goto LABEL_16;
    }
    *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) = v4;
    id v20 = objc_alloc((Class)NSError);
    id v21 = [v20 initWithDomain:IDSSendErrorDomain code:v4 userInfo:0];
    uint64_t v22 = *(void *)(*(void *)(a1 + 72) + 8);
    uint64_t v23 = *(void **)(v22 + 40);
    *(void *)(v22 + 40) = v21;
  }
  else
  {
    *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) = 0;
    uint64_t v24 = *(void *)(*(void *)(a1 + 72) + 8);
    uint64_t v23 = *(void **)(v24 + 40);
    *(void *)(v24 + 40) = 0;
  }

LABEL_16:
  BOOL v25 = v4 == 0;
  id v26 = objc_msgSend(*(id *)(a1 + 48), "count", v37, v38, v39, v40, v41, v42, v43, v44, *(_OWORD *)buf);
  uint64_t v27 = (uint64_t)[*(id *)(a1 + 56) count];
  __int16 v28 = *(void **)(a1 + 48);
  unsigned int v29 = [v3 deviceID];
  [v28 removeObject:v29];

  if (v25)
  {
    id v30 = *(void **)(a1 + 56);
    unsigned __int8 v31 = [v3 deviceID];
    [v30 removeObject:v31];
  }
  BOOL v32 = v26 != (id)-v27;
  id v33 = [*(id *)(a1 + 48) count];
  if ((char *)[*(id *)(a1 + 56) count] + (void)v33) {
    BOOL v34 = 0;
  }
  else {
    BOOL v34 = v32;
  }
  if (v34)
  {
    if (*(void *)(a1 + 64))
    {
      [v3 setIdsResponseCode:*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24)];
      [v3 setResponseError:*(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 40)];
      [v3 setLastCall:1];
      (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
    }
    uint64_t v35 = *(void *)(*(void *)(a1 + 72) + 8);
    __int16 v36 = *(void **)(v35 + 40);
    *(void *)(v35 + 40) = 0;
  }
}

id sub_1002FA9AC(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 hasPrefix:@"self-token:"])
  {
    id v4 = [v3 _stripFZIDPrefix];
    id v5 = (char *)[v4 rangeOfString:@"/"];
    if (v5 == (char *)0x7FFFFFFFFFFFFFFFLL)
    {
      id v6 = v4;
    }
    else
    {
      id v6 = [v4 substringToIndex:v5];
    }
    uint64_t v8 = v6;
    uint64_t v9 = +[NSData __imDataWithHexString:v6];
    if ([v4 length] <= v5 + 1)
    {
      id v12 = *(id *)(a1 + 48);
      CFStringRef v13 = v12;
      if (v12)
      {
        id v11 = v12;
      }
      else
      {
        id v14 = *(id *)(a1 + 56);
        if ([v14 count])
        {
          objc_msgSend(v14, "__imFirstObject");
          id v11 = (id)objc_claimAutoreleasedReturnValue();
        }
        else
        {
          id v11 = 0;
        }
      }
    }
    else
    {
      uint64_t v10 = objc_msgSend(v4, "substringFromIndex:");
      if (([(id)objc_opt_class() dependentRegistration:*(void *)(a1 + 32) hasDependentRegistrationWithURI:v10 token:v9] & 1) != 0|| objc_msgSend((id)objc_opt_class(), "dependentRegistration:hasDependentRegistrationWithURI:token:", *(void *)(a1 + 40), v10, v9))
      {
        id v11 = v10;
      }
      else
      {
        uint64_t v15 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          id v20 = v3;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Couldn't resolve %@ to a valid dependent registration.", buf, 0xCu);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
        {
          id v18 = v3;
          _IDSLogV();
        }
        id v11 = 0;
      }
    }
    if (objc_msgSend(v9, "length", v18) && objc_msgSend(v11, "length"))
    {
      id v7 = (id)_IDSCopyIDForTokenWithURI();
    }
    else
    {
      CFStringRef v16 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        id v20 = v3;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Could not construct a destination for %@", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        _IDSWarnV();
        _IDSLogV();
        _IDSLogTransport();
      }
      id v7 = 0;
    }
  }
  else
  {
    id v7 = v3;
  }

  return v7;
}

id sub_1002FAD38(uint64_t a1, void *a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = a2;
  id v4 = [v2 identifier];
  id v5 = +[IDSURI URIWithPrefixedURI:v3 withServiceLoggingHint:v4];

  return v5;
}

void sub_1002FADB4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (!*(unsigned char *)(a1 + 80))
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = [v3 lastCall];
    id v5 = [v4 responseError];
    if (v5)
    {
      uint64_t v6 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40);

      if (!v6)
      {
        uint64_t v7 = [v4 responseError];
        uint64_t v8 = *(void *)(*(void *)(a1 + 56) + 8);
        uint64_t v9 = *(void **)(v8 + 40);
        *(void *)(v8 + 40) = v7;

        *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = [v4 idsResponseCode];
      }
    }
    uint64_t v10 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      id v11 = [v4 idsResponseCode];
      id v12 = [v4 responseError];
      unsigned int v13 = [v4 lastCall];
      uint64_t v14 = *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
      uint64_t v15 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
      uint64_t v16 = [*(id *)(a1 + 32) accountUUID];
      uint64_t v17 = (void *)v16;
      CFStringRef v18 = @"NO";
      *(_DWORD *)buf = 134219266;
      *(void *)&uint8_t buf[4] = v11;
      *(_WORD *)&buf[12] = 2112;
      if (v13) {
        CFStringRef v18 = @"YES";
      }
      *(void *)&buf[14] = v12;
      __int16 v34 = 2112;
      CFStringRef v35 = v18;
      __int16 v36 = 2048;
      uint64_t v37 = v14;
      __int16 v38 = 2112;
      uint64_t v39 = v15;
      __int16 v40 = 2112;
      uint64_t v41 = v16;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Local send completion block {responseCode: %ld, error: %@, lastCall: %@, combinedResponseCode: %ld, combinedError: %@, account: %@}", buf, 0x3Eu);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      id v19 = [v4 idsResponseCode];
      id v20 = [v4 responseError];
      if ([v4 lastCall]) {
        CFStringRef v21 = @"YES";
      }
      else {
        CFStringRef v21 = @"NO";
      }
      uint64_t v22 = *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
      uint64_t v23 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
      [*(id *)(a1 + 32) accountUUID];
      v32 = uint64_t v31 = v23;
      CFStringRef v29 = v21;
      uint64_t v30 = v22;
      id v27 = v19;
      __int16 v28 = v20;
      _IDSLogV();
    }
    if (*(void *)(a1 + 40))
    {
      if (*(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24)) {
        BOOL v24 = *(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) != 0;
      }
      else {
        BOOL v24 = 0;
      }
      objc_msgSend(v4, "setIdsResponseCode:", *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24), v27, v28, v29, v30, v31, v32, *(_OWORD *)buf);
      [v4 setResponseError:*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40)];
      [v4 setLastCall:v24];
      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
      if (v24)
      {
        uint64_t v25 = *(void *)(*(void *)(a1 + 56) + 8);
        id v26 = *(void **)(v25 + 40);
        *(void *)(v25 + 40) = 0;
      }
    }
  }
}

void sub_1002FB108(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v12 = a2;
  id v7 = a3;
  id v8 = a4;
  if (![*(id *)(a1 + 32) count])
  {
    id v11 = v12;
    goto LABEL_11;
  }
  if (!v12)
  {
    id v10 = *(id *)(a1 + 40);
    if (!v10)
    {
      id v9 = 0;
      goto LABEL_10;
    }
    goto LABEL_8;
  }
  id v9 = objc_alloc_init((Class)NSMutableSet);
  [v9 addObjectsFromArray:v12];
  id v10 = *(id *)(a1 + 40);
  if (v10)
  {
    if (v9)
    {
LABEL_9:
      [v9 addObjectsFromArray:v10];
      goto LABEL_10;
    }
LABEL_8:
    id v9 = objc_alloc_init((Class)NSMutableSet);
    goto LABEL_9;
  }
LABEL_10:
  id v11 = [v9 allObjects];

LABEL_11:
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

void sub_1002FB238(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 144) == 2 && *(unsigned char *)(a1 + 148))
  {
    id v2 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      id v3 = [*(id *)(a1 + 32) dictionaryRepresentation];
      *(_DWORD *)buf = 138412290;
      uint64_t v41 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Attempted to send to remote destiantions on a local account, we are allowed to proxy, beginning proxy transaction, The params are %@", buf, 0xCu);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      CFStringRef v29 = [*(id *)(a1 + 32) dictionaryRepresentation];
      _IDSLogV();
    }
    objc_msgSend(*(id *)(a1 + 32), "setIsProxiedOutgoingMessage:", 1, v29);
    id v4 = [*(id *)(a1 + 32) destinations];
    id v5 = +[NSKeyedArchiver archivedDataWithRootObject:v4 requiringSecureCoding:0 error:0];

    [*(id *)(a1 + 32) setGroupData:v5];
    [*(id *)(a1 + 32) setDestinations:0];
    id v6 = [*(id *)(a1 + 32) dictionaryRepresentation];
    id v7 = objc_alloc_init((Class)IDSSendParameters);
    [v7 setMessage:v6];
    id v8 = +[IDSDestination defaultPairedDeviceDestination];
    [v7 setDestinations:v8];

    [v7 setCommand:&off_1009D1D28];
    [v7 setPriority:300];
    id v9 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      id v10 = [v7 dictionaryRepresentation];
      *(_DWORD *)buf = 138412290;
      uint64_t v41 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "The new params we will send locally are are %@", buf, 0xCu);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      uint64_t v30 = [v7 dictionaryRepresentation];
      _IDSLogV();
    }
    id v11 = *(void **)(a1 + 136);
    uint64_t v12 = *(void *)(a1 + 40);
    uint64_t v13 = *(void *)(a1 + 48);
    v38[0] = _NSConcreteStackBlock;
    v38[1] = 3221225472;
    v38[2] = sub_1002FB924;
    v38[3] = &unk_1009828A0;
    uint64_t v14 = *(void *)(a1 + 80);
    id v39 = *(id *)(a1 + 88);
    [v11 sendMessageWithSendParameters:v7 service:v12 threadContext:v13 willSendBlock:&stru_100988760 progressBlock:v14 completionBlock:v38];
  }
  else
  {
    uint64_t v15 = +[IDSDAccountController sharedInstance];
    uint64_t v16 = [*(id *)(a1 + 32) accountUUID];
    id v5 = [v15 accountWithUniqueID:v16];

    if (v5)
    {
      id v6 = [*(id *)(a1 + 32) copy];
      uint64_t v17 = objc_msgSend(*(id *)(a1 + 56), "__imArrayByApplyingBlock:", &stru_1009887A0);
      [v6 setFinalDestinationURIs:v17];

      uint64_t v18 = *(void *)(a1 + 64);
      uint64_t v19 = *(void *)(a1 + 72);
      v32[0] = _NSConcreteStackBlock;
      v32[1] = 3221225472;
      v32[2] = sub_1002FBA24;
      v32[3] = &unk_1009887C8;
      uint64_t v20 = *(void *)(a1 + 136);
      long long v34 = *(_OWORD *)(a1 + 104);
      uint64_t v21 = *(void *)(a1 + 120);
      uint64_t v37 = v20;
      uint64_t v35 = v21;
      uint64_t v22 = *(void *)(a1 + 96);
      id v23 = *(id *)(a1 + 88);
      uint64_t v24 = *(void *)(a1 + 128);
      id v33 = v23;
      uint64_t v36 = v24;
      [v5 _sendRemotelyWithSendParameters:v6 data:v18 protobuf:v19 willSendBlock:v22 completionBlock:v32];
      id v7 = v33;
    }
    else
    {
      uint64_t v25 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        id v26 = [*(id *)(a1 + 32) accountUUID];
        *(_DWORD *)buf = 138412290;
        uint64_t v41 = v26;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "No account found for ID: %@", buf, 0xCu);
      }
      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        uint64_t v31 = [*(id *)(a1 + 32) accountUUID];
        _IDSLogV();
      }
      IMLogBacktrace();
      id v27 = objc_alloc((Class)NSError);
      id v6 = [v27 initWithDomain:IDSSendErrorDomain code:2 userInfo:0];
      id v7 = [objc_alloc((Class)IDSDeliveryContext) initWithResponseCode:2 error:v6 lastCall:1];
      uint64_t v28 = *(void *)(a1 + 88);
      if (v28) {
        (*(void (**)(uint64_t, id))(v28 + 16))(v28, v7);
      }
    }
  }
}

void sub_1002FB7E0(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1002FB6D8);
  }
  _Unwind_Resume(a1);
}

void sub_1002FB82C(id a1, NSArray *a2, NSArray *a3, NSDictionary *a4)
{
  id v6 = a2;
  id v7 = a3;
  id v8 = a4;
  id v9 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v10 = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Will Send Block", v10, 2u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
}

void sub_1002FB924(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Completiom Send Block of message called, ", v5, 2u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

IDSURI *__cdecl sub_1002FBA14(id a1, NSString *a2)
{
  return +[IDSURI URIWithPrefixedURI:a2];
}

void sub_1002FBA24(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = a1[9];
    id v6 = [v3 idsResponseCode];
    id v7 = [v3 responseError];
    unsigned int v8 = [v3 lastCall];
    CFStringRef v9 = @"NO";
    *(_DWORD *)buf = 138413058;
    *(void *)&uint8_t buf[4] = v5;
    *(_WORD *)&buf[12] = 2048;
    if (v8) {
      CFStringRef v9 = @"YES";
    }
    *(void *)&buf[14] = v6;
    __int16 v38 = 2112;
    id v39 = v7;
    __int16 v40 = 2112;
    CFStringRef v41 = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%@ Remote send completion block with responseCode %ld error %@ lastCall %@", buf, 0x2Au);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v10 = a1[9];
    id v11 = [v3 idsResponseCode];
    uint64_t v12 = [v3 responseError];
    unsigned int v13 = [v3 lastCall];
    CFStringRef v14 = @"NO";
    if (v13) {
      CFStringRef v14 = @"YES";
    }
    id v33 = v12;
    CFStringRef v35 = v14;
    uint64_t v29 = v10;
    id v31 = v11;
    _IDSLogV();
  }
  *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = objc_msgSend(v3, "lastCall", v29, v31, v33, v35, *(_OWORD *)buf);
  uint64_t v15 = [v3 responseError];
  if (v15)
  {
    BOOL v16 = *(void *)(*(void *)(a1[6] + 8) + 40) == 0;

    if (v16)
    {
      uint64_t v17 = [v3 responseError];
      uint64_t v18 = *(void *)(a1[6] + 8);
      uint64_t v19 = *(void **)(v18 + 40);
      *(void *)(v18 + 40) = v17;

      *(void *)(*(void *)(a1[7] + 8) + 24) = [v3 idsResponseCode];
    }
  }
  if (a1[4])
  {
    if (*(unsigned char *)(*(void *)(a1[8] + 8) + 24)) {
      BOOL v20 = *(unsigned char *)(*(void *)(a1[5] + 8) + 24) != 0;
    }
    else {
      BOOL v20 = 0;
    }
    uint64_t v21 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v22 = a1[9];
      uint64_t v23 = *(void *)(*(void *)(a1[7] + 8) + 24);
      uint64_t v24 = *(void **)(*(void *)(a1[6] + 8) + 40);
      CFStringRef v25 = @"NO";
      if (v20) {
        CFStringRef v25 = @"YES";
      }
      *(_DWORD *)buf = 138413058;
      *(void *)&uint8_t buf[4] = v22;
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v23;
      __int16 v38 = 2112;
      id v39 = v24;
      __int16 v40 = 2112;
      CFStringRef v41 = v25;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%@ calling combined completion block responseCode %ld error %@ lastCall %@", buf, 0x2Au);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      CFStringRef v26 = @"NO";
      if (v20) {
        CFStringRef v26 = @"YES";
      }
      uint64_t v34 = *(void *)(*(void *)(a1[6] + 8) + 40);
      CFStringRef v36 = v26;
      uint64_t v30 = a1[9];
      uint64_t v32 = *(void *)(*(void *)(a1[7] + 8) + 24);
      _IDSLogV();
    }
    objc_msgSend(v3, "setIdsResponseCode:", *(void *)(*(void *)(a1[7] + 8) + 24), v30, v32, v34, v36);
    [v3 setResponseError:*(void *)(*(void *)(a1[6] + 8) + 40)];
    [v3 setLastCall:v20];
    (*(void (**)(void))(a1[4] + 16))();
    if (v20)
    {
      uint64_t v27 = *(void *)(a1[6] + 8);
      uint64_t v28 = *(void **)(v27 + 40);
      *(void *)(v27 + 40) = 0;
    }
  }
}

id sub_1002FCD64(uint64_t a1, void *a2)
{
  id v2 = *(void **)(*(void *)(a1 + 32) + 24);
  id v3 = a2;
  id v4 = [v2 identifier];
  uint64_t v5 = +[IDSURI URIWithPrefixedURI:v3 withServiceLoggingHint:v4];

  return v5;
}

void sub_1002FCDF0(uint64_t a1, void *a2)
{
  id v3 = a2;
  im_assert_primary_base_queue();
  if (!*(unsigned char *)(a1 + 80) || *(unsigned char *)(a1 + 81))
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = [v3 lastCall];
    id v4 = [v3 responseError];
    if (v4)
    {
      uint64_t v5 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40);

      if (!v5)
      {
        uint64_t v6 = [v3 responseError];
        uint64_t v7 = *(void *)(*(void *)(a1 + 56) + 8);
        unsigned int v8 = *(void **)(v7 + 40);
        *(void *)(v7 + 40) = v6;

        *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = [v3 idsResponseCode];
      }
    }
    CFStringRef v9 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      id v10 = [v3 idsResponseCode];
      id v11 = [v3 responseError];
      unsigned int v12 = [v3 lastCall];
      uint64_t v13 = *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
      uint64_t v14 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
      uint64_t v15 = [*(id *)(a1 + 32) uniqueID];
      BOOL v16 = (void *)v15;
      CFStringRef v17 = @"NO";
      *(_DWORD *)buf = 134219266;
      *(void *)&uint8_t buf[4] = v10;
      *(_WORD *)&buf[12] = 2112;
      if (v12) {
        CFStringRef v17 = @"YES";
      }
      *(void *)&buf[14] = v11;
      __int16 v33 = 2112;
      CFStringRef v34 = v17;
      __int16 v35 = 2048;
      uint64_t v36 = v13;
      __int16 v37 = 2112;
      uint64_t v38 = v14;
      __int16 v39 = 2112;
      uint64_t v40 = v15;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Local send completion block {responseCode: %ld, error: %@, lastCall: %@, combinedResponseCode: %ld, combinedError: %@, account: %@}", buf, 0x3Eu);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      id v18 = [v3 idsResponseCode];
      uint64_t v19 = [v3 responseError];
      if ([v3 lastCall]) {
        CFStringRef v20 = @"YES";
      }
      else {
        CFStringRef v20 = @"NO";
      }
      uint64_t v21 = *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
      uint64_t v22 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
      [*(id *)(a1 + 32) uniqueID];
      v31 = uint64_t v30 = v22;
      CFStringRef v28 = v20;
      uint64_t v29 = v21;
      id v26 = v18;
      uint64_t v27 = v19;
      _IDSLogV();
    }
    if (*(void *)(a1 + 40))
    {
      if (*(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24)) {
        BOOL v23 = *(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) != 0;
      }
      else {
        BOOL v23 = 0;
      }
      objc_msgSend(v3, "setIdsResponseCode:", *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24), v26, v27, v28, v29, v30, v31, *(_OWORD *)buf);
      [v3 setResponseError:*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40)];
      [v3 setLastCall:v23];
      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
      if (v23)
      {
        uint64_t v24 = *(void *)(*(void *)(a1 + 56) + 8);
        CFStringRef v25 = *(void **)(v24 + 40);
        *(void *)(v24 + 40) = 0;
      }
    }
  }
}

IDSURI *__cdecl sub_1002FD14C(id a1, NSString *a2)
{
  return +[IDSURI URIWithPrefixedURI:a2];
}

uint64_t sub_1002FD15C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1002FD16C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v12 = a2;
  id v7 = a3;
  id v8 = a4;
  if (![*(id *)(a1 + 32) count])
  {
    id v11 = v12;
    goto LABEL_11;
  }
  if (!v12)
  {
    id v10 = *(id *)(a1 + 40);
    if (!v10)
    {
      id v9 = 0;
      goto LABEL_10;
    }
    goto LABEL_8;
  }
  id v9 = objc_alloc_init((Class)NSMutableSet);
  [v9 addObjectsFromArray:v12];
  id v10 = *(id *)(a1 + 40);
  if (v10)
  {
    if (v9)
    {
LABEL_9:
      [v9 addObjectsFromArray:v10];
      goto LABEL_10;
    }
LABEL_8:
    id v9 = objc_alloc_init((Class)NSMutableSet);
    goto LABEL_9;
  }
LABEL_10:
  id v11 = [v9 allObjects];

LABEL_11:
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

IDSURI *__cdecl sub_1002FD29C(id a1, NSString *a2)
{
  return +[IDSURI URIWithPrefixedURI:a2];
}

void sub_1002FD2AC(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = a1[4];
    id v6 = [v3 idsResponseCode];
    id v7 = [v3 responseError];
    unsigned int v8 = [v3 lastCall];
    CFStringRef v9 = @"NO";
    *(_DWORD *)buf = 138413058;
    *(void *)&uint8_t buf[4] = v5;
    *(_WORD *)&buf[12] = 2048;
    if (v8) {
      CFStringRef v9 = @"YES";
    }
    *(void *)&buf[14] = v6;
    __int16 v36 = 2112;
    id v37 = v7;
    __int16 v38 = 2112;
    CFStringRef v39 = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%@ Remote send completion block with responseCode %ld error %@ lastCall %@", buf, 0x2Au);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v10 = a1[4];
    id v11 = [v3 idsResponseCode];
    id v12 = [v3 responseError];
    unsigned int v13 = [v3 lastCall];
    CFStringRef v14 = @"NO";
    if (v13) {
      CFStringRef v14 = @"YES";
    }
    __int16 v33 = v12;
    CFStringRef v34 = v14;
    uint64_t v31 = v10;
    id v32 = v11;
    _IDSLogV();
  }
  *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = objc_msgSend(v3, "lastCall", v31, v32, v33, v34, *(_OWORD *)buf);
  uint64_t v15 = [v3 responseError];
  if (v15)
  {
    BOOL v16 = *(void *)(*(void *)(a1[7] + 8) + 40) == 0;

    if (v16)
    {
      uint64_t v17 = [v3 responseError];
      uint64_t v18 = *(void *)(a1[7] + 8);
      uint64_t v19 = *(void **)(v18 + 40);
      *(void *)(v18 + 40) = v17;

      *(void *)(*(void *)(a1[8] + 8) + 24) = [v3 idsResponseCode];
    }
  }
  if (a1[5])
  {
    if (*(unsigned char *)(*(void *)(a1[9] + 8) + 24)) {
      BOOL v20 = *(unsigned char *)(*(void *)(a1[6] + 8) + 24) != 0;
    }
    else {
      BOOL v20 = 0;
    }
    uint64_t v21 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v22 = a1[4];
      uint64_t v23 = *(void *)(*(void *)(a1[8] + 8) + 24);
      uint64_t v24 = *(void **)(*(void *)(a1[7] + 8) + 40);
      CFStringRef v25 = @"NO";
      if (v20) {
        CFStringRef v25 = @"YES";
      }
      *(_DWORD *)buf = 138413058;
      *(void *)&uint8_t buf[4] = v22;
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v23;
      __int16 v36 = 2112;
      id v37 = v24;
      __int16 v38 = 2112;
      CFStringRef v39 = v25;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%@ calling combined completion block responseCode %ld error %@ lastCall %@", buf, 0x2Au);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    id v26 = [objc_alloc((Class)IDSDeliveryContext) initWithResponseCode:*(void *)(*(void *)(a1[8] + 8) + 24) error:*(void *)(*(void *)(a1[7] + 8) + 40) lastCall:v20];
    objc_msgSend(v26, "setLastCourierAck:", objc_msgSend(v3, "lastCourierAck"));
    (*(void (**)(void, id, uint64_t, uint64_t))(a1[5] + 16))(a1[5], v26, v27, v28);
    if (v20)
    {
      uint64_t v29 = *(void *)(a1[7] + 8);
      uint64_t v30 = *(void **)(v29 + 40);
      *(void *)(v29 + 40) = 0;
    }
  }
}

void sub_1002FD910(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 idsResponseCode])
  {
    id v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 32);
      id v6 = [v3 idsResponseCode];
      id v7 = [v3 responseError];
      *(_DWORD *)buf = 138412802;
      uint64_t v14 = v5;
      __int16 v15 = 2048;
      id v16 = v6;
      __int16 v17 = 2112;
      uint64_t v18 = v7;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Failed sending server message request response for topic %@. Result code %ld. Error %@.", buf, 0x20u);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      [v3 idsResponseCode];
      CFStringRef v9 = [v3 responseError];
      _IDSLogV();
LABEL_12:
    }
  }
  else
  {
    uint64_t v10 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = *(void *)(a1 + 32);
      id v12 = [v3 responseError];
      *(_DWORD *)buf = 138412546;
      uint64_t v14 = v11;
      __int16 v15 = 2112;
      id v16 = v12;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Finished sending server message request response for topic %@  [%@]", buf, 0x16u);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      CFStringRef v9 = [v3 responseError];
      _IDSLogV();
      goto LABEL_12;
    }
  }
  (*(void (**)(void, id, uint64_t))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), v3, v8);
}

id sub_1002FFA70(id a1, NSDictionary *a2)
{
  id v2 = [(NSDictionary *)a2 _stringForKey:IDSDevicePropertyIdentitiesURI];
  id v3 = [v2 _stripFZIDPrefix];

  return v3;
}

id sub_1002FFACC(id a1, NSDictionary *a2)
{
  id v2 = [(NSDictionary *)a2 _stringForKey:IDSDevicePropertyIdentitiesURI];
  id v3 = [v2 _stripFZIDPrefix];

  return v3;
}

id sub_1002FFB28(uint64_t a1)
{
  return [*(id *)(a1 + 32) enableCloudConnection];
}

void sub_1002FFB30(id a1)
{
  int v1 = IMGetDomainBoolForKey();
  byte_100A4C718 = v1;
  if (v1)
  {
    id v2 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)id v3 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "**** Local IDS connectivity is disabled, only using cloud ****", v3, 2u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      _IDSLogTransport();
    }
  }
}

id sub_100300894(id a1, id a2)
{
  return [a2 objectForKey:IDSDevicePairedDeviceID];
}

void sub_1003008A8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  im_assert_primary_base_queue();
  uint64_t v7 = *(void *)(*(void *)(*(void *)(a1 + 104) + 8) + 40);
  unsigned int v8 = [*(id *)(a1 + 32) containsObject:v6];
  unsigned int v9 = [*(id *)(a1 + 40) containsObject:v6];
  unsigned int v10 = v9;
  if (v7 || (v8 & 1) != 0 || !v9)
  {
    __int16 v15 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v16 = @"NO";
      *(_DWORD *)buf = 138413314;
      id v58 = v5;
      if (v7) {
        CFStringRef v17 = @"YES";
      }
      else {
        CFStringRef v17 = @"NO";
      }
      if (v8) {
        CFStringRef v18 = @"YES";
      }
      else {
        CFStringRef v18 = @"NO";
      }
      if (!v10) {
        CFStringRef v16 = @"YES";
      }
      __int16 v59 = 2112;
      id v60 = v6;
      __int16 v61 = 2112;
      CFStringRef v62 = v17;
      __int16 v63 = 2112;
      CFStringRef v64 = v18;
      __int16 v65 = 2112;
      CFStringRef v66 = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Fallback won't sent for %@ %@  alreadyFailed %@ alreadySending %@ alreadyComplete %@", buf, 0x34u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      goto LABEL_27;
    }
  }
  else
  {
    unsigned __int8 v11 = [*(id *)(a1 + 48) localDelivery];
    if (!v6
      || (v11 & 1) != 0
      || ([v5 isEqualToString:IDSDefaultPairedDevice] & 1) != 0
      || [v5 localizedCaseInsensitiveContainsString:@"__localURI__"])
    {
      id v12 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v13 = [*(id *)(a1 + 48) localDelivery];
        CFStringRef v14 = @"NO";
        *(_DWORD *)buf = 138412802;
        id v58 = v5;
        __int16 v59 = 2112;
        if (v13) {
          CFStringRef v14 = @"YES";
        }
        id v60 = v6;
        __int16 v61 = 2112;
        CFStringRef v62 = v14;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Ignoring request to fallback for %@ %@ forcedLocal %@", buf, 0x20u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        [*(id *)(a1 + 48) localDelivery];
LABEL_27:
        _IDSLogV();
      }
    }
    else
    {
      uint64_t v19 = +[IDSTrafficMonitor sharedInstance];
      BOOL v20 = [*(id *)(a1 + 56) service];
      uint64_t v21 = [v20 identifier];
      uint64_t v22 = [*(id *)(a1 + 56) service];
      unsigned __int8 v23 = objc_msgSend(v19, "noteOutgoingFallbackMessageForService:serviceType:requestor:", v21, objc_msgSend(v22, "adHocServiceType"), 0);

      if (v23)
      {
        v46[0] = _NSConcreteStackBlock;
        v46[1] = 3221225472;
        v46[2] = sub_1003010D8;
        v46[3] = &unk_100988658;
        id v47 = *(id *)(a1 + 48);
        id v24 = v5;
        id v48 = v24;
        CFStringRef v25 = (const __CFString *)v6;
        id v49 = (__CFString *)v25;
        id v50 = *(id *)(a1 + 40);
        id v51 = *(id *)(a1 + 32);
        long long v55 = *(_OWORD *)(a1 + 104);
        id v26 = *(id *)(a1 + 64);
        uint64_t v27 = *(void *)(a1 + 120);
        id v52 = v26;
        uint64_t v56 = v27;
        id v53 = *(id *)(a1 + 72);
        id v54 = *(id *)(a1 + 96);
        id v45 = objc_retainBlock(v46);
        id v28 = [*(id *)(a1 + 48) copy];
        uint64_t v29 = +[IDSURI URIWithPrefixedURI:v24];
        uint64_t v30 = +[NSArray arrayWithObject:v29];
        [v28 setFinalDestinationURIs:v30];

        [v28 setWantsResponse:1];
        if ([v28 priority] == (id)200) {
          [v28 setPriority:300];
        }
        uint64_t v31 = OSLogHandleForTransportCategory();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
        {
          id v32 = [*(id *)(a1 + 48) messageUUID];
          __int16 v33 = [*(id *)(a1 + 56) uniqueID];
          *(_DWORD *)buf = 138413058;
          id v58 = v32;
          __int16 v59 = 2112;
          id v60 = v24;
          __int16 v61 = 2112;
          CFStringRef v62 = v25;
          __int16 v63 = 2112;
          CFStringRef v64 = v33;
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Initiating fallback send for message %@ to %@ %@ from account %@", buf, 0x2Au);
        }
        if (os_log_shim_legacy_logging_enabled())
        {
          if (_IDSShouldLogTransport())
          {
            CFStringRef v34 = [*(id *)(a1 + 48) messageUUID];
            [*(id *)(a1 + 56) uniqueID];
            BOOL v44 = v42 = v25;
            uint64_t v40 = v34;
            id v41 = v24;
            _IDSLogTransport();

            if (_IDSShouldLog())
            {
              __int16 v35 = objc_msgSend(*(id *)(a1 + 48), "messageUUID", v34, v24, v25, v44);
              [*(id *)(a1 + 56) uniqueID];
              BOOL v44 = v42 = v25;
              uint64_t v40 = v35;
              id v41 = v24;
              _IDSLogV();
            }
          }
        }
        objc_msgSend(*(id *)(a1 + 32), "addObject:", v25, v40, v41, v42, v44);
        [*(id *)(a1 + 56) _sendRemotelyWithSendParameters:v28 data:*(void *)(a1 + 80) protobuf:*(void *)(a1 + 88) willSendBlock:0 completionBlock:v45];
      }
      else
      {
        __int16 v36 = OSLogHandleForTransportCategory();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v37 = [*(id *)(a1 + 48) localDelivery];
          CFStringRef v38 = @"NO";
          *(_DWORD *)buf = 138412802;
          id v58 = v5;
          __int16 v59 = 2112;
          if (v37) {
            CFStringRef v38 = @"YES";
          }
          id v60 = v6;
          __int16 v61 = 2112;
          CFStringRef v62 = v38;
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "Ignoring request to fallback for %@ %@ forcedLocal %@ due to budget restrictions.", buf, 0x20u);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
        {
          CFStringRef v39 = [*(id *)(a1 + 48) localDelivery] ? @"YES" : @"NO";
          uint64_t v43 = v39;
          _IDSLogTransport();
          if (_IDSShouldLog())
          {
            objc_msgSend(*(id *)(a1 + 48), "localDelivery", v5, v6, v43);
            goto LABEL_27;
          }
        }
      }
    }
  }
}

void sub_100301078(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x100300FD0);
  }
  _Unwind_Resume(a1);
}

void sub_1003010D8(uint64_t a1, void *a2)
{
  id v3 = a2;
  im_assert_primary_base_queue();
  id v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = [*(id *)(a1 + 32) messageUUID];
    uint64_t v7 = *(void *)(a1 + 40);
    uint64_t v6 = *(void *)(a1 + 48);
    id v8 = [v3 idsResponseCode];
    id v9 = [v3 responseError];
    unsigned int v10 = [v3 lastCall];
    CFStringRef v11 = @"NO";
    uint64_t v12 = *(void *)(a1 + 56);
    uint64_t v13 = *(void *)(a1 + 64);
    if (v10) {
      CFStringRef v11 = @"YES";
    }
    *(_DWORD *)buf = 138414082;
    id v58 = v5;
    __int16 v59 = 2112;
    uint64_t v60 = v7;
    __int16 v61 = 2112;
    uint64_t v62 = v6;
    __int16 v63 = 2048;
    id v64 = v8;
    __int16 v65 = 2112;
    id v66 = v9;
    __int16 v67 = 2112;
    CFStringRef v68 = v11;
    __int16 v69 = 2112;
    uint64_t v70 = v12;
    __int16 v71 = 2112;
    uint64_t v72 = v13;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Fallback send of %@ to %@ %@ completed with responseCode %ld error %@ lastCall %@ - current pending sends local %@ fallback %@", buf, 0x52u);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    CFStringRef v14 = [*(id *)(a1 + 32) messageUUID];
    uint64_t v15 = *(void *)(a1 + 40);
    uint64_t v16 = *(void *)(a1 + 48);
    id v17 = [v3 idsResponseCode];
    CFStringRef v18 = [v3 responseError];
    unsigned int v19 = [v3 lastCall];
    CFStringRef v20 = @"NO";
    if (v19) {
      CFStringRef v20 = @"YES";
    }
    uint64_t v55 = *(void *)(a1 + 56);
    uint64_t v56 = *(void *)(a1 + 64);
    id v53 = v18;
    CFStringRef v54 = v20;
    uint64_t v51 = v16;
    id v52 = v17;
    id v49 = v14;
    uint64_t v50 = v15;
    _IDSLogV();
  }
  if (objc_msgSend(v3, "lastCall", v49, v50, v51, v52, v53, v54, v55, v56))
  {
    id v21 = [v3 idsResponseCode];
    if (v21)
    {
      if (*(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 40))
      {
LABEL_23:
        BOOL v39 = v21 == 0;
        id v40 = [*(id *)(a1 + 56) count];
        uint64_t v41 = (uint64_t)[*(id *)(a1 + 64) count];
        [*(id *)(a1 + 64) removeObject:*(void *)(a1 + 48)];
        if (v39) {
          [*(id *)(a1 + 56) removeObject:*(void *)(a1 + 48)];
        }
        BOOL v42 = v40 != (id)-v41;
        id v43 = [*(id *)(a1 + 56) count];
        if ((char *)[*(id *)(a1 + 64) count] + (void)v43) {
          BOOL v44 = 0;
        }
        else {
          BOOL v44 = v42;
        }
        if (v44)
        {
          if (*(void *)(a1 + 88))
          {
            id v45 = [objc_alloc((Class)IDSDeliveryContext) initWithResponseCode:*(void *)(*(void *)(*(void *)(a1 + 104) + 8) + 24) error:*(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 40) lastCall:1];
            __int16 v46 = [v3 endpointState];
            [v45 setEndpointState:v46];

            (*(void (**)(void))(*(void *)(a1 + 88) + 16))();
          }
          uint64_t v47 = *(void *)(*(void *)(a1 + 96) + 8);
          id v48 = *(void **)(v47 + 40);
          *(void *)(v47 + 40) = 0;
        }
        goto LABEL_32;
      }
      *(void *)(*(void *)(*(void *)(a1 + 104) + 8) + 24) = [v3 idsResponseCode];
      uint64_t v22 = [v3 responseError];
      uint64_t v23 = *(void *)(*(void *)(a1 + 96) + 8);
      id v24 = *(id *)(v23 + 40);
      *(void *)(v23 + 40) = v22;
    }
    else
    {
      CFStringRef v25 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Overwriting previous local failure with remote success", buf, 2u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        _IDSLogV();
      }
      *(void *)(*(void *)(*(void *)(a1 + 104) + 8) + 24) = 0;
      uint64_t v26 = *(void *)(*(void *)(a1 + 96) + 8);
      uint64_t v27 = *(void **)(v26 + 40);
      *(void *)(v26 + 40) = 0;

      if (![*(id *)(a1 + 48) isEqualToString:IDSDeviceDefaultPairedDeviceUniqueID]) {
        goto LABEL_23;
      }
      id v24 = objc_msgSend(objc_alloc((Class)IDSLocalDeliveryMessageSentMetric), "initWithService:isToDefaultPairedDevice:messageSize:linkType:priority:", *(void *)(a1 + 72), 1, *(void *)(a1 + 112), 4, objc_msgSend(*(id *)(a1 + 32), "priority"));
      id v28 = +[IDSCoreAnalyticsLogger defaultLogger];
      [v28 logMetric:v24];

      uint64_t v29 = +[IDSAWDLogging sharedInstance];
      objc_msgSend(v29, "messageSentForService:isToDefaultPairedDevice:messageSize:linkType:priority:", *(void *)(a1 + 72), 1, *(void *)(a1 + 112), 4, objc_msgSend(*(id *)(a1 + 32), "priority"));

      uint64_t v30 = +[IDSUTunDeliveryController sharedInstance];
      uint64_t v31 = [*(id *)(a1 + 32) messageUUID];
      id v32 = JWUUIDPushObjectToString();
      [v30 cancelMessageID:v32];

      if ([*(id *)(a1 + 80) adHocServiceType] == 2)
      {
        id v33 = objc_alloc((Class)IDSLocalDeliveryMessageDeliveredMetric);
        CFStringRef v34 = [*(id *)(a1 + 80) identifier];
        id v35 = [v33 initWithService:v34 isToDefaultPairedDevice:1 messageSize:0 linkType:4 deliveryError:0 RTT:0 priority:0];

        __int16 v36 = +[IDSCoreAnalyticsLogger defaultLogger];
        [v36 logMetric:v35];

        unsigned int v37 = +[IDSAWDLogging sharedInstance];
        CFStringRef v38 = [*(id *)(a1 + 80) identifier];
        [v37 messageDeliveredForService:v38 isToDefaultPairedDevice:1 messageSize:0 linkType:4 deliveryError:0 RTT:0 priority:0];
      }
    }

    goto LABEL_23;
  }
LABEL_32:
}

void sub_100301710(uint64_t a1, void *a2)
{
  id v3 = a2;
  im_assert_primary_base_queue();
  id v4 = [v3 idsResponseCode];
  id v5 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = [*(id *)(a1 + 32) messageUUID];
    id v7 = [v3 deviceID];
    uint64_t v9 = *(void *)(a1 + 40);
    uint64_t v8 = *(void *)(a1 + 48);
    uint64_t v10 = *(void *)(a1 + 56);
    uint64_t v11 = [*(id *)(a1 + 64) uniqueID];
    uint64_t v12 = (void *)v11;
    CFStringRef v13 = @"NO";
    *(_DWORD *)buf = 138414082;
    *(void *)&uint8_t buf[4] = v6;
    if (!v4) {
      CFStringRef v13 = @"YES";
    }
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v7;
    __int16 v47 = 2112;
    CFStringRef v48 = v13;
    __int16 v49 = 2048;
    id v50 = v4;
    __int16 v51 = 2112;
    uint64_t v52 = v9;
    __int16 v53 = 2112;
    uint64_t v54 = v8;
    __int16 v55 = 2112;
    uint64_t v56 = v10;
    __int16 v57 = 2112;
    uint64_t v58 = v11;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "IDSUTunDeliveryController sendMessage %@ deviceID %@ succeeded? %@ response %ld topic: %@ - current pending sends local %@ fallback %@ account %@", buf, 0x52u);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    CFStringRef v14 = [*(id *)(a1 + 32) messageUUID];
    uint64_t v15 = [v3 deviceID];
    if (v4) {
      CFStringRef v16 = @"NO";
    }
    else {
      CFStringRef v16 = @"YES";
    }
    uint64_t v17 = *(void *)(a1 + 40);
    uint64_t v18 = *(void *)(a1 + 48);
    uint64_t v19 = *(void *)(a1 + 56);
    [*(id *)(a1 + 64) uniqueID];
    v45 = uint64_t v44 = v19;
    uint64_t v42 = v17;
    uint64_t v43 = v18;
    CFStringRef v40 = v16;
    id v41 = v4;
    CFStringRef v38 = v14;
    BOOL v39 = v15;
    _IDSLogV();
  }
  if (v4)
  {
    if (*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40)) {
      goto LABEL_21;
    }
    *(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 24) = v4;
    id v20 = objc_alloc((Class)NSError);
    id v21 = [v20 initWithDomain:IDSSendErrorDomain code:v4 userInfo:0];
    uint64_t v22 = *(void *)(*(void *)(a1 + 80) + 8);
    uint64_t v23 = *(void **)(v22 + 40);
    *(void *)(v22 + 40) = v21;
  }
  else
  {
    id v24 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Overwriting previous remote failure with local success", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    *(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 24) = 0;
    uint64_t v25 = *(void *)(*(void *)(a1 + 80) + 8);
    uint64_t v23 = *(void **)(v25 + 40);
    *(void *)(v25 + 40) = 0;
  }

LABEL_21:
  BOOL v26 = v4 == 0;
  id v27 = objc_msgSend(*(id *)(a1 + 48), "count", v38, v39, v40, v41, v42, v43, v44, v45, *(_OWORD *)buf);
  uint64_t v28 = (uint64_t)[*(id *)(a1 + 56) count];
  uint64_t v29 = *(void **)(a1 + 48);
  uint64_t v30 = [v3 deviceID];
  [v29 removeObject:v30];

  if (v26)
  {
    uint64_t v31 = *(void **)(a1 + 56);
    id v32 = [v3 deviceID];
    [v31 removeObject:v32];
  }
  BOOL v33 = v27 != (id)-v28;
  id v34 = [*(id *)(a1 + 48) count];
  if ((char *)[*(id *)(a1 + 56) count] + (void)v34) {
    BOOL v35 = 0;
  }
  else {
    BOOL v35 = v33;
  }
  if (v35)
  {
    if (*(void *)(a1 + 72))
    {
      [v3 setIdsResponseCode:*(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 24)];
      [v3 setResponseError:*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40)];
      [v3 setLastCall:1];
      (*(void (**)(void))(*(void *)(a1 + 72) + 16))();
    }
    uint64_t v36 = *(void *)(*(void *)(a1 + 80) + 8);
    unsigned int v37 = *(void **)(v36 + 40);
    *(void *)(v36 + 40) = 0;
  }
}

id sub_10030443C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [*(id *)(a1 + 32) setObject:a3 forKey:a2];
}

uint64_t sub_100304448(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100304458(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "All courier acks have completed, informing the next layer that the message has been sent sucessfully", v6, 2u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  id v5 = [objc_alloc((Class)IDSDeliveryContext) initWithResponseCode:0 error:0 lastCall:0];
  [v5 setResponseTimeStamp:v3];
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100304574(uint64_t a1, void *a2, int a3, void *a4, void *a5, void *a6, void *a7, void *a8, void *a9, uint64_t a10)
{
  id v91 = a2;
  id v92 = a4;
  id v17 = a5;
  id v18 = a6;
  id v19 = a7;
  id v20 = a8;
  id v21 = a9;
  v93 = v18;
  v94 = v19;
  v95 = v20;
  if (a3 && [v20 length])
  {
    uint64_t v22 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
    uint64_t v23 = v22;
    if (v18) {
      CFDictionarySetValue(v22, @"mmcs-owner", v18);
    }
    if (v20) {
      CFDictionarySetValue(v23, @"mmcs-url", v20);
    }
    id v24 = objc_msgSend(v19, "__imHexString");
    if (v24) {
      CFDictionarySetValue(v23, @"mmcs-signature-hex", v24);
    }

    if (v21) {
      CFDictionarySetValue(v23, @"decryption-key", v21);
    }
    uint64_t v25 = +[NSNumber numberWithInteger:a10];
    if (v25) {
      CFDictionarySetValue(v23, @"file-size", v25);
    }

    id v26 = objc_alloc_init((Class)NSMutableDictionary);
    id v27 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
    uint64_t v28 = v27;
    if (v23) {
      CFDictionarySetValue(v27, @"attach-mmcs-dict", v23);
    }
    uint64_t v29 = [*(id *)(a1 + 32) resourceMetadata];
    if (v29) {
      CFDictionarySetValue(v28, @"attach-meta", v29);
    }

    uint64_t v30 = *(void **)(a1 + 40);
    v99[0] = _NSConcreteStackBlock;
    v99[1] = 3221225472;
    v99[2] = sub_100304D60;
    v99[3] = &unk_100980928;
    id v31 = v26;
    id v100 = v31;
    [v30 enumerateKeysAndObjectsUsingBlock:v99];
    id v32 = *(void **)(a1 + 32);
    BOOL v33 = JWEncodeDictionary();
    [v32 setDataToEncrypt:v33];

    id v34 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      id v102 = v31;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Upload Complete, Here is the information, %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      id v47 = v31;
      _IDSLogV();
    }
    uint64_t v35 = +[IDSDeliveryController sharedInstance];
    v90 = [*(id *)(a1 + 32) messageUUID];
    v87 = JWUUIDPushObjectToString();
    v86 = [*(id *)(a1 + 32) dataToEncrypt];
    v85 = [*(id *)(a1 + 32) encryptionAttributes];
    uint64_t v74 = *(void *)(a1 + 48);
    unsigned int v73 = [*(id *)(a1 + 32) wantsResponse];
    v84 = [*(id *)(a1 + 32) expirationDate];
    unsigned __int8 v72 = [*(id *)(a1 + 32) enforceRemoteTimeouts];
    v89 = [*(id *)(a1 + 56) service];
    unsigned __int8 v71 = [v89 canUseLargePayload];
    v88 = [*(id *)(a1 + 56) service];
    unsigned __int8 v70 = [v88 sendOnePerToken];
    uint64_t v36 = [*(id *)(a1 + 56) service];
    unsigned __int8 v69 = [v36 allowPartialSendsToSucceed];
    id v68 = [*(id *)(a1 + 32) priority];
    unsigned __int8 v67 = [*(id *)(a1 + 32) fireAndForget];
    uint64_t v66 = *(void *)(a1 + 64);
    uint64_t v37 = [*(id *)(a1 + 32) fromShortHandle];
    uint64_t v65 = *(void *)(a1 + 72);
    v83 = [*(id *)(a1 + 32) finalDestinationURIs];
    v82 = [*(id *)(a1 + 32) accessToken];
    uint64_t v63 = *(void *)(a1 + 88);
    uint64_t v64 = *(void *)(a1 + 80);
    unsigned __int8 v62 = [*(id *)(a1 + 32) fakeMessage];
    unsigned __int8 v61 = [*(id *)(a1 + 32) alwaysSkipSelf];
    unsigned __int8 v60 = [*(id *)(a1 + 32) alwaysIncludeSelf];
    id v59 = [*(id *)(a1 + 32) forceQuery];
    v81 = [*(id *)(a1 + 32) pushPriority];
    unsigned __int8 v58 = [*(id *)(a1 + 32) ignoreMaxRetryCount];
    unsigned __int8 v57 = [*(id *)(a1 + 32) disallowRefresh];
    v80 = [*(id *)(a1 + 32) originalTimestamp];
    v79 = [*(id *)(a1 + 32) prioritizedTokenList];
    unsigned __int8 v56 = [*(id *)(a1 + 32) wantsFirewallDonation];
    v78 = [*(id *)(a1 + 32) deliveryMinimumTimeDelay];
    v77 = [*(id *)(a1 + 32) deliveryMinimumTime];
    v76 = [*(id *)(a1 + 32) sendMode];
    CFStringRef v75 = [*(id *)(a1 + 32) keyTransparencyURIVerificationMap];
    uint64_t v54 = *(void *)(a1 + 96);
    __int16 v55 = v23;
    CFStringRef v38 = (void *)v37;
    BOOL v39 = v36;
    CFStringRef v40 = (void *)v35;
    id v41 = v31;
    uint64_t v42 = v28;
    id v43 = v21;
    id v44 = v17;
    uint64_t v45 = *(void *)(a1 + 104);
    v96[0] = _NSConcreteStackBlock;
    v96[1] = 3221225472;
    v96[2] = sub_100304D6C;
    v96[3] = &unk_1009801B0;
    id v97 = *(id *)(a1 + 32);
    id v98 = *(id *)(a1 + 112);
    uint64_t v53 = v45;
    id v17 = v44;
    id v21 = v43;
    LOBYTE(v52) = v56;
    BYTE1(v51) = v57;
    LOBYTE(v51) = v58;
    BYTE2(v50) = v60;
    BYTE1(v50) = v61;
    LOBYTE(v50) = v62;
    LOBYTE(v49) = v67;
    BYTE3(v48) = v69;
    BYTE2(v48) = v70;
    BYTE1(v48) = v71;
    LOBYTE(v48) = v72;
    objc_msgSend(v40, "sendMessageDictionary:messageID:dataToEncrypt:withEncryptedAttributes:onService:wantsResponse:expirationDate:enforceRemoteTimeouts:canUseLargePayload:sendOnePerToken:allowPartialSendsToSucceed:priority:fireAndForget:fromID:fromShortHandle:fromIdentity:toURIs:accessToken:topic:registrationProperties:fakeMessage:alwaysSkipSelf:alwaysIncludeSelf:forceQuery:pushPriority:ignoreMaxRetryCount:disallowRefresh:originalTimestamp:prioritizedTokenList:wantsFirewallDonation:destinationObject:deliveryMinimumTimeDelay:deliveryMinimumTime:sendMode:KTURIVerificationMap:ackBlock:willSendBlock:sendCompletionBlock:", v41, v87, v86, v85, v74, v73, v84, v48, v68, v49, v66, v38,
      v65,
      v83,
      v82,
      v64,
      v63,
      v50,
      v59,
      v81,
      v51,
      v80,
      v79,
      v52,
      0,
      v78,
      v77,
      v76,
      v75,
      v54,
      v53,
      v96);
  }
  else if (*(void *)(a1 + 112))
  {
    id v46 = [objc_alloc((Class)IDSDeliveryContext) initWithResponseCode:2 error:0 lastCall:1];
    (*(void (**)(void))(*(void *)(a1 + 112) + 16))();
  }
}

id sub_100304D60(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [*(id *)(a1 + 32) setObject:a3 forKey:a2];
}

void sub_100304D6C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = [v3 idsResponseCode];
    id v6 = [v3 responseError];
    if ([v3 lastCall]) {
      CFStringRef v7 = @"YES";
    }
    else {
      CFStringRef v7 = @"NO";
    }
    id v8 = [v3 displayURIs];
    uint64_t v9 = [*(id *)(a1 + 32) messageUUID];
    *(_DWORD *)buf = 134219010;
    id v15 = v5;
    __int16 v16 = 2112;
    id v17 = v6;
    __int16 v18 = 2112;
    CFStringRef v19 = v7;
    __int16 v20 = 2112;
    id v21 = v8;
    __int16 v22 = 2112;
    uint64_t v23 = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, " => Send completed with resultCode %ld, send error %@, lastCall %@ for displayURIs %@  messageUUID %@", buf, 0x34u);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    [v3 idsResponseCode];
    uint64_t v10 = [v3 responseError];
    [v3 lastCall];
    uint64_t v11 = [v3 displayURIs];
    CFStringRef v13 = [*(id *)(a1 + 32) messageUUID];
    _IDSLogV();
  }
  uint64_t v12 = *(void *)(a1 + 40);
  if (v12) {
    (*(void (**)(uint64_t, id))(v12 + 16))(v12, v3);
  }
}

void sub_100304FBC(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = [v3 idsResponseCode];
    id v6 = [v3 responseError];
    if ([v3 lastCall]) {
      CFStringRef v7 = @"YES";
    }
    else {
      CFStringRef v7 = @"NO";
    }
    id v8 = [v3 displayURIs];
    uint64_t v9 = [*(id *)(a1 + 32) messageUUID];
    *(_DWORD *)buf = 134219010;
    *(void *)&uint8_t buf[4] = v5;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v6;
    __int16 v17 = 2112;
    CFStringRef v18 = v7;
    __int16 v19 = 2112;
    id v20 = v8;
    __int16 v21 = 2112;
    __int16 v22 = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, " => Send completed with resultCode %ld, send error %@, lastCall %@ for displayURIs %@  messageUUID %@", buf, 0x34u);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    [v3 idsResponseCode];
    uint64_t v10 = [v3 responseError];
    [v3 lastCall];
    uint64_t v11 = [v3 displayURIs];
    CFStringRef v14 = [*(id *)(a1 + 32) messageUUID];
    _IDSLogV();
  }
  id v12 = *(id *)(a1 + 40);
  voucher_adopt();
  if ([v3 lastCall])
  {
    id v15 = _os_activity_create((void *)&_mh_execute_header, "Send completed", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
    memset(buf, 170, 16);
    os_activity_scope_enter(v15, (os_activity_scope_state_t)buf);
    os_activity_scope_leave((os_activity_scope_state_t)buf);
    cut_arc_os_release();
  }
  uint64_t v13 = *(void *)(a1 + 48);
  if (v13) {
    (*(void (**)(uint64_t, id))(v13 + 16))(v13, v3);
  }
}

id sub_1003054F8(id a1, IDSURI *a2)
{
  return [(IDSURI *)a2 prefixedURI];
}

uint64_t sub_100305500(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

id sub_10030767C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 hasPrefix:@"self-token:"])
  {
    id v4 = [v3 _stripFZIDPrefix];
    id v5 = (char *)[v4 rangeOfString:@"/"];
    if (v5 == (char *)0x7FFFFFFFFFFFFFFFLL)
    {
      id v6 = v4;
    }
    else
    {
      id v6 = [v4 substringToIndex:v5];
    }
    id v8 = v6;
    uint64_t v9 = +[NSData __imDataWithHexString:v6];
    if ([v4 length] <= v5 + 1)
    {
      id v12 = [*(id *)(a1 + 32) primaryRegistration];
      uint64_t v13 = [v12 dsHandle];

      if (v13)
      {
        id v11 = v13;
      }
      else
      {
        id v15 = [*(id *)(a1 + 32) primaryRegistration];
        __int16 v16 = [v15 uris];

        if ([v16 count])
        {
          objc_msgSend(v16, "__imFirstObject");
          id v11 = (id)objc_claimAutoreleasedReturnValue();
        }
        else
        {
          id v11 = 0;
        }
      }
    }
    else
    {
      uint64_t v10 = objc_msgSend(v4, "substringFromIndex:");
      if ([*(id *)(a1 + 32) hasDependentRegistrationWithURI:v10 token:v9])
      {
        id v11 = v10;
      }
      else
      {
        CFStringRef v14 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          id v21 = v3;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Couldn't resolve %@ to a valid dependent registration.", buf, 0xCu);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
        {
          id v19 = v3;
          _IDSLogV();
        }
        id v11 = 0;
      }
    }
    if (objc_msgSend(v9, "length", v19) && objc_msgSend(v11, "length"))
    {
      id v7 = (id)_IDSCopyIDForTokenWithURI();
    }
    else
    {
      __int16 v17 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        id v21 = v3;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Could not construct a destination for %@", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        _IDSWarnV();
        _IDSLogV();
        _IDSLogTransport();
      }
      id v7 = 0;
    }
  }
  else
  {
    id v7 = v3;
  }

  return v7;
}

id sub_100307A10(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  id v6 = [a2 objectForKey:v5];
  if (objc_opt_isKindOfClass())
  {
    id v7 = v6;
  }
  else
  {
    if (v6)
    {
      id v8 = +[IMRGLog registration];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
        sub_10071E938((uint64_t)v5, a1, v8);
      }
    }
    id v7 = 0;
  }

  return v7;
}

uint64_t IDSProtoKeyTransparencyTrustedServiceReadFrom(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
    return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
  }
  while (2)
  {
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0;
    while (1)
    {
      unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v7 == -1 || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v8 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
      v6 |= (unint64_t)(v8 & 0x7F) << v4;
      if ((v8 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v9 = v5++ >= 9;
      if (v9)
      {
        unint64_t v6 = 0;
        int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }
    *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0;
    }
LABEL_13:
    if (v10 || (v6 & 7) == 4) {
      return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    switch((v6 >> 3))
    {
      case 1u:
        uint64_t v12 = PBReaderReadString();
        uint64_t v13 = 32;
        goto LABEL_28;
      case 2u:
        PBReaderReadString();
        id v15 = (IDSProtoKeyTransparencyLoggableData *)objc_claimAutoreleasedReturnValue();
        if (v15) {
          [(id)a1 addUris:v15];
        }
        goto LABEL_26;
      case 3u:
        id v15 = objc_alloc_init(IDSProtoKeyTransparencyLoggableData);
        objc_storeStrong((id *)(a1 + 24), v15);
        if (PBReaderPlaceMark()
          && (IDSProtoKeyTransparencyLoggableDataReadFrom((uint64_t)v15, a2) & 1) != 0)
        {
          PBReaderRecallMark();
LABEL_26:

LABEL_40:
          if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
          }
          continue;
        }

        return 0;
      case 4u:
        uint64_t v12 = PBReaderReadData();
        uint64_t v13 = 8;
LABEL_28:
        __int16 v16 = *(void **)(a1 + v13);
        *(void *)(a1 + v13) = v12;

        goto LABEL_40;
      case 5u:
        char v17 = 0;
        unsigned int v18 = 0;
        uint64_t v19 = 0;
        *(unsigned char *)(a1 + 48) |= 1u;
        while (2)
        {
          unint64_t v20 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v20 == -1 || v20 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }
          else
          {
            char v21 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v20);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v20 + 1;
            v19 |= (unint64_t)(v21 & 0x7F) << v17;
            if (v21 < 0)
            {
              v17 += 7;
              BOOL v9 = v18++ >= 9;
              if (v9)
              {
                LODWORD(v19) = 0;
                goto LABEL_39;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v19) = 0;
        }
LABEL_39:
        *(_DWORD *)(a1 + 16) = v19;
        goto LABEL_40;
      default:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_40;
    }
  }
}

void sub_10030A180(id a1)
{
  int v1 = objc_alloc_init(IDSCurrentDevice);
  uint64_t v2 = qword_100A4C730;
  qword_100A4C730 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_10030A988(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  _Block_object_dispose(&a28, 8);
  _Block_object_dispose(&a34, 8);
  _Block_object_dispose((const void *)(v34 - 184), 8);
  _Block_object_dispose((const void *)(v34 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10030A9C4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10030A9D4(uint64_t a1)
{
}

void sub_10030A9DC(uint64_t a1)
{
  uint64_t v2 = (char *)[*(id *)(a1 + 32) forceEncryptionType];
  if ((unint64_t)(v2 - 4) < 2 || v2 + 1 == 0)
  {
    char v4 = [*(id *)(a1 + 32) fullDeviceIdentityContainerEncrypter];
    uint64_t v5 = *(void *)(a1 + 40);
    uint64_t v6 = *(void *)(a1 + 48);
    uint64_t v7 = *(unsigned __int8 *)(a1 + 104);
    uint64_t v8 = *(unsigned __int8 *)(a1 + 105);
    uint64_t v9 = *(void *)(a1 + 80);
    uint64_t v10 = *(void *)(*(void *)(a1 + 88) + 8);
    id v11 = *(void **)(v10 + 40);
    uint64_t v12 = *(void *)(*(void *)(a1 + 96) + 8);
    uint64_t v14 = *(void *)(a1 + 56);
    uint64_t v13 = *(void *)(a1 + 64);
    id v26 = *(id *)(v12 + 40);
    id obj = v11;
    uint64_t v15 = *(void *)(v9 + 8);
    id v25 = *(id *)(v15 + 40);
    uint64_t v16 = [v4 encryptData:v5 encryptionContext:v6 forceSizeOptimizations:v7 resetState:v8 withEncryptedAttributes:v13 withPublicDeviceIdentityContainer:v14 usedIdentifier:&obj metadata:&v26 error:&v25];
    objc_storeStrong((id *)(v10 + 40), obj);
    objc_storeStrong((id *)(v12 + 40), v26);
    objc_storeStrong((id *)(v15 + 40), v25);
    uint64_t v17 = *(void *)(*(void *)(a1 + 72) + 8);
    unsigned int v18 = *(void **)(v17 + 40);
    *(void *)(v17 + 40) = v16;
  }
  else
  {
    if (v2 != (char *)6) {
      return;
    }
    char v4 = [*(id *)(a1 + 32) fullDeviceIdentityContainerEncrypter];
    uint64_t v19 = *(void *)(a1 + 40);
    uint64_t v20 = *(void *)(a1 + 48);
    uint64_t v21 = *(void *)(a1 + 56);
    uint64_t v22 = *(void *)(*(void *)(a1 + 80) + 8);
    id v28 = *(id *)(v22 + 40);
    uint64_t v23 = [v4 offGridKeyDistributionEncryptData:v19 encryptionContext:v20 withPublicDeviceIdentityContainer:v21 error:&v28];
    objc_storeStrong((id *)(v22 + 40), v28);
    uint64_t v24 = *(void *)(*(void *)(a1 + 72) + 8);
    unsigned int v18 = *(void **)(v24 + 40);
    *(void *)(v24 + 40) = v23;
  }
}

void sub_10030AD6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 112), 8);
  _Unwind_Resume(a1);
}

void sub_10030AD90(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) fullDeviceIdentityContainerEncrypter];
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = *(void *)(a1 + 56);
  uint64_t v6 = *(void *)(*(void *)(a1 + 72) + 8);
  id obj = *(id *)(v6 + 40);
  uint64_t v7 = [v2 legacyEncryptData:v3 withEncryptedAttributes:v4 withPublicDeviceIdentityContainer:v5 error:&obj];
  objc_storeStrong((id *)(v6 + 40), obj);
  uint64_t v8 = *(void *)(*(void *)(a1 + 64) + 8);
  uint64_t v9 = *(void **)(v8 + 40);
  *(void *)(v8 + 40) = v7;
}

void sub_10030B1B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_10030B1E4(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) fullDeviceIdentityContainerEncrypter];
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = *(void *)(*(void *)(a1 + 72) + 8);
  id obj = *(id *)(v5 + 40);
  uint64_t v6 = [v2 decryptData:v3 withPublicDeviceIdentityContainer:v4 error:&obj usingIdentifier:*(void *)(a1 + 56) isRetry:*(unsigned __int8 *)(a1 + 80)];
  objc_storeStrong((id *)(v5 + 40), obj);
  uint64_t v7 = *(void *)(*(void *)(a1 + 64) + 8);
  uint64_t v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v6;
}

void sub_10030B428(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) replayCommitter];
  uint64_t v3 = [v2 decryptedDataForKey:*(void *)(a1 + 40)];

  uint64_t v4 = [v3 decryptedData];
  uint64_t v5 = [v3 encryptedAttributes];
  if (v4)
  {
    uint64_t v6 = *(void *)(a1 + 72);
    uint64_t v7 = [[IDSDecryptionMetadata alloc] initWithUsedLastResortCache:0 usedCachedData:1];
    (*(void (**)(uint64_t, void *, void *, void, IDSDecryptionMetadata *))(v6 + 16))(v6, v4, v5, 0, v7);
  }
  else
  {
    uint64_t v8 = [*(id *)(a1 + 32) fullDeviceIdentityContainerEncrypter];
    uint64_t v9 = [v8 decryptData:*(void *)(a1 + 48) decryptionContext:0 withPublicDeviceIdentityContainer:*(void *)(a1 + 56) usingIdentifier:*(void *)(a1 + 64) isRetry:*(unsigned __int8 *)(a1 + 80)];
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_10030B5B0;
    v10[3] = &unk_100988AA0;
    void v10[4] = *(void *)(a1 + 32);
    id v12 = *(id *)(a1 + 72);
    id v11 = *(id *)(a1 + 40);
    [v9 registerResultBlock:v10];
  }
}

void sub_10030B5B0(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 state] == (id)1)
  {
    uint64_t v4 = [v3 error];

    uint64_t v5 = [v4 domain];
    if ([v5 isEqualToString:IDSDecryptionErrorDomain]
      && ([v4 code] == (id)12 || objc_msgSend(v4, "code") == (id)9))
    {
      uint64_t v6 = [*(id *)(a1 + 32) endpoint];
      uint64_t v7 = [v6 identityContainerDeserializationError];

      if (v7)
      {
        uint64_t v8 = [v4 domain];
        id v9 = [v4 code];
        NSErrorUserInfoKey v23 = NSUnderlyingErrorKey;
        uint64_t v10 = [*(id *)(a1 + 32) endpoint];
        id v11 = [v10 identityContainerDeserializationError];
        uint64_t v24 = v11;
        id v12 = +[NSDictionary dictionaryWithObjects:&v24 forKeys:&v23 count:1];
        uint64_t v13 = +[NSError errorWithDomain:v8 code:v9 userInfo:v12];

        uint64_t v4 = (void *)v13;
      }
    }
    else
    {
    }
    uint64_t v20 = *(void *)(a1 + 48);
    uint64_t v21 = objc_alloc_init(IDSDecryptionMetadata);
    (*(void (**)(uint64_t, void, void, void *, IDSDecryptionMetadata *))(v20 + 16))(v20, 0, 0, v4, v21);
  }
  else
  {
    id v22 = [v3 value];

    uint64_t v14 = [v22 decryptedData];
    uint64_t v15 = [v22 encryptedAttributes];
    uint64_t v16 = [v22 commitBlock];
    if (!CUTIsInternalInstall()
      || (+[IMUserDefaults isWritePushPayloadsToDiskEnabled] & 1) == 0)
    {
      uint64_t v17 = objc_msgSend(*(id *)(a1 + 32), "replayCommitter", v22);
      [v17 holdCommitBlock:v16 andDecryptedData:v14 withEncryptedAttributes:v15 forKey:*(void *)(a1 + 40)];
    }
    uint64_t v18 = *(void *)(a1 + 48);
    uint64_t v19 = [[IDSDecryptionMetadata alloc] initWithUsedLastResortCache:0 usedCachedData:0];
    (*(void (**)(uint64_t, void *, void *, void, IDSDecryptionMetadata *))(v18 + 16))(v18, v14, v15, 0, v19);
  }
}

void sub_10030B9CC(uint64_t a1)
{
  unsigned int v2 = [*(id *)(a1 + 32) _isNGMKeyType];
  id v3 = *(void **)(a1 + 32);
  if (v2)
  {
    uint64_t v4 = [v3 endpoint];
    uint64_t v5 = [v4 publicDeviceIdentityContainer];
    uint64_t v6 = [v5 ngmPublicDeviceIdentity];

    if (([*(id *)(a1 + 32) _isSecKeyType] & 1) == 0)
    {
      if (!v6) {
        goto LABEL_11;
      }
LABEL_8:
      id v9 = [*(id *)(a1 + 32) fullDeviceIdentitySigner];
      uint64_t v10 = *(void *)(a1 + 40);
      uint64_t v11 = *(void *)(a1 + 48);
      uint64_t v12 = *(void *)(a1 + 64);
      id v22 = 0;
      [v9 verifySignedData:v10 matchesData:v11 forType:v12 withPublicDeviceIdentity:v6 error:&v22];
      id v13 = v22;

      (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
      return;
    }
  }
  else
  {
    if (![v3 _isSecKeyType]) {
      goto LABEL_11;
    }
    uint64_t v6 = 0;
  }
  uint64_t v7 = [*(id *)(a1 + 32) endpoint];
  id v8 = [v7 applicationPublicDeviceIdentity];

  if (v6) {
    goto LABEL_8;
  }
  if (v8)
  {
    uint64_t v14 = [*(id *)(a1 + 32) fullDeviceIdentitySigner];
    uint64_t v16 = *(void *)(a1 + 40);
    uint64_t v15 = *(void *)(a1 + 48);
    uint64_t v17 = [*(id *)(a1 + 32) keyDiversifier];
    id v21 = 0;
    [v14 verifySignedData:v16 matchesData:v15 withSecPublicDeviceIdentity:v8 diversifier:v17 error:&v21];
    id v18 = v21;

    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
    return;
  }
LABEL_11:
  uint64_t v19 = *(void *)(a1 + 56);
  id v20 = +[NSError errorWithDomain:IDSSigningErrorDomain code:10 userInfo:0];
  (*(void (**)(uint64_t, void, id))(v19 + 16))(v19, 0, v20);
}

void sub_10030BD5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_10030BD80(uint64_t a1)
{
  unsigned int v2 = [*(id *)(a1 + 32) _isNGMKeyType];
  id v3 = *(void **)(a1 + 32);
  if (v2)
  {
    uint64_t v4 = [v3 endpoint];
    uint64_t v5 = [v4 publicDeviceIdentityContainer];
    uint64_t v6 = [v5 ngmPublicDeviceIdentity];

    if (([*(id *)(a1 + 32) _isSecKeyType] & 1) == 0)
    {
      if (!v6) {
        goto LABEL_12;
      }
      goto LABEL_8;
    }
  }
  else
  {
    if (![v3 _isSecKeyType]) {
      goto LABEL_12;
    }
    uint64_t v6 = 0;
  }
  uint64_t v7 = [*(id *)(a1 + 32) endpoint];
  id v8 = [v7 applicationPublicDeviceIdentity];

  if (v6)
  {
LABEL_8:
    id v9 = [*(id *)(a1 + 32) fullDeviceIdentitySigner];
    uint64_t v10 = *(void *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 48);
    uint64_t v12 = *(void *)(a1 + 72);
    uint64_t v13 = *(void *)(*(void *)(a1 + 64) + 8);
    id obj = *(id *)(v13 + 40);
    unsigned __int8 v14 = [v9 verifySignedData:v10 matchesData:v11 forType:v12 withPublicDeviceIdentity:v6 error:&obj];
    objc_storeStrong((id *)(v13 + 40), obj);
    *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = v14;

LABEL_11:
    return;
  }
  if (v8)
  {
    uint64_t v6 = [*(id *)(a1 + 32) fullDeviceIdentitySigner];
    uint64_t v16 = *(void *)(a1 + 40);
    uint64_t v15 = *(void *)(a1 + 48);
    uint64_t v17 = [*(id *)(a1 + 32) keyDiversifier];
    uint64_t v18 = *(void *)(*(void *)(a1 + 64) + 8);
    id v23 = *(id *)(v18 + 40);
    unsigned __int8 v19 = [v6 verifySignedData:v16 matchesData:v15 withSecPublicDeviceIdentity:v8 diversifier:v17 error:&v23];
    objc_storeStrong((id *)(v18 + 40), v23);
    *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = v19;

    goto LABEL_11;
  }
LABEL_12:
  uint64_t v20 = +[NSError errorWithDomain:IDSSigningErrorDomain code:10 userInfo:0];
  uint64_t v21 = *(void *)(*(void *)(a1 + 64) + 8);
  uint64_t v22 = *(void *)(v21 + 40);
  *(void *)(v21 + 40) = v20;

  _objc_release_x1(v20, v22);
}

BOOL sub_10030C080(int a1)
{
  return a1 == 1;
}

uint64_t sub_10030C08C(int a1)
{
  if ((a1 - 1) < 3) {
    return (unsigned __int16)(a1 - 1) + 1;
  }
  else {
    return 0;
  }
}

void sub_10030C274(id a1)
{
  int v1 = objc_alloc_init(IDSStewieCTMessagingClient);
  uint64_t v2 = qword_100A4C740;
  qword_100A4C740 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_10030C738(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = +[IDSFoundationLog stewieMessaging];
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    id v8 = [*(id *)(a1 + 32) identifier];
    if ([v5 success]) {
      CFStringRef v9 = @"YES";
    }
    else {
      CFStringRef v9 = @"NO";
    }
    uint64_t v10 = [v5 error];
    int v14 = 138413058;
    uint64_t v15 = v8;
    __int16 v16 = 2112;
    CFStringRef v17 = v9;
    __int16 v18 = 2112;
    unsigned __int8 v19 = v10;
    __int16 v20 = 2112;
    id v21 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Sent iMessage Lite %@ with Success %@, Error %@, Metadata %@", (uint8_t *)&v14, 0x2Au);
  }
  uint64_t v11 = *(void *)(a1 + 40);
  id v12 = [v5 success];
  uint64_t v13 = [v5 error];
  (*(void (**)(uint64_t, id, void *))(v11 + 16))(v11, v12, v13);
}

void sub_10030CAA4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = [*(id *)(a1 + 40) shortHandleNumberFromBase64String:a2];
  [v2 addObject:v3];
}

void sub_10030CAFC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = +[IDSFoundationLog stewieMessaging];
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(a1 + 32);
    if ([v5 success]) {
      CFStringRef v9 = @"YES";
    }
    else {
      CFStringRef v9 = @"NO";
    }
    uint64_t v10 = [v5 error];
    int v14 = 138413058;
    uint64_t v15 = v8;
    __int16 v16 = 2112;
    CFStringRef v17 = v9;
    __int16 v18 = 2112;
    unsigned __int8 v19 = v10;
    __int16 v20 = 2112;
    id v21 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Sent fetch message %@ with Success %@, Error %@, Metadata %@", (uint8_t *)&v14, 0x2Au);
  }
  uint64_t v11 = *(void *)(a1 + 40);
  id v12 = [v5 success];
  uint64_t v13 = [v5 error];
  (*(void (**)(uint64_t, id, void *))(v11 + 16))(v11, v12, v13);
}

void sub_10030CE54(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = a2;
  id v4 = [v3 success];
  id v5 = [v3 error];

  (*(void (**)(uint64_t, id, id))(v2 + 16))(v2, v4, v5);
}

void sub_10030D810(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog stewieMessaging];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    uint64_t v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Calling ack for incoming offgrid message with metadata %@", buf, 0xCu);
  }

  id v4 = *(NSObject **)(*(void *)(a1 + 40) + 16);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10030D92C;
  block[3] = &unk_10097E7F0;
  id v6 = *(id *)(a1 + 48);
  dispatch_async(v4, block);
}

uint64_t sub_10030D92C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10030D93C(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog stewieMessaging];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    uint64_t v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Calling ack for incoming summary message with metadata %@", buf, 0xCu);
  }

  id v4 = *(NSObject **)(*(void *)(a1 + 40) + 16);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10030DA58;
  block[3] = &unk_10097E7F0;
  id v6 = *(id *)(a1 + 48);
  dispatch_async(v4, block);
}

uint64_t sub_10030DA58(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

NSMutableDictionary *__cdecl sub_10030E00C(id a1, NSDictionary *a2, int64_t a3)
{
  id v4 = a2;
  id v5 = objc_alloc_init(IDSKeychainWrapper);
  id v27 = 0;
  unsigned __int8 v6 = [(IDSKeychainWrapper *)v5 removeDataForIdentifier:@"personal-session-token-cache" dataProtectionClass:2 error:&v27];
  id v7 = v27;
  if ((v6 & 1) == 0)
  {
    uint64_t v8 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      int64_t v29 = (int64_t)v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to remove peerIDCache v0 {error: %{public}@}", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      id v21 = v7;
      _IDSLogTransport();
    }
  }
  id v26 = v7;
  unsigned __int8 v9 = [(IDSKeychainWrapper *)v5 removeDataForIdentifier:@"personal-session-token-cache-v1", 2, &v26, v21 dataProtectionClass error];
  id v10 = v26;

  if ((v9 & 1) == 0)
  {
    uint64_t v11 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      int64_t v29 = (int64_t)v10;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Failed to remove peerIDCache v1 {error: %{public}@}", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      id v22 = v10;
      _IDSLogTransport();
    }
  }
  id v25 = v10;
  unsigned __int8 v12 = [(IDSKeychainWrapper *)v5 removeDataForIdentifier:@"personal-session-token-cache-v2", 2, &v25, v22 dataProtectionClass error];
  id v13 = v25;

  if ((v12 & 1) == 0)
  {
    int v14 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      int64_t v29 = (int64_t)v13;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Failed to remove peerIDCache v2 {error: %{public}@}", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      id v23 = v13;
      _IDSLogTransport();
    }
  }
  id v24 = v13;
  unsigned __int8 v15 = [(IDSKeychainWrapper *)v5 removeDataForIdentifier:@"personal-session-token-cache-v3", 2, &v24, v23 dataProtectionClass error];
  id v16 = v24;

  if ((v15 & 1) == 0)
  {
    CFStringRef v17 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      int64_t v29 = (int64_t)v16;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to remove peerIDCache v3 {error: %{public}@}", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      _IDSLogTransport();
    }
  }
  __int16 v18 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    int64_t v29 = a3;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Migrated Peer ID persistent map {oldVersionNumber: %ld}", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  id v19 = objc_alloc_init((Class)NSMutableDictionary);

  return (NSMutableDictionary *)v19;
}

NSMutableDictionary *__cdecl sub_10030E700(id a1, NSDictionary *a2, int64_t a3)
{
  id v4 = a2;
  id v5 = objc_alloc_init(IDSKeychainWrapper);
  id v27 = 0;
  unsigned __int8 v6 = [(IDSKeychainWrapper *)v5 removeDataForIdentifier:@"personal-session-token-cache" dataProtectionClass:2 error:&v27];
  id v7 = v27;
  if ((v6 & 1) == 0)
  {
    uint64_t v8 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      int64_t v29 = (int64_t)v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to remove peerIDCache v0 {error: %{public}@}", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      id v21 = v7;
      _IDSLogTransport();
    }
  }
  id v26 = v7;
  unsigned __int8 v9 = [(IDSKeychainWrapper *)v5 removeDataForIdentifier:@"personal-session-token-cache-v1", 2, &v26, v21 dataProtectionClass error];
  id v10 = v26;

  if ((v9 & 1) == 0)
  {
    uint64_t v11 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      int64_t v29 = (int64_t)v10;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Failed to remove peerIDCache v1 {error: %{public}@}", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      id v22 = v10;
      _IDSLogTransport();
    }
  }
  id v25 = v10;
  unsigned __int8 v12 = [(IDSKeychainWrapper *)v5 removeDataForIdentifier:@"personal-session-token-cache-v2", 2, &v25, v22 dataProtectionClass error];
  id v13 = v25;

  if ((v12 & 1) == 0)
  {
    int v14 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      int64_t v29 = (int64_t)v13;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Failed to remove peerIDCache v2 {error: %{public}@}", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      id v23 = v13;
      _IDSLogTransport();
    }
  }
  id v24 = v13;
  unsigned __int8 v15 = [(IDSKeychainWrapper *)v5 removeDataForIdentifier:@"personal-session-token-cache-v3", 2, &v24, v23 dataProtectionClass error];
  id v16 = v24;

  if ((v15 & 1) == 0)
  {
    CFStringRef v17 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      int64_t v29 = (int64_t)v16;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to remove peerIDCache v3 {error: %{public}@}", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      _IDSLogTransport();
    }
  }
  __int16 v18 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    int64_t v29 = a3;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Migrated Peer ID persistent map {oldVersionNumber: %ld}", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  id v19 = objc_alloc_init((Class)NSMutableDictionary);

  return (NSMutableDictionary *)v19;
}

void sub_10030EE4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t sub_10030EE68(uint64_t a1)
{
  long long v60 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id obj = [WeakRetained persistentMaps];
  id v41 = [obj countByEnumeratingWithState:&v60 objects:v72 count:16];
  if (v41)
  {
    uint64_t v40 = *(void *)v61;
    do
    {
      for (i = 0; i != v41; i = (char *)i + 1)
      {
        if (*(void *)v61 != v40) {
          objc_enumerationMutation(obj);
        }
        id v46 = *(void **)(*((void *)&v60 + 1) + 8 * i);
        int v1 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Query cache:", buf, 2u);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
          _IDSLogV();
        }
        long long v58 = 0u;
        long long v59 = 0u;
        long long v56 = 0u;
        long long v57 = 0u;
        objc_msgSend(v46, "allKeys", v35);
        id v44 = (id)objc_claimAutoreleasedReturnValue();
        id v47 = [v44 countByEnumeratingWithState:&v56 objects:v71 count:16];
        if (v47)
        {
          uint64_t v45 = *(void *)v57;
          do
          {
            for (j = 0; j != v47; j = (char *)j + 1)
            {
              if (*(void *)v57 != v45) {
                objc_enumerationMutation(v44);
              }
              uint64_t v2 = *(void **)(*((void *)&v56 + 1) + 8 * (void)j);
              uint64_t v3 = OSLogHandleForIDSCategory();
              if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
              {
                id v4 = [v2 service];
                id v5 = [v2 fromURI];
                unsigned __int8 v6 = [v2 toURI];
                *(_DWORD *)buf = 138543875;
                CFStringRef v66 = v4;
                __int16 v67 = 2113;
                id v68 = v5;
                __int16 v69 = 2113;
                unsigned __int8 v70 = v6;
                _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Key: <%{public}@,from:%{private}@,to:%{private}@>", buf, 0x20u);
              }
              if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
              {
                id v7 = [v2 service];
                uint64_t v8 = [v2 fromURI];
                [v2 toURI];
                v37 = uint64_t v36 = v8;
                uint64_t v35 = v7;
                _IDSLogV();
              }
              long long v54 = 0u;
              long long v55 = 0u;
              long long v52 = 0u;
              long long v53 = 0u;
              unsigned __int8 v9 = objc_msgSend(v46, "objectForKey:", v2, v35, v36, v37);
              id v49 = [v9 endpoints];

              id v51 = [v49 countByEnumeratingWithState:&v52 objects:v64 count:16];
              if (v51)
              {
                uint64_t v50 = *(void *)v53;
                do
                {
                  for (k = 0; k != v51; k = (char *)k + 1)
                  {
                    if (*(void *)v53 != v50) {
                      objc_enumerationMutation(v49);
                    }
                    uint64_t v11 = *(void **)(*((void *)&v52 + 1) + 8 * (void)k);
                    objc_msgSend(v11, "serializedPublicLegacyIdentity", v35);
                    unsigned __int8 v12 = (__CFString *)objc_claimAutoreleasedReturnValue();
                    id v13 = OSLogHandleForIDSCategory();
                    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
                    {
                      int v14 = [v11 URI];
                      *(_DWORD *)buf = 138412290;
                      CFStringRef v66 = v14;
                      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "        URI: %@", buf, 0xCu);
                    }
                    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
                    {
                      uint64_t v35 = [v11 URI];
                      _IDSLogV();
                    }
                    unsigned __int8 v15 = OSLogHandleForIDSCategory();
                    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
                    {
                      id v16 = [v11 shortHandle];
                      *(_DWORD *)buf = 138412290;
                      CFStringRef v66 = v16;
                      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "        Short Handle: %@", buf, 0xCu);
                    }
                    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
                    {
                      uint64_t v35 = [v11 shortHandle];
                      _IDSLogV();
                    }
                    CFStringRef v17 = OSLogHandleForIDSCategory();
                    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
                    {
                      __int16 v18 = [v11 pushToken];
                      id v19 = [v18 debugDescription];
                      *(_DWORD *)buf = 138412290;
                      CFStringRef v66 = v19;
                      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "        Push token: %@", buf, 0xCu);
                    }
                    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
                    {
                      __int16 v20 = [v11 pushToken];
                      uint64_t v35 = [v20 debugDescription];
                      _IDSLogV();
                    }
                    id v21 = OSLogHandleForIDSCategory();
                    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
                    {
                      id v22 = [v11 sessionToken];
                      id v23 = [v22 debugDescription];
                      *(_DWORD *)buf = 138412290;
                      CFStringRef v66 = v23;
                      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "        Session token: %@", buf, 0xCu);
                    }
                    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
                    {
                      id v24 = [v11 sessionToken];
                      uint64_t v35 = [v24 debugDescription];
                      _IDSLogV();
                    }
                    id v25 = OSLogHandleForIDSCategory();
                    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
                    {
                      id v26 = [v11 expireDate];
                      *(_DWORD *)buf = 138412290;
                      CFStringRef v66 = v26;
                      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "        Expire: %@", buf, 0xCu);
                    }
                    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
                    {
                      uint64_t v35 = [v11 expireDate];
                      _IDSLogV();
                    }
                    id v27 = OSLogHandleForIDSCategory();
                    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
                    {
                      id v28 = [v11 refreshDate];
                      *(_DWORD *)buf = 138412290;
                      CFStringRef v66 = v28;
                      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "        Refresh: %@", buf, 0xCu);
                    }
                    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
                    {
                      uint64_t v35 = [v11 refreshDate];
                      _IDSLogV();
                    }
                    int64_t v29 = OSLogHandleForIDSCategory();
                    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 138412290;
                      CFStringRef v66 = v12;
                      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "        Public Key: %@", buf, 0xCu);
                    }

                    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
                    {
                      uint64_t v35 = v12;
                      _IDSLogV();
                    }
                  }
                  id v51 = [v49 countByEnumeratingWithState:&v52 objects:v64 count:16];
                }
                while (v51);
              }
            }
            id v47 = [v44 countByEnumeratingWithState:&v56 objects:v71 count:16];
          }
          while (v47);
        }
      }
      id v41 = [obj countByEnumeratingWithState:&v60 objects:v72 count:16];
    }
    while (v41);
  }

  uint64_t v30 = +[IMRGLog sysdiagnose_oversized];
  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
  {
    id v31 = [*(id *)(a1 + 32) keyTransparencyVerifier];
    unsigned int v32 = [v31 isOptedInForServiceIdentifier:@"com.apple.madrid"];
    CFStringRef v33 = @"NO";
    if (v32) {
      CFStringRef v33 = @"YES";
    }
    *(_DWORD *)buf = 138412290;
    CFStringRef v66 = v33;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "KT Opt In State: %@", buf, 0xCu);
  }
  return 0;
}

void sub_100312894(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 138412802;
    uint64_t v10 = v8;
    __int16 v11 = 2112;
    id v12 = v5;
    __int16 v13 = 2112;
    id v14 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Triggered auto bug capture for excessive query cache entries for service: %@ {session : %@, error: %@}", buf, 0x20u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
}

void sub_1003129DC(id a1, NSArray *a2, NSError *a3)
{
  uint64_t v3 = a3;
  if (v3)
  {
    id v4 = +[IDSFoundationLog KeyTransparency];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 138412290;
      id v6 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Failed kicking KT peer verification for query { error: %@ }", (uint8_t *)&v5, 0xCu);
    }
  }
}

void sub_100312A94(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) queryCompletionBlock];
  (*((void (**)(id, void, void, void))v2 + 2))(v2, *(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56));
}

uint64_t sub_10031371C(uint64_t a1, void *a2)
{
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = [a2 pushToken];
  uint64_t v4 = [v2 isEqualToData:v3] ^ 1;

  return v4;
}

id sub_100313764(uint64_t a1, void *a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = a2;
  uint64_t v4 = [v2 rawToken];
  int v5 = [v3 pushToken];

  id v6 = [v4 isEqualToData:v5];
  return v6;
}

id sub_100313920(uint64_t a1, void *a2)
{
  id v3 = [a2 pushTokenObject];
  id v4 = [v3 isEqualToPushToken:*(void *)(a1 + 32)];

  return v4;
}

id sub_100313D44(uint64_t a1, void *a2)
{
  id v3 = [a2 pushTokenObject];
  id v4 = [v3 isEqualToPushToken:*(void *)(a1 + 32)];

  return v4;
}

id sub_100314B24(uint64_t a1, void *a2)
{
  id v3 = [a2 pushTokenObject];
  id v4 = [v3 isEqualToPushToken:*(void *)(a1 + 32)];

  return v4;
}

uint64_t sub_100314F00(uint64_t a1, void *a2)
{
  id v3 = a2;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  id v4 = *(id *)(a1 + 32);
  id v5 = [v4 countByEnumeratingWithState:&v16 objects:v20 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v17;
    while (2)
    {
      for (i = 0; i != v6; i = (char *)i + 1)
      {
        if (*(void *)v17 != v7) {
          objc_enumerationMutation(v4);
        }
        uint64_t v9 = *(void *)(*((void *)&v16 + 1) + 8 * i);
        uint64_t v10 = objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", v9, (void)v16);
        __int16 v11 = [v3 capabilities];
        id v12 = [v11 valueForCapability:v9];
        id v13 = [v10 integerValue];

        if (v12 != v13)
        {
          uint64_t v14 = 0;
          goto LABEL_11;
        }
      }
      id v6 = [v4 countByEnumeratingWithState:&v16 objects:v20 count:16];
      if (v6) {
        continue;
      }
      break;
    }
  }
  uint64_t v14 = 1;
LABEL_11:

  return v14;
}

id sub_100315C50(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 service];
  if ([v4 isEqualToString:*(void *)(a1 + 32)])
  {
    id v5 = [v3 fromURI];
    id v6 = [v5 isEqual:*(void *)(a1 + 40)];
  }
  else
  {
    id v6 = 0;
  }

  return v6;
}

id sub_100315DB0(uint64_t a1, void *a2)
{
  id v3 = [a2 service];
  id v4 = [v3 isEqualToString:*(void *)(a1 + 32)];

  return v4;
}

id sub_100316188(id a1, NSString *a2)
{
  id v2 = a2;
  if ([(NSString *)v2 isEqualToString:kFZServiceDefaultsSentinelAlias]
    || [(NSString *)v2 isEqualToString:kIDSServiceDefaultsSentinelSelfAlias])
  {
    id v3 = 0;
  }
  else
  {
    id v3 = +[IDSURI URIWithPrefixedURI:v2];
  }

  return v3;
}

id sub_100316C6C(id a1, IDSURI *a2)
{
  id v2 = a2;
  id v4 = [(IDSURI *)v2 tokenFreeURI];

  return v4;
}

void sub_100316CD0(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, unsigned int a8, void *a9, unsigned __int8 a10)
{
  id v48 = a2;
  id v47 = a3;
  id v16 = a4;
  id v46 = a5;
  id v45 = a6;
  id v44 = a7;
  id v43 = a9;
  long long v17 = *(void **)(a1 + 32);
  long long v18 = [*(id *)(a1 + 40) allObjects];
  id v49 = [v17 endpointsForURIs:v18 service:*(void *)(a1 + 48) fromURI:*(void *)(a1 + 56)];

  id v19 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithCapacity:", objc_msgSend(*(id *)(a1 + 64), "count"));
  __int16 v20 = +[NSMutableDictionary dictionary];
  long long v57 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  id obj = *(id *)(a1 + 64);
  id v53 = [obj countByEnumeratingWithState:&v57 objects:v61 count:16];
  if (v53)
  {
    uint64_t v52 = *(void *)v58;
    uint64_t v51 = a1;
    do
    {
      for (i = 0; i != v53; i = (char *)i + 1)
      {
        if (*(void *)v58 != v52) {
          objc_enumerationMutation(obj);
        }
        id v22 = *(void **)(*((void *)&v57 + 1) + 8 * i);
        id v24 = [v22 pushToken];
        id v25 = [v22 tokenFreeURI];
        id v26 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", [*(id *)(a1 + 32) hasPeerTokensForURI:v25 fromURI:*(void *)(a1 + 56) service:*(void *)(a1 + 48)]);
        [v19 setObject:v26 forKey:v25];

        context = v23;
        if (![v16 count])
        {
          if (!v24) {
            goto LABEL_17;
          }
LABEL_11:
          int64_t v29 = *(void **)(a1 + 72);
          goto LABEL_12;
        }
        unsigned __int8 v27 = [v16 containsObject:v25];
        unsigned __int8 v28 = v27;
        if (!v24)
        {
          if (v27) {
            uint64_t v37 = v49;
          }
          else {
LABEL_17:
          }
            uint64_t v37 = *(void **)(a1 + 72);
          unsigned int v32 = [v37 objectForKeyedSubscript:v25];
          [v20 setObject:v32 forKeyedSubscript:v25];
          goto LABEL_19;
        }
        int64_t v29 = v49;
        if ((v28 & 1) == 0) {
          goto LABEL_11;
        }
LABEL_12:
        id v30 = v19;
        id v31 = v16;
        unsigned int v32 = [v29 objectForKeyedSubscript:v25];
        v55[0] = _NSConcreteStackBlock;
        v55[1] = 3221225472;
        v55[2] = sub_10031711C;
        v55[3] = &unk_10097E5D0;
        id v56 = v24;
        CFStringRef v33 = objc_msgSend(v32, "__imArrayByFilteringWithBlock:", v55);
        uint64_t v34 = [v20 objectForKeyedSubscript:v25];
        uint64_t v35 = v34;
        if (v34)
        {
          uint64_t v36 = [v34 arrayByAddingObjectsFromArray:v33];

          CFStringRef v33 = (void *)v36;
        }
        [v20 setObject:v33 forKeyedSubscript:v25];

        id v16 = v31;
        id v19 = v30;
        a1 = v51;
LABEL_19:

        uint64_t v38 = [v20 objectForKeyedSubscript:v25];
        BOOL v39 = (void *)v38;
        if (v38) {
          uint64_t v40 = (void *)v38;
        }
        else {
          uint64_t v40 = &__NSArray0__struct;
        }
        [v20 setObject:v40 forKeyedSubscript:v25];
      }
      id v53 = [obj countByEnumeratingWithState:&v57 objects:v61 count:16];
    }
    while (v53);
  }

  uint64_t v41 = *(void *)(a1 + 80);
  if (v41) {
    (*(void (**)(uint64_t, id, id, id, id, void, id, void, void *))(v41 + 16))(v41, v48, v19, v45, v44, a8, v43, a10, v20);
  }
}

id sub_10031711C(uint64_t a1, void *a2)
{
  id v3 = [a2 pushTokenObject];
  id v4 = [v3 isEqualToPushToken:*(void *)(a1 + 32)];

  return v4;
}

id sub_1003185FC(id a1, NSString *a2)
{
  id v2 = a2;
  if ([(NSString *)v2 isEqualToString:kFZServiceDefaultsSentinelAlias]
    && [(NSString *)v2 isEqualToString:kIDSServiceDefaultsSentinelSelfAlias])
  {
    id v3 = 0;
  }
  else
  {
    id v3 = +[IDSURI URIWithPrefixedURI:v2];
  }

  return v3;
}

id sub_100318B14(uint64_t a1, void *a2)
{
  id v3 = [a2 service];
  id v4 = [v3 isEqualToString:*(void *)(a1 + 32)];

  return v4;
}

void sub_1003199B4(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, unsigned int a8, void *a9, unsigned __int8 a10)
{
  id v16 = a2;
  id v17 = a3;
  id v33 = a4;
  id v32 = a5;
  id v31 = a6;
  id v18 = a7;
  id v30 = a9;
  id v19 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithCapacity:", objc_msgSend(v17, "count"));
  long long v35 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  id obj = v17;
  id v20 = [obj countByEnumeratingWithState:&v35 objects:v39 count:16];
  if (v20)
  {
    id v21 = v20;
    uint64_t v22 = *(void *)v36;
    do
    {
      for (i = 0; i != v21; i = (char *)i + 1)
      {
        if (*(void *)v36 != v22) {
          objc_enumerationMutation(obj);
        }
        id v24 = *(void **)(*((void *)&v35 + 1) + 8 * i);
        id v26 = [v24 tokenFreeURI];
        unsigned __int8 v27 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", [*(id *)(a1 + 32) hasPeerTokensForURI:v26 fromURI:v16 service:v18]);
        [v19 setObject:v27 forKey:v26];
      }
      id v21 = [obj countByEnumeratingWithState:&v35 objects:v39 count:16];
    }
    while (v21);
  }

  uint64_t v28 = *(void *)(a1 + 40);
  if (v28) {
    (*(void (**)(uint64_t, id, id, id, id, void, id, void))(v28 + 16))(v28, v16, v19, v31, v18, a8, v30, a10);
  }
}

void sub_10031A504(void *a1)
{
  if (!*(void *)(a1[4] + 24))
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    uint64_t v3 = a1[4];
    id v4 = *(void **)(v3 + 24);
    *(void *)(v3 + 24) = Mutable;
  }
  id v5 = [[IDSPeerIDManagerEndpointQueryListener alloc] initWithQueryCompletionBlock:a1[7] queue:a1[5]];
  [*(id *)(a1[4] + 24) setObject:v5 forKey:a1[6]];
}

void sub_10031A740(uint64_t a1)
{
  [*(id *)(*(void *)(a1 + 32) + 24) removeObjectForKey:*(void *)(a1 + 40)];
  if (![*(id *)(*(void *)(a1 + 32) + 24) count])
  {
    uint64_t v2 = *(void *)(a1 + 32);
    uint64_t v3 = *(void **)(v2 + 24);
    *(void *)(v2 + 24) = 0;
  }
}

uint64_t sub_10031AAA4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10031AAB8(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) endpointsForURIs:*(void *)(a1 + 40) service:*(void *)(a1 + 48) fromURI:*(void *)(a1 + 56)];
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_10031AB78;
  v6[3] = &unk_10097E818;
  uint64_t v3 = *(NSObject **)(a1 + 64);
  id v4 = *(id *)(a1 + 72);
  id v7 = v2;
  id v8 = v4;
  id v5 = v2;
  dispatch_async(v3, v6);
}

uint64_t sub_10031AB78(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

id sub_10031AC80(uint64_t a1)
{
  return _[*(id *)(a1 + 32) cleanupExpiredEntriesIfNeeded];
}

id sub_10031ACF8(uint64_t a1)
{
  return _[*(id *)(a1 + 32) removeExcessiveQueryEntriesIfNeeded];
}

void sub_10031BA0C(id a1)
{
  int v1 = objc_alloc_init(IDSGroupEncryptionController);
  uint64_t v2 = qword_100A4C750;
  qword_100A4C750 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_10031CD50(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10031D2B8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10031DA9C(id a1)
{
  int v1 = objc_alloc_init(IDSDMessageStore);
  uint64_t v2 = qword_100A4C760;
  qword_100A4C760 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_10031E6A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
}

uint64_t sub_10031E700(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10031E710(uint64_t a1)
{
}

void sub_10031E718(uint64_t a1)
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_10031E798;
  v2[3] = &unk_100988E20;
  long long v3 = *(_OWORD *)(a1 + 40);
  uint64_t v1 = *(void *)(a1 + 64);
  uint64_t v4 = *(void *)(a1 + 56);
  sub_1003E5C84(v1, v2, *(void **)(a1 + 32));
}

void sub_10031E798(void *a1)
{
  CFArrayRef v2 = (const __CFArray *)CSDBRecordStoreProcessStatement();
  *(void *)(*(void *)(a1[4] + 8) + 24) = CFArrayGetCount(v2);
  if (*(uint64_t *)(*(void *)(a1[4] + 8) + 24) >= 1)
  {
    CFIndex v3 = 0;
    do
    {
      CFArrayGetValueAtIndex(v2, v3);
      uint64_t v4 = *(void *)(*(void *)(a1[5] + 8) + 24);
      CSDBRecordGetID();
      uint64_t RowidForRecordID = CSDBRecordStoreGetRowidForRecordID();
      if (v4 <= RowidForRecordID) {
        uint64_t v6 = RowidForRecordID;
      }
      else {
        uint64_t v6 = v4;
      }
      *(void *)(*(void *)(a1[5] + 8) + 24) = v6;
      CSDBRecordIndexOfPropertyNamed();
      uint64_t Property = CSDBRecordGetProperty();
      id v8 = objc_alloc_init((Class)IDSMessageToDelete);
      [v8 setDataProtectionClass:Property];
      CSDBRecordIndexOfPropertyNamed();
      uint64_t v9 = (const void *)CSDBRecordCopyProperty();
      [v8 setGUID:v9];
      CSDBRecordIndexOfPropertyNamed();
      uint64_t v10 = (const void *)CSDBRecordCopyProperty();
      [v8 setAlternateGUID:v10];
      __int16 v11 = IDSDataProtectionClassStringFromDataProtectionClass();
      id v12 = [*(id *)(*(void *)(a1[6] + 8) + 40) objectForKey:v11];
      if (!v12) {
        id v12 = objc_alloc_init((Class)NSMutableArray);
      }
      [v12 addObject:v8];
      [*(id *)(*(void *)(a1[6] + 8) + 40) setObject:v12 forKey:v11];
      if (v9) {
        CFRelease(v9);
      }
      if (v10) {
        CFRelease(v10);
      }

      ++v3;
    }
    while (v3 < *(void *)(*(void *)(a1[4] + 8) + 24));
  }
  if (v2)
  {
    CFRelease(v2);
  }
}

void sub_10031E9DC(uint64_t a1)
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_10031EA54;
  v2[3] = &unk_100988E70;
  uint64_t v1 = *(void **)(a1 + 32);
  void v2[4] = *(void *)(a1 + 40);
  sub_1003E5D0C(@"DELETE FROM outgoing_messages_to_delete WHERE ROWID <= ?;", v2, v1);
}

uint64_t sub_10031EA54()
{
  CSDBSqliteBindInt64();

  return CSDBSqliteStatementPerform();
}

void sub_10031ED28(uint64_t a1)
{
  CFArrayRef v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  id v3 = [*(id *)(a1 + 32) database];
  sub_100044BB0(v3);
}

void sub_100320F6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t sub_100320F88(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100321034;
  v3[3] = &unk_100981000;
  objc_copyWeak(&v4, (id *)(a1 + 40));
  [v1 performBlock:v3 waitUntilDone:1];
  objc_destroyWeak(&v4);
  return 0;
}

void sub_100321020(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_100321034(uint64_t a1)
{
  uint64_t v1 = (id *)(a1 + 32);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v3 = [WeakRetained database];
  id v4 = (void *)sub_1000417BC(v3);

  id v5 = objc_loadWeakRetained(v1);
  uint64_t v6 = [v5 database];
  id v7 = (void *)sub_100348648(v6);

  uint64_t v9 = sub_10032117C(v8, v4);
  uint64_t v10 = sub_10032117C((uint64_t)v9, v7);
  __int16 v11 = +[IDSFoundationLog IDSMessageStore];
  if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
  {
    int v12 = 138412546;
    id v13 = v9;
    __int16 v14 = 2112;
    unsigned __int8 v15 = v10;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "Database state:\n  Outgoing (account_guid, count)\n%@  Incoming (topic, count)\n%@", (uint8_t *)&v12, 0x16u);
  }
}

id sub_10032117C(uint64_t a1, void *a2)
{
  id v2 = a2;
  id v3 = [&stru_10099BE78 mutableCopy];
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  id v4 = v2;
  id v5 = [v4 countByEnumeratingWithState:&v14 objects:v18 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v15;
    do
    {
      for (i = 0; i != v6; i = (char *)i + 1)
      {
        if (*(void *)v15 != v7) {
          objc_enumerationMutation(v4);
        }
        uint64_t v9 = *(void **)(*((void *)&v14 + 1) + 8 * i);
        if ((unint64_t)[v9 count] >= 2)
        {
          uint64_t v10 = [v9 objectAtIndexedSubscript:0];
          __int16 v11 = [v9 objectAtIndexedSubscript:1];
          [v3 appendFormat:@"    %@  %@\n", v10, v11, (void)v14];
        }
      }
      id v6 = [v4 countByEnumeratingWithState:&v14 objects:v18 count:16];
    }
    while (v6);
  }

  id v12 = [v3 copy];

  return v12;
}

void sub_100321374(uint64_t a1)
{
  id v2 = +[IDSFoundationLog IDSMessageStore];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)id v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Performing initial database housekeeping", v4, 2u);
  }

  j__CSDBSqliteSetDefaultPageCacheSize();
  id v3 = [*(id *)(a1 + 32) database];
  sub_1003E6018(v3);
}

void sub_1003214F4(uint64_t a1)
{
  id v2 = (id *)(a1 + 32);
  id v3 = [*(id *)(a1 + 32) database];
  [v3 ensureDatabaseIsInitialized];

  int v4 = *(_DWORD *)(a1 + 64);
  uint64_t v5 = *(void *)(a1 + 48);
  BOOL v6 = *(unsigned __int8 *)(a1 + 68) == 1;
  uint64_t v7 = [*v2 database];
  if (v4) {
    uint64_t v8 = sub_100348D30(v5, v4, v6, v7, *(unsigned char **)(a1 + 56));
  }
  else {
    uint64_t v8 = sub_100348790(v5, v6, v7, *(unsigned char **)(a1 + 56));
  }
  CFArrayRef v9 = (const __CFArray *)v8;

  if (v9)
  {
    int Count = CFArrayGetCount(v9);
    if (Count >= 1)
    {
      CFIndex v11 = 0;
      if (Count <= 1uLL) {
        uint64_t v12 = 1;
      }
      else {
        uint64_t v12 = Count;
      }
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v9, v11);
        CFTypeRef v24 = 0;
        CFTypeRef cf = 0;
        CFTypeRef v22 = 0;
        CFTypeRef v23 = 0;
        unsigned __int8 v21 = 0;
        unsigned int v20 = -1431655766;
        uint64_t v19 = 0;
        long long v14 = [*(id *)(a1 + 32) database];
        sub_1003493B4((uint64_t)ValueAtIndex, 0, (uint64_t)&v24, (uint64_t)&v23, (uint64_t)&v22, (uint64_t)&cf, 0, (uint64_t)&v21, (uint64_t)&v19, (uint64_t)&v20, v14);

        long long v15 = JWDecodeDictionary();
        if (v15)
        {
          long long v16 = [IDSDIncomingMessage alloc];
          long long v17 = [(IDSDIncomingMessage *)v16 initWithMessage:v15 fromID:v22 topic:v23 guid:v24 isLocal:v21];
          [(IDSDIncomingMessage *)v17 setControlCategory:v20];
          [(IDSDIncomingMessage *)v17 setExpirationDate:v19];
          [*(id *)(a1 + 40) addObject:v17];
          if (cf)
          {
            CFRelease(cf);
            CFTypeRef cf = 0;
          }
          if (v24)
          {
            CFRelease(v24);
            CFTypeRef v24 = 0;
          }
          if (v23)
          {
            CFRelease(v23);
            CFTypeRef v23 = 0;
          }
          if (v22)
          {
            CFRelease(v22);
            CFTypeRef v22 = 0;
          }
        }
        else
        {
          id v18 = +[IDSFoundationLog IDSMessageStore];
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            CFTypeRef v27 = v24;
            _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Bad messageData for incoming message %@!", buf, 0xCu);
          }

          [*(id *)(a1 + 32) deleteIncomingMessageWithGUID:v24];
        }
        ++v11;
      }
      while (v12 != v11);
    }
    CFRelease(v9);
  }
}

void sub_100321870(_Unwind_Exception *a1)
{
  if (v1) {
    objc_end_catch();
  }
  _Unwind_Resume(a1);
}

void sub_10032188C(uint64_t a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  JUMPOUT(0x100321898);
}

void sub_100321980(uint64_t a1)
{
  id v2 = (id *)(a1 + 32);
  id v3 = [*(id *)(a1 + 32) database];
  [v3 ensureDatabaseIsInitialized];

  double v4 = *(double *)(a1 + 48);
  uint64_t v5 = [*v2 database];
  CFArrayRef v6 = (const __CFArray *)sub_100348A6C((uint64_t)v4, v5, *(unsigned char **)(a1 + 56));

  if (v6)
  {
    int Count = CFArrayGetCount(v6);
    if (Count >= 1)
    {
      CFIndex v8 = 0;
      if (Count <= 1uLL) {
        uint64_t v9 = 1;
      }
      else {
        uint64_t v9 = Count;
      }
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v6, v8);
        CFTypeRef v21 = 0;
        CFTypeRef cf = 0;
        CFTypeRef v19 = 0;
        CFTypeRef v20 = 0;
        unsigned __int8 v18 = 0;
        unsigned int v17 = -1431655766;
        uint64_t v16 = 0;
        CFIndex v11 = [*(id *)(a1 + 32) database];
        sub_1003493B4((uint64_t)ValueAtIndex, 0, (uint64_t)&v21, (uint64_t)&v20, (uint64_t)&v19, (uint64_t)&cf, 0, (uint64_t)&v18, (uint64_t)&v16, (uint64_t)&v17, v11);

        uint64_t v12 = JWDecodeDictionary();
        if (v12)
        {
          id v13 = [IDSDIncomingMessage alloc];
          long long v14 = [(IDSDIncomingMessage *)v13 initWithMessage:v12 fromID:v19 topic:v20 guid:v21 isLocal:v18];
          [(IDSDIncomingMessage *)v14 setControlCategory:v17];
          [(IDSDIncomingMessage *)v14 setExpirationDate:v16];
          [*(id *)(a1 + 40) addObject:v14];
          if (cf)
          {
            CFRelease(cf);
            CFTypeRef cf = 0;
          }
          if (v21)
          {
            CFRelease(v21);
            CFTypeRef v21 = 0;
          }
          if (v20)
          {
            CFRelease(v20);
            CFTypeRef v20 = 0;
          }
          if (v19)
          {
            CFRelease(v19);
            CFTypeRef v19 = 0;
          }
        }
        else
        {
          long long v15 = +[IDSFoundationLog IDSMessageStore];
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            CFTypeRef v24 = v21;
            _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Bad messageData for incoming message %@!", buf, 0xCu);
          }

          [*(id *)(a1 + 32) deleteIncomingMessageWithGUID:v21];
        }
        ++v8;
      }
      while (v9 != v8);
    }
    CFRelease(v6);
  }
}

void sub_100321CCC(_Unwind_Exception *a1)
{
  if (v1) {
    objc_end_catch();
  }
  _Unwind_Resume(a1);
}

void sub_100321CE8(uint64_t a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  JUMPOUT(0x100321CF4);
}

void sub_100322090(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,os_activity_scope_state_s state,char a23)
{
}

void sub_1003220CC(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  id v3 = +[NSString stringGUID];
  +[NSDate timeIntervalSinceReferenceDate];
  double v5 = v4;
  uint64_t v24 = 0;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  CFTypeRef v23 = _os_activity_create((void *)&_mh_execute_header, "Finished storing message", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v23, &state);
  CFStringRef v7 = *(const __CFString **)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 56);
  int v8 = *(unsigned __int8 *)(a1 + 84);
  CFStringRef v9 = *(const __CFString **)(a1 + 64);
  int v10 = *(_DWORD *)(a1 + 80);
  int v11 = *(unsigned __int8 *)(a1 + 85);
  uint64_t v12 = *(void *)(a1 + 40);
  id v13 = [*(id *)(a1 + 32) database];
  long long v14 = v13;
  if (v7) {
    CFStringRef v15 = v7;
  }
  else {
    CFStringRef v15 = &stru_10099BE78;
  }
  uint64_t v16 = sub_100347FD4(0, (uint64_t)v3, v12, (uint64_t)v15, v6, (uint64_t)v5, v8 != 0, v9, v10, v11 == 2, &v24, v13);

  if (v16) {
    CFRelease(v16);
  }
  if (*(void *)(a1 + 72))
  {
    unsigned int v17 = im_primary_queue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1003222E0;
    block[3] = &unk_100988EE8;
    id v19 = *(id *)(a1 + 72);
    uint64_t v20 = v24;
    BOOL v21 = v16 != 0;
    dispatch_async(v17, block);
  }
  os_activity_scope_leave(&state);
  cut_arc_os_release();
}

void sub_1003222BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, os_activity_scope_state_s state, char a20)
{
}

void sub_1003222E0(uint64_t a1)
{
  id v1 = *(id *)(a1 + 40);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32));
}

void sub_10032336C(_Unwind_Exception *a1)
{
}

void sub_100323444(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10032345C(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  id v3 = [*(id *)(a1 + 32) database];
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = sub_100041678(v3);
}

void sub_1003235BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1003235D4(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  id v6 = [*(id *)(a1 + 32) database];
  uint64_t v3 = sub_100041904(v6);
  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8);
  double v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;
}

void sub_100323768(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100323780(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = [*(id *)(a1 + 32) database];
  double v5 = (const void *)sub_100041C8C(v3, v4, 0);

  uint64_t v6 = [*(id *)(a1 + 32) _createOutgoingMessageRecordsFromSQLRecords:v5 includeMessagePayloads:0];
  uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8);
  int v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v6;

  if (v5)
  {
    CFRelease(v5);
  }
}

void sub_100323980(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100323998(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 48);
  double v5 = [*(id *)(a1 + 32) database];
  uint64_t v6 = (const void *)sub_100041E7C(v4, v3, v5, 0);

  uint64_t v7 = [*(id *)(a1 + 32) _createOutgoingMessageRecordsFromSQLRecords:v6 includeMessagePayloads:0];
  uint64_t v8 = *(void *)(*(void *)(a1 + 56) + 8);
  CFStringRef v9 = *(void **)(v8 + 40);
  *(void *)(v8 + 40) = v7;

  if (v6)
  {
    CFRelease(v6);
  }
}

void sub_100323B48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100323B60(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  uint64_t v3 = *(void *)(a1 + 48);
  uint64_t v4 = [*(id *)(a1 + 32) database];
  double v5 = (const void *)sub_1000420B0(v3, v4, 0);

  uint64_t v6 = [*(id *)(a1 + 32) _createOutgoingMessageRecordsFromSQLRecords:v5 includeMessagePayloads:0];
  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v6;

  if (v5)
  {
    CFRelease(v5);
  }
}

void sub_100323D0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100323D24(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  uint64_t v3 = *(void *)(a1 + 48);
  id v7 = [*(id *)(a1 + 32) database];
  uint64_t v4 = sub_1000422B8(v3, v7);
  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;
}

void sub_100323F18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100323F30(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  uint64_t v4 = *(void **)(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 48);
  uint64_t v5 = *(void *)(a1 + 64);
  uint64_t v6 = [*(id *)(a1 + 32) database];
  id v7 = (const void *)sub_1000424A0(v4, v3, v5, v6, 0);

  uint64_t v8 = [*(id *)(a1 + 32) _createOutgoingMessageRecordsFromSQLRecords:v7 includeMessagePayloads:0];
  uint64_t v9 = *(void *)(*(void *)(a1 + 56) + 8);
  int v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v8;

  if (v7)
  {
    CFRelease(v7);
  }
}

void sub_100324164(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10032417C(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  uint64_t v4 = *(void **)(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 48);
  uint64_t v5 = *(void *)(a1 + 64);
  uint64_t v6 = *(void *)(a1 + 72);
  id v7 = [*(id *)(a1 + 32) database];
  uint64_t v8 = (const void *)sub_100042708(v4, v5, v3, v6, v7, 0);

  uint64_t v9 = [*(id *)(a1 + 32) _createOutgoingMessageRecordsFromSQLRecords:v8 includeMessagePayloads:0];
  uint64_t v10 = *(void *)(*(void *)(a1 + 56) + 8);
  int v11 = *(void **)(v10 + 40);
  *(void *)(v10 + 40) = v9;

  if (v8)
  {
    CFRelease(v8);
  }
}

void sub_1003243D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1003243E8(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  uint64_t v4 = *(void **)(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 48);
  uint64_t v5 = *(void *)(a1 + 64);
  uint64_t v6 = *(void *)(a1 + 72);
  id v7 = [*(id *)(a1 + 32) database];
  uint64_t v8 = (const void *)sub_1000429F0(v4, v5, v3, v6, v7, *(unsigned char *)(a1 + 96), *(void *)(a1 + 80), *(unsigned char **)(a1 + 88));

  uint64_t v9 = [*(id *)(a1 + 32) _createOutgoingMessageRecordsFromSQLRecords:v8 includeMessagePayloads:*(unsigned __int8 *)(a1 + 96)];
  uint64_t v10 = *(void *)(*(void *)(a1 + 56) + 8);
  int v11 = *(void **)(v10 + 40);
  *(void *)(v10 + 40) = v9;

  if (v8)
  {
    CFRelease(v8);
  }
}

void sub_1003245B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1003245D0(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  uint64_t v3 = *(void *)(a1 + 48);
  char v4 = *(unsigned char *)(a1 + 56);
  id v8 = [*(id *)(a1 + 32) database];
  uint64_t v5 = sub_100041158(1000, v3, v4, v8, 0);
  uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
  id v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = v5;
}

void sub_100324798(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1003247B0(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  uint64_t v3 = *(void *)(a1 + 56);
  char v4 = *(unsigned char *)(a1 + 64);
  id v8 = [*(id *)(a1 + 32) database];
  uint64_t v5 = sub_100041158(1000, v3, v4, v8, *(void **)(a1 + 40));
  uint64_t v6 = *(void *)(*(void *)(a1 + 48) + 8);
  id v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = v5;
}

void sub_100324964(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10032497C(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  id v6 = [*(id *)(a1 + 32) database];
  uint64_t v3 = sub_100041158(1000, 300, 0, v6, *(void **)(a1 + 40));
  uint64_t v4 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;
}

void sub_100324BFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100324C14(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  int v3 = *(unsigned __int8 *)(a1 + 88);
  uint64_t v5 = *(void *)(a1 + 64);
  uint64_t v4 = *(void *)(a1 + 72);
  uint64_t v6 = *(void *)(a1 + 80);
  int v7 = *(unsigned __int8 *)(a1 + 89);
  uint64_t v9 = *(void *)(a1 + 40);
  uint64_t v8 = *(void *)(a1 + 48);
  uint64_t v10 = [*(id *)(a1 + 32) database];
  if (v5) {
    uint64_t v11 = sub_100042D54(v4, v5, v6, v9, v7 != 0, v8, v10, v3 != 0);
  }
  else {
    uint64_t v11 = sub_10004383C(v4, v6, v9, v7 != 0, v8, v10, v3 != 0);
  }
  uint64_t v12 = (const void *)v11;

  uint64_t v13 = [*(id *)(a1 + 32) _createOutgoingMessageRecordsFromSQLRecords:v12 includeMessagePayloads:v3 != 0];
  uint64_t v14 = *(void *)(*(void *)(a1 + 56) + 8);
  CFStringRef v15 = *(void **)(v14 + 40);
  *(void *)(v14 + 40) = v13;

  if (v12)
  {
    CFRelease(v12);
  }
}

void sub_100324EE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100324F00(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  uint64_t v4 = *(void *)(a1 + 72);
  uint64_t v3 = *(void *)(a1 + 80);
  uint64_t v5 = *(void *)(a1 + 88);
  int v6 = *(unsigned __int8 *)(a1 + 96);
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v7 = *(void *)(a1 + 48);
  uint64_t v9 = [*(id *)(a1 + 32) database];
  if (v4) {
    uint64_t v10 = sub_10004322C(v3, v4, v5, v8, v6 != 0, v7, v9, 1, *(void **)(a1 + 56));
  }
  else {
    uint64_t v10 = sub_100043BB8(v3, v5, v8, v6 != 0, v7, v9, 1, *(void **)(a1 + 56));
  }
  uint64_t v11 = (const void *)v10;

  uint64_t v12 = [*(id *)(a1 + 32) _createOutgoingMessageRecordsFromSQLRecords:v11 includeMessagePayloads:1];
  uint64_t v13 = *(void *)(*(void *)(a1 + 64) + 8);
  uint64_t v14 = *(void **)(v13 + 40);
  *(void *)(v13 + 40) = v12;

  if (v11)
  {
    CFRelease(v11);
  }
}

void sub_10032519C(uint64_t a1)
{
  id v2 = (id *)(a1 + 32);
  uint64_t v3 = [*(id *)(a1 + 32) database];
  [v3 ensureDatabaseIsInitialized];

  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 56);
  int v6 = [*v2 database];
  uint64_t v7 = (void *)sub_1000414A4(v4, v5, v6);

  if (v7)
  {
    long long v16 = 0u;
    long long v17 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    id v8 = v7;
    uint64_t v9 = (char *)[v8 countByEnumeratingWithState:&v14 objects:v18 count:16];
    if (v9)
    {
      uint64_t v10 = *(void *)v15;
      do
      {
        for (i = 0; i != v9; ++i)
        {
          if (*(void *)v15 != v10) {
            objc_enumerationMutation(v8);
          }
          uint64_t v13 = JWDecodeArray();
          if ([v13 count]) {
            [*(id *)(a1 + 48) addObjectsFromArray:v13];
          }
        }
        uint64_t v9 = (char *)[v8 countByEnumeratingWithState:&v14 objects:v18 count:16];
      }
      while (v9);
    }
  }
}

void sub_1003253C8(_Unwind_Exception *a1)
{
}

void sub_1003254A0(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  uint64_t v3 = +[IDSFoundationLog IDSMessageStore];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v5 = *(void *)(a1 + 48);
    int v9 = 138412546;
    uint64_t v10 = v4;
    __int16 v11 = 2112;
    uint64_t v12 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Performing MarkingLocalDestiations with accounts %@ and device %@", (uint8_t *)&v9, 0x16u);
  }

  uint64_t v7 = *(void **)(a1 + 40);
  int v6 = *(void **)(a1 + 48);
  id v8 = [*(id *)(a1 + 32) database];
  sub_100044208(v7, v6, v8);
}

void sub_100325664(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  uint64_t v3 = +[IDSFoundationLog IDSMessageStore];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *(void *)(a1 + 40);
    int v8 = 138412290;
    uint64_t v9 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Marking all pending delete messages for account %@", (uint8_t *)&v8, 0xCu);
  }

  int v6 = *(void **)(a1 + 40);
  uint64_t v5 = *(void **)(a1 + 48);
  uint64_t v7 = [*(id *)(a1 + 32) database];
  sub_10004438C(v6, v5, v7);
}

void sub_10032584C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100325864(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  uint64_t v3 = *(void *)(a1 + 48);
  uint64_t v4 = [*(id *)(a1 + 32) database];
  uint64_t v5 = (const void *)sub_100044510(v3, v4, 0);

  uint64_t v6 = [*(id *)(a1 + 32) _createOutgoingMessageRecordsFromSQLRecords:v5 includeMessagePayloads:0];
  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
  int v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v6;

  if (v5)
  {
    CFRelease(v5);
  }
}

void sub_100325A48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100325A60(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  uint64_t v3 = *(void *)(a1 + 56);
  uint64_t v4 = *(void *)(a1 + 64);
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v6 = [*(id *)(a1 + 32) database];
  uint64_t v7 = (const void *)sub_100044700(v3, v5, v4, v6, 0);

  uint64_t v8 = [*(id *)(a1 + 32) _createOutgoingMessageRecordsFromSQLRecords:v7 includeMessagePayloads:0];
  uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v8;

  if (v7)
  {
    CFRelease(v7);
  }
}

void sub_100325C1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100325C34(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  id v6 = [*(id *)(a1 + 32) database];
  uint64_t v3 = sub_100041A4C(v6);
  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;
}

void sub_100325D50(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  uint64_t v3 = *(void *)(a1 + 40);
  id v4 = [*(id *)(a1 + 32) database];
  sub_100045360(v3, v4);
}

void sub_100325E30(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  LODWORD(v2) = *(_DWORD *)(a1 + 40);
  id v3 = [*(id *)(a1 + 32) database];
  sub_10004491C((int)v2, v3);
}

void sub_100325F50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100325F68(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  id v3 = [*(id *)(a1 + 32) database];
  *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = sub_1000449A0(v3);
}

void sub_10032604C(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  id v3 = [*(id *)(a1 + 32) database];
  sub_100044AAC(v3);
}

void sub_100326748(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a2 == 1)
  {
    id v9 = objc_begin_catch(exception_object);
    uint64_t v10 = +[IDSFoundationLog IDSMessageStore];
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      sub_10071EE74();
    }

    objc_end_catch();
    JUMPOUT(0x100326570);
  }
  _Unwind_Resume(exception_object);
}

void sub_100326800(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  if (*(unsigned char *)(a1 + 128))
  {
    if (*(unsigned char *)(a1 + 129))
    {
      char v3 = 1;
    }
    else
    {
      [*(id *)(a1 + 40) accountUUID];
      [*(id *)(a1 + 40) priority];
      id v4 = [*(id *)(a1 + 32) database];
      int v5 = sub_100041150();

      id v6 = +[IDSFoundationLog IDSMessageStore];
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v7 = @"NO";
        uint64_t v8 = *(void *)(a1 + 48);
        if (v5) {
          CFStringRef v7 = @"YES";
        }
        *(_DWORD *)buf = 138412546;
        uint64_t v109 = v8;
        __int16 v110 = 2112;
        CFStringRef v111 = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Asked to send Message with guid: %@  database check for similiar messages that should be sent first says %@", buf, 0x16u);
      }

      char v3 = v5 ^ 1;
    }
  }
  else
  {
    char v3 = 0;
  }
  if ([*(id *)(a1 + 40) daemonDeathResend]
    && (CFStringRef v9 = *(const __CFString **)(a1 + 48),
        id v10 = [*(id *)(a1 + 40) alternateCallbackID],
        [*(id *)(a1 + 32) database],
        __int16 v11 = objc_claimAutoreleasedReturnValue(),
        LODWORD(v9) = sub_100040FCC(v9, (uint64_t)v10, v11),
        v11,
        v9))
  {
    uint64_t v12 = +[IDSFoundationLog IDSMessageStore];
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = *(void *)(a1 + 48);
      long long v14 = [*(id *)(a1 + 40) alternateCallbackID];
      *(_DWORD *)buf = 138412546;
      uint64_t v109 = v13;
      __int16 v110 = 2112;
      CFStringRef v111 = v14;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "We already have message with guid %@ alternate %@ in the database, dropping this redundant resend without calling completion.", buf, 0x16u);
    }
  }
  else
  {
    long long v15 = [*(id *)(a1 + 40) queueOneIdentifier];

    if (v15)
    {
      id v16 = [*(id *)(a1 + 40) queueOneIdentifier];
      long long v17 = [*(id *)(a1 + 32) database];
      sub_1000451EC((uint64_t)v16, v17);
    }
    id v18 = *(id *)(a1 + 48);
    char v102 = v3;
    if ([v18 length])
    {
      uint64_t v100 = (uint64_t)v18;
    }
    else
    {
      uint64_t v19 = +[NSString stringGUID];

      uint64_t v100 = v19;
    }
    +[NSDate timeIntervalSinceReferenceDate];
    uint64_t v99 = (uint64_t)v20;
    v101 = [*(id *)(a1 + 40) expirationDate];
    [v101 timeIntervalSinceReferenceDate];
    uint64_t v98 = (uint64_t)v21;
    +[NSDate timeIntervalSinceReferenceDate];
    uint64_t v89 = (uint64_t)v22;
    CFTypeRef v23 = (char *)[*(id *)(a1 + 56) length];
    uint64_t v24 = &v23[(void)[*(id *)(a1 + 64) length]];
    id v91 = (char *)[*(id *)(a1 + 72) length] + (void)v24;
    unsigned __int8 v84 = [*(id *)(a1 + 40) wantsFirewallDonation];
    id v97 = [*(id *)(a1 + 40) alternateCallbackID];
    id v96 = [*(id *)(a1 + 40) accountUUID];
    id v25 = [*(id *)(a1 + 40) fromID];
    uint64_t v94 = *(void *)(a1 + 56);
    uint64_t v95 = (uint64_t)v25;
    uint64_t v93 = *(void *)(a1 + 64);
    uint64_t v92 = *(void *)(a1 + 72);
    uint64_t v88 = *(void *)(a1 + 80);
    id v87 = [*(id *)(a1 + 40) dataToEncrypt];
    unsigned __int8 v86 = [*(id *)(a1 + 40) encryptPayload];
    unsigned __int8 v85 = [*(id *)(a1 + 40) compressPayload];
    unsigned __int8 v83 = [*(id *)(a1 + 40) useDictAsTopLevel];
    unsigned __int8 v82 = [*(id *)(a1 + 40) wantsResponse];
    v90 = [*(id *)(a1 + 40) command];
    id v81 = [v90 integerValue];
    unsigned __int8 v80 = [*(id *)(a1 + 40) wantsDeliveryStatus];
    uint64_t v79 = *(void *)(a1 + 88);
    id v78 = [*(id *)(a1 + 40) messageUUID];
    id v77 = [*(id *)(a1 + 40) priority];
    id v76 = [*(id *)(a1 + 40) identifier];
    unsigned __int8 v75 = [*(id *)(a1 + 40) localDelivery];
    id v74 = [*(id *)(a1 + 40) peerResponseIdentifier];
    unsigned __int8 v73 = [*(id *)(a1 + 40) expectsPeerResponse];
    unsigned __int8 v72 = [*(id *)(a1 + 40) wantsAppAck];
    unsigned __int8 v70 = [*(id *)(a1 + 40) nonWaking];
    unsigned __int8 v69 = [*(id *)(a1 + 40) nonCloudWaking];
    unsigned __int8 v68 = [*(id *)(a1 + 40) fireAndForget];
    uint64_t v67 = *(void *)(a1 + 96);
    unsigned __int8 v65 = [*(id *)(a1 + 40) bypassDuet];
    id v64 = [*(id *)(a1 + 40) queueOneIdentifier];
    unsigned __int8 v63 = [*(id *)(a1 + 40) enforceRemoteTimeouts];
    id v62 = [*(id *)(a1 + 40) mainAccountUUID];
    id v61 = [*(id *)(a1 + 40) localDestinationDeviceUUID];
    unsigned __int8 v71 = [*(id *)(a1 + 40) messageType];
    id v59 = [v71 integerValue];
    unsigned __int8 v58 = [*(id *)(a1 + 40) alwaysSkipSelf];
    unsigned __int8 v56 = [*(id *)(a1 + 40) alwaysIncludeSelf];
    CFStringRef v66 = [*(id *)(a1 + 40) pushPriority];
    id v55 = [v66 longValue];
    unsigned __int8 v54 = [*(id *)(a1 + 40) liveMessageDelivery];
    unsigned __int8 v53 = [*(id *)(a1 + 40) requireBluetooth];
    unsigned __int8 v52 = [*(id *)(a1 + 40) requireLocalWiFi];
    unsigned __int8 v51 = [*(id *)(a1 + 40) wantsProgress];
    unsigned __int8 v50 = [*(id *)(a1 + 40) ignoreMaxRetryCount];
    unsigned __int8 v26 = [*(id *)(a1 + 40) wantsCertifiedDelivery];
    long long v60 = [*(id *)(a1 + 40) originalTimestamp];
    id v27 = [v60 integerValue];
    uint64_t v28 = *(void *)(a1 + 104);
    long long v57 = [*(id *)(a1 + 40) sendMode];
    id v29 = [v57 integerValue];
    id v30 = [*(id *)(a1 + 40) deliveryMinimumTimeDelay];
    id v31 = [v30 integerValue];
    id v32 = [*(id *)(a1 + 40) deliveryMinimumTime];
    id v33 = [v32 integerValue];
    uint64_t v34 = [*(id *)(a1 + 32) database];
    LOBYTE(v49) = v84;
    uint64_t v48 = (uint64_t)v27;
    BYTE5(v47) = v26;
    BYTE4(v47) = v50;
    BYTE3(v47) = v51;
    BYTE2(v47) = v52;
    BYTE1(v47) = v53;
    LOBYTE(v47) = v54;
    BYTE1(v46) = v56;
    LOBYTE(v46) = v58;
    LOBYTE(v44) = v63;
    LOBYTE(v45) = 0;
    LOBYTE(v43) = v65;
    BYTE4(v42) = v68;
    BYTE3(v42) = v69;
    BYTE2(v42) = v70;
    BYTE1(v42) = v72;
    LOBYTE(v42) = v73;
    LOBYTE(v41) = v75;
    LOBYTE(v40) = v102;
    LOBYTE(v39) = v80;
    BYTE3(v38) = v82;
    BYTE2(v38) = v83;
    BYTE1(v38) = v85;
    LOBYTE(v38) = v86;
    uint64_t v12 = v100;
    long long v35 = sub_1000407D4(0, v100, (uint64_t)v97, (uint64_t)v96, v95, v94, v93, v92, v88, (uint64_t)v87, v38, v98, (uint64_t)v81, v39, v79, (uint64_t)v78, (uint64_t)v77, v99, v40,
            (uint64_t)v76,
            v41,
            (uint64_t)v74,
            v42,
            (uint64_t)v91,
            v67,
            v43,
            (uint64_t)v64,
            v44,
            (uint64_t)v62,
            v45,
            (uint64_t)v61,
            v89,
            (uint64_t)v59,
            v46,
            (uint64_t)v55,
            v47,
            v48,
            v28,
            v49,
            (uint64_t)v29,
            (uint64_t)v31,
            (uint64_t)v33,
            v34);

    if (v35) {
      CFRelease(v35);
    }
    long long v36 = *(void **)(a1 + 120);
    if (v36)
    {
      long long v37 = *(NSObject **)(a1 + 112);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100326FCC;
      block[3] = &unk_1009890C8;
      id v105 = v36;
      id v104 = *(id *)(a1 + 48);
      BOOL v106 = v35 != 0;
      char v107 = v102;
      dispatch_async(v37, block);
    }
  }
}

uint64_t sub_100326FCC(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 48), *(unsigned __int8 *)(a1 + 49));
}

void sub_100327098(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  LOBYTE(v2) = *(unsigned char *)(a1 + 48);
  uint64_t v3 = *(void *)(a1 + 40);
  id v4 = [*(id *)(a1 + 32) database];
  sub_100044044(v3, (char)v2, v4);
}

void sub_100327184(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  id v3 = [*(id *)(a1 + 32) database];
  sub_10004410C(v3);
}

void sub_100327280(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  id v3 = [*(id *)(a1 + 32) database];
  sub_10004412C(v3, *(void **)(a1 + 40));
}

void sub_1003273AC(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = [*(id *)(a1 + 40) database];
  sub_100044BC8(v2, v3, *(void **)(a1 + 48));
}

void sub_10032758C(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  CFStringRef v4 = *(const __CFString **)(a1 + 40);
  id v3 = *(const void **)(a1 + 48);
  int v5 = [*(id *)(a1 + 32) database];
  sub_100044D68(v4, v3, v5, *(void **)(a1 + 56));

  uint64_t v6 = CSDBGetMobileUserDirectory();
  if (v6)
  {
    CFStringRef v7 = +[NSString stringWithUTF8String:v6];
  }
  else
  {
    CFStringRef v7 = @"~";
  }
  v11[0] = v7;
  v11[1] = @"/Library/IdentityServices/files/";
  v11[2] = *(void *)(a1 + 40);
  uint64_t v8 = +[NSArray arrayWithObjects:v11 count:3];
  CFStringRef v9 = +[NSString pathWithComponents:v8];

  if (v6) {
  id v10 = +[NSFileManager defaultManager];
  }
  [v10 removeItemAtPath:v9 error:0];
}

void sub_100327780(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  CFStringRef v3 = *(const __CFString **)(a1 + 40);
  id v4 = [*(id *)(a1 + 32) database];
  sub_100349020(v3, v4);
}

void sub_100327874(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  uint64_t v3 = (uint64_t)*(double *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 48);
  id v5 = [*(id *)(a1 + 32) database];
  sub_1003491A0(v3, v4, v5);
}

void sub_1003279E8(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  uint64_t v3 = *(void **)(a1 + 40);
  uint64_t v4 = [*(id *)(a1 + 32) incomingExpiredRestrictedMessages:0 success:*(double *)(a1 + 48)];
  [v3 addObjectsFromArray:v4];

  uint64_t v5 = (uint64_t)*(double *)(a1 + 48);
  id v6 = [*(id *)(a1 + 32) database];
  sub_1003492B8(v5, v6);
}

void sub_100327B3C(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) database];
  [v2 ensureDatabaseIsInitialized];

  CFStringRef v4 = *(const __CFString **)(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 48);
  id v5 = [*(id *)(a1 + 32) database];
  sub_100348520(v4, v3, v5);
}

void sub_100327C54(uint64_t a1)
{
  id v1 = [*(id *)(a1 + 32) database];
  sub_1003E5DD0(v1);
}

id sub_100327E08(uint64_t a1)
{
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  uint64_t v3 = *(void *)(a1 + 32);
  double v4 = *(double *)(v3 + 24) - Current + 600.0;
  if (v4 <= 0.0)
  {
    return _objc_msgSend((id)v3, "__closeDatabase");
  }
  else
  {
    [*(id *)(v3 + 8) lock];
    id v5 = *(NSObject **)(*(void *)(a1 + 32) + 16);
    dispatch_time_t v6 = dispatch_time(0, (uint64_t)(v4 * 1000000000.0));
    dispatch_source_set_timer(v5, v6, 0x7FFFFFFFFFFFFFFFuLL, (uint64_t)(v4 * 1000000000.0) / 10);
    CFStringRef v7 = *(void **)(*(void *)(a1 + 32) + 8);
    return [v7 unlock];
  }
}

id sub_100327F6C(uint64_t a1)
{
  return _objc_msgSend(*(id *)(a1 + 32), "__closeDatabase");
}

id sub_100328090(uint64_t a1)
{
  return [*(id *)(a1 + 32) _setDatabaseCloseTimer];
}

id sub_100328208(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  id v2 = [*(id *)(a1 + 32) database];
  sub_1003E6018(v2);

  return [*(id *)(a1 + 32) _setDatabaseCloseTimer];
}

id sub_100328390(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  id v2 = [*(id *)(a1 + 32) database];
  sub_1003E6018(v2);

  return [*(id *)(a1 + 32) _setDatabaseCloseTimer];
}

void sub_1003284F8(id a1)
{
  id v1 = objc_alloc_init(IDSDMessageStoreMap);
  uint64_t v2 = qword_100A4C768;
  qword_100A4C768 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_100328AE4(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) delegate];
  [v2 receivedStewieEnabledChanged:*(void *)(a1 + 32)];
}

void sub_100328CA0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  CFStringRef v7 = [*(id *)(a1 + 32) queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100328D7C;
  block[3] = &unk_10097E418;
  id v11 = v6;
  id v12 = v5;
  uint64_t v13 = *(void *)(a1 + 32);
  id v8 = v5;
  id v9 = v6;
  dispatch_async(v7, block);
}

void sub_100328D7C(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    id v2 = +[IDSFoundationLog stewieProvisioning];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = *(void **)(a1 + 32);
      *(_DWORD *)buf = 138412290;
      id v32 = v3;
      double v4 = "Fetched session key updates from CT with error { error: %@ }";
      id v5 = v2;
      uint32_t v6 = 12;
LABEL_4:
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v4, buf, v6);
    }
  }
  else
  {
    CFStringRef v7 = [*(id *)(a1 + 40) keys];
    id v8 = [v7 count];

    if (!v8)
    {
      id v2 = +[IDSFoundationLog stewieProvisioning];
      if (!os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_18;
      }
      *(_WORD *)buf = 0;
      double v4 = "Fetched empty session key update from CT - nothing to update";
      id v5 = v2;
      uint32_t v6 = 2;
      goto LABEL_4;
    }
    id v2 = objc_alloc_init((Class)NSMutableArray);
    long long v26 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    uint64_t v24 = a1;
    id obj = [*(id *)(a1 + 40) keys];
    id v9 = [obj countByEnumeratingWithState:&v26 objects:v30 count:16];
    if (v9)
    {
      id v10 = v9;
      uint64_t v11 = *(void *)v27;
      do
      {
        for (i = 0; i != v10; i = (char *)i + 1)
        {
          uint64_t v13 = v2;
          if (*(void *)v27 != v11) {
            objc_enumerationMutation(obj);
          }
          long long v14 = *(void **)(*((void *)&v26 + 1) + 8 * i);
          long long v15 = [IDSCTTransportKey alloc];
          id v16 = [v14 key];
          long long v17 = objc_msgSend(v14, "key_epki");
          id v18 = [v14 index];
          uint64_t v19 = objc_msgSend(v14, "retiredKey_epki");
          double v20 = -[IDSCTTransportKey initWithKey:epki:forIdx:repki:lastResort:](v15, "initWithKey:epki:forIdx:repki:lastResort:", v16, v17, v18, v19, objc_msgSend(v14, "last_resort"));

          id v2 = v13;
          [v13 addObject:v20];
        }
        id v10 = [obj countByEnumeratingWithState:&v26 objects:v30 count:16];
      }
      while (v10);
    }

    double v21 = +[IDSFoundationLog stewieProvisioning];
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      id v22 = [v2 count];
      *(_DWORD *)buf = 134217984;
      id v32 = v22;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Fetched session key updates from CT - forwarding %ld keys to key manager", buf, 0xCu);
    }

    CFTypeRef v23 = [*(id *)(v24 + 48) delegate];
    [v23 stewieCTClient:*(void *)(v24 + 48) receivedSessionKeyUpdate:v2];
  }
LABEL_18:
}

void sub_10032979C(id a1, NSError *a2)
{
  id v2 = a2;
  uint64_t v3 = +[IDSFoundationLog stewieProvisioning];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    id v5 = v2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "setStewieBlocked finished { error: %@ }", (uint8_t *)&v4, 0xCu);
  }
}

void sub_100329968(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = a3;
  (*(void (**)(uint64_t, id, id))(v4 + 16))(v4, [a2 hwSupport], v5);
}

void sub_10032EF1C(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {

    objc_end_catch();
    JUMPOUT(0x10032EE48);
  }
  _Unwind_Resume(a1);
}

void sub_1003309D4(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1003306A4);
  }
  _Unwind_Resume(a1);
}

void sub_1003319E8(void *a1, uint64_t a2, uint64_t a3)
{
  id v4 = a1;
  id v5 = v4;
  if (v4 && a3)
  {
    id v6 = v4;
    IMLogRegisterStateToSysdiagnoseBlock();
  }
}

id sub_100331A94(uint64_t a1)
{
  if (+[IDSUserManagement isThreadDataSeparated])
  {
    id v2 = +[IMIDSLog daemon];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "IMLogRegisterStateToSysdiagnoseBlock invoked in a data separated context -- dropping", v5, 2u);
    }

    uint64_t v3 = 0;
  }
  else
  {
    uint64_t v3 = (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }

  return v3;
}

void sub_100331F08(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2555908];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setService:*(void *)(a1 + 40)];
    [v2 setIsToDefaultPairedDevice:*(unsigned __int8 *)(a1 + 72)];
    [v2 setMessageSize:*(void *)(a1 + 48)];
    [v2 setLinkType:*(void *)(a1 + 56)];
    [v2 setPriority:*(void *)(a1 + 64)];
    [*(id *)(a1 + 32) _submitAWDMetric:v2 withContainer:v3];
  }
}

void sub_100332090(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2588673];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setService:*(void *)(a1 + 40)];
    [v2 setPayloadSize:*(void *)(a1 + 48)];
    [v2 setDeltaTime:*(void *)(a1 + 56)];
    [v2 setPriority:*(void *)(a1 + 64)];
    [*(id *)(a1 + 32) _submitAWDMetric:v2 withContainer:v3];
  }
}

void sub_100332288(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2555909];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setService:*(void *)(a1 + 40)];
    [v2 setIsToDefaultPairedDevice:*(unsigned __int8 *)(a1 + 88)];
    [v2 setMessageSize:*(void *)(a1 + 48)];
    [v2 setLinkType:*(void *)(a1 + 56)];
    [v2 setDeliveryError:*(void *)(a1 + 64)];
    [v2 setRTT:*(void *)(a1 + 72)];
    [v2 setPriority:*(void *)(a1 + 80)];
    [*(id *)(a1 + 32) _submitAWDMetric:v2 withContainer:v3];
  }
}

void sub_100332478(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2555910];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setService:*(void *)(a1 + 40)];
    [v2 setIsFromDefaultPairedDevice:*(unsigned __int8 *)(a1 + 72)];
    [v2 setMessageSize:*(void *)(a1 + 48)];
    [v2 setLinkType:*(void *)(a1 + 56)];
    [v2 setPriority:*(void *)(a1 + 64)];
    [*(id *)(a1 + 32) _submitAWDMetric:v2 withContainer:v3];
  }
}

void sub_100332600(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2555911];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setService:*(void *)(a1 + 40)];
    [v2 setIsToDefaultPairedDevice:*(unsigned __int8 *)(a1 + 64)];
    [v2 setOpenError:*(void *)(a1 + 48)];
    [v2 setSocketError:*(void *)(a1 + 56)];
    [*(id *)(a1 + 32) _submitAWDMetric:v2 withContainer:v3];
  }
}

void sub_100332810(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2555912];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setService:*(void *)(a1 + 40)];
    [v2 setIsToDefaultPairedDevice:*(unsigned __int8 *)(a1 + 96)];
    [v2 setCloseError:*(void *)(a1 + 48)];
    [v2 setSocketError:*(void *)(a1 + 56)];
    [v2 setBytesSent:*(void *)(a1 + 64)];
    [v2 setPacketsSent:*(void *)(a1 + 72)];
    [v2 setBytesReceived:*(void *)(a1 + 80)];
    [v2 setPacketsReceived:*(void *)(a1 + 88)];
    [*(id *)(a1 + 32) _submitAWDMetric:v2 withContainer:v3];
  }
}

void sub_1003329BC(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) _metricContainerForMetricType:2588677];
  if (v2)
  {
    id v4 = v2;
    id v3 = objc_alloc_init((Class)IMWeakLinkClass());
    [v3 setType:*(void *)(a1 + 48)];
    [v3 setDuration:*(void *)(a1 + 56)];
    [v3 setResult:*(void *)(a1 + 64)];
    if (*(void *)(a1 + 40)) {
      objc_msgSend(v3, "setClient:");
    }
    [*(id *)(a1 + 32) _submitAWDMetric:v3 withContainer:v4];

    id v2 = v4;
  }
}

void sub_100332B3C(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2588678];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setService:*(void *)(a1 + 40)];
    [v2 setPriority:*(void *)(a1 + 48)];
    [v2 setDuration:*(void *)(a1 + 56)];
    [v2 setResult:*(unsigned int *)(a1 + 64)];
    [*(id *)(a1 + 32) _submitAWDMetric:v2 withContainer:v3];
  }
}

void sub_100332C78(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2588680];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setRecommendedLinkType:*(unsigned int *)(a1 + 40)];
    [v2 setPrimaryLinkType:*(unsigned int *)(a1 + 44)];
    [v2 setMagnetState:*(unsigned int *)(a1 + 48)];
    [v2 setInfraWiFiState:*(unsigned int *)(a1 + 52)];
    [*(id *)(a1 + 32) _submitAWDMetric:v2 withContainer:v3];
  }
}

void sub_100332E24(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2555914];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setDuration:*(void *)(a1 + 56)];
    [v2 setResult:*(unsigned int *)(a1 + 64)];
    [v2 setHasRecipientAccepted:*(unsigned int *)(a1 + 68)];
    [v2 setPayloadSize:*(unsigned int *)(a1 + 72)];
    [v2 setTopic:*(void *)(a1 + 40)];
    [v2 setService:*(void *)(a1 + 48)];
    [*(id *)(a1 + 32) _submitAWDMetric:v2 withContainer:v3];
  }
}

void sub_100332FA8(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2588681];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setDuration:*(void *)(a1 + 40)];
    [v2 setResultCode:*(void *)(a1 + 48)];
    [*(id *)(a1 + 32) _submitAWDMetric:v2 withContainer:v3];
  }
}

void sub_1003330FC(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2588682];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setDuration:*(void *)(a1 + 40)];
    [v2 setResultCode:*(void *)(a1 + 48)];
    [*(id *)(a1 + 32) _submitAWDMetric:v2 withContainer:v3];
  }
}

void sub_100333234(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2588685];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setResultCode:*(void *)(a1 + 40)];
    [*(id *)(a1 + 32) _submitAWDMetric:v2 withContainer:v3];
  }
}

void sub_1003333B4(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) _metricContainerForMetricType:2555933];
  if (v2)
  {
    id v5 = v2;
    id v3 = objc_alloc_init((Class)IMWeakLinkClass());
    objc_msgSend(v3, "setTimestamp:", (unint64_t)(ceil((double)(unint64_t)objc_msgSend(*(id *)(*(void *)(a1 + 32)+ OBJC_IVAR___IDSAWDLogging__AWDServerConnection), "getAWDTimestamp")/ 15.0)* 15.0));
    [v3 setFromStorage:*(unsigned __int8 *)(a1 + 72)];
    [v3 setServertimestamp:(unint64_t)(ceil(*(double *)(a1 + 56) / 15.0) * 15.0)];
    [v3 setLocaltimedelta:(unint64_t)(ceil(*(double *)(a1 + 64) / 15.0) * 15.0)];
    if (*(void *)(a1 + 40)) {
      objc_msgSend(v3, "setServiceIdentifier:");
    }
    id v4 = *(void **)(a1 + 48);
    if (v4) {
      objc_msgSend(v3, "setAccountType:", objc_msgSend(v4, "unsignedIntegerValue"));
    }
    [*(id *)(a1 + 32) _submitAWDMetric:v3 withContainer:v5];

    id v2 = v5;
  }
}

void sub_100333570(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2555930];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setCorrectFramesSinceLastCorruption:*(void *)(a1 + 40)];
    [v2 setCorrectRawBytesSinceLastCorruption:*(void *)(a1 + 48)];
    [v2 setDiscardedRawBytes:*(void *)(a1 + 56)];
    [v2 setRecoveryTimeInMs:*(void *)(a1 + 64)];
    [v2 setLinkType:*(void *)(a1 + 72)];
    [*(id *)(a1 + 32) _submitAWDMetric:v2 withContainer:v3];
  }
}

void sub_10033370C(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2588688];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setServiceIdentifier:*(void *)(a1 + 40)];
    [v2 setLinkType:*(void *)(a1 + 48)];
    [v2 setWasPrimary:*(unsigned __int8 *)(a1 + 72)];
    [v2 setTimeTaken:(unint64_t)*(double *)(a1 + 56)];
    [v2 setTotalMessages:(uint64_t)((double)(*(void *)(a1 + 64) / 5) * 5.0)];
    [*(id *)(a1 + 32) _submitAWDMetric:v2 withContainer:v3];
  }
}

void sub_100333AEC(id a1)
{
  id v1 = objc_alloc_init(IDSDSessionActiveParticipantsCache);
  uint64_t v2 = qword_100A4C780;
  qword_100A4C780 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

id sub_100333D3C(id a1, id a2)
{
  id v2 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v3 = 0;
  }
  else {
    id v3 = v2;
  }

  return v3;
}

void sub_100334104(id a1, IDSLocalDeliveryMessage *a2, unint64_t a3, BOOL *a4)
{
}

BOOL sub_1003341A8(uint64_t a1, void *a2)
{
  return [a2 dataProtectionClass] == *(_DWORD *)(a1 + 32);
}

BOOL sub_10033426C(uint64_t a1, void *a2)
{
  return [a2 messageType] == *(id *)(a1 + 32);
}

void sub_100334CB0()
{
}

void sub_100334CD8(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  id v10 = a2;
  if (([v10 deniedToSend] & 1) == 0)
  {
    CFStringRef v7 = *(void **)(a1 + 32);
    if (!v7
      || ([v10 topic],
          id v8 = objc_claimAutoreleasedReturnValue(),
          unsigned __int8 v9 = [v7 containsObject:v8],
          v8,
          (v9 & 1) == 0))
    {
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = a3;
      *a4 = 1;
    }
  }
}

id sub_1003366DC(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) networkCheckOverrideBehavior];
  qword_100A4C788 = (uint64_t)result;
  return result;
}

id sub_100336700(uint64_t a1, uint64_t a2)
{
  (*(void (**)(void, BOOL))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), a2 != 0);
  id v3 = *(void **)(a1 + 32);

  return [v3 setAvailability:0];
}

void sub_1003369AC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  CFStringRef v7 = v6;
  if (!v5 || v6)
  {
    id v12 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v13 = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Failed creating local data, bailing...", v13, 2u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    id v8 = +[IDSUTunController sharedInstance];
    unsigned __int8 v9 = [*(id *)(a1 + 32) uniqueID];
    id v10 = [*(id *)(a1 + 32) invitationManager];
    uint64_t v11 = [v10 remoteBlob];
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 3221225472;
    v14[2] = sub_100336BBC;
    v14[3] = &unk_100989408;
    id v16 = *(id *)(a1 + 40);
    id v15 = v5;
    [v8 processRemoteConnectionDataForDevice:v9 remoteConnectionData:v11 completionHandler:v14];
  }
}

void sub_100336BBC(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    id v6 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Finished connectivity check with error %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      _IDSLogTransport();
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40));
}

void sub_100337E60(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) inviteTimer];
  [v2 invalidate];

  [*(id *)(a1 + 32) setInviteTimer:0];
  id v3 = +[IDSFoundationLog IDSDSession];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    [*(id *)(a1 + 32) inviteTimeout];
    int v11 = 134217984;
    uint64_t v12 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Setting invite timeout to %f seconds", (uint8_t *)&v11, 0xCu);
  }

  id v5 = objc_alloc((Class)IMTimer);
  [*(id *)(a1 + 32) inviteTimeout];
  double v7 = v6;
  uint64_t v8 = *(void *)(a1 + 32);
  unsigned __int8 v9 = im_primary_queue();
  id v10 = [v5 initWithTimeInterval:@"SessionInviteTimeout" name:1 shouldWake:v8 target:"_inviteTimedOut" selector:0 userInfo:v9 queue:v7];
  [*(id *)(a1 + 32) setInviteTimer:v10];
}

id sub_10033804C(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _inviteTimedOut];
}

void sub_1003381F4(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) inviteTimer];

  if (v2)
  {
    id v3 = +[IDSFoundationLog IDSDSession];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Clearing invitation timeout timer", v5, 2u);
    }

    uint64_t v4 = [*(id *)(a1 + 32) inviteTimer];
    [v4 invalidate];

    [*(id *)(a1 + 32) setInviteTimer:0];
  }
}

void sub_100338338(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) connectionTimer];

  if (v2)
  {
    id v3 = +[IDSFoundationLog IDSDSession];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Clearing connection timeout timer", v5, 2u);
    }

    uint64_t v4 = [*(id *)(a1 + 32) connectionTimer];
    [v4 invalidate];

    [*(id *)(a1 + 32) setConnectionTimer:0];
  }
}

void sub_10033847C(uint64_t a1)
{
  id v2 = +[IDSFoundationLog IDSDSession];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    [*(id *)(a1 + 32) connectionTimeout];
    *(_DWORD *)buf = 134217984;
    uint64_t v17 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Setting connection timeout to %f seconds", buf, 0xCu);
  }

  uint64_t v4 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    [*(id *)(a1 + 32) connectionTimeout];
    *(_DWORD *)buf = 134217984;
    uint64_t v17 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Setting connection timeout to %f seconds", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      [*(id *)(a1 + 32) connectionTimeout];
      uint64_t v15 = v6;
      _IDSLogTransport();
      if (_IDSShouldLog())
      {
        objc_msgSend(*(id *)(a1 + 32), "connectionTimeout", v15);
        _IDSLogV();
      }
    }
  }
  id v7 = objc_alloc((Class)IMTimer);
  unsigned __int8 v9 = *(void **)(a1 + 32);
  uint64_t v8 = (id *)(a1 + 32);
  [v9 connectionTimeout];
  double v11 = v10;
  id v12 = *v8;
  uint64_t v13 = im_primary_queue();
  id v14 = [v7 initWithTimeInterval:@"SessionConnectionTimeout" name:1 shouldWake:v12 target:"_connectionTimedOut" selector:0 userInfo:v13 queue:v11];
  [*v8 setConnectionTimer:v14];
}

id sub_10033872C(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _connectionTimedOut];
}

void sub_100338898(uint64_t a1)
{
  id v1 = [*(id *)(a1 + 32) packetLossTimer];

  if (v1)
  {
    id v2 = +[IDSFoundationLog IDSDSession];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v3 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Clearing session packet loss timer", v3, 2u);
    }
  }
}

void sub_1003389B4(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) endSessionTimer];

  if (v2)
  {
    uint64_t v3 = +[IDSFoundationLog IDSDSession];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Clearing end session timeout timer", v5, 2u);
    }

    uint64_t v4 = [*(id *)(a1 + 32) endSessionTimer];
    [v4 invalidate];

    [*(id *)(a1 + 32) setEndSessionTimer:0];
  }
}

void sub_100338AF4(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) endSessionTimer];
  [v2 invalidate];

  [*(id *)(a1 + 32) setEndSessionTimer:0];
  uint64_t v3 = +[IDSFoundationLog IDSDSession];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    [*(id *)(a1 + 32) endSessionTimeout];
    int v10 = 134217984;
    uint64_t v11 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Setting end session timeout to %f seconds", (uint8_t *)&v10, 0xCu);
  }

  id v5 = objc_alloc((Class)IMTimer);
  uint64_t v6 = *(void *)(a1 + 32);
  double v7 = *(double *)(v6 + 120);
  uint64_t v8 = im_primary_queue();
  id v9 = [v5 initWithTimeInterval:@"EndSessionTimeout" name:1 shouldWake:v6 target:"_endSessionTimedOut" selector:0 userInfo:v8 queue:v7];
  [*(id *)(a1 + 32) setEndSessionTimer:v9];
}

id sub_100338CD8(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _endSessionTimedOut];
}

BOOL sub_100339ED4(uint64_t a1, void *a2)
{
  return [a2 subsystem] != *(id *)(a1 + 32);
}

void sub_10033AC78(uint64_t a1, char a2)
{
  if (a2)
  {
    uint64_t v3 = +[IMRGLog warning];
    if (os_log_type_enabled((os_log_t)v3, OS_LOG_TYPE_FAULT)) {
      sub_10071F67C(a1, v3);
    }
    goto LABEL_8;
  }
  uint64_t v4 = +[IMRGLog registration];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = [*(id *)(a1 + 32) message];
    int v8 = 138412290;
    id v9 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "  Successfully signed, sending (de)registration message: %@", (uint8_t *)&v8, 0xCu);
  }
  uint64_t v6 = [*(id *)(a1 + 32) sendBlock];

  if (v6)
  {
    uint64_t v3 = [*(id *)(a1 + 32) sendBlock];
    double v7 = [*(id *)(a1 + 32) message];
    (*(void (**)(uint64_t, void *))(v3 + 16))(v3, v7);

LABEL_8:
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

id sub_10033ADC8(uint64_t a1)
{
  return [*(id *)(a1 + 32) setIsBuildingContext:0];
}

void sub_10033B0DC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  [*(id *)(a1 + 32) setValidationSession:v5];
  [*(id *)(a1 + 32) setValidationContextDisabled:1];
  [*(id *)(a1 + 32) setIsBuildingContext:0];
  if (v6)
  {
    double v7 = +[IMRGLog warning];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      sub_10071F70C();
    }

    objc_msgSend(*(id *)(a1 + 40), "__failValidationQueueForSubsystemMechanism:", *(void *)(a1 + 48));
  }
  else
  {
    int v8 = +[IMRGLog registration];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 138412290;
      id v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Successfully initialized validation session for request {validationSession: %@}", (uint8_t *)&v9, 0xCu);
    }

    objc_msgSend(*(id *)(a1 + 40), "__flushValidationQueueForSubsystemMechanism:", *(void *)(a1 + 48));
  }
}

void sub_10033B448(uint64_t a1, void *a2, void *a3, unint64_t a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v61 = a5;
  id v11 = v9;
  id v12 = +[IMRGLog registration];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109378;
    *(_DWORD *)&uint8_t buf[4] = a4;
    LOWORD(v86) = 2112;
    *(void *)((char *)&v86 + 2) = v10;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "  Received cert request response with result: %d   error: %@", buf, 0x12u);
  }

  if (a4 < 2 || a4 == 200)
  {
    uint64_t v13 = [v11 responseCertificateData];
    id v14 = v13;
    if (!v13)
    {
      long long v28 = +[IMRGLog warning];
      if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT)) {
        sub_10071F7E0(v28);
      }

      [*(id *)(a1 + 32) setIsBuildingContext:0];
      id v77 = _NSConcreteStackBlock;
      uint64_t v78 = 3221225472;
      uint64_t v79 = sub_10033BC40;
      unsigned __int8 v80 = &unk_10097EDD8;
      uint64_t v29 = *(void *)(a1 + 48);
      uint64_t v81 = *(void *)(a1 + 40);
      uint64_t v82 = v29;
      im_dispatch_after_primary_queue();
      goto LABEL_46;
    }
    uint64_t v76 = 0;
    unsigned int v75 = 0;
    *(void *)buf = 0;
    *(void *)&long long v86 = buf;
    *((void *)&v86 + 1) = 0x2020000000;
    uint64_t v87 = 0;
    v73[0] = 0;
    v73[1] = v73;
    v73[2] = 0x2020000000;
    char v74 = 0;
    if ([v13 length])
    {
      if ([v14 length])
      {
        uint64_t v15 = +[IMRGLog registration];
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)unsigned __int8 v83 = 138412290;
          unsigned __int8 v84 = v14;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Calling NACInit with: %@", v83, 0xCu);
        }

        id v16 = v14;
        sub_1005846AC((uint64_t)[v16 bytes], (int)objc_msgSend(v16, "length"));
        uint64_t v18 = v17;
        if (v17)
        {
          uint64_t v19 = v86;
          uint64_t v20 = *(void *)(v86 + 24);
          if (v20)
          {
            sub_1005841F0(v20);
            uint64_t v19 = v86;
          }
          *(void *)(v19 + 24) = 0;
          double v21 = +[IMRGLog warning];
          if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT)) {
            sub_10071F94C(v18, v21, v22, v23, v24, v25, v26, v27);
          }

          [*(id *)(a1 + 32) setIsBuildingContext:0];
          objc_msgSend(*(id *)(a1 + 40), "__failValidationQueueForSubsystemMechanism:", *(void *)(a1 + 48));
          if (!v76) {
            goto LABEL_45;
          }
          sub_100584004(v76);
        }
        else
        {
          v66[0] = _NSConcreteStackBlock;
          v66[1] = 3221225472;
          v66[2] = sub_10033BC4C;
          v66[3] = &unk_1009894A0;
          id v67 = v61;
          unsigned __int8 v70 = buf;
          unsigned __int8 v71 = v73;
          id v44 = *(id *)(a1 + 32);
          uint64_t v45 = *(void *)(a1 + 40);
          uint64_t v46 = *(void *)(a1 + 48);
          id v68 = v44;
          uint64_t v69 = v45;
          uint64_t v72 = v46;
          long long v60 = objc_retainBlock(v66);
          uint64_t v47 = objc_alloc_init(IDSInitializeValidationMessage);
          [(IDSInitializeValidationMessage *)v47 setCompletionBlock:v60];
          uint64_t v48 = +[IMRGLog registration];
          if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)unsigned __int8 v83 = 0;
            _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "Sending initialize validation request", v83, 2u);
          }

          uint64_t v49 = +[IMRGLog registration];
          if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
          {
            unsigned __int8 v50 = [*(id *)(a1 + 40) pushHandler];
            unsigned __int8 v51 = [v50 pushToken];
            *(_DWORD *)unsigned __int8 v83 = 138412290;
            unsigned __int8 v84 = v51;
            _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "Push handler returned push token: %@", v83, 0xCu);
          }
          [(IDSInitializeValidationMessage *)v47 setTimeout:36000.0];
          unsigned __int8 v52 = [*(id *)(a1 + 40) pushHandler];
          unsigned __int8 v53 = [v52 pushToken];
          [(IDSInitializeValidationMessage *)v47 setPushToken:v53];

          IDSAssignPushIdentityToMessage();
          unsigned __int8 v54 = +[NSData dataWithBytes:v76 length:v75];
          [(IDSInitializeValidationMessage *)v47 setSessionInfoRequest:v54];
          if (+[IDSValidationSession isSigningSupported])
          {
            id v55 = +[IMRGLog registration];
            if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)unsigned __int8 v83 = 0;
              _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "Initialized validation session", v83, 2u);
            }

            unsigned __int8 v56 = im_primary_queue();
            v62[0] = _NSConcreteStackBlock;
            v62[1] = 3221225472;
            v62[2] = sub_10033C0FC;
            v62[3] = &unk_1009894C8;
            id v63 = *(id *)(a1 + 32);
            long long v57 = v47;
            uint64_t v58 = *(void *)(a1 + 40);
            id v64 = v57;
            uint64_t v65 = v58;
            +[IDSValidationSession validationSessionOnQueue:v56 mechanism:0 withCompletion:v62];

            id v59 = (void (**)(void, void))v63;
          }
          else
          {
            id v59 = [*(id *)(a1 + 40) validationMessageSendBlock];
            ((void (**)(void, IDSInitializeValidationMessage *))v59)[2](v59, v47);
          }
        }
      }
      else
      {
        uint64_t v41 = v86;
        uint64_t v42 = *(void *)(v86 + 24);
        if (v42)
        {
          sub_1005841F0(v42);
          uint64_t v41 = v86;
        }
        *(void *)(v41 + 24) = 0;
        uint64_t v43 = +[IMRGLog warning];
        if (os_log_type_enabled(v43, OS_LOG_TYPE_FAULT)) {
          sub_10071F8E0();
        }

        [*(id *)(a1 + 32) setIsBuildingContext:0];
        objc_msgSend(*(id *)(a1 + 40), "__failValidationQueueForSubsystemMechanism:", *(void *)(a1 + 48));
      }
    }
    else
    {
      long long v37 = +[IMRGLog warning];
      if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT)) {
        sub_10071F874();
      }

      [*(id *)(a1 + 32) setValidationContextDisabled:1];
      [*(id *)(a1 + 32) setValidationContext:0];
      id v38 = objc_alloc_init((Class)NSDate);
      [*(id *)(a1 + 32) setValidateContextDate:v38];

      [*(id *)(a1 + 32) setValidateContextTTL:&off_1009D1D88];
      uint64_t v39 = +[IMRGLog warning];
      if (os_log_type_enabled(v39, OS_LOG_TYPE_FAULT))
      {
        uint64_t v40 = [*(id *)(a1 + 32) validateContextTTL];
        sub_10071F824(v40, (uint64_t)v83, v39);
      }

      [*(id *)(a1 + 32) setIsBuildingContext:0];
      objc_msgSend(*(id *)(a1 + 40), "__flushValidationQueueForSubsystemMechanism:", *(void *)(a1 + 48));
    }
    if (v76) {
      sub_100584004(v76);
    }
LABEL_45:
    _Block_object_dispose(v73, 8);
    _Block_object_dispose(buf, 8);
LABEL_46:

    goto LABEL_47;
  }
  id v30 = +[IMRGLog warning];
  if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT)) {
    sub_10071F774(a4, v30, v31, v32, v33, v34, v35, v36);
  }

  [*(id *)(a1 + 32) setIsBuildingContext:0];
  objc_msgSend(*(id *)(a1 + 40), "__failValidationQueueWithErrorResponseCode:forSubsystemMechanism:", 8001, *(void *)(a1 + 48));
LABEL_47:
}

void sub_10033BBE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Block_object_dispose(&a29, 8);
  _Block_object_dispose((const void *)(v29 - 160), 8);
  _Unwind_Resume(a1);
}

id sub_10033BC40(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _sendAbsintheValidationCertRequestIfNeededForSubsystem:*(void *)(a1 + 40)];
}

void sub_10033BC4C(uint64_t a1, void *a2, void *a3, unint64_t a4)
{
  id v7 = a2;
  int v8 = a3;
  id v9 = v7;
  id v10 = [v9 responseSessionInfo];
  id v11 = +[IMRGLog registration];
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v12 = *(const __CFString **)(a1 + 32);
    *(_DWORD *)buf = 138412546;
    CFStringRef v53 = v12;
    __int16 v54 = 2112;
    CFStringRef v55 = v8;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "  Received validation initialization request response: %@   error: %@", buf, 0x16u);
  }

  if (a4 >= 2 && a4 != 200)
  {
    id v14 = +[IMRGLog warning];
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
      sub_10071F9B8(a4, v14, v15, v16, v17, v18, v19, v20);
    }
    goto LABEL_33;
  }
  if (!*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24)) {
    goto LABEL_40;
  }
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) || ![v10 length])
  {
    [*(id *)(a1 + 40) setValidationContextDisabled:1];
  }
  else
  {
    uint64_t v40 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
    id v41 = v10;
    sub_1005849F4(v40, (uint64_t)[v41 bytes], (int)objc_msgSend(v41, "length"));
    if (v42)
    {
      uint64_t v43 = v42;
      id v14 = +[IMRGLog warning];
      if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
        sub_10071FA90(v43, v14, v44, v45, v46, v47, v48, v49);
      }
LABEL_33:

      uint64_t v50 = *(void *)(*(void *)(a1 + 56) + 8);
      uint64_t v51 = *(void *)(v50 + 24);
      if (v51)
      {
        sub_1005841F0(v51);
        uint64_t v50 = *(void *)(*(void *)(a1 + 56) + 8);
      }
      *(void *)(v50 + 24) = 0;
      objc_msgSend(*(id *)(a1 + 48), "__failValidationQueueForSubsystemMechanism:", *(void *)(a1 + 72));
      goto LABEL_40;
    }
  }
  if ([*(id *)(a1 + 40) validationContextDisabled]) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
  }
  [*(id *)(a1 + 40) setValidationContext:v13];
  id v21 = objc_alloc_init((Class)NSDate);
  [*(id *)(a1 + 40) setValidateContextDate:v21];

  uint64_t v22 = [v9 responseTTL];
  [*(id *)(a1 + 40) setValidateContextTTL:v22];

  uint64_t v23 = +[IMRGLog registration];
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v24 = [*(id *)(a1 + 40) validateContextTTL];
    *(_DWORD *)buf = 138412290;
    CFStringRef v53 = v24;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "  Succeeded establishing session key!  (TTL: %@)", buf, 0xCu);
  }
  uint64_t v25 = [v9 responseAbsintheServKey];
  uint64_t v26 = [v9 responseAbsintheResponse];
  uint64_t v27 = +[IMRGLog registration];
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v28 = v25 == 0;
    uint64_t v29 = v25;
    id v30 = v8;
    if (v28) {
      CFStringRef v31 = @"NO";
    }
    else {
      CFStringRef v31 = @"YES";
    }
    if (v26) {
      CFStringRef v32 = @"YES";
    }
    else {
      CFStringRef v32 = @"NO";
    }
    uint64_t v33 = [*(id *)(a1 + 40) validationSession];
    *(_DWORD *)buf = 138412802;
    CFStringRef v34 = @"YES";
    if (!v33) {
      CFStringRef v34 = @"NO";
    }
    CFStringRef v53 = v31;
    int v8 = v30;
    uint64_t v25 = v29;
    __int16 v54 = 2112;
    CFStringRef v55 = v32;
    __int16 v56 = 2112;
    CFStringRef v57 = v34;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Processing validation response {servKey: %@, response: %@, session: %@}", buf, 0x20u);
  }
  uint64_t v35 = [*(id *)(a1 + 40) validationSession];

  if (v35)
  {
    uint64_t v36 = [*(id *)(a1 + 40) validationSession];
    long long v37 = [v36 activateWithValidationData:v26 serverKey:v25];

    id v38 = +[IMRGLog registration];
    uint64_t v39 = v38;
    if (v37)
    {
      if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT)) {
        sub_10071FA24();
      }
    }
    else if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "Successfully set up validation session", buf, 2u);
    }
  }
  objc_msgSend(*(id *)(a1 + 48), "__flushValidationQueueForSubsystemMechanism:", *(void *)(a1 + 72));

LABEL_40:
  [*(id *)(a1 + 40) setIsBuildingContext:0];
}

void sub_10033C0FC(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  [a1[4] setValidationSession:v5];
  if (v6)
  {
    id v7 = +[IMRGLog warning];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      sub_10071F70C();
    }
  }
  else
  {
    id v7 = +[IMRGLog registration];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = [v5 UDID];
      if (v8) {
        CFStringRef v9 = @"YES";
      }
      else {
        CFStringRef v9 = @"NO";
      }
      id v10 = [v5 helloMessage];
      *(_DWORD *)buf = 138412802;
      if (v10) {
        CFStringRef v11 = @"YES";
      }
      else {
        CFStringRef v11 = @"NO";
      }
      id v32 = v5;
      __int16 v33 = 2112;
      CFStringRef v34 = v9;
      __int16 v35 = 2112;
      CFStringRef v36 = v11;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Successfully initialized validation session and hello message for request {validationSession: %@, UDID: %@, helloMessage: %@}", buf, 0x20u);
    }
  }

  CFStringRef v12 = [v5 UDID];

  if (v12)
  {
    id v13 = a1[5];
    id v14 = [v5 UDID];
    [v13 setAbsintheUDID:v14];
  }
  if (!v6)
  {
    uint64_t v15 = [v5 helloMessage];

    if (v15)
    {
      id v16 = a1[5];
      uint64_t v17 = [v5 helloMessage];
      [v16 setAbsintheHello:v17];
    }
  }
  uint64_t v18 = +[IMRGLog registration];
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    id v19 = a1[5];
    uint64_t v28 = [v19 absintheUDID];
    id v30 = v6;
    CFStringRef v20 = @"NO";
    if (v28) {
      CFStringRef v21 = @"YES";
    }
    else {
      CFStringRef v21 = @"NO";
    }
    uint64_t v22 = objc_msgSend(a1[5], "absintheUDID", v28);
    CFStringRef v23 = (const __CFString *)[v22 length];
    uint64_t v24 = [a1[5] absintheHello];
    if (v24) {
      CFStringRef v20 = @"YES";
    }
    uint64_t v25 = [a1[5] absintheHello];
    id v26 = [v25 length];
    *(_DWORD *)buf = 138413314;
    id v32 = v19;
    __int16 v33 = 2112;
    CFStringRef v34 = v21;
    __int16 v35 = 2048;
    CFStringRef v36 = v23;
    __int16 v37 = 2112;
    CFStringRef v38 = v20;
    id v6 = v30;
    __int16 v39 = 2048;
    id v40 = v26;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Validation session parameters set on request {initializeMessage: %@, UDID: %@, UDID.length: %ld, helloMessage: %@, helloMessage.length: %ld}", buf, 0x34u);
  }
  uint64_t v27 = [a1[6] validationMessageSendBlock];
  ((void (**)(void, id))v27)[2](v27, a1[5]);
}

uint64_t sub_10033CF3C(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  uint64_t result = *(void *)(a1 + 40);
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(void))(result + 16);
    return v3();
  }
  return result;
}

void sub_10033CFF8(id a1)
{
  id v1 = objc_alloc_init(IDSDaemonMIGQueryInterface);
  uint64_t v2 = qword_100A4C7A0;
  qword_100A4C7A0 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

uint64_t sub_10033D340(uint64_t result)
{
  if (!*(unsigned char *)(*(void *)(result + 32) + 24))
  {
    uint64_t v1 = result;
    uint64_t v2 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      uint64_t v3 = *(void *)(v1 + 32);
      *(_DWORD *)buf = 138412290;
      uint64_t v5 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "IDSDaemonMIGQueryInterface auth port died: %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      MarcoLogMadridLevel();
      IMLogString();
      _IMWarn();
    }
    exit(-1);
  }
  return result;
}

void sub_10033D494(id a1, OS_xpc_object *a2, OS_xpc_object *a3)
{
  uint64_t v4 = a2;
  uint64_t v5 = a3;
  if (_os_feature_enabled_impl())
  {
    id v6 = im_primary_queue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10033D61C;
    block[3] = &unk_10097E440;
    id v16 = v4;
    uint64_t v17 = v5;
    id v7 = v5;
    int v8 = v4;
    dispatch_sync(v6, block);

    CFStringRef v9 = v16;
  }
  else
  {
    v14[0] = 0xAAAAAAAAAAAAAAAALL;
    v14[1] = 0xAAAAAAAAAAAAAAAALL;
    pthread_main_thread_np();
    pthread_dependency_init_np();
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_10033F3AC;
    v10[3] = &unk_1009875C8;
    CFStringRef v11 = v4;
    CFStringRef v12 = v5;
    id v13 = v14;
    id v7 = v5;
    int v8 = v4;
    dispatch_async((dispatch_queue_t)&_dispatch_main_q, v10);
    pthread_dependency_wait_np();

    CFStringRef v9 = v11;
  }
}

void sub_10033D61C(uint64_t a1)
{
}

void sub_10033D628(void *a1, void *a2)
{
  uint64_t v3 = a1;
  id v4 = a2;
  connection = v3;
  pid_t pid = xpc_connection_get_pid(v3);
  xpc_type_t type = xpc_get_type(v4);
  xpc_object_t object = v4;
  if (type != (xpc_type_t)&_xpc_type_error)
  {
    if (type == (xpc_type_t)&_xpc_type_dictionary)
    {
      id v12 = v4;
      if (_IDSWillLog())
      {
        id v13 = xpc_copy_description(v12);
        id v14 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109378;
          *(_DWORD *)&uint8_t buf[4] = xpc_connection_get_pid(connection);
          *(_WORD *)&uint8_t buf[8] = 2080;
          *(void *)&buf[10] = v13;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "received message from peer(%d): %s", buf, 0x12u);
        }

        if (os_log_shim_legacy_logging_enabled())
        {
          xpc_connection_get_pid(connection);
          MarcoLogMadridLevel();
          unsigned int v75 = (__CFString *)xpc_connection_get_pid(connection);
          unsigned __int8 v85 = v13;
          IMLogString();
          if (_IMWillLog())
          {
            unsigned int v75 = (__CFString *)xpc_connection_get_pid(connection);
            unsigned __int8 v85 = v13;
            _IMAlwaysLog();
          }
        }
        free(v13);
      }
      xpc_object_t xdict = v12;
      if (xpc_dictionary_get_BOOL(v12, "service-cache-request"))
      {
        uint64_t v15 = connection;
        id v16 = v12;
        xpc_object_t reply = xpc_dictionary_create_reply(v16);
        if (reply)
        {
          *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)buf = v18;
          *(_OWORD *)&uint8_t buf[16] = v18;
          xpc_connection_get_audit_token();
          pid_t v19 = xpc_connection_get_pid(v15);
          if ((IMDAuditTokenTaskHasEntitlement() & 1) != 0
            || (IMDAuditTokenTaskHasEntitlement() & 1) != 0
            || IMDAuditTokenTaskHasEntitlement())
          {
            IMGetXPCStringFromDictionary();
            CFStringRef v20 = (char *)objc_claimAutoreleasedReturnValue();
            IMGetXPCStringFromDictionary();
            CFStringRef v21 = (__CFString *)objc_claimAutoreleasedReturnValue();
            uint64_t v22 = OSLogHandleForIDSCategory();
            if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)v119 = 138412546;
              *(void *)&v119[4] = v21;
              *(_WORD *)&v119[12] = 2112;
              *(void *)&v119[14] = v20;
              _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "*** Incoming cache query for (service: %@) (transactionID: %@)", v119, 0x16u);
            }

            if (os_log_shim_legacy_logging_enabled())
            {
              MarcoLogMadridLevel();
              unsigned int v75 = v21;
              unsigned __int8 v85 = v20;
              IMLogString();
              if (_IMWillLog())
              {
                unsigned int v75 = v21;
                unsigned __int8 v85 = v20;
                _IMAlwaysLog();
              }
            }
            CFStringRef v23 = +[IDSDServiceController sharedInstance];
            uint64_t v24 = [v23 serviceWithIdentifier:v21];

            uint64_t v25 = [v24 queryService];
            id v26 = +[IDSIDStatusQueryController sharedInstance];
            uint64_t v27 = [v26 currentCacheForService:v25];

            uint64_t v28 = OSLogHandleForIDSCategory();
            if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
            {
              unsigned int v29 = [v27 count];
              *(_DWORD *)v119 = 67109120;
              *(_DWORD *)&v119[4] = v29;
              _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Current cache: %d count", v119, 8u);
            }

            if (os_log_shim_legacy_logging_enabled())
            {
              id v76 = [v27 count];
              MarcoLogMadridLevel();
              id v77 = objc_msgSend(v27, "count", v76);
              IMLogString();
              if (_IMWillLog())
              {
                objc_msgSend(v27, "count", v77);
                _IMAlwaysLog();
              }
            }
            IMInsertNSStringsToXPCDictionary();
            IMInsertDictionariesToXPCDictionary();
            IMInsertNSStringsToXPCDictionary();
          }
          else
          {
            uint64_t v69 = OSLogHandleForIDSCategory();
            if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)v119 = 67109120;
              *(_DWORD *)&v119[4] = v19;
              _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "Incoming cache query, but %d is not entitled to access the cache", v119, 8u);
            }

            if (os_log_shim_legacy_logging_enabled())
            {
              MarcoLogMadridLevel();
              IMLogString();
              if (_IMWillLog()) {
                _IMAlwaysLog();
              }
            }
          }
          xpc_connection_send_message(v15, reply);
        }
        else
        {
          uint64_t v65 = OSLogHandleForIDSCategory();
          if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_ERROR, "Could not create reply message for cache request", buf, 2u);
          }

          if (os_log_shim_legacy_logging_enabled())
          {
            MarcoLogMadridLevel();
            IMLogString();
            _IMWarn();
          }
        }
      }
      else if (xpc_dictionary_get_BOOL(v12, "cached-id-status-query"))
      {
        v101 = connection;
        xpc_object_t v106 = v12;
        xpc_object_t message = xpc_dictionary_create_reply(v106);
        if (message)
        {
          uint64_t v100 = IMGetXPCStringFromDictionary();
          IMGetXPCStringFromDictionary();
          id v104 = (char *)objc_claimAutoreleasedReturnValue();
          uint64_t v95 = IMGetXPCStringFromDictionary();
          v103 = IMGetXPCArrayFromDictionary();
          BOOL v112 = xpc_dictionary_get_BOOL(v106, "respect-expiry");
          __int16 v33 = OSLogHandleForIDSCategory();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
          {
            CFStringRef v34 = @"NO";
            *(_DWORD *)buf = 138413058;
            if (v112) {
              CFStringRef v34 = @"YES";
            }
            *(void *)&uint8_t buf[4] = v34;
            *(_WORD *)&buf[12] = 2112;
            *(void *)&buf[14] = v104;
            *(_WORD *)&unsigned char buf[22] = 2112;
            *(void *)&buf[24] = v100;
            LOWORD(v118) = 2112;
            *(void *)((char *)&v118 + 2) = v103;
            _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "*** Incoming cached ID status query for (respectExpiry: %@)  (service: %@)  (transactionID: %@)  (destinations: %@)", buf, 0x2Au);
          }

          if (os_log_shim_legacy_logging_enabled())
          {
            __int16 v35 = v112 ? @"YES" : @"NO";
            MarcoLogMadridLevel();
            id v91 = v100;
            uint64_t v92 = v103;
            unsigned int v75 = v35;
            unsigned __int8 v85 = v104;
            IMLogString();
            if (_IMWillLog())
            {
              id v91 = v100;
              uint64_t v92 = v103;
              unsigned int v75 = v35;
              unsigned __int8 v85 = v104;
              _IMAlwaysLog();
            }
          }
          uint64_t v98 = +[IDSURI URIWithUnprefixedURI:](IDSURI, "URIWithUnprefixedURI:", v95, v75, v85, v91, v92);
          CFStringRef v36 = +[IDSDServiceController sharedInstance];
          uint64_t v99 = [v36 serviceWithIdentifier:v104];

          __int16 v37 = [v99 queryService];
          CFStringRef v38 = +[IDSDAccountController sharedInstance];
          uint64_t v94 = [v38 accountsOnService:v99];

          uint64_t v93 = objc_msgSend(v103, "__imArrayByApplyingBlock:", &stru_100989578);
          char v102 = +[IDSQueryUtilities accountToQueryFrom:v94 fromURI:v98 destinationURIs:v93 allowLocalAccount:0];
          if (v102)
          {
            id v96 = objc_alloc_init((Class)NSMutableDictionary);
            id v97 = +[IDSQueryUtilities prefixedAliasStringToQueryFrom:v102 withPreferredFromURI:v98];
            if (![v97 length])
            {
              __int16 v39 = OSLogHandleForIDSCategory();
              if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 138412290;
                *(void *)&uint8_t buf[4] = v102;
                _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "No fromURI for account %@", buf, 0xCu);
              }

              if (os_log_shim_legacy_logging_enabled())
              {
                MarcoLogMadridLevel();
                uint64_t v78 = v102;
                IMLogString();
                if (_IMWillLog())
                {
                  uint64_t v78 = v102;
                  _IMAlwaysLog();
                }
              }
            }
            if (objc_msgSend(v97, "length", v78))
            {
              id v40 = sub_100133334(v103, v102);
              id v41 = OSLogHandleForIDSCategory();
              if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v42 = [v102 uniqueID];
                *(_DWORD *)buf = 138412546;
                *(void *)&uint8_t buf[4] = v42;
                *(_WORD *)&buf[12] = 2112;
                *(void *)&buf[14] = v97;
                _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Account: %@  fromURI: %@", buf, 0x16u);
              }
              if (os_log_shim_legacy_logging_enabled())
              {
                unsigned __int8 v80 = [v102 uniqueID];
                MarcoLogMadridLevel();

                uint64_t v79 = objc_msgSend(v102, "uniqueID", v80, v97);
                uint64_t v88 = v97;
                IMLogString();

                if (_IMWillLog())
                {
                  uint64_t v79 = objc_msgSend(v102, "uniqueID", v79, v97);
                  uint64_t v88 = v97;
                  _IMAlwaysLog();
                }
              }
              CFStringRef v111 = +[IDSURI URIWithUnprefixedURI:withServiceLoggingHint:](IDSURI, "URIWithUnprefixedURI:withServiceLoggingHint:", v97, v37, v79, v88);
              id v43 = objc_alloc_init((Class)NSMutableDictionary);
              long long v120 = 0u;
              long long v121 = 0u;
              memset(v119, 0, sizeof(v119));
              id obj = v40;
              id v44 = [obj countByEnumeratingWithState:v119 objects:buf count:16];
              if (v44)
              {
                uint64_t v45 = **(void **)&v119[16];
                do
                {
                  for (i = 0; i != v44; i = (char *)i + 1)
                  {
                    if (**(void **)&v119[16] != v45) {
                      objc_enumerationMutation(obj);
                    }
                    uint64_t v47 = *(void *)(*(void *)&v119[8] + 8 * i);
                    uint64_t v48 = OSLogHandleForIDSCategory();
                    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v49 = IDSLoggableDescriptionForHandleOnService();
                      *(_DWORD *)v113 = 138412546;
                      v114 = v49;
                      __int16 v115 = 2112;
                      v116 = v37;
                      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "Looking up cached value for %@ -> %@", v113, 0x16u);
                    }
                    if (os_log_shim_legacy_logging_enabled())
                    {
                      uint64_t v50 = IDSLoggableDescriptionForHandleOnService();
                      MarcoLogMadridLevel();

                      uint64_t v81 = IDSLoggableDescriptionForHandleOnService();
                      uint64_t v89 = v37;
                      IMLogString();

                      if (_IMWillLog())
                      {
                        uint64_t v81 = IDSLoggableDescriptionForHandleOnService();
                        uint64_t v89 = v37;
                        _IMAlwaysLog();
                      }
                    }
                    uint64_t v51 = +[IDSIDStatusQueryController sharedInstance];
                    unsigned __int8 v52 = +[IDSURI URIWithUnprefixedURI:v47 withServiceLoggingHint:v37];
                    id v53 = [v51 cachedIDStatusForID:v52 fromURI:v111 fromService:v37 respectExpiry:v112];

                    __int16 v54 = +[NSNumber numberWithInt:v53];
                    [v43 setObject:v54 forKey:v47];
                  }
                  id v44 = [obj countByEnumeratingWithState:v119 objects:buf count:16];
                }
                while (v44);
              }

              [v96 setObject:v43 forKey:v104];
            }
            IMInsertDictionariesToXPCDictionary();
            IMInsertNSStringsToXPCDictionary();
            IMInsertNSStringsToXPCDictionary();
            CFStringRef v55 = OSLogHandleForIDSCategory();
            if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
            {
              __int16 v56 = IDSLoggableDescriptionForObjectOnService();
              *(_DWORD *)v113 = 138412290;
              v114 = v56;
              _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "Sending id status results %@", v113, 0xCu);
            }
            if (os_log_shim_legacy_logging_enabled())
            {
              CFStringRef v57 = IDSLoggableDescriptionForObjectOnService();
              MarcoLogMadridLevel();

              uint64_t v82 = IDSLoggableDescriptionForObjectOnService();
              IMLogString();

              if (_IMWillLog())
              {
                unsigned __int8 v83 = IDSLoggableDescriptionForObjectOnService();
                _IMAlwaysLog();
              }
            }
            xpc_connection_send_message(v101, message);
          }
          else
          {
            id v67 = OSLogHandleForIDSCategory();
            if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138412290;
              *(void *)&uint8_t buf[4] = v104;
              _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "No registered account for service %@, bailing...", buf, 0xCu);
            }

            if (os_log_shim_legacy_logging_enabled())
            {
              MarcoLogMadridLevel();
              IMLogString();
              if (_IMWillLog()) {
                _IMAlwaysLog();
              }
            }
            if (v101)
            {
              *(void *)v119 = IDSIDQueryControllerErrorDestinationSet;
              *(void *)buf = v103;
              id v68 = +[NSDictionary dictionaryWithObjects:buf forKeys:v119 count:1];
              unsigned __int8 v84 = +[NSError errorWithDomain:IDSIDQueryControllerErrorDomain code:-3000 userInfo:v68];
              IMInsertKeyedCodableObjectsToXPCDictionary();

              xpc_connection_send_message(v101, message);
            }
          }
        }
        else
        {
          CFStringRef v66 = OSLogHandleForIDSCategory();
          if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_ERROR, "Could not create reply message for cached id status query", buf, 2u);
          }

          if (os_log_shim_legacy_logging_enabled())
          {
            MarcoLogMadridLevel();
            IMLogString();
            _IMWarn();
          }
        }
      }
      else if (xpc_dictionary_get_BOOL(v12, "id-status-query"))
      {
        id v59 = connection;
        id v60 = v12;
        if (qword_100A4C7B8 != -1) {
          dispatch_once(&qword_100A4C7B8, &stru_100989598);
        }
        id v61 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "__HandleIDStatusQuery - enqueuing", buf, 2u);
        }

        if (os_log_shim_legacy_logging_enabled())
        {
          MarcoLogMadridLevel();
          IMLogString();
          if (_IMWillLog()) {
            _IMAlwaysLog();
          }
        }
        *(void *)buf = _NSConcreteStackBlock;
        *(void *)&uint8_t buf[8] = 3221225472;
        *(void *)&uint8_t buf[16] = sub_10033FF10;
        *(void *)&buf[24] = &unk_10097E440;
        *(void *)&long long v118 = v60;
        *((void *)&v118 + 1) = v59;
        id v62 = v60;
        id v63 = v59;
        id v64 = objc_retainBlock(buf);
        [(id)qword_100A4C7B0 enqueueQueryBlock:v64 cleanup:0];
      }
      else if (xpc_dictionary_get_BOOL(v12, "set-id-status"))
      {
        sub_10033F550(connection, v12);
      }
      else if (xpc_dictionary_get_BOOL(v12, "remote-device-status-query"))
      {
        sub_10033F8E0(connection, v12);
      }
      else if (xpc_dictionary_get_BOOL(v12, "id-status-info-query"))
      {
        sub_10033FAB4(connection, v12);
      }
      else if (xpc_dictionary_get_BOOL(v12, "flush-query-cache"))
      {
        sub_10033FC88(connection, v12);
      }
      else
      {
        unsigned __int8 v70 = xpc_copy_description(v12);
        unsigned __int8 v71 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
        {
          uint64_t v72 = IMProcessNameForPid();
          *(_DWORD *)buf = 67109634;
          *(_DWORD *)&uint8_t buf[4] = pid;
          *(_WORD *)&uint8_t buf[8] = 2112;
          *(void *)&buf[10] = v72;
          *(_WORD *)&buf[18] = 2080;
          *(void *)&buf[20] = v70;
          _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_ERROR, "Unknown message from peer: (%d):(%@) %s", buf, 0x1Cu);
        }
        if (os_log_shim_legacy_logging_enabled())
        {
          unsigned __int8 v73 = IMProcessNameForPid();
          MarcoLogMadridLevel();

          char v74 = IMProcessNameForPid();
          IMLogString();

          v90 = IMProcessNameForPid();
          _IMWarn();
        }
        free(v70);
        xpc_connection_cancel(connection);
      }
    }
    else
    {
      id v7 = xpc_copy_description(v4);
      int v8 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v9 = IMProcessNameForPid();
        *(_DWORD *)buf = 67109634;
        *(_DWORD *)&uint8_t buf[4] = pid;
        *(_WORD *)&uint8_t buf[8] = 2112;
        *(void *)&buf[10] = v9;
        *(_WORD *)&buf[18] = 2080;
        *(void *)&buf[20] = v7;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "received unknown from peer(%d):(%@) %s", buf, 0x1Cu);
      }
      if (os_log_shim_legacy_logging_enabled())
      {
        id v10 = IMProcessNameForPid();
        MarcoLogMadridLevel();

        long long v86 = IMProcessNameForPid();
        IMLogString();

        if (_IMWillLog())
        {
          uint64_t v87 = IMProcessNameForPid();
          _IMAlwaysLog();
        }
      }
      free(v7);
    }
    goto LABEL_130;
  }
  if (v4 == &_xpc_error_connection_invalid)
  {
    id v30 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = xpc_connection_get_pid(v3);
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "peer(%d) received XPC_ERROR_CONNECTION_INVALID", buf, 8u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      xpc_connection_get_pid(v3);
      MarcoLogMadridLevel();
      xpc_connection_get_pid(v3);
      IMLogString();
      if (_IMWillLog())
      {
        xpc_connection_get_pid(v3);
        _IMAlwaysLog();
      }
    }
    CFStringRef v31 = im_local_object_from_connection();
    id v32 = v31;
    if (v31)
    {
      [v31 _portDidBecomeInvalid];
      CFRelease(v32);
    }
    xpc_connection_cancel(v3);
  }
  else if (v4 == &_xpc_error_connection_interrupted)
  {
    uint64_t v58 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = xpc_connection_get_pid(v3);
      _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "peer(%d) received XPC_ERROR_CONNECTION_INTERRUPTED", buf, 8u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      xpc_connection_get_pid(v3);
      MarcoLogMadridLevel();
      xpc_connection_get_pid(v3);
      IMLogString();
      if (_IMWillLog()) {
        goto LABEL_16;
      }
    }
  }
  else if (v4 == &_xpc_error_termination_imminent)
  {
    CFStringRef v11 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = xpc_connection_get_pid(v3);
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "peer(%d) received XPC_ERROR_TERMINATION_IMMINENT", buf, 8u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      xpc_connection_get_pid(v3);
      MarcoLogMadridLevel();
      xpc_connection_get_pid(v3);
      IMLogString();
      if (_IMWillLog())
      {
LABEL_16:
        xpc_connection_get_pid(v3);
        _IMAlwaysLog();
      }
    }
  }
LABEL_130:
}

uint64_t sub_10033F3AC(uint64_t a1)
{
  sub_10033D628(*(void **)(a1 + 32), *(void **)(a1 + 40));
  uint64_t v2 = *(void *)(a1 + 48);

  return _pthread_dependency_fulfill_np(v2, 0);
}

id sub_10033F478(uint64_t a1)
{
  return _objc_msgSend(*(id *)(a1 + 32), "__setupServer");
}

void sub_10033F550(void *a1, void *a2)
{
  uint64_t v3 = a1;
  id v4 = a2;
  xpc_connection_get_audit_token();
  pid_t pid = xpc_connection_get_pid(v3);
  if (IMDAuditTokenTaskHasEntitlement())
  {
    id v6 = IMGetXPCStringFromDictionary();
    id v7 = IMGetXPCStringFromDictionary();
    uint64_t v8 = IMGetXPCIntFromDictionary();
    CFStringRef v9 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109634;
      int v18 = v8;
      __int16 v19 = 2112;
      CFStringRef v20 = v6;
      __int16 v21 = 2112;
      uint64_t v22 = v7;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "*** Incoming ID status update: %d  (service: %@)  (destination: %@)", buf, 0x1Cu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      MarcoLogMadridLevel();
      uint64_t v15 = v6;
      id v16 = v7;
      uint64_t v14 = v8;
      IMLogString();
      if (_IMWillLog())
      {
        uint64_t v15 = v6;
        id v16 = v7;
        uint64_t v14 = v8;
        _IMAlwaysLog();
      }
    }
    id v10 = +[IDSURI URIWithUnprefixedURI:withServiceLoggingHint:](IDSURI, "URIWithUnprefixedURI:withServiceLoggingHint:", v7, v6, v14, v15, v16);
    CFStringRef v11 = +[IDSIDStatusQueryController sharedInstance];
    id v12 = +[IDSURI URIWithUnprefixedURI:@"email:myself" withServiceLoggingHint:v6];
    [v11 setCachedIDStatus:v8 ForID:v10 fromURI:v12 fromService:v6];
  }
  else
  {
    id v13 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v18 = pid;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "*** Incoming ID status update, from un-entitled proess: %d", buf, 8u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      MarcoLogMadridLevel();
      IMLogString();
      if (_IMWillLog()) {
        _IMAlwaysLog();
      }
    }
  }
}

void sub_10033F8E0(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  if (qword_100A4C7D0 != -1) {
    dispatch_once(&qword_100A4C7D0, &stru_100989620);
  }
  uint64_t v5 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "__HandleRemoteDeviceQuery - enqueuing", buf, 2u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    MarcoLogMadridLevel();
    IMLogString();
    if (_IMWillLog()) {
      _IMAlwaysLog();
    }
  }
  CFStringRef v9 = _NSConcreteStackBlock;
  uint64_t v10 = 3221225472;
  CFStringRef v11 = sub_100341A90;
  id v12 = &unk_10097E440;
  id v13 = v4;
  id v14 = v3;
  id v6 = v3;
  id v7 = v4;
  uint64_t v8 = objc_retainBlock(&v9);
  objc_msgSend((id)qword_100A4C7B0, "enqueueQueryBlock:cleanup:", v8, 0, v9, v10, v11, v12);
}

void sub_10033FAB4(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  if (qword_100A4C7D8 != -1) {
    dispatch_once(&qword_100A4C7D8, &stru_100989688);
  }
  uint64_t v5 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "__HandleIDInfoQuery - enqueuing", buf, 2u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    MarcoLogMadridLevel();
    IMLogString();
    if (_IMWillLog()) {
      _IMAlwaysLog();
    }
  }
  CFStringRef v9 = _NSConcreteStackBlock;
  uint64_t v10 = 3221225472;
  CFStringRef v11 = sub_1003430B8;
  id v12 = &unk_10097E440;
  id v13 = v4;
  id v14 = v3;
  id v6 = v3;
  id v7 = v4;
  uint64_t v8 = objc_retainBlock(&v9);
  objc_msgSend((id)qword_100A4C7B0, "enqueueQueryBlock:cleanup:", v8, 0, v9, v10, v11, v12);
}

void sub_10033FC88(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  xpc_connection_get_audit_token();
  pid_t pid = xpc_connection_get_pid(v3);
  if (IMDAuditTokenTaskHasEntitlement())
  {
    id v6 = +[IMIDSLog daemon];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      pid_t v11 = pid;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "*** Clearing ID status cache due to incoming cache clear from process: %d ***", buf, 8u);
    }

    id v7 = +[IDSPeerIDManager sharedInstance];
    [v7 clearCacheAndPersistImmediately:1];

    uint64_t v8 = +[IDSIDStatusQueryController sharedInstance];
    [v8 clearCache];
  }
  else
  {
    CFStringRef v9 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      pid_t v11 = pid;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "*** Incoming Query cache clear, from un-entitled proess: %d", buf, 8u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      MarcoLogMadridLevel();
      IMLogString();
      if (_IMWillLog()) {
        _IMAlwaysLog();
      }
    }
  }
}

id sub_10033FEC4(id a1, NSString *a2)
{
  return +[IDSURI URIWithUnprefixedURI:a2];
}

void sub_10033FED4(id a1)
{
  uint64_t v1 = objc_alloc_init(IDSStatusQueryQueue);
  uint64_t v2 = qword_100A4C7B0;
  qword_100A4C7B0 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_10033FF10(uint64_t a1)
{
  uint64_t v101 = 0;
  char v102 = &v101;
  uint64_t v103 = 0x3032000000;
  id v104 = sub_1003413C0;
  id v105 = sub_1003413D0;
  id reply = (id)0xAAAAAAAAAAAAAAAALL;
  id reply = xpc_dictionary_create_reply(*(xpc_object_t *)(a1 + 32));
  if (v102[5])
  {
    uint64_t v81 = IMGetXPCStringFromDictionary();
    uint64_t v2 = IMGetXPCStringFromDictionary();
    uint64_t v78 = IMGetXPCStringFromDictionary();
    unsigned __int8 v84 = IMGetXPCArrayFromDictionary();
    int v76 = IMGetXPCBoolFromDictionary();
    unsigned __int8 v85 = (void *)v2;
    int v3 = IMGetXPCBoolFromDictionary();
    int v75 = IMGetXPCBoolFromDictionary();
    id v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = IDSLoggableDescriptionForHandlesOnService();
      id v6 = (void *)v5;
      CFStringRef v7 = @"NO";
      *(_DWORD *)buf = 138413570;
      v116 = v85;
      if (v76) {
        CFStringRef v8 = @"YES";
      }
      else {
        CFStringRef v8 = @"NO";
      }
      if (v3) {
        CFStringRef v9 = @"YES";
      }
      else {
        CFStringRef v9 = @"NO";
      }
      if (v75) {
        CFStringRef v7 = @"YES";
      }
      __int16 v117 = 2112;
      uint64_t v118 = (uint64_t)v81;
      __int16 v119 = 2112;
      uint64_t v120 = v5;
      __int16 v121 = 2112;
      CFStringRef v122 = v8;
      __int16 v123 = 2112;
      CFStringRef v124 = v9;
      __int16 v125 = 2112;
      CFStringRef v126 = v7;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "*** Incoming ID status query  (service: %@)  (transactionID: %@)  (destinations: %@)   (sb: %@)  (force: %@) (bypass limit: %@)", buf, 0x3Eu);
    }
    if (os_log_shim_legacy_logging_enabled())
    {
      uint64_t v10 = IDSLoggableDescriptionForHandlesOnService();
      pid_t v11 = v76 ? @"YES" : @"NO";
      id v12 = v3 ? @"YES" : @"NO";
      id v13 = v75 ? @"YES" : @"NO";
      MarcoLogMadridLevel();

      IDSLoggableDescriptionForHandlesOnService();
      CFStringRef v66 = v12;
      id v64 = v67 = v13;
      uint64_t v65 = v11;
      IMLogString();

      if (_IMWillLog())
      {
        IDSLoggableDescriptionForHandlesOnService();
        CFStringRef v66 = v12;
        id v64 = v67 = v13;
        uint64_t v65 = v11;
        _IMAlwaysLog();
      }
    }
    IMInsertNSStringsToXPCDictionary();
    IMInsertNSStringsToXPCDictionary();
    uint64_t v79 = +[IDSURI URIWithUnprefixedURI:](IDSURI, "URIWithUnprefixedURI:", v78, v81, 0);
    id v14 = +[IDSDServiceController sharedInstance];
    uint64_t v82 = [v14 serviceWithIdentifier:v85];

    char v74 = [v82 queryService];
    uint64_t v15 = +[IDSDAccountController sharedInstance];
    id v77 = [v15 accountsOnService:v82];

    id v16 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      v116 = v82;
      __int16 v117 = 2112;
      uint64_t v118 = (uint64_t)v85;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Found service %@ for serviceName %@", buf, 0x16u);
    }

    uint64_t v17 = v85;
    if (os_log_shim_legacy_logging_enabled())
    {
      MarcoLogMadridLevel();
      CFStringRef v55 = v82;
      id v62 = v85;
      IMLogString();
      if (_IMWillLog())
      {
        CFStringRef v55 = v82;
        id v62 = v85;
        _IMAlwaysLog();
      }
    }
    unsigned __int8 v73 = objc_msgSend(v84, "__imArrayByApplyingBlock:", &stru_1009895B8, v55, v62, v64, v65, v66, v67);
    unsigned __int8 v83 = +[IDSQueryUtilities accountToQueryFrom:fromURI:destinationURIs:allowLocalAccount:](IDSQueryUtilities, "accountToQueryFrom:fromURI:destinationURIs:allowLocalAccount:", v77, v79);
    if (!v83)
    {
      int v18 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v116 = v85;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "No registered account for service %@", buf, 0xCu);
      }

      uint64_t v17 = v85;
      if (os_log_shim_legacy_logging_enabled())
      {
        MarcoLogMadridLevel();
        __int16 v56 = v85;
        IMLogString();
        if (_IMWillLog())
        {
          __int16 v56 = v85;
          _IMAlwaysLog();
        }
      }
    }
    unsigned __int8 v80 = +[IDSQueryUtilities prefixedAliasStringToQueryFrom:withPreferredFromURI:](IDSQueryUtilities, "prefixedAliasStringToQueryFrom:withPreferredFromURI:", v83, v79, v56);
    if (!v83) {
      goto LABEL_58;
    }
    if (![v80 length])
    {
      __int16 v19 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v116 = v83;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "No fromURI for account %@", buf, 0xCu);
      }

      uint64_t v17 = v85;
      if (os_log_shim_legacy_logging_enabled())
      {
        MarcoLogMadridLevel();
        CFStringRef v57 = v83;
        IMLogString();
        if (_IMWillLog())
        {
          CFStringRef v57 = v83;
          _IMAlwaysLog();
        }
      }
    }
    if (!objc_msgSend(v80, "length", v57))
    {
LABEL_58:
      id v26 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v116 = v17;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "No registered account for service after if %@, bailing...", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        MarcoLogMadridLevel();
        CFStringRef v57 = v85;
        IMLogString();
        if (_IMWillLog())
        {
          CFStringRef v57 = v85;
          _IMAlwaysLog();
        }
      }
      uint64_t v107 = IDSIDQueryControllerErrorDestinationSet;
      v108 = v84;
      uint64_t v27 = +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v108, &v107, 1, v57);
      id v59 = +[NSError errorWithDomain:IDSIDQueryControllerErrorDomain code:-3000 userInfo:v27];
      IMInsertKeyedCodableObjectsToXPCDictionary();

      uint64_t v28 = *(_xpc_connection_s **)(a1 + 40);
      if (v28) {
        xpc_connection_send_message(v28, (xpc_object_t)v102[5]);
      }
      goto LABEL_110;
    }
    CFStringRef v20 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      v116 = v80;
      __int16 v117 = 2112;
      uint64_t v118 = (uint64_t)v83;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Using %@ from %@ to perform id query.", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      MarcoLogMadridLevel();
      CFStringRef v57 = v80;
      uint64_t v63 = (uint64_t)v83;
      IMLogString();
      if (_IMWillLog())
      {
        CFStringRef v57 = v80;
        uint64_t v63 = (uint64_t)v83;
        _IMAlwaysLog();
      }
    }
    uint64_t v72 = sub_100133334(v84, v83);
    unsigned __int8 v71 = [v83 _registrationCert];
    if ([v72 count] && v71)
    {
      __int16 v21 = +[IMSystemMonitor sharedInstance];
      unsigned int v22 = [v21 isUnderFirstDataProtectionLock];

      if (!v22)
      {
        v96[0] = _NSConcreteStackBlock;
        v96[1] = 3221225472;
        v96[2] = sub_1003413E8;
        v96[3] = &unk_1009895E0;
        uint64_t v100 = &v101;
        id v68 = v74;
        id v97 = v68;
        id v34 = v85;
        id v98 = v34;
        id v99 = *(id *)(a1 + 40);
        uint64_t v69 = objc_retainBlock(v96);
        if (v3)
        {
          if (qword_100A4C7C8 != -1) {
            dispatch_once(&qword_100A4C7C8, &stru_100989600);
          }
          long long v94 = 0u;
          long long v95 = 0u;
          long long v92 = 0u;
          long long v93 = 0u;
          id obj = v84;
          id v35 = [obj countByEnumeratingWithState:&v92 objects:v110 count:16];
          if (v35)
          {
            uint64_t v36 = *(void *)v93;
            while (2)
            {
              for (i = 0; i != v35; i = (char *)i + 1)
              {
                if (*(void *)v93 != v36) {
                  objc_enumerationMutation(obj);
                }
                CFStringRef v38 = +[NSString stringWithFormat:@"%@-%@", v34, *(void *)(*((void *)&v92 + 1) + 8 * i)];
                if (([(id)qword_100A4C7C0 underLimitForItem:v38] & 1) == 0)
                {
                  uint64_t v45 = OSLogHandleForIDSCategory();
                  if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 138412546;
                    v116 = v38;
                    __int16 v117 = 2112;
                    uint64_t v118 = qword_100A4C7C0;
                    _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "Tried forcing, however this destination is not under the limit {destString: %@, rateLimiter: %@}", buf, 0x16u);
                  }

                  if (os_log_shim_legacy_logging_enabled())
                  {
                    MarcoLogMadridLevel();
                    CFStringRef v57 = v38;
                    uint64_t v63 = qword_100A4C7C0;
                    IMLogString();
                    if (_IMWillLog())
                    {
                      CFStringRef v57 = v38;
                      uint64_t v63 = qword_100A4C7C0;
                      _IMAlwaysLog();
                    }
                  }

                  char v44 = 0;
                  goto LABEL_104;
                }
              }
              id v35 = [obj countByEnumeratingWithState:&v92 objects:v110 count:16];
              if (v35) {
                continue;
              }
              break;
            }
          }

          long long v90 = 0u;
          long long v91 = 0u;
          long long v88 = 0u;
          long long v89 = 0u;
          id v39 = obj;
          id v40 = [v39 countByEnumeratingWithState:&v88 objects:v109 count:16];
          if (v40)
          {
            uint64_t v41 = *(void *)v89;
            do
            {
              for (j = 0; j != v40; j = (char *)j + 1)
              {
                if (*(void *)v89 != v41) {
                  objc_enumerationMutation(v39);
                }
                id v43 = +[NSString stringWithFormat:@"%@-%@", v34, *(void *)(*((void *)&v88 + 1) + 8 * (void)j)];
                [(id)qword_100A4C7C0 noteItem:v43];
              }
              id v40 = [v39 countByEnumeratingWithState:&v88 objects:v109 count:16];
            }
            while (v40);
          }
          char v44 = 1;
LABEL_104:
        }
        else
        {
          char v44 = 0;
        }
        v86[0] = _NSConcreteStackBlock;
        v86[1] = 3221225472;
        v86[2] = sub_100341974;
        v86[3] = &unk_10097E990;
        id v46 = v68;
        id v87 = v46;
        uint64_t v47 = objc_msgSend(v72, "__imArrayByApplyingBlock:", v86);
        if (v76)
        {
          uint64_t v48 = +[IDSServerBag sharedInstanceForBagType:0];
          uint64_t v49 = [v48 objectForKey:@"vc-disable-springboard-queries"];
          unsigned int v50 = [v49 BOOLValue];

          uint64_t v51 = v50 ^ 1;
        }
        else
        {
          uint64_t v51 = 1;
        }
        unsigned __int8 v52 = +[IDSIDStatusQueryController sharedInstance];
        id v53 = +[IDSURI URIWithUnprefixedURI:v80 withServiceLoggingHint:v46];
        __int16 v54 = sub_10034198C(@"IDStatus", *(void **)(a1 + 40));
        BYTE1(v61) = v75;
        LOBYTE(v61) = v44;
        objc_msgSend(v52, "requestIDStatusForIDs:fromIdentity:fromURI:fromService:lightQuery:allowQuery:forceQuery:bypassLimit:reason:completionBlock:", v47, v71, v53, v46, 1, v51, v61, v54, v69);

        goto LABEL_109;
      }
      CFStringRef v23 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        v116 = v84;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Querying %@ while under first unlock, bailing...", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        MarcoLogMadridLevel();
        IMLogString();
        CFStringRef v57 = v84;
        _IMWarn();
      }
      uint64_t v24 = v84;
      if (!v84) {
        uint64_t v24 = &__NSArray0__struct;
      }
      uint64_t v111 = IDSIDQueryControllerErrorDestinationSet;
      BOOL v112 = v24;
      uint64_t v25 = +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v112, &v111, 1, v57, v63);
      uint64_t v58 = +[NSError errorWithDomain:IDSIDQueryControllerErrorDomain code:-4000 userInfo:v25];
      IMInsertKeyedCodableObjectsToXPCDictionary();
    }
    else
    {
      id v30 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        v116 = v84;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "No URIs or cert after filtering destinations %@, bailing...", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        MarcoLogMadridLevel();
        IMLogString();
        CFStringRef v57 = v84;
        _IMWarn();
      }
      CFStringRef v31 = v84;
      if (!v84) {
        CFStringRef v31 = &__NSArray0__struct;
      }
      uint64_t v113 = IDSIDQueryControllerErrorDestinationSet;
      v114 = v31;
      id v32 = +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v114, &v113, 1, v57, v63);
      id v60 = +[NSError errorWithDomain:IDSIDQueryControllerErrorDomain code:-3000 userInfo:v32];
      IMInsertKeyedCodableObjectsToXPCDictionary();
    }
    __int16 v33 = *(_xpc_connection_s **)(a1 + 40);
    if (v33) {
      xpc_connection_send_message(v33, (xpc_object_t)v102[5]);
    }
LABEL_109:

LABEL_110:
    goto LABEL_111;
  }
  unsigned int v29 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Could not create reply message for cached id status query", buf, 2u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    MarcoLogMadridLevel();
    IMLogString();
    _IMWarn();
  }
LABEL_111:
  _Block_object_dispose(&v101, 8);
}

void sub_100341218(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
}

uint64_t sub_1003413C0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1003413D0(uint64_t a1)
{
}

id sub_1003413D8(id a1, NSString *a2)
{
  return +[IDSURI URIWithUnprefixedURI:a2];
}

void sub_1003413E8(void *a1, void *a2, void *a3, void *a4, int a5, void *a6)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a4;
  id v14 = a6;
  uint64_t v15 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v16 = @"NO";
    if (a5) {
      CFStringRef v17 = @"YES";
    }
    else {
      CFStringRef v17 = @"NO";
    }
    if (*(void *)(*(void *)(a1[7] + 8) + 40)) {
      CFStringRef v16 = @"YES";
    }
    *(_DWORD *)buf = 138413570;
    id v39 = v11;
    __int16 v40 = 2112;
    id v41 = v12;
    __int16 v42 = 2112;
    id v43 = v13;
    __int16 v44 = 2112;
    CFStringRef v45 = v17;
    __int16 v46 = 2112;
    id v47 = v14;
    __int16 v48 = 2112;
    CFStringRef v49 = v16;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Received status query updates (idStatusUpdates: %@)  (updateFromURI: %@)  (updateService: %@)  (success: %@)  (error: %@) - replyMessage? %@", buf, 0x3Eu);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    int v18 = a5 ? @"YES" : @"NO";
    MarcoLogMadridLevel();
    __int16 v19 = *(void *)(*(void *)(a1[7] + 8) + 40) ? @"YES" : @"NO";
    id v36 = v14;
    __int16 v37 = v19;
    id v34 = v13;
    id v35 = v18;
    id v29 = v11;
    id v33 = v12;
    IMLogString();
    if (_IMWillLog())
    {
      if (*(void *)(*(void *)(a1[7] + 8) + 40)) {
        CFStringRef v20 = @"YES";
      }
      else {
        CFStringRef v20 = @"NO";
      }
      id v36 = v14;
      __int16 v37 = (__CFString *)v20;
      id v34 = v13;
      id v35 = v18;
      id v29 = v11;
      id v33 = v12;
      _IMAlwaysLog();
    }
  }
  if (*(void *)(*(void *)(a1[7] + 8) + 40))
  {
    id v21 = objc_alloc_init((Class)NSMutableDictionary);
    unsigned int v22 = [v11 objectForKey:a1[4]];
    if (v22) {
      [v21 setObject:v22 forKey:a1[5]];
    }
    if (objc_msgSend(v21, "count", v29, v33, v34, v35, v36, v37))
    {
      id v30 = +[NSKeyedArchiver archivedDataWithRootObject:v21 requiringSecureCoding:1 error:0];
      IMInsertDatasToXPCDictionary();
    }
    CFStringRef v23 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v24 = IDSLoggableDescriptionForObjectOnService();
      *(_DWORD *)buf = 138412290;
      id v39 = v24;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Sending id status results %@", buf, 0xCu);
    }
    if (os_log_shim_legacy_logging_enabled())
    {
      uint64_t v25 = IDSLoggableDescriptionForObjectOnService();
      MarcoLogMadridLevel();

      CFStringRef v31 = IDSLoggableDescriptionForObjectOnService();
      IMLogString();

      if (_IMWillLog())
      {
        id v32 = IDSLoggableDescriptionForObjectOnService();
        _IMAlwaysLog();
      }
    }
    id v26 = (_xpc_connection_s *)a1[6];
    if (v26) {
      xpc_connection_send_message(v26, *(xpc_object_t *)(*(void *)(a1[7] + 8) + 40));
    }
    uint64_t v27 = *(void *)(a1[7] + 8);
    uint64_t v28 = *(void **)(v27 + 40);
    *(void *)(v27 + 40) = 0;
  }
}

void sub_100341878(id a1)
{
  uint64_t v1 = +[IDSServerBag sharedInstanceForBagType:0];
  id v9 = [v1 objectForKey:@"client-query-max-per-uri"];

  uint64_t v2 = +[IDSServerBag sharedInstanceForBagType:0];
  int v3 = [v2 objectForKey:@"client-query-max-time-range"];

  if (v9)
  {
    uint64_t v4 = (uint64_t)[v9 integerValue];
    if (v3)
    {
LABEL_3:
      [v3 doubleValue];
      double v6 = v5;
      goto LABEL_6;
    }
  }
  else
  {
    uint64_t v4 = 6;
    if (v3) {
      goto LABEL_3;
    }
  }
  double v6 = 82800.0;
LABEL_6:
  id v7 = [objc_alloc((Class)IDSRateLimiter) initWithLimit:v4 timeLimit:v6];
  CFStringRef v8 = (void *)qword_100A4C7C0;
  qword_100A4C7C0 = (uint64_t)v7;
}

IDSURI *sub_100341974(uint64_t a1, uint64_t a2)
{
  return +[IDSURI URIWithUnprefixedURI:a2 withServiceLoggingHint:*(void *)(a1 + 32)];
}

id sub_10034198C(void *a1, void *a2)
{
  id v3 = a1;
  uint64_t v4 = a2;
  double v5 = IMGetXPCStringFromDictionary();
  if (v5) {
    +[NSString stringWithFormat:@"%@[%@]", v3, v5];
  }
  else {
  double v6 = +[NSString stringWithFormat:@"%@[%llu]", v3, xpc_connection_get_pid(v4)];
  }

  return v6;
}

void sub_100341A54(id a1)
{
  uint64_t v1 = objc_alloc_init(IDSStatusQueryQueue);
  uint64_t v2 = qword_100A4C7B0;
  qword_100A4C7B0 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_100341A90(uint64_t a1)
{
  uint64_t v79 = 0;
  unsigned __int8 v80 = &v79;
  uint64_t v81 = 0x3032000000;
  uint64_t v82 = sub_1003413C0;
  unsigned __int8 v83 = sub_1003413D0;
  id reply = (id)0xAAAAAAAAAAAAAAAALL;
  id reply = xpc_dictionary_create_reply(*(xpc_object_t *)(a1 + 32));
  if (v80[5])
  {
    uint64_t v72 = IMGetXPCStringFromDictionary();
    uint64_t v2 = IMGetXPCStringFromDictionary();
    unsigned __int8 v70 = IMGetXPCStringFromDictionary();
    id v3 = +[IDSDestination classesForStrictUnarchiving];
    uint64_t v4 = IMGetXPCKeyedCodableFromDictionaryWithSecureCodingAllowedClasses();

    int v67 = IMGetXPCBoolFromDictionary();
    int v62 = IMGetXPCBoolFromDictionary();
    double v5 = [v4 destinationURIs];
    unsigned __int8 v71 = [v5 allObjects];

    double v6 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      id v7 = [v4 destinationURIs];
      CFStringRef v8 = [v7 allObjects];
      uint64_t v9 = IDSLoggableDescriptionForHandlesOnService();
      uint64_t v10 = (void *)v9;
      CFStringRef v11 = @"NO";
      *(_DWORD *)buf = 138413058;
      long long v92 = v2;
      if (v67) {
        CFStringRef v11 = @"YES";
      }
      __int16 v93 = 2112;
      long long v94 = v72;
      __int16 v95 = 2112;
      uint64_t v96 = v9;
      __int16 v97 = 2112;
      CFStringRef v98 = v11;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "*** Incoming ID status query  (service: %@)  (transactionID: %@)  (destinations: %@)   (sb: %@)", buf, 0x2Au);
    }
    if (os_log_shim_legacy_logging_enabled())
    {
      id v12 = [v4 destinationURIs];
      id v13 = [v12 allObjects];
      uint64_t v14 = IDSLoggableDescriptionForHandlesOnService();
      uint64_t v15 = (void *)v14;
      CFStringRef v16 = v67 ? @"YES" : @"NO";
      uint64_t v58 = v14;
      MarcoLogMadridLevel();

      CFStringRef v17 = objc_msgSend(v4, "destinationURIs", v2, v72, v58, v16);
      int v18 = [v17 allObjects];
      CFStringRef v57 = IDSLoggableDescriptionForHandlesOnService();
      id v59 = v16;
      IMLogString();

      if (_IMWillLog())
      {
        __int16 v19 = objc_msgSend(v4, "destinationURIs", v2, v72, v57, v16);
        CFStringRef v20 = [v19 allObjects];
        CFStringRef v57 = IDSLoggableDescriptionForHandlesOnService();
        id v59 = v16;
        _IMAlwaysLog();
      }
    }
    IMInsertNSStringsToXPCDictionary();
    IMInsertNSStringsToXPCDictionary();
    id v21 = +[IDSURI URIWithUnprefixedURI:](IDSURI, "URIWithUnprefixedURI:", v70, v72, 0);
    unsigned int v22 = +[IDSDServiceController sharedInstance];
    CFStringRef v23 = [v22 serviceWithIdentifier:v2];

    CFStringRef v66 = [v23 queryService];
    uint64_t v24 = +[IDSDAccountController sharedInstance];
    uint64_t v69 = [v24 accountsOnService:v23];

    uint64_t v25 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      long long v92 = v23;
      __int16 v93 = 2112;
      long long v94 = v2;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Found service %@ for serviceName %@", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      MarcoLogMadridLevel();
      CFStringRef v49 = v23;
      CFStringRef v55 = v2;
      IMLogString();
      if (_IMWillLog())
      {
        CFStringRef v49 = v23;
        CFStringRef v55 = v2;
        _IMAlwaysLog();
      }
    }
    uint64_t v65 = objc_msgSend(v71, "__imArrayByApplyingBlock:", &stru_100989640, v49, v55, v57, v59);
    id v26 = +[IDSQueryUtilities accountToQueryFrom:fromURI:destinationURIs:allowLocalAccount:](IDSQueryUtilities, "accountToQueryFrom:fromURI:destinationURIs:allowLocalAccount:", v69, v21);
    if (!v26)
    {
      uint64_t v27 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        long long v92 = v2;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "No registered account for service %@", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        MarcoLogMadridLevel();
        unsigned int v50 = v2;
        IMLogString();
        if (_IMWillLog())
        {
          unsigned int v50 = v2;
          _IMAlwaysLog();
        }
      }
    }
    uint64_t v28 = +[IDSQueryUtilities prefixedAliasStringToQueryFrom:withPreferredFromURI:](IDSQueryUtilities, "prefixedAliasStringToQueryFrom:withPreferredFromURI:", v26, v21, v50);
    id v29 = v28;
    if (!v26) {
      goto LABEL_45;
    }
    if (![v28 length])
    {
      id v30 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        long long v92 = v26;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "No fromURI for account %@", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        MarcoLogMadridLevel();
        uint64_t v51 = v26;
        IMLogString();
        if (_IMWillLog())
        {
          uint64_t v51 = v26;
          _IMAlwaysLog();
        }
      }
    }
    if (!objc_msgSend(v29, "length", v51))
    {
LABEL_45:
      id v36 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        long long v92 = v2;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "No registered account for service after if %@, bailing...", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        MarcoLogMadridLevel();
        uint64_t v51 = v2;
        IMLogString();
        if (_IMWillLog())
        {
          uint64_t v51 = v2;
          _IMAlwaysLog();
        }
      }
      uint64_t v85 = IDSIDQueryControllerErrorDestinationSet;
      long long v86 = v71;
      __int16 v37 = +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v86, &v85, 1, v51);
      unsigned __int8 v52 = +[NSError errorWithDomain:IDSIDQueryControllerErrorDomain code:-3000 userInfo:v37];
      IMInsertKeyedCodableObjectsToXPCDictionary();

      CFStringRef v38 = *(_xpc_connection_s **)(a1 + 40);
      if (v38) {
        xpc_connection_send_message(v38, (xpc_object_t)v80[5]);
      }
      goto LABEL_73;
    }
    CFStringRef v31 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      long long v92 = v29;
      __int16 v93 = 2112;
      long long v94 = v26;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Using %@ from %@ to perform id query.", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      MarcoLogMadridLevel();
      uint64_t v51 = v29;
      __int16 v56 = v26;
      IMLogString();
      if (_IMWillLog())
      {
        uint64_t v51 = v29;
        __int16 v56 = v26;
        _IMAlwaysLog();
      }
    }
    id v64 = sub_100133334(v71, v26);
    uint64_t v63 = [v26 _registrationCert];
    if ([v64 count] && v63)
    {
      id v32 = +[IMSystemMonitor sharedInstance];
      unsigned int v33 = [v32 isUnderFirstDataProtectionLock];

      if (!v33)
      {
        v75[0] = _NSConcreteStackBlock;
        v75[1] = 3221225472;
        v75[2] = sub_100342C00;
        v75[3] = &unk_100989668;
        uint64_t v78 = &v79;
        id v41 = v66;
        id v76 = v41;
        id v77 = *(id *)(a1 + 40);
        id v60 = objc_retainBlock(v75);
        v73[0] = _NSConcreteStackBlock;
        v73[1] = 3221225472;
        v73[2] = sub_100343064;
        void v73[3] = &unk_10097E990;
        id v42 = v41;
        id v74 = v42;
        uint64_t v61 = objc_msgSend(v64, "__imArrayByApplyingBlock:", v73);
        if (v67)
        {
          id v43 = +[IDSServerBag sharedInstanceForBagType:0];
          __int16 v44 = [v43 objectForKey:@"vc-disable-springboard-queries"];
          unsigned int v68 = [v44 BOOLValue];
        }
        else
        {
          unsigned int v68 = 0;
        }
        __int16 v46 = +[IDSIDStatusQueryController sharedInstance];
        id v47 = +[IDSURI URIWithUnprefixedURI:v29 withServiceLoggingHint:v42];
        __int16 v48 = sub_10034198C(@"RemoteDevice", *(void **)(a1 + 40));
        [v46 remoteDevicesForIDs:v61 fromIdentity:v63 fromURI:v47 fromService:v42 lightQuery:1 allowQuery:(v68 | v62) ^ 1 reason:v48 completionBlock:v60];

        id v35 = v76;
        goto LABEL_72;
      }
      id v34 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        long long v92 = v4;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Querying %@ while under first unlock, bailing...", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        MarcoLogMadridLevel();
        IMLogString();
        uint64_t v51 = v4;
        _IMWarn();
      }
      if (v71)
      {
        uint64_t v87 = IDSIDQueryControllerErrorDestinationSet;
        long long v88 = v71;
        id v35 = +[NSDictionary dictionaryWithObjects:&v88 forKeys:&v87 count:1];
      }
      else
      {
        id v35 = 0;
      }
      __int16 v54 = +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", IDSIDQueryControllerErrorDomain, -4000, v35, v51, v56);
      IMInsertKeyedCodableObjectsToXPCDictionary();

      CFStringRef v45 = *(_xpc_connection_s **)(a1 + 40);
      if (!v45) {
        goto LABEL_72;
      }
    }
    else
    {
      __int16 v40 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        long long v92 = v4;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "No URIs or cert after filtering destinations %@, bailing...", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        MarcoLogMadridLevel();
        IMLogString();
        uint64_t v51 = v4;
        _IMWarn();
      }
      if (v71)
      {
        uint64_t v89 = IDSIDQueryControllerErrorDestinationSet;
        long long v90 = v71;
        id v35 = +[NSDictionary dictionaryWithObjects:&v90 forKeys:&v89 count:1];
      }
      else
      {
        id v35 = 0;
      }
      id v53 = +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", IDSIDQueryControllerErrorDomain, -3000, v35, v51, v56);
      IMInsertKeyedCodableObjectsToXPCDictionary();

      CFStringRef v45 = *(_xpc_connection_s **)(a1 + 40);
      if (!v45) {
        goto LABEL_72;
      }
    }
    xpc_connection_send_message(v45, (xpc_object_t)v80[5]);
LABEL_72:

LABEL_73:
    goto LABEL_74;
  }
  id v39 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "Could not create reply message for cached id status query", buf, 2u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    MarcoLogMadridLevel();
    IMLogString();
    _IMWarn();
  }
LABEL_74:
  _Block_object_dispose(&v79, 8);
}

void sub_100342A80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
}

id sub_100342BF0(id a1, NSString *a2)
{
  return +[IDSURI URIWithUnprefixedURI:a2];
}

void sub_100342C00(uint64_t a1, void *a2, void *a3, void *a4, int a5, void *a6)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a4;
  id v14 = a6;
  uint64_t v15 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v16 = @"NO";
    if (a5) {
      CFStringRef v17 = @"YES";
    }
    else {
      CFStringRef v17 = @"NO";
    }
    if (*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40)) {
      CFStringRef v16 = @"YES";
    }
    *(_DWORD *)buf = 138413570;
    id v28 = v11;
    __int16 v29 = 2112;
    id v30 = v12;
    __int16 v31 = 2112;
    id v32 = v13;
    __int16 v33 = 2112;
    CFStringRef v34 = v17;
    __int16 v35 = 2112;
    id v36 = v14;
    __int16 v37 = 2112;
    CFStringRef v38 = v16;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Received status query updates (idStatusUpdates: %@)  (updateFromURI: %@)  (updateService: %@)  (success: %@)  (error: %@) - replyMessage? %@", buf, 0x3Eu);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    MarcoLogMadridLevel();
    IMLogString();
    if (_IMWillLog()) {
      _IMAlwaysLog();
    }
  }
  if (*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40))
  {
    int v18 = +[NSKeyedArchiver archivedDataWithRootObject:v11 requiringSecureCoding:0 error:0];
    IMInsertDatasToXPCDictionary();
    IMInsertKeyedCodableObjectsToXPCDictionary();
    __int16 v19 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v20 = IDSLoggableDescriptionForObjectOnService();
      *(_DWORD *)buf = 138412290;
      id v28 = v20;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Sending id status results %@", buf, 0xCu);
    }
    if (os_log_shim_legacy_logging_enabled())
    {
      id v21 = IDSLoggableDescriptionForObjectOnService();
      MarcoLogMadridLevel();

      uint64_t v25 = IDSLoggableDescriptionForObjectOnService();
      IMLogString();

      if (_IMWillLog())
      {
        id v26 = IDSLoggableDescriptionForObjectOnService();
        _IMAlwaysLog();
      }
    }
    unsigned int v22 = *(_xpc_connection_s **)(a1 + 40);
    if (v22) {
      xpc_connection_send_message(v22, *(xpc_object_t *)(*(void *)(*(void *)(a1 + 48) + 8) + 40));
    }
    uint64_t v23 = *(void *)(*(void *)(a1 + 48) + 8);
    uint64_t v24 = *(void **)(v23 + 40);
    *(void *)(v23 + 40) = 0;
  }
}

IDSURI *sub_100343064(uint64_t a1, uint64_t a2)
{
  return +[IDSURI URIWithUnprefixedURI:a2 withServiceLoggingHint:*(void *)(a1 + 32)];
}

void sub_10034307C(id a1)
{
  uint64_t v1 = objc_alloc_init(IDSStatusQueryQueue);
  uint64_t v2 = qword_100A4C7B0;
  qword_100A4C7B0 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_1003430B8(uint64_t a1)
{
  uint64_t v84 = 0;
  uint64_t v85 = &v84;
  uint64_t v86 = 0x3032000000;
  uint64_t v87 = sub_1003413C0;
  long long v88 = sub_1003413D0;
  id reply = (id)0xAAAAAAAAAAAAAAAALL;
  id reply = xpc_dictionary_create_reply(*(xpc_object_t *)(a1 + 32));
  if (v85[5])
  {
    id v77 = IMGetXPCStringFromDictionary();
    uint64_t v2 = IMGetXPCStringFromDictionary();
    id v3 = +[IDSDestination classesForStrictUnarchiving];
    uint64_t v4 = IMGetXPCKeyedCodableFromDictionaryWithSecureCodingAllowedClasses();

    uint64_t v65 = IMGetXPCIntFromDictionary();
    objc_opt_class();
    id v74 = IMGetXPCKeyedCodableFromDictionaryWithSecureCoding();
    unsigned __int8 v73 = IMGetXPCStringFromDictionary();
    int v70 = IMGetXPCBoolFromDictionary();
    unsigned __int8 v64 = [v74 waitForReply];
    double v5 = [v4 destinationURIs];
    id v76 = [v5 allObjects];

    double v6 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      id v7 = [v4 destinationURIs];
      CFStringRef v8 = [v7 allObjects];
      uint64_t v9 = IDSLoggableDescriptionForHandlesOnService();
      uint64_t v10 = (void *)v9;
      CFStringRef v11 = @"NO";
      *(_DWORD *)buf = 138413058;
      __int16 v97 = v2;
      if (v70) {
        CFStringRef v11 = @"YES";
      }
      __int16 v98 = 2112;
      id v99 = v77;
      __int16 v100 = 2112;
      uint64_t v101 = v9;
      __int16 v102 = 2112;
      CFStringRef v103 = v11;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "*** Incoming ID status query  (service: %@)  (transactionID: %@)  (destinations: %@)   (sb: %@)", buf, 0x2Au);
    }
    if (os_log_shim_legacy_logging_enabled())
    {
      id v12 = [v4 destinationURIs];
      id v13 = [v12 allObjects];
      uint64_t v14 = IDSLoggableDescriptionForHandlesOnService();
      uint64_t v15 = (void *)v14;
      CFStringRef v16 = v70 ? @"YES" : @"NO";
      uint64_t v61 = v14;
      MarcoLogMadridLevel();

      CFStringRef v17 = objc_msgSend(v4, "destinationURIs", v2, v77, v61, v16);
      int v18 = [v17 allObjects];
      id v60 = IDSLoggableDescriptionForHandlesOnService();
      int v62 = v16;
      IMLogString();

      if (_IMWillLog())
      {
        __int16 v19 = objc_msgSend(v4, "destinationURIs", v2, v77, v60, v16);
        CFStringRef v20 = [v19 allObjects];
        id v60 = IDSLoggableDescriptionForHandlesOnService();
        int v62 = v16;
        _IMAlwaysLog();
      }
    }
    IMInsertNSStringsToXPCDictionary();
    IMInsertNSStringsToXPCDictionary();
    int v75 = +[IDSURI URIWithUnprefixedURI:](IDSURI, "URIWithUnprefixedURI:", v73, v77, 0);
    id v21 = +[IDSDServiceController sharedInstance];
    unsigned int v22 = [v21 serviceWithIdentifier:v2];

    uint64_t v69 = [v22 queryService];
    uint64_t v23 = +[IDSDAccountController sharedInstance];
    uint64_t v72 = [v23 accountsOnService:v22];

    uint64_t v24 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      __int16 v97 = v22;
      __int16 v98 = 2112;
      id v99 = v2;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Found service %@ for serviceName %@", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      MarcoLogMadridLevel();
      uint64_t v51 = v22;
      uint64_t v58 = v2;
      IMLogString();
      if (_IMWillLog())
      {
        uint64_t v51 = v22;
        uint64_t v58 = v2;
        _IMAlwaysLog();
      }
    }
    unsigned int v68 = objc_msgSend(v76, "__imArrayByApplyingBlock:", &stru_1009896A8, v51, v58, v60, v62);
    uint64_t v25 = +[IDSQueryUtilities accountToQueryFrom:fromURI:destinationURIs:allowLocalAccount:](IDSQueryUtilities, "accountToQueryFrom:fromURI:destinationURIs:allowLocalAccount:", v72, v75);
    if (!v25)
    {
      id v26 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        __int16 v97 = v2;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "No registered account for service %@", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        MarcoLogMadridLevel();
        unsigned __int8 v52 = v2;
        IMLogString();
        if (_IMWillLog())
        {
          unsigned __int8 v52 = v2;
          _IMAlwaysLog();
        }
      }
    }
    uint64_t v27 = +[IDSQueryUtilities prefixedAliasStringToQueryFrom:withPreferredFromURI:](IDSQueryUtilities, "prefixedAliasStringToQueryFrom:withPreferredFromURI:", v25, v75, v52);
    id v28 = v27;
    if (!v25) {
      goto LABEL_46;
    }
    if (![v27 length])
    {
      __int16 v29 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        __int16 v97 = v25;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "No fromURI for account %@", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        MarcoLogMadridLevel();
        id v53 = v25;
        IMLogString();
        if (_IMWillLog())
        {
          id v53 = v25;
          _IMAlwaysLog();
        }
      }
    }
    if (!objc_msgSend(v28, "length", v53))
    {
LABEL_46:
      id v36 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        __int16 v97 = v2;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "No registered account for service after if %@, bailing...", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        MarcoLogMadridLevel();
        id v53 = v2;
        IMLogString();
        if (_IMWillLog())
        {
          id v53 = v2;
          _IMAlwaysLog();
        }
      }
      uint64_t v90 = IDSIDQueryControllerErrorDestinationSet;
      long long v91 = v76;
      __int16 v37 = +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v91, &v90, 1, v53);
      CFStringRef v55 = +[NSError errorWithDomain:IDSIDQueryControllerErrorDomain code:-3000 userInfo:v37];
      IMInsertKeyedCodableObjectsToXPCDictionary();

      CFStringRef v38 = *(_xpc_connection_s **)(a1 + 40);
      if (v38) {
        xpc_connection_send_message(v38, (xpc_object_t)v85[5]);
      }
      goto LABEL_69;
    }
    id v30 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      __int16 v97 = v28;
      __int16 v98 = 2112;
      id v99 = v25;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Using %@ from %@ to perform id query.", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      MarcoLogMadridLevel();
      id v53 = v28;
      id v59 = v25;
      IMLogString();
      if (_IMWillLog())
      {
        id v53 = v28;
        id v59 = v25;
        _IMAlwaysLog();
      }
    }
    int v67 = sub_100133334(v76, v25);
    CFStringRef v66 = [v25 _registrationCert];
    if ([v67 count] && v66)
    {
      __int16 v31 = +[IMSystemMonitor sharedInstance];
      unsigned int v32 = [v31 isUnderFirstDataProtectionLock];

      if (!v32)
      {
        v80[0] = _NSConcreteStackBlock;
        v80[1] = 3221225472;
        v80[2] = sub_10034427C;
        v80[3] = &unk_100989668;
        unsigned __int8 v83 = &v84;
        id v43 = v69;
        id v81 = v43;
        id v82 = *(id *)(a1 + 40);
        __int16 v44 = objc_retainBlock(v80);
        v78[0] = _NSConcreteStackBlock;
        v78[1] = 3221225472;
        v78[2] = sub_1003446E0;
        v78[3] = &unk_10097E990;
        id v45 = v43;
        id v79 = v45;
        uint64_t v63 = objc_msgSend(v67, "__imArrayByApplyingBlock:", v78);
        if (v70)
        {
          __int16 v46 = +[IDSServerBag sharedInstanceForBagType:0];
          id v47 = [v46 objectForKey:@"vc-disable-springboard-queries"];
          unsigned __int8 v71 = [v47 BOOLValue];
        }
        else
        {
          unsigned __int8 v71 = 0;
        }
        __int16 v48 = +[IDSIDStatusQueryController sharedInstance];
        CFStringRef v49 = +[IDSURI URIWithUnprefixedURI:v28 withServiceLoggingHint:v45];
        unsigned int v50 = sub_10034198C(@"InfoQuery", *(void **)(a1 + 40));
        BYTE1(v57) = (v71 | v64) ^ 1;
        LOBYTE(v57) = 1;
        objc_msgSend(v48, "infoForIDs:fromIdentity:fromURI:fromService:infoType:infoOptions:lightQuery:allowQuery:reason:completion:", v63, v66, v49, v45, v65, v74, v57, v50, v44);

        goto LABEL_68;
      }
      __int16 v33 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        __int16 v97 = v4;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Querying %@ while under first unlock, bailing...", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        MarcoLogMadridLevel();
        IMLogString();
        id v53 = v4;
        _IMWarn();
      }
      CFStringRef v34 = v76;
      if (!v76) {
        CFStringRef v34 = &__NSArray0__struct;
      }
      uint64_t v92 = IDSIDQueryControllerErrorDestinationSet;
      __int16 v93 = v34;
      __int16 v35 = +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v93, &v92, 1, v53, v59);
      __int16 v54 = +[NSError errorWithDomain:IDSIDQueryControllerErrorDomain code:-4000 userInfo:v35];
      IMInsertKeyedCodableObjectsToXPCDictionary();
    }
    else
    {
      __int16 v40 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        __int16 v97 = v4;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "No URIs or cert after filtering destinations %@, bailing...", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        MarcoLogMadridLevel();
        IMLogString();
        id v53 = v4;
        _IMWarn();
      }
      uint64_t v94 = IDSIDQueryControllerErrorDestinationSet;
      __int16 v95 = v76;
      id v41 = +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v95, &v94, 1, v53, v59);
      __int16 v56 = +[NSError errorWithDomain:IDSIDQueryControllerErrorDomain code:-3000 userInfo:v41];
      IMInsertKeyedCodableObjectsToXPCDictionary();
    }
    id v42 = *(_xpc_connection_s **)(a1 + 40);
    if (v42) {
      xpc_connection_send_message(v42, (xpc_object_t)v85[5]);
    }
LABEL_68:

LABEL_69:
    goto LABEL_70;
  }
  id v39 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "Could not create reply message for cached id status query", buf, 2u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    MarcoLogMadridLevel();
    IMLogString();
    _IMWarn();
  }
LABEL_70:
  _Block_object_dispose(&v84, 8);
}

void sub_1003440FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
}

id sub_10034426C(id a1, NSString *a2)
{
  return +[IDSURI URIWithUnprefixedURI:a2];
}

void sub_10034427C(uint64_t a1, void *a2, void *a3, void *a4, int a5, void *a6)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a4;
  id v14 = a6;
  uint64_t v15 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v16 = @"NO";
    if (a5) {
      CFStringRef v17 = @"YES";
    }
    else {
      CFStringRef v17 = @"NO";
    }
    if (*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40)) {
      CFStringRef v16 = @"YES";
    }
    *(_DWORD *)buf = 138413570;
    id v28 = v11;
    __int16 v29 = 2112;
    id v30 = v12;
    __int16 v31 = 2112;
    id v32 = v13;
    __int16 v33 = 2112;
    CFStringRef v34 = v17;
    __int16 v35 = 2112;
    id v36 = v14;
    __int16 v37 = 2112;
    CFStringRef v38 = v16;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Received status query updates (idStatusUpdates: %@)  (updateFromURI: %@)  (updateService: %@)  (success: %@)  (error: %@) - replyMessage? %@", buf, 0x3Eu);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    MarcoLogMadridLevel();
    IMLogString();
    if (_IMWillLog()) {
      _IMAlwaysLog();
    }
  }
  if (*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40))
  {
    int v18 = +[NSKeyedArchiver archivedDataWithRootObject:v11 requiringSecureCoding:0 error:0];
    IMInsertDatasToXPCDictionary();
    IMInsertKeyedCodableObjectsToXPCDictionary();
    __int16 v19 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v20 = IDSLoggableDescriptionForObjectOnService();
      *(_DWORD *)buf = 138412290;
      id v28 = v20;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Sending id status results %@", buf, 0xCu);
    }
    if (os_log_shim_legacy_logging_enabled())
    {
      id v21 = IDSLoggableDescriptionForObjectOnService();
      MarcoLogMadridLevel();

      uint64_t v25 = IDSLoggableDescriptionForObjectOnService();
      IMLogString();

      if (_IMWillLog())
      {
        id v26 = IDSLoggableDescriptionForObjectOnService();
        _IMAlwaysLog();
      }
    }
    unsigned int v22 = *(_xpc_connection_s **)(a1 + 40);
    if (v22) {
      xpc_connection_send_message(v22, *(xpc_object_t *)(*(void *)(*(void *)(a1 + 48) + 8) + 40));
    }
    uint64_t v23 = *(void *)(*(void *)(a1 + 48) + 8);
    uint64_t v24 = *(void **)(v23 + 40);
    *(void *)(v23 + 40) = 0;
  }
}

IDSURI *sub_1003446E0(uint64_t a1, uint64_t a2)
{
  return +[IDSURI URIWithUnprefixedURI:a2 withServiceLoggingHint:*(void *)(a1 + 32)];
}

void sub_100345B7C(uint64_t a1)
{
  memset_s(*(void **)(a1 + 32), 0x10uLL, 0, 0x10uLL);
  uint64_t v2 = *(void **)(a1 + 32);

  free(v2);
}

void sub_100346F18(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog delivery_oversized];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    int v5 = 138412546;
    uint64_t v6 = v3;
    __int16 v7 = 2112;
    uint64_t v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "GUID %@ Tokens for URI:\n%@", (uint8_t *)&v5, 0x16u);
  }
}

void sub_100346FD4(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog delivery_oversized];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    int v5 = 138412546;
    uint64_t v6 = v3;
    __int16 v7 = 2112;
    uint64_t v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "GUID %@ Skipped Destinations:\n%@", (uint8_t *)&v5, 0x16u);
  }
}

uint64_t sub_100347A3C(uint64_t a1, void *a2)
{
  uint64_t v9 = 0;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2020000000;
  uint64_t v12 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_100347B1C;
  v5[3] = &unk_10097EE00;
  __int16 v7 = &v9;
  uint64_t v8 = a1;
  id v2 = a2;
  id v6 = v2;
  sub_1003E5B1C(v5, v2);
  uint64_t v3 = v10[3];

  _Block_object_dispose(&v9, 8);
  return v3;
}

void sub_100347B04(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_100347B1C(uint64_t a1)
{
  if (*(void *)(a1 + 48))
  {
    CSDBRecordStoreAddRecord();
    if (CSDBRecordSaveStore())
    {
      uint64_t Database = CSDBRecordStoreGetDatabase();
      CSDBRecordIndexOfPropertyNamed();
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = CSDBRecordCopyProperty();
      if (Database)
      {
        if (_IMWillLog()) {
          _IMAlwaysLog();
        }
        int ID = CSDBRecordGetID();
        uint64_t v4 = sub_100348244((uint64_t)kCFAllocatorDefault, ID, 0, *(void **)(a1 + 32));
        if (v4)
        {
          CFRelease(v4);
        }
      }
    }
  }
}

uint64_t sub_100347C18(uint64_t a1, const __CFString *a2, int a3, void *a4)
{
  id v7 = a4;
  if (a1)
  {
    if (a2 && a3 && CFStringGetLength(a2))
    {
      if (_IMWillLog()) {
        _IMAlwaysLog();
      }
      uint64_t v14 = 0;
      uint64_t v15 = &v14;
      uint64_t v16 = 0x2020000000;
      uint64_t v17 = 0;
      v9[0] = _NSConcreteStackBlock;
      v9[1] = 3221225472;
      v9[2] = sub_100347D6C;
      v9[3] = &unk_1009898D8;
      CFStringRef v12 = a2;
      uint64_t v13 = a1;
      uint64_t v11 = &v14;
      id v10 = v7;
      sub_1003E5C84(@"SELECT ROWID, guid, topic, from_id, message_data, date, is_local, message_identifier, expiration_date, control_category FROM incoming_message WHERE message_identifier = ? ", v9, v10);
      a1 = v15[3];

      _Block_object_dispose(&v14, 8);
    }
    else
    {
      a1 = sub_100347A3C(a1, v7);
    }
  }

  return a1;
}

void sub_100347D54(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_100347D6C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CSDBSqliteBindTextFromCFString();
  CFArrayRef v5 = (const __CFArray *)CSDBRecordStoreProcessStatement();
  if (CFArrayGetCount(v5) || !*(void *)(a1 + 56))
  {
    CFArrayGetValueAtIndex(v5, 0);
    CSDBRecordIndexOfPropertyNamed();
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = CSDBRecordCopyProperty();
    id v6 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 48);
      uint64_t v8 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
      *(_DWORD *)buf = 138412546;
      uint64_t v12 = v7;
      __int16 v13 = 2112;
      uint64_t v14 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "IDSIncomingMessageRecordAddMessageRecordDedup deduped message with identifier %@. Will use storage guid %@", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
  }
  else
  {
    CSDBRecordStoreAddRecord();
    if (CSDBRecordSaveStore())
    {
      CSDBRecordIndexOfPropertyNamed();
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = CSDBRecordCopyProperty();
      if (a3)
      {
        if (_IMWillLog()) {
          _IMAlwaysLog();
        }
        int ID = CSDBRecordGetID();
        id v10 = sub_100348244((uint64_t)kCFAllocatorDefault, ID, 0, *(void **)(a1 + 32));
        if (v10) {
          CFRelease(v10);
        }
      }
    }
  }
  if (v5) {
    CFRelease(v5);
  }
}

void *sub_100347FD4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, const __CFString *a8, int a9, unsigned __int8 a10, void *a11, void *a12)
{
  id v12 = a12;
  pthread_once(&stru_100A44160, (void (*)(void))sub_10034964C);
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v14 = (void *)Instance;
  if (Instance)
  {
    *(void *)(Instance + 16) = 0;
    *(void *)(Instance + 24) = 0;
    *(_DWORD *)(Instance + 16) = 0;
    id v15 = v12;
    if (_IMWillLog()) {
      _IMAlwaysLog();
    }
    [v15 ensureDatabaseIsInitialized];
    uint64_t v16 = (const void *)CSDBRecordCreate();

    if (v16)
    {
      id v21 = v12;
      for (uint64_t i = 0; i != 9; ++i)
      {
        if (_IMWillLog()) {
          _IMAlwaysLog();
        }
        CSDBRecordSetProperty();
      }
      uint64_t v18 = sub_100347C18((uint64_t)v16, a8, a10, v15);
      if (v18)
      {
        __int16 v19 = (const void *)v18;
        v14[3] = (int)CSDBRecordGetID();
        id v12 = v21;
        if (a11) {
          *a11 = v19;
        }
        else {
          CFRelease(v19);
        }
        if (_IMWillLog()) {
          _IMAlwaysLog();
        }
      }
      else
      {
        CFRelease(v14);
        uint64_t v14 = 0;
        id v12 = v21;
      }
      CFRelease(v16);
    }
    else
    {
      CFRelease(v14);
      uint64_t v14 = 0;
    }
  }

  return v14;
}

const void *sub_100348244(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  id v6 = a4;
  pthread_once(&stru_100A44160, (void (*)(void))sub_10034964C);
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v8 = (const void *)Instance;
    *(void *)(Instance + 16) = 0;
    *(void *)(Instance + 24) = a2;
    *(_DWORD *)(Instance + 16) = 0;
    if (a3) {
      uint64_t v9 = (const void *)sub_1003482F8(a2, v6);
    }
    else {
      uint64_t v9 = (const void *)sub_10034840C(a2, v6);
    }
    if (v9)
    {
      id v10 = v8;
    }
    else
    {
      uint64_t v9 = v8;
      id v10 = 0;
    }
    CFRelease(v9);
  }
  else
  {
    id v10 = 0;
  }

  return v10;
}

uint64_t sub_1003482F8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2020000000;
  uint64_t v10 = 0;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_1003483C8;
  v6[3] = &unk_10097EEC8;
  void v6[4] = &v7;
  void v6[5] = a1;
  sub_1003E5B1C(v6, v3);
  uint64_t v4 = v8[3];
  _Block_object_dispose(&v7, 8);

  return v4;
}

void sub_1003483B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1003483C8(uint64_t a1)
{
  uint64_t result = CSDBRecordStoreCopyInstanceOfClassWithUID();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t sub_10034840C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2020000000;
  uint64_t v10 = 0;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_1003484DC;
  v6[3] = &unk_10097EEC8;
  void v6[4] = &v7;
  void v6[5] = a1;
  sub_1003E5B94(v6, v3);
  uint64_t v4 = v8[3];
  _Block_object_dispose(&v7, 8);

  return v4;
}

void sub_1003484C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1003484DC(uint64_t a1)
{
  uint64_t result = CSDBRecordStoreCopyInstanceOfClassWithUID();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

void sub_100348520(const __CFString *a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (_IMWillLog()) {
    _IMAlwaysLog();
  }
  if (a1 && CFStringGetLength(a1))
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    v6[2] = sub_1003485F8;
    v6[3] = &unk_1009898F8;
    void v6[4] = a2;
    void v6[5] = a1;
    sub_1003E5D0C(@"UPDATE incoming_message SET expiration_date = ?WHERE guid = ? ;", v6, v5);
  }
}

uint64_t sub_1003485F8()
{
  CSDBSqliteBindInt64();
  CSDBSqliteBindTextFromCFString();

  return CSDBSqliteStatementPerform();
}

uint64_t sub_100348648(void *a1)
{
  id v1 = a1;
  uint64_t v5 = 0;
  id v6 = &v5;
  uint64_t v7 = 0x2020000000;
  uint64_t v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_100348714;
  v4[3] = &unk_10097EF68;
  void v4[4] = &v5;
  sub_1003E5C0C(v4, v1);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);

  return v2;
}

void sub_1003486FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100348714(uint64_t a1)
{
  uint64_t result = CSDBSqliteDatabaseStatementForReading();
  if (result && *(void *)(result + 8))
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CSDBSqliteStatementCopyAllRowsStringsForColumnsAtIndices();
    return CSDBSqliteStatementReset();
  }
  return result;
}

uint64_t sub_100348790(uint64_t a1, uint64_t a2, void *a3, unsigned char *a4)
{
  uint64_t v18 = 0;
  __int16 v19 = &v18;
  uint64_t v20 = 0x2020000000;
  uint64_t v21 = 0;
  uint64_t v14 = 0;
  id v15 = &v14;
  uint64_t v16 = 0x2020000000;
  char v17 = 1;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1003488C8;
  v8[3] = &unk_100989920;
  uint64_t v12 = a2;
  uint64_t v13 = a1;
  id v5 = a3;
  id v9 = v5;
  uint64_t v10 = &v18;
  uint64_t v11 = &v14;
  sub_1003E5C0C(v8, v5);
  if (a4) {
    *a4 = *((unsigned char *)v15 + 24);
  }
  uint64_t v6 = v19[3];

  _Block_object_dispose(&v14, 8);
  _Block_object_dispose(&v18, 8);

  return v6;
}

void sub_1003488A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1003488C8(uint64_t a1)
{
  uint64_t v2 = CSDBSqliteDatabaseStatementForReading();
  if (v2 && *(void *)(v2 + 8))
  {
    CSDBSqliteBindInt64();
    CSDBSqliteBindInt64();
    CFArrayRef v3 = (const __CFArray *)CSDBRecordStoreProcessStatement();
    CFIndex Count = CFArrayGetCount(v3);
    if ((int)Count >= 1)
    {
      CFIndex v5 = (int)Count;
      uint64_t v6 = Count;
      uint64_t v7 = (Count << 32) - 0x100000000;
      while (1)
      {
        CFArrayGetValueAtIndex(v3, v7 >> 32);
        int ID = CSDBRecordGetID();
        id v9 = sub_100348244((uint64_t)kCFAllocatorDefault, ID, 0, *(void **)(a1 + 32));
        uint64_t v10 = v9;
        if (!*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
          break;
        }
        if (v9) {
          goto LABEL_7;
        }
LABEL_8:
        v7 -= 0x100000000;
        if (!--v6) {
          goto LABEL_13;
        }
      }
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = CFArrayCreateMutable(kCFAllocatorDefault, v5, &kCFTypeArrayCallBacks);
      if (!v10) {
        goto LABEL_8;
      }
LABEL_7:
      CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), v10);
      CFRelease(v10);
      goto LABEL_8;
    }
LABEL_13:
    CSDBSqliteStatementReset();
    if (v3)
    {
      CFRelease(v3);
    }
  }
  else
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
  }
}

uint64_t sub_100348A6C(uint64_t a1, void *a2, unsigned char *a3)
{
  uint64_t v16 = 0;
  char v17 = &v16;
  uint64_t v18 = 0x2020000000;
  uint64_t v19 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2020000000;
  char v15 = 1;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_100348B98;
  v7[3] = &unk_100989948;
  uint64_t v11 = a1;
  id v4 = a2;
  id v8 = v4;
  id v9 = &v16;
  uint64_t v10 = &v12;
  sub_1003E5C0C(v7, v4);
  if (a3) {
    *a3 = *((unsigned char *)v13 + 24);
  }
  uint64_t v5 = v17[3];

  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(&v16, 8);

  return v5;
}

void sub_100348B74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_100348B98(uint64_t a1)
{
  uint64_t v2 = CSDBSqliteDatabaseStatementForReading();
  if (v2 && *(void *)(v2 + 8))
  {
    CSDBSqliteBindInt64();
    CFArrayRef v3 = (const __CFArray *)CSDBRecordStoreProcessStatement();
    CFIndex Count = CFArrayGetCount(v3);
    if ((int)Count >= 1)
    {
      CFIndex v5 = (int)Count;
      uint64_t v6 = Count;
      uint64_t v7 = (Count << 32) - 0x100000000;
      while (1)
      {
        CFArrayGetValueAtIndex(v3, v7 >> 32);
        int ID = CSDBRecordGetID();
        uint64_t v9 = sub_100348244((uint64_t)kCFAllocatorDefault, ID, 0, *(void **)(a1 + 32));
        uint64_t v10 = v9;
        if (!*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
          break;
        }
        if (v9) {
          goto LABEL_7;
        }
LABEL_8:
        v7 -= 0x100000000;
        if (!--v6) {
          goto LABEL_13;
        }
      }
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = CFArrayCreateMutable(kCFAllocatorDefault, v5, &kCFTypeArrayCallBacks);
      if (!v10) {
        goto LABEL_8;
      }
LABEL_7:
      CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), v10);
      CFRelease(v10);
      goto LABEL_8;
    }
LABEL_13:
    CSDBSqliteStatementReset();
    if (v3)
    {
      CFRelease(v3);
    }
  }
  else
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
  }
}

uint64_t sub_100348D30(uint64_t a1, int a2, uint64_t a3, void *a4, unsigned char *a5)
{
  uint64_t v20 = 0;
  uint64_t v21 = &v20;
  uint64_t v22 = 0x2020000000;
  uint64_t v23 = 0;
  uint64_t v16 = 0;
  char v17 = &v16;
  uint64_t v18 = 0x2020000000;
  char v19 = 1;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  v9[2] = sub_100348E70;
  v9[3] = &unk_100989970;
  int v15 = a2;
  uint64_t v13 = a3;
  uint64_t v14 = a1;
  id v6 = a4;
  id v10 = v6;
  uint64_t v11 = &v20;
  uint64_t v12 = &v16;
  sub_1003E5C0C(v9, v6);
  if (a5) {
    *a5 = *((unsigned char *)v17 + 24);
  }
  uint64_t v7 = v21[3];

  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(&v20, 8);

  return v7;
}

void sub_100348E4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_100348E70(uint64_t a1)
{
  uint64_t v2 = CSDBSqliteDatabaseStatementForReading();
  if (v2 && *(void *)(v2 + 8))
  {
    CSDBSqliteBindInt64();
    CSDBSqliteBindInt();
    CSDBSqliteBindInt64();
    CFArrayRef v3 = (const __CFArray *)CSDBRecordStoreProcessStatement();
    CFIndex Count = CFArrayGetCount(v3);
    if ((int)Count >= 1)
    {
      CFIndex v5 = (int)Count;
      uint64_t v6 = Count;
      uint64_t v7 = (Count << 32) - 0x100000000;
      while (1)
      {
        CFArrayGetValueAtIndex(v3, v7 >> 32);
        int ID = CSDBRecordGetID();
        uint64_t v9 = sub_100348244((uint64_t)kCFAllocatorDefault, ID, 0, *(void **)(a1 + 32));
        id v10 = v9;
        if (!*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
          break;
        }
        if (v9) {
          goto LABEL_7;
        }
LABEL_8:
        v7 -= 0x100000000;
        if (!--v6) {
          goto LABEL_13;
        }
      }
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = CFArrayCreateMutable(kCFAllocatorDefault, v5, &kCFTypeArrayCallBacks);
      if (!v10) {
        goto LABEL_8;
      }
LABEL_7:
      CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), v10);
      CFRelease(v10);
      goto LABEL_8;
    }
LABEL_13:
    CSDBSqliteStatementReset();
    if (v3)
    {
      CFRelease(v3);
    }
  }
  else
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
  }
}

void sub_100349020(const __CFString *a1, void *a2)
{
  id v3 = a2;
  if (_IMWillLog()) {
    _IMAlwaysLog();
  }
  if (a1 && CFStringGetLength(a1))
  {
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472;
    v4[2] = sub_1003490EC;
    v4[3] = &unk_10097F2A0;
    void v4[4] = a1;
    sub_1003E5C84(@"SELECT ROWID, guid, topic, from_id, message_data, date, is_local, message_identifier, expiration_date, control_category FROM incoming_message WHERE guid = ? ORDER BY ROWID ASC;",
      v4,
      v3);
  }
}

uint64_t sub_1003490EC(uint64_t a1, uint64_t a2)
{
  CSDBSqliteBindTextFromCFString();
  CFArrayRef v3 = (const __CFArray *)CSDBRecordStoreProcessStatement();
  int Count = CFArrayGetCount(v3);
  if (Count >= 1)
  {
    CFIndex v5 = 0;
    uint64_t v6 = Count;
    do
    {
      CFArrayGetValueAtIndex(v3, v5);
      CSDBRecordStoreRemoveRecord();
      ++v5;
    }
    while (v6 != v5);
  }
  CFRelease(v3);
  CSDBRecordSaveStore();

  return _CSDBRecordStoreInvalidateCachesWithStore(a2);
}

void sub_1003491A0(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (_IMWillLog()) {
    _IMAlwaysLog();
  }
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_100349268;
  v6[3] = &unk_1009898F8;
  void v6[4] = a1;
  void v6[5] = a2;
  sub_1003E5D0C(@"DELETE FROM incoming_message WHERE date < ? LIMIT ?; ", v6, v5);
}

uint64_t sub_100349268()
{
  CSDBSqliteBindInt64();
  CSDBSqliteBindInt64();

  return CSDBSqliteStatementPerform();
}

void sub_1003492B8(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (_IMWillLog()) {
    _IMAlwaysLog();
  }
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_100349374;
  v4[3] = &unk_10097F2A0;
  void v4[4] = a1;
  sub_1003E5D0C(@"DELETE FROM incoming_message WHERE expiration_date > 0 AND expiration_date < ?; ",
    v4,
    v3);
}

uint64_t sub_100349374()
{
  CSDBSqliteBindInt64();

  return CSDBSqliteStatementPerform();
}

void sub_1003493B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  id v19 = a11;
  uint64_t v20 = v19;
  if (a1)
  {
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 3221225472;
    v21[2] = sub_1003494D4;
    v21[3] = &unk_100989998;
    uint64_t v23 = a1;
    id v22 = v19;
    uint64_t v24 = a2;
    uint64_t v25 = a3;
    uint64_t v26 = a4;
    uint64_t v27 = a5;
    uint64_t v28 = a6;
    uint64_t v29 = a7;
    uint64_t v30 = a8;
    uint64_t v31 = a9;
    uint64_t v32 = a10;
    sub_1003E5A34(a1 + 16, v21, v22);
  }
  else
  {
    _IMWarn();
  }
}

void sub_1003494D4(uint64_t a1)
{
  uint64_t v2 = sub_10034840C(*(void *)(*(void *)(a1 + 40) + 24), *(void **)(a1 + 32));
  if (v2)
  {
    id v3 = (const void *)v2;
    if (*(void *)(a1 + 48)) {
      **(void **)(a1 + 48) = (int)CSDBRecordGetID();
    }
    if (*(void *)(a1 + 56)) {
      **(void **)(a1 + 56) = CSDBRecordCopyProperty();
    }
    if (*(void *)(a1 + 64)) {
      **(void **)(a1 + 64) = CSDBRecordCopyProperty();
    }
    if (*(void *)(a1 + 72)) {
      **(void **)(a1 + 72) = CSDBRecordCopyProperty();
    }
    if (*(void *)(a1 + 80)) {
      **(void **)(a1 + 80) = CSDBRecordCopyProperty();
    }
    if (*(void *)(a1 + 88)) {
      **(void **)(a1 + 88) = CSDBRecordGetProperty();
    }
    if (*(void *)(a1 + 96)) {
      **(unsigned char **)(a1 + 96) = CSDBRecordGetProperty() != 0;
    }
    if (*(void *)(a1 + 104)) {
      **(void **)(a1 + 104) = CSDBRecordGetProperty();
    }
    if (*(void *)(a1 + 112)) {
      **(_DWORD **)(a1 + 112) = CSDBRecordGetProperty();
    }
    CFRelease(v3);
  }
}

uint64_t sub_10034964C()
{
  uint64_t v0 = 0;
  qword_100A4C7E0 = _CFRuntimeRegisterClass();
  id v1 = &off_1009896C8;
  do
  {
    v1 += 5;
    uint64_t result = CSDBRecordIndexOfPropertyNamed();
    dword_100A4C7E8[v0++] = result;
  }
  while (v0 != 9);
  return result;
}

uint64_t sub_1003496BC(uint64_t result)
{
  *(void *)(result + 24) = -1;
  return result;
}

void sub_1003496C8(uint64_t a1)
{
  uint64_t v2 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  *(void *)(a1 + 24) = -1;

  os_unfair_lock_unlock(v2);
}

BOOL sub_100349710(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 24) == *(void *)(a2 + 24);
}

uint64_t sub_100349724(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

CFStringRef sub_10034972C(os_unfair_lock_s *a1)
{
  uint64_t v2 = a1 + 4;
  os_unfair_lock_lock(a1 + 4);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFAllocatorRef v4 = CFGetAllocator(a1);
  CFStringRef v5 = CFStringCreateWithFormat(v3, 0, @"<IDSIncomingMessageRecord %p [%p]>{}", a1, v4);
  os_unfair_lock_unlock(v2);
  return v5;
}

id sub_100349D18(void *a1, void *a2)
{
  id v22 = a1;
  id v3 = a2;
  id v21 = objc_alloc_init((Class)NSMutableArray);
  long long v27 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  id obj = v3;
  id v4 = [obj countByEnumeratingWithState:&v27 objects:v32 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v20 = *(void *)v28;
    do
    {
      for (uint64_t i = 0; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v28 != v20) {
          objc_enumerationMutation(obj);
        }
        uint64_t v7 = *(void *)(*((void *)&v27 + 1) + 8 * i);
        long long v23 = 0u;
        long long v24 = 0u;
        long long v25 = 0u;
        long long v26 = 0u;
        id v8 = v22;
        id v9 = [v8 countByEnumeratingWithState:&v23 objects:v31 count:16];
        if (v9)
        {
          id v10 = v9;
          uint64_t v11 = *(void *)v24;
LABEL_8:
          uint64_t v12 = 0;
          while (1)
          {
            if (*(void *)v24 != v11) {
              objc_enumerationMutation(v8);
            }
            uint64_t v13 = *(void **)(*((void *)&v23 + 1) + 8 * v12);
            uint64_t v14 = [v13 SIMIdentifier];
            unsigned __int8 v15 = [v14 isEqual:v7];

            if (v15) {
              break;
            }
            if (v10 == (id)++v12)
            {
              id v10 = [v8 countByEnumeratingWithState:&v23 objects:v31 count:16];
              if (v10) {
                goto LABEL_8;
              }
              goto LABEL_14;
            }
          }
          uint64_t v16 = +[IDSPhoneSubscription phoneSubscriptionWithSIM:v13];

          if (v16) {
            goto LABEL_17;
          }
        }
        else
        {
LABEL_14:
        }
        uint64_t v16 = +[IDSPhoneSubscription phoneSubscriptionWithLabelID:v7];
LABEL_17:
        [v21 addObject:v16];
      }
      id v5 = [obj countByEnumeratingWithState:&v27 objects:v32 count:16];
    }
    while (v5);
  }

  id v17 = [v21 copy];

  return v17;
}

BOOL sub_10034A21C(id a1, IDSUser *a2)
{
  return [(IDSUser *)a2 hasBeenProvisioned];
}

id sub_10034A224(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = a2;
  id v4 = [v2 userStore];
  id v5 = [v4 propertiesForUser:v3];

  id v6 = objc_alloc((Class)IDSURI);
  uint64_t v7 = [v3 phoneNumber];
  id v8 = [v6 initWithUnprefixedURI:v7];

  id v9 = objc_alloc((Class)IDSPhoneTemporaryAliasDescription);
  id v10 = [v3 expirationDate];

  id v11 = objc_msgSend(v9, "initWithURI:expirationDate:selected:", v8, v10, objc_msgSend(v5, "disableRegistration") ^ 1);

  return v11;
}

id sub_10034A6C0(void *a1, void *a2)
{
  id v3 = a2;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  v11[2] = sub_10034BAF8;
  void v11[3] = &unk_100984228;
  id v12 = v3;
  id v4 = objc_msgSend(a1, "__imArrayByFilteringWithBlock:", v11);
  id v5 = [v4 firstObject];

  id v6 = [v5 SIMIdentifier];
  uint64_t v7 = v6;
  if (v6)
  {
    id v8 = v6;
  }
  else
  {
    id v8 = [v3 labelID];
  }
  id v9 = v8;

  return v9;
}

id sub_10034AF94(uint64_t a1, void *a2)
{
  return sub_10034A6C0(*(void **)(a1 + 32), a2);
}

BOOL sub_10034BAF8(uint64_t a1, void *a2)
{
  [a2 slot];
  id v3 = (id)IDSSubscriptionSlotFromCTSIMSlot();
  return v3 == [*(id *)(a1 + 32) subscriptionSlot];
}

void sub_10034BC74(id a1)
{
  id v1 = objc_alloc_init(IDSPeerIDManager);
  uint64_t v2 = qword_100A4C818;
  qword_100A4C818 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_10034BEB0(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10034BECC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    uint64_t v2 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      int v3 = _os_feature_enabled_impl();
      CFStringRef v4 = @"NO";
      if (v3) {
        CFStringRef v4 = @"YES";
      }
      *(_DWORD *)buf = 138412290;
      CFStringRef v7 = v4;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SwiftDataForQueryCache FF enabled: %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      _os_feature_enabled_impl();
      _IDSLogV();
    }
  }

  return 0;
}

void sub_10034ED24(void *a1, int a2, void *a3)
{
  id v5 = a3;
  if (v5 || !a2)
  {
    id v10 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = a1[4];
      uint64_t v12 = a1[5];
      uint64_t v13 = a1[6];
      *(_DWORD *)buf = 138413058;
      uint64_t v15 = v11;
      __int16 v16 = 2112;
      uint64_t v17 = v12;
      __int16 v18 = 2112;
      id v19 = v5;
      __int16 v20 = 2112;
      uint64_t v21 = v13;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Error saving endpoints to SwiftData DB for service: %@, uri: %@, error: %@, uuid: %@", buf, 0x2Au);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      goto LABEL_12;
    }
  }
  else
  {
    id v6 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = a1[4];
      uint64_t v8 = a1[5];
      id v9 = (void *)a1[6];
      *(_DWORD *)buf = 138412802;
      uint64_t v15 = v7;
      __int16 v16 = 2112;
      uint64_t v17 = v8;
      __int16 v18 = 2112;
      id v19 = v9;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Successfully saved endpoints to SwiftData DB for service: %@, uri: %@, uuid: %@", buf, 0x20u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
LABEL_12:
    }
      _IDSLogV();
  }
}

void sub_10034EF50(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 138412802;
    uint64_t v10 = v8;
    __int16 v11 = 2112;
    id v12 = v5;
    __int16 v13 = 2112;
    id v14 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Triggered auto bug capture for excessive query cache entries for service: %@ {session : %@, error: %@}", buf, 0x20u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
}

void sub_10034F098(id a1, NSArray *a2, NSError *a3)
{
  int v3 = a3;
  if (v3)
  {
    CFStringRef v4 = +[IDSFoundationLog KeyTransparency];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 138412290;
      id v6 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Failed kicking KT peer verification for query { error: %@ }", (uint8_t *)&v5, 0xCu);
    }
  }
}

void sub_10034F150(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) queryCompletionBlock];
  (*((void (**)(id, void, void, void))v2 + 2))(v2, *(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56));
}

void sub_1003521DC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = +[IMRGLog registration];
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(a1 + 32);
    int v9 = 138412802;
    uint64_t v10 = v8;
    __int16 v11 = 2112;
    id v12 = v5;
    __int16 v13 = 2112;
    id v14 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Finished capturing AutoBugCapture diagnostics for differed query cache results { context: %@, sessionID: %@, error: %@ }", (uint8_t *)&v9, 0x20u);
  }
}

double sub_100352F48()
{
  if (qword_100A4C8A8 != -1) {
    dispatch_once(&qword_100A4C8A8, &stru_10098A438);
  }
  return *(double *)&qword_100A4C830 * (double)mach_continuous_time();
}

uint64_t sub_100353B58(uint64_t a1)
{
  id v2 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    uint64_t v6 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%@ called nw_service_connector_cancel_active_connection", buf, 0xCu);
  }

  uint64_t result = os_log_shim_legacy_logging_enabled();
  if (result)
  {
    uint64_t result = _IDSShouldLogTransport();
    if (result)
    {
      _IDSLogTransport();
      uint64_t result = _IDSShouldLog();
      if (result) {
        return _IDSLogV();
      }
    }
  }
  return result;
}

void sub_1003541C0(id a1, BOOL a2)
{
  id v2 = +[IDSUTunController sharedInstance];
  objc_msgSend(v2, "onTransportThread_StopBTDatagramLinkForDefaultPairedDevice");
}

uint64_t sub_100354208(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void, void, uint64_t, void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), 0, 0, 0, 0, 0xFFFFFFFFLL, 0, 0, *(void *)(a1 + 32));
}

void sub_1003549D0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v5 = *(id *)(a1 + 40);
  id v4 = v3;
  IDSTransportThreadAddBlock();
}

id *sub_100354A78(id *result, char a2)
{
  if ((a2 & 1) == 0) {
    return (id *)_[result[4] _triggerStallDetectionLogsForDetector:result[5] withEvent:result[6]];
  }
  return result;
}

void sub_100354A90(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v5 = *(id *)(a1 + 40);
  id v4 = v3;
  IDSTransportThreadAddBlock();
}

uint64_t sub_100354B38(uint64_t result, char a2)
{
  if ((a2 & 1) == 0)
  {
    id v2 = (void *)result;
    id v3 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = v2[4];
      uint64_t v5 = v2[5];
      uint64_t v6 = v2[6];
      *(_DWORD *)buf = 134218498;
      uint64_t v8 = v4;
      __int16 v9 = 2112;
      uint64_t v10 = v5;
      __int16 v11 = 2112;
      uint64_t v12 = v6;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%p %@ Stall warning [%@]", buf, 0x20u);
    }

    uint64_t result = os_log_shim_legacy_logging_enabled();
    if (result)
    {
      uint64_t result = _IDSShouldLogTransport();
      if (result)
      {
        _IDSLogTransport();
        uint64_t result = _IDSShouldLog();
        if (result) {
          return _IDSLogV();
        }
      }
    }
  }
  return result;
}

void sub_100355B6C(id a1)
{
  id v1 = objc_alloc_init(IDSUTunController);
  uint64_t v2 = qword_100A4C840;
  qword_100A4C840 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

uint64_t tcp6checksum(int8x16_t *a1, int8x16_t *a2, int8x16_t *a3, unint64_t a4)
{
  if (a4 < 0x14) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v7 = a3[1].u16[0];
  a3[1].i16[0] = 0;
  uint32x4_t v8 = 0uLL;
  if (a1 && a2) {
    uint32x4_t v8 = vpadalq_u16(vpaddlq_u16((uint16x8_t)vrev16q_s8(*a2)), (uint16x8_t)vrev16q_s8(*a1));
  }
  uint32x4_t v24 = v8;
  int v9 = WORD1(a4);
  unint64_t v10 = a4 & 0xFFFFFFFFFFFFFFF0;
  __chkstk_darwin(a1, a2);
  memset((char *)&v24 - 2 * v10, 170, v11);
  uint64_t v12 = a3;
  if (a3)
  {
    memcpy((char *)&v24 - 2 * v10, a3, a4 & 0xFFFFFFFFFFFFFFF0);
    uint64_t v12 = (int8x16_t *)((char *)&v24 - 2 * v10);
  }
  unsigned int v13 = __rev16(v7);
  unint64_t v14 = (a4 >> 4) + 1;
  uint32x4_t v15 = v24;
  do
  {
    int8x16_t v16 = *v12++;
    uint32x4_t v15 = vpadalq_u16(v15, (uint16x8_t)vrev16q_s8(v16));
    --v14;
  }
  while (v14 > 1);
  unsigned int v17 = (unsigned __int16)a4
      + v9
      + vpadalq_u32((uint64x2_t)vdupq_laneq_s64((int64x2_t)vpaddlq_u32(v15), 1), v15).u32[0]
      + 6;
  __int16 v18 = &a3->i8[a4];
  if (a4)
  {
    int v19 = *--v18;
    v17 += v19 << 8;
  }
  unsigned int v20 = (a4 >> 1) & 7;
  if (v20)
  {
    uint64_t v21 = v18 - 1;
    unsigned int v22 = v20 + 1;
    do
    {
      v17 += bswap32(*(unsigned __int16 *)(v21 - 1)) >> 16;
      v21 -= 2;
      --v22;
    }
    while (v22 > 1);
  }
  if (v17 >= 0x10000)
  {
    do
      unsigned int v17 = HIWORD(v17) + (unsigned __int16)v17;
    while (HIWORD(v17));
  }
  unsigned int v23 = v17 ^ 0xFFFF;
  a3[1].i16[0] = bswap32(v23) >> 16;
  return v23 - v13;
}

uint64_t udp6checksum(uint64_t a1, uint64_t a2, int8x16_t *a3, unint64_t a4)
{
  if (a4 < 8) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v7 = a3->u16[3];
  a3->i16[3] = 0;
  unint64_t v8 = a4 & 0xFFFFFFFFFFFFFFF0;
  __chkstk_darwin(a1, a2);
  uint32x4_t v22 = v10;
  if (v8)
  {
    memset((char *)&v22 - 2 * v8, 170, v9);
    uint32x4_t v10 = v22;
  }
  size_t v11 = a3;
  if (a3)
  {
    memcpy((char *)&v22 - 2 * v8, a3, a4 & 0xFFFFFFFFFFFFFFF0);
    uint32x4_t v10 = v22;
    size_t v11 = (int8x16_t *)((char *)&v22 - 2 * v8);
  }
  if (a4 >= 0x10)
  {
    unint64_t v12 = (a4 >> 4) + 1;
    do
    {
      int8x16_t v13 = *v11++;
      uint32x4_t v10 = vpadalq_u16(v10, (uint16x8_t)vrev16q_s8(v13));
      --v12;
    }
    while (v12 > 1);
  }
  unsigned int v14 = (unsigned __int16)a4
      + WORD1(a4)
      + vpadalq_u32((uint64x2_t)vdupq_laneq_s64((int64x2_t)vpaddlq_u32(v10), 1), v10).u32[0]
      + 17;
  uint32x4_t v15 = &a3->i8[a4];
  if (a4)
  {
    int v16 = *--v15;
    v14 += v16 << 8;
  }
  unsigned int v17 = (a4 >> 1) & 7;
  if (v17)
  {
    __int16 v18 = v15 - 1;
    unsigned int v19 = v17 + 1;
    do
    {
      v14 += bswap32(*(unsigned __int16 *)(v18 - 1)) >> 16;
      v18 -= 2;
      --v19;
    }
    while (v19 > 1);
  }
  unsigned int v20 = __rev16(v7);
  if (v14 >= 0x10000)
  {
    do
      unsigned int v14 = HIWORD(v14) + (unsigned __int16)v14;
    while (HIWORD(v14));
  }
  unsigned int v21 = v14 ^ 0xFFFF;
  a3->i16[3] = bswap32(v21) >> 16;
  return v21 - v20;
}

void sub_100355F94(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    [*(id *)(a1 + 32) _reloadSettings];
    uint64_t v3 = IMGetDomainIntForKey();
    switch(v3)
    {
      case 0:
        return;
      case 1:
        uint64_t v4 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Custom Test 1 - simple control channel internal fail", (uint8_t *)&buf, 2u);
        }

        uint64_t v5 = sub_1003F2080(*(void *)(a1 + 32) + 8, kIDSDefaultPairedDeviceID);
        uint64_t v6 = [v5 controlChannel];
        [v6 simulateDecryptionFailure];
        goto LABEL_6;
      case 2:
        unsigned int v7 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Custom Test 2 - reset before control channel internal fail", (uint8_t *)&buf, 2u);
        }

        unint64_t v8 = sub_1003F2080(*(void *)(a1 + 32) + 8, kIDSDefaultPairedDeviceID);
        size_t v9 = sub_1003F1964((uint64_t)[v8 connectionsTableByLocalRemotePortKey], 67109888);
        [*(id *)(a1 + 32) resetTCPConnection:v9 forDeviceConnectionInfo:v8];
        uint32x4_t v10 = [v8 controlChannel];
        [v10 simulateDecryptionFailure];

        goto LABEL_15;
      case 3:
        size_t v11 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Custom Test 3 - simulate the control channel connection reset loop", (uint8_t *)&buf, 2u);
        }

        *(unsigned char *)(*(void *)(a1 + 32) + 128) = 1;
        unint64_t v8 = im_primary_queue();
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_100356AC4;
        block[3] = &unk_10097E4D0;
        void block[4] = *(void *)(a1 + 32);
        dispatch_async(v8, block);
LABEL_15:

        return;
      case 4:
        int v12 = IMGetDomainIntForKey();
        int8x16_t v13 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 67109120;
          DWORD1(buf) = v12;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Custom Test 4 - dump logs with flags %08X", (uint8_t *)&buf, 8u);
        }

        IDSNetworkingLogDump();
        return;
      case 5:
        unsigned int v14 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Custom Test 5 - simulate reaching file descriptor limit", (uint8_t *)&buf, 2u);
        }

        uint32x4_t v15 = +[NSMutableArray array];
        while (1)
        {
          uint64_t v16 = socket(30, 2, 0);
          __error();
          unsigned int v17 = +[IDSFoundationLog utunController];
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 67109120;
            DWORD1(buf) = v16;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Custom Test 5 - made new socket %d", (uint8_t *)&buf, 8u);
          }

          IDSAssertNonFatalErrnoWithSource();
          __int16 v18 = +[NSNumber numberWithInt:v16];
          [v15 addObject:v18];
        }
      case 6:
        unsigned int v19 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Custom Test 6 - pop alert", (uint8_t *)&buf, 2u);
        }

        IDSInternalAlertSimple();
        return;
      case 7:
        unsigned int v20 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Custom Test 7 - trigger utun socket stall detection", (uint8_t *)&buf, 2u);
        }

        unsigned int v21 = +[IDSStallDetector detectorWithName:@"kUTunConnectionDefaultUrgentOutgoingDetectorName"];
        uint64_t v5 = v21;
        if (v21)
        {
          [v21 forceTriggerStallDetectedBlockWithEventName:@"TestTrigger"];
        }
        else
        {
          uint64_t v6 = +[IDSFoundationLog utunController];
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 138412290;
            *(void *)((char *)&buf + 4) = @"kUTunConnectionDefaultUrgentOutgoingDetectorName";
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Custem Test 7 - Couldn't find the detector %@", (uint8_t *)&buf, 0xCu);
          }
LABEL_6:
        }
        goto LABEL_50;
      case 8:
        uint32x4_t v22 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Custom Test 8 - filling utun os_channel...", (uint8_t *)&buf, 2u);
        }

        unsigned int v23 = sub_1003F2080(*(void *)(a1 + 32) + 8, kIDSDefaultPairedDeviceID);
        int v24 = 0;
        int v62 = 0;
        long long v60 = 0u;
        long long v61 = 0u;
        long long v58 = 0u;
        long long v59 = 0u;
        long long buf = 0u;
        long long v57 = 0u;
        do
        {
          long long v25 = *(void **)(a1 + 32);
          long long v26 = [v23 remoteSA];
          id v27 = [v26 sa];
          long long v28 = [v23 localSA];
          LODWORD(v25) = objc_msgSend(v25, "handleUtunChannelWrite:source:destination:upperProtocol:bytes:bytesLen:", v23, v27, objc_msgSend(v28, "sa"), 6, &buf, 100);

          ++v24;
        }
        while (v25);
        long long v29 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int16 v54 = 67109120;
          int v55 = v24;
          _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Custom Test 8 - filled utun os_channel after %d dummy writes", v54, 8u);
        }

        goto LABEL_39;
      case 9:
LABEL_39:
        long long v30 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Custom Test 9 - Inject Corrupted BT packet.", (uint8_t *)&buf, 2u);
        }

        uint64_t v31 = *(void *)(a1 + 32);
        uint64_t v32 = v31 + 8;
        uint64_t v33 = kIDSDefaultPairedDeviceID;
        id v34 = *(id *)(v31 + 96);
        uint64_t v5 = sub_1003F2080(v32, v33);
        __int16 v35 = (void *)_IDSLinkPacketBufferCreate();
        id v36 = (_WORD *)*v35;
        __int16 v37 = [&stru_10099BE78 stringByPaddingToLength:1000 withString:@"a" startingAtIndex:0];
        id v38 = [v37 dataUsingEncoding:4];
        memcpy(v36, [v38 bytes], (size_t)objc_msgSend(v38, "length"));
        v35[2] = [v38 length];
        v35[3] = [v38 length];
        *id v36 = -1;
        [v34 injectFakePacketInBTLink:v35 cbuuid:v5[1].isa];

        free(v35);
        goto LABEL_50;
      case 10:
        int v39 = IMGetCachedDomainBoolForKeyWithDefaultValue();
        __int16 v40 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          CFStringRef v41 = @"NO";
          if (v39) {
            CFStringRef v41 = @"YES";
          }
          LODWORD(buf) = 138412290;
          *(void *)((char *)&buf + 4) = v41;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "Custom Test 10 - Control Message + main queue deadlock test (avoidMainQueue: %@", (uint8_t *)&buf, 0xCu);
        }

        uint64_t v42 = *(void *)(a1 + 32) + 8;
        v50[0] = _NSConcreteStackBlock;
        v50[1] = 3221225472;
        v50[2] = sub_100356B60;
        v50[3] = &unk_100989E70;
        char v51 = v39;
        char v52 = 0;
        id v43 = v50;
        goto LABEL_54;
      case 11:
        __int16 v44 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "Custom Test 11 - simulate starting control channel again", (uint8_t *)&buf, 2u);
        }

        id v45 = sub_1003F2080(*(void *)(a1 + 32) + 8, kIDSDefaultPairedDeviceID);
        v48[5] = _NSConcreteStackBlock;
        v48[6] = 3221225472;
        v48[7] = sub_1003570C0;
        v48[8] = &unk_100980D88;
        v48[9] = *(void *)(a1 + 32);
        id v49 = v45;
        uint64_t v5 = v45;
        IDSTransportThreadAddBlock();

        goto LABEL_50;
      case 12:
        __int16 v46 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "Custom Test 12 - Kill all links", (uint8_t *)&buf, 2u);
        }

        uint64_t v47 = *(void *)(a1 + 32);
        uint64_t v42 = v47 + 8;
        v48[0] = _NSConcreteStackBlock;
        v48[1] = 3221225472;
        v48[2] = sub_1003570D0;
        v48[3] = &unk_100989E98;
        v48[4] = v47;
        id v43 = v48;
LABEL_54:
        sub_1003F23AC(v42, (uint64_t)v43);
        break;
      default:
        uint64_t v5 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 134217984;
          *(void *)((char *)&buf + 4) = v3;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Custom Test - unsupported %ld", (uint8_t *)&buf, 0xCu);
        }
LABEL_50:

        break;
    }
  }
}

void sub_100356AC4(uint64_t a1)
{
  sub_1003F2080(*(void *)(a1 + 32) + 8, kIDSDefaultPairedDeviceID);
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  uint64_t v2 = sub_1003F1964((uint64_t)[v4 connectionsTableByLocalRemotePortKey], 67109888);
  [*(id *)(a1 + 32) resetTCPConnection:v2 forDeviceConnectionInfo:v4];
  uint64_t v3 = [v4 controlChannel];
  [v3 simulateDecryptionFailure];
}

void sub_100356B60(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  uint64_t v5 = [v4 controlChannel];
  uint64_t v6 = [v4 cbuuid];
  unsigned int v7 = [v6 description];

  unint64_t v8 = [v4 cbuuid];

  size_t v9 = [v5 remoteDeviceEncryptionInfo];

  uint32x4_t v10 = +[IDSFoundationLog utunController];
  BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
  if (v9)
  {
    if (v11)
    {
      *(_DWORD *)long long buf = 138412546;
      long long v25 = v7;
      __int16 v26 = 2112;
      id v27 = v8;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Custom Test 10 - about to ask main queue to sync onto TransportThread for %@ on %@", buf, 0x16u);
    }

    int v12 = im_primary_queue();
    __int16 v18 = _NSConcreteStackBlock;
    uint64_t v19 = 3221225472;
    unsigned int v20 = sub_100356E6C;
    unsigned int v21 = &unk_10097E440;
    int8x16_t v13 = v7;
    uint32x4_t v22 = v13;
    id v14 = v8;
    id v23 = v14;
    dispatch_async(v12, &v18);

    uint32x4_t v15 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412546;
      long long v25 = v13;
      __int16 v26 = 2112;
      id v27 = v14;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Custom Test 10 - telling control channel to encrypt and send message for %@ on %@", buf, 0x16u);
    }

    [v5 setAvoidMainQueueOverrideToNO:*(unsigned char *)(a1 + 32) == 0];
    uint64_t v16 = +[NSData dataWithBytes:a1 + 33 length:1];
    [v5 sendMessage:v16];

    unsigned int v17 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412546;
      long long v25 = v13;
      __int16 v26 = 2112;
      id v27 = v14;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Custom Test 10 - asked main queue to sync onto TransportThread for %@ on %@", buf, 0x16u);
    }

    uint32x4_t v10 = v22;
  }
  else if (v11)
  {
    *(_DWORD *)long long buf = 138412546;
    long long v25 = v7;
    __int16 v26 = 2112;
    id v27 = v8;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Custom Test 10 - skipping test for %@ on %@", buf, 0x16u);
  }
}

void sub_100356E6C(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog utunController];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 138412546;
    uint64_t v11 = v3;
    __int16 v12 = 2112;
    uint64_t v13 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Custom Test 10 - about to sync onto TransportThread for %@ on %@", buf, 0x16u);
  }

  id v8 = *(id *)(a1 + 32);
  id v9 = *(id *)(a1 + 40);
  IDSTransportThreadAddSyncBlock();
  uint64_t v5 = +[IDSFoundationLog utunController];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v7 = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 138412546;
    uint64_t v11 = v6;
    __int16 v12 = 2112;
    uint64_t v13 = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Custom Test 10 - sync onto TransportThread returned for %@ on %@", buf, 0x16u);
  }
}

void sub_100357004(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog utunController];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    int v5 = 138412546;
    uint64_t v6 = v3;
    __int16 v7 = 2112;
    uint64_t v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Custom Test 10 - sync operation on TransportThread for %@ on %@", (uint8_t *)&v5, 0x16u);
  }
}

id sub_1003570C0(uint64_t a1)
{
  return [*(id *)(a1 + 32) startControlChannelWithDevice:*(void *)(a1 + 40) endpoint:0];
}

void sub_1003570D0(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v6 = [v4 cbuuid];
  int v5 = [v4 deviceUniqueID];

  [*(id *)(*(void *)(a1 + 32) + 96) stopLinkForDeviceUniqueID:v5 cbuuid:v6 disconnectWP:1];
}

void sub_10035744C(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  int v5 = [v4 controlChannel];
  [v5 setDisableEncryption:*(unsigned __int8 *)(*(void *)(a1 + 32) + 115)];

  int v6 = NEVirtualInterfaceSetMaxPendingPackets();
  int v7 = *__error();
  uint64_t v8 = +[IDSFoundationLog utunController];
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = v4[1];
    if (v6) {
      int v10 = 0;
    }
    else {
      int v10 = v7;
    }
    int v11 = 138412802;
    uint64_t v12 = v9;
    __int16 v13 = 1024;
    int v14 = v6;
    __int16 v15 = 1024;
    int v16 = v10;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%@: SetMaxPendingPackets %d (%d)", (uint8_t *)&v11, 0x18u);
  }
}

void sub_100357838(void *a1, void *a2, void *a3, uint64_t a4, uint64_t a5, int a6, unsigned __int16 *a7, size_t a8, char *a9, char *a10)
{
  id v15 = a1;
  int v16 = a2;
  unsigned int v17 = a3;
  if (a6 == 6)
  {
    int v18 = *((unsigned __int8 *)a7 + 13);
    int v81 = -((*((unsigned __int8 *)a7 + 12) >> 2) & 0x3C);
    unsigned int v19 = bswap32(*((_DWORD *)a7 + 1));
  }
  else
  {
    int v18 = 170;
    int v81 = 1431655766;
    unsigned int v19 = -1431655766;
  }
  unsigned int v80 = v19;
  unsigned int v20 = a9;
  unsigned int v21 = a10;
  unsigned int v84 = __rev16(*a7);
  unsigned int v86 = __rev16(a7[1]);
  if (*((unsigned char *)v15 + 104))
  {
    uint32x4_t v22 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      if (a8 >= 0x28) {
        uint64_t v23 = 40;
      }
      else {
        uint64_t v23 = a8;
      }
      int v24 = [v16 vifName];
      uint64_t v25 = +[NSData dataWithBytesNoCopy:a7 length:v23 freeWhenDone:0];
      __int16 v26 = (void *)v25;
      *(_DWORD *)long long buf = 138413826;
      id v27 = " ...";
      uint64_t v92 = v24;
      if (a8 < 0x29) {
        id v27 = "";
      }
      __int16 v93 = 1024;
      *(_DWORD *)uint64_t v94 = v84;
      *(_WORD *)&v94[4] = 1024;
      *(_DWORD *)&v94[6] = v86;
      __int16 v95 = 1024;
      *(_DWORD *)uint64_t v96 = a6;
      *(_WORD *)&void v96[4] = 2048;
      *(void *)&v96[6] = a8;
      *(_WORD *)&v96[14] = 2112;
      *(void *)&v96[16] = v25;
      *(_WORD *)&v96[24] = 2080;
      *(void *)&v96[26] = v27;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%@: Payload Handler! %u => %u proto:%d (len=%ld)\n\t\t=> data[%@%s]", buf, 0x3Cu);

      unsigned int v21 = a10;
      unsigned int v20 = a9;
    }
  }
  if (*((unsigned char *)v16 + 8264))
  {
    long long v28 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      long long v29 = [v16 vifName];
      long long v30 = v16[1];
      *(_DWORD *)long long buf = 138412546;
      uint64_t v92 = v29;
      __int16 v93 = 2112;
      *(void *)uint64_t v94 = v30;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "%@: device %@ is suspending traffic", buf, 0x16u);
    }
    char *v20 = 1;
    *unsigned int v21 = 0;
    goto LABEL_17;
  }
  id v79 = v20;
  unsigned __int8 v83 = v21;
  if (v17 && (uint64_t)[*((id *)v17 + 18) state] >= 2 && objc_msgSend(*((id *)v17 + 18), "localContext"))
  {
    unsigned int v31 = [*((id *)v17 + 18) localCID];
    [*((id *)v17 + 18) localContext];
    uint64_t v32 = IDSHC_Compress();
    unsigned int v78 = v31;
    if (v32)
    {
      uint64_t v33 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        id v34 = [v16 vifName];
        *(_DWORD *)long long buf = 138412546;
        uint64_t v92 = v34;
        __int16 v93 = 2048;
        *(void *)uint64_t v94 = v32;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "%@: IDSHC_Compress failed (%lu), revert back to un-compressed", buf, 0x16u);

        unsigned int v31 = v78;
      }
    }
    if (v31 < 0x10)
    {
      __n_4 = (char *)a7 - 1;
      signed int __n = a8 + 1;
      char v36 = a6 == 6 ? -96 : 0x80;
      *((unsigned char *)a7 - 1) = v31 | v36;
    }
    else
    {
      __n_4 = (char *)a7 - 3;
      signed int __n = a8 + 3;
      char v35 = a6 == 6 ? -80 : -112;
      *((unsigned char *)a7 - 3) = v35;
      *((unsigned char *)a7 - 2) = BYTE1(v31);
      *((unsigned char *)a7 - 1) = v31;
    }
    __int16 v37 = (void *)_IDSLinkPacketBufferCreate();
    memcpy((void *)*v37, __n_4, __n);
    v37[2] = __n;
    if (!v32)
    {
      if (*((unsigned char *)v15 + 104))
      {
        uint64_t v72 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
        {
          if ((unint64_t)__n >= 0x14) {
            uint64_t v73 = 20;
          }
          else {
            uint64_t v73 = __n;
          }
          id v74 = v16[1038];
          uint64_t v75 = +[NSData dataWithBytesNoCopy:*v37 length:v73 freeWhenDone:0];
          *(_DWORD *)long long buf = 138414338;
          id v76 = " ...";
          uint64_t v92 = v74;
          *(_DWORD *)uint64_t v94 = 1;
          __int16 v93 = 1024;
          if (__n < 0x15) {
            id v76 = "";
          }
          *(_WORD *)&v94[4] = 1024;
          *(_DWORD *)&v94[6] = a6 == 6;
          __int16 v95 = 1024;
          *(_DWORD *)uint64_t v96 = v78;
          *(_WORD *)&void v96[4] = 1024;
          *(_DWORD *)&v96[6] = v84;
          *(_WORD *)&v96[10] = 1024;
          *(_DWORD *)&v96[12] = v86;
          *(_WORD *)&v96[16] = 2048;
          *(void *)&v96[18] = __n;
          *(_WORD *)&v96[26] = 2112;
          id v77 = (void *)v75;
          *(void *)&v96[28] = v75;
          *(_WORD *)&v96[36] = 2080;
          __int16 v97 = v76;
          _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "%@: outgoing header (compressed_bit:%d protocol_bit:%d local_cid:%d s_port:%u d_port:%u)\n\t\t=> c(%luB): [%@%s]", buf, 0x48u);
        }
      }
      int v38 = a6;
LABEL_36:
      if (*((unsigned char *)v15 + 114) && *((unsigned char *)v17 + 4784))
      {
        unsigned __int16 v39 = v17[2406];
        uint64_t v40 = sub_100221370((uint64_t)(v17 + 96), v39, (unsigned __int8 *)*v37, v37[2], 1);
        if (v40)
        {
          uint64_t v41 = v40;
          id v42 = [v16 portMap];
          id v43 = [v17 addressPair];
          __int16 v44 = [v43 localAddress];
          objc_msgSend(v15, "releasePortIfNecessary:port:", v42, objc_msgSend(v44, "saPortHostOrder"));

          id v45 = +[NSString stringWithFormat:@"Encryption failure: %u", v41];
          [v15 removeConnection:v17 fromDeviceConnectionInfo:v16 removeCode:5301 removeReason:v45];

          _IDSLinkPacketBufferRelease();
          goto LABEL_17;
        }
        IDSLinkPacketBufferAddBufferStart();
        __int16 v46 = (_WORD *)*v37;
        _WORD *v46 = 224;
        v46[1] = bswap32(v17[2406]) >> 16;
        *((_DWORD *)v46 + 1) = bswap32(*((_DWORD *)v17 + 1200));
        [v17 setSeqSend:(unsigned __int16)(v39 + 1)];
      }
      goto LABEL_41;
    }
  }
  int v38 = a6;
  __int16 v37 = (void *)_IDSLinkPacketBufferCreate();
  *(unsigned char *)*__int16 v37 = 32 * (a6 == 6);
  memcpy((void *)(*v37 + 1), a7, a8);
  v37[2] = a8 + 1;
  if (v17) {
    goto LABEL_36;
  }
LABEL_41:
  *((unsigned char *)v37 + 38) = [v17 isCloudEnabled];
  *((unsigned char *)v37 + 41) = [v17 isDefaultPairedDevice];
  if ((uint64_t)v37[2] > 675) {
    unsigned __int8 v47 = 0;
  }
  else {
    unsigned __int8 v47 = [v17 isRealTime];
  }
  *((unsigned char *)v37 + 42) = v47;
  int v48 = a8;
  if (qword_100A4C8A8 != -1) {
    dispatch_once(&qword_100A4C8A8, &stru_10098A438);
  }
  uint64_t v87 = mach_continuous_time();
  double v49 = *(double *)&qword_100A4C830;
  if (v38 == 6)
  {
    unsigned int v50 = v18 & 2;
    if (v17)
    {
      int v51 = v80 + a8 + v81 + (v50 >> 1);
      int v52 = *((_DWORD *)v17 + 25);
      if ((v52 & 0x40) != 0)
      {
        if ((v51 - *((_DWORD *)v17 + 23)) <= 0x3FFFFFFE) {
          *((_DWORD *)v17 + 23) = v51;
        }
      }
      else
      {
        *((_DWORD *)v17 + 25) = v52 | 0x40;
        *((_DWORD *)v17 + 23) = v51;
        int v53 = v18;
        if (qword_100A4C8A8 != -1) {
          dispatch_once(&qword_100A4C8A8, &stru_10098A438);
        }
        [v17 setConnectionSetupStartTime:*(double *)&qword_100A4C830 * (double)mach_continuous_time()];
        __int16 v54 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          uint64_t v92 = v17;
          _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "First packet for connection %@", buf, 0xCu);
        }

        int v18 = v53;
      }
    }
    if (*((unsigned char *)v15 + 104))
    {
      int v55 = v17;
      int v56 = v18;
      long long v57 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
      {
        long long v58 = [v16 vifName];
        long long v59 = "S";
        if (!v50) {
          long long v59 = "";
        }
        uint64_t v85 = v59;
        long long v60 = "R";
        if ((v56 & 4) == 0) {
          long long v60 = "";
        }
        id v82 = v60;
        long long v88 = v16;
        if ((v56 & 8) != 0) {
          long long v61 = "P";
        }
        else {
          long long v61 = "";
        }
        if ((v56 & 0x10) != 0) {
          int v62 = ".";
        }
        else {
          int v62 = "";
        }
        unsigned int v63 = [v55 expectedNextOutgoingSequenceNumber];
        *(_DWORD *)long long buf = 138414082;
        uint64_t v92 = v58;
        __int16 v93 = 1024;
        *(_DWORD *)uint64_t v94 = v48;
        *(_WORD *)&v94[4] = 1024;
        *(_DWORD *)&v94[6] = v56;
        __int16 v95 = 2080;
        *(void *)uint64_t v96 = v85;
        *(_WORD *)&v96[8] = 2080;
        *(void *)&v96[10] = v82;
        *(_WORD *)&v96[18] = 2080;
        *(void *)&v96[20] = v61;
        int v16 = v88;
        *(_WORD *)&v96[28] = 2080;
        *(void *)&v96[30] = v62;
        LOWORD(v97) = 1024;
        *(_DWORD *)((char *)&v97 + 2) = v63;
        _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "%@: Sending TCP %uB (flags[%02X] [%s%s%s%s])) noseq:%08x", buf, 0x46u);
      }
      unsigned int v17 = v55;
    }
  }
  else if (v38 == 17)
  {
    kdebug_trace();
  }
  char v64 = 1;
  *((unsigned char *)v37 + 40) = 1;
  uint64_t v65 = v37[2];
  id v66 = [*((id *)v15 + 12) sendPacketBuffer:v37 toDeviceUniqueID:v16[2] cbuuid:v16[1]];
  id v67 = v66;
  if (v66 == (id)1)
  {
    char v71 = 0;
    unsigned int v68 = v83;
  }
  else
  {
    unsigned int v68 = v83;
    if (v66 == (id)13)
    {
      uint64_t v69 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v70 = [v16 utunSocket];
        *(_DWORD *)long long buf = 67109120;
        LODWORD(v92) = v70;
        _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "[throughput] link throttling (s: %u)", buf, 8u);
      }

      char v64 = 1;
    }
    else
    {
      char v64 = 0;
    }
    char v71 = 1;
  }
  char *v79 = v64;
  char *v68 = v71;
  if (v17)
  {
    ++*((void *)v17 + 604);
    *((void *)v17 + 606) += v65;
    if (!v67) {
      *((double *)v17 + 17) = v49 * (double)v87;
    }
  }
LABEL_17:
}

BOOL sub_1003582D8(void *a1, void *a2, uint64_t a3)
{
  unint64_t v3 = *(unsigned int *)(a3 + 2628);
  if (v3 >= *(_DWORD *)(a3 + 2624)) {
    return 0;
  }
  uint64_t v7 = a3 + 1536;
  uint64_t v8 = a3 + 8 * v3;
  do
  {
    id v9 = *(id *)v8;
    unsigned __int8 v17 = -86;
    char v16 = -86;
    sub_100357838(a1, a2, v9, v10, v11, *(unsigned __int8 *)(v7 + v3), *(unsigned __int16 **)(v8 + 1600), *(void *)(v8 + 2112), (char *)&v17, &v16);
    if (v16)
    {
      id v12 = *(id *)v8;
      *(void *)uint64_t v8 = 0;

      ++*(_DWORD *)(a3 + 2628);
    }
    int v13 = v17;
    BOOL v14 = v17 != 0;

    if (v13) {
      break;
    }
    ++v3;
    v8 += 8;
  }
  while (v3 < *(unsigned int *)(a3 + 2624));
  return v14;
}

void sub_1003583D8(void *a1, void *a2, char *a3)
{
  id v8 = a1;
  int v5 = a2;
  if (v5[2079]) {
    sub_10071FB84();
  }
  int v6 = v5;
  if (sub_1003582D8(v8, v5, (uint64_t)(v5 + 2085)) || sub_1003582D8(v8, v6, (uint64_t)v6 + 19312))
  {
    char v7 = 1;
    IDSTransportThreadSuspendSocket();
    if (!a3) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  char v7 = 0;
  if (a3) {
LABEL_5:
  }
    *a3 = v7;
LABEL_6:
}

void sub_1003584BC(void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8)
{
  uint64_t v10 = a1;
  uint64_t v11 = a2;
  unsigned int v80 = v10;
  if (v10[27] < a8)
  {
    id v12 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = [v11 vifName];
      int v14 = v80[27];
      *(_DWORD *)long long buf = 138412802;
      *(void *)&uint8_t buf[4] = v13;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)long long v88 = a8;
      *(_WORD *)&v88[4] = 1024;
      *(_DWORD *)&v88[6] = v14;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%@: numPackets %u != max %u - dropping excess", buf, 0x18u);
    }
    a8 = v80[27];
  }
  if (v11[4826] != v11[4827])
  {
    id v15 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      char v16 = [v11 vifName];
      int v17 = v11[4826] - v11[4827];
      *(_DWORD *)long long buf = 138412546;
      *(void *)&uint8_t buf[4] = v16;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)long long v88 = v17;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%@: payload handler called while there are pending outgoing urgent packets - [%u] dropped", buf, 0x12u);
    }
    unint64_t v18 = v11[4827];
    if (v18 < v11[4826])
    {
      do
      {
        unsigned int v19 = *(void **)&v11[2 * v18 + 4170];
        *(void *)&v11[2 * v18 + 4170] = 0;

        ++v18;
      }
      while (v18 < v11[4826]);
    }
  }
  v11[4827] = 0;
  v11[4826] = 0;
  if (v11[5484] != v11[5485])
  {
    unsigned int v20 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v21 = [v11 vifName];
      int v22 = v11[5484] - v11[5485];
      *(_DWORD *)long long buf = 138412546;
      *(void *)&uint8_t buf[4] = v21;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)long long v88 = v22;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%@: payload handler called while there are pending outgoing regular packets - [%u] dropped", buf, 0x12u);
    }
    unint64_t v23 = v11[5485];
    if (v23 < v11[5484])
    {
      do
      {
        int v24 = *(void **)&v11[2 * v23 + 4828];
        *(void *)&v11[2 * v23 + 4828] = 0;

        ++v23;
      }
      while (v23 < v11[5484]);
    }
  }
  v11[5485] = 0;
  v11[5484] = 0;
  uint64_t v85 = a8;
  if (a8)
  {
    uint64_t v25 = 0;
    do
    {
      int v26 = *(unsigned __int8 *)(a5 + v25);
      if (v26 == 6 || v26 == 17)
      {
        long long v28 = *(unsigned __int16 **)(a6 + 8 * v25);
        unsigned int v29 = *v28;
        unsigned int v30 = v28[1];
        if (v26 == 6)
        {
          char v31 = *((unsigned char *)v28 + 13);
          unsigned int v32 = bswap32(*((_DWORD *)v28 + 1));
          BOOL v33 = ((*((unsigned __int8 *)v28 + 12) >> 2) & 0x3C) == *(_DWORD *)(a7 + 8 * v25);
        }
        else
        {
          kdebug_trace();
          BOOL v33 = 0;
          char v31 = 0;
          unsigned int v32 = 0;
        }
        uint64_t v34 = __rev16(v29);
        uint64_t v35 = __rev16(v30);
        char v36 = sub_1003F1964((uint64_t)objc_msgSend(v11, "connectionsTableByLocalRemotePortKey", v75, v76, v77, v78), v35 | (v34 << 16));
        unsigned __int16 v39 = v36;
        if (v36 || *(unsigned char *)(a5 + v25) == 6 && (v31 & 4) != 0)
        {
          if (!v33
            && ([v36 priority] == (id)200 || [v39 priority] == (id)100))
          {
            int v37 = 0;
            int v38 = &OBJC_IVAR___IDSDeviceConnectionInfo_regularPackets;
          }
          else
          {
            int v37 = 1;
            int v38 = &OBJC_IVAR___IDSDeviceConnectionInfo_urgentPackets;
          }
          uint64_t v45 = *v38;
          __int16 v46 = +[IDSFoundationLog utunController];
          BOOL v47 = os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT);
          if (v85 == 1)
          {
            if (v47)
            {
              int v48 = [v11 vifName];
              *(_DWORD *)long long buf = 138412546;
              *(void *)&uint8_t buf[4] = v48;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)long long v88 = v37;
              _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "%@: handleMultiple - saving packet to list (urgent: %d)", buf, 0x12u);
            }
          }
          else if (v47)
          {
            double v49 = [v11 vifName];
            *(_DWORD *)long long buf = 138413058;
            *(void *)&uint8_t buf[4] = v49;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)long long v88 = v25;
            *(_WORD *)&v88[4] = 1024;
            *(_DWORD *)&v88[6] = v85;
            *(_WORD *)&v88[10] = 1024;
            *(_DWORD *)&v88[12] = v37;
            _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "%@: handleMultiple - saving packet #%u (total %u) to list (urgent: %d)", buf, 0x1Eu);
          }
          *(void *)long long buf = 0xAAAAAAAAAAAAAAAALL;
          unsigned int v50 = (char *)v11 + v45;
          id v51 = objc_initWeak((id *)buf, v39);
          uint64_t v52 = *(unsigned int *)((char *)v11 + v45 + 2624);
          int v53 = *(void **)((char *)&v11[2 * v52] + v45);
          *(void *)&v50[8 * v52] = v39;

          uint64_t v54 = *(unsigned int *)((char *)v11 + v45 + 2624);
          uint64_t v55 = (uint64_t)&v11[2 * v54] + v45;
          *(void *)(v55 + 512) = *(void *)(a3 + 8 * v25);
          *(void *)(v55 + 1024) = *(void *)(a4 + 8 * v25);
          v50[v54 + 1536] = *(unsigned char *)(a5 + v25);
          uint64_t v56 = *(unsigned int *)((char *)v11 + v45 + 2624);
          uint64_t v57 = (uint64_t)&v11[2 * v56] + v45;
          *(void *)(v57 + 1600) = *(void *)(a6 + 8 * v25);
          *(void *)(v57 + 2112) = *(void *)(a7 + 8 * v25);
          *((_DWORD *)v50 + 656) = v56 + 1;
          objc_destroyWeak((id *)buf);
        }
        else
        {
          long long v58 = OSLogHandleForIDSCategory();
          if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
          {
            long long v59 = [v11 vifName];
            *(_DWORD *)long long buf = 138413058;
            *(void *)&uint8_t buf[4] = v59;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)long long v88 = v34;
            *(_WORD *)&v88[4] = 1024;
            *(_DWORD *)&v88[6] = v35;
            *(_WORD *)&v88[10] = 2112;
            *(void *)&v88[12] = v11;
            _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "%@: cannot find connection for outgoing packet [%u => %u] in [%@]", buf, 0x22u);
          }
          if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
          {
            [v11 vifName];
            uint64_t v77 = v35;
            uint64_t v75 = v78 = v11;
            uint64_t v76 = v34;
            _IDSLogV();
          }
          if (*(unsigned char *)(a5 + v25) == 6)
          {
            memset(v92, 170, sizeof(v92));
            unsigned int v60 = *((_DWORD *)v28 + 2);
            long long v61 = +[IDSFoundationLog utunController];
            int v62 = bswap32(v60);
            if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 67109376;
              *(_DWORD *)&uint8_t buf[4] = v32;
              *(_WORD *)&uint8_t buf[8] = 1024;
              *(_DWORD *)&buf[10] = v62;
              _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "reset TCP using seq:%08x ack:%08x", buf, 0xEu);
            }

            if ((v31 & 2) != 0) {
              int v63 = v32;
            }
            else {
              int v63 = v32 + 1;
            }
            sub_100358F18((uint64_t)v92, v35, v34, v62, v63);
            char v64 = [v11 remoteSA];
            uint64_t v65 = (char *)[v64 sa6];
            id v66 = [v11 localSA];
            tcp6checksum((int8x16_t *)(v65 + 8), (int8x16_t *)((char *)[v66 sa6] + 8), (int8x16_t *)v92, 0x14uLL);

            if (*((void *)v11 + 2079)) {
              sub_10071FBB0();
            }
            [v11 vifRef];
            id v67 = [v11 remoteSA];
            [v67 sa];
            unsigned int v68 = [v11 localSA];
            [v68 sa];
            int v69 = NEVirtualInterfaceWriteIPPayload();

            unsigned int v70 = +[IDSFoundationLog utunController];
            if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
            {
              char v71 = [v11 vifName];
              uint64_t v72 = [v11 localSA];
              uint64_t v73 = [v11 remoteSA];
              id v74 = +[NSData dataWithBytesNoCopy:v92 length:20 freeWhenDone:0];
              *(_DWORD *)long long buf = 138413314;
              *(void *)&uint8_t buf[4] = v71;
              *(_WORD *)&buf[12] = 2112;
              *(void *)long long v88 = v72;
              *(_WORD *)&v88[8] = 2112;
              *(void *)&v88[10] = v73;
              *(_WORD *)&v88[18] = 1024;
              int v89 = v69;
              __int16 v90 = 2112;
              long long v91 = v74;
              _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "%@: write generated reset %@ <= %@ neRet=%d\n\t\t<= data[%@]", buf, 0x30u);
            }
          }
        }
      }
      else
      {
        unsigned __int16 v39 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
        {
          id v41 = [v11 vifName];
          int v42 = *(unsigned __int8 *)(a5 + v25);
          int v43 = *((unsigned __int8 *)v80 + 104);
          if (*((unsigned char *)v80 + 104))
          {
            id v79 = +[NSData dataWithBytesNoCopy:*(void *)(a6 + 8 * v25) length:*(void *)(a7 + 8 * v25) freeWhenDone:0];
            CFStringRef v44 = v79;
          }
          else
          {
            CFStringRef v44 = @"--";
          }
          *(_DWORD *)long long buf = 138412802;
          *(void *)&uint8_t buf[4] = v41;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)long long v88 = v42;
          *(_WORD *)&v88[4] = 2112;
          *(void *)&v88[6] = v44;
          _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "%@: dropping unknown proto[%u] packet [%@]", buf, 0x1Cu);
          if (v43) {
        }
          }
      }

      ++v25;
    }
    while (v85 != v25);
  }
  sub_1003583D8(v80, v11, 0);
}

void sub_100358F18(uint64_t a1, __int16 a2, __int16 a3, int a4, int a5)
{
  *(unsigned char *)a1 = HIBYTE(a2);
  *(unsigned char *)(a1 + 1) = a2;
  *(unsigned char *)(a1 + 2) = HIBYTE(a3);
  *(unsigned char *)(a1 + 3) = a3;
  *(unsigned char *)(a1 + 4) = HIBYTE(a4);
  *(unsigned char *)(a1 + 5) = BYTE2(a4);
  *(unsigned char *)(a1 + 6) = BYTE1(a4);
  *(unsigned char *)(a1 + 7) = a4;
  *(unsigned char *)(a1 + 8) = HIBYTE(a5);
  *(unsigned char *)(a1 + 9) = BYTE2(a5);
  *(unsigned char *)(a1 + 10) = BYTE1(a5);
  *(unsigned char *)(a1 + 11) = a5;
  *(_WORD *)(a1 + 12) = 5200;
  *(_DWORD *)(a1 + 14) = 0;
  *(_WORD *)(a1 + 18) = 0;
  int v6 = +[IDSFoundationLog utunController];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    char v7 = +[NSData dataWithBytesNoCopy:a1 length:20 freeWhenDone:0];
    int v8 = 138412290;
    id v9 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Made reset[%@]", (uint8_t *)&v8, 0xCu);
  }
}

void sub_10035C72C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8)
{
  sub_1003584BC(*(void **)(a1 + 32), *(void **)(a1 + 40), a3, a4, a5, a6, a7, a8);
}

void sub_10035C7C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  LOBYTE(v14) = 1;
  [*(id *)(a1 + 32) handleIPPayload:a6 bytesLength:a7 source:a3 destination:a4 upperProtocol:a5 forDeviceConnectionInfo:*(void *)(a1 + 40) flush:v14 callerShouldStop:0];
}

void sub_10035C858(uint64_t a1)
{
  unint64_t v3 = *(void **)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  if (v3[2079])
  {
    uint64_t v4 = *(unsigned int *)(v2 + 108);
    _[(id)v2 handleUtunChannelRead:v3 limit:v4];
  }
  else if (*(unsigned char *)(v2 + 105))
  {
    char v9 = -86;
    sub_1003583D8((void *)v2, v3, &v9);
    if (!v9)
    {
      int v5 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        int v6 = *(_DWORD *)(a1 + 48);
        *(_DWORD *)long long buf = 67109120;
        int v11 = v6;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "ready-to-read-multiple on %d (utun)", buf, 8u);
      }

      NEVirtualInterfaceReadyToReadMultiple();
    }
  }
  else
  {
    char v7 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = *(_DWORD *)(a1 + 48);
      *(_DWORD *)long long buf = 67109120;
      int v11 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "ready-to-read on %d (utun)", buf, 8u);
    }

    NEVirtualInterfaceReadyToRead();
  }
}

uint64_t sub_10035CA14(uint64_t a1)
{
  *(void *)(*(void *)(a1 + 32) + 16672) = 0;
  return IDSTransportThreadSuspendSocket();
}

void sub_10035D4E0(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8, void *a9)
{
  id v13 = a2;
  uint64_t v14 = a8;
  id v15 = a9;
  if (!v15)
  {
    id v20 = *(id *)(a1 + 40);
    if (![*(id *)(a1 + 32) shouldUseIPsecLink])
    {
      [v20 setSdOriginal:a6];
      [v20 setSdNumberNoClose:a6];
      char v36 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109120;
        LODWORD(v63) = a6;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "about to wait for connect ready for {socket:%d}", buf, 8u);
      }

      id v27 = &v45;
      id v30 = v20;
      id v45 = v30;
      int v48 = a6;
      unsigned int v29 = (id *)v46;
      id v37 = *(id *)(a1 + 32);
      uint64_t v38 = *(void *)(a1 + 72);
      v46[0] = v37;
      v46[1] = v38;
      id v47 = *(id *)(a1 + 56);
      IDSTransportThreadAddSocket();
      unsigned __int16 v39 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109120;
        LODWORD(v63) = a6;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "scheduled wait for connect ready for {socket:%d}", buf, 8u);
      }

      char v31 = v47;
      goto LABEL_30;
    }
    if (v14)
    {
      if (v20)
      {
LABEL_17:
        nw_connection_set_queue(v14, *(dispatch_queue_t *)(*(void *)(a1 + 72) + 136));
        double v49 = _NSConcreteStackBlock;
        uint64_t v50 = 3221225472;
        id v51 = sub_10035DC84;
        uint64_t v52 = &unk_100989FD8;
        id v27 = (id *)&v53;
        long long v28 = v14;
        int v53 = v28;
        unsigned int v29 = &v54;
        id v30 = v20;
        id v54 = v30;
        id v55 = *(id *)(a1 + 32);
        uint64_t v56 = a7;
        int v57 = a6;
        nw_connection_set_event_handler();
        nw_connection_start(v28);
        [v30 reportToAWD:5 connectionType:*(unsigned int *)(a1 + 88) error:0];
        char v31 = v55;
LABEL_30:

        id v44 = *(id *)(a1 + 32);
        id v40 = v30;
        IDSTransportThreadAddBlockAfter();

        goto LABEL_38;
      }
      id v20 = +[IDSGenericConnectionID idWithAccount:*(void *)(a1 + 48) service:*(void *)(a1 + 56) name:*(void *)(a1 + 64)];
      uint64_t v25 = [*(id *)(a1 + 32) connectionsByID];
      uint64_t v26 = [v25 objectForKey:v20];

      if (v26)
      {

        id v20 = (id)v26;
        goto LABEL_17;
      }
      int v42 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v43 = *(void *)(a1 + 80);
        *(_DWORD *)long long buf = 134218498;
        int v63 = v14;
        __int16 v64 = 2112;
        uint64_t v65 = v14;
        __int16 v66 = 2112;
        uint64_t v67 = v43;
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "ids-ipsec: service connection (%p) %@ connected for service %@ but no generic connection - saving in cache", buf, 0x20u);
      }

      id v41 = [*(id *)(a1 + 32) serviceConnectionCache];
      [v41 setObject:v14 forKey:*(void *)(a1 + 80)];
    }
    else
    {
      id v41 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "startDataChannelWithDevice: finished with no error, but no socket and no connection", buf, 2u);
      }
    }

LABEL_37:
    goto LABEL_38;
  }
  char v16 = +[IDSFoundationLog utunController];
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    int v17 = *(NSObject **)(*(void *)(a1 + 32) + 8);
    *(_DWORD *)long long buf = 138412546;
    int v63 = v17;
    __int16 v64 = 2112;
    uint64_t v65 = v15;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "error creating socket with [%@] [%@]", buf, 0x16u);
  }

  unsigned int v18 = [*(id *)(a1 + 32) shouldUseIPsecLink];
  unsigned int v19 = *(void **)(a1 + 40);
  if (v18)
  {
    id v20 = v19;
    if (!v20)
    {
      unsigned int v21 = +[IDSGenericConnectionID idWithAccount:*(void *)(a1 + 48) service:*(void *)(a1 + 56) name:*(void *)(a1 + 64)];
      int v22 = [*(id *)(a1 + 32) connectionsByID];
      id v20 = [v22 objectForKey:v21];
    }
    objc_msgSend(*(id *)(a1 + 40), "reportToAWD:connectionType:error:", 5, *(unsigned int *)(a1 + 88), -[NSObject code](v15, "code"));
    if (v20)
    {
      unint64_t v23 = [v20 serviceConnection];

      if (v23)
      {
        int v24 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          int v63 = v15;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "ids-ipsec: start_request returns error but data channel fine - assuming connected via available block. Error %@", buf, 0xCu);
        }

        goto LABEL_37;
      }
    }
  }
  else
  {
    objc_msgSend(v19, "reportToAWD:connectionType:error:", objc_msgSend(*(id *)(*(void *)(a1 + 72) + 96), "currentLinkType:", *(void *)(*(void *)(a1 + 32) + 8)), *(unsigned int *)(a1 + 88), -[NSObject code](v15, "code"));
  }
  unsigned int v32 = [*(id *)(a1 + 40) openSocketCompletionHandler];

  if (v32)
  {
    objc_msgSend(*(id *)(a1 + 40), "setStateFlags:", objc_msgSend(*(id *)(a1 + 40), "stateFlags") | 2);
    BOOL v33 = [*(id *)(a1 + 40) openSocketCompletionHandler];
    uint64_t v34 = [*(id *)(a1 + 40) completionQueue];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10035DC34;
    block[3] = &unk_100989F10;
    id v60 = v33;
    uint64_t v61 = a7;
    long long v59 = v15;
    id v35 = v33;
    dispatch_async(v34, block);
  }
  else
  {
    if (([*(id *)(a1 + 40) sd] & 0x80000000) == 0) {
      close((int)[*(id *)(a1 + 40) sd]);
    }
    [*(id *)(a1 + 40) setSd:0xFFFFFFFFLL];
    [*(id *)(a1 + 40) setConnectError:v15];
  }
LABEL_38:
}

uint64_t sub_10035DC34(void *a1)
{
  return (*(uint64_t (**)(void, void, void, void, void, uint64_t, void, void, void))(a1[5] + 16))(a1[5], 0, 0, 0, 0, 0xFFFFFFFFLL, a1[6], 0, a1[4]);
}

void sub_10035DC84(uint64_t a1, int a2, void *a3)
{
  int v5 = a3;
  int v6 = v5;
  switch(a2)
  {
    case 0:
    case 4:
      if (v5) {
        CFErrorRef v7 = nw_error_copy_cf_error(v5);
      }
      else {
        CFErrorRef v7 = 0;
      }
      char v9 = v21;
      v21[0] = _NSConcreteStackBlock;
      v21[1] = 3221225472;
      v21[2] = sub_10035EC1C;
      v21[3] = &unk_100989FB0;
      int v22 = a2;
      void v21[4] = *(id *)(a1 + 32);
      int v23 = *(_DWORD *)(a1 + 64);
      v21[5] = *(id *)(a1 + 40);
      v21[6] = v7;
      v21[7] = *(id *)(a1 + 48);
      goto LABEL_25;
    case 3:
      if (v5)
      {
        CFErrorRef v8 = nw_error_copy_cf_error(v5);
        if (v8)
        {
          CFErrorRef v7 = v8;
LABEL_21:
          int v12 = -1;
          goto LABEL_24;
        }
      }
      [*(id *)(a1 + 40) socketTrafficClass];
      TrafficClassForIDSOpenSocketPriorityLevel();
      nw_connection_reset_traffic_class();
      int connected_socket = nw_connection_get_connected_socket();
      if (connected_socket < 0)
      {
        id v15 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v16 = *(void *)(a1 + 32);
          *(_DWORD *)long long buf = 134218242;
          *(void *)id v27 = v16;
          *(_WORD *)&v27[8] = 2112;
          *(void *)long long v28 = v16;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Failed to extract internal socket of (%p) %@", buf, 0x16u);
        }

        CFErrorRef v7 = 0;
        goto LABEL_21;
      }
      int v11 = connected_socket;
      int v12 = dup(connected_socket);
      if (v12 < 0)
      {
        __error();
        IDSAssertNonFatalErrnoWithSource();
      }
      else
      {
        id v13 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v14 = *(void *)(a1 + 32);
          *(_DWORD *)long long buf = 67109890;
          *(_DWORD *)id v27 = v12;
          *(_WORD *)&v27[4] = 1024;
          *(_DWORD *)&v27[6] = v11;
          *(_WORD *)long long v28 = 2048;
          *(void *)&v28[2] = v14;
          __int16 v29 = 2112;
          uint64_t v30 = v14;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Extracted {socket:%d} from internal {socket:%d} of (%p) %@", buf, 0x22u);
        }
      }
      CFErrorRef v7 = 0;
LABEL_24:
      char v9 = v24;
      v24[0] = _NSConcreteStackBlock;
      v24[1] = 3221225472;
      v24[2] = sub_10035E07C;
      v24[3] = &unk_100989F60;
      v24[4] = *(id *)(a1 + 32);
      int v25 = v12;
      v24[5] = *(id *)(a1 + 40);
      v24[6] = v7;
      v24[7] = *(id *)(a1 + 48);
LABEL_25:
      v9[8] = *(void *)(a1 + 56);
      int v17 = v7;
      IDSTransportThreadAddBlock();

LABEL_26:
      return;
    case 5:
      if (v5) {
        CFErrorRef v7 = nw_error_copy_cf_error(v5);
      }
      else {
        CFErrorRef v7 = 0;
      }
      char v9 = v18;
      v18[0] = _NSConcreteStackBlock;
      v18[1] = 3221225472;
      v18[2] = sub_10035F300;
      v18[3] = &unk_100989FB0;
      int v19 = 5;
      void v18[4] = *(id *)(a1 + 32);
      int v20 = *(_DWORD *)(a1 + 64);
      v18[5] = *(id *)(a1 + 40);
      v18[6] = v7;
      v18[7] = *(id *)(a1 + 48);
      goto LABEL_25;
    default:
      goto LABEL_26;
  }
}

void sub_10035E07C(uint64_t a1)
{
  uint64_t v2 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(_DWORD *)(a1 + 72);
    uint64_t v4 = *(void **)(a1 + 32);
    int v5 = [*(id *)(a1 + 40) addressPair];
    id v6 = [v5 shortDescription];
    uint64_t v7 = *(void *)(a1 + 48);
    CFErrorRef v8 = [*(id *)(a1 + 40) connectionID];
    uint64_t v9 = *(void *)(a1 + 56);
    *(_DWORD *)long long buf = 134219522;
    uint64_t v65 = v4;
    __int16 v66 = 2112;
    uint64_t v67 = v4;
    __int16 v68 = 1024;
    int v69 = v3;
    __int16 v70 = 2112;
    id v71 = v6;
    __int16 v72 = 2112;
    uint64_t v73 = v7;
    __int16 v74 = 2112;
    uint64_t v75 = v8;
    __int16 v76 = 2114;
    uint64_t v77 = v9;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "connect ready for nw_connection (%p) %@ {socket:%d} (ports[%@]), event error: %@, connection[%@], device[%{public}@]", buf, 0x44u);
  }
  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      uint64_t v10 = *(void *)(a1 + 32);
      uint64_t v11 = *(unsigned int *)(a1 + 72);
      int v12 = [*(id *)(a1 + 40) addressPair];
      id v13 = [v12 shortDescription];
      uint64_t v14 = *(void *)(a1 + 48);
      uint64_t v52 = [*(id *)(a1 + 40) connectionID];
      uint64_t v53 = *(void *)(a1 + 56);
      uint64_t v50 = v13;
      uint64_t v51 = v14;
      uint64_t v48 = v10;
      uint64_t v49 = v11;
      uint64_t v46 = v10;
      _IDSLogTransport();

      if (_IDSShouldLog())
      {
        uint64_t v15 = *(void *)(a1 + 32);
        uint64_t v16 = *(unsigned int *)(a1 + 72);
        int v17 = objc_msgSend(*(id *)(a1 + 40), "addressPair", v46, v48, v49, v13, v14, v52, v53);
        unsigned int v18 = [v17 shortDescription];
        uint64_t v19 = *(void *)(a1 + 48);
        uint64_t v52 = [*(id *)(a1 + 40) connectionID];
        uint64_t v53 = *(void *)(a1 + 56);
        uint64_t v50 = v18;
        uint64_t v51 = v19;
        uint64_t v48 = v15;
        uint64_t v49 = v16;
        uint64_t v46 = v15;
        _IDSLogV();
      }
    }
  }
  int v20 = objc_msgSend(*(id *)(a1 + 40), "serviceConnection", v46, v48, v49, v50, v51, v52, v53);
  if (v20)
  {
    unsigned int v21 = [*(id *)(a1 + 40) serviceConnection];
    BOOL v22 = v21 == *(void **)(a1 + 32);

    if (!v22)
    {
      int v23 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        int v24 = [*(id *)(a1 + 40) serviceConnection];
        int v25 = [*(id *)(a1 + 40) serviceConnection];
        *(_DWORD *)long long buf = 134218242;
        uint64_t v65 = v24;
        __int16 v66 = 2112;
        uint64_t v67 = v25;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Enabled new connection, cancelling previous instance (%p) %@", buf, 0x16u);
      }
      uint64_t v26 = [*(id *)(a1 + 40) serviceConnection];
      nw_connection_cancel(v26);

      if (([*(id *)(a1 + 40) sd] & 0x80000000) == 0)
      {
        close((int)[*(id *)(a1 + 40) sd]);
        [*(id *)(a1 + 40) setSd:0xFFFFFFFFLL];
      }
      [*(id *)(a1 + 40) setServiceConnection:0];
    }
  }
  [*(id *)(a1 + 40) setServiceConnection:*(void *)(a1 + 32)];
  if ([*(id *)(a1 + 40) didInvalidate])
  {
    id v27 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      long long v28 = *(void **)(a1 + 40);
      *(_DWORD *)long long buf = 138412290;
      uint64_t v65 = v28;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "This connection %@ has already been invalidated. Calling _closeSockets.", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        uint64_t v47 = *(void *)(a1 + 40);
        _IDSLogTransport();
        if (_IDSShouldLog())
        {
          uint64_t v47 = *(void *)(a1 + 40);
          _IDSLogV();
        }
      }
    }
    objc_msgSend(*(id *)(a1 + 40), "_closeSockets", v47);
    __int16 v29 = [*(id *)(a1 + 40) openSocketCompletionHandler];
    uint64_t v30 = [*(id *)(a1 + 40) openSocketCompletionHandler];

    if (v30)
    {
      char v31 = (id *)(a1 + 40);
      [*(id *)(a1 + 40) setOpenSocketCompletionHandler:0];
      objc_msgSend(*(id *)(a1 + 40), "setStateFlags:", objc_msgSend(*(id *)(a1 + 40), "stateFlags") | 2);
      unsigned int v32 = [*(id *)(a1 + 56) vifName];
      BOOL v33 = +[NSString stringWithFormat:@"%@: Connection (%@) was invalidated.", v32, *(void *)(a1 + 40)];

      uint64_t v34 = +[NSDictionary dictionaryWithObject:v33 forKey:NSLocalizedDescriptionKey];
      id v35 = +[NSError errorWithDomain:@"IDSUTun" code:5503 userInfo:v34];

      char v36 = [*v31 completionQueue];
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10035E830;
      block[3] = &unk_10097E818;
      id v62 = v35;
      id v63 = v29;
      id v37 = v35;
      dispatch_async(v36, block);
    }
  }
  else
  {
    uint64_t v38 = [*(id *)(a1 + 40) openSocketCompletionHandler];

    if (v38)
    {
      objc_msgSend(*(id *)(a1 + 40), "setStateFlags:", objc_msgSend(*(id *)(a1 + 40), "stateFlags") | 2);
      unsigned __int16 v39 = [*(id *)(a1 + 40) openSocketCompletionHandler];
      [*(id *)(a1 + 40) setOpenSocketCompletionHandler:0];
      int v40 = *(_DWORD *)(a1 + 72);
      [*(id *)(a1 + 40) socketTrafficClass];
      int v41 = TrafficClassForIDSOpenSocketPriorityLevel();
      sub_10035E880(v40, v41);
      if ([*(id *)(a1 + 40) shouldSetAllowlistUUIDForStreamingSocket]) {
        sub_10035E9F0(*(_DWORD *)(a1 + 72));
      }
      int v42 = [*(id *)(a1 + 40) completionQueue];
      v54[0] = _NSConcreteStackBlock;
      v54[1] = 3221225472;
      v54[2] = sub_10035EB74;
      v54[3] = &unk_100989F38;
      id v58 = v39;
      id v43 = *(id *)(a1 + 56);
      int v60 = *(_DWORD *)(a1 + 72);
      uint64_t v44 = *(void *)(a1 + 64);
      id v55 = v43;
      uint64_t v59 = v44;
      id v56 = *(id *)(a1 + 32);
      id v57 = *(id *)(a1 + 48);
      id v45 = v39;
      dispatch_async(v42, v54);
    }
    else
    {
      if (([*(id *)(a1 + 40) sd] & 0x80000000) == 0) {
        close((int)[*(id *)(a1 + 40) sd]);
      }
      [*(id *)(a1 + 40) setSd:*(unsigned int *)(a1 + 72)];
      [*(id *)(a1 + 40) setConnectError:*(void *)(a1 + 48)];
    }
  }
}

uint64_t sub_10035E830(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void, void, uint64_t, void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), 0, 0, 0, 0, 0xFFFFFFFFLL, 0, 0, *(void *)(a1 + 32));
}

void sub_10035E880(int a1, int a2)
{
  int v10 = a2;
  if (a1 != -1)
  {
    if (setsockopt(a1, 0xFFFF, 4230, &v10, 4u))
    {
      int v3 = *__error();
      uint64_t v4 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        int v5 = v10;
        id v6 = strerror(v3);
        *(_DWORD *)long long buf = 67109890;
        int v12 = a1;
        __int16 v13 = 1024;
        int v14 = v5;
        __int16 v15 = 1024;
        int v16 = v3;
        __int16 v17 = 2080;
        unsigned int v18 = v6;
        uint64_t v7 = "setsockopt on socket (%d) failed for traffic class (%d), (error=%d: %s).";
        CFErrorRef v8 = v4;
        uint32_t v9 = 30;
LABEL_7:
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, buf, v9);
      }
    }
    else
    {
      uint64_t v4 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109376;
        int v12 = a1;
        __int16 v13 = 1024;
        int v14 = v10;
        uint64_t v7 = "setsockopt on socket (%d) succeeded for traffic class (%d).";
        CFErrorRef v8 = v4;
        uint32_t v9 = 14;
        goto LABEL_7;
      }
    }
  }
}

void sub_10035E9F0(int a1)
{
  if (a1 != -1)
  {
    v15[0] = 0;
    v15[1] = 0;
    id v2 = objc_alloc((Class)NSUUID);
    id v3 = [v2 initWithUUIDString:NRParametersWhitelistedAppUUIDString];
    [v3 getUUIDBytes:v15];
    if (setsockopt(a1, 0xFFFF, 4360, v15, 0x10u))
    {
      int v4 = *__error();
      int v5 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        int v9 = 67109634;
        int v10 = a1;
        __int16 v11 = 1024;
        int v12 = v4;
        __int16 v13 = 2080;
        int v14 = strerror(v4);
        id v6 = "setsockopt on socket (%d) failed for delegated uuid (error=%d: %s).";
        uint64_t v7 = v5;
        uint32_t v8 = 24;
LABEL_7:
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v9, v8);
      }
    }
    else
    {
      int v5 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        int v9 = 67109120;
        int v10 = a1;
        id v6 = "setsockopt on socket (%d) succeeded for delegated uuid";
        uint64_t v7 = v5;
        uint32_t v8 = 8;
        goto LABEL_7;
      }
    }
  }
}

void sub_10035EB74(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  id v3 = [*(id *)(a1 + 32) controlChannelVersion];
  (*(void (**)(uint64_t, id, id, id, id, void, void, void, void))(v2 + 16))(v2, v3, [*(id *)(a1 + 32) capabilityFlags], objc_msgSend(*(id *)(a1 + 32), "instanceID"), objc_msgSend(*(id *)(a1 + 32), "serviceMinCompatibilityVersion"), *(unsigned int *)(a1 + 72), *(void *)(a1 + 64), *(void *)(a1 + 40), *(void *)(a1 + 48));
}

void sub_10035EC1C(uint64_t a1)
{
  uint64_t v2 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = nw_connection_state_to_string();
    int v4 = *(_DWORD *)(a1 + 76);
    int v5 = *(void **)(a1 + 32);
    id v6 = [*(id *)(a1 + 40) addressPair];
    id v7 = [v6 shortDescription];
    uint64_t v8 = *(void *)(a1 + 48);
    int v9 = [*(id *)(a1 + 40) connectionID];
    uint64_t v10 = *(void *)(a1 + 56);
    *(_DWORD *)long long buf = 136316930;
    uint64_t v58 = v3;
    __int16 v59 = 2048;
    int v60 = v5;
    __int16 v61 = 2112;
    id v62 = v5;
    __int16 v63 = 1024;
    int v64 = v4;
    __int16 v65 = 2112;
    id v66 = v7;
    __int16 v67 = 2112;
    uint64_t v68 = v8;
    __int16 v69 = 2112;
    __int16 v70 = v9;
    __int16 v71 = 2114;
    uint64_t v72 = v10;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "connection event %s for nw_connection (%p) %@ {socket:%d} (ports[%@]), event error: %@, connection[%@], device[%{public}@]", buf, 0x4Eu);
  }
  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      uint64_t v11 = nw_connection_state_to_string();
      uint64_t v12 = *(void *)(a1 + 32);
      uint64_t v13 = *(unsigned int *)(a1 + 76);
      int v14 = [*(id *)(a1 + 40) addressPair];
      __int16 v15 = [v14 shortDescription];
      uint64_t v16 = *(void *)(a1 + 48);
      uint64_t v49 = [*(id *)(a1 + 40) connectionID];
      uint64_t v50 = *(void *)(a1 + 56);
      uint64_t v47 = v15;
      uint64_t v48 = v16;
      uint64_t v44 = v12;
      uint64_t v46 = v13;
      uint64_t v41 = v11;
      uint64_t v42 = v12;
      _IDSLogTransport();

      if (_IDSShouldLog())
      {
        uint64_t v17 = nw_connection_state_to_string();
        uint64_t v18 = *(void *)(a1 + 32);
        uint64_t v19 = *(unsigned int *)(a1 + 76);
        int v20 = objc_msgSend(*(id *)(a1 + 40), "addressPair", v41, v42, v44, v46, v15, v16, v49, v50);
        unsigned int v21 = [v20 shortDescription];
        uint64_t v22 = *(void *)(a1 + 48);
        uint64_t v49 = [*(id *)(a1 + 40) connectionID];
        uint64_t v50 = *(void *)(a1 + 56);
        uint64_t v47 = v21;
        uint64_t v48 = v22;
        uint64_t v44 = v18;
        uint64_t v46 = v19;
        uint64_t v41 = v17;
        uint64_t v42 = v18;
        _IDSLogV();
      }
    }
  }
  int v23 = objc_msgSend(*(id *)(a1 + 40), "serviceConnection", v41, v42, v44, v46, v47, v48, v49, v50);
  if (!v23
    || ([*(id *)(a1 + 40) serviceConnection],
        int v24 = objc_claimAutoreleasedReturnValue(),
        BOOL v25 = v24 == *(void **)(a1 + 32),
        v24,
        v23,
        v25))
  {
    if (([*(id *)(a1 + 40) sd] & 0x80000000) == 0)
    {
      close((int)[*(id *)(a1 + 40) sd]);
      [*(id *)(a1 + 40) setSd:0xFFFFFFFFLL];
    }
    unsigned int v32 = [*(id *)(a1 + 56) vifName];
    char v31 = +[NSString stringWithFormat:@"%@: nw_connection %@ in bad state %s", v32, *(void *)(a1 + 32), nw_connection_state_to_string()];

    BOOL v33 = +[NSDictionary dictionaryWithObject:v31 forKey:NSLocalizedDescriptionKey];
    uint64_t v34 = +[NSError errorWithDomain:@"IDSUTun" code:5501 userInfo:v33];

    id v35 = [*(id *)(a1 + 40) openSocketCompletionHandler];

    if (v35)
    {
      objc_msgSend(*(id *)(a1 + 40), "setStateFlags:", objc_msgSend(*(id *)(a1 + 40), "stateFlags") | 2);
      char v36 = [*(id *)(a1 + 40) openSocketCompletionHandler];
      [*(id *)(a1 + 40) setOpenSocketCompletionHandler:0];
      id v37 = [*(id *)(a1 + 40) completionQueue];
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10035F254;
      block[3] = &unk_100989F88;
      id v54 = v36;
      id v38 = *(id *)(a1 + 56);
      int v56 = -1;
      uint64_t v39 = *(void *)(a1 + 64);
      id v52 = v38;
      uint64_t v55 = v39;
      id v53 = v34;
      id v40 = v36;
      dispatch_async(v37, block);
    }
    else
    {
      [*(id *)(a1 + 40) setSd:0xFFFFFFFFLL];
      [*(id *)(a1 + 40) setConnectError:v34];
    }
    nw_connection_cancel(*(nw_connection_t *)(a1 + 32));

    goto LABEL_21;
  }
  uint64_t v26 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v27 = *(void *)(a1 + 32);
    long long v28 = [*(id *)(a1 + 40) serviceConnection];
    __int16 v29 = *(void **)(a1 + 40);
    *(_DWORD *)long long buf = 134218498;
    uint64_t v58 = v27;
    __int16 v59 = 2048;
    int v60 = v28;
    __int16 v61 = 2112;
    id v62 = v29;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "serviceConnection (%p) not same as existing serviceConnection (%p) for genericConnection %@", buf, 0x20u);
  }
  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      uint64_t v30 = *(void *)(a1 + 32);
      id v43 = [*(id *)(a1 + 40) serviceConnection];
      uint64_t v45 = *(void *)(a1 + 40);
      _IDSLogTransport();

      if (_IDSShouldLog())
      {
        char v31 = objc_msgSend(*(id *)(a1 + 40), "serviceConnection", v30, v43, v45);
        _IDSLogV();
LABEL_21:
      }
    }
  }
}

void sub_10035F254(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id v3 = [*(id *)(a1 + 32) controlChannelVersion];
  (*(void (**)(uint64_t, id, id, id, id, void, void, void, void))(v2 + 16))(v2, v3, [*(id *)(a1 + 32) capabilityFlags], objc_msgSend(*(id *)(a1 + 32), "instanceID"), objc_msgSend(*(id *)(a1 + 32), "serviceMinCompatibilityVersion"), *(unsigned int *)(a1 + 64), *(void *)(a1 + 56), 0, *(void *)(a1 + 40));
}

void sub_10035F300(uint64_t a1)
{
  uint64_t v2 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = nw_connection_state_to_string();
    int v4 = *(_DWORD *)(a1 + 76);
    int v5 = *(void **)(a1 + 32);
    id v6 = [*(id *)(a1 + 40) addressPair];
    id v7 = [v6 shortDescription];
    uint64_t v8 = *(void *)(a1 + 48);
    int v9 = [*(id *)(a1 + 40) connectionID];
    uint64_t v10 = *(void *)(a1 + 56);
    *(_DWORD *)long long buf = 136316930;
    uint64_t v59 = v3;
    __int16 v60 = 2048;
    __int16 v61 = v5;
    __int16 v62 = 2112;
    __int16 v63 = v5;
    __int16 v64 = 1024;
    int v65 = v4;
    __int16 v66 = 2112;
    id v67 = v7;
    __int16 v68 = 2112;
    uint64_t v69 = v8;
    __int16 v70 = 2112;
    __int16 v71 = v9;
    __int16 v72 = 2114;
    uint64_t v73 = v10;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "connection event %s for nw_connection (%p) %@ {socket:%d} (ports[%@]), event error: %@, connection[%@], device[%{public}@]", buf, 0x4Eu);
  }
  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      uint64_t v11 = nw_connection_state_to_string();
      uint64_t v12 = *(void *)(a1 + 32);
      uint64_t v13 = *(unsigned int *)(a1 + 76);
      int v14 = [*(id *)(a1 + 40) addressPair];
      __int16 v15 = [v14 shortDescription];
      uint64_t v16 = *(void *)(a1 + 48);
      uint64_t v50 = [*(id *)(a1 + 40) connectionID];
      uint64_t v51 = *(void *)(a1 + 56);
      uint64_t v48 = v15;
      uint64_t v49 = v16;
      uint64_t v45 = v12;
      uint64_t v47 = v13;
      uint64_t v42 = v11;
      uint64_t v43 = v12;
      _IDSLogTransport();

      if (_IDSShouldLog())
      {
        uint64_t v17 = nw_connection_state_to_string();
        uint64_t v18 = *(void *)(a1 + 32);
        uint64_t v19 = *(unsigned int *)(a1 + 76);
        int v20 = objc_msgSend(*(id *)(a1 + 40), "addressPair", v42, v43, v45, v47, v15, v16, v50, v51);
        unsigned int v21 = [v20 shortDescription];
        uint64_t v22 = *(void *)(a1 + 48);
        uint64_t v50 = [*(id *)(a1 + 40) connectionID];
        uint64_t v51 = *(void *)(a1 + 56);
        uint64_t v48 = v21;
        uint64_t v49 = v22;
        uint64_t v45 = v18;
        uint64_t v47 = v19;
        uint64_t v42 = v17;
        uint64_t v43 = v18;
        _IDSLogV();
      }
    }
  }
  int v23 = objc_msgSend(*(id *)(a1 + 40), "openSocketCompletionHandler", v42, v43, v45, v47, v48, v49, v50, v51);
  BOOL v24 = v23 == 0;

  if (!v24)
  {
    BOOL v25 = [*(id *)(a1 + 40) serviceConnection];
    if (!v25
      || ([*(id *)(a1 + 40) serviceConnection],
          uint64_t v26 = objc_claimAutoreleasedReturnValue(),
          BOOL v27 = v26 == *(void **)(a1 + 32),
          v26,
          v25,
          v27))
    {
      uint64_t v34 = [*(id *)(a1 + 56) vifName];
      BOOL v33 = +[NSString stringWithFormat:@"%@: nw_connection %@ canceled", v34, *(void *)(a1 + 32)];

      id v35 = +[NSDictionary dictionaryWithObject:v33 forKey:NSLocalizedDescriptionKey];
      char v36 = +[NSError errorWithDomain:@"IDSUTun" code:5502 userInfo:v35];

      objc_msgSend(*(id *)(a1 + 40), "setStateFlags:", objc_msgSend(*(id *)(a1 + 40), "stateFlags") | 2);
      id v37 = [*(id *)(a1 + 40) openSocketCompletionHandler];
      [*(id *)(a1 + 40) setOpenSocketCompletionHandler:0];
      id v38 = [*(id *)(a1 + 40) completionQueue];
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10035F8E4;
      block[3] = &unk_100989F88;
      id v55 = v37;
      id v39 = *(id *)(a1 + 56);
      int v57 = -1;
      uint64_t v56 = *(void *)(a1 + 64);
      id v53 = v39;
      id v54 = v36;
      id v40 = v36;
      id v41 = v37;
      dispatch_async(v38, block);

      goto LABEL_17;
    }
    long long v28 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v29 = *(void *)(a1 + 32);
      uint64_t v30 = [*(id *)(a1 + 40) serviceConnection];
      char v31 = *(void **)(a1 + 40);
      *(_DWORD *)long long buf = 134218498;
      uint64_t v59 = v29;
      __int16 v60 = 2048;
      __int16 v61 = v30;
      __int16 v62 = 2112;
      __int16 v63 = v31;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "serviceConnection (%p) not same as existing serviceConnection (%p) for genericConnection %@", buf, 0x20u);
    }
    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        uint64_t v32 = *(void *)(a1 + 32);
        uint64_t v44 = [*(id *)(a1 + 40) serviceConnection];
        uint64_t v46 = *(void *)(a1 + 40);
        _IDSLogTransport();

        if (_IDSShouldLog())
        {
          BOOL v33 = objc_msgSend(*(id *)(a1 + 40), "serviceConnection", v32, v44, v46);
          _IDSLogV();
LABEL_17:
        }
      }
    }
  }
}

void sub_10035F8E4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id v3 = [*(id *)(a1 + 32) controlChannelVersion];
  (*(void (**)(uint64_t, id, id, id, id, void, void, void, void))(v2 + 16))(v2, v3, [*(id *)(a1 + 32) capabilityFlags], objc_msgSend(*(id *)(a1 + 32), "instanceID"), objc_msgSend(*(id *)(a1 + 32), "serviceMinCompatibilityVersion"), *(unsigned int *)(a1 + 64), *(void *)(a1 + 56), 0, *(void *)(a1 + 40));
}

void sub_10035F990(uint64_t a1)
{
  [*(id *)(a1 + 32) setSdOriginal:0xFFFFFFFFLL];
  socklen_t v65 = 4;
  int __errnum = -1431655766;
  int v2 = getsockopt(*(_DWORD *)(a1 + 64), 0xFFFF, 4103, &__errnum, &v65);
  id v3 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *(_DWORD *)(a1 + 64);
    int v5 = [*(id *)(a1 + 32) addressPair];
    id v6 = [v5 shortDescription];
    if (v2) {
      int v7 = -1;
    }
    else {
      int v7 = __errnum;
    }
    if (v2)
    {
      uint64_t v8 = "unknown";
    }
    else if (__errnum)
    {
      uint64_t v8 = strerror(__errnum);
    }
    else
    {
      uint64_t v8 = "no error";
    }
    int v9 = [*(id *)(a1 + 32) connectionID];
    uint64_t v10 = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 67110402;
    int v68 = v4;
    __int16 v69 = 2112;
    *(void *)__int16 v70 = v6;
    *(_WORD *)&v70[8] = 1024;
    *(_DWORD *)&v70[10] = v7;
    __int16 v71 = 2080;
    __int16 v72 = v8;
    __int16 v73 = 2112;
    __int16 v74 = v9;
    __int16 v75 = 2114;
    uint64_t v76 = v10;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "connect ready for {socket:%d} (ports[%@]), socket error: %d (%s), connection[%@], device[%{public}@]", buf, 0x36u);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
  {
    uint64_t v11 = *(unsigned int *)(a1 + 64);
    uint64_t v12 = [*(id *)(a1 + 32) addressPair];
    uint64_t v13 = [v12 shortDescription];
    uint64_t v14 = v2 ? 0xFFFFFFFFLL : __errnum;
    if (v2) {
      __int16 v15 = "unknown";
    }
    else {
      __int16 v15 = __errnum ? strerror(__errnum) : "no error";
    }
    id v55 = [*(id *)(a1 + 32) connectionID];
    uint64_t v56 = *(void *)(a1 + 40);
    uint64_t v53 = v14;
    id v54 = v15;
    uint64_t v51 = v11;
    id v52 = v13;
    _IDSLogTransport();

    if (_IDSShouldLog())
    {
      uint64_t v16 = *(unsigned int *)(a1 + 64);
      uint64_t v17 = objc_msgSend(*(id *)(a1 + 32), "addressPair", v51, v13, v14, v15, v55, v56);
      uint64_t v18 = [v17 shortDescription];
      if (v2) {
        uint64_t v19 = 0xFFFFFFFFLL;
      }
      else {
        uint64_t v19 = __errnum;
      }
      if (v2)
      {
        int v20 = "unknown";
      }
      else if (__errnum)
      {
        int v20 = strerror(__errnum);
      }
      else
      {
        int v20 = "no error";
      }
      id v55 = [*(id *)(a1 + 32) connectionID];
      uint64_t v56 = *(void *)(a1 + 40);
      uint64_t v53 = v19;
      id v54 = v20;
      uint64_t v51 = v16;
      id v52 = v18;
      _IDSLogV();
    }
  }
  unsigned int v21 = objc_msgSend(*(id *)(a1 + 32), "idsDeviceConnectionUUID", v51, v52, v53, v54, v55, v56);

  if (v21)
  {
    uint64_t v22 = +[IDSDeviceConnectionAWDMetrics sharedInstance];
    [*(id *)(a1 + 32) connectionInitTime];
    double v24 = v23;
    BOOL v25 = [*(id *)(a1 + 32) idsDeviceConnectionUUID];
    [v22 setConnectionInitTime:v25 forConnectionUUID:v24];
  }
  uint64_t v26 = *(unsigned int *)(a1 + 64);
  if (v2)
  {
    int __errnum = *__error();
    BOOL v27 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      int v68 = __errnum;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "getsockopt failed %d", buf, 8u);
    }
  }
  if (__errnum)
  {
    long long v28 = [*(id *)(a1 + 40) vifName];
    uint64_t v29 = +[NSString stringWithFormat:@"%@: socket failed (errno=%d)", v28, __errnum];

    uint64_t v30 = +[NSDictionary dictionaryWithObject:v29 forKey:NSLocalizedDescriptionKey];
    char v31 = +[NSError errorWithDomain:@"IDSUTun" code:5005 userInfo:v30];

    int v32 = *(_DWORD *)(a1 + 64);
    if (v32 != -1) {
      close(v32);
    }

    uint64_t v26 = 0xFFFFFFFFLL;
  }
  else
  {
    if ((v26 & 0x80000000) == 0)
    {
      if (([*(id *)(a1 + 32) sdCopy] & 0x80000000) == 0) {
        close((int)[*(id *)(a1 + 32) sdCopy]);
      }
      [*(id *)(a1 + 32) setSdCopy:dup(v26)];
      if (([*(id *)(a1 + 32) sdCopy] & 0x80000000) != 0)
      {
        __error();
        IDSAssertNonFatalErrnoWithSource();
      }
      else
      {
        BOOL v33 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v34 = [*(id *)(a1 + 32) sdCopy];
          uint64_t v35 = *(void *)(a1 + 32);
          *(_DWORD *)long long buf = 67109634;
          int v68 = v34;
          __int16 v69 = 1024;
          *(_DWORD *)__int16 v70 = v26;
          *(_WORD *)&v70[4] = 2112;
          *(void *)&v70[6] = v35;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "Saved sdCopy {socket:%d} of {socket:%d} in %@", buf, 0x18u);
        }
      }
    }
    char v31 = 0;
  }
  char v36 = *(void **)(*(void *)(a1 + 48) + 96);
  id v37 = [*(id *)(a1 + 40) cbuuid];
  id v38 = [v36 currentLinkType:v37];

  id v39 = [*(id *)(a1 + 32) openSocketCompletionHandler];

  if (v39)
  {
    objc_msgSend(*(id *)(a1 + 32), "setStateFlags:", objc_msgSend(*(id *)(a1 + 32), "stateFlags") | 2);
    id v40 = [*(id *)(a1 + 32) openSocketCompletionHandler];
    [*(id *)(a1 + 32) setOpenSocketCompletionHandler:0];
    if (qword_100A4C8A8 != -1) {
      dispatch_once(&qword_100A4C8A8, &stru_10098A438);
    }
    uint64_t v41 = mach_continuous_time();
    double v42 = *(double *)&qword_100A4C830;
    [*(id *)(a1 + 32) socketTrafficClass];
    int v43 = TrafficClassForIDSOpenSocketPriorityLevel();
    sub_10035E880(v26, v43);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1003601CC;
    block[3] = &unk_10098A000;
    double v62 = v42 * (double)v41;
    id v61 = v40;
    int8x16_t v57 = *(int8x16_t *)(a1 + 40);
    id v44 = (id)v57.i64[0];
    int8x16_t v59 = vextq_s8(v57, v57, 8uLL);
    int v64 = v26;
    id v63 = v38;
    id v60 = v31;
    id v45 = v40;
    dispatch_block_t v46 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, QOS_CLASS_USER_INTERACTIVE, 0, block);
    uint64_t v47 = [*(id *)(a1 + 32) completionQueue];
    dispatch_async(v47, v46);
  }
  else
  {
    if (([*(id *)(a1 + 32) sd] & 0x80000000) == 0) {
      close((int)[*(id *)(a1 + 32) sd]);
    }
    [*(id *)(a1 + 32) setSd:v26];
    [*(id *)(a1 + 32) setConnectError:v31];
  }
  if ([*(id *)(a1 + 56) isEqualToIgnoringCase:@"com.apple.private.alloy.phonecontinuity"])
  {
    uint64_t v48 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "Skipping header compression for phone continuity", buf, 2u);
    }
  }
  else if (!v31)
  {
    uint64_t v49 = [*(id *)(a1 + 32) compressionInfo];
    BOOL v50 = (uint64_t)[v49 state] < 2;

    if (v50) {
      [*(id *)(a1 + 48) startCompressionForConnection:*(void *)(a1 + 32) deviceConnectionInfo:*(void *)(a1 + 40)];
    }
  }
  IDSTransportThreadRemoveSocket();
}

void sub_1003601CC(uint64_t a1)
{
  if (qword_100A4C8A8 != -1) {
    dispatch_once(&qword_100A4C8A8, &stru_10098A438);
  }
  double v2 = *(double *)&qword_100A4C830 * (double)mach_continuous_time() - *(double *)(a1 + 64);
  id v3 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *(void *)(a1 + 32);
    *(_DWORD *)long long buf = 138412546;
    uint64_t v10 = v4;
    __int16 v11 = 2048;
    double v12 = v2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%@: openSocketCompletionHandler dispatch time %0.6lf seconds", buf, 0x16u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      double v8 = v2;
      uint64_t v7 = *(void *)(a1 + 32);
      _IDSLogTransport();
      if (_IDSShouldLog())
      {
        double v8 = v2;
        uint64_t v7 = *(void *)(a1 + 32);
        _IDSLogV();
      }
    }
  }
  uint64_t v5 = *(void *)(a1 + 56);
  id v6 = objc_msgSend(*(id *)(a1 + 40), "controlChannelVersion", v7, *(void *)&v8);
  (*(void (**)(uint64_t, void *, id, id, id, void, void, void, void))(v5 + 16))(v5, v6, [*(id *)(a1 + 40) capabilityFlags], objc_msgSend(*(id *)(a1 + 40), "instanceID"), objc_msgSend(*(id *)(a1 + 40), "serviceMinCompatibilityVersion"), *(unsigned int *)(a1 + 80), *(void *)(a1 + 72), 0, *(void *)(a1 + 48));
}

void sub_1003603E4(id *a1)
{
  if (([a1[4] stateFlags] & 1) == 0
    && ([a1[4] didInvalidate] & 1) == 0)
  {
    double v2 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      id v3 = a1[4];
      *(_DWORD *)long long buf = 138412546;
      uint64_t v22 = v3;
      __int16 v23 = 2112;
      double v24 = &off_1009D1E00;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "openSocket was never called on connection (%@) within %@ seconds of starting it.  Kill the connection!", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        id v19 = a1[4];
        int v20 = &off_1009D1E00;
        _IDSLogTransport();
        if (_IDSShouldLog())
        {
          id v19 = a1[4];
          int v20 = &off_1009D1E00;
          _IDSLogV();
        }
      }
    }
    uint64_t v4 = objc_msgSend(a1[4], "connectionID", v19, v20);
    uint64_t v5 = [a1[4] localConnectionGUID];
    id v6 = [a1[4] remoteConnectionGUID];
    uint64_t v7 = [v4 account];
    double v8 = [v4 service];
    int v9 = [v4 name];
    sub_100360720(v5, v6, v7, v8, v9);
    uint64_t v10 = (_UNKNOWN **)objc_claimAutoreleasedReturnValue();

    if (v10)
    {
      __int16 v11 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        double v12 = [a1[5] vifName];
        id v13 = a1[4];
        *(_DWORD *)long long buf = 138412802;
        uint64_t v22 = v12;
        __int16 v23 = 2112;
        double v24 = v10;
        __int16 v25 = 2112;
        id v26 = v13;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%@: close channel control message [%@] created for connection %@", buf, 0x20u);
      }
      uint64_t v14 = [a1[5] controlChannel];
      [v14 sendMessage:v10];
    }
    id v15 = a1[6];
    id v16 = [a1[5] portMap];
    uint64_t v17 = [a1[4] addressPair];
    uint64_t v18 = [v17 localAddress];
    objc_msgSend(v15, "releasePortIfNecessary:port:", v16, objc_msgSend(v18, "saPortHostOrder"));

    [a1[6] removeConnection:a1[4], a1[5], 5104, @"openSocket was never called, closing connection" fromDeviceConnectionInfo removeCode removeReason];
  }
}

id sub_100360720(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  if (a1)
  {
    id v11 = a1;
    id v12 = a5;
    id v13 = a4;
    BOOL v27 = (const char *)[v11 UTF8String];
    unsigned __int16 v14 = strlen(v27);
    if (v9)
    {
      id v26 = (const char *)[v9 UTF8String];
      unsigned int v15 = (unsigned __int16)strlen(v26);
    }
    else
    {
      id v26 = 0;
      unsigned int v15 = 0;
    }
    id v28 = v10;
    uint64_t v17 = (const char *)[v10 UTF8String];
    unsigned __int16 v18 = strlen(v17);
    id v19 = v13;
    int v20 = (const char *)[v19 UTF8String];

    unsigned __int16 v21 = strlen(v20);
    id v22 = v12;
    __int16 v23 = (const char *)[v22 UTF8String];

    unsigned __int16 v24 = strlen(v23);
    v29[0] = 3;
    v29[1] = HIBYTE(v14);
    v29[2] = v14;
    v29[3] = BYTE1(v15);
    v29[4] = v15;
    v29[5] = HIBYTE(v18);
    v29[6] = v18;
    v29[7] = HIBYTE(v21);
    v29[8] = v21;
    v29[9] = HIBYTE(v24);
    v29[10] = v24;
    id v16 = objc_alloc_init((Class)NSMutableData);
    [v16 appendBytes:v29 length:11];
    if (v14) {
      [v16 appendBytes:v27 length:v14];
    }
    if (v15) {
      [v16 appendBytes:v26 length:v15];
    }
    objc_msgSend(v16, "appendBytes:length:", v17, v18, v26);
    [v16 appendBytes:v20 length:v21];
    [v16 appendBytes:v23 length:v24];
    id v10 = v28;
  }
  else
  {
    id v16 = 0;
  }

  return v16;
}

void sub_100360F5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,id location)
{
  objc_destroyWeak(v25);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100360F80(uint64_t a1, void *a2, int a3, int a4, int a5, int a6)
{
  id v11 = a2;
  if (v11)
  {
    if (!*(unsigned char *)(a1 + 64))
    {
      id v12 = [*(id *)(a1 + 48) controlChannel];
      id v13 = [v12 deviceUniqueID];

      if (v13)
      {
        unsigned __int16 v14 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v15 = *(void **)(a1 + 40);
          *(_DWORD *)long long buf = 138412546;
          *(void *)&uint8_t buf[4] = v13;
          __int16 v53 = 2112;
          id v54 = v15;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Successfully decrypted control message, lock peer %@ for cbuuid %@.", buf, 0x16u);
        }

        id v16 = +[IDSUTunDeliveryController sharedInstance];
        [v16 lockContinuityPeer:v13 btUUID:*(void *)(a1 + 40)];
      }
    }
    uint64_t v17 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = *(void *)(a1 + 32);
      id v19 = *(void **)(a1 + 48);
      *(_DWORD *)long long buf = 134218498;
      *(void *)&uint8_t buf[4] = v18;
      __int16 v53 = 2112;
      id v54 = v11;
      __int16 v55 = 2112;
      uint64_t v56 = v19;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%p: control channel got message %@ device conn info:%@", buf, 0x20u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      id v46 = v11;
      uint64_t v47 = *(void *)(a1 + 48);
      uint64_t v45 = *(void *)(a1 + 32);
      _IDSLogV();
    }
    objc_msgSend(*(id *)(a1 + 32), "receiveControlChannelMessage:fromCbuuid:deviceUniqueID:", v11, *(void *)(a1 + 40), *(void *)(a1 + 56), v45, v46, v47);
    goto LABEL_42;
  }
  if (a4 && *(unsigned char *)(a1 + 64))
  {
    int v20 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "FairPlay authentication failed, obliterate device connection.", buf, 2u);
    }

    unsigned __int16 v21 = im_primary_queue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1003616A0;
    block[3] = &unk_10097E4D0;
    void block[4] = *(void *)(a1 + 32);
    dispatch_async(v21, block);

    goto LABEL_42;
  }
  if (a6)
  {
    id v22 = [*(id *)(a1 + 32) linkManager];
    [v22 triggerBTCorruptionRecoveryForCBUUID:*(void *)(a1 + 40)];
  }
  __int16 v23 = sub_1003F1964((uint64_t)[*(id *)(a1 + 48) connectionsTableByLocalRemotePortKey], 67109888);
  [*(id *)(a1 + 32) resetTCPConnection:v23 forDeviceConnectionInfo:*(void *)(a1 + 48)];
  if (a3) {
    [*(id *)(a1 + 32) resetAllConnectionsForDevice:*(void *)(a1 + 48)];
  }
  unsigned int v24 = [*(id *)(a1 + 48) linkLayerConnected];
  __int16 v25 = +[IDSDevicePolicyController sharedInstance];
  unsigned int v26 = [v25 shouldBlackOutDeviceWithCbuuid:*(void *)(a1 + 40)];

  if (v26)
  {
    BOOL v27 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      id v28 = *(void **)(a1 + 56);
      uint64_t v29 = *(void *)(a1 + 40);
      uint64_t v30 = [*(id *)(a1 + 48) controlChannel];
      char v31 = [v30 deviceUniqueID];
      *(_DWORD *)long long buf = 138412802;
      *(void *)&uint8_t buf[4] = v29;
      __int16 v53 = 2112;
      id v54 = v28;
      __int16 v55 = 2112;
      uint64_t v56 = v31;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Device %@/%@ (CC:%@) is blacked out due to fairplay failures", buf, 0x20u);
    }
    int v32 = [*(id *)(a1 + 32) linkManager];
    [v32 stopLinkForDeviceUniqueID:*(void *)(a1 + 56) cbuuid:*(void *)(a1 + 40) disconnectWP:1];

    goto LABEL_29;
  }
  if (!v24)
  {
LABEL_29:
    BOOL v33 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v34 = *(void *)(a1 + 40);
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v34;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "Add a block for control channel reestablishment on link connects for %@", buf, 0xCu);
    }

    *(void *)long long buf = 0xAAAAAAAAAAAAAAAALL;
    objc_initWeak((id *)buf, *(id *)(a1 + 48));
    uint64_t v35 = *(void **)(a1 + 48);
    v48[0] = _NSConcreteStackBlock;
    v48[1] = 3221225472;
    v48[2] = sub_10036171C;
    v48[3] = &unk_10098A050;
    objc_copyWeak(v49, (id *)buf);
    v48[4] = *(void *)(a1 + 32);
    [v35 addBlocksOnLinkConnect:v48];
    objc_destroyWeak(v49);
    objc_destroyWeak((id *)buf);
    goto LABEL_32;
  }
  v49[1] = _NSConcreteStackBlock;
  v49[2] = (id)3221225472;
  v49[3] = sub_10036170C;
  v49[4] = &unk_100980D88;
  v49[5] = *(id *)(a1 + 32);
  id v50 = *(id *)(a1 + 48);
  IDSTransportThreadAddBlockAfter();

LABEL_32:
  if (!*(unsigned char *)(a1 + 64) && a5)
  {
    char v36 = [*(id *)(a1 + 48) controlChannel];
    id v37 = [v36 deviceUniqueID];

    id v38 = +[IDSUTunDeliveryController sharedInstance];
    id v39 = [v38 pendingContinuityPeerID:*(void *)(a1 + 40)];

    unsigned int v40 = [v37 isEqualToString:v39];
    uint64_t v41 = +[IDSFoundationLog utunController];
    BOOL v42 = os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT);
    if (v40)
    {
      if (v42)
      {
        uint64_t v43 = *(void *)(a1 + 56);
        id v44 = *(void **)(a1 + 40);
        *(_DWORD *)long long buf = 138412546;
        *(void *)&uint8_t buf[4] = v43;
        __int16 v53 = 2112;
        id v54 = v44;
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Failed to encrypt/decrypt control message with deviceUniqueID %@, try different peer for %@.", buf, 0x16u);
      }

      uint64_t v41 = +[IDSUTunDeliveryController sharedInstance];
      [v41 tryNextContinuityPeer:*(void *)(a1 + 40)];
    }
    else if (v42)
    {
      *(_DWORD *)long long buf = 138412546;
      *(void *)&uint8_t buf[4] = v37;
      __int16 v53 = 2112;
      id v54 = v39;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "deviceUniqueID mismatch (%@!=%@), ignore decryption error.", buf, 0x16u);
    }
  }
LABEL_42:
}

void sub_100361660(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 144));
  _Unwind_Resume(a1);
}

void sub_1003616A0(uint64_t a1)
{
  id v1 = *(void **)(a1 + 32);
  id v3 = +[IDSPairingManager sharedInstance];
  uint64_t v2 = [v3 pairedDeviceUUIDString];
  [v1 obliterateConnectionInfoForCBUUID:v2];
}

id sub_10036170C(uint64_t a1)
{
  return [*(id *)(a1 + 32) startControlChannelWithDevice:*(void *)(a1 + 40) endpoint:0];
}

uint64_t sub_10036171C(uint64_t a1, char a2, uint64_t a3)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v7 = WeakRetained;
  if (!a3 && (a2 & 1) == 0 && WeakRetained)
  {
    id v9 = WeakRetained;
    id WeakRetained = [*(id *)(a1 + 32) startControlChannelWithDevice:WeakRetained endpoint:0];
    id v7 = v9;
  }

  return _objc_release_x1(WeakRetained, v7);
}

void sub_100361794(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  if (!v5 && (a2 & 1) == 0)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));

    id v5 = 0;
    if (WeakRetained)
    {
      id v7 = objc_loadWeakRetained((id *)(a1 + 40));
      [*(id *)(a1 + 32) startControlChannelWithDevice:v7 endpoint:0];

      id v5 = 0;
    }
  }
}

id sub_100361AF4(uint64_t a1)
{
  uint64_t v2 = [[IDSLinkManager alloc] initWithDelegate:*(void *)(a1 + 32)];
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void **)(v3 + 96);
  *(void *)(v3 + 96) = v2;

  [*(id *)(*(void *)(a1 + 32) + 96) setRequireBT:*(unsigned __int8 *)(a1 + 40)];
  id v5 = *(void **)(*(void *)(a1 + 32) + 96);

  return [v5 start];
}

void sub_100361CE0(uint64_t a1, void *a2, __CFError *a3)
{
  id v5 = a2;
  id v6 = +[IDSFoundationLog utunController];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 134218754;
    id v15 = v5;
    __int16 v16 = 2112;
    id v17 = v5;
    __int16 v18 = 2112;
    id v19 = a3;
    __int16 v20 = 2080;
    uint64_t v21 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "nw_service_connector_start_request returned connection(%p) %@ error %@ for %s", buf, 0x2Au);
  }

  if (!a3) {
    goto LABEL_8;
  }
  int Code = CFErrorGetCode(a3);
  if (Code != 36)
  {
    if (Code == 17)
    {
      id v9 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        id v10 = "nw_service_connector_start_request returned EEXIST - exit";
LABEL_11:
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v10, buf, 2u);
        goto LABEL_12;
      }
      goto LABEL_12;
    }
LABEL_8:
    id v11 = a3;
    id v13 = *(id *)(a1 + 32);
    id v12 = v5;
    id v9 = v11;
    IDSTransportThreadAddBlock();

    goto LABEL_12;
  }
  id v9 = +[IDSFoundationLog utunController];
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    id v10 = "nw_service_connector_start_request returned EINPROGRESS - exit";
    goto LABEL_11;
  }
LABEL_12:
}

uint64_t sub_100361EF4(void *a1)
{
  return (*(uint64_t (**)(void, void, void, void, void, uint64_t, void, void, void))(a1[6] + 16))(a1[6], 0, 0, 0, 0, 0xFFFFFFFFLL, 0, a1[4], a1[5]);
}

void sub_100362A18(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    uint64_t v12 = 0;
    id v13 = &v12;
    uint64_t v14 = 0x2020000000;
    char v15 = 0;
    uint64_t v3 = *(void *)(a1 + 32) + 8;
    id v6 = _NSConcreteStackBlock;
    uint64_t v7 = 3221225472;
    double v8 = sub_100362BC4;
    id v9 = &unk_10098A100;
    id v10 = *(id *)(a1 + 40);
    id v11 = &v12;
    sub_1003F23AC(v3, (uint64_t)&v6);
    if (*((unsigned char *)v13 + 24))
    {
      uint64_t v4 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
        *(_DWORD *)long long buf = 138412546;
        uint64_t v17 = v5;
        __int16 v18 = 1024;
        int v19 = dword_100A44230;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "UTunController calling startControlChannelWithDevice for [%@] after %d seconds", buf, 0x12u);
      }

      [*(id *)(a1 + 32) startControlChannelWithDevice:*(void *)(a1 + 40) endpoint:0];
    }

    _Block_object_dispose(&v12, 8);
  }
}

void sub_100362BA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100362BC4(uint64_t result, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  if (*(void *)(result + 32) == a3)
  {
    *(unsigned char *)(*(void *)(*(void *)(result + 40) + 8) + 24) = 1;
    *a4 = 1;
  }
  return result;
}

void sub_100363484(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8, void *a9)
{
  id v11 = *(void **)(a1 + 32);
  uint64_t v12 = *(void *)(a1 + 40);
  uint64_t v13 = *(void *)(a1 + 48);
  id v14 = a9;
  id v15 = a8;
  [v11 prepareControlChannelForDeviceConnectionInfo:v12 genericConnection:v13];
  [*(id *)(a1 + 32) didConnectControlChannelForDeviceConnectionInfo:*(void *)(a1 + 40) connection:v15 error:v14];
}

void sub_100363514(id *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  id v11 = a9;
  uint64_t v12 = +[IDSFoundationLog utunController];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = [a1[4] cbuuid];
    *(_DWORD *)long long buf = 138412290;
    uint64_t v17 = v13;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "startControlChannelWithDevice - waiting for connect ready for %@", buf, 0xCu);
  }
  [a1[5] setSdNumberNoClose:a6];
  [a1[6] prepareControlChannelForDeviceConnectionInfo:a1[4] genericConnection:a1[5]];
  id v15 = a1[4];
  id v14 = v11;
  IDSTransportThreadAddSocket();
}

void sub_100363694(uint64_t a1)
{
  socklen_t v17 = 4;
  int __errnum = 0;
  int v2 = getsockopt(*(_DWORD *)(a1 + 56), 0xFFFF, 4103, &__errnum, &v17);
  uint64_t v3 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *(_DWORD *)(a1 + 56);
    if (v2) {
      int v5 = -1;
    }
    else {
      int v5 = __errnum;
    }
    if (v2)
    {
      id v6 = "unknown";
    }
    else if (__errnum)
    {
      id v6 = strerror(__errnum);
    }
    else
    {
      id v6 = "no error";
    }
    uint64_t v7 = *(void *)(a1 + 32);
    *(_DWORD *)long long buf = 67109890;
    int v20 = v4;
    __int16 v21 = 1024;
    *(_DWORD *)id v22 = v5;
    *(_WORD *)&v22[4] = 2080;
    *(void *)&v22[6] = v6;
    __int16 v23 = 2114;
    uint64_t v24 = v7;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "legacy control channel connect ready {socket:%d}, socket error: %d (%s), device[%{public}@]", buf, 0x22u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
  {
    if (!v2 && __errnum) {
      strerror(__errnum);
    }
    _IDSLogTransport();
    if (_IDSShouldLog())
    {
      if (!v2)
      {
        if (__errnum) {
          strerror(__errnum);
        }
      }
      _IDSLogV();
    }
  }
  if (v2)
  {
    int __errnum = *__error();
    double v8 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = __errnum;
      id v10 = strerror(__errnum);
      *(_DWORD *)long long buf = 67109378;
      int v20 = v9;
      __int16 v21 = 2080;
      *(void *)id v22 = v10;
      id v11 = "getsockopt failed %d / %s";
LABEL_27:
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v11, buf, 0x12u);
      goto LABEL_28;
    }
    goto LABEL_28;
  }
  if (__errnum)
  {
    double v8 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = __errnum;
      uint64_t v13 = strerror(__errnum);
      *(_DWORD *)long long buf = 67109378;
      int v20 = v12;
      __int16 v21 = 2080;
      *(void *)id v22 = v13;
      id v11 = "socket error %d / %s";
      goto LABEL_27;
    }
LABEL_28:

    IDSTransportThreadRemoveSocket();
    close(*(_DWORD *)(a1 + 56));
    id v14 = [*(id *)(a1 + 32) controlChannel];
    [v14 setConnecting:0];

    [*(id *)(a1 + 40) startControlChannelWithDevice:*(void *)(a1 + 32) endpoint:0];
    return;
  }
  IDSTransportThreadRemoveSocket();
  legacy_tcp_socket = (void *)nw_parameters_create_legacy_tcp_socket();
  nw_parameters_set_data_mode();
  __int16 v16 = (void *)nw_connection_create_with_connected_socket_and_parameters();
  [*(id *)(a1 + 40) didConnectControlChannelForDeviceConnectionInfo:*(void *)(a1 + 32) connection:v16 error:*(void *)(a1 + 48)];
}

uint64_t sub_1003648D0(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void, void, uint64_t, void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), 0, 0, 0, 0, 0xFFFFFFFFLL, 0, 0, *(void *)(a1 + 32));
}

void sub_10036676C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

uint64_t sub_100366794(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1003667A4(uint64_t a1)
{
}

void sub_1003667AC(uint64_t a1, uint64_t a2, void *a3, unsigned char *a4)
{
  id v10 = a3;
  uint64_t v7 = [v10 compressionInfo];
  unsigned int v8 = [v7 remoteCID];
  int v9 = *(unsigned __int16 *)(a1 + 40);

  if (v8 == v9)
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), a3);
    *a4 = 1;
  }
}

id sub_100367880(unsigned int a1, id a2, void *a3, void *a4, void *a5, void *a6)
{
  id v10 = a2;
  id v11 = a6;
  id v12 = a5;
  id v13 = a4;
  id v14 = a3;
  id v28 = (const char *)[v10 UTF8String];
  LODWORD(a4) = strlen(v28);
  id v15 = v14;
  __int16 v16 = (const char *)[v15 UTF8String];

  LODWORD(v15) = strlen(v16);
  id v17 = v13;
  __int16 v18 = (const char *)[v17 UTF8String];

  unsigned int v19 = strlen(v18);
  id v20 = v12;
  __int16 v21 = (const char *)[v20 UTF8String];

  unsigned int v22 = strlen(v21);
  id v23 = v11;
  uint64_t v24 = (const char *)[v23 UTF8String];

  unsigned int v25 = strlen(v24);
  LOWORD(v23) = v25;
  char v31 = 5;
  __int16 v32 = bswap32(a4) >> 16;
  __int16 v33 = bswap32(v15) >> 16;
  __int16 v34 = bswap32(v19) >> 16;
  __int16 v35 = bswap32(v22) >> 16;
  __int16 v36 = bswap32(v25) >> 16;
  __int16 v30 = __rev16(a1);
  id v26 = objc_alloc_init((Class)NSMutableData);
  [v26 appendBytes:&v31 length:11];
  [v26 appendBytes:&v30 length:2];
  [v26 appendBytes:v28 length:(unsigned __int16)a4];
  [v26 appendBytes:v16 length:(unsigned __int16)v15];
  [v26 appendBytes:v18 length:(unsigned __int16)v19];
  [v26 appendBytes:v21 length:(unsigned __int16)v22];
  [v26 appendBytes:v24 length:(unsigned __int16)v23];

  return v26;
}

void sub_10036C38C(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x10036B450);
  }
  _Unwind_Resume(a1);
}

id sub_10036C514(int a1)
{
  v6[0] = 11;
  if (a1) {
    char v2 = 3;
  }
  else {
    char v2 = 1;
  }
  v6[1] = v2;
  uint64_t v3 = +[NSData dataWithBytes:v6 length:2];
  int v4 = +[IDSFoundationLog utunController];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109634;
    int v8 = 1;
    __int16 v9 = 1024;
    int v10 = a1;
    __int16 v11 = 2112;
    id v12 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "sending control message: encrypt control channel (%d, %d) %@", buf, 0x18u);
  }

  return v3;
}

id sub_10036C62C(char a1, __int16 a2, __int16 a3, void *a4, void *a5, void *a6, void *a7, void *a8, char a9, uint64_t a10)
{
  id v16 = a5;
  id v17 = a6;
  if (a9) {
    char v18 = 13;
  }
  else {
    char v18 = 2;
  }
  char v35 = v18;
  id v19 = a4;
  id v20 = a8;
  id v21 = a7;
  id v37 = (const char *)[v19 UTF8String];
  unsigned __int16 v22 = strlen(v37);
  id v39 = v16;
  if (v16)
  {
    __int16 v34 = (const char *)[v16 UTF8String];
    unsigned int v23 = (unsigned __int16)strlen(v34);
  }
  else
  {
    __int16 v34 = 0;
    unsigned int v23 = 0;
  }
  id v38 = v17;
  uint64_t v24 = (const char *)[v38 UTF8String];
  unsigned __int16 v25 = strlen(v24);
  id v26 = v21;
  BOOL v27 = (const char *)[v26 UTF8String];

  unsigned __int16 v28 = strlen(v27);
  id v29 = v20;
  __int16 v30 = (const char *)[v29 UTF8String];

  unsigned __int16 v31 = strlen(v30);
  v41[0] = v35;
  v41[1] = a1;
  v41[2] = HIBYTE(a2);
  v41[3] = a2;
  v41[4] = HIBYTE(a3);
  v41[5] = a3;
  v41[6] = HIBYTE(v22);
  v41[7] = v22;
  v41[8] = BYTE1(v23);
  v41[9] = v23;
  v41[10] = HIBYTE(v25);
  v41[11] = v25;
  v41[12] = HIBYTE(v28);
  v41[13] = v28;
  v41[14] = HIBYTE(v31);
  v41[15] = v31;
  id v32 = objc_alloc_init((Class)NSMutableData);
  [v32 appendBytes:v41 length:16];
  [v32 appendBytes:v37 length:v22];
  if (v23) {
    [v32 appendBytes:v34 length:v23];
  }
  [v32 appendBytes:v24 length:v25];
  [v32 appendBytes:v27 length:v28];
  [v32 appendBytes:v30 length:v31];
  if (a9)
  {
    uint64_t v40 = a10;
    [v32 appendBytes:&v40 length:8];
  }

  return v32;
}

id sub_10036C8C4(char a1, __int16 a2, __int16 a3, void *a4, void *a5, void *a6, void *a7, void *a8, char a9, char a10, char a11, char a12, char a13, char a14, uint64_t a15, unsigned __int16 a16)
{
  id v21 = a5;
  id v22 = a6;
  id v23 = a4;
  id v24 = a8;
  id v25 = a7;
  BOOL v42 = (const char *)[v23 UTF8String];
  unsigned __int16 v26 = strlen(v42);
  uint64_t v43 = v21;
  if (v21)
  {
    id v38 = (const char *)[v21 UTF8String];
    unsigned int v27 = (unsigned __int16)strlen(v38);
  }
  else
  {
    unsigned int v27 = 0;
    id v38 = 0;
  }
  id v41 = v22;
  unsigned __int16 v28 = (const char *)[v41 UTF8String];
  unsigned __int16 v29 = strlen(v28);
  id v30 = v25;
  unsigned __int16 v31 = (const char *)[v30 UTF8String];

  unsigned __int16 v32 = strlen(v31);
  id v33 = v24;
  __int16 v34 = (const char *)[v33 UTF8String];

  unsigned __int16 v35 = strlen(v34);
  v44[0] = 6;
  v44[1] = a1;
  v44[2] = HIBYTE(a2);
  v44[3] = a2;
  v44[4] = HIBYTE(a3);
  v44[5] = a3;
  v44[6] = HIBYTE(v26);
  v44[7] = v26;
  v44[8] = BYTE1(v27);
  v44[9] = v27;
  v44[10] = HIBYTE(v29);
  v44[11] = v29;
  v44[12] = HIBYTE(v32);
  v44[13] = v32;
  v44[14] = HIBYTE(v35);
  v44[15] = v35;
  v44[16] = a12;
  v44[17] = a11;
  v44[18] = a10;
  v44[19] = a9;
  v44[20] = a14;
  v44[21] = a13;
  v44[22] = HIBYTE(a16);
  v44[23] = a16;
  id v36 = objc_alloc_init((Class)NSMutableData);
  [v36 appendBytes:v44 length:24];
  [v36 appendBytes:v42 length:v26];
  if (v27) {
    [v36 appendBytes:v38 length:v27];
  }
  objc_msgSend(v36, "appendBytes:length:", v28, v29, v38);
  [v36 appendBytes:v31 length:v32];
  [v36 appendBytes:v34 length:v35];
  [v36 appendBytes:a15 length:a16];

  return v36;
}

void sub_10036CB7C(uint64_t a1)
{
  unint64_t v2 = (unint64_t)[*(id *)(a1 + 32) capabilityFlags];
  uint64_t v3 = +[IDSPairingManager sharedInstance];
  int v4 = [*(id *)(a1 + 40) productBuildVersion];
  id v16 = [*(id *)(a1 + 40) productVersion];
  id v15 = [*(id *)(a1 + 40) productName];
  id v17 = [*(id *)(a1 + 40) pairingProtocolVersion];
  unsigned int v14 = [v17 unsignedIntValue];
  int v5 = [*(id *)(a1 + 40) minCompatibilityVersion];
  unsigned int v13 = [v5 unsignedIntValue];
  id v6 = [*(id *)(a1 + 40) maxCompatibilityVersion];
  id v7 = [v6 unsignedIntValue];
  int v8 = [*(id *)(a1 + 40) serviceMinCompatibilityVersion];
  unsigned __int16 v9 = (unsigned __int16)[v8 unsignedShortValue];
  int v10 = [*(id *)(a1 + 40) deviceUniqueID];
  __int16 v11 = [v10 UUIDString];
  LOWORD(v12) = v9;
  [v3 updatePairedDeviceBuildVersion:v4 productVersion:v16 productName:v15 pairingProtocolVersion:v14 minCompatibilityVersion:v13 maxCompatibilityVersion:v7 serviceMinCompatibilityVersion:v12 capabilityFlags:v2 deviceUniqueID:v11];

  if (_IDSSupportsDirectMessaging())
  {
    id v18 = +[IDSDaemon sharedInstance];
    [v18 processDirectMessagingCapability:(v2 >> 11) & 1];
  }
}

void sub_10036CD50(uint64_t a1)
{
  id v2 = +[IDSDaemon sharedInstance];
  [v2 processDirectMessagingInfo:*(void *)(a1 + 32)];
}

void sub_10036E31C(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) objectForKey:@"completionHandler"];
  id v2 = [*(id *)(a1 + 40) controlChannelVersion];
  (*((void (**)(id, void *, id, id, id, void, void, void, void))v3 + 2))(v3, v2, [*(id *)(a1 + 40) capabilityFlags], objc_msgSend(*(id *)(a1 + 40), "instanceID"), objc_msgSend(*(id *)(a1 + 40), "serviceMinCompatibilityVersion"), *(unsigned int *)(a1 + 64), *(void *)(a1 + 56), 0, *(void *)(a1 + 48));
}

void sub_10036E3DC(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) vifName];
  id v6 = +[NSString stringWithFormat:@"%@: openSocketWithOptions unable to allocate new port - cannot continue", v2];

  id v3 = +[NSDictionary dictionaryWithObject:v6 forKey:NSLocalizedDescriptionKey];
  int v4 = +[NSError errorWithDomain:@"IDSUTun" code:5201 userInfo:v3];

  int v5 = [*(id *)(a1 + 40) objectForKey:@"completionHandler"];
  ((void (**)(void, void, void, void, void, uint64_t, void, void, void *))v5)[2](v5, 0, 0, 0, 0, 0xFFFFFFFFLL, 0, 0, v4);
}

void sub_10036EBD8(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 96);
  id v3 = +[IDSFoundationLog utunController];
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      BOOL v5 = *(unsigned char *)(a1 + 48) == 0;
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v16) = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "setShouldStartBTForDefaultPairedDevice: %d", buf, 8u);
    }

    [*(id *)(*(void *)(a1 + 32) + 96) setShouldStartBTLinkManager:*(unsigned char *)(a1 + 48) == 0];
    uint64_t v6 = kIDSDefaultPairedDeviceID;
    id v3 = sub_1003F2080(*(void *)(a1 + 32) + 8, kIDSDefaultPairedDeviceID);
    if (v3)
    {
      id v7 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v16 = v3;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "_prepareConnectionInfoWithCBUUID: deviceConnectionInfo already exists %@", buf, 0xCu);
      }
    }
    else
    {
      int v8 = +[IDSPairingManager sharedInstance];
      unsigned int v9 = [v8 isPaired];

      if (v9)
      {
        id v7 = [*(id *)(a1 + 32) defaultPairedDeviceIdentityPair];
        int v10 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          id v16 = v7;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "localdevicecontroller is paired [%@]", buf, 0xCu);
        }
      }
      else
      {
        __int16 v11 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "checking localdevicecontroller not paired", buf, 2u);
        }

        uint64_t v12 = im_primary_queue();
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_10036EED4;
        block[3] = &unk_10097E4D0;
        void block[4] = *(void *)(a1 + 32);
        dispatch_async(v12, block);

        id v7 = 0;
      }
      id v13 = [*(id *)(a1 + 32) _prepareConnectionInfoWithCBUUID:v6 deviceUniqueID:*(void *)(a1 + 40) shouldUseIPsecLink:*(unsigned __int8 *)(a1 + 48) identityPair:v7 remoteDeviceEncryptionInfo:0];
    }
  }
  else if (v4)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "prepareDefaultPairedConnectionInfoWithDeviceUniqueID failed due to invalid linkManager", buf, 2u);
  }
}

void sub_10036EED4(uint64_t a1)
{
  uint64_t v2 = +[IDSPairingManager sharedInstance];
  [v2 addDelegate:*(void *)(a1 + 32)];

  id v3 = +[IDSPairingManager sharedInstance];
  unsigned int v4 = [v3 isPaired];

  if (v4)
  {
    BOOL v5 = *(void **)(a1 + 32);
    [v5 didUpdatePairedDevice:0];
  }
}

void sub_10036F218(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    id v3 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = *(void *)(a1 + 32);
      uint64_t v5 = *(void *)(a1 + 40);
      *(_DWORD *)long long buf = 138412546;
      *(void *)&uint8_t buf[4] = v4;
      __int16 v61 = 2112;
      uint64_t v62 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%@: openSocketWithOptions called with options [%@]", buf, 0x16u);
    }

    uint64_t v6 = sub_1003F2080(*(void *)(a1 + 48) + 8, *(void *)(a1 + 32));
    if (v6)
    {
      id v7 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = *(void *)(a1 + 64);
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Update deviceUniqueID for controlChannel %@", buf, 0xCu);
      }

      unsigned int v9 = [v6 controlChannel];
      [v9 setDeviceUniqueID:*(void *)(a1 + 64)];

      int v10 = [v6 controlChannel];
      [v10 setRemoteDeviceEncryptionInfo:*(void *)(a1 + 72)];
LABEL_8:

      unsigned int v11 = [v6 linkLayerConnected];
      if (*(unsigned char *)(a1 + 81)) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = *(unsigned char *)(a1 + 82) == 0;
      }
      id v20 = +[IDSDevicePolicyController sharedInstance];
      unsigned int v21 = [v20 shouldBlackOutDeviceWithCbuuid:*(void *)(a1 + 32)];

      if (v21)
      {
        id v22 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v23 = *(void *)(a1 + 32);
          uint64_t v24 = *(void *)(a1 + 64);
          *(_DWORD *)long long buf = 138412546;
          *(void *)&uint8_t buf[4] = v23;
          __int16 v61 = 2112;
          uint64_t v62 = v24;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Device %@/%@ is blacked out due to fairplay failures", buf, 0x16u);
        }

        [*(id *)(*(void *)(a1 + 48) + 96) stopLinkForDeviceUniqueID:*(void *)(a1 + 64) cbuuid:*(void *)(a1 + 32) disconnectWP:1];
        BOOL v12 = 0;
      }
      else if (v11)
      {
        [*(id *)(a1 + 48) setupDataConnectionWithDeviceConnectionInfo:v6 options:*(void *)(a1 + 40)];
        [*(id *)(a1 + 48) checkSuspendTrafficForDevice:v6 wait:0];
LABEL_32:
        id v37 = [*(id *)(a1 + 40) objectForKey:IDSOpenSocketOptionPhoneCallKey];
        BOOL v38 = v37 == 0;

        if (!v38) {
          [*(id *)(*(void *)(a1 + 48) + 96) setIsOnPhoneCall:1 forDeviceID:*(void *)(a1 + 32)];
        }
        goto LABEL_34;
      }
      unsigned __int8 v53 = 0;
      id v25 = [*(id *)(a1 + 40) objectForKey:@"account"];
      unsigned __int16 v26 = [*(id *)(a1 + 40) objectForKey:@"service"];
      unsigned int v27 = [*(id *)(a1 + 40) objectForKey:IDSOpenSocketOptionStreamNameKey];
      unsigned __int16 v28 = [*(id *)(a1 + 40) objectForKey:IDSOpenSocketOptionClientIDKey];
      unsigned __int16 v29 = +[IDSGenericConnectionID idWithAccount:v25 service:v26 name:v27];
      if (v12) {
        [*(id *)(*(void *)(a1 + 48) + 96) startLinkForDeviceUniqueID:*(void *)(a1 + 64) cbuuid:*(void *)(a1 + 32)];
      }
      [v6 cancelBlockOnLinkConnectWithID:v29 cancelSucceeded:&v53];
      int v30 = v53;
      BOOL v31 = v53 == 0;
      unsigned __int16 v32 = +[IDSFoundationLog utunController];
      BOOL v33 = os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT);
      if (v31)
      {
        if (v33)
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "Add a block for data channel setup on link connects.", buf, 2u);
        }

        *(void *)long long buf = 0xAAAAAAAAAAAAAAAALL;
        objc_initWeak((id *)buf, v6);
        v46[0] = _NSConcreteStackBlock;
        v46[1] = 3221225472;
        void v46[2] = sub_10036FB94;
        v46[3] = &unk_10098A1C8;
        objc_copyWeak(&v52, (id *)buf);
        id v47 = v29;
        id v48 = v28;
        id v49 = *(id *)(a1 + 32);
        id v35 = *(id *)(a1 + 40);
        uint64_t v36 = *(void *)(a1 + 48);
        id v50 = v35;
        uint64_t v51 = v36;
        [v6 addBlocksOnLinkConnect:v46];

        objc_destroyWeak(&v52);
        objc_destroyWeak((id *)buf);
      }
      else
      {
        if (v33)
        {
          uint64_t v34 = *(void *)(a1 + 40);
          *(_DWORD *)long long buf = 138412546;
          *(void *)&uint8_t buf[4] = v29;
          __int16 v61 = 2112;
          uint64_t v62 = v34;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "Canceled a previously scheduled openSocket for %@. Rescheduling openSocket with new options %@.", buf, 0x16u);
        }
      }
      if (v30) {
        goto LABEL_34;
      }
      goto LABEL_32;
    }
    if (*(unsigned char *)(a1 + 80))
    {
      id v13 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = *(void *)(a1 + 32);
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v14;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%@: openSocketWithOptions called for default paired device but no connectionInfo - aborting", buf, 0xCu);
      }

      id v15 = +[NSString stringWithFormat:@"%@: openSocketWithOptions called for default paired device but no connectionInfo - cannot continue", *(void *)(a1 + 32)];
      id v16 = +[NSDictionary dictionaryWithObject:v15 forKey:NSLocalizedDescriptionKey];
      id v17 = +[NSError errorWithDomain:@"IDSUTun" code:5255 userInfo:v16];

      id v18 = [*(id *)(a1 + 40) objectForKey:@"completionHandlerQueue"];
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10036FA94;
      block[3] = &unk_10097E440;
      id v58 = *(id *)(a1 + 40);
      id v59 = v17;
      id v19 = v17;
      dispatch_async(v18, block);
    }
    else
    {
      int v10 = [*(id *)(a1 + 56) objectForKeyedSubscript:IDSOpenSocketOptionUnauthenticatedIdentityPair];
      uint64_t v6 = [*(id *)(a1 + 48) _prepareConnectionInfoWithCBUUID:*(void *)(a1 + 32) deviceUniqueID:*(void *)(a1 + 64) shouldUseIPsecLink:0 identityPair:v10 remoteDeviceEncryptionInfo:*(void *)(a1 + 72)];
      if (v6) {
        goto LABEL_8;
      }
      id v39 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v40 = *(void *)(a1 + 32);
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v40;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "%@: openSocketWithOptions unable to create new device - cannot continue", buf, 0xCu);
      }

      id v41 = +[NSString stringWithFormat:@"%@: openSocketWithOptions unable to create new device - cannot continue", *(void *)(a1 + 32)];
      BOOL v42 = +[NSDictionary dictionaryWithObject:v41 forKey:NSLocalizedDescriptionKey];
      uint64_t v43 = +[NSError errorWithDomain:@"IDSUTun" code:5201 userInfo:v42];

      id v44 = [*(id *)(a1 + 40) objectForKey:@"completionHandlerQueue"];
      v54[0] = _NSConcreteStackBlock;
      v54[1] = 3221225472;
      v54[2] = sub_10036FB14;
      v54[3] = &unk_10097E440;
      id v55 = *(id *)(a1 + 40);
      id v56 = v43;
      id v45 = v43;
      dispatch_async(v44, v54);
    }
    uint64_t v6 = 0;
LABEL_34:
  }
}

void sub_10036FA70(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 128));
  _Unwind_Resume(a1);
}

void sub_10036FA94(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) objectForKey:@"completionHandler"];
  (*((void (**)(id, void, void, void, void, uint64_t, void, void, void))v2 + 2))(v2, 0, 0, 0, 0, 0xFFFFFFFFLL, 0, 0, *(void *)(a1 + 40));
}

void sub_10036FB14(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) objectForKey:@"completionHandler"];
  (*((void (**)(id, void, void, void, void, uint64_t, void, void, void))v2 + 2))(v2, 0, 0, 0, 0, 0xFFFFFFFFLL, 0, 0, *(void *)(a1 + 40));
}

void sub_10036FB94(uint64_t a1, int a2, void *a3, unsigned char *a4)
{
  id v7 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 72));
  if (WeakRetained)
  {
    if (v7)
    {
      if (([*(id *)(a1 + 32) isEqual:v7] & 1) != 0
        || [*(id *)(a1 + 40) isEqual:v7])
      {
        unsigned int v9 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v10 = *(void *)(a1 + 48);
          *(_DWORD *)long long buf = 138412290;
          uint64_t v30 = v10;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%@: scheduled openSocketWithOptions attempt canceled - closeSocket called", buf, 0xCu);
        }

        unsigned int v11 = +[NSString stringWithFormat:@"%@: scheduled openSocketWithOptions attempt canceled - closeSocket called", *(void *)(a1 + 48)];
        BOOL v12 = +[NSDictionary dictionaryWithObject:v11 forKey:NSLocalizedDescriptionKey];
        id v13 = +[NSError errorWithDomain:@"IDSUTun" code:5205 userInfo:v12];

        uint64_t v14 = [*(id *)(a1 + 56) objectForKey:@"completionHandlerQueue"];
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_10036FF4C;
        block[3] = &unk_10097E440;
        id v27 = *(id *)(a1 + 56);
        id v28 = v13;
        id v15 = v13;
        dispatch_async(v14, block);
        *a4 = 1;
      }
    }
    else if (a2)
    {
      id v16 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v17 = *(void *)(a1 + 48);
        *(_DWORD *)long long buf = 138412290;
        uint64_t v30 = v17;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%@: openSocketWithOptions attempt canceled - possibly obliteration", buf, 0xCu);
      }

      id v18 = +[NSString stringWithFormat:@"%@: openSocketWithOptions attempt canceled - possibly obliteration", *(void *)(a1 + 48)];
      id v19 = +[NSDictionary dictionaryWithObject:v18 forKey:NSLocalizedDescriptionKey];
      id v20 = +[NSError errorWithDomain:@"IDSUTun" code:5204 userInfo:v19];

      unsigned int v21 = [*(id *)(a1 + 56) objectForKey:@"completionHandlerQueue"];
      v23[0] = _NSConcreteStackBlock;
      v23[1] = 3221225472;
      v23[2] = sub_10036FFCC;
      v23[3] = &unk_10097E440;
      id v24 = *(id *)(a1 + 56);
      id v25 = v20;
      id v22 = v20;
      dispatch_async(v21, v23);
    }
    else
    {
      [*(id *)(a1 + 64) setupDataConnectionWithDeviceConnectionInfo:WeakRetained options:*(void *)(a1 + 56)];
      [*(id *)(a1 + 64) checkSuspendTrafficForDevice:WeakRetained wait:0];
    }
  }
}

void sub_10036FF4C(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) objectForKey:@"completionHandler"];
  (*((void (**)(id, void, void, void, void, uint64_t, void, void, void))v2 + 2))(v2, 0, 0, 0, 0, 0xFFFFFFFFLL, 0, 0, *(void *)(a1 + 40));
}

void sub_10036FFCC(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) objectForKey:@"completionHandler"];
  (*((void (**)(id, void, void, void, void, uint64_t, void, void, void))v2 + 2))(v2, 0, 0, 0, 0, 0xFFFFFFFFLL, 0, 0, *(void *)(a1 + 40));
}

void sub_1003700DC(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    id v3 = *(void **)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 40) + 8;
      v9[0] = _NSConcreteStackBlock;
      v9[1] = 3221225472;
      v9[2] = sub_1003701CC;
      v9[3] = &unk_10098A240;
      uint64_t v5 = v3;
      uint64_t v6 = *(void *)(a1 + 40);
      uint64_t v10 = v5;
      uint64_t v11 = v6;
      sub_1003F23AC(v4, (uint64_t)v9);
      id v7 = v10;
    }
    else
    {
      id v7 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        v8[0] = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "cleanupSocketsForClient: clientID is nil.", (uint8_t *)v8, 2u);
      }
    }
  }
}

void sub_1003701CC(uint64_t a1, void *a2, void *a3)
{
  id v30 = a2;
  id v4 = a3;
  uint64_t v5 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void **)(a1 + 32);
    *(_DWORD *)long long buf = 138412546;
    id v45 = v30;
    __int16 v46 = 2112;
    id v47 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Device %@: utun cleaning up device connection for clientID: %@", buf, 0x16u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      id v28 = v30;
      uint64_t v29 = *(void *)(a1 + 32);
      _IDSLogTransport();
      if (_IDSShouldLog())
      {
        id v28 = v30;
        uint64_t v29 = *(void *)(a1 + 32);
        _IDSLogV();
      }
    }
  }
  id v7 = v4;
  char v43 = 0;
  [v7 cancelBlockOnLinkConnectWithID:*(void *)(a1 + 32) cancelSucceeded:&v43];
  id v8 = objc_alloc_init((Class)NSMutableArray);
  id v9 = [v7 connectionsTableByLocalRemotePortKey];
  v39[0] = _NSConcreteStackBlock;
  v39[1] = 3221225472;
  v39[2] = sub_100370688;
  v39[3] = &unk_10098A218;
  id v40 = *(id *)(a1 + 32);
  id v10 = v7;
  id v41 = v10;
  id v11 = v8;
  id v42 = v11;
  sub_1003F1C58((uint64_t)v9, (uint64_t)v39);
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  id obj = v11;
  id v34 = [obj countByEnumeratingWithState:&v35 objects:v50 count:16];
  if (v34)
  {
    uint64_t v32 = *(void *)v36;
    do
    {
      for (uint64_t i = 0; i != v34; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v36 != v32) {
          objc_enumerationMutation(obj);
        }
        id v13 = *(void **)(*((void *)&v35 + 1) + 8 * i);
        uint64_t v14 = objc_msgSend(v13, "connectionID", v28, v29);
        id v15 = [v13 localConnectionGUID];
        id v16 = [v13 remoteConnectionGUID];
        uint64_t v17 = [v14 account];
        id v18 = [v14 service];
        id v19 = [v14 name];
        id v20 = sub_100360720(v15, v16, v17, v18, v19);

        if (v20)
        {
          unsigned int v21 = +[IDSFoundationLog utunController];
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            id v22 = [v10 vifName];
            *(_DWORD *)long long buf = 138412802;
            id v45 = v22;
            __int16 v46 = 2112;
            id v47 = v20;
            __int16 v48 = 2112;
            id v49 = v13;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%@: close channel control message [%@] created for connection %@", buf, 0x20u);
          }
          uint64_t v23 = [v10 controlChannel];
          [v23 sendMessage:v20];
        }
        id v24 = *(void **)(a1 + 40);
        id v25 = [v10 portMap];
        unsigned __int16 v26 = [v13 addressPair];
        id v27 = [v26 localAddress];
        objc_msgSend(v24, "releasePortIfNecessary:port:", v25, objc_msgSend(v27, "saPortHostOrder"));

        [*(id *)(a1 + 40) removeConnection:v13 fromDeviceConnectionInfo:v10 removeCode:5030 removeReason:@"Cleaning up all connections for service"];
      }
      id v34 = [obj countByEnumeratingWithState:&v35 objects:v50 count:16];
    }
    while (v34);
  }
}

void sub_100370688(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  uint64_t v5 = [v4 clientID];
  unsigned int v6 = [v5 isEqualToIgnoringCase:*(void *)(a1 + 32)];

  if (v6)
  {
    id v7 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void *)(a1 + 32);
      uint64_t v9 = *(void *)(a1 + 40);
      id v10 = [v4 connectionID];
      id v11 = [v10 service];
      *(_DWORD *)long long buf = 138412802;
      uint64_t v22 = v9;
      __int16 v23 = 2112;
      uint64_t v24 = v8;
      __int16 v25 = 2112;
      unsigned __int16 v26 = v11;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "utun cleaning up device connection info: %@, clientID: %@, connection for service %@", buf, 0x20u);
    }
    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        uint64_t v13 = *(void *)(a1 + 32);
        uint64_t v12 = *(void *)(a1 + 40);
        uint64_t v14 = [v4 connectionID];
        [v14 service];
        v20 = uint64_t v19 = v13;
        uint64_t v18 = v12;
        _IDSLogTransport();

        if (_IDSShouldLog())
        {
          uint64_t v16 = *(void *)(a1 + 32);
          uint64_t v15 = *(void *)(a1 + 40);
          uint64_t v17 = objc_msgSend(v4, "connectionID", v18, v19, v20);
          [v17 service];
          v20 = uint64_t v19 = v16;
          uint64_t v18 = v15;
          _IDSLogV();
        }
      }
    }
    objc_msgSend(*(id *)(a1 + 48), "addObject:", v4, v18, v19, v20);
  }
}

void sub_100370984(id *a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    id v3 = a1 + 4;
    id v4 = [a1[4] objectForKey:IDSOpenSocketOptionCBUUIDKey];
    uint64_t v22 = [*v3 objectForKey:IDSOpenSocketOptionDeviceUniqueIDKey];
    uint64_t v5 = sub_1003F2080((uint64_t)a1[5] + 8, (uint64_t)v4);
    if (([v4 isEqualToString:kIDSDefaultPairedDeviceID] & 1) == 0)
    {
      unsigned int v6 = [v5 controlChannel];
      id v7 = [v6 deviceUniqueID];

      if (([v7 isEqualToString:v22] & 1) == 0)
      {
        uint64_t v8 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412546;
          *(void *)&uint8_t buf[4] = v22;
          __int16 v31 = 2112;
          uint64_t v32 = v7;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "closeSocketWithOptions found deviceUniqueID mismatch (%@ != %@), ignore.", buf, 0x16u);
        }
        goto LABEL_23;
      }
    }
    id v7 = [a1[4] objectForKey:@"account"];
    uint64_t v8 = [a1[4] objectForKey:@"service"];
    uint64_t v9 = [a1[4] objectForKey:IDSOpenSocketOptionStreamNameKey];
    id v10 = +[IDSGenericConnectionID idWithAccount:v7 service:v8 name:v9];
    id v11 = [v5 connectionsByID];
    uint64_t v12 = [v11 objectForKey:v10];

    if ([v5 linkLayerConnected])
    {
      [a1[5] closeDataConnectionWithDeviceConnectionInfo:v5 options:a1[4]];
      [a1[5] checkSuspendTrafficForDevice:v5 wait:1];
    }
    else
    {
      char v29 = 0;
      [v5 cancelBlockOnLinkConnectWithID:v10 cancelSucceeded:&v29];
      BOOL v13 = v29 == 0;
      uint64_t v14 = +[IDSFoundationLog utunController];
      BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
      if (!v13)
      {
        if (v15)
        {
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = v10;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Canceled a previously scheduled openSocket for %@. Not scheduling closeSocket.", buf, 0xCu);
        }

        goto LABEL_22;
      }
      if (v15)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Add a block for data channel close on link connects.", buf, 2u);
      }

      *(void *)long long buf = 0xAAAAAAAAAAAAAAAALL;
      objc_initWeak((id *)buf, v5);
      v26[0] = _NSConcreteStackBlock;
      v26[1] = 3221225472;
      v26[2] = sub_100370E54;
      v26[3] = &unk_10098A268;
      objc_copyWeak(&v28, (id *)buf);
      int8x16_t v21 = *((int8x16_t *)a1 + 2);
      id v16 = (id)v21.i64[0];
      int8x16_t v27 = vextq_s8(v21, v21, 8uLL);
      [v5 addBlocksOnLinkConnect:v26];

      objc_destroyWeak(&v28);
      objc_destroyWeak((id *)buf);
    }
    if (a1[7])
    {
      uint64_t v17 = a1[6];
      if (!a1[6])
      {
        uint64_t v18 = dispatch_get_global_queue(0, 0xFFFFFFFFFFFF8000);

        uint64_t v17 = v18;
      }
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100370ED8;
      block[3] = &unk_10097E818;
      id v25 = a1[7];
      id v24 = v12;
      dispatch_async(v17, block);
    }
    uint64_t v19 = objc_msgSend(a1[4], "objectForKey:", IDSOpenSocketOptionPhoneCallKey, *(_OWORD *)&v21);
    BOOL v20 = v19 == 0;

    if (!v20) {
      [*((id *)a1[5] + 12) setIsOnPhoneCall:0 forDeviceID:v4];
    }
LABEL_22:

LABEL_23:
  }
}

void sub_100370E30(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 128));
  _Unwind_Resume(a1);
}

uint64_t sub_100370E54(uint64_t a1, char a2, uint64_t a3)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v7 = WeakRetained;
  if (!a3 && (a2 & 1) == 0 && WeakRetained)
  {
    id v9 = WeakRetained;
    [*(id *)(a1 + 32) closeDataConnectionWithDeviceConnectionInfo:WeakRetained options:*(void *)(a1 + 40)];
    id WeakRetained = [*(id *)(a1 + 32) checkSuspendTrafficForDevice:v9 wait:1];
    id v7 = v9;
  }

  return _objc_release_x1(WeakRetained, v7);
}

uint64_t sub_100370ED8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  id v3 = [*(id *)(a1 + 32) packetsSent];
  id v4 = [*(id *)(a1 + 32) bytesSent];
  id v5 = [*(id *)(a1 + 32) packetsReceived];
  id v6 = [*(id *)(a1 + 32) bytesReceived];
  id v7 = *(uint64_t (**)(uint64_t, id, id, id, id))(v2 + 16);

  return v7(v2, v3, v4, v5, v6);
}

id sub_1003712CC(uint64_t a1)
{
  return [*(id *)(a1 + 32) doCheckSuspendTrafficForDevice:*(void *)(a1 + 40)];
}

id sub_100371504(uint64_t a1)
{
  return [*(id *)(a1 + 32) doCheckSuspendTrafficForDevice:*(void *)(a1 + 40)];
}

void sub_1003715A0(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    id v3 = [*(id *)(a1 + 32) objectForKey:IDSOpenSocketOptionCBUUIDKey];
    id v4 = [*(id *)(a1 + 32) objectForKey:@"account"];
    id v5 = [*(id *)(a1 + 32) objectForKey:@"service"];
    id v6 = [*(id *)(a1 + 32) objectForKey:IDSOpenSocketOptionStreamNameKey];
    id v7 = [*(id *)(a1 + 32) objectForKey:@"suspendWait"];
    uint64_t v8 = v7;
    if (v7) {
      unsigned int v20 = [v7 BOOLValue];
    }
    else {
      unsigned int v20 = 0;
    }
    id v9 = sub_1003F2080(*(void *)(a1 + 40) + 8, (uint64_t)v3);
    id v10 = +[IDSGenericConnectionID idWithAccount:v4 service:v5 name:v6];
    id v11 = [v9 connectionsByID];
    uint64_t v12 = [v11 objectForKey:v10];

    BOOL v13 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      [v9 vifName];
      uint64_t v19 = v6;
      uint64_t v14 = v5;
      BOOL v15 = v4;
      v17 = id v16 = v3;
      uint64_t v18 = *(void *)(a1 + 32);
      *(_DWORD *)long long buf = 138412802;
      uint64_t v22 = v17;
      __int16 v23 = 2112;
      uint64_t v24 = v18;
      __int16 v25 = 2112;
      unsigned __int16 v26 = v12;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%@: suspendSocketWithOptions called with options [%@] (connection %@)", buf, 0x20u);

      id v3 = v16;
      id v4 = v15;
      id v5 = v14;
      id v6 = v19;
    }

    if (v12)
    {
      if (([v12 suspended] & 1) == 0)
      {
        [v12 setSuspended:1];
        [*(id *)(a1 + 40) checkSuspendTrafficForDevice:v9 wait:v20];
      }
    }
  }
}

void sub_100371894(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    id v3 = [*(id *)(a1 + 32) objectForKey:IDSOpenSocketOptionCBUUIDKey];
    uint64_t v26 = [*(id *)(a1 + 32) objectForKey:IDSOpenSocketOptionDeviceUniqueIDKey];
    uint64_t v4 = [*(id *)(a1 + 32) objectForKey:@"account"];
    id v5 = [*(id *)(a1 + 32) objectForKey:@"service"];
    id v6 = [*(id *)(a1 + 32) objectForKey:IDSOpenSocketOptionStreamNameKey];
    id v7 = [*(id *)(a1 + 32) objectForKey:IDSOpenSocketOptionCloudEnabledKey];
    unsigned __int8 v24 = [v7 BOOLValue];

    uint64_t v8 = [*(id *)(a1 + 32) objectForKey:IDSOpenSocketOptionIsIDSDSessionSocket];
    unsigned __int8 v9 = [v8 BOOLValue];

    id v10 = sub_1003F2080(*(void *)(a1 + 40) + 8, (uint64_t)v3);
    __int16 v25 = (void *)v4;
    id v11 = +[IDSGenericConnectionID idWithAccount:v4 service:v5 name:v6];
    uint64_t v12 = [v10 connectionsByID];
    BOOL v13 = [v12 objectForKey:v11];

    if (*(unsigned char *)(a1 + 48))
    {
      uint64_t v14 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        BOOL v15 = [v10 vifName];
        id v16 = *(void **)(a1 + 32);
        *(_DWORD *)long long buf = 138412802;
        id v28 = v15;
        __int16 v29 = 2112;
        id v30 = v16;
        __int16 v31 = 2112;
        uint64_t v32 = v13;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%@: resumeSocketWithOptions called with options [%@] (connection %@)", buf, 0x20u);
      }
    }
    uint64_t v17 = +[IDSDevicePolicyController sharedInstance];
    unsigned int v18 = [v17 shouldBlackOutDeviceWithCbuuid:v3];

    if (v18)
    {
      uint64_t v19 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v20 = [v10 controlChannel];
        int8x16_t v21 = [v20 deviceUniqueID];
        *(_DWORD *)long long buf = 138412546;
        id v28 = v3;
        __int16 v29 = 2112;
        id v30 = v21;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Device %@/%@ is blacked out due to fairplay failures", buf, 0x16u);
      }
      uint64_t v22 = (void *)v26;
      [*(id *)(*(void *)(a1 + 40) + 96) stopLinkForDeviceUniqueID:v26 cbuuid:v3 disconnectWP:1];
    }
    else
    {
      char v23 = v24 | v9;
      uint64_t v22 = (void *)v26;
      if ((v23 & 1) == 0) {
        [*(id *)(*(void *)(a1 + 40) + 96) startLinkForDeviceUniqueID:v26 cbuuid:v3];
      }
      if (v13 && [v13 suspended])
      {
        [v13 setSuspended:0];
        [*(id *)(a1 + 40) checkSuspendTrafficForDevice:v10 wait:0];
      }
    }
  }
}

void *sub_100371D98(void *result)
{
  if (*(void *)(result[4] + 96)) {
    return [*(id *)(result[4] + 96) startUDPGlobalLinkForDevice:result[5]];
  }
  return result;
}

void sub_100371E44(uint64_t a1)
{
  uint64_t v2 = sub_1003F2080(*(void *)(a1 + 32) + 8, *(void *)(a1 + 40));
  id v3 = +[IDSFoundationLog utunController];
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      uint64_t v5 = *(void *)(a1 + 40);
      int v9 = 138412290;
      uint64_t v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "removeDeviceConnectionInfoForDevice for %@", (uint8_t *)&v9, 0xCu);
    }

    [*(id *)(a1 + 32) resetAllConnectionsForDevice:v2];
    id v6 = [v2 controlChannel];
    [v6 invalidate];

    if (v2[2079]) {
      os_channel_get_fd();
    }
    else {
      [v2 utunSocket];
    }
    IDSTransportThreadRemoveSocket();
    [v2 cancelBlocksOnLinkConnect];
    [v2 invalidate];
    sub_1003F2190(*(void *)(a1 + 32) + 8, *(const char **)(a1 + 40));
  }
  else
  {
    if (v4)
    {
      uint64_t v7 = *(void *)(a1 + 40);
      int v9 = 138412290;
      uint64_t v10 = v7;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "removeDeviceConnectionInfoForDevice found no match for %@", (uint8_t *)&v9, 0xCu);
    }
  }
  uint64_t v8 = *(void **)(*(void *)(a1 + 32) + 96);
  if (v8) {
    [v8 stopUDPGlobalLinkForDevice:*(void *)(a1 + 40)];
  }
}

void *sub_1003720B4(void *result)
{
  if (*(void *)(result[4] + 96)) {
    return [*(id *)(result[4] + 96) createConnectionDataForDevice:result[5] localPartyID:result[6] dataReadyHandler:result[7]];
  }
  return result;
}

void *sub_1003721B0(void *result)
{
  if (*(void *)(result[4] + 96)) {
    return [*(id *)(result[4] + 96) processRemoteConnectionDataForDevice:result[5] remoteConnectionData:result[6] completionHandler:result[7]];
  }
  return result;
}

void *sub_1003722A4(void *result)
{
  if (*(void *)(result[4] + 96)) {
    return [*(id *)(result[4] + 96) startConnectionForDevice:result[5] isInitiator:*((unsigned __int8 *)result + 56) remotePartyID:result[6] useStunMICheck:*((unsigned __int8 *)result + 57)];
  }
  return result;
}

void sub_100372358(uint64_t a1)
{
  uint64_t v2 = sub_1003F2080(*(void *)(a1 + 32) + 8, *(void *)(a1 + 40));
  id v3 = +[IDSFoundationLog utunController];
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      uint64_t v5 = *(void *)(a1 + 40);
      int v9 = 138412290;
      uint64_t v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "removeDeviceConnectionInfoForDevice for %@.", (uint8_t *)&v9, 0xCu);
    }

    [*(id *)(a1 + 32) resetAllConnectionsForDevice:v2];
    id v6 = [v2 controlChannel];
    [v6 invalidate];

    if (v2[2079]) {
      os_channel_get_fd();
    }
    else {
      [v2 utunSocket];
    }
    IDSTransportThreadRemoveSocket();
    [v2 cancelBlocksOnLinkConnect];
    [v2 invalidate];
    sub_1003F2190(*(void *)(a1 + 32) + 8, *(const char **)(a1 + 40));
  }
  else
  {
    if (v4)
    {
      uint64_t v7 = *(void *)(a1 + 40);
      int v9 = 138412290;
      uint64_t v10 = v7;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "removeDeviceConnectionInfoForDevice found no match for %@.", (uint8_t *)&v9, 0xCu);
    }
  }
  uint64_t v8 = *(void **)(*(void *)(a1 + 32) + 96);
  if (v8) {
    [v8 stopGlobalLinkForDevice:*(void *)(a1 + 40)];
  }
}

void *sub_100372640(void *result)
{
  if (*(void *)(result[4] + 96)) {
    return [*(id *)(result[4] + 96) startGlobalLinkForDevice:result[5]];
  }
  return result;
}

void *sub_100372748(void *result)
{
  if (*(void *)(result[4] + 96))
  {
    id v1 = result;
    uint64_t v2 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      int v3 = *((_DWORD *)v1 + 16);
      v4[0] = 67109120;
      v4[1] = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "IDSUTunController connectGlobalLinkForDevice preferredLocalInterface: %i", (uint8_t *)v4, 8u);
    }

    return [*(id *)(v1[4] + 96) connectGlobalLinkForDevice:v1[5] sessionInfo:v1[6] connectReadyHandler:v1[7] withLocalInterfacePreference:*((unsigned int *)v1 + 16)];
  }
  return result;
}

uint64_t sub_100372818(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

id sub_100372908(void *a1)
{
  return [*(id *)(a1[4] + 96) setAcceptedRelaySession:a1[5] relaySessionID:a1[6] options:a1[7]];
}

id sub_1003729B4(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 96) setHasPendingAllocation:*(unsigned __int8 *)(a1 + 48) forIDSSession:*(void *)(a1 + 40)];
}

id sub_100372A84(void *a1)
{
  return [*(id *)(a1[4] + 96) setTimeBase:a1[5] forIDSSession:a1[6]];
}

id sub_100372B40(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 96) setIsReliableUnicastSession:*(unsigned __int8 *)(a1 + 48) isClient:*(unsigned __int8 *)(a1 + 49) forIDSSession:*(void *)(a1 + 40)];
}

id sub_100372BF0(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 96) setAllowP2PforIDSSession:*(void *)(a1 + 40) isEnabled:*(unsigned __int8 *)(a1 + 48)];
}

id sub_100372C9C(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 96) setForceTCPFallbackOnWiFi:*(void *)(a1 + 40) forceTCPFallbackOnWiFi:*(unsigned __int8 *)(a1 + 48)];
}

id sub_100372D48(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 96) setForceTCPFallbackOnCell:*(void *)(a1 + 40) forceTCPFallbackOnCell:*(unsigned __int8 *)(a1 + 48)];
}

id sub_100372DF4(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 96) setSharedSessionHasJoined:*(unsigned __int8 *)(a1 + 48) forIDSSession:*(void *)(a1 + 40)];
}

id sub_100372EC4(void *a1)
{
  return [*(id *)(a1[4] + 96) setCellInterfaceName:a1[5] forIDSSession:a1[6]];
}

id sub_100372F94(void *a1)
{
  return [*(id *)(a1[4] + 96) setIDSContextBlob:a1[5] forIDSSession:a1[6]];
}

void sub_100373038(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 96);
    BOOL v4 = +[IDSFoundationLog utunController];
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (v3)
    {
      if (v5)
      {
        uint64_t v6 = *(void *)(a1 + 40);
        int v7 = 138412290;
        uint64_t v8 = v6;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "clearSharedSessionHasJoinedForIDSSession for session %@", (uint8_t *)&v7, 0xCu);
      }

      [*(id *)(*(void *)(a1 + 32) + 96) clearSharedSessionHasJoinedForIDSSession:*(void *)(a1 + 40)];
    }
    else
    {
      if (v5)
      {
        LOWORD(v7) = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "clearSharedSessionHasJoinedForIDSSession failed due to invalid linkManager", (uint8_t *)&v7, 2u);
      }
    }
  }
}

void sub_1003731D0(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 96);
    BOOL v4 = +[IDSFoundationLog utunController];
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (v3)
    {
      if (v5)
      {
        uint64_t v6 = *(void *)(a1 + 40);
        int v7 = 138412290;
        uint64_t v8 = v6;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "clearCellInterfaceName for session %@", (uint8_t *)&v7, 0xCu);
      }

      [*(id *)(*(void *)(a1 + 32) + 96) clearCellInterfaceName:*(void *)(a1 + 40)];
    }
    else
    {
      if (v5)
      {
        LOWORD(v7) = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "clearCellInterfaceName failed due to invalid linkManager", (uint8_t *)&v7, 2u);
      }
    }
  }
}

void sub_100373368(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 96);
    BOOL v4 = +[IDSFoundationLog utunController];
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (v3)
    {
      if (v5)
      {
        uint64_t v6 = *(void *)(a1 + 40);
        int v7 = 138412290;
        uint64_t v8 = v6;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "clearIDSContextBlob for session %@", (uint8_t *)&v7, 0xCu);
      }

      [*(id *)(*(void *)(a1 + 32) + 96) clearIDSContextBlob:*(void *)(a1 + 40)];
    }
    else
    {
      if (v5)
      {
        LOWORD(v7) = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "clearIDSContextBlob failed due to invalid linkManager", (uint8_t *)&v7, 2u);
      }
    }
  }
}

id sub_100373534(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 96) handleAllocateRequestFailureForDevice:*(void *)(a1 + 40) requestID:*(void *)(a1 + 48) errorCode:*(unsigned int *)(a1 + 56)];
}

void sub_100373608(uint64_t a1)
{
  unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  int v7 = -1431655766;
  [*(id *)(*(void *)(a1 + 32) + 96) currentLinkType:&v8 andRATType:&v7 forDeviceID:*(void *)(a1 + 40)];
  uint64_t v2 = im_primary_queue();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_1003736D4;
  v3[3] = &unk_10098A330;
  id v4 = *(id *)(a1 + 48);
  unint64_t v5 = v8;
  int v6 = v7;
  dispatch_async(v2, v3);
}

uint64_t sub_1003736D4(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40), *(unsigned int *)(a1 + 48));
}

uint64_t sub_1003738E0(uint64_t a1)
{
  kdebug_trace();
  [*(id *)(*(void *)(a1 + 32) + 96) startLocalSetup];

  return kdebug_trace();
}

void sub_100373B4C(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    if (*(void *)(*(void *)(a1 + 32) + 96))
    {
      uint64_t v3 = kIDSDefaultPairedDeviceID;
      if ([*(id *)(a1 + 40) isEqualToString:kIDSDefaultPairedDeviceID])
      {
        id v4 = im_primary_queue();
        dispatch_async(v4, &stru_10098A350);
      }
      unint64_t v5 = sub_1003F2080(*(void *)(a1 + 32) + 8, *(void *)(a1 + 40));
      if (v5)
      {
        int v6 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v7 = *(void *)(a1 + 40);
          *(_DWORD *)long long buf = 138412290;
          uint64_t v14 = v7;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "obliterateConnectionInfo: clear all connections for cbuuid %@", buf, 0xCu);
        }

        [*(id *)(a1 + 32) resetAllConnectionsForDevice:v5];
        unint64_t v8 = [v5 controlChannel];
        [v8 invalidate];

        if (v5[2079].isa) {
          os_channel_get_fd();
        }
        else {
          [v5 utunSocket];
        }
        IDSTransportThreadRemoveSocket();
        [v5 cancelBlocksOnLinkConnect];
        [v5 invalidate];
        sub_1003F2190(*(void *)(a1 + 32) + 8, *(const char **)(a1 + 40));
      }
      if ([*(id *)(a1 + 40) isEqualToString:v3]) {
        [*(id *)(*(void *)(a1 + 32) + 96) obliterateConnectionInfo];
      }
      int v9 = *(void **)(a1 + 56);
      if (v9)
      {
        uint64_t v10 = *(NSObject **)(a1 + 48);
        if (v10)
        {
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472;
          block[2] = sub_100373E34;
          block[3] = &unk_10097E7F0;
          id v12 = v9;
          dispatch_async(v10, block);
        }
      }
    }
    else
    {
      unint64_t v5 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "obliterateConnectionInfo failed due to invalid linkManager", buf, 2u);
      }
    }
  }
}

void sub_100373DA8(id a1)
{
  id v1 = +[IDSUTunDeliveryController sharedInstance];
  [v1 enableConnectionForDefaultPairedDevice:0];

  if (_IDSSupportsDirectMessaging())
  {
    id v2 = +[IDSUTunDeliveryController sharedInstance];
    [v2 defaultPeerSupportsDirectMessaging:0 isObliterating:1];
  }
}

uint64_t sub_100373E34(uint64_t a1)
{
  id v2 = +[IDSFoundationLog utunController];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "obliterateConnectionInfo: completionBlock", v4, 2u);
  }

  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100373F24(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    uint64_t v3 = sub_1003F2080(*(void *)(a1 + 32) + 8, kIDSDefaultPairedDeviceID);
    id v4 = +[IDSFoundationLog utunController];
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (v3)
    {
      if (v5)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Clearing control channel", buf, 2u);
      }

      id v4 = [v3 controlChannel];
      [*(id *)(*(void *)(a1 + 32) + 96) setRequireBT:1];
      [v4 setIdentityPair:0];
      [v4 setIsDefaultPairedDevicePairedLocally:0];
    }
    else if (v5)
    {
      *(_WORD *)int v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Couldn't find deviceConnection info", v6, 2u);
    }
  }
}

void sub_1003740DC(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    uint64_t v3 = *(void **)(*(void *)(a1 + 32) + 96);
    if (v3)
    {
      if (*(unsigned char *)(a1 + 48)) {
        [v3 setShouldStartBTLinkManager:0];
      }
      id v4 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = *(void *)(a1 + 40);
        int v7 = 138412290;
        uint64_t v8 = v5;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "addPairedDevice with cbuuid %@", (uint8_t *)&v7, 0xCu);
      }

      [*(id *)(*(void *)(a1 + 32) + 96) addPairedDevice:*(void *)(a1 + 40)];
    }
    else
    {
      int v6 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v7) = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "addPairedDevice failed due to invalid linkManager", (uint8_t *)&v7, 2u);
      }
    }
  }
}

void sub_100374298(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 96);
    id v4 = +[IDSFoundationLog utunController];
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (v3)
    {
      if (v5)
      {
        uint64_t v6 = *(void *)(a1 + 40);
        int v7 = 138412290;
        uint64_t v8 = v6;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "connectPairedDevice with cbuuid %@", (uint8_t *)&v7, 0xCu);
      }

      [*(id *)(*(void *)(a1 + 32) + 96) connectPairedDevice:*(void *)(a1 + 40)];
    }
    else
    {
      if (v5)
      {
        LOWORD(v7) = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "connectPairedDevice failed due to invalid linkManager", (uint8_t *)&v7, 2u);
      }
    }
  }
}

void sub_100374430(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 96);
    id v4 = +[IDSFoundationLog utunController];
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (v3)
    {
      if (v5)
      {
        uint64_t v6 = *(void *)(a1 + 40);
        int v7 = 138412290;
        uint64_t v8 = v6;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "deletePairedDevice with cbuuid %@", (uint8_t *)&v7, 0xCu);
      }

      [*(id *)(*(void *)(a1 + 32) + 96) deletePairedDevice:*(void *)(a1 + 40)];
    }
    else
    {
      if (v5)
      {
        LOWORD(v7) = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "deletePairedDevice failed due to invalid linkManager", (uint8_t *)&v7, 2u);
      }
    }
  }
}

void sub_100374610(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100374628(uint64_t a1)
{
  id v2 = *(void **)(*(void *)(a1 + 32) + 96);
  if (v2)
  {
    id v3 = [v2 copyLinkStatsDict];
    uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8);
    uint64_t v5 = *(void *)(v4 + 40);
    *(void *)(v4 + 40) = v3;
    _objc_release_x1(v3, v5);
  }
  else
  {
    uint64_t v6 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v9 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "copyLinkStatsDict failed due to invalid linkManager", v9, 2u);
    }

    uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
    uint64_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = 0;
  }
}

void sub_100374780(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 96);
    uint64_t v4 = +[IDSFoundationLog utunController];
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (v3)
    {
      if (v5)
      {
        uint64_t v6 = *(void *)(a1 + 40);
        int v7 = 138412290;
        uint64_t v8 = v6;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "clearPluginCacheForSession for session %@", (uint8_t *)&v7, 0xCu);
      }

      [*(id *)(*(void *)(a1 + 32) + 96) clearPluginCacheForSession:*(void *)(a1 + 40)];
    }
    else
    {
      if (v5)
      {
        LOWORD(v7) = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "clearPluginCacheForSession failed due to invalid linkManager", (uint8_t *)&v7, 2u);
      }
    }
  }
}

void sub_100374918(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    if (*(void *)(*(void *)(a1 + 32) + 96))
    {
      uint64_t v2 = *(void *)(a1 + 40);
      uint64_t v3 = *(void **)(*(void *)(a1 + 32) + 96);
      [v3 clearReliableUnicastStateForSession:v2];
    }
    else
    {
      uint64_t v4 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)BOOL v5 = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "clearReliableUnicastStateForSession failed due to invalid linkManager", v5, 2u);
      }
    }
  }
}

void sub_100374CFC(uint64_t a1, uint64_t a2, void *a3)
{
  id v12 = a3;
  uint64_t v4 = [v12 connectionID];
  BOOL v5 = [v4 service];

  if ([v5 length]
    && (([*(id *)(a1 + 32) containsObject:v5] & 1) != 0
     || ![*(id *)(a1 + 32) count]))
  {
    uint64_t v6 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
    if (!v6)
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      uint64_t v8 = *(void *)(*(void *)(a1 + 48) + 8);
      int v9 = *(void **)(v8 + 40);
      *(void *)(v8 + 40) = Mutable;

      uint64_t v6 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
    }
    uint64_t v10 = [v6 objectForKey:v5];
    if (!v10) {
      uint64_t v10 = objc_alloc_init(IDSServiceStatistics);
    }
    id v11 = [*(id *)(a1 + 40) objectForKey:v5];
    -[IDSServiceStatistics setPacketsSent:](v10, "setPacketsSent:", (char *)[v11 packetsSent]+ (void)objc_msgSend(v12, "packetsSent")+ -[IDSServiceStatistics packetsSent](v10, "packetsSent"));
    -[IDSServiceStatistics setPacketsReceived:](v10, "setPacketsReceived:", (char *)[v11 packetsReceived]+ (void)objc_msgSend(v12, "packetsReceived")+ -[IDSServiceStatistics packetsReceived](v10, "packetsReceived"));
    -[IDSServiceStatistics setBytesSent:](v10, "setBytesSent:", (char *)[v11 bytesSent]+ (void)objc_msgSend(v12, "bytesSent")+ -[IDSServiceStatistics bytesSent](v10, "bytesSent"));
    -[IDSServiceStatistics setBytesReceived:](v10, "setBytesReceived:", (char *)[v11 bytesReceived]+ (void)objc_msgSend(v12, "bytesReceived")+ -[IDSServiceStatistics bytesReceived](v10, "bytesReceived"));
    if (v10) {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), v5, v10);
    }
    [*(id *)(a1 + 40) removeObjectForKey:v5];
  }
}

void sub_1003750D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1003750F4(uint64_t result, char a2)
{
  if ((a2 & 1) == 0)
  {
    uint64_t v3 = (void *)result;
    uint64_t v4 = objc_msgSend(*(id *)(result + 32), "onTransportThread_PerServiceDataTransferredForDevice:services:", v3[5], v3[6]);
    uint64_t v5 = *(void *)(v3[7] + 8);
    uint64_t v6 = *(void *)(v5 + 40);
    *(void *)(v5 + 40) = v4;
    return _objc_release_x1(v4, v6);
  }
  return result;
}

void sub_10037531C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10037533C(uint64_t a1)
{
  uint64_t v2 = sub_1003F2080(*(void *)(a1 + 32) + 8, *(void *)(a1 + 40));
  uint64_t v3 = v2;
  if (v2)
  {
    id v4 = [v2 connectionsTableByLocalRemotePortKey];
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    v7[2] = sub_1003753FC;
    v7[3] = &unk_10098A3F0;
    id v5 = *(id *)(a1 + 48);
    uint64_t v6 = *(void *)(a1 + 56);
    id v8 = v5;
    uint64_t v9 = v6;
    sub_1003F1C58((uint64_t)v4, (uint64_t)v7);
  }
}

void sub_1003753FC(uint64_t a1, uint64_t a2, void *a3)
{
  id v18 = a3;
  id v4 = [v18 connectionID];
  id v5 = [v4 service];

  if ([v5 length]
    && (([*(id *)(a1 + 32) containsObject:v5] & 1) != 0
     || ![*(id *)(a1 + 32) count]))
  {
    if (!*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40))
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
      id v8 = *(void **)(v7 + 40);
      *(void *)(v7 + 40) = Mutable;
    }
    uint64_t v9 = (char *)[v18 packetsSent];
    uint64_t v10 = (char *)[v18 bytesSent];
    id v11 = [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) objectForKey:v5];
    if (!v11) {
      id v11 = objc_alloc_init((Class)NSMutableDictionary);
    }
    id v12 = [v11 objectForKey:@"localDeliveryQueueStatMessageCount"];
    BOOL v13 = [v11 objectForKey:@"localDeliveryQueueStatBytes"];
    uint64_t v14 = &v9[(void)[v12 unsignedLongLongValue]];
    BOOL v15 = &v10[(void)[v13 unsignedLongLongValue]];
    id v16 = +[NSNumber numberWithUnsignedLongLong:v14];
    [v11 setObject:v16 forKey:@"localDeliveryQueueStatMessageCount"];

    uint64_t v17 = +[NSNumber numberWithUnsignedLongLong:v15];
    [v11 setObject:v17 forKey:@"localDeliveryQueueStatBytes"];

    [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) setObject:v11 forKey:v5];
  }
}

void sub_1003757D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1003757F4(uint64_t a1)
{
  uint64_t v2 = sub_1003F2080(*(void *)(a1 + 32) + 8, *(void *)(a1 + 40));
  uint64_t v3 = v2;
  if (v2)
  {
    id v4 = [v2 connectionsTableByLocalRemotePortKey];
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    v7[2] = sub_1003758B4;
    v7[3] = &unk_10098A3F0;
    id v5 = *(id *)(a1 + 48);
    uint64_t v6 = *(void *)(a1 + 56);
    id v8 = v5;
    uint64_t v9 = v6;
    sub_1003F1C58((uint64_t)v4, (uint64_t)v7);
  }
}

void sub_1003758B4(uint64_t a1, uint64_t a2, void *a3)
{
  id v18 = a3;
  id v4 = [v18 connectionID];
  id v5 = [v4 service];

  if ([v5 length]
    && (([*(id *)(a1 + 32) containsObject:v5] & 1) != 0
     || ![*(id *)(a1 + 32) count]))
  {
    if (!*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40))
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
      id v8 = *(void **)(v7 + 40);
      *(void *)(v7 + 40) = Mutable;
    }
    uint64_t v9 = (char *)[v18 packetsReceived];
    uint64_t v10 = (char *)[v18 bytesReceived];
    id v11 = [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) objectForKey:v5];
    if (!v11) {
      id v11 = objc_alloc_init((Class)NSMutableDictionary);
    }
    id v12 = [v11 objectForKey:@"localDeliveryQueueStatMessageCount"];
    BOOL v13 = [v11 objectForKey:@"localDeliveryQueueStatBytes"];
    uint64_t v14 = &v9[(void)[v12 unsignedLongLongValue]];
    BOOL v15 = &v10[(void)[v13 unsignedLongLongValue]];
    id v16 = +[NSNumber numberWithUnsignedLongLong:v14];
    [v11 setObject:v16 forKey:@"localDeliveryQueueStatMessageCount"];

    uint64_t v17 = +[NSNumber numberWithUnsignedLongLong:v15];
    [v11 setObject:v17 forKey:@"localDeliveryQueueStatBytes"];

    [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) setObject:v11 forKey:v5];
  }
}

void sub_100375BB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100375BD0(uint64_t a1)
{
  uint64_t v2 = sub_1003F2080(*(void *)(a1 + 32) + 8, *(void *)(a1 + 40));
  uint64_t v3 = v2;
  if (v2)
  {
    id v4 = [v2 connectionsTableByLocalRemotePortKey];
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_100375D18;
    v9[3] = &unk_10098A3F0;
    id v5 = *(id *)(a1 + 48);
    uint64_t v6 = *(void *)(a1 + 56);
    uint64_t v10 = v5;
    uint64_t v11 = v6;
    sub_1003F1C58((uint64_t)v4, (uint64_t)v9);
    uint64_t v7 = v10;
  }
  else
  {
    uint64_t v7 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void *)(a1 + 40);
      *(_DWORD *)long long buf = 138412290;
      uint64_t v13 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "getTransmittedPacketsForDevice: cannot find device %@", buf, 0xCu);
    }
  }
}

void sub_100375D18(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = *(void **)(a1 + 32);
  id v8 = v4;
  uint64_t v6 = [v4 connectionID];
  uint64_t v7 = [v6 service];
  LODWORD(v5) = [v5 containsObject:v7];

  if (v5) {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += [v8 packetsSent];
  }
}

void sub_100375EB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100375ECC(uint64_t a1)
{
  uint64_t v2 = sub_1003F2080(*(void *)(a1 + 32) + 8, *(void *)(a1 + 40));
  uint64_t v3 = v2;
  if (v2)
  {
    id v4 = [v2 connectionsTableByLocalRemotePortKey];
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_100376014;
    v9[3] = &unk_10098A3F0;
    id v5 = *(id *)(a1 + 48);
    uint64_t v6 = *(void *)(a1 + 56);
    uint64_t v10 = v5;
    uint64_t v11 = v6;
    sub_1003F1C58((uint64_t)v4, (uint64_t)v9);
    uint64_t v7 = v10;
  }
  else
  {
    uint64_t v7 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void *)(a1 + 40);
      *(_DWORD *)long long buf = 138412290;
      uint64_t v13 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "getTransmittedPacketsForDevice: cannot find device %@", buf, 0xCu);
    }
  }
}

void sub_100376014(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = *(void **)(a1 + 32);
  id v8 = v4;
  uint64_t v6 = [v4 connectionID];
  uint64_t v7 = [v6 service];
  LODWORD(v5) = [v5 containsObject:v7];

  if (v5) {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += [v8 packetsReceived];
  }
}

void sub_100376124(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 96);
    id v4 = +[IDSFoundationLog utunController];
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (v3)
    {
      if (v5)
      {
        if (*(unsigned char *)(a1 + 40)) {
          CFStringRef v6 = @"YES";
        }
        else {
          CFStringRef v6 = @"NO";
        }
        int v7 = 138412290;
        CFStringRef v8 = v6;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "setPreferInfraWiFi %@", (uint8_t *)&v7, 0xCu);
      }

      [*(id *)(*(void *)(a1 + 32) + 96) setPreferInfraWiFi:*(unsigned __int8 *)(a1 + 40)];
    }
    else
    {
      if (v5)
      {
        LOWORD(v7) = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "setPreferInfraWiFi failed due to invalid linkManager", (uint8_t *)&v7, 2u);
      }
    }
  }
}

void sub_1003762D8(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    if (*(void *)(*(void *)(a1 + 32) + 96))
    {
      uint64_t v2 = *(void *)(a1 + 40);
      uint64_t v3 = *(void **)(*(void *)(a1 + 32) + 96);
      [v3 setLinkPreferences:v2];
    }
    else
    {
      id v4 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)BOOL v5 = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "setLinkPreferences failed due to invalid linkManager", v5, 2u);
      }
    }
  }
}

void sub_100376444(uint64_t a1)
{
  uint64_t v2 = sub_1003F2080(*(void *)(a1 + 32) + 8, kIDSDefaultPairedDeviceID);
  if ([v2 linkLayerConnected])
  {
    uint64_t v3 = [v2 controlChannel];
    [v3 sendOTRNegotiationMessage:*(void *)(a1 + 40) negotiationCount:*(unsigned int *)(a1 + 56) negotiationData:*(void *)(a1 + 48)];
  }
  else
  {
    id v4 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 40);
      int v6 = 138412290;
      uint64_t v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Drop OTR negotiation message for %@, link is not connected.", (uint8_t *)&v6, 0xCu);
    }

    uint64_t v3 = [v2 controlChannel];
    [v3 suspendOTRNegotiation:*(void *)(a1 + 40)];
  }
}

void sub_1003765F4(uint64_t a1)
{
  uint64_t v2 = sub_1003F2080(*(void *)(a1 + 32) + 8, kIDSDefaultPairedDeviceID);
  if ([v2 linkLayerConnected])
  {
    uint64_t v3 = [v2 controlChannel];
    [v3 sendSuspendOTRNegotiationMessage:*(void *)(a1 + 40)];
  }
  else
  {
    uint64_t v3 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = *(void *)(a1 + 40);
      int v5 = 138412290;
      uint64_t v6 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Drop suspend OTR negotiation message for %@, link is not connected.", (uint8_t *)&v5, 0xCu);
    }
  }
}

void sub_100376700(const char *a1, int a2)
{
  if (a1 && *a1)
  {
    int v4 = socket(30, 2, 0);
    if (v4 == -1)
    {
      __error();
      IDSAssertNonFatalErrnoWithSource();
      uint64_t v17 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = a1;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Cannot open socket for ioctl for %s on disconnect", buf, 0xCu);
      }

      goto LABEL_23;
    }
    int v5 = v4;
    *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)long long buf = v6;
    long long v23 = v6;
    __strlcpy_chk();
    if (ioctl(v5, 0xC02069AAuLL, buf) == -1)
    {
      uint64_t v10 = +[IDSFoundationLog utunController];
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_22;
      }
      *(_DWORD *)id v18 = 136315138;
      *(void *)uint64_t v19 = a1;
      id v12 = "Cannot get interface state for %s on disconnect";
    }
    else
    {
      int v7 = BYTE3(v23);
      int v8 = a2 ^ 1;
      BYTE3(v23) = a2 ^ 1;
      int v9 = ioctl(v5, 0xC02069A9uLL, buf);
      uint64_t v10 = +[IDSFoundationLog utunController];
      BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
      if (v9 != -1)
      {
        if (v11)
        {
          *(_DWORD *)id v18 = 67109634;
          *(_DWORD *)uint64_t v19 = v7;
          *(_WORD *)&void v19[4] = 1024;
          *(_DWORD *)&v19[6] = v8;
          __int16 v20 = 2080;
          int8x16_t v21 = a1;
          id v12 = "Set interface availability from %u to %u (0 is available) %s";
          uint64_t v13 = v10;
          uint32_t v14 = 24;
LABEL_21:
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v12, v18, v14);
        }
LABEL_22:

        close(v5);
LABEL_23:
        IDSCheckFileDescriptorUsageWithSource();
        return;
      }
      if (!v11) {
        goto LABEL_22;
      }
      *(_DWORD *)id v18 = 136315138;
      *(void *)uint64_t v19 = a1;
      id v12 = "Cannot set interface state to available for %s on disconnect";
    }
    uint64_t v13 = v10;
    uint32_t v14 = 12;
    goto LABEL_21;
  }
  BOOL v15 = +[IDSFoundationLog utunController];
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    id v16 = "<null>";
    if (a1) {
      id v16 = a1;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v16;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Cannot use invalid interface name [%s]", buf, 0xCu);
  }
}

void sub_100377218(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    uint64_t v3 = sub_1003F2080(*(void *)(a1 + 32) + 8, kIDSDefaultPairedDeviceID);
    if ([v3 shouldUseIPsecLink])
    {
      int v4 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "ipsec path does not require control channel encryption", buf, 2u);
      }

      int v5 = im_primary_queue();
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10037743C;
      block[3] = &unk_10097E4D0;
      void block[4] = *(void *)(a1 + 32);
      dispatch_async(v5, block);
    }
    else
    {
      int v5 = [v3 controlChannel];
      if ([v5 isDefaultPairedDevicePairedLocally])
      {
        long long v6 = +[IDSFoundationLog utunController];
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "control channel already paired", buf, 2u);
        }

        int v7 = im_primary_queue();
        v9[0] = _NSConcreteStackBlock;
        v9[1] = 3221225472;
        v9[2] = sub_100377494;
        v9[3] = &unk_10097E4D0;
        void v9[4] = *(void *)(a1 + 32);
        dispatch_async(v7, v9);
      }
      else if (*(void *)(a1 + 40))
      {
        -[NSObject setIdentityPair:](v5, "setIdentityPair:");
        [v5 setIsDefaultPairedDevicePairedLocally:1];
        int v8 = sub_10036C514((int)[v5 isDefaultPairedDevicePairedRemotely]);
        [v5 sendPriorityMessage:v8];
      }
    }
  }
}

void sub_10037743C(uint64_t a1)
{
  id v2 = +[IDSPairingManager sharedInstance];
  [v2 removeDelegate:*(void *)(a1 + 32)];
}

void sub_100377494(uint64_t a1)
{
  id v2 = +[IDSPairingManager sharedInstance];
  [v2 removeDelegate:*(void *)(a1 + 32)];
}

void sub_1003777D4(id a1)
{
  mach_timebase_info info = (mach_timebase_info)0xAAAAAAAAAAAAAAAALL;
  mach_timebase_info(&info);
  LODWORD(v2) = info.denom;
  LODWORD(v1) = info.numer;
  *(double *)&qword_100A4C830 = (double)v1 / (double)v2 / 1000000000.0;
}

id sub_1003785A8(id a1, IDSURI *a2)
{
  unint64_t v2 = a2;
  int v4 = [(IDSURI *)v2 tokenFreeURI];

  return v4;
}

id sub_10037860C(void *a1, void *a2, unsigned int a3)
{
  id v5 = a2;
  long long v6 = [a1 prefixedURI];
  int v7 = +[NSString stringWithFormat:@"%@,%@,%d", v5, v6, a3];

  return v7;
}

id sub_1003787A4(id a1, IDSURI *a2)
{
  unint64_t v2 = a2;
  int v4 = [(IDSURI *)v2 tokenFreeURI];

  return v4;
}

id sub_100378A6C(id a1, IDSURI *a2)
{
  unint64_t v2 = a2;
  int v4 = [(IDSURI *)v2 tokenFreeURI];

  return v4;
}

uint64_t sub_10037AD90(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10037ADA0(uint64_t a1)
{
}

id sub_10037ADA8(id a1, IDSURI *a2)
{
  return [(IDSURI *)a2 prefixedURI];
}

void sub_10037ADB0(uint64_t a1, void *a2, void *a3, unint64_t a4, void *a5)
{
  id v8 = a2;
  id v9 = a3;
  id v261 = a5;
  uint64_t v275 = a1;
  [*(id *)(a1 + 32) _dequeuePendingQueryIfPossible];
  double v10 = COERCE_DOUBLE(v9);
  double v262 = v10;
  if (IMGetDomainBoolForKey())
  {
    a4 = IMGetDomainIntForKey();
    +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", FTErrorDomain);
    double v10 = COERCE_DOUBLE(objc_claimAutoreleasedReturnValue());

    BOOL v11 = +[IMRGLog warning];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
      sub_10071FCD0(a4, v11);
    }
  }
  id v268 = v8;
  v272 = [v268 responseIdentities];
  id v12 = [v268 responseIdentities];
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();

  if ((isKindOfClass & 1) == 0)
  {
    uint32_t v14 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      BOOL v15 = [v268 responseIdentities];
      id v16 = (objc_class *)objc_opt_class();
      NSStringFromClass(v16);
      double v17 = COERCE_DOUBLE((id)objc_claimAutoreleasedReturnValue());
      id v18 = [v268 responseIdentities];
      *(_DWORD *)long long buf = 138413058;
      double v311 = v17;
      __int16 v312 = 2112;
      *(void *)v313 = v18;
      *(_WORD *)&v313[8] = 2112;
      *(double *)&v313[10] = v10;
      __int16 v314 = 2048;
      unint64_t v315 = a4;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Response identities is not what we expected (%@ instead of NSDictionary) %@, error %@, resultCode %ld", buf, 0x2Au);
    }
    if (os_log_shim_legacy_logging_enabled())
    {
      uint64_t v19 = [v268 responseIdentities];
      __int16 v20 = (objc_class *)objc_opt_class();
      int8x16_t v21 = NSStringFromClass(v20);
      v249 = [v268 responseIdentities];
      _IDSWarnV();

      uint64_t v22 = objc_msgSend(v268, "responseIdentities", v21, v249, *(void *)&v10, a4);
      long long v23 = (objc_class *)objc_opt_class();
      unsigned __int8 v24 = NSStringFromClass(v23);
      v250 = [v268 responseIdentities];
      _IDSLogV();

      __int16 v25 = objc_msgSend(v268, "responseIdentities", v24, v250, *(void *)&v10, a4);
      uint64_t v26 = (objc_class *)objc_opt_class();
      NSStringFromClass(v26);
      double v27 = COERCE_DOUBLE(objc_claimAutoreleasedReturnValue());
      [v268 responseIdentities];
      double v254 = v10;
      unint64_t v256 = a4;
      v248 = double v242 = v27;
      _IDSLogTransport();
    }
    v272 = 0;
  }
  char v305 = 0;
  int v28 = sub_1001BBE88(*(void **)&v10);
  int v29 = v28;
  uint64_t v30 = *(void *)(*(void *)(v275 + 120) + 8);
  if (*(unsigned char *)(v30 + 24)) {
    char v31 = v28;
  }
  else {
    char v31 = 0;
  }
  *(unsigned char *)(v30 + 24) = v31;
  if (v28)
  {
    *(void *)&double v32 = (int)++*(_DWORD *)(*(void *)(*(void *)(v275 + 128) + 8) + 24);
    if ((*(void *)&v32 == 9 || *(void *)&v32 == 4)
      && !+[IDSPeerIDQueryHandler isServerBackoffModeActive])
    {
      BOOL v33 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134217984;
        double v311 = v32;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "We have suffered %ld network failures. Forcing the server bag to reload.", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        double v242 = v32;
        _IDSLogV();
      }
      id v34 = +[IDSServerBag sharedInstanceForBagType:](IDSServerBag, "sharedInstanceForBagType:", 0, *(void *)&v242);
      [v34 forceBagLoad];
    }
  }
  long long v35 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v36 = @"NO";
    if (v29) {
      CFStringRef v36 = @"YES";
    }
    int v37 = *(_DWORD *)(*(void *)(*(void *)(v275 + 128) + 8) + 24);
    *(_DWORD *)long long buf = 138412802;
    double v311 = v10;
    __int16 v312 = 2112;
    *(void *)v313 = v36;
    *(_WORD *)&v313[8] = 1024;
    *(_DWORD *)&v313[10] = v37;
    _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "Query completed with error %@. isNetworkError? %@ numNetworkFailures %d", buf, 0x1Cu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    CFStringRef v38 = @"NO";
    if (v29) {
      CFStringRef v38 = @"YES";
    }
    v248 = (void *)v38;
    *(void *)&double v254 = *(unsigned int *)(*(void *)(*(void *)(v275 + 128) + 8) + 24);
    double v242 = v10;
    _IDSLogV();
  }
  unsigned int v260 = +[IDSPeerIDQueryHandler isQueryRetryForBadSignatureEnabled];
  int v40 = v10 == 0.0 && a4 < 2;
  int v265 = sub_1001BBB48(*(void **)&v10, &v305);
  uint64_t v41 = *(void *)(*(void *)(v275 + 136) + 8);
  if (*(unsigned char *)(v41 + 24)) {
    BOOL v42 = v305 == 0;
  }
  else {
    BOOL v42 = 1;
  }
  char v43 = !v42;
  *(unsigned char *)(v41 + 24) = v43;
  id v44 = +[NSDate date];
  [v44 timeIntervalSinceDate:*(void *)(v275 + 40)];
  double v46 = v45;

  if (a4 == 6003)
  {
    id v47 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "Time is off, considering this an invalid result", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      _IDSLogTransport();
    }
    *(double *)&uint64_t v48 = +[NSError errorWithDomain:IDSPeerIDManagerErrorDomain code:3 userInfo:0];

    int v265 = 0;
    int v40 = 0;
    double v10 = *(double *)&v48;
  }
  double v269 = v10;
  id v49 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v50 = *(void *)(v275 + 48);
    uint64_t v51 = *(void *)(v275 + 56);
    unint64_t v52 = *(void *)(v275 + 64);
    uint64_t v53 = *(void *)(v275 + 72);
    *(_DWORD *)long long buf = 134219010;
    double v311 = v46;
    __int16 v312 = 2112;
    *(void *)v313 = v50;
    *(_WORD *)&v313[8] = 2112;
    *(void *)&v313[10] = v51;
    __int16 v314 = 2112;
    unint64_t v315 = v52;
    __int16 v316 = 2112;
    *(void *)v317 = v53;
    _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "Query time was: %f  (identifier: %@) (URIs: %@) (service: %@) (fromURI: %@)", buf, 0x34u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    unint64_t v256 = *(void *)(v275 + 64);
    uint64_t v258 = *(void *)(v275 + 72);
    long long v251 = *(_OWORD *)(v275 + 48);
    double v243 = v46;
    _IDSLogEventV();
  }
  id v273 = objc_alloc_init((Class)NSMutableDictionary);
  if (v40)
  {
    id v55 = [v268 uris];
    v303[0] = _NSConcreteStackBlock;
    v303[1] = 3221225472;
    v303[2] = sub_10037DA00;
    v303[3] = &unk_10097E990;
    id v304 = *(id *)(v275 + 64);
    v263 = objc_msgSend(v55, "__imArrayByApplyingBlock:", v303);

    id v56 = [*(id *)(v275 + 32) delegate];
    int8x16_t v57 = [v56 finishedQueryWithInfo:v272 forURIs:v263 fromURI:*(void *)(v275 + 72) service:*(void *)(v275 + 64)];

    long long v301 = 0u;
    long long v302 = 0u;
    long long v299 = 0u;
    long long v300 = 0u;
    id v58 = v57;
    id v59 = [v58 countByEnumeratingWithState:&v299 objects:v318 count:16];
    if (v59)
    {
      double v270 = 0.0;
      uint64_t v60 = *(void *)v300;
      uint64_t v61 = IDSPeerIDManagerErrorDomain;
      char v274 = 1;
      do
      {
        for (uint64_t i = 0; i != v59; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v300 != v60) {
            objc_enumerationMutation(v58);
          }
          uint64_t v63 = *(void *)(*((void *)&v299 + 1) + 8 * i);
          socklen_t v65 = [v58 objectForKey:v63];
          unsigned int v66 = [v65 BOOLValue];

          if (v66)
          {
            ++*(void *)&v270;
          }
          else
          {
            if (!*(void *)(*(void *)(*(void *)(v275 + 144) + 8) + 40))
            {
              CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
              uint64_t v68 = *(void *)(*(void *)(v275 + 144) + 8);
              __int16 v69 = *(void **)(v68 + 40);
              *(void *)(v68 + 40) = Mutable;
            }
            __int16 v70 = +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", v61, 3, 0, *(void *)&v243, v251, v256, v258);
            [*(id *)(*(void *)(*(void *)(v275 + 144) + 8) + 40) setObject:v70 forKeyedSubscript:v63];

            char v274 = 0;
          }
        }
        id v59 = [v58 countByEnumeratingWithState:&v299 objects:v318 count:16];
      }
      while (v59);
    }
    else
    {
      double v270 = 0.0;
      char v274 = 1;
    }

    [v273 addEntriesFromDictionary:v58];
  }
  else
  {
    double v270 = 0.0;
    char v274 = 0;
  }
  if (v305) {
    unsigned int v71 = 6;
  }
  else {
    unsigned int v71 = 15;
  }
  __int16 v72 = +[IDSPairingManager sharedInstance];
  unsigned __int8 v73 = [v72 isCurrentDeviceTinkerConfiguredWatch];

  __int16 v75 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v76 = +[IDSPeerIDQueryHandler isServerBackoffModeActive];
    *(double *)&CFStringRef v77 = COERCE_DOUBLE(@"not ");
    if (v76) {
      *(double *)&CFStringRef v77 = COERCE_DOUBLE(&stru_10099BE78);
    }
    *(_DWORD *)long long buf = 138412290;
    double v311 = *(double *)&v77;
    _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, " We are %@in backoff mode.", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    unsigned int v78 = +[IDSPeerIDQueryHandler isServerBackoffModeActive];
    CFStringRef v79 = @"not ";
    if (v78) {
      CFStringRef v79 = &stru_10099BE78;
    }
    CFStringRef v244 = v79;
    _IDSLogV();
  }
  unsigned int v80 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v81 = +[IDSPeerIDQueryHandler shouldUseSelfTokens];
    *(double *)&CFStringRef v82 = COERCE_DOUBLE(@"not ");
    if (v81) {
      *(double *)&CFStringRef v82 = COERCE_DOUBLE(&stru_10099BE78);
    }
    *(_DWORD *)long long buf = 138412290;
    double v311 = *(double *)&v82;
    _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, " We are %@in self session mode.", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    unsigned int v83 = +[IDSPeerIDQueryHandler shouldUseSelfTokens];
    CFStringRef v84 = @"not ";
    if (v83) {
      CFStringRef v84 = &stru_10099BE78;
    }
    CFStringRef v244 = v84;
    _IDSLogV();
  }
  *(void *)&double v264 = v71 >> v73;
  if (+[IDSPeerIDQueryHandler isServerBackoffModeActive]&& *(unsigned char *)(v275 + 180))
  {
    double v264 = COERCE_DOUBLE((id)+[IDSPeerIDQueryHandler serverBackoffModeMaxSenderRetries]);
    uint64_t v85 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v311) = LODWORD(v264);
      _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, " **** We are in backoff mode! Using override for maxRetries %d", buf, 8u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      double v245 = v264;
      _IDSLogV();
    }
  }
  unsigned int v86 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT))
  {
    double v87 = *(double *)(v275 + 56);
    int v88 = *(_DWORD *)(*(void *)(*(void *)(v275 + 152) + 8) + 24);
    unsigned int v89 = [v268 forceCellular];
    CFStringRef v90 = @"NO";
    *(_DWORD *)long long buf = 138413570;
    double v311 = v87;
    __int16 v312 = 2112;
    if (v265) {
      CFStringRef v91 = @"YES";
    }
    else {
      CFStringRef v91 = @"NO";
    }
    if (v274) {
      CFStringRef v92 = @"YES";
    }
    else {
      CFStringRef v92 = @"NO";
    }
    *(void *)v313 = v92;
    *(_WORD *)&v313[8] = 2112;
    if (v89) {
      CFStringRef v90 = @"YES";
    }
    *(double *)&v313[10] = v269;
    __int16 v314 = 2112;
    unint64_t v315 = (unint64_t)v91;
    __int16 v316 = 1024;
    *(_DWORD *)v317 = v88;
    *(_WORD *)&v317[4] = 2112;
    *(void *)&v317[6] = v90;
    _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEFAULT, "Looked up %@   success: %@   error: %@   will retry: %@   retries: %d  tried force cell: %@", buf, 0x3Au);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    double v93 = *(double *)(v275 + 56);
    if (v274) {
      CFStringRef v94 = @"YES";
    }
    else {
      CFStringRef v94 = @"NO";
    }
    if (v265) {
      CFStringRef v95 = @"YES";
    }
    else {
      CFStringRef v95 = @"NO";
    }
    uint64_t v96 = *(unsigned int *)(*(void *)(*(void *)(v275 + 152) + 8) + 24);
    if (objc_msgSend(v268, "forceCellular", *(void *)&v245)) {
      CFStringRef v97 = @"YES";
    }
    else {
      CFStringRef v97 = @"NO";
    }
    uint64_t v258 = v96;
    CFStringRef v259 = v97;
    *((double *)&v251 + 1) = v269;
    unint64_t v256 = (unint64_t)v95;
    double v245 = v93;
    *(void *)&long long v251 = v94;
    _IDSLogEventV();
  }
  __int16 v98 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
  {
    *(double *)&CFStringRef v99 = COERCE_DOUBLE(@"NO");
    if (v274) {
      *(double *)&CFStringRef v99 = COERCE_DOUBLE(@"YES");
    }
    *(_DWORD *)long long buf = 138412290;
    double v311 = *(double *)&v99;
    _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_DEFAULT, "               Success: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    *(double *)&CFStringRef v100 = COERCE_DOUBLE(@"NO");
    if (v274) {
      *(double *)&CFStringRef v100 = COERCE_DOUBLE(@"YES");
    }
    double v245 = *(double *)&v100;
    _IDSLogV();
  }
  uint64_t v101 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v102 = [v268 uris];
    id v103 = [v102 count];
    *(_DWORD *)long long buf = 134218240;
    double v311 = v270;
    __int16 v312 = 2048;
    *(void *)v313 = v103;
    _os_log_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_DEFAULT, "    Found identity for: %lu/%lu", buf, 0x16u);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    id v104 = [v268 uris];
    double v245 = v270;
    *(void *)&long long v251 = [v104 count];
    _IDSLogV();
  }
  id v105 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v105, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v106 = [v268 forceCellular];
    *(double *)&CFStringRef v107 = COERCE_DOUBLE(@"NO");
    if (v106) {
      *(double *)&CFStringRef v107 = COERCE_DOUBLE(@"YES");
    }
    *(_DWORD *)long long buf = 138412290;
    double v311 = *(double *)&v107;
    _os_log_impl((void *)&_mh_execute_header, v105, OS_LOG_TYPE_DEFAULT, "  Tried Force Cellular: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    unsigned int v108 = [v268 forceCellular];
    *(double *)&CFStringRef v109 = COERCE_DOUBLE(@"NO");
    if (v108) {
      *(double *)&CFStringRef v109 = COERCE_DOUBLE(@"YES");
    }
    double v245 = *(double *)&v109;
    _IDSLogV();
  }
  __int16 v110 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
  {
    double v111 = *(double *)(v275 + 56);
    int v112 = *(_DWORD *)(*(void *)(*(void *)(v275 + 152) + 8) + 24);
    unsigned int v113 = [v268 forceCellular];
    CFStringRef v114 = @"NO";
    *(_DWORD *)long long buf = 138413570;
    double v311 = v111;
    __int16 v312 = 2112;
    if (v265) {
      CFStringRef v115 = @"YES";
    }
    else {
      CFStringRef v115 = @"NO";
    }
    if (v274) {
      CFStringRef v116 = @"YES";
    }
    else {
      CFStringRef v116 = @"NO";
    }
    *(void *)v313 = v116;
    *(_WORD *)&v313[8] = 2112;
    if (v113) {
      CFStringRef v114 = @"YES";
    }
    *(double *)&v313[10] = v269;
    __int16 v314 = 2112;
    unint64_t v315 = (unint64_t)v115;
    __int16 v316 = 1024;
    *(_DWORD *)v317 = v112;
    *(_WORD *)&v317[4] = 2112;
    *(void *)&v317[6] = v114;
    _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "Looked up %@   success: %@   error: %@   will retry: %@   retries: %d  tried force cell: %@", buf, 0x3Au);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
  {
    double v117 = *(double *)(v275 + 56);
    uint64_t v118 = (v274 & 1) != 0 ? @"YES" : @"NO";
    __int16 v119 = v265 ? @"YES" : @"NO";
    uint64_t v120 = *(unsigned int *)(*(void *)(*(void *)(v275 + 152) + 8) + 24);
    __int16 v121 = objc_msgSend(v268, "forceCellular", *(void *)&v245, v251, v256, v258, v259)
         ? @"YES"
         : @"NO";
    uint64_t v258 = v120;
    CFStringRef v259 = v121;
    *((double *)&v251 + 1) = v269;
    unint64_t v256 = (unint64_t)v119;
    double v245 = v117;
    *(void *)&long long v251 = v118;
    _IDSLogTransport();
    if (_IDSShouldLog())
    {
      double v122 = *(double *)(v275 + 56);
      uint64_t v123 = *(unsigned int *)(*(void *)(*(void *)(v275 + 152) + 8) + 24);
      if (objc_msgSend(v268, "forceCellular", *(void *)&v245, v118, *(void *)&v269, v119, v258, v259)) {
        CFStringRef v124 = @"YES";
      }
      else {
        CFStringRef v124 = @"NO";
      }
      uint64_t v258 = v123;
      CFStringRef v259 = v124;
      *((double *)&v251 + 1) = v269;
      unint64_t v256 = (unint64_t)v119;
      double v245 = v122;
      *(void *)&long long v251 = v118;
      _IDSLogV();
    }
  }
  __int16 v125 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v125, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    double v311 = v46;
    _os_log_impl((void *)&_mh_execute_header, v125, OS_LOG_TYPE_DEFAULT, "Query Time: %f", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      double v245 = v46;
      _IDSLogTransport();
      if (_IDSShouldLog())
      {
        double v245 = v46;
        _IDSLogV();
      }
    }
  }
  CFStringRef v126 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v126, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    double v311 = v46;
    _os_log_impl((void *)&_mh_execute_header, v126, OS_LOG_TYPE_DEFAULT, "            Query Time: %f", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    double v245 = v46;
    _IDSLogV();
  }
  v127 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v127, OS_LOG_TYPE_DEFAULT))
  {
    double v128 = *(double *)(v275 + 56);
    *(_DWORD *)long long buf = 138412290;
    double v311 = v128;
    _os_log_impl((void *)&_mh_execute_header, v127, OS_LOG_TYPE_DEFAULT, "                  URIs: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    double v245 = *(double *)(v275 + 56);
    _IDSLogV();
  }
  v129 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v129, OS_LOG_TYPE_DEFAULT))
  {
    IDSLoggableDescriptionForObjectOnService();
    double v130 = COERCE_DOUBLE((id)objc_claimAutoreleasedReturnValue());
    *(_DWORD *)long long buf = 138412290;
    double v311 = v130;
    _os_log_impl((void *)&_mh_execute_header, v129, OS_LOG_TYPE_DEFAULT, "    responseIdentities: %@", buf, 0xCu);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    IDSLoggableDescriptionForObjectOnService();
    double v245 = COERCE_DOUBLE(objc_claimAutoreleasedReturnValue());
    _IDSLogV();
  }
  v131 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v131, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    double v311 = v269;
    _os_log_impl((void *)&_mh_execute_header, v131, OS_LOG_TYPE_DEFAULT, "                 error: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    double v245 = v269;
    _IDSLogV();
  }
  v132 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v132, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v133 = @"NO";
    if (v265) {
      *(double *)&CFStringRef v134 = COERCE_DOUBLE(@"YES");
    }
    else {
      *(double *)&CFStringRef v134 = COERCE_DOUBLE(@"NO");
    }
    int v135 = *(_DWORD *)(*(void *)(*(void *)(v275 + 152) + 8) + 24);
    if (v305) {
      CFStringRef v133 = @"YES";
    }
    *(_DWORD *)long long buf = 138412802;
    double v311 = *(double *)&v134;
    __int16 v312 = 1024;
    *(_DWORD *)v313 = v135;
    *(_WORD *)&v313[4] = 2112;
    *(void *)&v313[6] = v133;
    _os_log_impl((void *)&_mh_execute_header, v132, OS_LOG_TYPE_DEFAULT, "           shouldRetry: %@   retries: %d   wasOffline: %@", buf, 0x1Cu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    CFStringRef v136 = @"NO";
    if (v265) {
      *(double *)&CFStringRef v137 = COERCE_DOUBLE(@"YES");
    }
    else {
      *(double *)&CFStringRef v137 = COERCE_DOUBLE(@"NO");
    }
    if (v305) {
      CFStringRef v136 = @"YES";
    }
    *(void *)&long long v251 = *(unsigned int *)(*(void *)(*(void *)(v275 + 152) + 8) + 24);
    *((void *)&v251 + 1) = v136;
    double v245 = *(double *)&v137;
    _IDSLogV();
  }
  v138 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    LODWORD(v311) = LODWORD(v264);
    _os_log_impl((void *)&_mh_execute_header, v138, OS_LOG_TYPE_DEFAULT, "            maxRetries: %d", buf, 8u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    double v245 = v264;
    _IDSLogV();
  }
  v139 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v139, OS_LOG_TYPE_DEFAULT))
  {
    *(double *)&CFStringRef v140 = COERCE_DOUBLE(@"NO");
    if (a4 == 6003) {
      *(double *)&CFStringRef v140 = COERCE_DOUBLE(@"YES");
    }
    *(_DWORD *)long long buf = 138412290;
    double v311 = *(double *)&v140;
    _os_log_impl((void *)&_mh_execute_header, v139, OS_LOG_TYPE_DEFAULT, "         Timestamp off: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    *(double *)&CFStringRef v141 = COERCE_DOUBLE(@"NO");
    if (a4 == 6003) {
      *(double *)&CFStringRef v141 = COERCE_DOUBLE(@"YES");
    }
    double v245 = *(double *)&v141;
    _IDSLogV();
  }
  v142 = [*(id *)&v269 domain];
  unsigned int v143 = [v142 isEqualToString:NSPOSIXErrorDomain];

  v144 = [*(id *)&v269 domain];
  if ([v144 isEqualToString:NSURLErrorDomain])
  {
    unsigned int v145 = 1;
  }
  else
  {
    v146 = [*(id *)&v269 domain];
    unsigned int v145 = [v146 isEqualToString:kCFErrorDomainCFNetwork];
  }
  v147 = +[FTNetworkSupport sharedInstance];
  unsigned int v148 = [v147 wiFiActiveAndReachable];

  uint64_t v149 = 1;
  if (v148) {
    unsigned int v150 = 2;
  }
  else {
    unsigned int v150 = 1;
  }
  if ((v274 & 1) == 0) {
    uint64_t v149 = sub_1001BC02C(a4);
  }
  BOOL v267 = a4 == 6005;
  unsigned __int8 v151 = objc_msgSend(v268, "hasAttemptedAPSDelivery", *(void *)&v245, v251, v256, v258, v259);
  if ([v268 deliveryMechanism] == (id)1) {
    uint64_t v152 = 3;
  }
  else {
    uint64_t v152 = v150;
  }
  if (v145) {
    int v153 = 2;
  }
  else {
    int v153 = 1;
  }
  if (v143) {
    unsigned int v154 = 3;
  }
  else {
    unsigned int v154 = v153;
  }
  if (v269 == 0.0) {
    uint64_t v155 = 0;
  }
  else {
    uint64_t v155 = v154;
  }
  id v156 = objc_alloc((Class)IDSQueryCompletionMetric);
  uint64_t v157 = *(void *)(v275 + 64);
  uint64_t v158 = *(unsigned int *)(v275 + 176);
  BYTE1(v252) = [v272 count] == 0;
  LOBYTE(v252) = v151;
  id v271 = [v156 initWithService:v157 querySuccess:v274 & 1 connectionType:v152 queryTimeInterval:v158 queryURITypes:v149 conferenceResultCode:v155 queryErrorType:v46 queryError:*(void *)&v269 wasReversePushAttempted:v252 hasEmptyResult:*(void *)(v275 + 80) queryReason:*(int *)(*(void *)(*(void *)(v275 + 152) + 8) + 24) retryCount:objc_msgSend(*(id *)(v275 + 88) uriCount:"count")];
  v159 = +[IDSCoreAnalyticsLogger defaultLogger];
  [v159 logMetric:v271];

  if (!v267)
  {
    int v170 = 0;
    goto LABEL_261;
  }
  if (v260)
  {
    v160 = +[IDSDAccountController sharedInstance];
    uint64_t v161 = *(void *)(v275 + 64);
    v162 = [*(id *)(v275 + 72) prefixedURI];
    v163 = [v160 deviceCertificateForService:v161 uri:v162];

    if (v163)
    {
      v164 = [v268 IDCertificate];
      unsigned __int8 v165 = [v163 isEqualToData:v164];

      if ((v165 & 1) == 0)
      {
        int v166 = *(_DWORD *)(*(void *)(*(void *)(v275 + 160) + 8) + 24);
        BOOL v167 = v166 < +[IDSPeerIDQueryHandler queryRetryNumberForBadSignature];
        v168 = +[IMRGLog queryRetry];
        BOOL v169 = os_log_type_enabled(v168, OS_LOG_TYPE_DEFAULT);
        if (v167)
        {
          if (v169)
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v168, OS_LOG_TYPE_DEFAULT, "Query used old certificate, retrying", buf, 2u);
          }

          [v268 setIDCertificate:v163];
          ++*(_DWORD *)(*(void *)(*(void *)(v275 + 160) + 8) + 24);
          int v170 = 1;
          goto LABEL_260;
        }
        if (v169)
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v168, OS_LOG_TYPE_DEFAULT, "Retries exhausted, not retrying", buf, 2u);
        }
      }
    }
  }
  else
  {
    v163 = +[IMRGLog queryRetry];
    if (os_log_type_enabled(v163, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v163, OS_LOG_TYPE_DEFAULT, "Server has disabled bad query signature recovery", buf, 2u);
    }
  }
  int v170 = 0;
LABEL_260:

LABEL_261:
  if (v274 & 1 | ((v265 & 1) == 0))
  {
    if (!v170)
    {
LABEL_263:
      if (((*(void *)&v269 == 0) & v274) != 0)
      {
        double v269 = 0.0;
      }
      else
      {
        v192 = [*(id *)&v269 domain];
        unsigned int v193 = [v192 isEqualToString:FTErrorDomain];

        if (v193)
        {
          uint64_t v194 = *(void *)(v275 + 96);
          if (v194)
          {
            id v195 = +[NSDictionary dictionaryWithObject:v194 forKey:IDSPeerIDManagerFromIdentityUserInfoKey];
          }
          else
          {
            id v195 = 0;
          }
          +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", FTErrorDomain, [*(id *)&v269 code], v195);
          *(double *)&uint64_t v196 = COERCE_DOUBLE(objc_claimAutoreleasedReturnValue());

          double v269 = *(double *)&v196;
        }
        if (!*(void *)(*(void *)(*(void *)(v275 + 144) + 8) + 40))
        {
          CFMutableDictionaryRef v197 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          uint64_t v198 = *(void *)(*(void *)(v275 + 144) + 8);
          v199 = *(void **)(v198 + 40);
          *(void *)(v198 + 40) = v197;
        }
        long long v290 = 0u;
        long long v291 = 0u;
        long long v288 = 0u;
        long long v289 = 0u;
        v200 = [v268 uris];
        id v201 = [v200 countByEnumeratingWithState:&v288 objects:v309 count:16];
        if (v201)
        {
          uint64_t v202 = *(void *)v289;
          do
          {
            for (j = 0; j != v201; j = (char *)j + 1)
            {
              if (*(void *)v289 != v202) {
                objc_enumerationMutation(v200);
              }
              v204 = +[IDSURI URIWithPrefixedURI:*(void *)(*((void *)&v288 + 1) + 8 * (void)j)];
              if (v269 != 0.0) {
                [*(id *)(*(void *)(*(void *)(v275 + 144) + 8) + 40) setObject:*(void *)&v269 forKeyedSubscript:v204];
              }
            }
            id v201 = [v200 countByEnumeratingWithState:&v288 objects:v309 count:16];
          }
          while (v201);
        }
      }
      v205 = +[IMMobileNetworkManager sharedInstance];
      [v205 removeFastDormancyDisableToken:*(void *)(v275 + 104)];

      v206 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v206, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v207 = @"NO";
        if (v274) {
          CFStringRef v208 = @"YES";
        }
        else {
          CFStringRef v208 = @"NO";
        }
        double v209 = *(double *)(v275 + 112);
        if (*(unsigned char *)(*(void *)(*(void *)(v275 + 120) + 8) + 24)) {
          CFStringRef v210 = @"YES";
        }
        else {
          CFStringRef v210 = @"NO";
        }
        if (*(unsigned char *)(*(void *)(*(void *)(v275 + 136) + 8) + 24)) {
          CFStringRef v207 = @"YES";
        }
        *(_DWORD *)long long buf = 138413058;
        double v311 = v209;
        __int16 v312 = 2112;
        *(void *)v313 = v208;
        *(_WORD *)&v313[8] = 2112;
        *(void *)&v313[10] = v210;
        __int16 v314 = 2112;
        unint64_t v315 = (unint64_t)v207;
        _os_log_impl((void *)&_mh_execute_header, v206, OS_LOG_TYPE_DEFAULT, "  All done query set for: %@   success: %@  allNetworkFailures: %@  entirelyOffline: %@", buf, 0x2Au);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        CFStringRef v211 = @"NO";
        if (v274) {
          CFStringRef v212 = @"YES";
        }
        else {
          CFStringRef v212 = @"NO";
        }
        if (*(unsigned char *)(*(void *)(*(void *)(v275 + 120) + 8) + 24)) {
          CFStringRef v213 = @"YES";
        }
        else {
          CFStringRef v213 = @"NO";
        }
        if (*(unsigned char *)(*(void *)(*(void *)(v275 + 136) + 8) + 24)) {
          CFStringRef v211 = @"YES";
        }
        CFStringRef v255 = v213;
        CFStringRef v257 = v211;
        double v246 = *(double *)(v275 + 112);
        CFStringRef v253 = v212;
        _IDSLogEventV();
      }
      if (objc_msgSend(*(id *)(v275 + 88), "count", *(void *)&v246, v253, v255, v257)
        && *(unsigned char *)(*(void *)(*(void *)(v275 + 120) + 8) + 24)
        && !+[IDSPeerIDQueryHandler isServerBackoffModeActive])
      {
        v214 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v214, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v214, OS_LOG_TYPE_DEFAULT, " **** Every failure was a network failure - forcing the bag to reload", buf, 2u);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
          _IDSLogV();
        }
        v215 = +[IDSServerBag sharedInstanceForBagType:0];
        [v215 forceBagLoad];
      }
      v191 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
      long long v286 = 0u;
      long long v287 = 0u;
      long long v284 = 0u;
      long long v285 = 0u;
      id v216 = *(id *)(v275 + 112);
      id v217 = [v216 countByEnumeratingWithState:&v284 objects:v308 count:16];
      if (v217)
      {
        uint64_t v218 = *(void *)v285;
        do
        {
          for (k = 0; k != v217; k = (char *)k + 1)
          {
            if (*(void *)v285 != v218) {
              objc_enumerationMutation(v216);
            }
            v220 = *(void **)(*((void *)&v284 + 1) + 8 * (void)k);
            v222 = [v220 tokenFreeURI];
            v223 = [v222 prefixedURI];

            v224 = [v272 _dictionaryForKey:v223];
            v225 = [v224 _numberForKey:@"negative-cache-ttl-seconds"];

            if (v225) {
              CFDictionarySetValue(v191, v223, v225);
            }
          }
          id v217 = [v216 countByEnumeratingWithState:&v284 objects:v308 count:16];
        }
        while (v217);
      }

      v226 = [*(id *)(v275 + 32) _completionBlocksForURIs:*(void *)(v275 + 112) fromURI:*(void *)(v275 + 72) fromService:*(void *)(v275 + 64) forRefresh:*(unsigned __int8 *)(v275 + 181)];
      id v227 = [v226 copy];

      long long v282 = 0u;
      long long v283 = 0u;
      long long v280 = 0u;
      long long v281 = 0u;
      id v228 = v227;
      id v229 = [v228 countByEnumeratingWithState:&v280 objects:v307 count:16];
      if (v229)
      {
        uint64_t v230 = *(void *)v281;
        do
        {
          for (m = 0; m != v229; m = (char *)m + 1)
          {
            if (*(void *)v281 != v230) {
              objc_enumerationMutation(v228);
            }
            (*(void (**)(void, void))(*(void *)(*((void *)&v280 + 1) + 8 * (void)m) + 16))(*(void *)(*((void *)&v280 + 1) + 8 * (void)m), *(void *)(v275 + 72));
          }
          id v229 = [v228 countByEnumeratingWithState:&v280 objects:v307 count:16];
        }
        while (v229);
      }

      v232 = [*(id *)(*(void *)(v275 + 32) + 40) allValues];
      id v233 = [v232 copy];

      long long v278 = 0u;
      long long v279 = 0u;
      long long v276 = 0u;
      long long v277 = 0u;
      id v234 = v233;
      id v235 = [v234 countByEnumeratingWithState:&v276 objects:v306 count:16];
      if (v235)
      {
        uint64_t v236 = *(void *)v277;
        do
        {
          for (n = 0; n != v235; n = (char *)n + 1)
          {
            if (*(void *)v277 != v236) {
              objc_enumerationMutation(v234);
            }
            (*(void (**)(void, void))(*(void *)(*((void *)&v276 + 1) + 8 * (void)n) + 16))(*(void *)(*((void *)&v276 + 1) + 8 * (void)n), *(void *)(v275 + 72));
          }
          id v235 = [v234 countByEnumeratingWithState:&v276 objects:v306 count:16];
        }
        while (v235);
      }

      [*(id *)(v275 + 32) _removeCompletionBlocksForURIs:*(void *)(v275 + 112) fromURI:*(void *)(v275 + 72) fromService:*(void *)(v275 + 64) forRefresh:*(unsigned __int8 *)(v275 + 181)];
      uint64_t v238 = *(void *)(*(void *)(v275 + 144) + 8);
      v239 = *(void **)(v238 + 40);
      *(void *)(v238 + 40) = 0;

      uint64_t v240 = *(void *)(*(void *)(v275 + 168) + 8);
      v241 = *(void **)(v240 + 40);
      *(void *)(v240 + 40) = 0;

      goto LABEL_392;
    }
  }
  else
  {
    if (*(_DWORD *)(*(void *)(*(void *)(v275 + 152) + 8) + 24) < SLODWORD(v264)) {
      char v171 = 1;
    }
    else {
      char v171 = v170;
    }
    if ((v171 & 1) == 0) {
      goto LABEL_263;
    }
  }
  uint64_t v172 = *(void *)(*(void *)(v275 + 144) + 8);
  v173 = *(void **)(v172 + 40);
  *(void *)(v172 + 40) = 0;

  uint64_t v174 = v275 + 152;
  ++*(_DWORD *)(*(void *)(*(void *)(v275 + 152) + 8) + 24);
  if (v305) {
    double v175 = 20.0;
  }
  else {
    double v175 = 5.0;
  }
  if (v305) {
    double v176 = 10.0;
  }
  else {
    double v176 = 3.0;
  }
  int v177 = *(_DWORD *)(*(void *)(*(void *)v174 + 8) + 24);
  objc_msgSend(v268, "setForceCellular:", objc_msgSend(v268, "forceCellular") ^ 1);
  if (v305) {
    double v178 = 120.0;
  }
  else {
    double v178 = 30.0;
  }
  if (v178 >= v175 * ((double)v177 / 15.0 * v176 + 1.0)) {
    double v179 = v175 * ((double)v177 / 15.0 * v176 + 1.0);
  }
  else {
    double v179 = v178;
  }
  if (v175 >= v179) {
    double v180 = v175;
  }
  else {
    double v180 = v179;
  }
  +[IDSPeerIDQueryHandler queryRetryIntervalForBadSignature];
  double v182 = v181;
  if (*(int *)(*(void *)(*(void *)v174 + 8) + 24) >= 2) {
    [v268 setImportanceLevel:1];
  }
  v183 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v183, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    double v311 = v178;
    _os_log_impl((void *)&_mh_execute_header, v183, OS_LOG_TYPE_DEFAULT, " Max Query Interval: %f", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    double v246 = v178;
    _IDSLogV();
  }
  v184 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v184, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    double v311 = v176;
    _os_log_impl((void *)&_mh_execute_header, v184, OS_LOG_TYPE_DEFAULT, "   Query Multiplier: %f", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    double v246 = v176;
    _IDSLogV();
  }
  v185 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v185, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    double v311 = v175;
    _os_log_impl((void *)&_mh_execute_header, v185, OS_LOG_TYPE_DEFAULT, " Base Retry Interval: %f", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    double v246 = v175;
    _IDSLogV();
  }
  v186 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v186, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    double v311 = v175 * ((double)v177 / 15.0 * v176 + 1.0);
    _os_log_impl((void *)&_mh_execute_header, v186, OS_LOG_TYPE_DEFAULT, "      Retry Interval: %f", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    double v246 = v175 * ((double)v177 / 15.0 * v176 + 1.0);
    _IDSLogV();
  }
  if (+[IDSPeerIDQueryHandler isServerBackoffModeActive]&& !*(unsigned char *)(v275 + 180))
  {
    double v180 = (double)+[IDSPeerIDQueryHandler serverBackoffModeReceiverRetryInterval];
    v187 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v187, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      double v311 = v180;
      _os_log_impl((void *)&_mh_execute_header, v187, OS_LOG_TYPE_DEFAULT, " **** We are in backoff mode! Overriding retry interval %f", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      double v247 = v180;
      _IDSLogV();
    }
    double v182 = (double)+[IDSPeerIDQueryHandler serverBackoffModeReceiverRetryInterval];
  }
  if (!v170) {
    double v182 = v180;
  }
  v188 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v188, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    double v311 = v182;
    _os_log_impl((void *)&_mh_execute_header, v188, OS_LOG_TYPE_DEFAULT, " ** Will retry in: %f", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  v292 = _NSConcreteStackBlock;
  uint64_t v293 = 3221225472;
  v294 = sub_10037DA18;
  v295 = &unk_10097E418;
  v296 = (__CFDictionary *)v268;
  id v189 = *(id *)(v275 + 56);
  uint64_t v190 = *(void *)(v275 + 32);
  id v297 = v189;
  uint64_t v298 = v190;
  im_dispatch_after_primary_queue();

  v191 = v296;
LABEL_392:
}

IDSURI *sub_10037DA00(uint64_t a1, uint64_t a2)
{
  return +[IDSURI URIWithPrefixedURI:a2 withServiceLoggingHint:*(void *)(a1 + 32)];
}

id sub_10037DA18(uint64_t a1)
{
  unint64_t v2 = +[NetworkChangeNotifier sharedInstance];
  id v3 = [v2 linkQualityForInterfaceType:2];

  if (v3 != (id)2)
  {
    int v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, " ** WiFi link quality is not good, requesting cellular preferred", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    [*(id *)(a1 + 32) setForceCellular:1];
  }
  id v5 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 138412290;
    uint64_t v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, " => Retrying query for URIs: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v10 = *(void *)(a1 + 40);
    _IDSLogV();
  }
  int v7 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 138412290;
    uint64_t v12 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, " => Retrying query for URIs: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v10 = *(void *)(a1 + 40);
    _IDSLogV();
  }
  return objc_msgSend(*(id *)(*(void *)(a1 + 48) + 16), "sendMessage:", *(void *)(a1 + 32), v10);
}

id sub_10037DCC4(uint64_t a1)
{
  return [*(id *)(a1 + 32) _dequeuePendingQueryIfPossible];
}

void sub_10037E95C(id a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  int v7 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218496;
    unint64_t v9 = a2;
    __int16 v10 = 2048;
    unint64_t v11 = a3;
    __int16 v12 = 2048;
    unint64_t v13 = a4;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Send attachment message progress updated to %lld of %lld (%lld bps)", buf, 0x20u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLog()) {
      _IDSLogV();
    }
  }
}

void sub_10037EA88(uint64_t a1, void *a2, int a3, void *a4, void *a5, void *a6, void *a7, void *a8, void *a9, uint64_t a10)
{
  id v17 = a2;
  id v18 = a4;
  id v46 = a5;
  id value = a6;
  id v49 = a7;
  id v19 = a8;
  id v47 = a9;
  uint64_t v48 = v17;
  if (a3)
  {
    __int16 v20 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v59 = v17;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Succeeded uploading file transfer: %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      id v45 = v17;
      _IDSLogV();
    }
    int8x16_t v21 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
    uint64_t v22 = v21;
    if (value) {
      CFDictionarySetValue(v21, @"mmcs-owner", value);
    }
    if (v19) {
      CFDictionarySetValue(v22, @"mmcs-url", v19);
    }
    long long v23 = objc_msgSend(v49, "__imHexString", v45);
    if (v23) {
      CFDictionarySetValue(v22, @"mmcs-signature-hex", v23);
    }

    unsigned __int8 v24 = objc_alloc_init(IDSAttachmentEncryptionParameter);
    __int16 v25 = JWEncodeDictionary();
    [(IDSAttachmentEncryptionParameter *)v24 setDataToEncrypt:v25];

    uint64_t v26 = IMSingleObjectArray();
    [(IDSAttachmentEncryptionParameter *)v24 setEndpoints:v26];

    [(IDSAttachmentEncryptionParameter *)v24 setGuid:*(void *)(a1 + 40)];
    [(IDSAttachmentEncryptionParameter *)v24 setEncryptionType:*(void *)(a1 + 88)];
    [(IDSAttachmentEncryptionParameter *)v24 setFromID:*(void *)(a1 + 48)];
    [(IDSAttachmentEncryptionParameter *)v24 setService:*(void *)(a1 + 56)];
    double v27 = [IDSEncryptionComponent alloc];
    int v28 = *(void **)(a1 + 64);
    uint64_t v29 = v28[1];
    uint64_t v30 = [v28 pinnedIdentityController];
    char v31 = [(IDSEncryptionComponent *)v27 initWithEncryptionController:v29 pinnedIdentityController:v30];

    int8x16_t v57 = v31;
    double v32 = +[NSArray arrayWithObjects:&v57 count:1];
    id v33 = +[IDSPipelineComponent pipelineFromComponents:v32];

    id v34 = [v33 runWithInput:v24];
    v52[0] = _NSConcreteStackBlock;
    v52[1] = 3221225472;
    v52[2] = sub_10037F0CC;
    v52[3] = &unk_10098A530;
    id v53 = *(id *)(a1 + 72);
    id v54 = *(id *)(a1 + 80);
    id v55 = *(id *)(a1 + 32);
    uint64_t v56 = a10;
    [v34 registerResultBlock:v52];
  }
  else
  {
    long long v35 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v36 = *(void **)(a1 + 72);
      *(_DWORD *)long long buf = 138412290;
      id v59 = v36;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "Failed uploading attachment file transfer: %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      id v45 = *(id *)(a1 + 72);
      _IDSLogV();
    }
    int v37 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
    uint64_t v22 = v37;
    if (v19) {
      CFDictionarySetValue(v37, @"url", v19);
    }
    CFStringRef v38 = objc_msgSend(v18, "domain", v45);
    if (v38) {
      CFDictionarySetValue(v22, @"eD", v38);
    }

    id v39 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [v18 code]);
    if (v39) {
      CFDictionarySetValue(v22, @"eC", v39);
    }

    int v40 = +[NSNumber numberWithInteger:a10];
    if (v40) {
      CFDictionarySetValue(v22, @"fS", v40);
    }

    unsigned __int8 v24 = (IDSAttachmentEncryptionParameter *)objc_msgSend(objc_alloc((Class)NSDictionary), "initWithObjectsAndKeys:", @"Failed uploading attachment file transfer (failed upload)", NSLocalizedDescriptionKey, v22, @"MMCSUploadErrorKey", 0, v46, v47);
    id v41 = objc_alloc((Class)NSError);
    char v31 = (IDSEncryptionComponent *)[v41 initWithDomain:IDSSendErrorDomain code:4 userInfo:v24];
    [*(id *)(a1 + 80) failWithError:v31];
    BOOL v42 = +[NSFileManager defaultManager];
    uint64_t v43 = *(void *)(a1 + 72);
    id v51 = 0;
    unsigned __int8 v44 = [v42 removeItemAtPath:v43 error:&v51];
    id v33 = v51;

    if ((v44 & 1) == 0 && _IMWillLog()) {
      _IMAlwaysLog();
    }
  }
}

void sub_10037F0CC(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 state] == (id)1)
  {
    int v4 = +[NSFileManager defaultManager];
    uint64_t v5 = *(void *)(a1 + 32);
    id v20 = 0;
    unsigned __int8 v6 = [v4 removeItemAtPath:v5 error:&v20];
    id v7 = v20;

    if ((v6 & 1) == 0 && _IMWillLog()) {
      _IMAlwaysLog();
    }
    id v8 = objc_alloc((Class)NSDictionary);
    unint64_t v9 = [v3 error];
    id v10 = objc_msgSend(v8, "initWithObjectsAndKeys:", @"Failed uploading attachment file transfer (failed post-upload encryption)", NSLocalizedDescriptionKey, v9, NSUnderlyingErrorKey, 0);

    id v11 = objc_alloc((Class)NSError);
    id v12 = [v11 initWithDomain:IDSSendErrorDomain code:4 userInfo:v10];
    [*(id *)(a1 + 40) failWithError:v12];
  }
  else
  {
    unint64_t v13 = [v3 value];
    uint32_t v14 = [v13 endpointsToEncryptedData];
    id v7 = [v14 objectForKey:*(void *)(a1 + 48)];

    BOOL v15 = [IDSMMCSUploadResult alloc];
    id v16 = +[NSNumber numberWithInteger:*(void *)(a1 + 56)];
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 3221225472;
    v18[2] = sub_10037F300;
    v18[3] = &unk_10097E4D0;
    id v19 = *(id *)(a1 + 32);
    id v17 = [(IDSMMCSUploadResult *)v15 initWithEncryptedResult:v7 dataLength:v16 fileCleanupBlock:v18];

    [*(id *)(a1 + 40) fulfillWithValue:v17];
    id v10 = v19;
  }
}

void sub_10037F300(uint64_t a1)
{
  unint64_t v2 = +[NSFileManager defaultManager];
  uint64_t v3 = *(void *)(a1 + 32);
  id v6 = 0;
  unsigned __int8 v4 = [v2 removeItemAtPath:v3 error:&v6];
  id v5 = v6;

  if ((v4 & 1) == 0 && _IMWillLog()) {
    _IMAlwaysLog();
  }
}

void sub_10037FD6C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v33 = a2;
  id v34 = a3;
  id v7 = a4;
  id v8 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v9 = [*(id *)(a1 + 32) identifier];
    *(_DWORD *)long long buf = 138413058;
    id v41 = v9;
    __int16 v42 = 2112;
    id v43 = v33;
    __int16 v44 = 2112;
    id v45 = v34;
    __int16 v46 = 2112;
    id v47 = v7;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Updating listener on %@ willSendToDestinations %@ skipped %@ regPropToDest %@", buf, 0x2Au);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    [*(id *)(a1 + 32) identifier];
    id v31 = v34;
    uint64_t v29 = v32 = v7;
    id v30 = v33;
    _IDSLogV();
  }
  id v10 = objc_alloc_init((Class)NSMutableDictionary);
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  id v11 = v7;
  id v12 = [v11 countByEnumeratingWithState:&v35 objects:v39 count:16];
  if (v12)
  {
    uint64_t v13 = *(void *)v36;
    do
    {
      for (uint64_t i = 0; i != v12; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v36 != v13) {
          objc_enumerationMutation(v11);
        }
        uint64_t v15 = *(void *)(*((void *)&v35 + 1) + 8 * i);
        id v16 = objc_msgSend(v11, "objectForKeyedSubscript:", v15, v29, v30, v31, v32);
        id v17 = objc_msgSend(v16, "__imArrayByApplyingBlock:", &stru_10098A578);
        [v10 setObject:v17 forKeyedSubscript:v15];
      }
      id v12 = [v11 countByEnumeratingWithState:&v35 objects:v39 count:16];
    }
    while (v12);
  }

  id v18 = +[IDSDaemon sharedInstance];
  id v19 = [*(id *)(a1 + 40) localObject];
  id v20 = [v18 broadcasterForLocalObject:v19 messageContext:*(void *)(a1 + 40)];

  if (v20)
  {
    uint64_t v22 = *(void **)(a1 + 32);
    int8x16_t v21 = (id *)(a1 + 32);
    long long v23 = [v22 identifier];
    unsigned __int8 v24 = [*v21 alternateCallbackID];
    __int16 v25 = [*v21 mainAccountUUID];
    uint64_t v26 = objc_msgSend(v33, "__imArrayByApplyingBlock:", &stru_10098A598);
    double v27 = objc_msgSend(v34, "__imArrayByApplyingBlock:", &stru_10098A5B8);
    id v28 = [v10 copy];
    [v20 messageIdentifier:v23 alternateCallbackID:v24 forAccount:v25 willSendToDestinations:v26 skippedDestinations:v27 registrationPropertyToDestinations:v28];
  }
}

id sub_1003800F4(id a1, IDSURI *a2)
{
  return [(IDSURI *)a2 prefixedURI];
}

id sub_1003800FC(id a1, IDSURI *a2)
{
  return [(IDSURI *)a2 prefixedURI];
}

id sub_100380104(id a1, IDSURI *a2)
{
  return [(IDSURI *)a2 prefixedURI];
}

void sub_10038010C(uint64_t a1, void *a2)
{
  id v3 = a2;
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(*(os_activity_t *)(a1 + 32), &state);
  unsigned __int8 v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = [*(id *)(a1 + 40) identifier];
    id v6 = [v3 idsResponseCode];
    id v7 = [v3 responseError];
    unsigned int v8 = [v3 lastCall];
    CFStringRef v9 = @"NO";
    uint64_t v10 = *(void *)(a1 + 48);
    *(_DWORD *)long long buf = 138413314;
    if (v8) {
      CFStringRef v9 = @"YES";
    }
    id v67 = v5;
    __int16 v68 = 2048;
    id v69 = v6;
    __int16 v70 = 2112;
    id v71 = v7;
    __int16 v72 = 2112;
    CFStringRef v73 = v9;
    __int16 v74 = 2112;
    uint64_t v75 = v10;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Updating listener on %@ with responseCode %ld error %@  lastCall %@ - messageContext %@", buf, 0x34u);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    id v11 = [*(id *)(a1 + 40) identifier];
    id v12 = [v3 idsResponseCode];
    uint64_t v13 = [v3 responseError];
    unsigned int v14 = [v3 lastCall];
    CFStringRef v15 = @"NO";
    if (v14) {
      CFStringRef v15 = @"YES";
    }
    CFStringRef v58 = v15;
    uint64_t v59 = *(void *)(a1 + 48);
    id v56 = v12;
    int8x16_t v57 = v13;
    id v54 = v11;
    _IDSLogV();
  }
  id v16 = objc_msgSend(v3, "responseError", v54, v56, v57, v58, v59);
  if ([v16 code] != (id)24)
  {

LABEL_19:
    int8x16_t v21 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
    id v23 = *(id *)(a1 + 56);
    if (v23) {
      CFDictionarySetValue(v21, IDSMessageContextServiceIdentifierKey, v23);
    }

    unsigned __int8 v24 = [*(id *)(a1 + 40) localDestinationDeviceUUID];
    if (v24) {
      CFDictionarySetValue(v21, IDSMessageContextOriginalDestinationDeviceKey, v24);
    }

    __int16 v25 = [*(id *)(a1 + 40) destinationCorrelationIdentifier];
    if (v25) {
      CFDictionarySetValue(v21, IDSMessageContextDestinationCorrelationIdentifierKey, v25);
    }

    uint64_t v26 = [*(id *)(a1 + 40) fromID];
    if (v26) {
      CFDictionarySetValue(v21, IDSMessageContextFromIDKey, v26);
    }

    double v27 = [v3 responseTimeStamp];

    if (v27)
    {
      id v28 = [v3 responseTimeStamp];
      uint64_t v29 = sub_100380B30(v28);

      [v29 timeIntervalSince1970];
      id v31 = v30;
      id v32 = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:");
      if (v32) {
        CFDictionarySetValue(v21, IDSMessageContextServerTimestampKey, v32);
      }

      id v33 = [*(id *)(a1 + 40) command];
      if (v33) {
        CFDictionarySetValue(v21, IDSMessageContextOriginalCommandKey, v33);
      }

      id v34 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134217984;
        id v67 = v31;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "ServerTimeStamps before broadcast is  %f", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        id v55 = v31;
        _IDSLogV();
      }
      long long v35 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v67 = v29;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "ServerDate before broadcast is  %@", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        id v55 = v29;
        _IDSLogV();
      }
    }
    long long v36 = objc_msgSend(v3, "currentAverageRTT", v55);
    if (v36) {
      CFDictionarySetValue(v21, IDSMessageContextAverageLocalRTTKey, v36);
    }

    long long v37 = [v3 localMessageState];
    if (v37) {
      CFDictionarySetValue(v21, IDSMessageContextLocalMessageStateKey, v37);
    }

    long long v38 = [v3 endpointState];
    if (v38) {
      CFDictionarySetValue(v21, IDSMessageContextEndpointStateKey, v38);
    }

    id v39 = [v3 isDeviceBlackedOut];
    if (v39) {
      CFDictionarySetValue(v21, IDSMessageContextDeviceBlackedOutKey, v39);
    }

    int v40 = [v3 wpConnectionErrorDomain];
    if (v40) {
      CFDictionarySetValue(v21, IDSMessageContextWPConnectionErrorDomainKey, v40);
    }

    id v41 = [v3 wpConnectionErrorCode];
    if (v41) {
      CFDictionarySetValue(v21, IDSMessageContextWPConnectionErrorCodeKey, v41);
    }

    __int16 v42 = [v3 wpConnectionErrorUserInfo];
    if (v42) {
      CFDictionarySetValue(v21, IDSMessageContextWPConnectionErrorUserInfoKey, v42);
    }

    id v43 = [*(id *)(a1 + 88) daemon];
    __int16 v44 = [*(id *)(a1 + 48) localObject];
    uint64_t v22 = [v43 broadcasterForLocalObject:v44 messageContext:*(void *)(a1 + 48)];

    if (v22)
    {
      id v45 = [*(id *)(a1 + 40) command];
      unsigned int v46 = [v45 isEqualToNumber:&off_1009D1E30];

      if (v46)
      {
        if (([v3 lastCall] & 1) == 0) {
          goto LABEL_67;
        }
        id v47 = [*(id *)(a1 + 40) command];
        if (v47) {
          CFDictionarySetValue(v21, IDSMessageContextOriginalCommandKey, v47);
        }
      }
      uint64_t v48 = [*(id *)(a1 + 40) identifier];
      id v49 = [*(id *)(a1 + 40) alternateCallbackID];
      uint64_t v50 = [*(id *)(a1 + 40) mainAccountUUID];
      id v51 = [v3 idsResponseCode];
      unint64_t v52 = [v3 responseError];
      objc_msgSend(v22, "messageIdentifier:alternateCallbackID:forAccount:updatedWithResponseCode:error:lastCall:context:", v48, v49, v50, v51, v52, objc_msgSend(v3, "lastCall"), v21);
    }
    else
    {
      if (![v3 lastCall]) {
        goto LABEL_67;
      }
      id v53 = *(void **)(a1 + 72);
      v60[0] = _NSConcreteStackBlock;
      v60[1] = 3221225472;
      v60[2] = sub_100380BE4;
      v60[3] = &unk_100981B50;
      id v61 = *(id *)(a1 + 40);
      id v62 = v3;
      uint64_t v63 = v21;
      id v64 = *(id *)(a1 + 64);
      [v53 enqueueBroadcast:v60 forTopic:*(void *)(a1 + 80) entitlement:kIDSMessagingEntitlement command:0 capabilities:kIDSListenerCapConsumesLaunchOnDemandOutgoingMessageUpdates messageContext:*(void *)(a1 + 48)];

      uint64_t v48 = v61;
    }

    goto LABEL_67;
  }
  BOOL v17 = *(unsigned char *)(a1 + 96) == 0;

  if (v17) {
    goto LABEL_19;
  }
  id v18 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    id v19 = *(void **)(a1 + 56);
    *(_DWORD *)long long buf = 138412290;
    id v67 = v19;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Silently failing %@ messages due to watch switch", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    id v55 = *(void **)(a1 + 56);
    _IDSLogV();
  }
  id v20 = objc_msgSend(*(id *)(a1 + 64), "dataProtectionClass", v55);
  int8x16_t v21 = [*(id *)(a1 + 40) identifier];
  uint64_t v22 = [*(id *)(a1 + 40) alternateCallbackID];
  +[IDSDMessageStore deleteOutgoingMessageWithGUID:v21 alternateGUID:v22 dataProtectionClass:v20];
LABEL_67:

  os_activity_scope_leave(&state);
}

void sub_100380A54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,os_activity_scope_state_s state)
{
}

id sub_100380B30(void *a1)
{
  id v1 = a1;
  unint64_t v2 = +[NSDate date];
  if (v1)
  {
    if ((double)(unint64_t)[v1 unsignedLongLongValue] / 1000000000.0 <= 600000.0) {
      +[NSDate date];
    }
    else {
    uint64_t v3 = +[NSDate dateWithTimeIntervalSince1970:](NSDate, "dateWithTimeIntervalSince1970:");
    }

    unint64_t v2 = (void *)v3;
  }
  id v4 = v2;

  return v4;
}

void sub_100380BE4(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = [*(id *)(a1 + 32) identifier];
    id v5 = [*(id *)(a1 + 32) alternateCallbackID];
    id v6 = [*(id *)(a1 + 32) mainAccountUUID];
    id v7 = [*(id *)(a1 + 40) idsResponseCode];
    unsigned int v8 = [*(id *)(a1 + 40) responseError];
    objc_msgSend(v3, "messageIdentifier:alternateCallbackID:forAccount:updatedWithResponseCode:error:lastCall:context:", v4, v5, v6, v7, v8, objc_msgSend(*(id *)(a1 + 40), "lastCall"), *(void *)(a1 + 48));
  }
  else if ([*(id *)(a1 + 40) lastCall])
  {
    id v9 = [*(id *)(a1 + 56) dataProtectionClass];
    uint64_t v10 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      id v11 = [*(id *)(a1 + 32) identifier];
      *(_DWORD *)long long buf = 138412290;
      id v18 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Found no valid broadcaster for outgoing message %@, cleaning up", buf, 0xCu);
    }
    if (os_log_shim_legacy_logging_enabled())
    {
      CFStringRef v15 = [*(id *)(a1 + 32) identifier];
      _IDSWarnV();

      id v16 = objc_msgSend(*(id *)(a1 + 32), "identifier", v15);
      _IDSLogV();

      unsigned int v14 = objc_msgSend(*(id *)(a1 + 32), "identifier", v16);
      _IDSLogTransport();
    }
    id v12 = objc_msgSend(*(id *)(a1 + 32), "identifier", v14);
    uint64_t v13 = [*(id *)(a1 + 32) alternateCallbackID];
    +[IDSDMessageStore deleteOutgoingMessageWithGUID:v12 alternateGUID:v13 dataProtectionClass:v9];
  }
}

void sub_10038132C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, int a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,int a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,int a35)
{
  if (a2 == 1)
  {
    objc_begin_catch(exception_object);
    objc_end_catch();
    JUMPOUT(0x100381190);
  }
  _Unwind_Resume(exception_object);
}

void sub_1003815AC(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void *)(a1 + 48);
  id v7 = v3;
  if (v4)
  {
    (*(void (**)(uint64_t, id))(v4 + 16))(v4, v3);
    id v3 = v7;
  }
  if ([v3 lastCall])
  {
    uint64_t v5 = *(void *)(a1 + 32);
    id v6 = [*(id *)(a1 + 40) alternateCallbackID];
    +[IDSDMessageStore deleteOutgoingMessageWithGUID:v5 alternateGUID:v6 dataProtectionClass:*(unsigned int *)(a1 + 56)];
  }
}

void sub_100381654(uint64_t a1)
{
  if (*(void *)(a1 + 48))
  {
    unint64_t v2 = im_primary_queue();
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    uint64_t v10 = sub_100381818;
    id v11 = &unk_10097E7F0;
    id v12 = *(id *)(a1 + 48);
    dispatch_async(v2, &block);
  }
  id v3 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *(void *)(a1 + 32);
    *(_DWORD *)long long buf = 138412290;
    uint64_t v14 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Deleting sent outgoing message with guid %@ after exception", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v7 = *(void *)(a1 + 32);
    _IDSLogV();
  }
  uint64_t v5 = *(void *)(a1 + 32);
  id v6 = objc_msgSend(*(id *)(a1 + 40), "alternateCallbackID", v7, block, v9, v10, v11);
  +[IDSDMessageStore deleteOutgoingMessageWithGUID:v5 alternateGUID:v6 dataProtectionClass:*(unsigned int *)(a1 + 56)];
}

void sub_100381818(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)IDSDeliveryContext);
  [v2 setIdsResponseCode:10];
  [v2 setLastCall:1];
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10038188C(uint64_t a1)
{
  if (*(void *)(a1 + 48))
  {
    id v2 = im_primary_queue();
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    uint64_t v10 = sub_100381A50;
    id v11 = &unk_10097E7F0;
    id v12 = *(id *)(a1 + 48);
    dispatch_async(v2, &block);
  }
  id v3 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *(void *)(a1 + 32);
    *(_DWORD *)long long buf = 138412290;
    uint64_t v14 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Deleting sent outgoing message with guid %@ after exception", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v7 = *(void *)(a1 + 32);
    _IDSLogV();
  }
  uint64_t v5 = *(void *)(a1 + 32);
  id v6 = objc_msgSend(*(id *)(a1 + 40), "alternateCallbackID", v7, block, v9, v10, v11);
  +[IDSDMessageStore deleteOutgoingMessageWithGUID:v5 alternateGUID:v6 dataProtectionClass:*(unsigned int *)(a1 + 56)];
}

void sub_100381A50(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)IDSDeliveryContext);
  [v2 setIdsResponseCode:10];
  [v2 setLastCall:1];
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100384524(char a1, int a2, void *a3)
{
  id v5 = a3;
  if (a1)
  {
LABEL_7:
    uint64_t v8 = 1;
    goto LABEL_8;
  }
  id v6 = +[IDSPairingManager sharedInstance];
  unsigned int v7 = [v6 shouldUseIPsecLinkForDefaultPairedDevice];

  uint64_t v8 = 0;
  if (a2 == 1 && v7)
  {
    uint64_t v9 = +[IMIDSLog daemon];
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 138412290;
      id v12 = v5;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Changing Class-A to AOverC for service %@", (uint8_t *)&v11, 0xCu);
    }

    goto LABEL_7;
  }
LABEL_8:

  return v8;
}

id sub_100384624(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  id v5 = v4;
  id v6 = 0;
  if (v3 && v4)
  {
    unsigned int v7 = +[NSURL fileURLWithPath:v3];
    v45[0] = v5;
    uint64_t v8 = [v7 lastPathComponent];
    v45[1] = v8;
    uint64_t v9 = +[NSArray arrayWithObjects:v45 count:2];
    id v10 = +[NSString pathWithComponents:v9];

    int v11 = [v7 lastPathComponent];
    id v12 = [v5 stringByAppendingString:v11];

    uint64_t v13 = +[NSFileManager defaultManager];
    uint64_t v14 = [v13 attributesOfItemAtPath:v10 error:0];

    if (v14)
    {
      CFStringRef v15 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v40 = v3;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "file persistence - destination file exists %@", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        _IDSLogV();
      }
      id v6 = 0;
      goto LABEL_33;
    }
    id v16 = +[NSFileManager defaultManager];
    id v38 = 0;
    unsigned __int8 v17 = [v16 moveItemAtPath:v3 toPath:v10 error:&v38];
    id v18 = v38;

    if ((v17 & 1) == 0)
    {
      id v19 = +[NSFileManager defaultManager];
      uint64_t v14 = [v19 attributesOfItemAtPath:v10 error:0];

      if (v14)
      {
LABEL_32:
        id v10 = v10;

        id v6 = v10;
LABEL_33:

        goto LABEL_34;
      }
      id v20 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412802;
        id v40 = v3;
        __int16 v41 = 2112;
        id v42 = v10;
        __int16 v43 = 2112;
        id v44 = v18;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "file persistence - failed to move file %@ => %@ (error %@)", buf, 0x20u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        id v32 = v10;
        id v34 = v18;
        id v30 = v3;
        _IDSLogV();
      }
      int8x16_t v21 = +[NSFileManager defaultManager];
      id v37 = 0;
      unsigned __int8 v22 = [v21 copyItemAtPath:v3 toPath:v10 error:&v37];
      id v23 = v37;

      if ((v22 & 1) == 0)
      {
        unsigned __int8 v24 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412802;
          id v40 = v3;
          __int16 v41 = 2112;
          id v42 = v10;
          __int16 v43 = 2112;
          id v44 = v23;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "file persistence - failed to copy file %@ => %@ (error %@)", buf, 0x20u);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
        {
          id v33 = v10;
          id v35 = v23;
          id v31 = v3;
          _IDSLogV();
        }

        id v10 = 0;
      }
      __int16 v25 = +[NSFileManager defaultManager];
      id v36 = 0;
      unsigned __int8 v26 = [v25 removeItemAtPath:v3 error:&v36];
      id v27 = v36;

      if ((v26 & 1) == 0)
      {
        id v28 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138412546;
          id v40 = v3;
          __int16 v41 = 2112;
          id v42 = v27;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEBUG, "file persistence - failed to remove original file %@ (error %@)", buf, 0x16u);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
    uint64_t v14 = 0;
    goto LABEL_32;
  }
LABEL_34:

  return v6;
}

void sub_100384B9C(uint64_t a1, void *a2, char a3, int a4)
{
  id v7 = a2;
  uint64_t v8 = v7;
  if (a3)
  {
    id v49 = v7;
    char v48 = a4;
    if (a4)
    {
      v75[0] = _NSConcreteStackBlock;
      v75[1] = 3221225472;
      v75[2] = sub_100385618;
      v75[3] = &unk_10098A680;
      uint64_t v83 = *(void *)(a1 + 104);
      id v76 = *(id *)(a1 + 32);
      id v77 = *(id *)(a1 + 40);
      id v78 = *(id *)(a1 + 48);
      id v79 = v8;
      int v84 = *(_DWORD *)(a1 + 112);
      id v80 = *(id *)(a1 + 88);
      id v81 = *(id *)(a1 + 96);
      id v82 = *(id *)(a1 + 80);
      uint64_t v9 = objc_retainBlock(v75);

      id v10 = &v76;
      int v11 = &v77;
    }
    else
    {
      if (!*(unsigned char *)(a1 + 116))
      {
        id v33 = *(void **)(a1 + 56);
        id v34 = [*(id *)(a1 + 40) identifier];
        LODWORD(v33) = [v33 _canSendNonUrgentInternetMessageForTopic:v34];

        if (v33)
        {
          id v35 = OSLogHandleForIDSCategory();
          if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "Sending a non-urgent sync message as we have a go ahead based on the server policy", buf, 2u);
          }

          if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
            _IDSLogV();
          }
          id v36 = (id *)v65;
          v65[0] = _NSConcreteStackBlock;
          v65[1] = 3221225472;
          v65[2] = sub_1003856D0;
          v65[3] = &unk_10098A680;
          uint64_t v69 = *(void *)(a1 + 104);
          v65[4] = *(id *)(a1 + 32);
          void v65[5] = *(id *)(a1 + 40);
          v65[6] = *(id *)(a1 + 48);
          v65[7] = v49;
          int v70 = *(_DWORD *)(a1 + 112);
          id v66 = *(id *)(a1 + 88);
          id v67 = *(id *)(a1 + 96);
          id v68 = *(id *)(a1 + 80);
          id v37 = objc_retainBlock(v65);
        }
        else
        {
          id v36 = (id *)v64;
          v64[0] = _NSConcreteStackBlock;
          v64[1] = 3221225472;
          v64[2] = sub_10038570C;
          v64[3] = &unk_10098A6D0;
          v64[4] = *(id *)(a1 + 32);
          v64[5] = v49;
          v64[6] = *(id *)(a1 + 56);
          v64[7] = *(id *)(a1 + 80);
          id v37 = objc_retainBlock(v64);
        }

        id v38 = im_primary_queue();
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_100385A2C;
        block[3] = &unk_10098A720;
        uint64_t v59 = *(void *)(a1 + 104);
        id v54 = *(id *)(a1 + 32);
        id v55 = v49;
        int v60 = *(_DWORD *)(a1 + 112);
        id v57 = *(id *)(a1 + 80);
        char v61 = *(unsigned char *)(a1 + 116);
        id v56 = *(id *)(a1 + 56);
        uint64_t v9 = v37;
        id v58 = v9;
        dispatch_async(v38, block);

        id v30 = v54;
        goto LABEL_32;
      }
      v71[0] = _NSConcreteStackBlock;
      v71[1] = 3221225472;
      v71[2] = sub_100385654;
      v71[3] = &unk_10098A6A8;
      id v72 = *(id *)(a1 + 32);
      id v73 = *(id *)(a1 + 48);
      int v74 = *(_DWORD *)(a1 + 112);
      uint64_t v9 = objc_retainBlock(v71);
      id v10 = &v72;
      int v11 = &v73;
    }

    if (*(unsigned char *)(a1 + 116))
    {
      id v16 = [*(id *)(a1 + 32) identifier];
      unsigned __int8 v17 = +[NSString stringWithFormat:@"message %@ on service %@", v16, *(void *)(a1 + 64)];

      id v18 = *(void **)(a1 + 104);
      uint64_t v19 = *(void *)(a1 + 64);
      uint64_t v20 = *(void *)(a1 + 72);
      uint64_t v21 = *(void *)(a1 + 32);
      unsigned __int8 v22 = +[IDSDaemonPriorityQueueController sharedInstance];
      id v23 = objc_msgSend(v22, "queueForPriority:", objc_msgSend(*(id *)(a1 + 32), "priority"));
      v62[0] = _NSConcreteStackBlock;
      v62[1] = 3221225472;
      v62[2] = sub_100385A10;
      v62[3] = &unk_100981FF0;
      uint64_t v63 = v9;
      [v18 _performDuetCheckAndSendForServiceIdentifier:v19 serviceDuetIdentifiers:v20 sendParameters:v21 logString:v17 fromQueue:v23 completionBlock:v62];
    }
    else
    {
      ((void (*)(void *, void))v9[2])(v9, 0);
    }
    if (!*(void *)(a1 + 80)) {
      goto LABEL_33;
    }
    unsigned __int8 v24 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v25 = *(void *)(a1 + 64);
      id v26 = [*(id *)(a1 + 32) identifier];
      id v27 = [*(id *)(a1 + 32) alternateCallbackID];
      *(_DWORD *)long long buf = 67109890;
      *(_DWORD *)unsigned int v86 = 11;
      *(_WORD *)&void v86[4] = 2112;
      *(void *)&v86[6] = v25;
      *(_WORD *)&v86[14] = 2112;
      *(void *)&v86[16] = v26;
      __int16 v87 = 2112;
      int v88 = v27;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Notifying client IDSResponsePersisted(%d) for %@ id %@ alt %@", buf, 0x26u);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      uint64_t v28 = *(void *)(a1 + 64);
      uint64_t v29 = [*(id *)(a1 + 32) identifier];
      [*(id *)(a1 + 32) alternateCallbackID];
      id v47 = v46 = v29;
      uint64_t v44 = 11;
      uint64_t v45 = v28;
      _IDSLogV();
    }
    id v30 = [objc_alloc((Class)IDSDeliveryContext) initWithResponseCode:11 error:0 lastCall:1];
    (*(void (**)(void, id, uint64_t, uint64_t))(*(void *)(a1 + 80) + 16))(*(void *)(a1 + 80), v30, v31, v32);
LABEL_32:

LABEL_33:
    if (objc_msgSend(*(id *)(a1 + 32), "priority", v44, v45, v46, v47) != (id)300) {
      goto LABEL_40;
    }
    if (!*(unsigned char *)(a1 + 116)) {
      goto LABEL_40;
    }
    if (v48) {
      goto LABEL_40;
    }
    id v39 = +[IDSUTunDeliveryController sharedInstance];
    unsigned int v40 = [v39 hasSpaceForMessagesWithPriority:300 dataProtectionClass:*(unsigned int *)(a1 + 112)];

    if (!v40) {
      goto LABEL_40;
    }
    __int16 v41 = +[IDSUTunDeliveryController sharedInstance];
    unsigned int v42 = [v41 hasSpaceForMessagesWithPriority:300 dataProtectionClass:*(unsigned int *)(a1 + 112)];

    if (!v42) {
      goto LABEL_40;
    }
    __int16 v43 = +[IDSDaemonPriorityQueueController sharedInstance];
    v50[0] = _NSConcreteStackBlock;
    v50[1] = 3221225472;
    v50[2] = sub_100385F68;
    v50[3] = &unk_10097FDE8;
    id v51 = *(id *)(a1 + 56);
    int v52 = *(_DWORD *)(a1 + 112);
    [v43 performBlockMainQueue:v50];

    id v13 = v51;
LABEL_39:

LABEL_40:
    uint64_t v8 = v49;
    goto LABEL_41;
  }
  if (*(void *)(a1 + 80))
  {
    id v49 = v7;
    id v12 = objc_alloc((Class)NSError);
    uint64_t v9 = [v12 initWithDomain:IDSSendErrorDomain code:18 userInfo:0];
    id v13 = [objc_alloc((Class)IDSDeliveryContext) initWithResponseCode:18 error:v9 lastCall:1];
    (*(void (**)(void))(*(void *)(a1 + 80) + 16))();
    uint64_t v14 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = *(void *)(a1 + 32);
      *(_DWORD *)long long buf = 138412546;
      *(void *)unsigned int v86 = v49;
      *(_WORD *)&v86[8] = 2112;
      *(void *)&v86[10] = v15;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Persisting message failed guid: %@  params: %@, failing with IDSResponseDataProtectionClassUnavailable", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
    goto LABEL_39;
  }
LABEL_41:
}

id sub_100385618(uint64_t a1)
{
  return [*(id *)(a1 + 88) _forwardSendMessageToAccountWithSendParameters:*(void *)(a1 + 32) service:*(void *)(a1 + 40) threadContext:*(void *)(a1 + 48) guid:*(void *)(a1 + 56) dataProtectionClass:*(unsigned int *)(a1 + 96) willSendBlock:*(void *)(a1 + 64) progressBlock:*(void *)(a1 + 72) completionBlock:*(void *)(a1 + 80)];
}

void sub_100385654(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) accountUUID];
  +[IDSDaemon _sendLocalDeliveryMessagesForAccountUUID:threadContext:priority:dataProtectionClass:](IDSDaemon, "_sendLocalDeliveryMessagesForAccountUUID:threadContext:priority:dataProtectionClass:", v2, *(void *)(a1 + 40), [*(id *)(a1 + 32) priority], *(unsigned int *)(a1 + 48));
}

id sub_1003856D0(uint64_t a1)
{
  return [*(id *)(a1 + 88) _forwardSendMessageToAccountWithSendParameters:*(void *)(a1 + 32) service:*(void *)(a1 + 40) threadContext:*(void *)(a1 + 48) guid:*(void *)(a1 + 56) dataProtectionClass:*(unsigned int *)(a1 + 96) willSendBlock:*(void *)(a1 + 64) progressBlock:*(void *)(a1 + 72) completionBlock:*(void *)(a1 + 80)];
}

void sub_10038570C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    id v5 = [*(id *)(a1 + 32) message];
    id v6 = [*(id *)(a1 + 32) destinations];
    id v7 = [*(id *)(a1 + 32) identifier];
    uint64_t v8 = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 138413314;
    id v21 = v3;
    __int16 v22 = 2112;
    id v23 = v5;
    __int16 v24 = 2112;
    id v25 = v6;
    __int16 v26 = 2112;
    id v27 = v7;
    __int16 v28 = 2112;
    uint64_t v29 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "account %@ sendMessage: %@ to: %@ identifier: %@ guid: %@ - non-urgent message has been persisted.", buf, 0x34u);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v9 = [*(id *)(a1 + 32) message];
    id v10 = [*(id *)(a1 + 32) destinations];
    id v18 = [*(id *)(a1 + 32) identifier];
    uint64_t v19 = *(void *)(a1 + 40);
    id v16 = v9;
    unsigned __int8 v17 = v10;
    id v14 = v3;
    _IDSLogV();
  }
  objc_msgSend(*(id *)(a1 + 48), "_processOutgoingNonUrgentInternetMessages", v14, v16, v17, v18, v19);
  if (*(void *)(a1 + 56))
  {
    int v11 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      id v12 = [*(id *)(a1 + 32) message];
      *(_DWORD *)long long buf = 138412290;
      id v21 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Non-urgent message send %@ will be maintained by us from now on, alerting sender that it's been persisted and scheduled for sending.", buf, 0xCu);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      uint64_t v15 = [*(id *)(a1 + 32) message];
      _IDSLogV();
    }
    id v13 = [objc_alloc((Class)IDSDeliveryContext) initWithResponseCode:0 error:0 lastCall:1];
    (*(void (**)(void))(*(void *)(a1 + 56) + 16))(*(void *)(a1 + 56));
  }
}

uint64_t sub_100385A10(uint64_t result, int a2)
{
  if (a2) {
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
  }
  return result;
}

void sub_100385A2C(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 72) accountController];
  id v3 = [*(id *)(a1 + 32) accountUUID];
  id v4 = [v2 accountWithUniqueID:v3];

  if (!v4)
  {
    id v12 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      id v13 = [*(id *)(a1 + 32) accountUUID];
      *(_DWORD *)long long buf = 138412290;
      *(void *)id v39 = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "(Messaging2) No account found for ID: %@", buf, 0xCu);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      id v33 = [*(id *)(a1 + 32) accountUUID];
      _IDSLogV();
    }
    IMLogBacktrace();
    uint64_t v14 = *(void *)(a1 + 40);
    uint64_t v15 = [*(id *)(a1 + 32) alternateCallbackID];
    +[IDSDMessageStore deleteOutgoingMessageWithGUID:v14 alternateGUID:v15 dataProtectionClass:*(unsigned int *)(a1 + 80)];

    id v16 = objc_alloc((Class)NSError);
    id v17 = [v16 initWithDomain:IDSSendErrorDomain code:2 userInfo:0];
    if (*(void *)(a1 + 56))
    {
      id v18 = [objc_alloc((Class)IDSDeliveryContext) initWithResponseCode:2 error:v17 lastCall:1];
      (*(void (**)(void))(*(void *)(a1 + 56) + 16))(*(void *)(a1 + 56));
    }
    goto LABEL_19;
  }
  if (*(unsigned char *)(a1 + 84))
  {
    id v5 = [*(id *)(a1 + 32) identifier];
    id v6 = [v4 service];
    id v7 = [v6 identifier];
    uint64_t v8 = +[NSString stringWithFormat:@"message %@ on service %@", v5, v7];

    uint64_t v9 = *(void **)(a1 + 48);
    uint64_t v10 = *(void *)(a1 + 32);
    int v11 = im_primary_queue();
    v35[0] = _NSConcreteStackBlock;
    v35[1] = 3221225472;
    v35[2] = sub_100385F4C;
    v35[3] = &unk_10098A6F8;
    id v37 = *(id *)(a1 + 64);
    id v36 = v4;
    [v9 _performDuetCheckAndSendForAccount:v36 sendParameters:v10 logString:v8 fromQueue:v11 completionBlock:v35];
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
  }
  if (*(void *)(a1 + 56))
  {
    uint64_t v19 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = [v4 service];
      id v21 = [v20 identifier];
      id v22 = [*(id *)(a1 + 32) identifier];
      id v23 = [*(id *)(a1 + 32) alternateCallbackID];
      *(_DWORD *)long long buf = 67109890;
      *(_DWORD *)id v39 = 11;
      *(_WORD *)&void v39[4] = 2112;
      *(void *)&v39[6] = v21;
      __int16 v40 = 2112;
      id v41 = v22;
      __int16 v42 = 2112;
      __int16 v43 = v23;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Notifying client IDSResponsePersisted(%d) for %@ id %@ alt %@", buf, 0x26u);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      __int16 v24 = [v4 service];
      id v25 = [v24 identifier];
      __int16 v26 = [*(id *)(a1 + 32) identifier];
      id v34 = [*(id *)(a1 + 32) alternateCallbackID];
      _IDSLogV();
    }
    id v17 = [objc_alloc((Class)IDSDeliveryContext) initWithResponseCode:11 error:0 lastCall:0];
    (*(void (**)(void, id, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 56)
                                                                                             + 16))(*(void *)(a1 + 56), v17, v27, v28, v29, v30, v31, v32);
LABEL_19:
  }
}

void sub_100385F18(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x100385C20);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100385F4C(uint64_t result, int a2)
{
  if (a2) {
    return (*(uint64_t (**)(void, void))(*(void *)(result + 40) + 16))(*(void *)(result + 40), *(void *)(result + 32));
  }
  return result;
}

void sub_100385F68(uint64_t a1)
{
  id v3 = *(void **)(a1 + 32);
  id v4 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(a1 + 40)];
  id v5 = +[NSArray arrayWithObject:v4];
  [v3 _handleSpaceBecomingAvailableForUrgentLocalMessagesWithDataProtectionClasses:v5 withMessageTypes:0];
}

void sub_100386D80(_Unwind_Exception *exc_buf, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(exc_buf);
    objc_end_catch();
    JUMPOUT(0x100386310);
  }
  _Unwind_Resume(exc_buf);
}

void sub_100386E00(id *a1, void *a2)
{
  id v3 = a2;
  if (![v3 lastCall]) {
    goto LABEL_29;
  }
  id v4 = [a1[4] servicePushTopic];
  id v5 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
  id v6 = [a1[4] subService];
  id v7 = [v6 length];
  id v8 = a1[4];
  if (v7) {
    [v8 subService];
  }
  else {
  uint64_t v9 = [v8 serviceIdentifier];
  }

  if (v9) {
    CFDictionarySetValue(v5, IDSMessageContextServiceIdentifierKey, v9);
  }
  uint64_t v10 = [a1[5] localDestinationDeviceUUID];
  if (v10) {
    CFDictionarySetValue(v5, IDSMessageContextOriginalDestinationDeviceKey, v10);
  }

  if (v4)
  {
    int v11 = [v3 responseError];
    if ([v11 code] == (id)24)
    {
      unsigned int v12 = [a1[4] silentlyFailMessagesOnSwitch];

      if (v12)
      {
        id v13 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          id v31 = v9;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Silently failing %@ messages due to watch switch", buf, 0xCu);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
        {
          __int16 v24 = v9;
          _IDSLogV();
        }
        goto LABEL_19;
      }
    }
    else
    {
    }
    uint64_t v14 = +[IDSDaemon sharedInstance];
    v26[0] = _NSConcreteStackBlock;
    v26[1] = 3221225472;
    v26[2] = sub_10038726C;
    v26[3] = &unk_100980138;
    id v27 = a1[5];
    id v28 = v3;
    uint64_t v29 = v5;
    [v14 enqueueBroadcast:v26 forTopic:v4 entitlement:kIDSMessagingEntitlement command:0 capabilities:kIDSListenerCapConsumesLaunchOnDemandOutgoingMessageUpdates messageContext:0];
  }
LABEL_19:
  uint64_t v15 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    id v16 = [a1[6] guid];
    unsigned int v17 = [v3 lastCall];
    CFStringRef v18 = @"NO";
    if (v17) {
      CFStringRef v18 = @"YES";
    }
    *(_DWORD *)long long buf = 138412546;
    id v31 = v16;
    __int16 v32 = 2112;
    CFStringRef v33 = v18;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Deleting sent outgoing non-urgent local message with guid %@? %@", buf, 0x16u);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v19 = [a1[6] guid];
    unsigned int v20 = [v3 lastCall];
    CFStringRef v21 = @"NO";
    if (v20) {
      CFStringRef v21 = @"YES";
    }
    __int16 v24 = v19;
    CFStringRef v25 = v21;
    _IDSLogV();
  }
  id v22 = objc_msgSend(a1[6], "guid", v24, v25);
  id v23 = [a1[6] alternateGUID];
  +[IDSDMessageStore deleteOutgoingMessageWithGUID:alternateGUID:dataProtectionClass:](IDSDMessageStore, "deleteOutgoingMessageWithGUID:alternateGUID:dataProtectionClass:", v22, v23, [a1[7] dataProtectionClass]);

LABEL_29:
}

void sub_10038726C(uint64_t a1, void *a2)
{
  id v3 = *(void **)(a1 + 32);
  id v4 = a2;
  id v9 = [v3 identifier];
  id v5 = [*(id *)(a1 + 32) alternateCallbackID];
  id v6 = [*(id *)(a1 + 32) mainAccountUUID];
  id v7 = [*(id *)(a1 + 40) idsResponseCode];
  id v8 = [*(id *)(a1 + 40) responseError];
  objc_msgSend(v4, "messageIdentifier:alternateCallbackID:forAccount:updatedWithResponseCode:error:lastCall:context:", v9, v5, v6, v7, v8, objc_msgSend(*(id *)(a1 + 40), "lastCall"), *(void *)(a1 + 48));
}

void sub_100387350(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    id v2 = [objc_alloc((Class)IDSDeliveryContext) initWithResponseCode:10 error:0 lastCall:1];
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

void sub_1003873D8(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    id v2 = [objc_alloc((Class)IDSDeliveryContext) initWithResponseCode:10 error:0 lastCall:1];
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

void sub_1003881A4(_Unwind_Exception *exc_buf, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(exc_buf);
    objc_end_catch();
    JUMPOUT(0x10038772CLL);
  }
  _Unwind_Resume(exc_buf);
}

void sub_100388224(id *a1, void *a2)
{
  id v3 = a2;
  if (![v3 lastCall]) {
    goto LABEL_29;
  }
  id v4 = [a1[4] servicePushTopic];
  id v5 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
  id v6 = [a1[4] subService];
  id v7 = [v6 length];
  id v8 = a1[4];
  if (v7) {
    [v8 subService];
  }
  else {
  id v9 = [v8 serviceIdentifier];
  }

  if (v9) {
    CFDictionarySetValue(v5, IDSMessageContextServiceIdentifierKey, v9);
  }
  uint64_t v10 = [a1[5] localDestinationDeviceUUID];
  if (v10) {
    CFDictionarySetValue(v5, IDSMessageContextOriginalDestinationDeviceKey, v10);
  }

  if (v4)
  {
    int v11 = [v3 responseError];
    if ([v11 code] == (id)24)
    {
      unsigned int v12 = [a1[4] silentlyFailMessagesOnSwitch];

      if (v12)
      {
        id v13 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          id v31 = v9;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Silently failing %@ messages due to watch switch", buf, 0xCu);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
        {
          __int16 v24 = v9;
          _IDSLogV();
        }
        goto LABEL_19;
      }
    }
    else
    {
    }
    uint64_t v14 = +[IDSDaemon sharedInstance];
    v26[0] = _NSConcreteStackBlock;
    v26[1] = 3221225472;
    v26[2] = sub_100388690;
    v26[3] = &unk_100980138;
    id v27 = a1[5];
    id v28 = v3;
    uint64_t v29 = v5;
    [v14 enqueueBroadcast:v26 forTopic:v4 entitlement:kIDSMessagingEntitlement command:0 capabilities:kIDSListenerCapConsumesLaunchOnDemandOutgoingMessageUpdates messageContext:0];
  }
LABEL_19:
  uint64_t v15 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    id v16 = [a1[6] guid];
    unsigned int v17 = [v3 lastCall];
    CFStringRef v18 = @"NO";
    if (v17) {
      CFStringRef v18 = @"YES";
    }
    *(_DWORD *)long long buf = 138412546;
    id v31 = v16;
    __int16 v32 = 2112;
    CFStringRef v33 = v18;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Deleting sent outgoing non-urgent local message with guid %@? %@", buf, 0x16u);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v19 = [a1[6] guid];
    unsigned int v20 = [v3 lastCall];
    CFStringRef v21 = @"NO";
    if (v20) {
      CFStringRef v21 = @"YES";
    }
    __int16 v24 = v19;
    CFStringRef v25 = v21;
    _IDSLogV();
  }
  id v22 = objc_msgSend(a1[6], "guid", v24, v25);
  id v23 = [a1[6] alternateGUID];
  +[IDSDMessageStore deleteOutgoingMessageWithGUID:alternateGUID:dataProtectionClass:](IDSDMessageStore, "deleteOutgoingMessageWithGUID:alternateGUID:dataProtectionClass:", v22, v23, [a1[7] dataProtectionClass]);

LABEL_29:
}

void sub_100388690(uint64_t a1, void *a2)
{
  id v3 = *(void **)(a1 + 32);
  id v4 = a2;
  id v9 = [v3 identifier];
  id v5 = [*(id *)(a1 + 32) alternateCallbackID];
  id v6 = [*(id *)(a1 + 32) mainAccountUUID];
  id v7 = [*(id *)(a1 + 40) idsResponseCode];
  id v8 = [*(id *)(a1 + 40) responseError];
  objc_msgSend(v4, "messageIdentifier:alternateCallbackID:forAccount:updatedWithResponseCode:error:lastCall:context:", v9, v5, v6, v7, v8, objc_msgSend(*(id *)(a1 + 40), "lastCall"), *(void *)(a1 + 48));
}

void sub_100388774(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    id v2 = [objc_alloc((Class)IDSDeliveryContext) initWithResponseCode:10 error:0 lastCall:1];
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

void sub_1003887FC(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    id v2 = [objc_alloc((Class)IDSDeliveryContext) initWithResponseCode:10 error:0 lastCall:1];
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

void sub_100388944(uint64_t a1)
{
  long long v7 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v8;
    do
    {
      id v6 = 0;
      do
      {
        if (*(void *)v8 != v5) {
          objc_enumerationMutation(v2);
        }
        objc_msgSend(*(id *)(a1 + 40), "_failSavedMessageCleanly:withResponseCode:", *(void *)(*((void *)&v7 + 1) + 8 * (void)v6), *(void *)(a1 + 48), (void)v7);
        id v6 = (char *)v6 + 1;
      }
      while (v4 != v6);
      id v4 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
    }
    while (v4);
  }
}

void sub_100388BFC(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    id v2 = [*(id *)(a1 + 40) serviceController];
    id v3 = [v2 serviceWithPushTopic:*(void *)(a1 + 32)];
    unsigned int v4 = [v3 shouldSilentlyFailMessagesOnSwitch];

    if (*(void *)(a1 + 64) == 24 && v4)
    {
      uint64_t v5 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        id v6 = *(void **)(a1 + 32);
        *(_DWORD *)long long buf = 138412290;
        CFStringRef v33 = v6;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Silently failing %@ messages due to watch switch", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLog())
        {
          __int16 v26 = *(void **)(a1 + 32);
          _IDSLogV();
        }
      }
    }
    else
    {
      long long v8 = [*(id *)(a1 + 48) command];
      id v9 = [v8 integerValue];

      if (v9 == (id)229)
      {
        long long v10 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          int v11 = [*(id *)(a1 + 48) guid];
          *(_DWORD *)long long buf = 138412290;
          CFStringRef v33 = v11;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Silently failing message with guid %@ due to it being a proxy ", buf, 0xCu);
        }
        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
        {
          __int16 v26 = [*(id *)(a1 + 48) guid];
          _IDSLogV();
        }
      }
      else
      {
        id v12 = objc_alloc_init((Class)IMMessageContext);
        id v13 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
        uint64_t v14 = v13;
        uint64_t v15 = *(const void **)(a1 + 32);
        if (v15) {
          CFDictionarySetValue(v13, IDSMessageContextServiceIdentifierKey, v15);
        }
        id v16 = [*(id *)(a1 + 48) localDestinationDeviceUUID];
        if (v16) {
          CFDictionarySetValue(v14, IDSMessageContextOriginalDestinationDeviceKey, v16);
        }

        v28[0] = _NSConcreteStackBlock;
        v28[1] = 3221225472;
        v28[2] = sub_100389054;
        v28[3] = &unk_10098A798;
        unsigned int v17 = *(void **)(a1 + 40);
        id v18 = *(id *)(a1 + 48);
        uint64_t v20 = *(void *)(a1 + 56);
        uint64_t v19 = *(void *)(a1 + 64);
        uint64_t v30 = v14;
        uint64_t v31 = v19;
        id v29 = v18;
        uint64_t v21 = kIDSMessagingEntitlement;
        uint64_t v22 = kIDSListenerCapConsumesLaunchOnDemandOutgoingMessageUpdates;
        id v23 = v14;
        [v17 enqueueBroadcast:v28 forTopic:v20 entitlement:v21 command:0 capabilities:v22 messageContext:v12];
      }
    }
    __int16 v24 = objc_msgSend(*(id *)(a1 + 48), "guid", v26);
    CFStringRef v25 = [*(id *)(a1 + 48) alternateGUID];
    +[IDSDMessageStore deleteOutgoingMessageWithGUID:v24 alternateGUID:v25];
  }
  else
  {
    id v27 = [*(id *)(a1 + 48) guid];
    long long v7 = [*(id *)(a1 + 48) alternateGUID];
    +[IDSDMessageStore deleteOutgoingMessageWithGUID:v27 alternateGUID:v7];
  }
}

void sub_100389054(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v4 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = [*(id *)(a1 + 32) guid];
    *(_DWORD *)long long buf = 138412290;
    id v12 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Broadcasting failure of outgoing message %@ that never got processed through the database", buf, 0xCu);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
  {
    long long v10 = [*(id *)(a1 + 32) guid];
    _IDSLogTransport();
  }
  id v6 = +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", IDSSendErrorDomain, *(void *)(a1 + 48), 0, v10);
  if (v3)
  {
    long long v7 = [*(id *)(a1 + 32) guid];
    long long v8 = [*(id *)(a1 + 32) alternateGUID];
    id v9 = [*(id *)(a1 + 32) mainAccountGuid];
    objc_msgSend(v3, "messageIdentifier:alternateCallbackID:forAccount:updatedWithResponseCode:error:lastCall:context:", v7, v8, v9, objc_msgSend(v6, "code"), v6, 1, *(void *)(a1 + 40));
  }
}

void sub_100389564(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) _maxOutgoingDatabasesSizeInMB];
  v7[0] = 0;
  v7[1] = v7;
  v7[2] = 0x3032000000;
  v7[3] = sub_1003896D0;
  void v7[4] = sub_1003896E0;
  id v8 = 0;
  id v3 = *(void **)(a1 + 40);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  unsigned char v6[2] = sub_1003896E8;
  v6[3] = &unk_10098A7C0;
  void v6[4] = v7;
  [v3 enumerateObjectsUsingBlock:v6];
  unsigned int v4 = +[IDSDaemonPriorityQueueController sharedInstance];
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_1003897B0;
  v5[3] = &unk_10098A7E8;
  void v5[4] = *(void *)(a1 + 32);
  v5[5] = v7;
  v5[6] = v2;
  [v4 performBlockSyncPriority:v5];

  _Block_object_dispose(v7, 8);
}

void sub_1003896B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1003896D0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1003896E0(uint64_t a1)
{
}

void sub_1003896E8(uint64_t a1, void *a2)
{
  id v9 = a2;
  id v3 = +[IDSDAccountController sharedInstance];
  unsigned int v4 = [v3 accountWithUniqueID:v9];

  if (([v4 isUsableForSending] & 1) == 0)
  {
    uint64_t v5 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
    if (!v5)
    {
      id v6 = objc_alloc_init((Class)NSMutableArray);
      uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
      id v8 = *(void **)(v7 + 40);
      *(void *)(v7 + 40) = v6;

      uint64_t v5 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
    }
    [v5 addObject:v9];
  }
}

void sub_1003897B0(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
  id v3 = +[IDSPairingManager sharedInstance];
  unsigned int v4 = [v3 pairedDeviceUniqueID];
  uint64_t v5 = +[IDSDMessageStore allUnsentOutgoingMessagesForAccounts:v2 localDestinationDeviceID:v4 hardLimit:2500];

  [*(id *)(a1 + 32) _failSavedMessagesCleanly:v5 withResponseCode:9];
  if (+[IDSDMessageStore databaseSizeBiggerThanThreshold:*(void *)(a1 + 48)])
  {
    id v6 = +[IDSDMessageStore largestPayloadSizeAccountUUID];
    uint64_t v7 = +[IDSDAccountController sharedInstance];
    id v8 = [v7 threadSafeServiceWithAccountUniqueID:v6];
    unsigned int v9 = [v8 adHocServiceType];

    if (v9 == 2)
    {
      long long v10 = +[IDSPairingManager sharedInstance];
      int v11 = [v10 pairedDeviceUniqueID];
    }
    else
    {
      int v11 = 0;
    }
    id v12 = +[IDSDMessageStore allOutgoingMessagesOnAccountGUID:v6 localDestinationDeviceID:v11];
    id v13 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = *(void *)(a1 + 48);
      *(_DWORD *)long long buf = 67109378;
      int v19 = v14;
      __int16 v20 = 2112;
      uint64_t v21 = v6;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "IDS outgoing DB past threshold size %d MB, largest payload size account UUID: %@", buf, 0x12u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
    {
      uint64_t v16 = *(void *)(a1 + 48);
      unsigned int v17 = v6;
      _IDSLogTransport();
    }
    objc_msgSend(*(id *)(a1 + 32), "_failSavedMessagesCleanly:withResponseCode:", v12, 19, v16, v17);
  }
  uint64_t v15 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Ending cleanup of outgoing message database", buf, 2u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport()) {
    _IDSLogTransport();
  }
}

void sub_100389B34(uint64_t a1)
{
  id v1 = [*(id *)(a1 + 32) _maxMessagesForRunawayClientConsideration];
  uint64_t v2 = +[IDSDaemonPriorityQueueController sharedInstance];
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100389BCC;
  v3[3] = &unk_10097EA18;
  void v3[4] = v1;
  [v2 performBlockSyncPriority:v3];
}

void sub_100389BCC(uint64_t a1)
{
  id v1 = +[IDSDMessageStore largestEnquedMessagesAccountUUIDOverThreshold:*(void *)(a1 + 32)];
  if ([v1 length])
  {
    uint64_t v2 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v3 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Runaway Client Detected, Purging messages for given client", v3, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    +[IDSDMessageStore deleteAllMessagesWithAccountGUID:v1];
  }
}

void sub_10038A254(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x10038A1D4);
  }
  _Unwind_Resume(a1);
}

void sub_10038A53C(id a1, OS_xpc_object *a2)
{
  uint64_t v2 = a2;
  xpc_activity_state_t state = xpc_activity_get_state(v2);
  if (state == 2)
  {
    unsigned int v9 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v10 = @"YES";
      if (!v2) {
        CFStringRef v10 = @"NO";
      }
      *(_DWORD *)long long buf = 138412290;
      CFStringRef v14 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Got called to checkpoint vacuum DB run state with non null activity %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      CFStringRef v11 = @"YES";
      if (!v2) {
        CFStringRef v11 = @"NO";
      }
      CFStringRef v12 = v11;
      _IDSLogV();
    }
    +[IDSDMessageStore checkpointAndVacuumDBWithDataProtectionClass:](IDSDMessageStore, "checkpointAndVacuumDBWithDataProtectionClass:", 0, v12);
    +[IDSDMessageStore checkpointAndVacuumDBWithDataProtectionClass:2];
  }
  else if (!state)
  {
    unsigned int v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v5 = @"YES";
      if (!v2) {
        CFStringRef v5 = @"NO";
      }
      *(_DWORD *)long long buf = 138412290;
      CFStringRef v14 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Told to Check In for Checkpointing and Vacuum with activity %@ ", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_int64(v6, XPC_ACTIVITY_GRACE_PERIOD, 0);
    xpc_dictionary_set_int64(v6, XPC_ACTIVITY_DELAY, 86400);
    xpc_dictionary_set_BOOL(v6, XPC_ACTIVITY_REQUIRE_SCREEN_SLEEP, 1);
    xpc_dictionary_set_BOOL(v6, XPC_ACTIVITY_ALLOW_BATTERY, 0);
    xpc_dictionary_set_string(v6, XPC_ACTIVITY_PRIORITY, XPC_ACTIVITY_PRIORITY_MAINTENANCE);
    xpc_dictionary_set_BOOL(v6, XPC_ACTIVITY_REQUIRES_CLASS_C, 1);
    xpc_object_t v7 = xpc_activity_copy_criteria(v2);
    id v8 = v7;
    if (!v7 || !xpc_equal(v7, v6)) {
      xpc_activity_set_criteria(v2, v6);
    }
  }
}

void sub_10038ACBC(uint64_t a1, void *a2)
{
  id v9 = a2;
  id v3 = *(void **)(a1 + 32);
  unsigned int v4 = [*(id *)(a1 + 40) service];
  CFStringRef v5 = [v4 identifier];
  LODWORD(v3) = [v3 client:v9 isEntitledToAccessService:v5 forEntitlement:kIDSMessagingEntitlement shouldWarn:1];

  if (v3)
  {
    uint64_t v6 = [v9 ID];
    uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8);
    id v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }
}

void sub_10038AD74(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    id v5 = [v3 idsResponseCode];
    id v6 = [v3 responseError];
    unsigned int v7 = [v3 lastCall];
    CFStringRef v8 = @"NO";
    uint64_t v9 = *(void *)(a1 + 32);
    *(_DWORD *)long long buf = 134218754;
    if (v7) {
      CFStringRef v8 = @"YES";
    }
    id v12 = v5;
    __int16 v13 = 2112;
    id v14 = v6;
    __int16 v15 = 2112;
    CFStringRef v16 = v8;
    __int16 v17 = 2112;
    uint64_t v18 = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "sendServerMessage updated with responseCode %ld error %@  lastCall %@ - messageContext %@", buf, 0x2Au);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    [v3 idsResponseCode];
    CFStringRef v10 = [v3 responseError];
    [v3 lastCall];
    _IDSLogV();
  }
}

void sub_10038B6B0(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v4 = [v3 entitlements];
  id v5 = [v4 dictionaryRepresentation];
  **(void **)(a1 + 32) = [v5 copy];

  id v6 = [v3 ID];

  **(void **)(a1 + 40) = [v6 copy];
}

void sub_10038C148(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) localObject];
  id v3 = *(void **)(a1 + 40);
  if (v3)
  {
    id v4 = [v3 keyType];
    id v5 = [*(id *)(a1 + 40) keyDiversifier];
  }
  else
  {
    id v5 = 0;
    id v4 = 0;
  }
  id v6 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v7 = *(void **)(a1 + 80);
    CFStringRef v8 = *(void **)(a1 + 56);
    uint64_t v9 = *(void *)(a1 + 64);
    uint64_t v11 = *(void *)(a1 + 40);
    uint64_t v10 = *(void *)(a1 + 48);
    *(_DWORD *)long long buf = 138413314;
    uint64_t v45 = v10;
    __int16 v46 = 2112;
    id v47 = v8;
    __int16 v48 = 2048;
    id v49 = v7;
    __int16 v50 = 2112;
    uint64_t v51 = v9;
    __int16 v52 = 2112;
    uint64_t v53 = v11;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Daemon received signData request {requestID: %@, data: %@, algo: %ld, service: %@, options: %@}", buf, 0x34u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v41 = *(void *)(a1 + 64);
    uint64_t v42 = *(void *)(a1 + 40);
    uint64_t v39 = *(void *)(a1 + 80);
    long long v36 = *(_OWORD *)(a1 + 48);
    _IDSLogV();
  }
  if (*(void *)(a1 + 56)
    && *(void *)(a1 + 64)
    && *(void *)(a1 + 48)
    && IDSIsValidSigningAlgorithm()
    && (IDSIsValidSigningKeyType() & 1) != 0)
  {
    if ([*(id *)(a1 + 72) validateListenerForLocalObject:v2 andCheckEntitlement:kIDSMessagingEntitlement forAccessToServiceWithIdentifier:*(void *)(a1 + 64)])
    {
      id v12 = [*(id *)(a1 + 72) _signatureTypeForSigningAlgorithm:*(void *)(a1 + 80)];
      if (v12 != (id)-1000 || v4)
      {
        id v28 = +[IDSEncryptionController sharedInstance];
        uint64_t v29 = *(void *)(a1 + 56);
        uint64_t v30 = *(void *)(a1 + 64);
        id v43 = 0;
        int v19 = [v28 publicKeySignData:v29 withSignatureType:v12 keyType:v4 keyDiversifier:v5 service:v30 priority:300 error:&v43];
        id v16 = v43;

        uint64_t v31 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v32 = *(void *)(a1 + 48);
          *(_DWORD *)long long buf = 138412802;
          uint64_t v45 = v32;
          __int16 v46 = 2112;
          id v47 = v19;
          __int16 v48 = 2112;
          id v49 = v16;
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Finished signing request... broadcasting { request: %@, signedData: %@, error: %@ }", buf, 0x20u);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
        {
          id v38 = v19;
          id v40 = v16;
          uint64_t v37 = *(void *)(a1 + 48);
          _IDSLogV();
        }
        objc_msgSend(*(id *)(a1 + 32), "setReply:", 1, v37, v38, v40);
        CFStringRef v33 = +[IDSDaemon sharedInstance];
        id v34 = [*(id *)(a1 + 32) localObject];
        id v35 = [v33 broadcasterForLocalObject:v34 messageContext:*(void *)(a1 + 32)];

        [v35 finishedSigningForRequest:*(void *)(a1 + 48) signedData:v19 error:v16];
      }
      else
      {
        __int16 v13 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v14 = *(void *)(a1 + 48);
          __int16 v15 = *(void **)(a1 + 80);
          *(_DWORD *)long long buf = 138412802;
          uint64_t v45 = v14;
          __int16 v46 = 2048;
          id v47 = v15;
          __int16 v48 = 2048;
          id v49 = 0;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Daemon dropping request %@ because it has a mismatched signing algorithm %ld and key type %ld", buf, 0x20u);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
        {
          *((void *)&v36 + 1) = *(void *)(a1 + 80);
          uint64_t v39 = 0;
          *(void *)&long long v36 = *(void *)(a1 + 48);
          _IDSLogV();
        }
        +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", IDSSigningErrorDomain, 1, 0, v36, v39, v41, v42);
        id v16 = (id)objc_claimAutoreleasedReturnValue();
        [*(id *)(a1 + 32) setReply:1];
        __int16 v17 = +[IDSDaemon sharedInstance];
        uint64_t v18 = [*(id *)(a1 + 32) localObject];
        int v19 = [v17 broadcasterForLocalObject:v18 messageContext:*(void *)(a1 + 32)];

        [v19 finishedSigningForRequest:*(void *)(a1 + 48) signedData:0 error:v16];
      }
    }
    else
    {
      __int16 v24 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v25 = *(void *)(a1 + 48);
        *(_DWORD *)long long buf = 138412290;
        uint64_t v45 = v25;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Daemon dropping request %@ because unentitled", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        *(void *)&long long v36 = *(void *)(a1 + 48);
        _IDSLogV();
      }
      +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", IDSSigningErrorDomain, 4, 0, v36, v39, v41, v42);
      id v16 = (id)objc_claimAutoreleasedReturnValue();
      [*(id *)(a1 + 32) setReply:1];
      __int16 v26 = +[IDSDaemon sharedInstance];
      id v27 = [*(id *)(a1 + 32) localObject];
      int v19 = [v26 broadcasterForLocalObject:v27 messageContext:*(void *)(a1 + 32)];

      [v19 finishedSigningForRequest:*(void *)(a1 + 48) signedData:0 error:v16];
    }
    goto LABEL_30;
  }
  __int16 v20 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v21 = *(void *)(a1 + 48);
    *(_DWORD *)long long buf = 138412290;
    uint64_t v45 = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Daemon dropping request %@ because it is missing required parameter", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  if (*(void *)(a1 + 48))
  {
    id v16 = +[NSError errorWithDomain:IDSSigningErrorDomain code:1 userInfo:0];
    [*(id *)(a1 + 32) setReply:1];
    uint64_t v22 = +[IDSDaemon sharedInstance];
    id v23 = [*(id *)(a1 + 32) localObject];
    int v19 = [v22 broadcasterForLocalObject:v23 messageContext:*(void *)(a1 + 32)];

    [v19 finishedSigningForRequest:*(void *)(a1 + 48) signedData:0 error:v16];
LABEL_30:
  }
}

void sub_10038CA80(uint64_t a1)
{
  id v78 = [*(id *)(a1 + 32) localObject];
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    unsigned int v76 = [v2 keyType];
    id v77 = [*(id *)(a1 + 40) keyDiversifier];
  }
  else
  {
    id v77 = 0;
    unsigned int v76 = 0;
  }
  id v3 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *(void *)(a1 + 56);
    uint64_t v5 = *(void *)(a1 + 64);
    uint64_t v6 = *(void *)(a1 + 96);
    uint64_t v7 = *(void *)(a1 + 72);
    uint64_t v8 = *(void *)(a1 + 80);
    uint64_t v10 = *(void *)(a1 + 40);
    uint64_t v9 = *(void *)(a1 + 48);
    *(_DWORD *)long long buf = 138413826;
    uint64_t v94 = v9;
    __int16 v95 = 2112;
    uint64_t v96 = v4;
    __int16 v97 = 2112;
    uint64_t v98 = v5;
    __int16 v99 = 2048;
    uint64_t v100 = v6;
    __int16 v101 = 2112;
    uint64_t v102 = v7;
    __int16 v103 = 2112;
    uint64_t v104 = v8;
    __int16 v105 = 2112;
    uint64_t v106 = v10;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Daemon received verifySignedData request {requestID: %@, signedData: %@, data: %@, algo: %ld, service: %@, uri: %@, options: %@}", buf, 0x48u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v65 = *(void *)(a1 + 80);
    uint64_t v66 = *(void *)(a1 + 40);
    uint64_t v63 = *(void *)(a1 + 96);
    uint64_t v64 = *(void *)(a1 + 72);
    uint64_t v61 = *(void *)(a1 + 64);
    long long v59 = *(_OWORD *)(a1 + 48);
    _IDSLogV();
  }
  if (*(void *)(a1 + 56)
    && *(void *)(a1 + 64)
    && *(void *)(a1 + 72)
    && *(void *)(a1 + 80)
    && *(void *)(a1 + 48)
    && IDSIsValidSigningAlgorithm()
    && (IDSIsValidSigningKeyType() & 1) != 0)
  {
    if ([*(id *)(a1 + 88) validateListenerForLocalObject:v78 andCheckEntitlement:kIDSMessagingEntitlement forAccessToServiceWithIdentifier:*(void *)(a1 + 72)])
    {
      if ([*(id *)(a1 + 80) isTokenURI])
      {
        id v69 = [*(id *)(a1 + 88) _signatureTypeForSigningAlgorithm:*(void *)(a1 + 96)];
        if (v69 != (id)-1000 || v76)
        {
          id v28 = objc_msgSend(*(id *)(a1 + 80), "prefixedURI", v59, v61, v63, v64, v65, v66);
          id v90 = 0;
          __int16 v17 = [v28 _stripPotentialTokenURIWithToken:&v90];
          id v14 = v90;

          id v68 = [objc_alloc((Class)IDSURI) initWithPrefixedURI:v17];
          if (v14 && v17)
          {
            uint64_t v29 = +[IDSDAccountController sharedInstance];
            uint64_t v30 = +[IDSDServiceController sharedInstance];
            uint64_t v31 = [v30 serviceWithIdentifier:*(void *)(a1 + 72)];
            uint64_t v32 = [v29 registeredAccountsOnService:v31];

            long long v88 = 0u;
            long long v89 = 0u;
            long long v86 = 0u;
            long long v87 = 0u;
            id obj = v32;
            id v72 = [obj countByEnumeratingWithState:&v86 objects:v92 count:16];
            if (v72)
            {
              CFStringRef v33 = 0;
              uint64_t v75 = 0;
              uint64_t v71 = *(void *)v87;
              uint64_t v34 = kIDSServiceDefaultsSentinelAlias;
              while (2)
              {
                uint64_t v35 = 0;
                do
                {
                  if (*(void *)v87 != v71)
                  {
                    uint64_t v36 = v35;
                    objc_enumerationMutation(obj);
                    uint64_t v35 = v36;
                  }
                  uint64_t v73 = v35;
                  uint64_t v37 = *(void **)(*((void *)&v86 + 1) + 8 * v35);
                  id v38 = [v37 primaryRegistration];
                  uint64_t v74 = [v38 registrationCert];

                  long long v84 = 0u;
                  long long v85 = 0u;
                  long long v82 = 0u;
                  long long v83 = 0u;
                  uint64_t v39 = [v37 prefixedURIStringsFromRegistration];
                  id v40 = [v39 countByEnumeratingWithState:&v82 objects:v91 count:16];
                  if (v40)
                  {
                    uint64_t v41 = *(void *)v83;
                    while (2)
                    {
                      for (uint64_t i = 0; i != v40; uint64_t i = (char *)i + 1)
                      {
                        if (*(void *)v83 != v41) {
                          objc_enumerationMutation(v39);
                        }
                        id v43 = *(void **)(*((void *)&v82 + 1) + 8 * i);
                        if (([v43 isEqualToString:v34] & 1) == 0)
                        {
                          id v44 = [objc_alloc((Class)IDSURI) initWithPrefixedURI:v43];

                          uint64_t v75 = v44;
                          goto LABEL_64;
                        }
                      }
                      id v40 = [v39 countByEnumeratingWithState:&v82 objects:v91 count:16];
                      if (v40) {
                        continue;
                      }
                      break;
                    }
                  }
LABEL_64:

                  CFStringRef v33 = (void *)v74;
                  if (v74 && v75)
                  {

                    id v49 = +[IDSEncryptionController sharedInstance];
                    uint64_t v50 = *(void *)(a1 + 56);
                    uint64_t v51 = *(void *)(a1 + 64);
                    uint64_t v52 = *(void *)(a1 + 72);
                    v79[0] = _NSConcreteStackBlock;
                    v79[1] = 3221225472;
                    v79[2] = sub_10038D7EC;
                    v79[3] = &unk_10097E758;
                    id v80 = *(id *)(a1 + 48);
                    id v81 = *(id *)(a1 + 32);
                    LOBYTE(v67) = 0;
                    LODWORD(v62) = v76;
                    [v49 publicKeyVerifySignedData:v50 matchesData:v51 forSignatureType:v69 identity:v74 toURI:v68 pushToken:v14 service:v52 localURI:v75 withKeyType:v62 keyDiversifier:v77 priority:300 completion:v79 avoidMainQueue:v67];

                    uint64_t v53 = v80;
                    goto LABEL_83;
                  }
                  uint64_t v35 = v73 + 1;
                }
                while ((id)(v73 + 1) != v72);
                id v72 = [obj countByEnumeratingWithState:&v86 objects:v92 count:16];
                if (v72) {
                  continue;
                }
                break;
              }
            }
            else
            {
              uint64_t v75 = 0;
              CFStringRef v33 = 0;
            }

            id v54 = OSLogHandleForIDSCategory();
            if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v55 = *(void *)(a1 + 48);
              *(_DWORD *)long long buf = 138412290;
              uint64_t v94 = v55;
              _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "Daemon dropping request %@ because we are not registered", buf, 0xCu);
            }

            if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
            {
              uint64_t v60 = *(void *)(a1 + 48);
              _IDSLogV();
            }
            uint64_t v53 = +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", IDSSigningErrorDomain, 14, 0, v60);
            [*(id *)(a1 + 32) setReply:1];
            id v56 = +[IDSDaemon sharedInstance];
            id v57 = [*(id *)(a1 + 32) localObject];
            id v58 = [v56 broadcasterForLocalObject:v57 messageContext:*(void *)(a1 + 32)];

            [v58 finishedVerifyingSignedDataForRequest:*(void *)(a1 + 48) success:0 error:v53];
LABEL_83:
          }
          else
          {
            uint64_t v45 = OSLogHandleForIDSCategory();
            if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v46 = *(void *)(a1 + 48);
              *(_DWORD *)long long buf = 138412290;
              uint64_t v94 = v46;
              _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "Daemon dropping request %@ because tokenURI malformed", buf, 0xCu);
            }

            if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
            {
              uint64_t v60 = *(void *)(a1 + 48);
              _IDSLogV();
            }
            CFStringRef v33 = +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", IDSSigningErrorDomain, 2, 0, v60);
            [*(id *)(a1 + 32) setReply:1];
            id v47 = +[IDSDaemon sharedInstance];
            __int16 v48 = [*(id *)(a1 + 32) localObject];
            uint64_t v75 = [v47 broadcasterForLocalObject:v48 messageContext:*(void *)(a1 + 32)];

            [v75 finishedVerifyingSignedDataForRequest:*(void *)(a1 + 48) success:0 error:v33];
          }
        }
        else
        {
          uint64_t v11 = OSLogHandleForIDSCategory();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v12 = *(void *)(a1 + 48);
            uint64_t v13 = *(void *)(a1 + 96);
            *(_DWORD *)long long buf = 138412802;
            uint64_t v94 = v12;
            __int16 v95 = 2048;
            uint64_t v96 = v13;
            __int16 v97 = 2048;
            uint64_t v98 = 0;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Daemon dropping request %@ because it has a mismatched verification algorithm %ld and key type %ld", buf, 0x20u);
          }

          if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
          {
            *((void *)&v59 + 1) = *(void *)(a1 + 96);
            uint64_t v61 = 0;
            *(void *)&long long v59 = *(void *)(a1 + 48);
            _IDSLogV();
          }
          +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", IDSSigningErrorDomain, 1, 0, v59, v61, v63, v64, v65, v66);
          id v14 = (id)objc_claimAutoreleasedReturnValue();
          [*(id *)(a1 + 32) setReply:1];
          __int16 v15 = +[IDSDaemon sharedInstance];
          id v16 = [*(id *)(a1 + 32) localObject];
          __int16 v17 = [v15 broadcasterForLocalObject:v16 messageContext:*(void *)(a1 + 32)];

          [v17 finishedVerifyingSignedDataForRequest:*(void *)(a1 + 48) success:0 error:v14];
        }
      }
      else
      {
        __int16 v24 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v25 = *(void *)(a1 + 48);
          *(_DWORD *)long long buf = 138412290;
          uint64_t v94 = v25;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Daemon dropping request %@ because it is not a token URI", buf, 0xCu);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
        {
          *(void *)&long long v59 = *(void *)(a1 + 48);
          _IDSLogV();
        }
        +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", IDSSigningErrorDomain, 2, 0, v59, v61, v63, v64, v65, v66);
        id v14 = (id)objc_claimAutoreleasedReturnValue();
        [*(id *)(a1 + 32) setReply:1];
        __int16 v26 = +[IDSDaemon sharedInstance];
        id v27 = [*(id *)(a1 + 32) localObject];
        __int16 v17 = [v26 broadcasterForLocalObject:v27 messageContext:*(void *)(a1 + 32)];

        [v17 finishedVerifyingSignedDataForRequest:*(void *)(a1 + 48) success:0 error:v14];
      }
    }
    else
    {
      __int16 v20 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v21 = *(void *)(a1 + 48);
        *(_DWORD *)long long buf = 138412290;
        uint64_t v94 = v21;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Daemon dropping request %@ because unentitled", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        *(void *)&long long v59 = *(void *)(a1 + 48);
        _IDSLogV();
      }
      +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", IDSSigningErrorDomain, 4, 0, v59, v61, v63, v64, v65, v66);
      id v14 = (id)objc_claimAutoreleasedReturnValue();
      [*(id *)(a1 + 32) setReply:1];
      uint64_t v22 = +[IDSDaemon sharedInstance];
      id v23 = [*(id *)(a1 + 32) localObject];
      __int16 v17 = [v22 broadcasterForLocalObject:v23 messageContext:*(void *)(a1 + 32)];

      [v17 finishedVerifyingSignedDataForRequest:*(void *)(a1 + 48) success:0 error:v14];
    }
    goto LABEL_33;
  }
  uint64_t v18 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v19 = *(void *)(a1 + 48);
    *(_DWORD *)long long buf = 138412290;
    uint64_t v94 = v19;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Daemon dropping request %@ because it is missing required parameter", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  if (*(void *)(a1 + 48))
  {
    id v14 = +[NSError errorWithDomain:IDSSigningErrorDomain code:1 userInfo:0];
    __int16 v17 = [*(id *)(a1 + 88) listenerRemoteObjectForLocalObject:v78];
    [v17 finishedVerifyingSignedDataForRequest:*(void *)(a1 + 48) success:0 error:v14];
LABEL_33:
  }
}

void sub_10038D7EC(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a1 + 32);
    CFStringRef v8 = @"NO";
    *(_DWORD *)long long buf = 138412802;
    if (a2) {
      CFStringRef v8 = @"YES";
    }
    uint64_t v17 = v7;
    __int16 v18 = 2112;
    CFStringRef v19 = v8;
    __int16 v20 = 2112;
    id v21 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Finished signing verification request... broadcasting { request: %@, verified: %@, error: %@ }", buf, 0x20u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    CFStringRef v9 = @"NO";
    if (a2) {
      CFStringRef v9 = @"YES";
    }
    CFStringRef v14 = v9;
    id v15 = v5;
    uint64_t v13 = *(void *)(a1 + 32);
    _IDSLogV();
  }
  objc_msgSend(*(id *)(a1 + 40), "setReply:", 1, v13, v14, v15);
  uint64_t v10 = +[IDSDaemon sharedInstance];
  uint64_t v11 = [*(id *)(a1 + 40) localObject];
  uint64_t v12 = [v10 broadcasterForLocalObject:v11 messageContext:*(void *)(a1 + 40)];

  [v12 finishedVerifyingSignedDataForRequest:*(void *)(a1 + 32) success:a2 error:v5];
}

void sub_10038DAB4(uint64_t a1)
{
  id v199 = 0;
  id v200 = 0;
  [*(id *)(a1 + 32) _fetchAccountEntitlements:&v200 listenerID:&v199 inContext:*(void *)(a1 + 40)];
  id v1 = v200;
  id v2 = v199;
  char v171 = v1;
  if (v1)
  {
    id v169 = v2;
    id v180 = [objc_alloc((Class)IDSSendParameters) initWithDictionary:*(void *)(a1 + 48)];
    id v3 = [v180 accountUUID];
    [v180 setMainAccountUUID:v3];

    uint64_t v4 = [v180 fromID];
    [v180 setOriginalfromID:v4];

    if ([*(id *)(a1 + 32) dropMessageIfDropPointIsDetectedWithSendParameters:v180])
    {
      id v5 = objc_alloc((Class)NSString);
      uint64_t v6 = [v180 messageUUID];
      int v170 = (__CFDictionary *)[v5 initWithData:v6 encoding:4];

      uint64_t v7 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v8 = [v180 messageType];
        CFStringRef v9 = [v180 accountUUID];
        uint64_t v10 = [v180 fromID];
        *(_DWORD *)long long buf = 138413058;
        v205 = v170;
        __int16 v206 = 2112;
        CFStringRef v207 = v8;
        __int16 v208 = 2112;
        double v209 = v9;
        __int16 v210 = 2112;
        CFStringRef v211 = v10;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Message has been dropped at point IDSMessageDropPointDaemon { messageID: %@, type: %@, accountID: %@, fromID: %@ }", buf, 0x2Au);
      }
      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        uint64_t v11 = [v180 messageType];
        uint64_t v12 = [v180 accountUUID];
        int v166 = [v180 fromID];
        _IDSLogV();
      }
LABEL_37:
      double v181 = 0;
LABEL_159:

      id v2 = v169;
      goto LABEL_160;
    }
    int v170 = [v180 groupData];
    if (v170)
    {
      uint64_t v13 = +[NSKeyedUnarchiver ids_secureUnarchiveObjectOfClass:objc_opt_class() withData:v170];
      [v180 setDestinations:v13];
    }
    CFStringRef v14 = [*(id *)(a1 + 32) accountController];
    id v15 = [v180 mainAccountUUID];
    double v181 = [v14 accountWithUniqueID:v15];

    id v16 = [v181 service];
    uint64_t v17 = [v16 pushTopic];
    LODWORD(v15) = [v17 hasPrefix:@"com.apple.private.alloy.continuity"];

    if (v15) {
      kdebug_trace();
    }
    if (!v181)
    {
      uint64_t v37 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        id v38 = [v180 mainAccountUUID];
        *(_DWORD *)long long buf = 138412290;
        v205 = v38;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "(Messaging1) No account found for ID: %@", buf, 0xCu);
      }
      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        uint64_t v155 = [v180 mainAccountUUID];
        _IDSLogV();
      }
      IMLogBacktrace();
      goto LABEL_37;
    }
    if ([v180 forceQuery] == (id)1)
    {
      __int16 v18 = *(void **)(a1 + 32);
      CFStringRef v19 = [*(id *)(a1 + 40) localObject];
      __int16 v20 = [v181 service];
      id v21 = [v20 identifier];
      LOBYTE(v18) = [v18 validateListenerForLocalObject:v19 andCheckEntitlement:kIDSForceQuerySendParameterEntitlement forAccessToServiceWithIdentifier:v21];

      if ((v18 & 1) == 0)
      {
        id v39 = objc_alloc((Class)NSString);
        id v40 = [v180 messageUUID];
        uint64_t v41 = (__CFDictionary *)[v39 initWithData:v40 encoding:4];

        uint64_t v42 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
        {
          id v43 = [v181 service];
          id v44 = [v43 identifier];
          *(_DWORD *)long long buf = 138412546;
          v205 = v41;
          __int16 v206 = 2112;
          CFStringRef v207 = v44;
          _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "Message using force query parameter but does not have appropriate entitlement! { messageID: %@, service: %@}", buf, 0x16u);
        }
        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
        {
          uint64_t v45 = [v181 service];
          v162 = [v45 identifier];
          _IDSLogV();
        }
        goto LABEL_159;
      }
    }
    uint64_t v22 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Gossip - Trying to fetch STH.", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    id v23 = [v180 destinations];
    if (v23)
    {
      __int16 v24 = [v181 service];
      uint64_t v25 = [v24 pushTopic];
      if (v25)
      {
        __int16 v26 = [v180 fromID];
        BOOL v27 = v26 == 0;

        if (!v27)
        {
          id v28 = +[IDSKTGossipManager sharedInstance];
          uint64_t v29 = [v180 destinations];
          uint64_t v30 = [v181 service];
          uint64_t v31 = [v30 pushTopic];
          uint64_t v32 = [v180 fromID];
          v168 = [v28 gossipSTHPayloadForDestinations:v29 forServiceIdentifier:v31 fromID:v32];

          if (v168)
          {
            uint64_t v202 = NGMEncryptedAttributeKTGossipData;
            v203 = v168;
            uint64_t v33 = +[NSDictionary dictionaryWithObjects:&v203 forKeys:&v202 count:1];
            uint64_t v34 = OSLogHandleForIDSCategory();
            if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 138412290;
              v205 = (__CFDictionary *)v33;
              _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Gossip - Encrypted Attributes: %@", buf, 0xCu);
            }

            if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
            {
              uint64_t v154 = v33;
              _IDSLogV();
            }
            uint64_t v35 = v180;
            uint64_t v36 = (void *)v33;
            goto LABEL_51;
          }
        }
      }
      else
      {
      }
    }
    uint64_t v46 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "Gossip - Retrieved nil STH. Will not gossip.", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    v168 = 0;
    uint64_t v36 = 0;
    uint64_t v35 = v180;
LABEL_51:
    BOOL v167 = v36;
    [v35 setEncryptionAttributes:v154];
    if ([v181 accountType] == 2) {
      goto LABEL_66;
    }
    id v47 = [v180 dataToEncrypt];
    if (v47)
    {
      BOOL v48 = 1;
    }
    else
    {
      id v49 = [v180 protobuf];
      BOOL v48 = v49 != 0;
    }
    if (([*(id *)(a1 + 32) _isUnderFirstDataProtectionLock] & v48) != 1)
    {
LABEL_66:
      long long v59 = *(void **)(a1 + 32);
      uint64_t v60 = [v180 destinations];
      LOBYTE(v59) = [v59 _canSendMessageWithAccount:v181 toDestination:v60];

      if (v59)
      {
        if ([v181 accountType] != 2)
        {
          long long v193 = 0u;
          long long v194 = 0u;
          long long v192 = 0u;
          long long v191 = 0u;
          uint64_t v61 = [v180 destinations];
          id obj = [v61 destinationURIs];

          id v179 = [obj countByEnumeratingWithState:&v191 objects:v201 count:16];
          if (v179)
          {
            uint64_t v176 = *(void *)v192;
            uint64_t v173 = IDSDevicePropertyIdentities;
            uint64_t v174 = IDSDevicePropertyPushToken;
            do
            {
              for (uint64_t i = 0; i != v179; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v192 != v176) {
                  objc_enumerationMutation(obj);
                }
                uint64_t v63 = *(void **)(*((void *)&v191 + 1) + 8 * i);
                if ([v63 hasPrefix:@"device:"])
                {
                  uint64_t v64 = OSLogHandleForIDSCategory();
                  if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)long long buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "Attempting to send to a local device using modern addressing, however we are not a local account, Swapping out destination for internet style addressing", buf, 2u);
                  }

                  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
                    _IDSLogV();
                  }
                  uint64_t v65 = [v63 _stripFZIDPrefix];
                  uint64_t v66 = [v181 service];
                  uint64_t v67 = objc_msgSend(v181, "dependentRegistrationMatchingUUID:includingTinker:", v65, objc_msgSend(v66, "wantsTinkerDevices"));

                  if (v67)
                  {
                    id v68 = [v67 _dataForKey:v174];
                    id v69 = [v67 _arrayForKey:v173];
                    int v70 = [v181 service];
                    uint64_t v71 = [v70 pushTopic];

                    id v72 = (void *)_IDSCopyIDForPushTokenAndIdentitiesWithService();
                    id v73 = objc_alloc((Class)NSMutableSet);
                    uint64_t v74 = [v180 destinations];
                    uint64_t v75 = [v74 destinationURIs];
                    id v76 = [v73 initWithSet:v75];

                    [v76 removeObject:v63];
                    if (v72)
                    {
                      [v76 addObject:v72];
                    }
                    else
                    {
                      id v77 = OSLogHandleForIDSCategory();
                      if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)long long buf = 138413058;
                        v205 = (__CFDictionary *)v63;
                        __int16 v206 = 2112;
                        CFStringRef v207 = v68;
                        __int16 v208 = 2112;
                        double v209 = v71;
                        __int16 v210 = 2112;
                        CFStringRef v211 = v69;
                        _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "Cloud destination could not be formed { destination: %@, token: %@, topic: %@, identities: %@ }", buf, 0x2Au);
                      }

                      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
                      {
                        v164 = v71;
                        unsigned __int8 v165 = v69;
                        id v156 = (__CFDictionary *)v63;
                        uint64_t v161 = v68;
                        _IDSLogV();
                      }
                    }
                    id v78 = +[NSSet setWithSet:](NSSet, "setWithSet:", v76, v156, v161, v164, v165);
                    id v79 = +[IDSDestination destinationWithStrings:v78];
                    [v180 setDestinations:v79];
                  }
                }
              }
              id v179 = [obj countByEnumeratingWithState:&v191 objects:v201 count:16];
            }
            while (v179);
          }
        }
        id v80 = [v180 command];
        unsigned int v81 = [v80 isEqual:&off_1009D1EA8];

        if (v81)
        {
          long long v82 = [*(id *)(a1 + 32) opportunisticDeliveryController];
          long long v83 = [v180 destinations];
          [v82 sendOpportunisticDataIfNeededToDestination:v83 completion:0];
        }
        id v54 = [v180 fromID];
        long long v84 = [*(id *)(a1 + 32) serviceController];
        long long v85 = [v181 service];
        long long v86 = [v85 pushTopic];
        long long v87 = [v84 serviceWithPushTopic:v86];
        unsigned int v88 = [v87 shouldAllowProxyDelivery];

        if ([v54 length]) {
          unsigned int v89 = v88;
        }
        else {
          unsigned int v89 = 0;
        }
        if (v89 == 1
          && ([v181 unprefixedURIStringsFromRegistration],
              id v90 = objc_claimAutoreleasedReturnValue(),
              [v54 _stripFZIDPrefix],
              CFStringRef v91 = objc_claimAutoreleasedReturnValue(),
              unsigned __int8 v92 = [v90 containsObject:v91],
              v91,
              v90,
              (v92 & 1) == 0))
        {
          v146 = [*(id *)(a1 + 32) accountController];
          v147 = [v181 service];
          double v178 = [v146 localAccountOnService:v147];

          unsigned int v148 = [(__CFDictionary *)v178 loginID];
          uint64_t v149 = [v148 _stripFZIDPrefix];
          unsigned int v150 = [v54 _stripFZIDPrefix];
          int v151 = _FTAreIDsEquivalent();

          if (v151)
          {
            uint64_t v152 = [(__CFDictionary *)v178 uniqueID];
            [v180 setAccountUUID:v152];

            int v153 = [(__CFDictionary *)v178 uniqueID];
            [v180 setMainAccountUUID:v153];
          }
        }
        else
        {
          double v178 = 0;
        }
        double v93 = [v54 _stripFZIDPrefix];
        int IsPhoneNumber = IMStringIsPhoneNumber();

        if (!IsPhoneNumber) {
          goto LABEL_118;
        }
        __int16 v95 = *(void **)(a1 + 32);
        uint64_t v96 = [v54 _stripFZIDPrefix];
        __int16 v97 = (void *)_IDSCopyIDForPhoneNumberWithOptions();
        uint64_t v98 = [v181 service];
        __int16 v99 = +[IDSDAccountController sharedInstance];
        uint64_t v100 = [v181 service];
        __int16 v101 = [v99 appleIDAccountOnService:v100];
        LODWORD(v95) = [v95 shouldDropMessageIfOutOfFamilyPhoneNumber:v97 forService:v98 withAppleIDAccount:v101];

        if (v95)
        {
          uint64_t v102 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
          __int16 v103 = [v180 subService];
          if (v103) {
            CFDictionarySetValue(v102, IDSMessageContextServiceIdentifierKey, v103);
          }

          uint64_t v104 = [v180 localDestinationDeviceUUID];
          if (v104) {
            CFDictionarySetValue(v102, IDSMessageContextOriginalDestinationDeviceKey, v104);
          }

          id v105 = objc_alloc_init((Class)IMMessageContext);
          uint64_t v106 = *(void **)(a1 + 32);
          v188[0] = _NSConcreteStackBlock;
          v188[1] = 3221225472;
          v188[2] = sub_10038FAC8;
          v188[3] = &unk_10098A878;
          id v189 = v180;
          uint64_t v190 = v102;
          int v177 = v102;
          CFStringRef v107 = [v181 service];
          unsigned int v108 = [v107 pushTopic];
          [v106 enqueueBroadcast:v188 forTopic:v108 entitlement:kIDSMessagingEntitlement command:0 capabilities:kIDSListenerCapConsumesLaunchOnDemandOutgoingMessageUpdates messageContext:v105];

          CFStringRef v109 = v189;
        }
        else
        {
LABEL_118:
          if (v178)
          {
            double v117 = v178;

            uint64_t v118 = OSLogHandleForIDSCategory();
            if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 138412290;
              v205 = v117;
              _os_log_impl((void *)&_mh_execute_header, v118, OS_LOG_TYPE_DEFAULT, "Switching to using local account since it has the alias corresponding to the fromID: %@", buf, 0xCu);
            }

            if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
            {
              id v156 = v117;
              _IDSLogV();
            }
          }
          else
          {
            double v117 = (__CFDictionary *)v181;
          }
          id v119 = [(__CFDictionary *)v117 newSendMessageContext];
          [v119 setListenerID:v169];
          [v119 setEntitlements:v171];
          uint64_t v120 = *(void **)(a1 + 32);
          __int16 v121 = [(__CFDictionary *)v117 service];
          LODWORD(v120) = [v120 _shouldIncludeDefaultDeviceAsDestinationForMessageWithParams:v180 service:v121];

          if (v120)
          {
            double v122 = *(void **)(a1 + 32);
            uint64_t v123 = [(__CFDictionary *)v117 service];
            id v124 = [v122 _shouldMessageBeProxied:v180 service:v123];
          }
          else
          {
            id v124 = 0;
          }
          [v119 setShouldIncludeDefaultDevice:v124];
          int v177 = [v180 subService];
          if ([(__CFDictionary *)v177 length])
          {
            [v119 setSubService:v177];
            __int16 v125 = [*(id *)(a1 + 32) serviceController];
            CFStringRef v126 = [v125 serviceWithPushTopic:v177];

            v127 = [*(id *)(a1 + 32) accountController];
            double v128 = [v127 localAccountOnService:v126];

            v129 = [v128 uniqueID];
            [v180 setAccountUUID:v129];
            [v180 setSubServiceAccountUUID:v129];
            double v130 = OSLogHandleForIDSCategory();
            if (os_log_type_enabled(v130, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 138412546;
              v205 = v177;
              __int16 v206 = 2112;
              CFStringRef v207 = v129;
              _os_log_impl((void *)&_mh_execute_header, v130, OS_LOG_TYPE_DEFAULT, "subServiceName %@ subServiceUUID %@", buf, 0x16u);
            }

            if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
            {
              uint64_t v157 = v177;
              uint64_t v161 = v129;
              _IDSLogV();
            }
            if (!v128)
            {
              v131 = OSLogHandleForIDSCategory();
              if (os_log_type_enabled(v131, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 138412290;
                v205 = v126;
                _os_log_impl((void *)&_mh_execute_header, v131, OS_LOG_TYPE_ERROR, "Couldn't find sub-account for service name %@", buf, 0xCu);
              }

              if (os_log_shim_legacy_logging_enabled())
              {
                _IDSWarnV();
                _IDSLogV();
                uint64_t v157 = v126;
                _IDSLogTransport();
              }
            }
          }
          v132 = [(__CFDictionary *)v117 service];
          CFStringRef v109 = [v132 identifier];

          double v182 = [(__CFDictionary *)v117 smallDescription];
          if ([v180 priority] == (id)300
            && ([(id)objc_opt_class() entitlementDictionary:v171 isEntitledToAccessService:v109 forEntitlement:kIDSHighPriorityMessagingEntitlement forAccount:v182 shouldWarn:0] & 1) == 0)
          {
            CFStringRef v133 = objc_opt_class();
            CFStringRef v134 = (__CFDictionary *)kIDSUrgentPriorityMessagingEntitlement;
            if (([v133 entitlementDictionary:v171 isEntitledToAccessService:v109 forEntitlement:kIDSUrgentPriorityMessagingEntitlement forAccount:v182 shouldWarn:0] & 1) == 0)
            {
              int v135 = OSLogHandleForIDSCategory();
              if (os_log_type_enabled(v135, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 138412546;
                v205 = v134;
                __int16 v206 = 2112;
                CFStringRef v207 = v109;
                _os_log_impl((void *)&_mh_execute_header, v135, OS_LOG_TYPE_ERROR, "**** IDSDaemon: Urgent priority messaging requires entitlement for %@, DOWNGRADING MESSAGE PRIORITY TO DEFAULT - violator %@ ****", buf, 0x16u);
              }

              if (os_log_shim_legacy_logging_enabled())
              {
                _IDSWarnV();
                _IDSLogV();
                uint64_t v158 = v134;
                v163 = v109;
                _IDSLogTransport();
              }
              objc_msgSend(v180, "setPriority:", 200, v158, v163);
            }
          }
          id v136 = [v180 priority];
          if (v136 != (id)100 && v136 != (id)200 && v136 != (id)300)
          {
            CFStringRef v137 = OSLogHandleForIDSCategory();
            if (os_log_type_enabled(v137, OS_LOG_TYPE_ERROR))
            {
              v138 = (__CFDictionary *)[v180 priority];
              *(_DWORD *)long long buf = 134218242;
              v205 = v138;
              __int16 v206 = 2112;
              CFStringRef v207 = v109;
              _os_log_impl((void *)&_mh_execute_header, v137, OS_LOG_TYPE_ERROR, "Client has specified a priority we do not recognize: %lu. Perpetrator: %@. Forcing default priority.", buf, 0x16u);
            }

            if (os_log_shim_legacy_logging_enabled())
            {
              id v159 = [v180 priority];
              _IDSWarnV();
              id v160 = objc_msgSend(v180, "priority", v159, v109);
              _IDSLogV();
              uint64_t v158 = (__CFDictionary *)objc_msgSend(v180, "priority", v160, v109);
              v163 = v109;
              _IDSLogTransport();
            }
            objc_msgSend(v180, "setPriority:", 200, v158, v163);
          }
          signed int v139 = [v180 priority];
          CFStringRef v140 = objc_opt_class();
          uint64_t v141 = *(void *)(a1 + 40);
          v142 = [v119 servicePushTopic];
          unsigned int v143 = [v140 progressBlockForSendParameters:v180 messageContext:v141 topic:v142 forObject:*(void *)(a1 + 32)];

          v144 = +[IDSDaemonPriorityQueueController sharedInstance];
          v183[0] = _NSConcreteStackBlock;
          v183[1] = 3221225472;
          v183[2] = sub_10038FBFC;
          v183[3] = &unk_100981B00;
          v183[4] = *(void *)(a1 + 32);
          id v184 = v180;
          id v185 = *(id *)(a1 + 40);
          id v105 = v119;
          id v186 = v105;
          id v145 = v143;
          id v187 = v145;
          [v144 performBlockWithPriority:v183 priority:v139];

          double v181 = v117;
        }

        goto LABEL_158;
      }
      __int16 v110 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "Result of can send message with account was no", buf, 2u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        _IDSLogV();
      }
      double v111 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
      int v112 = [v180 subService];
      if (v112) {
        CFDictionarySetValue(v111, IDSMessageContextServiceIdentifierKey, v112);
      }

      unsigned int v113 = [v180 localDestinationDeviceUUID];
      if (v113) {
        CFDictionarySetValue(v111, IDSMessageContextOriginalDestinationDeviceKey, v113);
      }

      id v54 = objc_alloc_init((Class)IMMessageContext);
      CFStringRef v114 = *(void **)(a1 + 32);
      id v56 = v195;
      v195[0] = _NSConcreteStackBlock;
      v195[1] = 3221225472;
      v195[2] = sub_10038F994;
      v195[3] = &unk_10098A878;
      v195[4] = v180;
      uint64_t v196 = v111;
      double v178 = v111;
      CFStringRef v115 = [v181 service];
      CFStringRef v116 = [v115 pushTopic];
      [v114 enqueueBroadcast:v195 forTopic:v116 entitlement:kIDSMessagingEntitlement command:0 capabilities:kIDSListenerCapConsumesLaunchOnDemandOutgoingMessageUpdates messageContext:v54];
    }
    else
    {
      uint64_t v50 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "Client is attempting to send a message under first data protection lock, failing message", buf, 2u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        _IDSLogV();
      }
      uint64_t v51 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
      uint64_t v52 = [v180 subService];
      if (v52) {
        CFDictionarySetValue(v51, IDSMessageContextServiceIdentifierKey, v52);
      }

      uint64_t v53 = [v180 localDestinationDeviceUUID];
      if (v53) {
        CFDictionarySetValue(v51, IDSMessageContextOriginalDestinationDeviceKey, v53);
      }

      id v54 = objc_alloc_init((Class)IMMessageContext);
      uint64_t v55 = *(void **)(a1 + 32);
      id v56 = v197;
      v197[0] = _NSConcreteStackBlock;
      v197[1] = 3221225472;
      v197[2] = sub_10038F860;
      v197[3] = &unk_10098A878;
      v197[4] = v180;
      uint64_t v198 = v51;
      double v178 = v51;
      id v57 = [v181 service];
      id v58 = [v57 pushTopic];
      [v55 enqueueBroadcast:v197 forTopic:v58 entitlement:kIDSMessagingEntitlement command:0 capabilities:kIDSListenerCapConsumesLaunchOnDemandOutgoingMessageUpdates messageContext:v54];
    }
    id v105 = (id)v56[4];
LABEL_158:

    goto LABEL_159;
  }
  id v180 = 0;
  double v181 = 0;
LABEL_160:
}

void sub_10038F860(uint64_t a1, void *a2)
{
  id v10 = a2;
  uint64_t v3 = IDSSendErrorDomain;
  uint64_t v4 = +[NSDictionary dictionaryWithObject:@"Sending Internet IDS Messages before first unlock is no longer supported. Please contact the IDS & Privacy teams to discuss further" forKey:@"Reason"];
  id v5 = +[NSError errorWithDomain:v3 code:18 userInfo:v4];

  if (v10)
  {
    uint64_t v6 = [*(id *)(a1 + 32) messageUUID];
    uint64_t v7 = JWUUIDPushObjectToString();
    CFStringRef v8 = [*(id *)(a1 + 32) alternateCallbackID];
    CFStringRef v9 = [*(id *)(a1 + 32) mainAccountUUID];
    objc_msgSend(v10, "messageIdentifier:alternateCallbackID:forAccount:updatedWithResponseCode:error:lastCall:context:", v7, v8, v9, objc_msgSend(v5, "code"), v5, 1, *(void *)(a1 + 40));
  }
}

void sub_10038F994(uint64_t a1, void *a2)
{
  id v10 = a2;
  uint64_t v3 = IDSSendErrorDomain;
  uint64_t v4 = +[NSDictionary dictionaryWithObject:@"Destination device is not active for this account" forKey:@"Reason"];
  id v5 = +[NSError errorWithDomain:v3 code:24 userInfo:v4];

  if (v10)
  {
    uint64_t v6 = [*(id *)(a1 + 32) messageUUID];
    uint64_t v7 = JWUUIDPushObjectToString();
    CFStringRef v8 = [*(id *)(a1 + 32) alternateCallbackID];
    CFStringRef v9 = [*(id *)(a1 + 32) mainAccountUUID];
    objc_msgSend(v10, "messageIdentifier:alternateCallbackID:forAccount:updatedWithResponseCode:error:lastCall:context:", v7, v8, v9, objc_msgSend(v5, "code"), v5, 1, *(void *)(a1 + 40));
  }
}

void sub_10038FAC8(uint64_t a1, void *a2)
{
  id v10 = a2;
  uint64_t v3 = IDSSendErrorDomain;
  uint64_t v4 = +[NSDictionary dictionaryWithObject:@"Sender phone number is not bound to account AppleID." forKey:@"Reason"];
  id v5 = +[NSError errorWithDomain:v3 code:37 userInfo:v4];

  if (v10)
  {
    uint64_t v6 = [*(id *)(a1 + 32) messageUUID];
    uint64_t v7 = JWUUIDPushObjectToString();
    CFStringRef v8 = [*(id *)(a1 + 32) alternateCallbackID];
    CFStringRef v9 = [*(id *)(a1 + 32) mainAccountUUID];
    objc_msgSend(v10, "messageIdentifier:alternateCallbackID:forAccount:updatedWithResponseCode:error:lastCall:context:", v7, v8, v9, objc_msgSend(v5, "code"), v5, 1, *(void *)(a1 + 40));
  }
}

id sub_10038FBFC(void *a1)
{
  id v2 = objc_opt_class();
  uint64_t v3 = a1[6];
  uint64_t v4 = a1[7];
  uint64_t v5 = a1[8];
  uint64_t v7 = a1[4];
  uint64_t v6 = a1[5];

  return _[v2 sendMessageWithIDSSendParameters:v6 messageContext:v3 threadContext:v4 progressBlock:v5 onObject:v7];
}

void sub_10039069C(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x100390468);
  }
  _Unwind_Resume(a1);
}

void sub_1003906FC(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) replayStateCommitter];
  id v2 = [*(id *)(a1 + 40) replayKey];
  [v3 commitStateForKey:v2];
}

void sub_100390AA0(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v5 = *(void *)(a1 + 40);
    uint64_t v8 = *(void *)(a1 + 48);
    uint64_t v7 = *(void *)(a1 + 56);
    id v9 = [v3 idsResponseCode];
    id v10 = [v3 responseError];
    *(_DWORD *)long long buf = 138413570;
    uint64_t v30 = v6;
    __int16 v31 = 2112;
    uint64_t v32 = v5;
    __int16 v33 = 2112;
    uint64_t v34 = v8;
    __int16 v35 = 2112;
    uint64_t v36 = v7;
    __int16 v37 = 2048;
    id v38 = v9;
    __int16 v39 = 2112;
    id v40 = v10;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Finished sending cancel message using queueOneIdentifier: %@  fromID: %@  service: %@  messageIdentifier: %@   with responseCode: %ld responseError: %@", buf, 0x3Eu);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v11 = *(void *)(a1 + 32);
    uint64_t v12 = *(void *)(a1 + 40);
    uint64_t v13 = *(void *)(a1 + 48);
    uint64_t v14 = *(void *)(a1 + 56);
    id v15 = [v3 idsResponseCode];
    [v3 responseError];
    v28 = id v27 = v15;
    uint64_t v25 = v13;
    uint64_t v26 = v14;
    uint64_t v23 = v11;
    uint64_t v24 = v12;
    _IDSLogV();
  }
  if (objc_msgSend(v3, "idsResponseCode", v23, v24, v25, v26, v27, v28))
  {
    BOOL v16 = 0;
  }
  else
  {
    uint64_t v17 = [v3 responseError];
    BOOL v16 = v17 == 0;
  }
  __int16 v18 = +[IDSDaemon sharedInstance];
  CFStringRef v19 = [*(id *)(a1 + 64) localObject];
  __int16 v20 = [v18 broadcasterForLocalObject:v19 messageContext:*(void *)(a1 + 64)];

  if (v20)
  {
    uint64_t v21 = *(void *)(a1 + 72);
    uint64_t v22 = [v3 responseError];
    [v20 didCancelMessageWithSuccess:v16 onAccount:v21 error:v22 identifier:*(void *)(a1 + 56)];
  }
}

void sub_10039149C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  if (a2 == 1)
  {
    objc_begin_catch(exception_object);
    objc_end_catch();
    JUMPOUT(0x100391184);
  }
  _Unwind_Resume(exception_object);
}

void sub_100391658(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void *)(a1 + 40);
  if (v4) {
    (*(void (**)(uint64_t, id))(v4 + 16))(v4, v3);
  }
  uint64_t v5 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v6 = *(void *)(a1 + 32);
    unsigned int v7 = [v3 lastCall];
    CFStringRef v8 = @"NO";
    if (v7) {
      CFStringRef v8 = @"YES";
    }
    *(_DWORD *)long long buf = 138412546;
    uint64_t v10 = v6;
    __int16 v11 = 2112;
    CFStringRef v12 = v8;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Sent outgoing error message with guid %@. Last call? %@", buf, 0x16u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    [v3 lastCall];
    _IDSLogV();
  }
}

void sub_10039238C(uint64_t a1, void *a2, void *a3, double a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412802;
    id v17 = v7;
    __int16 v18 = 2048;
    double v19 = a4;
    __int16 v20 = 1024;
    BOOL v21 = v8 == 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Completed forced OTR negotiation: token is %@, setupTime is %.6f, error==nil is %d", buf, 0x1Cu);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      BOOL v15 = v8 == 0;
      double v14 = a4;
      id v13 = v7;
      _IDSLogTransport();
      if (_IDSShouldLog())
      {
        BOOL v15 = v8 == 0;
        double v14 = a4;
        id v13 = v7;
        _IDSLogV();
      }
    }
  }
  uint64_t v10 = +[IDSDaemon sharedInstance];
  __int16 v11 = [*(id *)(a1 + 32) localObject];
  CFStringRef v12 = [v10 broadcasterForLocalObject:v11 messageContext:*(void *)(a1 + 32)];

  if (v12) {
    [v12 OTRTestCallback:v7 time:v8 error:a4];
  }
}

void sub_100392D08(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 lastCall])
  {
    if ([v3 idsResponseCode])
    {
      uint64_t v4 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = [v3 responseError];
        uint64_t v6 = *(void *)(a1 + 32);
        *(_DWORD *)long long buf = 138412546;
        CFStringRef v12 = v5;
        __int16 v13 = 2112;
        uint64_t v14 = v6;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "** Failed sending engram decryption failure {responseError: %@, token: %@}", buf, 0x16u);
      }
      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
LABEL_12:
        uint64_t v10 = [v3 responseError];
        _IDSLogV();
      }
    }
    else
    {
      id v7 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        id v8 = [v3 responseError];
        uint64_t v9 = *(void *)(a1 + 32);
        *(_DWORD *)long long buf = 138412546;
        CFStringRef v12 = v8;
        __int16 v13 = 2112;
        uint64_t v14 = v9;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Finished sending engram decryption failure {responseError: %@, token: %@}", buf, 0x16u);
      }
      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        goto LABEL_12;
      }
    }
  }
}

void sub_100392F2C(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x100392EA0);
  }
  _Unwind_Resume(a1);
}

id sub_100393544(id a1, id a2)
{
  id v2 = a2;
  id v3 = [objc_alloc((Class)NSData) initWithBase64EncodedString:v2 options:0];

  return v3;
}

id sub_100393EDC(id a1, id a2)
{
  return [a2 base64EncodedStringWithOptions:0];
}

void sub_100394F88(uint64_t a1)
{
  id v2 = +[IDSUTunDeliveryController sharedInstance];
  unsigned __int8 v3 = [v2 hasSpaceForMessagesWithPriority:*(void *)(a1 + 48) dataProtectionClass:*(unsigned int *)(a1 + 56)];

  if (v3)
  {
    uint64_t v4 = +[IDSDMessageStore unsentNonUrgentAccountUUIDsRequiringDuetOverrides:*(unsigned __int8 *)(a1 + 60) priority:*(void *)(a1 + 48) dataProtectionClass:*(unsigned int *)(a1 + 56)];
    if ([v4 count]) {
      [*(id *)(a1 + 32) addObjectsFromArray:v4];
    }
    uint64_t v5 = [*(id *)(a1 + 32) allObjects];
    id v6 = [v5 mutableCopy];

    id v7 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void *)(a1 + 48);
      CFStringRef v9 = @"Sync";
      if (v8 == 200) {
        CFStringRef v9 = @"Default";
      }
      if (v8 == 300) {
        CFStringRef v10 = @"URGENT";
      }
      else {
        CFStringRef v10 = v9;
      }
      *(_DWORD *)long long buf = 138412546;
      CFStringRef v20 = v10;
      __int16 v21 = 2112;
      id v22 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "AccountUUIDs with pending %@ messages %@", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
    __int16 v11 = im_primary_queue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1003952AC;
    block[3] = &unk_10098A958;
    uint64_t v12 = *(void *)(a1 + 48);
    void block[4] = *(void *)(a1 + 40);
    id v16 = v6;
    uint64_t v17 = v12;
    int v18 = *(_DWORD *)(a1 + 56);
    id v13 = v6;
    dispatch_async(v11, block);
  }
  else
  {
    uint64_t v14 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "No space in local delivery queues for these messages.", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
  }
}

void sub_1003952AC(uint64_t a1)
{
  [*(id *)(a1 + 32) _processLocalMessagesWithAccountUUIDs:*(void *)(a1 + 40) priority:*(void *)(a1 + 48) dataProtectionClass:*(unsigned int *)(a1 + 56)];
}

void sub_1003956D0(uint64_t a1)
{
  id v2 = +[IDSUTunDeliveryController sharedInstance];
  unsigned __int8 v3 = [v2 hasSpaceForCloudMessagesWithPriority:*(void *)(a1 + 56) dataProtectionClass:*(unsigned int *)(a1 + 64)];

  if (v3)
  {
    uint64_t v4 = +[IDSDMessageStore unsentNonUrgentAccountUUIDsRequiringDuetOverrides:*(unsigned __int8 *)(a1 + 68) priority:*(void *)(a1 + 56) dataProtectionClass:*(unsigned int *)(a1 + 64) withMessageTypes:*(void *)(a1 + 32)];
    if ([v4 count]) {
      [*(id *)(a1 + 40) addObjectsFromArray:v4];
    }
    uint64_t v5 = [*(id *)(a1 + 40) allObjects];
    id v6 = [v5 mutableCopy];

    id v7 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void *)(a1 + 56);
      CFStringRef v9 = @"Sync";
      if (v8 == 200) {
        CFStringRef v9 = @"Default";
      }
      if (v8 == 300) {
        CFStringRef v10 = @"URGENT";
      }
      else {
        CFStringRef v10 = v9;
      }
      *(_DWORD *)long long buf = 138412546;
      CFStringRef v21 = v10;
      __int16 v22 = 2112;
      id v23 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "AccountUUIDs with pending %@ messages %@", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
    __int16 v11 = im_primary_queue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100395A10;
    block[3] = &unk_10098A178;
    uint64_t v12 = *(void *)(a1 + 56);
    void block[4] = *(void *)(a1 + 48);
    id v16 = v6;
    uint64_t v18 = v12;
    int v19 = *(_DWORD *)(a1 + 64);
    id v17 = *(id *)(a1 + 32);
    id v13 = v6;
    dispatch_async(v11, block);
  }
  else
  {
    uint64_t v14 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "No space in local delivery queues for these messages.", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
  }
}

void sub_100395A10(uint64_t a1)
{
  [*(id *)(a1 + 32) _processLocalMessagesWithAccountUUIDs:*(void *)(a1 + 40) priority:*(void *)(a1 + 56) dataProtectionClass:*(unsigned int *)(a1 + 64) messageTypes:*(void *)(a1 + 48)];
}

id sub_10039627C(uint64_t a1)
{
  return [*(id *)(a1 + 32) _processLocalMessagesWithAccountUUIDs:*(void *)(a1 + 40) priority:*(void *)(a1 + 48) dataProtectionClass:*(unsigned int *)(a1 + 56)];
}

void sub_100396290(uint64_t a1)
{
  id v2 = objc_opt_class();
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = *(void *)(a1 + 56);
  id v6 = +[IDSDaemonPriorityQueueController sharedInstance];
  id v7 = [v6 queueForPriority:*(void *)(a1 + 96)];
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  v11[2] = sub_1003963EC;
  void v11[3] = &unk_10098A9D0;
  void v11[4] = *(void *)(a1 + 32);
  id v12 = *(id *)(a1 + 64);
  id v8 = *(id *)(a1 + 72);
  CFStringRef v10 = *(void **)(a1 + 88);
  uint64_t v9 = *(void *)(a1 + 96);
  id v13 = v8;
  uint64_t v17 = v9;
  int v18 = *(_DWORD *)(a1 + 104);
  id v16 = v10;
  id v14 = *(id *)(a1 + 80);
  id v15 = *(id *)(a1 + 56);
  [v2 _performDuetCheckAndSendForServiceIdentifier:v3 serviceDuetIdentifiers:v4 sendParameters:v5 logString:0 fromQueue:v7 completionBlock:v11];
}

void sub_1003963EC(uint64_t a1, int a2)
{
  if (a2)
  {
    uint64_t v3 = objc_opt_class();
    uint64_t v4 = [*(id *)(a1 + 40) uniqueID];
    [v3 _sendLocalDeliveryMessagesForAccountUUID:v4 threadContext:*(void *)(a1 + 48) priority:*(void *)(a1 + 80) dataProtectionClass:*(unsigned int *)(a1 + 88)];

    CFStringRef v20 = im_primary_queue();
    dispatch_async(v20, *(dispatch_block_t *)(a1 + 72));
  }
  else
  {
    uint64_t v5 = objc_msgSend(*(id *)(a1 + 32), "_messageStoreForDataProtectionClass:", objc_msgSend(*(id *)(a1 + 48), "dataProtectionClass"));
    id v6 = [v5 duetIdentifiersOverrideForAccountWithGUID:*(void *)(a1 + 56) priority:*(void *)(a1 + 80)];

    if ([v6 count])
    {
      id v7 = *(void **)(a1 + 64);
      id v8 = [v6 allObjects];
      [v7 setDuetIdentifiersOverride:v8];

      uint64_t v9 = objc_opt_class();
      CFStringRef v10 = [*(id *)(a1 + 48) serviceIdentifier];
      __int16 v11 = [*(id *)(a1 + 48) serviceDuetIdentifiers];
      uint64_t v12 = *(void *)(a1 + 64);
      id v13 = +[IDSDaemonPriorityQueueController sharedInstance];
      id v14 = [v13 queueForPriority:*(void *)(a1 + 80)];
      v21[0] = _NSConcreteStackBlock;
      v21[1] = 3221225472;
      v21[2] = sub_100396648;
      v21[3] = &unk_10098A9A8;
      id v15 = *(void **)(a1 + 40);
      void v21[4] = *(void *)(a1 + 32);
      id v22 = v15;
      id v16 = *(id *)(a1 + 48);
      int v18 = *(void **)(a1 + 72);
      uint64_t v17 = *(void *)(a1 + 80);
      id v23 = v16;
      uint64_t v25 = v17;
      int v26 = *(_DWORD *)(a1 + 88);
      id v24 = v18;
      [v9 _performDuetCheckAndSendForServiceIdentifier:v10 serviceDuetIdentifiers:v11 sendParameters:v12 logString:0 fromQueue:v14 completionBlock:v21];
    }
    else
    {
      int v19 = im_primary_queue();
      dispatch_async(v19, *(dispatch_block_t *)(a1 + 72));
    }
  }
}

void sub_100396648(uint64_t a1, int a2)
{
  if (a2)
  {
    uint64_t v3 = objc_opt_class();
    uint64_t v4 = [*(id *)(a1 + 40) uniqueID];
    [v3 _sendLocalDeliveryMessagesForAccountUUID:v4 threadContext:*(void *)(a1 + 48) priority:*(void *)(a1 + 64) dataProtectionClass:*(unsigned int *)(a1 + 72)];
  }
  uint64_t v5 = im_primary_queue();
  dispatch_async(v5, *(dispatch_block_t *)(a1 + 56));
}

id sub_100396F44(uint64_t a1)
{
  return [*(id *)(a1 + 32) _processLocalMessagesWithAccountUUIDs:*(void *)(a1 + 40) priority:*(void *)(a1 + 56) dataProtectionClass:*(unsigned int *)(a1 + 64) messageTypes:*(void *)(a1 + 48)];
}

void sub_100396F58(uint64_t a1)
{
  id v2 = objc_opt_class();
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = *(void *)(a1 + 56);
  id v6 = +[IDSDaemonPriorityQueueController sharedInstance];
  id v7 = [v6 queueForPriority:*(void *)(a1 + 104)];
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_1003970CC;
  v10[3] = &unk_10098AA48;
  void v10[4] = *(void *)(a1 + 32);
  id v11 = *(id *)(a1 + 64);
  id v8 = *(id *)(a1 + 72);
  uint64_t v9 = *(void *)(a1 + 104);
  id v12 = v8;
  uint64_t v17 = v9;
  id v13 = *(id *)(a1 + 80);
  int v18 = *(_DWORD *)(a1 + 112);
  id v16 = *(id *)(a1 + 96);
  id v14 = *(id *)(a1 + 88);
  id v15 = *(id *)(a1 + 56);
  [v2 _performDuetCheckAndSendForServiceIdentifier:v3 serviceDuetIdentifiers:v4 sendParameters:v5 logString:0 fromQueue:v7 completionBlock:v10];
}

void sub_1003970CC(uint64_t a1, int a2)
{
  if (a2)
  {
    uint64_t v3 = objc_opt_class();
    uint64_t v4 = [*(id *)(a1 + 40) uniqueID];
    [v3 _sendLocalDeliveryMessagesForAccountUUID:v4 threadContext:*(void *)(a1 + 48) priority:*(void *)(a1 + 88) messageTypes:*(void *)(a1 + 56) dataProtectionClass:*(unsigned int *)(a1 + 96)];

    int v19 = im_primary_queue();
    dispatch_async(v19, *(dispatch_block_t *)(a1 + 80));
  }
  else
  {
    uint64_t v5 = objc_msgSend(*(id *)(a1 + 32), "_messageStoreForDataProtectionClass:", objc_msgSend(*(id *)(a1 + 48), "dataProtectionClass"));
    id v6 = [v5 duetIdentifiersOverrideForAccountWithGUID:*(void *)(a1 + 64) priority:*(void *)(a1 + 88)];

    if ([v6 count])
    {
      id v7 = *(void **)(a1 + 72);
      id v8 = [v6 allObjects];
      [v7 setDuetIdentifiersOverride:v8];

      uint64_t v9 = objc_opt_class();
      CFStringRef v10 = [*(id *)(a1 + 48) serviceIdentifier];
      id v11 = [*(id *)(a1 + 48) serviceDuetIdentifiers];
      uint64_t v12 = *(void *)(a1 + 72);
      id v13 = +[IDSDaemonPriorityQueueController sharedInstance];
      id v14 = [v13 queueForPriority:*(void *)(a1 + 88)];
      v20[0] = _NSConcreteStackBlock;
      v20[1] = 3221225472;
      v20[2] = sub_100397340;
      v20[3] = &unk_10098AA20;
      id v15 = *(void **)(a1 + 40);
      v20[4] = *(void *)(a1 + 32);
      id v21 = v15;
      id v16 = *(id *)(a1 + 48);
      uint64_t v17 = *(void *)(a1 + 88);
      id v22 = v16;
      uint64_t v25 = v17;
      id v23 = *(id *)(a1 + 56);
      int v26 = *(_DWORD *)(a1 + 96);
      id v24 = *(id *)(a1 + 80);
      [v9 _performDuetCheckAndSendForServiceIdentifier:v10 serviceDuetIdentifiers:v11 sendParameters:v12 logString:0 fromQueue:v14 completionBlock:v20];
    }
    else
    {
      int v18 = im_primary_queue();
      dispatch_async(v18, *(dispatch_block_t *)(a1 + 80));
    }
  }
}

void sub_100397340(uint64_t a1, int a2)
{
  if (a2)
  {
    uint64_t v3 = objc_opt_class();
    uint64_t v4 = [*(id *)(a1 + 40) uniqueID];
    [v3 _sendLocalDeliveryMessagesForAccountUUID:v4 threadContext:*(void *)(a1 + 48) priority:*(void *)(a1 + 72) messageTypes:*(void *)(a1 + 56) dataProtectionClass:*(unsigned int *)(a1 + 80)];
  }
  uint64_t v5 = im_primary_queue();
  dispatch_async(v5, *(dispatch_block_t *)(a1 + 64));
}

id sub_100397D88(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _nonUrgentInternetSendTimerFired];
}

void sub_10039A4C4(_Unwind_Exception *exc_buf, int a2)
{
  if (a2 == 1)
  {

    objc_end_catch();
    JUMPOUT(0x10039984CLL);
  }
  _Unwind_Resume(exc_buf);
}

void sub_10039A578(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) guid];

  if (v2)
  {
    uint64_t v3 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = [*(id *)(a1 + 32) guid];
      *(_DWORD *)long long buf = 138412290;
      __int16 v33 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Deleting non-urgent internet outgoing message with guid %@", buf, 0xCu);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      int v26 = [*(id *)(a1 + 32) guid];
      _IDSLogV();
    }
    uint64_t v5 = +[IDSDAccountController sharedInstance];
    id v6 = [*(id *)(a1 + 32) accountGUID];
    id v7 = [v5 accountWithUniqueID:v6];

    id v8 = [v7 service];
    id v9 = [v8 dataProtectionClass];

    CFStringRef v10 = [*(id *)(a1 + 32) guid];
    id v11 = [*(id *)(a1 + 32) alternateGUID];
    +[IDSDMessageStore deleteOutgoingMessageWithGUID:v10 alternateGUID:v11 dataProtectionClass:v9];
  }
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  uint64_t v12 = [*(id *)(a1 + 32) combinedMessages];
  id v13 = [v12 countByEnumeratingWithState:&v27 objects:v31 count:16];
  if (v13)
  {
    uint64_t v14 = *(void *)v28;
    do
    {
      for (uint64_t i = 0; i != v13; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v28 != v14) {
          objc_enumerationMutation(v12);
        }
        id v16 = *(void **)(*((void *)&v27 + 1) + 8 * i);
        uint64_t v17 = [v16 guid];

        if (v17)
        {
          int v18 = OSLogHandleForIDSCategory();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            int v19 = [v16 guid];
            *(_DWORD *)long long buf = 138412290;
            __int16 v33 = v19;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Deleting non-urgent internet outgoing combinedMessage with guid %@", buf, 0xCu);
          }
          if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
          {
            int v26 = [v16 guid];
            _IDSLogV();
          }
          CFStringRef v20 = +[IDSDAccountController sharedInstance];
          id v21 = [*(id *)(a1 + 32) accountGUID];
          id v22 = [v20 accountWithUniqueID:v21];

          id v23 = [v22 service];
          id v24 = [v23 dataProtectionClass];

          uint64_t v25 = [v16 guid];
          +[IDSDMessageStore deleteOutgoingMessageWithGUID:v25 alternateGUID:0 dataProtectionClass:v24];
        }
      }
      id v13 = [v12 countByEnumeratingWithState:&v27 objects:v31 count:16];
    }
    while (v13);
  }
}

void sub_10039A9AC(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = [v3 guid];
    *(_DWORD *)long long buf = 138412290;
    __int16 v31 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Sending individual non-urgent internet message %@", buf, 0xCu);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    id v15 = [v3 guid];
    _IDSLogV();
  }
  id v22 = *(void **)(a1 + 32);
  int v26 = objc_msgSend(v3, "message", v15);
  id v25 = [v3 copySendParameters];
  id v24 = [v3 fromID];
  id v23 = [v3 destinations];
  unsigned int v21 = [v3 useDictAsTopLevel];
  id v6 = [v3 dataToEncrypt];
  unsigned __int8 v20 = [v3 encryptPayload];
  unsigned __int8 v19 = [v3 wantsResponse];
  id v7 = [v3 expirationDate];
  id v8 = [v3 command];
  unsigned __int8 v9 = [v3 wantsDeliveryStatus];
  unsigned __int8 v10 = [v3 wantsCertifiedDelivery];
  id v11 = [v3 deliveryStatusContext];
  uint64_t v12 = [v3 messageUUID];
  id v13 = [v3 priority];
  v27[0] = _NSConcreteStackBlock;
  v27[1] = 3221225472;
  v27[2] = sub_10039ACD4;
  v27[3] = &unk_100980110;
  id v28 = v3;
  id v29 = *(id *)(a1 + 32);
  id v14 = v3;
  LOWORD(v18) = 0;
  BYTE1(v17) = v10;
  LOBYTE(v17) = v9;
  BYTE1(v16) = v19;
  LOBYTE(v16) = v20;
  objc_msgSend(v22, "sendMessage:params:bulkedPayload:fromID:toDestinations:useDictAsTopLevel:dataToEncrypt:encryptPayload:wantsResponse:expirationDate:command:wantsDeliveryStatus:wantsCertifiedDelivery:deliveryStatusContext:messageUUID:priority:localDelivery:disallowRefresh:willSendBlock:completionBlock:", v26, v25, 0, v24, v23, v21, v6, v16, v7, v8, v17, v11, v12, v13, v18,
    0,
    v27);
}

void sub_10039ACD4(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = [*(id *)(a1 + 32) guid];
    if ([v3 lastCall]) {
      CFStringRef v6 = @"YES";
    }
    else {
      CFStringRef v6 = @"NO";
    }
    id v7 = [v3 responseError];
    *(_DWORD *)long long buf = 138413058;
    id v19 = v5;
    __int16 v20 = 2112;
    CFStringRef v21 = v6;
    __int16 v22 = 2112;
    id v23 = v7;
    __int16 v24 = 2048;
    id v25 = [v3 idsResponseCode];
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Deleting sent non-urgent internet outgoing sole message with guid %@? %@. Error? %@ response code %ld", buf, 0x2Au);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    id v8 = [*(id *)(a1 + 32) guid];
    if ([v3 lastCall]) {
      CFStringRef v9 = @"YES";
    }
    else {
      CFStringRef v9 = @"NO";
    }
    uint64_t v16 = [v3 responseError];
    id v17 = [v3 idsResponseCode];
    id v14 = v8;
    CFStringRef v15 = v9;
    _IDSLogV();
  }
  if (objc_msgSend(v3, "lastCall", v14, v15, v16, v17))
  {
    unsigned __int8 v10 = [*(id *)(a1 + 40) service];
    id v11 = [v10 dataProtectionClass];

    uint64_t v12 = [*(id *)(a1 + 32) guid];
    id v13 = [*(id *)(a1 + 32) alternateGUID];
    +[IDSDMessageStore deleteOutgoingMessageWithGUID:v12 alternateGUID:v13 dataProtectionClass:v11];
  }
}

void sub_10039AF38(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = [*(id *)(a1 + 32) guid];
    if ([v3 lastCall]) {
      CFStringRef v6 = @"YES";
    }
    else {
      CFStringRef v6 = @"NO";
    }
    id v7 = [v3 responseError];
    *(_DWORD *)long long buf = 138413058;
    id v15 = v5;
    __int16 v16 = 2112;
    CFStringRef v17 = v6;
    __int16 v18 = 2112;
    id v19 = v7;
    __int16 v20 = 2048;
    id v21 = [v3 idsResponseCode];
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Deleting sent non-urgent internet message with guid %@? %@. Error? %@ response code %ld", buf, 0x2Au);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    id v8 = [*(id *)(a1 + 32) guid];
    if ([v3 lastCall]) {
      CFStringRef v9 = @"YES";
    }
    else {
      CFStringRef v9 = @"NO";
    }
    uint64_t v12 = [v3 responseError];
    id v13 = [v3 idsResponseCode];
    unsigned __int8 v10 = v8;
    CFStringRef v11 = v9;
    _IDSLogV();
  }
  if (objc_msgSend(v3, "lastCall", v10, v11, v12, v13)) {
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

uint64_t sub_10039B14C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_10039B15C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10039BFE8(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) replayStateCommitter];
  [v2 commitStateForKey:*(void *)(a1 + 40)];
}

void sub_10039D18C(uint64_t a1, void *a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7)
{
  id v106 = a2;
  id v109 = a4;
  __int16 v110 = a5;
  id v114 = a6;
  id v113 = a7;
  if (_os_feature_enabled_impl() && IDSCommandIsGroupSessionCommand())
  {
    [*(id *)(a1 + 32) integerValue];
    kdebug_trace();
  }
  uint64_t v13 = sub_1002DC660(v114);
  unint64_t v107 = (unint64_t)[v113 encryptionType];
  uint64_t v115 = v13;
  if (([v113 usedCachedData] & 1) == 0)
  {
    if (v107 == 4)
    {
      CFMutableDictionaryRef theDict = +[NSNumber numberWithBool:a3];
      id v100 = v114;
      id v14 = [v113 additionalDecryptionResult];
      id v15 = [v14 objectForKey:&off_1009D1F20];
      id v16 = v15;
      id value = v16;
      if (![v16 code])
      {
        CFStringRef v17 = [v16 domain];
        unsigned int v18 = [v17 isEqualToString:@"com.apple.messageprotection"];

        id value = v16;
        if (v18)
        {

          id value = 0;
        }
      }
      if (v15)
      {
        id v19 = +[NSNumber numberWithBool:value == 0];
      }
      else
      {
        id v19 = 0;
      }

      id v98 = 0;
      uint64_t v104 = 0;
      goto LABEL_18;
    }
    if ((v107 & 0xFFFFFFFFFFFFFFFELL) == 4)
    {
      uint64_t v104 = 0;
      id v98 = 0;
    }
    else
    {
      uint64_t v104 = +[NSNumber numberWithBool:a3];
      id v98 = v114;
      if (v107 != 5)
      {
        CFMutableDictionaryRef theDict = 0;
        id v100 = 0;
        id value = 0;
        id v19 = 0;
        goto LABEL_18;
      }
    }
    id value = v114;
    id v19 = +[NSNumber numberWithBool:a3];
    CFMutableDictionaryRef theDict = 0;
    id v100 = 0;
LABEL_18:
    __int16 v20 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = *(void *)(a1 + 32);
      *(_DWORD *)long long buf = 138413058;
      *(void *)CFStringRef v140 = theDict;
      *(_WORD *)&v140[8] = 2112;
      *(void *)&v140[10] = v104;
      *(_WORD *)&v140[18] = 2112;
      *(void *)&v140[20] = v19;
      __int16 v141 = 2112;
      uint64_t v142 = v21;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Incoming message - processing metrics {ECSuccess: %@, legacySuccess: %@, secondarySuccess: %@, command: %@}", buf, 0x2Au);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      id v94 = v19;
      uint64_t v95 = *(void *)(a1 + 32);
      CFMutableDictionaryRef v90 = theDict;
      unsigned __int8 v92 = v104;
      _IDSLogV();
    }
    uint64_t v23 = *(void *)(a1 + 32);
    uint64_t v22 = *(void *)(a1 + 40);
    unsigned __int8 v24 = objc_msgSend(v113, "usedLastResortCache", v90, v92, v94, v95);
    id v25 = [*(id *)(a1 + 48) prefixedURI];
    int v26 = [*(id *)(a1 + 56) rawToken];
    long long v27 = [*(id *)(a1 + 64) pushHandlerForAPSDelegatePort];
    id v28 = [v27 pushToken];
    LOBYTE(v91) = v24;
    +[IDSMessageMetricReporter reportMessageMetricWithMetadata:v22 secondarySuccess:v19 ECSuccess:theDict legacySuccess:v104 command:v23 decryptedEqual:1 triedLastResort:v91 secondaryError:value ECError:v100 legacyError:v98 fromDestination:v25 fromToken:v26 toToken:v28];

    uint64_t v13 = v115;
  }
  if (v13)
  {
    CFMutableDictionaryRef theDicta = +[NSError errorWithDomain:IDSGenericErrorDomain code:v13 userInfo:0];
    if ([*(id *)(a1 + 64) _shouldForgetCachedPeerTokensForDecryptionErrorType:v115 withOriginalDecryptionError:v114])
    {
      id v29 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v30 = *(void *)(a1 + 48);
        *(_DWORD *)long long buf = 138412290;
        *(void *)CFStringRef v140 = v30;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Blowing away local peer cache for peer tokens for URI: %@", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        CFMutableDictionaryRef v90 = *(CFMutableDictionaryRef *)(a1 + 48);
        _IDSLogV();
      }
      __int16 v31 = +[IDSPeerIDManager sharedInstance];
      uint64_t v32 = *(void *)(a1 + 48);
      uint64_t v33 = *(void *)(a1 + 88);
      uint64_t v34 = [*(id *)(a1 + 96) queryService];
      [v31 forgetPeerTokensForURI:v32 fromURI:v33 service:v34];
    }
    int v35 = v115;
    if (*(unsigned char *)(a1 + 184)
      || (int v35 = v115, ![*(id *)(a1 + 64) _shouldRetryForDecryptionErrorType:v115]))
    {
      uint64_t v41 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v42 = *(void *)(a1 + 72);
        *(_DWORD *)long long buf = 67109634;
        *(_DWORD *)CFStringRef v140 = v35;
        *(_WORD *)&v140[4] = 2112;
        *(void *)&v140[6] = v42;
        *(_WORD *)&v140[14] = 2112;
        *(void *)&v140[16] = v114;
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "** Had decryption error: %d { guid: %@, error: %@ }", buf, 0x1Cu);
      }

      int v43 = os_log_shim_legacy_logging_enabled();
      uint64_t v44 = v115;
      if (v43)
      {
        unsigned __int8 v92 = *(void **)(a1 + 72);
        id v94 = v114;
        CFMutableDictionaryRef v90 = (CFMutableDictionaryRef)v115;
        _IDSLogEventV();
        uint64_t v44 = v115;
      }
      sub_1002DC27C(v44);
      FTAWDLogIMessageReceived();
      if (v115 == 601)
      {
        id v45 = [objc_alloc((Class)IDSMissingMessageMetric) initWithReason:704 guid:*(void *)(a1 + 72) service:*(void *)(a1 + 80) additionalInformation:0];
        +[IDSMissingMessageMetricReporter sendMetric:v45];
      }
      v119[0] = _NSConcreteStackBlock;
      v119[1] = 3221225472;
      v119[2] = sub_10039E27C;
      v119[3] = &unk_10098AAE8;
      id v46 = *(id *)(a1 + 168);
      uint64_t v47 = *(void *)(a1 + 176);
      id v125 = v46;
      uint64_t v126 = v47;
      id v120 = *(id *)(a1 + 104);
      id v121 = *(id *)(a1 + 136);
      id v122 = *(id *)(a1 + 144);
      CFMutableDictionaryRef theDicta = theDicta;
      CFMutableDictionaryRef v123 = theDicta;
      id v124 = *(id *)(a1 + 128);
      id v105 = objc_retainBlock(v119);
      if (v107 == 5) {
        BOOL v48 = v114;
      }
      else {
        BOOL v48 = 0;
      }
      id v49 = v48;
      if (v107 == 4) {
        uint64_t v50 = v114;
      }
      else {
        uint64_t v50 = 0;
      }
      id v51 = v50;
      if ((v107 & 0xFFFFFFFFFFFFFFFELL) == 4) {
        uint64_t v52 = 0;
      }
      else {
        uint64_t v52 = v114;
      }
      __int16 v97 = v49;
      __int16 v99 = v51;
      id v101 = v52;
      unsigned int v108 = objc_msgSend(*(id *)(a1 + 64), "_failureReasonMessageFromSecondaryError:ECError:andLegacyError:", v49, v51);
      if ([*(id *)(a1 + 64) _shouldReplyWithCertifiedDeliveryReceiptForDecryptionErrorType:v115])
      {
        uint64_t v53 = *(void **)(a1 + 64);
        uint64_t v54 = *(void *)(a1 + 104);
        uint64_t v55 = *(void *)(a1 + 80);
        id v56 = +[NSNumber numberWithInteger:v115];
        [v53 _sendCertifiedDeliveryReceiptIfNeededForNiceMessage:v54 service:v55 failureReason:v56 failureReasonMessage:v108 generateDeliveryReceipt:0];
      }
      if (objc_msgSend(*(id *)(a1 + 64), "_shouldReplyWithRemoteDecryptionErrorMessageForDecryptionErrorType:", v115, v90, v92, v94))
      {
        valuea = [*(id *)(a1 + 104) pushUUID];
        uint64_t v96 = [*(id *)(a1 + 104) command];
        id v57 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
        id v58 = IDSGetUUIDData();
        if (v58) {
          CFDictionarySetValue(v57, IDSFailedUUIDKey, v58);
        }

        if (valuea) {
          CFDictionarySetValue(v57, IDSFailedMessageIDKey, valuea);
        }
        long long v59 = +[NSNumber numberWithInteger:v115];
        if (v59) {
          CFDictionarySetValue(v57, IDSFailureReasonKey, v59);
        }

        if (v108) {
          CFDictionarySetValue(v57, IDSFailureReasonMessageKey, v108);
        }
        uint64_t v60 = [*(id *)(a1 + 120) dataRepresentation];
        if (v60) {
          CFDictionarySetValue(v57, @"gI", v60);
        }

        uint64_t v61 = (id *)(a1 + 56);
        uint64_t v62 = [*(id *)(a1 + 56) rawToken];
        uint64_t v63 = [*(id *)(a1 + 48) prefixedURI];
        uint64_t v64 = (void *)_IDSCopyIDForTokenWithURI();

        uint64_t v65 = *(void **)(a1 + 64);
        uint64_t v66 = *(void *)(a1 + 88);
        uint64_t v67 = +[NSSet setWithObject:v64];
        id v68 = +[IDSDestination destinationWithStrings:v67];
        id v69 = [*(id *)(a1 + 152) uniqueID];
        int v70 = +[NSNumber numberWithInteger:120];
        v116[0] = _NSConcreteStackBlock;
        v116[1] = 3221225472;
        v116[2] = sub_10039E3C0;
        v116[3] = &unk_10098AB10;
        uint64_t v118 = v115;
        id v117 = *v61;
        LOBYTE(v93) = 1;
        [v65 _sendErrorMessage:v57 originalCommand:v96 fromURI:v66 toDestinations:v68 usingAccountWithUniqueID:v69 useDictAsTopLevel:1 dataToEncrypt:-1.0 wantsResponse:0 timeout:v93 command:v70 priority:300 completionBlock:v116];
      }
      ((void (*)(void))v105[2])();
    }
    else
    {
      uint64_t v36 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v37 = *(void *)(a1 + 72);
        [*(id *)(a1 + 64) _decryptionRetryIntervalForError:v114];
        *(_DWORD *)long long buf = 138412546;
        *(void *)CFStringRef v140 = v37;
        *(_WORD *)&v140[8] = 2048;
        *(void *)&v140[10] = v38;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "Retrying decryption for message %@ in %f seconds", buf, 0x16u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        __int16 v39 = *(__CFDictionary **)(a1 + 72);
        [*(id *)(a1 + 64) _decryptionRetryIntervalForError:v114];
        unsigned __int8 v92 = v40;
        CFMutableDictionaryRef v90 = v39;
        _IDSLogV();
      }
      objc_msgSend(*(id *)(a1 + 64), "_decryptionRetryIntervalForError:", v114, v90, v92);
      v127 = _NSConcreteStackBlock;
      uint64_t v128 = 3221225472;
      v129 = sub_10039E23C;
      double v130 = &unk_10098AAC0;
      uint64_t v131 = *(void *)(a1 + 64);
      id v132 = *(id *)(a1 + 104);
      id v133 = *(id *)(a1 + 112);
      id v134 = *(id *)(a1 + 120);
      id v135 = *(id *)(a1 + 80);
      id v136 = *(id *)(a1 + 48);
      id v137 = *(id *)(a1 + 128);
      id v138 = *(id *)(a1 + 168);
      im_dispatch_after_primary_queue();
    }
  }
  else
  {
    if ([v113 usedLastResortCache]) {
      [*(id *)(a1 + 64) _submitLastResortCacheMetricForGUID:*(void *)(a1 + 72) service:*(void *)(a1 + 80)];
    }
    if (*(void *)(a1 + 176) == 3)
    {
      CFMutableDictionaryRef theDicta = (CFMutableDictionaryRef)objc_alloc_init((Class)NSMutableDictionary);
      uint64_t v71 = [*(id *)(a1 + 104) rawMessage];
      if (v71)
      {
        CFDictionarySetValue(theDicta, IDSIncomingMessagePushPayloadKey, v71);
      }
      else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        sub_10071FD6C();
      }

      long long v85 = *(const void **)(a1 + 136);
      if (v85) {
        CFDictionarySetValue(theDicta, IDSIncomingMessageOriginalEncryptionTypeKey, v85);
      }
      long long v86 = *(const void **)(a1 + 144);
      if (v86) {
        CFDictionarySetValue(theDicta, IDSIncomingMessageEngramEncryptedDataKey, v86);
      }
      (*(void (**)(void))(*(void *)(a1 + 168) + 16))();
    }
    else
    {
      if (v110)
      {
        id v72 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          *(void *)CFStringRef v140 = v110;
          _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "Gossip - EncryptedAttributes: %@", buf, 0xCu);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
        {
          CFMutableDictionaryRef v90 = v110;
          _IDSLogV();
        }
        id v73 = -[__CFDictionary objectForKeyedSubscript:](v110, "objectForKeyedSubscript:", NGMEncryptedAttributeKTGossipData, v90);

        if (v73)
        {
          uint64_t v74 = +[IDSKTGossipManager sharedInstance];
          uint64_t v75 = [(__CFDictionary *)v110 objectForKeyedSubscript:NGMEncryptedAttributeKTGossipData];
          [v74 sthReceivedFromGossipReceipient:v75];
        }
      }
      if (*(void *)(a1 + 128))
      {
        id v76 = objc_alloc((Class)IDSCertifiedDeliveryContext);
        id v77 = [*(id *)(a1 + 128) originalGUID];
        id v78 = [*(id *)(a1 + 128) service];
        uint64_t v79 = IDSEncryptionTypeFromEncryptionTypeString();
        id v80 = [*(id *)(a1 + 128) certifiedDeliveryVersion];
        unsigned int v81 = [*(id *)(a1 + 128) certifiedDeliveryRTS];
        long long v82 = [*(id *)(a1 + 128) senderToken];
        long long v83 = [*(id *)(a1 + 128) localURI];
        long long v84 = [*(id *)(a1 + 128) remoteURI];
        CFMutableDictionaryRef theDicta = (CFMutableDictionaryRef)[v76 initWithGUID:v77 service:v78 encryptionType:v79 certifiedDeliveryVersion:v80 certifiedDeliveryRTS:v81 senderToken:v82 localURI:v83 remoteURI:v84 replayKey:*(void *)(a1 + 160)];
      }
      else
      {
        CFMutableDictionaryRef theDicta = 0;
      }
      long long v87 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
      unsigned int v88 = [*(id *)(a1 + 104) rawMessage];
      if (v88)
      {
        CFDictionarySetValue(v87, IDSIncomingMessagePushPayloadKey, v88);
      }
      else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        sub_10071FD6C();
      }

      if (v109) {
        CFDictionarySetValue(v87, IDSIncomingMessageDecryptedDataKey, v109);
      }
      unsigned int v89 = *(const void **)(a1 + 136);
      if (v89) {
        CFDictionarySetValue(v87, IDSIncomingMessageOriginalEncryptionTypeKey, v89);
      }
      (*(void (**)(void))(*(void *)(a1 + 168) + 16))();
    }
  }
}

id sub_10039E23C(uint64_t a1)
{
  LOBYTE(v2) = 1;
  return [*(id *)(a1 + 32) _optionallyDecryptNiceMessage:*(void *)(a1 + 40) encryptedData:*(void *)(a1 + 48) forGroupID:*(void *)(a1 + 56) forTopic:*(void *)(a1 + 64) fromURI:*(void *)(a1 + 72) certifiedDeliveryContext:*(void *)(a1 + 80) isLiveRetry:v2 completionBlock:*(void *)(a1 + 88)];
}

void sub_10039E27C(uint64_t a1)
{
  if (*(void *)(a1 + 72))
  {
    uint64_t v2 = *(void *)(a1 + 80);
    id v3 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
    uint64_t v4 = [*(id *)(a1 + 32) rawMessage];
    id v5 = v4;
    if (v2 == 3)
    {
      if (v4)
      {
        CFDictionarySetValue(v3, IDSIncomingMessagePushPayloadKey, v4);
      }
      else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        sub_10071FD6C();
      }

      CFStringRef v6 = *(const void **)(a1 + 40);
      if (v6) {
        CFDictionarySetValue(v3, IDSIncomingMessageOriginalEncryptionTypeKey, v6);
      }
      id v7 = *(const void **)(a1 + 48);
      if (!v7) {
        goto LABEL_18;
      }
      id v8 = (const void **)&IDSIncomingMessageEngramEncryptedDataKey;
    }
    else
    {
      if (v4)
      {
        CFDictionarySetValue(v3, IDSIncomingMessagePushPayloadKey, v4);
      }
      else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        sub_10071FD6C();
      }

      id v7 = *(const void **)(a1 + 40);
      if (!v7) {
        goto LABEL_18;
      }
      id v8 = (const void **)&IDSIncomingMessageOriginalEncryptionTypeKey;
    }
    CFDictionarySetValue(v3, *v8, v7);
LABEL_18:
    (*(void (**)(void))(*(void *)(a1 + 72) + 16))();
  }
}

void sub_10039E3C0(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 lastCall])
  {
    if ([v3 idsResponseCode])
    {
      uint64_t v4 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = *(void *)(a1 + 40);
        CFStringRef v6 = [v3 responseError];
        uint64_t v7 = *(void *)(a1 + 32);
        *(_DWORD *)long long buf = 67109634;
        int v14 = v5;
        __int16 v15 = 2112;
        id v16 = v6;
        __int16 v17 = 2112;
        uint64_t v18 = v7;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "** Failed sending decryption error: %d, %@ to token: %@", buf, 0x1Cu);
      }
      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
LABEL_12:
        uint64_t v12 = [v3 responseError];
        _IDSLogV();
      }
    }
    else
    {
      id v8 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = *(void *)(a1 + 40);
        unsigned __int8 v10 = [v3 responseError];
        uint64_t v11 = *(void *)(a1 + 32);
        *(_DWORD *)long long buf = 67109634;
        int v14 = v9;
        __int16 v15 = 2112;
        id v16 = v10;
        __int16 v17 = 2112;
        uint64_t v18 = v11;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Finished sending decryption error: %d, %@  to token: %@", buf, 0x1Cu);
      }
      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        goto LABEL_12;
      }
    }
  }
}

void sub_10039E614(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x10039E57CLL);
  }
  _Unwind_Resume(a1);
}

void sub_10039EF18(uint64_t a1, void *a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7)
{
  id v117 = a2;
  id v121 = a4;
  id v122 = a5;
  id v13 = a6;
  id v14 = a7;
  uint64_t v126 = v13;
  uint64_t v15 = sub_1002DC660(v13);
  unint64_t v16 = (unint64_t)[v14 encryptionType];
  CFMutableDictionaryRef v123 = v14;
  uint64_t v127 = v15;
  if ([v14 usedCachedData]) {
    goto LABEL_28;
  }
  id value = [*(id *)(a1 + 32) command];
  if (v16 != 4)
  {
    BOOL v19 = (v16 & 0xFFFFFFFFFFFFFFFELL) == 4;
    if ((v16 & 0xFFFFFFFFFFFFFFFELL) == 4)
    {
      id v124 = 0;
    }
    else
    {
      id v124 = +[NSNumber numberWithBool:a3];
      if (v16 != 5)
      {
        __int16 v17 = 0;
        id v114 = 0;
        BOOL v19 = 0;
        uint64_t v18 = 0;
        goto LABEL_4;
      }
    }
    __int16 v17 = +[NSNumber numberWithBool:a3];
    id v114 = 0;
    __int16 v20 = v126;
    uint64_t v18 = v126;
    goto LABEL_10;
  }
  id v114 = +[NSNumber numberWithBool:a3];
  __int16 v17 = 0;
  id v124 = 0;
  uint64_t v18 = 0;
  BOOL v19 = 1;
LABEL_4:
  __int16 v20 = v126;
LABEL_10:
  uint64_t v21 = v20;
  if (v16 != 4) {
    __int16 v20 = 0;
  }
  id v108 = v20;
  if (v19) {
    uint64_t v22 = 0;
  }
  else {
    uint64_t v22 = v21;
  }
  id v111 = v22;
  id v23 = v18;
  if (v16 == 4)
  {
    unsigned __int8 v24 = [v123 additionalDecryptionResult];
    id v25 = [v24 objectForKey:&off_1009D1F20];
    id v26 = v25;

    id v23 = v26;
    if (![v26 code])
    {
      long long v27 = [v26 domain];
      unsigned int v28 = [v27 isEqualToString:@"com.apple.messageprotection"];

      id v23 = v26;
      if (v28)
      {

        id v23 = 0;
      }
    }
    if (v25)
    {
      id v25 = +[NSNumber numberWithBool:v23 == 0];
    }

    __int16 v17 = v25;
  }
  id v29 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138413058;
    *(void *)uint64_t v149 = v114;
    *(_WORD *)&v149[8] = 2112;
    *(void *)&v149[10] = v124;
    *(_WORD *)&v149[18] = 2112;
    *(void *)&v149[20] = v17;
    __int16 v150 = 2112;
    int v151 = value;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "EC overflow message came in, processing metric {ECSuccess: %@, legacySuccess: %@, secondarySuccess: %@, command: %@}", buf, 0x2Au);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v104 = v17;
    id v105 = value;
    id v99 = v114;
    uint64_t v102 = v124;
    _IDSLogV();
  }
  uint64_t v30 = *(void *)(a1 + 40);
  unsigned __int8 v31 = objc_msgSend(v123, "usedLastResortCache", v99, v102, v104, v105);
  uint64_t v32 = [*(id *)(a1 + 48) prefixedURI];
  uint64_t v33 = [*(id *)(a1 + 56) rawToken];
  uint64_t v34 = [*(id *)(a1 + 64) pushHandlerForAPSDelegatePort];
  int v35 = [v34 pushToken];
  LOBYTE(v100) = v31;
  +[IDSMessageMetricReporter reportMessageMetricWithMetadata:v30 secondarySuccess:v17 ECSuccess:v114 legacySuccess:v124 command:value decryptedEqual:1 triedLastResort:v100 secondaryError:v23 ECError:v108 legacyError:v111 fromDestination:v32 fromToken:v33 toToken:v35];

  uint64_t v15 = v127;
LABEL_28:
  if (v15)
  {
    uint64_t v36 = +[NSError errorWithDomain:IDSGenericErrorDomain code:v15 userInfo:0];
    if ([*(id *)(a1 + 64) _shouldForgetCachedPeerTokensForDecryptionErrorType:v127 withOriginalDecryptionError:v126])
    {
      uint64_t v37 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v38 = *(void *)(a1 + 48);
        *(_DWORD *)long long buf = 138412290;
        *(void *)uint64_t v149 = v38;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "Blowing away local peer cache for peer tokens for URI: %@", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        id v99 = *(id *)(a1 + 48);
        _IDSLogV();
      }
      __int16 v39 = +[IDSPeerIDManager sharedInstance];
      uint64_t v40 = *(void *)(a1 + 48);
      uint64_t v41 = *(void *)(a1 + 72);
      uint64_t v42 = [*(id *)(a1 + 80) queryService];
      [v39 forgetPeerTokensForURI:v40 fromURI:v41 service:v42];
    }
    int v43 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v44 = *(void *)(a1 + 88);
      *(_DWORD *)long long buf = 67109634;
      *(_DWORD *)uint64_t v149 = v127;
      *(_WORD *)&v149[4] = 2112;
      *(void *)&v149[6] = v44;
      *(_WORD *)&v149[14] = 2112;
      *(void *)&v149[16] = v126;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "** Had decryption error: %d { guid: %@, error: %@ }", buf, 0x1Cu);
    }

    int v45 = os_log_shim_legacy_logging_enabled();
    uint64_t v46 = v127;
    if (v45)
    {
      uint64_t v102 = *(void **)(a1 + 88);
      uint64_t v104 = v126;
      id v99 = (id)v127;
      _IDSLogEventV();
      uint64_t v46 = v127;
    }
    sub_1002DC27C(v46);
    FTAWDLogIMessageReceived();
    v142[0] = _NSConcreteStackBlock;
    v142[1] = 3221225472;
    v142[2] = sub_1003A01E8;
    v142[3] = &unk_10098AB60;
    id v147 = *(id *)(a1 + 128);
    id v143 = *(id *)(a1 + 32);
    id v144 = *(id *)(a1 + 96);
    id v125 = v36;
    id v145 = v125;
    id v146 = *(id *)(a1 + 104);
    uint64_t v115 = objc_retainBlock(v142);
    if (*(void *)(a1 + 136) == 5) {
      uint64_t v47 = v126;
    }
    else {
      uint64_t v47 = 0;
    }
    id v48 = v47;
    if (*(void *)(a1 + 136) == 4) {
      id v49 = v126;
    }
    else {
      id v49 = 0;
    }
    id v50 = v49;
    if ((*(void *)(a1 + 136) & 0xFFFFFFFFFFFFFFFELL) == 4) {
      id v51 = 0;
    }
    else {
      id v51 = v126;
    }
    unint64_t v107 = v48;
    id v109 = v50;
    id v112 = v51;
    valuea = objc_msgSend(*(id *)(a1 + 64), "_failureReasonMessageFromSecondaryError:ECError:andLegacyError:", v48, v50);
    if ([*(id *)(a1 + 64) _shouldReplyWithCertifiedDeliveryReceiptForDecryptionErrorType:v127])
    {
      uint64_t v52 = *(void **)(a1 + 64);
      uint64_t v53 = *(void *)(a1 + 32);
      uint64_t v54 = *(void *)(a1 + 112);
      uint64_t v55 = +[NSNumber numberWithInteger:v127];
      [v52 _sendCertifiedDeliveryReceiptIfNeededForNiceMessage:v53 service:v54 failureReason:v55 failureReasonMessage:valuea generateDeliveryReceipt:0];
    }
    if (objc_msgSend(*(id *)(a1 + 64), "_shouldReplyWithRemoteDecryptionErrorMessageForDecryptionErrorType:", v127, v99, v102, v104))
    {
      id v56 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
      id v57 = IDSGetUUIDData();
      if (v57) {
        CFDictionarySetValue(v56, IDSFailedUUIDKey, v57);
      }

      id v58 = *(const void **)(a1 + 88);
      if (v58) {
        CFDictionarySetValue(v56, IDSFailedMessageIDKey, v58);
      }
      long long v59 = +[NSNumber numberWithInteger:v127];
      if (v59) {
        CFDictionarySetValue(v56, IDSFailureReasonKey, v59);
      }

      if (valuea) {
        CFDictionarySetValue(v56, IDSFailureReasonMessageKey, valuea);
      }
      id v106 = [*(id *)(a1 + 32) command];
      uint64_t v60 = (id *)(a1 + 56);
      uint64_t v61 = [*(id *)(a1 + 56) rawToken];
      uint64_t v62 = [*(id *)(a1 + 48) prefixedURI];
      uint64_t v63 = (void *)_IDSCopyIDForTokenWithURI();

      uint64_t v65 = *(void **)(a1 + 64);
      uint64_t v64 = *(void *)(a1 + 72);
      uint64_t v66 = +[NSSet setWithObject:v63];
      uint64_t v67 = +[IDSDestination destinationWithStrings:v66];
      id v68 = [*(id *)(a1 + 120) uniqueID];
      id v69 = +[NSNumber numberWithInteger:120];
      v139[0] = _NSConcreteStackBlock;
      v139[1] = 3221225472;
      v139[2] = sub_1003A02B0;
      v139[3] = &unk_10098AB10;
      uint64_t v141 = v127;
      id v140 = *v60;
      LOBYTE(v103) = 1;
      [v65 _sendErrorMessage:v56 originalCommand:v106 fromURI:v64 toDestinations:v67 usingAccountWithUniqueID:v68 useDictAsTopLevel:1 dataToEncrypt:-1.0 wantsResponse:0 timeout:v103 command:v69 priority:300 completionBlock:v139];
    }
    ((void (*)(void))v115[2])();

    int v70 = v147;
  }
  else
  {
    if ([v123 usedLastResortCache]) {
      [*(id *)(a1 + 64) _submitLastResortCacheMetricForGUID:*(void *)(a1 + 88) service:*(void *)(a1 + 112)];
    }
    uint64_t v71 = [v121 _FTOptionallyDecompressData];
    JWDecodeDictionary();
    id v125 = (id)objc_claimAutoreleasedReturnValue();

    if (!v125)
    {
      JWDecodeDictionary();
      id v125 = (id)objc_claimAutoreleasedReturnValue();
    }
    id v72 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)uint64_t v149 = v125;
      _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "messageDictionary: %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      id v99 = v125;
      _IDSLogV();
    }
    valueb = objc_msgSend(v125, "_stringForKey:", @"mmcs-url", v99);
    uint64_t v128 = [v125 _stringForKey:@"mmcs-signature-hex"];
    CFStringRef v116 = [v125 _stringForKey:@"mmcs-owner"];
    if (v122)
    {
      id v73 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        *(void *)uint64_t v149 = v122;
        _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, "Gossip - EncryptedAttributes: %@", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        id v101 = v122;
        _IDSLogV();
      }
      uint64_t v74 = objc_msgSend(v122, "objectForKeyedSubscript:", NGMEncryptedAttributeKTGossipData, v101);

      if (v74)
      {
        uint64_t v75 = +[IDSKTGossipManager sharedInstance];
        id v76 = [v122 objectForKeyedSubscript:NGMEncryptedAttributeKTGossipData];
        [v75 sthReceivedFromGossipReceipient:v76];
      }
    }
    id v77 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)uint64_t v149 = v128;
      _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, " => Settled on signature: %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      id v101 = v128;
      _IDSLogV();
    }
    if (v128 && valueb && v116)
    {
      id v78 = +[NSFileManager defaultManager];
      uint64_t v79 = [v78 _randomTemporaryPathWithSuffix:0];

      id v80 = [objc_alloc((Class)IDSServiceProperties) initWithServiceIdentifier:*(void *)(a1 + 112)];
      id v113 = [v80 dataUsageBundleID];
      unsigned int v81 = -[IDSDaemon _IMTransferServiceController]_0();
      long long v82 = +[NSString stringGUID];
      uint64_t v83 = *(void *)(a1 + 112);
      long long v84 = [v128 _FTDataFromHexString];
      v129[0] = _NSConcreteStackBlock;
      v129[1] = 3221225472;
      v129[2] = sub_1003A08E4;
      v129[3] = &unk_10098ABA8;
      v129[4] = *(void *)(a1 + 64);
      id v130 = *(id *)(a1 + 32);
      id v131 = *(id *)(a1 + 112);
      id v132 = *(id *)(a1 + 48);
      id v133 = *(id *)(a1 + 104);
      id v136 = *(id *)(a1 + 128);
      id v134 = *(id *)(a1 + 88);
      id v135 = *(id *)(a1 + 96);
      [v81 receiveFileTransfer:v82 topic:v83 path:v79 requestURLString:valueb ownerID:v116 sourceAppID:v113 signature:v84 decryptionKey:0 fileSize:0 progressBlock:&stru_10098AB80 completionBlock:v129];
    }
    else
    {
      long long v85 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, " => Missing fields from dictionary, returning error", buf, 2u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        _IDSLogV();
      }
      objc_msgSend(*(id *)(a1 + 64), "_sendCertifiedDeliveryReceiptIfNeededForNiceMessage:service:failureReason:failureReasonMessage:generateDeliveryReceipt:", *(void *)(a1 + 32), *(void *)(a1 + 112), &off_1009D1F38, 0, 0, v101);
      uint64_t v79 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
      long long v86 = IDSGetUUIDData();
      if (v86) {
        CFDictionarySetValue(v79, IDSFailedUUIDKey, v86);
      }

      long long v87 = *(const void **)(a1 + 88);
      if (v87) {
        CFDictionarySetValue(v79, IDSFailedMessageIDKey, v87);
      }
      unsigned int v88 = +[NSNumber numberWithInt:400];
      if (v88) {
        CFDictionarySetValue(v79, IDSFailureReasonKey, v88);
      }

      id v80 = [*(id *)(a1 + 32) command];
      unsigned int v89 = [*(id *)(a1 + 56) rawToken];
      CFMutableDictionaryRef v90 = [*(id *)(a1 + 48) prefixedURI];
      id v113 = (void *)_IDSCopyIDForTokenWithURI();

      uint64_t v91 = *(void **)(a1 + 64);
      uint64_t v110 = *(void *)(a1 + 72);
      unsigned __int8 v92 = +[NSSet setWithObject:v113];
      uint64_t v93 = +[IDSDestination destinationWithStrings:v92];
      id v94 = [*(id *)(a1 + 120) uniqueID];
      uint64_t v95 = +[NSNumber numberWithInteger:120];
      v137[0] = _NSConcreteStackBlock;
      v137[1] = 3221225472;
      v137[2] = sub_1003A0538;
      v137[3] = &unk_100980FD8;
      id v138 = *(id *)(a1 + 56);
      LOBYTE(v102) = 1;
      [v91 _sendErrorMessage:v79 originalCommand:v80 fromURI:v110 toDestinations:v93 usingAccountWithUniqueID:v94 useDictAsTopLevel:1 dataToEncrypt:-1.0 wantsResponse:0 timeout:v102 command:v95 priority:300 completionBlock:v137];

      if (*(void *)(a1 + 128))
      {
        uint64_t v96 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
        __int16 v97 = [*(id *)(a1 + 32) rawMessage];
        if (v97)
        {
          CFDictionarySetValue(v96, IDSIncomingMessagePushPayloadKey, v97);
        }
        else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
        {
          sub_10071FD6C();
        }

        id v98 = *(const void **)(a1 + 96);
        if (v98) {
          CFDictionarySetValue(v96, IDSIncomingMessageOriginalEncryptionTypeKey, v98);
        }
        (*(void (**)(void))(*(void *)(a1 + 128) + 16))();
      }
    }

    int v70 = valueb;
  }
}

void sub_1003A01E8(uint64_t a1)
{
  if (*(void *)(a1 + 64))
  {
    uint64_t v2 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
    id v3 = [*(id *)(a1 + 32) rawMessage];
    if (v3)
    {
      CFDictionarySetValue(v2, IDSIncomingMessagePushPayloadKey, v3);
    }
    else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      sub_10071FD6C();
    }

    uint64_t v4 = *(const void **)(a1 + 40);
    if (v4) {
      CFDictionarySetValue(v2, IDSIncomingMessageOriginalEncryptionTypeKey, v4);
    }
    (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
  }
}

void sub_1003A02B0(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 lastCall])
  {
    if ([v3 idsResponseCode])
    {
      uint64_t v4 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = *(void *)(a1 + 40);
        CFStringRef v6 = [v3 responseError];
        uint64_t v7 = *(void *)(a1 + 32);
        *(_DWORD *)long long buf = 67109634;
        int v14 = v5;
        __int16 v15 = 2112;
        unint64_t v16 = v6;
        __int16 v17 = 2112;
        uint64_t v18 = v7;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "** Failed sending decryption error: %d %@ to token: %@", buf, 0x1Cu);
      }
      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
LABEL_12:
        uint64_t v12 = [v3 responseError];
        _IDSLogV();
      }
    }
    else
    {
      id v8 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = *(void *)(a1 + 40);
        unsigned __int8 v10 = [v3 responseError];
        uint64_t v11 = *(void *)(a1 + 32);
        *(_DWORD *)long long buf = 67109634;
        int v14 = v9;
        __int16 v15 = 2112;
        unint64_t v16 = v10;
        __int16 v17 = 2112;
        uint64_t v18 = v11;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Finished sending decryption error: %d %@ to token: %@", buf, 0x1Cu);
      }
      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        goto LABEL_12;
      }
    }
  }
}

void sub_1003A0504(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1003A046CLL);
  }
  _Unwind_Resume(a1);
}

void sub_1003A0538(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 lastCall])
  {
    if ([v3 idsResponseCode])
    {
      uint64_t v4 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = [v3 responseError];
        uint64_t v6 = *(void *)(a1 + 32);
        *(_DWORD *)long long buf = 67109634;
        int v12 = 400;
        __int16 v13 = 2112;
        int v14 = v5;
        __int16 v15 = 2112;
        uint64_t v16 = v6;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "** Failed sending download (bad field) error: %d %@ to token: %@", buf, 0x1Cu);
      }
      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
LABEL_12:
        unsigned __int8 v10 = [v3 responseError];
        _IDSLogV();
      }
    }
    else
    {
      uint64_t v7 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        id v8 = [v3 responseError];
        uint64_t v9 = *(void *)(a1 + 32);
        *(_DWORD *)long long buf = 67109634;
        int v12 = 400;
        __int16 v13 = 2112;
        int v14 = v8;
        __int16 v15 = 2112;
        uint64_t v16 = v9;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Finished sending download (bad field) error: %d %@ to token: %@", buf, 0x1Cu);
      }
      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        goto LABEL_12;
      }
    }
  }
}

void sub_1003A0784(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1003A06F0);
  }
  _Unwind_Resume(a1);
}

void sub_1003A07B8(id a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v7 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218496;
    unint64_t v9 = a2;
    __int16 v10 = 2048;
    unint64_t v11 = a3;
    __int16 v12 = 2048;
    unint64_t v13 = a4;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Attachment data download updated to %lld of %lld (%lld bps)", buf, 0x20u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLog()) {
      _IDSLogV();
    }
  }
}

void sub_1003A08E4(void *a1, void *a2, void *a3, int a4, void *a5, void *a6)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a5;
  id v14 = a6;
  if (a4)
  {
    __int16 v15 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "retrieved message data for incoming attachent message", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    uint64_t v16 = (void *)a1[4];
    uint64_t v17 = a1[5];
    uint64_t v18 = +[NSURL fileURLWithPath:v12];
    BOOL v19 = +[NSData dataWithContentsOfURL:v18 options:1 error:0];
    [v16 _optionallyDecryptNiceMessage:v17 encryptedData:v19 forGroupID:0 forTopic:a1[6] fromURI:a1[7] certifiedDeliveryContext:a1[8] completionBlock:a1[11]];
  }
  else
  {
    __int16 v20 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = a1[9];
      uint64_t v22 = a1[7];
      *(_DWORD *)long long buf = 138412802;
      uint64_t v26 = v21;
      __int16 v27 = 2112;
      uint64_t v28 = v22;
      __int16 v29 = 2112;
      id v30 = v13;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Failed to grab message data for message ID: %@ from: %@ error %@", buf, 0x20u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    uint64_t v18 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
    id v23 = [(id)a1[5] rawMessage];
    if (v23)
    {
      CFDictionarySetValue(v18, IDSIncomingMessagePushPayloadKey, v23);
    }
    else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      sub_10071FD6C();
    }

    unsigned __int8 v24 = (const void *)a1[10];
    if (v24) {
      CFDictionarySetValue(v18, IDSIncomingMessageOriginalEncryptionTypeKey, v24);
    }
    (*(void (**)(void, __CFDictionary *, void))(a1[11] + 16))(a1[11], v18, 0);
  }
}

uint64_t sub_1003A0DB0(uint64_t a1)
{
  pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 32) + 304));
  --*(void *)(*(void *)(a1 + 32) + 368);
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(void *)(v2 + 368))
  {
    id v3 = *(void **)(v2 + 376);
    *(void *)(v2 + 376) = 0;

    uint64_t v2 = *(void *)(a1 + 32);
  }

  return pthread_mutex_unlock((pthread_mutex_t *)(v2 + 304));
}

void sub_1003A30F4(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = (__CFDictionary *)[objc_alloc((Class)NSMutableDictionary) initWithCapacity:2];
  uint64_t v5 = (const void *)a1[4];
  CFMutableDictionaryRef theDict = v4;
  if (v5) {
    CFDictionarySetValue(v4, IDSOriginalCommandKey, v5);
  }
  uint64_t v6 = (const void *)a1[5];
  if (v6) {
    CFDictionarySetValue(theDict, IDSIncomingMessagePushPayloadKey, v6);
  }
  uint64_t v8 = a1[5];
  uint64_t v7 = a1[6];
  uint64_t v9 = a1[7];
  __int16 v10 = +[IDSURI URIWithPrefixedURI:a1[8]];
  id v11 = +[IDSURI URIWithPrefixedURI:a1[9]];
  [v3 messageReceived:theDict withGUID:v7 withPayload:v8 forTopic:v9 toURI:v10 fromURI:v11 context:a1[10]];
}

void sub_1003A3208(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 56);
  id v7 = a2;
  uint64_t v8 = +[IDSURI URIWithPrefixedURI:v6];
  uint64_t v9 = +[IDSURI URIWithPrefixedURI:*(void *)(a1 + 64)];
  [v7 protobufReceived:v3 withGUID:v4 forTopic:v5 toURI:v8 fromURI:v9 context:*(void *)(a1 + 72)];

  if ([*(id *)(a1 + 48) hasPrefix:@"com.apple.private.alloy.continuity"])
  {
    id v10 = [*(id *)(a1 + 72) objectForKey:IDSMessageContextSequenceNumberKey];
    [v10 unsignedIntegerValue];
    kdebug_trace();
  }
}

void sub_1003A3334(void *a1, void *a2)
{
  uint64_t v3 = a1[4];
  uint64_t v4 = a1[5];
  uint64_t v5 = a1[6];
  uint64_t v6 = a1[7];
  id v7 = a2;
  id v9 = +[IDSURI URIWithPrefixedURI:v6];
  uint64_t v8 = +[IDSURI URIWithPrefixedURI:a1[8]];
  [v7 dataReceived:v3 withGUID:v4 forTopic:v5 toURI:v9 fromURI:v8 context:a1[9]];
}

void sub_1003A33F0(void *a1, void *a2)
{
  uint64_t v3 = a1[4];
  uint64_t v4 = a1[5];
  uint64_t v5 = a1[6];
  uint64_t v6 = a1[7];
  id v7 = a2;
  id v9 = +[IDSURI URIWithPrefixedURI:v6];
  uint64_t v8 = +[IDSURI URIWithPrefixedURI:a1[8]];
  [v7 dataReceived:v3 withGUID:v4 forTopic:v5 toURI:v9 fromURI:v8 context:a1[9]];
}

void sub_1003A34AC(uint64_t a1, void *a2)
{
  id v42 = a2;
  uint64_t v2 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(__CFDictionary **)(a1 + 32);
    *(_DWORD *)long long buf = 138412290;
    uint64_t v55 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "The Account Was %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      uint64_t v40 = *(void *)(a1 + 32);
      _IDSLogTransport();
      if (_IDSShouldLog())
      {
        uint64_t v40 = *(void *)(a1 + 32);
        _IDSLogV();
      }
    }
  }
  uint64_t v4 = +[IDSDAccountController sharedInstance];
  uint64_t v5 = [v4 accountsOnService:*(void *)(a1 + 40) withType:0];
  uint64_t v46 = [v5 firstObject];

  uint64_t v6 = [*(id *)(a1 + 48) objectForKey:@"dd"];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v7 = [*(id *)(a1 + 48) objectForKey:@"dd"];
    id value = +[NSData _IDSDataFromBase64String:v7];
  }
  else
  {
    id v7 = [*(id *)(a1 + 48) objectForKey:@"dd"];
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      id value = [*(id *)(a1 + 48) objectForKey:@"dd"];
    }
    else
    {
      id value = 0;
    }
  }

  uint64_t v8 = objc_opt_class();
  int v43 = sub_1002B4B18(v8, *(void **)(a1 + 48), @"U");
  id v9 = JWDecodeDictionary();
  CFMutableDictionaryRef theDict = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
  if (value) {
    CFDictionarySetValue(theDict, IDSIncomingMessageDecryptedDataKey, value);
  }
  CFDictionarySetValue(theDict, IDSIncomingMessageOriginalEncryptionTypeKey, @"pair");
  if ([v46 accountType] == 1)
  {
    id v10 = [v46 primaryRegistration];
    id v11 = [v10 dsHandle];
    uint64_t v44 = [v11 _stripFZIDPrefix];

    [*(id *)(a1 + 40) shouldRegisterUsingDSHandle];
    id v12 = [*(id *)(a1 + 40) identifier];
    _IDSPrefersPhoneNumbersForServiceIdentifier();

    id v13 = [v46 unprefixedURIStringsFromRegistration];
    id v14 = [v46 pseudonyms];
    __int16 v15 = (void *)_IDSCopyCallerIDWithPseudonyms();
    uint64_t v16 = [v15 _bestGuessURI];
  }
  else
  {
    uint64_t v44 = [v46 accountInfo];
    long long v51 = 0u;
    long long v52 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    uint64_t v17 = [v44 objectForKeyedSubscript:kIDSServiceDefaultsVettedAliasesKey];
    id v18 = [v17 countByEnumeratingWithState:&v49 objects:v53 count:16];
    if (v18)
    {
      uint64_t v19 = *(void *)v50;
LABEL_18:
      uint64_t v20 = 0;
      while (1)
      {
        if (*(void *)v50 != v19) {
          objc_enumerationMutation(v17);
        }
        uint64_t v21 = [v9 objectForKey:@"p"];
        uint64_t v22 = (void *)_IDSCopyIDForPhoneNumberWithOptions();
        unsigned __int8 v23 = [v21 containsObject:v22];

        if (v23) {
          break;
        }
        if (v18 == (id)++v20)
        {
          id v18 = [v17 countByEnumeratingWithState:&v49 objects:v53 count:16];
          if (v18) {
            goto LABEL_18;
          }
          goto LABEL_24;
        }
      }
      uint64_t v16 = (void *)_IDSCopyIDForPhoneNumberWithOptions();

      if (v16) {
        goto LABEL_28;
      }
    }
    else
    {
LABEL_24:
    }
    id v13 = [v46 loginID];
    uint64_t v16 = (void *)_IDSCopyIDForPhoneNumberWithOptions();
  }

LABEL_28:
  unsigned __int8 v24 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
  id v25 = v24;
  uint64_t v26 = *(const void **)(a1 + 56);
  if (v26) {
    CFDictionarySetValue(v24, IDSCommandKey, v26);
  }
  __int16 v27 = IDSGetUUIDData();
  if (v27) {
    CFDictionarySetValue(v25, IDSUUIDKey, v27);
  }

  if (v16)
  {
    CFDictionarySetValue(v25, IDSSenderIDKey, v16);
    CFDictionarySetValue(v25, IDSReceiverIDKey, v16);
  }
  uint64_t v28 = +[IDSPairingManager sharedInstance];
  __int16 v29 = [v28 pairedDevicePushToken];

  if (v29) {
    CFDictionarySetValue(v25, IDSTokenKey, v29);
  }

  id v30 = [v9 objectForKey:@"p"];

  if (v30)
  {
    unsigned __int8 v31 = [v9 objectForKey:@"p"];
    if (v31) {
      CFDictionarySetValue(v25, @"p", v31);
    }
  }
  uint64_t v32 = (const void *)IDSDeliveryStatusContextKey;
  uint64_t v33 = [v9 objectForKey:IDSDeliveryStatusContextKey];

  if (v33)
  {
    uint64_t v34 = [v9 objectForKey:v32];
    if (v34) {
      CFDictionarySetValue(v25, v32, v34);
    }
  }
  if (v25) {
    CFDictionarySetValue(theDict, IDSIncomingMessagePushPayloadKey, v25);
  }
  int v35 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    uint64_t v55 = theDict;
    _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "The message that will be broadcast is %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      uint64_t v41 = theDict;
      _IDSLogTransport();
      if (_IDSShouldLog())
      {
        uint64_t v41 = theDict;
        _IDSLogV();
      }
    }
  }
  uint64_t v37 = *(void *)(a1 + 64);
  uint64_t v36 = *(void *)(a1 + 72);
  uint64_t v38 = +[IDSURI URIWithPrefixedURI:](IDSURI, "URIWithPrefixedURI:", *(void *)(a1 + 80), v41);
  __int16 v39 = +[IDSURI URIWithPrefixedURI:*(void *)(a1 + 88)];
  [v42 messageReceived:theDict withGUID:v37 withPayload:v25 forTopic:v36 toURI:v38 fromURI:v39 context:*(void *)(a1 + 96)];
}

void sub_1003A3CD4(void *a1, void *a2)
{
  uint64_t v3 = a1[4];
  uint64_t v4 = a1[5];
  uint64_t v5 = a1[6];
  id v6 = a2;
  id v7 = +[IDSURI URIWithPrefixedURI:v5];
  [v6 messageIdentifier:v3 forTopic:v4 toURI:v7 fromURI:0 hasBeenDeliveredWithContext:a1[7]];
}

void sub_1003A3D6C(id a1, NSArray *a2, NSArray *a3, NSDictionary *a4)
{
  id v6 = a2;
  id v7 = a3;
  uint64_t v8 = a4;
  id v9 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v10 = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Will Send Block After Send", v10, 2u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
}

void sub_1003A3E64(id a1, IDSDeliveryContext *a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Message Send After Transposing", v4, 2u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
}

void sub_1003A3F34(void *a1, void *a2)
{
  uint64_t v3 = a1[4];
  uint64_t v4 = a1[5];
  uint64_t v5 = a1[6];
  uint64_t v6 = a1[7];
  uint64_t v7 = a1[8];
  id v8 = a2;
  id v10 = +[IDSURI URIWithPrefixedURI:v7];
  id v9 = +[IDSURI URIWithPrefixedURI:a1[9]];
  [v8 messageReceived:v3 withGUID:v4 withPayload:v5 forTopic:v6 toURI:v10 fromURI:v9 context:a1[10]];
}

void sub_1003A4004(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = (__CFDictionary *)[objc_alloc((Class)NSMutableDictionary) initWithCapacity:2];
  uint64_t v5 = (const void *)a1[4];
  CFMutableDictionaryRef theDict = v4;
  if (v5) {
    CFDictionarySetValue(v4, IDSOriginalCommandKey, v5);
  }
  uint64_t v6 = (const void *)a1[5];
  if (v6) {
    CFDictionarySetValue(theDict, IDSIncomingMessagePushPayloadKey, v6);
  }
  uint64_t v8 = a1[5];
  uint64_t v7 = a1[6];
  uint64_t v9 = a1[7];
  uint64_t v10 = a1[8];
  id v11 = +[IDSURI URIWithPrefixedURI:a1[9]];
  id v12 = +[IDSURI URIWithPrefixedURI:a1[10]];
  [v3 messageReceived:v7 withGUID:v9 withPayload:v8 forTopic:v10 toURI:v11 fromURI:v12 context:a1[11]];
}

void sub_1003A411C(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = a1[4];
    uint64_t v6 = a1[5];
    uint64_t v7 = a1[6];
    uint64_t v8 = a1[7];
    uint64_t v9 = a1[8];
    *(_DWORD *)long long buf = 138413314;
    uint64_t v19 = v5;
    __int16 v20 = 2112;
    uint64_t v21 = v6;
    __int16 v22 = 2112;
    uint64_t v23 = v7;
    __int16 v24 = 2112;
    uint64_t v25 = v8;
    __int16 v26 = 2112;
    uint64_t v27 = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "PROXY BROADCASTING BLOCK %@ Guid %@ Topic %@ ToID %@ fromID %@", buf, 0x34u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v17 = a1[8];
    long long v15 = *((_OWORD *)a1 + 2);
    long long v16 = *((_OWORD *)a1 + 3);
    _IDSLogV();
  }
  uint64_t v10 = a1[4];
  uint64_t v11 = a1[5];
  uint64_t v12 = a1[6];
  id v13 = +[IDSURI URIWithPrefixedURI:](IDSURI, "URIWithPrefixedURI:", a1[7], v15, v16, v17);
  id v14 = +[IDSURI URIWithPrefixedURI:a1[8]];
  [v3 dataReceived:v10 withGUID:v11 forTopic:v12 toURI:v13 fromURI:v14 context:a1[9]];
}

void sub_1003A42D8(void *a1, void *a2)
{
  id v3 = a2;
  JWDecodeDictionary();
  id v8 = (id)objc_claimAutoreleasedReturnValue();
  uint64_t v4 = a1[5];
  uint64_t v5 = a1[6];
  uint64_t v6 = +[IDSURI URIWithPrefixedURI:a1[7]];
  uint64_t v7 = +[IDSURI URIWithPrefixedURI:a1[8]];
  [v3 protobufReceived:v8 withGUID:v4 forTopic:v5 toURI:v6 fromURI:v7 context:a1[9]];
}

id sub_1003A439C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = +[IDSDaemonPriorityQueueController sharedInstance];
  uint64_t v5 = objc_msgSend(v4, "queueForPriority:", (int)objc_msgSend(*(id *)(a1 + 48), "intValue"));
  [v2 getLocalIncomingPowerAssertion:v3 queue:v5];

  return [*(id *)(a1 + 32) enqueueIncomingMessageBroadcast:*(void *)(a1 + 88) broadcastData:*(void *)(a1 + 56) forTopic:*(void *)(a1 + 64) entitlement:kIDSMessagingEntitlement command:*(void *)(a1 + 72) capabilities:*(unsigned int *)(a1 + 96) messageContext:*(void *)(a1 + 80)];
}

id sub_1003A4448(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = im_primary_queue();
  [v2 getLocalIncomingPowerAssertion:v3 queue:v4];

  return [*(id *)(a1 + 32) enqueueIncomingMessageBroadcast:*(void *)(a1 + 80) broadcastData:*(void *)(a1 + 48) forTopic:*(void *)(a1 + 56) entitlement:kIDSMessagingEntitlement command:*(void *)(a1 + 64) capabilities:*(unsigned int *)(a1 + 88) messageContext:*(void *)(a1 + 72)];
}

void sub_1003A4ED4(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1003A4D74);
  }
  _Unwind_Resume(a1);
}

void sub_1003A60DC(uint64_t a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  JUMPOUT(0x1003A60E8);
}

int64_t sub_1003A60F0(id a1, IDSDIncomingMessage *a2, IDSDIncomingMessage *a3)
{
  uint64_t v4 = a3;
  uint64_t v5 = [(IDSDIncomingMessage *)a2 message];
  uint64_t v6 = [v5 objectForKey:@"e"];

  uint64_t v7 = [(IDSDIncomingMessage *)v4 message];

  id v8 = [v7 objectForKey:@"e"];

  if (v6 && v8)
  {
    int64_t v9 = (int64_t)[v6 compare:v8];
  }
  else if (v6 || !v8)
  {
    if (v6) {
      BOOL v10 = v8 == 0;
    }
    else {
      BOOL v10 = 0;
    }
    if (v10) {
      int64_t v9 = -1;
    }
    else {
      int64_t v9 = 0;
    }
  }
  else
  {
    int64_t v9 = 1;
  }

  return v9;
}

id sub_1003A61C0(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _processStoredIncomingRemoteMessagesWithGUIDs:*(void *)(a1 + 40) ignoringGUIDs:*(void *)(a1 + 48) controlCategory:*(unsigned int *)(a1 + 64) lastTimeInterval:1 repeatedAttempt:*(double *)(a1 + 56)];
}

id sub_1003A61DC(uint64_t a1)
{
  id v1 = *(void **)(a1 + 32);
  id v2 = [*(id *)(a1 + 40) unsignedIntValue];

  return _[v1 _processStoredIncomingRemoteMessagesWithGUIDs:0 ignoringGUIDs:0 controlCategory:v2 lastTimeInterval:0 repeatedAttempt:0.0];
}

void sub_1003A639C(uint64_t a1)
{
  id v2 = +[IDSPairingManager sharedInstance];
  uint64_t v3 = [v2 pairedDeviceUniqueID];

  uint64_t v4 = +[IDSDMessageStore unsentOutgoingMessagesUpToLimit:10000 priority:*(void *)(a1 + 56) wantsPayload:0 localDestinationDeviceID:v3];
  id v5 = objc_alloc_init((Class)IMMessageContext);
  [v5 setShouldBoost:*(void *)(a1 + 56) == 300];
  uint64_t v6 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v7 = (const __CFString *)[v4 count];
    uint64_t v8 = *(void *)(a1 + 56);
    CFStringRef v9 = @"Sync";
    if (v8 == 200) {
      CFStringRef v9 = @"Default";
    }
    if (v8 == 300) {
      CFStringRef v10 = @"URGENT";
    }
    else {
      CFStringRef v10 = v9;
    }
    *(_DWORD *)long long buf = 134218242;
    CFStringRef v37 = v7;
    __int16 v38 = 2112;
    CFStringRef v39 = v10;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Processing stored %lu outgoing messages due to unpairing. Priority %@", buf, 0x16u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    id v11 = [v4 count];
    uint64_t v12 = *(void *)(a1 + 56);
    CFStringRef v13 = @"Sync";
    if (v12 == 200) {
      CFStringRef v13 = @"Default";
    }
    if (v12 == 300) {
      CFStringRef v14 = @"URGENT";
    }
    else {
      CFStringRef v14 = v13;
    }
    id v26 = v11;
    CFStringRef v27 = v14;
    _IDSLogV();
  }
  long long v15 = +[IDSDaemonPriorityQueueController sharedInstance];
  v28[0] = _NSConcreteStackBlock;
  v28[1] = 3221225472;
  v28[2] = sub_1003A676C;
  v28[3] = &unk_10098AD68;
  id v16 = v4;
  id v29 = v16;
  id v17 = *(id *)(a1 + 32);
  uint64_t v18 = *(void *)(a1 + 40);
  uint64_t v19 = *(void **)(a1 + 48);
  id v30 = v17;
  uint64_t v31 = v18;
  uint64_t v34 = *(void *)(a1 + 64);
  id v32 = v19;
  id v20 = v5;
  uint64_t v21 = *(void *)(a1 + 56);
  id v33 = v20;
  uint64_t v35 = v21;
  [v15 performBlockMainQueue:v28];

  __int16 v22 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v23 = *(void *)(a1 + 56);
    CFStringRef v24 = @"Sync";
    if (v23 == 200) {
      CFStringRef v24 = @"Default";
    }
    if (v23 == 300) {
      CFStringRef v25 = @"URGENT";
    }
    else {
      CFStringRef v25 = v24;
    }
    *(_DWORD *)long long buf = 138412290;
    CFStringRef v37 = v25;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Finished processing stored outgoing messages due to unpairing. Priority %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
}

void sub_1003A676C(uint64_t a1)
{
  id v31 = objc_alloc_init((Class)NSMutableArray);
  id v32 = objc_alloc_init((Class)NSMutableArray);
  long long v42 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  uint64_t v34 = a1;
  id obj = *(id *)(a1 + 32);
  id v2 = [obj countByEnumeratingWithState:&v42 objects:v48 count:16];
  if (v2)
  {
    uint64_t v3 = *(void *)v43;
    do
    {
      for (uint64_t i = 0; i != v2; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v43 != v3) {
          objc_enumerationMutation(obj);
        }
        id v5 = *(void **)(*((void *)&v42 + 1) + 8 * i);
        CFStringRef v7 = +[IDSDAccountController sharedInstance];
        uint64_t v8 = [v5 accountGUID];
        CFStringRef v9 = [v7 accountWithUniqueID:v8];

        if (v9)
        {
          CFStringRef v10 = [v9 service];
          if ([v10 adHocServiceType] != 2)
          {
            id v11 = [v9 service];
            BOOL v12 = [v11 adHocServiceType] == 5;

LABEL_14:
            goto LABEL_15;
          }
LABEL_13:
          BOOL v12 = 1;
          goto LABEL_14;
        }
        CFStringRef v13 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v14 = [v5 accountGUID];
          *(_DWORD *)long long buf = 138412290;
          uint64_t v47 = v14;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Found stored outgoing message from account with guid %@ which no longer exists or is not local type.", buf, 0xCu);
        }
        if (os_log_shim_legacy_logging_enabled())
        {
          id v29 = [v5 accountGUID];
          _IDSWarnV();

          id v30 = objc_msgSend(v5, "accountGUID", v29);
          _IDSLogV();

          CFStringRef v10 = objc_msgSend(v5, "accountGUID", v30);
          _IDSLogTransport();
          goto LABEL_13;
        }
        BOOL v12 = 1;
LABEL_15:
        uint64_t v15 = *(void *)(v34 + 40);
        if (v15)
        {
          id v16 = [v9 service];
          id v17 = [v16 allowedTrafficClasses];
          LOBYTE(v15) = _IDSIsTrafficAllowed();
        }
        if (v12 && (v15 & 1) == 0)
        {
          uint64_t v18 = [v9 service];
          uint64_t v19 = [v18 pushTopic];

          if (v19)
          {
            id v20 = [v9 service];
            uint64_t v21 = [v20 pushTopic];
            __int16 v22 = +[IMPair pairWithFirst:v21 second:v5];

            [v32 addObject:v22];
          }
          else
          {
            [v31 addObject:v5];
          }
        }
      }
      id v2 = [obj countByEnumeratingWithState:&v42 objects:v48 count:16];
    }
    while (v2);
  }

  uint64_t v23 = +[IDSDaemonPriorityQueueController sharedInstance];
  v35[0] = _NSConcreteStackBlock;
  v35[1] = 3221225472;
  v35[2] = sub_1003A6C20;
  v35[3] = &unk_100984C50;
  id v36 = v31;
  id v37 = v32;
  uint64_t v24 = *(void *)(v34 + 72);
  CFStringRef v25 = *(void **)(v34 + 56);
  uint64_t v38 = *(void *)(v34 + 48);
  uint64_t v41 = v24;
  id v39 = v25;
  id v40 = *(id *)(v34 + 64);
  uint64_t v26 = *(void *)(v34 + 80);
  id v27 = v32;
  id v28 = v31;
  [v23 performBlockWithPriority:v35 priority:v26];
}

void sub_1003A6C20(uint64_t a1)
{
  long long v40 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v40 objects:v45 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v41;
    do
    {
      for (uint64_t i = 0; i != v4; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v41 != v5) {
          objc_enumerationMutation(v2);
        }
        CFStringRef v7 = *(void **)(*((void *)&v40 + 1) + 8 * i);
        uint64_t v8 = [v7 guid];
        CFStringRef v9 = [v7 alternateGUID];
        +[IDSDMessageStore deleteOutgoingMessageWithGUID:v8 alternateGUID:v9];
      }
      id v4 = [v2 countByEnumeratingWithState:&v40 objects:v45 count:16];
    }
    while (v4);
  }

  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  id obj = *(id *)(a1 + 40);
  id v10 = [obj countByEnumeratingWithState:&v36 objects:v44 count:16];
  if (v10)
  {
    id v11 = v10;
    uint64_t v30 = *(void *)v37;
    key = (void *)IDSMessageContextServiceIdentifierKey;
    id v27 = (void *)IDSMessageContextOriginalDestinationDeviceKey;
    uint64_t v29 = kIDSMessagingEntitlement;
    uint64_t v12 = kIDSListenerCapConsumesLaunchOnDemandOutgoingMessageUpdates;
    do
    {
      for (j = 0; j != v11; j = (char *)j + 1)
      {
        if (*(void *)v37 != v30) {
          objc_enumerationMutation(obj);
        }
        CFStringRef v14 = *(void **)(*((void *)&v36 + 1) + 8 * (void)j);
        uint64_t v15 = [v14 first];
        id v16 = [v14 second];
        id v17 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
        uint64_t v18 = v17;
        if (v15) {
          CFDictionarySetValue(v17, key, v15);
        }
        uint64_t v19 = [v16 localDestinationDeviceUUID];
        if (v19) {
          CFDictionarySetValue(v18, v27, v19);
        }

        v31[0] = _NSConcreteStackBlock;
        v31[1] = 3221225472;
        v31[2] = sub_1003A6FA0;
        v31[3] = &unk_10098AD40;
        uint64_t v35 = *(void *)(a1 + 72);
        id v20 = *(void **)(a1 + 48);
        id v32 = *(id *)(a1 + 56);
        id v33 = v16;
        uint64_t v34 = v18;
        uint64_t v21 = *(void *)(a1 + 64);
        __int16 v22 = v18;
        id v23 = v16;
        [v20 enqueueBroadcast:v31 forTopic:v15 entitlement:v29 command:0 capabilities:v12 messageContext:v21];
        uint64_t v24 = [v23 guid];
        CFStringRef v25 = [v23 alternateGUID];
        +[IDSDMessageStore deleteOutgoingMessageWithGUID:v24 alternateGUID:v25];
      }
      id v11 = [obj countByEnumeratingWithState:&v36 objects:v44 count:16];
    }
    while (v11);
  }
}

void sub_1003A6FA0(uint64_t a1, void *a2)
{
  id v10 = a2;
  uint64_t v3 = IDSSendErrorDomain;
  uint64_t v4 = *(void *)(a1 + 56);
  uint64_t v5 = +[NSDictionary dictionaryWithObject:*(void *)(a1 + 32) forKey:@"Reason"];
  uint64_t v6 = +[NSError errorWithDomain:v3 code:v4 userInfo:v5];

  if (v10)
  {
    CFStringRef v7 = [*(id *)(a1 + 40) guid];
    uint64_t v8 = [*(id *)(a1 + 40) alternateGUID];
    CFStringRef v9 = [*(id *)(a1 + 40) mainAccountGuid];
    objc_msgSend(v10, "messageIdentifier:alternateCallbackID:forAccount:updatedWithResponseCode:error:lastCall:context:", v7, v8, v9, objc_msgSend(v6, "code"), v6, 1, *(void *)(a1 + 48));
  }
}

void sub_1003A8038(_Unwind_Exception *exc_buf, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(exc_buf);
    objc_end_catch();
    JUMPOUT(0x1003A7548);
  }
  _Unwind_Resume(exc_buf);
}

void sub_1003A809C(id *a1, void *a2)
{
  id v3 = a2;
  if ([v3 lastCall])
  {
    if (!a1[4])
    {
      uint64_t v19 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        id v20 = [a1[6] guid];
        unsigned int v21 = [v3 lastCall];
        CFStringRef v22 = @"NO";
        if (v21) {
          CFStringRef v22 = @"YES";
        }
        *(_DWORD *)long long buf = 138412546;
        id v37 = v20;
        __int16 v38 = 2112;
        CFStringRef v39 = v22;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Deleting sent outgoing urgent message with guid %@? %@", buf, 0x16u);
      }
      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        id v23 = [a1[6] guid];
        unsigned int v24 = [v3 lastCall];
        CFStringRef v25 = @"NO";
        if (v24) {
          CFStringRef v25 = @"YES";
        }
        id v29 = v23;
        CFStringRef v30 = v25;
        _IDSLogV();
      }
      goto LABEL_21;
    }
    uint64_t v4 = [a1[5] serviceController];
    uint64_t v5 = [v4 serviceWithPushTopic:a1[4]];
    unsigned int v6 = [v5 shouldSilentlyFailMessagesOnSwitch];

    CFStringRef v7 = [v3 responseError];
    if ([v7 code] != (id)24) {
      unsigned int v6 = 0;
    }

    if (v6 != 1)
    {
      v31[0] = _NSConcreteStackBlock;
      v31[1] = 3221225472;
      v31[2] = sub_1003A85CC;
      v31[3] = &unk_100981B50;
      id v26 = a1[5];
      id v32 = a1[4];
      id v33 = a1[7];
      id v27 = v3;
      id v28 = a1[6];
      id v34 = v27;
      id v35 = v28;
      [v26 enqueueBroadcast:v31 forTopic:a1[4] entitlement:kIDSMessagingEntitlement command:0 capabilities:kIDSListenerCapConsumesLaunchOnDemandOutgoingMessageUpdates messageContext:0];

      id v17 = v32;
      goto LABEL_33;
    }
    uint64_t v8 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      id v9 = a1[4];
      *(_DWORD *)long long buf = 138412290;
      id v37 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Silently failing %@ messages due to watch switch", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      id v29 = a1[4];
      _IDSLogV();
    }
    if (objc_msgSend(v3, "lastCall", v29))
    {
      id v10 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        id v11 = [a1[6] guid];
        unsigned int v12 = [v3 lastCall];
        CFStringRef v13 = @"NO";
        if (v12) {
          CFStringRef v13 = @"YES";
        }
        *(_DWORD *)long long buf = 138412546;
        id v37 = v11;
        __int16 v38 = 2112;
        CFStringRef v39 = v13;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Deleting sent outgoing urgent message with guid %@? %@", buf, 0x16u);
      }
      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        CFStringRef v14 = [a1[6] guid];
        unsigned int v15 = [v3 lastCall];
        CFStringRef v16 = @"NO";
        if (v15) {
          CFStringRef v16 = @"YES";
        }
        id v29 = v14;
        CFStringRef v30 = v16;
        _IDSLogV();
      }
LABEL_21:
      id v17 = objc_msgSend(a1[6], "guid", v29, v30);
      uint64_t v18 = [a1[6] alternateGUID];
      +[IDSDMessageStore deleteOutgoingMessageWithGUID:v17 alternateGUID:v18];

LABEL_33:
    }
  }
}

void sub_1003A85CC(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
  uint64_t v5 = v4;
  unsigned int v6 = *(const void **)(a1 + 32);
  if (v6) {
    CFDictionarySetValue(v4, IDSMessageContextServiceIdentifierKey, v6);
  }
  CFStringRef v7 = [*(id *)(a1 + 40) localDestinationDeviceUUID];
  if (v7) {
    CFDictionarySetValue(v5, IDSMessageContextOriginalDestinationDeviceKey, v7);
  }

  uint64_t v8 = [*(id *)(a1 + 40) command];
  if (v8) {
    CFDictionarySetValue(v5, IDSMessageContextOriginalCommandKey, v8);
  }

  id v9 = [*(id *)(a1 + 48) responseTimeStamp];
  if (v9) {
    CFDictionarySetValue(v5, IDSMessageContextServerTimestampKey, v9);
  }

  if (v3)
  {
    id v10 = [*(id *)(a1 + 40) identifier];
    id v11 = [*(id *)(a1 + 40) alternateCallbackID];
    unsigned int v12 = [*(id *)(a1 + 40) mainAccountUUID];
    id v13 = [*(id *)(a1 + 48) idsResponseCode];
    CFStringRef v14 = [*(id *)(a1 + 48) responseError];
    objc_msgSend(v3, "messageIdentifier:alternateCallbackID:forAccount:updatedWithResponseCode:error:lastCall:context:", v10, v11, v12, v13, v14, objc_msgSend(*(id *)(a1 + 48), "lastCall"), v5);
  }
  if ([*(id *)(a1 + 48) lastCall])
  {
    unsigned int v15 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      id v16 = [*(id *)(a1 + 56) guid];
      unsigned int v17 = [*(id *)(a1 + 48) lastCall];
      CFStringRef v18 = @"NO";
      if (v17) {
        CFStringRef v18 = @"YES";
      }
      *(_DWORD *)long long buf = 138412546;
      id v27 = v16;
      __int16 v28 = 2112;
      CFStringRef v29 = v18;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Deleting sent outgoing urgent message with guid %@? %@", buf, 0x16u);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      uint64_t v19 = [*(id *)(a1 + 56) guid];
      unsigned int v20 = [*(id *)(a1 + 48) lastCall];
      CFStringRef v21 = @"NO";
      if (v20) {
        CFStringRef v21 = @"YES";
      }
      unsigned int v24 = v19;
      CFStringRef v25 = v21;
      _IDSLogV();
    }
    CFStringRef v22 = objc_msgSend(*(id *)(a1 + 56), "guid", v24, v25);
    id v23 = [*(id *)(a1 + 56) alternateGUID];
    +[IDSDMessageStore deleteOutgoingMessageWithGUID:v22 alternateGUID:v23];
  }
}

void sub_1003A891C(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    id v2 = [objc_alloc((Class)IDSDeliveryContext) initWithResponseCode:10 error:0 lastCall:1];
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

void sub_1003A89A4(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    id v2 = [objc_alloc((Class)IDSDeliveryContext) initWithResponseCode:10 error:0 lastCall:1];
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

void sub_1003A9978(uint64_t a1, void *a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_1003A9A34;
  v5[3] = &unk_10098ADE0;
  id v6 = a2;
  uint64_t v3 = *(void *)(a1 + 32);
  id v7 = *(id *)(a1 + 40);
  char v8 = *(unsigned char *)(a1 + 48);
  id v4 = v6;
  [v4 fetchGroupWithGroupID:v3 completion:v5];
}

void sub_1003A9A34(uint64_t a1, void *a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_1003A9AF4;
  v5[3] = &unk_10098ADB8;
  id v6 = a2;
  uint64_t v3 = *(void **)(a1 + 32);
  id v7 = *(id *)(a1 + 40);
  char v8 = *(unsigned char *)(a1 + 48);
  id v4 = v6;
  [v3 _noteDecryptionFailureForGroup:v4 completion:v5];
}

void sub_1003A9AF4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    *(_DWORD *)long long buf = 138412546;
    uint64_t v7 = v5;
    __int16 v8 = 2112;
    id v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Noted decryption failure for engram group {group: %@, noteError: %@}", buf, 0x16u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  (*(void (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), 0);
}

void sub_1003A9F08(id a1)
{
  uint64_t v1 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", &off_1009D1FB0, &off_1009D1FC8, &off_1009D1FE0, &off_1009D1FF8, &off_1009D2010, &off_1009D2028, &off_1009D2040, 0);
  uint64_t v2 = qword_100A4C8B8;
  qword_100A4C8B8 = v1;

  _objc_release_x1(v1, v2);
}

void sub_1003AA018(id a1)
{
  uint64_t v1 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", &off_1009D2058, &off_1009D2070, &off_1009D2088, &off_1009D20A0, &off_1009D20B8, &off_1009D20D0, &off_1009D20E8, 0);
  uint64_t v2 = qword_100A4C8C8;
  qword_100A4C8C8 = v1;

  _objc_release_x1(v1, v2);
}

void sub_1003AAE94(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1003AABDCLL);
  }
  _Unwind_Resume(a1);
}

void *sub_1003AAFDC(void *result, void *a2)
{
  if (a2) {
    return [a2 messageIdentifier:result[4] forTopic:result[5] toURI:result[6] fromURI:result[7] hasBeenDeliveredWithContext:result[8]];
  }
  return result;
}

void sub_1003AE7E4(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) senderKeyDistributionManager];
  [v2 markLastActivePeerToken:*(void *)(a1 + 40) localURI:*(void *)(a1 + 48) remoteURI:*(void *)(a1 + 56)];
}

void sub_1003AE83C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = [v3 idsResponseCode];
    uint64_t v6 = *(void *)(a1 + 32);
    *(_DWORD *)long long buf = 134218242;
    id v8 = v5;
    __int16 v9 = 2112;
    uint64_t v10 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Sent certified delivery receipt for filtered message { success: %ld, context: %@ }", buf, 0x16u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    [v3 idsResponseCode];
    _IDSLogV();
  }
}

void sub_1003AE97C(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  uint64_t v6 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a1 + 32);
    uint64_t v8 = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 138412802;
    id v86 = v5;
    __int16 v87 = 2112;
    uint64_t v88 = v7;
    __int16 v89 = 2112;
    uint64_t v90 = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Broadcasting the receipt of message %@  (%@)  (topic: %@)", buf, 0x20u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v56 = *(void *)(a1 + 32);
    uint64_t v58 = *(void *)(a1 + 40);
    id v53 = v5;
    _IDSLogV();
  }
  if ((a3 & 1) == 0)
  {
    __int16 v9 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = *(void *)(a1 + 32);
      uint64_t v11 = *(void *)(a1 + 40);
      *(_DWORD *)long long buf = 138412802;
      id v86 = v5;
      __int16 v87 = 2112;
      uint64_t v88 = v10;
      __int16 v89 = 2112;
      uint64_t v90 = v11;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Persisting failed for message %@  (%@)  (topic: %@)", buf, 0x20u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      uint64_t v56 = *(void *)(a1 + 32);
      uint64_t v58 = *(void *)(a1 + 40);
      id v53 = v5;
      _IDSLogTransport();
    }
  }
  if (!objc_msgSend(*(id *)(a1 + 48), "isFamilyService", v53, v56, v58)) {
    goto LABEL_30;
  }
  unsigned int v12 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    id v13 = *(void **)(a1 + 56);
    *(_DWORD *)long long buf = 138412290;
    id v86 = v13;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Performing validity check for message %@ sent to family service.", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v54 = *(void *)(a1 + 56);
    _IDSLogV();
  }
  CFStringRef v14 = objc_msgSend(*(id *)(a1 + 64), "familyManager", v54);
  unsigned int v15 = [v14 familyMembers];
  BOOL v16 = [v15 count] == 0;

  if (!v16)
  {
LABEL_18:
    if (objc_msgSend(*(id *)(a1 + 64), "_shouldRejectMessageOnFamilyService:fromSenderURI:", *(void *)(a1 + 48), *(void *)(a1 + 72), v55))
    {
      unsigned int v17 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v18 = *(void **)(a1 + 56);
        uint64_t v19 = *(void *)(a1 + 72);
        *(_DWORD *)long long buf = 138412546;
        id v86 = v18;
        __int16 v87 = 2112;
        uint64_t v88 = v19;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Family Message %@ is coming from an account that is not in the family. Sender was: %@", buf, 0x16u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        uint64_t v54 = *(void *)(a1 + 56);
        uint64_t v57 = *(void *)(a1 + 72);
        _IDSLogV();
      }
      objc_msgSend(objc_msgSend(*(id *)(a1 + 64), "_messageStoreClass", v54, v57), "deleteIncomingMessageWithGUID:", v5);
      [*(id *)(a1 + 64) _sendCertifiedDeliveryReceiptIfNeededForNiceMessage:*(void *)(a1 + 32) service:*(void *)(a1 + 40) failureReason:&off_1009D2148 failureReasonMessage:0 generateDeliveryReceipt:0];
      goto LABEL_74;
    }
    unsigned int v20 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v21 = *(void **)(a1 + 56);
      *(_DWORD *)long long buf = 138412290;
      id v86 = v21;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Message %@ sent to family service passed validity requirements.", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      uint64_t v54 = *(void *)(a1 + 56);
      _IDSLogV();
    }
LABEL_30:
    CFStringRef v22 = +[IDSDServiceController sharedInstance];
    id v23 = [v22 serviceWithPushTopic:*(void *)(a1 + 40)];
    unsigned int v24 = [v23 dontFilterSelfMessagesForUnknownDevice];

    unsigned int v25 = [*(id *)(a1 + 40) isEqualToIgnoringCase:@"com.apple.madrid"];
    if (!a3
      || (([*(id *)(a1 + 72) isEqualToURI:*(void *)(a1 + 80)] ^ 1 | v25 | v24) & 1) != 0
      || ([*(id *)(a1 + 64) _isDeviceInAccountRegistration:*(void *)(a1 + 88) forService:*(void *)(a1 + 40)] & 1) != 0)
    {
      goto LABEL_71;
    }
    id v26 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Device is NOT in our account registrations, It should be, Can we force a GDR?", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    id v27 = +[IDSDAccountController sharedInstance];
    __int16 v28 = +[IDSDServiceController sharedInstance];
    CFStringRef v29 = [v28 serviceWithPushTopic:*(void *)(a1 + 40)];
    CFStringRef v30 = [v27 appleIDAccountOnService:v29];
    id v31 = [v30 primaryAccount];

    if ([*(id *)(*(void *)(a1 + 64) + 168) containsObject:*(void *)(a1 + 88)])
    {
      if (([v31 issuingDependentCheck] & 1) == 0)
      {
        id v32 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "Unknown devices, but GDR attempt exchasuted", buf, 2u);
        }

        if (!os_log_shim_legacy_logging_enabled() || (_IDSShouldLog() & 1) == 0) {
          goto LABEL_70;
        }
        goto LABEL_69;
      }
    }
    else
    {
      if (![v31 _issueForcedDependentCheckIfPossible])
      {
        long long v45 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "No forced GDR is possible", buf, 2u);
        }

        if (!os_log_shim_legacy_logging_enabled() || (_IDSShouldLog() & 1) == 0) {
          goto LABEL_70;
        }
LABEL_69:
        _IDSLogV();
LABEL_70:

LABEL_71:
        uint64_t v46 = *(void **)(a1 + 64);
        v59[0] = _NSConcreteStackBlock;
        v59[1] = 3221225472;
        v59[2] = sub_1003AF660;
        v59[3] = &unk_10098B040;
        id v60 = *(id *)(a1 + 96);
        id v61 = *(id *)(a1 + 40);
        id v62 = *(id *)(a1 + 104);
        id v63 = *(id *)(a1 + 112);
        id v64 = *(id *)(a1 + 120);
        id v65 = *(id *)(a1 + 56);
        id v47 = *(id *)(a1 + 32);
        char v81 = *(unsigned char *)(a1 + 192);
        uint64_t v48 = *(void *)(a1 + 64);
        long long v49 = *(void **)(a1 + 72);
        id v66 = v47;
        uint64_t v67 = v48;
        id v68 = v49;
        id v69 = *(id *)(a1 + 80);
        id v70 = *(id *)(a1 + 48);
        id v71 = *(id *)(a1 + 128);
        id v72 = v5;
        id v73 = *(id *)(a1 + 88);
        char v82 = *(unsigned char *)(a1 + 193);
        id v74 = *(id *)(a1 + 136);
        id v75 = *(id *)(a1 + 144);
        id v76 = *(id *)(a1 + 152);
        id v77 = *(id *)(a1 + 160);
        id v78 = *(id *)(a1 + 168);
        id v50 = *(id *)(a1 + 176);
        char v83 = *(unsigned char *)(a1 + 194);
        uint64_t v51 = *(void *)(a1 + 184);
        id v79 = v50;
        uint64_t v80 = v51;
        char v84 = *(unsigned char *)(a1 + 195);
        double v52 = 300.0;
        if (!v84) {
          double v52 = 30.0;
        }
        [v46 _enqueueBlock:v59 identifier:*(void *)(a1 + 56) withTimeout:*(void *)(a1 + 40) forKey:v52];

        goto LABEL_74;
      }
      long long v40 = *(void **)(*(void *)(a1 + 64) + 168);
      if (!v40)
      {
        id v41 = objc_alloc_init((Class)NSMutableSet);
        uint64_t v42 = *(void *)(a1 + 64);
        long long v43 = *(void **)(v42 + 168);
        *(void *)(v42 + 168) = v41;

        long long v40 = *(void **)(*(void *)(a1 + 64) + 168);
      }
      [v40 addObject:*(void *)(a1 + 88)];
      long long v44 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "Issuing forced GDR & sending message to storage", buf, 2u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        _IDSLogV();
      }
    }

    goto LABEL_74;
  }
  id v33 = [*(id *)(a1 + 64) familyManager];
  unsigned int v34 = [v33 canForceFamilyFetch];

  if (!v34)
  {
    __int16 v38 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v39 = *(void **)(a1 + 56);
      *(_DWORD *)long long buf = 138412290;
      id v86 = v39;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "IDS Family member count is zero, but out of fetches to fetch family again, this message %@ will likely fail.", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      uint64_t v55 = *(void *)(a1 + 56);
      _IDSLogV();
    }
    goto LABEL_18;
  }
  id v35 = [*(id *)(a1 + 64) familyManager];
  [v35 setStoredIncomingFamilyMessage:1];

  long long v36 = [*(id *)(a1 + 64) familyManager];
  [v36 forceFamilyFetch];

  id v37 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "IDS Family member count is zero, trying to fetch family again. Will retry message after fetch completes. Sending incoming family message to storage.", buf, 2u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
LABEL_74:
}

void sub_1003AF660(uint64_t a1, void *a2)
{
  id v3 = a2;
  v25[0] = _NSConcreteStackBlock;
  v25[1] = 3221225472;
  v25[2] = sub_1003AFB04;
  v25[3] = &unk_10098B018;
  id v26 = *(id *)(a1 + 32);
  id v27 = *(id *)(a1 + 40);
  id v28 = *(id *)(a1 + 48);
  id v29 = *(id *)(a1 + 56);
  id v30 = *(id *)(a1 + 64);
  id v31 = *(id *)(a1 + 72);
  id v4 = *(id *)(a1 + 80);
  char v47 = *(unsigned char *)(a1 + 200);
  uint64_t v5 = *(void *)(a1 + 88);
  uint64_t v6 = *(void **)(a1 + 96);
  id v32 = v4;
  uint64_t v33 = v5;
  id v34 = v6;
  id v35 = *(id *)(a1 + 104);
  id v36 = *(id *)(a1 + 112);
  id v37 = *(id *)(a1 + 120);
  id v38 = *(id *)(a1 + 128);
  id v22 = v3;
  id v46 = v22;
  id v39 = *(id *)(a1 + 136);
  char v48 = *(unsigned char *)(a1 + 201);
  id v40 = *(id *)(a1 + 144);
  id v41 = *(id *)(a1 + 152);
  id v42 = *(id *)(a1 + 160);
  id v43 = *(id *)(a1 + 168);
  id v44 = *(id *)(a1 + 176);
  id v45 = *(id *)(a1 + 184);
  char v49 = *(unsigned char *)(a1 + 202);
  unsigned int v24 = objc_retainBlock(v25);
  if (*(uint64_t *)(a1 + 192) < 1)
  {
    id v19 = 0;
  }
  else
  {
    id v23 = [*(id *)(a1 + 80) certifiedDeliveryRTS];
    if (!v23)
    {
      uint64_t v7 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        uint64_t v8 = *(void *)(a1 + 72);
        uint64_t v9 = *(void *)(a1 + 192);
        *(_DWORD *)long long buf = 138412546;
        uint64_t v51 = v8;
        __int16 v52 = 2048;
        uint64_t v53 = v9;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "No certified delivery RTS found in payload with cdv { guid: %@, cdv: %ld }", buf, 0x16u);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        _IDSWarnV();
        _IDSLogV();
        _IDSLogTransport();
      }
    }
    id v10 = objc_alloc((Class)IDSCertifiedDeliveryContext);
    uint64_t v11 = *(void *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 72);
    id v13 = [*(id *)(a1 + 80) encryptionTypeStr];
    uint64_t v14 = IDSEncryptionTypeFromEncryptionTypeString();
    uint64_t v15 = *(void *)(a1 + 192);
    BOOL v16 = [*(id *)(a1 + 136) rawToken];
    unsigned int v17 = [*(id *)(a1 + 104) prefixedURI];
    CFStringRef v18 = [*(id *)(a1 + 96) prefixedURI];
    id v19 = [v10 initWithGUID:v12 service:v11 encryptionType:v14 certifiedDeliveryVersion:v15 certifiedDeliveryRTS:v23 senderToken:v16 localURI:v17 remoteURI:v18];
  }
  uint64_t v21 = *(void *)(a1 + 80);
  unsigned int v20 = *(void **)(a1 + 88);
  if (*(unsigned char *)(a1 + 203)) {
    [v20 _handleIncomingNiceAttachmentMessage:v21 forTopic:*(void *)(a1 + 40) fromURI:*(void *)(a1 + 96) certifiedDeliveryContext:v19 completionBlock:v24];
  }
  else {
    [v20 _optionallyDecryptNiceMessage:v21 encryptedData:0 forGroupID:*(void *)(a1 + 176) forTopic:*(void *)(a1 + 40) fromURI:*(void *)(a1 + 96) certifiedDeliveryContext:v19 completionBlock:v24];
  }
}

void sub_1003AFB04(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v99 = a3;
  id v100 = a4;
  uint64_t v153 = 0;
  uint64_t v154 = (id *)&v153;
  uint64_t v155 = 0x3032000000;
  id v156 = sub_1003896D0;
  uint64_t v157 = sub_1003896E0;
  id v158 = (id)0xAAAAAAAAAAAAAAAALL;
  id v98 = v7;
  id v158 = v98;
  uint64_t v147 = 0;
  unsigned int v148 = &v147;
  uint64_t v149 = 0x3032000000;
  __int16 v150 = sub_1003896D0;
  int v151 = sub_1003896E0;
  id v152 = (id)0xAAAAAAAAAAAAAAAALL;
  id v152 = *(id *)(a1 + 32);
  id v101 = *(id *)(a1 + 40);
  id v102 = *(id *)(a1 + 48);
  id v103 = *(id *)(a1 + 56);
  id v104 = *(id *)(a1 + 64);
  id v105 = *(id *)(a1 + 72);
  uint64_t v108 = a1;
  id v106 = [*(id *)(a1 + 80) storageContext];
  if (_os_feature_enabled_impl() && *(unsigned char *)(a1 + 200))
  {
    uint64_t v8 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void **)(a1 + 72);
      *(_DWORD *)long long buf = 138412290;
      uint64_t v161 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Received encrypted receipt { guid: %@ }", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      uint64_t v90 = *(void *)(a1 + 72);
      _IDSLogV();
    }
    uint64_t v10 = IDSIncomingMessageDecryptedDataKey;
    uint64_t v11 = objc_msgSend(v154[5], "objectForKey:", IDSIncomingMessageDecryptedDataKey, v90);
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      uint64_t v12 = [v154[5] objectForKey:v10];
      uint64_t v13 = +[NSData _IDSDataFromBase64String:v12];
    }
    else
    {
      uint64_t v12 = [v154[5] objectForKey:v10];
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        uint64_t v14 = 0;
LABEL_14:

        uint64_t v15 = JWDecodeDictionary();
        if (_os_feature_enabled_impl())
        {
          BOOL v16 = im_primary_queue();
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472;
          block[2] = sub_1003B1094;
          block[3] = &unk_10097E418;
          void block[4] = *(void *)(a1 + 88);
          id v145 = v15;
          id v146 = *(id *)(a1 + 80);
          dispatch_async(v16, block);
        }
        if (!v15
          || !IDSQueryHashKey
          || (unsigned int v17 = (id)CFDictionaryGetValue((CFDictionaryRef)v15, IDSQueryHashKey)) == 0)
        {
          id v23 = OSLogHandleForIDSCategory();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          {
            unsigned int v24 = *(void **)(a1 + 72);
            *(_DWORD *)long long buf = 138412290;
            uint64_t v161 = v24;
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Delivery receipt %@ had encrypted payload, but had a poorly encoded queryHash.", buf, 0xCu);
          }

          if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
          {
            uint64_t v90 = *(void *)(a1 + 72);
            _IDSLogV();
          }
          CFStringRef v18 = 0;
          goto LABEL_31;
        }
        CFStringRef v18 = v17;
        id v19 = [objc_alloc((Class)NSMutableData) initWithLength:32];
        unsigned __int8 v20 = [v18 isEqualToData:v19];

        if (v20)
        {
          uint64_t v21 = OSLogHandleForIDSCategory();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            id v22 = *(void **)(v108 + 72);
            *(_DWORD *)long long buf = 138412290;
            uint64_t v161 = v22;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Decrypted hash was prosthetic 0 hash. Processed in DeliveryReceipt %@", buf, 0xCu);
          }

          if (!os_log_shim_legacy_logging_enabled() || !_IDSShouldLog()) {
            goto LABEL_31;
          }
        }
        else
        {
          [*(id *)(v108 + 88) queryHashForceUpdate:*(void *)(v108 + 32) fromURI:*(void *)(v108 + 96) messageUUID:*(void *)(v108 + 72) updateHash:v18 toURI:*(void *)(v108 + 104) service:*(void *)(v108 + 112)];
          id v86 = OSLogHandleForIDSCategory();
          if (os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT))
          {
            __int16 v87 = *(void **)(v108 + 72);
            *(_DWORD *)long long buf = 138412290;
            uint64_t v161 = v87;
            _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEFAULT, "Decrypted hash Processed in DeliveryReceipt %@", buf, 0xCu);
          }

          if (!os_log_shim_legacy_logging_enabled() || (_IDSShouldLog() & 1) == 0) {
            goto LABEL_31;
          }
        }
        uint64_t v90 = *(void *)(v108 + 72);
        _IDSLogV();
LABEL_31:

        goto LABEL_32;
      }
      uint64_t v13 = [v154[5] objectForKey:v10];
    }
    uint64_t v14 = (void *)v13;
    goto LABEL_14;
  }
LABEL_32:
  if (objc_msgSend(*(id *)(v108 + 40), "isEqualToString:", IDSServiceNameiMessage, v90)
    && [*(id *)(v108 + 32) unsignedIntValue] == 100)
  {
    unsigned int v25 = im_primary_queue();
    v141[0] = _NSConcreteStackBlock;
    v141[1] = 3221225472;
    v141[2] = sub_1003B114C;
    v141[3] = &unk_10097E418;
    v141[4] = *(void *)(v108 + 88);
    id v142 = *(id *)(v108 + 96);
    id v143 = *(id *)(v108 + 104);
    dispatch_async(v25, v141);

    id v26 = [*(id *)(v108 + 88) senderKeyDistributionManager];
    id v27 = [*(id *)(v108 + 80) senderPushToken];
    [v26 markLastIMessagedPeerToken:v27 localURI:*(void *)(v108 + 104) remoteURI:*(void *)(v108 + 96)];
  }
  uint64_t v28 = v108;
  if (*(void *)(v108 + 120))
  {
    unsigned int v29 = [*(id *)(v108 + 32) unsignedIntValue];
    uint64_t v28 = v108;
    if (v29 == 133)
    {
      id v30 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        id v31 = *(void **)(v108 + 72);
        id v32 = *(void **)(v108 + 96);
        uint64_t v33 = *(void *)(v108 + 104);
        *(_DWORD *)long long buf = 138412802;
        uint64_t v161 = v31;
        __int16 v162 = 2112;
        v163 = v32;
        __int16 v164 = 2112;
        uint64_t v165 = v33;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Received SenderKeyDistributionMessage with GUID %@ fromURI: %@ toURI: %@", buf, 0x20u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        uint64_t v94 = *(void *)(v108 + 96);
        uint64_t v96 = *(void *)(v108 + 104);
        uint64_t v91 = *(void *)(v108 + 72);
        _IDSLogV();
      }
      uint64_t v34 = IDSIncomingMessageDecryptedDataKey;
      id v35 = objc_msgSend(v154[5], "objectForKey:", IDSIncomingMessageDecryptedDataKey, v91, v94, v96);
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        id v36 = [v154[5] objectForKey:v34];
        uint64_t v37 = +[NSData _IDSDataFromBase64String:v36];
      }
      else
      {
        id v36 = [v154[5] objectForKey:v34];
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          char v82 = 0;
          goto LABEL_90;
        }
        uint64_t v37 = [v154[5] objectForKey:v34];
      }
      char v82 = (void *)v37;
LABEL_90:

      char v83 = [*(id *)(v108 + 88) senderKeyDistributionManager];
      char v84 = [v83 processedKeyMessageWithRemoteURI:*(void *)(v108 + 96) localURI:*(void *)(v108 + 104) messageData:v82 messageGUID:*(void *)(v108 + 72)];

      [*(id *)(v108 + 88) _sendCertifiedDeliveryReceiptForSenderKeyDistributionMessage:*(void *)(v108 + 80) service:*(void *)(v108 + 40) keyIDs:v84];
      +[IDSDMessageStore deleteIncomingMessageWithGUID:*(void *)(v108 + 128)];
      (*(void (**)(void))(*(void *)(v108 + 192) + 16))();

      goto LABEL_106;
    }
  }
  if ([*(id *)(v28 + 88) isFirewallOnForService:*(void *)(v28 + 112)])
  {
    id v38 = +[IDSPeerIDManager sharedInstance];
    uint64_t v39 = *(void *)(v108 + 96);
    uint64_t v40 = *(void *)(v108 + 104);
    id v41 = [*(id *)(v108 + 112) queryService];
    __int16 v97 = [v38 senderCorrelationIdentifierForURI:v39 fromURI:v40 service:v41];

    if ([*(id *)(v108 + 88) shouldFirewallDropMessageForFromURI:*(void *)(v108 + 96) mergeID:v97 service:*(void *)(v108 + 112)])
    {
      id v42 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
      {
        id v43 = *(void **)(v108 + 72);
        id v44 = *(void **)(v108 + 96);
        *(_DWORD *)long long buf = 138412546;
        uint64_t v161 = v43;
        __int16 v162 = 2112;
        v163 = v44;
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "Message %@ is coming from an account that is firewalled from talking to this device. Sender Was: %@", buf, 0x16u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        uint64_t v91 = *(void *)(v108 + 72);
        uint64_t v94 = *(void *)(v108 + 96);
        _IDSLogV();
      }
      objc_msgSend(*(id *)(v108 + 88), "noteBlockedMessageFromURI:service:", *(void *)(v108 + 96), *(void *)(v108 + 112), v91, v94);
      if (+[IDSDaemon _commandIsSessionCommand:](IDSDaemon, "_commandIsSessionCommand:", [(id)v148[5] integerValue])|| +[IDSDaemon _commandIsSessionGroupSessionCommand:](IDSDaemon, "_commandIsSessionGroupSessionCommand:", objc_msgSend((id)v148[5], "integerValue")))
      {
        id v45 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
        {
          id v46 = *(void **)(v108 + 72);
          *(_DWORD *)long long buf = 138412290;
          uint64_t v161 = v46;
          _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "Firewalled message %@ is coming for session.", buf, 0xCu);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
        {
          uint64_t v92 = *(void *)(v108 + 72);
          _IDSLogV();
        }
        char v47 = +[IDSDSessionController sharedInstance];
        char v48 = [v47 groupSessionGroupIDs];

        long long v139 = 0u;
        long long v140 = 0u;
        long long v137 = 0u;
        long long v138 = 0u;
        id v49 = v48;
        id v50 = [v49 countByEnumeratingWithState:&v137 objects:v159 count:16];
        if (v50)
        {
          char v51 = 0;
          uint64_t v52 = *(void *)v138;
          do
          {
            for (uint64_t i = 0; i != v50; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v138 != v52) {
                objc_enumerationMutation(v49);
              }
              uint64_t v54 = *(void *)(*((void *)&v137 + 1) + 8 * i);
              uint64_t v55 = +[IDSDSessionController sharedInstance];
              uint64_t v56 = [v55 sessionWithGroupID:v54];

              if (v56)
              {
                uint64_t v57 = [v56 getFromService];
                uint64_t v58 = [*(id *)(v108 + 112) identifier];
                if ([v57 isEqualToIgnoringCase:v58])
                {
                  unsigned int v59 = [v56 destinationsContainFromURI:*(void *)(v108 + 96)];

                  if (v59)
                  {
                    if ([v56 groupSessionState] == 1)
                    {
                      id v60 = OSLogHandleForIDSCategory();
                      if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
                      {
                        id v61 = [*(id *)(v108 + 112) identifier];
                        id v62 = [v56 groupID];
                        *(_DWORD *)long long buf = 138412546;
                        uint64_t v161 = v61;
                        __int16 v162 = 2112;
                        v163 = v62;
                        _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "Ending session for service %@ with groupID %@", buf, 0x16u);
                      }
                      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
                      {
                        id v63 = [*(id *)(v108 + 112) identifier];
                        [v56 groupID];
                        v95 = uint64_t v93 = v63;
                        _IDSLogV();
                      }
                      objc_msgSend(v56, "endSessionWithReason:", 48, v93, v95);
                    }
                    char v51 = 1;
                  }
                }
                else
                {
                }
              }
            }
            id v50 = [v49 countByEnumeratingWithState:&v137 objects:v159 count:16];
          }
          while (v50);

          if (v51) {
            goto LABEL_105;
          }
        }
        else
        {
        }
      }
      uint64_t v88 = [*(id *)(v108 + 88) firewallNotificationCenter];
      [v88 postNotificationForURI:*(void *)(v108 + 96) onService:*(void *)(v108 + 112) shouldRateLimit:1 command:v148[5]];

LABEL_105:
      +[IDSDMessageStore deleteIncomingMessageWithGUID:*(void *)(v108 + 128)];
      id v89 = [objc_alloc((Class)IDSMissingMessageMetric) initWithReason:702 guid:*(void *)(v108 + 72) service:*(void *)(v108 + 40) additionalInformation:0];
      +[IDSMissingMessageMetricReporter sendMetric:v89];
      [*(id *)(v108 + 88) _sendCertifiedDeliveryReceiptIfNeededForNiceMessage:*(void *)(v108 + 80) service:*(void *)(v108 + 40) failureReason:&off_1009D2118 failureReasonMessage:0 generateDeliveryReceipt:0];
      (*(void (**)(void))(*(void *)(v108 + 192) + 16))();

      char v82 = v97;
      goto LABEL_106;
    }
  }
  v109[0] = _NSConcreteStackBlock;
  v109[1] = 3221225472;
  v109[2] = sub_1003B13E8;
  v109[3] = &unk_10098AFF0;
  id v134 = &v153;
  id v110 = *(id *)(v108 + 96);
  id v111 = *(id *)(v108 + 136);
  id v112 = *(id *)(v108 + 104);
  id v113 = *(id *)(v108 + 112);
  id v114 = *(id *)(v108 + 72);
  int8x16_t v107 = *(int8x16_t *)(v108 + 80);
  id v64 = (id)v107.i64[0];
  int8x16_t v115 = vextq_s8(v107, v107, 8uLL);
  id v116 = *(id *)(v108 + 40);
  id v117 = v106;
  id v118 = *(id *)(v108 + 128);
  id v65 = v99;
  id v119 = v65;
  id v133 = *(id *)(v108 + 192);
  id v135 = &v147;
  char v136 = *(unsigned char *)(v108 + 201);
  id v120 = *(id *)(v108 + 32);
  id v121 = v100;
  id v122 = v105;
  id v123 = v102;
  id v124 = v104;
  id v125 = v103;
  id v126 = *(id *)(v108 + 144);
  id v127 = *(id *)(v108 + 152);
  id v128 = *(id *)(v108 + 160);
  id v129 = v101;
  id v130 = *(id *)(v108 + 168);
  id v131 = *(id *)(v108 + 176);
  id v132 = *(id *)(v108 + 184);
  id v66 = objc_retainBlock(v109);
  if (*(unsigned char *)(v108 + 202))
  {
    uint64_t v67 = [*(id *)(v108 + 80) failureReason];
    id v68 = [*(id *)(v108 + 80) failureMessageID];
    id v69 = [*(id *)(v108 + 80) failureReasonMessage];
    id v70 = (__CFDictionary *)[v154[5] mutableCopy];
    id v71 = +[IDSPeerIDManager sharedInstance];
    uint64_t v72 = *(void *)(v108 + 136);
    uint64_t v74 = *(void *)(v108 + 96);
    uint64_t v73 = *(void *)(v108 + 104);
    id v75 = [*(id *)(v108 + 112) queryService];
    id v76 = [v71 shouldShowPeerErrorsFor:v74 pushToken:v72 fromURI:v73 service:v75];

    id v77 = +[NSNumber numberWithBool:v76];
    if (v77) {
      CFDictionarySetValue(v70, IDSIncomingMessageShouldShowPeerErrorsKey, v77);
    }

    objc_storeStrong(v154 + 5, v70);
    id v78 = *(void **)(v108 + 88);
    id v79 = v154[5];
    uint64_t v80 = *(void **)(v108 + 112);
    char v81 = [v80 queryService];
    [v78 _processMessageError:v76 topLevelMessage:v79 error:v67 messageID:v68 failureReasonMessage:v69 service:v80 serviceType:v81 pushToken:*(void *)(v108 + 136) fromURI:*(void *)(v108 + 96) toURI:*(void *)(v108 + 104) groupID:*(void *)(v108 + 176) completionBlock:v66];
  }
  else if (v65)
  {
    ((void (*)(void *, void, void, id))v66[2])(v66, 0, 0, objc_msgSend(*(id *)(v108 + 88), "_shouldDropMessageForIncomingDecryptionErrorType:", objc_msgSend(v65, "code")));
  }
  else
  {
    long long v85 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "No Message Error, Processing Immediately", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    ((void (*)(void *, void, void, void))v66[2])(v66, 0, 0, 0);
  }

  char v82 = v110;
LABEL_106:

  _Block_object_dispose(&v147, 8);
  _Block_object_dispose(&v153, 8);
}

void sub_1003B1094(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  id v7 = [*(id *)(a1 + 48) fromURI];
  id v4 = [*(id *)(a1 + 48) senderPushToken];
  uint64_t v5 = [*(id *)(a1 + 48) toURI];
  uint64_t v6 = [*(id *)(a1 + 48) pushUUID];
  [v2 _handleDeliveryReceiptForSenderKeyCheck:v3 remoteURI:v7 remotePushToken:v4 localURI:v5 originalGUID:v6];
}

void sub_1003B114C(uint64_t a1)
{
  id v2 = *(void **)(*(void *)(a1 + 32) + 512);
  uint64_t v9 = *(void *)(a1 + 40);
  uint64_t v3 = +[NSArray arrayWithObjects:&v9 count:1];
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = +[IDSSenderKeySendContext iMessageReceive];
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  unsigned char v6[2] = sub_1003B1288;
  v6[3] = &unk_100980D88;
  id v7 = *(id *)(a1 + 40);
  id v8 = *(id *)(a1 + 48);
  [v2 generateAndSendKeyIfNeededToURIs:v3 fromURI:v4 context:v5 completion:v6];
}

uint64_t sub_1003B1288(uint64_t a1, int a2)
{
  uint64_t v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v5 = @"NO";
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v7 = *(void *)(a1 + 40);
    if (a2) {
      CFStringRef v5 = @"YES";
    }
    *(_DWORD *)long long buf = 138412802;
    CFStringRef v10 = v5;
    __int16 v11 = 2112;
    uint64_t v12 = v6;
    __int16 v13 = 2112;
    uint64_t v14 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Did trigger generateAndSendKeyIfNeededToURIs: %@ { toURI: %@ fromURI: %@ }", buf, 0x20u);
  }

  uint64_t result = os_log_shim_legacy_logging_enabled();
  if (result)
  {
    uint64_t result = _IDSShouldLog();
    if (result) {
      return _IDSLogV();
    }
  }
  return result;
}

void sub_1003B13E8(uint64_t a1, void *a2, void *a3, int a4)
{
  id v152 = a2;
  id v150 = a3;
  if (v150) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 232) + 8) + 40), a3);
  }
  uint64_t v7 = +[IDSPeerIDManager sharedInstance];
  uint64_t v8 = *(void *)(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 40);
  uint64_t v10 = *(void *)(a1 + 48);
  __int16 v11 = [*(id *)(a1 + 56) queryService];
  uint64_t v12 = [v7 senderCorrelationIdentifierForURI:v8 pushToken:v9 fromURI:v10 service:v11];

  if ([v12 length])
  {
    __int16 v13 = (__CFDictionary *)[objc_alloc((Class)NSMutableDictionary) initWithDictionary:*(void *)(*(void *)(*(void *)(a1 + 232) + 8) + 40)];
    id v14 = v12;
    if (v14) {
      CFDictionarySetValue(v13, @"mid", v14);
    }

    uint64_t v15 = +[NSDictionary dictionaryWithDictionary:v13];
    uint64_t v16 = *(void *)(*(void *)(a1 + 232) + 8);
    unsigned int v17 = *(void **)(v16 + 40);
    *(void *)(v16 + 40) = v15;
  }
  CFStringRef v18 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v19 = *(void *)(a1 + 64);
    uint64_t v20 = *(void *)(a1 + 32);
    uint64_t v21 = [*(id *)(*(void *)(*(void *)(a1 + 232) + 8) + 40) allKeys];
    *(_DWORD *)long long buf = 138413058;
    *(void *)v205 = v19;
    *(_WORD *)&v205[8] = 2112;
    *(void *)&v205[10] = v20;
    *(_WORD *)&v205[18] = 2112;
    *(void *)&v205[20] = v12;
    __int16 v206 = 2112;
    CFStringRef v207 = v21;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Finished handling decryption {GUID: %@, URI: %@, SenderCorrelationIdentifier: %@, topLevelPayload: %@}", buf, 0x2Au);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v22 = *(void *)(a1 + 64);
    uint64_t v23 = *(void *)(a1 + 32);
    [*(id *)(*(void *)(*(void *)(a1 + 232) + 8) + 40) allKeys];
    v144 = id v142 = v12;
    uint64_t v136 = v22;
    uint64_t v139 = v23;
    _IDSLogV();
  }
  objc_msgSend(*(id *)(a1 + 72), "_sendNiceMessageCheckpointIfNecessary:checkpoint:service:additionalInformation:", *(void *)(a1 + 80), 9300, *(void *)(a1 + 88), 0, v136, v139, v142, v144);
  unsigned int v24 = [*(id *)(a1 + 80) serverTimestamp];
  uint64_t v153 = sub_100380B30(v24);

  [v153 timeIntervalSince1970];
  double v26 = v25;
  id v27 = +[NSDate date];
  [v27 timeIntervalSince1970];
  double v29 = v28;

  id v30 = [*(id *)(a1 + 96) BOOLValue];
  double v31 = v29 - v26;
  id v151 = [objc_alloc((Class)IDSNoteMessageReceivedMetric) initWithService:*(void *)(a1 + 88) accountType:0 fromStorage:v30 serverTimestamp:v26 localTimeDelta:v31];
  id v32 = +[IDSCoreAnalyticsLogger defaultLogger];
  [v32 logMetric:v151];

  uint64_t v33 = +[IDSAWDLogging sharedInstance];
  [v33 noteMessageReceivedForService:*(void *)(a1 + 88) accountType:0 fromStorage:v30 serverTimestamp:v26 localTimeDelta:v31];

  if (!a4)
  {
    uint64_t v196 = 0;
    CFMutableDictionaryRef v197 = &v196;
    uint64_t v198 = 0x3032000000;
    id v199 = sub_1003896D0;
    id v200 = sub_1003896E0;
    id v201 = 0;
    uint64_t v190 = 0;
    long long v191 = &v190;
    uint64_t v192 = 0x3032000000;
    long long v193 = sub_1003896D0;
    long long v194 = sub_1003896E0;
    id v195 = 0;
    uint64_t v38 = IDSIncomingMessageDecryptedDataKey;
    uint64_t v39 = [*(id *)(*(void *)(*(void *)(a1 + 232) + 8) + 40) objectForKey:IDSIncomingMessageDecryptedDataKey];
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      uint64_t v40 = [*(id *)(*(void *)(*(void *)(a1 + 232) + 8) + 40) objectForKey:v38];
      id v41 = +[NSData _IDSDataFromBase64String:v40];
    }
    else
    {
      uint64_t v40 = [*(id *)(*(void *)(*(void *)(a1 + 232) + 8) + 40) objectForKey:v38];
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        id v42 = 0;
LABEL_25:

        id v43 = [*(id *)(a1 + 80) rawBulkedData];
        id v44 = [*(id *)(a1 + 80) isBulkedPayload];
        unsigned int v45 = [v44 BOOLValue];
        if (v43) {
          int v46 = 1;
        }
        else {
          int v46 = v45;
        }

        uint64_t v149 = [*(id *)(a1 + 80) rawUnencryptedPayload];
        char v47 = [*(id *)(a1 + 80) originalCommand];
        if (v47)
        {
          id v48 = v42;
          id v49 = OSLogHandleForIDSCategory();
          if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
          {
            CFStringRef v50 = @"YES";
            if (!v48) {
              CFStringRef v50 = @"NO";
            }
            *(_DWORD *)long long buf = 138412546;
            *(void *)v205 = v47;
            *(_WORD *)&v205[8] = 2112;
            *(void *)&v205[10] = v50;
            _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "Overflow attachment (with original command %@) -- checking for original payload? %@", buf, 0x16u);
          }

          if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
          {
            CFStringRef v51 = @"YES";
            if (!v48) {
              CFStringRef v51 = @"NO";
            }
            CFStringRef v137 = v47;
            CFStringRef v140 = v51;
            _IDSLogV();
          }
          id v52 = v48;
          uint64_t v53 = v52;
          BOOL v54 = v46 == 0;
          if (v46) {
            unint64_t v55 = 0;
          }
          else {
            unint64_t v55 = (unint64_t)v52;
          }
          if (v54) {
            unint64_t v56 = 0;
          }
          else {
            unint64_t v56 = (unint64_t)v52;
          }
          if (v55 | v56)
          {
            uint64_t v57 = OSLogHandleForIDSCategory();
            if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
            {
              CFStringRef v58 = @"NO";
              if (v55) {
                CFStringRef v59 = @"YES";
              }
              else {
                CFStringRef v59 = @"NO";
              }
              if (v56) {
                CFStringRef v58 = @"YES";
              }
              *(_DWORD *)long long buf = 138412546;
              *(void *)v205 = v59;
              *(_WORD *)&v205[8] = 2112;
              *(void *)&v205[10] = v58;
              _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "Pulled out original payload %@ or bulked payload %@ from attachment message, using original command.", buf, 0x16u);
            }

            if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
            {
              CFStringRef v60 = @"NO";
              if (v55) {
                CFStringRef v61 = @"YES";
              }
              else {
                CFStringRef v61 = @"NO";
              }
              if (v56) {
                CFStringRef v60 = @"YES";
              }
              CFStringRef v137 = v61;
              CFStringRef v140 = v60;
              _IDSLogV();
            }
            id v42 = (id)v55;

            id v62 = (id)v56;
            objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 240) + 8) + 40), v47);
            id v43 = v62;
          }
          else
          {
            id v42 = v52;
          }
        }
        if (objc_msgSend(*(id *)(*(void *)(*(void *)(a1 + 240) + 8) + 40), "integerValue", v137, v140) == (id)242
          || [*(id *)(*(void *)(*(void *)(a1 + 240) + 8) + 40) integerValue] == (id)153)
        {
          uint64_t v63 = [v42 _FTOptionallyDecompressData];
LABEL_66:
          id v64 = 0;
          id v65 = (id)v197[5];
          void v197[5] = v63;
          uint64_t v66 = 1;
LABEL_67:

          id v67 = v64;
LABEL_68:
          if ([*(id *)(a1 + 56) adHocServiceType] == 2)
          {
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              id v68 = objc_alloc((Class)IDSLocalDeliveryMessageReceivedMetric);
              id v69 = [*(id *)(a1 + 56) identifier];
              id v70 = objc_msgSend(v68, "initWithService:isFromDefaultPairedDevice:messageSize:linkType:priority:", v69, 1, objc_msgSend(v42, "length"), 4, 300);

              id v71 = +[IDSCoreAnalyticsLogger defaultLogger];
              [v71 logMetric:v70];

              uint64_t v72 = +[IDSAWDLogging sharedInstance];
              uint64_t v73 = [*(id *)(a1 + 56) identifier];
              objc_msgSend(v72, "messageReceivedForService:isFromDefaultPairedDevice:messageSize:linkType:priority:", v73, 1, objc_msgSend(v42, "length"), 4, 300);
            }
          }
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0 && [v43 length])
          {
            uint64_t v74 = OSLogHandleForIDSCategory();
            if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "Found rawBulkedData", buf, 2u);
            }

            if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
              _IDSLogV();
            }
            id v75 = [v43 _FTOptionallyDecompressData];
            id v76 = JWDecodeArray();

            if ([v76 count])
            {
              id v77 = v76;
            }
            else
            {
              uint64_t v80 = JWDecodeArray();

              id v77 = (void *)v80;
            }
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
LABEL_89:
              char v81 = OSLogHandleForIDSCategory();
              if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v82 = *(void *)(*(void *)(*(void *)(a1 + 240) + 8) + 40);
                CFStringRef v83 = @"YES";
                if (v67) {
                  CFStringRef v84 = @"YES";
                }
                else {
                  CFStringRef v84 = @"NO";
                }
                if (v191[5]) {
                  CFStringRef v85 = @"YES";
                }
                else {
                  CFStringRef v85 = @"NO";
                }
                if (v197[5]) {
                  CFStringRef v86 = @"YES";
                }
                else {
                  CFStringRef v86 = @"NO";
                }
                if (!v77) {
                  CFStringRef v83 = @"NO";
                }
                *(_DWORD *)long long buf = 138413314;
                *(void *)v205 = v82;
                *(_WORD *)&v205[8] = 2112;
                *(void *)&v205[10] = v84;
                *(_WORD *)&v205[18] = 2112;
                *(void *)&v205[20] = v85;
                __int16 v206 = 2112;
                CFStringRef v207 = v86;
                __int16 v208 = 2112;
                CFStringRef v209 = v83;
                _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_DEFAULT, "For command %@ we have unpacked dictionaryPayload? %@ protobufPayload? %@ dataPayload? %@ bulkedPayloads? %@", buf, 0x34u);
              }

              if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
              {
                CFStringRef v87 = @"YES";
                if (v67) {
                  CFStringRef v88 = @"YES";
                }
                else {
                  CFStringRef v88 = @"NO";
                }
                if (v191[5]) {
                  CFStringRef v89 = @"YES";
                }
                else {
                  CFStringRef v89 = @"NO";
                }
                if (v197[5]) {
                  CFStringRef v90 = @"YES";
                }
                else {
                  CFStringRef v90 = @"NO";
                }
                if (!v77) {
                  CFStringRef v87 = @"NO";
                }
                CFStringRef v145 = v90;
                CFStringRef v146 = v87;
                CFStringRef v141 = v88;
                CFStringRef v143 = v89;
                CFStringRef v138 = *(const __CFString **)(*(void *)(*(void *)(a1 + 240) + 8) + 40);
                _IDSLogV();
              }

              v157[0] = _NSConcreteStackBlock;
              v157[1] = 3221225472;
              v157[2] = sub_1003B2BE8;
              v157[3] = &unk_10098AFA0;
              id v158 = *(id *)(a1 + 64);
              id v91 = *(id *)(a1 + 104);
              int v189 = v66;
              id v184 = &v196;
              id v185 = &v190;
              uint64_t v92 = *(void *)(a1 + 72);
              uint64_t v93 = *(void **)(a1 + 80);
              id v159 = v91;
              uint64_t v160 = v92;
              id v161 = v93;
              id v162 = *(id *)(a1 + 32);
              id v163 = *(id *)(a1 + 56);
              id v164 = v12;
              id v94 = v67;
              id v165 = v94;
              id v166 = *(id *)(a1 + 128);
              id v167 = *(id *)(a1 + 136);
              id v168 = *(id *)(a1 + 144);
              id v169 = *(id *)(a1 + 152);
              id v170 = *(id *)(a1 + 160);
              id v171 = *(id *)(a1 + 168);
              id v172 = *(id *)(a1 + 120);
              id v173 = *(id *)(a1 + 48);
              id v174 = *(id *)(a1 + 176);
              id v175 = *(id *)(a1 + 96);
              id v176 = *(id *)(a1 + 184);
              double v188 = v26;
              id v95 = *(id *)(a1 + 192);
              uint64_t v96 = *(void *)(a1 + 240);
              id v177 = v95;
              uint64_t v186 = v96;
              id v178 = *(id *)(a1 + 40);
              id v179 = *(id *)(a1 + 200);
              id v97 = *(id *)(a1 + 88);
              uint64_t v98 = *(void *)(a1 + 232);
              id v180 = v97;
              uint64_t v187 = v98;
              id v181 = *(id *)(a1 + 208);
              id v182 = *(id *)(a1 + 216);
              id v99 = v77;
              id v183 = v99;
              v154[0] = _NSConcreteStackBlock;
              v154[1] = 3221225472;
              v154[2] = sub_1003B68D0;
              v154[3] = &unk_10098AFC8;
              id v100 = objc_retainBlock(v157);
              id v155 = v100;
              id v156 = *(id *)(a1 + 224);
              id v101 = objc_retainBlock(v154);
              id v102 = [*(id *)(a1 + 56) identifier];
              unsigned int v103 = +[IMUserDefaults serviceConstraintOverride:v102];

              unsigned int v104 = [*(id *)(a1 + 56) constraintType];
              if (v103) {
                CFStringRef v105 = (const __CFString *)v103;
              }
              else {
                CFStringRef v105 = (const __CFString *)v104;
              }
              id v106 = (__CFString *)[objc_alloc((Class)IDSBlastDoorMessageContext) initWithService:*(void *)(a1 + 56) command:*(void *)(*(void *)(*(void *)(a1 + 240) + 8) + 40)];
              [(__CFString *)v106 setPayloadType:v66];
              if (v66)
              {
                if (v66 == 1)
                {
                  uint64_t v108 = v197[5];
                  if (v108)
                  {
                    CFStringRef v202 = @"##payload-data##";
                    uint64_t v203 = v108;
                    id v109 = +[NSDictionary dictionaryWithObjects:&v203 forKeys:&v202 count:1];
                  }
                  else
                  {
                    id v109 = &__NSDictionary0__struct;
                  }
LABEL_127:
                  id v110 = OSLogHandleForIDSCategory();
                  if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v111 = *(void *)(a1 + 64);
                    *(_DWORD *)long long buf = 138412802;
                    *(void *)v205 = v111;
                    *(_WORD *)&v205[8] = 1024;
                    *(_DWORD *)&v205[10] = v105;
                    *(_WORD *)&v205[14] = 2112;
                    *(void *)&v205[16] = v106;
                    _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "IDSBlastDoor: Incoming message %@ has constraint type %u and BlastDoor context %@", buf, 0x1Cu);
                  }

                  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
                  {
                    CFStringRef v141 = v105;
                    CFStringRef v143 = v106;
                    CFStringRef v138 = *(const __CFString **)(a1 + 64);
                    _IDSLogV();
                  }
                  if (v105)
                  {
                    if (v105 == 2)
                    {
                      [*(id *)(*(void *)(a1 + 72) + 472) diffuseClientMessage:v109 context:v106 withCompletionBlock:v101];
LABEL_146:

                      _Block_object_dispose(&v190, 8);
                      _Block_object_dispose(&v196, 8);

                      goto LABEL_147;
                    }
                    if (v105 != 1)
                    {
                      id v113 = OSLogHandleForIDSCategory();
                      if (os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT))
                      {
                        uint64_t v114 = *(void *)(a1 + 64);
                        *(_DWORD *)long long buf = 67109378;
                        *(_DWORD *)v205 = v105;
                        *(_WORD *)&v205[4] = 2112;
                        *(void *)&v205[6] = v114;
                        _os_log_impl((void *)&_mh_execute_header, v113, OS_LOG_TYPE_DEFAULT, "IDSBlastDoor: Unknown constraint type %u, dropping message %@", buf, 0x12u);
                      }

                      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
                      {
                        CFStringRef v138 = v105;
                        CFStringRef v141 = *(const __CFString **)(a1 + 64);
                        _IDSLogV();
                      }
                      +[IDSDMessageStore deleteIncomingMessageWithGUID:](IDSDMessageStore, "deleteIncomingMessageWithGUID:", *(void *)(a1 + 104), v138, v141, v143, v145, v146);
                      uint64_t v115 = *(void *)(a1 + 224);
                      if (v115) {
                        (*(void (**)(void))(v115 + 16))();
                      }
                      goto LABEL_146;
                    }
                    uint64_t v112 = 1;
                  }
                  else
                  {
                    uint64_t v112 = 2;
                  }
                  ((void (*)(void *, id, uint64_t, void))v101[2])(v101, v109, v112, 0);
                  goto LABEL_146;
                }
                id v107 = (id)v191[5];
              }
              else
              {
                id v107 = v94;
              }
              id v109 = v107;
              goto LABEL_127;
            }
          }
          id v77 = 0;
          goto LABEL_89;
        }
        if ([*(id *)(*(void *)(*(void *)(a1 + 240) + 8) + 40) integerValue] == (id)250)
        {
          if (v149)
          {
            uint64_t v63 = [v149 _FTOptionallyDecompressData];
            goto LABEL_66;
          }
          id v67 = 0;
        }
        else
        {
          if ([*(id *)(*(void *)(*(void *)(a1 + 240) + 8) + 40) integerValue] == (id)243)
          {
            id v65 = [v42 _FTOptionallyDecompressData];
            uint64_t v78 = JWDecodeDictionary();
            id v79 = (void *)v191[5];
            v191[5] = v78;

            id v64 = 0;
            uint64_t v66 = 2;
            goto LABEL_67;
          }
          id v67 = [*(id *)(a1 + 72) _payloadFromDecryptedData:v42];
          if (!v67)
          {
            if (*(unsigned char *)(a1 + 248))
            {
              id v116 = [objc_alloc((Class)IDSOffGridEncryptedMessage) initWithPayload:v42 senderURI:*(void *)(a1 + 32) recipientURI:*(void *)(a1 + 48)];
              id v117 = [*(id *)(a1 + 80) messageChunkNumber];
              id v118 = [v116 encryptionProperties];
              [v118 setSegmentNumber:v117];

              id v119 = [*(id *)(a1 + 80) totalChunkCount];
              id v120 = [v116 encryptionProperties];
              [v120 setTotalSegments:v119];

              id v121 = [*(id *)(a1 + 80) pendingMessageCount];
              [v116 setPendingTotalCount:v121];

              id v122 = [*(id *)(a1 + 80) pendingMessagePerSenderCount];
              [v116 setPendingCount:v122];

              id v123 = [*(id *)(a1 + 80) serverTimestamp];
              [v123 doubleValue];
              id v125 = +[NSDate dateWithTimeIntervalSince1970:v124 / 1000000000.0];
              [v116 setDate:v125];

              id v126 = [*(id *)(a1 + 80) desiredProtocol];
              [v116 setPreferredService:v126];

              id v127 = [v116 dictionaryRepresentation];
              id v128 = [v127 mutableCopy];

              id v67 = v128;
            }
            else
            {
              id v67 = 0;
            }
          }
          if ([*(id *)(a1 + 88) isEqualToString:IDSServiceNameiMessageLite]
            && [*(id *)(a1 + 120) integerValue] == (id)128)
          {
            id v147 = objc_alloc((Class)IDSOffGridServiceUpdateMessage);
            id v129 = [*(id *)(a1 + 80) desiredProtocol];
            signed int v130 = [v129 intValue];
            unsigned int v148 = [*(id *)(a1 + 80) fromURI];
            id v131 = [*(id *)(a1 + 80) toURI];
            id v65 = [v147 initWithPreferredServiceType:v130 senderURI:v148 recipientURI:v131];

            id v132 = [*(id *)(a1 + 80) expirationDate];
            [v132 doubleValue];
            id v133 = +[NSDate dateWithTimeIntervalSince1970:](NSDate, "dateWithTimeIntervalSince1970:");
            [v65 setExpirationDate:v133];

            id v134 = [v65 dictionaryRepresentation];
            id v135 = [v134 mutableCopy];

            id v64 = v135;
            uint64_t v66 = 0;
            goto LABEL_67;
          }
        }
        uint64_t v66 = 0;
        goto LABEL_68;
      }
      id v41 = [*(id *)(*(void *)(*(void *)(a1 + 232) + 8) + 40) objectForKey:v38];
    }
    id v42 = v41;

    goto LABEL_25;
  }
  uint64_t v34 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
  {
    uint64_t v35 = *(void *)(a1 + 104);
    uint64_t v36 = *(void *)(a1 + 112);
    *(_DWORD *)long long buf = 138478339;
    *(void *)v205 = v35;
    *(_WORD *)&v205[8] = 2112;
    *(void *)&v205[10] = v152;
    *(_WORD *)&v205[18] = 2112;
    *(void *)&v205[20] = v36;
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Dropping message! {guid: %{private}@, processError: %@, decryptionError %@", buf, 0x20u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    _IDSWarnV();
    _IDSLogV();
    CFStringRef v140 = v152;
    CFStringRef v143 = *(const __CFString **)(a1 + 112);
    CFStringRef v137 = *(const __CFString **)(a1 + 104);
    _IDSLogTransport();
  }
  objc_msgSend(objc_msgSend(*(id *)(a1 + 72), "_messageStoreClass", v137, v140, v143), "deleteIncomingMessageWithGUID:", *(void *)(a1 + 104));
  uint64_t v37 = *(void *)(a1 + 224);
  if (v37) {
    (*(void (**)(void))(v37 + 16))();
  }
LABEL_147:
}

void sub_1003B299C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *exc_buf, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
  if (a2 == 1)
  {
    id v64 = objc_begin_catch(a1);
    id v65 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)(v63 - 176) = 138412290;
      *(void *)(v63 - 172) = v64;
      _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "Hit exception %@ trying to deserialize payloads", (uint8_t *)(v63 - 176), 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }

    objc_end_catch();
    JUMPOUT(0x1003B20B0);
  }
  _Block_object_dispose(&a63, 8);
  _Block_object_dispose((const void *)(v63 - 240), 8);
  _Unwind_Resume(a1);
}

void sub_1003B2BE8(uint64_t a1, void *a2, const __CFString *a3, void *a4)
{
  id v7 = a2;
  uint64_t v8 = a4;
  if (!v8)
  {
    __int16 v11 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v12 = *(const __CFString **)(a1 + 32);
      CFStringRef v13 = @"YES";
      *(_DWORD *)long long buf = 138412802;
      if (!v7) {
        CFStringRef v13 = @"NO";
      }
      CFStringRef v120 = v12;
      __int16 v121 = 2112;
      CFStringRef v122 = v13;
      __int16 v123 = 2048;
      CFStringRef v124 = a3;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "IDSBlastDoor: Completed blastdoor validation for message %@ with validated payload %@ and message type %ld", buf, 0x20u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      CFStringRef v14 = @"YES";
      if (!v7) {
        CFStringRef v14 = @"NO";
      }
      CFStringRef v84 = v14;
      CFStringRef v87 = a3;
      uint64_t v81 = *(void *)(a1 + 32);
      _IDSLogV();
    }
    int v15 = *(_DWORD *)(a1 + 280);
    if (v15 == 2)
    {
      uint64_t v17 = *(void *)(*(void *)(a1 + 248) + 8);
      id v18 = v7;
      uint64_t v16 = *(void **)(v17 + 40);
      *(void *)(v17 + 40) = v18;
    }
    else
    {
      if (v15 != 1)
      {
LABEL_26:
        objc_msgSend(*(id *)(a1 + 48), "_replayKeyForNiceMessage:encryptedData:", *(void *)(a1 + 56), 0, v81, v84, v87);
        uint64_t v19 = (__CFString *)objc_claimAutoreleasedReturnValue();
        if (v19)
        {
          uint64_t v20 = [*(id *)(*(void *)(a1 + 48) + 480) objectForKey:v19];
          unsigned __int8 v21 = [v20 isEqualToIgnoringCase:*(void *)(a1 + 32)];

          if ((v21 & 1) == 0)
          {
            uint64_t v22 = OSLogHandleForIDSCategory();
            if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
            {
              CFStringRef v23 = *(const __CFString **)(a1 + 32);
              unsigned int v24 = [*(id *)(*(void *)(a1 + 48) + 480) objectForKey:v19];
              *(_DWORD *)long long buf = 138412802;
              CFStringRef v120 = v19;
              __int16 v121 = 2112;
              CFStringRef v122 = v23;
              __int16 v123 = 2112;
              CFStringRef v124 = v24;
              _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "ERROR: Replay key %@ failed to match to the messageUUID %@ in the map: %@", buf, 0x20u);
            }
            if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
            {
              double v25 = *(__CFString **)(a1 + 32);
              [*(id *)(*(void *)(a1 + 48) + 480) objectForKey:v19];
              CFStringRef v85 = v25;
              CFStringRef v88 = (__CFString *)objc_claimAutoreleasedReturnValue();
              CFStringRef v82 = v19;
              _IDSLogV();
            }
          }
        }
        if (a3 != (const __CFString *)2)
        {
          if (a3 != (const __CFString *)1)
          {
            double v28 = OSLogHandleForIDSCategory();
            if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
            {
              CFStringRef v29 = *(const __CFString **)(a1 + 32);
              *(_DWORD *)long long buf = 134218242;
              CFStringRef v120 = a3;
              __int16 v121 = 2112;
              CFStringRef v122 = v29;
              _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "IDSBlastDoor: Invalid message type %ld for message %@, dropping", buf, 0x16u);
            }

            if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
            {
              CFStringRef v82 = a3;
              CFStringRef v85 = *(__CFString **)(a1 + 32);
              _IDSLogV();
            }
            +[IDSDMessageStore deleteIncomingMessageWithGUID:](IDSDMessageStore, "deleteIncomingMessageWithGUID:", *(void *)(a1 + 40), v82, v85, v88);
            goto LABEL_129;
          }
          if (([*(id *)(a1 + 48) isMessageFromSelfForFromURI:*(void *)(a1 + 64) service:*(void *)(a1 + 72)] & 1) == 0&& (objc_msgSend(*(id *)(a1 + 48), "firewallDatabaseAllowsFromURI:mergeID:service:", *(void *)(a1 + 64), *(void *)(a1 + 80), *(void *)(a1 + 72)) & 1) == 0)
          {
            id v76 = OSLogHandleForIDSCategory();
            if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
            {
              CFStringRef v77 = *(const __CFString **)(a1 + 80);
              CFStringRef v78 = *(const __CFString **)(a1 + 64);
              unsigned int v79 = [*(id *)(a1 + 72) controlCategory];
              *(_DWORD *)long long buf = 138412802;
              CFStringRef v120 = v78;
              __int16 v121 = 2112;
              CFStringRef v122 = v77;
              __int16 v123 = 1024;
              LODWORD(v124) = v79;
              _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "IDSBlastDoor: Sender %@ with mergeID %@ not in allow list for service category %u", buf, 0x1Cu);
            }

            if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
            {
              CFStringRef v80 = *(const __CFString **)(a1 + 64);
              CFStringRef v85 = *(__CFString **)(a1 + 80);
              CFStringRef v88 = (__CFString *)[*(id *)(a1 + 72) controlCategory];
              CFStringRef v82 = v80;
              _IDSLogV();
            }
            +[IDSDMessageStore updateExpirationForIncomingMessageWithGUID:expirationDate:](IDSDMessageStore, "updateExpirationForIncomingMessageWithGUID:expirationDate:", *(void *)(a1 + 40), objc_msgSend(*(id *)(a1 + 48), "_expirationTimeForRestrictedMessages", v82, v85, v88));
            goto LABEL_129;
          }
          id v26 = *(id *)(a1 + 88);

          id v7 = v26;
        }
        if (CUTIsInternalInstall()) {
          unsigned int v27 = +[IMUserDefaults isWritePushPayloadsToDiskEnabled];
        }
        else {
          unsigned int v27 = 0;
        }
        id v30 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
        {
          CFStringRef v31 = *(const __CFString **)(a1 + 32);
          CFStringRef v32 = @"NO";
          if (*(void *)(a1 + 96)) {
            CFStringRef v33 = @"YES";
          }
          else {
            CFStringRef v33 = @"NO";
          }
          *(_DWORD *)long long buf = 138413314;
          if (v27) {
            CFStringRef v32 = @"YES";
          }
          CFStringRef v120 = v31;
          __int16 v121 = 2112;
          CFStringRef v122 = v19;
          __int16 v123 = 2112;
          CFStringRef v124 = @"YES";
          __int16 v125 = 2112;
          CFStringRef v126 = v33;
          __int16 v127 = 2112;
          CFStringRef v128 = v32;
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Commit block status for message %@: Replay Key %@, IDSXAccountBlastdoor %@ hasCertifiedDelivery %@, isWritePayloadToDiskEnabled %@", buf, 0x34u);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
        {
          CFStringRef v34 = @"NO";
          if (*(void *)(a1 + 96)) {
            CFStringRef v35 = @"YES";
          }
          else {
            CFStringRef v35 = @"NO";
          }
          if (v27) {
            CFStringRef v34 = @"YES";
          }
          CFStringRef v90 = v35;
          CFStringRef v91 = v34;
          CFStringRef v85 = v19;
          CFStringRef v88 = @"YES";
          CFStringRef v82 = *(const __CFString **)(a1 + 32);
          _IDSLogV();
        }
        if (v19 && (*(void *)(a1 + 96) ? (char v36 = 1) : (char v36 = v27), (v36 & 1) == 0))
        {
          uint64_t v39 = OSLogHandleForIDSCategory();
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
          {
            CFStringRef v40 = *(const __CFString **)(a1 + 32);
            *(_DWORD *)long long buf = 138412546;
            CFStringRef v120 = v40;
            __int16 v121 = 2112;
            CFStringRef v122 = v19;
            _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "Commit block status for message %@: Calling commit block with replay key %@", buf, 0x16u);
          }

          if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
          {
            CFStringRef v82 = *(const __CFString **)(a1 + 32);
            CFStringRef v85 = v19;
            _IDSLogV();
          }
          id v41 = +[IDSEncryptionController sharedInstance];
          v117[0] = _NSConcreteStackBlock;
          v117[1] = 3221225472;
          v117[2] = sub_1003B3E10;
          v117[3] = &unk_10097E440;
          v117[4] = *(void *)(a1 + 48);
          id v42 = v19;
          id v118 = v42;
          [v41 performAsyncBlock:v117 priority:300];

          [*(id *)(*(void *)(a1 + 48) + 480) removeObjectForKey:v42];
        }
        else
        {
          uint64_t v37 = OSLogHandleForIDSCategory();
          if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
          {
            CFStringRef v38 = *(const __CFString **)(a1 + 32);
            *(_DWORD *)long long buf = 138412290;
            CFStringRef v120 = v38;
            _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "Commit block status for message %@: Not calling commit block.", buf, 0xCu);
          }

          if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
          {
            CFStringRef v82 = *(const __CFString **)(a1 + 32);
            _IDSLogV();
          }
        }
        id v43 = objc_msgSend(*(id *)(a1 + 56), "originalTimestamp", v82);
        unsigned int v92 = [*(id *)(a1 + 56) isTrustedSender];
        id v44 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
        id v45 = *(id *)(a1 + 104);
        if (v45) {
          CFDictionarySetValue(v44, IDSMessageContextOutgoingResponseIdentifierKey, v45);
        }

        id v46 = *(id *)(a1 + 112);
        if (v46) {
          CFDictionarySetValue(v44, IDSMessageContextIncomingResponseIdentifierKey, v46);
        }

        id v47 = *(id *)(a1 + 120);
        if (v47) {
          CFDictionarySetValue(v44, IDSMessageContextExpectsPeerResponseKey, v47);
        }

        id v48 = *(id *)(a1 + 128);
        if (v48) {
          CFDictionarySetValue(v44, IDSMessageContextWantsAppAckKey, v48);
        }

        id v49 = *(id *)(a1 + 40);
        if (v49) {
          CFDictionarySetValue(v44, IDSMessageContextStorageGuidKey, v49);
        }

        id v50 = *(id *)(a1 + 136);
        if (v50) {
          CFDictionarySetValue(v44, IDSMessageContextCommandContextKey, v50);
        }

        id v51 = *(id *)(a1 + 144);
        if (v51) {
          CFDictionarySetValue(v44, IDSMessageContextOriginalCommandKey, v51);
        }

        id v52 = [*(id *)(a1 + 152) prefixedURI];
        if (v52) {
          CFDictionarySetValue(v44, IDSMessageContextToIDKey, v52);
        }

        uint64_t v53 = [*(id *)(a1 + 160) dictionaryRepresentation];
        if (v53) {
          CFDictionarySetValue(v44, IDSMessageContextTargettedPseudonymKey, v53);
        }

        id v54 = *(id *)(a1 + 168);
        if (v54) {
          CFDictionarySetValue(v44, IDSMessageContextFromServerStorageKey, v54);
        }

        id v55 = *(id *)(a1 + 176);
        if (v55) {
          CFDictionarySetValue(v44, IDSMessageContextEngramGroupIDKey, v55);
        }

        unint64_t v56 = +[NSNumber numberWithDouble:*(double *)(a1 + 272)];
        if (v56) {
          CFDictionarySetValue(v44, IDSMessageContextServerTimestampKey, v56);
        }

        id v57 = v43;
        if (v57) {
          CFDictionarySetValue(v44, IDSMessageContextOriginalTimestampKey, v57);
        }

        id v58 = *(id *)(a1 + 80);
        if (v58) {
          CFDictionarySetValue(v44, IDSMessageContextSenderCorrelationIdentifierKey, v58);
        }

        CFStringRef v59 = [*(id *)(a1 + 64) prefixedURI];
        if (v59) {
          CFDictionarySetValue(v44, IDSMessageContextFromIDKey, v59);
        }

        CFStringRef v60 = [*(id *)(a1 + 152) prefixedURI];
        if (v60) {
          CFDictionarySetValue(v44, IDSMessageContextToIDKey, v60);
        }

        CFStringRef v61 = [*(id *)(a1 + 96) dictionaryRepresentation];
        if (v61) {
          CFDictionarySetValue(v44, IDSMessageContextCertifiedDeliveryContextKey, v61);
        }

        id v62 = *(id *)(a1 + 136);
        if (v62) {
          CFDictionarySetValue(v44, IDSMessageContextPublicIntentActionKey, v62);
        }

        id v63 = *(id *)(a1 + 32);
        if (v63) {
          CFDictionarySetValue(v44, IDSMessageContextOriginalGUIDKey, v63);
        }

        id v64 = *(id *)(a1 + 184);
        if (v64) {
          CFDictionarySetValue(v44, IDSMessageContextServiceIdentifierKey, v64);
        }

        id v65 = +[NSNumber numberWithBool:v92];
        if (v65) {
          CFDictionarySetValue(v44, IDSMessageContextIsFromTrustedSender, v65);
        }

        if ([*(id *)(a1 + 48) _processNonMessagingPayloadWithCommand:*(void *)(*(void *)(*(void *)(a1 + 256) + 8) + 40) dictionaryPayload:v7 senderPushToken:*(void *)(a1 + 192) topic:*(void *)(a1 + 184) toURI:*(void *)(a1 + 152) fromURI:*(void *)(a1 + 64) peerResponseIdentifier:*(void *)(a1 + 112) guid:*(void *)(a1 + 40) service:*(void *)(a1 + 72) idsMessageContext:v44 messageContext:*(void *)(a1 + 200)])
        {
          state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
          id v94 = _os_activity_create((void *)&_mh_execute_header, "Not broadcasting command", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
          state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
          os_activity_scope_enter(v94, &state);
          uint64_t v66 = OSLogHandleForIDSCategory();
          if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
          {
            CFStringRef v67 = *(const __CFString **)(a1 + 144);
            CFStringRef v68 = *(const __CFString **)(a1 + 56);
            CFStringRef v69 = *(const __CFString **)(a1 + 40);
            *(_DWORD *)long long buf = 138412802;
            CFStringRef v120 = v67;
            __int16 v121 = 2112;
            CFStringRef v122 = v68;
            __int16 v123 = 2112;
            CFStringRef v124 = v69;
            _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "Shouldn't broadcast for this command %@ for received message %@ with guid %@", buf, 0x20u);
          }

          if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
          {
            uint64_t v86 = *(void *)(a1 + 56);
            uint64_t v89 = *(void *)(a1 + 40);
            uint64_t v83 = *(void *)(a1 + 144);
            _IDSLogV();
          }
          +[IDSDMessageStore deleteIncomingMessageWithGUID:](IDSDMessageStore, "deleteIncomingMessageWithGUID:", *(void *)(a1 + 40), v83, v86, v89);
          os_activity_scope_leave(&state);
          cut_arc_os_release();
        }
        else
        {
          v100[0] = _NSConcreteStackBlock;
          v100[1] = 3221225472;
          v100[2] = sub_1003B3E64;
          v100[3] = &unk_10098AF50;
          id v101 = v44;
          id v102 = *(id *)(a1 + 32);
          id v103 = *(id *)(a1 + 192);
          id v104 = *(id *)(a1 + 64);
          id v70 = *(id *)(a1 + 208);
          uint64_t v71 = *(void *)(a1 + 48);
          id v105 = v70;
          uint64_t v106 = v71;
          id v107 = *(id *)(a1 + 152);
          long long v116 = *(_OWORD *)(a1 + 256);
          id v108 = *(id *)(a1 + 184);
          id v109 = *(id *)(a1 + 72);
          id v110 = *(id *)(a1 + 40);
          id v111 = *(id *)(a1 + 216);
          id v112 = *(id *)(a1 + 56);
          id v113 = *(id *)(a1 + 224);
          id v72 = v7;
          id v114 = v72;
          id v115 = *(id *)(a1 + 200);
          uint64_t v73 = objc_retainBlock(v100);
          v95[0] = _NSConcreteStackBlock;
          v95[1] = 3221225472;
          v95[2] = sub_1003B6660;
          v95[3] = &unk_10098AF78;
          id v96 = *(id *)(a1 + 232);
          uint64_t v74 = v73;
          id v98 = v74;
          id v97 = v72;
          long long v99 = *(_OWORD *)(a1 + 240);
          id v75 = objc_retainBlock(v95);
          ((void (*)(void))v75[2])();
        }
LABEL_129:

        goto LABEL_130;
      }
      if (v7)
      {
        uint64_t v16 = [v7 objectForKey:@"##payload-data##"];
      }
      else
      {
        uint64_t v16 = 0;
      }
      objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 240) + 8) + 40), v16);
      if (!v7)
      {
LABEL_25:

        id v7 = 0;
        goto LABEL_26;
      }
    }

    goto LABEL_25;
  }
  uint64_t v9 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v10 = *(const __CFString **)(a1 + 32);
    *(_DWORD *)long long buf = 138412546;
    CFStringRef v120 = v10;
    __int16 v121 = 2112;
    CFStringRef v122 = v8;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "IDSBlastDoor: Received an error from blastdoor for message %@, dropping message %@", buf, 0x16u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v81 = *(void *)(a1 + 32);
    CFStringRef v84 = v8;
    _IDSLogV();
  }
  +[IDSDMessageStore deleteIncomingMessageWithGUID:](IDSDMessageStore, "deleteIncomingMessageWithGUID:", *(void *)(a1 + 40), v81, v84);
LABEL_130:
}

void sub_1003B3CEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, os_activity_scope_state_s state, char a17)
{
  if (a2 == 1)
  {
    objc_begin_catch(exception_object);
    objc_end_catch();
    JUMPOUT(0x1003B3C74);
  }
  _Unwind_Resume(exception_object);
}

void sub_1003B3E10(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) replayStateCommitter];
  [v2 commitStateForKey:*(void *)(a1 + 40)];
}

void sub_1003B3E64(uint64_t a1, void *a2)
{
  id v80 = a2;
  uint64_t v3 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v4 = *(void **)(a1 + 32);
    CFStringRef v5 = *(void **)(a1 + 40);
    *(_DWORD *)long long buf = 138412546;
    id v134 = v4;
    __int16 v135 = 2112;
    uint64_t v136 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "Broadcast will include message context %@, identifier %@", buf, 0x16u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v71 = *(void *)(a1 + 32);
    uint64_t v74 = *(void *)(a1 + 40);
    _IDSLogV();
  }
  uint64_t v6 = objc_msgSend(*(id *)(a1 + 48), "rawToken", v71, v74);
  if ([v6 length])
  {
    id v7 = [*(id *)(a1 + 56) prefixedURI];
    if ([v7 length])
    {
      uint64_t v8 = [*(id *)(a1 + 48) rawToken];
      uint64_t v9 = [*(id *)(a1 + 56) prefixedURI];
      CFStringRef v10 = (void *)_IDSCopyIDForTokenWithURI();
      id v11 = +[IDSURI URIWithPrefixedURI:v10 withServiceLoggingHint:*(void *)(a1 + 64)];
    }
    else
    {
      id v11 = 0;
    }
  }
  else
  {
    id v11 = 0;
  }

  CFStringRef v12 = [*(id *)(a1 + 72) serviceController];
  CFStringRef v13 = [v12 serviceWithIdentifier:*(void *)(a1 + 64)];

  CFStringRef v14 = +[IDSDAccountController sharedInstance];
  unsigned int v79 = [v14 accountsOnService:v13];

  int v15 = +[IDSDAccountController sharedInstance];
  uint64_t v16 = [v15 accountsOnService:v13 withType:0];
  uint64_t v17 = [v16 firstObject];

  id v18 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412802;
    id v134 = v13;
    __int16 v135 = 2112;
    uint64_t v136 = v79;
    __int16 v137 = 2112;
    CFStringRef v138 = v17;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Found Topic %@  with all accounts %@ and Going to use account %@", buf, 0x20u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    id v75 = v79;
    CFStringRef v77 = v17;
    id v72 = v13;
    _IDSLogV();
  }
  uint64_t v19 = *(void **)(a1 + 72);
  uint64_t v20 = objc_msgSend(*(id *)(a1 + 80), "prefixedURI", v72, v75, v77);
  LODWORD(v19) = [v19 shouldProxyMessageForService:v13 toIdentifier:v20];

  if (v19)
  {
    unsigned __int8 v21 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Forwarding Message To Local Device to Process and Broadcast", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    uint64_t v22 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
    id v23 = *(id *)(*(void *)(*(void *)(a1 + 152) + 8) + 40);
    if (v23) {
      CFDictionarySetValue(v22, IDSCommandKey, v23);
    }

    id v24 = *(id *)(*(void *)(*(void *)(a1 + 160) + 8) + 40);
    if (v24) {
      CFDictionarySetValue(v22, IDSProxyTopLevelPayloadKey, v24);
    }

    id v25 = *(id *)(a1 + 40);
    if (v25) {
      CFDictionarySetValue(v22, IDSProxyGuidKey, v25);
    }

    id v26 = v80;
    if (v26) {
      CFDictionarySetValue(v22, IDSProxyPayloadKey, v26);
    }

    id v27 = *(id *)(a1 + 88);
    if (v27) {
      CFDictionarySetValue(v22, IDSProxyTopicKey, v27);
    }

    double v28 = [*(id *)(a1 + 80) prefixedURI];
    if (v28) {
      CFDictionarySetValue(v22, IDSProxyToIDKey, v28);
    }

    CFStringRef v29 = [v11 prefixedURI];
    if (v29) {
      CFDictionarySetValue(v22, IDSProxyFromIDKey, v29);
    }

    +[NSDate timeIntervalSinceReferenceDate];
    id v30 = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:");
    if (v30) {
      CFDictionarySetValue(v22, IDSProxyForwardedTimeKey, v30);
    }

    id v31 = objc_alloc_init((Class)IDSSendParameters);
    [v31 setMessage:v22];
    [v31 setLocalDelivery:1];
    CFStringRef v32 = [v17 uniqueID];
    [v31 setAccountUUID:v32];

    [v31 setPriority:300];
    [v31 setTimeout:172800.0];
    id v33 = IDSDefaultPairedDevice;
    id v34 = objc_msgSend(objc_alloc((Class)NSSet), "initWithObjects:", v33, 0);
    CFStringRef v35 = +[IDSDestination destinationWithStrings:v34];
    [v31 setDestinations:v35];

    char v36 = +[NSNumber numberWithInteger:229];
    [v31 setCommand:v36];

    uint64_t v37 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "About To Send Message Over Local Link", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    [v17 sendMessageWithSendParameters:v31 willSendBlock:&stru_10098AE68 completionBlock:&stru_10098AE88];
  }
  if ([*(id *)(a1 + 96) watchOnlyService])
  {
    CFStringRef v38 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "We received a message on a service that is local only, we have kicked off a forwarding of the message if necessary, we can delete this message from our database", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    +[IDSDMessageStore deleteIncomingMessageWithGUID:*(void *)(a1 + 104)];
  }
  if (*(void *)(a1 + 112))
  {
    uint64_t v39 = *(void *)(*(void *)(a1 + 152) + 8);
    CFStringRef v40 = *(void **)(v39 + 40);
    *(void *)(v39 + 40) = &off_1009D2160;
  }
  uint64_t v41 = (uint64_t)[*(id *)(*(void *)(*(void *)(a1 + 152) + 8) + 40) integerValue];
  if (v41 > 241)
  {
    switch(v41)
    {
      case 242:
        id v55 = (id *)v129;
        v129[0] = _NSConcreteStackBlock;
        v129[1] = 3221225472;
        v129[2] = sub_1003B5AE0;
        v129[3] = &unk_10098AC20;
        v129[4] = v80;
        void v129[5] = *(id *)(a1 + 104);
        v129[6] = *(id *)(a1 + 88);
        id v130 = *(id *)(a1 + 80);
        id v131 = v11;
        id v132 = *(id *)(a1 + 32);
        id v44 = objc_retainBlock(v129);

        goto LABEL_96;
      case 243:
        v99[0] = _NSConcreteStackBlock;
        v99[1] = 3221225472;
        v99[2] = sub_1003B61E8;
        v99[3] = &unk_10098AC20;
        id v100 = v80;
        id v101 = *(id *)(a1 + 104);
        id v102 = *(id *)(a1 + 88);
        id v103 = *(id *)(a1 + 80);
        id v104 = v11;
        id v105 = *(id *)(a1 + 32);
        id v44 = objc_retainBlock(v99);

        id v48 = &v100;
        id v49 = &v101;
        id v50 = &v102;
        id v51 = (unsigned int *)&kIDSListenerCapConsumesLaunchOnDemandIncomingProtobuf;
        goto LABEL_108;
      case 244:
        goto LABEL_84;
      case 245:
        [*(id *)(a1 + 72) _processIncomingRemoteResourceTransferMessage:*(void *)(*(void *)(*(void *)(a1 + 160) + 8) + 40) forceDownload:0 guid:*(void *)(a1 + 104) context:*(void *)(a1 + 32) specificOriginatorURI:v11 broadcastTopic:*(void *)(a1 + 88) toURI:*(void *)(a1 + 80) topic:*(void *)(a1 + 64) messageContext:*(void *)(a1 + 144)];
        goto LABEL_118;
      case 246:
      case 247:
        id v42 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "Broadcasting Incoming Invitation Message top", buf, 2u);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
          _IDSLogV();
        }
        id v43 = (id *)v113;
        v113[0] = _NSConcreteStackBlock;
        v113[1] = 3221225472;
        v113[2] = sub_1003B5D14;
        v113[3] = &unk_10098AC20;
        uint8_t v113[4] = *(id *)(a1 + 136);
        v113[5] = *(id *)(a1 + 104);
        v113[6] = *(id *)(a1 + 64);
        id v114 = *(id *)(a1 + 80);
        id v115 = v11;
        id v116 = *(id *)(a1 + 32);
        id v44 = objc_retainBlock(v113);

        goto LABEL_77;
      case 248:
      case 249:
        id v47 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "Broadcasting Incoming Invitation Update Message top", buf, 2u);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
          _IDSLogV();
        }
        id v43 = (id *)v109;
        v109[0] = _NSConcreteStackBlock;
        v109[1] = 3221225472;
        v109[2] = sub_1003B5E04;
        v109[3] = &unk_10098AC20;
        void v109[4] = *(id *)(a1 + 136);
        v109[5] = *(id *)(a1 + 104);
        v109[6] = *(id *)(a1 + 64);
        id v110 = *(id *)(a1 + 80);
        id v111 = v11;
        id v112 = *(id *)(a1 + 32);
        id v44 = objc_retainBlock(v109);

LABEL_77:
        id v48 = v43 + 4;
        id v49 = v43 + 5;
        id v50 = v43 + 6;
        id v51 = (unsigned int *)&kIDSListenerCapConsumesLaunchOnDemandInvitationUpdates;
        goto LABEL_108;
      case 250:
        unint64_t v56 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "Broadcasting HomeKit Message top", buf, 2u);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
          _IDSLogV();
        }
        id v55 = (id *)v125;
        v125[0] = _NSConcreteStackBlock;
        v125[1] = 3221225472;
        v125[2] = sub_1003B5AF4;
        v125[3] = &unk_10098AC20;
        v125[4] = v80;
        v125[5] = *(id *)(a1 + 104);
        v125[6] = *(id *)(a1 + 88);
        id v126 = *(id *)(a1 + 80);
        id v127 = v11;
        id v128 = *(id *)(a1 + 32);
        id v44 = objc_retainBlock(v125);

LABEL_96:
        id v48 = v55 + 4;
        id v49 = v55 + 5;
        id v50 = v55 + 6;
        id v51 = (unsigned int *)&kIDSListenerCapConsumesLaunchOnDemandIncomingData;
        goto LABEL_108;
      case 251:
        id v57 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "Broadcasting HomeKit Report Message top", buf, 2u);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
          _IDSLogV();
        }
        v117[0] = _NSConcreteStackBlock;
        v117[1] = 3221225472;
        v117[2] = sub_1003B5BE4;
        v117[3] = &unk_10098ABF8;
        id v118 = *(id *)(a1 + 128);
        id v119 = *(id *)(a1 + 56);
        id v120 = *(id *)(a1 + 80);
        id v121 = *(id *)(a1 + 104);
        id v122 = *(id *)(a1 + 64);
        id v123 = v11;
        id v124 = *(id *)(a1 + 32);
        id v44 = objc_retainBlock(v117);

        id v48 = &v118;
        id v49 = &v119;
        id v50 = &v120;
        id v51 = (unsigned int *)&kIDSListenerCapConsumesLaunchOnDemandAccessoryReportMessages;
        goto LABEL_108;
      default:
        if (v41 != 315) {
          goto LABEL_84;
        }
        id v52 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v53 = *(void **)(a1 + 120);
          *(_DWORD *)long long buf = 138412290;
          id v134 = v53;
          _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "Got a message of type FTCommandIDEngramEncryptedMessage -- dropping, this is not supported {message: %@}", buf, 0xCu);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
        {
          uint64_t v73 = *(void *)(a1 + 120);
          _IDSLogV();
        }
        goto LABEL_118;
    }
  }
  switch(v41)
  {
    case 120:
      if (([v13 wantsRemoteErrors] & 1) != 0
        || [*(id *)(a1 + 64) isEqualToIgnoringCase:@"com.apple.madrid"])
      {
        id v54 = (id *)v93;
        v93[0] = _NSConcreteStackBlock;
        v93[1] = 3221225472;
        v93[2] = sub_1003B6374;
        v93[3] = &unk_10098AF00;
        uint64_t v97 = *(void *)(a1 + 160);
        v93[4] = *(id *)(a1 + 104);
        v93[5] = v80;
        v93[6] = *(id *)(a1 + 88);
        id v94 = *(id *)(a1 + 80);
        id v95 = v11;
        id v96 = *(id *)(a1 + 32);
        id v44 = objc_retainBlock(v93);

        goto LABEL_107;
      }
      CFStringRef v61 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
      {
        id v62 = *(void **)(a1 + 104);
        id v63 = *(void **)(a1 + 88);
        *(_DWORD *)long long buf = 138412546;
        id v134 = v62;
        __int16 v135 = 2112;
        uint64_t v136 = v63;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_ERROR, "Received IDS remote error (120) for client that can not hanlde it %@ %@", buf, 0x16u);
      }

      if (!os_log_shim_legacy_logging_enabled()) {
        goto LABEL_118;
      }
LABEL_117:
      _IDSWarnV();
      _IDSLogV();
      uint64_t v73 = *(void *)(a1 + 104);
      uint64_t v76 = *(void *)(a1 + 88);
      _IDSLogTransport();
      goto LABEL_118;
    case 121:
      id v54 = (id *)v98;
      v98[0] = _NSConcreteStackBlock;
      v98[1] = 3221225472;
      v98[2] = sub_1003B61FC;
      v98[3] = &unk_100980138;
      v98[4] = *(id *)(a1 + 136);
      v98[5] = *(id *)(a1 + 56);
      v98[6] = *(id *)(a1 + 32);
      id v44 = objc_retainBlock(v98);
      goto LABEL_107;
    case 153:
      id v45 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "Broadcasting GroupShare Message top", buf, 2u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        _IDSLogV();
      }
      id v46 = +[IDSDGroupContextController sharedInstance];
      v106[0] = _NSConcreteStackBlock;
      v106[1] = 3221225472;
      v106[2] = sub_1003B5EF4;
      v106[3] = &unk_10098AED8;
      id v107 = v80;
      id v108 = *(id *)(a1 + 104);
      [v46 groupContextForProtectionSpace:0 withCompletion:v106];

      goto LABEL_118;
  }
LABEL_84:
  if ([*(id *)(*(void *)(*(void *)(a1 + 152) + 8) + 40) integerValue] == (id)227
    && ![v80 count])
  {
    id v64 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
    {
      id v65 = *(void **)(a1 + 104);
      uint64_t v66 = *(void **)(a1 + 88);
      *(_DWORD *)long long buf = 138412546;
      id v134 = v65;
      __int16 v135 = 2112;
      uint64_t v136 = v66;
      _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_ERROR, "Received IDS message payload is empty, not delivering %@ %@", buf, 0x16u);
    }

    if (!os_log_shim_legacy_logging_enabled()) {
      goto LABEL_118;
    }
    goto LABEL_117;
  }
  id v54 = (id *)v88;
  v88[0] = _NSConcreteStackBlock;
  v88[1] = 3221225472;
  v88[2] = sub_1003B63B4;
  v88[3] = &unk_10098AF00;
  uint64_t v92 = *(void *)(a1 + 160);
  v88[4] = *(id *)(a1 + 104);
  v88[5] = v80;
  v88[6] = *(id *)(a1 + 88);
  id v89 = *(id *)(a1 + 80);
  id v90 = v11;
  id v91 = *(id *)(a1 + 32);
  id v44 = objc_retainBlock(v88);

LABEL_107:
  id v48 = v54 + 4;
  id v49 = v54 + 5;
  id v50 = v54 + 6;
  id v51 = (unsigned int *)&kIDSListenerCapConsumesLaunchOnDemandIncomingMessages;
LABEL_108:
  uint64_t v58 = *v51;

  if (v44)
  {
    CFStringRef v59 = *(void **)(a1 + 72);
    v83[0] = _NSConcreteStackBlock;
    v83[1] = 3221225472;
    v83[2] = sub_1003B63F4;
    v83[3] = &unk_10098AF28;
    id v84 = *(id *)(a1 + 104);
    id v85 = *(id *)(a1 + 88);
    id v86 = *(id *)(a1 + 64);
    CFStringRef v60 = v44;
    id v87 = v60;
    [v59 enqueueBroadcast:v83 forTopic:*(void *)(a1 + 88) entitlement:kIDSMessagingEntitlement command:*(void *)(*(void *)(*(void *)(a1 + 152) + 8) + 40) capabilities:v58 messageContext:*(void *)(a1 + 144)];

    goto LABEL_125;
  }
LABEL_118:
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  CFStringRef v82 = _os_activity_create((void *)&_mh_execute_header, "Not broadcasting", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v82, &state);
  if ([*(id *)(*(void *)(*(void *)(a1 + 152) + 8) + 40) integerValue] != (id)245)
  {
    CFStringRef v67 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v68 = *(void **)(*(void *)(*(void *)(a1 + 152) + 8) + 40);
      CFStringRef v69 = *(void **)(a1 + 88);
      id v70 = *(void **)(a1 + 104);
      *(_DWORD *)long long buf = 138412802;
      id v134 = v68;
      __int16 v135 = 2112;
      uint64_t v136 = v69;
      __int16 v137 = 2112;
      CFStringRef v138 = v70;
      _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_ERROR, "No broadcast desired for command %@ topic %@ -- deleting message with guid %@", buf, 0x20u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      uint64_t v76 = *(void *)(a1 + 88);
      uint64_t v78 = *(void *)(a1 + 104);
      uint64_t v73 = *(void *)(*(void *)(*(void *)(a1 + 152) + 8) + 40);
      _IDSLogTransport();
    }
    +[IDSDMessageStore deleteIncomingMessageWithGUID:](IDSDMessageStore, "deleteIncomingMessageWithGUID:", *(void *)(a1 + 104), v73, v76, v78);
  }
  os_activity_scope_leave(&state);
  cut_arc_os_release();

LABEL_125:
}

void sub_1003B5830(id a1, NSArray *a2, NSArray *a3, NSDictionary *a4)
{
  uint64_t v6 = a2;
  id v7 = a3;
  uint64_t v8 = a4;
  uint64_t v9 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CFStringRef v10 = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "PROXY: Will Send Block", v10, 2u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
}

void sub_1003B5928(id a1, IDSDeliveryContext *a2)
{
  id v2 = a2;
  uint64_t v3 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    id v4 = [(IDSDeliveryContext *)v2 idsResponseCode];
    id v5 = [(IDSDeliveryContext *)v2 responseError];
    unsigned int v6 = [(IDSDeliveryContext *)v2 lastCall];
    CFStringRef v7 = @"NO";
    *(_DWORD *)long long buf = 134218498;
    id v10 = v4;
    __int16 v11 = 2112;
    if (v6) {
      CFStringRef v7 = @"YES";
    }
    id v12 = v5;
    __int16 v13 = 2112;
    CFStringRef v14 = v7;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "PROXY: Completion Block %ld, %@, %@", buf, 0x20u);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    [(IDSDeliveryContext *)v2 idsResponseCode];
    uint64_t v8 = [(IDSDeliveryContext *)v2 responseError];
    [(IDSDeliveryContext *)v2 lastCall];
    _IDSLogV();
  }
}

id sub_1003B5AE0(void *a1, void *a2)
{
  return [a2 dataReceived:a1[4] withGUID:a1[5] forTopic:a1[6] toURI:a1[7] fromURI:a1[8] context:a1[9]];
}

void sub_1003B5AF4(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Broadcasting HomeKit Message brodcast block", v5, 2u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  [v3 accessoryDataReceived:a1[4] withGUID:a1[5] forTopic:a1[6] toURI:a1[7] fromURI:a1[8] context:a1[9]];
}

void sub_1003B5BE4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Broadcasting HomeKit Report Message brodcast block", buf, 2u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  uint64_t v5 = *(void *)(a1 + 32);
  unsigned int v6 = [*(id *)(a1 + 40) prefixedURI];
  CFStringRef v7 = [*(id *)(a1 + 48) prefixedURI];
  [v3 accessoryReportMessageReceived:v5 accessoryID:v6 controllerID:v7 withGUID:*(void *)(a1 + 56) forTopic:*(void *)(a1 + 64) toURI:*(void *)(a1 + 48) fromURI:*(void *)(a1 + 72) context:*(void *)(a1 + 80)];
}

void sub_1003B5D14(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Broadcasting Incoming Invitation Message block", v5, 2u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  [v3 incomingInvitation:a1[4] withGUID:a1[5] forTopic:a1[6] toURI:a1[7] fromURI:a1[8] context:a1[9]];
}

void sub_1003B5E04(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Broadcasting Incoming Invitation Update Message block", v5, 2u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  [v3 incomingInvitationUpdate:a1[4] withGUID:a1[5] forTopic:a1[6] toURI:a1[7] fromURI:a1[8] context:a1[9]];
}

void sub_1003B5EF4(uint64_t a1, void *a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_1003B5FA8;
  v5[3] = &unk_10098AEB0;
  id v6 = a2;
  uint64_t v3 = *(void *)(a1 + 32);
  id v7 = *(id *)(a1 + 40);
  id v4 = v6;
  [v4 _groupFromPublicDataRepresentation:v3 completion:v5];
}

void sub_1003B5FA8(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  if (v5 && !a3)
  {
    id v6 = +[IDSFoundationLog groupCrypto];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      id v7 = [v5 groupID];
      *(_DWORD *)long long buf = 138543362;
      __int16 v13 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Received Sent Ahead Group {groupID: %{public}@}", buf, 0xCu);
    }
    uint64_t v8 = *(void **)(a1 + 32);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_1003B6108;
    v9[3] = &unk_100981B98;
    id v10 = v5;
    id v11 = *(id *)(a1 + 40);
    [v8 cacheIncomingGroup:v10 completion:v9];
  }
}

void sub_1003B6108(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSFoundationLog groupCrypto];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = 138543619;
    id v7 = v3;
    __int16 v8 = 2113;
    uint64_t v9 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Cached Sent Ahead Group {error: %{public}@, group: %{private}@}", (uint8_t *)&v6, 0x16u);
  }

  +[IDSDMessageStore deleteIncomingMessageWithGUID:*(void *)(a1 + 40)];
}

id sub_1003B61E8(void *a1, void *a2)
{
  return [a2 protobufReceived:a1[4] withGUID:a1[5] forTopic:a1[6] toURI:a1[7] fromURI:a1[8] context:a1[9]];
}

void sub_1003B61FC(uint64_t a1, void *a2)
{
  id v3 = *(void **)(a1 + 32);
  id v4 = a2;
  id v12 = [v3 objectForKey:@"d"];
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();
  if (isKindOfClass)
  {
    int v6 = [*(id *)(a1 + 32) objectForKey:@"d"];
    uint64_t v7 = +[NSData _IDSDataFromBase64String:v6];
LABEL_5:
    __int16 v8 = (void *)v7;
    char v9 = isKindOfClass ^ 1;
    goto LABEL_7;
  }
  int v6 = [*(id *)(a1 + 32) objectForKey:@"d"];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v7 = [*(id *)(a1 + 32) objectForKey:@"d"];
    goto LABEL_5;
  }
  char v9 = 0;
  __int16 v8 = 0;
LABEL_7:
  uint64_t v10 = objc_opt_class();
  id v11 = sub_1002B4B18(v10, *(void **)(a1 + 32), @"i");
  [v4 opportunisticDataReceived:v8 withIdentifier:v11 fromURI:*(void *)(a1 + 40) context:*(void *)(a1 + 48)];

  if (v9) {
  if (isKindOfClass)
  }
}

id sub_1003B6374(void *a1, void *a2)
{
  return [a2 messageReceived:*(void *)(*(void *)(a1[10] + 8) + 40) withGUID:a1[4] withPayload:a1[5] forTopic:a1[6] toURI:a1[7] fromURI:a1[8] context:a1[9]];
}

id sub_1003B63B4(void *a1, void *a2)
{
  return [a2 messageReceived:*(void *)(*(void *)(a1[10] + 8) + 40) withGUID:a1[4] withPayload:a1[5] forTopic:a1[6] toURI:a1[7] fromURI:a1[8] context:a1[9]];
}

void sub_1003B63F4(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = a1[4];
    uint64_t v6 = a1[5];
    uint64_t v7 = a1[6];
    *(_DWORD *)long long buf = 138543874;
    uint64_t v15 = v5;
    __int16 v16 = 2114;
    uint64_t v17 = v6;
    __int16 v18 = 2114;
    uint64_t v19 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Broadcasting for received message with guid %{public}@   broadcast topic: %{public}@  (topic: %{public}@)", buf, 0x20u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v13 = a1[6];
    long long v12 = *((_OWORD *)a1 + 2);
    _IDSLogV();
  }
  if (v3)
  {
    (*(void (**)(void, id, uint64_t))(a1[7] + 16))(a1[7], v3, v8);
  }
  else
  {
    char v9 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = a1[4];
      uint64_t v11 = a1[5];
      *(_DWORD *)long long buf = 138412546;
      uint64_t v15 = v10;
      __int16 v16 = 2112;
      uint64_t v17 = v11;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "No broadcaster found - deleting incoming message %@ on topic %@ with no listeners", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      long long v12 = *((_OWORD *)a1 + 2);
      _IDSLogTransport();
    }
    +[IDSDMessageStore deleteIncomingMessageWithGUID:](IDSDMessageStore, "deleteIncomingMessageWithGUID:", a1[4], v12, v13);
  }
}

void sub_1003B6660(uint64_t a1)
{
  if ([*(id *)(a1 + 32) count])
  {
    long long v13 = 0u;
    long long v14 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    id v2 = *(id *)(a1 + 32);
    id v3 = (char *)[v2 countByEnumeratingWithState:&v11 objects:v15 count:16];
    if (v3)
    {
      uint64_t v4 = *(void *)v12;
      do
      {
        for (uint64_t i = 0; i != v3; ++i)
        {
          if (*(void *)v12 != v4) {
            objc_enumerationMutation(v2);
          }
          uint64_t v6 = OSLogHandleForIDSCategory();
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Processing bulked payload ...", buf, 2u);
          }

          if (os_log_shim_legacy_logging_enabled())
          {
            if (_IDSShouldLog()) {
              _IDSLogV();
            }
          }
          (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
        }
        id v3 = (char *)[v2 countByEnumeratingWithState:&v11 objects:v15 count:16];
      }
      while (v3);
    }
  }
  else
  {
    id v7 = *(id *)(a1 + 40);
    uint64_t v8 = v7;
    if (!v7)
    {
      id v7 = *(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
      uint64_t v8 = v7;
      if (!v7) {
        uint64_t v8 = *(void **)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
      }
    }
    id v9 = v8;

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
}

uint64_t sub_1003B68D0(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  uint64_t result = *(void *)(a1 + 40);
  if (result)
  {
    id v3 = *(uint64_t (**)(void))(result + 16);
    return v3();
  }
  return result;
}

void sub_1003B692C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v5 = *(id *)(a1 + 32);
  id v4 = v3;
  im_dispatch_after_primary_queue();
}

void sub_1003B69F4(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  uint64_t v2 = *(void *)(*(void *)(a1 + 48) + 8);
  id v3 = *(void **)(v2 + 40);
  *(void *)(v2 + 40) = 0;
}

id sub_1003B6DF0(void *a1, void *a2)
{
  return _[a2 pendingIncomingMessageWithGUID:a1[4] forTopic:a1[5] toURI:a1[6] fromURI:a1[7] context:a1[8]];
}

void sub_1003B6E04(void *a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    (*(void (**)(void))(a1[6] + 16))();
  }
  else
  {
    id v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = a1[4];
      uint64_t v6 = a1[5];
      *(_DWORD *)long long buf = 138412546;
      uint64_t v8 = v5;
      __int16 v9 = 2112;
      uint64_t v10 = v6;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "No broadcaster found - dropping update for incoming pending message %@ on topic %@ with no listeners", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      _IDSLogTransport();
    }
  }
}

id sub_1003B7938(void *a1, void *a2)
{
  return _[a2 pendingResourceWithMetadata:a1[4] guid:a1[5] forTopic:a1[6] toURI:a1[7] fromURI:a1[8] context:a1[9]];
}

void sub_1003B794C(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = a1[4];
    uint64_t v6 = a1[5];
    uint64_t v7 = a1[6];
    *(_DWORD *)long long buf = 138543874;
    uint64_t v15 = v5;
    __int16 v16 = 2114;
    uint64_t v17 = v6;
    __int16 v18 = 2114;
    uint64_t v19 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Broadcasting for pending Resource with guid %{public}@   broadcast topic: %{public}@  (topic: %{public}@)", buf, 0x20u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v13 = a1[6];
    long long v12 = *((_OWORD *)a1 + 2);
    _IDSLogV();
  }
  if (v3)
  {
    (*(void (**)(void, id, uint64_t))(a1[7] + 16))(a1[7], v3, v8);
  }
  else
  {
    __int16 v9 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = a1[4];
      uint64_t v11 = a1[5];
      *(_DWORD *)long long buf = 138412546;
      uint64_t v15 = v10;
      __int16 v16 = 2112;
      uint64_t v17 = v11;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "No broadcaster found - deleting incoming message %@ on topic %@ with no listeners", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      long long v12 = *((_OWORD *)a1 + 2);
      _IDSLogTransport();
    }
    +[IDSDMessageStore deleteIncomingMessageWithGUID:](IDSDMessageStore, "deleteIncomingMessageWithGUID:", a1[4], v12, v13);
  }
}

void sub_1003B7BB8(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5, void *a6)
{
  id v33 = a2;
  id v35 = a3;
  id v10 = a5;
  id v34 = a6;
  uint64_t v11 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    id v50 = v35;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "File Has Been Downloaded to %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  uint64_t v12 = CSDBGetMobileUserDirectory();
  if (v12)
  {
    uint64_t v13 = +[NSString stringWithUTF8String:v12];
  }
  else
  {
    uint64_t v13 = @"~";
  }
  long long v14 = +[NSArray arrayWithObjects:v13, @"/Library/IdentityServices/files/", *(void *)(a1 + 32), 0];
  uint64_t v15 = +[NSString pathWithComponents:v14];

  if (v12) {
  __int16 v16 = +[NSFileManager defaultManager];
  }
  id v48 = v10;
  [v16 createDirectoryAtPath:v15 withIntermediateDirectories:1 attributes:0 error:&v48];
  id v32 = v48;

  uint64_t v17 = sub_100384624(v35, v15);
  if (v17)
  {
    __int16 v18 = +[NSMutableDictionary dictionary];
    id v19 = v17;
    [v19 UTF8String];
    uint64_t v20 = (void *)sandbox_extension_issue_file();
    if (v20)
    {
      unsigned __int8 v21 = +[NSString stringWithUTF8String:v20];
      if (v21) {
        CFDictionarySetValue(v18, IDSMessageResourceTransferSandboxExtensionKey, v21);
      }

      free(v20);
    }
    else
    {
      uint64_t v22 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v50 = v19;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Failed to issue sandbox extension for file [%@]", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        if (MarcoShouldLog()) {
          MarcoLog();
        }
        if (IMShouldLog()) {
          IMLogString();
        }
      }
    }
    CFDictionarySetValue(v18, IDSMessageResourceTransferURLKey, v19);
    id v23 = [*(id *)(a1 + 40) objectForKey:@"attach-meta"];
    if (v23) {
      CFDictionarySetValue(v18, IDSMessageResourceTransferMetadataKey, v23);
    }

    id v24 = [*(id *)(a1 + 48) mutableCopy];
    [v24 addEntriesFromDictionary:v18];
    v41[0] = _NSConcreteStackBlock;
    v41[1] = 3221225472;
    v41[2] = sub_1003B81EC;
    v41[3] = &unk_10098AC20;
    id v42 = v18;
    id v43 = *(id *)(a1 + 32);
    id v44 = *(id *)(a1 + 56);
    id v45 = *(id *)(a1 + 64);
    id v46 = *(id *)(a1 + 72);
    id v47 = v24;
    id v25 = v24;
    id v31 = v18;
    id v26 = objc_retainBlock(v41);
    id v27 = *(void **)(a1 + 80);
    v36[0] = _NSConcreteStackBlock;
    v36[1] = 3221225472;
    v36[2] = sub_1003B8224;
    v36[3] = &unk_10098AF28;
    id v37 = *(id *)(a1 + 32);
    id v38 = *(id *)(a1 + 56);
    id v39 = *(id *)(a1 + 88);
    id v40 = v26;
    uint64_t v28 = *(void *)(a1 + 56);
    CFStringRef v29 = v26;
    id v30 = +[NSNumber numberWithInteger:245];
    [v27 enqueueBroadcast:v36 forTopic:v28 entitlement:kIDSMessagingEntitlement command:v30 capabilities:kIDSListenerCapConsumesLaunchOnDemandIncomingResource messageContext:*(void *)(a1 + 96)];
  }
  else
  {
    +[IDSDMessageStore deleteIncomingMessageWithGUID:*(void *)(a1 + 32)];
  }
}

id sub_1003B81EC(void *a1, void *a2)
{
  return [a2 messageReceived:a1[4] withGUID:a1[5] withPayload:a1[4] forTopic:a1[6] toURI:a1[7] fromURI:a1[8] context:a1[9]];
}

void sub_1003B8224(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = a1[4];
    uint64_t v6 = a1[5];
    uint64_t v7 = a1[6];
    *(_DWORD *)long long buf = 138543874;
    uint64_t v15 = v5;
    __int16 v16 = 2114;
    uint64_t v17 = v6;
    __int16 v18 = 2114;
    uint64_t v19 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Broadcasting for received message with guid %{public}@   broadcast topic: %{public}@  (topic: %{public}@)", buf, 0x20u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v13 = a1[6];
    long long v12 = *((_OWORD *)a1 + 2);
    _IDSLogV();
  }
  if (v3)
  {
    (*(void (**)(void, id, uint64_t))(a1[7] + 16))(a1[7], v3, v8);
  }
  else
  {
    __int16 v9 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = a1[4];
      uint64_t v11 = a1[5];
      *(_DWORD *)long long buf = 138412546;
      uint64_t v15 = v10;
      __int16 v16 = 2112;
      uint64_t v17 = v11;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "No broadcaster found - deleting incoming message %@ on topic %@ with no listeners", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      long long v12 = *((_OWORD *)a1 + 2);
      _IDSLogTransport();
    }
    +[IDSDMessageStore deleteIncomingMessageWithGUID:](IDSDMessageStore, "deleteIncomingMessageWithGUID:", a1[4], v12, v13);
  }
}

void sub_1003B8A4C(_Unwind_Exception *a1)
{
  os_activity_scope_leave((os_activity_scope_state_t)(v1 - 112));
  cut_arc_os_release();
  _Unwind_Resume(a1);
}

void sub_1003B8AB8(uint64_t a1, void *a2, char a3)
{
  id v5 = a2;
  uint64_t v6 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a1 + 32);
    *(_DWORD *)long long buf = 138412546;
    id v12 = v5;
    __int16 v13 = 2112;
    uint64_t v14 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Storing item from server storage %@  (%@)", buf, 0x16u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  if ((a3 & 1) == 0)
  {
    uint64_t v8 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = *(void *)(a1 + 32);
      *(_DWORD *)long long buf = 138412546;
      id v12 = v5;
      __int16 v13 = 2112;
      uint64_t v14 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Persisting failed for message %@  (%@)", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      _IDSLogTransport();
    }
  }
  uint64_t v10 = *(void **)(a1 + 40);
  if (*(unsigned char *)(a1 + 56)) {
    [v10 _noteLastItemFromStorage:v5];
  }
  else {
    [v10 _noteItemFromStorage:v5];
  }
}

id sub_1003B9108(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _storageTimerFired];
}

void sub_1003B9560(uint64_t a1)
{
  uint64_t v2 = +[IDSDMessageStore sharedInstance];
  id v3 = [v2 deleteExpiredIncomingRestrictedMessagesOlderThan:*(double *)(a1 + 40)];

  id v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    uint64_t v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Calling replay commit for expired incoming messages %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v7 = v3;
    _IDSLogV();
  }
  objc_msgSend(*(id *)(a1 + 32), "_callReplayCommitBlockForIncomingMessages:", v3, v7);
  id v5 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void **)(*(void *)(a1 + 32) + 480);
    *(_DWORD *)long long buf = 138412290;
    uint64_t v9 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Replay key map state: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
}

id sub_1003B9950(uint64_t a1)
{
  return [*(id *)(a1 + 32) _restrictedMessageCleanupTimerFired];
}

void sub_1003B9CC4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (v3)
  {
    [v3 checkTransportLogWithReason:0];
  }
  else
  {
    id v5 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(void *)(a1 + 32);
      *(_DWORD *)long long buf = 138412290;
      uint64_t v8 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Failed to hint service to check transport log {service: %@, reason: connected}", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
  }
}

BOOL sub_1003BA510(id a1, id a2)
{
  id v2 = a2;
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();

  return isKindOfClass & 1;
}

void sub_1003BAD34(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) serviceController];
  id v3 = [v2 serviceWithPushTopic:*(void *)(a1 + 40)];

  id v4 = +[IDSDAccountController sharedInstance];
  id v5 = [v4 appleIDAccountOnService:v3];

  if ([v5 isRegistered])
  {
    uint64_t v6 = [v5 prefixedURIStringsFromRegistration];
    uint64_t v7 = [v6 firstObject];

    uint64_t v8 = (void *)v7;
  }
  else
  {
    uint64_t v8 = 0;
  }
  uint64_t v9 = *(void *)(a1 + 40);
  uint64_t v10 = *(void **)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 48);
  uint64_t v12 = *(void *)(a1 + 56);
  uint64_t v20 = v8;
  __int16 v13 = +[IDSURI URIWithPrefixedURI:withServiceLoggingHint:](IDSURI, "URIWithPrefixedURI:withServiceLoggingHint:");
  uint64_t v14 = +[IDSURI URIWithPrefixedURI:*(void *)(a1 + 64) withServiceLoggingHint:*(void *)(a1 + 40)];
  LOBYTE(v9) = [v10 _processNonMessagingPayloadWithCommand:v11 dictionaryPayload:v12 senderPushToken:0 topic:v9 toURI:v13 fromURI:v14 peerResponseIdentifier:0 guid:0 service:v3 idsMessageContext:0 messageContext:0];

  if ((v9 & 1) == 0)
  {
    uint64_t v15 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = *(void *)(a1 + 40);
      uint64_t v17 = *(void *)(a1 + 48);
      uint64_t v19 = *(void *)(a1 + 56);
      uint64_t v18 = *(void *)(a1 + 64);
      *(_DWORD *)long long buf = 138544131;
      uint64_t v22 = v16;
      __int16 v23 = 2114;
      uint64_t v24 = v17;
      __int16 v25 = 2113;
      uint64_t v26 = v18;
      __int16 v27 = 2113;
      uint64_t v28 = v19;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Received a message over Bonjour Delivery that we can't process! -- dropping {service: %{public}@, command: %{public}@, deviceID: %{private}@, message: %{private}@}", buf, 0x2Au);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
  }
}

void sub_1003BB6C0(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  uint64_t v6 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a1 + 32);
    *(_DWORD *)long long buf = 138412802;
    uint64_t v9 = v7;
    __int16 v10 = 2112;
    id v11 = v5;
    __int16 v12 = 1024;
    int v13 = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Stored incoming message under first lock for service %@ with guid %@. Success: %d", buf, 0x1Cu);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      _IDSLogTransport();
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
  }
}

void sub_1003BBD88(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) serviceController];
  id v3 = [v2 serviceWithPushTopic:*(void *)(a1 + 40)];

  objc_msgSend(*(id *)(a1 + 32), "_ackMessageWithSequenceNumber:forDeviceID:priority:dataProtectionClass:connectionType:guid:", objc_msgSend(*(id *)(a1 + 48), "unsignedIntValue"), *(void *)(a1 + 56), *(void *)(a1 + 72), objc_msgSend(v3, "dataProtectionClass"), *(void *)(a1 + 80), *(void *)(a1 + 64));
}

void sub_1003BBE38(uint64_t a1)
{
  id v2 = (id *)(a1 + 32);
  id v3 = [*(id *)(a1 + 32) serviceController];
  id v4 = [v3 serviceWithPushTopic:*(void *)(a1 + 40)];

  if (![*v2 _shouldStoreBeforeFirstUnlockIncomingLocalMessage:*(void *)(a1 + 48) from:*(void *)(a1 + 56) forTopic:*(void *)(a1 + 40)])
  {
    if (sub_100384524((char)[v4 shouldProtectTrafficUsingClassA], (int)objc_msgSend(v4, "dataProtectionClass"), *(void **)(a1 + 40)))
    {
      id v5 = *(void **)(a1 + 32);
      uint64_t v6 = [*(id *)(a1 + 88) data];
      uint64_t v7 = *(void *)(a1 + 40);
      uint64_t v8 = +[IDSPairingManager sharedInstance];
      uint64_t v9 = [v8 pairedDeviceUniqueID];
      id v35 = 0;
      __int16 v10 = [v5 _decryptAOverCMessage:v6 topic:v7 fromDeviceID:v9 error:&v35];
      id v11 = v35;

      if (!v10)
      {
        uint64_t v19 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v20 = *(void *)(a1 + 40);
          *(_DWORD *)long long buf = 138412546;
          uint64_t v37 = v20;
          __int16 v38 = 2112;
          id v39 = v11;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Failed to decrypt AoverC message -- dropping {topic: %@, error: %@}", buf, 0x16u);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
          _IDSLogV();
        }
        unsigned __int8 v21 = im_primary_queue();
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_1003BC228;
        block[3] = &unk_10098AD68;
        void block[4] = *(void *)(a1 + 32);
        id v29 = *(id *)(a1 + 64);
        id v22 = *(id *)(a1 + 72);
        uint64_t v23 = *(void *)(a1 + 104);
        id v30 = v22;
        uint64_t v33 = v23;
        id v24 = v4;
        uint64_t v25 = *(void *)(a1 + 112);
        id v31 = v24;
        uint64_t v34 = v25;
        id v32 = *(id *)(a1 + 80);
        dispatch_block_t v26 = dispatch_block_create(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, block);
        dispatch_async(v21, v26);

        goto LABEL_7;
      }
      [*(id *)(a1 + 88) setData:v10];
    }
    __int16 v12 = *(void **)(a1 + 32);
    id v11 = [*(id *)(a1 + 88) dictionaryRepresentation];
    uint64_t v13 = *(void *)(a1 + 96);
    uint64_t v14 = *(void *)(a1 + 72);
    uint64_t v15 = *(void *)(a1 + 56);
    uint64_t v16 = *(void *)(a1 + 40);
    uint64_t v17 = [*(id *)(a1 + 48) objectForKey:@"IDSIncomingLocalMessageContext"];
    uint64_t v18 = +[NSNumber numberWithInteger:*(void *)(a1 + 104)];
    LOBYTE(v27) = *(unsigned char *)(a1 + 120);
    [v12 _processIncomingLocalMessage:v11 topic:v16 command:v13 deviceID:v14 btUUID:v15 context:v17 storedGUID:0 priority:v18 connectionType:*(void *)(a1 + 112) didWakeHint:v27];

LABEL_7:
    goto LABEL_8;
  }
  objc_msgSend(*(id *)(a1 + 32), "_ackMessageWithSequenceNumber:forDeviceID:priority:dataProtectionClass:connectionType:guid:", objc_msgSend(*(id *)(a1 + 64), "unsignedIntValue"), *(void *)(a1 + 72), *(void *)(a1 + 104), objc_msgSend(v4, "dataProtectionClass"), *(void *)(a1 + 112), *(void *)(a1 + 80));
LABEL_8:
}

id sub_1003BC228(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = [*(id *)(a1 + 40) unsignedIntValue];
  uint64_t v4 = *(void *)(a1 + 72);
  uint64_t v5 = *(void *)(a1 + 48);
  id v6 = [*(id *)(a1 + 56) dataProtectionClass];
  uint64_t v7 = *(void *)(a1 + 80);
  uint64_t v8 = *(void *)(a1 + 64);

  return [v2 _ackMessageWithSequenceNumber:v3 forDeviceID:v5 priority:v4 dataProtectionClass:v6 connectionType:v7 guid:v8];
}

void sub_1003BC7D8(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) serviceController];
  id v3 = [v2 serviceWithPushTopic:*(void *)(a1 + 40)];

  objc_msgSend(*(id *)(a1 + 32), "_ackMessageWithSequenceNumber:forDeviceID:priority:dataProtectionClass:connectionType:guid:", objc_msgSend(*(id *)(a1 + 48), "unsignedIntValue"), *(void *)(a1 + 56), *(void *)(a1 + 72), objc_msgSend(v3, "dataProtectionClass"), *(void *)(a1 + 80), *(void *)(a1 + 64));
}

void sub_1003BC888(uint64_t a1)
{
  id v2 = (id *)(a1 + 32);
  id v3 = [*(id *)(a1 + 32) serviceController];
  uint64_t v4 = [v3 serviceWithPushTopic:*(void *)(a1 + 40)];

  if ([*v2 _shouldStoreBeforeFirstUnlockIncomingLocalMessage:*(void *)(a1 + 48) from:*(void *)(a1 + 56) forTopic:*(void *)(a1 + 40)])
  {
    objc_msgSend(*(id *)(a1 + 32), "_ackMessageWithSequenceNumber:forDeviceID:priority:dataProtectionClass:connectionType:guid:", objc_msgSend(*(id *)(a1 + 64), "unsignedIntValue"), *(void *)(a1 + 72), *(void *)(a1 + 104), objc_msgSend(v4, "dataProtectionClass"), *(void *)(a1 + 112), *(void *)(a1 + 80));
  }
  else
  {
    int v5 = sub_100384524((char)[v4 shouldProtectTrafficUsingClassA], (int)objc_msgSend(v4, "dataProtectionClass"), *(void **)(a1 + 40));
    uint64_t v6 = *(void *)(a1 + 88);
    uint64_t v8 = *(void **)(a1 + 32);
    uint64_t v7 = *(void *)(a1 + 40);
    if (v5)
    {
      uint64_t v9 = +[IDSPairingManager sharedInstance];
      __int16 v10 = [v9 pairedDeviceUniqueID];
      id v41 = 0;
      id v11 = [v8 _decryptAOverCMessage:v6 topic:v7 fromDeviceID:v10 error:&v41];
      id v12 = v41;

      if (v11)
      {

        uint64_t v14 = *(void **)(a1 + 32);
        uint64_t v13 = *(void *)(a1 + 40);
        uint64_t v15 = *(void *)(a1 + 96);
        uint64_t v16 = *(void *)(a1 + 72);
        uint64_t v17 = *(void *)(a1 + 56);
        uint64_t v18 = [*(id *)(a1 + 48) objectForKey:@"IDSIncomingLocalMessageContext"];
        uint64_t v19 = +[NSNumber numberWithInteger:*(void *)(a1 + 104)];
        LOBYTE(v33) = *(unsigned char *)(a1 + 120);
        [v14 _processIncomingLocalMessage:v11 topic:v13 command:v15 deviceID:v16 btUUID:v17 context:v18 storedGUID:0 priority:v19 connectionType:*(void *)(a1 + 112) didWakeHint:v33];
      }
      else
      {
        uint64_t v25 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v26 = *(void *)(a1 + 40);
          *(_DWORD *)long long buf = 138412546;
          uint64_t v43 = v26;
          __int16 v44 = 2112;
          id v45 = v12;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Failed to decrypt AoverC message -- dropping {topic: %@, error: %@}", buf, 0x16u);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
          _IDSLogV();
        }
        uint64_t v27 = im_primary_queue();
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_1003BCCBC;
        block[3] = &unk_10098AD68;
        void block[4] = *(void *)(a1 + 32);
        id v35 = *(id *)(a1 + 64);
        id v28 = *(id *)(a1 + 72);
        uint64_t v29 = *(void *)(a1 + 104);
        id v36 = v28;
        uint64_t v39 = v29;
        id v30 = v4;
        uint64_t v31 = *(void *)(a1 + 112);
        id v37 = v30;
        uint64_t v40 = v31;
        id v38 = *(id *)(a1 + 80);
        dispatch_block_t v32 = dispatch_block_create(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, block);
        dispatch_async(v27, v32);
      }
    }
    else
    {
      uint64_t v20 = *(void *)(a1 + 96);
      uint64_t v21 = *(void *)(a1 + 72);
      uint64_t v22 = *(void *)(a1 + 56);
      uint64_t v23 = [*(id *)(a1 + 48) objectForKey:@"IDSIncomingLocalMessageContext"];
      id v24 = +[NSNumber numberWithInteger:*(void *)(a1 + 104)];
      LOBYTE(v33) = *(unsigned char *)(a1 + 120);
      [v8 _processIncomingLocalMessage:v6 topic:v7 command:v20 deviceID:v21 btUUID:v22 context:v23 storedGUID:0 priority:v24 connectionType:*(void *)(a1 + 112) didWakeHint:v33];
    }
  }
}

id sub_1003BCCBC(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = [*(id *)(a1 + 40) unsignedIntValue];
  uint64_t v4 = *(void *)(a1 + 72);
  uint64_t v5 = *(void *)(a1 + 48);
  id v6 = [*(id *)(a1 + 56) dataProtectionClass];
  uint64_t v7 = *(void *)(a1 + 80);
  uint64_t v8 = *(void *)(a1 + 64);

  return [v2 _ackMessageWithSequenceNumber:v3 forDeviceID:v5 priority:v4 dataProtectionClass:v6 connectionType:v7 guid:v8];
}

void sub_1003BD248(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) serviceController];
  id v3 = [v2 serviceWithPushTopic:*(void *)(a1 + 40)];

  objc_msgSend(*(id *)(a1 + 32), "_ackMessageWithSequenceNumber:forDeviceID:priority:dataProtectionClass:connectionType:guid:", objc_msgSend(*(id *)(a1 + 48), "unsignedIntValue"), *(void *)(a1 + 56), *(void *)(a1 + 72), objc_msgSend(v3, "dataProtectionClass"), *(void *)(a1 + 80), *(void *)(a1 + 64));
}

void sub_1003BD2F8(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) serviceController];
  id v3 = [v2 serviceWithPushTopic:*(void *)(a1 + 40)];

  uint64_t v4 = +[IDSDAccountController sharedInstance];
  id v47 = [v4 appleIDAccountOnService:v3];

  uint64_t v5 = v47;
  if ([v47 isRegistered])
  {
    id v6 = [v47 prefixedURIStringsFromRegistration];
    id v45 = [v6 firstObject];

    uint64_t v5 = v47;
  }
  else
  {
    id v45 = 0;
  }
  id v48 = [v5 fromIDForCBUUID:*(void *)(a1 + 48) deviceID:*(void *)(a1 + 56)];
  if (!v48)
  {
    uint64_t v7 = +[IDSPairingManager sharedInstance];
    uint64_t v8 = [v7 pairedDeviceUniqueID];
    id v48 = (void *)_IDSCopyIDForDeviceUniqueID();
  }
  int v9 = sub_100384524((char)[v3 shouldProtectTrafficUsingClassA], (int)objc_msgSend(v3, "dataProtectionClass"), *(void **)(a1 + 40));
  if (v9) {
    goto LABEL_8;
  }
  __int16 v10 = JWDecodeDictionary();
  uint64_t v11 = *(void *)(a1 + 40);
  id v12 = *(void **)(a1 + 32);
  uint64_t v13 = *(void *)(a1 + 72);
  uint64_t v14 = +[IDSURI URIWithPrefixedURI:v45 withServiceLoggingHint:v11];
  uint64_t v15 = +[IDSURI URIWithPrefixedURI:v48 withServiceLoggingHint:*(void *)(a1 + 40)];
  LOBYTE(v12) = [v12 _processNonMessagingPayloadWithCommand:v13 dictionaryPayload:v10 senderPushToken:0 topic:v11 toURI:v14 fromURI:v15 peerResponseIdentifier:0 guid:0 service:v3 idsMessageContext:0 messageContext:0];

  if ((v12 & 1) == 0)
  {
LABEL_8:
    LOWORD(v42) = *(_WORD *)(a1 + 120);
    id v46 = objc_msgSend(*(id *)(a1 + 32), "_incomingMessageStorageDictionaryForPayload:topic:deviceID:btUUID:command:messageUUID:sequenceNumber:wantsAppAck:expectsPeerResponse:peerResponseIdentifier:", *(void *)(a1 + 64), *(void *)(a1 + 40), *(void *)(a1 + 56), *(void *)(a1 + 48), *(void *)(a1 + 72), *(void *)(a1 + 80), *(void *)(a1 + 88), v42, *(void *)(a1 + 96));
    if ([*(id *)(a1 + 32) _shouldStoreBeforeFirstUnlockIncomingLocalMessage:v46 from:*(void *)(a1 + 48) forTopic:*(void *)(a1 + 40)])
    {
      objc_msgSend(*(id *)(a1 + 32), "_ackMessageWithSequenceNumber:forDeviceID:priority:dataProtectionClass:connectionType:guid:", objc_msgSend(*(id *)(a1 + 88), "unsignedIntValue"), *(void *)(a1 + 56), *(void *)(a1 + 104), objc_msgSend(v3, "dataProtectionClass"), *(void *)(a1 + 112), *(void *)(a1 + 80));
LABEL_18:

      goto LABEL_19;
    }
    if (v9)
    {
      uint64_t v16 = *(void *)(a1 + 40);
      uint64_t v17 = +[IDSPairingManager sharedInstance];
      uint64_t v18 = [v17 pairedDeviceUniqueID];
      unsigned int v19 = +[IDSEncryptionHelpers areDataProtectionKeysAvailableForService:v16 withDataProtectionClass:1 fromDevice:v18];

      if (v19)
      {
        uint64_t v20 = *(void *)(a1 + 64);
        uint64_t v22 = *(void **)(a1 + 32);
        uint64_t v21 = *(void *)(a1 + 40);
        uint64_t v23 = +[IDSPairingManager sharedInstance];
        id v24 = [v23 pairedDeviceUniqueID];
        id v56 = 0;
        uint64_t v44 = [v22 _decryptAOverCMessage:v20 topic:v21 fromDeviceID:v24 error:&v56];
        id v25 = v56;

        if (!v44)
        {
          uint64_t v34 = OSLogHandleForIDSCategory();
          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v35 = *(void *)(a1 + 40);
            *(_DWORD *)long long buf = 138412546;
            uint64_t v58 = v35;
            __int16 v59 = 2112;
            id v60 = v25;
            _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Failed to decrypt AoverC message -- dropping {topic: %@, error: %@}", buf, 0x16u);
          }

          if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
            _IDSLogV();
          }
          id v36 = im_primary_queue();
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472;
          block[2] = sub_1003BD8E8;
          block[3] = &unk_10098AD68;
          void block[4] = *(void *)(a1 + 32);
          id v50 = *(id *)(a1 + 88);
          id v37 = *(id *)(a1 + 56);
          uint64_t v38 = *(void *)(a1 + 104);
          id v51 = v37;
          uint64_t v54 = v38;
          id v39 = v3;
          uint64_t v40 = *(void *)(a1 + 112);
          id v52 = v39;
          uint64_t v55 = v40;
          id v53 = *(id *)(a1 + 80);
          dispatch_block_t v41 = dispatch_block_create(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, block);
          dispatch_async(v36, v41);

          goto LABEL_17;
        }

        uint64_t v26 = JWDecodeDictionary();
      }
      else
      {
        uint64_t v44 = 0;
        uint64_t v26 = 0;
      }
    }
    else
    {
      uint64_t v26 = JWDecodeDictionary();
      uint64_t v44 = 0;
    }
    uint64_t v27 = *(void **)(a1 + 32);
    uint64_t v28 = *(void *)(a1 + 40);
    uint64_t v29 = *(void *)(a1 + 72);
    uint64_t v31 = *(void *)(a1 + 48);
    uint64_t v30 = *(void *)(a1 + 56);
    dispatch_block_t v32 = [v46 objectForKey:@"IDSIncomingLocalMessageContext"];
    uint64_t v33 = +[NSNumber numberWithInteger:*(void *)(a1 + 104)];
    LOBYTE(v43) = *(unsigned char *)(a1 + 122);
    [v27 _processIncomingLocalMessage:v26 topic:v28 command:v29 deviceID:v30 btUUID:v31 context:v32 storedGUID:0 priority:v33 connectionType:*(void *)(a1 + 112) didWakeHint:v43];

    id v25 = (id)v44;
LABEL_17:

    goto LABEL_18;
  }
LABEL_19:
}

id sub_1003BD8E8(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = [*(id *)(a1 + 40) unsignedIntValue];
  uint64_t v4 = *(void *)(a1 + 72);
  uint64_t v5 = *(void *)(a1 + 48);
  id v6 = [*(id *)(a1 + 56) dataProtectionClass];
  uint64_t v7 = *(void *)(a1 + 80);
  uint64_t v8 = *(void *)(a1 + 64);

  return [v2 _ackMessageWithSequenceNumber:v3 forDeviceID:v5 priority:v4 dataProtectionClass:v6 connectionType:v7 guid:v8];
}

void sub_1003BDC18(uint64_t a1)
{
  if (([*(id *)(a1 + 32) _shouldStoreBeforeFirstUnlockIncomingLocalMessage:*(void *)(a1 + 40) from:*(void *)(a1 + 48) forTopic:*(void *)(a1 + 56)] & 1) == 0)
  {
    uint64_t v2 = *(void *)(a1 + 64);
    uint64_t v3 = *(void *)(a1 + 72);
    uint64_t v5 = *(void *)(a1 + 48);
    uint64_t v4 = *(void *)(a1 + 56);
    id v6 = *(void **)(a1 + 32);
    id v9 = [*(id *)(a1 + 40) objectForKey:@"IDSIncomingLocalMessageContext"];
    uint64_t v7 = +[NSNumber numberWithInteger:*(void *)(a1 + 80)];
    LOBYTE(v8) = 0;
    [v6 _processIncomingLocalMessage:0 topic:v4 command:v2 deviceID:v3 btUUID:v5 context:v9 storedGUID:0 priority:v7 connectionType:*(void *)(a1 + 88) didWakeHint:v8];
  }
}

void sub_1003BE704(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 144), 8);
  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Unwind_Resume(a1);
}

void sub_1003BE728(uint64_t a1, void *a2, void *a3, void *a4, int a5, int a6)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a4;
  if (a6)
  {
    uint64_t v14 = *(void **)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
    if (v14)
    {
      [v14 cancel];
      [*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) _unpublish];
      uint64_t v15 = *(void *)(*(void *)(a1 + 64) + 8);
      uint64_t v16 = *(void **)(v15 + 40);
      *(void *)(v15 + 40) = 0;
    }
    goto LABEL_37;
  }
  id v17 = [v12 integerValue];
  uint64_t v18 = (uint64_t)[v13 integerValue];
  id v19 = (id)v18;
  if (!a5) {
    goto LABEL_11;
  }
  uint64_t v20 = *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24);
  if (v20 == -1) {
    goto LABEL_11;
  }
  if (*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) == -1 || v17 == (id)v18) {
    goto LABEL_11;
  }
  uint64_t v60 = (uint64_t)v17 - v20;
  if (v60 < 0) {
    uint64_t v60 = -v60;
  }
  if ((unint64_t)v60 >> 7 >= 0x7D)
  {
    if (100 * v60 / v18)
    {
      [*(id *)(*(void *)(*(void *)(a1 + 88) + 8) + 40) timeIntervalSinceNow];
      if (v61 <= -1.0)
      {
LABEL_11:
        uint64_t v22 = *(void **)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
        if (v22)
        {
          [v22 setByteTotalCount:v13];
          [*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) setByteCompletedCount:v12];
        }
        else
        {
          CFStringRef v67 = [*(id *)(a1 + 32) message];
          uint64_t v23 = [v67 objectForKeyedSubscript:IDSMessageResourceTransferOriginalURLKey];
          if (v23)
          {
            id v24 = [objc_alloc((Class)NSProgress) initWithParent:0 userInfo:0];
            uint64_t v25 = *(void *)(*(void *)(a1 + 64) + 8);
            uint64_t v26 = *(void **)(v25 + 40);
            *(void *)(v25 + 40) = v24;

            [*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) setTotalUnitCount:1];
            uint64_t v27 = +[NSURL URLWithString:v23];
            [*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) setFileURL:v27];

            [*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) setByteTotalCount:v13];
            [*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) setByteCompletedCount:v12];
            [*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) setKind:NSProgressKindFile];
            [*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) setCancellable:0];
            [*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) setPausable:0];
            [*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) setFileOperationKind:NSProgressFileOperationKindCopying];
            uint64_t v28 = *(void **)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
            uint64_t v29 = +[NSURL URLWithString:v23];
            [v28 setUserInfoObject:v29 forKey:NSProgressFileURLKey];

            uint64_t v30 = *(void **)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
            uint64_t v31 = [*(id *)(a1 + 32) identifier];
            [v30 setUserInfoObject:v31 forKey:IDSSendResourceProgressIdentifier];

            [*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) _publish];
          }
        }
        if (v17 == v19)
        {
          dispatch_block_t v32 = *(void **)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
          if (v32)
          {
            [v32 setCompletedUnitCount:1];
            [*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) _unpublish];
            uint64_t v33 = *(void *)(*(void *)(a1 + 64) + 8);
            uint64_t v34 = *(void **)(v33 + 40);
            *(void *)(v33 + 40) = 0;
          }
        }
        *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) = v17;
        *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) = v19;
        uint64_t v35 = +[NSDate date];
        uint64_t v36 = *(void *)(*(void *)(a1 + 88) + 8);
        id v37 = *(void **)(v36 + 40);
        *(void *)(v36 + 40) = v35;

        uint64_t v38 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
        id v39 = v38;
        if (v12) {
          CFDictionarySetValue(v38, IDSMessageContextBytesSent, v12);
        }
        if (v13) {
          CFDictionarySetValue(v39, IDSMessageContextTotalBytes, v13);
        }
        uint64_t v40 = [*(id *)(a1 + 40) localObject];
        if (v40
          && ([*(id *)(a1 + 40) localObject],
              dispatch_block_t v41 = objc_claimAutoreleasedReturnValue(),
              unsigned int v42 = [v41 isValid],
              v41,
              v40,
              v42))
        {
          uint64_t v43 = *(void **)(a1 + 48);
          uint64_t v44 = [*(id *)(a1 + 40) localObject];
          id v45 = [v43 broadcasterForLocalObject:v44 messageContext:*(void *)(a1 + 40)];

          if (!v45)
          {
LABEL_35:

            goto LABEL_36;
          }
          id v46 = OSLogHandleForIDSCategory();
          if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
          {
            id v47 = [*(id *)(a1 + 32) identifier];
            id v48 = [v11 idsResponseCode];
            id v49 = [v11 responseError];
            *(_DWORD *)long long buf = 138413314;
            id v75 = v47;
            __int16 v76 = 2048;
            id v77 = v48;
            __int16 v78 = 2112;
            unsigned int v79 = v49;
            __int16 v80 = 2112;
            id v81 = v12;
            __int16 v82 = 2112;
            id v83 = v13;
            _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "Sending update to listener on %@ with responseCode %ld error %@ - %@/%@ bytes", buf, 0x34u);
          }
          if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
          {
            id v50 = [*(id *)(a1 + 32) identifier];
            id v51 = [v11 idsResponseCode];
            [v11 responseError];
            id v65 = v12;
            id v66 = v13;
            v64 = id v63 = v51;
            id v62 = v50;
            _IDSLogV();
          }
          id v53 = *(void **)(a1 + 32);
          id v52 = (id *)(a1 + 32);
          uint64_t v54 = objc_msgSend(v53, "identifier", v62, v63, v64, v65, v66);
          uint64_t v55 = [*v52 alternateCallbackID];
          id v56 = [*v52 mainAccountUUID];
          id v57 = [v11 idsResponseCode];
          uint64_t v58 = [v11 responseError];
          -[IDSIncomingMessageBroadcast messageIdentifier:alternateCallbackID:forAccount:updatedWithResponseCode:error:lastCall:context:](v45, "messageIdentifier:alternateCallbackID:forAccount:updatedWithResponseCode:error:lastCall:context:", v54, v55, v56, v57, v58, [v11 lastCall], v39);
        }
        else
        {
          if (!*(void *)(a1 + 56))
          {
LABEL_36:

            goto LABEL_37;
          }
          id v45 = objc_alloc_init(IDSIncomingMessageBroadcast);
          [(IDSIncomingMessageBroadcast *)v45 setTransient:1];
          __int16 v59 = *(void **)(a1 + 48);
          v68[0] = _NSConcreteStackBlock;
          v68[1] = 3221225472;
          v68[2] = sub_1003BEE9C;
          v68[3] = &unk_100981B28;
          id v69 = *(id *)(a1 + 32);
          id v70 = v11;
          id v71 = v12;
          id v72 = v13;
          uint64_t v73 = v39;
          [v59 enqueueIncomingMessageBroadcast:v68 broadcastData:v45 forTopic:*(void *)(a1 + 56) entitlement:kIDSMessagingEntitlement command:0 capabilities:0 messageContext:0];

          uint64_t v54 = v69;
        }

        goto LABEL_35;
      }
    }
  }
LABEL_37:
}

void sub_1003BEE9C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    uint64_t v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      id v5 = [*(id *)(a1 + 32) identifier];
      id v6 = [*(id *)(a1 + 40) idsResponseCode];
      uint64_t v7 = [*(id *)(a1 + 40) responseError];
      uint64_t v8 = *(void *)(a1 + 48);
      uint64_t v9 = *(void *)(a1 + 56);
      *(_DWORD *)long long buf = 138413314;
      id v24 = v5;
      __int16 v25 = 2048;
      id v26 = v6;
      __int16 v27 = 2112;
      uint64_t v28 = v7;
      __int16 v29 = 2112;
      uint64_t v30 = v8;
      __int16 v31 = 2112;
      uint64_t v32 = v9;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Broadcasting update to listener on %@ with responseCode %ld error %@ %@/%@ bytes", buf, 0x34u);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      __int16 v10 = [*(id *)(a1 + 32) identifier];
      id v11 = [*(id *)(a1 + 40) idsResponseCode];
      id v12 = [*(id *)(a1 + 40) responseError];
      uint64_t v21 = *(void *)(a1 + 48);
      uint64_t v22 = *(void *)(a1 + 56);
      id v19 = v11;
      uint64_t v20 = v12;
      uint64_t v18 = v10;
      _IDSLogV();
    }
    id v13 = objc_msgSend(*(id *)(a1 + 32), "identifier", v18, v19, v20, v21, v22);
    uint64_t v14 = [*(id *)(a1 + 32) alternateCallbackID];
    uint64_t v15 = [*(id *)(a1 + 32) mainAccountUUID];
    id v16 = [*(id *)(a1 + 40) idsResponseCode];
    id v17 = [*(id *)(a1 + 40) responseError];
    objc_msgSend(v3, "messageIdentifier:alternateCallbackID:forAccount:updatedWithResponseCode:error:lastCall:context:", v13, v14, v15, v16, v17, objc_msgSend(*(id *)(a1 + 40), "lastCall"), *(void *)(a1 + 64));
  }
}

void sub_1003BFCD4(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) service];
  uint64_t v3 = *(void *)(a1 + 64);
  id v5 = *(void **)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 48);
  id v6 = [v2 identifier];
  uint64_t v7 = objc_msgSend(v5, "dequeueBroadcastWithID:forMessageUUID:service:priority:", v3, v4, v6, (int)objc_msgSend(*(id *)(a1 + 56), "intValue"));

  if (v7)
  {
    uint64_t v8 = *(void **)(a1 + 40);
    id v9 = [v7 messageSequenceNumber];
    __int16 v10 = [v7 messageSenderID];
    objc_msgSend(v8, "_ackMessageWithSequenceNumber:forDeviceID:priority:dataProtectionClass:connectionType:guid:", v9, v10, (int)objc_msgSend(*(id *)(a1 + 56), "intValue"), objc_msgSend(v2, "dataProtectionClass"), *(void *)(a1 + 72), *(void *)(a1 + 48));

    id v11 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(void *)(a1 + 48);
      uint64_t v13 = *(void *)(a1 + 64);
      *(_DWORD *)long long buf = 138412802;
      uint64_t v15 = v12;
      __int16 v16 = 2048;
      uint64_t v17 = v13;
      __int16 v18 = 1024;
      unsigned int v19 = [v7 messageSequenceNumber];
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Broadcast: message %@ got client ack, sending IDS ack to sender, broadcast ID %lld, sequence number %u \n", buf, 0x1Cu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
    {
      [v7 messageSequenceNumber];
      _IDSLogTransport();
    }
  }
}

void sub_1003C0704(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 lastCall])
  {
    uint64_t v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 32);
      unsigned int v6 = [v3 lastCall];
      CFStringRef v7 = @"NO";
      if (v6) {
        CFStringRef v7 = @"YES";
      }
      *(_DWORD *)long long buf = 138412546;
      uint64_t v9 = v5;
      __int16 v10 = 2112;
      CFStringRef v11 = v7;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Sent app-level ack with guid %@. Last call? %@", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      [v3 lastCall];
      _IDSLogV();
    }
  }
}

void sub_1003C1E50(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_1003C1E6C(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v3 = [WeakRetained isFirewallOn];
    CFStringRef v4 = @"NO";
    if (v3) {
      CFStringRef v4 = @"YES";
    }
    *(_DWORD *)long long buf = 138412290;
    CFStringRef v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Is firewall enabled %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    [WeakRetained isFirewallOn];
    _IDSLogV();
  }
  uint64_t v5 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v6 = [WeakRetained[60] allValues];
    *(_DWORD *)long long buf = 138412290;
    CFStringRef v10 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Pending replay blocks for guids %@", buf, 0xCu);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v8 = [WeakRetained[60] allValues];
    _IDSLogV();
  }
  return 0;
}

void sub_1003C2088(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1003C1FF0);
  }
  _Unwind_Resume(a1);
}

void sub_1003C2110(id a1)
{
  uint64_t v1 = objc_alloc_init(IDSAppleIDRegistrationCenter);
  uint64_t v2 = qword_100A4C8E0;
  qword_100A4C8E0 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_1003C2C5C()
{
}

void sub_1003C305C()
{
}

void sub_1003C35E4()
{
}

void sub_1003C3810()
{
}

void sub_1003C3C8C()
{
}

void sub_1003C3CC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,os_activity_scope_state_s state,char a25)
{
}

void sub_1003C3CD8(uint64_t a1, int a2)
{
  if (!a2) {
    sub_1003C3CDC();
  }
  objc_terminate();
}

void sub_1003C3FBC()
{
}

void sub_1003C3FE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,os_activity_scope_state_s state,char a23)
{
}

void sub_1003C4000(uint64_t a1, int a2)
{
  if (!a2) {
    sub_1003C4004();
  }
  objc_terminate();
}

void sub_1003C4890(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
}

void sub_1003C4ABC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7, void *a8, void *a9, char a10)
{
  id v14 = a5;
  id v15 = a6;
  id v16 = a7;
  id v17 = a8;
  id v18 = a9;
  unsigned int v19 = +[IMRGLog registration];
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v20 = *(void *)(a1 + 32);
    int v30 = 138412290;
    uint64_t v31 = v20;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Received auth token response for reg: %@", (uint8_t *)&v30, 0xCu);
  }

  id v21 = [v18 integerValue];
  if (!v16 || (a10 & 1) != 0)
  {
    if (a10)
    {
      uint64_t v23 = +[IMRGLog registration];
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v30) = 0;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, " ** user cancelled, bailing", (uint8_t *)&v30, 2u);
      }

      uint64_t v25 = *(void *)(a1 + 32);
      id v24 = *(void **)(a1 + 40);
      uint64_t v26 = 1;
      uint64_t v27 = 41;
      id v28 = 0;
    }
    else
    {
      if (v21 == (id)5103)
      {
        uint64_t v25 = *(void *)(a1 + 32);
        id v24 = *(void **)(a1 + 40);
        uint64_t v26 = 5103;
        uint64_t v27 = 34;
      }
      else if (v21 == (id)5100)
      {
        uint64_t v25 = *(void *)(a1 + 32);
        id v24 = *(void **)(a1 + 40);
        uint64_t v26 = 5100;
        uint64_t v27 = 33;
      }
      else
      {
        __int16 v29 = +[IMRGLog warning];
        if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT)) {
          sub_10071FE6C(v29);
        }

        uint64_t v25 = *(void *)(a1 + 32);
        id v24 = *(void **)(a1 + 40);
        uint64_t v26 = 1;
        uint64_t v27 = 17;
      }
      id v28 = v17;
    }
    [v24 _notifyAuthenticationFailure:v25 responseCode:v26 registrationError:v27 error:0 info:v28];
  }
  else
  {
    uint64_t v22 = +[IMRGLog registration];
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v30) = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, " We have a token, great!", (uint8_t *)&v30, 2u);
    }

    [*(id *)(a1 + 40) _noteSuccessfulToken:v16 profileID:v14 selfID:v15 forRegistrationInfo:*(void *)(a1 + 32) wasFetched:0];
  }
}

void sub_1003C4F44(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, void *a6, void *a7, void *a8, void *a9)
{
  id v14 = a3;
  id v15 = a5;
  id v16 = a6;
  id v17 = a7;
  id v18 = a8;
  id v19 = a9;
  uint64_t v20 = +[IMRGLog registration];
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v21 = *(void *)(a1 + 32);
    int v32 = 138412290;
    uint64_t v33 = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Token fetcher finished for registration info: %@", (uint8_t *)&v32, 0xCu);
  }

  if (!v15)
  {
    id v15 = [*(id *)(a1 + 32) profileID];
  }
  if ([v15 length] && objc_msgSend(v17, "length"))
  {
    uint64_t v22 = +[IMRGLog registration];
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v32) = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, " We have a token, just sending auth", (uint8_t *)&v32, 2u);
    }

    [*(id *)(a1 + 40) _noteSuccessfulToken:v17 profileID:v15 selfID:v16 forRegistrationInfo:*(void *)(a1 + 32) wasFetched:1];
  }
  else if ([v14 length])
  {
    uint64_t v23 = *(void *)(a1 + 48);
    if (v23) {
      (*(void (**)(void))(v23 + 16))();
    }
    if (v19)
    {
      id v24 = [v19 integerValue];
      if (v24 == (id)5103)
      {
        uint64_t v26 = *(void *)(a1 + 32);
        uint64_t v25 = *(void **)(a1 + 40);
        uint64_t v27 = 5103;
        uint64_t v28 = 34;
      }
      else
      {
        if (v24 != (id)5100) {
          goto LABEL_26;
        }
        uint64_t v26 = *(void *)(a1 + 32);
        uint64_t v25 = *(void **)(a1 + 40);
        uint64_t v27 = 5100;
        uint64_t v28 = 33;
      }
      [v25 _notifyAuthenticationFailure:v26 responseCode:v27 registrationError:v28 error:0 info:v18];
      goto LABEL_26;
    }
    uint64_t v31 = +[IMRGLog registration];
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v32) = 0;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, " ** No token found, requesting it!", (uint8_t *)&v32, 2u);
    }

    [*(id *)(a1 + 40) _renewTokenForRegistrationInfo:*(void *)(a1 + 32) forceRenewal:0 failIfNotSilent:*(unsigned __int8 *)(a1 + 56)];
  }
  else
  {
    __int16 v29 = +[IMRGLog warning];
    if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT)) {
      sub_10071FEB0((uint64_t)v17, v29);
    }

    uint64_t v30 = *(void *)(a1 + 48);
    if (v30) {
      (*(void (**)(void))(v30 + 16))();
    }
  }
LABEL_26:
}

void sub_1003C5530(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
}

id sub_1003C58E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return _[*(id *)(a1 + 32) _processRegionValidationMessage:a2 deliveredWithError:a3 resultCode:a4 resultDictionary:a5];
}

id sub_1003C5B38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return _[*(id *)(a1 + 32) _processDefaultInvitationContextMessage:a2 deliveredWithError:a3 resultCode:a4 resultDictionary:a5];
}

NSSet *sub_1003C6EBC()
{
  self;
  uint64_t v0 = objc_opt_class();
  uint64_t v1 = objc_opt_class();
  uint64_t v2 = objc_opt_class();
  uint64_t v3 = objc_opt_class();
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  return +[NSSet setWithObjects:](NSSet, "setWithObjects:", v0, v1, v2, v3, v4, v5, objc_opt_class(), 0);
}

id *sub_1003C711C(id *a1, void *a2)
{
  id v4 = a2;
  if (a1)
  {
    v7.receiver = a1;
    v7.super_class = (Class)IDSStewieStore;
    uint64_t v5 = (id *)objc_msgSendSuper2(&v7, "init");
    a1 = v5;
    if (v5) {
      objc_storeStrong(v5 + 1, a2);
    }
  }

  return a1;
}

id sub_1003C7ECC(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = a2;
  id v4 = [v2 nextComponent];
  uint64_t v5 = [v4 runWithInput:v3];

  return v5;
}

void sub_1003CBAB4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  objc_super v7 = im_primary_queue();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1003CBB8C;
  block[3] = &unk_10097E418;
  void block[4] = *(void *)(a1 + 32);
  id v11 = v5;
  id v12 = v6;
  id v8 = v6;
  id v9 = v5;
  dispatch_async(v7, block);
}

void sub_1003CBB8C(uint64_t a1)
{
  if (+[IMUserDefaults shouldDropKTAccountKeySignatureResponseOnLaunch]&& CUTIsInternalInstall())
  {
    uint64_t v2 = +[IDSFoundationLog KeyTransparency];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Default is set to drop account key signature response from transparencyd. This path is not hit during registration.", buf, 2u);
    }

    id v3 = [*(id *)(a1 + 32) keyManager];
    id v4 = +[NSError errorWithDomain:@"IDSKTRegistrationDataManagerErrorDomain" code:-7000 userInfo:0];
    [v3 _handleTransparencySignatureResponse:0 error:v4];
  }
  else
  {
    id v5 = [*(id *)(a1 + 32) keyManager];
    [v5 _handleTransparencySignatureResponse:*(void *)(a1 + 40) error:*(void *)(a1 + 48)];
  }
}

void sub_1003CC874(id *a1, void *a2)
{
  id v34 = a2;
  if ([v34 count])
  {
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    id v3 = [a1[4] allKeys];
    id v4 = [v3 countByEnumeratingWithState:&v39 objects:v43 count:16];
    if (v4)
    {
      id v5 = v4;
      uint64_t v6 = *(void *)v40;
      uint64_t v32 = *(void *)v40;
      do
      {
        objc_super v7 = 0;
        id v33 = v5;
        do
        {
          if (*(void *)v40 != v6) {
            objc_enumerationMutation(v3);
          }
          uint64_t v8 = *(void *)(*((void *)&v39 + 1) + 8 * (void)v7);
          id v9 = [a1[5] objectForKeyedSubscript:v8];
          CFStringRef v10 = [a1[6] serviceController];
          id v11 = [v9 serviceIdentifier];
          id v12 = [v10 serviceWithIdentifier:v11];

          if ([v12 adHocServiceType])
          {
            uint64_t v13 = [a1[6] serviceController];
            uint64_t v14 = objc_msgSend(v13, "primaryServiceForAdhocServiceType:", objc_msgSend(v12, "adHocServiceType"));

            id v12 = (void *)v14;
          }
          id v15 = objc_msgSend(a1[6], "_ktApplicationForKTRegistrationIndex:", objc_msgSend(v12, "ktRegistrationDataIndex"));
          if (v15)
          {
            id v16 = [a1[4] objectForKeyedSubscript:v8];

            if (v16)
            {
              id v17 = [v34 objectForKeyedSubscript:v15];
              if (v17)
              {
                id v18 = v3;
                id v19 = [a1[4] objectForKeyedSubscript:v8];
                objc_msgSend(v19, "setKtOptInStatus:", objc_msgSend(v17, "status"));

                uint64_t v20 = [a1[4] objectForKeyedSubscript:v8];
                uint64_t v21 = [v17 timestamp];
                [v20 setKtOptInTimestamp:v21];

                uint64_t v22 = [v17 error];

                if (v22)
                {
                  uint64_t v23 = [a1[4] objectForKeyedSubscript:v8];
                  id v24 = [v17 error];
                  uint64_t v25 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [v24 code]);
                  [v23 setKtOptInErrorCode:v25];
                }
                id v26 = [v17 status];
                id v3 = v18;
                uint64_t v6 = v32;
                id v5 = v33;
              }
              else
              {
                id v26 = 0;
              }
              [v9 setOptedIntoKT:v26];
            }
          }

          objc_super v7 = (char *)v7 + 1;
        }
        while (v5 != v7);
        id v5 = [v3 countByEnumeratingWithState:&v39 objects:v43 count:16];
      }
      while (v5);
    }
  }
  if ([a1[7] count])
  {
    id v27 = [objc_alloc((Class)TransparencyIDSRegistrationRequest) initWithSignatureRequests:a1[7]];
    [v27 setInitialTimeout:30.0];
    if (objc_opt_respondsToSelector()) {
      [v27 setDontWaitForKeySigning:1];
    }
    uint64_t v28 = a1[6];
    __int16 v29 = (void *)v28[4];
    v35[0] = _NSConcreteStackBlock;
    v35[1] = 3221225472;
    v35[2] = sub_1003CCCC8;
    v35[3] = &unk_10098B358;
    void v35[4] = v28;
    id v36 = a1[4];
    id v37 = a1[5];
    id v38 = a1[8];
    [v29 transparencyGetKTSignatures:v27 complete:v35];
  }
  else
  {
    uint64_t v30 = +[IDSFoundationLog KeyTransparency];
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      sub_1007202FC();
    }

    uint64_t v31 = (void (**)(id, id))a1[8];
    if (v31) {
      v31[2](v31, a1[4]);
    }
  }
}

void sub_1003CCCC8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  objc_super v7 = im_primary_queue();
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1003CCDD8;
  v12[3] = &unk_10097E840;
  uint64_t v8 = *(void *)(a1 + 32);
  id v9 = *(void **)(a1 + 40);
  id v13 = v5;
  uint64_t v14 = v8;
  id v15 = v6;
  id v16 = v9;
  id v17 = *(id *)(a1 + 48);
  id v18 = *(id *)(a1 + 56);
  id v10 = v6;
  id v11 = v5;
  dispatch_async(v7, v12);
}

uint64_t sub_1003CCDD8(uint64_t a1)
{
  if (+[IMUserDefaults shouldDropKTAccountKeySignatureOnlyDuringReg]&& CUTIsInternalInstall())
  {
    uint64_t v2 = +[IDSFoundationLog KeyTransparency];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Default is set to drop signature from KT account key response.", buf, 2u);
    }

    long long v73 = 0u;
    long long v74 = 0u;
    long long v71 = 0u;
    long long v72 = 0u;
    id v3 = [*(id *)(a1 + 32) registrationData];
    id v4 = [v3 allValues];

    id v5 = [v4 countByEnumeratingWithState:&v71 objects:v83 count:16];
    if (v5)
    {
      id v6 = v5;
      uint64_t v7 = *(void *)v72;
      do
      {
        for (uint64_t i = 0; i != v6; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v72 != v7) {
            objc_enumerationMutation(v4);
          }
          [*(id *)(*((void *)&v71 + 1) + 8 * i) setSignature:0];
        }
        id v6 = [v4 countByEnumeratingWithState:&v71 objects:v83 count:16];
      }
      while (v6);
    }
  }
  if (+[IMUserDefaults shouldDropKTAccountKeyOnlyDuringReg]&& CUTIsInternalInstall())
  {
    id v9 = +[IDSFoundationLog KeyTransparency];
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Default is set to drop public key from KT account key response.", buf, 2u);
    }

    long long v69 = 0u;
    long long v70 = 0u;
    long long v67 = 0u;
    long long v68 = 0u;
    id v10 = [*(id *)(a1 + 32) registrationData];
    id v11 = [v10 allValues];

    id v12 = [v11 countByEnumeratingWithState:&v67 objects:v82 count:16];
    if (v12)
    {
      id v13 = v12;
      uint64_t v14 = *(void *)v68;
      do
      {
        for (j = 0; j != v13; j = (char *)j + 1)
        {
          if (*(void *)v68 != v14) {
            objc_enumerationMutation(v11);
          }
          [*(id *)(*((void *)&v67 + 1) + 8 * (void)j) setPublicKey:0];
        }
        id v13 = [v11 countByEnumeratingWithState:&v67 objects:v82 count:16];
      }
      while (v13);
    }
  }
  if (+[IMUserDefaults shouldDropKTAccountKeySignatureResponseDuringReg]&& CUTIsInternalInstall())
  {
    id v16 = +[IDSFoundationLog KeyTransparency];
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Default is set to drop account key signature response during registraiton.", buf, 2u);
    }

    id v17 = [*(id *)(a1 + 40) keyManager];
    id v18 = +[NSError errorWithDomain:@"IDSKTRegistrationDataManagerErrorDomain" code:-7000 userInfo:0];
    [v17 _handleTransparencySignatureResponseForRegistration:0 error:v18];
  }
  else
  {
    id v17 = [*(id *)(a1 + 40) keyManager];
    [v17 _handleTransparencySignatureResponseForRegistration:*(void *)(a1 + 32) error:*(void *)(a1 + 48)];
  }

  long long v65 = 0u;
  long long v66 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  id obj = [*(id *)(a1 + 56) allKeys];
  id v19 = [obj countByEnumeratingWithState:&v63 objects:v81 count:16];
  if (v19)
  {
    id v21 = v19;
    uint64_t v22 = *(void *)v64;
    *(void *)&long long v20 = 138412802;
    long long v58 = v20;
    uint64_t v59 = *(void *)v64;
    do
    {
      uint64_t v23 = 0;
      id v60 = v21;
      do
      {
        if (*(void *)v64 != v22) {
          objc_enumerationMutation(obj);
        }
        uint64_t v24 = *(void *)(*((void *)&v63 + 1) + 8 * (void)v23);
        uint64_t v25 = objc_msgSend(*(id *)(a1 + 64), "objectForKeyedSubscript:", v24, v58);
        id v26 = [*(id *)(a1 + 40) serviceController];
        id v27 = [v25 serviceIdentifier];
        uint64_t v28 = [v26 serviceWithIdentifier:v27];

        if ([v28 adHocServiceType])
        {
          __int16 v29 = [*(id *)(a1 + 40) serviceController];
          uint64_t v30 = objc_msgSend(v29, "primaryServiceForAdhocServiceType:", objc_msgSend(v28, "adHocServiceType"));

          uint64_t v28 = (void *)v30;
        }
        uint64_t v31 = [*(id *)(a1 + 40) accountController];
        uint64_t v32 = [v31 appleIDAccountOnService:v28];

        id v33 = objc_msgSend(*(id *)(a1 + 40), "_ktApplicationForKTRegistrationIndex:", objc_msgSend(v28, "ktRegistrationDataIndex"));
        if (v33)
        {
          id v34 = [*(id *)(a1 + 56) objectForKeyedSubscript:v24];

          if (v34)
          {
            uint64_t v35 = [*(id *)(a1 + 32) registrationData];
            [v35 objectForKeyedSubscript:v33];
            v37 = id v36 = v32;

            id v38 = *(void **)(a1 + 40);
            long long v39 = [v37 dsid];
            id v62 = v36;
            long long v40 = [v36 dsID];
            unsigned int v41 = [v38 doesSignatureDSID:v39 matchAccountDSID:v40];

            if (v37 && v41)
            {
              long long v42 = [*(id *)(a1 + 56) objectForKeyedSubscript:v24];
              uint64_t v43 = [v37 publicKey];
              [v42 setKtPublicAccountKey:v43];

              uint64_t v44 = [*(id *)(a1 + 56) objectForKeyedSubscript:v24];
              id v45 = [v37 signature];
              [v44 setKtDataSignature:v45];

              id v46 = [*(id *)(a1 + 56) objectForKeyedSubscript:v24];
              id v47 = [v37 orderedTimestamp];
              [v46 setKtAccountKeyTimestamp:v47];

              goto LABEL_47;
            }
            if ((v41 & 1) == 0)
            {
              id v48 = +[IDSFoundationLog KeyTransparency];
              if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
              {
                id v49 = [v37 dsid];
                id v50 = [v62 dsID];
                *(_DWORD *)long long buf = v58;
                uint64_t v76 = v24;
                __int16 v77 = 2112;
                __int16 v78 = v49;
                __int16 v79 = 2112;
                __int16 v80 = v50;
                _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "DSID for account and signature do not match. { service: %@, signatureDSID: %@, accountDSID: %@", buf, 0x20u);
              }
              id v51 = [*(id *)(a1 + 56) objectForKeyedSubscript:v24];
              [v51 setKtPublicAccountKey:0];

              id v52 = [*(id *)(a1 + 56) objectForKeyedSubscript:v24];
              [v52 setKtDataSignature:0];

              id v46 = [*(id *)(a1 + 56) objectForKeyedSubscript:v24];
              [v46 setKtAccountKeyTimestamp:0];
LABEL_47:

              id v53 = [*(id *)(a1 + 56) objectForKeyedSubscript:v24];
              uint64_t v54 = [v37 dsid];
              [v53 setDsid:v54];
            }
            if (*(void *)(a1 + 48))
            {
              uint64_t v55 = [*(id *)(a1 + 56) objectForKeyedSubscript:v24];
              id v56 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [*(id *)(a1 + 48) code]);
              [v55 setKtAccountKeyErrorCode:v56];
            }
            uint64_t v22 = v59;
            id v21 = v60;
            uint64_t v32 = v62;
          }
        }

        uint64_t v23 = (char *)v23 + 1;
      }
      while (v21 != v23);
      id v21 = [obj countByEnumeratingWithState:&v63 objects:v81 count:16];
    }
    while (v21);
  }

  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void))(result + 16))(result, *(void *)(a1 + 56));
  }
  return result;
}

void sub_1003CED04(uint64_t a1, char a2)
{
  id v4 = im_primary_queue();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1003CEDB4;
  block[3] = &unk_1009802F0;
  id v5 = *(void **)(a1 + 40);
  void block[4] = *(void *)(a1 + 32);
  id v7 = v5;
  char v8 = a2;
  dispatch_async(v4, block);
}

void sub_1003CEDB4(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) keyManager];
  [v2 _handleKVSUpdateResponseForTrustedDevices:*(void *)(a1 + 40) withSuccessfulKVSSync:*(unsigned __int8 *)(a1 + 48)];
}

void sub_1003D1CA0(id a1)
{
  uint64_t v1 = objc_alloc_init(IDSDaemonPriorityQueueController);
  uint64_t v2 = qword_100A4C8F0;
  qword_100A4C8F0 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_1003D1F08(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1003D1FF8(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1003D2124(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1003D222C(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1003D2708(id a1)
{
  uint64_t v1 = objc_alloc_init(IDSPinnedIdentityController);
  uint64_t v2 = qword_100A4C900;
  qword_100A4C900 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

IDSDAccount *__cdecl sub_1003D3964(id a1, IDSServiceProperties *a2, int a3)
{
  uint64_t v3 = *(void *)&a3;
  id v4 = a2;
  id v5 = [IDSDAccount alloc];
  id v6 = +[NSString stringGUID];
  id v7 = [(IDSDAccount *)v5 initWithLoginID:&stru_10099BE78 service:v4 uniqueID:v6 accountType:v3 accountConfig:0];

  return v7;
}

id sub_1003D3FB4(uint64_t a1)
{
  return [*(id *)(a1 + 32) synchronize];
}

id sub_1003D40C4(uint64_t a1, void *a2)
{
  uint64_t v3 = [a2 registration];
  id v4 = [v3 userUniqueIdentifier];
  id v5 = [v4 isEqualToString:*(void *)(a1 + 32)];

  return v5;
}

void sub_1003D5C8C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 72);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1003D5D00;
  block[3] = &unk_10097E4D0;
  void block[4] = v1;
  dispatch_async(v2, block);
}

id sub_1003D5D00(uint64_t a1)
{
  uint64_t v2 = +[IMRGLog registration];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Migration completed, performing synchronize", v6, 2u);
  }

  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = *(void **)(v3 + 88);
  *(void *)(v3 + 88) = 0;

  return [*(id *)(a1 + 32) synchronize];
}

id sub_1003D5D8C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 realm])
  {
    if ([v3 realm] != (id)2) {
      goto LABEL_6;
    }
    id v4 = (id *)(a1 + 40);
  }
  else
  {
    id v4 = (id *)(a1 + 32);
  }
  [*v4 addObject:v3];
LABEL_6:
  id v5 = [v3 uniqueIdentifier];

  return v5;
}

IMPair *__cdecl sub_1003D5E0C(id a1, IDSCTSIM *a2)
{
  uint64_t v2 = a2;
  id v3 = objc_alloc((Class)IMPair);
  id v4 = [(IDSCTSIM *)v2 mobileCountryCode];
  id v5 = [(IDSCTSIM *)v2 mobileNetworkCode];

  id v6 = [v3 initWithFirst:v4 second:v5];

  return (IMPair *)v6;
}

IMPair *__cdecl sub_1003D5EA0(id a1, IDSPhoneUser *a2)
{
  uint64_t v2 = a2;
  id v3 = objc_alloc((Class)IMPair);
  id v4 = [(IDSPhoneUser *)v2 countryCode];
  id v5 = [(IDSPhoneUser *)v2 networkCode];

  id v6 = [v3 initWithFirst:v4 second:v5];

  return (IMPair *)v6;
}

id sub_1003D5F34(uint64_t a1, void *a2)
{
  id v3 = [a2 uniqueIdentifier];
  id v4 = [*(id *)(a1 + 32) userUniqueIdentifier];
  id v5 = [v3 isEqualToString:v4];

  return v5;
}

void sub_1003D5F98(uint64_t a1)
{
  uint64_t v2 = +[IMRGLog registration_oversized];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    int v5 = 138412546;
    uint64_t v6 = v3;
    __int16 v7 = 2112;
    uint64_t v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%@ Current existing accounts {existingIdentifierByService: %@}", (uint8_t *)&v5, 0x16u);
  }
}

void sub_1003D6054(uint64_t a1)
{
  uint64_t v2 = +[IMRGLog registration_oversized];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    int v5 = 138412546;
    uint64_t v6 = v3;
    __int16 v7 = 2112;
    uint64_t v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%@ Current disabled accounts {disabledByService: %@}", (uint8_t *)&v5, 0x16u);
  }
}

void sub_1003D97AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1003D97C4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1003D97D4(uint64_t a1)
{
}

void sub_1003D97DC(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, void *a7)
{
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  id v16 = a7;
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a7);
  if ([v15 length])
  {
    id v17 = [*(id *)(a1 + 32) dsHandle];
    id v18 = [v17 length];

    if (!v18)
    {
      id v19 = +[IMRGLog registration];
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        int v26 = 138412290;
        id v27 = v15;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "  ** Fixed Self ID to be: %@", (uint8_t *)&v26, 0xCu);
      }

      [*(id *)(a1 + 32) setDSHandle:v15];
    }
  }
  if ([v14 length])
  {
    long long v20 = [*(id *)(a1 + 32) profileID];
    id v21 = [v20 length];

    if (!v21)
    {
      uint64_t v22 = +[IMRGLog registration];
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        int v26 = 138412290;
        id v27 = v14;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "  ** Fixed Profile ID to be: %@", (uint8_t *)&v26, 0xCu);
      }

      [*(id *)(a1 + 32) setProfileID:v14];
    }
  }
  uint64_t v23 = +[IMRGLog registration];
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v24 = IMTruncatedLoggingStringForString();
    uint64_t v25 = IMGetEnvironmentName();
    int v26 = 138413314;
    id v27 = v12;
    __int16 v28 = 2112;
    id v29 = v13;
    __int16 v30 = 2112;
    id v31 = v15;
    __int16 v32 = 2112;
    id v33 = v24;
    __int16 v34 = 2112;
    uint64_t v35 = v25;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Successfully fetched token for account (%@:%@:%@): %@  (Environment: %@)", (uint8_t *)&v26, 0x34u);
  }
}

void sub_1003D9CF4(uint64_t a1, uint64_t a2, void *a3, void *a4, int a5)
{
  id v8 = a3;
  id v9 = a4;
  id v10 = +[IMRGLog registration];
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    if ([*(id *)(a1 + 32) length]) {
      CFStringRef v11 = @"updated";
    }
    else {
      CFStringRef v11 = @"removed";
    }
    if (a5) {
      CFStringRef v12 = @"YES";
    }
    else {
      CFStringRef v12 = @"NO";
    }
    id v13 = IMGetEnvironmentName();
    uint64_t v14 = *(void *)(a1 + 32);
    int v15 = 138413570;
    CFStringRef v16 = v11;
    __int16 v17 = 2112;
    id v18 = v8;
    __int16 v19 = 2112;
    id v20 = v9;
    __int16 v21 = 2112;
    CFStringRef v22 = v12;
    __int16 v23 = 2112;
    uint64_t v24 = v13;
    __int16 v25 = 2112;
    uint64_t v26 = v14;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Successfully %@ token for account (%@:%@): %@  (Environment: %@  New Token: %@)", (uint8_t *)&v15, 0x3Eu);
  }
}

void sub_1003DA084(id a1, NSString *a2, NSString *a3, NSString *a4, BOOL a5)
{
  BOOL v5 = a5;
  __int16 v7 = a3;
  id v8 = a4;
  id v9 = +[IMRGLog registration];
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if (v5) {
      CFStringRef v10 = @"YES";
    }
    else {
      CFStringRef v10 = @"NO";
    }
    CFStringRef v11 = IMGetEnvironmentName();
    int v12 = 138413058;
    id v13 = v7;
    __int16 v14 = 2112;
    int v15 = v8;
    __int16 v16 = 2112;
    CFStringRef v17 = v10;
    __int16 v18 = 2112;
    __int16 v19 = v11;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Successfully voided password for account (%@:%@): %@  (Environment: %@)", (uint8_t *)&v12, 0x2Au);
  }
}

id sub_1003DB424(id a1, IDSCTSIM *a2)
{
  uint64_t v2 = [(IDSCTSIM *)a2 phoneNumber];
  uint64_t v3 = [v2 lowercaseString];

  return v3;
}

id sub_1003DB474(id a1, IDSTemporaryPhoneUser *a2)
{
  uint64_t v2 = [(IDSTemporaryPhoneUser *)a2 phoneNumber];
  uint64_t v3 = [v2 lowercaseString];

  return v3;
}

void sub_1003DC210(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0x20u);
}

uint64_t sub_1003DC248()
{
  return objc_opt_class();
}

void sub_1003DC308(id a1)
{
  uint64_t v1 = objc_alloc_init(IDSDeviceConnectionAWDMetrics);
  uint64_t v2 = qword_100A4C920;
  qword_100A4C920 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_1003DC758(uint64_t a1, uint64_t a2, void *a3)
{
  id v7 = a3;
  uint64_t v4 = [v7 objectForKeyedSubscript:IDSDeviceConnectionAWDMetricsCreatedAtKey];
  [v4 doubleValue];
  double v6 = v5;

  if (*(double *)(a1 + 40) - v6 >= 86400.0) {
    [*(id *)(a1 + 32) addObject:v7];
  }
}

void sub_1003DC7EC(uint64_t a1, void *a2)
{
  id v3 = a2;
  __int16 v25 = [v3 objectForKeyedSubscript:IDSDeviceConnectionAWDMetricsServiceNameKey];
  uint64_t v4 = [v3 objectForKeyedSubscript:IDSDeviceConnectionAWDMetricsSuccessKey];
  id v5 = [v4 BOOLValue];

  uint64_t v24 = [v3 objectForKeyedSubscript:IDSDeviceConnectionAWDMetricsClientInitKey];
  double v6 = [v3 objectForKeyedSubscript:IDSDeviceConnectionAWDMetricsClientOpenSocketCompletionKey];
  id v7 = [v3 objectForKeyedSubscript:IDSDeviceConnectionAWDMetricsDaemonOpenSocketKey];
  id v8 = [v3 objectForKeyedSubscript:IDSDeviceConnectionAWDMetricsDaemonCompletionHandlerKey];
  id v9 = [v3 objectForKeyedSubscript:IDSDeviceConnectionAWDMetricsFirstDataPacketReceiveKey];
  uint64_t v10 = [v3 objectForKeyedSubscript:IDSDeviceConnectionAWDMetricsConnectionInitKey];
  if ([*(id *)(a1 + 32) _canReportMetric:v3])
  {
    id v11 = [objc_alloc((Class)IDSDeviceConnectionDurationEventMetric) initWithService:v25 wasSuccessful:v5 clientInitTime:v24 clientOpenSocketCompletionTime:v6 daemonOpenSocketTime:v7 daemonOpenSocketCompletionTime:v8 firstPacketReceiveTime:v9 connectionInitTime:v10];
    int v12 = +[IDSCoreAnalyticsLogger defaultLogger];
    [v12 logMetric:v11];

    id v13 = +[IDSAWDLogging sharedInstance];
    [v13 IDSDeviceConnectionForService:v25 wasSuccessful:v5 clientInitTime:v24 clientOpenSocketCompletionTime:v6 daemonOpenSocketTime:v7 daemonOpenSocketCompletionTime:v8 firstPacketReceiveTime:v9 connectionInitTime:v10];

    __int16 v14 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v27 = v3;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Final Report - %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
    __int16 v16 = *(os_unfair_lock_s **)(a1 + 32);
    int v15 = (os_unfair_lock_s **)(a1 + 32);
    os_unfair_lock_lock(v16 + 4);
    CFStringRef v17 = *(void **)&(*v15)[2]._os_unfair_lock_opaque;
    __int16 v18 = [v3 objectForKeyedSubscript:IDSDeviceConnectionAWDMetricsConnectionUUIDKey];
    [v17 removeObjectForKey:v18];

    os_unfair_lock_unlock(*v15 + 4);
  }
  else
  {
    __int16 v19 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v27 = v3;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Final Report - %@, but there might be client side errors.", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
    __int16 v21 = *(os_unfair_lock_s **)(a1 + 32);
    id v20 = (os_unfair_lock_s **)(a1 + 32);
    os_unfair_lock_lock(v21 + 4);
    CFStringRef v22 = *(void **)&(*v20)[2]._os_unfair_lock_opaque;
    __int16 v23 = [v3 objectForKeyedSubscript:IDSDeviceConnectionAWDMetricsConnectionUUIDKey];
    [v22 removeObjectForKey:v23];

    os_unfair_lock_unlock(*v20 + 4);
  }
}

void sub_1003DE13C(id a1)
{
  uint64_t v1 = objc_alloc_init(IDSDServiceController);
  uint64_t v2 = qword_100A4C930;
  qword_100A4C930 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_1003DF3A4(_Unwind_Exception *a1)
{
}

uint64_t sub_1003DF3F0(uint64_t result, int a2)
{
  if (a2) {
    *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  }
  return result;
}

BOOL sub_1003E0554(id a1, IDSServiceProperties *a2)
{
  return [(IDSServiceProperties *)a2 wantsTinkerDevices];
}

BOOL sub_1003E05B4(id a1, IDSServiceProperties *a2)
{
  return [(IDSServiceProperties *)a2 isFamilyService];
}

BOOL sub_1003E0614(id a1, IDSServiceProperties *a2)
{
  return [(IDSServiceProperties *)a2 requiresPinnedIdentity];
}

void sub_1003E0DB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1003E0DC8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1003E0DD8(uint64_t a1)
{
}

void sub_1003E0DE0(uint64_t a1)
{
  v6.receiver = *(id *)(a1 + 32);
  v6.super_class = (Class)IDSPairedDeviceRepository;
  uint64_t v2 = objc_msgSendSuper2(&v6, "description");
  uint64_t v3 = +[NSString stringWithFormat:@"%@ %@", v2, *(void *)(*(void *)(a1 + 32) + 8)];
  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8);
  id v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;
}

id sub_1003E0F20(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _criticalLoadPairedDeviceArray:*(void *)(a1 + 40)];
}

void sub_1003E12A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1003E12C0(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) _criticalPairedDeviceWithCBUUID:*(void *)(a1 + 40)];
  uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v4 = *(void *)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  return _objc_release_x1(v2, v4);
}

id sub_1003E151C(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) cbuuid];
  uint64_t v3 = [*(id *)(a1 + 40) _criticalPairedDeviceWithCBUUID:v2];
  if (v3)
  {
    uint64_t v4 = +[IMRGLog pairedDeviceRepo];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_100722A2C();
    }

    id v5 = 0;
  }
  else
  {
    [*(id *)(a1 + 40) _criticalPutPairedDevice:*(void *)(a1 + 32)];
    id v5 = [*(id *)(a1 + 40) _criticalPersistState];
  }

  return v5;
}

id sub_1003E186C(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _criticalRemovePairedDeviceWithCBUUID:*(void *)(a1 + 40)];
}

void sub_1003E1A20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1003E1A38(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) _criticalAllPairedDevices];
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v4 = *(void *)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  return _objc_release_x1(v2, v4);
}

BOOL sub_1003E1A84(uint64_t a1, void *a2)
{
  return [a2 pairingType] == *(id *)(a1 + 32);
}

void sub_1003E1D9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_1003E1DBC(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = [*(id *)(a1 + 32) _criticalActivatePairedDeviceWithCBUUID:*(void *)(a1 + 40)];
  return *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) == 0;
}

id sub_1003E1ED0(uint64_t a1)
{
  [*(id *)(a1 + 32) _criticalPerformPairedDeviceDeactivation];
  uint64_t v2 = *(void **)(a1 + 32);

  return [v2 _criticalPersistState];
}

id sub_1003E2364(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _criticalPurgeSecuredEncryptionKeysForAllPairedDevices];
}

id sub_1003E2630(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _criticalUpdatePairedDeviceWithCBUUID:*(void *)(a1 + 40) deviceInfoPayload:*(void *)(a1 + 48)];
}

id sub_1003E28C4(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _criticalUpdatePairedDeviceWithCBUUID:*(void *)(a1 + 40) supportIPsec:*(unsigned __int8 *)(a1 + 48)];
}

id sub_1003E2D0C(uint64_t a1)
{
  LOWORD(v2) = *(_WORD *)(a1 + 92);
  return objc_msgSend(*(id *)(a1 + 32), "_criticalUpdatePairedDeviceWithCBUUID:deviceUniqueID:buildVersion:productVersion:productName:pairingProtocolVersion:minCompatibilityVersion:maxCompatibilityVersion:serviceMinCompatibilityVersion:", *(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 64), *(void *)(a1 + 72), *(unsigned int *)(a1 + 80), *(void *)(a1 + 84), v2);
}

id sub_1003E365C(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _criticalUpdatePairedDeviceWithCBUUID:*(void *)(a1 + 40) pairingType:*(void *)(a1 + 48)];
}

id sub_1003E39CC(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _criticalUpdatePairedDeviceWithCBUUID:*(void *)(a1 + 40) iCloudURIs:*(void *)(a1 + 48) pushToken:*(void *)(a1 + 56)];
}

void sub_1003E3D60(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

id sub_1003E3D78(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) _criticalPerformTransactionWithBlock:*(void *)(a1 + 40)];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = (_BYTE)result;
  return result;
}

id sub_1003E49E8(id a1, id a2)
{
  id v2 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = 0;
  }
  id v4 = v3;

  return v4;
}

void sub_1003E5420(uint64_t a1, void *a2, uint64_t a3)
{
  id v11 = a2;
  if (a3)
  {
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    id v5 = objc_alloc((Class)ENGroupID);
    id v6 = objc_alloc((Class)ENStableGroupID);
    id v7 = [v11 responseEngramID];
    id v8 = [v6 initWithDataRepresentation:v7];
    id v9 = [v11 responseVersion];
    id v10 = objc_msgSend(v5, "initWithStableGroupID:generation:", v8, objc_msgSend(v9, "intValue"));

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

id sub_1003E552C(void *a1)
{
  id v1 = a1;
  if (qword_100A4C940 != -1) {
    dispatch_once(&qword_100A4C940, &stru_10098B8A0);
  }
  pthread_mutex_lock(&stru_100A4C948);
  id v2 = +[IMSystemMonitor sharedInstance];
  unsigned int v3 = [v2 isUnderDataProtectionLock];

  id v4 = +[IMSystemMonitor sharedInstance];
  unsigned int v5 = [v4 isUnderFirstDataProtectionLock];

  unsigned int v6 = [v1 dataProtectionClass];
  id v7 = IDSDataProtectionClassStringFromDataProtectionClass();
  id v8 = [(id)qword_100A4C938 objectForKey:v7];
  if (v8) {
    goto LABEL_4;
  }
  if (v6 == 1) {
    unsigned int v9 = v3;
  }
  else {
    unsigned int v9 = 0;
  }
  if (v9 != 1)
  {
    unsigned int v10 = v6 ? 0 : v5;
    if (v10 != 1)
    {
      int v12 = +[NSString stringWithFormat:@"IDSMessageStore-%@", v7];
      id v8 = (void *)CSDBCreateThreadedRecordStoreWithQOSClassAndLookAsideBufferConfig();
      [(id)qword_100A4C938 setObject:v8 forKey:v7];
      id v13 = +[IMRGLog dataProtectionClass];
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        uint64_t v15 = qword_100A4C938;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "SharedMessage store %@", buf, 0xCu);
      }

LABEL_4:
      pthread_mutex_unlock(&stru_100A4C948);
      goto LABEL_14;
    }
  }
  pthread_mutex_unlock(&stru_100A4C948);
  id v8 = 0;
LABEL_14:

  return v8;
}

void sub_1003E5748(id a1)
{
  id v1 = objc_alloc_init((Class)NSMutableDictionary);
  id v2 = (void *)qword_100A4C938;
  qword_100A4C938 = (uint64_t)v1;

  pthread_mutex_init(&stru_100A4C948, 0);
}

void sub_1003E5794(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  unsigned int v6 = sub_1003E552C(v4);
  CSDBThreadedRecordStoreOwnsCurrentThread();

  id v7 = sub_1003E552C(v4);

  if (v7)
  {
    id v8 = v4;
    unsigned int v9 = v5;
    unsigned int v11 = [v8 dataProtectionClass];
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472;
    void v15[2] = sub_1003E6304;
    v15[3] = &unk_10098B900;
    unsigned int v16 = v11;
    int v12 = objc_retainBlock(v15);
    id v13 = v12;
    if (!v9) {
      unsigned int v9 = objc_retainBlock(v12);
    }
    __int16 v14 = sub_1003E552C(v8);
    CSDBThreadedRecordStoreEnsureDatabaseSetupWithProtection();
  }
}

void sub_1003E5954(void *a1, uint64_t a2, void *a3)
{
  id v4 = a1;
  sub_1003E552C(a3);
  id v5 = (id)objc_claimAutoreleasedReturnValue();
  CSDBPerformBlock();
}

void sub_1003E59C4(void *a1, void *a2)
{
  id v3 = a1;
  sub_1003E552C(a2);
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  CSDBPerformBlockAfterDelay();
}

void sub_1003E5A34(uint64_t a1, void *a2, void *a3)
{
  id v4 = a3;
  id v5 = a2;
  [v4 ensureDatabaseIsInitialized];
  sub_1003E552C(v4);
  id v6 = (id)objc_claimAutoreleasedReturnValue();

  CSDBPerformLockedSectionUsingUnfairLock();
}

void sub_1003E5ABC(void *a1, void *a2)
{
  id v3 = a1;
  sub_1003E552C(a2);
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  CSDBPerformLockedSectionForRecordStoreWithoutInitialize();
}

void sub_1003E5B1C(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  [v3 ensureDatabaseIsInitialized];
  sub_1003E552C(v3);
  id v5 = (id)objc_claimAutoreleasedReturnValue();

  CSDBPerformLockedSectionForRecordStore();
}

void sub_1003E5B94(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  [v3 ensureDatabaseIsInitialized];
  sub_1003E552C(v3);
  id v5 = (id)objc_claimAutoreleasedReturnValue();

  CSDBPerformUnlockedSectionForRecordStore();
}

void sub_1003E5C0C(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  [v3 ensureDatabaseIsInitialized];
  sub_1003E552C(v3);
  id v5 = (id)objc_claimAutoreleasedReturnValue();

  CSDBPerformLockedSectionForDatabase();
}

void sub_1003E5C84(uint64_t a1, void *a2, void *a3)
{
  id v4 = a3;
  id v5 = a2;
  [v4 ensureDatabaseIsInitialized];
  sub_1003E552C(v4);
  id v6 = (id)objc_claimAutoreleasedReturnValue();

  CSDBPerformLockedSectionForQueryForReading();
}

void sub_1003E5D0C(uint64_t a1, void *a2, void *a3)
{
  id v4 = a3;
  id v5 = a2;
  [v4 ensureDatabaseIsInitialized];
  sub_1003E552C(v4);
  id v6 = (id)objc_claimAutoreleasedReturnValue();

  CSDBPerformLockedSectionForQueryForWriting();
}

void sub_1003E5D94(id a1, CSDBRecordStore *a2)
{
  CSDBRecordSaveStore();

  _CSDBRecordStoreInvalidateCachesWithStore(a2);
}

void sub_1003E5DD0(void *a1)
{
  id v1 = a1;
  id v2 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Saving database.", buf, 2u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  sub_1003E5B1C(&stru_10098B8C0, v1);
  id v3 = sub_1003E552C(v1);

  if (v3)
  {
    id v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v8 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Destroying database.", v8, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    id v5 = sub_1003E552C(v1);
    CSDBThreadedRecordStoreTeardownDatabase();

    id v6 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v7 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Closed database.", v7, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
  }
}

void sub_1003E6018(void *a1)
{
}

void sub_1003E6028(id a1, CSDBRecordStore *a2)
{
}

uint64_t sub_1003E6168(uint64_t a1)
{
  id v1 = [*(id *)(a1 + 32) filename];
  uint64_t v2 = sub_1003E61A8(v1, 0);

  return v2;
}

uint64_t sub_1003E61A8(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  if (v4)
  {
    uint64_t v6 = [v3 stringByAppendingPathComponent:v4];

    id v3 = (id)v6;
  }
  id v7 = v3;
  [v7 fileSystemRepresentation];
  CSDBGetMobileUserUID();
  CSDBGetMobileUserGID();
  CSDBCreateDirectoriesToPath();
  uint64_t v8 = [v7 stringByResolvingAndStandardizingPath];

  return v8;
}

uint64_t sub_1003E6304(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 32);
  uint64_t v3 = CSDBGetMobileUserDirectory();
  if (v3)
  {
    id v4 = objc_alloc((Class)NSString);
    id v5 = v4;
    if (v1 == 2)
    {
      id v6 = [v4 initWithFormat:@"%@", @"ids.db"];
    }
    else
    {
      id v7 = IDSDataProtectionClassStringFromDataProtectionClass();
      uint64_t v8 = +[NSString stringWithFormat:@"ids-%@.db", v7];
      id v6 = [v5 initWithFormat:@"%@", v8];
    }
    unsigned int v9 = +[NSString stringWithUTF8String:v3];
    unsigned int v10 = +[NSArray arrayWithObjects:v9, @"/Library/IdentityServices/", 0];
    unsigned int v11 = +[NSString pathWithComponents:v10];

    uint64_t v3 = sub_1003E61A8(v11, v6);
  }
  return v3;
}

uint64_t sub_1003E645C()
{
  CSDBRecordStoreCreateTablesForClass();
  CSDBRecordStoreCreateTablesForClass();

  return CSDBRecordStoreCreateTablesForClass();
}

uint64_t sub_1003E64C0()
{
  uint64_t v0 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Enabling WAL journal mode.", buf, 2u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  CSDBSqliteConnectionPerformSQL();
  int v1 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "Enabling Foreign Key support.", v3, 2u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  return CSDBSqliteConnectionPerformSQL();
}

BOOL sub_1003E6644(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a3 <= 0x2726) {
    _IMWarn();
  }
  return a3 < 0x2727;
}

uint64_t sub_1003E66A0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = +[NSDate date];
  id v6 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109376;
    int v109 = a3;
    __int16 v110 = 1024;
    int v111 = 10023;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Beginning migration.  The IDS db is currently at v%d, upgrading to v%d.", buf, 0xEu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v106 = a3;
    uint64_t v107 = 10023;
    _IDSLogV();
  }
  CSDBSqliteConnectionCommit();
  if (CSDBSqliteDatabaseCheckIntegrity())
  {
    id v7 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Initial integrity check success", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
LABEL_39:
    }
      _IDSLogV();
  }
  else
  {
    uint64_t v8 = CSDBSqliteConnectionPerformSQL();
    if (v8 != 101 && v8)
    {
      uint64_t v106 = v8;
      _IMWarn();
    }
    else
    {
      unsigned int v9 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Reindexing the DB worked.", buf, 2u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        _IDSLogV();
      }
    }
    if (CSDBSqliteDatabaseCheckIntegrity())
    {
      unsigned int v10 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Post-reindex integrity check success", buf, 2u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        goto LABEL_39;
      }
    }
    else
    {
      int v11 = CSDBSqliteDatabaseVacuum();
      if (v11 != 101 && v11)
      {
        _IMWarn();
      }
      else
      {
        int v12 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Database vacuum success", buf, 2u);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
          _IDSLogV();
        }
      }
      if (CSDBSqliteDatabaseCheckIntegrity())
      {
        id v13 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Final integrity check success", buf, 2u);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
          goto LABEL_39;
        }
      }
      else
      {
        _IMWarn();
      }
    }
  }
  CSDBSqliteConnectionBegin();
  unsigned int v14 = a3 >> 3;
  if (a3 >> 3 <= 0x4E4)
  {
    CSDBSqliteConnectionBeginTransactionType();
    if (a3 == 7000)
    {
      CSDBSqliteDatabaseSetVersion();
      uint64_t v15 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Adding fields to support iMessage on IDS", buf, 2u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        _IDSLogV();
      }
      int v16 = sub_1003E9A74(a2, @"Unable to drop legacy table", @"Successfully dropped legacy table", @"DROP TABLE outgoing_message");
      CSDBRecordStoreCreateTablesForClass();
      if (!v16) {
        goto LABEL_425;
      }
      CSDBSqliteDatabaseSetVersion();
    }
    else if (a3 >> 1 != 3500)
    {
      unsigned int v21 = a3 - 7000;
      if ((a3 - 7000) > 2) {
        goto LABEL_68;
      }
      goto LABEL_61;
    }
    CSDBSqliteDatabaseSetVersion();
    __int16 v19 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Adding field to support sending iMessage from aliases", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    int v20 = sub_1003E9A74(a2, @"Unable to drop legacy table", @"Successfully dropped legacy table", @"DROP TABLE outgoing_message");
    CSDBRecordStoreCreateTablesForClass();
    if (!v20) {
      goto LABEL_425;
    }
    CSDBSqliteDatabaseSetVersion();
    unsigned int v21 = a3 - 7000;
LABEL_61:
    CSDBSqliteDatabaseSetVersion();
    CFStringRef v22 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Adding support for high priority messages", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    int v23 = sub_1003E9A74(a2, @"Unable to drop legacy table", @"Successfully dropped legacy table", @"DROP TABLE outgoing_message");
    CSDBRecordStoreCreateTablesForClass();
    if (!v23) {
      goto LABEL_425;
    }
    CSDBSqliteDatabaseSetVersion();
LABEL_68:
    if (a3 >> 2 == 1750)
    {
      CSDBSqliteDatabaseSetVersion();
      uint64_t v24 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Flushing stale messages to enable database", buf, 2u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        _IDSLogV();
      }
      int v25 = sub_1003E9A74(a2, @"Unable to drop legacy table", @"Successfully dropped legacy table", @"DROP TABLE outgoing_message");
      int v26 = sub_1003E9A74(a2, @"Unable to drop legacy table", @"Successfully dropped legacy table", @"DROP TABLE incoming_message");
      CSDBRecordStoreCreateTablesForClass();
      CSDBRecordStoreCreateTablesForClass();
      if ((v25 & v26) == 0) {
        goto LABEL_425;
      }
      CSDBSqliteDatabaseSetVersion();
    }
    if (v21 > 4)
    {
      if (v21 != 5)
      {
        if (v21 > 6) {
          goto LABEL_100;
        }
        goto LABEL_93;
      }
    }
    else
    {
      CSDBSqliteDatabaseSetVersion();
      id v27 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Flushing potentially old stale messages", buf, 2u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        _IDSLogV();
      }
      int v28 = sub_1003E9A74(a2, @"Unable to drop legacy table", @"Successfully dropped legacy table", @"DROP TABLE outgoing_message");
      int v29 = sub_1003E9A74(a2, @"Unable to drop legacy table", @"Successfully dropped legacy table", @"DROP TABLE incoming_message");
      CSDBRecordStoreCreateTablesForClass();
      CSDBRecordStoreCreateTablesForClass();
      if ((v28 & v29) == 0) {
        goto LABEL_425;
      }
      CSDBSqliteDatabaseSetVersion();
    }
    CSDBSqliteDatabaseSetVersion();
    __int16 v30 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Updating outgoing_message to have all needed fields", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    int v31 = sub_1003E9A74(a2, @"Unable to drop legacy table", @"Successfully dropped legacy table", @"DROP TABLE outgoing_message");
    CSDBRecordStoreCreateTablesForClass();
    if (!v31) {
      goto LABEL_425;
    }
    CSDBSqliteDatabaseSetVersion();
LABEL_93:
    CSDBSqliteDatabaseSetVersion();
    __int16 v32 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "Updating outgoing_message to have is_sent column", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    int v33 = sub_1003E9A74(a2, @"Unable to drop legacy table", @"Successfully dropped legacy table", @"DROP TABLE outgoing_message");
    CSDBRecordStoreCreateTablesForClass();
    if (!v33) {
      goto LABEL_425;
    }
    CSDBSqliteDatabaseSetVersion();
LABEL_100:
    if (v14 == 875)
    {
      CSDBSqliteDatabaseSetVersion();
      __int16 v34 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Updating outgoing_message to have new send types and options.", buf, 2u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        _IDSLogV();
      }
      int v35 = sub_1003E9A74(a2, @"Unable to drop legacy table", @"Successfully dropped legacy table", @"DROP TABLE outgoing_message");
      CSDBRecordStoreCreateTablesForClass();
      if (!v35) {
        goto LABEL_425;
      }
      CSDBSqliteDatabaseSetVersion();
    }
    if (v21 > 0x3E8)
    {
      if (v21 != 1001)
      {
        if (v21 > 0x3EA)
        {
          if (v21 != 1003)
          {
            if (v21 > 0x3EC)
            {
              if (v21 != 1005)
              {
                if (v21 > 0x3EE)
                {
                  if (v21 != 1007)
                  {
                    if (v21 > 0x3F0)
                    {
                      if (v21 != 1009)
                      {
                        if (v21 > 0x3F2)
                        {
                          if (v21 != 1011)
                          {
                            if (v21 > 0x3F4)
                            {
                              if (v21 != 1013)
                              {
                                if (v21 > 0x3F6)
                                {
                                  if (v21 > 0x7D1)
                                  {
                                    if (v21 != 2002)
                                    {
                                      if (v21 > 0xBB9)
                                      {
                                        if (v21 != 3002)
                                        {
                                          if (v21 > 0xBBB)
                                          {
                                            if (v21 != 3004)
                                            {
                                              if (v21 > 0xBBD)
                                              {
                                                if (v21 != 3006)
                                                {
                                                  if (v21 > 0xBBF)
                                                  {
                                                    if (v21 != 3008)
                                                    {
                                                      if (v21 > 0xBC1)
                                                      {
                                                        if (v21 != 3010)
                                                        {
                                                          if (v21 > 0xBC3)
                                                          {
                                                            if (v21 != 3012)
                                                            {
                                                              if (v21 > 0xBC9)
                                                              {
                                                                if (v21 != 3018)
                                                                {
                                                                  if (v21 > 0xBCB)
                                                                  {
                                                                    if (v21 != 3020)
                                                                    {
                                                                      if (v21 > 0xBCD)
                                                                      {
                                                                        if (v21 != 3022) {
                                                                          goto LABEL_392;
                                                                        }
LABEL_385:
                                                                        CSDBSqliteDatabaseSetVersion();
                                                                        id v104 = OSLogHandleForIDSCategory();
                                                                        if (os_log_type_enabled(v104, OS_LOG_TYPE_DEFAULT))
                                                                        {
                                                                          *(_WORD *)long long buf = 0;
                                                                          _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEFAULT, "Add delivery_minimum_time column to outgoing_message", buf, 2u);
                                                                        }

                                                                        if (os_log_shim_legacy_logging_enabled()
                                                                          && _IDSShouldLog())
                                                                        {
                                                                          _IDSLogV();
                                                                        }
                                                                        if (sub_1003E9C20(a2, @"delivery_minimum_time", @"INTEGER DEFAULT 0", @"outgoing_message"))
                                                                        {
                                                                          CSDBSqliteDatabaseSetVersion();
LABEL_392:
                                                                          CSDBSqliteConnectionCommit();
                                                                          CSDBSqliteConnectionPerformSQL();
                                                                          uint64_t v17 = 0;
                                                                          goto LABEL_51;
                                                                        }
LABEL_425:
                                                                        CSDBSqliteConnectionCommit();
                                                                        uint64_t v17 = 2;
                                                                        goto LABEL_426;
                                                                      }
LABEL_368:
                                                                      CSDBSqliteDatabaseSetVersion();
                                                                      long long v99 = OSLogHandleForIDSCategory();
                                                                      if (os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT))
                                                                      {
                                                                        *(_WORD *)long long buf = 0;
                                                                        _os_log_impl((void *)&_mh_execute_header, v99, OS_LOG_TYPE_DEFAULT, "Add kt_uri_verification_map column to outgoing_message", buf, 2u);
                                                                      }

                                                                      if (os_log_shim_legacy_logging_enabled()
                                                                        && _IDSShouldLog())
                                                                      {
                                                                        _IDSLogV();
                                                                      }
                                                                      int v100 = sub_1003E9C20(a2, @"kt_uri_verification_map", @"BLOB", @"outgoing_message");
                                                                      id v101 = OSLogHandleForIDSCategory();
                                                                      if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
                                                                      {
                                                                        *(_WORD *)long long buf = 0;
                                                                        _os_log_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_DEFAULT, "Add delivery_minimum_time_delay column to outgoing_message", buf, 2u);
                                                                      }

                                                                      if (os_log_shim_legacy_logging_enabled()
                                                                        && _IDSShouldLog())
                                                                      {
                                                                        _IDSLogV();
                                                                      }
                                                                      int v102 = sub_1003E9C20(a2, @"delivery_minimum_time_delay", @"INTEGER DEFAULT 0", @"outgoing_message");
                                                                      id v103 = OSLogHandleForIDSCategory();
                                                                      if (os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT))
                                                                      {
                                                                        *(_WORD *)long long buf = 0;
                                                                        _os_log_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_DEFAULT, "Add include_self column to outgoing_message", buf, 2u);
                                                                      }

                                                                      if (os_log_shim_legacy_logging_enabled()
                                                                        && _IDSShouldLog())
                                                                      {
                                                                        _IDSLogV();
                                                                      }
                                                                      if ((v100 & v102 & sub_1003E9C20(a2, @"include_self", @"INTEGER DEFAULT 0", @"outgoing_message")) != 1) {
                                                                        goto LABEL_425;
                                                                      }
                                                                      CSDBSqliteDatabaseSetVersion();
                                                                      goto LABEL_385;
                                                                    }
LABEL_356:
                                                                    CSDBSqliteDatabaseSetVersion();
                                                                    id v96 = OSLogHandleForIDSCategory();
                                                                    if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
                                                                    {
                                                                      *(_WORD *)long long buf = 0;
                                                                      _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "Add expiration_date column to incoming_message", buf, 2u);
                                                                    }

                                                                    if (os_log_shim_legacy_logging_enabled()
                                                                      && _IDSShouldLog())
                                                                    {
                                                                      _IDSLogV();
                                                                    }
                                                                    int v97 = sub_1003E9C20(a2, @"expiration_date", @"INTEGER DEFAULT 0", @"incoming_message");
                                                                    id v98 = OSLogHandleForIDSCategory();
                                                                    if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
                                                                    {
                                                                      *(_WORD *)long long buf = 0;
                                                                      _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_DEFAULT, "Add control_category column to incoming_message", buf, 2u);
                                                                    }

                                                                    if (os_log_shim_legacy_logging_enabled()
                                                                      && _IDSShouldLog())
                                                                    {
                                                                      _IDSLogV();
                                                                    }
                                                                    if ((v97 & sub_1003E9C20(a2, @"control_category", @"INTEGER DEFAULT 0", @"incoming_message")) != 1)goto LABEL_425; {
                                                                    CSDBSqliteDatabaseSetVersion();
                                                                    }
                                                                    goto LABEL_368;
                                                                  }
LABEL_339:
                                                                  CSDBSqliteDatabaseSetVersion();
                                                                  id v91 = OSLogHandleForIDSCategory();
                                                                  if (os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT))
                                                                  {
                                                                    *(_WORD *)long long buf = 0;
                                                                    _os_log_impl((void *)&_mh_execute_header, v91, OS_LOG_TYPE_DEFAULT, "Add send_mode column to outgoing_message", buf, 2u);
                                                                  }

                                                                  if (os_log_shim_legacy_logging_enabled()
                                                                    && _IDSShouldLog())
                                                                  {
                                                                    _IDSLogV();
                                                                  }
                                                                  int v92 = sub_1003E9C20(a2, @"send_mode", @"INTEGER DEFAULT 0", @"outgoing_message");
                                                                  uint64_t v93 = OSLogHandleForIDSCategory();
                                                                  if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT))
                                                                  {
                                                                    *(_WORD *)long long buf = 0;
                                                                    _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_DEFAULT, "Add kt_uri_verification_map column to outgoing_message", buf, 2u);
                                                                  }

                                                                  if (os_log_shim_legacy_logging_enabled()
                                                                    && _IDSShouldLog())
                                                                  {
                                                                    _IDSLogV();
                                                                  }
                                                                  int v94 = sub_1003E9C20(a2, @"kt_uri_verification_map", @"BLOB", @"outgoing_message");
                                                                  id v95 = OSLogHandleForIDSCategory();
                                                                  if (os_log_type_enabled(v95, OS_LOG_TYPE_DEFAULT))
                                                                  {
                                                                    *(_WORD *)long long buf = 0;
                                                                    _os_log_impl((void *)&_mh_execute_header, v95, OS_LOG_TYPE_DEFAULT, "Add wants_firewall_donation column to outgoing_message", buf, 2u);
                                                                  }

                                                                  if (os_log_shim_legacy_logging_enabled()
                                                                    && _IDSShouldLog())
                                                                  {
                                                                    _IDSLogV();
                                                                  }
                                                                  if ((v92 & v94 & sub_1003E9C20(a2, @"wants_firewall_donation", @"INTEGER DEFAULT 0", @"outgoing_message")) != 1)goto LABEL_425; {
                                                                  CSDBSqliteDatabaseSetVersion();
                                                                  }
                                                                  goto LABEL_356;
                                                                }
LABEL_327:
                                                                CSDBSqliteDatabaseSetVersion();
                                                                CFStringRef v88 = OSLogHandleForIDSCategory();
                                                                if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
                                                                {
                                                                  *(_WORD *)long long buf = 0;
                                                                  _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "Add send_mode column to outgoing_message", buf, 2u);
                                                                }

                                                                if (os_log_shim_legacy_logging_enabled()
                                                                  && _IDSShouldLog())
                                                                {
                                                                  _IDSLogV();
                                                                }
                                                                int v89 = sub_1003E9C20(a2, @"send_mode", @"INTEGER DEFAULT 0", @"outgoing_message");
                                                                id v90 = OSLogHandleForIDSCategory();
                                                                if (os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
                                                                {
                                                                  *(_WORD *)long long buf = 0;
                                                                  _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_DEFAULT, "Add wants_firewall_donation column to outgoing_message", buf, 2u);
                                                                }

                                                                if (os_log_shim_legacy_logging_enabled()
                                                                  && _IDSShouldLog())
                                                                {
                                                                  _IDSLogV();
                                                                }
                                                                if ((v89 & sub_1003E9C20(a2, @"wants_firewall_donation", @"INTEGER DEFAULT 0", @"outgoing_message")) != 1)goto LABEL_425; {
                                                                CSDBSqliteDatabaseSetVersion();
                                                                }
                                                                goto LABEL_339;
                                                              }
LABEL_315:
                                                              CSDBSqliteDatabaseSetVersion();
                                                              id v85 = OSLogHandleForIDSCategory();
                                                              if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
                                                              {
                                                                *(_WORD *)long long buf = 0;
                                                                _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "Add send_mode column to outgoing_message", buf, 2u);
                                                              }

                                                              if (os_log_shim_legacy_logging_enabled()
                                                                && _IDSShouldLog())
                                                              {
                                                                _IDSLogV();
                                                              }
                                                              int v86 = sub_1003E9C20(a2, @"send_mode", @"INTEGER DEFAULT 0", @"outgoing_message");
                                                              id v87 = OSLogHandleForIDSCategory();
                                                              if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
                                                              {
                                                                *(_WORD *)long long buf = 0;
                                                                _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEFAULT, "Add kt_uri_verification_map column to outgoing_message", buf, 2u);
                                                              }

                                                              if (os_log_shim_legacy_logging_enabled()
                                                                && _IDSShouldLog())
                                                              {
                                                                _IDSLogV();
                                                              }
                                                              if ((v86 & sub_1003E9C20(a2, @"kt_uri_verification_map", @"BLOB", @"outgoing_message")) != 1)goto LABEL_425; {
                                                              CSDBSqliteDatabaseSetVersion();
                                                              }
                                                              goto LABEL_327;
                                                            }
LABEL_308:
                                                            CSDBSqliteDatabaseSetVersion();
                                                            id v84 = OSLogHandleForIDSCategory();
                                                            if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
                                                            {
                                                              *(_WORD *)long long buf = 0;
                                                              _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "Add send_mode column to outgoing_message", buf, 2u);
                                                            }

                                                            if (os_log_shim_legacy_logging_enabled()
                                                              && _IDSShouldLog())
                                                            {
                                                              _IDSLogV();
                                                            }
                                                            if (!sub_1003E9C20(a2, @"send_mode", @"INTEGER DEFAULT 0", @"outgoing_message"))goto LABEL_425; {
                                                            CSDBSqliteDatabaseSetVersion();
                                                            }
                                                            goto LABEL_315;
                                                          }
LABEL_301:
                                                          CSDBSqliteDatabaseSetVersion();
                                                          id v83 = OSLogHandleForIDSCategory();
                                                          if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
                                                          {
                                                            *(_WORD *)long long buf = 0;
                                                            _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_DEFAULT, "Add push_priority column to outgoing_message", buf, 2u);
                                                          }

                                                          if (os_log_shim_legacy_logging_enabled()
                                                            && _IDSShouldLog())
                                                          {
                                                            _IDSLogV();
                                                          }
                                                          if (!sub_1003E9C20(a2, @"push_priority", @"INTEGER DEFAULT 0", @"outgoing_message"))goto LABEL_425; {
                                                          CSDBSqliteDatabaseSetVersion();
                                                          }
                                                          goto LABEL_308;
                                                        }
LABEL_294:
                                                        CSDBSqliteDatabaseSetVersion();
                                                        __int16 v82 = OSLogHandleForIDSCategory();
                                                        if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
                                                        {
                                                          *(_WORD *)long long buf = 0;
                                                          _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "Dropping old bypass_duet messages", buf, 2u);
                                                        }

                                                        if (os_log_shim_legacy_logging_enabled()
                                                          && _IDSShouldLog())
                                                        {
                                                          _IDSLogV();
                                                        }
                                                        if (!sub_1003E9A74(a2, @"Unable to drop bypass_duet messages", @"Successfully dropped bypass_duet messages", @"DELETE FROM outgoing_message where bypass_duet = 1;")) {
                                                          goto LABEL_425;
                                                        }
                                                        CSDBSqliteDatabaseSetVersion();
                                                        goto LABEL_301;
                                                      }
LABEL_287:
                                                      CSDBSqliteDatabaseSetVersion();
                                                      __int16 v80 = OSLogHandleForIDSCategory();
                                                      if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
                                                      {
                                                        *(_WORD *)long long buf = 0;
                                                        _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "Adding message_identifier column to incoming_message", buf, 2u);
                                                      }

                                                      if (os_log_shim_legacy_logging_enabled()
                                                        && _IDSShouldLog())
                                                      {
                                                        _IDSLogV();
                                                      }
                                                      int v81 = sub_1003E9C20(a2, @"message_identifier", @"TEXT", @"incoming_message");
                                                      if ((v81 & sub_1003E9A74(a2, @"Unable to add incoming_message message_identifier index", @"Successfully added incoming_message message_identifier index", @"CREATE INDEX incoming_message_message_identifier_idx ON incoming_message(message_identifier);")) != 1) {
                                                        goto LABEL_425;
                                                      }
                                                      CSDBSqliteDatabaseSetVersion();
                                                      goto LABEL_294;
                                                    }
LABEL_280:
                                                    CSDBSqliteDatabaseSetVersion();
                                                    __int16 v79 = OSLogHandleForIDSCategory();
                                                    if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
                                                    {
                                                      *(_WORD *)long long buf = 0;
                                                      _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "Add originalTimestamp column to outgoing_message", buf, 2u);
                                                    }

                                                    if (os_log_shim_legacy_logging_enabled()
                                                      && _IDSShouldLog())
                                                    {
                                                      _IDSLogV();
                                                    }
                                                    if (!sub_1003E9C20(a2, @"original_timestamp", @"INTEGER DEFAULT 0", @"outgoing_message"))goto LABEL_425; {
                                                    CSDBSqliteDatabaseSetVersion();
                                                    }
                                                    goto LABEL_287;
                                                  }
LABEL_273:
                                                  CSDBSqliteDatabaseSetVersion();
                                                  __int16 v78 = OSLogHandleForIDSCategory();
                                                  if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
                                                  {
                                                    *(_WORD *)long long buf = 0;
                                                    _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "Add wantsCertifiedDelivery column to outgoing_message", buf, 2u);
                                                  }

                                                  if (os_log_shim_legacy_logging_enabled()
                                                    && _IDSShouldLog())
                                                  {
                                                    _IDSLogV();
                                                  }
                                                  if (!sub_1003E9C20(a2, @"wants_certified_delivery", @"INTEGER DEFAULT 0", @"outgoing_message"))goto LABEL_425; {
                                                  CSDBSqliteDatabaseSetVersion();
                                                  }
                                                  goto LABEL_280;
                                                }
LABEL_266:
                                                CSDBSqliteDatabaseSetVersion();
                                                __int16 v77 = OSLogHandleForIDSCategory();
                                                if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
                                                {
                                                  *(_WORD *)long long buf = 0;
                                                  _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "Add ignoreMaxRetryCount column to outgoing_message", buf, 2u);
                                                }

                                                if (os_log_shim_legacy_logging_enabled()
                                                  && _IDSShouldLog())
                                                {
                                                  _IDSLogV();
                                                }
                                                if (!sub_1003E9C20(a2, @"ignore_max_retry_count", @"INTEGER DEFAULT 0", @"outgoing_message"))goto LABEL_425; {
                                                CSDBSqliteDatabaseSetVersion();
                                                }
                                                goto LABEL_273;
                                              }
LABEL_259:
                                              CSDBSqliteDatabaseSetVersion();
                                              uint64_t v76 = OSLogHandleForIDSCategory();
                                              if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
                                              {
                                                *(_WORD *)long long buf = 0;
                                                _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "Add wants progress column to outgoing_message", buf, 2u);
                                              }

                                              if (os_log_shim_legacy_logging_enabled()
                                                && _IDSShouldLog())
                                              {
                                                _IDSLogV();
                                              }
                                              if (!sub_1003E9C20(a2, @"wants_progress", @"INTEGER DEFAULT 0", @"outgoing_message"))goto LABEL_425; {
                                              CSDBSqliteDatabaseSetVersion();
                                              }
                                              goto LABEL_266;
                                            }
LABEL_252:
                                            CSDBSqliteDatabaseSetVersion();
                                            long long v73 = OSLogHandleForIDSCategory();
                                            if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
                                            {
                                              *(_WORD *)long long buf = 0;
                                              _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, "Add nonCloudWaking column to outgoing_message", buf, 2u);
                                            }

                                            if (os_log_shim_legacy_logging_enabled()
                                              && _IDSShouldLog())
                                            {
                                              _IDSLogV();
                                            }
                                            int v74 = sub_1003E9C20(a2, @"live_delivery", @"INTEGER DEFAULT 0", @"outgoing_message");
                                            int v75 = sub_1003E9C20(a2, @"require_bluetooth", @"INTEGER DEFAULT 0", @"outgoing_message");
                                            if ((v74 & v75 & sub_1003E9C20(a2, @"require_local_wifi", @"INTEGER DEFAULT 0", @"outgoing_message")) != 1)goto LABEL_425; {
                                            CSDBSqliteDatabaseSetVersion();
                                            }
                                            goto LABEL_259;
                                          }
LABEL_245:
                                          CSDBSqliteDatabaseSetVersion();
                                          long long v72 = OSLogHandleForIDSCategory();
                                          if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
                                          {
                                            *(_WORD *)long long buf = 0;
                                            _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "Add nonCloudWaking column to outgoing_message", buf, 2u);
                                          }

                                          if (os_log_shim_legacy_logging_enabled()
                                            && _IDSShouldLog())
                                          {
                                            _IDSLogV();
                                          }
                                          if (!sub_1003E9C20(a2, @"non_cloud_waking", @"INTEGER DEFAULT 0", @"outgoing_message"))goto LABEL_425; {
                                          CSDBSqliteDatabaseSetVersion();
                                          }
                                          goto LABEL_252;
                                        }
LABEL_238:
                                        CSDBSqliteDatabaseSetVersion();
                                        long long v71 = OSLogHandleForIDSCategory();
                                        if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
                                        {
                                          *(_WORD *)long long buf = 0;
                                          _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "Add skip_self column to outgoing_message", buf, 2u);
                                        }

                                        if (os_log_shim_legacy_logging_enabled()
                                          && _IDSShouldLog())
                                        {
                                          _IDSLogV();
                                        }
                                        if (!sub_1003E9C20(a2, @"skip_self", @"INTEGER DEFAULT 0", @"outgoing_message"))goto LABEL_425; {
                                        CSDBSqliteDatabaseSetVersion();
                                        }
                                        goto LABEL_245;
                                      }
LABEL_231:
                                      CSDBSqliteDatabaseSetVersion();
                                      long long v66 = OSLogHandleForIDSCategory();
                                      if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
                                      {
                                        *(_WORD *)long long buf = 0;
                                        _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "Setting a reasonable timeout on messages which are missing them", buf, 2u);
                                      }

                                      if (os_log_shim_legacy_logging_enabled()
                                        && _IDSShouldLog())
                                      {
                                        _IDSLogV();
                                      }
                                      long long v67 = +[NSDate date];
                                      long long v68 = [v67 dateByAddingTimeInterval:172800.0];

                                      [v68 timeIntervalSinceReferenceDate];
                                      +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"UPDATE outgoing_message SET expiration_date = %lld WHERE expiration_date = 0;",
                                      long long v70 = (uint64_t)v69);
                                      if (!sub_1003E9A74(a2, @"Unable to set expiration date on messages", @"Successfully added expiration date on messages", v70))
                                      {

                                        goto LABEL_425;
                                      }
                                      CSDBSqliteDatabaseSetVersion();

                                      goto LABEL_238;
                                    }
LABEL_224:
                                    CSDBSqliteDatabaseSetVersion();
                                    long long v65 = OSLogHandleForIDSCategory();
                                    if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
                                    {
                                      *(_WORD *)long long buf = 0;
                                      _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "Add message_type column to outgoing_message", buf, 2u);
                                    }

                                    if (os_log_shim_legacy_logging_enabled()
                                      && _IDSShouldLog())
                                    {
                                      _IDSLogV();
                                    }
                                    if (!sub_1003E9C20(a2, @"message_type", @"INTEGER DEFAULT 0", @"outgoing_message"))goto LABEL_425; {
                                    CSDBSqliteDatabaseSetVersion();
                                    }
                                    goto LABEL_231;
                                  }
LABEL_217:
                                  CSDBSqliteDatabaseSetVersion();
                                  id v62 = OSLogHandleForIDSCategory();
                                  if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
                                  {
                                    *(_WORD *)long long buf = 0;
                                    _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "Add pending_delete column to outgoing_message", buf, 2u);
                                  }

                                  if (os_log_shim_legacy_logging_enabled()
                                    && _IDSShouldLog())
                                  {
                                    _IDSLogV();
                                  }
                                  int v63 = sub_1003E9C20(a2, @"pending_delete", @"INTEGER DEFAULT 0", @"outgoing_message");
                                  int v64 = sub_1003E9C20(a2, @"local_destination_device_uuid", @"TEXT", @"outgoing_message");
                                  if ((v63 & v64 & sub_1003E9C20(a2, @"enqueued_date", @"INTEGER DEFAULT 0", @"outgoing_message")) != 1)goto LABEL_425; {
                                  CSDBSqliteDatabaseSetVersion();
                                  }
                                  goto LABEL_224;
                                }
LABEL_210:
                                CSDBSqliteDatabaseSetVersion();
                                double v61 = OSLogHandleForIDSCategory();
                                if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
                                {
                                  *(_WORD *)long long buf = 0;
                                  _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "Add main_account_guid column to outgoing_message", buf, 2u);
                                }

                                if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
                                  _IDSLogV();
                                }
                                if (!sub_1003E9C20(a2, @"main_account_guid", @"TEXT", @"outgoing_message"))goto LABEL_425; {
                                CSDBSqliteDatabaseSetVersion();
                                }
                                goto LABEL_217;
                              }
LABEL_203:
                              CSDBSqliteDatabaseSetVersion();
                              id v60 = OSLogHandleForIDSCategory();
                              if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
                              {
                                *(_WORD *)long long buf = 0;
                                _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "Adding indexes on account_guid, priority and is_send", buf, 2u);
                              }

                              if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
                                _IDSLogV();
                              }
                              if (!sub_1003E9A74(a2, @"Unable to add outgoing_message similar message query index", @"Successfully added outgoing_message similar message query index", @"CREATE INDEX outgoing_message_similarity_idx ON outgoing_message(account_guid, priority, is_sent);")) {
                                goto LABEL_425;
                              }
                              CSDBSqliteDatabaseSetVersion();
                              goto LABEL_210;
                            }
LABEL_197:
                            CSDBSqliteDatabaseSetVersion();
                            uint64_t v59 = OSLogHandleForIDSCategory();
                            if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
                            {
                              *(_WORD *)long long buf = 0;
                              _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "Create table outgoing_messages_to_delete", buf, 2u);
                            }

                            if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
                              _IDSLogV();
                            }
                            CSDBRecordStoreCreateTablesForClass();
                            CSDBSqliteDatabaseSetVersion();
                            goto LABEL_203;
                          }
LABEL_190:
                          CSDBSqliteDatabaseSetVersion();
                          long long v58 = OSLogHandleForIDSCategory();
                          if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
                          {
                            *(_WORD *)long long buf = 0;
                            _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "Add enforce_remote_timeout column to outgoing_message", buf, 2u);
                          }

                          if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
                            _IDSLogV();
                          }
                          if (!sub_1003E9C20(a2, @"enforce_remote_timeout", @"INTEGER DEFAULT 0", @"outgoing_message"))goto LABEL_425; {
                          CSDBSqliteDatabaseSetVersion();
                          }
                          goto LABEL_197;
                        }
LABEL_183:
                        CSDBSqliteDatabaseSetVersion();
                        id v56 = OSLogHandleForIDSCategory();
                        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_WORD *)long long buf = 0;
                          _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "Adding indexes on message guid", buf, 2u);
                        }

                        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
                          _IDSLogV();
                        }
                        int v57 = sub_1003E9A74(a2, @"Unable to add outgoing_message guid index", @"Successfully added outgoing_message guid index", @"CREATE INDEX IF NOT EXISTS outgoing_message_guid_idx ON outgoing_message(guid);");
                        if ((v57 & sub_1003E9A74(a2, @"Unable to add incoming_message guid index", @"Successfully added incoming_message guid index", @"CREATE INDEX IF NOT EXISTS incoming_message_guid_idx ON incoming_message(guid);")) != 1) {
                          goto LABEL_425;
                        }
                        CSDBSqliteDatabaseSetVersion();
                        goto LABEL_190;
                      }
LABEL_176:
                      CSDBSqliteDatabaseSetVersion();
                      uint64_t v54 = OSLogHandleForIDSCategory();
                      if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_WORD *)long long buf = 0;
                        _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "Duet columns, payload size added to outgoing message record", buf, 2u);
                      }

                      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
                        _IDSLogV();
                      }
                      int v55 = sub_1003E9A74(a2, @"Unable to drop legacy table", @"Successfully dropped legacy table", @"DROP TABLE outgoing_message");
                      CSDBRecordStoreCreateTablesForClass();
                      if (!v55) {
                        goto LABEL_425;
                      }
                      CSDBSqliteDatabaseSetVersion();
                      goto LABEL_183;
                    }
LABEL_169:
                    CSDBSqliteDatabaseSetVersion();
                    id v52 = OSLogHandleForIDSCategory();
                    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)long long buf = 0;
                      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "isLocal added to incoming message record", buf, 2u);
                    }

                    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
                      _IDSLogV();
                    }
                    int v53 = sub_1003E9A74(a2, @"Unable to drop legacy table", @"Successfully dropped legacy table", @"DROP TABLE incoming_message");
                    CSDBRecordStoreCreateTablesForClass();
                    if (!v53) {
                      goto LABEL_425;
                    }
                    CSDBSqliteDatabaseSetVersion();
                    goto LABEL_176;
                  }
LABEL_162:
                  CSDBSqliteDatabaseSetVersion();
                  id v50 = OSLogHandleForIDSCategory();
                  if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)long long buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "AlternateGUID support", buf, 2u);
                  }

                  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
                    _IDSLogV();
                  }
                  int v51 = sub_1003E9A74(a2, @"Unable to drop legacy table", @"Successfully dropped legacy table", @"DROP TABLE outgoing_message");
                  CSDBRecordStoreCreateTablesForClass();
                  if (!v51) {
                    goto LABEL_425;
                  }
                  CSDBSqliteDatabaseSetVersion();
                  goto LABEL_169;
                }
LABEL_155:
                CSDBSqliteDatabaseSetVersion();
                id v48 = OSLogHandleForIDSCategory();
                if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)long long buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "Outgoing message priority changes", buf, 2u);
                }

                if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
                  _IDSLogV();
                }
                int v49 = sub_1003E9A74(a2, @"Unable to drop legacy table", @"Successfully dropped legacy table", @"DROP TABLE outgoing_message");
                CSDBRecordStoreCreateTablesForClass();
                if (!v49) {
                  goto LABEL_425;
                }
                CSDBSqliteDatabaseSetVersion();
                goto LABEL_162;
              }
LABEL_148:
              CSDBSqliteDatabaseSetVersion();
              id v46 = OSLogHandleForIDSCategory();
              if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "Adding nonWaking, fireAndForget, queueOneIdentifier option", buf, 2u);
              }

              if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
                _IDSLogV();
              }
              int v47 = sub_1003E9A74(a2, @"Unable to drop legacy table", @"Successfully dropped legacy table", @"DROP TABLE outgoing_message");
              CSDBRecordStoreCreateTablesForClass();
              if (!v47) {
                goto LABEL_425;
              }
              CSDBSqliteDatabaseSetVersion();
              goto LABEL_155;
            }
LABEL_141:
            CSDBSqliteDatabaseSetVersion();
            uint64_t v44 = OSLogHandleForIDSCategory();
            if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "Adding compress option", buf, 2u);
            }

            if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
              _IDSLogV();
            }
            int v45 = sub_1003E9A74(a2, @"Unable to drop legacy table", @"Successfully dropped legacy table", @"DROP TABLE outgoing_message");
            CSDBRecordStoreCreateTablesForClass();
            if (!v45) {
              goto LABEL_425;
            }
            CSDBSqliteDatabaseSetVersion();
            goto LABEL_148;
          }
LABEL_133:
          CSDBSqliteDatabaseSetVersion();
          long long v42 = OSLogHandleForIDSCategory();
          if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "Adding app level ack", buf, 2u);
          }

          if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
            _IDSLogV();
          }
          int v43 = sub_1003E9A74(a2, @"Unable to drop legacy table", @"Successfully dropped legacy table", @"DROP TABLE outgoing_message");
          CSDBRecordStoreCreateTablesForClass();
          if (!v43) {
            goto LABEL_425;
          }
          CSDBSqliteDatabaseSetVersion();
          goto LABEL_141;
        }
LABEL_125:
        CSDBSqliteDatabaseSetVersion();
        long long v40 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "Adding expiration date support", buf, 2u);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
          _IDSLogV();
        }
        int v41 = sub_1003E9A74(a2, @"Unable to drop legacy table", @"Successfully dropped legacy table", @"DROP TABLE outgoing_message");
        CSDBRecordStoreCreateTablesForClass();
        if (!v41) {
          goto LABEL_425;
        }
        CSDBSqliteDatabaseSetVersion();
        goto LABEL_133;
      }
    }
    else
    {
      CSDBSqliteDatabaseSetVersion();
      id v36 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "Flushing stale outgoing_messages.", buf, 2u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        _IDSLogV();
      }
      int v37 = sub_1003E9A74(a2, @"Unable to drop legacy table", @"Successfully dropped legacy table", @"DROP TABLE outgoing_message");
      CSDBRecordStoreCreateTablesForClass();
      if (!v37) {
        goto LABEL_425;
      }
      CSDBSqliteDatabaseSetVersion();
    }
    CSDBSqliteDatabaseSetVersion();
    id v38 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "Adding indexes on message guid", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    int v39 = sub_1003E9A74(a2, @"Unable to add outgoing_message guid index", @"Successfully added outgoing_message guid index", @"CREATE INDEX outgoing_message_guid_idx ON outgoing_message(guid);");
    if ((v39 & sub_1003E9A74(a2, @"Unable to add incoming_message guid index", @"Successfully added incoming_message guid index", @"CREATE INDEX incoming_message_guid_idx ON incoming_message(guid);")) != 1) {
      goto LABEL_425;
    }
    CSDBSqliteDatabaseSetVersion();
    goto LABEL_125;
  }
  _IMWarn();
  uint64_t v17 = 2;
LABEL_51:
  __int16 v18 = +[NSDate date];
  [v18 timeIntervalSinceDate:v5];
  _IMWarn();

LABEL_426:
  return v17;
}

void sub_1003E9A20(id a1, CSDBThreadedRecordStore *a2)
{
  uint64_t v2 = a2;
  CSDBThreadedRecordStoreRegisterClass();
  CSDBThreadedRecordStoreRegisterClass();
}

uint64_t sub_1003E9A74(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v6 = a2;
  id v7 = a3;
  id v8 = a4;
  if ([v8 length])
  {
    int v9 = CSDBSqliteConnectionPerformSQL();
    if (v9) {
      BOOL v10 = v9 == 101;
    }
    else {
      BOOL v10 = 1;
    }
    uint64_t v11 = v10;
    if (v9 && v9 != 101)
    {
      CSDBSqliteErrMsg();
      _IMWarn();
    }
    else
    {
      int v12 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v15 = v7;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%@", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        _IDSLogV();
      }
    }
  }
  else
  {
    _IMWarn();
    uint64_t v11 = 1;
  }

  return v11;
}

uint64_t sub_1003E9C20(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (a1 && [v7 length] && objc_msgSend(v8, "length") && objc_msgSend(v9, "length"))
  {
    id v10 = [objc_alloc((Class)NSString) initWithFormat:@"SELECT %@ FROM %@", v7, v9];
    int v11 = CSDBSqliteConnectionPerformSQL();
    if ((v11 - 100) >= 2 && v11)
    {
      id v15 = [objc_alloc((Class)NSString) initWithFormat:@"IDS DB migration failed to add column %@ to the %@ table.", v7, v9];
      id v16 = [objc_alloc((Class)NSString) initWithFormat:@"Added %@ column to the %@ table.", v7, v9];
      id v17 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", @"ALTER TABLE %@ ADD COLUMN %@ %@;",
              v9,
              v7,
              v8);
      uint64_t v13 = sub_1003E9A74(a1, v15, v16, v17);
    }
    else
    {
      int v12 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412546;
        id v19 = v7;
        __int16 v20 = 2112;
        id v21 = v9;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "The %@ column already exists on %@, skipping this step.", buf, 0x16u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        _IDSLogV();
      }
      uint64_t v13 = 1;
    }
  }
  else
  {
    _IMWarn();
    uint64_t v13 = 0;
  }

  return v13;
}

void sub_1003EA394(id a1)
{
  off_100A4C988 = (uint64_t (*)(void, void))IMWeakLinkSymbol();
}

id sub_1003EA6DC(void *a1)
{
  id v1 = a1;
  if ([v1 containsString:@":"]) {
    goto LABEL_2;
  }
  if ([v1 _appearsToBeEmail])
  {
    id v2 = (id)_IDSCopyIDForEmailAddress();
  }
  else if ([v1 _appearsToBePhoneNumber])
  {
    id v2 = (id)_IDSCopyIDForPhoneNumberWithOptions();
  }
  else if ([v1 _appearsToBePseudonymID])
  {
    id v2 = [v1 _URIFromCanonicalizedPseudonymID];
  }
  else
  {
    if (![v1 _appearsToBeTemporaryID])
    {
LABEL_2:
      id v2 = v1;
      goto LABEL_11;
    }
    id v2 = [v1 _URIFromCanonicalizedTemporaryID];
  }
LABEL_11:
  uint64_t v3 = v2;

  return v3;
}

int64_t sub_1003EC1D4(id a1, NSUUID *a2, NSUUID *a3)
{
  id v4 = a3;
  id v5 = [(NSUUID *)a2 UUIDString];
  id v6 = [(NSUUID *)v4 UUIDString];

  id v7 = [v5 caseInsensitiveCompare:v6];
  return (int64_t)v7;
}

uint64_t sub_1003EC984(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1003EC994(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    (*(void (**)(void))(*(void *)(a1 + 72) + 16))();
  }
  else
  {
    if (!*(unsigned char *)(a1 + 88))
    {
      id v4 = [*(id *)(a1 + 32) utunDeliveryController];
      [v4 addUTunPeerWithDeviceUniqueID:IDSDeviceDefaultPairedDeviceUniqueID btuuid:*(void *)(a1 + 40)];
    }
    id v5 = [*(id *)(a1 + 32) utunDeliveryController];
    [v5 prepareForQuickSwitch];

    kdebug_trace();
    id v6 = [*(id *)(a1 + 32) pairingManager];
    [v6 addLocalPairedDevice:*(void *)(a1 + 40) BTOutOfBandKey:*(void *)(a1 + 48) shouldPairDirectlyOverIPsec:*(unsigned __int8 *)(a1 + 88) pairingType:*(void *)(a1 + 80) bluetoothMACAddress:*(void *)(a1 + 56)];

    kdebug_trace();
    kdebug_trace();
    id v7 = [*(id *)(a1 + 32) accountController];
    [v7 startLocalSetup];

    kdebug_trace();
    kdebug_trace();
    id v8 = [*(id *)(a1 + 32) utunDeliveryController];
    [v8 localSetupStarted];

    id v9 = [*(id *)(a1 + 32) utunController];
    [v9 startLocalSetup];

    id v10 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = *(void *)(a1 + 64);
      *(_DWORD *)long long buf = 138412290;
      uint64_t v14 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "(Daemon) Told to add a paired device %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
    kdebug_trace();
    int v12 = [*(id *)(a1 + 32) utunController];
    [v12 addPairedDevice:*(void *)(a1 + 40) shouldPairDirectlyOverIPsec:*(unsigned __int8 *)(a1 + 88)];
  }
}

id sub_1003ECE28(id a1, IDSEndpoint *a2)
{
  id v2 = a2;
  id v3 = [(IDSEndpoint *)v2 pushToken];
  if (v3)
  {
    id v4 = [(IDSEndpoint *)v2 KTLoggableData];

    if (v4)
    {
      id v5 = [IDSKeyTransparencyEntry alloc];
      id v6 = [(IDSEndpoint *)v2 pushToken];
      id v7 = [(IDSEndpoint *)v2 KTLoggableData];
      id v8 = [(IDSEndpoint *)v2 KTDeviceSignature];
      id v3 = [(IDSKeyTransparencyEntry *)v5 initWithPushToken:v6 loggableData:v7 signedData:v8];

      [(IDSKeyTransparencyEntry *)v3 setKtCapable:[(IDSEndpoint *)v2 ktCapableFlag]];
    }
    else
    {
      id v3 = 0;
    }
  }

  return v3;
}

void sub_1003ED230(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 state];
  uint64_t v5 = *(void *)(a1 + 32);
  if (v4)
  {
    id v6 = [v3 error];

    (*(void (**)(uint64_t, void, id))(v5 + 16))(v5, 0, v6);
  }
  else
  {
    id v6 = [v3 value];

    (*(void (**)(uint64_t, id, void))(v5 + 16))(v5, v6, 0);
  }
}

void sub_1003ED57C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, void *a7)
{
  id v9 = a7;
  id v10 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v11 = @"NO";
    if (a6) {
      CFStringRef v11 = @"YES";
    }
    *(_DWORD *)long long buf = 138412546;
    CFStringRef v27 = v11;
    __int16 v28 = 2112;
    id v29 = v9;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Completed query for forced verification. { success: %@, errorDictionary: %@ }", buf, 0x16u);
  }

  int v12 = [[IDSPeerIDKey alloc] initWithService:*(void *)(a1 + 32) fromURI:*(void *)(a1 + 40) toURI:*(void *)(a1 + 48)];
  uint64_t v13 = [*(id *)(a1 + 56) _peerIDManager];
  uint64_t v14 = [v13 pleaseDontCopyCacheDictionaryRepresentation];
  id v15 = [v14 objectForKeyedSubscript:v12];

  id v16 = [v15 keyTransparencyContext];
  id v17 = [v16 ticket];

  __int16 v18 = [IDSKeyTransparencyIndex alloc];
  uint64_t v19 = *(void *)(a1 + 32);
  __int16 v20 = [v15 keyTransparencyContext];
  id v21 = [v20 accountKey];
  CFStringRef v22 = [(IDSKeyTransparencyIndex *)v18 initWithServiceIdentifier:v19 accountKey:v21 URI:*(void *)(a1 + 48)];

  int v23 = [*(id *)(a1 + 56) _verifier];
  v24[0] = _NSConcreteStackBlock;
  v24[1] = 3221225472;
  v24[2] = sub_1003ED7CC;
  v24[3] = &unk_100981C88;
  id v25 = *(id *)(a1 + 64);
  [v23 forceVerificationWithIndex:v22 ticket:v17 completion:v24];
}

uint64_t sub_1003ED7CC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1003ED8A0(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) _verifier];
  id v4 = [v2 fetchTrustedDevicesFromKVS];

  if ([v4 count])
  {
    id v3 = objc_msgSend(v4, "__imArrayByApplyingBlock:", &stru_10098C660);
  }
  else
  {
    id v3 = &__NSArray0__struct;
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

id sub_1003ED948(id a1, IDSProtoKeyTransparencyTrustedDevice *a2)
{
  return [(IDSProtoKeyTransparencyTrustedDevice *)a2 dictionaryRepresentation];
}

void sub_1003EDA2C(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 value];

  id v4 = [v3 error];

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1003EDB64(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  id v8 = v5;
  id v9 = [v8 countByEnumeratingWithState:&v16 objects:v20 count:16];
  if (v9)
  {
    id v10 = v9;
    uint64_t v11 = *(void *)v17;
    do
    {
      for (uint64_t i = 0; i != v10; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v17 != v11) {
          objc_enumerationMutation(v8);
        }
        uint64_t v13 = *(const void **)(*((void *)&v16 + 1) + 8 * i);
        uint64_t v14 = objc_msgSend(v8, "objectForKey:", v13, (void)v16);
        id v15 = [v14 dictionaryRepresentation];
        if (v15) {
          CFDictionarySetValue(v7, v13, v15);
        }
      }
      id v10 = [v8 countByEnumeratingWithState:&v16 objects:v20 count:16];
    }
    while (v10);
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1003EDD8C(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  uint64_t v20 = a1;
  id v7 = a2;
  id v8 = a3;
  id v21 = a5;
  CFMutableDictionaryRef theDict = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
  id v9 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  id v10 = v7;
  id v11 = [v10 countByEnumeratingWithState:&v23 objects:v27 count:16];
  if (v11)
  {
    id v12 = v11;
    uint64_t v13 = *(void *)v24;
    do
    {
      for (uint64_t i = 0; i != v12; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v24 != v13) {
          objc_enumerationMutation(v10);
        }
        id v15 = *(const void **)(*((void *)&v23 + 1) + 8 * i);
        long long v16 = objc_msgSend(v10, "objectForKey:", v15, v20);
        long long v17 = [v8 objectForKey:v15];
        long long v18 = [v16 dictionaryRepresentation];
        if (v18) {
          CFDictionarySetValue(theDict, v15, v18);
        }

        long long v19 = [v17 dictionaryRepresentation];
        if (v19) {
          CFDictionarySetValue(v9, v15, v19);
        }
      }
      id v12 = [v10 countByEnumeratingWithState:&v23 objects:v27 count:16];
    }
    while (v12);
  }

  (*(void (**)(void))(*(void *)(v20 + 32) + 16))();
}

uint64_t sub_1003EE02C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1003EE930(id a1)
{
  id v1 = [[IDSRestoreMonitor alloc] initWithTimerBlock:&stru_10098C6C0];
  uint64_t v2 = qword_100A4C998;
  qword_100A4C998 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

IMTimer *__cdecl sub_1003EE978(id a1, id a2, SEL a3)
{
  id v4 = a2;
  id v5 = objc_alloc((Class)IMTimer);
  id v6 = im_primary_queue();
  id v7 = [v5 initWithTimeInterval:@"com.apple.identityservicesd-backup-check" name:0 shouldWake:v4 target:a3 selector:0 userInfo:v6 queue:60.0];

  return (IMTimer *)v7;
}

id sub_1003EEDF4(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _timerFired];
}

void sub_1003EF25C(id a1)
{
  id v1 = objc_alloc_init(IDSFirewallStore);
  uint64_t v2 = qword_100A4C9B0;
  qword_100A4C9B0 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_1003EF668(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) _currentLocalTime];
  id v9 = [*(id *)(a1 + 40) uri];
  id v3 = [v9 prefixedURI];
  id v4 = [*(id *)(a1 + 40) mergeID];
  uint64_t v5 = *(unsigned int *)(a1 + 48);
  uint64_t v6 = *(unsigned __int8 *)(a1 + 52);
  id v7 = [*(id *)(a1 + 40) lastSeen];
  [v7 timeIntervalSince1970];
  sub_100425F24((uint64_t)v3, (uint64_t)v4, v5, v6, (uint64_t)v8, (uint64_t)v2);
}

void sub_1003EF720(uint64_t a1)
{
  id v15 = [*(id *)(a1 + 32) _currentLocalTime];
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  id obj = *(id *)(a1 + 40);
  id v2 = [obj countByEnumeratingWithState:&v16 objects:v20 count:16];
  if (v2)
  {
    id v3 = v2;
    uint64_t v14 = *(void *)v17;
    do
    {
      id v4 = 0;
      do
      {
        if (*(void *)v17 != v14) {
          objc_enumerationMutation(obj);
        }
        uint64_t v5 = *(void *)(*((void *)&v16 + 1) + 8 * (void)v4);
        uint64_t v6 = [*(id *)(a1 + 48) uri];
        id v7 = [v6 prefixedURI];
        id v8 = [*(id *)(a1 + 48) mergeID];
        uint64_t v9 = *(unsigned int *)(a1 + 56);
        uint64_t v10 = *(unsigned __int8 *)(a1 + 60);
        id v11 = [*(id *)(a1 + 48) lastSeen];
        [v11 timeIntervalSince1970];
        sub_100425E14((uint64_t)v7, (uint64_t)v8, v5, v9, v10, (uint64_t)v12, (uint64_t)v15);

        id v4 = (char *)v4 + 1;
      }
      while (v3 != v4);
      id v3 = [obj countByEnumeratingWithState:&v16 objects:v20 count:16];
    }
    while (v3);
  }
}

id sub_1003EFAFC(uint64_t a1)
{
  sub_100426264((const __CFArray *)[*(id *)(a1 + 32) allObjects], *(unsigned int *)(a1 + 48), *(unsigned __int8 *)(a1 + 52));
  id result = [*(id *)(a1 + 40) count];
  if (result)
  {
    CFArrayRef v3 = (const __CFArray *)[*(id *)(a1 + 40) allObjects];
    uint64_t v4 = *(unsigned int *)(a1 + 48);
    uint64_t v5 = *(unsigned __int8 *)(a1 + 52);
    return (id)sub_100426398(v3, v4, v5);
  }
  return result;
}

id sub_1003EFDB8(uint64_t a1)
{
  sub_100426024((const __CFArray *)[*(id *)(a1 + 32) allObjects], *(unsigned int *)(a1 + 48));
  id result = [*(id *)(a1 + 40) count];
  if (result)
  {
    CFArrayRef v3 = (const __CFArray *)[*(id *)(a1 + 40) allObjects];
    uint64_t v4 = *(unsigned int *)(a1 + 48);
    return (id)sub_100426144(v3, v4);
  }
  return result;
}

uint64_t sub_1003EFE90(uint64_t a1)
{
  return sub_100426594(*(unsigned int *)(a1 + 32));
}

uint64_t sub_1003EFF10(uint64_t a1)
{
  return sub_1004264CC(*(unsigned int *)(a1 + 32), *(unsigned __int8 *)(a1 + 36));
}

void sub_1003F0000(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1003F0018(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) uri];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = sub_10042664C((uint64_t)[v2 prefixedURI], *(unsigned int *)(a1 + 48), *(unsigned __int8 *)(a1 + 52));
}

void sub_1003F01E8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_1003F0200(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) uri];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = sub_100426788((uint64_t)[v2 prefixedURI], *(unsigned int *)(a1 + 48));
}

uint64_t sub_1003F0264(uint64_t a1)
{
  uint64_t result = sub_1004268B8((uint64_t)[*(id *)(a1 + 32) mergeID], *(unsigned int *)(a1 + 48));
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = result;
  return result;
}

void sub_1003F0390(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1003F03A8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1003F03B8(uint64_t a1)
{
}

uint64_t sub_1003F03C0(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) _createFirewallRecordsFromSQLRecords:sub_1004269E8(*(unsigned int *)(a1 + 48))];
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v4 = *(void *)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  return _objc_release_x1(v2, v4);
}

void sub_1003F0508(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1003F0520(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) _createFirewallRecordsFromSQLRecords:sub_100426AF8(*(unsigned int *)(a1 + 48))];
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v4 = *(void *)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  return _objc_release_x1(v2, v4);
}

void sub_1003F095C(id a1)
{
  uint64_t v1 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "Performing initial database housekeeping", buf, 2u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  uint64_t v2 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "  => Setting cache size", v5, 2u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  sub_1001C0FF0();
  uint64_t v3 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "  => Invalidating caches", v4, 2u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  sub_1001C0F94();
}

void sub_1003F0C24(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_1003F0C40(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v3 = +[IMUserDefaults isFirewallEnabled];
    CFStringRef v4 = @"NO";
    if (v3) {
      CFStringRef v4 = @"YES";
    }
    *(_DWORD *)long long buf = 138412290;
    v19[0] = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Is firewall user default enabled %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    unsigned int v5 = +[IMUserDefaults isFirewallEnabled];
    CFStringRef v6 = @"NO";
    if (v5) {
      CFStringRef v6 = @"YES";
    }
    CFStringRef v16 = v6;
    _IDSLogV();
  }
  id v7 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v8 = +[IMUserDefaults shouldFirewallDropForAllCategories];
    CFStringRef v9 = @"NO";
    if (v8) {
      CFStringRef v9 = @"YES";
    }
    *(_DWORD *)long long buf = 138412290;
    v19[0] = v9;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Should firewall drop for all categories %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    unsigned int v10 = +[IMUserDefaults shouldFirewallDropForAllCategories];
    CFStringRef v11 = @"NO";
    if (v10) {
      CFStringRef v11 = @"YES";
    }
    CFStringRef v16 = v11;
    _IDSLogV();
  }
  CFStringRef v12 = 0;
  do
  {
    uint64_t v13 = objc_msgSend(WeakRetained, "getAllAllowedEntriesForCategory:", v12, v16, v17);
    uint64_t v14 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109378;
      LODWORD(v19[0]) = v12;
      WORD2(v19[0]) = 2112;
      *(void *)((char *)v19 + 6) = v13;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Entries for category %u: %@", buf, 0x12u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      CFStringRef v16 = v12;
      long long v17 = v13;
      _IDSLogV();
    }

    CFStringRef v12 = (const __CFString *)(v12 + 1);
  }
  while (v12 != 11);

  return 0;
}

void sub_1003F0F80(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1003F0DDCLL);
  }
  _Unwind_Resume(a1);
}

id sub_1003F1230(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _runCleanupWithExpirationInterval:2592000.0];
}

void sub_1003F136C(uint64_t a1)
{
  uint64_t v2 = +[NSDate dateWithTimeIntervalSince1970:](NSDate, "dateWithTimeIntervalSince1970:", (double)(unint64_t)[*(id *)(a1 + 32) _currentLocalTime]);
  unsigned int v3 = +[IDSServerBag sharedInstanceForBagType:0];
  CFStringRef v4 = [v3 objectForKey:@"ids-firewall-record-expiration-time-in-seconds"];

  [v4 doubleValue];
  if (v5 == 0.0) {
    double v5 = *(double *)(a1 + 40);
  }
  CFStringRef v6 = [v2 dateByAddingTimeInterval:-v5];
  id v7 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 138412290;
    CFStringRef v11 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "Removing entries older than %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    CFStringRef v9 = v6;
    _IDSLogV();
  }
  objc_msgSend(v6, "timeIntervalSince1970", v9);
  sub_100426C08((uint64_t)v8);
  sub_1001C0F94();
  [*(id *)(a1 + 32) _setDatabaseCloseTimerOnIvarQueue];
}

void *sub_1003F1600(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)a1 = a2;
  uint64_t result = malloc_type_malloc(16 * a2, 0x10800407411B482uLL);
  *(void *)(a1 + _Block_object_dispose(&STACK[0x320], 8) = result;
  return result;
}

void sub_1003F1644(uint64_t a1)
{
}

void sub_1003F164C(int *a1, int a2, void *a3)
{
  if (!*((void *)a1 + 1))
  {
    CFStringRef v11 = +[IDSFoundationLog utunController];
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v24 = 136315138;
    *(void *)long long v25 = "SimpleUInt32ToObjectTable_SetObjectForKey";
    CFStringRef v12 = "%s: table empty";
    uint64_t v13 = v11;
    uint32_t v14 = 12;
    goto LABEL_22;
  }
  id v6 = a3;
  uint64_t v7 = a1[4];
  double v8 = (char *)*((void *)a1 + 1);
  if ((int)v7 <= 0)
  {
    int v15 = a1[4];
    LODWORD(v7) = 0;
LABEL_20:
    id v21 = &v8[16 * (int)v7];
    *(_DWORD *)id v21 = a2;
    *((void *)v21 + 1) = a3;
    a1[4] = v15 + 1;
    CFStringRef v22 = +[IDSFoundationLog utunController];
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v23 = a1[4];
    int v24 = 67109890;
    *(_DWORD *)long long v25 = a2;
    *(_WORD *)&void v25[4] = 1024;
    *(_DWORD *)&v25[6] = v7;
    LOWORD(v26) = 1024;
    *(_DWORD *)((char *)&v26 + 2) = v23;
    HIWORD(v26) = 2112;
    CFStringRef v27 = a3;
    CFStringRef v12 = "UI32Table_Set: key %08X at %d (total elements: %d) store object %@";
    uint64_t v13 = v22;
    uint32_t v14 = 30;
LABEL_22:
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v24, v14);
    return;
  }
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  while (*(_DWORD *)&v8[v9] != a2)
  {
    ++v10;
    v9 += 16;
    if (v7 == v10) {
      goto LABEL_11;
    }
  }
  if (v7 != v10)
  {
    long long v19 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = *(void *)(*((void *)a1 + 1) + v9 + 8);
      int v24 = 138412546;
      *(void *)long long v25 = v20;
      *(_WORD *)&v25[8] = 2112;
      long long v26 = a3;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "UI32Table_Set: replacing object %@ with %@", (uint8_t *)&v24, 0x16u);
    }

    int v15 = a1[4] - 1;
    double v8 = (char *)*((void *)a1 + 1);
    LODWORD(v7) = v10;
    goto LABEL_20;
  }
LABEL_11:
  if (*a1 != v7)
  {
    int v15 = a1[4];
    goto LABEL_20;
  }
  double v8 = (char *)malloc_type_realloc(*((void **)a1 + 1), 32 * v7, 0x10800407411B482uLL);
  CFStringRef v16 = +[IDSFoundationLog utunController];
  BOOL v17 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
  if (v8)
  {
    if (v17)
    {
      int v18 = *a1;
      int v24 = 67109376;
      *(_DWORD *)long long v25 = v18;
      *(_WORD *)&void v25[4] = 1024;
      *(_DWORD *)&v25[6] = 2 * v7;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "UI32Table_Set: table resize from %d to %d", (uint8_t *)&v24, 0xEu);
    }
    *((void *)a1 + 1) = v8;
    *a1 = 2 * v7;
    int v15 = a1[4];
    goto LABEL_20;
  }
  if (v17)
  {
    int v24 = 138412290;
    *(void *)long long v25 = a3;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "UI32Table_Set: cannot allocate memory for %@", (uint8_t *)&v24, 0xCu);
  }
}

uint64_t sub_1003F1964(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = *(unsigned int *)(a1 + 16);
    if ((int)v3 >= 1)
    {
      for (uint64_t i = v2 + 8; *(_DWORD *)(i - 8) != a2; i += 16)
      {
        if (!--v3) {
          return 0;
        }
      }
      if (v3) {
        return *(void *)i;
      }
    }
  }
  else
  {
    double v5 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315138;
      double v8 = "SimpleUInt32ToObjectTable_ObjectForKey_NoRetain";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%s: table empty", (uint8_t *)&v7, 0xCu);
    }
  }
  return 0;
}

void sub_1003F1A54(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2)
  {
    double v8 = +[IDSFoundationLog utunController];
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v15 = 136315138;
    *(void *)CFStringRef v16 = "SimpleUInt32ToObjectTable_RemoveObjectForKey";
    uint64_t v9 = "%s: table empty";
    uint64_t v10 = v8;
    uint32_t v11 = 12;
LABEL_12:
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v15, v11);
    return;
  }
  uint64_t v5 = *(unsigned int *)(a1 + 16);
  if ((int)v5 < 1) {
    goto LABEL_10;
  }
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  while (*(_DWORD *)(v2 + v6) != a2)
  {
    ++v7;
    v6 += 16;
    if (v5 == v7) {
      goto LABEL_10;
    }
  }
  if (v5 == v7)
  {
LABEL_10:
    CFStringRef v12 = +[IDSFoundationLog utunController];
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v15 = 67109376;
    *(_DWORD *)CFStringRef v16 = a2;
    *(_WORD *)&v16[4] = 1024;
    *(_DWORD *)&v16[6] = v5;
    uint64_t v9 = "UI32Table_Remove: did not find %08X (from %d entries)";
    uint64_t v10 = v12;
    uint32_t v11 = 14;
    goto LABEL_12;
  }
  uint64_t v13 = +[IDSFoundationLog utunController];
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = *(void *)(*(void *)(a1 + 8) + v6 + 8);
    int v15 = 138412802;
    *(void *)CFStringRef v16 = v14;
    *(_WORD *)&v16[8] = 1024;
    int v17 = v7;
    __int16 v18 = 1024;
    int v19 = v5;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "UI32Table_Remove: removing %@ @%d (from %d entries)", (uint8_t *)&v15, 0x18u);
  }

  if ((int)v5 >= 2) {
    *(_OWORD *)(*(void *)(a1 + 8) + 16 * v7) = *(_OWORD *)(*(void *)(a1 + 8) + 16 * (v5 - 1));
  }
  --*(_DWORD *)(a1 + 16);
}

void sub_1003F1C58(uint64_t a1, uint64_t a2)
{
  int v4 = 0;
  char v5 = 0;
  int v6 = *(_DWORD *)(a1 + 16);
  char v10 = 0;
  do
  {
    if (v4 >= v6) {
      break;
    }
    char v9 = 0;
    uint64_t v7 = (unsigned int *)(*(void *)(a1 + 8) + 16 * v4);
    (*(void (**)(uint64_t, void, void, char *, char *))(a2 + 16))(a2, *v7, *((void *)v7 + 1), &v10, &v9);
    if (v9)
    {

      BOOL v8 = __OFSUB__(v6--, 1);
      if (!((v6 < 0) ^ v8 | (v6 == 0))) {
        *(_OWORD *)(*(void *)(a1 + 8) + 16 * v4) = *(_OWORD *)(*(void *)(a1 + 8) + 16 * v6);
      }
      char v5 = 1;
    }
    else
    {
      ++v4;
    }
  }
  while (!v10);
  if (v5) {
    *(_DWORD *)(a1 + 16) = v6;
  }
}

void *sub_1003F1D24(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)a1 = a2;
  uint64_t result = malloc_type_malloc(16 * a2, 0x80040803F642BuLL);
  *(void *)(a1 + _Block_object_dispose(&STACK[0x320], 8) = result;
  return result;
}

void sub_1003F1D68(int *a1, void *a2, void *a3)
{
  if (!*((void *)a1 + 1))
  {
    char v10 = +[IDSFoundationLog utunController];
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v22 = 136315138;
    *(void *)int v23 = "SimpleNSStringToObjectTable_SetObjectForKey";
    uint32_t v11 = "%s: table empty";
    CFStringRef v12 = v10;
    goto LABEL_9;
  }
  id v6 = a3;
  uint64_t v7 = a1[4];
  if ((int)v7 > 0)
  {
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    while (([*(id *)(*((void *)a1 + 1) + v8) isEqualToString:a2] & 1) == 0)
    {
      ++v9;
      v8 += 16;
      if (v7 == v9) {
        goto LABEL_12;
      }
    }
    if (v7 != v9)
    {
      uint64_t v20 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v21 = *(void *)(*((void *)a1 + 1) + v8 + 8);
        int v22 = 138412546;
        *(void *)int v23 = v21;
        *(_WORD *)&v23[8] = 2112;
        *(void *)int v24 = a3;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "NSSTable_Set: replacing object %@ with %@", (uint8_t *)&v22, 0x16u);
      }

      *(void *)(*((void *)a1 + 1) + 16 * v9 + _Block_object_dispose(&STACK[0x320], 8) = a3;
      LODWORD(v7) = v9;
      goto LABEL_18;
    }
LABEL_12:
    uint64_t v14 = (void *)*((void *)a1 + 1);
    if (*a1 != v7) {
      goto LABEL_17;
    }
    uint64_t v14 = malloc_type_realloc(*((void **)a1 + 1), 16 * (2 * v7), 0x80040803F642BuLL);
    int v15 = +[IDSFoundationLog utunController];
    BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
    if (v14)
    {
      if (v16)
      {
        int v17 = *a1;
        int v22 = 67109376;
        *(_DWORD *)int v23 = v17;
        *(_WORD *)&void v23[4] = 1024;
        *(_DWORD *)&v23[6] = 2 * v7;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "NSSTable_Set: table resize from %d to %d", (uint8_t *)&v22, 0xEu);
      }
      *((void *)a1 + 1) = v14;
      *a1 = 2 * v7;
      goto LABEL_17;
    }
    if (!v16) {
      return;
    }
    int v22 = 138412290;
    *(void *)int v23 = a3;
    uint32_t v11 = "NSSTable_Set: cannot allocate memory for %@";
    CFStringRef v12 = v15;
LABEL_9:
    uint32_t v13 = 12;
LABEL_20:
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v11, (uint8_t *)&v22, v13);
    return;
  }
  LODWORD(v7) = 0;
  uint64_t v14 = (void *)*((void *)a1 + 1);
LABEL_17:
  v14[2 * (int)v7 + 1] = a3;
  ++a1[4];
  *(void *)(*((void *)a1 + 1) + 16 * (int)v7) = [a2 copy];
LABEL_18:
  __int16 v18 = +[IDSFoundationLog utunController];
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    int v19 = a1[4];
    int v22 = 138413058;
    *(void *)int v23 = a2;
    *(_WORD *)&v23[8] = 1024;
    *(_DWORD *)int v24 = v7;
    *(_WORD *)&void v24[4] = 1024;
    *(_DWORD *)&v24[6] = v19;
    __int16 v25 = 2112;
    long long v26 = a3;
    uint32_t v11 = "NSSTable_Set: key %8@ at %d (total elements: %d) store object %@";
    CFStringRef v12 = v18;
    uint32_t v13 = 34;
    goto LABEL_20;
  }
}

uint64_t sub_1003F2080(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 8))
  {
    uint64_t v3 = *(unsigned int *)(a1 + 16);
    if ((int)v3 >= 1)
    {
      for (uint64_t i = 0;
            ([*(id *)(*(void *)(a1 + 8) + i) isEqualToString:a2] & 1) == 0;
            i += 16)
      {
        if (!--v3) {
          return 0;
        }
      }
      if (v3) {
        return *(void *)(*(void *)(a1 + 8) + i + 8);
      }
    }
  }
  else
  {
    id v6 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 136315138;
      uint64_t v9 = "SimpleNSStringToObjectTable_ObjectForKey_NoRetain";
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%s: table empty", (uint8_t *)&v8, 0xCu);
    }
  }
  return 0;
}

void sub_1003F2190(uint64_t a1, const char *a2)
{
  if (!*(void *)(a1 + 8))
  {
    uint64_t v7 = +[IDSFoundationLog utunController];
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v14 = 136315138;
    int v15 = "SimpleNSStringToObjectTable_RemoveObjectForKey";
    int v8 = "%s: table empty";
    uint64_t v9 = v7;
    uint32_t v10 = 12;
LABEL_12:
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v14, v10);
    return;
  }
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if ((int)v4 < 1) {
    goto LABEL_10;
  }
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  while (([*(id *)(*(void *)(a1 + 8) + v5) isEqualToString:a2] & 1) == 0)
  {
    ++v6;
    v5 += 16;
    if (v4 == v6) {
      goto LABEL_10;
    }
  }
  if (v4 == v6)
  {
LABEL_10:
    uint32_t v11 = +[IDSFoundationLog utunController];
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v14 = 138412546;
    int v15 = a2;
    __int16 v16 = 1024;
    int v17 = v4;
    int v8 = "NSSTable_Remove: did not find %@ (from %d entries)";
    uint64_t v9 = v11;
    uint32_t v10 = 18;
    goto LABEL_12;
  }
  CFStringRef v12 = +[IDSFoundationLog utunController];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    uint32_t v13 = *(const char **)(*(void *)(a1 + 8) + v5 + 8);
    int v14 = 138412802;
    int v15 = v13;
    __int16 v16 = 1024;
    int v17 = v6;
    __int16 v18 = 1024;
    int v19 = v4;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "NSSTable_Remove: removing %@ @%d (from %d entries)", (uint8_t *)&v14, 0x18u);
  }

  if ((int)v4 >= 2) {
    *(_OWORD *)(*(void *)(a1 + 8) + 16 * v6) = *(_OWORD *)(*(void *)(a1 + 8) + 16 * (v4 - 1));
  }
  --*(_DWORD *)(a1 + 16);
}

void sub_1003F23AC(uint64_t a1, uint64_t a2)
{
  int v4 = 0;
  char v5 = 0;
  int v6 = *(_DWORD *)(a1 + 16);
  char v10 = 0;
  do
  {
    if (v4 >= v6) {
      break;
    }
    char v9 = 0;
    uint64_t v7 = (void *)(*(void *)(a1 + 8) + 16 * v4);
    (*(void (**)(uint64_t, void, void, char *, char *))(a2 + 16))(a2, *v7, v7[1], &v10, &v9);
    if (v9)
    {

      BOOL v8 = __OFSUB__(v6--, 1);
      if (!((v6 < 0) ^ v8 | (v6 == 0))) {
        *(_OWORD *)(*(void *)(a1 + 8) + 16 * v4) = *(_OWORD *)(*(void *)(a1 + 8) + 16 * v6);
      }
      char v5 = 1;
    }
    else
    {
      ++v4;
    }
  }
  while (!v10);
  if (v5) {
    *(_DWORD *)(a1 + 16) = v6;
  }
}

void sub_1003F2F18(id a1)
{
  uint64_t v1 = objc_alloc_init(IDSGroupEncryptionController2Shim);
  uint64_t v2 = qword_100A4C9C8;
  qword_100A4C9C8 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_1003F34B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_1003F34C8(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  id result = [a2 isEqualToString:*(void *)(a1 + 32)];
  if (result)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
    *a4 = 1;
  }
  return result;
}

void sub_1003F36C0(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog RealTimeEncryptionController];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    *(_DWORD *)long long buf = 138412290;
    uint64_t v22 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "setAccount: Add the registraion listener for account: %@", buf, 0xCu);
  }

  int v4 = +[IDSDAccountController sharedInstance];
  char v5 = [v4 accountWithUniqueID:*(void *)(a1 + 32)];

  id v6 = objc_alloc_init((Class)NSMutableSet);
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  id obj = [v5 registeredDevices];
  id v7 = [obj countByEnumeratingWithState:&v16 objects:v20 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v17;
    do
    {
      for (uint64_t i = 0; i != v8; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v17 != v9) {
          objc_enumerationMutation(obj);
        }
        uint32_t v11 = [*(id *)(*((void *)&v16 + 1) + 8 * i) pushToken];
        CFStringRef v12 = [v5 service];
        uint32_t v13 = [v12 identifier];
        int v14 = +[IDSPushToken pushTokenWithData:v11 withServiceLoggingHint:v13];
        [v6 addObject:v14];
      }
      id v8 = [obj countByEnumeratingWithState:&v16 objects:v20 count:16];
    }
    while (v8);
  }

  [*(id *)(*(void *)(a1 + 40) + 80) setObject:v6 forKeyedSubscript:*(void *)(a1 + 32)];
  [v5 addRegistrationListener:*(void *)(a1 + 40)];
}

id sub_1003F3A84(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog RealTimeEncryptionController];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v7 = 138412290;
    uint64_t v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "setAccount: Remove the registraion listener for account: %@", (uint8_t *)&v7, 0xCu);
  }

  int v4 = +[IDSDAccountController sharedInstance];
  char v5 = [v4 accountWithUniqueID:*(void *)(a1 + 32)];
  [v5 removeRegistrationListener:*(void *)(a1 + 40)];

  return [*(id *)(*(void *)(a1 + 40) + 80) setObject:0 forKeyedSubscript:*(void *)(a1 + 32)];
}

uint64_t sub_1003F3D68(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

uint64_t sub_1003F5B7C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1003F6438(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 224), 8);
  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

void sub_1003F649C(void *a1, int a2)
{
  int v4 = +[IDSFoundationLog RealTimeEncryptionController];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(*(void *)(a1[8] + 8) + 24)) {
      CFStringRef v5 = @"YES";
    }
    else {
      CFStringRef v5 = @"NO";
    }
    if (*(unsigned char *)(*(void *)(a1[9] + 8) + 24)) {
      CFStringRef v6 = @"YES";
    }
    else {
      CFStringRef v6 = @"NO";
    }
    uint64_t v7 = a1[4];
    uint64_t v8 = a1[5];
    v11[0] = 67110146;
    v11[1] = a2;
    __int16 v12 = 2112;
    CFStringRef v13 = v5;
    __int16 v14 = 2112;
    CFStringRef v15 = v6;
    __int16 v16 = 2112;
    uint64_t v17 = v7;
    __int16 v18 = 2112;
    uint64_t v19 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "sendMessage: sendKeyMaterialMessageDataOverQR completed with %d. completionBlocks called %@ %@, groupID %@, sessionID %@", (uint8_t *)v11, 0x30u);
  }

  if (a1[6])
  {
    uint64_t v9 = *(void *)(a1[8] + 8);
    if (!*(unsigned char *)(v9 + 24))
    {
      *(unsigned char *)(v9 + 24) = 1;
      (*(void (**)(void))(a1[6] + 16))();
    }
  }
  if (a1[7])
  {
    uint64_t v10 = *(void *)(a1[9] + 8);
    if (!*(unsigned char *)(v10 + 24))
    {
      *(unsigned char *)(v10 + 24) = 1;
      (*(void (**)(void))(a1[7] + 16))();
    }
  }
}

void sub_1003F6618(void *a1, void *a2)
{
  id v3 = a2;
  int v4 = +[IDSFoundationLog RealTimeEncryptionController];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = a1[4];
    uint64_t v6 = a1[11];
    id v7 = [v3 idsResponseCode];
    if ([v3 lastCall]) {
      CFStringRef v8 = @"YES";
    }
    else {
      CFStringRef v8 = @"NO";
    }
    uint64_t v9 = [v3 responseError];
    int v18 = 138413314;
    *(void *)uint64_t v19 = v5;
    *(_WORD *)&v19[8] = 2048;
    *(void *)&unsigned char v19[10] = v6;
    *(_WORD *)&v19[18] = 2048;
    *(void *)&v19[20] = v7;
    *(_WORD *)&v19[28] = 2112;
    *(void *)&v19[30] = v8;
    *(_WORD *)&v19[38] = 2112;
    *(void *)&v19[40] = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Group session encryption message completion block fired { GUID: %@, command: %ld, responseCode: %lu, lastCall: %@, error: %@ }", (uint8_t *)&v18, 0x34u);
  }
  if ([v3 lastCall])
  {
    uint64_t v10 = +[IDSFoundationLog RealTimeEncryptionController];
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v11 = [v3 responseCode];
      if (*(unsigned char *)(*(void *)(a1[9] + 8) + 24)) {
        CFStringRef v12 = @"YES";
      }
      else {
        CFStringRef v12 = @"NO";
      }
      if (*(unsigned char *)(*(void *)(a1[10] + 8) + 24)) {
        CFStringRef v13 = @"YES";
      }
      else {
        CFStringRef v13 = @"NO";
      }
      uint64_t v14 = a1[5];
      uint64_t v15 = a1[6];
      int v18 = 67110146;
      *(_DWORD *)uint64_t v19 = v11;
      *(_WORD *)&void v19[4] = 2112;
      *(void *)&v19[6] = v12;
      *(_WORD *)&v19[14] = 2112;
      *(void *)&uint8_t v19[16] = v13;
      *(_WORD *)&v19[24] = 2112;
      *(void *)&v19[26] = v14;
      *(_WORD *)&v19[34] = 2112;
      *(void *)&v19[36] = v15;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "sendMessage: sendMessageWithSendParameters completed with %d. completionBlocks called %@ %@, groupID %@, sessionID %@", (uint8_t *)&v18, 0x30u);
    }

    if (a1[7])
    {
      uint64_t v16 = *(void *)(a1[9] + 8);
      if (!*(unsigned char *)(v16 + 24))
      {
        *(unsigned char *)(v16 + 24) = 1;
        (*(void (**)(void, id))(a1[7] + 16))(a1[7], [v3 responseCode]);
      }
    }
    if (a1[8])
    {
      uint64_t v17 = *(void *)(a1[10] + 8);
      if (!*(unsigned char *)(v17 + 24))
      {
        *(unsigned char *)(v17 + 24) = 1;
        (*(void (**)(void))(a1[8] + 16))();
      }
    }
  }
}

void sub_1003F6898(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog RealTimeEncryptionController_oversize];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = 136315651;
    uint64_t v5 = "IDSGroupEncryptionController2Shim.m";
    __int16 v6 = 1024;
    int v7 = 678;
    __int16 v8 = 2113;
    uint64_t v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%s:%d %{private}@", (uint8_t *)&v4, 0x1Cu);
  }
}

id sub_1003F6A9C(void *a1)
{
  uint64_t v1 = (void *)a1[4];
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t v4 = a1[7];
  uint64_t v5 = a1[8];
  [v1 _multiwayFTMessageSendTimeout];
  LOBYTE(v7) = 0;
  return objc_msgSend(v1, "_sendMessage:toDestination:forGroup:sessionID:command:timeout:shouldExpire:useQR:completion:completionBlock:", v2, v3, v4, v5, 210, 0, v7, 0, 0);
}

id sub_1003F6C2C(void *a1)
{
  uint64_t v1 = (void *)a1[4];
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t v4 = a1[7];
  uint64_t v5 = a1[8];
  [v1 _multiwayFTMessageSendTimeout];
  LOBYTE(v7) = 0;
  return objc_msgSend(v1, "_sendMessage:toDestination:forGroup:sessionID:command:timeout:shouldExpire:useQR:completion:completionBlock:", v2, v3, v4, v5, 210, 1, v7, 0, 0);
}

uint64_t sub_1003F7298(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = [v5 pushToken];
  if (v7)
  {
    __int16 v8 = [v5 pushToken];
    if ([v8 isNull])
    {
      unsigned int v9 = 0;
    }
    else
    {
      uint64_t v10 = *(void **)(a1 + 32);
      unsigned int v11 = [v5 pushToken];
      CFStringRef v12 = objc_msgSend(v11, "__imHexString");
      unsigned int v9 = [v10 containsObject:v12];
    }
  }
  else
  {
    unsigned int v9 = 0;
  }

  CFStringRef v13 = [v6 pushToken];
  if (v13)
  {
    uint64_t v14 = [v6 pushToken];
    if ([v14 isNull])
    {
      unsigned int v15 = 0;
    }
    else
    {
      uint64_t v16 = *(void **)(a1 + 32);
      uint64_t v17 = [v6 pushToken];
      int v18 = objc_msgSend(v17, "__imHexString");
      unsigned int v15 = [v16 containsObject:v18];
    }
  }
  else
  {
    unsigned int v15 = 0;
  }

  if (v9 ^ 1 | v15) {
    uint64_t v19 = (v9 ^ 1) & v15;
  }
  else {
    uint64_t v19 = -1;
  }

  return v19;
}

void sub_1003F8098(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) sessionController];
  uint64_t v3 = (uint64_t *)(a1 + 40);
  uint64_t v4 = [v2 sessionWithGroupID:*(void *)(a1 + 40)];

  id v5 = +[IDSFoundationLog RealTimeEncryptionController];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *v3;
    uint64_t v7 = [v4 uniqueID];
    *(_DWORD *)long long buf = 138412802;
    uint64_t v19 = v6;
    __int16 v20 = 2112;
    uint64_t v21 = v7;
    __int16 v22 = 2112;
    int v23 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "rollNewKeysAfterResettingPrekeysForGroups: %@ session %@: %@", buf, 0x20u);
  }
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  void v14[2] = sub_1003F82E4;
  v14[3] = &unk_10097E5A8;
  long long v15 = *(_OWORD *)(a1 + 32);
  id v16 = *(id *)(a1 + 48);
  id v8 = v4;
  id v17 = v8;
  unsigned int v9 = objc_retainBlock(v14);
  uint64_t v10 = (void (**)(void))v9;
  if (v8)
  {
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472;
    v12[2] = sub_1003F84D0;
    v12[3] = &unk_10097E7F0;
    CFStringRef v13 = v9;
    [v8 recvMembershipChangeEventWithReason:3 completionHandler:v12];
  }
  else
  {
    unsigned int v11 = +[IDSFoundationLog RealTimeEncryptionController];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      sub_1007232A8(v3, v11);
    }

    v10[2](v10);
  }
}

void sub_1003F82E4(uint64_t a1)
{
  [*(id *)(a1 + 32) resetKeysForGroup:*(void *)(a1 + 40) shouldRemoveCurrentParticipants:1];
  uint64_t v2 = im_primary_queue();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_1003F83B0;
  v5[3] = &unk_10097E5A8;
  void v5[4] = *(void *)(a1 + 32);
  id v3 = *(id *)(a1 + 48);
  uint64_t v4 = *(void *)(a1 + 40);
  id v6 = v3;
  uint64_t v7 = v4;
  id v8 = *(id *)(a1 + 56);
  dispatch_async(v2, v5);
}

void sub_1003F83B0(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) createRealTimeEncryptionFullIdentityForDevice:*(void *)(a1 + 40) completionBlock:0];
  id v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 48);
  id v5 = [*(id *)(a1 + 56) uniqueID];
  [v3 sendPublicKeyToGroup:v4 sessionID:v5];

  id v6 = *(void **)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 48);
  id v8 = [*(id *)(a1 + 56) uniqueID];
  [v6 requestKeyMaterialForGroup:v7 sessionID:v8];

  unsigned int v9 = *(void **)(a1 + 32);
  uint64_t v10 = [*(id *)(a1 + 56) uniqueID];
  [v9 _updateRelevantEncryptedDataBlobForSession:v10];

  +[NSDictionary dictionaryWithObjectsAndKeys:](NSDictionary, "dictionaryWithObjectsAndKeys:", &off_1009D23A0, IDSGlobalLinkOptionSessionInfoRequestTypeKey, &off_1009D23B8, IDSGlobalLinkOptionSessionInfoCommandFlagKey, 0);
  id v11 = (id)objc_claimAutoreleasedReturnValue();
  [*(id *)(a1 + 56) requestSessionInfoWithOptions:v11];
}

uint64_t sub_1003F84D0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1003F88F4(uint64_t a1)
{
  id v2 = +[IDSFoundationLog RealTimeEncryptionController_oversize];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = 136315651;
    id v5 = "IDSGroupEncryptionController2Shim.m";
    __int16 v6 = 1024;
    int v7 = 1013;
    __int16 v8 = 2113;
    uint64_t v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%s:%d %{private}@", (uint8_t *)&v4, 0x1Cu);
  }
}

void sub_1003F89C8(void *a1)
{
  id v2 = +[IDSFoundationLog RealTimeEncryptionController];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = a1[5];
    uint64_t v5 = a1[6];
    int v10 = 138412802;
    uint64_t v11 = v3;
    __int16 v12 = 2112;
    uint64_t v13 = v4;
    __int16 v14 = 2112;
    uint64_t v15 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "didReceiveEndpointsUpdate: %@ forGroup: %@ - roll new keys for the group (previous %@)", (uint8_t *)&v10, 0x20u);
  }

  __int16 v6 = (void *)a1[7];
  int v7 = +[NSArray arrayWithObject:a1[5]];
  [v6 rollNewKeysAfterResettingPrekeysForGroups:v7 withReason:2];

  [*(id *)(a1[7] + 88) invalidate];
  uint64_t v8 = a1[7];
  uint64_t v9 = *(void **)(v8 + 88);
  *(void *)(v8 + 8_Block_object_dispose(&STACK[0x320], 8) = 0;
}

void sub_1003F92C8(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_1003F93E8;
  v10[3] = &unk_100984C00;
  id v3 = v2;
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void **)(a1 + 48);
  id v11 = v3;
  uint64_t v12 = v4;
  id v13 = v5;
  [v3 initializeWithCompletion:v10];
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_1003F95EC;
  v7[3] = &unk_100984C28;
  __int16 v6 = *(void **)(a1 + 48);
  void v7[4] = *(void *)(a1 + 40);
  id v8 = v6;
  id v9 = *(id *)(a1 + 56);
  [*(id *)(a1 + 32) setResolvedEndpointsDidUpdateHandler:v7];
}

void sub_1003F93E8(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = objc_alloc_init((Class)NSMutableSet);
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  id v8 = v5;
  id v9 = [v8 countByEnumeratingWithState:&v17 objects:v29 count:16];
  if (v9)
  {
    id v10 = v9;
    uint64_t v11 = *(void *)v18;
    do
    {
      uint64_t v12 = 0;
      do
      {
        if (*(void *)v18 != v11) {
          objc_enumerationMutation(v8);
        }
        id v13 = objc_msgSend(*(id *)(*((void *)&v17 + 1) + 8 * (void)v12), "pushToken", (void)v17);
        __int16 v14 = +[IDSPushToken pushTokenWithData:v13];
        [v7 addObject:v14];

        uint64_t v12 = (char *)v12 + 1;
      }
      while (v10 != v12);
      id v10 = [v8 countByEnumeratingWithState:&v17 objects:v29 count:16];
    }
    while (v10);
  }

  uint64_t v15 = +[IDSFoundationLog RealTimeEncryptionController];
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = a1[4];
    *(_DWORD *)long long buf = 134218754;
    uint64_t v22 = v16;
    __int16 v23 = 2112;
    id v24 = v8;
    __int16 v25 = 2112;
    id v26 = v6;
    __int16 v27 = 2112;
    id v28 = v7;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "setMembers: endpointSubscription: %p initialResolvedEndpoints: %@ error: %@ _lastKnownGroupIDToPushTokens: %@", buf, 0x2Au);
  }

  os_unfair_lock_lock((os_unfair_lock_t)(a1[5] + 36));
  [*(id *)(a1[5] + 72) setObject:v7 forKeyedSubscript:a1[6]];
  os_unfair_lock_unlock((os_unfair_lock_t)(a1[5] + 36));
}

id sub_1003F95EC(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) didReceiveEndpointsUpdate:a2 forGroup:*(void *)(a1 + 40) sessionID:*(void *)(a1 + 48)];
}

void sub_1003F9D18(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) sessionController];
  id v3 = [v2 sessionWithGroupID:*(void *)(a1 + 40)];

  uint64_t v4 = +[IDSFoundationLog RealTimeEncryptionController];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 40);
    int v6 = 138412290;
    uint64_t v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Account is no longer registered, ending group: %@", (uint8_t *)&v6, 0xCu);
  }

  [v3 endSessionWithReason:47];
}

uint64_t IDSProtoApplicationKeyEntryReadFrom(uint64_t a1, uint64_t a2)
{
  while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      break;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0;
    while (1)
    {
      unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v7 == -1 || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v8 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
      v6 |= (unint64_t)(v8 & 0x7F) << v4;
      if ((v8 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v9 = v5++ >= 9;
      if (v9)
      {
        unint64_t v6 = 0;
        int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }
    *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0;
    }
LABEL_13:
    if (v10 || (v6 & 7) == 4) {
      break;
    }
    if ((v6 >> 3) == 2)
    {
      uint64_t v17 = PBReaderReadData();
      long long v18 = *(void **)(a1 + 16);
      *(void *)(a1 + 16) = v17;
    }
    else if ((v6 >> 3) == 1)
    {
      char v12 = 0;
      unsigned int v13 = 0;
      uint64_t v14 = 0;
      *(unsigned char *)(a1 + 24) |= 1u;
      while (1)
      {
        unint64_t v15 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v15 == -1 || v15 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
          break;
        }
        char v16 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v15);
        *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v15 + 1;
        v14 |= (unint64_t)(v16 & 0x7F) << v12;
        if ((v16 & 0x80) == 0) {
          goto LABEL_30;
        }
        v12 += 7;
        BOOL v9 = v13++ >= 9;
        if (v9)
        {
          LODWORD(v14) = 0;
          goto LABEL_32;
        }
      }
      *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_30:
      if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        LODWORD(v14) = 0;
      }
LABEL_32:
      *(_DWORD *)(a1 + _Block_object_dispose(&STACK[0x320], 8) = v14;
    }
    else
    {
      uint64_t result = PBReaderSkipValueWithTag();
      if (!result) {
        return result;
      }
    }
  }
  return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

id sub_1003FE398()
{
  if (qword_100A4C9D8 != -1) {
    dispatch_once(&qword_100A4C9D8, &stru_10098C8B0);
  }
  uint64_t v0 = (void *)qword_100A4C9D0;

  return v0;
}

void sub_1003FE3EC(id a1)
{
  nw_protocol_definition_t definition = nw_framer_create_definition("IDSNWSocketPairConnectionProtocol", 0, &stru_10098C8F0);
  uint64_t v2 = qword_100A4C9D0;
  qword_100A4C9D0 = (uint64_t)definition;

  _objc_release_x1(definition, v2);
}

int sub_1003FE434(id a1, OS_nw_framer *a2)
{
  uint64_t v2 = a2;
  nw_framer_set_input_handler((nw_framer_t)v2, &stru_10098C930);
  nw_framer_set_output_handler((nw_framer_t)v2, &stru_10098C998);
  nw_framer_pass_through_output((nw_framer_t)v2);

  return 1;
}

unint64_t sub_1003FE484(id a1, OS_nw_framer *a2)
{
  uint64_t v2 = a2;
  id v3 = +[IDSSocketPairMessage headerDataSize];
  size_t v5 = v3;
  *(void *)&long long v6 = 67109376;
  long long v16 = v6;
  do
  {
    uint64_t v18 = 0;
    long long v19 = &v18;
    uint64_t v20 = 0x2020000000;
    char v21 = 0;
    __chkstk_darwin(v3, v4);
    unint64_t v7 = (unsigned __int8 *)&parse[-2] - ((v5 + 15) & 0x1FFFFFFF0);
    if (v5) {
      memset((char *)&parse[-2] - ((v5 + 15) & 0x1FFFFFFF0), 170, v5);
    }
    parse[0] = _NSConcreteStackBlock;
    parse[1] = 3221225472;
    parse[2] = sub_1003FE77C;
    parse[3] = &unk_10098C958;
    parse[4] = &v18;
    parse[5] = v5;
    if (!nw_framer_parse_input((nw_framer_t)v2, v5, v5, (uint8_t *)&parse[-2] - ((v5 + 15) & 0x1FFFFFFF0), parse))
    {
      int v13 = 1;
      goto LABEL_18;
    }
    if (!*((unsigned char *)v19 + 24))
    {
      int v10 = +[IDSFoundationLog socketPairConnection];
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "IDSNWSocketPairConnection: IDSNWSocketPairConnectionProtocol returning -- no header.", buf, 2u);
      }
      goto LABEL_16;
    }
    int v8 = *v7;
    unsigned int v9 = *(_DWORD *)(v7 + 1);
    int v10 = nw_framer_message_create((nw_framer_t)v2);
    uint64_t v11 = +[IDSFoundationLog socketPairConnection];
    unsigned int v12 = bswap32(v9);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = v16;
      unsigned int v23 = v12;
      __int16 v24 = 1024;
      int v25 = v8;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "IDSNWSocketPairConnection: IDSNWSocketPairConnectionProtocol read message_length:%u, type:%u", buf, 0xEu);
    }

    if (!nw_framer_deliver_input_no_copy((nw_framer_t)v2, v5 + v12, v10, 1))
    {
      uint64_t v14 = +[IDSFoundationLog socketPairConnection];
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "IDSNWSocketPairConnection: IDSNWSocketPairConnectionProtocol returning partial data.", buf, 2u);
      }

LABEL_16:
      int v13 = 1;
      goto LABEL_17;
    }
    int v13 = 0;
LABEL_17:

LABEL_18:
    _Block_object_dispose(&v18, 8);
  }
  while (!v13);

  return 0;
}

void sub_1003FE74C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1003FE77C(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a2 && *(void *)(a1 + 40) <= a3) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
  return 0;
}

void sub_1003FE7A4(id a1, OS_nw_framer *a2, OS_nw_protocol_metadata *a3, unint64_t a4, BOOL a5)
{
}

void sub_1003FEAD4(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  if ((a2 - 4) >= 2 && a2)
  {
    if (a2 == 3)
    {
      long long v6 = (void *)nw_connection_copy_connected_path();
      if (v6)
      {
        uint64_t is_multilayer_packet_logging_enabled = nw_path_is_multilayer_packet_logging_enabled();
        int v8 = *(void **)(a1 + 32);
      }
      else
      {
        int v13 = +[IDSFoundationLog socketPairConnection];
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v14 = [*(id *)(a1 + 32) identifier];
          int v17 = 138412290;
          uint64_t v18 = v14;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "IDSNWSocketPairConnection: %@ Connection: nw_path_t is NULL, dissabling cross-layer logging.", (uint8_t *)&v17, 0xCu);
        }
        int v8 = *(void **)(a1 + 32);
        uint64_t is_multilayer_packet_logging_enabled = 0;
      }
      [v8 setShouldUseCrossLayerLogging:is_multilayer_packet_logging_enabled];
      unint64_t v15 = +[IDSFoundationLog socketPairConnection];
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        long long v16 = [*(id *)(a1 + 32) identifier];
        int v17 = 138412290;
        uint64_t v18 = v16;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "IDSNWSocketPairConnection: %@ Connection from listener is ready.", (uint8_t *)&v17, 0xCu);
      }
      [*(id *)(a1 + 32) _receiveFromNWConnection:*(void *)(*(void *)(a1 + 32) + 88)];
    }
    else
    {
      uint64_t v11 = +[IDSFoundationLog socketPairConnection];
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v12 = [*(id *)(a1 + 32) identifier];
        int v17 = 138412546;
        uint64_t v18 = v12;
        __int16 v19 = 1024;
        int v20 = a2;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "IDSNWSocketPairConnection: %@ Listening connection state: %d", (uint8_t *)&v17, 0x12u);
      }
    }
  }
  else
  {
    unsigned int v9 = +[IDSFoundationLog socketPairConnection];
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = [*(id *)(a1 + 32) identifier];
      int v17 = 138412290;
      uint64_t v18 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "IDSNWSocketPairConnection: %@ Listening connection closed.", (uint8_t *)&v17, 0xCu);
    }
    [*(id *)(a1 + 32) endSession];
  }
}

void sub_1003FF080(uint64_t a1, void *a2, void *a3, int a4, void *a5)
{
  unsigned int v9 = a2;
  int v10 = a3;
  id v11 = a5;
  if (v9)
  {
    size_t size = dispatch_data_get_size(v9);
    if (HIDWORD(size)) {
      goto LABEL_24;
    }
  }
  else
  {
    size_t size = 0;
  }
  unsigned int v13 = +[IDSSocketPairMessage headerDataSize];
  BOOL is_final = nw_content_context_get_is_final(v10);
  unint64_t v15 = +[IDSFoundationLog socketPairConnection];
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    long long v16 = [*(id *)(a1 + 32) identifier];
    *(_DWORD *)long long buf = 138412546;
    __int16 v34 = v16;
    __int16 v35 = 1024;
    LODWORD(v36) = size;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "IDSNWSocketPairConnection: %@ Read %u bytes", buf, 0x12u);
  }
  if (v9 && size >= v13)
  {
    BOOL v30 = is_final;
    int v17 = v9;
    -[NSObject subdataWithRange:](v17, "subdataWithRange:", 0, v13);
    uint64_t v18 = v29 = a4;
    __int16 v19 = -[NSObject subdataWithRange:](v17, "subdataWithRange:", v13, (char *)[v17 length] - v13);
    id v20 = v18;
    if (bswap32(*(_DWORD *)((char *)[v20 bytes] + 1)) + v13 == size && v29 != 0)
    {
      uint64_t v22 = +[IDSSocketPairMessage messageWithHeaderData:v20 data:v19];
      [*(id *)(a1 + 32) _processIncomingRawMessage:v22];
    }
    BOOL is_final = v30;
  }
  if (v11) {
    int v23 = 1;
  }
  else {
    int v23 = is_final;
  }
  if (v23 != 1)
  {
    __int16 v27 = +[IDSDaemonPriorityQueueController sharedInstance];
    v31[0] = _NSConcreteStackBlock;
    v31[1] = 3221225472;
    v31[2] = sub_1003FF3D0;
    v31[3] = &unk_10097E440;
    id v28 = *(void **)(a1 + 40);
    void v31[4] = *(void *)(a1 + 32);
    id v32 = v28;
    [v27 performBlockWithPriority:v31 priority:*(void *)(*(void *)(a1 + 32) + 80)];

    goto LABEL_26;
  }
  __int16 v24 = +[IDSFoundationLog socketPairConnection];
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    int v25 = [*(id *)(a1 + 32) identifier];
    CFStringRef v26 = @"NO";
    *(_DWORD *)long long buf = 138412802;
    __int16 v34 = v25;
    __int16 v35 = 2112;
    if (is_final) {
      CFStringRef v26 = @"YES";
    }
    id v36 = v11;
    __int16 v37 = 2112;
    CFStringRef v38 = v26;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "IDSNWSocketPairConnection: %@ nw_connection_receive_message Error %@, isFinal %@", buf, 0x20u);
  }
LABEL_24:
  [*(id *)(a1 + 32) endSession];
LABEL_26:
}

id sub_1003FF3D0(uint64_t a1)
{
  return [*(id *)(a1 + 32) _receiveFromNWConnection:*(void *)(a1 + 40)];
}

_DWORD *sub_1003FFCF4(uint64_t a1)
{
  uint64_t result = *(_DWORD **)(a1 + 32);
  if (!result[8]) {
    return [result _dequeueNextMessageFromOutgoingQueue];
  }
  return result;
}

void sub_1004000C4(uint64_t a1, void *a2)
{
  id v7 = a2;
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();
  uint64_t v4 = *(void **)(a1 + 32);
  if (isKindOfClass)
  {
    uint64_t v5 = [v7 objectForKey:@"originalMessage"];

    id v6 = (id)v5;
  }
  else
  {
    id v6 = v7;
  }
  id v8 = v6;
  [v4 addObject:v6];
}

void sub_10040024C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = +[IDSFoundationLog socketPairConnection];
  uint64_t v5 = v4;
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      id v6 = [*(id *)(a1 + 32) identifier];
      int v8 = 138412546;
      unsigned int v9 = v6;
      __int16 v10 = 2112;
      id v11 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "IDSNWSocketPairConnection: _sendDataViaNWConnection: %@ Error %@! Could not write data to nw_connection.", (uint8_t *)&v8, 0x16u);
    }
    [*(id *)(a1 + 32) endSession];
  }
  else
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG)) {
      sub_100723F24(a1, v5);
    }
  }
  --*(_DWORD *)(*(void *)(a1 + 32) + 32);
  id v7 = *(_DWORD **)(a1 + 32);
  if (!v7[8]) {
    [v7 _dequeueNextMessageFromOutgoingQueue];
  }
}

void sub_100400B98(uint64_t a1)
{
  IDSTransportThreadRemoveSocket();
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 8));
  os_channel_destroy();
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = *(void **)(v2 + 16);
  *(void *)(v2 + 16) = 0;

  uint64_t v4 = (os_unfair_lock_s *)(*(void *)(a1 + 32) + 8);

  os_unfair_lock_unlock(v4);
}

uint64_t sub_10040113C()
{
  return IDSTransportThreadAddSocket();
}

void sub_1004011BC(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 8));
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(v2 + 32);
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 8));
  if (v3)
  {
    uint64_t v4 = *(unsigned int *)(a1 + 48);
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472;
    v8[2] = sub_1004012EC;
    v8[3] = &unk_10098CA38;
    uint64_t v5 = *(void *)(a1 + 40);
    void v8[4] = *(void *)(a1 + 32);
    sub_10022388C(v3, v5, v4, v8);
  }
  else
  {
    id v6 = +[IDSFoundationLog Multiplexer];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      *(_DWORD *)long long buf = 138412290;
      uint64_t v10 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "startReadOnTransportThread fd ready to read but os_channel now nil - %@", buf, 0xCu);
    }
  }
}

uint64_t sub_1004012EC(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 8));
  uint64_t v4 = (uint64_t (**)(id, void))objc_retainBlock(*(id *)(*(void *)(a1 + 32) + 16));
  *(unsigned char *)(a2 + 43) = *(unsigned char *)(*(void *)(a1 + 32) + 66);
  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 8));
  uint64_t v5 = v4[2](v4, a2);

  return v5;
}

nw_protocol_definition_t sub_100401868(void *a1)
{
  start_handler[0] = _NSConcreteStackBlock;
  start_handler[1] = 3221225472;
  start_handler[2] = sub_100401908;
  start_handler[3] = &unk_10098CAD0;
  id v5 = a1;
  id v1 = v5;
  nw_protocol_definition_t definition = nw_framer_create_definition("IDSGroupSessionProtocol", 0, start_handler);

  return definition;
}

uint64_t sub_100401908(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = a2;
  [v3 setFramer:v4];
  id v5 = [*(id *)(a1 + 32) transport];
  id v6 = [v5 participantIDToAliasConverter];
  uint64_t v7 = [*(id *)(a1 + 32) multiplexerParams];
  id v8 = [v7 participantID];
  unsigned int v9 = [*(id *)(a1 + 32) multiplexerParams];
  uint64_t v10 = [v9 salt];
  id v11 = [v6 participantIDForAlias:v8 salt:v10];

  [*(id *)(a1 + 32) setContext:v11];
  unsigned __int8 v12 = [*(id *)(a1 + 32) verboseFunctionalLogging];
  input_handler[0] = _NSConcreteStackBlock;
  input_handler[1] = 3221225472;
  input_handler[2] = sub_100401A70;
  input_handler[3] = &unk_10098CA88;
  id v16 = v11;
  unsigned __int8 v17 = v12;
  id v15 = *(id *)(a1 + 32);
  nw_framer_set_input_handler(v4, input_handler);
  nw_framer_set_output_handler(v4, &stru_10098CAA8);

  return 1;
}

uint64_t sub_100401A70(uint64_t a1, NSObject *a2)
{
  do
  {
    parse[0] = _NSConcreteStackBlock;
    parse[1] = 3221225472;
    parse[2] = sub_100401B44;
    parse[3] = &unk_10098CA60;
    uint64_t v4 = *(void **)(a1 + 32);
    uint64_t v9 = *(void *)(a1 + 40);
    char v10 = *(unsigned char *)(a1 + 48);
    id v8 = v4;
    BOOL v5 = nw_framer_parse_input(a2, 1uLL, 0xFFFFFFFFuLL, 0, parse);
  }
  while (v5);
  return 1;
}

size_t sub_100401B44(uint64_t a1, const void *a2, size_t a3)
{
  size_t result = 0;
  if (a2 && a3)
  {
    uint64_t v7 = _IDSLinkPacketBufferCreate();
    id v8 = (uint64_t *)v7;
    uint64_t v9 = *(void *)(a1 + 40);
    if (v9)
    {
      *(_DWORD *)(v7 + 536) |= 1u;
      *(void *)(v7 + 48_Block_object_dispose(&STACK[0x320], 8) = v9;
    }
    memcpy(*(void **)v7, a2, a3);
    v8[2] = a3;
    char v10 = +[IDSFoundationLog Multiplexer];
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = *(void *)(a1 + 40);
      int v14 = 134218240;
      size_t v15 = a3;
      __int16 v16 = 2048;
      uint64_t v17 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "input_handler read %lu bytes for participant %llu", (uint8_t *)&v14, 0x16u);
    }

    if (*(unsigned char *)(a1 + 48))
    {
      unsigned __int8 v12 = +[IDSFoundationLog Multiplexer];
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v13 = sub_1002237D8(*v8, v8[2]);
        int v14 = 136315138;
        size_t v15 = (size_t)v13;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "input_handler whole packet:\n%s", (uint8_t *)&v14, 0xCu);
      }
    }
    [*(id *)(a1 + 32) callPacketBufferReadHandler:v8];
    _IDSLinkPacketBufferRelease();
    return a3;
  }
  return result;
}

void sub_100401CF0(id a1, OS_nw_framer *a2, OS_nw_protocol_metadata *a3, unint64_t a4, BOOL a5)
{
}

void sub_100402368(uint64_t a1)
{
}

void sub_100402890(uint64_t a1, void *a2, void *a3, char a4, void *a5)
{
  id v9 = a3;
  id v10 = a5;
  v25[0] = _NSConcreteStackBlock;
  v25[1] = 3221225472;
  v25[2] = sub_100402A8C;
  v25[3] = &unk_100984CA0;
  char v30 = a4;
  id v11 = v9;
  id v26 = v11;
  id v12 = v10;
  uint64_t v13 = *(void *)(a1 + 32);
  int v14 = *(void **)(a1 + 40);
  id v27 = v12;
  uint64_t v28 = v13;
  id v29 = v14;
  id v15 = a2;
  __int16 v16 = objc_retainBlock(v25);
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 184));
  uint64_t v17 = [*(id *)(a1 + 32) multiplexerParams];
  id v18 = [v17 participantID];

  uint64_t v19 = _IDSLinkPacketBufferCreate();
  uint64_t v20 = v19;
  if (v18)
  {
    *(_DWORD *)(v19 + 536) |= 1u;
    *(void *)(v19 + 48_Block_object_dispose(&STACK[0x320], 8) = v18;
  }
  uint64_t v21 = *(void *)v19;
  *(_WORD *)uint64_t v21 = __rev16([*(id *)(a1 + 32) localPort]);
  unsigned __int16 v22 = (unsigned __int16)[*(id *)(a1 + 32) remotePort];
  *(unsigned char *)(v21 + 2) = HIBYTE(v22);
  *(unsigned char *)(v21 + 3) = v22;
  *(_DWORD *)(v21 + 4) = 0;
  id v23 = v15;
  memcpy((void *)(v21 + 8), [v23 bytes], (size_t)objc_msgSend(v23, "length"));
  __int16 v24 = (char *)[v23 length];

  *(void *)(v20 + 16) = v24 + 8;
  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 184));
  [*(id *)(a1 + 32) callPacketBufferReadHandler:v20];
  ((void (*)(void *))v16[2])(v16);
}

id sub_100402A8C(id result)
{
  id v1 = result;
  if (*((unsigned char *)result + 64))
  {
    uint64_t v2 = *((void *)result + 4);
    if (!v2 || (size_t result = (id)nw_content_context_get_is_final(v2), result)) {
      exit(0);
    }
  }
  if (!v1[5])
  {
    uint64_t v3 = (void *)v1[6];
    uint64_t v4 = v1[7];
    return [v3 receiveFromSimulatorSendToQRLoopFromConnection:v4];
  }
  return result;
}

void sub_100402B18(id a1, OS_nw_error *a2)
{
  if (a2)
  {
    int error_code = nw_error_get_error_code((nw_error_t)a2);
    *__error() = error_code;
  }
}

void sub_100403098(id a1)
{
  id v1 = objc_alloc_init(IDSDevicePropertiesStateNotifier);
  uint64_t v2 = qword_100A4C9E8;
  qword_100A4C9E8 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

BOOL sub_1004039F4(void *a1)
{
  id v1 = a1;
  uint64_t v2 = [v1 unprefixedURI];
  CMFItemFromString = (const void *)CreateCMFItemFromString();
  int IsItemBlocked = CMFBlockListIsItemBlocked();
  if (CMFItemFromString) {
    CFRelease(CMFItemFromString);
  }
  if (_IMWillLog()) {
    _IMAlwaysLog();
  }

  return IsItemBlocked != 0;
}

id sub_100404060(void *a1)
{
  id v1 = a1;
  id v2 = objc_alloc_init((Class)NSMutableData);
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  uint64_t v3 = objc_msgSend(v1, "allObjects", 0);
  uint64_t v4 = [v3 sortedArrayUsingComparator:&stru_10098CBB0];

  id v5 = [v4 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v11;
    do
    {
      for (uint64_t i = 0; i != v6; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v11 != v7) {
          objc_enumerationMutation(v4);
        }
        [v2 appendData:*(void *)(*((void *)&v10 + 1) + 8 * i)];
      }
      id v6 = [v4 countByEnumeratingWithState:&v10 objects:v14 count:16];
    }
    while (v6);
  }

  return v2;
}

void sub_100404C60(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x100404660);
  }
  _Unwind_Resume(a1);
}

id sub_100404CD4(id a1, IDSServiceProperties *a2)
{
  return [(IDSServiceProperties *)a2 queryService];
}

int64_t sub_100404DF8(id a1, NSData *a2, NSData *a3)
{
  uint64_t v4 = a3;
  id v5 = [(NSData *)a2 __imHexString];
  id v6 = [(NSData *)v4 __imHexString];

  id v7 = [v5 compare:v6];
  return (int64_t)v7;
}

void sub_100404EBC(id a1)
{
  id v1 = objc_alloc_init(IDSDevicePolicyController);
  uint64_t v2 = qword_100A4C9F8;
  qword_100A4C9F8 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_100405158(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    if (a2 == 2)
    {
      objc_begin_catch(exception_object);
      objc_end_catch();
      JUMPOUT(0x1004050CCLL);
    }
    objc_begin_catch(exception_object);
    os_unfair_lock_unlock(v2);
    objc_exception_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void sub_1004051B4(uint64_t a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  JUMPOUT(0x10040517CLL);
}

void sub_100405220(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_100405234(_Unwind_Exception *a1)
{
}

void sub_1004055C4(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    if (a2 == 2)
    {
      objc_begin_catch(exception_object);
      objc_end_catch();
      JUMPOUT(0x10040540CLL);
    }
    objc_begin_catch(exception_object);
    os_unfair_lock_unlock(v2);
    objc_exception_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void sub_100405BEC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100405C60;
  block[3] = &unk_10097E4D0;
  void block[4] = v1;
  dispatch_async(v2, block);
}

id sub_100405C60(uint64_t a1)
{
  uint64_t v2 = +[IMRGLog registration];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Migration completed, calling updateUsers", v4, 2u);
  }

  return [*(id *)(*(void *)(a1 + 32) + 16) reloadUsersForRealm:1];
}

Class sub_100405DB0(uint64_t a1)
{
  v3[0] = 0;
  if (!qword_100A4CA08)
  {
    v3[1] = _NSConcreteStackBlock;
    v3[2] = (void *)3221225472;
    v3[3] = sub_100405EDC;
    void v3[4] = &unk_10097EA18;
    void v3[5] = v3;
    long long v4 = off_10098CBF0;
    uint64_t v5 = 0;
    qword_100A4CA08 = _sl_dlopen();
  }
  if (!qword_100A4CA08) {
    sub_100724234(v3);
  }
  if (v3[0]) {
    free(v3[0]);
  }
  Class result = objc_getClass("UMUserPersona");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    sub_1007242B4();
  }
  qword_100A4CA00 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t sub_100405EDC()
{
  uint64_t result = _sl_dlopen();
  qword_100A4CA08 = result;
  return result;
}

void sub_100407000(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, double a5)
{
  id v12 = a4;
  id v9 = *(void **)(a1 + 32);
  long long v10 = [*(id *)(a1 + 40) localObject];
  long long v11 = [v9 broadcasterForLocalObject:v10 messageContext:*(void *)(a1 + 40)];

  if (v11) {
    [v11 iMessageReportSpamCheckUnknownResponseForRequestID:*(void *)(a1 + 48) status:a2 abusive:a3 delay:v12 withError:a5];
  }
}

id sub_1004070B8(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
LABEL_13:
    id v5 = 0;
    goto LABEL_15;
  }
  uint64_t v3 = [v1 domain];
  unsigned int v4 = [v3 isEqualToString:NSOSStatusErrorDomain];

  if (!v4)
  {
    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    id v6 = objc_msgSend(v2, "underlyingErrors", 0);
    id v7 = [v6 countByEnumeratingWithState:&v13 objects:v17 count:16];
    if (v7)
    {
      id v8 = v7;
      uint64_t v9 = *(void *)v14;
      while (2)
      {
        long long v10 = 0;
        do
        {
          if (*(void *)v14 != v9) {
            objc_enumerationMutation(v6);
          }
          uint64_t v11 = sub_1004070B8(*(void *)(*((void *)&v13 + 1) + 8 * (void)v10));
          if (v11)
          {
            id v5 = (id)v11;

            goto LABEL_15;
          }
          long long v10 = (char *)v10 + 1;
        }
        while (v8 != v10);
        id v8 = [v6 countByEnumeratingWithState:&v13 objects:v17 count:16];
        if (v8) {
          continue;
        }
        break;
      }
    }

    goto LABEL_13;
  }
  id v5 = [v2 code];
LABEL_15:

  return v5;
}

id sub_100407308(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) _repairTimerHit:a2];
}

id sub_10040764C(uint64_t a1)
{
  return [*(id *)(a1 + 32) recertifyDeviceIfNeeded];
}

id sub_100407654(uint64_t a1)
{
  return [*(id *)(a1 + 32) recertifyDeviceIfNeeded];
}

void sub_10040765C()
{
  int v0 = MAERecertifyDeviceWithError();
  id v1 = 0;
  uint64_t v2 = +[IMRGLog warning];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v3 = @"NO";
    if (v0) {
      CFStringRef v3 = @"YES";
    }
    *(_DWORD *)long long buf = 138412546;
    CFStringRef v5 = v3;
    __int16 v6 = 2112;
    id v7 = v1;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Completed device re-certification { result: %@, error: %@ }", buf, 0x16u);
  }

  im_dispatch_after_primary_queue();
}

void sub_1004077AC(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) delegate];
  [v2 deviceRecertificationCompleted:*(void *)(a1 + 32)];
}

BOOL sub_100407C48(uint64_t a1)
{
  SecCertificateNotValidAfter();
  CFAbsoluteTime v3 = v2;
  double Current = CFAbsoluteTimeGetCurrent();
  double v5 = Current + 864000.0;
  CFDateRef v6 = CFDateCreate(kCFAllocatorDefault, v3);
  CFDateRef v7 = CFDateCreate(kCFAllocatorDefault, Current);
  id v8 = +[IMRGLog warning];
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v9 = @"NO";
    int v11 = 134219266;
    uint64_t v12 = a1;
    __int16 v13 = 2048;
    if (v3 < v5) {
      CFStringRef v9 = @"YES";
    }
    CFAbsoluteTime v14 = v3;
    __int16 v15 = 2048;
    double v16 = Current;
    __int16 v17 = 2112;
    CFDateRef v18 = v6;
    __int16 v19 = 2112;
    CFDateRef v20 = v7;
    __int16 v21 = 2112;
    CFStringRef v22 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Checking if cert is near expiry { cert: %p, expireTime: %f, currentTime: %f, expirationDate: %@, currentDate: %@, isNearExpiry: %@ }", (uint8_t *)&v11, 0x3Eu);
  }

  if (v6) {
    CFRelease(v6);
  }
  if (v7) {
    CFRelease(v7);
  }
  return v3 < v5;
}

void sub_100407DBC(id a1)
{
  id v1 = +[IMRGLog warning];
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)double v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Telling apsd to invalidate the identity", v2, 2u);
  }

  [sub_100407E34() invalidateDeviceIdentity];
}

id sub_100407E34()
{
  if (qword_100A4CA28 != -1) {
    dispatch_once(&qword_100A4CA28, &stru_10098CC70);
  }
  int v0 = (void *)qword_100A4CA20;

  return v0;
}

void sub_100407F14(id a1)
{
  CFStringRef v1 = (const __CFString *)MGCopyAnswer();
  if (v1)
  {
    CFStringRef v2 = v1;
    if (CFStringHasSuffix(v1, @"DEV")) {
      BOOL v3 = 1;
    }
    else {
      BOOL v3 = CFStringHasSuffix(v2, @"dev") != 0;
    }
    byte_100A4CA10 = v3;
    CFRelease(v2);
  }
}

void sub_100407FA0(id a1)
{
  qword_100A4CA20 = IMWeakLinkClass();
}

void sub_1004085D8(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v4 = +[IMRGLog registration];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    id v34 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Executing temporary phone user transaction %@", buf, 0xCu);
  }

  id v5 = [v3 type];
  if (v5 == (id)1)
  {
    id v13 = v3;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    uint64_t v26 = a1;
    id v14 = *(id *)(a1 + 32);
    id v15 = [v14 countByEnumeratingWithState:&v28 objects:v32 count:16];
    if (v15)
    {
      id v16 = v15;
      id v25 = v3;
      long long v10 = 0;
      uint64_t v17 = *(void *)v29;
      id obj = v14;
      do
      {
        for (uint64_t i = 0; i != v16; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v29 != v17) {
            objc_enumerationMutation(obj);
          }
          __int16 v19 = *(void **)(*((void *)&v28 + 1) + 8 * i);
          CFDateRef v20 = [v19 phoneNumber];
          __int16 v21 = [v13 user];
          CFStringRef v22 = [v21 phoneNumber];
          unsigned int v23 = [v20 isEqualToString:v22];

          if (v23)
          {
            id v24 = v19;

            long long v10 = v24;
          }
        }
        id v16 = [obj countByEnumeratingWithState:&v28 objects:v32 count:16];
      }
      while (v16);

      id v3 = v25;
      if (!v10) {
        goto LABEL_22;
      }
      if ([v13 alertType] == (id)1) {
        +[IDSTemporaryPhoneAlertManager attemptPresentationOfExpirationAlertForUser:v10];
      }
      [*(id *)(v26 + 32) removeObject:v10];
    }
    else
    {
      long long v10 = v14;
    }
    goto LABEL_21;
  }
  if (!v5)
  {
    id v6 = v3;
    CFDateRef v7 = [v6 credential];

    if (!v7)
    {
LABEL_22:

      goto LABEL_23;
    }
    id v8 = *(void **)(a1 + 32);
    CFStringRef v9 = [v6 user];
    [v8 addObject:v9];

    long long v10 = [*(id *)(a1 + 40) userStore];
    int v11 = [v6 credential];
    uint64_t v12 = [v6 user];
    [v10 setCredential:v11 forUser:v12];

LABEL_21:
    goto LABEL_22;
  }
LABEL_23:
}

void sub_10040A60C(uint64_t a1)
{
  CFStringRef v2 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 32)) {
      CFStringRef v3 = @"Downstream";
    }
    else {
      CFStringRef v3 = @"Upstream";
    }
    *(_DWORD *)long long buf = 138412290;
    CFStringRef v6 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Start collecting logs due to %@ Magnet corruption", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      _IDSLogTransport();
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
  }
  if (qword_100A4CA38 != -1) {
    dispatch_once(&qword_100A4CA38, &stru_10098CCB8);
  }
  if (off_100A4CA30)
  {
    if (*(unsigned char *)(a1 + 32)) {
      CFStringRef v4 = @"Downstream data corruption";
    }
    else {
      CFStringRef v4 = @"Upstream data corruption";
    }
    off_100A4CA30(@"IDS", v4, 2, 152);
  }
}

void sub_10040A7E8(id a1)
{
  off_100A4CA30 = (uint64_t (*)(void, void, void, void))CUTWeakLinkSymbol();
}

id sub_10040AAD8(uint64_t a1)
{
  return [*(id *)(a1 + 32) _processIncomingPacket];
}

id sub_10040AAE0(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _processOutgoingPacket];
}

void sub_10040D328(id a1)
{
  mach_timebase_info info = (mach_timebase_info)0xAAAAAAAAAAAAAAAALL;
  mach_timebase_info(&info);
  LODWORD(v2) = info.denom;
  LODWORD(v1) = info.numer;
  *(double *)&qword_100A4CA48 = (double)v1 / (double)v2 / 1000000000.0;
}

void sub_10040D9A8(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_10040D9C4(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a5;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v13 = +[IDSFoundationLog delivery];
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = *(void *)(a1 + 32);
    *(_DWORD *)long long buf = 138413058;
    uint64_t v49 = v14;
    __int16 v50 = 2112;
    id v51 = WeakRetained;
    __int16 v52 = 2048;
    uint64_t v53 = a4;
    __int16 v54 = 2112;
    id v55 = v10;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "GUID %@ Finished MML %@ with result code: %ld error: %@", buf, 0x2Au);
  }

  id v15 = [WeakRetained chunkNumber];
  id v16 = [v10 description];
  long long v31 = [v11 description];
  uint64_t v17 = [v9 messageBodyUsingCache];
  id v32 = v9;
  CFDateRef v18 = [v9 service];
  __int16 v19 = IDSLoggableDescriptionForObjectOnService();

  __int16 v37 = _NSConcreteStackBlock;
  uint64_t v38 = 3221225472;
  int v39 = sub_10040DD08;
  long long v40 = &unk_100984C50;
  id v41 = *(id *)(a1 + 32);
  id v30 = v15;
  id v42 = v30;
  uint64_t v46 = a4;
  id v29 = v16;
  id v43 = v29;
  id v28 = v31;
  id v44 = v28;
  id v27 = v19;
  id v45 = v27;
  cut_dispatch_log_queue();
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  CFDateRef v20 = [WeakRetained aggregateMessages];
  id v21 = [v20 countByEnumeratingWithState:&v33 objects:v47 count:16];
  if (v21)
  {
    id v22 = v21;
    uint64_t v23 = *(void *)v34;
    do
    {
      for (uint64_t i = 0; i != v22; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v34 != v23) {
          objc_enumerationMutation(v20);
        }
        id v25 = *(void **)(*((void *)&v33 + 1) + 8 * i);
        objc_msgSend(v25, "completionBlock", v27, v28, v29, v30);
        uint64_t v26 = (void (**)(void, void, void, void, void))objc_claimAutoreleasedReturnValue();
        ((void (**)(void, void *, id, uint64_t, id))v26)[2](v26, v25, v10, a4, v11);
      }
      id v22 = [v20 countByEnumeratingWithState:&v33 objects:v47 count:16];
    }
    while (v22);
  }
}

void sub_10040DD08(void *a1)
{
  uint64_t v2 = +[IDSFoundationLog delivery_oversized];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = a1[5];
    uint64_t v5 = a1[6];
    uint64_t v6 = a1[7];
    uint64_t v8 = a1[8];
    uint64_t v7 = a1[9];
    int v9 = 138413570;
    uint64_t v10 = v3;
    __int16 v11 = 2112;
    uint64_t v12 = v4;
    __int16 v13 = 2048;
    uint64_t v14 = v7;
    __int16 v15 = 2112;
    uint64_t v16 = v5;
    __int16 v17 = 2112;
    uint64_t v18 = v6;
    __int16 v19 = 2112;
    uint64_t v20 = v8;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Full response info for GUID %@ Finished MML %@ with result code: %ld error: %@ result dictionary: %@ message body: %@", (uint8_t *)&v9, 0x3Eu);
  }
}

void sub_10040DF3C(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 72));
  _Unwind_Resume(a1);
}

void sub_10040DF58(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9 = a3;
  id v10 = a5;
  id v11 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 64));
  __int16 v13 = +[IDSFoundationLog delivery];
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = *(void *)(a1 + 32);
    __int16 v15 = [WeakRetained chunkNumber];
    *(_DWORD *)long long buf = 138413058;
    uint64_t v53 = v14;
    __int16 v54 = 2112;
    id v55 = v15;
    __int16 v56 = 2048;
    uint64_t v57 = a4;
    __int16 v58 = 2112;
    id v59 = v9;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "GUID %@ Finished Fanout %@ with result code: %ld error: %@", buf, 0x2Au);
  }
  int v47 = WeakRetained;
  uint64_t v16 = [WeakRetained chunkNumber];
  __int16 v17 = [v9 description];
  uint64_t v18 = [v10 description];
  __int16 v19 = [v11 messageBodyUsingCache];
  uint64_t v20 = [v11 service];

  id v21 = IDSLoggableDescriptionForObjectOnService();

  id v48 = *(id *)(a1 + 32);
  id v46 = v16;
  id v22 = v17;
  uint64_t v49 = v22;
  id v23 = v18;
  __int16 v50 = v23;
  id v24 = v21;
  id v51 = v24;
  cut_dispatch_log_queue();
  uint64_t v25 = 2;
  if ((a4 - 1002) < 2) {
    uint64_t v25 = 0;
  }
  if (a4 >= 2) {
    uint64_t v26 = v25;
  }
  else {
    uint64_t v26 = 0;
  }
  if (v9)
  {
    id v27 = +[NSDictionary dictionaryWithObjectsAndKeys:](NSDictionary, "dictionaryWithObjectsAndKeys:", v9, NSUnderlyingErrorKey, 0);
    id v28 = +[NSError errorWithDomain:IDSSendErrorDomain code:v26 userInfo:v27];
  }
  else
  {
    id v28 = 0;
  }
  id v29 = [objc_alloc((Class)IDSDeliveryContext) initWithResponseCode:v26 error:v28 lastCall:1];
  [v29 setDisplayURIs:*(void *)(a1 + 40)];
  id v30 = [v10 _numberForKey:@"e"];

  if (v30)
  {
    long long v31 = [v10 _numberForKey:@"e"];
    [v29 setResponseTimeStamp:v31];
  }
  if ([v29 idsResponseCode])
  {
    id v32 = [*(id *)(a1 + 48) delegate];
    [v32 receivedErrorWithContext:v29];
  }
  if (!*(unsigned char *)(a1 + 72) || v28) {
    [v47 callAllIndividualCompletionBlocksWithDeliveryContext:v29];
  }
  if (a4 == 7000)
  {
    long long v33 = [v10 _numberForKey:@"ttr"];

    if (v33)
    {
      long long v34 = [*(id *)(a1 + 48) delegate];
      long long v35 = [v47 topic];
      [v10 _numberForKey:@"ttr"];
      id v45 = v28;
      id v36 = v10;
      id v37 = v9;
      id v38 = v24;
      id v39 = v23;
      v41 = id v40 = v22;
      [v34 receivedRateLimitingResponseForTopic:v35 ttr:v41];

      id v22 = v40;
      id v23 = v39;
      id v24 = v38;
      id v9 = v37;
      id v10 = v36;
      id v28 = v45;
    }
  }
  id v42 = [*(id *)(a1 + 56) count];
  id v43 = +[IMMobileNetworkManager sharedInstance];
  id v44 = v43;
  if (v42) {
    [v43 addFastDormancyDisableToken:@"IDSDeliveryManager"];
  }
  else {
    [v43 removeFastDormancyDisableToken:@"IDSDeliveryManager"];
  }
}

void sub_10040E3F8(void *a1)
{
  uint64_t v2 = +[IDSFoundationLog delivery_oversized];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = a1[5];
    uint64_t v5 = a1[6];
    uint64_t v6 = a1[7];
    uint64_t v8 = a1[8];
    uint64_t v7 = a1[9];
    int v9 = 138413570;
    uint64_t v10 = v3;
    __int16 v11 = 2112;
    uint64_t v12 = v4;
    __int16 v13 = 2048;
    uint64_t v14 = v7;
    __int16 v15 = 2112;
    uint64_t v16 = v5;
    __int16 v17 = 2112;
    uint64_t v18 = v6;
    __int16 v19 = 2112;
    uint64_t v20 = v8;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Full response info for GUID %@ Finished Fanout %@ with result code: %ld error: %@ result dictionary: %@ message body: %@", (uint8_t *)&v9, 0x3Eu);
  }
}

void sub_10040E6BC(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = +[IDSFoundationLog delivery];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = *(void *)(a1 + 40);
    if ([v3 responseCode]) {
      CFStringRef v7 = @"NO";
    }
    else {
      CFStringRef v7 = @"YES";
    }
    id v8 = [v3 responseCode];
    int v9 = [v3 responseError];
    int v23 = 138413314;
    uint64_t v24 = v5;
    __int16 v25 = 2112;
    uint64_t v26 = v6;
    __int16 v27 = 2112;
    CFStringRef v28 = v7;
    __int16 v29 = 2048;
    id v30 = v8;
    __int16 v31 = 2112;
    id v32 = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "GUID %@ Finished sending to destination %@ { success: %@, code: %ld, error: %@ }", (uint8_t *)&v23, 0x34u);
  }
  if ([v3 responseCode])
  {
    uint64_t v10 = [*(id *)(a1 + 48) delegate];
    [v10 receivedErrorWithContext:v3];
  }
  __int16 v11 = [v3 responseTimeStamp];

  if (v11)
  {
    uint64_t v12 = *(void **)(*(void *)(a1 + 48) + 8);
    if (!v12
      || ([v12 doubleValue],
          double v14 = v13,
          [v3 responseTimeStamp],
          __int16 v15 = objc_claimAutoreleasedReturnValue(),
          [v15 doubleValue],
          double v17 = v16,
          v15,
          v14 > v17))
    {
      uint64_t v18 = [v3 responseTimeStamp];
      uint64_t v19 = *(void *)(a1 + 48);
      uint64_t v20 = *(void **)(v19 + 8);
      *(void *)(v19 + _Block_object_dispose(&STACK[0x320], 8) = v18;
    }
  }
  [*(id *)(a1 + 56) removeObject:*(void *)(a1 + 64)];
  if (![*(id *)(a1 + 56) count])
  {
    [v3 setResponseTimeStamp:*(void *)(*(void *)(a1 + 48) + 8)];
    id v21 = [*(id *)(a1 + 48) delegate];
    [v21 finishedTrackingMadridAcksWithContext:v3 uris:*(void *)(a1 + 72) guid:*(void *)(a1 + 32)];
  }
  uint64_t v22 = *(void *)(a1 + 80);
  if (v22) {
    (*(void (**)(uint64_t, id))(v22 + 16))(v22, v3);
  }
}

void sub_100410884(id a1)
{
  unint64_t v1 = objc_alloc_init(IDSKeyTransparencyVerifier);
  uint64_t v2 = qword_100A4CA58;
  qword_100A4CA58 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_100410F04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,id location)
{
  objc_destroyWeak(v25);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t sub_100410F28(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    id v3 = +[IMRGLog sysdiagnose_keyTransparency];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v4 = [WeakRetained isOptedInForServiceIdentifier:@"com.apple.madrid"];
      CFStringRef v5 = @"NO";
      if (v4) {
        CFStringRef v5 = @"YES";
      }
      int v7 = 138412290;
      CFStringRef v8 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "KT Opt In Status: %@", (uint8_t *)&v7, 0xCu);
    }

    [WeakRetained fetchCurrentDeviceKVSKey:&stru_10098CD90];
    [*(id *)(a1 + 32) getCurrentRegistrationStateWithCompletion:&stru_10098CDB0];
  }

  return 0;
}

void sub_10041103C(id a1, NSDictionary *a2, NSError *a3)
{
  id v3 = a2;
  unsigned int v4 = +[IMRGLog sysdiagnose_keyTransparency];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v5 = [(NSDictionary *)v3 allKeys];
    int v6 = 138412290;
    int v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "This device's KVS keys: {kvsKeys: %@}", (uint8_t *)&v6, 0xCu);
  }
}

void sub_10041110C(id a1, NSArray *a2)
{
  uint64_t v2 = a2;
  id v3 = (id *)IMRGLog_ptr;
  unsigned int v4 = +[IMRGLog sysdiagnose_keyTransparency];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    NSUInteger v26 = [(NSArray *)v2 count];
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Found %lu registrations on KT services", buf, 0xCu);
  }

  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  id obj = v2;
  id v5 = [(NSArray *)obj countByEnumeratingWithState:&v21 objects:v35 count:16];
  if (v5)
  {
    id v7 = v5;
    uint64_t v8 = *(void *)v22;
    *(void *)&long long v6 = 138413314;
    long long v18 = v6;
    uint64_t v19 = *(void *)v22;
    do
    {
      int v9 = 0;
      do
      {
        if (*(void *)v22 != v8) {
          objc_enumerationMutation(obj);
        }
        uint64_t v10 = *(void **)(*((void *)&v21 + 1) + 8 * (void)v9);
        __int16 v11 = objc_msgSend(*v3, "sysdiagnose_keyTransparency", v18);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v12 = [v10 userID];
          [v10 status];
          double v13 = _IDSStringFromIDSRegistrationStatus();
          id v14 = [v10 optedIn];
          if ([v10 containsAccountKey]) {
            CFStringRef v15 = @"YES";
          }
          else {
            CFStringRef v15 = @"NO";
          }
          unsigned int v16 = [v10 containsDeviceSignature];
          *(_DWORD *)long long buf = v18;
          if (v16) {
            CFStringRef v17 = @"YES";
          }
          else {
            CFStringRef v17 = @"NO";
          }
          NSUInteger v26 = (NSUInteger)v12;
          __int16 v27 = 2112;
          CFStringRef v28 = v13;
          __int16 v29 = 2048;
          id v30 = v14;
          __int16 v31 = 2112;
          CFStringRef v32 = v15;
          __int16 v33 = 2112;
          CFStringRef v34 = v17;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "    Registration user ID: %@, Registration status: %@, KTOptInStatus(at time of registration, may be out of date): %lu, containsAccountKey:%@, containsDeviceSignature: %@", buf, 0x34u);

          id v3 = (id *)IMRGLog_ptr;
          uint64_t v8 = v19;
        }
        int v9 = (char *)v9 + 1;
      }
      while (v7 != v9);
      id v7 = [(NSArray *)obj countByEnumeratingWithState:&v21 objects:v35 count:16];
    }
    while (v7);
  }
}

uint64_t sub_1004116D0(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = v4;
  if (*(void *)(a1 + 40))
  {
    id v8 = v4;
    if (v4)
    {
      long long v6 = [*(id *)(a1 + 32) _clientErrorWithCode:-1100 debugDescription:@"Failed to determine eligibility for the key transparency trust circle" underlyingError:v4];
    }
    else
    {
      long long v6 = 0;
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();

    id v5 = v8;
  }

  return _objc_release_x1(v4, v5);
}

void sub_100411878(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  if (a2)
  {
    long long v6 = [*(id *)(a1 + 32) registrationDataSource];
    id v7 = [v6 currentLocalKeyTransparencyEligibleServiceIdentifiers];
  }
  else
  {
    id v7 = &__NSArray0__struct;
  }
  id v8 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = 138412546;
    __int16 v11 = v7;
    __int16 v12 = 2112;
    id v13 = v5;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Done fetching local device trust circle eligible service identifiers { eligibleServices: %@, error: %@ }", (uint8_t *)&v10, 0x16u);
  }

  uint64_t v9 = *(void *)(a1 + 40);
  if (v9) {
    (*(void (**)(uint64_t, void *, id))(v9 + 16))(v9, v7, v5);
  }
}

void sub_100412160(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = +[IDSFoundationLog KeyTransparency];
  id v8 = v7;
  if (v6)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      sub_100724790();
    }

    uint64_t v9 = *(void *)(a1 + 56);
    int v10 = [*(id *)(a1 + 32) _clientErrorWithCode:-9004 debugDescription:@"Failed to get query results." underlyingError:v6];
    (*(void (**)(uint64_t, void *, void *))(v9 + 16))(v9, &__NSArray0__struct, v10);
  }
  else
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = *(void *)(a1 + 40);
      uint64_t v12 = *(void *)(a1 + 48);
      CFStringRef v13 = @"YES";
      if (!*(unsigned char *)(a1 + 64)) {
        CFStringRef v13 = @"NO";
      }
      *(_DWORD *)long long buf = 138412802;
      uint64_t v21 = v11;
      __int16 v22 = 2112;
      uint64_t v23 = v12;
      __int16 v24 = 2112;
      CFStringRef v25 = v13;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Calling into Transparency to validate peers { uris: %@ service: %@ fetchNow: %@ }", buf, 0x20u);
    }

    uint64_t v14 = +[NSDate now];
    uint64_t v15 = *(void *)(a1 + 32);
    unsigned int v16 = *(void **)(v15 + 120);
    *(void *)(v15 + 120) = v14;

    int v10 = [*(id *)(a1 + 32) _keyTransparencyVerifierForServiceIdentifier:*(void *)(a1 + 48)];
    uint64_t v17 = *(unsigned __int8 *)(a1 + 64);
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 3221225472;
    v18[2] = sub_10041237C;
    v18[3] = &unk_100982A88;
    id v19 = *(id *)(a1 + 56);
    [v10 validatePeers:v5 fetchNow:v17 completionBlock:v18];
  }
}

uint64_t sub_10041237C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100412660(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

BOOL sub_10041299C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = *(void **)(a1 + 32);
  id v5 = [v3 serviceIdentifier];
  if ([v4 containsObject:v5])
  {
    BOOL v6 = 1;
  }
  else if ([v3 keyIndex])
  {
    BOOL v6 = (int)[v3 keyIndex] < 4;
  }
  else
  {
    BOOL v6 = 0;
  }

  return v6;
}

void sub_100413078(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 138412290;
    id v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Done nuking KT verification state { error: %@ }", (uint8_t *)&v7, 0xCu);
  }

  uint64_t v5 = *(void *)(a1 + 40);
  if (v5)
  {
    if (v3)
    {
      BOOL v6 = [*(id *)(a1 + 32) _clientErrorWithCode:-6000 debugDescription:@"Failed to nuke key transparency state" underlyingError:v3];
      uint64_t v5 = *(void *)(a1 + 40);
    }
    else
    {
      BOOL v6 = 0;
    }
    (*(void (**)(uint64_t, void *))(v5 + 16))(v5, v6);
  }
}

void sub_1004135CC(uint64_t a1, void *a2)
{
  id v2 = a2;
  id v3 = objc_alloc_init((Class)IDSKTVerificationResult);
  id v4 = [v2 uri];
  [v3 setUri:v4];

  objc_msgSend(v3, "setOptedIn:", objc_msgSend(v2, "optedIn"));
  id v5 = objc_alloc_init((Class)NSMutableArray);
  id v6 = objc_alloc_init((Class)NSMutableArray);
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  int v7 = [v2 loggableDatas];
  id v8 = [v7 countByEnumeratingWithState:&v17 objects:v21 count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v18;
    do
    {
      for (uint64_t i = 0; i != v9; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v18 != v10) {
          objc_enumerationMutation(v7);
        }
        uint64_t v12 = *(void **)(*((void *)&v17 + 1) + 8 * i);
        id v13 = [v12 result];
        uint64_t v14 = [v12 deviceID];
        if (v13 == (id)1) {
          uint64_t v15 = v5;
        }
        else {
          uint64_t v15 = v6;
        }
        [v15 addObject:v14];
      }
      id v9 = [v7 countByEnumeratingWithState:&v17 objects:v21 count:16];
    }
    while (v9);
  }

  [v3 setVerifiedPushTokens:v5];
  [v3 setUnverifiedPushTokens:v6];
  os_unfair_lock_lock(&stru_100A4CA60);
  if (v3) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), *(const void **)(a1 + 40), v3);
  }
  os_unfair_lock_unlock(&stru_100A4CA60);
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
}

uint64_t sub_1004137C0(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

id sub_100413B9C(id a1, KTLoggableData *a2)
{
  return [(KTLoggableData *)a2 deviceID];
}

void sub_100413EDC(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  int v7 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = a1[4];
    unint64_t v9 = (unint64_t)[v5 succeed];
    if (v9 > 3) {
      CFStringRef v10 = @"Unrecognized";
    }
    else {
      CFStringRef v10 = off_10098D250[v9];
    }
    uint64_t v11 = a1[5];
    unsigned int v12 = [v5 optedIn];
    int v19 = 138413314;
    CFStringRef v13 = @"NO";
    uint64_t v20 = v8;
    __int16 v21 = 2112;
    if (v12) {
      CFStringRef v13 = @"YES";
    }
    CFStringRef v22 = v10;
    __int16 v23 = 2112;
    id v24 = v6;
    __int16 v25 = 2112;
    uint64_t v26 = v11;
    __int16 v27 = 2112;
    CFStringRef v28 = v13;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Finished KT validate peer result { KTURI: %@, result: %@, error: %@, ticket: %@, optedIn: %@ }", (uint8_t *)&v19, 0x34u);
  }

  uint64_t v14 = (void *)a1[6];
  uint64_t v15 = a1[7];
  uint64_t v16 = a1[8];
  id v17 = [v5 succeed];
  long long v18 = [v5 loggableDatas];
  objc_msgSend(v14, "_fulfillOrFailPromiseSeal:basedOnIndex:KTResult:ktLoggableDatas:optedIn:error:", v15, v16, v17, v18, objc_msgSend(v5, "optedIn"), v6);
}

void sub_10041438C(uint64_t a1, uint64_t a2, unint64_t a3, int a4, uint64_t a5, void *a6)
{
  id v9 = a6;
  CFStringRef v10 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = *(void *)(a1 + 32);
    if (a3 > 3) {
      CFStringRef v12 = @"Unrecognized";
    }
    else {
      CFStringRef v12 = off_10098D250[a3];
    }
    CFStringRef v13 = @"NO";
    uint64_t v14 = *(void *)(a1 + 40);
    int v17 = 138413314;
    if (a4) {
      CFStringRef v13 = @"YES";
    }
    uint64_t v18 = v11;
    __int16 v19 = 2112;
    CFStringRef v20 = v12;
    __int16 v21 = 2112;
    id v22 = v9;
    __int16 v23 = 2112;
    uint64_t v24 = v14;
    __int16 v25 = 2112;
    CFStringRef v26 = v13;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Finished KT force validate { KTURI: %@, result: %@, error: %@, ticket: %@, optedIn: %@", (uint8_t *)&v17, 0x34u);
  }

  uint64_t v15 = *(void *)(a1 + 56);
  if (v15)
  {
    uint64_t v16 = [*(id *)(a1 + 48) _clientErrorForKTResult:a3 underlyingError:v9];
    (*(void (**)(uint64_t, void *))(v15 + 16))(v15, v16);
  }
}

void sub_100414B98(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, void *a5, void *a6)
{
  id v10 = a6;
  id v11 = a5;
  CFStringRef v12 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = *(void *)(a1 + 32);
    if (a3 > 3) {
      CFStringRef v14 = @"Unrecognized";
    }
    else {
      CFStringRef v14 = off_10098D250[a3];
    }
    CFStringRef v15 = @"NO";
    uint64_t v16 = *(void *)(a1 + 40);
    int v17 = 138413314;
    if (a4) {
      CFStringRef v15 = @"YES";
    }
    uint64_t v18 = v13;
    __int16 v19 = 2112;
    CFStringRef v20 = v14;
    __int16 v21 = 2112;
    id v22 = v10;
    __int16 v23 = 2112;
    uint64_t v24 = v16;
    __int16 v25 = 2112;
    CFStringRef v26 = v15;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Finished KT validate enrollment result { KTURI: %@, result: %@, error: %@, ticket: %@, optedIn: %@ }", (uint8_t *)&v17, 0x34u);
  }

  [*(id *)(a1 + 48) _fulfillOrFailPromiseSeal:*(void *)(a1 + 56) basedOnIndex:*(void *)(a1 + 64) KTResult:a3 ktLoggableDatas:v11 optedIn:a4 error:v10];
}

id sub_1004157AC(id a1, NSString *a2)
{
  id v2 = a2;
  if ([(NSString *)v2 isEqualToString:kFZServiceDefaultsSentinelAlias]
    && [(NSString *)v2 isEqualToString:kIDSServiceDefaultsSentinelSelfAlias])
  {
    id v3 = 0;
  }
  else
  {
    id v3 = +[IDSURI URIWithPrefixedURI:v2];
  }

  return v3;
}

uint64_t sub_100415834(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100415B64(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v5 && ([v5 containsObject:*(void *)(a1 + 32)] & 1) != 0)
  {
    int v7 = [*(id *)(a1 + 40) accountController];
    uint64_t v8 = [*(id *)(a1 + 40) serviceController];
    id v9 = [v8 serviceWithIdentifier:*(void *)(a1 + 32)];
    id v10 = [v7 appleIDAccountOnService:v9];

    id v11 = [*(id *)(a1 + 48) BOOLValue];
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 3221225472;
    v18[2] = sub_100415D54;
    v18[3] = &unk_10098CF50;
    int8x16_t v17 = *(int8x16_t *)(a1 + 32);
    id v12 = (id)v17.i64[0];
    int8x16_t v19 = vextq_s8(v17, v17, 8uLL);
    id v20 = *(id *)(a1 + 56);
    [v10 updateKTOptInStatus:v11 withCompletion:v18];
  }
  else
  {
    uint64_t v13 = +[IDSFoundationLog KeyTransparency];
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      sub_100724F28();
    }

    uint64_t v14 = *(void *)(a1 + 56);
    id v15 = objc_alloc((Class)IDSKTOptInResult);
    id v10 = [*(id *)(a1 + 40) _clientErrorWithCode:-8000 debugDescription:0 underlyingError:v6];
    id v16 = [v15 initWithSuccess:0 serverProvidedSMT:0 error:v10];
    (*(void (**)(uint64_t, id))(v14 + 16))(v14, v16);
  }
}

void sub_100415D54(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if ([v3 success]) {
      CFStringRef v5 = @"YES";
    }
    else {
      CFStringRef v5 = @"NO";
    }
    id v6 = [v3 error];
    *(_DWORD *)long long buf = 138412546;
    CFStringRef v16 = v5;
    __int16 v17 = 2112;
    uint64_t v18 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Received KT opt-in result from server {success: %@, error: %@}", buf, 0x16u);
  }
  if (_os_feature_enabled_impl())
  {
    if ([v3 success])
    {
      id v10 = [v3 error];

      if (!v10)
      {
        id v11 = im_primary_base_queue();
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 3221225472;
        v13[2] = sub_100415F24;
        v13[3] = &unk_10097E440;
        id v12 = (void *)a1[5];
        v13[4] = a1[4];
        id v14 = v12;
        dispatch_async(v11, v13);
      }
    }
  }
  (*(void (**)(void, id, uint64_t, uint64_t, uint64_t))(a1[6] + 16))(a1[6], v3, v7, v8, v9);
}

id sub_100415F24(uint64_t a1)
{
  return [*(id *)(a1 + 32) clearCacheAndUpdatePeersForService:*(void *)(a1 + 40)];
}

void sub_100416528(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v5 && ([v5 containsObject:*(void *)(a1 + 32)] & 1) != 0)
  {
    uint64_t v7 = [*(id *)(a1 + 40) accountController];
    uint64_t v8 = [*(id *)(a1 + 40) serviceController];
    uint64_t v9 = [v8 serviceWithIdentifier:*(void *)(a1 + 32)];
    id v10 = [v7 appleIDAccountOnService:v9];

    uint64_t v11 = *(void *)(a1 + 48);
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 3221225472;
    v18[2] = sub_100416714;
    v18[3] = &unk_10098CF50;
    int8x16_t v17 = *(int8x16_t *)(a1 + 32);
    id v12 = (id)v17.i64[0];
    int8x16_t v19 = vextq_s8(v17, v17, 8uLL);
    id v20 = *(id *)(a1 + 56);
    [v10 updateKTOptInStatusWithRequest:v11 withCompletion:v18];
  }
  else
  {
    uint64_t v13 = +[IDSFoundationLog KeyTransparency];
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      sub_100724F28();
    }

    uint64_t v14 = *(void *)(a1 + 56);
    id v15 = objc_alloc((Class)IDSKTOptInResult);
    id v10 = [*(id *)(a1 + 40) _clientErrorWithCode:-8000 debugDescription:0 underlyingError:v6];
    id v16 = [v15 initWithSuccess:0 optedInOutURIs:0 serverSMTByURI:0 error:v10];
    (*(void (**)(uint64_t, id))(v14 + 16))(v14, v16);
  }
}

void sub_100416714(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if ([v3 success]) {
      CFStringRef v5 = @"YES";
    }
    else {
      CFStringRef v5 = @"NO";
    }
    id v6 = [v3 error];
    *(_DWORD *)long long buf = 138412546;
    CFStringRef v16 = v5;
    __int16 v17 = 2112;
    uint64_t v18 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Received KT opt in result from server {success: %@, error: %@}", buf, 0x16u);
  }
  if (_os_feature_enabled_impl())
  {
    if ([v3 success])
    {
      id v10 = [v3 error];

      if (!v10)
      {
        uint64_t v11 = im_primary_base_queue();
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 3221225472;
        v13[2] = sub_1004168E4;
        v13[3] = &unk_10097E440;
        id v12 = (void *)a1[5];
        v13[4] = a1[4];
        id v14 = v12;
        dispatch_async(v11, v13);
      }
    }
  }
  (*(void (**)(void, id, uint64_t, uint64_t, uint64_t))(a1[6] + 16))(a1[6], v3, v7, v8, v9);
}

id sub_1004168E4(uint64_t a1)
{
  return [*(id *)(a1 + 32) clearCacheAndUpdatePeersForService:*(void *)(a1 + 40)];
}

void sub_1004168F0(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if ([v3 success]) {
      CFStringRef v5 = @"YES";
    }
    else {
      CFStringRef v5 = @"NO";
    }
    id v6 = [v3 error];
    *(_DWORD *)long long buf = 138412546;
    CFStringRef v16 = v5;
    __int16 v17 = 2112;
    uint64_t v18 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Received KT opt out result from server {success: %@, error: %@}", buf, 0x16u);
  }
  if (_os_feature_enabled_impl())
  {
    if ([v3 success])
    {
      id v10 = [v3 error];

      if (!v10)
      {
        uint64_t v11 = im_primary_base_queue();
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 3221225472;
        v13[2] = sub_100416AC0;
        v13[3] = &unk_10097E440;
        id v12 = (void *)a1[5];
        v13[4] = a1[4];
        id v14 = v12;
        dispatch_async(v11, v13);
      }
    }
  }
  (*(void (**)(void, id, uint64_t, uint64_t, uint64_t))(a1[6] + 16))(a1[6], v3, v7, v8, v9);
}

id sub_100416AC0(uint64_t a1)
{
  return [*(id *)(a1 + 32) clearCacheAndUpdatePeersForService:*(void *)(a1 + 40)];
}

void sub_100417038(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(a1 + 32);
    id v9 = [v5 state];
    id v10 = [v5 smtTimestamp];
    int v14 = 138413058;
    uint64_t v15 = v8;
    __int16 v16 = 2048;
    id v17 = v9;
    __int16 v18 = 2112;
    int8x16_t v19 = v10;
    __int16 v20 = 2112;
    id v21 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Fetched opt in state for KT application %@ { state: %ld smtTimestamp: %@ getError: %@", (uint8_t *)&v14, 0x2Au);
  }
  uint64_t v11 = [IDSKTOptInState alloc];
  id v12 = [v5 smtTimestamp];
  uint64_t v13 = -[IDSKTOptInState initWithTimeStamp:status:error:](v11, "initWithTimeStamp:status:error:", v12, [v5 state], v6);

  os_unfair_lock_lock(&stru_100A4CA64);
  if (v13) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), *(const void **)(a1 + 32), v13);
  }
  os_unfair_lock_unlock(&stru_100A4CA64);
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
}

uint64_t sub_1004171D4(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

id sub_100417690(id a1, NSString *a2)
{
  id v2 = a2;
  if ([(NSString *)v2 isEqualToString:kIDSServiceDefaultsSentinelSelfAlias]) {
    id v3 = 0;
  }
  else {
    id v3 = [objc_alloc((Class)IDSURI) initWithPrefixedURI:v2];
  }

  return v3;
}

void sub_100417E9C(uint64_t a1, void *a2, void *a3, void *a4, void *a5, char a6, void *a7, uint64_t a8, void *a9)
{
  id v39 = a2;
  id v38 = a3;
  id v37 = a4;
  id v40 = a5;
  id v14 = a7;
  id v34 = a9;
  if ((a6 & 1) == 0)
  {
    uint64_t v15 = +[IDSFoundationLog KeyTransparency];
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      sub_1007250A8();
    }
  }
  id v36 = v14;
  __int16 v16 = objc_msgSend(*(id *)(a1 + 32), "peerIDManager", v34);
  id v45 = [v16 endpointsForURIs:*(void *)(a1 + 40) service:v40 fromURI:*(void *)(a1 + 48)];

  id v17 = v40;
  id v42 = objc_alloc_init((Class)NSMutableDictionary);
  long long v47 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  id obj = *(id *)(a1 + 40);
  id v46 = [obj countByEnumeratingWithState:&v47 objects:v51 count:16];
  if (v46)
  {
    uint64_t v44 = *(void *)v48;
    do
    {
      for (uint64_t i = 0; i != v46; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v48 != v44) {
          objc_enumerationMutation(obj);
        }
        int8x16_t v19 = *(void **)(*((void *)&v47 + 1) + 8 * i);
        __int16 v20 = [v45 objectForKey:v19];
        if ([v20 count])
        {
          id v21 = objc_msgSend(v20, "__imArrayByApplyingBlock:", &stru_10098CFE0);
          id v22 = [*(id *)(a1 + 32) _KTDatasForIDSKeyTransparencyEntries:v21];
          __int16 v23 = [*(id *)(a1 + 32) peerIDManager];
          uint64_t v24 = [v23 keyTransparencyContextForService:v17 fromURI:*(void *)(a1 + 48) toURI:v19];

          id v25 = objc_alloc((Class)KTVerificationInfo);
          CFStringRef v26 = [v24 accountKey];
          id v27 = [v25 initWithAccountKey:v26 serverLoggableDatas:v22];

          objc_msgSend(v27, "setOptedIn:", objc_msgSend(v24, "ktOptIn"));
          CFStringRef v28 = [v24 queryResponseTime];

          if (v28)
          {
            __int16 v29 = [v24 queryResponseTime];
            [v27 setIdsResponseTime:v29];
          }
          id v30 = +[IDSKeyTransparencyVerifier keyTransparencyURIPrefixForServiceIdentifier:v17];
          __int16 v31 = [v19 prefixedURI];
          if (v30)
          {
            CFStringRef v32 = [v19 prefixedURI];
            uint64_t v33 = [v30 stringByAppendingString:v32];

            __int16 v31 = (void *)v33;
            id v17 = v40;
          }
          [v42 setObject:v27 forKeyedSubscript:v31];
        }
      }
      id v46 = [obj countByEnumeratingWithState:&v47 objects:v51 count:16];
    }
    while (v46);
  }

  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
}

id sub_10041824C(id a1, IDSEndpoint *a2)
{
  id v2 = a2;
  id v3 = [(IDSEndpoint *)v2 pushToken];

  if (v3)
  {
    id v4 = [IDSKeyTransparencyEntry alloc];
    id v5 = [(IDSEndpoint *)v2 pushToken];
    id v6 = [(IDSEndpoint *)v2 KTLoggableData];
    uint64_t v7 = [(IDSEndpoint *)v2 KTDeviceSignature];
    id v3 = [(IDSKeyTransparencyEntry *)v4 initWithPushToken:v5 loggableData:v6 signedData:v7];

    [(IDSKeyTransparencyEntry *)v3 setKtCapable:[(IDSEndpoint *)v2 ktCapableFlag]];
  }

  return v3;
}

id sub_1004188E0(id a1, NSString *a2)
{
  id v2 = a2;
  if ([(NSString *)v2 isEqualToString:kFZServiceDefaultsSentinelAlias]
    && [(NSString *)v2 isEqualToString:kIDSServiceDefaultsSentinelSelfAlias])
  {
    id v3 = 0;
  }
  else
  {
    id v3 = +[IDSURI URIWithPrefixedURI:v2];
  }

  return v3;
}

void sub_100418968(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = +[IDSFoundationLog KeyTransparency];
  uint64_t v8 = v7;
  if (v6)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      sub_100725178();
    }

    uint64_t v9 = *(void *)(a1 + 64);
    id v10 = [objc_alloc((Class)KTSelfVerificationInfo) initWithSyncedLoggableDatas:&__NSArray0__struct uriToServerLoggableDatas:&__NSDictionary0__struct];
    uint64_t v11 = [*(id *)(a1 + 32) _clientErrorWithCode:-9004 debugDescription:@"Failed to get query results." underlyingError:v6];
    (*(void (**)(uint64_t, id, void *))(v9 + 16))(v9, v10, v11);
  }
  else
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Force syncing KVS for self verification.", buf, 2u);
    }

    id v10 = [*(id *)(a1 + 32) forceSyncKVS];
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 3221225472;
    v13[2] = sub_100418B5C;
    v13[3] = &unk_10098D068;
    id v12 = *(void **)(a1 + 40);
    v13[4] = *(void *)(a1 + 32);
    id v14 = v12;
    id v15 = *(id *)(a1 + 48);
    id v16 = v5;
    id v17 = *(id *)(a1 + 56);
    id v18 = *(id *)(a1 + 64);
    [v10 registerResultBlock:v13];
  }
}

void sub_100418B5C(uint64_t a1, void *a2)
{
  id v3 = [a2 state];
  id v4 = +[IDSFoundationLog KeyTransparency];
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (!v5) {
      goto LABEL_7;
    }
    *(_WORD *)long long buf = 0;
    id v6 = "Failed to sync KVS.";
  }
  else
  {
    if (!v5) {
      goto LABEL_7;
    }
    *(_WORD *)long long buf = 0;
    id v6 = "Successfully synced KVS.";
  }
  _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v6, buf, 2u);
LABEL_7:

  uint64_t v57 = [*(id *)(a1 + 32) fetchTrustedDevicesFromKVS];
  uint64_t v7 = objc_msgSend(*(id *)(a1 + 32), "_KTDatasForIDSProtoKeyTransparencyTrustedDevices:serviceIdentifier:");
  uint64_t v8 = [*(id *)(a1 + 32) peerIDManager];
  uint64_t v9 = [v8 keyTransparencyContextForService:*(void *)(a1 + 40) fromURI:*(void *)(a1 + 48) toURI:*(void *)(a1 + 48)];

  id v10 = [IDSKeyTransparencyIndex alloc];
  uint64_t v11 = *(void *)(a1 + 40);
  id v55 = v9;
  id v12 = [v9 accountKey];
  uint64_t v13 = [(IDSKeyTransparencyIndex *)v10 initWithServiceIdentifier:v11 accountKey:v12 URI:*(void *)(a1 + 48)];

  id v63 = objc_alloc_init((Class)NSMutableSet);
  long long v75 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v78 = 0u;
  id v14 = *(id *)(a1 + 56);
  id v15 = [v14 countByEnumeratingWithState:&v75 objects:v85 count:16];
  if (v15)
  {
    id v16 = v15;
    uint64_t v17 = *(void *)v76;
    do
    {
      for (uint64_t i = 0; i != v16; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v76 != v17) {
          objc_enumerationMutation(v14);
        }
        int8x16_t v19 = [*(id *)(a1 + 56) objectForKeyedSubscript:*(void *)(*((void *)&v75 + 1) + 8 * i)];
        __int16 v20 = [v19 serverLoggableDatas];
        [v63 addObjectsFromArray:v20];
      }
      id v16 = [v14 countByEnumeratingWithState:&v75 objects:v85 count:16];
    }
    while (v16);
  }

  id v21 = [v63 allObjects];
  __int16 v54 = v13;
  [*(id *)(a1 + 32) _mutateSuccessfulSyncIndicatorOnKTLoggableDatas:v7 forIndex:v13];
  id v22 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v23 = objc_msgSend(v21, "__imArrayByApplyingBlock:", &stru_10098D020);
    uint64_t v24 = objc_msgSend(v7, "__imArrayByApplyingBlock:", &stru_10098D040);
    *(_DWORD *)long long buf = 138412546;
    __int16 v82 = v23;
    __int16 v83 = 2112;
    id v84 = v24;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Calling in to note KT synced datas on existing UUID for self-validation { serverKTDataPushTokens: %@, syncedKTDataPushTokens: %@ }", buf, 0x16u);
  }
  uint64_t v53 = v21;
  __int16 v56 = v7;

  uint64_t v58 = a1;
  id v25 = [*(id *)(a1 + 64) dependentRegistrationsIncludingCurrentDevice];
  id v66 = objc_alloc_init((Class)NSMutableDictionary);
  id v65 = objc_alloc_init((Class)NSMutableDictionary);
  id v64 = objc_alloc_init((Class)NSMutableDictionary);
  long long v71 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  id obj = v25;
  id v26 = [obj countByEnumeratingWithState:&v71 objects:v80 count:16];
  if (v26)
  {
    id v27 = v26;
    uint64_t v62 = *(void *)v72;
    uint64_t v61 = IDSDevicePropertyPushToken;
    uint64_t v60 = IDSDevicePropertyPrivateDeviceData;
    uint64_t v28 = IDSPrivateDeviceDataProductBuildVersion;
    uint64_t v29 = IDSPrivateDeviceDataProductName;
    uint64_t v30 = IDSPrivateDeviceDataTransparencyVersion;
    do
    {
      for (j = 0; j != v27; j = (char *)j + 1)
      {
        if (*(void *)v72 != v62) {
          objc_enumerationMutation(obj);
        }
        CFStringRef v32 = *(void **)(*((void *)&v71 + 1) + 8 * (void)j);
        uint64_t v33 = objc_msgSend(v32, "objectForKey:", v61, v53);
        id v34 = [v32 objectForKey:v60];
        long long v35 = [v34 objectForKey:v28];
        id v36 = [v34 objectForKey:v29];
        id v37 = [v34 objectForKey:v30];
        [v66 setObject:v35 forKeyedSubscript:v33];
        [v65 setObject:v36 forKeyedSubscript:v33];
        [v64 setObject:v37 forKeyedSubscript:v33];
      }
      id v27 = [obj countByEnumeratingWithState:&v71 objects:v80 count:16];
    }
    while (v27);
  }

  long long v69 = 0u;
  long long v70 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  id v38 = v53;
  id v39 = [v38 countByEnumeratingWithState:&v67 objects:v79 count:16];
  if (v39)
  {
    id v40 = v39;
    uint64_t v41 = *(void *)v68;
    do
    {
      for (k = 0; k != v40; k = (char *)k + 1)
      {
        if (*(void *)v68 != v41) {
          objc_enumerationMutation(v38);
        }
        id v43 = *(void **)(*((void *)&v67 + 1) + 8 * (void)k);
        uint64_t v44 = objc_msgSend(v43, "deviceID", v53);
        id v45 = [v66 objectForKeyedSubscript:v44];
        [v43 setBuild:v45];

        id v46 = [v43 deviceID];
        long long v47 = [v65 objectForKeyedSubscript:v46];
        [v43 setProduct:v47];

        long long v48 = [v43 deviceID];
        long long v49 = [v64 objectForKeyedSubscript:v48];
        [v43 setVersion:v49];
      }
      id v40 = [v38 countByEnumeratingWithState:&v67 objects:v79 count:16];
    }
    while (v40);
  }

  id v50 = [objc_alloc((Class)KTSelfVerificationInfo) initWithSyncedLoggableDatas:v56 uriToServerLoggableDatas:*(void *)(v58 + 56)];
  id v51 = [*(id *)(v58 + 64) primaryRegistration];
  __int16 v52 = [v51 pushToken];
  [v50 setSelfDeviceID:v52];

  (*(void (**)(void))(*(void *)(v58 + 72) + 16))();
}

id sub_100419204(id a1, KTLoggableData *a2)
{
  return [(KTLoggableData *)a2 deviceID];
}

id sub_10041920C(id a1, KTLoggableData *a2)
{
  return [(KTLoggableData *)a2 deviceID];
}

void sub_1004196FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100419720(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained(a1 + 6);
  if (v6)
  {
    uint64_t v8 = +[IDSFoundationLog KeyTransparency];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      sub_1007251E0();
    }
    id v9 = 0;
  }
  else
  {
    id v9 = objc_msgSend(a1[4], "_IDSKTAccountStatusForKTAccountStatus:", objc_msgSend(v5, "accountStatus"));
    uint64_t v8 = +[IDSFoundationLog KeyTransparency];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      id v10 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [v5 accountStatus]);
      uint64_t v11 = +[NSNumber numberWithInteger:v9];
      *(_DWORD *)long long buf = 138412546;
      uint64_t v17 = v10;
      __int16 v18 = 2112;
      int8x16_t v19 = v11;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Received KTAccountStatus from transparency. { KTAccountStatus: %@, currentKTAccountStatus: %@ }", buf, 0x16u);
    }
  }

  id v12 = im_primary_queue();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100419930;
  block[3] = &unk_10098D0B8;
  void block[4] = WeakRetained;
  id v15 = v9;
  id v14 = a1[5];
  dispatch_async(v12, block);
}

uint64_t sub_100419930(uint64_t a1)
{
  [*(id *)(a1 + 32) setMostRecentKTCDPAccountStatus:*(void *)(a1 + 48)];
  id v2 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16);

  return v2();
}

uint64_t sub_10041AED0(uint64_t a1, void *a2)
{
  [a2 state];
  id v3 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);

  return v3();
}

void sub_10041BB84(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[NSDate date];
  [v4 timeIntervalSinceDate:*(void *)(a1 + 32)];
  double v6 = v5;
  id v7 = [v3 state];
  uint64_t v8 = +[IDSFoundationLog KeyTransparency];
  BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (v7)
  {
    if (v9)
    {
      id v10 = [v3 error];
      *(_DWORD *)long long buf = 134218242;
      double v24 = v6;
      __int16 v25 = 2112;
      id v26 = v10;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Failed to sync KVS. { timeInterval: %f, error: %@ }", buf, 0x16u);
    }
    uint64_t v11 = +[TransparencyAnalytics logger];
    id v12 = [v3 error];
    [v11 logResultForEvent:@"ktKVSSync" hardFailure:1 result:v12];

    uint64_t v13 = +[TransparencyAnalytics logger];
    id v14 = +[NSNumber numberWithDouble:v6];
    id v15 = +[NSString stringWithFormat:@"%@-%@", @"ktKVSSyncTime", @"Failure"];
    [v13 logMetric:v14 withName:v15];

    id v16 = *(void **)(a1 + 40);
    uint64_t v17 = [v3 error];
    [v16 failWithError:v17];
  }
  else
  {
    if (v9)
    {
      *(_DWORD *)long long buf = 134217984;
      double v24 = v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Successfully synced KVS. {timeInterval: %f", buf, 0xCu);
    }

    __int16 v18 = +[TransparencyAnalytics logger];
    [v18 logSuccessForEventNamed:@"ktKVSSync"];

    int8x16_t v19 = +[TransparencyAnalytics logger];
    __int16 v20 = +[NSNumber numberWithDouble:v6];
    id v21 = +[NSString stringWithFormat:@"%@-%@", @"ktKVSSyncTime", @"Success"];
    [v19 logMetric:v20 withName:v21];

    id v22 = *(void **)(a1 + 40);
    uint64_t v17 = +[NSNull null];
    [v22 fulfillWithValue:v17];
  }
}

void sub_10041C128(uint64_t a1, void *a2)
{
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  id v3 = [a2 allKeys];
  id v4 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v11;
    while (2)
    {
      for (uint64_t i = 0; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v11 != v6) {
          objc_enumerationMutation(v3);
        }
        if (![*(id *)(a1 + 32) isKeyInKVS:*(void *)(*((void *)&v10 + 1) + 8 * i)])
        {

          uint64_t v8 = +[IDSFoundationLog KeyTransparency];
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)BOOL v9 = 0;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "This device is missing from KVS. Uploading it.", v9, 2u);
          }

          id v3 = [*(id *)(a1 + 32) keyManager];
          [v3 updateKVSForKTRegistrationData];
          goto LABEL_13;
        }
      }
      id v5 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
      if (v5) {
        continue;
      }
      break;
    }
  }
LABEL_13:
}

void sub_10041C354(uint64_t a1)
{
  unint64_t v1 = [*(id *)(a1 + 32) keyTransparencyStore];
  id v2 = [v1 fetchAllEntries];

  CFMutableDictionaryRef theDict = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
  uint64_t v17 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  id v3 = v2;
  id v4 = [v3 countByEnumeratingWithState:&v21 objects:v27 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v22;
    uint64_t v19 = IDSKTKVSTrustedDeviceMetadataKey;
    uint64_t v20 = IDSKTKVSTrustedDeviceKey;
    do
    {
      for (uint64_t i = 0; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v22 != v6) {
          objc_enumerationMutation(v3);
        }
        uint64_t v8 = *(const void **)(*((void *)&v21 + 1) + 8 * i);
        BOOL v9 = [v3 objectForKey:v8];
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          long long v10 = [IDSProtoKeyTransparencyTrustedDevice alloc];
          long long v11 = [v9 objectForKey:v20];
          long long v12 = [(IDSProtoKeyTransparencyTrustedDevice *)v10 initWithData:v11];

          long long v13 = [IDSProtoKeyTransparencyTrustedDeviceMetadata alloc];
          id v14 = [v9 objectForKey:v19];
          id v15 = [(IDSProtoKeyTransparencyTrustedDeviceMetadata *)v13 initWithData:v14];

          if (v12) {
            CFDictionarySetValue(theDict, v8, v12);
          }
          if (v15) {
            CFDictionarySetValue(v17, v8, v15);
          }
        }
        else
        {
          long long v12 = +[IDSFoundationLog KeyTransparency];
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138412290;
            id v26 = v8;
            _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "KVSEntry not of expected type, skipping. {kvsKey: %@}", buf, 0xCu);
          }
        }
      }
      id v5 = [v3 countByEnumeratingWithState:&v21 objects:v27 count:16];
    }
    while (v5);
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

BOOL sub_10041D8E4(uint64_t a1, void *a2)
{
  id v3 = *(void **)(a1 + 32);
  id v4 = a2;
  id v5 = [v3 registrationDataSource];
  uint64_t v6 = [*(id *)(a1 + 40) serviceIdentifier];
  id v7 = [v4 pushToken];

  id v8 = [v5 expectedRemoteKeyTransparencyEligibilityForServiceIdentifier:v6 pushToken:v7];
  return v8 == (id)1;
}

id sub_10041DA50(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) _isTrustedCandidate:a2 index:*(void *)(a1 + 40) givenTrustedDevices:*(void *)(a1 + 48)];
}

unint64_t sub_10041DB40(uint64_t a1, void *a2)
{
  unint64_t v7 = a2;
  id v3 = [(id)v7 trustedServices];
  BOOL v9 = _NSConcreteStackBlock;
  uint64_t v10 = 3221225472;
  long long v11 = sub_10041DC5C;
  long long v12 = &unk_10098D1A0;
  id v13 = *(id *)(a1 + 32);
  id v14 = *(id *)(a1 + 40);
  id v4 = objc_msgSend(v3, "__imArrayByFilteringWithBlock:", &v9);

  id v5 = objc_msgSend(*(id *)(a1 + 40), "pushToken", v9, v10, v11, v12);
  uint64_t v6 = [(id)v7 pushToken];

  LODWORD(v7) = [v5 isEqual:v6];
  if ([v4 count]) {
    unint64_t v7 = v7;
  }
  else {
    unint64_t v7 = 0;
  }

  return v7;
}

uint64_t sub_10041DC5C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 serviceIdentifier];
  if (v4)
  {
    id v5 = [*(id *)(a1 + 32) serviceIdentifier];
    uint64_t v6 = [v3 serviceIdentifier];
    unsigned int v7 = [v5 isEqual:v6];
  }
  else
  {
    unsigned int v7 = 0;
  }

  id v8 = [v3 ktLoggableData];
  BOOL v9 = [v8 data];
  if (v9)
  {
    uint64_t v10 = [*(id *)(a1 + 40) loggableData];
    long long v11 = [v3 ktLoggableData];
    long long v12 = [v11 data];
    unsigned int v13 = [v10 isEqual:v12];
  }
  else
  {
    unsigned int v13 = 0;
  }

  id v14 = [*(id *)(a1 + 32) URI];
  if (v14)
  {
    id v15 = [v3 uris];
    id v16 = objc_msgSend(v15, "__imArrayByApplyingBlock:", &stru_10098D178);
    uint64_t v17 = [*(id *)(a1 + 32) URI];
    unsigned int v18 = [v16 containsObject:v17];
  }
  else
  {
    unsigned int v18 = 0;
  }

  return v7 & v13 & v18;
}

id sub_10041DDF0(id a1, NSString *a2)
{
  return +[IDSURI URIWithPrefixedURI:a2];
}

IDSKeyTransparencyEntry *sub_10041E3FC(uint64_t a1, void *a2)
{
  id v3 = a2;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  id v4 = objc_msgSend(v3, "trustedServices", 0);
  id v5 = [v4 countByEnumeratingWithState:&v23 objects:v27 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v24;
    while (2)
    {
      for (uint64_t i = 0; i != v6; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v24 != v7) {
          objc_enumerationMutation(v4);
        }
        BOOL v9 = *(void **)(*((void *)&v23 + 1) + 8 * i);
        uint64_t v10 = [v9 serviceIdentifier];
        if ([v10 isEqualToString:*(void *)(a1 + 32)])
        {

LABEL_13:
          id v15 = [v9 ktLoggableData];
          unsigned int v13 = [v15 data];

          id v14 = [v9 deviceSignature];
          goto LABEL_14;
        }
        unsigned int v11 = [v9 keyIndex];
        int v12 = sub_10030C08C((int)[*(id *)(a1 + 40) ktRegistrationDataIndex]);

        if (v11 == v12) {
          goto LABEL_13;
        }
      }
      id v6 = [v4 countByEnumeratingWithState:&v23 objects:v27 count:16];
      unsigned int v13 = 0;
      id v14 = 0;
      if (v6) {
        continue;
      }
      break;
    }
  }
  else
  {
    unsigned int v13 = 0;
    id v14 = 0;
  }
LABEL_14:

  id v16 = [v3 pushToken];
  if (v16 && v13)
  {

    if (v14)
    {
      uint64_t v17 = [IDSKeyTransparencyEntry alloc];
      unsigned int v18 = [v3 pushToken];
      uint64_t v19 = [(IDSKeyTransparencyEntry *)v17 initWithPushToken:v18 loggableData:v13 signedData:v14];

      [(IDSKeyTransparencyEntry *)v19 setKtCapable:1];
      uint64_t v20 = [v3 productName];
      [(IDSKeyTransparencyEntry *)v19 setProductName:v20];

      long long v21 = [v3 buildVersion];
      [(IDSKeyTransparencyEntry *)v19 setBuildVersion:v21];

      -[IDSKeyTransparencyEntry setTransparencyVersion:](v19, "setTransparencyVersion:", [v3 transparencyVersion]);
      goto LABEL_20;
    }
  }
  else
  {
  }
  uint64_t v19 = 0;
LABEL_20:

  return v19;
}

int64_t sub_10041ED44(id a1, NSData *a2, NSData *a3)
{
  id v4 = a3;
  id v5 = [(NSData *)a2 __imHexString];
  id v6 = [(NSData *)v4 __imHexString];

  id v7 = [v5 compare:v6];
  return (int64_t)v7;
}

void sub_10041F1CC(id a1)
{
  v3[0] = IDSiMessageKeyTransparencyService;
  v3[1] = IDSMultiplex1KeyTransparencyService;
  v4[0] = @"im://";
  v4[1] = @"mp1://";
  v3[2] = IDSFaceTimeMultiKeyTransparencyService;
  _DWORD v4[2] = @"ftm://";
  uint64_t v1 = +[NSDictionary dictionaryWithObjects:v4 forKeys:v3 count:3];
  id v2 = (void *)qword_100A4CA68;
  qword_100A4CA68 = v1;
}

uint64_t sub_100422E10(void *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = [a1 bag];
  id v2 = [v1 objectForKey:@"sps-prov-keys-rate-limit-count"];

  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    uint64_t v3 = (uint64_t)[v2 integerValue];
  }
  else {
    uint64_t v3 = 3;
  }

  return v3;
}

double sub_100422E94(void *a1)
{
  if (!a1) {
    return 0.0;
  }
  uint64_t v1 = [a1 bag];
  id v2 = [v1 objectForKey:@"sps-prov-keys-rate-limit-time-limit"];

  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    double v3 = (double)(uint64_t)[v2 integerValue];
  }
  else {
    double v3 = 86400.0;
  }

  return v3;
}

void sub_100423024(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  id v6 = +[IDSFoundationLog stewieProvisioning];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v7 = @"NO";
    if (a2) {
      CFStringRef v7 = @"YES";
    }
    int v25 = 138412546;
    long long v26 = (void *)v7;
    __int16 v27 = 2112;
    id v28 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Fetched Stewie enablement status: %@  error: %@", (uint8_t *)&v25, 0x16u);
  }

  if (!v5 && (a2 & 1) != 0 || ([*(id *)(a1 + 32) isStewieEnabled] & 1) != 0)
  {
    id v8 = +[IDSFoundationLog stewieProvisioning];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v25) = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Notified of startup, checking stewie components", (uint8_t *)&v25, 2u);
    }

    BOOL v9 = [*(id *)(a1 + 32) store];
    [v9 persistStewieEnabled];

    if (CUTIsInternalInstall())
    {
      uint64_t v10 = [*(id *)(a1 + 32) store];
      unsigned int v11 = [v10 persistedSPSEnvironment];

      int v12 = IMGetSPSEnvironmentName();
      if ([v11 length] && (objc_msgSend(v12, "isEqualToIgnoringCase:", v11) & 1) == 0)
      {
        unsigned int v13 = +[IDSFoundationLog stewieProvisioning];
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          int v25 = 138412546;
          long long v26 = v11;
          __int16 v27 = 2112;
          id v28 = v12;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "SPS Environment changed - was: %@, is now: %@", (uint8_t *)&v25, 0x16u);
        }

        [*(id *)(a1 + 32) clearAllState];
      }
    }
    if (+[IMUserDefaults clearStewieStoreOnLaunch])
    {
      id v14 = +[IDSFoundationLog stewieProvisioning];
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v25) = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Detected clear state default", (uint8_t *)&v25, 2u);
      }

      [*(id *)(a1 + 32) clearAllState];
    }
    id v15 = [*(id *)(a1 + 32) store];
    id v16 = [v15 persistedNextHeartbeat];

    uint64_t v17 = +[IDSFoundationLog stewieProvisioning];
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      int v25 = 138412290;
      long long v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Loaded next heartbeat { nextHeartbeat: %@ }", (uint8_t *)&v25, 0xCu);
    }

    if (v16) {
      sub_1004234C8(*(void **)(a1 + 32), v16);
    }
    unsigned int v18 = [*(id *)(a1 + 32) store];
    uint64_t v19 = [v18 persistedNextRollKeys];

    uint64_t v20 = +[IDSFoundationLog stewieProvisioning];
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      int v25 = 138412290;
      long long v26 = v19;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Loaded next roll keys { nextRollKeys: %@ }", (uint8_t *)&v25, 0xCu);
    }

    if (v19) {
      sub_100423648(*(void **)(a1 + 32), v19);
    }
    long long v21 = [*(id *)(a1 + 32) store];
    long long v22 = [v21 persistedNextRollSMSConfig];

    long long v23 = +[IDSFoundationLog stewieProvisioning];
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      int v25 = 138412290;
      long long v26 = v22;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Loaded next roll sms config { nextRollSMSConfig: %@ }", (uint8_t *)&v25, 0xCu);
    }

    if (v22) {
      sub_1004237C0(*(void **)(a1 + 32), v22);
    }
    sub_100423938(*(void **)(a1 + 32));
    sub_1004239D0(*(void **)(a1 + 32));
    long long v24 = [*(id *)(a1 + 32) sessionKeyManager];
    [v24 performInitialKeyInfoCheck];

    sub_100423A68(*(id *)(a1 + 32));
    sub_100423B54(*(void **)(a1 + 32));
  }
  else
  {
    id v16 = +[IDSFoundationLog stewieProvisioning];
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v25) = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Stewie is not enabled, not checking stewie components", (uint8_t *)&v25, 2u);
    }
  }
}

void sub_1004234C8(void *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v4 = +[IDSFoundationLog stewieProvisioning];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v12 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Setting heartbeat timer for next heartbeat { nextHeartbeat: %@ }", buf, 0xCu);
    }

    sub_100423D10(a1);
    id v5 = objc_alloc((Class)IMDispatchTimer);
    id v6 = im_primary_queue();
    [v3 timeIntervalSinceNow];
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_100423D84;
    v10[3] = &unk_100980598;
    void v10[4] = a1;
    id v8 = [v5 initWithQueue:v6 interval:(unint64_t)v7 repeats:0 handlerBlock:v10];
    [a1 setHeartbeatTimer:v8];

    [v3 timeIntervalSinceNow];
    if (v9 < 0.0) {
      [a1 heartbeatTimerFired];
    }
  }
}

void sub_100423648(void *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v4 = +[IDSFoundationLog stewieProvisioning];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v12 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Setting roll keys timer for next roll keys { nextRollKeys: %@ }", buf, 0xCu);
    }

    id v5 = objc_alloc((Class)IMDispatchTimer);
    id v6 = im_primary_queue();
    [v3 timeIntervalSinceNow];
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_100423FD4;
    v10[3] = &unk_100980598;
    void v10[4] = a1;
    id v8 = [v5 initWithQueue:v6 interval:(unint64_t)v7 repeats:0 handlerBlock:v10];
    [a1 setRollKeysTimer:v8];

    [v3 timeIntervalSinceNow];
    if (v9 < 0.0) {
      [a1 rollKeysTimerFired];
    }
  }
}

void sub_1004237C0(void *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v4 = +[IDSFoundationLog stewieProvisioning];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v12 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Setting roll keys timer for next roll sms config { nextRollSMSConfig: %@ }", buf, 0xCu);
    }

    id v5 = objc_alloc((Class)IMDispatchTimer);
    id v6 = im_primary_queue();
    [v3 timeIntervalSinceNow];
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_100423EEC;
    v10[3] = &unk_100980598;
    void v10[4] = a1;
    id v8 = [v5 initWithQueue:v6 interval:(unint64_t)v7 repeats:0 handlerBlock:v10];
    [a1 setRollSMSConfigTimer:v8];

    [v3 timeIntervalSinceNow];
    if (v9 < 0.0) {
      sub_100423EF4(a1);
    }
  }
}

void sub_100423938(void *a1)
{
  if (a1)
  {
    id v2 = [a1 deviceInfoManager];

    if (!v2)
    {
      id v3 = [[IDSStewieDeviceInfoManager alloc] initWithDelegate:a1 queue:a1[9]];
      [a1 setDeviceInfoManager:v3];
    }
    id v4 = [a1 deviceInfoManager];
    [v4 performInitialDeviceInfoCheck];
  }
}

void sub_1004239D0(void *a1)
{
  if (a1)
  {
    id v2 = [a1 phoneNumberManager];

    if (!v2)
    {
      id v3 = [[IDSStewiePhoneNumberManager alloc] initWithDelegate:a1 queue:a1[9] userStore:a1[10]];
      [a1 setPhoneNumberManager:v3];
    }
    id v4 = [a1 phoneNumberManager];
    [v4 performInitialPhoneInfoCheck];
  }
}

void sub_100423A68(id val)
{
  if (val)
  {
    id location = (id)0xAAAAAAAAAAAAAAAALL;
    objc_initWeak(&location, val);
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_100423C20;
    void v3[3] = &unk_10097E518;
    objc_copyWeak(&v4, &location);
    void v3[4] = val;
    id v2 = [val queue];
    sub_1003319E8(v3, @"IDS-Stewie", (uint64_t)v2);

    objc_destroyWeak(&v4);
    objc_destroyWeak(&location);
  }
}

void sub_100423B38(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 24));
  _Unwind_Resume(a1);
}

void sub_100423B54(void *a1)
{
  if (a1)
  {
    uint64_t v2 = +[IDSFoundationLog stewieProvisioning];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Performing initial sms config info check", v4, 2u);
    }

    id v3 = [a1 ctClient];
    [v3 fetchStewieSMSConfig];
  }
}

uint64_t sub_100423C20(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    id v3 = +[IDSFoundationLog stewieProvisioning];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      id v4 = [*(id *)(a1 + 32) store];
      id v5 = [v4 persistedStewieLoggingGUID];
      int v7 = 138412290;
      id v8 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Stewie logging GUID: %@", (uint8_t *)&v7, 0xCu);
    }
  }

  return 0;
}

void sub_100423D10(void *a1)
{
  if (a1)
  {
    uint64_t v2 = [a1 heartbeatTimer];

    if (v2)
    {
      id v3 = [a1 heartbeatTimer];
      [v3 invalidate];

      [a1 setHeartbeatTimer:0];
    }
  }
}

id sub_100423D84(uint64_t a1)
{
  return [*(id *)(a1 + 32) heartbeatTimerFired];
}

double sub_100423E3C(void *a1)
{
  if (!a1) {
    return 0.0;
  }
  uint64_t v1 = [a1 bag];
  uint64_t v2 = [v1 objectForKey:@"sps-prov-heartbeat-interval"];

  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    double v3 = (double)(uint64_t)[v2 integerValue];
  }
  else {
    double v3 = 2592000.0;
  }
  if (+[IMUserDefaults stewieHeartbeatInterval] >= 1) {
    double v3 = (double)+[IMUserDefaults stewieHeartbeatInterval];
  }

  return v3;
}

id sub_100423EEC(uint64_t a1)
{
  return sub_100423EF4(*(id *)(a1 + 32));
}

id sub_100423EF4(id result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = +[IDSFoundationLog stewieProvisioning];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Stewie roll SMS config fired", v6, 2u);
    }

    double v3 = [v1 ctClient];
    unsigned __int8 v4 = [v3 forceRollSMSConfigWipeAll:1];

    if ((v4 & 1) == 0)
    {
      id v5 = +[IDSFoundationLog stewieProvisioning];
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_10072542C(v5);
      }
    }
    return [v1 setRollSMSConfigTimer:0];
  }
  return result;
}

id sub_100423FD4(uint64_t a1)
{
  return [*(id *)(a1 + 32) rollKeysTimerFired];
}

void sub_100424E1C(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog stewieProvisioning];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
    sub_1007254E8(a1, v2);
  }

  double v3 = [*(id *)(a1 + 40) phoneNumberManager];
  [v3 performInitialPhoneInfoCheck];
}

uint64_t sub_100425E14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_100425E98;
  v8[3] = &unk_10098D2A8;
  void v8[4] = a1;
  void v8[5] = a2;
  v8[6] = a3;
  v8[7] = a4;
  __int16 v8[8] = a5;
  v8[9] = a6;
  v8[10] = a7;
  sub_1001C0EBC(@"INSERT INTO firewall_record (handle, merge_id, service, category, is_donated, last_seen_date, last_modified_date) VALUES (?, ?, ?, ?, ?, ?, ?);",
    v8);
  return 1;
}

uint64_t sub_100425E98()
{
  CSDBSqliteBindTextFromCFString();
  CSDBSqliteBindTextFromCFString();
  CSDBSqliteBindTextFromCFString();
  CSDBSqliteBindInt64();
  CSDBSqliteBindInt64();
  CSDBSqliteBindInt64();
  CSDBSqliteBindInt64();

  return CSDBSqliteStatementPerform();
}

uint64_t sub_100425F24(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_100425FA4;
  v7[3] = &unk_10098D2C8;
  void v7[4] = a2;
  void v7[5] = a5;
  v7[6] = a6;
  v7[7] = a1;
  v7[8] = a3;
  v7[9] = a4;
  sub_1001C0EBC(@"UPDATE firewall_record SET merge_id = ?, last_seen_date = ?, last_modified_date = ? WHERE handle = ? AND category = ? AND is_donated = ?;",
    v7);
  return 1;
}

uint64_t sub_100425FA4()
{
  CSDBSqliteBindTextFromCFString();
  CSDBSqliteBindInt64();
  CSDBSqliteBindInt64();
  CSDBSqliteBindTextFromCFString();
  CSDBSqliteBindInt64();
  CSDBSqliteBindInt64();

  return CSDBSqliteStatementPerform();
}

uint64_t sub_100426024(const __CFArray *a1, uint64_t a2)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  CFStringAppend(Mutable, @"DELETE FROM firewall_record WHERE handle ");
  CFArrayGetCount(a1);
  CFStringRef v5 = (const __CFString *)CSDBGenerateInClauseForCount();
  CFStringAppend(Mutable, v5);
  CFStringAppend(Mutable, @"AND category = ?");
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_1004260F4;
  v7[3] = &unk_1009898F8;
  void v7[4] = a1;
  void v7[5] = a2;
  sub_1001C0EBC((uint64_t)Mutable, v7);
  return 1;
}

uint64_t sub_1004260F4()
{
  CSDBSqliteBindTextFromCFArrayOfCFStrings();
  CSDBSqliteBindInt64();

  return CSDBSqliteStatementPerform();
}

uint64_t sub_100426144(const __CFArray *a1, uint64_t a2)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  CFStringAppend(Mutable, @"DELETE FROM firewall_record WHERE merge_id ");
  CFArrayGetCount(a1);
  CFStringRef v5 = (const __CFString *)CSDBGenerateInClauseForCount();
  CFStringAppend(Mutable, v5);
  CFStringAppend(Mutable, @"AND category = ?");
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_100426214;
  v7[3] = &unk_1009898F8;
  void v7[4] = a1;
  void v7[5] = a2;
  sub_1001C0EBC((uint64_t)Mutable, v7);
  return 1;
}

uint64_t sub_100426214()
{
  CSDBSqliteBindTextFromCFArrayOfCFStrings();
  CSDBSqliteBindInt64();

  return CSDBSqliteStatementPerform();
}

uint64_t sub_100426264(const __CFArray *a1, uint64_t a2, uint64_t a3)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  CFStringAppend(Mutable, @"DELETE FROM firewall_record WHERE handle ");
  CFArrayGetCount(a1);
  CFStringRef v7 = (const __CFString *)CSDBGenerateInClauseForCount();
  CFStringAppend(Mutable, v7);
  CFStringAppend(Mutable, @"AND category = ? AND is_donated = ?;");
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  v9[2] = sub_10042633C;
  v9[3] = &unk_10098D2E8;
  void v9[4] = a1;
  void v9[5] = a2;
  v9[6] = a3;
  sub_1001C0EBC((uint64_t)Mutable, v9);
  return 1;
}

uint64_t sub_10042633C()
{
  CSDBSqliteBindTextFromCFArrayOfCFStrings();
  CSDBSqliteBindInt64();
  CSDBSqliteBindInt64();

  return CSDBSqliteStatementPerform();
}

uint64_t sub_100426398(const __CFArray *a1, uint64_t a2, uint64_t a3)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  CFStringAppend(Mutable, @"DELETE FROM firewall_record WHERE merge_id ");
  CFArrayGetCount(a1);
  CFStringRef v7 = (const __CFString *)CSDBGenerateInClauseForCount();
  CFStringAppend(Mutable, v7);
  CFStringAppend(Mutable, @"AND category = ? AND is_donated = ?;");
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  v9[2] = sub_100426470;
  v9[3] = &unk_10098D2E8;
  void v9[4] = a1;
  void v9[5] = a2;
  v9[6] = a3;
  sub_1001C0EBC((uint64_t)Mutable, v9);
  return 1;
}

uint64_t sub_100426470()
{
  CSDBSqliteBindTextFromCFArrayOfCFStrings();
  CSDBSqliteBindInt64();
  CSDBSqliteBindInt64();

  return CSDBSqliteStatementPerform();
}

uint64_t sub_1004264CC(uint64_t a1, uint64_t a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100426544;
  void v3[3] = &unk_1009898F8;
  void v3[4] = a1;
  void v3[5] = a2;
  sub_1001C0EBC(@"DELETE FROM firewall_record WHERE category = ? AND is_donated = ?", v3);
  return 1;
}

uint64_t sub_100426544()
{
  CSDBSqliteBindInt64();
  CSDBSqliteBindInt64();

  return CSDBSqliteStatementPerform();
}

uint64_t sub_100426594(uint64_t a1)
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_10042660C;
  v2[3] = &unk_10097F2A0;
  void v2[4] = a1;
  sub_1001C0EBC(@"DELETE FROM firewall_record WHERE category = ?", v2);
  return 1;
}

uint64_t sub_10042660C()
{
  CSDBSqliteBindInt64();

  return CSDBSqliteStatementPerform();
}

uint64_t sub_10042664C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = 0;
  CFStringRef v7 = &v6;
  uint64_t v8 = 0x2020000000;
  char v9 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_100426714;
  v5[3] = &unk_10098D310;
  v5[6] = a2;
  void v5[7] = a3;
  void v5[4] = &v6;
  void v5[5] = a1;
  sub_1001C0F28(@"SELECT COUNT(1) FROM firewall_record WHERE handle = ? AND category = ? AND is_donated = ?LIMIT 1;",
    v5);
  uint64_t v3 = *((unsigned __int8 *)v7 + 24);
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_1004266FC(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100426714(uint64_t a1)
{
  CSDBSqliteBindTextFromCFString();
  CSDBSqliteBindInt64();
  CSDBSqliteBindInt64();
  uint64_t result = CSDBSqliteStep();
  if (result)
  {
    uint64_t result = CSDBSqliteStatementInteger64ResultColumn();
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result > 0;
  }
  return result;
}

uint64_t sub_100426788(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000;
  char v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  _DWORD v4[2] = sub_100426850;
  void v4[3] = &unk_10097EEF0;
  void v4[5] = a1;
  v4[6] = a2;
  void v4[4] = &v5;
  sub_1001C0F28(@"SELECT COUNT(1) FROM firewall_record WHERE handle = ? AND category = ?LIMIT 1;", v4);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_100426838(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100426850(uint64_t a1)
{
  CSDBSqliteBindTextFromCFString();
  CSDBSqliteBindInt64();
  uint64_t result = CSDBSqliteStep();
  if (result)
  {
    uint64_t result = CSDBSqliteStatementInteger64ResultColumn();
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result > 0;
  }
  return result;
}

uint64_t sub_1004268B8(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000;
  char v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  _DWORD v4[2] = sub_100426980;
  void v4[3] = &unk_10097EEF0;
  void v4[5] = a1;
  v4[6] = a2;
  void v4[4] = &v5;
  sub_1001C0F28(@"SELECT COUNT(1) FROM firewall_record WHERE merge_id = ? AND category = ?LIMIT 1;", v4);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_100426968(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100426980(uint64_t a1)
{
  CSDBSqliteBindTextFromCFString();
  CSDBSqliteBindInt64();
  uint64_t result = CSDBSqliteStep();
  if (result)
  {
    uint64_t result = CSDBSqliteStatementInteger64ResultColumn();
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result > 0;
  }
  return result;
}

uint64_t sub_1004269E8(uint64_t a1)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100426AAC;
  void v3[3] = &unk_10098D338;
  void v3[4] = &v4;
  void v3[5] = a1;
  sub_1001C0F28(@"SELECT DISTINCT handle, last_seen_date, is_donated, merge_id FROM firewall_record WHERE category = ?;",
    v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_100426A94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100426AAC(uint64_t a1)
{
  CSDBSqliteBindInt64();
  uint64_t result = CSDBSqliteStatementCopyAllRowsStringsForColumnsAtIndices();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t sub_100426AF8(uint64_t a1)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100426BBC;
  void v3[3] = &unk_10098D338;
  void v3[4] = &v4;
  void v3[5] = a1;
  sub_1001C0F28(@"SELECT DISTINCT handle, last_seen_date, is_donated, merge_id FROM firewall_record WHERE category = ? AND is_donated = 1;",
    v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_100426BA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100426BBC(uint64_t a1)
{
  CSDBSqliteBindInt64();
  uint64_t result = CSDBSqliteStatementCopyAllRowsStringsForColumnsAtIndices();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

void sub_100426C08(uint64_t a1)
{
  v1[0] = _NSConcreteStackBlock;
  v1[1] = 3221225472;
  v1[2] = sub_100426C7C;
  v1[3] = &unk_10097F2A0;
  v1[4] = a1;
  sub_1001C0EBC(@"DELETE from firewall_record WHERE last_seen_date < ? AND is_donated = 0; ", v1);
}

uint64_t sub_100426C7C()
{
  CSDBSqliteBindInt64();

  return CSDBSqliteStatementPerform();
}

void sub_10042DFA8(id a1)
{
  uint64_t v1 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  uint64_t v2 = dispatch_queue_attr_make_initially_inactive(v1);
  xpc_object_t object = dispatch_queue_create("IDSGroupAgentQueue", v2);

  uint64_t v3 = IDSRealTimeContext();
  nw_queue_context_target_dispatch_queue();

  dispatch_activate(object);
  uint64_t v4 = [[IDSGroupAgent alloc] initWithQueue:object isSessionControlEnabled:_os_feature_enabled_impl()];
  uint64_t v5 = (void *)qword_100A4CA78;
  qword_100A4CA78 = (uint64_t)v4;

  [(id)qword_100A4CA78 registerAgent];
  [(id)qword_100A4CA78 registerEntitledAgent];
  sub_100108A60();
}

void sub_10042E5F4(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  char v9 = a4;
  uint64_t v10 = nw_array_get_object_at_index();
  if (v10)
  {
    unsigned int v11 = +[NSString stringWithFormat:@"%s", nw_endpoint_get_application_service_alias()];
    id v12 = [objc_alloc((Class)IDSGroupSessionConnectionParameters) initWithStringRepresentation:v11];
    unsigned int v13 = +[IDSFoundationLog TransportLevelAgent];
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      id v14 = [v12 sessionID];
      *(_DWORD *)long long buf = 138412802;
      id v29 = v8;
      __int16 v30 = 2112;
      __int16 v31 = v14;
      __int16 v32 = 2112;
      id v33 = v7;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "add_members_handler: request to add members %@, for sessionID %@, client %@", buf, 0x20u);
    }
    id v27 = v7;

    id v15 = [*(id *)(a1 + 32) membersArrayDict];
    id v16 = [v12 sessionID];
    uint64_t v17 = [v15 objectForKey:v16];

    if (v17)
    {
      unsigned int v18 = +[IDSFoundationLog TransportLevelAgent];
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v29 = v17;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "add_members_handler: current members found %@", buf, 0xCu);
      }

      id combined_array = (id)nw_array_create_combined_array();
    }
    else
    {
      id combined_array = v8;
    }
    uint64_t v20 = [*(id *)(a1 + 32) membersArrayDict];
    long long v21 = [v12 sessionID];
    [v20 setObject:combined_array forKey:v21];

    long long v22 = +[NSString stringWithFormat:@"%s", nw_endpoint_get_application_service_name()];
    long long v23 = (void *)nw_array_create();
    id v24 = v22;
    id v25 = v23;
    nw_array_apply();
    long long v26 = +[IDSFoundationLog TransportLevelAgent];
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v29 = v25;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "add_members_handler: calling assign with %@", buf, 0xCu);
    }

    v9[2](v9, v25);
    id v7 = v27;
  }
  else
  {
    unsigned int v11 = +[IDSFoundationLog TransportLevelAgent];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "add_members_handler: nw_agent_set_group_handlers called with empty array", buf, 2u);
    }
  }
}

uint64_t sub_10042E9E0(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  uint64_t v5 = +[NSString stringWithFormat:@"%s", nw_endpoint_get_application_service_name()];
  if ([*(id *)(a1 + 32) isEqualToString:v5]) {
    nw_array_append();
  }

  return 1;
}

void sub_10042EA68(id a1, OS_nw_agent_client *a2, OS_nw_array *a3, id a4)
{
  uint64_t v5 = a2;
  uint64_t v6 = a3;
  id v7 = +[IDSFoundationLog TransportLevelAgent];
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 138412546;
    char v9 = v6;
    __int16 v10 = 2112;
    unsigned int v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Request to remove members %@, for client %@ ", (uint8_t *)&v8, 0x16u);
  }
}

void sub_10042EB40(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = (void *)nw_agent_client_copy_endpoint();
  int v8 = +[IDSFoundationLog TransportLevelAgent];
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    long long v22 = v7;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Client starting flow to %@\n", buf, 0xCu);
  }

  if (v7)
  {
    char v9 = +[NSString stringWithFormat:@"%s", nw_endpoint_get_description()];
    __int16 v10 = [*(id *)(*(void *)(a1 + 32) + 72) objectForKeyedSubscript:v9];
    unsigned int v11 = [IDSTransportLevelAgentClientInfo alloc];
    id v12 = [v10 appleID];
    unsigned int v13 = [(IDSTransportLevelAgentClientInfo *)v11 initWithAgentClient:v5 assign:v6 parameters:v12];

    [(IDSTransportLevelAgentClientInfo *)v13 setLocalEndpoint:v7];
    [(IDSTransportLevelAgentClientInfo *)v13 setEndpoint:v7];
    id v14 = sub_10042EDC0();
    id v15 = [v10 secondaryPort];
    id v16 = [v15 stringValue];

    id v17 = v14;
    unsigned int v18 = (const char *)[v17 cStringUsingEncoding:134217984];
    id v19 = v16;
    nw_endpoint_t host = nw_endpoint_create_host(v18, (const char *)[v19 cStringUsingEncoding:134217984]);
    [(IDSTransportLevelAgentClientInfo *)v13 setLocalEndpoint:host];

    [*(id *)(*(void *)(a1 + 32) + 96) connectionRequest:v13];
    [*(id *)(*(void *)(a1 + 32) + 80) setObject:v13 forKey:v9];
  }
  else
  {
    char v9 = (void *)nw_agent_client_copy_path();
    if ((nw_path_is_listener() & 1) == 0) {
      (*((void (**)(id, void, void, void))v6 + 2))(v6, 0, 0, 0);
    }
  }
}

id sub_10042EDC0()
{
  int v6 = 0;
  uint64_t v5 = 0;
  uint64_t v4 = 1;
  arc4random_buf(&v5, 8uLL);
  *(void *)&long long v0 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v0 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v8[14] = v0;
  *(_OWORD *)id v7 = v0;
  *(_OWORD *)int v8 = v0;
  inet_ntop(30, &v4, v7, 0x2Eu);
  uint64_t v1 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v7, 7708, v4);
  uint64_t v2 = [v1 stringByAppendingString:@"%"];

  return v2;
}

void sub_10042EEA4(uint64_t a1)
{
  uint64_t v2 = (void *)nw_agent_client_copy_endpoint();
  uint64_t v3 = +[NSString stringWithFormat:@"%@", v2];

  uint64_t v4 = +[IDSFoundationLog TransportLevelAgent];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    id v29 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Client stopped flow to endpoint %@\n", buf, 0xCu);
  }

  uint64_t v5 = [*(id *)(*(void *)(a1 + 32) + 72) objectForKeyedSubscript:v3];
  id v6 = objc_alloc((Class)IDSGroupSessionConnectionParameters);
  id v7 = [v5 appleID];
  id v8 = [v6 initWithStringRepresentation:v7];

  if (v8 && ![v8 participantID])
  {
    char v9 = [*(id *)(a1 + 32) membersArrayDict];
    __int16 v10 = [v8 sessionID];
    [v9 removeObjectForKey:v10];

    unsigned int v11 = [*(id *)(a1 + 32) portCollisionDetection];
    id v12 = [v8 sessionID];
    [v11 removeObjectForKey:v12];

    unsigned int v13 = [*(id *)(a1 + 32) managedSessions];
    id v14 = [v8 sessionID];
    id v15 = [v13 objectForKey:v14];

    if (v15)
    {
      id v16 = +[IDSFoundationLog TransportLevelAgent];
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        id v17 = [v8 sessionID];
        *(_DWORD *)long long buf = 138412290;
        id v29 = v17;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Group session %@ ended.", buf, 0xCu);
      }
      unsigned int v18 = im_primary_queue();
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10042F24C;
      block[3] = &unk_10097E440;
      id v26 = v15;
      id v19 = v8;
      id v27 = v19;
      dispatch_async(v18, block);

      uint64_t v20 = [*(id *)(a1 + 32) managedSessions];
      long long v21 = [v19 sessionID];
      [v20 removeObjectForKey:v21];
    }
    long long v22 = *(void **)(*(void *)(a1 + 32) + 112);
    long long v23 = [v8 sessionID];
    [v22 removeObjectForKey:v23];
  }
  [*(id *)(*(void *)(a1 + 32) + 72) setObject:0 forKeyedSubscript:v3];
  id v24 = [*(id *)(*(void *)(a1 + 32) + 80) objectForKeyedSubscript:v3];
  if (v24)
  {
    [*(id *)(*(void *)(a1 + 32) + 96) connectionCancel:v24];
    [*(id *)(*(void *)(a1 + 32) + 80) removeObjectForKey:v3];
  }
}

void sub_10042F24C(uint64_t a1)
{
  [*(id *)(a1 + 32) endSession];
  id v3 = +[IDSDSessionController sharedInstance];
  uint64_t v2 = [*(id *)(a1 + 40) sessionID];
  [v3 cleanupSession:v2 shouldCleanSessionStatus:1];
}

void sub_10042F2C8(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = a3;
  uint64_t v5 = (void *)nw_agent_client_copy_endpoint();
  id v6 = +[IDSFoundationLog TransportLevelAgent];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 138412290;
    __int16 v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "resolve_handler: resolve request for endpoint %@\n", (uint8_t *)&v9, 0xCu);
  }

  if (v5)
  {
    id v7 = (void *)nw_array_create();
    if ([*(id *)(a1 + 32) isAppleEndpointForExistingSession:v5])
    {
      id v8 = [*(id *)(a1 + 32) resolveAppleEndpoint:v5];
      if (v8) {
        nw_array_append();
      }
      v4[2](v4, v7);
    }
  }
}

void sub_10042F3F8(id a1, OS_nw_agent_client *a2)
{
  uint64_t v2 = (void *)nw_agent_client_copy_endpoint();
  id v3 = +[IDSFoundationLog TransportLevelAgent];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    uint64_t v5 = v2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "resolve_handler: stop_resolve_handler called for endpoint:%@", (uint8_t *)&v4, 0xCu);
  }
}

void sub_10042F834(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = +[IDSFoundationLog TransportLevelAgent];
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    id v25 = v5;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "resolve_handler: resolve request for client %@\n", buf, 0xCu);
  }

  id v8 = (void *)nw_agent_client_copy_endpoint();
  if (v8)
  {
    int v9 = (void *)nw_array_create();
    __int16 v10 = (void *)nw_agent_client_copy_path();
    unsigned int v11 = (void *)nw_path_copy_parameters();
    uint64_t v12 = nw_parameters_get_server_mode() ^ 1;
    unsigned int v13 = +[IDSFoundationLog TransportLevelAgent];
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v25) = v12;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "resolve_handler: isClient: %d\n", buf, 8u);
    }

    id v14 = *(void **)(a1 + 32);
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 3221225472;
    void v19[2] = sub_10042FA48;
    v19[3] = &unk_10098D4C8;
    id v15 = v6;
    uint64_t v16 = *(void *)(a1 + 32);
    id v20 = v9;
    uint64_t v21 = v16;
    id v22 = v11;
    id v23 = v15;
    id v17 = v11;
    id v18 = v9;
    [v14 createNewSessionForClientRequest:v8 isClient:v12 registrationCompletionBlock:v19];
  }
}

void sub_10042FA48(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = [v4 objectForKeyedSubscript:IDSSessionUniqueIDKey];
  if (v5)
  {
    [*(id *)(a1 + 40) resolveAirDropProEndpointWithParams:*(void *)(a1 + 48) options:v4 agentResolveResponse:*(void *)(a1 + 56)];
  }
  else
  {
    id v6 = +[IDSFoundationLog TransportLevelAgent];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v7 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "resolve_handler: could not create session.", v7, 2u);
    }

    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
  }
}

void sub_10042FB18(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = (void *)nw_agent_client_copy_endpoint();
  id v5 = +[IDSFoundationLog TransportLevelAgent];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    id v12 = v3;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "resolve_handler: stop_resolve_handler called for client:%@", buf, 0xCu);
  }

  if ([*(id *)(a1 + 32) isAirDropSession:v4])
  {
    id v6 = +[NSString stringWithFormat:@"%s", nw_endpoint_get_application_service_alias()];
    id v7 = [v6 componentsSeparatedByString:@":"];
    if ((unint64_t)[v7 count] <= 4) {
      sub_100725564();
    }
    id v8 = [v7 objectAtIndexedSubscript:4];
    int v9 = [*(id *)(*(void *)(a1 + 32) + 104) objectForKey:v8];
    __int16 v10 = v9;
    if (v9)
    {
      [v9 leaveGroupSession:0 options:0];
      [*(id *)(*(void *)(a1 + 32) + 104) removeObjectForKey:v8];
      [*(id *)(*(void *)(a1 + 32) + 112) removeObjectForKey:v8];
      [*(id *)(*(void *)(a1 + 32) + 120) removeObjectForKey:v8];
    }
  }
}

void sub_100430914(uint64_t a1)
{
  uint64_t v2 = +[IDSDSessionController sharedInstance];
  id v3 = [v2 setupNewOutgoingSessionWithOptions:*(void *)(a1 + 32)];

  if (v3)
  {
    [v3 setClientID:*(void *)(a1 + 56)];
    id v4 = +[IDSFoundationLog TransportLevelAgent];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Created new sesssion: %@", buf, 0xCu);
    }

    [*(id *)(*(void *)(a1 + 40) + 104) setValue:v3 forKey:*(void *)(a1 + 48)];
    id v5 = +[NSMutableDictionary dictionary];
    memset(buf, 170, 20);
    arc4random_buf(buf, 0x14uLL);
    id v6 = +[NSData dataWithBytes:buf length:20];
    [v5 setObject:v6 forKeyedSubscript:IDSGroupSessionParticipantDataKey];

    [v5 setObject:&__kCFBooleanTrue forKeyedSubscript:IDSGroupSessionIsReliableUnicastSession];
    [v5 setObject:&__kCFBooleanTrue forKeyedSubscript:IDSGroupSessionStartedAsUPlusOneKey];
    [v5 setObject:&__kCFBooleanFalse forKeyedSubscript:IDSGroupSessionNewServerAllocationKey];
    [v3 joinWithOptions:v5];
  }
  else
  {
    id v5 = [*(id *)(*(void *)(a1 + 40) + 104) objectForKey:*(void *)(a1 + 48)];
    if (v5)
    {
      id v7 = +[IDSFoundationLog TransportLevelAgent];
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = *(void *)(a1 + 48);
        *(_DWORD *)long long buf = 138412546;
        *(void *)&uint8_t buf[4] = v5;
        *(_WORD *)&unsigned char buf[12] = 2112;
        *(void *)&unsigned char buf[14] = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "resolve_handler: Found existing session %@ with sessiondID %@, calling registration completion handler!", buf, 0x16u);
      }

      uint64_t v19 = IDSSessionUniqueIDKey;
      uint64_t v20 = *(void *)(a1 + 48);
      int v9 = +[NSDictionary dictionaryWithObjects:&v20 forKeys:&v19 count:1];
      __int16 v10 = [*(id *)(a1 + 40) queue];
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100430CA4;
      block[3] = &unk_10097E818;
      id v11 = *(id *)(a1 + 64);
      id v17 = v9;
      id v18 = v11;
      id v12 = v9;
      dispatch_async(v10, block);
    }
    else
    {
      unsigned int v13 = [*(id *)(a1 + 40) queue];
      v14[0] = _NSConcreteStackBlock;
      v14[1] = 3221225472;
      void v14[2] = sub_100430CBC;
      v14[3] = &unk_10097E7F0;
      id v15 = *(id *)(a1 + 64);
      dispatch_async(v13, v14);

      id v12 = v15;
    }
  }
}

uint64_t sub_100430CA4(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), 1, *(void *)(a1 + 32));
}

uint64_t sub_100430CBC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

int64_t sub_100430EA0(id a1, id a2, id a3)
{
  return (int64_t)[a2 compare:a3];
}

void sub_100431388(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  id v7 = [*(id *)(a1 + 32) entitledAgent];
  nw_agent_get_uuid();

  nw_endpoint_set_agent_identifier();
  uint64_t v8 = [*(id *)(*(void *)(a1 + 32) + 112) objectForKeyedSubscript:*(void *)(a1 + 40)];
  if (!v8)
  {
    uint64_t v8 = (void *)nw_array_create();
    [*(id *)(*(void *)(a1 + 32) + 112) setObject:v8 forKey:*(void *)(a1 + 40)];
  }
  nw_array_append();
  int v9 = +[IDSFoundationLog TransportLevelAgent];
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = 138412546;
    id v11 = v5;
    __int16 v12 = 2112;
    unsigned int v13 = v8;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "resolve_handler: storing evaluator:%@, responding with endpoints: %@", (uint8_t *)&v10, 0x16u);
  }

  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  [*(id *)(*(void *)(a1 + 32) + 120) setObject:v5 forKey:*(void *)(a1 + 40)];
}

uint64_t sub_100431924(void *a1)
{
  [a1 dataUsingEncoding:4];
  memset(v5, 170, 20);
  id v1 = objc_claimAutoreleasedReturnValue();
  CC_SHA1(objc_msgSend(v1, "bytes", *(void *)v5, *(void *)&v5[8], *(void *)&v5[16]), (CC_LONG)objc_msgSend(v1, "length"), v5);
  id v2 = +[NSData dataWithBytes:v5 length:20];
  uint64_t v3 = *(unsigned int *)[v2 bytes];

  return v3;
}

void *sub_100431E3C()
{
  return &unk_100794B30;
}

BOOL sub_100431E48(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return ((*a1 ^ *a2) & 1) == 0;
}

Swift::Int sub_100431E60()
{
  Swift::UInt v1 = *v0;
  sub_100726DD0();
  sub_100726DE0(v1);
  return sub_100726E30();
}

void sub_100431EA8()
{
  sub_100726DE0(*v0);
}

Swift::Int sub_100431ED4()
{
  Swift::UInt v1 = *v0;
  sub_100726DD0();
  sub_100726DE0(v1);
  return sub_100726E30();
}

uint64_t sub_100431F18(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100431F80(&qword_100A44A50);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16))(a2, a1, v4);
  return a2;
}

uint64_t sub_100431F80(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result < 0)
  {
    uint64_t result = swift_getTypeByMangledNameInContext2();
    *a1 = result;
  }
  return result;
}

uint64_t type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(uint64_t a1)
{
  return sub_100440FD0(a1, (uint64_t *)&unk_100A4CC20);
}

uint64_t sub_100431FE4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100431F80(&qword_100A44A50);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 32))(a2, a1, v4);
  return a2;
}

uint64_t type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey(uint64_t a1)
{
  return sub_100440FD0(a1, (uint64_t *)&unk_100A4CC30);
}

uint64_t sub_10043206C@<X0>(uint64_t a1@<X1>, char a2@<W2>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  v28[1] = a1;
  uint64_t v7 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey(0);
  __chkstk_darwin(v7, v8);
  int v10 = (char *)v28 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(0);
  __chkstk_darwin(v11, v12);
  uint64_t v14 = (char *)v28 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState(0);
  __chkstk_darwin(v15, v16);
  id v18 = (char *)v28 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_1004323D4(v4, (uint64_t)v18, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
  int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
  if (EnumCaseMultiPayload)
  {
    if (EnumCaseMultiPayload != 1)
    {
      uint64_t v22 = sub_100725CC0();
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v22 - 8) + 56))(a3, 1, 1, v22);
    }
    sub_10043243C((uint64_t)v18, (uint64_t)v10, type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey);
    if (a2)
    {
      uint64_t v24 = sub_100725CC0();
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v24 - 8) + 56))(a3, 1, 1, v24);
    }
    else
    {
      sub_100725CA0();
      uint64_t v20 = sub_100725CC0();
      (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v20 - 8) + 56))(a3, 0, 1, v20);
    }
    id v25 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey;
    uint64_t v26 = (uint64_t)v10;
  }
  else
  {
    sub_10043243C((uint64_t)v18, (uint64_t)v14, type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey);
    if (a2)
    {
      uint64_t v27 = sub_100725CC0();
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v27 - 8) + 56))(a3, 1, 1, v27);
    }
    else
    {
      sub_100725CA0();
      uint64_t v21 = sub_100725CC0();
      (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v21 - 8) + 56))(a3, 0, 1, v21);
    }
    id v25 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey;
    uint64_t v26 = (uint64_t)v14;
  }
  return sub_1004324A4(v26, v25);
}

uint64_t type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState(uint64_t a1)
{
  return sub_100440FD0(a1, (uint64_t *)&unk_100A4CC40);
}

uint64_t sub_1004323D4(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a3(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16))(a2, a1, v5);
  return a2;
}

uint64_t sub_10043243C(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a3(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 32))(a2, a1, v5);
  return a2;
}

uint64_t sub_1004324A4(uint64_t a1, uint64_t (*a2)(void))
{
  uint64_t v3 = a2(0);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v3 - 8) + 8))(a1, v3);
  return a1;
}

uint64_t sub_100432504@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey(0);
  __chkstk_darwin(v4, v5);
  uint64_t v7 = (char *)&v22 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(0);
  __chkstk_darwin(v8, v9);
  uint64_t v11 = (char *)&v22 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState(0);
  __chkstk_darwin(v12, v13);
  uint64_t v15 = (char *)&v22 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_1004323D4(v2, (uint64_t)v15, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
  int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
  if (!EnumCaseMultiPayload)
  {
    sub_10043243C((uint64_t)v15, (uint64_t)v11, type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey);
    sub_1004323D4((uint64_t)&v11[*(int *)(v8 + 20)], a1, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    uint64_t v17 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey;
    uint64_t v18 = (uint64_t)v11;
    goto LABEL_5;
  }
  if (EnumCaseMultiPayload == 1)
  {
    sub_10043243C((uint64_t)v15, (uint64_t)v7, type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey);
    sub_1004323D4((uint64_t)&v7[*(int *)(v4 + 20)], a1, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    uint64_t v17 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey;
    uint64_t v18 = (uint64_t)v7;
LABEL_5:
    sub_1004324A4(v18, v17);
    uint64_t v19 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v19 - 8) + 56))(a1, 0, 1, v19);
  }
  uint64_t v21 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v21 - 8) + 56))(a1, 1, 1, v21);
}

uint64_t sub_100432794()
{
  uint64_t v1 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey(0);
  __chkstk_darwin(v1, v2);
  uint64_t v4 = (char *)&v18 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v5 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(0);
  __chkstk_darwin(v5, v6);
  uint64_t v8 = (char *)&v18 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v9 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState(0);
  __chkstk_darwin(v9, v10);
  uint64_t v12 = (char *)&v18 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_1004323D4(v0, (uint64_t)v12, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
  int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
  if (EnumCaseMultiPayload)
  {
    if (EnumCaseMultiPayload != 1) {
      return 0x79656B206F6ELL;
    }
    sub_10043243C((uint64_t)v12, (uint64_t)v4, type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey);
    uint64_t v18 = 0;
    unint64_t v19 = 0xE000000000000000;
    sub_1007269F0(29);
    v20._countAndFlagsBits = 0x7379656B206F7774;
    v20._xpc_object_t object = (void *)0xEF20666F20736120;
    sub_1007264C0(v20);
    sub_100725C30();
    sub_100726620();
    v21._countAndFlagsBits = 0x73646E6F63657320;
    v21._xpc_object_t object = (void *)0xEC0000006F676120;
    sub_1007264C0(v21);
    uint64_t v14 = v18;
    uint64_t v15 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey;
    uint64_t v16 = (uint64_t)v4;
  }
  else
  {
    sub_10043243C((uint64_t)v12, (uint64_t)v8, type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey);
    uint64_t v18 = 0;
    unint64_t v19 = 0xE000000000000000;
    sub_1007269F0(28);
    v22._countAndFlagsBits = 0x2079656B20656E6FLL;
    v22._xpc_object_t object = (void *)0xEE0020666F207361;
    sub_1007264C0(v22);
    sub_100725C30();
    sub_100726620();
    v23._countAndFlagsBits = 0x73646E6F63657320;
    v23._xpc_object_t object = (void *)0xEC0000006F676120;
    sub_1007264C0(v23);
    uint64_t v14 = v18;
    uint64_t v15 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey;
    uint64_t v16 = (uint64_t)v8;
  }
  sub_1004324A4(v16, v15);
  return v14;
}

uint64_t sub_100432AA4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 40))(a2, a1, v4);
  return a2;
}

uint64_t type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(uint64_t a1)
{
  return sub_100440FD0(a1, qword_100A4CC50);
}

uint64_t sub_100432B28@<X0>(uint64_t a1@<X8>)
{
  type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState(0);
  swift_storeEnumTagMultiPayload();
  uint64_t v2 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0);
  uint64_t v3 = a1 + v2[5];
  *(void *)uint64_t v3 = 0;
  *(void *)(v3 + _Block_object_dispose(&STACK[0x320], 8) = 0;
  *(unsigned char *)(v3 + 16) = 1;
  *(unsigned char *)(a1 + v2[6]) = 0;
  *(void *)(a1 + v2[7] + _Block_object_dispose(&STACK[0x320], 8) = 0;
  swift_unknownObjectWeakInit();
  *(void *)(a1 + v2[8]) = 0;
  uint64_t v4 = v2[9];
  if (((unint64_t)_swiftEmptyArrayStorage & 0xC000000000000000) != 0)
  {
    if (sub_100726BA0())
    {
      sub_100440398((unint64_t)_swiftEmptyArrayStorage);
      *(void *)(a1 + v4) = v7;
    }
    else
    {
      uint64_t v5 = &_swiftEmptySetSingleton;
      *(void *)(a1 + v4) = &_swiftEmptySetSingleton;
      if (((unint64_t)_swiftEmptyArrayStorage & 0xC000000000000000) == 0) {
        goto LABEL_3;
      }
    }
    if (sub_100726BA0()) {
      sub_100440398((unint64_t)_swiftEmptyArrayStorage);
    }
    else {
      uint64_t v5 = &_swiftEmptySetSingleton;
    }
  }
  else
  {
    uint64_t v5 = &_swiftEmptySetSingleton;
    *(void *)(a1 + v4) = &_swiftEmptySetSingleton;
  }
LABEL_3:
  *(void *)(a1 + v2[10]) = v5;
  *(void *)(a1 + v2[11]) = 0;
  *(unsigned char *)(a1 + v2[12]) = 0;
  *(void *)(a1 + v2[13]) = _swiftEmptyArrayStorage;
  uint64_t result = sub_100725C40();
  *(void *)(a1 + v2[15]) = 1;
  return result;
}

uint64_t sub_100432C78()
{
  uint64_t v1 = *(void *)(v0 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state);
  uint64_t v2 = v1 + *(void *)(class metadata base offset for ManagedBuffer + *(void *)v1 + 16);
  uint64_t v3 = (os_unfair_lock_s *)(v1 + ((*(unsigned int *)(*(void *)v1 + 48) + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v3);
  sub_100432D24(v2, &v5);
  os_unfair_lock_unlock(v3);
  return v5;
}

uint64_t sub_100432D24@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3 = a1 + *(int *)(type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0) + 28);
  uint64_t result = swift_unknownObjectWeakLoadStrong();
  uint64_t v5 = *(void *)(v3 + 8);
  *a2 = result;
  a2[1] = v5;
  return result;
}

void sub_100432D78(void *a1)
{
  uint64_t v3 = *(void *)(v1 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state);
  uint64_t v4 = v3 + *(void *)(class metadata base offset for ManagedBuffer + *(void *)v3 + 16);
  uint64_t v5 = (os_unfair_lock_s *)(v3 + ((*(unsigned int *)(*(void *)v3 + 48) + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v5);
  sub_1004406F0(v4);
  os_unfair_lock_unlock(v5);
}

void (*sub_100432E28(void *a1))(id **a1, char a2)
{
  uint64_t v3 = malloc(0x30uLL);
  uint64_t v4 = *(uint64_t **)(v1 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state);
  *a1 = v3;
  v3[2] = v4;
  uint64_t v5 = *v4;
  uint64_t v6 = *(void *)(class metadata base offset for ManagedBuffer + *v4 + 16);
  void v3[3] = v6;
  uint64_t v7 = (uint64_t)v4 + v6;
  uint64_t v8 = *(unsigned int *)(v5 + 48);
  *((_DWORD *)v3 + 10) = v8;
  uint64_t v9 = (os_unfair_lock_s *)((char *)v4 + ((v8 + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v9);
  sub_100432D24(v7, v11);
  void v3[4] = 0;
  os_unfair_lock_unlock(v9);
  *(_OWORD *)uint64_t v3 = *(_OWORD *)v11;
  return sub_100432F20;
}

void sub_100432F20(id **a1, char a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = (char *)(*a1)[2];
  uint64_t v4 = (*((unsigned int *)*a1 + 10) + 3) & 0x1FFFFFFFCLL;
  uint64_t v5 = (os_unfair_lock_s *)&v3[v4];
  uint64_t v6 = (uint64_t)(*a1)[3] + (void)v3;
  if (a2)
  {
    id v7 = **a1;
    os_unfair_lock_lock(v5);
    sub_1004406F0(v6);
    os_unfair_lock_unlock(v5);
  }
  else
  {
    long long v8 = *(_OWORD *)*a1;
    os_unfair_lock_lock((os_unfair_lock_t)&v3[v4]);
    sub_1004406F0(v6);
    os_unfair_lock_unlock(v5);
  }
  free(v2);
}

uint64_t sub_100433000()
{
  uint64_t v1 = (unsigned __int8 *)(v0
                         + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_shortKIEnabled);
  swift_beginAccess();
  return *v1;
}

uint64_t sub_100433048(char a1)
{
  uint64_t v3 = (unsigned char *)(v1 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_shortKIEnabled);
  uint64_t result = swift_beginAccess();
  *uint64_t v3 = a1;
  return result;
}

uint64_t (*sub_100433094())()
{
  return j__swift_endAccess;
}

unint64_t sub_1004330F4()
{
  uint64_t v1 = *(void *)(v0 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state);
  uint64_t v2 = v1 + *(void *)(class metadata base offset for ManagedBuffer + *(void *)v1 + 16);
  uint64_t v3 = (os_unfair_lock_s *)(v1 + ((*(unsigned int *)(*(void *)v1 + 48) + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v3);
  sub_1004331A4(v2, &v5);
  os_unfair_lock_unlock(v3);
  return v5.n128_u64[0];
}

__n128 sub_1004331A4@<Q0>(uint64_t a1@<X0>, __n128 *a2@<X8>)
{
  uint64_t v3 = (__n128 *)(a1 + *(int *)(type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0) + 20));
  unsigned __int8 v4 = v3[1].n128_u8[0];
  __n128 result = *v3;
  *a2 = *v3;
  a2[1].n128_u8[0] = v4;
  return result;
}

void sub_1004331F8()
{
  uint64_t v1 = *(void *)(v0 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state);
  uint64_t v2 = v1 + *(void *)(class metadata base offset for ManagedBuffer + *(void *)v1 + 16);
  uint64_t v3 = (os_unfair_lock_s *)(v1 + ((*(unsigned int *)(*(void *)v1 + 48) + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v3);
  sub_100440844(v2);
  os_unfair_lock_unlock(v3);
}

void (*sub_1004332AC(__n128 **a1))(uint64_t *a1)
{
  uint64_t v3 = (__n128 *)malloc(0x38uLL);
  *a1 = v3;
  unsigned __int8 v4 = *(uint64_t **)(v1 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state);
  v3[1].n128_u64[1] = v1;
  v3[2].n128_u64[0] = (unint64_t)v4;
  uint64_t v5 = *v4;
  unint64_t v6 = *(void *)(class metadata base offset for ManagedBuffer + *v4 + 16);
  v3[2].n128_u64[1] = v6;
  uint64_t v7 = (uint64_t)v4 + v6;
  uint64_t v8 = *(unsigned int *)(v5 + 48);
  v3[1].n128_u32[1] = v8;
  uint64_t v9 = (os_unfair_lock_s *)((char *)v4 + ((v8 + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v9);
  sub_1004331A4(v7, &v12);
  v3[3].n128_u64[0] = 0;
  os_unfair_lock_unlock(v9);
  unsigned __int8 v10 = v13;
  *uint64_t v3 = v12;
  v3[1].n128_u8[0] = v10;
  return sub_1004333AC;
}

void sub_1004333AC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(*a1 + 32) + ((*(unsigned int *)(*a1 + 20) + 3) & 0x1FFFFFFFCLL)));
  uint64_t v2 = *(unsigned int *)(v1 + 20);
  uint64_t v3 = *(void *)(v1 + 32);
  sub_100440844(v3 + *(void *)(v1 + 40));
  os_unfair_lock_unlock((os_unfair_lock_t)(v3 + ((v2 + 3) & 0x1FFFFFFFCLL)));
  free((void *)v1);
}

uint64_t sub_10043345C()
{
  uint64_t v1 = *(void *)(v0 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state);
  uint64_t v2 = v1 + *(void *)(class metadata base offset for ManagedBuffer + *(void *)v1 + 16);
  uint64_t v3 = (os_unfair_lock_s *)(v1 + ((*(unsigned int *)(*(void *)v1 + 48) + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v3);
  sub_100433508(v2, &v5);
  os_unfair_lock_unlock(v3);
  return v5;
}

uint64_t sub_100433508@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t result = type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0);
  *a2 = *(unsigned char *)(a1 + *(int *)(result + 24));
  return result;
}

void sub_100433550()
{
  uint64_t v1 = *(void *)(v0 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state);
  uint64_t v2 = v1 + *(void *)(class metadata base offset for ManagedBuffer + *(void *)v1 + 16);
  uint64_t v3 = (os_unfair_lock_s *)(v1 + ((*(unsigned int *)(*(void *)v1 + 48) + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v3);
  sub_1004408C0(v2);
  os_unfair_lock_unlock(v3);
}

void (*sub_100433600(void *a1))(uint64_t *a1)
{
  uint64_t v3 = malloc(0x28uLL);
  *a1 = v3;
  unsigned __int8 v4 = *(uint64_t **)(v1 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state);
  *uint64_t v3 = v1;
  v3[1] = v4;
  uint64_t v5 = *v4;
  uint64_t v6 = *(void *)(class metadata base offset for ManagedBuffer + *v4 + 16);
  v3[2] = v6;
  uint64_t v7 = (uint64_t)v4 + v6;
  uint64_t v8 = *(unsigned int *)(v5 + 48);
  *((_DWORD *)v3 + _Block_object_dispose(&STACK[0x320], 8) = v8;
  uint64_t v9 = (os_unfair_lock_s *)((char *)v4 + ((v8 + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v9);
  sub_100433508(v7, v11);
  void v3[3] = 0;
  os_unfair_lock_unlock(v9);
  *((unsigned char *)v3 + 36) = v11[0];
  return sub_1004336F8;
}

void sub_1004336F8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(*a1 + 8) + ((*(unsigned int *)(*a1 + 32) + 3) & 0x1FFFFFFFCLL)));
  uint64_t v2 = *(unsigned int *)(v1 + 32);
  uint64_t v3 = *(void *)(v1 + 8);
  sub_1004408C0(v3 + *(void *)(v1 + 16));
  os_unfair_lock_unlock((os_unfair_lock_t)(v3 + ((v2 + 3) & 0x1FFFFFFFCLL)));
  free((void *)v1);
}

uint64_t sub_1004337A0()
{
  uint64_t v1 = *(void *)(v0 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state);
  uint64_t v2 = v1 + *(void *)(class metadata base offset for ManagedBuffer + *(void *)v1 + 16);
  uint64_t v3 = (os_unfair_lock_s *)(v1 + ((*(unsigned int *)(*(void *)v1 + 48) + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v3);
  sub_10043384C(v2, &v5);
  os_unfair_lock_unlock(v3);
  return v5;
}

uint64_t sub_10043384C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0);
  *a2 = *(void *)(a1 + *(int *)(result + 32));
  return result;
}

void sub_100433894()
{
  uint64_t v1 = *(void *)(v0 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state);
  uint64_t v2 = v1 + *(void *)(class metadata base offset for ManagedBuffer + *(void *)v1 + 16);
  uint64_t v3 = (os_unfair_lock_s *)(v1 + ((*(unsigned int *)(*(void *)v1 + 48) + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v3);
  sub_100440928(v2);
  os_unfair_lock_unlock(v3);
}

uint64_t sub_10043393C(uint64_t a1, uint64_t a2, void *a3)
{
  id v46 = a3;
  uint64_t v5 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey(0);
  __chkstk_darwin(v5, v6);
  uint64_t v8 = (char *)&v46 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v9 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(0);
  __chkstk_darwin(v9, v10);
  __n128 v12 = (char *)&v46 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState(0);
  uint64_t v15 = __chkstk_darwin(v13, v14);
  uint64_t v17 = (char *)&v46 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v15, v18);
  Swift::String v20 = (char *)&v46 - v19;
  uint64_t v21 = *(int *)(type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0) + 32);
  uint64_t v22 = *(void *)(a1 + v21);
  if (v22) {
    BOOL v23 = v22 == a2;
  }
  else {
    BOOL v23 = 1;
  }
  int v24 = !v23;
  int v47 = v24;
  *(void *)(a1 + v21) = a2;
  sub_1004323D4(a1, (uint64_t)v20, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
  uint64_t result = swift_getEnumCaseMultiPayload();
  if (result)
  {
    if (result != 1) {
      goto LABEL_12;
    }
    sub_1004324A4(a1, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
    sub_10043243C((uint64_t)v20, (uint64_t)v8, type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey);
    uint64_t v26 = v5[5];
    uint64_t v27 = &v17[v26];
    sub_1004323D4((uint64_t)&v8[v26], (uint64_t)&v17[v26], (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    uint64_t v28 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
    id v29 = &v27[*(int *)(v28 + 52)];
    *(void *)id v29 = a2;
    v29[8] = 0;
    uint64_t v30 = v5[6];
    __int16 v31 = &v17[v30];
    sub_1004323D4((uint64_t)&v8[v30], (uint64_t)&v17[v30], (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    __int16 v32 = &v31[*(int *)(v28 + 52)];
    *(void *)__int16 v32 = a2;
    v32[8] = 0;
    sub_100431F18((uint64_t)v8, (uint64_t)v17);
    uint64_t v33 = v5[7];
    id v34 = &v8[v33];
    long long v35 = &v17[v33];
    uint64_t v36 = sub_100725CC0();
    (*(void (**)(char *, char *, uint64_t))(*(void *)(v36 - 8) + 16))(v35, v34, v36);
    id v37 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey;
    uint64_t v38 = (uint64_t)v8;
  }
  else
  {
    sub_1004324A4(a1, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
    sub_10043243C((uint64_t)v20, (uint64_t)v12, type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey);
    uint64_t v39 = *(int *)(v9 + 20);
    id v40 = &v17[v39];
    sub_1004323D4((uint64_t)&v12[v39], (uint64_t)&v17[v39], (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    uint64_t v41 = &v40[*(int *)(type metadata accessor for IDSGroupEncryptionKeyMaterialContent() + 52)];
    *(void *)uint64_t v41 = a2;
    v41[8] = 0;
    sub_100431F18((uint64_t)v12, (uint64_t)v17);
    uint64_t v42 = *(int *)(v9 + 24);
    id v43 = &v12[v42];
    uint64_t v44 = &v17[v42];
    uint64_t v45 = sub_100725CC0();
    (*(void (**)(char *, char *, uint64_t))(*(void *)(v45 - 8) + 16))(v44, v43, v45);
    id v37 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey;
    uint64_t v38 = (uint64_t)v12;
  }
  sub_1004324A4(v38, v37);
  swift_storeEnumTagMultiPayload();
  uint64_t result = sub_10043243C((uint64_t)v17, a1, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
LABEL_12:
  if (v47) {
    return (*(uint64_t (**)(uint64_t))((swift_isaMask & *v46) + 0x188))(a1);
  }
  return result;
}

void (*sub_100433D74(void *a1))(uint64_t *a1)
{
  uint64_t v3 = malloc(0x30uLL);
  *a1 = v3;
  unsigned __int8 v4 = *(uint64_t **)(v1 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state);
  v3[1] = v1;
  v3[2] = v4;
  uint64_t v5 = *v4;
  uint64_t v6 = *(void *)(class metadata base offset for ManagedBuffer + *v4 + 16);
  void v3[3] = v6;
  uint64_t v7 = (uint64_t)v4 + v6;
  uint64_t v8 = *(unsigned int *)(v5 + 48);
  *((_DWORD *)v3 + 10) = v8;
  uint64_t v9 = (os_unfair_lock_s *)((char *)v4 + ((v8 + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v9);
  sub_10043384C(v7, &v11);
  void v3[4] = 0;
  os_unfair_lock_unlock(v9);
  *uint64_t v3 = v11;
  return sub_100433E6C;
}

void sub_100433E6C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(*a1 + 16) + ((*(unsigned int *)(*a1 + 40) + 3) & 0x1FFFFFFFCLL)));
  uint64_t v2 = *(unsigned int *)(v1 + 40);
  uint64_t v3 = *(void *)(v1 + 16);
  sub_10044C800(v3 + *(void *)(v1 + 24));
  os_unfair_lock_unlock((os_unfair_lock_t)(v3 + ((v2 + 3) & 0x1FFFFFFFCLL)));
  free((void *)v1);
}

void sub_100433F10(uint64_t a1@<X8>)
{
  uint64_t v3 = *(void *)(v1 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state);
  uint64_t v4 = v3 + *(void *)(class metadata base offset for ManagedBuffer + *(void *)v3 + 16);
  uint64_t v5 = (os_unfair_lock_s *)(v3 + ((*(unsigned int *)(*(void *)v3 + 48) + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v5);
  sub_100433FC8(v4, a1);

  os_unfair_lock_unlock(v5);
}

uint64_t sub_100433FC8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey(0);
  __chkstk_darwin(v4 - 8, v5);
  uint64_t v7 = (char *)v21 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(0);
  __chkstk_darwin(v8 - 8, v9);
  uint64_t v11 = (char *)v21 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState(0);
  __chkstk_darwin(v12, v13);
  uint64_t v15 = (char *)v21 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_1004323D4(a1, (uint64_t)v15, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
  int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
  if (!EnumCaseMultiPayload)
  {
    sub_10043243C((uint64_t)v15, (uint64_t)v11, type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey);
    sub_100431F18((uint64_t)v11, a2);
    uint64_t v17 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey;
    uint64_t v18 = (uint64_t)v11;
    return sub_1004324A4(v18, v17);
  }
  if (EnumCaseMultiPayload == 1)
  {
    sub_10043243C((uint64_t)v15, (uint64_t)v7, type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey);
    sub_100431F18((uint64_t)v7, a2);
    uint64_t v17 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey;
    uint64_t v18 = (uint64_t)v7;
    return sub_1004324A4(v18, v17);
  }
  uint64_t v20 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v20 - 8) + 56))(a2, 1, 1, v20);
}

void sub_1004341F0(uint64_t a1@<X8>)
{
  uint64_t v3 = *(void *)(v1 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state);
  uint64_t v4 = v3 + *(void *)(class metadata base offset for ManagedBuffer + *(void *)v3 + 16);
  uint64_t v5 = (os_unfair_lock_s *)(v3 + ((*(unsigned int *)(*(void *)v3 + 48) + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v5);
  sub_1004342A8(v4, a1);

  os_unfair_lock_unlock(v5);
}

uint64_t sub_1004342A8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey(0);
  __chkstk_darwin(v4, v5);
  uint64_t v7 = (char *)v22 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(0);
  __chkstk_darwin(v8, v9);
  uint64_t v11 = (char *)v22 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState(0);
  __chkstk_darwin(v12, v13);
  uint64_t v15 = (char *)v22 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_1004323D4(a1, (uint64_t)v15, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
  int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
  if (!EnumCaseMultiPayload)
  {
    sub_10043243C((uint64_t)v15, (uint64_t)v11, type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey);
    sub_1004323D4((uint64_t)&v11[*(int *)(v8 + 20)], a2, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    uint64_t v17 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey;
    uint64_t v18 = (uint64_t)v11;
    goto LABEL_5;
  }
  if (EnumCaseMultiPayload == 1)
  {
    sub_10043243C((uint64_t)v15, (uint64_t)v7, type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey);
    sub_1004323D4((uint64_t)&v7[*(int *)(v4 + 20)], a2, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    uint64_t v17 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey;
    uint64_t v18 = (uint64_t)v7;
LABEL_5:
    sub_1004324A4(v18, v17);
    uint64_t v19 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v19 - 8) + 56))(a2, 0, 1, v19);
  }
  uint64_t v21 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v21 - 8) + 56))(a2, 1, 1, v21);
}

void sub_100434548(uint64_t a1@<X8>)
{
  uint64_t v3 = *(void *)(v1 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state);
  uint64_t v4 = v3 + *(void *)(class metadata base offset for ManagedBuffer + *(void *)v3 + 16);
  uint64_t v5 = (os_unfair_lock_s *)(v3 + ((*(unsigned int *)(*(void *)v3 + 48) + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v5);
  sub_100434600(v4, a1);

  os_unfair_lock_unlock(v5);
}

uint64_t sub_100434600@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey(0);
  __chkstk_darwin(v4, v5);
  uint64_t v7 = (char *)v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState(0);
  __chkstk_darwin(v8, v9);
  uint64_t v11 = (char *)v17 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_1004323D4(a1, (uint64_t)v11, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
  int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
  if (EnumCaseMultiPayload)
  {
    if (EnumCaseMultiPayload == 1)
    {
      sub_10043243C((uint64_t)v11, (uint64_t)v7, type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey);
      sub_1004323D4((uint64_t)&v7[*(int *)(v4 + 24)], a2, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
      sub_1004324A4((uint64_t)v7, type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey);
      uint64_t v13 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
      return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v13 - 8) + 56))(a2, 0, 1, v13);
    }
    else
    {
      uint64_t v16 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v16 - 8) + 56))(a2, 1, 1, v16);
    }
  }
  else
  {
    uint64_t v15 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v15 - 8) + 56))(a2, 1, 1, v15);
    return sub_1004324A4((uint64_t)v11, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
  }
}

uint64_t sub_10043484C()
{
  uint64_t v1 = *(void *)(v0 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state);
  uint64_t v2 = v1 + *(void *)(class metadata base offset for ManagedBuffer + *(void *)v1 + 16);
  uint64_t v3 = (os_unfair_lock_s *)(v1 + ((*(unsigned int *)(*(void *)v1 + 48) + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v3);
  sub_1004348F8(v2, &v5);
  os_unfair_lock_unlock(v3);
  return v5;
}

uint64_t sub_1004348F8@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0);
  *a2 = *(void *)(a1 + *(int *)(result + 60));
  return result;
}

id sub_100434940(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, char a8, char a9, char a10, char a11, char a12)
{
  int v17 = a8 & 1;
  id v18 = objc_allocWithZone(v12);
  id v19 = sub_100440954((uint64_t)a1, a2, a3, a4, a5, a6, a7, v17, a9 & 1, a10, a11, a12);

  return v19;
}

id sub_1004349FC()
{
  uint64_t v1 = v0;
  uint64_t v2 = *(void *)&v0[OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state];
  uint64_t v3 = v2 + *(void *)(class metadata base offset for ManagedBuffer + *(void *)v2 + 16);
  uint64_t v4 = (os_unfair_lock_s *)(v2 + ((*(unsigned int *)(*(void *)v2 + 48) + 3) & 0x1FFFFFFFCLL));
  swift_retain();
  os_unfair_lock_lock(v4);
  sub_100434AD8(v3);
  os_unfair_lock_unlock(v4);
  swift_release();
  v6.receiver = v1;
  v6.super_class = (Class)type metadata accessor for IDSGroupEncryptionKeyMaterialController(0);
  return objc_msgSendSuper2(&v6, "dealloc");
}

uint64_t sub_100434AD8(uint64_t a1)
{
  uint64_t result = type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0);
  uint64_t v3 = *(int *)(result + 44);
  if (*(void *)(a1 + v3))
  {
    swift_retain();
    sub_100725F70();
    uint64_t result = swift_release_n();
    *(void *)(a1 + v3) = 0;
  }
  return result;
}

void sub_100434CDC(uint64_t a1)
{
  uint64_t v60 = sub_100725EE0();
  uint64_t v58 = *(void *)(v60 - 8);
  __chkstk_darwin(v60, v2);
  uint64_t v57 = (os_log_t *)((char *)&v52 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v61 = sub_100725F50();
  uint64_t v59 = *(void *)(v61 - 8);
  uint64_t v5 = __chkstk_darwin(v61, v4);
  uint64_t v62 = (char *)&v52 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v5, v7);
  __int16 v56 = (char *)&v52 - v8;
  uint64_t v9 = sub_100725EF0();
  __chkstk_darwin(v9, v10);
  uint64_t v11 = sub_100431F80(&qword_100A47D80);
  __chkstk_darwin(v11 - 8, v12);
  uint64_t v14 = (char *)&v52 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = sub_100725CC0();
  uint64_t v64 = *(void *)(v15 - 8);
  uint64_t v17 = __chkstk_darwin(v15, v16);
  id v19 = (char *)&v52 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v17, v20);
  id v63 = (char *)&v52 - v21;
  uint64_t v22 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0);
  uint64_t v23 = v22[11];
  if (*(void *)(a1 + v23))
  {
    swift_retain();
    sub_100725F70();
    swift_release_n();
    *(void *)(a1 + v23) = 0;
  }
  uint64_t v24 = a1 + v22[7];
  uint64_t Strong = swift_unknownObjectWeakLoadStrong();
  if (Strong)
  {
    uint64_t v26 = (void *)Strong;
    uint64_t v27 = *(void *)(v24 + 8);
    uint64_t ObjectType = swift_getObjectType();
    LOBYTE(v27) = (*(uint64_t (**)(uint64_t, uint64_t))(v27 + 8))(ObjectType, v27);

    if (v27)
    {
      sub_10043206C(*(void *)(a1 + v22[5] + 8), *(unsigned char *)(a1 + v22[5] + 16), (uint64_t)v14);
      uint64_t v29 = v64;
      if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v64 + 48))(v14, 1, v15) == 1)
      {
        sub_10044C150((uint64_t)v14, &qword_100A47D80);
        return;
      }
      uint64_t v33 = v63;
      (*(void (**)(char *, char *, uint64_t))(v29 + 32))(v63, v14, v15);
      (*(void (**)(char *, char *, uint64_t))(v29 + 16))(v19, v33, v15);
      id v34 = sub_100725EB0();
      os_log_type_t v35 = sub_1007266E0();
      int v36 = v35;
      if (os_log_type_enabled(v34, v35))
      {
        uint64_t v37 = swift_slowAlloc();
        int v53 = v36;
        uint64_t v38 = v37;
        uint64_t v54 = swift_slowAlloc();
        aBlock[0] = v54;
        *(_DWORD *)uint64_t v38 = 136315394;
        os_log_t v52 = v34;
        long long v67 = (void *)sub_10043E578(0xD00000000000001ELL, 0x80000001008C0820, aBlock);
        sub_100726830();
        *(_WORD *)(v38 + 12) = 2048;
        sub_100725C30();
        long long v67 = v39;
        sub_100726830();
        id v55 = *(void (**)(char *, uint64_t))(v64 + 8);
        v55(v19, v15);
        os_log_t v40 = v52;
        _os_log_impl((void *)&_mh_execute_header, v52, (os_log_type_t)v53, "%s: scheduling roll task after %f seconds", (uint8_t *)v38, 0x16u);
        swift_arrayDestroy();
        swift_slowDealloc();
        swift_slowDealloc();
      }
      else
      {

        id v55 = *(void (**)(char *, uint64_t))(v29 + 8);
        v55(v19, v15);
      }
      uint64_t v41 = swift_allocObject();
      swift_unknownObjectWeakInit();
      aBlock[4] = (uint64_t)sub_10044C288;
      aBlock[5] = v41;
      aBlock[0] = (uint64_t)_NSConcreteStackBlock;
      aBlock[1] = 1107296256;
      aBlock[2] = (uint64_t)sub_100435714;
      aBlock[3] = (uint64_t)&unk_10098DA20;
      _Block_copy(aBlock);
      long long v67 = &_swiftEmptyArrayStorage;
      sub_10044C1AC((unint64_t *)&unk_100A46890, (void (*)(uint64_t))&type metadata accessor for DispatchWorkItemFlags);
      swift_retain();
      sub_100431F80((uint64_t *)&unk_100A454C0);
      sub_1004413A8((unint64_t *)&qword_100A468A0, (uint64_t *)&unk_100A454C0);
      sub_100726890();
      sub_100725F80();
      swift_allocObject();
      uint64_t v42 = sub_100725F60();
      swift_release();
      swift_release();
      swift_retain();
      swift_release();
      *(void *)(a1 + v23) = v42;
      id v43 = v62;
      sub_100725F30();
      sub_100725C30();
      double v45 = v44 * 1000.0;
      if ((~*(void *)&v45 & 0x7FF0000000000000) != 0)
      {
        if (v45 > -9.22337204e18)
        {
          if (v45 < 9.22337204e18)
          {
            int v47 = v57;
            uint64_t v46 = v58;
            void *v57 = (uint64_t)v45;
            uint64_t v48 = v60;
            (*(void (**)(void *, void, uint64_t))(v46 + 104))(v47, enum case for DispatchTimeInterval.milliseconds(_:), v60);
            long long v49 = v56;
            sub_100725F40();
            (*(void (**)(void *, uint64_t))(v46 + 8))(v47, v48);
            id v50 = *(void (**)(char *, uint64_t))(v59 + 8);
            uint64_t v51 = v61;
            v50(v43, v61);
            sub_100726720();
            swift_release();
            v50(v49, v51);
            v55(v63, v15);
            return;
          }
LABEL_22:
          __break(1u);
          return;
        }
      }
      else
      {
        __break(1u);
      }
      __break(1u);
      goto LABEL_22;
    }
  }
  id v65 = sub_100725EB0();
  os_log_type_t v30 = sub_1007266E0();
  if (os_log_type_enabled(v65, v30))
  {
    __int16 v31 = (uint8_t *)swift_slowAlloc();
    aBlock[0] = swift_slowAlloc();
    *(_DWORD *)__int16 v31 = 136315138;
    long long v67 = (void *)sub_10043E578(0xD00000000000001ELL, 0x80000001008C0820, aBlock);
    sub_100726830();
    _os_log_impl((void *)&_mh_execute_header, v65, v30, "%s: not scheduling roll task: session is not active", v31, 0xCu);
    swift_arrayDestroy();
    swift_slowDealloc();
    swift_slowDealloc();
  }
  else
  {
    __int16 v32 = v65;
  }
}

void sub_100435604()
{
  swift_beginAccess();
  uint64_t Strong = swift_unknownObjectWeakLoadStrong();
  if (Strong)
  {
    uint64_t v2 = (void *)Strong;
    uint64_t v3 = *(void *)(Strong + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state);
    __chkstk_darwin(Strong, v1);
    uint64_t v4 = v3 + *(void *)(class metadata base offset for ManagedBuffer + *(void *)v3 + 16);
    uint64_t v5 = (os_unfair_lock_s *)(v3 + ((*(unsigned int *)(*(void *)v3 + 48) + 3) & 0x1FFFFFFFCLL));
    swift_retain();
    os_unfair_lock_lock(v5);
    sub_10044C290(v4);
    os_unfair_lock_unlock(v5);
    swift_release();
  }
}

void sub_100435718()
{
  swift_bridgeObjectRetain_n();
  uint64_t v0 = sub_100725EB0();
  os_log_type_t v1 = sub_1007266E0();
  if (os_log_type_enabled(v0, v1))
  {
    uint64_t v2 = swift_slowAlloc();
    v11[0] = swift_slowAlloc();
    *(_DWORD *)uint64_t v2 = 136315394;
    sub_10043E578(0xD000000000000017, 0x80000001008C0670, v11);
    sub_100726830();
    *(_WORD *)(v2 + 12) = 2080;
    type metadata accessor for IDSGroupEncryptionControllerMember();
    sub_10044C1AC((unint64_t *)&qword_100A44A78, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionControllerMember);
    swift_bridgeObjectRetain();
    uint64_t v3 = sub_100726650();
    unint64_t v5 = v4;
    swift_bridgeObjectRelease();
    sub_10043E578(v3, v5, v11);
    sub_100726830();
    swift_bridgeObjectRelease_n();
    swift_bridgeObjectRelease();
    _os_log_impl((void *)&_mh_execute_header, v0, v1, "%s: %s", (uint8_t *)v2, 0x16u);
    swift_arrayDestroy();
    swift_slowDealloc();
    swift_slowDealloc();
  }
  else
  {
    swift_bridgeObjectRelease_n();
  }

  __chkstk_darwin(v6, v7);
  uint64_t v9 = v8 + *(void *)(class metadata base offset for ManagedBuffer + *(void *)v8 + 16);
  uint64_t v10 = (os_unfair_lock_s *)(v8 + ((*(unsigned int *)(*(void *)v8 + 48) + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v10);
  sub_100441008(v9);
  os_unfair_lock_unlock(v10);
}

uint64_t sub_1004359C4(uint64_t a1)
{
  uint64_t v2 = v1;
  uint64_t v4 = sub_100725EF0();
  uint64_t v5 = *(void *)(v4 - 8);
  __chkstk_darwin(v4, v6);
  uint64_t v27 = (char *)&v23 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = sub_100725F20();
  uint64_t v26 = *(void *)(v8 - 8);
  __chkstk_darwin(v8, v9);
  uint64_t v11 = (char *)&v23 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = sub_100725EB0();
  os_log_type_t v13 = sub_1007266E0();
  if (os_log_type_enabled(v12, v13))
  {
    uint64_t v14 = swift_slowAlloc();
    uint64_t v24 = v2;
    uint64_t v15 = (uint8_t *)v14;
    uint64_t v16 = swift_slowAlloc();
    uint64_t v25 = v8;
    aBlock[0] = v16;
    *(_DWORD *)uint64_t v15 = 136315138;
    uint64_t v28 = (void *)sub_10043E578(0xD000000000000012, 0x80000001008C07C0, aBlock);
    sub_100726830();
    _os_log_impl((void *)&_mh_execute_header, v12, v13, "%s", v15, 0xCu);
    swift_arrayDestroy();
    uint64_t v8 = v25;
    swift_slowDealloc();
    uint64_t v2 = v24;
    swift_slowDealloc();
  }

  uint64_t result = type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0);
  uint64_t v18 = *(int *)(result + 48);
  if ((*(unsigned char *)(a1 + v18) & 1) == 0)
  {
    *(unsigned char *)(a1 + v1_Block_object_dispose(&STACK[0x320], 8) = 1;
    uint64_t v19 = swift_allocObject();
    *(void *)(v19 + 16) = v2;
    aBlock[4] = (uint64_t)sub_10044BF54;
    aBlock[5] = v19;
    aBlock[0] = (uint64_t)_NSConcreteStackBlock;
    aBlock[1] = 1107296256;
    aBlock[2] = (uint64_t)sub_100435714;
    aBlock[3] = (uint64_t)&unk_10098D890;
    uint64_t v20 = _Block_copy(aBlock);
    id v21 = v2;
    sub_100725F00();
    uint64_t v28 = &_swiftEmptyArrayStorage;
    sub_10044C1AC((unint64_t *)&unk_100A46890, (void (*)(uint64_t))&type metadata accessor for DispatchWorkItemFlags);
    sub_100431F80((uint64_t *)&unk_100A454C0);
    sub_1004413A8((unint64_t *)&qword_100A468A0, (uint64_t *)&unk_100A454C0);
    uint64_t v22 = v27;
    sub_100726890();
    sub_100726750();
    _Block_release(v20);
    (*(void (**)(char *, uint64_t))(v5 + 8))(v22, v4);
    (*(void (**)(char *, uint64_t))(v26 + 8))(v11, v8);
    return swift_release();
  }
  return result;
}

uint64_t sub_100435DD0(uint64_t a1)
{
  os_log_type_t v1 = *(void (**)(uint64_t))(a1 + 32);
  uint64_t v2 = swift_retain();
  v1(v2);

  return swift_release();
}

uint64_t sub_100435E14(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = sub_100725EF0();
  uint64_t v6 = *(void *)(v5 - 8);
  __chkstk_darwin(v5, v7);
  uint64_t v9 = (char *)v19 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = sub_100725F20();
  uint64_t v11 = *(void *)(v10 - 8);
  __chkstk_darwin(v10, v12);
  uint64_t v14 = (char *)v19 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v19[0] = *(void *)&v2[OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_q];
  uint64_t v15 = (void *)swift_allocObject();
  void v15[2] = v2;
  v15[3] = a1;
  void v15[4] = a2;
  aBlock[4] = sub_1004412E0;
  aBlock[5] = v15;
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 1107296256;
  aBlock[2] = sub_100435714;
  aBlock[3] = &unk_10098D578;
  uint64_t v16 = _Block_copy(aBlock);
  uint64_t v17 = v2;
  swift_retain();
  sub_100725F00();
  v19[1] = &_swiftEmptyArrayStorage;
  sub_10044C1AC((unint64_t *)&unk_100A46890, (void (*)(uint64_t))&type metadata accessor for DispatchWorkItemFlags);
  sub_100431F80((uint64_t *)&unk_100A454C0);
  sub_1004413A8((unint64_t *)&qword_100A468A0, (uint64_t *)&unk_100A454C0);
  sub_100726890();
  sub_100726750();
  _Block_release(v16);
  (*(void (**)(char *, uint64_t))(v6 + 8))(v9, v5);
  (*(void (**)(char *, uint64_t))(v11 + 8))(v14, v10);
  return swift_release();
}

uint64_t sub_1004360D4()
{
  *(void *)(v1 + 16) = v0;
  return _swift_task_switch(sub_1004360F4, 0, 0);
}

uint64_t sub_1004360F4()
{
  uint64_t v1 = v0[2];
  uint64_t v2 = swift_task_alloc();
  v0[3] = v2;
  *(void *)(v2 + 16) = v1;
  uint64_t v3 = (void *)swift_task_alloc();
  v0[4] = v3;
  *uint64_t v3 = v0;
  v3[1] = sub_1004361E8;
  return withCheckedContinuation<A>(isolation:function:_:)();
}

uint64_t sub_1004361E8()
{
  swift_task_dealloc();
  swift_task_dealloc();
  return _swift_task_switch(sub_100436300, 0, 0);
}

uint64_t sub_100436300()
{
  return (*(uint64_t (**)(void))(v0 + 8))();
}

uint64_t sub_100436314(uint64_t a1, void *a2)
{
  uint64_t v4 = sub_100431F80(&qword_100A470D0);
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v6 = *(void *)(v5 + 64);
  __chkstk_darwin(v4, v7);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))((char *)&v11 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0), a1, v4);
  unint64_t v8 = (*(unsigned __int8 *)(v5 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v5 + 80);
  uint64_t v9 = swift_allocObject();
  (*(void (**)(unint64_t, char *, uint64_t))(v5 + 32))(v9 + v8, (char *)&v11 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0), v4);
  (*(void (**)(uint64_t (*)(), uint64_t))((swift_isaMask & *a2) + 0x150))(sub_10044C3BC, v9);
  return swift_release();
}

void sub_100436498()
{
  uint64_t v1 = (os_unfair_lock_s *)(*(void *)(v0
                                      + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state)
                          + ((*(unsigned int *)(**(void **)(v0
                                                            + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state)
                                              + 48)
                            + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v1);
  sub_100441400();
  os_unfair_lock_unlock(v1);
}

uint64_t sub_100436540(uint64_t a1)
{
  uint64_t v2 = v1;
  uint64_t v4 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(0);
  __chkstk_darwin(v4 - 8, v5);
  uint64_t v7 = (char *)v100 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState(0);
  __chkstk_darwin(v8, v9);
  uint64_t v110 = (uint64_t)v100 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = sub_100431F80(&qword_100A47D80);
  __chkstk_darwin(v11 - 8, v12);
  uint64_t v114 = (uint64_t)v100 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = sub_100725CC0();
  uint64_t v115 = *(void *)(v14 - 8);
  uint64_t v116 = v14;
  uint64_t v16 = __chkstk_darwin(v14, v15);
  int v111 = (char *)v100 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = __chkstk_darwin(v16, v18);
  id v112 = (char *)v100 - v20;
  __chkstk_darwin(v19, v21);
  id v113 = (char *)v100 - v22;
  uint64_t v23 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0);
  uint64_t v25 = __chkstk_darwin(v23, v24);
  uint64_t v27 = (char *)v100 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v29 = __chkstk_darwin(v25, v28);
  __int16 v31 = (char *)v100 - v30;
  uint64_t v33 = __chkstk_darwin(v29, v32);
  os_log_type_t v35 = (char *)v100 - v34;
  uint64_t v36 = a1 + *(int *)(v33 + 28);
  uint64_t Strong = swift_unknownObjectWeakLoadStrong();
  if (Strong)
  {
    uint64_t v38 = (void *)Strong;
    uint64_t v39 = *(void *)(v36 + 8);
    uint64_t ObjectType = swift_getObjectType();
    LOBYTE(v39) = (*(uint64_t (**)(uint64_t, uint64_t))(v39 + 16))(ObjectType, v39);

    if (v39)
    {
      sub_1004323D4(a1, (uint64_t)v35, type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
      uint64_t v41 = (char *)v2 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_l;
      sub_1004323D4((uint64_t)v35, (uint64_t)v31, type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
      sub_1004323D4((uint64_t)v35, (uint64_t)v27, type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
      id v108 = v41;
      uint64_t v42 = sub_100725EB0();
      os_log_type_t v43 = sub_1007266E0();
      int v44 = v43;
      BOOL v45 = os_log_type_enabled(v42, v43);
      id v105 = v2;
      uint64_t v106 = v7;
      uint64_t v107 = v35;
      uint64_t v103 = v8;
      if (v45)
      {
        uint64_t v46 = swift_slowAlloc();
        uint64_t v109 = swift_slowAlloc();
        v117[0] = v109;
        *(_DWORD *)uint64_t v46 = 136315650;
        uint64_t v118 = sub_10043E578(0x5F28657461647075, 0xEA0000000000293ALL, v117);
        os_log_t v101 = (os_log_t)&v119;
        sub_100726830();
        *(_WORD *)(v46 + 12) = 2080;
        v100[1] = v46 + 14;
        os_log_t v104 = v42;
        type metadata accessor for IDSGroupEncryptionControllerMember();
        sub_10044C1AC((unint64_t *)&qword_100A44A78, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionControllerMember);
        swift_bridgeObjectRetain();
        uint64_t v47 = sub_100726650();
        LODWORD(v102) = v44;
        unint64_t v49 = v48;
        swift_bridgeObjectRelease();
        uint64_t v118 = sub_10043E578(v47, v49, v117);
        sub_100726830();
        swift_bridgeObjectRelease();
        sub_1004324A4((uint64_t)v31, type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
        *(_WORD *)(v46 + 22) = 2080;
        swift_bridgeObjectRetain();
        uint64_t v50 = sub_100726650();
        unint64_t v52 = v51;
        swift_bridgeObjectRelease();
        uint64_t v118 = sub_10043E578(v50, v52, v117);
        sub_100726830();
        swift_bridgeObjectRelease();
        sub_1004324A4((uint64_t)v27, type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
        os_log_t v53 = v104;
        _os_log_impl((void *)&_mh_execute_header, v104, (os_log_type_t)v102, "%s: previous members: %s; new members: %s",
          (uint8_t *)v46,
          0x20u);
        swift_arrayDestroy();
        swift_slowDealloc();
        swift_slowDealloc();
      }
      else
      {

        sub_1004324A4((uint64_t)v31, type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
        sub_1004324A4((uint64_t)v27, type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
      }
      uint64_t v63 = v23[9];
      uint64_t v62 = v23[10];
      uint64_t v64 = *(void *)(a1 + v63);
      uint64_t v109 = a1;
      os_log_t v104 = v62;
      uint64_t v65 = *(uint64_t *)((char *)&v62->isa + a1);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      id v66 = sub_1004DD5F0(v64, v65);
      uint64_t v68 = v67;
      uint64_t v70 = v69;
      uint64_t v72 = v71;
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      if ((v64 & 0xC000000000000001) != 0)
      {
        swift_bridgeObjectRetain();
        uint64_t v73 = sub_100726920();
        swift_bridgeObjectRelease();
      }
      else
      {
        uint64_t v73 = *(void *)(v64 + 16);
      }
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(void *)(v109 + v63) = v65;
      swift_bridgeObjectRetain_n();
      swift_bridgeObjectRetain_n();
      swift_bridgeObjectRetain_n();
      swift_bridgeObjectRetain_n();
      long long v74 = sub_100725EB0();
      os_log_type_t v75 = sub_1007266E0();
      if (os_log_type_enabled(v74, v75))
      {
        uint64_t v76 = swift_slowAlloc();
        uint64_t v102 = swift_slowAlloc();
        uint64_t v118 = v102;
        *(_DWORD *)uint64_t v76 = 136315394;
        os_log_t v101 = v74;
        v117[0] = sub_10043E578(0x5F28657461647075, 0xEA0000000000293ALL, &v118);
        sub_100726830();
        *(_WORD *)(v76 + 12) = 2080;
        v117[0] = (uint64_t)v66;
        v117[1] = v68;
        v117[2] = v70;
        v117[3] = v72;
        sub_100441464();
        uint64_t v77 = sub_100726D00();
        v117[0] = sub_10043E578(v77, v78, &v118);
        sub_100726830();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease_n();
        swift_bridgeObjectRelease_n();
        swift_bridgeObjectRelease_n();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        long long v74 = v101;
        _os_log_impl((void *)&_mh_execute_header, v101, v75, "%s: diff: %s", (uint8_t *)v76, 0x16u);
        swift_arrayDestroy();
        swift_slowDealloc();
        swift_slowDealloc();
      }
      else
      {
        swift_bridgeObjectRelease_n();
        swift_bridgeObjectRelease_n();
        swift_bridgeObjectRelease_n();
        swift_bridgeObjectRelease_n();
      }

      uint64_t v79 = (uint64_t)v106;
      if (!v73)
      {
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        int v81 = sub_100725EB0();
        uint64_t v82 = sub_1007266E0();
        if (os_log_type_enabled(v81, (os_log_type_t)v82))
        {
          __int16 v83 = (uint8_t *)swift_slowAlloc();
          v117[0] = swift_slowAlloc();
          *(_DWORD *)__int16 v83 = 136315138;
          uint64_t v118 = sub_10043E578(0x5F28657461647075, 0xEA0000000000293ALL, v117);
          sub_100726830();
          _os_log_impl((void *)&_mh_execute_header, v81, (os_log_type_t)v82, "%s: This is initially setting members, should not roll/ratchet, but should ensure we have a key", v83, 0xCu);
          swift_arrayDestroy();
          swift_slowDealloc();
          swift_slowDealloc();
        }

        id v84 = v105;
        uint64_t v85 = v109;
        uint64_t v86 = *(uint64_t *)((char *)&v104->isa + v109);
        if ((v86 & 0xC000000000000001) != 0)
        {
          swift_bridgeObjectRetain();
          uint64_t v87 = sub_100726920();
          swift_bridgeObjectRelease();
          if (v87 < 1) {
            return sub_1004324A4((uint64_t)v107, type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
          }
        }
        else if (*(uint64_t *)(v86 + 16) < 1)
        {
          return sub_1004324A4((uint64_t)v107, type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
        }
        (*(void (**)(uint64_t))((swift_isaMask & *v84) + 0x1E8))(v85);
        return sub_1004324A4((uint64_t)v107, type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
      }
      if (sub_1004DD2F4((uint64_t)v66, v68, v70, v72))
      {
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        uint64_t v80 = v109;
        (*(void (**)(uint64_t))((swift_isaMask & *v105) + 0x188))(v109);
      }
      else
      {
        BOOL v88 = sub_1004DD330((uint64_t)v66, v68, v70);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        if (v88)
        {
          uint64_t v80 = v109;
          if (*((unsigned char *)v105
               + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_isRatchetEnabled) == 1)
            sub_10043920C(v109);
          else {
            (*(void (**)(uint64_t))((swift_isaMask & *v105) + 0x188))(v109);
          }
        }
        else
        {
          uint64_t v89 = v23[5];
          uint64_t v80 = v109;
          uint64_t v90 = v114;
          sub_10043206C(*(void *)(v109 + v89 + 8), *(unsigned char *)(v109 + v89 + 16), v114);
          uint64_t v92 = v115;
          uint64_t v91 = v116;
          if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v115 + 48))(v90, 1, v116) == 1)
          {
            sub_10044C150(v90, &qword_100A47D80);
          }
          else
          {
            uint64_t v93 = v113;
            (*(void (**)(char *, uint64_t, uint64_t))(v92 + 32))(v113, v90, v91);
            int v94 = v111;
            sub_100725CB0();
            id v95 = v112;
            sub_100725CA0();
            id v96 = *(void (**)(char *, uint64_t))(v92 + 8);
            v96(v94, v91);
            char v97 = sub_100725C00();
            v96(v95, v91);
            if (v97)
            {
              uint64_t v98 = v110;
              sub_1004323D4(v80, v110, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
              int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
              if (EnumCaseMultiPayload)
              {
                if (EnumCaseMultiPayload == 1) {
                  sub_100437C70(v80);
                }
                v96(v93, v91);
                sub_1004324A4(v98, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
                goto LABEL_20;
              }
              sub_10043243C(v98, v79, type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey);
              sub_1004375B8(v80, v79);
              sub_1004324A4(v79, type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey);
            }
            v96(v93, v91);
          }
        }
      }
LABEL_20:
      sub_100434CDC(v80);
      return sub_1004324A4((uint64_t)v107, type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
    }
  }
  uint64_t v54 = (char *)v2 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_l;
  id v55 = sub_100725EB0();
  os_log_type_t v56 = sub_1007266E0();
  if (os_log_type_enabled(v55, v56))
  {
    uint64_t v57 = (uint8_t *)swift_slowAlloc();
    v117[0] = swift_slowAlloc();
    *(_DWORD *)uint64_t v57 = 136315138;
    uint64_t v118 = sub_10043E578(0x5F28657461647075, 0xEA0000000000293ALL, v117);
    sub_100726830();
    _os_log_impl((void *)&_mh_execute_header, v55, v56, "%s: not updating because session has gone away", v57, 0xCu);
    swift_arrayDestroy();
    swift_slowDealloc();
    swift_slowDealloc();
  }

  uint64_t v58 = sub_100725EB0();
  os_log_type_t v59 = sub_1007266E0();
  if (os_log_type_enabled(v58, v59))
  {
    uint64_t v60 = (uint8_t *)swift_slowAlloc();
    v117[0] = swift_slowAlloc();
    *(_DWORD *)uint64_t v60 = 136315138;
    uint64_t v118 = sub_10043E578(0x5F28657461647075, 0xEA0000000000293ALL, v117);
    sub_100726830();
    _os_log_impl((void *)&_mh_execute_header, v58, v59, "%s: setting state to .noKey", v60, 0xCu);
    swift_arrayDestroy();
    swift_slowDealloc();
    swift_slowDealloc();
  }

  sub_1004324A4(a1, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
  swift_storeEnumTagMultiPayload();
  return (*(uint64_t (**)(char *, void, unint64_t, uint64_t))((swift_isaMask & *v2) + 0x208))(v54, 0, 0xE000000000000000, a1);
}

BOOL sub_100437508()
{
  uint64_t v1 = *(void *)(v0 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state);
  uint64_t v2 = v1 + *(void *)(class metadata base offset for ManagedBuffer + *(void *)v1 + 16);
  uint64_t v3 = (os_unfair_lock_s *)(v1 + ((*(unsigned int *)(*(void *)v1 + 48) + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v3);
  sub_1004414B8(v2, &v5);
  os_unfair_lock_unlock(v3);
  return v5;
}

void sub_1004375B8(uint64_t a1, uint64_t a2)
{
  uint64_t v57 = a2;
  uint64_t v3 = sub_100725EF0();
  uint64_t v65 = *(void *)(v3 - 8);
  uint64_t v66 = v3;
  __chkstk_darwin(v3, v4);
  uint64_t v64 = (char *)&v54 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = sub_100725F20();
  uint64_t v62 = *(void *)(v6 - 8);
  uint64_t v63 = v6;
  __chkstk_darwin(v6, v7);
  uint64_t v61 = (char *)&v54 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v9 = sub_100725CC0();
  uint64_t v58 = *(void *)(v9 - 8);
  uint64_t v59 = v9;
  __chkstk_darwin(v9, v10);
  os_log_type_t v56 = (char *)&v54 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v55 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState(0);
  __chkstk_darwin(v55, v12);
  uint64_t v14 = (char *)&v54 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = sub_100431F80(&qword_100A44A50);
  uint64_t v17 = __chkstk_darwin(v15 - 8, v16);
  uint64_t v19 = (char *)&v54 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v17, v20);
  uint64_t v22 = (char *)&v54 - v21;
  uint64_t v23 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  uint64_t v24 = *(void *)(v23 - 8);
  uint64_t v26 = __chkstk_darwin(v23, v25);
  uint64_t v28 = (char *)&v54 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v30 = __chkstk_darwin(v26, v29);
  uint64_t v32 = (char *)&v54 - v31;
  __chkstk_darwin(v30, v33);
  os_log_type_t v35 = (char *)&v54 - v34;
  uint64_t v36 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0);
  uint64_t v37 = *(int *)(v36 + 32);
  uint64_t v60 = a1;
  sub_10043ADC4(*(void *)(a1 + v37), (uint64_t)v22);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v24 + 48))(v22, 1, v23) == 1)
  {
    sub_10044C150((uint64_t)v22, &qword_100A44A50);
    uint64_t v38 = v60;
  }
  else
  {
    sub_10043243C((uint64_t)v22, (uint64_t)v35, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    uint64_t v39 = v57;
    sub_100431F18(v57, (uint64_t)v19);
    uint64_t v40 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(0);
    sub_1004323D4(v39 + *(int *)(v40 + 20), (uint64_t)v32, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    sub_1004323D4((uint64_t)v35, (uint64_t)v28, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    uint64_t v41 = v56;
    sub_100725CB0();
    sub_1004324A4((uint64_t)v35, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    sub_100431FE4((uint64_t)v19, (uint64_t)v14);
    uint64_t v42 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey(0);
    sub_10043243C((uint64_t)v32, (uint64_t)&v14[v42[5]], (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    sub_10043243C((uint64_t)v28, (uint64_t)&v14[v42[6]], (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    (*(void (**)(char *, char *, uint64_t))(v58 + 32))(&v14[v42[7]], v41, v59);
    swift_storeEnumTagMultiPayload();
    uint64_t v38 = v60;
    sub_100432AA4((uint64_t)v14, v60);
  }
  uint64_t v43 = v38 + *(int *)(v36 + 28);
  uint64_t Strong = (void *)swift_unknownObjectWeakLoadStrong();
  uint64_t v45 = *(void *)(v43 + 8);
  uint64_t v46 = v67;
  uint64_t v47 = (void *)swift_allocObject();
  v47[2] = Strong;
  v47[3] = v45;
  v47[4] = v46;
  aBlock[4] = sub_10044154C;
  aBlock[5] = v47;
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 1107296256;
  aBlock[2] = sub_100435714;
  aBlock[3] = &unk_10098D980;
  unint64_t v48 = _Block_copy(aBlock);
  id v49 = Strong;
  uint64_t v50 = v46;
  unint64_t v51 = v61;
  sub_100725F00();
  uint64_t v68 = &_swiftEmptyArrayStorage;
  sub_10044C1AC((unint64_t *)&unk_100A46890, (void (*)(uint64_t))&type metadata accessor for DispatchWorkItemFlags);
  sub_100431F80((uint64_t *)&unk_100A454C0);
  sub_1004413A8((unint64_t *)&qword_100A468A0, (uint64_t *)&unk_100A454C0);
  unint64_t v52 = v64;
  uint64_t v53 = v66;
  sub_100726890();
  sub_100726750();
  _Block_release(v48);
  (*(void (**)(char *, uint64_t))(v65 + 8))(v52, v53);
  (*(void (**)(char *, uint64_t))(v62 + 8))(v51, v63);
  swift_release();
  (*(void (**)(uint64_t, void, unint64_t, uint64_t))((swift_isaMask & *v50) + 0x208))((uint64_t)v50 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_l, 0, 0xE000000000000000, v38);
}

void sub_100437C70(uint64_t a1)
{
  uint64_t v81 = a1;
  uint64_t v78 = sub_100725EF0();
  uint64_t v2 = *(void *)(v78 - 8);
  __chkstk_darwin(v78, v3);
  uint64_t v5 = (char *)&v70 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = sub_100725F20();
  uint64_t v7 = *(void *)(v6 - 8);
  __chkstk_darwin(v6, v8);
  uint64_t v82 = (char *)&v70 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = sub_100725CC0();
  uint64_t v76 = *(void *)(v10 - 8);
  uint64_t v77 = v10;
  __chkstk_darwin(v10, v11);
  os_log_type_t v75 = (char *)&v70 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  uint64_t v79 = *(void *)(v13 - 8);
  uint64_t v80 = v13;
  uint64_t v15 = __chkstk_darwin(v13, v14);
  uint64_t v71 = (uint64_t)&v70 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v15, v17);
  uint64_t v74 = (uint64_t)&v70 - v18;
  uint64_t v19 = sub_100431F80(&qword_100A44A50);
  uint64_t v21 = __chkstk_darwin(v19 - 8, v20);
  uint64_t v23 = (char *)&v70 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v21, v24);
  uint64_t v73 = (uint64_t)&v70 - v25;
  uint64_t v72 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey(0);
  __chkstk_darwin(v72, v26);
  uint64_t v28 = (char *)&v70 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v88 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState(0);
  uint64_t v30 = __chkstk_darwin(v88, v29);
  uint64_t v32 = (char *)&v70 - ((v31 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v30, v33);
  uint64_t v87 = (uint64_t)&v70 - v34;
  os_log_type_t v35 = v1;
  uint64_t v89 = &v1[OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_l];
  uint64_t v36 = sub_100725EB0();
  os_log_type_t v37 = sub_1007266E0();
  BOOL v38 = os_log_type_enabled(v36, v37);
  uint64_t v85 = v6;
  uint64_t v86 = v2;
  uint64_t v83 = v7;
  id v84 = v5;
  if (v38)
  {
    uint64_t v39 = (uint8_t *)swift_slowAlloc();
    aBlock[0] = swift_slowAlloc();
    *(_DWORD *)uint64_t v39 = 136315138;
    uint64_t v90 = (void *)sub_10043E578(0xD000000000000011, 0x80000001008C0800, aBlock);
    sub_100726830();
    _os_log_impl((void *)&_mh_execute_header, v36, v37, "%s: roll to next key", v39, 0xCu);
    swift_arrayDestroy();
    swift_slowDealloc();
    swift_slowDealloc();
  }

  uint64_t v40 = v81;
  uint64_t v41 = v35;
  uint64_t v42 = v87;
  sub_1004323D4(v81, v87, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
  if (swift_getEnumCaseMultiPayload() == 1)
  {
    sub_10043243C(v42, (uint64_t)v28, type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey);
    uint64_t v43 = v72;
    uint64_t v44 = v73;
    sub_1004323D4((uint64_t)&v28[*(int *)(v72 + 20)], v73, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    (*(void (**)(uint64_t, void, uint64_t, uint64_t))(v79 + 56))(v44, 0, 1, v80);
    uint64_t v45 = v74;
    sub_1004323D4((uint64_t)&v28[*(int *)(v43 + 24)], v74, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    uint64_t v46 = v75;
    sub_100725CB0();
    sub_1004324A4((uint64_t)v28, type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey);
    sub_100431FE4(v44, (uint64_t)v32);
    uint64_t v47 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(0);
    sub_10043243C(v45, (uint64_t)&v32[*(int *)(v47 + 20)], (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    (*(void (**)(char *, char *, uint64_t))(v76 + 32))(&v32[*(int *)(v47 + 24)], v46, v77);
    swift_storeEnumTagMultiPayload();
    sub_100432AA4((uint64_t)v32, v40);
    uint64_t v48 = v78;
  }
  else
  {
    uint64_t v49 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0);
    sub_10043ADC4(*(void *)(v40 + *(int *)(v49 + 32)), (uint64_t)v23);
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v79 + 48))(v23, 1, v80) == 1)
    {
      sub_10044C150((uint64_t)v23, &qword_100A44A50);
      uint64_t v50 = sub_100725EB0();
      os_log_type_t v51 = sub_1007266E0();
      BOOL v52 = os_log_type_enabled(v50, v51);
      uint64_t v53 = v78;
      if (v52)
      {
        uint64_t v54 = (uint8_t *)swift_slowAlloc();
        aBlock[0] = swift_slowAlloc();
        *(_DWORD *)uint64_t v54 = 136315138;
        uint64_t v90 = (void *)sub_10043E578(0xD000000000000011, 0x80000001008C0800, aBlock);
        uint64_t v42 = v87;
        sub_100726830();
        _os_log_impl((void *)&_mh_execute_header, v50, v51, "%s: setting state to .noKey", v54, 0xCu);
        swift_arrayDestroy();
        swift_slowDealloc();
        swift_slowDealloc();
      }

      uint64_t v48 = v53;
      sub_1004324A4(v40, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
      swift_storeEnumTagMultiPayload();
      (*(void (**)(char *, void, unint64_t, uint64_t))((swift_isaMask & *(void *)v35) + 0x208))(v89, 0, 0xE000000000000000, v40);
    }
    else
    {
      uint64_t v55 = v71;
      sub_10043243C((uint64_t)v23, v71, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
      uint64_t v56 = v73;
      sub_100432504(v73);
      uint64_t v57 = v74;
      sub_1004323D4(v55, v74, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
      uint64_t v58 = v75;
      sub_100725CB0();
      sub_1004324A4(v55, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
      sub_100431FE4(v56, (uint64_t)v32);
      uint64_t v59 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(0);
      sub_10043243C(v57, (uint64_t)&v32[*(int *)(v59 + 20)], (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
      (*(void (**)(char *, char *, uint64_t))(v76 + 32))(&v32[*(int *)(v59 + 24)], v58, v77);
      swift_storeEnumTagMultiPayload();
      sub_100432AA4((uint64_t)v32, v40);
      uint64_t v48 = v78;
    }
    sub_1004324A4(v42, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
  }
  uint64_t v60 = v40 + *(int *)(type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0) + 28);
  uint64_t Strong = (void *)swift_unknownObjectWeakLoadStrong();
  uint64_t v62 = *(void *)(v60 + 8);
  uint64_t v88 = *(void *)&v41[OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_q];
  uint64_t v63 = (void *)swift_allocObject();
  v63[2] = Strong;
  v63[3] = v62;
  v63[4] = v41;
  aBlock[4] = (uint64_t)sub_10044154C;
  aBlock[5] = (uint64_t)v63;
  aBlock[0] = (uint64_t)_NSConcreteStackBlock;
  aBlock[1] = 1107296256;
  aBlock[2] = (uint64_t)sub_100435714;
  aBlock[3] = (uint64_t)&unk_10098D9D0;
  uint64_t v64 = _Block_copy(aBlock);
  id v65 = Strong;
  uint64_t v66 = v41;
  uint64_t v67 = v40;
  uint64_t v68 = v82;
  sub_100725F00();
  uint64_t v90 = &_swiftEmptyArrayStorage;
  sub_10044C1AC((unint64_t *)&unk_100A46890, (void (*)(uint64_t))&type metadata accessor for DispatchWorkItemFlags);
  sub_100431F80((uint64_t *)&unk_100A454C0);
  sub_1004413A8((unint64_t *)&qword_100A468A0, (uint64_t *)&unk_100A454C0);
  uint64_t v69 = v84;
  sub_100726890();
  sub_100726750();
  _Block_release(v64);
  (*(void (**)(char *, uint64_t))(v86 + 8))(v69, v48);
  (*(void (**)(char *, uint64_t))(v83 + 8))(v68, v85);
  swift_release();
  (*(void (**)(char *, void, unint64_t, uint64_t))((swift_isaMask & *(void *)v66) + 0x208))(v89, 0, 0xE000000000000000, v67);
}

void sub_1004387AC(uint64_t a1)
{
  uint64_t v2 = v1;
  uint64_t v4 = sub_100725EF0();
  uint64_t v5 = *(void *)(v4 - 8);
  __chkstk_darwin(v4, v6);
  uint64_t v8 = (char *)&v63 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v9 = sub_100725F20();
  uint64_t v10 = *(void *)(v9 - 8);
  __chkstk_darwin(v9, v11);
  uint64_t v79 = (char *)&v63 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = sub_100725CC0();
  uint64_t v69 = *(void *)(v13 - 8);
  uint64_t v70 = v13;
  __chkstk_darwin(v13, v14);
  uint64_t v68 = (char *)&v63 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  id v78 = (id)type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState(0);
  __chkstk_darwin(v78, v16);
  uint64_t v67 = (uint64_t)&v63 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = sub_100431F80(&qword_100A44A50);
  uint64_t v20 = __chkstk_darwin(v18 - 8, v19);
  uint64_t v66 = (char *)&v63 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v20, v22);
  uint64_t v24 = (char *)&v63 - v23;
  uint64_t v76 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  uint64_t v25 = *(void *)(v76 - 8);
  uint64_t v27 = __chkstk_darwin(v76, v26);
  uint64_t v65 = (uint64_t)&v63 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v27, v29);
  uint64_t v64 = (uint64_t)&v63 - v30;
  uint64_t v77 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0);
  uint64_t v31 = *(int *)(v77 + 60);
  uint64_t v32 = a1;
  uint64_t v33 = *(void *)(a1 + v31);
  uint64_t v34 = (void *)(v33 + 1);
  if (v33 == -1)
  {
    __break(1u);
  }
  else
  {
    uint64_t v72 = v8;
    uint64_t v74 = v5;
    uint64_t v75 = v4;
    *(void *)(v32 + v31) = v34;
    uint64_t v80 = (char *)v2 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_l;
    os_log_type_t v35 = sub_100725EB0();
    os_log_type_t v36 = sub_1007266E0();
    BOOL v37 = os_log_type_enabled(v35, v36);
    uint64_t v73 = v9;
    uint64_t v71 = v10;
    if (v37)
    {
      uint64_t v38 = swift_slowAlloc();
      uint64_t v63 = v32;
      uint64_t v39 = v38;
      aBlock[0] = swift_slowAlloc();
      *(_DWORD *)uint64_t v39 = 136315394;
      uint64_t v81 = (void *)sub_10043E578(0x6C6C6F5264726168, 0xEC000000293A5F28, aBlock);
      sub_100726830();
      *(_WORD *)(v39 + 12) = 2048;
      uint64_t v81 = v34;
      sub_100726830();
      _os_log_impl((void *)&_mh_execute_header, v35, v36, "%s: hard rolling; gen count: %llu", (uint8_t *)v39, 0x16u);
      swift_arrayDestroy();
      swift_slowDealloc();
      uint64_t v32 = v63;
      swift_slowDealloc();
    }

    uint64_t v40 = v77;
    sub_10043ADC4(*(void *)(v32 + *(int *)(v77 + 32)), (uint64_t)v24);
    uint64_t v41 = v76;
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v25 + 48))(v24, 1, v76) == 1)
    {
      sub_10044C150((uint64_t)v24, &qword_100A44A50);
      uint64_t v42 = v80;
      uint64_t v43 = sub_100725EB0();
      os_log_type_t v44 = sub_1007266E0();
      if (os_log_type_enabled(v43, v44))
      {
        uint64_t v45 = (uint8_t *)swift_slowAlloc();
        aBlock[0] = swift_slowAlloc();
        *(_DWORD *)uint64_t v45 = 136315138;
        uint64_t v81 = (void *)sub_10043E578(0x6C6C6F5264726168, 0xEC000000293A5F28, aBlock);
        uint64_t v42 = v80;
        sub_100726830();
        _os_log_impl((void *)&_mh_execute_header, v43, v44, "%s: setting state to .noKey", v45, 0xCu);
        swift_arrayDestroy();
        swift_slowDealloc();
        swift_slowDealloc();
      }

      sub_1004324A4(v32, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
      swift_storeEnumTagMultiPayload();
      (*(void (**)(char *, void, unint64_t, uint64_t))((swift_isaMask & *v2) + 0x208))(v42, 0, 0xE000000000000000, v32);
    }
    else
    {
      uint64_t v46 = (uint64_t)v24;
      uint64_t v47 = v64;
      sub_10043243C(v46, v64, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
      uint64_t v48 = (uint64_t)v66;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v25 + 56))(v66, 1, 1, v41);
      uint64_t v49 = v65;
      sub_1004323D4(v47, v65, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
      uint64_t v50 = v68;
      sub_100725CB0();
      sub_1004324A4(v47, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
      uint64_t v51 = v67;
      sub_100431FE4(v48, v67);
      uint64_t v52 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(0);
      sub_10043243C(v49, v51 + *(int *)(v52 + 20), (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
      (*(void (**)(uint64_t, char *, uint64_t))(v69 + 32))(v51 + *(int *)(v52 + 24), v50, v70);
      swift_storeEnumTagMultiPayload();
      sub_100432AA4(v51, v32);
    }
    uint64_t v53 = v32;
    uint64_t v54 = v32 + *(int *)(v40 + 28);
    uint64_t Strong = (void *)swift_unknownObjectWeakLoadStrong();
    uint64_t v56 = *(void *)(v54 + 8);
    uint64_t v57 = (void *)swift_allocObject();
    v57[2] = Strong;
    v57[3] = v56;
    v57[4] = v2;
    aBlock[4] = (uint64_t)sub_10044154C;
    aBlock[5] = (uint64_t)v57;
    aBlock[0] = (uint64_t)_NSConcreteStackBlock;
    aBlock[1] = 1107296256;
    aBlock[2] = (uint64_t)sub_100435714;
    aBlock[3] = (uint64_t)&unk_10098D5C8;
    uint64_t v58 = _Block_copy(aBlock);
    id v78 = Strong;
    uint64_t v59 = v2;
    uint64_t v60 = v79;
    sub_100725F00();
    uint64_t v81 = &_swiftEmptyArrayStorage;
    sub_10044C1AC((unint64_t *)&unk_100A46890, (void (*)(uint64_t))&type metadata accessor for DispatchWorkItemFlags);
    sub_100431F80((uint64_t *)&unk_100A454C0);
    sub_1004413A8((unint64_t *)&qword_100A468A0, (uint64_t *)&unk_100A454C0);
    uint64_t v61 = v72;
    uint64_t v62 = v75;
    sub_100726890();
    sub_100726750();
    _Block_release(v58);
    (*(void (**)(char *, uint64_t))(v74 + 8))(v61, v62);
    (*(void (**)(char *, uint64_t))(v71 + 8))(v60, v73);
    swift_release();
    (*(void (**)(char *, void, unint64_t, uint64_t))((swift_isaMask & *v59) + 0x208))(v80, 0, 0xE000000000000000, v53);
  }
}

void sub_100439164()
{
  uint64_t v1 = (os_unfair_lock_s *)(*(void *)(v0
                                      + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state)
                          + ((*(unsigned int *)(**(void **)(v0
                                                            + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state)
                                              + 48)
                            + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v1);
  sub_100441550();
  os_unfair_lock_unlock(v1);
}

void sub_10043920C(uint64_t a1)
{
  uint64_t v2 = v1;
  uint64_t v150 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey(0);
  uint64_t v5 = __chkstk_darwin(v150, v4);
  CFStringRef v146 = (char *)&v133 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v5, v7);
  uint64_t v151 = (uint64_t)&v133 - v8;
  uint64_t v9 = sub_100725EF0();
  uint64_t v143 = *(void *)(v9 - 8);
  __chkstk_darwin(v9, v10);
  CFStringRef v140 = (char *)&v133 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v142 = sub_100725F20();
  uint64_t v141 = *(void *)(v142 - 8);
  __chkstk_darwin(v142, v12);
  uint64_t v139 = (char *)&v133 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = sub_100431F80(&qword_100A44A50);
  uint64_t v16 = __chkstk_darwin(v14 - 8, v15);
  uint64_t v18 = (char *)&v133 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v16, v19);
  id v144 = (char *)&v133 - v20;
  uint64_t v21 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  uint64_t v153 = *(void *)(v21 - 8);
  uint64_t v154 = v21;
  uint64_t v23 = __chkstk_darwin(v21, v22);
  CFStringRef v145 = (char *)&v133 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v26 = __chkstk_darwin(v23, v25);
  uint64_t v148 = (uint64_t)&v133 - v27;
  uint64_t v29 = __chkstk_darwin(v26, v28);
  uint64_t v136 = (uint64_t)&v133 - v30;
  __chkstk_darwin(v29, v31);
  uint64_t v147 = (uint64_t)&v133 - v32;
  uint64_t v149 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(0);
  uint64_t v34 = __chkstk_darwin(v149, v33);
  uint64_t v135 = (uint64_t)&v133 - ((v35 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v34, v36);
  uint64_t v152 = (uint64_t)&v133 - v37;
  uint64_t v155 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState(0);
  uint64_t v39 = __chkstk_darwin(v155, v38);
  uint64_t v138 = (uint64_t)&v133 - ((v40 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v39, v41);
  uint64_t v43 = (char *)&v133 - v42;
  uint64_t v44 = sub_100725CC0();
  uint64_t v45 = *(void *)(v44 - 8);
  __chkstk_darwin(v44, v46);
  uint64_t v48 = (char *)&v133 - ((v47 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_100725C80();
  uint64_t v137 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0);
  uint64_t v49 = a1 + *(int *)(v137 + 56);
  sub_100725BC0();
  double v51 = v50;
  (*(void (**)(char *, uint64_t))(v45 + 8))(v48, v44);
  if (v51 <= 5.0)
  {
    uint64_t v72 = sub_100725EB0();
    os_log_type_t v73 = sub_1007266E0();
    if (os_log_type_enabled(v72, v73))
    {
      uint64_t v74 = (uint8_t *)swift_slowAlloc();
      uint64_t aBlock = swift_slowAlloc();
      *(_DWORD *)uint64_t v74 = 136315138;
      uint64_t v163 = sub_10043E578(0x2874656863746172, 0xEB00000000293A5FLL, &aBlock);
      sub_100726830();
      _os_log_impl((void *)&_mh_execute_header, v72, v73, "%s: ratchet canceled because we just ratcheted recently", v74, 0xCu);
      swift_arrayDestroy();
      swift_slowDealloc();
      swift_slowDealloc();
    }
  }
  else
  {
    sub_100725C80();
    (*(void (**)(uint64_t, char *, uint64_t))(v45 + 40))(v49, v48, v44);
    uint64_t v52 = sub_100725EB0();
    os_log_type_t v53 = sub_1007266E0();
    BOOL v54 = os_log_type_enabled(v52, v53);
    uint64_t v134 = v9;
    id v133 = v18;
    if (v54)
    {
      uint64_t v55 = (uint8_t *)swift_slowAlloc();
      uint64_t aBlock = swift_slowAlloc();
      *(_DWORD *)uint64_t v55 = 136315138;
      uint64_t v163 = sub_10043E578(0x2874656863746172, 0xEB00000000293A5FLL, &aBlock);
      sub_100726830();
      _os_log_impl((void *)&_mh_execute_header, v52, v53, "%s: ratchet (rolling)", v55, 0xCu);
      swift_arrayDestroy();
      swift_slowDealloc();
      swift_slowDealloc();
    }

    sub_1004323D4(a1, (uint64_t)v43, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
    int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
    if (!EnumCaseMultiPayload)
    {
      uint64_t v75 = (uint64_t)v43;
      uint64_t v76 = v152;
      sub_10043243C(v75, v152, type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey);
      uint64_t v77 = sub_100725EB0();
      os_log_type_t v78 = sub_1007266E0();
      if (os_log_type_enabled(v77, v78))
      {
        uint64_t v79 = (uint8_t *)swift_slowAlloc();
        uint64_t aBlock = swift_slowAlloc();
        *(_DWORD *)uint64_t v79 = 136315138;
        uint64_t v163 = sub_10043E578(0x2874656863746172, 0xEB00000000293A5FLL, &aBlock);
        sub_100726830();
        _os_log_impl((void *)&_mh_execute_header, v77, v78, "%s: ratcheting current key because we have one key", v79, 0xCu);
        swift_arrayDestroy();
        uint64_t v76 = v152;
        swift_slowDealloc();
        swift_slowDealloc();
      }

      uint64_t v80 = v154;
      uint64_t v81 = v144;
      swift_beginAccess();
      int v82 = dword_100A531F8 + 1;
      if (dword_100A531F8 != -1)
      {
        ++dword_100A531F8;
        uint64_t v83 = v76 + *(int *)(v149 + 20);
        sub_100484138(v82, v81);
        if ((*(unsigned int (**)(unsigned char *, uint64_t, uint64_t))(v153 + 48))(v81, 1, v80) == 1)
        {
          sub_10044C150((uint64_t)v81, &qword_100A44A50);
          uint64_t v84 = v135;
          sub_1004323D4(v76, v135, type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey);
          uint64_t v85 = sub_100725EB0();
          os_log_type_t v86 = sub_1007266E0();
          if (os_log_type_enabled(v85, v86))
          {
            uint64_t v87 = swift_slowAlloc();
            uint64_t aBlock = swift_slowAlloc();
            *(_DWORD *)uint64_t v87 = 136315394;
            id v162 = (void *)sub_10043E578(0x2874656863746172, 0xEB00000000293A5FLL, &aBlock);
            sub_100726830();
            *(_WORD *)(v87 + 12) = 2080;
            sub_10044C1AC(&qword_100A44D38, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
            uint64_t v88 = sub_100726D00();
            id v162 = (void *)sub_10043E578(v88, v89, &aBlock);
            sub_100726830();
            swift_bridgeObjectRelease();
            sub_1004324A4(v84, type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey);
            _os_log_impl((void *)&_mh_execute_header, v85, v86, "%s: ratcheting failed for local key: %s", (uint8_t *)v87, 0x16u);
            swift_arrayDestroy();
            swift_slowDealloc();
            swift_slowDealloc();
          }
          else
          {

            sub_1004324A4(v84, type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey);
          }
          sub_100437C70(a1);
        }
        else
        {
          id v144 = v2;
          uint64_t v99 = v147;
          sub_10043243C((uint64_t)v81, v147, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
          uint64_t v100 = v136;
          sub_1004323D4(v99, v136, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
          os_log_t v101 = sub_100725EB0();
          os_log_type_t v102 = sub_1007266E0();
          if (os_log_type_enabled(v101, v102))
          {
            uint64_t v103 = swift_slowAlloc();
            uint64_t aBlock = swift_slowAlloc();
            *(_DWORD *)uint64_t v103 = 136315394;
            id v162 = (void *)sub_10043E578(0x2874656863746172, 0xEB00000000293A5FLL, &aBlock);
            sub_100726830();
            *(_WORD *)(v103 + 12) = 2080;
            sub_10044C1AC(&qword_100A44D38, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
            uint64_t v104 = sub_100726D00();
            id v162 = (void *)sub_10043E578(v104, v105, &aBlock);
            sub_100726830();
            swift_bridgeObjectRelease();
            sub_1004324A4(v100, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
            _os_log_impl((void *)&_mh_execute_header, v101, v102, "%s: ratcheted to new local key: %s", (uint8_t *)v103, 0x16u);
            swift_arrayDestroy();
            uint64_t v80 = v154;
            swift_slowDealloc();
            swift_slowDealloc();
          }
          else
          {

            sub_1004324A4(v100, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
          }
          uint64_t v122 = v138;
          sub_1004323D4(v83, v138, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
          (*(void (**)(uint64_t, void, uint64_t, uint64_t))(v153 + 56))(v122, 0, 1, v80);
          sub_1004323D4(v147, v122 + *(int *)(v149 + 20), (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
          sub_100725CB0();
          swift_storeEnumTagMultiPayload();
          sub_100432AA4(v122, a1);
          uint64_t v123 = a1 + *(int *)(v137 + 28);
          uint64_t Strong = (void *)swift_unknownObjectWeakLoadStrong();
          uint64_t v125 = *(void *)(v123 + 8);
          id v126 = v144;
          id v127 = (void *)swift_allocObject();
          v127[2] = Strong;
          v127[3] = v125;
          v127[4] = v126;
          uint64_t v160 = sub_10044154C;
          id v161 = v127;
          uint64_t aBlock = (uint64_t)_NSConcreteStackBlock;
          uint64_t v157 = 1107296256;
          id v158 = sub_100435714;
          id v159 = &unk_10098D930;
          id v128 = _Block_copy(&aBlock);
          id v129 = Strong;
          v126;
          id v130 = v139;
          sub_100725F00();
          id v162 = &_swiftEmptyArrayStorage;
          sub_10044C1AC((unint64_t *)&unk_100A46890, (void (*)(uint64_t))&type metadata accessor for DispatchWorkItemFlags);
          sub_100431F80((uint64_t *)&unk_100A454C0);
          sub_1004413A8((unint64_t *)&qword_100A468A0, (uint64_t *)&unk_100A454C0);
          id v131 = v140;
          uint64_t v132 = v134;
          sub_100726890();
          sub_100726750();
          _Block_release(v128);
          (*(void (**)(char *, uint64_t))(v143 + 8))(v131, v132);
          (*(void (**)(char *, uint64_t))(v141 + 8))(v130, v142);
          swift_release();
          sub_100434CDC(a1);

          sub_1004324A4(v147, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
        }
        uint64_t v106 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey;
        uint64_t v107 = v152;
        goto LABEL_37;
      }
      goto LABEL_39;
    }
    id v144 = v2;
    if (EnumCaseMultiPayload == 1)
    {
      uint64_t v57 = v151;
      sub_10043243C((uint64_t)v43, v151, type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey);
      uint64_t v58 = sub_100725EB0();
      os_log_type_t v59 = sub_1007266E0();
      if (os_log_type_enabled(v58, v59))
      {
        uint64_t v60 = (uint8_t *)swift_slowAlloc();
        uint64_t aBlock = swift_slowAlloc();
        *(_DWORD *)uint64_t v60 = 136315138;
        uint64_t v163 = sub_10043E578(0x2874656863746172, 0xEB00000000293A5FLL, &aBlock);
        uint64_t v57 = v151;
        sub_100726830();
        _os_log_impl((void *)&_mh_execute_header, v58, v59, "%s: ratcheting current key because we have two key", v60, 0xCu);
        swift_arrayDestroy();
        swift_slowDealloc();
        swift_slowDealloc();
      }

      uint64_t v61 = v154;
      uint64_t v62 = (uint64_t)v146;
      uint64_t v63 = (uint64_t)v145;
      swift_beginAccess();
      int v64 = dword_100A531F8 + 1;
      if (dword_100A531F8 != -1)
      {
        ++dword_100A531F8;
        uint64_t v65 = v57 + *(int *)(v150 + 20);
        uint64_t v66 = v133;
        sub_100484138(v64, v133);
        if ((*(unsigned int (**)(unsigned char *, uint64_t, uint64_t))(v153 + 48))(v66, 1, v61) == 1)
        {
          sub_10044C150((uint64_t)v66, &qword_100A44A50);
          sub_1004323D4(v57, v62, type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey);
          uint64_t v67 = sub_100725EB0();
          os_log_type_t v68 = sub_1007266E0();
          if (os_log_type_enabled(v67, v68))
          {
            uint64_t v69 = swift_slowAlloc();
            uint64_t aBlock = swift_slowAlloc();
            *(_DWORD *)uint64_t v69 = 136315394;
            id v162 = (void *)sub_10043E578(0x2874656863746172, 0xEB00000000293A5FLL, &aBlock);
            sub_100726830();
            *(_WORD *)(v69 + 12) = 2080;
            sub_10044C1AC(&qword_100A44D38, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
            uint64_t v70 = sub_100726D00();
            id v162 = (void *)sub_10043E578(v70, v71, &aBlock);
            uint64_t v57 = v151;
            sub_100726830();
            swift_bridgeObjectRelease();
            sub_1004324A4(v62, type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey);
            _os_log_impl((void *)&_mh_execute_header, v67, v68, "%s: ratcheting failed for local key: %s", (uint8_t *)v69, 0x16u);
            swift_arrayDestroy();
            swift_slowDealloc();
            swift_slowDealloc();
          }
          else
          {

            sub_1004324A4(v62, type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey);
          }
          sub_100437C70(a1);
          uint64_t v106 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey;
          uint64_t v107 = v57;
        }
        else
        {
          uint64_t v93 = v148;
          sub_10043243C((uint64_t)v66, v148, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
          sub_1004323D4(v93, v63, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
          int v94 = sub_100725EB0();
          os_log_type_t v95 = sub_1007266E0();
          if (os_log_type_enabled(v94, v95))
          {
            uint64_t v96 = swift_slowAlloc();
            uint64_t aBlock = swift_slowAlloc();
            *(_DWORD *)uint64_t v96 = 136315394;
            id v162 = (void *)sub_10043E578(0x2874656863746172, 0xEB00000000293A5FLL, &aBlock);
            sub_100726830();
            *(_WORD *)(v96 + 12) = 2080;
            sub_10044C1AC(&qword_100A44D38, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
            uint64_t v97 = sub_100726D00();
            id v162 = (void *)sub_10043E578(v97, v98, &aBlock);
            uint64_t v57 = v151;
            sub_100726830();
            swift_bridgeObjectRelease();
            sub_1004324A4(v63, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
            _os_log_impl((void *)&_mh_execute_header, v94, v95, "%s: ratcheted to new local key: %s", (uint8_t *)v96, 0x16u);
            swift_arrayDestroy();
            uint64_t v61 = v154;
            swift_slowDealloc();
            swift_slowDealloc();
          }
          else
          {

            sub_1004324A4(v63, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
          }
          uint64_t v108 = v65;
          uint64_t v109 = v138;
          sub_1004323D4(v108, v138, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
          (*(void (**)(uint64_t, void, uint64_t, uint64_t))(v153 + 56))(v109, 0, 1, v61);
          uint64_t v110 = v150;
          sub_1004323D4(v148, v109 + *(int *)(v150 + 20), (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
          sub_1004323D4(v57 + *(int *)(v110 + 24), v109 + *(int *)(v110 + 24), (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
          sub_100725CB0();
          swift_storeEnumTagMultiPayload();
          sub_100432AA4(v109, a1);
          uint64_t v111 = a1 + *(int *)(v137 + 28);
          id v112 = (void *)swift_unknownObjectWeakLoadStrong();
          uint64_t v113 = *(void *)(v111 + 8);
          uint64_t v114 = v144;
          uint64_t v155 = *(void *)&v144[OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_q];
          uint64_t v115 = (void *)swift_allocObject();
          v115[2] = v112;
          v115[3] = v113;
          v115[4] = v114;
          uint64_t v160 = sub_10044154C;
          id v161 = v115;
          uint64_t aBlock = (uint64_t)_NSConcreteStackBlock;
          uint64_t v157 = 1107296256;
          id v158 = sub_100435714;
          id v159 = &unk_10098D8E0;
          uint64_t v116 = _Block_copy(&aBlock);
          v114;
          id v117 = v112;
          uint64_t v118 = v139;
          sub_100725F00();
          id v162 = &_swiftEmptyArrayStorage;
          sub_10044C1AC((unint64_t *)&unk_100A46890, (void (*)(uint64_t))&type metadata accessor for DispatchWorkItemFlags);
          sub_100431F80((uint64_t *)&unk_100A454C0);
          uint64_t v119 = v57;
          sub_1004413A8((unint64_t *)&qword_100A468A0, (uint64_t *)&unk_100A454C0);
          id v120 = v140;
          uint64_t v121 = v134;
          sub_100726890();
          sub_100726750();
          _Block_release(v116);
          (*(void (**)(char *, uint64_t))(v143 + 8))(v120, v121);
          (*(void (**)(char *, uint64_t))(v141 + 8))(v118, v142);
          swift_release();
          sub_100434CDC(a1);

          sub_1004324A4(v148, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
          uint64_t v106 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey;
          uint64_t v107 = v119;
        }
LABEL_37:
        sub_1004324A4(v107, v106);
        return;
      }
      __break(1u);
LABEL_39:
      __break(1u);
      return;
    }
    uint64_t v90 = sub_100725EB0();
    os_log_type_t v91 = sub_1007266E0();
    if (os_log_type_enabled(v90, v91))
    {
      uint64_t v92 = (uint8_t *)swift_slowAlloc();
      uint64_t aBlock = swift_slowAlloc();
      *(_DWORD *)uint64_t v92 = 136315138;
      uint64_t v163 = sub_10043E578(0x2874656863746172, 0xEB00000000293A5FLL, &aBlock);
      sub_100726830();
      _os_log_impl((void *)&_mh_execute_header, v90, v91, "%s: rolling because we have no key", v92, 0xCu);
      swift_arrayDestroy();
      swift_slowDealloc();
      swift_slowDealloc();
    }

    sub_100437C70(a1);
  }
}

void *sub_10043ABD4()
{
  uint64_t v1 = (void **)(v0 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_persistenceManager);
  swift_beginAccess();
  uint64_t v2 = *v1;
  id v3 = v2;
  return v2;
}

void sub_10043AC24(void *a1)
{
  id v3 = (void **)(v1 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_persistenceManager);
  swift_beginAccess();
  uint64_t v4 = *v3;
  *id v3 = a1;
}

uint64_t (*sub_10043AC78())()
{
  return j_j__swift_endAccess;
}

uint64_t sub_10043ACD4()
{
  uint64_t v1 = (unsigned int *)(v0 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_rollIndex);
  swift_beginAccess();
  return *v1;
}

uint64_t sub_10043AD1C(int a1)
{
  id v3 = (_DWORD *)(v1 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_rollIndex);
  uint64_t result = swift_beginAccess();
  *id v3 = a1;
  return result;
}

uint64_t (*sub_10043AD68())()
{
  return j_j__swift_endAccess;
}

uint64_t sub_10043ADC4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  id v3 = v2;
  uint64_t v6 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v9 = __chkstk_darwin(v6, v8);
  uint64_t v144 = (uint64_t)&v132 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v9, v11);
  CFStringRef v146 = (char *)&v132 - v12;
  uint64_t v13 = sub_100725CC0();
  uint64_t v141 = *(void *)(v13 - 8);
  __chkstk_darwin(v13, v14);
  uint64_t v145 = (uint64_t)&v132 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = sub_100431F80(&qword_100A44D30);
  __chkstk_darwin(v16 - 8, v17);
  uint64_t v19 = (char *)&v132 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = sub_100725D30();
  uint64_t v21 = *(void *)(v20 - 8);
  uint64_t v150 = v20;
  uint64_t v151 = v21;
  uint64_t v23 = __chkstk_darwin(v20, v22);
  uint64_t v143 = (char *)&v132 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v26 = __chkstk_darwin(v23, v25);
  uint64_t v28 = (char *)&v132 - v27;
  uint64_t v30 = __chkstk_darwin(v26, v29);
  uint64_t v32 = (char *)&v132 - v31;
  uint64_t v34 = __chkstk_darwin(v30, v33);
  uint64_t v152 = (char *)&v132 - v35;
  if (((*(uint64_t (**)(uint64_t))((swift_isaMask & *v2) + 0xB0))(v34) & 1) == 0)
  {
    uint64_t v142 = a1;
    BOOL v54 = sub_100725EB0();
    os_log_type_t v55 = sub_1007266E0();
    BOOL v56 = os_log_type_enabled(v54, v55);
    uint64_t v148 = a2;
    uint64_t v149 = v6;
    uint64_t v147 = v7;
    if (v56)
    {
      uint64_t v57 = (uint8_t *)swift_slowAlloc();
      uint64_t v153 = swift_slowAlloc();
      *(_DWORD *)uint64_t v57 = 136315138;
      v156[0] = sub_10043E578(0xD00000000000001BLL, 0x80000001008C07E0, &v153);
      sub_100726830();
      _os_log_impl((void *)&_mh_execute_header, v54, v55, "%s: Generting key with normal UUID KI", v57, 0xCu);
      swift_arrayDestroy();
      swift_slowDealloc();
      swift_slowDealloc();
    }

    goto LABEL_22;
  }
  if (!a1)
  {
    uint64_t v58 = sub_100725EB0();
    uint64_t v59 = sub_1007266E0();
    if (os_log_type_enabled(v58, (os_log_type_t)v59))
    {
      uint64_t v60 = (uint8_t *)swift_slowAlloc();
      uint64_t v153 = swift_slowAlloc();
      *(_DWORD *)uint64_t v60 = 136315138;
      v156[0] = sub_10043E578(0xD00000000000001BLL, 0x80000001008C07E0, &v153);
      sub_100726830();
      _os_log_impl((void *)&_mh_execute_header, v58, (os_log_type_t)v59, "%s: Generting key abort because we don't have a participant ID yet to form short MKI", v60, 0xCu);
      uint64_t v61 = 1;
      swift_arrayDestroy();
      swift_slowDealloc();
      swift_slowDealloc();
    }
    else
    {

      uint64_t v61 = 1;
    }
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v7 + 56))(a2, v61, 1, v6);
  }
  uint64_t v147 = v7;
  uint64_t v149 = v6;
  uint64_t v36 = *(uint64_t (**)(void))((swift_isaMask & *v2) + 0x1B8);
  uint64_t v140 = (swift_isaMask & *v2) + 440;
  int v37 = v36();
  uint64_t v148 = a2;
  uint64_t v142 = a1;
  uint64_t v139 = v36;
  if (v37 != 1
    || (uint64_t v38 = (*(uint64_t (**)(void))((swift_isaMask & *v2) + 0x1A0))()) == 0
    || (v39 = (void *)v38, unint64_t v40 = sub_100559B0C(a1, 0), v39, (v40 & 0x100000000) != 0))
  {
LABEL_18:
    unsigned int v62 = v36();
    unint64_t v63 = sub_100482EA4(v62, 0);
    unsigned int v64 = v63;
    unint64_t v137 = HIDWORD(v63);
    uint64_t v138 = v65;
    sub_100483D2C(v63, v65, (uint64_t)v19);
    uint64_t v67 = v150;
    uint64_t v66 = v151;
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v151 + 48))(v19, 1, v150) != 1)
    {
      (*(void (**)(char *, char *, uint64_t))(v66 + 32))(v32, v19, v67);
      uint64_t v136 = *(void (**)(char *, char *, uint64_t))(v66 + 16);
      v136(v28, v32, v67);
      uint64_t v113 = sub_100725EB0();
      os_log_type_t v114 = sub_1007266E0();
      int v115 = v114;
      if (os_log_type_enabled(v113, v114))
      {
        uint64_t v116 = swift_slowAlloc();
        os_log_t v135 = (os_log_t)swift_slowAlloc();
        v156[0] = (uint64_t)v135;
        *(_DWORD *)uint64_t v116 = 136315650;
        os_log_t v134 = v113;
        uint64_t v153 = sub_10043E578(0xD00000000000001BLL, 0x80000001008C07E0, v156);
        int v133 = v115;
        sub_100726830();
        *(_WORD *)(v116 + 12) = 2080;
        uint64_t v132 = v116 + 14;
        sub_10044C1AC(&qword_100A45210, (void (*)(uint64_t))&type metadata accessor for UUID);
        uint64_t v117 = sub_100726D00();
        uint64_t v153 = sub_10043E578(v117, v118, v156);
        sub_100726830();
        swift_bridgeObjectRelease();
        uint64_t v119 = *(void (**)(char *, uint64_t))(v151 + 8);
        v119(v28, v67);
        *(_WORD *)(v116 + 22) = 2080;
        uint64_t v153 = __PAIR64__(v137, v64);
        uint64_t v154 = v138;
        uint64_t v120 = sub_100726480();
        uint64_t v153 = sub_10043E578(v120, v121, v156);
        sub_100726830();
        swift_bridgeObjectRelease();
        os_log_t v122 = v134;
        _os_log_impl((void *)&_mh_execute_header, v134, (os_log_type_t)v133, "%s: Generted keyIndex %s with [ShortKI info: %s]", (uint8_t *)v116, 0x20u);
        swift_arrayDestroy();
        swift_slowDealloc();
        swift_slowDealloc();
      }
      else
      {

        uint64_t v119 = *(void (**)(char *, uint64_t))(v66 + 8);
        v119(v28, v67);
      }
      uint64_t v123 = ((uint64_t (*)(char *, char *, uint64_t))v136)(v152, v32, v67);
      uint64_t v124 = (*(uint64_t (**)(uint64_t))((swift_isaMask & *v3) + 0x1A0))(v123);
      uint64_t v125 = v139;
      if (v124)
      {
        id v126 = (void *)v124;
        int v127 = v139();
        uint64_t v128 = v145;
        sub_100725CB0();
        sub_10055FA50(v142, v127, v128, 0, 0);

        uint64_t v124 = (*(uint64_t (**)(uint64_t, uint64_t))(v141 + 8))(v128, v13);
      }
      unsigned int v129 = ((uint64_t (*)(uint64_t))v125)(v124);
      if (v129 >= *(_DWORD *)sub_100482E98())
      {
        (*(void (**)(uint64_t))((swift_isaMask & *v3) + 0x1C0))(1);
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t *))((swift_isaMask & *v3) + 0x1C8))(&v153);
        if (*v130 == -1)
        {
LABEL_50:
          __break(1u);
          goto LABEL_51;
        }
        ++*v130;
        ((void (*)(uint64_t *, void))result)(&v153, 0);
      }
      v119(v32, v67);
      char v73 = 2;
LABEL_23:
      uint64_t v74 = (void *)((char *)v3
                     + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_cryptoHandler);
      uint64_t v75 = *(void *)((char *)v3
                      + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_cryptoHandler
                      + 24);
      uint64_t v76 = *(void *)((char *)v3
                      + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_cryptoHandler
                      + 32);
      sub_10044C0F4((void *)((char *)v3+ OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_cryptoHandler), v75);
      uint64_t v77 = (*(uint64_t (**)(uint64_t, uint64_t))(v76 + 40))(v75, v76);
      unint64_t v79 = v78;
      LOBYTE(v76) = v80;
      uint64_t v81 = v74[3];
      uint64_t v82 = v74[4];
      sub_10044C0F4(v74, v81);
      uint64_t v83 = (*(uint64_t (**)(uint64_t, uint64_t))(v82 + 48))(v81, v82);
      uint64_t v86 = v83;
      unint64_t v87 = v84;
      char v88 = v85;
      if (v76)
      {
        sub_10044C138(v77, v79, 1);
        swift_errorRetain();
        swift_errorRetain();
        unint64_t v89 = sub_100725EB0();
        os_log_type_t v94 = sub_1007266C0();
        if (os_log_type_enabled(v89, v94))
        {
          uint64_t v95 = swift_slowAlloc();
          uint64_t v153 = swift_slowAlloc();
          *(_DWORD *)uint64_t v95 = 136315394;
          v156[0] = sub_10043E578(0xD00000000000001BLL, 0x80000001008C07E0, &v153);
          sub_100726830();
          *(_WORD *)(v95 + 12) = 2080;
          v156[0] = v77;
          swift_errorRetain();
          sub_100431F80(&qword_100A46DA0);
          uint64_t v96 = sub_100726480();
          uint64_t v145 = v87;
          v156[0] = sub_10043E578(v96, v97, &v153);
          sub_100726830();
          swift_bridgeObjectRelease();
          uint64_t v61 = 1;
          sub_10044C144(v77, v79, 1);
          sub_10044C144(v77, v79, 1);
          _os_log_impl((void *)&_mh_execute_header, v89, v94, "%s: error: %s", (uint8_t *)v95, 0x16u);
          swift_arrayDestroy();
          swift_slowDealloc();
          swift_slowDealloc();

          sub_10044C144(v86, v145, v88 & 1);
          sub_10044C144(v77, v79, 1);
          sub_10044C144(v77, v79, 1);
          goto LABEL_37;
        }
        uint64_t v61 = 1;
        sub_10044C144(v77, v79, 1);
        sub_10044C144(v86, v87, v88 & 1);
        sub_10044C144(v77, v79, 1);
        sub_10044C144(v77, v79, 1);
LABEL_36:
        swift_errorRelease();

        goto LABEL_37;
      }
      if (v85)
      {
        sub_10044C138(v83, v84, 1);
        sub_10044C138(v86, v87, 1);
        sub_10044C138(v86, v87, 1);
        sub_10044C138(v77, v79, 0);
        unint64_t v89 = sub_100725EB0();
        os_log_type_t v90 = sub_1007266C0();
        if (os_log_type_enabled(v89, v90))
        {
          uint64_t v91 = swift_slowAlloc();
          uint64_t v153 = swift_slowAlloc();
          *(_DWORD *)uint64_t v91 = 136315394;
          v156[0] = sub_10043E578(0xD00000000000001BLL, 0x80000001008C07E0, &v153);
          sub_100726830();
          *(_WORD *)(v91 + 12) = 2080;
          v156[0] = v86;
          swift_errorRetain();
          sub_100431F80(&qword_100A46DA0);
          uint64_t v92 = sub_100726480();
          v156[0] = sub_10043E578(v92, v93, &v153);
          sub_100726830();
          swift_bridgeObjectRelease();
          uint64_t v61 = 1;
          sub_10044C144(v86, v87, 1);
          sub_10044C144(v86, v87, 1);
          _os_log_impl((void *)&_mh_execute_header, v89, v90, "%s: error: %s", (uint8_t *)v91, 0x16u);
          swift_arrayDestroy();
          swift_slowDealloc();
          swift_slowDealloc();

          sub_10044C144(v77, v79, 0);
          sub_10044C144(v86, v87, 1);
          sub_10044C144(v86, v87, 1);
          sub_10044C144(v77, v79, 0);
LABEL_37:
          (*(void (**)(char *, uint64_t))(v151 + 8))(v152, v150);
          a2 = v148;
          uint64_t v6 = v149;
          uint64_t v7 = v147;
          return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v7 + 56))(a2, v61, 1, v6);
        }
        sub_10044C144(v77, v79, 0);
        uint64_t v61 = 1;
        sub_10044C144(v86, v87, 1);
        sub_10044C144(v77, v79, 0);
        sub_10044C144(v86, v87, 1);
        sub_10044C144(v86, v87, 1);
        goto LABEL_36;
      }
      char v98 = v73;
      uint64_t result = swift_beginAccess();
      if (dword_100A531F8 != -1)
      {
        ++dword_100A531F8;
        uint64_t v99 = (uint64_t)v143;
        (*(void (**)(char *, char *, uint64_t))(v151 + 16))(v143, v152, v150);
        sub_10044C138(v77, v79, 0);
        sub_10044C138(v86, v87, 0);
        sub_10044C138(v86, v87, 0);
        sub_10044C138(v77, v79, 0);
        uint64_t v100 = v145;
        sub_100725CB0();
        uint64_t v101 = *(void *)((char *)v3
                         + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_groupID);
        int v102 = dword_100A531F8;
        uint64_t v103 = swift_bridgeObjectRetain();
        char v131 = v98;
        uint64_t v104 = v146;
        sub_1004846FC(1, v99, v86, v87, v77, v79, v100, v101, v146, v103, v102, 0, v131, v142, 0);
        uint64_t v105 = v144;
        sub_1004323D4((uint64_t)v104, v144, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
        uint64_t v106 = sub_100725EB0();
        os_log_type_t v107 = sub_1007266E0();
        if (os_log_type_enabled(v106, v107))
        {
          uint64_t v108 = swift_slowAlloc();
          uint64_t v145 = v87;
          uint64_t v109 = v108;
          uint64_t v143 = (char *)swift_slowAlloc();
          v156[0] = (uint64_t)v143;
          *(_DWORD *)uint64_t v109 = 136315394;
          uint64_t v155 = sub_10043E578(0xD00000000000001BLL, 0x80000001008C07E0, v156);
          sub_100726830();
          *(_WORD *)(v109 + 12) = 2080;
          sub_10044C1AC(&qword_100A44D38, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
          uint64_t v110 = sub_100726D00();
          uint64_t v155 = sub_10043E578(v110, v111, v156);
          sub_100726830();
          swift_bridgeObjectRelease();
          sub_1004324A4(v105, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
          _os_log_impl((void *)&_mh_execute_header, v106, v107, "%s: Created key %s", (uint8_t *)v109, 0x16u);
          swift_arrayDestroy();
          swift_slowDealloc();
          swift_slowDealloc();

          sub_10044C144(v77, v79, 0);
          unint64_t v112 = v145;
          sub_10044C144(v86, v145, 0);
          sub_10044C144(v86, v112, 0);
          sub_10044C144(v77, v79, 0);
        }
        else
        {
          sub_10044C144(v77, v79, 0);
          sub_10044C144(v86, v87, 0);
          sub_10044C144(v86, v87, 0);
          sub_10044C144(v77, v79, 0);
          sub_1004324A4(v105, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
        }
        (*(void (**)(char *, uint64_t))(v151 + 8))(v152, v150);
        uint64_t v7 = v147;
        a2 = v148;
        sub_10043243C((uint64_t)v146, v148, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
        uint64_t v61 = 0;
        uint64_t v6 = v149;
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v7 + 56))(a2, v61, 1, v6);
      }
      __break(1u);
      goto LABEL_50;
    }
    sub_10044C150((uint64_t)v19, &qword_100A44D30);
    os_log_type_t v68 = sub_100725EB0();
    os_log_type_t v69 = sub_1007266C0();
    if (os_log_type_enabled(v68, v69))
    {
      uint64_t v70 = swift_slowAlloc();
      v156[0] = swift_slowAlloc();
      *(_DWORD *)uint64_t v70 = 136315394;
      uint64_t v153 = sub_10043E578(0xD00000000000001BLL, 0x80000001008C07E0, v156);
      sub_100726830();
      *(_WORD *)(v70 + 12) = 2080;
      uint64_t v153 = __PAIR64__(v137, v64);
      uint64_t v154 = v138;
      uint64_t v71 = sub_100726480();
      uint64_t v153 = sub_10043E578(v71, v72, v156);
      sub_100726830();
      swift_bridgeObjectRelease();
      _os_log_impl((void *)&_mh_execute_header, v68, v69, "%s: Failed to generate keyIndex with [ShortKI info: %s]", (uint8_t *)v70, 0x16u);
      swift_arrayDestroy();
      swift_slowDealloc();
      swift_slowDealloc();
    }

LABEL_22:
    sub_100725D20();
    char v73 = 0;
    goto LABEL_23;
  }
  uint64_t result = (v40 + 1);
  if (v40 != -1)
  {
    uint64_t v42 = *(uint64_t (**)(uint64_t))((swift_isaMask & *v3) + 0x1C0);
    uint64_t v43 = v42(result);
    unsigned int v44 = ((uint64_t (*)(uint64_t))v139)(v43);
    if (*(_DWORD *)sub_100482E98() < v44) {
      v42(1);
    }
    uint64_t v45 = v3;
    uint64_t v46 = sub_100725EB0();
    os_log_type_t v47 = sub_1007266E0();
    int v48 = v47;
    if (os_log_type_enabled(v46, v47))
    {
      uint64_t v49 = swift_slowAlloc();
      uint64_t v136 = v45;
      uint64_t v50 = v49;
      uint64_t v138 = swift_slowAlloc();
      uint64_t v153 = v138;
      *(_DWORD *)uint64_t v50 = 136315650;
      LODWORD(v137) = v48;
      v156[0] = sub_10043E578(0xD00000000000001BLL, 0x80000001008C07E0, &v153);
      os_log_t v135 = v46;
      sub_100726830();
      *(_WORD *)(v50 + 12) = 1024;
      LODWORD(v156[0]) = v40;
      uint64_t v51 = sub_100726830();
      *(_WORD *)(v50 + 1_Block_object_dispose(&STACK[0x320], 8) = 1024;
      uint64_t v52 = v136;
      LODWORD(v156[0]) = ((uint64_t (*)(uint64_t))v139)(v51);
      sub_100726830();

      os_log_t v53 = v135;
      _os_log_impl((void *)&_mh_execute_header, v135, (os_log_type_t)v137, "%s: Found cached rollIndex %u, continuing from %u", (uint8_t *)v50, 0x18u);
      swift_arrayDestroy();
      swift_slowDealloc();
      uint64_t v36 = v139;
      swift_slowDealloc();
    }
    else
    {

      uint64_t v36 = v139;
    }
    goto LABEL_18;
  }
LABEL_51:
  __break(1u);
  return result;
}

void *sub_10043C508()
{
  uint64_t v1 = sub_100431F80(&qword_100A44A50);
  uint64_t v3 = __chkstk_darwin(v1 - 8, v2);
  uint64_t v5 = (char *)&v30 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v3, v6);
  uint64_t v8 = (char *)&v30 - v7;
  uint64_t v9 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  uint64_t v10 = *(void *)(v9 - 8);
  uint64_t v12 = __chkstk_darwin(v9, v11);
  uint64_t v30 = (uint64_t)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = __chkstk_darwin(v12, v14);
  uint64_t v17 = (char *)&v30 - v16;
  uint64_t v19 = __chkstk_darwin(v15, v18);
  uint64_t v21 = (char *)&v30 - v20;
  uint64_t v23 = __chkstk_darwin(v19, v22);
  uint64_t v25 = (char *)&v30 - v24;
  uint64_t v31 = &_swiftEmptySetSingleton;
  (*(void (**)(uint64_t))((swift_isaMask & *v0) + 0x118))(v23);
  uint64_t v26 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v10 + 48);
  if (v26(v8, 1, v9) == 1)
  {
    uint64_t v27 = sub_10044C150((uint64_t)v8, &qword_100A44A50);
  }
  else
  {
    sub_10043243C((uint64_t)v8, (uint64_t)v25, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    sub_1004323D4((uint64_t)v25, (uint64_t)v17, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    sub_10043F7EC((uint64_t)v21, (uint64_t)v17);
    sub_1004324A4((uint64_t)v21, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    uint64_t v27 = sub_1004324A4((uint64_t)v25, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
  }
  (*(void (**)(uint64_t))((swift_isaMask & *v0) + 0x120))(v27);
  if (v26(v5, 1, v9) == 1)
  {
    sub_10044C150((uint64_t)v5, &qword_100A44A50);
  }
  else
  {
    uint64_t v28 = v30;
    sub_10043243C((uint64_t)v5, v30, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    sub_1004323D4(v28, (uint64_t)v17, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    sub_10043F7EC((uint64_t)v21, (uint64_t)v17);
    sub_1004324A4((uint64_t)v21, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    sub_1004324A4(v28, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
  }
  return v31;
}

id sub_10043CA8C()
{
  uint64_t v1 = sub_100431F80(&qword_100A44A50);
  __chkstk_darwin(v1 - 8, v2);
  uint64_t v4 = (char *)&v13 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v5 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v8 = __chkstk_darwin(v5, v7);
  uint64_t v10 = (char *)&v13 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(uint64_t))((swift_isaMask & *v0) + 0x118))(v8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v6 + 48))(v4, 1, v5) == 1)
  {
    sub_10044C150((uint64_t)v4, &qword_100A44A50);
    return 0;
  }
  else
  {
    sub_10043243C((uint64_t)v4, (uint64_t)v10, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    id v11 = sub_10048391C();
    sub_1004324A4((uint64_t)v10, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
  }
  return v11;
}

uint64_t sub_10043CC50(uint64_t a1)
{
  uint64_t v2 = sub_100725EF0();
  uint64_t v43 = *(void *)(v2 - 8);
  uint64_t v44 = v2;
  __chkstk_darwin(v2, v3);
  uint64_t v41 = (char *)&v39 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v42 = sub_100725F20();
  uint64_t v40 = *(void *)(v42 - 8);
  __chkstk_darwin(v42, v5);
  uint64_t v7 = (char *)&v39 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = sub_100431F80(&qword_100A44A50);
  __chkstk_darwin(v8 - 8, v9);
  id v11 = (char *)&v39 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  uint64_t v13 = *(void *)(v12 - 8);
  __chkstk_darwin(v12, v14);
  uint64_t v16 = (char *)&v39 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v17 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState(0);
  uint64_t v19 = __chkstk_darwin(v17, v18);
  uint64_t v21 = (char *)&v39 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v19, v22);
  uint64_t v24 = (char *)&v39 - v23;
  sub_1004323D4(a1, (uint64_t)&v39 - v23, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
  int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
  uint64_t result = sub_1004324A4((uint64_t)v24, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
  if (EnumCaseMultiPayload == 2)
  {
    uint64_t v27 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0);
    sub_10043ADC4(*(void *)(a1 + *(int *)(v27 + 32)), (uint64_t)v11);
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v13 + 48))(v11, 1, v12) == 1)
    {
      sub_10044C150((uint64_t)v11, &qword_100A44A50);
    }
    else
    {
      sub_10043243C((uint64_t)v11, (uint64_t)v16, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v13 + 56))(v21, 1, 1, v12);
      uint64_t v28 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(0);
      sub_1004323D4((uint64_t)v16, (uint64_t)&v21[*(int *)(v28 + 20)], (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
      sub_100725CB0();
      swift_storeEnumTagMultiPayload();
      sub_100432AA4((uint64_t)v21, a1);
      uint64_t v29 = a1 + *(int *)(v27 + 28);
      uint64_t Strong = (void *)swift_unknownObjectWeakLoadStrong();
      uint64_t v31 = *(void *)(v29 + 8);
      uint64_t v32 = v45;
      uint64_t v39 = *(void *)&v45[OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_q];
      uint64_t v33 = (void *)swift_allocObject();
      v33[2] = Strong;
      v33[3] = v31;
      v33[4] = v32;
      aBlock[4] = sub_10044154C;
      aBlock[5] = v33;
      aBlock[0] = _NSConcreteStackBlock;
      aBlock[1] = 1107296256;
      aBlock[2] = sub_100435714;
      aBlock[3] = &unk_10098D618;
      uint64_t v34 = _Block_copy(aBlock);
      id v35 = Strong;
      id v36 = v32;
      sub_100725F00();
      uint64_t v46 = &_swiftEmptyArrayStorage;
      sub_10044C1AC((unint64_t *)&unk_100A46890, (void (*)(uint64_t))&type metadata accessor for DispatchWorkItemFlags);
      sub_100431F80((uint64_t *)&unk_100A454C0);
      sub_1004413A8((unint64_t *)&qword_100A468A0, (uint64_t *)&unk_100A454C0);
      int v37 = v41;
      uint64_t v38 = v44;
      sub_100726890();
      sub_100726750();
      _Block_release(v34);

      (*(void (**)(char *, uint64_t))(v43 + 8))(v37, v38);
      (*(void (**)(char *, uint64_t))(v40 + 8))(v7, v42);
      sub_1004324A4((uint64_t)v16, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
      swift_release();
    }
    return sub_1004359C4(a1);
  }
  return result;
}

void sub_10043D1E0()
{
  uint64_t v1 = (os_unfair_lock_s *)(*(void *)(v0
                                      + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state)
                          + ((*(unsigned int *)(**(void **)(v0
                                                            + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state)
                                              + 48)
                            + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v1);
  sub_1004415B4();
  os_unfair_lock_unlock(v1);
}

void sub_10043D344()
{
  uint64_t v1 = *(void *)(v0 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state);
  uint64_t v2 = v1 + *(void *)(class metadata base offset for ManagedBuffer + *(void *)v1 + 16);
  uint64_t v3 = (os_unfair_lock_s *)(v1 + ((*(unsigned int *)(*(void *)v1 + 48) + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v3);
  sub_1004415CC(v2);
  os_unfair_lock_unlock(v3);
}

void sub_10043D3EC()
{
  uint64_t v1 = *(void *)(v0 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state);
  uint64_t v2 = v1 + *(void *)(class metadata base offset for ManagedBuffer + *(void *)v1 + 16);
  uint64_t v3 = (os_unfair_lock_s *)(v1 + ((*(unsigned int *)(*(void *)v1 + 48) + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v3);
  sub_1004417B8(v2);
  os_unfair_lock_unlock(v3);
}

void sub_10043D498(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v94 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey(0);
  __chkstk_darwin(v94, v8);
  uint64_t v95 = (uint64_t)&v92 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(0);
  __chkstk_darwin(v10 - 8, v11);
  uint64_t v93 = (uint64_t)&v92 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v104 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState(0);
  uint64_t v14 = __chkstk_darwin(v104, v13);
  uint64_t v99 = (uint64_t)&v92 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v14, v16);
  uint64_t v96 = (uint64_t)&v92 - v17;
  uint64_t v107 = sub_100431F80(&qword_100A44A50);
  uint64_t v19 = __chkstk_darwin(v107, v18);
  uint64_t v100 = (char *)&v92 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = __chkstk_darwin(v19, v21);
  uint64_t v98 = (uint64_t)&v92 - v23;
  __chkstk_darwin(v22, v24);
  uint64_t v97 = (uint64_t)&v92 - v25;
  uint64_t v101 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0);
  uint64_t v27 = __chkstk_darwin(v101, v26);
  uint64_t v105 = (uint64_t)&v92 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v30 = __chkstk_darwin(v27, v29);
  uint64_t v106 = (uint64_t)&v92 - v31;
  uint64_t v33 = __chkstk_darwin(v30, v32);
  uint64_t v103 = (uint64_t)&v92 - v34;
  uint64_t v36 = __chkstk_darwin(v33, v35);
  uint64_t v102 = (uint64_t)&v92 - v37;
  __chkstk_darwin(v36, v38);
  uint64_t v40 = (char *)&v92 - v39;
  uint64_t v108 = a4;
  sub_1004323D4(a4, (uint64_t)&v92 - v39, type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
  swift_bridgeObjectRetain_n();
  uint64_t v110 = a1;
  uint64_t v41 = sub_100725EB0();
  os_log_type_t v42 = sub_1007266E0();
  BOOL v43 = os_log_type_enabled(v41, v42);
  uint64_t v109 = a2;
  if (v43)
  {
    uint64_t v44 = swift_slowAlloc();
    v112[0] = swift_slowAlloc();
    *(_DWORD *)uint64_t v44 = 136315394;
    swift_bridgeObjectRetain();
    uint64_t v111 = sub_10043E578(a2, a3, v112);
    sub_100726830();
    swift_bridgeObjectRelease_n();
    *(_WORD *)(v44 + 12) = 2080;
    uint64_t v45 = sub_100432794();
    uint64_t v111 = sub_10043E578(v45, v46, v112);
    sub_100726830();
    swift_bridgeObjectRelease();
    sub_1004324A4((uint64_t)v40, type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
    _os_log_impl((void *)&_mh_execute_header, v41, v42, "%sKeyMaterialController (%s)", (uint8_t *)v44, 0x16u);
    swift_arrayDestroy();
    swift_slowDealloc();
    swift_slowDealloc();
  }
  else
  {
    swift_bridgeObjectRelease_n();

    sub_1004324A4((uint64_t)v40, type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
  }
  uint64_t v47 = v108;
  uint64_t v48 = v102;
  sub_1004323D4(v108, v102, type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
  swift_bridgeObjectRetain_n();
  uint64_t v49 = sub_100725EB0();
  os_log_type_t v50 = sub_1007266E0();
  if (!os_log_type_enabled(v49, v50))
  {
    swift_bridgeObjectRelease_n();

    sub_1004324A4(v48, type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
    goto LABEL_13;
  }
  uint64_t v51 = swift_slowAlloc();
  v112[0] = swift_slowAlloc();
  *(_DWORD *)uint64_t v51 = 136315394;
  swift_bridgeObjectRetain();
  uint64_t v111 = sub_10043E578(v109, a3, v112);
  sub_100726830();
  swift_bridgeObjectRelease_n();
  *(_WORD *)(v51 + 12) = 2080;
  uint64_t v52 = v96;
  sub_1004323D4(v48, v96, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
  int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
  if (EnumCaseMultiPayload)
  {
    uint64_t v54 = v97;
    if (EnumCaseMultiPayload != 1)
    {
      uint64_t v60 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v60 - 8) + 56))(v54, 1, 1, v60);
      goto LABEL_12;
    }
    uint64_t v55 = v95;
    sub_10043243C(v52, v95, type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey);
    sub_100431F18(v55, v54);
    BOOL v56 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey;
    uint64_t v57 = v55;
  }
  else
  {
    uint64_t v58 = v52;
    uint64_t v59 = v93;
    sub_10043243C(v58, v93, type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey);
    sub_100431F18(v59, v97);
    BOOL v56 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey;
    uint64_t v57 = v59;
  }
  sub_1004324A4(v57, v56);
LABEL_12:
  uint64_t v61 = sub_100726480();
  uint64_t v111 = sub_10043E578(v61, v62, v112);
  sub_100726830();
  swift_bridgeObjectRelease();
  sub_1004324A4(v48, type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
  _os_log_impl((void *)&_mh_execute_header, v49, v50, "%s    previous: %s", (uint8_t *)v51, 0x16u);
  swift_arrayDestroy();
  swift_slowDealloc();
  swift_slowDealloc();

  uint64_t v47 = v108;
LABEL_13:
  uint64_t v63 = v103;
  sub_1004323D4(v47, v103, type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
  swift_bridgeObjectRetain_n();
  unsigned int v64 = sub_100725EB0();
  os_log_type_t v65 = sub_1007266E0();
  if (os_log_type_enabled(v64, v65))
  {
    uint64_t v66 = swift_slowAlloc();
    v112[0] = swift_slowAlloc();
    *(_DWORD *)uint64_t v66 = 136315394;
    swift_bridgeObjectRetain();
    uint64_t v111 = sub_10043E578(v109, a3, v112);
    sub_100726830();
    swift_bridgeObjectRelease_n();
    *(_WORD *)(v66 + 12) = 2080;
    sub_100432504(v98);
    uint64_t v67 = sub_100726480();
    uint64_t v111 = sub_10043E578(v67, v68, v112);
    uint64_t v47 = v108;
    sub_100726830();
    swift_bridgeObjectRelease();
    sub_1004324A4(v63, type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
    _os_log_impl((void *)&_mh_execute_header, v64, v65, "%s    current: %s", (uint8_t *)v66, 0x16u);
    swift_arrayDestroy();
    swift_slowDealloc();
    swift_slowDealloc();
  }
  else
  {
    swift_bridgeObjectRelease_n();

    sub_1004324A4(v63, type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
  }
  uint64_t v69 = v106;
  sub_1004323D4(v47, v106, type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
  swift_bridgeObjectRetain_n();
  uint64_t v70 = sub_100725EB0();
  os_log_type_t v71 = sub_1007266E0();
  if (os_log_type_enabled(v70, v71))
  {
    uint64_t v72 = swift_slowAlloc();
    v112[0] = swift_slowAlloc();
    *(_DWORD *)uint64_t v72 = 136315394;
    swift_bridgeObjectRetain();
    uint64_t v111 = sub_10043E578(v109, a3, v112);
    sub_100726830();
    swift_bridgeObjectRelease_n();
    *(_WORD *)(v72 + 12) = 2080;
    uint64_t v73 = v99;
    sub_1004323D4(v69, v99, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
    int v74 = swift_getEnumCaseMultiPayload();
    if (v74)
    {
      uint64_t v75 = (uint64_t)v100;
      if (v74 == 1)
      {
        uint64_t v76 = v73;
        uint64_t v77 = v95;
        sub_10043243C(v76, v95, type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey);
        sub_1004323D4(v77 + *(int *)(v94 + 24), v75, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
        sub_1004324A4(v77, type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey);
        uint64_t v78 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
        (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v78 - 8) + 56))(v75, 0, 1, v78);
      }
      else
      {
        uint64_t v80 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v80 - 8) + 56))(v75, 1, 1, v80);
      }
    }
    else
    {
      uint64_t v79 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v79 - 8) + 56))(v100, 1, 1, v79);
      sub_1004324A4(v73, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
    }
    uint64_t v81 = sub_100726480();
    uint64_t v111 = sub_10043E578(v81, v82, v112);
    sub_100726830();
    swift_bridgeObjectRelease();
    sub_1004324A4(v106, type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
    _os_log_impl((void *)&_mh_execute_header, v70, v71, "%s    next: %s", (uint8_t *)v72, 0x16u);
    swift_arrayDestroy();
    swift_slowDealloc();
    swift_slowDealloc();
  }
  else
  {
    swift_bridgeObjectRelease_n();

    sub_1004324A4(v69, type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
  }
  swift_bridgeObjectRetain_n();
  uint64_t v83 = sub_100725EB0();
  os_log_type_t v84 = sub_1007266E0();
  if (os_log_type_enabled(v83, v84))
  {
    char v85 = (uint8_t *)swift_slowAlloc();
    v112[0] = swift_slowAlloc();
    *(_DWORD *)char v85 = 136315138;
    swift_bridgeObjectRetain();
    uint64_t v111 = sub_10043E578(v109, a3, v112);
    sub_100726830();
    swift_bridgeObjectRelease_n();
    _os_log_impl((void *)&_mh_execute_header, v83, v84, "%s    ", v85, 0xCu);
    swift_arrayDestroy();
    swift_slowDealloc();
    swift_slowDealloc();
  }
  else
  {
    swift_bridgeObjectRelease_n();
  }

  uint64_t v86 = v47;
  uint64_t v87 = v105;
  sub_1004323D4(v86, v105, type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
  swift_bridgeObjectRetain_n();
  char v88 = sub_100725EB0();
  os_log_type_t v89 = sub_1007266E0();
  if (os_log_type_enabled(v88, v89))
  {
    uint64_t v90 = swift_slowAlloc();
    v112[0] = swift_slowAlloc();
    *(_DWORD *)uint64_t v90 = 136315394;
    swift_bridgeObjectRetain();
    uint64_t v111 = sub_10043E578(v109, a3, v112);
    sub_100726830();
    swift_bridgeObjectRelease_n();
    *(_WORD *)(v90 + 12) = 2048;
    uint64_t v91 = *(void *)(v87 + *(int *)(v101 + 60));
    sub_1004324A4(v87, type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
    uint64_t v111 = v91;
    sub_100726830();
    _os_log_impl((void *)&_mh_execute_header, v88, v89, "%s    generation: %llu", (uint8_t *)v90, 0x16u);
    swift_arrayDestroy();
    swift_slowDealloc();
    swift_slowDealloc();
  }
  else
  {
    sub_1004324A4(v87, type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
    swift_bridgeObjectRelease_n();
  }
}

uint64_t sub_10043E40C()
{
  return (*(uint64_t (**)(void))((swift_isaMask & **v0) + 0x200))();
}

char *sub_10043E468(char *result, int64_t a2, char a3, char *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }
  unint64_t v6 = *((void *)a4 + 3);
  uint64_t v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2) {
    goto LABEL_8;
  }
  if (v7 + 0x4000000000000000 >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
      uint64_t v7 = a2;
    }
LABEL_8:
    uint64_t v8 = *((void *)a4 + 2);
    if (v7 <= v8) {
      uint64_t v9 = *((void *)a4 + 2);
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      sub_100431F80((uint64_t *)&unk_100A46D90);
      uint64_t v10 = (char *)swift_allocObject();
      int64_t v11 = j__malloc_size(v10);
      uint64_t v12 = v11 - 32;
      if (v11 < 32) {
        uint64_t v12 = v11 - 17;
      }
      *((void *)v10 + 2) = v8;
      *((void *)v10 + 3) = 2 * (v12 >> 4);
      uint64_t v13 = v10 + 32;
      if (v5) {
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v10 = (char *)&_swiftEmptyArrayStorage;
      uint64_t v13 = (char *)&_swiftEmptyArrayStorage + 32;
      if (result)
      {
LABEL_15:
        if (v10 != a4 || v13 >= &a4[16 * v8 + 32]) {
          memmove(v13, a4 + 32, 16 * v8);
        }
        *((void *)a4 + 2) = 0;
        goto LABEL_24;
      }
    }
    sub_10044C59C(0, v8, (unint64_t)v13, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease();
    return v10;
  }
  __break(1u);
  return result;
}

uint64_t sub_10043E578(uint64_t a1, unint64_t a2, uint64_t *a3)
{
  uint64_t v6 = sub_10043E64C(v12, 0, 0, 1, a1, a2);
  uint64_t v7 = v12[0];
  if (v6)
  {
    uint64_t v8 = v6;
    uint64_t ObjectType = (void *)swift_getObjectType();
    v12[0] = v8;
    uint64_t v9 = *a3;
    if (*a3)
    {
      sub_10044C6FC((uint64_t)v12, *a3);
      *a3 = v9 + 32;
    }
  }
  else
  {
    uint64_t ObjectType = &type metadata for _StringGuts;
    v12[0] = a1;
    v12[1] = a2;
    uint64_t v10 = *a3;
    if (*a3)
    {
      sub_10044C6FC((uint64_t)v12, *a3);
      *a3 = v10 + 32;
    }
    swift_bridgeObjectRetain();
  }
  sub_10044C6AC((uint64_t)v12);
  return v7;
}

uint64_t sub_10043E64C(uint64_t *a1, char *__dst, uint64_t a3, char a4, uint64_t a5, unint64_t a6)
{
  if ((a6 & 0x2000000000000000) != 0)
  {
    if ((a4 & 1) == 0)
    {
      if (__dst)
      {
        uint64_t v11 = HIBYTE(a6) & 0xF;
        if (a3 - (uint64_t)__dst > v11)
        {
          __src[0] = a5;
          __src[1] = a6 & 0xFFFFFFFFFFFFFFLL;
          if (__src >= (void *)&__dst[v11] || (char *)__src + v11 <= __dst)
          {
            memcpy(__dst, __src, HIBYTE(a6) & 0xF);
            sub_100726840();
            uint64_t result = 0;
            *a1 = (uint64_t)__dst;
            return result;
          }
          goto LABEL_17;
        }
      }
    }
LABEL_13:
    uint64_t result = sub_10043E808(a5, a6);
    *a1 = v12;
    return result;
  }
  if ((a6 & 0x1000000000000000) != 0) {
    goto LABEL_13;
  }
  if ((a5 & 0x1000000000000000) != 0)
  {
    uint64_t v8 = (a6 & 0xFFFFFFFFFFFFFFFLL) + 32;
    goto LABEL_5;
  }
  uint64_t v8 = sub_100726A30();
  if (!v8)
  {
    sub_100726B80();
    __break(1u);
LABEL_17:
    uint64_t result = sub_100726BF0();
    __break(1u);
    return result;
  }
LABEL_5:
  *a1 = v8;
  if ((a6 & 0x8000000000000000) != 0) {
    return 0;
  }
  else {
    return swift_unknownObjectRetain();
  }
}

uint64_t sub_10043E808(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = (uint64_t)sub_10043E8A0(a1, a2);
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
    uint64_t v2 = sub_10043EA80(0, *(void *)(v2 + 16) + 1, 1, (char *)v2);
  }
  unint64_t v4 = *(void *)(v2 + 16);
  unint64_t v3 = *(void *)(v2 + 24);
  if (v4 >= v3 >> 1) {
    uint64_t v2 = sub_10043EA80(v3 > 1, v4 + 1, 1, (char *)v2);
  }
  *(void *)(v2 + 16) = v4 + 1;
  *(unsigned char *)(v2 + 32 + v4) = 0;
  return v2;
}

void *sub_10043E8A0(uint64_t a1, unint64_t a2)
{
  if ((a2 & 0x1000000000000000) != 0) {
    goto LABEL_10;
  }
  if ((a2 & 0x2000000000000000) != 0) {
    uint64_t v2 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v2 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v2)
  {
    while (1)
    {
      unint64_t v3 = sub_10043EA18(v2, 0);
      if (v2 < 0) {
        break;
      }
      unint64_t v4 = v3;
      uint64_t v5 = sub_100726A00();
      if (v6) {
        goto LABEL_14;
      }
      if (v5 == v2) {
        return v4;
      }
      sub_100726B80();
      __break(1u);
LABEL_10:
      uint64_t v2 = sub_1007264D0();
      if (!v2) {
        return &_swiftEmptyArrayStorage;
      }
    }
    sub_100726BF0();
    __break(1u);
LABEL_14:
    uint64_t result = (void *)sub_100726B80();
    __break(1u);
  }
  else
  {
    return &_swiftEmptyArrayStorage;
  }
  return result;
}

void *sub_10043EA18(uint64_t a1, uint64_t a2)
{
  if (a2 <= a1) {
    uint64_t v2 = a1;
  }
  else {
    uint64_t v2 = a2;
  }
  if (!v2) {
    return &_swiftEmptyArrayStorage;
  }
  sub_100431F80((uint64_t *)&unk_100A45440);
  unint64_t v4 = (void *)swift_allocObject();
  size_t v5 = j__malloc_size(v4);
  _DWORD v4[2] = a1;
  void v4[3] = 2 * v5 - 64;
  return v4;
}

uint64_t sub_10043EA80(char a1, int64_t a2, char a3, char *a4)
{
  if (a3)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        goto LABEL_30;
      }
      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
        int64_t v7 = a2;
      }
    }
  }
  else
  {
    int64_t v7 = a2;
  }
  int64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    int64_t v9 = *((void *)a4 + 2);
  }
  else {
    int64_t v9 = v7;
  }
  if (v9)
  {
    sub_100431F80((uint64_t *)&unk_100A45440);
    uint64_t v10 = (char *)swift_allocObject();
    size_t v11 = j__malloc_size(v10);
    *((void *)v10 + 2) = v8;
    *((void *)v10 + 3) = 2 * v11 - 64;
  }
  else
  {
    uint64_t v10 = (char *)&_swiftEmptyArrayStorage;
  }
  uint64_t v12 = v10 + 32;
  uint64_t v13 = a4 + 32;
  if (a1)
  {
    if (v10 != a4 || v12 >= &v13[v8]) {
      memmove(v12, v13, v8);
    }
    *((void *)a4 + 2) = 0;
    goto LABEL_28;
  }
  if (v13 >= &v12[v8] || v12 >= &v13[v8])
  {
    memcpy(v12, v13, v8);
LABEL_28:
    swift_bridgeObjectRelease();
    return (uint64_t)v10;
  }
LABEL_30:
  uint64_t result = sub_100726BF0();
  __break(1u);
  return result;
}

uint64_t sub_10043EBD0()
{
  uint64_t v1 = v0;
  uint64_t v2 = *v0;
  sub_100431F80(&qword_100A44D48);
  uint64_t v3 = sub_1007269C0();
  uint64_t v4 = v3;
  if (*(void *)(v2 + 16))
  {
    uint64_t v28 = v0;
    uint64_t v5 = 1 << *(unsigned char *)(v2 + 32);
    unint64_t v6 = (void *)(v2 + 56);
    if (v5 < 64) {
      uint64_t v7 = ~(-1 << v5);
    }
    else {
      uint64_t v7 = -1;
    }
    unint64_t v8 = v7 & *(void *)(v2 + 56);
    int64_t v9 = (unint64_t)(v5 + 63) >> 6;
    uint64_t v10 = v3 + 56;
    uint64_t result = swift_retain();
    int64_t v12 = 0;
    while (1)
    {
      if (v8)
      {
        unint64_t v14 = __clz(__rbit64(v8));
        v8 &= v8 - 1;
        unint64_t v15 = v14 | (v12 << 6);
      }
      else
      {
        int64_t v16 = v12 + 1;
        if (__OFADD__(v12, 1))
        {
LABEL_38:
          __break(1u);
LABEL_39:
          __break(1u);
          return result;
        }
        if (v16 >= v9) {
          goto LABEL_33;
        }
        unint64_t v17 = v6[v16];
        ++v12;
        if (!v17)
        {
          int64_t v12 = v16 + 1;
          if (v16 + 1 >= v9) {
            goto LABEL_33;
          }
          unint64_t v17 = v6[v12];
          if (!v17)
          {
            int64_t v12 = v16 + 2;
            if (v16 + 2 >= v9) {
              goto LABEL_33;
            }
            unint64_t v17 = v6[v12];
            if (!v17)
            {
              int64_t v18 = v16 + 3;
              if (v18 >= v9)
              {
LABEL_33:
                swift_release();
                uint64_t v1 = v28;
                uint64_t v27 = 1 << *(unsigned char *)(v2 + 32);
                if (v27 > 63) {
                  bzero((void *)(v2 + 56), ((unint64_t)(v27 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
                }
                else {
                  *unint64_t v6 = -1 << v27;
                }
                *(void *)(v2 + 16) = 0;
                break;
              }
              unint64_t v17 = v6[v18];
              if (!v17)
              {
                while (1)
                {
                  int64_t v12 = v18 + 1;
                  if (__OFADD__(v18, 1)) {
                    goto LABEL_39;
                  }
                  if (v12 >= v9) {
                    goto LABEL_33;
                  }
                  unint64_t v17 = v6[v12];
                  ++v18;
                  if (v17) {
                    goto LABEL_23;
                  }
                }
              }
              int64_t v12 = v18;
            }
          }
        }
LABEL_23:
        unint64_t v8 = (v17 - 1) & v17;
        unint64_t v15 = __clz(__rbit64(v17)) + (v12 << 6);
      }
      uint64_t v19 = *(void *)(*(void *)(v2 + 48) + 8 * v15);
      uint64_t result = sub_1007267E0(*(void *)(v4 + 40));
      uint64_t v20 = -1 << *(unsigned char *)(v4 + 32);
      unint64_t v21 = result & ~v20;
      unint64_t v22 = v21 >> 6;
      if (((-1 << v21) & ~*(void *)(v10 + 8 * (v21 >> 6))) != 0)
      {
        unint64_t v13 = __clz(__rbit64((-1 << v21) & ~*(void *)(v10 + 8 * (v21 >> 6)))) | v21 & 0x7FFFFFFFFFFFFFC0;
      }
      else
      {
        char v23 = 0;
        unint64_t v24 = (unint64_t)(63 - v20) >> 6;
        do
        {
          if (++v22 == v24 && (v23 & 1) != 0)
          {
            __break(1u);
            goto LABEL_38;
          }
          BOOL v25 = v22 == v24;
          if (v22 == v24) {
            unint64_t v22 = 0;
          }
          v23 |= v25;
          uint64_t v26 = *(void *)(v10 + 8 * v22);
        }
        while (v26 == -1);
        unint64_t v13 = __clz(__rbit64(~v26)) + (v22 << 6);
      }
      *(void *)(v10 + ((v13 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v13;
      *(void *)(*(void *)(v4 + 48) + 8 * v13) = v19;
      ++*(void *)(v4 + 16);
    }
  }
  uint64_t result = swift_release();
  *uint64_t v1 = v4;
  return result;
}

uint64_t sub_10043EE70()
{
  uint64_t v1 = v0;
  uint64_t v2 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  uint64_t v34 = *(void *)(v2 - 8);
  __chkstk_darwin(v2, v3);
  uint64_t v5 = (char *)&v31 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = *v0;
  sub_100431F80(&qword_100A44D28);
  uint64_t v7 = sub_1007269C0();
  uint64_t v8 = v7;
  if (*(void *)(v6 + 16))
  {
    uint64_t v31 = v0;
    uint64_t v9 = 1 << *(unsigned char *)(v6 + 32);
    uint64_t v10 = *(void *)(v6 + 56);
    uint64_t v33 = (void *)(v6 + 56);
    if (v9 < 64) {
      uint64_t v11 = ~(-1 << v9);
    }
    else {
      uint64_t v11 = -1;
    }
    unint64_t v12 = v11 & v10;
    int64_t v32 = (unint64_t)(v9 + 63) >> 6;
    uint64_t v13 = v7 + 56;
    uint64_t result = swift_retain();
    int64_t v15 = 0;
    while (1)
    {
      if (v12)
      {
        unint64_t v17 = __clz(__rbit64(v12));
        v12 &= v12 - 1;
        unint64_t v18 = v17 | (v15 << 6);
      }
      else
      {
        int64_t v19 = v15 + 1;
        if (__OFADD__(v15, 1))
        {
LABEL_38:
          __break(1u);
LABEL_39:
          __break(1u);
          return result;
        }
        if (v19 >= v32) {
          goto LABEL_33;
        }
        unint64_t v20 = v33[v19];
        ++v15;
        if (!v20)
        {
          int64_t v15 = v19 + 1;
          if (v19 + 1 >= v32) {
            goto LABEL_33;
          }
          unint64_t v20 = v33[v15];
          if (!v20)
          {
            int64_t v15 = v19 + 2;
            if (v19 + 2 >= v32) {
              goto LABEL_33;
            }
            unint64_t v20 = v33[v15];
            if (!v20)
            {
              int64_t v21 = v19 + 3;
              if (v21 >= v32)
              {
LABEL_33:
                swift_release();
                uint64_t v1 = v31;
                uint64_t v30 = 1 << *(unsigned char *)(v6 + 32);
                if (v30 > 63) {
                  bzero(v33, ((unint64_t)(v30 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
                }
                else {
                  *uint64_t v33 = -1 << v30;
                }
                *(void *)(v6 + 16) = 0;
                break;
              }
              unint64_t v20 = v33[v21];
              if (!v20)
              {
                while (1)
                {
                  int64_t v15 = v21 + 1;
                  if (__OFADD__(v21, 1)) {
                    goto LABEL_39;
                  }
                  if (v15 >= v32) {
                    goto LABEL_33;
                  }
                  unint64_t v20 = v33[v15];
                  ++v21;
                  if (v20) {
                    goto LABEL_23;
                  }
                }
              }
              int64_t v15 = v21;
            }
          }
        }
LABEL_23:
        unint64_t v12 = (v20 - 1) & v20;
        unint64_t v18 = __clz(__rbit64(v20)) + (v15 << 6);
      }
      uint64_t v22 = *(void *)(v34 + 72);
      sub_10043243C(*(void *)(v6 + 48) + v22 * v18, (uint64_t)v5, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
      sub_10044C1AC(&qword_100A44D18, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
      uint64_t result = sub_1007263D0();
      uint64_t v23 = -1 << *(unsigned char *)(v8 + 32);
      unint64_t v24 = result & ~v23;
      unint64_t v25 = v24 >> 6;
      if (((-1 << v24) & ~*(void *)(v13 + 8 * (v24 >> 6))) != 0)
      {
        unint64_t v16 = __clz(__rbit64((-1 << v24) & ~*(void *)(v13 + 8 * (v24 >> 6)))) | v24 & 0x7FFFFFFFFFFFFFC0;
      }
      else
      {
        char v26 = 0;
        unint64_t v27 = (unint64_t)(63 - v23) >> 6;
        do
        {
          if (++v25 == v27 && (v26 & 1) != 0)
          {
            __break(1u);
            goto LABEL_38;
          }
          BOOL v28 = v25 == v27;
          if (v25 == v27) {
            unint64_t v25 = 0;
          }
          v26 |= v28;
          uint64_t v29 = *(void *)(v13 + 8 * v25);
        }
        while (v29 == -1);
        unint64_t v16 = __clz(__rbit64(~v29)) + (v25 << 6);
      }
      *(void *)(v13 + ((v16 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v16;
      uint64_t result = sub_10043243C((uint64_t)v5, *(void *)(v8 + 48) + v16 * v22, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
      ++*(void *)(v8 + 16);
    }
  }
  uint64_t result = swift_release();
  *uint64_t v1 = v8;
  return result;
}

uint64_t sub_10043F248(uint64_t isStackAllocationSafe, uint64_t a2)
{
  uint64_t v3 = isStackAllocationSafe;
  char v4 = *(unsigned char *)(isStackAllocationSafe + 32);
  unint64_t v5 = (unint64_t)((1 << v4) + 63) >> 6;
  size_t v6 = 8 * v5;
  if ((v4 & 0x3Fu) <= 0xD
    || (isStackAllocationSafe = swift_stdlib_isStackAllocationSafe(), (isStackAllocationSafe & 1) != 0))
  {
    __chkstk_darwin(isStackAllocationSafe, a2);
    bzero((char *)&v12 - ((v6 + 15) & 0x3FFFFFFFFFFFFFF0), v6);
    sub_10043F3AC((unint64_t *)((char *)&v12 - ((v6 + 15) & 0x3FFFFFFFFFFFFFF0)), v5, v3);
    uint64_t v8 = v7;
    swift_release();
    if (v2) {
      swift_willThrow();
    }
  }
  else
  {
    uint64_t v9 = (void *)swift_slowAlloc();
    bzero(v9, v6);
    sub_10043F3AC((unint64_t *)v9, v5, v3);
    uint64_t v8 = v10;
    swift_release();
    swift_slowDealloc();
  }
  return v8;
}

void sub_10043F3AC(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v21 = 0;
  int64_t v4 = 0;
  uint64_t v5 = a3 + 56;
  uint64_t v6 = 1 << *(unsigned char *)(a3 + 32);
  uint64_t v7 = -1;
  if (v6 < 64) {
    uint64_t v7 = ~(-1 << v6);
  }
  unint64_t v8 = v7 & *(void *)(a3 + 56);
  int64_t v9 = (unint64_t)(v6 + 63) >> 6;
  while (1)
  {
    if (v8)
    {
      unint64_t v10 = __clz(__rbit64(v8));
      v8 &= v8 - 1;
      unint64_t v11 = v10 | (v4 << 6);
      goto LABEL_5;
    }
    int64_t v15 = v4 + 1;
    if (__OFADD__(v4, 1))
    {
      __break(1u);
      goto LABEL_26;
    }
    if (v15 >= v9) {
      goto LABEL_24;
    }
    unint64_t v16 = *(void *)(v5 + 8 * v15);
    ++v4;
    if (!v16)
    {
      int64_t v4 = v15 + 1;
      if (v15 + 1 >= v9) {
        goto LABEL_24;
      }
      unint64_t v16 = *(void *)(v5 + 8 * v4);
      if (!v16)
      {
        int64_t v4 = v15 + 2;
        if (v15 + 2 >= v9) {
          goto LABEL_24;
        }
        unint64_t v16 = *(void *)(v5 + 8 * v4);
        if (!v16) {
          break;
        }
      }
    }
LABEL_20:
    unint64_t v8 = (v16 - 1) & v16;
    unint64_t v11 = __clz(__rbit64(v16)) + (v4 << 6);
LABEL_5:
    uint64_t v12 = *(void **)(*(void *)(a3 + 48) + 8 * v11);
    uint64_t v13 = *(uint64_t (**)(void))((swift_isaMask & *v12) + 0x80);
    unint64_t v14 = v12;
    LOBYTE(v13) = v13();

    if ((v13 & 1) == 0)
    {
      *(unint64_t *)((char *)a1 + ((v11 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v11;
      if (__OFADD__(v21++, 1))
      {
        __break(1u);
LABEL_24:
        swift_retain();
        sub_10043F58C(a1, a2, v21, a3);
        return;
      }
    }
  }
  int64_t v17 = v15 + 3;
  if (v17 >= v9) {
    goto LABEL_24;
  }
  unint64_t v16 = *(void *)(v5 + 8 * v17);
  if (v16)
  {
    int64_t v4 = v17;
    goto LABEL_20;
  }
  while (1)
  {
    int64_t v4 = v17 + 1;
    if (__OFADD__(v17, 1)) {
      break;
    }
    if (v4 >= v9) {
      goto LABEL_24;
    }
    unint64_t v16 = *(void *)(v5 + 8 * v4);
    ++v17;
    if (v16) {
      goto LABEL_20;
    }
  }
LABEL_26:
  __break(1u);
}

uint64_t sub_10043F58C(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  if (!a3)
  {
    int64_t v9 = &_swiftEmptySetSingleton;
LABEL_36:
    swift_release();
    return (uint64_t)v9;
  }
  uint64_t v5 = a3;
  if (*(void *)(a4 + 16) == a3) {
    return v4;
  }
  sub_100431F80(&qword_100A44D48);
  uint64_t result = sub_1007269E0();
  int64_t v9 = (void *)result;
  uint64_t v29 = a1;
  if (a2 < 1) {
    unint64_t v10 = 0;
  }
  else {
    unint64_t v10 = *a1;
  }
  uint64_t v11 = 0;
  uint64_t v12 = result + 56;
  while (1)
  {
    if (v10)
    {
      unint64_t v13 = __clz(__rbit64(v10));
      v10 &= v10 - 1;
      unint64_t v14 = v13 | (v11 << 6);
      goto LABEL_24;
    }
    uint64_t v15 = v11 + 1;
    if (__OFADD__(v11, 1)) {
      goto LABEL_39;
    }
    if (v15 >= a2) {
      goto LABEL_36;
    }
    unint64_t v16 = v29[v15];
    ++v11;
    if (!v16)
    {
      uint64_t v11 = v15 + 1;
      if (v15 + 1 >= a2) {
        goto LABEL_36;
      }
      unint64_t v16 = v29[v11];
      if (!v16)
      {
        uint64_t v11 = v15 + 2;
        if (v15 + 2 >= a2) {
          goto LABEL_36;
        }
        unint64_t v16 = v29[v11];
        if (!v16) {
          break;
        }
      }
    }
LABEL_23:
    unint64_t v10 = (v16 - 1) & v16;
    unint64_t v14 = __clz(__rbit64(v16)) + (v11 << 6);
LABEL_24:
    Swift::Int v18 = v9[5];
    id v19 = *(id *)(*(void *)(v4 + 48) + 8 * v14);
    uint64_t result = sub_1007267E0(v18);
    uint64_t v20 = -1 << *((unsigned char *)v9 + 32);
    unint64_t v21 = result & ~v20;
    unint64_t v22 = v21 >> 6;
    if (((-1 << v21) & ~*(void *)(v12 + 8 * (v21 >> 6))) != 0)
    {
      unint64_t v23 = __clz(__rbit64((-1 << v21) & ~*(void *)(v12 + 8 * (v21 >> 6)))) | v21 & 0x7FFFFFFFFFFFFFC0;
    }
    else
    {
      char v24 = 0;
      unint64_t v25 = (unint64_t)(63 - v20) >> 6;
      do
      {
        if (++v22 == v25 && (v24 & 1) != 0)
        {
          __break(1u);
          goto LABEL_38;
        }
        BOOL v26 = v22 == v25;
        if (v22 == v25) {
          unint64_t v22 = 0;
        }
        v24 |= v26;
        uint64_t v27 = *(void *)(v12 + 8 * v22);
      }
      while (v27 == -1);
      unint64_t v23 = __clz(__rbit64(~v27)) + (v22 << 6);
    }
    *(void *)(v12 + ((v23 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v23;
    *(void *)(v9[6] + 8 * v23) = v19;
    ++v9[2];
    if (__OFSUB__(v5--, 1))
    {
LABEL_38:
      __break(1u);
LABEL_39:
      __break(1u);
      goto LABEL_40;
    }
    if (!v5) {
      goto LABEL_36;
    }
  }
  uint64_t v17 = v15 + 3;
  if (v17 >= a2) {
    goto LABEL_36;
  }
  unint64_t v16 = v29[v17];
  if (v16)
  {
    uint64_t v11 = v17;
    goto LABEL_23;
  }
  while (1)
  {
    uint64_t v11 = v17 + 1;
    if (__OFADD__(v17, 1)) {
      break;
    }
    if (v11 >= a2) {
      goto LABEL_36;
    }
    unint64_t v16 = v29[v11];
    ++v17;
    if (v16) {
      goto LABEL_23;
    }
  }
LABEL_40:
  __break(1u);
  return result;
}

uint64_t sub_10043F7EC(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  uint64_t v6 = *(void *)(v5 - 8);
  __chkstk_darwin(v5, v7);
  int64_t v9 = (char *)&v21 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  unint64_t v23 = v2;
  uint64_t v10 = *v2;
  sub_10044C1AC(&qword_100A44D18, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
  swift_bridgeObjectRetain();
  uint64_t v11 = a2;
  uint64_t v12 = sub_1007263D0();
  uint64_t v13 = -1 << *(unsigned char *)(v10 + 32);
  unint64_t v14 = v12 & ~v13;
  if ((*(void *)(v10 + 56 + ((v14 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v14))
  {
    uint64_t v22 = a1;
    uint64_t v15 = ~v13;
    uint64_t v16 = *(void *)(v6 + 72);
    while (1)
    {
      sub_1004323D4(*(void *)(v10 + 48) + v16 * v14, (uint64_t)v9, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
      sub_10044C1AC(&qword_100A44D20, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
      char v17 = sub_100726410();
      sub_1004324A4((uint64_t)v9, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
      if (v17) {
        break;
      }
      unint64_t v14 = (v14 + 1) & v15;
      if (((*(void *)(v10 + 56 + ((v14 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v14) & 1) == 0)
      {
        swift_bridgeObjectRelease();
        a1 = v22;
        goto LABEL_7;
      }
    }
    swift_bridgeObjectRelease();
    sub_1004324A4(v11, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    sub_1004323D4(*(void *)(*v23 + 48) + v16 * v14, v22, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    return 0;
  }
  else
  {
    swift_bridgeObjectRelease();
LABEL_7:
    Swift::Int v18 = v23;
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
    sub_1004323D4(v11, (uint64_t)v9, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    uint64_t v24 = *v18;
    *Swift::Int v18 = 0x8000000000000000;
    sub_10043FAF0((uint64_t)v9, v14, isUniquelyReferenced_nonNull_native);
    *Swift::Int v18 = v24;
    swift_bridgeObjectRelease();
    sub_10043243C(v11, a1, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    return 1;
  }
}

uint64_t sub_10043FAF0(uint64_t a1, unint64_t a2, char a3)
{
  uint64_t v7 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  uint64_t v8 = *(void *)(v7 - 8);
  __chkstk_darwin(v7, v9);
  uint64_t v11 = (char *)&v25 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  unint64_t v12 = *(void *)(*v3 + 16);
  unint64_t v13 = *(void *)(*v3 + 24);
  uint64_t v25 = v8;
  BOOL v26 = v3;
  if (v13 > v12 && (a3 & 1) != 0) {
    goto LABEL_12;
  }
  if (a3)
  {
    sub_10043EE70();
  }
  else
  {
    if (v13 > v12)
    {
      sub_10043FD98();
      goto LABEL_12;
    }
    sub_10043FFFC();
  }
  uint64_t v14 = *v3;
  sub_10044C1AC(&qword_100A44D18, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
  uint64_t v15 = sub_1007263D0();
  uint64_t v16 = -1 << *(unsigned char *)(v14 + 32);
  a2 = v15 & ~v16;
  if ((*(void *)(v14 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a2))
  {
    uint64_t v17 = ~v16;
    uint64_t v18 = *(void *)(v8 + 72);
    do
    {
      sub_1004323D4(*(void *)(v14 + 48) + v18 * a2, (uint64_t)v11, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
      sub_10044C1AC(&qword_100A44D20, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
      char v19 = sub_100726410();
      sub_1004324A4((uint64_t)v11, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
      if (v19) {
        goto LABEL_15;
      }
      a2 = (a2 + 1) & v17;
    }
    while (((*(void *)(v14 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a2) & 1) != 0);
  }
LABEL_12:
  uint64_t v20 = *v26;
  *(void *)(*v26 + 8 * (a2 >> 6) + 56) |= 1 << a2;
  uint64_t result = sub_10043243C(a1, *(void *)(v20 + 48) + *(void *)(v25 + 72) * a2, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
  uint64_t v22 = *(void *)(v20 + 16);
  BOOL v23 = __OFADD__(v22, 1);
  uint64_t v24 = v22 + 1;
  if (!v23)
  {
    *(void *)(v20 + 16) = v24;
    return result;
  }
  __break(1u);
LABEL_15:
  uint64_t result = sub_100726D30();
  __break(1u);
  return result;
}

void *sub_10043FD98()
{
  uint64_t v1 = v0;
  uint64_t v2 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  uint64_t v3 = *(void *)(v2 - 8);
  __chkstk_darwin(v2 - 8, v4);
  uint64_t v6 = (char *)&v24 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_100431F80(&qword_100A44D28);
  uint64_t v7 = *v0;
  uint64_t v8 = sub_1007269B0();
  uint64_t v9 = v8;
  if (!*(void *)(v7 + 16))
  {
LABEL_25:
    uint64_t result = (void *)swift_release();
    *uint64_t v1 = v9;
    return result;
  }
  uint64_t result = (void *)(v8 + 56);
  uint64_t v11 = v7 + 56;
  unint64_t v12 = (unint64_t)((1 << *(unsigned char *)(v9 + 32)) + 63) >> 6;
  if (v9 != v7 || (unint64_t)result >= v11 + 8 * v12) {
    uint64_t result = memmove(result, (const void *)(v7 + 56), 8 * v12);
  }
  int64_t v13 = 0;
  *(void *)(v9 + 16) = *(void *)(v7 + 16);
  uint64_t v14 = 1 << *(unsigned char *)(v7 + 32);
  uint64_t v15 = -1;
  if (v14 < 64) {
    uint64_t v15 = ~(-1 << v14);
  }
  unint64_t v16 = v15 & *(void *)(v7 + 56);
  int64_t v17 = (unint64_t)(v14 + 63) >> 6;
  while (1)
  {
    if (v16)
    {
      unint64_t v18 = __clz(__rbit64(v16));
      v16 &= v16 - 1;
      unint64_t v19 = v18 | (v13 << 6);
      goto LABEL_9;
    }
    int64_t v21 = v13 + 1;
    if (__OFADD__(v13, 1))
    {
      __break(1u);
      goto LABEL_27;
    }
    if (v21 >= v17) {
      goto LABEL_25;
    }
    unint64_t v22 = *(void *)(v11 + 8 * v21);
    ++v13;
    if (!v22)
    {
      int64_t v13 = v21 + 1;
      if (v21 + 1 >= v17) {
        goto LABEL_25;
      }
      unint64_t v22 = *(void *)(v11 + 8 * v13);
      if (!v22)
      {
        int64_t v13 = v21 + 2;
        if (v21 + 2 >= v17) {
          goto LABEL_25;
        }
        unint64_t v22 = *(void *)(v11 + 8 * v13);
        if (!v22) {
          break;
        }
      }
    }
LABEL_24:
    unint64_t v16 = (v22 - 1) & v22;
    unint64_t v19 = __clz(__rbit64(v22)) + (v13 << 6);
LABEL_9:
    unint64_t v20 = *(void *)(v3 + 72) * v19;
    sub_1004323D4(*(void *)(v7 + 48) + v20, (uint64_t)v6, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    uint64_t result = (void *)sub_10043243C((uint64_t)v6, *(void *)(v9 + 48) + v20, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
  }
  int64_t v23 = v21 + 3;
  if (v23 >= v17) {
    goto LABEL_25;
  }
  unint64_t v22 = *(void *)(v11 + 8 * v23);
  if (v22)
  {
    int64_t v13 = v23;
    goto LABEL_24;
  }
  while (1)
  {
    int64_t v13 = v23 + 1;
    if (__OFADD__(v23, 1)) {
      break;
    }
    if (v13 >= v17) {
      goto LABEL_25;
    }
    unint64_t v22 = *(void *)(v11 + 8 * v13);
    ++v23;
    if (v22) {
      goto LABEL_24;
    }
  }
LABEL_27:
  __break(1u);
  return result;
}

uint64_t sub_10043FFFC()
{
  uint64_t v1 = v0;
  uint64_t v2 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  uint64_t v33 = *(void *)(v2 - 8);
  __chkstk_darwin(v2, v3);
  uint64_t v5 = (char *)&v30 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = *v0;
  sub_100431F80(&qword_100A44D28);
  uint64_t v7 = sub_1007269C0();
  uint64_t v8 = v7;
  if (!*(void *)(v6 + 16))
  {
    uint64_t result = swift_release();
LABEL_35:
    *uint64_t v1 = v8;
    return result;
  }
  uint64_t v9 = 1 << *(unsigned char *)(v6 + 32);
  uint64_t v10 = *(void *)(v6 + 56);
  uint64_t v30 = v0;
  uint64_t v31 = v6 + 56;
  if (v9 < 64) {
    uint64_t v11 = ~(-1 << v9);
  }
  else {
    uint64_t v11 = -1;
  }
  unint64_t v12 = v11 & v10;
  int64_t v32 = (unint64_t)(v9 + 63) >> 6;
  uint64_t v13 = v7 + 56;
  uint64_t result = swift_retain();
  int64_t v15 = 0;
  while (1)
  {
    if (v12)
    {
      unint64_t v17 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      unint64_t v18 = v17 | (v15 << 6);
      goto LABEL_24;
    }
    int64_t v19 = v15 + 1;
    if (__OFADD__(v15, 1))
    {
LABEL_36:
      __break(1u);
      goto LABEL_37;
    }
    if (v19 >= v32) {
      goto LABEL_33;
    }
    unint64_t v20 = *(void *)(v31 + 8 * v19);
    ++v15;
    if (!v20)
    {
      int64_t v15 = v19 + 1;
      if (v19 + 1 >= v32) {
        goto LABEL_33;
      }
      unint64_t v20 = *(void *)(v31 + 8 * v15);
      if (!v20)
      {
        int64_t v15 = v19 + 2;
        if (v19 + 2 >= v32) {
          goto LABEL_33;
        }
        unint64_t v20 = *(void *)(v31 + 8 * v15);
        if (!v20) {
          break;
        }
      }
    }
LABEL_23:
    unint64_t v12 = (v20 - 1) & v20;
    unint64_t v18 = __clz(__rbit64(v20)) + (v15 << 6);
LABEL_24:
    uint64_t v22 = *(void *)(v33 + 72);
    sub_1004323D4(*(void *)(v6 + 48) + v22 * v18, (uint64_t)v5, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    sub_10044C1AC(&qword_100A44D18, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    uint64_t result = sub_1007263D0();
    uint64_t v23 = -1 << *(unsigned char *)(v8 + 32);
    unint64_t v24 = result & ~v23;
    unint64_t v25 = v24 >> 6;
    if (((-1 << v24) & ~*(void *)(v13 + 8 * (v24 >> 6))) != 0)
    {
      unint64_t v16 = __clz(__rbit64((-1 << v24) & ~*(void *)(v13 + 8 * (v24 >> 6)))) | v24 & 0x7FFFFFFFFFFFFFC0;
    }
    else
    {
      char v26 = 0;
      unint64_t v27 = (unint64_t)(63 - v23) >> 6;
      do
      {
        if (++v25 == v27 && (v26 & 1) != 0)
        {
          __break(1u);
          goto LABEL_36;
        }
        BOOL v28 = v25 == v27;
        if (v25 == v27) {
          unint64_t v25 = 0;
        }
        v26 |= v28;
        uint64_t v29 = *(void *)(v13 + 8 * v25);
      }
      while (v29 == -1);
      unint64_t v16 = __clz(__rbit64(~v29)) + (v25 << 6);
    }
    *(void *)(v13 + ((v16 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v16;
    uint64_t result = sub_10043243C((uint64_t)v5, *(void *)(v8 + 48) + v16 * v22, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    ++*(void *)(v8 + 16);
  }
  int64_t v21 = v19 + 3;
  if (v21 >= v32)
  {
LABEL_33:
    uint64_t result = swift_release_n();
    uint64_t v1 = v30;
    goto LABEL_35;
  }
  unint64_t v20 = *(void *)(v31 + 8 * v21);
  if (v20)
  {
    int64_t v15 = v21;
    goto LABEL_23;
  }
  while (1)
  {
    int64_t v15 = v21 + 1;
    if (__OFADD__(v21, 1)) {
      break;
    }
    if (v15 >= v32) {
      goto LABEL_33;
    }
    unint64_t v20 = *(void *)(v31 + 8 * v15);
    ++v21;
    if (v20) {
      goto LABEL_23;
    }
  }
LABEL_37:
  __break(1u);
  return result;
}

void sub_100440398(unint64_t a1)
{
  unint64_t v2 = a1 >> 62;
  if (a1 >> 62)
  {
    swift_bridgeObjectRetain();
    uint64_t v6 = sub_100726BA0();
    swift_bridgeObjectRelease();
    if (v6)
    {
LABEL_3:
      sub_100431F80(&qword_100A44D48);
      uint64_t v3 = (void *)sub_1007269E0();
      uint64_t v4 = a1 & 0xFFFFFFFFFFFFFF8;
      if (!v2) {
        goto LABEL_4;
      }
LABEL_8:
      swift_bridgeObjectRetain();
      uint64_t v5 = sub_100726BA0();
      swift_bridgeObjectRelease();
      if (!v5) {
        return;
      }
      goto LABEL_9;
    }
  }
  else if (*(void *)((a1 & 0xFFFFFFFFFFFFFF8) + 0x10))
  {
    goto LABEL_3;
  }
  uint64_t v3 = &_swiftEmptySetSingleton;
  uint64_t v4 = a1 & 0xFFFFFFFFFFFFFF8;
  if (v2) {
    goto LABEL_8;
  }
LABEL_4:
  uint64_t v5 = *(void *)(v4 + 16);
  if (!v5) {
    return;
  }
LABEL_9:
  uint64_t v7 = (char *)(v3 + 7);
  uint64_t v42 = v5;
  if ((a1 & 0xC000000000000001) != 0)
  {
    uint64_t v8 = 0;
    while (1)
    {
      uint64_t v9 = sub_100726A10();
      BOOL v10 = __OFADD__(v8++, 1);
      if (v10)
      {
        __break(1u);
        goto LABEL_36;
      }
      uint64_t v11 = v9;
      Swift::Int v12 = sub_1007267E0(v3[5]);
      uint64_t v13 = -1 << *((unsigned char *)v3 + 32);
      unint64_t v14 = v12 & ~v13;
      unint64_t v15 = v14 >> 6;
      uint64_t v16 = *(void *)&v7[8 * (v14 >> 6)];
      uint64_t v17 = 1 << v14;
      if (((1 << v14) & v16) != 0)
      {
        type metadata accessor for IDSGroupEncryptionControllerMember();
        id v18 = *(id *)(v3[6] + 8 * v14);
        char v19 = sub_1007267F0();

        if (v19)
        {
LABEL_11:
          swift_unknownObjectRelease();
          goto LABEL_12;
        }
        uint64_t v20 = ~v13;
        while (1)
        {
          unint64_t v14 = (v14 + 1) & v20;
          unint64_t v15 = v14 >> 6;
          uint64_t v16 = *(void *)&v7[8 * (v14 >> 6)];
          uint64_t v17 = 1 << v14;
          if ((v16 & (1 << v14)) == 0) {
            break;
          }
          id v21 = *(id *)(v3[6] + 8 * v14);
          char v22 = sub_1007267F0();

          if (v22) {
            goto LABEL_11;
          }
        }
      }
      *(void *)&v7[8 * v15] = v17 | v16;
      *(void *)(v3[6] + 8 * v14) = v11;
      uint64_t v23 = v3[2];
      BOOL v10 = __OFADD__(v23, 1);
      uint64_t v24 = v23 + 1;
      if (v10) {
        goto LABEL_37;
      }
      v3[2] = v24;
LABEL_12:
      if (v8 == v42) {
        return;
      }
    }
  }
  uint64_t v25 = 0;
  uint64_t v41 = *(void *)((a1 & 0xFFFFFFFFFFFFFF8) + 0x10);
  while (v25 != v41)
  {
    Swift::Int v26 = v3[5];
    id v27 = *(id *)(a1 + 32 + 8 * v25);
    Swift::Int v28 = sub_1007267E0(v26);
    uint64_t v29 = -1 << *((unsigned char *)v3 + 32);
    unint64_t v30 = v28 & ~v29;
    unint64_t v31 = v30 >> 6;
    uint64_t v32 = *(void *)&v7[8 * (v30 >> 6)];
    uint64_t v33 = 1 << v30;
    if (((1 << v30) & v32) != 0)
    {
      type metadata accessor for IDSGroupEncryptionControllerMember();
      id v34 = *(id *)(v3[6] + 8 * v30);
      char v35 = sub_1007267F0();

      if (v35) {
        goto LABEL_23;
      }
      uint64_t v36 = ~v29;
      unint64_t v30 = (v30 + 1) & v36;
      unint64_t v31 = v30 >> 6;
      uint64_t v32 = *(void *)&v7[8 * (v30 >> 6)];
      uint64_t v33 = 1 << v30;
      if ((v32 & (1 << v30)) != 0)
      {
        while (1)
        {
          id v37 = *(id *)(v3[6] + 8 * v30);
          char v38 = sub_1007267F0();

          if (v38) {
            break;
          }
          unint64_t v30 = (v30 + 1) & v36;
          unint64_t v31 = v30 >> 6;
          uint64_t v32 = *(void *)&v7[8 * (v30 >> 6)];
          uint64_t v33 = 1 << v30;
          if ((v32 & (1 << v30)) == 0) {
            goto LABEL_31;
          }
        }
LABEL_23:

        uint64_t v5 = v42;
        goto LABEL_24;
      }
LABEL_31:
      uint64_t v5 = v42;
    }
    *(void *)&v7[8 * v31] = v33 | v32;
    *(void *)(v3[6] + 8 * v30) = v27;
    uint64_t v39 = v3[2];
    BOOL v10 = __OFADD__(v39, 1);
    uint64_t v40 = v39 + 1;
    if (v10) {
      goto LABEL_38;
    }
    v3[2] = v40;
LABEL_24:
    if (++v25 == v5) {
      return;
    }
  }
LABEL_36:
  __break(1u);
LABEL_37:
  __break(1u);
LABEL_38:
  __break(1u);
}

uint64_t sub_1004406F0(uint64_t a1)
{
  return sub_100440708(a1);
}

uint64_t sub_100440708(uint64_t a1)
{
  uint64_t v2 = *(void *)(v1 + 24);
  *(void *)(a1 + *(int *)(type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0) + 28) + _Block_object_dispose(&STACK[0x320], 8) = v2;
  return swift_unknownObjectWeakAssign();
}

unint64_t sub_100440758()
{
  unint64_t result = qword_100A45480;
  if (!qword_100A45480)
  {
    self;
    unint64_t result = swift_getObjCClassMetadata();
    atomic_store(result, (unint64_t *)&qword_100A45480);
  }
  return result;
}

uint64_t sub_100440798(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result < 0)
  {
    uint64_t result = swift_getTypeByMangledNameInContextInMetadataState2();
    *a1 = result;
  }
  return result;
}

uint64_t sub_1004407E0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  *(void *)(a2 + 24) = v3;
  *(void *)(a2 + 32) = *(void *)(a1 + 32);
  (**(void (***)(uint64_t, uint64_t))(v3 - 8))(a2, a1);
  return a2;
}

void sub_100440844(uint64_t a1)
{
}

void sub_10044085C(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  uint64_t v4 = *(void *)(v1 + 24);
  char v5 = *(unsigned char *)(v1 + 32);
  uint64_t v6 = a1 + *(int *)(type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0) + 20);
  *(void *)uint64_t v6 = v3;
  *(void *)(v6 + _Block_object_dispose(&STACK[0x320], 8) = v4;
  *(unsigned char *)(v6 + 16) = v5;
  sub_100434CDC(a1);
}

uint64_t sub_1004408C0(uint64_t a1)
{
  return sub_1004408D8(a1);
}

uint64_t sub_1004408D8(uint64_t a1)
{
  char v3 = *(unsigned char *)(v1 + 16);
  *(unsigned char *)(a1 + *(int *)(type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0) + 24)) = v3;
  return sub_1004359C4(a1);
}

uint64_t sub_100440928(uint64_t a1)
{
  return sub_10043393C(a1, *(void *)(v1 + 16), *(void **)(v1 + 24));
}

id sub_100440954(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, char a9, unsigned __int8 a10, unsigned __int8 a11, unsigned __int8 a12)
{
  int v56 = a8;
  uint64_t v54 = a6;
  uint64_t v55 = a7;
  uint64_t v62 = a5;
  uint64_t v63 = a3;
  uint64_t v64 = a4;
  uint64_t v57 = a1;
  uint64_t v58 = a2;
  int v68 = a11;
  int v69 = a12;
  int v66 = a10;
  uint64_t v67 = sub_100725ED0();
  uint64_t v65 = *(void *)(v67 - 8);
  __chkstk_darwin(v67, v13);
  uint64_t v61 = (char *)&v54 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = sub_100726740();
  uint64_t v59 = *(void *)(v15 - 8);
  uint64_t v60 = v15;
  __chkstk_darwin(v15, v16);
  id v18 = (char *)&v54 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = sub_100726700();
  __chkstk_darwin(v19, v20);
  uint64_t v21 = sub_100725F20();
  __chkstk_darwin(v21 - 8, v22);
  uint64_t v23 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0);
  __chkstk_darwin(v23 - 8, v24);
  Swift::Int v26 = (char *)&v54 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v27 = OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state;
  Swift::Int v28 = v12;
  sub_100432B28((uint64_t)v26);
  sub_100431F80(&qword_100A44A58);
  uint64_t v29 = swift_allocObject();
  *(_DWORD *)(v29 + ((*(unsigned int *)(*(void *)v29 + 48) + 3) & 0x1FFFFFFFCLL)) = 0;
  sub_1004323D4((uint64_t)v26, v29 + *(void *)(class metadata base offset for ManagedBuffer + *(void *)v29 + 16), type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
  sub_1004324A4((uint64_t)v26, type metadata accessor for IDSGroupEncryptionKeyMaterialController.State);
  *(void *)&v12[v27] = v29;
  uint64_t v30 = OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_q;
  sub_100440758();
  sub_100725F00();
  os_log_type_t v71 = _swiftEmptyArrayStorage;
  sub_10044C1AC(&qword_100A44A68, (void (*)(uint64_t))&type metadata accessor for OS_dispatch_queue.Attributes);
  sub_100431F80((uint64_t *)&unk_100A45490);
  sub_1004413A8((unint64_t *)&qword_100A44A70, (uint64_t *)&unk_100A45490);
  sub_100726890();
  (*(void (**)(char *, void, uint64_t))(v59 + 104))(v18, enum case for OS_dispatch_queue.AutoreleaseFrequency.inherit(_:), v60);
  uint64_t v31 = v62;
  *(void *)&v28[v30] = sub_100726760();
  uint64_t v32 = (void **)&v28[OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_persistenceManager];
  *(void *)&v28[OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_persistenceManager] = 0;
  *(_DWORD *)&v28[OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_rollIndex] = 1;
  uint64_t v33 = &v28[OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_groupID];
  uint64_t v34 = v64;
  *(void *)uint64_t v33 = v63;
  *((void *)v33 + 1) = v34;
  sub_1004407E0(v31, (uint64_t)&v28[OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_cryptoHandler]);
  char v35 = v61;
  sub_1004DFE9C(v66);
  (*(void (**)(char *, char *, uint64_t))(v65 + 32))(&v28[OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_l], v35, v67);
  v28[OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_shortKIEnabled] = v68;
  v28[OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_isRatchetEnabled] = v69;
  uint64_t v36 = self;
  id v37 = [v36 sharedInstance];

  if (!v37)
  {
    id v40 = 0;
    goto LABEL_5;
  }
  id result = [v36 sharedInstance];
  if (result)
  {
    uint64_t v39 = result;
    id v40 = [result persistenceManager];

LABEL_5:
    char v41 = v56;
    uint64_t v43 = v54;
    uint64_t v42 = v55;
    swift_beginAccess();
    uint64_t v44 = *v32;
    void *v32 = v40;

    uint64_t v45 = (objc_class *)type metadata accessor for IDSGroupEncryptionKeyMaterialController(0);
    v70.receiver = v28;
    v70.super_class = v45;
    id v46 = objc_msgSendSuper2(&v70, "init");
    uint64_t v48 = (void *)__chkstk_darwin(v46, v47);
    uint64_t v49 = v58;
    *(&v54 - 6) = v57;
    *(&v54 - 5) = v49;
    *(&v54 - 4) = v43;
    *(&v54 - 3) = v42;
    *((unsigned char *)&v54 - 16) = v41 & 1;
    *((unsigned char *)&v54 - 15) = a9 & 1;
    uint64_t v51 = v50 + *(void *)(class metadata base offset for ManagedBuffer + *(void *)v50 + 16);
    uint64_t v52 = (os_unfair_lock_s *)(v50 + ((*(unsigned int *)(*(void *)v50 + 48) + 3) & 0x1FFFFFFFCLL));
    id v53 = v48;
    os_unfair_lock_lock(v52);
    sub_10044C758(v51);
    os_unfair_lock_unlock(v52);

    sub_10044C6AC(v31);
    return v53;
  }
  __break(1u);
  return result;
}

uint64_t type metadata accessor for IDSGroupEncryptionKeyMaterialController(uint64_t a1)
{
  return sub_100440FD0(a1, (uint64_t *)&unk_100A4CC10);
}

uint64_t sub_100440FD0(uint64_t a1, uint64_t *a2)
{
  uint64_t result = *a2;
  if (!*a2) {
    return swift_getSingletonMetadata();
  }
  return result;
}

Swift::Int sub_100441008(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  uint64_t v4 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0);
  if (*(unsigned char *)(a1 + *(int *)(v4 + 24)))
  {
    if ((v3 & 0xC000000000000001) != 0)
    {
      swift_bridgeObjectRetain();
      sub_1007268E0();
      if (sub_100726950())
      {
        type metadata accessor for IDSGroupEncryptionControllerMember();
        do
        {
          uint64_t v5 = swift_dynamicCast();
          if ((*(uint64_t (**)(uint64_t))((swift_isaMask & *v19) + 0x80))(v5))
          {
          }
          else
          {
            if (*((void *)&_swiftEmptySetSingleton + 3) <= *((void *)&_swiftEmptySetSingleton + 2)) {
              sub_10043EBD0();
            }
            Swift::Int result = sub_1007267E0(*((void *)&_swiftEmptySetSingleton + 5));
            uint64_t v7 = (char *)&_swiftEmptySetSingleton + 56;
            uint64_t v8 = -1 << *((unsigned char *)&_swiftEmptySetSingleton + 32);
            unint64_t v9 = result & ~v8;
            unint64_t v10 = v9 >> 6;
            if (((-1 << v9) & ~*((void *)&_swiftEmptySetSingleton + (v9 >> 6) + 7)) != 0)
            {
              unint64_t v11 = __clz(__rbit64((-1 << v9) & ~*((void *)&_swiftEmptySetSingleton + (v9 >> 6) + 7))) | v9 & 0x7FFFFFFFFFFFFFC0;
            }
            else
            {
              char v12 = 0;
              unint64_t v13 = (unint64_t)(63 - v8) >> 6;
              do
              {
                if (++v10 == v13 && (v12 & 1) != 0)
                {
                  __break(1u);
                  return result;
                }
                BOOL v14 = v10 == v13;
                if (v10 == v13) {
                  unint64_t v10 = 0;
                }
                v12 |= v14;
                uint64_t v15 = *(void *)&v7[8 * v10];
              }
              while (v15 == -1);
              unint64_t v11 = __clz(__rbit64(~v15)) + (v10 << 6);
            }
            *(void *)&v7[(v11 >> 3) & 0x1FFFFFFFFFFFFFF8] |= 1 << v11;
            *(void *)(*((void *)&_swiftEmptySetSingleton + 6) + 8 * v11) = v19;
            ++*((void *)&_swiftEmptySetSingleton + 2);
          }
        }
        while (sub_100726950());
        uint64_t v3 = (uint64_t)&_swiftEmptySetSingleton;
      }
      else
      {
        uint64_t v3 = (uint64_t)&_swiftEmptySetSingleton;
      }
      swift_release();
    }
    else
    {
      uint64_t v16 = swift_bridgeObjectRetain();
      uint64_t v3 = sub_10043F248(v16, v17);
    }
  }
  else
  {
    swift_bridgeObjectRetain();
  }
  uint64_t v18 = *(int *)(v4 + 40);
  swift_bridgeObjectRelease();
  *(void *)(a1 + v1_Block_object_dispose(&STACK[0x320], 8) = v3;
  return sub_1004359C4(a1);
}

uint64_t sub_1004412A0()
{
  swift_release();

  return _swift_deallocObject(v0, 40, 7);
}

void sub_1004412E0()
{
  uint64_t v1 = *(void *)(*(void *)(v0 + 16)
                 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state);
  uint64_t v2 = v1 + *(void *)(class metadata base offset for ManagedBuffer + *(void *)v1 + 16);
  uint64_t v3 = (os_unfair_lock_s *)(v1 + ((*(unsigned int *)(*(void *)v1 + 48) + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v3);
  sub_10044C424(v2);
  os_unfair_lock_unlock(v3);
}

uint64_t sub_100441390(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_1004413A0()
{
  return swift_release();
}

uint64_t sub_1004413A8(unint64_t *a1, uint64_t *a2)
{
  uint64_t result = *a1;
  if (!result)
  {
    sub_100440798(a2);
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

uint64_t sub_1004413F8(uint64_t a1)
{
  return sub_100436314(a1, *(void **)(v1 + 16));
}

uint64_t sub_100441400()
{
  return (*(uint64_t (**)(void))((swift_isaMask & **(void **)(v0 + 16)) + 0x168))();
}

unint64_t sub_100441464()
{
  unint64_t result = qword_100A44A88;
  if (!qword_100A44A88)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_100A44A88);
  }
  return result;
}

uint64_t sub_1004414B8@<X0>(uint64_t a1@<X0>, BOOL *a2@<X8>)
{
  unint64_t v5 = *(void *)(v2 + 16);
  uint64_t result = type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0);
  *a2 = *(void *)(a1 + *(int *)(result + 60)) > v5;
  return result;
}

uint64_t sub_10044150C()
{
  return _swift_deallocObject(v0, 40, 7);
}

uint64_t sub_100441550()
{
  return (*(uint64_t (**)(void))((swift_isaMask & **(void **)(v0 + 16)) + 0x188))();
}

uint64_t sub_1004415B4()
{
  return sub_10044BEB8();
}

uint64_t sub_1004415CC(uint64_t a1)
{
  uint64_t v3 = *(void **)(v1 + 16);
  uint64_t v4 = (char *)v3 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_l;
  unint64_t v5 = sub_100725EB0();
  os_log_type_t v6 = sub_1007266E0();
  if (os_log_type_enabled(v5, v6))
  {
    uint64_t v7 = (uint8_t *)swift_slowAlloc();
    uint64_t v9 = swift_slowAlloc();
    *(_DWORD *)uint64_t v7 = 136315138;
    sub_10043E578(0x29287465736572, 0xE700000000000000, &v9);
    sub_100726830();
    _os_log_impl((void *)&_mh_execute_header, v5, v6, "%s: setting state to .noKey", v7, 0xCu);
    swift_arrayDestroy();
    swift_slowDealloc();
    swift_slowDealloc();
  }

  sub_1004324A4(a1, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
  type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState(0);
  swift_storeEnumTagMultiPayload();
  return (*(uint64_t (**)(char *, void, unint64_t, uint64_t))((swift_isaMask & *v3) + 0x208))(v4, 0, 0xE000000000000000, a1);
}

uint64_t sub_1004417B8(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, uint64_t))((swift_isaMask & **(void **)(v1 + 16)) + 0x208))(*(void *)(v1 + 24), *(void *)(v1 + 32), *(void *)(v1 + 40), a1);
}

unint64_t sub_10044182C()
{
  unint64_t result = qword_100A44A90;
  if (!qword_100A44A90)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_100A44A90);
  }
  return result;
}

__n128 initializeBufferWithCopyOfBuffer for IDSGroupEncryptionKeyMaterialRollPolicy(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[1].n128_u8[0] = a2[1].n128_u8[0];
  *a1 = result;
  return result;
}

uint64_t getEnumTagSinglePayload for IDSGroupEncryptionKeyMaterialRollPolicy(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 17)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for IDSGroupEncryptionKeyMaterialRollPolicy(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)__n128 result = 0;
    *(void *)(result + _Block_object_dispose(&STACK[0x320], 8) = 0;
    *(unsigned char *)(result + 16) = 0;
    *(_DWORD *)__n128 result = a2 - 1;
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 17) = v3;
  return result;
}

uint64_t sub_1004418E8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t sub_100441904(uint64_t result, int a2)
{
  if (a2)
  {
    *(void *)__n128 result = (a2 - 1);
    *(void *)(result + _Block_object_dispose(&STACK[0x320], 8) = 0;
    *(unsigned char *)(result + 16) = 1;
  }
  else
  {
    *(unsigned char *)(result + 16) = 0;
  }
  return result;
}

ValueMetadata *type metadata accessor for IDSGroupEncryptionKeyMaterialRollPolicy()
{
  return &type metadata for IDSGroupEncryptionKeyMaterialRollPolicy;
}

uint64_t sub_100441934()
{
  return type metadata accessor for IDSGroupEncryptionKeyMaterialController(0);
}

uint64_t sub_10044193C()
{
  uint64_t result = sub_100725ED0();
  if (v1 <= 0x3F)
  {
    uint64_t result = swift_updateClassMetadata2();
    if (!result) {
      return 0;
    }
  }
  return result;
}

unsigned char *initializeBufferWithCopyOfBuffer for IDSGroupEncryptionKeyMaterialController.MembershipChangePolicy(unsigned char *result, unsigned char *a2)
{
  *uint64_t result = *a2;
  return result;
}

uint64_t getEnumTagSinglePayload for IDSGroupEncryptionKeyMaterialController.MembershipChangePolicy(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFF) {
    goto LABEL_17;
  }
  if (a2 + 1 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 1) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 1;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 1;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 1;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 2;
  int v8 = v6 - 2;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for IDSGroupEncryptionKeyMaterialController.MembershipChangePolicy(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 1 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 1) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFF) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFE)
  {
    unsigned int v6 = ((a2 - 255) >> 8) + 1;
    *uint64_t result = a2 + 1;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x100441B88);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *uint64_t result = a2 + 1;
        break;
    }
  }
  return result;
}

uint64_t sub_100441BB0(unsigned __int8 *a1)
{
  return *a1;
}

unsigned char *sub_100441BB8(unsigned char *result, char a2)
{
  *uint64_t result = a2 & 1;
  return result;
}

ValueMetadata *type metadata accessor for IDSGroupEncryptionKeyMaterialController.MembershipChangePolicy()
{
  return &type metadata for IDSGroupEncryptionKeyMaterialController.MembershipChangePolicy;
}

uint64_t *sub_100441BD4(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  int v5 = *(_DWORD *)(*(void *)(a3 - 8) + 80);
  if ((v5 & 0x20000) != 0)
  {
    uint64_t v10 = *a2;
    *a1 = *a2;
    unint64_t v11 = (uint64_t *)(v10 + ((v5 + 16) & ~(unint64_t)v5));
    swift_retain();
  }
  else
  {
    BOOL v7 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
    uint64_t v8 = *((void *)v7 - 1);
    if ((*(unsigned int (**)(uint64_t *, uint64_t, int *))(v8 + 48))(a2, 1, v7))
    {
      uint64_t v9 = sub_100431F80(&qword_100A44A50);
      memcpy(a1, a2, *(void *)(*(void *)(v9 - 8) + 64));
    }
    else
    {
      *(unsigned char *)a1 = *(unsigned char *)a2;
      uint64_t v12 = v7[5];
      unint64_t v13 = (char *)a1 + v12;
      BOOL v14 = (char *)a2 + v12;
      uint64_t v15 = sub_100725D30();
      (*(void (**)(char *, char *, uint64_t))(*(void *)(v15 - 8) + 16))(v13, v14, v15);
      uint64_t v16 = v7[6];
      uint64_t v17 = (uint64_t *)((char *)a1 + v16);
      uint64_t v18 = (uint64_t *)((char *)a2 + v16);
      uint64_t v19 = *v18;
      unint64_t v20 = v18[1];
      sub_100441FD4(*v18, v20);
      *uint64_t v17 = v19;
      v17[1] = v20;
      uint64_t v21 = v7[7];
      uint64_t v22 = (uint64_t *)((char *)a1 + v21);
      uint64_t v23 = (uint64_t *)((char *)a2 + v21);
      uint64_t v24 = *v23;
      unint64_t v25 = v23[1];
      sub_100441FD4(*v23, v25);
      *uint64_t v22 = v24;
      v22[1] = v25;
      uint64_t v26 = v7[8];
      uint64_t v27 = (char *)a1 + v26;
      Swift::Int v28 = (char *)a2 + v26;
      uint64_t v29 = sub_100725CC0();
      (*(void (**)(char *, char *, uint64_t))(*(void *)(v29 - 8) + 16))(v27, v28, v29);
      uint64_t v30 = v7[9];
      uint64_t v31 = (uint64_t *)((char *)a1 + v30);
      uint64_t v32 = (uint64_t *)((char *)a2 + v30);
      uint64_t v33 = v32[1];
      *uint64_t v31 = *v32;
      v31[1] = v33;
      *(_DWORD *)((char *)a1 + v7[10]) = *(_DWORD *)((char *)a2 + v7[10]);
      *(_DWORD *)((char *)a1 + v7[11]) = *(_DWORD *)((char *)a2 + v7[11]);
      *((unsigned char *)a1 + v7[12]) = *((unsigned char *)a2 + v7[12]);
      uint64_t v34 = v7[13];
      char v35 = (char *)a1 + v34;
      uint64_t v36 = (char *)a2 + v34;
      v35[8] = v36[8];
      *(void *)char v35 = *(void *)v36;
      id v37 = *(void (**)(uint64_t *, void, uint64_t, int *))(v8 + 56);
      swift_bridgeObjectRetain();
      v37(a1, 0, 1, v7);
    }
    uint64_t v38 = *(int *)(a3 + 20);
    uint64_t v39 = (char *)a1 + v38;
    id v40 = (char *)a2 + v38;
    *uint64_t v39 = *((unsigned char *)a2 + v38);
    uint64_t v41 = v7[5];
    uint64_t v42 = &v39[v41];
    uint64_t v43 = &v40[v41];
    uint64_t v44 = sub_100725D30();
    (*(void (**)(unsigned char *, char *, uint64_t))(*(void *)(v44 - 8) + 16))(v42, v43, v44);
    uint64_t v45 = v7[6];
    id v46 = (uint64_t *)&v39[v45];
    uint64_t v47 = (uint64_t *)&v40[v45];
    uint64_t v48 = *v47;
    unint64_t v49 = v47[1];
    sub_100441FD4(*v47, v49);
    uint64_t *v46 = v48;
    v46[1] = v49;
    uint64_t v50 = v7[7];
    uint64_t v51 = (uint64_t *)&v39[v50];
    uint64_t v52 = (uint64_t *)&v40[v50];
    uint64_t v53 = *v52;
    unint64_t v54 = v52[1];
    sub_100441FD4(*v52, v54);
    *uint64_t v51 = v53;
    v51[1] = v54;
    uint64_t v55 = v7[8];
    int v56 = &v39[v55];
    uint64_t v57 = &v40[v55];
    uint64_t v58 = sub_100725CC0();
    uint64_t v59 = *(void (**)(char *, char *, uint64_t))(*(void *)(v58 - 8) + 16);
    v59(v56, v57, v58);
    uint64_t v60 = v7[9];
    uint64_t v61 = &v39[v60];
    uint64_t v62 = &v40[v60];
    uint64_t v63 = *((void *)v62 + 1);
    *uint64_t v61 = *(void *)v62;
    v61[1] = v63;
    *(_DWORD *)&v39[v7[10]] = *(_DWORD *)&v40[v7[10]];
    *(_DWORD *)&v39[v7[11]] = *(_DWORD *)&v40[v7[11]];
    v39[v7[12]] = v40[v7[12]];
    uint64_t v64 = v7[13];
    uint64_t v65 = &v39[v64];
    int v66 = &v40[v64];
    unint64_t v11 = a1;
    void v65[8] = v66[8];
    *(void *)uint64_t v65 = *(void *)v66;
    uint64_t v67 = *(int *)(a3 + 24);
    int v68 = (char *)a1 + v67;
    int v69 = (char *)a2 + v67;
    swift_bridgeObjectRetain();
    v59(v68, v69, v58);
  }
  return v11;
}

uint64_t sub_100441FD4(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62 != 1)
  {
    if (a2 >> 62 != 2) {
      return result;
    }
    swift_retain();
  }

  return swift_retain();
}

uint64_t sub_10044202C(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  if (!(*(unsigned int (**)(uint64_t, uint64_t, int *))(*((void *)v4 - 1) + 48))(a1, 1, v4))
  {
    uint64_t v5 = a1 + v4[5];
    uint64_t v6 = sub_100725D30();
    (*(void (**)(uint64_t, uint64_t))(*(void *)(v6 - 8) + 8))(v5, v6);
    sub_100442248(*(void *)(a1 + v4[6]), *(void *)(a1 + v4[6] + 8));
    sub_100442248(*(void *)(a1 + v4[7]), *(void *)(a1 + v4[7] + 8));
    uint64_t v7 = a1 + v4[8];
    uint64_t v8 = sub_100725CC0();
    (*(void (**)(uint64_t, uint64_t))(*(void *)(v8 - 8) + 8))(v7, v8);
    swift_bridgeObjectRelease();
  }
  uint64_t v9 = a1 + *(int *)(a2 + 20);
  uint64_t v10 = v9 + v4[5];
  uint64_t v11 = sub_100725D30();
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v11 - 8) + 8))(v10, v11);
  sub_100442248(*(void *)(v9 + v4[6]), *(void *)(v9 + v4[6] + 8));
  sub_100442248(*(void *)(v9 + v4[7]), *(void *)(v9 + v4[7] + 8));
  uint64_t v12 = v9 + v4[8];
  uint64_t v13 = sub_100725CC0();
  uint64_t v16 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v13 - 8) + 8);
  ((void (*)(void *__return_ptr, uint64_t, uint64_t))v16)((void *)(v13 - 8), v12, v13);
  swift_bridgeObjectRelease();
  uint64_t v14 = a1 + *(int *)(a2 + 24);

  return v16(v14, v13);
}

uint64_t sub_100442248(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62 != 1)
  {
    if (a2 >> 62 != 2) {
      return result;
    }
    swift_release();
  }

  return swift_release();
}

unsigned char *sub_1004422A0(unsigned char *a1, unsigned char *a2, uint64_t a3)
{
  uint64_t v6 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  uint64_t v7 = *((void *)v6 - 1);
  if ((*(unsigned int (**)(unsigned char *, uint64_t, int *))(v7 + 48))(a2, 1, v6))
  {
    uint64_t v8 = sub_100431F80(&qword_100A44A50);
    memcpy(a1, a2, *(void *)(*(void *)(v8 - 8) + 64));
  }
  else
  {
    *a1 = *a2;
    uint64_t v9 = v6[5];
    uint64_t v10 = &a1[v9];
    uint64_t v11 = &a2[v9];
    uint64_t v12 = sub_100725D30();
    (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v12 - 8) + 16))(v10, v11, v12);
    uint64_t v13 = v6[6];
    uint64_t v14 = (uint64_t *)&a1[v13];
    uint64_t v15 = (uint64_t *)&a2[v13];
    uint64_t v16 = *v15;
    unint64_t v17 = v15[1];
    sub_100441FD4(*v15, v17);
    *uint64_t v14 = v16;
    v14[1] = v17;
    uint64_t v18 = v6[7];
    uint64_t v19 = (uint64_t *)&a1[v18];
    unint64_t v20 = (uint64_t *)&a2[v18];
    uint64_t v21 = *v20;
    unint64_t v22 = v20[1];
    sub_100441FD4(*v20, v22);
    *uint64_t v19 = v21;
    v19[1] = v22;
    uint64_t v23 = v6[8];
    uint64_t v24 = &a1[v23];
    unint64_t v25 = &a2[v23];
    uint64_t v26 = sub_100725CC0();
    (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v26 - 8) + 16))(v24, v25, v26);
    uint64_t v27 = v6[9];
    Swift::Int v28 = &a1[v27];
    uint64_t v29 = &a2[v27];
    uint64_t v30 = v29[1];
    *Swift::Int v28 = *v29;
    v28[1] = v30;
    *(_DWORD *)&a1[v6[10]] = *(_DWORD *)&a2[v6[10]];
    *(_DWORD *)&a1[v6[11]] = *(_DWORD *)&a2[v6[11]];
    a1[v6[12]] = a2[v6[12]];
    uint64_t v31 = v6[13];
    uint64_t v32 = &a1[v31];
    uint64_t v33 = &a2[v31];
    v32[8] = v33[8];
    *(void *)uint64_t v32 = *(void *)v33;
    uint64_t v34 = *(void (**)(unsigned char *, void, uint64_t, int *))(v7 + 56);
    swift_bridgeObjectRetain();
    v34(a1, 0, 1, v6);
  }
  uint64_t v35 = *(int *)(a3 + 20);
  uint64_t v36 = &a1[v35];
  id v37 = &a2[v35];
  *uint64_t v36 = a2[v35];
  uint64_t v38 = v6[5];
  uint64_t v39 = &v36[v38];
  id v40 = &v37[v38];
  uint64_t v41 = sub_100725D30();
  (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v41 - 8) + 16))(v39, v40, v41);
  uint64_t v42 = v6[6];
  uint64_t v43 = (uint64_t *)&v36[v42];
  uint64_t v44 = (uint64_t *)&v37[v42];
  uint64_t v45 = *v44;
  unint64_t v46 = v44[1];
  sub_100441FD4(*v44, v46);
  *uint64_t v43 = v45;
  v43[1] = v46;
  uint64_t v47 = v6[7];
  uint64_t v48 = (uint64_t *)&v36[v47];
  unint64_t v49 = (uint64_t *)&v37[v47];
  uint64_t v50 = *v49;
  unint64_t v51 = v49[1];
  sub_100441FD4(*v49, v51);
  *uint64_t v48 = v50;
  v48[1] = v51;
  uint64_t v52 = v6[8];
  uint64_t v53 = &v36[v52];
  unint64_t v54 = &v37[v52];
  uint64_t v55 = sub_100725CC0();
  int v56 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v55 - 8) + 16);
  v56(v53, v54, v55);
  uint64_t v57 = v6[9];
  uint64_t v58 = &v36[v57];
  uint64_t v59 = &v37[v57];
  uint64_t v60 = v59[1];
  void *v58 = *v59;
  v58[1] = v60;
  *(_DWORD *)&v36[v6[10]] = *(_DWORD *)&v37[v6[10]];
  *(_DWORD *)&v36[v6[11]] = *(_DWORD *)&v37[v6[11]];
  v36[v6[12]] = v37[v6[12]];
  uint64_t v61 = v6[13];
  uint64_t v62 = &v36[v61];
  uint64_t v63 = &v37[v61];
  v62[8] = v63[8];
  *(void *)uint64_t v62 = *(void *)v63;
  uint64_t v64 = *(int *)(a3 + 24);
  uint64_t v65 = &a1[v64];
  int v66 = &a2[v64];
  swift_bridgeObjectRetain();
  v56(v65, v66, v55);
  return a1;
}

unsigned char *sub_100442658(unsigned char *a1, unsigned char *a2, uint64_t a3)
{
  uint64_t v6 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  uint64_t v7 = *((void *)v6 - 1);
  uint64_t v8 = *(uint64_t (**)(unsigned char *, uint64_t, int *))(v7 + 48);
  int v9 = v8(a1, 1, v6);
  int v10 = v8(a2, 1, v6);
  if (!v9)
  {
    if (!v10)
    {
      *a1 = *a2;
      uint64_t v72 = v6[5];
      uint64_t v73 = &a1[v72];
      int v74 = &a2[v72];
      uint64_t v75 = sub_100725D30();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v75 - 8) + 24))(v73, v74, v75);
      uint64_t v76 = v6[6];
      uint64_t v77 = (uint64_t *)&a1[v76];
      uint64_t v78 = (uint64_t *)&a2[v76];
      uint64_t v79 = *v78;
      unint64_t v80 = v78[1];
      sub_100441FD4(*v78, v80);
      uint64_t v81 = *v77;
      unint64_t v82 = v77[1];
      uint64_t *v77 = v79;
      v77[1] = v80;
      sub_100442248(v81, v82);
      uint64_t v83 = v6[7];
      os_log_type_t v84 = (uint64_t *)&a1[v83];
      char v85 = (uint64_t *)&a2[v83];
      uint64_t v86 = *v85;
      unint64_t v87 = v85[1];
      sub_100441FD4(*v85, v87);
      uint64_t v88 = *v84;
      unint64_t v89 = v84[1];
      uint64_t *v84 = v86;
      v84[1] = v87;
      sub_100442248(v88, v89);
      uint64_t v90 = v6[8];
      uint64_t v91 = &a1[v90];
      uint64_t v92 = &a2[v90];
      uint64_t v93 = sub_100725CC0();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v93 - 8) + 24))(v91, v92, v93);
      uint64_t v94 = v6[9];
      uint64_t v95 = &a1[v94];
      uint64_t v96 = &a2[v94];
      void *v95 = *v96;
      v95[1] = v96[1];
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(_DWORD *)&a1[v6[10]] = *(_DWORD *)&a2[v6[10]];
      *(_DWORD *)&a1[v6[11]] = *(_DWORD *)&a2[v6[11]];
      a1[v6[12]] = a2[v6[12]];
      uint64_t v97 = v6[13];
      uint64_t v98 = &a1[v97];
      uint64_t v99 = &a2[v97];
      uint64_t v100 = *(void *)v99;
      v98[8] = v99[8];
      *(void *)uint64_t v98 = v100;
      goto LABEL_7;
    }
    sub_1004324A4((uint64_t)a1, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    goto LABEL_6;
  }
  if (v10)
  {
LABEL_6:
    uint64_t v37 = sub_100431F80(&qword_100A44A50);
    memcpy(a1, a2, *(void *)(*(void *)(v37 - 8) + 64));
    goto LABEL_7;
  }
  *a1 = *a2;
  uint64_t v11 = v6[5];
  uint64_t v12 = &a1[v11];
  uint64_t v13 = &a2[v11];
  uint64_t v14 = sub_100725D30();
  (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v14 - 8) + 16))(v12, v13, v14);
  uint64_t v15 = v6[6];
  uint64_t v16 = (uint64_t *)&a1[v15];
  unint64_t v17 = (uint64_t *)&a2[v15];
  uint64_t v18 = *v17;
  unint64_t v19 = v17[1];
  sub_100441FD4(*v17, v19);
  *uint64_t v16 = v18;
  v16[1] = v19;
  uint64_t v20 = v6[7];
  uint64_t v21 = (uint64_t *)&a1[v20];
  unint64_t v22 = (uint64_t *)&a2[v20];
  uint64_t v23 = *v22;
  unint64_t v24 = v22[1];
  sub_100441FD4(*v22, v24);
  *uint64_t v21 = v23;
  v21[1] = v24;
  uint64_t v25 = v6[8];
  uint64_t v26 = &a1[v25];
  uint64_t v27 = &a2[v25];
  uint64_t v28 = sub_100725CC0();
  (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v28 - 8) + 16))(v26, v27, v28);
  uint64_t v29 = v6[9];
  uint64_t v30 = &a1[v29];
  uint64_t v31 = &a2[v29];
  *uint64_t v30 = *v31;
  v30[1] = v31[1];
  *(_DWORD *)&a1[v6[10]] = *(_DWORD *)&a2[v6[10]];
  *(_DWORD *)&a1[v6[11]] = *(_DWORD *)&a2[v6[11]];
  a1[v6[12]] = a2[v6[12]];
  uint64_t v32 = v6[13];
  uint64_t v33 = &a1[v32];
  uint64_t v34 = &a2[v32];
  char v35 = v34[8];
  *(void *)uint64_t v33 = *(void *)v34;
  v33[8] = v35;
  uint64_t v36 = *(void (**)(unsigned char *, void, uint64_t, int *))(v7 + 56);
  swift_bridgeObjectRetain();
  v36(a1, 0, 1, v6);
LABEL_7:
  uint64_t v38 = *(int *)(a3 + 20);
  uint64_t v39 = &a1[v38];
  id v40 = &a2[v38];
  *uint64_t v39 = a2[v38];
  uint64_t v41 = v6[5];
  uint64_t v42 = &v39[v41];
  uint64_t v43 = &v40[v41];
  uint64_t v44 = sub_100725D30();
  (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v44 - 8) + 24))(v42, v43, v44);
  uint64_t v45 = v6[6];
  unint64_t v46 = (uint64_t *)&v39[v45];
  uint64_t v47 = (uint64_t *)&v40[v45];
  uint64_t v48 = *v47;
  unint64_t v49 = v47[1];
  sub_100441FD4(*v47, v49);
  uint64_t v50 = *v46;
  unint64_t v51 = v46[1];
  uint64_t *v46 = v48;
  v46[1] = v49;
  sub_100442248(v50, v51);
  uint64_t v52 = v6[7];
  uint64_t v53 = (uint64_t *)&v39[v52];
  unint64_t v54 = (uint64_t *)&v40[v52];
  uint64_t v55 = *v54;
  unint64_t v56 = v54[1];
  sub_100441FD4(*v54, v56);
  uint64_t v57 = *v53;
  unint64_t v58 = v53[1];
  *uint64_t v53 = v55;
  v53[1] = v56;
  sub_100442248(v57, v58);
  uint64_t v59 = v6[8];
  uint64_t v60 = &v39[v59];
  uint64_t v61 = &v40[v59];
  uint64_t v62 = sub_100725CC0();
  uint64_t v63 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v62 - 8) + 24);
  v63(v60, v61, v62);
  uint64_t v64 = v6[9];
  uint64_t v65 = &v39[v64];
  int v66 = &v40[v64];
  *uint64_t v65 = *v66;
  v65[1] = v66[1];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)&v39[v6[10]] = *(_DWORD *)&v40[v6[10]];
  *(_DWORD *)&v39[v6[11]] = *(_DWORD *)&v40[v6[11]];
  v39[v6[12]] = v40[v6[12]];
  uint64_t v67 = v6[13];
  int v68 = &v39[v67];
  int v69 = &v40[v67];
  uint64_t v70 = *(void *)v69;
  v68[8] = v69[8];
  *(void *)int v68 = v70;
  v63(&a1[*(int *)(a3 + 24)], &a2[*(int *)(a3 + 24)], v62);
  return a1;
}

unsigned char *sub_100442BC8(unsigned char *a1, unsigned char *a2, uint64_t a3)
{
  uint64_t v6 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  uint64_t v7 = *((void *)v6 - 1);
  if ((*(unsigned int (**)(unsigned char *, uint64_t, int *))(v7 + 48))(a2, 1, v6))
  {
    uint64_t v8 = sub_100431F80(&qword_100A44A50);
    memcpy(a1, a2, *(void *)(*(void *)(v8 - 8) + 64));
  }
  else
  {
    *a1 = *a2;
    uint64_t v9 = v6[5];
    int v10 = &a1[v9];
    uint64_t v11 = &a2[v9];
    uint64_t v12 = sub_100725D30();
    (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v12 - 8) + 32))(v10, v11, v12);
    *(_OWORD *)&a1[v6[6]] = *(_OWORD *)&a2[v6[6]];
    *(_OWORD *)&a1[v6[7]] = *(_OWORD *)&a2[v6[7]];
    uint64_t v13 = v6[8];
    uint64_t v14 = &a1[v13];
    uint64_t v15 = &a2[v13];
    uint64_t v16 = sub_100725CC0();
    (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v16 - 8) + 32))(v14, v15, v16);
    *(_OWORD *)&a1[v6[9]] = *(_OWORD *)&a2[v6[9]];
    *(_DWORD *)&a1[v6[10]] = *(_DWORD *)&a2[v6[10]];
    *(_DWORD *)&a1[v6[11]] = *(_DWORD *)&a2[v6[11]];
    a1[v6[12]] = a2[v6[12]];
    uint64_t v17 = v6[13];
    uint64_t v18 = &a1[v17];
    unint64_t v19 = &a2[v17];
    *(void *)uint64_t v18 = *(void *)v19;
    v18[8] = v19[8];
    (*(void (**)(unsigned char *, void, uint64_t, int *))(v7 + 56))(a1, 0, 1, v6);
  }
  uint64_t v20 = *(int *)(a3 + 20);
  uint64_t v21 = &a1[v20];
  unint64_t v22 = &a2[v20];
  *uint64_t v21 = a2[v20];
  uint64_t v23 = v6[5];
  unint64_t v24 = &v21[v23];
  uint64_t v25 = &v22[v23];
  uint64_t v26 = sub_100725D30();
  (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v26 - 8) + 32))(v24, v25, v26);
  *(_OWORD *)&v21[v6[6]] = *(_OWORD *)&v22[v6[6]];
  *(_OWORD *)&v21[v6[7]] = *(_OWORD *)&v22[v6[7]];
  uint64_t v27 = v6[8];
  uint64_t v28 = &v21[v27];
  uint64_t v29 = &v22[v27];
  uint64_t v30 = sub_100725CC0();
  uint64_t v31 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v30 - 8) + 32);
  v31(v28, v29, v30);
  *(_OWORD *)&v21[v6[9]] = *(_OWORD *)&v22[v6[9]];
  *(_DWORD *)&v21[v6[10]] = *(_DWORD *)&v22[v6[10]];
  *(_DWORD *)&v21[v6[11]] = *(_DWORD *)&v22[v6[11]];
  v21[v6[12]] = v22[v6[12]];
  uint64_t v32 = v6[13];
  uint64_t v33 = &v21[v32];
  uint64_t v34 = &v22[v32];
  *(void *)uint64_t v33 = *(void *)v34;
  v33[8] = v34[8];
  v31(&a1[*(int *)(a3 + 24)], &a2[*(int *)(a3 + 24)], v30);
  return a1;
}

unsigned char *sub_100442F0C(unsigned char *a1, unsigned char *a2, uint64_t a3)
{
  uint64_t v6 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  uint64_t v7 = *((void *)v6 - 1);
  uint64_t v8 = *(uint64_t (**)(unsigned char *, uint64_t, int *))(v7 + 48);
  int v9 = v8(a1, 1, v6);
  int v10 = v8(a2, 1, v6);
  if (!v9)
  {
    if (!v10)
    {
      *a1 = *a2;
      uint64_t v50 = v6[5];
      unint64_t v51 = &a1[v50];
      uint64_t v52 = &a2[v50];
      uint64_t v53 = sub_100725D30();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v53 - 8) + 40))(v51, v52, v53);
      uint64_t v54 = v6[6];
      uint64_t v55 = *(void *)&a1[v54];
      unint64_t v56 = *(void *)&a1[v54 + 8];
      *(_OWORD *)&a1[v54] = *(_OWORD *)&a2[v54];
      sub_100442248(v55, v56);
      uint64_t v57 = v6[7];
      uint64_t v58 = *(void *)&a1[v57];
      unint64_t v59 = *(void *)&a1[v57 + 8];
      *(_OWORD *)&a1[v57] = *(_OWORD *)&a2[v57];
      sub_100442248(v58, v59);
      uint64_t v60 = v6[8];
      uint64_t v61 = &a1[v60];
      uint64_t v62 = &a2[v60];
      uint64_t v63 = sub_100725CC0();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v63 - 8) + 40))(v61, v62, v63);
      uint64_t v64 = v6[9];
      uint64_t v65 = &a1[v64];
      int v66 = (uint64_t *)&a2[v64];
      uint64_t v68 = *v66;
      uint64_t v67 = v66[1];
      *uint64_t v65 = v68;
      v65[1] = v67;
      swift_bridgeObjectRelease();
      *(_DWORD *)&a1[v6[10]] = *(_DWORD *)&a2[v6[10]];
      *(_DWORD *)&a1[v6[11]] = *(_DWORD *)&a2[v6[11]];
      a1[v6[12]] = a2[v6[12]];
      uint64_t v69 = v6[13];
      uint64_t v70 = &a1[v69];
      os_log_type_t v71 = &a2[v69];
      *(void *)uint64_t v70 = *(void *)v71;
      v70[8] = v71[8];
      goto LABEL_7;
    }
    sub_1004324A4((uint64_t)a1, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    goto LABEL_6;
  }
  if (v10)
  {
LABEL_6:
    uint64_t v22 = sub_100431F80(&qword_100A44A50);
    memcpy(a1, a2, *(void *)(*(void *)(v22 - 8) + 64));
    goto LABEL_7;
  }
  *a1 = *a2;
  uint64_t v11 = v6[5];
  uint64_t v12 = &a1[v11];
  uint64_t v13 = &a2[v11];
  uint64_t v14 = sub_100725D30();
  (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v14 - 8) + 32))(v12, v13, v14);
  *(_OWORD *)&a1[v6[6]] = *(_OWORD *)&a2[v6[6]];
  *(_OWORD *)&a1[v6[7]] = *(_OWORD *)&a2[v6[7]];
  uint64_t v15 = v6[8];
  uint64_t v16 = &a1[v15];
  uint64_t v17 = &a2[v15];
  uint64_t v18 = sub_100725CC0();
  (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v18 - 8) + 32))(v16, v17, v18);
  *(_OWORD *)&a1[v6[9]] = *(_OWORD *)&a2[v6[9]];
  *(_DWORD *)&a1[v6[10]] = *(_DWORD *)&a2[v6[10]];
  *(_DWORD *)&a1[v6[11]] = *(_DWORD *)&a2[v6[11]];
  a1[v6[12]] = a2[v6[12]];
  uint64_t v19 = v6[13];
  uint64_t v20 = &a1[v19];
  uint64_t v21 = &a2[v19];
  *(void *)uint64_t v20 = *(void *)v21;
  v20[8] = v21[8];
  (*(void (**)(unsigned char *, void, uint64_t, int *))(v7 + 56))(a1, 0, 1, v6);
LABEL_7:
  uint64_t v23 = *(int *)(a3 + 20);
  unint64_t v24 = &a1[v23];
  uint64_t v25 = &a2[v23];
  *unint64_t v24 = a2[v23];
  uint64_t v26 = v6[5];
  uint64_t v27 = &v24[v26];
  uint64_t v28 = &v25[v26];
  uint64_t v29 = sub_100725D30();
  (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v29 - 8) + 40))(v27, v28, v29);
  uint64_t v30 = v6[6];
  uint64_t v31 = *(void *)&v24[v30];
  unint64_t v32 = *(void *)&v24[v30 + 8];
  *(_OWORD *)&v24[v30] = *(_OWORD *)&v25[v30];
  sub_100442248(v31, v32);
  uint64_t v33 = v6[7];
  uint64_t v34 = *(void *)&v24[v33];
  unint64_t v35 = *(void *)&v24[v33 + 8];
  *(_OWORD *)&v24[v33] = *(_OWORD *)&v25[v33];
  sub_100442248(v34, v35);
  uint64_t v36 = v6[8];
  uint64_t v37 = &v24[v36];
  uint64_t v38 = &v25[v36];
  uint64_t v39 = sub_100725CC0();
  id v40 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v39 - 8) + 40);
  v40(v37, v38, v39);
  uint64_t v41 = v6[9];
  uint64_t v42 = &v24[v41];
  uint64_t v43 = (uint64_t *)&v25[v41];
  uint64_t v45 = *v43;
  uint64_t v44 = v43[1];
  *uint64_t v42 = v45;
  v42[1] = v44;
  swift_bridgeObjectRelease();
  *(_DWORD *)&v24[v6[10]] = *(_DWORD *)&v25[v6[10]];
  *(_DWORD *)&v24[v6[11]] = *(_DWORD *)&v25[v6[11]];
  v24[v6[12]] = v25[v6[12]];
  uint64_t v46 = v6[13];
  uint64_t v47 = &v24[v46];
  uint64_t v48 = &v25[v46];
  *(void *)uint64_t v47 = *(void *)v48;
  v47[8] = v48[8];
  v40(&a1[*(int *)(a3 + 24)], &a2[*(int *)(a3 + 24)], v39);
  return a1;
}

uint64_t sub_1004433E0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return _swift_getEnumTagSinglePayloadGeneric(a1, a2, a3, sub_1004433F4);
}

uint64_t sub_1004433F4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_100431F80(&qword_100A44A50);
  uint64_t v7 = *(void *)(v6 - 8);
  if (*(_DWORD *)(v7 + 84) == a2)
  {
    uint64_t v8 = v6;
    int v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 48);
    uint64_t v10 = a1;
LABEL_5:
    return v9(v10, a2, v8);
  }
  uint64_t v11 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  uint64_t v12 = *(void *)(v11 - 8);
  if (*(_DWORD *)(v12 + 84) == a2)
  {
    uint64_t v8 = v11;
    uint64_t v10 = a1 + *(int *)(a3 + 20);
    int v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v12 + 48);
    goto LABEL_5;
  }
  uint64_t v14 = sub_100725CC0();
  uint64_t v15 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v14 - 8) + 48);
  uint64_t v16 = v14;
  uint64_t v17 = a1 + *(int *)(a3 + 24);

  return v15(v17, a2, v16);
}

uint64_t sub_100443544(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _swift_storeEnumTagSinglePayloadGeneric(a1, a2, a3, a4, sub_100443558);
}

uint64_t sub_100443558(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8 = sub_100431F80(&qword_100A44A50);
  uint64_t v9 = *(void *)(v8 - 8);
  if (*(_DWORD *)(v9 + 84) == a3)
  {
    uint64_t v10 = v8;
    uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 56);
    uint64_t v12 = a1;
LABEL_5:
    return v11(v12, a2, a2, v10);
  }
  uint64_t v13 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  uint64_t v14 = *(void *)(v13 - 8);
  if (*(_DWORD *)(v14 + 84) == a3)
  {
    uint64_t v10 = v13;
    uint64_t v12 = a1 + *(int *)(a4 + 20);
    uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v14 + 56);
    goto LABEL_5;
  }
  uint64_t v16 = sub_100725CC0();
  uint64_t v17 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v16 - 8) + 56);
  uint64_t v18 = v16;
  uint64_t v19 = a1 + *(int *)(a4 + 24);

  return v17(v19, a2, a2, v18);
}

void sub_1004436B4()
{
  sub_1004437B8();
  if (v0 <= 0x3F)
  {
    type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
    if (v1 <= 0x3F)
    {
      sub_100725CC0();
      if (v2 <= 0x3F) {
        swift_initStructMetadata();
      }
    }
  }
}

void sub_1004437B8()
{
  if (!qword_100A44B18)
  {
    type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
    unint64_t v0 = sub_100726810();
    if (!v1) {
      atomic_store(v0, (unint64_t *)&qword_100A44B18);
    }
  }
}

uint64_t *sub_100443810(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  int v5 = *(_DWORD *)(*(void *)(a3 - 8) + 80);
  if ((v5 & 0x20000) != 0)
  {
    uint64_t v10 = *a2;
    *a1 = *a2;
    a1 = (uint64_t *)(v10 + ((v5 + 16) & ~(unint64_t)v5));
    swift_retain();
  }
  else
  {
    uint64_t v7 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
    uint64_t v8 = *((void *)v7 - 1);
    if ((*(unsigned int (**)(uint64_t *, uint64_t, int *))(v8 + 48))(a2, 1, v7))
    {
      uint64_t v9 = sub_100431F80(&qword_100A44A50);
      memcpy(a1, a2, *(void *)(*(void *)(v9 - 8) + 64));
    }
    else
    {
      *(unsigned char *)a1 = *(unsigned char *)a2;
      uint64_t v11 = v7[5];
      uint64_t v12 = (char *)a1 + v11;
      uint64_t v13 = (char *)a2 + v11;
      uint64_t v14 = sub_100725D30();
      (*(void (**)(char *, char *, uint64_t))(*(void *)(v14 - 8) + 16))(v12, v13, v14);
      uint64_t v15 = v7[6];
      uint64_t v16 = (uint64_t *)((char *)a1 + v15);
      uint64_t v17 = (uint64_t *)((char *)a2 + v15);
      uint64_t v18 = *v17;
      unint64_t v19 = v17[1];
      sub_100441FD4(*v17, v19);
      *uint64_t v16 = v18;
      v16[1] = v19;
      uint64_t v20 = v7[7];
      uint64_t v21 = (uint64_t *)((char *)a1 + v20);
      uint64_t v22 = (uint64_t *)((char *)a2 + v20);
      uint64_t v23 = *v22;
      unint64_t v24 = v22[1];
      sub_100441FD4(*v22, v24);
      *uint64_t v21 = v23;
      v21[1] = v24;
      uint64_t v25 = v7[8];
      uint64_t v26 = (char *)a1 + v25;
      uint64_t v27 = (char *)a2 + v25;
      uint64_t v28 = sub_100725CC0();
      (*(void (**)(char *, char *, uint64_t))(*(void *)(v28 - 8) + 16))(v26, v27, v28);
      uint64_t v29 = v7[9];
      uint64_t v30 = (uint64_t *)((char *)a1 + v29);
      uint64_t v31 = (uint64_t *)((char *)a2 + v29);
      uint64_t v32 = v31[1];
      *uint64_t v30 = *v31;
      v30[1] = v32;
      *(_DWORD *)((char *)a1 + v7[10]) = *(_DWORD *)((char *)a2 + v7[10]);
      *(_DWORD *)((char *)a1 + v7[11]) = *(_DWORD *)((char *)a2 + v7[11]);
      *((unsigned char *)a1 + v7[12]) = *((unsigned char *)a2 + v7[12]);
      uint64_t v33 = v7[13];
      uint64_t v34 = (char *)a1 + v33;
      unint64_t v35 = (char *)a2 + v33;
      v34[8] = v35[8];
      *(void *)uint64_t v34 = *(void *)v35;
      uint64_t v36 = *(void (**)(uint64_t *, void, uint64_t, int *))(v8 + 56);
      swift_bridgeObjectRetain();
      v36(a1, 0, 1, v7);
    }
    uint64_t v37 = *(int *)(a3 + 20);
    uint64_t v38 = (char *)a1 + v37;
    uint64_t v39 = (char *)a2 + v37;
    *uint64_t v38 = *((unsigned char *)a2 + v37);
    uint64_t v40 = v7[5];
    uint64_t v41 = &v38[v40];
    uint64_t v42 = &v39[v40];
    uint64_t v96 = sub_100725D30();
    uint64_t v95 = *(void (**)(unsigned char *, char *, uint64_t))(*(void *)(v96 - 8) + 16);
    v95(v41, v42, v96);
    uint64_t v43 = v7[6];
    uint64_t v97 = a3;
    uint64_t v44 = (uint64_t *)&v38[v43];
    uint64_t v45 = (uint64_t *)&v39[v43];
    uint64_t v46 = *v45;
    unint64_t v47 = v45[1];
    sub_100441FD4(*v45, v47);
    *uint64_t v44 = v46;
    v44[1] = v47;
    uint64_t v48 = v7[7];
    unint64_t v49 = (uint64_t *)&v38[v48];
    uint64_t v50 = (uint64_t *)&v39[v48];
    uint64_t v51 = *v50;
    unint64_t v52 = v50[1];
    sub_100441FD4(*v50, v52);
    *unint64_t v49 = v51;
    v49[1] = v52;
    uint64_t v53 = v7[8];
    uint64_t v54 = &v38[v53];
    uint64_t v55 = &v39[v53];
    uint64_t v56 = sub_100725CC0();
    uint64_t v57 = a2;
    uint64_t v94 = a2;
    uint64_t v58 = *(void (**)(char *, char *, uint64_t))(*(void *)(v56 - 8) + 16);
    v58(v54, v55, v56);
    uint64_t v59 = v7[9];
    uint64_t v60 = &v38[v59];
    uint64_t v61 = &v39[v59];
    uint64_t v62 = *((void *)v61 + 1);
    void *v60 = *(void *)v61;
    v60[1] = v62;
    *(_DWORD *)&v38[v7[10]] = *(_DWORD *)&v39[v7[10]];
    *(_DWORD *)&v38[v7[11]] = *(_DWORD *)&v39[v7[11]];
    v38[v7[12]] = v39[v7[12]];
    uint64_t v63 = v7[13];
    uint64_t v64 = &v38[v63];
    uint64_t v65 = &v39[v63];
    *(void *)uint64_t v64 = *(void *)v65;
    void v64[8] = v65[8];
    uint64_t v66 = *(int *)(v97 + 24);
    uint64_t v67 = (char *)a1 + v66;
    uint64_t v68 = (char *)v57 + v66;
    *uint64_t v67 = *((unsigned char *)v57 + v66);
    uint64_t v69 = v7[5];
    uint64_t v70 = &v67[v69];
    os_log_type_t v71 = &v68[v69];
    swift_bridgeObjectRetain();
    v95(v70, v71, v96);
    uint64_t v72 = v7[6];
    uint64_t v73 = (uint64_t *)&v67[v72];
    int v74 = (uint64_t *)&v68[v72];
    uint64_t v75 = *v74;
    unint64_t v76 = v74[1];
    sub_100441FD4(*v74, v76);
    *uint64_t v73 = v75;
    v73[1] = v76;
    uint64_t v77 = v7[7];
    uint64_t v78 = (uint64_t *)&v67[v77];
    uint64_t v79 = (uint64_t *)&v68[v77];
    uint64_t v80 = *v79;
    unint64_t v81 = v79[1];
    sub_100441FD4(*v79, v81);
    uint64_t *v78 = v80;
    v78[1] = v81;
    unint64_t v82 = v58;
    v58(&v67[v7[8]], &v68[v7[8]], v56);
    uint64_t v83 = v7[9];
    os_log_type_t v84 = &v67[v83];
    char v85 = &v68[v83];
    uint64_t v86 = *((void *)v85 + 1);
    void *v84 = *(void *)v85;
    v84[1] = v86;
    *(_DWORD *)&v67[v7[10]] = *(_DWORD *)&v68[v7[10]];
    *(_DWORD *)&v67[v7[11]] = *(_DWORD *)&v68[v7[11]];
    v67[v7[12]] = v68[v7[12]];
    uint64_t v87 = v7[13];
    uint64_t v88 = &v67[v87];
    unint64_t v89 = &v68[v87];
    v88[8] = v89[8];
    *(void *)uint64_t v88 = *(void *)v89;
    uint64_t v90 = *(int *)(v97 + 28);
    uint64_t v91 = (char *)a1 + v90;
    uint64_t v92 = (char *)v94 + v90;
    swift_bridgeObjectRetain();
    v82(v91, v92, v56);
  }
  return a1;
}

uint64_t sub_100443D20(uint64_t a1, int *a2)
{
  unsigned int v4 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  if (!(*(unsigned int (**)(uint64_t, uint64_t, int *))(*((void *)v4 - 1) + 48))(a1, 1, v4))
  {
    uint64_t v5 = a1 + v4[5];
    uint64_t v6 = sub_100725D30();
    (*(void (**)(uint64_t, uint64_t))(*(void *)(v6 - 8) + 8))(v5, v6);
    sub_100442248(*(void *)(a1 + v4[6]), *(void *)(a1 + v4[6] + 8));
    sub_100442248(*(void *)(a1 + v4[7]), *(void *)(a1 + v4[7] + 8));
    uint64_t v7 = a1 + v4[8];
    uint64_t v8 = sub_100725CC0();
    (*(void (**)(uint64_t, uint64_t))(*(void *)(v8 - 8) + 8))(v7, v8);
    swift_bridgeObjectRelease();
  }
  uint64_t v9 = a1 + a2[5];
  uint64_t v10 = v9 + v4[5];
  uint64_t v11 = sub_100725D30();
  uint64_t v12 = *(void (**)(uint64_t, uint64_t))(*(void *)(v11 - 8) + 8);
  v12(v10, v11);
  sub_100442248(*(void *)(v9 + v4[6]), *(void *)(v9 + v4[6] + 8));
  sub_100442248(*(void *)(v9 + v4[7]), *(void *)(v9 + v4[7] + 8));
  uint64_t v13 = v9 + v4[8];
  uint64_t v14 = sub_100725CC0();
  uint64_t v18 = *(void (**)(uint64_t, uint64_t))(*(void *)(v14 - 8) + 8);
  ((void (*)(void *__return_ptr, uint64_t, uint64_t))v18)((void *)(v14 - 8), v13, v14);
  swift_bridgeObjectRelease();
  uint64_t v15 = a1 + a2[6];
  v12(v15 + v4[5], v11);
  sub_100442248(*(void *)(v15 + v4[6]), *(void *)(v15 + v4[6] + 8));
  sub_100442248(*(void *)(v15 + v4[7]), *(void *)(v15 + v4[7] + 8));
  v18(v15 + v4[8], v14);
  swift_bridgeObjectRelease();
  uint64_t v16 = a1 + a2[7];

  return ((uint64_t (*)(uint64_t, uint64_t))v18)(v16, v14);
}

unsigned char *sub_100443FBC(unsigned char *a1, unsigned char *a2, uint64_t a3)
{
  uint64_t v6 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  uint64_t v7 = *((void *)v6 - 1);
  if ((*(unsigned int (**)(unsigned char *, uint64_t, int *))(v7 + 48))(a2, 1, v6))
  {
    uint64_t v8 = sub_100431F80(&qword_100A44A50);
    memcpy(a1, a2, *(void *)(*(void *)(v8 - 8) + 64));
  }
  else
  {
    *a1 = *a2;
    uint64_t v9 = v6[5];
    uint64_t v10 = &a1[v9];
    uint64_t v11 = &a2[v9];
    uint64_t v12 = sub_100725D30();
    (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v12 - 8) + 16))(v10, v11, v12);
    uint64_t v13 = v6[6];
    uint64_t v14 = (uint64_t *)&a1[v13];
    uint64_t v15 = (uint64_t *)&a2[v13];
    uint64_t v16 = *v15;
    unint64_t v17 = v15[1];
    sub_100441FD4(*v15, v17);
    *uint64_t v14 = v16;
    v14[1] = v17;
    uint64_t v18 = v6[7];
    unint64_t v19 = (uint64_t *)&a1[v18];
    uint64_t v20 = (uint64_t *)&a2[v18];
    uint64_t v21 = *v20;
    unint64_t v22 = v20[1];
    sub_100441FD4(*v20, v22);
    *unint64_t v19 = v21;
    v19[1] = v22;
    uint64_t v23 = v6[8];
    unint64_t v24 = &a1[v23];
    uint64_t v25 = &a2[v23];
    uint64_t v26 = sub_100725CC0();
    (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v26 - 8) + 16))(v24, v25, v26);
    uint64_t v27 = v6[9];
    uint64_t v28 = &a1[v27];
    uint64_t v29 = &a2[v27];
    uint64_t v30 = v29[1];
    *uint64_t v28 = *v29;
    v28[1] = v30;
    *(_DWORD *)&a1[v6[10]] = *(_DWORD *)&a2[v6[10]];
    *(_DWORD *)&a1[v6[11]] = *(_DWORD *)&a2[v6[11]];
    a1[v6[12]] = a2[v6[12]];
    uint64_t v31 = v6[13];
    uint64_t v32 = &a1[v31];
    uint64_t v33 = &a2[v31];
    v32[8] = v33[8];
    *(void *)uint64_t v32 = *(void *)v33;
    uint64_t v34 = *(void (**)(unsigned char *, void, uint64_t, int *))(v7 + 56);
    swift_bridgeObjectRetain();
    v34(a1, 0, 1, v6);
  }
  uint64_t v35 = *(int *)(a3 + 20);
  uint64_t v92 = a3;
  uint64_t v36 = &a1[v35];
  uint64_t v37 = &a2[v35];
  *uint64_t v36 = a2[v35];
  uint64_t v38 = v6[5];
  uint64_t v39 = &v36[v38];
  uint64_t v40 = &v37[v38];
  uint64_t v41 = sub_100725D30();
  uint64_t v91 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v41 - 8) + 16);
  v91(v39, v40, v41);
  uint64_t v42 = v6[6];
  uint64_t v43 = (uint64_t *)&v36[v42];
  uint64_t v44 = (uint64_t *)&v37[v42];
  uint64_t v45 = *v44;
  unint64_t v46 = v44[1];
  sub_100441FD4(*v44, v46);
  *uint64_t v43 = v45;
  v43[1] = v46;
  uint64_t v47 = v6[7];
  uint64_t v48 = (uint64_t *)&v36[v47];
  unint64_t v49 = (uint64_t *)&v37[v47];
  uint64_t v50 = *v49;
  unint64_t v51 = v49[1];
  sub_100441FD4(*v49, v51);
  *uint64_t v48 = v50;
  v48[1] = v51;
  uint64_t v52 = v6[8];
  uint64_t v53 = &v36[v52];
  uint64_t v54 = &v37[v52];
  uint64_t v55 = sub_100725CC0();
  uint64_t v90 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v55 - 8) + 16);
  v90(v53, v54, v55);
  uint64_t v56 = v6[9];
  uint64_t v57 = &v36[v56];
  uint64_t v58 = &v37[v56];
  uint64_t v59 = v58[1];
  void *v57 = *v58;
  v57[1] = v59;
  *(_DWORD *)&v36[v6[10]] = *(_DWORD *)&v37[v6[10]];
  *(_DWORD *)&v36[v6[11]] = *(_DWORD *)&v37[v6[11]];
  v36[v6[12]] = v37[v6[12]];
  uint64_t v60 = v6[13];
  uint64_t v61 = &v36[v60];
  uint64_t v62 = &v37[v60];
  *(void *)uint64_t v61 = *(void *)v62;
  v61[8] = v62[8];
  uint64_t v63 = *(int *)(v92 + 24);
  uint64_t v64 = &a1[v63];
  uint64_t v65 = &a2[v63];
  unsigned char *v64 = a2[v63];
  uint64_t v66 = v6[5];
  uint64_t v67 = &v64[v66];
  uint64_t v68 = &v65[v66];
  swift_bridgeObjectRetain();
  v91(v67, v68, v41);
  uint64_t v69 = v6[6];
  uint64_t v70 = (uint64_t *)&v64[v69];
  os_log_type_t v71 = (uint64_t *)&v65[v69];
  uint64_t v72 = *v71;
  unint64_t v73 = v71[1];
  sub_100441FD4(*v71, v73);
  uint64_t *v70 = v72;
  v70[1] = v73;
  uint64_t v74 = v6[7];
  uint64_t v75 = (uint64_t *)&v64[v74];
  unint64_t v76 = (uint64_t *)&v65[v74];
  uint64_t v77 = *v76;
  unint64_t v78 = v76[1];
  sub_100441FD4(*v76, v78);
  *uint64_t v75 = v77;
  v75[1] = v78;
  v90(&v64[v6[8]], &v65[v6[8]], v55);
  uint64_t v79 = v6[9];
  uint64_t v80 = &v64[v79];
  unint64_t v81 = &v65[v79];
  uint64_t v82 = v81[1];
  void *v80 = *v81;
  v80[1] = v82;
  *(_DWORD *)&v64[v6[10]] = *(_DWORD *)&v65[v6[10]];
  *(_DWORD *)&v64[v6[11]] = *(_DWORD *)&v65[v6[11]];
  v64[v6[12]] = v65[v6[12]];
  uint64_t v83 = v6[13];
  os_log_type_t v84 = &v64[v83];
  char v85 = &v65[v83];
  v84[8] = v85[8];
  *(void *)os_log_type_t v84 = *(void *)v85;
  uint64_t v86 = *(int *)(v92 + 28);
  uint64_t v87 = &a1[v86];
  uint64_t v88 = &a2[v86];
  swift_bridgeObjectRetain();
  v90(v87, v88, v55);
  return a1;
}

unsigned char *sub_100444470(unsigned char *a1, unsigned char *a2, int *a3)
{
  uint64_t v6 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  uint64_t v7 = *((void *)v6 - 1);
  uint64_t v8 = *(uint64_t (**)(unsigned char *, uint64_t, int *))(v7 + 48);
  int v9 = v8(a1, 1, v6);
  int v10 = v8(a2, 1, v6);
  if (!v9)
  {
    if (!v10)
    {
      *a1 = *a2;
      uint64_t v96 = v6[5];
      uint64_t v97 = &a1[v96];
      uint64_t v98 = &a2[v96];
      uint64_t v99 = sub_100725D30();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v99 - 8) + 24))(v97, v98, v99);
      uint64_t v100 = v6[6];
      uint64_t v101 = (uint64_t *)&a1[v100];
      uint64_t v102 = (uint64_t *)&a2[v100];
      uint64_t v103 = *v102;
      unint64_t v104 = v102[1];
      sub_100441FD4(*v102, v104);
      uint64_t v105 = *v101;
      unint64_t v106 = v101[1];
      uint64_t *v101 = v103;
      v101[1] = v104;
      sub_100442248(v105, v106);
      uint64_t v107 = v6[7];
      uint64_t v108 = (uint64_t *)&a1[v107];
      uint64_t v109 = (uint64_t *)&a2[v107];
      uint64_t v110 = *v109;
      unint64_t v111 = v109[1];
      sub_100441FD4(*v109, v111);
      uint64_t v112 = *v108;
      unint64_t v113 = v108[1];
      uint64_t *v108 = v110;
      v108[1] = v111;
      sub_100442248(v112, v113);
      uint64_t v114 = v6[8];
      int v115 = &a1[v114];
      uint64_t v116 = &a2[v114];
      uint64_t v117 = sub_100725CC0();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v117 - 8) + 24))(v115, v116, v117);
      uint64_t v118 = v6[9];
      uint64_t v119 = &a1[v118];
      uint64_t v120 = &a2[v118];
      *uint64_t v119 = *v120;
      v119[1] = v120[1];
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(_DWORD *)&a1[v6[10]] = *(_DWORD *)&a2[v6[10]];
      *(_DWORD *)&a1[v6[11]] = *(_DWORD *)&a2[v6[11]];
      a1[v6[12]] = a2[v6[12]];
      uint64_t v121 = v6[13];
      os_log_t v122 = &a1[v121];
      uint64_t v123 = &a2[v121];
      uint64_t v124 = *(void *)v123;
      v122[8] = v123[8];
      *(void *)os_log_t v122 = v124;
      goto LABEL_7;
    }
    sub_1004324A4((uint64_t)a1, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    goto LABEL_6;
  }
  if (v10)
  {
LABEL_6:
    uint64_t v37 = sub_100431F80(&qword_100A44A50);
    memcpy(a1, a2, *(void *)(*(void *)(v37 - 8) + 64));
    goto LABEL_7;
  }
  *a1 = *a2;
  uint64_t v11 = v6[5];
  uint64_t v12 = &a1[v11];
  uint64_t v13 = &a2[v11];
  uint64_t v14 = sub_100725D30();
  (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v14 - 8) + 16))(v12, v13, v14);
  uint64_t v15 = v6[6];
  uint64_t v16 = (uint64_t *)&a1[v15];
  unint64_t v17 = (uint64_t *)&a2[v15];
  uint64_t v18 = *v17;
  unint64_t v19 = v17[1];
  sub_100441FD4(*v17, v19);
  *uint64_t v16 = v18;
  v16[1] = v19;
  uint64_t v20 = v6[7];
  uint64_t v21 = (uint64_t *)&a1[v20];
  unint64_t v22 = (uint64_t *)&a2[v20];
  uint64_t v23 = *v22;
  unint64_t v24 = v22[1];
  sub_100441FD4(*v22, v24);
  *uint64_t v21 = v23;
  v21[1] = v24;
  uint64_t v25 = v6[8];
  uint64_t v26 = &a1[v25];
  uint64_t v27 = &a2[v25];
  uint64_t v28 = sub_100725CC0();
  (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v28 - 8) + 16))(v26, v27, v28);
  uint64_t v29 = v6[9];
  uint64_t v30 = &a1[v29];
  uint64_t v31 = &a2[v29];
  *uint64_t v30 = *v31;
  v30[1] = v31[1];
  *(_DWORD *)&a1[v6[10]] = *(_DWORD *)&a2[v6[10]];
  *(_DWORD *)&a1[v6[11]] = *(_DWORD *)&a2[v6[11]];
  a1[v6[12]] = a2[v6[12]];
  uint64_t v32 = v6[13];
  uint64_t v33 = &a1[v32];
  uint64_t v34 = &a2[v32];
  char v35 = v34[8];
  *(void *)uint64_t v33 = *(void *)v34;
  v33[8] = v35;
  uint64_t v36 = *(void (**)(unsigned char *, void, uint64_t, int *))(v7 + 56);
  swift_bridgeObjectRetain();
  v36(a1, 0, 1, v6);
LABEL_7:
  uint64_t v38 = a3[5];
  uint64_t v39 = &a1[v38];
  id v126 = a1;
  uint64_t v40 = &a2[v38];
  *uint64_t v39 = a2[v38];
  uint64_t v41 = v6[5];
  uint64_t v42 = &v39[v41];
  uint64_t v43 = &v40[v41];
  uint64_t v44 = sub_100725D30();
  uint64_t v125 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v44 - 8) + 24);
  v125(v42, v43, v44);
  uint64_t v45 = v6[6];
  int v127 = a2;
  unint64_t v46 = (uint64_t *)&v39[v45];
  uint64_t v47 = (uint64_t *)&v40[v45];
  uint64_t v48 = *v47;
  unint64_t v49 = v47[1];
  sub_100441FD4(*v47, v49);
  uint64_t v50 = *v46;
  unint64_t v51 = v46[1];
  uint64_t *v46 = v48;
  v46[1] = v49;
  sub_100442248(v50, v51);
  uint64_t v52 = v6[7];
  uint64_t v53 = (uint64_t *)&v39[v52];
  uint64_t v54 = (uint64_t *)&v40[v52];
  uint64_t v55 = *v54;
  unint64_t v56 = v54[1];
  sub_100441FD4(*v54, v56);
  uint64_t v57 = *v53;
  unint64_t v58 = v53[1];
  *uint64_t v53 = v55;
  v53[1] = v56;
  sub_100442248(v57, v58);
  uint64_t v59 = v6[8];
  uint64_t v60 = &v39[v59];
  uint64_t v61 = &v40[v59];
  uint64_t v62 = sub_100725CC0();
  uint64_t v63 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v62 - 8) + 24);
  v63(v60, v61, v62);
  uint64_t v64 = v6[9];
  uint64_t v65 = &v39[v64];
  uint64_t v66 = &v40[v64];
  *uint64_t v65 = *v66;
  v65[1] = v66[1];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)&v39[v6[10]] = *(_DWORD *)&v40[v6[10]];
  *(_DWORD *)&v39[v6[11]] = *(_DWORD *)&v40[v6[11]];
  v39[v6[12]] = v40[v6[12]];
  uint64_t v67 = v6[13];
  uint64_t v68 = &v39[v67];
  uint64_t v69 = &v40[v67];
  uint64_t v70 = *(void *)v69;
  v68[8] = v69[8];
  *(void *)uint64_t v68 = v70;
  uint64_t v71 = a3[6];
  uint64_t v72 = &v126[v71];
  unint64_t v73 = &v127[v71];
  v126[v71] = v127[v71];
  v125(&v126[v71 + v6[5]], &v127[v71 + v6[5]], v44);
  uint64_t v74 = v6[6];
  uint64_t v75 = (uint64_t *)&v72[v74];
  unint64_t v76 = (uint64_t *)&v73[v74];
  uint64_t v77 = *v76;
  unint64_t v78 = v76[1];
  sub_100441FD4(*v76, v78);
  uint64_t v79 = *v75;
  unint64_t v80 = v75[1];
  *uint64_t v75 = v77;
  v75[1] = v78;
  sub_100442248(v79, v80);
  uint64_t v81 = v6[7];
  uint64_t v82 = (uint64_t *)&v72[v81];
  uint64_t v83 = (uint64_t *)&v73[v81];
  uint64_t v84 = *v83;
  unint64_t v85 = v83[1];
  sub_100441FD4(*v83, v85);
  uint64_t v86 = *v82;
  unint64_t v87 = v82[1];
  uint64_t *v82 = v84;
  v82[1] = v85;
  sub_100442248(v86, v87);
  v63(&v72[v6[8]], &v73[v6[8]], v62);
  uint64_t v88 = v6[9];
  unint64_t v89 = &v72[v88];
  uint64_t v90 = &v73[v88];
  void *v89 = *v90;
  v89[1] = v90[1];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)&v72[v6[10]] = *(_DWORD *)&v73[v6[10]];
  *(_DWORD *)&v72[v6[11]] = *(_DWORD *)&v73[v6[11]];
  v72[v6[12]] = v73[v6[12]];
  uint64_t v91 = v6[13];
  uint64_t v92 = &v72[v91];
  uint64_t v93 = (uint64_t *)&v73[v91];
  uint64_t v94 = *v93;
  v92[8] = *((unsigned char *)v93 + 8);
  *(void *)uint64_t v92 = v94;
  v63(&v126[a3[7]], &v127[a3[7]], v62);
  return v126;
}

unsigned char *sub_100444B00(unsigned char *a1, unsigned char *a2, uint64_t a3)
{
  uint64_t v6 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  uint64_t v7 = *((void *)v6 - 1);
  if ((*(unsigned int (**)(unsigned char *, uint64_t, int *))(v7 + 48))(a2, 1, v6))
  {
    uint64_t v8 = sub_100431F80(&qword_100A44A50);
    memcpy(a1, a2, *(void *)(*(void *)(v8 - 8) + 64));
  }
  else
  {
    *a1 = *a2;
    uint64_t v9 = v6[5];
    int v10 = &a1[v9];
    uint64_t v11 = &a2[v9];
    uint64_t v12 = sub_100725D30();
    (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v12 - 8) + 32))(v10, v11, v12);
    *(_OWORD *)&a1[v6[6]] = *(_OWORD *)&a2[v6[6]];
    *(_OWORD *)&a1[v6[7]] = *(_OWORD *)&a2[v6[7]];
    uint64_t v13 = v6[8];
    uint64_t v14 = &a1[v13];
    uint64_t v15 = &a2[v13];
    uint64_t v16 = sub_100725CC0();
    (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v16 - 8) + 32))(v14, v15, v16);
    *(_OWORD *)&a1[v6[9]] = *(_OWORD *)&a2[v6[9]];
    *(_DWORD *)&a1[v6[10]] = *(_DWORD *)&a2[v6[10]];
    *(_DWORD *)&a1[v6[11]] = *(_DWORD *)&a2[v6[11]];
    a1[v6[12]] = a2[v6[12]];
    uint64_t v17 = v6[13];
    uint64_t v18 = &a1[v17];
    unint64_t v19 = &a2[v17];
    *(void *)uint64_t v18 = *(void *)v19;
    v18[8] = v19[8];
    (*(void (**)(unsigned char *, void, uint64_t, int *))(v7 + 56))(a1, 0, 1, v6);
  }
  uint64_t v20 = *(int *)(a3 + 20);
  uint64_t v43 = a2;
  uint64_t v44 = a3;
  uint64_t v21 = &a1[v20];
  unint64_t v22 = &a2[v20];
  *uint64_t v21 = *v22;
  uint64_t v23 = v6[5];
  unint64_t v24 = &v21[v23];
  uint64_t v25 = &v22[v23];
  uint64_t v26 = sub_100725D30();
  uint64_t v42 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v26 - 8) + 32);
  v42(v24, v25, v26);
  *(_OWORD *)&v21[v6[6]] = *(_OWORD *)&v22[v6[6]];
  *(_OWORD *)&v21[v6[7]] = *(_OWORD *)&v22[v6[7]];
  uint64_t v27 = v6[8];
  uint64_t v28 = &v21[v27];
  uint64_t v29 = &v22[v27];
  uint64_t v30 = sub_100725CC0();
  uint64_t v31 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v30 - 8) + 32);
  v31(v28, v29, v30);
  *(_OWORD *)&v21[v6[9]] = *(_OWORD *)&v22[v6[9]];
  *(_DWORD *)&v21[v6[10]] = *(_DWORD *)&v22[v6[10]];
  *(_DWORD *)&v21[v6[11]] = *(_DWORD *)&v22[v6[11]];
  v21[v6[12]] = v22[v6[12]];
  uint64_t v32 = v6[13];
  uint64_t v33 = &v21[v32];
  uint64_t v34 = &v22[v32];
  *(void *)uint64_t v33 = *(void *)v34;
  v33[8] = v34[8];
  uint64_t v35 = *(int *)(v44 + 24);
  uint64_t v36 = &a1[v35];
  uint64_t v37 = &v43[v35];
  a1[v35] = v43[v35];
  v42(&a1[v35 + v6[5]], &v43[v35 + v6[5]], v26);
  *(_OWORD *)&v36[v6[6]] = *(_OWORD *)&v37[v6[6]];
  *(_OWORD *)&v36[v6[7]] = *(_OWORD *)&v37[v6[7]];
  v31(&v36[v6[8]], &v37[v6[8]], v30);
  *(_OWORD *)&v36[v6[9]] = *(_OWORD *)&v37[v6[9]];
  *(_DWORD *)&v36[v6[10]] = *(_DWORD *)&v37[v6[10]];
  *(_DWORD *)&v36[v6[11]] = *(_DWORD *)&v37[v6[11]];
  v36[v6[12]] = v37[v6[12]];
  uint64_t v38 = v6[13];
  uint64_t v39 = &v36[v38];
  uint64_t v40 = &v37[v38];
  *(void *)uint64_t v39 = *(void *)v40;
  v39[8] = v40[8];
  v31(&a1[*(int *)(v44 + 28)], &v43[*(int *)(v44 + 28)], v30);
  return a1;
}

unsigned char *sub_100444EFC(unsigned char *a1, unsigned char *a2, int *a3)
{
  uint64_t v6 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  uint64_t v7 = *((void *)v6 - 1);
  uint64_t v8 = *(uint64_t (**)(unsigned char *, uint64_t, int *))(v7 + 48);
  int v9 = v8(a1, 1, v6);
  int v10 = v8(a2, 1, v6);
  if (!v9)
  {
    if (!v10)
    {
      *a1 = *a2;
      uint64_t v67 = v6[5];
      uint64_t v68 = &a1[v67];
      uint64_t v69 = &a2[v67];
      uint64_t v70 = sub_100725D30();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v70 - 8) + 40))(v68, v69, v70);
      uint64_t v71 = v6[6];
      uint64_t v72 = *(void *)&a1[v71];
      unint64_t v73 = *(void *)&a1[v71 + 8];
      *(_OWORD *)&a1[v71] = *(_OWORD *)&a2[v71];
      sub_100442248(v72, v73);
      uint64_t v74 = v6[7];
      uint64_t v75 = *(void *)&a1[v74];
      unint64_t v76 = *(void *)&a1[v74 + 8];
      *(_OWORD *)&a1[v74] = *(_OWORD *)&a2[v74];
      sub_100442248(v75, v76);
      uint64_t v77 = v6[8];
      unint64_t v78 = &a1[v77];
      uint64_t v79 = &a2[v77];
      uint64_t v80 = sub_100725CC0();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v80 - 8) + 40))(v78, v79, v80);
      uint64_t v81 = v6[9];
      uint64_t v82 = &a1[v81];
      uint64_t v83 = (uint64_t *)&a2[v81];
      uint64_t v85 = *v83;
      uint64_t v84 = v83[1];
      void *v82 = v85;
      v82[1] = v84;
      swift_bridgeObjectRelease();
      *(_DWORD *)&a1[v6[10]] = *(_DWORD *)&a2[v6[10]];
      *(_DWORD *)&a1[v6[11]] = *(_DWORD *)&a2[v6[11]];
      a1[v6[12]] = a2[v6[12]];
      uint64_t v86 = v6[13];
      unint64_t v87 = &a1[v86];
      uint64_t v88 = &a2[v86];
      *(void *)unint64_t v87 = *(void *)v88;
      v87[8] = v88[8];
      goto LABEL_7;
    }
    sub_1004324A4((uint64_t)a1, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionKeyMaterialContent);
    goto LABEL_6;
  }
  if (v10)
  {
LABEL_6:
    uint64_t v22 = sub_100431F80(&qword_100A44A50);
    memcpy(a1, a2, *(void *)(*(void *)(v22 - 8) + 64));
    goto LABEL_7;
  }
  *a1 = *a2;
  uint64_t v11 = v6[5];
  uint64_t v12 = &a1[v11];
  uint64_t v13 = &a2[v11];
  uint64_t v14 = sub_100725D30();
  (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v14 - 8) + 32))(v12, v13, v14);
  *(_OWORD *)&a1[v6[6]] = *(_OWORD *)&a2[v6[6]];
  *(_OWORD *)&a1[v6[7]] = *(_OWORD *)&a2[v6[7]];
  uint64_t v15 = v6[8];
  uint64_t v16 = &a1[v15];
  uint64_t v17 = &a2[v15];
  uint64_t v18 = sub_100725CC0();
  (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v18 - 8) + 32))(v16, v17, v18);
  *(_OWORD *)&a1[v6[9]] = *(_OWORD *)&a2[v6[9]];
  *(_DWORD *)&a1[v6[10]] = *(_DWORD *)&a2[v6[10]];
  *(_DWORD *)&a1[v6[11]] = *(_DWORD *)&a2[v6[11]];
  a1[v6[12]] = a2[v6[12]];
  uint64_t v19 = v6[13];
  uint64_t v20 = &a1[v19];
  uint64_t v21 = &a2[v19];
  *(void *)uint64_t v20 = *(void *)v21;
  v20[8] = v21[8];
  (*(void (**)(unsigned char *, void, uint64_t, int *))(v7 + 56))(a1, 0, 1, v6);
LABEL_7:
  uint64_t v23 = a3[5];
  unint64_t v24 = &a1[v23];
  uint64_t v91 = a1;
  uint64_t v25 = &a2[v23];
  *unint64_t v24 = a2[v23];
  uint64_t v26 = v6[5];
  uint64_t v27 = &v24[v26];
  uint64_t v28 = &v25[v26];
  uint64_t v29 = sub_100725D30();
  uint64_t v90 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v29 - 8) + 40);
  v90(v27, v28, v29);
  uint64_t v30 = v6[6];
  uint64_t v31 = *(void *)&v24[v30];
  unint64_t v32 = *(void *)&v24[v30 + 8];
  *(_OWORD *)&v24[v30] = *(_OWORD *)&v25[v30];
  sub_100442248(v31, v32);
  uint64_t v33 = v6[7];
  uint64_t v34 = *(void *)&v24[v33];
  unint64_t v35 = *(void *)&v24[v33 + 8];
  *(_OWORD *)&v24[v33] = *(_OWORD *)&v25[v33];
  sub_100442248(v34, v35);
  uint64_t v36 = v6[8];
  uint64_t v37 = &v24[v36];
  unint64_t v89 = a2;
  uint64_t v38 = &v25[v36];
  uint64_t v39 = sub_100725CC0();
  uint64_t v40 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v39 - 8) + 40);
  v40(v37, v38, v39);
  uint64_t v41 = v6[9];
  uint64_t v42 = &v24[v41];
  uint64_t v43 = (uint64_t *)&v25[v41];
  uint64_t v45 = *v43;
  uint64_t v44 = v43[1];
  *uint64_t v42 = v45;
  v42[1] = v44;
  swift_bridgeObjectRelease();
  *(_DWORD *)&v24[v6[10]] = *(_DWORD *)&v25[v6[10]];
  *(_DWORD *)&v24[v6[11]] = *(_DWORD *)&v25[v6[11]];
  v24[v6[12]] = v25[v6[12]];
  uint64_t v46 = v6[13];
  uint64_t v47 = &v24[v46];
  uint64_t v48 = &v25[v46];
  *(void *)uint64_t v47 = *(void *)v48;
  v47[8] = v48[8];
  uint64_t v49 = a3[6];
  uint64_t v50 = &v91[v49];
  unint64_t v51 = &v89[v49];
  v91[v49] = v89[v49];
  v90(&v91[v49 + v6[5]], &v89[v49 + v6[5]], v29);
  uint64_t v52 = v6[6];
  uint64_t v53 = *(void *)&v50[v52];
  unint64_t v54 = *(void *)&v50[v52 + 8];
  *(_OWORD *)&v50[v52] = *(_OWORD *)&v51[v52];
  sub_100442248(v53, v54);
  uint64_t v55 = v6[7];
  uint64_t v56 = *(void *)&v50[v55];
  unint64_t v57 = *(void *)&v50[v55 + 8];
  *(_OWORD *)&v50[v55] = *(_OWORD *)&v51[v55];
  sub_100442248(v56, v57);
  v40(&v50[v6[8]], &v51[v6[8]], v39);
  uint64_t v58 = v6[9];
  uint64_t v59 = &v50[v58];
  uint64_t v60 = (uint64_t *)&v51[v58];
  uint64_t v62 = *v60;
  uint64_t v61 = v60[1];
  *uint64_t v59 = v62;
  v59[1] = v61;
  swift_bridgeObjectRelease();
  *(_DWORD *)&v50[v6[10]] = *(_DWORD *)&v51[v6[10]];
  *(_DWORD *)&v50[v6[11]] = *(_DWORD *)&v51[v6[11]];
  v50[v6[12]] = v51[v6[12]];
  uint64_t v63 = v6[13];
  uint64_t v64 = &v50[v63];
  uint64_t v65 = &v51[v63];
  *(void *)uint64_t v64 = *(void *)v65;
  void v64[8] = v65[8];
  v40(&v91[a3[7]], &v89[a3[7]], v39);
  return v91;
}

uint64_t sub_1004454B8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return _swift_getEnumTagSinglePayloadGeneric(a1, a2, a3, sub_1004454CC);
}

uint64_t sub_1004454CC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_100431F80(&qword_100A44A50);
  uint64_t v7 = *(void *)(v6 - 8);
  if (*(_DWORD *)(v7 + 84) == a2)
  {
    uint64_t v8 = v6;
    int v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 48);
    uint64_t v10 = a1;
LABEL_5:
    return v9(v10, a2, v8);
  }
  uint64_t v11 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  uint64_t v12 = *(void *)(v11 - 8);
  if (*(_DWORD *)(v12 + 84) == a2)
  {
    uint64_t v8 = v11;
    uint64_t v10 = a1 + *(int *)(a3 + 20);
    int v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v12 + 48);
    goto LABEL_5;
  }
  uint64_t v14 = sub_100725CC0();
  uint64_t v15 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v14 - 8) + 48);
  uint64_t v16 = v14;
  uint64_t v17 = a1 + *(int *)(a3 + 28);

  return v15(v17, a2, v16);
}

uint64_t sub_10044561C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _swift_storeEnumTagSinglePayloadGeneric(a1, a2, a3, a4, sub_100445630);
}

uint64_t sub_100445630(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8 = sub_100431F80(&qword_100A44A50);
  uint64_t v9 = *(void *)(v8 - 8);
  if (*(_DWORD *)(v9 + 84) == a3)
  {
    uint64_t v10 = v8;
    uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 56);
    uint64_t v12 = a1;
LABEL_5:
    return v11(v12, a2, a2, v10);
  }
  uint64_t v13 = type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
  uint64_t v14 = *(void *)(v13 - 8);
  if (*(_DWORD *)(v14 + 84) == a3)
  {
    uint64_t v10 = v13;
    uint64_t v12 = a1 + *(int *)(a4 + 20);
    uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v14 + 56);
    goto LABEL_5;
  }
  uint64_t v16 = sub_100725CC0();
  uint64_t v17 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v16 - 8) + 56);
  uint64_t v18 = v16;
  uint64_t v19 = a1 + *(int *)(a4 + 28);

  return v17(v19, a2, a2, v18);
}

void sub_10044578C()
{
  sub_1004437B8();
  if (v0 <= 0x3F)
  {
    type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
    if (v1 <= 0x3F)
    {
      sub_100725CC0();
      if (v2 <= 0x3F) {
        swift_initStructMetadata();
      }
    }
  }
}

uint64_t *sub_100445890(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  int v5 = *(_DWORD *)(*(void *)(a3 - 8) + 80);
  if ((v5 & 0x20000) != 0)
  {
    uint64_t v11 = *a2;
    *a1 = *a2;
    a1 = (uint64_t *)(v11 + ((v5 + 16) & ~(unint64_t)v5));
    swift_retain();
  }
  else
  {
    uint64_t v6 = *(void *)(a3 - 8);
    int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
    if (EnumCaseMultiPayload == 1)
    {
      uint64_t v12 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
      uint64_t v13 = *((void *)v12 - 1);
      if ((*(unsigned int (**)(uint64_t *, uint64_t, int *))(v13 + 48))(a2, 1, v12))
      {
        uint64_t v14 = sub_100431F80(&qword_100A44A50);
        memcpy(a1, a2, *(void *)(*(void *)(v14 - 8) + 64));
      }
      else
      {
        *(unsigned char *)a1 = *(unsigned char *)a2;
        uint64_t v73 = v12[5];
        uint64_t v74 = (char *)a1 + v73;
        uint64_t v75 = (char *)a2 + v73;
        uint64_t v76 = sub_100725D30();
        (*(void (**)(char *, char *, uint64_t))(*(void *)(v76 - 8) + 16))(v74, v75, v76);
        uint64_t v77 = v12[6];
        unint64_t v78 = (uint64_t *)((char *)a1 + v77);
        uint64_t v79 = (uint64_t *)((char *)a2 + v77);
        uint64_t v80 = *v79;
        unint64_t v81 = v79[1];
        sub_100441FD4(*v79, v81);
        uint64_t *v78 = v80;
        v78[1] = v81;
        uint64_t v82 = v12[7];
        uint64_t v83 = (uint64_t *)((char *)a1 + v82);
        uint64_t v84 = (uint64_t *)((char *)a2 + v82);
        uint64_t v85 = *v84;
        unint64_t v86 = v84[1];
        sub_100441FD4(*v84, v86);
        uint64_t *v83 = v85;
        v83[1] = v86;
        uint64_t v87 = v12[8];
        uint64_t v88 = (char *)a1 + v87;
        unint64_t v89 = (char *)a2 + v87;
        uint64_t v90 = sub_100725CC0();
        (*(void (**)(char *, char *, uint64_t))(*(void *)(v90 - 8) + 16))(v88, v89, v90);
        uint64_t v91 = v12[9];
        uint64_t v92 = (uint64_t *)((char *)a1 + v91);
        uint64_t v93 = (uint64_t *)((char *)a2 + v91);
        uint64_t v94 = v93[1];
        *uint64_t v92 = *v93;
        v92[1] = v94;
        *(_DWORD *)((char *)a1 + v12[10]) = *(_DWORD *)((char *)a2 + v12[10]);
        *(_DWORD *)((char *)a1 + v12[11]) = *(_DWORD *)((char *)a2 + v12[11]);
        *((unsigned char *)a1 + v12[12]) = *((unsigned char *)a2 + v12[12]);
        uint64_t v95 = v12[13];
        uint64_t v96 = (char *)a1 + v95;
        uint64_t v97 = (char *)a2 + v95;
        v96[8] = v97[8];
        *(void *)uint64_t v96 = *(void *)v97;
        uint64_t v98 = *(void (**)(uint64_t *, void, uint64_t, int *))(v13 + 56);
        swift_bridgeObjectRetain();
        v98(a1, 0, 1, v12);
      }
      uint64_t v157 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey(0);
      uint64_t v99 = v157[5];
      uint64_t v100 = (char *)a1 + v99;
      uint64_t v101 = (char *)a2 + v99;
      *uint64_t v100 = *((unsigned char *)a2 + v99);
      uint64_t v102 = v12[5];
      uint64_t v103 = &v100[v102];
      unint64_t v104 = &v101[v102];
      uint64_t v155 = sub_100725D30();
      uint64_t v154 = *(void (**)(unsigned char *, char *, uint64_t))(*(void *)(v155 - 8) + 16);
      v154(v103, v104, v155);
      uint64_t v105 = v12[6];
      unint64_t v106 = (uint64_t *)&v100[v105];
      uint64_t v107 = (uint64_t *)&v101[v105];
      uint64_t v108 = *v107;
      unint64_t v109 = v107[1];
      sub_100441FD4(*v107, v109);
      *unint64_t v106 = v108;
      v106[1] = v109;
      uint64_t v110 = v12[7];
      unint64_t v111 = (uint64_t *)&v100[v110];
      uint64_t v112 = (uint64_t *)&v101[v110];
      uint64_t v113 = *v112;
      unint64_t v114 = v112[1];
      sub_100441FD4(*v112, v114);
      *unint64_t v111 = v113;
      v111[1] = v114;
      uint64_t v115 = v12[8];
      uint64_t v116 = &v100[v115];
      uint64_t v117 = &v101[v115];
      uint64_t v118 = sub_100725CC0();
      uint64_t v153 = *(void (**)(char *, char *, uint64_t))(*(void *)(v118 - 8) + 16);
      v153(v116, v117, v118);
      uint64_t v119 = v12[9];
      uint64_t v120 = &v100[v119];
      uint64_t v121 = &v101[v119];
      uint64_t v122 = *((void *)v121 + 1);
      *uint64_t v120 = *(void *)v121;
      v120[1] = v122;
      *(_DWORD *)&v100[v12[10]] = *(_DWORD *)&v101[v12[10]];
      *(_DWORD *)&v100[v12[11]] = *(_DWORD *)&v101[v12[11]];
      v100[v12[12]] = v101[v12[12]];
      uint64_t v123 = v12[13];
      uint64_t v124 = &v100[v123];
      uint64_t v125 = &v101[v123];
      *(void *)uint64_t v124 = *(void *)v125;
      v124[8] = v125[8];
      uint64_t v126 = v157[6];
      int v127 = (char *)a1 + v126;
      uint64_t v128 = (char *)a2 + v126;
      unsigned char *v127 = *((unsigned char *)a2 + v126);
      uint64_t v129 = v12[5];
      id v130 = &v127[v129];
      char v131 = &v128[v129];
      swift_bridgeObjectRetain();
      v154(v130, v131, v155);
      uint64_t v132 = v12[6];
      int v133 = (uint64_t *)&v127[v132];
      os_log_t v134 = (uint64_t *)&v128[v132];
      uint64_t v135 = *v134;
      unint64_t v136 = v134[1];
      sub_100441FD4(*v134, v136);
      *int v133 = v135;
      v133[1] = v136;
      uint64_t v137 = v12[7];
      uint64_t v138 = (uint64_t *)&v127[v137];
      uint64_t v139 = (uint64_t *)&v128[v137];
      uint64_t v140 = *v139;
      unint64_t v141 = v139[1];
      sub_100441FD4(*v139, v141);
      uint64_t *v138 = v140;
      v138[1] = v141;
      v153(&v127[v12[8]], &v128[v12[8]], v118);
      uint64_t v142 = v12[9];
      uint64_t v143 = &v127[v142];
      uint64_t v144 = &v128[v142];
      uint64_t v145 = *((void *)v144 + 1);
      *uint64_t v143 = *(void *)v144;
      v143[1] = v145;
      *(_DWORD *)&v127[v12[10]] = *(_DWORD *)&v128[v12[10]];
      *(_DWORD *)&v127[v12[11]] = *(_DWORD *)&v128[v12[11]];
      v127[v12[12]] = v128[v12[12]];
      uint64_t v146 = v12[13];
      uint64_t v147 = &v127[v146];
      uint64_t v148 = &v128[v146];
      v147[8] = v148[8];
      *(void *)uint64_t v147 = *(void *)v148;
      uint64_t v149 = v157[7];
      uint64_t v150 = (char *)a1 + v149;
      uint64_t v151 = (char *)a2 + v149;
      swift_bridgeObjectRetain();
      v153(v150, v151, v118);
      goto LABEL_14;
    }
    if (!EnumCaseMultiPayload)
    {
      uint64_t v8 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
      uint64_t v9 = *((void *)v8 - 1);
      if ((*(unsigned int (**)(uint64_t *, uint64_t, int *))(v9 + 48))(a2, 1, v8))
      {
        uint64_t v10 = sub_100431F80(&qword_100A44A50);
        memcpy(a1, a2, *(void *)(*(void *)(v10 - 8) + 64));
      }
      else
      {
        *(unsigned char *)a1 = *(unsigned char *)a2;
        uint64_t v15 = v8[5];
        uint64_t v16 = (char *)a1 + v15;
        uint64_t v17 = (char *)a2 + v15;
        uint64_t v18 = sub_100725D30();
        (*(void (**)(char *, char *, uint64_t))(*(void *)(v18 - 8) + 16))(v16, v17, v18);
        uint64_t v19 = v8[6];
        uint64_t v20 = (uint64_t *)((char *)a1 + v19);
        uint64_t v21 = (uint64_t *)((char *)a2 + v19);
        uint64_t v22 = *v21;
        unint64_t v23 = v21[1];
        sub_100441FD4(*v21, v23);
        uint64_t *v20 = v22;
        v20[1] = v23;
        uint64_t v24 = v8[7];
        uint64_t v25 = (uint64_t *)((char *)a1 + v24);
        uint64_t v26 = (uint64_t *)((char *)a2 + v24);
        uint64_t v27 = *v26;
        unint64_t v28 = v26[1];
        sub_100441FD4(*v26, v28);
        uint64_t *v25 = v27;
        v25[1] = v28;
        uint64_t v29 = v8[8];
        uint64_t v30 = (char *)a1 + v29;
        uint64_t v31 = (char *)a2 + v29;
        uint64_t v32 = sub_100725CC0();
        (*(void (**)(char *, char *, uint64_t))(*(void *)(v32 - 8) + 16))(v30, v31, v32);
        uint64_t v33 = v8[9];
        uint64_t v34 = (uint64_t *)((char *)a1 + v33);
        unint64_t v35 = (uint64_t *)((char *)a2 + v33);
        uint64_t v36 = v35[1];
        *uint64_t v34 = *v35;
        v34[1] = v36;
        *(_DWORD *)((char *)a1 + v8[10]) = *(_DWORD *)((char *)a2 + v8[10]);
        *(_DWORD *)((char *)a1 + v8[11]) = *(_DWORD *)((char *)a2 + v8[11]);
        *((unsigned char *)a1 + v8[12]) = *((unsigned char *)a2 + v8[12]);
        uint64_t v37 = v8[13];
        uint64_t v38 = (char *)a1 + v37;
        uint64_t v39 = (char *)a2 + v37;
        v38[8] = v39[8];
        *(void *)uint64_t v38 = *(void *)v39;
        uint64_t v40 = *(void (**)(uint64_t *, void, uint64_t, int *))(v9 + 56);
        swift_bridgeObjectRetain();
        v40(a1, 0, 1, v8);
      }
      uint64_t v156 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(0);
      uint64_t v41 = *(int *)(v156 + 20);
      uint64_t v42 = (char *)a1 + v41;
      uint64_t v43 = (char *)a2 + v41;
      *uint64_t v42 = *((unsigned char *)a2 + v41);
      uint64_t v44 = v8[5];
      uint64_t v45 = &v42[v44];
      uint64_t v46 = &v43[v44];
      uint64_t v47 = sub_100725D30();
      (*(void (**)(unsigned char *, char *, uint64_t))(*(void *)(v47 - 8) + 16))(v45, v46, v47);
      uint64_t v48 = v8[6];
      uint64_t v49 = (uint64_t *)&v42[v48];
      uint64_t v50 = (uint64_t *)&v43[v48];
      uint64_t v51 = *v50;
      unint64_t v52 = v50[1];
      sub_100441FD4(*v50, v52);
      *uint64_t v49 = v51;
      v49[1] = v52;
      uint64_t v53 = v8[7];
      unint64_t v54 = (uint64_t *)&v42[v53];
      uint64_t v55 = (uint64_t *)&v43[v53];
      uint64_t v56 = *v55;
      unint64_t v57 = v55[1];
      sub_100441FD4(*v55, v57);
      uint64_t *v54 = v56;
      v54[1] = v57;
      uint64_t v58 = v8[8];
      uint64_t v59 = &v42[v58];
      uint64_t v60 = &v43[v58];
      uint64_t v61 = sub_100725CC0();
      uint64_t v62 = *(void (**)(char *, char *, uint64_t))(*(void *)(v61 - 8) + 16);
      v62(v59, v60, v61);
      uint64_t v63 = v8[9];
      uint64_t v64 = &v42[v63];
      uint64_t v65 = &v43[v63];
      uint64_t v66 = *((void *)v65 + 1);
      void *v64 = *(void *)v65;
      v64[1] = v66;
      *(_DWORD *)&v42[v8[10]] = *(_DWORD *)&v43[v8[10]];
      *(_DWORD *)&v42[v8[11]] = *(_DWORD *)&v43[v8[11]];
      v42[v8[12]] = v43[v8[12]];
      uint64_t v67 = v8[13];
      uint64_t v68 = &v42[v67];
      uint64_t v69 = &v43[v67];
      v68[8] = v69[8];
      *(void *)uint64_t v68 = *(void *)v69;
      uint64_t v70 = *(int *)(v156 + 24);
      uint64_t v71 = (char *)a1 + v70;
      uint64_t v72 = (char *)a2 + v70;
      swift_bridgeObjectRetain();
      v62(v71, v72, v61);
LABEL_14:
      swift_storeEnumTagMultiPayload();
      return a1;
    }
    memcpy(a1, a2, *(void *)(v6 + 64));
  }
  return a1;
}

uint64_t sub_100446158(uint64_t a1)
{
  uint64_t result = swift_getEnumCaseMultiPayload();
  if (result == 1)
  {
    uint64_t v16 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
    if (!(*(unsigned int (**)(uint64_t, uint64_t, int *))(*((void *)v16 - 1) + 48))(a1, 1, v16))
    {
      uint64_t v17 = a1 + v16[5];
      uint64_t v18 = sub_100725D30();
      (*(void (**)(uint64_t, uint64_t))(*(void *)(v18 - 8) + 8))(v17, v18);
      sub_100442248(*(void *)(a1 + v16[6]), *(void *)(a1 + v16[6] + 8));
      sub_100442248(*(void *)(a1 + v16[7]), *(void *)(a1 + v16[7] + 8));
      uint64_t v19 = a1 + v16[8];
      uint64_t v20 = sub_100725CC0();
      (*(void (**)(uint64_t, uint64_t))(*(void *)(v20 - 8) + 8))(v19, v20);
      swift_bridgeObjectRelease();
    }
    uint64_t v21 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey(0);
    uint64_t v22 = a1 + v21[5];
    uint64_t v23 = v22 + v16[5];
    uint64_t v24 = sub_100725D30();
    uint64_t v25 = *(void (**)(uint64_t, uint64_t))(*(void *)(v24 - 8) + 8);
    v25(v23, v24);
    sub_100442248(*(void *)(v22 + v16[6]), *(void *)(v22 + v16[6] + 8));
    sub_100442248(*(void *)(v22 + v16[7]), *(void *)(v22 + v16[7] + 8));
    uint64_t v26 = v22 + v16[8];
    uint64_t v27 = sub_100725CC0();
    uint64_t v29 = *(void (**)(uint64_t, uint64_t))(*(void *)(v27 - 8) + 8);
    ((void (*)(void *__return_ptr, uint64_t, uint64_t))v29)((void *)(v27 - 8), v26, v27);
    swift_bridgeObjectRelease();
    uint64_t v28 = a1 + v21[6];
    v25(v28 + v16[5], v24);
    sub_100442248(*(void *)(v28 + v16[6]), *(void *)(v28 + v16[6] + 8));
    sub_100442248(*(void *)(v28 + v16[7]), *(void *)(v28 + v16[7] + 8));
    v29(v28 + v16[8], v27);
    swift_bridgeObjectRelease();
    uint64_t v14 = a1 + v21[7];
    uint64_t v15 = v27;
  }
  else
  {
    if (result) {
      return result;
    }
    int v3 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
    if (!(*(unsigned int (**)(uint64_t, uint64_t, int *))(*((void *)v3 - 1) + 48))(a1, 1, v3))
    {
      uint64_t v4 = a1 + v3[5];
      uint64_t v5 = sub_100725D30();
      (*(void (**)(uint64_t, uint64_t))(*(void *)(v5 - 8) + 8))(v4, v5);
      sub_100442248(*(void *)(a1 + v3[6]), *(void *)(a1 + v3[6] + 8));
      sub_100442248(*(void *)(a1 + v3[7]), *(void *)(a1 + v3[7] + 8));
      uint64_t v6 = a1 + v3[8];
      uint64_t v7 = sub_100725CC0();
      (*(void (**)(uint64_t, uint64_t))(*(void *)(v7 - 8) + 8))(v6, v7);
      swift_bridgeObjectRelease();
    }
    uint64_t v8 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(0);
    uint64_t v9 = a1 + *(int *)(v8 + 20);
    uint64_t v10 = v9 + v3[5];
    uint64_t v11 = sub_100725D30();
    (*(void (**)(uint64_t, uint64_t))(*(void *)(v11 - 8) + 8))(v10, v11);
    sub_100442248(*(void *)(v9 + v3[6]), *(void *)(v9 + v3[6] + 8));
    sub_100442248(*(void *)(v9 + v3[7]), *(void *)(v9 + v3[7] + 8));
    uint64_t v12 = v9 + v3[8];
    uint64_t v13 = sub_100725CC0();
    uint64_t v29 = *(void (**)(uint64_t, uint64_t))(*(void *)(v13 - 8) + 8);
    ((void (*)(void *__return_ptr, uint64_t, uint64_t))v29)((void *)(v13 - 8), v12, v13);
    swift_bridgeObjectRelease();
    uint64_t v14 = a1 + *(int *)(v8 + 24);
    uint64_t v15 = v13;
  }

  return ((uint64_t (*)(uint64_t, uint64_t))v29)(v14, v15);
}

unsigned char *sub_100446600(unsigned char *a1, unsigned char *a2, uint64_t a3)
{
  int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
  if (EnumCaseMultiPayload == 1)
  {
    uint64_t v10 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
    uint64_t v11 = *((void *)v10 - 1);
    if ((*(unsigned int (**)(unsigned char *, uint64_t, int *))(v11 + 48))(a2, 1, v10))
    {
      uint64_t v12 = sub_100431F80(&qword_100A44A50);
      memcpy(a1, a2, *(void *)(*(void *)(v12 - 8) + 64));
    }
    else
    {
      *a1 = *a2;
      uint64_t v71 = v10[5];
      uint64_t v72 = &a1[v71];
      uint64_t v73 = &a2[v71];
      uint64_t v74 = sub_100725D30();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v74 - 8) + 16))(v72, v73, v74);
      uint64_t v75 = v10[6];
      uint64_t v76 = (uint64_t *)&a1[v75];
      uint64_t v77 = (uint64_t *)&a2[v75];
      uint64_t v78 = *v77;
      unint64_t v79 = v77[1];
      sub_100441FD4(*v77, v79);
      uint64_t *v76 = v78;
      v76[1] = v79;
      uint64_t v80 = v10[7];
      unint64_t v81 = (uint64_t *)&a1[v80];
      uint64_t v82 = (uint64_t *)&a2[v80];
      uint64_t v83 = *v82;
      unint64_t v84 = v82[1];
      sub_100441FD4(*v82, v84);
      uint64_t *v81 = v83;
      v81[1] = v84;
      uint64_t v85 = v10[8];
      unint64_t v86 = &a1[v85];
      uint64_t v87 = &a2[v85];
      uint64_t v88 = sub_100725CC0();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v88 - 8) + 16))(v86, v87, v88);
      uint64_t v89 = v10[9];
      uint64_t v90 = &a1[v89];
      uint64_t v91 = &a2[v89];
      uint64_t v92 = v91[1];
      void *v90 = *v91;
      v90[1] = v92;
      *(_DWORD *)&a1[v10[10]] = *(_DWORD *)&a2[v10[10]];
      *(_DWORD *)&a1[v10[11]] = *(_DWORD *)&a2[v10[11]];
      a1[v10[12]] = a2[v10[12]];
      uint64_t v93 = v10[13];
      uint64_t v94 = &a1[v93];
      uint64_t v95 = &a2[v93];
      v94[8] = v95[8];
      *(void *)uint64_t v94 = *(void *)v95;
      uint64_t v96 = *(void (**)(unsigned char *, void, uint64_t, int *))(v11 + 56);
      swift_bridgeObjectRetain();
      v96(a1, 0, 1, v10);
    }
    uint64_t v155 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey(0);
    uint64_t v97 = v155[5];
    uint64_t v98 = &a1[v97];
    uint64_t v99 = &a2[v97];
    *uint64_t v98 = a2[v97];
    uint64_t v100 = v10[5];
    uint64_t v101 = &v98[v100];
    uint64_t v102 = &v99[v100];
    uint64_t v153 = sub_100725D30();
    uint64_t v152 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v153 - 8) + 16);
    v152(v101, v102, v153);
    uint64_t v103 = v10[6];
    unint64_t v104 = (uint64_t *)&v98[v103];
    uint64_t v105 = (uint64_t *)&v99[v103];
    uint64_t v106 = *v105;
    unint64_t v107 = v105[1];
    sub_100441FD4(*v105, v107);
    *unint64_t v104 = v106;
    v104[1] = v107;
    uint64_t v108 = v10[7];
    unint64_t v109 = (uint64_t *)&v98[v108];
    uint64_t v110 = (uint64_t *)&v99[v108];
    uint64_t v111 = *v110;
    unint64_t v112 = v110[1];
    sub_100441FD4(*v110, v112);
    *unint64_t v109 = v111;
    v109[1] = v112;
    uint64_t v113 = v10[8];
    unint64_t v114 = &v98[v113];
    uint64_t v115 = &v99[v113];
    uint64_t v116 = sub_100725CC0();
    uint64_t v151 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v116 - 8) + 16);
    v151(v114, v115, v116);
    uint64_t v117 = v10[9];
    uint64_t v118 = &v98[v117];
    uint64_t v119 = &v99[v117];
    uint64_t v120 = v119[1];
    *uint64_t v118 = *v119;
    v118[1] = v120;
    *(_DWORD *)&v98[v10[10]] = *(_DWORD *)&v99[v10[10]];
    *(_DWORD *)&v98[v10[11]] = *(_DWORD *)&v99[v10[11]];
    v98[v10[12]] = v99[v10[12]];
    uint64_t v121 = v10[13];
    uint64_t v122 = &v98[v121];
    uint64_t v123 = &v99[v121];
    *(void *)uint64_t v122 = *(void *)v123;
    v122[8] = v123[8];
    uint64_t v124 = v155[6];
    uint64_t v125 = &a1[v124];
    uint64_t v126 = &a2[v124];
    *uint64_t v125 = a2[v124];
    uint64_t v127 = v10[5];
    uint64_t v128 = &v125[v127];
    uint64_t v129 = &v126[v127];
    swift_bridgeObjectRetain();
    v152(v128, v129, v153);
    uint64_t v130 = v10[6];
    char v131 = (uint64_t *)&v125[v130];
    uint64_t v132 = (uint64_t *)&v126[v130];
    uint64_t v133 = *v132;
    unint64_t v134 = v132[1];
    sub_100441FD4(*v132, v134);
    uint64_t *v131 = v133;
    v131[1] = v134;
    uint64_t v135 = v10[7];
    unint64_t v136 = (uint64_t *)&v125[v135];
    uint64_t v137 = (uint64_t *)&v126[v135];
    uint64_t v138 = *v137;
    unint64_t v139 = v137[1];
    sub_100441FD4(*v137, v139);
    *unint64_t v136 = v138;
    v136[1] = v139;
    v151(&v125[v10[8]], &v126[v10[8]], v116);
    uint64_t v140 = v10[9];
    unint64_t v141 = &v125[v140];
    uint64_t v142 = &v126[v140];
    uint64_t v143 = v142[1];
    *unint64_t v141 = *v142;
    v141[1] = v143;
    *(_DWORD *)&v125[v10[10]] = *(_DWORD *)&v126[v10[10]];
    *(_DWORD *)&v125[v10[11]] = *(_DWORD *)&v126[v10[11]];
    v125[v10[12]] = v126[v10[12]];
    uint64_t v144 = v10[13];
    uint64_t v145 = &v125[v144];
    uint64_t v146 = &v126[v144];
    v145[8] = v146[8];
    *(void *)uint64_t v145 = *(void *)v146;
    uint64_t v147 = v155[7];
    uint64_t v148 = &a1[v147];
    uint64_t v149 = &a2[v147];
    swift_bridgeObjectRetain();
    v151(v148, v149, v116);
    goto LABEL_12;
  }
  if (!EnumCaseMultiPayload)
  {
    uint64_t v7 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
    uint64_t v8 = *((void *)v7 - 1);
    if ((*(unsigned int (**)(unsigned char *, uint64_t, int *))(v8 + 48))(a2, 1, v7))
    {
      uint64_t v9 = sub_100431F80(&qword_100A44A50);
      memcpy(a1, a2, *(void *)(*(void *)(v9 - 8) + 64));
    }
    else
    {
      *a1 = *a2;
      uint64_t v13 = v7[5];
      uint64_t v14 = &a1[v13];
      uint64_t v15 = &a2[v13];
      uint64_t v16 = sub_100725D30();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v16 - 8) + 16))(v14, v15, v16);
      uint64_t v17 = v7[6];
      uint64_t v18 = (uint64_t *)&a1[v17];
      uint64_t v19 = (uint64_t *)&a2[v17];
      uint64_t v20 = *v19;
      unint64_t v21 = v19[1];
      sub_100441FD4(*v19, v21);
      *uint64_t v18 = v20;
      v18[1] = v21;
      uint64_t v22 = v7[7];
      uint64_t v23 = (uint64_t *)&a1[v22];
      uint64_t v24 = (uint64_t *)&a2[v22];
      uint64_t v25 = *v24;
      unint64_t v26 = v24[1];
      sub_100441FD4(*v24, v26);
      *uint64_t v23 = v25;
      v23[1] = v26;
      uint64_t v27 = v7[8];
      uint64_t v28 = &a1[v27];
      uint64_t v29 = &a2[v27];
      uint64_t v30 = sub_100725CC0();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v30 - 8) + 16))(v28, v29, v30);
      uint64_t v31 = v7[9];
      uint64_t v32 = &a1[v31];
      uint64_t v33 = &a2[v31];
      uint64_t v34 = v33[1];
      void *v32 = *v33;
      v32[1] = v34;
      *(_DWORD *)&a1[v7[10]] = *(_DWORD *)&a2[v7[10]];
      *(_DWORD *)&a1[v7[11]] = *(_DWORD *)&a2[v7[11]];
      a1[v7[12]] = a2[v7[12]];
      uint64_t v35 = v7[13];
      uint64_t v36 = &a1[v35];
      uint64_t v37 = &a2[v35];
      v36[8] = v37[8];
      *(void *)uint64_t v36 = *(void *)v37;
      uint64_t v38 = *(void (**)(unsigned char *, void, uint64_t, int *))(v8 + 56);
      swift_bridgeObjectRetain();
      v38(a1, 0, 1, v7);
    }
    uint64_t v154 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(0);
    uint64_t v39 = *(int *)(v154 + 20);
    uint64_t v40 = &a1[v39];
    uint64_t v41 = &a2[v39];
    *uint64_t v40 = a2[v39];
    uint64_t v42 = v7[5];
    uint64_t v43 = &v40[v42];
    uint64_t v44 = &v41[v42];
    uint64_t v45 = sub_100725D30();
    (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v45 - 8) + 16))(v43, v44, v45);
    uint64_t v46 = v7[6];
    uint64_t v47 = (uint64_t *)&v40[v46];
    uint64_t v48 = (uint64_t *)&v41[v46];
    uint64_t v49 = *v48;
    unint64_t v50 = v48[1];
    sub_100441FD4(*v48, v50);
    *uint64_t v47 = v49;
    v47[1] = v50;
    uint64_t v51 = v7[7];
    unint64_t v52 = (uint64_t *)&v40[v51];
    uint64_t v53 = (uint64_t *)&v41[v51];
    uint64_t v54 = *v53;
    unint64_t v55 = v53[1];
    sub_100441FD4(*v53, v55);
    uint64_t *v52 = v54;
    v52[1] = v55;
    uint64_t v56 = v7[8];
    unint64_t v57 = &v40[v56];
    uint64_t v58 = &v41[v56];
    uint64_t v59 = sub_100725CC0();
    uint64_t v60 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v59 - 8) + 16);
    v60(v57, v58, v59);
    uint64_t v61 = v7[9];
    uint64_t v62 = &v40[v61];
    uint64_t v63 = &v41[v61];
    uint64_t v64 = v63[1];
    void *v62 = *v63;
    v62[1] = v64;
    *(_DWORD *)&v40[v7[10]] = *(_DWORD *)&v41[v7[10]];
    *(_DWORD *)&v40[v7[11]] = *(_DWORD *)&v41[v7[11]];
    v40[v7[12]] = v41[v7[12]];
    uint64_t v65 = v7[13];
    uint64_t v66 = &v40[v65];
    uint64_t v67 = &v41[v65];
    v66[8] = v67[8];
    *(void *)uint64_t v66 = *(void *)v67;
    uint64_t v68 = *(int *)(v154 + 24);
    uint64_t v69 = &a1[v68];
    uint64_t v70 = &a2[v68];
    swift_bridgeObjectRetain();
    v60(v69, v70, v59);
LABEL_12:
    swift_storeEnumTagMultiPayload();
    return a1;
  }
  memcpy(a1, a2, *(void *)(*(void *)(a3 - 8) + 64));
  return a1;
}

unsigned char *sub_100446E84(unsigned char *a1, unsigned char *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    sub_1004324A4((uint64_t)a1, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
    int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
    if (EnumCaseMultiPayload == 1)
    {
      uint64_t v10 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
      uint64_t v11 = *((void *)v10 - 1);
      if ((*(unsigned int (**)(unsigned char *, uint64_t, int *))(v11 + 48))(a2, 1, v10))
      {
        uint64_t v12 = sub_100431F80(&qword_100A44A50);
        memcpy(a1, a2, *(void *)(*(void *)(v12 - 8) + 64));
      }
      else
      {
        *a1 = *a2;
        uint64_t v71 = v10[5];
        uint64_t v72 = &a1[v71];
        uint64_t v73 = &a2[v71];
        uint64_t v74 = sub_100725D30();
        (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v74 - 8) + 16))(v72, v73, v74);
        uint64_t v75 = v10[6];
        uint64_t v76 = (uint64_t *)&a1[v75];
        uint64_t v77 = (uint64_t *)&a2[v75];
        uint64_t v78 = *v77;
        unint64_t v79 = v77[1];
        sub_100441FD4(*v77, v79);
        uint64_t *v76 = v78;
        v76[1] = v79;
        uint64_t v80 = v10[7];
        unint64_t v81 = (uint64_t *)&a1[v80];
        uint64_t v82 = (uint64_t *)&a2[v80];
        uint64_t v83 = *v82;
        unint64_t v84 = v82[1];
        sub_100441FD4(*v82, v84);
        uint64_t *v81 = v83;
        v81[1] = v84;
        uint64_t v85 = v10[8];
        unint64_t v86 = &a1[v85];
        uint64_t v87 = &a2[v85];
        uint64_t v88 = sub_100725CC0();
        (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v88 - 8) + 16))(v86, v87, v88);
        uint64_t v89 = v10[9];
        uint64_t v90 = &a1[v89];
        uint64_t v91 = &a2[v89];
        void *v90 = *v91;
        v90[1] = v91[1];
        *(_DWORD *)&a1[v10[10]] = *(_DWORD *)&a2[v10[10]];
        *(_DWORD *)&a1[v10[11]] = *(_DWORD *)&a2[v10[11]];
        a1[v10[12]] = a2[v10[12]];
        uint64_t v92 = v10[13];
        uint64_t v93 = &a1[v92];
        uint64_t v94 = &a2[v92];
        char v95 = v94[8];
        *(void *)uint64_t v93 = *(void *)v94;
        v93[8] = v95;
        uint64_t v96 = *(void (**)(unsigned char *, void, uint64_t, int *))(v11 + 56);
        swift_bridgeObjectRetain();
        v96(a1, 0, 1, v10);
      }
      uint64_t v155 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey(0);
      uint64_t v97 = v155[5];
      uint64_t v98 = &a1[v97];
      uint64_t v99 = &a2[v97];
      *uint64_t v98 = a2[v97];
      uint64_t v100 = v10[5];
      uint64_t v101 = &v98[v100];
      uint64_t v102 = &v99[v100];
      uint64_t v153 = sub_100725D30();
      uint64_t v152 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v153 - 8) + 16);
      v152(v101, v102, v153);
      uint64_t v103 = v10[6];
      unint64_t v104 = (uint64_t *)&v98[v103];
      uint64_t v105 = (uint64_t *)&v99[v103];
      uint64_t v106 = *v105;
      unint64_t v107 = v105[1];
      sub_100441FD4(*v105, v107);
      *unint64_t v104 = v106;
      v104[1] = v107;
      uint64_t v108 = v10[7];
      unint64_t v109 = (uint64_t *)&v98[v108];
      uint64_t v110 = (uint64_t *)&v99[v108];
      uint64_t v111 = *v110;
      unint64_t v112 = v110[1];
      sub_100441FD4(*v110, v112);
      *unint64_t v109 = v111;
      v109[1] = v112;
      uint64_t v113 = v10[8];
      unint64_t v114 = &v98[v113];
      uint64_t v115 = &v99[v113];
      uint64_t v116 = sub_100725CC0();
      uint64_t v151 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v116 - 8) + 16);
      v151(v114, v115, v116);
      uint64_t v117 = v10[9];
      uint64_t v118 = &v98[v117];
      uint64_t v119 = &v99[v117];
      *uint64_t v118 = *v119;
      v118[1] = v119[1];
      *(_DWORD *)&v98[v10[10]] = *(_DWORD *)&v99[v10[10]];
      *(_DWORD *)&v98[v10[11]] = *(_DWORD *)&v99[v10[11]];
      v98[v10[12]] = v99[v10[12]];
      uint64_t v120 = v10[13];
      uint64_t v121 = &v98[v120];
      uint64_t v122 = &v99[v120];
      char v123 = v122[8];
      *(void *)uint64_t v121 = *(void *)v122;
      v121[8] = v123;
      uint64_t v124 = v155[6];
      uint64_t v125 = &a1[v124];
      uint64_t v126 = &a2[v124];
      *uint64_t v125 = a2[v124];
      uint64_t v127 = v10[5];
      uint64_t v128 = &v125[v127];
      uint64_t v129 = &v126[v127];
      swift_bridgeObjectRetain();
      v152(v128, v129, v153);
      uint64_t v130 = v10[6];
      char v131 = (uint64_t *)&v125[v130];
      uint64_t v132 = (uint64_t *)&v126[v130];
      uint64_t v133 = *v132;
      unint64_t v134 = v132[1];
      sub_100441FD4(*v132, v134);
      uint64_t *v131 = v133;
      v131[1] = v134;
      uint64_t v135 = v10[7];
      unint64_t v136 = (uint64_t *)&v125[v135];
      uint64_t v137 = (uint64_t *)&v126[v135];
      uint64_t v138 = *v137;
      unint64_t v139 = v137[1];
      sub_100441FD4(*v137, v139);
      *unint64_t v136 = v138;
      v136[1] = v139;
      v151(&v125[v10[8]], &v126[v10[8]], v116);
      uint64_t v140 = v10[9];
      unint64_t v141 = &v125[v140];
      uint64_t v142 = &v126[v140];
      *unint64_t v141 = *v142;
      v141[1] = v142[1];
      *(_DWORD *)&v125[v10[10]] = *(_DWORD *)&v126[v10[10]];
      *(_DWORD *)&v125[v10[11]] = *(_DWORD *)&v126[v10[11]];
      v125[v10[12]] = v126[v10[12]];
      uint64_t v143 = v10[13];
      uint64_t v144 = &v125[v143];
      uint64_t v145 = &v126[v143];
      char v146 = v145[8];
      *(void *)uint64_t v144 = *(void *)v145;
      v144[8] = v146;
      uint64_t v147 = v155[7];
      uint64_t v148 = &a1[v147];
      uint64_t v149 = &a2[v147];
      swift_bridgeObjectRetain();
      v151(v148, v149, v116);
      goto LABEL_13;
    }
    if (!EnumCaseMultiPayload)
    {
      uint64_t v7 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
      uint64_t v8 = *((void *)v7 - 1);
      if ((*(unsigned int (**)(unsigned char *, uint64_t, int *))(v8 + 48))(a2, 1, v7))
      {
        uint64_t v9 = sub_100431F80(&qword_100A44A50);
        memcpy(a1, a2, *(void *)(*(void *)(v9 - 8) + 64));
      }
      else
      {
        *a1 = *a2;
        uint64_t v13 = v7[5];
        uint64_t v14 = &a1[v13];
        uint64_t v15 = &a2[v13];
        uint64_t v16 = sub_100725D30();
        (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v16 - 8) + 16))(v14, v15, v16);
        uint64_t v17 = v7[6];
        uint64_t v18 = (uint64_t *)&a1[v17];
        uint64_t v19 = (uint64_t *)&a2[v17];
        uint64_t v20 = *v19;
        unint64_t v21 = v19[1];
        sub_100441FD4(*v19, v21);
        *uint64_t v18 = v20;
        v18[1] = v21;
        uint64_t v22 = v7[7];
        uint64_t v23 = (uint64_t *)&a1[v22];
        uint64_t v24 = (uint64_t *)&a2[v22];
        uint64_t v25 = *v24;
        unint64_t v26 = v24[1];
        sub_100441FD4(*v24, v26);
        *uint64_t v23 = v25;
        v23[1] = v26;
        uint64_t v27 = v7[8];
        uint64_t v28 = &a1[v27];
        uint64_t v29 = &a2[v27];
        uint64_t v30 = sub_100725CC0();
        (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v30 - 8) + 16))(v28, v29, v30);
        uint64_t v31 = v7[9];
        uint64_t v32 = &a1[v31];
        uint64_t v33 = &a2[v31];
        void *v32 = *v33;
        v32[1] = v33[1];
        *(_DWORD *)&a1[v7[10]] = *(_DWORD *)&a2[v7[10]];
        *(_DWORD *)&a1[v7[11]] = *(_DWORD *)&a2[v7[11]];
        a1[v7[12]] = a2[v7[12]];
        uint64_t v34 = v7[13];
        uint64_t v35 = &a1[v34];
        uint64_t v36 = &a2[v34];
        char v37 = v36[8];
        *(void *)uint64_t v35 = *(void *)v36;
        v35[8] = v37;
        uint64_t v38 = *(void (**)(unsigned char *, void, uint64_t, int *))(v8 + 56);
        swift_bridgeObjectRetain();
        v38(a1, 0, 1, v7);
      }
      uint64_t v154 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(0);
      uint64_t v39 = *(int *)(v154 + 20);
      uint64_t v40 = &a1[v39];
      uint64_t v41 = &a2[v39];
      *uint64_t v40 = a2[v39];
      uint64_t v42 = v7[5];
      uint64_t v43 = &v40[v42];
      uint64_t v44 = &v41[v42];
      uint64_t v45 = sub_100725D30();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v45 - 8) + 16))(v43, v44, v45);
      uint64_t v46 = v7[6];
      uint64_t v47 = (uint64_t *)&v40[v46];
      uint64_t v48 = (uint64_t *)&v41[v46];
      uint64_t v49 = *v48;
      unint64_t v50 = v48[1];
      sub_100441FD4(*v48, v50);
      *uint64_t v47 = v49;
      v47[1] = v50;
      uint64_t v51 = v7[7];
      unint64_t v52 = (uint64_t *)&v40[v51];
      uint64_t v53 = (uint64_t *)&v41[v51];
      uint64_t v54 = *v53;
      unint64_t v55 = v53[1];
      sub_100441FD4(*v53, v55);
      uint64_t *v52 = v54;
      v52[1] = v55;
      uint64_t v56 = v7[8];
      unint64_t v57 = &v40[v56];
      uint64_t v58 = &v41[v56];
      uint64_t v59 = sub_100725CC0();
      uint64_t v60 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v59 - 8) + 16);
      v60(v57, v58, v59);
      uint64_t v61 = v7[9];
      uint64_t v62 = &v40[v61];
      uint64_t v63 = &v41[v61];
      void *v62 = *v63;
      v62[1] = v63[1];
      *(_DWORD *)&v40[v7[10]] = *(_DWORD *)&v41[v7[10]];
      *(_DWORD *)&v40[v7[11]] = *(_DWORD *)&v41[v7[11]];
      v40[v7[12]] = v41[v7[12]];
      uint64_t v64 = v7[13];
      uint64_t v65 = &v40[v64];
      uint64_t v66 = &v41[v64];
      char v67 = v66[8];
      *(void *)uint64_t v65 = *(void *)v66;
      void v65[8] = v67;
      uint64_t v68 = *(int *)(v154 + 24);
      uint64_t v69 = &a1[v68];
      uint64_t v70 = &a2[v68];
      swift_bridgeObjectRetain();
      v60(v69, v70, v59);
LABEL_13:
      swift_storeEnumTagMultiPayload();
      return a1;
    }
    memcpy(a1, a2, *(void *)(*(void *)(a3 - 8) + 64));
  }
  return a1;
}

unsigned char *sub_100447754(unsigned char *a1, unsigned char *a2, uint64_t a3)
{
  int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
  if (EnumCaseMultiPayload == 1)
  {
    uint64_t v10 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
    uint64_t v11 = *((void *)v10 - 1);
    if ((*(unsigned int (**)(unsigned char *, uint64_t, int *))(v11 + 48))(a2, 1, v10))
    {
      uint64_t v12 = sub_100431F80(&qword_100A44A50);
      memcpy(a1, a2, *(void *)(*(void *)(v12 - 8) + 64));
    }
    else
    {
      *a1 = *a2;
      uint64_t v39 = v10[5];
      uint64_t v40 = &a1[v39];
      uint64_t v41 = &a2[v39];
      uint64_t v42 = sub_100725D30();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v42 - 8) + 32))(v40, v41, v42);
      *(_OWORD *)&a1[v10[6]] = *(_OWORD *)&a2[v10[6]];
      *(_OWORD *)&a1[v10[7]] = *(_OWORD *)&a2[v10[7]];
      uint64_t v43 = v10[8];
      uint64_t v44 = &a1[v43];
      uint64_t v45 = &a2[v43];
      uint64_t v46 = sub_100725CC0();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v46 - 8) + 32))(v44, v45, v46);
      *(_OWORD *)&a1[v10[9]] = *(_OWORD *)&a2[v10[9]];
      *(_DWORD *)&a1[v10[10]] = *(_DWORD *)&a2[v10[10]];
      *(_DWORD *)&a1[v10[11]] = *(_DWORD *)&a2[v10[11]];
      a1[v10[12]] = a2[v10[12]];
      uint64_t v47 = v10[13];
      uint64_t v48 = &a1[v47];
      uint64_t v49 = &a2[v47];
      *(void *)uint64_t v48 = *(void *)v49;
      v48[8] = v49[8];
      (*(void (**)(unsigned char *, void, uint64_t, int *))(v11 + 56))(a1, 0, 1, v10);
    }
    uint64_t v74 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey(0);
    uint64_t v50 = v74[5];
    uint64_t v51 = &a1[v50];
    unint64_t v52 = &a2[v50];
    *uint64_t v51 = a2[v50];
    uint64_t v53 = v10[5];
    uint64_t v54 = &v51[v53];
    unint64_t v55 = &v52[v53];
    uint64_t v71 = sub_100725D30();
    uint64_t v72 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v71 - 8) + 32);
    v72(v54, v55, v71);
    *(_OWORD *)&v51[v10[6]] = *(_OWORD *)&v52[v10[6]];
    *(_OWORD *)&v51[v10[7]] = *(_OWORD *)&v52[v10[7]];
    uint64_t v56 = v10[8];
    unint64_t v57 = &v51[v56];
    uint64_t v58 = &v52[v56];
    uint64_t v59 = sub_100725CC0();
    uint64_t v60 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v59 - 8) + 32);
    v60(v57, v58, v59);
    *(_OWORD *)&v51[v10[9]] = *(_OWORD *)&v52[v10[9]];
    *(_DWORD *)&v51[v10[10]] = *(_DWORD *)&v52[v10[10]];
    *(_DWORD *)&v51[v10[11]] = *(_DWORD *)&v52[v10[11]];
    v51[v10[12]] = v52[v10[12]];
    uint64_t v61 = v10[13];
    uint64_t v62 = &v51[v61];
    uint64_t v63 = &v52[v61];
    *(void *)uint64_t v62 = *(void *)v63;
    v62[8] = v63[8];
    uint64_t v64 = v74[6];
    uint64_t v65 = &a1[v64];
    uint64_t v66 = &a2[v64];
    a1[v64] = a2[v64];
    v72(&a1[v64 + v10[5]], &a2[v64 + v10[5]], v71);
    *(_OWORD *)&v65[v10[6]] = *(_OWORD *)&v66[v10[6]];
    *(_OWORD *)&v65[v10[7]] = *(_OWORD *)&v66[v10[7]];
    v60(&v65[v10[8]], &v66[v10[8]], v59);
    *(_OWORD *)&v65[v10[9]] = *(_OWORD *)&v66[v10[9]];
    *(_DWORD *)&v65[v10[10]] = *(_DWORD *)&v66[v10[10]];
    *(_DWORD *)&v65[v10[11]] = *(_DWORD *)&v66[v10[11]];
    v65[v10[12]] = v66[v10[12]];
    uint64_t v67 = v10[13];
    uint64_t v68 = &v65[v67];
    uint64_t v69 = &v66[v67];
    v68[8] = v69[8];
    *(void *)uint64_t v68 = *(void *)v69;
    v60(&a1[v74[7]], &a2[v74[7]], v59);
    goto LABEL_12;
  }
  if (!EnumCaseMultiPayload)
  {
    uint64_t v7 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
    uint64_t v8 = *((void *)v7 - 1);
    if ((*(unsigned int (**)(unsigned char *, uint64_t, int *))(v8 + 48))(a2, 1, v7))
    {
      uint64_t v9 = sub_100431F80(&qword_100A44A50);
      memcpy(a1, a2, *(void *)(*(void *)(v9 - 8) + 64));
    }
    else
    {
      *a1 = *a2;
      uint64_t v13 = v7[5];
      uint64_t v14 = &a1[v13];
      uint64_t v15 = &a2[v13];
      uint64_t v16 = sub_100725D30();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v16 - 8) + 32))(v14, v15, v16);
      *(_OWORD *)&a1[v7[6]] = *(_OWORD *)&a2[v7[6]];
      *(_OWORD *)&a1[v7[7]] = *(_OWORD *)&a2[v7[7]];
      uint64_t v17 = v7[8];
      uint64_t v18 = &a1[v17];
      uint64_t v19 = &a2[v17];
      uint64_t v20 = sub_100725CC0();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v20 - 8) + 32))(v18, v19, v20);
      *(_OWORD *)&a1[v7[9]] = *(_OWORD *)&a2[v7[9]];
      *(_DWORD *)&a1[v7[10]] = *(_DWORD *)&a2[v7[10]];
      *(_DWORD *)&a1[v7[11]] = *(_DWORD *)&a2[v7[11]];
      a1[v7[12]] = a2[v7[12]];
      uint64_t v21 = v7[13];
      uint64_t v22 = &a1[v21];
      uint64_t v23 = &a2[v21];
      *(void *)uint64_t v22 = *(void *)v23;
      v22[8] = v23[8];
      (*(void (**)(unsigned char *, void, uint64_t, int *))(v8 + 56))(a1, 0, 1, v7);
    }
    uint64_t v73 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(0);
    uint64_t v24 = *(int *)(v73 + 20);
    uint64_t v25 = &a1[v24];
    unint64_t v26 = &a2[v24];
    unsigned char *v25 = a2[v24];
    uint64_t v27 = v7[5];
    uint64_t v28 = &v25[v27];
    uint64_t v29 = &v26[v27];
    uint64_t v30 = sub_100725D30();
    (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v30 - 8) + 32))(v28, v29, v30);
    *(_OWORD *)&v25[v7[6]] = *(_OWORD *)&v26[v7[6]];
    *(_OWORD *)&v25[v7[7]] = *(_OWORD *)&v26[v7[7]];
    uint64_t v31 = v7[8];
    uint64_t v32 = &v25[v31];
    uint64_t v33 = &v26[v31];
    uint64_t v34 = sub_100725CC0();
    uint64_t v35 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v34 - 8) + 32);
    v35(v32, v33, v34);
    *(_OWORD *)&v25[v7[9]] = *(_OWORD *)&v26[v7[9]];
    *(_DWORD *)&v25[v7[10]] = *(_DWORD *)&v26[v7[10]];
    *(_DWORD *)&v25[v7[11]] = *(_DWORD *)&v26[v7[11]];
    v25[v7[12]] = v26[v7[12]];
    uint64_t v36 = v7[13];
    char v37 = &v25[v36];
    uint64_t v38 = &v26[v36];
    v37[8] = v38[8];
    *(void *)char v37 = *(void *)v38;
    v35(&a1[*(int *)(v73 + 24)], &a2[*(int *)(v73 + 24)], v34);
LABEL_12:
    swift_storeEnumTagMultiPayload();
    return a1;
  }
  memcpy(a1, a2, *(void *)(*(void *)(a3 - 8) + 64));
  return a1;
}

unsigned char *sub_100447EB0(unsigned char *a1, unsigned char *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    sub_1004324A4((uint64_t)a1, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
    int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
    if (EnumCaseMultiPayload == 1)
    {
      uint64_t v10 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
      uint64_t v11 = *((void *)v10 - 1);
      if ((*(unsigned int (**)(unsigned char *, uint64_t, int *))(v11 + 48))(a2, 1, v10))
      {
        uint64_t v12 = sub_100431F80(&qword_100A44A50);
        memcpy(a1, a2, *(void *)(*(void *)(v12 - 8) + 64));
      }
      else
      {
        *a1 = *a2;
        uint64_t v39 = v10[5];
        uint64_t v40 = &a1[v39];
        uint64_t v41 = &a2[v39];
        uint64_t v42 = sub_100725D30();
        (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v42 - 8) + 32))(v40, v41, v42);
        *(_OWORD *)&a1[v10[6]] = *(_OWORD *)&a2[v10[6]];
        *(_OWORD *)&a1[v10[7]] = *(_OWORD *)&a2[v10[7]];
        uint64_t v43 = v10[8];
        uint64_t v44 = &a1[v43];
        uint64_t v45 = &a2[v43];
        uint64_t v46 = sub_100725CC0();
        (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v46 - 8) + 32))(v44, v45, v46);
        *(_OWORD *)&a1[v10[9]] = *(_OWORD *)&a2[v10[9]];
        *(_DWORD *)&a1[v10[10]] = *(_DWORD *)&a2[v10[10]];
        *(_DWORD *)&a1[v10[11]] = *(_DWORD *)&a2[v10[11]];
        a1[v10[12]] = a2[v10[12]];
        uint64_t v47 = v10[13];
        uint64_t v48 = &a1[v47];
        uint64_t v49 = &a2[v47];
        *(void *)uint64_t v48 = *(void *)v49;
        v48[8] = v49[8];
        (*(void (**)(unsigned char *, void, uint64_t, int *))(v11 + 56))(a1, 0, 1, v10);
      }
      uint64_t v74 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey(0);
      uint64_t v50 = v74[5];
      uint64_t v51 = &a1[v50];
      unint64_t v52 = &a2[v50];
      *uint64_t v51 = a2[v50];
      uint64_t v53 = v10[5];
      uint64_t v54 = &v51[v53];
      unint64_t v55 = &v52[v53];
      uint64_t v71 = sub_100725D30();
      uint64_t v72 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v71 - 8) + 32);
      v72(v54, v55, v71);
      *(_OWORD *)&v51[v10[6]] = *(_OWORD *)&v52[v10[6]];
      *(_OWORD *)&v51[v10[7]] = *(_OWORD *)&v52[v10[7]];
      uint64_t v56 = v10[8];
      unint64_t v57 = &v51[v56];
      uint64_t v58 = &v52[v56];
      uint64_t v59 = sub_100725CC0();
      uint64_t v60 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v59 - 8) + 32);
      v60(v57, v58, v59);
      *(_OWORD *)&v51[v10[9]] = *(_OWORD *)&v52[v10[9]];
      *(_DWORD *)&v51[v10[10]] = *(_DWORD *)&v52[v10[10]];
      *(_DWORD *)&v51[v10[11]] = *(_DWORD *)&v52[v10[11]];
      v51[v10[12]] = v52[v10[12]];
      uint64_t v61 = v10[13];
      uint64_t v62 = &v51[v61];
      uint64_t v63 = &v52[v61];
      *(void *)uint64_t v62 = *(void *)v63;
      v62[8] = v63[8];
      uint64_t v64 = v74[6];
      uint64_t v65 = &a1[v64];
      uint64_t v66 = &a2[v64];
      a1[v64] = a2[v64];
      v72(&a1[v64 + v10[5]], &a2[v64 + v10[5]], v71);
      *(_OWORD *)&v65[v10[6]] = *(_OWORD *)&v66[v10[6]];
      *(_OWORD *)&v65[v10[7]] = *(_OWORD *)&v66[v10[7]];
      v60(&v65[v10[8]], &v66[v10[8]], v59);
      *(_OWORD *)&v65[v10[9]] = *(_OWORD *)&v66[v10[9]];
      *(_DWORD *)&v65[v10[10]] = *(_DWORD *)&v66[v10[10]];
      *(_DWORD *)&v65[v10[11]] = *(_DWORD *)&v66[v10[11]];
      v65[v10[12]] = v66[v10[12]];
      uint64_t v67 = v10[13];
      uint64_t v68 = &v65[v67];
      uint64_t v69 = &v66[v67];
      v68[8] = v69[8];
      *(void *)uint64_t v68 = *(void *)v69;
      v60(&a1[v74[7]], &a2[v74[7]], v59);
      goto LABEL_13;
    }
    if (!EnumCaseMultiPayload)
    {
      uint64_t v7 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
      uint64_t v8 = *((void *)v7 - 1);
      if ((*(unsigned int (**)(unsigned char *, uint64_t, int *))(v8 + 48))(a2, 1, v7))
      {
        uint64_t v9 = sub_100431F80(&qword_100A44A50);
        memcpy(a1, a2, *(void *)(*(void *)(v9 - 8) + 64));
      }
      else
      {
        *a1 = *a2;
        uint64_t v13 = v7[5];
        uint64_t v14 = &a1[v13];
        uint64_t v15 = &a2[v13];
        uint64_t v16 = sub_100725D30();
        (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v16 - 8) + 32))(v14, v15, v16);
        *(_OWORD *)&a1[v7[6]] = *(_OWORD *)&a2[v7[6]];
        *(_OWORD *)&a1[v7[7]] = *(_OWORD *)&a2[v7[7]];
        uint64_t v17 = v7[8];
        uint64_t v18 = &a1[v17];
        uint64_t v19 = &a2[v17];
        uint64_t v20 = sub_100725CC0();
        (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v20 - 8) + 32))(v18, v19, v20);
        *(_OWORD *)&a1[v7[9]] = *(_OWORD *)&a2[v7[9]];
        *(_DWORD *)&a1[v7[10]] = *(_DWORD *)&a2[v7[10]];
        *(_DWORD *)&a1[v7[11]] = *(_DWORD *)&a2[v7[11]];
        a1[v7[12]] = a2[v7[12]];
        uint64_t v21 = v7[13];
        uint64_t v22 = &a1[v21];
        uint64_t v23 = &a2[v21];
        *(void *)uint64_t v22 = *(void *)v23;
        v22[8] = v23[8];
        (*(void (**)(unsigned char *, void, uint64_t, int *))(v8 + 56))(a1, 0, 1, v7);
      }
      uint64_t v73 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(0);
      uint64_t v24 = *(int *)(v73 + 20);
      uint64_t v25 = &a1[v24];
      unint64_t v26 = &a2[v24];
      unsigned char *v25 = a2[v24];
      uint64_t v27 = v7[5];
      uint64_t v28 = &v25[v27];
      uint64_t v29 = &v26[v27];
      uint64_t v30 = sub_100725D30();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v30 - 8) + 32))(v28, v29, v30);
      *(_OWORD *)&v25[v7[6]] = *(_OWORD *)&v26[v7[6]];
      *(_OWORD *)&v25[v7[7]] = *(_OWORD *)&v26[v7[7]];
      uint64_t v31 = v7[8];
      uint64_t v32 = &v25[v31];
      uint64_t v33 = &v26[v31];
      uint64_t v34 = sub_100725CC0();
      uint64_t v35 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v34 - 8) + 32);
      v35(v32, v33, v34);
      *(_OWORD *)&v25[v7[9]] = *(_OWORD *)&v26[v7[9]];
      *(_DWORD *)&v25[v7[10]] = *(_DWORD *)&v26[v7[10]];
      *(_DWORD *)&v25[v7[11]] = *(_DWORD *)&v26[v7[11]];
      v25[v7[12]] = v26[v7[12]];
      uint64_t v36 = v7[13];
      char v37 = &v25[v36];
      uint64_t v38 = &v26[v36];
      v37[8] = v38[8];
      *(void *)char v37 = *(void *)v38;
      v35(&a1[*(int *)(v73 + 24)], &a2[*(int *)(v73 + 24)], v34);
LABEL_13:
      swift_storeEnumTagMultiPayload();
      return a1;
    }
    memcpy(a1, a2, *(void *)(*(void *)(a3 - 8) + 64));
  }
  return a1;
}

uint64_t sub_100448630(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(*(void *)(a3 - 8) + 48))();
}

uint64_t sub_100448658(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(*(void *)(a4 - 8) + 56))();
}

uint64_t sub_100448684()
{
  return swift_storeEnumTagMultiPayload();
}

uint64_t sub_100448694()
{
  uint64_t result = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(319);
  if (v1 <= 0x3F)
  {
    uint64_t result = type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey(319);
    if (v2 <= 0x3F)
    {
      swift_initEnumMetadataMultiPayload();
      return 0;
    }
  }
  return result;
}

unsigned char *sub_100448758(unsigned char *a1, unsigned char *a2, int *a3)
{
  int v5 = *(_DWORD *)(*((void *)a3 - 1) + 80);
  if ((v5 & 0x20000) == 0)
  {
    uint64_t v7 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState(0);
    int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
    if (EnumCaseMultiPayload == 1)
    {
      uint64_t v14 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
      uint64_t v15 = *((void *)v14 - 1);
      if ((*(unsigned int (**)(unsigned char *, uint64_t, int *))(v15 + 48))(a2, 1, v14))
      {
        uint64_t v16 = sub_100431F80(&qword_100A44A50);
        memcpy(a1, a2, *(void *)(*(void *)(v16 - 8) + 64));
      }
      else
      {
        *a1 = *a2;
        uint64_t v75 = v14[5];
        uint64_t v76 = &a1[v75];
        uint64_t v77 = &a2[v75];
        uint64_t v78 = sub_100725D30();
        (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v78 - 8) + 16))(v76, v77, v78);
        uint64_t v79 = v14[6];
        uint64_t v80 = (uint64_t *)&a1[v79];
        unint64_t v81 = (uint64_t *)&a2[v79];
        uint64_t v82 = *v81;
        unint64_t v83 = v81[1];
        sub_100441FD4(*v81, v83);
        uint64_t *v80 = v82;
        v80[1] = v83;
        uint64_t v84 = v14[7];
        uint64_t v85 = (uint64_t *)&a1[v84];
        unint64_t v86 = (uint64_t *)&a2[v84];
        uint64_t v87 = *v86;
        unint64_t v88 = v86[1];
        sub_100441FD4(*v86, v88);
        uint64_t *v85 = v87;
        v85[1] = v88;
        uint64_t v89 = v14[8];
        uint64_t v90 = &a1[v89];
        uint64_t v91 = &a2[v89];
        uint64_t v92 = sub_100725CC0();
        (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v92 - 8) + 16))(v90, v91, v92);
        uint64_t v93 = v14[9];
        uint64_t v94 = &a1[v93];
        char v95 = &a2[v93];
        uint64_t v96 = v95[1];
        void *v94 = *v95;
        v94[1] = v96;
        *(_DWORD *)&a1[v14[10]] = *(_DWORD *)&a2[v14[10]];
        *(_DWORD *)&a1[v14[11]] = *(_DWORD *)&a2[v14[11]];
        a1[v14[12]] = a2[v14[12]];
        uint64_t v97 = v14[13];
        uint64_t v98 = &a1[v97];
        uint64_t v99 = &a2[v97];
        v98[8] = v99[8];
        *(void *)uint64_t v98 = *(void *)v99;
        uint64_t v100 = *(void (**)(unsigned char *, void, uint64_t, int *))(v15 + 56);
        swift_bridgeObjectRetain();
        v100(a1, 0, 1, v14);
      }
      id v173 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey(0);
      uint64_t v101 = v173[5];
      uint64_t v102 = &a1[v101];
      uint64_t v103 = &a2[v101];
      *uint64_t v102 = a2[v101];
      uint64_t v104 = v14[5];
      uint64_t v105 = &v102[v104];
      uint64_t v106 = &v103[v104];
      uint64_t v170 = sub_100725D30();
      id v169 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v170 - 8) + 16);
      v169(v105, v106, v170);
      uint64_t v107 = v14[6];
      uint64_t v108 = (uint64_t *)&v102[v107];
      unint64_t v109 = (uint64_t *)&v103[v107];
      uint64_t v110 = *v109;
      unint64_t v111 = v109[1];
      sub_100441FD4(*v109, v111);
      uint64_t *v108 = v110;
      v108[1] = v111;
      uint64_t v112 = v14[7];
      uint64_t v113 = (uint64_t *)&v102[v112];
      unint64_t v114 = (uint64_t *)&v103[v112];
      uint64_t v115 = *v114;
      unint64_t v116 = v114[1];
      sub_100441FD4(*v114, v116);
      *uint64_t v113 = v115;
      v113[1] = v116;
      uint64_t v117 = v14[8];
      uint64_t v118 = &v102[v117];
      uint64_t v119 = &v103[v117];
      uint64_t v167 = sub_100725CC0();
      id v168 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v167 - 8) + 16);
      v168(v118, v119, v167);
      uint64_t v120 = v14[9];
      uint64_t v121 = &v102[v120];
      uint64_t v122 = &v103[v120];
      uint64_t v123 = v122[1];
      *uint64_t v121 = *v122;
      v121[1] = v123;
      *(_DWORD *)&v102[v14[10]] = *(_DWORD *)&v103[v14[10]];
      *(_DWORD *)&v102[v14[11]] = *(_DWORD *)&v103[v14[11]];
      v102[v14[12]] = v103[v14[12]];
      uint64_t v124 = v14[13];
      uint64_t v125 = &v102[v124];
      uint64_t v126 = &v103[v124];
      *(void *)uint64_t v125 = *(void *)v126;
      v125[8] = v126[8];
      uint64_t v127 = v173[6];
      uint64_t v128 = &a1[v127];
      uint64_t v129 = &a2[v127];
      *uint64_t v128 = a2[v127];
      uint64_t v130 = v14[5];
      char v131 = &v128[v130];
      uint64_t v132 = &v129[v130];
      swift_bridgeObjectRetain();
      v169(v131, v132, v170);
      uint64_t v133 = v14[6];
      unint64_t v134 = (uint64_t *)&v128[v133];
      uint64_t v135 = (uint64_t *)&v129[v133];
      uint64_t v136 = *v135;
      unint64_t v137 = v135[1];
      sub_100441FD4(*v135, v137);
      *unint64_t v134 = v136;
      v134[1] = v137;
      uint64_t v138 = v14[7];
      unint64_t v139 = (uint64_t *)&v128[v138];
      uint64_t v140 = (uint64_t *)&v129[v138];
      uint64_t v141 = *v140;
      unint64_t v142 = v140[1];
      sub_100441FD4(*v140, v142);
      uint64_t *v139 = v141;
      v139[1] = v142;
      v168(&v128[v14[8]], &v129[v14[8]], v167);
      uint64_t v143 = v14[9];
      uint64_t v144 = &v128[v143];
      uint64_t v145 = &v129[v143];
      uint64_t v146 = v145[1];
      void *v144 = *v145;
      v144[1] = v146;
      *(_DWORD *)&v128[v14[10]] = *(_DWORD *)&v129[v14[10]];
      *(_DWORD *)&v128[v14[11]] = *(_DWORD *)&v129[v14[11]];
      v128[v14[12]] = v129[v14[12]];
      uint64_t v147 = v14[13];
      uint64_t v148 = &v128[v147];
      uint64_t v149 = &v129[v147];
      v148[8] = v149[8];
      *(void *)uint64_t v148 = *(void *)v149;
      uint64_t v150 = v173[7];
      uint64_t v151 = &a1[v150];
      uint64_t v152 = &a2[v150];
      swift_bridgeObjectRetain();
      v168(v151, v152, v167);
    }
    else
    {
      if (EnumCaseMultiPayload)
      {
        memcpy(a1, a2, *(void *)(*(void *)(v7 - 8) + 64));
LABEL_15:
        uint64_t v153 = a3[5];
        uint64_t v154 = a3[6];
        uint64_t v155 = &a1[v153];
        uint64_t v156 = &a2[v153];
        *(_OWORD *)uint64_t v155 = *(_OWORD *)v156;
        char v157 = a2[v154];
        v155[16] = v156[16];
        a1[v154] = v157;
        id v158 = &a2[a3[7]];
        *(void *)(swift_unknownObjectWeakCopyInit() + _Block_object_dispose(&STACK[0x320], 8) = *((void *)v158 + 1);
        uint64_t v159 = a3[9];
        *(void *)&a1[a3[8]] = *(void *)&a2[a3[8]];
        *(void *)&a1[v159] = *(void *)&a2[v159];
        uint64_t v160 = a3[11];
        *(void *)&a1[a3[10]] = *(void *)&a2[a3[10]];
        *(void *)&a1[v160] = *(void *)&a2[v160];
        uint64_t v161 = a3[13];
        a1[a3[12]] = a2[a3[12]];
        *(void *)&a1[v161] = *(void *)&a2[v161];
        uint64_t v162 = a3[14];
        id v174 = &a2[v162];
        id v175 = &a1[v162];
        uint64_t v163 = sub_100725CC0();
        id v164 = a3;
        id v165 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v163 - 8) + 16);
        uint64_t v13 = a1;
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_retain();
        swift_bridgeObjectRetain();
        v165(v175, v174, v163);
        *(void *)&a1[v164[15]] = *(void *)&a2[v164[15]];
        return v13;
      }
      uint64_t v9 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
      uint64_t v10 = *((void *)v9 - 1);
      if ((*(unsigned int (**)(unsigned char *, uint64_t, int *))(v10 + 48))(a2, 1, v9))
      {
        uint64_t v11 = sub_100431F80(&qword_100A44A50);
        memcpy(a1, a2, *(void *)(*(void *)(v11 - 8) + 64));
      }
      else
      {
        *a1 = *a2;
        uint64_t v17 = v9[5];
        uint64_t v18 = &a1[v17];
        uint64_t v19 = &a2[v17];
        uint64_t v20 = sub_100725D30();
        (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v20 - 8) + 16))(v18, v19, v20);
        uint64_t v21 = v9[6];
        uint64_t v22 = (uint64_t *)&a1[v21];
        uint64_t v23 = (uint64_t *)&a2[v21];
        uint64_t v24 = *v23;
        unint64_t v25 = v23[1];
        sub_100441FD4(*v23, v25);
        *uint64_t v22 = v24;
        v22[1] = v25;
        uint64_t v26 = v9[7];
        uint64_t v27 = (uint64_t *)&a1[v26];
        uint64_t v28 = (uint64_t *)&a2[v26];
        uint64_t v29 = *v28;
        unint64_t v30 = v28[1];
        sub_100441FD4(*v28, v30);
        *uint64_t v27 = v29;
        v27[1] = v30;
        uint64_t v31 = v9[8];
        uint64_t v32 = &a1[v31];
        uint64_t v33 = &a2[v31];
        uint64_t v34 = sub_100725CC0();
        (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v34 - 8) + 16))(v32, v33, v34);
        uint64_t v35 = v9[9];
        uint64_t v36 = &a1[v35];
        char v37 = &a2[v35];
        uint64_t v38 = v37[1];
        *uint64_t v36 = *v37;
        v36[1] = v38;
        *(_DWORD *)&a1[v9[10]] = *(_DWORD *)&a2[v9[10]];
        *(_DWORD *)&a1[v9[11]] = *(_DWORD *)&a2[v9[11]];
        a1[v9[12]] = a2[v9[12]];
        uint64_t v39 = v9[13];
        uint64_t v40 = &a1[v39];
        uint64_t v41 = &a2[v39];
        v40[8] = v41[8];
        *(void *)uint64_t v40 = *(void *)v41;
        uint64_t v42 = *(void (**)(unsigned char *, void, uint64_t, int *))(v10 + 56);
        swift_bridgeObjectRetain();
        v42(a1, 0, 1, v9);
      }
      uint64_t v172 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(0);
      uint64_t v43 = *(int *)(v172 + 20);
      uint64_t v44 = &a1[v43];
      uint64_t v45 = &a2[v43];
      *uint64_t v44 = a2[v43];
      uint64_t v46 = v9[5];
      uint64_t v47 = &v44[v46];
      uint64_t v48 = &v45[v46];
      uint64_t v49 = sub_100725D30();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v49 - 8) + 16))(v47, v48, v49);
      uint64_t v50 = v9[6];
      uint64_t v51 = (uint64_t *)&v44[v50];
      unint64_t v52 = (uint64_t *)&v45[v50];
      uint64_t v53 = *v52;
      unint64_t v54 = v52[1];
      sub_100441FD4(*v52, v54);
      *uint64_t v51 = v53;
      v51[1] = v54;
      uint64_t v55 = v9[7];
      uint64_t v56 = (uint64_t *)&v44[v55];
      unint64_t v57 = (uint64_t *)&v45[v55];
      uint64_t v58 = *v57;
      unint64_t v59 = v57[1];
      sub_100441FD4(*v57, v59);
      uint64_t *v56 = v58;
      v56[1] = v59;
      uint64_t v60 = v9[8];
      id v171 = &v44[v60];
      uint64_t v61 = &v45[v60];
      uint64_t v62 = sub_100725CC0();
      uint64_t v63 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v62 - 8) + 16);
      v63(v171, v61, v62);
      uint64_t v64 = v63;
      uint64_t v65 = v9[9];
      uint64_t v66 = &v44[v65];
      uint64_t v67 = &v45[v65];
      uint64_t v68 = v67[1];
      void *v66 = *v67;
      v66[1] = v68;
      *(_DWORD *)&v44[v9[10]] = *(_DWORD *)&v45[v9[10]];
      *(_DWORD *)&v44[v9[11]] = *(_DWORD *)&v45[v9[11]];
      v44[v9[12]] = v45[v9[12]];
      uint64_t v69 = v9[13];
      uint64_t v70 = &v44[v69];
      uint64_t v71 = &v45[v69];
      v70[8] = v71[8];
      *(void *)uint64_t v70 = *(void *)v71;
      uint64_t v72 = *(int *)(v172 + 24);
      uint64_t v73 = &a1[v72];
      uint64_t v74 = &a2[v72];
      swift_bridgeObjectRetain();
      v64(v73, v74, v62);
    }
    swift_storeEnumTagMultiPayload();
    goto LABEL_15;
  }
  uint64_t v12 = *(void *)a2;
  *(void *)a1 = *(void *)a2;
  uint64_t v13 = (unsigned char *)(v12 + ((v5 + 16) & ~(unint64_t)v5));
  swift_retain();
  return v13;
}

uint64_t sub_100449148(uint64_t a1, uint64_t a2)
{
  type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState(0);
  int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
  if (EnumCaseMultiPayload == 1)
  {
    uint64_t v17 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
    if (!(*(unsigned int (**)(uint64_t, uint64_t, int *))(*((void *)v17 - 1) + 48))(a1, 1, v17))
    {
      uint64_t v18 = a1 + v17[5];
      uint64_t v19 = sub_100725D30();
      (*(void (**)(uint64_t, uint64_t))(*(void *)(v19 - 8) + 8))(v18, v19);
      sub_100442248(*(void *)(a1 + v17[6]), *(void *)(a1 + v17[6] + 8));
      sub_100442248(*(void *)(a1 + v17[7]), *(void *)(a1 + v17[7] + 8));
      uint64_t v20 = a1 + v17[8];
      uint64_t v21 = sub_100725CC0();
      (*(void (**)(uint64_t, uint64_t))(*(void *)(v21 - 8) + 8))(v20, v21);
      swift_bridgeObjectRelease();
    }
    uint64_t v34 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey(0);
    uint64_t v22 = a1 + v34[5];
    uint64_t v23 = v22 + v17[5];
    uint64_t v24 = sub_100725D30();
    uint64_t v33 = *(void (**)(uint64_t, uint64_t))(*(void *)(v24 - 8) + 8);
    v33(v23, v24);
    sub_100442248(*(void *)(v22 + v17[6]), *(void *)(v22 + v17[6] + 8));
    sub_100442248(*(void *)(v22 + v17[7]), *(void *)(v22 + v17[7] + 8));
    uint64_t v25 = v22 + v17[8];
    uint64_t v26 = sub_100725CC0();
    uint64_t v27 = *(void (**)(uint64_t, uint64_t))(*(void *)(v26 - 8) + 8);
    v27(v25, v26);
    swift_bridgeObjectRelease();
    uint64_t v28 = a1 + v34[6];
    v33(v28 + v17[5], v24);
    sub_100442248(*(void *)(v28 + v17[6]), *(void *)(v28 + v17[6] + 8));
    sub_100442248(*(void *)(v28 + v17[7]), *(void *)(v28 + v17[7] + 8));
    v27(v28 + v17[8], v26);
    swift_bridgeObjectRelease();
    v27(a1 + v34[7], v26);
  }
  else if (!EnumCaseMultiPayload)
  {
    int v5 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
    if (!(*(unsigned int (**)(uint64_t, uint64_t, int *))(*((void *)v5 - 1) + 48))(a1, 1, v5))
    {
      uint64_t v6 = a1 + v5[5];
      uint64_t v7 = sub_100725D30();
      (*(void (**)(uint64_t, uint64_t))(*(void *)(v7 - 8) + 8))(v6, v7);
      sub_100442248(*(void *)(a1 + v5[6]), *(void *)(a1 + v5[6] + 8));
      sub_100442248(*(void *)(a1 + v5[7]), *(void *)(a1 + v5[7] + 8));
      uint64_t v8 = a1 + v5[8];
      uint64_t v9 = sub_100725CC0();
      (*(void (**)(uint64_t, uint64_t))(*(void *)(v9 - 8) + 8))(v8, v9);
      swift_bridgeObjectRelease();
    }
    uint64_t v10 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(0);
    uint64_t v11 = a1 + *(int *)(v10 + 20);
    uint64_t v12 = v11 + v5[5];
    uint64_t v13 = sub_100725D30();
    (*(void (**)(uint64_t, uint64_t))(*(void *)(v13 - 8) + 8))(v12, v13);
    sub_100442248(*(void *)(v11 + v5[6]), *(void *)(v11 + v5[6] + 8));
    sub_100442248(*(void *)(v11 + v5[7]), *(void *)(v11 + v5[7] + 8));
    uint64_t v14 = v11 + v5[8];
    uint64_t v15 = sub_100725CC0();
    uint64_t v16 = *(void (**)(uint64_t, uint64_t))(*(void *)(v15 - 8) + 8);
    v16(v14, v15);
    swift_bridgeObjectRelease();
    v16(a1 + *(int *)(v10 + 24), v15);
  }
  swift_unknownObjectWeakDestroy();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_release();
  swift_bridgeObjectRelease();
  uint64_t v29 = a1 + *(int *)(a2 + 56);
  uint64_t v30 = sub_100725CC0();
  uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v30 - 8) + 8);

  return v31(v29, v30);
}

unsigned char *sub_100449654(unsigned char *a1, unsigned char *a2, int *a3)
{
  uint64_t v5 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState(0);
  int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
  if (EnumCaseMultiPayload == 1)
  {
    uint64_t v10 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
    uint64_t v11 = *((void *)v10 - 1);
    if ((*(unsigned int (**)(unsigned char *, uint64_t, int *))(v11 + 48))(a2, 1, v10))
    {
      uint64_t v12 = sub_100431F80(&qword_100A44A50);
      memcpy(a1, a2, *(void *)(*(void *)(v12 - 8) + 64));
    }
    else
    {
      *a1 = *a2;
      uint64_t v72 = v10[5];
      uint64_t v73 = &a1[v72];
      uint64_t v74 = &a2[v72];
      uint64_t v75 = sub_100725D30();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v75 - 8) + 16))(v73, v74, v75);
      uint64_t v76 = v10[6];
      uint64_t v77 = (uint64_t *)&a1[v76];
      uint64_t v78 = (uint64_t *)&a2[v76];
      uint64_t v79 = *v78;
      unint64_t v80 = v78[1];
      sub_100441FD4(*v78, v80);
      uint64_t *v77 = v79;
      v77[1] = v80;
      uint64_t v81 = v10[7];
      uint64_t v82 = (uint64_t *)&a1[v81];
      unint64_t v83 = (uint64_t *)&a2[v81];
      uint64_t v84 = *v83;
      unint64_t v85 = v83[1];
      sub_100441FD4(*v83, v85);
      uint64_t *v82 = v84;
      v82[1] = v85;
      uint64_t v86 = v10[8];
      uint64_t v87 = &a1[v86];
      unint64_t v88 = &a2[v86];
      uint64_t v89 = sub_100725CC0();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v89 - 8) + 16))(v87, v88, v89);
      uint64_t v90 = v10[9];
      uint64_t v91 = &a1[v90];
      uint64_t v92 = &a2[v90];
      uint64_t v93 = v92[1];
      *uint64_t v91 = *v92;
      v91[1] = v93;
      *(_DWORD *)&a1[v10[10]] = *(_DWORD *)&a2[v10[10]];
      *(_DWORD *)&a1[v10[11]] = *(_DWORD *)&a2[v10[11]];
      a1[v10[12]] = a2[v10[12]];
      uint64_t v94 = v10[13];
      char v95 = &a1[v94];
      uint64_t v96 = &a2[v94];
      v95[8] = v96[8];
      *(void *)char v95 = *(void *)v96;
      uint64_t v97 = *(void (**)(unsigned char *, void, uint64_t, int *))(v11 + 56);
      swift_bridgeObjectRetain();
      v97(a1, 0, 1, v10);
    }
    id v168 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey(0);
    uint64_t v98 = v168[5];
    uint64_t v99 = &a1[v98];
    uint64_t v100 = &a2[v98];
    *uint64_t v99 = a2[v98];
    uint64_t v101 = v10[5];
    uint64_t v102 = &v99[v101];
    uint64_t v103 = &v100[v101];
    uint64_t v166 = sub_100725D30();
    id v165 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v166 - 8) + 16);
    v165(v102, v103, v166);
    uint64_t v104 = v10[6];
    uint64_t v105 = (uint64_t *)&v99[v104];
    uint64_t v106 = (uint64_t *)&v100[v104];
    uint64_t v107 = *v106;
    unint64_t v108 = v106[1];
    sub_100441FD4(*v106, v108);
    *uint64_t v105 = v107;
    v105[1] = v108;
    uint64_t v109 = v10[7];
    uint64_t v110 = (uint64_t *)&v99[v109];
    unint64_t v111 = (uint64_t *)&v100[v109];
    uint64_t v112 = *v111;
    unint64_t v113 = v111[1];
    sub_100441FD4(*v111, v113);
    *uint64_t v110 = v112;
    v110[1] = v113;
    uint64_t v114 = v10[8];
    uint64_t v115 = &v99[v114];
    unint64_t v116 = &v100[v114];
    uint64_t v163 = sub_100725CC0();
    id v164 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v163 - 8) + 16);
    v164(v115, v116, v163);
    uint64_t v117 = v10[9];
    uint64_t v118 = &v99[v117];
    uint64_t v119 = &v100[v117];
    uint64_t v120 = v119[1];
    *uint64_t v118 = *v119;
    v118[1] = v120;
    *(_DWORD *)&v99[v10[10]] = *(_DWORD *)&v100[v10[10]];
    *(_DWORD *)&v99[v10[11]] = *(_DWORD *)&v100[v10[11]];
    v99[v10[12]] = v100[v10[12]];
    uint64_t v121 = v10[13];
    uint64_t v122 = &v99[v121];
    uint64_t v123 = &v100[v121];
    *(void *)uint64_t v122 = *(void *)v123;
    v122[8] = v123[8];
    uint64_t v124 = v168[6];
    uint64_t v125 = &a1[v124];
    uint64_t v126 = &a2[v124];
    *uint64_t v125 = a2[v124];
    uint64_t v127 = v10[5];
    uint64_t v128 = &v125[v127];
    uint64_t v129 = &v126[v127];
    swift_bridgeObjectRetain();
    v165(v128, v129, v166);
    uint64_t v130 = v10[6];
    char v131 = (uint64_t *)&v125[v130];
    uint64_t v132 = (uint64_t *)&v126[v130];
    uint64_t v133 = *v132;
    unint64_t v134 = v132[1];
    sub_100441FD4(*v132, v134);
    uint64_t *v131 = v133;
    v131[1] = v134;
    uint64_t v135 = v10[7];
    uint64_t v136 = (uint64_t *)&v125[v135];
    unint64_t v137 = (uint64_t *)&v126[v135];
    uint64_t v138 = *v137;
    unint64_t v139 = v137[1];
    sub_100441FD4(*v137, v139);
    *uint64_t v136 = v138;
    v136[1] = v139;
    v164(&v125[v10[8]], &v126[v10[8]], v163);
    uint64_t v140 = v10[9];
    uint64_t v141 = &v125[v140];
    unint64_t v142 = &v126[v140];
    uint64_t v143 = v142[1];
    *uint64_t v141 = *v142;
    v141[1] = v143;
    *(_DWORD *)&v125[v10[10]] = *(_DWORD *)&v126[v10[10]];
    *(_DWORD *)&v125[v10[11]] = *(_DWORD *)&v126[v10[11]];
    v125[v10[12]] = v126[v10[12]];
    uint64_t v144 = v10[13];
    uint64_t v145 = &v125[v144];
    uint64_t v146 = &v126[v144];
    v145[8] = v146[8];
    *(void *)uint64_t v145 = *(void *)v146;
    uint64_t v147 = v168[7];
    uint64_t v148 = &a1[v147];
    uint64_t v149 = &a2[v147];
    swift_bridgeObjectRetain();
    v164(v148, v149, v163);
    goto LABEL_12;
  }
  if (!EnumCaseMultiPayload)
  {
    uint64_t v7 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
    uint64_t v8 = *((void *)v7 - 1);
    if ((*(unsigned int (**)(unsigned char *, uint64_t, int *))(v8 + 48))(a2, 1, v7))
    {
      uint64_t v9 = sub_100431F80(&qword_100A44A50);
      memcpy(a1, a2, *(void *)(*(void *)(v9 - 8) + 64));
    }
    else
    {
      *a1 = *a2;
      uint64_t v13 = v7[5];
      uint64_t v14 = &a1[v13];
      uint64_t v15 = &a2[v13];
      uint64_t v16 = sub_100725D30();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v16 - 8) + 16))(v14, v15, v16);
      uint64_t v17 = v7[6];
      uint64_t v18 = (uint64_t *)&a1[v17];
      uint64_t v19 = (uint64_t *)&a2[v17];
      uint64_t v20 = *v19;
      unint64_t v21 = v19[1];
      sub_100441FD4(*v19, v21);
      *uint64_t v18 = v20;
      v18[1] = v21;
      uint64_t v22 = v7[7];
      uint64_t v23 = (uint64_t *)&a1[v22];
      uint64_t v24 = (uint64_t *)&a2[v22];
      uint64_t v25 = *v24;
      unint64_t v26 = v24[1];
      sub_100441FD4(*v24, v26);
      *uint64_t v23 = v25;
      v23[1] = v26;
      uint64_t v27 = v7[8];
      uint64_t v28 = &a1[v27];
      uint64_t v29 = &a2[v27];
      uint64_t v30 = sub_100725CC0();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v30 - 8) + 16))(v28, v29, v30);
      uint64_t v31 = v7[9];
      uint64_t v32 = &a1[v31];
      uint64_t v33 = &a2[v31];
      uint64_t v34 = v33[1];
      void *v32 = *v33;
      v32[1] = v34;
      *(_DWORD *)&a1[v7[10]] = *(_DWORD *)&a2[v7[10]];
      *(_DWORD *)&a1[v7[11]] = *(_DWORD *)&a2[v7[11]];
      a1[v7[12]] = a2[v7[12]];
      uint64_t v35 = v7[13];
      uint64_t v36 = &a1[v35];
      char v37 = &a2[v35];
      v36[8] = v37[8];
      *(void *)uint64_t v36 = *(void *)v37;
      uint64_t v38 = *(void (**)(unsigned char *, void, uint64_t, int *))(v8 + 56);
      swift_bridgeObjectRetain();
      v38(a1, 0, 1, v7);
    }
    uint64_t v167 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(0);
    uint64_t v39 = *(int *)(v167 + 20);
    uint64_t v40 = &a1[v39];
    uint64_t v41 = &a2[v39];
    *uint64_t v40 = a2[v39];
    uint64_t v42 = v7[5];
    uint64_t v43 = &v40[v42];
    uint64_t v44 = &v41[v42];
    uint64_t v45 = sub_100725D30();
    (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v45 - 8) + 16))(v43, v44, v45);
    uint64_t v46 = v7[6];
    uint64_t v47 = (uint64_t *)&v40[v46];
    uint64_t v48 = (uint64_t *)&v41[v46];
    uint64_t v49 = *v48;
    unint64_t v50 = v48[1];
    sub_100441FD4(*v48, v50);
    *uint64_t v47 = v49;
    v47[1] = v50;
    uint64_t v51 = v7[7];
    unint64_t v52 = (uint64_t *)&v40[v51];
    uint64_t v53 = (uint64_t *)&v41[v51];
    uint64_t v54 = *v53;
    unint64_t v55 = v53[1];
    sub_100441FD4(*v53, v55);
    uint64_t *v52 = v54;
    v52[1] = v55;
    uint64_t v56 = v7[8];
    unint64_t v57 = &v40[v56];
    uint64_t v58 = &v41[v56];
    uint64_t v59 = sub_100725CC0();
    uint64_t v60 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v59 - 8) + 16);
    v60(v57, v58, v59);
    uint64_t v61 = v60;
    uint64_t v62 = v7[9];
    uint64_t v63 = &v40[v62];
    uint64_t v64 = &v41[v62];
    uint64_t v65 = v64[1];
    *uint64_t v63 = *v64;
    v63[1] = v65;
    *(_DWORD *)&v40[v7[10]] = *(_DWORD *)&v41[v7[10]];
    *(_DWORD *)&v40[v7[11]] = *(_DWORD *)&v41[v7[11]];
    v40[v7[12]] = v41[v7[12]];
    uint64_t v66 = v7[13];
    uint64_t v67 = &v40[v66];
    uint64_t v68 = &v41[v66];
    v67[8] = v68[8];
    *(void *)uint64_t v67 = *(void *)v68;
    uint64_t v69 = *(int *)(v167 + 24);
    uint64_t v70 = &a1[v69];
    uint64_t v71 = &a2[v69];
    swift_bridgeObjectRetain();
    v61(v70, v71, v59);
LABEL_12:
    swift_storeEnumTagMultiPayload();
    goto LABEL_13;
  }
  memcpy(a1, a2, *(void *)(*(void *)(v5 - 8) + 64));
LABEL_13:
  uint64_t v150 = a3[5];
  uint64_t v151 = a3[6];
  uint64_t v152 = &a1[v150];
  uint64_t v153 = &a2[v150];
  *(_OWORD *)uint64_t v152 = *(_OWORD *)v153;
  char v154 = a2[v151];
  v152[16] = v153[16];
  a1[v151] = v154;
  uint64_t v155 = &a2[a3[7]];
  *(void *)(swift_unknownObjectWeakCopyInit() + _Block_object_dispose(&STACK[0x320], 8) = *((void *)v155 + 1);
  uint64_t v156 = a3[9];
  *(void *)&a1[a3[8]] = *(void *)&a2[a3[8]];
  *(void *)&a1[v156] = *(void *)&a2[v156];
  uint64_t v157 = a3[11];
  *(void *)&a1[a3[10]] = *(void *)&a2[a3[10]];
  *(void *)&a1[v157] = *(void *)&a2[v157];
  uint64_t v158 = a3[13];
  a1[a3[12]] = a2[a3[12]];
  *(void *)&a1[v158] = *(void *)&a2[v158];
  uint64_t v159 = a3[14];
  id v169 = &a2[v159];
  uint64_t v170 = &a1[v159];
  uint64_t v160 = sub_100725CC0();
  uint64_t v161 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v160 - 8) + 16);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_retain();
  swift_bridgeObjectRetain();
  v161(v170, v169, v160);
  *(void *)&a1[a3[15]] = *(void *)&a2[a3[15]];
  return a1;
}

unsigned char *sub_100449FE8(unsigned char *a1, unsigned char *a2, int *a3)
{
  if (a1 != a2)
  {
    sub_1004324A4((uint64_t)a1, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
    uint64_t v6 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState(0);
    int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
    if (EnumCaseMultiPayload == 1)
    {
      uint64_t v11 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
      uint64_t v12 = *((void *)v11 - 1);
      if ((*(unsigned int (**)(unsigned char *, uint64_t, int *))(v12 + 48))(a2, 1, v11))
      {
        uint64_t v13 = sub_100431F80(&qword_100A44A50);
        memcpy(a1, a2, *(void *)(*(void *)(v13 - 8) + 64));
      }
      else
      {
        *a1 = *a2;
        uint64_t v72 = v11[5];
        uint64_t v73 = &a1[v72];
        uint64_t v74 = &a2[v72];
        uint64_t v75 = sub_100725D30();
        (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v75 - 8) + 16))(v73, v74, v75);
        uint64_t v76 = v11[6];
        uint64_t v77 = (uint64_t *)&a1[v76];
        uint64_t v78 = (uint64_t *)&a2[v76];
        uint64_t v79 = *v78;
        unint64_t v80 = v78[1];
        sub_100441FD4(*v78, v80);
        uint64_t *v77 = v79;
        v77[1] = v80;
        uint64_t v81 = v11[7];
        uint64_t v82 = (uint64_t *)&a1[v81];
        unint64_t v83 = (uint64_t *)&a2[v81];
        uint64_t v84 = *v83;
        unint64_t v85 = v83[1];
        sub_100441FD4(*v83, v85);
        uint64_t *v82 = v84;
        v82[1] = v85;
        uint64_t v86 = v11[8];
        uint64_t v87 = &a1[v86];
        unint64_t v88 = &a2[v86];
        uint64_t v89 = sub_100725CC0();
        (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v89 - 8) + 16))(v87, v88, v89);
        uint64_t v90 = v11[9];
        uint64_t v91 = &a1[v90];
        uint64_t v92 = &a2[v90];
        *uint64_t v91 = *v92;
        v91[1] = v92[1];
        *(_DWORD *)&a1[v11[10]] = *(_DWORD *)&a2[v11[10]];
        *(_DWORD *)&a1[v11[11]] = *(_DWORD *)&a2[v11[11]];
        a1[v11[12]] = a2[v11[12]];
        uint64_t v93 = v11[13];
        uint64_t v94 = &a1[v93];
        char v95 = &a2[v93];
        char v96 = v95[8];
        *(void *)uint64_t v94 = *(void *)v95;
        v94[8] = v96;
        uint64_t v97 = *(void (**)(unsigned char *, void, uint64_t, int *))(v12 + 56);
        swift_bridgeObjectRetain();
        v97(a1, 0, 1, v11);
      }
      uint64_t v166 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey(0);
      uint64_t v98 = v166[5];
      uint64_t v99 = &a1[v98];
      uint64_t v100 = &a2[v98];
      *uint64_t v99 = a2[v98];
      uint64_t v101 = v11[5];
      uint64_t v102 = &v99[v101];
      uint64_t v103 = &v100[v101];
      uint64_t v163 = sub_100725D30();
      uint64_t v162 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v163 - 8) + 16);
      v162(v102, v103, v163);
      uint64_t v104 = v11[6];
      uint64_t v105 = (uint64_t *)&v99[v104];
      uint64_t v106 = (uint64_t *)&v100[v104];
      uint64_t v107 = *v106;
      unint64_t v108 = v106[1];
      sub_100441FD4(*v106, v108);
      *uint64_t v105 = v107;
      v105[1] = v108;
      uint64_t v109 = v11[7];
      uint64_t v110 = (uint64_t *)&v99[v109];
      unint64_t v111 = (uint64_t *)&v100[v109];
      uint64_t v112 = *v111;
      unint64_t v113 = v111[1];
      sub_100441FD4(*v111, v113);
      *uint64_t v110 = v112;
      v110[1] = v113;
      uint64_t v114 = v11[8];
      uint64_t v115 = &v99[v114];
      unint64_t v116 = &v100[v114];
      uint64_t v160 = sub_100725CC0();
      uint64_t v161 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v160 - 8) + 16);
      v161(v115, v116, v160);
      uint64_t v117 = v11[9];
      uint64_t v118 = &v99[v117];
      uint64_t v119 = &v100[v117];
      *uint64_t v118 = *v119;
      v118[1] = v119[1];
      *(_DWORD *)&v99[v11[10]] = *(_DWORD *)&v100[v11[10]];
      *(_DWORD *)&v99[v11[11]] = *(_DWORD *)&v100[v11[11]];
      v99[v11[12]] = v100[v11[12]];
      uint64_t v120 = v11[13];
      uint64_t v121 = &v99[v120];
      uint64_t v122 = &v100[v120];
      char v123 = v122[8];
      *(void *)uint64_t v121 = *(void *)v122;
      v121[8] = v123;
      uint64_t v124 = v166[6];
      uint64_t v125 = &a1[v124];
      uint64_t v126 = &a2[v124];
      *uint64_t v125 = a2[v124];
      uint64_t v127 = v11[5];
      uint64_t v128 = &v125[v127];
      uint64_t v129 = &v126[v127];
      swift_bridgeObjectRetain();
      v162(v128, v129, v163);
      uint64_t v130 = v11[6];
      char v131 = (uint64_t *)&v125[v130];
      uint64_t v132 = (uint64_t *)&v126[v130];
      uint64_t v133 = *v132;
      unint64_t v134 = v132[1];
      sub_100441FD4(*v132, v134);
      uint64_t *v131 = v133;
      v131[1] = v134;
      uint64_t v135 = v11[7];
      uint64_t v136 = (uint64_t *)&v125[v135];
      unint64_t v137 = (uint64_t *)&v126[v135];
      uint64_t v138 = *v137;
      unint64_t v139 = v137[1];
      sub_100441FD4(*v137, v139);
      *uint64_t v136 = v138;
      v136[1] = v139;
      v161(&v125[v11[8]], &v126[v11[8]], v160);
      uint64_t v140 = v11[9];
      uint64_t v141 = &v125[v140];
      unint64_t v142 = &v126[v140];
      *uint64_t v141 = *v142;
      v141[1] = v142[1];
      *(_DWORD *)&v125[v11[10]] = *(_DWORD *)&v126[v11[10]];
      *(_DWORD *)&v125[v11[11]] = *(_DWORD *)&v126[v11[11]];
      v125[v11[12]] = v126[v11[12]];
      uint64_t v143 = v11[13];
      uint64_t v144 = &v125[v143];
      uint64_t v145 = &v126[v143];
      char v146 = v145[8];
      *(void *)uint64_t v144 = *(void *)v145;
      v144[8] = v146;
      uint64_t v147 = v166[7];
      uint64_t v148 = &a1[v147];
      uint64_t v149 = &a2[v147];
      swift_bridgeObjectRetain();
      v161(v148, v149, v160);
      goto LABEL_13;
    }
    if (!EnumCaseMultiPayload)
    {
      uint64_t v8 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
      uint64_t v9 = *((void *)v8 - 1);
      if ((*(unsigned int (**)(unsigned char *, uint64_t, int *))(v9 + 48))(a2, 1, v8))
      {
        uint64_t v10 = sub_100431F80(&qword_100A44A50);
        memcpy(a1, a2, *(void *)(*(void *)(v10 - 8) + 64));
      }
      else
      {
        *a1 = *a2;
        uint64_t v14 = v8[5];
        uint64_t v15 = &a1[v14];
        uint64_t v16 = &a2[v14];
        uint64_t v17 = sub_100725D30();
        (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v17 - 8) + 16))(v15, v16, v17);
        uint64_t v18 = v8[6];
        uint64_t v19 = (uint64_t *)&a1[v18];
        uint64_t v20 = (uint64_t *)&a2[v18];
        uint64_t v21 = *v20;
        unint64_t v22 = v20[1];
        sub_100441FD4(*v20, v22);
        *uint64_t v19 = v21;
        v19[1] = v22;
        uint64_t v23 = v8[7];
        uint64_t v24 = (uint64_t *)&a1[v23];
        uint64_t v25 = (uint64_t *)&a2[v23];
        uint64_t v26 = *v25;
        unint64_t v27 = v25[1];
        sub_100441FD4(*v25, v27);
        *uint64_t v24 = v26;
        v24[1] = v27;
        uint64_t v28 = v8[8];
        uint64_t v29 = &a1[v28];
        uint64_t v30 = &a2[v28];
        uint64_t v31 = sub_100725CC0();
        (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v31 - 8) + 16))(v29, v30, v31);
        uint64_t v32 = v8[9];
        uint64_t v33 = &a1[v32];
        uint64_t v34 = &a2[v32];
        *uint64_t v33 = *v34;
        v33[1] = v34[1];
        *(_DWORD *)&a1[v8[10]] = *(_DWORD *)&a2[v8[10]];
        *(_DWORD *)&a1[v8[11]] = *(_DWORD *)&a2[v8[11]];
        a1[v8[12]] = a2[v8[12]];
        uint64_t v35 = v8[13];
        uint64_t v36 = &a1[v35];
        char v37 = &a2[v35];
        char v38 = v37[8];
        *(void *)uint64_t v36 = *(void *)v37;
        v36[8] = v38;
        uint64_t v39 = *(void (**)(unsigned char *, void, uint64_t, int *))(v9 + 56);
        swift_bridgeObjectRetain();
        v39(a1, 0, 1, v8);
      }
      uint64_t v165 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(0);
      uint64_t v40 = *(int *)(v165 + 20);
      uint64_t v41 = &a1[v40];
      uint64_t v42 = &a2[v40];
      *uint64_t v41 = a2[v40];
      uint64_t v43 = v8[5];
      uint64_t v44 = &v41[v43];
      uint64_t v45 = &v42[v43];
      uint64_t v46 = sub_100725D30();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v46 - 8) + 16))(v44, v45, v46);
      uint64_t v47 = v8[6];
      uint64_t v48 = (uint64_t *)&v41[v47];
      uint64_t v49 = (uint64_t *)&v42[v47];
      uint64_t v50 = *v49;
      unint64_t v51 = v49[1];
      sub_100441FD4(*v49, v51);
      *uint64_t v48 = v50;
      v48[1] = v51;
      uint64_t v52 = v8[7];
      uint64_t v53 = (uint64_t *)&v41[v52];
      uint64_t v54 = (uint64_t *)&v42[v52];
      uint64_t v55 = *v54;
      unint64_t v56 = v54[1];
      sub_100441FD4(*v54, v56);
      *uint64_t v53 = v55;
      v53[1] = v56;
      uint64_t v57 = v8[8];
      id v164 = &v41[v57];
      uint64_t v58 = &v42[v57];
      uint64_t v59 = sub_100725CC0();
      uint64_t v60 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v59 - 8) + 16);
      v60(v164, v58, v59);
      uint64_t v61 = v60;
      uint64_t v62 = v8[9];
      uint64_t v63 = &v41[v62];
      uint64_t v64 = &v42[v62];
      *uint64_t v63 = *v64;
      v63[1] = v64[1];
      *(_DWORD *)&v41[v8[10]] = *(_DWORD *)&v42[v8[10]];
      *(_DWORD *)&v41[v8[11]] = *(_DWORD *)&v42[v8[11]];
      v41[v8[12]] = v42[v8[12]];
      uint64_t v65 = v8[13];
      uint64_t v66 = &v41[v65];
      uint64_t v67 = &v42[v65];
      char v68 = v67[8];
      *(void *)uint64_t v66 = *(void *)v67;
      v66[8] = v68;
      uint64_t v69 = *(int *)(v165 + 24);
      uint64_t v70 = &a1[v69];
      uint64_t v71 = &a2[v69];
      swift_bridgeObjectRetain();
      v61(v70, v71, v59);
LABEL_13:
      swift_storeEnumTagMultiPayload();
      goto LABEL_14;
    }
    memcpy(a1, a2, *(void *)(*(void *)(v6 - 8) + 64));
  }
LABEL_14:
  uint64_t v150 = a3[5];
  uint64_t v151 = &a1[v150];
  uint64_t v152 = &a2[v150];
  long long v153 = *(_OWORD *)v152;
  v151[16] = v152[16];
  *(_OWORD *)uint64_t v151 = v153;
  a1[a3[6]] = a2[a3[6]];
  char v154 = &a2[a3[7]];
  *(void *)(swift_unknownObjectWeakCopyAssign() + _Block_object_dispose(&STACK[0x320], 8) = *((void *)v154 + 1);
  *(void *)&a1[a3[8]] = *(void *)&a2[a3[8]];
  *(void *)&a1[a3[9]] = *(void *)&a2[a3[9]];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)&a1[a3[10]] = *(void *)&a2[a3[10]];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)&a1[a3[11]] = *(void *)&a2[a3[11]];
  swift_retain();
  swift_release();
  a1[a3[12]] = a2[a3[12]];
  *(void *)&a1[a3[13]] = *(void *)&a2[a3[13]];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v155 = a3[14];
  uint64_t v156 = &a1[v155];
  uint64_t v157 = &a2[v155];
  uint64_t v158 = sub_100725CC0();
  (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v158 - 8) + 24))(v156, v157, v158);
  *(void *)&a1[a3[15]] = *(void *)&a2[a3[15]];
  return a1;
}

unsigned char *sub_10044A9F4(unsigned char *a1, unsigned char *a2, int *a3)
{
  uint64_t v6 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState(0);
  int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
  if (EnumCaseMultiPayload == 1)
  {
    uint64_t v11 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
    uint64_t v12 = *((void *)v11 - 1);
    if ((*(unsigned int (**)(unsigned char *, uint64_t, int *))(v12 + 48))(a2, 1, v11))
    {
      uint64_t v13 = sub_100431F80(&qword_100A44A50);
      memcpy(a1, a2, *(void *)(*(void *)(v13 - 8) + 64));
    }
    else
    {
      *a1 = *a2;
      uint64_t v39 = v11[5];
      uint64_t v40 = &a1[v39];
      uint64_t v41 = &a2[v39];
      uint64_t v42 = sub_100725D30();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v42 - 8) + 32))(v40, v41, v42);
      *(_OWORD *)&a1[v11[6]] = *(_OWORD *)&a2[v11[6]];
      *(_OWORD *)&a1[v11[7]] = *(_OWORD *)&a2[v11[7]];
      uint64_t v43 = v11[8];
      uint64_t v44 = &a1[v43];
      uint64_t v45 = &a2[v43];
      uint64_t v46 = sub_100725CC0();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v46 - 8) + 32))(v44, v45, v46);
      *(_OWORD *)&a1[v11[9]] = *(_OWORD *)&a2[v11[9]];
      *(_DWORD *)&a1[v11[10]] = *(_DWORD *)&a2[v11[10]];
      *(_DWORD *)&a1[v11[11]] = *(_DWORD *)&a2[v11[11]];
      a1[v11[12]] = a2[v11[12]];
      uint64_t v47 = v11[13];
      uint64_t v48 = &a1[v47];
      uint64_t v49 = &a2[v47];
      *(void *)uint64_t v48 = *(void *)v49;
      v48[8] = v49[8];
      (*(void (**)(unsigned char *, void, uint64_t, int *))(v12 + 56))(a1, 0, 1, v11);
    }
    uint64_t v90 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey(0);
    uint64_t v50 = v90[5];
    unint64_t v51 = &a1[v50];
    uint64_t v52 = &a2[v50];
    *unint64_t v51 = a2[v50];
    uint64_t v53 = v11[5];
    uint64_t v54 = &v51[v53];
    uint64_t v55 = &v52[v53];
    uint64_t v87 = sub_100725D30();
    uint64_t v86 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v87 - 8) + 32);
    v86(v54, v55, v87);
    *(_OWORD *)&v51[v11[6]] = *(_OWORD *)&v52[v11[6]];
    *(_OWORD *)&v51[v11[7]] = *(_OWORD *)&v52[v11[7]];
    uint64_t v56 = v11[8];
    uint64_t v57 = &v51[v56];
    uint64_t v58 = &v52[v56];
    uint64_t v59 = sub_100725CC0();
    uint64_t v60 = (void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v59 - 8) + 32);
    uint64_t v61 = v58;
    uint64_t v62 = *v60;
    (*v60)(v57, v61, v59);
    *(_OWORD *)&v51[v11[9]] = *(_OWORD *)&v52[v11[9]];
    *(_DWORD *)&v51[v11[10]] = *(_DWORD *)&v52[v11[10]];
    *(_DWORD *)&v51[v11[11]] = *(_DWORD *)&v52[v11[11]];
    v51[v11[12]] = v52[v11[12]];
    uint64_t v63 = v11[13];
    uint64_t v64 = &v51[v63];
    uint64_t v65 = &v52[v63];
    *(void *)uint64_t v64 = *(void *)v65;
    void v64[8] = v65[8];
    uint64_t v66 = v90[6];
    uint64_t v67 = &a1[v66];
    char v68 = &a2[v66];
    a1[v66] = a2[v66];
    v86(&a1[v66 + v11[5]], &a2[v66 + v11[5]], v87);
    *(_OWORD *)&v67[v11[6]] = *(_OWORD *)&v68[v11[6]];
    *(_OWORD *)&v67[v11[7]] = *(_OWORD *)&v68[v11[7]];
    v62(&v67[v11[8]], &v68[v11[8]], v59);
    *(_OWORD *)&v67[v11[9]] = *(_OWORD *)&v68[v11[9]];
    *(_DWORD *)&v67[v11[10]] = *(_DWORD *)&v68[v11[10]];
    *(_DWORD *)&v67[v11[11]] = *(_DWORD *)&v68[v11[11]];
    v67[v11[12]] = v68[v11[12]];
    uint64_t v69 = v11[13];
    uint64_t v70 = &v67[v69];
    uint64_t v71 = &v68[v69];
    v70[8] = v71[8];
    *(void *)uint64_t v70 = *(void *)v71;
    v62(&a1[v90[7]], &a2[v90[7]], v59);
    goto LABEL_12;
  }
  if (!EnumCaseMultiPayload)
  {
    uint64_t v8 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
    uint64_t v9 = *((void *)v8 - 1);
    if ((*(unsigned int (**)(unsigned char *, uint64_t, int *))(v9 + 48))(a2, 1, v8))
    {
      uint64_t v10 = sub_100431F80(&qword_100A44A50);
      memcpy(a1, a2, *(void *)(*(void *)(v10 - 8) + 64));
    }
    else
    {
      *a1 = *a2;
      uint64_t v14 = v8[5];
      uint64_t v15 = &a1[v14];
      uint64_t v16 = &a2[v14];
      uint64_t v17 = sub_100725D30();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v17 - 8) + 32))(v15, v16, v17);
      *(_OWORD *)&a1[v8[6]] = *(_OWORD *)&a2[v8[6]];
      *(_OWORD *)&a1[v8[7]] = *(_OWORD *)&a2[v8[7]];
      uint64_t v18 = v8[8];
      uint64_t v19 = &a1[v18];
      uint64_t v20 = &a2[v18];
      uint64_t v21 = sub_100725CC0();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v21 - 8) + 32))(v19, v20, v21);
      *(_OWORD *)&a1[v8[9]] = *(_OWORD *)&a2[v8[9]];
      *(_DWORD *)&a1[v8[10]] = *(_DWORD *)&a2[v8[10]];
      *(_DWORD *)&a1[v8[11]] = *(_DWORD *)&a2[v8[11]];
      a1[v8[12]] = a2[v8[12]];
      uint64_t v22 = v8[13];
      uint64_t v23 = &a1[v22];
      uint64_t v24 = &a2[v22];
      *(void *)uint64_t v23 = *(void *)v24;
      v23[8] = v24[8];
      (*(void (**)(unsigned char *, void, uint64_t, int *))(v9 + 56))(a1, 0, 1, v8);
    }
    uint64_t v89 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(0);
    uint64_t v25 = *(int *)(v89 + 20);
    uint64_t v26 = &a1[v25];
    unint64_t v27 = &a2[v25];
    unsigned char *v26 = a2[v25];
    uint64_t v28 = v8[5];
    uint64_t v29 = &v26[v28];
    uint64_t v30 = &v27[v28];
    uint64_t v31 = sub_100725D30();
    (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v31 - 8) + 32))(v29, v30, v31);
    *(_OWORD *)&v26[v8[6]] = *(_OWORD *)&v27[v8[6]];
    *(_OWORD *)&v26[v8[7]] = *(_OWORD *)&v27[v8[7]];
    uint64_t v32 = v8[8];
    unint64_t v88 = &v26[v32];
    uint64_t v33 = &v27[v32];
    uint64_t v34 = sub_100725CC0();
    uint64_t v35 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v34 - 8) + 32);
    v35(v88, v33, v34);
    *(_OWORD *)&v26[v8[9]] = *(_OWORD *)&v27[v8[9]];
    *(_DWORD *)&v26[v8[10]] = *(_DWORD *)&v27[v8[10]];
    *(_DWORD *)&v26[v8[11]] = *(_DWORD *)&v27[v8[11]];
    v26[v8[12]] = v27[v8[12]];
    uint64_t v36 = v8[13];
    char v37 = &v26[v36];
    char v38 = &v27[v36];
    v37[8] = v38[8];
    *(void *)char v37 = *(void *)v38;
    v35(&a1[*(int *)(v89 + 24)], &a2[*(int *)(v89 + 24)], v34);
LABEL_12:
    swift_storeEnumTagMultiPayload();
    goto LABEL_13;
  }
  memcpy(a1, a2, *(void *)(*(void *)(v6 - 8) + 64));
LABEL_13:
  uint64_t v72 = a3[5];
  uint64_t v73 = a3[6];
  uint64_t v74 = &a1[v72];
  uint64_t v75 = &a2[v72];
  *(_OWORD *)uint64_t v74 = *(_OWORD *)v75;
  char v76 = a2[v73];
  v74[16] = v75[16];
  a1[v73] = v76;
  uint64_t v77 = &a2[a3[7]];
  *(void *)(swift_unknownObjectWeakTakeInit() + _Block_object_dispose(&STACK[0x320], 8) = *((void *)v77 + 1);
  uint64_t v78 = a3[9];
  *(void *)&a1[a3[8]] = *(void *)&a2[a3[8]];
  *(void *)&a1[v78] = *(void *)&a2[v78];
  uint64_t v79 = a3[11];
  *(void *)&a1[a3[10]] = *(void *)&a2[a3[10]];
  *(void *)&a1[v79] = *(void *)&a2[v79];
  uint64_t v80 = a3[13];
  a1[a3[12]] = a2[a3[12]];
  *(void *)&a1[v80] = *(void *)&a2[v80];
  uint64_t v81 = a3[14];
  uint64_t v82 = &a1[v81];
  unint64_t v83 = &a2[v81];
  uint64_t v84 = sub_100725CC0();
  (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v84 - 8) + 32))(v82, v83, v84);
  *(void *)&a1[a3[15]] = *(void *)&a2[a3[15]];
  return a1;
}

unsigned char *sub_10044B238(unsigned char *a1, unsigned char *a2, int *a3)
{
  if (a1 != a2)
  {
    sub_1004324A4((uint64_t)a1, type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState);
    uint64_t v6 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState(0);
    int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
    if (EnumCaseMultiPayload == 1)
    {
      uint64_t v11 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
      uint64_t v12 = *((void *)v11 - 1);
      if ((*(unsigned int (**)(unsigned char *, uint64_t, int *))(v12 + 48))(a2, 1, v11))
      {
        uint64_t v13 = sub_100431F80(&qword_100A44A50);
        memcpy(a1, a2, *(void *)(*(void *)(v13 - 8) + 64));
      }
      else
      {
        *a1 = *a2;
        uint64_t v39 = v11[5];
        uint64_t v40 = &a1[v39];
        uint64_t v41 = &a2[v39];
        uint64_t v42 = sub_100725D30();
        (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v42 - 8) + 32))(v40, v41, v42);
        *(_OWORD *)&a1[v11[6]] = *(_OWORD *)&a2[v11[6]];
        *(_OWORD *)&a1[v11[7]] = *(_OWORD *)&a2[v11[7]];
        uint64_t v43 = v11[8];
        uint64_t v44 = &a1[v43];
        uint64_t v45 = &a2[v43];
        uint64_t v46 = sub_100725CC0();
        (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v46 - 8) + 32))(v44, v45, v46);
        *(_OWORD *)&a1[v11[9]] = *(_OWORD *)&a2[v11[9]];
        *(_DWORD *)&a1[v11[10]] = *(_DWORD *)&a2[v11[10]];
        *(_DWORD *)&a1[v11[11]] = *(_DWORD *)&a2[v11[11]];
        a1[v11[12]] = a2[v11[12]];
        uint64_t v47 = v11[13];
        uint64_t v48 = &a1[v47];
        uint64_t v49 = &a2[v47];
        *(void *)uint64_t v48 = *(void *)v49;
        v48[8] = v49[8];
        (*(void (**)(unsigned char *, void, uint64_t, int *))(v12 + 56))(a1, 0, 1, v11);
      }
      uint64_t v89 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialController.TwoKey(0);
      uint64_t v50 = v89[5];
      unint64_t v51 = &a1[v50];
      uint64_t v52 = &a2[v50];
      *unint64_t v51 = a2[v50];
      uint64_t v53 = v11[5];
      uint64_t v54 = &v51[v53];
      uint64_t v55 = &v52[v53];
      uint64_t v86 = sub_100725D30();
      unint64_t v85 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v86 - 8) + 32);
      v85(v54, v55, v86);
      *(_OWORD *)&v51[v11[6]] = *(_OWORD *)&v52[v11[6]];
      *(_OWORD *)&v51[v11[7]] = *(_OWORD *)&v52[v11[7]];
      uint64_t v56 = v11[8];
      uint64_t v57 = &v51[v56];
      uint64_t v58 = &v52[v56];
      uint64_t v59 = sub_100725CC0();
      uint64_t v60 = (void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v59 - 8) + 32);
      uint64_t v61 = v58;
      uint64_t v62 = *v60;
      (*v60)(v57, v61, v59);
      *(_OWORD *)&v51[v11[9]] = *(_OWORD *)&v52[v11[9]];
      *(_DWORD *)&v51[v11[10]] = *(_DWORD *)&v52[v11[10]];
      *(_DWORD *)&v51[v11[11]] = *(_DWORD *)&v52[v11[11]];
      v51[v11[12]] = v52[v11[12]];
      uint64_t v63 = v11[13];
      uint64_t v64 = &v51[v63];
      uint64_t v65 = &v52[v63];
      *(void *)uint64_t v64 = *(void *)v65;
      void v64[8] = v65[8];
      uint64_t v66 = v89[6];
      uint64_t v67 = &a1[v66];
      char v68 = &a2[v66];
      a1[v66] = a2[v66];
      v85(&a1[v66 + v11[5]], &a2[v66 + v11[5]], v86);
      *(_OWORD *)&v67[v11[6]] = *(_OWORD *)&v68[v11[6]];
      *(_OWORD *)&v67[v11[7]] = *(_OWORD *)&v68[v11[7]];
      v62(&v67[v11[8]], &v68[v11[8]], v59);
      *(_OWORD *)&v67[v11[9]] = *(_OWORD *)&v68[v11[9]];
      *(_DWORD *)&v67[v11[10]] = *(_DWORD *)&v68[v11[10]];
      *(_DWORD *)&v67[v11[11]] = *(_DWORD *)&v68[v11[11]];
      v67[v11[12]] = v68[v11[12]];
      uint64_t v69 = v11[13];
      uint64_t v70 = &v67[v69];
      uint64_t v71 = &v68[v69];
      v70[8] = v71[8];
      *(void *)uint64_t v70 = *(void *)v71;
      v62(&a1[v89[7]], &a2[v89[7]], v59);
      goto LABEL_13;
    }
    if (!EnumCaseMultiPayload)
    {
      uint64_t v8 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialContent();
      uint64_t v9 = *((void *)v8 - 1);
      if ((*(unsigned int (**)(unsigned char *, uint64_t, int *))(v9 + 48))(a2, 1, v8))
      {
        uint64_t v10 = sub_100431F80(&qword_100A44A50);
        memcpy(a1, a2, *(void *)(*(void *)(v10 - 8) + 64));
      }
      else
      {
        *a1 = *a2;
        uint64_t v14 = v8[5];
        uint64_t v15 = &a1[v14];
        uint64_t v16 = &a2[v14];
        uint64_t v17 = sub_100725D30();
        (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v17 - 8) + 32))(v15, v16, v17);
        *(_OWORD *)&a1[v8[6]] = *(_OWORD *)&a2[v8[6]];
        *(_OWORD *)&a1[v8[7]] = *(_OWORD *)&a2[v8[7]];
        uint64_t v18 = v8[8];
        uint64_t v19 = &a1[v18];
        uint64_t v20 = &a2[v18];
        uint64_t v21 = sub_100725CC0();
        (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v21 - 8) + 32))(v19, v20, v21);
        *(_OWORD *)&a1[v8[9]] = *(_OWORD *)&a2[v8[9]];
        *(_DWORD *)&a1[v8[10]] = *(_DWORD *)&a2[v8[10]];
        *(_DWORD *)&a1[v8[11]] = *(_DWORD *)&a2[v8[11]];
        a1[v8[12]] = a2[v8[12]];
        uint64_t v22 = v8[13];
        uint64_t v23 = &a1[v22];
        uint64_t v24 = &a2[v22];
        *(void *)uint64_t v23 = *(void *)v24;
        v23[8] = v24[8];
        (*(void (**)(unsigned char *, void, uint64_t, int *))(v9 + 56))(a1, 0, 1, v8);
      }
      uint64_t v88 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.OneKey(0);
      uint64_t v25 = *(int *)(v88 + 20);
      uint64_t v26 = &a1[v25];
      unint64_t v27 = &a2[v25];
      unsigned char *v26 = a2[v25];
      uint64_t v28 = v8[5];
      uint64_t v29 = &v26[v28];
      uint64_t v30 = &v27[v28];
      uint64_t v31 = sub_100725D30();
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v31 - 8) + 32))(v29, v30, v31);
      *(_OWORD *)&v26[v8[6]] = *(_OWORD *)&v27[v8[6]];
      *(_OWORD *)&v26[v8[7]] = *(_OWORD *)&v27[v8[7]];
      uint64_t v32 = v8[8];
      uint64_t v87 = &v26[v32];
      uint64_t v33 = &v27[v32];
      uint64_t v34 = sub_100725CC0();
      uint64_t v35 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v34 - 8) + 32);
      v35(v87, v33, v34);
      *(_OWORD *)&v26[v8[9]] = *(_OWORD *)&v27[v8[9]];
      *(_DWORD *)&v26[v8[10]] = *(_DWORD *)&v27[v8[10]];
      *(_DWORD *)&v26[v8[11]] = *(_DWORD *)&v27[v8[11]];
      v26[v8[12]] = v27[v8[12]];
      uint64_t v36 = v8[13];
      char v37 = &v26[v36];
      char v38 = &v27[v36];
      v37[8] = v38[8];
      *(void *)char v37 = *(void *)v38;
      v35(&a1[*(int *)(v88 + 24)], &a2[*(int *)(v88 + 24)], v34);
LABEL_13:
      swift_storeEnumTagMultiPayload();
      goto LABEL_14;
    }
    memcpy(a1, a2, *(void *)(*(void *)(v6 - 8) + 64));
  }
LABEL_14:
  uint64_t v72 = a3[5];
  uint64_t v73 = a3[6];
  uint64_t v74 = &a1[v72];
  uint64_t v75 = &a2[v72];
  *(_OWORD *)uint64_t v74 = *(_OWORD *)v75;
  char v76 = a2[v73];
  v74[16] = v75[16];
  a1[v73] = v76;
  uint64_t v77 = &a2[a3[7]];
  *(void *)(swift_unknownObjectWeakTakeAssign() + _Block_object_dispose(&STACK[0x320], 8) = *((void *)v77 + 1);
  uint64_t v78 = a3[9];
  *(void *)&a1[a3[8]] = *(void *)&a2[a3[8]];
  *(void *)&a1[v78] = *(void *)&a2[v78];
  swift_bridgeObjectRelease();
  *(void *)&a1[a3[10]] = *(void *)&a2[a3[10]];
  swift_bridgeObjectRelease();
  *(void *)&a1[a3[11]] = *(void *)&a2[a3[11]];
  swift_release();
  uint64_t v79 = a3[13];
  a1[a3[12]] = a2[a3[12]];
  *(void *)&a1[v79] = *(void *)&a2[v79];
  swift_bridgeObjectRelease();
  uint64_t v80 = a3[14];
  uint64_t v81 = &a1[v80];
  uint64_t v82 = &a2[v80];
  uint64_t v83 = sub_100725CC0();
  (*(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)(v83 - 8) + 40))(v81, v82, v83);
  *(void *)&a1[a3[15]] = *(void *)&a2[a3[15]];
  return a1;
}

uint64_t sub_10044BAC4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return _swift_getEnumTagSinglePayloadGeneric(a1, a2, a3, sub_10044BAD8);
}

uint64_t sub_10044BAD8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState(0);
  uint64_t v7 = *(void *)(v6 - 8);
  if (*(_DWORD *)(v7 + 84) == a2)
  {
    uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 48);
    return v8(a1, a2, v6);
  }
  else if (a2 == 0x7FFFFFFF)
  {
    uint64_t v10 = a1 + *(int *)(a3 + 28);
    uint64_t v11 = *(void *)(v10 + 8);
    int v12 = *(_DWORD *)v10 & 0x7FFFFFFF;
    if ((v11 & 0xF000000000000007) != 0) {
      return (v12 + 1);
    }
    else {
      return 0;
    }
  }
  else
  {
    uint64_t v13 = sub_100725CC0();
    uint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v13 - 8) + 48);
    uint64_t v15 = v13;
    uint64_t v16 = a1 + *(int *)(a3 + 56);
    return v14(v16, a2, v15);
  }
}

uint64_t sub_10044BC08(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _swift_storeEnumTagSinglePayloadGeneric(a1, a2, a3, a4, sub_10044BC1C);
}

uint64_t sub_10044BC1C(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t result = type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState(0);
  uint64_t v9 = *(void *)(result - 8);
  if (*(_DWORD *)(v9 + 84) == a3)
  {
    uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 56);
    return v10(a1, a2, a2, result);
  }
  else if (a3 == 0x7FFFFFFF)
  {
    uint64_t v11 = (void *)(a1 + *(int *)(a4 + 28));
    *uint64_t v11 = (a2 - 1);
    v11[1] = 1;
  }
  else
  {
    uint64_t v12 = sub_100725CC0();
    uint64_t v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v12 - 8) + 56);
    uint64_t v14 = v12;
    uint64_t v15 = a1 + *(int *)(a4 + 56);
    return v13(v15, a2, a2, v14);
  }
  return result;
}

uint64_t sub_10044BD50()
{
  uint64_t result = type metadata accessor for IDSGroupEncryptionKeyMaterialController.KeyState(319);
  if (v1 <= 0x3F)
  {
    uint64_t result = sub_100725CC0();
    if (v2 <= 0x3F)
    {
      swift_initStructMetadata();
      return 0;
    }
  }
  return result;
}

void type metadata accessor for os_unfair_lock_s()
{
  if (!qword_100A45340)
  {
    unint64_t ForeignTypeMetadata = swift_getForeignTypeMetadata();
    if (!v1) {
      atomic_store(ForeignTypeMetadata, (unint64_t *)&qword_100A45340);
    }
  }
}

uint64_t sub_10044BEB8()
{
  return (*(uint64_t (**)(void))((swift_isaMask & **(void **)(v0 + 16)) + 0x1E8))();
}

uint64_t sub_10044BF1C()
{
  return _swift_deallocObject(v0, 24, 7);
}

void sub_10044BF54()
{
  uint64_t v1 = *(void *)(*(void *)(v0 + 16)
                 + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionKeyMaterialController_state);
  uint64_t v2 = v1 + *(void *)(class metadata base offset for ManagedBuffer + *(void *)v1 + 16);
  int v3 = (os_unfair_lock_s *)(v1 + ((*(unsigned int *)(*(void *)v1 + 48) + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v3);
  sub_10044C000(v2);
  os_unfair_lock_unlock(v3);
}

uint64_t sub_10044C000(uint64_t a1)
{
  int v3 = *(void **)(v1 + 16);
  uint64_t v4 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0);
  uint64_t v5 = *(int *)(v4 + 48);
  *(unsigned char *)(a1 + v5) = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t))((swift_isaMask & *v3) + 0x168))(a1);
  if ((*(unsigned char *)(a1 + v5) & 1) == 0)
  {
    uint64_t v7 = *(int *)(v4 + 52);
    uint64_t v8 = *(void *)(a1 + v7);
    *(void *)(a1 + v7) = &_swiftEmptyArrayStorage;
    uint64_t v9 = *(void *)(v8 + 16);
    if (v9)
    {
      uint64_t v10 = v8 + 40;
      do
      {
        uint64_t v11 = *(void (**)(uint64_t))(v10 - 8);
        uint64_t v12 = swift_retain();
        v11(v12);
        swift_release();
        v10 += 16;
        --v9;
      }
      while (v9);
    }
    return swift_bridgeObjectRelease();
  }
  return result;
}

void *sub_10044C0F4(void *result, uint64_t a2)
{
  if ((*(_DWORD *)(*(void *)(a2 - 8) + 80) & 0x20000) != 0) {
    return (void *)(*result
  }
                    + ((*(_DWORD *)(*(void *)(a2 - 8) + 80) + 16) & ~(unint64_t)*(_DWORD *)(*(void *)(a2 - 8) + 80)));
  return result;
}

uint64_t sub_10044C138(uint64_t a1, unint64_t a2, char a3)
{
  if (a3) {
    return swift_errorRetain();
  }
  else {
    return sub_100441FD4(a1, a2);
  }
}

uint64_t sub_10044C144(uint64_t a1, unint64_t a2, char a3)
{
  if (a3) {
    return swift_errorRelease();
  }
  else {
    return sub_100442248(a1, a2);
  }
}

uint64_t sub_10044C150(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = sub_100431F80(a2);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v3 - 8) + 8))(a1, v3);
  return a1;
}

uint64_t sub_10044C1AC(unint64_t *a1, void (*a2)(uint64_t))
{
  uint64_t result = *a1;
  if (!result)
  {
    a2(255);
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

void sub_10044C1F4()
{
  if (v0[2])
  {
    uint64_t v2 = v0[3];
    uint64_t v1 = v0[4];
    uint64_t ObjectType = swift_getObjectType();
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v2 + 24))(v1, ObjectType, v2);
  }
}

uint64_t sub_10044C250()
{
  swift_unknownObjectWeakDestroy();

  return _swift_deallocObject(v0, 24, 7);
}

void sub_10044C288()
{
}

uint64_t sub_10044C290(uint64_t a1)
{
  uint64_t v3 = *(void **)(v1 + 16);
  uint64_t v4 = *(int *)(type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0) + 44);
  swift_release();
  *(void *)(a1 + v4) = 0;
  return (*(uint64_t (**)(uint64_t))((swift_isaMask & *v3) + 0x168))(a1);
}

uint64_t sub_10044C328()
{
  uint64_t v1 = sub_100431F80(&qword_100A470D0);
  uint64_t v2 = *(void *)(v1 - 8);
  uint64_t v3 = *(unsigned __int8 *)(v2 + 80);
  uint64_t v4 = (v3 + 16) & ~v3;
  uint64_t v5 = v4 + *(void *)(v2 + 64);
  uint64_t v6 = v3 | 7;
  (*(void (**)(uint64_t, uint64_t))(v2 + 8))(v0 + v4, v1);

  return _swift_deallocObject(v0, v5, v6);
}

uint64_t sub_10044C3BC()
{
  return sub_1007265E0();
}

uint64_t sub_10044C424(uint64_t a1)
{
  uint64_t v4 = *(uint64_t (**)(void))(v1 + 16);
  uint64_t v3 = *(void *)(v1 + 24);
  uint64_t v5 = type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0);
  if (*(unsigned char *)(a1 + *(int *)(v5 + 48)) != 1) {
    return v4();
  }
  uint64_t v6 = v5;
  uint64_t v7 = swift_allocObject();
  *(void *)(v7 + 16) = v4;
  *(void *)(v7 + 24) = v3;
  uint64_t v8 = *(int *)(v6 + 52);
  uint64_t v9 = *(void *)(a1 + v8);
  swift_retain();
  uint64_t result = swift_isUniquelyReferenced_nonNull_native();
  if ((result & 1) == 0)
  {
    uint64_t result = (uint64_t)sub_10043E468(0, *(void *)(v9 + 16) + 1, 1, (char *)v9);
    uint64_t v9 = result;
  }
  unint64_t v12 = *(void *)(v9 + 16);
  unint64_t v11 = *(void *)(v9 + 24);
  if (v12 >= v11 >> 1)
  {
    uint64_t result = (uint64_t)sub_10043E468((char *)(v11 > 1), v12 + 1, 1, (char *)v9);
    uint64_t v9 = result;
  }
  *(void *)(v9 + 16) = v12 + 1;
  unint64_t v13 = v9 + 16 * v12;
  *(void *)(v13 + 32) = sub_10044C574;
  *(void *)(v13 + 40) = v7;
  *(void *)(a1 + v_Block_object_dispose(&STACK[0x320], 8) = v9;
  return result;
}

uint64_t sub_10044C53C()
{
  swift_release();

  return _swift_deallocObject(v0, 32, 7);
}

uint64_t sub_10044C574()
{
  return (*(uint64_t (**)(void))(v0 + 16))();
}

uint64_t sub_10044C59C(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else if ((v4 & 0x8000000000000000) == 0)
  {
    unint64_t v5 = a4 + 16 * a1 + 32;
    unint64_t v6 = a3 + 16 * v4;
    if (v5 >= v6 || v5 + 16 * v4 <= a3)
    {
      sub_100431F80(&qword_100A44D40);
      swift_arrayInitWithCopy();
      return v6;
    }
  }
  uint64_t result = sub_100726BF0();
  __break(1u);
  return result;
}

uint64_t sub_10044C6AC(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 24) - 8);
  if ((*(unsigned char *)(v1 + 82) & 2) != 0) {
    return swift_release();
  }
  else {
    return (*(uint64_t (**)(void))(v1 + 8))();
  }
}

uint64_t sub_10044C6FC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  *(void *)(a2 + 24) = v3;
  (**(void (***)(uint64_t, uint64_t))(v3 - 8))(a2, a1);
  return a2;
}

uint64_t sub_10044C758(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 24);
  uint64_t v4 = *(void *)(v1 + 32);
  uint64_t v5 = *(void *)(v1 + 40);
  char v6 = *(unsigned char *)(v1 + 48);
  char v7 = *(unsigned char *)(v1 + 49);
  uint64_t v8 = (int *)type metadata accessor for IDSGroupEncryptionKeyMaterialController.State(0);
  *(void *)(a1 + v8[7] + _Block_object_dispose(&STACK[0x320], 8) = v3;
  uint64_t result = swift_unknownObjectWeakAssign();
  uint64_t v10 = a1 + v8[5];
  *(void *)uint64_t v10 = v4;
  *(void *)(v10 + _Block_object_dispose(&STACK[0x320], 8) = v5;
  *(unsigned char *)(v10 + 16) = v6;
  *(unsigned char *)(a1 + v8[6]) = v7;
  return result;
}

uint64_t sub_10044C800(uint64_t a1)
{
  return sub_100440928(a1);
}

void type metadata accessor for SecKey()
{
  if (!qword_100A47B70)
  {
    unint64_t ForeignTypeMetadata = swift_getForeignTypeMetadata();
    if (!v1) {
      atomic_store(ForeignTypeMetadata, (unint64_t *)&qword_100A47B70);
    }
  }
}

uint64_t sub_10044C8A8()
{
  v1._countAndFlagsBits = 0x7469746E6564493CLL;
  v1._xpc_object_t object = (void *)0xEB00000000203A79;
  sub_1007264C0(v1);
  type metadata accessor for SecKey();
  sub_100726A90();
  v2._countAndFlagsBits = 62;
  v2._xpc_object_t object = (void *)0xE100000000000000;
  sub_1007264C0(v2);
  return 0;
}

void *initializeBufferWithCopyOfBuffer for IDSGlobalLinkP2PKeyNegotiationLocalIdentity(void *a1, uint64_t a2)
{
  uint64_t v3 = *(void **)a2;
  uint64_t v4 = *(void **)(a2 + 8);
  *a1 = *(void *)a2;
  a1[1] = v4;
  id v5 = v3;
  id v6 = v4;
  return a1;
}

void destroy for IDSGlobalLinkP2PKeyNegotiationLocalIdentity(uint64_t a1)
{
  Swift::String v2 = *(void **)(a1 + 8);
}

uint64_t assignWithCopy for IDSGlobalLinkP2PKeyNegotiationLocalIdentity(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)a2;
  id v5 = *(void **)a1;
  *(void *)a1 = *(void *)a2;
  id v6 = v4;

  char v7 = *(void **)(a2 + 8);
  uint64_t v8 = *(void **)(a1 + 8);
  *(void *)(a1 + _Block_object_dispose(&STACK[0x320], 8) = v7;
  id v9 = v7;

  return a1;
}

__n128 initializeWithTake for IDSGlobalLinkP2PKeyNegotiationLocalIdentity(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

uint64_t assignWithTake for IDSGlobalLinkP2PKeyNegotiationLocalIdentity(uint64_t a1, _OWORD *a2)
{
  uint64_t v4 = *(void **)(a1 + 8);
  *(_OWORD *)a1 = *a2;

  return a1;
}

uint64_t getEnumTagSinglePayload for IDSGlobalLinkP2PKeyNegotiationLocalIdentity(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *((unsigned char *)a1 + 16)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for IDSGlobalLinkP2PKeyNegotiationLocalIdentity(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)__n128 result = a2 ^ 0x80000000;
    *(void *)(result + _Block_object_dispose(&STACK[0x320], 8) = 0;
    if (a3 < 0) {
      *(unsigned char *)(result + 16) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)__n128 result = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 16) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for IDSGlobalLinkP2PKeyNegotiationLocalIdentity()
{
  return &type metadata for IDSGlobalLinkP2PKeyNegotiationLocalIdentity;
}

uint64_t sub_10044CAE8()
{
  return 1;
}

uint64_t sub_10044CAF0(uint64_t a1, char a2)
{
  if (!a1) {
    return 0;
  }
  uint64_t v4 = self;
  id v13 = 0;
  swift_unknownObjectRetain();
  id v5 = [v4 archivedDataWithRootObject:a1 requiringSecureCoding:a2 & 1 error:&v13];
  id v6 = v13;
  if (!v5)
  {
    uint64_t v8 = v6;
    sub_100725A20();

    swift_willThrow();
    sub_100431F80(&qword_100A44D50);
    uint64_t v9 = swift_allocObject();
    *(_OWORD *)(v9 + 16) = xmmword_100794E30;
    id v13 = 0;
    unint64_t v14 = 0xE000000000000000;
    sub_1007269F0(19);
    v15._xpc_object_t object = (void *)0x80000001008C0D80;
    v15._countAndFlagsBits = 0xD000000000000011;
    sub_1007264C0(v15);
    sub_100431F80(&qword_100A46DA0);
    sub_100726A90();
    id v10 = v13;
    unint64_t v11 = v14;
    *(void *)(v9 + 56) = &type metadata for String;
    *(void *)(v9 + 32) = v10;
    *(void *)(v9 + 40) = v11;
    sub_100726DB0();
    swift_bridgeObjectRelease();
    swift_errorRelease();
    swift_unknownObjectRelease();
    return 0;
  }
  uint64_t v7 = sub_100725B50();

  swift_unknownObjectRelease();
  return v7;
}

uint64_t sub_10044CCC4(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = 0;
  if (a3 >> 60 != 15)
  {
    sub_10044CE48();
    sub_100441FD4(a2, a3);
    uint64_t v3 = sub_1007266F0();
    sub_10044CE88(a2, a3);
  }
  return v3;
}

unint64_t sub_10044CE48()
{
  unint64_t result = qword_100A44D58;
  if (!qword_100A44D58)
  {
    self;
    unint64_t result = swift_getObjCClassMetadata();
    atomic_store(result, (unint64_t *)&qword_100A44D58);
  }
  return result;
}

uint64_t sub_10044CE88(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60 != 15) {
    return sub_100442248(a1, a2);
  }
  return a1;
}

uint64_t sub_10044CE9C()
{
  return swift_deallocClassInstance();
}

uint64_t sub_10044CEAC()
{
  return swift_allocObject();
}

uint64_t sub_10044CEBC()
{
  uint64_t v0 = sub_1007260B0();
  uint64_t v27 = *(void *)(v0 - 8);
  __chkstk_darwin(v0, v1);
  uint64_t v3 = (char *)&v24 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v4 = sub_100725FE0();
  uint64_t v29 = *(void *)(v4 - 8);
  __chkstk_darwin(v4, v5);
  uint64_t v28 = (char *)&v24 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = sub_100726470();
  uint64_t v8 = *(void *)(v7 - 8);
  __chkstk_darwin(v7, v9);
  unint64_t v11 = (char *)&v24 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_100726460();
  uint64_t v12 = sub_100726440();
  unint64_t v14 = v13;
  (*(void (**)(char *, uint64_t))(v8 + 8))(v11, v7);
  if (v14 >> 60 == 15) {
LABEL_12:
  }
    __break(1u);
  long long v34 = xmmword_100794E40;
  sub_100725B70();
  sub_100725B70();
  unint64_t v16 = *((void *)&v34 + 1);
  uint64_t v15 = v34;
  sub_100441FD4(v34, *((unint64_t *)&v34 + 1));
  sub_10044D57C((unint64_t *)&qword_100A44D60, (void (*)(uint64_t))&type metadata accessor for SHA256);
  sub_100725FD0();
  unint64_t v25 = v14;
  uint64_t v26 = v12;
  switch(v16 >> 62)
  {
    case 1uLL:
      if (v15 >> 32 < (int)v15)
      {
        __break(1u);
        goto LABEL_12;
      }
      sub_100441FD4(v15, v16);
      sub_10044D49C((int)v15, v15 >> 32);
LABEL_7:
      sub_100442248(v15, v16);
LABEL_10:
      uint64_t v19 = v28;
      sub_100725FC0();
      (*(void (**)(char *, uint64_t))(v27 + 8))(v3, v0);
      uint64_t v32 = v4;
      uint64_t v33 = sub_10044D57C(&qword_100A47BA0, (void (*)(uint64_t))&type metadata accessor for SHA256Digest);
      uint64_t v20 = sub_10044D5C4(v31);
      uint64_t v21 = v29;
      (*(void (**)(uint64_t *, char *, uint64_t))(v29 + 16))(v20, v19, v4);
      sub_10044C0F4(v31, v32);
      sub_100725960();
      uint64_t v22 = v30;
      sub_10044C6AC((uint64_t)v31);
      (*(void (**)(char *, uint64_t))(v21 + 8))(v19, v4);
      sub_100442248(v15, v16);
      sub_10044CE88(v26, v25);
      sub_100442248(v34, *((unint64_t *)&v34 + 1));
      return v22;
    case 2uLL:
      uint64_t v17 = *(void *)(v15 + 16);
      uint64_t v18 = *(void *)(v15 + 24);
      sub_100441FD4(v15, v16);
      swift_retain();
      swift_retain();
      sub_10044D49C(v17, v18);
      swift_release();
      swift_release();
      goto LABEL_7;
    case 3uLL:
      memset(v31, 0, 14);
      goto LABEL_9;
    default:
      v31[0] = v15;
      LOWORD(v31[1]) = v16;
      BYTE2(v31[1]) = BYTE2(v16);
      BYTE3(v31[1]) = BYTE3(v16);
      BYTE4(v31[1]) = BYTE4(v16);
      BYTE5(v31[1]) = BYTE5(v16);
LABEL_9:
      sub_100725FB0();
      sub_100442248(v15, v16);
      goto LABEL_10;
  }
}

unsigned char *sub_10044D424@<X0>(unsigned char *result@<X0>, unsigned char *a2@<X1>, void *a3@<X8>)
{
  if (!result) {
    goto LABEL_4;
  }
  uint64_t v4 = a2 - result;
  if (a2 == result)
  {
    unint64_t result = 0;
LABEL_4:
    unint64_t v5 = 0xC000000000000000;
    goto LABEL_5;
  }
  if (v4 <= 14)
  {
    unint64_t result = (unsigned char *)sub_10044D6EC(result, a2);
    unint64_t v5 = v7 & 0xFFFFFFFFFFFFFFLL;
  }
  else if ((unint64_t)v4 >= 0x7FFFFFFF)
  {
    unint64_t result = (unsigned char *)sub_10044D7B0((uint64_t)result, (uint64_t)a2);
    unint64_t v5 = v8 | 0x8000000000000000;
  }
  else
  {
    unint64_t result = (unsigned char *)sub_10044D82C((uint64_t)result, (uint64_t)a2);
    unint64_t v5 = v6 | 0x4000000000000000;
  }
LABEL_5:
  *a3 = result;
  a3[1] = v5;
  return result;
}

uint64_t sub_10044D49C(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100725910();
  if (!result || (uint64_t result = sub_100725940(), !__OFSUB__(a1, result)))
  {
    if (!__OFSUB__(a2, a1))
    {
      sub_100725930();
      sub_1007260B0();
      sub_10044D57C((unint64_t *)&qword_100A44D60, (void (*)(uint64_t))&type metadata accessor for SHA256);
      return sub_100725FB0();
    }
    __break(1u);
  }
  __break(1u);
  return result;
}

uint64_t sub_10044D57C(unint64_t *a1, void (*a2)(uint64_t))
{
  uint64_t result = *a1;
  if (!result)
  {
    a2(255);
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

uint64_t *sub_10044D5C4(uint64_t *a1)
{
  uint64_t v1 = a1;
  if ((*(unsigned char *)(*(void *)(a1[3] - 8) + 82) & 2) != 0)
  {
    *a1 = swift_allocBox();
    return (uint64_t *)v2;
  }
  return v1;
}

uint64_t sub_10044D628(uint64_t result)
{
  if (result)
  {
    unint64_t v1 = result;
    if (result <= 14)
    {
      if (result < 0) {
        __break(1u);
      }
      else {
        return 0;
      }
    }
    else
    {
      sub_100725950();
      swift_allocObject();
      sub_100725920();
      if (v1 >= 0x7FFFFFFF)
      {
        sub_100725AD0();
        uint64_t result = swift_allocObject();
        *(void *)(result + 16) = 0;
        *(void *)(result + 24) = v1;
      }
      else
      {
        return v1 << 32;
      }
    }
  }
  return result;
}

uint64_t type metadata accessor for ArchiveHelper()
{
  return self;
}

uint64_t sub_10044D6EC(unsigned char *__src, unsigned char *a2)
{
  if (__src) {
    unint64_t v2 = a2 - __src;
  }
  else {
    unint64_t v2 = 0;
  }
  if ((v2 & 0x8000000000000000) != 0)
  {
    __break(1u);
LABEL_11:
    __break(1u);
  }
  if (v2 > 0xFF) {
    goto LABEL_11;
  }
  memset(__dst, 0, sizeof(__dst));
  char v5 = v2;
  if (__src && a2 != __src) {
    memcpy(__dst, __src, a2 - __src);
  }
  return *(void *)__dst;
}

uint64_t sub_10044D7B0(uint64_t a1, uint64_t a2)
{
  if (a1) {
    uint64_t v2 = a2 - a1;
  }
  else {
    uint64_t v2 = 0;
  }
  sub_100725950();
  swift_allocObject();
  uint64_t result = sub_100725900();
  if (v2 < 0)
  {
    __break(1u);
  }
  else
  {
    sub_100725AD0();
    uint64_t result = swift_allocObject();
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = v2;
  }
  return result;
}

uint64_t sub_10044D82C(uint64_t a1, uint64_t a2)
{
  if (a1) {
    uint64_t v2 = a2 - a1;
  }
  else {
    uint64_t v2 = 0;
  }
  sub_100725950();
  swift_allocObject();
  uint64_t result = sub_100725900();
  if (v2 < (uint64_t)0xFFFFFFFF80000000)
  {
    __break(1u);
    goto LABEL_9;
  }
  if (v2 > 0x7FFFFFFF)
  {
LABEL_9:
    __break(1u);
    goto LABEL_10;
  }
  if ((v2 & 0x80000000) == 0) {
    return v2 << 32;
  }
LABEL_10:
  __break(1u);
  return result;
}

void sub_10044D8B0()
{
  *(_WORD *)&algn_100A53248[6] = -4864;
}

void sub_10044D908()
{
  *(_WORD *)&algn_100A53258[6] = -4864;
}

void sub_10044D960()
{
  qword_100A53260 = 0x646F6D2D70617277;
  *(void *)algn_100A53268 = 0xE900000000000065;
}

id sub_10044D9B0(uint64_t a1, uint64_t a2, void *a3)
{
  if (*a3 != -1) {
    swift_once();
  }
  swift_bridgeObjectRetain();
  NSString v3 = sub_100726420();
  swift_bridgeObjectRelease();

  return v3;
}

uint64_t type metadata accessor for IDSGroupEncryptionPreKeyDictionaryKeys()
{
  return self;
}

id sub_10044DA90()
{
  v2.receiver = v0;
  v2.super_class = (Class)type metadata accessor for IDSGroupEncryptionPreKeyDictionaryKeys();
  return objc_msgSendSuper2(&v2, "dealloc");
}

uint64_t type metadata accessor for IDSGroupEncryptionDesiredPreKeyMaterialSet()
{
  uint64_t result = qword_100A4CF00;
  if (!qword_100A4CF00) {
    return swift_getSingletonMetadata();
  }
  return result;
}

uint64_t sub_10044DB14()
{
  uint64_t v0 = sub_100725ED0();
  sub_10045091C(v0, qword_100A53270);
  sub_10044DB64(v0, (uint64_t)qword_100A53270);
  return sub_1004DFE9C(2);
}

uint64_t sub_10044DB64(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned char *)(*(void *)(a1 - 8) + 82) & 2) != 0) {
    return *(void *)a2;
  }
  return a2;
}

uint64_t sub_10044DB9C()
{
  sub_1007269F0(62);
  v1._xpc_object_t object = (void *)0x80000001008C0DF0;
  v1._countAndFlagsBits = 0xD00000000000003BLL;
  sub_1007264C0(v1);
  type metadata accessor for IDSGroupEncryptionDesiredPreKeyMaterialSet();
  type metadata accessor for IDSGroupEncryptionPublicIdentity(0);
  sub_10044F9FC(&qword_100A44E00, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionPublicIdentity);
  v2._countAndFlagsBits = sub_100726D00();
  sub_1007264C0(v2);
  swift_bridgeObjectRelease();
  v3._countAndFlagsBits = 62;
  v3._xpc_object_t object = (void *)0xE100000000000000;
  sub_1007264C0(v3);
  return 0;
}

void *sub_10044DC84()
{
  uint64_t v1 = type metadata accessor for IDSGroupEncryptionDesiredPreKeyMaterialSet();
  uint64_t v3 = __chkstk_darwin(v1, v2);
  uint64_t v72 = (uint64_t)&v70 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = __chkstk_darwin(v3, v5);
  uint64_t v8 = (char *)&v70 - v7;
  uint64_t v10 = __chkstk_darwin(v6, v9);
  uint64_t v71 = (uint64_t)&v70 - v11;
  __chkstk_darwin(v10, v12);
  uint64_t v77 = (uint8_t *)&v70 - v13;
  uint64_t v81 = sub_100725ED0();
  uint64_t v79 = *(void *)(v81 - 8);
  uint64_t v15 = __chkstk_darwin(v81, v14);
  uint64_t v17 = (char *)&v70 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v15, v18);
  uint64_t v73 = (char *)&v70 - v19;
  uint64_t v74 = (uint8_t *)type metadata accessor for IDSGroupEncryptionMaterialData();
  uint64_t v21 = __chkstk_darwin(v74, v20);
  uint64_t v23 = (uint64_t *)((char *)&v70 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0));
  __chkstk_darwin(v21, v24);
  uint64_t v75 = (uint64_t)&v70 - v25;
  uint64_t v26 = sub_100725CC0();
  uint64_t v27 = *(void *)(v26 - 8);
  __chkstk_darwin(v26, v28);
  uint64_t v30 = (char *)&v70 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0);
  unint64_t v85 = &_swiftEmptySetSingleton;
  unint64_t v76 = v1;
  uint64_t v31 = *(int *)(v1 + 20);
  uint64_t v78 = v0;
  uint64_t v32 = v0 + v31;
  uint64_t v80 = sub_1005353E4();
  if (v33 >> 60 == 15)
  {
    if (qword_100A4CCF8 != -1) {
      swift_once();
    }
    uint64_t v34 = v81;
    uint64_t v35 = sub_10044DB64(v81, (uint64_t)qword_100A53270);
    uint64_t v36 = v79;
    (*(void (**)(char *, uint64_t, uint64_t))(v79 + 16))(v17, v35, v34);
    sub_10044F994(v78, (uint64_t)v8, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredPreKeyMaterialSet);
    char v37 = sub_100725EB0();
    os_log_type_t v38 = sub_1007266E0();
    int v39 = v38;
    if (os_log_type_enabled(v37, v38))
    {
      LODWORD(v80) = v39;
      uint64_t v40 = (uint8_t *)swift_slowAlloc();
      uint64_t v78 = swift_slowAlloc();
      uint64_t v84 = v78;
      uint64_t v77 = v40;
      *(_DWORD *)uint64_t v40 = 136315138;
      uint64_t v41 = v72;
      sub_10044F994((uint64_t)v8, v72, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredPreKeyMaterialSet);
      uint64_t v82 = 0;
      unint64_t v83 = 0xE000000000000000;
      sub_1007269F0(62);
      v86._xpc_object_t object = (void *)0x80000001008C0DF0;
      v86._countAndFlagsBits = 0xD00000000000003BLL;
      sub_1007264C0(v86);
      type metadata accessor for IDSGroupEncryptionPublicIdentity(0);
      sub_10044F9FC(&qword_100A44E00, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionPublicIdentity);
      v87._countAndFlagsBits = sub_100726D00();
      sub_1007264C0(v87);
      swift_bridgeObjectRelease();
      v88._countAndFlagsBits = 62;
      v88._xpc_object_t object = (void *)0xE100000000000000;
      sub_1007264C0(v88);
      uint64_t v42 = v82;
      unint64_t v43 = v83;
      sub_10044F0CC(v41, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredPreKeyMaterialSet);
      uint64_t v82 = sub_10043E578(v42, v43, &v84);
      sub_100726830();
      swift_bridgeObjectRelease();
      sub_10044F0CC((uint64_t)v8, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredPreKeyMaterialSet);
      _os_log_impl((void *)&_mh_execute_header, v37, (os_log_type_t)v80, "%s.materialData: no public identity data", v77, 0xCu);
      swift_arrayDestroy();
      swift_slowDealloc();
      swift_slowDealloc();

      (*(void (**)(char *, uint64_t))(v79 + 8))(v17, v81);
    }
    else
    {
      sub_10044F0CC((uint64_t)v8, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredPreKeyMaterialSet);

      (*(void (**)(char *, uint64_t))(v36 + 8))(v17, v34);
    }
  }
  else
  {
    unint64_t v44 = v33;
    sub_100431F80((uint64_t *)&unk_100A45610);
    uint64_t inited = swift_initStackObject();
    *(_OWORD *)(inited + 16) = xmmword_100794E70;
    if (qword_100A4CCE0 != -1) {
      swift_once();
    }
    uint64_t v82 = qword_100A53240;
    unint64_t v83 = *(void *)algn_100A53248;
    swift_bridgeObjectRetain();
    sub_1007269A0();
    *(void *)(inited + 96) = &type metadata for Data;
    uint64_t v46 = (uint64_t)v80;
    *(void *)(inited + 72) = v80;
    *(void *)(inited + 80) = v44;
    sub_100441FD4(v46, v44);
    if (qword_100A4CCE8 != -1) {
      swift_once();
    }
    uint64_t v82 = qword_100A53250;
    unint64_t v83 = *(void *)algn_100A53258;
    swift_bridgeObjectRetain();
    sub_1007269A0();
    sub_100725CB0();
    sub_100725C50();
    uint64_t v48 = v47;
    (*(void (**)(char *, uint64_t))(v27 + 8))(v30, v26);
    *(void *)(inited + 16_Block_object_dispose(&STACK[0x320], 8) = &type metadata for Double;
    *(void *)(inited + 144) = v48;
    if (qword_100A4CCF0 != -1) {
      swift_once();
    }
    uint64_t v82 = qword_100A53260;
    unint64_t v83 = *(void *)algn_100A53268;
    swift_bridgeObjectRetain();
    sub_1007269A0();
    uint64_t v49 = type metadata accessor for IDSGroupEncryptionPublicIdentity(0);
    uint64_t v50 = sub_1005350E0(*(unsigned char *)(v32 + *(int *)(v49 + 32)));
    *(void *)(inited + 240) = &type metadata for Int;
    *(void *)(inited + 216) = v50;
    sub_10044E7C0(inited);
    Class isa = sub_100726380().super.isa;
    swift_bridgeObjectRelease();
    id v52 = (id)JWEncodeDictionary();

    uint64_t v53 = v77;
    if (v52)
    {
      uint64_t v54 = sub_100725B50();
      uint64_t v56 = v55;

      *uint64_t v23 = v54;
      v23[1] = v56;
      swift_storeEnumTagMultiPayload();
      uint64_t v57 = v75;
      sub_10044EDC8(v75, (uint64_t)v23);
      sub_10044CE88((uint64_t)v80, v44);
      sub_10044F0CC(v57, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionMaterialData);
    }
    else
    {
      if (qword_100A4CCF8 != -1) {
        swift_once();
      }
      uint64_t v58 = v81;
      uint64_t v59 = sub_10044DB64(v81, (uint64_t)qword_100A53270);
      uint64_t v60 = v79;
      uint64_t v61 = v73;
      (*(void (**)(char *, uint64_t, uint64_t))(v79 + 16))(v73, v59, v58);
      sub_10044F994(v78, (uint64_t)v53, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredPreKeyMaterialSet);
      uint64_t v62 = sub_100725EB0();
      os_log_type_t v63 = sub_1007266E0();
      int v64 = v63;
      if (os_log_type_enabled(v62, v63))
      {
        LODWORD(v7_Block_object_dispose(&STACK[0x320], 8) = v64;
        uint64_t v65 = (uint8_t *)swift_slowAlloc();
        uint64_t v75 = swift_slowAlloc();
        uint64_t v84 = v75;
        uint64_t v74 = v65;
        *(_DWORD *)uint64_t v65 = 136315138;
        uint64_t v66 = v71;
        sub_10044F994((uint64_t)v53, v71, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredPreKeyMaterialSet);
        uint64_t v82 = 0;
        unint64_t v83 = 0xE000000000000000;
        sub_1007269F0(62);
        v89._xpc_object_t object = (void *)0x80000001008C0DF0;
        v89._countAndFlagsBits = 0xD00000000000003BLL;
        sub_1007264C0(v89);
        sub_10044F9FC(&qword_100A44E00, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionPublicIdentity);
        v90._countAndFlagsBits = sub_100726D00();
        sub_1007264C0(v90);
        swift_bridgeObjectRelease();
        v91._countAndFlagsBits = 62;
        v91._xpc_object_t object = (void *)0xE100000000000000;
        sub_1007264C0(v91);
        unint64_t v76 = v44;
        uint64_t v67 = v82;
        unint64_t v68 = v83;
        sub_10044F0CC(v66, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredPreKeyMaterialSet);
        uint64_t v82 = sub_10043E578(v67, v68, &v84);
        sub_100726830();
        swift_bridgeObjectRelease();
        sub_10044F0CC((uint64_t)v53, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredPreKeyMaterialSet);
        _os_log_impl((void *)&_mh_execute_header, v62, (os_log_type_t)v78, "%s.materialData: could not encode dictionary", v74, 0xCu);
        swift_arrayDestroy();
        swift_slowDealloc();
        swift_slowDealloc();

        sub_10044CE88((uint64_t)v80, v76);
        (*(void (**)(char *, uint64_t))(v60 + 8))(v73, v81);
      }
      else
      {
        sub_10044CE88((uint64_t)v80, v44);
        sub_10044F0CC((uint64_t)v53, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredPreKeyMaterialSet);

        (*(void (**)(char *, uint64_t))(v60 + 8))(v61, v58);
      }
    }
  }
  return v85;
}

unint64_t sub_10044E7C0(uint64_t a1)
{
  if (!*(void *)(a1 + 16))
  {
    uint64_t v3 = &_swiftEmptyDictionarySingleton;
    goto LABEL_9;
  }
  sub_100431F80(&qword_100A45620);
  uint64_t v2 = sub_100726BE0();
  uint64_t v3 = (void *)v2;
  uint64_t v4 = *(void *)(a1 + 16);
  if (!v4)
  {
LABEL_9:
    swift_bridgeObjectRelease();
    return (unint64_t)v3;
  }
  uint64_t v5 = v2 + 64;
  uint64_t v6 = a1 + 32;
  swift_retain();
  while (1)
  {
    sub_10045072C(v6, (uint64_t)v15);
    unint64_t result = sub_10044ED84((uint64_t)v15);
    if (v8) {
      break;
    }
    *(void *)(v5 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << result;
    uint64_t v9 = v3[6] + 40 * result;
    long long v10 = v15[0];
    long long v11 = v15[1];
    *(void *)(v9 + 32) = v16;
    *(_OWORD *)uint64_t v9 = v10;
    *(_OWORD *)(v9 + 16) = v11;
    unint64_t result = (unint64_t)sub_100450794(&v17, (_OWORD *)(v3[7] + 32 * result));
    uint64_t v12 = v3[2];
    BOOL v13 = __OFADD__(v12, 1);
    uint64_t v14 = v12 + 1;
    if (v13) {
      goto LABEL_11;
    }
    v3[2] = v14;
    v6 += 72;
    if (!--v4)
    {
      swift_release();
      goto LABEL_9;
    }
  }
  __break(1u);
LABEL_11:
  __break(1u);
  return result;
}

uint64_t sub_10044E8F0(unsigned int *a1, unsigned int *a2)
{
  if (!sub_100512630(*a1 | ((unint64_t)*((unsigned __int8 *)a1 + 4) << 32), *a2 | ((unint64_t)*((unsigned __int8 *)a2 + 4) << 32)))return 0; {
  uint64_t v4 = *(int *)(type metadata accessor for IDSGroupEncryptionDesiredPreKeyMaterialSet() + 20);
  }

  return sub_1005351F4((char *)a1 + v4, (char *)a2 + v4);
}

uint64_t sub_10044E968@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)a2 = 0;
  *(unsigned char *)(a2 + 4) = 3;
  uint64_t v4 = type metadata accessor for IDSGroupEncryptionDesiredPreKeyMaterialSet();
  return sub_1004500C4(a1, a2 + *(int *)(v4 + 20), type metadata accessor for IDSGroupEncryptionPublicIdentity);
}

uint64_t sub_10044E9C8()
{
  sub_1007269F0(62);
  v1._xpc_object_t object = (void *)0x80000001008C0DF0;
  v1._countAndFlagsBits = 0xD00000000000003BLL;
  sub_1007264C0(v1);
  type metadata accessor for IDSGroupEncryptionPublicIdentity(0);
  sub_10044F9FC(&qword_100A44E00, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionPublicIdentity);
  v2._countAndFlagsBits = sub_100726D00();
  sub_1007264C0(v2);
  swift_bridgeObjectRelease();
  v3._countAndFlagsBits = 62;
  v3._xpc_object_t object = (void *)0xE100000000000000;
  sub_1007264C0(v3);
  return 0;
}

Swift::Int sub_10044EAB4()
{
  return sub_100726E30();
}

uint64_t sub_10044EB80()
{
  return sub_1007263E0();
}

Swift::Int sub_10044EC3C()
{
  return sub_100726E30();
}

uint64_t sub_10044ED04(unsigned int *a1, unsigned int *a2, uint64_t a3)
{
  if (!sub_100512630(*a1 | ((unint64_t)*((unsigned __int8 *)a1 + 4) << 32), *a2 | ((unint64_t)*((unsigned __int8 *)a2 + 4) << 32)))return 0; {
  uint64_t v6 = *(int *)(a3 + 20);
  }

  return sub_1005351F4((char *)a1 + v6, (char *)a2 + v6);
}

unint64_t sub_10044ED84(uint64_t a1)
{
  uint64_t v2 = v1;
  Swift::Int v4 = sub_100726980(*(void *)(v2 + 40));

  return sub_1004507A4(a1, v4);
}

uint64_t sub_10044EDC8(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = type metadata accessor for IDSGroupEncryptionMaterialData();
  uint64_t v6 = *(void *)(v5 - 8);
  __chkstk_darwin(v5, v7);
  uint64_t v9 = (char *)&v21 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v23 = v2;
  uint64_t v10 = *v2;
  sub_10044F9FC(&qword_100A44ED0, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionMaterialData);
  swift_bridgeObjectRetain();
  uint64_t v11 = a2;
  uint64_t v12 = sub_1007263D0();
  uint64_t v13 = -1 << *(unsigned char *)(v10 + 32);
  unint64_t v14 = v12 & ~v13;
  if ((*(void *)(v10 + 56 + ((v14 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v14))
  {
    uint64_t v22 = a1;
    uint64_t v15 = ~v13;
    uint64_t v16 = *(void *)(v6 + 72);
    while (1)
    {
      sub_10044F994(*(void *)(v10 + 48) + v16 * v14, (uint64_t)v9, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionMaterialData);
      sub_10044F9FC(&qword_100A44ED8, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionMaterialData);
      char v17 = sub_100726410();
      sub_10044F0CC((uint64_t)v9, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionMaterialData);
      if (v17) {
        break;
      }
      unint64_t v14 = (v14 + 1) & v15;
      if (((*(void *)(v10 + 56 + ((v14 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v14) & 1) == 0)
      {
        swift_bridgeObjectRelease();
        a1 = v22;
        goto LABEL_7;
      }
    }
    swift_bridgeObjectRelease();
    sub_10044F0CC(v11, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionMaterialData);
    sub_10044F994(*(void *)(*v23 + 48) + v16 * v14, v22, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionMaterialData);
    return 0;
  }
  else
  {
    swift_bridgeObjectRelease();
LABEL_7:
    uint64_t v18 = v23;
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
    sub_10044F994(v11, (uint64_t)v9, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionMaterialData);
    uint64_t v24 = *v18;
    *uint64_t v18 = 0x8000000000000000;
    sub_10044FE1C((uint64_t)v9, v14, isUniquelyReferenced_nonNull_native);
    *uint64_t v18 = v24;
    swift_bridgeObjectRelease();
    sub_1004500C4(v11, a1, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionMaterialData);
    return 1;
  }
}

uint64_t sub_10044F0CC(uint64_t a1, uint64_t (*a2)(void))
{
  uint64_t v3 = a2(0);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v3 - 8) + 8))(a1, v3);
  return a1;
}

unint64_t sub_10044F12C()
{
  unint64_t result = qword_100A44E08;
  if (!qword_100A44E08)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_100A44E08);
  }
  return result;
}

uint64_t sub_10044F180(uint64_t a1)
{
  uint64_t result = sub_10044F9FC(&qword_100A44E18, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionDesiredPreKeyMaterialSet);
  *(void *)(a1 + _Block_object_dispose(&STACK[0x320], 8) = result;
  return result;
}

uint64_t sub_10044F1D8()
{
  return sub_10044F9FC(&qword_100A44E20, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionDesiredPreKeyMaterialSet);
}

void *sub_10044F220(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = (void *)a1;
  int v4 = *(_DWORD *)(*(void *)(a3 - 8) + 80);
  if ((v4 & 0x20000) != 0)
  {
    uint64_t v20 = *a2;
    *uint64_t v3 = *a2;
    uint64_t v3 = (void *)(v20 + ((v4 + 16) & ~(unint64_t)v4));
    swift_retain();
  }
  else
  {
    *(_DWORD *)a1 = *(_DWORD *)a2;
    *(unsigned char *)(a1 + 4) = *((unsigned char *)a2 + 4);
    uint64_t v5 = *(int *)(a3 + 20);
    uint64_t v6 = (void *)(a1 + v5);
    uint64_t v7 = (uint64_t)a2 + v5;
    uint64_t v8 = *(void **)((char *)a2 + v5);
    uint64_t v9 = *(void **)((char *)a2 + v5 + 8);
    *uint64_t v6 = v8;
    v6[1] = v9;
    uint64_t v10 = (int *)type metadata accessor for IDSGroupEncryptionPublicIdentity(0);
    uint64_t v11 = v10[6];
    uint64_t v22 = (char *)v6 + v11;
    uint64_t v12 = v7 + v11;
    uint64_t v13 = sub_100725CC0();
    unint64_t v14 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(v13 - 8) + 16);
    id v15 = v8;
    id v16 = v9;
    v14(v22, v12, v13);
    uint64_t v17 = v10[7];
    uint64_t v18 = *(void **)(v7 + v17);
    *(void *)((char *)v6 + v17) = v18;
    *((unsigned char *)v6 + v10[8]) = *(unsigned char *)(v7 + v10[8]);
    id v19 = v18;
  }
  return v3;
}

void sub_10044F360(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (id *)(a1 + *(int *)(a2 + 20));

  uint64_t v3 = type metadata accessor for IDSGroupEncryptionPublicIdentity(0);
  int v4 = (char *)v2 + *(int *)(v3 + 24);
  uint64_t v5 = sub_100725CC0();
  (*(void (**)(char *, uint64_t))(*(void *)(v5 - 8) + 8))(v4, v5);
  uint64_t v6 = *(id *)((char *)v2 + *(int *)(v3 + 28));
}

uint64_t sub_10044F400(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(unsigned char *)(a1 + 4) = *(unsigned char *)(a2 + 4);
  uint64_t v4 = *(int *)(a3 + 20);
  uint64_t v5 = (void *)(a1 + v4);
  uint64_t v6 = a2 + v4;
  uint64_t v7 = *(void **)(a2 + v4);
  uint64_t v8 = *(void **)(a2 + v4 + 8);
  *uint64_t v5 = v7;
  v5[1] = v8;
  uint64_t v9 = (int *)type metadata accessor for IDSGroupEncryptionPublicIdentity(0);
  uint64_t v10 = v9[6];
  uint64_t v20 = (char *)v5 + v10;
  uint64_t v11 = v6 + v10;
  uint64_t v12 = sub_100725CC0();
  uint64_t v13 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(v12 - 8) + 16);
  id v14 = v7;
  id v15 = v8;
  v13(v20, v11, v12);
  uint64_t v16 = v9[7];
  uint64_t v17 = *(void **)(v6 + v16);
  *(void *)((char *)v5 + v16) = v17;
  *((unsigned char *)v5 + v9[8]) = *(unsigned char *)(v6 + v9[8]);
  id v18 = v17;
  return a1;
}

uint64_t sub_10044F4F0(uint64_t a1, int *a2, uint64_t a3)
{
  int v4 = *a2;
  *(unsigned char *)(a1 + 4) = *((unsigned char *)a2 + 4);
  *(_DWORD *)a1 = v4;
  uint64_t v5 = *(int *)(a3 + 20);
  uint64_t v6 = (void *)(a1 + v5);
  uint64_t v7 = (uint64_t)a2 + v5;
  uint64_t v8 = *(void **)(a1 + v5);
  uint64_t v9 = *(void **)((char *)a2 + v5);
  *uint64_t v6 = v9;
  id v10 = v9;

  uint64_t v11 = *(void **)(v7 + 8);
  uint64_t v12 = (void *)v6[1];
  v6[1] = v11;
  id v13 = v11;

  id v14 = (int *)type metadata accessor for IDSGroupEncryptionPublicIdentity(0);
  uint64_t v15 = v14[6];
  uint64_t v16 = (char *)v6 + v15;
  uint64_t v17 = v7 + v15;
  uint64_t v18 = sub_100725CC0();
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v18 - 8) + 24))(v16, v17, v18);
  uint64_t v19 = v14[7];
  uint64_t v20 = *(void **)(v7 + v19);
  uint64_t v21 = *(void **)((char *)v6 + v19);
  *(void *)((char *)v6 + v19) = v20;
  id v22 = v20;

  *((unsigned char *)v6 + v14[8]) = *(unsigned char *)(v7 + v14[8]);
  return a1;
}

uint64_t sub_10044F5E0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(unsigned char *)(a1 + 4) = *(unsigned char *)(a2 + 4);
  uint64_t v4 = *(int *)(a3 + 20);
  uint64_t v5 = a1 + v4;
  uint64_t v6 = a2 + v4;
  *(_OWORD *)(a1 + v4) = *(_OWORD *)(a2 + v4);
  uint64_t v7 = (int *)type metadata accessor for IDSGroupEncryptionPublicIdentity(0);
  uint64_t v8 = v7[6];
  uint64_t v9 = v5 + v8;
  uint64_t v10 = v6 + v8;
  uint64_t v11 = sub_100725CC0();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v11 - 8) + 32))(v9, v10, v11);
  *(void *)(v5 + v7[7]) = *(void *)(v6 + v7[7]);
  *(unsigned char *)(v5 + v7[8]) = *(unsigned char *)(v6 + v7[8]);
  return a1;
}

uint64_t sub_10044F6A4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(unsigned char *)(a1 + 4) = *(unsigned char *)(a2 + 4);
  uint64_t v4 = *(int *)(a3 + 20);
  uint64_t v5 = (void *)(a1 + v4);
  uint64_t v6 = (void *)(a2 + v4);
  uint64_t v7 = *(void **)(a1 + v4);
  *uint64_t v5 = *v6;

  uint64_t v8 = (void *)v5[1];
  v5[1] = v6[1];

  uint64_t v9 = (int *)type metadata accessor for IDSGroupEncryptionPublicIdentity(0);
  uint64_t v10 = v9[6];
  uint64_t v11 = (char *)v5 + v10;
  uint64_t v12 = (char *)v6 + v10;
  uint64_t v13 = sub_100725CC0();
  (*(void (**)(char *, char *, uint64_t))(*(void *)(v13 - 8) + 40))(v11, v12, v13);
  uint64_t v14 = v9[7];
  uint64_t v15 = *(void **)((char *)v5 + v14);
  *(void *)((char *)v5 + v14) = *(void *)((char *)v6 + v14);

  *((unsigned char *)v5 + v9[8]) = *((unsigned char *)v6 + v9[8]);
  return a1;
}

uint64_t sub_10044F788(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return _swift_getEnumTagSinglePayloadGeneric(a1, a2, a3, sub_10044F79C);
}

uint64_t sub_10044F79C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 == 252)
  {
    unsigned int v4 = *(unsigned __int8 *)(a1 + 4);
    if (v4 > 3) {
      return (v4 ^ 0xFF) + 1;
    }
    else {
      return 0;
    }
  }
  else
  {
    uint64_t v8 = type metadata accessor for IDSGroupEncryptionPublicIdentity(0);
    uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v8 - 8) + 48);
    uint64_t v10 = v8;
    uint64_t v11 = a1 + *(int *)(a3 + 20);
    return v9(v11, a2, v10);
  }
}

uint64_t sub_10044F844(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _swift_storeEnumTagSinglePayloadGeneric(a1, a2, a3, a4, sub_10044F858);
}

uint64_t sub_10044F858(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v5 = result;
  if (a3 == 252)
  {
    *(unsigned char *)(result + 4) = -(char)a2;
  }
  else
  {
    uint64_t v7 = type metadata accessor for IDSGroupEncryptionPublicIdentity(0);
    uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v7 - 8) + 56);
    uint64_t v9 = v7;
    uint64_t v10 = v5 + *(int *)(a4 + 20);
    return v8(v10, a2, a2, v9);
  }
  return result;
}

uint64_t sub_10044F8FC()
{
  uint64_t result = type metadata accessor for IDSGroupEncryptionPublicIdentity(319);
  if (v1 <= 0x3F)
  {
    swift_initStructMetadata();
    return 0;
  }
  return result;
}

uint64_t sub_10044F994(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a3(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16))(a2, a1, v5);
  return a2;
}

uint64_t sub_10044F9FC(unint64_t *a1, void (*a2)(uint64_t))
{
  uint64_t result = *a1;
  if (!result)
  {
    a2(255);
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

uint64_t sub_10044FA44()
{
  unint64_t v1 = v0;
  uint64_t v2 = type metadata accessor for IDSGroupEncryptionMaterialData();
  uint64_t v34 = *(void *)(v2 - 8);
  __chkstk_darwin(v2, v3);
  uint64_t v5 = (char *)&v31 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = *v0;
  sub_100431F80(&qword_100A44EE0);
  uint64_t v7 = sub_1007269C0();
  uint64_t v8 = v7;
  if (*(void *)(v6 + 16))
  {
    uint64_t v31 = v0;
    uint64_t v9 = 1 << *(unsigned char *)(v6 + 32);
    uint64_t v10 = *(void *)(v6 + 56);
    unint64_t v33 = (void *)(v6 + 56);
    if (v9 < 64) {
      uint64_t v11 = ~(-1 << v9);
    }
    else {
      uint64_t v11 = -1;
    }
    unint64_t v12 = v11 & v10;
    int64_t v32 = (unint64_t)(v9 + 63) >> 6;
    uint64_t v13 = v7 + 56;
    uint64_t result = swift_retain();
    int64_t v15 = 0;
    while (1)
    {
      if (v12)
      {
        unint64_t v17 = __clz(__rbit64(v12));
        v12 &= v12 - 1;
        unint64_t v18 = v17 | (v15 << 6);
      }
      else
      {
        int64_t v19 = v15 + 1;
        if (__OFADD__(v15, 1))
        {
LABEL_38:
          __break(1u);
LABEL_39:
          __break(1u);
          return result;
        }
        if (v19 >= v32) {
          goto LABEL_33;
        }
        unint64_t v20 = v33[v19];
        ++v15;
        if (!v20)
        {
          int64_t v15 = v19 + 1;
          if (v19 + 1 >= v32) {
            goto LABEL_33;
          }
          unint64_t v20 = v33[v15];
          if (!v20)
          {
            int64_t v15 = v19 + 2;
            if (v19 + 2 >= v32) {
              goto LABEL_33;
            }
            unint64_t v20 = v33[v15];
            if (!v20)
            {
              int64_t v21 = v19 + 3;
              if (v21 >= v32)
              {
LABEL_33:
                swift_release();
                unint64_t v1 = v31;
                uint64_t v30 = 1 << *(unsigned char *)(v6 + 32);
                if (v30 > 63) {
                  bzero(v33, ((unint64_t)(v30 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
                }
                else {
                  *unint64_t v33 = -1 << v30;
                }
                *(void *)(v6 + 16) = 0;
                break;
              }
              unint64_t v20 = v33[v21];
              if (!v20)
              {
                while (1)
                {
                  int64_t v15 = v21 + 1;
                  if (__OFADD__(v21, 1)) {
                    goto LABEL_39;
                  }
                  if (v15 >= v32) {
                    goto LABEL_33;
                  }
                  unint64_t v20 = v33[v15];
                  ++v21;
                  if (v20) {
                    goto LABEL_23;
                  }
                }
              }
              int64_t v15 = v21;
            }
          }
        }
LABEL_23:
        unint64_t v12 = (v20 - 1) & v20;
        unint64_t v18 = __clz(__rbit64(v20)) + (v15 << 6);
      }
      uint64_t v22 = *(void *)(v34 + 72);
      sub_1004500C4(*(void *)(v6 + 48) + v22 * v18, (uint64_t)v5, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionMaterialData);
      sub_10044F9FC(&qword_100A44ED0, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionMaterialData);
      uint64_t result = sub_1007263D0();
      uint64_t v23 = -1 << *(unsigned char *)(v8 + 32);
      unint64_t v24 = result & ~v23;
      unint64_t v25 = v24 >> 6;
      if (((-1 << v24) & ~*(void *)(v13 + 8 * (v24 >> 6))) != 0)
      {
        unint64_t v16 = __clz(__rbit64((-1 << v24) & ~*(void *)(v13 + 8 * (v24 >> 6)))) | v24 & 0x7FFFFFFFFFFFFFC0;
      }
      else
      {
        char v26 = 0;
        unint64_t v27 = (unint64_t)(63 - v23) >> 6;
        do
        {
          if (++v25 == v27 && (v26 & 1) != 0)
          {
            __break(1u);
            goto LABEL_38;
          }
          BOOL v28 = v25 == v27;
          if (v25 == v27) {
            unint64_t v25 = 0;
          }
          v26 |= v28;
          uint64_t v29 = *(void *)(v13 + 8 * v25);
        }
        while (v29 == -1);
        unint64_t v16 = __clz(__rbit64(~v29)) + (v25 << 6);
      }
      *(void *)(v13 + ((v16 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v16;
      uint64_t result = sub_1004500C4((uint64_t)v5, *(void *)(v8 + 48) + v16 * v22, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionMaterialData);
      ++*(void *)(v8 + 16);
    }
  }
  uint64_t result = swift_release();
  *unint64_t v1 = v8;
  return result;
}

uint64_t sub_10044FE1C(uint64_t a1, unint64_t a2, char a3)
{
  uint64_t v7 = type metadata accessor for IDSGroupEncryptionMaterialData();
  uint64_t v8 = *(void *)(v7 - 8);
  __chkstk_darwin(v7, v9);
  uint64_t v11 = (char *)&v25 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  unint64_t v12 = *(void *)(*v3 + 16);
  unint64_t v13 = *(void *)(*v3 + 24);
  uint64_t v25 = v8;
  char v26 = v3;
  if (v13 > v12 && (a3 & 1) != 0) {
    goto LABEL_12;
  }
  if (a3)
  {
    sub_10044FA44();
  }
  else
  {
    if (v13 > v12)
    {
      sub_10045012C();
      goto LABEL_12;
    }
    sub_100450390();
  }
  uint64_t v14 = *v3;
  sub_10044F9FC(&qword_100A44ED0, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionMaterialData);
  uint64_t v15 = sub_1007263D0();
  uint64_t v16 = -1 << *(unsigned char *)(v14 + 32);
  a2 = v15 & ~v16;
  if ((*(void *)(v14 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a2))
  {
    uint64_t v17 = ~v16;
    uint64_t v18 = *(void *)(v8 + 72);
    do
    {
      sub_10044F994(*(void *)(v14 + 48) + v18 * a2, (uint64_t)v11, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionMaterialData);
      sub_10044F9FC(&qword_100A44ED8, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionMaterialData);
      char v19 = sub_100726410();
      sub_10044F0CC((uint64_t)v11, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionMaterialData);
      if (v19) {
        goto LABEL_15;
      }
      a2 = (a2 + 1) & v17;
    }
    while (((*(void *)(v14 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a2) & 1) != 0);
  }
LABEL_12:
  uint64_t v20 = *v26;
  *(void *)(*v26 + 8 * (a2 >> 6) + 56) |= 1 << a2;
  uint64_t result = sub_1004500C4(a1, *(void *)(v20 + 48) + *(void *)(v25 + 72) * a2, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionMaterialData);
  uint64_t v22 = *(void *)(v20 + 16);
  BOOL v23 = __OFADD__(v22, 1);
  uint64_t v24 = v22 + 1;
  if (!v23)
  {
    *(void *)(v20 + 16) = v24;
    return result;
  }
  __break(1u);
LABEL_15:
  uint64_t result = sub_100726D30();
  __break(1u);
  return result;
}

uint64_t sub_1004500C4(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a3(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 32))(a2, a1, v5);
  return a2;
}

void *sub_10045012C()
{
  unint64_t v1 = v0;
  uint64_t v2 = type metadata accessor for IDSGroupEncryptionMaterialData();
  uint64_t v3 = *(void *)(v2 - 8);
  __chkstk_darwin(v2 - 8, v4);
  uint64_t v6 = (char *)&v24 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_100431F80(&qword_100A44EE0);
  uint64_t v7 = *v0;
  uint64_t v8 = sub_1007269B0();
  uint64_t v9 = v8;
  if (!*(void *)(v7 + 16))
  {
LABEL_25:
    uint64_t result = (void *)swift_release();
    *unint64_t v1 = v9;
    return result;
  }
  uint64_t result = (void *)(v8 + 56);
  uint64_t v11 = v7 + 56;
  unint64_t v12 = (unint64_t)((1 << *(unsigned char *)(v9 + 32)) + 63) >> 6;
  if (v9 != v7 || (unint64_t)result >= v11 + 8 * v12) {
    uint64_t result = memmove(result, (const void *)(v7 + 56), 8 * v12);
  }
  int64_t v13 = 0;
  *(void *)(v9 + 16) = *(void *)(v7 + 16);
  uint64_t v14 = 1 << *(unsigned char *)(v7 + 32);
  uint64_t v15 = -1;
  if (v14 < 64) {
    uint64_t v15 = ~(-1 << v14);
  }
  unint64_t v16 = v15 & *(void *)(v7 + 56);
  int64_t v17 = (unint64_t)(v14 + 63) >> 6;
  while (1)
  {
    if (v16)
    {
      unint64_t v18 = __clz(__rbit64(v16));
      v16 &= v16 - 1;
      unint64_t v19 = v18 | (v13 << 6);
      goto LABEL_9;
    }
    int64_t v21 = v13 + 1;
    if (__OFADD__(v13, 1))
    {
      __break(1u);
      goto LABEL_27;
    }
    if (v21 >= v17) {
      goto LABEL_25;
    }
    unint64_t v22 = *(void *)(v11 + 8 * v21);
    ++v13;
    if (!v22)
    {
      int64_t v13 = v21 + 1;
      if (v21 + 1 >= v17) {
        goto LABEL_25;
      }
      unint64_t v22 = *(void *)(v11 + 8 * v13);
      if (!v22)
      {
        int64_t v13 = v21 + 2;
        if (v21 + 2 >= v17) {
          goto LABEL_25;
        }
        unint64_t v22 = *(void *)(v11 + 8 * v13);
        if (!v22) {
          break;
        }
      }
    }
LABEL_24:
    unint64_t v16 = (v22 - 1) & v22;
    unint64_t v19 = __clz(__rbit64(v22)) + (v13 << 6);
LABEL_9:
    unint64_t v20 = *(void *)(v3 + 72) * v19;
    sub_10044F994(*(void *)(v7 + 48) + v20, (uint64_t)v6, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionMaterialData);
    uint64_t result = (void *)sub_1004500C4((uint64_t)v6, *(void *)(v9 + 48) + v20, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionMaterialData);
  }
  int64_t v23 = v21 + 3;
  if (v23 >= v17) {
    goto LABEL_25;
  }
  unint64_t v22 = *(void *)(v11 + 8 * v23);
  if (v22)
  {
    int64_t v13 = v23;
    goto LABEL_24;
  }
  while (1)
  {
    int64_t v13 = v23 + 1;
    if (__OFADD__(v23, 1)) {
      break;
    }
    if (v13 >= v17) {
      goto LABEL_25;
    }
    unint64_t v22 = *(void *)(v11 + 8 * v13);
    ++v23;
    if (v22) {
      goto LABEL_24;
    }
  }
LABEL_27:
  __break(1u);
  return result;
}

uint64_t sub_100450390()
{
  unint64_t v1 = v0;
  uint64_t v2 = type metadata accessor for IDSGroupEncryptionMaterialData();
  uint64_t v33 = *(void *)(v2 - 8);
  __chkstk_darwin(v2, v3);
  uint64_t v5 = (char *)&v30 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = *v0;
  sub_100431F80(&qword_100A44EE0);
  uint64_t v7 = sub_1007269C0();
  uint64_t v8 = v7;
  if (!*(void *)(v6 + 16))
  {
    uint64_t result = swift_release();
LABEL_35:
    *unint64_t v1 = v8;
    return result;
  }
  uint64_t v9 = 1 << *(unsigned char *)(v6 + 32);
  uint64_t v10 = *(void *)(v6 + 56);
  uint64_t v30 = v0;
  uint64_t v31 = v6 + 56;
  if (v9 < 64) {
    uint64_t v11 = ~(-1 << v9);
  }
  else {
    uint64_t v11 = -1;
  }
  unint64_t v12 = v11 & v10;
  int64_t v32 = (unint64_t)(v9 + 63) >> 6;
  uint64_t v13 = v7 + 56;
  uint64_t result = swift_retain();
  int64_t v15 = 0;
  while (1)
  {
    if (v12)
    {
      unint64_t v17 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      unint64_t v18 = v17 | (v15 << 6);
      goto LABEL_24;
    }
    int64_t v19 = v15 + 1;
    if (__OFADD__(v15, 1))
    {
LABEL_36:
      __break(1u);
      goto LABEL_37;
    }
    if (v19 >= v32) {
      goto LABEL_33;
    }
    unint64_t v20 = *(void *)(v31 + 8 * v19);
    ++v15;
    if (!v20)
    {
      int64_t v15 = v19 + 1;
      if (v19 + 1 >= v32) {
        goto LABEL_33;
      }
      unint64_t v20 = *(void *)(v31 + 8 * v15);
      if (!v20)
      {
        int64_t v15 = v19 + 2;
        if (v19 + 2 >= v32) {
          goto LABEL_33;
        }
        unint64_t v20 = *(void *)(v31 + 8 * v15);
        if (!v20) {
          break;
        }
      }
    }
LABEL_23:
    unint64_t v12 = (v20 - 1) & v20;
    unint64_t v18 = __clz(__rbit64(v20)) + (v15 << 6);
LABEL_24:
    uint64_t v22 = *(void *)(v33 + 72);
    sub_10044F994(*(void *)(v6 + 48) + v22 * v18, (uint64_t)v5, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionMaterialData);
    sub_10044F9FC(&qword_100A44ED0, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionMaterialData);
    uint64_t result = sub_1007263D0();
    uint64_t v23 = -1 << *(unsigned char *)(v8 + 32);
    unint64_t v24 = result & ~v23;
    unint64_t v25 = v24 >> 6;
    if (((-1 << v24) & ~*(void *)(v13 + 8 * (v24 >> 6))) != 0)
    {
      unint64_t v16 = __clz(__rbit64((-1 << v24) & ~*(void *)(v13 + 8 * (v24 >> 6)))) | v24 & 0x7FFFFFFFFFFFFFC0;
    }
    else
    {
      char v26 = 0;
      unint64_t v27 = (unint64_t)(63 - v23) >> 6;
      do
      {
        if (++v25 == v27 && (v26 & 1) != 0)
        {
          __break(1u);
          goto LABEL_36;
        }
        BOOL v28 = v25 == v27;
        if (v25 == v27) {
          unint64_t v25 = 0;
        }
        v26 |= v28;
        uint64_t v29 = *(void *)(v13 + 8 * v25);
      }
      while (v29 == -1);
      unint64_t v16 = __clz(__rbit64(~v29)) + (v25 << 6);
    }
    *(void *)(v13 + ((v16 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v16;
    uint64_t result = sub_1004500C4((uint64_t)v5, *(void *)(v8 + 48) + v16 * v22, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionMaterialData);
    ++*(void *)(v8 + 16);
  }
  int64_t v21 = v19 + 3;
  if (v21 >= v32)
  {
LABEL_33:
    uint64_t result = swift_release_n();
    unint64_t v1 = v30;
    goto LABEL_35;
  }
  unint64_t v20 = *(void *)(v31 + 8 * v21);
  if (v20)
  {
    int64_t v15 = v21;
    goto LABEL_23;
  }
  while (1)
  {
    int64_t v15 = v21 + 1;
    if (__OFADD__(v21, 1)) {
      break;
    }
    if (v15 >= v32) {
      goto LABEL_33;
    }
    unint64_t v20 = *(void *)(v31 + 8 * v15);
    ++v21;
    if (v20) {
      goto LABEL_23;
    }
  }
LABEL_37:
  __break(1u);
  return result;
}

uint64_t sub_10045072C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100431F80(&qword_100A44EE8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16))(a2, a1, v4);
  return a2;
}

_OWORD *sub_100450794(_OWORD *a1, _OWORD *a2)
{
  long long v2 = a1[1];
  *a2 = *a1;
  a2[1] = v2;
  return a2;
}

unint64_t sub_1004507A4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = -1 << *(unsigned char *)(v2 + 32);
  unint64_t v4 = a2 & ~v3;
  if ((*(void *)(v2 + 64 + ((v4 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v4))
  {
    uint64_t v5 = ~v3;
    do
    {
      sub_10045086C(*(void *)(v2 + 48) + 40 * v4, (uint64_t)v8);
      char v6 = sub_100726990();
      sub_1004508C8((uint64_t)v8);
      if (v6) {
        break;
      }
      unint64_t v4 = (v4 + 1) & v5;
    }
    while (((*(void *)(v2 + 64 + ((v4 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v4) & 1) != 0);
  }
  return v4;
}

uint64_t sub_10045086C(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t sub_1004508C8(uint64_t a1)
{
  return a1;
}

uint64_t *sub_10045091C(uint64_t a1, uint64_t *a2)
{
  if ((*(_DWORD *)(*(void *)(a1 - 8) + 80) & 0x20000) != 0)
  {
    uint64_t v3 = swift_slowAlloc();
    *a2 = v3;
    return (uint64_t *)v3;
  }
  return a2;
}

BOOL sub_100450980(int a1, int a2)
{
  return ((a2 ^ a1) & 1) == 0;
}

uint64_t sub_1004509A0()
{
  unint64_t v1 = (unsigned __int8 *)(v0 + OBJC_IVAR____TtC17identityservicesd34IDSGroupEncryptionControllerMember_kind);
  swift_beginAccess();
  return *v1;
}

uint64_t sub_1004509E8(char a1)
{
  char v2 = a1 & 1;
  uint64_t v3 = (unsigned char *)(v1 + OBJC_IVAR____TtC17identityservicesd34IDSGroupEncryptionControllerMember_kind);
  uint64_t result = swift_beginAccess();
  *uint64_t v3 = v2;
  return result;
}

uint64_t (*sub_100450A3C())()
{
  return j__swift_endAccess;
}

uint64_t sub_100450B18()
{
  uint64_t v1 = v0;
  BYTE8(v_Block_object_dispose(&STACK[0x320], 8) = 0;
  sub_1007269F0(19);
  v9._countAndFlagsBits = 0x207265626D654D3CLL;
  v9._xpc_object_t object = (void *)0xE800000000000000;
  sub_1007264C0(v9);
  id v2 = *(id *)((char *)v0 + OBJC_IVAR____TtC17identityservicesd34IDSGroupEncryptionControllerMember_uri);
  id v3 = [v2 description];
  uint64_t v4 = sub_100726430();
  char v6 = v5;

  v10._countAndFlagsBits = v4;
  v10._xpc_object_t object = v6;
  sub_1007264C0(v10);

  swift_bridgeObjectRelease();
  v11._countAndFlagsBits = 0x3A646E696B20;
  v11._xpc_object_t object = (void *)0xE600000000000000;
  sub_1007264C0(v11);
  *(void *)&long long v8 = (*(uint64_t (**)(void))((swift_isaMask & *v1) + 0x60))() & 1;
  sub_100726A90();
  v12._countAndFlagsBits = 62;
  v12._xpc_object_t object = (void *)0xE100000000000000;
  sub_1007264C0(v12);
  return *(void *)((char *)&v8 + 1);
}

uint64_t sub_100450C70(uint64_t a1)
{
  sub_100450D28(a1, (uint64_t)v5);
  if (!v6)
  {
    sub_100450D90((uint64_t)v5);
    goto LABEL_5;
  }
  type metadata accessor for IDSGroupEncryptionControllerMember();
  if ((swift_dynamicCast() & 1) == 0)
  {
LABEL_5:
    char v2 = 0;
    return v2 & 1;
  }
  sub_100450E14();
  id v1 = *(id *)&v4[OBJC_IVAR____TtC17identityservicesd34IDSGroupEncryptionControllerMember_uri];
  char v2 = sub_1007267F0();

  return v2 & 1;
}

uint64_t sub_100450D28(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100431F80(&qword_100A44F00);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16))(a2, a1, v4);
  return a2;
}

uint64_t sub_100450D90(uint64_t a1)
{
  uint64_t v2 = sub_100431F80(&qword_100A44F00);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v2 - 8) + 8))(a1, v2);
  return a1;
}

uint64_t type metadata accessor for IDSGroupEncryptionControllerMember()
{
  return self;
}

unint64_t sub_100450E14()
{
  unint64_t result = qword_100A44F08;
  if (!qword_100A44F08)
  {
    self;
    unint64_t result = swift_getObjCClassMetadata();
    atomic_store(result, (unint64_t *)&qword_100A44F08);
  }
  return result;
}

id sub_100450ECC(uint64_t a1, char a2)
{
  char v4 = a2 & 1;
  uint64_t v5 = objc_allocWithZone(v2);
  uint64_t v6 = &v5[OBJC_IVAR____TtC17identityservicesd34IDSGroupEncryptionControllerMember_kind];
  v5[OBJC_IVAR____TtC17identityservicesd34IDSGroupEncryptionControllerMember_kind] = 1;
  *(void *)&v5[OBJC_IVAR____TtC17identityservicesd34IDSGroupEncryptionControllerMember_uri] = a1;
  swift_beginAccess();
  *uint64_t v6 = v4;
  v8.receiver = v5;
  v8.super_class = v2;
  return objc_msgSendSuper2(&v8, "init");
}

uint64_t sub_100450FCC()
{
  return (*(uint64_t (**)(void))((swift_isaMask & *v0) + 0x60))() & 1;
}

uint64_t sub_1004510A4(char a1)
{
  return (*(uint64_t (**)(void))((swift_isaMask & *v1) + 0x68))(a1 & 1);
}

uint64_t (*sub_1004510DC(uint64_t a1))(uint64_t a1)
{
  *(void *)a1 = v1;
  *(unsigned char *)(a1 + _Block_object_dispose(&STACK[0x320], 8) = (*(uint64_t (**)(void))((swift_isaMask & *v1) + 0x60))() & 1;
  return sub_100451158;
}

uint64_t sub_100451158(uint64_t a1)
{
  return (*(uint64_t (**)(void))((swift_isaMask & **(void **)a1) + 0x68))(*(unsigned __int8 *)(a1 + 8));
}

void sub_1004511B0(uint64_t a1, uint64_t a2, unint64_t a3)
{
  id v6 = v3;
  swift_bridgeObjectRetain_n();
  uint64_t v7 = v6;
  oslog = sub_100725EB0();
  os_log_type_t v8 = sub_1007266E0();
  if (os_log_type_enabled(oslog, v8))
  {
    uint64_t v9 = swift_slowAlloc();
    Swift::String v10 = (void *)swift_slowAlloc();
    uint64_t v16 = swift_slowAlloc();
    *(_DWORD *)uint64_t v9 = 136315650;
    swift_bridgeObjectRetain();
    sub_10043E578(a2, a3, &v16);
    sub_100726830();
    swift_bridgeObjectRelease_n();
    *(_WORD *)(v9 + 12) = 2112;
    Swift::String v11 = *(void **)((char *)v7 + OBJC_IVAR____TtC17identityservicesd34IDSGroupEncryptionControllerMember_uri);
    id v12 = v11;
    sub_100726830();
    *Swift::String v10 = v11;

    *(_WORD *)(v9 + 22) = 2080;
    (*(void (**)(void))((swift_isaMask & *v7) + 0x60))();
    uint64_t v13 = sub_100726480();
    sub_10043E578(v13, v14, &v16);
    sub_100726830();

    swift_bridgeObjectRelease();
    _os_log_impl((void *)&_mh_execute_header, oslog, v8, "%sMember: %@; kind=%s", (uint8_t *)v9, 0x20u);
    sub_100431F80(&qword_100A44F10);
    swift_arrayDestroy();
    swift_slowDealloc();
    swift_arrayDestroy();
    swift_slowDealloc();
    swift_slowDealloc();
  }
  else
  {

    swift_bridgeObjectRelease_n();
  }
}

id sub_1004514B8()
{
  v2.receiver = v0;
  v2.super_class = (Class)type metadata accessor for IDSGroupEncryptionControllerMember();
  return objc_msgSendSuper2(&v2, "dealloc");
}

uint64_t sub_1004514FC()
{
  return (*(uint64_t (**)(void))((swift_isaMask & **v0) + 0x98))();
}

unint64_t sub_100451554()
{
  unint64_t result = qword_100A44F18;
  if (!qword_100A44F18)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_100A44F18);
  }
  return result;
}

unsigned char *storeEnumTagSinglePayload for IDSGroupEncryptionControllerParticipantType(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 1 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 1) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFF) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFE)
  {
    unsigned int v6 = ((a2 - 255) >> 8) + 1;
    *unint64_t result = a2 + 1;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x100451674);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *unint64_t result = a2 + 1;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for IDSGroupEncryptionControllerParticipantType()
{
  return &type metadata for IDSGroupEncryptionControllerParticipantType;
}

uint64_t type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet()
{
  uint64_t result = qword_100A4D2A0;
  if (!qword_100A4D2A0) {
    return swift_getSingletonMetadata();
  }
  return result;
}

uint64_t sub_100451708()
{
  uint64_t v0 = sub_100725ED0();
  sub_10045091C(v0, qword_100A53288);
  sub_10044DB64(v0, (uint64_t)qword_100A53288);
  return sub_1004DFE9C(2);
}

uint64_t sub_100451758()
{
  sub_100726E40();
  sub_10044F12C();
  sub_1007263E0();
  uint64_t v1 = *(void *)(v0 + 8);
  unint64_t v2 = *(void *)(v0 + 16);
  sub_100441FD4(v1, v2);
  sub_100725B60();
  sub_100442248(v1, v2);
  uint64_t v3 = type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet();
  type metadata accessor for IDSGroupEncryptionPublicIdentity(0);
  sub_10045471C(&qword_100A44E10, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionPublicIdentity);
  sub_1007263E0();
  sub_100726E10(*(void *)(v0 + *(int *)(v3 + 28)));
  sub_100725D30();
  sub_10045471C(&qword_100A44F48, (void (*)(uint64_t))&type metadata accessor for UUID);
  sub_1007263E0();
  sub_100726E20();
  sub_1007269F0(76);
  v5._xpc_object_t object = (void *)0x80000001008C0FB0;
  v5._countAndFlagsBits = 0xD000000000000010;
  sub_1007264C0(v5);
  v6._countAndFlagsBits = sub_100726D00();
  sub_1007264C0(v6);
  swift_bridgeObjectRelease();
  v7._countAndFlagsBits = 0xD000000000000012;
  v7._xpc_object_t object = (void *)0x80000001008C0FD0;
  sub_1007264C0(v7);
  v8._countAndFlagsBits = sub_100726D00();
  sub_1007264C0(v8);
  swift_bridgeObjectRelease();
  v9._countAndFlagsBits = 0xD000000000000013;
  v9._xpc_object_t object = (void *)0x80000001008C0FF0;
  sub_1007264C0(v9);
  sub_10045471C(&qword_100A44E00, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionPublicIdentity);
  v10._countAndFlagsBits = sub_100726D00();
  sub_1007264C0(v10);
  swift_bridgeObjectRelease();
  v11._countAndFlagsBits = 0x3A79656B2029;
  v11._xpc_object_t object = (void *)0xE600000000000000;
  sub_1007264C0(v11);
  v12._countAndFlagsBits = sub_100726480();
  sub_1007264C0(v12);
  swift_bridgeObjectRelease();
  v13._countAndFlagsBits = 0x3A6174616420;
  v13._xpc_object_t object = (void *)0xE600000000000000;
  sub_1007264C0(v13);
  sub_100441FD4(v1, v2);
  v14._countAndFlagsBits = sub_100725AA0();
  sub_1007264C0(v14);
  swift_bridgeObjectRelease();
  sub_100442248(v1, v2);
  v15._countAndFlagsBits = 62;
  v15._xpc_object_t object = (void *)0xE100000000000000;
  sub_1007264C0(v15);
  return 0;
}

id sub_100451AD8()
{
  uint64_t v1 = *((void *)v0 + 1);
  unint64_t v2 = *((void *)v0 + 2);
  if (*((unsigned char *)v0 + 4) == 2) {
    uint64_t v3 = *v0;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet();
  Swift::String v5 = (char *)v0 + *(int *)(v4 + 24);
  Swift::String v6 = *(void **)&v5[*(int *)(type metadata accessor for IDSGroupEncryptionPublicIdentity(0) + 28)];
  uint64_t v7 = *(void *)((char *)v0 + *(int *)(v4 + 28));
  id v8 = objc_allocWithZone((Class)IDSServerDesiredEncryptedDataSet);
  sub_100441FD4(v1, v2);
  id v9 = v6;
  Class isa = sub_100725B20().super.isa;
  id v11 = [v8 initWithEncryptedData:isa type:v3 forPublicIdentity:v9 forParticipantID:v7];

  sub_100442248(v1, v2);
  return v11;
}

void *sub_100451BBC(void *a1)
{
  uint64_t v2 = v1;
  uint64_t v76 = type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet();
  uint64_t v5 = __chkstk_darwin(v76, v4);
  uint64_t v7 = (char *)&v70 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v9 = __chkstk_darwin(v5, v8);
  uint64_t v80 = (uint64_t)&v70 - v10;
  uint64_t v12 = __chkstk_darwin(v9, v11);
  uint64_t v78 = (uint64_t)&v70 - v13;
  __chkstk_darwin(v12, v14);
  uint64_t v79 = (uint64_t)&v70 - v15;
  uint64_t v77 = type metadata accessor for IDSGroupEncryptionMaterialData();
  uint64_t v17 = __chkstk_darwin(v77, v16);
  uint64_t v81 = (uint64_t)&v70 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = __chkstk_darwin(v17, v19);
  uint64_t v22 = (char *)&v70 - v21;
  uint64_t v24 = __chkstk_darwin(v20, v23);
  char v26 = (char *)&v70 - v25;
  __chkstk_darwin(v24, v27);
  uint64_t v29 = (char *)&v70 - v28;
  uint64_t v30 = sub_100431F80(&qword_100A44F50);
  uint64_t v32 = __chkstk_darwin(v30, v31);
  uint64_t v34 = (unint64_t *)((char *)&v70 - ((v33 + 15) & 0xFFFFFFFFFFFFFFF0));
  __chkstk_darwin(v32, v35);
  char v37 = (char *)&v70 - v36;
  unint64_t v85 = &_swiftEmptySetSingleton;
  sub_1004524B4(a1, (uint64_t *)((char *)&v70 - v36));
  uint64_t v82 = v37;
  sub_1004546B8((uint64_t)v37, (uint64_t)v34, &qword_100A44F50);
  if (swift_getEnumCaseMultiPayload() == 1)
  {
    unint64_t v38 = *v34;
    if (qword_100A4D010 != -1) {
      swift_once();
    }
    uint64_t v39 = sub_100725ED0();
    sub_10044DB64(v39, (uint64_t)qword_100A53288);
    sub_100452F64(v2, (uint64_t)v7, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet);
    sub_100452A44(v38);
    sub_100452A44(v38);
    uint64_t v40 = sub_100725EB0();
    os_log_type_t v41 = sub_1007266C0();
    if (os_log_type_enabled(v40, v41))
    {
      uint64_t v42 = swift_slowAlloc();
      uint64_t v84 = swift_slowAlloc();
      *(_DWORD *)uint64_t v42 = 136315394;
      char v43 = v7[4];
      LODWORD(v83) = *(_DWORD *)v7;
      BYTE4(v83) = v43;
      uint64_t v44 = sub_100726480();
      uint64_t v83 = sub_10043E578(v44, v45, &v84);
      sub_100726830();
      swift_bridgeObjectRelease();
      sub_100452FCC((uint64_t)v7, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet);
      *(_WORD *)(v42 + 12) = 2080;
      uint64_t v83 = v38;
      sub_100452A44(v38);
      uint64_t v46 = sub_100726480();
      uint64_t v83 = sub_10043E578(v46, v47, &v84);
      sub_100726830();
      swift_bridgeObjectRelease();
      sub_100452A54(v38);
      sub_100452A54(v38);
      _os_log_impl((void *)&_mh_execute_header, v40, v41, "materialData: could not get material data for material %s: %s", (uint8_t *)v42, 0x16u);
      swift_arrayDestroy();
      swift_slowDealloc();
      swift_slowDealloc();
    }
    else
    {

      sub_100452A54(v38);
      sub_100452A54(v38);
      sub_100452FCC((uint64_t)v7, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet);
    }
    sub_100452A54(v38);
  }
  else
  {
    sub_1004537A4((uint64_t)v34, (uint64_t)v29, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionMaterialData);
    sub_100452F64((uint64_t)v29, (uint64_t)v22, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionMaterialData);
    sub_10044EDC8((uint64_t)v26, (uint64_t)v22);
    sub_100452FCC((uint64_t)v26, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionMaterialData);
    uint64_t v48 = v29;
    if (qword_100A4D010 != -1) {
      swift_once();
    }
    uint64_t v49 = sub_100725ED0();
    sub_10044DB64(v49, (uint64_t)qword_100A53288);
    uint64_t v50 = v79;
    sub_100452F64(v2, v79, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet);
    uint64_t v51 = v78;
    sub_100452F64(v2, v78, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet);
    uint64_t v52 = v80;
    sub_100452F64(v2, v80, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet);
    uint64_t v53 = (uint64_t)v29;
    uint64_t v54 = v81;
    sub_100452F64(v53, v81, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionMaterialData);
    uint64_t v55 = sub_100725EB0();
    os_log_type_t v56 = sub_1007266A0();
    int v57 = v56;
    if (os_log_type_enabled(v55, v56))
    {
      uint64_t v58 = swift_slowAlloc();
      uint64_t v74 = swift_slowAlloc();
      uint64_t v84 = v74;
      *(_DWORD *)uint64_t v58 = 136315906;
      int v73 = v57;
      char v59 = *(unsigned char *)(v50 + 4);
      LODWORD(v83) = *(_DWORD *)v50;
      BYTE4(v83) = v59;
      uint64_t v71 = v26;
      uint64_t v75 = (uint64_t)v48;
      uint64_t v60 = sub_100726480();
      os_log_t v72 = v55;
      uint64_t v83 = sub_10043E578(v60, v61, &v84);
      sub_100726830();
      swift_bridgeObjectRelease();
      sub_100452FCC(v50, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet);
      *(_WORD *)(v58 + 12) = 2048;
      uint64_t v62 = *(void *)(v51 + *(int *)(v76 + 28));
      sub_100452FCC(v51, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet);
      uint64_t v83 = v62;
      sub_100726830();
      *(_WORD *)(v58 + 22) = 2080;
      type metadata accessor for IDSGroupEncryptionPublicIdentity(0);
      sub_10045471C(&qword_100A44E00, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionPublicIdentity);
      uint64_t v63 = sub_100726D00();
      uint64_t v83 = sub_10043E578(v63, v64, &v84);
      sub_100726830();
      swift_bridgeObjectRelease();
      sub_100452FCC(v52, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet);
      *(_WORD *)(v58 + 32) = 2080;
      sub_100452F64(v54, (uint64_t)v71, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionMaterialData);
      uint64_t v65 = sub_100726480();
      uint64_t v83 = sub_10043E578(v65, v66, &v84);
      sub_100726830();
      swift_bridgeObjectRelease();
      sub_100452FCC(v54, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionMaterialData);
      os_log_t v67 = v72;
      _os_log_impl((void *)&_mh_execute_header, v72, (os_log_type_t)v73, "materialData: encrypted kv %s for participantID: %llu; for public identity: %s, data: %s",
        (uint8_t *)v58,
        0x2Au);
      swift_arrayDestroy();
      swift_slowDealloc();
      swift_slowDealloc();

      uint64_t v68 = v75;
    }
    else
    {
      sub_100452FCC(v51, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet);

      sub_100452FCC(v54, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionMaterialData);
      sub_100452FCC(v52, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet);
      sub_100452FCC(v50, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet);
      uint64_t v68 = (uint64_t)v48;
    }
    sub_100452FCC(v68, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionMaterialData);
  }
  sub_100452A64((uint64_t)v82);
  return v85;
}

void sub_1004524B4(void *a1@<X2>, void *a2@<X8>)
{
  uint64_t v3 = v2;
  uint64_t v6 = type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet();
  __chkstk_darwin(v6, v7);
  uint64_t v9 = (char *)v40 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (qword_100A4D010 != -1) {
    swift_once();
  }
  uint64_t v10 = sub_100725ED0();
  sub_10044DB64(v10, (uint64_t)qword_100A53288);
  sub_100452F64(v2, (uint64_t)v9, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet);
  uint64_t v11 = sub_100725EB0();
  os_log_type_t v12 = sub_1007266E0();
  if (os_log_type_enabled(v11, v12))
  {
    uint64_t v13 = swift_slowAlloc();
    uint64_t v43 = (uint64_t)a2;
    uint64_t v14 = v13;
    uint64_t v42 = swift_slowAlloc();
    uint64_t v45 = v42;
    *(_DWORD *)uint64_t v14 = 136315394;
    uint64_t v44 = sub_10043E578(0xD000000000000022, 0x80000001008C1010, &v45);
    sub_100726830();
    *(_WORD *)(v14 + 12) = 2080;
    v40[1] = v14 + 14;
    type metadata accessor for IDSGroupEncryptionPublicIdentity(0);
    os_log_type_t v41 = (int *)v6;
    sub_10045471C(&qword_100A44E00, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionPublicIdentity);
    uint64_t v15 = sub_100726D00();
    uint64_t v44 = sub_10043E578(v15, v16, &v45);
    sub_100726830();
    swift_bridgeObjectRelease();
    sub_100452FCC((uint64_t)v9, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet);
    _os_log_impl((void *)&_mh_execute_header, v11, v12, "%s: encrypting for %s", (uint8_t *)v14, 0x16u);
    swift_arrayDestroy();
    swift_slowDealloc();
    a2 = (void *)v43;
    swift_slowDealloc();

    uint64_t v17 = v41;
  }
  else
  {
    sub_100452FCC((uint64_t)v9, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet);

    uint64_t v17 = (int *)v6;
  }
  uint64_t v18 = a1[3];
  uint64_t v19 = a1[4];
  sub_10044C0F4(a1, v18);
  uint64_t v20 = (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t))(v19 + 24))(*(void *)(v2 + 8), *(void *)(v2 + 16), v2 + v17[6], v18, v19);
  uint64_t v22 = v20;
  if (v23)
  {
    *a2 = v20;
    goto LABEL_13;
  }
  unint64_t v24 = v21;
  if (*(unsigned char *)(v3 + 4) == 2) {
    int v25 = *(_DWORD *)v3;
  }
  else {
    int v25 = 0;
  }
  uint64_t v43 = sub_100431F80(&qword_100A44F58);
  char v26 = (char *)a2 + *(int *)(v43 + 48);
  *(_DWORD *)a2 = v25;
  uint64_t v27 = v3 + v17[8];
  uint64_t v28 = sub_100725D30();
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v28 - 8) + 16))(v26, v27, v28);
  sub_100431F80((uint64_t *)&unk_100A45610);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_100794E70;
  uint64_t v45 = sub_100726430();
  uint64_t v46 = v30;
  sub_100441FD4(v22, v24);
  sub_1007269A0();
  *(void *)(inited + 96) = &type metadata for Data;
  *(void *)(inited + 72) = v22;
  *(void *)(inited + 80) = v24;
  uint64_t v45 = sub_100726430();
  uint64_t v46 = v31;
  sub_100441FD4(v22, v24);
  sub_1007269A0();
  *(void *)(inited + 16_Block_object_dispose(&STACK[0x320], 8) = &type metadata for Int;
  *(void *)(inited + 144) = 1;
  uint64_t v45 = sub_100726430();
  uint64_t v46 = v32;
  sub_1007269A0();
  uint64_t v33 = *(void *)(v3 + v17[7]);
  *(void *)(inited + 240) = &type metadata for UInt64;
  *(void *)(inited + 216) = v33;
  sub_10044E7C0(inited);
  Class isa = sub_100726380().super.isa;
  swift_bridgeObjectRelease();
  id v35 = (id)JWEncodeDictionary();

  if (v35)
  {
    uint64_t v36 = (void *)((char *)a2 + *(int *)(v43 + 64));
    uint64_t v37 = sub_100725B50();
    uint64_t v39 = v38;

    sub_10044C144(v22, v24, 0);
    sub_10044C144(v22, v24, 0);
    *uint64_t v36 = v37;
    v36[1] = v39;
    type metadata accessor for IDSGroupEncryptionMaterialData();
    swift_storeEnumTagMultiPayload();
LABEL_13:
    sub_100431F80(&qword_100A44F50);
    swift_storeEnumTagMultiPayload();
    return;
  }
  __break(1u);
}

unint64_t sub_100452A44(unint64_t result)
{
  if (result >= 2) {
    return swift_errorRetain();
  }
  return result;
}

unint64_t sub_100452A54(unint64_t result)
{
  if (result >= 2) {
    return swift_errorRelease();
  }
  return result;
}

uint64_t sub_100452A64(uint64_t a1)
{
  uint64_t v2 = sub_100431F80(&qword_100A44F50);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v2 - 8) + 8))(a1, v2);
  return a1;
}

Swift::Int sub_100452AC8()
{
  sub_100726DD0();
  sub_10044F12C();
  sub_1007263E0();
  sub_100725B60();
  uint64_t v1 = type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet();
  type metadata accessor for IDSGroupEncryptionPublicIdentity(0);
  sub_10045471C(&qword_100A44E10, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionPublicIdentity);
  sub_1007263E0();
  sub_100726E10(*(void *)(v0 + *(int *)(v1 + 28)));
  sub_100725D30();
  sub_10045471C(&qword_100A44F48, (void (*)(uint64_t))&type metadata accessor for UUID);
  sub_1007263E0();
  return sub_100726E30();
}

uint64_t sub_100452C10@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  *(_DWORD *)a7 = a1;
  *(unsigned char *)(a7 + 4) = BYTE4(a1);
  *(void *)(a7 + _Block_object_dispose(&STACK[0x320], 8) = a2;
  *(void *)(a7 + 16) = a3;
  uint64_t v11 = (int *)type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet();
  sub_1004537A4(a4, a7 + v11[6], type metadata accessor for IDSGroupEncryptionPublicIdentity);
  *(void *)(a7 + v11[7]) = a5;
  uint64_t v12 = a7 + v11[8];
  uint64_t v13 = sub_100725D30();
  uint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v13 - 8) + 32);

  return v14(v12, a6, v13);
}

uint64_t sub_100452CF0(uint64_t a1, uint64_t a2)
{
  sub_10044F12C();
  sub_1007263E0();
  sub_100725B60();
  type metadata accessor for IDSGroupEncryptionPublicIdentity(0);
  sub_10045471C(&qword_100A44E10, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionPublicIdentity);
  sub_1007263E0();
  sub_100726E10(*(void *)(v2 + *(int *)(a2 + 28)));
  sub_100725D30();
  sub_10045471C(&qword_100A44F48, (void (*)(uint64_t))&type metadata accessor for UUID);
  return sub_1007263E0();
}

Swift::Int sub_100452E28(uint64_t a1, uint64_t a2)
{
  sub_100726DD0();
  sub_10044F12C();
  sub_1007263E0();
  sub_100725B60();
  type metadata accessor for IDSGroupEncryptionPublicIdentity(0);
  sub_10045471C(&qword_100A44E10, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionPublicIdentity);
  sub_1007263E0();
  sub_100726E10(*(void *)(v2 + *(int *)(a2 + 28)));
  sub_100725D30();
  sub_10045471C(&qword_100A44F48, (void (*)(uint64_t))&type metadata accessor for UUID);
  sub_1007263E0();
  return sub_100726E30();
}

uint64_t sub_100452F64(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a3(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16))(a2, a1, v5);
  return a2;
}

uint64_t sub_100452FCC(uint64_t a1, uint64_t (*a2)(void))
{
  uint64_t v3 = a2(0);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v3 - 8) + 8))(a1, v3);
  return a1;
}

uint64_t sub_10045302C@<X0>(uint64_t __s1@<X0>, uint64_t a2@<X2>, unint64_t a3@<X3>, char *a4@<X8>)
{
  uint64_t v7 = (const void *)__s1;
  switch(a3 >> 62)
  {
    case 1uLL:
      uint64_t v9 = (a2 >> 32) - (int)a2;
      if (a2 >> 32 < (int)a2)
      {
        __break(1u);
LABEL_31:
        __break(1u);
LABEL_32:
        __break(1u);
        goto LABEL_33;
      }
      sub_100441FD4(a2, a3);
      uint64_t v10 = (char *)sub_100725910();
      if (!v10) {
        goto LABEL_8;
      }
      uint64_t v11 = sub_100725940();
      if (__OFSUB__((int)a2, v11)) {
LABEL_33:
      }
        __break(1u);
      v10 += (int)a2 - v11;
LABEL_8:
      uint64_t v12 = sub_100725930();
      if (v12 >= v9) {
        size_t v13 = (a2 >> 32) - (int)a2;
      }
      else {
        size_t v13 = v12;
      }
      if (!v7)
      {
LABEL_35:
        __break(1u);
LABEL_36:
        __break(1u);
LABEL_37:
        __break(1u);
LABEL_38:
        __break(1u);
LABEL_39:
        __break(1u);
        JUMPOUT(0x100453290);
      }
      if (!v10) {
        goto LABEL_36;
      }
      int v14 = memcmp(v7, v10, v13);
      __s1 = sub_100442248(a2, a3);
      BOOL v8 = v14 == 0;
LABEL_24:
      char v24 = v8;
LABEL_29:
      *a4 = v24;
      return __s1;
    case 2uLL:
      uint64_t v15 = *(void *)(a2 + 16);
      uint64_t v16 = *(void *)(a2 + 24);
      swift_retain();
      swift_retain();
      uint64_t v17 = (char *)sub_100725910();
      if (!v17) {
        goto LABEL_17;
      }
      uint64_t v18 = sub_100725940();
      if (__OFSUB__(v15, v18)) {
        goto LABEL_32;
      }
      v17 += v15 - v18;
LABEL_17:
      BOOL v19 = __OFSUB__(v16, v15);
      int64_t v20 = v16 - v15;
      if (v19) {
        goto LABEL_31;
      }
      uint64_t v21 = sub_100725930();
      if (v21 >= v20) {
        size_t v22 = v20;
      }
      else {
        size_t v22 = v21;
      }
      if (!v7) {
        goto LABEL_37;
      }
      if (!v17) {
        goto LABEL_38;
      }
      int v23 = memcmp(v7, v17, v22);
      swift_release();
      __s1 = swift_release();
      BOOL v8 = v23 == 0;
      goto LABEL_24;
    case 3uLL:
      if (!__s1) {
        goto LABEL_39;
      }
      char v24 = 1;
      goto LABEL_29;
    default:
      uint64_t __s2 = a2;
      __int16 v26 = a3;
      char v27 = BYTE2(a3);
      char v28 = BYTE3(a3);
      char v29 = BYTE4(a3);
      char v30 = BYTE5(a3);
      if (__s1)
      {
        __s1 = memcmp((const void *)__s1, &__s2, BYTE6(a3));
        BOOL v8 = __s1 == 0;
        goto LABEL_24;
      }
      __break(1u);
      goto LABEL_35;
  }
}

uint64_t sub_1004532A0(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  switch(a2 >> 62)
  {
    case 1uLL:
      if (a1 >> 32 < (int)a1) {
        __break(1u);
      }
      sub_100441FD4(a1, a2);
      char v5 = sub_1004534D0((int)a1, a1 >> 32, a2 & 0x3FFFFFFFFFFFFFFFLL, a3, a4);
      sub_100442248(a1, a2);
      goto LABEL_6;
    case 2uLL:
      uint64_t v10 = a2 & 0x3FFFFFFFFFFFFFFFLL;
      uint64_t v11 = *(void *)(a1 + 16);
      uint64_t v12 = *(void *)(a1 + 24);
      swift_retain();
      swift_retain();
      char v5 = sub_1004534D0(v11, v12, v10, a3, a4);
      swift_release();
      swift_release();
LABEL_6:
      sub_100442248(a3, a4);
      return v5 & 1;
    case 3uLL:
      memset(__s1, 0, 14);
      goto LABEL_8;
    default:
      __s1[0] = a1;
      LOWORD(__s1[1]) = a2;
      BYTE2(__s1[1]) = BYTE2(a2);
      BYTE3(__s1[1]) = BYTE3(a2);
      BYTE4(__s1[1]) = BYTE4(a2);
      BYTE5(__s1[1]) = BYTE5(a2);
LABEL_8:
      sub_10045302C((uint64_t)__s1, a3, a4, &v14);
      sub_100442248(a3, a4);
      if (!v4) {
        char v5 = v14;
      }
      return v5 & 1;
  }
}

uint64_t sub_1004534D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t result = sub_100725910();
  uint64_t v11 = result;
  if (result)
  {
    uint64_t result = sub_100725940();
    if (__OFSUB__(a1, result))
    {
LABEL_9:
      __break(1u);
      return result;
    }
    v11 += a1 - result;
  }
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
    goto LABEL_9;
  }
  sub_100725930();
  sub_10045302C(v11, a4, a5, &v13);
  if (!v5) {
    char v12 = v13;
  }
  return v12 & 1;
}

uint64_t sub_100453588(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = 0;
  switch(a2 >> 62)
  {
    case 1uLL:
      LODWORD(v_Block_object_dispose(&STACK[0x320], 8) = HIDWORD(a1) - a1;
      if (__OFSUB__(HIDWORD(a1), a1))
      {
        __break(1u);
LABEL_19:
        __break(1u);
LABEL_20:
        __break(1u);
LABEL_21:
        __break(1u);
        JUMPOUT(0x1004536C4);
      }
      uint64_t v8 = (int)v8;
LABEL_6:
      switch(a4 >> 62)
      {
        case 1uLL:
          LODWORD(v12) = HIDWORD(a3) - a3;
          if (__OFSUB__(HIDWORD(a3), a3)) {
            goto LABEL_20;
          }
          uint64_t v12 = (int)v12;
LABEL_11:
          if (v8 == v12)
          {
            if (v8 < 1)
            {
              char v15 = 1;
            }
            else
            {
              sub_100441FD4(a3, a4);
              char v15 = sub_1004532A0(a1, a2, a3, a4);
            }
          }
          else
          {
            char v15 = 0;
          }
          return v15 & 1;
        case 2uLL:
          uint64_t v14 = *(void *)(a3 + 16);
          uint64_t v13 = *(void *)(a3 + 24);
          BOOL v11 = __OFSUB__(v13, v14);
          uint64_t v12 = v13 - v14;
          if (!v11) {
            goto LABEL_11;
          }
          goto LABEL_21;
        case 3uLL:
          char v15 = v8 == 0;
          return v15 & 1;
        default:
          uint64_t v12 = BYTE6(a4);
          goto LABEL_11;
      }
    case 2uLL:
      uint64_t v10 = *(void *)(a1 + 16);
      uint64_t v9 = *(void *)(a1 + 24);
      BOOL v11 = __OFSUB__(v9, v10);
      uint64_t v8 = v9 - v10;
      if (!v11) {
        goto LABEL_6;
      }
      goto LABEL_19;
    case 3uLL:
      goto LABEL_6;
    default:
      uint64_t v8 = BYTE6(a2);
      goto LABEL_6;
  }
}

uint64_t sub_1004536E4(unsigned int *a1, unsigned int *a2)
{
  if (!sub_100512630(*a1 | ((unint64_t)*((unsigned __int8 *)a1 + 4) << 32), *a2 | ((unint64_t)*((unsigned __int8 *)a2 + 4) << 32)))return 0; {
  if ((sub_100453588(*((void *)a1 + 1), *((void *)a1 + 2), *((void *)a2 + 1), *((void *)a2 + 2)) & 1) == 0)
  }
    return 0;
  uint64_t v4 = type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet();
  if ((sub_1005351F4((char *)a1 + *(int *)(v4 + 24), (char *)a2 + *(int *)(v4 + 24)) & 1) == 0
    || *(void *)((char *)a1 + *(int *)(v4 + 28)) != *(void *)((char *)a2 + *(int *)(v4 + 28)))
  {
    return 0;
  }

  return sub_100725CF0();
}

uint64_t sub_1004537A4(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a3(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 32))(a2, a1, v5);
  return a2;
}

uint64_t sub_10045380C(uint64_t a1)
{
  uint64_t result = sub_10045471C(&qword_100A44F60, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet);
  *(void *)(a1 + _Block_object_dispose(&STACK[0x320], 8) = result;
  return result;
}

uint64_t sub_100453864()
{
  return sub_10045471C(&qword_100A44F68, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet);
}

void *sub_1004538AC(uint64_t a1, uint64_t *a2, int *a3)
{
  uint64_t v4 = (void *)a1;
  int v5 = *(_DWORD *)(*((void *)a3 - 1) + 80);
  if ((v5 & 0x20000) != 0)
  {
    uint64_t v27 = *a2;
    *uint64_t v4 = *a2;
    uint64_t v4 = (void *)(v27 + ((v5 + 16) & ~(unint64_t)v5));
    swift_retain();
  }
  else
  {
    *(_DWORD *)a1 = *(_DWORD *)a2;
    *(unsigned char *)(a1 + 4) = *((unsigned char *)a2 + 4);
    uint64_t v7 = a2[1];
    unint64_t v8 = a2[2];
    sub_100441FD4(v7, v8);
    v4[1] = v7;
    _DWORD v4[2] = v8;
    uint64_t v9 = a3[6];
    uint64_t v10 = (void *)((char *)v4 + v9);
    uint64_t v11 = (uint64_t)a2 + v9;
    uint64_t v13 = *(void **)((char *)a2 + v9);
    uint64_t v12 = *(void **)((char *)a2 + v9 + 8);
    *uint64_t v10 = v13;
    v10[1] = v12;
    uint64_t v14 = (int *)type metadata accessor for IDSGroupEncryptionPublicIdentity(0);
    uint64_t v15 = v14[6];
    uint64_t v30 = v11 + v15;
    uint64_t v31 = (char *)v10 + v15;
    uint64_t v16 = sub_100725CC0();
    char v29 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(v16 - 8) + 16);
    id v17 = v13;
    id v18 = v12;
    v29(v31, v30, v16);
    uint64_t v19 = v14[7];
    int64_t v20 = *(void **)(v11 + v19);
    *(void *)((char *)v10 + v19) = v20;
    *((unsigned char *)v10 + v14[8]) = *(unsigned char *)(v11 + v14[8]);
    uint64_t v21 = a3[8];
    *(void *)((char *)v4 + a3[7]) = *(uint64_t *)((char *)a2 + a3[7]);
    size_t v22 = (char *)v4 + v21;
    uint64_t v23 = (uint64_t)a2 + v21;
    uint64_t v24 = sub_100725D30();
    int v25 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(v24 - 8) + 16);
    id v26 = v20;
    v25(v22, v23, v24);
  }
  return v4;
}

uint64_t sub_100453A60(uint64_t a1, uint64_t a2)
{
  sub_100442248(*(void *)(a1 + 8), *(void *)(a1 + 16));
  uint64_t v4 = (id *)(a1 + *(int *)(a2 + 24));

  uint64_t v5 = type metadata accessor for IDSGroupEncryptionPublicIdentity(0);
  uint64_t v6 = (char *)v4 + *(int *)(v5 + 24);
  uint64_t v7 = sub_100725CC0();
  (*(void (**)(char *, uint64_t))(*(void *)(v7 - 8) + 8))(v6, v7);

  uint64_t v8 = a1 + *(int *)(a2 + 32);
  uint64_t v9 = sub_100725D30();
  uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v9 - 8) + 8);

  return v10(v8, v9);
}

uint64_t sub_100453B5C(uint64_t a1, uint64_t a2, int *a3)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(unsigned char *)(a1 + 4) = *(unsigned char *)(a2 + 4);
  uint64_t v6 = *(void *)(a2 + 8);
  unint64_t v7 = *(void *)(a2 + 16);
  sub_100441FD4(v6, v7);
  *(void *)(a1 + _Block_object_dispose(&STACK[0x320], 8) = v6;
  *(void *)(a1 + 16) = v7;
  uint64_t v8 = a3[6];
  uint64_t v9 = (void *)(a1 + v8);
  uint64_t v10 = a2 + v8;
  uint64_t v12 = *(void **)(a2 + v8);
  uint64_t v11 = *(void **)(a2 + v8 + 8);
  *uint64_t v9 = v12;
  v9[1] = v11;
  uint64_t v13 = (int *)type metadata accessor for IDSGroupEncryptionPublicIdentity(0);
  uint64_t v14 = v13[6];
  uint64_t v28 = v10 + v14;
  char v29 = (char *)v9 + v14;
  uint64_t v15 = sub_100725CC0();
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(v15 - 8) + 16);
  id v17 = v12;
  id v18 = v11;
  v16(v29, v28, v15);
  uint64_t v19 = v13[7];
  int64_t v20 = *(void **)(v10 + v19);
  *(void *)((char *)v9 + v19) = v20;
  *((unsigned char *)v9 + v13[8]) = *(unsigned char *)(v10 + v13[8]);
  uint64_t v21 = a3[8];
  *(void *)(a1 + a3[7]) = *(void *)(a2 + a3[7]);
  uint64_t v22 = a1 + v21;
  uint64_t v23 = a2 + v21;
  uint64_t v24 = sub_100725D30();
  int v25 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v24 - 8) + 16);
  id v26 = v20;
  v25(v22, v23, v24);
  return a1;
}

uint64_t sub_100453CC0(uint64_t a1, int *a2, int *a3)
{
  int v6 = *a2;
  *(unsigned char *)(a1 + 4) = *((unsigned char *)a2 + 4);
  *(_DWORD *)a1 = v6;
  uint64_t v7 = *((void *)a2 + 1);
  unint64_t v8 = *((void *)a2 + 2);
  sub_100441FD4(v7, v8);
  uint64_t v9 = *(void *)(a1 + 8);
  unint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + _Block_object_dispose(&STACK[0x320], 8) = v7;
  *(void *)(a1 + 16) = v8;
  sub_100442248(v9, v10);
  uint64_t v11 = a3[6];
  uint64_t v12 = (void *)(a1 + v11);
  uint64_t v13 = (uint64_t)a2 + v11;
  uint64_t v14 = *(void **)(a1 + v11);
  uint64_t v15 = *(void **)((char *)a2 + v11);
  *uint64_t v12 = v15;
  id v16 = v15;

  id v17 = *(void **)(v13 + 8);
  id v18 = (void *)v12[1];
  v12[1] = v17;
  id v19 = v17;

  int64_t v20 = (int *)type metadata accessor for IDSGroupEncryptionPublicIdentity(0);
  uint64_t v21 = v20[6];
  uint64_t v22 = (char *)v12 + v21;
  uint64_t v23 = v13 + v21;
  uint64_t v24 = sub_100725CC0();
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v24 - 8) + 24))(v22, v23, v24);
  uint64_t v25 = v20[7];
  id v26 = *(void **)(v13 + v25);
  uint64_t v27 = *(void **)((char *)v12 + v25);
  *(void *)((char *)v12 + v25) = v26;
  id v28 = v26;

  *((unsigned char *)v12 + v20[8]) = *(unsigned char *)(v13 + v20[8]);
  *(void *)(a1 + a3[7]) = *(void *)((char *)a2 + a3[7]);
  uint64_t v29 = a3[8];
  uint64_t v30 = a1 + v29;
  uint64_t v31 = (uint64_t)a2 + v29;
  uint64_t v32 = sub_100725D30();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v32 - 8) + 24))(v30, v31, v32);
  return a1;
}

uint64_t sub_100453E30(uint64_t a1, uint64_t a2, int *a3)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(unsigned char *)(a1 + 4) = *(unsigned char *)(a2 + 4);
  *(_OWORD *)(a1 + _Block_object_dispose(&STACK[0x320], 8) = *(_OWORD *)(a2 + 8);
  uint64_t v6 = a3[6];
  uint64_t v7 = a1 + v6;
  uint64_t v8 = a2 + v6;
  *(_OWORD *)(a1 + v6) = *(_OWORD *)(a2 + v6);
  uint64_t v9 = (int *)type metadata accessor for IDSGroupEncryptionPublicIdentity(0);
  uint64_t v10 = v9[6];
  uint64_t v11 = v7 + v10;
  uint64_t v12 = v8 + v10;
  uint64_t v13 = sub_100725CC0();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v13 - 8) + 32))(v11, v12, v13);
  *(void *)(v7 + v9[7]) = *(void *)(v8 + v9[7]);
  *(unsigned char *)(v7 + v9[8]) = *(unsigned char *)(v8 + v9[8]);
  uint64_t v14 = a3[8];
  *(void *)(a1 + a3[7]) = *(void *)(a2 + a3[7]);
  uint64_t v15 = a1 + v14;
  uint64_t v16 = a2 + v14;
  uint64_t v17 = sub_100725D30();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v17 - 8) + 32))(v15, v16, v17);
  return a1;
}

uint64_t sub_100453F5C(uint64_t a1, uint64_t a2, int *a3)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(unsigned char *)(a1 + 4) = *(unsigned char *)(a2 + 4);
  uint64_t v6 = *(void *)(a1 + 8);
  unint64_t v7 = *(void *)(a1 + 16);
  *(_OWORD *)(a1 + _Block_object_dispose(&STACK[0x320], 8) = *(_OWORD *)(a2 + 8);
  sub_100442248(v6, v7);
  uint64_t v8 = a3[6];
  uint64_t v9 = (void *)(a1 + v8);
  uint64_t v10 = (void *)(a2 + v8);
  uint64_t v11 = *(void **)(a1 + v8);
  *uint64_t v9 = *v10;

  uint64_t v12 = (void *)v9[1];
  v9[1] = v10[1];

  uint64_t v13 = (int *)type metadata accessor for IDSGroupEncryptionPublicIdentity(0);
  uint64_t v14 = v13[6];
  uint64_t v15 = (char *)v9 + v14;
  uint64_t v16 = (char *)v10 + v14;
  uint64_t v17 = sub_100725CC0();
  (*(void (**)(char *, char *, uint64_t))(*(void *)(v17 - 8) + 40))(v15, v16, v17);
  uint64_t v18 = v13[7];
  id v19 = *(void **)((char *)v9 + v18);
  *(void *)((char *)v9 + v1_Block_object_dispose(&STACK[0x320], 8) = *(void *)((char *)v10 + v18);

  *((unsigned char *)v9 + v13[8]) = *((unsigned char *)v10 + v13[8]);
  uint64_t v20 = a3[8];
  *(void *)(a1 + a3[7]) = *(void *)(a2 + a3[7]);
  uint64_t v21 = a1 + v20;
  uint64_t v22 = a2 + v20;
  uint64_t v23 = sub_100725D30();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v23 - 8) + 40))(v21, v22, v23);
  return a1;
}

uint64_t sub_1004540B4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return _swift_getEnumTagSinglePayloadGeneric(a1, a2, a3, sub_1004540C8);
}

uint64_t sub_1004540C8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 == 252)
  {
    unsigned int v4 = *(unsigned __int8 *)(a1 + 4);
    if (v4 > 3) {
      return (v4 ^ 0xFF) + 1;
    }
    else {
      return 0;
    }
  }
  else
  {
    uint64_t v8 = type metadata accessor for IDSGroupEncryptionPublicIdentity(0);
    uint64_t v9 = *(void *)(v8 - 8);
    if (*(_DWORD *)(v9 + 84) == a2)
    {
      uint64_t v10 = v8;
      uint64_t v11 = a1 + *(int *)(a3 + 24);
      uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v9 + 48);
      return v12(v11, a2, v10);
    }
    else
    {
      uint64_t v13 = sub_100725D30();
      uint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v13 - 8) + 48);
      uint64_t v15 = v13;
      uint64_t v16 = a1 + *(int *)(a3 + 32);
      return v14(v16, a2, v15);
    }
  }
}

uint64_t sub_1004541EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _swift_storeEnumTagSinglePayloadGeneric(a1, a2, a3, a4, sub_100454200);
}

uint64_t sub_100454200(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v5 = result;
  if (a3 == 252)
  {
    *(unsigned char *)(result + 4) = -(char)a2;
  }
  else
  {
    uint64_t v8 = type metadata accessor for IDSGroupEncryptionPublicIdentity(0);
    uint64_t v9 = *(void *)(v8 - 8);
    if (*(_DWORD *)(v9 + 84) == a3)
    {
      uint64_t v10 = v8;
      uint64_t v11 = v5 + *(int *)(a4 + 24);
      uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 56);
      return v12(v11, a2, a2, v10);
    }
    else
    {
      uint64_t v13 = sub_100725D30();
      uint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v13 - 8) + 56);
      uint64_t v15 = v13;
      uint64_t v16 = v5 + *(int *)(a4 + 32);
      return v14(v16, a2, a2, v15);
    }
  }
  return result;
}

uint64_t sub_100454328()
{
  uint64_t result = type metadata accessor for IDSGroupEncryptionPublicIdentity(319);
  if (v1 <= 0x3F)
  {
    uint64_t result = sub_100725D30();
    if (v2 <= 0x3F)
    {
      swift_initStructMetadata();
      return 0;
    }
  }
  return result;
}

void *initializeBufferWithCopyOfBuffer for IDSGroupEncryptionDesiredKeyValueMaterialSet.DataError(void *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if ((unint64_t)*a2 >= 0xFFFFFFFF) {
    swift_errorRetain();
  }
  *a1 = v3;
  return a1;
}

unint64_t destroy for IDSGroupEncryptionDesiredKeyValueMaterialSet.DataError(unint64_t *a1)
{
  unint64_t result = *a1;
  if (result >= 0xFFFFFFFF) {
    return swift_errorRelease();
  }
  return result;
}

unint64_t *assignWithCopy for IDSGroupEncryptionDesiredKeyValueMaterialSet.DataError(unint64_t *a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  if (*a1 < 0xFFFFFFFF)
  {
    if (v3 >= 0xFFFFFFFF) {
      swift_errorRetain();
    }
    *a1 = v3;
  }
  else if (v3 < 0xFFFFFFFF)
  {
    swift_errorRelease();
    *a1 = *a2;
  }
  else
  {
    swift_errorRetain();
    *a1 = v3;
    swift_errorRelease();
  }
  return a1;
}

void *initializeWithTake for IDSGroupEncryptionDesiredKeyValueMaterialSet.DataError(void *result, void *a2)
{
  *unint64_t result = *a2;
  return result;
}

unint64_t *assignWithTake for IDSGroupEncryptionDesiredKeyValueMaterialSet.DataError(unint64_t *a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  if (*a1 < 0xFFFFFFFF) {
    goto LABEL_6;
  }
  if (v3 < 0xFFFFFFFF)
  {
    swift_errorRelease();
LABEL_6:
    *a1 = v3;
    return a1;
  }
  *a1 = v3;
  swift_errorRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for IDSGroupEncryptionDesiredKeyValueMaterialSet.DataError(uint64_t *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0x7FFFFFFE && *((unsigned char *)a1 + 8)) {
    return (*(_DWORD *)a1 + 2147483646);
  }
  uint64_t v3 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v3) = -1;
  }
  unsigned int v4 = v3 + 1;
  unsigned int v5 = v3 - 1;
  if (v4 >= 3) {
    return v5;
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for IDSGroupEncryptionDesiredKeyValueMaterialSet.DataError(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x7FFFFFFD)
  {
    *(void *)unint64_t result = 0;
    *(_DWORD *)unint64_t result = a2 - 2147483646;
    if (a3 >= 0x7FFFFFFE) {
      *(unsigned char *)(result + _Block_object_dispose(&STACK[0x320], 8) = 1;
    }
  }
  else
  {
    if (a3 >= 0x7FFFFFFE) {
      *(unsigned char *)(result + _Block_object_dispose(&STACK[0x320], 8) = 0;
    }
    if (a2) {
      *(void *)unint64_t result = a2 + 1;
    }
  }
  return result;
}

uint64_t sub_100454618(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v1) = -1;
  }
  return (v1 + 1);
}

void *sub_100454630(void *result, int a2)
{
  if (a2 < 0)
  {
    unsigned int v2 = a2 ^ 0x80000000;
  }
  else
  {
    if (!a2) {
      return result;
    }
    unsigned int v2 = a2 - 1;
  }
  *unint64_t result = v2;
  return result;
}

ValueMetadata *type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet.DataError()
{
  return &type metadata for IDSGroupEncryptionDesiredKeyValueMaterialSet.DataError;
}

void type metadata accessor for IDSQRProtoMaterialInfo_MaterialType()
{
  if (!qword_100A45000)
  {
    unint64_t ForeignTypeMetadata = swift_getForeignTypeMetadata();
    if (!v1) {
      atomic_store(ForeignTypeMetadata, (unint64_t *)&qword_100A45000);
    }
  }
}

uint64_t sub_1004546B8(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = sub_100431F80(a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16))(a2, a1, v5);
  return a2;
}

uint64_t sub_10045471C(unint64_t *a1, void (*a2)(uint64_t))
{
  uint64_t result = *a1;
  if (!result)
  {
    a2(255);
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

Class sub_100454780(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = (uint64_t *)(a1 + *a3);
  uint64_t v4 = *v3;
  unint64_t v5 = v3[1];
  sub_100441FD4(*v3, v5);
  v6.super.Class isa = sub_100725B20().super.isa;
  sub_100442248(v4, v5);

  return v6.super.isa;
}

id sub_1004547EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v11 = (char *)objc_allocWithZone(v5);
  uint64_t v12 = &v11[OBJC_IVAR____TtC17identityservicesd32IDSGlobalLinkP2PNegotiatedKeySet_serverSecret];
  *(void *)uint64_t v12 = a1;
  *((void *)v12 + 1) = a2;
  uint64_t v13 = &v11[OBJC_IVAR____TtC17identityservicesd32IDSGlobalLinkP2PNegotiatedKeySet_clientSecret];
  *(void *)uint64_t v13 = a3;
  *((void *)v13 + 1) = a4;
  *(void *)&v11[OBJC_IVAR____TtC17identityservicesd32IDSGlobalLinkP2PNegotiatedKeySet_counters] = a5;
  v15.receiver = v11;
  v15.super_class = v5;
  return objc_msgSendSuper2(&v15, "init");
}

uint64_t type metadata accessor for IDSGlobalLinkP2PNegotiatedKeySet()
{
  return self;
}

unint64_t *sub_1004548A0(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = a2 >> 62;
  uint64_t v3 = (unint64_t *)&_swiftEmptyArrayStorage;
  switch(a2 >> 62)
  {
    case 1uLL:
      if (__OFSUB__(HIDWORD(a1), a1)) {
        goto LABEL_43;
      }
      uint64_t v4 = HIDWORD(a1) - (int)a1;
LABEL_6:
      if (!v4) {
        return v3;
      }
      uint64_t v29 = (unint64_t *)&_swiftEmptyArrayStorage;
      int64_t v7 = v4 & ~(v4 >> 63);
      sub_100455590(0, v7, 0);
      uint64_t v3 = (unint64_t *)&_swiftEmptyArrayStorage;
      if (v2)
      {
        if (v2 == 1) {
          uint64_t v8 = (int)a1;
        }
        else {
          uint64_t v8 = *(void *)(a1 + 16);
        }
        if (v4 < 0)
        {
LABEL_42:
          __break(1u);
LABEL_43:
          __break(1u);
LABEL_44:
          __break(1u);
LABEL_45:
          __break(1u);
LABEL_46:
          __break(1u);
LABEL_47:
          __break(1u);
        }
      }
      else
      {
        if (v4 < 0) {
          goto LABEL_45;
        }
        uint64_t v8 = 0;
      }
      int v25 = v2;
      do
      {
        if (!v7)
        {
          __break(1u);
LABEL_36:
          __break(1u);
LABEL_37:
          __break(1u);
LABEL_38:
          __break(1u);
LABEL_39:
          __break(1u);
LABEL_40:
          __break(1u);
LABEL_41:
          __break(1u);
          goto LABEL_42;
        }
        if (v2)
        {
          if (v2 == 1)
          {
            if (v8 < (int)a1 || v8 >= a1 >> 32) {
              goto LABEL_36;
            }
            uint64_t v9 = sub_100725910();
            if (!v9) {
              goto LABEL_46;
            }
            uint64_t v10 = v9;
            uint64_t v11 = sub_100725940();
            uint64_t v12 = v8 - v11;
            if (__OFSUB__(v8, v11)) {
              goto LABEL_39;
            }
          }
          else
          {
            if (v8 < *(void *)(a1 + 16)) {
              goto LABEL_38;
            }
            if (v8 >= *(void *)(a1 + 24)) {
              goto LABEL_40;
            }
            uint64_t v14 = sub_100725910();
            if (!v14) {
              goto LABEL_47;
            }
            uint64_t v10 = v14;
            uint64_t v15 = sub_100725940();
            uint64_t v12 = v8 - v15;
            if (__OFSUB__(v8, v15)) {
              goto LABEL_41;
            }
          }
          char v13 = *(unsigned char *)(v10 + v12);
        }
        else
        {
          if (v8 >= BYTE6(a2)) {
            goto LABEL_37;
          }
          uint64_t v26 = a1;
          int v27 = a2;
          __int16 v28 = WORD2(a2);
          char v13 = *((unsigned char *)&v26 + v8);
        }
        sub_100431F80(&qword_100A45168);
        uint64_t v16 = swift_allocObject();
        *(_OWORD *)(v16 + 16) = xmmword_100794E30;
        *(void *)(v16 + 56) = &type metadata for UInt8;
        *(void *)(v16 + 64) = &protocol witness table for UInt8;
        *(unsigned char *)(v16 + 32) = v13;
        unint64_t v2 = sub_100726450();
        unint64_t v18 = v17;
        uint64_t v29 = v3;
        unint64_t v20 = v3[2];
        unint64_t v19 = v3[3];
        if (v20 >= v19 >> 1)
        {
          sub_100455590((char *)(v19 > 1), v20 + 1, 1);
          uint64_t v3 = v29;
        }
        v3[2] = v20 + 1;
        uint64_t v21 = &v3[2 * v20];
        void v21[4] = v2;
        void v21[5] = v18;
        ++v8;
        --v7;
        --v4;
        LODWORD(v2) = v25;
      }
      while (v4);
      return v3;
    case 2uLL:
      uint64_t v6 = *(void *)(a1 + 16);
      uint64_t v5 = *(void *)(a1 + 24);
      uint64_t v4 = v5 - v6;
      if (!__OFSUB__(v5, v6)) {
        goto LABEL_6;
      }
      goto LABEL_44;
    case 3uLL:
      return v3;
    default:
      uint64_t v4 = BYTE6(a2);
      goto LABEL_6;
  }
}

uint64_t sub_100454C60()
{
  uint64_t v1 = v0;
  sub_1007269F0(81);
  v9._countAndFlagsBits = 0xD000000000000029;
  v9._xpc_object_t object = (void *)0x80000001008C1040;
  sub_1007264C0(v9);
  swift_bridgeObjectRetain();
  v10._countAndFlagsBits = sub_100726580();
  sub_1007264C0(v10);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  v11._xpc_object_t object = (void *)0x80000001008C1070;
  v11._countAndFlagsBits = 0xD000000000000010;
  sub_1007264C0(v11);
  sub_1004548A0(*(void *)(v1 + OBJC_IVAR____TtC17identityservicesd32IDSGlobalLinkP2PNegotiatedKeySet_serverSecret), *(void *)(v1 + OBJC_IVAR____TtC17identityservicesd32IDSGlobalLinkP2PNegotiatedKeySet_serverSecret + 8));
  sub_100431F80(&qword_100A468E0);
  sub_100454E4C();
  uint64_t v2 = sub_1007263F0();
  uint64_t v4 = v3;
  swift_bridgeObjectRelease();
  v12._countAndFlagsBits = v2;
  v12._xpc_object_t object = v4;
  sub_1007264C0(v12);
  swift_bridgeObjectRelease();
  v13._xpc_object_t object = (void *)0x80000001008C1090;
  v13._countAndFlagsBits = 0xD000000000000010;
  sub_1007264C0(v13);
  sub_1004548A0(*(void *)(v1 + OBJC_IVAR____TtC17identityservicesd32IDSGlobalLinkP2PNegotiatedKeySet_clientSecret), *(void *)(v1 + OBJC_IVAR____TtC17identityservicesd32IDSGlobalLinkP2PNegotiatedKeySet_clientSecret + 8));
  uint64_t v5 = sub_1007263F0();
  int64_t v7 = v6;
  swift_bridgeObjectRelease();
  v14._countAndFlagsBits = v5;
  v14._xpc_object_t object = v7;
  sub_1007264C0(v14);
  swift_bridgeObjectRelease();
  v15._countAndFlagsBits = 15882;
  v15._xpc_object_t object = (void *)0xE200000000000000;
  sub_1007264C0(v15);
  return 0;
}

unint64_t sub_100454E4C()
{
  unint64_t result = qword_100A45030;
  if (!qword_100A45030)
  {
    sub_100440798(&qword_100A468E0);
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_100A45030);
  }
  return result;
}

unint64_t sub_100454EC0()
{
  sub_1007269F0(44);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRetain();
  v1._countAndFlagsBits = sub_100726580();
  sub_1007264C0(v1);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  v2._countAndFlagsBits = 62;
  v2._xpc_object_t object = (void *)0xE100000000000000;
  sub_1007264C0(v2);
  return 0xD000000000000029;
}

id sub_100454FA8()
{
  return sub_10045550C(type metadata accessor for IDSGlobalLinkP2PNegotiatedKeySet);
}

id sub_10045509C(char a1, uint64_t a2, uint64_t a3)
{
  int64_t v7 = objc_allocWithZone(v3);
  v7[OBJC_IVAR____TtC17identityservicesd30IDSGlobalLinkP2PNegotiatedKeys_isServer] = a1;
  *(void *)&v7[OBJC_IVAR____TtC17identityservicesd30IDSGlobalLinkP2PNegotiatedKeys_avc] = a2;
  *(void *)&v7[OBJC_IVAR____TtC17identityservicesd30IDSGlobalLinkP2PNegotiatedKeys_ids] = a3;
  v9.receiver = v7;
  v9.super_class = v3;
  return objc_msgSendSuper2(&v9, "init");
}

uint64_t type metadata accessor for IDSGlobalLinkP2PNegotiatedKeys()
{
  return self;
}

uint64_t sub_100455138()
{
  uint64_t v1 = v0;
  sub_1007269F0(56);
  v12._xpc_object_t object = (void *)0x80000001008C10F0;
  v12._countAndFlagsBits = 0xD000000000000021;
  sub_1007264C0(v12);
  if (*(unsigned char *)(v0 + OBJC_IVAR____TtC17identityservicesd30IDSGlobalLinkP2PNegotiatedKeys_isServer)) {
    v2._countAndFlagsBits = 0x726576726553;
  }
  else {
    v2._countAndFlagsBits = 0x746E65696C43;
  }
  v2._xpc_object_t object = (void *)0xE600000000000000;
  sub_1007264C0(v2);
  swift_bridgeObjectRelease();
  v13._countAndFlagsBits = 0x3D63766120200A29;
  v13._xpc_object_t object = (void *)0xE800000000000000;
  sub_1007264C0(v13);
  id v3 = [*(id *)(v0 + OBJC_IVAR____TtC17identityservicesd30IDSGlobalLinkP2PNegotiatedKeys_avc) sensitiveDescription];
  uint64_t v4 = sub_100726430();
  uint64_t v6 = v5;

  v14._countAndFlagsBits = v4;
  v14._xpc_object_t object = v6;
  sub_1007264C0(v14);
  swift_bridgeObjectRelease();
  v15._countAndFlagsBits = 0x3D73646920200ALL;
  v15._xpc_object_t object = (void *)0xE700000000000000;
  sub_1007264C0(v15);
  id v7 = [*(id *)(v1 + OBJC_IVAR____TtC17identityservicesd30IDSGlobalLinkP2PNegotiatedKeys_ids) sensitiveDescription];
  uint64_t v8 = sub_100726430();
  Swift::String v10 = v9;

  v16._countAndFlagsBits = v8;
  v16._xpc_object_t object = v10;
  sub_1007264C0(v16);
  swift_bridgeObjectRelease();
  v17._countAndFlagsBits = 15882;
  v17._xpc_object_t object = (void *)0xE200000000000000;
  sub_1007264C0(v17);
  return 0;
}

id sub_1004552E4(void *a1, uint64_t a2, void (*a3)(void))
{
  id v4 = a1;
  a3();

  NSString v5 = sub_100726420();
  swift_bridgeObjectRelease();

  return v5;
}

uint64_t sub_100455354()
{
  sub_1007269F0(56);
  v3._xpc_object_t object = (void *)0x80000001008C10F0;
  v3._countAndFlagsBits = 0xD000000000000021;
  sub_1007264C0(v3);
  if (*(unsigned char *)(v0 + OBJC_IVAR____TtC17identityservicesd30IDSGlobalLinkP2PNegotiatedKeys_isServer)) {
    v1._countAndFlagsBits = 0x726576726553;
  }
  else {
    v1._countAndFlagsBits = 0x746E65696C43;
  }
  v1._xpc_object_t object = (void *)0xE600000000000000;
  sub_1007264C0(v1);
  swift_bridgeObjectRelease();
  v4._countAndFlagsBits = 0x3D63766120200A29;
  v4._xpc_object_t object = (void *)0xE800000000000000;
  sub_1007264C0(v4);
  sub_100431F80(&qword_100A450B0);
  sub_100726A90();
  v5._countAndFlagsBits = 0x3D73646920200ALL;
  v5._xpc_object_t object = (void *)0xE700000000000000;
  sub_1007264C0(v5);
  sub_100726A90();
  v6._countAndFlagsBits = 15882;
  v6._xpc_object_t object = (void *)0xE200000000000000;
  sub_1007264C0(v6);
  return 0;
}

id sub_1004554F4()
{
  return sub_10045550C(type metadata accessor for IDSGlobalLinkP2PNegotiatedKeys);
}

id sub_10045550C(uint64_t (*a1)(void))
{
  v3.receiver = v1;
  v3.super_class = (Class)a1();
  return objc_msgSendSuper2(&v3, "dealloc");
}

char *sub_100455590(char *a1, int64_t a2, char a3)
{
  unint64_t result = sub_1004555B0(a1, a2, a3, *v3);
  *objc_super v3 = result;
  return result;
}

char *sub_1004555B0(char *result, int64_t a2, char a3, char *a4)
{
  char v5 = (char)result;
  if (a3)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        return result;
      }
      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
        int64_t v7 = a2;
      }
    }
  }
  else
  {
    int64_t v7 = a2;
  }
  uint64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    uint64_t v9 = *((void *)a4 + 2);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    sub_100431F80((uint64_t *)&unk_100A45170);
    Swift::String v10 = (char *)swift_allocObject();
    int64_t v11 = j__malloc_size(v10);
    uint64_t v12 = v11 - 32;
    if (v11 < 32) {
      uint64_t v12 = v11 - 17;
    }
    *((void *)v10 + 2) = v8;
    *((void *)v10 + 3) = 2 * (v12 >> 4);
  }
  else
  {
    Swift::String v10 = (char *)&_swiftEmptyArrayStorage;
  }
  Swift::String v13 = v10 + 32;
  Swift::String v14 = a4 + 32;
  if (v5)
  {
    if (v10 != a4 || v13 >= &v14[16 * v8]) {
      memmove(v13, v14, 16 * v8);
    }
    *((void *)a4 + 2) = 0;
  }
  else
  {
    swift_arrayInitWithCopy();
  }
  swift_release();
  return v10;
}

uint64_t type metadata accessor for IDSDSessionKeyValueDeliveryLocalEntry(uint64_t a1)
{
  return sub_100440FD0(a1, (uint64_t *)&unk_100A4D2B8);
}

unint64_t sub_1004556D4(uint64_t a1)
{
  uint64_t v2 = sub_100431F80(&qword_100A45478);
  uint64_t v3 = *(void *)(v2 - 8);
  __chkstk_darwin(v2, v4);
  unint64_t v6 = (char *)v23 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (!*(void *)(a1 + 16))
  {
    uint64_t v8 = &_swiftEmptyDictionarySingleton;
    goto LABEL_9;
  }
  sub_100431F80(&qword_100A45450);
  uint64_t v7 = sub_100726BE0();
  uint64_t v8 = (void *)v7;
  uint64_t v9 = *(void *)(a1 + 16);
  if (!v9)
  {
LABEL_9:
    swift_bridgeObjectRelease();
    return (unint64_t)v8;
  }
  uint64_t v10 = *(int *)(v2 + 48);
  uint64_t v11 = v7 + 64;
  unint64_t v12 = (*(unsigned __int8 *)(v3 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80);
  v23[1] = a1;
  uint64_t v13 = a1 + v12;
  uint64_t v14 = *(void *)(v3 + 72);
  swift_retain();
  while (1)
  {
    sub_1004546B8(v13, (uint64_t)v6, &qword_100A45478);
    unint64_t result = sub_10045C63C((uint64_t)v6);
    if (v16) {
      break;
    }
    unint64_t v17 = result;
    *(void *)(v11 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << result;
    uint64_t v18 = v8[6];
    uint64_t v19 = sub_100725D30();
    unint64_t result = (*(uint64_t (**)(unint64_t, char *, uint64_t))(*(void *)(v19 - 8) + 32))(v18 + *(void *)(*(void *)(v19 - 8) + 72) * v17, v6, v19);
    *(void *)(v8[7] + 8 * v17) = *(void *)&v6[v10];
    uint64_t v20 = v8[2];
    BOOL v21 = __OFADD__(v20, 1);
    uint64_t v22 = v20 + 1;
    if (v21) {
      goto LABEL_11;
    }
    v8[2] = v22;
    v13 += v14;
    if (!--v9)
    {
      swift_release();
      goto LABEL_9;
    }
  }
  __break(1u);
LABEL_11:
  __break(1u);
  return result;
}

unint64_t sub_1004558C8(uint64_t a1)
{
  if (!*(void *)(a1 + 16))
  {
    uint64_t v2 = &_swiftEmptyDictionarySingleton;
    goto LABEL_9;
  }
  sub_100431F80(&qword_100A45460);
  uint64_t v2 = (void *)sub_100726BE0();
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3)
  {
LABEL_9:
    swift_bridgeObjectRelease();
    return (unint64_t)v2;
  }
  swift_retain();
  uint64_t v4 = (uint64_t *)(a1 + 40);
  while (1)
  {
    uint64_t v5 = *v4;
    id v6 = (id)*(v4 - 1);
    swift_bridgeObjectRetain();
    unint64_t result = sub_10045C740((uint64_t)v6);
    if (v8) {
      break;
    }
    *(void *)((char *)v2 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8) + 64) |= 1 << result;
    uint64_t v9 = 8 * result;
    *(void *)(v2[6] + v9) = v6;
    *(void *)(v2[7] + v9) = v5;
    uint64_t v10 = v2[2];
    BOOL v11 = __OFADD__(v10, 1);
    uint64_t v12 = v10 + 1;
    if (v11) {
      goto LABEL_11;
    }
    v2[2] = v12;
    v4 += 2;
    if (!--v3)
    {
      swift_release();
      goto LABEL_9;
    }
  }
  __break(1u);
LABEL_11:
  __break(1u);
  return result;
}

unint64_t sub_1004559D4(uint64_t a1)
{
  if (!*(void *)(a1 + 16))
  {
    uint64_t v2 = &_swiftEmptyDictionarySingleton;
    goto LABEL_9;
  }
  sub_100431F80(&qword_100A45468);
  uint64_t v2 = (void *)sub_100726BE0();
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3)
  {
LABEL_9:
    swift_bridgeObjectRelease();
    return (unint64_t)v2;
  }
  swift_retain();
  uint64_t v4 = (unint64_t *)(a1 + 48);
  while (1)
  {
    uint64_t v5 = *(v4 - 1);
    unint64_t v6 = *v4;
    id v7 = (id)*(v4 - 2);
    sub_100441FD4(v5, v6);
    unint64_t result = sub_10045C740((uint64_t)v7);
    if (v9) {
      break;
    }
    *(void *)((char *)v2 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8) + 64) |= 1 << result;
    *(void *)(v2[6] + 8 * result) = v7;
    uint64_t v10 = (uint64_t *)(v2[7] + 16 * result);
    *uint64_t v10 = v5;
    v10[1] = v6;
    uint64_t v11 = v2[2];
    BOOL v12 = __OFADD__(v11, 1);
    uint64_t v13 = v11 + 1;
    if (v12) {
      goto LABEL_11;
    }
    v4 += 3;
    v2[2] = v13;
    if (!--v3)
    {
      swift_release();
      goto LABEL_9;
    }
  }
  __break(1u);
LABEL_11:
  __break(1u);
  return result;
}

uint64_t variable initialization expression of IDSDSessionKeyValueDelivery.l()
{
  return sub_1004DFE9C(12);
}

uint64_t variable initialization expression of IDSDSessionKeyValueDelivery.participantProvider()
{
  return 0;
}

uint64_t sub_100455B04()
{
  return swift_unknownObjectWeakLoadStrong();
}

uint64_t sub_100455B54(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = v2 + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_participantProvider;
  swift_beginAccess();
  *(void *)(v4 + _Block_object_dispose(&STACK[0x320], 8) = a2;
  swift_unknownObjectWeakAssign();
  return swift_unknownObjectRelease();
}

void (*sub_100455BC0(void *a1))(uint64_t a1, char a2)
{
  uint64_t v3 = malloc(0x38uLL);
  *a1 = v3;
  uint64_t v4 = OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_participantProvider;
  void v3[5] = v1;
  void v3[6] = v4;
  uint64_t v5 = v1 + v4;
  swift_beginAccess();
  uint64_t Strong = swift_unknownObjectWeakLoadStrong();
  uint64_t v7 = *(void *)(v5 + 8);
  void v3[3] = Strong;
  void v3[4] = v7;
  return sub_100455C48;
}

void sub_100455C48(uint64_t a1, char a2)
{
  uint64_t v3 = *(void **)a1;
  *(void *)(*(void *)(*(void *)a1 + 40) + *(void *)(*(void *)a1 + 48) + _Block_object_dispose(&STACK[0x320], 8) = *(void *)(*(void *)a1 + 32);
  swift_unknownObjectWeakAssign();
  if (a2)
  {
    swift_unknownObjectRelease();
    swift_endAccess();
  }
  else
  {
    swift_endAccess();
    swift_unknownObjectRelease();
  }

  free(v3);
}

uint64_t variable initialization expression of IDSDSessionKeyValueDelivery.state()
{
  swift_unknownObjectWeakInit();
  v2[1] = sub_1004556D4((uint64_t)&_swiftEmptyArrayStorage);
  v2[2] = sub_1004609D0((uint64_t)&_swiftEmptyArrayStorage);
  v2[3] = sub_100460AD4((uint64_t)&_swiftEmptyArrayStorage);
  sub_100460C98((uint64_t)v2, (uint64_t)v3);
  sub_100431F80((uint64_t *)&unk_100A451E0);
  uint64_t v0 = swift_allocObject();
  *(_DWORD *)(v0 + 4_Block_object_dispose(&STACK[0x320], 8) = 0;
  sub_100460CDC(v3, (void *)(v0 + 16));
  sub_100460CEC((uint64_t)v3);
  return v0;
}

id sub_100455D70(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v17 = *(void *)(a7 + 24);
  uint64_t v16 = *(void *)(a7 + 32);
  uint64_t v18 = sub_100460D14(a7, v17);
  id v19 = sub_1004610D0(a1, a2, a3, a4, a5, a6, v18, a8, a9, v9, v17, v16);
  swift_unknownObjectRelease();

  swift_unknownObjectRelease();
  swift_unknownObjectRelease();
  sub_10044C6AC(a7);
  return v19;
}

id IDSDSessionKeyValueDelivery.__deallocating_deinit()
{
  uint64_t v1 = *(void *)&v0[OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_state];
  swift_retain();
  os_unfair_lock_lock((os_unfair_lock_t)(v1 + 48));
  sub_100455ED4((void *)(v1 + 16));
  os_unfair_lock_unlock((os_unfair_lock_t)(v1 + 48));
  swift_release();
  v3.receiver = v0;
  v3.super_class = (Class)type metadata accessor for IDSDSessionKeyValueDelivery(0);
  return objc_msgSendSuper2(&v3, "dealloc");
}

uint64_t sub_100455ED4(void *a1)
{
  swift_unknownObjectWeakAssign();
  unint64_t v2 = sub_1004556D4((uint64_t)&_swiftEmptyArrayStorage);
  swift_bridgeObjectRelease();
  a1[1] = v2;
  unint64_t v3 = sub_1004609D0((uint64_t)&_swiftEmptyArrayStorage);
  swift_bridgeObjectRelease();
  a1[2] = v3;
  unint64_t v4 = sub_100460AD4((uint64_t)&_swiftEmptyArrayStorage);
  uint64_t result = swift_bridgeObjectRelease();
  a1[3] = v4;
  return result;
}

uint64_t sub_1004560DC(uint64_t a1)
{
  unint64_t v2 = sub_1004558C8((uint64_t)&_swiftEmptyArrayStorage);
  uint64_t v47 = a1 + 64;
  uint64_t v3 = 1 << *(unsigned char *)(a1 + 32);
  if (v3 < 64) {
    uint64_t v4 = ~(-1 << v3);
  }
  else {
    uint64_t v4 = -1;
  }
  unint64_t v5 = v4 & *(void *)(a1 + 64);
  int64_t v48 = (unint64_t)(v3 + 63) >> 6;
  uint64_t v49 = a1;
  swift_bridgeObjectRetain();
  int64_t v6 = 0;
LABEL_6:
  unint64_t v53 = v2;
  if (!v5)
  {
    int64_t v10 = v6 + 1;
    if (__OFADD__(v6, 1)) {
      goto LABEL_60;
    }
    if (v10 >= v48) {
      goto LABEL_56;
    }
    unint64_t v11 = *(void *)(v47 + 8 * v10);
    int64_t v12 = v6 + 1;
    if (!v11)
    {
      int64_t v12 = v6 + 2;
      if (v6 + 2 >= v48) {
        goto LABEL_56;
      }
      unint64_t v11 = *(void *)(v47 + 8 * v12);
      if (!v11)
      {
        int64_t v12 = v6 + 3;
        if (v6 + 3 >= v48) {
          goto LABEL_56;
        }
        unint64_t v11 = *(void *)(v47 + 8 * v12);
        if (!v11)
        {
          uint64_t v13 = v6 + 4;
          if (v6 + 4 < v48)
          {
            unint64_t v11 = *(void *)(v47 + 8 * v13);
            if (v11)
            {
              int64_t v12 = v6 + 4;
              goto LABEL_21;
            }
            while (1)
            {
              int64_t v12 = v13 + 1;
              if (__OFADD__(v13, 1)) {
                goto LABEL_61;
              }
              if (v12 >= v48) {
                break;
              }
              unint64_t v11 = *(void *)(v47 + 8 * v12);
              ++v13;
              if (v11) {
                goto LABEL_21;
              }
            }
          }
LABEL_56:
          swift_release();
          return v2;
        }
      }
    }
LABEL_21:
    uint64_t v51 = (v11 - 1) & v11;
    int64_t v52 = v12;
    unint64_t v9 = __clz(__rbit64(v11)) + (v12 << 6);
    goto LABEL_22;
  }
  uint64_t v51 = (v5 - 1) & v5;
  int64_t v52 = v6;
  unint64_t v9 = __clz(__rbit64(v5)) | (v6 << 6);
LABEL_22:
  unsigned int v50 = *(_DWORD *)(*(void *)(v49 + 48) + 4 * v9);
  uint64_t v14 = *(void *)(*(void *)(v49 + 56) + 8 * v9);
  swift_bridgeObjectRetain();
  Swift::String v15 = (void *)sub_1004559D4((uint64_t)&_swiftEmptyArrayStorage);
  int64_t v16 = 0;
  uint64_t v54 = v14 + 64;
  uint64_t v17 = 1 << *(unsigned char *)(v14 + 32);
  if (v17 < 64) {
    uint64_t v18 = ~(-1 << v17);
  }
  else {
    uint64_t v18 = -1;
  }
  unint64_t v19 = v18 & *(void *)(v14 + 64);
  int64_t v55 = (unint64_t)(v17 + 63) >> 6;
  uint64_t v56 = v14;
  while (1)
  {
    if (v19)
    {
      unint64_t v21 = __clz(__rbit64(v19));
      v19 &= v19 - 1;
      unint64_t v22 = v21 | (v16 << 6);
    }
    else
    {
      int64_t v23 = v16 + 1;
      if (__OFADD__(v16, 1)) {
        goto LABEL_58;
      }
      if (v23 >= v55)
      {
LABEL_5:
        swift_release();
        id v7 = [objc_allocWithZone((Class)NSNumber) initWithUnsignedInt:v50];
        char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
        sub_10045E630((uint64_t)v15, v7, isUniquelyReferenced_nonNull_native);
        unint64_t v2 = v53;

        swift_bridgeObjectRelease();
        unint64_t v5 = v51;
        int64_t v6 = v52;
        goto LABEL_6;
      }
      unint64_t v24 = *(void *)(v54 + 8 * v23);
      ++v16;
      if (!v24)
      {
        int64_t v16 = v23 + 1;
        if (v23 + 1 >= v55) {
          goto LABEL_5;
        }
        unint64_t v24 = *(void *)(v54 + 8 * v16);
        if (!v24)
        {
          int64_t v16 = v23 + 2;
          if (v23 + 2 >= v55) {
            goto LABEL_5;
          }
          unint64_t v24 = *(void *)(v54 + 8 * v16);
          if (!v24)
          {
            int64_t v25 = v23 + 3;
            if (v25 >= v55) {
              goto LABEL_5;
            }
            unint64_t v24 = *(void *)(v54 + 8 * v25);
            if (!v24)
            {
              while (1)
              {
                int64_t v16 = v25 + 1;
                if (__OFADD__(v25, 1)) {
                  goto LABEL_59;
                }
                if (v16 >= v55) {
                  goto LABEL_5;
                }
                unint64_t v24 = *(void *)(v54 + 8 * v16);
                ++v25;
                if (v24) {
                  goto LABEL_43;
                }
              }
            }
            int64_t v16 = v25;
          }
        }
      }
LABEL_43:
      unint64_t v19 = (v24 - 1) & v24;
      unint64_t v22 = __clz(__rbit64(v24)) + (v16 << 6);
    }
    uint64_t v26 = *(void *)(*(void *)(v56 + 48) + 8 * v22);
    int v27 = (uint64_t *)(*(void *)(v56 + 56) + 16 * v22);
    uint64_t v28 = *v27;
    unint64_t v29 = v27[1];
    id v30 = objc_allocWithZone((Class)NSNumber);
    sub_100441FD4(v28, v29);
    id v31 = [v30 initWithUnsignedLongLong:v26];
    sub_100441FD4(v28, v29);
    char v32 = swift_isUniquelyReferenced_nonNull_native();
    unint64_t v2 = (unint64_t)v15;
    unint64_t v34 = sub_10045C740((uint64_t)v31);
    uint64_t v35 = v15[2];
    BOOL v36 = (v33 & 1) == 0;
    uint64_t v37 = v35 + v36;
    if (__OFADD__(v35, v36))
    {
      __break(1u);
      goto LABEL_56;
    }
    char v38 = v33;
    if (v15[3] >= v37)
    {
      if (v32)
      {
        if (v33) {
          goto LABEL_26;
        }
      }
      else
      {
        sub_10045F01C();
        if (v38) {
          goto LABEL_26;
        }
      }
    }
    else
    {
      sub_10045D108(v37, v32);
      unint64_t v39 = sub_10045C740((uint64_t)v31);
      if ((v38 & 1) != (v40 & 1)) {
        goto LABEL_62;
      }
      unint64_t v34 = v39;
      if (v38)
      {
LABEL_26:
        uint64_t v20 = v15[7] + 16 * v34;
        sub_100442248(*(void *)v20, *(void *)(v20 + 8));
        *(void *)uint64_t v20 = v28;
        *(void *)(v20 + _Block_object_dispose(&STACK[0x320], 8) = v29;
        goto LABEL_27;
      }
    }
    v15[(v34 >> 6) + 8] |= 1 << v34;
    *(void *)(v15[6] + 8 * v34) = v31;
    os_log_type_t v41 = (uint64_t *)(v15[7] + 16 * v34);
    *os_log_type_t v41 = v28;
    v41[1] = v29;
    uint64_t v42 = v15[2];
    BOOL v43 = __OFADD__(v42, 1);
    uint64_t v44 = v42 + 1;
    if (v43) {
      break;
    }
    _OWORD v15[2] = v44;
    id v45 = v31;
LABEL_27:

    swift_bridgeObjectRelease();
    sub_100442248(v28, v29);
  }
  __break(1u);
LABEL_58:
  __break(1u);
LABEL_59:
  __break(1u);
LABEL_60:
  __break(1u);
LABEL_61:
  __break(1u);
LABEL_62:
  sub_100462C50(0, (unint64_t *)&unk_100A468F0);
  uint64_t result = sub_100726D40();
  __break(1u);
  return result;
}

uint64_t sub_1004565A4(uint64_t a1, Swift::UInt32 a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = sub_100431F80(&qword_100A453A8);
  __chkstk_darwin(v6 - 8, v7);
  unint64_t v9 = (char *)&v22 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = type metadata accessor for IDSDSessionKeyValueDeliveryLocalEntry(0);
  uint64_t v11 = *(void *)(v10 - 8);
  __chkstk_darwin(v10, v12);
  uint64_t v14 = (char *)&v22 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v11 + 48))(a1, 1, v10) == 1)
  {
    sub_10044C150(a1, &qword_100A453A8);
    unint64_t v15 = sub_10045C6D4(a2);
    if (v16)
    {
      unint64_t v17 = v15;
      char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
      uint64_t v19 = *v3;
      uint64_t v23 = *v3;
      *uint64_t v3 = 0x8000000000000000;
      if ((isUniquelyReferenced_nonNull_native & 1) == 0)
      {
        sub_10045F7D0();
        uint64_t v19 = v23;
      }
      sub_10046129C(*(void *)(v19 + 56) + *(void *)(v11 + 72) * v17, (uint64_t)v9, type metadata accessor for IDSDSessionKeyValueDeliveryLocalEntry);
      sub_10045E43C(v17, v19);
      *uint64_t v3 = v19;
      swift_bridgeObjectRelease();
      (*(void (**)(char *, void, uint64_t, uint64_t))(v11 + 56))(v9, 0, 1, v10);
    }
    else
    {
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v11 + 56))(v9, 1, 1, v10);
    }
    return sub_10044C150((uint64_t)v9, &qword_100A453A8);
  }
  else
  {
    sub_10046129C(a1, (uint64_t)v14, type metadata accessor for IDSDSessionKeyValueDeliveryLocalEntry);
    char v20 = swift_isUniquelyReferenced_nonNull_native();
    uint64_t v23 = *v3;
    *uint64_t v3 = 0x8000000000000000;
    sub_10045EBC4((uint64_t)v14, a2, v20);
    *uint64_t v3 = v23;
    return swift_bridgeObjectRelease();
  }
}

void IDSDSessionKeyValueDelivery.add(deliveryHandler:uuid:)()
{
  uint64_t v1 = *(os_unfair_lock_s **)(v0 + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_state);
  uint64_t v2 = (uint64_t)&v1[4];
  uint64_t v3 = v1 + 12;
  os_unfair_lock_lock(v1 + 12);
  sub_100461240(v2);
  os_unfair_lock_unlock(v3);
}

void sub_10045686C(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  uint64_t v61 = a1;
  uint64_t v7 = sub_100725D30();
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v10 = __chkstk_darwin(v7, v9);
  int v57 = (char *)&v54 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = __chkstk_darwin(v10, v12);
  char v59 = (char *)&v54 - v14;
  __chkstk_darwin(v13, v15);
  unint64_t v17 = (char *)&v54 - v16;
  uint64_t v18 = (char *)a2 + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_l;
  uint64_t v19 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 16);
  uint64_t v63 = a3;
  v19((char *)&v54 - v16, a3, v7);
  uint64_t v60 = v18;
  char v20 = sub_100725EB0();
  os_log_type_t v21 = sub_1007266E0();
  BOOL v22 = os_log_type_enabled(v20, v21);
  uint64_t v62 = v19;
  if (v22)
  {
    uint64_t v23 = swift_slowAlloc();
    int64_t v55 = a4;
    unint64_t v24 = (uint8_t *)v23;
    uint64_t v25 = swift_slowAlloc();
    uint64_t v56 = a2;
    uint64_t v65 = v25;
    uint64_t v58 = v8;
    *(_DWORD *)unint64_t v24 = 136315138;
    sub_1004614A0(&qword_100A45210, (void (*)(uint64_t))&type metadata accessor for UUID);
    uint64_t v26 = sub_100726D00();
    uint64_t v64 = sub_10043E578(v26, v27, &v65);
    uint64_t v8 = v58;
    sub_100726830();
    swift_bridgeObjectRelease();
    uint64_t v28 = *(void (**)(char *, uint64_t))(v8 + 8);
    v28(v17, v7);
    _os_log_impl((void *)&_mh_execute_header, v20, v21, "add delivery handler with uuid %s", v24, 0xCu);
    swift_arrayDestroy();
    a2 = v56;
    swift_slowDealloc();
    a4 = v55;
    swift_slowDealloc();
  }
  else
  {

    uint64_t v28 = *(void (**)(char *, uint64_t))(v8 + 8);
    v28(v17, v7);
  }
  uint64_t v29 = v61;
  uint64_t v30 = v63;
  id v31 = (uint64_t *)(v61 + 8);
  uint64_t v32 = *(void *)(v61 + 8);
  if (*(void *)(v32 + 16) && (v33 = sub_10045C63C(v63), uint64_t v30 = v63, (v34 & 1) != 0))
  {
    uint64_t v58 = v8;
    uint64_t v35 = *(void **)(*(void *)(v32 + 56) + 8 * v33);
    BOOL v36 = v57;
    v62(v57, v63, v7);
    swift_unknownObjectRetain_n();
    uint64_t v37 = sub_100725EB0();
    os_log_type_t v38 = sub_1007266E0();
    if (os_log_type_enabled(v37, v38))
    {
      uint64_t v39 = swift_slowAlloc();
      uint64_t v63 = swift_slowAlloc();
      uint64_t v65 = v63;
      *(_DWORD *)uint64_t v39 = 136315394;
      sub_1004614A0(&qword_100A45210, (void (*)(uint64_t))&type metadata accessor for UUID);
      uint64_t v40 = sub_100726D00();
      uint64_t v64 = sub_10043E578(v40, v41, &v65);
      sub_100726830();
      swift_bridgeObjectRelease();
      v28(v36, v7);
      *(_WORD *)(v39 + 12) = 2080;
      id v42 = [v35 description];
      uint64_t v43 = sub_100726430();
      unint64_t v45 = v44;

      uint64_t v64 = sub_10043E578(v43, v45, &v65);
      sub_100726830();
      swift_unknownObjectRelease_n();
      swift_bridgeObjectRelease();
      _os_log_impl((void *)&_mh_execute_header, v37, v38, "... already added handler with uuid %s: %s", (uint8_t *)v39, 0x16u);
      swift_arrayDestroy();
      swift_slowDealloc();
      swift_slowDealloc();

      swift_unknownObjectRelease();
    }
    else
    {

      swift_unknownObjectRelease();
      v28(v36, v7);
      swift_unknownObjectRelease_n();
    }
  }
  else
  {
    uint64_t v46 = (uint64_t)v59;
    v62(v59, v30, v7);
    if (a4)
    {
      swift_unknownObjectRetain();
      char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
      uint64_t v65 = *v31;
      *id v31 = 0x8000000000000000;
      sub_10045E7A4((uint64_t)a4, v46, isUniquelyReferenced_nonNull_native);
      *id v31 = v65;
      swift_bridgeObjectRelease();
      v28((char *)v46, v7);
    }
    else
    {
      sub_10045CD38(v46);
      v28((char *)v46, v7);
      swift_unknownObjectRelease();
    }
    int64_t v48 = sub_100725EB0();
    os_log_type_t v49 = sub_1007266E0();
    if (os_log_type_enabled(v48, v49))
    {
      unsigned int v50 = (uint8_t *)swift_slowAlloc();
      *(_WORD *)unsigned int v50 = 0;
      _os_log_impl((void *)&_mh_execute_header, v48, v49, "sending all cached data to the new delivery handler", v50, 2u);
      swift_slowDealloc();
    }

    if (a4)
    {
      (*(void (**)(void))((swift_isaMask & *a2) + 0xB0))(*(void *)(v29 + 16));
      sub_100462C50(0, (unint64_t *)&unk_100A468F0);
      sub_100431F80(&qword_100A453E8);
      sub_100462B7C();
      Class isa = sub_100726380().super.isa;
      swift_bridgeObjectRelease();
      [a4 handleGroupSessionKeyValues:isa];
    }
    id v52 = [*(id *)((char *)a2 + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_metricsCollector) keyValueDelivery];
    NSString v53 = sub_100726420();
    [v52 event:v53];
  }
}

void IDSDSessionKeyValueDelivery.remove(deliveryHandlerWithUUID:)()
{
  uint64_t v1 = *(os_unfair_lock_s **)(v0 + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_state);
  uint64_t v2 = (uint64_t)&v1[4];
  uint64_t v3 = v1 + 12;
  os_unfair_lock_lock(v1 + 12);
  sub_100461270(v2);
  os_unfair_lock_unlock(v3);
}

uint64_t sub_100457044(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = sub_100725D30();
  uint64_t v6 = *(void *)(v5 - 8);
  __chkstk_darwin(v5, v7);
  uint64_t v9 = (char *)&v17 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v9, a3, v5);
  uint64_t v10 = sub_100725EB0();
  os_log_type_t v11 = sub_1007266E0();
  if (os_log_type_enabled(v10, v11))
  {
    uint64_t v12 = swift_slowAlloc();
    uint64_t v17 = a1;
    uint64_t v13 = (uint8_t *)v12;
    uint64_t v20 = swift_slowAlloc();
    *(_DWORD *)uint64_t v13 = 136315138;
    uint64_t v18 = a3;
    sub_1004614A0(&qword_100A45210, (void (*)(uint64_t))&type metadata accessor for UUID);
    uint64_t v14 = sub_100726D00();
    uint64_t v19 = sub_10043E578(v14, v15, &v20);
    a3 = v18;
    sub_100726830();
    swift_bridgeObjectRelease();
    (*(void (**)(char *, uint64_t))(v6 + 8))(v9, v5);
    _os_log_impl((void *)&_mh_execute_header, v10, v11, "remove delivery handler with uuid %s", v13, 0xCu);
    swift_arrayDestroy();
    swift_slowDealloc();
    swift_slowDealloc();
  }
  else
  {

    (*(void (**)(char *, uint64_t))(v6 + 8))(v9, v5);
  }
  sub_10045CD38(a3);
  return swift_unknownObjectRelease();
}

uint64_t IDSDSessionKeyValueDelivery.addHandler(_:uuid:)()
{
  return (*(uint64_t (**)(void))((swift_isaMask & *v0) + 0xB8))();
}

uint64_t IDSDSessionKeyValueDelivery.removeHandler(_:)()
{
  return (*(uint64_t (**)(void))((swift_isaMask & *v0) + 0xC0))();
}

uint64_t sub_100457578(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void *)((char *)v2 + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_groupID);
  unint64_t v3 = *(void *)((char *)v2 + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_groupID + 8);
  BOOL v5 = v4 == a1 && v3 == a2;
  if (v5 || (sub_100726D20() & 1) != 0) {
    return (*(uint64_t (**)(void))((swift_isaMask & *v2) + 0xE0))();
  }
  swift_bridgeObjectRetain_n();
  uint64_t v9 = v2;
  uint64_t v10 = sub_100725EB0();
  os_log_type_t v11 = sub_1007266C0();
  if (os_log_type_enabled(v10, v11))
  {
    uint64_t v12 = swift_slowAlloc();
    uint64_t v13 = swift_slowAlloc();
    *(_DWORD *)uint64_t v12 = 136315650;
    sub_10043E578(0xD000000000000033, 0x80000001008C12F0, &v13);
    sub_100726830();
    *(_WORD *)(v12 + 12) = 2080;
    swift_bridgeObjectRetain();
    sub_10043E578(a1, a2, &v13);
    sub_100726830();
    swift_bridgeObjectRelease_n();
    *(_WORD *)(v12 + 22) = 2080;
    swift_bridgeObjectRetain();
    sub_10043E578(v4, v3, &v13);
    sub_100726830();

    swift_bridgeObjectRelease();
    _os_log_impl((void *)&_mh_execute_header, v10, v11, "%s: groupID doesn't match: %s, %s", (uint8_t *)v12, 0x20u);
    swift_arrayDestroy();
    swift_slowDealloc();
    swift_slowDealloc();
  }
  else
  {

    swift_bridgeObjectRelease_n();
  }

  return 0;
}

id IDSDSessionKeyValueDelivery.objcMaterials.getter()
{
  uint64_t v1 = type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet();
  __chkstk_darwin(v1 - 8, v2);
  uint64_t v4 = (char *)&v28 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v5 = type metadata accessor for IDSGroupEncryptionDesiredMaterialSetContainer();
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v8 = __chkstk_darwin(v5, v7);
  uint64_t v10 = (char *)&v28 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = __chkstk_darwin(v8, v11);
  uint64_t v14 = (char *)&v28 - v13;
  uint64_t v15 = (*(uint64_t (**)(uint64_t))((swift_isaMask & *v0) + 0xF0))(v12);
  id result = [objc_allocWithZone((Class)NSMutableSet) init];
  int64_t v17 = 0;
  uint64_t v18 = 1 << *(unsigned char *)(v15 + 32);
  uint64_t v19 = -1;
  if (v18 < 64) {
    uint64_t v19 = ~(-1 << v18);
  }
  uint64_t v20 = *(void *)(v15 + 56);
  id v29 = result;
  uint64_t v30 = v15 + 56;
  unint64_t v21 = v19 & v20;
  int64_t v31 = (unint64_t)(v18 + 63) >> 6;
  if ((v19 & v20) != 0) {
    goto LABEL_6;
  }
LABEL_7:
  int64_t v24 = v17 + 1;
  if (!__OFADD__(v17, 1))
  {
    if (v24 < v31)
    {
      unint64_t v25 = *(void *)(v30 + 8 * v24);
      ++v17;
      if (v25) {
        goto LABEL_20;
      }
      int64_t v17 = v24 + 1;
      if (v24 + 1 >= v31) {
        goto LABEL_24;
      }
      unint64_t v25 = *(void *)(v30 + 8 * v17);
      if (v25) {
        goto LABEL_20;
      }
      int64_t v17 = v24 + 2;
      if (v24 + 2 >= v31) {
        goto LABEL_24;
      }
      unint64_t v25 = *(void *)(v30 + 8 * v17);
      if (v25)
      {
LABEL_20:
        unint64_t v21 = (v25 - 1) & v25;
        for (unint64_t i = __clz(__rbit64(v25)) + (v17 << 6); ; unint64_t i = v22 | (v17 << 6))
        {
          sub_1004613A8(*(void *)(v15 + 48) + *(void *)(v6 + 72) * i, (uint64_t)v14, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredMaterialSetContainer);
          sub_10046129C((uint64_t)v14, (uint64_t)v10, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredMaterialSetContainer);
          if (swift_getEnumCaseMultiPayload() == 1)
          {
            sub_10046129C((uint64_t)v10, (uint64_t)v4, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet);
            id v27 = sub_100451AD8();
            [v29 addObject:v27];

            id result = (id)sub_100461304((uint64_t)v4, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredKeyValueMaterialSet);
            if (!v21) {
              goto LABEL_7;
            }
          }
          else
          {
            id result = (id)sub_100461304((uint64_t)v10, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredMaterialSetContainer);
            if (!v21) {
              goto LABEL_7;
            }
          }
LABEL_6:
          unint64_t v22 = __clz(__rbit64(v21));
          v21 &= v21 - 1;
        }
      }
      int64_t v26 = v24 + 3;
      if (v26 < v31)
      {
        unint64_t v25 = *(void *)(v30 + 8 * v26);
        if (v25)
        {
          int64_t v17 = v26;
          goto LABEL_20;
        }
        while (1)
        {
          int64_t v17 = v26 + 1;
          if (__OFADD__(v26, 1)) {
            goto LABEL_26;
          }
          if (v17 >= v31) {
            break;
          }
          unint64_t v25 = *(void *)(v30 + 8 * v17);
          ++v26;
          if (v25) {
            goto LABEL_20;
          }
        }
      }
    }
LABEL_24:
    swift_release();
    return v29;
  }
  __break(1u);
LABEL_26:
  __break(1u);
  return result;
}

void *sub_100457C24(uint64_t a1, uint64_t a2)
{
  BOOL v3 = *(void *)((char *)v2 + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_groupID) == a1
    && *(void *)((char *)v2 + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_groupID + 8) == a2;
  if (v3 || (sub_100726D20() & 1) != 0)
  {
    uint64_t v4 = *(uint64_t (**)(void))((swift_isaMask & *v2) + 0xF0);
    return (void *)v4();
  }
  else
  {
    uint64_t v6 = sub_100725EB0();
    os_log_type_t v7 = sub_1007266C0();
    if (os_log_type_enabled(v6, v7))
    {
      uint64_t v8 = (uint8_t *)swift_slowAlloc();
      uint64_t v9 = swift_slowAlloc();
      *(_DWORD *)uint64_t v8 = 136315138;
      sub_10043E578(0xD000000000000027, 0x80000001008C1330, &v9);
      sub_100726830();
      _os_log_impl((void *)&_mh_execute_header, v6, v7, "%s: group id mismatch", v8, 0xCu);
      swift_arrayDestroy();
      swift_slowDealloc();
      swift_slowDealloc();
    }

    return &_swiftEmptySetSingleton;
  }
}

uint64_t sub_100457DE4()
{
  uint64_t v1 = *(os_unfair_lock_s **)(v0 + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_state);
  uint64_t v2 = (uint64_t)&v1[4];
  BOOL v3 = v1 + 12;
  os_unfair_lock_lock(v1 + 12);
  sub_100461364(v2, &v5);
  os_unfair_lock_unlock(v3);
  return v5;
}

void sub_100457E50(uint64_t a1@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  uint64_t v122 = a3;
  uint64_t v5 = sub_100725D30();
  uint64_t v6 = *(void *)(v5 - 8);
  __chkstk_darwin(v5, v7);
  uint64_t v144 = (char *)&v121 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v143 = type metadata accessor for IDSGroupEncryptionDesiredMaterialSetContainer();
  uint64_t v10 = __chkstk_darwin(v143, v9);
  uint64_t v142 = (uint64_t)&v121 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v10, v12);
  uint64_t v141 = (uint64_t)&v121 - v13;
  uint64_t v14 = sub_100431F80(&qword_100A453F8);
  __chkstk_darwin(v14 - 8, v15);
  uint64_t v159 = (char *)&v121 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v158 = type metadata accessor for IDSGroupEncryptionPublicIdentity(0);
  uint64_t v17 = *(void *)(v158 - 8);
  uint64_t v19 = __chkstk_darwin(v158, v18);
  uint64_t v140 = (uint64_t)&v121 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v19, v21);
  uint64_t v23 = (char *)&v121 - v22;
  uint64_t v24 = type metadata accessor for IDSDSessionKeyValueDeliveryLocalEntry(0);
  uint64_t v127 = *(void *)(v24 - 8);
  uint64_t v26 = __chkstk_darwin(v24, v25);
  uint64_t v139 = (uint64_t)&v121 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v26, v28);
  uint64_t v147 = (int64_t *)((char *)&v121 - v29);
  uint64_t v30 = sub_100431F80(&qword_100A45400);
  uint64_t v32 = __chkstk_darwin(v30 - 8, v31);
  uint64_t v136 = (char *)&v121 - ((v33 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v32, v34);
  uint64_t v130 = (char *)&v121 - v35;
  uint64_t v165 = &_swiftEmptySetSingleton;
  uint64_t v36 = *(void *)(a1 + 24);
  uint64_t v37 = *(void *)(v36 + 64);
  uint64_t v123 = v36 + 64;
  uint64_t v38 = 1 << *(unsigned char *)(v36 + 32);
  if (v38 < 64) {
    uint64_t v39 = ~(-1 << v38);
  }
  else {
    uint64_t v39 = -1;
  }
  unint64_t v135 = v39 & v37;
  uint64_t v126 = OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_pushTokensForCapabilityProvider;
  uint64_t v125 = (char *)a2 + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_groupID;
  uint64_t v138 = (char *)a2 + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_l;
  uint64_t v157 = (unsigned int (**)(uint64_t, uint64_t, uint64_t))(v17 + 48);
  unint64_t v137 = (void (**)(char *, char *, uint64_t))(v6 + 16);
  int64_t v124 = (unint64_t)(v38 + 63) >> 6;
  int64_t v121 = v124 - 1;
  uint64_t v128 = v36;
  swift_bridgeObjectRetain();
  int64_t v131 = 0;
  *(void *)&long long v40 = 136315394;
  long long v133 = v40;
  uint64_t v132 = (char *)&type metadata for Any + 8;
  uint64_t v148 = (char *)&type metadata for Swift.AnyObject + 8;
  uint64_t v150 = a2;
  uint64_t v145 = v5;
  char v154 = v23;
  uint64_t v146 = v24;
LABEL_6:
  if (v135)
  {
    unint64_t v41 = __clz(__rbit64(v135));
    v135 &= v135 - 1;
    unint64_t v42 = v41 | (v131 << 6);
    uint64_t v43 = v147;
    unint64_t v44 = v136;
LABEL_8:
    uint64_t v45 = *(void *)(v128 + 56);
    *unint64_t v44 = *(_DWORD *)(*(void *)(v128 + 48) + 4 * v42);
    uint64_t v46 = v45 + *(void *)(v127 + 72) * v42;
    uint64_t v47 = sub_100431F80(&qword_100A45408);
    uint64_t v48 = v46;
    unint64_t v44 = v136;
    sub_1004613A8(v48, (uint64_t)&v136[*(int *)(v47 + 48)], type metadata accessor for IDSDSessionKeyValueDeliveryLocalEntry);
    (*(void (**)(_DWORD *, void, uint64_t, uint64_t))(*(void *)(v47 - 8) + 56))(v44, 0, 1, v47);
    os_log_type_t v49 = (unsigned int *)v130;
    goto LABEL_27;
  }
  int64_t v50 = v131 + 1;
  uint64_t v43 = v147;
  unint64_t v44 = v136;
  if (__OFADD__(v131, 1)) {
    goto LABEL_107;
  }
  os_log_type_t v49 = (unsigned int *)v130;
  if (v50 < v124)
  {
    unint64_t v51 = *(void *)(v123 + 8 * v50);
    if (v51)
    {
LABEL_12:
      unint64_t v135 = (v51 - 1) & v51;
      unint64_t v42 = __clz(__rbit64(v51)) + (v50 << 6);
      int64_t v131 = v50;
      goto LABEL_8;
    }
    int64_t v52 = v131 + 2;
    ++v131;
    if (v50 + 1 < v124)
    {
      unint64_t v51 = *(void *)(v123 + 8 * v52);
      if (v51)
      {
LABEL_15:
        int64_t v50 = v52;
        goto LABEL_12;
      }
      int64_t v131 = v50 + 1;
      if (v50 + 2 < v124)
      {
        unint64_t v51 = *(void *)(v123 + 8 * (v50 + 2));
        if (v51)
        {
          v50 += 2;
          goto LABEL_12;
        }
        int64_t v52 = v50 + 3;
        int64_t v131 = v50 + 2;
        if (v50 + 3 < v124)
        {
          unint64_t v51 = *(void *)(v123 + 8 * v52);
          if (v51) {
            goto LABEL_15;
          }
          while (1)
          {
            int64_t v50 = v52 + 1;
            if (__OFADD__(v52, 1)) {
              goto LABEL_108;
            }
            if (v50 >= v124) {
              break;
            }
            unint64_t v51 = *(void *)(v123 + 8 * v50);
            ++v52;
            if (v51) {
              goto LABEL_12;
            }
          }
          int64_t v131 = v121;
        }
      }
    }
  }
  uint64_t v53 = sub_100431F80(&qword_100A45408);
  (*(void (**)(_DWORD *, uint64_t, uint64_t, uint64_t))(*(void *)(v53 - 8) + 56))(v44, 1, 1, v53);
  unint64_t v135 = 0;
LABEL_27:
  sub_100462BE4((uint64_t)v44, (uint64_t)v49, &qword_100A45400);
  uint64_t v54 = sub_100431F80(&qword_100A45408);
  if ((*(unsigned int (**)(unsigned int *, uint64_t, uint64_t))(*(void *)(v54 - 8) + 48))(v49, 1, v54) == 1)
  {
    swift_release();
    *uint64_t v122 = v165;
    return;
  }
  unsigned int v152 = *v49;
  sub_10046129C((uint64_t)v49 + *(int *)(v54 + 48), (uint64_t)v43, type metadata accessor for IDSDSessionKeyValueDeliveryLocalEntry);
  if (v43[4])
  {
    int64_t v55 = *(void **)((char *)a2 + v126);
    swift_bridgeObjectRetain();
    a2 = v150;
    NSString v56 = sub_100726420();
    NSString v57 = sub_100726420();
    swift_bridgeObjectRelease();
    id v58 = [v55 pushTokensForGroupID:v56 capability:v57];

    sub_100462C50(0, (unint64_t *)&qword_100A47A80);
    uint64_t v59 = sub_100726570();
  }
  else
  {
    uint64_t v59 = 0;
  }
  if ((*(uint64_t (**)(void))((swift_isaMask & *a2) + 0x90))())
  {
    uint64_t v61 = v60;
    uint64_t ObjectType = swift_getObjectType();
    uint64_t v63 = (*(uint64_t (**)(uint64_t, uint64_t))(v61 + 16))(ObjectType, v61);
    swift_unknownObjectRelease();
  }
  else
  {
    uint64_t v63 = (uint64_t)&_swiftEmptySetSingleton;
    if (((unint64_t)&_swiftEmptyArrayStorage & 0xC000000000000000) != 0 && sub_100726BA0())
    {
      sub_1004614E8((unint64_t)&_swiftEmptyArrayStorage);
      uint64_t v63 = v120;
    }
  }
  if ((v63 & 0xC000000000000001) != 0)
  {
    sub_1007268E0();
    type metadata accessor for IDSGroupEncryptionControllerParticipant(0);
    sub_1004614A0((unint64_t *)&unk_100A45410, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionControllerParticipant);
    sub_100726680();
    uint64_t v63 = v166;
    uint64_t v156 = v167;
    uint64_t v64 = v168;
    uint64_t v65 = v169;
    unint64_t v66 = v170;
  }
  else
  {
    uint64_t v65 = 0;
    uint64_t v67 = -1 << *(unsigned char *)(v63 + 32);
    uint64_t v68 = *(void *)(v63 + 56);
    uint64_t v156 = v63 + 56;
    uint64_t v69 = ~v67;
    uint64_t v70 = -v67;
    if (v70 < 64) {
      uint64_t v71 = ~(-1 << v70);
    }
    else {
      uint64_t v71 = -1;
    }
    unint64_t v66 = v71 & v68;
    uint64_t v64 = v69;
  }
  uint64_t v151 = v63 & 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v134 = v64;
  int64_t v153 = (unint64_t)(v64 + 64) >> 6;
  uint64_t v72 = v59 & 0xFFFFFFFFFFFFFF8;
  uint64_t v160 = v59 & 0xFFFFFFFFFFFFFF8;
  if (v59 < 0) {
    uint64_t v72 = v59;
  }
  uint64_t v129 = v72;
  unint64_t v155 = v59 & 0xC000000000000001;
  uint64_t v161 = v63;
  uint64_t v162 = v59;
  if (v63 < 0)
  {
LABEL_43:
    uint64_t v73 = sub_100726950();
    if (!v73) {
      goto LABEL_5;
    }
    uint64_t v163 = v73;
    type metadata accessor for IDSGroupEncryptionControllerParticipant(0);
    swift_unknownObjectRetain();
    swift_dynamicCast();
    uint64_t v74 = v164;
    uint64_t v75 = (void *)swift_unknownObjectRelease();
    uint64_t v76 = v65;
    uint64_t v77 = v66;
    if (!v74) {
      goto LABEL_5;
    }
    goto LABEL_65;
  }
  while (1)
  {
    if (v66)
    {
      uint64_t v77 = (v66 - 1) & v66;
      unint64_t v78 = __clz(__rbit64(v66)) | (v65 << 6);
      uint64_t v76 = v65;
      goto LABEL_64;
    }
    int64_t v79 = v65 + 1;
    if (__OFADD__(v65, 1)) {
      break;
    }
    if (v79 >= v153) {
      goto LABEL_5;
    }
    unint64_t v80 = *(void *)(v156 + 8 * v79);
    uint64_t v76 = v65 + 1;
    if (!v80)
    {
      uint64_t v76 = v65 + 2;
      if (v65 + 2 >= v153) {
        goto LABEL_5;
      }
      unint64_t v80 = *(void *)(v156 + 8 * v76);
      if (!v80)
      {
        uint64_t v76 = v65 + 3;
        if (v65 + 3 >= v153) {
          goto LABEL_5;
        }
        unint64_t v80 = *(void *)(v156 + 8 * v76);
        if (!v80)
        {
          uint64_t v76 = v65 + 4;
          if (v65 + 4 >= v153) {
            goto LABEL_5;
          }
          unint64_t v80 = *(void *)(v156 + 8 * v76);
          if (!v80)
          {
            uint64_t v81 = v65 + 5;
            while (v153 != v81)
            {
              unint64_t v80 = *(void *)(v156 + 8 * v81++);
              if (v80)
              {
                uint64_t v76 = v81 - 1;
                uint64_t v63 = v161;
                goto LABEL_63;
              }
            }
LABEL_5:
            sub_100462C48();
            sub_100461304((uint64_t)v147, type metadata accessor for IDSDSessionKeyValueDeliveryLocalEntry);
            swift_bridgeObjectRelease();
            a2 = v150;
            goto LABEL_6;
          }
        }
      }
    }
LABEL_63:
    uint64_t v77 = (v80 - 1) & v80;
    unint64_t v78 = __clz(__rbit64(v80)) + (v76 << 6);
LABEL_64:
    uint64_t v75 = *(id *)(*(void *)(v63 + 48) + 8 * v78);
    uint64_t v74 = v75;
    if (!v75) {
      goto LABEL_5;
    }
LABEL_65:
    if (v59)
    {
      uint64_t v82 = *(void **)((char *)v74
                     + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionControllerParticipant_pushToken);
      if ((unint64_t)v59 >> 62)
      {
        swift_bridgeObjectRetain_n();
        id v119 = v82;
        uint64_t v83 = sub_100726BA0();
        if (!v83) {
          goto LABEL_77;
        }
      }
      else
      {
        uint64_t v83 = *(void *)(v160 + 16);
        swift_bridgeObjectRetain_n();
        id v84 = v82;
        if (!v83) {
          goto LABEL_77;
        }
      }
      if (v155) {
        id v85 = (id)sub_100726A10();
      }
      else {
        id v85 = *(id *)(v59 + 32);
      }
      Swift::String v86 = v85;
      sub_100462C50(0, (unint64_t *)&qword_100A47A80);
      char v87 = sub_1007267F0();

      if ((v87 & 1) == 0)
      {
        uint64_t v59 = v162;
        if (v83 == 1) {
          goto LABEL_77;
        }
        if (v155)
        {
          sub_100726A10();
          char v109 = sub_1007267F0();
          swift_unknownObjectRelease();
          if ((v109 & 1) == 0)
          {
            uint64_t v59 = v162;
            if (v83 != 2)
            {
              uint64_t v110 = 2;
              while (1)
              {
                sub_100726A10();
                uint64_t v111 = v110 + 1;
                if (__OFADD__(v110, 1)) {
                  goto LABEL_105;
                }
                char v112 = sub_1007267F0();
                swift_unknownObjectRelease();
                if (v112) {
                  goto LABEL_71;
                }
                ++v110;
                uint64_t v59 = v162;
                if (v111 == v83) {
                  goto LABEL_77;
                }
              }
            }
            goto LABEL_77;
          }
        }
        else
        {
          id v113 = *(id *)(v162 + 40);
          char v114 = sub_1007267F0();

          if ((v114 & 1) == 0)
          {
            uint64_t v59 = v162;
            if (v83 != 2)
            {
              uint64_t v115 = 6;
              do
              {
                uint64_t v116 = v115 - 3;
                if (__OFADD__(v115 - 4, 1)) {
                  goto LABEL_106;
                }
                id v117 = *(id *)(v59 + 8 * v115);
                char v118 = sub_1007267F0();

                if (v118) {
                  goto LABEL_71;
                }
                ++v115;
                uint64_t v59 = v162;
              }
              while (v116 != v83);
            }
LABEL_77:

            swift_bridgeObjectRelease_n();
LABEL_79:

            goto LABEL_47;
          }
        }
      }
LABEL_71:

      uint64_t v59 = v162;
      uint64_t v75 = (void *)swift_bridgeObjectRelease_n();
    }
    uint64_t v88 = (uint64_t)v159;
    (*(void (**)(void *))((swift_isaMask & *v74) + 0x108))(v75);
    if ((*v157)(v88, 1, v158) == 1)
    {

      sub_10044C150(v88, &qword_100A453F8);
LABEL_47:
      uint64_t v65 = v76;
      unint64_t v66 = v77;
      uint64_t v63 = v161;
      if (v161 < 0) {
        goto LABEL_43;
      }
    }
    else
    {
      uint64_t v89 = (uint64_t)v154;
      sub_10046129C(v88, (uint64_t)v154, type metadata accessor for IDSGroupEncryptionPublicIdentity);
      unsigned int v90 = (*(uint64_t (**)(void))((swift_isaMask & *v150) + 0xF8))(v152);
      if (!v90)
      {
        sub_100461304(v89, type metadata accessor for IDSGroupEncryptionPublicIdentity);
        goto LABEL_79;
      }
      unsigned int v91 = v90;
      unint64_t v149 = v77;
      uint64_t v92 = (char *)v147;
      uint64_t v93 = *v147;
      unint64_t v94 = v147[1];
      uint64_t v95 = v140;
      sub_1004613A8(v89, v140, type metadata accessor for IDSGroupEncryptionPublicIdentity);
      uint64_t v96 = *(void *)((char *)v74
                      + OBJC_IVAR____TtC17identityservicesd39IDSGroupEncryptionControllerParticipant_participantID);
      uint64_t v97 = (uint64_t)v144;
      (*v137)(v144, &v92[*(int *)(v146 + 28)], v145);
      sub_100441FD4(v93, v94);
      uint64_t v98 = v91 | 0x200000000;
      uint64_t v99 = v142;
      sub_100452C10(v98, v93, v94, v95, v96, v97, v142);
      swift_storeEnumTagMultiPayload();
      uint64_t v100 = v141;
      sub_10045FA4C(v141, v99);
      sub_100461304(v100, (uint64_t (*)(void))type metadata accessor for IDSGroupEncryptionDesiredMaterialSetContainer);
      uint64_t v101 = v139;
      sub_1004613A8((uint64_t)v92, v139, type metadata accessor for IDSDSessionKeyValueDeliveryLocalEntry);
      uint64_t v102 = sub_100725EB0();
      os_log_type_t v103 = sub_1007266E0();
      if (os_log_type_enabled(v102, v103))
      {
        uint64_t v104 = swift_slowAlloc();
        id v164 = (void *)swift_slowAlloc();
        *(_DWORD *)uint64_t v104 = v133;
        LODWORD(v163) = v152;
        type metadata accessor for IDSGroupSessionClientDataKey(0);
        uint64_t v105 = sub_100726480();
        *(void *)(v104 + 4) = sub_10043E578(v105, v106, (uint64_t *)&v164);
        swift_bridgeObjectRelease();
        *(_WORD *)(v104 + 12) = 2080;
        sub_1004614A0(&qword_100A45210, (void (*)(uint64_t))&type metadata accessor for UUID);
        uint64_t v107 = sub_100726D00();
        *(void *)(v104 + 14) = sub_10043E578(v107, v108, (uint64_t *)&v164);
        swift_bridgeObjectRelease();
        sub_100461304(v101, type metadata accessor for IDSDSessionKeyValueDeliveryLocalEntry);
        _os_log_impl((void *)&_mh_execute_header, v102, v103, "adding KV to desired: key %s with data ID %s", (uint8_t *)v104, 0x16u);
        swift_arrayDestroy();
        swift_slowDealloc();
        swift_slowDealloc();
      }
      else
      {

        sub_100461304(v101, type metadata accessor for IDSDSessionKeyValueDeliveryLocalEntry);
      }

      sub_100461304((uint64_t)v154, type metadata accessor for IDSGroupEncryptionPublicIdentity);
      uint64_t v65 = v76;
      unint64_t v66 = v149;
      uint64_t v63 = v161;
      uint64_t v59 = v162;
      if (v161 < 0) {
        goto LABEL_43;
      }
    }
  }
  __break(1u);
LABEL_105:
  __break(1u);
LABEL_106:
  __break(1u);
LABEL_107:
  __break(1u);
LABEL_108:
  __break(1u);
}

uint64_t sub_100458FF4(int a1)
{
  if (a1 == 1) {
    return 5;
  }
  else {
    return 0;
  }
}

BOOL sub_100459004(int a1)
{
  return a1 == 5;
}

void IDSDSessionKeyValueDelivery.receive(dictionaryData:forType:fromParticipant:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  uint64_t v8 = sub_100431F80(&qword_100A451F0);
  uint64_t v10 = __chkstk_darwin(v8 - 8, v9);
  uint64_t v12 = (char *)&v112 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v10, v13);
  uint64_t v15 = (char *)&v112 - v14;
  uint64_t v16 = type metadata accessor for IDSGroupEncryptionFullIdentity(0);
  uint64_t v17 = *(void *)(v16 - 8);
  uint64_t v19 = __chkstk_darwin(v16, v18);
  uint64_t v121 = (uint64_t)&v112 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = __chkstk_darwin(v19, v21);
  uint64_t v122 = (char *)&v112 - v23;
  uint64_t v25 = __chkstk_darwin(v22, v24);
  uint64_t v27 = (char *)&v112 - v26;
  __chkstk_darwin(v25, v28);
  uint64_t v30 = (char *)&v112 - v29;
  unsigned int v31 = (*(uint64_t (**)(uint64_t))((swift_isaMask & *v4) + 0x100))(a2);
  if (!v31)
  {
    id v58 = *(void **)((char *)v4 + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_metricsCollector);
    NSString v59 = sub_100726420();
    id v60 = [v58 error:v59];

    uint64_t v122 = (char *)sub_100726420();
    [v60 event:v122];

    uint64_t v61 = v122;

    return;
  }
  unsigned int v32 = v31;
  uint64_t v120 = a3;
  uint64_t v33 = sub_100726430();
  if (!*(void *)(a1 + 16) || (v119 = v32, unint64_t v35 = sub_10045C784(v33, v34), (v36 & 1) == 0))
  {
    swift_bridgeObjectRelease();
    goto LABEL_12;
  }
  uint64_t v37 = *(void *)(*(void *)(a1 + 56) + 8 * v35);
  swift_unknownObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v123 = (void *)v37;
  if ((swift_dynamicCast() & 1) == 0)
  {
LABEL_12:
    uint64_t v38 = 0;
    goto LABEL_13;
  }
  uint64_t v38 = v125;
  if (v125 != 1)
  {
LABEL_13:
    os_log_type_t v49 = sub_100725EB0();
    os_log_type_t v50 = sub_1007266C0();
    if (os_log_type_enabled(v49, v50))
    {
      uint64_t v51 = swift_slowAlloc();
      uint64_t v125 = swift_slowAlloc();
      *(_DWORD *)uint64_t v51 = 136315394;
      uint64_t v123 = (void *)sub_10043E578(0xD000000000000030, 0x80000001008C1380, &v125);
      sub_100726830();
      *(_WORD *)(v51 + 12) = 2080;
      uint64_t v123 = (void *)v38;
      LOBYTE(v124) = 0;
      sub_100431F80(&qword_100A451F8);
      uint64_t v52 = sub_100726480();
      uint64_t v123 = (void *)sub_10043E578(v52, v53, &v125);
      sub_100726830();
      swift_bridgeObjectRelease();
      _os_log_impl((void *)&_mh_execute_header, v49, v50, "%s: unsupported wrapMode %s", (uint8_t *)v51, 0x16u);
      swift_arrayDestroy();
      swift_slowDealloc();
      swift_slowDealloc();
    }

    uint64_t v54 = *(void **)((char *)v4 + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_metricsCollector);
    NSString v55 = sub_100726420();
    id v56 = [v54 error:v55];

    NSString v57 = sub_100726420();
    [v56 event:v57];
    goto LABEL_16;
  }
  uint64_t v39 = sub_100726430();
  if (*(void *)(a1 + 16) && (unint64_t v41 = sub_10045C784(v39, v40), (v42 & 1) != 0))
  {
    uint64_t v43 = *(void *)(*(void *)(a1 + 56) + 8 * v41);
    swift_unknownObjectRetain();
    swift_bridgeObjectRelease();
    uint64_t v125 = v43;
    if (swift_dynamicCast())
    {
      unint64_t v117 = v124;
      char v118 = v123;
      uint64_t v44 = *(void *)((char *)v4
                      + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_identityProvider
                      + 24);
      uint64_t v45 = *(void *)((char *)v4
                      + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_identityProvider
                      + 32);
      uint64_t v116 = (void *)((char *)v4 + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_identityProvider);
      sub_10044C0F4((void *)((char *)v4 + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_identityProvider), v44);
      (*(void (**)(uint64_t, uint64_t))(v45 + 8))(v44, v45);
      uint64_t v48 = *(unsigned int (**)(void, void, void))(v17 + 48);
      uint64_t v47 = v17 + 48;
      uint64_t v46 = v48;
      if (v48(v15, 1, v16) == 1)
      {
        sub_10044C150((uint64_t)v15, &qword_100A451F0);
      }
      else
      {
        sub_10046129C((uint64_t)v15, (uint64_t)v30, type metadata accessor for IDSGroupEncryptionFullIdentity);
        sub_1004613A8((uint64_t)v30, (uint64_t)v27, type metadata accessor for IDSGroupEncryptionFullIdentity);
        uint64_t v65 = sub_100725EB0();
        os_log_type_t v66 = sub_1007266E0();
        int v67 = v66;
        if (os_log_type_enabled(v65, v66))
        {
          uint64_t v68 = swift_slowAlloc();
          char v114 = v46;
          uint64_t v115 = v47;
          uint64_t v69 = v68;
          uint64_t v123 = (void *)swift_slowAlloc();
          *(_DWORD *)uint64_t v69 = 136315394;
          int v113 = v67;
          uint64_t v125 = sub_10043E578(0xD000000000000030, 0x80000001008C1380, (uint64_t *)&v123);
          sub_100726830();
          *(_WORD *)(v69 + 12) = 2080;
          uint64_t v112 = v69 + 14;
          sub_1004614A0(&qword_100A45200, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionFullIdentity);
          uint64_t v70 = sub_100726D00();
          uint64_t v125 = sub_10043E578(v70, v71, (uint64_t *)&v123);
          sub_100726830();
          swift_bridgeObjectRelease();
          sub_100461304((uint64_t)v27, type metadata accessor for IDSGroupEncryptionFullIdentity);
          _os_log_impl((void *)&_mh_execute_header, v65, (os_log_type_t)v113, "%s: attempting to decrypt with identity %s", (uint8_t *)v69, 0x16u);
          swift_arrayDestroy();
          swift_slowDealloc();
          uint64_t v46 = v114;
          swift_slowDealloc();
        }
        else
        {

          sub_100461304((uint64_t)v27, type metadata accessor for IDSGroupEncryptionFullIdentity);
        }
        uint64_t v72 = *(void *)((char *)v4
                        + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_cryptoHandler
                        + 24);
        uint64_t v73 = *(void *)((char *)v4
                        + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_cryptoHandler
                        + 32);
        sub_10044C0F4((void *)((char *)v4 + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_cryptoHandler), v72);
        uint64_t v74 = (*(uint64_t (**)(void *, unint64_t, char *, uint64_t, uint64_t))(v73 + 32))(v118, v117, v30, v72, v73);
        unint64_t v76 = v75;
        char v78 = v77;
        sub_100461304((uint64_t)v30, type metadata accessor for IDSGroupEncryptionFullIdentity);
        if ((v78 & 1) == 0)
        {
LABEL_36:
          sub_100441FD4(v74, v76);
          sub_100441FD4(v74, v76);
          sub_100441FD4(v74, v76);
          uint64_t v96 = sub_100725EB0();
          os_log_type_t v97 = sub_1007266E0();
          if (os_log_type_enabled(v96, v97))
          {
            unint64_t v98 = v76;
            uint64_t v99 = swift_slowAlloc();
            uint64_t v122 = (char *)swift_slowAlloc();
            uint64_t v123 = v122;
            *(_DWORD *)uint64_t v99 = 136315906;
            uint64_t v125 = sub_10043E578(0xD000000000000030, 0x80000001008C1380, (uint64_t *)&v123);
            sub_100726830();
            *(_WORD *)(v99 + 12) = 2080;
            sub_100441FD4(v74, v98);
            uint64_t v100 = sub_100725AA0();
            unint64_t v102 = v101;
            sub_100442248(v74, v98);
            uint64_t v125 = sub_10043E578(v100, v102, (uint64_t *)&v123);
            sub_100726830();
            swift_bridgeObjectRelease();
            sub_100442248(v74, v98);
            sub_100442248(v74, v98);
            *(_WORD *)(v99 + 22) = 2080;
            uint64_t v103 = v119;
            LODWORD(v125) = v119;
            type metadata accessor for IDSGroupSessionClientDataKey(0);
            uint64_t v104 = sub_100726480();
            uint64_t v125 = sub_10043E578(v104, v105, (uint64_t *)&v123);
            sub_100726830();
            swift_bridgeObjectRelease();
            *(_WORD *)(v99 + 32) = 2048;
            uint64_t v106 = v120;
            uint64_t v125 = v120;
            sub_100726830();
            _os_log_impl((void *)&_mh_execute_header, v96, v97, "%s: received %s forKey: %s fromParticipant: %llu", (uint8_t *)v99, 0x2Au);
            swift_arrayDestroy();
            swift_slowDealloc();
            unint64_t v76 = v98;
            swift_slowDealloc();
          }
          else
          {

            sub_100442248(v74, v76);
            sub_100442248(v74, v76);
            uint64_t v106 = v120;
            uint64_t v103 = v119;
          }
          (*(void (**)(uint64_t, unint64_t, uint64_t, uint64_t))((swift_isaMask & *v4) + 0x110))(v74, v76, v103, v106);
          sub_100461390(v74, v76, 0);
          sub_100442248(v74, v76);
          sub_100442248((uint64_t)v118, v117);
          return;
        }
        sub_10044C144(v74, v76, 1);
      }
      uint64_t v79 = v116[3];
      uint64_t v80 = v116[4];
      sub_10044C0F4(v116, v79);
      (*(void (**)(uint64_t, uint64_t))(v80 + 16))(v79, v80);
      if (v46(v12, 1, v16) == 1)
      {
        sub_10044C150((uint64_t)v12, &qword_100A451F0);
        uint64_t v74 = 0;
        unint64_t v81 = 0;
        unsigned __int8 v82 = -1;
LABEL_41:
        uint64_t v107 = sub_100725EB0();
        os_log_type_t v108 = sub_1007266C0();
        if (os_log_type_enabled(v107, v108))
        {
          char v109 = (uint8_t *)swift_slowAlloc();
          uint64_t v123 = (void *)swift_slowAlloc();
          *(_DWORD *)char v109 = 136315138;
          uint64_t v125 = sub_10043E578(0xD000000000000030, 0x80000001008C1380, (uint64_t *)&v123);
          sub_100726830();
          _os_log_impl((void *)&_mh_execute_header, v107, v108, "%s: failed CryptoHandler decrypt", v109, 0xCu);
          swift_arrayDestroy();
          swift_slowDealloc();
          swift_slowDealloc();
        }

        uint64_t v110 = *(void **)((char *)v4 + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_metricsCollector);
        NSString v111 = sub_100726420();
        id v56 = [v110 error:v111];

        NSString v57 = sub_100726420();
        [v56 event:v57];
        sub_100461390(v74, v81, v82);
        sub_100442248((uint64_t)v118, v117);
LABEL_16:

        return;
      }
      uint64_t v83 = (uint64_t)v122;
      sub_10046129C((uint64_t)v12, (uint64_t)v122, type metadata accessor for IDSGroupEncryptionFullIdentity);
      uint64_t v84 = v121;
      sub_1004613A8(v83, v121, type metadata accessor for IDSGroupEncryptionFullIdentity);
      id v85 = sub_100725EB0();
      os_log_type_t v86 = sub_1007266E0();
      if (os_log_type_enabled(v85, v86))
      {
        uint64_t v87 = swift_slowAlloc();
        uint64_t v123 = (void *)swift_slowAlloc();
        *(_DWORD *)uint64_t v87 = 136315394;
        uint64_t v125 = sub_10043E578(0xD000000000000030, 0x80000001008C1380, (uint64_t *)&v123);
        sub_100726830();
        *(_WORD *)(v87 + 12) = 2080;
        sub_1004614A0(&qword_100A45200, (void (*)(uint64_t))type metadata accessor for IDSGroupEncryptionFullIdentity);
        uint64_t v88 = sub_100726D00();
        uint64_t v125 = sub_10043E578(v88, v89, (uint64_t *)&v123);
        sub_100726830();
        swift_bridgeObjectRelease();
        sub_100461304(v84, type metadata accessor for IDSGroupEncryptionFullIdentity);
        _os_log_impl((void *)&_mh_execute_header, v85, v86, "%s: could not CryptoHandler decrypt with current identity; trying with previous %s",
          (uint8_t *)v87,
          0x16u);
        swift_arrayDestroy();
        swift_slowDealloc();
        swift_slowDealloc();
      }
      else
      {

        sub_100461304(v84, type metadata accessor for IDSGroupEncryptionFullIdentity);
      }
      uint64_t v90 = *(void *)((char *)v4 + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_cryptoHandler + 24);
      uint64_t v91 = *(void *)((char *)v4 + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_cryptoHandler + 32);
      sub_10044C0F4((void *)((char *)v4 + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_cryptoHandler), v90);
      uint64_t v92 = (uint64_t)v122;
      uint64_t v74 = (*(uint64_t (**)(void *, unint64_t, char *, uint64_t, uint64_t))(v91 + 32))(v118, v117, v122, v90, v91);
      unint64_t v76 = v93;
      char v95 = v94;
      sub_100461304(v92, type metadata accessor for IDSGroupEncryptionFullIdentity);
      if (v95)
      {
        unint64_t v81 = v76;
        unsigned __int8 v82 = 1;
        goto LABEL_41;
      }
      goto LABEL_36;
    }
  }
  else
  {
    swift_bridgeObjectRelease();
  }
  uint64_t v62 = sub_100725EB0();
  os_log_type_t v63 = sub_1007266C0();
  if (os_log_type_enabled(v62, v63))
  {
    uint64_t v64 = (uint8_t *)swift_slowAlloc();
    uint64_t v123 = (void *)swift_slowAlloc();
    *(_DWORD *)uint64_t v64 = 136315138;
    uint64_t v125 = sub_10043E578(0xD000000000000030, 0x80000001008C1380, (uint64_t *)&v123);
    sub_100726830();
    _os_log_impl((void *)&_mh_execute_header, v62, v63, "%s: could not extract data", v64, 0xCu);
    swift_arrayDestroy();
    swift_slowDealloc();
    swift_slowDealloc();
  }
}

void IDSDSessionKeyValueDelivery.receive(unencryptedData:forKey:fromParticipant:)()
{
  uint64_t v1 = v0;
  uint64_t v2 = sub_100725EB0();
  os_log_type_t v3 = sub_1007266E0();
  if (os_log_type_enabled(v2, v3))
  {
    uint64_t v4 = swift_slowAlloc();
    v14[0] = swift_slowAlloc();
    *(_DWORD *)uint64_t v4 = 136315650;
    sub_10043E578(0xD000000000000030, 0x80000001008C13E0, v14);
    sub_100726830();
    *(_WORD *)(v4 + 12) = 2080;
    type metadata accessor for IDSGroupSessionClientDataKey(0);
    uint64_t v5 = sub_100726480();
    sub_10043E578(v5, v6, v14);
    sub_100726830();
    swift_bridgeObjectRelease();
    *(_WORD *)(v4 + 22) = 2048;
    sub_100726830();
    _os_log_impl((void *)&_mh_execute_header, v2, v3, "%s: key: %s participant: %llu", (uint8_t *)v4, 0x20u);
    swift_arrayDestroy();
    swift_slowDealloc();
    swift_slowDealloc();
  }

  id v7 = [*(id *)(v1 + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_metricsCollector) keyValueDelivery];
  NSString v8 = sub_100726420();
  [v7 event:v8];

  __chkstk_darwin(v9, v10);
  uint64_t v12 = (uint64_t)&v11[4];
  uint64_t v13 = v11 + 12;
  os_unfair_lock_lock(v11 + 12);
  sub_100461424(v12);
  os_unfair_lock_unlock(v13);
}

unint64_t sub_10045A444(uint64_t a1, Swift::UInt32 a2, uint64_t a3, uint64_t a4, unint64_t a5, void *a6)
{
  char v78 = a6;
  uint64_t v81 = a3;
  uint64_t v10 = sub_100431F80(&qword_100A453B8);
  uint64_t v12 = __chkstk_darwin(v10 - 8, v11);
  uint64_t v14 = (char *)&v68 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v12, v15);
  unint64_t v75 = (char *)&v68 - v16;
  uint64_t v17 = *(void *)(a1 + 16);
  if (*(void *)(v17 + 16) && (unint64_t v18 = sub_10045C6D4(a2), (v19 & 1) != 0))
  {
    unint64_t v20 = *(void *)(*(void *)(v17 + 56) + 8 * v18);
    swift_bridgeObjectRetain();
  }
  else
  {
    unint64_t v20 = sub_100460D64(&_swiftEmptyArrayStorage);
  }
  sub_100441FD4(a4, a5);
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  unint64_t v91 = v20;
  sub_10045EA84(a4, a5, v81, isUniquelyReferenced_nonNull_native);
  uint64_t v22 = v91;
  swift_bridgeObjectRelease();
  char v23 = swift_isUniquelyReferenced_nonNull_native();
  unint64_t v91 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0x8000000000000000;
  sub_10045E94C(v22, a2, v23);
  *(void *)(a1 + 16) = v91;
  swift_bridgeObjectRelease();
  uint64_t v24 = *(void *)(a1 + 8);
  uint64_t v25 = *(void *)(v24 + 64);
  uint64_t v69 = v24 + 64;
  uint64_t v26 = 1 << *(unsigned char *)(v24 + 32);
  uint64_t v27 = -1;
  if (v26 < 64) {
    uint64_t v27 = ~(-1 << v26);
  }
  unint64_t v28 = v27 & v25;
  char v77 = &v89;
  uint64_t v79 = &v85;
  int64_t v70 = (unint64_t)(v26 + 63) >> 6;
  int64_t v68 = v70 - 1;
  uint64_t v76 = v24;
  unint64_t result = swift_bridgeObjectRetain();
  int64_t v82 = 0;
  uint64_t v74 = &v92;
  long long v80 = xmmword_100794E30;
  uint64_t v30 = (uint64_t)v75;
  uint64_t v73 = a4;
  Swift::UInt32 v72 = a2;
  unint64_t v71 = v14;
  while (1)
  {
    if (v28)
    {
      unint64_t v33 = __clz(__rbit64(v28));
      uint64_t v34 = (v28 - 1) & v28;
      unint64_t v35 = v33 | (v82 << 6);
LABEL_12:
      uint64_t v36 = v76;
      uint64_t v37 = *(void *)(v76 + 48);
      uint64_t v38 = sub_100725D30();
      (*(void (**)(char *, unint64_t, uint64_t))(*(void *)(v38 - 8) + 16))(v14, v37 + *(void *)(*(void *)(v38 - 8) + 72) * v35, v38);
      uint64_t v39 = *(void *)(v36 + 56);
      uint64_t v40 = sub_100431F80(&qword_100A453C0);
      *(void *)&v14[*(int *)(v40 + 48)] = *(void *)(v39 + 8 * v35);
      (*(void (**)(char *, void, uint64_t, uint64_t))(*(void *)(v40 - 8) + 56))(v14, 0, 1, v40);
      swift_unknownObjectRetain();
      goto LABEL_31;
    }
    int64_t v41 = v82 + 1;
    if (__OFADD__(v82, 1)) {
      goto LABEL_47;
    }
    if (v41 < v70)
    {
      unint64_t v42 = *(void *)(v69 + 8 * v41);
      if (v42) {
        goto LABEL_16;
      }
      int64_t v43 = v82 + 2;
      ++v82;
      if (v41 + 1 < v70)
      {
        unint64_t v42 = *(void *)(v69 + 8 * v43);
        if (v42) {
          goto LABEL_19;
        }
        int64_t v82 = v41 + 1;
        if (v41 + 2 < v70)
        {
          unint64_t v42 = *(void *)(v69 + 8 * (v41 + 2));
          if (v42)
          {
            v41 += 2;
            goto LABEL_16;
          }
          int64_t v43 = v41 + 3;
          int64_t v82 = v41 + 2;
          if (v41 + 3 < v70) {
            break;
          }
        }
      }
    }
LABEL_30:
    uint64_t v44 = sub_100431F80(&qword_100A453C0);
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v44 - 8) + 56))(v14, 1, 1, v44);
    uint64_t v34 = 0;
LABEL_31:
    sub_100462BE4((uint64_t)v14, v30, &qword_100A453B8);
    uint64_t v45 = sub_100431F80(&qword_100A453C0);
    if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v45 - 8) + 48))(v30, 1, v45) == 1) {
      return swift_release();
    }
    id v84 = *(id *)(v30 + *(int *)(v45 + 48));
    long long v88 = v80;
    Swift::UInt32 v89 = a2;
    uint64_t v85 = v81;
    uint64_t v86 = a4;
    unint64_t v87 = a5;
    sub_100431F80(&qword_100A453C8);
    uint64_t v46 = (void *)sub_100726BE0();
    uint64_t v48 = v85;
    uint64_t v47 = v86;
    unint64_t v49 = v87;
    unint64_t result = sub_10045C7FC(v85);
    if (v50) {
      goto LABEL_45;
    }
    v46[(result >> 6) + 8] |= 1 << result;
    *(void *)(v46[6] + 8 * result) = v48;
    uint64_t v51 = (uint64_t *)(v46[7] + 16 * result);
    *uint64_t v51 = v47;
    v51[1] = v49;
    uint64_t v52 = v46[2];
    BOOL v53 = __OFADD__(v52, 1);
    uint64_t v54 = v52 + 1;
    if (v53) {
      goto LABEL_46;
    }
    unint64_t v83 = v34;
    void v46[2] = v54;
    sub_100441FD4(a4, a5);
    sub_100441FD4(v47, v49);
    sub_100431F80(&qword_100A453D0);
    swift_arrayDestroy();
    uint64_t v90 = v46;
    uint64_t v55 = v88;
    if ((void)v88)
    {
      unint64_t v56 = a5;
      sub_100431F80(&qword_100A453D8);
      NSString v57 = (void *)sub_100726BE0();
      Swift::UInt32 v58 = v89;
      NSString v59 = v90;
      unint64_t result = sub_10045C6D4(v89);
      if (v60)
      {
LABEL_43:
        __break(1u);
      }
      else
      {
        uint64_t v61 = v55;
        uint64_t v62 = v74;
        while (1)
        {
          *(void *)((char *)v57 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8) + 64) |= 1 << result;
          *(_DWORD *)(v57[6] + 4 * result) = v58;
          *(void *)(v57[7] + 8 * result) = v59;
          uint64_t v63 = v57[2];
          BOOL v53 = __OFADD__(v63, 1);
          uint64_t v64 = v63 + 1;
          if (v53) {
            break;
          }
          v57[2] = v64;
          if (!--v61)
          {
            swift_bridgeObjectRetain();
            a5 = v56;
            a4 = v73;
            a2 = v72;
            uint64_t v14 = v71;
            uint64_t v30 = (uint64_t)v75;
            goto LABEL_9;
          }
          uint64_t v65 = v62 + 16;
          Swift::UInt32 v58 = *((_DWORD *)v62 - 2);
          os_log_type_t v66 = *(void **)v62;
          swift_bridgeObjectRetain();
          unint64_t result = sub_10045C6D4(v58);
          uint64_t v62 = v65;
          NSString v59 = v66;
          if (v67) {
            goto LABEL_43;
          }
        }
      }
      __break(1u);
LABEL_45:
      __break(1u);
LABEL_46:
      __break(1u);
LABEL_47:
      __break(1u);
      goto LABEL_48;
    }
    NSString v57 = &_swiftEmptyDictionarySingleton;
LABEL_9:
    sub_100431F80(&qword_100A453E0);
    swift_arrayDestroy();
    (*(void (**)(void *))((swift_isaMask & *v78) + 0xB0))(v57);
    swift_release();
    sub_100462C50(0, (unint64_t *)&unk_100A468F0);
    sub_100431F80(&qword_100A453E8);
    sub_100462B7C();
    Class isa = sub_100726380().super.isa;
    swift_bridgeObjectRelease();
    [v84 handleGroupSessionKeyValues:isa];

    swift_unknownObjectRelease();
    uint64_t v32 = sub_100725D30();
    unint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v32 - 8) + 8))(v30, v32);
    unint64_t v28 = v83;
  }
  unint64_t v42 = *(void *)(v69 + 8 * v43);
  if (v42)
  {
LABEL_19:
    int64_t v41 = v43;
LABEL_16:
    uint64_t v34 = (v42 - 1) & v42;
    unint64_t v35 = __clz(__rbit64(v42)) + (v41 << 6);
    int64_t v82 = v41;
    goto LABEL_12;
  }
  while (1)
  {
    int64_t v41 = v43 + 1;
    if (__OFADD__(v43, 1)) {
      break;
    }
    if (v41 >= v70)
    {
      int64_t v82 = v68;
      goto LABEL_30;
    }
    unint64_t v42 = *(void *)(v69 + 8 * v41);
    ++v43;
    if (v42) {
      goto LABEL_16;
    }
  }
LABEL_48:
  __break(1u);
  return result;
}

uint64_t IDSDSessionKeyValueDelivery.test_receive(_:for:fromParticipant:)()
{
  return (*(uint64_t (**)(void))((swift_isaMask & *v0) + 0x110))();
}

uint64_t IDSDSessionKeyValueDelivery.send(_:for:encryption:capability:)(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6)
{
  *(void *)(v7 + 64) = a6;
  *(void *)(v7 + 72) = v6;
  *(void *)(v7 + 4_Block_object_dispose(&STACK[0x320], 8) = a2;
  *(void *)(v7 + 56) = a5;
  *(_DWORD *)(v7 + 116) = a3;
  *(_DWORD *)(v7 + 120) = a4;
  *(void *)(v7 + 40) = a1;
  uint64_t v8 = sub_100725D30();
  *(void *)(v7 + 80) = v8;
  *(void *)(v7 + 8_Block_object_dispose(&STACK[0x320], 8) = *(void *)(v8 - 8);
  *(void *)(v7 + 96) = swift_task_alloc();
  *(void *)(v7 + 104) = swift_task_alloc();
  return _swift_task_switch(sub_10045AE10, 0, 0);
}

uint64_t sub_10045AE10()
{
  uint64_t v33 = v0;
  uint64_t v1 = *(void *)(v0 + 96);
  uint64_t v2 = *(void *)(v0 + 104);
  uint64_t v3 = *(void *)(v0 + 80);
  uint64_t v4 = *(void *)(v0 + 88);
  sub_100725D20();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v4 + 16))(v1, v2, v3);
  uint64_t v5 = sub_100725EB0();
  os_log_type_t v6 = sub_1007266E0();
  if (os_log_type_enabled(v5, v6))
  {
    uint64_t v29 = *(void *)(v0 + 96);
    uint64_t v30 = *(void *)(v0 + 88);
    uint64_t v28 = *(void *)(v0 + 80);
    int v7 = *(_DWORD *)(v0 + 116);
    uint64_t v8 = swift_slowAlloc();
    v32[0] = swift_slowAlloc();
    *(_DWORD *)uint64_t v8 = 136315650;
    *(void *)(v0 + 16) = sub_10043E578(0xD000000000000022, 0x80000001008C1420, v32);
    sub_100726830();
    *(_DWORD *)(v0 + 112) = v7;
    *(_WORD *)(v8 + 12) = 2080;
    type metadata accessor for IDSGroupSessionClientDataKey(0);
    uint64_t v9 = sub_100726480();
    *(void *)(v0 + 24) = sub_10043E578(v9, v10, v32);
    sub_100726830();
    swift_bridgeObjectRelease();
    *(_WORD *)(v8 + 22) = 2080;
    sub_1004614A0(&qword_100A45210, (void (*)(uint64_t))&type metadata accessor for UUID);
    uint64_t v11 = sub_100726D00();
    *(void *)(v0 + 32) = sub_10043E578(v11, v12, v32);
    sub_100726830();
    swift_bridgeObjectRelease();
    uint64_t v13 = *(void (**)(uint64_t, uint64_t))(v30 + 8);
    v13(v29, v28);
    _os_log_impl((void *)&_mh_execute_header, v5, v6, "%s: senddata called for key %s with data ID %s", (uint8_t *)v8, 0x20u);
    swift_arrayDestroy();
    swift_slowDealloc();
    swift_slowDealloc();
  }
  else
  {
    uint64_t v15 = *(void *)(v0 + 88);
    uint64_t v14 = *(void *)(v0 + 96);
    uint64_t v16 = *(void *)(v0 + 80);

    uint64_t v13 = *(void (**)(uint64_t, uint64_t))(v15 + 8);
    v13(v14, v16);
  }
  uint64_t v17 = *(void *)(v0 + 104);
  uint64_t v18 = *(void *)(v0 + 72);
  long long v31 = *(_OWORD *)(v0 + 56);
  int v20 = *(_DWORD *)(v0 + 116);
  int v19 = *(_DWORD *)(v0 + 120);
  uint64_t v22 = *(void *)(v0 + 40);
  uint64_t v21 = *(void *)(v0 + 48);
  char v23 = *(os_unfair_lock_s **)(v18 + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_state);
  uint64_t v24 = swift_task_alloc();
  *(_DWORD *)(v24 + 16) = v20;
  *(void *)(v24 + 24) = v22;
  *(void *)(v24 + 32) = v21;
  *(_DWORD *)(v24 + 40) = v19;
  *(_OWORD *)(v24 + 4_Block_object_dispose(&STACK[0x320], 8) = v31;
  *(void *)(v24 + 64) = v17;
  *(void *)(v24 + 72) = v18;
  os_unfair_lock_lock(v23 + 12);
  sub_100461458(v32);
  os_unfair_lock_unlock(v23 + 12);
  uint64_t v25 = (void *)v32[0];
  swift_task_dealloc();
  if (v25)
  {
    [v25 updateServerDesiredKeyValueDeliveryMaterialsNeeded];
    swift_unknownObjectRelease();
  }
  v13(*(void *)(v0 + 104), *(void *)(v0 + 80));
  swift_task_dealloc();
  swift_task_dealloc();
  uint64_t v26 = *(uint64_t (**)(void))(v0 + 8);
  return v26();
}

uint64_t sub_10045B1DC@<X0>(Swift::UInt32 a1@<W1>, uint64_t a2@<X2>, unint64_t a3@<X3>, int a4@<W4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, uint64_t *a8@<X8>, uint64_t a9)
{
  Swift::UInt32 v26 = a1;
  uint64_t v28 = a8;
  uint64_t v27 = a9;
  uint64_t v15 = sub_100431F80(&qword_100A453A8);
  __chkstk_darwin(v15 - 8, v16);
  uint64_t v18 = (char *)&v25 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = type metadata accessor for IDSDSessionKeyValueDeliveryLocalEntry(0);
  int v20 = &v18[*(int *)(v19 + 28)];
  uint64_t v21 = sub_100725D30();
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v21 - 8) + 16))(v20, a7, v21);
  *(void *)uint64_t v18 = a2;
  *((void *)v18 + 1) = a3;
  *((_DWORD *)v18 + 4) = a4;
  *((void *)v18 + 3) = a5;
  *((void *)v18 + 4) = a6;
  (*(void (**)(char *, void, uint64_t, uint64_t))(*(void *)(v19 - 8) + 56))(v18, 0, 1, v19);
  sub_100441FD4(a2, a3);
  swift_bridgeObjectRetain();
  sub_1004565A4((uint64_t)v18, v26);
  id v22 = [*(id *)(v27 + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_metricsCollector) keyValueDelivery];
  NSString v23 = sub_100726420();
  [v22 event:v23];

  uint64_t result = swift_unknownObjectWeakLoadStrong();
  *uint64_t v28 = result;
  return result;
}

uint64_t sub_10045B564(void *a1, int a2, int a3, void *a4, void *aBlock, void *a6)
{
  unsigned char v6[2] = a6;
  v6[3] = _Block_copy(aBlock);
  id v12 = a4;
  id v13 = a1;
  a6;
  uint64_t v14 = sub_100725B50();
  uint64_t v16 = v15;

  void v6[4] = v14;
  void v6[5] = v16;
  if (a4)
  {
    a4 = (void *)sub_100726430();
    uint64_t v18 = v17;
  }
  else
  {
    uint64_t v18 = 0;
  }
  void v6[6] = v18;
  uint64_t v19 = (void *)swift_task_alloc();
  v6[7] = v19;
  *uint64_t v19 = v6;
  v19[1] = sub_10045B69C;
  return IDSDSessionKeyValueDelivery.send(_:for:encryption:capability:)(v14, v16, a2, a3, (uint64_t)a4, v18);
}

uint64_t sub_10045B69C()
{
  uint64_t v2 = v0;
  uint64_t v4 = *v1;
  uint64_t v3 = *v1;
  unint64_t v5 = *(void *)(*v1 + 40);
  uint64_t v6 = *(void *)(*v1 + 32);
  int v7 = *(void **)(*v1 + 16);
  uint64_t v8 = *v1;
  swift_task_dealloc();

  swift_bridgeObjectRelease();
  sub_100442248(v6, v5);
  uint64_t v9 = *(void *)(v3 + 24);
  if (v2)
  {
    unint64_t v10 = (void *)sub_100725A10();
    swift_errorRelease();
    (*(void (**)(uint64_t, void *))(v9 + 16))(v9, v10);
  }
  else
  {
    (*(void (**)(void, void))(v9 + 16))(*(void *)(v3 + 24), 0);
  }
  _Block_release(*(const void **)(v4 + 24));
  uint64_t v11 = *(uint64_t (**)(void))(v8 + 8);
  return v11();
}

void IDSDSessionKeyValueDelivery.requestData(for:participantID:)(uint64_t a1, uint64_t a2)
{
  unint64_t v5 = (os_unfair_lock_s *)(*(void *)(v2 + OBJC_IVAR____TtC17identityservicesd27IDSDSessionKeyValueDelivery_state)
                          + 48);
  os_unfair_lock_lock(v5);
  sub_10045B938((uint64_t *)&v6);
  os_unfair_lock_unlock(v5);
  if (v6)
  {
    [v6 requestKeyValueDeliveryDataForKey:a1 participantID:a2];
    swift_unknownObjectRelease();
  }
}

uint64_t sub_10045B938@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = swift_unknownObjectWeakLoadStrong();
  *a1 = result;
  return result;
}

uint64_t sub_10045BBD4(void *a1)
{
  uint64_t v2 = *(uint64_t (**)(unsigned char *))((swift_isaMask & *a1) + 0x130);
  id v3 = v1;
  uint64_t v4 = (uint64_t (*)(unsigned char *, void))v2(v13);
  id v6 = v5;
  int v7 = *v5;
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  *id v6 = v7;
  if ((isUniquelyReferenced_nonNull_native & 1) == 0)
  {
    int v7 = sub_10045C52C(0, v7[2] + 1, 1, v7);
    *id v6 = v7;
  }
  unint64_t v10 = v7[2];
  unint64_t v9 = v7[3];
  if (v10 >= v9 >> 1)
  {
    int v7 = sub_10045C52C((void *)(v9 > 1), v10 + 1, 1, v7);
    *id v6 = v7;
  }
  v7[2] = v10 + 1;
  uint64_t v11 = &v7[2 * v10];
  uint64_t v11[4] = v3;
  void v11[5] = &off_10098DCC8;
  return v4(v13, 0);
}

id IDSDSessionKeyValueDelivery.__allocating_init()()
{
  id v1 = objc_allocWithZone(v0);

  return [v1 init];
}

void IDSDSessionKeyValueDelivery.init()()
{
}

uint64_t sub_10045BEC8()
{
  return (*(uint64_t (**)(void))((swift_isaMask & *v0) + 0xE8))();
}

Swift::Int sub_10045BEFC()
{
  Swift::UInt32 v1 = *v0;
  sub_100726DD0();
  sub_100726E00(v1);
  return sub_100726E30();
}

void sub_10045BF44()
{
  sub_100726E00(*v0);
}

Swift::Int sub_10045BF70()
{
  Swift::UInt32 v1 = *v0;
  sub_100726DD0();
  sub_100726E00(v1);
  return sub_100726E30();
}

BOOL sub_10045BFB4(_DWORD *a1, _DWORD *a2)
{
  return *a1 == *a2;
}

BOOL sub_10045BFC8(void *a1, void *a2)
{
  return *a1 == *a2;
}

_DWORD *sub_10045BFDC@<X0>(_DWORD *result@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)a2 = *result;
  *(unsigned char *)(a2 + 4) = 0;
  return result;
}

void sub_10045BFEC(_DWORD *a1@<X8>)
{
  *a1 = *v1;
}

void *sub_10045BFF8@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = *result;
  *(unsigned char *)(a2 + _Block_object_dispose(&STACK[0x320], 8) = 0;
  return result;
}

void sub_10045C008(void *a1@<X8>)
{
  *a1 = *v1;
}

uint64_t sub_10045C014(uint64_t a1, uint64_t a2, int *a3)
{
  id v6 = (uint64_t (*)(void))((char *)a3 + *a3);
  uint64_t v4 = (void *)swift_task_alloc();
  *(void *)(v3 + 16) = v4;
  *uint64_t v4 = v3;
  v4[1] = sub_100462CA4;
  return v6();
}

uint64_t sub_10045C0E0(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v7 = (uint64_t (*)(void))((char *)a4 + *a4);
  unint64_t v5 = (void *)swift_task_alloc();
  *(void *)(v4 + 16) = v5;
  *unint64_t v5 = v4;
  v5[1] = sub_100462CA4;
  return v7();
}

uint64_t sub_10045C1AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_100726600();
  uint64_t v7 = *(void *)(v6 - 8);
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v7 + 48))(a1, 1, v6) != 1)
  {
    sub_1007265F0();
    (*(void (**)(uint64_t, uint64_t))(v7 + 8))(a1, v6);
    if (!*(void *)(a3 + 16)) {
      goto LABEL_5;
    }
    goto LABEL_3;
  }
  sub_10044C150(a1, &qword_100A45350);
  if (*(void *)(a3 + 16))
  {
LABEL_3:
    swift_getObjectType();
    swift_unknownObjectRetain();
    sub_1007265D0();
    swift_unknownObjectRelease();
  }
LABEL_5:
  uint64_t v8 = swift_allocObject();
  *(void *)(v8 + 16) = a2;
  *(void *)(v8 + 24) = a3;
  return swift_task_create();
}

uint64_t sub_10045C358(uint64_t a1, int *a2)
{
  uint64_t v6 = (uint64_t (*)(uint64_t))((char *)a2 + *a2);
  uint64_t v4 = (void *)swift_task_alloc();
  *(void *)(v2 + 16) = v4;
  *uint64_t v4 = v2;
  v4[1] = sub_10045C434;
  return v6(a1);
}

uint64_t sub_10045C434()
{
  uint64_t v3 = *v0;
  swift_task_dealloc();
  Swift::UInt32 v1 = *(uint64_t (**)(void))(v3 + 8);
  return v1();
}

void *sub_10045C52C(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }
  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2) {
    goto LABEL_8;
  }
  if (v7 + 0x4000000000000000 >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
      uint64_t v7 = a2;
    }
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      sub_100431F80(&qword_100A45398);
      unint64_t v10 = (void *)swift_allocObject();
      int64_t v11 = j__malloc_size(v10);
      uint64_t v12 = v11 - 32;
      if (v11 < 32) {
        uint64_t v12 = v11 - 17;
      }
      v10[2] = v8;
      v10[3] = 2 * (v12 >> 4);
      uint64_t v13 = v10 + 4;
      if (v5) {
        goto LABEL_15;
      }
    }
    else
    {
      unint64_t v10 = &_swiftEmptyArrayStorage;
      uint64_t v13 = &_swiftEmptyArrayStorage + 4;
      if (result)
      {
LABEL_15:
        if (v10 != a4 || v13 >= &a4[2 * v8 + 4]) {
          memmove(v13, a4 + 4, 16 * v8);
        }
        a4[2] = 0;
        goto LABEL_24;
      }
    }
    sub_1004629F0(0, v8, (unint64_t)v13, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease();
    return v10;
  }
  __break(1u);
  return result;
}

unint64_t sub_10045C63C(uint64_t a1)
{
  sub_100725D30();
  sub_1004614A0(&qword_100A44F48, (void (*)(uint64_t))&type metadata accessor for UUID);
  uint64_t v2 = sub_1007263D0();

  return sub_10045C840(a1, v2);
}

unint64_t sub_10045C6D4(Swift::UInt32 a1)
{
  sub_100726DD0();
  sub_100726E00(a1);
  Swift::Int v2 = sub_100726E30();

  return sub_10045CA00(a1, v2);
}

unint64_t sub_10045C740(uint64_t a1)
{
  uint64_t v2 = v1;
  Swift::Int v4 = sub_1007267E0(*(void *)(v2 + 40));

  return sub_10045CA9C(a1, v4);
}

unint64_t sub_10045C784(uint64_t a1, uint64_t a2)
{
  sub_100726DD0();
  sub_100726490();
  Swift::Int v4 = sub_100726E30();

  return sub_10045CBB8(a1, a2, v4);
}

unint64_t sub_10045C7FC(uint64_t a1)
{
  uint64_t v2 = sub_100726DC0();

  return sub_10045CC9C(a1, v2);
}

unint64_t sub_10045C840(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = a1;
  uint64_t v4 = sub_100725D30();
  uint64_t v5 = *(void *)(v4 - 8);
  __chkstk_darwin(v4, v6);
  uint64_t v8 = (char *)&v18 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v21 = v2;
  uint64_t v9 = -1 << *(unsigned char *)(v2 + 32);
  unint64_t v10 = a2 & ~v9;
  uint64_t v19 = v2 + 64;
  if ((*(void *)(v2 + 64 + ((v10 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v10))
  {
    uint64_t v11 = ~v9;
    uint64_t v14 = *(void (**)(char *, unint64_t, uint64_t))(v5 + 16);
    uint64_t v13 = v5 + 16;
    uint64_t v12 = v14;
    uint64_t v15 = *(void *)(v13 + 56);
    do
    {
      v12(v8, *(void *)(v21 + 48) + v15 * v10, v4);
      sub_1004614A0(&qword_100A45458, (void (*)(uint64_t))&type metadata accessor for UUID);
      char v16 = sub_100726410();
      (*(void (**)(char *, uint64_t))(v13 - 8))(v8, v4);
      if (v16) {
        break;
      }
      unint64_t v10 = (v10 + 1) & v11;
    }
    while (((*(void *)(v19 + ((v10 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v10) & 1) != 0);
  }
  return v10;
}

unint64_t sub_10045CA00(int a1, uint64_t a2)
{
  uint64_t v4 = v2 + 64;
  uint64_t v5 = -1 << *(unsigned char *)(v2 + 32);
  unint64_t result = a2 & ~v5;
  if ((*(void *)(v2 + 64 + ((result >> 3) & 0xFFFFFFFFFFFFFF8)) >> result))
  {
    uint64_t v7 = *(void *)(v2 + 48);
    if (*(_DWORD *)(v7 + 4 * result) != a1)
    {
      uint64_t v8 = ~v5;
      for (unint64_t result = (result + 1) & v8;
            ((*(void *)(v4 + ((result >> 3) & 0xFFFFFFFFFFFFFF8)) >> result) & 1) != 0;
            unint64_t result = (result + 1) & v8)
      {
        if (*(_DWORD *)(v7 + 4 * result) == a1) {
          break;
        }
      }
    }
  }
  return result;
}

unint64_t sub_10045CA9C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2 + 64;
  uint64_t v4 = -1 << *(unsigned char *)(v2 + 32);
  unint64_t i = a2 & ~v4;
  if ((*(void *)(v2 + 64 + ((i >> 3) & 0xFFFFFFFFFFFFFF8)) >> i))
  {
    sub_100462C50(0, (unint64_t *)&unk_100A468F0);
    id v6 = *(id *)(*(void *)(v2 + 48) + 8 * i);
    char v7 = sub_1007267F0();

    if ((v7 & 1) == 0)
    {
      uint64_t v8 = ~v4;
      for (unint64_t i = (i + 1) & v8; ((*(void *)(v3 + ((i >> 3) & 0xFFFFFFFFFFFFFF8)) >> i) & 1) != 0; unint64_t i = (i + 1) & v8)
      {
        id v9 = *(id *)(*(void *)(v2 + 48) + 8 * i);
        char v10 = sub_1007267F0();

        if (v10) {
          break;
        }
      }
    }
  }
  return i;
}

unint64_t sub_10045CBB8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3 + 64;
  uint64_t v5 = -1 << *(unsigned char *)(v3 + 32);
  unint64_t v6 = a3 & ~v5;
  if ((*(void *)(v3 + 64 + ((v6 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v6))
  {
    uint64_t v9 = *(void *)(v3 + 48);
    char v10 = (void *)(v9 + 16 * v6);
    BOOL v11 = *v10 == a1 && v10[1] == a2;
    if (!v11 && (sub_100726D20() & 1) == 0)
    {
      uint64_t v12 = ~v5;
      do
      {
        unint64_t v6 = (v6 + 1) & v12;
        if (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v6) & 1) == 0) {
          break;
        }
        uint64_t v13 = (void *)(v9 + 16 * v6);
        BOOL v14 = *v13 == a1 && v13[1] == a2;
      }
      while (!v14 && (sub_100726D20() & 1) == 0);
    }
  }
  return v6;
}

unint64_t sub_10045CC9C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = v2 + 64;
  uint64_t v5 = -1 << *(unsigned char *)(v2 + 32);
  unint64_t result = a2 & ~v5;
  if ((*(void *)(v2 + 64 + ((result >> 3) & 0xFFFFFFFFFFFFFF8)) >> result))
  {
    uint64_t v7 = *(void *)(v2 + 48);
    if (*(void *)(v7 + 8 * result) != a1)
    {
      uint64_t v8 = ~v5;
      for (unint64_t result = (result + 1) & v8;
            ((*(void *)(v4 + ((result >> 3) & 0xFFFFFFFFFFFFFF8)) >> result) & 1) != 0;
            unint64_t result = (result + 1) & v8)
      {
        if (*(void *)(v7 + 8 * result) == a1) {
          break;
        }
      }
    }
  }
  return result;
}

uint64_t sub_10045CD38(uint64_t a1)
{
  uint64_t v2 = v1;
  swift_bridgeObjectRetain();
  unint64_t v4 = sub_10045C63C(a1);
  LOBYTE(a1) = v5;
  swift_bridgeObjectRelease();
  if ((a1 & 1) == 0) {
    return 0;
  }
  int isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  uint64_t v7 = *v2;
  uint64_t v12 = *v2;
  uint64_t *v2 = 0x8000000000000000;
  if (!isUniquelyReferenced_nonNull_native)
  {
    sub_10045F1E0();
    uint64_t v7 = v12;
  }
  uint64_t v8 = *(void *)(v7 + 48);
  uint64_t v9 = sub_100725D30();
  (*(void (**)(unint64_t, uint64_t))(*(void *)(v9 - 8) + 8))(v8 + *(void *)(*(void *)(v9 - 8) + 72) * v4, v9);
  uint64_t v10 = *(void *)(*(void *)(v7 + 56) + 8 * v4);
  sub_10045E144(v4, v7);
  uint64_t *v2 = v7;
  swift_bridgeObjectRelease();
  return v10;
}

uint64_t sub_10045CE30(uint64_t a1, char a2)
{
  uint64_t v3 = v2;
  uint64_t v5 = *v2;
  sub_100431F80(&qword_100A45460);
  uint64_t v6 = sub_100726BC0();
  uint64_t v7 = v6;
  if (!*(void *)(v5 + 16)) {
    goto LABEL_40;
  }
  uint64_t v8 = 1 << *(unsigned char *)(v5 + 32);
  unint64_t v35 = v2;
  uint64_t v36 = v5 + 64;
  if (v8 < 64) {
    uint64_t v9 = ~(-1 << v8);
  }
  else {
    uint64_t v9 = -1;
  }
  unint64_t v10 = v9 & *(void *)(v5 + 64);
  int64_t v11 = (unint64_t)(v8 + 63) >> 6;
  uint64_t v12 = v6 + 64;
  uint64_t result = swift_retain();
  int64_t v14 = 0;
  while (1)
  {
    if (v10)
    {
      unint64_t v20 = __clz(__rbit64(v10));
      v10 &= v10 - 1;
      unint64_t v21 = v20 | (v14 << 6);
      goto LABEL_31;
    }
    int64_t v22 = v14 + 1;
    if (__OFADD__(v14, 1))
    {
LABEL_41:
      __break(1u);
LABEL_42:
      __break(1u);
      return result;
    }
    if (v22 >= v11) {
      break;
    }
    NSString v23 = (void *)(v5 + 64);
    unint64_t v24 = *(void *)(v36 + 8 * v22);
    ++v14;
    if (!v24)
    {
      int64_t v14 = v22 + 1;
      if (v22 + 1 >= v11) {
        goto LABEL_33;
      }
      unint64_t v24 = *(void *)(v36 + 8 * v14);
      if (!v24)
      {
        int64_t v25 = v22 + 2;
        if (v25 >= v11)
        {
LABEL_33:
          swift_release();
          uint64_t v3 = v35;
          if ((a2 & 1) == 0) {
            goto LABEL_40;
          }
          goto LABEL_36;
        }
        unint64_t v24 = *(void *)(v36 + 8 * v25);
        if (!v24)
        {
          while (1)
          {
            int64_t v14 = v25 + 1;
            if (__OFADD__(v25, 1)) {
              goto LABEL_42;
            }
            if (v14 >= v11) {
              goto LABEL_33;
            }
            unint64_t v24 = *(void *)(v36 + 8 * v14);
            ++v25;
            if (v24) {
              goto LABEL_30;
            }
          }
        }
        int64_t v14 = v25;
      }
    }
LABEL_30:
    unint64_t v10 = (v24 - 1) & v24;
    unint64_t v21 = __clz(__rbit64(v24)) + (v14 << 6);
LABEL_31:
    uint64_t v30 = 8 * v21;
    long long v31 = *(void **)(*(void *)(v5 + 48) + v30);
    uint64_t v32 = *(void *)(*(void *)(v5 + 56) + v30);
    if ((a2 & 1) == 0)
    {
      id v33 = v31;
      swift_bridgeObjectRetain();
    }
    uint64_t result = sub_1007267E0(*(void *)(v7 + 40));
    uint64_t v15 = -1 << *(unsigned char *)(v7 + 32);
    unint64_t v16 = result & ~v15;
    unint64_t v17 = v16 >> 6;
    if (((-1 << v16) & ~*(void *)(v12 + 8 * (v16 >> 6))) != 0)
    {
      unint64_t v18 = __clz(__rbit64((-1 << v16) & ~*(void *)(v12 + 8 * (v16 >> 6)))) | v16 & 0x7FFFFFFFFFFFFFC0;
    }
    else
    {
      char v26 = 0;
      unint64_t v27 = (unint64_t)(63 - v15) >> 6;
      do
      {
        if (++v17 == v27 && (v26 & 1) != 0)
        {
          __break(1u);
          goto LABEL_41;
        }
        BOOL v28 = v17 == v27;
        if (v17 == v27) {
          unint64_t v17 = 0;
        }
        v26 |= v28;
        uint64_t v29 = *(void *)(v12 + 8 * v17);
      }
      while (v29 == -1);
      unint64_t v18 = __clz(__rbit64(~v29)) + (v17 << 6);
    }
    *(void *)(v12 + ((v18 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v18;
    uint64_t v19 = 8 * v18;
    *(void *)(*(void *)(v7 + 48) + v19) = v31;
    *(void *)(*(void *)(v7 + 56) + v19) = v32;
    ++*(void *)(v7 + 16);
  }
  swift_release();
  uint64_t v3 = v35;
  NSString v23 = (void *)(v5 + 64);
  if ((a2 & 1) == 0) {
    goto LABEL_40;
  }
LABEL_36:
  uint64_t v34 = 1 << *(unsigned char *)(v5 + 32);
  if (v34 >= 64) {
    bzero(v23, ((unint64_t)(v34 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
  }
  else {
    *NSString v23 = -1 << v34;
  }
  *(void *)(v5 + 16) = 0;
LABEL_40:
  uint64_t result = swift_release();
  *uint64_t v3 = v7;
  return result;
}

uint64_t sub_10045D108(uint64_t a1, char a2)
{
  uint64_t v3 = v2;
  uint64_t v5 = *v2;
  sub_100431F80(&qword_100A45468);
  uint64_t v6 = sub_100726BC0();
  uint64_t v7 = v6;
  if (*(void *)(v5 + 16))
  {
    uint64_t v32 = v2;
    uint64_t v8 = 1 << *(unsigned char *)(v5 + 32);
    uint64_t v9 = (void *)(v5 + 64);
    if (v8 < 64) {
      uint64_t v10 = ~(-1 << v8);
    }
    else {
      uint64_t v10 = -1;
    }
    unint64_t v11 = v10 & *(void *)(v5 + 64);
    int64_t v12 = (unint64_t)(v8 + 63) >> 6;
    uint64_t v13 = v6 + 64;
    uint64_t result = swift_retain();
    int64_t v15 = 0;
    while (1)
    {
      if (v11)
      {
        unint64_t v20 = __clz(__rbit64(v11));
        v11 &= v11 - 1;
        unint64_t v21 = v20 | (v15 << 6);
      }
      else
      {
        int64_t v22 = v15 + 1;
        if (__OFADD__(v15, 1))
        {
LABEL_41:
          __break(1u);
LABEL_42:
          __break(1u);
          return result;
        }
        if (v22 >= v12) {
          goto LABEL_33;
        }
        unint64_t v23 = v9[v22];
        ++v15;
        if (!v23)
        {
          int64_t v15 = v22 + 1;
          if (v22 + 1 >= v12) {
            goto LABEL_33;
          }
          unint64_t v23 = v9[v15];
          if (!v23)
          {
            int64_t v24 = v22 + 2;
            if (v24 >= v12)
            {
LABEL_33:
              swift_release();
              if ((a2 & 1) == 0)
              {
                uint64_t result = swift_release();
                uint64_t v3 = v32;
                goto LABEL_40;
              }
              uint64_t v31 = 1 << *(unsigned char *)(v5 + 32);
              if (v31 >= 64) {
                bzero((void *)(v5 + 64), ((unint64_t)(v31 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
              }
              else {
                *uint64_t v9 = -1 << v31;
              }
              uint64_t v3 = v32;
              *(void *)(v5 + 16) = 0;
              break;
            }
            unint64_t v23 = v9[v24];
            if (!v23)
            {
              while (1)
              {
                int64_t v15 = v24 + 1;
                if (__OFADD__(v24, 1)) {
                  goto LABEL_42;
                }
                if (v15 >= v12) {
                  goto LABEL_33;
                }
                unint64_t v23 = v9[v15];
                ++v24;
                if (v23) {
                  goto LABEL_30;
                }
              }
            }
            int64_t v15 = v24;
          }
        }
LABEL_30:
        unint64_t v11 = (v23 - 1) & v23;
        unint64_t v21 = __clz(__rbit64(v23)) + (v15 << 6);
      }
      uint64_t v29 = *(void **)(*(void *)(v5 + 48) + 8 * v21);
      long long v33 = *(_OWORD *)(*(void *)(v5 + 56) + 16 * v21);
      if ((a2 & 1) == 0)
      {
        id v30 = v29;
        sub_100441FD4(v33, *((unint64_t *)&v33 + 1));
      }
      uint64_t result = sub_1007267E0(*(void *)(v7 + 40));
      uint64_t v16 = -1 << *(unsigned char *)(v7 + 32);
      unint64_t v17 = result & ~v16;
      unint64_t v18 = v17 >> 6;
      if (((-1 << v17) & ~*(void *)(v13 + 8 * (v17 >> 6))) != 0)
      {
        unint64_t v19 = __clz(__rbit64((-1 << v17) & ~*(void *)(v13 + 8 * (v17 >> 6)))) | v17 & 0x7FFFFFFFFFFFFFC0;
      }
      else
      {
        char v25 = 0;
        unint64_t v26 = (unint64_t)(63 - v16) >> 6;
        do
        {
          if (++v18 == v26 && (v25 & 1) != 0)
          {
            __break(1u);
            goto LABEL_41;
          }
          BOOL v27 = v18 == v26;
          if (v18 == v26) {
            unint64_t v18 = 0;
          }
          v25 |= v27;
          uint64_t v28 = *(void *)(v13 + 8 * v18);
        }
        while (v28 == -1);
        unint64_t v19 = __clz(__rbit64(~v28)) + (v18 << 6);
      }
      *(void *)(v13 + ((v19 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v19;
      *(void *)(*(void *)(v7 + 48) + 8 * v19) = v29;
      *(_OWORD *)(*(void *)(v7 + 56) + 16 * v19) = v33;
      ++*(void *)(v7 + 16);
    }
  }
  uint64_t result = swift_release();
LABEL_40:
  *uint64_t v3 = v7;
  return result;
}

uint64_t sub_10045D3E0(uint64_t a1, int a2)
{
  uint64_t v3 = v2;
  uint64_t v5 = sub_100725D30();
  uint64_t v6 = *(void *)(v5 - 8);
  __chkstk_darwin(v5, v7);
  uint64_t v9 = (char *)&v40 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = *v2;
  sub_100431F80(&qword_100A45450);
  int v47 = a2;
  uint64_t v11 = sub_100726BC0();
  uint64_t v12 = v10;
  uint64_t v13 = v11;
  if (!*(void *)(v12 + 16)) {
    goto LABEL_41;
  }
  uint64_t v14 = 1 << *(unsigned char *)(v12 + 32);
  uint64_t v15 = *(void *)(v12 + 64);
  int64_t v43 = (void *)(v12 + 64);
  if (v14 < 64) {
    uint64_t v16 = ~(-1 << v14);
  }
  else {
    uint64_t v16 = -1;
  }
  unint64_t v17 = v16 & v15;
  int64_t v41 = v3;
  int64_t v42 = (unint64_t)(v14 + 63) >> 6;
  uint64_t v44 = (void (**)(char *, unint64_t, uint64_t))(v6 + 16);
  uint64_t v46 = v6;
  unint64_t v18 = (void (**)(char *, unint64_t, uint64_t))(v6 + 32);
  uint64_t v19 = v11 + 64;
  uint64_t result = swift_retain();
  int64_t v21 = 0;
  for (i = v12; ; uint64_t v12 = i)
  {
    if (v17)
    {
      unint64_t v23 = __clz(__rbit64(v17));
      v17 &= v17 - 1;
      unint64_t v24 = v23 | (v21 << 6);
      goto LABEL_22;
    }
    int64_t v25 = v21 + 1;
    if (__OFADD__(v21, 1))
    {
LABEL_42:
      __break(1u);
LABEL_43:
      __break(1u);
      return result;
    }
    if (v25 >= v42) {
      break;
    }
    unint64_t v26 = v43;
    unint64_t v27 = v43[v25];
    ++v21;
    if (!v27)
    {
      int64_t v21 = v25 + 1;
      if (v25 + 1 >= v42) {
        goto LABEL_34;
      }
      unint64_t v27 = v43[v21];
      if (!v27)
      {
        int64_t v28 = v25 + 2;
        if (v28 >= v42)
        {
LABEL_34:
          swift_release();
          uint64_t v3 = v41;
          if ((v47 & 1) == 0) {
            goto LABEL_41;
          }
          goto LABEL_37;
        }
        unint64_t v27 = v43[v28];
        if (!v27)
        {
          while (1)
          {
            int64_t v21 = v28 + 1;
            if (__OFADD__(v28, 1)) {
              goto LABEL_43;
            }
            if (v21 >= v42) {
              goto LABEL_34;
            }
            unint64_t v27 = v43[v21];
            ++v28;
            if (v27) {
              goto LABEL_21;
            }
          }
        }
        int64_t v21 = v28;
      }
    }
LABEL_21:
    unint64_t v17 = (v27 - 1) & v27;
    unint64_t v24 = __clz(__rbit64(v27)) + (v21 << 6);
LABEL_22:
    uint64_t v29 = *(void *)(v46 + 72);
    unint64_t v30 = *(void *)(v12 + 48) + v29 * v24;
    if (v47)
    {
      (*v18)(v9, v30, v5);
      uint64_t v31 = *(void *)(*(void *)(v12 + 56) + 8 * v24);
    }
    else
    {
      (*v44)(v9, v30, v5);
      uint64_t v31 = *(void *)(*(void *)(v12 + 56) + 8 * v24);
      swift_unknownObjectRetain();
    }
    sub_1004614A0(&qword_100A44F48, (void (*)(uint64_t))&type metadata accessor for UUID);
    uint64_t result = sub_1007263D0();
    uint64_t v32 = -1 << *(unsigned char *)(v13 + 32);
    unint64_t v33 = result & ~v32;
    unint64_t v34 = v33 >> 6;
    if (((-1 << v33) & ~*(void *)(v19 + 8 * (v33 >> 6))) != 0)
    {
      unint64_t v22 = __clz(__rbit64((-1 << v33) & ~*(void *)(v19 + 8 * (v33 >> 6)))) | v33 & 0x7FFFFFFFFFFFFFC0;
    }
    else
    {
      char v35 = 0;
      unint64_t v36 = (unint64_t)(63 - v32) >> 6;
      do
      {
        if (++v34 == v36 && (v35 & 1) != 0)
        {
          __break(1u);
          goto LABEL_42;
        }
        BOOL v37 = v34 == v36;
        if (v34 == v36) {
          unint64_t v34 = 0;
        }
        v35 |= v37;
        uint64_t v38 = *(void *)(v19 + 8 * v34);
      }
      while (v38 == -1);
      unint64_t v22 = __clz(__rbit64(~v38)) + (v34 << 6);
    }
    *(void *)(v19 + ((v22 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v22;
    uint64_t result = ((uint64_t (*)(unint64_t, char *, uint64_t))*v18)(*(void *)(v13 + 48) + v29 * v22, v9, v5);
    *(void *)(*(void *)(v13 + 56) + 8 * v22) = v31;
    ++*(void *)(v13 + 16);
  }
  swift_release();
  uint64_t v3 = v41;
  unint64_t v26 = v43;
  if ((v47 & 1) == 0) {
    goto LABEL_41;
  }
LABEL_37:
  uint64_t v39 = 1 << *(unsigned char *)(v12 + 32);
  if (v39 >= 64) {
    bzero(v26, ((unint64_t)(v39 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
  }
  else {
    void *v26 = -1 << v39;
  }
  *(void *)(v12 + 16) = 0;
LABEL_41:
  uint64_t result = swift_release();
  *uint64_t v3 = v13;
  return result;
}

uint64_t sub_10045D804(uint64_t a1, char a2)
{
  uint64_t v3 = v2;
  uint64_t v5 = *v2;
  sub_100431F80(&qword_100A453D8);
  uint64_t result = sub_100726BC0();
  uint64_t v7 = result;
  if (*(void *)(v5 + 16))
  {
    int64_t v8 = 0;
    unint64_t v30 = (void *)(v5 + 64);
    uint64_t v9 = 1 << *(unsigned char *)(v5 + 32);
    if (v9 < 64) {
      uint64_t v10 = ~(-1 << v9);
    }
    else {
      uint64_t v10 = -1;
    }
    unint64_t v11 = v10 & *(void *)(v5 + 64);
    int64_t v29 = (unint64_t)(v9 + 63) >> 6;
    uint64_t v12 = result + 64;
    while (1)
    {
      if (v11)
      {
        unint64_t v17 = __clz(__rbit64(v11));
        v11 &= v11 - 1;
        unint64_t v18 = v17 | (v8 << 6);
      }
      else
      {
        int64_t v19 = v8 + 1;
        if (__OFADD__(v8, 1))
        {
LABEL_41:
          __break(1u);
LABEL_42:
          __break(1u);
          return result;
        }
        uint64_t result = v5 + 64;
        if (v19 >= v29) {
          goto LABEL_33;
        }
        unint64_t v20 = v30[v19];
        ++v8;
        if (!v20)
        {
          int64_t v8 = v19 + 1;
          if (v19 + 1 >= v29) {
            goto LABEL_33;
          }
          unint64_t v20 = v30[v8];
          if (!v20)
          {
            int64_t v21 = v19 + 2;
            if (v21 >= v29)
            {
LABEL_33:
              if ((a2 & 1) == 0)
              {
                uint64_t result = swift_release();
                uint64_t v3 = v2;
                goto LABEL_40;
              }
              uint64_t v28 = 1 << *(unsigned char *)(v5 + 32);
              if (v28 >= 64) {
                bzero(v30, ((unint64_t)(v28 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
              }
              else {
                *unint64_t v30 = -1 << v28;
              }
              uint64_t v3 = v2;
              *(void *)(v5 + 16) = 0;
              break;
            }
            unint64_t v20 = v30[v21];
            if (!v20)
            {
              while (1)
              {
                int64_t v8 = v21 + 1;
                if (__OFADD__(v21, 1)) {
                  goto LABEL_42;
                }
                if (v8 >= v29) {
                  goto LABEL_33;
                }
                unint64_t v20 = v30[v8];
                ++v21;
                if (v20) {
                  goto LABEL_30;
                }
              }
            }
            int64_t v8 = v21;
          }
        }
LABEL_30:
        unint64_t v11 = (v20 - 1) & v20;
        unint64_t v18 = __clz(__rbit64(v20)) + (v8 << 6);
      }
      Swift::UInt32 v26 = *(_DWORD *)(*(void *)(v5 + 48) + 4 * v18);
      uint64_t v27 = *(void *)(*(void *)(v5 + 56) + 8 * v18);
      if ((a2 & 1) == 0) {
        swift_bridgeObjectRetain();
      }
      sub_100726DD0();
      sub_100726E00(v26);
      uint64_t result = sub_100726E30();
      uint64_t v13 = -1 << *(unsigned char *)(v7 + 32);
      unint64_t v14 = result & ~v13;
      unint64_t v15 = v14 >> 6;
      if (((-1 << v14) & ~*(void *)(v12 + 8 * (v14 >> 6))) != 0)
      {
        unint64_t v16 = __clz(__rbit64((-1 << v14) & ~*(void *)(v12 + 8 * (v14 >> 6)))) | v14 & 0x7FFFFFFFFFFFFFC0;
      }
      else
      {
        char v22 = 0;
        unint64_t v23 = (unint64_t)(63 - v13) >> 6;
        do
        {
          if (++v15 == v23 && (v22 & 1) != 0)
          {
            __break(1u);
            goto LABEL_41;
          }
          BOOL v24 = v15 == v23;
          if (v15 == v23) {
            unint64_t v15 = 0;
          }
          v22 |= v24;
          uint64_t v25 = *(void *)(v12 + 8 * v15);
        }
        while (v25 == -1);
        unint64_t v16 = __clz(__rbit64(~v25)) + (v15 << 6);
      }
      *(void *)(v12 + ((v16 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v16;
      *(_DWORD *)(*(void *)(v7 + 48) + 4 * v16) = v26;
      *(void *)(*(void *)(v7 + 56) + 8 * v16) = v27;
      ++*(void *)(v7 + 16);
    }
  }
  uint64_t result = swift_release();
LABEL_40:
  *uint64_t v3 = v7;
  return result;
}

uint64_t sub_10045DAD8(uint64_t a1, char a2)
{
  uint64_t v3 = v2;
  uint64_t v5 = *v2;
  sub_100431F80(&qword_100A453C8);
  uint64_t result = sub_100726BC0();
  uint64_t v7 = result;
  if (*(void *)(v5 + 16))
  {
    unint64_t v30 = v3;
    int64_t v8 = 0;
    uint64_t v9 = (void *)(v5 + 64);
    uint64_t v10 = 1 << *(unsigned char *)(v5 + 32);
    if (v10 < 64) {
      uint64_t v11 = ~(-1 << v10);
    }
    else {
      uint64_t v11 = -1;
    }
    unint64_t v12 = v11 & *(void *)(v5 + 64);
    int64_t v13 = (unint64_t)(v10 + 63) >> 6;
    uint64_t v14 = result + 64;
    while (1)
    {
      if (v12)
      {
        unint64_t v19 = __clz(__rbit64(v12));
        v12 &= v12 - 1;
        unint64_t v20 = v19 | (v8 << 6);
      }
      else
      {
        int64_t v21 = v8 + 1;
        if (__OFADD__(v8, 1))
        {
LABEL_41:
          __break(1u);
LABEL_42:
          __break(1u);
          return result;
        }
        if (v21 >= v13) {
          goto LABEL_33;
        }
        unint64_t v22 = v9[v21];
        ++v8;
        if (!v22)
        {
          int64_t v8 = v21 + 1;
          if (v21 + 1 >= v13) {
            goto LABEL_33;
          }
          unint64_t v22 = v9[v8];
          if (!v22)
          {
            int64_t v23 = v21 + 2;
            if (v23 >= v13)
            {
LABEL_33:
              if ((a2 & 1) == 0)
              {
                uint64_t result = swift_release();
                uint64_t v3 = v30;
                goto LABEL_40;
              }
              uint64_t v29 = 1 << *(unsigned char *)(v5 + 32);
              if (v29 >= 64) {
                bzero((void *)(v5 + 64), ((unint64_t)(v29 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
              }
              else {
                *uint64_t v9 = -1 << v29;
              }
              uint64_t v3 = v30;
              *(void *)(v5 + 16) = 0;
              break;
            }
            unint64_t v22 = v9[v23];
            if (!v22)
            {
              while (1)
              {
                int64_t v8 = v23 + 1;
                if (__OFADD__(v23, 1)) {
                  goto LABEL_42;
                }
                if (v8 >= v13) {
                  goto LABEL_33;
                }
                unint64_t v22 = v9[v8];
                ++v23;
                if (v22) {
                  goto LABEL_30;
                }
              }
            }
            int64_t v8 = v23;
          }
        }
LABEL_30:
        unint64_t v12 = (v22 - 1) & v22;
        unint64_t v20 = __clz(__rbit64(v22)) + (v8 << 6);
      }
      uint64_t v28 = *(void *)(*(void *)(v5 + 48) + 8 * v20);
      long long v31 = *(_OWORD *)(*(void *)(v5 + 56) + 16 * v20);
      if ((a2 & 1) == 0) {
        sub_100441FD4(v31, *((unint64_t *)&v31 + 1));
      }
      uint64_t result = sub_100726DC0();
      uint64_t v15 = -1 << *(unsigned char *)(v7 + 32);
      unint64_t v16 = result & ~v15;
      unint64_t v17 = v16 >> 6;
      if (((-1 << v16) & ~*(void *)(v14 + 8 * (v16 >> 6))) != 0)
      {
        unint64_t v18 = __clz(__rbit64((-1 << v16) & ~*(void *)(v14 + 8 * (v16 >> 6)))) | v16 & 0x7FFFFFFFFFFFFFC0;
      }
      else
      {
        char v24 = 0;
        unint64_t v25 = (unint64_t)(63 - v15) >> 6;
        do
        {
          if (++v17 == v25 && (v24 & 1) != 0)
          {
            __break(1u);
            goto LABEL_41;
          }
          BOOL v26 = v17 == v25;
          if (v17 == v25) {
            unint64_t v17 = 0;
          }
          v24 |= v26;
          uint64_t v27 = *(void *)(v14 + 8 * v17);
        }
        while (v27 == -1);
        unint64_t v18 = __clz(__rbit64(~v27)) + (v17 << 6);
      }
      *(void *)(v14 + ((v18 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v18;
      *(void *)(*(void *)(v7 + 48) + 8 * v1_Block_object_dispose(&STACK[0x320], 8) = v28;
      *(_OWORD *)(*(void *)(v7 + 56) + 16 * v1_Block_object_dispose(&STACK[0x320], 8) = v31;
      ++*(void *)(v7 + 16);
    }
  }
  uint64_t result = swift_release();
LABEL_40:
  *uint64_t v3 = v7;
  return result;
}

uint64_t sub_10045DDA0(uint64_t a1, int a2)
{
  uint64_t v3 = v2;
  uint64_t v5 = type metadata accessor for IDSDSessionKeyValueDeliveryLocalEntry(0);
  uint64_t v38 = *(void *)(v5 - 8);
  __chkstk_darwin(v5 - 8, v6);
  int64_t v8 = (char *)&v35 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v9 = *v2;
  sub_100431F80(&qword_100A453B0);
  int v39 = a2;
  uint64_t result = sub_100726BC0();
  uint64_t v11 = result;
  if (*(void *)(v9 + 16))
  {
    char v35 = v2;
    int64_t v12 = 0;
    uint64_t v13 = *(void *)(v9 + 64);
    BOOL v37 = (void *)(v9 + 64);
    uint64_t v14 = 1 << *(unsigned char *)(v9 + 32);
    if (v14 < 64) {
      uint64_t v15 = ~(-1 << v14);
    }
    else {
      uint64_t v15 = -1;
    }
    unint64_t v16 = v15 & v13;
    int64_t v36 = (unint64_t)(v14 + 63) >> 6;
    uint64_t v17 = result + 64;
    while (1)
    {
      if (v16)
      {
        unint64_t v19 = __clz(__rbit64(v16));
        v16 &= v16 - 1;
        unint64_t v20 = v19 | (v12 << 6);
      }
      else
      {
        int64_t v21 = v12 + 1;
        if (__OFADD__(v12, 1))
        {
LABEL_42:
          __break(1u);
LABEL_43:
          __break(1u);
          return result;
        }
        uint64_t result = (uint64_t)v37;
        if (v21 >= v36) {
          goto LABEL_34;
        }
        unint64_t v22 = v37[v21];
        ++v12;
        if (!v22)
        {
          int64_t v12 = v21 + 1;
          if (v21 + 1 >= v36) {
            goto LABEL_34;
          }
          unint64_t v22 = v37[v12];
          if (!v22)
          {
            int64_t v23 = v21 + 2;
            if (v23 >= v36)
            {
LABEL_34:
              if ((v39 & 1) == 0)
              {
                uint64_t result = swift_release();
                uint64_t v3 = v35;
                goto LABEL_41;
              }
              uint64_t v34 = 1 << *(unsigned char *)(v9 + 32);
              if (v34 >= 64) {
                bzero(v37, ((unint64_t)(v34 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
              }
              else {
                *BOOL v37 = -1 << v34;
              }
              uint64_t v3 = v35;
              *(void *)(v9 + 16) = 0;
              break;
            }
            unint64_t v22 = v37[v23];
            if (!v22)
            {
              while (1)
              {
                int64_t v12 = v23 + 1;
                if (__OFADD__(v23, 1)) {
                  goto LABEL_43;
                }
                if (v12 >= v36) {
                  goto LABEL_34;
                }
                unint64_t v22 = v37[v12];
                ++v23;
                if (v22) {
                  goto LABEL_21;
                }
              }
            }
            int64_t v12 = v23;
          }
        }
LABEL_21:
        unint64_t v16 = (v22 - 1) & v22;
        unint64_t v20 = __clz(__rbit64(v22)) + (v12 << 6);
      }
      Swift::UInt32 v24 = *(_DWORD *)(*(void *)(v9 + 48) + 4 * v20);
      uint64_t v25 = *(void *)(v38 + 72);
      uint64_t v26 = *(void *)(v9 + 56) + v25 * v20;
      if (v39) {
        sub_10046129C(v26, (uint64_t)v8, type metadata accessor for IDSDSessionKeyValueDeliveryLocalEntry);
      }
      else {
        sub_1004613A8(v26, (uint64_t)v8, type metadata accessor for IDSDSessionKeyValueDeliveryLocalEntry);
      }
      sub_100726DD0();
      sub_100726E00(v24);
      uint64_t result = sub_100726E30();
      uint64_t v27 = -1 << *(unsigned char *)(v11 + 32);
      unint64_t v28 = result & ~v27;
      unint64_t v29 = v28 >> 6;
      if (((-1 << v28) & ~*(void *)(v17 + 8 * (v28 >> 6))) != 0)
      {
        unint64_t v18 = __clz(__rbit64((-1 << v28) & ~*(void *)(v17 + 8 * (v28 >> 6)))) | v28 & 0x7FFFFFFFFFFFFFC0;
      }
      else
      {
        char v30 = 0;
        unint64_t v31 = (unint64_t)(63 - v27) >> 6;
        do
        {
          if (++v29 == v31 && (v30 & 1) != 0)
          {
            __break(1u);
            goto LABEL_42;
          }
          BOOL v32 = v29 == v31;
          if (v29 == v31) {
            unint64_t v29 = 0;
          }
          v30 |= v32;
          uint64_t v33 = *(void *)(v17 + 8 * v29);
        }
        while (v33 == -1);
        unint64_t v18 = __clz(__rbit64(~v33)) + (v29 << 6);
      }
      *(void *)(v17 + ((v18 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v18;
      *(_DWORD *)(*(void *)(v11 + 48) + 4 * v1_Block_object_dispose(&STACK[0x320], 8) = v24;
      uint64_t result = sub_10046129C((uint64_t)v8, *(void *)(v11 + 56) + v25 * v18, type metadata accessor for IDSDSessionKeyValueDeliveryLocalEntry);
      ++*(void *)(v11 + 16);
    }
  }
  uint64_t result = swift_release();
LABEL_41:
  *uint64_t v3 = v11;
  return result;
}

unint64_t sub_10045E144(int64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100725D30();
  uint64_t v5 = *(void *)(v4 - 8);
  unint64_t result = __chkstk_darwin(v4, v6);
  uint64_t v9 = (char *)&v32 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = -1 << *(unsigned char *)(a2 + 32);
  unint64_t v11 = (a1 + 1) & ~v10;
  if (((1 << v11) & *(void *)(a2 + 64 + 8 * (v11 >> 6))) != 0)
  {
    uint64_t v12 = ~v10;
    uint64_t v35 = a2 + 64;
    unint64_t result = sub_1007268A0();
    uint64_t v13 = v35;
    if ((*(void *)(v35 + 8 * (v11 >> 6)) & (1 << v11)) != 0)
    {
      unint64_t v32 = (result + 1) & v12;
      uint64_t v33 = *(void (**)(char *, unint64_t, uint64_t))(v5 + 16);
      uint64_t v34 = v5 + 16;
      uint64_t v14 = (uint64_t (**)(char *, uint64_t))(v5 + 8);
      uint64_t v15 = *(void *)(v5 + 72);
      do
      {
        uint64_t v16 = v15;
        int64_t v17 = v15 * v11;
        v33(v9, *(void *)(a2 + 48) + v15 * v11, v4);
        sub_1004614A0(&qword_100A44F48, (void (*)(uint64_t))&type metadata accessor for UUID);
        uint64_t v18 = sub_1007263D0();
        unint64_t result = (*v14)(v9, v4);
        unint64_t v19 = v18 & v12;
        if (a1 >= (uint64_t)v32)
        {
          if (v19 >= v32 && a1 >= (uint64_t)v19)
          {
LABEL_16:
            uint64_t v22 = *(void *)(a2 + 48);
            uint64_t v15 = v16;
            unint64_t result = v22 + v16 * a1;
            if (v16 * a1 < v17 || result >= v22 + v17 + v16)
            {
              unint64_t result = swift_arrayInitWithTakeFrontToBack();
            }
            else if (v16 * a1 != v17)
            {
              unint64_t result = swift_arrayInitWithTakeBackToFront();
            }
            uint64_t v23 = *(void *)(a2 + 56);
            Swift::UInt32 v24 = (void *)(v23 + 8 * a1);
            uint64_t v25 = (void *)(v23 + 8 * v11);
            uint64_t v13 = v35;
            if (a1 != v11 || (a1 = v11, v24 >= v25 + 1))
            {
              *Swift::UInt32 v24 = *v25;
              a1 = v11;
            }
            goto LABEL_5;
          }
        }
        else if (v19 >= v32 || a1 >= (uint64_t)v19)
        {
          goto LABEL_16;
        }
        uint64_t v13 = v35;
        uint64_t v15 = v16;
LABEL_5:
        unint64_t v11 = (v11 + 1) & v12;
      }
      while (((*(void *)(v13 + ((v11 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v11) & 1) != 0);
    }
    uint64_t v26 = (uint64_t *)(v13 + 8 * ((unint64_t)a1 >> 6));
    uint64_t v27 = *v26;
    uint64_t v28 = (-1 << a1) - 1;
  }
  else
  {
    uint64_t v26 = (uint64_t *)(a2 + 64 + 8 * ((unint64_t)a1 >> 6));
    uint64_t v28 = *v26;
    uint64_t v27 = (-1 << a1) - 1;
  }
  uint64_t *v26 = v28 & v27;
  uint64_t v29 = *(void *)(a2 + 16);
  BOOL v30 = __OFSUB__(v29, 1);
  uint64_t v31 = v29 - 1;
  if (v30)
  {
    __break(1u);
  }
  else
  {
    *(void *)(a2 + 16) = v31;
    ++*(_DWORD *)(a2 + 36);
  }
  return result;
}

unint64_t sub_10045E43C(unint64_t result, uint64_t a2)
{
  int64_t v3 = result;
  uint64_t v4 = a2 + 64;
  uint64_t v5 = -1 << *(unsigned char *)(a2 + 32);
  unint64_t v6 = (result + 1) & ~v5;
  if (((1 << v6) & *(void *)(a2 + 64 + 8 * (v6 >> 6))) != 0)
  {
    uint64_t v7 = ~v5;
    unint64_t result = sub_1007268A0();
    if ((*(void *)(v4 + 8 * (v6 >> 6)) & (1 << v6)) != 0)
    {
      unint64_t v8 = (result + 1) & v7;
      while (1)
      {
        Swift::UInt32 v9 = *(_DWORD *)(*(void *)(a2 + 48) + 4 * v6);
        sub_100726DD0();
        sub_100726E00(v9);
        unint64_t result = sub_100726E30();
        unint64_t v10 = result & v7;
        if (v3 >= (uint64_t)v8) {
          break;
        }
        if (v10 < v8) {
          goto LABEL_11;
        }
LABEL_12:
        uint64_t v11 = *(void *)(a2 + 48);
        uint64_t v12 = (_DWORD *)(v11 + 4 * v3);
        uint64_t v13 = (_DWORD *)(v11 + 4 * v6);
        if (v3 != v6 || v12 >= v13 + 1) {
          *uint64_t v12 = *v13;
        }
        uint64_t v14 = *(void *)(a2 + 56);
        uint64_t v15 = *(void *)(*(void *)(type metadata accessor for IDSDSessionKeyValueDeliveryLocalEntry(0) - 8) + 72);
        int64_t v16 = v15 * v3;
        unint64_t result = v14 + v15 * v3;
        int64_t v17 = v15 * v6;
        unint64_t v18 = v14 + v15 * v6 + v15;
        if (v16 < v17 || result >= v18)
        {
          unint64_t result = swift_arrayInitWithTakeFrontToBack();
        }
        else
        {
          int64_t v3 = v6;
          if (v16 == v17) {
            goto LABEL_6;
          }
          unint64_t result = swift_arrayInitWithTakeBackToFront();
        }
        int64_t v3 = v6;
LABEL_6:
        unint64_t v6 = (v6 + 1) & v7;
        if (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v6) & 1) == 0) {
          goto LABEL_21;
        }
      }
      if (v10 < v8) {
        goto LABEL_6;
      }
LABEL_11:
      if (v3 < (uint64_t)v10) {
        goto LABEL_6;
      }
      goto LABEL_12;
    }
LABEL_21:
    unint64_t v20 = (uint64_t *)(v4 + 8 * ((unint64_t)v3 >> 6));
    uint64_t v21 = *v20;
    uint64_t v22 = (-1 << v3) - 1;
  }
  else
  {
    unint64_t v20 = (uint64_t *)(v4 + 8 * (result >> 6));
    uint64_t v22 = *v20;
    uint64_t v21 = (-1 << result) - 1;
  }
  uint64_t *v20 = v22 & v21;
  uint64_t v23 = *(void *)(a2 + 16);
  BOOL v24 = __OFSUB__(v23, 1);
  uint64_t v25 = v23 - 1;
  if (v24)
  {
    __break(1u);
  }
  else
  {
    *(void *)(a2 + 16) = v25;
    ++*(_DWORD *)(a2 + 36);
  }
  return result;
}

id sub_10045E630(uint64_t a1, void *a2, char a3)
{
  uint64_t v4 = v3;
  uint64_t v7 = *v3;
  unint64_t v9 = sub_10045C740((uint64_t)a2);
  uint64_t v10 = *(void *)(v7 + 16);
  BOOL v11 = (v8 & 1) == 0;
  uint64_t v12 = v10 + v11;
  if (__OFADD__(v10, v11))
  {
    __break(1u);
    goto LABEL_16;
  }
  char v13 = v8;
  uint64_t v14 = *(void *)(v7 + 24);
  if (v14 >= v12 && (a3 & 1) != 0) {
    goto LABEL_7;
  }
  if (v14 >= v12 && (a3 & 1) == 0)
  {
    sub_10045EE70();
LABEL_7:
    uint64_t v15 = (void *)*v4;
    if (v13)
    {
LABEL_8:
      uint64_t v16 = v15[7];
      id result = (id)swift_bridgeObjectRelease();
      *(void *)(v16 + 8 * v9) = a1;
      return result;
    }
    goto LABEL_11;
  }
  sub_10045CE30(v12, a3 & 1);
  unint64_t v18 = sub_10045C740((uint64_t)a2);
  if ((v13 & 1) != (v19 & 1))
  {
LABEL_17:
    sub_100462C50(0, (unint64_t *)&unk_100A468F0);
    id result = (id)sub_100726D40();
    __break(1u);
    return result;
  }
  unint64_t v9 = v18;
  uint64_t v15 = (void *)*v4;
  if (v13) {
    goto LABEL_8;
  }
LABEL_11:
  v15[(v9 >> 6) + 8] |= 1 << v9;
  uint64_t v20 = 8 * v9;
  *(void *)(v15[6] + v20) = a2;
  *(void *)(v15[7] + v20) = a1;
  uint64_t v21 = v15[2];
  BOOL v22 = __OFADD__(v21, 1);
  uint64_t v23 = v21 + 1;
  if (v22)
  {
LABEL_16:
    __break(1u);
    goto LABEL_17;
  }
  _OWORD v15[2] = v23;

  return a2;
}

uint64_t sub_10045E7A4(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v4 = (void **)v3;
  uint64_t v8 = sub_100725D30();
  uint64_t v9 = *(void *)(v8 - 8);
  __chkstk_darwin(v8, v10);
  uint64_t v12 = (char *)&v26 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  char v13 = (void *)*v3;
  unint64_t v15 = sub_10045C63C(a2);
  uint64_t v16 = v13[2];
  BOOL v17 = (v14 & 1) == 0;
  uint64_t v18 = v16 + v17;
  if (__OFADD__(v16, v17))
  {
    __break(1u);
    goto LABEL_14;
  }
  char v19 = v14;
  uint64_t v20 = v13[3];
  if (v20 >= v18 && (a3 & 1) != 0)
  {
LABEL_7:
    uint64_t v21 = *v4;
    if (v19)
    {
LABEL_8:
      uint64_t v22 = v21[7];
      uint64_t result = swift_unknownObjectRelease();
      *(void *)(v22 + 8 * v15) = a1;
      return result;
    }
    goto LABEL_11;
  }
  if (v20 >= v18 && (a3 & 1) == 0)
  {
    sub_10045F1E0();
    goto LABEL_7;
  }
  sub_10045D3E0(v18, a3 & 1);
  unint64_t v24 = sub_10045C63C(a2);
  if ((v19 & 1) != (v25 & 1))
  {
LABEL_14:
    uint64_t result = sub_100726D40();
    __break(1u);
    return result;
  }
  unint64_t v15 = v24;
  uint64_t v21 = *v4;
  if (v19) {
    goto LABEL_8;
  }
LABEL_11:
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v12, a2, v8);
  return sub_10045ED10(v15, (uint64_t)v12, a1, v21);
}

uint64_t sub_10045E94C(uint64_t a1, Swift::UInt32 a2, char a3)
{
  uint64_t v4 = v3;
  uint64_t v8 = *v3;
  unint64_t v10 = sub_10045C6D4(a2);
  uint64_t v11 = *(void *)(v8 + 16);
  BOOL v12 = (v9 & 1) == 0;
  uint64_t result = v11 + v12;
  if (__OFADD__(v11, v12))
  {
    __break(1u);
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }
  char v14 = v9;
  uint64_t v15 = *(void *)(v8 + 24);
  if (v15 >= result && (a3 & 1) != 0) {
    goto LABEL_7;
  }
  if (v15 >= result && (a3 & 1) == 0)
  {
    uint64_t result = (uint64_t)sub_10045F478();
LABEL_7:
    uint64_t v16 = (void *)*v4;
    if (v14)
    {
LABEL_8:
      uint64_t v17 = v16[7];
      uint64_t result = swift_bridgeObjectRelease();
      *(void *)(v17 + 8 * v10) = a1;
      return result;
    }
LABEL_11:
    v16[(v10 >> 6) + 8] |= 1 << v10;
    *(_DWORD *)(v16[6] + 4 * v10) = a2;
    *(void *)(v16[7] + 8 * v10) = a1;
    uint64_t v19 = v16[2];
    BOOL v20 = __OFADD__(v19, 1);
    uint64_t v21 = v19 + 1;
    if (!v20)
    {
      v16[2] = v21;
      return result;
    }
    goto LABEL_14;
  }
  sub_10045D804(result, a3 & 1);
  uint64_t result = sub_10045C6D4(a2);
  if ((v14 & 1) == (v18 & 1))
  {
    unint64_t v10 = result;
    uint64_t v16 = (void *)*v4;
    if (v14) {
      goto LABEL_8;
    }
    goto LABEL_11;
  }
LABEL_15:
  type metadata accessor for IDSGroupSessionClientDataKey(0);
  uint64_t result = sub_100726D40();
  __break(1u);
  return result;
}

uint64_t sub_10045EA84(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v5 = v4;
  uint64_t v10 = *v4;
  unint64_t v12 = sub_10045C7FC(a3);
  uint64_t v13 = *(void *)(v10 + 16);
  BOOL v14 = (v11 & 1) == 0;
  uint64_t result = v13 + v14;
  if (__OFADD__(v13, v14))
  {
    __break(1u);
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }
  char v16 = v11;
  uint64_t v17 = *(void *)(v10 + 24);
  if (v17 >= result && (a4 & 1) != 0) {
    goto LABEL_7;
  }
  if (v17 >= result && (a4 & 1) == 0)
  {
    uint64_t result = (uint64_t)sub_10045F620();
LABEL_7:
    char v18 = (void *)*v5;
    if (v16)
    {
LABEL_8:
      uint64_t v19 = v18[7] + 16 * v12;
      uint64_t result = sub_100442248(*(void *)v19, *(void *)(v19 + 8));
      *(void *)uint64_t v19 = a1;
      *(void *)(v19 + _Block_object_dispose(&STACK[0x320], 8) = a2;
      return result;
    }
LABEL_11:
    v18[(v12 >> 6) + 8] |= 1 << v12;
    *(void *)(v18[6] + 8 * v12) = a3;
    uint64_t v21 = (void *)(v18[7] + 16 * v12);
    *uint64_t v21 = a1;
    v21[1] = a2;
    uint64_t v22 = v18[2];
    BOOL v23 = __OFADD__(v22, 1);
    uint64_t v24 = v22 + 1;
    if (!v23)
    {
      v18[2] = v24;
      return result;
    }
    goto LABEL_14;
  }
  sub_10045DAD8(result, a4 & 1);
  uint64_t result = sub_10045C7FC(a3);
  if ((v16 & 1) == (v20 & 1))
  {
    unint64_t v12 = result;
    char v18 = (void *)*v5;
    if (v16) {
      goto LABEL_8;
    }
    goto LABEL_11;
  }
LABEL_15:
  uint64_t result = sub_100726D40();
  __break(1u);
  return result;
}

uint64_t sub_10045EBC4(uint64_t a1, Swift::UInt32 a2, char a3)
{
  uint64_t v4 = (void **)v3;
  uint64_t v8 = (void *)*v3;
  unint64_t v10 = sub_10045C6D4(a2);
  uint64_t v11 = v8[2];
  BOOL v12 = (v9 & 1) == 0;
  uint64_t v13 = v11 + v12;
  if (__OFADD__(v11, v12))
  {
    __break(1u);
    goto LABEL_17;
  }
  char v14 = v9;
  uint64_t v15 = v8[3];
  if (v15 < v13 || (a3 & 1) == 0)
  {
    if (v15 >= v13 && (a3 & 1) == 0)
    {
      sub_10045F7D0();
      goto LABEL_7;
    }
    sub_10045DDA0(v13, a3 & 1);
    unint64_t v20 = sub_10045C6D4(a2);
    if ((v14 & 1) == (v21 & 1))
    {
      unint64_t v10 = v20;
      char v16 = *v4;
      if (v14) {
        goto LABEL_8;
      }
      goto LABEL_13;
    }
LABEL_17:
    type metadata accessor for IDSGroupSessionClientDataKey(0);
    uint64_t result = sub_100726D40();
    __break(1u);
    return result;
  }
LABEL_7:
  char v16 = *v4;
  if (v14)
  {
LABEL_8:
    uint64_t v17 = v16[7];
    uint64_t v18 = v17
        + *(void *)(*(void *)(type metadata accessor for IDSDSessionKeyValueDeliveryLocalEntry(0) - 8) + 72)
        * v10;
    return sub_100462B18(a1, v18);
  }
LABEL_13:

  return sub_10045EDC8(v10, a2, a1, v16);
}

uint64_t sub_10045ED10(unint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  a4[(a1 >> 6) + 8] |= 1 << a1;
  uint64_t v8 = a4[6];
  uint64_t v9 = sub_100725D30();
  uint64_t result = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(*(void *)(v9 - 8) + 32))(v8 + *(void *)(*(void *)(v9 - 8) + 72) * a1, a2, v9);
  *(void *)(a4[7] + 8 * a1) = a3;
  uint64_t v11 = a4[2];
  BOOL v12 = __OFADD__(v11, 1);
  uint64_t v13 = v11 + 1;
  if (v12) {
    __break(1u);
  }
  else {
    a4[2] = v13;
  }
  return result;
}

uint64_t sub_10045EDC8(unint64_t a1, int a2, uint64_t a3, void *a4)
{
  a4[(a1 >> 6) + 8] |= 1 << a1;
  *(_DWORD *)(a4[6] + 4 * a1) = a2;
  uint64_t v7 = a4[7];
  uint64_t v8 = type metadata accessor for IDSDSessionKeyValueDeliveryLocalEntry(0);
  uint64_t result = sub_10046129C(a3, v7 + *(void *)(*(void *)(v8 - 8) + 72) * a1, type metadata accessor for IDSDSessionKeyValueDeliveryLocalEntry);
  uint64_t v10 = a4[2];
  BOOL v11 = __OFADD__(v10, 1);
  uint64_t v12 = v10 + 1;
  if (v11) {
    __break(1u);
  }
  else {
    a4[2] = v12;
  }
  return result;
}

void *sub_10045EE70()
{
  uint64_t v1 = v0;
  sub_100431F80(&qword_100A45460);
  uint64_t v2 = *v0;
  uint64_t v3 = sub_100726BB0();
  uint64_t v4 = v3;
  if (!*(void *)(v2 + 16))
  {
LABEL_26:
    uint64_t result = (void *)swift_release();
    *uint64_t v1 = v4;
    return result;
  }
  uint64_t result = (void *)(v3 + 64);
  uint64_t v6 = v2 + 64;
  unint64_t v7 = (unint64_t)((1 << *(unsigned char *)(v4 + 32)) + 63) >> 6;
  if (v4 != v2 || (unint64_t)result >= v2 + 64 + 8 * v7) {
    uint64_t result = memmove(result, (const void *)(v2 + 64), 8 * v7);
  }
  int64_t v9 = 0;
  *(void *)(v4 + 16) = *(void *)(v2 + 16);
  uint64_t v10 = 1 << *(unsigned char *)(v2 + 32);
  uint64_t v11 = -1;
  if (v10 < 64) {
    uint64_t v11 = ~(-1 << v10);
  }
  unint64_t v12 = v11 & *(void *)(v2 + 64);
  int64_t v13 = (unint64_t)(v10 + 63) >> 6;
  while (1)
  {
    if (v12)
    {
      unint64_t v14 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      unint64_t v15 = v14 | (v9 << 6);
      goto LABEL_12;
    }
    int64_t v20 = v9 + 1;
    if (__OFADD__(v9, 1))
    {
      __break(1u);
      goto LABEL_28;
    }
    if (v20 >= v13) {
      goto LABEL_26;
    }
    unint64_t v21 = *(void *)(v6 + 8 * v20);
    ++v9;
    if (!v21)
    {
      int64_t v9 = v20 + 1;
      if (v20 + 1 >= v13) {
        goto LABEL_26;
      }
      unint64_t v21 = *(void *)(v6 + 8 * v9);
      if (!v21) {
        break;
      }
    }
LABEL_25:
    unint64_t v12 = (v21 - 1) & v21;
    unint64_t v15 = __clz(__rbit64(v21)) + (v9 << 6);
LABEL_12:
    uint64_t v16 = 8 * v15;
    uint64_t v17 = *(void **)(*(void *)(v2 + 48) + v16);
    uint64_t v18 = *(void *)(*(void *)(v2 + 56) + v16);
    *(void *)(*(void *)(v4 + 48) + v16) = v17;
    *(void *)(*(void *)(v4 + 56) + v16) = v18;
    id v19 = v17;
    uint64_t result = (void *)swift_bridgeObjectRetain();
  }
  int64_t v22 = v20 + 2;
  if (v22 >= v13) {
    goto LABEL_26;
  }
  unint64_t v21 = *(void *)(v6 + 8 * v22);
  if (v21)
  {
    int64_t v9 = v22;
    goto LABEL_25;
  }
  while (1)
  {
    int64_t v9 = v22 + 1;
    if (__OFADD__(v22, 1)) {
      break;
    }
    if (v9 >= v13) {
      goto LABEL_26;
    }
    unint64_t v21 = *(void *)(v6 + 8 * v9);
    ++v22;
    if (v21) {
      goto LABEL_25;
    }
  }
LABEL_28:
  __break(1u);
  return result;
}

void *sub_10045F01C()
{
  uint64_t v1 = v0;
  sub_100431F80(&qword_100A45468);
  uint64_t v2 = *v0;
  uint64_t v3 = sub_100726BB0();
  uint64_t v4 = v3;
  if (!*(void *)(v2 + 16))
  {
LABEL_26:
    uint64_t result = (void *)swift_release();
    *uint64_t v1 = v4;
    return result;
  }
  uint64_t result = (void *)(v3 + 64);
  uint64_t v6 = v2 + 64;
  unint64_t v7 = (unint64_t)((1 << *(unsigned char *)(v4 + 32)) + 63) >> 6;
  if (v4 != v2 || (unint64_t)result >= v2 + 64 + 8 * v7) {
    uint64_t result = memmove(result, (const void *)(v2 + 64), 8 * v7);
  }
  int64_t v9 = 0;
  *(void *)(v4 + 16) = *(void *)(v2 + 16);
  uint64_t v10 = 1 << *(unsigned char *)(v2 + 32);
  uint64_t v11 = -1;
  if (v10 < 64) {
    uint64_t v11 = ~(-1 << v10);
  }
  unint64_t v12 = v11 & *(void *)(v2 + 64);
  int64_t v13 = (unint64_t)(v10 + 63) >> 6;
  while (1)
  {
    if (v12)
    {
      unint64_t v14 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      unint64_t v15 = v14 | (v9 << 6);
      goto LABEL_12;
    }
    int64_t v20 = v9 + 1;
    if (__OFADD__(v9, 1))
    {
      __break(1u);
      goto LABEL_28;
    }
    if (v20 >= v13) {
      goto LABEL_26;
    }
    unint64_t v21 = *(void *)(v6 + 8 * v20);
    ++v9;
    if (!v21)
    {
      int64_t v9 = v20 + 1;
      if (v20 + 1 >= v13) {
        goto LABEL_26;
      }
      unint64_t v21 = *(void *)(v6 + 8 * v9);
      if (!v21) {
        break;
      }
    }
LABEL_25:
    unint64_t v12 = (v21 - 1) & v21;
    unint64_t v15 = __clz(__rbit64(v21)) + (v9 << 6);
LABEL_12:
    uint64_t v16 = 8 * v15;
    uint64_t v17 = *(void **)(*(void *)(v2 + 48) + 8 * v15);
    uint64_t v18 = 16 * v15;
    long long v23 = *(_OWORD *)(*(void *)(v2 + 56) + v18);
    *(void *)(*(void *)(v4 + 48) + v16) = v17;
    *(_OWORD *)(*(void *)(v4 + 56) + v1_Block_object_dispose(&STACK[0x320], 8) = v23;
    id v19 = v17;
    uint64_t result = (void *)sub_100441FD4(v23, *((unint64_t *)&v23 + 1));
  }
  int64_t v22 = v20 + 2;
  if (v22 >= v13) {
    goto LABEL_26;
  }
  unint64_t v21 = *(void *)(v6 + 8 * v22);
  if (v21)
  {
    int64_t v9 = v22;
    goto LABEL_25;
  }
  while (1)
  {
    int64_t v9 = v22 + 1;
    if (__OFADD__(v22, 1)) {
      break;
    }
    if (v9 >= v13) {
      goto LABEL_26;
    }
    unint64_t v21 = *(void *)(v6 + 8 * v9);
    ++v22;
    if (v21) {
      goto LABEL_25;
    }
  }
LABEL_28:
  __break(1u);
  return result;
}

void *sub_10045F1E0()
{
  uint64_t v1 = sub_100725D30();
  uint64_t v2 = *(void *)(v1 - 8);
  __chkstk_darwin(v1, v3);
  uint64_t v5 = (char *)&v23 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_100431F80(&qword_100A45450);
  uint64_t v24 = v0;
  uint64_t v6 = *v0;
  uint64_t v7 = sub_100726BB0();
  uint64_t v8 = v7;
  if (!*(void *)(v6 + 16))
  {
LABEL_23:
    uint64_t result = (void *)swift_release();
    *uint64_t v24 = v8;
    return result;
  }
  uint64_t result = (void *)(v7 + 64);
  unint64_t v10 = (unint64_t)((1 << *(unsigned char *)(v8 + 32)) + 63) >> 6;
  if (v8 != v6 || (unint64_t)result >= v6 + 64 + 8 * v10) {
    uint64_t result = memmove(result, (const void *)(v6 + 64), 8 * v10);
  }
  int64_t v11 = 0;
  *(void *)(v8 + 16) = *(void *)(v6 + 16);
  uint64_t v12 = 1 << *(unsigned char *)(v6 + 32);
  uint64_t v13 = -1;
  if (v12 < 64) {
    uint64_t v13 = ~(-1 << v12);
  }
  unint64_t v14 = v13 & *(void *)(v6 + 64);
  uint64_t v25 = v6 + 64;
  int64_t v26 = (unint64_t)(v12 + 63) >> 6;
  uint64_t v27 = v2 + 32;
  uint64_t v28 = v2 + 16;
  while (1)
  {
    if (v14)
    {
      unint64_t v15 = __clz(__rbit64(v14));
      v14 &= v14 - 1;
      unint64_t v16 = v15 | (v11 << 6);
      goto LABEL_9;
    }
    int64_t v20 = v11 + 1;
    if (__OFADD__(v11, 1))
    {
      __break(1u);
      goto LABEL_25;
    }
    if (v20 >= v26) {
      goto LABEL_23;
    }
    unint64_t v21 = *(void *)(v25 + 8 * v20);
    ++v11;
    if (!v21)
    {
      int64_t v11 = v20 + 1;
      if (v20 + 1 >= v26) {
        goto LABEL_23;
      }
      unint64_t v21 = *(void *)(v25 + 8 * v11);
      if (!v21) {
        break;
      }
    }
LABEL_22:
    unint64_t v14 = (v21 - 1) & v21;
    unint64_t v16 = __clz(__rbit64(v21)) + (v11 << 6);
LABEL_9:
    unint64_t v17 = *(void *)(v2 + 72) * v16;
    (*(void (**)(char *, unint64_t, uint64_t))(v2 + 16))(v5, *(void *)(v6 + 48) + v17, v1);
    uint64_t v18 = 8 * v16;
    uint64_t v19 = *(void *)(*(void *)(v6 + 56) + 8 * v16);
    (*(void (**)(unint64_t, char *, uint64_t))(v2 + 32))(*(void *)(v8 + 48) + v17, v5, v1);
    *(void *)(*(void *)(v8 + 56) + v1_Block_object_dispose(&STACK[0x320], 8) = v19;
    uint64_t result = (void *)swift_unknownObjectRetain();
  }
  int64_t v22 = v20 + 2;
  if (v22 >= v26) {
    goto LABEL_23;
  }
  unint64_t v21 = *(void *)(v25 + 8 * v22);
  if (v21)
  {
    int64_t v11 = v22;
    goto LABEL_22;
  }
  while (1)
  {
    int64_t v11 = v22 + 1;
    if (__OFADD__(v22, 1)) {
      break;
    }
    if (v11 >= v26) {
      goto LABEL_23;
    }
    unint64_t v21 = *(void *)(v25 + 8 * v11);
    ++v22;
    if (v21) {
      goto LABEL_22;
    }
  }
LABEL_25:
  __break(1u);
  return result;
}

void *sub_10045F478()
{
  uint64_t v1 = v0;
  sub_100431F80(&qword_100A453D8);
  uint64_t v2 = *v0;
  uint64_t v3 = sub_100726BB0();
  uint64_t v4 = v3;
  if (!*(void *)(v2 + 16))
  {
LABEL_26:
    uint64_t result = (void *)swift_release();
    *uint64_t v1 = v4;
    return result;
  }
  uint64_t result = (void *)(v3 + 64);
  uint64_t v6 = v2 + 64;
  unint64_t v7 = (unint64_t)((1 << *(unsigned char *)(v4 + 32)) + 63) >> 6;
  if (v4 != v2 || (unint64_t)result >= v2 + 64 + 8 * v7) {
    uint64_t result = memmove(result, (const void *)(v2 + 64), 8 * v7);
  }
  int64_t v9 = 0;
  *(void *)(v4 + 16) = *(void *)(v2 + 16);
  uint64_t v10 = 1 << *(unsigned char *)(v2 + 32);
  uint64_t v11 = -1;
  if (v10 < 64) {
    uint64_t v11 = ~(-1 << v10);
  }
  unint64_t v12 = v11 & *(void *)(v2 + 64);
  int64_t v13 = (unint64_t)(v10 + 63) >> 6;
  while (1)
  {
    if (v12)
    {
      unint64_t v14 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      unint64_t v15 = v14 | (v9 << 6);
      goto LABEL_12;
    }
    int64_t v20 = v9 + 1;
    if (__OFADD__(v9, 1))
    {
      __break(1u);
      goto LABEL_28;
    }
    if (v20 >= v13) {
      goto LABEL_26;
    }
    unint64_t v21 = *(void *)(v6 + 8 * v20);
    ++v9;
    if (!v21)
    {
      int64_t v9 = v20 + 1;
      if (v20 + 1 >= v13) {
        goto LABEL_26;
      }
      unint64_t v21 = *(void *)(v6 + 8 * v9);
      if (!v21) {
        break;
      }
    }
LABEL_25:
    unint64_t v12 = (v21 - 1) & v21;
    unint64_t v15 = __clz(__rbit64(v21)) + (v9 << 6);
LABEL_12:
    uint64_t v16 = 4 * v15;
    int v17 = *(_DWORD *)(*(void *)(v2 + 48) + 4 * v15);
    uint64_t v18 = 8 * v15;
    uint64_t v19 = *(void *)(*(void *)(v2 + 56) + v18);
    *(_DWORD *)(*(void *)(v4 + 48) + v16) = v17;
    *(void *)(*(void *)(v4 + 56) + v1_Block_object_dispose(&STACK[0x320], 8) = v19;
    uint64_t result = (void *)swift_bridgeObjectRetain();
  }
  int64_t v22 = v20 + 2;
  if (v22 >= v13) {
    goto LABEL_26;
  }
  unint64_t v21 = *(void *)(v6 + 8 * v22);
  if (v21)
  {
    int64_t v9 = v22;
    goto LABEL_25;
  }
  while (1)
  {
    int64_t v9 = v22 + 1;
    if (__OFADD__(v22, 1)) {
      break;
    }
    if (v9 >= v13) {
      goto LABEL_26;
    }
    unint64_t v21 = *(void *)(v6 + 8 * v9);
    ++v22;
    if (v21) {
      goto LABEL_25;
    }
  }
LABEL_28:
  __break(1u);
  return result;
}

void *sub_10045F620()
{
  uint64_t v1 = v0;
  sub_100431F80(&qword_100A453C8);
  uint64_t v2 = *v0;
  uint64_t v3 = sub_100726BB0();
  uint64_t v4 = v3;
  if (!*(void *)(v2 + 16))
  {
LABEL_26:
    uint64_t result = (void *)swift_release();
    *uint64_t v1 = v4;
    return result;
  }
  uint64_t result = (void *)(v3 + 64);
  uint64_t v6 = v2 + 64;
  unint64_t v7 = (unint64_t)((1 << *(unsigned char *)(v4 + 32)) + 63) >> 6;
  if (v4 != v2 || (unint64_t)result >= v2 + 64 + 8 * v7) {
    uint64_t result = memmove(result, (const void *)(v2 + 64), 8 * v7);
  }
  int64_t v9 = 0;
  *(void *)(v4 + 16) = *(void *)(v2 + 16);
  uint64_t v10 = 1 << *(unsigned char *)(v2 + 32);
  uint64_t v11 = -1;
  if (v10 < 64) {
    uint64_t v11 = ~(-1 << v10);
  }
  unint64_t v12 = v11 & *(void *)(v2 + 64);
  int64_t v13 = (unint64_t)(v10 + 63) >> 6;
  while (1)
  {
    if (v12)
    {
      unint64_t v14 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      unint64_t v15 = v14 | (v9 << 6);
      goto LABEL_12;
    }
    int64_t v20 = v9 + 1;
    if (__OFADD__(v9, 1))
    {
      __break(1u);
      goto LABEL_28;
    }
    if (v20 >= v13) {
      goto LABEL_26;
    }
    unint64_t v21 = *(void *)(v6 + 8 * v20);
    ++v9;
    if (!v21)
    {
      int64_t v9 = v20 + 1;
      if (v20 + 1 >= v13) {
        goto LABEL_26;
      }
      unint64_t v21 = *(void *)(v6 + 8 * v9);
      if (!v21) {
        break;
      }
    }
LABEL_25:
    unint64_t v12 = (v21 - 1) & v21;
    unint64_t v15 = __clz(__rbit64(v21)) + (v9 << 6);
LABEL_12:
    uint64_t v16 = 8 * v15;
    uint64_t v17 = *(void *)(*(void *)(v2 + 48) + 8 * v15);
    uint64_t v18 = 16 * v15;
    long long v19 = *(_OWORD *)(*(void *)(v2 + 56) + v18);
    *(void *)(*(void *)(v4 + 48) + v16) = v17;
    *(_OWORD *)(*(void *)(v4 + 56) + v1_Block_object_dispose(&STACK[0x320], 8) = v19;
    uint64_t result = (void *)sub_100441FD4(v19, *((unint64_t *)&v19 + 1));
  }
  int64_t v22 = v20 + 2;
  if (v22 >= v13) {
    goto LABEL_26;
  }
  unint64_t v21 = *(void *)(v6 + 8 * v22);
  if (v21)
  {
    int64_t v9 = v22;
    goto LABEL_25;
  }
  while (1)
  {
    int64_t v9 = v22 + 1;
    if (__OFADD__(v22, 1)) {
      break;
    }
    if (v9 >= v13) {
      goto LABEL_26;
    }
    unint64_t v21 = *(void *)(v6 + 8 * v9);
    ++v22;
    if (v21) {
      goto LABEL_25;
    }
  }
LABEL_28:
  __break(1u);
  return result;
}