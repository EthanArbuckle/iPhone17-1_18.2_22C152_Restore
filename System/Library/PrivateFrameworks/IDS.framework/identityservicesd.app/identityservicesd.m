void sub_100004560(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  void *v4;
  uint64_t vars8;

  v2 = *(NSObject **)(*(void *)(a1 + 32) + 32);
  if (v2)
  {
    dispatch_source_cancel(v2);
    v3 = *(void *)(a1 + 32);
    v4 = *(void **)(v3 + 32);
    *(void *)(v3 + 32) = 0;
  }

  sub_100006030();
}

uint64_t sub_1000045B0(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = [*(id *)(a1 + 32) _criticalAllPairedDevices];

  return _objc_release_x1();
}

void sub_1000045FC(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000046A0(uint64_t a1)
{
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v8 objects:v12 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v9;
LABEL_3:
    uint64_t v6 = 0;
    while (1)
    {
      if (*(void *)v9 != v5) {
        objc_enumerationMutation(v2);
      }
      v7 = objc_msgSend(*(id *)(*((void *)&v8 + 1) + 8 * v6), "cloudConnection", (void)v8);
      *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = [v7 isIdle];

      if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
        break;
      }
      if (v4 == (id)++v6)
      {
        id v4 = [v2 countByEnumeratingWithState:&v8 objects:v12 count:16];
        if (v4) {
          goto LABEL_3;
        }
        break;
      }
    }
  }
}

void sub_1000047C4(uint64_t a1)
{
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v8 objects:v12 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v9;
LABEL_3:
    uint64_t v6 = 0;
    while (1)
    {
      if (*(void *)v9 != v5) {
        objc_enumerationMutation(v2);
      }
      v7 = objc_msgSend(*(id *)(*((void *)&v8 + 1) + 8 * v6), "cloudConnection", (void)v8);
      *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = [v7 isIdle];

      if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
        break;
      }
      if (v4 == (id)++v6)
      {
        id v4 = [v2 countByEnumeratingWithState:&v8 objects:v12 count:16];
        if (v4) {
          goto LABEL_3;
        }
        break;
      }
    }
  }
}

void sub_1000048E8(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  os_unfair_lock_lock((os_unfair_lock_t)&unk_100A4AA20);
  sub_100005EF0(v3);

  uint64_t v5 = sub_10000627C();
  CSDBPerformLocked();

  os_unfair_lock_unlock((os_unfair_lock_t)&unk_100A4AA20);
}

void sub_100004A98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100004AB0(uint64_t a1)
{
  WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 40));
  id v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    uint64_t v8 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Updating interested bundle IDs to: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v6 = *(void *)(a1 + 32);
    _IDSLogV();
  }
  objc_msgSend(WeakRetained[48], "updateInterestedBundleIDs:", *(void *)(a1 + 32), v6);
}

void sub_100004BF0(uint64_t a1)
{
  id v2 = im_local_object_from_connection();
  if (+[IDSUserManagement isThreadDataSeparated]
    && _os_feature_enabled_impl())
  {
    id v3 = +[IMRGLog registration];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      uint64_t v4 = *(void *)(a1 + 32);
      uint64_t v5 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138412802;
      v16 = v2;
      __int16 v17 = 2112;
      uint64_t v18 = v4;
      __int16 v19 = 2112;
      uint64_t v20 = v5;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Data separated request came in to %@ from peer: %@ -- rejecting %@", buf, 0x20u);
    }
LABEL_13:

    goto LABEL_14;
  }
  if (v2)
  {
    uint64_t v6 = [v2 protocolChecker];
    id v3 = [v6 protocol];

    int int64 = xpc_dictionary_get_int64(*(xpc_object_t *)(a1 + 40), "priority");
    if (int64)
    {
      uint64_t v8 = +[IDSDaemonPriorityQueueController sharedInstance];
      v10[0] = _NSConcreteStackBlock;
      v10[1] = 3221225472;
      v10[2] = sub_100134EC0;
      v10[3] = &unk_1009815E8;
      id v11 = *(id *)(a1 + 40);
      id v12 = v2;
      id v3 = v3;
      v13 = v3;
      int v14 = int64;
      [v8 performBlockWithPriority:v10 priority:int64];
    }
    else
    {
      long long v9 = (void *)IMCreateInvocationFromXPCObjectWithProtocol();
      if (v9)
      {
        if (_os_feature_enabled_impl()) {
          [v2 _enqueueInvocationWithSync:v9 xpcMessage:*(void *)(a1 + 40)];
        }
        else {
          [v2 _enqueueInvocation:v9];
        }
      }
      CFRelease(v2);
    }
    goto LABEL_13;
  }
LABEL_14:
}

void sub_100004E4C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v5 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138412290;
    id v17 = v3;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Application state changed: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    id v13 = v3;
    _IDSLogV();
  }
  uint64_t v6 = objc_msgSend(v3, "objectForKey:", BKSApplicationStateProcessIDKey, v13);
  v7 = [v3 objectForKey:BKSApplicationStateKey];
  uint64_t v8 = v7;
  if (v6) {
    BOOL v9 = v7 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (!v9 && [v7 intValue] == 2)
  {
    long long v10 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v11 = [v6 intValue];
      *(_DWORD *)buf = 67109120;
      LODWORD(v17) = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, " => Pid %d suspended!", buf, 8u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      [v6 intValue];
      _IDSLogV();
    }
    id v12 = im_primary_queue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1001254CC;
    block[3] = &unk_10097E440;
    block[4] = WeakRetained;
    id v15 = v6;
    dispatch_async(v12, block);
  }
}

void sub_1000058E8(uint64_t a1)
{
  id v2 = +[IDSDaemonMIGInterface sharedInstance];
  id v3 = [v2 delegate];

  uint64_t v4 = IMGetXPCStringFromDictionary();
  uint64_t v5 = IMGetXPCDictionaryFromDictionary();
  uint64_t pid = xpc_connection_get_pid(*(xpc_connection_t *)(a1 + 40));
  if (+[IDSUserManagement isThreadDataSeparated]
    || !_os_feature_enabled_impl())
  {
    id v12 = +[IMRGLog registration];
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      uint64_t v17 = *(void *)(a1 + 40);
      *(_DWORD *)uint64_t v20 = 138412802;
      *(void *)&v20[4] = v4;
      *(_WORD *)&v20[12] = 1024;
      *(_DWORD *)&v20[14] = pid;
      *(_WORD *)&v20[18] = 2112;
      *(void *)&v20[20] = v17;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Data separated port name request for: %@ from pid: %d -- rejecting %@", v20, 0x1Cu);
    }

    LOBYTE(v10) = 0;
    id v11 = 0;
  }
  else
  {
    *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)uint64_t v20 = v7;
    *(_OWORD *)&v20[16] = v7;
    xpc_connection_get_audit_token();
    if (v3 && *(void *)(a1 + 40))
    {
      uint64_t v8 = +[IDSDaemonMIGInterface sharedInstance];
      uint64_t v9 = *(void *)(a1 + 40);
      *(_OWORD *)buf = *(_OWORD *)v20;
      *(_OWORD *)&buf[16] = *(_OWORD *)&v20[16];
      id v18 = 0;
      unsigned int v10 = [v3 daemonInterface:v8 shouldGrantAccessForPID:pid auditToken:buf portName:v4 listenerConnection:v9 setupInfo:v5 setupResponse:&v18];
      id v11 = v18;
    }
    else
    {
      id v11 = 0;
      unsigned int v10 = 1;
    }
    id v13 = +[IMRGLog registration];
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v14 = @"NO";
      *(_DWORD *)buf = 138412802;
      *(void *)&uint8_t buf[4] = v4;
      if (v10) {
        CFStringRef v14 = @"YES";
      }
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = pid;
      *(_WORD *)&buf[18] = 2112;
      *(void *)&buf[20] = v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Port name request for: %@ from pid: %d granted: %@", buf, 0x1Cu);
    }
  }
  xpc_object_t reply = xpc_dictionary_create_reply(*(xpc_object_t *)(a1 + 32));
  v16 = reply;
  if (reply)
  {
    if (v11) {
      xpc_dictionary_set_value(reply, "response", v11);
    }
    xpc_dictionary_set_BOOL(v16, "granted", v10);
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 40), v16);
  }
}

void sub_100005EF0(void *a1)
{
  id v1 = a1;
  os_unfair_lock_assert_owner((const os_unfair_lock *)&unk_100A4AA20);
  id v2 = sub_10000627C();

  if (v2)
  {
    id v3 = v1;
    uint64_t v5 = sub_10000627C();
    id v6 = v3;
    CSDBThreadedRecordStoreEnsureDatabaseSetupWithProtection();
  }
}

void sub_100006030()
{
  os_unfair_lock_assert_owner((const os_unfair_lock *)&unk_100A4AA20);
  v0 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "Saving database.", buf, 2u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  id v1 = sub_10000627C();
  CSDBPerformLockedSectionForRecordStore();

  id v2 = sub_10000627C();

  if (v2)
  {
    id v3 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v7 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Destroying database.", v7, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    uint64_t v4 = sub_10000627C();
    CSDBThreadedRecordStoreTeardownDatabase();

    uint64_t v5 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Closed database.", v6, 2u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
  }
}

id sub_10000627C()
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1001C0E68;
  block[3] = &unk_10097EA18;
  block[4] = @"IDSFirewallStore";
  if (qword_100A4AA18 != -1) {
    dispatch_once(&qword_100A4AA18, block);
  }
  v0 = (void *)qword_100A4AA10;

  return v0;
}

void sub_100006478(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000064E8(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = [*(id *)(a1 + 32) _criticalActivePairedDevice];

  return _objc_release_x1();
}

void sub_100006668(id a1, OS_xpc_object *a2, OS_xpc_object *a3)
{
  uint64_t v4 = a2;
  uint64_t v5 = a3;
  if (_IMWillLog()) {
    _IMAlwaysLog();
  }
  id v6 = v4;
  long long v7 = v5;
  xpc_type_t type = xpc_get_type(v7);
  if (type != (xpc_type_t)&_xpc_type_error)
  {
    if (type != (xpc_type_t)&_xpc_type_dictionary)
    {
      uint64_t v9 = xpc_copy_description(v7);
      if (_IMWillLog())
      {
        xpc_connection_get_pid(v6);
        _IMAlwaysLog();
      }
      free(v9);
      goto LABEL_50;
    }
    id v11 = v7;
    if (xpc_dictionary_get_BOOL(v11, "setup-request"))
    {
      if (_IMWillLog()) {
        _IMAlwaysLog();
      }
      if (_IMWillLog())
      {
        id v12 = xpc_copy_description(v11);
        if (_IMWillLog())
        {
          xpc_connection_get_pid(v6);
          _IMAlwaysLog();
        }
        free(v12);
      }
      *(void *)buf = _NSConcreteStackBlock;
      uint64_t v20 = 3221225472;
      v21 = sub_1000058E8;
      v22 = &unk_10097E440;
      v23 = v11;
      v24 = v6;
      id v13 = (void (**)(void))dispatch_block_create((dispatch_block_flags_t)0, buf);
      if (_os_feature_enabled_impl()) {
        goto LABEL_47;
      }
    }
    else if (xpc_dictionary_get_BOOL(v11, "xpc-object"))
    {
      uint64_t v17 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "Incoming file descriptor request", buf, 2u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        _IDSLogV();
      }
      *(void *)buf = _NSConcreteStackBlock;
      uint64_t v20 = 3221225472;
      v21 = sub_100134D54;
      v22 = &unk_10097E440;
      v23 = v6;
      v24 = v11;
      id v13 = (void (**)(void))dispatch_block_create((dispatch_block_flags_t)0, buf);
      if (_os_feature_enabled_impl()) {
        goto LABEL_47;
      }
    }
    else
    {
      *(void *)buf = _NSConcreteStackBlock;
      uint64_t v20 = 3221225472;
      v21 = sub_100004BF0;
      v22 = &unk_10097E440;
      v23 = v6;
      v24 = v11;
      id v13 = (void (**)(void))dispatch_block_create((dispatch_block_flags_t)0, buf);
      if (_os_feature_enabled_impl())
      {
LABEL_47:
        v13[2](v13);
LABEL_49:

        goto LABEL_50;
      }
    }
    sub_100006D8C(v13);
    goto LABEL_49;
  }
  if (v7 == (OS_xpc_object *)&_xpc_error_connection_invalid)
  {
    CFStringRef v14 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = xpc_connection_get_pid(v6);
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "peer(%d) received XPC_ERROR_CONNECTION_INVALID", buf, 8u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      xpc_connection_get_pid(v6);
      _IDSLogV();
    }
    id v15 = im_local_object_from_connection();
    v16 = v15;
    if (v15)
    {
      [v15 _portDidBecomeInvalid];
      CFRelease(v16);
    }
    xpc_connection_cancel(v6);
  }
  else if (v7 == (OS_xpc_object *)&_xpc_error_connection_interrupted)
  {
    id v18 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = xpc_connection_get_pid(v6);
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "peer(%d) received XPC_ERROR_CONNECTION_INTERRUPTED", buf, 8u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      goto LABEL_15;
    }
  }
  else if (v7 == (OS_xpc_object *)&_xpc_error_termination_imminent)
  {
    unsigned int v10 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = xpc_connection_get_pid(v6);
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "peer(%d) received XPC_ERROR_TERMINATION_IMMINENT", buf, 8u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLog())
      {
LABEL_15:
        xpc_connection_get_pid(v6);
        _IDSLogV();
      }
    }
  }
LABEL_50:
}

void sub_100006D2C(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1000067E0);
  }
  _Unwind_Resume(a1);
}

void sub_100006D8C(void *a1)
{
  id v1 = a1;
  v6[0] = 0xAAAAAAAAAAAAAAAALL;
  v6[1] = 0xAAAAAAAAAAAAAAAALL;
  pthread_main_thread_np();
  pthread_dependency_init_np();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_10000BBC4;
  v3[3] = &unk_100981570;
  id v4 = v1;
  uint64_t v5 = v6;
  id v2 = v1;
  dispatch_async((dispatch_queue_t)&_dispatch_main_q, v3);
  pthread_dependency_wait_np();
}

void sub_100006FEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000076FC(uint64_t a1, void *a2)
{
  id v62 = a2;
  id v63 = objc_alloc_init((Class)NSMutableSet);
  v66 = [v62 entitlements];
  if ([v66 hasAnyEntitlements])
  {
    long long v82 = 0u;
    long long v83 = 0u;
    long long v80 = 0u;
    long long v81 = 0u;
    id obj = *(id *)(a1 + 32);
    id v2 = [obj countByEnumeratingWithState:&v80 objects:v93 count:16];
    if (v2)
    {
      uint64_t v3 = *(void *)v81;
      uint64_t v4 = kIDSRegistrationEntitlement;
      uint64_t v5 = kIDSSessionEntitlement;
      uint64_t v6 = kIDSMessagingEntitlement;
      do
      {
        for (i = 0; i != v2; i = (char *)i + 1)
        {
          if (*(void *)v81 != v3) {
            objc_enumerationMutation(obj);
          }
          uint64_t v8 = *(void *)(*((void *)&v80 + 1) + 8 * i);
          v92[0] = v4;
          v92[1] = v5;
          v92[2] = v6;
          uint64_t v9 = +[NSArray arrayWithObjects:v92 count:3];
          unsigned int v10 = [v66 hasService:v8 forAnyOfEntitlements:v9];

          if (v10) {
            [v63 addObject:v8];
          }
        }
        id v2 = [obj countByEnumeratingWithState:&v80 objects:v93 count:16];
      }
      while (v2);
    }
  }
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40), v63);
  id v11 = [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) copy];
  uint64_t v12 = *(void *)(*(void *)(a1 + 64) + 8);
  id v13 = *(void **)(v12 + 40);
  *(void *)(v12 + 40) = v11;

  CFStringRef v14 = [v62 notificationServices];
  id v15 = [v14 copy];
  uint64_t v16 = *(void *)(*(void *)(a1 + 72) + 8);
  uint64_t v17 = *(void **)(v16 + 40);
  *(void *)(v16 + 40) = v15;

  id v18 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
  {
    CFStringRef v19 = *(const __CFString **)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
    uint64_t v20 = *(void **)(a1 + 40);
    int v21 = *(_DWORD *)(a1 + 80);
    *(_DWORD *)buf = 138412802;
    CFStringRef v87 = v19;
    __int16 v88 = 2112;
    id v89 = v20;
    __int16 v90 = 1024;
    LODWORD(v91) = v21;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "Allowing listener services %@ commands %@ caps %d", buf, 0x1Cu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    id v60 = *(id *)(a1 + 40);
    id v61 = (id)*(unsigned int *)(a1 + 80);
    CFStringRef v59 = *(const __CFString **)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
    _IDSLogV();
  }
  v22 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
  {
    v23 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
    *(_DWORD *)buf = 138412802;
    CFStringRef v87 = @"services";
    __int16 v88 = 2112;
    id v89 = v23;
    __int16 v90 = 2112;
    id v91 = v62;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEBUG, "Got %@ %@ for listener %@", buf, 0x20u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    id v60 = *(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
    id v61 = v62;
    CFStringRef v59 = @"services";
    _IDSLogV();
  }
  if (!*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40))
  {
    uint64_t v24 = +[NSSet set];
    uint64_t v25 = *(void *)(*(void *)(a1 + 56) + 8);
    v26 = *(void **)(v25 + 40);
    *(void *)(v25 + 40) = v24;
  }
  if (v62)
  {
    v27 = [v62 services];
    if (([v27 isEqualToSet:*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40)] & 1) == 0)
    {
      [v62 setServices:*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40)];
      if ([v27 isSubsetOfSet:*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40)])
      {
        uint64_t v28 = a1;
        v29 = *(void **)(*(void *)(a1 + 48) + 112);
        if (!v29)
        {
          id v30 = objc_alloc_init((Class)NSMutableSet);
          uint64_t v31 = *(void *)(a1 + 48);
          v32 = *(void **)(v31 + 112);
          *(void *)(v31 + 112) = v30;

          v29 = *(void **)(*(void *)(a1 + 48) + 112);
          uint64_t v28 = a1;
        }
        objc_msgSend(v29, "unionSet:", *(void *)(*(void *)(*(void *)(v28 + 56) + 8) + 40), v59, v60, v61);
      }
      else
      {
        id v33 = objc_alloc_init((Class)NSMutableSet);
        uint64_t v34 = *(void *)(a1 + 48);
        v35 = *(void **)(v34 + 112);
        *(void *)(v34 + 112) = v33;

        long long v78 = 0u;
        long long v79 = 0u;
        long long v76 = 0u;
        long long v77 = 0u;
        id v36 = *(id *)(*(void *)(a1 + 48) + 72);
        id v37 = [v36 countByEnumeratingWithState:&v76 objects:v85 count:16];
        if (v37)
        {
          uint64_t v38 = *(void *)v77;
          do
          {
            for (j = 0; j != v37; j = (char *)j + 1)
            {
              if (*(void *)v77 != v38) {
                objc_enumerationMutation(v36);
              }
              v40 = *(void **)(*(void *)(a1 + 48) + 112);
              v41 = objc_msgSend(*(id *)(*((void *)&v76 + 1) + 8 * (void)j), "services", v59, v60, v61);
              [v40 unionSet:v41];
            }
            id v37 = [v36 countByEnumeratingWithState:&v76 objects:v85 count:16];
          }
          while (v37);
        }
      }
      v71 = _NSConcreteStackBlock;
      uint64_t v72 = 3221225472;
      v73 = sub_100130340;
      v74 = &unk_10097E4D0;
      id v75 = *(id *)(a1 + 48);
      objc_msgSend(v75, "updateTopics", v59, v60, v61);
    }
  }
  id v42 = *(id *)(a1 + 40);
  v43 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138412802;
    CFStringRef v87 = @"commands";
    __int16 v88 = 2112;
    id v89 = v42;
    __int16 v90 = 2112;
    id v91 = v62;
    _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEBUG, "Got %@ %@ for listener %@", buf, 0x20u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    id v60 = v42;
    id v61 = v62;
    CFStringRef v59 = @"commands";
    _IDSLogV();
  }
  v44 = v62;
  if (v42)
  {
    if (!v62) {
      goto LABEL_64;
    }
  }
  else
  {
    id v42 = +[NSSet set];
    v44 = v62;
    if (!v62) {
      goto LABEL_64;
    }
  }
  v45 = objc_msgSend(v44, "commands", v59, v60, v61);
  if (([v45 isEqualToSet:v42] & 1) == 0)
  {
    [v62 setCommands:v42];
    if ([v45 isSubsetOfSet:v42])
    {
      v46 = *(void **)(*(void *)(a1 + 48) + 120);
      if (!v46)
      {
        id v47 = objc_alloc_init((Class)NSMutableSet);
        uint64_t v48 = *(void *)(a1 + 48);
        v49 = *(void **)(v48 + 120);
        *(void *)(v48 + 120) = v47;

        v46 = *(void **)(*(void *)(a1 + 48) + 120);
      }
      [v46 unionSet:v42];
    }
    else
    {
      id v50 = objc_alloc_init((Class)NSMutableSet);
      uint64_t v51 = *(void *)(a1 + 48);
      v52 = *(void **)(v51 + 120);
      *(void *)(v51 + 120) = v50;

      long long v69 = 0u;
      long long v70 = 0u;
      long long v67 = 0u;
      long long v68 = 0u;
      id v53 = *(id *)(*(void *)(a1 + 48) + 72);
      id v54 = [v53 countByEnumeratingWithState:&v67 objects:v84 count:16];
      if (v54)
      {
        uint64_t v55 = *(void *)v68;
        do
        {
          for (k = 0; k != v54; k = (char *)k + 1)
          {
            if (*(void *)v68 != v55) {
              objc_enumerationMutation(v53);
            }
            v57 = *(void **)(*(void *)(a1 + 48) + 120);
            v58 = [*(id *)(*((void *)&v67 + 1) + 8 * (void)k) commands];
            [v57 unionSet:v58];
          }
          id v54 = [v53 countByEnumeratingWithState:&v67 objects:v84 count:16];
        }
        while (v54);
      }
    }
    [*(id *)(a1 + 48) _updatePushCommandsLocked];
  }

  v44 = v62;
LABEL_64:
  if (objc_msgSend(v44, "capabilities", v59, v60, v61) != *(_DWORD *)(a1 + 80)) {
    objc_msgSend(v62, "setCapabilities:");
  }
}

id sub_100008268(void *a1)
{
  id v1 = a1;
  if ([v1 rangeOfString:@"+."])
  {
    if ([v1 rangeOfString:@"-."])
    {
      if ([v1 rangeOfString:@"&."])
      {
        if ([v1 rangeOfString:@"^."])
        {
          id v6 = v1;
          goto LABEL_11;
        }
        long long v7 = [v1 substringFromIndex:v5];
        +[NSString stringWithFormat:@"com.apple.%@", v7];
      }
      else
      {
        long long v7 = [v1 substringFromIndex:v4];
        +[NSString stringWithFormat:@"com.apple.private.alloy.%@", v7];
      }
    }
    else
    {
      long long v7 = [v1 substringFromIndex:v3];
      +[NSString stringWithFormat:@"^.%@", v7];
    }
  }
  else
  {
    long long v7 = [v1 substringFromIndex:v2];
    +[NSString stringWithFormat:@"&.%@", v7];
  }
  id v6 = (id)objc_claimAutoreleasedReturnValue();

LABEL_11:

  return v6;
}

id sub_10000969C(void *a1)
{
  id v1 = a1;
  if ([v1 rangeOfString:@"&."])
  {
    if ([v1 rangeOfString:@"^."])
    {
      if ([v1 rangeOfString:@"com.apple.private.alloy."])
      {
        if ([v1 rangeOfString:@"com.apple."])
        {
          id v6 = v1;
          goto LABEL_11;
        }
        long long v7 = [v1 substringFromIndex:v5];
        +[NSString stringWithFormat:@"^.%@", v7];
      }
      else
      {
        long long v7 = [v1 substringFromIndex:v4];
        +[NSString stringWithFormat:@"&.%@", v7];
      }
    }
    else
    {
      long long v7 = [v1 substringFromIndex:v3];
      +[NSString stringWithFormat:@"-.%@", v7];
    }
  }
  else
  {
    long long v7 = [v1 substringFromIndex:v2];
    +[NSString stringWithFormat:@"+.%@", v7];
  }
  id v6 = (id)objc_claimAutoreleasedReturnValue();

LABEL_11:

  return v6;
}

uint64_t sub_100009A28(void *a1)
{
  id v1 = a1;
  if ([v1 isEqualToString:kIDSRegistrationEntitlement])
  {
    char v2 = 1;
  }
  else if ([v1 isEqualToString:kIDSMessagingEntitlement])
  {
    char v2 = 2;
  }
  else if ([v1 isEqualToString:kIDSSessionEntitlement])
  {
    char v2 = 3;
  }
  else if ([v1 isEqualToString:kIDSRegistrationResetEntitlement])
  {
    char v2 = 4;
  }
  else if ([v1 isEqualToString:kIDSiCloudSignInHackEntitlement])
  {
    char v2 = 5;
  }
  else if ([v1 isEqualToString:kIDSEncryptionKeysEntitlement])
  {
    char v2 = 6;
  }
  else if ([v1 isEqualToString:kIDSHighPriorityMessagingEntitlement])
  {
    char v2 = 7;
  }
  else if ([v1 isEqualToString:kIDSUrgentPriorityMessagingEntitlement])
  {
    char v2 = 8;
  }
  else if ([v1 isEqualToString:kIDSContinuityEntitlement])
  {
    char v2 = 9;
  }
  else if ([v1 isEqualToString:kIDSSelfSessionEntitlement])
  {
    char v2 = 10;
  }
  else if ([v1 isEqualToString:kIDSDeviceUUIDEntitlement])
  {
    char v2 = 11;
  }
  else if ([v1 isEqualToString:kIDSSessionPrivateEntitlement])
  {
    char v2 = 12;
  }
  else if ([v1 isEqualToString:kIDSBypassSizeCheckEntitlement])
  {
    char v2 = 13;
  }
  else if ([v1 isEqualToString:kIDSPreferInfraWiFiEntitlement])
  {
    char v2 = 14;
  }
  else if ([v1 isEqualToString:kIDSLinkPreferencesEntitlement])
  {
    char v2 = 15;
  }
  else if ([v1 isEqualToString:kIDSLocalPairingEntitlement])
  {
    char v2 = 16;
  }
  else if ([v1 isEqualToString:kIDSLocalPairingAPIEntitlement])
  {
    char v2 = 17;
  }
  else if ([v1 isEqualToString:kIDSAccountSyncEntitlement])
  {
    char v2 = 18;
  }
  else if ([v1 isEqualToString:kIDSAllowedTrafficClasses])
  {
    char v2 = 19;
  }
  else if ([v1 isEqualToString:kIDSKeyRollingEntitlement])
  {
    char v2 = 20;
  }
  else if ([v1 isEqualToString:kIDSReportiMessageSpamEntitlement])
  {
    char v2 = 21;
  }
  else if ([v1 isEqualToString:kIDSForceEncryptionOffEntitlement])
  {
    char v2 = 22;
  }
  else if ([v1 isEqualToString:kIDSSubServicesEntitlement])
  {
    char v2 = 23;
  }
  else if ([v1 isEqualToString:kIDSAppleCareServicesEntitlement])
  {
    char v2 = 24;
  }
  else if ([v1 isEqualToString:kIDSRegistrationControlEntitlement])
  {
    char v2 = 25;
  }
  else if ([v1 isEqualToString:kIDSPhoneNumberAuthenticationEntitlement])
  {
    char v2 = 26;
  }
  else if ([v1 isEqualToString:kIDSPhoneNumberAuthenticationPrivateEntitlement])
  {
    char v2 = 27;
  }
  else if ([v1 isEqualToString:kIDSTestToolEntitlement])
  {
    char v2 = 28;
  }
  else if ([v1 isEqualToString:kIDSStateResetEntitlement])
  {
    char v2 = 29;
  }
  else if ([v1 isEqualToString:kIDSReportSpamEntitlement])
  {
    char v2 = 30;
  }
  else if ([v1 isEqualToString:kIDSStatusKitPublishingForStatusTypeEntitlement])
  {
    char v2 = 31;
  }
  else if ([v1 isEqualToString:kIDSStatusKitSubscriptionForStatusTypeEntitlement])
  {
    char v2 = 32;
  }
  else if ([v1 isEqualToString:kIDSStatusKitPublishingForAllStatusTypeEntitlement])
  {
    char v2 = 33;
  }
  else if ([v1 isEqualToString:kIDSStatusKitSubscriptionForAllStatusTypeEntitlement])
  {
    char v2 = 34;
  }
  else if ([v1 isEqualToString:kIDSForceQuerySendParameterEntitlement])
  {
    char v2 = 35;
  }
  else
  {
    char v2 = -1;
  }

  return v2;
}

void sub_10000B6C0(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,long long buf)
{
  if (a2 == 1)
  {
    id v31 = objc_begin_catch(a1);

    v32 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v31;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Exception generating setup information for listener: %@", (uint8_t *)&buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      _IDSLogTransport();
    }
    IMLogBacktrace();
    IMLogSimulateCrashForException();

    objc_end_catch();
    JUMPOUT(0x10000B4C4);
  }
  _Unwind_Resume(a1);
}

BOOL sub_10000B884(id a1, id a2, NSDictionary *a3)
{
  return objc_msgSend(a2, "length", a3) != 0;
}

uint64_t sub_10000BBC4(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  uint64_t v2 = *(void *)(a1 + 40);

  return _pthread_dependency_fulfill_np(v2, 0);
}

void sub_10000C468(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 144), 8);
  _Unwind_Resume(a1);
}

void sub_10000C490(id a1, CSDBRecordStore *a2)
{
  CSDBRecordSaveStore();

  _CSDBRecordStoreInvalidateCachesWithStore(a2);
}

void sub_10000C4CC(uint64_t a1)
{
  uint64_t v2 = *(void **)(*(void *)(a1 + 32) + 96);
  if (v2)
  {
    uint64_t v3 = *(unsigned __int8 *)(a1 + 56);
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v5 = *(void *)(a1 + 48);
    [v2 disconnectGlobalLinkForDevice:v4 isReinitiating:v3 completionHandler:v5];
  }
  else if (*(void *)(a1 + 48))
  {
    id v6 = im_primary_queue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100372818;
    block[3] = &unk_10097E7F0;
    id v9 = *(id *)(a1 + 48);
    dispatch_block_t v7 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, QOS_CLASS_USER_INTERACTIVE, 0, block);
    dispatch_async(v6, v7);
  }
}

void sub_10000C5C0(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10000C60C(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10000C658(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10000C6A4(uint64_t a1)
{
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  uint64_t v3 = *(void *)(a1 + 32);
  double v4 = *(double *)(v3 + 40) - Current + 600.0;
  if (v4 <= 0.0)
  {
    [(id)v3 closeDatabase];
  }
  else
  {
    int64_t v5 = (uint64_t)(v4 * 1000000000.0);
    id v6 = *(NSObject **)(v3 + 32);
    dispatch_time_t v7 = dispatch_time(0, v5);
    dispatch_source_set_timer(v6, v7, 0x7FFFFFFFFFFFFFFFuLL, v5 / 10);
  }
}

id sub_10000C754(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) _cloudDisableTimerFired:a2];
}

id sub_10000C760(uint64_t a1)
{
  return [*(id *)(a1 + 32) _resetQueuedBroadcastsForServices:*(void *)(a1 + 40) priority:100];
}

id sub_10000C770(uint64_t a1)
{
  return [*(id *)(a1 + 32) _resetQueuedBroadcastsForServices:*(void *)(a1 + 40) priority:200];
}

id sub_10000C780(uint64_t a1)
{
  return [*(id *)(a1 + 32) _resetQueuedBroadcastsForServices:*(void *)(a1 + 40) priority:300];
}

void sub_10000C790(uint64_t a1, void *a2)
{
}

id sub_10000C7A0()
{
  return +[CTStewieIMessageLiteMessageOutgoing maxLengthInBytesForPayload];
}

void sub_10000D4C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10000F950(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  id v3 = [*(id *)(a1 + 48) uniqueID];
  [v1 requestKeyMaterialForGroup:v2 sessionID:v3 toSpecificMembers:0 requireMKM:1 requireSKM:0];
}

id sub_10000FDB8(uint64_t a1)
{
  return _[*(id *)(a1 + 32) sendKeyMaterialsRecoveryRequestToGroup:*(void *)(a1 + 40) requireMKM:1 requireSKM:0];
}

void sub_1000101F8(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  id v3 = [*(id *)(a1 + 48) uniqueID];
  [v1 requestKeyMaterialForGroup:v2 sessionID:v3 toSpecificMembers:0 requireMKM:1 requireSKM:0];
}

void sub_100011D98(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = *(void **)(a1 + 32);
  id v13 = v3;
  int64_t v5 = [v3 serviceName];
  id v6 = [v4 objectForKeyedSubscript:v5];

  if (!v6)
  {
    id v7 = objc_alloc_init((Class)NSMutableArray);
    uint64_t v8 = *(void **)(a1 + 32);
    id v9 = [v13 serviceName];
    [v8 setObject:v7 forKeyedSubscript:v9];
  }
  unsigned int v10 = *(void **)(a1 + 32);
  id v11 = [v13 serviceName];
  uint64_t v12 = [v10 objectForKeyedSubscript:v11];

  [v12 addObject:v13];
}

void sub_100012130(id a1)
{
  qword_100A4A228 = objc_alloc_init(IDSDeviceHeartbeatCenter);

  _objc_release_x1();
}

id sub_100012B0C(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _updateDependentRegistrations];
}

id sub_100012D04(uint64_t a1)
{
  return [*(id *)(a1 + 32) _heartBeat];
}

void sub_100012E04(id a1)
{
  off_100A4A230 = (_UNKNOWN *)IMWeakLinkSymbol();
}

id sub_100013EB0(uint64_t a1)
{
  return [*(id *)(a1 + 32) _processIncomingPacket];
}

void sub_100015BA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t sub_100015BC0(uint64_t a1)
{
  long long v106 = 0u;
  long long v107 = 0u;
  long long v108 = 0u;
  long long v109 = 0u;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id obj = [WeakRetained persistenceManagers];
  id v79 = [obj countByEnumeratingWithState:&v106 objects:v119 count:16];
  if (v79)
  {
    uint64_t v78 = *(void *)v107;
    do
    {
      for (i = 0; i != v79; i = (char *)i + 1)
      {
        if (*(void *)v107 != v78) {
          objc_enumerationMutation(obj);
        }
        uint64_t v1 = *(void **)(*((void *)&v106 + 1) + 8 * i);
        uint64_t v2 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Query cache:", buf, 2u);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
          _IDSLogV();
        }
        long long v104 = 0u;
        long long v105 = 0u;
        long long v102 = 0u;
        long long v103 = 0u;
        objc_msgSend(v1, "allPeerIDKeys", v74, v75, v76);
        id v82 = (id)objc_claimAutoreleasedReturnValue();
        id v84 = [v82 countByEnumeratingWithState:&v102 objects:v118 count:16];
        if (v84)
        {
          uint64_t v83 = *(void *)v103;
          do
          {
            for (j = 0; j != v84; j = (char *)j + 1)
            {
              if (*(void *)v103 != v83) {
                objc_enumerationMutation(v82);
              }
              id v3 = *(void **)(*((void *)&v102 + 1) + 8 * (void)j);
              id v88 = v3;
              double v4 = OSLogHandleForIDSCategory();
              if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
              {
                int64_t v5 = [v3 service];
                id v6 = [v3 fromURI];
                id v7 = [v3 toURI];
                *(_DWORD *)buf = 138543875;
                CFStringRef v113 = v5;
                __int16 v114 = 2113;
                v115 = v6;
                __int16 v116 = 2113;
                v117 = v7;
                _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Key: <%{public}@,from:%{private}@,to:%{private}@>", buf, 0x20u);
              }
              if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
              {
                uint64_t v8 = [v3 service];
                id v9 = [v3 fromURI];
                [v3 toURI];
                v76 = id v75 = v9;
                v74 = v8;
                _IDSLogV();
              }
              char v101 = 0;
              unsigned int v10 = *(void **)(a1 + 32);
              id v11 = objc_msgSend(v3, "service", v74);
              uint64_t v12 = [v3 fromURI];
              id v13 = [v3 toURI];
              CFStringRef v14 = [v10 _endpointsForService:v11 fromURI:v12 toURI:v13 ignoreExpiration:1 ignoreCache:0 hitCache:&v101];

              long long v99 = 0u;
              long long v100 = 0u;
              long long v97 = 0u;
              long long v98 = 0u;
              id v90 = v14;
              id v15 = [v90 countByEnumeratingWithState:&v97 objects:v111 count:16];
              if (v15)
              {
                uint64_t v91 = *(void *)v98;
                do
                {
                  for (k = 0; k != v15; k = (char *)k + 1)
                  {
                    if (*(void *)v98 != v91) {
                      objc_enumerationMutation(v90);
                    }
                    uint64_t v17 = *(void **)(*((void *)&v97 + 1) + 8 * (void)k);
                    objc_msgSend(v17, "serializedPublicLegacyIdentity", v74);
                    id v18 = (__CFString *)objc_claimAutoreleasedReturnValue();
                    CFStringRef v19 = OSLogHandleForIDSCategory();
                    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v20 = [v17 URI];
                      *(_DWORD *)buf = 138412290;
                      CFStringRef v113 = v20;
                      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "        URI: %@", buf, 0xCu);
                    }
                    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
                    {
                      v74 = [v17 URI];
                      _IDSLogV();
                    }
                    int v21 = OSLogHandleForIDSCategory();
                    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
                    {
                      v22 = [v17 shortHandle];
                      *(_DWORD *)buf = 138412290;
                      CFStringRef v113 = v22;
                      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "        Short Handle: %@", buf, 0xCu);
                    }
                    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
                    {
                      v74 = [v17 shortHandle];
                      _IDSLogV();
                    }
                    v23 = OSLogHandleForIDSCategory();
                    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v24 = [v17 pushToken];
                      uint64_t v25 = [v24 debugDescription];
                      *(_DWORD *)buf = 138412290;
                      CFStringRef v113 = v25;
                      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "        Push token: %@", buf, 0xCu);
                    }
                    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
                    {
                      v26 = [v17 pushToken];
                      v74 = [v26 debugDescription];
                      _IDSLogV();
                    }
                    v27 = OSLogHandleForIDSCategory();
                    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v28 = [v17 sessionToken];
                      v29 = [v28 debugDescription];
                      *(_DWORD *)buf = 138412290;
                      CFStringRef v113 = v29;
                      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "        Session token: %@", buf, 0xCu);
                    }
                    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
                    {
                      id v30 = [v17 sessionToken];
                      v74 = [v30 debugDescription];
                      _IDSLogV();
                    }
                    id v31 = OSLogHandleForIDSCategory();
                    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
                    {
                      v32 = [v17 expireDate];
                      *(_DWORD *)buf = 138412290;
                      CFStringRef v113 = v32;
                      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "        Expire: %@", buf, 0xCu);
                    }
                    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
                    {
                      v74 = [v17 expireDate];
                      _IDSLogV();
                    }
                    id v33 = OSLogHandleForIDSCategory();
                    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v34 = [v17 refreshDate];
                      *(_DWORD *)buf = 138412290;
                      CFStringRef v113 = v34;
                      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "        Refresh: %@", buf, 0xCu);
                    }
                    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
                    {
                      v74 = [v17 refreshDate];
                      _IDSLogV();
                    }
                    v35 = OSLogHandleForIDSCategory();
                    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 138412290;
                      CFStringRef v113 = v18;
                      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "        Public Key: %@", buf, 0xCu);
                    }

                    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
                    {
                      v74 = v18;
                      _IDSLogV();
                    }
                  }
                  id v15 = [v90 countByEnumeratingWithState:&v97 objects:v111 count:16];
                }
                while (v15);
              }

              if (v101)
              {
                id v36 = *(void **)(a1 + 32);
                id v37 = [v88 service];
                uint64_t v38 = [v88 fromURI];
                uint64_t v39 = [v88 toURI];
                v86 = [v36 _endpointsForService:v37 fromURI:v38 toURI:v39 ignoreExpiration:1 ignoreCache:1 hitCache:0];

                v40 = +[NSSet setWithArray:v90];
                v41 = +[NSSet setWithArray:v86];
                LOBYTE(v39) = [v40 isEqualToSet:v41];

                if ((v39 & 1) == 0)
                {
                  id v42 = OSLogHandleForIDSCategory();
                  if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
                  {
                    v43 = [v88 service];
                    v44 = [v88 fromURI];
                    v45 = [v88 toURI];
                    *(_DWORD *)buf = 138543875;
                    CFStringRef v113 = v43;
                    __int16 v114 = 2113;
                    v115 = v44;
                    __int16 v116 = 2113;
                    v117 = v45;
                    _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "Persisted Result for Key: <%{public}@,from:%{private}@,to:%{private}@>", buf, 0x20u);
                  }
                  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
                  {
                    v46 = [v88 service];
                    id v47 = [v88 fromURI];
                    [v88 toURI];
                    v76 = id v75 = v47;
                    v74 = v46;
                    _IDSLogV();
                  }
                  long long v95 = 0u;
                  long long v96 = 0u;
                  long long v93 = 0u;
                  long long v94 = 0u;
                  id v89 = v86;
                  id v48 = [v89 countByEnumeratingWithState:&v93 objects:v110 count:16];
                  if (v48)
                  {
                    uint64_t v92 = *(void *)v94;
                    do
                    {
                      for (m = 0; m != v48; m = (char *)m + 1)
                      {
                        if (*(void *)v94 != v92) {
                          objc_enumerationMutation(v89);
                        }
                        id v50 = *(void **)(*((void *)&v93 + 1) + 8 * (void)m);
                        objc_msgSend(v50, "serializedPublicLegacyIdentity", v74);
                        uint64_t v51 = (__CFString *)objc_claimAutoreleasedReturnValue();
                        v52 = OSLogHandleForIDSCategory();
                        if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
                        {
                          id v53 = [v50 URI];
                          *(_DWORD *)buf = 138412290;
                          CFStringRef v113 = v53;
                          _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "        URI: %@", buf, 0xCu);
                        }
                        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
                        {
                          v74 = [v50 URI];
                          _IDSLogV();
                        }
                        id v54 = OSLogHandleForIDSCategory();
                        if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
                        {
                          uint64_t v55 = [v50 shortHandle];
                          *(_DWORD *)buf = 138412290;
                          CFStringRef v113 = v55;
                          _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "        Short Handle: %@", buf, 0xCu);
                        }
                        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
                        {
                          v74 = [v50 shortHandle];
                          _IDSLogV();
                        }
                        v56 = OSLogHandleForIDSCategory();
                        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
                        {
                          v57 = [v50 pushToken];
                          v58 = [v57 debugDescription];
                          *(_DWORD *)buf = 138412290;
                          CFStringRef v113 = v58;
                          _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "        Push token: %@", buf, 0xCu);
                        }
                        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
                        {
                          CFStringRef v59 = [v50 pushToken];
                          v74 = [v59 debugDescription];
                          _IDSLogV();
                        }
                        id v60 = OSLogHandleForIDSCategory();
                        if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
                        {
                          id v61 = [v50 sessionToken];
                          id v62 = [v61 debugDescription];
                          *(_DWORD *)buf = 138412290;
                          CFStringRef v113 = v62;
                          _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "        Session token: %@", buf, 0xCu);
                        }
                        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
                        {
                          id v63 = [v50 sessionToken];
                          v74 = [v63 debugDescription];
                          _IDSLogV();
                        }
                        v64 = OSLogHandleForIDSCategory();
                        if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
                        {
                          v65 = [v50 expireDate];
                          *(_DWORD *)buf = 138412290;
                          CFStringRef v113 = v65;
                          _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "        Expire: %@", buf, 0xCu);
                        }
                        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
                        {
                          v74 = [v50 expireDate];
                          _IDSLogV();
                        }
                        v66 = OSLogHandleForIDSCategory();
                        if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
                        {
                          long long v67 = [v50 refreshDate];
                          *(_DWORD *)buf = 138412290;
                          CFStringRef v113 = v67;
                          _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "        Refresh: %@", buf, 0xCu);
                        }
                        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
                        {
                          v74 = [v50 refreshDate];
                          _IDSLogV();
                        }
                        long long v68 = OSLogHandleForIDSCategory();
                        if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_DWORD *)buf = 138412290;
                          CFStringRef v113 = v51;
                          _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "        Public Key: %@", buf, 0xCu);
                        }

                        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
                        {
                          v74 = v51;
                          _IDSLogV();
                        }
                      }
                      id v48 = [v89 countByEnumeratingWithState:&v93 objects:v110 count:16];
                    }
                    while (v48);
                  }
                }
              }
            }
            id v84 = [v82 countByEnumeratingWithState:&v102 objects:v118 count:16];
          }
          while (v84);
        }
      }
      id v79 = [obj countByEnumeratingWithState:&v106 objects:v119 count:16];
    }
    while (v79);
  }

  long long v69 = +[IMRGLog sysdiagnose_oversized];
  if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
  {
    long long v70 = [*(id *)(a1 + 32) keyTransparencyVerifier];
    unsigned int v71 = [v70 isOptedInForServiceIdentifier:@"com.apple.madrid"];
    CFStringRef v72 = @"NO";
    if (v71) {
      CFStringRef v72 = @"YES";
    }
    *(_DWORD *)buf = 138412290;
    CFStringRef v113 = v72;
    _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "KT Opt In State: %@", buf, 0xCu);
  }
  return 0;
}

void sub_10001A0C0(void *a1, int a2, void *a3)
{
  id v5 = a3;
  if (v5 || !a2)
  {
    unsigned int v10 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = a1[4];
      uint64_t v12 = a1[5];
      uint64_t v13 = a1[6];
      *(_DWORD *)buf = 138413058;
      uint64_t v15 = v11;
      __int16 v16 = 2112;
      uint64_t v17 = v12;
      __int16 v18 = 2112;
      id v19 = v5;
      __int16 v20 = 2112;
      uint64_t v21 = v13;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Error saving endpoints to SwiftData DB for service: %@, uri: %@, error: %@, uuid: %@", buf, 0x2Au);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      goto LABEL_12;
    }
  }
  else
  {
    id v6 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = a1[4];
      uint64_t v8 = a1[5];
      id v9 = (void *)a1[6];
      *(_DWORD *)buf = 138412802;
      uint64_t v15 = v7;
      __int16 v16 = 2112;
      uint64_t v17 = v8;
      __int16 v18 = 2112;
      id v19 = v9;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Successfully saved endpoints to SwiftData DB for service: %@, uri: %@, uuid: %@", buf, 0x20u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
LABEL_12:
    }
      _IDSLogV();
  }
}

void sub_10001A2EC(id a1, NSArray *a2, NSError *a3)
{
  id v3 = a3;
  if (v3)
  {
    double v4 = +[IDSFoundationLog KeyTransparency];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 138412290;
      id v6 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Failed kicking KT peer verification for query { error: %@ }", (uint8_t *)&v5, 0xCu);
    }
  }
}

void sub_10001A3A4(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) queryCompletionBlock];
  (*((void (**)(id, void, void, void))v2 + 2))(v2, *(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56));
}

uint64_t sub_10001B02C(uint64_t a1, void *a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = [a2 pushToken];
  uint64_t v4 = [v2 isEqualToData:v3] ^ 1;

  return v4;
}

id sub_10001B074(uint64_t a1, void *a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = a2;
  uint64_t v4 = [v2 rawToken];
  int v5 = [v3 pushToken];

  id v6 = [v4 isEqualToData:v5];
  return v6;
}

id sub_10001B230(uint64_t a1, void *a2)
{
  id v3 = [a2 pushTokenObject];
  id v4 = [v3 isEqualToPushToken:*(void *)(a1 + 32)];

  return v4;
}

id sub_10001B670(uint64_t a1, void *a2)
{
  id v3 = [a2 pushTokenObject];
  id v4 = [v3 isEqualToPushToken:*(void *)(a1 + 32)];

  return v4;
}

id sub_10001C398(uint64_t a1, void *a2)
{
  id v3 = [a2 pushTokenObject];
  id v4 = [v3 isEqualToPushToken:*(void *)(a1 + 32)];

  return v4;
}

uint64_t sub_10001C774(uint64_t a1, void *a2)
{
  id v3 = a2;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  id v4 = *(id *)(a1 + 32);
  id v5 = [v4 countByEnumeratingWithState:&v16 objects:v20 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v17;
    while (2)
    {
      for (i = 0; i != v6; i = (char *)i + 1)
      {
        if (*(void *)v17 != v7) {
          objc_enumerationMutation(v4);
        }
        uint64_t v9 = *(void *)(*((void *)&v16 + 1) + 8 * i);
        unsigned int v10 = objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", v9, (void)v16);
        uint64_t v11 = [v3 capabilities];
        id v12 = [v11 valueForCapability:v9];
        id v13 = [v10 integerValue];

        if (v12 != v13)
        {
          uint64_t v14 = 0;
          goto LABEL_11;
        }
      }
      id v6 = [v4 countByEnumeratingWithState:&v16 objects:v20 count:16];
      if (v6) {
        continue;
      }
      break;
    }
  }
  uint64_t v14 = 1;
LABEL_11:

  return v14;
}

id sub_10001D5F8(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 service];
  if ([v4 isEqualToString:*(void *)(a1 + 32)])
  {
    id v5 = [v3 fromURI];
    id v6 = [v5 isEqual:*(void *)(a1 + 40)];
  }
  else
  {
    id v6 = 0;
  }

  return v6;
}

id sub_10001D764(uint64_t a1, void *a2)
{
  id v3 = [a2 service];
  id v4 = [v3 isEqualToString:*(void *)(a1 + 32)];

  return v4;
}

id sub_10001DB3C(id a1, NSString *a2)
{
  id v2 = a2;
  if ([(NSString *)v2 isEqualToString:kFZServiceDefaultsSentinelAlias]
    || [(NSString *)v2 isEqualToString:kIDSServiceDefaultsSentinelSelfAlias])
  {
    id v3 = 0;
  }
  else
  {
    id v3 = +[IDSURI URIWithPrefixedURI:v2];
  }

  return v3;
}

void sub_10001E310(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  if (v5 || !a2)
  {
    uint64_t v8 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138412546;
      uint64_t v11 = v9;
      __int16 v12 = 2112;
      id v13 = v5;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Failed to update SwiftData DB with new KT peer verification results for URI: %@ {error: %@}", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      goto LABEL_12;
    }
  }
  else
  {
    id v6 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138412290;
      uint64_t v11 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Successfully updated SwiftData DB with new KT peer verification results for URI: %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
LABEL_12:
    }
      _IDSLogV();
  }
}

id sub_10001E840(id a1, IDSURI *a2)
{
  id v2 = a2;
  id v4 = [(IDSURI *)v2 tokenFreeURI];

  return v4;
}

void sub_10001E8A4(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, unsigned int a8, void *a9, unsigned __int8 a10)
{
  id v51 = a2;
  id v50 = a3;
  id v16 = a4;
  id v49 = a5;
  id v48 = a6;
  id v47 = a7;
  id v46 = a9;
  long long v17 = *(void **)(a1 + 32);
  long long v18 = [*(id *)(a1 + 40) allObjects];
  v52 = [v17 endpointsForURIs:v18 service:*(void *)(a1 + 48) fromURI:*(void *)(a1 + 56)];

  long long v19 = +[NSMutableDictionary dictionary];
  long long v59 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  uint64_t v54 = a1;
  id obj = *(id *)(a1 + 64);
  id v20 = [obj countByEnumeratingWithState:&v59 objects:v63 count:16];
  if (v20)
  {
    id v21 = v20;
    uint64_t v22 = *(void *)v60;
    do
    {
      for (i = 0; i != v21; i = (char *)i + 1)
      {
        if (*(void *)v60 != v22) {
          objc_enumerationMutation(obj);
        }
        uint64_t v24 = *(void **)(*((void *)&v59 + 1) + 8 * i);
        uint64_t v26 = [v24 pushToken];
        v27 = [v24 tokenFreeURI];
        v56 = (void *)v26;
        if (![v16 count])
        {
          if (!v26) {
            goto LABEL_17;
          }
LABEL_11:
          id v30 = *(void **)(v54 + 72);
          goto LABEL_12;
        }
        unsigned __int8 v28 = [v16 containsObject:v27];
        unsigned __int8 v29 = v28;
        if (!v26)
        {
          if (v28) {
            v40 = v52;
          }
          else {
LABEL_17:
          }
            v40 = *(void **)(v54 + 72);
          id v31 = [v40 objectForKeyedSubscript:v27];
          [v19 setObject:v31 forKeyedSubscript:v27];
          goto LABEL_19;
        }
        id v30 = v52;
        if ((v29 & 1) == 0) {
          goto LABEL_11;
        }
LABEL_12:
        uint64_t v55 = v25;
        id v31 = [v30 objectForKeyedSubscript:v27];
        v57[0] = _NSConcreteStackBlock;
        v57[1] = 3221225472;
        v57[2] = sub_10001ECA0;
        v57[3] = &unk_10097E5D0;
        id v58 = v56;
        v32 = objc_msgSend(v31, "__imArrayByFilteringWithBlock:", v57);
        id v33 = [v19 objectForKeyedSubscript:v27];
        uint64_t v34 = v33;
        if (v33)
        {
          [v33 arrayByAddingObjectsFromArray:v32];
          v35 = v19;
          id v36 = v21;
          uint64_t v37 = v22;
          v39 = id v38 = v16;

          v32 = (void *)v39;
          id v16 = v38;
          uint64_t v22 = v37;
          id v21 = v36;
          long long v19 = v35;
        }
        [v19 setObject:v32 forKeyedSubscript:v27];

        uint64_t v25 = v55;
LABEL_19:

        uint64_t v41 = [v19 objectForKeyedSubscript:v27];
        id v42 = (void *)v41;
        if (v41) {
          v43 = (void *)v41;
        }
        else {
          v43 = &__NSArray0__struct;
        }
        [v19 setObject:v43 forKeyedSubscript:v27];
      }
      id v21 = [obj countByEnumeratingWithState:&v59 objects:v63 count:16];
    }
    while (v21);
  }

  uint64_t v44 = *(void *)(v54 + 80);
  if (v44) {
    (*(void (**)(uint64_t, id, id, id, id, void, id, void, void *))(v44 + 16))(v44, v51, v49, v48, v47, a8, v46, a10, v19);
  }
}

id sub_10001ECA0(uint64_t a1, void *a2)
{
  id v3 = [a2 pushTokenObject];
  id v4 = [v3 isEqualToPushToken:*(void *)(a1 + 32)];

  return v4;
}

void sub_10001F3C0(id a1, BOOL a2, NSError *a3)
{
  id v4 = a3;
  if (v4 || !a2)
  {
    id v5 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Failed deleting peer and personal entries from DB", v6, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
  }
}

void sub_10001F94C(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  if (v5 || (a2 & 1) == 0)
  {
    id v6 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      uint64_t v8 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138412802;
      uint64_t v10 = v7;
      __int16 v11 = 2112;
      uint64_t v12 = v8;
      __int16 v13 = 2112;
      id v14 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Failed deleting endpoints for URIs: %@ services: %@  {deleteError: %@}", buf, 0x20u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
  }
}

void sub_10001FF08(void *a1, char a2, void *a3)
{
  id v5 = a3;
  if (v5 || (a2 & 1) == 0)
  {
    id v6 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = a1[4];
      uint64_t v8 = a1[5];
      uint64_t v9 = a1[6];
      *(_DWORD *)buf = 138413058;
      uint64_t v11 = v7;
      __int16 v12 = 2112;
      uint64_t v13 = v8;
      __int16 v14 = 2112;
      uint64_t v15 = v9;
      __int16 v16 = 2112;
      id v17 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Failed deleting endpoints for URI: %@  from URI: %@  service: %@  {deleteError: %@}", buf, 0x2Au);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
  }
}

void sub_100020570(void *a1, char a2, void *a3)
{
  id v5 = a3;
  if (v5 || (a2 & 1) == 0)
  {
    id v6 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = a1[4];
      uint64_t v8 = a1[5];
      uint64_t v9 = a1[6];
      *(_DWORD *)buf = 138413058;
      uint64_t v11 = v7;
      __int16 v12 = 2112;
      uint64_t v13 = v8;
      __int16 v14 = 2112;
      uint64_t v15 = v9;
      __int16 v16 = 2112;
      id v17 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Failed deleting endpoints for URI: %@  from URI: %@  services: %@  {deleteError: %@}", buf, 0x2Au);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
  }
}

id sub_100020ACC(id a1, NSString *a2)
{
  id v2 = a2;
  if ([(NSString *)v2 isEqualToString:kFZServiceDefaultsSentinelAlias]
    && [(NSString *)v2 isEqualToString:kIDSServiceDefaultsSentinelSelfAlias])
  {
    id v3 = 0;
  }
  else
  {
    id v3 = +[IDSURI URIWithPrefixedURI:v2];
  }

  return v3;
}

void sub_100020DA8(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  if (v5 || (a2 & 1) == 0)
  {
    uint64_t v8 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138412546;
      uint64_t v11 = v9;
      __int16 v12 = 2112;
      id v13 = v5;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Failed deleting endpoints for service: %@  {deleteError: %@}", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      goto LABEL_12;
    }
  }
  else
  {
    id v6 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138412290;
      uint64_t v11 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Successfully deleted endpoints for service: %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
LABEL_12:
    }
      _IDSLogV();
  }
}

uint64_t sub_1000220E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned __int8 a10)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void))(result + 16))(result, a2, a5, a6, a7, a8, a9, a10);
  }
  return result;
}

void sub_100022A2C(void *a1)
{
  if (!*(void *)(a1[4] + 24))
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    uint64_t v3 = a1[4];
    id v4 = *(void **)(v3 + 24);
    *(void *)(v3 + 24) = Mutable;
  }
  id v5 = [[IDSPeerIDManagerEndpointQueryListener alloc] initWithQueryCompletionBlock:a1[7] queue:a1[5]];
  [*(id *)(a1[4] + 24) setObject:v5 forKey:a1[6]];
}

void sub_100022C68(uint64_t a1)
{
  [*(id *)(*(void *)(a1 + 32) + 24) removeObjectForKey:*(void *)(a1 + 40)];
  if (![*(id *)(*(void *)(a1 + 32) + 24) count])
  {
    uint64_t v2 = *(void *)(a1 + 32);
    uint64_t v3 = *(void **)(v2 + 24);
    *(void *)(v2 + 24) = 0;
  }
}

uint64_t sub_100022FCC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100022FE0(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) endpointsForURIs:*(void *)(a1 + 40) service:*(void *)(a1 + 48) fromURI:*(void *)(a1 + 56)];
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_1000230A0;
  v6[3] = &unk_10097E818;
  uint64_t v3 = *(NSObject **)(a1 + 64);
  id v4 = *(id *)(a1 + 72);
  id v7 = v2;
  id v8 = v4;
  id v5 = v2;
  dispatch_async(v3, v6);
}

uint64_t sub_1000230A0(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

id sub_100023768(id a1, NSString *a2)
{
  uint64_t v2 = a2;
  if ([(NSString *)v2 isEqualToString:kFZServiceDefaultsSentinelAlias]
    || [(NSString *)v2 isEqualToString:kIDSServiceDefaultsSentinelSelfAlias])
  {
    uint64_t v3 = 0;
  }
  else
  {
    uint64_t v3 = +[IDSURI URIWithPrefixedURI:v2];
  }

  return v3;
}

void sub_100024A5C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (([v5 isUserDisabled] & 1) == 0)
  {
    id v7 = [*(id *)(a1 + 32) restrictions];
    if ([v7 shouldDisableService:v6])
    {
    }
    else
    {
      id v8 = [v5 registrationError];

      if (v8 == (id)2)
      {
        uint64_t v9 = +[IMRGLog registration];
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v10 = [v6 identifier];
          int v11 = 138412546;
          id v12 = v5;
          __int16 v13 = 2112;
          __int16 v14 = v10;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "After SIM insertion, user denied SMS registration found, changing error {accounts: %@, service: %@", (uint8_t *)&v11, 0x16u);
        }
        [v5 _updateRegistrationStatusWithError:1 info:0];
      }
    }
  }
}

void sub_100024E84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100024EA8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  BOOL v7 = [(__CFString *)v5 registrationError] == (id)2
    || [(__CFString *)v5 registrationError] == (id)35
    || [(__CFString *)v5 registrationError] == (id)38
    || [(__CFString *)v5 registrationError] == (id)39
    || [(__CFString *)v5 registrationError] == (id)36;
  id v8 = [*(id *)(a1 + 32) restrictions];
  unsigned int v9 = [v8 shouldDisableService:v6];

  unsigned __int8 v10 = [(__CFString *)v5 isUserDisabled];
  int v11 = +[IMRGLog registration];
  BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
  if ((v10 & 1) != 0 || (v9 & 1) != 0 || v7)
  {
    if (v12)
    {
      if ([(__CFString *)v5 isUserDisabled]) {
        CFStringRef v14 = @"YES";
      }
      else {
        CFStringRef v14 = @"NO";
      }
      if (v9) {
        CFStringRef v15 = @"YES";
      }
      else {
        CFStringRef v15 = @"NO";
      }
      *(_DWORD *)buf = 138413058;
      CFStringRef v18 = v14;
      __int16 v19 = 2112;
      CFStringRef v20 = v15;
      __int16 v21 = 2048;
      id v22 = [(__CFString *)v5 registrationError];
      __int16 v23 = 2112;
      uint64_t v24 = v5;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Not enabling account after registration state changed {isUserDisabled: %@, shouldDisableService: %@, registrationError: %ld, account: %@}", buf, 0x2Au);
    }
  }
  else
  {
    if (v12)
    {
      __int16 v13 = [v6 identifier];
      *(_DWORD *)buf = 138412546;
      CFStringRef v18 = v5;
      __int16 v19 = 2112;
      CFStringRef v20 = v13;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "After registration state changed, enabling account: %@ on service: %@", buf, 0x16u);
    }
    __int16 v16 = v5;
    im_dispatch_after_primary_queue();
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
  }
}

void sub_100025140(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) accountController];
  uint64_t v2 = [*(id *)(a1 + 40) uniqueID];
  [v3 enableAccountWithUniqueID:v2];
}

void sub_1000257D8(uint64_t a1)
{
  id v2 = +[NRDeviceIdentifier newDeviceIdentifierWithBluetoothUUID:*(void *)(a1 + 32)];
  id v3 = objc_alloc((Class)NRDeviceMonitor);
  id v5 = *(void **)(a1 + 40);
  id v4 = (id *)(a1 + 40);
  id v6 = [v5 nrMonitorQueue];
  id v7 = [v3 initWithDeviceIdentifier:v2 delegate:v5 queue:v6];
  [*v4 setNrDeviceMonitor:v7];

  id v8 = [*v4 nrDeviceMonitor];

  unsigned int v9 = +[IDSFoundationLog IPsecLink];
  unsigned __int8 v10 = v9;
  if (v8)
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = [*v4 nrDeviceMonitor];
      BOOL v12 = [v11 deviceIdentifier];
      id v13 = *v4;
      int v14 = 138412546;
      CFStringRef v15 = v12;
      __int16 v16 = 2048;
      id v17 = v13;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "NRDeviceMonitor created {deviceIdentifier: %@, pointer: %p}", (uint8_t *)&v14, 0x16u);
    }
  }
  else if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    sub_100709138((uint64_t *)v4, v10);
  }
}

id sub_100025C30(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) delegate];
  [v2 nrDeviceBridge:*(void *)(a1 + 32) defaultPeerConnectivityDidChange:*(unsigned __int8 *)(a1 + 40)];

  id v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(unsigned __int8 *)(a1 + 40);

  return _[v3 _notifyIDSNanoRegistryPluginManagerOnWatch:v4];
}

void sub_100025E18(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) delegate];
  [v2 nrDeviceBridge:*(void *)(a1 + 32) defaultPeerNearbyDidChange:*(unsigned __int8 *)(a1 + 40)];
}

void sub_100026000(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) delegate];
  [v2 nrDeviceBridge:*(void *)(a1 + 32) defaultPeerCloudConnectivityDidChange:*(unsigned __int8 *)(a1 + 40)];
}

void sub_1000261EC(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) delegate];
  [v2 nrDeviceBridge:*(void *)(a1 + 32) deviceMagnetIndicationOfAwakeStateDidChange:*(unsigned __int8 *)(a1 + 40)];
}

void sub_100026460(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) delegate];
  [v2 nrDeviceBridge:*(void *)(a1 + 32) linkType:*(unsigned __int8 *)(a1 + 40)];
}

void sub_100026648(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) delegate];
  [v2 nrDeviceBridge:*(void *)(a1 + 32) defaultPeerClassCConnectivityDidChange:*(unsigned __int8 *)(a1 + 40)];
}

void sub_100026C5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100026C88(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    id v5 = [*(id *)(a1 + 32) queue];
    dispatch_assert_queue_V2(v5);

    id v6 = +[IDSFoundationLog query];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      int v11 = 138412546;
      uint64_t v12 = v7;
      __int16 v13 = 2112;
      id v14 = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Received endpoints for initial subscription state {self: %@, endpoints: %@}", (uint8_t *)&v11, 0x16u);
    }

    [WeakRetained _registerEndpointQueryCompletionBlock];
    id v8 = [v3 mutableCopy];
    [WeakRetained setEndpointMap:v8];

    uint64_t v9 = *(void *)(a1 + 40);
    unsigned __int8 v10 = [*(id *)(a1 + 32) resolvedEndpoints];
    (*(void (**)(uint64_t, void *, void))(v9 + 16))(v9, v10, 0);
  }
}

void sub_100027024(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_100027048(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v10 = a3;
  id v6 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v8 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v9 = [WeakRetained queue];
    dispatch_assert_queue_V2(v9);

    [v8 _noteSourceDidDiscoverEndpointMap:v6 forLocalURI:v10];
  }
}

void sub_10002751C(id a1)
{
  qword_100A4A248 = objc_alloc_init(IDSPublicIdentityCache);

  _objc_release_x1();
}

void sub_1000278CC(id a1, BOOL a2, NSError *a3)
{
  BOOL v3 = a2;
  uint64_t v4 = a3;
  id v5 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v6 = @"NO";
    if (v3) {
      CFStringRef v6 = @"YES";
    }
    *(_DWORD *)buf = 138412546;
    CFStringRef v8 = v6;
    __int16 v9 = 2112;
    id v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Saved public identity data to SwiftData DB { success: %@ saveError: %@ }", buf, 0x16u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
}

void sub_1000283E0(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  if (v5 || (a2 & 1) == 0)
  {
    CFStringRef v6 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      uint64_t v8 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138412802;
      uint64_t v10 = v7;
      __int16 v11 = 2112;
      uint64_t v12 = v8;
      __int16 v13 = 2112;
      id v14 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Failed to delete public identities with startDate: %@ endDate: %@ {deleteError: %@}", buf, 0x20u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
  }
}

id sub_100028968(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [v3 componentsSeparatedByString:@"-"];
  id v5 = [v4 objectAtIndex:2];

  if ([v5 isEqualToString:*(void *)(a1 + 32)])
  {
    CFStringRef v6 = [v3 componentsSeparatedByString:@"-"];
    uint64_t v7 = [v6 objectAtIndex:1];

    uint64_t v8 = +[IDSURI URIWithPrefixedURI:v7];
  }
  else
  {
    uint64_t v8 = 0;
  }

  return v8;
}

BOOL sub_100028A3C(id a1, IDSURI *a2)
{
  id v2 = a2;
  id v3 = [(IDSURI *)v2 prefixedURI];
  if ([v3 _appearsToBeDSID])
  {
    LOBYTE(v4) = 0;
  }
  else
  {
    id v5 = [(IDSURI *)v2 prefixedURI];
    if ([v5 _appearsToBePseudonymID])
    {
      LOBYTE(v4) = 0;
    }
    else
    {
      CFStringRef v6 = [(IDSURI *)v2 prefixedURI];
      unsigned int v4 = [v6 _appearsToBeTemporaryID] ^ 1;
    }
  }

  return v4;
}

void sub_10002977C(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x16u);
}

void sub_100029890(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100029C8C(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    if (a2 == 2)
    {
      objc_begin_catch(exception_object);
      objc_end_catch();
      JUMPOUT(0x100029BC8);
    }
    objc_begin_catch(exception_object);
    os_unfair_lock_unlock(v2);
    objc_exception_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void sub_100029D28(void *a1)
{
}

void sub_10002A1DC(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    if (a2 == 2)
    {
      objc_begin_catch(exception_object);
      objc_end_catch();
      JUMPOUT(0x10002A0E8);
    }

    objc_begin_catch(exception_object);
    os_unfair_lock_unlock(v2);
    objc_exception_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void sub_10002A4B4(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    objc_begin_catch(exception_object);
    os_unfair_lock_unlock(v2);
    objc_exception_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void sub_10002A8C0(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    objc_begin_catch(exception_object);
    os_unfair_lock_unlock(v2);
    objc_exception_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void sub_10002A9A0(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_10002A9B4(_Unwind_Exception *a1)
{
}

void sub_10002ABF8(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_10002AC0C(_Unwind_Exception *a1)
{
}

void sub_10002AC94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v12 = v11;

  _Unwind_Resume(a1);
}

void sub_10002B028(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v8 = a2;
  id v9 = a3;
  id v10 = a5;
  __int16 v11 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138412290;
    id v20 = v8;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "Get Service User ID's Completed with response %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  id v12 = v8;
  id v14 = *(void **)(a1 + 40);
  __int16 v13 = (void *)(a1 + 40);
  CFStringRef v15 = (void *)*(v13 - 1);
  __int16 v16 = [v14 localObject];
  id v17 = [v15 broadcasterForLocalObject:v16 messageContext:*v13];

  if (v17)
  {
    CFStringRef v18 = [v12 responseServiceUserIDs];
    [v17 serviceUserIDs:v18 error:v9];
  }
}

void sub_10002B45C(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v8 = a2;
  id v9 = a3;
  id v10 = a5;
  __int16 v11 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138412290;
    id v28 = v8;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "Get Admin Access Tokens Completed with response %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    id v26 = v8;
    _IDSLogV();
  }
  id v12 = v8;
  __int16 v13 = (__CFArray *)objc_alloc_init((Class)NSMutableArray);
  id v14 = [v12 responseAccessoryID];
  if (v14)
  {
    CFStringRef v15 = [v12 responseAdminAcccessToken];
    BOOL v16 = v15 == 0;

    if (!v16)
    {
      id v17 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
      CFStringRef v18 = [v12 responseAccessoryID];
      if (v18)
      {
        CFDictionarySetValue(v17, @"accessory-id", v18);
      }
      else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        sub_100709690();
      }

      __int16 v19 = [v12 responseAdminAcccessToken];
      if (v19)
      {
        CFDictionarySetValue(v17, @"access-token", v19);
      }
      else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        sub_1007095F4();
      }

      id v20 = [v12 responseExpiry];
      if (v20) {
        CFDictionarySetValue(v17, @"expiry", v20);
      }

      if (v13 && v17) {
        CFArrayAppendValue(v13, v17);
      }
    }
  }
  id v22 = *(void **)(a1 + 40);
  __int16 v21 = (void *)(a1 + 40);
  __int16 v23 = (void *)*(v21 - 1);
  uint64_t v24 = objc_msgSend(v22, "localObject", v26);
  uint64_t v25 = [v23 broadcasterForLocalObject:v24 messageContext:*v21];

  if (v25) {
    [v25 adminAccessTokens:v13 error:v9];
  }
}

void sub_10002B9B0(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v8 = a2;
  id v9 = a3;
  id v10 = a5;
  __int16 v11 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138412290;
    id v20 = v8;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "Get Consent Tokens Completed with response %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  id v12 = v8;
  __int16 v13 = [v12 responseConsentTokens];
  CFStringRef v15 = *(void **)(a1 + 40);
  id v14 = (void *)(a1 + 40);
  BOOL v16 = (void *)*(v14 - 1);
  id v17 = [v15 localObject];
  CFStringRef v18 = [v16 broadcasterForLocalObject:v17 messageContext:*v14];

  if (v18) {
    [v18 consentTokens:v13 error:v9];
  }
}

void sub_10002BDE4(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v8 = a2;
  id v9 = a3;
  id v10 = a5;
  __int16 v11 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138412290;
    id v20 = v8;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "Get User Access Tokens Completed with response %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  id v12 = v8;
  __int16 v13 = [v12 responseAccessTokens];
  CFStringRef v15 = *(void **)(a1 + 40);
  id v14 = (void *)(a1 + 40);
  BOOL v16 = (void *)*(v14 - 1);
  id v17 = [v15 localObject];
  CFStringRef v18 = [v16 broadcasterForLocalObject:v17 messageContext:*v14];

  if (v18) {
    [v18 userAccessTokens:v13 error:v9];
  }
}

uint64_t sub_10002C2B8(uint64_t a1)
{
  qword_100A4A250 = (uint64_t)objc_alloc_init(*(Class *)(a1 + 32));

  return _objc_release_x1();
}

void sub_10002C458(_Unwind_Exception *a1)
{
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v3 - 72));
  _Unwind_Resume(a1);
}

void sub_10002C484(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = im_primary_base_queue();
  dispatch_assert_queue_V2(v7);

  id v8 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412546;
    id v15 = v5;
    __int16 v16 = 2112;
    id v17 = v6;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Duet resources changed {syncIdentifiersToCheck: %@, defaultIdentifiersToCheck: %@}", buf, 0x16u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    id v12 = v5;
    id v13 = v6;
    _IDSLogV();
  }
  id v9 = +[NSMutableSet set];
  [v9 addObjectsFromArray:v6];
  [v9 addObjectsFromArray:v5];
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  __int16 v11 = [v9 allObjects];
  [WeakRetained _resourceAvailabilityChangedForIdentifiers:v11];
}

void sub_10002C630(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v4 = im_primary_base_queue();
  dispatch_assert_queue_V2(v4);

  id v5 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    id v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Duet admission revocation, {defaultIdentifiersToAllow: %@}", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained clearAdmissionCheckCache];
  [WeakRetained _resourceAvailabilityChangedForIdentifiers:v3];
}

void sub_10002CEDC(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x10002CDF8);
  }
  _Unwind_Resume(a1);
}

void sub_10002D270(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x10002D18CLL);
  }
  _Unwind_Resume(a1);
}

id sub_10002D3DC(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) appendString:a2];
}

void sub_10002E2AC(uint64_t a1)
{
  id v1 = objc_alloc(*(Class *)(a1 + 32));
  id v2 = [IDSActivityStateProvider alloc];
  id v11 = +[IMUserDefaults sharedDefaults];
  id v3 = [(IDSActivityStateProvider *)v2 initWithUserDefaults:v11];
  unsigned int v4 = objc_msgSend(+[FTMessageDelivery APNSMessageDeliveryClass](FTMessageDelivery, "APNSMessageDeliveryClass"), "sharedInstance");
  id v5 = +[IDSPeerIDManager sharedInstance];
  id v6 = +[IDSDAccountController sharedInstance];
  uint64_t v7 = +[IDSDServiceController sharedInstance];
  id v8 = im_primary_queue();
  id v9 = [v1 initWithStateProvider:v3 messageDelivery:v4 peerIDManager:v5 accountController:v6 serviceController:v7 queue:v8];
  id v10 = (void *)qword_100A4A260;
  qword_100A4A260 = (uint64_t)v9;
}

void sub_10002F1E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, void *a9)
{
  id v11 = a9;
  if (a6)
  {
    uint64_t v27 = a1;
    id v12 = objc_alloc_init((Class)NSMutableArray);
    long long v33 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    id v28 = v11;
    id v13 = v11;
    id v14 = [v13 countByEnumeratingWithState:&v33 objects:v38 count:16];
    if (v14)
    {
      id v15 = v14;
      uint64_t v16 = *(void *)v34;
      do
      {
        id v17 = 0;
        do
        {
          if (*(void *)v34 != v16) {
            objc_enumerationMutation(v13);
          }
          uint64_t v18 = *(void *)(*((void *)&v33 + 1) + 8 * (void)v17);
          long long v29 = 0u;
          long long v30 = 0u;
          long long v31 = 0u;
          long long v32 = 0u;
          __int16 v19 = objc_msgSend(v13, "objectForKeyedSubscript:", v18, v27);
          id v20 = [v19 countByEnumeratingWithState:&v29 objects:v37 count:16];
          if (v20)
          {
            id v21 = v20;
            uint64_t v22 = *(void *)v30;
            do
            {
              __int16 v23 = 0;
              do
              {
                if (*(void *)v30 != v22) {
                  objc_enumerationMutation(v19);
                }
                uint64_t v24 = [*(id *)(*((void *)&v29 + 1) + 8 * (void)v23) pushToken];
                [v12 addObject:v24];

                __int16 v23 = (char *)v23 + 1;
              }
              while (v21 != v23);
              id v21 = [v19 countByEnumeratingWithState:&v29 objects:v37 count:16];
            }
            while (v21);
          }

          id v17 = (char *)v17 + 1;
        }
        while (v17 != v15);
        id v15 = [v13 countByEnumeratingWithState:&v33 objects:v38 count:16];
      }
      while (v15);
    }

    [*(id *)(v27 + 32) _subscribeForInfo:*(void *)(v27 + 40) withDescription:*(void *)(v27 + 48) resolvedTokens:v12 withCompletion:*(void *)(v27 + 56)];
    id v11 = v28;
  }
  else
  {
    uint64_t v25 = *(void *)(a1 + 56);
    id v26 = +[NSError errorWithDomain:IDSActivityMonitorErrorDomain code:-201 userInfo:0];
    (*(void (**)(uint64_t, void *))(v25 + 16))(v25, v26);
  }
}

void sub_10002F5CC(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id v6 = [*(id *)(a1 + 32) stateProvider];
  uint64_t v7 = [v6 storedActivityTopics];
  id v8 = +[NSMutableSet setWithSet:v7];

  [v8 removeObject:*(void *)(a1 + 40)];
  id v9 = [*(id *)(a1 + 32) stateProvider];
  [v9 setStoredActivityTopics:v8];

  if (a3) {
    BOOL v10 = 0;
  }
  else {
    BOOL v10 = [v5 responseStatus] == 0;
  }
  id v11 = [*(id *)(a1 + 32) stateProvider];
  [v11 storeActivityDescription:0 forActivity:*(void *)(a1 + 40)];

  id v12 = [*(id *)(a1 + 32) stateProvider];
  [v12 removeSubscriptionForActivity:*(void *)(a1 + 40) subActivity:*(void *)(a1 + 48)];

  id v13 = [*(id *)(a1 + 32) stateProvider];
  unsigned __int8 v14 = [v13 hasActiveSubscription];

  if ((v14 & 1) == 0)
  {
    id v15 = +[IMRGLog registration];
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v19) = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "No active subscriptions, disabling presence on the server.", (uint8_t *)&v19, 2u);
    }

    [*(id *)(a1 + 32) stopListeningOnActivity:@"com.apple.icloud.presence"];
  }
  uint64_t v16 = +[IMRGLog registration];
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = *(void *)(a1 + 40);
    int v19 = 138412546;
    uint64_t v20 = v17;
    __int16 v21 = 1024;
    BOOL v22 = v10;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Activity unregister for activity topic %@ finished.  Success? %d", (uint8_t *)&v19, 0x12u);
  }

  if (v10)
  {
    uint64_t v18 = 0;
  }
  else
  {
    uint64_t v18 = +[NSError errorWithDomain:IDSActivityMonitorErrorDomain code:-300 userInfo:0];
  }
  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
}

void sub_10002FAA0(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v8 = a2;
  id v9 = a3;
  id v10 = a5;
  id v11 = v8;
  id v12 = v11;
  if (v9) {
    BOOL v13 = 0;
  }
  else {
    BOOL v13 = [v11 responseStatus] == 0;
  }
  unsigned __int8 v14 = [*(id *)(a1 + 32) stateProvider];
  uint64_t v15 = [v14 storedActivityTopics];
  uint64_t v16 = +[NSMutableSet setWithSet:v15];

  uint64_t v17 = [*(id *)(a1 + 40) activity];
  LOBYTE(v15) = [v16 containsObject:v17];

  if ((v15 & 1) == 0)
  {
    uint64_t v18 = [*(id *)(a1 + 40) activity];
    [v16 addObject:v18];

    int v19 = [*(id *)(a1 + 32) stateProvider];
    [v19 setStoredActivityTopics:v16];
  }
  if (v13)
  {
    uint64_t v20 = [*(id *)(a1 + 32) stateProvider];
    unsigned __int8 v21 = [v20 hasActiveSubscription];

    if ((v21 & 1) == 0)
    {
      BOOL v22 = +[IMRGLog registration];
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v32) = 0;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "The first subscription succeeded, enabling presence on the server.", (uint8_t *)&v32, 2u);
      }

      [*(id *)(a1 + 32) startListeningOnActivity:@"com.apple.icloud.presence"];
    }
    __int16 v23 = [*(id *)(a1 + 32) stateProvider];
    uint64_t v24 = *(void **)(a1 + 40);
    uint64_t v25 = [v24 activity];
    [v23 storeActivityDescription:v24 forActivity:v25];

    id v26 = [*(id *)(a1 + 32) stateProvider];
    uint64_t v27 = *(void *)(a1 + 48);
    id v28 = [*(id *)(a1 + 40) activity];
    [v26 storeSubscription:v27 forActivity:v28];
  }
  long long v29 = +[IMRGLog registration];
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    long long v30 = [*(id *)(a1 + 40) activity];
    int v32 = 138412546;
    long long v33 = v30;
    __int16 v34 = 1024;
    BOOL v35 = v13;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Activity register for activity topic %@ finished.  Success? %d", (uint8_t *)&v32, 0x12u);
  }
  if (v13)
  {
    long long v31 = 0;
  }
  else
  {
    long long v31 = +[NSError errorWithDomain:IDSActivityMonitorErrorDomain code:-300 userInfo:0];
  }
  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
}

id sub_10002FE84(id a1, id a2)
{
  id v2 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0
    && [v2 isEqualToString:@"com.apple.icloud.presence"])
  {
    id v3 = v2;
  }
  else
  {
    id v3 = +[NSString stringWithFormat:@"%@%@", @"com.apple.icloud.presence.", v2];
  }
  unsigned int v4 = v3;

  return v4;
}

void sub_100030B2C(id a1, unsigned int a2, NSObject *a3, BOOL *a4, BOOL *a5)
{
  if (objc_opt_respondsToSelector()) {
    [a3 invalidate];
  }
}

void sub_1000314F0(id a1)
{
  mach_timebase_info info = (mach_timebase_info)0xAAAAAAAAAAAAAAAALL;
  mach_timebase_info(&info);
  LODWORD(v2) = info.denom;
  LODWORD(v1) = info.numer;
  *(double *)&qword_100A4A278 = (double)v1 / (double)v2 / 1000000000.0;
}

void sub_100031728(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
}

void sub_10003183C(_Unwind_Exception *a1)
{
  os_activity_scope_leave((os_activity_scope_state_t)(v1 - 40));
  cut_arc_os_release();
  _Unwind_Resume(a1);
}

void sub_10003185C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v9 = v5;
  if (a3)
  {
    uint64_t v6 = *(void *)(a1 + 40);
    uint64_t v7 = sub_100031930(a3);
    (*(void (**)(uint64_t, id, void *))(v6 + 16))(v6, v9, v7);
LABEL_3:

    goto LABEL_6;
  }
  if (!v5)
  {
    uint64_t v8 = *(void *)(a1 + 40);
    uint64_t v7 = +[NSError errorWithDomain:@"Engram Error" code:65543 userInfo:0];
    (*(void (**)(uint64_t, void, void *))(v8 + 16))(v8, 0, v7);
    goto LABEL_3;
  }
  [*(id *)(a1 + 32) _rollAccountKeyWithFullCluster:v5 completion:*(void *)(a1 + 40)];
LABEL_6:
}

id sub_100031930(void *a1)
{
  if (a1)
  {
    a1 = +[NSError errorWithDomain:@"Engram Error" code:a1 userInfo:0];
    uint64_t v1 = vars8;
  }
  return a1;
}

void sub_100031A3C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  uint64_t v6 = v5;
  if (!a3)
  {
    if (v5)
    {
      id v10 = [v5 groupID];
      if (!v10) {
        sub_100709758();
      }

      id v11 = [v6 groupID];

      if (!v11)
      {
        uint64_t v15 = +[IDSFoundationLog accountIdentity];
        if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT)) {
          sub_100709784((uint64_t)v6, v15);
        }

        uint64_t v7 = *(void *)(a1 + 48);
        uint64_t v8 = +[NSError errorWithDomain:@"Engram Error" code:262145 userInfo:0];
        goto LABEL_3;
      }
      uint64_t v12 = IDSMPServiceIdentityTypeForName();
      id v9 = [v6 adminServiceIdentityWithType:v12];
      uint64_t v13 = [v6 signingServiceIdentityWithType:v12];
      if (v13)
      {
        id v14 = (id)v13;
        (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
LABEL_28:

        goto LABEL_29;
      }

      id v9 = objc_alloc_init((Class)NSMutableArray);
      long long v27 = 0u;
      long long v28 = 0u;
      long long v29 = 0u;
      long long v30 = 0u;
      uint64_t v16 = [v6 fullServiceIdentitiesSigning];
      id v17 = [v16 countByEnumeratingWithState:&v27 objects:v31 count:16];
      if (v17)
      {
        id v18 = v17;
        uint64_t v19 = *(void *)v28;
        do
        {
          for (i = 0; i != v18; i = (char *)i + 1)
          {
            if (*(void *)v28 != v19) {
              objc_enumerationMutation(v16);
            }
            unsigned __int8 v21 = [*(id *)(*((void *)&v27 + 1) + 8 * i) identityServiceTypeName];
            [v9 addObject:v21];
          }
          id v18 = [v16 countByEnumeratingWithState:&v27 objects:v31 count:16];
        }
        while (v18);
      }
    }
    else
    {
      id v9 = objc_alloc_init((Class)NSMutableArray);
    }
    id v14 = [v9 mutableCopy];
    if ([v14 containsObject:*(void *)(a1 + 32)]) {
      sub_10070972C();
    }
    if (([v14 containsObject:*(void *)(a1 + 32)] & 1) == 0) {
      [v14 addObject:*(void *)(a1 + 32)];
    }
    if (v6)
    {
      BOOL v22 = [v6 fullAccountIdentity];
    }
    else
    {
      BOOL v22 = 0;
    }
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 3221225472;
    v24[2] = sub_100031DA0;
    v24[3] = &unk_10097EBE8;
    __int16 v23 = *(void **)(a1 + 40);
    id v26 = *(id *)(a1 + 48);
    id v25 = *(id *)(a1 + 32);
    [v23 _createAccountKeysWithFullAccountIdentity:v22 serviceTypeNames:v14 oldCluster:v6 completion:v24];

    goto LABEL_28;
  }
  uint64_t v7 = *(void *)(a1 + 48);
  uint64_t v8 = sub_100031930(a3);
LABEL_3:
  id v9 = (id)v8;
  (*(void (**)(uint64_t, void, void, void, uint64_t))(v7 + 16))(v7, 0, 0, 0, v8);
LABEL_29:
}

void sub_100031DA0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v13 = v5;
  if (a3)
  {
    uint64_t v6 = *(void *)(a1 + 40);
    uint64_t v7 = sub_100031930(a3);
LABEL_3:
    uint64_t v8 = (void *)v7;
    (*(void (**)(uint64_t, void, void, void, uint64_t))(v6 + 16))(v6, 0, 0, 0, v7);
    goto LABEL_7;
  }
  id v9 = [v5 groupID];
  if (!v9) {
    sub_1007097FC();
  }

  id v10 = [v13 groupID];

  if (!v10)
  {
    uint64_t v6 = *(void *)(a1 + 40);
    uint64_t v7 = +[NSError errorWithDomain:@"Engram Error" code:262145 userInfo:0];
    goto LABEL_3;
  }
  uint64_t v11 = IDSMPServiceIdentityTypeForName();
  uint64_t v8 = [v13 adminServiceIdentityWithType:v11];
  uint64_t v12 = [v13 signingServiceIdentityWithType:v11];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();

LABEL_7:
}

void sub_100031F94(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = [v5 groupName];
  if (v7)
  {
    uint64_t v8 = [*(id *)(a1 + 32) keychainElectionStore];
    id v19 = 0;
    id v9 = [v8 fetchFullClusterWithIdentifier:v7 error:&v19];
    id v10 = v19;

    if (v9)
    {
      uint64_t v11 = [v9 groupID];

      if (v11)
      {
        id v12 = v10;
        id v13 = v9;
      }
      else
      {
        uint64_t v15 = [v5 groupID];
        id v18 = v10;
        id v13 = [v9 clusterByUpdatingGroupID:v15 error:&v18];
        id v12 = v18;

        if (!v13)
        {
          uint64_t v16 = +[IDSFoundationLog accountIdentity];
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            id v17 = [v5 groupID];
            *(_DWORD *)buf = 138543874;
            unsigned __int8 v21 = 0;
            __int16 v22 = 2114;
            id v23 = v17;
            __int16 v24 = 2114;
            id v25 = v12;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Failed to update groupID {accountIdentityCluster: %{public}@, groupID: %{public}@, error: %{public}@}", buf, 0x20u);
          }
        }
      }
      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();

      id v10 = v12;
    }
    else
    {
      id v14 = +[IDSFoundationLog accountIdentity];
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138543618;
        unsigned __int8 v21 = v7;
        __int16 v22 = 2114;
        id v23 = v10;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Failed to get fullClusterFromKeychain {accountGroupkey: %{public}@, error: %{public}@}", buf, 0x16u);
      }

      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    }
  }
  else
  {
    +[IDSCloudKitKeyElectionStore isItemNotFoundError:v6];
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

void sub_100032454(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (a3)
  {
    sub_100031930(a3);
    id v6 = (id)objc_claimAutoreleasedReturnValue();
    (*(void (**)(uint64_t, void, id))(v3 + 16))(v3, 0, v6);
  }
  else
  {
    unsigned int v4 = *(void (**)(uint64_t))(v3 + 16);
    uint64_t v5 = *(void *)(a1 + 32);
    v4(v5);
  }
}

void sub_100033280(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,os_activity_scope_state_s state,char a61)
{
}

void sub_100033350(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (!v6
    || (+[IDSCloudKitKeyElectionStore isItemNotFoundError:v6] & 1) != 0)
  {
    uint64_t v7 = +[IDSFoundationLog accountIdentity];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 138477827;
      id v31 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "Fetched CloudKit account -- Continue {fetchedCloudKitItem: %{private}@}", buf, 0xCu);
    }

    uint64_t v8 = [v5 groupName];
    id v9 = [v5 groupID];
    if (v9 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
    {
      uint64_t v15 = +[IDSFoundationLog accountIdentity];
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138477827;
        id v31 = v5;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Unexpected existingGroupID class -- Fail {fetchedCloudKitItem: %{private}@}", buf, 0xCu);
      }
    }
    else
    {
      if (!v8 || ([v8 isEqualToString:*(void *)(a1 + 48)] & 1) != 0)
      {
        id v10 = [*(id *)(a1 + 32) keychainElectionStore];
        uint64_t v11 = *(void **)(a1 + 40);
        v17[0] = _NSConcreteStackBlock;
        v17[1] = 3221225472;
        v17[2] = sub_100033768;
        v17[3] = &unk_10097ECD8;
        id v12 = v11;
        uint64_t v13 = *(void *)(a1 + 32);
        id v18 = v12;
        uint64_t v19 = v13;
        id v28 = *(id *)(a1 + 120);
        id v20 = *(id *)(a1 + 56);
        id v21 = *(id *)(a1 + 64);
        id v22 = *(id *)(a1 + 72);
        id v23 = *(id *)(a1 + 80);
        long long v29 = *(_OWORD *)(a1 + 128);
        id v24 = *(id *)(a1 + 88);
        id v25 = *(id *)(a1 + 96);
        id v26 = *(id *)(a1 + 104);
        id v27 = *(id *)(a1 + 112);
        [v10 storeFullCluster:v12 completion:v17];

LABEL_19:
        goto LABEL_20;
      }
      uint64_t v15 = +[IDSFoundationLog accountIdentity];
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v16 = *(void *)(a1 + 48);
        *(_DWORD *)buf = 138543618;
        id v31 = v8;
        __int16 v32 = 2114;
        uint64_t v33 = v16;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "recordName mismatch -- Fail {recordName: %{public}@, existingIdentityGroupName: %{public}@}", buf, 0x16u);
      }
    }

    [*(id *)(a1 + 32) _cleanupFailedElectionWithFullAccountIdentityCluster:*(void *)(a1 + 40)];
    (*(void (**)(void))(*(void *)(a1 + 120) + 16))();
    goto LABEL_19;
  }
  id v14 = +[IDSFoundationLog accountIdentity];
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138543362;
    id v31 = v6;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Failed to fetch item from CloudKit -- Fail {fetchError: %{public}@}", buf, 0xCu);
  }

  [*(id *)(a1 + 32) _cleanupFailedElectionWithFullAccountIdentityCluster:*(void *)(a1 + 40)];
  (*(void (**)(void))(*(void *)(a1 + 120) + 16))();
LABEL_20:
}

void sub_100033768(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = +[IDSFoundationLog accountIdentity];
  uint64_t v8 = v7;
  if (v6)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138543618;
      id v22 = v6;
      __int16 v23 = 2114;
      uint64_t v24 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Failed to store cluster in keychain -- Fail {storeError: %{public}@, newCluster: %{public}@}", buf, 0x16u);
    }

    [*(id *)(a1 + 40) _cleanupFailedElectionWithFullAccountIdentityCluster:*(void *)(a1 + 32)];
    (*(void (**)(void))(*(void *)(a1 + 112) + 16))();
  }
  else
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "Stored cluster in Keychain", buf, 2u);
    }

    id v10 = objc_alloc_init(IDSGroupServerKeyElectionStoreItem);
    [(IDSGroupServerKeyElectionStoreItem *)v10 setAccountBlob:*(void *)(a1 + 48)];
    [(IDSGroupServerKeyElectionStoreItem *)v10 setSignature:*(void *)(a1 + 56)];
    [(IDSGroupServerKeyElectionStoreItem *)v10 setGroupID:*(void *)(a1 + 64)];
    [(IDSGroupServerKeyElectionStoreItem *)v10 setForwardingTicket:*(void *)(a1 + 72)];
    [(IDSGroupServerKeyElectionStoreItem *)v10 setParentPg:*(void *)(a1 + 120)];
    [(IDSGroupServerKeyElectionStoreItem *)v10 setNewPg:*(void *)(a1 + 128)];
    [(IDSGroupServerKeyElectionStoreItem *)v10 setParentVersion:*(void *)(a1 + 80)];
    [(IDSGroupServerKeyElectionStoreItem *)v10 setENID:*(void *)(a1 + 88)];
    uint64_t v11 = [*(id *)(a1 + 40) groupServerElectionStore];
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472;
    v15[2] = sub_100033A00;
    v15[3] = &unk_10097ECB0;
    uint64_t v16 = v10;
    int8x16_t v14 = *(int8x16_t *)(a1 + 32);
    id v12 = (id)v14.i64[0];
    int8x16_t v17 = vextq_s8(v14, v14, 8uLL);
    id v20 = *(id *)(a1 + 112);
    id v18 = *(id *)(a1 + 96);
    id v19 = *(id *)(a1 + 104);
    uint64_t v13 = v10;
    [v11 storeItem:v13 withCompletion:v15];
  }
}

void sub_100033A00(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = +[IDSFoundationLog accountIdentity];
  uint64_t v11 = v10;
  if (v9)
  {
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      id v12 = *(void **)(a1 + 32);
      *(_DWORD *)buf = 138543618;
      id v26 = v12;
      __int16 v27 = 2114;
      id v28 = v9;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Failed to store in group server {groupServerItem: %{public}@, groupServerError: %{public}@", buf, 0x16u);
    }

    uint64_t v13 = [v9 domain];
    if ([v13 isEqualToString:off_100A444A8]) {
      [v9 code];
    }

    [*(id *)(a1 + 40) _cleanupFailedElectionWithFullAccountIdentityCluster:*(void *)(a1 + 48)];
    (*(void (**)(void))(*(void *)(a1 + 72) + 16))();
  }
  else
  {
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      int8x16_t v14 = *(void **)(a1 + 32);
      *(_DWORD *)buf = 138543362;
      id v26 = v14;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "Stored cluster in GroupServer {groupServerItem: %{public}@}", buf, 0xCu);
    }

    uint64_t v15 = +[IDSFoundationLog accountIdentity];
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      id v26 = v8;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "!setState groupServerGroupID=%@", buf, 0xCu);
    }

    id v16 = objc_alloc_init((Class)IDSCloudKitKeyElectionStoreItem);
    [v16 setGroupName:*(void *)(a1 + 56)];
    [v16 setGroupID:v8];
    int8x16_t v17 = [*(id *)(a1 + 40) cloudKitElectionStore];
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 3221225472;
    v19[2] = sub_100033D18;
    v19[3] = &unk_10097EC88;
    id v20 = v16;
    id v24 = *(id *)(a1 + 72);
    id v21 = *(id *)(a1 + 48);
    id v22 = *(id *)(a1 + 64);
    id v23 = v8;
    id v18 = v16;
    [v17 storeAccountIdentityItem:v18 withCompletion:v19];
  }
}

void sub_100033D18(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    id v7 = +[IDSFoundationLog accountIdentity];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      id v8 = *(void **)(a1 + 32);
      int v15 = 138543618;
      id v16 = v8;
      __int16 v17 = 2114;
      id v18 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Failed to save identityItem to CloudKit -- Fail {cloudKitItem: %{public}@, cloudKitSetError: %{public}@}", (uint8_t *)&v15, 0x16u);
    }

    (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
  }
  else
  {
    id v9 = *(id *)(a1 + 40);
    if (!*(void *)(a1 + 48))
    {
      id v10 = +[IDSFoundationLog accountIdentity];
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        uint64_t v11 = *(void **)(a1 + 40);
        id v12 = *(void **)(a1 + 56);
        int v15 = 138543618;
        id v16 = v11;
        __int16 v17 = 2114;
        id v18 = v12;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "Updating newCluster groupID {newCluster: %{public}@, groupID: %{public}@}", (uint8_t *)&v15, 0x16u);
      }

      uint64_t v13 = [*(id *)(a1 + 40) clusterByUpdatingGroupID:*(void *)(a1 + 56) error:0];

      id v9 = (id)v13;
    }
    int8x16_t v14 = +[IDSFoundationLog accountIdentity];
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      int v15 = 138543362;
      id v16 = v9;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "Stored Cluster in CloudKit -- Done {cluster: %{public}@}", (uint8_t *)&v15, 0xCu);
    }

    (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
  }
}

void sub_10003464C(id a1)
{
  qword_100A4A288 = objc_alloc_init(IDSRegistrationKeyManager);

  _objc_release_x1();
}

void sub_1000346CC(id a1)
{
  id v1 = +[IDSRegistrationKeyManager sharedInstance];
  [v1 _loadIfNeeded:1];
}

void sub_100038074(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 224), 8);
  _Unwind_Resume(a1);
}

id sub_1000381B0(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _generateKTRegistrationData:*(void *)(a1 + 40)];
}

uint64_t sub_1000381BC(uint64_t result)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  return result;
}

void sub_10003A330(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v3 = +[IMRGLog registration];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unsigned int v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "IDSRegistrationKeyManager notified of time change", v4, 2u);
    }

    [a2 _retryGenerationIfNeeded];
  }
}

id sub_10003A608(uint64_t a1)
{
  return [*(id *)(a1 + 32) _retryGenerationIfNeeded];
}

void sub_10003AFCC(uint64_t a1)
{
  [*(id *)(*(void *)(a1 + 32) + 8) lock];
  unint64_t v2 = [*(id *)(a1 + 32) config];
  uint64_t v3 = [v2 unregisteredIdentityContainer];
  if (v3)
  {

    [*(id *)(*(void *)(a1 + 32) + 8) unlock];
LABEL_4:
    id v5 = +[IMRGLog registration];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Posting notification of identity regeneration", buf, 2u);
    }

    id v6 = +[NSNotificationCenter defaultCenter];
    [v6 __mainThreadPostNotificationName:@"__kIDSRegistrationKeyManagerPrivateIdentityGeneratedNotification" object:*(void *)(a1 + 32)];
    goto LABEL_7;
  }
  unsigned __int8 v4 = [*(id *)(*(void *)(a1 + 32) + 80) hasUnregisteredIdentity];

  [*(id *)(*(void *)(a1 + 32) + 8) unlock];
  if (v4) {
    goto LABEL_4;
  }
  id v6 = +[IMRGLog registration];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Skipping notification of identity regeneration; we've already done it",
      v7,
      2u);
  }
LABEL_7:
}

void sub_10003B2C0(uint64_t a1)
{
  if (([*(id *)(a1 + 32) _shouldCheckUnregisteredKTData] & 1) == 0)
  {
    uint64_t v3 = +[IMRGLog registration];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      id v5 = buf;
      goto LABEL_7;
    }
LABEL_8:

    uint64_t v3 = +[NSNotificationCenter defaultCenter];
    [v3 __mainThreadPostNotificationName:IDSRegistrationKeyManagerKTRegDataUpdatedNotification object:*(void *)(a1 + 32)];
    goto LABEL_9;
  }
  [*(id *)(*(void *)(a1 + 32) + 8) lock];
  unsigned int v2 = [*(id *)(*(void *)(a1 + 32) + 120) hasUnregisteredKTData];
  [*(id *)(*(void *)(a1 + 32) + 8) unlock];
  uint64_t v3 = +[IMRGLog registration];
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      __int16 v7 = 0;
      id v5 = (uint8_t *)&v7;
LABEL_7:
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Posting notification of unregistered KT data", v5, 2u);
      goto LABEL_8;
    }
    goto LABEL_8;
  }
  if (v4)
  {
    *(_WORD *)id v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Skipping notification of unregistered KT data; we've already done it",
      v6,
      2u);
  }
LABEL_9:
}

id sub_10003CFA8(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _generateKTRegistrationData:*(void *)(a1 + 40)];
}

void sub_10003D8D8(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 40) && !*(unsigned char *)(a1 + 41) && !*(unsigned char *)(a1 + 42)) {
    return;
  }
  uint64_t v2 = [*(id *)(a1 + 32) publicMessageProtectionDataToRegisterForClassA];
  if (!v2) {
    return;
  }
  id v17 = (id)v2;
  uint64_t v3 = [*(id *)(a1 + 32) publicMessageProtectionDataToRegisterForClassC];
  if (v3)
  {
    BOOL v4 = (void *)v3;
    uint64_t v5 = [*(id *)(a1 + 32) publicMessageProtectionDataToRegisterForClassD];
    if (v5)
    {
      id v6 = (void *)v5;
      __int16 v7 = +[IDSPairingManager sharedInstance];
      uint64_t v8 = [v7 pairedDevicePublicKey];
      if (v8)
      {
        id v9 = (void *)v8;
        id v10 = +[IDSPairingManager sharedInstance];
        uint64_t v11 = [v10 pairedDevicePublicClassAKey];
        if (v11)
        {
          id v12 = (void *)v11;
          uint64_t v13 = +[IDSPairingManager sharedInstance];
          int8x16_t v14 = [v13 pairedDevicePublicClassCKey];

          if (v14)
          {
            int v15 = OSLogHandleForTransportCategory();
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "We saved our keys, resuming OTR session negotiation", buf, 2u);
            }

            if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
            {
              _IDSLogTransport();
              if (_IDSShouldLog()) {
                _IDSLogV();
              }
            }
            id v16 = +[IDSOTRController sharedInstance];
            [v16 resumeSessionNegotiation];
          }
          return;
        }
      }
    }
  }
}

void sub_10003F110(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 40);
  uint64_t v3 = +[IMRGLog registration];
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      LOWORD(v12) = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Already scheduled timer for purge of previous identity", (uint8_t *)&v12, 2u);
    }
  }
  else
  {
    if (v4)
    {
      uint64_t v5 = *(void *)(a1 + 40);
      int v12 = 134217984;
      uint64_t v13 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Scheduling timer for purge of previous identity {delay: %f}", (uint8_t *)&v12, 0xCu);
    }

    id v6 = objc_alloc((Class)IMTimer);
    double v7 = *(double *)(a1 + 40);
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v3 = im_primary_queue();
    id v9 = [v6 initWithTimeInterval:@"com.apple.identityservicesd.identity-purge" name:0 shouldWake:v8 target:"_purgePreviousIdentityTimerFired" selector:0 userInfo:v3 queue:v7];
    uint64_t v10 = *(void *)(a1 + 32);
    uint64_t v11 = *(void **)(v10 + 40);
    *(void *)(v10 + 40) = v9;
  }
}

id sub_10003F304(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _purgePreviousIdentityTimerFired];
}

void sub_10003F3F4(uint64_t a1)
{
  [*(id *)(*(void *)(a1 + 32) + 40) invalidate];
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void **)(v2 + 40);
  *(void *)(v2 + 40) = 0;
}

void sub_10003F4D4(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 48);
  uint64_t v3 = +[IMRGLog registration];
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      LOWORD(v12) = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Already scheduled timer for purge of previous identity", (uint8_t *)&v12, 2u);
    }
  }
  else
  {
    if (v4)
    {
      uint64_t v5 = *(void *)(a1 + 40);
      int v12 = 134217984;
      uint64_t v13 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Scheduling timer for regneration of registered identity {delay: %f}", (uint8_t *)&v12, 0xCu);
    }

    id v6 = objc_alloc((Class)IMTimer);
    double v7 = *(double *)(a1 + 40);
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v3 = im_primary_queue();
    id v9 = [v6 initWithTimeInterval:@"com.apple.identityservicesd.identity-regenerate" name:0 shouldWake:v8 target:"_regenerateIdentityTimerFired" selector:0 userInfo:v3 queue:v7];
    uint64_t v10 = *(void *)(a1 + 32);
    uint64_t v11 = *(void **)(v10 + 48);
    *(void *)(v10 + 48) = v9;
  }
}

id sub_10003F6C8(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _regenerateIdentityTimerFired];
}

void sub_10003F818(uint64_t a1)
{
  [*(id *)(*(void *)(a1 + 32) + 48) invalidate];
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void **)(v2 + 48);
  *(void *)(v2 + 48) = 0;
}

void sub_1000400D4(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x16u);
}

void sub_100040124(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

void sub_10004014C(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x16u);
}

void sub_100040170(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, a5, 0xCu);
}

void sub_100040188(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 2u);
}

void sub_1000401B0(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void sub_1000401D0(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_fault_impl(a1, log, OS_LOG_TYPE_FAULT, a4, (uint8_t *)va, 0x16u);
}

uint64_t sub_100040210(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t sub_100040228(uint64_t result, uint64_t a2, float a3)
{
  *(float *)a2 = a3;
  *(void *)(a2 + 4) = result;
  return result;
}

void sub_100040250(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x20u);
}

void sub_1000405E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100040608(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100040618(uint64_t a1)
{
}

void sub_100040620(uint64_t a1)
{
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40))
  {
    uint64_t v2 = (void **)IMWeakLinkSymbol();
    if (v2) {
      uint64_t v3 = *v2;
    }
    else {
      uint64_t v3 = 0;
    }
    uint64_t v4 = (id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
    objc_storeStrong(v4, v3);
  }
}

void *sub_1000407D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43)
{
  id v43 = a43;
  pthread_once(&stru_100A406C0, (void (*)(void))sub_100046068);
  uint64_t Instance = _CFRuntimeCreateInstance();
  v45 = (void *)Instance;
  if (Instance)
  {
    *(void *)(Instance + 16) = 0;
    *(void *)(Instance + 24) = 0;
    *(_DWORD *)(Instance + 16) = 0;
    id v46 = v43;
    if (_IMWillLog()) {
      _IMAlwaysLog();
    }
    [v46 ensureDatabaseIsInitialized];
    id v47 = (const void *)CSDBRecordCreate();

    if (v47)
    {
      id v50 = v43;
      for (uint64_t i = 0; i != 54; ++i)
      {
        if (_IMWillLog()) {
          _IMAlwaysLog();
        }
        CSDBRecordSetProperty();
      }
      if (sub_100040B40((uint64_t)v47, v46))
      {
        v45[3] = (int)CSDBRecordGetID();
        id v43 = v50;
        if (_IMWillLog()) {
          _IMAlwaysLog();
        }
      }
      else
      {
        CFRelease(v45);
        v45 = 0;
        id v43 = v50;
      }
      CFRelease(v47);
    }
    else
    {
      CFRelease(v45);
      v45 = 0;
    }
  }

  return v45;
}

uint64_t sub_100040B40(uint64_t a1, void *a2)
{
  uint64_t v9 = 0;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2020000000;
  char v12 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_100040CD4;
  v5[3] = &unk_10097EE00;
  double v7 = &v9;
  uint64_t v8 = a1;
  id v2 = a2;
  id v6 = v2;
  sub_1003E5B1C(v5, v2);
  uint64_t v3 = *((unsigned __int8 *)v10 + 24);

  _Block_object_dispose(&v9, 8);
  return v3;
}

void sub_100040C08(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

const void *sub_100040C20(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  id v6 = a4;
  pthread_once(&stru_100A406C0, (void (*)(void))sub_100046068);
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v8 = (const void *)Instance;
    *(void *)(Instance + 16) = 0;
    *(void *)(Instance + 24) = a2;
    *(_DWORD *)(Instance + 16) = 0;
    if (a3) {
      uint64_t v9 = (const void *)sub_100040DA4(a2, v6);
    }
    else {
      uint64_t v9 = (const void *)sub_100040EB8(a2, v6);
    }
    if (v9)
    {
      uint64_t v10 = v8;
    }
    else
    {
      uint64_t v9 = v8;
      uint64_t v10 = 0;
    }
    CFRelease(v9);
  }
  else
  {
    uint64_t v10 = 0;
  }

  return v10;
}

void sub_100040CD4(uint64_t a1)
{
  if (*(void *)(a1 + 48))
  {
    CSDBRecordStoreAddRecord();
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = CSDBRecordSaveStore();
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
    {
      if (CSDBRecordStoreGetDatabase())
      {
        if (_IMWillLog()) {
          _IMAlwaysLog();
        }
        int ID = CSDBRecordGetID();
        uint64_t v3 = sub_100040C20((uint64_t)kCFAllocatorDefault, ID, 0, *(void **)(a1 + 32));
        if (v3)
        {
          CFRelease(v3);
        }
      }
    }
  }
}

uint64_t sub_100040DA4(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2020000000;
  uint64_t v10 = 0;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100040E74;
  v6[3] = &unk_10097EEC8;
  void v6[4] = &v7;
  v6[5] = a1;
  sub_1003E5B1C(v6, v3);
  uint64_t v4 = v8[3];
  _Block_object_dispose(&v7, 8);

  return v4;
}

void sub_100040E5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100040E74(uint64_t a1)
{
  uint64_t result = CSDBRecordStoreCopyInstanceOfClassWithUID();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t sub_100040EB8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2020000000;
  uint64_t v10 = 0;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100040F88;
  v6[3] = &unk_10097EEC8;
  void v6[4] = &v7;
  v6[5] = a1;
  sub_1003E5B94(v6, v3);
  uint64_t v4 = v8[3];
  _Block_object_dispose(&v7, 8);

  return v4;
}

void sub_100040F70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100040F88(uint64_t a1)
{
  uint64_t result = CSDBRecordStoreCopyInstanceOfClassWithUID();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

BOOL sub_100040FCC(const __CFString *a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (a1 && CFStringGetLength(a1))
  {
    if (a2) {
      CFStringRef v6 = @"SELECT COUNT(1) FROM outgoing_message WHERE guid = ? AND alternate_guid = ? AND pending_delete = 0 LIMIT 1;";
    }
    else {
      CFStringRef v6 = @"SELECT COUNT(1) FROM outgoing_message WHERE guid = ? AND pending_delete = 0 LIMIT 1;";
    }
    uint64_t v10 = 0;
    uint64_t v11 = &v10;
    uint64_t v12 = 0x2020000000;
    char v13 = 0;
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_1000410E4;
    v9[3] = &unk_10097EEF0;
    v9[5] = a1;
    v9[6] = a2;
    v9[4] = &v10;
    sub_1003E5C84((uint64_t)v6, v9, v5);
    BOOL v7 = *((unsigned char *)v11 + 24) != 0;
    _Block_object_dispose(&v10, 8);
  }
  else
  {
    BOOL v7 = 0;
  }

  return v7;
}

void sub_1000410CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000410E4(uint64_t a1)
{
  CSDBSqliteBindTextFromCFString();
  if (*(void *)(a1 + 48)) {
    CSDBSqliteBindTextFromCFString();
  }
  uint64_t result = CSDBSqliteStep();
  if (result)
  {
    uint64_t result = CSDBSqliteStatementInteger64ResultColumn();
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result > 0;
  }
  return result;
}

uint64_t sub_100041150()
{
  return 0;
}

uint64_t sub_100041158(uint64_t a1, uint64_t a2, char a3, void *a4, void *a5)
{
  id v9 = a4;
  uint64_t v19 = 0;
  id v20 = &v19;
  uint64_t v21 = 0x2020000000;
  uint64_t v22 = 0;
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_100041264;
  v13[3] = &unk_10097EF18;
  char v18 = a3;
  id v10 = a5;
  uint64_t v16 = a2;
  uint64_t v17 = a1;
  id v14 = v10;
  int v15 = &v19;
  sub_1003E5C0C(v13, v9);
  uint64_t v11 = v20[3];

  _Block_object_dispose(&v19, 8);
  return v11;
}

void sub_10004124C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100041264(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  CFStringAppend(Mutable, @"SELECT DISTINCT account_guid FROM outgoing_message WHERE priority = ? AND is_sent = 0 AND pending_delete = 0 ");
  if (*(unsigned char *)(a1 + 64)) {
    CFStringAppend(Mutable, @"AND duet_identifiers IS NOT NULL ");
  }
  if ([*(id *)(a1 + 32) count])
  {
    CFStringAppend(Mutable, @"AND message_type ");
    [*(id *)(a1 + 32) count];
    CFStringRef v3 = (const __CFString *)CSDBGenerateInClauseForCount();
    CFStringAppend(Mutable, v3);
  }
  CFStringAppend(Mutable, @"LIMIT ?");
  uint64_t v4 = CSDBSqliteDatabaseStatementForReading();
  if (v4 && *(void *)(v4 + 8))
  {
    CSDBSqliteBindInt64();
    if ([*(id *)(a1 + 32) count])
    {
      long long v15 = 0u;
      long long v16 = 0u;
      long long v13 = 0u;
      long long v14 = 0u;
      id v5 = *(id *)(a1 + 32);
      id v6 = [v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
      if (v6)
      {
        id v7 = v6;
        uint64_t v8 = *(void *)v14;
        do
        {
          for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v14 != v8) {
              objc_enumerationMutation(v5);
            }
            objc_msgSend(*(id *)(*((void *)&v13 + 1) + 8 * i), "longLongValue", (void)v13);
            CSDBSqliteBindInt64();
          }
          id v7 = [v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
        }
        while (v7);
      }
    }
    CSDBSqliteBindInt64();
    while (1)
    {
      uint64_t v10 = CSDBSqliteStatementCopyStringResult();
      if (!v10) {
        break;
      }
      uint64_t v11 = (const void *)v10;
      uint64_t v12 = *(__CFArray **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
      if (!v12)
      {
        *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
        uint64_t v12 = *(__CFArray **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
      }
      CFArrayAppendValue(v12, v11);
      CFRelease(v11);
    }
    CSDBSqliteStatementReset();
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
}

uint64_t sub_1000414A4(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  uint64_t v9 = 0;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2020000000;
  uint64_t v12 = 0;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_100041584;
  v8[3] = &unk_10097EF40;
  v8[5] = a2;
  v8[6] = a1;
  v8[4] = &v9;
  sub_1003E5C0C(v8, v5);
  uint64_t v6 = v10[3];
  _Block_object_dispose(&v9, 8);

  return v6;
}

void sub_10004156C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100041584(uint64_t a1)
{
  uint64_t result = CSDBSqliteDatabaseStatementForReading();
  if (result && *(void *)(result + 8))
  {
    CSDBSqliteBindInt64();
    if (*(void *)(a1 + 48)) {
      CSDBSqliteBindTextFromCFString();
    }
    while (1)
    {
      uint64_t v3 = CSDBSqliteStatementCopyDataResult();
      if (!v3) {
        break;
      }
      uint64_t v4 = (const void *)v3;
      id v5 = *(__CFArray **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      if (!v5)
      {
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
        id v5 = *(__CFArray **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      }
      CFArrayAppendValue(v5, v4);
      CFRelease(v4);
    }
    return CSDBSqliteStatementReset();
  }
  return result;
}

uint64_t sub_100041678(void *a1)
{
  id v1 = a1;
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000;
  uint64_t v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_100041744;
  v4[3] = &unk_10097EF68;
  v4[4] = &v5;
  sub_1003E5C0C(v4, v1);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);

  return v2;
}

void sub_10004172C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100041744(uint64_t a1)
{
  uint64_t result = CSDBSqliteDatabaseStatementForReading();
  if (result && *(void *)(result + 8))
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CSDBSqliteStatementInteger64Result();
    return CSDBSqliteStatementReset();
  }
  return result;
}

uint64_t sub_1000417BC(void *a1)
{
  id v1 = a1;
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000;
  uint64_t v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_100041888;
  v4[3] = &unk_10097EF68;
  v4[4] = &v5;
  sub_1003E5C0C(v4, v1);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);

  return v2;
}

void sub_100041870(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100041888(uint64_t a1)
{
  uint64_t result = CSDBSqliteDatabaseStatementForReading();
  if (result && *(void *)(result + 8))
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CSDBSqliteStatementCopyAllRowsStringsForColumnsAtIndices();
    return CSDBSqliteStatementReset();
  }
  return result;
}

uint64_t sub_100041904(void *a1)
{
  id v1 = a1;
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000;
  uint64_t v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_1000419D0;
  v4[3] = &unk_10097EF68;
  v4[4] = &v5;
  sub_1003E5C0C(v4, v1);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);

  return v2;
}

void sub_1000419B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000419D0(uint64_t a1)
{
  uint64_t result = CSDBSqliteDatabaseStatementForReading();
  if (result && *(void *)(result + 8))
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CSDBSqliteStatementCopyStringsForColumnsAtIndices();
    return CSDBSqliteStatementReset();
  }
  return result;
}

uint64_t sub_100041A4C(void *a1)
{
  id v1 = a1;
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000;
  uint64_t v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_100041B18;
  v4[3] = &unk_10097EF68;
  v4[4] = &v5;
  sub_1003E5C0C(v4, v1);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);

  return v2;
}

void sub_100041B00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100041B18(uint64_t a1)
{
  uint64_t result = CSDBSqliteDatabaseStatementForReading();
  if (result && *(void *)(result + 8))
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CSDBSqliteStatementCopyStringsForColumnsAtIndices();
    return CSDBSqliteStatementReset();
  }
  return result;
}

__CFArray *sub_100041B94(const __CFArray *a1, void *a2)
{
  id v3 = a2;
  CFIndex Count = CFArrayGetCount(a1);
  CFMutableDictionaryRef Mutable = 0;
  if (Count << 32)
  {
    CFIndex v6 = 0;
    CFIndex v7 = (int)Count;
    if ((unint64_t)(int)Count <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = (int)Count;
    }
    while (1)
    {
      CFArrayGetValueAtIndex(a1, v6);
      int ID = CSDBRecordGetID();
      uint64_t v10 = sub_100040C20((uint64_t)kCFAllocatorDefault, ID, 0, v3);
      uint64_t v11 = v10;
      if (!Mutable) {
        break;
      }
      if (v10) {
        goto LABEL_7;
      }
LABEL_8:
      if (v8 == ++v6) {
        goto LABEL_12;
      }
    }
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, v7, &kCFTypeArrayCallBacks);
    if (!v11) {
      goto LABEL_8;
    }
LABEL_7:
    CFArrayAppendValue(Mutable, v11);
    CFRelease(v11);
    goto LABEL_8;
  }
LABEL_12:

  return Mutable;
}

uint64_t sub_100041C8C(uint64_t a1, void *a2, char a3)
{
  uint64_t v11 = 0;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2020000000;
  uint64_t v14 = 0;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100041D74;
  v6[3] = &unk_10097EF90;
  char v10 = a3;
  uint64_t v8 = &v11;
  uint64_t v9 = a1;
  id v3 = a2;
  id v7 = v3;
  sub_1003E5C0C(v6, v3);
  uint64_t v4 = v12[3];

  _Block_object_dispose(&v11, 8);
  return v4;
}

void sub_100041D5C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_100041D74(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  id v3 = Mutable;
  if (*(unsigned char *)(a1 + 56)) {
    CFStringRef v4 = @"SELECT ROWID, guid, alternate_guid, account_guid, from_identifier, message_data, data, protobuf_data, destinations, data_to_encrypt, encrypt_payload, compress_payload, use_top_level_dict, wants_response, expiration_date, command, wants_delivery_status, delivery_status_context, message_uuid, priority, date, is_sent, identifier, forced_local, peer_response_identifier, expects_peer_response, wants_app_ack, non_waking, fire_and_forget, stored_size, duet_identifiers, bypass_duet, queue_one_identifier, enforce_remote_timeout, main_account_guid, pending_delete, local_destination_device_uuid, enqueued_date, message_type, skip_self, include_self, push_priority, non_cloud_waking, live_delivery, require_bluetooth, require_local_wifi, wants_progress, ignore_max_retry_count, wants_certified_delivery, original_timestamp, kt_uri_verification_map, wants_firewall_donation, send_mode, delivery_minimum_time_delay, delivery_minimum_time FROM outgoing_message ";
  }
  else {
    CFStringRef v4 = @"SELECT ROWID, guid, alternate_guid, account_guid, from_identifier, NULL AS message_data, NULL AS data, NULL AS protobuf_data, destinations, NULL AS data_to_encrypt, encrypt_payload, compress_payload, use_top_level_dict, wants_response, expiration_date, command, wants_delivery_status, delivery_status_context, message_uuid, priority, date, is_sent, identifier, forced_local, peer_response_identifier, expects_peer_response, wants_app_ack, non_waking, fire_and_forget, stored_size, duet_identifiers, bypass_duet, queue_one_identifier, enforce_remote_timeout, main_account_guid, pending_delete, local_destination_device_uuid, enqueued_date, message_type, skip_self, include_self, push_priority, non_cloud_waking, live_delivery, require_bluetooth, require_local_wifi, wants_progress, ignore_max_retry_count, wants_certified_delivery, original_timestamp, kt_uri_verification_map, wants_firewall_donation, send_mode, delivery_minimum_time_delay, delivery_minimum_time FROM outgoing_message ";
  }
  CFStringAppend(Mutable, v4);
  CFStringAppend(v3, @"WHERE pending_delete = 0 AND guid = ? ");
  uint64_t v5 = CSDBSqliteDatabaseStatementForReading();
  if (v5)
  {
    if (*(void *)(v5 + 8))
    {
      CSDBSqliteBindTextFromCFString();
      CFArrayRef v6 = (const __CFArray *)CSDBRecordStoreProcessStatement();
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = sub_100041B94(v6, *(void **)(a1 + 32));
      CSDBSqliteStatementReset();
      if (v6) {
        CFRelease(v6);
      }
    }
  }
  if (v3)
  {
    CFRelease(v3);
  }
}

uint64_t sub_100041E7C(uint64_t a1, uint64_t a2, void *a3, char a4)
{
  uint64_t v13 = 0;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2020000000;
  uint64_t v16 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_100041F74;
  v7[3] = &unk_10097EFB8;
  char v12 = a4;
  uint64_t v10 = a2;
  uint64_t v11 = a1;
  uint64_t v9 = &v13;
  id v4 = a3;
  id v8 = v4;
  sub_1003E5C0C(v7, v4);
  uint64_t v5 = v14[3];

  _Block_object_dispose(&v13, 8);
  return v5;
}

void sub_100041F5C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_100041F74(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  id v3 = Mutable;
  if (*(unsigned char *)(a1 + 64)) {
    CFStringRef v4 = @"SELECT ROWID, guid, alternate_guid, account_guid, from_identifier, message_data, data, protobuf_data, destinations, data_to_encrypt, encrypt_payload, compress_payload, use_top_level_dict, wants_response, expiration_date, command, wants_delivery_status, delivery_status_context, message_uuid, priority, date, is_sent, identifier, forced_local, peer_response_identifier, expects_peer_response, wants_app_ack, non_waking, fire_and_forget, stored_size, duet_identifiers, bypass_duet, queue_one_identifier, enforce_remote_timeout, main_account_guid, pending_delete, local_destination_device_uuid, enqueued_date, message_type, skip_self, include_self, push_priority, non_cloud_waking, live_delivery, require_bluetooth, require_local_wifi, wants_progress, ignore_max_retry_count, wants_certified_delivery, original_timestamp, kt_uri_verification_map, wants_firewall_donation, send_mode, delivery_minimum_time_delay, delivery_minimum_time FROM outgoing_message ";
  }
  else {
    CFStringRef v4 = @"SELECT ROWID, guid, alternate_guid, account_guid, from_identifier, NULL AS message_data, NULL AS data, NULL AS protobuf_data, destinations, NULL AS data_to_encrypt, encrypt_payload, compress_payload, use_top_level_dict, wants_response, expiration_date, command, wants_delivery_status, delivery_status_context, message_uuid, priority, date, is_sent, identifier, forced_local, peer_response_identifier, expects_peer_response, wants_app_ack, non_waking, fire_and_forget, stored_size, duet_identifiers, bypass_duet, queue_one_identifier, enforce_remote_timeout, main_account_guid, pending_delete, local_destination_device_uuid, enqueued_date, message_type, skip_self, include_self, push_priority, non_cloud_waking, live_delivery, require_bluetooth, require_local_wifi, wants_progress, ignore_max_retry_count, wants_certified_delivery, original_timestamp, kt_uri_verification_map, wants_firewall_donation, send_mode, delivery_minimum_time_delay, delivery_minimum_time FROM outgoing_message ";
  }
  CFStringAppend(Mutable, v4);
  CFStringAppend(v3, @"WHERE is_sent = 0 AND pending_delete = 0 AND account_guid = ? ");
  if (*(void *)(a1 + 48)) {
    CFStringRef v5 = @"AND local_destination_device_uuid = ? ";
  }
  else {
    CFStringRef v5 = @"AND local_destination_device_uuid is null ";
  }
  CFStringAppend(v3, v5);
  uint64_t v6 = CSDBSqliteDatabaseStatementForReading();
  if (v6 && *(void *)(v6 + 8))
  {
    CSDBSqliteBindTextFromCFString();
    if (*(void *)(a1 + 48)) {
      CSDBSqliteBindTextFromCFString();
    }
    CFArrayRef v7 = (const __CFArray *)CSDBRecordStoreProcessStatement();
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = sub_100041B94(v7, *(void **)(a1 + 32));
    CSDBSqliteStatementReset();
    if (v7) {
      CFRelease(v7);
    }
  }
  if (v3)
  {
    CFRelease(v3);
  }
}

uint64_t sub_1000420B0(uint64_t a1, void *a2, char a3)
{
  uint64_t v11 = 0;
  char v12 = &v11;
  uint64_t v13 = 0x2020000000;
  uint64_t v14 = 0;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100042198;
  v6[3] = &unk_10097EF90;
  char v10 = a3;
  id v8 = &v11;
  uint64_t v9 = a1;
  id v3 = a2;
  id v7 = v3;
  sub_1003E5C0C(v6, v3);
  uint64_t v4 = v12[3];

  _Block_object_dispose(&v11, 8);
  return v4;
}

void sub_100042180(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_100042198(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  id v3 = Mutable;
  if (*(unsigned char *)(a1 + 56)) {
    CFStringRef v4 = @"SELECT ROWID, guid, alternate_guid, account_guid, from_identifier, message_data, data, protobuf_data, destinations, data_to_encrypt, encrypt_payload, compress_payload, use_top_level_dict, wants_response, expiration_date, command, wants_delivery_status, delivery_status_context, message_uuid, priority, date, is_sent, identifier, forced_local, peer_response_identifier, expects_peer_response, wants_app_ack, non_waking, fire_and_forget, stored_size, duet_identifiers, bypass_duet, queue_one_identifier, enforce_remote_timeout, main_account_guid, pending_delete, local_destination_device_uuid, enqueued_date, message_type, skip_self, include_self, push_priority, non_cloud_waking, live_delivery, require_bluetooth, require_local_wifi, wants_progress, ignore_max_retry_count, wants_certified_delivery, original_timestamp, kt_uri_verification_map, wants_firewall_donation, send_mode, delivery_minimum_time_delay, delivery_minimum_time FROM outgoing_message ";
  }
  else {
    CFStringRef v4 = @"SELECT ROWID, guid, alternate_guid, account_guid, from_identifier, NULL AS message_data, NULL AS data, NULL AS protobuf_data, destinations, NULL AS data_to_encrypt, encrypt_payload, compress_payload, use_top_level_dict, wants_response, expiration_date, command, wants_delivery_status, delivery_status_context, message_uuid, priority, date, is_sent, identifier, forced_local, peer_response_identifier, expects_peer_response, wants_app_ack, non_waking, fire_and_forget, stored_size, duet_identifiers, bypass_duet, queue_one_identifier, enforce_remote_timeout, main_account_guid, pending_delete, local_destination_device_uuid, enqueued_date, message_type, skip_self, include_self, push_priority, non_cloud_waking, live_delivery, require_bluetooth, require_local_wifi, wants_progress, ignore_max_retry_count, wants_certified_delivery, original_timestamp, kt_uri_verification_map, wants_firewall_donation, send_mode, delivery_minimum_time_delay, delivery_minimum_time FROM outgoing_message ";
  }
  CFStringAppend(Mutable, v4);
  CFStringAppend(v3, @"WHERE is_sent = 0 AND pending_delete = 0 AND expiration_date > 0 AND expiration_date <= ? LIMIT ? ");
  uint64_t v5 = CSDBSqliteDatabaseStatementForReading();
  if (v5)
  {
    if (*(void *)(v5 + 8))
    {
      +[NSDate timeIntervalSinceReferenceDate];
      CSDBSqliteBindInt64();
      CSDBSqliteBindInt64();
      CFArrayRef v6 = (const __CFArray *)CSDBRecordStoreProcessStatement();
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = sub_100041B94(v6, *(void **)(a1 + 32));
      CSDBSqliteStatementReset();
      if (v6) {
        CFRelease(v6);
      }
    }
  }
  if (v3)
  {
    CFRelease(v3);
  }
}

uint64_t sub_1000422B8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v7 = 0;
  id v8 = &v7;
  uint64_t v9 = 0x2020000000;
  uint64_t v10 = 0;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100042388;
  v6[3] = &unk_10097EFE0;
  void v6[4] = &v7;
  v6[5] = a1;
  sub_1003E5C0C(v6, v3);
  uint64_t v4 = v8[3];
  _Block_object_dispose(&v7, 8);

  return v4;
}

void sub_100042370(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100042388(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  CFStringAppend(Mutable, @"SELECT DISTINCT account_guid FROM outgoing_message WHERE is_sent = 0 AND pending_delete = 0 LIMIT ? ");
  uint64_t v3 = CSDBSqliteDatabaseStatementForReading();
  if (v3 && *(void *)(v3 + 8))
  {
    CSDBSqliteBindInt64();
    while (1)
    {
      uint64_t v4 = CSDBSqliteStatementCopyStringResult();
      if (!v4) {
        break;
      }
      uint64_t v5 = (const void *)v4;
      CFArrayRef v6 = *(__CFArray **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      if (!v6)
      {
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
        CFArrayRef v6 = *(__CFArray **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      }
      CFArrayAppendValue(v6, v5);
      CFRelease(v5);
    }
    CSDBSqliteStatementReset();
  }
  if (Mutable)
  {
    CFRelease(Mutable);
  }
}

uint64_t sub_1000424A0(void *a1, uint64_t a2, uint64_t a3, void *a4, char a5)
{
  id v8 = a1;
  id v9 = a4;
  if ([v8 count])
  {
    uint64_t v18 = 0;
    uint64_t v19 = &v18;
    uint64_t v20 = 0x2020000000;
    uint64_t v21 = 0;
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472;
    v12[2] = sub_1000425CC;
    v12[3] = &unk_10097F008;
    char v17 = a5;
    uint64_t v15 = &v18;
    uint64_t v16 = a3;
    id v13 = v8;
    id v14 = v9;
    sub_1003E5C0C(v12, v14);
    uint64_t v10 = v19[3];

    _Block_object_dispose(&v18, 8);
  }
  else
  {
    uint64_t v10 = 0;
  }

  return v10;
}

void sub_1000425B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000425CC(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  uint64_t v3 = Mutable;
  if (*(unsigned char *)(a1 + 64)) {
    CFStringRef v4 = @"SELECT ROWID, guid, alternate_guid, account_guid, from_identifier, message_data, data, protobuf_data, destinations, data_to_encrypt, encrypt_payload, compress_payload, use_top_level_dict, wants_response, expiration_date, command, wants_delivery_status, delivery_status_context, message_uuid, priority, date, is_sent, identifier, forced_local, peer_response_identifier, expects_peer_response, wants_app_ack, non_waking, fire_and_forget, stored_size, duet_identifiers, bypass_duet, queue_one_identifier, enforce_remote_timeout, main_account_guid, pending_delete, local_destination_device_uuid, enqueued_date, message_type, skip_self, include_self, push_priority, non_cloud_waking, live_delivery, require_bluetooth, require_local_wifi, wants_progress, ignore_max_retry_count, wants_certified_delivery, original_timestamp, kt_uri_verification_map, wants_firewall_donation, send_mode, delivery_minimum_time_delay, delivery_minimum_time FROM outgoing_message ";
  }
  else {
    CFStringRef v4 = @"SELECT ROWID, guid, alternate_guid, account_guid, from_identifier, NULL AS message_data, NULL AS data, NULL AS protobuf_data, destinations, NULL AS data_to_encrypt, encrypt_payload, compress_payload, use_top_level_dict, wants_response, expiration_date, command, wants_delivery_status, delivery_status_context, message_uuid, priority, date, is_sent, identifier, forced_local, peer_response_identifier, expects_peer_response, wants_app_ack, non_waking, fire_and_forget, stored_size, duet_identifiers, bypass_duet, queue_one_identifier, enforce_remote_timeout, main_account_guid, pending_delete, local_destination_device_uuid, enqueued_date, message_type, skip_self, include_self, push_priority, non_cloud_waking, live_delivery, require_bluetooth, require_local_wifi, wants_progress, ignore_max_retry_count, wants_certified_delivery, original_timestamp, kt_uri_verification_map, wants_firewall_donation, send_mode, delivery_minimum_time_delay, delivery_minimum_time FROM outgoing_message ";
  }
  CFStringAppend(Mutable, v4);
  CFStringAppend(v3, @"WHERE is_sent = 0 AND pending_delete = 0 AND account_guid ");
  [*(id *)(a1 + 32) count];
  CFStringRef v5 = (const __CFString *)CSDBGenerateInClauseForCount();
  CFStringAppend(v3, v5);
  CFStringAppend(v3, @"LIMIT ? ");
  uint64_t v6 = CSDBSqliteDatabaseStatementForReading();
  if (v6)
  {
    if (*(void *)(v6 + 8))
    {
      CSDBSqliteBindTextFromCFArrayOfCFStrings();
      CSDBSqliteBindInt64();
      CFArrayRef v7 = (const __CFArray *)CSDBRecordStoreProcessStatement();
      *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = sub_100041B94(v7, *(void **)(a1 + 40));
      CSDBSqliteStatementReset();
      if (v7) {
        CFRelease(v7);
      }
    }
  }
  if (v3)
  {
    CFRelease(v3);
  }
}

uint64_t sub_100042708(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, char a6)
{
  id v11 = a1;
  id v12 = a5;
  if ([v11 count])
  {
    uint64_t v23 = 0;
    id v24 = &v23;
    uint64_t v25 = 0x2020000000;
    uint64_t v26 = 0;
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472;
    v15[2] = sub_100042864;
    v15[3] = &unk_10097F030;
    char v22 = a6;
    uint64_t v19 = a3;
    uint64_t v20 = a2;
    uint64_t v21 = a4;
    id v16 = v11;
    uint64_t v18 = &v23;
    id v17 = v12;
    sub_1003E5C0C(v15, v17);
    uint64_t v13 = v24[3];

    _Block_object_dispose(&v23, 8);
  }
  else
  {
    _IMWarn();
    uint64_t v13 = 0;
  }

  return v13;
}

void sub_10004284C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100042864(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  uint64_t v3 = Mutable;
  if (*(unsigned char *)(a1 + 80)) {
    CFStringRef v4 = @"SELECT ROWID, guid, alternate_guid, account_guid, from_identifier, message_data, data, protobuf_data, destinations, data_to_encrypt, encrypt_payload, compress_payload, use_top_level_dict, wants_response, expiration_date, command, wants_delivery_status, delivery_status_context, message_uuid, priority, date, is_sent, identifier, forced_local, peer_response_identifier, expects_peer_response, wants_app_ack, non_waking, fire_and_forget, stored_size, duet_identifiers, bypass_duet, queue_one_identifier, enforce_remote_timeout, main_account_guid, pending_delete, local_destination_device_uuid, enqueued_date, message_type, skip_self, include_self, push_priority, non_cloud_waking, live_delivery, require_bluetooth, require_local_wifi, wants_progress, ignore_max_retry_count, wants_certified_delivery, original_timestamp, kt_uri_verification_map, wants_firewall_donation, send_mode, delivery_minimum_time_delay, delivery_minimum_time FROM outgoing_message ";
  }
  else {
    CFStringRef v4 = @"SELECT ROWID, guid, alternate_guid, account_guid, from_identifier, NULL AS message_data, NULL AS data, NULL AS protobuf_data, destinations, NULL AS data_to_encrypt, encrypt_payload, compress_payload, use_top_level_dict, wants_response, expiration_date, command, wants_delivery_status, delivery_status_context, message_uuid, priority, date, is_sent, identifier, forced_local, peer_response_identifier, expects_peer_response, wants_app_ack, non_waking, fire_and_forget, stored_size, duet_identifiers, bypass_duet, queue_one_identifier, enforce_remote_timeout, main_account_guid, pending_delete, local_destination_device_uuid, enqueued_date, message_type, skip_self, include_self, push_priority, non_cloud_waking, live_delivery, require_bluetooth, require_local_wifi, wants_progress, ignore_max_retry_count, wants_certified_delivery, original_timestamp, kt_uri_verification_map, wants_firewall_donation, send_mode, delivery_minimum_time_delay, delivery_minimum_time FROM outgoing_message ";
  }
  CFStringAppend(Mutable, v4);
  CFStringAppend(v3, @"WHERE is_sent = 0 AND pending_delete = 0 AND account_guid ");
  [*(id *)(a1 + 32) count];
  CFStringRef v5 = (const __CFString *)CSDBGenerateInClauseForCount();
  CFStringAppend(v3, v5);
  CFStringAppend(v3, @"AND priority = ? ");
  if (*(void *)(a1 + 56)) {
    CFStringRef v6 = @"AND local_destination_device_uuid = ? ";
  }
  else {
    CFStringRef v6 = @"AND local_destination_device_uuid is null ";
  }
  CFStringAppend(v3, v6);
  CFStringAppend(v3, @"LIMIT ? ");
  uint64_t v7 = CSDBSqliteDatabaseStatementForReading();
  if (v7 && *(void *)(v7 + 8))
  {
    CSDBSqliteBindTextFromCFArrayOfCFStrings();
    CSDBSqliteBindInt64();
    if (*(void *)(a1 + 56)) {
      CSDBSqliteBindTextFromCFString();
    }
    CSDBSqliteBindInt64();
    CFArrayRef v8 = (const __CFArray *)CSDBRecordStoreProcessStatement();
    *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = sub_100041B94(v8, *(void **)(a1 + 40));
    CSDBSqliteStatementReset();
    if (v8) {
      CFRelease(v8);
    }
  }
  if (v3)
  {
    CFRelease(v3);
  }
}

uint64_t sub_1000429F0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, char a6, uint64_t a7, unsigned char *a8)
{
  id v15 = a1;
  id v16 = a5;
  if ([v15 count])
  {
    uint64_t v33 = 0;
    __int16 v34 = &v33;
    uint64_t v35 = 0x2020000000;
    uint64_t v36 = 0;
    uint64_t v29 = 0;
    long long v30 = &v29;
    uint64_t v31 = 0x2020000000;
    char v32 = 1;
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 3221225472;
    v19[2] = sub_100042B9C;
    v19[3] = &unk_10097F058;
    char v28 = a6;
    uint64_t v24 = a3;
    uint64_t v25 = a2;
    uint64_t v26 = a7;
    uint64_t v27 = a4;
    id v20 = v15;
    char v22 = &v33;
    id v21 = v16;
    uint64_t v23 = &v29;
    sub_1003E5C0C(v19, v21);
    if (a8) {
      *a8 = *((unsigned char *)v30 + 24);
    }
    uint64_t v17 = v34[3];

    _Block_object_dispose(&v29, 8);
    _Block_object_dispose(&v33, 8);
  }
  else
  {
    _IMWarn();
    uint64_t v17 = 0;
  }

  return v17;
}

void sub_100042B78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v16 - 120), 8);
  _Unwind_Resume(a1);
}

void sub_100042B9C(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  uint64_t v3 = Mutable;
  if (*(unsigned char *)(a1 + 96)) {
    CFStringRef v4 = @"SELECT ROWID, guid, alternate_guid, account_guid, from_identifier, message_data, data, protobuf_data, destinations, data_to_encrypt, encrypt_payload, compress_payload, use_top_level_dict, wants_response, expiration_date, command, wants_delivery_status, delivery_status_context, message_uuid, priority, date, is_sent, identifier, forced_local, peer_response_identifier, expects_peer_response, wants_app_ack, non_waking, fire_and_forget, stored_size, duet_identifiers, bypass_duet, queue_one_identifier, enforce_remote_timeout, main_account_guid, pending_delete, local_destination_device_uuid, enqueued_date, message_type, skip_self, include_self, push_priority, non_cloud_waking, live_delivery, require_bluetooth, require_local_wifi, wants_progress, ignore_max_retry_count, wants_certified_delivery, original_timestamp, kt_uri_verification_map, wants_firewall_donation, send_mode, delivery_minimum_time_delay, delivery_minimum_time FROM outgoing_message ";
  }
  else {
    CFStringRef v4 = @"SELECT ROWID, guid, alternate_guid, account_guid, from_identifier, NULL AS message_data, NULL AS data, NULL AS protobuf_data, destinations, NULL AS data_to_encrypt, encrypt_payload, compress_payload, use_top_level_dict, wants_response, expiration_date, command, wants_delivery_status, delivery_status_context, message_uuid, priority, date, is_sent, identifier, forced_local, peer_response_identifier, expects_peer_response, wants_app_ack, non_waking, fire_and_forget, stored_size, duet_identifiers, bypass_duet, queue_one_identifier, enforce_remote_timeout, main_account_guid, pending_delete, local_destination_device_uuid, enqueued_date, message_type, skip_self, include_self, push_priority, non_cloud_waking, live_delivery, require_bluetooth, require_local_wifi, wants_progress, ignore_max_retry_count, wants_certified_delivery, original_timestamp, kt_uri_verification_map, wants_firewall_donation, send_mode, delivery_minimum_time_delay, delivery_minimum_time FROM outgoing_message ";
  }
  CFStringAppend(Mutable, v4);
  CFStringAppend(v3, @"WHERE is_sent = 0 AND pending_delete = 0 AND account_guid ");
  [*(id *)(a1 + 32) count];
  CFStringRef v5 = (const __CFString *)CSDBGenerateInClauseForCount();
  CFStringAppend(v3, v5);
  CFStringAppend(v3, @"AND priority = ? ");
  CFStringAppend(v3, @"AND message_xpc_type_t type = ? ");
  if (*(void *)(a1 + 64)) {
    CFStringRef v6 = @"AND local_destination_device_uuid = ? ";
  }
  else {
    CFStringRef v6 = @"AND local_destination_device_uuid is null ";
  }
  CFStringAppend(v3, v6);
  CFStringAppend(v3, @"LIMIT ? ");
  uint64_t v7 = CSDBSqliteDatabaseStatementForReading();
  if (!v7 || !*(void *)(v7 + 8))
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 0;
    if (!v3) {
      return;
    }
    goto LABEL_14;
  }
  CSDBSqliteBindTextFromCFArrayOfCFStrings();
  CSDBSqliteBindInt64();
  CSDBSqliteBindInt64();
  if (*(void *)(a1 + 64)) {
    CSDBSqliteBindTextFromCFString();
  }
  CSDBSqliteBindInt64();
  CFArrayRef v8 = (const __CFArray *)CSDBRecordStoreProcessStatement();
  *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = sub_100041B94(v8, *(void **)(a1 + 40));
  CSDBSqliteStatementReset();
  if (v8) {
    CFRelease(v8);
  }
  if (v3)
  {
LABEL_14:
    CFRelease(v3);
  }
}

uint64_t sub_100042D54(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, void *a7, int a8)
{
  id v15 = a7;
  if (a4)
  {
    uint64_t v34 = 0;
    uint64_t v35 = &v34;
    uint64_t v36 = 0x2020000000;
    uint64_t v37 = 0;
    uint64_t v30 = 0;
    uint64_t v31 = &v30;
    uint64_t v32 = 0x2020000000;
    CFMutableStringRef Mutable = (CFMutableStringRef)0xAAAAAAAAAAAAAAAALL;
    CFMutableStringRef Mutable = CFStringCreateMutable(0, 0);
    CFStringAppend((CFMutableStringRef)v31[3], @"SELECT DISTINCT ");
    if (a8) {
      CFStringRef v16 = @"ROWID, guid, alternate_guid, account_guid, from_identifier, message_data, data, protobuf_data, destinations, data_to_encrypt, encrypt_payload, compress_payload, use_top_level_dict, wants_response, expiration_date, command, wants_delivery_status, delivery_status_context, message_uuid, priority, date, is_sent, identifier, forced_local, peer_response_identifier, expects_peer_response, wants_app_ack, non_waking, fire_and_forget, stored_size, duet_identifiers, bypass_duet, queue_one_identifier, enforce_remote_timeout, main_account_guid, pending_delete, local_destination_device_uuid, enqueued_date, message_type, skip_self, include_self, push_priority, non_cloud_waking, live_delivery, require_bluetooth, require_local_wifi, wants_progress, ignore_max_retry_count, wants_certified_delivery, original_timestamp, kt_uri_verification_map, wants_firewall_donation, send_mode, delivery_minimum_time_delay, delivery_minimum_time ";
    }
    else {
      CFStringRef v16 = @"ROWID, guid, alternate_guid, account_guid, from_identifier, NULL AS message_data, NULL AS data, NULL AS protobuf_data, destinations, NULL AS data_to_encrypt, encrypt_payload, compress_payload, use_top_level_dict, wants_response, expiration_date, command, wants_delivery_status, delivery_status_context, message_uuid, priority, date, is_sent, identifier, forced_local, peer_response_identifier, expects_peer_response, wants_app_ack, non_waking, fire_and_forget, stored_size, duet_identifiers, bypass_duet, queue_one_identifier, enforce_remote_timeout, main_account_guid, pending_delete, local_destination_device_uuid, enqueued_date, message_type, skip_self, include_self, push_priority, non_cloud_waking, live_delivery, require_bluetooth, require_local_wifi, wants_progress, ignore_max_retry_count, wants_certified_delivery, original_timestamp, kt_uri_verification_map, wants_firewall_donation, send_mode, delivery_minimum_time_delay, delivery_minimum_time ";
    }
    CFStringAppend((CFMutableStringRef)v31[3], v16);
    CFStringAppend((CFMutableStringRef)v31[3], @" FROM(  SELECT ");
    CFStringAppend((CFMutableStringRef)v31[3], v16);
    CFStringAppend((CFMutableStringRef)v31[3], @"  FROM outgoing_message o   WHERE priority = ? AND pending_delete = 0 AND is_sent = 0 AND account_guid = ? AND (bypass_duet = ? OR bypass_duet = ?) ");
    if (a6) {
      CFStringRef v17 = @"AND local_destination_device_uuid = ? ";
    }
    else {
      CFStringRef v17 = @"AND local_destination_device_uuid is null ";
    }
    CFStringAppend((CFMutableStringRef)v31[3], v17);
    CFStringAppend((CFMutableStringRef)v31[3], @"  ORDER BY ROWID ASC   LIMIT ? AS ofilt WHERE (SELECT SUM(stored_size) FROM outgoing_message s where s.ROWID <= ofilt.ROWID) <= ? UNION SELECT "));
    CFStringAppend((CFMutableStringRef)v31[3], v16);
    CFStringAppend((CFMutableStringRef)v31[3], @" FROM(  SELECT ");
    CFStringAppend((CFMutableStringRef)v31[3], v16);
    CFStringAppend((CFMutableStringRef)v31[3], @" FROM outgoing_message   WHERE priority = ? AND pending_delete = 0 AND is_sent = 0 AND account_guid = ? AND (bypass_duet = ? OR bypass_duet = ?) ");
    CFStringAppend((CFMutableStringRef)v31[3], v17);
    CFStringAppend((CFMutableStringRef)v31[3], @"  ORDER BY ROWID ASC LIMIT 1 "));
    v20[0] = _NSConcreteStackBlock;
    v20[1] = 3221225472;
    v20[2] = sub_10004300C;
    v20[3] = &unk_10097F080;
    char v22 = &v30;
    uint64_t v24 = a3;
    uint64_t v25 = a4;
    char v29 = a5;
    uint64_t v26 = a6;
    uint64_t v27 = a1;
    uint64_t v28 = a2;
    id v21 = v15;
    uint64_t v23 = &v34;
    sub_1003E5C0C(v20, v21);
    uint64_t v18 = v35[3];

    _Block_object_dispose(&v30, 8);
    _Block_object_dispose(&v34, 8);
  }
  else
  {
    _IMWarn();
    uint64_t v18 = 0;
  }

  return v18;
}

void sub_100042FE0(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Unwind_Resume(a1);
}

void sub_10004300C(uint64_t a1)
{
  uint64_t v2 = CSDBSqliteDatabaseStatementForReading();
  if (v2 && *(void *)(v2 + 8))
  {
    CSDBSqliteBindInt64();
    CSDBSqliteBindTextFromCFString();
    CSDBSqliteBindInt64();
    CSDBSqliteBindInt64();
    if (*(void *)(a1 + 72)) {
      CSDBSqliteBindTextFromCFString();
    }
    CSDBSqliteBindInt64();
    CSDBSqliteBindInt64();
    CSDBSqliteBindInt64();
    CSDBSqliteBindTextFromCFString();
    CSDBSqliteBindInt64();
    CSDBSqliteBindInt64();
    if (*(void *)(a1 + 72)) {
      CSDBSqliteBindTextFromCFString();
    }
    CFArrayRef v3 = (const __CFArray *)CSDBRecordStoreProcessStatement();
    CFIndex Count = CFArrayGetCount(v3);
    if (Count << 32)
    {
      CFIndex v5 = 0;
      CFIndex v6 = (int)Count;
      if ((unint64_t)(int)Count <= 1) {
        uint64_t v7 = 1;
      }
      else {
        uint64_t v7 = (int)Count;
      }
      while (1)
      {
        CFArrayGetValueAtIndex(v3, v5);
        int ID = CSDBRecordGetID();
        id v9 = sub_100040C20((uint64_t)kCFAllocatorDefault, ID, 0, *(void **)(a1 + 32));
        uint64_t v10 = v9;
        if (!*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24)) {
          break;
        }
        if (v9) {
          goto LABEL_13;
        }
LABEL_14:
        if (v7 == ++v5) {
          goto LABEL_18;
        }
      }
      *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = CFArrayCreateMutable(kCFAllocatorDefault, v6, &kCFTypeArrayCallBacks);
      if (!v10) {
        goto LABEL_14;
      }
LABEL_13:
      CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(*(void *)(a1 + 48) + 8) + 24), v10);
      CFRelease(v10);
      goto LABEL_14;
    }
LABEL_18:
    CSDBSqliteStatementReset();
    if (v3) {
      CFRelease(v3);
    }
  }
  id v11 = *(const void **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  if (v11)
  {
    CFRelease(v11);
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
  }
}

uint64_t sub_10004322C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, void *a7, int a8, void *a9)
{
  id v16 = a7;
  id v17 = a9;
  if (a4)
  {
    uint64_t v39 = 0;
    v40 = &v39;
    uint64_t v41 = 0x2020000000;
    uint64_t v42 = 0;
    uint64_t v35 = 0;
    uint64_t v36 = &v35;
    uint64_t v37 = 0x2020000000;
    CFMutableStringRef Mutable = (CFMutableStringRef)0xAAAAAAAAAAAAAAAALL;
    CFMutableStringRef Mutable = CFStringCreateMutable(0, 0);
    CFStringAppend((CFMutableStringRef)v36[3], @"SELECT DISTINCT ");
    if (a8) {
      CFStringRef v18 = @"ROWID, guid, alternate_guid, account_guid, from_identifier, message_data, data, protobuf_data, destinations, data_to_encrypt, encrypt_payload, compress_payload, use_top_level_dict, wants_response, expiration_date, command, wants_delivery_status, delivery_status_context, message_uuid, priority, date, is_sent, identifier, forced_local, peer_response_identifier, expects_peer_response, wants_app_ack, non_waking, fire_and_forget, stored_size, duet_identifiers, bypass_duet, queue_one_identifier, enforce_remote_timeout, main_account_guid, pending_delete, local_destination_device_uuid, enqueued_date, message_type, skip_self, include_self, push_priority, non_cloud_waking, live_delivery, require_bluetooth, require_local_wifi, wants_progress, ignore_max_retry_count, wants_certified_delivery, original_timestamp, kt_uri_verification_map, wants_firewall_donation, send_mode, delivery_minimum_time_delay, delivery_minimum_time ";
    }
    else {
      CFStringRef v18 = @"ROWID, guid, alternate_guid, account_guid, from_identifier, NULL AS message_data, NULL AS data, NULL AS protobuf_data, destinations, NULL AS data_to_encrypt, encrypt_payload, compress_payload, use_top_level_dict, wants_response, expiration_date, command, wants_delivery_status, delivery_status_context, message_uuid, priority, date, is_sent, identifier, forced_local, peer_response_identifier, expects_peer_response, wants_app_ack, non_waking, fire_and_forget, stored_size, duet_identifiers, bypass_duet, queue_one_identifier, enforce_remote_timeout, main_account_guid, pending_delete, local_destination_device_uuid, enqueued_date, message_type, skip_self, include_self, push_priority, non_cloud_waking, live_delivery, require_bluetooth, require_local_wifi, wants_progress, ignore_max_retry_count, wants_certified_delivery, original_timestamp, kt_uri_verification_map, wants_firewall_donation, send_mode, delivery_minimum_time_delay, delivery_minimum_time ";
    }
    CFStringAppend((CFMutableStringRef)v36[3], v18);
    CFStringAppend((CFMutableStringRef)v36[3], @" FROM(  SELECT ");
    CFStringAppend((CFMutableStringRef)v36[3], v18);
    CFStringAppend((CFMutableStringRef)v36[3], @"  FROM outgoing_message o   WHERE priority = ? AND pending_delete = 0 AND is_sent = 0 AND account_guid = ? AND (bypass_duet = ? OR bypass_duet = ?) ");
    if (a6) {
      CFStringRef v19 = @"AND local_destination_device_uuid = ? ";
    }
    else {
      CFStringRef v19 = @"AND local_destination_device_uuid is null ";
    }
    CFStringAppend((CFMutableStringRef)v36[3], v19);
    CFStringAppend((CFMutableStringRef)v36[3], @"  ORDER BY ROWID ASC   LIMIT ? AS ofilt WHERE (SELECT SUM(stored_size) FROM outgoing_message s where s.ROWID <= ofilt.ROWID) <= ? UNION SELECT "));
    CFStringAppend((CFMutableStringRef)v36[3], v18);
    CFStringAppend((CFMutableStringRef)v36[3], @" FROM(  SELECT ");
    CFStringAppend((CFMutableStringRef)v36[3], v18);
    CFStringAppend((CFMutableStringRef)v36[3], @" FROM outgoing_message   WHERE priority = ? AND pending_delete = 0 AND is_sent = 0 AND account_guid = ? AND (bypass_duet = ? OR bypass_duet = ?) ");
    CFStringAppend((CFMutableStringRef)v36[3], v19);
    if ([v17 count])
    {
      CFStringAppend((CFMutableStringRef)v36[3], @"AND message_type ");
      id v20 = (__CFString *)v36[3];
      [v17 count];
      CFStringRef v21 = (const __CFString *)CSDBGenerateInClauseForCount();
      CFStringAppend(v20, v21);
    }
    CFStringAppend((CFMutableStringRef)v36[3], @"  ORDER BY ROWID ASC LIMIT 1 "));
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 3221225472;
    v24[2] = sub_100043544;
    v24[3] = &unk_10097F0A8;
    uint64_t v27 = &v35;
    uint64_t v29 = a3;
    uint64_t v30 = a4;
    char v34 = a5;
    uint64_t v31 = a6;
    uint64_t v32 = a1;
    uint64_t v33 = a2;
    id v25 = v17;
    id v26 = v16;
    uint64_t v28 = &v39;
    sub_1003E5C0C(v24, v26);
    uint64_t v22 = v40[3];

    _Block_object_dispose(&v35, 8);
    _Block_object_dispose(&v39, 8);
  }
  else
  {
    _IMWarn();
    uint64_t v22 = 0;
  }

  return v22;
}

void sub_100043518(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 120), 8);
  _Unwind_Resume(a1);
}

void sub_100043544(uint64_t a1)
{
  uint64_t v2 = CSDBSqliteDatabaseStatementForReading();
  if (v2 && *(void *)(v2 + 8))
  {
    CSDBSqliteBindInt64();
    CSDBSqliteBindTextFromCFString();
    CSDBSqliteBindInt64();
    CSDBSqliteBindInt64();
    if (*(void *)(a1 + 80)) {
      CSDBSqliteBindTextFromCFString();
    }
    CSDBSqliteBindInt64();
    CSDBSqliteBindInt64();
    CSDBSqliteBindInt64();
    CSDBSqliteBindTextFromCFString();
    CSDBSqliteBindInt64();
    CSDBSqliteBindInt64();
    if (*(void *)(a1 + 80)) {
      CSDBSqliteBindTextFromCFString();
    }
    if ([*(id *)(a1 + 32) count])
    {
      long long v19 = 0u;
      long long v20 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      id v3 = *(id *)(a1 + 32);
      id v4 = [v3 countByEnumeratingWithState:&v17 objects:v21 count:16];
      if (v4)
      {
        id v5 = v4;
        uint64_t v6 = *(void *)v18;
        do
        {
          uint64_t v7 = 0;
          do
          {
            if (*(void *)v18 != v6) {
              objc_enumerationMutation(v3);
            }
            objc_msgSend(*(id *)(*((void *)&v17 + 1) + 8 * (void)v7), "longLongValue", (void)v17);
            CSDBSqliteBindInt64();
            uint64_t v7 = (char *)v7 + 1;
          }
          while (v5 != v7);
          id v5 = [v3 countByEnumeratingWithState:&v17 objects:v21 count:16];
        }
        while (v5);
      }
    }
    CFArrayRef v8 = (const __CFArray *)CSDBRecordStoreProcessStatement();
    CFIndex Count = CFArrayGetCount(v8);
    if (Count << 32)
    {
      CFIndex v10 = 0;
      CFIndex v11 = (int)Count;
      if ((unint64_t)(int)Count <= 1) {
        uint64_t v12 = 1;
      }
      else {
        uint64_t v12 = (int)Count;
      }
      while (1)
      {
        CFArrayGetValueAtIndex(v8, v10);
        int ID = CSDBRecordGetID();
        id v14 = sub_100040C20((uint64_t)kCFAllocatorDefault, ID, 0, *(void **)(a1 + 40));
        id v15 = v14;
        if (!*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24)) {
          break;
        }
        if (v14) {
          goto LABEL_22;
        }
LABEL_23:
        if (v12 == ++v10) {
          goto LABEL_27;
        }
      }
      *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = CFArrayCreateMutable(kCFAllocatorDefault, v11, &kCFTypeArrayCallBacks);
      if (!v15) {
        goto LABEL_23;
      }
LABEL_22:
      CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(*(void *)(a1 + 56) + 8) + 24), v15);
      CFRelease(v15);
      goto LABEL_23;
    }
LABEL_27:
    CSDBSqliteStatementReset();
    if (v8) {
      CFRelease(v8);
    }
  }
  id v16 = *(const void **)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
  if (v16)
  {
    CFRelease(v16);
    *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
  }
}

uint64_t sub_10004383C(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, void *a6, char a7)
{
  uint64_t v19 = 0;
  long long v20 = &v19;
  uint64_t v21 = 0x2020000000;
  uint64_t v22 = 0;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_100043954;
  v10[3] = &unk_10097F0D0;
  char v17 = a7;
  char v18 = a4;
  uint64_t v13 = a3;
  uint64_t v14 = a5;
  uint64_t v15 = a2;
  uint64_t v16 = a1;
  id v7 = a6;
  id v11 = v7;
  uint64_t v12 = &v19;
  sub_1003E5C0C(v10, v7);
  uint64_t v8 = v20[3];

  _Block_object_dispose(&v19, 8);
  return v8;
}

void sub_10004393C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100043954(uint64_t a1)
{
  CFMutableStringRef Mutable = CFStringCreateMutable(0, 0);
  id v3 = Mutable;
  if (*(unsigned char *)(a1 + 80)) {
    CFStringRef v4 = @"SELECT ROWID, guid, alternate_guid, account_guid, from_identifier, message_data, data, protobuf_data, destinations, data_to_encrypt, encrypt_payload, compress_payload, use_top_level_dict, wants_response, expiration_date, command, wants_delivery_status, delivery_status_context, message_uuid, priority, date, is_sent, identifier, forced_local, peer_response_identifier, expects_peer_response, wants_app_ack, non_waking, fire_and_forget, stored_size, duet_identifiers, bypass_duet, queue_one_identifier, enforce_remote_timeout, main_account_guid, pending_delete, local_destination_device_uuid, enqueued_date, message_type, skip_self, include_self, push_priority, non_cloud_waking, live_delivery, require_bluetooth, require_local_wifi, wants_progress, ignore_max_retry_count, wants_certified_delivery, original_timestamp, kt_uri_verification_map, wants_firewall_donation, send_mode, delivery_minimum_time_delay, delivery_minimum_time FROM outgoing_message ";
  }
  else {
    CFStringRef v4 = @"SELECT ROWID, guid, alternate_guid, account_guid, from_identifier, NULL AS message_data, NULL AS data, NULL AS protobuf_data, destinations, NULL AS data_to_encrypt, encrypt_payload, compress_payload, use_top_level_dict, wants_response, expiration_date, command, wants_delivery_status, delivery_status_context, message_uuid, priority, date, is_sent, identifier, forced_local, peer_response_identifier, expects_peer_response, wants_app_ack, non_waking, fire_and_forget, stored_size, duet_identifiers, bypass_duet, queue_one_identifier, enforce_remote_timeout, main_account_guid, pending_delete, local_destination_device_uuid, enqueued_date, message_type, skip_self, include_self, push_priority, non_cloud_waking, live_delivery, require_bluetooth, require_local_wifi, wants_progress, ignore_max_retry_count, wants_certified_delivery, original_timestamp, kt_uri_verification_map, wants_firewall_donation, send_mode, delivery_minimum_time_delay, delivery_minimum_time FROM outgoing_message ";
  }
  CFStringAppend(Mutable, v4);
  CFStringAppend(v3, @"WHERE priority = ? AND is_sent = 0 AND pending_delete = 0 ");
  if (*(void *)(a1 + 48)) {
    CFStringAppend(v3, @"AND account_guid = ? ");
  }
  if (*(unsigned char *)(a1 + 81)) {
    CFStringAppend(v3, @"AND bypass_duet = 0 ");
  }
  if (*(void *)(a1 + 56)) {
    CFStringRef v5 = @"AND local_destination_device_uuid = ? ";
  }
  else {
    CFStringRef v5 = @"AND local_destination_device_uuid is null ";
  }
  CFStringAppend(v3, v5);
  CFStringAppend(v3, @"ORDER BY ROWID ASC LIMIT ?");
  uint64_t v6 = CSDBSqliteDatabaseStatementForReading();
  if (v6 && *(void *)(v6 + 8))
  {
    CSDBSqliteBindInt64();
    if (*(void *)(a1 + 48)) {
      CSDBSqliteBindTextFromCFString();
    }
    if (*(void *)(a1 + 56)) {
      CSDBSqliteBindTextFromCFString();
    }
    CSDBSqliteBindInt64();
    CFArrayRef v7 = (const __CFArray *)CSDBRecordStoreProcessStatement();
    CFIndex Count = CFArrayGetCount(v7);
    if (Count << 32)
    {
      CFIndex v9 = 0;
      CFIndex v10 = (int)Count;
      if ((unint64_t)(int)Count <= 1) {
        uint64_t v11 = 1;
      }
      else {
        uint64_t v11 = (int)Count;
      }
      while (1)
      {
        CFArrayGetValueAtIndex(v7, v9);
        int ID = CSDBRecordGetID();
        uint64_t v13 = sub_100040C20((uint64_t)kCFAllocatorDefault, ID, 0, *(void **)(a1 + 32));
        uint64_t v14 = v13;
        if (!*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
          break;
        }
        if (v13) {
          goto LABEL_23;
        }
LABEL_24:
        if (v11 == ++v9) {
          goto LABEL_28;
        }
      }
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = CFArrayCreateMutable(kCFAllocatorDefault, v10, &kCFTypeArrayCallBacks);
      if (!v14) {
        goto LABEL_24;
      }
LABEL_23:
      CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), v14);
      CFRelease(v14);
      goto LABEL_24;
    }
LABEL_28:
    CSDBSqliteStatementReset();
    if (v7) {
      CFRelease(v7);
    }
  }
  if (v3)
  {
    CFRelease(v3);
  }
}

uint64_t sub_100043BB8(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, void *a6, char a7, void *a8)
{
  id v15 = a6;
  uint64_t v30 = 0;
  uint64_t v31 = &v30;
  uint64_t v32 = 0x2020000000;
  uint64_t v33 = 0;
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472;
  v20[2] = sub_100043CFC;
  v20[3] = &unk_10097F0F8;
  char v28 = a7;
  char v29 = a4;
  uint64_t v24 = a3;
  uint64_t v25 = a5;
  id v16 = a8;
  id v21 = v16;
  uint64_t v26 = a2;
  uint64_t v27 = a1;
  id v17 = v15;
  id v22 = v17;
  uint64_t v23 = &v30;
  sub_1003E5C0C(v20, v17);
  uint64_t v18 = v31[3];

  _Block_object_dispose(&v30, 8);
  return v18;
}

void sub_100043CE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100043CFC(uint64_t a1)
{
  CFMutableStringRef Mutable = CFStringCreateMutable(0, 0);
  id v3 = Mutable;
  if (*(unsigned char *)(a1 + 88)) {
    CFStringRef v4 = @"SELECT ROWID, guid, alternate_guid, account_guid, from_identifier, message_data, data, protobuf_data, destinations, data_to_encrypt, encrypt_payload, compress_payload, use_top_level_dict, wants_response, expiration_date, command, wants_delivery_status, delivery_status_context, message_uuid, priority, date, is_sent, identifier, forced_local, peer_response_identifier, expects_peer_response, wants_app_ack, non_waking, fire_and_forget, stored_size, duet_identifiers, bypass_duet, queue_one_identifier, enforce_remote_timeout, main_account_guid, pending_delete, local_destination_device_uuid, enqueued_date, message_type, skip_self, include_self, push_priority, non_cloud_waking, live_delivery, require_bluetooth, require_local_wifi, wants_progress, ignore_max_retry_count, wants_certified_delivery, original_timestamp, kt_uri_verification_map, wants_firewall_donation, send_mode, delivery_minimum_time_delay, delivery_minimum_time FROM outgoing_message ";
  }
  else {
    CFStringRef v4 = @"SELECT ROWID, guid, alternate_guid, account_guid, from_identifier, NULL AS message_data, NULL AS data, NULL AS protobuf_data, destinations, NULL AS data_to_encrypt, encrypt_payload, compress_payload, use_top_level_dict, wants_response, expiration_date, command, wants_delivery_status, delivery_status_context, message_uuid, priority, date, is_sent, identifier, forced_local, peer_response_identifier, expects_peer_response, wants_app_ack, non_waking, fire_and_forget, stored_size, duet_identifiers, bypass_duet, queue_one_identifier, enforce_remote_timeout, main_account_guid, pending_delete, local_destination_device_uuid, enqueued_date, message_type, skip_self, include_self, push_priority, non_cloud_waking, live_delivery, require_bluetooth, require_local_wifi, wants_progress, ignore_max_retry_count, wants_certified_delivery, original_timestamp, kt_uri_verification_map, wants_firewall_donation, send_mode, delivery_minimum_time_delay, delivery_minimum_time FROM outgoing_message ";
  }
  CFStringAppend(Mutable, v4);
  CFStringAppend(v3, @"WHERE priority = ? AND is_sent = 0 AND pending_delete = 0 ");
  if (*(void *)(a1 + 56)) {
    CFStringAppend(v3, @"AND account_guid = ? ");
  }
  if (*(unsigned char *)(a1 + 89)) {
    CFStringAppend(v3, @"AND bypass_duet = 0 ");
  }
  if (*(void *)(a1 + 64)) {
    CFStringRef v5 = @"AND local_destination_device_uuid = ? ";
  }
  else {
    CFStringRef v5 = @"AND local_destination_device_uuid is null ";
  }
  CFStringAppend(v3, v5);
  if ([*(id *)(a1 + 32) count])
  {
    CFStringAppend(v3, @"AND message_type ");
    [*(id *)(a1 + 32) count];
    CFStringRef v6 = (const __CFString *)CSDBGenerateInClauseForCount();
    CFStringAppend(v3, v6);
  }
  CFStringAppend(v3, @"ORDER BY ROWID ASC LIMIT ?");
  uint64_t v7 = CSDBSqliteDatabaseStatementForReading();
  if (v7 && *(void *)(v7 + 8))
  {
    CSDBSqliteBindInt64();
    if (*(void *)(a1 + 56)) {
      CSDBSqliteBindTextFromCFString();
    }
    if (*(void *)(a1 + 64)) {
      CSDBSqliteBindTextFromCFString();
    }
    if ([*(id *)(a1 + 32) count])
    {
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      id v8 = *(id *)(a1 + 32);
      id v9 = [v8 countByEnumeratingWithState:&v21 objects:v25 count:16];
      if (v9)
      {
        id v10 = v9;
        uint64_t v11 = *(void *)v22;
        do
        {
          uint64_t v12 = 0;
          do
          {
            if (*(void *)v22 != v11) {
              objc_enumerationMutation(v8);
            }
            objc_msgSend(*(id *)(*((void *)&v21 + 1) + 8 * (void)v12), "longLongValue", (void)v21);
            CSDBSqliteBindInt64();
            uint64_t v12 = (char *)v12 + 1;
          }
          while (v10 != v12);
          id v10 = [v8 countByEnumeratingWithState:&v21 objects:v25 count:16];
        }
        while (v10);
      }
    }
    CSDBSqliteBindInt64();
    CFArrayRef v13 = (const __CFArray *)CSDBRecordStoreProcessStatement();
    CFIndex Count = CFArrayGetCount(v13);
    if (Count << 32)
    {
      CFIndex v15 = 0;
      CFIndex v16 = (int)Count;
      if ((unint64_t)(int)Count <= 1) {
        uint64_t v17 = 1;
      }
      else {
        uint64_t v17 = (int)Count;
      }
      while (1)
      {
        CFArrayGetValueAtIndex(v13, v15);
        int ID = CSDBRecordGetID();
        uint64_t v19 = sub_100040C20((uint64_t)kCFAllocatorDefault, ID, 0, *(void **)(a1 + 40));
        long long v20 = v19;
        if (!*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24)) {
          break;
        }
        if (v19) {
          goto LABEL_34;
        }
LABEL_35:
        if (v17 == ++v15) {
          goto LABEL_39;
        }
      }
      *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = CFArrayCreateMutable(kCFAllocatorDefault, v16, &kCFTypeArrayCallBacks);
      if (!v20) {
        goto LABEL_35;
      }
LABEL_34:
      CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(*(void *)(a1 + 48) + 8) + 24), v20);
      CFRelease(v20);
      goto LABEL_35;
    }
LABEL_39:
    CSDBSqliteStatementReset();
    if (v13) {
      CFRelease(v13);
    }
  }
  if (v3) {
    CFRelease(v3);
  }
}

void sub_100044044(uint64_t a1, char a2, void *a3)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_1000440BC;
  v3[3] = &unk_10097F118;
  char v4 = a2;
  void v3[4] = a1;
  sub_1003E5D0C(@"UPDATE outgoing_message SET is_sent = ? WHERE guid = ?", v3, a3);
}

uint64_t sub_1000440BC()
{
  CSDBSqliteBindInt64();
  CSDBSqliteBindTextFromCFString();

  return CSDBSqliteStatementPerform();
}

void sub_10004410C(void *a1)
{
  sub_1003E5D0C(@"UPDATE outgoing_message SET is_sent = 0", &stru_10097F158, a1);
}

void sub_100044124(id a1, CSDBRecordStore *a2, CSDBSqliteDatabase *a3, CSDBSqliteStatement *a4)
{
}

void sub_10004412C(void *a1, void *a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_1000441C8;
  v4[3] = &unk_10097F180;
  id v5 = a2;
  id v3 = v5;
  sub_1003E5D0C(@"UPDATE outgoing_message SET is_sent = 0 WHERE local_destination_device_uuid = ?", v4, a1);
}

uint64_t sub_1000441C8()
{
  CSDBSqliteBindTextFromCFString();

  return CSDBSqliteStatementPerform();
}

void sub_100044208(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  if ([v5 count])
  {
    CFMutableStringRef Mutable = CFStringCreateMutable(0, 0);
    CFStringAppend(Mutable, @"UPDATE outgoing_message SET local_destination_device_uuid = ? WHERE is_sent = 0 AND pending_delete = 0 AND account_guid ");
    [v5 count];
    CFStringRef v9 = (const __CFString *)CSDBGenerateInClauseForCount();
    CFStringAppend(Mutable, v9);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_10004433C;
    v10[3] = &unk_10097F1A8;
    id v11 = v6;
    id v12 = v5;
    sub_1003E5D0C((uint64_t)Mutable, v10, v7);
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
  else
  {
    _IMWarn();
  }
}

uint64_t sub_10004433C()
{
  CSDBSqliteBindTextFromCFString();
  CSDBSqliteBindTextFromCFArrayOfCFStrings();

  return CSDBSqliteStatementPerform();
}

void sub_10004438C(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  if (![v5 count]) {
    _IMWarn();
  }
  CFMutableStringRef Mutable = CFStringCreateMutable(0, 0);
  CFStringAppend(Mutable, @"UPDATE outgoing_message SET pending_delete = 1 WHERE local_destination_device_uuid = ? AND account_guid ");
  [v5 count];
  CFStringRef v9 = (const __CFString *)CSDBGenerateInClauseForCount();
  CFStringAppend(Mutable, v9);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1000444C0;
  v12[3] = &unk_10097F1A8;
  id v13 = v6;
  id v14 = v5;
  id v10 = v5;
  id v11 = v6;
  sub_1003E5D0C((uint64_t)Mutable, v12, v7);

  if (Mutable) {
    CFRelease(Mutable);
  }
}

uint64_t sub_1000444C0()
{
  CSDBSqliteBindTextFromCFString();
  CSDBSqliteBindTextFromCFArrayOfCFStrings();

  return CSDBSqliteStatementPerform();
}

uint64_t sub_100044510(uint64_t a1, void *a2, char a3)
{
  uint64_t v11 = 0;
  id v12 = &v11;
  uint64_t v13 = 0x2020000000;
  uint64_t v14 = 0;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_1000445F8;
  v6[3] = &unk_10097EF90;
  char v10 = a3;
  id v8 = &v11;
  uint64_t v9 = a1;
  id v3 = a2;
  id v7 = v3;
  sub_1003E5C0C(v6, v3);
  uint64_t v4 = v12[3];

  _Block_object_dispose(&v11, 8);
  return v4;
}

void sub_1000445E0(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_1000445F8(uint64_t a1)
{
  CFMutableStringRef Mutable = CFStringCreateMutable(0, 0);
  id v3 = Mutable;
  if (*(unsigned char *)(a1 + 56)) {
    CFStringRef v4 = @"SELECT ROWID, guid, alternate_guid, account_guid, from_identifier, message_data, data, protobuf_data, destinations, data_to_encrypt, encrypt_payload, compress_payload, use_top_level_dict, wants_response, expiration_date, command, wants_delivery_status, delivery_status_context, message_uuid, priority, date, is_sent, identifier, forced_local, peer_response_identifier, expects_peer_response, wants_app_ack, non_waking, fire_and_forget, stored_size, duet_identifiers, bypass_duet, queue_one_identifier, enforce_remote_timeout, main_account_guid, pending_delete, local_destination_device_uuid, enqueued_date, message_type, skip_self, include_self, push_priority, non_cloud_waking, live_delivery, require_bluetooth, require_local_wifi, wants_progress, ignore_max_retry_count, wants_certified_delivery, original_timestamp, kt_uri_verification_map, wants_firewall_donation, send_mode, delivery_minimum_time_delay, delivery_minimum_time FROM outgoing_message ";
  }
  else {
    CFStringRef v4 = @"SELECT ROWID, guid, alternate_guid, account_guid, from_identifier, NULL AS message_data, NULL AS data, NULL AS protobuf_data, destinations, NULL AS data_to_encrypt, encrypt_payload, compress_payload, use_top_level_dict, wants_response, expiration_date, command, wants_delivery_status, delivery_status_context, message_uuid, priority, date, is_sent, identifier, forced_local, peer_response_identifier, expects_peer_response, wants_app_ack, non_waking, fire_and_forget, stored_size, duet_identifiers, bypass_duet, queue_one_identifier, enforce_remote_timeout, main_account_guid, pending_delete, local_destination_device_uuid, enqueued_date, message_type, skip_self, include_self, push_priority, non_cloud_waking, live_delivery, require_bluetooth, require_local_wifi, wants_progress, ignore_max_retry_count, wants_certified_delivery, original_timestamp, kt_uri_verification_map, wants_firewall_donation, send_mode, delivery_minimum_time_delay, delivery_minimum_time FROM outgoing_message ";
  }
  CFStringAppend(Mutable, v4);
  CFStringAppend(v3, @"WHERE pending_delete = 1 LIMIT ? ");
  uint64_t v5 = CSDBSqliteDatabaseStatementForReading();
  if (v5)
  {
    if (*(void *)(v5 + 8))
    {
      CSDBSqliteBindInt64();
      CFArrayRef v6 = (const __CFArray *)CSDBRecordStoreProcessStatement();
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = sub_100041B94(v6, *(void **)(a1 + 32));
      CSDBSqliteStatementReset();
      if (v6) {
        CFRelease(v6);
      }
    }
  }
  if (v3)
  {
    CFRelease(v3);
  }
}

uint64_t sub_100044700(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, char a5)
{
  uint64_t v15 = 0;
  CFIndex v16 = &v15;
  uint64_t v17 = 0x2020000000;
  uint64_t v18 = 0;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1000447FC;
  v8[3] = &unk_10097F1D0;
  char v14 = a5;
  uint64_t v12 = a2;
  uint64_t v13 = a3;
  char v10 = &v15;
  uint64_t v11 = a1;
  id v5 = a4;
  id v9 = v5;
  sub_1003E5C0C(v8, v5);
  uint64_t v6 = v16[3];

  _Block_object_dispose(&v15, 8);
  return v6;
}

void sub_1000447E4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1000447FC(uint64_t a1)
{
  CFMutableStringRef Mutable = CFStringCreateMutable(0, 0);
  id v3 = Mutable;
  if (*(unsigned char *)(a1 + 72)) {
    CFStringRef v4 = @"SELECT ROWID, guid, alternate_guid, account_guid, from_identifier, message_data, data, protobuf_data, destinations, data_to_encrypt, encrypt_payload, compress_payload, use_top_level_dict, wants_response, expiration_date, command, wants_delivery_status, delivery_status_context, message_uuid, priority, date, is_sent, identifier, forced_local, peer_response_identifier, expects_peer_response, wants_app_ack, non_waking, fire_and_forget, stored_size, duet_identifiers, bypass_duet, queue_one_identifier, enforce_remote_timeout, main_account_guid, pending_delete, local_destination_device_uuid, enqueued_date, message_type, skip_self, include_self, push_priority, non_cloud_waking, live_delivery, require_bluetooth, require_local_wifi, wants_progress, ignore_max_retry_count, wants_certified_delivery, original_timestamp, kt_uri_verification_map, wants_firewall_donation, send_mode, delivery_minimum_time_delay, delivery_minimum_time FROM outgoing_message ";
  }
  else {
    CFStringRef v4 = @"SELECT ROWID, guid, alternate_guid, account_guid, from_identifier, NULL AS message_data, NULL AS data, NULL AS protobuf_data, destinations, NULL AS data_to_encrypt, encrypt_payload, compress_payload, use_top_level_dict, wants_response, expiration_date, command, wants_delivery_status, delivery_status_context, message_uuid, priority, date, is_sent, identifier, forced_local, peer_response_identifier, expects_peer_response, wants_app_ack, non_waking, fire_and_forget, stored_size, duet_identifiers, bypass_duet, queue_one_identifier, enforce_remote_timeout, main_account_guid, pending_delete, local_destination_device_uuid, enqueued_date, message_type, skip_self, include_self, push_priority, non_cloud_waking, live_delivery, require_bluetooth, require_local_wifi, wants_progress, ignore_max_retry_count, wants_certified_delivery, original_timestamp, kt_uri_verification_map, wants_firewall_donation, send_mode, delivery_minimum_time_delay, delivery_minimum_time FROM outgoing_message ";
  }
  CFStringAppend(Mutable, v4);
  CFStringAppend(v3, @"WHERE is_sent = 0 AND pending_delete = 0 AND enqueued_date > 0 AND enqueued_date <= ? AND local_destination_device_uuid IS NOT NULL AND local_destination_device_uuid != ? LIMIT ? ");
  uint64_t v5 = CSDBSqliteDatabaseStatementForReading();
  if (v5)
  {
    if (*(void *)(v5 + 8))
    {
      CSDBSqliteBindInt64();
      CSDBSqliteBindTextFromCFString();
      CSDBSqliteBindInt64();
      CFArrayRef v6 = (const __CFArray *)CSDBRecordStoreProcessStatement();
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = sub_100041B94(v6, *(void **)(a1 + 32));
      CSDBSqliteStatementReset();
      if (v6) {
        CFRelease(v6);
      }
    }
  }
  if (v3)
  {
    CFRelease(v3);
  }
}

void sub_10004491C(int a1, void *a2)
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_100044988;
  v2[3] = &unk_10097F1F0;
  int v3 = a1;
  sub_1003E5C0C(v2, a2);
}

uint64_t sub_100044988(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return _CSDBSqliteConnectionSetIntegerForProperty(*(void *)(a3 + 8), @"InternalMigration", *(unsigned int *)(a1 + 32));
}

uint64_t sub_1000449A0(void *a1)
{
  id v1 = a1;
  uint64_t v5 = 0;
  CFArrayRef v6 = &v5;
  uint64_t v7 = 0x2020000000;
  int v8 = -1431655766;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_100044A70;
  v4[3] = &unk_10097EF68;
  void v4[4] = &v5;
  sub_1003E5C0C(v4, v1);
  uint64_t v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);

  return v2;
}

void sub_100044A58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100044A70(uint64_t a1)
{
  uint64_t result = CSDBSqliteConnectionIntegerForProperty();
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t sub_100044AAC(void *a1)
{
  id v1 = a1;
  uint64_t v5 = 0;
  CFArrayRef v6 = &v5;
  uint64_t v7 = 0x2020000000;
  int v8 = -1431655766;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_100044B7C;
  v4[3] = &unk_10097EF68;
  void v4[4] = &v5;
  sub_1003E5C0C(v4, v1);
  uint64_t v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);

  return v2;
}

void sub_100044B64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100044B7C(uint64_t a1)
{
  uint64_t result = CSDBSqliteDatabaseCheckpointAndVacuum();
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

void sub_100044BB0(void *a1)
{
}

void sub_100044BC0(id a1, CSDBRecordStore *a2, CSDBSqliteDatabase *a3)
{
}

void sub_100044BC8(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  if (_IMWillLog()) {
    _IMAlwaysLog();
  }
  unsigned int v8 = [v6 dataProtectionClass];
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  id v9 = v5;
  id v10 = [v9 countByEnumeratingWithState:&v17 objects:v21 count:16];
  if (v10)
  {
    id v11 = v10;
    uint64_t v12 = *(void *)v18;
    do
    {
      for (uint64_t i = 0; i != v11; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v18 != v12) {
          objc_enumerationMutation(v9);
        }
        char v14 = *(void **)(*((void *)&v17 + 1) + 8 * i);
        if (objc_msgSend(v14, "dataProtectionClass", (void)v17) == v8)
        {
          uint64_t v15 = [v14 guid];
          CFIndex v16 = [v14 alternateGUID];
          sub_100044D68(v15, v16, v6, v7);
        }
      }
      id v11 = [v9 countByEnumeratingWithState:&v17 objects:v21 count:16];
    }
    while (v11);
  }
}

void sub_100044D68(const __CFString *a1, const void *a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  if (_IMWillLog()) {
    _IMAlwaysLog();
  }
  if (a1 && CFStringGetLength(a1))
  {
    if (a2) {
      CFStringRef v9 = @"SELECT ROWID, guid, alternate_guid, account_guid, from_identifier, message_data, data, protobuf_data, destinations, data_to_encrypt, encrypt_payload, compress_payload, use_top_level_dict, wants_response, expiration_date, command, wants_delivery_status, delivery_status_context, message_uuid, priority, date, is_sent, identifier, forced_local, peer_response_identifier, expects_peer_response, wants_app_ack, non_waking, fire_and_forget, stored_size, duet_identifiers, bypass_duet, queue_one_identifier, enforce_remote_timeout, main_account_guid, pending_delete, local_destination_device_uuid, enqueued_date, message_type, skip_self, include_self, push_priority, non_cloud_waking, live_delivery, require_bluetooth, require_local_wifi, wants_progress, ignore_max_retry_count, wants_certified_delivery, original_timestamp, kt_uri_verification_map, wants_firewall_donation, send_mode, delivery_minimum_time_delay, delivery_minimum_time FROM outgoing_message WHERE guid = ? AND alternate_guid = ? ORDER BY ROWID ASC;";
    }
    else {
      CFStringRef v9 = @"SELECT ROWID, guid, alternate_guid, account_guid, from_identifier, message_data, data, protobuf_data, destinations, data_to_encrypt, encrypt_payload, compress_payload, use_top_level_dict, wants_response, expiration_date, command, wants_delivery_status, delivery_status_context, message_uuid, priority, date, is_sent, identifier, forced_local, peer_response_identifier, expects_peer_response, wants_app_ack, non_waking, fire_and_forget, stored_size, duet_identifiers, bypass_duet, queue_one_identifier, enforce_remote_timeout, main_account_guid, pending_delete, local_destination_device_uuid, enqueued_date, message_type, skip_self, include_self, push_priority, non_cloud_waking, live_delivery, require_bluetooth, require_local_wifi, wants_progress, ignore_max_retry_count, wants_certified_delivery, original_timestamp, kt_uri_verification_map, wants_firewall_donation, send_mode, delivery_minimum_time_delay, delivery_minimum_time FROM outgoing_message WHERE guid = ? ORDER BY ROWID ASC;";
    }
    uint64_t v16 = 0;
    long long v17 = &v16;
    uint64_t v18 = 0x2020000000;
    char v19 = 0;
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472;
    v15[2] = sub_100044F3C;
    v15[3] = &unk_10097EEF0;
    v15[5] = a1;
    v15[6] = a2;
    void v15[4] = &v16;
    sub_1003E5C84((uint64_t)v9, v15, v7);
    if (!*((unsigned char *)v17 + 24))
    {
      CFRetain(a1);
      if (a2) {
        CFRetain(a2);
      }
      v10[0] = _NSConcreteStackBlock;
      v10[1] = 3221225472;
      v10[2] = sub_100045018;
      v10[3] = &unk_10097F280;
      CFStringRef v13 = a1;
      char v14 = a2;
      id v11 = v8;
      id v12 = v7;
      sub_1003E5954(v10, 0, v11);
    }
    _Block_object_dispose(&v16, 8);
  }
}

void sub_100044F24(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100044F3C(uint64_t a1, uint64_t a2)
{
  CSDBSqliteBindTextFromCFString();
  if (*(void *)(a1 + 48)) {
    CSDBSqliteBindTextFromCFString();
  }
  CFArrayRef v4 = (const __CFArray *)CSDBRecordStoreProcessStatement();
  int Count = CFArrayGetCount(v4);
  if (Count >= 1)
  {
    CFIndex v6 = 0;
    uint64_t v7 = Count;
    do
    {
      CFArrayGetValueAtIndex(v4, v6);
      CSDBRecordStoreRemoveRecord();
      ++v6;
    }
    while (v7 != v6);
  }
  CFRelease(v4);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CSDBRecordSaveStore();

  return _CSDBRecordStoreInvalidateCachesWithStore(a2);
}

void sub_100045018(uint64_t a1)
{
  if (_IMWillLog())
  {
    uint64_t v6 = *(void *)(a1 + 48);
    uint64_t v7 = *(void *)(a1 + 56);
    _IMAlwaysLog();
  }
  objc_msgSend(*(id *)(a1 + 32), "ensureDatabaseIsInitialized", v6, v7);
  if (*(void *)(a1 + 56)) {
    uint64_t v2 = ", alternate_guid) VALUES (?, ?, ?)";
  }
  else {
    uint64_t v2 = ") VALUES (?, ?)";
  }
  CFStringRef v3 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("INSERT OR IGNORE INTO outgoing_messages_to_delete (data_protection_class, guid%s;"),
         v2);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_100045148;
  v8[3] = &unk_10097F258;
  id v9 = *(id *)(a1 + 40);
  long long v10 = *(_OWORD *)(a1 + 48);
  sub_1003E5D0C((uint64_t)v3, v8, *(void **)(a1 + 32));
  CFRelease(v3);
  CFArrayRef v4 = *(const void **)(a1 + 48);
  if (v4) {
    CFRelease(v4);
  }
  id v5 = *(const void **)(a1 + 56);
  if (v5) {
    CFRelease(v5);
  }
}

uint64_t sub_100045148(uint64_t a1)
{
  [*(id *)(a1 + 32) dataProtectionClass];
  CSDBSqliteBindInt();
  CSDBSqliteBindTextFromCFString();
  if (*(void *)(a1 + 48)) {
    CSDBSqliteBindTextFromCFString();
  }
  uint64_t result = CSDBSqliteStatementPerform();
  if (result != 101)
  {
    uint64_t result = _IMWillLog();
    if (result)
    {
      return _IMAlwaysLog();
    }
  }
  return result;
}

void sub_1000451EC(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (_IMWillLog()) {
    _IMAlwaysLog();
  }
  if (a1)
  {
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472;
    v4[2] = sub_1000452AC;
    v4[3] = &unk_10097F2A0;
    void v4[4] = a1;
    sub_1003E5C84(@"SELECT ROWID, guid, alternate_guid, account_guid, from_identifier, message_data, data, protobuf_data, destinations, data_to_encrypt, encrypt_payload, compress_payload, use_top_level_dict, wants_response, expiration_date, command, wants_delivery_status, delivery_status_context, message_uuid, priority, date, is_sent, identifier, forced_local, peer_response_identifier, expects_peer_response, wants_app_ack, non_waking, fire_and_forget, stored_size, duet_identifiers, bypass_duet, queue_one_identifier, enforce_remote_timeout, main_account_guid, pending_delete, local_destination_device_uuid, enqueued_date, message_type, skip_self, include_self, push_priority, non_cloud_waking, live_delivery, require_bluetooth, require_local_wifi, wants_progress, ignore_max_retry_count, wants_certified_delivery, original_timestamp, kt_uri_verification_map, wants_firewall_donation, send_mode, delivery_minimum_time_delay, delivery_minimum_time FROM outgoing_message WHERE queue_one_identifier = ? ORDER BY ROWID ASC;",
      v4,
      v3);
  }
}

uint64_t sub_1000452AC(uint64_t a1, uint64_t a2)
{
  CSDBSqliteBindTextFromCFString();
  CFArrayRef v3 = (const __CFArray *)CSDBRecordStoreProcessStatement();
  int Count = CFArrayGetCount(v3);
  if (Count >= 1)
  {
    CFIndex v5 = 0;
    uint64_t v6 = Count;
    do
    {
      CFArrayGetValueAtIndex(v3, v5);
      CSDBRecordStoreRemoveRecord();
      ++v5;
    }
    while (v6 != v5);
  }
  CFRelease(v3);
  CSDBRecordSaveStore();

  return _CSDBRecordStoreInvalidateCachesWithStore(a2);
}

void sub_100045360(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (_IMWillLog()) {
    _IMAlwaysLog();
  }
  if (a1)
  {
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472;
    v4[2] = sub_100045420;
    v4[3] = &unk_10097F2A0;
    void v4[4] = a1;
    sub_1003E5D0C(@"DELETE FROM outgoing_message WHERE account_guid = ? ", v4, v3);
  }
}

uint64_t sub_100045420()
{
  CSDBSqliteBindTextFromCFString();

  return CSDBSqliteStatementPerform();
}

void sub_100045460(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,void *a57)
{
  id v65 = a57;
  v66 = v65;
  if (a1)
  {
    v67[0] = _NSConcreteStackBlock;
    v67[1] = 3221225472;
    v67[2] = sub_100045858;
    v67[3] = &unk_10097F2F0;
    uint64_t v69 = a1;
    uint64_t v71 = a3;
    uint64_t v72 = a4;
    uint64_t v73 = a5;
    uint64_t v74 = a6;
    uint64_t v75 = a7;
    uint64_t v76 = a8;
    uint64_t v77 = a9;
    uint64_t v78 = a10;
    uint64_t v79 = a11;
    uint64_t v80 = a12;
    uint64_t v81 = a13;
    uint64_t v82 = a14;
    uint64_t v83 = a15;
    uint64_t v84 = a16;
    uint64_t v85 = a17;
    uint64_t v86 = a18;
    uint64_t v87 = a19;
    uint64_t v88 = a20;
    uint64_t v89 = a21;
    uint64_t v90 = a22;
    uint64_t v91 = a23;
    uint64_t v92 = a24;
    uint64_t v93 = a25;
    uint64_t v94 = a26;
    uint64_t v95 = a27;
    uint64_t v96 = a28;
    id v68 = v65;
    uint64_t v70 = a2;
    uint64_t v97 = a29;
    uint64_t v98 = a30;
    uint64_t v99 = a31;
    uint64_t v100 = a32;
    uint64_t v101 = a33;
    uint64_t v102 = a34;
    uint64_t v103 = a35;
    uint64_t v104 = a36;
    uint64_t v105 = a37;
    uint64_t v106 = a38;
    uint64_t v107 = a39;
    uint64_t v108 = a40;
    uint64_t v109 = a41;
    uint64_t v110 = a42;
    uint64_t v111 = a43;
    uint64_t v112 = a44;
    uint64_t v113 = a45;
    uint64_t v114 = a46;
    uint64_t v115 = a47;
    uint64_t v116 = a48;
    uint64_t v117 = a49;
    uint64_t v118 = a50;
    uint64_t v119 = a51;
    uint64_t v120 = a52;
    uint64_t v121 = a53;
    uint64_t v122 = a54;
    uint64_t v123 = a55;
    uint64_t v124 = a56;
    sub_1003E5A34(a1 + 16, v67, v68);
  }
  else
  {
    _IMWarn();
  }
}

void sub_100045858(uint64_t a1)
{
  uint64_t v2 = sub_100040EB8(*(void *)(*(void *)(a1 + 40) + 24), *(void **)(a1 + 32));
  if (v2)
  {
    id v3 = (const void *)v2;
    if (*(void *)(a1 + 48)) {
      **(void **)(a1 + 48) = (int)CSDBRecordGetID();
    }
    if (*(void *)(a1 + 56)) {
      **(void **)(a1 + 56) = CSDBRecordCopyProperty();
    }
    if (*(void *)(a1 + 64)) {
      **(void **)(a1 + 64) = CSDBRecordCopyProperty();
    }
    if (*(void *)(a1 + 72)) {
      **(void **)(a1 + 72) = CSDBRecordCopyProperty();
    }
    if (*(void *)(a1 + 80)) {
      **(void **)(a1 + 80) = CSDBRecordCopyProperty();
    }
    if (*(void *)(a1 + 88)) {
      **(void **)(a1 + 88) = CSDBRecordCopyProperty();
    }
    if (*(void *)(a1 + 96)) {
      **(void **)(a1 + 96) = CSDBRecordCopyProperty();
    }
    if (*(void *)(a1 + 104)) {
      **(void **)(a1 + 104) = CSDBRecordCopyProperty();
    }
    if (*(void *)(a1 + 112)) {
      **(void **)(a1 + 112) = CSDBRecordCopyProperty();
    }
    if (*(void *)(a1 + 120)) {
      **(void **)(a1 + 120) = CSDBRecordCopyProperty();
    }
    if (*(void *)(a1 + 128)) {
      **(unsigned char **)(a1 + 128) = CSDBRecordGetProperty() != 0;
    }
    if (*(void *)(a1 + 136)) {
      **(unsigned char **)(a1 + 136) = CSDBRecordGetProperty() != 0;
    }
    if (*(void *)(a1 + 144)) {
      **(unsigned char **)(a1 + 144) = CSDBRecordGetProperty() != 0;
    }
    if (*(void *)(a1 + 152)) {
      **(unsigned char **)(a1 + 152) = CSDBRecordGetProperty() != 0;
    }
    if (*(void *)(a1 + 160)) {
      **(void **)(a1 + 160) = CSDBRecordGetProperty();
    }
    if (*(void *)(a1 + 168)) {
      **(void **)(a1 + 168) = CSDBRecordGetProperty();
    }
    if (*(void *)(a1 + 176)) {
      **(unsigned char **)(a1 + 176) = CSDBRecordGetProperty() != 0;
    }
    if (*(void *)(a1 + 184)) {
      **(void **)(a1 + 184) = CSDBRecordCopyProperty();
    }
    if (*(void *)(a1 + 192)) {
      **(void **)(a1 + 192) = CSDBRecordCopyProperty();
    }
    if (*(void *)(a1 + 200)) {
      **(void **)(a1 + 200) = CSDBRecordGetProperty();
    }
    if (*(void *)(a1 + 208)) {
      **(void **)(a1 + 208) = CSDBRecordGetProperty();
    }
    if (*(void *)(a1 + 216)) {
      **(unsigned char **)(a1 + 216) = CSDBRecordGetProperty() != 0;
    }
    if (*(void *)(a1 + 224)) {
      **(void **)(a1 + 224) = CSDBRecordCopyProperty();
    }
    if (*(void *)(a1 + 232)) {
      **(unsigned char **)(a1 + 232) = CSDBRecordGetProperty() != 0;
    }
    if (*(void *)(a1 + 240)) {
      **(void **)(a1 + 240) = CSDBRecordCopyProperty();
    }
    if (*(void *)(a1 + 248)) {
      **(unsigned char **)(a1 + 248) = CSDBRecordGetProperty() != 0;
    }
    if (*(void *)(a1 + 256)) {
      **(unsigned char **)(a1 + 256) = CSDBRecordGetProperty() != 0;
    }
    if (*(void *)(a1 + 264)) {
      **(unsigned char **)(a1 + 264) = CSDBRecordGetProperty() != 0;
    }
    if (*(void *)(a1 + 272)) {
      **(unsigned char **)(a1 + 272) = CSDBRecordGetProperty() != 0;
    }
    if (*(void *)(a1 + 280)) {
      **(unsigned char **)(a1 + 280) = CSDBRecordGetProperty() != 0;
    }
    if (*(void *)(a1 + 288)) {
      **(void **)(a1 + 288) = CSDBRecordGetProperty();
    }
    if (*(void *)(a1 + 296)) {
      **(void **)(a1 + 296) = CSDBRecordCopyProperty();
    }
    if (*(void *)(a1 + 304)) {
      **(unsigned char **)(a1 + 304) = CSDBRecordGetProperty() != 0;
    }
    if (*(void *)(a1 + 312)) {
      **(void **)(a1 + 312) = CSDBRecordCopyProperty();
    }
    if (*(void *)(a1 + 320)) {
      **(unsigned char **)(a1 + 320) = CSDBRecordGetProperty() != 0;
    }
    if (*(void *)(a1 + 328)) {
      **(void **)(a1 + 328) = CSDBRecordCopyProperty();
    }
    if (*(void *)(a1 + 336)) {
      **(unsigned char **)(a1 + 336) = CSDBRecordGetProperty() != 0;
    }
    if (*(void *)(a1 + 344)) {
      **(void **)(a1 + 344) = CSDBRecordCopyProperty();
    }
    if (*(void *)(a1 + 352))
    {
      **(void **)(a1 + 352) = CSDBRecordGetProperty();
      **(void **)(a1 + 352) = CSDBRecordGetProperty();
    }
    if (*(void *)(a1 + 360)) {
      **(void **)(a1 + 360) = CSDBRecordGetProperty();
    }
    if (*(void *)(a1 + 368)) {
      **(unsigned char **)(a1 + 368) = CSDBRecordGetProperty() != 0;
    }
    if (*(void *)(a1 + 376)) {
      **(unsigned char **)(a1 + 376) = CSDBRecordGetProperty() != 0;
    }
    if (*(void *)(a1 + 384)) {
      **(void **)(a1 + 384) = CSDBRecordGetProperty();
    }
    if (*(void *)(a1 + 392)) {
      **(unsigned char **)(a1 + 392) = CSDBRecordGetProperty() != 0;
    }
    if (*(void *)(a1 + 400)) {
      **(unsigned char **)(a1 + 400) = CSDBRecordGetProperty() != 0;
    }
    if (*(void *)(a1 + 408)) {
      **(unsigned char **)(a1 + 408) = CSDBRecordGetProperty() != 0;
    }
    if (*(void *)(a1 + 416)) {
      **(unsigned char **)(a1 + 416) = CSDBRecordGetProperty() != 0;
    }
    if (*(void *)(a1 + 424)) {
      **(unsigned char **)(a1 + 424) = CSDBRecordGetProperty() != 0;
    }
    if (*(void *)(a1 + 432)) {
      **(unsigned char **)(a1 + 432) = CSDBRecordGetProperty() != 0;
    }
    if (*(void *)(a1 + 440)) {
      **(void **)(a1 + 440) = CSDBRecordGetProperty();
    }
    if (*(void *)(a1 + 448)) {
      **(void **)(a1 + 448) = CSDBRecordCopyProperty();
    }
    if (*(void *)(a1 + 456)) {
      **(unsigned char **)(a1 + 456) = CSDBRecordGetProperty() != 0;
    }
    if (*(void *)(a1 + 464)) {
      **(void **)(a1 + 464) = CSDBRecordGetProperty();
    }
    if (*(void *)(a1 + 472)) {
      **(void **)(a1 + 472) = CSDBRecordGetProperty();
    }
    if (*(void *)(a1 + 480)) {
      **(void **)(a1 + 480) = CSDBRecordGetProperty();
    }
    CFRelease(v3);
  }
}

uint64_t sub_100046068()
{
  uint64_t v0 = 0;
  qword_100A4A2A0 = _CFRuntimeRegisterClass();
  uint64_t v1 = &off_10097F370;
  do
  {
    v1 += 5;
    uint64_t result = CSDBRecordIndexOfPropertyNamed();
    dword_100A4A2A8[v0++] = result;
  }
  while (v0 != 54);
  return result;
}

uint64_t sub_1000460D8(uint64_t result)
{
  *(void *)(result + 24) = -1;
  return result;
}

void sub_1000460E4(uint64_t a1)
{
  uint64_t v2 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  *(void *)(a1 + 24) = -1;

  os_unfair_lock_unlock(v2);
}

BOOL sub_10004612C(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 24) == *(void *)(a2 + 24);
}

uint64_t sub_100046140(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

CFStringRef sub_100046148(os_unfair_lock_s *a1)
{
  uint64_t v2 = a1 + 4;
  os_unfair_lock_lock(a1 + 4);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFAllocatorRef v4 = CFGetAllocator(a1);
  CFStringRef v5 = CFStringCreateWithFormat(v3, 0, @"<IDSOutgoingMessageRecord %p [%p]>{}", a1, v4);
  os_unfair_lock_unlock(v2);
  return v5;
}

void sub_10004671C(uint64_t a1)
{
  [*(id *)(a1 + 32) doubleValue];
  double v3 = v2;
  [*(id *)(a1 + 40) doubleValue];
  unint64_t v55 = llround((v3 - v4) * 1000.0);
  [*(id *)(a1 + 48) doubleValue];
  double v6 = v5;
  [*(id *)(a1 + 40) doubleValue];
  unint64_t v54 = llround((v6 - v7) * 1000.0);
  [*(id *)(a1 + 56) doubleValue];
  double v9 = v8;
  [*(id *)(a1 + 48) doubleValue];
  uint64_t v11 = llround((v9 - v10) * 1000.0);
  [*(id *)(a1 + 64) doubleValue];
  double v13 = v12;
  [*(id *)(a1 + 32) doubleValue];
  uint64_t v15 = llround((v13 - v14) * 1000.0);
  [*(id *)(a1 + 48) doubleValue];
  double v17 = v16;
  [*(id *)(a1 + 64) doubleValue];
  unint64_t v19 = llround((v17 - v18) * 1000.0);
  [*(id *)(a1 + 56) doubleValue];
  double v21 = v20;
  [*(id *)(a1 + 64) doubleValue];
  uint64_t v23 = llround((v21 - v22) * 1000.0);
  [*(id *)(a1 + 56) doubleValue];
  double v25 = v24;
  [*(id *)(a1 + 72) doubleValue];
  uint64_t v27 = llround((v25 - v26) * 1000.0);
  uint64_t v28 = v15 & ~(v15 >> 63);
  uint64_t v29 = v11 & ~(v11 >> 63);
  uint64_t v30 = v27 & ~(v27 >> 63);
  uint64_t v31 = *(void *)(a1 + 56);
  uint64_t v53 = v23 & ~(v23 >> 63);
  if (v31) {
    uint64_t v32 = v23 & ~(v23 >> 63);
  }
  else {
    uint64_t v32 = -1;
  }
  if (v31) {
    uint64_t v33 = v27 & ~(v27 >> 63);
  }
  else {
    uint64_t v33 = -1;
  }
  if (v31) {
    uint64_t v34 = v29;
  }
  else {
    uint64_t v34 = -1;
  }
  uint64_t v35 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
  {
    int v36 = *(unsigned __int8 *)(a1 + 96);
    *(_DWORD *)buf = 134219778;
    if (v36) {
      CFStringRef v37 = @"YES";
    }
    else {
      CFStringRef v37 = @"NO";
    }
    unint64_t v57 = v55;
    __int16 v58 = 2048;
    unint64_t v59 = v54;
    __int16 v60 = 2048;
    uint64_t v61 = v34;
    __int16 v62 = 2048;
    uint64_t v63 = v28;
    __int16 v64 = 2048;
    unint64_t v65 = v19;
    __int16 v66 = 2048;
    uint64_t v67 = v32;
    __int16 v68 = 2048;
    uint64_t v69 = v33;
    __int16 v70 = 2112;
    CFStringRef v71 = v37;
    _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "IDSDeviceConnectionForService - clientInitToDaemonOpenSocket %lldms, clientInitToClientOpenSocketHandler %lldms, clientOpenSocketHandlerToIncomingFirstPacket %lldms, daemonOpenSocketToDaemonCompletionHandler %lldms, daemonCompletionHandlerToClientOpenSocketCompletion %lldms, daemonCompletionHandlerToIncomingFirstPacket %lldms, connectionInitToIncomingFirstPacket %lldms, success %@", buf, 0x52u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
  {
    id v38 = *(unsigned char *)(a1 + 96) ? @"YES" : @"NO";
    uint64_t v51 = v33;
    v52 = v38;
    unint64_t v49 = v19;
    uint64_t v50 = v32;
    uint64_t v47 = v34;
    uint64_t v48 = v28;
    unint64_t v45 = v55;
    unint64_t v46 = v54;
    _IDSLogTransport();
    if (_IDSShouldLog())
    {
      CFStringRef v39 = @"YES";
      if (!*(unsigned char *)(a1 + 96)) {
        CFStringRef v39 = @"NO";
      }
      uint64_t v51 = v33;
      v52 = (__CFString *)v39;
      unint64_t v49 = v19;
      uint64_t v50 = v32;
      uint64_t v47 = v34;
      uint64_t v48 = v28;
      unint64_t v45 = v55;
      unint64_t v46 = v54;
      _IDSLogV();
    }
  }
  v40 = objc_msgSend(*(id *)(a1 + 80), "_metricContainerForMetricType:", 2555932, v45, v46, v47, v48, v49, v50, v51, v52);
  if (v40)
  {
    id v41 = objc_alloc_init((Class)IMWeakLinkClass());
    uint64_t v42 = *(void **)(a1 + 88);
    if (v42)
    {
      BOOL v43 = v31 == 0;
      id v44 = [v42 copy];
      [v41 setServiceName:v44];

      [v41 setSuccess:*(unsigned __int8 *)(a1 + 96)];
      [v41 setClientInitToDaemonOpenSocket:v55];
      [v41 setClientInitToClientOpenSocketHandler:v54];
      [v41 setDaemonOpenSocketToDaemonCompletionHandler:v28];
      [v41 setDaemonCompletionHandlerToClientOpenSocketCompletion:v19];
      if (!v43)
      {
        [v41 setConnectionInitToIncomingFirstPacket:v30];
        [v41 setClientOpenSocketHandlerToIncomingFirstPacket:v29];
        [v41 setDaemonCompletionHandlerToIncomingFirstPacket:v53];
      }
      [*(id *)(a1 + 80) _submitAWDMetric:v41 withContainer:v40];
    }
  }
}

void sub_100047470(void *a1)
{
  double v2 = +[IDSFoundationLog delivery_oversized];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = a1[5];
    uint64_t v5 = a1[6];
    int v6 = 138412802;
    uint64_t v7 = v3;
    __int16 v8 = 2112;
    uint64_t v9 = v4;
    __int16 v10 = 2112;
    uint64_t v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "GUID %@ Fanout %@ contains:\n%@", (uint8_t *)&v6, 0x20u);
  }
}

void sub_10004954C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 state] == (id)1)
  {
    uint64_t v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = [v3 error];
      *(_DWORD *)buf = 138412290;
      uint64_t v31 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "   Public/Private decryption failed with error: %@", buf, 0xCu);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      unint64_t v19 = [v3 error];
      _IDSLogV();
    }
    double v26 = objc_msgSend(*(id *)(a1 + 32), "previousFullDeviceIdentityContainer", v19);
    if (v26)
    {
      int v6 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        uint64_t v31 = v26;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Using previous full identity: %@", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        double v20 = v26;
        _IDSLogV();
      }
      uint64_t v21 = *(void *)(a1 + 48);
      double v24 = objc_msgSend(*(id *)(a1 + 56), "authenticatedData", v20);
      id v7 = [*(id *)(a1 + 56) messageType];
      uint64_t v23 = [*(id *)(a1 + 56) guid];
      double v25 = [*(id *)(a1 + 56) sendingURI];
      double v22 = [v25 prefixedURI];
      __int16 v8 = [*(id *)(a1 + 56) sendingPushToken];
      uint64_t v9 = [v8 rawToken];
      __int16 v10 = [*(id *)(a1 + 56) receivingURI];
      uint64_t v11 = [v10 prefixedURI];
      double v12 = [*(id *)(a1 + 56) receivingPushToken];
      double v13 = [v12 rawToken];
      double v14 = [v26 unsealMessage:v21 authenticatedData:v24 messageType:v7 guid:v23 sendingURI:v22 sendingPushToken:v9 receivingURI:v11 receivingPushToken:v13 signedByPublicIdentity:*(void *)(a1 + 64) usingIdentityWithIdentifier:*(void *)(a1 + 72)];
      v27[0] = _NSConcreteStackBlock;
      v27[1] = 3221225472;
      v27[2] = sub_100049964;
      v27[3] = &unk_10097FC10;
      id v28 = *(id *)(a1 + 40);
      id v29 = v3;
      [v14 registerResultBlock:v27];

      uint64_t v15 = v28;
    }
    else
    {
      double v18 = *(void **)(a1 + 40);
      uint64_t v15 = [v3 error];
      [v18 failWithError:v15];
    }
  }
  else
  {
    double v16 = *(void **)(a1 + 40);
    double v17 = [v3 value];
    [v16 fulfillWithValue:v17];
  }
}

void sub_100049964(uint64_t a1, void *a2)
{
  id v6 = a2;
  id v3 = [v6 state];
  uint64_t v4 = *(void **)(a1 + 32);
  if (v3 == (id)1)
  {
    uint64_t v5 = [*(id *)(a1 + 40) error];
    [v4 failWithError:v5];
  }
  else
  {
    uint64_t v5 = [v6 value];
    [v4 fulfillWithValue:v5];
  }
}

void sub_10004A35C(id a1)
{
  qword_100A4A380 = IMWeakLinkClass();
}

id sub_10004AF3C(uint64_t a1, void *a2)
{
  id v3 = a2;
  [*(id *)(a1 + 32) setAggregatableMessages:v3];
  id v4 = objc_alloc_init((Class)NSMutableDictionary);
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  id v5 = v3;
  id v6 = [v5 countByEnumeratingWithState:&v20 objects:v26 count:16];
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v21;
    do
    {
      for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v21 != v8) {
          objc_enumerationMutation(v5);
        }
        __int16 v10 = *(void **)(*((void *)&v20 + 1) + 8 * i);
        uint64_t v11 = [v10 targetPeerID];
        double v12 = [v10 targetToken];
        double v13 = [v11 URIByAddingPushToken:v12];

        if (v13) {
          [v4 setObject:v10 forKey:v13];
        }
      }
      id v7 = [v5 countByEnumeratingWithState:&v20 objects:v26 count:16];
    }
    while (v7);
  }

  double v14 = +[IDSFoundationLog delivery];
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 138412290;
    uint64_t v25 = v15;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "GUID %@ finished constructing aggregatable messages", buf, 0xCu);
  }

  unint64_t v19 = +[NSString stringWithFormat:@"GUID %@ Message to send per destination:\n%@", *(void *)(a1 + 40), v4];
  id v16 = v19;
  cut_dispatch_log_queue();
  double v17 = +[CUTUnsafePromise fulfilledPromiseWithValue:*(void *)(a1 + 32)];

  return v17;
}

void sub_10004B1C0(uint64_t a1)
{
  double v2 = +[IDSFoundationLog delivery_oversized];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = 136315651;
    id v5 = "IDSIMLMessageFactoryComponent.m";
    __int16 v6 = 1024;
    int v7 = 72;
    __int16 v8 = 2113;
    uint64_t v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%s:%d %{private}@", (uint8_t *)&v4, 0x1Cu);
  }
}

void sub_10004C2D8(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x12u);
}

void sub_10004C2F8(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x12u);
}

void sub_10004C930(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 state])
  {
    uint64_t v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      id v5 = [v3 error];
      *(_DWORD *)buf = 138412290;
      uint64_t v9 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Failed to setup RTCReporting to report EC metric { error: %@ }", buf, 0xCu);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      int v7 = [v3 error];
      _IDSLogV();
    }
  }
  else
  {
    __int16 v6 = [v3 value];
    [v6 sendMessageWithCategory:32 type:97 payload:*(void *)(a1 + 32) error:0];
  }
}

void sub_10004D72C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 state])
  {
    uint64_t v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      id v5 = [v3 error];
      *(_DWORD *)buf = 138412290;
      uint64_t v9 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Failed to setup RTCReporting to report EC metric { error: %@ }", buf, 0xCu);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      int v7 = [v3 error];
      _IDSLogV();
    }
  }
  else
  {
    __int16 v6 = [v3 value];
    [v6 sendMessageWithCategory:32 type:97 payload:*(void *)(a1 + 32) error:0];
  }
}

void sub_10004D8A4(void *a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = +[IMRGLog registration];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = a1[4];
    CFStringRef v7 = @"YES";
    if (a1[5]) {
      CFStringRef v8 = @"YES";
    }
    else {
      CFStringRef v8 = @"NO";
    }
    if (!a1[6]) {
      CFStringRef v7 = @"NO";
    }
    int v9 = 138413058;
    uint64_t v10 = v6;
    __int16 v11 = 2112;
    CFStringRef v12 = v8;
    __int16 v13 = 2112;
    CFStringRef v14 = v7;
    __int16 v15 = 2112;
    id v16 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Finished capturing AutoBugCapture diagnostics for decryption failure { context: %@, legacySuccess: %@, ECSuccess: %@, error: %@ }", (uint8_t *)&v9, 0x2Au);
  }
}

void sub_10004D9A8(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = +[IMRGLog registration];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 32);
    if (*(void *)(a1 + 40)) {
      CFStringRef v7 = @"YES";
    }
    else {
      CFStringRef v7 = @"NO";
    }
    int v8 = 138412802;
    uint64_t v9 = v6;
    __int16 v10 = 2112;
    CFStringRef v11 = v7;
    __int16 v12 = 2112;
    id v13 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Finished capturing AutoBugCapture diagnostics for decryption failure { context: %@, secondarySuccess: %@, error: %@ }", (uint8_t *)&v8, 0x20u);
  }
}

BOOL sub_10004E8EC(id a1, OS_nw_frame *a2)
{
  return 1;
}

void sub_10005034C(id a1)
{
  dword_100A4A3C0 = 4;
  qword_100A4A408 = (uint64_t)sub_1000503BC;
  qword_100A4A410 = (uint64_t)sub_100050948;
  qword_100A4A398 = objc_alloc_init(IDSClientChannelManager);

  _objc_release_x1();
}

void sub_1000503BC(uint64_t a1, uint64_t a2)
{
  if (qword_100A4A4D8 != -1) {
    dispatch_once(&qword_100A4A4D8, &stru_10097FE30);
  }
  uint64_t v3 = mach_continuous_time();
  double v4 = *(double *)&qword_100A4A4E0;
  id v5 = *(id *)(a1 + 40);
  uint64_t v6 = [v5 readHandler];
  if (v6)
  {
    uint64_t v8 = v6;
    double v9 = v4 * (double)v3;
    *(void *)&long long v7 = 134217984;
    long long v35 = v7;
    uint64_t v36 = a1;
    while ((*(unsigned int (**)(void))(*(void *)(a2 + 24) + 80))())
    {
      uint64_t v10 = nw_frame_array_first();
      if (v10)
      {
        CFStringRef v11 = (void *)v10;
        __int16 v12 = 0;
        do
        {
          id v13 = v12;
          __int16 v12 = nw_frame_array_next();

          CFStringRef v14 = (unsigned __int16 *)nw_frame_unclaimed_bytes();
          if (qword_100A4A4D8 != -1) {
            dispatch_once(&qword_100A4A4D8, &stru_10097FE30);
          }
          double v15 = *(double *)&qword_100A4A4E0 * (double)mach_continuous_time();
          if ([v5 verboseFunctionalLogging])
          {
            id v16 = +[IDSFoundationLog ClientChannelManager];
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
            {
              id v17 = objc_retainBlock((id)v8);
              *(_DWORD *)buf = 134218752;
              uint64_t v39 = 2863311530;
              __int16 v40 = 2048;
              unint64_t v41 = (unint64_t)v17;
              __int16 v42 = 2048;
              double v43 = v15 - v9;
              __int16 v44 = 2048;
              double v45 = v15;
              _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "processing data (total %lu) from client (handle %p) getInputFrameTime %0.6lf [%013.6lf]", buf, 0x2Au);
            }
          }
          uint64_t v18 = 2863311530;
          if (v5[8])
          {
            uint64_t v20 = __rev16(*v14);
            if (v20) {
              unint64_t v19 = v14 + 1;
            }
            else {
              unint64_t v19 = 0;
            }
            CFStringRef v14 = (unsigned __int16 *)((char *)v14 + (v20 + 2));
            uint64_t v18 = (-1431655768 - v20);
          }
          else
          {
            unint64_t v19 = 0;
            uint64_t v20 = 0;
          }
          int v21 = (*(uint64_t (**)(uint64_t, unsigned __int16 *, uint64_t, unsigned __int16 *, uint64_t, void))(v8 + 16))(v8, v14, v18, v19, v20, 0);
          if (qword_100A4A4D8 != -1) {
            dispatch_once(&qword_100A4A4D8, &stru_10097FE30);
          }
          uint64_t v22 = mach_continuous_time();
          double v23 = *(double *)&qword_100A4A4E0;
          nw_frame_finalize();
          id v24 = v12;

          if (qword_100A4A4D8 != -1) {
            dispatch_once(&qword_100A4A4D8, &stru_10097FE30);
          }
          uint64_t v25 = mach_continuous_time();
          double v26 = *(double *)&qword_100A4A4E0;
          if ([v5 verbosePerformanceLogging])
          {
            uint64_t v27 = +[IDSFoundationLog ClientChannelManager];
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
            {
              double v28 = v23 * (double)v22;
              double v29 = v26 * (double)v25;
              double v30 = COERCE_DOUBLE(objc_retainBlock((id)v8));
              double v31 = v30;
              *(_DWORD *)buf = 134220034;
              *(double *)&CFStringRef v32 = COERCE_DOUBLE(@"NO");
              if (v21) {
                *(double *)&CFStringRef v32 = COERCE_DOUBLE(@"YES");
              }
              uint64_t v39 = v18;
              __int16 v40 = 2048;
              unint64_t v41 = v20;
              __int16 v42 = 2048;
              double v43 = v30;
              __int16 v44 = 2112;
              double v45 = *(double *)&v32;
              __int16 v46 = 2048;
              uint64_t v47 = v36;
              __int16 v48 = 2048;
              uint64_t v49 = a2;
              __int16 v50 = 2048;
              double v51 = v28 - v15;
              __int16 v52 = 2048;
              double v53 = v29 - v28;
              __int16 v54 = 2048;
              double v55 = v28;
              _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "processing data (total %lu metadata %lu) from client (handle %p) (success %@) protocol %p output_handler %p readHandlerTime %0.6lf finalizeTime %0.6lf [%013.6lf]", buf, 0x5Cu);
            }
          }
          CFStringRef v11 = v12;
        }
        while (v12);
      }

      id v5 = *(id *)(v36 + 40);
      uint64_t v8 = [v5 readHandler];
      if (!v8) {
        goto LABEL_32;
      }
    }
    uint64_t v33 = +[IDSFoundationLog ClientChannelManager];
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      id v34 = objc_retainBlock((id)v8);
      *(_DWORD *)buf = v35;
      uint64_t v39 = (uint64_t)v34;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "input_available but no frames (handle %p)", buf, 0xCu);
    }
  }
  else
  {
LABEL_32:
    uint64_t v8 = +[IDSFoundationLog ClientChannelManager];
    if (os_log_type_enabled((os_log_t)v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)v8, OS_LOG_TYPE_DEFAULT, "input_available but no readHandler", buf, 2u);
    }
  }
}

void sub_100050948(uint64_t a1, uint64_t a2)
{
  double v4 = +[IDSFoundationLog ClientChannelManager];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 134218240;
    uint64_t v6 = a1;
    __int16 v7 = 2048;
    uint64_t v8 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "output available protocol %p output_handler %p", (uint8_t *)&v5, 0x16u);
  }
}

uint64_t sub_1000511A4(int a1, unsigned __int16 **a2, void *a3, unsigned int *a4)
{
  if (!a1)
  {
    *a3 = 0;
    *a4 = 0;
    return 1;
  }
  int v5 = a2[2];
  if (v5 > 1)
  {
    uint64_t v9 = (uint64_t)*a2;
    unsigned int v10 = __rev16(**a2);
    *a4 = v10;
    if (v10)
    {
      if (v10 > (int)v5 - 2)
      {
        CFStringRef v11 = OSLogHandleForTransportCategory();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v12 = *a4;
          *(_DWORD *)buf = 67109120;
          LODWORD(v15) = v12;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "metadataSize is bigger than the actual packet buffer size (%u)", buf, 8u);
        }

        uint64_t result = os_log_shim_legacy_logging_enabled();
        if (result)
        {
          uint64_t result = _IDSShouldLogTransport();
          if (result)
          {
            _IDSLogTransport();
            uint64_t result = _IDSShouldLog();
            if (result) {
              goto LABEL_17;
            }
          }
        }
        return result;
      }
      uint64_t v13 = v9 + 2;
    }
    else
    {
      uint64_t v13 = 0;
    }
    *a3 = v13;
    IDSLinkPacketBufferAddBufferStart();
    return 1;
  }
  uint64_t v6 = a2[2];
  __int16 v7 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    uint64_t v15 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "data should have metadata but not enough bytes (%lu)", buf, 0xCu);
  }

  uint64_t result = os_log_shim_legacy_logging_enabled();
  if (result)
  {
    uint64_t result = _IDSShouldLogTransport();
    if (result)
    {
      _IDSLogTransport();
      uint64_t result = _IDSShouldLog();
      if (result)
      {
LABEL_17:
        _IDSLogV();
        return 0;
      }
    }
  }
  return result;
}

void sub_1000519F8(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_100051A64(uint64_t a1)
{
  uint64_t v1 = *(unsigned char **)(a1 + 32);
  if (v1[9])
  {
    IDSTransportThreadRemoveSocket();
    return;
  }
  double v2 = v1;
  uint64_t v3 = (double *)&unk_100A4A000;
  if (([v2 verboseFunctionalLogging] & 1) != 0
    || [v2 verbosePerformanceLogging])
  {
    if (qword_100A4A4D8 != -1) {
      dispatch_once(&qword_100A4A4D8, &stru_10097FE30);
    }
    double v4 = *(double *)&qword_100A4A4E0 * (double)mach_continuous_time();
    int v5 = 1;
  }
  else
  {
    int v5 = 0;
    double v4 = 0.0;
  }
  unsigned int v6 = os_channel_available_slot_count();
  if (v6)
  {
    unsigned int v7 = v6;
    int v8 = 0;
    id v38 = v2;
    while (1)
    {
      double v9 = 0.0;
      if (v5)
      {
        if (qword_100A4A4D8 != -1) {
          dispatch_once(&qword_100A4A4D8, &stru_10097FE30);
        }
        double v9 = v3[156] * (double)mach_continuous_time();
      }
      *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v50 = v10;
      long long v51 = v10;
      *(_OWORD *)uint64_t v49 = v10;
      *(_OWORD *)&v49[16] = v10;
      os_channel_get_next_slot();
      uint64_t v11 = _IDSLinkPacketBufferCreate();
      uint64_t v12 = v11;
      if (*(void *)(v11 + 8) >= (unint64_t)*(unsigned __int16 *)&v49[2])
      {
        if (*(_WORD *)&v49[2])
        {
          memcpy(*(void **)v11, *(const void **)&v49[16], *(unsigned __int16 *)&v49[2]);
          *(void *)(v12 + 16) = *(unsigned __int16 *)&v49[2];
          unint64_t v40 = 0xAAAAAAAAAAAAAAAALL;
          unsigned int v39 = -1431655766;
          if (sub_1000511A4(v2[8], (unsigned __int16 **)v12, &v40, &v39))
          {
            CFStringRef v14 = [v2 packetBufferHandler];
            double v15 = 0.0;
            if (v5)
            {
              if (qword_100A4A4D8 != -1) {
                dispatch_once(&qword_100A4A4D8, &stru_10097FE30);
              }
              double v15 = v3[156] * (double)mach_continuous_time();
            }
            if (v14)
            {
              uint64_t v16 = v39;
              v14[2](v14, v12, v40, v39, 0);
              if (v5)
              {
                if (qword_100A4A4D8 != -1) {
                  dispatch_once(&qword_100A4A4D8, &stru_10097FE30);
                }
                uint64_t v36 = mach_continuous_time();
                double v17 = *(double *)&qword_100A4A4E0;
                uint64_t v18 = +[IDSFoundationLog ClientChannelManager];
                if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
                {
                  double v19 = v17 * (double)v36;
                  uint64_t v37 = *(unsigned __int16 *)&v49[2];
                  uint64_t v35 = *(void *)(v12 + 16);
                  id v20 = objc_retainBlock(v14);
                  *(_DWORD *)buf = 134219264;
                  *(void *)__int16 v42 = v37;
                  *(_WORD *)&v42[8] = 2048;
                  *(void *)&v42[10] = v35;
                  *(_WORD *)&v42[18] = 2048;
                  *(void *)&v42[20] = v16;
                  __int16 v43 = 2048;
                  id v44 = v20;
                  __int16 v45 = 2048;
                  double v46 = v15 - v9;
                  __int16 v47 = 2048;
                  double v48 = v19 - v15;
                  _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "_clientChannel_read_datagrams got slot %lu data %lu metadata %lu packetBufferHandler %p slotParseTime %0.6lf handlerCallTime %0.6lf", buf, 0x3Eu);
                }
                goto LABEL_45;
              }
            }
            else
            {
              _IDSLinkPacketBufferRelease();
              uint64_t v18 = +[IDSFoundationLog ClientChannelManager];
              if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315138;
                *(void *)__int16 v42 = "_clientChannel_read_datagrams";
                _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%s: packetBufferHandler is nil", buf, 0xCu);
              }
LABEL_45:

              double v2 = v38;
            }

            uint64_t v3 = (double *)&unk_100A4A000;
            goto LABEL_41;
          }
          uint64_t v13 = +[IDSFoundationLog ClientChannelManager];
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            CFStringRef v21 = @"YES";
            if (!v2[8]) {
              CFStringRef v21 = @"NO";
            }
            uint64_t v22 = *(void *)(v12 + 16);
            *(_DWORD *)buf = 67109634;
            *(_DWORD *)__int16 v42 = v8;
            *(_WORD *)&v42[4] = 2112;
            *(void *)&v42[6] = v21;
            *(_WORD *)&v42[14] = 2048;
            *(void *)&v42[16] = v22;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "cannot parse slot %d hasMetadata %@ length %ld", buf, 0x1Cu);
          }
        }
        else
        {
          uint64_t v13 = +[IDSFoundationLog ClientChannelManager];
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)__int16 v42 = v8;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "channel has no data in slot %d", buf, 8u);
          }
        }
      }
      else
      {
        uint64_t v13 = +[IDSFoundationLog ClientChannelManager];
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)__int16 v42 = v8;
          *(_WORD *)&v42[4] = 1024;
          *(_DWORD *)&v42[6] = *(unsigned __int16 *)&v49[2];
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "channel has too much data in slot %d length %u", buf, 0xEu);
        }
      }

      _IDSLinkPacketBufferRelease();
LABEL_41:
      if (v7 == ++v8)
      {
        int v23 = os_channel_advance_slot();
        if (v23)
        {
          int v24 = v23;
          [v2 osChannelInfoLog];
          uint64_t v25 = +[IDSFoundationLog ClientChannelManager];
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)uint64_t v49 = 67109120;
            *(_DWORD *)&v49[4] = v24;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "os_channel_advance_slot failed for read %d", v49, 8u);
          }
        }
        int v26 = os_channel_sync();
        if (v26)
        {
          int v27 = v26;
          [v2 osChannelInfoLog];
          double v28 = +[IDSFoundationLog ClientChannelManager];
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)uint64_t v49 = 67109120;
            *(_DWORD *)&v49[4] = v27;
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "os_channel_sync for RX failed %d", v49, 8u);
          }
        }
        if (v5)
        {
          if (qword_100A4A4D8 != -1) {
            dispatch_once(&qword_100A4A4D8, &stru_10097FE30);
          }
          uint64_t v29 = mach_continuous_time();
          double v30 = v3[156];
          double v31 = +[IDSFoundationLog ClientChannelManager];
          if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)uint64_t v49 = 134218240;
            *(void *)&v49[4] = v7;
            *(_WORD *)&v49[12] = 2048;
            *(double *)&v49[14] = v30 * (double)v29 - v4;
            CFStringRef v32 = "_clientChannel_read_datagrams processed %lu slots total time %0.6lf";
            uint64_t v33 = v31;
            uint32_t v34 = 22;
            goto LABEL_62;
          }
          goto LABEL_63;
        }
        goto LABEL_64;
      }
    }
  }
  [v2 osChannelInfoLog];
  double v31 = +[IDSFoundationLog ClientChannelManager];
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v49 = 0;
    CFStringRef v32 = "_clientChannel_read_datagrams gave no slots to read";
    uint64_t v33 = v31;
    uint32_t v34 = 2;
LABEL_62:
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, v32, v49, v34);
  }
LABEL_63:

LABEL_64:
}

void sub_100052224(uint64_t a1)
{
  id v2 = objc_retainBlock(*(id *)(*(void *)(a1 + 32) + 136));
  uint64_t v3 = v2;
  if (v2)
  {
    (*((void (**)(id))v2 + 2))(v2);
  }
  else
  {
    double v4 = +[IDSFoundationLog ClientChannelManager];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 32);
      int v6 = 138412290;
      uint64_t v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "clientChannel %@ has no write handler - suspend", (uint8_t *)&v6, 0xCu);
    }

    IDSTransportThreadSuspendSocket();
  }
}

void sub_1000527B4(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_100052E40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, os_unfair_lock_t lock)
{
}

void sub_100053138(uint64_t a1)
{
  id v2 = +[IDSDSessionController sharedInstance];
  [v2 cleanupSessionWithChannelDestination:*(void *)(a1 + 32) clientChannelUUID:*(void *)(a1 + 40)];
}

void sub_100053190(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    os_channel_get_fd();
    IDSTransportThreadRemoveSocket();
    os_channel_destroy();
    *(void *)(*(void *)(a1 + 32) + 88) = 0;
    os_channel_attr_destroy();
    *(void *)(*(void *)(a1 + 32) + 96) = 0;
    *(void *)(*(void *)(a1 + 32) + 104) = 0;
    os_nexus_controller_free_provider_instance();
    *(unsigned char *)(*(void *)(a1 + 32) + 9) = 1;
    id v7 = [*(id *)(a1 + 32) packetBufferHandler];
    id v4 = [objc_alloc((Class)NSString) initWithFormat:@"client %@ closed connection", *(void *)(a1 + 48)];
    id v5 = objc_msgSend(objc_alloc((Class)NSDictionary), "initWithObjectsAndKeys:", v4, NSLocalizedDescriptionKey, 0);
    id v6 = [objc_alloc((Class)NSError) initWithDomain:@"ClientChannel" code:9001 userInfo:v5];
    if (v7) {
      (*((void (**)(id, void, void, void, id))v7 + 2))(v7, 0, 0, 0, v6);
    }
  }
}

void sub_1000534B8(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_100053704(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_10005380C(id a1)
{
  mach_timebase_info info = (mach_timebase_info)0xAAAAAAAAAAAAAAAALL;
  mach_timebase_info(&info);
  LODWORD(v2) = info.denom;
  LODWORD(v1) = info.numer;
  *(double *)&qword_100A4A4E0 = (double)v1 / (double)v2 / 1000000000.0;
}

uint64_t sub_100053C08(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0) {
    return IDSTransportThreadAddSocketWithPriority();
  }
  return result;
}

void sub_100053CC0(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 40));
  [*(id *)(a1 + 32) _processBytesAvailable];
  unint64_t v2 = (os_unfair_lock_s *)(*(void *)(a1 + 32) + 40);

  os_unfair_lock_unlock(v2);
}

void sub_100053D0C(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 40));
  [*(id *)(a1 + 32) _sendToConnectedSocket];
  unint64_t v2 = (os_unfair_lock_s *)(*(void *)(a1 + 32) + 40);

  os_unfair_lock_unlock(v2);
}

void sub_1000540C4(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 40));
    [*(id *)(a1 + 32) _endSession];
    id v4 = (os_unfair_lock_s *)(*(void *)(a1 + 32) + 40);
    os_unfair_lock_unlock(v4);
  }
}

void sub_100054384(uint64_t a1, void *a2)
{
  id v7 = a2;
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();
  id v4 = *(void **)(a1 + 32);
  if (isKindOfClass)
  {
    uint64_t v5 = [v7 objectForKey:@"originalMessage"];

    id v6 = (id)v5;
  }
  else
  {
    id v6 = v7;
  }
  id v8 = v6;
  [v4 addObject:v6];
}

void sub_100054590(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_100054BA4(uint64_t a1, void *a2, uint64_t a3)
{
  id v9 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v5 = v9;
    if ([v5 shouldEncrypt]
      && *(_DWORD *)(a1 + 40) == [v5 protectionClass])
    {
      [*(id *)(a1 + 32) addIndex:a3];
    }
  }
  else
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0) {
      goto LABEL_15;
    }
    CFDictionaryRef Value = (const __CFDictionary *)v9;
    if (Value) {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Value, @"originalMessage");
    }
    CFDictionaryRef v7 = Value;
    if ([(__CFDictionary *)v7 command] == 24)
    {
      CFDictionaryRef v8 = v7;
      if ([(__CFDictionary *)v8 shouldEncrypt]
        && *(_DWORD *)(a1 + 40) == [(__CFDictionary *)v8 protectionClass])
      {
        [*(id *)(a1 + 32) addIndex:a3];
      }
    }
  }

LABEL_15:
}

void sub_100054CD0(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (objc_opt_respondsToSelector()) {
    [v3 connectionDidReachInFlightMessageLowWaterMark:*(void *)(a1 + 32)];
  }
}

void sub_10005552C(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass() & 1) != 0 && (objc_opt_respondsToSelector()) {
    objc_msgSend(v3, "connection:didReceiveData:withIdentifier:", *(void *)(a1 + 40), *(void *)(a1 + 48), objc_msgSend(*(id *)(a1 + 32), "sequenceNumber"));
  }
  if (objc_opt_respondsToSelector()) {
    [v3 connection:*(void *)(a1 + 40) didReceiveDataMessage:*(void *)(a1 + 32)];
  }
}

void sub_100055F10(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (objc_opt_respondsToSelector()) {
    [v3 connectionDidReceiveBytes:*(void *)(a1 + 32)];
  }
}

void sub_100056700(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (objc_opt_respondsToSelector()) {
    [v3 connectionDidReachInFlightMessageLowWaterMark:*(void *)(a1 + 32)];
  }
}

void sub_100056EC4(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (objc_opt_respondsToSelector()) {
    [v3 connectionBecameEmpty:*(void *)(a1 + 32)];
  }
}

void sub_100057184(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 40));
    uint64_t v4 = *(void *)(a1 + 32);
    if (!*(unsigned char *)(v4 + 140))
    {
      *(unsigned char *)(v4 + 140) = 1;
      IDSTransportThreadResumeSocketWithPriority();
      uint64_t v4 = *(void *)(a1 + 32);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(v4 + 40));
  }
}

void sub_1000573E8(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (objc_opt_respondsToSelector()) {
    [v3 connectionDidClose:*(void *)(a1 + 32)];
  }
}

void sub_1000577A0(id a1)
{
  mach_timebase_info info = (mach_timebase_info)0xAAAAAAAAAAAAAAAALL;
  mach_timebase_info(&info);
  LODWORD(v2) = info.denom;
  LODWORD(v1) = info.numer;
  *(double *)&qword_100A4A4F0 = (double)v1 / (double)v2 / 1000000000.0;
}

BOOL sub_100057A6C(id a1, ACAccount *a2)
{
  unint64_t v2 = [(ACAccount *)a2 accountPropertyForKey:@"primaryAccount"];
  unsigned __int8 v3 = [v2 BOOLValue];

  return v3;
}

BOOL sub_100057B44(id a1, ACAccount *a2)
{
  return [(ACAccount *)a2 isActive];
}

BOOL sub_100057BC8(id a1, ACAccount *a2)
{
  unint64_t v2 = [(ACAccount *)a2 accountPropertyForKey:@"primaryAccount"];
  unsigned __int8 v3 = [v2 BOOLValue];

  return v3;
}

BOOL sub_100057C88(id a1, ACAccount *a2)
{
  return [(ACAccount *)a2 isActive];
}

void sub_100057D84(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (!v6)
  {
    id v9 = [*(id *)(a1 + 32) _systemAccountRepresentationOfACAccount:v5 DSIDKey:*(void *)(a1 + 40)];
    uint64_t v11 = +[IMRGLog registration];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(void *)(a1 + 48);
      *(_DWORD *)buf = 138412546;
      uint64_t v17 = v12;
      __int16 v18 = 2112;
      id v19 = v9;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Done checking for system signed in account { identifier: %@, systemAccount: %@ }", buf, 0x16u);
    }

    uint64_t v13 = *(void *)(a1 + 56);
    if (!v13) {
      goto LABEL_9;
    }
    long long v10 = *(void (**)(void))(v13 + 16);
LABEL_8:
    v10();
LABEL_9:

    goto LABEL_10;
  }
  if (*(void *)(a1 + 56))
  {
    id v7 = objc_alloc((Class)NSError);
    NSErrorUserInfoKey v14 = NSUnderlyingErrorKey;
    id v15 = v6;
    CFDictionaryRef v8 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
    id v9 = [v7 initWithDomain:@"IDSSystemAccountAdapterErrorDomain" code:-1000 userInfo:v8];

    long long v10 = *(void (**)(void))(*(void *)(a1 + 56) + 16);
    goto LABEL_8;
  }
LABEL_10:
}

void sub_100058044(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = [*(id *)(a1 + 32) queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10005816C;
  block[3] = &unk_100980008;
  id v12 = v5;
  id v13 = v6;
  CFDictionaryRef v8 = *(void **)(a1 + 40);
  uint64_t v14 = *(void *)(a1 + 32);
  id v15 = v8;
  id v17 = *(id *)(a1 + 56);
  id v16 = *(id *)(a1 + 48);
  id v18 = *(id *)(a1 + 64);
  id v9 = v6;
  id v10 = v5;
  dispatch_async(v7, block);
}

void sub_10005816C(uint64_t a1)
{
  if (*(void *)(a1 + 32) && !*(void *)(a1 + 40))
  {
    id v5 = objc_msgSend(*(id *)(a1 + 48), "_firstAccountInStore:withType:matchingCriteria:", *(void *)(a1 + 56));
  }
  else
  {
    unint64_t v2 = +[IMRGLog registration];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = *(void *)(a1 + 64);
      uint64_t v4 = *(void *)(a1 + 40);
      int v6 = 138412546;
      uint64_t v7 = v3;
      __int16 v8 = 2112;
      uint64_t v9 = v4;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Did not find account type { identifier: %@, accountsError: %@ }", (uint8_t *)&v6, 0x16u);
    }

    id v5 = 0;
  }
  (*(void (**)(void))(*(void *)(a1 + 80) + 16))();
}

void sub_1000588AC(id a1)
{
  unint64_t v1 = *(const void **)IMWeakLinkSymbol();
  qword_100A4A500 = (uint64_t)v1;
  if (v1)
  {
    CFRetain(v1);
  }
}

void sub_1000588FC(id a1)
{
  unint64_t v1 = *(const void **)IMWeakLinkSymbol();
  qword_100A4A510 = (uint64_t)v1;
  if (v1)
  {
    CFRetain(v1);
  }
}

void sub_100058BEC(uint64_t a1)
{
  unint64_t v2 = +[IDSFoundationLog opportunistic];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v5 = *(void *)(a1 + 48);
    uint64_t v6 = *(void *)(a1 + 56);
    id v7 = [*(id *)(a1 + 64) length];
    *(_DWORD *)buf = 138413314;
    uint64_t v14 = v3;
    __int16 v15 = 2112;
    uint64_t v16 = v4;
    __int16 v17 = 2112;
    uint64_t v18 = v5;
    __int16 v19 = 2112;
    uint64_t v20 = v6;
    __int16 v21 = 2048;
    id v22 = v7;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Asked to send opportunistic data {identifier: %@, service: %@, uniqueID: %@, options: %@, dataLength: %llu}", buf, 0x34u);
  }

  __int16 v8 = *(void **)(*(void *)(a1 + 72) + 16);
  id v9 = [objc_alloc((Class)IDSOpportunisticData) initWithData:*(void *)(a1 + 64) identifier:*(void *)(a1 + 32) serviceName:*(void *)(a1 + 40) accountUniqueID:*(void *)(a1 + 48) options:*(void *)(a1 + 56)];
  id v12 = 0;
  [v8 addData:v9 withError:&v12];
  id v10 = v12;

  uint64_t v11 = *(void *)(a1 + 80);
  if (v11) {
    (*(void (**)(uint64_t, id))(v11 + 16))(v11, v10);
  }
}

void sub_100058E2C(void *a1)
{
  unint64_t v2 = +[IDSFoundationLog opportunistic];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = a1[5];
    *(_DWORD *)buf = 138412546;
    uint64_t v12 = v3;
    __int16 v13 = 2112;
    uint64_t v14 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Asked to cancel opportunistic data {identifier: %@, service: %@}", buf, 0x16u);
  }

  uint64_t v5 = a1[5];
  uint64_t v6 = *(void **)(a1[6] + 16);
  uint64_t v7 = a1[4];
  id v10 = 0;
  [v6 removeDataWithIdentifier:v7 serviceName:v5 withError:&v10];
  id v8 = v10;
  uint64_t v9 = a1[7];
  if (v9) {
    (*(void (**)(uint64_t, id))(v9 + 16))(v9, v8);
  }
}

uint64_t sub_100059120(uint64_t a1)
{
  if ([*(id *)(a1 + 32) diceRoll])
  {
    unint64_t v2 = [*(id *)(*(void *)(a1 + 32) + 16) selectDataForDestination:*(void *)(a1 + 40)];
    uint64_t v3 = +[IDSFoundationLog opportunistic];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = *(void *)(a1 + 40);
      int v7 = 138412546;
      uint64_t v8 = v4;
      __int16 v9 = 2112;
      id v10 = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Passed dice roll {destination: %@, data: %@}", (uint8_t *)&v7, 0x16u);
    }

    if (v2
      && [*(id *)(a1 + 32) sendOpportunisticData:v2 toDestination:*(void *)(a1 + 40)])
    {
      [v2 incrementSendCountForDestination:*(void *)(a1 + 40)];
      uint64_t v5 = 1;
    }
    else
    {
      uint64_t v5 = 0;
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  uint64_t result = *(void *)(a1 + 48);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(result + 16))(result, v5);
  }
  return result;
}

void sub_100059680(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = +[IDSFoundationLog opportunistic];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = *(void *)(a1 + 40);
    id v7 = [v3 idsResponseCode];
    uint64_t v8 = [v3 responseError];
    unsigned int v9 = [v3 lastCall];
    int v11 = 138413314;
    CFStringRef v10 = @"NO";
    uint64_t v12 = v5;
    __int16 v13 = 2112;
    if (v9) {
      CFStringRef v10 = @"YES";
    }
    uint64_t v14 = v6;
    __int16 v15 = 2048;
    id v16 = v7;
    __int16 v17 = 2112;
    uint64_t v18 = v8;
    __int16 v19 = 2112;
    CFStringRef v20 = v10;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Message for opportunistic data got response {identifier: %@, guid: %@, responseCode: %lu, error: %@, lastCall: %@}", (uint8_t *)&v11, 0x34u);
  }
}

void sub_1000597B4(uint64_t a1)
{
  [*(id *)(a1 + 32) sendMessageWithSendParameters:*(void *)(a1 + 40) willSendBlock:0 completionBlock:*(void *)(a1 + 80)];
  unint64_t v2 = +[IDSFoundationLog opportunistic];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 48);
    uint64_t v4 = *(void *)(a1 + 56);
    uint64_t v5 = *(void *)(a1 + 64);
    uint64_t v6 = [*(id *)(a1 + 32) uniqueID];
    uint64_t v7 = *(void *)(a1 + 72);
    *(_DWORD *)buf = 138413314;
    uint64_t v16 = v3;
    __int16 v17 = 2112;
    uint64_t v18 = v4;
    __int16 v19 = 2112;
    uint64_t v20 = v5;
    __int16 v21 = 2112;
    id v22 = v6;
    __int16 v23 = 2112;
    uint64_t v24 = v7;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Sent opportunistic message {identifier: %@, guid: %@, service: %@, accountUUID: %@, destination: %@}", buf, 0x34u);
  }
  uint64_t v8 = +[IDSDaemon sharedInstance];
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  v11[2] = sub_1000599B4;
  v11[3] = &unk_100980138;
  id v12 = *(id *)(a1 + 48);
  id v13 = *(id *)(a1 + 32);
  id v14 = *(id *)(a1 + 72);
  unsigned int v9 = [*(id *)(a1 + 32) service];
  CFStringRef v10 = [v9 pushTopic];
  [v8 enqueueBroadcast:v11 forTopic:v10 entitlement:kIDSMessagingEntitlement command:0 capabilities:kIDSListenerCapConsumesLaunchOnDemandOutgoingMessageUpdates messageContext:0];
}

void sub_1000599B4(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void **)(a1 + 40);
  id v5 = a2;
  id v8 = [v4 uniqueID];
  uint64_t v6 = [*(id *)(a1 + 48) normalizedURIStrings];
  uint64_t v7 = [v6 allObjects];
  [v5 didSendOpportunisticDataWithIdentifier:v3 onAccount:v8 toIDs:v7];
}

uint64_t sub_10005AEF4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

void sub_10005AF0C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = +[IDSFoundationLog IDSDSession];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    id v6 = [v3 idsResponseCode];
    uint64_t v7 = [v3 responseError];
    unsigned int v8 = [v3 lastCall];
    CFStringRef v9 = @"NO";
    int v11 = 138413058;
    uint64_t v12 = v5;
    __int16 v13 = 2048;
    if (v8) {
      CFStringRef v9 = @"YES";
    }
    id v14 = v6;
    __int16 v15 = 2112;
    uint64_t v16 = v7;
    __int16 v17 = 2112;
    CFStringRef v18 = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Message %@ got response code %lu error %@ lastCall %@", (uint8_t *)&v11, 0x2Au);
  }
  uint64_t v10 = *(void *)(a1 + 40);
  if (v10) {
    (*(void (**)(uint64_t, id))(v10 + 16))(v10, v3);
  }
}

void sub_10005C714(id a1)
{
  qword_100A4A518 = objc_alloc_init(IDSNanoRegistryPluginManager);

  _objc_release_x1();
}

id sub_10005C834(uint64_t a1)
{
  uint64_t v2 = objc_opt_new();
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void **)(v3 + 24);
  *(void *)(v3 + 24) = v2;

  uint64_t v5 = *(void **)(a1 + 32);

  return _[v5 _initializePlugin];
}

void sub_10005C91C(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 32) + 24) count];
  [*(id *)(*(void *)(a1 + 32) + 24) addObject:*(void *)(a1 + 40)];
  if (!v2 && [*(id *)(a1 + 32) pluginImplementsWatchDidStartAdvertising])
  {
    id v3 = [*(id *)(a1 + 32) plugin];
    [v3 watchDidStartAdvertising];
  }
}

unsigned char *sub_10005CA1C(uint64_t a1)
{
  uint64_t result = [*(id *)(a1 + 32) pluginImplementsWatchDidStartAdvertising];
  if (result)
  {
    uint64_t result = *(unsigned char **)(a1 + 32);
    if (!result[10])
    {
      id v3 = [result plugin];
      [v3 watchDidStartAdvertising];

      *(unsigned char *)(*(void *)(a1 + 32) + 10) = 1;
      uint64_t v4 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        if (*(unsigned char *)(*(void *)(a1 + 32) + 10)) {
          CFStringRef v5 = @"YES";
        }
        else {
          CFStringRef v5 = @"NO";
        }
        *(_DWORD *)buf = 138412290;
        CFStringRef v7 = v5;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Bundle {isAdvertising:%@}", buf, 0xCu);
      }

      uint64_t result = (unsigned char *)os_log_shim_legacy_logging_enabled();
      if (result)
      {
        uint64_t result = (unsigned char *)_IDSShouldLog();
        if (result) {
          return (unsigned char *)_IDSLogV();
        }
      }
    }
  }
  return result;
}

void sub_10005CC30(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 32) + 24) count];
  [*(id *)(*(void *)(a1 + 32) + 24) removeObject:*(void *)(a1 + 40)];
  if (v2 == (id)1
    && ![*(id *)(*(void *)(a1 + 32) + 24) count]
    && [*(id *)(a1 + 32) pluginImplementsWatchDidStopAdvertising])
  {
    id v3 = [*(id *)(a1 + 32) plugin];
    [v3 watchDidStopAdvertising];
  }
}

unsigned char *sub_10005CD44(uint64_t a1)
{
  uint64_t result = [*(id *)(a1 + 32) pluginImplementsWatchDidStopAdvertising];
  if (result)
  {
    uint64_t result = *(unsigned char **)(a1 + 32);
    if (result[10])
    {
      id v3 = [result plugin];
      [v3 watchDidStopAdvertising];

      *(unsigned char *)(*(void *)(a1 + 32) + 10) = 0;
      uint64_t v4 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        if (*(unsigned char *)(*(void *)(a1 + 32) + 10)) {
          CFStringRef v5 = @"YES";
        }
        else {
          CFStringRef v5 = @"NO";
        }
        *(_DWORD *)buf = 138412290;
        CFStringRef v7 = v5;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Bundle {isAdvertising:%@}", buf, 0xCu);
      }

      uint64_t result = (unsigned char *)os_log_shim_legacy_logging_enabled();
      if (result)
      {
        uint64_t result = (unsigned char *)_IDSShouldLog();
        if (result) {
          return (unsigned char *)_IDSLogV();
        }
      }
    }
  }
  return result;
}

id sub_10005CF30(uint64_t a1)
{
  return [*(id *)(a1 + 32) _initializePluginWithClass:*(void *)(a1 + 40)];
}

uint64_t sub_10005CFD8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10005DC78(id a1)
{
  qword_100A4A530 = objc_alloc_init(IDSHeartbeatCenter);

  _objc_release_x1();
}

void sub_10005DD6C(id a1, IDSHeartbeatCenter *a2)
{
}

void sub_10005E1D8(id a1)
{
  off_100A4A538 = (_UNKNOWN *)IMWeakLinkSymbol();
}

id sub_10005EFB4(uint64_t a1)
{
  return [*(id *)(a1 + 32) _serverHeartBeatTimerHit:*(void *)(a1 + 40)];
}

void sub_100060E58(uint64_t a1)
{
  id v2 = +[IDSWPLinkManager sharedInstance];
  [v2 addConnectivityDelegate:*(void *)(a1 + 32)];
}

uint64_t sub_10006129C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

void sub_100061454(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  if (*(unsigned char *)(a1 + 48))
  {
    id v2 = [*(id *)(a1 + 32) cloudConnection];

    if (v2)
    {
      uint64_t v3 = *(void *)(a1 + 40);
      id v4 = [*(id *)(a1 + 32) cloudConnection];
      (*(void (**)(uint64_t, id))(v3 + 16))(v3, v4);
    }
  }
}

void sub_10006169C(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  if (*(unsigned char *)(a1 + 48))
  {
    id v2 = [*(id *)(a1 + 32) cloudConnection];

    if (v2)
    {
      uint64_t v3 = *(void *)(a1 + 40);
      id v4 = [*(id *)(a1 + 32) cloudConnection];
      (*(void (**)(uint64_t, id))(v3 + 16))(v3, v4);
    }
  }
}

void sub_10006196C(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  id v6 = a2;
  if ([v6 dataProtectionClass] == 3
    || [v6 dataProtectionClass] == *(_DWORD *)(a1 + 40))
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
    *a4 = 1;
  }
}

void sub_100061D34(uint64_t a1)
{
  [*(id *)(a1 + 32) setCbuuid:*(void *)(a1 + 40)];
  if (*(unsigned char *)(a1 + 48))
  {
    id v2 = [*(id *)(a1 + 32) cloudConnection];
    [v2 setCbuuid:*(void *)(a1 + 40)];
  }
}

void sub_100061E58(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_100061E70(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSFoundationLog UTunPeer];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = *(_DWORD *)(a1 + 56);
    uint64_t v6 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 67109634;
    int v15 = v5;
    __int16 v16 = 1024;
    int v17 = v6;
    __int16 v18 = 2112;
    id v19 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "sendAckForMessageWithSequenceNumber: class %d priority %d connection %@", buf, 0x18u);
  }

  CFStringRef v7 = +[IDSDaemonPriorityQueueController sharedInstance];
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_100061FF0;
  v10[3] = &unk_10097FDC0;
  uint64_t v8 = *(void *)(a1 + 48);
  id v11 = v3;
  uint64_t v12 = v8;
  int v13 = *(_DWORD *)(a1 + 60);
  id v9 = v3;
  objc_msgSend(v7, "performBlockWithPriority:priority:", v10, objc_msgSend(v9, "idsPriority"));

  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
}

void sub_100061FF0(uint64_t a1)
{
  if (*(void *)(a1 + 40) == 2
    && ([*(id *)(a1 + 32) cloudConnection],
        id v2 = objc_claimAutoreleasedReturnValue(),
        v2,
        v2))
  {
    id v3 = [*(id *)(a1 + 32) cloudConnection];
  }
  else
  {
    id v3 = *(id *)(a1 + 32);
  }
  id v4 = v3;
  [v3 sendAckForMessageWithSequenceNumber:*(unsigned int *)(a1 + 48)];
}

void sub_100062168(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100062180(uint64_t a1, void *a2)
{
  if (*(void *)(a1 + 40) == 6)
  {
    id v3 = [a2 cloudConnection];
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = [v3 hasSpaceForMessagesWithDataProtectionClass:*(unsigned int *)(a1 + 48)];
  }
  else
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = [a2 hasSpaceForMessagesWithDataProtectionClass:*(unsigned int *)(a1 + 48)];
  }
}

void sub_100062BF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
}

uint64_t sub_100062C44(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100062C54(uint64_t a1)
{
}

void sub_100062C5C(uint64_t a1)
{
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  id v2 = *(id *)(*(void *)(a1 + 32) + 64);
  id v3 = [v2 countByEnumeratingWithState:&v17 objects:v21 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v18;
    do
    {
      for (uint64_t i = 0; i != v4; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v18 != v5) {
          objc_enumerationMutation(v2);
        }
        CFStringRef v7 = *(void **)(*((void *)&v17 + 1) + 8 * i);
        uint64_t v8 = *(void **)(a1 + 32);
        id v9 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
        uint64_t v10 = objc_msgSend(v7, "sendingMessageStatistics", (void)v17);
        id v11 = [v8 _copyStatisticsDict:v10];
        [v9 addObject:v11];

        uint64_t v12 = *(void **)(a1 + 32);
        int v13 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
        id v14 = [v7 cloudConnection];
        int v15 = [v14 sendingMessageStatistics];
        id v16 = [v12 _copyStatisticsDict:v15];
        [v13 addObject:v16];
      }
      id v4 = [v2 countByEnumeratingWithState:&v17 objects:v21 count:16];
    }
    while (v4);
  }
}

void sub_100062DEC(uint64_t a1)
{
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  id v2 = *(id *)(*(void *)(a1 + 32) + 56);
  id v3 = [v2 countByEnumeratingWithState:&v17 objects:v21 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v18;
    do
    {
      for (uint64_t i = 0; i != v4; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v18 != v5) {
          objc_enumerationMutation(v2);
        }
        CFStringRef v7 = *(void **)(*((void *)&v17 + 1) + 8 * i);
        uint64_t v8 = *(void **)(a1 + 32);
        id v9 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
        uint64_t v10 = objc_msgSend(v7, "sendingMessageStatistics", (void)v17);
        id v11 = [v8 _copyStatisticsDict:v10];
        [v9 addObject:v11];

        uint64_t v12 = *(void **)(a1 + 32);
        int v13 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
        id v14 = [v7 cloudConnection];
        int v15 = [v14 sendingMessageStatistics];
        id v16 = [v12 _copyStatisticsDict:v15];
        [v13 addObject:v16];
      }
      id v4 = [v2 countByEnumeratingWithState:&v17 objects:v21 count:16];
    }
    while (v4);
  }
}

void sub_100062F7C(uint64_t a1)
{
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  id v2 = *(id *)(*(void *)(a1 + 32) + 72);
  id v3 = [v2 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v12;
    do
    {
      uint64_t v6 = 0;
      do
      {
        if (*(void *)v12 != v5) {
          objc_enumerationMutation(v2);
        }
        CFStringRef v7 = *(void **)(a1 + 32);
        uint64_t v8 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
        id v9 = objc_msgSend(*(id *)(*((void *)&v11 + 1) + 8 * (void)v6), "sendingMessageStatistics", (void)v11);
        id v10 = [v7 _copyStatisticsDict:v9];
        [v8 addObject:v10];

        uint64_t v6 = (char *)v6 + 1;
      }
      while (v4 != v6);
      id v4 = [v2 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }
    while (v4);
  }
}

void sub_1000631C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000631E0(uint64_t a1)
{
  id v2 = *(id **)(a1 + 32);
  id v7 = [v2[9] objectAtIndexedSubscript:0];
  id v3 = [v7 queueStatistics];
  id v4 = [v2 _copyStatisticsDict:v3];
  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;
}

void sub_10006337C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100063394(uint64_t a1)
{
  id v2 = *(id **)(a1 + 32);
  id v7 = [v2[8] objectAtIndexedSubscript:0];
  id v3 = [v7 queueStatistics];
  id v4 = [v2 _copyStatisticsDict:v3];
  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;
}

void sub_100063530(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100063548(uint64_t a1)
{
  id v2 = *(id **)(a1 + 32);
  id v7 = [v2[7] objectAtIndexedSubscript:0];
  id v3 = [v7 queueStatistics];
  id v4 = [v2 _copyStatisticsDict:v3];
  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;
}

void sub_1000636E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000636FC(uint64_t a1)
{
  id v2 = *(id **)(a1 + 32);
  id v8 = [v2[7] objectAtIndexedSubscript:0];
  id v3 = [v8 cloudConnection];
  id v4 = [v3 queueStatistics];
  id v5 = [v2 _copyStatisticsDict:v4];
  uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
  id v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = v5;
}

void sub_1000638A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000638C0(uint64_t a1)
{
  id v2 = *(id **)(a1 + 32);
  id v8 = [v2[8] objectAtIndexedSubscript:0];
  id v3 = [v8 cloudConnection];
  id v4 = [v3 queueStatistics];
  id v5 = [v2 _copyStatisticsDict:v4];
  uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
  id v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = v5;
}

void sub_100064250(void *a1, void *a2)
{
  id v3 = (void *)a1[4];
  id v4 = (void *)a1[5];
  id v5 = a2;
  uint64_t v6 = [v5 cumulativeOutgoingStatistics];
  id v7 = [v4 _copyStatisticsDict:v6];
  [v3 addObject:v7];

  id v9 = (void *)a1[5];
  id v8 = (void *)a1[6];
  id v10 = [v5 cumulativeIncomingStatistics];
  id v11 = [v9 _copyStatisticsDict:v10];
  [v8 addObject:v11];

  long long v12 = (void *)a1[4];
  long long v13 = (void *)a1[5];
  long long v14 = [v5 cloudConnection];
  int v15 = [v14 cumulativeOutgoingStatistics];
  id v16 = [v13 _copyStatisticsDict:v15];
  [v12 addObject:v16];

  long long v19 = a1 + 5;
  long long v17 = (void *)a1[5];
  long long v18 = (void *)v19[1];
  id v22 = [v5 cloudConnection];

  long long v20 = [v22 cumulativeIncomingStatistics];
  id v21 = [v17 _copyStatisticsDict:v20];
  [v18 addObject:v21];
}

void sub_100064A94(uint64_t a1)
{
  id v1 = [*(id *)(a1 + 32) object];
  [v1 _powerlogDictionaryForSockets];
}

void sub_100064F08(uint64_t a1)
{
  id v1 = [*(id *)(a1 + 32) object];
  [v1 _powerlogDictionaryForPriority:300];
}

void sub_100064F50(uint64_t a1)
{
  id v1 = [*(id *)(a1 + 32) object];
  [v1 _powerlogDictionaryForPriority:200];
}

void sub_100064F98(uint64_t a1)
{
  id v1 = [*(id *)(a1 + 32) object];
  [v1 _powerlogDictionaryForPriority:100];
}

void sub_100065410(uint64_t a1)
{
  id v1 = [*(id *)(a1 + 32) object];
  [v1 _powerlogDictionaryForPriority:300];
}

void sub_100065458(uint64_t a1)
{
  id v1 = [*(id *)(a1 + 32) object];
  [v1 _powerlogDictionaryForPriority:200];
}

void sub_1000654A0(uint64_t a1)
{
  id v1 = [*(id *)(a1 + 32) object];
  [v1 _powerlogDictionaryForPriority:100];
}

void sub_100065798(id a1, IDSUTunConnection *a2)
{
}

void sub_100065A24(uint64_t a1)
{
  id v2 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(a1 + 32) cloudConnection];
    *(_DWORD *)buf = 138412290;
    id v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "enable connection %@.", buf, 0xCu);
  }
  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      id v5 = [*(id *)(a1 + 32) cloudConnection];
      _IDSLogTransport();

      if (_IDSShouldLog())
      {
        id v5 = objc_msgSend(*(id *)(a1 + 32), "cloudConnection", v5);
        _IDSLogV();
      }
    }
  }
  id v4 = objc_msgSend(*(id *)(a1 + 32), "cloudConnection", v5);
  [v4 setEnabled:1];
}

void sub_100065E94(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    id v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "disable connection %@.", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      id v5 = v3;
      _IDSLogTransport();
      if (_IDSShouldLog())
      {
        id v5 = v3;
        _IDSLogV();
      }
    }
  }
  objc_msgSend(v3, "setEnabled:", 0, v5);
  [v3 flushAllMessagesForReason:*(void *)(a1 + 32)];
}

void sub_100065FEC(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    id v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "disable connection %@.", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      id v5 = v3;
      _IDSLogTransport();
      if (_IDSShouldLog())
      {
        id v5 = v3;
        _IDSLogV();
      }
    }
  }
  objc_msgSend(v3, "setEnabled:", 0, v5);
  [v3 flushAllMessagesForReason:*(void *)(a1 + 32)];
}

void sub_1000663F8(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) cloudConnection];
  [v2 setEnabled:0];

  id v3 = [*(id *)(a1 + 32) cloudConnection];
  [v3 flushAllMessagesForReason:*(void *)(a1 + 40)];
}

id sub_1000664EC(uint64_t a1, void *a2)
{
  return [a2 setEnableOTR:*(unsigned __int8 *)(a1 + 32)];
}

id sub_10006658C(uint64_t a1, void *a2)
{
  return [a2 setIsMagnetIndicatingPeerIsAwake:*(unsigned __int8 *)(a1 + 32)];
}

id sub_100066E98(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _checkServicesPreferringInfraWiFi:*(unsigned int *)(a1 + 40)];
}

id sub_10006721C(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _checkServicesPreferringInfraWiFi:*(unsigned int *)(a1 + 40)];
}

void sub_100067404(id a1, IDSUTunConnection *a2)
{
}

void sub_1000674C0(id a1, IDSUTunConnection *a2)
{
}

void sub_100067508(id a1, IDSUTunConnection *a2)
{
}

void sub_100067578(id a1, IDSUTunConnection *a2)
{
}

id sub_100067624(uint64_t a1, void *a2)
{
  return [a2 cancelMessageID:*(void *)(a1 + 32)];
}

id sub_1000676D4(uint64_t a1, void *a2)
{
  return [a2 kickProgressBlockForMessageID:*(void *)(a1 + 32)];
}

void sub_100067C10(_Unwind_Exception *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,os_activity_scope_state_s state)
{
  if (a2 == 1)
  {
    objc_begin_catch(exc_buf);
    objc_end_catch();
    JUMPOUT(0x100067A50);
  }
  os_activity_scope_leave(&state);
  cut_arc_os_release();
  _Unwind_Resume(exc_buf);
}

void sub_100067C90(uint64_t a1)
{
  id v2 = +[IDSDevicePolicyController sharedInstance];
  id v3 = [*(id *)(a1 + 32) cbuuid];
  id v4 = [v2 shouldBlackOutDeviceWithCbuuid:v3];

  id v5 = objc_alloc((Class)IDSDeliveryContext);
  uint64_t v6 = *(void *)(a1 + 40);
  [*(id *)(a1 + 32) rtt];
  id v7 = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:");
  id v8 = +[NSNumber numberWithBool:v4];
  id v9 = [v5 initWithResponseCode:15 deviceID:v6 currentAverageRTT:v7 isDeviceBlackedOut:v8 localMessageState:&off_1009D0CA8];

  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

void sub_100067D9C(uint64_t a1)
{
  id v2 = +[IDSDevicePolicyController sharedInstance];
  id v3 = [*(id *)(a1 + 32) cbuuid];
  id v4 = [v2 shouldBlackOutDeviceWithCbuuid:v3];

  id v5 = objc_alloc((Class)IDSDeliveryContext);
  uint64_t v6 = *(void *)(a1 + 40);
  [*(id *)(a1 + 32) rtt];
  id v7 = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:");
  id v8 = +[NSNumber numberWithBool:v4];
  id v9 = [v5 initWithResponseCode:30 deviceID:v6 currentAverageRTT:v7 isDeviceBlackedOut:v8 localMessageState:&off_1009D0CA8];

  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

void sub_100067FEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100068004(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v9 = v3;
  if (*(unsigned char *)(a1 + 40))
  {
    uint64_t v4 = [v3 cloudConnection];
    uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
    uint64_t v6 = *(void **)(v5 + 40);
    *(void *)(v5 + 40) = v4;
  }
  else
  {
    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
    id v8 = v3;
    uint64_t v6 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v8;
  }
}

void sub_100068310(uint64_t a1)
{
  id v2 = (unsigned __int8 *)(a1 + 32);
  unsigned int v3 = [*(id *)(a1 + 32) isConnected];
  uint64_t v4 = +[NSNumber numberWithBool:v2[16]];
  [*(id *)(*(void *)v2 + 80) setObject:v4 forKeyedSubscript:*(void *)(a1 + 40)];

  unsigned int v5 = [*(id *)v2 isConnected];
  uint64_t v6 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a1 + 32);
    CFStringRef v8 = @"NO";
    if (v3) {
      CFStringRef v9 = @"YES";
    }
    else {
      CFStringRef v9 = @"NO";
    }
    *(_DWORD *)buf = 138412802;
    uint64_t v12 = v7;
    __int16 v13 = 2112;
    if (v5) {
      CFStringRef v8 = @"YES";
    }
    CFStringRef v14 = v9;
    __int16 v15 = 2112;
    CFStringRef v16 = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%@ wasConnected? %@ isConnected in aggregate? %@", buf, 0x20u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  if (v3 != v5)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 152));
    [WeakRetained peerConnectivityChanged:*(void *)(a1 + 32)];
  }
}

void sub_100068C64(uint64_t a1, void *a2)
{
  id v6 = a2;
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 276));
  unsigned int v3 = [*(id *)(*(void *)(a1 + 32) + 88) objectForKeyedSubscript:v6];
  unsigned int v4 = [v3 BOOLValue];

  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 276));
  if (v4)
  {
    unsigned int v5 = [v6 cloudConnection];
    [v5 setEnabled:1];
  }
}

void sub_1000695E8(id a1, IDSUTunConnection *a2)
{
}

void sub_1000695F4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v6 = v3;
  if (*(unsigned char *)(a1 + 32) || (BOOL v4 = [v3 idsPriority] == (id)300, v5 = v6, v4))
  {
    [v6 setEnabled:1];
    unsigned int v5 = v6;
  }
}

id sub_100069C70(uint64_t a1)
{
  return [*(id *)(a1 + 32) _handleCBUUIDDidConnect:*(void *)(a1 + 40) isDefaultPairedDevice:*(unsigned __int8 *)(a1 + 48) isAlwaysConnected:*(unsigned __int8 *)(a1 + 49)];
}

id sub_100069C84(uint64_t a1)
{
  return [*(id *)(a1 + 32) _handleCBUUIDFailToConnect:*(void *)(a1 + 40) withReason:0];
}

void sub_100069E68(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 idsPriority] == (id)300) {
    [v3 setEnabled:0 withReason:*(void *)(a1 + 32)];
  }
  else {
    [v3 setEnabled:0];
  }
}

void sub_10006A1A0(id a1, IDSUTunConnection *a2)
{
  id v2 = a2;
  if ([(IDSUTunConnection *)v2 isEnabled] && ![(IDSUTunConnection *)v2 isIdle]) {
    [(IDSUTunConnection *)v2 resumeConnectivity];
  }
}

void sub_10006A4B4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Unwind_Resume(a1);
}

void sub_10006A4D4(uint64_t a1)
{
  long long v7 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v8;
LABEL_3:
    uint64_t v6 = 0;
    while (1)
    {
      if (*(void *)v8 != v5) {
        objc_enumerationMutation(v2);
      }
      *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = objc_msgSend(*(id *)(*((void *)&v7 + 1)+ 8 * v6), "isIdle", (void)v7);
      if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
        break;
      }
      if (v4 == (id)++v6)
      {
        id v4 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
        if (v4) {
          goto LABEL_3;
        }
        break;
      }
    }
  }
}

void sub_10006A5E0(uint64_t a1)
{
  long long v7 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v8;
LABEL_3:
    uint64_t v6 = 0;
    while (1)
    {
      if (*(void *)v8 != v5) {
        objc_enumerationMutation(v2);
      }
      *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = objc_msgSend(*(id *)(*((void *)&v7 + 1)+ 8 * v6), "isIdle", (void)v7);
      if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
        break;
      }
      if (v4 == (id)++v6)
      {
        id v4 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
        if (v4) {
          goto LABEL_3;
        }
        break;
      }
    }
  }
}

void sub_10006A6EC(uint64_t a1)
{
  long long v7 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v8;
LABEL_3:
    uint64_t v6 = 0;
    while (1)
    {
      if (*(void *)v8 != v5) {
        objc_enumerationMutation(v2);
      }
      *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = objc_msgSend(*(id *)(*((void *)&v7 + 1)+ 8 * v6), "isIdle", (void)v7);
      if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
        break;
      }
      if (v4 == (id)++v6)
      {
        id v4 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
        if (v4) {
          goto LABEL_3;
        }
        break;
      }
    }
  }
}

id sub_10006A930(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) _disableTimerFired:a2];
}

void sub_10006A9A4(id a1, IDSUTunConnection *a2)
{
}

double sub_10006A9B0()
{
  uint64_t v0 = +[IDSServerBag sharedInstance];
  uint64_t v1 = [v0 objectForKey:@"gl-cloud-msg-disable-interval"];

  if (v1)
  {
    [v1 doubleValue];
    double v3 = v2;
  }
  else
  {
    double v3 = 10.0;
  }

  return v3;
}

void sub_10006B0B8(uint64_t a1)
{
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v10;
    do
    {
      for (uint64_t i = 0; i != v4; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v10 != v5) {
          objc_enumerationMutation(v2);
        }
        long long v7 = *(void **)(*((void *)&v9 + 1) + 8 * i);
        objc_msgSend(v7, "forceOTRNegotiation:priority:completionBlock:", *(void *)(a1 + 40), *(void *)(a1 + 56), *(void *)(a1 + 48), (void)v9);
        if (*(unsigned char *)(a1 + 64))
        {
          long long v8 = [v7 cloudConnection];
          [v8 forceOTRNegotiation:*(void *)(a1 + 40) priority:*(void *)(a1 + 56) completionBlock:*(void *)(a1 + 48)];
        }
      }
      id v4 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
    }
    while (v4);
  }
}

void sub_10006B1E4(uint64_t a1)
{
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v10;
    do
    {
      for (uint64_t i = 0; i != v4; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v10 != v5) {
          objc_enumerationMutation(v2);
        }
        long long v7 = *(void **)(*((void *)&v9 + 1) + 8 * i);
        objc_msgSend(v7, "forceOTRNegotiation:priority:completionBlock:", *(void *)(a1 + 40), *(void *)(a1 + 56), *(void *)(a1 + 48), (void)v9);
        if (*(unsigned char *)(a1 + 64))
        {
          long long v8 = [v7 cloudConnection];
          [v8 forceOTRNegotiation:*(void *)(a1 + 40) priority:*(void *)(a1 + 56) completionBlock:*(void *)(a1 + 48)];
        }
      }
      id v4 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
    }
    while (v4);
  }
}

void sub_10006B310(uint64_t a1)
{
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v10;
    do
    {
      for (uint64_t i = 0; i != v4; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v10 != v5) {
          objc_enumerationMutation(v2);
        }
        long long v7 = *(void **)(*((void *)&v9 + 1) + 8 * i);
        objc_msgSend(v7, "forceOTRNegotiation:priority:completionBlock:", *(void *)(a1 + 40), *(void *)(a1 + 56), *(void *)(a1 + 48), (void)v9);
        if (*(unsigned char *)(a1 + 64))
        {
          long long v8 = [v7 cloudConnection];
          [v8 forceOTRNegotiation:*(void *)(a1 + 40) priority:*(void *)(a1 + 56) completionBlock:*(void *)(a1 + 48)];
        }
      }
      id v4 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
    }
    while (v4);
  }
}

id sub_10006B4D8(uint64_t a1, void *a2)
{
  return [a2 admissionPolicyChangedForTopic:*(void *)(a1 + 32) allowed:*(unsigned __int8 *)(a1 + 40)];
}

uint64_t sub_10006CD34(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10006D294(id a1)
{
  off_100A4A548 = (uint64_t (*)(void, void, void))IMWeakLinkSymbol();
}

void sub_10006D2C4(id a1)
{
  off_100A4A558 = (uint64_t (*)(void, void, void))IMWeakLinkSymbol();
}

id sub_10006D2F4()
{
  CFTypeRef cf = 0;
  if (qword_100A4A570 != -1) {
    dispatch_once(&qword_100A4A570, &stru_1009806B8);
  }
  if (!off_100A4A568 || ((v0 = (void *)off_100A4A568(0, &cf)) != 0 ? (BOOL v1 = cf == 0) : (BOOL v1 = 0), !v1))
  {
    id v2 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      CFTypeRef v6 = cf;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SecMWCreateSessionSeed for Key Material (error %@)", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
    uint64_t v0 = (void *)cf;
    if (cf)
    {
      CFRelease(cf);
      uint64_t v0 = 0;
    }
  }

  return v0;
}

void sub_10006D49C(id a1)
{
  off_100A4A568 = (_UNKNOWN *)IMWeakLinkSymbol();
}

id sub_10006D4CC()
{
  CFTypeRef cf = 0;
  if (qword_100A4A580 != -1) {
    dispatch_once(&qword_100A4A580, &stru_1009806D8);
  }
  if (!off_100A4A578 || ((v0 = (void *)off_100A4A578(0, &cf)) != 0 ? (BOOL v1 = cf == 0) : (BOOL v1 = 0), !v1))
  {
    id v2 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      CFTypeRef v6 = cf;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "_SecMWCreateSessionSalt for Key Salt (error %@)", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
    uint64_t v0 = (void *)cf;
    if (cf)
    {
      CFRelease(cf);
      uint64_t v0 = 0;
    }
  }

  return v0;
}

void sub_10006D674(id a1)
{
  off_100A4A578 = (_UNKNOWN *)IMWeakLinkSymbol();
}

id sub_10006D6A4(void *a1, uint64_t a2, uint64_t a3)
{
  id v5 = a1;
  id v13 = 0;
  CFTypeRef v6 = +[GFTKeyWrapping wrapSeed:v5 to:a2 legacy:a3 error:&v13];
  id v7 = v13;
  long long v8 = v7;
  if (v6) {
    BOOL v9 = v7 == 0;
  }
  else {
    BOOL v9 = 0;
  }
  if (v9)
  {
    id v11 = v6;
  }
  else
  {
    long long v10 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      __int16 v15 = v8;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "wrapSeed (error %@)", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
    id v11 = 0;
  }

  return v11;
}

id sub_10006D854(void *a1, uint64_t a2, uint64_t a3)
{
  id v5 = a1;
  id v13 = 0;
  CFTypeRef v6 = +[GFTKeyWrapping unwrapSeed:v5 usingKey:a2 legacy:a3 error:&v13];
  id v7 = v13;
  long long v8 = v7;
  if (v6) {
    BOOL v9 = v7 == 0;
  }
  else {
    BOOL v9 = 0;
  }
  if (v9)
  {
    id v11 = v6;
  }
  else
  {
    long long v10 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      __int16 v15 = v8;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "unwrapSeed (error %@)", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
    id v11 = 0;
  }

  return v11;
}

id sub_10006DA04(void *a1, uint64_t a2)
{
  id v3 = a1;
  id v11 = 0;
  id v4 = +[GFTKeyWrapping encrypt:v3 toKey:a2 error:&v11];
  id v5 = v11;
  CFTypeRef v6 = v5;
  if (v4) {
    BOOL v7 = v5 == 0;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7)
  {
    id v9 = v4;
  }
  else
  {
    long long v8 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      id v13 = v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "unwrapSeed (error %@)", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
    id v9 = 0;
  }

  return v9;
}

id sub_10006DBAC(void *a1, uint64_t a2)
{
  id v3 = a1;
  id v11 = 0;
  id v4 = +[GFTKeyWrapping decrypt:v3 usingKey:a2 error:&v11];
  id v5 = v11;
  CFTypeRef v6 = v5;
  if (v4) {
    BOOL v7 = v5 == 0;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7)
  {
    id v9 = v4;
  }
  else
  {
    long long v8 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      id v13 = v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "unwrapSeed (error %@)", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
    id v9 = 0;
  }

  return v9;
}

uint64_t sub_10006DD54(void *a1, uint64_t a2)
{
  id v3 = a1;
  CFTypeRef cf = 0;
  if (qword_100A4A590 != -1) {
    dispatch_once(&qword_100A4A590, &stru_1009806F8);
  }
  if (!off_100A4A588 || ((uint64_t v4 = off_100A4A588(v3, a2, &cf)) != 0 ? (v5 = cf == 0) : (v5 = 0), !v5))
  {
    CFTypeRef v6 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      CFTypeRef v10 = cf;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "(error %@)", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
    if (cf) {
      CFRelease(cf);
    }
    uint64_t v4 = 0;
  }

  return v4;
}

void sub_10006DF08(id a1)
{
  off_100A4A588 = (_UNKNOWN *)IMWeakLinkSymbol();
}

uint64_t sub_10006DF38(uint64_t a1, uint64_t a2)
{
  if (qword_100A4A5A0 != -1) {
    dispatch_once(&qword_100A4A5A0, &stru_100980718);
  }
  id v3 = (uint64_t (*)(void, uint64_t))off_100A4A598;
  if (!off_100A4A598) {
    return 0;
  }

  return v3(0, a2);
}

void sub_10006DFB4(id a1)
{
  off_100A4A598 = (_UNKNOWN *)IMWeakLinkSymbol();
}

id sub_10006E088(id a1, IDSURI *a2)
{
  return [(IDSURI *)a2 prefixedURI];
}

id sub_10006EA08(id a1, id a2)
{
  id v2 = [a2 _stripPotentialTokenURIWithToken:0];
  id v3 = [v2 _stripFZIDPrefix];

  return v3;
}

uint64_t sub_10006EA5C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [*(id *)(a1 + 32) invisibleAliases];
  if ([v4 containsObject:v3]) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = [v3 hasSuffix:@"inbox.appleid.apple.com"] ^ 1;
  }

  return v5;
}

int64_t sub_10006EAD0(id a1, IDSDAccount *a2, IDSDAccount *a3)
{
  uint64_t v4 = a3;
  uint64_t v5 = [(IDSDAccount *)a2 loginID];
  CFTypeRef v6 = [(IDSDAccount *)v4 loginID];

  id v7 = [v5 compare:v6];
  return (int64_t)v7;
}

void sub_10006F278(void *a1)
{
  if (!a1) {
    return;
  }
  id v2 = [a1 inProgressKeyUpdates];
  if ([v2 count])
  {

    goto LABEL_5;
  }
  id v3 = [a1 successKeyResponses];
  id v4 = [v3 count];

  if (v4)
  {
LABEL_5:
    uint64_t v5 = [a1 inProgressKeyUpdates];
    id v6 = [v5 count];

    if (!v6)
    {
      id v7 = +[IDSFoundationLog stewieProvisioning];
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        long long v8 = [a1 successKeyResponses];
        int v14 = 134217984;
        id v15 = [v8 count];
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Received successful key updates - sending keysReceipt { self.successKeyResponses.count: %ld, withSuccess: YES }", (uint8_t *)&v14, 0xCu);
      }
      id v9 = [a1 stewieCTClient];
      CFTypeRef v10 = [a1 successKeyResponses];
      [v9 didUpdateSessionKeys:v10 withAnySuccess:1];

      [a1 setSuccessKeyResponses:0];
    }
    return;
  }
  id v11 = +[IDSFoundationLog stewieProvisioning];
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v14) = 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Received no successful key updates - sending keysReceipt { self.successKeyResponses.count: 0, withSuccess: NO }", (uint8_t *)&v14, 2u);
  }

  long long v12 = [a1 stewieCTClient];
  id v13 = [a1 successKeyResponses];
  [v12 didUpdateSessionKeys:v13 withAnySuccess:0];
}

void sub_10006FCE8(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSFoundationLog opportunistic];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = [*(id *)(a1 + 32) connection];
    int v6 = 138412546;
    id v7 = v3;
    __int16 v8 = 2112;
    id v9 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Retrieved opportunistic cache {cache: %@, connection: %@}", (uint8_t *)&v6, 0x16u);
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_10007046C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IMRGLog registration];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG)) {
    sub_10070BC2C((uint64_t)v3, v4);
  }

  if (![v3 registrationType] || objc_msgSend(v3, "registrationType") == 2)
  {
    uint64_t v5 = +[IMRGLog registration];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG)) {
      sub_10070BBE8(v5);
    }

    int v6 = [v3 phoneNumber];
    if (v6) {
      [*(id *)(a1 + 32) addObject:v6];
    }
  }
}

void sub_10007059C(id a1)
{
  qword_100A4A5B0 = objc_alloc_init(IDSRegistrationController);

  _objc_release_x1();
}

void sub_100070968()
{
  BOOL v1 = +[IDSRegistrationController sharedInstance];
  [v1 _systemConfigurationPrefsChanged];
}

void sub_1000720C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,os_activity_scope_state_s state,char a23)
{
}

id sub_10007216C(void *a1)
{
  id v1 = a1;
  id v2 = [v1 mainID];

  if (!v2)
  {
    id v11 = +[IMRGLog registration];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      int v18 = 138412290;
      id v19 = v1;
      long long v12 = "Missing MainID, Not sending IDS Authentication/Register for: %@";
      goto LABEL_30;
    }
LABEL_31:
    id v4 = 0;
    goto LABEL_32;
  }
  if ([v1 registrationType] == 1
    && ([v1 profileID],
        id v3 = objc_claimAutoreleasedReturnValue(),
        id v4 = [v3 length],
        v3,
        !v4))
  {
    id v11 = +[IMRGLog registration];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      int v18 = 138412290;
      id v19 = v1;
      long long v12 = "Missing ProfileID, Not sending IDS Authentication/Register for: %@";
      goto LABEL_30;
    }
  }
  else if ([v1 registrationType] == 1 {
         && ([v1 regionID],
  }
             uint64_t v5 = objc_claimAutoreleasedReturnValue(),
             id v4 = [v5 length],
             v5,
             !v4))
  {
    id v11 = +[IMRGLog registration];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      int v18 = 138412290;
      id v19 = v1;
      long long v12 = "Missing regionID, Not sending IDS Authentication/Register for: %@";
      goto LABEL_30;
    }
  }
  else
  {
    if ([v1 registrationType] != 1
      || ([v1 regionBasePhoneNumber],
          int v6 = objc_claimAutoreleasedReturnValue(),
          id v4 = [v6 length],
          v6,
          v4))
    {
      id v7 = [v1 authenticationCert];
      if (v7)
      {
      }
      else
      {
        id v13 = [v1 authenticationToken];

        if (v13)
        {
          int v14 = +[IMRGLog registration];
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            int v18 = 138412290;
            id v19 = v1;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Sending IDS Authentication for: %@", (uint8_t *)&v18, 0xCu);
          }

          id v11 = +[IDSRegistrationCenter sharedInstance];
          id v15 = [v11 authenticateRegistration:v1];
LABEL_27:
          id v4 = v15;
          goto LABEL_32;
        }
      }
      uint64_t v8 = [v1 authenticationCert];
      if (!v8
        || (id v9 = (void *)v8,
            unsigned __int8 v10 = [v1 stopAtAuthentication],
            v9,
            (v10 & 1) != 0))
      {
        id v11 = +[IMRGLog registration];
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          int v18 = 138412290;
          id v19 = v1;
          long long v12 = "Not sending IDS Registration or Authentication for: %@";
LABEL_30:
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v18, 0xCu);
          goto LABEL_31;
        }
        goto LABEL_31;
      }
      CFStringRef v16 = +[IMRGLog registration];
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        int v18 = 138412290;
        id v19 = v1;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Sending IDS Registration for: %@", (uint8_t *)&v18, 0xCu);
      }

      id v11 = +[IDSRegistrationCenter sharedInstance];
      id v15 = [v11 sendRegistration:v1];
      goto LABEL_27;
    }
    id v11 = +[IMRGLog registration];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      int v18 = 138412290;
      id v19 = v1;
      long long v12 = "Missing regionBasePhoneNumber, Not sending IDS Authentication/Register for: %@";
      goto LABEL_30;
    }
  }
LABEL_32:

  return v4;
}

void sub_10007309C(_Unwind_Exception *a1)
{
}

void sub_1000732B0()
{
}

void sub_1000734C0()
{
}

void sub_1000737C8()
{
}

void sub_1000737F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,os_activity_scope_state_s state,char a23)
{
}

void sub_100073808(uint64_t a1, int a2)
{
  if (!a2) {
    sub_10007380C();
  }
  objc_terminate();
}

void sub_100073AA0()
{
}

void sub_100073AC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,os_activity_scope_state_s state,char a23)
{
}

void sub_100073ADC(uint64_t a1, int a2)
{
  if (!a2) {
    sub_100073AE0();
  }
  objc_terminate();
}

void sub_100073D94()
{
}

void sub_100073F44()
{
}

void sub_100074230(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = +[IMRGLog registration];
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(a1 + 32);
    int v9 = 138412802;
    uint64_t v10 = v8;
    __int16 v11 = 2112;
    id v12 = v5;
    __int16 v13 = 2112;
    id v14 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Finished capturing AutoBugCapture diagnostics for registration failure { context: %@, sessionID: %@, error: %@ }", (uint8_t *)&v9, 0x20u);
  }
}

void sub_100074678(uint64_t a1)
{
  id v1 = *(void **)(a1 + 32);
  id v2 = [*(id *)(a1 + 40) userUniqueIdentifier];
  [v1 _postHomeNumberNotificationBeforeAlertForIdentifier:v2 forcefully:0];
}

uint64_t sub_1000758A4(uint64_t a1)
{
  uint64_t result = (uint64_t)[*(id *)(a1 + 32) registrationStatus];
  if (result <= 6)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    id v3 = *(void **)(a1 + 40);
    return (uint64_t)_[v3 _notifyRegistrationUpdated:v4];
  }
  return result;
}

id sub_10007716C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [v3 mainID];
  id v5 = objc_msgSend(v4, "_im_normalizedURIString");
  LODWORD(a1) = [v5 isEqualToString:*(void *)(a1 + 32)];

  if (a1) {
    id v6 = v3;
  }
  else {
    id v6 = 0;
  }

  return v6;
}

id sub_100077298(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 registrationType] == *(_DWORD *)(a1 + 32)) {
    id v4 = v3;
  }
  else {
    id v4 = 0;
  }

  return v4;
}

id sub_10007734C(id a1, id a2)
{
  id v2 = a2;
  if ([v2 canSendRegistration]
    && ([v2 stopAtAuthentication] & 1) == 0)
  {
    id v3 = v2;
  }
  else
  {
    id v3 = 0;
  }

  return v3;
}

id sub_100077B0C(uint64_t a1)
{
  return [*(id *)(a1 + 32) _postHomeNumberNotificationBeforeAlertForIdentifier:*(void *)(a1 + 40) forcefully:1];
}

void sub_100078228(uint64_t a1, void *a2)
{
  id v3 = [a2 response];
  id v4 = +[IMRGLog registration];
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v5)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "User didn't hit default button on disable phone number alert", buf, 2u);
    }

    id v6 = objc_alloc((Class)NSMutableSet);
    id v7 = +[FTUserConfiguration sharedInstance];
    uint64_t v8 = [v7 selectedPhoneNumberRegistrationSubscriptionLabels];
    id v4 = [v6 initWithArray:v8];

    [v4 removeObject:*(void *)(a1 + 32)];
    int v9 = +[FTUserConfiguration sharedInstance];
    if (([v9 isDeviceInDualPhoneIdentityMode] & 1) == 0)
    {
      uint64_t v10 = +[FTUserConfiguration sharedInstance];
      unsigned __int8 v11 = [v10 isDeviceInManualPhoneSelectionMode];

      if (v11)
      {
LABEL_8:
        id v12 = +[FTUserConfiguration sharedInstance];
        __int16 v13 = [v4 allObjects];
        [v12 setSelectedPhoneNumberRegistrationSubscriptionLabels:v13];

        goto LABEL_11;
      }
      int v9 = +[FTUserConfiguration sharedInstance];
      [v9 setIsDeviceInManualPhoneSelectionMode:1];
    }

    goto LABEL_8;
  }
  if (v5)
  {
    *(_WORD *)id v15 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "User hit no to disable phone number alert -- ignoring", v15, 2u);
  }
LABEL_11:

  id v14 = [*(id *)(a1 + 40) _provisionedTemporaryUser];
  if ([v14 finishedRegistration]
    && ([v14 hasNotifiedSuccess] & 1) == 0)
  {
    [*(id *)(a1 + 40) _notifyHomeNumberSuccessForUser:v14];
  }
  [*(id *)(a1 + 40) setDisplayingAddNumberPrompt:0];
}

void sub_10007A530(id a1, NSString *a2, NSError *a3)
{
  id v4 = a2;
  BOOL v5 = a3;
  id v6 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412546;
    uint64_t v8 = v4;
    __int16 v9 = 2112;
    uint64_t v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Triggered auto bug capture for rate limiting {session : %@, error: %@}", buf, 0x16u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
}

id sub_10007B6B4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [*(id *)(a1 + 32) setObject:a3 forKey:a2];
}

uint64_t IDSProtoKeyTransparencyLoggableDataReadFrom(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
    return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
  }
  while (2)
  {
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0;
    while (1)
    {
      unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v7 == -1 || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v8 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
      v6 |= (unint64_t)(v8 & 0x7F) << v4;
      if ((v8 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v9 = v5++ >= 9;
      if (v9)
      {
        unint64_t v6 = 0;
        int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }
    *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0;
    }
LABEL_13:
    if (v10 || (v6 & 7) == 4) {
      return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    switch((v6 >> 3))
    {
      case 1u:
        uint64_t v12 = PBReaderReadData();
        __int16 v13 = *(void **)(a1 + 24);
        *(void *)(a1 + 24) = v12;

        goto LABEL_47;
      case 2u:
        char v15 = 0;
        unsigned int v16 = 0;
        uint64_t v17 = 0;
        *(unsigned char *)(a1 + 36) |= 2u;
        while (2)
        {
          unint64_t v18 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v18 == -1 || v18 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }
          else
          {
            char v19 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v18);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v18 + 1;
            v17 |= (unint64_t)(v19 & 0x7F) << v15;
            if (v19 < 0)
            {
              v15 += 7;
              BOOL v9 = v16++ >= 9;
              if (v9)
              {
                LODWORD(v17) = 0;
                goto LABEL_41;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v17) = 0;
        }
LABEL_41:
        uint64_t v25 = 32;
        goto LABEL_46;
      case 3u:
        char v20 = 0;
        unsigned int v21 = 0;
        uint64_t v17 = 0;
        *(unsigned char *)(a1 + 36) |= 1u;
        while (2)
        {
          unint64_t v22 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v22 == -1 || v22 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }
          else
          {
            char v23 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v22);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v22 + 1;
            v17 |= (unint64_t)(v23 & 0x7F) << v20;
            if (v23 < 0)
            {
              v20 += 7;
              BOOL v9 = v21++ >= 9;
              if (v9)
              {
                LODWORD(v17) = 0;
                goto LABEL_45;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v17) = 0;
        }
LABEL_45:
        uint64_t v25 = 16;
LABEL_46:
        *(_DWORD *)(a1 + v25) = v17;
        goto LABEL_47;
      case 4u:
        uint64_t v24 = objc_alloc_init(IDSProtoApplicationKeyEntry);
        [(id)a1 addApplicationPublicIdentity:v24];
        if PBReaderPlaceMark() && (IDSProtoApplicationKeyEntryReadFrom((uint64_t)v24, a2))
        {
          PBReaderRecallMark();

LABEL_47:
          if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
          }
          continue;
        }

        return 0;
      default:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_47;
    }
  }
}

void sub_10007D658(id *a1)
{
  v21[0] = _NSConcreteStackBlock;
  v21[1] = 3221225472;
  v21[2] = sub_10007D9C8;
  v21[3] = &unk_1009800C0;
  id v2 = a1 + 4;
  v21[4] = a1[4];
  id v22 = a1[5];
  id v23 = v2[2];
  id v24 = v2[4];
  id v3 = objc_retainBlock(v21);
  char v4 = [*v2 _lookupEndpoint];
  LOBYTE(v2) = v4 == 0;

  if (v2)
  {
    if ([a1[4] avoidMainQueue])
    {
      unsigned int v5 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v6 = [a1[4] remoteURI];
        unint64_t v7 = [a1[4] localURI];
        char v8 = [a1[4] service];
        *(_DWORD *)buf = 138412802;
        int v26 = v6;
        __int16 v27 = 2112;
        double v28 = v7;
        __int16 v29 = 2112;
        double v30 = v8;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Need to query for encryption but should avoid main -- failing {remoteURI: %@, localURI: %@, service: %@}", buf, 0x20u);
      }
      if (os_log_shim_legacy_logging_enabled())
      {
        BOOL v9 = [a1[4] remoteURI];
        int v10 = [a1[4] localURI];
        [a1[4] service];
        v16 = char v15 = v10;
        id v14 = v9;
        _IDSLogEventV();
      }
      id v11 = a1[8];
      uint64_t v12 = +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", IDSEncryptionErrorDomain, 6, 0, v14, v15, v16);
      (*((void (**)(id, void, void *, void))v11 + 2))(v11, 0, v12, 0);
    }
    __int16 v13 = im_primary_queue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10007DCBC;
    block[3] = &unk_1009809A0;
    void block[4] = a1[4];
    id v18 = a1[7];
    char v19 = v3;
    id v20 = a1[8];
    dispatch_async(v13, block);
  }
  else
  {
    ((void (*)(void *))v3[2])(v3);
  }
}

void sub_10007D9C8(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 48);
  id v21 = 0;
  id v22 = 0;
  unsigned int v5 = [v2 legacyEncryptData:v3 withEncryptedAttributes:v4 usedIdentifier:&v22 error:&v21];
  id v6 = v22;
  id v7 = v21;
  if ([*(id *)(a1 + 32) avoidMainQueue])
  {
    uint64_t v8 = *(void *)(a1 + 56);
    BOOL v9 = [[IDSEncryptionMetadata alloc] initWithMPIdentityIdentifier:v6];
    (*(void (**)(uint64_t, void *, id, IDSEncryptionMetadata *))(v8 + 16))(v8, v5, v7, v9);
  }
  int v10 = im_primary_queue();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10007DB3C;
  block[3] = &unk_100980950;
  id v16 = v5;
  id v17 = v7;
  uint64_t v18 = *(void *)(a1 + 32);
  id v11 = *(id *)(a1 + 56);
  id v19 = v6;
  id v20 = v11;
  id v12 = v6;
  id v13 = v7;
  id v14 = v5;
  dispatch_async(v10, block);
}

void sub_10007DB3C(uint64_t a1)
{
  if (!*(void *)(a1 + 32) || *(void *)(a1 + 40))
  {
    id v2 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v11 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Flushing peer tokens, in hopes this resolves in the next error", v11, 2u);
    }

    if (os_log_shim_legacy_logging_enabled()) {
      _IDSLogEventV();
    }
    uint64_t v3 = [*(id *)(a1 + 48) peerIDManager];
    uint64_t v4 = [*(id *)(a1 + 48) remoteURI];
    unsigned int v5 = [*(id *)(a1 + 48) localURI];
    id v6 = [*(id *)(a1 + 48) service];
    [v3 forgetPeerTokensForURI:v4 fromURI:v5 service:v6];
  }
  if (([*(id *)(a1 + 48) avoidMainQueue] & 1) == 0)
  {
    uint64_t v7 = *(void *)(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v9 = *(void *)(a1 + 40);
    int v10 = [[IDSEncryptionMetadata alloc] initWithMPIdentityIdentifier:*(void *)(a1 + 56)];
    (*(void (**)(uint64_t, uint64_t, uint64_t, IDSEncryptionMetadata *))(v7 + 16))(v7, v8, v9, v10);
  }
}

void sub_10007DCBC(id *a1)
{
  id v2 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = [a1[4] remoteURI];
    uint64_t v4 = [a1[4] localURI];
    unsigned int v5 = [a1[4] service];
    *(_DWORD *)buf = 138412802;
    id v23 = v3;
    __int16 v24 = 2112;
    uint64_t v25 = v4;
    __int16 v26 = 2112;
    __int16 v27 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Missing encryption keys -- querying {remoteURI: %@, localURI: %@, service: %@}", buf, 0x20u);
  }
  if (os_log_shim_legacy_logging_enabled())
  {
    id v6 = [a1[4] remoteURI];
    uint64_t v7 = [a1[4] localURI];
    [a1[4] service];
    id v17 = v16 = v7;
    id v14 = v6;
    _IDSLogEventV();
  }
  uint64_t v8 = objc_msgSend(a1[4], "peerIDManager", v14, v16, v17);
  uint64_t v9 = [a1[4] remoteURI];
  int v10 = IMSingleObjectArray();
  id v11 = [a1[4] cert];
  id v12 = [a1[4] localURI];
  id v13 = [a1[4] service];
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472;
  v18[2] = sub_10007DFA0;
  v18[3] = &unk_100980978;
  v18[4] = a1[4];
  id v19 = a1[5];
  id v20 = a1[6];
  id v21 = a1[7];
  LOBYTE(v15) = 0;
  [v8 startQueryForURIs:v10 fromIdentity:v11 fromURI:v12 fromService:v13 forSending:1 forRefresh:0 isForced:v15 reason:@"URIEncrypt" completionBlock:v18];
}

void sub_10007DFA0(uint64_t a1, void *a2, void *a3, void *a4, void *a5, int a6, void *a7, uint64_t a8, void *a9)
{
  id v32 = a2;
  id v33 = a3;
  id v15 = a4;
  id v34 = a5;
  id v16 = a7;
  id v17 = a9;
  uint64_t v18 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    if (a6) {
      CFStringRef v19 = @"YES";
    }
    else {
      CFStringRef v19 = @"NO";
    }
    id v20 = [*(id *)(a1 + 32) remoteURI];
    id v21 = [*(id *)(a1 + 32) localURI];
    id v22 = [*(id *)(a1 + 32) service];
    *(_DWORD *)buf = 138413058;
    CFStringRef v36 = v19;
    __int16 v37 = 2112;
    id v38 = v20;
    __int16 v39 = 2112;
    unint64_t v40 = v21;
    __int16 v41 = 2112;
    __int16 v42 = v22;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Encryption query completed {success: %@, remoteURI: %@, localURI: %@, service: %@}", buf, 0x2Au);
  }
  if (os_log_shim_legacy_logging_enabled())
  {
    if (a6) {
      CFStringRef v23 = @"YES";
    }
    else {
      CFStringRef v23 = @"NO";
    }
    __int16 v24 = [*(id *)(a1 + 32) remoteURI];
    uint64_t v25 = [*(id *)(a1 + 32) localURI];
    [*(id *)(a1 + 32) service];
    v31 = double v30 = v25;
    CFStringRef v28 = v23;
    __int16 v29 = v24;
    _IDSLogEventV();
  }
  if (a6 && ([*(id *)(a1 + 32) avoidMainQueue] & 1) == 0)
  {
    [*(id *)(a1 + 40) performAsyncBlock:*(void *)(a1 + 48)];
  }
  else if ((objc_msgSend(*(id *)(a1 + 32), "avoidMainQueue", v28, v29, v30, v31) & 1) == 0)
  {
    uint64_t v26 = *(void *)(a1 + 56);
    __int16 v27 = +[NSError errorWithDomain:IDSEncryptionErrorDomain code:1 userInfo:0];
    (*(void (**)(uint64_t, void, void *, void))(v26 + 16))(v26, 0, v27, 0);
  }
}

void sub_10007E3C8(uint64_t a1)
{
  v42[0] = _NSConcreteStackBlock;
  v42[1] = 3221225472;
  v42[2] = sub_10007E938;
  v42[3] = &unk_100980A18;
  id v2 = (id *)(a1 + 32);
  v42[4] = *(void *)(a1 + 32);
  id v43 = *(id *)(a1 + 40);
  id v44 = *(id *)(a1 + 48);
  id v45 = *(id *)(a1 + 56);
  uint64_t v3 = *(void **)(a1 + 64);
  char v48 = *(unsigned char *)(a1 + 88);
  id v46 = v3;
  id v47 = *(id *)(a1 + 80);
  uint64_t v4 = objc_retainBlock(v42);
  unsigned int v5 = [*v2 replayCommitter];
  id v6 = [v5 decryptedDataForKey:*(void *)(a1 + 64)];

  uint64_t v7 = [v6 encryptedAttributes];
  uint64_t v8 = [v6 decryptedData];
  uint64_t v9 = [v6 additionalDecryptionResult];
  id v10 = *v2;
  if (v8)
  {
    if ([v10 avoidMainQueue])
    {
      uint64_t v11 = *(void *)(a1 + 80);
      id v12 = [[IDSDecryptionMetadata alloc] initWithUsedLastResortCache:0 usedCachedData:1 additionalDecryptionResult:v9];
      (*(void (**)(uint64_t, void *, void *, void, IDSDecryptionMetadata *))(v11 + 16))(v11, v8, v7, 0, v12);
    }
    else
    {
      uint64_t v18 = im_primary_queue();
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10007EF28;
      block[3] = &unk_100980A40;
      id v41 = *(id *)(a1 + 80);
      id v38 = v8;
      id v39 = v7;
      id v40 = v9;
      dispatch_async(v18, block);
    }
  }
  else
  {
    id v13 = [v10 _lookupEndpoint];
    BOOL v14 = v13 == 0;

    id v15 = *(void **)(a1 + 32);
    if (v14)
    {
      if ([v15 avoidMainQueue])
      {
        CFStringRef v19 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          id v20 = [*(id *)(a1 + 32) remoteURI];
          id v21 = [*(id *)(a1 + 32) localURI];
          id v22 = [*(id *)(a1 + 32) service];
          *(_DWORD *)buf = 138412802;
          long long v50 = v20;
          __int16 v51 = 2112;
          __int16 v52 = v21;
          __int16 v53 = 2112;
          __int16 v54 = v22;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Need to query for decryption but should avoid main -- failing {remoteURI: %@, localURI: %@, service: %@}", buf, 0x20u);
        }
        if (os_log_shim_legacy_logging_enabled())
        {
          CFStringRef v23 = [*(id *)(a1 + 32) remoteURI];
          __int16 v24 = [*(id *)(a1 + 32) localURI];
          [*(id *)(a1 + 32) service];
          v31 = double v30 = v24;
          __int16 v29 = v23;
          _IDSLogEventV();
        }
        uint64_t v25 = *(void *)(a1 + 80);
        uint64_t v26 = +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", IDSDecryptionErrorDomain, 1, 0, v29, v30, v31);
        __int16 v27 = objc_alloc_init(IDSDecryptionMetadata);
        (*(void (**)(uint64_t, void, void, void *, IDSDecryptionMetadata *))(v25 + 16))(v25, 0, 0, v26, v27);
      }
      CFStringRef v28 = im_primary_queue();
      v32[0] = _NSConcreteStackBlock;
      v32[1] = 3221225472;
      v32[2] = sub_10007EFB4;
      v32[3] = &unk_100980AB8;
      v32[4] = *(void *)(a1 + 32);
      id v33 = *(id *)(a1 + 72);
      uint64_t v35 = v4;
      id v36 = *(id *)(a1 + 80);
      id v34 = v9;
      dispatch_async(v28, v32);
    }
    else
    {
      id v16 = [v15 _lookupEndpoint];
      id v17 = [v16 publicDeviceIdentityContainer];

      ((void (*)(void *, void *, void, void))v4[2])(v4, v17, 0, 0);
    }
  }
}

void sub_10007E938(uint64_t a1, void *a2, char a3, void *a4)
{
  id v7 = a4;
  uint64_t v8 = *(void **)(a1 + 32);
  id v9 = a2;
  id v10 = [v8 fullDeviceIdentityContainerEncrypter];
  uint64_t v11 = [v10 decryptData:*(void *)(a1 + 40) decryptionContext:*(void *)(a1 + 48) withPublicDeviceIdentityContainer:v9 usingIdentifier:*(void *)(a1 + 56) isRetry:*(unsigned __int8 *)(a1 + 80)];

  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_10007EA5C;
  v14[3] = &unk_1009809F0;
  char v19 = a3;
  uint64_t v12 = *(void *)(a1 + 32);
  id v15 = v7;
  uint64_t v16 = v12;
  id v17 = *(id *)(a1 + 64);
  id v18 = *(id *)(a1 + 72);
  id v13 = v7;
  [v11 registerResultBlock:v14];
}

void sub_10007EA5C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 state] == (id)1)
  {
    if (*(unsigned char *)(a1 + 64)
      && *(void *)(a1 + 32)
      && (uint64_t v4 = *(void **)(a1 + 40),
          [v3 error],
          unsigned int v5 = objc_claimAutoreleasedReturnValue(),
          LOBYTE(v4) = [v4 _isReplayError:v5],
          v5,
          (v4 & 1) == 0))
    {
      id v6 = *(id *)(a1 + 32);
    }
    else
    {
      id v6 = [v3 error];
    }
    id v7 = v6;
    uint64_t v8 = [*(id *)(a1 + 40) _lookupEndpoint];
    id v9 = [v7 domain];
    if ([v9 isEqualToString:IDSDecryptionErrorDomain]
      && ([v7 code] == (id)12 || objc_msgSend(v7, "code") == (id)9))
    {
      id v10 = [v8 identityContainerDeserializationError];

      if (v10)
      {
        uint64_t v11 = [v7 domain];
        id v12 = [v7 code];
        NSErrorUserInfoKey v36 = NSUnderlyingErrorKey;
        id v13 = [v8 identityContainerDeserializationError];
        __int16 v37 = v13;
        BOOL v14 = +[NSDictionary dictionaryWithObjects:&v37 forKeys:&v36 count:1];
        uint64_t v15 = +[NSError errorWithDomain:v11 code:v12 userInfo:v14];

        id v7 = (void *)v15;
      }
    }
    else
    {
    }
    id v20 = [[IDSDecryptionMetadata alloc] initWithUsedLastResortCache:*(unsigned __int8 *)(a1 + 64) usedCachedData:0 additionalDecryptionResult:0];

    id v17 = 0;
    id v18 = 0;
    char v19 = 0;
  }
  else
  {
    uint64_t v16 = [v3 value];
    id v17 = [v16 decryptedData];
    id v18 = [v16 encryptedAttributes];
    char v19 = [v16 additionalDecryptionResult];
    id v20 = [[IDSDecryptionMetadata alloc] initWithUsedLastResortCache:*(unsigned __int8 *)(a1 + 64) usedCachedData:0 additionalDecryptionResult:v19];
    if (!CUTIsInternalInstall()
      || (+[IMUserDefaults isWritePushPayloadsToDiskEnabled] & 1) == 0)
    {
      id v21 = [*(id *)(a1 + 40) replayCommitter];
      id v22 = [v16 commitBlock];
      [v21 holdCommitBlock:v22 andDecryptedData:v17 withEncryptedAttributes:v18 forKey:*(void *)(a1 + 48)];
    }
    id v7 = 0;
  }
  if ([*(id *)(a1 + 40) avoidMainQueue]) {
    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
  }
  CFStringRef v23 = im_primary_queue();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10007EE44;
  block[3] = &unk_1009809C8;
  id v30 = v17;
  id v31 = v7;
  uint64_t v32 = *(void *)(a1 + 40);
  id v24 = *(id *)(a1 + 56);
  id v34 = v20;
  id v35 = v24;
  id v33 = v18;
  uint64_t v25 = v20;
  id v26 = v18;
  id v27 = v7;
  id v28 = v17;
  dispatch_async(v23, block);
}

uint64_t sub_10007EE44(uint64_t a1)
{
  if (!*(void *)(a1 + 32) || *(void *)(a1 + 40))
  {
    id v2 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Flushing peer tokens, in hopes this resolves in the next error", v4, 2u);
    }

    if (os_log_shim_legacy_logging_enabled()) {
      _IDSLogEventV();
    }
  }
  uint64_t result = (uint64_t)[*(id *)(a1 + 48) avoidMainQueue];
  if ((result & 1) == 0) {
    return (*(uint64_t (**)(void))(*(void *)(a1 + 72) + 16))();
  }
  return result;
}

void sub_10007EF28(void *a1)
{
  uint64_t v1 = a1[7];
  uint64_t v2 = a1[4];
  uint64_t v3 = a1[5];
  uint64_t v4 = [[IDSDecryptionMetadata alloc] initWithUsedLastResortCache:0 usedCachedData:1 additionalDecryptionResult:a1[6]];
  (*(void (**)(uint64_t, uint64_t, uint64_t, void, IDSDecryptionMetadata *))(v1 + 16))(v1, v2, v3, 0, v4);
}

void sub_10007EFB4(id *a1)
{
  uint64_t v2 = a1 + 4;
  uint64_t v3 = [a1[4] remoteURI];
  uint64_t v4 = [v3 prefixedURI];
  unsigned __int8 v5 = [v4 _appearsToBePseudonymID];
  id v6 = *v2;
  if (v5)
  {
    id v7 = [v6 remoteURI];
    uint64_t v8 = [v7 prefixedURI];
  }
  else
  {
    uint64_t v8 = [v6 pushToken];
  }

  id v9 = [a1[4] rateLimiter];
  unsigned int v10 = [v9 underLimitForItem:v8];

  uint64_t v11 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    if (v10) {
      CFStringRef v12 = @"YES";
    }
    else {
      CFStringRef v12 = @"NO";
    }
    id v13 = [a1[4] remoteURI];
    BOOL v14 = [a1[4] localURI];
    uint64_t v15 = [a1[4] service];
    *(_DWORD *)buf = 138413058;
    CFStringRef v55 = v12;
    __int16 v56 = 2112;
    unint64_t v57 = v13;
    __int16 v58 = 2112;
    unint64_t v59 = v14;
    __int16 v60 = 2112;
    uint64_t v61 = v15;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Missing decryption keys, need to query {underLimit: %@, remoteURI: %@, localURI: %@, service: %@}", buf, 0x2Au);
  }
  if (os_log_shim_legacy_logging_enabled())
  {
    if (v10) {
      CFStringRef v16 = @"YES";
    }
    else {
      CFStringRef v16 = @"NO";
    }
    id v17 = [a1[4] remoteURI];
    id v18 = [a1[4] localURI];
    [a1[4] service];
    v40 = id v39 = v18;
    CFStringRef v37 = v16;
    id v38 = v17;
    _IDSLogEventV();
  }
  id v19 = a1[4];
  if (!v10)
  {
    if ([v19 avoidMainQueue]) {
      goto LABEL_23;
    }
    buf[0] = 0;
    uint64_t v29 = [a1[4] _lookupIdentityWithLastResortFallback:buf];
    id v30 = (void *)v29;
    if (!v29 || buf[0])
    {
      BOOL v32 = v29 != 0;
      +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", IDSDecryptionErrorDomain, 17, 0, v37, v38, v39, v40);
      id v31 = (id)objc_claimAutoreleasedReturnValue();
      if (!v32)
      {
        id v35 = a1[8];
        NSErrorUserInfoKey v36 = [IDSDecryptionMetadata alloc];
        id v34 = [(IDSDecryptionMetadata *)v36 initWithUsedLastResortCache:buf[0] usedCachedData:0 additionalDecryptionResult:a1[6]];
        (*((void (**)(id, void, void, id, IDSDecryptionMetadata *))v35 + 2))(v35, 0, 0, v31, v34);
        goto LABEL_22;
      }
    }
    else
    {
      id v31 = 0;
    }
    id v33 = a1[5];
    v43[0] = _NSConcreteStackBlock;
    v43[1] = 3221225472;
    v43[2] = sub_10007FA88;
    v43[3] = &unk_100980A68;
    id v46 = (IDSDecryptionMetadata *)a1[7];
    id v44 = v30;
    uint8_t v47 = buf[0];
    id v31 = v31;
    id v45 = v31;
    [v33 performAsyncBlock:v43];

    id v34 = v46;
LABEL_22:

    goto LABEL_23;
  }
  id v20 = [v19 peerIDManager];
  id v21 = [a1[4] remoteURI];
  id v22 = [a1[4] localURI];
  CFStringRef v23 = [a1[4] service];
  [v20 forgetPeerTokensForURI:v21 fromURI:v22 service:v23];

  id v41 = [[IDSPeerIDQueryContext alloc] initWithSending:0 refresh:0 messaging:0 resultExpected:1 preventNewQuery:0];
  __int16 v42 = [a1[4] peerIDManager];
  id v24 = [a1[4] remoteURI];
  uint64_t v25 = IMSingleObjectArray();
  id v26 = [a1[4] cert];
  id v27 = [a1[4] localURI];
  id v28 = [a1[4] service];
  v48[0] = _NSConcreteStackBlock;
  v48[1] = 3221225472;
  v48[2] = sub_10007F578;
  v48[3] = &unk_100980A90;
  v48[4] = a1[4];
  id v49 = v8;
  id v50 = a1[5];
  id v52 = a1[7];
  id v53 = a1[8];
  id v51 = a1[6];
  [v42 startQueryForURIs:v25 fromIdentity:v26 fromURI:v27 fromService:v28 context:v41 reason:@"URIDecrypt" completionBlock:v48];

LABEL_23:
}

void sub_10007F578(uint64_t a1, void *a2, void *a3, void *a4, void *a5, int a6, void *a7, char a8, void *a9)
{
  id v44 = a2;
  id v45 = a3;
  id v46 = a4;
  id v15 = a5;
  id v16 = a7;
  id v17 = a9;
  id v18 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    if (a6) {
      CFStringRef v19 = @"YES";
    }
    else {
      CFStringRef v19 = @"NO";
    }
    id v20 = [*(id *)(a1 + 32) remoteURI];
    id v21 = [*(id *)(a1 + 32) localURI];
    id v22 = [*(id *)(a1 + 32) service];
    *(_DWORD *)buf = 138413058;
    CFStringRef v57 = v19;
    __int16 v58 = 2112;
    unint64_t v59 = v20;
    __int16 v60 = 2112;
    uint64_t v61 = v21;
    __int16 v62 = 2112;
    uint64_t v63 = v22;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Decryption query completed {success: %@, remoteURI: %@, localURI: %@, service: %@}", buf, 0x2Au);
  }
  if (os_log_shim_legacy_logging_enabled())
  {
    if (a6) {
      CFStringRef v23 = @"YES";
    }
    else {
      CFStringRef v23 = @"NO";
    }
    id v24 = [*(id *)(a1 + 32) remoteURI];
    uint64_t v25 = [*(id *)(a1 + 32) localURI];
    [*(id *)(a1 + 32) service];
    __int16 v42 = v41 = v25;
    CFStringRef v39 = v23;
    id v40 = v24;
    _IDSLogEventV();
  }
  buf[0] = 0;
  id v26 = objc_msgSend(*(id *)(a1 + 32), "_lookupIdentityWithLastResortFallback:", buf, v39, v40, v41, v42);
  if (v26 && !buf[0])
  {
    id v27 = 0;
    goto LABEL_20;
  }
  id v28 = [*(id *)(a1 + 32) remoteURI];
  uint64_t v29 = [v16 objectForKey:v28];

  if (v29)
  {
    NSErrorUserInfoKey v54 = NSUnderlyingErrorKey;
    id v30 = [*(id *)(a1 + 32) remoteURI];
    id v31 = [v16 objectForKey:v30];
    CFStringRef v55 = v31;
    BOOL v32 = +[NSDictionary dictionaryWithObjects:&v55 forKeys:&v54 count:1];
  }
  else
  {
    if (!a6)
    {
      BOOL v32 = 0;
      goto LABEL_19;
    }
    NSErrorUserInfoKey v52 = NSUnderlyingErrorKey;
    id v30 = +[NSError errorWithDomain:IDSPeerIDManagerErrorDomain code:4 userInfo:0];
    id v53 = v30;
    BOOL v32 = +[NSDictionary dictionaryWithObjects:&v53 forKeys:&v52 count:1];
  }

LABEL_19:
  id v27 = +[NSError errorWithDomain:IDSDecryptionErrorDomain code:2 userInfo:v32];

LABEL_20:
  if (!((v26 == 0) | [*(id *)(a1 + 32) avoidMainQueue] & 1))
  {
    if (buf[0])
    {
      CFStringRef v37 = [*(id *)(a1 + 32) rateLimiter];
      [v37 noteItem:*(void *)(a1 + 40)];
    }
    id v38 = *(void **)(a1 + 48);
    v47[0] = _NSConcreteStackBlock;
    v47[1] = 3221225472;
    v47[2] = sub_10007FA6C;
    v47[3] = &unk_100980A68;
    id v50 = (IDSDecryptionMetadata *)*(id *)(a1 + 64);
    id v48 = v26;
    uint8_t v51 = buf[0];
    id v49 = v27;
    [v38 performAsyncBlock:v47];

    NSErrorUserInfoKey v36 = v50;
    goto LABEL_28;
  }
  if (([*(id *)(a1 + 32) avoidMainQueue] & 1) == 0)
  {
    if ((a8 & 1) == 0)
    {
      id v33 = [*(id *)(a1 + 32) rateLimiter];
      [v33 noteItem:*(void *)(a1 + 40)];
    }
    uint64_t v34 = *(void *)(a1 + 72);
    id v35 = [IDSDecryptionMetadata alloc];
    NSErrorUserInfoKey v36 = [(IDSDecryptionMetadata *)v35 initWithUsedLastResortCache:buf[0] usedCachedData:0 additionalDecryptionResult:*(void *)(a1 + 56)];
    (*(void (**)(uint64_t, void, void, void *, IDSDecryptionMetadata *))(v34 + 16))(v34, 0, 0, v27, v36);
LABEL_28:
  }
}

uint64_t sub_10007FA6C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void))(*(void *)(a1 + 48) + 16))(*(void *)(a1 + 48), *(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 56), *(void *)(a1 + 40));
}

uint64_t sub_10007FA88(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void))(*(void *)(a1 + 48) + 16))(*(void *)(a1 + 48), *(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 56), *(void *)(a1 + 40));
}

void sub_10007FBB8(uint64_t a1)
{
  v49[0] = _NSConcreteStackBlock;
  v49[1] = 3221225472;
  v49[2] = sub_10008012C;
  v49[3] = &unk_100980B08;
  uint64_t v2 = (id *)(a1 + 32);
  v49[4] = *(void *)(a1 + 32);
  id v50 = *(id *)(a1 + 64);
  uint64_t v3 = objc_retainBlock(v49);
  unsigned int v4 = [*v2 _isNGMKeyType];
  if (v4)
  {
    unsigned __int8 v5 = v45;
    v45[0] = _NSConcreteStackBlock;
    v45[1] = 3221225472;
    v45[2] = sub_100080234;
    v45[3] = &unk_100980B30;
    id v6 = *(void **)(a1 + 40);
    v45[4] = *(void *)(a1 + 32);
    id v30 = &v46;
    id v46 = v6;
    BOOL v32 = &v47;
    id v7 = *(id *)(a1 + 48);
    uint64_t v8 = *(void *)(a1 + 72);
    id v47 = v7;
    v48[1] = v8;
    uint64_t v34 = (id *)v48;
    v48[0] = v3;
  }
  else
  {
    unsigned __int8 v5 = 0;
  }
  id v9 = objc_retainBlock(v5);
  unsigned int v10 = [*(id *)(a1 + 32) _isSecKeyType];
  if (v10)
  {
    uint64_t v11 = v41;
    v41[0] = _NSConcreteStackBlock;
    v41[1] = 3221225472;
    v41[2] = sub_1000802F4;
    v41[3] = &unk_100980B58;
    CFStringRef v12 = *(void **)(a1 + 40);
    v41[4] = *(void *)(a1 + 32);
    id v31 = &v42;
    id v42 = v12;
    id v33 = &v43;
    id v43 = *(id *)(a1 + 48);
    id v35 = (id *)&v44;
    id v44 = v3;
  }
  else
  {
    uint64_t v11 = 0;
  }
  id v13 = objc_retainBlock(v11);
  if ([*(id *)(a1 + 32) _isNGMKeyType])
  {
    BOOL v14 = [*(id *)(a1 + 32) _lookupNGMVerificationIdentityShouldUseLastResort:0 usedLastResort:0];
  }
  else
  {
    BOOL v14 = 0;
  }
  if ([*(id *)(a1 + 32) _isSecKeyType])
  {
    id v15 = [*(id *)(a1 + 32) _copyLookupSecVerificationIdentity];
    if (!v14) {
      goto LABEL_18;
    }
  }
  else
  {
    id v15 = 0;
    if (!v14) {
      goto LABEL_18;
    }
  }
  if (v9)
  {
    ((void (*)(void *, void *, void))v9[2])(v9, v14, 0);
    goto LABEL_16;
  }
LABEL_18:
  if (v15 && v13)
  {
    ((void (*)(void *, id, void))v13[2])(v13, v15, 0);
    goto LABEL_21;
  }
  if ([*(id *)(a1 + 32) avoidMainQueue])
  {
    id v16 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v29 = [*(id *)(a1 + 32) remoteURI];
      id v28 = [*(id *)(a1 + 32) localURI];
      uint64_t v17 = [*(id *)(a1 + 32) service];
      *(_DWORD *)buf = 138412802;
      NSErrorUserInfoKey v52 = v29;
      __int16 v53 = 2112;
      NSErrorUserInfoKey v54 = v28;
      __int16 v55 = 2112;
      uint64_t v56 = v17;
      id v27 = (void *)v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Need to query for signing verification but should avoid main -- failing {remoteURI: %@, localURI: %@, service: %@}", buf, 0x20u);
    }
    if (os_log_shim_legacy_logging_enabled())
    {
      CFStringRef v19 = *(void **)(a1 + 32);
      id v18 = (id *)(a1 + 32);
      id v20 = [v19 remoteURI];
      id v21 = [*v18 localURI];
      [*v18 service];
      v26 = uint64_t v25 = v21;
      id v24 = v20;
      _IDSLogEventV();
    }
    id v22 = +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", IDSSigningErrorDomain, 6, 0, v24, v25, v26);
    ((void (*)(void *, void, void *))v3[2])(v3, 0, v22);
  }
  else
  {
    CFStringRef v23 = im_primary_queue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000803E0;
    block[3] = &unk_100980BD0;
    void block[4] = *(void *)(a1 + 32);
    id v38 = v3;
    id v37 = *(id *)(a1 + 56);
    CFStringRef v39 = v9;
    id v40 = v13;
    dispatch_async(v23, block);
  }
LABEL_16:
  if (v15) {
LABEL_21:
  }
    CFRelease(v15);

  if (v10)
  {
  }
  if (v4)
  {
  }
}

void sub_10008012C(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  if ([*(id *)(a1 + 32) avoidMainQueue])
  {
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    id v6 = im_primary_queue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10008021C;
    block[3] = &unk_1009802A0;
    id v9 = *(id *)(a1 + 40);
    char v10 = a2;
    id v8 = v5;
    dispatch_async(v6, block);
  }
}

uint64_t sub_10008021C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned __int8 *)(a1 + 48), *(void *)(a1 + 32));
}

void sub_100080234(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    unsigned int v4 = [*(id *)(a1 + 32) fullDeviceIdentitySigner];
    uint64_t v5 = *(void *)(a1 + 40);
    uint64_t v6 = *(void *)(a1 + 48);
    uint64_t v7 = *(void *)(a1 + 64);
    id v9 = 0;
    [v4 verifySignedData:v5 matchesData:v6 forType:v7 withPublicDeviceIdentity:v3 error:&v9];
    id v8 = v9;

    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
  }
}

void sub_1000802F4(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    unsigned int v4 = [*(id *)(a1 + 32) fullDeviceIdentitySigner];
    uint64_t v6 = *(void *)(a1 + 40);
    uint64_t v5 = *(void *)(a1 + 48);
    uint64_t v7 = [*(id *)(a1 + 32) keyDiversifier];
    id v10 = 0;
    [v4 verifySignedData:v6 matchesData:v5 withSecPublicDeviceIdentity:a2 diversifier:v7 error:&v10];
    id v8 = v10;

    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
  }
  else
  {
    id v9 = *(void (**)(void))(*(void *)(a1 + 56) + 16);
    v9();
  }
}

void sub_1000803E0(id *a1)
{
  uint64_t v2 = a1 + 4;
  id v3 = [a1[4] remoteURI];
  unsigned int v4 = [v3 prefixedURI];
  unsigned __int8 v5 = [v4 _appearsToBePseudonymID];
  uint64_t v6 = *v2;
  if (v5)
  {
    uint64_t v7 = [v6 remoteURI];
    id v8 = [v7 prefixedURI];
  }
  else
  {
    id v8 = [v6 pushToken];
  }

  id v9 = [a1[4] rateLimiter];
  unsigned int v10 = [v9 underLimitForItem:v8];

  uint64_t v11 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    if (v10) {
      CFStringRef v12 = @"YES";
    }
    else {
      CFStringRef v12 = @"NO";
    }
    id v13 = [a1[4] remoteURI];
    BOOL v14 = [a1[4] localURI];
    id v15 = [a1[4] service];
    *(_DWORD *)buf = 138413058;
    CFStringRef v48 = v12;
    __int16 v49 = 2112;
    id v50 = v13;
    __int16 v51 = 2112;
    NSErrorUserInfoKey v52 = v14;
    __int16 v53 = 2112;
    NSErrorUserInfoKey v54 = v15;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Missing signing verification key, need to query {underLimit: %@, remoteURI: %@, localURI: %@, service: %@}", buf, 0x2Au);
  }
  if (os_log_shim_legacy_logging_enabled())
  {
    if (v10) {
      CFStringRef v16 = @"YES";
    }
    else {
      CFStringRef v16 = @"NO";
    }
    uint64_t v17 = [a1[4] remoteURI];
    id v18 = [a1[4] localURI];
    [a1[4] service];
    v35 = uint64_t v34 = v18;
    CFStringRef v32 = v16;
    id v33 = v17;
    _IDSLogEventV();
  }
  if (!v10)
  {
    buf[0] = 0;
    if ([a1[4] _isNGMKeyType])
    {
      id v28 = [a1[4] _lookupNGMVerificationIdentityShouldUseLastResort:1 usedLastResort:buf];
      if (v28)
      {
        id v29 = a1[7];
        if (v29)
        {
          id v30 = a1[5];
          v38[0] = _NSConcreteStackBlock;
          v38[1] = 3221225472;
          v38[2] = sub_100080E24;
          v38[3] = &unk_10097E818;
          id v40 = v29;
          id v28 = v28;
          id v39 = v28;
          [v30 performAsyncBlock:v38];

          id v31 = v40;
LABEL_22:

          goto LABEL_23;
        }
      }
    }
    else
    {
      id v28 = 0;
    }
    id v31 = +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", IDSSigningErrorDomain, 8, 0, v32, v33, v34, v35);
    (*((void (**)(void))a1[6] + 2))();
    goto LABEL_22;
  }
  CFStringRef v19 = [a1[4] peerIDManager];
  id v20 = [a1[4] remoteURI];
  id v21 = [a1[4] localURI];
  id v22 = [a1[4] service];
  [v19 forgetPeerTokensForURI:v20 fromURI:v21 service:v22];

  NSErrorUserInfoKey v36 = [[IDSPeerIDQueryContext alloc] initWithSending:0 refresh:0 messaging:0 resultExpected:1 preventNewQuery:0];
  id v37 = [a1[4] peerIDManager];
  CFStringRef v23 = [a1[4] remoteURI];
  id v24 = IMSingleObjectArray();
  uint64_t v25 = [a1[4] cert];
  id v26 = [a1[4] localURI];
  id v27 = [a1[4] service];
  v41[0] = _NSConcreteStackBlock;
  v41[1] = 3221225472;
  v41[2] = sub_10008094C;
  v41[3] = &unk_100980BA8;
  v41[4] = a1[4];
  id v42 = v8;
  id v44 = a1[6];
  id v43 = a1[5];
  id v45 = a1[7];
  id v46 = a1[8];
  [v37 startQueryForURIs:v24 fromIdentity:v25 fromURI:v26 fromService:v27 context:v36 reason:@"URIVerify" completionBlock:v41];

LABEL_23:
}

void sub_10008094C(uint64_t a1, void *a2, void *a3, void *a4, void *a5, int a6, void *a7, char a8, void *a9)
{
  id v41 = a2;
  id v42 = a3;
  id v15 = a4;
  id v43 = a5;
  id v16 = a7;
  id v17 = a9;
  id v18 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    if (a6) {
      CFStringRef v19 = @"YES";
    }
    else {
      CFStringRef v19 = @"NO";
    }
    id v20 = [*(id *)(a1 + 32) remoteURI];
    id v21 = [*(id *)(a1 + 32) localURI];
    id v22 = [*(id *)(a1 + 32) service];
    *(_DWORD *)buf = 138413058;
    *(void *)&uint8_t buf[4] = v19;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v20;
    *(_WORD *)&buf[22] = 2112;
    unint64_t v51 = (unint64_t)v21;
    __int16 v52 = 2112;
    __int16 v53 = v22;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Signing verification query completed {success: %@, remoteURI: %@, localURI: %@, service: %@}", buf, 0x2Au);
  }
  if (os_log_shim_legacy_logging_enabled())
  {
    if (a6) {
      CFStringRef v23 = @"YES";
    }
    else {
      CFStringRef v23 = @"NO";
    }
    id v24 = [*(id *)(a1 + 32) remoteURI];
    uint64_t v25 = [*(id *)(a1 + 32) localURI];
    [*(id *)(a1 + 32) service];
    v39 = id v38 = v25;
    CFStringRef v36 = v23;
    id v37 = v24;
    _IDSLogEventV();
  }
  char v49 = 0;
  if (objc_msgSend(*(id *)(a1 + 32), "_isNGMKeyType", v36, v37, v38, v39))
  {
    id v26 = [*(id *)(a1 + 32) _lookupNGMVerificationIdentityShouldUseLastResort:1 usedLastResort:&v49];
  }
  else
  {
    id v26 = 0;
  }
  *(void *)buf = 0;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&uint8_t buf[16] = 0x2020000000;
  unint64_t v51 = 0xAAAAAAAAAAAAAAAALL;
  if ([*(id *)(a1 + 32) _isSecKeyType]) {
    id v27 = [*(id *)(a1 + 32) _copyLookupSecVerificationIdentity];
  }
  else {
    id v27 = 0;
  }
  unint64_t v51 = (unint64_t)v27;
  if (v26 || *(void *)(*(void *)&buf[8] + 24))
  {
    if (v49)
    {
      id v28 = [*(id *)(a1 + 32) rateLimiter];
      [v28 noteItem:*(void *)(a1 + 40)];
    }
    id v29 = *(void **)(a1 + 48);
    v44[0] = _NSConcreteStackBlock;
    v44[1] = 3221225472;
    v44[2] = sub_100080DAC;
    v44[3] = &unk_100980B80;
    id v46 = *(id *)(a1 + 64);
    id v45 = v26;
    id v47 = *(id *)(a1 + 72);
    CFStringRef v48 = buf;
    [v29 performAsyncBlock:v44];

    id v30 = v46;
  }
  else
  {
    id v31 = [*(id *)(a1 + 32) _lookupEndpoint];

    uint64_t v32 = 7;
    if (a6) {
      uint64_t v32 = 9;
    }
    if (v31) {
      uint64_t v33 = 10;
    }
    else {
      uint64_t v33 = v32;
    }
    id v30 = +[NSError errorWithDomain:IDSSigningErrorDomain code:v33 userInfo:0];
    if ((a8 & 1) == 0)
    {
      uint64_t v34 = [*(id *)(a1 + 32) rateLimiter];
      [v34 noteItem:*(void *)(a1 + 40)];
    }
    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
    id v35 = *(const void **)(*(void *)&buf[8] + 24);
    if (v35)
    {
      CFRelease(v35);
      *(void *)(*(void *)&buf[8] + 24) = 0;
    }
  }

  _Block_object_dispose(buf, 8);
}

void sub_100080D68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_100080DAC(void *a1)
{
  uint64_t v2 = a1[5];
  if (v2)
  {
    id v3 = a1 + 4;
  }
  else
  {
    uint64_t v2 = a1[6];
    if (!v2) {
      goto LABEL_6;
    }
    id v3 = (void *)(*(void *)(a1[7] + 8) + 24);
  }
  (*(void (**)(uint64_t, void, void))(v2 + 16))(v2, *v3, 0);
LABEL_6:
  unsigned int v4 = *(const void **)(*(void *)(a1[7] + 8) + 24);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(*(void *)(a1[7] + 8) + 24) = 0;
  }
}

uint64_t sub_100080E24(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

void sub_100081C90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100081CB4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100081CC4(uint64_t a1)
{
}

void sub_100081CCC(void *a1)
{
  uint64_t v2 = (void *)a1[4];
  uint64_t v3 = a1[5];
  uint64_t v4 = a1[6];
  uint64_t v5 = *(void *)(a1[8] + 8);
  id obj = *(id *)(v5 + 40);
  uint64_t v6 = [v2 _legacyEncryptData:v3 withEncryptedAttributes:v4 error:&obj];
  objc_storeStrong((id *)(v5 + 40), obj);
  uint64_t v7 = *(void *)(a1[7] + 8);
  id v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v6;
}

void sub_100081F88(id *a1)
{
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472;
  v16[2] = sub_100082254;
  v16[3] = &unk_1009800C0;
  uint64_t v2 = a1 + 4;
  v16[4] = a1[4];
  id v17 = a1[5];
  id v18 = v2[2];
  id v19 = v2[4];
  uint64_t v3 = objc_retainBlock(v16);
  uint64_t v4 = [*v2 publicKeyStorage];
  uint64_t v5 = [*v2 deviceID];
  uint64_t v6 = [v4 publicDeviceIdentityContainerForDeviceID:v5];
  BOOL v7 = v6 == 0;

  if (v7)
  {
    id v8 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      id v9 = [a1[4] deviceID];
      *(_DWORD *)buf = 138412290;
      id v21 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Missing device encryption keys -- querying {deviceID: %@}", buf, 0xCu);
    }
    if (os_log_shim_legacy_logging_enabled())
    {
      uint64_t v11 = [a1[4] deviceID];
      _IDSLogEventV();
    }
    unsigned int v10 = im_primary_queue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000822F8;
    block[3] = &unk_1009809A0;
    void block[4] = a1[4];
    id v13 = a1[7];
    BOOL v14 = v3;
    id v15 = a1[8];
    dispatch_async(v10, block);
  }
  else
  {
    ((void (*)(void *))v3[2])(v3);
  }
}

void sub_100082254(void *a1)
{
  uint64_t v2 = (void *)a1[4];
  uint64_t v3 = a1[5];
  uint64_t v4 = a1[6];
  id v10 = 0;
  uint64_t v5 = [v2 _legacyEncryptData:v3 withEncryptedAttributes:v4 error:&v10];
  id v6 = v10;
  uint64_t v7 = a1[7];
  id v8 = [IDSEncryptionMetadata alloc];
  id v9 = [(IDSEncryptionMetadata *)v8 initWithMPIdentityIdentifier:IDSMPLegacyIdentityIdentifier];
  (*(void (**)(uint64_t, void *, id, IDSEncryptionMetadata *))(v7 + 16))(v7, v5, v6, v9);
}

void sub_1000822F8(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) accountController];
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_1000823C4;
  v4[3] = &unk_100980978;
  uint64_t v3 = *(void **)(a1 + 40);
  void v4[4] = *(void *)(a1 + 32);
  id v5 = v3;
  id v6 = *(id *)(a1 + 48);
  id v7 = *(id *)(a1 + 56);
  [v2 issueDependentIDQueriesWithCompletionBlock:v4];
}

void sub_1000823C4(uint64_t a1, void *a2, void *a3, void *a4, void *a5, int a6, void *a7, uint64_t a8, void *a9)
{
  id v15 = a2;
  id v16 = a3;
  id v17 = a4;
  id v18 = a5;
  id v19 = a7;
  id v20 = a9;
  id v21 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v22 = [*(id *)(a1 + 32) deviceID];
    CFStringRef v23 = (void *)v22;
    CFStringRef v24 = @"NO";
    if (a6) {
      CFStringRef v24 = @"YES";
    }
    *(_DWORD *)buf = 138412546;
    CFStringRef v29 = v24;
    __int16 v30 = 2112;
    uint64_t v31 = v22;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Device encryption query completed {success: %@, deviceID: %@}", buf, 0x16u);
  }
  if (os_log_shim_legacy_logging_enabled())
  {
    id v27 = [*(id *)(a1 + 32) deviceID];
    _IDSLogEventV();
  }
  if (a6)
  {
    [*(id *)(a1 + 40) performAsyncBlock:*(void *)(a1 + 48)];
  }
  else
  {
    uint64_t v25 = *(void *)(a1 + 56);
    id v26 = +[NSError errorWithDomain:IDSEncryptionErrorDomain code:1 userInfo:0];
    (*(void (**)(uint64_t, void, void *, void))(v25 + 16))(v25, 0, v26, 0);
  }
}

void sub_1000827C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 112), 8);
  _Unwind_Resume(a1);
}

void sub_1000827E4(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = *(unsigned __int8 *)(a1 + 72);
  uint64_t v6 = *(void *)(*(void *)(a1 + 64) + 8);
  id obj = *(id *)(v6 + 40);
  uint64_t v7 = [v2 _decryptData:v3 usingIdentifier:v4 isRetry:v5 error:&obj];
  objc_storeStrong((id *)(v6 + 40), obj);
  uint64_t v8 = *(void *)(*(void *)(a1 + 56) + 8);
  id v9 = *(void **)(v8 + 40);
  *(void *)(v8 + 40) = v7;
}

void sub_100082978(id *a1)
{
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472;
  v16[2] = sub_100082C4C;
  v16[3] = &unk_100980C98;
  uint64_t v2 = a1 + 4;
  v16[4] = a1[4];
  id v17 = a1[5];
  id v18 = v2[2];
  char v20 = *((unsigned char *)v2 + 40);
  id v19 = v2[4];
  uint64_t v3 = objc_retainBlock(v16);
  uint64_t v4 = [*v2 publicKeyStorage];
  uint64_t v5 = [*v2 deviceID];
  uint64_t v6 = [v4 publicDeviceIdentityContainerForDeviceID:v5];
  BOOL v7 = v6 == 0;

  if (v7)
  {
    uint64_t v8 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      id v9 = [a1[4] deviceID];
      *(_DWORD *)buf = 138412290;
      uint64_t v22 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Missing device decryption keys -- querying {deviceID: %@}", buf, 0xCu);
    }
    if (os_log_shim_legacy_logging_enabled())
    {
      uint64_t v11 = [a1[4] deviceID];
      _IDSLogEventV();
    }
    id v10 = im_primary_queue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100082EF4;
    block[3] = &unk_1009809A0;
    void block[4] = a1[4];
    id v13 = a1[7];
    BOOL v14 = v3;
    id v15 = a1[8];
    dispatch_async(v10, block);
  }
  else
  {
    ((void (*)(void *))v3[2])(v3);
  }
}

void sub_100082C4C(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) _decryptData:*(void *)(a1 + 40) usingIdentifier:*(void *)(a1 + 48) isRetry:*(unsigned __int8 *)(a1 + 64)];
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100082CF4;
  v3[3] = &unk_100980C70;
  id v4 = *(id *)(a1 + 56);
  [v2 registerResultBlock:v3];
}

void sub_100082CF4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init(IDSDecryptionMetadata);
  if ([v3 state] == (id)1)
  {
    uint64_t v5 = [v3 error];
    uint64_t v6 = 0;
    BOOL v7 = 0;
  }
  else
  {
    uint64_t v8 = [v3 value];
    BOOL v7 = [v8 decryptedData];
    uint64_t v6 = [v8 encryptedAttributes];
    uint64_t v9 = [v8 commitBlock];
    id v10 = (void *)v9;
    if (v9)
    {
      id v14 = 0;
      char v11 = (*(uint64_t (**)(uint64_t, id *))(v9 + 16))(v9, &v14);
      id v12 = v14;
      if ((v11 & 1) == 0)
      {
        id v13 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          id v16 = v12;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Error committing replay state for device ID decryption { error: %@ }", buf, 0xCu);
        }

        if (os_log_shim_legacy_logging_enabled()) {
          _IDSLogEventV();
        }
      }
    }
    uint64_t v5 = 0;
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32));
}

void sub_100082EF4(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) rateLimiter];
  id v3 = [*(id *)(a1 + 32) deviceID];
  unsigned int v4 = [v2 underLimitForItem:v3];

  if (v4)
  {
    uint64_t v5 = [*(id *)(a1 + 32) accountController];
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_10008308C;
    v10[3] = &unk_100980978;
    uint64_t v6 = *(void **)(a1 + 40);
    void v10[4] = *(void *)(a1 + 32);
    id v11 = v6;
    id v12 = *(id *)(a1 + 48);
    id v13 = *(id *)(a1 + 56);
    [v5 issueDependentIDQueriesWithCompletionBlock:v10];
  }
  else
  {
    uint64_t v7 = *(void *)(a1 + 56);
    id v9 = +[NSError errorWithDomain:IDSDecryptionErrorDomain code:17 userInfo:0];
    uint64_t v8 = objc_alloc_init(IDSDecryptionMetadata);
    (*(void (**)(uint64_t, void, void, id, IDSDecryptionMetadata *))(v7 + 16))(v7, 0, 0, v9, v8);
  }
}

void sub_10008308C(uint64_t a1, void *a2, void *a3, void *a4, void *a5, int a6, void *a7, char a8, void *a9)
{
  id v16 = a2;
  id v40 = a3;
  id v41 = a4;
  id v42 = a5;
  id v17 = a7;
  id v18 = a9;
  id v19 = [*(id *)(a1 + 32) publicKeyStorage];
  char v20 = [*(id *)(a1 + 32) deviceID];
  id v21 = [v19 publicDeviceIdentityContainerForDeviceID:v20];

  uint64_t v22 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v23 = [*(id *)(a1 + 32) deviceID];
    CFStringRef v24 = (void *)v23;
    CFStringRef v25 = @"NO";
    if (v21) {
      CFStringRef v26 = @"YES";
    }
    else {
      CFStringRef v26 = @"NO";
    }
    *(_DWORD *)buf = 138412802;
    if (a6) {
      CFStringRef v25 = @"YES";
    }
    CFStringRef v46 = v25;
    __int16 v47 = 2112;
    CFStringRef v48 = v26;
    __int16 v49 = 2112;
    uint64_t v50 = v23;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Device decryption query completed {success: %@, hasKeyAfterQuery: %@, deviceID: %@}", buf, 0x20u);
  }
  if (os_log_shim_legacy_logging_enabled())
  {
    if (a6) {
      CFStringRef v27 = @"YES";
    }
    else {
      CFStringRef v27 = @"NO";
    }
    if (v21) {
      CFStringRef v28 = @"YES";
    }
    else {
      CFStringRef v28 = @"NO";
    }
    [*(id *)(a1 + 32) deviceID];
    v39 = CFStringRef v38 = v28;
    CFStringRef v37 = v27;
    _IDSLogEventV();
  }
  if (a6 && v21)
  {
    [*(id *)(a1 + 40) performAsyncBlock:*(void *)(a1 + 48)];
  }
  else
  {
    if ((a8 & 1) == 0)
    {
      CFStringRef v29 = [*(id *)(a1 + 32) rateLimiter];
      __int16 v30 = [*(id *)(a1 + 32) deviceID];
      [v29 noteItem:v30];
    }
    uint64_t v31 = objc_msgSend(v17, "objectForKey:", v16, v37, v38, v39, v40, v41, v42);

    if (v31)
    {
      NSErrorUserInfoKey v43 = NSUnderlyingErrorKey;
      uint64_t v32 = [v17 objectForKey:v16];
      id v44 = v32;
      uint64_t v33 = +[NSDictionary dictionaryWithObjects:&v44 forKeys:&v43 count:1];
    }
    else
    {
      uint64_t v33 = 0;
    }
    uint64_t v34 = *(void *)(a1 + 56);
    id v35 = +[NSError errorWithDomain:IDSDecryptionErrorDomain code:2 userInfo:v33];
    CFStringRef v36 = objc_alloc_init(IDSDecryptionMetadata);
    (*(void (**)(uint64_t, void, void, void *, IDSDecryptionMetadata *))(v34 + 16))(v34, 0, 0, v35, v36);
  }
}

void sub_100087968(uint64_t a1, int token)
{
  uint64_t state64 = 0;
  notify_get_state(token, &state64);
  id v3 = +[IDSFoundationLog IDSDSession];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    uint64_t v10 = state64;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Sliced cellular interface - received bitmask: %llu", buf, 0xCu);
  }

  unsigned int v4 = +[IDSNWPathUtils sharedInstance];
  uint64_t v5 = state64;
  uint64_t v6 = [*(id *)(a1 + 32) sharedState];
  uint64_t v7 = [v6 uniqueID];
  [v4 setSliceInterfaceBitMask:v5 forSession:v7];
}

double sub_100087A84()
{
  if (qword_100A4A5D0 != -1) {
    dispatch_once(&qword_100A4A5D0, &stru_100981748);
  }
  return *(double *)&qword_100A4A5D8 * (double)mach_continuous_time();
}

void sub_100087AD4(uint64_t a1, void *a2)
{
  id v10 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (v10 && WeakRetained && [v10 length])
  {
    unsigned int v4 = [WeakRetained utunController];
    uint64_t v5 = [*(id *)(a1 + 32) sharedState];
    uint64_t v6 = [v5 uniqueID];
    [v4 setCellInterfaceName:v10 forIDSSession:v6];

    if (qword_100A4A5D0 != -1) {
      dispatch_once(&qword_100A4A5D0, &stru_100981748);
    }
    uint64_t v7 = mach_continuous_time();
    if (!WeakRetained[45])
    {
      uint64_t v8 = +[NSNumber numberWithDouble:*(double *)&qword_100A4A5D8 * (double)v7 - *(double *)(a1 + 48)];
      id v9 = (void *)WeakRetained[45];
      WeakRetained[45] = v8;
    }
  }
}

void sub_100087C00(void *a1, dispatch_qos_class_t a2, void *a3)
{
  uint64_t v5 = a1;
  id v6 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS|DISPATCH_BLOCK_ASSIGN_CURRENT, a2, 0, a3);
  dispatch_async(v5, v6);
}

void sub_100087C78(uint64_t a1)
{
  id v15 = [*(id *)(a1 + 32) groupStatusNotificationController];
  id v14 = [*(id *)(a1 + 32) sharedState];
  id v13 = [v14 destinations];
  uint64_t v2 = [v13 allObjects];
  id v12 = [*(id *)(a1 + 32) sharedState];
  id v3 = [v12 groupID];
  unsigned int v4 = [*(id *)(a1 + 32) sharedState];
  uint64_t v5 = [v4 uniqueID];
  id v6 = [*(id *)(a1 + 32) sharedState];
  uint64_t v7 = [v6 fromURI];
  uint64_t v8 = [*(id *)(a1 + 32) accountController];
  id v9 = [*(id *)(a1 + 32) sharedState];
  id v10 = [v9 accountID];
  id v11 = [v8 accountWithUniqueID:v10];
  [v15 pushTokenLookup:v2 forGroup:v3 sessionID:v5 fromURI:v7 account:v11 completionBlock:0];
}

id sub_100087E00(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _generateKeys:*(void *)(a1 + 40)];
}

void sub_100089DA4(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog IDSDSession];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = *(unsigned __int8 *)(a1 + 40);
    int v5 = *(unsigned __int8 *)(a1 + 41);
    *(_DWORD *)buf = 138412802;
    uint64_t v9 = v3;
    __int16 v10 = 1024;
    int v11 = v4;
    __int16 v12 = 1024;
    int v13 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "<%@> _lightweightParticipantSync: generationCounterLSB: %u, currentGenerationCounterLSB: %u, request up-to-date lightweight participants", buf, 0x18u);
  }

  id v6 = *(void **)(a1 + 32);
  uint64_t v7 = +[NSDictionary dictionaryWithObjectsAndKeys:](NSDictionary, "dictionaryWithObjectsAndKeys:", &off_1009D0D38, IDSGlobalLinkOptionSessionInfoRequestTypeKey, 0);
  [v6 requestSessionInfoWithOptions:v7];
}

void sub_100089FBC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v3 = WeakRetained;
  if (*(unsigned char *)(a1 + 75)) {
    BOOL v4 = *(unsigned char *)(a1 + 75) == 9;
  }
  else {
    BOOL v4 = 1;
  }
  int v5 = v4;
  id v6 = (void *)WeakRetained[44];
  if (v6)
  {
    uint64_t v7 = [v6 objectForKey:IDSDSessionReportCellularNetworkInfoIsNetworkSliceActive];
    unsigned int v8 = [v7 BOOLValue];
  }
  else
  {
    unsigned int v8 = 0;
  }
  uint64_t v9 = +[NSString stringWithCString:a1 + 118 encoding:4];
  __int16 v10 = (void *)v3[44];
  if (v10)
  {
    int v11 = [v10 objectForKey:IDSDSessionReportCellularNetworkInfoCellularInterfaceName];
    __int16 v12 = v11;
    if (v11) {
      LOBYTE(v10) = [v11 isEqualToString:v9];
    }
    else {
      LOBYTE(v10) = 0;
    }
  }
  else
  {
    __int16 v12 = 0;
  }
  if (((v5 | v8) & 1) == 0 && (v10 & 1) == 0)
  {
    int v13 = +[NSString stringWithCString:IDSRadioAccessTechnologyToString() encoding:4];
    id v14 = [v3 getCellularNetworkInfo:v9];
    id v15 = [v14 mutableCopy];

    if (v13) {
      [v15 setObject:v13 forKey:IDSDSessionReportCellularNetworkInfoLocalCellularRadioAccessTech];
    }
    uint64_t v16 = v3[45];
    if (v16) {
      [v15 setObject:v16 forKey:IDSDSessionReportCellularNetworkInfoInterfaceBringupTime];
    }
    [v15 setObject:&off_1009D0D50 forKeyedSubscript:IDSDSessionReportQREventSubTypeKey];
    [v15 setObject:&off_1009D0D68 forKeyedSubscript:IDSDSessionReportResultCodeKey];
    id v17 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      id v20 = v15;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "networkSlicing: networkInfo=%@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    id v18 = (void *)v3[44];
    v3[44] = v15;
  }
}

void sub_10008ABA4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  [v6 setVerboseFunctionalLogging:*(unsigned __int8 *)(*(void *)(a1 + 32) + 601)];
  [v6 setVerbosePerformanceLogging:*(unsigned __int8 *)(*(void *)(a1 + 32) + 602)];
  uint64_t v7 = [v6 description];
  unsigned int v8 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 96);
    *(_DWORD *)buf = 138412546;
    __int16 v47 = v7;
    __int16 v48 = 2048;
    uint64_t v49 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Client channel connected %@ (connections claimed %lu)", buf, 0x16u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      id v35 = v7;
      uint64_t v36 = *(void *)(*(void *)(a1 + 32) + 96);
      _IDSLogTransport();
      if (_IDSShouldLog())
      {
        id v35 = v7;
        uint64_t v36 = *(void *)(*(void *)(a1 + 32) + 96);
        _IDSLogV();
      }
    }
  }
  objc_msgSend(*(id *)(*(void *)(a1 + 32) + 896), "clientChannelConnected", v35, v36);
  __int16 v10 = [*(id *)(a1 + 32) sharedState];
  if ([v10 useQRDirectly]) {
    goto LABEL_12;
  }
  int v11 = [*(id *)(a1 + 32) sharedState];
  if ([v11 clientType] == (id)1)
  {
LABEL_11:

LABEL_12:
    goto LABEL_13;
  }
  __int16 v12 = [*(id *)(a1 + 32) sharedState];
  if ([v12 clientType] == (id)5)
  {

    goto LABEL_11;
  }
  id v21 = [*(id *)(a1 + 32) sharedState];
  BOOL v22 = [v21 clientType] == (id)6;

  if (v22)
  {
LABEL_13:
    if ([v6 hasMetadata]) {
      goto LABEL_14;
    }
    id v17 = [*(id *)(a1 + 32) sharedState];
    if ([v17 clientType] != (id)1)
    {
      id v18 = [*(id *)(a1 + 32) sharedState];
      if ([v18 clientType] != (id)5)
      {
        uint64_t v31 = [*(id *)(a1 + 32) sharedState];
        BOOL v32 = [v31 clientType] == (id)6;

        if (!v32)
        {
LABEL_14:
          id v39 = _NSConcreteStackBlock;
          uint64_t v40 = 3221225472;
          id v41 = sub_10008B208;
          id v42 = &unk_100980D88;
          uint64_t v43 = *(void *)(a1 + 32);
          id v13 = v6;
          id v44 = v13;
          IDSTransportThreadAddBlock();
          id v14 = +[IMLockdownManager sharedInstance];
          unsigned int v15 = [v14 isInternalInstall];

          uint64_t v16 = &v44;
          if (v15) {
            [*(id *)(a1 + 32) _checkAndRunClientChannelTests:v13];
          }
          goto LABEL_16;
        }
LABEL_25:
        id v19 = im_primary_queue();
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_10008B1FC;
        block[3] = &unk_10097E4D0;
        void block[4] = *(void *)(a1 + 32);
        dispatch_block_t v20 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS|DISPATCH_BLOCK_ASSIGN_CURRENT, QOS_CLASS_USER_INTERACTIVE, 0, block);
        dispatch_async(v19, v20);

        goto LABEL_26;
      }
    }
    goto LABEL_25;
  }
  uint64_t v23 = *(void *)(a1 + 32);
  uint64_t v24 = *(void *)(v23 + 96);
  if (v24)
  {
    CFStringRef v25 = (void *)(v24 - 1);
    id v26 = (id)v23;
    objc_sync_enter(v26);
    CFStringRef v27 = *(void **)(*(void *)(a1 + 32) + 144);
    CFStringRef v28 = +[NSNumber numberWithUnsignedInteger:v25];
    CFStringRef v29 = [v27 objectForKey:v28];

    objc_sync_exit(v26);
    if (v29)
    {
      unsigned int v30 = [v29 intValue];
    }
    else
    {
      uint64_t v34 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        __int16 v47 = v25;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Lost race condition - missing connection for extra connection %lu", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLogTransport())
        {
          _IDSLogTransport();
          if (_IDSShouldLog()) {
            _IDSLogV();
          }
        }
      }
      unsigned int v30 = -1;
    }

    uint64_t v23 = *(void *)(a1 + 32);
    uint64_t v33 = *(void *)(v23 + 96) + 1;
  }
  else
  {
    unsigned int v30 = *(_DWORD *)(v23 + 584);
    uint64_t v33 = 1;
  }
  *(void *)(v23 + 96) = v33;
  if (v30 == -1) {
    goto LABEL_17;
  }
  id v37 = v6;
  unsigned int v38 = v30;
  IDSTransportThreadAddBlock();
  uint64_t v16 = &v37;
LABEL_16:

LABEL_17:
  if (*(double *)(*(void *)(a1 + 32) + 416) == 0.0)
  {
    if (qword_100A4A5D0 != -1) {
      dispatch_once(&qword_100A4A5D0, &stru_100981748);
    }
    *(double *)(*(void *)(a1 + 32) + 416) = *(double *)&qword_100A4A5D8 * (double)mach_continuous_time();
  }
LABEL_26:
}

id sub_10008B1FC(uint64_t a1)
{
  return [*(id *)(a1 + 32) endSessionWithReason:20];
}

void *sub_10008B208(void *result, char a2)
{
  if ((a2 & 1) == 0)
  {
    uint64_t v3 = result;
    uint64_t v4 = result[4];
    id v5 = *(void **)(v4 + 72);
    if (v5)
    {
      id v6 = (void *)v3[5];
      uint64_t v7 = [v5 cachedDataForClient];
      [v6 setCachedDataForClient:v7];

      uint64_t v4 = v3[4];
    }
    os_unfair_lock_lock((os_unfair_lock_t)(v4 + 88));
    objc_storeStrong((id *)(v3[4] + 72), (id)v3[5]);
    os_unfair_lock_unlock((os_unfair_lock_t)(v3[4] + 88));
    uint64_t v8 = [(id)v3[5] uuid];
    uint64_t v9 = v3[4];
    __int16 v10 = *(void **)(v9 + 80);
    *(void *)(v9 + 80) = v8;

    [(id)v3[4] _connectQRDirectlyToClientChannel:v3[5]];
    int v11 = [(id)v3[4] utunController];
    id v12 = [(id)v3[5] clientUniquePID];
    id v13 = [(id)v3[4] sharedState];
    id v14 = [v13 uniqueID];
    objc_msgSend(v11, "onTransportThread_setClientUniquePID:sessionID:", v12, v14);

    [(id)v3[4] _checkAndSendCachedDataForClient:v3[5]];
    unsigned int v15 = (void *)v3[5];
    return [v15 writePacketBuffer:0 metaData:0 metadataSize:0 moreComing:0];
  }
  return result;
}

void *sub_10008B334(void *result, char a2)
{
  if ((a2 & 1) == 0)
  {
    uint64_t v2 = result;
    uint64_t v3 = result[4];
    if (*(unsigned char *)(v3 + 48))
    {
      if (*(void *)(v3 + 72))
      {
        uint64_t v4 = (void *)v2[5];
        id v5 = [*(id *)(v3 + 72) cachedDataForClient];
        [v4 setCachedDataForClient:v5];

        uint64_t v3 = v2[4];
      }
      os_unfair_lock_lock((os_unfair_lock_t)(v3 + 88));
      objc_storeStrong((id *)(v2[4] + 72), (id)v2[5]);
      os_unfair_lock_unlock((os_unfair_lock_t)(v2[4] + 88));
      [(id)v2[4] _connectSocketDescriptor:*((unsigned int *)v2 + 12) toClientChannel:v2[5]];
      [(id)v2[4] _checkAndSendCachedDataForClient:v2[5]];
      id v6 = (void *)v2[5];
      return [v6 writePacketBuffer:0 metaData:0 metadataSize:0 moreComing:0];
    }
    else
    {
      uint64_t v7 = *((unsigned int *)v2 + 12);
      uint64_t v8 = v2[5];
      return [(id)v3 _connectSocketDescriptor:v7 toClientChannel:v8];
    }
  }
  return result;
}

void sub_10008B890(id a1)
{
  off_100A4A5C0 = (uint64_t (*)(void, void, void))IMWeakLinkSymbol();
}

id sub_10008B8C0(uint64_t a1)
{
  return [*(id *)(a1 + 32) endSessionWithReason:20];
}

void sub_10008C5D4(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v3 = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v4 = v3;
  if (v3 && WeakRetained)
  {
    [v3 _checkAndSendCachedDataForClient:WeakRetained];
    [WeakRetained writePacketBuffer:0 metaData:0 metadataSize:0 moreComing:0];
  }
  else
  {
    id v5 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134218240;
      id v7 = WeakRetained;
      __int16 v8 = 2048;
      uint64_t v9 = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%p: writeHandler: IDSDSession %p", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
  }
}

uint64_t sub_10008CCF4(uint64_t result, char a2)
{
  if ((a2 & 1) == 0)
  {
    uint64_t v2 = result;
    int v14 = -1431655766;
    *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
    void v13[4] = v3;
    v13[5] = v3;
    v13[3] = v3;
    v13[1] = v3;
    v13[2] = v3;
    v13[0] = v3;
    IDSByteBufferInitForWriteWithAllocatedSpace();
    IDSByteBufferWriteField();
    int v4 = -1;
    do
      ++v4;
    while (([*(id *)(v2 + 32) writePacketBuffer:0 metaData:v13 metadataSize:0 moreComing:1] & 1) != 0);
    IDSByteBufferRelease();
    id v5 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(void *)(v2 + 32);
      *(_DWORD *)buf = 67109634;
      int v8 = v4;
      __int16 v9 = 1024;
      int v10 = 0;
      __int16 v11 = 2112;
      uint64_t v12 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "generateClientChannelDataTest: wrote %d test metadata (size %u) into client channel %@", buf, 0x18u);
    }

    uint64_t result = os_log_shim_legacy_logging_enabled();
    if (result)
    {
      uint64_t result = _IDSShouldLogTransport();
      if (result)
      {
        _IDSLogTransport();
        uint64_t result = _IDSShouldLog();
        if (result) {
          return _IDSLogV();
        }
      }
    }
  }
  return result;
}

uint64_t sub_10008CEF4(uint64_t result, char a2)
{
  if ((a2 & 1) == 0)
  {
    uint64_t v2 = result;
    int v15 = -1431655766;
    *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
    void v14[4] = v3;
    v14[5] = v3;
    v14[3] = v3;
    v14[1] = v3;
    v14[2] = v3;
    v14[0] = v3;
    IDSByteBufferInitForWriteWithAllocatedSpace();
    IDSByteBufferWriteField();
    int v4 = 79;
    do
      ++v4;
    while (([*(id *)(v2 + 32) writePacketBuffer:0 metaData:v14 metadataSize:0 moreComing:1] & 1) != 0);
    int v5 = 80;
    do
    {
      [*(id *)(v2 + 40) writeToClientChannel:*(void *)(v2 + 32) packetBuffer:0 metaData:v14 metadataSize:0];
      --v5;
    }
    while (v5);
    IDSByteBufferRelease();
    uint64_t v6 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(v2 + 32);
      *(_DWORD *)buf = 67109634;
      int v9 = v4;
      __int16 v10 = 1024;
      int v11 = 0;
      __int16 v12 = 2112;
      uint64_t v13 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "overflowClientChannelDataTest wrote %d test metadata (size %u) into client channel %@", buf, 0x18u);
    }

    uint64_t result = os_log_shim_legacy_logging_enabled();
    if (result)
    {
      uint64_t result = _IDSShouldLogTransport();
      if (result)
      {
        _IDSLogTransport();
        uint64_t result = _IDSShouldLog();
        if (result) {
          return _IDSLogV();
        }
      }
    }
  }
  return result;
}

uint64_t sub_10008D114(uint64_t result, char a2)
{
  if ((a2 & 1) == 0)
  {
    uint64_t v2 = result;
    int v15 = -1431655766;
    *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
    void v14[4] = v3;
    v14[5] = v3;
    v14[3] = v3;
    v14[1] = v3;
    v14[2] = v3;
    v14[0] = v3;
    IDSByteBufferInitForWriteWithAllocatedSpace();
    IDSByteBufferWriteField();
    int v4 = 79;
    do
      ++v4;
    while (([*(id *)(v2 + 32) writePacketBuffer:0 metaData:0xAAAAAAAAAAAAAAAALL metadataSize:0 moreComing:1] & 1) != 0);
    int v5 = 80;
    do
    {
      [*(id *)(v2 + 40) writeToClientChannel:*(void *)(v2 + 32) packetBuffer:0 metaData:v14 metadataSize:0];
      --v5;
    }
    while (v5);
    IDSByteBufferRelease();
    uint64_t v6 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(v2 + 32);
      *(_DWORD *)buf = 67109634;
      int v9 = v4;
      __int16 v10 = 1024;
      int v11 = 0;
      __int16 v12 = 2112;
      uint64_t v13 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "overflowClientChannelDataTest wrote %d test metadata (size %u) into client channel %@", buf, 0x18u);
    }

    uint64_t result = os_log_shim_legacy_logging_enabled();
    if (result)
    {
      uint64_t result = _IDSShouldLogTransport();
      if (result)
      {
        _IDSLogTransport();
        uint64_t result = _IDSShouldLog();
        if (result) {
          return _IDSLogV();
        }
      }
    }
  }
  return result;
}

id sub_10008D808(uint64_t a1)
{
  return [*(id *)(a1 + 32) endSessionWithReason:23];
}

id sub_10008D814(uint64_t a1)
{
  return [*(id *)(a1 + 32) endSessionWithReason:20];
}

uint64_t sub_10008D820(uint64_t a1)
{
  uint64_t v2 = _IDSLinkPacketBufferCreate();
  long long v3 = (void *)read(*(_DWORD *)(a1 + 48), *(void **)v2, 0x7D0uLL);
  uint64_t v4 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v4 + 602) || *(unsigned char *)(v4 + 601))
  {
    int v5 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *(_DWORD *)(a1 + 48);
      uint64_t v7 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 134218498;
      *(void *)&uint8_t buf[4] = v3;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v6;
      *(_WORD *)&buf[18] = 2112;
      *(void *)&buf[20] = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "got data %ld from socket %d clientChannel %@", buf, 0x1Cu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      uint64_t v26 = *(unsigned int *)(a1 + 48);
      uint64_t v27 = *(void *)(a1 + 40);
      CFStringRef v25 = v3;
      _IDSLogV();
    }
  }
  if (v3)
  {
    if (v3 != (void *)-1)
    {
      *(void *)(v2 + 16) = v3;
      if ([*(id *)(a1 + 40) hasMetadata])
      {
        uint64_t v13 = *(void *)v2 + *(void *)(v2 + 16);
        unint64_t v29 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&long long v14 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)buf = v14;
        *(_OWORD *)&uint8_t buf[16] = v14;
        IDSByteBufferInitForWriteWithAllocatedSpace();
        IDSByteBufferWriteField();
        IDSByteBufferWriteField();
        IDSByteBufferWriteField();
        IDSByteBufferWriteField();
        IDSByteBufferWriteField();
        __int16 v15 = *(_WORD *)&buf[16];
        __int16 v16 = *(_WORD *)buf;
        IDSByteBufferRelease();
        uint64_t v17 = (unsigned __int16)(v15 - v16);
      }
      else
      {
        uint64_t v13 = 0;
        uint64_t v17 = 0;
      }
      objc_msgSend(*(id *)(a1 + 32), "writeToClientChannel:packetBuffer:metaData:metadataSize:", *(void *)(a1 + 40), v2, v13, v17, v25, v26, v27);
      return _IDSLinkPacketBufferRelease();
    }
    unsigned int v8 = *__error();
    if (v8 <= 0x24 && ((1 << v8) & 0x1800000010) != 0)
    {
      BOOL v9 = 1;
    }
    else
    {
      long long v3 = objc_msgSend(*(id *)(a1 + 32), "sharedState", v25, v26, v27);
      id v18 = [v3 transportType];
      BOOL v9 = v8 == 61 && v18 == 0;
    }
    if (v8 > 0x24 || ((1 << v8) & 0x1800000010) == 0) {

    }
    if (v9)
    {
      dispatch_block_t v20 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v21 = *(void *)(a1 + 32);
        *(_DWORD *)buf = 138412546;
        *(void *)&uint8_t buf[4] = v21;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v8;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "<%@> read nonfatal failure errno %d", buf, 0x12u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        _IDSLogV();
      }
      return _IDSLinkPacketBufferRelease();
    }
    IDSTransportThreadSuspendSocket();
    BOOL v22 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v23 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138412546;
      *(void *)&uint8_t buf[4] = v23;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v8;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "<%@> read failed errno %d", buf, 0x12u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
LABEL_42:
    }
      _IDSLogV();
  }
  else
  {
    int v10 = *__error();
    IDSTransportThreadSuspendSocket();
    int v11 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138412546;
      *(void *)&uint8_t buf[4] = v12;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v10;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "<%@> read returned 0 bytes errno %d", buf, 0x12u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      goto LABEL_42;
    }
  }
  return _IDSLinkPacketBufferRelease();
}

uint64_t sub_10008DD88(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, void *a5)
{
  id v8 = a5;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (!v8)
  {
    long long v14 = *(void **)(a1 + 32);
    if (!v14 || ([v14 closed] & 1) != 0 || !WeakRetained)
    {
      uint64_t v24 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "_connectSocketDescriptor: ClientChannel or Session has been invalidated; not writing",
          buf,
          2u);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLogTransport())
        {
          _IDSLogTransport();
          if (_IDSShouldLog()) {
            _IDSLogV();
          }
        }
      }
      goto LABEL_97;
    }
    if (*((unsigned char *)WeakRetained + 602) || *((unsigned char *)WeakRetained + 601))
    {
      __int16 v15 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v16 = *(void *)(a2 + 16);
        int v17 = *(_DWORD *)(a1 + 64);
        *(_DWORD *)buf = 134218754;
        unint64_t v63 = v16;
        __int16 v64 = 2048;
        *(void *)unint64_t v65 = a4;
        *(_WORD *)&v65[8] = 2112;
        uint64_t v66 = 0;
        __int16 v67 = 1024;
        int v68 = v17;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Client channel read packetBuffer %lu metadata_size %lu error %@ for socket %d", buf, 0x26u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        uint64_t v57 = 0;
        uint64_t v58 = *(unsigned int *)(a1 + 64);
        uint64_t v54 = *(void *)(a2 + 16);
        uint64_t v56 = a4;
        _IDSLogV();
      }
    }
    if (!*(void *)(a2 + 16))
    {
      uint64_t v33 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        int v34 = *(_DWORD *)(a1 + 64);
        *(_DWORD *)buf = 134218240;
        unint64_t v63 = a4;
        __int16 v64 = 1024;
        *(_DWORD *)unint64_t v65 = v34;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "Bug in client: Client channel read only metadata for socket session - dropping metadata_size %lu for socket %d", buf, 0x12u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        _IDSLogV();
      }
      goto LABEL_97;
    }
    if (*((unsigned char *)WeakRetained + 48))
    {
      id v18 = (void *)*((void *)WeakRetained + 13);
      if (v18)
      {
        id v19 = [v18 connection];
        if (v19)
        {
          dispatch_block_t v20 = [*((id *)WeakRetained + 13) deviceConnectionInfo];
          BOOL v21 = v20 == 0;

          if (!v21)
          {
            BOOL v22 = [*(id *)(a1 + 40) utunController];
            id v23 = objc_msgSend(v22, "onTransportThread_SendWithConnectionContext:packetBuffer:", *((void *)WeakRetained + 13), a2);

            if (!v23) {
              goto LABEL_49;
            }
            goto LABEL_59;
          }
        }
      }
LABEL_97:
      _IDSLinkPacketBufferRelease();
      goto LABEL_49;
    }
    id v35 = [WeakRetained sharedState];
    BOOL v36 = [v35 state] == 8;

    if (v36)
    {
      if (!*(void *)(a2 + 16)) {
        goto LABEL_97;
      }
    }
    else
    {
      ssize_t v40 = write(*(_DWORD *)(a1 + 64), *(const void **)a2, *(void *)(a2 + 16));
      id v41 = (void *)v40;
      if (v40 == *(void *)(a2 + 16)) {
        goto LABEL_97;
      }
      if (v40 >= 1)
      {
        if (*((unsigned char *)WeakRetained + 602) || *((unsigned char *)WeakRetained + 601))
        {
          id v42 = OSLogHandleForIDSCategory();
          if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v43 = *(void *)(a2 + 16);
            *(_DWORD *)buf = 138412802;
            unint64_t v63 = (unint64_t)WeakRetained;
            __int16 v64 = 1024;
            *(_DWORD *)unint64_t v65 = v41;
            *(_WORD *)&v65[4] = 1024;
            *(_DWORD *)&v65[6] = v43;
            _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "<%@> write failed to send all bytes %d < %d", buf, 0x18u);
          }

          if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
            _IDSLogV();
          }
        }
        goto LABEL_65;
      }
      if (v40)
      {
        unsigned int v44 = *__error();
        if (v44 <= 0x37 && ((1 << v44) & 0x80000800000010) != 0)
        {
          BOOL v45 = 1;
        }
        else
        {
          id v41 = objc_msgSend(WeakRetained, "sharedState", v54, v56, v57, v58);
          id v46 = [v41 transportType];
          BOOL v45 = v44 == 61 && v46 == 0;
        }
        if (v44 > 0x37 || ((1 << v44) & 0x80000800000010) == 0) {

        }
        if (!v45)
        {
          uint64_t v49 = OSLogHandleForIDSCategory();
          if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412546;
            unint64_t v63 = (unint64_t)WeakRetained;
            __int16 v64 = 1024;
            *(_DWORD *)unint64_t v65 = v44;
            _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "<%@> write failed errno %d", buf, 0x12u);
          }

          if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
            _IDSLogV();
          }
          uint64_t v50 = (id *)(a1 + 56);
          id v51 = objc_loadWeakRetained(v50);

          if (v51)
          {
            id v52 = objc_loadWeakRetained(v50);
            [v52 invalidate];
          }
          __int16 v53 = im_primary_queue();
          v59[0] = _NSConcreteStackBlock;
          v59[1] = 3221225472;
          v59[2] = sub_10008EA70;
          v59[3] = &unk_10097E4D0;
          v59[4] = WeakRetained;
          sub_100087C00(v53, QOS_CLASS_USER_INITIATED, v59);

          goto LABEL_65;
        }
        if (*((unsigned char *)WeakRetained + 602) || *((unsigned char *)WeakRetained + 601))
        {
          __int16 v48 = OSLogHandleForIDSCategory();
          if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412546;
            unint64_t v63 = (unint64_t)WeakRetained;
            __int16 v64 = 1024;
            *(_DWORD *)unint64_t v65 = v44;
            _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "<%@> write nonfatal failure errno %d", buf, 0x12u);
          }

          if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
            _IDSLogV();
          }
        }
        goto LABEL_97;
      }
    }
LABEL_59:
    int v37 = *__error();
    unsigned int v38 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      unint64_t v63 = (unint64_t)WeakRetained;
      __int16 v64 = 1024;
      *(_DWORD *)unint64_t v65 = v37;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "<%@> write failed connection terminated %d", buf, 0x12u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    id v39 = im_primary_queue();
    v60[0] = _NSConcreteStackBlock;
    v60[1] = 3221225472;
    v60[2] = sub_10008EA64;
    v60[3] = &unk_10097E4D0;
    v60[4] = WeakRetained;
    sub_100087C00(v39, QOS_CLASS_USER_INITIATED, v60);

LABEL_65:
    _IDSLinkPacketBufferRelease();
    goto LABEL_49;
  }
  int v10 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    unint64_t v63 = (unint64_t)v8;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "_connectSocketDescriptor: ClientChannel read error %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      _IDSLogTransport();
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
  }
  if (WeakRetained
    && ([WeakRetained sharedState],
        int v11 = objc_claimAutoreleasedReturnValue(),
        BOOL v12 = [v11 clientType] == (id)6,
        v11,
        !v12))
  {
    CFStringRef v25 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v26 = [WeakRetained sharedState];
      unsigned int v27 = [v26 clientType];
      *(_DWORD *)buf = 67109120;
      LODWORD(v63) = v27;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "_connectSocketDescriptor: clientType: %u, end session", buf, 8u);
    }
    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        CFStringRef v28 = [WeakRetained sharedState];
        id v55 = [v28 clientType];
        _IDSLogTransport();

        if (_IDSShouldLog())
        {
          unint64_t v29 = objc_msgSend(WeakRetained, "sharedState", v55);
          [v29 clientType];
          _IDSLogV();
        }
      }
    }
    if (!*((unsigned char *)WeakRetained + 636))
    {
      unsigned int v30 = im_primary_queue();
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10008EA58;
      block[3] = &unk_10097E4D0;
      void block[4] = WeakRetained;
      dispatch_block_t v31 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS|DISPATCH_BLOCK_ASSIGN_CURRENT, QOS_CLASS_USER_INITIATED, 0, block);
      dispatch_async(v30, v31);
    }
  }
  else
  {
    uint64_t v13 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      unint64_t v63 = (unint64_t)WeakRetained;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "_connectSocketDescriptor: strongSelf: %p, not ending session because we have not been told to", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
  }
  _IDSLinkPacketBufferRelease();
LABEL_49:

  return 1;
}

id sub_10008EA58(uint64_t a1)
{
  return [*(id *)(a1 + 32) endSessionWithReason:11];
}

id sub_10008EA64(uint64_t a1)
{
  return [*(id *)(a1 + 32) endSessionWithReason:15];
}

id sub_10008EA70(uint64_t a1)
{
  return [*(id *)(a1 + 32) endSessionWithReason:15];
}

void sub_10008EA7C(uint64_t a1)
{
  id v1 = *(id *)(a1 + 40);
  IDSTransportThreadAddBlock();
}

uint64_t sub_10008EB00(uint64_t a1)
{
  IDSByteBufferInitForWrite();
  uint64_t v2 = [*(id *)(a1 + 32) sharedState];
  [v2 useBTDatagramPipe];

  IDSByteBufferWriteField();
  objc_msgSend(*(id *)(a1 + 32), "writeToClientChannel:packetBuffer:metaData:metadataSize:", *(void *)(a1 + 40), 0);
  return IDSByteBufferRelease();
}

void sub_1000967B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id *location)
{
  objc_destroyWeak(location);
  objc_destroyWeak((id *)(v22 - 256));
  _Unwind_Resume(a1);
}

void sub_10009692C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    uint64_t v4 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      id v8 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "sendSKEData failed with error: %@. Will retry.", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
    id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 40));
    int v6 = WeakRetained;
    if (WeakRetained) {
      objc_storeStrong(WeakRetained + 72, *(id *)(a1 + 32));
    }
  }
}

void sub_100096A90(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) accountController];
  id v3 = [*(id *)(a1 + 32) sharedState];
  uint64_t v4 = [v3 accountID];
  int v5 = [v2 accountWithUniqueID:v4];
  int v6 = [v5 primaryRegistration];
  uint64_t v7 = [v6 pushToken];
  id v8 = [*(id *)(a1 + 32) sharedState];
  BOOL v9 = [v8 serviceName];
  id v17 = +[IDSPushToken pushTokenWithData:v7 withServiceLoggingHint:v9];

  int v10 = +[IDSGroupEncryptionController sharedInstance];
  id v11 = [v10 createRealTimeEncryptionFullIdentityForDevice:v17 completionBlock:0];

  BOOL v12 = +[IDSGroupEncryptionController sharedInstance];
  uint64_t v13 = [*(id *)(a1 + 32) sharedState];
  long long v14 = [v13 groupID];
  __int16 v15 = [*(id *)(a1 + 32) sharedState];
  unint64_t v16 = [v15 uniqueID];
  [v12 reliablyRequestKeyMaterialForGroup:v14 sessionID:v16];
}

void sub_100096C38(uint64_t a1)
{
  uint64_t v2 = +[IDSGroupEncryptionController sharedInstance];
  id v3 = [*(id *)(a1 + 32) sharedState];
  uint64_t v4 = [v3 accountID];
  int v5 = [*(id *)(a1 + 32) sharedState];
  int v6 = [v5 fromURI];
  uint64_t v7 = [*(id *)(a1 + 32) sharedState];
  id v8 = [v7 groupID];
  [v2 setAccount:v4 fromURI:v6 forGroup:v8];

  BOOL v9 = +[IDSGroupEncryptionController sharedInstance];
  int v10 = [*(id *)(a1 + 32) sharedState];
  id v11 = [v10 groupID];
  [v9 resetKeysForGroup:v11 shouldRemoveCurrentParticipants:1];

  id v16 = +[IDSGroupEncryptionController sharedInstance];
  BOOL v12 = [*(id *)(a1 + 32) sharedState];
  uint64_t v13 = [v12 groupID];
  long long v14 = [*(id *)(a1 + 32) sharedState];
  __int16 v15 = [v14 uniqueID];
  [v16 requestKeyMaterialForGroup:v13 sessionID:v15];
}

void sub_100096DDC(uint64_t a1)
{
  id v4 = [*(id *)(a1 + 32) utunController];
  uint64_t v2 = [*(id *)(a1 + 32) sharedState];
  id v3 = [v2 uniqueID];
  objc_msgSend(v4, "onTransportThread_sendStatsRequest:options:", v3, *(void *)(a1 + 40));
}

void sub_100096E64(uint64_t a1)
{
  id v5 = [*(id *)(a1 + 32) utunController];
  uint64_t v2 = *(char *)(a1 + 40);
  id v3 = [*(id *)(a1 + 32) sharedState];
  id v4 = [v3 uniqueID];
  objc_msgSend(v5, "onTransportThread_requestChildConnectionIDForLinkID:sessionID:", v2, v4);
}

void sub_100097138(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

id sub_10009717C(uint64_t a1)
{
  return [*(id *)(a1 + 32) endSessionWithReason:20];
}

uint64_t sub_100097188(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, void *a5)
{
  id v8 = a5;
  if (qword_100A4A5D0 != -1) {
    dispatch_once(&qword_100A4A5D0, &stru_100981748);
  }
  uint64_t v9 = mach_continuous_time();
  if (v8)
  {
    int v10 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      id v11 = [*(id *)(a1 + 32) sharedState];
      *(_DWORD *)buf = 138412546;
      *(void *)uint64_t v73 = v8;
      *(_WORD *)&v73[8] = 1024;
      LODWORD(v74) = [v11 state];
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "_connectQRDirectlyToClientChannel: ClientChannel read error %@, self.sharedState.state %d", buf, 0x12u);
    }
    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        BOOL v12 = [*(id *)(a1 + 32) sharedState];
        id v59 = [v12 state];
        _IDSLogTransport();

        if (_IDSShouldLog())
        {
          uint64_t v13 = objc_msgSend(*(id *)(a1 + 32), "sharedState", v8, v59);
          [v13 state];
          _IDSLogV();
        }
      }
    }
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
    __int16 v15 = WeakRetained;
    if (WeakRetained
      && ([WeakRetained sharedState],
          id v16 = objc_claimAutoreleasedReturnValue(),
          BOOL v17 = [v16 clientType] == (id)6,
          v16,
          !v17))
    {
      id v23 = [v15 sharedState];
      unsigned int v24 = [v23 state];

      CFStringRef v25 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)uint64_t v73 = v24;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "_connectQRDirectlyToClientChannel: state: %u", buf, 8u);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLogTransport())
        {
          _IDSLogTransport();
          if (_IDSShouldLog()) {
            _IDSLogV();
          }
        }
      }
      if (!v15[636] && v24 != 7)
      {
        uint64_t v26 = im_primary_queue();
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_100097E64;
        block[3] = &unk_10097E4D0;
        void block[4] = *(void *)(a1 + 32);
        dispatch_block_t v27 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS|DISPATCH_BLOCK_ASSIGN_CURRENT, QOS_CLASS_USER_INITIATED, 0, block);
        dispatch_async(v26, v27);
      }
    }
    else
    {
      id v18 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        *(void *)uint64_t v73 = v15;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "_connectQRDirectlyToClientChannel: strongSelf: %p, not ending session because we have not been told to.", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLogTransport())
        {
          _IDSLogTransport();
          if (_IDSShouldLog()) {
            _IDSLogV();
          }
        }
      }
    }
    _IDSLinkPacketBufferRelease();
    goto LABEL_99;
  }
  unint64_t v61 = v9;
  __int16 v15 = 0;
  double v19 = *(double *)&qword_100A4A5D8;
  if (a3 && a4)
  {
    __int16 v15 = [*(id *)(a1 + 32) _extractFieldBytesFromMetadata:a3 ofSize:a4 packetBuffer:a2];
  }
  uint64_t v69 = [v15 objectForKeyedSubscript:@"ccmdtcdc"];
  unsigned int v20 = [v69 unsignedCharValue];
  BOOL v21 = [v15 objectForKeyedSubscript:@"ccmdttdc"];
  int v68 = v21;
  if (v21) {
    uint64_t v22 = (uint64_t)[v21 unsignedCharValue];
  }
  else {
    uint64_t v22 = 1;
  }
  CFStringRef v28 = [v15 objectForKeyedSubscript:@"ccmdtpli"];
  __int16 v67 = v28;
  if (v28) {
    *(unsigned char *)(a2 + 1216) = [v28 charValue];
  }
  unint64_t v29 = [v15 objectForKeyedSubscript:@"ccmdttc"];
  uint64_t v66 = v29;
  if (v29) {
    *(_WORD *)(a2 + 440) = (unsigned __int16)[v29 unsignedShortValue];
  }
  unsigned int v30 = [v15 objectForKeyedSubscript:@"ccmdtdscp"];
  unint64_t v65 = v30;
  if (v30) {
    *(unsigned char *)(a2 + 442) = [v30 unsignedCharValue];
  }
  dispatch_block_t v31 = [v15 objectForKeyedSubscript:@"ccmdtpid"];
  __int16 v64 = v31;
  if (v31)
  {
    *(_DWORD *)(a2 + 536) |= 1u;
    *(void *)(a2 + 488) = [v31 unsignedLongLongValue];
  }
  BOOL v32 = [v15 objectForKeyedSubscript:@"ccmdtpgid"];
  unint64_t v63 = v32;
  if (v32)
  {
    *(_DWORD *)(a2 + 536) |= 0x10u;
    *(_WORD *)(a2 + 498) = (unsigned __int16)[v32 unsignedShortValue];
  }
  uint64_t v33 = [v15 objectForKeyedSubscript:@"ccmdtsid"];
  int v34 = v33;
  if (v33)
  {
    *(_DWORD *)(a2 + 536) |= 0x40u;
    *(_WORD *)(a2 + 504) = (unsigned __int16)[v33 unsignedShortValue];
  }
  id v35 = [v15 objectForKeyedSubscript:@"ccmdtcp"];
  __int16 v62 = v35;
  if (v35)
  {
    *(_DWORD *)(a2 + 536) |= 8u;
    *(unsigned char *)(a2 + 496) = [v35 unsignedCharValue];
  }
  BOOL v36 = [v15 objectForKeyedSubscript:@"ccmdtipc"];
  unsigned int v37 = [v36 BOOLValue];

  if (v37)
  {
    *(_DWORD *)(a2 + 536) |= 4u;
    *(unsigned char *)(a2 + 501) = 1;
  }
  unsigned int v38 = [v15 objectForKeyedSubscript:@"ccmdtnhbhe"];
  unsigned int v39 = [v38 BOOLValue];

  if (v39)
  {
    *(_DWORD *)(a2 + 536) |= 0x400u;
    *(unsigned char *)(a2 + 517) = 1;
  }
  if (qword_100A4A5D0 != -1) {
    dispatch_once(&qword_100A4A5D0, &stru_100981748);
  }
  uint64_t v60 = mach_continuous_time();
  uint64_t v40 = *(void *)(a2 + 16);
  BOOL v41 = v40 <= 0 && v34 == 0;
  double v42 = *(double *)&qword_100A4A5D8;
  if (v41 || !v22)
  {
    if (v40 < 1 || v22 < 9)
    {
      uint64_t v50 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109632;
        *(_DWORD *)uint64_t v73 = v40;
        *(_WORD *)&v73[4] = 1024;
        *(_DWORD *)&v73[6] = v20;
        LOWORD(v74) = 1024;
        *(_DWORD *)((char *)&v74 + 2) = v22;
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "not sending to UTunController - packetBufferLength %d currentDatagramCount %u totalDatagramCount %u", buf, 0x14u);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLogTransport())
        {
          _IDSLogTransport();
          if (_IDSShouldLog()) {
            _IDSLogV();
          }
        }
      }
    }
    else
    {
      __int16 v48 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)uint64_t v73 = 8;
        *(_WORD *)&v73[4] = 1024;
        *(_DWORD *)&v73[6] = v22;
        _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "Can't send more than %u over the compound data channel! totalDatagramCount %u", buf, 0xEu);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLogTransport())
        {
          _IDSLogTransport();
          if (_IDSShouldLog()) {
            _IDSLogV();
          }
        }
      }
    }
    _IDSLinkPacketBufferRelease();
LABEL_85:
    unint64_t v47 = 0;
    goto LABEL_86;
  }
  *(void *)(*(void *)(a1 + 32) + 8 * v20 + 448) = a2;
  uint64_t v43 = *(unsigned char **)(a1 + 32);
  if (v22 - 1 != v20)
  {
    if (!v43[602] && !v43[601])
    {
      unint64_t v47 = 0;
      goto LABEL_86;
    }
    uint64_t v49 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)uint64_t v73 = v20;
      *(_WORD *)&v73[4] = 1024;
      *(_DWORD *)&v73[6] = v22;
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "not sending to UTunController - currentDatagramCount %u totalDatagramCount %u", buf, 0xEu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
    goto LABEL_85;
  }
  unsigned int v44 = [v43 utunController];
  BOOL v45 = [*(id *)(a1 + 32) sharedState];
  id v46 = [v45 uniqueID];
  unint64_t v47 = (unint64_t)objc_msgSend(v44, "onTransportThread_SendToGlobalLinkWithSessionID:packetBufferArray:arraySize:", v46, *(void *)(a1 + 32) + 448, v22);

LABEL_86:
  if (qword_100A4A5D0 != -1) {
    dispatch_once(&qword_100A4A5D0, &stru_100981748);
  }
  uint64_t v51 = mach_continuous_time();
  uint64_t v52 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v52 + 602) || *(unsigned char *)(v52 + 601))
  {
    double v53 = v19 * (double)v61;
    double v54 = v42 * (double)v60;
    double v55 = *(double *)&qword_100A4A5D8 * (double)v51;
    uint64_t v56 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
    {
      if (v47 > 0xF) {
        uint64_t v57 = "UnexpectedSendResult";
      }
      else {
        uint64_t v57 = (const char *)_IDSLinkSendResultStrings[v47];
      }
      *(_DWORD *)buf = 134219266;
      *(void *)uint64_t v73 = v40;
      *(_WORD *)&v73[8] = 2048;
      uint64_t v74 = a4;
      __int16 v75 = 2080;
      uint64_t v76 = v57;
      __int16 v77 = 2048;
      double v78 = v54 - v53;
      __int16 v79 = 2048;
      double v80 = v55 - v54;
      __int16 v81 = 2048;
      double v82 = v55;
      _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "Client channel read datagram_size %lu metadata_size %lu sendResult %s processTime %0.6lf sendTime %0.6lf [%013.6lf]", buf, 0x3Eu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
  }

LABEL_99:
  return 1;
}

id sub_100097E64(uint64_t a1)
{
  return [*(id *)(a1 + 32) endSessionWithReason:11];
}

void sub_100098A8C(uint64_t a1)
{
  double v19 = *(void **)(a1 + 32);
  id v16 = [*(id *)(a1 + 40) sharedState];
  __int16 v15 = [v16 destinations];
  id v18 = [v15 allObjects];
  long long v14 = [*(id *)(a1 + 40) sharedState];
  BOOL v17 = [v14 uniqueID];
  uint64_t v2 = [*(id *)(a1 + 40) accountController];
  uint64_t v13 = [*(id *)(a1 + 40) sharedState];
  BOOL v12 = [v13 accountID];
  id v11 = objc_msgSend(v2, "accountWithUniqueID:");
  id v3 = [v11 _registrationCert];
  id v4 = [*(id *)(a1 + 40) sharedState];
  id v5 = [v4 fromURI];
  int v6 = [v5 unprefixedURI];
  uint64_t v7 = [v6 _bestGuessURI];
  id v8 = [*(id *)(a1 + 48) identifier];
  uint64_t v9 = *(void *)(a1 + 56);
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472;
  v20[2] = sub_100098CCC;
  v20[3] = &unk_100980F38;
  objc_copyWeak(v22, (id *)(a1 + 72));
  v22[1] = *(id *)(a1 + 80);
  id v21 = *(id *)(a1 + 64);
  id v10 = [v19 setupNewAllocation:v18 sessionID:v17 fromIdentity:v3 fromURI:v7 fromService:v8 options:v9 connectReadyHandler:v20];

  objc_destroyWeak(v22);
}

void sub_100098CB8(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_100098CCC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    uint64_t v3 = *(void *)(a1 + 48);
    if (v3 == 2)
    {
      id v4 = im_primary_queue();
      v8[0] = _NSConcreteStackBlock;
      v8[1] = 3221225472;
      v8[2] = sub_100098E34;
      v8[3] = &unk_10097E440;
      void v8[4] = WeakRetained;
      id v5 = &v9;
      id v9 = *(id *)(a1 + 32);
      int v6 = v8;
      goto LABEL_6;
    }
    if (v3 == 1)
    {
      id v4 = im_primary_queue();
      v10[0] = _NSConcreteStackBlock;
      v10[1] = 3221225472;
      v10[2] = sub_100098E28;
      v10[3] = &unk_10097E440;
      void v10[4] = WeakRetained;
      id v5 = &v11;
      id v11 = *(id *)(a1 + 32);
      int v6 = v10;
LABEL_6:
      dispatch_block_t v7 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS|DISPATCH_BLOCK_ASSIGN_CURRENT, QOS_CLASS_USER_INITIATED, 0, v6);
      dispatch_async(v4, v7);
    }
  }
}

id sub_100098E28(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _sendingOfflineActiveParticipantInfoRequest:*(void *)(a1 + 40)];
}

id sub_100098E34(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _sendStreamSubscriptionRequest:*(void *)(a1 + 40)];
}

void sub_100098E40(uint64_t a1)
{
  id v4 = [*(id *)(a1 + 32) utunController];
  uint64_t v2 = [*(id *)(a1 + 32) sharedState];
  uint64_t v3 = [v2 uniqueID];
  objc_msgSend(v4, "onTransportThread_getSessionInfo:relayGroupID:relaySessionID:options:", v3, *(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56));
}

void sub_10009917C(uint64_t a1)
{
  id v8 = objc_alloc_init((Class)IMMessageContext);
  [v8 setShouldBoost:1];
  uint64_t v2 = +[IDSDaemon sharedInstance];
  uint64_t v3 = [*(id *)(a1 + 32) sharedState];
  id v4 = [v3 pushTopic];
  id v5 = [v2 broadcasterForTopic:v4 entitlement:kIDSSessionEntitlement command:0 messageContext:v8];

  int v6 = [*(id *)(a1 + 32) sharedState];
  dispatch_block_t v7 = [v6 uniqueID];
  [v5 session:v7 didReceiveURIsForParticipantIDs:*(void *)(a1 + 40) withRequestID:*(void *)(a1 + 48)];
}

void sub_100099490(uint64_t a1)
{
  id v6 = [*(id *)(a1 + 32) utunController];
  uint64_t v2 = [*(id *)(a1 + 32) sharedState];
  uint64_t v3 = [v2 uniqueID];
  id v4 = [*(id *)(a1 + 32) sharedState];
  id v5 = [v4 groupID];
  objc_msgSend(v6, "onTransportThread_registerPluginForGroup:relayGroupID:options:", v3, v5, *(void *)(a1 + 40));
}

void sub_10009975C(uint64_t a1)
{
  id v6 = [*(id *)(a1 + 32) utunController];
  uint64_t v2 = [*(id *)(a1 + 32) sharedState];
  uint64_t v3 = [v2 uniqueID];
  id v4 = [*(id *)(a1 + 32) sharedState];
  id v5 = [v4 groupID];
  objc_msgSend(v6, "onTransportThread_registerPluginForGroup:relayGroupID:options:", v3, v5, *(void *)(a1 + 40));
}

void sub_100099D3C(uint64_t a1)
{
  id v4 = [*(id *)(a1 + 32) utunController];
  uint64_t v2 = [*(id *)(a1 + 32) sharedState];
  uint64_t v3 = [v2 uniqueID];
  objc_msgSend(v4, "onTransportThread_getSessionInfo:relayGroupID:relaySessionID:options:", v3, *(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56));
}

void sub_10009A754(uint64_t a1)
{
  id v4 = [*(id *)(a1 + 32) utunController];
  uint64_t v2 = [*(id *)(a1 + 32) sharedState];
  uint64_t v3 = [v2 uniqueID];
  objc_msgSend(v4, "onTransportThread_getSessionInfo:relayGroupID:relaySessionID:options:", v3, *(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56));
}

void sub_10009BD28(id *a1)
{
  id WeakRetained = objc_loadWeakRetained(a1 + 6);
  IDSByteBufferInitForWrite();
  [a1[4] bytes];
  [a1[4] length];
  IDSByteBufferWriteField();
  objc_msgSend(a1[5], "writeToClientChannel:packetBuffer:metaData:metadataSize:", WeakRetained, 0);
  IDSByteBufferRelease();
}

void sub_10009DD2C(_Unwind_Exception *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,id location)
{
  if (a2 == 1)
  {
    objc_begin_catch(exc_buf);
    objc_end_catch();
    JUMPOUT(0x10009D410);
  }
  _Unwind_Resume(exc_buf);
}

void sub_10009DDE4(uint64_t a1, void *a2)
{
  id v111 = a2;
  uint64_t v113 = a1;
  uint64_t v3 = (id *)(a1 + 48);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    if (v111)
    {
      id v4 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        id v5 = [WeakRetained sharedState];
        id v6 = [v5 uniqueID];
        *(_DWORD *)buf = 138412546;
        uint64_t v119 = v6;
        __int16 v120 = 2112;
        *(void *)uint64_t v121 = v111;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Connect to QR server failed for %@ with error %@.", buf, 0x16u);
      }
      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLogTransport())
        {
          dispatch_block_t v7 = [WeakRetained sharedState];
          uint64_t v87 = [v7 uniqueID];
          id v90 = v111;
          _IDSLogTransport();

          if (_IDSShouldLog())
          {
            id v8 = objc_msgSend(WeakRetained, "sharedState", v87, v111);
            uint64_t v87 = [v8 uniqueID];
            id v90 = v111;
            _IDSLogV();
          }
        }
      }
      id v9 = objc_msgSend(WeakRetained, "globalLinkErrorToSessionEndReason:", objc_msgSend(v111, "code", v87, v90));
      id v10 = +[NSMutableDictionary dictionary];
      id v11 = +[NSNumber numberWithUnsignedInt:v9];
      if (v11)
      {
        CFDictionarySetValue(v10, kIDSQRAllocateKey_ErrorCode, v11);
      }
      else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        sub_10070DD4C();
      }

      v122[0] = 0xAAAAAAAAAAAAAAAALL;
      v122[1] = 0xAAAAAAAAAAAAAAAALL;
      id v43 = objc_alloc((Class)NSUUID);
      unsigned int v44 = (const void *)kIDSQRAllocateKey_RequestID;
      BOOL v45 = [*(id *)(v113 + 32) objectForKeyedSubscript:kIDSQRAllocateKey_RequestID];
      id v46 = [v43 initWithUUIDString:v45];
      [v46 getUUIDBytes:v122];

      id v47 = +[NSData dataWithBytes:v122 length:16];
      if (v47)
      {
        CFDictionarySetValue(v10, v44, v47);
      }
      else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        sub_10070DC40();
      }

      __int16 v48 = (const void *)kIDSQRAllocateKey_RelayAddress;
      uint64_t v49 = [*(id *)(v113 + 32) objectForKeyedSubscript:kIDSQRAllocateKey_RelayAddress];
      if (v49)
      {
        CFDictionarySetValue(v10, v48, v49);
      }
      else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        sub_10070DC40();
      }

      uint64_t v50 = (const void *)kIDSQRAllocateKey_RelayPort;
      uint64_t v51 = [*(id *)(v113 + 32) objectForKeyedSubscript:kIDSQRAllocateKey_RelayPort];
      if (v51)
      {
        CFDictionarySetValue(v10, v50, v51);
      }
      else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        sub_10070DC40();
      }

      uint64_t v52 = (const void *)kIDSQRAllocateKey_RelayAddressIPv6;
      double v53 = [*(id *)(v113 + 32) objectForKeyedSubscript:kIDSQRAllocateKey_RelayAddressIPv6];
      if (v53) {
        CFDictionarySetValue(v10, v52, v53);
      }

      double v54 = (const void *)kIDSQRAllocateKey_AppID;
      double v55 = [*(id *)(v113 + 32) objectForKeyedSubscript:kIDSQRAllocateKey_AppID];
      if (v55)
      {
        CFDictionarySetValue(v10, v54, v55);
      }
      else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        sub_10070DC40();
      }

      uint64_t v56 = +[IMDeviceSupport sharedInstance];
      uint64_t v57 = [v56 userAgentString];

      id v58 = v57;
      if (v58)
      {
        CFDictionarySetValue(v10, kIDSQRAllocateKey_UserAgent, v58);
      }
      else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        sub_10070DCC4();
      }

      id v59 = (const void *)kIDSQRAllocateKey_ReportingDataBlob;
      uint64_t v60 = [*(id *)(v113 + 32) objectForKeyedSubscript:kIDSQRAllocateKey_ReportingDataBlob];
      if (v60)
      {
        CFDictionarySetValue(v10, v59, v60);
      }
      else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        sub_10070DC40();
      }

      unint64_t v61 = +[IDSFoundationLog IDSDSession];
      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v62 = [*(id *)(v113 + 40) sharedState];
        unint64_t v63 = [v62 uniqueID];
        *(_DWORD *)buf = 138412802;
        uint64_t v119 = v63;
        __int16 v120 = 1024;
        *(_DWORD *)uint64_t v121 = v9;
        *(_WORD *)&v121[4] = 2112;
        *(void *)&v121[6] = v58;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "Sending server message QR metrics report for session %@ end reason %d, ua: %@", buf, 0x1Cu);
      }
      __int16 v64 = [[IDSServerMessage alloc] initWithPayload:v10 command:&off_1009D0DC8];
      unint64_t v65 = +[IDSDeliveryController sharedInstance];
      v117[0] = _NSConcreteStackBlock;
      v117[1] = 3221225472;
      v117[2] = sub_10009EFE4;
      v117[3] = &unk_100980FD8;
      v117[4] = *(void *)(v113 + 40);
      [v65 sendIDSMessage:v64 service:0 topic:kIDSQuickRelayPushTopic completionBlock:v117];

      uint64_t v66 = [*(id *)(v113 + 40) sharedState];
      if ([v66 isInitiator])
      {
        __int16 v67 = [*(id *)(v113 + 40) sharedState];
        if ([v67 clientType] == (id)1)
        {

LABEL_70:
          [*(id *)(v113 + 40) _sendSessionEndWithData:0];
          goto LABEL_71;
        }
        int v68 = [*(id *)(v113 + 40) sharedState];
        BOOL v69 = [v68 clientType] == (id)5;

        if (v69) {
          goto LABEL_70;
        }
      }
      else
      {
      }
LABEL_71:
      [WeakRetained endSessionWithReason:v9];

LABEL_85:
      goto LABEL_86;
    }
    BOOL v12 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = [WeakRetained sharedState];
      long long v14 = [v13 uniqueID];
      *(_DWORD *)buf = 138412290;
      uint64_t v119 = v14;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Connect to QR server succeeded for %@.", buf, 0xCu);
    }
    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        __int16 v15 = [WeakRetained sharedState];
        uint64_t v87 = [v15 uniqueID];
        _IDSLogTransport();

        if (_IDSShouldLog())
        {
          id v16 = objc_msgSend(WeakRetained, "sharedState", v87);
          uint64_t v87 = [v16 uniqueID];
          _IDSLogV();
        }
      }
    }
    if (IMGetDomainBoolForKey() && !*(unsigned char *)(v113 + 56) && !WeakRetained[644])
    {
      BOOL v17 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        id v18 = [WeakRetained sharedState];
        double v19 = [v18 uniqueID];
        *(_DWORD *)buf = 138412290;
        uint64_t v119 = v19;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Will reinitiate after 15s for %@.", buf, 0xCu);
      }
      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLogTransport())
        {
          unsigned int v20 = [WeakRetained sharedState];
          uint64_t v87 = [v20 uniqueID];
          _IDSLogTransport();

          if (_IDSShouldLog())
          {
            id v21 = objc_msgSend(WeakRetained, "sharedState", v87);
            uint64_t v87 = [v21 uniqueID];
            _IDSLogV();
          }
        }
      }
      WeakRetained[644] = 1;
      dispatch_time_t v22 = dispatch_time(0, 15000000000);
      id v23 = im_primary_queue();
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10009F15C;
      block[3] = &unk_100981000;
      objc_copyWeak(&v116, v3);
      dispatch_after(v22, v23, block);

      objc_destroyWeak(&v116);
    }
    if (*(unsigned char *)(v113 + 57))
    {
      id v94 = objc_alloc((Class)IDSGroupSessionParticipantUpdate);
      id v24 = objc_alloc((Class)NSUUID);
      uint64_t v110 = [*(id *)(v113 + 40) sharedState];
      uint64_t v109 = [v110 groupID];
      id v96 = [v24 initWithUUIDString:v109];
      uint64_t v108 = [*(id *)(*(void *)(v113 + 40) + 184) isInitiator];
      unsigned int v93 = [v108 BOOLValue];
      uint64_t v107 = [*(id *)(*(void *)(v113 + 40) + 184) participantID];
      id v92 = [v107 unsignedLongLongValue];
      uint64_t v105 = [*(id *)(v113 + 40) accountController];
      uint64_t v106 = [*(id *)(v113 + 40) sharedState];
      uint64_t v104 = [v106 accountID];
      uint64_t v103 = [v105 accountWithUniqueID:v104];
      uint64_t v102 = [v103 primaryRegistration];
      uint64_t v98 = [v102 pushToken];
      uint64_t v101 = [*(id *)(v113 + 40) sharedState];
      uint64_t v100 = [v101 fromURI];
      uint64_t v99 = [v100 prefixedURI];
      uint64_t v95 = (void *)_IDSCopyIDForTokenWithURI();
      uint64_t v97 = [*(id *)(*(void *)(v113 + 40) + 184) joinType];
      BOOL v25 = [v97 integerValue] == (id)1;
      uint64_t v26 = +[NSDate date];
      dispatch_block_t v27 = [*(id *)(*(void *)(v113 + 40) + 184) participantData];
      CFStringRef v28 = [*(id *)(v113 + 40) sharedState];
      unint64_t v29 = [v28 destinations];
      unsigned int v30 = [v29 allObjects];
      dispatch_block_t v31 = [*(id *)(v113 + 32) objectForKeyedSubscript:kIDSQRAllocateKey_URIToParticipantID];
      id v32 = objc_alloc((Class)NSUUID);
      uint64_t v33 = [*(id *)(*(void *)(v113 + 40) + 184) relaySessionID];
      id v34 = [v32 initWithUUIDString:v33];
      LOBYTE(v88) = 0;
      id v10 = (__CFDictionary *)[v94 initWithGroupUUID:v96 isInitiator:v93 participantIdentifier:v92 participantDestinationID:v95 participantUpdateType:1 participantUpdateSubtype:v25 fromServer:v88 serverDate:v26 participantData:v27 clientContextData:0 members:v30 participantIDs:v31 relaySessionID:v34];

      id v35 = [(__CFDictionary *)v10 participantIDs];
      [*(id *)(*(void *)(v113 + 40) + 184) setUrisToParticipantIDs:v35];

      if (*(_DWORD *)(*(void *)(v113 + 40) + 176))
      {
        BOOL v36 = OSLogHandleForTransportCategory();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v37 = [*(id *)(v113 + 40) sharedState];
          unsigned int v38 = [v37 groupID];
          int v39 = *(_DWORD *)(*(void *)(v113 + 40) + 176);
          *(_DWORD *)buf = 138412546;
          uint64_t v119 = v38;
          __int16 v120 = 1024;
          *(_DWORD *)uint64_t v121 = v39;
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "Not in join state, group = %@, state = %d", buf, 0x12u);
        }
        if (!os_log_shim_legacy_logging_enabled()) {
          goto LABEL_84;
        }
        if (!_IDSShouldLogTransport()) {
          goto LABEL_84;
        }
        uint64_t v40 = [*(id *)(v113 + 40) sharedState];
        uint64_t v89 = [v40 groupID];
        uint64_t v91 = *(unsigned int *)(*(void *)(v113 + 40) + 176);
        _IDSLogTransport();

        if (!_IDSShouldLog()) {
          goto LABEL_84;
        }
        objc_msgSend(*(id *)(v113 + 40), "sharedState", v89, v91);
        id v41 = (id)objc_claimAutoreleasedReturnValue();
        double v42 = [v41 groupID];
        uint64_t v89 = v42;
        uint64_t v91 = *(unsigned int *)(*(void *)(v113 + 40) + 176);
        _IDSLogV();
      }
      else
      {
        uint64_t v73 = [*(id *)(v113 + 40) sharedState];
        uint64_t v74 = [v73 groupID];

        if (v74)
        {
          __int16 v75 = im_primary_queue();
          v114[0] = _NSConcreteStackBlock;
          v114[1] = 3221225472;
          v114[2] = sub_10009F388;
          v114[3] = &unk_10097E4D0;
          v114[4] = *(void *)(v113 + 40);
          dispatch_block_t v76 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS|DISPATCH_BLOCK_ASSIGN_CURRENT, QOS_CLASS_USER_INTERACTIVE, 0, v114);
          dispatch_async(v75, v76);
        }
        else
        {
          __int16 v77 = OSLogHandleForTransportCategory();
          if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "Cannot fan out the join notification to the group, no groupID!", buf, 2u);
          }

          if (os_log_shim_legacy_logging_enabled())
          {
            if (_IDSShouldLogTransport())
            {
              _IDSLogTransport();
              if (_IDSShouldLog()) {
                _IDSLogV();
              }
            }
          }
        }
        id v41 = objc_alloc_init((Class)IMMessageContext);
        [v41 setShouldBoost:1];
        double v78 = +[IDSDaemon sharedInstance];
        __int16 v79 = [*(id *)(v113 + 40) sharedState];
        double v80 = [v79 pushTopic];
        double v42 = [v78 broadcasterForTopic:v80 entitlement:kIDSSessionEntitlement command:0 messageContext:v41];

        __int16 v81 = [*(id *)(v113 + 40) sharedState];
        double v82 = [v81 uniqueID];
        uint64_t v83 = [(__CFDictionary *)v10 dictionaryRepresentation];
        [v42 sessionDidJoinGroup:v82 participantUpdateDictionary:v83 error:0];

        *(_DWORD *)(*(void *)(v113 + 40) + 176) = 1;
      }

LABEL_84:
      uint64_t v84 = +[IDSGroupEncryptionController sharedInstance];
      uint64_t v85 = [*(id *)(v113 + 40) sharedState];
      uint64_t v86 = [v85 groupID];
      [v84 resetKeyMaterialCacheTimerIfNeeded:v86];

      goto LABEL_85;
    }
    __int16 v70 = [WeakRetained sharedState];
    unsigned __int8 v71 = [v70 isInitiator];

    if ((v71 & 1) == 0)
    {
      id v10 = [WeakRetained sharedState];
      uint64_t v72 = [(__CFDictionary *)v10 uniqueID];
      [WeakRetained openSocketToDevice:v72];

      goto LABEL_85;
    }
  }
LABEL_86:
}

void sub_10009EFE4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 idsResponseCode];
  id v5 = +[IDSFoundationLog IDSDSession];
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v6)
    {
      dispatch_block_t v7 = [*(id *)(a1 + 32) sharedState];
      id v8 = [v7 uniqueID];
      id v9 = [v3 deliveryError];
      int v11 = 138412546;
      BOOL v12 = v8;
      __int16 v13 = 2112;
      long long v14 = v9;
      id v10 = "Failed sending server message QR metrics report for session %@, delivery error %@";
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v11, 0x16u);
    }
  }
  else if (v6)
  {
    dispatch_block_t v7 = [*(id *)(a1 + 32) sharedState];
    id v8 = [v7 uniqueID];
    id v9 = [v3 deliveryError];
    int v11 = 138412546;
    BOOL v12 = v8;
    __int16 v13 = 2112;
    long long v14 = v9;
    id v10 = "Finished sending server message QR metrics report for session %@ delivery error %@";
    goto LABEL_6;
  }
}

void sub_10009F15C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    uint64_t v2 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      id v3 = [WeakRetained sharedState];
      id v4 = [v3 uniqueID];
      unsigned int v5 = [WeakRetained sharedSessionHasJoined];
      CFStringRef v6 = @"NO";
      if (v5) {
        CFStringRef v6 = @"YES";
      }
      *(_DWORD *)buf = 138412546;
      id v16 = v4;
      __int16 v17 = 2112;
      CFStringRef v18 = v6;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "reinitiate 15s have passed for %@; has joined: %@.",
        buf,
        0x16u);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
    {
      dispatch_block_t v7 = [WeakRetained sharedState];
      id v8 = [v7 uniqueID];
      id v9 = [WeakRetained sharedSessionHasJoined] ? @"YES" : @"NO";
      __int16 v13 = v8;
      long long v14 = v9;
      _IDSLogTransport();

      if (_IDSShouldLog())
      {
        id v10 = objc_msgSend(WeakRetained, "sharedState", v8, v14);
        int v11 = [v10 uniqueID];
        if ([WeakRetained sharedSessionHasJoined]) {
          CFStringRef v12 = @"YES";
        }
        else {
          CFStringRef v12 = @"NO";
        }
        __int16 v13 = v11;
        long long v14 = (__CFString *)v12;
        _IDSLogV();
      }
    }
    if (objc_msgSend(WeakRetained, "sharedSessionHasJoined", v13, v14)) {
      [WeakRetained reinitiate];
    }
  }
}

void sub_10009F388(uint64_t a1)
{
  [*(id *)(a1 + 32) _noteJoinNotificationWillSend];
  uint64_t v2 = [*(id *)(a1 + 32) groupStatusNotificationController];
  BOOL v36 = [*(id *)(a1 + 32) sharedState];
  id v3 = [v36 groupID];
  id v35 = [*(id *)(a1 + 32) sharedState];
  id v34 = [v35 destinations];
  id v4 = [v34 allObjects];
  unsigned int v5 = *(void **)(a1 + 32);
  uint64_t v31 = v5[23];
  id v32 = [v5 accountController];
  uint64_t v33 = [*(id *)(a1 + 32) sharedState];
  CFStringRef v6 = [v33 accountID];
  dispatch_block_t v7 = [v32 accountWithUniqueID:v6];
  id v8 = [*(id *)(a1 + 32) sharedState];
  id v9 = [v8 fromURI];
  id v10 = [*(id *)(a1 + 32) sharedState];
  int v11 = [v10 uniqueID];
  unsigned __int8 v12 = [*(id *)(a1 + 32) shouldReportUPlusOneKey];
  v38[0] = _NSConcreteStackBlock;
  v38[1] = 3221225472;
  v38[2] = sub_10009F798;
  v38[3] = &unk_100981028;
  void v38[4] = *(void *)(a1 + 32);
  LOBYTE(v30) = v12;
  [v2 notifyJoinToGroup:v3 members:v4 params:v31 fromAccount:v7 fromURI:v9 sessionID:v11 isUPlusOne:v30 completionBlock:v38];

  if (*(unsigned char *)(*(void *)(a1 + 32) + 636))
  {
    __int16 v13 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "lightweight participant: create keys", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
    {
      _IDSLogTransport();
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
    long long v14 = [*(id *)(a1 + 32) accountController];
    __int16 v15 = [*(id *)(a1 + 32) sharedState];
    id v16 = [v15 accountID];
    __int16 v17 = [v14 accountWithUniqueID:v16];
    CFStringRef v18 = [v17 primaryRegistration];
    double v19 = [v18 pushToken];
    unsigned int v20 = [*(id *)(a1 + 32) sharedState];
    id v21 = [v20 serviceName];
    dispatch_time_t v22 = +[IDSPushToken pushTokenWithData:v19 withServiceLoggingHint:v21];

    id v23 = +[IDSGroupEncryptionController sharedInstance];
    id v24 = [v23 createRealTimeEncryptionFullIdentityForDevice:v22 completionBlock:0];

    BOOL v25 = +[IDSGroupEncryptionController sharedInstance];
    uint64_t v26 = [*(id *)(a1 + 32) sharedState];
    dispatch_block_t v27 = [v26 groupID];
    CFStringRef v28 = [*(id *)(a1 + 32) sharedState];
    unint64_t v29 = [v28 uniqueID];
    [v25 reliablyRequestKeyMaterialForGroup:v27 sessionID:v29];
  }
}

void sub_10009F798(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5, uint64_t a6)
{
  id v10 = a2;
  id v11 = a3;
  id v12 = a4;
  __int16 v13 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v14 = @"NO";
    if (a6) {
      CFStringRef v14 = @"YES";
    }
    *(_DWORD *)buf = 138412546;
    id v19 = v11;
    __int16 v20 = 2112;
    CFStringRef v21 = v14;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Completed send of join notification fanout message { groupID: %@, success: %@ }", buf, 0x16u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
  {
    if (a6) {
      CFStringRef v15 = @"YES";
    }
    else {
      CFStringRef v15 = @"NO";
    }
    id v16 = v11;
    CFStringRef v17 = v15;
    _IDSLogTransport();
    if (_IDSShouldLog())
    {
      id v16 = v11;
      CFStringRef v17 = v15;
      _IDSLogV();
    }
  }
  objc_msgSend(*(id *)(a1 + 32), "_noteJoinNotificationDidDeliverWithSuccess:", a6, v16, v17);
}

void sub_10009FEE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  if (a2 == 1)
  {
    objc_begin_catch(exception_object);
    objc_end_catch();
    JUMPOUT(0x10009FD84);
  }
  _Unwind_Resume(exception_object);
}

void sub_10009FF4C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    uint64_t v2 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      id v3 = [WeakRetained sharedState];
      id v4 = [v3 groupID];
      *(_DWORD *)buf = 138412290;
      id v9 = v4;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Failed to receive all APNS courier acks for reliable join notification before timeout -- ending session { groupID: %@ }", buf, 0xCu);
    }
    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        unsigned int v5 = [WeakRetained sharedState];
        dispatch_block_t v7 = [v5 groupID];
        _IDSLogTransport();

        if (_IDSShouldLog())
        {
          CFStringRef v6 = objc_msgSend(WeakRetained, "sharedState", v7);
          dispatch_block_t v7 = [v6 groupID];
          _IDSLogV();
        }
      }
    }
    objc_msgSend(WeakRetained, "endSessionWithReason:", 40, v7);
  }
}

void sub_1000A10E4(id a1, BOOL a2)
{
  if (!a2) {
    _IDSTransportThreadAssertRealTimeMode(1);
  }
}

id sub_1000A10F4(uint64_t a1, uint64_t a2)
{
  id v4 = [*(id *)(a1 + 32) sharedState];
  if ([v4 clientType] == (id)4)
  {
    int v5 = *(unsigned __int8 *)(a2 + 1216);

    if (!v5) {
      *(unsigned char *)(a2 + 1216) = 1;
    }
  }
  else
  {
  }
  CFStringRef v6 = *(void **)(a1 + 32);

  return [v6 link:0 didReceivePacket:a2 fromDeviceUniqueID:0 cbuuid:0];
}

void sub_1000A117C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8, void *a9)
{
  id v13 = a2;
  id v14 = a8;
  id v15 = a9;
  id v16 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109634;
    int v23 = a6;
    __int16 v24 = 1024;
    int v25 = a7;
    __int16 v26 = 2112;
    id v27 = v15;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Open socket for session complete (socket: %d, initial link type:%d) (error: %@)", buf, 0x18u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      uint64_t v20 = a7;
      id v21 = v15;
      uint64_t v19 = a6;
      _IDSLogTransport();
      if (_IDSShouldLog())
      {
        uint64_t v20 = a7;
        id v21 = v15;
        uint64_t v19 = a6;
        _IDSLogV();
      }
    }
  }
  objc_msgSend(*(id *)(a1 + 32), "_setInitialLinkType:", a7, v19, v20, v21);
  CFStringRef v17 = *(_DWORD **)(a1 + 32);
  if ((a6 & 0x80000000) != 0 || v15)
  {
    CFStringRef v18 = [v17 sharedState];
    [v18 clearAllTimers];

    [*(id *)(a1 + 32) endSessionWithReason:10];
  }
  else
  {
    v17[146] = a6;
    [*(id *)(a1 + 32) checkAndCallSessionStart];
  }
}

void sub_1000A1368(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8, void *a9)
{
  id v12 = a2;
  id v13 = a8;
  id v14 = a9;
  id v15 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    int v16 = *(_DWORD *)(a1 + 40);
    *(_DWORD *)buf = 67109634;
    int v27 = v16;
    __int16 v28 = 1024;
    int v29 = a6;
    __int16 v30 = 2112;
    id v31 = v14;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Open socket for session complete (extra #%d) (socket: %d) (error: %@)", buf, 0x18u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      uint64_t v24 = a6;
      id v25 = v14;
      uint64_t v23 = *(unsigned int *)(a1 + 40);
      _IDSLogTransport();
      if (_IDSShouldLog())
      {
        uint64_t v24 = a6;
        id v25 = v14;
        uint64_t v23 = *(unsigned int *)(a1 + 40);
        _IDSLogV();
      }
    }
  }
  CFStringRef v17 = *(void **)(a1 + 32);
  if ((a6 & 0x80000000) != 0 || v14)
  {
    dispatch_time_t v22 = objc_msgSend(v17, "sharedState", v23, v24, v25);
    [v22 clearAllTimers];

    [*(id *)(a1 + 32) endSessionWithReason:10];
  }
  else
  {
    id v18 = v17;
    objc_sync_enter(v18);
    uint64_t v19 = *(void **)(*(void *)(a1 + 32) + 144);
    uint64_t v20 = +[NSNumber numberWithInt:a6];
    id v21 = +[NSNumber numberWithInt:*(unsigned int *)(a1 + 40)];
    [v19 setObject:v20 forKey:v21];

    objc_sync_exit(v18);
    [*(id *)(a1 + 32) checkAndCallSessionStart];
  }
}

void sub_1000A1B70(uint64_t a1)
{
  uint64_t v4 = IDSQuickRelayServerProviderKey;
  id v1 = *(void **)(a1 + 32);
  uint64_t v2 = +[NSNumber numberWithInteger:*(void *)(a1 + 40)];
  int v5 = v2;
  id v3 = +[NSDictionary dictionaryWithObjects:&v5 forKeys:&v4 count:1];
  [v1 link:v1 didReceiveReportEvent:v3];
}

void sub_1000A1CE4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000A22E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000A2328(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    uint64_t v2 = [*(id *)(a1 + 32) utunController];
    id v3 = [WeakRetained sharedState];
    uint64_t v4 = [v3 uniqueID];
    objc_msgSend(v2, "onTransportThread_SendSKEData:skeData:completionHandler:", v4, WeakRetained[72], &stru_100981170);

    int v5 = (void *)WeakRetained[72];
    WeakRetained[72] = 0;
  }
}

void sub_1000A23E0(id a1, NSError *a2)
{
  uint64_t v2 = a2;
  if (v2)
  {
    id v3 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      int v5 = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Retry sendSKEData failed with error: %@. Give up.", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
  }
}

uint64_t sub_1000A291C(uint64_t a1, uint64_t a2, void *a3)
{
  if (a3)
  {
    uint64_t v4 = *(void **)(a1 + 32);
    id v5 = a3;
    CFStringRef v6 = [v4 sharedState];
    [v6 setLocalBlob:v5];
  }
  dispatch_block_t v7 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16);

  return v7();
}

void sub_1000A3A48(id a1, BOOL a2)
{
  id v2 = +[IDSDSessionController sharedInstance];
  [v2 updateCriticalReliabilityState];
}

void sub_1000A3B50(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    uint64_t v4 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      id v10 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "disconnectGlobalLink failed with error %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        id v8 = v3;
        _IDSLogTransport();
        if (_IDSShouldLog())
        {
          id v8 = v3;
          _IDSLogV();
        }
      }
    }
  }
  id v5 = objc_msgSend(*(id *)(a1 + 32), "utunController", v8);
  CFStringRef v6 = [*(id *)(a1 + 32) sharedState];
  dispatch_block_t v7 = [v6 uniqueID];
  [v5 stopGlobalLinkForDevice:v7];
}

id sub_1000A3E34(uint64_t a1)
{
  return _[*(id *)(a1 + 32) didSessionReinitiated];
}

void sub_1000A52F8(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1000A50DCLL);
  }
  _Unwind_Resume(a1);
}

void sub_1000A5380(uint64_t a1)
{
  id v2 = +[IDSUTunDeliveryController sharedInstance];
  [v2 removeUTunPeerWithSessionID:*(void *)(a1 + 32) reason:0 shouldWait:0];

  id v3 = +[IDSUTunDeliveryController sharedInstance];
  [v3 unlockContinuityPeer:*(void *)(a1 + 32)];
}

void sub_1000A5404(uint64_t a1)
{
  id v6 = objc_alloc_init((Class)IMMessageContext);
  [v6 setShouldBoost:1];
  id v2 = +[IDSDaemon sharedInstance];
  id v3 = [*(id *)(a1 + 32) sharedState];
  uint64_t v4 = [v3 pushTopic];
  id v5 = [v2 broadcasterForTopic:v4 entitlement:kIDSSessionEntitlement command:0 messageContext:v6];

  [v5 groupSessionDidTerminate:*(void *)(a1 + 40)];
}

void sub_1000A54DC(uint64_t a1)
{
  [*(id *)(a1 + 32) submitAWDMetricsForIDSSessionCompleted];
  id v1 = +[IDSDSessionController sharedInstance];
  [v1 updateCriticalReliabilityState];
}

void sub_1000A57BC(uint64_t a1)
{
  id v2 = +[IDSUTunDeliveryController sharedInstance];
  [v2 defaultPeerSetLinkPreferences:*(void *)(a1 + 32)];
}

void sub_1000A5BDC(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    id v3 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138412290;
      uint64_t v17 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Unhooking and closing socket descriptors from TransportThread %@ (possibly not on TransportThread)", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        uint64_t v10 = *(void *)(a1 + 32);
        _IDSLogTransport();
        if (_IDSShouldLog())
        {
          uint64_t v10 = *(void *)(a1 + 32);
          _IDSLogV();
        }
      }
    }
    long long v13 = 0u;
    long long v14 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    id v5 = *(id *)(a1 + 32);
    id v6 = [v5 countByEnumeratingWithState:&v11 objects:v15 count:16];
    if (v6)
    {
      uint64_t v7 = *(void *)v12;
      do
      {
        id v8 = 0;
        do
        {
          if (*(void *)v12 != v7) {
            objc_enumerationMutation(v5);
          }
          int v9 = objc_msgSend(*(id *)(*((void *)&v11 + 1) + 8 * (void)v8), "intValue", v10);
          if (v9 != -1)
          {
            IDSTransportThreadRemoveSocket();
            close(v9);
          }
          id v8 = (char *)v8 + 1;
        }
        while (v6 != v8);
        id v6 = [v5 countByEnumeratingWithState:&v11 objects:v15 count:16];
      }
      while (v6);
    }
  }
}

void sub_1000A6AC0(id a1, BOOL a2)
{
  if (!a2) {
    _IDSTransportThreadAssertRealTimeMode(0);
  }
}

void sub_1000A719C(uint64_t a1)
{
  [*(id *)(a1 + 32) submitAWDMetricsForIDSSessionCompleted];
  id v1 = +[IDSDSessionController sharedInstance];
  [v1 updateCriticalReliabilityState];
}

uint64_t sub_1000A84E0(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a1;
  id v10 = a2;
  if (![v10 count] && !objc_msgSend(v9, "count"))
  {
    id v17 = 0;
    uint64_t v21 = 0;
    goto LABEL_14;
  }
  if ([v10 count] && !objc_msgSend(v9, "count"))
  {
    id v15 = [objc_alloc((Class)NSSet) initWithArray:v10];
    id v16 = 0;
    id v17 = 0;
    uint64_t v21 = 1;
  }
  else
  {
    if (![v10 count] && objc_msgSend(v9, "count"))
    {
      id v17 = [objc_alloc((Class)NSSet) initWithArray:v9];
      uint64_t v21 = 1;
LABEL_14:
      id v16 = 0;
      id v15 = 0;
      goto LABEL_26;
    }
    __int16 v26 = a3;
    int v27 = v11;
    long long v12 = +[NSSet setWithArray:v10];
    long long v13 = +[NSSet setWithArray:v9];
    unsigned int v14 = [v12 isEqualToSet:v13];
    if (v14)
    {
      id v15 = 0;
      id v16 = 0;
      id v17 = 0;
    }
    else
    {
      uint64_t v24 = a5;
      id v25 = a4;
      id v18 = [v13 mutableCopy];
      [v18 minusSet:v12];
      id v19 = [v12 mutableCopy];
      [v19 minusSet:v13];
      id v20 = [v13 mutableCopy];
      [v20 intersectSet:v12];
      if ([v19 count]) {
        id v15 = [v19 copy];
      }
      else {
        id v15 = 0;
      }
      if ([v18 count]) {
        id v17 = [v18 copy];
      }
      else {
        id v17 = 0;
      }
      uint64_t v23 = v18;
      if ([v20 count]) {
        id v16 = v20;
      }
      else {
        id v16 = 0;
      }

      a5 = v24;
      a4 = v25;
    }
    uint64_t v21 = v14 ^ 1;

    a3 = v26;
    long long v11 = v27;
  }
  if (v15)
  {
    id v15 = v15;
    *a3 = v15;
  }
LABEL_26:
  if (v17) {
    *a5 = v17;
  }
  if (v16) {
    *a4 = v16;
  }

  return v21;
}

void sub_1000A8764(int a1, int a2, void *a3, void *a4, void *a5, id *a6, id *a7, id *a8, id *a9)
{
  id v24 = a3;
  id v16 = a4;
  id v17 = a5;
  if ([v24 count])
  {
    id v18 = *a8;
    if (!*a8)
    {
      id v18 = objc_alloc_init((Class)NSMutableSet);
      *a8 = v18;
    }
    [v18 unionSet:v24];
    if (a1 && [v17 count])
    {
      id v19 = *a6;
      if (!*a6)
      {
        id v19 = objc_alloc_init((Class)NSMutableSet);
        *a6 = v19;
      }
      [v19 unionSet:v24];
    }
  }
  if ([v16 count])
  {
    if ([v24 count])
    {
      id v20 = *a9;
      if (!*a9)
      {
        id v20 = objc_alloc_init((Class)NSMutableSet);
        *a9 = v20;
      }
      [v20 unionSet:v16];
    }
    if ([v17 count])
    {
      id v21 = *a6;
      if (!*a6)
      {
        id v21 = objc_alloc_init((Class)NSMutableSet);
        *a6 = v21;
      }
      [v21 unionSet:v16];
    }
  }
  if ([v17 count])
  {
    id v22 = *a7;
    if (!*a7)
    {
      id v22 = objc_alloc_init((Class)NSMutableSet);
      *a7 = v22;
    }
    [v22 unionSet:v17];
    if (a2 && [v24 count])
    {
      id v23 = *a9;
      if (!*a9)
      {
        id v23 = objc_alloc_init((Class)NSMutableSet);
        *a9 = v23;
      }
      [v23 unionSet:v17];
    }
  }
}

void sub_1000A8928(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 72))
  {
    int v39 = [*(id *)(a1 + 32) groupStatusNotificationController];
    unsigned int v37 = [*(id *)(a1 + 32) sharedState];
    id v25 = [v37 groupID];
    id v35 = [*(id *)(a1 + 32) sharedState];
    uint64_t v33 = [v35 destinations];
    id v24 = [v33 allObjects];
    id v2 = *(void **)(a1 + 32);
    uint64_t v23 = v2[23];
    int v29 = [v2 accountController];
    id v31 = [*(id *)(a1 + 32) sharedState];
    int v27 = [v31 accountID];
    id v22 = [v29 accountWithUniqueID:v27];
    id v3 = [*(id *)(a1 + 32) sharedState];
    uint64_t v4 = [v3 fromURI];
    id v5 = [*(id *)(a1 + 32) sharedState];
    id v6 = [v5 uniqueID];
    unsigned __int8 v7 = [*(id *)(a1 + 32) shouldReportUPlusOneKey];
    id v8 = [*(id *)(a1 + 40) allObjects];
    id v9 = [*(id *)(a1 + 48) allObjects];
    LOBYTE(v21) = v7;
    [v39 notifyLeaveToSpecificMembersOfGroup:v25 members:v24 params:v23 fromAccount:v22 fromURI:v4 sessionID:v6 isUPlusOne:v21 requiredCapabilites:v8 requiredLackOfCapabilities:v9];
  }
  if (*(unsigned char *)(a1 + 73))
  {
    uint64_t v40 = [*(id *)(a1 + 32) groupStatusNotificationController];
    unsigned int v38 = [*(id *)(a1 + 32) sharedState];
    id v10 = [v38 groupID];
    BOOL v36 = [*(id *)(a1 + 32) sharedState];
    id v34 = [v36 destinations];
    __int16 v28 = [v34 allObjects];
    long long v11 = *(void **)(a1 + 32);
    uint64_t v26 = v11[23];
    __int16 v30 = [v11 accountController];
    id v32 = [*(id *)(a1 + 32) sharedState];
    long long v12 = [v32 accountID];
    long long v13 = [v30 accountWithUniqueID:v12];
    unsigned int v14 = [*(id *)(a1 + 32) sharedState];
    id v15 = [v14 fromURI];
    id v16 = [*(id *)(a1 + 32) sharedState];
    id v17 = [v16 uniqueID];
    unsigned __int8 v18 = [*(id *)(a1 + 32) shouldReportUPlusOneKey];
    id v19 = [*(id *)(a1 + 56) allObjects];
    id v20 = [*(id *)(a1 + 64) allObjects];
    LOBYTE(v21) = v18;
    [v40 notifyJoinToSpecificMembersOfGroup:v10 members:v28 params:v26 fromAccount:v13 fromURI:v15 sessionID:v17 isUPlusOne:v21 requiredCapabilites:v19 requiredLackOfCapabilities:v20];
  }
}

uint64_t sub_1000AA550(uint64_t a1, _WORD *a2)
{
  if (*(unsigned char *)a1 != 58) {
    return *a2 != 0;
  }
  int v3 = atoi((const char *)(a1 + 1));
  int v4 = v3;
  if ((v3 - 1) >= 0xFFFF)
  {
    id v6 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, " invalid port %d", buf, 8u);
    }

    uint64_t result = os_log_shim_legacy_logging_enabled();
    if (result)
    {
      uint64_t result = _IDSShouldLogTransport();
      if (result)
      {
        _IDSLogTransport();
        uint64_t result = _IDSShouldLog();
        if (result)
        {
          _IDSLogV();
          return 0;
        }
      }
    }
  }
  else
  {
    *a2 = v3;
    return 1;
  }
  return result;
}

id sub_1000AA84C(uint64_t a1)
{
  if (!*(void *)(*(void *)(a1 + 32) + 536))
  {
    id v2 = objc_alloc_init((Class)NSMutableArray);
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = *(void **)(v3 + 536);
    *(void *)(v3 + 536) = v2;
  }
  id v5 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v7 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 138412546;
    uint64_t v12 = v6;
    __int16 v13 = 2112;
    uint64_t v14 = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "<%@> add the new QR event for the RTC report: %@", buf, 0x16u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      uint64_t v9 = *(void *)(a1 + 32);
      uint64_t v10 = *(void *)(a1 + 40);
      _IDSLogTransport();
      if (_IDSShouldLog())
      {
        uint64_t v9 = *(void *)(a1 + 32);
        uint64_t v10 = *(void *)(a1 + 40);
        _IDSLogV();
      }
    }
  }
  return objc_msgSend(*(id *)(*(void *)(a1 + 32) + 536), "addObject:", *(void *)(a1 + 40), v9, v10);
}

id sub_1000AA9C4(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _sendQREventToAVC:*(void *)(a1 + 40)];
}

void sub_1000AB824(uint64_t a1)
{
  uint64_t v10 = +[IDSGroupEncryptionController sharedInstance];
  uint64_t v11 = *(void *)(a1 + 32);
  uint64_t v12 = [*(id *)(a1 + 40) sharedState];
  id v2 = [v12 groupID];
  uint64_t v3 = [*(id *)(a1 + 40) accountController];
  int v4 = [*(id *)(a1 + 40) sharedState];
  id v5 = [v4 accountID];
  uint64_t v6 = [v3 accountWithUniqueID:v5];
  uint64_t v8 = *(void *)(a1 + 48);
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v9 = *(void **)(a1 + 64);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_1000AB9B4;
  v13[3] = &unk_100981278;
  void v13[4] = *(void *)(a1 + 40);
  id v14 = v9;
  id v15 = *(id *)(a1 + 48);
  id v16 = *(id *)(a1 + 56);
  [v10 processedQRMKMPayloadFromData:v11 forGroupID:v2 account:v6 remoteURI:v8 localURI:v7 tokens:v14 completionHandler:v13];
}

void sub_1000AB9B4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v5)
  {
    uint64_t v7 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      if (qword_100A4A5D0 != -1) {
        dispatch_once(&qword_100A4A5D0, &stru_100981748);
      }
      *(_DWORD *)buf = 134217984;
      double v27 = *(double *)&qword_100A4A5D8 * (double)mach_continuous_time();
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Receiving Key Material (QR) [*KM] -- %f", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
    {
      if (qword_100A4A5D0 != -1) {
        dispatch_once(&qword_100A4A5D0, &stru_100981748);
      }
      double v20 = *(double *)&qword_100A4A5D8 * (double)mach_continuous_time();
      _IDSLogTransport();
      if (_IDSShouldLog())
      {
        if (qword_100A4A5D0 != -1) {
          dispatch_once(&qword_100A4A5D0, &stru_100981748);
        }
        double v20 = *(double *)&qword_100A4A5D8 * (double)mach_continuous_time();
        _IDSLogV();
      }
    }
    uint64_t v8 = *(void **)(*(void *)(a1 + 32) + 896);
    uint64_t v9 = objc_msgSend(*(id *)(a1 + 40), "firstObject", *(void *)&v20);
    [v8 receivedKMOverQRFromToken:v9];

    uint64_t v10 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      double v11 = *(double *)(a1 + 40);
      uint64_t v12 = *(void *)(a1 + 48);
      uint64_t v13 = *(void *)(a1 + 56);
      *(_DWORD *)buf = 138412802;
      double v27 = v11;
      __int16 v28 = 2112;
      uint64_t v29 = v12;
      __int16 v30 = 2112;
      uint64_t v31 = v13;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Received remote key material message from tokens %@ fromURI %@ toURI %@", buf, 0x20u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
    id v14 = im_primary_queue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000ABECC;
    block[3] = &unk_10097E5A8;
    id v22 = v5;
    id v23 = v6;
    id v24 = *(id *)(a1 + 48);
    id v25 = *(id *)(a1 + 56);
    dispatch_block_t v15 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS|DISPATCH_BLOCK_ASSIGN_CURRENT, QOS_CLASS_USER_INITIATED, 0, block);
    dispatch_async(v14, v15);
  }
  else
  {
    id v16 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      double v17 = *(double *)(a1 + 40);
      uint64_t v18 = *(void *)(a1 + 48);
      uint64_t v19 = *(void *)(a1 + 56);
      *(_DWORD *)buf = 138412802;
      double v27 = v17;
      __int16 v28 = 2112;
      uint64_t v29 = v18;
      __int16 v30 = 2112;
      uint64_t v31 = v19;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Could not process remote key material message from tokens %@ fromURI %@ toURI %@", buf, 0x20u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
  }
}

void sub_1000ABECC(void *a1)
{
  id v4 = +[IDSDSessionController sharedInstance];
  uint64_t v2 = a1[4];
  uint64_t v3 = +[IDSPushToken pushTokenWithData:a1[5]];
  [v4 processIncomingGroupSessionMessage:v2 fromToken:v3 fromURI:a1[6] toURI:a1[7] topic:0 idsMessageContext:0];
}

void sub_1000ADAB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id *location)
{
  if (a2 == 1)
  {
    objc_begin_catch(exception_object);
    objc_end_catch();
    JUMPOUT(0x1000AD998);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000ADD08(uint64_t a1)
{
  uint64_t v2 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(a1 + 32) ownerParticipantId];
    id v4 = [*(id *)(a1 + 40) sharedState];
    id v5 = [v4 groupID];
    id v6 = [*(id *)(a1 + 40) sharedState];
    uint64_t v7 = [v6 uniqueID];
    *(_DWORD *)buf = 134218498;
    *(void *)&uint8_t buf[4] = v3;
    __int16 v22 = 2112;
    id v23 = v5;
    __int16 v24 = 2112;
    id v25 = v7;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "didReceiveMaterialInfo: processing pending material from %llu for group %@ and session %@", buf, 0x20u);
  }
  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      id v8 = [*(id *)(a1 + 32) ownerParticipantId];
      uint64_t v9 = [*(id *)(a1 + 40) sharedState];
      uint64_t v10 = [v9 groupID];
      double v11 = [*(id *)(a1 + 40) sharedState];
      uint64_t v19 = [v11 uniqueID];
      _IDSLogTransport();

      if (_IDSShouldLog())
      {
        objc_msgSend(*(id *)(a1 + 32), "ownerParticipantId", v8, v10, v19);
        uint64_t v12 = [*(id *)(a1 + 40) sharedState];
        uint64_t v13 = [v12 groupID];
        id v14 = [*(id *)(a1 + 40) sharedState];
        double v20 = [v14 uniqueID];
        _IDSLogV();
      }
    }
  }
  if (qword_100A4A5D0 != -1) {
    dispatch_once(&qword_100A4A5D0, &stru_100981748);
  }
  if (*(double *)&qword_100A4A5D8 * (double)mach_continuous_time() <= *(double *)(a1 + 72))
  {
    *(void *)buf = 0xAAAAAAAAAAAAAAAALL;
    objc_copyWeak((id *)buf, (id *)(a1 + 64));
    id WeakRetained = objc_loadWeakRetained((id *)buf);

    if (WeakRetained)
    {
      id v18 = objc_loadWeakRetained((id *)(a1 + 64));
      [v18 link:*(void *)(a1 + 48) didReceiveMaterialInfo:*(void *)(a1 + 56) material:*(void *)(a1 + 32)];
    }
    objc_destroyWeak((id *)buf);
  }
  else
  {
    dispatch_block_t v15 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      if (qword_100A4A5D0 != -1) {
        dispatch_once(&qword_100A4A5D0, &stru_100981748);
      }
      double v16 = *(double *)&qword_100A4A5D8 * (double)mach_continuous_time() - *(double *)(a1 + 72);
      *(_DWORD *)buf = 134217984;
      *(double *)&uint8_t buf[4] = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "didReceiveMaterialInfo: dropping material because it timed out by %f seconds", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
    {
      if (qword_100A4A5D0 != -1) {
        dispatch_once(&qword_100A4A5D0, &stru_100981748);
      }
      mach_continuous_time();
      _IDSLogTransport();
      if (_IDSShouldLog())
      {
        if (qword_100A4A5D0 != -1) {
          dispatch_once(&qword_100A4A5D0, &stru_100981748);
        }
        mach_continuous_time();
        _IDSLogV();
      }
    }
  }
}

void sub_1000AE164(_Unwind_Exception *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id location)
{
  if (a2 == 1)
  {
    objc_begin_catch(exc_buf);
    objc_end_catch();
    JUMPOUT(0x1000ADFC8);
  }
  _Unwind_Resume(exc_buf);
}

void sub_1000AE1C0(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  if (a2)
  {
    switch([*(id *)(a1 + 32) materialType])
    {
      case 5u:
        id v6 = +[IDSFoundationLog IDSDSession];
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          double v7 = *(double *)(a1 + 56);
          id v8 = [*(id *)(a1 + 48) ownerParticipantId];
          *(_DWORD *)buf = 138412546;
          double v138 = v7;
          __int16 v139 = 2048;
          id v140 = v8;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "payload: %@, material.ownerParticipantId: %llu", buf, 0x16u);
        }

        uint64_t v9 = *(void *)(a1 + 56);
        if (v9) {
          objc_msgSend(*(id *)(*(void *)(a1 + 40) + 864), "receiveDictionaryData:forType:fromParticipant:", v9, objc_msgSend(*(id *)(a1 + 32), "materialType"), objc_msgSend(*(id *)(a1 + 48), "ownerParticipantId"));
        }
        break;
      case 0xBu:
        id v14 = OSLogHandleForTransportCategory();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          if (qword_100A4A5D0 != -1) {
            dispatch_once(&qword_100A4A5D0, &stru_100981748);
          }
          *(_DWORD *)buf = 134217984;
          double v138 = *(double *)&qword_100A4A5D8 * (double)mach_continuous_time();
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Receiving Key Material (QUIC) [PreKey] -- %f", buf, 0xCu);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
        {
          if (qword_100A4A5D0 != -1) {
            dispatch_once(&qword_100A4A5D0, &stru_100981748);
          }
          double v116 = *(double *)&qword_100A4A5D8 * (double)mach_continuous_time();
          _IDSLogTransport();
          if (_IDSShouldLog())
          {
            double v116 = sub_100087A84();
            _IDSLogV();
          }
        }
        dispatch_block_t v15 = *(void **)(*(void *)(a1 + 40) + 896);
        double v16 = objc_msgSend(*(id *)(a1 + 64), "rawToken", *(void *)&v116);
        double v17 = [v15 joinCycleForToken:v16];
        [v17 receivedPreKeyOverQUIC];

        id v18 = *(void **)(a1 + 56);
        uint64_t v19 = +[IDSGroupEncryptionPreKeyDictionaryKeys publicPreKey];
        double v20 = [v18 objectForKey:v19];
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          uint64_t v21 = *(void **)(a1 + 56);
          __int16 v22 = +[IDSGroupEncryptionPreKeyDictionaryKeys publicPreKey];
          id v23 = [v21 objectForKey:v22];
          __int16 v24 = +[NSData _IDSDataFromBase64String:v23];
        }
        else
        {
          unint64_t v65 = *(void **)(a1 + 56);
          __int16 v22 = +[IDSGroupEncryptionPreKeyDictionaryKeys publicPreKey];
          id v23 = [v65 objectForKey:v22];
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            uint64_t v66 = *(void **)(a1 + 56);
            __int16 v67 = +[IDSGroupEncryptionPreKeyDictionaryKeys publicPreKey];
            __int16 v24 = [v66 objectForKey:v67];
          }
          else
          {
            __int16 v24 = 0;
          }
        }

        if (v24)
        {
          uint64_t v91 = objc_opt_class();
          id v92 = *(void **)(a1 + 56);
          unsigned int v93 = +[IDSGroupEncryptionPreKeyDictionaryKeys wrapMode];
          sub_1000AF6F8(v91, v92, v93);
          id v132 = (id)objc_claimAutoreleasedReturnValue();

          uint64_t v94 = objc_opt_class();
          uint64_t v95 = *(void **)(a1 + 56);
          id v96 = +[IDSGroupEncryptionPreKeyDictionaryKeys creationDate];
          v129 = sub_1000AF6F8(v94, v95, v96);

          if (v132)
          {
            if (v129)
            {
              uint64_t v97 = +[IDSGroupEncryptionController sharedInstance];
              uint64_t v99 = *(void **)(a1 + 40);
              uint64_t v98 = a1 + 40;
              uint64_t v100 = *(void *)(v98 + 24);
              uint64_t v101 = *(void *)(v98 + 32);
              uint64_t v102 = [v99 sharedState];
              uint64_t v103 = [v102 groupID];
              uint64_t v104 = [*(id *)v98 sharedState];
              uint64_t v105 = [v104 uniqueID];
              [v129 doubleValue];
              uint64_t v106 = +[NSDate dateWithTimeIntervalSince1970:](NSDate, "dateWithTimeIntervalSince1970:");
              objc_msgSend(v97, "setRealTimeEncryptionPublicKey:forDevice:fromURI:groupID:sessionID:serverDate:wrapMode:", v24, v100, v101, v103, v105, v106, (int)objc_msgSend(v132, "intValue"));
            }
            else
            {
              uint64_t v113 = OSLogHandleForTransportCategory();
              if (os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT))
              {
                double v114 = COERCE_DOUBLE([*(id *)(a1 + 48) ownerParticipantId]);
                uint64_t v115 = *(void **)(a1 + 56);
                *(_DWORD *)buf = 134218242;
                double v138 = v114;
                __int16 v139 = 2112;
                id v140 = v115;
                _os_log_impl((void *)&_mh_execute_header, v113, OS_LOG_TYPE_DEFAULT, "didReceiveMaterialInfo could not process preKey for participant %llu; no creation date found in payload %@",
                  buf,
                  0x16u);
              }

              if (os_log_shim_legacy_logging_enabled())
              {
                if (_IDSShouldLogTransport())
                {
                  id v118 = [*(id *)(a1 + 48) ownerParticipantId];
                  id v123 = *(id *)(a1 + 56);
                  _IDSLogTransport();
                  if (_IDSShouldLog())
                  {
                    id v118 = objc_msgSend(*(id *)(a1 + 48), "ownerParticipantId", v118, v123);
                    id v123 = *(id *)(a1 + 56);
                    _IDSLogV();
                  }
                }
              }
              objc_msgSend(*(id *)(a1 + 40), "materialInfoError:", @"missingServerDateTimestamp", v118, v123);
            }
          }
          else
          {
            uint64_t v110 = OSLogHandleForTransportCategory();
            if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
            {
              double v111 = COERCE_DOUBLE([*(id *)(a1 + 48) ownerParticipantId]);
              uint64_t v112 = *(void **)(a1 + 56);
              *(_DWORD *)buf = 134218242;
              double v138 = v111;
              __int16 v139 = 2112;
              id v140 = v112;
              _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "didReceiveMaterialInfo could not process preKey for participant %llu; no wrap-mode found in payload %@",
                buf,
                0x16u);
            }

            if (os_log_shim_legacy_logging_enabled())
            {
              if (_IDSShouldLogTransport())
              {
                id v118 = [*(id *)(a1 + 48) ownerParticipantId];
                id v123 = *(id *)(a1 + 56);
                _IDSLogTransport();
                if (_IDSShouldLog())
                {
                  id v118 = objc_msgSend(*(id *)(a1 + 48), "ownerParticipantId", v118, v123);
                  id v123 = *(id *)(a1 + 56);
                  _IDSLogV();
                }
              }
            }
            objc_msgSend(*(id *)(a1 + 40), "materialInfoError:", @"missingWrapMode", v118, v123);
          }
        }
        else
        {
          uint64_t v107 = OSLogHandleForTransportCategory();
          if (os_log_type_enabled(v107, OS_LOG_TYPE_DEFAULT))
          {
            double v108 = COERCE_DOUBLE([*(id *)(a1 + 48) ownerParticipantId]);
            uint64_t v109 = *(void **)(a1 + 56);
            *(_DWORD *)buf = 134218242;
            double v138 = v108;
            __int16 v139 = 2112;
            id v140 = v109;
            _os_log_impl((void *)&_mh_execute_header, v107, OS_LOG_TYPE_DEFAULT, "didReceiveMaterialInfo could not process preKey for participant %llu; no preKey found in payload %@",
              buf,
              0x16u);
          }

          if (os_log_shim_legacy_logging_enabled())
          {
            if (_IDSShouldLogTransport())
            {
              id v118 = [*(id *)(a1 + 48) ownerParticipantId];
              id v123 = *(id *)(a1 + 56);
              _IDSLogTransport();
              if (_IDSShouldLog())
              {
                id v118 = objc_msgSend(*(id *)(a1 + 48), "ownerParticipantId", v118, v123);
                id v123 = *(id *)(a1 + 56);
                _IDSLogV();
              }
            }
          }
          objc_msgSend(*(id *)(a1 + 40), "materialInfoError:", @"missingPreKeyData", v118, v123);
        }

        break;
      case 0xDu:
        id v25 = OSLogHandleForTransportCategory();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          if (qword_100A4A5D0 != -1) {
            dispatch_once(&qword_100A4A5D0, &stru_100981748);
          }
          *(_DWORD *)buf = 134217984;
          double v138 = *(double *)&qword_100A4A5D8 * (double)mach_continuous_time();
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Receiving Key Material (QUIC) [MKM] -- %f", buf, 0xCu);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
        {
          if (qword_100A4A5D0 != -1) {
            dispatch_once(&qword_100A4A5D0, &stru_100981748);
          }
          double v116 = *(double *)&qword_100A4A5D8 * (double)mach_continuous_time();
          _IDSLogTransport();
          if (_IDSShouldLog())
          {
            double v116 = sub_100087A84();
            _IDSLogV();
          }
        }
        uint64_t v26 = *(void **)(*(void *)(a1 + 40) + 896);
        double v27 = objc_msgSend(*(id *)(a1 + 64), "rawToken", *(void *)&v116);
        [v26 receivedKMOverQUICFromToken:v27];

        id v130 = [*(id *)(a1 + 56) objectForKeyedSubscript:IDSRealTimeEncryptionMKI];
        if ([v130 length] == (id)16)
        {
          __int16 v28 = objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDBytes:", objc_msgSend(v130, "bytes"));
          uint64_t v29 = *(void **)(*(void *)(a1 + 40) + 896);
          __int16 v30 = IDSGetUUIDDataFromNSUUID();
          uint64_t v31 = [v29 getOrCreateMKICycleFor:v30];
          [v31 receivedFromGFT2];
        }
        else
        {
          __int16 v28 = +[IDSFoundationLog IDSDSession];
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
            sub_10070DEE4();
          }
        }

        uint64_t v49 = *(void *)(a1 + 40);
        if (!*(unsigned char *)(v49 + 752))
        {
          *(unsigned char *)(v49 + 752) = 1;
          if (qword_100A4A5D0 != -1) {
            dispatch_once(&qword_100A4A5D0, &stru_100981748);
          }
          *(double *)(*(void *)(a1 + 40) + 760) = *(double *)&qword_100A4A5D8 * (double)mach_continuous_time();
        }
        uint64_t v50 = +[IDSGroupEncryptionController sharedInstance];
        uint64_t v52 = *(void *)(a1 + 56);
        uint64_t v51 = *(void *)(a1 + 64);
        uint64_t v53 = *(void *)(a1 + 72);
        double v54 = [*(id *)(a1 + 40) sharedState];
        double v55 = [v54 groupID];
        uint64_t v56 = [*(id *)(a1 + 40) sharedState];
        uint64_t v57 = [v56 uniqueID];
        id v134 = 0;
        LOWORD(v126) = 1;
        LOBYTE(v119) = 1;
        id v58 = objc_msgSend(v50, "receivedAndSetKeyMaterial:stableKeyMaterial:forDevice:fromURI:groupID:sessionID:fromSender:error:forMKM:forSKM:", v52, 0, v51, v53, v55, v57, v119, &v134, v126);
        id v59 = v134;

        if (v59)
        {
          uint64_t v60 = OSLogHandleForTransportCategory();
          if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
          {
            double v61 = COERCE_DOUBLE([*(id *)(a1 + 48) ownerParticipantId]);
            __int16 v62 = *(void **)(a1 + 56);
            *(_DWORD *)buf = 134218498;
            double v138 = v61;
            __int16 v139 = 2112;
            id v140 = v62;
            __int16 v141 = 2112;
            id v142 = v59;
            _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "didReceiveMaterialInfo failed processing MKM for participant %llu; payload %@; error: %@",
              buf,
              0x20u);
          }

          if (os_log_shim_legacy_logging_enabled())
          {
            if (_IDSShouldLogTransport())
            {
              id v63 = [*(id *)(a1 + 48) ownerParticipantId];
              uint64_t v125 = *(void *)(a1 + 56);
              id v128 = v59;
              id v122 = v63;
              _IDSLogTransport();
              if (_IDSShouldLog())
              {
                id v64 = objc_msgSend(*(id *)(a1 + 48), "ownerParticipantId", v122, v125, v59);
                uint64_t v125 = *(void *)(a1 + 56);
                id v128 = v59;
                id v122 = v64;
                _IDSLogV();
              }
            }
          }
          objc_msgSend(*(id *)(a1 + 40), "materialInfoError:", @"failedProcessingMKM", v122, v125, v128);
        }
        else
        {
          if (v58)
          {
            double v80 = [v58 objectForKeyedSubscript:@"ids-rtencryption-master-key-material-key"];
            __int16 v81 = +[IDSGroupEncryptionController sharedInstance];
            v136 = v80;
            double v82 = +[NSArray arrayWithObjects:&v136 count:1];
            uint64_t v135 = *(void *)(a1 + 72);
            uint64_t v83 = +[NSArray arrayWithObjects:&v135 count:1];
            uint64_t v84 = [*(id *)(a1 + 40) sharedState];
            uint64_t v85 = [v84 uniqueID];
            [v81 noteReceivedGroupMasterKeyMaterials:v82 URIs:v83 sessionID:v85];
          }
          uint64_t v86 = +[IDSGroupEncryptionController sharedInstance];
          uint64_t v87 = [*(id *)(a1 + 40) sharedState];
          uint64_t v88 = [v87 groupID];
          uint64_t v89 = [*(id *)(a1 + 40) sharedState];
          id v90 = [v89 uniqueID];
          [v86 requestPendingKeyMaterialsForGroup:v88 sessionID:v90];
        }
        break;
      case 0xEu:
        id v32 = OSLogHandleForTransportCategory();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
          if (qword_100A4A5D0 != -1) {
            dispatch_once(&qword_100A4A5D0, &stru_100981748);
          }
          *(_DWORD *)buf = 134217984;
          double v138 = *(double *)&qword_100A4A5D8 * (double)mach_continuous_time();
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "Receiving Key Material (QUIC) [SKM] -- %f", buf, 0xCu);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
        {
          if (qword_100A4A5D0 != -1) {
            dispatch_once(&qword_100A4A5D0, &stru_100981748);
          }
          double v116 = *(double *)&qword_100A4A5D8 * (double)mach_continuous_time();
          _IDSLogTransport();
          if (_IDSShouldLog())
          {
            double v116 = sub_100087A84();
            _IDSLogV();
          }
        }
        uint64_t v33 = *(void **)(*(void *)(a1 + 40) + 896);
        id v34 = objc_msgSend(*(id *)(a1 + 64), "rawToken", *(void *)&v116);
        [v33 receivedKMOverQUICFromToken:v34];

        id v35 = +[IDSGroupEncryptionController sharedInstance];
        uint64_t v36 = *(void *)(a1 + 56);
        uint64_t v37 = *(void *)(a1 + 64);
        uint64_t v38 = *(void *)(a1 + 72);
        int v39 = [*(id *)(a1 + 40) sharedState];
        uint64_t v40 = [v39 groupID];
        id v41 = [*(id *)(a1 + 40) sharedState];
        double v42 = [v41 uniqueID];
        id v133 = 0;
        LOWORD(v126) = 256;
        LOBYTE(v120) = 1;
        objc_msgSend(v35, "receivedAndSetKeyMaterial:stableKeyMaterial:forDevice:fromURI:groupID:sessionID:fromSender:error:forMKM:forSKM:", 0, v36, v37, v38, v40, v42, v120, &v133, v126);
        id v131 = (id)objc_claimAutoreleasedReturnValue();
        id v43 = v133;

        if (v43)
        {
          unsigned int v44 = OSLogHandleForTransportCategory();
          if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
          {
            double v45 = COERCE_DOUBLE([*(id *)(a1 + 48) ownerParticipantId]);
            id v46 = *(void **)(a1 + 56);
            *(_DWORD *)buf = 134218498;
            double v138 = v45;
            __int16 v139 = 2112;
            id v140 = v46;
            __int16 v141 = 2112;
            id v142 = v43;
            _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "didReceiveMaterialInfo failed processing SKM for participant %llu; payload %@; error: %@",
              buf,
              0x20u);
          }

          if (os_log_shim_legacy_logging_enabled())
          {
            if (_IDSShouldLogTransport())
            {
              id v47 = [*(id *)(a1 + 48) ownerParticipantId];
              uint64_t v124 = *(void *)(a1 + 56);
              id v127 = v43;
              id v121 = v47;
              _IDSLogTransport();
              if (_IDSShouldLog())
              {
                id v48 = objc_msgSend(*(id *)(a1 + 48), "ownerParticipantId", v121, v124, v43);
                uint64_t v124 = *(void *)(a1 + 56);
                id v127 = v43;
                id v121 = v48;
                _IDSLogV();
              }
            }
          }
          objc_msgSend(*(id *)(a1 + 40), "materialInfoError:", @"failedProcessingSKM", v121, v124, v127);
        }
        else
        {
          if (v131)
          {
            int v68 = +[IDSGroupEncryptionController sharedInstance];
            BOOL v69 = [v131 objectForKeyedSubscript:@"ids-rtencryption-stable-key-material-key"];
            uint64_t v70 = *(void *)(a1 + 64);
            unsigned __int8 v71 = [*(id *)(a1 + 40) sharedState];
            uint64_t v72 = [v71 uniqueID];
            uint64_t v73 = [*(id *)(a1 + 40) sharedState];
            uint64_t v74 = [v73 groupID];
            [v68 receivedGroupStableKeyMaterial:v69 fromPushToken:v70 sessionID:v72 groupID:v74];
          }
          __int16 v75 = +[IDSGroupEncryptionController sharedInstance];
          dispatch_block_t v76 = [*(id *)(a1 + 40) sharedState];
          __int16 v77 = [v76 groupID];
          double v78 = [*(id *)(a1 + 40) sharedState];
          __int16 v79 = [v78 uniqueID];
          [v75 requestPendingKeyMaterialsForGroup:v77 sessionID:v79];
        }
        break;
      default:
        uint64_t v12 = OSLogHandleForTransportCategory();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v13 = [*(id *)(a1 + 32) materialType];
          *(_DWORD *)buf = 67109120;
          LODWORD(v138) = v13;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "didReceiveMaterialInfo unknown material type %d", buf, 8u);
        }

        if (os_log_shim_legacy_logging_enabled())
        {
          if (_IDSShouldLogTransport())
          {
            id v117 = [*(id *)(a1 + 32) materialType];
            _IDSLogTransport();
            if (_IDSShouldLog())
            {
              objc_msgSend(*(id *)(a1 + 32), "materialType", v117);
              _IDSLogV();
            }
          }
        }
        break;
    }
  }
  else
  {
    uint64_t v10 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      double v11 = *(double *)(a1 + 32);
      *(_DWORD *)buf = 138412546;
      double v138 = v11;
      __int16 v139 = 2112;
      id v140 = v5;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "didReceiveMaterialInfo failed to verify signature for info: %@ error: %@", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        double v116 = *(double *)(a1 + 32);
        id v123 = v5;
        _IDSLogTransport();
        if (_IDSShouldLog())
        {
          double v116 = *(double *)(a1 + 32);
          id v123 = v5;
          _IDSLogV();
        }
      }
    }
    objc_msgSend(*(id *)(a1 + 40), "materialInfoError:", @"failedSignatureVerification", *(void *)&v116, v123);
  }
}

void sub_1000AF5E0(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1000AF488);
  }
  _Unwind_Resume(a1);
}

id sub_1000AF6F8(uint64_t a1, void *a2, void *a3)
{
  id v4 = a3;
  id v5 = [a2 objectForKey:v4];
  if (objc_opt_isKindOfClass())
  {
    id v6 = v5;
  }
  else
  {
    if (v5)
    {
      double v7 = +[IMRGLog registration];
      if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
        sub_10070DF18();
      }
    }
    id v6 = 0;
  }

  return v6;
}

void sub_1000AF7B4(id *a1, char a2, void *a3)
{
  id v5 = a3;
  id v6 = im_primary_queue();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000AF8C0;
  block[3] = &unk_100981318;
  id v11 = a1[4];
  id v12 = a1[5];
  id v7 = a1[6];
  char v15 = a2;
  id v13 = v5;
  id v14 = v7;
  id v8 = v5;
  dispatch_block_t v9 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS|DISPATCH_BLOCK_ASSIGN_CURRENT, QOS_CLASS_USER_INTERACTIVE, 0, block);
  dispatch_async(v6, v9);
}

uint64_t sub_1000AF8C0(uint64_t a1)
{
  uint64_t v2 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 138412546;
    uint64_t v7 = v3;
    __int16 v8 = 2112;
    uint64_t v9 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "didReceiveMaterialInfo verified signature: %@ matchesPayload: %@", buf, 0x16u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      _IDSLogTransport();
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
  }
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned __int8 *)(a1 + 64));
}

uint64_t sub_1000AFA18(uint64_t a1)
{
  uint64_t v2 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "didReceiveMaterialInfo did not verify signature", v4, 2u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      _IDSLogTransport();
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

id sub_1000AFD4C(uint64_t a1)
{
  return [*(id *)(a1 + 32) _setInitialLinkType:*(void *)(a1 + 40)];
}

void sub_1000B0EB0(uint64_t a1)
{
  id v8 = objc_alloc_init((Class)IMMessageContext);
  [v8 setShouldBoost:1];
  uint64_t v2 = +[IDSDaemon sharedInstance];
  uint64_t v3 = [*(id *)(a1 + 32) sharedState];
  uint64_t v4 = [v3 pushTopic];
  id v5 = [v2 broadcasterForTopic:v4 entitlement:kIDSSessionEntitlement command:0 messageContext:v8];

  id v6 = [*(id *)(a1 + 32) sharedState];
  uint64_t v7 = [v6 uniqueID];
  [v5 participantUpdatedForSession:v7];
}

void sub_1000B2278(uint64_t a1)
{
  id v6 = objc_alloc_init((Class)IMMessageContext);
  [v6 setShouldBoost:1];
  uint64_t v2 = +[IDSDaemon sharedInstance];
  uint64_t v3 = [*(id *)(a1 + 32) sharedState];
  uint64_t v4 = [v3 pushTopic];
  id v5 = [v2 broadcasterForTopic:v4 entitlement:kIDSSessionEntitlement command:0 messageContext:v6];

  [v5 groupSessionDidConnectUnderlyingLinks:*(void *)(a1 + 40)];
}

void sub_1000B2858(uint64_t a1)
{
  id v6 = objc_alloc_init((Class)IMMessageContext);
  [v6 setShouldBoost:1];
  uint64_t v2 = +[IDSDaemon sharedInstance];
  uint64_t v3 = [*(id *)(a1 + 32) sharedState];
  uint64_t v4 = [v3 pushTopic];
  id v5 = [v2 broadcasterForTopic:v4 entitlement:kIDSSessionEntitlement command:0 messageContext:v6];

  [v5 groupSessionDidDisconnectUnderlyingLinks:*(void *)(a1 + 40)];
}

void sub_1000B585C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 248), 8);
  _Unwind_Resume(a1);
}

void sub_1000B5894(uint64_t a1)
{
  id v8 = objc_alloc_init((Class)IMMessageContext);
  [v8 setShouldBoost:1];
  uint64_t v2 = +[IDSDaemon sharedInstance];
  uint64_t v3 = [*(id *)(a1 + 32) sharedState];
  uint64_t v4 = [v3 pushTopic];
  id v5 = [v2 broadcasterForTopic:v4 entitlement:kIDSSessionEntitlement command:0 messageContext:v8];

  id v6 = [*(id *)(a1 + 32) sharedState];
  uint64_t v7 = [v6 uniqueID];
  [v5 session:v7 didReceiveBlockedParticipantIDs:*(void *)(a1 + 40) withCode:0 withType:*(unsigned __int16 *)(a1 + 48) isTruncated:*(unsigned __int8 *)(a1 + 50)];
}

void sub_1000B59A0(uint64_t a1)
{
  id v11 = objc_alloc_init((Class)IMMessageContext);
  [v11 setShouldBoost:1];
  uint64_t v2 = +[IDSDaemon sharedInstance];
  uint64_t v3 = [*(id *)(a1 + 32) sharedState];
  uint64_t v4 = [v3 pushTopic];
  id v5 = [v2 broadcasterForTopic:v4 entitlement:kIDSSessionEntitlement command:0 messageContext:v11];

  int v6 = *(unsigned __int16 *)(a1 + 56);
  if (v6 == 3)
  {
    uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8);
    goto LABEL_6;
  }
  if (v6 != 4)
  {
    uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8);
    int v8 = 2;
    goto LABEL_8;
  }
  uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8);
  if (*(_WORD *)(a1 + 58) != 5)
  {
LABEL_6:
    *(_DWORD *)(v7 + 24) = 0;
    goto LABEL_9;
  }
  int v8 = 3;
LABEL_8:
  *(_DWORD *)(v7 + 24) = v8;
LABEL_9:
  uint64_t v9 = [*(id *)(a1 + 32) sharedState];
  uint64_t v10 = [v9 uniqueID];
  [v5 session:v10 didReceiveQueryBlockedParticipantIDs:*(void *)(a1 + 40) withCode:*(unsigned int *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) isTruncated:*(unsigned __int8 *)(a1 + 60)];
}

void sub_1000B5AFC(uint64_t a1)
{
  id v12 = objc_alloc_init((Class)IMMessageContext);
  [v12 setShouldBoost:1];
  uint64_t v2 = +[IDSDaemon sharedInstance];
  uint64_t v3 = [*(id *)(a1 + 32) sharedState];
  uint64_t v4 = [v3 pushTopic];
  id v5 = [v2 broadcasterForTopic:v4 entitlement:kIDSSessionEntitlement command:0 messageContext:v12];

  int v6 = *(unsigned __int16 *)(a1 + 56);
  if (v6 == 3) {
    goto LABEL_13;
  }
  if (v6 != 4)
  {
    uint64_t v8 = *(void *)(*(void *)(a1 + 48) + 8);
    int v9 = 2;
    goto LABEL_8;
  }
  int v7 = *(unsigned __int16 *)(a1 + 58);
  if (v7 == 7)
  {
    uint64_t v8 = *(void *)(*(void *)(a1 + 48) + 8);
    int v9 = 4;
    goto LABEL_8;
  }
  if (v7 == 5)
  {
    uint64_t v8 = *(void *)(*(void *)(a1 + 48) + 8);
    int v9 = 3;
LABEL_8:
    *(_DWORD *)(v8 + 24) = v9;
    goto LABEL_14;
  }
  if (!*(_WORD *)(a1 + 60))
  {
LABEL_13:
    *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
  }
  else
  {
    if (v7 != 1) {
      int v7 = 2;
    }
    *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = v7;
  }
LABEL_14:
  uint64_t v10 = [*(id *)(a1 + 32) sharedState];
  id v11 = [v10 uniqueID];
  [v5 session:v11 didReceiveBlockedParticipantIDs:*(void *)(a1 + 40) withCode:*(unsigned int *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) withType:*(unsigned __int16 *)(a1 + 60) isTruncated:*(unsigned __int8 *)(a1 + 62)];
}

void sub_1000B5C98(uint64_t a1)
{
  id v9 = objc_alloc_init((Class)IMMessageContext);
  [v9 setShouldBoost:1];
  uint64_t v2 = +[IDSDaemon sharedInstance];
  uint64_t v3 = [*(id *)(a1 + 32) sharedState];
  uint64_t v4 = [v3 pushTopic];
  id v5 = [v2 broadcasterForTopic:v4 entitlement:kIDSSessionEntitlement command:0 messageContext:v9];

  *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 2 * (*(_WORD *)(a1 + 56) != 3);
  if (*(_WORD *)(a1 + 56) == 3)
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
  }
  else
  {
    if (*(_WORD *)(a1 + 58) == 5) {
      int v6 = 3;
    }
    else {
      int v6 = 2;
    }
    *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = v6;
  }
  int v7 = [*(id *)(a1 + 32) sharedState];
  uint64_t v8 = [v7 uniqueID];
  [v5 session:v8 didRemoveParticipantIDs:*(void *)(a1 + 40) withCode:*(unsigned int *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) isTruncated:*(unsigned __int8 *)(a1 + 60)];
}

void sub_1000B5E00(uint64_t a1)
{
  id v8 = objc_alloc_init((Class)IMMessageContext);
  [v8 setShouldBoost:1];
  uint64_t v2 = +[IDSDaemon sharedInstance];
  uint64_t v3 = [*(id *)(a1 + 32) sharedState];
  uint64_t v4 = [v3 pushTopic];
  id v5 = [v2 broadcasterForTopic:v4 entitlement:kIDSSessionEntitlement command:0 messageContext:v8];

  int v6 = [*(id *)(a1 + 32) sharedState];
  int v7 = [v6 uniqueID];
  [v5 sessionDidReceiveParticipantUpgrade:v7 participantType:*(unsigned __int16 *)(a1 + 48) error:*(void *)(a1 + 40)];
}

void sub_1000B5F04(uint64_t a1)
{
  id v8 = objc_alloc_init((Class)IMMessageContext);
  [v8 setShouldBoost:1];
  uint64_t v2 = +[IDSDaemon sharedInstance];
  uint64_t v3 = [*(id *)(a1 + 32) sharedState];
  uint64_t v4 = [v3 pushTopic];
  id v5 = [v2 broadcasterForTopic:v4 entitlement:kIDSSessionEntitlement command:0 messageContext:v8];

  int v6 = [*(id *)(a1 + 32) sharedState];
  int v7 = [v6 uniqueID];
  [v5 session:v7 didReceiveParticipantIDs:0 withCode:5 managementType:*(unsigned __int16 *)(a1 + 40)];
}

void sub_1000B6220(uint64_t a1)
{
  id v8 = objc_alloc_init((Class)IMMessageContext);
  [v8 setShouldBoost:1];
  uint64_t v2 = +[IDSDaemon sharedInstance];
  uint64_t v3 = [*(id *)(a1 + 32) sharedState];
  uint64_t v4 = [v3 pushTopic];
  id v5 = [v2 broadcasterForTopic:v4 entitlement:kIDSSessionEntitlement command:0 messageContext:v8];

  int v6 = [*(id *)(a1 + 32) sharedState];
  int v7 = [v6 uniqueID];
  [v5 participantUpdatedForSession:v7];
}

void sub_1000B65EC(uint64_t a1)
{
  id v8 = objc_alloc_init((Class)IMMessageContext);
  [v8 setShouldBoost:1];
  uint64_t v2 = +[IDSDaemon sharedInstance];
  uint64_t v3 = [*(id *)(a1 + 32) sharedState];
  uint64_t v4 = [v3 pushTopic];
  id v5 = [v2 broadcasterForTopic:v4 entitlement:kIDSSessionEntitlement command:0 messageContext:v8];

  int v6 = [*(id *)(a1 + 32) sharedState];
  int v7 = [v6 uniqueID];
  [v5 session:v7 didRegisterPluginAllocationInfo:*(void *)(a1 + 40)];
}

void sub_1000B6974(uint64_t a1)
{
  id v8 = objc_alloc_init((Class)IMMessageContext);
  [v8 setShouldBoost:1];
  uint64_t v2 = +[IDSDaemon sharedInstance];
  uint64_t v3 = [*(id *)(a1 + 32) sharedState];
  uint64_t v4 = [v3 pushTopic];
  id v5 = [v2 broadcasterForTopic:v4 entitlement:kIDSSessionEntitlement command:0 messageContext:v8];

  int v6 = [*(id *)(a1 + 32) sharedState];
  int v7 = [v6 uniqueID];
  [v5 session:v7 didUnregisterPluginAllocationInfo:*(void *)(a1 + 40)];
}

void sub_1000B6BBC(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4 = *(void **)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 40);
  id v6 = a3;
  objc_msgSend(v4, "link:didReceivePluginUnregistration:pluginName:", v5, objc_msgSend(a2, "unsignedLongLongValue"), v6);
}

void sub_1000B6DE4(uint64_t a1, void *a2, void *a3)
{
  id v7 = a2;
  id v5 = a3;
  id v6 = [*(id *)(a1 + 32) objectForKey:v5];

  if (!v6) {
    [*(id *)(a1 + 32) setObject:v5 forKey:v7];
  }
}

id sub_1000B7414(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [*(id *)(a1 + 32) _sendParticipantMappingUpdateToClient:a2 forLinkID:*(char *)(a1 + 40) shouldReplace:a3 == 0];
}

id sub_1000B7630(uint64_t a1)
{
  return [*(id *)(a1 + 32) endSessionWithReason:*(unsigned int *)(a1 + 40)];
}

id sub_1000B77B4(uint64_t a1)
{
  return [*(id *)(a1 + 32) receiveAndDecryptEncryptedDataBlobs:*(void *)(a1 + 40)];
}

void sub_1000B7930(uint64_t a1)
{
  id v8 = objc_alloc_init((Class)IMMessageContext);
  [v8 setShouldBoost:1];
  uint64_t v2 = +[IDSDaemon sharedInstance];
  uint64_t v3 = [*(id *)(a1 + 32) sharedState];
  uint64_t v4 = [v3 pushTopic];
  id v5 = [v2 broadcasterForTopic:v4 entitlement:kIDSSessionEntitlement command:0 messageContext:v8];

  id v6 = [*(id *)(a1 + 32) sharedState];
  id v7 = [v6 uniqueID];
  [v5 session:v7 didReceiveServerErrorCode:*(unsigned int *)(a1 + 40)];
}

id sub_1000B8590(uint64_t a1)
{
  return [*(id *)(a1 + 32) endSessionWithReason:43];
}

void sub_1000B8BC4(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  id v6 = im_primary_queue();
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_1000B8CE0;
  v10[3] = &unk_100981458;
  id v11 = *(id *)(a1 + 32);
  id v7 = *(id *)(a1 + 40);
  char v17 = a2;
  id v12 = v7;
  id v13 = v5;
  id v14 = *(id *)(a1 + 48);
  uint64_t v16 = *(void *)(a1 + 72);
  long long v15 = *(_OWORD *)(a1 + 56);
  id v8 = v5;
  dispatch_block_t v9 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS|DISPATCH_BLOCK_ASSIGN_CURRENT, QOS_CLASS_USER_INTERACTIVE, 0, v10);
  dispatch_async(v6, v9);
}

void sub_1000B8CE0(uint64_t a1)
{
  uint64_t v2 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void **)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 138412546;
    id v20 = v3;
    __int16 v21 = 2112;
    uint64_t v22 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "_processParticipantInfo: verified signature: %@ matchesPayload: %@", buf, 0x16u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v18 = *(void *)(a1 + 40);
      _IDSLogTransport();
      if (_IDSShouldLog())
      {
        uint64_t v16 = *(void *)(a1 + 32);
        uint64_t v18 = *(void *)(a1 + 40);
        _IDSLogV();
      }
    }
  }
  if (*(unsigned char *)(a1 + 88))
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    id v6 = (__CFArray *)objc_alloc_init((Class)NSMutableArray);
    id v7 = [objc_alloc((Class)NSMutableData) initWithData:*(void *)(a1 + 56)];
    [v7 appendBytes:a1 + 80 length:8];
    if (v6 && v7) {
      CFArrayAppendValue(v6, v7);
    }
    -[__CFDictionary setObject:forKey:](Mutable, "setObject:forKey:", v6, &off_1009D0E70, v16, v18);
    [*(id *)(*(void *)(a1 + 64) + 160) setObject:Mutable forKey:*(void *)(a1 + 72)];
    id v8 = [*(id *)(*(void *)(a1 + 64) + 152) objectForKeyedSubscript:*(void *)(a1 + 72)];
    if (v8)
    {
      uint64_t v10 = *(id **)(a1 + 64);
      dispatch_block_t v9 = (void *)(a1 + 64);
      id v11 = [v10[20] objectForKeyedSubscript:v9[1]];
      [v10 receiveAndDecryptEncryptedDataBlobs:v11];

      [*(id *)(*v9 + 160) setObject:0 forKeyedSubscript:v9[1]];
    }
    else
    {
      id v14 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        id v15 = [*(id *)(a1 + 72) unsignedLongLongValue];
        *(_DWORD *)buf = 134217984;
        id v20 = v15;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "_processParticipantInfo: have not received AVC Blob yet from participant: %llu!", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
      {
        id v17 = [*(id *)(a1 + 72) unsignedLongLongValue];
        _IDSLogTransport();
        if (_IDSShouldLog())
        {
          objc_msgSend(*(id *)(a1 + 72), "unsignedLongLongValue", v17);
          _IDSLogV();
        }
      }
    }
  }
  else
  {
    id v12 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      id v13 = *(void **)(a1 + 48);
      *(_DWORD *)buf = 138412290;
      id v20 = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "_processParticipantInfo: failed to verify signature with error: %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
  }
}

void sub_1000BA16C(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) sharedState];
  id v9 = [v2 pushTopic];

  id v3 = objc_alloc_init((Class)IMMessageContext);
  [v3 setShouldBoost:1];
  uint64_t v4 = +[IDSDaemon sharedInstance];
  id v5 = [v4 broadcasterForTopic:v9 entitlement:kIDSSessionEntitlement command:0 messageContext:v3];

  id v6 = [*(id *)(a1 + 32) sharedState];
  id v7 = [v6 uniqueID];
  id v8 = +[NSArray array];
  [v5 session:v7 didReceiveActiveParticipants:v8 success:0];
}

void sub_1000BA284(uint64_t a1)
{
  uint64_t v2 = +[IDSGroupEncryptionController sharedInstance];
  id v3 = [*(id *)(a1 + 32) sharedState];
  uint64_t v4 = [v3 groupID];
  id v5 = [*(id *)(a1 + 32) sharedState];
  id v6 = [v5 uniqueID];
  [v2 didUpdateParticipants:&__NSArray0__struct ofType:0 forGroup:v4 sessionID:v6];

  id v7 = [*(id *)(a1 + 32) sharedState];
  id v13 = [v7 pushTopic];

  id v8 = objc_alloc_init((Class)IMMessageContext);
  [v8 setShouldBoost:1];
  id v9 = +[IDSDaemon sharedInstance];
  uint64_t v10 = [v9 broadcasterForTopic:v13 entitlement:kIDSSessionEntitlement command:0 messageContext:v8];

  id v11 = [*(id *)(a1 + 32) sharedState];
  id v12 = [v11 uniqueID];
  [v10 session:v12 didReceiveActiveParticipants:&__NSArray0__struct success:1];
}

void sub_1000BA40C(uint64_t a1)
{
  uint64_t v2 = +[IDSGroupEncryptionController sharedInstance];
  id v3 = [*(id *)(a1 + 32) sharedState];
  uint64_t v4 = [v3 groupID];
  id v5 = [*(id *)(a1 + 32) sharedState];
  id v6 = [v5 uniqueID];
  [v2 didUpdateParticipants:&__NSArray0__struct ofType:1 forGroup:v4 sessionID:v6];

  id v7 = [*(id *)(a1 + 32) sharedState];
  id v13 = [v7 pushTopic];

  id v8 = objc_alloc_init((Class)IMMessageContext);
  [v8 setShouldBoost:1];
  id v9 = +[IDSDaemon sharedInstance];
  uint64_t v10 = [v9 broadcasterForTopic:v13 entitlement:kIDSSessionEntitlement command:0 messageContext:v8];

  id v11 = [*(id *)(a1 + 32) sharedState];
  id v12 = [v11 uniqueID];
  [v10 session:v12 didReceiveActiveLightweightParticipants:&__NSArray0__struct success:1];
}

id sub_1000BC534(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = a2;
  uint64_t v4 = [v2 sharedState];
  id v5 = [v4 serviceName];
  id v6 = +[IDSURI URIWithPrefixedURI:v3 withServiceLoggingHint:v5];

  return v6;
}

void sub_1000BC5C0(uint64_t a1)
{
  uint64_t v2 = im_primary_queue();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000BC750;
  block[3] = &unk_100981368;
  char v13 = *(unsigned char *)(a1 + 64);
  id v3 = *(void **)(a1 + 40);
  void block[4] = *(void *)(a1 + 32);
  __int16 v14 = *(_WORD *)(a1 + 65);
  id v12 = v3;
  dispatch_block_t v4 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS|DISPATCH_BLOCK_ASSIGN_CURRENT, QOS_CLASS_USER_INITIATED, 0, block);
  dispatch_async(v2, v4);

  if (*(unsigned char *)(a1 + 65))
  {
    id v5 = im_primary_queue();
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    v7[2] = sub_1000BCC9C;
    v7[3] = &unk_1009814A8;
    void v7[4] = *(void *)(a1 + 32);
    id v8 = *(id *)(a1 + 48);
    id v9 = *(id *)(a1 + 56);
    char v10 = *(unsigned char *)(a1 + 66);
    dispatch_block_t v6 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS|DISPATCH_BLOCK_ASSIGN_CURRENT, QOS_CLASS_USER_INITIATED, 0, v7);
    dispatch_async(v5, v6);
  }
}

void sub_1000BC750(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 48);
  id v3 = +[IDSFoundationLog IDSDSession];
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      id v5 = [*(id *)(a1 + 32) sharedState];
      uint64_t v6 = [v5 groupID];
      id v7 = (void *)v6;
      CFStringRef v8 = @"YES";
      if (!*(unsigned char *)(a1 + 49)) {
        CFStringRef v8 = @"NO";
      }
      *(_DWORD *)buf = 138412546;
      uint64_t v29 = v6;
      __int16 v30 = 2112;
      CFStringRef v31 = v8;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "updateMembers: Resetting keys & sending membership change to AVC for group %@, triggeredLocally: %@", buf, 0x16u);
    }
    id v9 = *(void **)(a1 + 32);
    uint64_t v10 = *(unsigned __int8 *)(a1 + 50);
    v25[0] = _NSConcreteStackBlock;
    v25[1] = 3221225472;
    v25[2] = sub_1000BCA60;
    v25[3] = &unk_1009802F0;
    v25[4] = v9;
    char v27 = *(unsigned char *)(a1 + 48);
    id v26 = *(id *)(a1 + 40);
    [v9 recvMembershipChangeEventWithReason:v10 completionHandler:v25];
    [*(id *)(*(void *)(a1 + 32) + 896) membershipChange];
  }
  else
  {
    if (v4)
    {
      id v11 = [*(id *)(a1 + 32) sharedState];
      uint64_t v12 = [v11 groupID];
      char v13 = (void *)v12;
      CFStringRef v14 = @"YES";
      if (!*(unsigned char *)(a1 + 49)) {
        CFStringRef v14 = @"NO";
      }
      *(_DWORD *)buf = 138412546;
      uint64_t v29 = v12;
      __int16 v30 = 2112;
      CFStringRef v31 = v14;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "updateMembers: No need to reset keys for group %@, triggeredLocally: %@", buf, 0x16u);
    }
    __int16 v24 = +[IDSGroupEncryptionController sharedInstance];
    id v15 = [*(id *)(a1 + 32) sharedState];
    uint64_t v16 = [v15 destinations];
    id v17 = [v16 allObjects];
    uint64_t v18 = [*(id *)(a1 + 32) sharedState];
    uint64_t v19 = [v18 groupID];
    id v20 = [*(id *)(a1 + 32) sharedState];
    __int16 v21 = [v20 uniqueID];
    uint64_t v22 = [*(id *)(a1 + 32) sharedState];
    id v23 = [v22 destinationsLightweightStatus];
    [v24 didUpdateMembers:v17 forGroup:v19 sessionID:v21 lightweightStatusDict:v23 hasChangedStandardMembers:*(unsigned __int8 *)(a1 + 48) newlyAddedMembers:*(void *)(a1 + 40)];
  }
}

void sub_1000BCA60(uint64_t a1)
{
  int v2 = im_primary_queue();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000BCB24;
  block[3] = &unk_1009802F0;
  id v3 = *(void **)(a1 + 40);
  void block[4] = *(void *)(a1 + 32);
  char v7 = *(unsigned char *)(a1 + 48);
  id v6 = v3;
  dispatch_block_t v4 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS|DISPATCH_BLOCK_ASSIGN_CURRENT, QOS_CLASS_USER_INITIATED, 0, block);
  dispatch_async(v2, v4);
}

void sub_1000BCB24(uint64_t a1)
{
  int v2 = +[IDSGroupEncryptionController sharedInstance];
  id v3 = [*(id *)(a1 + 32) sharedState];
  dispatch_block_t v4 = [v3 groupID];
  [v2 resetKeysForGroup:v4 shouldRemoveCurrentParticipants:0];

  id v14 = +[IDSGroupEncryptionController sharedInstance];
  id v5 = [*(id *)(a1 + 32) sharedState];
  id v6 = [v5 destinations];
  char v7 = [v6 allObjects];
  CFStringRef v8 = [*(id *)(a1 + 32) sharedState];
  id v9 = [v8 groupID];
  uint64_t v10 = [*(id *)(a1 + 32) sharedState];
  id v11 = [v10 uniqueID];
  uint64_t v12 = [*(id *)(a1 + 32) sharedState];
  char v13 = [v12 destinationsLightweightStatus];
  [v14 didUpdateMembers:v7 forGroup:v9 sessionID:v11 lightweightStatusDict:v13 hasChangedStandardMembers:*(unsigned __int8 *)(a1 + 48) newlyAddedMembers:*(void *)(a1 + 40)];
}

void sub_1000BCC9C(uint64_t a1)
{
  int v2 = +[IDSFoundationLog IDSDSession];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "updateMembers: Informing remote participants of membership change via push.", buf, 2u);
  }

  uint64_t v19 = [*(id *)(a1 + 32) groupStatusNotificationController];
  uint64_t v22 = [*(id *)(a1 + 32) sharedState];
  __int16 v21 = [v22 destinations];
  id v17 = [v21 allObjects];
  id v20 = [*(id *)(a1 + 32) sharedState];
  id v15 = [v20 groupID];
  uint64_t v16 = *(void *)(a1 + 40);
  id v3 = *(void **)(a1 + 32);
  uint64_t v14 = v3[23];
  uint64_t v18 = [v3 accountController];
  dispatch_block_t v4 = [*(id *)(a1 + 32) sharedState];
  id v5 = [v4 accountID];
  id v6 = [v18 accountWithUniqueID:v5];
  char v7 = [*(id *)(a1 + 32) sharedState];
  CFStringRef v8 = [v7 fromURI];
  id v9 = [*(id *)(a1 + 32) sharedState];
  uint64_t v10 = [v9 uniqueID];
  uint64_t v11 = *(void *)(a1 + 48);
  char v12 = *(unsigned char *)(a1 + 56);
  BYTE1(v13) = [*(id *)(a1 + 32) shouldReportUPlusOneKey];
  LOBYTE(v13) = v12;
  objc_msgSend(v19, "updateMembers:toGroup:withContext:params:fromAccount:fromURI:sessionID:messagingCapabilities:reason:isUPlusOne:completionBlock:", v17, v15, v16, v14, v6, v8, v10, v11, v13, 0);
}

void sub_1000BCE98(uint64_t a1)
{
  id v15 = [*(id *)(a1 + 32) groupStatusNotificationController];
  uint64_t v14 = [*(id *)(a1 + 32) sharedState];
  uint64_t v13 = [v14 destinations];
  uint64_t v11 = [v13 allObjects];
  char v12 = [*(id *)(a1 + 32) sharedState];
  int v2 = [v12 groupID];
  id v3 = [*(id *)(a1 + 32) sharedState];
  dispatch_block_t v4 = [v3 uniqueID];
  id v5 = [*(id *)(a1 + 32) sharedState];
  id v6 = [v5 fromURI];
  char v7 = [*(id *)(a1 + 32) accountController];
  CFStringRef v8 = [*(id *)(a1 + 32) sharedState];
  id v9 = [v8 accountID];
  uint64_t v10 = [v7 accountWithUniqueID:v9];
  [v15 pushTokenLookup:v11 forGroup:v2 sessionID:v4 fromURI:v6 account:v10 completionBlock:*(void *)(a1 + 40)];
}

void sub_1000BD278(uint64_t a1)
{
  id v4 = [*(id *)(a1 + 32) utunController];
  int v2 = [*(id *)(a1 + 32) sharedState];
  id v3 = [v2 uniqueID];
  objc_msgSend(v4, "onTransportThread_manageDesignatedDestinationsWithSessionID:destinations:withType:sessionStateCounter:", v3, *(void *)(a1 + 40), *(unsigned __int16 *)(a1 + 48), *(unsigned int *)(*(void *)(a1 + 32) + 628));
}

void sub_1000BD530(uint64_t a1)
{
  id v4 = [*(id *)(a1 + 32) utunController];
  int v2 = [*(id *)(a1 + 32) sharedState];
  id v3 = [v2 uniqueID];
  objc_msgSend(v4, "onTransportThread_removeParticipantIDsWithSessionID:participantIDs:sessionStateCounter:", v3, *(void *)(a1 + 40), *(unsigned int *)(*(void *)(a1 + 32) + 628));
}

void sub_1000BD730(uint64_t a1)
{
  [*(id *)(*(void *)(a1 + 32) + 184) setParticipantData:*(void *)(a1 + 40)];
  id v19 = [*(id *)(a1 + 32) groupStatusNotificationController];
  uint64_t v18 = [*(id *)(a1 + 32) sharedState];
  id v17 = [v18 destinations];
  id v15 = [v17 allObjects];
  uint64_t v16 = [*(id *)(a1 + 32) sharedState];
  int v2 = [v16 groupID];
  id v3 = *(void **)(a1 + 32);
  uint64_t v13 = v3[23];
  uint64_t v14 = *(void *)(a1 + 48);
  id v4 = [v3 accountController];
  id v5 = [*(id *)(a1 + 32) sharedState];
  id v6 = [v5 accountID];
  char v7 = [v4 accountWithUniqueID:v6];
  CFStringRef v8 = [*(id *)(a1 + 32) sharedState];
  id v9 = [v8 fromURI];
  uint64_t v10 = [*(id *)(a1 + 32) sharedState];
  uint64_t v11 = [v10 uniqueID];
  LOBYTE(v12) = [*(id *)(a1 + 32) shouldReportUPlusOneKey];
  [v19 updateParticipantDataToMembers:v15 toGroup:v2 withContext:v14 params:v13 fromAccount:v7 fromURI:v9 sessionID:v11 isUPlusOne:v12];
}

void sub_1000BE088(uint64_t a1)
{
  id v10 = +[IDSGroupEncryptionController sharedInstance];
  int v2 = [*(id *)(a1 + 32) sharedState];
  id v3 = [v2 destinationsLightweightStatus];
  uint64_t v4 = *(unsigned __int8 *)(a1 + 48);
  uint64_t v5 = *(void *)(a1 + 40);
  id v6 = [*(id *)(a1 + 32) sharedState];
  char v7 = [v6 groupID];
  CFStringRef v8 = [*(id *)(a1 + 32) sharedState];
  id v9 = [v8 uniqueID];
  [v10 updateLightweightMemberTypes:v3 members:v5 triggeredLocally:v4 forGroup:v7 sessionID:v9];
}

void sub_1000BE17C(uint64_t a1)
{
  int v2 = +[IDSGroupEncryptionController sharedInstance];
  id v3 = [*(id *)(a1 + 32) sharedState];
  uint64_t v4 = [v3 destinationsLightweightStatus];
  uint64_t v5 = *(unsigned __int8 *)(a1 + 50);
  uint64_t v6 = *(void *)(a1 + 40);
  char v7 = [*(id *)(a1 + 32) sharedState];
  CFStringRef v8 = [v7 groupID];
  id v9 = [*(id *)(a1 + 32) sharedState];
  id v10 = [v9 uniqueID];
  [v2 updateLightweightMemberTypes:v4 members:v6 triggeredLocally:v5 forGroup:v8 sessionID:v10];

  if (*(_WORD *)(a1 + 48) == 1)
  {
    id v15 = +[IDSGroupEncryptionController sharedInstance];
    uint64_t v11 = [*(id *)(a1 + 32) sharedState];
    uint64_t v12 = [v11 groupID];
    uint64_t v13 = [*(id *)(a1 + 32) sharedState];
    uint64_t v14 = [v13 uniqueID];
    [v15 reliablyRequestKeyMaterialForGroup:v12 sessionID:v14];
  }
}

void sub_1000BE314(uint64_t a1)
{
  id v5 = [*(id *)(a1 + 32) utunController];
  uint64_t v2 = *(unsigned __int16 *)(a1 + 40);
  id v3 = [*(id *)(a1 + 32) sharedState];
  uint64_t v4 = [v3 uniqueID];
  objc_msgSend(v5, "onTransportThread_updateParticipantType:forSessionID:sessionStateCounter:", v2, v4, *(unsigned int *)(*(void *)(a1 + 32) + 628));
}

void sub_1000BE3A8(uint64_t a1)
{
  id v8 = objc_alloc_init((Class)IMMessageContext);
  [v8 setShouldBoost:1];
  uint64_t v2 = +[IDSDaemon sharedInstance];
  id v3 = [*(id *)(a1 + 32) sharedState];
  uint64_t v4 = [v3 pushTopic];
  id v5 = [v2 broadcasterForTopic:v4 entitlement:kIDSSessionEntitlement command:0 messageContext:v8];

  uint64_t v6 = [*(id *)(a1 + 32) sharedState];
  char v7 = [v6 uniqueID];
  [v5 sessionDidReceiveParticipantUpgrade:v7 participantType:*(unsigned __int16 *)(a1 + 40) error:0];
}

void sub_1000BE518(uint64_t a1)
{
  id v4 = [*(id *)(a1 + 32) utunController];
  uint64_t v2 = [*(id *)(a1 + 32) sharedState];
  id v3 = [v2 uniqueID];
  objc_msgSend(v4, "onTransportThread_sendConnectedLinkInfoToAVCForSessionID:", v3);
}

void sub_1000C0ACC(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    [v2 setReply:1];
    id v3 = +[IDSDaemon sharedInstance];
    id v4 = [*(id *)(a1 + 32) localObject];
    id v5 = [v3 broadcasterForLocalObject:v4 messageContext:*(void *)(a1 + 32)];

    [v5 emptyXPCReply];
  }
}

void sub_1000C0E84(_Unwind_Exception *a1)
{
  objc_destroyWeak((id *)(v1 - 64));
  _Unwind_Resume(a1);
}

void sub_1000C0EC0(uint64_t a1)
{
  id v4 = [*(id *)(a1 + 32) utunController];
  uint64_t v2 = [*(id *)(a1 + 32) sharedState];
  id v3 = [v2 uniqueID];
  objc_msgSend(v4, "onTransportThread_receiveJoinNotificationFromAParticipant:", v3);
}

void sub_1000C0F3C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v2 = WeakRetained;
    [WeakRetained reinitiate];
    id WeakRetained = v2;
  }
}

void sub_1000C1344(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      id v33 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "disconnectGlobalLink during leaving group session failed: %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        id v30 = v3;
        _IDSLogTransport();
        if (_IDSShouldLog())
        {
          id v30 = v3;
          _IDSLogV();
        }
      }
    }
  }
  id v5 = objc_msgSend(*(id *)(a1 + 32), "utunController", v30);
  uint64_t v6 = [*(id *)(a1 + 32) sharedState];
  char v7 = [v6 uniqueID];
  [v5 stopGlobalLinkForDevice:v7];

  id v8 = [*(id *)(a1 + 32) sharedState];
  [v8 setState:7];

  id v9 = [*(id *)(a1 + 32) sharedState];
  id v10 = [v9 groupID];

  if (v10)
  {
    uint64_t v11 = im_primary_queue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000C1810;
    block[3] = &unk_10097E4D0;
    void block[4] = *(void *)(a1 + 32);
    dispatch_block_t v12 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS|DISPATCH_BLOCK_ASSIGN_CURRENT, QOS_CLASS_USER_INITIATED, 0, block);
    dispatch_async(v11, v12);
  }
  else
  {
    uint64_t v13 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Cannot fan out the leave notification to the group, no groupID!", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
  }
  uint64_t v14 = +[IDSGroupEncryptionController sharedInstance];
  id v15 = [*(id *)(a1 + 32) sharedState];
  uint64_t v16 = [v15 groupID];
  [v14 removeLocalActiveParticipantForGroup:v16];

  id v17 = *(_DWORD **)(a1 + 32);
  if (v17[44] <= 1u)
  {
    id v18 = objc_alloc_init((Class)IMMessageContext);
    [v18 setShouldBoost:1];
    id v19 = +[IDSDaemon sharedInstance];
    id v20 = [*(id *)(a1 + 32) sharedState];
    __int16 v21 = [v20 pushTopic];
    uint64_t v22 = [v19 broadcasterForTopic:v21 entitlement:kIDSSessionEntitlement command:0 messageContext:v18];

    id v23 = +[IDSFoundationLog IDSDSession];
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v24 = [*(id *)(a1 + 32) sharedState];
      id v25 = [v24 uniqueID];
      *(_DWORD *)buf = 138412290;
      id v33 = v25;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Broadcasting did leave group session: %@", buf, 0xCu);
    }
    char v27 = *(void **)(a1 + 32);
    id v26 = (id *)(a1 + 32);
    __int16 v28 = [v27 sharedState];
    uint64_t v29 = [v28 uniqueID];
    [v22 sessionDidLeaveGroup:v29 error:v3];

    [*v26 _reportRTC];
    id v17 = *v26;
  }
  v17[44] = 2;
}

void sub_1000C1810(uint64_t a1)
{
  id v18 = [*(id *)(a1 + 32) groupStatusNotificationController];
  id v17 = [*(id *)(a1 + 32) sharedState];
  uint64_t v14 = [v17 groupID];
  uint64_t v16 = [*(id *)(a1 + 32) sharedState];
  id v15 = [v16 destinations];
  id v2 = [v15 allObjects];
  id v3 = *(void **)(a1 + 32);
  uint64_t v13 = v3[23];
  id v4 = [v3 accountController];
  id v5 = [*(id *)(a1 + 32) sharedState];
  uint64_t v6 = [v5 accountID];
  char v7 = [v4 accountWithUniqueID:v6];
  id v8 = [*(id *)(a1 + 32) sharedState];
  id v9 = [v8 fromURI];
  id v10 = [*(id *)(a1 + 32) sharedState];
  uint64_t v11 = [v10 uniqueID];
  LOBYTE(v12) = [*(id *)(a1 + 32) shouldReportUPlusOneKey];
  [v18 notifyLeaveToGroup:v14 members:v2 params:v13 fromAccount:v7 fromURI:v9 sessionID:v11 isUPlusOne:v12];
}

void sub_1000C19AC(uint64_t a1)
{
  id v4 = +[IDSGroupEncryptionController sharedInstance];
  id v2 = [*(id *)(a1 + 32) sharedState];
  id v3 = [v2 groupID];
  [v4 reportPrekeyAckStatus:v3];
}

void sub_1000C1FF8(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1000C1B5CLL);
  }
  _Unwind_Resume(a1);
}

void sub_1000C202C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    id v6 = [v3 idsResponseCode];
    id v7 = [v3 responseError];
    unsigned int v8 = [v3 lastCall];
    CFStringRef v9 = @"NO";
    *(_DWORD *)buf = 138413058;
    uint64_t v17 = v5;
    __int16 v18 = 2048;
    if (v8) {
      CFStringRef v9 = @"YES";
    }
    id v19 = v6;
    __int16 v20 = 2112;
    id v21 = v7;
    __int16 v22 = 2112;
    CFStringRef v23 = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Message %@ got response code %lu error %@ lastCall %@", buf, 0x2Au);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
  {
    uint64_t v10 = *(void *)(a1 + 32);
    id v11 = [v3 idsResponseCode];
    uint64_t v12 = [v3 responseError];
    if ([v3 lastCall]) {
      CFStringRef v13 = @"YES";
    }
    else {
      CFStringRef v13 = @"NO";
    }
    CFStringRef v15 = v13;
    _IDSLogTransport();

    if (_IDSShouldLog())
    {
      objc_msgSend(v3, "idsResponseCode", v10, v11, v12, v15);
      uint64_t v14 = [v3 responseError];
      [v3 lastCall];
      _IDSLogV();
    }
  }
}

void sub_1000C2348(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) utunController];
  id v3 = [*(id *)(a1 + 32) sharedState];
  id v4 = [v3 uniqueID];
  uint64_t v5 = [*(id *)(a1 + 32) sharedState];
  id v6 = [v5 groupID];
  uint64_t v7 = *(void *)(a1 + 40);
  unsigned int v8 = [*(id *)(a1 + 48) destinationURIs];
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  v9[2] = sub_1000C246C;
  v9[3] = &unk_100981598;
  id v10 = *(id *)(a1 + 56);
  objc_msgSend(v2, "onTransportThread_SendKeyMaterialMessage:relayGroupID:keyMaterialMessageData:destinationURIs:completionHandler:", v4, v6, v7, v8, v9);
}

void sub_1000C246C(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    int v2 = a2;
    id v3 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v11 = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "sendKeyMaterialData failed with error: %d", buf, 8u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
    {
      _IDSLogTransport();
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
  }
  else if (*(void *)(a1 + 32))
  {
    uint64_t v5 = im_primary_queue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000C2648;
    block[3] = &unk_100981570;
    id v8 = *(id *)(a1 + 32);
    uint64_t v9 = 0;
    dispatch_block_t v6 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS|DISPATCH_BLOCK_ASSIGN_CURRENT, QOS_CLASS_USER_INITIATED, 0, block);
    dispatch_async(v5, v6);
  }
}

uint64_t sub_1000C2648(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40));
}

void sub_1000C2EDC(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) utunController];
  objc_msgSend(v2, "onTransportThread_setServerDesiredMaterialsForSession:materials:signer:", *(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56));
}

id sub_1000C3290(uint64_t a1)
{
  return _[*(id *)(a1 + 32) link:*(void *)(a1 + 32) didReceiveEncryptionInformation:*(void *)(a1 + 40)];
}

void sub_1000C35A4(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)IMMessageContext);
  [v2 setShouldBoost:1];
  id v3 = +[IDSDaemon sharedInstance];
  id v4 = [*(id *)(a1 + 32) sharedState];
  uint64_t v5 = [v4 pushTopic];
  dispatch_block_t v6 = [v3 broadcasterForTopic:v5 entitlement:kIDSSessionEntitlement command:0 messageContext:v2];

  uint64_t v8 = a1 + 56;
  int v7 = *(_DWORD *)(a1 + 56);
  if (v7 == 6)
  {
    uint64_t v16 = *(void **)(*(void *)(a1 + 32) + 896);
    uint64_t v17 = [*(id *)(a1 + 40) participantPushToken];
    __int16 v18 = [v16 joinCycleForToken:v17];
    [v18 decryptedBlobOverQUIC:@"mirage-blob"];

    uint64_t v12 = [*(id *)(a1 + 32) sharedState];
    CFStringRef v13 = [v12 uniqueID];
    uint64_t v19 = *(void *)(a1 + 48);
    CFStringRef v15 = [*(id *)(a1 + 40) dictionaryRepresentation];
    [v6 session:v13 didReceiveData:v19 dataType:1 forParticipant:v15];
    goto LABEL_5;
  }
  if (v7 == 12)
  {
    uint64_t v9 = *(void **)(*(void *)(a1 + 32) + 896);
    id v10 = [*(id *)(a1 + 40) participantPushToken];
    int v11 = [v9 joinCycleForToken:v10];
    [v11 decryptedBlobOverQUIC:@"avc"];

    uint64_t v12 = [*(id *)(a1 + 32) sharedState];
    CFStringRef v13 = [v12 uniqueID];
    uint64_t v14 = *(void *)(a1 + 48);
    CFStringRef v15 = [*(id *)(a1 + 40) dictionaryRepresentation];
    [v6 session:v13 didReceiveDataBlob:v14 forParticipant:v15];
LABEL_5:

    goto LABEL_9;
  }
  __int16 v20 = +[IDSFoundationLog IDSDSession];
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
    sub_10070E8B8(v8, v20, v21, v22, v23, v24, v25, v26);
  }

LABEL_9:
}

void sub_1000C38A4(uint64_t a1)
{
  id v8 = objc_alloc_init((Class)IMMessageContext);
  [v8 setShouldBoost:1];
  id v2 = +[IDSDaemon sharedInstance];
  id v3 = [*(id *)(a1 + 32) sharedState];
  id v4 = [v3 pushTopic];
  uint64_t v5 = [v2 broadcasterForTopic:v4 entitlement:kIDSSessionEntitlement command:0 messageContext:v8];

  dispatch_block_t v6 = [*(id *)(a1 + 32) sharedState];
  int v7 = [v6 uniqueID];
  objc_msgSend(v5, "session:didReceiveJoinedParticipantID:withContext:", v7, objc_msgSend(*(id *)(a1 + 40), "unsignedLongLongValue"), *(void *)(a1 + 48));
}

id sub_1000C3F64(uint64_t a1)
{
  return [*(id *)(a1 + 32) _decryptReceivedDataBlobsUsingSKMs];
}

void sub_1000C44A0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  int v7 = objc_msgSend(v6, "subdataWithRange:", (char *)objc_msgSend(v6, "length") - 8, 8);
  if ([*(id *)(a1 + 32) intValue] == 7)
  {
    if ((unint64_t)[v7 length] <= 7)
    {
      id v8 = +[IDSFoundationLog IDSDSession];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_10070E928();
      }
      goto LABEL_32;
    }
    [v7 bytes];
    uint64_t v9 = objc_msgSend(v6, "subdataWithRange:", 0, (char *)objc_msgSend(v6, "length") - 8);
    id v10 = [v9 copy];

    id v6 = v10;
  }
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 40) + 824));
  int v11 = *(void **)(*(void *)(a1 + 40) + 656);
  id v28 = 0;
  uint64_t v12 = [v11 decryptData:v6 keyID:v5 sequenceNumber:0 error:&v28];
  id v8 = v28;
  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 40) + 824));
  if (v8)
  {
    id v13 = [v8 code];
    uint64_t v14 = +[IDSFoundationLog IDSDSession];
    CFMutableDictionaryRef Mutable = v14;
    if (v13 == (id)1)
    {
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        id v30 = v5;
        _os_log_impl((void *)&_mh_execute_header, Mutable, OS_LOG_TYPE_DEFAULT, "_decryptReceivedDataBlobsUsingSKMs: haven't got keyID: %@", buf, 0xCu);
      }
    }
    else
    {
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        int v26 = *(_DWORD *)(a1 + 64);
        *(_DWORD *)buf = 138412802;
        id v30 = v6;
        __int16 v31 = 1024;
        *(_DWORD *)id v32 = v26;
        *(_WORD *)&v32[4] = 2112;
        *(void *)&v32[6] = v8;
        _os_log_error_impl((void *)&_mh_execute_header, Mutable, OS_LOG_TYPE_ERROR, "_decryptReceivedDataBlobsUsingSKMs: couldn't decrypt data blob: %@, encryptedDataType: %d error: %@", buf, 0x1Cu);
      }

      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      [Mutable setObject:&off_1009D0F30 forKeyedSubscript:IDSDSessionReportTransportTypeKey];
      uint64_t v22 = +[NSNumber numberWithInteger:[v8 code]];
      [Mutable setObject:v22 forKeyedSubscript:IDSDSessionReportResultCodeKey];

      [Mutable setObject:*(void *)(a1 + 32) forKeyedSubscript:IDSDSessionReportDataBlobTypeKey];
      [*(id *)(a1 + 40) addQREventForRTCReport:Mutable];
    }
  }
  else
  {
    os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 40) + 824));
    CFDictionaryRef Value = 0;
    if (v5 && *(void *)(*(void *)(a1 + 40) + 696)) {
      CFDictionaryRef Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 40) + 696), v5);
    }
    CFMutableDictionaryRef Mutable = Value;
    uint64_t v17 = +[IDSFoundationLog IDSDSession];
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      int v18 = *(_DWORD *)(a1 + 64);
      *(_DWORD *)buf = 138413058;
      id v30 = v12;
      __int16 v31 = 2112;
      *(void *)id v32 = v5;
      *(_WORD *)&v32[8] = 2112;
      *(void *)&v32[10] = Mutable;
      __int16 v33 = 1024;
      int v34 = v18;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "_decryptReceivedDataBlobsUsingSKMs: decryptedBlob: %@, keyID: %@, participantID: %@, type: %d", buf, 0x26u);
    }

    os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 40) + 824));
    if (Mutable)
    {
      uint64_t v19 = [*(id *)(a1 + 40) _getURIFromParticipantIDNumber:Mutable];
      if (v19)
      {
        if ([*(id *)(a1 + 32) intValue] == 7)
        {
          id v20 = [objc_alloc((Class)NSMutableData) initWithData:v7];
          [v20 appendData:v12];
          id v21 = [v20 copy];

          uint64_t v12 = v21;
        }
        if (v12) {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 48), Mutable, v12);
        }
        [*(id *)(a1 + 56) addObject:v5];
      }
      else
      {
        uint64_t v23 = +[IDSFoundationLog IDSDSession];
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          id v27 = [Mutable unsignedLongLongValue];
          uint64_t v24 = [*(id *)(a1 + 40) sharedState];
          uint64_t v25 = [v24 groupID];
          *(_DWORD *)buf = 134218242;
          id v30 = v27;
          __int16 v31 = 2112;
          *(void *)id v32 = v25;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "_decryptReceivedDataBlobsUsingSKMs: no valid URI for participantID: %llu, group: %@, not consuming", buf, 0x16u);
        }
      }
    }
    else
    {
      uint64_t v19 = +[IDSFoundationLog IDSDSession];
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_10070E95C();
      }
    }
  }
LABEL_32:
}

void sub_1000C49B0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  int v7 = (id *)(a1 + 32);
  id v8 = [*(id *)(a1 + 32) _getPushTokenFromParticipantIDNumber:v5];
  if (!v8)
  {
    uint64_t v9 = +[IDSFoundationLog IDSDSession];
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      id v10 = [v5 unsignedLongLongValue];
      int v11 = [*v7 sharedState];
      uint64_t v12 = [v11 groupID];
      *(_DWORD *)buf = 134218242;
      id v32 = v10;
      __int16 v33 = 2112;
      id v34 = v12;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "warning: _decryptReceivedDataBlobsUsingSKMs: couldn't find push token for participantID: %llu, group: %@", buf, 0x16u);
    }
  }
  id v13 = [*v7 _getURIFromParticipantIDNumber:v5];
  if (v13)
  {
    if ([*(id *)(a1 + 40) intValue] != 7)
    {
      id v15 = objc_alloc((Class)NSUUID);
      uint64_t v16 = [*v7 sharedState];
      uint64_t v17 = [v16 groupID];
      uint64_t v14 = [v15 initWithUUIDString:v17];

      id v18 = objc_msgSend(objc_alloc((Class)IDSGroupSessionActiveParticipant), "initWithGroupUUID:participantIdentifier:isKnown:participantURI:pushToken:", v14, objc_msgSend(v5, "unsignedLongLongValue"), 1, v13, v8);
      uint64_t v19 = +[IDSFoundationLog IDSDSession];
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        int v20 = *(_DWORD *)(a1 + 48);
        *(_DWORD *)buf = 138413058;
        id v32 = v6;
        __int16 v33 = 2112;
        id v34 = v5;
        __int16 v35 = 2112;
        uint64_t v36 = v13;
        __int16 v37 = 1024;
        int v38 = v20;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "_decryptReceivedDataBlobsUsingSKMs: sending blob to client: %@, participantID: %@, URI: %@, type: %d", buf, 0x26u);
      }

      [*(id *)(a1 + 32) _sendClientDecryptedDatabBlobs:v6 type:*(unsigned int *)(a1 + 48) forParticipant:v18];
      id v21 = im_primary_queue();
      v27[0] = _NSConcreteStackBlock;
      v27[1] = 3221225472;
      v27[2] = sub_1000C4E68;
      v27[3] = &unk_10097E5A8;
      int8x16_t v28 = vextq_s8(*(int8x16_t *)(a1 + 32), *(int8x16_t *)(a1 + 32), 8uLL);
      id v29 = v5;
      id v6 = v6;
      id v30 = v6;
      dispatch_block_t v22 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS|DISPATCH_BLOCK_ASSIGN_CURRENT, QOS_CLASS_USER_INTERACTIVE, 0, v27);
      dispatch_async(v21, v22);

      goto LABEL_15;
    }
    if ((unint64_t)[v6 length] <= 7)
    {
      uint64_t v14 = +[IDSFoundationLog IDSDSession];
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_10070E928();
      }
      goto LABEL_16;
    }
    id v23 = v6;
    uint64_t v24 = *(void *)[v23 bytes];
    objc_msgSend(v23, "subdataWithRange:", 8, (char *)objc_msgSend(v23, "length") - 8);
    id v6 = (id)objc_claimAutoreleasedReturnValue();

    if ((unint64_t)[v6 length] <= 7)
    {
      uint64_t v14 = +[IDSFoundationLog IDSDSession];
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_10070EA90();
      }
      goto LABEL_16;
    }
    id v6 = v6;
    double v25 = *(double *)[v6 bytes];
    uint64_t v14 = objc_msgSend(v6, "subdataWithRange:", 8, (char *)objc_msgSend(v6, "length") - 8);
    if ([*v7 shouldReportToClient:v5 timeStamp:v24 type:v25])
    {
      if (v24 == 2)
      {
        [*v7 _sendRemoteParticipantInfoEventToClient:v14 forParticipant:v5];
        goto LABEL_16;
      }
      if (v24 == 1)
      {
        id v26 = *v7;
        id v18 = [*((id *)*v7 + 19) objectForKeyedSubscript:v5];
        [v26 _sendRemoteParticipantInfoEventToClient:v18 forParticipant:v5];
LABEL_15:
      }
    }
  }
  else
  {
    uint64_t v14 = +[IDSFoundationLog IDSDSession];
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      sub_10070E9C4(v5, (id *)(a1 + 32), v14);
    }
  }
LABEL_16:
}

id sub_1000C4E68(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) intValue];
  if (result == 12)
  {
    [*(id *)(*(void *)(a1 + 40) + 152) setObject:*(void *)(a1 + 56) forKeyedSubscript:*(void *)(a1 + 48)];
    id v3 = *(id **)(a1 + 40);
    id v4 = [v3[20] objectForKeyedSubscript:*(void *)(a1 + 48)];
    [v3 receiveAndDecryptEncryptedDataBlobs:v4];

    uint64_t v5 = *(void *)(a1 + 48);
    id v6 = *(void **)(*(void *)(a1 + 40) + 160);
    return [v6 setObject:0 forKeyedSubscript:v5];
  }
  return result;
}

void sub_1000C5424(uint64_t a1)
{
  id v8 = objc_alloc_init((Class)IMMessageContext);
  [v8 setShouldBoost:1];
  id v2 = +[IDSDaemon sharedInstance];
  id v3 = [*(id *)(a1 + 32) sharedState];
  id v4 = [v3 pushTopic];
  uint64_t v5 = [v2 broadcasterForTopic:v4 entitlement:kIDSSessionEntitlement command:0 messageContext:v8];

  id v6 = [*(id *)(a1 + 32) sharedState];
  int v7 = [v6 uniqueID];
  [v5 session:v7 rejectedKeyRecoveryRequestFromURI:*(void *)(a1 + 40) reason:*(unsigned int *)(a1 + 48)];
}

void sub_1000C5A94(uint64_t a1)
{
  id v8 = objc_alloc_init((Class)IMMessageContext);
  [v8 setShouldBoost:1];
  id v2 = +[IDSDaemon sharedInstance];
  id v3 = [*(id *)(a1 + 32) sharedState];
  id v4 = [v3 pushTopic];
  uint64_t v5 = [v2 broadcasterForTopic:v4 entitlement:kIDSSessionEntitlement command:0 messageContext:v8];

  id v6 = [*(id *)(a1 + 32) sharedState];
  int v7 = [v6 uniqueID];
  [v5 session:v7 didReceiveKeyMaterial:*(void *)(a1 + 40)];
}

void sub_1000C5C60(uint64_t a1)
{
  id v8 = objc_alloc_init((Class)IMMessageContext);
  [v8 setShouldBoost:1];
  id v2 = +[IDSDaemon sharedInstance];
  id v3 = [*(id *)(a1 + 32) sharedState];
  id v4 = [v3 pushTopic];
  uint64_t v5 = [v2 broadcasterForTopic:v4 entitlement:kIDSSessionEntitlement command:0 messageContext:v8];

  id v6 = [*(id *)(a1 + 32) sharedState];
  int v7 = [v6 uniqueID];
  [v5 session:v7 shouldInvalidateKeyMaterialByKeyIndexes:*(void *)(a1 + 40)];
}

uint64_t sub_1000C5E90(uint64_t a1)
{
  [*(id *)(a1 + 32) link:*(void *)(a1 + 32) didReceiveMembershipChangedInformation:*(unsigned __int8 *)(a1 + 48)];
  id v2 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16);

  return v2();
}

void sub_1000C61F0(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 96));
  _Unwind_Resume(a1);
}

void sub_1000C6214(uint64_t a1, uint64_t a2, void *a3)
{
  id v11 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    id v5 = objc_alloc_init((Class)IMMessageContext);
    [v5 setShouldBoost:1];
    id v6 = +[IDSDaemon sharedInstance];
    int v7 = [*(id *)(a1 + 32) pushTopic];
    id v8 = [v6 broadcasterForTopic:v7 entitlement:kIDSSessionEntitlement command:0 messageContext:v5];

    uint64_t v9 = [WeakRetained sharedState];
    id v10 = [v9 uniqueID];
    [v8 allocationDone:v10 sessionInfo:v11];
  }
}

void sub_1000C6500(uint64_t a1)
{
  uint64_t v2 = +[IDSGroupEncryptionController sharedInstance];
  id v3 = [*(id *)(a1 + 32) sharedState];
  id v4 = [v3 groupID];
  id v5 = [v2 localParticipantIDForGroupID:v4];

  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  id v6 = *(id *)(a1 + 40);
  id v7 = [v6 countByEnumeratingWithState:&v20 objects:v24 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v21;
    do
    {
      for (uint64_t i = 0; i != v8; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v21 != v9) {
          objc_enumerationMutation(v6);
        }
        id v11 = *(void **)(*((void *)&v20 + 1) + 8 * i);
        if (objc_msgSend(v11, "unsignedLongLongValue", (void)v20) != v5)
        {
          uint64_t v12 = [*(id *)(a1 + 32) _getPushTokenFromParticipantIDNumber:v11];
          if (v12)
          {
            id v13 = [*(id *)(*(void *)(a1 + 32) + 896) joinCycleForToken:v12];
            [v13 requestedKM];
          }
        }
      }
      id v8 = [v6 countByEnumeratingWithState:&v20 objects:v24 count:16];
    }
    while (v8);
  }

  uint64_t v14 = +[IDSGroupEncryptionController sharedInstance];
  uint64_t v15 = *(void *)(a1 + 40);
  uint64_t v16 = [*(id *)(a1 + 32) sharedState];
  uint64_t v17 = [v16 groupID];
  id v18 = [*(id *)(a1 + 32) sharedState];
  uint64_t v19 = [v18 uniqueID];
  [v14 sendKeyMaterialsRecoveryRequestToParticipants:v15 groupID:v17 sessionID:v19 requireMKM:0 requireSKM:1];
}

void sub_1000C6A20(uint64_t a1)
{
  id v4 = [*(id *)(a1 + 32) utunController];
  uint64_t v2 = [*(id *)(a1 + 32) sharedState];
  id v3 = [v2 uniqueID];
  objc_msgSend(v4, "onTransportThread_requestMaterialsForSession:participantIDs:materialType:", v3, *(void *)(a1 + 40), *(unsigned int *)(a1 + 48));
}

void sub_1000C6B44(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) utunController];
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 48);
  id v5 = [*(id *)(a1 + 32) sharedState];
  id v6 = [v5 uniqueID];
  id v7 = objc_msgSend(v2, "onTransportThread_createAliasForParticipantID:salt:sessionID:", v3, v4, v6);

  id v8 = im_primary_queue();
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1000C6C6C;
  v12[3] = &unk_10097F280;
  uint64_t v9 = *(void **)(a1 + 40);
  void v12[4] = *(void *)(a1 + 32);
  uint64_t v10 = *(void *)(a1 + 48);
  id v14 = v7;
  uint64_t v15 = v10;
  id v13 = v9;
  dispatch_block_t v11 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS|DISPATCH_BLOCK_ASSIGN_CURRENT, QOS_CLASS_USER_INTERACTIVE, 0, v12);
  dispatch_async(v8, v11);
}

void sub_1000C6C6C(uint64_t a1)
{
  id v8 = objc_alloc_init((Class)IMMessageContext);
  [v8 setShouldBoost:1];
  uint64_t v2 = +[IDSDaemon sharedInstance];
  uint64_t v3 = [*(id *)(a1 + 32) sharedState];
  uint64_t v4 = [v3 pushTopic];
  id v5 = [v2 broadcasterForTopic:v4 entitlement:kIDSSessionEntitlement command:0 messageContext:v8];

  id v6 = [*(id *)(a1 + 32) sharedState];
  id v7 = [v6 uniqueID];
  [v5 session:v7 didCreateParticipantIDAlias:*(void *)(a1 + 48) forParticipantID:*(void *)(a1 + 56) salt:*(void *)(a1 + 40)];
}

void sub_1000C6E08(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) utunController];
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 48);
  id v5 = [*(id *)(a1 + 32) sharedState];
  id v6 = [v5 uniqueID];
  id v7 = objc_msgSend(v2, "onTransportThread_participantIDForAlias:salt:sessionID:", v3, v4, v6);

  id v8 = im_primary_queue();
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1000C6F30;
  v12[3] = &unk_10097F280;
  uint64_t v9 = *(void **)(a1 + 40);
  void v12[4] = *(void *)(a1 + 32);
  uint64_t v10 = *(void *)(a1 + 48);
  id v14 = v7;
  uint64_t v15 = v10;
  id v13 = v9;
  dispatch_block_t v11 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS|DISPATCH_BLOCK_ASSIGN_CURRENT, QOS_CLASS_USER_INTERACTIVE, 0, v12);
  dispatch_async(v8, v11);
}

void sub_1000C6F30(uint64_t a1)
{
  id v8 = objc_alloc_init((Class)IMMessageContext);
  [v8 setShouldBoost:1];
  uint64_t v2 = +[IDSDaemon sharedInstance];
  uint64_t v3 = [*(id *)(a1 + 32) sharedState];
  uint64_t v4 = [v3 pushTopic];
  id v5 = [v2 broadcasterForTopic:v4 entitlement:kIDSSessionEntitlement command:0 messageContext:v8];

  id v6 = [*(id *)(a1 + 32) sharedState];
  id v7 = [v6 uniqueID];
  [v5 session:v7 didReceiveParticipantID:*(void *)(a1 + 48) forParticipantIDAlias:*(void *)(a1 + 56) salt:*(void *)(a1 + 40)];
}

void sub_1000C7104(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_1000C711C(uint64_t a1)
{
  id v6 = [*(id *)(a1 + 32) utunController];
  uint64_t v2 = *(void *)(a1 + 56);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = [*(id *)(a1 + 32) sharedState];
  id v5 = [v4 uniqueID];
  *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = objc_msgSend(v6, "onTransportThread_participantIDForAlias:salt:sessionID:", v2, v3, v5);
}

void sub_1000C74F8(uint64_t a1)
{
  id v6 = [*(id *)(a1 + 32) utunController];
  uint64_t v2 = [*(id *)(a1 + 32) sharedState];
  uint64_t v3 = [v2 uniqueID];
  uint64_t v4 = [*(id *)(a1 + 32) sharedState];
  id v5 = [v4 groupID];
  objc_msgSend(v6, "onTransportThread_updateSessionParticipants:relayGroupID:relaySessionID:participants:", v3, v5, *(void *)(a1 + 40), *(void *)(a1 + 48));
}

void sub_1000C75B0(uint64_t a1)
{
  uint64_t v2 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Sending the session info request to update the active participant list...", buf, 2u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      _IDSLogTransport();
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
  }
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = +[NSDictionary dictionaryWithObjectsAndKeys:](NSDictionary, "dictionaryWithObjectsAndKeys:", &off_1009D0D38, IDSGlobalLinkOptionSessionInfoRequestTypeKey, 0);
  [v3 requestSessionInfoWithOptions:v4];
}

void sub_1000C796C(uint64_t a1)
{
  id v6 = [*(id *)(a1 + 32) utunController];
  uint64_t v2 = [*(id *)(a1 + 32) sharedState];
  uint64_t v3 = [v2 uniqueID];
  uint64_t v4 = [*(id *)(a1 + 32) sharedState];
  id v5 = [v4 groupID];
  objc_msgSend(v6, "onTransportThread_updateSessionURIToParticipantIDs:relayGroupID:relaySessionID:sessionInfo:", v3, v5, *(void *)(a1 + 40), *(void *)(a1 + 48));
}

void sub_1000C8000(uint64_t a1)
{
  uint64_t v2 = +[NSMutableSet set];
  long long v48 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  id v3 = *(id *)(a1 + 32);
  id v4 = [v3 countByEnumeratingWithState:&v48 objects:v52 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v49;
    do
    {
      for (uint64_t i = 0; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v49 != v6) {
          objc_enumerationMutation(v3);
        }
        id v8 = *(void **)(*((void *)&v48 + 1) + 8 * i);
        if ([v8 isKnown])
        {
          uint64_t v9 = [v8 participantURI];
          [v2 addObject:v9];
        }
      }
      id v5 = [v3 countByEnumeratingWithState:&v48 objects:v52 count:16];
    }
    while (v5);
  }

  [*(id *)(*(void *)(a1 + 40) + 896) setActiveParticipantURIs:v2];
  uint64_t v10 = +[IDSGroupEncryptionController sharedInstance];
  dispatch_block_t v11 = [v10 realTimeEncryptionPublicKeyData];

  if (!v11)
  {
    id v43 = [*(id *)(a1 + 40) accountController];
    uint64_t v12 = [*(id *)(a1 + 40) sharedState];
    id v13 = [v12 accountID];
    id v14 = [v43 accountWithUniqueID:v13];
    uint64_t v15 = [v14 primaryRegistration];
    uint64_t v16 = [v15 pushToken];
    uint64_t v17 = [*(id *)(a1 + 40) sharedState];
    id v18 = [v17 serviceName];
    uint64_t v19 = +[IDSPushToken pushTokenWithData:v16 withServiceLoggingHint:v18];

    long long v20 = +[IDSGroupEncryptionController sharedInstance];
    id v21 = [v20 createRealTimeEncryptionFullIdentityForDevice:v19 completionBlock:0];
  }
  long long v22 = +[IDSGroupEncryptionController sharedInstance];
  uint64_t v23 = *(void *)(a1 + 32);
  uint64_t v24 = [*(id *)(a1 + 40) sharedState];
  double v25 = [v24 groupID];
  id v26 = [*(id *)(a1 + 40) sharedState];
  id v27 = [v26 uniqueID];
  [v22 didUpdateParticipants:v23 ofType:0 forGroup:v25 sessionID:v27];

  int8x16_t v28 = [*(id *)(a1 + 40) sharedState];
  id v29 = [v28 pushTopic];

  id v30 = objc_alloc_init((Class)IMMessageContext);
  [v30 setShouldBoost:1];
  __int16 v31 = +[IDSDaemon sharedInstance];
  id v32 = [v31 broadcasterForTopic:v29 entitlement:kIDSSessionEntitlement command:0 messageContext:v30];

  __int16 v33 = +[NSMutableArray array];
  id v34 = +[IDSGroupEncryptionController sharedInstance];
  __int16 v35 = [*(id *)(a1 + 40) sharedState];
  uint64_t v36 = [v35 groupID];
  id v37 = [v34 localParticipantIDForGroupID:v36];

  v44[0] = _NSConcreteStackBlock;
  v44[1] = 3221225472;
  v44[2] = sub_1000C8464;
  v44[3] = &unk_100981700;
  int v39 = *(void **)(a1 + 32);
  uint64_t v38 = *(void *)(a1 + 40);
  id v45 = v33;
  uint64_t v46 = v38;
  id v47 = v37;
  id v40 = v33;
  [v39 enumerateObjectsUsingBlock:v44];
  id v41 = [*(id *)(a1 + 40) sharedState];
  double v42 = [v41 uniqueID];
  [v32 session:v42 didReceiveActiveParticipants:v40 success:1];
}

void sub_1000C8464(uint64_t a1, void *a2)
{
  id v6 = a2;
  id v3 = *(void **)(a1 + 32);
  id v4 = [v6 dictionaryRepresentation];
  [v3 addObject:v4];

  if ([v6 participantIdentifier] != *(id *)(a1 + 48) && objc_msgSend(v6, "isKnown"))
  {
    id v5 = [v6 participantPushToken];
    [*(id *)(*(void *)(a1 + 40) + 896) remoteDidBecomeActive:v5];
  }
}

void sub_1000C85E0(uint64_t a1)
{
  uint64_t v2 = +[IDSGroupEncryptionController sharedInstance];
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = [*(id *)(a1 + 40) sharedState];
  id v5 = [v4 groupID];
  id v6 = [*(id *)(a1 + 40) sharedState];
  id v7 = [v6 uniqueID];
  [v2 didUpdateParticipants:v3 ofType:1 forGroup:v5 sessionID:v7];

  id v8 = [*(id *)(a1 + 40) sharedState];
  uint64_t v9 = [v8 pushTopic];

  id v10 = objc_alloc_init((Class)IMMessageContext);
  [v10 setShouldBoost:1];
  dispatch_block_t v11 = +[IDSDaemon sharedInstance];
  uint64_t v12 = [v11 broadcasterForTopic:v9 entitlement:kIDSSessionEntitlement command:0 messageContext:v10];

  id v13 = +[NSMutableArray array];
  id v14 = +[IDSGroupEncryptionController sharedInstance];
  uint64_t v15 = [*(id *)(a1 + 40) sharedState];
  uint64_t v16 = [v15 groupID];
  id v17 = [v14 localParticipantIDForGroupID:v16];

  v23[0] = _NSConcreteStackBlock;
  v23[1] = 3221225472;
  v23[2] = sub_1000C8824;
  v23[3] = &unk_100981700;
  uint64_t v19 = *(void **)(a1 + 32);
  uint64_t v18 = *(void *)(a1 + 40);
  id v24 = v13;
  uint64_t v25 = v18;
  id v26 = v17;
  id v20 = v13;
  [v19 enumerateObjectsUsingBlock:v23];
  id v21 = [*(id *)(a1 + 40) sharedState];
  long long v22 = [v21 uniqueID];
  [v12 session:v22 didReceiveActiveLightweightParticipants:v20 success:1];
}

void sub_1000C8824(uint64_t a1, void *a2)
{
  id v6 = a2;
  uint64_t v3 = *(void **)(a1 + 32);
  id v4 = [v6 dictionaryRepresentation];
  [v3 addObject:v4];

  if ([v6 participantIdentifier] != *(id *)(a1 + 48) && objc_msgSend(v6, "isKnown"))
  {
    id v5 = [v6 participantPushToken];
    [*(id *)(*(void *)(a1 + 40) + 896) remoteDidBecomeActive:v5];
  }
}

BOOL sub_1000C93B0(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  _IDSLinkPacketBufferRetain();
  unint64_t v6 = (unint64_t)objc_msgSend(*(id *)(a1 + 32), "onTransportThread_SendToGlobalLinkWithSessionID:packetBuffer:", *(void *)(a1 + 40), a2);
  id v7 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if (v6 > 0xF) {
      id v8 = "UnexpectedSendResult";
    }
    else {
      id v8 = (const char *)_IDSLinkSendResultStrings[v6];
    }
    *(_DWORD *)buf = 138412546;
    id v11 = v5;
    __int16 v12 = 2080;
    id v13 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "IDSDSession read handler called for %@ - result %s", buf, 0x16u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      _IDSLogTransport();
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
  }

  return v6 == 0;
}

void sub_1000CA1A4(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      id v13 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "disconnectGlobalLink during reinitiate failed with error %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        id v11 = v3;
        _IDSLogTransport();
        if (_IDSShouldLog())
        {
          id v11 = v3;
          _IDSLogV();
        }
      }
    }
  }
  unint64_t v6 = *(void **)(a1 + 32);
  id v5 = (id *)(a1 + 32);
  id v7 = objc_msgSend(v6, "utunController", v11);
  id v8 = [*v5 sharedState];
  uint64_t v9 = [v8 uniqueID];
  [v7 stopGlobalLinkForDevice:v9];

  id v10 = [*v5 messenger];
  [v10 sendReinitiateMessageWithSubcommand:2];
}

void sub_1000CB338(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1000CB214);
  }
  _Unwind_Resume(a1);
}

void sub_1000CB39C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      id v16 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "disconnectGlobalLink during reinitiate teardown failed with error %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        id v14 = v3;
        _IDSLogTransport();
        if (_IDSShouldLog())
        {
          id v14 = v3;
          _IDSLogV();
        }
      }
    }
  }
  unint64_t v6 = *(void **)(a1 + 32);
  id v5 = (id *)(a1 + 32);
  id v7 = objc_msgSend(v6, "utunController", v14);
  id v8 = [*v5 sharedState];
  uint64_t v9 = [v8 uniqueID];
  [v7 stopGlobalLinkForDevice:v9];

  id v10 = [*v5 qrAllocator];
  id v11 = [*v5 sharedState];
  __int16 v12 = [v11 uniqueID];
  [v10 clearResponseFromQRGroupID:v12];

  id v13 = [*v5 messenger];
  [v13 sendReinitiateMessageWithSubcommand:3];
}

void sub_1000CC310(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1000CC01CLL);
  }
  _Unwind_Resume(a1);
}

id sub_1000CD220(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = a2;
  id v4 = [v2 sharedState];
  id v5 = [v4 serviceName];
  unint64_t v6 = +[IDSURI URIWithPrefixedURI:v3 withServiceLoggingHint:v5];

  return v6;
}

void sub_1000CE078(id a1)
{
  mach_timebase_info info = (mach_timebase_info)0xAAAAAAAAAAAAAAAALL;
  mach_timebase_info(&info);
  LODWORD(v2) = info.denom;
  LODWORD(v1) = info.numer;
  *(double *)&qword_100A4A5D8 = (double)v1 / (double)v2 / 1000000000.0;
}

void sub_1000CE0C8(id a1)
{
  unint64_t v1 = (void *)qword_100A4A5E0;
  qword_100A4A5E0 = (uint64_t)&off_1009D2B78;

  id v2 = +[IMLockdownManager sharedInstance];
  byte_100A4A5E8 = [v2 isInternalInstall];
}

void sub_1000CE13C(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 8u);
}

void sub_1000CE158(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

uint64_t sub_1000CEA7C(uint64_t result, int a2)
{
  if (result)
  {
    uint64_t v3 = result;
    id v4 = malloc_type_malloc(424 * a2, 0x1000040A56E9926uLL);
    *(void *)(v3 + 8) = v4;
    if (v4)
    {
      *(_DWORD *)uint64_t v3 = 0;
      *(_DWORD *)(v3 + 4) = a2;
      return 1;
    }
    else
    {
      id v5 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)id v7 = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "IDSSockAddrPairTable_Init failed with memory allocation", v7, 2u);
      }

      id result = os_log_shim_legacy_logging_enabled();
      if (result)
      {
        int v6 = _IDSShouldLog();
        id result = 0;
        if (v6)
        {
          _IDSLogV();
          return 0;
        }
      }
    }
  }
  return result;
}

BOOL sub_1000CEB88(void *a1)
{
  if (a1)
  {
    id v2 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "IDSSockAddrPairTable_Release", v5, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    uint64_t v3 = (void *)a1[1];
    if (v3)
    {
      free(v3);
      a1[1] = 0;
    }
    *a1 = 0;
  }
  return a1 != 0;
}

uint64_t sub_1000CEC70(int *a1, int a2, unsigned __int8 *a3, unsigned __int8 *a4, uint64_t a5, const void *a6, int a7)
{
  uint64_t result = 0;
  if (!a1 || !a3 || !a4) {
    return result;
  }
  *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v37[6] = v15;
  v37[7] = v15;
  v37[4] = v15;
  v37[5] = v15;
  v37[2] = v15;
  v37[3] = v15;
  v37[0] = v15;
  v37[1] = v15;
  v36[6] = v15;
  v36[7] = v15;
  v36[4] = v15;
  v36[5] = v15;
  v36[2] = v15;
  v36[3] = v15;
  v36[0] = v15;
  v36[1] = v15;
  SAToIPPortString();
  SAToIPPortString();
  if (*a1 < 1)
  {
    LODWORD(v16) = 0;
  }
  else
  {
    uint64_t v16 = 0;
    uint64_t v17 = 144;
    while (!IsSameSA() || !IsSameSA())
    {
      ++v16;
      v17 += 424;
      if (v16 >= *a1) {
        goto LABEL_17;
      }
    }
    uint64_t v18 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      *(void *)id v30 = v37;
      *(_WORD *)&v30[8] = 2080;
      __int16 v31 = v36;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "[%s-%s] already exists.", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled() & 1) != 0 && (_IDSShouldLogTransport())
    {
      _IDSLogTransport();
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
  }
LABEL_17:
  if (v16 != *a1) {
    goto LABEL_28;
  }
  int v19 = a1[1];
  if (v19 > (int)v16)
  {
    id v20 = (char *)*((void *)a1 + 1);
LABEL_27:
    id v24 = &v20[424 * (int)v16];
    *(void *)id v24 = a5;
    *((_DWORD *)v24 + 71) = 0;
    *((_DWORD *)v24 + 2) = a2;
    memcpy(v24 + 16, a3, *a3);
    memcpy((void *)(*((void *)a1 + 1) + 424 * *a1 + 144), a4, *a4);
    memcpy((void *)(*((void *)a1 + 1) + 424 * *a1 + 288), a6, a7);
    int v25 = *a1;
    *(_DWORD *)(*((void *)a1 + 1) + 424 * v25 + 416) = a7;
    *a1 = v25 + 1;
LABEL_28:
    id v26 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      int v27 = *a1;
      *(_DWORD *)buf = 136315906;
      *(void *)id v30 = v37;
      *(_WORD *)&v30[8] = 2080;
      __int16 v31 = v36;
      __int16 v32 = 2048;
      uint64_t v33 = a5;
      __int16 v34 = 1024;
      int v35 = v27;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "added pair [%s-%s], state (%ld), total %d pair(s).", buf, 0x26u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
    {
      _IDSLogTransport();
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
    return 1;
  }
  id v20 = (char *)malloc_type_realloc(*((void **)a1 + 1), 848 * v19, 0x1000040A56E9926uLL);
  if (v20)
  {
    int v21 = 2 * v19;
    long long v22 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      int v23 = a1[1];
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)id v30 = v23;
      *(_WORD *)&v30[4] = 1024;
      *(_DWORD *)&v30[6] = v21;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "increase capacity %d->%d", buf, 0xEu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    *((void *)a1 + 1) = v20;
    a1[1] = v21;
    LODWORD(v16) = *a1;
    goto LABEL_27;
  }
  int8x16_t v28 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "failed with realloc", buf, 2u);
  }

  uint64_t result = os_log_shim_legacy_logging_enabled();
  if (result)
  {
    uint64_t result = _IDSShouldLog();
    if (result)
    {
      _IDSLogV();
      return 0;
    }
  }
  return result;
}

uint64_t sub_1000CF200(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = 0;
  if (a1 && a2)
  {
    *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v25[6] = v6;
    v25[7] = v6;
    v25[4] = v6;
    void v25[5] = v6;
    v25[2] = v6;
    v25[3] = v6;
    v25[0] = v6;
    v25[1] = v6;
    v24[6] = v6;
    v24[7] = v6;
    void v24[4] = v6;
    v24[5] = v6;
    v24[2] = v6;
    v24[3] = v6;
    v24[0] = v6;
    v24[1] = v6;
    uint64_t v7 = *a1;
    if ((int)v7 < 1)
    {
      LODWORD(v8) = 0;
    }
    else
    {
      uint64_t v8 = 0;
      uint64_t v9 = *((void *)a1 + 1) + 272;
      while (*(void *)a2 != *(void *)v9 || *(_DWORD *)(a2 + 8) != (unint64_t)*(unsigned int *)(v9 + 8))
      {
        ++v8;
        v9 += 424;
        if (v7 == v8) {
          goto LABEL_13;
        }
      }
    }
    if (v8 == v7)
    {
LABEL_13:
      id v11 = +[NSData dataWithBytes:a2 length:12];
      __int16 v12 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        uint64_t v17 = v11;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "IDSSockAddrPairTable_UpdatePairState - found no match for transactionID %@", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }

      return 0;
    }
    else
    {
      SAToIPPortString();
      unsigned int v13 = v8;
      SAToIPPortString();
      id v14 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v15 = *(void *)(*((void *)a1 + 1) + 424 * v13);
        *(_DWORD *)buf = 136315906;
        uint64_t v17 = v25;
        __int16 v18 = 2080;
        int v19 = v24;
        __int16 v20 = 2048;
        uint64_t v21 = v15;
        __int16 v22 = 2048;
        uint64_t v23 = a3;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "IDSSockAddrPairTable_UpdatePairState - update state for [%s-%s] (%ld->%ld)", buf, 0x2Au);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLogTransport())
        {
          _IDSLogTransport();
          if (_IDSShouldLog()) {
            _IDSLogV();
          }
        }
      }
      *(void *)(*((void *)a1 + 1) + 424 * v13) = a3;
      return 1;
    }
  }
  return result;
}

void sub_1000CF584(uint64_t a1, void *a2, void *a3, __int16 a4)
{
  id v13 = a2;
  id v7 = a3;
  if (a1 && v13 && v7)
  {
    if (*(int *)(a1 + 1492) < 1)
    {
      uint64_t v8 = 0;
    }
    else
    {
      uint64_t v8 = +[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", a1 + 20);
    }
    int v9 = *(_DWORD *)a1;
    if (*(int *)a1 >= 1)
    {
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      do
      {
        __int16 v12 = (uint64_t *)(*(void *)(a1 + 8) + v10);
        if (*v12 <= 2)
        {
          sub_1000CF684((uint64_t)v12, v13, v7, 0, 0, a4, v8);
          int v9 = *(_DWORD *)a1;
        }
        ++v11;
        v10 += 424;
      }
      while (v11 < v9);
    }
  }
}

void sub_1000CF684(uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5, __int16 a6, void *a7)
{
  id v13 = a2;
  id v14 = a3;
  id v15 = a7;
  if (a1)
  {
    *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v58 = v16;
    long long v59 = v16;
    long long v56 = v16;
    long long v57 = v16;
    long long v54 = v16;
    long long v55 = v16;
    long long v52 = v16;
    long long v53 = v16;
    long long v50 = v16;
    long long v51 = v16;
    long long v48 = v16;
    long long v49 = v16;
    long long v46 = v16;
    long long v47 = v16;
    long long v44 = v16;
    long long v45 = v16;
    uint64_t v17 = (void *)_IDSLinkPacketBufferCreate();
    *((_DWORD *)v17 + 12) = *(_DWORD *)(a1 + 8);
    memcpy(v17 + 7, (const void *)(a1 + 16), *(unsigned __int8 *)(a1 + 16));
    memcpy(v17 + 23, (const void *)(a1 + 144), *(unsigned __int8 *)(a1 + 144));
    id v35 = [objc_alloc((Class)IDSStunMessage) initWithType:1];
    switch(*(void *)a1)
    {
      case 1:
        *(void *)a1 = 2;
        LOWORD(v31) = a6;
        [v35 stunRequestToBuffer:*v17 outputLength:v17 + 2 transactionID:0 reqCount:0 userName:a4 usernameLen:a5 sendTime:v31 keyData:v15 remainingLength:v17[1]];
        id v18 = [v35 transactionID];
        int v19 = [v18 bytes];

        uint64_t v20 = *(void *)v19;
        *(_DWORD *)(a1 + 280) = v19[2];
        *(void *)(a1 + 272) = v20;
        goto LABEL_8;
      case 2:
        LOWORD(v31) = a6;
        [v35 stunRequestToBuffer:*v17 outputLength:v17 + 2 transactionID:a1 + 272 reqCount:0 userName:a4 usernameLen:a5 sendTime:v31 keyData:v15 remainingLength:v17[1]];
        goto LABEL_8;
      case 3:
      case 4:
        if (a4 && (int)a5 > 0)
        {
          *(void *)a1 = 4;
          LOWORD(v31) = a6;
          [v35 stunRequestToBuffer:*v17 outputLength:v17 + 2 transactionID:a1 + 272 reqCount:*(unsigned int *)(a1 + 284) userName:a4 usernameLen:a5 sendTime:v31 keyData:v15 remainingLength:v17[1]];
LABEL_8:
          uint64_t v21 = OSLogHandleForTransportCategory();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v22 = SAToIPPortString();
            int v23 = *((_DWORD *)v17 + 12);
            *(_DWORD *)buf = 138413058;
            id v37 = (const char *)v35;
            __int16 v38 = 2080;
            uint64_t v39 = v22;
            __int16 v40 = 1024;
            int v41 = v23;
            __int16 v42 = 2080;
            uint64_t v43 = SAToIPPortString();
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "send binding request %@ for [%s(%u)-%s].", buf, 0x26u);
          }

          if (os_log_shim_legacy_logging_enabled())
          {
            if (_IDSShouldLogTransport())
            {
              uint64_t v24 = SAToIPPortString();
              uint64_t v33 = *((unsigned int *)v17 + 12);
              uint64_t v34 = SAToIPPortString();
              id v31 = v35;
              uint64_t v32 = v24;
              _IDSLogTransport();
              if (_IDSShouldLog())
              {
                uint64_t v25 = SAToIPPortString();
                uint64_t v33 = *((unsigned int *)v17 + 12);
                uint64_t v34 = SAToIPPortString();
                id v31 = v35;
                uint64_t v32 = v25;
                _IDSLogV();
              }
            }
          }
          unint64_t v26 = (unint64_t)objc_msgSend(v13, "sendPacketBuffer:toDeviceUniqueID:cbuuid:", v17, 0, v14, v31, v32, v33, v34);
          if (v26)
          {
            int v27 = OSLogHandleForTransportCategory();
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
            {
              if (v26 > 0xF) {
                int8x16_t v28 = "UnexpectedSendResult";
              }
              else {
                int8x16_t v28 = (const char *)_IDSLinkSendResultStrings[v26];
              }
              *(_DWORD *)buf = 136315138;
              id v37 = v28;
              _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "failed to send binding request with error (%s)", buf, 0xCu);
            }

            if (os_log_shim_legacy_logging_enabled())
            {
              if (_IDSShouldLogTransport())
              {
                _IDSLogTransport();
                if (_IDSShouldLog()) {
                  goto LABEL_35;
                }
              }
            }
          }
        }
        else
        {
          id v30 = OSLogHandleForTransportCategory();
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "skip regular binding request", buf, 2u);
          }

          if (os_log_shim_legacy_logging_enabled())
          {
            if (_IDSShouldLogTransport())
            {
              _IDSLogTransport();
              if (_IDSShouldLog()) {
LABEL_35:
              }
                _IDSLogV();
            }
          }
        }
LABEL_36:

        break;
      case 5:
        id v29 = OSLogHandleForTransportCategory();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "skip nominate binding request", buf, 2u);
        }

        if (os_log_shim_legacy_logging_enabled())
        {
          if (_IDSShouldLogTransport())
          {
            _IDSLogTransport();
            if (_IDSShouldLog()) {
              goto LABEL_35;
            }
          }
        }
        goto LABEL_36;
      default:
        goto LABEL_8;
    }
  }
}

BOOL sub_1000CFD24(unsigned int *a1)
{
  if (!a1) {
    return 1;
  }
  uint64_t v1 = *a1;
  if ((int)v1 < 1) {
    return 1;
  }
  id v2 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v3 = v1 - 1;
  do
  {
    BOOL result = *v2 > 2;
    BOOL v6 = v3-- != 0;
    if (*v2 < 3) {
      break;
    }
    v2 += 53;
  }
  while (v6);
  return result;
}

unint64_t sub_1000CFD6C(unint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(unsigned int *)result;
    if ((int)v1 < 1)
    {
      return 0;
    }
    else
    {
      id v2 = *(void **)(result + 8);
      uint64_t v3 = v1 - 1;
      do
      {
        BOOL result = *v2 == 5;
        BOOL v4 = *v2 == 5 || v3-- == 0;
        v2 += 53;
      }
      while (!v4);
    }
  }
  return result;
}

unint64_t sub_1000CFDAC(unint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(unsigned int *)result;
    if ((int)v1 < 1)
    {
      return 0;
    }
    else
    {
      id v2 = *(void **)(result + 8);
      uint64_t v3 = v1 - 1;
      do
      {
        BOOL result = *v2 == 7;
        BOOL v4 = *v2 == 7 || v3-- == 0;
        v2 += 53;
      }
      while (!v4);
    }
  }
  return result;
}

uint64_t sub_1000CFDEC(uint64_t result, void *__s2, int a3, _DWORD *a4, void *a5, void *a6)
{
  if (result)
  {
    uint64_t v6 = *(unsigned int *)result;
    if ((int)v6 < 1)
    {
      return 0;
    }
    else
    {
      for (uint64_t i = *(void *)(result + 8); ; i += 424)
      {
        if (*(void *)i == 5)
        {
          int v13 = *(_DWORD *)(i + 416);
          if (v13 >= a3) {
            int v13 = a3;
          }
          if (!memcmp((const void *)(i + 288), __s2, v13)) {
            break;
          }
        }
        if (!--v6) {
          return 0;
        }
      }
      if (a4) {
        *a4 = *(_DWORD *)(i + 8);
      }
      memcpy(a5, (const void *)(i + 16), *(unsigned __int8 *)(i + 16));
      memcpy(a6, (const void *)(i + 144), *(unsigned __int8 *)(i + 144));
      return 1;
    }
  }
  return result;
}

void sub_1000CFEBC(uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5, __int16 a6)
{
  id v11 = a2;
  id v12 = a3;
  int v13 = v12;
  if (a1 && v11 && v12)
  {
    *(void *)&long long v14 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v50 = v14;
    long long v51 = v14;
    long long v48 = v14;
    long long v49 = v14;
    long long v46 = v14;
    long long v47 = v14;
    long long v44 = v14;
    long long v45 = v14;
    long long v42 = v14;
    long long v43 = v14;
    long long v40 = v14;
    long long v41 = v14;
    long long v38 = v14;
    long long v39 = v14;
    long long v36 = v14;
    long long v37 = v14;
    if (*(int *)(a1 + 1492) < 1)
    {
      id v29 = 0;
    }
    else
    {
      id v29 = +[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", a1 + 20);
    }
    unsigned int v15 = *(_DWORD *)a1;
    if (*(int *)a1 >= 1)
    {
      uint64_t v16 = 0;
      while (1)
      {
        uint64_t v17 = *(void *)(*(void *)(a1 + 8) + v16);
        if (v17 == 4)
        {
          uint64_t v20 = OSLogHandleForTransportCategory();
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v21 = SAToIPPortString();
            int v22 = *(_DWORD *)(*(void *)(a1 + 8) + v16 + 8);
            *(_DWORD *)buf = 136315650;
            uint64_t v31 = v21;
            __int16 v32 = 1024;
            int v33 = v22;
            __int16 v34 = 2080;
            uint64_t v35 = SAToIPPortString();
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Nominate connection [%s(%u)-%s].", buf, 0x1Cu);
          }

          if (os_log_shim_legacy_logging_enabled())
          {
            if (_IDSShouldLogTransport())
            {
              SAToIPPortString();
              SAToIPPortString();
              _IDSLogTransport();
              if (_IDSShouldLog())
              {
                SAToIPPortString();
                SAToIPPortString();
                _IDSLogV();
              }
            }
          }
LABEL_35:
          sub_1000CF684(*(void *)(a1 + 8) + v16, v11, v13, a4, a5, a6, v29);
          goto LABEL_36;
        }
        if (v17 == 5) {
          break;
        }
        v16 += 424;
        if (424 * v15 == v16)
        {
          uint64_t v16 = 0;
          uint64_t v18 = *(void *)(a1 + 8);
          uint64_t v19 = 424 * v15;
          while (*(void *)(v18 + v16) != 3)
          {
            v16 += 424;
            if (v19 == v16) {
              goto LABEL_36;
            }
          }
          ++*(_DWORD *)(v18 + v16 + 284);
          unint64_t v26 = OSLogHandleForTransportCategory();
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v27 = SAToIPPortString();
            int v28 = *(_DWORD *)(*(void *)(a1 + 8) + v16 + 8);
            *(_DWORD *)buf = 136315650;
            uint64_t v31 = v27;
            __int16 v32 = 1024;
            int v33 = v28;
            __int16 v34 = 2080;
            uint64_t v35 = SAToIPPortString();
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Nominate new connection [%s(%u)-%s].", buf, 0x1Cu);
          }

          if (os_log_shim_legacy_logging_enabled())
          {
            if (_IDSShouldLogTransport())
            {
              SAToIPPortString();
              SAToIPPortString();
              _IDSLogTransport();
              if (_IDSShouldLog())
              {
                SAToIPPortString();
                SAToIPPortString();
                _IDSLogV();
              }
            }
          }
          goto LABEL_35;
        }
      }
      int v23 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v24 = SAToIPPortString();
        int v25 = *(_DWORD *)(*(void *)(a1 + 8) + v16 + 8);
        *(_DWORD *)buf = 136315650;
        uint64_t v31 = v24;
        __int16 v32 = 1024;
        int v33 = v25;
        __int16 v34 = 2080;
        uint64_t v35 = SAToIPPortString();
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Nominate connection [%s(%u)-%s] is done, skip.", buf, 0x1Cu);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLogTransport())
        {
          SAToIPPortString();
          SAToIPPortString();
          _IDSLogTransport();
          if (_IDSShouldLog())
          {
            SAToIPPortString();
            SAToIPPortString();
            _IDSLogV();
          }
        }
      }
    }
LABEL_36:
  }
}

void sub_1000D057C(int *a1, void *a2, void *a3, uint64_t a4, uint64_t a5, __int16 a6)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = v10;
  if (a1 && v9 && v10)
  {
    if (a1[373] < 1)
    {
      id v12 = 0;
    }
    else
    {
      id v12 = +[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", a1 + 5);
    }
    if (*a1 < 1) {
      goto LABEL_46;
    }
    uint64_t v13 = 0;
    uint64_t v14 = 144;
    while (!IsSameSA() || !IsSameSA())
    {
      ++v13;
      v14 += 424;
      if (v13 >= *a1) {
        goto LABEL_46;
      }
    }
    unsigned int v15 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = a1[4];
      uint64_t v17 = SAToIPPortString();
      int v18 = *(_DWORD *)(*((void *)a1 + 1) + v14 - 136);
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)&uint8_t buf[4] = v16;
      *(_WORD *)&uint8_t buf[8] = 2080;
      *(void *)&buf[10] = v17;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v18;
      *(_WORD *)&unsigned char buf[24] = 2080;
      *(void *)&buf[26] = SAToIPPortString();
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Start echo (%d) for [%s(%u)-%s].", buf, 0x22u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        uint64_t v19 = a1[4];
        SAToIPPortString();
        uint64_t v44 = SAToIPPortString();
        uint64_t v40 = v19;
        _IDSLogTransport();
        if (_IDSShouldLog())
        {
          uint64_t v20 = a1[4];
          SAToIPPortString();
          uint64_t v44 = SAToIPPortString();
          uint64_t v40 = v20;
          _IDSLogV();
        }
      }
    }
    uint64_t v21 = *((void *)a1 + 1);
    uint64_t v46 = a1[4];
    id v48 = v9;
    id v49 = v11;
    id v22 = v12;
    if (!v21)
    {
LABEL_45:

LABEL_46:
      goto LABEL_47;
    }
    id v45 = v22;
    *(void *)&long long v23 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v68 = v23;
    long long v69 = v23;
    long long v66 = v23;
    long long v67 = v23;
    *(_OWORD *)&unsigned char buf[32] = v23;
    long long v65 = v23;
    *(_OWORD *)buf = v23;
    *(_OWORD *)&uint8_t buf[16] = v23;
    long long v62 = v23;
    long long v63 = v23;
    long long v60 = v23;
    long long v61 = v23;
    long long v58 = v23;
    long long v59 = v23;
    long long v56 = v23;
    long long v57 = v23;
    uint64_t v24 = _IDSLinkPacketBufferCreate();
    id v47 = [objc_alloc((Class)IDSStunMessage) initWithType:3811];
    uint64_t v25 = v21 + v14;
    uint64_t v26 = *(void *)(v21 + v14 - 144);
    if (v26 < 5 || v26 == 7)
    {
      long long v38 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v39 = *(void *)(v25 - 144);
        *(_DWORD *)long long v50 = 67109120;
        *(_DWORD *)long long v51 = v39;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "cannot send echo request due to invalid state (%d).", v50, 8u);
      }

      if (!os_log_shim_legacy_logging_enabled()) {
        goto LABEL_44;
      }
      if (!_IDSShouldLogTransport()) {
        goto LABEL_44;
      }
      _IDSLogTransport();
      if (!_IDSShouldLog()) {
        goto LABEL_44;
      }
    }
    else
    {
      *(void *)(v25 - 144) = 6;
      LOWORD(v40) = a6;
      objc_msgSend(v47, "stunRequestToBuffer:outputLength:transactionID:reqCount:userName:usernameLen:sendTime:keyData:remainingLength:", *(void *)v24, v24 + 16, v40, v45, *(void *)(v24 + 8));
      uint64_t v27 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v28 = SAToIPPortString();
        int v29 = *(_DWORD *)(v24 + 48);
        *(_DWORD *)long long v50 = 67109890;
        *(_DWORD *)long long v51 = v46;
        *(_WORD *)&v51[4] = 2080;
        *(void *)&v51[6] = v28;
        __int16 v52 = 1024;
        int v53 = v29;
        __int16 v54 = 2080;
        uint64_t v55 = SAToIPPortString();
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "send echo request (count:%d) for %s(%u)-%s.", v50, 0x22u);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLogTransport())
        {
          uint64_t v30 = SAToIPPortString();
          uint64_t v43 = *(unsigned int *)(v24 + 48);
          uint64_t v44 = SAToIPPortString();
          uint64_t v41 = v46;
          uint64_t v42 = v30;
          _IDSLogTransport();
          if (_IDSShouldLog())
          {
            uint64_t v31 = SAToIPPortString();
            uint64_t v43 = *(unsigned int *)(v24 + 48);
            uint64_t v44 = SAToIPPortString();
            uint64_t v41 = v46;
            uint64_t v42 = v31;
            _IDSLogV();
          }
        }
      }
      objc_msgSend(v47, "transactionID", v41, v42, v43, v44);
      id v32 = objc_claimAutoreleasedReturnValue();
      int v33 = [v32 bytes];

      uint64_t v34 = *(void *)v33;
      *(_DWORD *)(v21 + v14 + 136) = v33[2];
      *(void *)(v21 + v14 + 128) = v34;
      unint64_t v35 = (unint64_t)[v48 sendPacketBuffer:v24 toDeviceUniqueID:0 cbuuid:v49];
      if (!v35) {
        goto LABEL_44;
      }
      long long v36 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        if (v35 > 0xF) {
          long long v37 = "UnexpectedSendResult";
        }
        else {
          long long v37 = (const char *)_IDSLinkSendResultStrings[v35];
        }
        *(_DWORD *)long long v50 = 136315138;
        *(void *)long long v51 = v37;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "failed to send echo request with error (%s)", v50, 0xCu);
      }

      if (!os_log_shim_legacy_logging_enabled()) {
        goto LABEL_44;
      }
      if (!_IDSShouldLogTransport()) {
        goto LABEL_44;
      }
      _IDSLogTransport();
      if (!_IDSShouldLog()) {
        goto LABEL_44;
      }
    }
    _IDSLogV();
LABEL_44:

    id v22 = v45;
    goto LABEL_45;
  }
LABEL_47:
}

char *sub_1000D0D7C(char *result, const void *a2, size_t __n)
{
  if (result && a2)
  {
    int v3 = __n;
    if ((__n - 1472) >= 0xFFFFFA41)
    {
      BOOL v4 = result;
      BOOL result = (char *)memcpy(result + 20, a2, __n);
      v4[373] = v3;
    }
  }
  return result;
}

uint64_t sub_1000D0DC8(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 16);
  }
  return result;
}

unsigned int *sub_1000D0DD4(unsigned int *result)
{
  if (result)
  {
    ++result[4];
    uint64_t v1 = *result;
    if ((int)v1 >= 1)
    {
      id v2 = (void *)*((void *)result + 1);
      do
      {
        if ((*v2 & 0xFFFFFFFFFFFFFFFELL) == 6) {
          void *v2 = 5;
        }
        v2 += 53;
        --v1;
      }
      while (v1);
    }
  }
  return result;
}

id sub_1000D11FC(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init((Class)CUTUnsafePromiseSeal);
  id v5 = [v3 commitBlock];
  uint64_t v6 = v5;
  if (!v5) {
    id v5 = *(void **)(a1 + 32);
  }
  id v7 = objc_retainBlock(v5);

  id v8 = objc_alloc((Class)IDSMPDecryptionResult);
  id v9 = [v3 decryptedData];
  id v10 = [v3 encryptedAttributes];
  id v11 = [v3 additionalDecryptionResult];
  id v12 = [v8 initWithData:v9 encryptedAttributes:v10 withCommitState:v7 additionalDecryptionResult:v11];
  [v4 fulfillWithValue:v12];

  uint64_t v13 = [v4 promise];

  return v13;
}

id sub_1000D14A4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init((Class)CUTUnsafePromiseSeal);
  id v5 = [v3 commitBlock];
  uint64_t v6 = v5;
  if (!v5) {
    id v5 = *(void **)(a1 + 32);
  }
  id v7 = objc_retainBlock(v5);

  id v8 = objc_alloc((Class)IDSMPDecryptionResult);
  id v9 = [v3 decryptedData];
  id v10 = [v3 encryptedAttributes];
  id v11 = [v3 additionalDecryptionResult];
  id v12 = [v8 initWithData:v9 encryptedAttributes:v10 withCommitState:v7 additionalDecryptionResult:v11];
  [v4 fulfillWithValue:v12];

  uint64_t v13 = [v4 promise];

  return v13;
}

uint64_t IDSProtoKeyTransparencyTrustedDeviceMetadataReadFrom(uint64_t a1, uint64_t a2)
{
  while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      break;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0;
    while (1)
    {
      uint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      unint64_t v8 = v7 + 1;
      if (v7 == -1 || v8 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v9 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v8;
      v6 |= (unint64_t)(v9 & 0x7F) << v4;
      if ((v9 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v10 = v5++ >= 9;
      if (v10)
      {
        unint64_t v6 = 0;
        int v11 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }
    *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v11 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0;
    }
LABEL_13:
    if (v11 || (v6 & 7) == 4) {
      break;
    }
    if ((v6 >> 3) == 2)
    {
      *(unsigned char *)(a1 + 20) |= 1u;
      unint64_t v19 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v19 <= 0xFFFFFFFFFFFFFFF7 && v19 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
      {
        uint64_t v20 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v19);
        *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v19 + 8;
      }
      else
      {
        *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
        uint64_t v20 = 0;
      }
      *(void *)(a1 + 8) = v20;
    }
    else if ((v6 >> 3) == 1)
    {
      char v13 = 0;
      unsigned int v14 = 0;
      uint64_t v15 = 0;
      *(unsigned char *)(a1 + 20) |= 2u;
      while (1)
      {
        uint64_t v16 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        unint64_t v17 = v16 + 1;
        if (v16 == -1 || v17 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
          break;
        }
        char v18 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v16);
        *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v17;
        v15 |= (unint64_t)(v18 & 0x7F) << v13;
        if ((v18 & 0x80) == 0) {
          goto LABEL_32;
        }
        v13 += 7;
        BOOL v10 = v14++ >= 9;
        if (v10)
        {
          LODWORD(v15) = 0;
          goto LABEL_34;
        }
      }
      *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_32:
      if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        LODWORD(v15) = 0;
      }
LABEL_34:
      *(_DWORD *)(a1 + 16) = v15;
    }
    else
    {
      uint64_t result = PBReaderSkipValueWithTag();
      if (!result) {
        return result;
      }
    }
  }
  return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

id sub_1000D1F7C(uint64_t a1, void *a2)
{
  id v4 = a2;
  objc_storeStrong((id *)&qword_100A4A600, a2);
  unsigned int v5 = +[IMRGLog registration];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unint64_t v8 = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "NLDEBUG: SWIZZLE CALLED!", v8, 2u);
  }

  unint64_t v6 = (*(void (**)(id, void))(a1 + 32))(v4, *(void *)(a1 + 40));

  return v6;
}

void sub_1000D2198(int a1)
{
  id v2 = im_primary_queue();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000D2220;
  block[3] = &unk_1009817F0;
  int v4 = a1;
  dispatch_async(v2, block);
}

void sub_1000D2220(uint64_t a1)
{
  id v2 = (int *)(a1 + 32);
  int v1 = *(_DWORD *)(a1 + 32);
  if (v1 > 14)
  {
    if (v1 <= 29)
    {
      if (v1 != 15)
      {
        if (v1 == 29)
        {
          id v3 = +[IDSDaemon sharedInstance];
          [v3 logState];

          int v4 = +[IDSRegistrationCenter sharedInstance];
          [v4 logState];

          unsigned int v5 = +[IDSTrafficMonitor sharedInstance];
          [v5 logState];

          id v20 = +[IDSPublicKeyStorage sharedInstance];
          [v20 logState];

          return;
        }
        goto LABEL_32;
      }
      goto LABEL_13;
    }
    if (v1 == 30)
    {
      unsigned int v14 = +[IMIDSLog daemon];
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)id v22 = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "*** Clearing ID status cache ***", v22, 2u);
      }

      uint64_t v15 = +[IDSPeerIDManager sharedInstance];
      [v15 clearCacheAndPersistImmediately:1];

      uint64_t v16 = +[IDSPublicKeyStorage sharedInstance];
      [v16 clearCache];

      unint64_t v17 = +[IDSIDStatusQueryController sharedInstance];
      [v17 clearCache];

      char v18 = +[IDSDuetInterface sharedInstance];
      [v18 clearAdmissionCheckCache];

      int v11 = +[IDSDaemonPriorityQueueController sharedInstance];
      [v11 performBlockSyncPriority:&stru_1009817D0];
      goto LABEL_31;
    }
    if (v1 == 31)
    {
      id v12 = +[IMIDSLog daemon];
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v21 = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "*** Reloading Logging Settings ***", v21, 2u);
      }

      _IMSyncLoggingSettings();
      MarcoSyncLoggingsPreferences();
      char v13 = +[IDSUTunController sharedInstance];
      [v13 reloadSettings];

      sub_100108A60();
      return;
    }
LABEL_32:
    unint64_t v19 = +[IMIDSLog daemon];
    if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
      sub_10070EC7C(v2, v19);
    }

    return;
  }
  if (v1 == 1 || v1 == 3)
  {
LABEL_13:
    uint64_t v7 = +[IMIDSLog daemon];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Quit - notifying about shutdown", buf, 2u);
    }

    unint64_t v8 = +[NSNotificationCenter defaultCenter];
    objc_msgSend(v8, "__mainThreadPostNotificationName:object:", @"IDSDaemonShutdownNotification", 0);

    char v9 = +[IMIDSLog daemon];
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v24 = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Quit - shutting down daemon", v24, 2u);
    }

    BOOL v10 = +[IDSDaemon sharedInstance];
    [v10 shutdown];

    int v11 = +[IMIDSLog daemon];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v23 = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Quit - goodbye!", v23, 2u);
    }
LABEL_31:

    return;
  }
  if (v1 != 13) {
    goto LABEL_32;
  }

  signal(2, (void (__cdecl *)(int))sub_1000D2198);
}

void sub_1000D2608(id a1)
{
  int v1 = +[IDSDaemon sharedInstance];
  [v1 _cleanUpOutgoingMessageDatabaseAndClearStatementCache];

  id v2 = +[IDSDaemon sharedInstance];
  [v2 _cleanupIncomingMessageDatabase];

  id v5 = +[IDSDaemon sharedInstance];
  id v3 = [v5 opportunisticDeliveryController];
  int v4 = [v3 cache];
  [v4 clearKeychainWithError:0];
}

void sub_1000D26AC(id a1)
{
  int v1 = dispatch_get_global_queue(0, 0);
  for (uint64_t i = 0; i != 7; ++i)
  {
    int v3 = dword_100794134[i];
    int v4 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_signal, v3, 0, v1);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472;
    handler[2] = sub_1000D27D4;
    handler[3] = &unk_1009817F0;
    int v8 = v3;
    dispatch_source_set_event_handler(v4, handler);
    id v5 = (void *)qword_100A531B0[i];
    qword_100A531B0[i] = v4;
    unint64_t v6 = v4;

    dispatch_resume(v6);
    signal(v3, (void (__cdecl *)(int))1);
  }
}

void sub_1000D27D4(uint64_t a1)
{
}

uint64_t start()
{
  if ((_set_user_dir_suffix() & 1) == 0)
  {
    int v29 = +[IMIDSLog daemon];
    if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT)) {
      sub_10070EDF0();
    }

    exit(1);
  }
  if (!setiopolicy_np(9, 0, 1))
  {
    uint64_t v0 = +[IMIDSLog daemon];
    if (os_log_type_enabled(v0, OS_LOG_TYPE_FAULT)) {
      sub_10070ED70();
    }
  }
  nullsub_37();
  uint64_t v38 = 0;
  uint64_t v39 = &v38;
  uint64_t v40 = 0x3032000000;
  uint64_t v41 = sub_1000D2DC0;
  uint64_t v42 = sub_1000D2DD0;
  id v43 = 0;
  uint64_t v32 = 0;
  int v33 = &v32;
  uint64_t v34 = 0x3032000000;
  unint64_t v35 = sub_1000D2DC0;
  long long v36 = sub_1000D2DD0;
  id v37 = 0;
  id v2 = NSTemporaryDirectory();
  if (qword_100A4A618 != -1) {
    dispatch_once(&qword_100A4A618, &stru_100981810);
  }
  if (_os_feature_enabled_impl())
  {
    int v3 = +[IMIDSLog daemon];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Launching IDS with updated queue architecture.", buf, 2u);
    }

    int v4 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    id v5 = dispatch_queue_create("IDS Primary Base Queue", v4);

    unint64_t v6 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    dispatch_queue_t v7 = dispatch_queue_create_with_target_V2("IDSDaemon Primary Queue Targets Base Queue", v6, v5);
  }
  else
  {
    id v5 = &_dispatch_main_q;
    id v8 = &_dispatch_main_q;
    dispatch_queue_t v7 = (dispatch_queue_t)&_dispatch_main_q;
  }
  im_set_primary_base_queue();
  im_set_primary_queue();
  inactive = dispatch_workloop_create_inactive("com.apple.pds.xpc.workloop");
  dispatch_workloop_set_autorelease_frequency(inactive, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_activate(inactive);
  id v11 = objc_alloc_init((Class)PDSConfiguration);
  [v11 setWorkloop:inactive];
  id v12 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t v13 = dispatch_queue_create_with_target_V2("com.apple.identityservicesd.pds", v12, inactive);
  [v11 setQueue:v13];

  unsigned int v14 = NSHomeDirectory();
  v44[0] = v14;
  v44[1] = @"/Library/IdentityServices/PDS/";
  uint64_t v15 = +[NSArray arrayWithObjects:v44 count:2];
  uint64_t v16 = +[NSURL fileURLWithPathComponents:v15];
  [v11 setDaemonRootDirectory:v16];

  [v11 setPushHandlerPort:@"com.apple.identityservicesd.aps"];
  id v17 = [objc_alloc((Class)PDSDaemon) initWithConfiguration:v11];
  [v17 start];

  if (_os_feature_enabled_impl())
  {
    unint64_t v19 = im_primary_queue();
    v30[0] = _NSConcreteStackBlock;
    v30[1] = 3221225472;
    v30[2] = sub_1000D2DD8;
    v30[3] = &unk_100981838;
    v30[4] = &v38;
    v30[5] = &v32;
    dispatch_sync(v19, v30);
  }
  else
  {
    uint64_t v20 = +[IDSDaemon sharedInstance];
    uint64_t v21 = (void *)v39[5];
    v39[5] = v20;

    id v22 = [IDSDXPCDaemonServer alloc];
    unint64_t v19 = im_primary_queue();
    long long v23 = [(IDSDXPCDaemonServer *)v22 initWithServiceName:IDSXPCDaemonMachServiceName queue:v19];
    uint64_t v24 = (void *)v33[5];
    v33[5] = (uint64_t)v23;
  }

  if (v39[5])
  {
    uint64_t v25 = +[NSRunLoop currentRunLoop];
    [v25 run];
  }
  id v26 = self;
  id v27 = self;

  _Block_object_dispose(&v32, 8);
  _Block_object_dispose(&v38, 8);

  return 0;
}

void sub_1000D2D10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000D2DC0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1000D2DD0(uint64_t a1)
{
}

void sub_1000D2DD8(uint64_t a1)
{
  uint64_t v2 = +[IDSDaemon sharedInstance];
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8);
  int v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  id v5 = [IDSDXPCDaemonServer alloc];
  uint64_t v6 = IDSXPCDaemonMachServiceName;
  im_primary_queue();
  id v10 = (id)objc_claimAutoreleasedReturnValue();
  dispatch_queue_t v7 = [(IDSDXPCDaemonServer *)v5 initWithServiceName:v6 queue:v10];
  uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v9 = *(void **)(v8 + 40);
  *(void *)(v8 + 40) = v7;
}

void sub_1000D2E8C(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, v9, OS_LOG_TYPE_FAULT, a4, &a9, 8u);
}

void sub_1000D3AF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, os_activity_scope_state_s state)
{
}

void sub_1000D3D98(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) fullDeviceIdentitySigner];
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 56);
  id v15 = 0;
  id v5 = [v2 batchSignDatas:v3 withType:v4 error:&v15];
  id v6 = v15;

  dispatch_queue_t v7 = im_primary_queue();
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  v11[2] = sub_1000D3EA4;
  v11[3] = &unk_100981860;
  id v8 = *(id *)(a1 + 48);
  id v13 = v6;
  id v14 = v8;
  id v12 = v5;
  id v9 = v6;
  id v10 = v5;
  dispatch_async(v7, v11);
}

uint64_t sub_1000D3EA4(void *a1)
{
  return (*(uint64_t (**)(void, void, void))(a1[6] + 16))(a1[6], a1[4], a1[5]);
}

void sub_1000D3F8C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 56);
  id v15 = 0;
  id v5 = [v2 _signData:v3 withType:v4 error:&v15];
  id v6 = v15;
  dispatch_queue_t v7 = im_primary_queue();
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  v11[2] = sub_1000D4088;
  v11[3] = &unk_100981860;
  id v8 = *(id *)(a1 + 48);
  id v13 = v6;
  id v14 = v8;
  id v12 = v5;
  id v9 = v6;
  id v10 = v5;
  dispatch_async(v7, v11);
}

uint64_t sub_1000D4088(void *a1)
{
  return (*(uint64_t (**)(void, void, void))(a1[6] + 16))(a1[6], a1[4], a1[5]);
}

void sub_1000D41E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000D41F8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1000D4208(uint64_t a1)
{
}

void sub_1000D4210(uint64_t a1)
{
  id v5 = [*(id *)(a1 + 32) fullDeviceIdentitySigner];
  uint64_t v2 = [v5 batchSignDatas:*(void *)(a1 + 40) withType:*(void *)(a1 + 56) error:*(void *)(a1 + 64)];
  uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void sub_1000D4420(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_1000D4444(void *a1)
{
  uint64_t v2 = (void *)a1[4];
  uint64_t v3 = a1[5];
  uint64_t v4 = a1[8];
  uint64_t v5 = *(void *)(a1[7] + 8);
  id obj = *(id *)(v5 + 40);
  uint64_t v6 = [v2 _signData:v3 withType:v4 error:&obj];
  objc_storeStrong((id *)(v5 + 40), obj);
  uint64_t v7 = *(void *)(a1[6] + 8);
  id v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v6;
}

NSMutableDictionary *__cdecl sub_1000D4C44(id a1, NSDictionary *a2, int64_t a3)
{
  return 0;
}

void sub_1000D518C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000D51A4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1000D51B4(uint64_t a1)
{
}

uint64_t sub_1000D51BC(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = [*(id *)(*(void *)(a1 + 32) + 96) copy];

  return _objc_release_x1();
}

void sub_1000D5318(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000D5330(void *a1)
{
  *(void *)(*(void *)(a1[6] + 8) + 40) = [*(id *)(a1[4] + 96) objectForKey:a1[5]];

  return _objc_release_x1();
}

id sub_1000D544C(void *a1)
{
  return [*(id *)(a1[4] + 96) setObject:a1[5] forKey:a1[6]];
}

id sub_1000D54FC(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 96) removeObjectForKey:*(void *)(a1 + 40)];
}

id sub_1000D559C(uint64_t a1)
{
  unsigned int v2 = [*(id *)(a1 + 32) loadAndCheckStatus];
  if (!*(void *)(*(void *)(a1 + 32) + 96))
  {
    id v3 = objc_alloc_init((Class)NSMutableDictionary);
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = *(void **)(v4 + 96);
    *(void *)(v4 + 96) = v3;
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  if (v2)
  {
    uint64_t v6 = *(void **)(a1 + 32);
    return [v6 delayedSave];
  }
  else
  {
    id v8 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 24);
      *(_DWORD *)buf = 138412290;
      uint64_t v11 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "We're not loaded; ignoring save to disk for cache %@",
        buf,
        0xCu);
    }

    id result = (id)os_log_shim_legacy_logging_enabled();
    if (result)
    {
      id result = (id)_IDSShouldLog();
      if (result) {
        return (id)_IDSLogV();
      }
    }
  }
  return result;
}

uint64_t sub_1000D57C8(uint64_t a1)
{
  [*(id *)(a1 + 32) loadAndCheckStatus];
  unsigned int v2 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16);

  return v2();
}

void sub_1000D597C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000D5994(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = [*(id *)(*(void *)(a1 + 32) + 96) allKeys];

  return _objc_release_x1();
}

void sub_1000D5ACC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000D5AE4(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = [*(id *)(*(void *)(a1 + 32) + 96) allValues];

  return _objc_release_x1();
}

id sub_1000D5BA0(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 96) removeAllObjects];
}

void sub_1000D5C84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000D5C9C(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = [*(id *)(*(void *)(a1 + 32) + 96) copy];

  return _objc_release_x1();
}

void sub_1000D61F0(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    id v2 = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 16));
    [v2 didFirstLoadPersistentMap:WeakRetained];
  }
}

void sub_1000D62C4(uint64_t a1)
{
  unsigned int v2 = [*(id *)(a1 + 32) loadAndCheckStatus];
  unsigned int v3 = v2;
  if (*(void *)(*(void *)(a1 + 32) + 96))
  {
    if (v2)
    {
LABEL_3:
      *(void *)location = 0xAAAAAAAAAAAAAAAALL;
      objc_initWeak((id *)location, *(id *)(a1 + 32));
      uint64_t v4 = *(NSObject **)(*(void *)(a1 + 32) + 40);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_1000D64A4;
      block[3] = &unk_100981000;
      objc_copyWeak(&v11, (id *)location);
      dispatch_async(v4, block);
      objc_destroyWeak(&v11);
      objc_destroyWeak((id *)location);
      return;
    }
  }
  else
  {
    id v5 = objc_alloc_init((Class)NSMutableDictionary);
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v7 = *(void **)(v6 + 96);
    *(void *)(v6 + 96) = v5;

    if (v3) {
      goto LABEL_3;
    }
  }
  id v8 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 24);
    *(_DWORD *)location = 138412290;
    *(void *)&location[4] = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "We're not loaded; ignoring save to disk for cache %@",
      location,
      0xCu);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLog()) {
      _IDSLogV();
    }
  }
}

void sub_1000D64A4(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_1000D6530;
  v2[3] = &unk_10097E4D0;
  void v2[4] = WeakRetained;
  [WeakRetained _performLockedBlock:v2];
  [WeakRetained _save];
}

void sub_1000D6530(uint64_t a1)
{
  unsigned int v2 = *(NSObject **)(*(void *)(a1 + 32) + 48);
  if (v2)
  {
    dispatch_source_cancel(v2);
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void **)(v3 + 48);
    *(void *)(v3 + 48) = 0;
  }
}

void sub_1000D6750(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v6 = _NSConcreteStackBlock;
  uint64_t v7 = 3221225472;
  id v8 = sub_1000D6808;
  uint64_t v9 = &unk_10097E440;
  id v10 = v3;
  id v11 = WeakRetained;
  id v4 = WeakRetained;
  [v3 _performLockedBlock:&v6];
  id v5 = objc_loadWeakRetained((id *)(a1 + 48));
  objc_msgSend(v5, "_save", v6, v7, v8, v9, v10);
}

void sub_1000D6808(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  unsigned int v2 = *(void **)(a1 + 40);
  uint64_t v3 = *(void **)(v1 + 48);
  if (v3 == v2)
  {
    *(void *)(v1 + 48) = 0;
  }
}

void sub_1000D6C28(_Unwind_Exception *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  if (a2 == 1)
  {
    objc_begin_catch(exc_buf);
    objc_end_catch();
    JUMPOUT(0x1000D6AE4);
  }
  _Block_object_dispose(&a19, 8);
  _Block_object_dispose((const void *)(v19 - 96), 8);
  _Unwind_Resume(exc_buf);
}

uint64_t sub_1000D6CD0(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 32) + 96) copy];
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) = [*(id *)(a1 + 32) _mapByAddingMetadataToMap:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40)];

  return _objc_release_x1();
}

void sub_1000D6E30(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, long long buf)
{
  if (a2 == 1)
  {
    id v14 = objc_begin_catch(a1);
    id v15 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = *(void *)(v13 + 24);
      LODWORD(buf) = 138412546;
      *(void *)((char *)&buf + 4) = v14;
      WORD6(buf) = 2112;
      *(void *)((char *)&buf + 14) = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Exception decoding persistent map -- throwing away {exception: %@, identitier: %@}", (uint8_t *)&buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }

    objc_end_catch();
    JUMPOUT(0x1000D6DE0);
  }
  _Unwind_Resume(a1);
}

id sub_1000D7634(void *a1)
{
  if (a1)
  {
    uint64_t v1 = [a1 bag];
    id v2 = [v1 objectForKey:@"channel-roll-keys-key"];

    if (v2 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
      id v3 = v2;
    }
    else {
      id v3 = 0;
    }
  }
  else
  {
    id v3 = 0;
  }

  return v3;
}

id sub_1000D7810(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = [a2 objectForKey:v5];
  if (objc_opt_isKindOfClass())
  {
    id v7 = v6;
  }
  else
  {
    if (v6)
    {
      id v8 = +[IMRGLog registration];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
        sub_10070EEF4((uint64_t)v5, a1, v8);
      }
    }
    id v7 = 0;
  }

  return v7;
}

void sub_1000D78CC(void *a1, void *a2)
{
  if (a1)
  {
    id v3 = a2;
    uint64_t v4 = objc_opt_class();
    sub_1000D7810(v4, v3, @"maxDelay");
    id v8 = (id)objc_claimAutoreleasedReturnValue();

    id v5 = v8;
    if (v8)
    {
      double v6 = (double)arc4random_uniform(1000 * [v8 unsignedIntValue]) / 1000.0;
      id v7 = [a1 delegate];
      [v7 pushHandler:a1 receivedRollSMSConfigPushWithDelay:v6];

      id v5 = v8;
    }
  }
}

id sub_1000D883C(id a1, NSString *a2)
{
  return +[IDSURI URIWithPrefixedURI:a2];
}

void sub_1000DABD8(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 0xCu);
}

void sub_1000DAD1C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 lastCall])
  {
    uint64_t v4 = +[IDSFoundationLog delivery];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      id v5 = [v3 idsResponseCode];
      double v6 = [*(id *)(a1 + 32) guid];
      id v7 = [*(id *)(a1 + 32) service];
      id v8 = [*(id *)(a1 + 32) reason];
      uint64_t v9 = [*(id *)(a1 + 32) additionalInfo];
      int v10 = 134219010;
      id v11 = v5;
      __int16 v12 = 2112;
      uint64_t v13 = v6;
      __int16 v14 = 2112;
      id v15 = v7;
      __int16 v16 = 2048;
      id v17 = v8;
      __int16 v18 = 2112;
      uint64_t v19 = v9;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Sent missing message metric to server { success: %ld, guid: %@, service: %@, reason: %ld, additionalInfo: %@ }", (uint8_t *)&v10, 0x34u);
    }
  }
}

void sub_1000DAEC4(id a1)
{
  qword_100A4A628 = objc_alloc_init(IDSDGroupStatusNotificationController);

  _objc_release_x1();
}

void sub_1000DB698(uint64_t a1)
{
  id v2 = +[IDSFoundationLog GroupStatus_oversized];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    int v5 = 138412546;
    uint64_t v6 = v3;
    __int16 v7 = 2112;
    uint64_t v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "participantsForGroupID %@ are %@", (uint8_t *)&v5, 0x16u);
  }
}

void sub_1000DBEB8(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) realTimeEncryptionController];
  uint64_t v3 = [v2 realTimeEncryptionPublicKeyData];

  if (v3) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), IDSDSessionMessageRealTimeEncryptionPublicKey, v3);
  }

  uint64_t v4 = [*(id *)(a1 + 32) realTimeEncryptionController];
  int v5 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [v4 realTimeEncryptionPublicKeyWrappingMode]);

  if (v5) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), IDSDSessionMessageRealTimeEncryptionWrapModeKey, v5);
  }

  uint64_t v6 = *(void *)(a1 + 48);
  uint64_t v16 = *(void *)(a1 + 40);
  id v17 = *(void **)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = *(void *)(a1 + 64);
  uint64_t v9 = *(void *)(a1 + 112);
  uint64_t v10 = *(void *)(a1 + 72);
  uint64_t v11 = *(void *)(a1 + 80);
  uint64_t v12 = *(void *)(a1 + 88);
  char v13 = *(unsigned char *)(a1 + 120);
  id v18 = [*(id *)(a1 + 96) isInitiator];
  __int16 v14 = [*(id *)(a1 + 96) quickRelayUserType];
  BYTE2(v15) = v13;
  LOWORD(v15) = 0;
  objc_msgSend(v17, "_sendFanoutMessage:account:toGroupMembers:fromURI:command:commandContext:toGroup:sessionID:reason:waitForMadridAcks:isUPlusOne:isInitiator:quickRelayUserType:requiredCapabilites:requiredLackOfCapabilities:completionBlock:", v16, v6, v7, v8, v9, v10, v11, v12, v15, v18, v14, 0, 0, *(void *)(a1 + 104));
}

void sub_1000DC718(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) realTimeEncryptionController];
  uint64_t v3 = [v2 realTimeEncryptionPublicKeyData];

  if (v3) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), IDSDSessionMessageRealTimeEncryptionPublicKey, v3);
  }

  uint64_t v4 = [*(id *)(a1 + 32) realTimeEncryptionController];
  int v5 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [v4 realTimeEncryptionPublicKeyWrappingMode]);

  if (v5) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), IDSDSessionMessageRealTimeEncryptionWrapModeKey, v5);
  }

  uint64_t v6 = *(void *)(a1 + 48);
  uint64_t v16 = *(void *)(a1 + 40);
  id v17 = *(void **)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = *(void *)(a1 + 64);
  uint64_t v9 = *(void *)(a1 + 120);
  uint64_t v10 = *(void *)(a1 + 72);
  uint64_t v11 = *(void *)(a1 + 80);
  uint64_t v12 = *(void *)(a1 + 88);
  char v13 = *(unsigned char *)(a1 + 128);
  id v18 = [*(id *)(a1 + 96) isInitiator];
  __int16 v14 = [*(id *)(a1 + 96) quickRelayUserType];
  BYTE2(v15) = v13;
  LOWORD(v15) = 0;
  objc_msgSend(v17, "_sendFanoutMessage:account:toGroupMembers:fromURI:command:commandContext:toGroup:sessionID:reason:waitForMadridAcks:isUPlusOne:isInitiator:quickRelayUserType:requiredCapabilites:requiredLackOfCapabilities:completionBlock:", v16, v6, v7, v8, v9, v10, v11, v12, v15, v18, v14, *(void *)(a1 + 104), *(void *)(a1 + 112), 0);
}

void sub_1000DE5F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

id sub_1000DE638(uint64_t a1, uint64_t a2)
{
  id result = objc_retainBlock(*(id *)(a2 + 40));
  *(void *)(a1 + 40) = result;
  return result;
}

void sub_1000DE664(uint64_t a1)
{
}

void sub_1000DE66C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v5 = *(const __CFString **)(a1 + 32);
    id v6 = [v3 idsResponseCode];
    id v7 = [v3 responseError];
    unsigned int v8 = [v3 lastCourierAck];
    unsigned int v9 = [v3 lastCall];
    CFStringRef v10 = @"NO";
    *(_DWORD *)buf = 138413314;
    CFStringRef v46 = v5;
    __int16 v47 = 2048;
    if (v8) {
      CFStringRef v11 = @"YES";
    }
    else {
      CFStringRef v11 = @"NO";
    }
    id v48 = v6;
    if (v9) {
      CFStringRef v10 = @"YES";
    }
    __int16 v49 = 2112;
    id v50 = v7;
    __int16 v51 = 2112;
    CFStringRef v52 = v11;
    __int16 v53 = 2112;
    CFStringRef v54 = v10;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Group status notification message callback received { GUID: %@, responseCode: %lu, error: %@, lastCourerAck: %@, lastCall: %@ }", buf, 0x34u);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
  {
    uint64_t v12 = *(void *)(a1 + 32);
    id v13 = [v3 idsResponseCode];
    __int16 v14 = [v3 responseError];
    uint64_t v15 = [v3 lastCourierAck] ? @"YES" : @"NO";
    uint64_t v16 = [v3 lastCall] ? @"YES" : @"NO";
    id v43 = v15;
    uint64_t v44 = v16;
    id v38 = v13;
    uint64_t v42 = v14;
    uint64_t v36 = v12;
    _IDSLogTransport();

    if (_IDSShouldLog())
    {
      uint64_t v17 = *(void *)(a1 + 32);
      id v18 = objc_msgSend(v3, "idsResponseCode", v36, v13, v14, v15, v44);
      uint64_t v19 = [v3 responseError];
      if ([v3 lastCourierAck]) {
        CFStringRef v20 = @"YES";
      }
      else {
        CFStringRef v20 = @"NO";
      }
      if ([v3 lastCall]) {
        CFStringRef v21 = @"YES";
      }
      else {
        CFStringRef v21 = @"NO";
      }
      id v43 = (__CFString *)v20;
      uint64_t v44 = (__CFString *)v21;
      id v38 = v18;
      uint64_t v42 = v19;
      uint64_t v36 = v17;
      _IDSLogV();
    }
  }
  objc_msgSend(v3, "responseCode", v36, v38, v42, v43, v44);
  if ([v3 lastCourierAck]
    && !*(unsigned char *)(a1 + 72)
    && *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40))
  {
    id v22 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(a1 + 72)) {
        CFStringRef v23 = @"YES";
      }
      else {
        CFStringRef v23 = @"NO";
      }
      id v24 = objc_retainBlock(*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40));
      *(_DWORD *)buf = 138412546;
      CFStringRef v46 = v23;
      __int16 v47 = 2112;
      id v48 = v24;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Last Courier ack received for group status notification message { waitForMadridAcks: %@, pendingCompletionBlock: %@ }", buf, 0x16u);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
    {
      CFStringRef v25 = @"YES";
      id v26 = *(unsigned char *)(a1 + 72) ? @"YES" : @"NO";
      id v37 = v26;
      id v39 = objc_retainBlock(*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40));
      _IDSLogTransport();

      if (_IDSShouldLog())
      {
        if (!*(unsigned char *)(a1 + 72)) {
          CFStringRef v25 = @"NO";
        }
        id v37 = (__CFString *)v25;
        id v39 = objc_retainBlock(*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40));
        _IDSLogV();
      }
    }
    (*(void (**)(void, void))(*(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) + 16))(*(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40), *(void *)(a1 + 40));
    uint64_t v27 = *(void *)(*(void *)(a1 + 64) + 8);
    uint64_t v28 = *(void **)(v27 + 40);
    *(void *)(v27 + 40) = 0;
  }
  if (objc_msgSend(v3, "lastCall", v37, v39)
    && *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40))
  {
    int v29 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(a1 + 72)) {
        CFStringRef v30 = @"YES";
      }
      else {
        CFStringRef v30 = @"NO";
      }
      id v31 = objc_retainBlock(*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40));
      *(_DWORD *)buf = 138412546;
      CFStringRef v46 = v30;
      __int16 v47 = 2112;
      id v48 = v31;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Last Madrid ack received for group status notification message { waitForMadridAcks: %@, pendingCompletionBlock: %@ }", buf, 0x16u);
    }
    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        id v40 = objc_retainBlock(*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40));
        _IDSLogTransport();

        if (_IDSShouldLog())
        {
          id v41 = objc_retainBlock(*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40));
          _IDSLogV();
        }
      }
    }
    uint64_t v33 = *(void *)(a1 + 64);
    uint64_t v32 = a1 + 64;
    (*(void (**)(void, void))(*(void *)(*(void *)(v33 + 8) + 40) + 16))(*(void *)(*(void *)(v33 + 8) + 40), *(void *)(v32 - 24));
    uint64_t v34 = *(void *)(*(void *)v32 + 8);
    unint64_t v35 = *(void **)(v34 + 40);
    *(void *)(v34 + 40) = 0;
  }
}

id sub_1000DFDC8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  id v6 = [a2 objectForKey:v5];
  if (objc_opt_isKindOfClass())
  {
    id v7 = v6;
  }
  else
  {
    if (v6)
    {
      unsigned int v8 = +[IMRGLog registration];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
        sub_10070F6D4((uint64_t)v5, a1, v8);
      }
    }
    id v7 = 0;
  }

  return v7;
}

id sub_1000DFE84(id a1, NSString *a2)
{
  return +[IDSURI URIWithPrefixedURI:a2];
}

id sub_1000E085C(id a1, NSString *a2)
{
  return +[IDSURI URIWithPrefixedURI:a2];
}

void sub_1000E0C08(uint64_t a1, void *a2, void *a3, void *a4, void *a5, uint64_t a6, void *a7, uint64_t a8, void *a9)
{
  id v59 = a2;
  id v60 = a3;
  id v61 = a4;
  id v62 = a5;
  id v63 = a7;
  id v14 = a9;
  id v75 = objc_alloc_init((Class)NSMutableArray);
  id v77 = objc_alloc_init((Class)NSMutableSet);
  id v70 = objc_alloc_init((Class)NSMutableArray);
  long long v66 = (void *)a1;
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 72));
  long long v82 = 0u;
  long long v83 = 0u;
  long long v84 = 0u;
  long long v85 = 0u;
  id obj = v14;
  id v67 = [obj countByEnumeratingWithState:&v82 objects:v95 count:16];
  if (v67)
  {
    uint64_t v65 = *(void *)v83;
    uint64_t v74 = IDSRegistrationPropertySupportsMirage;
    uint64_t v73 = kIDSQRAllocateKey_RecipientPushToken;
    uint64_t v71 = kIDSQRAllocateKey_RecipientURI;
    uint64_t v72 = kIDSQRAllocateKey_RecipientSessionToken;
    do
    {
      uint64_t v15 = 0;
      do
      {
        if (*(void *)v83 != v65)
        {
          uint64_t v16 = v15;
          objc_enumerationMutation(obj);
          uint64_t v15 = v16;
        }
        uint64_t v69 = v15;
        uint64_t v17 = *(void **)(*((void *)&v82 + 1) + 8 * v15);
        id v18 = objc_msgSend(obj, "objectForKeyedSubscript:", v17, v54, v56);
        uint64_t v19 = OSLogHandleForTransportCategory();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v20 = [v18 count];
          *(_DWORD *)buf = 138412546;
          uint64_t v87 = v17;
          __int16 v88 = 1024;
          LODWORD(v89) = v20;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Look up peer with URI: %@, push token count: %u", buf, 0x12u);
        }

        if (os_log_shim_legacy_logging_enabled())
        {
          if (_IDSShouldLogTransport())
          {
            CFStringRef v54 = v17;
            id v56 = [v18 count];
            _IDSLogTransport();
            if (_IDSShouldLog())
            {
              id v21 = objc_msgSend(v18, "count", v17, v56);
              CFStringRef v54 = v17;
              id v56 = v21;
              _IDSLogV();
            }
          }
        }
        long long v80 = 0u;
        long long v81 = 0u;
        long long v78 = 0u;
        long long v79 = 0u;
        id v76 = v18;
        id v22 = 0;
        id v23 = [v76 countByEnumeratingWithState:&v78 objects:v94 count:16];
        if (v23)
        {
          uint64_t v24 = *(void *)v79;
          do
          {
            for (uint64_t i = 0; i != v23; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v79 != v24) {
                objc_enumerationMutation(v76);
              }
              id v26 = *(void **)(*((void *)&v78 + 1) + 8 * i);
              uint64_t v27 = objc_msgSend(v26, "pushToken", v54);
              if ([v77 containsObject:v27])
              {
                uint64_t v28 = OSLogHandleForTransportCategory();
                if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 138412290;
                  uint64_t v87 = v27;
                  _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Skipping duplicate token %@", buf, 0xCu);
                }

                if (os_log_shim_legacy_logging_enabled())
                {
                  if (_IDSShouldLogTransport())
                  {
                    CFStringRef v54 = v27;
                    _IDSLogTransport();
                    if (_IDSShouldLog())
                    {
                      CFStringRef v54 = v27;
                      _IDSLogV();
                    }
                  }
                }
              }
              else
              {
                int v29 = [v26 capabilities];
                if ([v29 valueForCapability:v74])
                {
                  CFStringRef v30 = [v26 pushToken];
                  [v70 addObject:v30];
                }
                [v77 addObject:v27];
                v93[0] = v27;
                v92[0] = v73;
                v92[1] = v72;
                id v31 = [v26 sessionToken];
                v92[2] = v71;
                v93[1] = v31;
                v93[2] = v17;
                uint64_t v32 = +[NSDictionary dictionaryWithObjects:v93 forKeys:v92 count:3];

                [v75 addObject:v32];
                uint64_t v33 = [v17 prefixedURI];
                unsigned int v34 = [v33 _appearsToBePseudonymID];

                if (v34)
                {
                  if (!v22) {
                    id v22 = objc_alloc_init((Class)NSMutableSet);
                  }
                  [v22 addObject:v27];
                }
              }
            }
            id v23 = [v76 countByEnumeratingWithState:&v78 objects:v94 count:16];
          }
          while (v23);
        }

        unint64_t v35 = +[IDSDSessionActiveParticipantsCache sharedInstance];
        [v35 updateParticipants:v22 forSessionID:v66[4]];

        uint64_t v15 = v69 + 1;
      }
      while ((id)(v69 + 1) != v67);
      id v67 = [obj countByEnumeratingWithState:&v82 objects:v95 count:16];
    }
    while (v67);
  }

  uint64_t v36 = [WeakRetained[10] objectForKeyedSubscript:v66[5]];
  BOOL v37 = v36 == 0;

  if (v37)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    [WeakRetained[10] setObject:Mutable forKeyedSubscript:v66[5]];
  }
  if (objc_msgSend(v70, "count", v54, v56))
  {
    id v39 = v70;
    if (v39)
    {
      id v40 = [WeakRetained[10] objectForKeyedSubscript:v66[5]];
      CFDictionarySetValue(v40, IDSRegistrationPropertySupportsMirage, v39);
    }
    else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      sub_10070F7F4();
    }

    id v41 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
    {
      id v43 = (void *)v66[4];
      uint64_t v42 = (void *)v66[5];
      uint64_t v44 = [WeakRetained[10] objectForKeyedSubscript:v42];
      *(_DWORD *)buf = 138412802;
      uint64_t v87 = v42;
      __int16 v88 = 2112;
      id v89 = v43;
      __int16 v90 = 2112;
      uint64_t v91 = v44;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "groupID: %@, sessionID: %@, %@", buf, 0x20u);
    }
    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        uint64_t v46 = v66[4];
        uint64_t v45 = v66[5];
        [WeakRetained[10] objectForKeyedSubscript:v45];
        long long v58 = v57 = v46;
        uint64_t v55 = v45;
        _IDSLogTransport();

        if (_IDSShouldLog())
        {
          uint64_t v48 = v66[4];
          uint64_t v47 = v66[5];
          objc_msgSend(WeakRetained[10], "objectForKeyedSubscript:", v47, v55, v57, v58);
          long long v58 = v57 = v48;
          uint64_t v55 = v47;
          _IDSLogV();
        }
      }
    }
  }
  if (objc_msgSend(v75, "count", v55, v57, v58))
  {
    [WeakRetained[4] setObject:v75 forKeyedSubscript:v66[5]];
    __int16 v49 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
    {
      id v50 = *(void **)(v66[7] + 32);
      *(_DWORD *)buf = 138412290;
      uint64_t v87 = v50;
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "Looked up _groupMemberPushTokens: %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
    uint64_t v51 = v66[8];
    if (v51) {
      (*(void (**)(uint64_t))(v51 + 16))(v51);
    }
  }
  else
  {
    CFStringRef v52 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v53 = (void *)v66[6];
      *(_DWORD *)buf = 138412546;
      uint64_t v87 = v53;
      __int16 v88 = 2112;
      id v89 = v63;
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "Could not look up the recipients' push tokens, IDs: %@, errors: %@ ", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
  }
}

void sub_1000E168C(void *a1)
{
  id v3 = +[IDSPeerIDManager sharedInstance];
  LOBYTE(v2) = 0;
  [v3 startQueryForURIs:a1[4] fromIdentity:a1[5] fromURI:a1[6] fromService:a1[7] forSending:1 forRefresh:0 isForced:v2 reason:@"SessionMemberLookup" completionBlock:a1[8]];
}

void sub_1000E2614(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    uint64_t v4 = [*(id *)(a1 + 32) dictionaryRepresentation];
    uint64_t v5 = *(void *)(a1 + 40);
    id v6 = [*(id *)(a1 + 48) prefixedURI];
    id v7 = [*(id *)(a1 + 56) unprefixedURI];
    [v3 receivedGroupSessionParticipantUpdate:v4 forTopic:v5 toIdentifier:v6 fromID:v7 context:*(void *)(a1 + 64)];
  }
  else
  {
    unsigned int v8 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unsigned int v9 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Did not find a client to handle receivedGroupSessionParticipantUpdate:forTopic: -- dropping broadcast", v9, 2u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
  }
}

void sub_1000E2A14(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    uint64_t v4 = [*(id *)(a1 + 32) dictionaryRepresentation];
    uint64_t v5 = *(void *)(a1 + 40);
    id v6 = [*(id *)(a1 + 48) prefixedURI];
    id v7 = [*(id *)(a1 + 56) unprefixedURI];
    [v3 receivedGroupSessionParticipantDataUpdate:v4 forTopic:v5 toIdentifier:v6 fromID:v7];
  }
  else
  {
    unsigned int v8 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unsigned int v9 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Did not find a client to handle receivedGroupSessionParticipantDataUpdate:forTopic: -- dropping broadcast", v9, 2u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
  }
}

id sub_1000E2B78(id a1, IDSURI *a2)
{
  return [(IDSURI *)a2 prefixedURI];
}

void sub_1000E2BA0(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, v9, OS_LOG_TYPE_FAULT, a4, &a9, 0x20u);
}

void sub_1000E3C54(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_1000E48C4(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = +[IDSFoundationLog IDSOffGridStateManager];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 138412290;
    id v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Publishing offgrid mode through StatusKit completed with error %@", (uint8_t *)&v6, 0xCu);
  }

  if (v3) {
    uint64_t v5 = 2;
  }
  else {
    uint64_t v5 = 1;
  }
  [*(id *)(a1 + 32) _setAndPersistOffGridMode:*(void *)(*(void *)(a1 + 32) + 88) publishStatus:v5];
  [*(id *)(a1 + 32) _updateClientsWithCurrentStateAndError:v3];
}

void sub_1000E49A8(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  int v6 = +[IDSFoundationLog IDSOffGridStateManager];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v7 = @"NO";
    if (a2) {
      CFStringRef v7 = @"YES";
    }
    int v9 = 138412546;
    CFStringRef v10 = v7;
    __int16 v11 = 2112;
    id v12 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Sent OffGridStatusDecryptionKey with Success %@, error %@", (uint8_t *)&v9, 0x16u);
  }

  if (((v5 == 0) & a2) != 0) {
    uint64_t v8 = 1;
  }
  else {
    uint64_t v8 = 2;
  }
  [*(id *)(a1 + 32) _setAndPersistOffGridMode:*(void *)(*(void *)(a1 + 32) + 88) publishStatus:v8];
  [*(id *)(a1 + 32) _updateClientsWithCurrentStateAndError:v5];
  [*(id *)(a1 + 32) _updateOffGridConnectActionWithPayloadKey:0];
}

void sub_1000E4AC8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = +[IDSFoundationLog IDSOffGridStateManager];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    id v10 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Got CTStewieRequestContext: %@", buf, 0xCu);
  }

  if (*(void *)(a1 + 32) && ([v3 reason] == (id)8 || objc_msgSend(v3, "reason") == (id)9)) {
    [*(id *)(a1 + 40) _updateOffGridConnectActionWithPayloadKey:*(void *)(a1 + 32)];
  }
  id v5 = *(void **)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 48);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_1000E4C2C;
  v7[3] = &unk_100981B98;
  void v7[4] = v5;
  id v8 = *(id *)(a1 + 32);
  [v5 _connectStewieWithContext:v3 options:v6 withCompletion:v7];
}

void sub_1000E4C2C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = +[IDSFoundationLog IDSOffGridStateManager];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 138412290;
    id v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Request stewie completed with error %@", (uint8_t *)&v8, 0xCu);
  }

  if (v3)
  {
    [*(id *)(a1 + 32) _updateOffGridConnectActionWithPayloadKey:0];
    [*(id *)(a1 + 32) _setAndPersistOffGridMode:*(void *)(*(void *)(a1 + 32) + 88) publishStatus:2];
    [*(id *)(a1 + 32) _updateClientsWithCurrentStateAndError:v3];
  }
  else if (*(void *)(a1 + 40))
  {
    [*(id *)(a1 + 32) _scheduleClearSendOnConnectTimer];
  }
  else
  {
    id v5 = +[IDSFoundationLog IDSOffGridStateManager];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      sub_10070FD24();
    }

    [*(id *)(a1 + 32) _updateOffGridConnectActionWithPayloadKey:0];
    [*(id *)(a1 + 32) _setAndPersistOffGridMode:*(void *)(*(void *)(a1 + 32) + 88) publishStatus:2];
    uint64_t v6 = *(void **)(a1 + 32);
    CFStringRef v7 = [v6 _errorForNoProvisionedPayload];
    [v6 _updateClientsWithCurrentStateAndError:v7];
  }
}

void sub_1000E4E54(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1)
  {
    id v2 = [*(id *)(*(void *)(a1 + 32) + 64) invitedHandles];
    (*(void (**)(uint64_t, id, void))(v1 + 16))(v1, v2, 0);
  }
}

void sub_1000E513C(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = +[IDSFoundationLog IDSOffGridStateManager];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = a1[4];
    if (a1[5]) {
      CFStringRef v6 = @"YES";
    }
    else {
      CFStringRef v6 = @"NO";
    }
    uint64_t v7 = a1[6];
    int v11 = 138413058;
    uint64_t v12 = v5;
    __int16 v13 = 2112;
    CFStringRef v14 = v6;
    __int16 v15 = 2112;
    uint64_t v16 = v7;
    __int16 v17 = 2112;
    id v18 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Completed request to send invite from sender handle %@ with payload %@ to %@ with error %@", (uint8_t *)&v11, 0x2Au);
  }

  if (!v3)
  {
    int v8 = +[IDSFoundationLog IDSOffGridStateManager];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v11) = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Reprovisioning on successful invite", (uint8_t *)&v11, 2u);
    }

    id v9 = (void *)a1[7];
    [v9 _provisionOnInviteDebounceTimeInterval];
    objc_msgSend(v9, "_scheduleOffGridPayloadProvisioningTimerWithInterval:shouldForce:", 1);
  }
  uint64_t v10 = a1[8];
  if (v10) {
    (*(void (**)(uint64_t, void, void, void, id))(v10 + 16))(v10, a1[6], a1[4], a1[5], v3);
  }
}

void sub_1000E5494(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = +[IDSFoundationLog IDSOffGridStateManager];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = a1[4];
    int v9 = 138412546;
    uint64_t v10 = v5;
    __int16 v11 = 2112;
    id v12 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Completed request to remove invites for handles %@ with error %@", (uint8_t *)&v9, 0x16u);
  }

  if (!v3)
  {
    CFStringRef v6 = +[IDSFoundationLog IDSOffGridStateManager];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v9) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Reprovisioning on successful invite removal", (uint8_t *)&v9, 2u);
    }

    uint64_t v7 = (void *)a1[5];
    [v7 _provisionOnInviteDebounceTimeInterval];
    objc_msgSend(v7, "_scheduleOffGridPayloadProvisioningTimerWithInterval:shouldForce:", 1);
  }
  uint64_t v8 = a1[6];
  if (v8) {
    (*(void (**)(uint64_t, void, id))(v8 + 16))(v8, a1[4], v3);
  }
}

void sub_1000E56F8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = +[IDSFoundationLog IDSOffGridStateManager];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v7 = 138412546;
    uint64_t v8 = v5;
    __int16 v9 = 2112;
    id v10 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Completed request to remove all invites %@ with error %@", (uint8_t *)&v7, 0x16u);
  }

  uint64_t v6 = *(void *)(a1 + 40);
  if (v6) {
    (*(void (**)(uint64_t, void, id))(v6 + 16))(v6, *(void *)(a1 + 32), v3);
  }
}

void sub_1000E5A58(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = +[IDSFoundationLog IDSOffGridStateManager];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 138412290;
    id v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Got CTStewieRequestContext: %@", (uint8_t *)&v6, 0xCu);
  }

  id v5 = objc_alloc_init((Class)IDSOffGridModeOptions);
  [v5 setEntryPointSource:@"connectStewieWithCompletion:"];
  [*(id *)(a1 + 32) _connectStewieWithContext:v3 options:v5 withCompletion:*(void *)(a1 + 40)];
}

void sub_1000E5D3C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = +[IDSFoundationLog IDSOffGridStateManager];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 138412290;
    id v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Exit Stewie completed with error %@", (uint8_t *)&v6, 0xCu);
  }

  uint64_t v5 = *(void *)(a1 + 32);
  if (v5) {
    (*(void (**)(uint64_t, id))(v5 + 16))(v5, v3);
  }
}

void sub_1000E5F54(uint64_t a1, void *a2)
{
  id v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void **)(a1 + 40);
  id v7 = a2;
  id v5 = [v4 reason];
  int v6 = [*(id *)(a1 + 48) entryPointSource];
  [v3 _reportOffGridEntryMetricWithService:v5 source:v6 success:v7 == 0];

  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
}

void sub_1000E60E4(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = +[IDSFoundationLog IDSOffGridStateManager];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 138412290;
    id v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Disabled offgrid mode through internet with error: %@", (uint8_t *)&v6, 0xCu);
  }

  if (v3) {
    uint64_t v5 = 2;
  }
  else {
    uint64_t v5 = 1;
  }
  [*(id *)(a1 + 32) _setAndPersistOffGridMode:*(void *)(*(void *)(a1 + 32) + 88) publishStatus:v5];
  [*(id *)(a1 + 32) _updateClientsWithCurrentStateAndError:v3];
}

void sub_1000E64EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E650C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1000E651C(uint64_t a1)
{
}

void sub_1000E6524(uint64_t a1, uint64_t a2, void *a3)
{
  id v6 = a3;
  if (v6) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), a3);
  }
  else {
    [*(id *)(a1 + 32) addObjectsFromArray:a2];
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

uint64_t sub_1000E65A8(void *a1)
{
  id v2 = +[IDSFoundationLog IDSOffGridStateManager];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = *(void *)(*(void *)(a1[6] + 8) + 40);
    int v6 = 138412546;
    uint64_t v7 = v3;
    __int16 v8 = 2112;
    uint64_t v9 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Completed fetch contacts %@ with fetchError %@", (uint8_t *)&v6, 0x16u);
  }

  uint64_t result = a1[5];
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, void))(result + 16))(result, a1[4], *(void *)(*(void *)(a1[6] + 8) + 40));
  }
  return result;
}

void sub_1000E69CC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = +[IDSFoundationLog IDSOffGridStateManager];
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134218242;
    id v26 = [v5 count];
    __int16 v27 = 2112;
    id v28 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Completed fetch of emergency handles { count: %ld } with error %@", buf, 0x16u);
  }

  if (v6)
  {
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    id v18 = 0;
    id v19 = v5;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    id v8 = v5;
    id v9 = [v8 countByEnumeratingWithState:&v20 objects:v24 count:16];
    if (v9)
    {
      id v10 = v9;
      uint64_t v11 = *(void *)v21;
      do
      {
        id v12 = 0;
        do
        {
          if (*(void *)v21 != v11) {
            objc_enumerationMutation(v8);
          }
          __int16 v13 = objc_msgSend(*(id *)(*((void *)&v20 + 1) + 8 * (void)v12), "phoneNumber", v18, v19, (void)v20);
          CFStringRef v14 = (void *)_IDSCopyIDForPhoneNumberWithOptions();
          if (v14)
          {
            id v15 = objc_alloc((Class)IDSOffGridContactInfo);
            uint64_t v16 = +[IDSURI URIWithUnprefixedURI:v14];
            id v17 = [v15 initWithURI:v16 type:1];

            [*(id *)(a1 + 32) addObject:v17];
          }

          id v12 = (char *)v12 + 1;
        }
        while (v10 != v12);
        id v10 = [v8 countByEnumeratingWithState:&v20 objects:v24 count:16];
      }
      while (v10);
    }

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    id v6 = v18;
    id v5 = v19;
  }
}

id sub_1000E6DC8(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _offGridResetTimerFired];
}

id sub_1000E6EB8(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _resetOffGridModeIfRequired];
}

id sub_1000E7498(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _emergencyContactsDidChange];
}

id sub_1000E74A0(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _familyContactsDidChange];
}

void sub_1000E763C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void **)(a1 + 32);
  if (a3)
  {
    id v5 = v4;
  }
  else
  {
    id v5 = [v4 arrayByAddingObjectsFromArray:a2];
  }
  id v6 = v5;
  [*(id *)(a1 + 40) _calloutToDelegateWithUpdatedContacts:v5];
}

id sub_1000E7838(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _offGridPayloadProvisioningTimerFiredShouldForce:*(unsigned __int8 *)(a1 + 40)];
}

id sub_1000E7940(uint64_t a1)
{
  return [*(id *)(a1 + 32) _provisionOffGridPayloadsShouldForce:*(unsigned __int8 *)(a1 + 40)];
}

void sub_1000E804C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = +[NSDate now];
  uint64_t v8 = *(void *)(a1 + 32);
  id v9 = *(void **)(v8 + 152);
  *(void *)(v8 + 152) = v7;

  objc_storeStrong((id *)(*(void *)(a1 + 32) + 160), a3);
  if (v6)
  {
    id v10 = +[IDSFoundationLog IDSOffGridStateManager];
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      sub_10070FF34((uint64_t)v6, v10);
    }

    uint64_t v11 = *(void **)(a1 + 32);
    [v11 _failedProvisionInterval];
    objc_msgSend(v11, "_scheduleOffGridPayloadProvisioningTimerWithInterval:shouldForce:", 0);
  }
  else
  {
    [*(id *)(*(void *)(a1 + 32) + 144) setObject:v5 forKey:@"provisioned-payloads"];
    [*(id *)(*(void *)(a1 + 32) + 144) removeObjectForKey:@"sent-payload-id"];
    [*(id *)(*(void *)(a1 + 32) + 144) persistImmediately];
    id v13 = *(id *)(a1 + 40);
    cut_dispatch_log_queue();
    id v12 = *(void **)(a1 + 32);
    [v12 _successfulProvisionInterval];
    objc_msgSend(v12, "_scheduleOffGridPayloadProvisioningTimerWithInterval:shouldForce:", 0);
  }
  [*(id *)(a1 + 32) _markProvisionRequestCompleted];
}

void sub_1000E81D4(uint64_t a1)
{
  id v2 = +[IDSFoundationLog IDSOffGridStateManager_oversized];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = 138412290;
    uint64_t v5 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Persisted provisioned payloads %@", (uint8_t *)&v4, 0xCu);
  }
}

uint64_t sub_1000E8F08(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = +[NSNumber numberWithBool:a2];
  if (v3) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), kCTStewieAreAllPrimaryContactsReachableViaIML, v3);
  }

  [*(id *)(a1 + 40) setMetadata:*(void *)(a1 + 32)];
  int v4 = *(uint64_t (**)(void))(*(void *)(a1 + 48) + 16);

  return v4();
}

void sub_1000E9640(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v5 && [v5 count])
  {
    id v19 = v6;
    uint64_t v7 = +[IDSDaemon sharedInstance];
    uint64_t v8 = [v7 persistenceManager];

    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    id v20 = v5;
    id v9 = v5;
    id v10 = [v9 countByEnumeratingWithState:&v21 objects:v25 count:16];
    if (v10)
    {
      id v11 = v10;
      uint64_t v12 = *(void *)v22;
      uint64_t v13 = IDSServiceNameiMessageLite;
      while (2)
      {
        for (uint64_t i = 0; i != v11; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v22 != v12) {
            objc_enumerationMutation(v9);
          }
          id v15 = *(void **)(*((void *)&v21 + 1) + 8 * i);
          uint64_t v16 = +[IDSDAccountController sharedInstance];
          id v17 = [(id)v16 registeredLocalURIsOnService:v13];

          id v18 = [v15 uri];
          LOBYTE(v16) = [v8 hasUsableSenderKeyFor:v18 fromAny:v17];

          if ((v16 & 1) == 0)
          {
            (*(void (**)(void))(*(void *)(a1 + 32) + 16))();

            goto LABEL_14;
          }
        }
        id v11 = [v9 countByEnumeratingWithState:&v21 objects:v25 count:16];
        if (v11) {
          continue;
        }
        break;
      }
    }

    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
LABEL_14:

    id v6 = v19;
    id v5 = v20;
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

id sub_1000E99BC(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _clearSendKeyOnConnectTimerFired];
}

id sub_1000E9AAC(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _clearSendKeyOnConnect];
}

void sub_1000EA02C(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  id v6 = +[IDSFoundationLog IDSOffGridStateManager];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v7 = @"NO";
    if (a2) {
      CFStringRef v7 = @"YES";
    }
    int v9 = 138412546;
    CFStringRef v10 = v7;
    __int16 v11 = 2112;
    id v12 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Sent OffGridStatusDecryptionKey on connect with Success %@, error %@", (uint8_t *)&v9, 0x16u);
  }

  uint64_t v8 = 2;
  if (!v5 && a2)
  {
    objc_msgSend(*(id *)(a1 + 32), "_markPayloadAsSentForDecryptionKey:", *(void *)(*(void *)(a1 + 32) + 176), 2);
    uint64_t v8 = 1;
  }
  [*(id *)(a1 + 32) _setAndPersistOffGridMode:*(void *)(*(void *)(a1 + 32) + 88) publishStatus:v8];
  [*(id *)(a1 + 32) _updateClientsWithCurrentStateAndError:v5];
  [*(id *)(a1 + 32) _updateOffGridConnectActionWithPayloadKey:0];
}

void sub_1000EAE10(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_1000EAE2C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = +[IDSFoundationLog IDSOffGridStateManager];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = (void *)*((void *)WeakRetained + 11);
    uint64_t v4 = *((void *)WeakRetained + 12);
    *(_DWORD *)buf = 134218240;
    id v12 = v3;
    __int16 v13 = 2048;
    uint64_t v14 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Current OffGrid Mode:%ld Publish Status:%ld", buf, 0x16u);
  }

  id v5 = +[IDSFoundationLog IDSOffGridStateManager];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = (void *)*((void *)WeakRetained + 19);
    uint64_t v7 = *((void *)WeakRetained + 20);
    *(_DWORD *)buf = 138412546;
    id v12 = v6;
    __int16 v13 = 2112;
    uint64_t v14 = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Last provision details: Time %@ Error %@", buf, 0x16u);
  }

  uint64_t v8 = +[IDSFoundationLog IDSOffGridStateManager];
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = [*((id *)WeakRetained + 18) objectForKey:@"sent-payload-id"];
    *(_DWORD *)buf = 138412290;
    id v12 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Sent payload identifiers: %@", buf, 0xCu);
  }
  cut_dispatch_log_queue();
  cut_dispatch_log_queue();

  return 0;
}

void sub_1000EB06C(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog IDSOffGridStateManager_oversized];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = [*(id *)(*(void *)(a1 + 32) + 144) objectForKey:@"provisioned-payloads"];
    int v4 = 138412290;
    id v5 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Provisioned payloads \n%@", (uint8_t *)&v4, 0xCu);
  }
}

void sub_1000EB138(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog IDSOffGridStateManager_oversized];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = [*(id *)(*(void *)(a1 + 32) + 64) invitedHandles];
    int v4 = 138412290;
    id v5 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Invited handles: \n%@", (uint8_t *)&v4, 0xCu);
  }
}

Class sub_1000EB4F8(uint64_t a1)
{
  sub_1000EB550();
  Class result = objc_getClass("HKMedicalIDStore");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    sub_1007100F4();
  }
  qword_100A4A630 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_1000EB550()
{
  v0[0] = 0;
  if (!qword_100A4A638)
  {
    v0[1] = _NSConcreteStackBlock;
    v0[2] = (void *)3221225472;
    v0[3] = sub_1000EB644;
    v0[4] = &unk_10097EA18;
    v0[5] = v0;
    long long v1 = off_100981E10;
    uint64_t v2 = 0;
    qword_100A4A638 = _sl_dlopen();
  }
  if (!qword_100A4A638) {
    sub_100710170(v0);
  }
  if (v0[0]) {
    free(v0[0]);
  }
}

uint64_t sub_1000EB644()
{
  uint64_t result = _sl_dlopen();
  qword_100A4A638 = result;
  return result;
}

Class sub_1000EB6B8(uint64_t a1)
{
  sub_1000EB550();
  Class result = objc_getClass("HKHealthStore");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    sub_1007101F0();
  }
  qword_100A4A640 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_1000ED1C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t sub_1000ED1EC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1000ED1FC(uint64_t a1)
{
}

void sub_1000ED204(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = [*(id *)(a1 + 32) _registeredIdentityTimestamps];
  (*(void (**)(uint64_t, void *))(v2 + 16))(v2, v3);

  int v4 = +[IDSDRegistrationListener sharedInstance];
  [v4 removeBlockForIdentifier:*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40)];

  id v5 = +[IDSRegistrationKeyManager sharedInstance];
  [v5 setForceRoll:*(unsigned __int8 *)(a1 + 56)];
}

uint64_t sub_1000ED768(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

id sub_1000EDEAC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  id v6 = [a2 objectForKey:v5];
  if (objc_opt_isKindOfClass())
  {
    id v7 = v6;
  }
  else
  {
    if (v6)
    {
      uint64_t v8 = +[IMRGLog registration];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
        sub_10071026C((uint64_t)v5, a1, v8);
      }
    }
    id v7 = 0;
  }

  return v7;
}

void sub_1000EE230(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v6 = *(void *)(a1 + 32);
  id v7 = a4;
  id v8 = a2;
  objc_msgSend(a3, "__imArrayByApplyingBlock:", &stru_100981E98);
  id v9 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id, id, id))(v6 + 16))(v6, v8, v9, v7);
}

id sub_1000EE2C8(id a1, IDSEndpoint *a2)
{
  v52[0] = @"URI";
  uint64_t v2 = a2;
  uint64_t v51 = [(IDSEndpoint *)v2 URI];
  uint64_t v3 = [v51 description];
  id v50 = (void *)v3;
  if (v3) {
    CFStringRef v4 = (const __CFString *)v3;
  }
  else {
    CFStringRef v4 = @"(null)";
  }
  v53[0] = v4;
  v52[1] = @"Push Token";
  __int16 v49 = [(IDSEndpoint *)v2 pushToken];
  uint64_t v5 = [v49 debugDescription];
  uint64_t v48 = (void *)v5;
  if (v5) {
    CFStringRef v6 = (const __CFString *)v5;
  }
  else {
    CFStringRef v6 = @"(null)";
  }
  v53[1] = v6;
  v52[2] = @"Session Token";
  uint64_t v47 = [(IDSEndpoint *)v2 sessionToken];
  uint64_t v7 = [v47 debugDescription];
  uint64_t v46 = (void *)v7;
  if (v7) {
    CFStringRef v8 = (const __CFString *)v7;
  }
  else {
    CFStringRef v8 = @"(null)";
  }
  v53[2] = v8;
  v52[3] = @"Refresh Date";
  uint64_t v45 = [(IDSEndpoint *)v2 refreshDate];
  uint64_t v9 = [v45 description];
  uint64_t v44 = (void *)v9;
  if (v9) {
    CFStringRef v10 = (const __CFString *)v9;
  }
  else {
    CFStringRef v10 = @"(null)";
  }
  v53[3] = v10;
  v52[4] = @"Expire Date";
  id v43 = [(IDSEndpoint *)v2 expireDate];
  uint64_t v11 = [v43 description];
  uint64_t v42 = (void *)v11;
  if (v11) {
    CFStringRef v12 = (const __CFString *)v11;
  }
  else {
    CFStringRef v12 = @"(null)";
  }
  v53[4] = v12;
  v52[5] = @"Legacy Message Protection Version";
  id v41 = +[NSNumber numberWithChar:[(IDSEndpoint *)v2 legacyVersion]];
  uint64_t v13 = [v41 description];
  id v40 = (void *)v13;
  if (v13) {
    CFStringRef v14 = (const __CFString *)v13;
  }
  else {
    CFStringRef v14 = @"(null)";
  }
  v53[5] = v14;
  v52[6] = @"Legacy Message Protection Identity";
  id v39 = [(IDSEndpoint *)v2 serializedLegacyPublicIdentity];
  uint64_t v15 = [v39 description];
  id v38 = (void *)v15;
  if (v15) {
    CFStringRef v16 = (const __CFString *)v15;
  }
  else {
    CFStringRef v16 = @"(null)";
  }
  v53[6] = v16;
  v52[7] = @"NGM Message Protection Version";
  BOOL v37 = +[NSNumber numberWithShort:[(IDSEndpoint *)v2 ngmVersion]];
  uint64_t v17 = [v37 description];
  id v18 = (void *)v17;
  if (v17) {
    CFStringRef v19 = (const __CFString *)v17;
  }
  else {
    CFStringRef v19 = @"(null)";
  }
  v53[7] = v19;
  v52[8] = @"NGM Message Protection Prekey";
  uint64_t v36 = [(IDSEndpoint *)v2 serializedNGMDevicePrekey];
  uint64_t v20 = [v36 description];
  long long v21 = (void *)v20;
  if (v20) {
    CFStringRef v22 = (const __CFString *)v20;
  }
  else {
    CFStringRef v22 = @"(null)";
  }
  v53[8] = v22;
  v52[9] = @"KT Loggable Data";
  long long v23 = [(IDSEndpoint *)v2 KTLoggableData];
  uint64_t v24 = [v23 description];
  CFStringRef v25 = (void *)v24;
  if (v24) {
    CFStringRef v26 = (const __CFString *)v24;
  }
  else {
    CFStringRef v26 = @"(null)";
  }
  v53[9] = v26;
  v52[10] = @"KT Device Signature";
  __int16 v27 = [(IDSEndpoint *)v2 KTDeviceSignature];
  uint64_t v28 = [v27 description];
  int v29 = (void *)v28;
  if (v28) {
    CFStringRef v30 = (const __CFString *)v28;
  }
  else {
    CFStringRef v30 = @"(null)";
  }
  v53[10] = v30;
  v52[11] = @"KT Mismatched Account Flag";
  if ([(IDSEndpoint *)v2 mismatchedAccountFlag]) {
    CFStringRef v31 = @"YES";
  }
  else {
    CFStringRef v31 = @"NO";
  }
  v53[11] = v31;
  v52[12] = @"KT Capable Flag";
  unsigned int v32 = [(IDSEndpoint *)v2 ktCapableFlag];

  if (v32) {
    CFStringRef v33 = @"YES";
  }
  else {
    CFStringRef v33 = @"NO";
  }
  v53[12] = v33;
  unsigned int v34 = +[NSDictionary dictionaryWithObjects:v53 forKeys:v52 count:13];

  return v34;
}

void sub_1000EE7C8(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = a2;
  sub_1000EE844(a3);
  id v6 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id, id))(v4 + 16))(v4, v5, v6);
}

id sub_1000EE844(void *a1)
{
  id v1 = a1;
  uint64_t v2 = [v1 userInfo];
  id v3 = [v2 mutableCopy];

  uint64_t v4 = [v3 objectForKeyedSubscript:NSUnderlyingErrorKey];
  if (v4)
  {
    id v5 = (void *)v4;
    id v6 = [v3 objectForKeyedSubscript:NSUnderlyingErrorKey];
    objc_opt_class();
    char isKindOfClass = objc_opt_isKindOfClass();

    if (isKindOfClass)
    {
      CFStringRef v8 = [v1 userInfo];
      uint64_t v9 = [v8 objectForKeyedSubscript:NSUnderlyingErrorKey];
      CFStringRef v10 = sub_1000EE844();
      [v3 setObject:v10 forKeyedSubscript:NSUnderlyingErrorKey];
    }
  }
  id v11 = [v1 domain];
  if (v11)
  {
    id v12 = [v1 code];

    if (v12)
    {
      id v13 = objc_alloc((Class)NSError);
      CFStringRef v14 = [v1 domain];
      id v11 = objc_msgSend(v13, "initWithDomain:code:userInfo:", v14, objc_msgSend(v1, "code"), v3);
    }
    else
    {
      id v11 = 0;
    }
  }

  return v11;
}

void sub_1000EEAC4(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  sub_1000EE844(a2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v3);
}

uint64_t sub_1000EEBD0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1000EEC8C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1000EED48(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1000EEE04(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000EEFE0(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  sub_1000EE844(a2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v3);
}

void sub_1000EF5BC(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 state] == (id)1)
  {
    uint64_t v4 = *(void *)(a1 + 40);
    id v5 = [v3 error];
    (*(void (**)(uint64_t, void, void *))(v4 + 16))(v4, 0, v5);
  }
  else
  {
    id v6 = [v3 value];
    v27[0] = _NSConcreteStackBlock;
    v27[1] = 3221225472;
    v27[2] = sub_1000EF858;
    v27[3] = &unk_100981F60;
    id v7 = objc_alloc_init((Class)NSMutableString);
    id v28 = v7;
    CFStringRef v8 = objc_retainBlock(v27);
    uint64_t v9 = *(void *)(a1 + 32);
    if (v9)
    {
      CFStringRef v10 = [v6 clientDatasByServiceType];
      id v11 = [v10 objectForKeyedSubscript:*(void *)(a1 + 32)];
      ((void (*)(void *, uint64_t, void *))v8[2])(v8, v9, v11);
    }
    else
    {
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      CFStringRef v10 = [v6 clientDatasByServiceType];
      id v12 = [v10 countByEnumeratingWithState:&v23 objects:v29 count:16];
      if (v12)
      {
        id v13 = v12;
        id v21 = v7;
        id v22 = v3;
        uint64_t v14 = *(void *)v24;
        do
        {
          for (uint64_t i = 0; i != v13; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v24 != v14) {
              objc_enumerationMutation(v10);
            }
            uint64_t v16 = *(void *)(*((void *)&v23 + 1) + 8 * i);
            uint64_t v17 = [v6 clientDatasByServiceType];
            id v18 = [v17 objectForKeyedSubscript:v16];
            ((void (*)(void *, uint64_t, void *))v8[2])(v8, v16, v18);
          }
          id v13 = [v10 countByEnumeratingWithState:&v23 objects:v29 count:16];
        }
        while (v13);
        id v3 = v22;
        id v7 = v21;
      }
    }

    uint64_t v19 = *(void *)(a1 + 40);
    id v20 = [v7 copy];
    (*(void (**)(uint64_t, id, void))(v19 + 16))(v19, v20, 0);
  }
}

void sub_1000EF858(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4 = *(void **)(a1 + 32);
  id v5 = a2;
  id v6 = [a3 debugDescription];
  [v4 appendFormat:@"%@ => %@\n", v5, v6];
}

uint64_t sub_1000EFE30(uint64_t a1)
{
  return _IDSTransportThreadAssertRealTimeMode(*(unsigned __int8 *)(a1 + 32));
}

id sub_1000EFEEC(id a1, id a2)
{
  id v2 = a2;
  id v3 = objc_alloc((Class)NSDate);
  [v2 doubleValue];
  double v5 = v4;

  id v6 = [v3 initWithTimeIntervalSince1970:v5];

  return v6;
}

void sub_1000F01BC(uint64_t a1)
{
  id v4 = +[IDSDaemon sharedInstance];
  id v2 = [v4 firewallNotificationCenter];
  id v3 = [objc_alloc((Class)IDSURI) initWithUnprefixedURI:*(void *)(a1 + 32)];
  [v2 postNotificationForURI:v3 onService:*(void *)(a1 + 40) shouldRateLimit:0 command:&off_1009D0FC0];
}

id sub_1000F0414(uint64_t a1)
{
  return +[IDSTemporaryPhoneAlertManager presentSuccessAlertForUser:*(void *)(a1 + 32)];
}

id sub_1000F0428(uint64_t a1)
{
  return +[IDSTemporaryPhoneAlertManager attemptPresentationOfNearExpirationAlertForUser:*(void *)(a1 + 32)];
}

id sub_1000F043C(uint64_t a1)
{
  return +[IDSTemporaryPhoneAlertManager attemptPresentationOfExpirationAlertForUser:*(void *)(a1 + 32)];
}

uint64_t sub_1000F0820(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1000F09A4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000F0D0C(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7, void *a8)
{
  id v28 = a2;
  id v14 = a3;
  id v15 = a4;
  id v16 = a5;
  id v17 = a6;
  id v18 = a8;
  uint64_t v19 = *(void **)(a1 + 32);
  if (!v19
    || ([v28 processName],
        id v20 = objc_claimAutoreleasedReturnValue(),
        unsigned int v21 = [v19 containsObject:v20],
        v20,
        v21))
  {
    id v22 = [v28 processName];
    long long v23 = +[NSMutableString stringWithFormat:](NSMutableString, "stringWithFormat:", @"%@[%lld]\n", v22, (int)[v28 pid]);

    sub_1000F0F74(v23, @"services:", 1);
    sub_1000F1010(v23, v14, 2);
    sub_1000F0F74(v23, @"notification services:", 1);
    sub_1000F1010(v23, v15, 2);
    sub_1000F0F74(v23, @"entitlements:", 1);
    long long v24 = [v16 dictionaryRepresentation];
    sub_1000F1010(v23, v24, 2);

    sub_1000F0F74(v23, @"commands:", 1);
    long long v25 = [v17 allObjects];
    long long v26 = [v25 sortedArrayUsingSelector:"compare:"];

    sub_1000F1010(v23, v26, 2);
    sub_1000F0F74(v23, @"capabilities:", 1);
    __int16 v27 = IDSPrettyListOfEnabledCapabilities();
    sub_1000F1010(v23, v27, 2);

    sub_1000F0F74(v23, @"bundle ID:", 1);
    sub_1000F1010(v23, v18, 2);
    [*(id *)(a1 + 40) addObject:v23];
  }
}

void sub_1000F0F74(void *a1, void *a2, int a3)
{
  uint64_t v4 = 2 * a3;
  id v5 = a2;
  id v6 = a1;
  id v7 = [&stru_10099BE78 stringByPaddingToLength:v4 withString:@" " startingAtIndex:0];
  [v6 appendFormat:@"%@%@\n", v7, v5];
}

void sub_1000F1010(void *a1, void *a2, uint64_t a3)
{
  id v5 = a1;
  id v6 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass() & 1) != 0 || (objc_opt_class(), (objc_opt_isKindOfClass()))
  {
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    id v7 = v6;
    id v8 = [(__CFString *)v7 countByEnumeratingWithState:&v26 objects:v31 count:16];
    if (v8)
    {
      id v9 = v8;
      uint64_t v10 = *(void *)v27;
      do
      {
        for (uint64_t i = 0; i != v9; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v27 != v10) {
            objc_enumerationMutation(v7);
          }
          sub_1000F1010(v5, *(void *)(*((void *)&v26 + 1) + 8 * i), a3);
        }
        id v9 = [(__CFString *)v7 countByEnumeratingWithState:&v26 objects:v31 count:16];
      }
      while (v9);
    }

    if ((objc_opt_respondsToSelector() & 1) != 0 && ![(__CFString *)v7 count]) {
      goto LABEL_22;
    }
  }
  else
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      unsigned int v21 = v5;
      id v20 = v6;
      goto LABEL_24;
    }
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    id v12 = v6;
    id v13 = [(__CFString *)v12 countByEnumeratingWithState:&v22 objects:v30 count:16];
    if (v13)
    {
      id v14 = v13;
      uint64_t v15 = *(void *)v23;
      do
      {
        for (j = 0; j != v14; j = (char *)j + 1)
        {
          if (*(void *)v23 != v15) {
            objc_enumerationMutation(v12);
          }
          uint64_t v17 = *(void *)(*((void *)&v22 + 1) + 8 * (void)j);
          id v18 = +[NSString stringWithFormat:@"%@:", v17];
          sub_1000F1010(v5, v18, a3);

          uint64_t v19 = [(__CFString *)v12 objectForKeyedSubscript:v17];
          sub_1000F1010(v5, v19, (a3 + 1));
        }
        id v14 = [(__CFString *)v12 countByEnumeratingWithState:&v22 objects:v30 count:16];
      }
      while (v14);
    }

    if (![(__CFString *)v12 count])
    {
LABEL_22:
      id v20 = @"(None)";
      unsigned int v21 = v5;
LABEL_24:
      sub_1000F0F74(v21, v20, a3);
    }
  }
}

void sub_1000F1380(id a1)
{
  qword_100A4A650 = objc_alloc_init(IDSTrafficMonitor);

  _objc_release_x1();
}

id sub_1000F166C(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _dailyTimerHandler];
}

id sub_1000F1730(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _hourlyTimerHandler];
}

void sub_1000F3DB4(id a1)
{
  qword_100A4A660 = objc_alloc_init(IDSQuickSwitchHelper);

  _objc_release_x1();
}

void sub_1000F4258(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    uint64_t v4 = v3;
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  else
  {
    id v5 = +[IDSPairingManager sharedInstance];
    id v6 = (char *)[v5 activatePairedDeviceWithCBUUID:*(void *)(a1 + 32)];

    id v7 = +[IDSUTunDeliveryController sharedInstance];
    [v7 addUTunPeerWithDeviceUniqueID:IDSDeviceDefaultPairedDeviceUniqueID btuuid:*(void *)(a1 + 32)];

    id v8 = +[IDSUTunDeliveryController sharedInstance];
    [v8 prepareForQuickSwitch];

    if ((unint64_t)(v6 - 2) >= 3)
    {
      uint64_t v10 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v23) = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Finishing up switching", (uint8_t *)&v23, 2u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        _IDSLogV();
      }
      id v11 = +[IDSUTunController sharedInstance];
      [v11 addPairedDevice:*(void *)(a1 + 32)];

      id v12 = +[IDSPairingManager sharedInstance];
      [v12 ensureCommunicationWithActivePairedDeviceIsPossible];

      id v13 = +[IDSUTunDeliveryController sharedInstance];
      [v13 updatecloudDeliveryStateOnDefaultPeer];

      id v14 = +[IDSAccountSync sharedInstance];
      [v14 resetAndResynchronizeEverything];

      uint64_t v15 = +[IDSDaemon sharedInstance];
      [v15 _processStoredMessagesIncludingClassD:1];

      if (*(unsigned char *)(a1 + 64))
      {
        id v9 = +[IDSUTunDeliveryController sharedInstance];
        [v9 ensureLocalSetupInProgressConsistencyAfterQWS];
      }
      else
      {
        id v16 = +[IDSPairingManager sharedInstance];
        id v9 = [v16 pairedDeviceUniqueID];

        uint64_t v17 = +[IDSDaemon sharedInstance];
        id v18 = [v17 broadcasterWithMessageContext:0];

        [v18 didSwitchActivePairedDevice:v9];
      }
      uint64_t v4 = 0;
    }
    else
    {
      uint64_t v4 = +[NSError errorWithDomain:IDSLocalPairingErrorDomain code:qword_100794180[(void)(v6 - 2)] userInfo:0];
      id v9 = +[IMRGLog watchPairing];
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        int v23 = 138412290;
        double v24 = *(double *)&v4;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "QuickSwitch initiated with error: %@", (uint8_t *)&v23, 0xCu);
      }
    }

    uint64_t v19 = *(void *)(a1 + 48);
    if (v19) {
      (*(void (**)(uint64_t, void *))(v19 + 16))(v19, v4);
    }
    [*(id *)(a1 + 40) _setIsQuickSwitchingToAnotherDevice:0];
    id v20 = +[IMRGLog watchPairing];
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      +[NSDate timeIntervalSinceReferenceDate];
      double v22 = v21 - *(double *)(a1 + 56);
      int v23 = 134217984;
      double v24 = v22;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "QuickSwitch time %f", (uint8_t *)&v23, 0xCu);
    }
  }
}

void sub_1000F477C(uint64_t a1)
{
  id v2 = +[IDSPairingManager sharedInstance];
  id v3 = [v2 pairedDeviceUniqueID];

  if ([v3 length])
  {
    uint64_t v32 = a1;
    CFStringRef v33 = v3;
    uint64_t v4 = +[IDSDAccountController sharedInstance];
    id v5 = [v4 accountsOfAdHocType:2];

    id v6 = objc_alloc_init((Class)NSMutableSet);
    long long v37 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    id v7 = v5;
    id v8 = [v7 countByEnumeratingWithState:&v37 objects:v41 count:16];
    if (v8)
    {
      id v9 = v8;
      uint64_t v10 = *(void *)v38;
      do
      {
        for (uint64_t i = 0; i != v9; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v38 != v10) {
            objc_enumerationMutation(v7);
          }
          uint64_t v12 = *(void *)(*((void *)&v37 + 1) + 8 * i);
          id v13 = +[IDSDAccountController sharedInstance];
          id v14 = [v13 accountWithUniqueID:v12];

          uint64_t v15 = [v14 service];
          unsigned __int8 v16 = [v15 allowPendingMessagesForInactiveDevice];

          if ((v16 & 1) == 0) {
            [v6 addObject:v12];
          }
        }
        id v9 = [v7 countByEnumeratingWithState:&v37 objects:v41 count:16];
      }
      while (v9);
    }

    a1 = v32;
    if (*(unsigned char *)(v32 + 40))
    {
      uint64_t v17 = [v6 allObjects];
      id v3 = v33;
      +[IDSDMessageStore markAllMessageAsPendingDeleteForAccounts:v17 withDestinationDevice:v33];
    }
    else
    {
      id v3 = v33;
      +[IDSDMessageStore markOutgoingMessagesAsUnsentForDestination:v33];
    }
  }
  if (*(unsigned char *)(a1 + 40))
  {
    id v18 = +[IDSPairingManager sharedInstance];
    [v18 deactivatePairedDevices];

    uint64_t v19 = +[IDSDaemon sharedInstance];
    id v20 = [v19 broadcasterWithMessageContext:0];

    [v20 deactivatePairedDevices];
  }
  double v21 = +[IMRGLog watchPairing];
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Removing the keychain and in-memory data used for OTR communication.", buf, 2u);
  }

  double v22 = +[IDSOTRKeyStorage sharedInstance];
  [v22 removeSessionKeyForAllTokenFromMainQueue];

  int v23 = +[IDSOTRController sharedInstance];
  [v23 removeAllCachedSessionsFromMainQueue];

  double v24 = +[IMRGLog watchPairing];
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Resetting all OTR sessions to allow communication with the new active paired device.", buf, 2u);
  }

  long long v25 = +[IDSOTRController sharedInstance];
  [v25 resetAllSessions];

  if (*(unsigned char *)(a1 + 40)) {
    uint64_t v26 = 24;
  }
  else {
    uint64_t v26 = 31;
  }
  long long v27 = +[IDSUTunDeliveryController sharedInstance];
  uint64_t v28 = IDSDeviceDefaultPairedDeviceUniqueID;
  [v27 removeUTunPeerWithDeviceUniqueID:IDSDeviceDefaultPairedDeviceUniqueID btuuid:0 reason:v26 shouldWait:1];

  long long v29 = +[IDSUTunController sharedInstance];
  [v29 tearDownEncryptionForDeviceUniqueID:v28 cbuuid:0];

  CFStringRef v30 = +[IDSUTunController sharedInstance];
  v34[0] = _NSConcreteStackBlock;
  v34[1] = 3221225472;
  v34[2] = sub_1000F4BC8;
  v34[3] = &unk_10097E7F0;
  id v35 = *(id *)(a1 + 32);
  CFStringRef v31 = im_primary_queue();
  [v30 obliterateConnectionInfoWithCompletionBlock:v34 completionQueue:v31];
}

uint64_t sub_1000F4BC8(uint64_t result)
{
  if (*(void *)(result + 32))
  {
    uint64_t v1 = result;
    id v2 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v3 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Calling completion block to finish switching", v3, 2u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
    return (*(uint64_t (**)(void))(*(void *)(v1 + 32) + 16))();
  }
  return result;
}

void sub_1000F4D00(id a1)
{
  qword_100A4A670 = objc_alloc_init(IDSAccountSync);

  _objc_release_x1();
}

id sub_1000F533C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (([v3 isEqualToString:@"PreferredAccount"] & 1) != 0
    || ([v3 isEqualToString:@"FetchRemote"] & 1) != 0
    || ([v3 isEqualToString:@"TinkerDeviceInfo"] & 1) != 0)
  {
    uint64_t v4 = 0;
  }
  else
  {
    id v6 = [*(id *)(a1 + 32) serviceController];
    uint64_t v4 = [v6 serviceWithIdentifier:v3];
  }

  return v4;
}

id sub_1000F5608(uint64_t a1, uint64_t a2)
{
  return +[IDSAccountSync retryTimeForKey:*(void *)(a1 + 32) attempts:a2];
}

uint64_t sub_1000F5620(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000F5978(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 72));
  _Unwind_Resume(a1);
}

void sub_1000F5994(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 72));
  id v5 = [WeakRetained syncCredential];
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v13 = *(void *)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 48);
  id v8 = [*(id *)(a1 + 56) pairingManager];
  uint64_t v9 = [v8 activePairedDeviceHasPairingType:1] ^ 1;
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_1000F5AEC;
  v14[3] = &unk_100982140;
  objc_copyWeak(&v18, (id *)(a1 + 72));
  id v10 = *(id *)(a1 + 64);
  uint64_t v11 = *(void *)(a1 + 56);
  id v15 = v10;
  uint64_t v16 = v11;
  id v12 = v3;
  id v17 = v12;
  [v5 sendAccountSyncMessage:v13 messageID:v6 queueOneIdentifier:v7 allowCloudFallback:v9 completionBlock:v14];

  objc_destroyWeak(&v18);
}

void sub_1000F5AD8(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_1000F5AEC(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = +[IMRGLog accountSync];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v7 = @"NO";
    if (a2) {
      CFStringRef v7 = @"YES";
    }
    int v10 = 138412546;
    id v11 = v5;
    __int16 v12 = 2112;
    CFStringRef v13 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Sent account sync message (message ID: %@) (success: %@)", (uint8_t *)&v10, 0x16u);
  }

  if (a2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
    uint64_t v9 = [WeakRetained currentInFlightSyncAttempts];
    [v9 setObject:0 forKeyedSubscript:*(void *)(a1 + 32)];

    [*(id *)(a1 + 40) saveTracking];
  }
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

void sub_1000F6970(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 112));
  _Unwind_Resume(a1);
}

void sub_1000F6994(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v5 = [WeakRetained syncCredential];
  uint64_t v6 = [*(id *)(a1 + 32) allObjects];
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1000F6A78;
  v8[3] = &unk_1009807E8;
  void v8[4] = *(void *)(a1 + 40);
  id v9 = v3;
  id v7 = v3;
  [v5 fetchRemoteAccountsOfServiceTypes:v6 withCompletionBlock:v8];
}

void sub_1000F6A78(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = +[IMRGLog accountSync];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = [v3 allKeys];
    *(_DWORD *)buf = 138412290;
    uint64_t v19 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Received remote account information {accountInfoMapKey: %@}", buf, 0xCu);
  }
  if (v3)
  {
    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    uint64_t v6 = objc_msgSend(v3, "allKeys", 0);
    id v7 = [v6 countByEnumeratingWithState:&v13 objects:v17 count:16];
    if (v7)
    {
      id v8 = v7;
      uint64_t v9 = *(void *)v14;
      do
      {
        for (uint64_t i = 0; i != v8; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v14 != v9) {
            objc_enumerationMutation(v6);
          }
          uint64_t v11 = *(void *)(*((void *)&v13 + 1) + 8 * i);
          __int16 v12 = [v3 _arrayForKey:v11];
          [*(id *)(a1 + 32) synchronizeAccountsWithRemoteInfo:v12 service:v11];
        }
        id v8 = [v6 countByEnumeratingWithState:&v13 objects:v17 count:16];
      }
      while (v8);
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

id sub_1000F7980(id a1, id a2)
{
  uint64_t v2 = [a2 objectForKeyedSubscript:kIDSServiceDefaultsAliasKey];
  if ([v2 length]) {
    id v3 = v2;
  }
  else {
    id v3 = 0;
  }
  id v4 = v3;

  return v4;
}

id sub_1000F7C48(id a1, IDSDAccount *a2)
{
  uint64_t v2 = [(IDSDAccount *)a2 accountInfo];
  id v3 = [v2 objectForKeyedSubscript:kIDSServiceDefaultsAliasesKey];
  id v4 = objc_msgSend(v3, "__imArrayByApplyingBlock:", &stru_100982210);
  id v5 = [v4 firstObject];

  return v5;
}

id sub_1000F7CD4(id a1, id a2)
{
  uint64_t v2 = [a2 objectForKeyedSubscript:kIDSServiceDefaultsAliasKey];
  if ([v2 length]) {
    id v3 = v2;
  }
  else {
    id v3 = 0;
  }
  id v4 = v3;

  return v4;
}

id sub_1000F8B14(id a1, NSDictionary *a2)
{
  uint64_t v2 = [(NSDictionary *)a2 objectForKeyedSubscript:kIDSServiceDefaultsLoginAsKey];
  id v3 = [v2 lowercaseString];

  return v3;
}

id sub_1000F9904(id a1, id a2)
{
  uint64_t v2 = [a2 objectForKeyedSubscript:kIDSServiceDefaultsAliasKey];
  if ([v2 length]) {
    id v3 = v2;
  }
  else {
    id v3 = 0;
  }
  id v4 = v3;

  return v4;
}

BOOL sub_1000F9958(id a1, id a2)
{
  uint64_t v2 = [a2 objectForKeyedSubscript:kIDSServiceDefaultsAliasKey];
  char v3 = [v2 isEqualToString:kIDSServiceDefaultsSentinelAlias] ^ 1;

  return v3;
}

BOOL sub_1000F99AC(id a1, id a2)
{
  return [a2 isEqualToIgnoringCase:kIDSServiceDefaultsSentinelAlias] ^ 1;
}

void sub_1000F99D8(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = a2;
  id v5 = [v2 accountController];
  id v4 = [v3 uniqueID];

  [v5 enablePrimaryAccountWithUniqueID:v4];
}

void sub_1000F9A50(id a1, id a2)
{
}

id sub_1000FA31C(uint64_t a1, void *a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_1000FA3C4;
  v5[3] = &unk_100982360;
  id v6 = *(id *)(a1 + 32);
  id v3 = objc_msgSend(a2, "__imDictionaryByFilteringWithBlock:", v5);

  return v3;
}

id sub_1000FA3C4(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) containsObject:a2];
}

id sub_1000FB34C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return [*(id *)(a1 + 32) _respondToAppleCareRequestID:*(void *)(a1 + 40) withMessageContext:*(void *)(a1 + 48) error:a4];
}

void sub_1000FBDC8(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  id v6 = +[IDSFoundationLog accountIdentity];
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_INFO);
  if (a2)
  {
    if (v7)
    {
      id v8 = *(void **)(a1 + 32);
      int v9 = 138543362;
      id v10 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "Stored cluster in keychain {fullCluster: %{public}@}", (uint8_t *)&v9, 0xCu);
    }
  }
  else if (v7)
  {
    int v9 = 138543362;
    id v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "Failed to store cluster in keychain {error: %{public}@}", (uint8_t *)&v9, 0xCu);
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_1000FD424(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
}

uint64_t sub_1000FD498(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1000FD4A8(uint64_t a1)
{
}

void sub_1000FD4B0(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = +[IMRGLog registration];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v7 = *(void *)(a1 + 40);
    int v8 = 138412802;
    uint64_t v9 = v6;
    __int16 v10 = 2112;
    uint64_t v11 = v7;
    __int16 v12 = 2112;
    id v13 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Finished capturing AutoBugCapture diagnostics for EC key loading failure { context: %@, keyLoadingError: %@, error: %@ }", (uint8_t *)&v8, 0x20u);
  }
}

void sub_1000FD588(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = *(void **)(a1 + 96);
  id v5 = [*(id *)(a1 + 32) allKeys];
  uint64_t v6 = +[NSSet setWithArray:v5];
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_1000FD6F8;
  v10[3] = &unk_100982400;
  uint64_t v20 = *(void *)(a1 + 96);
  id v7 = *(id *)(a1 + 32);
  uint64_t v8 = *(void *)(a1 + 80);
  id v11 = v7;
  uint64_t v18 = v8;
  id v12 = *(id *)(a1 + 40);
  id v13 = *(id *)(a1 + 48);
  id v14 = v3;
  uint64_t v19 = *(void *)(a1 + 88);
  id v15 = *(id *)(a1 + 56);
  id v16 = *(id *)(a1 + 64);
  id v17 = *(id *)(a1 + 72);
  id v9 = v3;
  [v4 _fetchPresenceCapabilityForServiceTypes:v6 withCompletion:v10];
}

void sub_1000FD6F8(uint64_t a1, char a2)
{
  id v4 = *(void **)(a1 + 104);
  id v5 = [*(id *)(a1 + 32) allKeys];
  uint64_t v6 = +[NSSet setWithArray:v5];
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_1000FD868;
  v10[3] = &unk_1009823D8;
  uint64_t v7 = *(void *)(a1 + 88);
  uint64_t v20 = *(void *)(a1 + 104);
  uint64_t v18 = v7;
  id v11 = *(id *)(a1 + 40);
  id v12 = *(id *)(a1 + 32);
  id v13 = *(id *)(a1 + 48);
  id v8 = *(id *)(a1 + 56);
  uint64_t v9 = *(void *)(a1 + 96);
  id v14 = v8;
  uint64_t v19 = v9;
  id v15 = *(id *)(a1 + 64);
  id v16 = *(id *)(a1 + 72);
  char v21 = a2;
  id v17 = *(id *)(a1 + 80);
  [v4 _fetchStewieCapabilityForServiceTypes:v6 withCompletion:v10];
}

void sub_1000FD868(uint64_t a1, char a2)
{
  if (!_os_feature_enabled_impl()
    || ([(id)objc_opt_class() _isKTAsyncEnrollmentDisabledViaUserDefaults] & 1) != 0
    || [(id)objc_opt_class() _isKTAsyncEnrollmentDisabledViaServerBag])
  {
    id v4 = +[IDSFoundationLog KeyTransparency];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "KT Async Enrollment is disabled.", buf, 2u);
    }

    id v5 = [*(id *)(a1 + 32) createKTRegistrationDataForServiceTypes:*(void *)(a1 + 40) withPublicIdentity:*(void *)(a1 + 48)];
    id v6 = [v5 mutableCopy];
    uint64_t v7 = *(void *)(*(void *)(a1 + 88) + 8);
    id v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }
  else
  {
    id v13 = [*(id *)(a1 + 56) mutableCopy];
    uint64_t v14 = *(void *)(*(void *)(a1 + 88) + 8);
    id v15 = *(void **)(v14 + 40);
    *(void *)(v14 + 40) = v13;
  }
  BYTE1(v16) = a2;
  LOBYTE(v16) = *(unsigned char *)(a1 + 112);
  uint64_t v9 = objc_msgSend(*(id *)(a1 + 104), "_createClientDatasForServiceTypes:withAppleIDRegistrationsForServiceTypes:ktRegDataByServiceType:publicIdentityData:publicIdentityError:keyStore:isPresenceCapable:isStewieCapable:", *(void *)(a1 + 40), *(void *)(a1 + 64), *(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 40), *(void *)(a1 + 48), *(void *)(a1 + 72), *(void *)(a1 + 32), v16);
  uint64_t v10 = *(void *)(*(void *)(a1 + 96) + 8);
  id v11 = *(void **)(v10 + 40);
  *(void *)(v10 + 40) = v9;

  id v12 = objc_alloc_init(IDSClientDataResult);
  [(IDSClientDataResult *)v12 setClientDatasByServiceType:*(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 40)];
  [(IDSClientDataResult *)v12 setKtRegDataByServiceType:*(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 40)];
  [*(id *)(a1 + 80) fulfillWithValue:v12];
}

void sub_1000FF93C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000FF960(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_1000FF9F8;
  v7[3] = &unk_100982478;
  id v5 = *(NSObject **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  id v8 = v3;
  uint64_t v9 = v4;
  id v6 = v3;
  dispatch_async(v5, v7);
}

void sub_1000FF9F8(uint64_t a1)
{
  uint64_t v2 = +[FTDeviceSupport sharedInstance];
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_1000FFAA8;
  v5[3] = &unk_100982450;
  long long v4 = *(_OWORD *)(a1 + 32);
  id v3 = (id)v4;
  long long v6 = v4;
  [v2 supportsStewieWithCompletion:v5];
}

void sub_1000FFAA8(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  long long v6 = +[IMRGLog registration];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v7 = @"NO";
    if (a2) {
      CFStringRef v7 = @"YES";
    }
    int v8 = 138412546;
    CFStringRef v9 = v7;
    __int16 v10 = 2112;
    id v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Fetched stewie capability with result: %@ error: %@", (uint8_t *)&v8, 0x16u);
  }

  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = a2;
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000FFBAC(uint64_t a1, char a2)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000FFC40;
  block[3] = &unk_1009824C8;
  char v9 = a2;
  id v3 = *(NSObject **)(a1 + 32);
  id v4 = *(id *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  id v7 = v4;
  uint64_t v8 = v5;
  dispatch_async(v3, block);
}

uint64_t sub_1000FFC40(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48))
  {
    uint64_t v2 = +[IMRGLog registration];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      sub_100710718(v2);
    }
  }
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void))(result + 16))(result, *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
  }
  return result;
}

void sub_100100004(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100100028(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = *(NSObject **)(a1 + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1001000C8;
  block[3] = &unk_100982560;
  long long v8 = *(_OWORD *)(a1 + 40);
  id v7 = v3;
  id v5 = v3;
  dispatch_async(v4, block);
}

void sub_1001000C8(uint64_t a1)
{
  id v2 = [objc_alloc(*(Class *)(a1 + 48)) initWithPresenceIdentifier:&stru_10099BE78];
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_10010017C;
  v5[3] = &unk_100982538;
  long long v4 = *(_OWORD *)(a1 + 32);
  id v3 = (id)v4;
  long long v6 = v4;
  [v2 fetchPresenceCapability:v5];
}

uint64_t sub_10010017C(uint64_t a1, int a2)
{
  long long v4 = +[IMRGLog registration];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 67109120;
    v6[1] = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Fetched StatusKit presence capability with result: %d", (uint8_t *)v6, 8u);
  }

  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = a2;
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100100250(uint64_t a1, char a2)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1001002E4;
  block[3] = &unk_1009824C8;
  char v9 = a2;
  id v3 = *(NSObject **)(a1 + 32);
  id v4 = *(id *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  id v7 = v4;
  uint64_t v8 = v5;
  dispatch_async(v3, block);
}

uint64_t sub_1001002E4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48))
  {
    id v2 = +[IMRGLog registration];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      sub_10071075C(v2);
    }
  }
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void))(result + 16))(result, *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
  }
  return result;
}

BOOL sub_100101330(id a1, id a2)
{
  return [a2 isEqualToIgnoringCase:kIDSServiceDefaultsSentinelAlias] ^ 1;
}

BOOL sub_100101464(id a1, id a2)
{
  return [a2 isEqualToIgnoringCase:kIDSServiceDefaultsSentinelAlias] ^ 1;
}

BOOL sub_10010198C(id a1, id a2)
{
  return [a2 isEqualToIgnoringCase:kIDSServiceDefaultsSentinelAlias] ^ 1;
}

id sub_100101D60(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) _repairTimerHit:a2];
}

uint64_t sub_100101D6C()
{
  uint64_t v0 = +[IDSServerBag sharedInstanceForBagType:0];
  uint64_t v1 = [v0 objectForKey:@"allow-account-repair-activity"];

  if (v1 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    uint64_t v2 = (uint64_t)[v1 BOOLValue];
  }
  else {
    uint64_t v2 = 1;
  }

  return v2;
}

void sub_100101DF4(uint64_t a1)
{
  id v1 = *(id *)(a1 + 32);
  im_dispatch_after_primary_queue();
}

id sub_100101E74(uint64_t a1)
{
  *(unsigned char *)(*(void *)(a1 + 32) + 9) = 0;
  [*(id *)(a1 + 32) _repairTimerHit:0];
  uint64_t v2 = *(void **)(a1 + 32);

  return [v2 setupPhoneNumberRepairTimer];
}

void sub_10010317C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IMRGLog registration];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 138412290;
    id v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, " => Kicking alternate SMS based linked account: %@", (uint8_t *)&v7, 0xCu);
  }

  uint64_t v5 = [*(id *)(a1 + 32) accountController];
  long long v6 = [v3 uniqueID];
  [v5 enableAccountWithUniqueID:v6];

  [v3 registerAccount];
}

void sub_100103278(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IMRGLog registration];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 138412290;
    id v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, " => Kicking SMS based linked account: %@", (uint8_t *)&v7, 0xCu);
  }

  uint64_t v5 = [*(id *)(a1 + 32) accountController];
  long long v6 = [v3 uniqueID];
  [v5 enableAccountWithUniqueID:v6];

  [v3 registerAccount];
}

void sub_100103374(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IMRGLog registration];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 138412290;
    id v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, " => Kicking iCloud SMS based linked account: %@", (uint8_t *)&v7, 0xCu);
  }

  uint64_t v5 = [*(id *)(a1 + 32) accountController];
  long long v6 = [v3 uniqueID];
  [v5 enableAccountWithUniqueID:v6];

  [v3 registerAccount];
}

void sub_100103B90(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IMRGLog registration];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 138412290;
    id v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, " => Kicking Apple ID based linked account: %@", (uint8_t *)&v7, 0xCu);
  }

  uint64_t v5 = [*(id *)(a1 + 32) accountController];
  long long v6 = [v3 uniqueID];
  [v5 enableAccountWithUniqueID:v6];

  [v3 registerAccount];
}

void sub_100103D98(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 32));
  _Unwind_Resume(a1);
}

void sub_100103DB4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  xpc_activity_state_t state = xpc_activity_get_state(v3);
  if (state == 2)
  {
    id v11 = +[IMRGLog registration];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Got called to kick account repair.", buf, 2u);
    }

    if (sub_100101D6C())
    {
      id v8 = im_primary_queue();
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100103FE8;
      block[3] = &unk_10097E4D0;
      void block[4] = WeakRetained;
      dispatch_async(v8, block);
LABEL_15:
    }
  }
  else if (!state)
  {
    long long v6 = +[IMRGLog registration];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v7 = @"YES";
      if (!v3) {
        CFStringRef v7 = @"NO";
      }
      *(_DWORD *)buf = 138412290;
      CFStringRef v14 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Told to check in for account repair with activity %@ ", buf, 0xCu);
    }

    id v8 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_string(v8, XPC_ACTIVITY_PRIORITY, XPC_ACTIVITY_PRIORITY_MAINTENANCE);
    xpc_dictionary_set_int64(v8, XPC_ACTIVITY_INTERVAL, XPC_ACTIVITY_INTERVAL_4_HOURS);
    xpc_object_t v9 = xpc_activity_copy_criteria(v3);
    __int16 v10 = v9;
    if (!v9 || !xpc_equal(v9, v8)) {
      xpc_activity_set_criteria(v3, v8);
    }

    goto LABEL_15;
  }
}

id sub_100103FE8(uint64_t a1)
{
  return [*(id *)(a1 + 32) repairAccounts];
}

id sub_100105970(uint64_t a1, int a2, void *a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_1001059F4;
  v5[3] = &unk_100982650;
  int v6 = a2;
  id v3 = objc_msgSend(a3, "__imArrayByFilteringWithBlock:", v5);

  return v3;
}

BOOL sub_1001059F4(uint64_t a1, void *a2)
{
  return [a2 accountType] == *(_DWORD *)(a1 + 32);
}

BOOL sub_100105A28(id a1, IDSDAccount *a2)
{
  return ![(IDSDAccount *)a2 isAdHocAccount];
}

void sub_100105A48(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v5 = +[IMRGLog registration];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v23 = 138412290;
    CFStringRef v24 = v3;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "   Checking account registration status: %@", (uint8_t *)&v23, 0xCu);
  }

  unint64_t v6 = (unint64_t)[(__CFString *)v3 registrationError];
  if (v6 <= 0x26)
  {
    unint64_t v7 = v6;
    if (((1 << v6) & 0x4600000000) != 0)
    {
      id v8 = +[IMRGLog registration];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        int v23 = 134218242;
        CFStringRef v24 = (const __CFString *)v7;
        __int16 v25 = 2112;
        uint64_t v26 = (uint64_t)v3;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "   Not attempting repair service/account pair {registrationError: %ld, account: %@}", (uint8_t *)&v23, 0x16u);
      }
LABEL_7:

      goto LABEL_28;
    }
  }
  xpc_object_t v9 = [(__CFString *)v3 loginID];
  if (!IMAreEmailsLogicallyTheSame())
  {

    goto LABEL_22;
  }
  int v10 = *(unsigned __int8 *)(a1 + 48);

  if (v10)
  {
LABEL_22:
    uint64_t v16 = +[IMRGLog registration];
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v17 = *(const __CFString **)(a1 + 32);
      uint64_t v18 = [(__CFString *)v3 loginID];
      uint64_t v19 = (void *)v18;
      int v20 = *(unsigned __int8 *)(a1 + 48);
      int v23 = 138412802;
      CFStringRef v24 = v17;
      if (v20) {
        CFStringRef v21 = @"YES";
      }
      else {
        CFStringRef v21 = @"NO";
      }
      __int16 v25 = 2112;
      uint64_t v26 = v18;
      __int16 v27 = 2112;
      CFStringRef v28 = v21;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "  => Account does not appear to be primary, we shouldn't be here...  {primaryUserName: %@, loginID: %@, hasActiveAppleIDBasedAccounts: %@}", (uint8_t *)&v23, 0x20u);
    }
    goto LABEL_28;
  }
  if ([(__CFString *)v3 isEnabled]
    && (int)[(__CFString *)v3 registrationStatus] > 1)
  {
    id v8 = +[IMRGLog registration];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      double v22 = [(__CFString *)v3 uniqueID];
      int v23 = 138412290;
      CFStringRef v24 = v22;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "   Account appears to be in good form: %@", (uint8_t *)&v23, 0xCu);
    }
    goto LABEL_7;
  }
  id v11 = +[IMRGLog registration];
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    if ([(__CFString *)v3 isEnabled]) {
      CFStringRef v12 = @"YES";
    }
    else {
      CFStringRef v12 = @"NO";
    }
    if ((int)[(__CFString *)v3 registrationStatus] >= 2) {
      CFStringRef v13 = @"NO";
    }
    else {
      CFStringRef v13 = @"YES";
    }
    int v23 = 138412546;
    CFStringRef v24 = v12;
    __int16 v25 = 2112;
    uint64_t v26 = (uint64_t)v13;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "   Account isn't enabled or registerd -- enabling {isEnabled: %@, unregistered: %@}", (uint8_t *)&v23, 0x16u);
  }

  CFStringRef v14 = [*(id *)(a1 + 40) accountController];
  id v15 = [(__CFString *)v3 uniqueID];
  [v14 enableAccountWithUniqueID:v15];

  [(__CFString *)v3 registerAccount];
LABEL_28:
}

void sub_100105DD0(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([(__CFString *)v3 registrationError] == (id)38)
  {
    uint64_t v5 = +[IMRGLog registration];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = 134218242;
      uint64_t v17 = 38;
      __int16 v18 = 2112;
      CFStringRef v19 = v3;
      unint64_t v6 = "   Not enabling account due to irreparable registration error {registrationError: %ld, account: %@}";
      unint64_t v7 = v5;
      uint32_t v8 = 22;
LABEL_11:
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v16, v8);
      goto LABEL_12;
    }
    goto LABEL_12;
  }
  xpc_object_t v9 = [*(id *)(a1 + 32) accountController];
  if (![v9 hasActiveSMSAccount])
  {

    goto LABEL_9;
  }
  if ([(__CFString *)v3 isEnabled])
  {
    int v10 = [(__CFString *)v3 registrationStatus];

    if (v10 < 2) {
      goto LABEL_15;
    }
LABEL_9:
    uint64_t v5 = +[IMRGLog registration];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v16) = 0;
      unint64_t v6 = "  => We have no active SMS registrations, skipping";
      unint64_t v7 = v5;
      uint32_t v8 = 2;
      goto LABEL_11;
    }
LABEL_12:

    goto LABEL_13;
  }

LABEL_15:
  id v11 = +[IMRGLog registration];
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    if ([(__CFString *)v3 isEnabled]) {
      CFStringRef v12 = @"YES";
    }
    else {
      CFStringRef v12 = @"NO";
    }
    if ((int)[(__CFString *)v3 registrationStatus] >= 2) {
      CFStringRef v13 = @"NO";
    }
    else {
      CFStringRef v13 = @"YES";
    }
    int v16 = 138412546;
    uint64_t v17 = (uint64_t)v12;
    __int16 v18 = 2112;
    CFStringRef v19 = v13;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "   Account isn't enabled and/or registered -- enabling {isEnabled: %@, unregistered: %@}", (uint8_t *)&v16, 0x16u);
  }

  CFStringRef v14 = [*(id *)(a1 + 32) accountController];
  id v15 = [(__CFString *)v3 uniqueID];
  [v14 enableAccountWithUniqueID:v15];

  [(__CFString *)v3 registerAccount];
LABEL_13:
}

void sub_100106034(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (([v3 isEnabled] & 1) == 0)
  {
    uint64_t v5 = +[IMRGLog registration];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint32_t v8 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "   Account isn't enabled, enabling local account", v8, 2u);
    }

    unint64_t v6 = [*(id *)(a1 + 32) accountController];
    unint64_t v7 = [v3 uniqueID];
    [v6 enableAccountWithUniqueID:v7];
  }
}

void sub_10010610C(uint64_t a1, void *a2)
{
  id v3 = *(void **)(a1 + 32);
  id v4 = a2;
  uint64_t v5 = [v3 accountController];
  [v5 addPrimaryAccount:v4];

  id v7 = [*(id *)(a1 + 32) accountController];
  unint64_t v6 = [v4 uniqueID];

  [v7 enablePrimaryAccountWithUniqueID:v6];
}

void sub_100106BF8(uint64_t a1)
{
  id v1 = [*(id *)(*(void *)(a1 + 32) + 24) iTunesSystemAccountWithError:0];
  if (v1)
  {
    uint64_t v2 = +[IMRGLog registration];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 138412290;
      uint64_t v5 = v1;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "iTunes is signed in -- ignoring request to sign out { systemAccount: %@ }", (uint8_t *)&v4, 0xCu);
    }
  }
  else
  {
    uint64_t v2 = +[IDSDaemon sharedInstance];
    id v3 = [v2 signInResponder];
    [v3 iTunesSignOut];
  }
}

void sub_1001070B0(uint64_t a1)
{
  id v1 = [*(id *)(*(void *)(a1 + 32) + 24) iCloudSystemAccountWithError:0];
  if (v1)
  {
    uint64_t v2 = +[IMRGLog registration];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 138412290;
      uint64_t v5 = v1;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "iCloud is signed in -- ignoring request to sign out { systemAccount: %@ }", (uint8_t *)&v4, 0xCu);
    }
  }
  else
  {
    uint64_t v2 = +[IDSDaemon sharedInstance];
    id v3 = [v2 signInResponder];
    [v3 iCloudSignOut];
  }
}

void sub_10010729C(uint64_t a1, uint64_t a2)
{
  int v4 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = +[NSNumber numberWithInteger:a2];
    int v9 = 138412290;
    int v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Fetched current KT CDP Status. { IDSKTAccountStatus: %@ }", (uint8_t *)&v9, 0xCu);
  }
  if (a2 == 4)
  {
    unint64_t v6 = [*(id *)(a1 + 32) accountController];
    id v7 = [*(id *)(a1 + 40) uniqueID];
    [v6 enableAccountWithUniqueID:v7];

    [*(id *)(a1 + 40) registerAccount];
  }
  else
  {
    uint32_t v8 = +[IDSFoundationLog KeyTransparency];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v9) = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "KT says account isn't ready. Not trying to repair account.", (uint8_t *)&v9, 2u);
    }
  }
}

double sub_1001074D0()
{
  uint64_t v0 = +[IDSServerBag sharedInstanceForBagType:0];
  id v1 = [v0 objectForKey:@"phone-registration-retry-interval-seconds"];

  if (v1)
  {
    [v1 doubleValue];
    double v3 = v2;
  }
  else
  {
    double v3 = 86400.0;
  }
  if (IDSDebuggingShouldForcePhoneRepairTimer())
  {
    IDSDebuggingPhoneRepairTimerOverride();
    double v3 = v4;
  }

  return v3;
}

double sub_10010755C()
{
  uint64_t v0 = +[IDSServerBag sharedInstanceForBagType:0];
  id v1 = [v0 objectForKey:@"phone-registration-retry-max-interval-seconds"];

  if (v1)
  {
    [v1 doubleValue];
    double v3 = v2;
  }
  else
  {
    double v3 = 691200.0;
  }

  return v3;
}

id sub_100107D3C(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) _phoneNumberRepairTimerHit:a2];
}

id sub_100108188(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) _phoneNumberRepairTimerHit:a2];
}

id sub_1001088B8(uint64_t a1)
{
  double v2 = [*(id *)(a1 + 32) accountController];
  double v3 = [*(id *)(a1 + 40) uniqueID];
  [v2 enableAccountWithUniqueID:v3];

  double v4 = *(void **)(a1 + 40);

  return [v4 registerAccount];
}

void sub_100108A44(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 2u);
}

uint64_t sub_100108A60()
{
  uint64_t result = IMGetDomainBoolForKeyWithDefaultValue();
  byte_100A531E8 = result;
  return result;
}

nw_endpoint_t sub_100108A94(unsigned int a1)
{
  *(void *)&address[4] = 0;
  *(void *)&address[12] = 0;
  uint64_t v4 = 0;
  *(_WORD *)&address[2] = __rev16(a1);
  *(_WORD *)address = 7708;
  nw_endpoint_t v1 = nw_endpoint_create_address((const sockaddr *)address);

  return v1;
}

void sub_100109138(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  os_unfair_lock_unlock(v17);
  _Unwind_Resume(a1);
}

uint64_t sub_100109168(uint64_t result, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  if (*(void *)(result + 32) == a2)
  {
    *(void *)(*(void *)(*(void *)(result + 40) + 8) + 24) = a3;
    *a4 = 1;
  }
  return result;
}

uint64_t sub_100109190(uint64_t result, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  if (*(void *)(result + 32) == a2)
  {
    *(void *)(*(void *)(*(void *)(result + 40) + 8) + 24) = a3;
    *a4 = 1;
  }
  return result;
}

uint64_t sub_1001097C4(uint64_t a1, uint64_t *a2)
{
  if (atomic_load_explicit((atomic_uchar *volatile)(*(void *)(a1 + 32) + 16), memory_order_acquire))
  {
    id v11 = +[IDSFoundationLog Multiplexer];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      CFStringRef v12 = "Mutliplexer Transport readHandler called for routed connection while invalidated";
LABEL_16:
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v12, buf, 2u);
    }
  }
  else
  {
    if ([*(id *)(a1 + 40) isTCP])
    {
      uint64_t v4 = [*(id *)(a1 + 40) localTCPSYN];

      if (!v4 && (*(unsigned char *)(*a2 + 13) & 2) != 0)
      {
        uint64_t v5 = bswap32(*(_DWORD *)(*a2 + 4));
        unint64_t v6 = +[NSNumber numberWithUnsignedInt:v5];
        [*(id *)(a1 + 40) setLocalTCPSYN:v6];

        id v7 = +[IDSFoundationLog Multiplexer];
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v8 = *(void *)(a1 + 40);
          *(_DWORD *)buf = 67109378;
          int v22 = v5;
          __int16 v23 = 2112;
          uint64_t v24 = v8;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "saved local SYN %08X for connection %@", buf, 0x12u);
        }
      }
    }
    int v9 = *((unsigned __int8 *)a2 + 46);
    if (!*((unsigned char *)a2 + 46)) {
      *((_DWORD *)a2 + 134) |= 0x4000u;
    }
    if (*(void *)(a1 + 48))
    {
      IDSLinkPacketBufferAddBufferStart();
      *((_DWORD *)a2 + 134) |= 1u;
      a2[61] = *(void *)(a1 + 48);
      goto LABEL_12;
    }
    if (byte_100A531E8)
    {
      if (v9) {
        goto LABEL_13;
      }
      IDSLinkPacketBufferAddBufferStart();
LABEL_12:
      *(_DWORD *)*a2 = 1467207418;
LABEL_13:
      kdebug_trace();
      return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 32) + 56) + 16))();
    }
    uint64_t v13 = *a2;
    uint64_t v14 = *(void *)(a1 + 32);
    __int16 v15 = *(_WORD *)(v14 + 72);
    *(_WORD *)(v14 + 72) = v15 + 1;
    *(_DWORD *)(v13 - 26) = 1467207418;
    *(unsigned char *)(v13 - 22) = HIBYTE(v15);
    *(unsigned char *)(v13 - 21) = v15;
    *(_DWORD *)(v13 - 20) = bswap32(*(_DWORD *)(a1 + 48));
    uint64_t v16 = *(void *)(a1 + 32);
    uint64_t v17 = *(void **)(v16 + 64);
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 3221225472;
    v19[2] = sub_100109ADC;
    v19[3] = &unk_100982758;
    uint64_t v18 = *(void *)(a1 + 48);
    void v19[4] = v16;
    v19[5] = v18;
    __int16 v20 = v15;
    v19[6] = v13 - 16;
    v19[7] = a2;
    if ([v17 useCurrentEncryptionkeyWithHandler:v19])
    {
      IDSLinkPacketBufferAddBufferStart();
      goto LABEL_13;
    }
    id v11 = +[IDSFoundationLog Multiplexer];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      CFStringRef v12 = "Fanout encryption - useCurrentEncryptionkeyWithHandler failed - dropping outgoing packet";
      goto LABEL_16;
    }
  }

  return 0;
}

void sub_100109ADC(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  int v10 = v9;
  uint64_t v11 = *(void *)(a1 + 32);
  CFStringRef v12 = *(_DWORD **)(v11 + 88);
  if (v12)
  {
    if ([v9 isEqual:*(void *)(v11 + 80)])
    {
LABEL_12:
      [v10 getUUIDBytes:*(void *)(a1 + 48)];
      sub_100221370((uint64_t)v12, *(unsigned __int16 *)(a1 + 64), **(unsigned __int8 ***)(a1 + 56), *(void *)(*(void *)(a1 + 56) + 16), 1);
      goto LABEL_13;
    }
    sub_100221340((uint64_t)v12);
    *(void *)(*(void *)(a1 + 32) + 88) = 0;
    uint64_t v13 = *(void *)(a1 + 32);
    uint64_t v14 = *(void **)(v13 + 80);
    *(void *)(v13 + 80) = 0;
  }
  while (1)
  {
    uint64_t v15 = *(void *)(a1 + 32);
    int v17 = *(_DWORD *)(v15 + 76);
    uint64_t v16 = (void *)(v15 + 76);
    if (v17) {
      break;
    }
    if (SecRandomCopyBytes(kSecRandomDefault, 4uLL, v16)) {
      sub_100710C00();
    }
  }
  CFStringRef v12 = malloc_type_malloc(0x11F0uLL, 0x10300408CDAB1FBuLL);
  id v18 = v7;
  sub_100220DA4(v12, (uint64_t)[v18 bytes], (int)objc_msgSend(v18, "length"), 1, *(_DWORD *)(*(void *)(a1 + 32) + 76), 0, 0, 0, 1);
  id v19 = v18;
  int v20 = sub_100220DA4(v12, (uint64_t)[v19 bytes], (int)objc_msgSend(v19, "length"), 1, *(_DWORD *)(a1 + 40), 0, 0, 0, 1);
  if (!v20)
  {
    *(void *)(*(void *)(a1 + 32) + 88) = v12;
    id v23 = [v10 copy];
    uint64_t v24 = *(void *)(a1 + 32);
    __int16 v25 = *(void **)(v24 + 80);
    *(void *)(v24 + 80) = v23;

    goto LABEL_12;
  }
  int v21 = v20;
  free(v12);
  int v22 = +[IDSFoundationLog Multiplexer];
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    int v27 = v21;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Fanout encryption - SRTP init failed with error code %d", buf, 8u);
  }

LABEL_13:
}

void sub_10010A0C4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v2 - 96), 8);
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_10010A0F4(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  unsigned int v7 = [a2 unsignedIntValue];
  id v8 = [*(id *)(*(void *)(a1 + 32) + 32) objectAtIndexedSubscript:a3];
  id v9 = [v8 unsignedLongLongValue];

  int v10 = +[IDSFoundationLog Multiplexer];
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v11 = *(_DWORD *)(a1 + 56);
    uint64_t v12 = *(void *)(*(void *)(a1 + 48) + 488);
    int v22 = 67109888;
    unsigned int v23 = v7;
    __int16 v24 = 1024;
    unsigned int v25 = v11;
    __int16 v26 = 2048;
    id v27 = v9;
    __int16 v28 = 2048;
    uint64_t v29 = v12;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "comparing portSignatures %08X to %08X and participantIDs %016llX to %016llX", (uint8_t *)&v22, 0x22u);
  }

  if (v7 == *(_DWORD *)(a1 + 56) && v9 == *(id *)(*(void *)(a1 + 48) + 488))
  {
    if (!*(unsigned char *)(a1 + 64))
    {
LABEL_16:
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = a3;
      *a4 = 1;
      return;
    }
    uint64_t v13 = [*(id *)(*(void *)(a1 + 32) + 40) objectAtIndexedSubscript:a3];
    uint64_t v14 = [v13 localTCPSYN];

    if (v14)
    {
      unsigned int v15 = [v14 unsignedLongValue];
      if (*(_DWORD *)(a1 + 60) == v15)
      {
        *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = a3;
        *a4 = 1;
LABEL_15:

        goto LABEL_16;
      }
      uint64_t v16 = +[IDSFoundationLog Multiplexer];
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v21 = *(_DWORD *)(a1 + 60);
        int v22 = 67109376;
        unsigned int v23 = v21;
        __int16 v24 = 1024;
        unsigned int v25 = v15;
        id v18 = "resetSYN %08X localSYN %08X do not match";
        id v19 = v16;
        uint32_t v20 = 14;
        goto LABEL_13;
      }
    }
    else
    {
      uint64_t v16 = +[IDSFoundationLog Multiplexer];
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v17 = *(_DWORD *)(a1 + 60);
        int v22 = 67109120;
        unsigned int v23 = v17;
        id v18 = "resetSYN %08X but no localSYN";
        id v19 = v16;
        uint32_t v20 = 8;
LABEL_13:
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v18, (uint8_t *)&v22, v20);
      }
    }

    goto LABEL_15;
  }
}

void sub_10010A5E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_unfair_lock_t lock)
{
}

uint64_t sub_10010A7F4(uint64_t a1, uint64_t a2)
{
  unsigned __int8 explicit = atomic_load_explicit((atomic_uchar *volatile)(*(void *)(a1 + 32) + 16), memory_order_acquire);
  uint64_t v5 = +[IDSFoundationLog Multiplexer];
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (explicit)
  {
    if (v6)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Mutliplexer Transport readHandler called for listner while invalidated", buf, 2u);
    }

    return 0;
  }
  else
  {
    if (v6)
    {
      *(_WORD *)id v8 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "listener read callback!", v8, 2u);
    }

    IDSLinkPacketBufferAddBufferStart();
    **(_DWORD **)a2 = 1467207418;
    *(_DWORD *)(a2 + 536) |= 0x4000u;
    kdebug_trace();
    return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 32) + 56) + 16))();
  }
}

void sub_10010B2DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_unfair_lock_t lock, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a27, 8);
  os_unfair_lock_unlock(v27);
  _Unwind_Resume(a1);
}

void sub_10010B330(uint64_t a1, id a2)
{
  double v3 = *(_DWORD **)(a1 + 32);
  id v4 = a2;
  id v5 = [v4 bytes];
  int v6 = [v4 length];

  int v7 = sub_100220DA4(v3, (uint64_t)v5, v6, 0, 0, 0, *(_DWORD *)(a1 + 40), 0, 1);
  if (v7)
  {
    int v8 = v7;
    id v9 = +[IDSFoundationLog Multiplexer];
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v11 = v8;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Fanout encryption - SRTP init failed with error code %d", buf, 8u);
    }
  }
}

void sub_10010B450(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  unsigned int v7 = [a2 unsignedIntValue];
  int v8 = [*(id *)(*(void *)(a1 + 32) + 32) objectAtIndexedSubscript:a3];
  id v9 = [v8 unsignedLongLongValue];

  if (v7 == *(_DWORD *)(a1 + 56))
  {
    id v10 = *(id *)(a1 + 48);
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = a3;
    if (v9 == v10) {
      *a4 = 1;
    }
  }
}

void sub_10010B720(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_10010B878(id a1)
{
  qword_100A4A680 = [[IDSGroupSessionMultiplexer alloc] initAndSetupNexus];

  _objc_release_x1();
}

void sub_10010BD5C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_10010BEE8(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_10010C53C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

id sub_10010D74C(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog Multiplexer];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v5 = 138412290;
    uint64_t v6 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "MUXKillQUICConnectionTimer fired for %@", (uint8_t *)&v5, 0xCu);
  }

  [*(id *)(a1 + 40) resetConnection:*(void *)(a1 + 32)];
  return [*(id *)(a1 + 32) invalidate];
}

BOOL IDSProtoKeyTransparencyTrustedServiceSignatureReadFrom(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    while (1)
    {
      if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
      }
      char v4 = 0;
      unsigned int v5 = 0;
      unint64_t v6 = 0;
      while (1)
      {
        unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v7 == -1 || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
          break;
        }
        char v8 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
        *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
        v6 |= (unint64_t)(v8 & 0x7F) << v4;
        if ((v8 & 0x80) == 0) {
          goto LABEL_11;
        }
        v4 += 7;
        if (v5++ >= 9)
        {
          unint64_t v6 = 0;
          int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
          goto LABEL_13;
        }
      }
      *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
      int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
      if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        unint64_t v6 = 0;
      }
LABEL_13:
      if (v10 || (v6 & 7) == 4) {
        return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
      }
      if ((v6 >> 3) == 2) {
        break;
      }
      if ((v6 >> 3) == 1)
      {
        uint64_t v12 = PBReaderReadString();
        uint64_t v13 = 8;
LABEL_21:
        uint64_t v14 = *(void **)(a1 + v13);
        *(void *)(a1 + v13) = v12;

        goto LABEL_23;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0) {
        return 0;
      }
LABEL_23:
      if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
      }
    }
    uint64_t v12 = PBReaderReadData();
    uint64_t v13 = 16;
    goto LABEL_21;
  }
  return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

void sub_10010FB6C(uint64_t a1)
{
  uint64_t v2 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    if (*(unsigned char *)(a1 + 40)) {
      CFStringRef v3 = @"YES";
    }
    else {
      CFStringRef v3 = @"NO";
    }
    *(_DWORD *)buf = 138412290;
    CFStringRef v13 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "setHasSpaceAvailable %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  uint64_t v4 = *(void *)(a1 + 32);
  if (*(unsigned char *)(a1 + 40))
  {
    unsigned int v5 = *(void **)(v4 + 144);
    if (v5)
    {
      id v6 = [v5 length];
      uint64_t v8 = *(void *)(a1 + 32);
      uint64_t v7 = a1 + 32;
      *(void *)(v8 + 64) += v6;
      ++*(void *)(*(void *)v7 + 72);
      *(unsigned char *)(*(void *)v7 + 136) = 0;
      [*(id *)(*(void *)v7 + 40) sendData:*(void *)(*(void *)v7 + 144) peerID:*(void *)(*(void *)v7 + 32)];
      id v9 = *(void **)(*(void *)v7 + 144);
      *(void *)(*(void *)v7 + 144) = 0;
    }
    else
    {
      *(unsigned char *)(v4 + 136) = 1;
      uint64_t v10 = *(void *)(a1 + 32);
      if (*(unsigned char *)(v10 + 137))
      {
        id WeakRetained = objc_loadWeakRetained((id *)(v10 + 152));
        [WeakRetained link:*(void *)(a1 + 32) hasSpaceAvailable:1 deviceUniqueID:0 cbuuid:*(void *)(*(void *)(a1 + 32) + 8)];

        *(unsigned char *)(*(void *)(a1 + 32) + 137) = 0;
      }
    }
  }
  else
  {
    *(unsigned char *)(v4 + 136) = 0;
  }
}

id sub_10010FDE4(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _didReceiveData:*(void *)(a1 + 40)];
}

void sub_10011073C(id a1)
{
  mach_timebase_info info = (mach_timebase_info)0xAAAAAAAAAAAAAAAALL;
  mach_timebase_info(&info);
  LODWORD(v2) = info.denom;
  LODWORD(v1) = info.numer;
  *(double *)&qword_100A4A690 = (double)v1 / (double)v2 / 1000000000.0;
}

void sub_100110DC8(id a1)
{
  qword_100A4A6A0 = objc_alloc_init(IDSRapportDeliveryController);

  _objc_release_x1();
}

uint64_t sub_1001112BC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

void sub_1001112D4(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [v3 currentItem];
  unsigned int v5 = +[IDSFoundationLog bonjourDeliveryController];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v7 = *(void *)(a1 + 40);
    uint64_t v8 = *(void *)(a1 + 48);
    *(_DWORD *)buf = 138544131;
    uint64_t v26 = v6;
    __int16 v27 = 2114;
    uint64_t v28 = v7;
    __int16 v29 = 2113;
    CFStringRef v30 = v4;
    __int16 v31 = 2114;
    uint64_t v32 = v8;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Bonjour send message {guid: %{public}@, topic: %{public}@, deviceID: %{private}@, command: %{public}@}", buf, 0x2Au);
  }

  id v9 = [v4 _stripFZIDPrefix];
  uint64_t v10 = *(void *)(a1 + 32);
  v21[0] = @"id";
  v21[1] = @"t";
  long long v23 = *(_OWORD *)(a1 + 40);
  v21[2] = @"c";
  v21[3] = @"p";
  uint64_t v22 = v10;
  uint64_t v24 = *(void *)(a1 + 56);
  int v11 = +[NSDictionary dictionaryWithObjects:&v22 forKeys:v21 count:4];
  uint64_t v12 = [*(id *)(a1 + 64) rapportClient];
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  v15[2] = sub_100111524;
  v15[3] = &unk_100981BE8;
  id v16 = v3;
  id v17 = *(id *)(a1 + 32);
  id v18 = *(id *)(a1 + 40);
  id v19 = v4;
  id v20 = *(id *)(a1 + 72);
  id v13 = v4;
  id v14 = v3;
  [v12 sendMessage:v11 toDeviceIdentifier:v9 completionBlock:v15];
}

void sub_100111524(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [*(id *)(a1 + 32) currentResult];
  unsigned int v5 = +[IDSFoundationLog bonjourDeliveryController];
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v6)
    {
      uint64_t v7 = *(void *)(a1 + 40);
      uint64_t v8 = *(void *)(a1 + 48);
      uint64_t v9 = *(void *)(a1 + 56);
      int v14 = 138543875;
      uint64_t v15 = v7;
      __int16 v16 = 2114;
      uint64_t v17 = v8;
      __int16 v18 = 2113;
      uint64_t v19 = v9;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Bonjour failed to send message {guid: %{public}@, topic: %{public}@, deviceID: %{private}@}", (uint8_t *)&v14, 0x20u);
    }

    id v10 = [objc_alloc((Class)IDSDeliveryContext) initWithResponseCode:2 error:v3 lastCall:0];
    [v10 setDeviceID:*(void *)(a1 + 56)];
  }
  else
  {
    if (v6)
    {
      uint64_t v11 = *(void *)(a1 + 40);
      uint64_t v12 = *(void *)(a1 + 48);
      uint64_t v13 = *(void *)(a1 + 56);
      int v14 = 138543875;
      uint64_t v15 = v11;
      __int16 v16 = 2114;
      uint64_t v17 = v12;
      __int16 v18 = 2113;
      uint64_t v19 = v13;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Bonjour did send message {guid: %{public}@, topic: %{public}@, deviceID: %{private}@}", (uint8_t *)&v14, 0x20u);
    }

    [v4 addObject:*(void *)(a1 + 56)];
    id v10 = [objc_alloc((Class)IDSDeliveryContext) initWithResponseCode:0 deviceID:*(void *)(a1 + 56)];
    [v10 setLastCall:0];
  }
  (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
  [*(id *)(a1 + 32) continueWithResult:v4];
}

void sub_1001116F8(void *a1, void *a2)
{
  id v3 = a2;
  if ([v3 state])
  {
    uint64_t v15 = +[NSAssertionHandler currentHandler];
    [v15 handleFailureInMethod:a1[9] object:a1[4] file:@"IDSRapportDeliveryController.m" lineNumber:103 description:@"Any single bonjour message send shouldn't fail the whole send operation"];
  }
  uint64_t v4 = [v3 value];
  if ([v4 count])
  {
    unsigned int v5 = +[IDSFoundationLog bonjourDeliveryController];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = a1[5];
      uint64_t v7 = a1[6];
      uint64_t v8 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [v4 count]);
      int v16 = 138543875;
      uint64_t v17 = v6;
      __int16 v18 = 2114;
      uint64_t v19 = v7;
      __int16 v20 = 2113;
      unsigned int v21 = v8;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Bonjour did finish sending message {guid: %{public}@, topic: %{public}@, sentDeviceIDs.count: %{private}@", (uint8_t *)&v16, 0x20u);
    }
    uint64_t v9 = 0;
  }
  else
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1[4] + 8));
    id v10 = +[IDSFoundationLog bonjourDeliveryController];
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = a1[5];
      uint64_t v12 = a1[6];
      uint64_t v13 = (void *)a1[7];
      int v16 = 138543875;
      uint64_t v17 = v11;
      __int16 v18 = 2114;
      uint64_t v19 = v12;
      __int16 v20 = 2113;
      unsigned int v21 = v13;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Bonjour failed to send message to any recipient {guid: %{public}@, topic: %{public}@, deviceIDs: %{private}@}", (uint8_t *)&v16, 0x20u);
    }

    pthread_mutex_unlock((pthread_mutex_t *)(a1[4] + 8));
    uint64_t v9 = 2;
  }
  id v14 = [objc_alloc((Class)IDSDeliveryContext) initWithResponseCode:v9 error:0 lastCall:1];
  (*(void (**)(void))(a1[8] + 16))();
}

id sub_100112470(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [*(id *)(a1 + 32) setObject:a3 forKey:a2];
}

uint64_t sub_100113F7C(uint64_t result, unsigned int *a2, int a3, _DWORD *a4)
{
  if (a3 == 4)
  {
    *a4 = bswap32(*a2);
  }
  else
  {
    int v5 = result;
    uint64_t v6 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109376;
      int v8 = a3;
      __int16 v9 = 1024;
      int v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "getUint32FromBytes, uint32_t should be 4 bytes, not %u bytes, field: %u", buf, 0xEu);
    }

    uint64_t result = os_log_shim_legacy_logging_enabled();
    if (result)
    {
      uint64_t result = _IDSShouldLogTransport();
      if (result)
      {
        _IDSLogTransport();
        uint64_t result = _IDSShouldLog();
        if (result) {
          return _IDSLogV();
        }
      }
    }
  }
  return result;
}

void sub_1001142E0(id a1)
{
  qword_100A4A6B0 = objc_alloc_init(IDSDRegistrationPushManager);

  _objc_release_x1();
}

void sub_1001154A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,os_activity_scope_state_s state,char a29)
{
}

void sub_100115B30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,os_activity_scope_state_s state,char a29)
{
}

void sub_100115F70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,os_activity_scope_state_s state,char a29)
{
}

void sub_100116150(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, os_activity_scope_state_s state, char a20)
{
}

void sub_10011628C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
}

void sub_1001164A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, os_activity_scope_state_s state, char a20)
{
}

void sub_1001166D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,os_activity_scope_state_s state,char a26)
{
}

void sub_100116714(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = +[IMRGLog registration];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = [v3 responseUserID];
    uint64_t v6 = [v3 responseStatus];
    uint64_t v7 = [v3 responseOrigin];
    int v8 = [v3 responseMessage];
    int v15 = 138413058;
    int v16 = v5;
    __int16 v17 = 2112;
    __int16 v18 = v6;
    __int16 v19 = 2112;
    __int16 v20 = v7;
    __int16 v21 = 2112;
    uint64_t v22 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Received validate credentials response {userID: %@, status: %@, origin: %@, message: %@}", (uint8_t *)&v15, 0x2Au);
  }
  __int16 v9 = [v3 responseStatus];
  unsigned int v10 = [v9 intValue];

  if (v10)
  {
    uint64_t v11 = +[IMRGLog registration];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
      sub_100710F54(v3, v11);
    }
  }
  else
  {
    uint64_t v12 = *(void **)(a1 + 32);
    uint64_t v11 = [v3 responseOrigin];
    id v13 = [v11 integerValue];
    id v14 = +[NSArray arrayWithObject:*(void *)(a1 + 40)];
    [v12 _handleAction:v13 forAccounts:v14];
  }
}

uint64_t sub_1001169D4(uint64_t a1)
{
  qword_100A4A6B8 = (uint64_t)objc_alloc_init(*(Class *)(a1 + 32));

  return _objc_release_x1();
}

void sub_100117844(id a1)
{
  qword_100A4A6D0 = objc_alloc_init(IDSKTGossipManager);

  _objc_release_x1();
}

id sub_100117ED0(id a1, NSString *a2)
{
  unint64_t v2 = [(NSString *)a2 _stripPotentialTokenURIWithToken:0];
  id v3 = [objc_alloc((Class)IDSURI) initWithPrefixedURI:v2];

  return v3;
}

void sub_100117FDC(uint64_t a1)
{
  uint64_t v13 = *(void *)(a1 + 32);
  id v3 = +[NSArray arrayWithObjects:&v13 count:1];
  id v10 = 0;
  +[TransparencyGossip sthsReceivedFromPeers:v3 error:&v10];
  id v4 = v10;

  int v5 = +[IDSFoundationLog KeyTransparency];
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v6)
    {
      *(_DWORD *)buf = 138412290;
      id v12 = v4;
      uint64_t v7 = "Sending sth's to transparencyd failed with error: %@";
      int v8 = v5;
      uint32_t v9 = 12;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, buf, v9);
    }
  }
  else if (v6)
  {
    *(_WORD *)buf = 0;
    uint64_t v7 = "Successfully sent sth's to transparencyd.";
    int v8 = v5;
    uint32_t v9 = 2;
    goto LABEL_6;
  }
}

void sub_1001183DC(id a1)
{
  qword_100A4A6E0 = objc_alloc_init(IDSDGroupContextDataSource);

  _objc_release_x1();
}

void sub_100118A7C(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5, void *a6)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a5;
  id v14 = a6;
  int v15 = [v11 responseEntries];

  if (v15)
  {
    int v16 = [v11 responseEntries];
    __int16 v17 = [v16 lastObject];
    __int16 v18 = [v17 objectForKey:@"version"];
    id v19 = [v18 intValue];

    id v20 = objc_alloc((Class)ENGroupID);
    id v21 = objc_alloc((Class)ENStableGroupID);
    uint64_t v22 = [v11 responseEngramID];
    id v23 = [v21 initWithDataRepresentation:v22];
    id v24 = [v20 initWithStableGroupID:v23 generation:v19];

    unsigned int v25 = *(void **)(a1 + 32);
    uint64_t v26 = *(void *)(a1 + 40);
    uint64_t v27 = *(void *)(a1 + 48);
    v52[0] = _NSConcreteStackBlock;
    v52[1] = 3221225472;
    v52[2] = sub_100118F84;
    v52[3] = &unk_100982998;
    id v53 = *(id *)(a1 + 112);
    [v25 _groupFromServerResponse:v11 context:v26 groupID:v24 error:v27 resultCode:a4 resultDictionary:v13 allEntries:v14 completion:v52];
  }
  else if (v12)
  {
    uint64_t v28 = +[ENLog groupContext];
    if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT)) {
      sub_100711114();
    }

    __int16 v29 = +[ENLog groupContext];
    if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT)) {
      sub_100711054(v11);
    }

    (*(void (**)(void))(*(void *)(a1 + 112) + 16))();
  }
  else
  {
    id v30 = objc_alloc((Class)ENGroupID);
    id v31 = objc_alloc((Class)ENStableGroupID);
    uint64_t v32 = [v11 responseEngramID];
    id v33 = [v31 initWithDataRepresentation:v32];
    unsigned int v34 = [v11 responseVersion];
    id v35 = objc_msgSend(v30, "initWithStableGroupID:generation:", v33, objc_msgSend(v34, "intValue"));

    uint64_t v36 = +[ENLog groupContext];
    if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 138477827;
      id v55 = v35;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_INFO, "Saved group to group server {groupID: %{private}@}", buf, 0xCu);
    }

    long long v37 = +[ENLog groupContext];
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138477827;
      id v55 = v35;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "Saved group to group server {groupID: %{private}@}", buf, 0xCu);
    }

    long long v38 = *(void **)(a1 + 56);
    id v51 = 0;
    long long v39 = [v38 conversationGroupWithUpdatedGroupID:v35 error:&v51];
    id v40 = v51;
    id v41 = v40;
    if (v39)
    {
      id v50 = v40;
      id v42 = objc_alloc((Class)IDSConversationGroupCypher);
      uint64_t v43 = *(void *)(a1 + 64);
      uint64_t v44 = [*(id *)(a1 + 72) participants];
      id v45 = [v42 initWithConversationGroup:v39 deviceIdentity:v43 participants:v44];

      id v46 = [objc_alloc((Class)ENGroup) initWithGroupInfo:*(void *)(a1 + 72) groupID:v35 cypher:v45];
      uint64_t v47 = +[IDSFoundationLog groupCrypto];
      if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
      {
        [v46 groupID];
        uint64_t v48 = v49 = v45;
        *(_DWORD *)buf = 138543362;
        id v55 = v48;
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "Saved group to group server { groupID: %{public}@ }", buf, 0xCu);

        id v45 = v49;
      }

      (*(void (**)(void))(*(void *)(a1 + 112) + 16))();
      id v41 = v50;
    }
    else
    {
      (*(void (**)(void))(*(void *)(a1 + 112) + 16))();
    }
  }
}

void sub_100118F84(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (v3)
  {
    uint64_t v7 = ENGroupContextErrorItemKey;
    id v8 = v3;
    int v5 = +[NSDictionary dictionaryWithObjects:&v8 forKeys:&v7 count:1];
  }
  else
  {
    int v5 = 0;
  }
  BOOL v6 = +[NSError errorWithDomain:ENGroupContextErrorDomain code:-2100 userInfo:v5];
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100119730(uint64_t a1, void *a2)
{
  id v56 = a2;
  long long v58 = +[ENParticipant participantsByAlias:](ENParticipant, "participantsByAlias:");
  long long v88 = 0u;
  long long v89 = 0u;
  long long v90 = 0u;
  long long v91 = 0u;
  uint64_t v62 = a1;
  id obj = *(id *)(a1 + 32);
  id v60 = [obj countByEnumeratingWithState:&v88 objects:v102 count:16];
  id v3 = 0;
  if (v60)
  {
    uint64_t v59 = *(void *)v89;
    do
    {
      for (uint64_t i = 0; i != v60; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v89 != v59) {
          objc_enumerationMutation(obj);
        }
        int v5 = *(void **)(*((void *)&v88 + 1) + 8 * i);
        BOOL v6 = +[IDSFoundationLog groupCrypto];
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138543362;
          uint64_t v94 = v5;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Fetched Entry from GroupServer {entry: %{public}@}", buf, 0xCu);
        }

        uint64_t v7 = *(void **)(v62 + 40);
        id v8 = [v5 publicKeyData];
        uint32_t v9 = [v7 objectForKeyedSubscript:v8];

        if (v9)
        {
          id v61 = i;
          id v10 = [v9 sponsorAlias];
          id v11 = [v58 objectForKeyedSubscript:v10];

          long long v86 = 0u;
          long long v87 = 0u;
          long long v84 = 0u;
          long long v85 = 0u;
          id v12 = v11;
          id v13 = [v12 countByEnumeratingWithState:&v84 objects:v101 count:16];
          if (v13)
          {
            id v14 = v13;
            id v67 = v5;
            uint64_t v15 = *(void *)v85;
            id v64 = v12;
            uint64_t v65 = v9;
            uint64_t v63 = *(void *)v85;
            do
            {
              int v16 = 0;
              id v66 = v14;
              do
              {
                if (*(void *)v85 != v15) {
                  objc_enumerationMutation(v12);
                }
                __int16 v17 = [*(id *)(*((void *)&v84 + 1) + 8 * (void)v16) accountPublicKey];
                objc_opt_class();
                if (objc_opt_isKindOfClass())
                {
                  uint64_t v69 = v17;
                  id v70 = v17;
                  uint64_t v18 = [v70 signingIdentity];
                  uint64_t v71 = v18;
                  if (v18)
                  {
                    uint64_t v19 = v18;
                    id v20 = [v9 conversationKey];
                    id v21 = [v67 data];
                    uint64_t v22 = [v67 publicKeyData];
                    id v23 = [v67 signature];
                    id v24 = [v67 groupID];
                    unsigned int v25 = [v67 forwardingTicket];
                    id v83 = v3;
                    uint64_t v26 = +[IDSMPConversationGroup conversationGroupWithConversationKey:v20 fromPublicData:v21 publicKey:v22 signature:v23 groupID:v24 parent:0 parentPublicKey:0 forwardingTicket:v25 sponsor:v19 error:&v83];
                    id v68 = v83;

                    if (v26)
                    {
                      uint64_t v27 = +[IDSFoundationLog groupCrypto];
                      id v12 = v64;
                      __int16 v17 = v69;
                      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
                      {
                        uint64_t v28 = [v26 groupID];
                        *(_DWORD *)buf = 138543362;
                        uint64_t v94 = v28;
                        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Fetched Group from GroupServer {groupID: %{public}@}", buf, 0xCu);
                      }
                      __int16 v29 = [v67 groupID];
                      id v82 = v68;
                      id v30 = [v26 conversationGroupWithUpdatedGroupID:v29 error:&v82];
                      id v3 = v82;

                      uint32_t v9 = v65;
                      if (v30)
                      {
                        [*(id *)(v62 + 48) addObject:v30];

                        goto LABEL_40;
                      }
                      id v31 = +[ENLog groupContext];
                      if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT))
                      {
                        uint64_t v32 = [v67 groupID];
                        *(_DWORD *)buf = 138544130;
                        uint64_t v94 = v67;
                        __int16 v95 = 2114;
                        id v96 = v26;
                        __int16 v97 = 2114;
                        uint64_t v98 = v32;
                        id v33 = (void *)v32;
                        __int16 v99 = 2114;
                        id v100 = v3;
                        _os_log_fault_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_FAULT, "Failed to set groupID on created group {entry: %{public}@, group: %{public}@, groupID: %{public}@, error: %{public}@}", buf, 0x2Au);
                      }
                    }
                    else
                    {
                      id v31 = +[ENLog groupContext];
                      __int16 v17 = v69;
                      if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT))
                      {
                        *(_DWORD *)buf = 138543874;
                        id v3 = v68;
                        uint64_t v94 = v67;
                        __int16 v95 = 2114;
                        id v96 = v71;
                        __int16 v97 = 2114;
                        uint64_t v98 = (uint64_t)v68;
                        _os_log_fault_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_FAULT, "Failed to create group from server reponse entry {entry: %{public}@, publicSigningIdentity: %{public}@, error: %{public}@}", buf, 0x20u);
                      }
                      else
                      {
                        id v3 = v68;
                      }
                      id v12 = v64;
                      uint32_t v9 = v65;
                    }
                    uint64_t v15 = v63;

                    id v14 = v66;
                  }
                  else
                  {
                    uint64_t v26 = +[ENLog groupContext];
                    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
                    {
                      id v35 = *(void **)(v62 + 56);
                      uint64_t v36 = *(NSObject **)(v62 + 64);
                      *(_DWORD *)buf = 138543618;
                      uint64_t v94 = v35;
                      __int16 v95 = 2114;
                      id v96 = v36;
                      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Failed to create fetched group, could not create publicSigningIdentity {deviceIdentity: %{public}@, error: %{public}@", buf, 0x16u);
                    }
                  }

                  unsigned int v34 = v70;
                }
                else
                {
                  unsigned int v34 = +[ENLog groupContext];
                  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 138543362;
                    uint64_t v94 = v17;
                    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Unexpected sponsot accountIdentity {sponsorPublicAccountIdentity: %{public}@}", buf, 0xCu);
                  }
                }

                int v16 = (char *)v16 + 1;
              }
              while (v14 != v16);
              id v37 = [v12 countByEnumeratingWithState:&v84 objects:v101 count:16];
              id v14 = v37;
            }
            while (v37);
          }
LABEL_40:

          uint64_t i = v61;
        }
        else
        {
          id v12 = +[ENLog groupContext];
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            long long v38 = [v5 publicKeyData];
            long long v39 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [*(id *)(v62 + 40) count]);
            *(_DWORD *)buf = 138543618;
            uint64_t v94 = v38;
            __int16 v95 = 2114;
            id v96 = v39;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "No sponsor pair {entry.publicKeyData: %{public}@, keyToSponsorPairMap.lenth: %{public}@}", buf, 0x16u);
          }
        }
      }
      id v60 = [obj countByEnumeratingWithState:&v88 objects:v102 count:16];
    }
    while (v60);
  }

  id v40 = +[ENLog groupContext];
  if (os_log_type_enabled(v40, OS_LOG_TYPE_INFO))
  {
    id v41 = *(void **)(v62 + 48);
    *(_DWORD *)buf = 138543362;
    uint64_t v94 = v41;
    _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_INFO, "got groups %{public}@", buf, 0xCu);
  }

  long long v80 = 0u;
  long long v81 = 0u;
  long long v78 = 0u;
  long long v79 = 0u;
  id v42 = *(id *)(v62 + 48);
  id v43 = [v42 countByEnumeratingWithState:&v78 objects:v92 count:16];
  if (v43)
  {
    id v44 = v43;
    uint64_t v45 = *(void *)v79;
LABEL_47:
    uint64_t v46 = 0;
    while (1)
    {
      if (*(void *)v79 != v45) {
        objc_enumerationMutation(v42);
      }
      uint64_t v47 = *(void **)(*((void *)&v78 + 1) + 8 * v46);
      uint64_t v48 = [v47 groupID];
      unsigned __int8 v49 = [v48 isEqual:*(void *)(v62 + 72)];

      if (v49) {
        break;
      }
      if (v44 == (id)++v46)
      {
        id v44 = [v42 countByEnumeratingWithState:&v78 objects:v92 count:16];
        if (v44) {
          goto LABEL_47;
        }
        goto LABEL_53;
      }
    }
    id v50 = v47;

    if (!v50) {
      goto LABEL_56;
    }
    id v51 = *(void **)(v62 + 80);
    CFStringRef v52 = [v50 groupMembers];
    id v53 = [v52 allKeys];
    v72[0] = _NSConcreteStackBlock;
    v72[1] = 3221225472;
    v72[2] = sub_10011A110;
    v72[3] = &unk_1009829E8;
    id v73 = v50;
    id v74 = *(id *)(v62 + 56);
    id v75 = *(id *)(v62 + 88);
    id v76 = *(id *)(v62 + 72);
    id v77 = *(id *)(v62 + 104);
    id v54 = v50;
    [v51 _participantsForDestinations:v53 completion:v72];
  }
  else
  {
LABEL_53:

LABEL_56:
    id v55 = +[ENLog groupContext];
    if (os_log_type_enabled(v55, OS_LOG_TYPE_FAULT)) {
      sub_100711224();
    }

    (*(void (**)(void))(*(void *)(v62 + 104) + 16))();
  }
}

void sub_10011A110(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v9 = [objc_alloc((Class)IDSConversationGroupCypher) initWithConversationGroup:*(void *)(a1 + 32) deviceIdentity:*(void *)(a1 + 40) participants:v3];
  id v4 = objc_alloc((Class)_ENGroupInfo);
  int v5 = [*(id *)(a1 + 48) accountIdentity];
  BOOL v6 = [*(id *)(a1 + 32) applicationData];
  id v7 = [v4 initWithAccountIdentity:v5 paricipants:v3 sharedApplicationData:v6];

  id v8 = [objc_alloc((Class)ENGroup) initWithGroupInfo:v7 groupID:*(void *)(a1 + 56) cypher:v9];
  (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
}

id sub_10011A340(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return [*(id *)(a1 + 32) _groupFromServerResponse:a2 context:*(void *)(a1 + 40) groupID:*(void *)(a1 + 48) error:a3 resultCode:a4 resultDictionary:a5 allEntries:a6 completion:*(void *)(a1 + 56)];
}

void sub_10011AF1C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 count])
  {
    id v4 = +[ENParticipant participantsByAlias:v3];
    int v5 = [*(id *)(a1 + 32) sponsorAlias];
    BOOL v6 = [v4 objectForKeyedSubscript:v5];

    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    id obj = v6;
    id v7 = [obj countByEnumeratingWithState:&v50 objects:v62 count:16];
    if (v7)
    {
      uint64_t v36 = v4;
      id v37 = v3;
      uint64_t v8 = *(void *)v51;
      uint64_t v38 = *(void *)v51;
      while (2)
      {
        id v9 = 0;
        id v39 = v7;
        do
        {
          if (*(void *)v51 != v8) {
            objc_enumerationMutation(obj);
          }
          id v10 = *(void **)(*((void *)&v50 + 1) + 8 * (void)v9);
          id v11 = [v10 accountPublicKey];
          objc_opt_class();
          char isKindOfClass = objc_opt_isKindOfClass();

          if (isKindOfClass)
          {
            id v13 = [v10 accountPublicKey];
            id v42 = [*(id *)(a1 + 32) conversationKey];
            id v41 = [*(id *)(a1 + 40) data];
            id v14 = [*(id *)(a1 + 40) publicKeyData];
            uint64_t v15 = [*(id *)(a1 + 40) signature];
            int v16 = [*(id *)(a1 + 40) groupID];
            __int16 v17 = (void *)a1;
            uint64_t v18 = [*(id *)(a1 + 40) forwardingTicket];
            uint64_t v19 = [v13 signingIdentity];
            id v49 = 0;
            id v7 = +[IDSMPConversationGroup conversationGroupWithConversationKey:v42 fromPublicData:v41 publicKey:v14 signature:v15 groupID:v16 parent:0 parentPublicKey:0 forwardingTicket:v18 sponsor:v19 error:&v49];
            id v20 = v49;

            if (v7)
            {

              id v4 = v36;
              id v3 = v37;
              a1 = (uint64_t)v17;
              goto LABEL_21;
            }
            id v21 = +[ENLog groupContext];
            a1 = (uint64_t)v17;
            if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
            {
              uint64_t v23 = v17[5];
              uint64_t v22 = (void *)v17[6];
              uint64_t v24 = v17[4];
              *(_DWORD *)buf = 138544130;
              id v55 = v22;
              __int16 v56 = 2114;
              uint64_t v57 = v23;
              __int16 v58 = 2114;
              uint64_t v59 = v24;
              __int16 v60 = 2114;
              id v61 = v13;
              _os_log_fault_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_FAULT, "Failed group->groupPublicData -- Failed to create group {error: %{public}@, entry: %{public}@, pair: %{public}@, sponsor: %{public}@}", buf, 0x2Au);
            }

            uint64_t v8 = v38;
            id v7 = v39;
          }
          else
          {
            id v13 = +[ENLog groupContext];
            if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 138543362;
              id v55 = v10;
              _os_log_fault_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_FAULT, "Failed group->groupPublicData -- Unexpected sponsor accountKeyClass {sponsor: %{public}@}", buf, 0xCu);
            }
          }

          id v9 = (char *)v9 + 1;
        }
        while (v7 != v9);
        id v7 = [obj countByEnumeratingWithState:&v50 objects:v62 count:16];
        if (v7) {
          continue;
        }
        break;
      }
      id v4 = v36;
      id v3 = v37;
    }
LABEL_21:

    uint64_t v32 = [v7 groupMembers];
    id v33 = *(void **)(a1 + 56);
    unsigned int v34 = [v32 allKeys];
    v43[0] = _NSConcreteStackBlock;
    v43[1] = 3221225472;
    v43[2] = sub_10011B410;
    v43[3] = &unk_1009829E8;
    id v44 = v7;
    id v45 = *(id *)(a1 + 64);
    id v46 = *(id *)(a1 + 72);
    id v47 = *(id *)(a1 + 40);
    id v48 = *(id *)(a1 + 80);
    id v35 = v7;
    [v33 _participantsForDestinations:v34 completion:v43];
  }
  else
  {
    unsigned int v25 = +[ENLog groupContext];
    if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
      sub_100711574(a1, v25, v26, v27, v28, v29, v30, v31);
    }

    (*(void (**)(void))(*(void *)(a1 + 80) + 16))();
  }
}

void sub_10011B410(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [objc_alloc((Class)IDSConversationGroupCypher) initWithConversationGroup:*(void *)(a1 + 32) deviceIdentity:*(void *)(a1 + 40) participants:v3];
  id v5 = objc_alloc((Class)_ENGroupInfo);
  BOOL v6 = [*(id *)(a1 + 48) accountIdentity];
  id v7 = [*(id *)(a1 + 32) applicationData];
  id v8 = [v5 initWithAccountIdentity:v6 paricipants:v3 sharedApplicationData:v7];

  id v9 = objc_alloc((Class)ENGroup);
  id v10 = [*(id *)(a1 + 56) groupID];
  id v11 = [v9 initWithGroupInfo:v8 groupID:v10 cypher:v4];

  id v12 = +[ENLog groupContext];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
  {
    uint64_t v13 = *(void *)(a1 + 32);
    int v14 = 138477827;
    uint64_t v15 = v13;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "group->groupPublicData -- Success {group: %{private}@}", (uint8_t *)&v14, 0xCu);
  }

  (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
}

uint64_t sub_10011B710(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10011BFD0(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, v9, OS_LOG_TYPE_FAULT, a4, &a9, 0x16u);
}

void sub_10011D3F8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = [*(id *)(a1 + 32) queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10011D508;
  block[3] = &unk_100982AD8;
  id v12 = *(id *)(a1 + 40);
  id v13 = v5;
  uint64_t v8 = *(void *)(a1 + 32);
  id v14 = v6;
  uint64_t v15 = v8;
  char v18 = *(unsigned char *)(a1 + 64);
  uint64_t v17 = *(void *)(a1 + 56);
  id v16 = *(id *)(a1 + 48);
  id v9 = v6;
  id v10 = v5;
  dispatch_async(v7, block);
}

void sub_10011D508(uint64_t a1)
{
  unint64_t v2 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = *(void **)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v5 = *(void *)(a1 + 48);
    *(_DWORD *)buf = 138412802;
    id v33 = v3;
    __int16 v34 = 2112;
    uint64_t v35 = v4;
    __int16 v36 = 2112;
    uint64_t v37 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Completed CloudKit zone fetch {zoneID: %@, recordZonesByID: %@, fetchError: %@}", buf, 0x20u);
  }

  id v6 = [*(id *)(a1 + 40) objectForKeyedSubscript:*(void *)(a1 + 32)];
  [*(id *)(a1 + 56) setCachedRecordZone:v6];

  uint64_t v8 = (id *)(a1 + 48);
  id v7 = *(void **)(a1 + 48);
  if (!v7) {
    goto LABEL_20;
  }
  if ([v7 code] == (id)2)
  {
    id v9 = +[IDSFoundationLog KeyTransparency];
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "CloudKit zone not found -- creating it", buf, 2u);
    }

    if (qword_100A4A740 != -1) {
      dispatch_once(&qword_100A4A740, &stru_100983028);
    }
    id v10 = (void *)qword_100A4A738;
    if (!qword_100A4A738)
    {
      id v11 = +[IDSFoundationLog KeyTransparency];
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
        sub_100711A50();
      }

      id v10 = (void *)qword_100A4A738;
    }
    id v12 = [objc_alloc((Class)v10) initWithZoneID:*(void *)(a1 + 32)];
    id v13 = objc_alloc((Class)sub_10011D938());
    id v31 = v12;
    id v14 = +[NSArray arrayWithObjects:&v31 count:1];
    id v15 = [v13 initWithRecordZonesToSave:v14 recordZoneIDsToDelete:0];

    id v16 = [*(id *)(a1 + 56) container];
    uint64_t v17 = [v15 configuration];
    [v17 setContainer:v16];

    if (*(unsigned char *)(a1 + 80))
    {
      char v18 = [v15 configuration];
      [v18 setDiscretionaryNetworkBehavior:0];
    }
    double v19 = *(double *)(a1 + 72);
    id v20 = [v15 configuration];
    [v20 setTimeoutIntervalForRequest:v19];

    v29[0] = _NSConcreteStackBlock;
    v29[1] = 3221225472;
    v29[2] = sub_10011D9CC;
    v29[3] = &unk_100982AB0;
    id v21 = *(void **)(a1 + 64);
    v29[4] = *(void *)(a1 + 56);
    id v30 = v21;
    [v15 setModifyRecordZonesCompletionBlock:v29];
    uint64_t v22 = +[IDSFoundationLog KeyTransparency];
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      id v33 = v15;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Starting CloudKit operation to create KT zone {operation: %@}", buf, 0xCu);
    }

    uint64_t v23 = [*(id *)(a1 + 56) database];
    [v23 addOperation:v15];

    return;
  }
  if (*v8 && [*v8 code] != (id)2)
  {
    uint64_t v27 = +[IDSFoundationLog KeyTransparency];
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      sub_100711AD4();
    }

    uint64_t v28 = *(void *)(a1 + 64);
    if (v28)
    {
      uint64_t v26 = *(void (**)(void))(v28 + 16);
      goto LABEL_24;
    }
  }
  else
  {
LABEL_20:
    uint64_t v24 = +[IDSFoundationLog KeyTransparency];
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "CloudKit zone exists -- no need to create it", buf, 2u);
    }

    uint64_t v25 = *(void *)(a1 + 64);
    if (v25)
    {
      uint64_t v26 = *(void (**)(void))(v25 + 16);
LABEL_24:
      v26();
    }
  }
}

id sub_10011D938()
{
  if (qword_100A4A760 != -1) {
    dispatch_once(&qword_100A4A760, &stru_100983068);
  }
  uint64_t v0 = (void *)qword_100A4A758;
  if (!qword_100A4A758)
  {
    unint64_t v1 = +[IDSFoundationLog KeyTransparency];
    if (os_log_type_enabled(v1, OS_LOG_TYPE_FAULT)) {
      sub_100711B3C();
    }

    uint64_t v0 = (void *)qword_100A4A758;
  }

  return v0;
}

void sub_10011D9CC(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = [*(id *)(a1 + 32) queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10011DAE0;
  block[3] = &unk_100981B00;
  id v17 = v7;
  id v18 = v8;
  uint64_t v11 = *(void *)(a1 + 32);
  id v12 = *(void **)(a1 + 40);
  id v19 = v9;
  uint64_t v20 = v11;
  id v21 = v12;
  id v13 = v9;
  id v14 = v8;
  id v15 = v7;
  dispatch_async(v10, block);
}

uint64_t sub_10011DAE0(uint64_t a1)
{
  unint64_t v2 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v5 = *(void *)(a1 + 48);
    int v12 = 138412802;
    uint64_t v13 = v3;
    __int16 v14 = 2112;
    uint64_t v15 = v4;
    __int16 v16 = 2112;
    uint64_t v17 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Completed CloudKit zone modification (save) operation {savedRecordZones: %@, deletedRecordZoneIDs: %@, modifyError: %@}", (uint8_t *)&v12, 0x20u);
  }

  id v6 = [*(id *)(a1 + 32) firstObject];
  [*(id *)(a1 + 56) setCachedRecordZone:v6];

  uint64_t v7 = *(void *)(a1 + 48);
  id v8 = +[IDSFoundationLog KeyTransparency];
  id v9 = v8;
  if (v7)
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      sub_100711BC0();
    }

    uint64_t result = *(void *)(a1 + 64);
    if (result)
    {
      uint64_t v11 = *(uint64_t (**)(void))(result + 16);
      return v11();
    }
  }
  else
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v12) = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Successfully created CloudKit zone", (uint8_t *)&v12, 2u);
    }

    uint64_t result = *(void *)(a1 + 64);
    if (result)
    {
      uint64_t v11 = *(uint64_t (**)(void))(result + 16);
      return v11();
    }
  }
  return result;
}

id sub_10011DCE8(uint64_t a1)
{
  return _objc_msgSend(*(id *)(a1 + 32), "setCachedManateeAvailability:");
}

void sub_10011DFB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v17 - 144), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10011DFEC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10011DFFC(uint64_t a1)
{
}

void sub_10011E004(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [*(id *)(a1 + 32) queue];
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_10011E0C4;
  v7[3] = &unk_100982B78;
  uint64_t v5 = *(void *)(a1 + 32);
  long long v9 = *(_OWORD *)(a1 + 40);
  void v7[4] = v5;
  id v8 = v3;
  id v6 = v3;
  dispatch_async(v4, v7);
}

void sub_10011E0C4(uint64_t a1)
{
  unint64_t v1 = *(void **)(a1 + 32);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_10011E168;
  v4[3] = &unk_100982B50;
  uint64_t v6 = *(void *)(a1 + 56);
  void v4[4] = v1;
  long long v3 = *(_OWORD *)(a1 + 40);
  id v2 = (id)v3;
  long long v5 = v3;
  objc_msgSend(v1, "_no_timeout_verifyEncryptionPrerequisitesWithCompletion:", v4);
}

void sub_10011E168(uint64_t a1, char a2, uint64_t a3, void *a4)
{
  id v6 = a4;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = a2;
  id v8 = v6;
  if (v6)
  {
    uint64_t v7 = [*(id *)(a1 + 32) _clientErrorWithCode:-1000 debugDescription:@"Unable to fetch CloudKit account info" underlyingError:v6];
  }
  else
  {
    uint64_t v7 = 0;
  }
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40), v7);
  if (v8) {

  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_10011E21C(uint64_t a1, int a2)
{
  uint64_t v4 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v5 = @"NO";
    if (a2) {
      CFStringRef v5 = @"YES";
    }
    *(_DWORD *)buf = 138412290;
    CFStringRef v14 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Account device-to-device encryption eligibility task final block called {timedOut: %@}", buf, 0xCu);
  }

  id v6 = [*(id *)(a1 + 32) queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10011E384;
  block[3] = &unk_100982BC8;
  char v12 = a2;
  void block[4] = *(void *)(a1 + 32);
  long long v8 = *(_OWORD *)(a1 + 40);
  id v7 = (id)v8;
  long long v10 = v8;
  uint64_t v11 = *(void *)(a1 + 56);
  dispatch_async(v6, block);
}

uint64_t sub_10011E384(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v2 = [*(id *)(a1 + 32) _clientErrorWithCode:-4000 debugDescription:@"Timed out fetching account key transparency eligibility." underlyingError:0];
    uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8);
    uint64_t v4 = *(void **)(v3 + 40);
    *(void *)(v3 + 40) = v2;
  }
  uint64_t result = *(void *)(a1 + 40);
  if (result)
  {
    id v6 = *(uint64_t (**)(void))(result + 16);
    return v6();
  }
  return result;
}

void sub_10011E538(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = [*(id *)(a1 + 32) queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10011E620;
  block[3] = &unk_1009800E8;
  id v11 = v5;
  id v12 = v6;
  id v13 = *(id *)(a1 + 40);
  id v8 = v6;
  id v9 = v5;
  dispatch_async(v7, block);
}

uint64_t sub_10011E620(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) deviceToDeviceEncryptionAvailability];
  unsigned int v3 = [*(id *)(a1 + 32) supportsDeviceToDeviceEncryption];
  uint64_t v4 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v5 = @"NO";
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v7 = *(void *)(a1 + 40);
    if (v3) {
      CFStringRef v5 = @"YES";
    }
    int v9 = 138413058;
    CFStringRef v10 = v5;
    __int16 v11 = 2048;
    id v12 = v2;
    __int16 v13 = 2112;
    uint64_t v14 = v6;
    __int16 v15 = 2112;
    uint64_t v16 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Completed CloudKit container account info fetch {supportsDeviceToDeviceEncryption: %@, deviceToDeviceEncryptionStatus: %ld, accountInfo: %@, accountInfoError: %@}", (uint8_t *)&v9, 0x2Au);
  }

  uint64_t result = *(void *)(a1 + 48);
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

void sub_10011EAA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_10011EAC8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [*(id *)(a1 + 32) queue];
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  v9[2] = sub_10011EBC0;
  v9[3] = &unk_100982C88;
  CFStringRef v5 = *(void **)(a1 + 40);
  void v9[4] = *(void *)(a1 + 32);
  id v10 = v5;
  id v11 = *(id *)(a1 + 48);
  id v6 = *(id *)(a1 + 56);
  uint64_t v7 = *(void *)(a1 + 64);
  id v13 = v3;
  uint64_t v14 = v7;
  id v12 = v6;
  id v8 = v3;
  dispatch_async(v4, v9);
}

void sub_10011EBC0(uint64_t a1)
{
  unint64_t v1 = *(void **)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 48);
  uint64_t v4 = *(void *)(a1 + 56);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_10011EC70;
  v7[3] = &unk_100982C60;
  long long v6 = *(_OWORD *)(a1 + 64);
  id v5 = (id)v6;
  long long v8 = v6;
  objc_msgSend(v1, "_no_timeout_upsertKeyTransparencyDeviceRecord:recordsToModify:recordsToDelete:completion:", v2, v3, v4, v7);
}

void sub_10011EC70(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10011ECD8(uint64_t a1, int a2)
{
  id v4 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v5 = @"NO";
    if (a2) {
      CFStringRef v5 = @"YES";
    }
    *(_DWORD *)buf = 138412290;
    CFStringRef v13 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Trusted device upsert task final block called {timedOut: %@}", buf, 0xCu);
  }

  long long v6 = [*(id *)(a1 + 32) queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10011EE38;
  block[3] = &unk_100982CD8;
  char v11 = a2;
  void block[4] = *(void *)(a1 + 32);
  long long v8 = *(_OWORD *)(a1 + 40);
  id v7 = (id)v8;
  long long v10 = v8;
  dispatch_async(v6, block);
}

uint64_t sub_10011EE38(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56))
  {
    uint64_t v2 = [*(id *)(a1 + 32) _clientErrorWithCode:-4000 debugDescription:@"Timed out upserting key transparency device record" underlyingError:0];
    uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8);
    id v4 = *(void **)(v3 + 40);
    *(void *)(v3 + 40) = v2;
  }
  uint64_t result = *(void *)(a1 + 40);
  if (result)
  {
    long long v6 = *(uint64_t (**)(void))(result + 16);
    return v6();
  }
  return result;
}

void sub_10011F14C(uint64_t a1, uint64_t a2, char a3, void *a4)
{
  id v6 = a4;
  if (a3)
  {
    id v7 = *(void **)(a1 + 32);
    double v8 = *(double *)(a1 + 72);
    uint64_t v9 = *(unsigned __int8 *)(a1 + 80);
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 3221225472;
    v21[2] = sub_10011F340;
    v21[3] = &unk_100982DC0;
    id v10 = *(id *)(a1 + 64);
    uint64_t v11 = *(void *)(a1 + 32);
    id v12 = *(void **)(a1 + 40);
    id v25 = v10;
    void v21[4] = v11;
    id v22 = v12;
    id v23 = *(id *)(a1 + 48);
    id v24 = *(id *)(a1 + 56);
    char v27 = *(unsigned char *)(a1 + 80);
    uint64_t v26 = *(void *)(a1 + 72);
    [v7 _createZoneIfNeededUsingTimeIntervalForRequest:v9 isNonDiscretionary:v21 completion:v8];

    CFStringRef v13 = v25;
LABEL_13:

    goto LABEL_14;
  }
  uint64_t v14 = +[IDSFoundationLog KeyTransparency];
  BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    if (v15)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Device to device encryption is not currently able to be determined for this CloudKit container -- not upserting trusted device record", buf, 2u);
    }

    uint64_t v16 = *(void *)(a1 + 64);
    if (v16)
    {
      uint64_t v17 = *(void **)(a1 + 32);
      CFStringRef v18 = @"Failed to fetch device-to-device encryption availability status";
      uint64_t v19 = -1000;
      id v20 = v6;
LABEL_12:
      CFStringRef v13 = [v17 _clientErrorWithCode:v19 debugDescription:v18 underlyingError:v20];
      (*(void (**)(uint64_t, void *))(v16 + 16))(v16, v13);
      goto LABEL_13;
    }
  }
  else
  {
    if (v15)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Device to device encryption is not currently available for this CloudKit container -- not upserting trusted device record", buf, 2u);
    }

    uint64_t v16 = *(void *)(a1 + 64);
    if (v16)
    {
      uint64_t v17 = *(void **)(a1 + 32);
      CFStringRef v18 = @"Device-to-device encryption is not available";
      uint64_t v19 = -3000;
      id v20 = 0;
      goto LABEL_12;
    }
  }
LABEL_14:
}

void sub_10011F340(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (!v3)
  {
    id v6 = objc_alloc_init((Class)NSMutableArray);
    id v7 = [*(id *)(a1 + 32) _cloudKitRecordForDeviceRecord:*(void *)(a1 + 40)];
    if (v7)
    {
      [v6 addObject:v7];
      long long v39 = 0u;
      long long v40 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      id v8 = *(id *)(a1 + 48);
      id v9 = [v8 countByEnumeratingWithState:&v37 objects:v43 count:16];
      if (v9)
      {
        id v10 = v9;
        uint64_t v11 = *(void *)v38;
        do
        {
          for (uint64_t i = 0; i != v10; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v38 != v11) {
              objc_enumerationMutation(v8);
            }
            CFStringRef v13 = [*(id *)(a1 + 32) _cloudKitRecordForDeviceRecord:*(void *)(*((void *)&v37 + 1) + 8 * i)];
            [v6 addObject:v13];
          }
          id v10 = [v8 countByEnumeratingWithState:&v37 objects:v43 count:16];
        }
        while (v10);
      }

      uint64_t v14 = *(void **)(a1 + 56);
      v36[0] = _NSConcreteStackBlock;
      v36[1] = 3221225472;
      v36[2] = sub_10011F7E8;
      v36[3] = &unk_100982D48;
      v36[4] = *(void *)(a1 + 32);
      BOOL v15 = objc_msgSend(v14, "__imArrayByApplyingBlock:", v36);
      if (qword_100A4A770 != -1) {
        dispatch_once(&qword_100A4A770, &stru_100983088);
      }
      uint64_t v16 = (void *)qword_100A4A768;
      if (!qword_100A4A768)
      {
        uint64_t v17 = +[IDSFoundationLog KeyTransparency];
        if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT)) {
          sub_100711C90();
        }

        uint64_t v16 = (void *)qword_100A4A768;
      }
      id v18 = [objc_alloc((Class)v16) initWithRecordsToSave:v6 recordIDsToDelete:v15];
      [v18 setSavePolicy:2];
      uint64_t v19 = [*(id *)(a1 + 32) container];
      id v20 = [v18 configuration];
      [v20 setContainer:v19];

      if (*(unsigned char *)(a1 + 80))
      {
        id v21 = [v18 configuration];
        [v21 setDiscretionaryNetworkBehavior:0];
      }
      double v22 = *(double *)(a1 + 72);
      id v23 = [v18 configuration];
      [v23 setTimeoutIntervalForRequest:v22];

      uint64_t v29 = _NSConcreteStackBlock;
      uint64_t v30 = 3221225472;
      id v31 = sub_10011F7F4;
      uint64_t v32 = &unk_100982D98;
      uint64_t v33 = *(void *)(a1 + 32);
      id v35 = *(id *)(a1 + 64);
      id v34 = *(id *)(a1 + 40);
      [v18 setModifyRecordsCompletionBlock:&v29];
      id v24 = +[IDSFoundationLog KeyTransparency];
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        id v42 = v18;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Starting CloudKit operation to modify (save) KT record {operation: %@}", buf, 0xCu);
      }

      id v25 = [*(id *)(a1 + 32) database];
      [v25 addOperation:v18];
    }
    else
    {
      uint64_t v26 = +[IDSFoundationLog KeyTransparency];
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
        sub_100711C28();
      }

      uint64_t v27 = *(void *)(a1 + 64);
      if (v27)
      {
        uint64_t v28 = [*(id *)(a1 + 32) _clientErrorWithCode:-2000 debugDescription:@"Unable to create CloudKit record for provided device record" underlyingError:0];
        (*(void (**)(uint64_t, void *))(v27 + 16))(v27, v28);
      }
    }

    goto LABEL_30;
  }
  id v4 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
    sub_100711D14();
  }

  uint64_t v5 = *(void *)(a1 + 64);
  if (v5)
  {
    id v6 = [*(id *)(a1 + 32) _clientErrorWithCode:-1000 debugDescription:0 underlyingError:v3];
    (*(void (**)(uint64_t, id))(v5 + 16))(v5, v6);
LABEL_30:
  }
}

id sub_10011F7E8(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) _recordIDForDeviceRecord:a2];
}

void sub_10011F7F4(id *a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = [a1[4] queue];
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  v15[2] = sub_10011F920;
  v15[3] = &unk_100982D70;
  id v16 = v7;
  id v17 = v8;
  id v11 = a1[4];
  id v18 = v9;
  id v19 = v11;
  id v21 = a1[6];
  id v20 = a1[5];
  id v12 = v9;
  id v13 = v8;
  id v14 = v7;
  dispatch_async(v10, v15);
}

void sub_10011F920(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v5 = *(void *)(a1 + 48);
    int v12 = 138412802;
    uint64_t v13 = v3;
    __int16 v14 = 2112;
    uint64_t v15 = v4;
    __int16 v16 = 2112;
    uint64_t v17 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Completed CloudKit save record operation {savedRecords: %@, deletedRecordIDs: %@, operationError: %@}", (uint8_t *)&v12, 0x20u);
  }

  uint64_t v6 = *(void *)(a1 + 48);
  id v7 = +[IDSFoundationLog KeyTransparency];
  id v8 = v7;
  if (v6)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      sub_100711D48();
    }

    [*(id *)(a1 + 56) setCachedRecordZone:0];
    uint64_t v9 = *(void *)(a1 + 72);
    if (v9)
    {
      id v10 = [*(id *)(a1 + 56) _clientErrorWithCode:-1000 debugDescription:0 underlyingError:*(void *)(a1 + 48)];
      (*(void (**)(uint64_t, void *))(v9 + 16))(v9, v10);
    }
  }
  else
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v12) = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "CloudKit save operation for trusted device succeeded", (uint8_t *)&v12, 2u);
    }

    [*(id *)(a1 + 56) setLastSuccessfulUpsertDeviceRecord:*(void *)(a1 + 64)];
    uint64_t v11 = *(void *)(a1 + 72);
    if (v11) {
      (*(void (**)(uint64_t, void))(v11 + 16))(v11, 0);
    }
  }
}

void sub_10011FE08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10011FE30(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [*(id *)(a1 + 32) queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10011FEEC;
  block[3] = &unk_100981D00;
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 40);
  id v9 = v3;
  uint64_t v10 = v6;
  void block[4] = v5;
  id v7 = v3;
  dispatch_async(v4, block);
}

void sub_10011FEEC(uint64_t a1)
{
  unint64_t v1 = *(void **)(a1 + 32);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_10011FF84;
  v4[3] = &unk_100982C60;
  long long v3 = *(_OWORD *)(a1 + 40);
  id v2 = (id)v3;
  long long v5 = v3;
  objc_msgSend(v1, "_no_timeout_nukeKeyTransparencyDeviceRecordsWithCompletion:", v4);
}

void sub_10011FF84(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10011FFEC(uint64_t a1, int a2)
{
  id v4 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v5 = @"NO";
    if (a2) {
      CFStringRef v5 = @"YES";
    }
    *(_DWORD *)buf = 138412290;
    CFStringRef v13 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Key transparency device record nuke task final block called {timedOut: %@}", buf, 0xCu);
  }

  uint64_t v6 = [*(id *)(a1 + 32) queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10012014C;
  block[3] = &unk_100982CD8;
  char v11 = a2;
  void block[4] = *(void *)(a1 + 32);
  long long v8 = *(_OWORD *)(a1 + 40);
  id v7 = (id)v8;
  long long v10 = v8;
  dispatch_async(v6, block);
}

uint64_t sub_10012014C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56))
  {
    uint64_t v2 = [*(id *)(a1 + 32) _clientErrorWithCode:-4000 debugDescription:@"Timed out nuking key transparency device records" underlyingError:0];
    uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8);
    id v4 = *(void **)(v3 + 40);
    *(void *)(v3 + 40) = v2;
  }
  uint64_t result = *(void *)(a1 + 40);
  if (result)
  {
    uint64_t v6 = *(uint64_t (**)(void))(result + 16);
    return v6();
  }
  return result;
}

void sub_1001204C8(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  long long v10 = [*(id *)(a1 + 32) queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1001205E0;
  block[3] = &unk_100980950;
  id v16 = v7;
  id v17 = v8;
  id v18 = v9;
  id v11 = *(id *)(a1 + 40);
  uint64_t v19 = *(void *)(a1 + 32);
  id v20 = v11;
  id v12 = v9;
  id v13 = v8;
  id v14 = v7;
  dispatch_async(v10, block);
}

void sub_1001205E0(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v5 = *(void *)(a1 + 48);
    int v12 = 138412802;
    uint64_t v13 = v3;
    __int16 v14 = 2112;
    uint64_t v15 = v4;
    __int16 v16 = 2112;
    uint64_t v17 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Completed CloudKit zone modification (delete) operation {savedRecordZones: %@, deletedRecordZoneIDs: %@, modifyError: %@}", (uint8_t *)&v12, 0x20u);
  }

  uint64_t v6 = *(void *)(a1 + 48);
  id v7 = +[IDSFoundationLog KeyTransparency];
  id v8 = v7;
  if (v6)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      sub_100711DB0();
    }

    uint64_t v9 = *(void *)(a1 + 64);
    if (v9)
    {
      long long v10 = [*(id *)(a1 + 56) _clientErrorWithCode:-1000 debugDescription:0 underlyingError:*(void *)(a1 + 48)];
      (*(void (**)(uint64_t, void *))(v9 + 16))(v9, v10);
    }
  }
  else
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v12) = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Successfully deleted CloudKit zone", (uint8_t *)&v12, 2u);
    }

    uint64_t v11 = *(void *)(a1 + 64);
    if (v11) {
      (*(void (**)(uint64_t, void))(v11 + 16))(v11, 0);
    }
  }
}

void sub_100120A70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v17 - 160), 8);
  _Unwind_Resume(a1);
}

void sub_100120AA4(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [*(id *)(a1 + 32) queue];
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_100120B64;
  v7[3] = &unk_100982B78;
  uint64_t v5 = *(void *)(a1 + 32);
  long long v9 = *(_OWORD *)(a1 + 40);
  void v7[4] = v5;
  id v8 = v3;
  id v6 = v3;
  dispatch_async(v4, v7);
}

void sub_100120B64(uint64_t a1)
{
  unint64_t v1 = *(void **)(a1 + 32);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_100120C04;
  v4[3] = &unk_100982E30;
  uint64_t v6 = *(void *)(a1 + 56);
  long long v3 = *(_OWORD *)(a1 + 40);
  id v2 = (id)v3;
  long long v5 = v3;
  objc_msgSend(v1, "_no_timeout_fetchKeyTransparencyDeviceRecordsWithCompletion:", v4);
}

void sub_100120C04(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = *(void *)(a1[5] + 8);
  id v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v5;
  id v12 = v5;

  uint64_t v9 = *(void *)(a1[6] + 8);
  long long v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v6;
  id v11 = v6;

  (*(void (**)(void))(a1[4] + 16))();
}

void sub_100120CA8(uint64_t a1, int a2)
{
  uint64_t v4 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v5 = @"NO";
    if (a2) {
      CFStringRef v5 = @"YES";
    }
    *(_DWORD *)buf = 138412290;
    CFStringRef v14 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Key transparency device record fetch task final block called {timedOut: %@}", buf, 0xCu);
  }

  id v6 = [*(id *)(a1 + 32) queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100120E10;
  block[3] = &unk_100982BC8;
  char v12 = a2;
  void block[4] = *(void *)(a1 + 32);
  long long v8 = *(_OWORD *)(a1 + 40);
  id v7 = (id)v8;
  long long v10 = v8;
  uint64_t v11 = *(void *)(a1 + 56);
  dispatch_async(v6, block);
}

uint64_t sub_100120E10(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v2 = [*(id *)(a1 + 32) _clientErrorWithCode:-4000 debugDescription:@"Timed out fetching key transparency device records" underlyingError:0];
    uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8);
    uint64_t v4 = *(void **)(v3 + 40);
    *(void *)(v3 + 40) = v2;
  }
  uint64_t result = *(void *)(a1 + 40);
  if (result)
  {
    id v6 = *(uint64_t (**)(void))(result + 16);
    return v6();
  }
  return result;
}

id sub_10012127C(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = [*(id *)(a1 + 32) currentDeviceRecordsPromise];
    int v5 = 138412290;
    id v6 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Clearing cached promise for key transparency device records {promise: %@}", (uint8_t *)&v5, 0xCu);
  }
  return [*(id *)(a1 + 32) setCurrentDeviceRecordsPromise:0];
}

void sub_100121350(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void **)(a1 + 32);
  id v4 = a2;
  int v5 = [v3 queue];
  dispatch_assert_queue_V2(v5);

  id v6 = [v4 state];
  uint64_t v7 = *(void *)(a1 + 40);
  if (v6)
  {
    id v8 = [v4 error];

    (*(void (**)(uint64_t, void, id))(v7 + 16))(v7, 0, v8);
  }
  else
  {
    id v8 = [v4 value];

    (*(void (**)(uint64_t, id, void))(v7 + 16))(v7, v8, 0);
  }
}

void sub_1001215AC(uint64_t a1, uint64_t a2, char a3, void *a4)
{
  id v6 = a4;
  if (a3)
  {
    double v7 = *(double *)(a1 + 48);
    uint64_t v8 = *(unsigned __int8 *)(a1 + 56);
    v20[0] = _NSConcreteStackBlock;
    v20[1] = 3221225472;
    v20[2] = sub_100121748;
    v20[3] = &unk_100982F40;
    uint64_t v9 = *(void **)(a1 + 40);
    id v10 = *(id *)(a1 + 32);
    uint64_t v11 = *(void *)(a1 + 40);
    id v21 = v10;
    uint64_t v22 = v11;
    char v24 = *(unsigned char *)(a1 + 56);
    uint64_t v23 = *(void *)(a1 + 48);
    [v9 _createZoneIfNeededUsingTimeIntervalForRequest:v8 isNonDiscretionary:v20 completion:v7];
    char v12 = v21;
  }
  else
  {
    uint64_t v13 = +[IDSFoundationLog KeyTransparency];
    BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
    if (v6)
    {
      if (v14)
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Device to device encryption is not currently available for this CloudKit container -- not fetching trusted device record", buf, 2u);
      }

      __int16 v16 = *(void **)(a1 + 32);
      uint64_t v15 = *(void **)(a1 + 40);
      CFStringRef v17 = @"Failed to fetch device-to-device encryption availability status";
      uint64_t v18 = -1000;
      id v19 = v6;
    }
    else
    {
      if (v14)
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Device to device encryption is not currently available for this CloudKit container -- not fetching trusted device record", buf, 2u);
      }

      __int16 v16 = *(void **)(a1 + 32);
      uint64_t v15 = *(void **)(a1 + 40);
      CFStringRef v17 = @"Device-to-device encryption is not available";
      uint64_t v18 = -3000;
      id v19 = 0;
    }
    char v12 = [v15 _clientErrorWithCode:v18 debugDescription:v17 underlyingError:v19];
    [v16 failWithError:v12];
  }
}

void sub_100121748(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = +[IDSFoundationLog KeyTransparency];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_100711F20();
    }

    int v5 = *(void **)(a1 + 32);
    id v6 = [*(id *)(a1 + 40) _clientErrorWithCode:-1000 debugDescription:0 underlyingError:v3];
    [v5 failWithError:v6];
  }
  else
  {
    id v6 = +[NSPredicate predicateWithValue:1];
    if (qword_100A4A780 != -1) {
      dispatch_once(&qword_100A4A780, &stru_1009830A8);
    }
    double v7 = (void *)qword_100A4A778;
    if (!qword_100A4A778)
    {
      uint64_t v8 = +[IDSFoundationLog KeyTransparency];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
        sub_100711E9C();
      }

      double v7 = (void *)qword_100A4A778;
    }
    id v9 = objc_alloc((Class)v7);
    id v10 = [*(id *)(a1 + 40) _recordType];
    id v11 = [v9 initWithRecordType:v10 predicate:v6];

    if (qword_100A4A790 != -1) {
      dispatch_once(&qword_100A4A790, &stru_1009830C8);
    }
    char v12 = (void *)qword_100A4A788;
    if (!qword_100A4A788)
    {
      uint64_t v13 = +[IDSFoundationLog KeyTransparency];
      if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT)) {
        sub_100711E18();
      }

      char v12 = (void *)qword_100A4A788;
    }
    id v14 = [objc_alloc((Class)v12) initWithQuery:v11];
    uint64_t v15 = [*(id *)(a1 + 40) _zoneID];
    [v14 setZoneID:v15];

    __int16 v16 = [*(id *)(a1 + 40) container];
    CFStringRef v17 = [v14 configuration];
    [v17 setContainer:v16];

    if (*(unsigned char *)(a1 + 56))
    {
      uint64_t v18 = [v14 configuration];
      [v18 setDiscretionaryNetworkBehavior:0];
    }
    double v19 = *(double *)(a1 + 48);
    id v20 = [v14 configuration];
    [v20 setTimeoutIntervalForRequest:v19];

    v31[0] = 0;
    v31[1] = v31;
    v31[2] = 0x3032000000;
    v31[3] = sub_10011DFEC;
    v31[4] = sub_10011DFFC;
    id v32 = (id)0xAAAAAAAAAAAAAAAALL;
    id v32 = objc_alloc_init((Class)NSMutableArray);
    v30[0] = _NSConcreteStackBlock;
    v30[1] = 3221225472;
    v30[2] = sub_100121BE0;
    v30[3] = &unk_100982EA0;
    v30[4] = *(void *)(a1 + 40);
    v30[5] = v31;
    [v14 setRecordFetchedBlock:v30];
    v26[0] = _NSConcreteStackBlock;
    v26[1] = 3221225472;
    v26[2] = sub_100121DC4;
    v26[3] = &unk_100982F18;
    uint64_t v29 = v31;
    int8x16_t v25 = *(int8x16_t *)(a1 + 32);
    id v21 = (id)v25.i64[0];
    int8x16_t v27 = vextq_s8(v25, v25, 8uLL);
    id v22 = v11;
    id v28 = v22;
    [v14 setQueryCompletionBlock:v26];
    uint64_t v23 = +[IDSFoundationLog KeyTransparency];
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      id v34 = v22;
      __int16 v35 = 2112;
      id v36 = v14;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Starting CloudKit operation to query KT records {query: %@, operation: %@}", buf, 0x16u);
    }

    char v24 = [*(id *)(a1 + 40) database];
    [v24 addOperation:v14];

    _Block_object_dispose(v31, 8);
  }
}

void sub_100121BBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100121BE0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [*(id *)(a1 + 32) queue];
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_100121C98;
  v7[3] = &unk_100980368;
  uint64_t v5 = *(void *)(a1 + 40);
  id v8 = v3;
  uint64_t v9 = v5;
  id v6 = v3;
  dispatch_async(v4, v7);
}

id sub_100121C98(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = *(void **)(a1 + 32);
    id v4 = [v3 encryptedValues];
    uint64_t v5 = [v4 objectForKeyedSubscript:@"IDSKTDevice"];
    id v6 = [*(id *)(a1 + 32) objectForKeyedSubscript:@"IDSKTMetadata"];
    int v8 = 138412802;
    uint64_t v9 = v3;
    __int16 v10 = 2112;
    id v11 = v5;
    __int16 v12 = 2112;
    uint64_t v13 = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Fetched CloudKit record of trusted device {record: %@, device: %@, deviceMetadata: %@}", (uint8_t *)&v8, 0x20u);
  }
  return [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) addObject:*(void *)(a1 + 32)];
}

void sub_100121DC4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  double v7 = [*(id *)(a1 + 32) queue];
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_100121ECC;
  v12[3] = &unk_100982EF0;
  id v13 = v6;
  id v14 = v5;
  uint64_t v18 = *(void *)(a1 + 56);
  id v8 = *(id *)(a1 + 40);
  uint64_t v9 = *(void *)(a1 + 32);
  id v15 = v8;
  uint64_t v16 = v9;
  id v17 = *(id *)(a1 + 48);
  id v10 = v5;
  id v11 = v6;
  dispatch_async(v7, v12);
}

void sub_100121ECC(void *a1)
{
  uint64_t v2 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = (void *)a1[4];
    id v4 = (void *)a1[5];
    uint64_t v5 = *(void *)(*(void *)(a1[9] + 8) + 40);
    *(_DWORD *)buf = 138412802;
    id v31 = v3;
    __int16 v32 = 2112;
    uint64_t v33 = v4;
    __int16 v34 = 2112;
    uint64_t v35 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Completed CloudKit query for trusted devices {queryError: %@, cursor: %@ results: %@}", buf, 0x20u);
  }

  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  uint64_t v23 = a1;
  id v6 = *(id *)(*(void *)(a1[9] + 8) + 40);
  id v7 = [v6 countByEnumeratingWithState:&v25 objects:v29 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v26;
    do
    {
      for (uint64_t i = 0; i != v8; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v26 != v9) {
          objc_enumerationMutation(v6);
        }
        id v11 = *(void **)(*((void *)&v25 + 1) + 8 * i);
        __int16 v12 = +[IDSFoundationLog KeyTransparency];
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          id v13 = [v11 encryptedValues];
          id v14 = [v13 objectForKeyedSubscript:@"IDSKTDevice"];
          id v15 = [v11 objectForKeyedSubscript:@"IDSKTMetadata"];
          *(_DWORD *)buf = 138412546;
          id v31 = v14;
          __int16 v32 = 2112;
          uint64_t v33 = v15;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Found device data from CloudKit record {device: %@, deviceMetadata: %@}", buf, 0x16u);
        }
      }
      id v8 = [v6 countByEnumeratingWithState:&v25 objects:v29 count:16];
    }
    while (v8);
  }

  uint64_t v16 = (void *)v23[4];
  if (v16)
  {
    if ([v16 code] == (id)11)
    {
LABEL_21:
      [(id)v23[6] fulfillWithValue:&__NSArray0__struct];
      return;
    }
    if (v23[4]) {
      goto LABEL_16;
    }
  }
  if (![*(id *)(*(void *)(v23[9] + 8) + 40) count]) {
    goto LABEL_21;
  }
LABEL_16:
  if ([*(id *)(*(void *)(v23[9] + 8) + 40) count])
  {
    id v17 = *(void **)(*(void *)(v23[9] + 8) + 40);
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 3221225472;
    v24[2] = sub_100122258;
    v24[3] = &unk_100982EC8;
    void v24[4] = v23[7];
    uint64_t v18 = objc_msgSend(v17, "__imArrayByApplyingBlock:", v24);
    if (v18) {
      double v19 = v18;
    }
    else {
      double v19 = &__NSArray0__struct;
    }
    [(id)v23[6] fulfillWithValue:v19];
  }
  else
  {
    id v20 = +[IDSFoundationLog KeyTransparency];
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      sub_100711F54();
    }

    [(id)v23[7] setCachedRecordZone:0];
    id v21 = (void *)v23[6];
    id v22 = [(id)v23[7] _clientErrorWithCode:-1000 debugDescription:0 underlyingError:v23[4]];
    [v21 failWithError:v22];
  }
}

id sub_100122258(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) _deviceRecordForCloudKitRecord:a2];
}

void sub_100122CC0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = im_primary_queue();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100122D88;
  block[3] = &unk_10097E418;
  id v9 = v3;
  id v5 = *(id *)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 40);
  id v10 = v5;
  uint64_t v11 = v6;
  id v7 = v3;
  dispatch_async(v4, block);
}

void sub_100122D88(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = +[IDSFoundationLog KeyTransparency];
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Failed to force sync KVS.", buf, 2u);
    }

    id v5 = *(void **)(a1 + 40);
    uint64_t v6 = [*(id *)(a1 + 48) _clientErrorWithCode:-5000 debugDescription:@"Failed to sync KVS." underlyingError:*(void *)(a1 + 32)];
    [v5 failWithError:v6];
  }
  else
  {
    if (v4)
    {
      *(_WORD *)id v8 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Successfully force synced KVS.", v8, 2u);
    }

    id v7 = *(void **)(a1 + 40);
    uint64_t v6 = +[NSNull null];
    [v7 fulfillWithValue:v6];
  }
}

double sub_100123044(void *a1, uint64_t a2, double a3)
{
  BOOL v4 = [a1 objectForKey:a2];
  if (v4)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      [v4 doubleValue];
      a3 = v5;
    }
  }

  return a3;
}

id sub_1001230B0(void *a1, id a2)
{
  id v3 = objc_msgSend(a1, "objectForKey:");
  if (v3)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      a2 = [v3 BOOLValue];
    }
  }

  return a2;
}

void sub_100123110(id a1)
{
  if (!qword_100A4A6E8)
  {
    unint64_t v1 = (void **)IMWeakLinkSymbol();
    if (v1) {
      uint64_t v2 = *v1;
    }
    else {
      uint64_t v2 = 0;
    }
    objc_storeStrong((id *)&qword_100A4A6E8, v2);
  }
}

void sub_100123174(id a1)
{
  qword_100A4A6F8 = IMWeakLinkClass();
}

void sub_1001231A4(id a1)
{
  qword_100A4A708 = IMWeakLinkClass();
}

void sub_1001231D4(id a1)
{
  qword_100A4A718 = IMWeakLinkClass();
}

void sub_100123204(id a1)
{
  qword_100A4A728 = IMWeakLinkClass();
}

void sub_100123234(id a1)
{
  qword_100A4A738 = IMWeakLinkClass();
}

void sub_100123264(id a1)
{
  qword_100A4A748 = IMWeakLinkClass();
}

void sub_100123294(id a1)
{
  qword_100A4A758 = IMWeakLinkClass();
}

void sub_1001232C4(id a1)
{
  qword_100A4A768 = IMWeakLinkClass();
}

void sub_1001232F4(id a1)
{
  qword_100A4A778 = IMWeakLinkClass();
}

void sub_100123324(id a1)
{
  qword_100A4A788 = IMWeakLinkClass();
}

void sub_100123364(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 0x16u);
}

void sub_10012338C(uint64_t a1@<X8>)
{
  *(void *)(v1 - 8) = a1;
}

void sub_100123CB8(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog delivery_oversized];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = 136315651;
    double v5 = "IDSIMLFanoutFactoryComponent.m";
    __int16 v6 = 1024;
    int v7 = 85;
    __int16 v8 = 2113;
    uint64_t v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%s:%d %{private}@", (uint8_t *)&v4, 0x1Cu);
  }
}

void sub_100124418(id a1)
{
  qword_100A4A7A0 = objc_alloc_init(IDSDaemon);

  _objc_release_x1();
}

id sub_1001254CC(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  id v2 = [*(id *)(a1 + 40) intValue];

  return _[v1 _pidSuspended:v2];
}

void sub_100125508(uint64_t a1)
{
  [*(id *)(a1 + 32) _cleanupIncomingFilesDirectories];
  [*(id *)(a1 + 32) _resetPreferences];
  uint64_t v3 = [*(id *)(a1 + 32) uTunDeliveryController];
  [v3 setDelegate:*(void *)(a1 + 32)];

  int v4 = [*(id *)(a1 + 32) rapportDeliveryController];
  [v4 setDelegate:*(void *)(a1 + 32)];

  id v5 = [*(id *)(a1 + 32) registrationController];
  id v6 = [*(id *)(a1 + 32) registrationPushManager];
  id v7 = [*(id *)(a1 + 32) centralRegListener];
  __int16 v8 = [*(id *)(a1 + 32) accountController];
  [v8 loadStoredAccounts];

  uint64_t v9 = [IDSDSignInResponder alloc];
  id v10 = [*(id *)(*(void *)(a1 + 32) + 520) userStore];
  uint64_t v11 = [(IDSDSignInResponder *)v9 initWithUserStore:v10];
  uint64_t v12 = *(void *)(a1 + 32);
  id v13 = *(void **)(v12 + 416);
  *(void *)(v12 + 416) = v11;

  id v14 = [*(id *)(a1 + 32) deviceHeartbeatCenter];
  [v14 setup];

  id v15 = [*(id *)(a1 + 32) pairingManager];
  [v15 addDelegate:*(void *)(a1 + 32)];

  id v16 = [*(id *)(a1 + 32) encryptionController];
  id v17 = [*(id *)(a1 + 32) sessionController];
  id v18 = +[IDSQuickRelayAllocator sharedInstance];
  id v19 = [*(id *)(a1 + 32) currentDevice];
  id v20 = +[IDSClientChannelManager sharedInstance];
  id v21 = +[IDSLocalMultiplexer sharedInstance];
  id v22 = +[IDSGroupAgent sharedInstance];
  uint64_t v23 = +[IDSDuetInterface sharedInstance];
  [v23 setDelegate:*(void *)(a1 + 32)];

  [*(id *)(a1 + 32) _registerForCheckpointAndVacuumDB];
  char v24 = +[IDSAWDLogging sharedInstance];
  long long v25 = [v24 AWDServerConnection];
  v64[0] = _NSConcreteStackBlock;
  v64[1] = 3221225472;
  v64[2] = sub_100125DB4;
  v64[3] = &unk_100983148;
  id v26 = v24;
  id v65 = v26;
  [v25 registerQueriableMetric:2555929 callback:v64];

  [*(id *)(a1 + 32) registerForRegistrationAccountStatusMetric];
  [*(id *)(a1 + 32) registerForRegistrationEventTrackCleanup];
  [*(id *)(a1 + 32) registerForSenderKeyCleanup];
  [*(id *)(a1 + 32) registerForQueryDBCleanup];
  [*(id *)(a1 + 32) _registerForDailyMetricReporting];
  long long v27 = [*(id *)(a1 + 32) idStatusQueryController];
  v63[0] = _NSConcreteStackBlock;
  v63[1] = 3221225472;
  v63[2] = sub_100125DBC;
  v63[3] = &unk_100983170;
  v63[4] = *(void *)(a1 + 32);
  [v27 addCompletionBlock:v63 forUniqueIdentifier:@"IDSDaemon"];

  long long v28 = +[IDSPeerIDManager sharedInstance];
  v62[0] = _NSConcreteStackBlock;
  v62[1] = 3221225472;
  v62[2] = sub_100126004;
  v62[3] = &unk_100983198;
  v62[4] = *(void *)(a1 + 32);
  [v28 addClientDataUpdateBlock:v62 forToken:@"idsdaemon-peeridmanager-clientdatablock"];

  if ((_os_feature_enabled_impl() & 1) == 0)
  {
    uint64_t v29 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEBUG, "Opening up the grant MIG port", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    uint64_t v30 = [*(id *)(a1 + 32) daemonMIGInterface];
    [v30 setDelegate:*(void *)(a1 + 32)];
    [v30 acceptIncomingGrantRequests];
    if (IMGetDomainBoolForKeyWithDefaultValue()) {
      [v30 launchSim2HostServer];
    }
    id v31 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEBUG, "Opening up the NSXPC Interface", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    id v32 = [*(id *)(a1 + 32) daemonXPCInterface];
    uint64_t v33 = [*(id *)(a1 + 32) daemonMIGQueryInterface];
    [v33 setDelegate:*(void *)(a1 + 32)];
    [v33 acceptIncomingGrantRequests];
    __int16 v34 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEBUG, "Now accepting query grants, setup complete", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
  }
  uint64_t v35 = +[IMUserDefaults sharedDefaults];
  unsigned int v36 = [v35 clearStateOnLaunch];

  if (v36)
  {
    long long v37 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "Found default to clear IDS state on launch", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    [*(id *)(a1 + 32) _clearIDSState];
  }
  id v38 = [*(id *)(a1 + 32) messageStoreMigrator];
  [*(id *)(a1 + 32) _processStoredMessagesIncludingClassD:1];
  long long v39 = [*(id *)(a1 + 32) serverStorageStateMachine];
  [v39 reissuePersistedRequests];

  [*(id *)(a1 + 32) _startPushHandlingLocked];
  long long v40 = [*(id *)(a1 + 32) pushHandlerForAPSDelegatePort];
  [v40 setShouldWaitToSetTopics:0];

  [*(id *)(a1 + 32) _registerForNetworkAvailableNotification];
  id v41 = [*(id *)(a1 + 32) activityStateMonitor];
  [v41 setup];

  im_dispatch_after_primary_queue();
  id v42 = [*(id *)(a1 + 32) familyManager];
  id v43 = objc_alloc_init(IDSInvitationStore);
  uint64_t v44 = *(void *)(a1 + 32);
  id v45 = *(void **)(v44 + 448);
  *(void *)(v44 + 448) = v43;

  id v46 = [IDSPersistentMap alloc];
  uint64_t v47 = objc_opt_class();
  id v48 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", v47, objc_opt_class(), 0);
  id v49 = [(IDSPersistentMap *)v46 initWithIdentifier:@"com.apple.identityservicesd.waking-push-priority" versionNumber:1 decodableClasses:v48 migrationBlock:0];
  uint64_t v50 = *(void *)(a1 + 32);
  long long v51 = *(void **)(v50 + 456);
  *(void *)(v50 + 456) = v49;

  long long v52 = objc_alloc_init(IDSFirewallNotificationCenter);
  uint64_t v53 = *(void *)(a1 + 32);
  id v54 = *(void **)(v53 + 464);
  *(void *)(v53 + 464) = v52;

  id v55 = objc_alloc_init((Class)IDSBlastDoorConnectionHelper);
  uint64_t v56 = *(void *)(a1 + 32);
  uint64_t v57 = *(void **)(v56 + 472);
  *(void *)(v56 + 472) = v55;

  id v58 = objc_alloc_init((Class)NSMutableDictionary);
  uint64_t v59 = *(void *)(a1 + 32);
  __int16 v60 = *(void **)(v59 + 480);
  *(void *)(v59 + 480) = v58;

  [*(id *)(a1 + 32) _setupRestrictedMessageCleanupTimer];
  [*(id *)(a1 + 32) _registerSysdiagnoseBlock];
  +[IDSTemporaryPhoneAlertManager clearFollowups];
}

id sub_100125DB4(uint64_t a1)
{
  return _[*(id *)(a1 + 32) queryAndSubmitStatusForAccounts];
}

void sub_100125DBC(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5, void *a6)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a4;
  id v14 = a6;
  id v28 = 0;
  id v15 = +[NSKeyedArchiver archivedDataWithRootObject:v11 requiringSecureCoding:1 error:&v28];
  id v16 = v28;
  id v17 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
  {
    CFStringRef v18 = @"NO";
    *(_DWORD *)buf = 138413570;
    id v30 = v11;
    if (a5) {
      CFStringRef v18 = @"YES";
    }
    __int16 v31 = 2112;
    id v32 = v12;
    __int16 v33 = 2112;
    id v34 = v13;
    __int16 v35 = 2112;
    CFStringRef v36 = v18;
    __int16 v37 = 2112;
    id v38 = v14;
    __int16 v39 = 2112;
    id v40 = v16;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "Got id query completed with updates %@ fromURI %@ service %@ success %@ error %@ encodeError %@", buf, 0x3Eu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    CFStringRef v19 = @"NO";
    if (a5) {
      CFStringRef v19 = @"YES";
    }
    id v26 = v14;
    id v27 = v16;
    id v24 = v13;
    CFStringRef v25 = v19;
    id v22 = v11;
    id v23 = v12;
    _IDSLogV();
  }
  id v20 = objc_msgSend(*(id *)(a1 + 32), "broadcasterWithMessageContext:", 0, v22, v23, v24, v25, v26, v27);
  id v21 = [v12 prefixedURI];
  [v20 IDQueryCompletedWithFromURI:v21 idStatusUpdates:v15 service:v13 success:a5 error:v14];
}

void sub_100126004(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id v13 = [*(id *)(a1 + 32) serviceController];
  id v14 = [v13 serviceWithIdentifier:v9];
  unsigned int v15 = [v14 shouldHaveRestrictedStorage];

  if (!v15)
  {
    CFStringRef v19 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      id v20 = [v12 pushToken];
      *(_DWORD *)buf = 138412290;
      __int16 v31 = v20;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Adding identity to last resort cache for token %@", buf, 0xCu);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      id v27 = [v12 pushToken];
      _IDSLogV();
    }
    id v21 = +[IDSPublicIdentityCache sharedInstance];
    id v22 = [v12 publicDeviceIdentityContainer];
    id v23 = [v12 pushToken];
    id v24 = [v12 URI];
    id v29 = 0;
    [v21 addIdentity:v22 forToken:v23 uri:v24 service:v9 error:&v29];
    id v18 = v29;

    if (v18)
    {
      CFStringRef v25 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        id v26 = [v12 pushToken];
        *(_DWORD *)buf = 138412546;
        __int16 v31 = v26;
        __int16 v32 = 2112;
        id v33 = v18;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Error adding identity to last resort cache { token: %@, error: %@ }", buf, 0x16u);
      }
      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        id v28 = [v12 pushToken];
        _IDSLogV();
      }
    }
    goto LABEL_18;
  }
  id v16 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    id v17 = [v12 pushTokenObject];
    *(_DWORD *)buf = 138412546;
    __int16 v31 = v17;
    __int16 v32 = 2112;
    id v33 = v9;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Not adding identity to last resort cache for token %@ service: %@", buf, 0x16u);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    id v18 = [v12 pushTokenObject];
    _IDSLogV();
LABEL_18:
  }
}

void sub_1001263C8(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x100126324);
  }
  _Unwind_Resume(a1);
}

id sub_100126414(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _postAliveNotification];
}

void sub_10012641C(uint64_t a1)
{
  [*(id *)(a1 + 32) _cleanUpOutgoingMessageDatabaseAndClearStatementCache];
  [*(id *)(a1 + 32) _cleanupIncomingMessageDatabase];
  id v2 = [*(id *)(*(void *)(a1 + 32) + 424) negativeRegistrationUpdateCache];
  [v2 cleanupExpiredItems];

  uint64_t v3 = +[IDSPublicIdentityCache sharedInstance];
  id v6 = 0;
  [v3 cleanupWithError:&v6];
  id v4 = v6;

  if (v4)
  {
    id v5 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      id v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Error cleaning last resort cache { error: %@ }", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
  }
}

NSString *__cdecl sub_100126584(id a1)
{
  uint64_t v1 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    id v2 = +[IMUserDefaults sharedDefaults];
    id v3 = [v2 copyMultipleForCurrentKeys:0 appID:@"com.apple.conference"];
    *(_DWORD *)buf = 138412290;
    id v18 = v3;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Conference Prefs %@", buf, 0xCu);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    id v4 = +[IMUserDefaults sharedDefaults];
    id v14 = [v4 copyMultipleForCurrentKeys:0 appID:@"com.apple.conference"];
    _IDSLogV();
  }
  id v5 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = +[IMUserDefaults sharedDefaults];
    id v7 = [v6 copyMultipleForCurrentKeys:0 appID:@"com.apple.ids"];
    *(_DWORD *)buf = 138412290;
    id v18 = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "IDS Prefs %@", buf, 0xCu);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    id v8 = +[IMUserDefaults sharedDefaults];
    id v15 = [v8 copyMultipleForCurrentKeys:0 appID:@"com.apple.ids"];
    _IDSLogV();
  }
  id v9 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    id v10 = +[IMUserDefaults sharedDefaults];
    id v11 = [v10 copyMultipleForCurrentKeys:0 appID:kCFPreferencesCurrentApplication];
    *(_DWORD *)buf = 138412290;
    id v18 = v11;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "IDSD Prefs %@", buf, 0xCu);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    id v12 = +[IMUserDefaults sharedDefaults];
    id v16 = [v12 copyMultipleForCurrentKeys:0 appID:kCFPreferencesCurrentApplication];
    _IDSLogV();
  }
  return 0;
}

void sub_100126A18(id a1)
{
  id v1 = +[IDSUTunDeliveryController sharedInstance];
  [v1 defaultPeerSetLinkPreferences:@"dummyService"];
}

uint64_t sub_100127228(uint64_t a1)
{
  ids_monotonic_time();
  double v3 = v2;
  id v4 = +[NSFileManager defaultManager];
  [v4 removeItemAtPath:*(void *)(a1 + 32) error:0];

  ids_monotonic_time();
  double v6 = v5;
  id v7 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    double v10 = v6 - v3;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Delayed background file removal took %0.6lf seconds", buf, 0xCu);
  }

  uint64_t result = os_log_shim_legacy_logging_enabled();
  if (result)
  {
    uint64_t result = _IDSShouldLogTransport();
    if (result)
    {
      _IDSLogTransport();
      uint64_t result = _IDSShouldLog();
      if (result) {
        return _IDSLogV();
      }
    }
  }
  return result;
}

id sub_100127CC0(uint64_t a1)
{
  return [*(id *)(a1 + 32) _processQueuedBroadcastsForServices:*(void *)(a1 + 40) priority:300 forceRetry:1];
}

id sub_100127CD4(uint64_t a1)
{
  return [*(id *)(a1 + 32) _processQueuedBroadcastsForServices:*(void *)(a1 + 40) priority:200 forceRetry:1];
}

id sub_100127CE8(uint64_t a1)
{
  return [*(id *)(a1 + 32) _processQueuedBroadcastsForServices:*(void *)(a1 + 40) priority:100 forceRetry:1];
}

id sub_100127EAC(uint64_t a1)
{
  return [*(id *)(a1 + 32) _dropQueuedBroadcastsForServices:*(void *)(a1 + 40) priority:300];
}

id sub_100127EBC(uint64_t a1)
{
  return [*(id *)(a1 + 32) _dropQueuedBroadcastsForServices:*(void *)(a1 + 40) priority:200];
}

id sub_100127ECC(uint64_t a1)
{
  return [*(id *)(a1 + 32) _dropQueuedBroadcastsForServices:*(void *)(a1 + 40) priority:100];
}

void sub_100127F98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100127FB0(uint64_t result)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  return result;
}

void sub_1001280D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_1001280F0(uint64_t a1, uint64_t a2)
{
  id result = [*(id *)(a1 + 32) client:a2 isEntitledToAccessService:*(void *)(a1 + 40) forEntitlement:*(void *)(a1 + 48) shouldWarn:1];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = (_BYTE)result;
  return result;
}

void sub_1001281E8(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = a2;
  id v10 = [v3 remoteObject];
  id v4 = [v3 services];
  double v5 = [v3 notificationServices];
  double v6 = [v3 entitlements];
  id v7 = [v3 commands];
  id v8 = [v3 capabilities];
  id v9 = [v3 bundleID];

  (*(void (**)(uint64_t, id, void *, void *, void *, void *, id, void *))(v2 + 16))(v2, v10, v4, v5, v6, v7, v8, v9);
}

void sub_100128C64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint8_t buf)
{
  if (a2 == 1)
  {
    objc_begin_catch(exception_object);
    objc_end_catch();
    JUMPOUT(0x100128AE8);
  }
  _Unwind_Resume(exception_object);
}

id sub_100128E38(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      id v9 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        id v13 = v4;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "_IDSSessionClientID unknown class type for %@", buf, 0xCu);
      }

      if (!os_log_shim_legacy_logging_enabled() || (_IDSShouldLog() & 1) == 0) {
        goto LABEL_18;
      }
      goto LABEL_17;
    }
  }
  double v5 = [v4 connection];
  double v6 = v5;
  if (v5)
  {
    id pid = (id)xpc_connection_get_pid(v5);
LABEL_7:
    id v8 = +[NSString stringWithFormat:@"%@.[%d]", v3, pid];

    goto LABEL_19;
  }
  if (objc_opt_respondsToSelector())
  {
    id pid = [v4 pid];
    goto LABEL_7;
  }
  id v10 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    id v13 = v4;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "_IDSSessionClientID failed to get pid from %@", buf, 0xCu);
  }

  if os_log_shim_legacy_logging_enabled() && (_IDSShouldLog()) {
LABEL_17:
  }
    _IDSLogV();
LABEL_18:
  id v8 = v3;
LABEL_19:

  return v8;
}

id sub_1001290AC(uint64_t a1)
{
  return [*(id *)(a1 + 32) updateTopics];
}

id sub_1001290B4(uint64_t a1)
{
  return [*(id *)(a1 + 32) _updatePushCommandsLocked];
}

void sub_100129218(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, long long buf)
{
  if (a2 == 1)
  {
    id v19 = objc_begin_catch(a1);
    id v20 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v19;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Exception removing listener object: %@", (uint8_t *)&buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      _IDSLogTransport();
    }
    IMLogBacktrace();
    IMLogSimulateCrashForException();

    objc_end_catch();
    JUMPOUT(0x1001291D8);
  }
  _Unwind_Resume(a1);
}

void sub_1001294B8(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, long long buf)
{
  if (a2 == 1)
  {
    id v19 = objc_begin_catch(a1);
    id v20 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v19;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Exception removing local listener object: %@", (uint8_t *)&buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      _IDSLogTransport();
    }
    IMLogBacktrace();
    IMLogSimulateCrashForException();

    objc_end_catch();
    JUMPOUT(0x100129454);
  }
  _Unwind_Resume(a1);
}

void sub_1001297A0(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, long long buf)
{
  if (a2 == 1)
  {
    id v19 = objc_begin_catch(a1);
    id v20 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v19;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Exception removing local listener object: %@", (uint8_t *)&buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      _IDSLogTransport();
    }
    IMLogBacktrace();
    IMLogSimulateCrashForException();

    objc_end_catch();
    JUMPOUT(0x100129760);
  }
  _Unwind_Resume(a1);
}

void sub_100129E20(uint64_t a1)
{
  id v2 = +[IDSUTunDeliveryController sharedInstance];
  [v2 defaultPeerSetLinkPreferences:*(void *)(a1 + 32)];
}

void sub_10012BB48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10012BB60(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10012BB70(uint64_t a1)
{
}

void sub_10012BB78(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 entitlements];
  if (*(void *)(a1 + 32))
  {
    double v5 = [v3 commands];
    if ([*(id *)(a1 + 32) integerValue] == (id)227
      || [*(id *)(a1 + 32) integerValue] == (id)243
      || [*(id *)(a1 + 32) integerValue] == (id)242
      || [*(id *)(a1 + 32) integerValue] == (id)245
      || [*(id *)(a1 + 32) integerValue] == (id)250
      || [*(id *)(a1 + 32) integerValue] == (id)251
      || [*(id *)(a1 + 32) integerValue] == (id)244
      || [*(id *)(a1 + 32) integerValue] == (id)153
      || [*(id *)(a1 + 32) integerValue] == (id)315
      || [*(id *)(a1 + 32) integerValue] == (id)121
      || [*(id *)(a1 + 32) integerValue] == (id)246
      || [*(id *)(a1 + 32) integerValue] == (id)248
      || [*(id *)(a1 + 32) integerValue] == (id)247
      || [*(id *)(a1 + 32) integerValue] == (id)249)
    {
      unsigned int v6 = 1;
    }
    else
    {
      unsigned int v6 = [v5 containsObject:*(void *)(a1 + 32)];
    }
  }
  else
  {
    unsigned int v6 = 1;
  }
  if (*(_DWORD *)(a1 + 72)) {
    BOOL v7 = (*(_DWORD *)(a1 + 72) & ~[v3 capabilities]) != 0;
  }
  else {
    BOOL v7 = 0;
  }
  if (*(unsigned char *)(a1 + 76))
  {
    if ((v6 ^ 1 | v7)) {
      goto LABEL_45;
    }
  }
  else
  {
    if (*(unsigned char *)(a1 + 77)) {
      [v3 notificationServices];
    }
    else {
    id v8 = [v3 services];
    }
    id v9 = v8;
    if (*(void *)(a1 + 40) && ([v8 containsObject:*(void *)(a1 + 48)] & 1) == 0) {
      unsigned int v10 = [v9 containsObject:IDSWildCardTopic] ^ 1;
    }
    else {
      unsigned int v10 = 0;
    }

    if ((v10 | v7 | v6 ^ 1)) {
      goto LABEL_45;
    }
  }
  if ([v4 hasAnyEntitlements])
  {
    long long v18 = 0u;
    long long v19 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    id v11 = *(id *)(a1 + 56);
    id v12 = [v11 countByEnumeratingWithState:&v16 objects:v20 count:16];
    if (v12)
    {
      id v13 = v12;
      uint64_t v14 = *(void *)v17;
      while (2)
      {
        for (uint64_t i = 0; i != v13; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v17 != v14) {
            objc_enumerationMutation(v11);
          }
          if (objc_msgSend(v4, "hasService:forEntitlement:", *(void *)(a1 + 48), *(void *)(*((void *)&v16 + 1) + 8 * i), (void)v16))
          {
            [*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) addObject:v3];
            goto LABEL_44;
          }
        }
        id v13 = [v11 countByEnumeratingWithState:&v16 objects:v20 count:16];
        if (v13) {
          continue;
        }
        break;
      }
    }
LABEL_44:
  }
LABEL_45:
}

void sub_10012C73C(id a1, IDSIncomingMessageBroadcast *a2, unint64_t a3, BOOL *a4)
{
  id v4 = a2;
  double v5 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    int v6 = 134217984;
    int64_t v7 = [(IDSIncomingMessageBroadcast *)v4 broadcastID];
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "\t\tBroadcast ID: %lld\n", (uint8_t *)&v6, 0xCu);
  }
}

void sub_10012D4C4(_Unwind_Exception *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a2 == 1)
  {
    objc_begin_catch(exc_buf);
    objc_end_catch();
    JUMPOUT(0x10012D084);
  }
  os_activity_scope_leave((os_activity_scope_state_t)(v16 - 200));
  cut_arc_os_release();
  _Unwind_Resume(exc_buf);
}

uint64_t sub_10012D970(uint64_t a1, uint64_t a2)
{
  if (a2 != 1)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 96));
    pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 32) + 8));
    double v5 = [*(id *)(a1 + 32) _lockedRemoteObjectsWithNotificationService:*(void *)(a1 + 40) entitlement:*(void *)(a1 + 48) command:*(void *)(a1 + 56) capabilities:*(unsigned int *)(a1 + 112)];
    pthread_mutex_unlock((pthread_mutex_t *)(*(void *)(a1 + 32) + 8));
    if ([v5 count])
    {
      int v6 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
      {
        int64_t v7 = *(void **)(a1 + 104);
        uint64_t v8 = *(void *)(a1 + 64);
        *(_DWORD *)buf = 134218242;
        id v28 = v7;
        __int16 v29 = 2112;
        uint64_t v30 = v8;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "Broadcast: Performing enqueued broadcast %lld for topic %@\n", buf, 0x16u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
      {
        uint64_t v25 = *(void *)(a1 + 104);
        uint64_t v26 = *(void *)(a1 + 64);
        _IDSLogTransport();
      }
      id v9 = objc_msgSend(*(id *)(*(void *)(a1 + 32) + 128), "broadcastProxyForTargets:messageContext:protocol:", v5, *(void *)(a1 + 72), &OBJC_PROTOCOL___IDSDaemonListenerProtocol, v25, v26);
      (*(void (**)(void))(*(void *)(a1 + 88) + 16))();
    }
    else
    {
      unsigned int v10 = *(void **)(a1 + 80);
      if (!v10 || ([v10 timeIntervalSinceNow], fabs(v11) <= 300.0))
      {
        long long v17 = OSLogHandleForTransportCategory();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          id v18 = [WeakRetained broadcastID];
          uint64_t v19 = *(void *)(a1 + 40);
          uint64_t v20 = *(void *)(a1 + 48);
          uint64_t v22 = *(void *)(a1 + 56);
          uint64_t v21 = *(void *)(a1 + 64);
          int v23 = *(_DWORD *)(a1 + 112);
          *(_DWORD *)buf = 134219266;
          id v28 = v18;
          __int16 v29 = 2112;
          uint64_t v30 = v21;
          __int16 v31 = 2112;
          uint64_t v32 = v19;
          __int16 v33 = 2112;
          uint64_t v34 = v20;
          __int16 v35 = 2112;
          uint64_t v36 = v22;
          __int16 v37 = 1024;
          int v38 = v23;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Broadcast: enqueued broadcast %lld of topic %@ doesn't find target with service %@ entitlement %@ command %@ capabilities %u", buf, 0x3Au);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
        {
          [WeakRetained broadcastID];
          _IDSLogTransport();
        }
        uint64_t v3 = 0;
        goto LABEL_25;
      }
      id v12 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        id v13 = *(void **)(a1 + 104);
        uint64_t v14 = *(void *)(a1 + 80);
        uint64_t v15 = *(void *)(a1 + 64);
        *(_DWORD *)buf = 134218498;
        id v28 = v13;
        __int16 v29 = 2112;
        uint64_t v30 = v14;
        __int16 v31 = 2112;
        uint64_t v32 = v15;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Broadcast: Broadcast %lld enqueued at %@ has timed out - Calling timed out broadcast block for topic %@ with nil broadcaster to allow cleanup\n", buf, 0x20u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport()) {
        _IDSLogTransport();
      }
      (*(void (**)(void, void, uint64_t))(*(void *)(a1 + 88) + 16))(*(void *)(a1 + 88), 0, v16);
    }
    uint64_t v3 = 1;
LABEL_25:

    return v3;
  }
  (*(void (**)(void))(*(void *)(a1 + 88) + 16))();
  return 1;
}

void sub_10012E3A0(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x10012E300);
  }
  _Unwind_Resume(a1);
}

void sub_10012EC28(_Unwind_Exception *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  if (a2 == 1)
  {
    objc_begin_catch(exc_buf);
    objc_end_catch();
    JUMPOUT(0x10012EB00);
  }
  _Block_object_dispose(&a19, 8);
  _Unwind_Resume(exc_buf);
}

void sub_10012EC88(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  id v9 = a2;
  if ([v9 broadcastID] == *(id *)(a1 + 48))
  {
    int64_t v7 = [v9 messageUUID];
    unsigned int v8 = [v7 isEqualToIgnoringCase:*(void *)(a1 + 32)];

    if (v8)
    {
      objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
      *a4 = 1;
    }
  }
}

void sub_10012ED34(id a1, IDSIncomingMessageBroadcast *a2, unint64_t a3, BOOL *a4)
{
}

void sub_10012F1F8(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  id v7 = a2;
  if (([v7 broadcastPerformed] & 1) == 0)
  {
    unsigned int v8 = [v7 broadcastBlock];
    int v9 = v8[2](v8, 0);

    unsigned int v10 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      id v11 = [v7 broadcastID];
      uint64_t v12 = *(void *)(a1 + 32);
      unsigned int v13 = [v7 broadcastNeedsClientAck];
      int v14 = *(unsigned __int8 *)(a1 + 56);
      *(_DWORD *)buf = 134219010;
      id v16 = v11;
      __int16 v17 = 2112;
      uint64_t v18 = v12;
      __int16 v19 = 1024;
      int v20 = v9;
      __int16 v21 = 1024;
      unsigned int v22 = v13;
      __int16 v23 = 1024;
      int v24 = v14;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "Broadcast: previously enqueued broadcast %lld for service %@ succeeded %d needsClientAck %d forceRetry %d \n", buf, 0x28u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
    {
      [v7 broadcastID];
      [v7 broadcastNeedsClientAck];
      _IDSLogTransport();
    }
    if (v9)
    {
      [v7 setBroadcastPerformed:1];
      if (([v7 broadcastNeedsClientAck] & 1) == 0) {
        [*(id *)(a1 + 40) addIndex:a3];
      }
    }
    else
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
      *a4 = 1;
    }
  }
}

void sub_10012F7F0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = [v3 messageUUID];
    int v6 = [*(id *)(a1 + 32) identifier];
    *(_DWORD *)buf = 138412546;
    id v13 = v5;
    __int16 v14 = 2112;
    uint64_t v15 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Dropping %@ for %@", buf, 0x16u);
  }
  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      id v7 = [v3 messageUUID];
      [*(id *)(a1 + 32) identifier];
      v11 = unsigned int v10 = v7;
      _IDSLogTransport();

      if (_IDSShouldLog())
      {
        unsigned int v8 = objc_msgSend(v3, "messageUUID", v7, v11);
        [*(id *)(a1 + 32) identifier];
        v11 = unsigned int v10 = v8;
        _IDSLogV();
      }
    }
  }
  if ((objc_msgSend(v3, "broadcastPerformed", v10, v11) & 1) == 0)
  {
    int v9 = [v3 broadcastBlock];
    v9[2](v9, 1);
  }
}

id sub_100130340(uint64_t a1)
{
  return [*(id *)(a1 + 32) updateTopics];
}

id sub_100130348(uint64_t a1)
{
  return [*(id *)(a1 + 32) _updatePushCommandsLocked];
}

void sub_100130534(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_10013056C(void *a1, void *a2)
{
  id v3 = a2;
  *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = 1;
  uint64_t v4 = [v3 notificationServices];
  uint64_t v5 = *(void *)(a1[6] + 8);
  int v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;

  id v7 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(*(void *)(a1[6] + 8) + 40);
    uint64_t v9 = *(void *)(*(void *)(a1[7] + 8) + 40);
    *(_DWORD *)buf = 136315650;
    __int16 v17 = "-[IDSDaemon registerForNotificationsOnServices:messageContext:]_block_invoke";
    __int16 v18 = 2112;
    uint64_t v19 = v8;
    __int16 v20 = 2112;
    uint64_t v21 = v9;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%s: received client request to change notification services from %@ to %@ \n", buf, 0x20u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
  {
    uint64_t v14 = *(void *)(*(void *)(a1[6] + 8) + 40);
    uint64_t v15 = *(void *)(*(void *)(a1[7] + 8) + 40);
    id v13 = "-[IDSDaemon registerForNotificationsOnServices:messageContext:]_block_invoke";
    _IDSLogTransport();
  }
  objc_msgSend(*(id *)(*(void *)(a1[7] + 8) + 40), "minusSet:", *(void *)(*(void *)(a1[6] + 8) + 40), v13, v14, v15);
  [*(id *)(*(void *)(a1[6] + 8) + 40) unionSet:a1[4]];
  id v10 = [*(id *)(*(void *)(a1[6] + 8) + 40) copy];
  uint64_t v11 = *(void *)(a1[6] + 8);
  uint64_t v12 = *(void **)(v11 + 40);
  *(void *)(v11 + 40) = v10;
}

void sub_1001317EC(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8, void *a9)
{
  id v41 = a2;
  id v12 = a8;
  id v13 = a9;
  kdebug_trace();
  uint64_t v14 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109378;
    *(_DWORD *)id v43 = a6;
    *(_WORD *)&void v43[4] = 2112;
    *(void *)&v43[6] = v13;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "client's openSocketWithOptions call returned socket %d, error %@", buf, 0x12u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      uint64_t v33 = a6;
      id v36 = v13;
      _IDSLogTransport();
      if (_IDSShouldLog())
      {
        uint64_t v33 = a6;
        id v36 = v13;
        _IDSLogV();
      }
    }
  }
  if ((int)a6 <= 0) {
    uint64_t v15 = 201;
  }
  else {
    uint64_t v15 = 0;
  }
  id v16 = objc_msgSend(objc_alloc((Class)IDSLocalDeliverySocketOpenedMetric), "initWithService:isToDefaultPairedDevice:openError:socketError:", *(void *)(a1 + 32), *(unsigned char *)(a1 + 80) != 0, v15, objc_msgSend(v13, "code", v33, v36));
  __int16 v17 = +[IDSCoreAnalyticsLogger defaultLogger];
  [v17 logMetric:v16];

  __int16 v18 = +[IDSAWDLogging sharedInstance];
  objc_msgSend(v18, "socketOpenedForService:isToDefaultPairedDevice:openError:socketError:", *(void *)(a1 + 32), *(unsigned char *)(a1 + 80) != 0, v15, objc_msgSend(v13, "code"));

  if (v13)
  {
    xpc_object_t v19 = 0;
  }
  else
  {
    xpc_object_t v19 = xpc_fd_create(a6);
    close(a6);
  }
  __int16 v20 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v21 = *(void *)(a1 + 40);
    uint64_t v22 = *(void *)(a1 + 48);
    *(_DWORD *)buf = 138413314;
    *(void *)id v43 = v21;
    *(_WORD *)&v43[8] = 1024;
    *(_DWORD *)&v43[10] = a6;
    __int16 v44 = 2112;
    uint64_t v45 = v22;
    __int16 v46 = 2112;
    id v47 = v13;
    __int16 v48 = 2112;
    xpc_object_t v49 = v19;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "utun finished connection options[%@] socket(%d) handlerID[%@] error[%@] socketObject[%@]\n", buf, 0x30u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    id v39 = v13;
    xpc_object_t v40 = v19;
    uint64_t v37 = a6;
    uint64_t v38 = *(void *)(a1 + 48);
    uint64_t v34 = *(void *)(a1 + 40);
    _IDSLogV();
  }
  __int16 v23 = *(void **)(a1 + 56);
  int v24 = objc_msgSend(*(id *)(a1 + 64), "localObject", v34, v37, v38, v39, v40);
  uint64_t v25 = [v23 broadcasterForLocalObject:v24 messageContext:*(void *)(a1 + 64)];

  xpc_object_t v26 = xpc_dictionary_create(0, 0, 0);
  IMInsertBoolsToXPCDictionary();
  xpc_dictionary_set_value(v26, "object", v19);
  id v27 = objc_alloc_init((Class)NSMutableDictionary);
  objc_msgSend(v27, "setObject:forKey:", @"device-socket", @"object-type", 1, 0);
  [v27 setObject:*(void *)(a1 + 48) forKey:@"completionHandlerID"];
  if (*(void *)(a1 + 72))
  {
    ids_monotonic_time();
    double v29 = v28;
    uint64_t v30 = +[IDSDeviceConnectionAWDMetrics sharedInstance];
    [v30 setDaemonOpenSocketCompletionTime:*(void *)(a1 + 72) forConnectionUUID:v29];

    __int16 v31 = +[IDSDeviceConnectionAWDMetrics sharedInstance];
    uint64_t v32 = [v31 awdMetricsForConnectionUUID:*(void *)(a1 + 72)];
    [v27 setObject:v32 forKey:@"metrics"];
  }
  if (v13) {
    [v27 setObject:v13 forKey:@"error"];
  }
  id v35 = [v27 copy];
  IMInsertKeyedCodableObjectsToXPCDictionary();

  objc_msgSend(v25, "sendXPCObject:", v26, v35, 0);
}

void sub_100132260(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  id v12 = [objc_alloc((Class)IDSLocalDeliverySocketClosedMetric) initWithService:*(void *)(a1 + 32) isToDefaultPairedDevice:*(unsigned __int8 *)(a1 + 40) closeError:0 socketError:0 bytesSent:a3 packetsSent:a2 bytesReceived:a5 packetsReceived:a4];
  id v10 = +[IDSCoreAnalyticsLogger defaultLogger];
  [v10 logMetric:v12];

  uint64_t v11 = +[IDSAWDLogging sharedInstance];
  [v11 socketClosedForService:*(void *)(a1 + 32) isToDefaultPairedDevice:*(unsigned __int8 *)(a1 + 40) closeError:0 socketError:0 bytesSent:a3 packetsSent:a2 bytesReceived:a5 packetsReceived:a4];
}

id sub_10013329C(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  if ([v3 isEqualToIgnoringCase:kIDSServiceDefaultsSentinelSelfAlias])
  {
    uint64_t v5 = [v4 primaryRegistration];
    id v6 = [v5 dsHandle];
  }
  else
  {
    id v6 = v3;
  }

  return v6;
}

id sub_100133334(void *a1, void *a2)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  _DWORD v6[2] = sub_1001333E4;
  v6[3] = &unk_100980858;
  id v7 = a2;
  id v3 = v7;
  id v4 = objc_msgSend(a1, "__imArrayByApplyingBlock:", v6);

  return v4;
}

id sub_1001333E4(uint64_t a1, void *a2)
{
  return sub_10013329C(a2, *(void **)(a1 + 32));
}

BOOL sub_100133838(id a1, IDSServiceProperties *a2)
{
  return [(IDSServiceProperties *)a2 adHocServiceType] == 2;
}

void sub_1001339D0(void *a1, void *a2, void *a3, void *a4, int a5)
{
  id v9 = a3;
  id v10 = a4;
  if (a2)
  {
    id v11 = a2;
    id v12 = (__CFDictionary *)[objc_alloc((Class)NSMutableDictionary) initWithDictionary:a1[4]];
    id v13 = v12;
    if (v9) {
      CFDictionarySetValue(v12, IDSDevicePropertyService, v9);
    }
    if (a5) {
      uint64_t v14 = (void *)a1[5];
    }
    else {
      uint64_t v14 = (void *)a1[6];
    }
    id v15 = [v14 copy];
    if (v15) {
      CFDictionarySetValue(v13, IDSDevicePropertyIdentities, v15);
    }

    id v16 = +[IMRGLog registration];
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = 138412290;
      id v18 = v10;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "broadcasting tinkerDeviceAdded on %@", (uint8_t *)&v17, 0xCu);
    }

    [v11 service:v10 tinkerDeviceAdded:v13];
  }
}

void sub_100133CB8(void *a1, void *a2, void *a3, void *a4, int a5)
{
  id v9 = a3;
  id v10 = a4;
  if (a2)
  {
    id v11 = a2;
    id v12 = (__CFDictionary *)[objc_alloc((Class)NSMutableDictionary) initWithDictionary:a1[4]];
    id v13 = v12;
    if (v9) {
      CFDictionarySetValue(v12, IDSDevicePropertyService, v9);
    }
    if (a5) {
      uint64_t v14 = (void *)a1[5];
    }
    else {
      uint64_t v14 = (void *)a1[6];
    }
    id v15 = [v14 copy];
    if (v15) {
      CFDictionarySetValue(v13, IDSDevicePropertyIdentities, v15);
    }

    id v16 = +[IMRGLog registration];
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = 138412290;
      id v18 = v10;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "broadcasting tinkerDeviceRemoved on %@", (uint8_t *)&v17, 0xCu);
    }

    [v11 service:v10 tinkerDeviceRemoved:v13];
  }
}

void sub_100133FA0(void *a1, void *a2, void *a3, void *a4, int a5)
{
  id v9 = a3;
  id v10 = a4;
  if (a2)
  {
    id v11 = a2;
    id v12 = (__CFDictionary *)[objc_alloc((Class)NSMutableDictionary) initWithDictionary:a1[4]];
    id v13 = v12;
    if (v9) {
      CFDictionarySetValue(v12, IDSDevicePropertyService, v9);
    }
    if (a5) {
      uint64_t v14 = (void *)a1[5];
    }
    else {
      uint64_t v14 = (void *)a1[6];
    }
    id v15 = [v14 copy];
    if (v15) {
      CFDictionarySetValue(v13, IDSDevicePropertyIdentities, v15);
    }

    id v16 = +[IMRGLog registration];
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = 138412290;
      id v18 = v10;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "broadcasting tinkerDeviceUpdated on %@", (uint8_t *)&v17, 0xCu);
    }

    [v11 service:v10 tinkerDeviceUpdated:v13];
  }
}

void sub_100134288(void *a1, void *a2, void *a3, void *a4, int a5)
{
  id v9 = a3;
  id v10 = a4;
  if (a2)
  {
    id v11 = a2;
    id v12 = (__CFDictionary *)[objc_alloc((Class)NSMutableDictionary) initWithDictionary:a1[4]];
    id v13 = v12;
    if (v9) {
      CFDictionarySetValue(v12, IDSDevicePropertyService, v9);
    }
    if (a5) {
      uint64_t v14 = (void *)a1[5];
    }
    else {
      uint64_t v14 = (void *)a1[6];
    }
    id v15 = [v14 copy];
    if (v15) {
      CFDictionarySetValue(v13, IDSDevicePropertyIdentities, v15);
    }

    id v16 = +[IMRGLog registration];
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = 138412290;
      id v18 = v10;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "broadcasting tinkerDeviceUpdated on %@", (uint8_t *)&v17, 0xCu);
    }

    [v11 service:v10 tinkerDeviceUpdated:v13];
  }
}

void sub_100134764(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 0xCu);
}

void sub_100134780(id a1)
{
  qword_100A4A7B8 = objc_alloc_init(IDSDaemonMIGInterface);

  _objc_release_x1();
}

uint64_t sub_100134A58(uint64_t result)
{
  if (!*(unsigned char *)(*(void *)(result + 32) + 40))
  {
    uint64_t v1 = result;
    id v2 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      uint64_t v3 = *(void *)(v1 + 32);
      *(_DWORD *)buf = 138412290;
      uint64_t v5 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "IDSDaemonMIGInterface auth port died: %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      _IDSLogTransport();
    }
    exit(-1);
  }
  return result;
}

id sub_100134C30(uint64_t a1)
{
  return _objc_msgSend(*(id *)(a1 + 32), "__setupServer");
}

void sub_100134D54(uint64_t a1)
{
  id v2 = im_local_object_from_connection();
  if (!v2) {
    goto LABEL_10;
  }
  xpc_dictionary_get_value(*(xpc_object_t *)(a1 + 40), "object");
  id v10 = (id)objc_claimAutoreleasedReturnValue();
  IMGetXPCDictionaryFromDictionary();
  id v9 = (id)objc_claimAutoreleasedReturnValue();
  int v3 = xpc_fd_dup(v10);
  close(v3);
  id v4 = &OBJC_PROTOCOL___IDSDaemonProtocol;
  objc_method_description MethodDescription = protocol_getMethodDescription((Protocol *)v4, "xpcObject:objectContext:", 1, 1);
  types = MethodDescription.types;
  if (!MethodDescription.name)
  {
    types = protocol_getMethodDescription((Protocol *)v4, "xpcObject:objectContext:", 0, 1).types;
    if (types) {
      goto LABEL_4;
    }
LABEL_6:
    id v7 = 0;
    goto LABEL_7;
  }
  if (!MethodDescription.types) {
    goto LABEL_6;
  }
LABEL_4:
  id v7 = +[NSMethodSignature signatureWithObjCTypes:](NSMethodSignature, "signatureWithObjCTypes:", types, v9, v10);
LABEL_7:

  uint64_t v8 = +[NSInvocation invocationWithMethodSignature:v7];
  [v8 retainArguments];
  [v8 setSelector:"xpcObject:objectContext:"];
  [v8 setArgument:&v10 atIndex:2];
  [v8 setArgument:&v9 atIndex:3];
  if (v8) {
    [v2 _enqueueInvocation:v8];
  }
  CFRelease(v2);

LABEL_10:
}

uint64_t sub_100134EC0(uint64_t a1)
{
  uint64_t v4 = IMCreateInvocationFromXPCObjectWithProtocol();
  if (v4) {
    [*(id *)(a1 + 40) _enqueueInvocationWithPriority:v4 priority:*(unsigned int *)(a1 + 56)];
  }
  id v2 = *(const void **)(a1 + 40);
  if (v2) {
    CFRelease(v2);
  }

  return _objc_release_x1();
}

uint64_t sub_100135138(void *a1)
{
  id v1 = a1;
  if (([v1 isEqualToString:@"com.apple.private.alloy.facetime.multi"] & 1) != 0
    || ([v1 isEqualToString:@"com.apple.private.alloy.arcade.fastsync"] & 1) != 0
    || ([v1 isEqualToString:@"com.apple.private.alloy.airdrop.walkaway"] & 1) != 0
    || ([v1 isEqualToString:@"com.apple.private.alloy.carmelsync"] & 1) != 0
    || ([v1 isEqualToString:@"com.apple.private.alloy.notes"] & 1) != 0
    || ([v1 isEqualToString:@"com.apple.private.alloy.dropin.communication"] & 1) != 0
    || ([v1 isEqualToString:@"com.apple.private.alloy.safari.groupactivities"] & 1) != 0
    || ([v1 isEqualToString:@"com.apple.private.alloy.gftaastest.communication"] & 1) != 0
    || ([v1 isEqualToString:@"com.apple.private.alloy.groupRemoteControl.cloud"] & 1) != 0)
  {
    uint64_t v2 = 1;
  }
  else
  {
    uint64_t v2 = (uint64_t)[v1 isEqualToString:@"com.apple.private.alloy.groupRemoteControl.session"];
  }

  return v2;
}

int64_t sub_100136A94(id a1, IDSStewiePhoneNumberInfo *a2, IDSStewiePhoneNumberInfo *a3)
{
  uint64_t v4 = a3;
  uint64_t v5 = [(IDSStewiePhoneNumberInfo *)a2 phoneNumber];
  id v6 = [(IDSStewiePhoneNumberInfo *)v4 phoneNumber];

  id v7 = [v5 compare:v6];
  return (int64_t)v7;
}

BOOL sub_100137E60(uint64_t a1, void *a2)
{
  return [a2 responseCode] != *(id *)(a1 + 32);
}

void sub_1001385F0(id a1)
{
  qword_100A4A7D0 = objc_alloc_init(IDSLinkPreferencesManager);

  _objc_release_x1();
}

void sub_100139300(uint64_t a1)
{
  id v1 = [*(id *)(a1 + 32) copy];
  IDSPowerLogDictionary();
}

uint64_t IDSProtoKeyTransparencyTrustedDeviceReadFrom(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
    return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
  }
  while (2)
  {
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0;
    while (1)
    {
      unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v7 == -1 || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v8 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
      v6 |= (unint64_t)(v8 & 0x7F) << v4;
      if ((v8 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v9 = v5++ >= 9;
      if (v9)
      {
        unint64_t v6 = 0;
        int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }
    *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0;
    }
LABEL_13:
    if (v10 || (v6 & 7) == 4) {
      return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    switch((v6 >> 3))
    {
      case 1u:
        uint64_t v12 = PBReaderReadData();
        uint64_t v13 = 32;
        goto LABEL_26;
      case 2u:
        id v15 = objc_alloc_init(IDSProtoKeyTransparencyTrustedService);
        [(id)a1 addTrustedServices:v15];
        if (PBReaderPlaceMark()
          && (IDSProtoKeyTransparencyTrustedServiceReadFrom((uint64_t)v15, a2) & 1) != 0)
        {
          PBReaderRecallMark();

LABEL_38:
          if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
          }
          continue;
        }

        return 0;
      case 3u:
        uint64_t v12 = PBReaderReadString();
        uint64_t v13 = 16;
        goto LABEL_26;
      case 4u:
        uint64_t v12 = PBReaderReadString();
        uint64_t v13 = 24;
LABEL_26:
        id v16 = *(void **)(a1 + v13);
        *(void *)(a1 + v13) = v12;

        goto LABEL_38;
      case 5u:
        char v17 = 0;
        unsigned int v18 = 0;
        uint64_t v19 = 0;
        *(unsigned char *)(a1 + 48) |= 1u;
        while (2)
        {
          unint64_t v20 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v20 == -1 || v20 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }
          else
          {
            char v21 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v20);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v20 + 1;
            v19 |= (unint64_t)(v21 & 0x7F) << v17;
            if (v21 < 0)
            {
              v17 += 7;
              BOOL v9 = v18++ >= 9;
              if (v9)
              {
                uint64_t v19 = 0;
                goto LABEL_37;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v19 = 0;
        }
LABEL_37:
        *(void *)(a1 + 8) = v19;
        goto LABEL_38;
      default:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_38;
    }
  }
}

uint64_t sub_10013A9F0(uint64_t a1)
{
  return 1;
}

void sub_10013B21C(uint64_t a1, void *a2)
{
  id v3 = a2;
  char v4 = +[IDSFoundationLog IDSFirewall];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    id v13 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Continuing to adding entries to firewall with queryError %@", buf, 0xCu);
  }

  unsigned int v5 = [*(id *)(a1 + 32) _firewallStore];
  unsigned __int8 v6 = [v5 addEntries:*(void *)(a1 + 40) forImpactedServices:*(void *)(*(void *)(a1 + 32) + 24) category:*(unsigned int *)(*(void *)(a1 + 32) + 8) isDonated:1];

  if (v6)
  {
    unint64_t v7 = 0;
  }
  else
  {
    uint64_t v8 = IDSFirewallErrorDomain;
    NSErrorUserInfoKey v10 = NSLocalizedDescriptionKey;
    CFStringRef v11 = @"Failed to add entries to allow list.";
    BOOL v9 = +[NSDictionary dictionaryWithObjects:&v11 forKeys:&v10 count:1];
    unint64_t v7 = +[NSError errorWithDomain:v8 code:4 userInfo:v9];
  }
  [*(id *)(a1 + 32) scheduleProcessStoredRemoteIncomingMessages];
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

void sub_10013B4C8(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog IDSFirewall];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 40);
    int v4 = *(_DWORD *)(*(void *)(a1 + 32) + 8);
    *(_DWORD *)buf = 67109378;
    int v13 = v4;
    __int16 v14 = 2112;
    uint64_t v15 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Update to category %u removeEntries %@", buf, 0x12u);
  }

  unsigned int v5 = [*(id *)(a1 + 32) _firewallStore];
  unsigned __int8 v6 = [v5 removeAllEntries:*(void *)(a1 + 40) forImpactedServices:*(void *)(*(void *)(a1 + 32) + 24) category:*(unsigned int *)(*(void *)(a1 + 32) + 8)];

  if (v6)
  {
    unint64_t v7 = 0;
  }
  else
  {
    uint64_t v8 = IDSFirewallErrorDomain;
    NSErrorUserInfoKey v10 = NSLocalizedDescriptionKey;
    CFStringRef v11 = @"Failed to remove entries from allow list.";
    BOOL v9 = +[NSDictionary dictionaryWithObjects:&v11 forKeys:&v10 count:1];
    unint64_t v7 = +[NSError errorWithDomain:v8 code:4 userInfo:v9];
  }
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

void sub_10013B768(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog IDSFirewall];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 40);
    int v4 = *(_DWORD *)(*(void *)(a1 + 32) + 8);
    *(_DWORD *)buf = 67109378;
    int v13 = v4;
    __int16 v14 = 2112;
    uint64_t v15 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Update to category %u removeDonatedEntries %@", buf, 0x12u);
  }

  unsigned int v5 = [*(id *)(a1 + 32) _firewallStore];
  unsigned __int8 v6 = [v5 removeEntries:*(void *)(a1 + 40) forImpactedServices:*(void *)(*(void *)(a1 + 32) + 24) category:*(unsigned int *)(*(void *)(a1 + 32) + 8) isDonated:1];

  if (v6)
  {
    unint64_t v7 = 0;
  }
  else
  {
    uint64_t v8 = IDSFirewallErrorDomain;
    NSErrorUserInfoKey v10 = NSLocalizedDescriptionKey;
    CFStringRef v11 = @"Failed to remove entries from allow list.";
    BOOL v9 = +[NSDictionary dictionaryWithObjects:&v11 forKeys:&v10 count:1];
    unint64_t v7 = +[NSError errorWithDomain:v8 code:4 userInfo:v9];
  }
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

void sub_10013BBC0(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = +[IDSFoundationLog IDSFirewall];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 40);
    int v6 = *(_DWORD *)(*(void *)(a1 + 32) + 8);
    *(_DWORD *)buf = 67109634;
    int v15 = v6;
    __int16 v16 = 2112;
    id v17 = v3;
    __int16 v18 = 2112;
    uint64_t v19 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Update to category %u queryError %@ addEntries %@", buf, 0x1Cu);
  }

  unint64_t v7 = [*(id *)(a1 + 32) _firewallStore];
  unsigned __int8 v8 = [v7 addEntries:*(void *)(a1 + 40) forImpactedServices:*(void *)(*(void *)(a1 + 32) + 24) category:*(unsigned int *)(*(void *)(a1 + 32) + 8) isDonated:1];

  if (v8)
  {
    [*(id *)(a1 + 32) scheduleProcessStoredRemoteIncomingMessages];
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  else
  {
    uint64_t v9 = IDSFirewallErrorDomain;
    NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
    CFStringRef v13 = @"Failed to add entries to the allow list after successfully removing entries.";
    NSErrorUserInfoKey v10 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
    CFStringRef v11 = +[NSError errorWithDomain:v9 code:4 userInfo:v10];

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
}

id sub_10013C820(uint64_t a1)
{
  return _[*(id *)(a1 + 32) processStoredRemoteIncomingMessagesForCategoryFired];
}

void sub_10013C94C(uint64_t a1)
{
  id v2 = +[IDSDaemon sharedInstance];
  [v2 _processStoredIncomingMessagesForCategory:*(unsigned int *)(*(void *)(a1 + 32) + 8)];
}

void sub_10013D1A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, void *a9)
{
  id v11 = a9;
  NSErrorUserInfoKey v12 = +[IDSFoundationLog IDSFirewall];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v13 = @"NO";
    if (a6) {
      CFStringRef v13 = @"YES";
    }
    *(_DWORD *)buf = 138412546;
    CFStringRef v43 = v13;
    __int16 v44 = 2112;
    id v45 = v11;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Received query result with success {%@} and result {%@}", buf, 0x16u);
  }

  __int16 v14 = +[IDSFoundationLog IDSFirewall];
  BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
  if (a6)
  {
    if (v15)
    {
      CFStringRef v16 = *(const __CFString **)(a1 + 32);
      *(_DWORD *)buf = 138412290;
      CFStringRef v43 = v16;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Populating merge for handles {%@}", buf, 0xCu);
    }

    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    id v17 = *(id *)(a1 + 40);
    id v18 = [v17 countByEnumeratingWithState:&v35 objects:v41 count:16];
    if (v18)
    {
      id v19 = v18;
      uint64_t v20 = *(void *)v36;
      do
      {
        char v21 = 0;
        do
        {
          if (*(void *)v36 != v20) {
            objc_enumerationMutation(v17);
          }
          uint64_t v22 = *(void **)(*((void *)&v35 + 1) + 8 * (void)v21);
          __int16 v23 = objc_msgSend(v22, "mergeID", (void)v35);
          if (v23) {
            goto LABEL_14;
          }
          int v24 = [v22 uri];
          uint64_t v25 = [v11 objectForKey:v24];

          if (v25)
          {
            xpc_object_t v26 = [v22 uri];
            __int16 v23 = [v11 objectForKey:v26];

            id v27 = [v23 firstObject];

            if (v27)
            {
              double v28 = [v23 firstObject];
              double v29 = [v28 senderCorrelationIdentifier];
              [v22 setMergeID:v29];
            }
LABEL_14:
          }
          char v21 = (char *)v21 + 1;
        }
        while (v19 != v21);
        id v30 = [v17 countByEnumeratingWithState:&v35 objects:v41 count:16];
        id v19 = v30;
      }
      while (v30);
    }

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  else
  {
    if (v15)
    {
      CFStringRef v31 = *(const __CFString **)(a1 + 32);
      *(_DWORD *)buf = 138412290;
      CFStringRef v43 = v31;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Failed to query for handles {%@}", buf, 0xCu);
    }

    uint64_t v32 = IDSFirewallErrorDomain;
    NSErrorUserInfoKey v39 = NSLocalizedDescriptionKey;
    CFStringRef v40 = @"Failed to query for merge id due to unsuccessful request";
    uint64_t v33 = +[NSDictionary dictionaryWithObjects:&v40 forKeys:&v39 count:1];
    uint64_t v34 = +[NSError errorWithDomain:v32 code:6 userInfo:v33];

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
}

void sub_10013E4D4(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 state] == (id)1)
  {
    id v24 = [v3 error];

    int v4 = [v24 userInfo];
    id v5 = [v4 mutableCopy];

    if (!v5) {
      id v5 = objc_alloc_init((Class)NSMutableDictionary);
    }
    [v5 setObject:*(void *)(a1 + 32) forKey:@"IDSPipelineParameter"];
    id v6 = objc_alloc((Class)NSError);
    unint64_t v7 = [v24 domain];
    id v8 = objc_msgSend(v6, "initWithDomain:code:userInfo:", v7, objc_msgSend(v24, "code"), v5);

    [*(id *)(a1 + 40) failWithError:v8];
  }
  else
  {
    uint64_t v9 = [v3 value];

    NSErrorUserInfoKey v10 = objc_alloc_init(IDSPeerAggregatableMessage);
    id v11 = [*(id *)(a1 + 48) pushTokenObject];
    [(IDSPeerAggregatableMessage *)v10 setTargetToken:v11];

    NSErrorUserInfoKey v12 = [*(id *)(a1 + 48) sessionToken];
    [(IDSPeerAggregatableMessage *)v10 setTargetSessionToken:v12];

    [(IDSPeerAggregatableMessage *)v10 setTargetPeerID:*(void *)(a1 + 56)];
    CFStringRef v13 = +[NSNumber numberWithBool:*(unsigned __int8 *)(a1 + 72)];
    [(IDSPeerAggregatableMessage *)v10 setWantsDeliveryStatus:v13];

    [(IDSPeerAggregatableMessage *)v10 setWantsCertifiedDelivery:*(unsigned __int8 *)(a1 + 73)];
    __int16 v14 = [*(id *)(a1 + 48) anonymizedSenderID];
    [(IDSPeerAggregatableMessage *)v10 setAnonymizedSenderID:v14];

    BOOL v15 = [*(id *)(a1 + 48) expireDate];
    [(IDSPeerAggregatableMessage *)v10 setExpirationDate:v15];

    [(IDSPeerAggregatableMessage *)v10 setCommand:&off_1009D16E0];
    CFStringRef v16 = [v9 dataLength];
    [(IDSPeerAggregatableMessage *)v10 setDataLength:v16];

    id v17 = [v9 encryptedResult];
    id v18 = [v17 data];
    [(IDSPeerAggregatableMessage *)v10 setEncryptedData:v18];

    id v19 = [v17 payloadMetadata];
    id v20 = [v19 length];

    if (v20)
    {
      char v21 = [v17 payloadMetadata];
      [(IDSPeerAggregatableMessage *)v10 setPayloadMetadata:v21];
    }
    if ([v17 encryptionType] != (id)2)
    {
      [v17 encryptionType];
      uint64_t v22 = IDSEncryptionTypeStringFromEncryptionType();
      [(IDSPeerAggregatableMessage *)v10 setEncryptionType:v22];
    }
    __int16 v23 = [v9 fileCleanupBlock];
    if (v23)
    {
      v25[0] = _NSConcreteStackBlock;
      v25[1] = 3221225472;
      v25[2] = sub_10013E858;
      v25[3] = &unk_1009801B0;
      id v26 = *(id *)(a1 + 64);
      id v27 = v23;
      [(IDSPeerAggregatableMessage *)v10 setCompletionBlock:v25];
    }
    [*(id *)(a1 + 40) fulfillWithValue:v10];
  }
}

uint64_t sub_10013E858(uint64_t a1)
{
  id v2 = +[IDSFoundationLog delivery];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v5 = 138412290;
    uint64_t v6 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "GUID %@ Finished sending attachment. Cleaning up temporary file.", (uint8_t *)&v5, 0xCu);
  }

  return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16))();
}

id sub_10013E918(uint64_t a1, void *a2)
{
  id v3 = a2;
  [*(id *)(a1 + 32) setAggregatableMessages:v3];
  id v4 = objc_alloc_init((Class)NSMutableDictionary);
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  id v5 = v3;
  id v6 = [v5 countByEnumeratingWithState:&v24 objects:v30 count:16];
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v25;
    do
    {
      for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v25 != v8) {
          objc_enumerationMutation(v5);
        }
        NSErrorUserInfoKey v10 = *(void **)(*((void *)&v24 + 1) + 8 * i);
        id v11 = [v10 targetPeerID];
        NSErrorUserInfoKey v12 = [v10 targetToken];
        CFStringRef v13 = [v11 URIByAddingPushToken:v12];

        if (v13) {
          [v4 setObject:v10 forKey:v13];
        }
      }
      id v7 = [v5 countByEnumeratingWithState:&v24 objects:v30 count:16];
    }
    while (v7);
  }

  __int16 v14 = +[IDSFoundationLog delivery];
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 138412290;
    uint64_t v29 = v15;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "GUID %@ finished constructing aggregatable messages", buf, 0xCu);
  }

  CFStringRef v16 = [*(id *)(a1 + 32) guid];
  id v17 = [v16 copy];

  [v4 debugDescription];
  v23 = uint64_t v22 = v17;
  id v18 = v23;
  id v19 = v17;
  cut_dispatch_log_queue();
  id v20 = +[CUTUnsafePromise fulfilledPromiseWithValue:](CUTUnsafePromise, "fulfilledPromiseWithValue:", *(void *)(a1 + 32), _NSConcreteStackBlock, 3221225472, sub_10013EBB8, &unk_10097E440);

  return v20;
}

void sub_10013EBB8(uint64_t a1)
{
  id v2 = +[IDSFoundationLog delivery_oversized];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    int v5 = 138412546;
    uint64_t v6 = v3;
    __int16 v7 = 2112;
    uint64_t v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "GUID %@ Message to send per destination:\n%@", (uint8_t *)&v5, 0x16u);
  }
}

void sub_10013F174(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, void *a5)
{
  id v7 = a2;
  id v8 = a5;
  uint64_t v9 = [*(id *)(a1 + 32) queue];
  dispatch_assert_queue_V2(v9);

  if (v8)
  {
    NSErrorUserInfoKey v10 = +[IMRGLog engram];
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138543362;
      id v18 = v8;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Account identity cluster election failed {error: %{public}@}", buf, 0xCu);
    }

    v15[0] = NSLocalizedDescriptionKey;
    v15[1] = NSUnderlyingErrorKey;
    v16[0] = @"Engram key election failed";
    v16[1] = v8;
    id v11 = +[NSDictionary dictionaryWithObjects:v16 forKeys:v15 count:2];
    NSErrorUserInfoKey v12 = +[NSError errorWithDomain:@"IDSEngramKeyStoreErrorDomain" code:-6000 userInfo:v11];

    CFStringRef v13 = [*(id *)(a1 + 32) seal];
    [v13 failWithError:v12];
  }
  else
  {
    __int16 v14 = [*(id *)(a1 + 32) seal];
    [v14 fulfillWithValue:v7];
  }
}

void sub_10013F31C(uint64_t a1, void *a2)
{
  id v7 = a2;
  id v3 = [v7 state];
  if (v3 == (id)1)
  {
    uint64_t v6 = *(void *)(a1 + 32);
    int v5 = [v7 error];
    (*(void (**)(uint64_t, void, void *))(v6 + 16))(v6, 0, v5);
  }
  else
  {
    if (v3) {
      goto LABEL_6;
    }
    uint64_t v4 = *(void *)(a1 + 32);
    int v5 = [v7 value];
    (*(void (**)(uint64_t, void *, void))(v4 + 16))(v4, v5, 0);
  }

LABEL_6:
}

void sub_10013F6B4(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, void *a5)
{
  id v7 = a2;
  id v8 = a5;
  uint64_t v9 = [*(id *)(a1 + 32) queue];
  dispatch_assert_queue_V2(v9);

  if (v8)
  {
    NSErrorUserInfoKey v10 = +[IMRGLog engram];
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138543618;
      id v17 = v8;
      __int16 v18 = 2114;
      uint64_t v19 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Existing account identity cluster fetch failed {error: %{public}@}, seal: %{public}@", buf, 0x16u);
    }

    v14[0] = NSLocalizedDescriptionKey;
    v14[1] = NSUnderlyingErrorKey;
    v15[0] = @"Engram key election failed";
    v15[1] = v8;
    NSErrorUserInfoKey v12 = +[NSDictionary dictionaryWithObjects:v15 forKeys:v14 count:2];
    CFStringRef v13 = +[NSError errorWithDomain:@"IDSEngramKeyStoreErrorDomain" code:-6000 userInfo:v12];

    [*(id *)(a1 + 40) failWithError:v13];
  }
  else
  {
    [*(id *)(a1 + 40) fulfillWithValue:v7];
  }
}

void sub_10013F84C(uint64_t a1, void *a2)
{
  id v7 = a2;
  id v3 = [v7 state];
  if (v3 == (id)1)
  {
    uint64_t v6 = *(void *)(a1 + 32);
    int v5 = [v7 error];
    (*(void (**)(uint64_t, void, void *))(v6 + 16))(v6, 0, v5);
  }
  else
  {
    if (v3) {
      goto LABEL_6;
    }
    uint64_t v4 = *(void *)(a1 + 32);
    int v5 = [v7 value];
    (*(void (**)(uint64_t, void *, void))(v4 + 16))(v4, v5, 0);
  }

LABEL_6:
}

void sub_10013FB2C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v5)
  {
    id v7 = [*(id *)(a1 + 32) keychainWrapper];
    id v8 = [(id)objc_opt_class() _keychainIdentifier];
    id v30 = 0;
    uint64_t v9 = [v7 dataForIdentifier:v8 error:&v30];
    id v10 = v30;

    if (v9)
    {
      uint64_t v11 = [v5 adminServiceIdentityWithType:1];
      NSErrorUserInfoKey v12 = v11;
      if (v11)
      {
        id v29 = v10;
        CFStringRef v13 = [v11 publicServiceIdentityAdminWithError:&v29];
        id v14 = v29;

        if (v13)
        {
          id v28 = v14;
          uint64_t v15 = +[IDSMPFullDeviceIdentity deviceIdentityFromDataRepresentation:v9 publicAdminServiceIdentity:v13 error:&v28];
          id v16 = v28;

          if (v15)
          {
            id v17 = +[IMRGLog engram];
            if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 138543362;
              id v32 = v15;
              _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "existingFullDeviceIdentity -- success {deviceIdentity: %{public}@}", buf, 0xCu);
            }

            (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
            __int16 v18 = v16;
          }
          else
          {
            NSErrorUserInfoKey v37 = NSLocalizedDescriptionKey;
            CFStringRef v38 = @"Unable to extract device identity from serialized data";
            long long v26 = +[NSDictionary dictionaryWithObjects:&v38 forKeys:&v37 count:1];
            __int16 v18 = +[NSError errorWithDomain:@"IDSEngramKeyStoreErrorDomain" code:-3000 userInfo:v26];

            long long v27 = +[IMRGLog engram];
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138543875;
              id v32 = v18;
              __int16 v33 = 2114;
              uint64_t v34 = v13;
              __int16 v35 = 2113;
              long long v36 = v9;
              _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Failed existingFullDeviceidentity -- failed to create deviceIdentity {error: %{public}@, publicAdminIdentity: %{public}@, data: %{private}@}", buf, 0x20u);
            }

            (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
          }
        }
        else
        {
          NSErrorUserInfoKey v39 = NSLocalizedDescriptionKey;
          CFStringRef v40 = @"Cluster missing public admin identity with type A";
          long long v24 = +[NSDictionary dictionaryWithObjects:&v40 forKeys:&v39 count:1];
          __int16 v18 = +[NSError errorWithDomain:@"IDSEngramKeyStoreErrorDomain" code:-3000 userInfo:v24];

          long long v25 = +[IMRGLog engram];
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138543618;
            id v32 = v18;
            __int16 v33 = 2114;
            uint64_t v34 = v12;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Failed existingFullDeviceIdentity -- missing publicAdminIdentity {error: %{public}@, fullAdminIdentity: %{public}@}", buf, 0x16u);
          }

          (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
        }
      }
      else
      {
        NSErrorUserInfoKey v41 = NSLocalizedDescriptionKey;
        CFStringRef v42 = @"Cluster missing full admin identity with type A";
        uint64_t v22 = +[NSDictionary dictionaryWithObjects:&v42 forKeys:&v41 count:1];
        __int16 v18 = +[NSError errorWithDomain:@"IDSEngramKeyStoreErrorDomain" code:-3000 userInfo:v22];

        __int16 v23 = +[IMRGLog engram];
        if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT)) {
          sub_100712888((uint64_t)v18, (uint64_t)v5, v23);
        }

        (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
      }
    }
    else
    {
      if (+[IDSKeychainWrapper isItemNotFoundError:v10])
      {
        NSErrorUserInfoKey v43 = NSLocalizedDescriptionKey;
        CFStringRef v44 = @"No registered account identity. Please re-register";
        id v20 = +[NSDictionary dictionaryWithObjects:&v44 forKeys:&v43 count:1];
        __int16 v18 = +[NSError errorWithDomain:@"IDSEngramKeyStoreErrorDomain" code:-5000 userInfo:v20];

        char v21 = +[IMRGLog engram];
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138543362;
          id v32 = v18;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Failed existingFullDeviceIdentity -- keychain item not found {error: %{public}@}", buf, 0xCu);
        }
      }
      else
      {
        char v21 = +[IMRGLog engram];
        if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT)) {
          sub_100712810((uint64_t)v10, v21);
        }
        __int16 v18 = v10;
      }

      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    }
  }
  else
  {
    uint64_t v19 = +[IMRGLog engram];
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138543362;
      id v32 = v6;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Failed existingFullDeviceIdentity -- missing cluster {error: %{public}@}", buf, 0xCu);
    }

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

void sub_100140A64(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = +[IDSFoundationLog ConnectivityMonitor];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    id v6 = [v3 idsResponseCode];
    id v7 = [v3 responseError];
    int v15 = 138412802;
    uint64_t v16 = v5;
    __int16 v17 = 2048;
    id v18 = v6;
    __int16 v19 = 2112;
    id v20 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Connectivity monitor %@ got response %ld with error %@", (uint8_t *)&v15, 0x20u);
  }
  id v8 = [v3 responseError];
  BOOL v9 = v8 == 0;

  id v10 = objc_alloc_init(IDSConnectivityMonitorMetricProperties);
  [(IDSConnectivityMonitorMetricProperties *)v10 setSuccess:v9];
  [(IDSConnectivityMonitorMetricProperties *)v10 setTerminusConnected:1];
  [(IDSConnectivityMonitorMetricProperties *)v10 setTerminusRegistered:1];
  [(IDSConnectivityMonitorMetricProperties *)v10 setTerminusNearby:1];
  uint64_t v11 = +[IDSPairingManager sharedInstance];
  NSErrorUserInfoKey v12 = [v11 pairedDeviceUUIDString];
  [(IDSConnectivityMonitorMetricProperties *)v10 setPairedDeviceCBUUIDString:v12];

  [*(id *)(a1 + 40) timeConnected];
  -[IDSConnectivityMonitorMetricProperties setTimeConnected:](v10, "setTimeConnected:");
  [*(id *)(a1 + 40) timeDisconnected];
  -[IDSConnectivityMonitorMetricProperties setTimeDisconnected:](v10, "setTimeDisconnected:");
  CFStringRef v13 = [[IDSConnectivityMonitorMetric alloc] initWithProperties:v10];
  id v14 = +[IDSRTCLogger loggerWithCategory:3000];
  [v14 logMetric:v13];
}

void sub_100141608(id a1)
{
  qword_100A4A7E0 = objc_alloc_init(IDSFamilyManager);

  _objc_release_x1();
}

void sub_1001418E4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    id v16 = [v6 code];
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Family Fetch returned with error code: %ld", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    [v6 code];
    _IDSLogV();
  }
  id v8 = im_primary_queue();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100141ABC;
  block[3] = &unk_10097E418;
  id v12 = v6;
  id v13 = v5;
  uint64_t v14 = *(void *)(a1 + 32);
  id v9 = v5;
  id v10 = v6;
  dispatch_async(v8, block);
}

id sub_100141ABC(uint64_t a1)
{
  uint64_t v22 = a1;
  if ([*(id *)(a1 + 32) code])
  {
    id v2 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Error fetching family, will allow trying again later.", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    *(unsigned char *)(*(void *)(a1 + 48) + 13) = 0;
    *(unsigned char *)(*(void *)(a1 + 48) + 12) = 1;
  }
  else
  {
    id v21 = objc_alloc_init((Class)NSMutableSet);
    id v18 = objc_alloc_init((Class)NSMutableSet);
    long long v24 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    id obj = [*(id *)(a1 + 40) members];
    id v3 = [obj countByEnumeratingWithState:&v24 objects:v28 count:16];
    if (v3)
    {
      uint64_t v4 = *(void *)v25;
      do
      {
        for (uint64_t i = 0; i != v3; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v25 != v4) {
            objc_enumerationMutation(obj);
          }
          id v6 = *(void **)(*((void *)&v24 + 1) + 8 * i);
          id v7 = [*(id *)(v22 + 48) handlesFromFamilyMember:v6];
          id v8 = objc_alloc((Class)IDSFamilyMember);
          id v9 = [v6 dsid];
          id v10 = [v6 appleID];
          id v11 = [v8 initWithiCloudID:v9 appleID:v10 handles:v7 devices:0];

          [*(id *)(*(void *)(v22 + 48) + 32) unionSet:v7];
          [v21 addObject:v11];
        }
        id v3 = [obj countByEnumeratingWithState:&v24 objects:v28 count:16];
      }
      while (v3);
    }

    objc_storeStrong((id *)(*(void *)(v22 + 48) + 16), v21);
    objc_storeStrong((id *)(*(void *)(v22 + 48) + 24), v18);
    *(unsigned char *)(*(void *)(v22 + 48) + 13) = 0;
    id v12 = [v21 count];
    uint64_t v13 = v22;
    if (!v12)
    {
      uint64_t v14 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Device is not part of a family. Will not allow force fetch until family updates.", buf, 2u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        _IDSLogV();
      }
      uint64_t v13 = v22;
      *(unsigned char *)(*(void *)(v22 + 48) + 12) = 0;
    }
    if (*(unsigned char *)(*(void *)(v13 + 48) + 14))
    {
      int v15 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Pulling out previously stored messages sent to a family service.", buf, 2u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        _IDSLogV();
      }
      *(unsigned char *)(*(void *)(v22 + 48) + 14) = 0;
      id v16 = +[IDSDaemon sharedInstance];
      [v16 _processStoredIncomingMessages];
    }
  }
  return [*(id *)(v22 + 48) _notifyFamilyServicesOfUpdate];
}

void sub_100143DA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54,uint64_t a55,uint64_t a56,uint64_t a57,char a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
}

uint64_t sub_100143DDC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100143DEC(uint64_t a1)
{
}

void sub_100143DF4(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, void *a6, void *a7)
{
  id v10 = a4;
  id v11 = a7;
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = sub_1002DC660(a6);
  id v12 = [v11 encryptionType];

  *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = v12;
  uint64_t v13 = *(void *)(*(void *)(a1 + 56) + 8);
  uint64_t v14 = *(void **)(v13 + 40);
  *(void *)(v13 + 40) = v10;
  id v15 = v10;

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

uint64_t sub_100143EA4()
{
  return IDSTransportThreadAddBlock();
}

id *sub_100143F14(id *result, char a2)
{
  if ((a2 & 1) == 0)
  {
    id v2 = result;
    uint64_t result = (id *)[result[4] _cancelConnectionAndResetDataConnections:1 shouldObliterate:0 encryptionFailure:1 shouldTriggerCorruptionRecovery:0];
    *((unsigned char *)v2[4] + 40) = 0;
  }
  return result;
}

uint64_t sub_100143F5C()
{
  return IDSTransportThreadAddBlock();
}

id *sub_100143FCC(id *result, char a2)
{
  if ((a2 & 1) == 0)
  {
    id v2 = result;
    uint64_t result = (id *)[result[4] _cancelConnectionAndResetDataConnections:1 shouldObliterate:0 encryptionFailure:1 shouldTriggerCorruptionRecovery:0];
    *((unsigned char *)v2[4] + 40) = 0;
  }
  return result;
}

void sub_100144748(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  id v6 = v5;
  switch(a2)
  {
    case 0:
    case 4:
      if (v5) {
        CFErrorRef v7 = nw_error_copy_cf_error(v5);
      }
      else {
        CFErrorRef v7 = 0;
      }
      id v11 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = nw_connection_state_to_string();
        uint64_t v13 = *(void *)(a1 + 32);
        uint64_t v14 = *(void *)(a1 + 40);
        int v15 = *(_DWORD *)(v14 + 24);
        uint64_t v16 = *(void *)(v14 + 8);
        *(_DWORD *)buf = 136316419;
        uint64_t v34 = v12;
        __int16 v35 = 2048;
        uint64_t v36 = v13;
        __int16 v37 = 2112;
        *(void *)CFStringRef v38 = v13;
        *(_WORD *)&v38[8] = 1024;
        *(_DWORD *)&v38[10] = v15;
        __int16 v39 = 2112;
        CFErrorRef v40 = v7;
        __int16 v41 = 2113;
        uint64_t v42 = v16;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "control channel connection event %s for nw_connection (%p) %@ {socket:%d} event error: %@, deviceUniqueID[%{private}@]", buf, 0x3Au);
      }
      goto LABEL_21;
    case 3:
      if (v5)
      {
        CFErrorRef v8 = nw_error_copy_cf_error(v5);
        if (v8)
        {
          CFErrorRef v9 = v8;
          int connected_socket = -1;
LABEL_15:
          __int16 v17 = +[IDSFoundationLog utunController];
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v18 = *(void *)(a1 + 32);
            __int16 v19 = *(__CFError **)(*(void *)(a1 + 40) + 8);
            *(_DWORD *)buf = 134219011;
            uint64_t v34 = v18;
            __int16 v35 = 2112;
            uint64_t v36 = v18;
            __int16 v37 = 1024;
            *(_DWORD *)CFStringRef v38 = connected_socket;
            *(_WORD *)&void v38[4] = 2112;
            *(void *)&v38[6] = v9;
            __int16 v39 = 2113;
            CFErrorRef v40 = v19;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "control channel connect ready for nw_connection (%p) %@ {socket:%d}, event error: %@, deviceUniqueID[%{private}@]", buf, 0x30u);
          }

          int8x16_t v30 = *(int8x16_t *)(a1 + 32);
          id v20 = (id)v30.i64[0];
          id v32 = *(id *)(a1 + 48);
          IDSTransportThreadAddBlock();

          goto LABEL_22;
        }
      }
      int connected_socket = nw_connection_get_connected_socket();
      if ((connected_socket & 0x80000000) == 0)
      {
        CFErrorRef v9 = 0;
        goto LABEL_15;
      }
      long long v27 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v28 = *(void *)(a1 + 32);
        id v29 = *(__CFError **)(*(void *)(a1 + 40) + 8);
        *(_DWORD *)buf = 134219011;
        uint64_t v34 = v28;
        __int16 v35 = 2112;
        uint64_t v36 = v28;
        __int16 v37 = 1024;
        *(_DWORD *)CFStringRef v38 = connected_socket;
        *(_WORD *)&void v38[4] = 2112;
        *(void *)&v38[6] = 0;
        __int16 v39 = 2113;
        CFErrorRef v40 = v29;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "control channel connect ready for nw_connection (%p) %@ {socket:%d}, event error: %@, deviceUniqueID[%{private}@]", buf, 0x30u);
      }

      IDSTransportThreadAddBlock();
LABEL_22:

      return;
    case 5:
      if (v5) {
        CFErrorRef v7 = nw_error_copy_cf_error(v5);
      }
      else {
        CFErrorRef v7 = 0;
      }
      id v11 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v21 = nw_connection_state_to_string();
        uint64_t v22 = *(void *)(a1 + 32);
        uint64_t v23 = *(void *)(a1 + 40);
        int v24 = *(_DWORD *)(v23 + 24);
        uint64_t v25 = *(void *)(v23 + 8);
        *(_DWORD *)buf = 136316419;
        uint64_t v34 = v21;
        __int16 v35 = 2048;
        uint64_t v36 = v22;
        __int16 v37 = 2112;
        *(void *)CFStringRef v38 = v22;
        *(_WORD *)&v38[8] = 1024;
        *(_DWORD *)&v38[10] = v24;
        __int16 v39 = 2112;
        CFErrorRef v40 = v7;
        __int16 v41 = 2113;
        uint64_t v42 = v25;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "control channel connection event %s for nw_connection (%p) %@ {socket:%d} event error: %@, deviceUniqueID[%{private}@]", buf, 0x3Au);
      }
LABEL_21:

      int8x16_t v31 = *(int8x16_t *)(a1 + 32);
      id v26 = (id)v31.i64[0];
      IDSTransportThreadAddBlock();

      goto LABEL_22;
    default:
      goto LABEL_22;
  }
}

id sub_100144C98(uint64_t a1)
{
  return [*(id *)(a1 + 32) _cancelConnectionAndResetDataConnections:0 shouldObliterate:0 encryptionFailure:0 shouldTriggerCorruptionRecovery:0];
}

void sub_100144CB0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(void *)(v1 + 144) == *(void *)(a1 + 40))
  {
    *(_DWORD *)(v1 + 24) = *(_DWORD *)(a1 + 56);
    id v10 = _NSConcreteStackBlock;
    uint64_t v11 = 3221225472;
    uint64_t v12 = sub_100144DF4;
    uint64_t v13 = &unk_10097E4D0;
    id v5 = _NSConcreteStackBlock;
    uint64_t v6 = 3221225472;
    CFErrorRef v7 = sub_100144DFC;
    CFErrorRef v8 = &unk_10097E4D0;
    uint64_t v9 = *(void *)(a1 + 32);
    IDSTransportThreadAddSocket();
    uint64_t v4 = *(void *)(a1 + 48);
    if (v4) {
      objc_msgSend(*(id *)(*(void *)(a1 + 32) + 72), "insertObject:atIndex:", v4, 0, _NSConcreteStackBlock, 3221225472, sub_100144DFC, &unk_10097E4D0, v9, _NSConcreteStackBlock, 3221225472, sub_100144DF4, &unk_10097E4D0);
    }
    objc_msgSend(*(id *)(a1 + 32), "_checkSendNewMessage", v5, v6, v7, v8, v9, v10, v11, v12, v13);
  }
  else
  {
    id v2 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "control channel connect ready but connection already canceled - exit without TPAddSocket", buf, 2u);
    }
  }
}

id sub_100144DF4(uint64_t a1)
{
  return _[*(id *)(a1 + 32) readFromConnection];
}

id sub_100144DFC(uint64_t a1)
{
  return _[*(id *)(a1 + 32) writeToConnection];
}

void sub_100144E04(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  if (v2[18] == *(void *)(a1 + 40))
  {
    _[v2 cancelConnection];
  }
  else
  {
    id v3 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "control channel failure/invalid event but connection already canceled - exit without causing additional cleanup", v4, 2u);
    }
  }
}

void sub_100144EAC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v2 + 168))
  {
    *(unsigned char *)(v2 + 168) = 0;
    id v3 = *(id *)(*(void *)(a1 + 32) + 176);
    uint64_t v4 = *(void *)(a1 + 32);
    id v5 = *(void **)(v4 + 176);
    *(void *)(v4 + 176) = 0;

    if (v3 == *(NSObject **)(a1 + 40))
    {
      [*(id *)(a1 + 32) _callHandlerWithMessage:0 resetDataConnections:*(unsigned __int8 *)(*(void *)(a1 + 32) + 184) shouldObliterate:*(unsigned __int8 *)(*(void *)(a1 + 32) + 185) decryptionFailed:*(unsigned __int8 *)(*(void *)(a1 + 32) + 186) shouldTriggerCorruptionRecovery:*(unsigned __int8 *)(*(void *)(a1 + 32) + 187)];
    }
    else
    {
      uint64_t v6 = +[IDSFoundationLog utunController];
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = *(void *)(a1 + 40);
        uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 144);
        int v11 = 138412802;
        uint64_t v12 = v7;
        __int16 v13 = 2112;
        uint64_t v14 = v8;
        __int16 v15 = 2112;
        uint64_t v16 = v3;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "control channel connection %@ canceled, _connection %@, _canceledConnection %@", (uint8_t *)&v11, 0x20u);
      }
    }
  }
  else
  {
    if (*(void *)(a1 + 40) != *(void *)(v2 + 144)) {
      return;
    }
    id v3 = +[IDSFoundationLog utunController];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(a1 + 40);
      uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 144);
      int v11 = 138412546;
      uint64_t v12 = v9;
      __int16 v13 = 2112;
      uint64_t v14 = v10;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "gatherDataToInvestigate_59608320: connection: %@, _connection: %@", (uint8_t *)&v11, 0x16u);
    }
  }
}

void sub_100145F20(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6)
{
  id v9 = a4;
  id v10 = a5;
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = [a6 encryptionType];
  uint64_t v11 = sub_1002DC598(v10);

  *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = v11;
  uint64_t v12 = *(void *)(*(void *)(a1 + 56) + 8);
  __int16 v13 = *(void **)(v12 + 40);
  *(void *)(v12 + 40) = v9;
  id v14 = v9;

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_100145FD0(id a1)
{
  id v1 = +[IDSDAccountController sharedInstance];
  [v1 issueDependentIDQueriesWithCompletionBlock:0];
}

uint64_t sub_10014601C()
{
  return IDSTransportThreadAddBlock();
}

id *sub_10014608C(id *result, char a2)
{
  if ((a2 & 1) == 0) {
    return (id *)[result[4] _cancelConnectionAndResetDataConnections:1 shouldObliterate:0 encryptionFailure:1 shouldTriggerCorruptionRecovery:0];
  }
  return result;
}

void sub_1001460AC(id a1)
{
  id v1 = +[IDSDAccountController sharedInstance];
  [v1 issueDependentIDQueriesWithCompletionBlock:0];
}

uint64_t sub_1001460F8()
{
  return IDSTransportThreadAddBlock();
}

id *sub_100146168(id *result, char a2)
{
  if ((a2 & 1) == 0) {
    return (id *)[result[4] _cancelConnectionAndResetDataConnections:1 shouldObliterate:0 encryptionFailure:1 shouldTriggerCorruptionRecovery:0];
  }
  return result;
}

void sub_100147AB4(id a1)
{
  off_100A4A7E8 = (uint64_t (*)(void, void, void))IMWeakLinkSymbol();
}

void sub_1001484DC(int a1, void *a2, void *a3, uint64_t a4)
{
}

void sub_1001484EC(int a1, uint64_t a2, void *a3, void *a4, uint64_t a5)
{
  id v8 = a3;
  id v9 = a4;
  id v10 = +[IMRGLog registration];
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412546;
    id v19 = v8;
    __int16 v20 = 2112;
    id v21 = v9;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%@ - %@", buf, 0x16u);
  }

  if ((IMGetCachedDomainBoolForKey() & 1) != 0 || a1)
  {
    uint64_t v11 = +[IMUserNotification userNotificationWithIdentifier:@"Registration" title:v8 message:v9 defaultButton:@"OK" alternateButton:0 otherButton:0];
    [v11 setUsesNotificationCenter:1];
    uint64_t v12 = +[IMUserNotificationCenter sharedInstance];
    [v12 addUserNotification:v11 listener:0];

    __int16 v13 = +[IMLockdownManager sharedInstance];
    if ([v13 isInternalInstall])
    {

      if ((int)a5 < 1)
      {
LABEL_12:

        goto LABEL_13;
      }
    }
    else
    {
      char v14 = IMGetCachedDomainBoolForKey();

      if ((int)a5 < 1 || (v14 & 1) == 0) {
        goto LABEL_12;
      }
    }
    __int16 v15 = +[NSFileManager defaultManager];
    unsigned int v16 = [v15 fileExistsAtPath:@"/usr/local/bin/figplaySS"];

    if (v16)
    {
      id v17 = +[NSString stringWithFormat:@"%@ -ssid %d", @"/usr/local/bin/figplaySS", a5];
      [v17 UTF8String];
      IMPerformSystem();
    }
    goto LABEL_12;
  }
LABEL_13:
}

uint64_t sub_100148710(int a1)
{
  if ((a1 + 1) > 0x1E) {
    return -2;
  }
  else {
    return qword_100794230[a1 + 1];
  }
}

uint64_t sub_100148734(uint64_t a1)
{
  if ((unint64_t)(a1 + 1) > 0x32) {
    return 0;
  }
  else {
    return dword_100794328[a1 + 1];
  }
}

CFStringRef _StringForIDSRegistrationType(unsigned int a1)
{
  if (a1 > 2) {
    return @"Unrecognized";
  }
  else {
    return off_1009838A0[a1];
  }
}

CFStringRef sub_10014877C(uint64_t a1)
{
  if ((unint64_t)(a1 + 2) > 0x33) {
    return @"Unrecognized";
  }
  else {
    return off_1009838B8[a1 + 2];
  }
}

__CFString *sub_1001487A4(void *a1)
{
  id v1 = a1;
  if (IDSIsiMessageRegistrationServiceType())
  {
    uint64_t v2 = @"Messenger";
LABEL_7:

    goto LABEL_8;
  }
  if ((IDSIsFaceTimeRegistrationServiceType() & 1) != 0
    || (IDSIsCallingRegistrationServiceType() & 1) != 0
    || (IDSIsMultiwayRegistrationServiceType() & 1) != 0)
  {
    uint64_t v2 = @"Invitation";
    goto LABEL_7;
  }
  uint64_t v2 = v1;
  if (IDSIsAlloyRegistrationServiceType())
  {
    uint64_t v2 = @"com.apple.private.alloy";
    goto LABEL_7;
  }
LABEL_8:

  return v2;
}

__CFString *sub_100148844(void *a1)
{
  id v1 = a1;
  if (IDSIsiMessageRegistrationServiceType())
  {
    uint64_t v2 = @"com.apple.madrid";
  }
  else if (IDSIsFaceTimeRegistrationServiceType())
  {
    uint64_t v2 = @"com.apple.ess";
  }
  else if (IDSIsCallingRegistrationServiceType())
  {
    uint64_t v2 = @"com.apple.private.ac";
  }
  else
  {
    uint64_t v2 = v1;
    if (!IDSIsMultiwayRegistrationServiceType()) {
      goto LABEL_10;
    }
    uint64_t v2 = @"com.apple.private.alloy.facetime.multi";
  }

LABEL_10:

  return v2;
}

__CFString *sub_1001488E4(unsigned int a1)
{
  if (a1 > 2) {
    return 0;
  }
  else {
    return off_100983A58[a1];
  }
}

id sub_100148904(void *a1)
{
  id v1 = a1;
  uint64_t v2 = [v1 mainID];

  if (!v2)
  {
    id v9 = +[IMRGLog registration];
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = 138412290;
      id v17 = v1;
      uint64_t v12 = "Missing MainID, Not sending IDS Authentication/Register for: %@";
LABEL_29:
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v16, 0xCu);
    }
LABEL_30:
    id v4 = 0;
    goto LABEL_31;
  }
  if ([v1 registrationType] == 1)
  {
    id v3 = [v1 profileID];
    id v4 = [v3 length];

    if (!v4)
    {
      id v9 = +[IMRGLog registration];
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_31;
      }
      int v16 = 138412290;
      id v17 = v1;
      uint64_t v12 = "Missing ProfileID, Not sending IDS Authentication/Register for: %@";
      goto LABEL_29;
    }
  }
  if ([v1 registrationType] == 1)
  {
    id v5 = [v1 regionID];
    id v4 = [v5 length];

    if (!v4)
    {
      id v9 = +[IMRGLog registration];
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_31;
      }
      int v16 = 138412290;
      id v17 = v1;
      uint64_t v12 = "Missing regionID, Not sending IDS Authentication/Register for: %@";
      goto LABEL_29;
    }
  }
  if ([v1 registrationType] == 1)
  {
    uint64_t v6 = [v1 regionBasePhoneNumber];
    id v4 = [v6 length];

    if (!v4)
    {
      id v9 = +[IMRGLog registration];
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_31;
      }
      int v16 = 138412290;
      id v17 = v1;
      uint64_t v12 = "Missing regionBasePhoneNumber, Not sending IDS Authentication/Register for: %@";
      goto LABEL_29;
    }
  }
  uint64_t v7 = [v1 authenticationCert];
  if (v7)
  {
  }
  else
  {
    __int16 v13 = [v1 authenticationToken];

    if (v13)
    {
      char v14 = +[IMRGLog registration];
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        int v16 = 138412290;
        id v17 = v1;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Sending IDS Authentication for: %@", (uint8_t *)&v16, 0xCu);
      }

      id v9 = +[IDSRegistrationCenter sharedInstance];
      id v11 = [v9 authenticateRegistration:v1];
      goto LABEL_20;
    }
  }
  id v8 = [v1 authenticationCert];

  id v9 = +[IMRGLog registration];
  BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if (!v8)
  {
    if (v10)
    {
      int v16 = 138412290;
      id v17 = v1;
      uint64_t v12 = "Not sending IDS Registration or Authentication for: %@";
      goto LABEL_29;
    }
    goto LABEL_30;
  }
  if (v10)
  {
    int v16 = 138412290;
    id v17 = v1;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Sending IDS Registration for: %@", (uint8_t *)&v16, 0xCu);
  }

  id v9 = +[IDSRegistrationCenter sharedInstance];
  id v11 = [v9 sendRegistration:v1];
LABEL_20:
  id v4 = v11;
LABEL_31:

  return v4;
}

id sub_100148C98()
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, 0, 0);
  CFDictionaryAddValue(Mutable, kSecClass, kSecClassGenericPassword);
  CFDictionaryAddValue(Mutable, kSecAttrService, @"AppleIDClientIdentifier");
  CFDictionaryAddValue(Mutable, kSecReturnData, kCFBooleanTrue);
  CFTypeRef result = 0;
  id v1 = 0;
  if (SecItemCopyMatching(Mutable, &result)) {
    BOOL v2 = 1;
  }
  else {
    BOOL v2 = result == 0;
  }
  if (!v2)
  {
    id v3 = objc_alloc((Class)NSString);
    id v1 = [v3 initWithData:result encoding:4];
    CFRelease(result);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }

  return v1;
}

id sub_100148D9C(void *a1)
{
  id v1 = a1;
  BOOL v2 = [v1 componentsSeparatedByString:@":"];
  if ([v2 count] == (id)2)
  {
    id v3 = [v2 objectAtIndex:1];
    id v4 = +[NSNumber numberWithLongLong:[v3 longLongValue]];
    if ([v4 longLongValue])
    {
      id v5 = v4;
    }
    else
    {
      uint64_t v6 = +[IMRGLog registrationAuthKit];
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        int v8 = 138412290;
        id v9 = v1;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "DSID NSNumber extracted from the profile id is null. profileId: %@", (uint8_t *)&v8, 0xCu);
      }

      id v5 = 0;
    }
  }
  else
  {
    id v3 = +[IMRGLog registrationAuthKit];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      id v9 = v1;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Could not split the profileId in order to send only the numerical part to AuthKit. profileId: %@", (uint8_t *)&v8, 0xCu);
    }
    id v5 = 0;
  }

  return v5;
}

void sub_10014931C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t sub_100149340(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

void sub_100149358(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    _DWORD v6[2] = sub_100149420;
    v6[3] = &unk_100983AA0;
    uint64_t v5 = *(void *)(a1 + 32);
    id v7 = *(id *)(a1 + 40);
    id v8 = v3;
    [WeakRetained _fetchCachedObjectForKey:v5 completion:v6];
  }
}

uint64_t sub_100149420(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  BOOL v2 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16);

  return v2();
}

id sub_1001498CC(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _performEvictionSweep];
}

void sub_100149D80(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = [v6 evictionDate];
  id v8 = [v7 compare:*(void *)(a1 + 32)];

  id v9 = +[IDSFoundationLog utilities];
  BOOL v10 = v9;
  if (v8 == (id)-1)
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG)) {
      sub_100712CEC((uint64_t)v5, v6, v10);
    }

    [*(id *)(a1 + 40) addObject:v5];
  }
  else
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      id v11 = [v6 evictionDate];
      int v12 = 138478083;
      id v13 = v5;
      __int16 v14 = 2114;
      __int16 v15 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Not evicting item {key: %{private}@, evictionDate: %{public}@", (uint8_t *)&v12, 0x16u);
    }
  }
}

void sub_10014A090(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [*(id *)(a1 + 32) queue];
  dispatch_assert_queue_V2(v4);

  if (v3)
  {
    id v5 = [*(id *)(a1 + 40) object];
    unsigned __int8 v6 = [v3 isEqual:v5];

    if (v6)
    {
      id v7 = *(void **)(a1 + 40);
      [*(id *)(a1 + 32) ttlInSeconds];
      objc_msgSend(v7, "bumpEvictionDateToSecondsFromNow:");
    }
    else
    {
      id v11 = +[IDSFoundationLog utilities];
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = *(void *)(a1 + 48);
        id v13 = [*(id *)(a1 + 40) object];
        int v14 = 138478339;
        uint64_t v15 = v12;
        __int16 v16 = 2113;
        id v17 = v13;
        __int16 v18 = 2113;
        id v19 = v3;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Delegate replace cached object {key: %{private}@, previous: %{private}@, replacement: %{private}@}", (uint8_t *)&v14, 0x20u);
      }
      [*(id *)(a1 + 32) cacheObject:v3 forKey:*(void *)(a1 + 48)];
    }
    BOOL v10 = *(void (**)(void))(*(void *)(a1 + 56) + 16);
  }
  else
  {
    id v8 = +[IDSFoundationLog utilities];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(a1 + 48);
      int v14 = 138477827;
      uint64_t v15 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Replacement object is nil {key: %{private}@}", (uint8_t *)&v14, 0xCu);
    }

    if (*(void *)(a1 + 40)) {
      [*(id *)(a1 + 32) evictCachedObjectForKey:*(void *)(a1 + 48)];
    }
    BOOL v10 = *(void (**)(void))(*(void *)(a1 + 56) + 16);
  }
  v10();
}

void sub_10014AC50(id a1)
{
  qword_100A4A800 = objc_alloc_init(IDSRegistrationReasonTracker);

  _objc_release_x1();
}

void sub_10014AD80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t sub_10014AD9C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    BOOL v2 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      id v3 = [WeakRetained PNRReasonByUserID];
      *(_DWORD *)buf = 138412290;
      id v9 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Most Recent PNR Reasons %@", buf, 0xCu);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      id v7 = [WeakRetained PNRReasonByUserID];
      _IDSLogV();
    }
    id v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      id v5 = [WeakRetained mostRecentIDSRegistrationReason];
      *(_DWORD *)buf = 134217984;
      id v9 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Most Recent IDS Registration Reason %ld", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      [WeakRetained mostRecentIDSRegistrationReason];
      _IDSLogV();
    }
  }

  return 0;
}

void sub_10014AF74(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x10014AEF4);
  }
  _Unwind_Resume(a1);
}

void sub_10014C448(uint64_t a1)
{
  BOOL v2 = +[IDSFoundationLog RealTimeEncryptionController_oversize];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 56)) {
      CFStringRef v3 = @"YES";
    }
    else {
      CFStringRef v3 = @"NO";
    }
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = *(void *)(a1 + 40);
    uint64_t v6 = *(void *)(a1 + 48);
    int v7 = 138413058;
    uint64_t v8 = v4;
    __int16 v9 = 2112;
    CFStringRef v10 = v3;
    __int16 v11 = 2112;
    uint64_t v12 = v5;
    __int16 v13 = 2112;
    uint64_t v14 = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Returning MkM collection to broadcast { destinationURI: %@, shouldIncludePeerKeys: %@, collection: %@, self: %@ }", (uint8_t *)&v7, 0x2Au);
  }
}

void sub_10014C8AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10014C8C4(uint64_t a1, void *a2, unsigned char *a3)
{
  uint64_t v5 = *(void **)(a1 + 32);
  uint64_t v6 = [a2 keyIndex];
  int v7 = [v6 UUIDString];
  LODWORD(v5) = [v5 isEqualToString:v7];

  if (v5)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
    *a3 = 1;
  }
}

void sub_10014CB50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
}

void sub_10014CB7C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  BOOL v2 = +[IDSFoundationLog RealTimeEncryptionController];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v3 = [WeakRetained automaticResetBlock];
    id v4 = objc_retainBlock(v3);
    int v7 = 138412546;
    id v8 = WeakRetained;
    __int16 v9 = 2112;
    id v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Automatic cache reset timer fired { sself: %@, resetBlock: %@ }", (uint8_t *)&v7, 0x16u);
  }
  if (WeakRetained)
  {
    uint64_t v5 = [WeakRetained automaticResetBlock];

    if (v5)
    {
      uint64_t v6 = [WeakRetained automaticResetBlock];
      ((void (**)(void, id))v6)[2](v6, WeakRetained);
    }
  }
}

void sub_10014D3AC(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0x16u);
}

void sub_10014D658(id a1)
{
  qword_100A4A820 = objc_alloc_init(IDSPACStateTracker);

  _objc_release_x1();
}

void sub_10015064C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7 = a3;
  if (a4)
  {
    NSErrorUserInfoKey v14 = NSUnderlyingErrorKey;
    uint64_t v15 = a4;
    id v8 = a4;
    __int16 v9 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
    uint64_t v10 = +[NSError errorWithDomain:@"IDSValidationSessionErrorDomain" code:-3000 userInfo:v9];
  }
  else
  {
    id v11 = 0;
    uint64_t v12 = [v7 objectAtIndexedSubscript:0];
    [*(id *)(a1 + 32) setBAACert:v12];

    __int16 v13 = [v7 objectAtIndexedSubscript:1];
    [*(id *)(a1 + 32) setIntermediateRootCert:v13];

    [*(id *)(a1 + 32) setBIKKeyRef:a2];
    objc_msgSend(*(id *)(a1 + 32), "setStateFlags:", (unint64_t)objc_msgSend(*(id *)(a1 + 32), "stateFlags") | 1);
    objc_msgSend(*(id *)(a1 + 32), "setStateFlags:", (unint64_t)objc_msgSend(*(id *)(a1 + 32), "stateFlags") | 0x10);
    uint64_t v10 = 0;
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_100150B20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100150B40(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  if (!v8) {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) |= 4u;
  }
  __int16 v9 = +[IMRGLog registration];
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if (v8) {
      CFStringRef v10 = @"YES";
    }
    else {
      CFStringRef v10 = @"NO";
    }
    if (a2) {
      CFStringRef v11 = @"YES";
    }
    else {
      CFStringRef v11 = @"NO";
    }
    *(_DWORD *)buf = 138413058;
    *(void *)id v64 = v10;
    *(_WORD *)&v64[8] = 2112;
    *(void *)&v64[10] = v11;
    *(_WORD *)&v64[18] = 2048;
    *(void *)&v64[20] = [v7 count];
    __int16 v65 = 2112;
    id v66 = v8;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Completed device identity fetch {success: %@, referenceKey: %@, certificates: %lu, error: %@}", buf, 0x2Au);
  }

  uint64_t v62 = 0;
  unsigned int v61 = 0;
  uint64_t v60 = 0;
  uint64_t v12 = 0;
  if ([*(id *)(a1 + 32) _shouldUseAbsintheV3])
  {
    int v13 = sub_1005E8A30((uint64_t)&v60, (uint64_t)&v62, (uint64_t)&v61, *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24));
    if (v13) {
      BOOL v14 = 1;
    }
    else {
      BOOL v14 = v60 == 0;
    }
    if (!v14 && v62 != 0)
    {
      objc_msgSend(*(id *)(a1 + 32), "setPscSession:");
      __int16 v18 = +[NSData dataWithBytes:v62 length:v61];
      [*(id *)(a1 + 32) setHelloMessage:v18];

      id v19 = +[IMRGLog registration];
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        id v21 = [*(id *)(a1 + 32) UDID];
        id v22 = [v21 length];
        uint64_t v23 = [*(id *)(a1 + 32) helloMessage];
        id v24 = [v23 length];
        *(_DWORD *)buf = 134218240;
        *(void *)id v64 = v22;
        *(_WORD *)&v64[8] = 2048;
        *(void *)&v64[10] = v24;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Successfully initialized validation session and hello message {UDUD.length: %ld, helloMessage.length: %ld}", buf, 0x16u);
      }
      if ([*(id *)(a1 + 32) _shouldUseDebugPiscoLogging])
      {
        uint64_t v25 = +[IMRGLog sysdiagnose_oversized];
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          int v26 = *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)id v64 = v26;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "[Pisco] {sessionOptionFlags: %u}", buf, 8u);
        }

        long long v27 = +[IMRGLog sysdiagnose_oversized];
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v28 = [*(id *)(a1 + 32) helloMessage];
          *(_DWORD *)buf = 138412290;
          *(void *)id v64 = v28;
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "[Pisco] {helloMessage: %@}", buf, 0xCu);
        }
      }
      uint64_t v12 = 0;
      if (v8) {
        goto LABEL_55;
      }
      goto LABEL_35;
    }
    int v16 = v13;
    id v17 = +[IMRGLog warning];
    if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
    {
      id v50 = [*(id *)(a1 + 32) pscSession];
      CFStringRef v51 = @"YES";
      if (v50) {
        CFStringRef v52 = @"YES";
      }
      else {
        CFStringRef v52 = @"NO";
      }
      *(_DWORD *)buf = 67109634;
      *(_DWORD *)id v64 = v16;
      *(_WORD *)&void v64[4] = 2112;
      if (!v62) {
        CFStringRef v51 = @"NO";
      }
      *(void *)&v64[6] = v52;
      *(_WORD *)&v64[14] = 2112;
      *(void *)&v64[16] = v51;
      _os_log_fault_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, "Failed to initialize validation session {helloStatus: %d, session: %@, helloMessageBytes: %@}", buf, 0x1Cu);
    }

    if (v60)
    {
      sub_10067B0D8(v60);
      uint64_t v60 = 0;
    }
    uint64_t v12 = +[NSError errorWithDomain:@"IDSValidationSessionErrorDomain" code:-3000 userInfo:0];
  }
  if (v8)
  {
LABEL_55:
    [*(id *)(a1 + 32) setLastBAAError:v8];
    goto LABEL_56;
  }
LABEL_35:
  if (![*(id *)(a1 + 32) _shouldUseBAACertOption]) {
    goto LABEL_55;
  }
  id v29 = [v7 objectAtIndexedSubscript:0];
  [*(id *)(a1 + 32) setBAACert:v29];

  int8x16_t v30 = [v7 objectAtIndexedSubscript:1];
  [*(id *)(a1 + 32) setIntermediateRootCert:v30];

  [*(id *)(a1 + 32) setBIKKeyRef:a2];
  if ([*(id *)(a1 + 32) _shouldUseDebugPiscoLogging])
  {
    int8x16_t v31 = +[IMRGLog sysdiagnose_oversized];
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      id v32 = [*(id *)(a1 + 32) BAACert];
      *(_DWORD *)buf = 138412290;
      *(void *)id v64 = v32;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "[Pisco] {BAACert: %@}", buf, 0xCu);
    }
    __int16 v33 = +[IMRGLog sysdiagnose_oversized];
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v34 = [*(id *)(a1 + 32) intermediateRootCert];
      *(_DWORD *)buf = 138412290;
      *(void *)id v64 = v34;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "[Pisco] {intermediateRootCert: %@}", buf, 0xCu);
    }
  }
  if ([*(id *)(a1 + 32) _shouldUsePSCBAA])
  {
    __int16 v35 = +[IMRGLog registration];
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "Using PSC BAA validation", buf, 2u);
    }

    objc_msgSend(*(id *)(a1 + 32), "setStateFlags:", (unint64_t)objc_msgSend(*(id *)(a1 + 32), "stateFlags") | 1);
    uint64_t v36 = [*(id *)(a1 + 32) BAACert];
    if (v36)
    {
      __int16 v37 = v36;
      uint64_t v38 = [*(id *)(a1 + 32) intermediateRootCert];
      if (v38)
      {
        __int16 v39 = (void *)v38;
        id v40 = [*(id *)(a1 + 32) BIKKeyRef];

        if (!v40) {
          goto LABEL_56;
        }
        __int16 v41 = +[IMRGLog registration];
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Adding option to new validation session", buf, 2u);
        }

        id v54 = [*(id *)(a1 + 32) BIKKeyRef];
        id v55 = [*(id *)(a1 + 32) BAACert];
        id v53 = [v55 bytes];
        uint64_t v42 = [*(id *)(a1 + 32) BAACert];
        int v43 = [v42 length];
        id v44 = [*(id *)(a1 + 32) intermediateRootCert];
        id v45 = [v44 bytes];
        __int16 v46 = [*(id *)(a1 + 32) intermediateRootCert];
        LODWORD(v45) = sub_100708170((uint64_t)&v60, (uint64_t)v54, (uint64_t)v53, v43, (uint64_t)v45, (int)[v46 length]);

        if (!v45 && v60)
        {
          id v47 = +[IMRGLog registration];
          if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "Successfully added option to validation session", buf, 2u);
          }

          [*(id *)(a1 + 32) setPscSession:v60];
          objc_msgSend(*(id *)(a1 + 32), "setStateFlags:", (unint64_t)objc_msgSend(*(id *)(a1 + 32), "stateFlags") | 0x10);
          goto LABEL_56;
        }
        __int16 v37 = +[IMRGLog warning];
        if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT)) {
          sub_1007131C8();
        }
      }
    }
  }
LABEL_56:
  if (v62)
  {
    sub_1005CA308(v62);
    uint64_t v62 = 0;
  }
  __int16 v48 = [*(id *)(a1 + 32) queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10015138C;
  block[3] = &unk_100981860;
  id v59 = *(id *)(a1 + 40);
  id v57 = *(id *)(a1 + 32);
  id v58 = v12;
  id v49 = v12;
  dispatch_async(v48, block);
}

uint64_t sub_10015138C(void *a1)
{
  return (*(uint64_t (**)(void, void, void))(a1[6] + 16))(a1[6], a1[4], a1[5]);
}

void sub_100151E50(void *a1, void *a2)
{
  uint64_t v3 = a1[7];
  id v4 = a2;
  uint64_t v5 = [[IDSValidationSigningResult alloc] initWithAbsintheResultData:a1[4] absintheServerKey:a1[5] absintheError:a1[6] baaResult:v4];

  (*(void (**)(uint64_t, IDSValidationSigningResult *))(v3 + 16))(v3, v5);
}

void sub_100151EDC(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = a2;
  id v4 = [[IDSValidationSigningResult alloc] initWithAbsintheResultData:0 absintheServerKey:0 absintheError:0 baaResult:v3];

  (*(void (**)(uint64_t, IDSValidationSigningResult *))(v2 + 16))(v2, v4);
}

void sub_10015202C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 absintheError];
  if (v4) {
    goto LABEL_2;
  }
  uint64_t v24 = [v3 absintheServerKey];
  if (!v24) {
    goto LABEL_3;
  }
  id v4 = (void *)v24;
  uint64_t v25 = [v3 absintheResultData];
  if (!v25)
  {
LABEL_2:
  }
  else
  {
    int v26 = (void *)v25;
    id v27 = [*(id *)(a1 + 32) mechanism];

    if (!v27)
    {
      uint64_t v5 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
      uint64_t v28 = [*(id *)(a1 + 40) sha256Digest];
      id v29 = [v28 base64EncodedStringWithOptions:0];

      if (v29)
      {
        CFDictionarySetValue(v5, @"absinthe-message", v29);
      }
      else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        sub_100713520();
      }

      uint64_t v38 = [v3 absintheResultData];
      __int16 v39 = [v38 base64EncodedStringWithOptions:0];

      if (v39)
      {
        CFDictionarySetValue(v5, @"absinthe-signature", v39);
      }
      else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        sub_100713498();
      }

      id v40 = [v3 absintheServerKey];
      __int16 v41 = [v40 base64EncodedStringWithOptions:0];

      if (v41)
      {
        CFDictionarySetValue(v5, @"absinthe-serv-key", v41);
      }
      else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        sub_100713410();
      }

      uint64_t v42 = [*(id *)(a1 + 32) UDID];
      if (v42)
      {
        CFDictionarySetValue(v5, @"absinthe-udid", v42);
      }
      else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        sub_100713388();
      }

      int v43 = [*(id *)(a1 + 32) serialNumber];
      if (v43)
      {
        CFDictionarySetValue(v5, @"absinthe-serial-number", v43);
      }
      else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        sub_100713300();
      }

      id v44 = [*(id *)(a1 + 32) IMEI];
      if (v44) {
        CFDictionarySetValue(v5, @"absinthe-imei", v44);
      }

      id v45 = [*(id *)(a1 + 32) MEID];
      if (v45) {
        CFDictionarySetValue(v5, @"absinthe-meid", v45);
      }

      if ([*(id *)(a1 + 32) isUsingAbsintheV4]) {
        CFStringRef v46 = @"true";
      }
      else {
        CFStringRef v46 = @"false";
      }
      CFDictionarySetValue(v5, @"absinthe-v4", v46);
      if ([*(id *)(a1 + 32) isUsingBAA]) {
        CFStringRef v47 = @"true";
      }
      else {
        CFStringRef v47 = @"false";
      }
      CFDictionarySetValue(v5, @"absinthe-baa", v47);
      goto LABEL_5;
    }
  }
LABEL_3:
  if ([*(id *)(a1 + 32) mechanism] != (id)1)
  {
    uint64_t v5 = 0;
    goto LABEL_9;
  }
  uint64_t v5 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
LABEL_5:
  uint64_t v6 = [*(id *)(a1 + 32) baaSigner];
  uint64_t v7 = *(void *)(a1 + 40);
  id v8 = [v3 baaResult];
  __int16 v9 = [*(id *)(a1 + 32) BAACert];
  CFStringRef v10 = [*(id *)(a1 + 32) intermediateRootCert];
  CFStringRef v11 = [v6 headersBySigningData:v7 baaSigningResult:v8 baaCert:v9 intermediateRootCert:v10];

  if (v11) {
    [(__CFDictionary *)v5 addEntriesFromDictionary:v11];
  }

LABEL_9:
  uint64_t v12 = [v3 absintheError];
  if (v12)
  {
    int v13 = (void *)v12;
    BOOL v14 = [v3 baaResult];
    uint64_t v15 = [v14 error];

    if (v15)
    {
      id v16 = objc_alloc((Class)NSError);
      NSErrorUserInfoKey v49 = NSMultipleUnderlyingErrorsKey;
      id v17 = [v3 absintheError];
      v48[0] = v17;
      __int16 v18 = [v3 baaResult];
      id v19 = [v18 error];
      v48[1] = v19;
      __int16 v20 = +[NSArray arrayWithObjects:v48 count:2];
      id v50 = v20;
      id v21 = +[NSDictionary dictionaryWithObjects:&v50 forKeys:&v49 count:1];
      id v22 = [v16 initWithDomain:@"IDSValidationSessionErrorDomain" code:-5000 userInfo:v21];

LABEL_21:
      goto LABEL_22;
    }
  }
  uint64_t v23 = [v3 absintheError];

  if (v23)
  {
    id v22 = [v3 absintheError];
    goto LABEL_22;
  }
  int8x16_t v30 = [v3 baaResult];
  int8x16_t v31 = [v30 error];

  if (v31)
  {
    id v17 = [v3 baaResult];
    id v22 = [v17 error];
    goto LABEL_21;
  }
  id v22 = 0;
LABEL_22:
  id v32 = [v3 baaResult];
  __int16 v33 = [v32 icloudDigest];

  if (v33)
  {
    id v34 = objc_alloc((Class)IDSBAASignerContext);
    __int16 v35 = [v3 baaResult];
    uint64_t v36 = [v35 icloudDigest];
    id v37 = [v34 initWithSigningDigest:v36];
  }
  else
  {
    id v37 = 0;
  }
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

void sub_10015301C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  _Block_object_dispose(&a27, 8);
  _Block_object_dispose(&a33, 8);
  _Block_object_dispose((const void *)(v33 - 176), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100153064(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100153074(uint64_t a1)
{
}

void sub_10015307C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IMRGLog registration];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    uint64_t v15 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Starting fetch of device identity for validation session {validityInMinutes: %@}", buf, 0xCu);
  }

  v12[0] = kMAOptionsBAAKeychainLabel;
  v12[1] = kMAOptionsBAAValidity;
  uint64_t v6 = *(void *)(a1 + 32);
  v13[0] = @"com.apple.IDS";
  v13[1] = v6;
  v12[2] = kMAOptionsBAAOIDSToInclude;
  v11[0] = kMAOptionsBAAOIDUCRTDeviceIdentifiers;
  v11[1] = kMAOptionsBAAOIDDeviceOSInformation;
  v11[2] = kMAOptionsBAAOIDProductType;
  uint64_t v7 = +[NSArray arrayWithObjects:v11 count:3];
  v13[2] = v7;
  id v8 = +[NSDictionary dictionaryWithObjects:v13 forKeys:v12 count:3];

  __int16 v9 = [*(id *)(a1 + 40) BAAQueue];
  id v10 = v3;
  DeviceIdentityIssueClientCertificateWithCompletion();
}

void sub_100153280(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  __int16 v9 = +[IMRGLog registration];
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if (a2) {
      CFStringRef v10 = @"YES";
    }
    else {
      CFStringRef v10 = @"NO";
    }
    *(_DWORD *)buf = 138412802;
    CFStringRef v24 = v10;
    __int16 v25 = 2048;
    id v26 = [v7 count];
    __int16 v27 = 2112;
    id v28 = v8;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Completed fetch of device identity for validation session {referenceKey: %@, certificates: %lu, error: %@}", buf, 0x20u);
  }

  CFStringRef v11 = [*(id *)(a1 + 32) BAAQueue];
  dispatch_assert_queue_V2(v11);

  uint64_t v12 = [*(id *)(a1 + 32) queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100153460;
  block[3] = &unk_100983D20;
  uint64_t v22 = a2;
  long long v21 = *(_OWORD *)(a1 + 56);
  id v18 = v7;
  id v19 = v8;
  long long v16 = *(_OWORD *)(a1 + 40);
  id v13 = (id)v16;
  long long v20 = v16;
  id v14 = v8;
  id v15 = v7;
  dispatch_async(v12, block);
}

uint64_t sub_100153460(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = *(void *)(a1 + 80);
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40), *(id *)(a1 + 32));
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 72) + 8) + 40), *(id *)(a1 + 40));
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)(a1 + 48) + 16);

  return v2();
}

void sub_1001534D4(uint64_t a1, int a2)
{
  id v4 = +[IMRGLog registration];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v5 = @"NO";
    if (a2) {
      CFStringRef v5 = @"YES";
    }
    *(_DWORD *)buf = 138412290;
    CFStringRef v14 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Device identity fetch final block called {timedOut: %@}", buf, 0xCu);
  }

  uint64_t v6 = [*(id *)(a1 + 32) queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10015363C;
  block[3] = &unk_100983DC0;
  char v12 = a2;
  long long v11 = *(_OWORD *)(a1 + 56);
  long long v8 = *(_OWORD *)(a1 + 40);
  id v7 = (id)v8;
  long long v10 = v8;
  void block[4] = *(void *)(a1 + 32);
  dispatch_async(v6, block);
}

void sub_10015363C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 72))
  {
    *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
    uint64_t v2 = *(void *)(*(void *)(a1 + 56) + 8);
    id v3 = *(void **)(v2 + 40);
    *(void *)(v2 + 40) = 0;

    NSErrorUserInfoKey v13 = NSDebugDescriptionErrorKey;
    CFStringRef v14 = @"Timed out requesting device identity";
    id v4 = +[NSDictionary dictionaryWithObjects:&v14 forKeys:&v13 count:1];
    uint64_t v5 = +[NSError errorWithDomain:@"IDSValidationSessionInternalErrorDomain" code:-11000 userInfo:v4];
    uint64_t v6 = *(void *)(*(void *)(a1 + 64) + 8);
    id v7 = *(void **)(v6 + 40);
    *(void *)(v6 + 40) = v5;
  }
  if (*(void *)(a1 + 40))
  {
    long long v8 = [*(id *)(a1 + 32) queue];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1001537C4;
    block[3] = &unk_100983D98;
    id v10 = *(id *)(a1 + 40);
    long long v11 = *(_OWORD *)(a1 + 48);
    uint64_t v12 = *(void *)(a1 + 64);
    dispatch_async(v8, block);
  }
}

uint64_t sub_1001537C4(void *a1)
{
  return (*(uint64_t (**)(void, void, void, void))(a1[4] + 16))(a1[4], *(void *)(*(void *)(a1[5] + 8) + 24), *(void *)(*(void *)(a1[6] + 8) + 40), *(void *)(*(void *)(a1[7] + 8) + 40));
}

void sub_100153C78(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 8u);
}

void sub_100153F50(id a1)
{
  qword_100A4A848 = objc_alloc_init(IDSDAccountController);

  _objc_release_x1();
}

void sub_100154888(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1001548B0(id a1, IDSDAccountController *a2)
{
}

uint64_t sub_1001548B8(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v115 = _os_activity_create((void *)&_mh_execute_header, "ids/registration/account-controller/state", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
    state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
    os_activity_scope_enter(v115, &state);
    __int16 v99 = [WeakRetained[7] iCloudSystemAccountWithError:0];
    id v100 = WeakRetained;
    uint64_t v98 = [WeakRetained[7] iTunesSystemAccountWithError:0];
    uint64_t v2 = +[IMRGLog sysdiagnose_oversized];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      CFStringRef v120 = v99;
      __int16 v121 = 2112;
      CFStringRef v122 = v98;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Current system account state { iCloudAccount: %@, iTunesAccount: %@ }", buf, 0x16u);
    }

    id v3 = +[FTDeviceSupport sharedInstance];
    __int16 v97 = [v3 deviceName];

    id v4 = +[FTDeviceSupport sharedInstance];
    id v96 = [v4 model];

    uint64_t v5 = +[FTDeviceSupport sharedInstance];
    __int16 v95 = [v5 productName];

    uint64_t v6 = +[FTDeviceSupport sharedInstance];
    uint64_t v94 = [v6 productVersion];

    id v7 = +[FTDeviceSupport sharedInstance];
    unsigned int v93 = [v7 productBuildVersion];

    long long v8 = +[IDSPushHandler sharedInstance];
    id v92 = [v8 pushToken];

    uint64_t v9 = +[IDSPushHandler sharedInstance];
    id v10 = [v9 copyPushIdentity];

    long long v11 = +[IDSCurrentDevice sharedInstance];
    long long v91 = [v11 deviceIdentifier];

    long long v90 = IMGetEnvironmentName();
    uint64_t v12 = +[IMRGLog sysdiagnose_oversized];
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      id v13 = [v92 debugDescription];
      int v14 = _os_feature_enabled_impl();
      CFStringRef v15 = @"NO";
      *(_DWORD *)buf = 138414594;
      CFStringRef v120 = v97;
      __int16 v121 = 2112;
      if (v14) {
        CFStringRef v15 = @"YES";
      }
      CFStringRef v122 = v96;
      __int16 v123 = 2112;
      CFStringRef v124 = v95;
      __int16 v125 = 2112;
      CFStringRef v126 = v94;
      __int16 v127 = 2112;
      uint64_t v128 = (uint64_t)v93;
      __int16 v129 = 2112;
      id v130 = v13;
      __int16 v131 = 2112;
      id v132 = v10;
      __int16 v133 = 2112;
      id v134 = v91;
      __int16 v135 = 2112;
      CFStringRef v136 = v15;
      __int16 v137 = 2112;
      double v138 = v90;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Current IDS device state { deviceName: %@, model: %@, productName: %@, productVersion: %@, build: %@, pushToken: %@, pushIdentity: %@, idsUniqueID: %@, prototypeMode: %@, environment: %@ }", buf, 0x66u);
    }
    if (v10) {
      CFRelease(v10);
    }
    long long v16 = +[IMRGLog sysdiagnose_oversized];
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      if (+[IDSRegistrationController isBuddyShowing]) {
        CFStringRef v17 = @"NO";
      }
      else {
        CFStringRef v17 = @"YES";
      }
      id v18 = +[IMSystemMonitor sharedInstance];
      if ([v18 isUnderDataProtectionLock]) {
        CFStringRef v19 = @"YES";
      }
      else {
        CFStringRef v19 = @"NO";
      }
      long long v20 = +[IMSystemMonitor sharedInstance];
      if ([v20 isUnderFirstDataProtectionLock]) {
        CFStringRef v21 = @"YES";
      }
      else {
        CFStringRef v21 = @"NO";
      }
      uint64_t v22 = +[IMSystemMonitor sharedInstance];
      if ([v22 systemIsShuttingDown]) {
        CFStringRef v23 = @"YES";
      }
      else {
        CFStringRef v23 = @"NO";
      }
      *(_DWORD *)buf = 138413058;
      CFStringRef v120 = v17;
      __int16 v121 = 2112;
      CFStringRef v122 = v19;
      __int16 v123 = 2112;
      CFStringRef v124 = v21;
      __int16 v125 = 2112;
      CFStringRef v126 = v23;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Current IDS system monitor state { isSetup: %@, isUnderDataProtectionLock: %@, isUnderFirstDataProtectionLock: %@, systemIsShuttingDown: %@ }", buf, 0x2Au);
    }
    CFStringRef v24 = +[IMRGLog sysdiagnose_oversized];
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v25 = +[IDSRegistrationKeyManager sharedInstance];
      id v26 = [v25 publicMessageProtectionData];
      *(_DWORD *)buf = 138412290;
      CFStringRef v120 = v26;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Current IDS message protection state { publicMessageProtectionData: %@ }", buf, 0xCu);
    }
    long long v89 = +[FTServerBag sharedInstanceForBagType:0];
    __int16 v27 = +[IMRGLog sysdiagnose_oversized];
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      if ([(__CFString *)v89 isLoaded]) {
        CFStringRef v28 = @"YES";
      }
      else {
        CFStringRef v28 = @"NO";
      }
      if ([(__CFString *)v89 isLoading]) {
        CFStringRef v29 = @"YES";
      }
      else {
        CFStringRef v29 = @"NO";
      }
      unsigned int v30 = [(__CFString *)v89 isServerAvailable];
      uint64_t v31 = [(__CFString *)v89 apsEnvironmentName];
      id v32 = (void *)v31;
      if (v30) {
        CFStringRef v33 = @"YES";
      }
      else {
        CFStringRef v33 = @"NO";
      }
      *(_DWORD *)buf = 138413314;
      CFStringRef v120 = v89;
      __int16 v121 = 2112;
      CFStringRef v122 = v28;
      __int16 v123 = 2112;
      CFStringRef v124 = v29;
      __int16 v125 = 2112;
      CFStringRef v126 = v33;
      __int16 v127 = 2112;
      uint64_t v128 = v31;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Current IDS server bag state { serverBag: %@, isLoaded: %@, isLoading: %@, isServerAvailable: %@, environment: %@ }", buf, 0x34u);
    }
    uint64_t v101 = +[FTServiceStatus sharedInstance];
    id v34 = +[IMRGLog sysdiagnose_oversized];
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v35 = +[FTDeviceSupport sharedInstance];
      uint64_t v36 = [v35 deviceRegionInfo];
      if ([v101 iMessageSupported]) {
        CFStringRef v37 = @"YES";
      }
      else {
        CFStringRef v37 = @"NO";
      }
      unsigned int v38 = [v101 faceTimeAudioSupported];
      unsigned int v39 = [v101 faceTimeMultiwaySupported];
      if (v38) {
        CFStringRef v40 = @"YES";
      }
      else {
        CFStringRef v40 = @"NO";
      }
      *(_DWORD *)buf = 138413058;
      if (v39) {
        CFStringRef v41 = @"YES";
      }
      else {
        CFStringRef v41 = @"NO";
      }
      CFStringRef v120 = v36;
      __int16 v121 = 2112;
      CFStringRef v122 = v37;
      __int16 v123 = 2112;
      CFStringRef v124 = v40;
      __int16 v125 = 2112;
      CFStringRef v126 = v41;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Current IDS service capability state { regionInfo: %@, iMessageSupported: %@, faceTimeAudioSupported: %@, faceTimeMultiwaySupported: %@ }", buf, 0x2Au);
    }
    uint64_t v42 = +[IMRGLog sysdiagnose_oversized];
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      int v43 = +[IDSSMSRegistrationCenter sharedInstance];
      id v44 = [v43 validators];
      id v45 = +[IDSLogFormatter descriptionForArray:v44 options:16];
      *(_DWORD *)buf = 138412290;
      CFStringRef v120 = v45;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "Current IDS phone number validation state { stateMachines: %@ }", buf, 0xCu);
    }
    CFStringRef v46 = +[IMRGLog sysdiagnose_oversized];
    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v47 = +[IDSDaemon sharedInstance];
      __int16 v48 = [v47 registrationConductor];
      NSErrorUserInfoKey v49 = [v48 userStore];
      id v50 = [v49 debugDescription];
      *(_DWORD *)buf = 138412290;
      CFStringRef v120 = v50;
      _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "Current IDS user store state { userStore: %@ }", buf, 0xCu);
    }
    CFStringRef v51 = +[IMRGLog sysdiagnose_oversized];
    if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v52 = +[IDSCTAdapter sharedInstance];
      if ([v52 supportsIdentification]) {
        CFStringRef v53 = @"YES";
      }
      else {
        CFStringRef v53 = @"NO";
      }
      id v54 = +[IDSCTAdapter sharedInstance];
      id v55 = [v54 currentSIMsWithError:0];
      uint64_t v56 = +[FTUserConfiguration sharedInstance];
      id v57 = [v56 selectedPhoneNumberRegistrationSubscriptionLabels];
      id v58 = +[IDSLogFormatter descriptionForArray:v57 options:0];
      *(_DWORD *)buf = 138412802;
      CFStringRef v120 = v53;
      __int16 v121 = 2112;
      CFStringRef v122 = v55;
      __int16 v123 = 2112;
      CFStringRef v124 = v58;
      _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "Current IDS phone profile state { isPNRSupported: %@, SIMs: %@, selectedTelephonyLabelID: %@ }", buf, 0x20u);
    }
    id v59 = [v100 accounts];
    uint64_t v60 = +[IMRGLog sysdiagnose_oversized];
    if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "Current IDS accounts list:", buf, 2u);
    }

    long long v112 = 0u;
    long long v113 = 0u;
    long long v110 = 0u;
    long long v111 = 0u;
    id v61 = v59;
    id v62 = [v61 countByEnumeratingWithState:&v110 objects:v118 count:16];
    if (v62)
    {
      uint64_t v63 = *(void *)v111;
      do
      {
        for (uint64_t i = 0; i != v62; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v111 != v63) {
            objc_enumerationMutation(v61);
          }
          __int16 v65 = *(void **)(*((void *)&v110 + 1) + 8 * i);
          id v66 = +[IMRGLog sysdiagnose_oversized];
          if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
          {
            id v67 = [v65 debugDescription];
            *(_DWORD *)buf = 138412290;
            CFStringRef v120 = v67;
            _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "%@", buf, 0xCu);
          }
        }
        id v62 = [v61 countByEnumeratingWithState:&v110 objects:v118 count:16];
      }
      while (v62);
    }

    id v68 = +[IMRGLog sysdiagnose_oversized];
    if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "Current IDS account info dictionaries:", buf, 2u);
    }

    long long v108 = 0u;
    long long v109 = 0u;
    long long v106 = 0u;
    long long v107 = 0u;
    id v69 = v61;
    id v70 = [v69 countByEnumeratingWithState:&v106 objects:v117 count:16];
    if (v70)
    {
      uint64_t v71 = *(void *)v107;
      do
      {
        for (j = 0; j != v70; j = (char *)j + 1)
        {
          if (*(void *)v107 != v71) {
            objc_enumerationMutation(v69);
          }
          id v73 = *(void **)(*((void *)&v106 + 1) + 8 * (void)j);
          id v74 = [v73 service];
          id v75 = [v74 pushTopic];
          unsigned __int8 v76 = [&off_1009D2BD8 containsObject:v75];

          if (v76)
          {
            id v77 = +[IMRGLog sysdiagnose_oversized];
            if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
            {
              long long v78 = [v73 accountInfo];
              *(_DWORD *)buf = 138412290;
              CFStringRef v120 = v78;
              _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "%@", buf, 0xCu);
            }
          }
        }
        id v70 = [v69 countByEnumeratingWithState:&v106 objects:v117 count:16];
      }
      while (v70);
    }

    long long v104 = 0u;
    long long v105 = 0u;
    long long v102 = 0u;
    long long v103 = 0u;
    id v79 = v69;
    id v80 = [v79 countByEnumeratingWithState:&v102 objects:v116 count:16];
    if (v80)
    {
      uint64_t v81 = *(void *)v103;
      do
      {
        for (k = 0; k != v80; k = (char *)k + 1)
        {
          if (*(void *)v103 != v81) {
            objc_enumerationMutation(v79);
          }
          id v83 = *(void **)(*((void *)&v102 + 1) + 8 * (void)k);
          long long v84 = [v83 service];
          long long v85 = [v84 pushTopic];
          unsigned __int8 v86 = [&off_1009D2BF0 containsObject:v85];

          if (v86)
          {
            long long v87 = [v83 dependentRegistrations];
            [v87 enumerateObjectsUsingBlock:&stru_100983EA8];
          }
        }
        id v80 = [v79 countByEnumeratingWithState:&v102 objects:v116 count:16];
      }
      while (v80);
    }

    os_activity_scope_leave(&state);
    cut_arc_os_release();

    id WeakRetained = v100;
  }

  return 0;
}

void sub_10015566C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,os_activity_scope_state_s state,char a51)
{
}

void sub_100155750(id a1, id a2, unint64_t a3, BOOL *a4)
{
  uint64_t v4 = IDSDevicePropertyService;
  id v5 = a2;
  uint64_t v6 = [v5 objectForKey:v4];
  id v7 = [v5 objectForKey:IDSDevicePropertyPushToken];
  long long v8 = [v5 objectForKey:IDSDevicePropertyName];
  uint64_t v9 = [v5 objectForKey:IDSDevicePropertyHardwareVersion];
  id v10 = [v5 objectForKey:IDSDevicePropertyPrivateDeviceData];
  long long v11 = [v5 objectForKey:IDSDevicePropertySubServices];
  CFStringRef v24 = [v5 objectForKey:IDSDevicePropertyIdentities];
  CFStringRef v23 = [v5 objectForKey:IDSDevicePropertyLinkedUserURIs];
  uint64_t v12 = [v5 objectForKey:IDSDevicePropertyClientData];
  id v13 = [v12 objectForKey:_IDSIdentityClientDataMessageProtectionIdentityKey];
  int v14 = [v5 objectForKey:IDSDevicePropertyIsHSATrustedDevice];

  CFStringRef v15 = +[IMRGLog sysdiagnose_oversized];
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    [v7 debugDescription];
    uint64_t v22 = v11;
    long long v16 = v9;
    CFStringRef v17 = v8;
    v19 = id v18 = v6;
    [v10 objectForKey:IDSPrivateDeviceDataUniqueID];
    long long v20 = v21 = v7;
    *(_DWORD *)buf = 138415106;
    id v26 = v17;
    __int16 v27 = 2112;
    CFStringRef v28 = v18;
    __int16 v29 = 2112;
    unsigned int v30 = v16;
    __int16 v31 = 2112;
    id v32 = v19;
    __int16 v33 = 2112;
    id v34 = v20;
    __int16 v35 = 2112;
    uint64_t v36 = v23;
    __int16 v37 = 2112;
    unsigned int v38 = v10;
    __int16 v39 = 2112;
    CFStringRef v40 = v22;
    __int16 v41 = 2112;
    uint64_t v42 = v24;
    __int16 v43 = 2112;
    id v44 = v12;
    __int16 v45 = 2112;
    CFStringRef v46 = v13;
    __int16 v47 = 2112;
    __int16 v48 = v14;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "  * Device Name: %@    Service: %@     Hardware: %@    Token: %@   Unique ID: %@   Linked URIs: %@   Device Data: %@   Sub-services: %@   Identities: %@   Client data: %@   public key: %@ HSA trusted: %@", buf, 0x7Au);

    id v7 = v21;
    uint64_t v6 = v18;
    long long v8 = v17;
    uint64_t v9 = v16;
    long long v11 = v22;
  }
}

void sub_100155CD8(id a1)
{
  id v1 = +[IMRGLog registration];
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Hard deregister complete, clearing accounts and shutting down daemon", v3, 2u);
  }

  uint64_t v2 = +[IDSDaemon sharedInstance];
  [v2 shutdown];
}

id sub_100156788(uint64_t a1)
{
  id v1 = [*(id *)(a1 + 32) _inUseUsernames];
  uint64_t v2 = [v1 allObjects];

  return v2;
}

id sub_1001567D8(uint64_t a1)
{
  id v1 = [*(id *)(a1 + 32) _inUseProfileIDs];
  uint64_t v2 = [v1 allObjects];

  return v2;
}

void sub_100156DDC(id a1, id a2)
{
  id v2 = a2;
  id v3 = [v2 uniqueID];
  uint64_t v4 = +[IMRGLog registration];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 138412290;
    id v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Removing linked account: %@", (uint8_t *)&v6, 0xCu);
  }

  id v5 = +[IDSDAccountController sharedInstance];
  [v5 removeAccount:v2];
}

id sub_10015BD40(id a1, NSString *a2)
{
  id v2 = a2;
  if ([(NSString *)v2 isEqualToString:kIDSServiceDefaultsSentinelSelfAlias]) {
    id v3 = 0;
  }
  else {
    id v3 = [objc_alloc((Class)IDSURI) initWithPrefixedURI:v2];
  }

  return v3;
}

void sub_10015BF90(uint64_t a1, void *a2)
{
  id v3 = *(void **)(a1 + 32);
  id v4 = a2;
  [v3 addPrimaryAccount:v4];
  id v5 = *(void **)(a1 + 32);
  id v6 = [v4 uniqueID];

  [v5 enablePrimaryAccountWithUniqueID:v6];
}

BOOL sub_10015E33C(uint64_t a1, void *a2)
{
  id v3 = [a2 service];
  BOOL v4 = v3 == *(void **)(a1 + 32);

  return v4;
}

void sub_10015EA80(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = +[IMRGLog registration];
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = 138412290;
    id v15 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Importing account: %@", (uint8_t *)&v14, 0xCu);
  }

  id v8 = [v6 mutableCopy];
  [v8 addEntriesFromDictionary:v6];
  uint64_t v9 = kFZServiceDefaultsLoginAsKey;
  id v10 = [v6 objectForKey:kFZServiceDefaultsLoginAsKey];
  long long v11 = [v10 _stripFZIDPrefix];
  uint64_t v12 = +[IMRGLog registration];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = 138412546;
    id v15 = v10;
    __int16 v16 = 2112;
    CFStringRef v17 = v11;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Login ID: %@, new login: %@", (uint8_t *)&v14, 0x16u);
  }

  id v13 = +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", [v10 _FZIDType] == (id)1);
  [v8 setObject:v13 forKey:kIDSServiceDefaultsAccountTypeKey];

  [v8 removeObjectForKey:@"AuthToken"];
  if (v11) {
    [v8 setObject:v11 forKey:v9];
  }
  [*(id *)(a1 + 32) setObject:v8 forKey:v5];
}

void sub_10015EF14(_Unwind_Exception *a1)
{
}

uint64_t sub_10015F4AC()
{
  if (_os_feature_enabled_impl()) {
    uint64_t v0 = 1832;
  }
  else {
    uint64_t v0 = 1831;
  }
  id v1 = +[FTDeviceSupport sharedInstance];
  unsigned int v2 = [v1 supportsEmojiImages];

  return v0 + v2;
}

void sub_10015FEB8(uint64_t a1)
{
  unsigned int v2 = +[IMRGLog registration];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Re-register timer hit", buf, 2u);
  }

  if (![*(id *)(a1 + 32) hasForcedReRegistered] || *(unsigned char *)(a1 + 40))
  {
    id v3 = +[IMRGLog registration];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "We still need to re-register, triggering it now...", buf, 2u);
    }

    BOOL v4 = [*(id *)(a1 + 32) accounts];
    id v5 = [v4 _copyForEnumerating];

    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    id v6 = v5;
    id v7 = [v6 countByEnumeratingWithState:&v13 objects:v19 count:16];
    if (v7)
    {
      id v8 = v7;
      uint64_t v9 = *(void *)v14;
      while (2)
      {
        for (uint64_t i = 0; i != v8; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v14 != v9) {
            objc_enumerationMutation(v6);
          }
          long long v11 = *(void **)(*((void *)&v13 + 1) + 8 * i);
          if ((objc_msgSend(v11, "isAdHocAccount", (void)v13) & 1) == 0
            && [v11 isRegistered]
            && [v11 isEnabled])
          {
            uint64_t v12 = +[IMRGLog registration];
            if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138412290;
              id v18 = v11;
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "We picked %@ to re-register", buf, 0xCu);
            }

            [v11 registerAccount];
            goto LABEL_21;
          }
        }
        id v8 = [v6 countByEnumeratingWithState:&v13 objects:v19 count:16];
        if (v8) {
          continue;
        }
        break;
      }
    }
LABEL_21:
  }
}

void sub_1001600F4(uint64_t a1)
{
  if (!+[IDSRegistrationController systemSupportsPhoneNumberRegistration])
  {
    unsigned int v2 = [*(id *)(a1 + 32) userDefaults];
    unsigned __int8 v3 = [v2 appBoolForKey:@"GDRRequestMadeForRelayRepair"];

    if ((v3 & 1) == 0)
    {
      uint64_t v39 = a1;
      BOOL v4 = +[IDSDServiceController sharedInstance];
      uint64_t v5 = [v4 serviceWithIdentifier:@"com.apple.madrid"];

      id v6 = +[IDSDServiceController sharedInstance];
      uint64_t v7 = [v6 serviceWithIdentifier:@"com.apple.ess"];

      unsigned int v38 = (void *)v5;
      id v8 = [*(id *)(a1 + 32) accountsOnService:v5];
      __int16 v37 = (void *)v7;
      uint64_t v36 = [*(id *)(a1 + 32) accountsOnService:v7];
      long long v52 = 0u;
      long long v53 = 0u;
      long long v54 = 0u;
      long long v55 = 0u;
      id v9 = v8;
      id v10 = [v9 countByEnumeratingWithState:&v52 objects:v61 count:16];
      if (v10)
      {
        id v11 = v10;
        uint64_t v12 = *(void *)v53;
        do
        {
          for (uint64_t i = 0; i != v11; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v53 != v12) {
              objc_enumerationMutation(v9);
            }
            long long v14 = *(void **)(*((void *)&v52 + 1) + 8 * i);
            if ([v14 accountType] == 1)
            {
              long long v15 = [v14 unprefixedURIStringsFromRegistration];
              long long v48 = 0u;
              long long v49 = 0u;
              long long v50 = 0u;
              long long v51 = 0u;
              id v16 = v15;
              CFStringRef v17 = (char *)[v16 countByEnumeratingWithState:&v48 objects:v60 count:16];
              if (v17)
              {
                id v18 = v17;
                uint64_t v19 = *(void *)v49;
                while (2)
                {
                  for (j = 0; j != v18; ++j)
                  {
                    if (*(void *)v49 != v19) {
                      objc_enumerationMutation(v16);
                    }
                    if (IMStringIsPhoneNumber())
                    {
                      CFStringRef v21 = +[IMRGLog registration];
                      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)buf = 138412290;
                        id v59 = v14;
                        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "We found a phone number alias on the iMessage account, triggering GDR request for %@", buf, 0xCu);
                      }

                      [*(id *)(a1 + 32) issueGetDependentRequestForAccount:v14];
                      goto LABEL_21;
                    }
                  }
                  id v18 = (char *)[v16 countByEnumeratingWithState:&v48 objects:v60 count:16];
                  if (v18) {
                    continue;
                  }
                  break;
                }
              }
LABEL_21:
            }
          }
          id v11 = [v9 countByEnumeratingWithState:&v52 objects:v61 count:16];
        }
        while (v11);
      }

      long long v46 = 0u;
      long long v47 = 0u;
      long long v44 = 0u;
      long long v45 = 0u;
      id v22 = v36;
      id v23 = [v22 countByEnumeratingWithState:&v44 objects:v57 count:16];
      if (v23)
      {
        id v24 = v23;
        uint64_t v25 = *(void *)v45;
        do
        {
          for (k = 0; k != v24; k = (char *)k + 1)
          {
            if (*(void *)v45 != v25) {
              objc_enumerationMutation(v22);
            }
            __int16 v27 = *(void **)(*((void *)&v44 + 1) + 8 * (void)k);
            if ([v27 accountType] == 1)
            {
              CFStringRef v28 = [v27 unprefixedURIStringsFromRegistration];
              long long v40 = 0u;
              long long v41 = 0u;
              long long v42 = 0u;
              long long v43 = 0u;
              id v29 = v28;
              unsigned int v30 = (char *)[v29 countByEnumeratingWithState:&v40 objects:v56 count:16];
              if (v30)
              {
                __int16 v31 = v30;
                uint64_t v32 = *(void *)v41;
                while (2)
                {
                  for (m = 0; m != v31; ++m)
                  {
                    if (*(void *)v41 != v32) {
                      objc_enumerationMutation(v29);
                    }
                    if (IMStringIsPhoneNumber())
                    {
                      id v34 = +[IMRGLog registration];
                      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)buf = 138412290;
                        id v59 = v27;
                        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "We found a phone number alias on the FaceTime account, triggering GDR request for %@", buf, 0xCu);
                      }

                      a1 = v39;
                      [*(id *)(v39 + 32) issueGetDependentRequestForAccount:v27];
                      goto LABEL_42;
                    }
                  }
                  __int16 v31 = (char *)[v29 countByEnumeratingWithState:&v40 objects:v56 count:16];
                  a1 = v39;
                  if (v31) {
                    continue;
                  }
                  break;
                }
              }
LABEL_42:
            }
          }
          id v24 = [v22 countByEnumeratingWithState:&v44 objects:v57 count:16];
        }
        while (v24);
      }
    }
  }
  __int16 v35 = [*(id *)(a1 + 32) userDefaults];
  [v35 setAppBool:1 forKey:@"GDRRequestMadeForRelayRepair"];
}

void sub_10016080C(id a1)
{
  id v1 = +[IDSDaemon sharedInstance];
  [v1 _cleanUpOutgoingMessageDatabaseAndClearStatementCache];
}

void sub_100163154(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46)
{
}

void sub_10016319C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, uint64_t a7, char a8)
{
  uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8);
  if (*(unsigned char *)(v8 + 24)) {
    char v9 = a6;
  }
  else {
    char v9 = 0;
  }
  *(unsigned char *)(v8 + 24) = v9;
  uint64_t v10 = *(void *)(*(void *)(a1 + 48) + 8);
  if (*(unsigned char *)(v10 + 24)) {
    char v11 = a8;
  }
  else {
    char v11 = 0;
  }
  *(unsigned char *)(v10 + 24) = v11;
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

uint64_t sub_1001631D4(void *a1)
{
  uint64_t result = a1[4];
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, void, void, void, void, void, void, void))(result + 16))(result, 0, 0, 0, 0, *(unsigned __int8 *)(*(void *)(a1[5] + 8) + 24), 0, *(unsigned __int8 *)(*(void *)(a1[6] + 8) + 24), 0);
  }
  return result;
}

void sub_100163940(uint64_t a1)
{
  if ([*(id *)(a1 + 32) isLoading])
  {
    unsigned int v2 = +[IMRGLog registration];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v11) = 0;
      unsigned __int8 v3 = "Waiting on accounts to load, the account controller isn't ready yet";
      BOOL v4 = v2;
      uint32_t v5 = 2;
LABEL_7:
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v3, (uint8_t *)&v11, v5);
    }
  }
  else
  {
    [*(id *)(a1 + 32) _updateDeviceProperties];
    [*(id *)(a1 + 32) _kickRemoteCacheWipe];
    if ([*(id *)(a1 + 32) hasForcedReRegistered]) {
      return;
    }
    id v6 = [*(id *)(a1 + 32) userDefaults];
    uint64_t v7 = +[NSNumber numberWithLongLong:sub_10015F4AC()];
    [v6 setAppValue:v7 forKey:@"ReRegisteredForDevices"];

    uint64_t v8 = [*(id *)(a1 + 32) userDefaults];
    char v9 = _IDSServiceDictionaryRepresentableHash();
    [v8 setAppValue:v9 forKey:@"ReRegisteredForDevicesHash"];

    uint64_t v10 = [*(id *)(a1 + 32) userDefaults];
    [v10 setAppBool:0 forKey:@"ReRegisterForAliasRepair"];

    unsigned int v2 = +[IMRGLog registration];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 134217984;
      uint64_t v12 = sub_10015F4AC();
      unsigned __int8 v3 = "Re-registered succesfully, setting force re-register version to %llu";
      BOOL v4 = v2;
      uint32_t v5 = 12;
      goto LABEL_7;
    }
  }
}

id sub_100165DF4(uint64_t a1)
{
  return [*(id *)(a1 + 32) saveDevicePropertiesWithOldKeys:*(void *)(a1 + 40)];
}

void sub_100165E00(uint64_t a1, void *a2, void *a3)
{
  id v6 = a2;
  uint32_t v5 = [a3 objectForKey:IDSDevicePropertyNSUUID];
  if (v6 && v5) {
    [*(id *)(a1 + 32) setObject:v5 forKey:v6];
  }
}

void sub_1001661C8(uint64_t a1)
{
  unsigned int v2 = +[IMRGLog registrationAuthKit];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    if (*(unsigned char *)(a1 + 48)) {
      CFStringRef v5 = @"YES";
    }
    else {
      CFStringRef v5 = @"NO";
    }
    int v7 = 138412802;
    uint64_t v8 = v3;
    __int16 v9 = 2048;
    uint64_t v10 = v4;
    __int16 v11 = 2112;
    CFStringRef v12 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Updating AuthKit for DSID: %@, AKAppleIDServiceType: %ld and inUse: %@", (uint8_t *)&v7, 0x20u);
  }

  id v6 = objc_alloc_init((Class)IMWeakLinkClass());
  [v6 setAppleIDWithDSID:*(void *)(a1 + 32) inUse:*(unsigned __int8 *)(a1 + 48) forService:*(void *)(a1 + 40)];
}

void sub_100166544(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0xCu);
}

void sub_100166564(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, a5, 0xCu);
}

void sub_100166DF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100166E0C(uint64_t result, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  if (*(void *)(result + 32) == a2)
  {
    *(void *)(*(void *)(*(void *)(result + 40) + 8) + 24) = a3;
    *a4 = 1;
  }
  return result;
}

uint64_t sub_100166E34(uint64_t result, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  if (*(void *)(result + 32) == a2)
  {
    *(void *)(*(void *)(*(void *)(result + 40) + 8) + 24) = a3;
    *a4 = 1;
  }
  return result;
}

uint64_t sub_1001670A8(uint64_t a1, _DWORD **a2)
{
  [*(id *)(a1 + 32) packetizationHeadroom];
  IDSLinkPacketBufferAddBufferStart();
  **a2 = 1467207418;
  kdebug_trace();
  uint64_t v4 = *(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 32) + 40) + 16);

  return v4();
}

uint64_t sub_100167294(uint64_t a1, _DWORD **a2)
{
  uint64_t v4 = +[IDSFoundationLog Multiplexer];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "listener read callback!", v6, 2u);
  }

  [*(id *)(a1 + 32) packetizationHeadroom];
  IDSLinkPacketBufferAddBufferStart();
  **a2 = 1467207418;
  kdebug_trace();
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 32) + 40) + 16))();
}

void sub_10016775C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 144), 8);
  _Unwind_Resume(a1);
}

id sub_100167794(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  id result = [a2 unsignedIntValue];
  if (result == *(_DWORD *)(a1 + 40))
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a3;
    *a4 = 1;
  }
  return result;
}

void sub_1001679A4(id a1)
{
  qword_100A4A858 = objc_alloc_init(IDSLocalMultiplexer);

  _objc_release_x1();
}

id sub_1001684C0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = [*(id *)(*(void *)(a1 + 32) + 152) objectForKeyedSubscript:*(void *)(a1 + 40)];
  id v4 = [v3 tryConsumePacketBuffer:a2];

  uint64_t v5 = +[IDSFoundationLog Multiplexer];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v6 = @"NO";
    if (v4) {
      CFStringRef v6 = @"YES";
    }
    int v8 = 138412290;
    CFStringRef v9 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "incoming packet consumed? %@", (uint8_t *)&v8, 0xCu);
  }

  return v4;
}

uint64_t sub_10016A2B0(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), 0, *(void *)(a1 + 32));
}

uint64_t sub_10016B440(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 32) + 40) + 16))();
}

uint64_t sub_10016B454(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 32) + 40) + 16))();
}

uint64_t sub_10016B468(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 32) + 40) + 16))();
}

uint64_t sub_10016B47C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 32) + 40) + 16))();
}

uint64_t sub_10016B490(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 32) + 40) + 16))();
}

uint64_t sub_10016C310(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 32) + 32) + 16))();
}

uint64_t sub_10016C328(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 32) + 32) + 16))();
}

uint64_t sub_10016C838(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 32) + 40) + 16))();
}

id sub_10016C84C(uint64_t a1)
{
  return [*(id *)(a1 + 32) _sendConnectionCheckRequest];
}

id sub_10016CDA4(uint64_t a1)
{
  return [*(id *)(a1 + 32) _sendNominateRequest];
}

id sub_10016D04C(uint64_t a1)
{
  return [*(id *)(a1 + 32) _startConnectionEcho:*(double *)(a1 + 40)];
}

uint64_t sub_10016D5C8()
{
  return IDSTransportThreadAddBlock();
}

id sub_10016D638(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _handleEchoTimer];
}

BOOL sub_10016DC64(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 1);
  if (v2 != *(unsigned __int8 *)(a2 + 1)) {
    return v2 == 30;
  }
  if (v2 != 2) {
    return 0;
  }
  unsigned int v3 = bswap32(*(_DWORD *)(a1 + 4));
  BOOL v4 = HIWORD(v3) == 49320 || (v3 & 0xFF000000) == 167772160;
  if (v4 || (v3 & 0xFFF00000) == -1408237568) {
    return 0;
  }
  unsigned int v6 = bswap32(*(_DWORD *)(a2 + 4));
  BOOL result = 1;
  if ((v6 & 0xFFFF0000) != 0xC0A80000 && (v6 & 0xFF000000) != 0xA000000 && (v6 & 0xFFF00000) != 0xAC100000) {
    return 0;
  }
  return result;
}

uint64_t sub_10016EF70(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 32) + 40) + 16))();
}

id sub_1001707CC(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _processStunBindingRequest:*(void *)(a1 + 40) fromDevice:*(void *)(a1 + 48) localIfIndex:*(unsigned int *)(a1 + 320) localAddress:a1 + 56 remmoteAddress:a1 + 184 arrivalTime:*(double *)(a1 + 312)];
}

void sub_1001712A8(id a1)
{
  if (!qword_100A4A860)
  {
    memset(v6, 170, sizeof(v6));
    ids_monotonic_time();
    double v2 = v1;
    gettimeofday(&v6[1], 0);
    ids_monotonic_time();
    double v4 = v3;
    gettimeofday(v6, 0);
    ids_monotonic_time();
    if (v5 - v4 < v4 - v2)
    {
      v6[1] = v6[0];
      double v2 = v4;
    }
    qword_100A4A860 = vcvtd_n_u64_f64((double)v6[1].tv_sec + (double)v6[1].tv_usec * 0.000001 + 2208988800.0 - v2, 0x20uLL);
  }
}

void sub_100171CB0(uint64_t a1)
{
  id v4 = [*(id *)(a1 + 32) _metricContainerForMetricType:2555929];
  if (v4)
  {
    double v2 = *(void **)(a1 + 32);
    double v3 = [*(id *)(a1 + 40) awdRepresentation];
    [v2 _submitAWDMetric:v3 withContainer:v4];
  }
}

void sub_100171E08(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2555931];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setRegistrationType:*(unsigned int *)(a1 + 56)];
    [v2 setServiceIdentifier:*(void *)(a1 + 40)];
    [v2 setWasSuccessful:*(unsigned __int8 *)(a1 + 60)];
    [v2 setRegistrationError:*(unsigned int *)(a1 + 48)];
    [*(id *)(a1 + 32) _submitAWDMetric:v2 withContainer:v3];
  }
}

void sub_100171F10(id a1)
{
  qword_100A4A878 = objc_alloc_init(IDSWPLinkManager);

  _objc_release_x1();
}

id sub_100172468(uint64_t a1)
{
  return _[*(id *)(a1 + 32) setDelegateOnMainQueue:*(void *)(a1 + 40)];
}

id sub_100172690(uint64_t a1)
{
  return [*(id *)(a1 + 32) manager:*(void *)(a1 + 40) cbuuidDidConnect:*(void *)(a1 + 48) isAlwaysConnected:1];
}

void sub_10017275C(uint64_t a1)
{
  id v2 = *(void **)(*(void *)(a1 + 32) + 72);
  if (!v2)
  {
    id v3 = objc_alloc_init((Class)NSMutableSet);
    uint64_t v4 = *(void *)(a1 + 32);
    double v5 = *(void **)(v4 + 72);
    *(void *)(v4 + 72) = v3;

    id v2 = *(void **)(*(void *)(a1 + 32) + 72);
  }
  [v2 addObject:*(void *)(a1 + 40)];
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  id v6 = *(id *)(*(void *)(a1 + 32) + 88);
  id v7 = [v6 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v12;
    do
    {
      uint64_t v10 = 0;
      do
      {
        if (*(void *)v12 != v9) {
          objc_enumerationMutation(v6);
        }
        objc_msgSend(*(id *)(*((void *)&v11 + 1) + 8 * (void)v10), "manager:cbuuidDidConnect:isAlwaysConnected:", *(void *)(a1 + 32), *(void *)(a1 + 40), 1, (void)v11);
        uint64_t v10 = (char *)v10 + 1;
      }
      while (v8 != v10);
      id v8 = [v6 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }
    while (v8);
  }
}

id sub_100174E90(uint64_t a1)
{
  return _[*(id *)(a1 + 32) connectOnMainQueueToPeer:*(void *)(a1 + 40)];
}

id sub_100175384(uint64_t a1)
{
  return _[*(id *)(a1 + 32) disconnectOnMainQueueFromPeer:*(void *)(a1 + 40)];
}

id sub_100175464(void *a1)
{
  id v2 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = a1[5];
    *(_DWORD *)buf = 138412546;
    uint64_t v7 = v3;
    __int16 v8 = 2112;
    uint64_t v9 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "removing a link %@ with linkID %@", buf, 0x16u);
  }

  id result = (id)os_log_shim_legacy_logging_enabled();
  if (result)
  {
    id result = (id)_IDSShouldLogTransport();
    if (result)
    {
      _IDSLogTransport();
      id result = (id)_IDSShouldLog();
      if (result) {
        id result = (id)_IDSLogV();
      }
    }
  }
  if (a1[5]) {
    return objc_msgSend(*(id *)(a1[6] + 48), "removeObjectForKey:");
  }
  return result;
}

void sub_1001758AC(uint64_t a1, void *a2)
{
  id v3 = a2;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  id v4 = *(id *)(*(void *)(a1 + 32) + 88);
  id v5 = [v4 countByEnumeratingWithState:&v9 objects:v13 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v10;
    do
    {
      __int16 v8 = 0;
      do
      {
        if (*(void *)v10 != v7) {
          objc_enumerationMutation(v4);
        }
        objc_msgSend(*(id *)(*((void *)&v9 + 1) + 8 * (void)v8), "manager:cbuuidDidDisconnect:", *(void *)(a1 + 32), v3, (void)v9);
        __int16 v8 = (char *)v8 + 1;
      }
      while (v6 != v8);
      id v6 = [v4 countByEnumeratingWithState:&v9 objects:v13 count:16];
    }
    while (v6);
  }
}

void sub_100175B20(uint64_t a1)
{
  id v2 = +[IDSDaemon sharedInstance];
  id v3 = [v2 broadcasterForEntitlement:kIDSContinuityEntitlement messageContext:0];

  id v4 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v5 = *(void *)(a1 + 32);
    if (v5 > 3) {
      id v6 = "UnexpectedState";
    }
    else {
      id v6 = (&off_100984150)[v5];
    }
    *(_DWORD *)buf = 136315138;
    long long v13 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "calling continuityDidUpdateStateToState:%s", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
  {
    unint64_t v7 = *(void *)(a1 + 32);
    __int16 v8 = v7 > 3 ? "UnexpectedState" : (&off_100984150)[v7];
    long long v11 = v8;
    _IDSLogTransport();
    if (_IDSShouldLog())
    {
      unint64_t v9 = *(void *)(a1 + 32);
      if (v9 > 3) {
        long long v10 = "UnexpectedState";
      }
      else {
        long long v10 = (&off_100984150)[v9];
      }
      long long v11 = (void *)v10;
      _IDSLogV();
    }
  }
  objc_msgSend(v3, "continuityDidUpdateStateToState:", *(void *)(a1 + 32), v11);
}

id sub_100178964(id a1, id a2)
{
  id v2 = a2;
  id v3 = [objc_alloc((Class)NSUUID) initWithUUIDString:v2];

  return v3;
}

void sub_100179B4C(void *a1)
{
  id v2 = +[IMRGLog registration];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = a1[5];
    uint64_t v5 = a1[6];
    uint64_t v6 = a1[7];
    int v7 = 138413058;
    uint64_t v8 = v3;
    __int16 v9 = 2112;
    uint64_t v10 = v4;
    __int16 v11 = 2112;
    uint64_t v12 = v5;
    __int16 v13 = 2112;
    uint64_t v14 = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Finished capturing AutoBugCapture diagnostics for encryption failure { context: %@, ECError: %@, legacyError: %@, secondaryError: %@ }", (uint8_t *)&v7, 0x2Au);
  }
}

void sub_100179C1C(void *a1)
{
  id v2 = +[IMRGLog registration];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = a1[5];
    uint64_t v5 = a1[6];
    uint64_t v6 = a1[7];
    int v7 = 138413058;
    uint64_t v8 = v3;
    __int16 v9 = 2112;
    uint64_t v10 = v4;
    __int16 v11 = 2112;
    uint64_t v12 = v5;
    __int16 v13 = 2112;
    uint64_t v14 = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Finished capturing AutoBugCapture diagnostics for encryption failure { context: %@, ECError: %@, legacyError: %@, secondaryError: %@ }", (uint8_t *)&v7, 0x2Au);
  }
}

void sub_100179CEC(uint64_t a1)
{
  id v2 = +[IDSFoundationLog delivery_oversized];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    int v5 = 138412546;
    uint64_t v6 = v3;
    __int16 v7 = 2112;
    uint64_t v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "GUID %@ Encryption information:\n%@", (uint8_t *)&v5, 0x16u);
  }
}

id sub_10017A588()
{
  if (qword_100A4A888 != -1) {
    dispatch_once(&qword_100A4A888, &stru_100984270);
  }
  uint64_t v0 = (void *)qword_100A4A880;

  return v0;
}

void sub_10017A5DC(uint64_t a1, void *a2)
{
  id v10 = a2;
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = [*(id *)(a1 + 40) localObject];
  int v5 = [v3 broadcasterForLocalObject:v4 messageContext:*(void *)(a1 + 40)];

  if (v5)
  {
    id v6 = [v10 state];
    if (v6 == (id)1)
    {
      uint64_t v9 = *(void *)(a1 + 48);
      __int16 v7 = [v10 error];
      [v5 didAuthenticatePhoneWithAuthenticationCertificateData:0 requestUUID:v9 error:v7];
    }
    else
    {
      if (v6) {
        goto LABEL_7;
      }
      __int16 v7 = [v10 value];
      uint64_t v8 = [v7 dataRepresentation];
      [v5 didAuthenticatePhoneWithAuthenticationCertificateData:v8 requestUUID:*(void *)(a1 + 48) error:0];
    }
  }
LABEL_7:
}

void sub_10017A9D0(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void **)(a1 + 32);
  int v5 = [*(id *)(a1 + 40) localObject];
  id v6 = [v4 broadcasterForLocalObject:v5 messageContext:*(void *)(a1 + 40)];

  if (v6)
  {
    id v7 = [v3 state];
    if (v7 == (id)1)
    {
      __int16 v33 = [v3 error];
      __int16 v37 = +[IMRGLog sms];
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        long long v51 = v33;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "Failed to generate phone authentication signature {error: %@}", buf, 0xCu);
      }

      [v6 didGeneratePhoneAuthenticationSignature:0 nonce:0 certificates:0 labelIDs:0 inputData:0 requestUUID:*(void *)(a1 + 56) error:v33];
      goto LABEL_34;
    }
    if (!v7)
    {
      uint64_t v8 = sub_10017A588();
      id v9 = [v8 phoneAuthenticationCertificatePublicKey];

      id v10 = sub_10017A588();
      id v11 = [v10 phoneAuthenticationCertificatePrivateKey];

      id v12 = 0;
      long long v42 = v6;
      id v13 = 0;
      if (v9 && v11)
      {
        uint64_t v48 = 0;
        uint64_t v49 = 0;
        _FTGenerateNonceAndSignatureFromPayload();
        id v12 = 0;
        id v13 = 0;
      }
      id v38 = v9;
      uint64_t v39 = v13;
      id v40 = v12;
      uint64_t v41 = a1;
      id v14 = objc_alloc_init((Class)NSMutableArray);
      id v15 = objc_alloc_init((Class)NSMutableArray);
      id v43 = v3;
      id v16 = [v3 value];
      long long v44 = 0u;
      long long v45 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      id v17 = [v16 countByEnumeratingWithState:&v44 objects:v58 count:16];
      if (v17)
      {
        id v18 = v17;
        uint64_t v19 = *(void *)v45;
        do
        {
          for (uint64_t i = 0; i != v18; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v45 != v19) {
              objc_enumerationMutation(v16);
            }
            CFStringRef v21 = *(void **)(*((void *)&v44 + 1) + 8 * i);
            uint64_t v22 = [v21 authenticationCertificate];
            if (v22)
            {
              id v23 = (void *)v22;
              id v24 = [v21 phoneUser];
              uint64_t v25 = [v24 uniqueIdentifier];

              if (v25)
              {
                id v26 = [v21 authenticationCertificate];
                __int16 v27 = [v26 dataRepresentation];
                [v14 addObject:v27];

                CFStringRef v28 = [v21 phoneUser];
                id v29 = [v28 uniqueIdentifier];
                [v15 addObject:v29];
              }
            }
          }
          id v18 = [v16 countByEnumeratingWithState:&v44 objects:v58 count:16];
        }
        while (v18);
      }
      ct_green_tea_logger_create_static();
      unsigned int v30 = getCTGreenTeaOsLogHandle();
      __int16 v31 = v30;
      if (v30 && os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_INFO, "Transmitting phone number", buf, 2u);
      }

      uint64_t v32 = +[IMRGLog sms];
      id v6 = v42;
      __int16 v33 = v40;
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v34 = @"NO";
        if (v38) {
          CFStringRef v35 = @"YES";
        }
        else {
          CFStringRef v35 = @"NO";
        }
        *(_DWORD *)buf = 138413058;
        long long v51 = v16;
        if (v40) {
          CFStringRef v36 = @"YES";
        }
        else {
          CFStringRef v36 = @"NO";
        }
        CFStringRef v53 = v35;
        __int16 v52 = 2112;
        __int16 v54 = 2112;
        if (v39) {
          CFStringRef v34 = @"YES";
        }
        CFStringRef v55 = v36;
        __int16 v56 = 2112;
        CFStringRef v57 = v34;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "Generated phone authentication signature {phoneUserAuthCerts: %@, publicKey: %@, nonce: %@, signature: %@}", buf, 0x2Au);
      }

      [v42 didGeneratePhoneAuthenticationSignature:v39 nonce:v40 certificates:v14 labelIDs:v15 inputData:*(void *)(v41 + 48) requestUUID:*(void *)(v41 + 56) error:0];
      id v3 = v43;
LABEL_34:
    }
  }
}

BOOL sub_10017BA84(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [*(id *)(a1 + 32) integerValue];
  if (v4 == (id)1)
  {
    uint64_t v5 = 0;
  }
  else
  {
    if (v4 != (id)2)
    {
      BOOL v6 = 0;
      goto LABEL_7;
    }
    uint64_t v5 = 1;
  }
  BOOL v6 = [v3 slot] == (id)v5;
LABEL_7:

  return v6;
}

void sub_10017BAF0(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v6 = a2;
  id v7 = [v6 responseStatus];
  uint64_t v8 = [v6 responseCarrierToken];
  id v9 = [v6 responseMessage];

  id v10 = +[IMRGLog sms];
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    id v11 = +[NSNumber numberWithInteger:a4];
    CFStringRef v12 = @"YES";
    *(_DWORD *)buf = 138413058;
    id v24 = v11;
    if (!v8) {
      CFStringRef v12 = @"NO";
    }
    __int16 v25 = 2112;
    id v26 = v7;
    __int16 v27 = 2112;
    CFStringRef v28 = v9;
    __int16 v29 = 2112;
    CFStringRef v30 = v12;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Carrier token response received {resultCode: %@, serverStatus: %@, serverErrorDetail: %@, carrierToken: %@}", buf, 0x2Au);
  }
  if (v8)
  {
    id v13 = 0;
  }
  else
  {
    id v14 = +[NSNumber numberWithInteger:a4];
    id v15 = +[NSString stringWithFormat:@"Failed to request carrier token from IDS server {resultCode: %@, serverStatus: %@, serverErrorDetail: %@}", v14, v7, v9];

    uint64_t v16 = IDSRegistrationControlErrorDomain;
    NSErrorUserInfoKey v21 = NSDebugDescriptionErrorKey;
    uint64_t v22 = v15;
    id v17 = +[NSDictionary dictionaryWithObjects:&v22 forKeys:&v21 count:1];
    id v13 = +[NSError errorWithDomain:v16 code:1 userInfo:v17];
  }
  id v18 = *(void **)(a1 + 32);
  uint64_t v19 = [*(id *)(a1 + 40) localObject];
  long long v20 = [v18 broadcasterForLocalObject:v19 messageContext:*(void *)(a1 + 40)];

  [v20 didRequestCarrierTokenString:v8 requestUUID:*(void *)(a1 + 48) error:v13];
}

void sub_10017C3F8(id a1)
{
  double v1 = [IDSPhoneUserRegistry alloc];
  im_primary_base_queue();
  id v7 = (id)objc_claimAutoreleasedReturnValue();
  id v2 = +[IDSDaemon sharedInstance];
  id v3 = [v2 registrationConductor];
  id v4 = [v3 userStore];
  uint64_t v5 = [(IDSPhoneUserRegistry *)v1 initWithQueue:v7 userStore:v4];
  id v6 = (void *)qword_100A4A880;
  qword_100A4A880 = (uint64_t)v5;
}

void sub_10017C4AC(id a1)
{
  id v1 = objc_alloc_init((Class)+[FTMessageDelivery HTTPMessageDeliveryClass]);
  id v2 = (void *)qword_100A4A890;
  qword_100A4A890 = (uint64_t)v1;

  [(id)qword_100A4A890 setLogToRegistration:1];
  id v3 = (void *)qword_100A4A890;
  id v4 = +[IDSRegistrationRequestTracker sharedInstance];
  [v3 addRequestObserver:v4];
}

void sub_10017CFCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
}

id sub_10017D088(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (*(unsigned char *)(a1 + 48) && [*(id *)(a1 + 32) containsObject:v3])
  {
    id v4 = +[IMRGLog accountCleanup];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 32);
      int v8 = 138412546;
      id v9 = v3;
      __int16 v10 = 2112;
      uint64_t v11 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "  Found bad vetted alias, it was my phone number: %@ => %@", (uint8_t *)&v8, 0x16u);
    }

    id v6 = 0;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
  }
  else
  {
    id v6 = v3;
  }

  return v6;
}

id sub_10017D1A4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 objectForKey:kIDSServiceDefaultsAliasKey];
  uint64_t v5 = [v3 objectForKey:kIDSServiceDefaultsAliasStatusKey];
  int v6 = [v5 intValue];

  unsigned int v7 = [v4 isEqualToIgnoringCase:kIDSServiceDefaultsSentinelAlias];
  unsigned int v8 = v7;
  uint64_t v9 = *(void *)(*(void *)(a1 + 64) + 8);
  if (*(unsigned char *)(v9 + 24)) {
    BOOL v10 = 1;
  }
  else {
    BOOL v10 = v7 == 0;
  }
  if (v10)
  {
    if (*(unsigned char *)(v9 + 24) && ((v7 ^ 1) & 1) == 0)
    {
LABEL_16:
      *(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) = 1;
      [*(id *)(a1 + 32) addObject:v4];
      id v15 = 0;
      goto LABEL_29;
    }
  }
  else
  {
    *(unsigned char *)(v9 + 24) = 1;
  }
  uint64_t v11 = [*(id *)(a1 + 40) service];
  if ([v11 shouldRegisterUsingDSHandle]) {
    unsigned int v12 = [v4 _appearsToBeDSID];
  }
  else {
    unsigned int v12 = 0;
  }

  int v13 = v8 | v12;
  if (v6 >= 2)
  {
    if ((([*(id *)(a1 + 48) containsObject:v4] | v13) & 1) == 0) {
      goto LABEL_13;
    }
  }
  else if ((v13 & 1) == 0)
  {
LABEL_13:
    id v14 = +[IMRGLog accountCleanup];
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      int v21 = 138412290;
      uint64_t v22 = v4;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "  Found unvalidated/failed alias: %@", (uint8_t *)&v21, 0xCu);
    }

    goto LABEL_16;
  }
  uint64_t v16 = IMStripFormattingFromAddress();
  if ([v16 isEqualToIgnoringCase:v4])
  {
    if (*(unsigned char *)(a1 + 80) && [*(id *)(a1 + 56) containsObject:v16])
    {
      id v17 = +[IMRGLog accountCleanup];
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        id v18 = *(void **)(a1 + 56);
        int v21 = 138412546;
        uint64_t v22 = v16;
        __int16 v23 = 2112;
        id v24 = v18;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "  Found bad alias, it was my phone number: %@ => %@", (uint8_t *)&v21, 0x16u);
      }

      *(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) = 1;
      [*(id *)(a1 + 32) addObject:v4];
      id v15 = 0;
    }
    else
    {
      id v15 = v3;
    }
  }
  else
  {
    uint64_t v19 = +[IMRGLog accountCleanup];
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      int v21 = 138412546;
      uint64_t v22 = v4;
      __int16 v23 = 2112;
      id v24 = v16;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "  Found bad alias: %@ => %@", (uint8_t *)&v21, 0x16u);
    }

    id v15 = 0;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) = 1;
  }

LABEL_29:

  return v15;
}

id sub_10017D4D4(id a1, id a2)
{
  id v2 = a2;
  if ([v2 isEqualToIgnoringCase:kIDSServiceDefaultsSentinelAlias]) {
    id v3 = 0;
  }
  else {
    id v3 = v2;
  }

  return v3;
}

id sub_10017D534(id a1, id a2)
{
  id v2 = [a2 objectForKey:kIDSServiceDefaultsAliasKey];
  if ([v2 length]
    && ([v2 isEqualToIgnoringCase:kIDSServiceDefaultsSentinelAlias] & 1) == 0)
  {
    if (IMStringIsPhoneNumber())
    {
      IMCanonicalizeFormattedString();
      id v4 = (id)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      id v4 = v2;
    }
    id v3 = v4;
  }
  else
  {
    id v3 = 0;
  }

  return v3;
}

BOOL sub_10017D5D4(id a1, IDSPseudonym *a2)
{
  id v2 = [(IDSPseudonym *)a2 properties];
  unsigned __int8 v3 = [v2 hasBeenExpiredForAtLeast:IDSPseudonymMaxExpiredAgeInSeconds];

  return v3;
}

void sub_10017D988(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10017D9D8(id a1, IDSDAccount *a2)
{
}

void sub_10017D9E0(uint64_t a1, void *a2, void *a3, void *a4, void *a5, uint64_t a6, void *a7)
{
  id v12 = a2;
  id v35 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a7;
  uint64_t v16 = (id *)(a1 + 32);
  id WeakRetained = objc_loadWeakRetained(v16);

  if (WeakRetained)
  {
    id v18 = objc_loadWeakRetained(v16);
    uint64_t v19 = v18;
    if (!v12 || !v14) {
      goto LABEL_22;
    }
    long long v20 = [v18 service];
    int v21 = [v20 queryService];
    if ([v14 isEqualToString:v21])
    {
      uint64_t v22 = [v19 aliases];
      __int16 v23 = [v12 unprefixedURI];
      unsigned int v24 = [v22 containsObject:v23];

      if (v24)
      {
        __int16 v25 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138413058;
          *(void *)&uint8_t buf[4] = v14;
          *(_WORD *)&unsigned char buf[12] = 2112;
          *(void *)&buf[14] = v12;
          *(_WORD *)&buf[22] = 2112;
          CFStringRef v42 = @"YES";
          __int16 v43 = 2112;
          id v44 = v15;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Received IDQueryCompletedWithFromURI for service %@ fromURI %@ isRelevant? %@  errors %@", buf, 0x2Au);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
        {
          CFStringRef v33 = @"YES";
          id v34 = v15;
          id v31 = v14;
          id v32 = v12;
          _IDSLogV();
        }
        *(void *)buf = 0;
        *(void *)&uint8_t buf[8] = buf;
        *(void *)&uint8_t buf[16] = 0x2020000000;
        LOBYTE(v42) = 0;
        uint64_t v37 = 0;
        id v38 = &v37;
        uint64_t v39 = 0x2020000000;
        char v40 = 0;
        v36[0] = _NSConcreteStackBlock;
        v36[1] = 3221225472;
        v36[2] = sub_10017DDAC;
        v36[3] = &unk_100984408;
        v36[4] = v19;
        void v36[5] = &v37;
        v36[6] = buf;
        objc_msgSend(v15, "enumerateKeysAndObjectsUsingBlock:", v36, v31, v32, v33, v34, v35);
        if (*(unsigned char *)(*(void *)&buf[8] + 24))
        {
          id v26 = +[IDSRegistrationReasonTracker sharedInstance];
          __int16 v27 = [v19 userUniqueIdentifier];
          [v26 setPNRReason:11 forUserUniqueIdentifier:v27];

          CFStringRef v28 = [v19 primaryAccount];
          __int16 v29 = v28;
          if (v28) {
            [v28 reIdentify];
          }
          else {
            [v19 reIdentify];
          }
        }
        else
        {
          if (!*((unsigned char *)v38 + 24))
          {
LABEL_21:
            _Block_object_dispose(&v37, 8);
            _Block_object_dispose(buf, 8);
            goto LABEL_22;
          }
          CFStringRef v30 = [v19 primaryAccount];
          __int16 v29 = v30;
          if (v30) {
            [v30 reregister];
          }
          else {
            [v19 reregister];
          }
        }

        goto LABEL_21;
      }
    }
    else
    {
    }
LABEL_22:
  }
}

void sub_10017DD5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va1, a13);
  va_start(va, a13);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10017DDAC(uint64_t a1, uint64_t a2, void *a3, BOOL *a4)
{
  id v6 = a3;
  unsigned int v7 = [v6 domain];
  unsigned int v8 = [v7 isEqualToString:FTErrorDomain];

  if (!v8) {
    goto LABEL_25;
  }
  uint64_t v9 = [v6 userInfo];
  BOOL v10 = [v9 objectForKey:off_100A42350];

  if (!v10 || ![*(id *)(a1 + 32) isDeviceRegistered]) {
    goto LABEL_24;
  }
  id v11 = [v6 code];
  if (v11 == (id)6003)
  {
    uint64_t v14 = +[IMRGLog registration];
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      unsigned int v31 = [v6 code];
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Query failed with %d  -  Warning", buf, 8u);
    }

    id v15 = +[IMLockdownManager sharedInstance];
    if ([v15 isInternalInstall])
    {
      char v16 = IMGetCachedDomainBoolForKey();

      uint64_t v17 = (void *)qword_100A4A8A0;
      if (!qword_100A4A8A0)
      {
LABEL_22:
        if (v16) {
          goto LABEL_24;
        }
LABEL_23:
        id v20 = objc_alloc_init((Class)NSDate);
        int v21 = (void *)qword_100A4A8A0;
        qword_100A4A8A0 = (uint64_t)v20;

        uint64_t v22 = +[NSBundle bundleForClass:objc_opt_class()];
        __int16 v29 = IMLocalizedStringFromTableInBundle();
        __int16 v23 = IMLocalizedStringFromTableInBundle();
        unsigned int v24 = IMLocalizedStringFromTableInBundle();
        __int16 v25 = IMLocalizedStringFromTableInBundle();
        id v26 = +[IMUserNotification userNotificationWithIdentifier:@"ServerAlerts" title:v29 message:v23 defaultButton:v25 alternateButton:v24 otherButton:0];
        [v26 setShowInLockScreen:1];
        __int16 v27 = +[IMUserNotificationCenter sharedInstance];
        [v27 addUserNotification:v26 listener:0 completionHandler:&stru_1009843E0];

        goto LABEL_24;
      }
    }
    else
    {

      uint64_t v17 = (void *)qword_100A4A8A0;
      if (!qword_100A4A8A0) {
        goto LABEL_23;
      }
      char v16 = 0;
    }
    [v17 timeIntervalSinceNow];
    if (fabs(v19) <= 3600.0) {
      goto LABEL_24;
    }
    goto LABEL_22;
  }
  if (v11 == (id)6005)
  {
    uint64_t v18 = +[IMRGLog registration];
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      unsigned int v31 = [v6 code];
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Query failed; refreshing credentials {error code: %d}",
        buf,
        8u);
    }

    uint64_t v13 = *(void *)(a1 + 48);
    goto LABEL_18;
  }
  if (v11 == (id)6006)
  {
    id v12 = +[IMRGLog registration];
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      unsigned int v31 = [v6 code];
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Query failed; re-registering {error code: %d}",
        buf,
        8u);
    }

    uint64_t v13 = *(void *)(a1 + 40);
LABEL_18:
    *(unsigned char *)(*(void *)(v13 + 8) + 24) = 1;
  }
LABEL_24:

LABEL_25:
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24)) {
    BOOL v28 = 1;
  }
  else {
    BOOL v28 = *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) != 0;
  }
  *a4 = v28;
}

void sub_10017E1F8(id a1, IMUserNotification *a2)
{
  if ([(IMUserNotification *)a2 response] == (id)1)
  {
    id v3 = [objc_alloc((Class)NSURL) initWithString:@"prefs:root=General&path=DATE_AND_TIME"];
    if (v3)
    {
      id v2 = [(id)IMWeakLinkClass() defaultWorkspace];
      [v2 openSensitiveURL:v3 withOptions:0];
    }
  }
}

id sub_10017E624(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 objectForKey:kIDSServiceDefaultsAliasKey];
  if (([*(id *)(a1 + 32) shouldRegisterUsingDSHandle] & 1) != 0
    || ([v4 _appearsToBeDSID] & 1) == 0)
  {
    id v6 = [v3 mutableCopy];
    if ([v4 isEqualToIgnoringCase:kIDSServiceDefaultsSentinelAlias])
    {
      [v6 setObject:&__kCFBooleanFalse forKey:kIDSServiceDefaultsAliasIsUserVisibleKey];
    }
    else
    {
      unsigned int v7 = [*(id *)(a1 + 40) objectForKey:kIDSServiceDefaultsInvisibleAliasesKey];
      if ([v7 count]) {
        uint64_t v8 = [v7 containsObject:v4] ^ 1;
      }
      else {
        uint64_t v8 = 1;
      }
      uint64_t v9 = +[NSNumber numberWithBool:v8];
      [v6 setObject:v9 forKey:kIDSServiceDefaultsAliasIsUserVisibleKey];
    }
    if ([v3 isEqual:v6]) {
      id v10 = v3;
    }
    else {
      id v10 = [v6 copy];
    }
    uint64_t v5 = v10;
  }
  else
  {
    uint64_t v5 = 0;
  }

  return v5;
}

id sub_10018036C(id a1, id a2)
{
  return [a2 objectForKey:kIDSServiceDefaultsAliasKey];
}

id sub_100180450(id a1, NSString *a2)
{
  return [(NSString *)a2 _stripFZIDPrefix];
}

id sub_1001825F8(uint64_t a1, void *a2)
{
  id v3 = [a2 userUniqueIdentifier];
  id v4 = [*(id *)(a1 + 32) userUniqueIdentifier];
  id v5 = [v3 isEqualToString:v4];

  return v5;
}

void sub_100184198(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSDaemon sharedInstance];
  id v5 = [v3 service];
  id v6 = [v5 pushTopic];
  unsigned int v7 = [v4 broadcasterForTopic:v6 messageContext:*(void *)(a1 + 32)];

  if (IMShouldLog() && v7)
  {
    uint64_t v8 = +[IMRGLog registration];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v11 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Broadcasting registration status info changes", v11, 2u);
    }
  }
  uint64_t v9 = [v3 uniqueID];
  if ([*(id *)(a1 + 40) isNull]) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = *(void *)(a1 + 40);
  }
  [v7 account:v9 registrationStatusInfoChanged:v10];
}

void sub_1001842D0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSDaemon sharedInstance];
  id v5 = [v3 service];
  id v6 = [v5 pushTopic];
  unsigned int v7 = [v4 broadcasterForTopic:v6 messageContext:*(void *)(a1 + 32)];

  if (IMShouldLog() && v7)
  {
    uint64_t v8 = +[IMRGLog registration];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v11 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Broadcasting aliases changes", v11, 2u);
    }
  }
  uint64_t v9 = [v3 uniqueID];
  if ([*(id *)(a1 + 40) isNull]) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = *(void *)(a1 + 40);
  }
  [v7 account:v9 aliasesChanged:v10];
}

void sub_100184408(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSDaemon sharedInstance];
  id v5 = [v3 service];
  id v6 = [v5 pushTopic];
  unsigned int v7 = [v4 registrationBroadcasterForTopic:v6 messageContext:*(void *)(a1 + 32)];

  if (IMShouldLog() && v7)
  {
    uint64_t v8 = +[IMRGLog registration];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v11 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Broadcasting vetted aliases changes", v11, 2u);
    }
  }
  uint64_t v9 = [v3 uniqueID];
  if ([*(id *)(a1 + 40) isNull]) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = *(void *)(a1 + 40);
  }
  [v7 account:v9 vettedAliasesChanged:v10];
}

void sub_100184540(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSDaemon sharedInstance];
  id v5 = [v3 service];
  id v6 = [v5 pushTopic];
  unsigned int v7 = [v4 registrationBroadcasterForTopic:v6 messageContext:*(void *)(a1 + 32)];

  if (IMShouldLog() && v7)
  {
    uint64_t v8 = +[IMRGLog registration];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v11 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Broadcasting profile changes", v11, 2u);
    }
  }
  uint64_t v9 = [v3 uniqueID];
  if ([*(id *)(a1 + 40) isNull]) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = *(void *)(a1 + 40);
  }
  [v7 account:v9 profileChanged:v10];
}

void sub_100184678(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSDaemon sharedInstance];
  id v5 = [v3 service];
  id v6 = [v5 pushTopic];
  unsigned int v7 = [v4 registrationBroadcasterForTopic:v6 messageContext:*(void *)(a1 + 32)];

  if (IMShouldLog() && v7)
  {
    uint64_t v8 = +[IMRGLog registration];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v11 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Broadcasting loginAs changes", v11, 2u);
    }
  }
  uint64_t v9 = [v3 uniqueID];
  if ([*(id *)(a1 + 40) isNull]) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = *(void *)(a1 + 40);
  }
  [v7 account:v9 loginChanged:v10];
}

void sub_1001847B0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSDaemon sharedInstance];
  id v5 = [v3 service];
  id v6 = [v5 pushTopic];
  unsigned int v7 = [v4 registrationBroadcasterForTopic:v6 messageContext:*(void *)(a1 + 32)];

  if (IMShouldLog() && v7)
  {
    uint64_t v8 = +[IMRGLog registration];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v11 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Broadcasting displayName changes", v11, 2u);
    }
  }
  uint64_t v9 = [v3 uniqueID];
  if ([*(id *)(a1 + 40) isNull]) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = *(void *)(a1 + 40);
  }
  [v7 account:v9 displayNameChanged:v10];
}

void sub_1001848E8(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSDaemon sharedInstance];
  id v5 = [v3 service];
  id v6 = [v5 pushTopic];
  unsigned int v7 = [v4 broadcasterForTopic:v6 messageContext:*(void *)(a1 + 32)];

  if (IMShouldLog() && v7)
  {
    uint64_t v8 = +[IMRGLog registration];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v11 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Broadcasting pseudonym changes", v11, 2u);
    }
  }
  uint64_t v9 = [v3 uniqueID];
  if ([*(id *)(a1 + 40) isNull]) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = *(void *)(a1 + 40);
  }
  [v7 account:v9 pseudonymsChanged:v10];
}

void sub_10018522C(uint64_t a1, void *a2)
{
  id v8 = a2;
  id v4 = *(void **)(a1 + 32);
  if (!v4
    || ([v8 service],
        id v5 = objc_claimAutoreleasedReturnValue(),
        [v5 identifier],
        id v6 = objc_claimAutoreleasedReturnValue(),
        unsigned int v7 = [v4 containsObject:v6],
        v6,
        v5,
        v7))
  {
    [v8 _writeAccountDefaults:*(void *)(a1 + 40) force:*(unsigned __int8 *)(a1 + 48)];
  }
}

void sub_10018579C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IMRGLog registration];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = [v3 uniqueID];
    int v10 = 138412290;
    id v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Calling out to linked account: %@", (uint8_t *)&v10, 0xCu);
  }
  id v6 = [v3 service];
  unsigned int v7 = [v6 identifier];

  id v8 = [v3 service];
  uint64_t v9 = [v8 pushTopic];

  if (v7) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), kIDSServiceDefaultsServiceNameKey, v7);
  }
  if (v9) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), kIDSServiceDefaultsPushTopicKey, v9);
  }
  [v3 _updateAccountWithAccountInfo:*(void *)(a1 + 32)];
}

id sub_100185F34(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) addObject:a2];
}

void sub_100186AD8(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = (__CFDictionary *)[objc_alloc((Class)NSMutableDictionary) initWithDictionary:*(void *)(a1 + 32)];
    id v5 = [*(id *)(a1 + 40) service];
    id v6 = [v5 identifier];

    if (v6) {
      CFDictionarySetValue(v4, IDSDevicePropertyService, v6);
    }

    unsigned int v7 = [*(id *)(a1 + 40) uniqueID];
    [v3 account:v7 localDeviceAdded:v4];

    id v8 = [*(id *)(a1 + 40) service];
    uint64_t v9 = [v8 identifier];
    if (([v9 isEqualToIgnoringCase:@"com.apple.private.alloy.health.sync.classc"] & 1) == 0)
    {
      int v10 = [*(id *)(a1 + 40) service];
      id v11 = [v10 identifier];
      if (([v11 isEqualToIgnoringCase:@"com.apple.private.alloy.fitnessfriends.icloud"] & 1) == 0)
      {
        uint64_t v14 = [*(id *)(a1 + 40) service];
        id v15 = [v14 identifier];
        unsigned __int8 v16 = [v15 isEqualToIgnoringCase:@"com.apple.private.alloy.fitnessfriends.imessage"];

        if ((v16 & 1) == 0)
        {
LABEL_11:

          goto LABEL_12;
        }
LABEL_8:
        id v12 = +[IMRGLog healthDebugging];
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v13 = [*(id *)(a1 + 40) smallDescription];
          int v17 = 138412546;
          id v18 = v3;
          __int16 v19 = 2112;
          id v20 = v13;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Broadcaster for localDeviceAdded %@ on account %@", (uint8_t *)&v17, 0x16u);
        }
        goto LABEL_11;
      }
    }
    goto LABEL_8;
  }
LABEL_12:
}

void sub_100186E50(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (!v3) {
    goto LABEL_9;
  }
  id v4 = [*(id *)(a1 + 32) uniqueID];
  [v3 account:v4 localDeviceRemoved:*(void *)(a1 + 40)];

  id v5 = [*(id *)(a1 + 32) service];
  id v6 = [v5 identifier];
  if (([v6 isEqualToIgnoringCase:@"com.apple.private.alloy.health.sync.classc"] & 1) == 0)
  {
    unsigned int v7 = [*(id *)(a1 + 32) service];
    id v8 = [v7 identifier];
    if (([v8 isEqualToIgnoringCase:@"com.apple.private.alloy.fitnessfriends.icloud"] & 1) == 0)
    {
      id v11 = [*(id *)(a1 + 32) service];
      id v12 = [v11 identifier];
      unsigned __int8 v13 = [v12 isEqualToIgnoringCase:@"com.apple.private.alloy.fitnessfriends.imessage"];

      if ((v13 & 1) == 0) {
        goto LABEL_9;
      }
      goto LABEL_6;
    }
  }
LABEL_6:
  uint64_t v9 = +[IMRGLog healthDebugging];
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = [*(id *)(a1 + 32) smallDescription];
    int v14 = 138412546;
    id v15 = v3;
    __int16 v16 = 2112;
    int v17 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Broadcaster for localDeviceRemoved %@ on account %@", (uint8_t *)&v14, 0x16u);
  }
LABEL_9:
}

void sub_1001870D8(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [*(id *)(a1 + 32) uniqueID];
  id v5 = [*(id *)(a1 + 32) dependentRegistrations];
  [v3 account:v4 dependentDevicesUpdated:v5];

  id v6 = [*(id *)(a1 + 32) service];
  unsigned int v7 = [v6 identifier];
  if (([v7 isEqualToIgnoringCase:@"com.apple.private.alloy.health.sync.classc"] & 1) == 0)
  {
    id v8 = [*(id *)(a1 + 32) service];
    uint64_t v9 = [v8 identifier];
    if (([v9 isEqualToIgnoringCase:@"com.apple.private.alloy.fitnessfriends.icloud"] & 1) == 0)
    {
      id v12 = [*(id *)(a1 + 32) service];
      unsigned __int8 v13 = [v12 identifier];
      unsigned __int8 v14 = [v13 isEqualToIgnoringCase:@"com.apple.private.alloy.fitnessfriends.imessage"];

      if ((v14 & 1) == 0) {
        goto LABEL_8;
      }
      goto LABEL_5;
    }
  }
LABEL_5:
  int v10 = +[IMRGLog healthDebugging];
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    id v11 = [*(id *)(a1 + 32) smallDescription];
    int v15 = 138412546;
    id v16 = v3;
    __int16 v17 = 2112;
    id v18 = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Broadcaster for didUpdatePairedDevice %@ on account %@", (uint8_t *)&v15, 0x16u);
  }
LABEL_8:
}

void sub_1001873F0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IMRGLog registration];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = [*(id *)(a1 + 32) service];
    id v6 = [v5 pushTopic];
    int v9 = 138412290;
    int v10 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Notifying %@ delegate of protocol changes to device", (uint8_t *)&v9, 0xCu);
  }
  unsigned int v7 = [*(id *)(a1 + 32) uniqueID];
  id v8 = [*(id *)(a1 + 32) dependentRegistrations];
  [v3 account:v7 dependentDevicesUpdated:v8];
}

void sub_100187C20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100187C40(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100187C50(uint64_t a1)
{
}

void sub_100187C58(uint64_t a1)
{
  if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40))
  {
    id v2 = [*(id *)(a1 + 32) daemonClients];
    [v2 removeObject:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40)];
  }
}

void sub_100188738(id a1, NSArray *a2, NSError *a3)
{
  id v3 = a2;
  id v65 = objc_alloc_init((Class)IDSQualifiedContactsMetric);
  id v4 = +[IDSPublicIdentityCache sharedInstance];
  id v64 = [v4 recentURIsWithinTimeInterval:IDSServiceNameiMessage forService:0 error:2592000.0];

  id v5 = [(NSArray *)v3 __imArrayByFilteringWithBlock:&stru_100984548];
  id v66 = v3;
  id v6 = [(NSArray *)v3 __imArrayByFilteringWithBlock:&stru_100984568];
  long long v87 = 0u;
  long long v88 = 0u;
  long long v89 = 0u;
  long long v90 = 0u;
  id v7 = v5;
  id v8 = [v7 countByEnumeratingWithState:&v87 objects:v99 count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = 0;
    uint64_t v11 = *(void *)v88;
    do
    {
      for (uint64_t i = 0; i != v9; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v88 != v11) {
          objc_enumerationMutation(v7);
        }
        unsigned __int8 v13 = objc_msgSend(*(id *)(*((void *)&v87 + 1) + 8 * i), "uri", v64);
        unsigned __int8 v14 = [v13 tokenFreeURI];
        id v15 = [v14 IDSIDType];

        if (!v15) {
          ++v10;
        }
      }
      id v9 = [v7 countByEnumeratingWithState:&v87 objects:v99 count:16];
    }
    while (v9);
  }
  else
  {
    uint64_t v10 = 0;
  }

  long long v85 = 0u;
  long long v86 = 0u;
  long long v83 = 0u;
  long long v84 = 0u;
  id v16 = v6;
  id v17 = [v16 countByEnumeratingWithState:&v83 objects:v98 count:16];
  if (v17)
  {
    id v18 = v17;
    uint64_t v19 = 0;
    uint64_t v20 = *(void *)v84;
    do
    {
      for (j = 0; j != v18; j = (char *)j + 1)
      {
        if (*(void *)v84 != v20) {
          objc_enumerationMutation(v16);
        }
        uint64_t v22 = objc_msgSend(*(id *)(*((void *)&v83 + 1) + 8 * (void)j), "uri", v64);
        __int16 v23 = [v22 tokenFreeURI];
        id v24 = [v23 IDSIDType];

        if (!v24) {
          ++v19;
        }
      }
      id v18 = [v16 countByEnumeratingWithState:&v83 objects:v98 count:16];
    }
    while (v18);
  }
  else
  {
    uint64_t v19 = 0;
  }
  id v67 = v16;

  __int16 v25 = +[IDSDaemon sharedInstance];
  id v26 = [v25 persistenceManager];

  __int16 v27 = +[IDSDAccountController sharedInstance];
  BOOL v28 = [v27 registeredLocalURIsOnService:IDSServiceNameiMessageLite];

  long long v81 = 0u;
  long long v82 = 0u;
  long long v79 = 0u;
  long long v80 = 0u;
  id obj = v7;
  id v29 = [obj countByEnumeratingWithState:&v79 objects:v97 count:16];
  if (v29)
  {
    id v30 = v29;
    uint64_t v31 = 0;
    uint64_t v32 = *(void *)v80;
    do
    {
      for (k = 0; k != v30; k = (char *)k + 1)
      {
        if (*(void *)v80 != v32) {
          objc_enumerationMutation(obj);
        }
        id v34 = objc_msgSend(*(id *)(*((void *)&v79 + 1) + 8 * (void)k), "uri", v64);
        unsigned int v35 = [v26 hasUsableSenderKeyFor:v34 fromAny:v28];

        v31 += v35;
      }
      id v30 = [obj countByEnumeratingWithState:&v79 objects:v97 count:16];
    }
    while (v30);
  }
  else
  {
    uint64_t v31 = 0;
  }
  id v70 = v26;

  long long v77 = 0u;
  long long v78 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  id v68 = v67;
  id v36 = [v68 countByEnumeratingWithState:&v75 objects:v96 count:16];
  if (v36)
  {
    id v37 = v36;
    uint64_t v38 = 0;
    uint64_t v39 = *(void *)v76;
    do
    {
      for (m = 0; m != v37; m = (char *)m + 1)
      {
        if (*(void *)v76 != v39) {
          objc_enumerationMutation(v68);
        }
        uint64_t v41 = objc_msgSend(*(id *)(*((void *)&v75 + 1) + 8 * (void)m), "uri", v64);
        unsigned int v42 = [v70 hasUsableSenderKeyFor:v41 fromAny:v28];

        v38 += v42;
      }
      id v37 = [v68 countByEnumeratingWithState:&v75 objects:v96 count:16];
    }
    while (v37);
  }
  else
  {
    uint64_t v38 = 0;
  }

  long long v73 = 0u;
  long long v74 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  id v43 = v64;
  id v44 = [v43 countByEnumeratingWithState:&v71 objects:v95 count:16];
  if (v44)
  {
    id v45 = v44;
    uint64_t v46 = 0;
    uint64_t v47 = *(void *)v72;
    do
    {
      for (n = 0; n != v45; n = (char *)n + 1)
      {
        if (*(void *)v72 != v47) {
          objc_enumerationMutation(v43);
        }
        v46 += objc_msgSend(v70, "hasUsableSenderKeyFor:fromAny:", *(void *)(*((void *)&v71 + 1) + 8 * (void)n), v28, v64);
      }
      id v45 = [v43 countByEnumeratingWithState:&v71 objects:v95 count:16];
    }
    while (v45);
  }
  else
  {
    uint64_t v46 = 0;
  }

  uint64_t v49 = +[NSNumber numberWithInteger:v10];
  [v65 setQualifiedEmergencyHandles:v49];

  long long v50 = +[NSNumber numberWithInteger:v31];
  [v65 setQualifiedEmergencyHandlesIML:v50];

  long long v51 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [obj count]);
  [v65 setEmergencyHandlesCount:v51];

  __int16 v52 = +[NSNumber numberWithInteger:v19 + v10];
  [v65 setQualifiedPrimaryHandles:v52];

  CFStringRef v53 = +[NSNumber numberWithInteger:v38 + v31];
  [v65 setQualifiedPrimaryHandlesIML:v53];

  __int16 v54 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", (char *)[obj count] + (void)objc_msgSend(v68, "count"));
  [v65 setPrimaryHandlesCount:v54];

  CFStringRef v55 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [v68 count]);
  [v65 setFamilyHandlesCount:v55];

  __int16 v56 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [v43 count]);
  [v65 setQualifiedHandlesCount:v56];

  CFStringRef v57 = +[NSNumber numberWithInteger:v46];
  [v65 setQualifiedHandlesIML:v57];

  id v58 = objc_alloc_init(IDSContactsUtilities);
  id v59 = +[NSNumber numberWithInteger:[(IDSContactsUtilities *)v58 countOfHandles]];
  [v65 setHandlesCount:v59];

  uint64_t v60 = v70;
  id v61 = [v70 lastQualifiedContactsMetric];
  if (([v61 isEqual:v65] & 1) == 0)
  {
    id v62 = +[IDSFoundationLog xpc];
    if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      id v92 = v65;
      __int16 v93 = 2112;
      uint64_t v94 = v61;
      _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "Capturing metric - current IDSQualifiedContactsMetric: %@ differs from last metric: %@", buf, 0x16u);
    }

    uint64_t v63 = +[IDSCoreAnalyticsLogger defaultLogger];
    [v63 logMetric:v65];

    uint64_t v60 = v70;
    [v70 updateQualifiedContactsCountWithMetric:v65];
  }
}

BOOL sub_100188EF0(id a1, IDSOffGridContactInfo *a2)
{
  return [(IDSOffGridContactInfo *)a2 type] == (id)1;
}

BOOL sub_100188F14(id a1, IDSOffGridContactInfo *a2)
{
  return [(IDSOffGridContactInfo *)a2 type] == (id)2;
}

void sub_100189870(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) accountRepair];
  [v2 repairAccounts];

  id v3 = [*(id *)(a1 + 32) deviceCertificationRepair];
  [v3 recertifyDeviceIfNeeded];

  id v4 = [*(id *)(a1 + 32) stewieCoordinator];
  [v4 checkComponentsAtStartup];
}

id sub_1001898F0(uint64_t a1)
{
  return [*(id *)(a1 + 32) kickMissedTemporaryAlerts];
}

id sub_1001898F8(uint64_t a1)
{
  return _[*(id *)(a1 + 32) checkRestorationState];
}

void sub_10018A204(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) deviceCertificationRepair];
  [v2 recertifyDeviceIfNeeded];

  id v3 = [*(id *)(a1 + 32) accountRepair];
  [v3 repairAccounts];

  id v4 = [*(id *)(a1 + 32) accountRepair];
  [v4 setupPhoneNumberRepairTimer];

  id v5 = [*(id *)(a1 + 32) SIMPhoneUserSynchronizer];
  [v5 verifyState];

  id v6 = [*(id *)(a1 + 32) stewieCoordinator];
  [v6 checkComponentsAtStartup];
}

void sub_10018A324(uint64_t a1)
{
  id v1 = [*(id *)(a1 + 32) accountSync];
  [v1 noteShouldSynchronizePreferredAccount];
}

void sub_10018A4E8(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) SIMResponder];
  [v2 handleRegistrationStateChanged:*(unsigned __int8 *)(a1 + 40)];

  id v3 = [*(id *)(a1 + 32) heartbeatCenter];
  [v3 noteRegistrationStateChanged];

  if (*(unsigned char *)(a1 + 40))
  {
    id v4 = [*(id *)(a1 + 32) userAccountSynchronizer];
    [v4 synchronize];
  }
}

void sub_10018A60C(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) accountRepair];
  [v2 setupPhoneNumberRepairTimer];

  id v3 = [*(id *)(a1 + 32) userAccountSynchronizer];
  [v3 synchronize];
}

void sub_10018A74C(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) registrationController];
  [v2 SIM:*(void *)(a1 + 40) didDeactivateWithInfo:*(void *)(a1 + 48)];
}

void sub_10018A7B4(id a1, id a2)
{
}

void sub_10018A914(id a1)
{
  qword_100A4A8B0 = objc_alloc_init(IDSSMSRegistrationCenter);

  _objc_release_x1();
}

id sub_10018B3D8(id a1, IDSRegistration *a2)
{
  return [(IDSRegistration *)a2 userUniqueIdentifier];
}

void sub_10018BCB0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = +[IMRGLog sms];
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(a1 + 32);
    int v9 = 138412802;
    uint64_t v10 = v8;
    __int16 v11 = 2112;
    id v12 = v5;
    __int16 v13 = 2112;
    id v14 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Finished capturing AutoBugCapture diagnostics for high registration attempt rate { context: %@, sessionID: %@, error: %@ }", (uint8_t *)&v9, 0x20u);
  }
}

void sub_10018C218()
{
}

void sub_10018C884()
{
}

void sub_10018CA24(_Unwind_Exception *a1)
{
}

void sub_10018D014(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = +[IMRGLog sms];
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(a1 + 32);
    int v9 = 138412802;
    uint64_t v10 = v8;
    __int16 v11 = 2112;
    id v12 = v5;
    __int16 v13 = 2112;
    id v14 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Finished capturing AutoBugCapture diagnostics for registration failure { context: %@, sessionID: %@, error: %@ }", (uint8_t *)&v9, 0x20u);
  }
}

void sub_10018D1F0(uint64_t a1)
{
  id v2 = +[IMLockdownManager sharedInstance];
  if ([v2 isInternalInstall])
  {
    int v3 = IMGetCachedDomainBoolForKey();

    if (v3)
    {
      id v4 = +[IMRGLog sms];
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Suppressing non-zero-rated SMS notification due to presence of internal deafult -- allowing SMS", buf, 2u);
      }

      (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
      return;
    }
  }
  else
  {
  }
  id v5 = [*(id *)(a1 + 32) systemMonitor];
  unsigned __int8 v6 = [v5 isSetup];

  if (v6)
  {
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    id v7 = *(id *)(*(void *)(a1 + 32) + 16);
    id v8 = [v7 countByEnumeratingWithState:&v32 objects:v36 count:16];
    if (v8)
    {
      id v9 = v8;
      int v10 = 0;
      uint64_t v11 = *(void *)v33;
      do
      {
        for (uint64_t i = 0; i != v9; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v33 != v11) {
            objc_enumerationMutation(v7);
          }
          __int16 v13 = [*(id *)(*((void *)&v32 + 1) + 8 * i) serviceType];
          if ((IDSIsFaceTimeRegistrationServiceType() & 1) == 0 && (IDSIsCallingRegistrationServiceType() & 1) == 0) {
            v10 |= IDSIsiMessageRegistrationServiceType();
          }
        }
        id v9 = [v7 countByEnumeratingWithState:&v32 objects:v36 count:16];
      }
      while (v9);
    }

    int v21 = +[NSBundle bundleForClass:objc_opt_class()];
    uint64_t v22 = IMLocalizedStringFromTableInBundle();
    __int16 v23 = IMLocalizedStringFromTableInBundle();
    id v24 = IMLocalizedStringFromTableInBundle();
    __int16 v25 = IMLocalizedStringFromTableInBundle();
    id v26 = +[IMUserNotification userNotificationWithIdentifier:@"Registration" title:v22 message:v23 defaultButton:v24 defaultButtonStyle:0 alternateButton:v25 alternateButtonStyle:0 otherButton:0 otherButtonStyle:0];
    [v26 setRequireUserInteraction:1];
    __int16 v27 = +[IMUserNotificationCenter sharedInstance];
    v29[0] = _NSConcreteStackBlock;
    v29[1] = 3221225472;
    v29[2] = sub_10018D918;
    v29[3] = &unk_100984630;
    BOOL v28 = *(void **)(a1 + 40);
    v29[4] = *(void *)(a1 + 32);
    id v30 = v28;
    id v31 = *(id *)(a1 + 48);
    [v27 addUserNotification:v26 listener:0 completionHandler:v29];

    goto LABEL_27;
  }
  id v14 = +[IMRGLog sms];
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 138412290;
    uint64_t v38 = v15;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Unable to post SMS alert during buddy, deferring until device is setup {CTPNR: %@}", buf, 0xCu);
  }

  id v16 = [*(id *)(a1 + 32) CTPNRByConsentCompletion];

  if (!v16)
  {
    id v17 = +[NSMapTable strongToStrongObjectsMapTable];
    [*(id *)(a1 + 32) setCTPNRByConsentCompletion:v17];
  }
  id v18 = [*(id *)(a1 + 32) CTPNRByConsentCompletion];
  id v19 = objc_retainBlock(*(id *)(a1 + 48));
  [v18 setObject:v19 forKey:*(void *)(a1 + 40)];

  uint64_t v20 = [*(id *)(a1 + 32) restoreMonitor];
  LOBYTE(v19) = [v20 hasActionForTarget:*(void *)(a1 + 32)];

  if ((v19 & 1) == 0)
  {
    int v21 = [*(id *)(a1 + 32) restoreMonitor];
    [v21 addTarget:*(void *)(a1 + 32) actionBlock:&stru_100984608];
LABEL_27:
  }
}

void sub_10018D86C(id a1, id a2)
{
  id v2 = a2;
  int v3 = im_primary_queue();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10018D910;
  block[3] = &unk_10097E4D0;
  id v6 = v2;
  id v4 = v2;
  dispatch_async(v3, block);
}

id sub_10018D910(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _postPendingConsentAlerts];
}

uint64_t sub_10018D918(uint64_t a1, void *a2)
{
  id v3 = [a2 response];
  id v4 = +[IMRGLog sms];
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v5)
    {
      *(_WORD *)id v8 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "User notification denied Phone Number Validation delivery, not sending", v8, 2u);
    }

    id v6 = *(void **)(*(void *)(a1 + 32) + 48);
    id v4 = [*(id *)(a1 + 40) uniqueIdentifier];
    [v6 addObject:v4];
  }
  else if (v5)
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "User notification allowed Phone Number Validation delivery, sending", buf, 2u);
  }

  return (*(uint64_t (**)(void))(*(void *)(a1 + 48) + 16))();
}

void sub_10018DD7C(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x16u);
}

void sub_10018EAD0(id a1)
{
  qword_100A4A8D0 = objc_alloc_init(IDSRestrictions);

  _objc_release_x1();
}

void sub_10018EB0C(id a1)
{
  [(id)qword_100A4A8D0 setShouldPostNotifications:0];
  [(id)qword_100A4A8D0 _updateParentalSettings];
  id v1 = (void *)qword_100A4A8D0;

  [v1 setShouldPostNotifications:1];
}

void sub_10018F8BC(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = +[IMRGLog registration];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v5 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 134218242;
    uint64_t v14 = v5;
    __int16 v15 = 2112;
    uint64_t v16 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Broadcasting restriction change for service {restrictionReason: %lu, service: %@", buf, 0x16u);
  }

  id v7 = +[IDSDaemon sharedInstance];
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_10018FA48;
  void v12[3] = &unk_1009846C0;
  uint64_t v8 = *(void *)(a1 + 40);
  void v12[4] = *(void *)(a1 + 32);
  void v12[5] = v8;
  uint64_t v9 = kIDSRegistrationEntitlement;
  uint64_t v10 = kIDSListenerCapConsumesLaunchOnDemandRestrictionUpdates;
  id v11 = objc_alloc_init((Class)IMMessageContext);
  [v7 enqueueBroadcast:v12 forTopic:v3 entitlement:v9 command:0 capabilities:v10 messageContext:v11];
}

id sub_10018FA48(uint64_t a1, void *a2)
{
  return _[a2 service:*(void *)(a1 + 32) restrictionReasonChanged:*(void *)(a1 + 40)];
}

id sub_10018FFD8(uint64_t a1)
{
  [*(id *)(a1 + 32) _updateParentalSettingsIfFTInstallChanged];
  id v2 = *(void **)(a1 + 32);

  return [v2 _updateParentalSettingsIfMessagesInstallChanged];
}

id sub_10019009C(uint64_t a1)
{
  [*(id *)(a1 + 32) _updateParentalSettingsIfFTInstallChanged];
  id v2 = *(void **)(a1 + 32);

  return [v2 _updateParentalSettingsIfMessagesInstallChanged];
}

void sub_100190264(uint64_t a1)
{
  [*(id *)(a1 + 32) doubleValue];
  double v3 = v2;
  [*(id *)(a1 + 40) doubleValue];
  unint64_t v5 = llround((v3 - v4) * 1000.0);
  uint64_t v6 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a1 + 72);
    uint64_t v8 = *(void *)(a1 + 48);
    uint64_t v9 = *(void *)(a1 + 56);
    *(_DWORD *)buf = 134218754;
    uint64_t v17 = v7;
    __int16 v18 = 2048;
    unint64_t v19 = v5;
    __int16 v20 = 2112;
    uint64_t v21 = v8;
    __int16 v22 = 2112;
    uint64_t v23 = v9;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "AWDIDSGenericConnectionSetupDurationEvent linkType:%lu, setupDuration:%llums connectionType:%@ errorCode:%@", buf, 0x2Au);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      uint64_t v14 = *(void *)(a1 + 48);
      uint64_t v15 = *(void *)(a1 + 56);
      uint64_t v12 = *(void *)(a1 + 72);
      unint64_t v13 = v5;
      _IDSLogTransport();
      if (_IDSShouldLog())
      {
        uint64_t v14 = *(void *)(a1 + 48);
        uint64_t v15 = *(void *)(a1 + 56);
        uint64_t v12 = *(void *)(a1 + 72);
        unint64_t v13 = v5;
        _IDSLogV();
      }
    }
  }
  uint64_t v10 = objc_msgSend(*(id *)(a1 + 64), "_metricContainerForMetricType:", 2555934, v12, v13, v14, v15);
  if (v10)
  {
    id v11 = objc_alloc_init((Class)IMWeakLinkClass());
    [v11 setLinkType:*(unsigned int *)(a1 + 72)];
    [v11 setConnectionSetupDuration:v5];
    objc_msgSend(v11, "setConnectionType:", objc_msgSend(*(id *)(a1 + 48), "integerValue"));
    [v11 setSuccess:*(unsigned __int8 *)(a1 + 80)];
    objc_msgSend(v11, "setErrorCode:", objc_msgSend(*(id *)(a1 + 56), "integerValue"));
    [*(id *)(a1 + 64) _submitAWDMetric:v11 withContainer:v10];
  }
}

void sub_1001904A0(id a1)
{
  qword_100A4A8E0 = objc_alloc_init(IDSPairingManager);

  _objc_release_x1();
}

void sub_1001907E4(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (objc_opt_respondsToSelector()) {
    [v3 didAddPairedDevice:*(void *)(a1 + 32)];
  }
}

void sub_1001909D4(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (objc_opt_respondsToSelector()) {
    [v3 didRemovePairedDevice:*(void *)(a1 + 32)];
  }
}

id sub_100190AA0(uint64_t a1)
{
  double v2 = [*(id *)(a1 + 32) pairedDeviceRepository];
  id v3 = [v2 activePairedDevice];

  unsigned int v4 = [*(id *)(a1 + 32) isPaired];
  id result = [*(id *)(a1 + 32) _hasAllEncryptionKeys];
  if (v3 && (v4 & result & 1) == 0)
  {
    [*(id *)(a1 + 32) _requestPairedDeviceInfo];
    uint64_t v6 = *(void **)(a1 + 32);
    return [v6 _requestPairedDeviceInfoAfterDelay:15.5];
  }
  return result;
}

void sub_100190E24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100190E44(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100190E54(uint64_t a1)
{
}

void sub_100190E5C(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8);
  double v2 = *(void **)(v1 + 40);
  *(void *)(v1 + 40) = 0;
}

void sub_10019134C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (objc_opt_respondsToSelector()) {
    [v3 didUpdatePairedDevice:*(void *)(a1 + 32)];
  }
}

void sub_100193B5C(uint64_t a1)
{
  id v2 = +[IDSDevicePropertiesStateNotifier sharedInstance];
  [v2 updateStateForDeviceWithUniqueID:*(void *)(a1 + 32)];
}

void sub_100196170(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (objc_opt_respondsToSelector()) {
    [v3 didUpdatePairedDevice:*(void *)(a1 + 32)];
  }
}

void sub_1001969EC(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v4 = +[IMRGLog NRPairing];
  unint64_t v5 = v4;
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_100714A30((uint64_t)v3, a1, v5);
    }
  }
  else
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      uint64_t v6 = *(void *)(a1 + 40);
      int v15 = 138478083;
      uint64_t v16 = v6;
      __int16 v17 = 2113;
      uint64_t v18 = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Did register device with NRDeviceManager {nrDeviceIdentifier: %{private}@, cbuuid: %{private}@}", (uint8_t *)&v15, 0x16u);
    }

    if (*(unsigned char *)(a1 + 56))
    {
      uint64_t v8 = +[IMRGLog NRPairing];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = *(void *)(a1 + 32);
        int v15 = 138477827;
        uint64_t v16 = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Starting UTunPeer and NRDevice bridge for device with cbuuid: %{private}@}", (uint8_t *)&v15, 0xCu);
      }

      uint64_t v10 = +[IDSUTunDeliveryController sharedInstance];
      [v10 addConnectivityDelegate:*(void *)(a1 + 48)];

      id v11 = +[IDSUTunDeliveryController sharedInstance];
      uint64_t v12 = IDSDeviceDefaultPairedDeviceUniqueID;
      unint64_t v13 = [*(id *)(a1 + 32) UUIDString];
      [v11 addUTunPeerWithDeviceUniqueID:v12 btuuid:v13];

      uint64_t v14 = +[IDSUTunDeliveryController sharedInstance];
      [v14 startIdsNRDeviceBridgeAndPreferenceHandlerWithIdentifier:*(void *)(a1 + 32)];

      [*(id *)(a1 + 48) _requestPairedDeviceInfoAfterDelay:10.0];
    }
  }
}

void sub_100197870(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (objc_opt_respondsToSelector()) {
    [v3 didUpdatePairedDevice:*(void *)(a1 + 32)];
  }
}

void sub_1001978D0(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (objc_opt_respondsToSelector()) {
    [v3 didUpdateProtocolForPairedDevice:*(void *)(a1 + 32)];
  }
}

void sub_100197B28(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (objc_opt_respondsToSelector()) {
    [v3 didUpdatePairedDevice:*(void *)(a1 + 32)];
  }
}

id sub_1001981F0(uint64_t a1)
{
  id v2 = +[IMRGLog NRPairing];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v5 = 138477827;
    uint64_t v6 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Finished resetting communication -- Done {uniqueID: %{private}@}", (uint8_t *)&v5, 0xCu);
  }

  return [*(id *)(a1 + 40) _callPairedDeviceDidConnectBlocksForUniqueID:*(void *)(a1 + 48) withError:0];
}

uint64_t sub_100198410(uint64_t a1, uint64_t a2)
{
  return a2;
}

void sub_100198438(void *a1, uint64_t a2, uint64_t a3, const char *a4)
{
  _os_log_error_impl(a1, v4, OS_LOG_TYPE_ERROR, a4, v5, 0xCu);
}

void sub_1001984C0(id a1)
{
  qword_100A4A8F8 = objc_alloc_init(IDSGroupEncryptionController1);

  _objc_release_x1();
}

double sub_100198EB8(void *a1, double a2)
{
  id v3 = a1;
  if (v3)
  {
    unsigned int v4 = +[IDSServerBag sharedInstance];
    int v5 = [v4 objectForKey:v3];

    if (v5)
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        [v5 doubleValue];
        a2 = v6;
      }
    }
  }
  else
  {
    int v5 = 0;
  }

  return a2;
}

void sub_10019934C(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 28));
  id v2 = *(void **)(*(void *)(a1 + 32) + 360);
  id v3 = objc_retainBlock(*(id *)(a1 + 40));
  [v2 removeObject:v3];

  unsigned int v4 = (os_unfair_lock_s *)(*(void *)(a1 + 32) + 28);

  os_unfair_lock_unlock(v4);
}

void sub_100199674(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_10019968C(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  id result = [a2 isEqualToString:*(void *)(a1 + 32)];
  if (result)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
    *a4 = 1;
  }
  return result;
}

void sub_100199834(uint64_t a1, void *a2)
{
  id v3 = (os_unfair_lock_s *)(*(void *)(a1 + 32) + 28);
  id v4 = a2;
  os_unfair_lock_lock(v3);
  [v4 resetRemoteMasterKeyMaterialCacheAndCancelResetInterval];

  int v5 = (os_unfair_lock_s *)(*(void *)(a1 + 32) + 28);

  os_unfair_lock_unlock(v5);
}

void sub_100199AD0(uint64_t a1)
{
  id v2 = +[IDSFoundationLog RealTimeEncryptionController];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    uint64_t v22 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "setAccount: Add the registraion listener for account: %@", buf, 0xCu);
  }

  id v4 = +[IDSDAccountController sharedInstance];
  int v5 = [v4 accountWithUniqueID:*(void *)(a1 + 32)];

  id v6 = objc_alloc_init((Class)NSMutableSet);
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  id obj = [v5 registeredDevices];
  id v7 = [obj countByEnumeratingWithState:&v16 objects:v20 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v17;
    do
    {
      for (uint64_t i = 0; i != v8; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v17 != v9) {
          objc_enumerationMutation(obj);
        }
        id v11 = [*(id *)(*((void *)&v16 + 1) + 8 * i) pushToken];
        uint64_t v12 = [v5 service];
        unint64_t v13 = [v12 identifier];
        uint64_t v14 = +[IDSPushToken pushTokenWithData:v11 withServiceLoggingHint:v13];
        [v6 addObject:v14];
      }
      id v8 = [obj countByEnumeratingWithState:&v16 objects:v20 count:16];
    }
    while (v8);
  }

  [*(id *)(*(void *)(a1 + 40) + 240) setObject:v6 forKeyedSubscript:*(void *)(a1 + 32)];
  [v5 addRegistrationListener:*(void *)(a1 + 40)];
}

id sub_100199E94(uint64_t a1)
{
  id v2 = +[IDSFoundationLog RealTimeEncryptionController];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v7 = 138412290;
    uint64_t v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "setAccount: Remove the registraion listener for account: %@", (uint8_t *)&v7, 0xCu);
  }

  id v4 = +[IDSDAccountController sharedInstance];
  int v5 = [v4 accountWithUniqueID:*(void *)(a1 + 32)];
  [v5 removeRegistrationListener:*(void *)(a1 + 40)];

  return [*(id *)(*(void *)(a1 + 40) + 240) setObject:0 forKeyedSubscript:*(void *)(a1 + 32)];
}

void sub_10019B1DC(uint64_t a1)
{
  id v2 = +[IDSFoundationLog RealTimeEncryptionController_oversize];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = 136315651;
    int v5 = "IDSGroupEncryptionController1.m";
    __int16 v6 = 1024;
    int v7 = 398;
    __int16 v8 = 2113;
    uint64_t v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%s:%d %{private}@", (uint8_t *)&v4, 0x1Cu);
  }
}

void sub_10019B2B0(uint64_t a1)
{
  id v2 = +[IDSFoundationLog RealTimeEncryptionController_oversize];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = 136315651;
    int v5 = "IDSGroupEncryptionController1.m";
    __int16 v6 = 1024;
    int v7 = 573;
    __int16 v8 = 2113;
    uint64_t v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%s:%d %{private}@", (uint8_t *)&v4, 0x1Cu);
  }
}

void sub_10019B710(id *a1, void *a2)
{
  id v15 = a2;
  uint64_t v3 = [v15 participantPushToken];
  int v4 = +[IDSPushToken pushTokenWithData:v3];
  int v5 = v4;
  if (v4)
  {
    id v6 = v4;
  }
  else
  {
    id v6 = +[NSNull null];
  }
  int v7 = v6;

  if ([a1[4] containsObject:v7])
  {
    id v8 = a1[5];
    uint64_t v9 = [v15 participantURI];
    uint64_t v10 = [v8 objectForKeyedSubscript:v9];

    id v11 = [v7 rawToken];
    uint64_t v12 = [v15 participantURI];
    unint64_t v13 = (void *)_IDSCopyIDForTokenWithURI();

    uint64_t v14 = [a1[5] objectForKeyedSubscript:v13];
    if (v10 && ![v10 BOOLValue]
      || v14 && ([v14 BOOLValue] & 1) == 0)
    {
      [a1[6] addObject:v7];
    }
  }
}

void sub_10019BD3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10019BD60(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) sessionController];
  uint64_t v3 = [v2 sessionWithGroupID:*(void *)(a1 + 40)];

  id WeakRetained = (os_unfair_lock_s *)objc_loadWeakRetained((id *)(a1 + 48));
  int v5 = WeakRetained;
  if (WeakRetained)
  {
    os_unfair_lock_lock(WeakRetained + 7);
    id v6 = +[IDSFoundationLog RealTimeEncryptionController];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = *(void *)(a1 + 40);
      id v8 = [v3 uniqueID];
      uint64_t v9 = [*(id *)&v5[54]._os_unfair_lock_opaque objectForKeyedSubscript:*(void *)(a1 + 40)];
      int v10 = 138412802;
      uint64_t v11 = v7;
      __int16 v12 = 2112;
      unint64_t v13 = v8;
      __int16 v14 = 2112;
      id v15 = v9;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Failed to distribute initial key material distribution to some participants -- ending session { groupID: %@, sessionID: %@, remainingDestinations: %@ }", (uint8_t *)&v10, 0x20u);
    }
    [*(id *)&v5[86]._os_unfair_lock_opaque setObject:0 forKeyedSubscript:*(void *)(a1 + 40)];
    [*(id *)&v5[54]._os_unfair_lock_opaque setObject:0 forKeyedSubscript:*(void *)(a1 + 40)];
    os_unfair_lock_unlock(v5 + 7);
  }
  [v3 endSessionWithReason:39];
}

void sub_10019C6E0(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 28));
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(v2 + 104);
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 28));
  if (v3)
  {
    int v4 = *(id **)(a1 + 32);
    int v5 = [v4[13] pushToken];
    id v6 = [v4 createRealTimeEncryptionFullIdentityForDevice:v5 completionBlock:0];

    uint64_t v7 = *(void **)(a1 + 32);
    _[v7 _sendRenewedPrekeysToGroups];
  }
  else
  {
    id v8 = +[IDSFoundationLog RealTimeEncryptionController];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      sub_100714EC4();
    }
  }
}

id sub_10019CDB4(uint64_t a1)
{
  LOBYTE(v2) = *(unsigned char *)(a1 + 81);
  return [*(id *)(a1 + 32) sendKeyMaterialsRecoveryRequestToDevice:*(void *)(a1 + 40) fromURI:*(void *)(a1 + 48) participantID:*(void *)(a1 + 56) groupID:*(void *)(a1 + 64) sessionID:*(void *)(a1 + 72) requireMKM:*(unsigned __int8 *)(a1 + 80) requireSKM:v2];
}

id sub_10019CDF0(uint64_t a1)
{
  LOBYTE(v2) = *(unsigned char *)(a1 + 81);
  return [*(id *)(a1 + 32) sendKeyMaterialsRecoveryRequestToDevice:*(void *)(a1 + 40) fromURI:*(void *)(a1 + 48) participantID:*(void *)(a1 + 56) groupID:*(void *)(a1 + 64) sessionID:*(void *)(a1 + 72) requireMKM:*(unsigned __int8 *)(a1 + 80) requireSKM:v2];
}

id sub_10019D658(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _doCheckPendingKeyMaterialsAndSendKeyRecoveryRequestForMKM:*(unsigned __int8 *)(a1 + 56) forSKM:*(unsigned __int8 *)(a1 + 57) forDevice:*(void *)(a1 + 40) forGroupID:*(void *)(a1 + 48)];
}

id sub_10019D7AC(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _doCheckPendingKeyMaterialsAndSendKeyRecoveryRequestForMKM:*(unsigned __int8 *)(a1 + 56) forSKM:*(unsigned __int8 *)(a1 + 57) forDevice:*(void *)(a1 + 40) forGroupID:*(void *)(a1 + 48)];
}

uint64_t sub_10019E068(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog RealTimeEncryptionController];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v5 = 138412290;
    uint64_t v6 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "createRealTimeEncryptionFullIdentity - found the existed one %@", (uint8_t *)&v5, 0xCu);
  }

  return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_10019E128(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void **)(v1 + 112);
  *(void *)(v1 + 112) = 0;

  uint64_t v3 = +[IDSFoundationLog RealTimeEncryptionController];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "createRealTimeEncryptionFullIdentity - previous pre-key is now expired.", v4, 2u);
  }
}

uint64_t sub_10019E1A8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10019E1B8(id a1)
{
  off_100A4A908 = (uint64_t (*)(void, void))IMWeakLinkSymbol();
}

void sub_10019E1E8(id a1)
{
  off_100A4A918 = (uint64_t (*)(void))IMWeakLinkSymbol();
}

uint64_t sub_10019E218(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10019E624(id a1)
{
  off_100A4A928 = (_UNKNOWN *)IMWeakLinkSymbol();
}

id sub_10019EC70(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog RealTimeEncryptionController];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v5 = 136315394;
    uint64_t v6 = "-[IDSGroupEncryptionController1 resetMKMCacheAfterTimeoutForGroup:interval:]_block_invoke";
    __int16 v7 = 2112;
    uint64_t v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%s %@, keyMaterial reset timer fired. Resetting stored encryption sequence number during cleanup to 0", (uint8_t *)&v5, 0x16u);
  }

  return [*(id *)(a1 + 40) _resetKeyCacheForGroup:*(void *)(a1 + 32)];
}

void sub_10019FC50(id a1)
{
  off_100A4A938 = (uint64_t (*)(void, void, void))IMWeakLinkSymbol();
}

id sub_10019FC80(uint64_t a1)
{
  return _[*(id *)(a1 + 32) sendPendingKeyMaterialsToGroup:*(void *)(a1 + 40) sessionID:*(void *)(a1 + 48) forDevice:*(void *)(a1 + 56) fromURI:*(void *)(a1 + 64)];
}

id sub_10019FC94(uint64_t a1)
{
  return _[*(id *)(a1 + 32) sendKeyMaterialsToWaitingParticipantsForGroup:*(void *)(a1 + 40) sessionID:*(void *)(a1 + 48)];
}

id sub_1001A07BC(void *a1)
{
  uint64_t v1 = (void *)a1[4];
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t v4 = a1[7];
  uint64_t v5 = a1[8];
  [v1 _multiwayFTMessageSendTimeout];
  LOBYTE(v7) = 0;
  return objc_msgSend(v1, "_sendMessage:toDestination:forGroup:sessionID:command:timeout:shouldExpire:useQR:completion:completionBlock:", v2, v3, v4, v5, 210, 1, v7, 0, 0);
}

void sub_1001A1294(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
}

uint64_t sub_1001A12E0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1001A12F0(uint64_t a1)
{
}

BOOL sub_1001A12F8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [v3 createdAt];
  LODWORD(v5) = *(_DWORD *)(*(void *)(a1 + 32) + 64);
  uint64_t v6 = [v4 dateByAddingTimeInterval:(double)v5];

  uint64_t v7 = +[NSDate date];
  id v8 = [v7 compare:v6];

  if (v8 == (id)1)
  {
    uint64_t v9 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    int v10 = [v3 groupID];
    id v11 = v9;
    __int16 v12 = [v11 objectForKeyedSubscript:v10];
    if (!v12)
    {
      __int16 v12 = +[NSMutableArray array];
      [v11 setObject:v12 forKeyedSubscript:v10];
    }

    unint64_t v13 = [v3 keyIndex];
    id v14 = [v13 copy];
    [v12 addObject:v14];

    id v15 = +[IDSFoundationLog RealTimeEncryptionController];
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = 138412546;
      long long v18 = v6;
      __int16 v19 = 2112;
      id v20 = v3;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Found expired MkM { expirationDate: %@, MkM: %@ }", (uint8_t *)&v17, 0x16u);
    }
  }
  return v8 != (id)1;
}

void sub_1001A14CC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if ([v6 count])
  {
    uint64_t v7 = +[IDSFoundationLog RealTimeEncryptionController];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 138412546;
      id v12 = v5;
      __int16 v13 = 2112;
      id v14 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "expired MKIs for group %@: %@", (uint8_t *)&v11, 0x16u);
    }

    id v8 = [*(id *)(a1 + 32) sessionController];
    uint64_t v9 = [v8 sessionWithGroupID:v5];

    if (v9)
    {
      [v9 invalidateKeyMaterialByKeyIndexes:v6];
    }
    else
    {
      int v10 = +[IDSFoundationLog RealTimeEncryptionController];
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        int v11 = 138412290;
        id v12 = v5;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "cleanUpExpiredMasterKeyMaterial: couldn't invalidate MKIs - cannot find session with groupID %@", (uint8_t *)&v11, 0xCu);
      }
    }
  }
}

id sub_1001A1A34(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _handleMkmRollTimerForGroup:*(void *)(a1 + 40)];
}

id sub_1001A1F68(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _handleMkmExpirationTimerForGroup:*(void *)(a1 + 40)];
}

id sub_1001A2D48(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog RealTimeEncryptionController];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 40);
    int v4 = *(_DWORD *)(*(void *)(a1 + 32) + 68);
    v6[0] = 67109378;
    v6[1] = v4;
    __int16 v7 = 2112;
    uint64_t v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "MKMRoll timer fired: duration: %u, groupID: %@", (uint8_t *)v6, 0x12u);
  }

  return [*(id *)(a1 + 32) _mkmRollTimerFiredForGroup:*(void *)(a1 + 40) sessionID:*(void *)(a1 + 48)];
}

void sub_1001A2E14(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 28));
  uint64_t v2 = [*(id *)(*(void *)(a1 + 32) + 136) objectForKeyedSubscript:*(void *)(a1 + 40)];
  uint64_t v3 = +[IDSFoundationLog RealTimeEncryptionController];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v4 = @"YES";
    if (!*(unsigned char *)(a1 + 56)) {
      CFStringRef v4 = @"NO";
    }
    int v16 = 138412546;
    CFStringRef v17 = v4;
    __int16 v18 = 2112;
    __int16 v19 = v2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "MKMExpiration timer fired: isFirstLocalGeneratedMKM: %@, innerKeyMaterialCache: %@", (uint8_t *)&v16, 0x16u);
  }

  if (v2 && ([v2 currentLocalMasterKeyMaterial], (uint64_t v5 = objc_claimAutoreleasedReturnValue()) != 0))
  {
    id v6 = (void *)v5;
    __int16 v7 = [*(id *)(a1 + 32) sessionController];
    uint64_t v8 = [v7 sessionWithUniqueID:*(void *)(a1 + 48)];

    if (v8
      && [v8 groupSessionState] == 1
      && ([*(id *)(*(void *)(a1 + 32) + 168) objectForKeyedSubscript:*(void *)(a1 + 40)],
          uint64_t v9 = objc_claimAutoreleasedReturnValue(),
          id v10 = [v9 count],
          v9,
          (unint64_t)v10 > 1))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 28));
      [*(id *)(a1 + 32) requestKeyMaterialForGroup:*(void *)(a1 + 40) sessionID:*(void *)(a1 + 48) shouldGenerateMKM:1];
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 28));
      int v11 = +[IDSFoundationLog RealTimeEncryptionController];
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        id v12 = [v6 keyIndex];
        __int16 v13 = *(void **)(a1 + 40);
        unsigned int v14 = [v8 groupSessionState];
        id v15 = [*(id *)(*(void *)(a1 + 32) + 168) objectForKeyedSubscript:*(void *)(a1 + 40)];
        int v16 = 138413058;
        CFStringRef v17 = v12;
        __int16 v18 = 2112;
        __int16 v19 = v13;
        __int16 v20 = 1024;
        unsigned int v21 = v14;
        __int16 v22 = 2112;
        uint64_t v23 = v15;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "The MKI (%@) has been expired for group: %@, but no need to create new MKMs: group session state %d, active participant: %@", (uint8_t *)&v16, 0x26u);
      }
      [*(id *)(a1 + 32) _stopMkmExpirationTimerForGroup:*(void *)(a1 + 40)];
      [v2 setCurrentLocalMasterKeyMaterial:0];
      [v2 setNextLocalMasterKeyMaterial:0];
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 28));
  }
}

id sub_1001A4474(uint64_t a1)
{
  return _[*(id *)(a1 + 32) sendKeyMaterialsRecoveryRequestToGroup:*(void *)(a1 + 40) requireMKM:0 requireSKM:1];
}

void sub_1001A4488(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v9 = [*(id *)(a1 + 40) participantPushToken];
  uint64_t v3 = +[IDSPushToken pushTokenWithData:](IDSPushToken, "pushTokenWithData:");
  CFStringRef v4 = v3;
  if (!v3)
  {
    CFStringRef v4 = +[NSNull null];
  }
  uint64_t v5 = [*(id *)(a1 + 40) participantURI];
  id v6 = +[IDSURI URIWithPrefixedURI:v5];
  __int16 v7 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", [*(id *)(a1 + 40) participantIdentifier]);
  LOBYTE(v8) = *(unsigned char *)(a1 + 65);
  [v2 sendKeyMaterialsRecoveryRequestToDevice:v4 fromURI:v6 participantID:v7 groupID:*(void *)(a1 + 48) sessionID:*(void *)(a1 + 56) requireMKM:*(unsigned __int8 *)(a1 + 64) requireSKM:v8];

  if (!v3) {
}
  }

id sub_1001A6AD4(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _startKeyRecoveryForMKM:1 forSKM:0 forDevice:*(void *)(a1 + 40) forGroupID:*(void *)(a1 + 48)];
}

id sub_1001AA134(id a1, IDSURI *a2)
{
  return [(IDSURI *)a2 prefixedURI];
}

void sub_1001AA13C(uint64_t a1)
{
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472;
  v18[2] = sub_1001AA2C4;
  v18[3] = &unk_100984A48;
  uint64_t v2 = *(void **)(a1 + 40);
  v18[4] = *(void *)(a1 + 32);
  id v19 = v2;
  id v20 = *(id *)(a1 + 48);
  uint64_t v3 = objc_retainBlock(v18);
  CFStringRef v4 = *(void **)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 56);
  uint64_t v6 = *(void *)(a1 + 64);
  uint64_t v7 = *(void *)(a1 + 72);
  uint64_t v8 = *(void *)(a1 + 80);
  [v4 _multiwayFTMessageSendTimeout];
  double v10 = v9;
  uint64_t v11 = *(void *)(a1 + 32);
  char v12 = *(unsigned char *)(v11 + 33);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  void v15[2] = sub_1001AA3E8;
  v15[3] = &unk_100984A70;
  uint64_t v13 = *(void *)(a1 + 88);
  void v15[4] = v11;
  v15[5] = v13;
  id v16 = *(id *)(a1 + 72);
  id v17 = *(id *)(a1 + 64);
  LOBYTE(v14) = v12;
  [v4 _sendMessage:v5 toDestination:v6 forGroup:v7 sessionID:v8 command:211 timeout:1 shouldExpire:v10 useQR:v14 completion:v15 completionBlock:v3];
}

void sub_1001AA2C4(id *a1, void *a2, void *a3)
{
  id v13 = a2;
  id v5 = a3;
  if (([a1[4] isTestRunning] & 1) == 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)a1[4] + 7);
    uint64_t v6 = [*((id *)a1[4] + 17) objectForKeyedSubscript:v13];
    uint64_t v7 = [v6 currentLocalMasterKeyMaterial];
    unsigned int v8 = [v7 isEqual:a1[5]];

    if (v8)
    {
      double v9 = +[NSDate date];
      double v10 = [a1[5] createdAt];
      [v9 timeIntervalSinceDate:v10];
      double v12 = v11;

      [a1[6] didSendKeyMaterial:a1[5] duration:v12];
      [a1[4] sendKeyMaterialsToLocal:v13 sessionID:v5];
    }
    os_unfair_lock_unlock((os_unfair_lock_t)a1[4] + 7);
  }
}

id sub_1001AA3E8(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = +[IDSFoundationLog RealTimeEncryptionController];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_10071589C(a1);
    }

    return [*(id *)(a1 + 32) _noteKeyMaterialDidSendToDestination:*(void *)(a1 + 40) groupID:*(void *)(a1 + 48) withSuccess:0];
  }
  else
  {
    id v5 = *(void **)(a1 + 32);
    uint64_t v6 = *(void *)(a1 + 40);
    uint64_t v7 = *(void *)(a1 + 48);
    return [v5 _noteKeyMaterialDidSendToDestination:v6 groupID:v7 withSuccess:1];
  }
}

void sub_1001AA48C(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog RealTimeEncryptionController_oversize];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = 136315651;
    id v5 = "IDSGroupEncryptionController1.m";
    __int16 v6 = 1024;
    int v7 = 2780;
    __int16 v8 = 2113;
    uint64_t v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%s:%d %{private}@", (uint8_t *)&v4, 0x1Cu);
  }
}

void sub_1001AB2C8(uint64_t a1, void *a2, void *a3)
{
  id v7 = a2;
  id v5 = [a3 objectForKeyedSubscript:IDSGroupSessionMessagesGroupIDKey];
  unsigned int v6 = [v5 isEqualToString:*(void *)(a1 + 32)];

  if (v6) {
    [*(id *)(a1 + 40) addObject:v7];
  }
}

void sub_1001ACC18(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 224), 8);
  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

void sub_1001ACC7C(void *a1, int a2)
{
  int v4 = +[IDSFoundationLog RealTimeEncryptionController];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(*(void *)(a1[8] + 8) + 24)) {
      CFStringRef v5 = @"YES";
    }
    else {
      CFStringRef v5 = @"NO";
    }
    if (*(unsigned char *)(*(void *)(a1[9] + 8) + 24)) {
      CFStringRef v6 = @"YES";
    }
    else {
      CFStringRef v6 = @"NO";
    }
    uint64_t v7 = a1[4];
    uint64_t v8 = a1[5];
    v11[0] = 67110146;
    v11[1] = a2;
    __int16 v12 = 2112;
    CFStringRef v13 = v5;
    __int16 v14 = 2112;
    CFStringRef v15 = v6;
    __int16 v16 = 2112;
    uint64_t v17 = v7;
    __int16 v18 = 2112;
    uint64_t v19 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "sendMessage: sendKeyMaterialMessageDataOverQR completed with %d. completionBlocks called %@ %@, groupID %@, sessionID %@", (uint8_t *)v11, 0x30u);
  }

  if (a1[6])
  {
    uint64_t v9 = *(void *)(a1[8] + 8);
    if (!*(unsigned char *)(v9 + 24))
    {
      *(unsigned char *)(v9 + 24) = 1;
      (*(void (**)(void))(a1[6] + 16))();
    }
  }
  if (a1[7])
  {
    uint64_t v10 = *(void *)(a1[9] + 8);
    if (!*(unsigned char *)(v10 + 24))
    {
      *(unsigned char *)(v10 + 24) = 1;
      (*(void (**)(void))(a1[7] + 16))();
    }
  }
}

void sub_1001ACDF8(void *a1, void *a2)
{
  id v3 = a2;
  int v4 = +[IDSFoundationLog RealTimeEncryptionController];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = a1[4];
    uint64_t v6 = a1[11];
    id v7 = [v3 idsResponseCode];
    if ([v3 lastCall]) {
      CFStringRef v8 = @"YES";
    }
    else {
      CFStringRef v8 = @"NO";
    }
    uint64_t v9 = [v3 responseError];
    int v18 = 138413314;
    *(void *)uint64_t v19 = v5;
    *(_WORD *)&void v19[8] = 2048;
    *(void *)&v19[10] = v6;
    *(_WORD *)&v19[18] = 2048;
    *(void *)&v19[20] = v7;
    *(_WORD *)&v19[28] = 2112;
    *(void *)&v19[30] = v8;
    *(_WORD *)&v19[38] = 2112;
    *(void *)&v19[40] = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Group session encryption message completion block fired { GUID: %@, command: %ld, responseCode: %lu, lastCall: %@, error: %@ }", (uint8_t *)&v18, 0x34u);
  }
  if ([v3 lastCall])
  {
    uint64_t v10 = +[IDSFoundationLog RealTimeEncryptionController];
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v11 = [v3 responseCode];
      if (*(unsigned char *)(*(void *)(a1[9] + 8) + 24)) {
        CFStringRef v12 = @"YES";
      }
      else {
        CFStringRef v12 = @"NO";
      }
      if (*(unsigned char *)(*(void *)(a1[10] + 8) + 24)) {
        CFStringRef v13 = @"YES";
      }
      else {
        CFStringRef v13 = @"NO";
      }
      uint64_t v14 = a1[5];
      uint64_t v15 = a1[6];
      int v18 = 67110146;
      *(_DWORD *)uint64_t v19 = v11;
      *(_WORD *)&void v19[4] = 2112;
      *(void *)&v19[6] = v12;
      *(_WORD *)&v19[14] = 2112;
      *(void *)&v19[16] = v13;
      *(_WORD *)&v19[24] = 2112;
      *(void *)&v19[26] = v14;
      *(_WORD *)&v19[34] = 2112;
      *(void *)&v19[36] = v15;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "sendMessage: sendMessageWithSendParameters completed with %d. completionBlocks called %@ %@, groupID %@, sessionID %@", (uint8_t *)&v18, 0x30u);
    }

    if (a1[7])
    {
      uint64_t v16 = *(void *)(a1[9] + 8);
      if (!*(unsigned char *)(v16 + 24))
      {
        *(unsigned char *)(v16 + 24) = 1;
        (*(void (**)(void, id))(a1[7] + 16))(a1[7], [v3 responseCode]);
      }
    }
    if (a1[8])
    {
      uint64_t v17 = *(void *)(a1[10] + 8);
      if (!*(unsigned char *)(v17 + 24))
      {
        *(unsigned char *)(v17 + 24) = 1;
        (*(void (**)(void))(a1[8] + 16))();
      }
    }
  }
}

void sub_1001AD078(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog RealTimeEncryptionController_oversize];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = 136315651;
    uint64_t v5 = "IDSGroupEncryptionController1.m";
    __int16 v6 = 1024;
    int v7 = 3200;
    __int16 v8 = 2113;
    uint64_t v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%s:%d %{private}@", (uint8_t *)&v4, 0x1Cu);
  }
}

id sub_1001AD5A8(void *a1)
{
  uint64_t v1 = (void *)a1[4];
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t v4 = a1[7];
  uint64_t v5 = a1[8];
  [v1 _multiwayFTMessageSendTimeout];
  LOBYTE(v7) = 0;
  return objc_msgSend(v1, "_sendMessage:toDestination:forGroup:sessionID:command:timeout:shouldExpire:useQR:completion:completionBlock:", v2, v3, v4, v5, 210, 0, v7, 0, 0);
}

void sub_1001AD6E4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  if ([a3 isExpired]) {
    [*(id *)(a1 + 32) addObject:v5];
  }
}

void sub_1001AD978(_Unwind_Exception *a1)
{
  sub_1001ADA8C(v1);
  _Unwind_Resume(a1);
}

void sub_1001AD98C(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void **)(*(void *)(a1 + 32) + 128);
  id v6 = a2;
  uint64_t v4 = [v3 objectForKeyedSubscript:v6];

  uint64_t v5 = 48;
  if (!v4) {
    uint64_t v5 = 40;
  }
  [*(id *)(a1 + v5) addObject:v6];
}

void sub_1001ADA0C(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void **)(*(void *)(a1 + 32) + 128);
  id v6 = a2;
  uint64_t v4 = [v3 objectForKeyedSubscript:v6];

  uint64_t v5 = 48;
  if (!v4) {
    uint64_t v5 = 40;
  }
  [*(id *)(a1 + v5) addObject:v6];
}

void sub_1001ADA8C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
}

void sub_1001ADFB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  sub_1001ADA8C((uint64_t)va);
  _Unwind_Resume(a1);
}

id sub_1001ADFEC(uint64_t a1)
{
  return [*(id *)(a1 + 32) requestKeyMaterialForGroup:*(void *)(a1 + 40) sessionID:*(void *)(a1 + 48) toSpecificMembers:*(void *)(a1 + 56) requireMKM:1 requireSKM:1];
}

id sub_1001AE004(uint64_t a1)
{
  return [*(id *)(a1 + 32) requestKeyMaterialForGroup:*(void *)(a1 + 40) sessionID:*(void *)(a1 + 48) toSpecificMembers:*(void *)(a1 + 56) requireMKM:0 requireSKM:1];
}

uint64_t sub_1001AE618(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = [v5 pushToken];
  if (v7)
  {
    __int16 v8 = [v5 pushToken];
    if ([v8 isNull])
    {
      unsigned int v9 = 0;
    }
    else
    {
      uint64_t v10 = *(void **)(a1 + 32);
      unsigned int v11 = [v5 pushToken];
      CFStringRef v12 = objc_msgSend(v11, "__imHexString");
      unsigned int v9 = [v10 containsObject:v12];
    }
  }
  else
  {
    unsigned int v9 = 0;
  }

  CFStringRef v13 = [v6 pushToken];
  if (v13)
  {
    uint64_t v14 = [v6 pushToken];
    if ([v14 isNull])
    {
      unsigned int v15 = 0;
    }
    else
    {
      uint64_t v16 = *(void **)(a1 + 32);
      uint64_t v17 = [v6 pushToken];
      int v18 = objc_msgSend(v17, "__imHexString");
      unsigned int v15 = [v16 containsObject:v18];
    }
  }
  else
  {
    unsigned int v15 = 0;
  }

  if (v9 ^ 1 | v15) {
    uint64_t v19 = (v9 ^ 1) & v15;
  }
  else {
    uint64_t v19 = -1;
  }

  return v19;
}

id sub_1001AFF60(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id v6 = +[IDSEncryptionController sharedInstance];
  uint64_t v7 = [*(id *)(a1 + 32) service];
  __int16 v8 = [v7 identifier];
  unsigned int v9 = [v6 publicKeySignData:v5 withSignatureType:0 service:v8 priority:300 error:a3];

  return v9;
}

void sub_1001B0230(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) sessionController];
  uint64_t v3 = (uint64_t *)(a1 + 40);
  uint64_t v4 = [v2 sessionWithGroupID:*(void *)(a1 + 40)];

  id v5 = +[IDSFoundationLog RealTimeEncryptionController];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *v3;
    uint64_t v7 = [v4 uniqueID];
    *(_DWORD *)buf = 138412802;
    uint64_t v25 = v6;
    __int16 v26 = 2112;
    __int16 v27 = v7;
    __int16 v28 = 2112;
    id v29 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "rollNewKeysAfterResettingPrekeysForGroups: %@ session %@: %@", buf, 0x20u);
  }
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472;
  v20[2] = sub_1001B047C;
  v20[3] = &unk_10097E5A8;
  long long v21 = *(_OWORD *)(a1 + 32);
  id v22 = *(id *)(a1 + 48);
  id v8 = v4;
  id v23 = v8;
  unsigned int v9 = objc_retainBlock(v20);
  uint64_t v10 = (void (**)(void))v9;
  if (v8)
  {
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 3221225472;
    v18[2] = sub_1001B0668;
    v18[3] = &unk_10097E7F0;
    uint64_t v19 = v9;
    [v8 recvMembershipChangeEventWithReason:3 completionHandler:v18];
  }
  else
  {
    unsigned int v11 = +[IDSFoundationLog RealTimeEncryptionController];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      sub_100715CD0((uint64_t)v3, v11, v12, v13, v14, v15, v16, v17);
    }

    v10[2](v10);
  }
}

void sub_1001B047C(uint64_t a1)
{
  [*(id *)(a1 + 32) resetKeysForGroup:*(void *)(a1 + 40) shouldRemoveCurrentParticipants:1];
  uint64_t v2 = im_primary_queue();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_1001B0548;
  v5[3] = &unk_10097E5A8;
  void v5[4] = *(void *)(a1 + 32);
  id v3 = *(id *)(a1 + 48);
  uint64_t v4 = *(void *)(a1 + 40);
  id v6 = v3;
  uint64_t v7 = v4;
  id v8 = *(id *)(a1 + 56);
  dispatch_async(v2, v5);
}

void sub_1001B0548(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) createRealTimeEncryptionFullIdentityForDevice:*(void *)(a1 + 40) completionBlock:0];
  id v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 48);
  id v5 = [*(id *)(a1 + 56) uniqueID];
  [v3 sendPublicKeyToGroup:v4 sessionID:v5];

  id v6 = *(void **)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 48);
  id v8 = [*(id *)(a1 + 56) uniqueID];
  [v6 requestKeyMaterialForGroup:v7 sessionID:v8];

  unsigned int v9 = *(void **)(a1 + 32);
  uint64_t v10 = [*(id *)(a1 + 56) uniqueID];
  [v9 _updateRelevantEncryptedDataBlobForSession:v10];

  +[NSDictionary dictionaryWithObjectsAndKeys:](NSDictionary, "dictionaryWithObjectsAndKeys:", &off_1009D1788, IDSGlobalLinkOptionSessionInfoRequestTypeKey, &off_1009D17B8, IDSGlobalLinkOptionSessionInfoCommandFlagKey, 0);
  id v11 = (id)objc_claimAutoreleasedReturnValue();
  [*(id *)(a1 + 56) requestSessionInfoWithOptions:v11];
}

uint64_t sub_1001B0668(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1001B0A8C(uint64_t a1)
{
  id v2 = +[IDSFoundationLog RealTimeEncryptionController_oversize];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = 136315651;
    id v5 = "IDSGroupEncryptionController1.m";
    __int16 v6 = 1024;
    int v7 = 3749;
    __int16 v8 = 2113;
    uint64_t v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%s:%d %{private}@", (uint8_t *)&v4, 0x1Cu);
  }
}

void sub_1001B0B60(void *a1)
{
  id v2 = +[IDSFoundationLog RealTimeEncryptionController];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = a1[5];
    uint64_t v5 = a1[6];
    int v10 = 138412802;
    uint64_t v11 = v3;
    __int16 v12 = 2112;
    uint64_t v13 = v4;
    __int16 v14 = 2112;
    uint64_t v15 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "didReceiveEndpointsUpdate: %@ forGroup: %@ - roll new keys for the group (previous %@)", (uint8_t *)&v10, 0x20u);
  }

  __int16 v6 = (void *)a1[7];
  int v7 = +[NSArray arrayWithObject:a1[5]];
  [v6 rollNewKeysAfterResettingPrekeysForGroups:v7 withReason:2];

  [*(id *)(a1[7] + 368) invalidate];
  uint64_t v8 = a1[7];
  uint64_t v9 = *(void **)(v8 + 368);
  *(void *)(v8 + 368) = 0;
}

void sub_1001B161C(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_1001B174C;
  v10[3] = &unk_100984C00;
  id v11 = v2;
  id v3 = *(id *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 48);
  id v12 = v3;
  uint64_t v13 = v4;
  [v11 initializeWithCompletion:v10];
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_1001B1A14;
  v7[3] = &unk_100984C28;
  int8x16_t v6 = *(int8x16_t *)(a1 + 40);
  id v5 = (id)v6.i64[0];
  int8x16_t v8 = vextq_s8(v6, v6, 8uLL);
  id v9 = *(id *)(a1 + 56);
  [*(id *)(a1 + 32) setResolvedEndpointsDidUpdateHandler:v7];
}

void sub_1001B174C(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = objc_alloc_init((Class)NSMutableSet);
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  id v8 = v5;
  id v9 = [v8 countByEnumeratingWithState:&v16 objects:v20 count:16];
  if (v9)
  {
    id v10 = v9;
    uint64_t v11 = *(void *)v17;
    do
    {
      for (uint64_t i = 0; i != v10; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v17 != v11) {
          objc_enumerationMutation(v8);
        }
        uint64_t v13 = [*(id *)(*((void *)&v16 + 1) + 8 * i) pushTokenObject];
        [v7 addObject:v13];
      }
      id v10 = [v8 countByEnumeratingWithState:&v16 objects:v20 count:16];
    }
    while (v10);
  }

  uint64_t v15 = +[NSString stringWithFormat:@"setMembers: endpointSubscription: %p groupID %@ error: %@ newPushTokensForGroup: %@", a1[4], a1[5], v6, v7];
  id v14 = v15;
  cut_dispatch_log_queue();
  os_unfair_lock_lock((os_unfair_lock_t)(a1[6] + 28));
  [*(id *)(a1[6] + 232) setObject:v7 forKeyedSubscript:a1[5]];
  os_unfair_lock_unlock((os_unfair_lock_t)(a1[6] + 28));
}

void sub_1001B1940(uint64_t a1)
{
  id v2 = +[IDSFoundationLog RealTimeEncryptionController_oversize];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = 136315651;
    id v5 = "IDSGroupEncryptionController1.m";
    __int16 v6 = 1024;
    int v7 = 3876;
    __int16 v8 = 2113;
    uint64_t v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%s:%d %{private}@", (uint8_t *)&v4, 0x1Cu);
  }
}

id sub_1001B1A14(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) didReceiveEndpointsUpdate:a2 forGroup:*(void *)(a1 + 40) sessionID:*(void *)(a1 + 48)];
}

void sub_1001B2060(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 28));
  [*(id *)(*(void *)(a1 + 32) + 336) setObject:&__kCFBooleanFalse forKeyedSubscript:*(void *)(a1 + 40)];
  id v2 = [*(id *)(a1 + 48) count];
  if (v2)
  {
    uint64_t v3 = +[IDSFoundationLog RealTimeEncryptionController];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = *(void *)(a1 + 72);
      uint64_t v5 = *(void *)(a1 + 48);
      *(_DWORD *)buf = 134218242;
      uint64_t v14 = v4;
      __int16 v15 = 2112;
      uint64_t v16 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "_dispatchDeferredPrekeyRequestForGroupID - after %f sec, now sending prekey request to group because we still have not delivered key material to participants %@", buf, 0x16u);
    }
  }
  __int16 v6 = +[NSMutableSet set];
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_1001B222C;
  v10[3] = &unk_100984868;
  void v10[4] = *(void *)(a1 + 32);
  int v7 = *(void **)(a1 + 56);
  id v11 = *(id *)(a1 + 48);
  id v8 = v6;
  id v12 = v8;
  [v7 enumerateObjectsUsingBlock:v10];
  uint64_t v9 = +[IDSDestination destinationWithDestinations:v8];
  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 28));
  if (v2) {
    [*(id *)(a1 + 32) sendPrekeyRequestToDestination:v9 group:*(void *)(a1 + 40) sessionID:*(void *)(a1 + 64)];
  }
}

void sub_1001B222C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void **)(a1 + 32);
  uint64_t v5 = [v3 participantPushTokenObject];
  if (([v4 _isValidPushToken:v5] & 1) == 0)
  {
LABEL_6:

    goto LABEL_7;
  }
  __int16 v6 = *(void **)(a1 + 40);
  int v7 = [v3 participantPushTokenObject];
  LODWORD(v6) = [v6 containsObject:v7];

  if (v6)
  {
    id v8 = +[IDSFoundationLog RealTimeEncryptionController];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 138412290;
      id v12 = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "_dispatchDeferredPrekeyRequestForGroupID - adding participant to destinations for prekey request %@", (uint8_t *)&v11, 0xCu);
    }

    uint64_t v9 = [v3 participantURI];
    id v10 = [v3 participantPushToken];
    uint64_t v5 = +[IDSDestination destinationWithAlias:v9 pushToken:v10];

    [*(id *)(a1 + 48) addObject:v5];
    goto LABEL_6;
  }
LABEL_7:
}

void sub_1001B391C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [v3 participantPushTokenObject];
  if ([v3 isKnown]
    && [*(id *)(a1 + 32) _isValidPushToken:v4])
  {
    if (([*(id *)(a1 + 40) containsObject:v4] & 1) == 0)
    {
      [*(id *)(a1 + 40) addObject:v4];
      if (v3)
      {
        uint64_t v5 = *(__CFArray **)(a1 + 48);
        if (v5) {
          CFArrayAppendValue(v5, v3);
        }
      }
    }
    if ([*(id *)(a1 + 56) containsObject:v4])
    {
      __int16 v6 = +[IDSFoundationLog RealTimeEncryptionController];
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        int v7 = 138412290;
        id v8 = v3;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "_updateLightweightParticipants: remove standard participant: %@ due to downgrade", (uint8_t *)&v7, 0xCu);
      }

      [*(id *)(a1 + 56) removeObject:v4];
    }
  }
}

void sub_1001B3A54(uint64_t a1)
{
  id v2 = +[IDSFoundationLog RealTimeEncryptionController_oversize];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = 136315651;
    uint64_t v5 = "IDSGroupEncryptionController1.m";
    __int16 v6 = 1024;
    int v7 = 4143;
    __int16 v8 = 2113;
    uint64_t v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%s:%d %{private}@", (uint8_t *)&v4, 0x1Cu);
  }
}

void sub_1001B3B28(uint64_t a1)
{
  id v2 = +[IDSFoundationLog RealTimeEncryptionController_oversize];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = 136315651;
    uint64_t v5 = "IDSGroupEncryptionController1.m";
    __int16 v6 = 1024;
    int v7 = 4146;
    __int16 v8 = 2113;
    uint64_t v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%s:%d %{private}@", (uint8_t *)&v4, 0x1Cu);
  }
}

void sub_1001B3BFC(uint64_t a1)
{
  id v2 = +[IDSFoundationLog RealTimeEncryptionController_oversize];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = 136315651;
    uint64_t v5 = "IDSGroupEncryptionController1.m";
    __int16 v6 = 1024;
    int v7 = 4162;
    __int16 v8 = 2113;
    uint64_t v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%s:%d %{private}@", (uint8_t *)&v4, 0x1Cu);
  }
}

id sub_1001B3CD0(uint64_t a1)
{
  LOBYTE(v2) = 1;
  return [*(id *)(a1 + 32) _requestKeyMaterialForGroup:*(void *)(a1 + 40) sessionID:*(void *)(a1 + 48) toSpecificMembers:*(void *)(a1 + 56) shouldTrackDistribution:0 shouldIncludeCachedPeerKeyMaterial:0 requireMKM:0 requireSKM:v2];
}

void sub_1001B4508(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = [v3 participantPushTokenObject];
  if ([v3 isKnown]
    && [*(id *)(a1 + 32) _isValidPushToken:v4])
  {
    if (([*(id *)(a1 + 40) containsObject:v4] & 1) == 0)
    {
      [*(id *)(a1 + 40) addObject:v4];
      if (v3)
      {
        uint64_t v5 = *(__CFArray **)(a1 + 48);
        if (v5) {
          CFArrayAppendValue(v5, v3);
        }
      }
    }
    if ([*(id *)(a1 + 56) containsObject:v4])
    {
      __int16 v6 = +[IDSFoundationLog RealTimeEncryptionController];
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        int v7 = 138412290;
        id v8 = v3;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "_updateStandardParticipants: remove lightweight participant: %@ due to upgrade", (uint8_t *)&v7, 0xCu);
      }

      [*(id *)(a1 + 56) removeObject:v4];
    }
  }
}

void sub_1001B4640(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog RealTimeEncryptionController_oversize];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = 136315651;
    uint64_t v5 = "IDSGroupEncryptionController1.m";
    __int16 v6 = 1024;
    int v7 = 4231;
    __int16 v8 = 2113;
    uint64_t v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%s:%d %{private}@", (uint8_t *)&v4, 0x1Cu);
  }
}

void sub_1001B4714(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog RealTimeEncryptionController_oversize];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = 136315651;
    uint64_t v5 = "IDSGroupEncryptionController1.m";
    __int16 v6 = 1024;
    int v7 = 4234;
    __int16 v8 = 2113;
    uint64_t v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%s:%d %{private}@", (uint8_t *)&v4, 0x1Cu);
  }
}

void sub_1001B47E8(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog RealTimeEncryptionController_oversize];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = 136315651;
    uint64_t v5 = "IDSGroupEncryptionController1.m";
    __int16 v6 = 1024;
    int v7 = 4253;
    __int16 v8 = 2113;
    uint64_t v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%s:%d %{private}@", (uint8_t *)&v4, 0x1Cu);
  }
}

id sub_1001B48BC(uint64_t a1)
{
  LOBYTE(v2) = 1;
  return [*(id *)(a1 + 32) _requestKeyMaterialForGroup:*(void *)(a1 + 40) sessionID:*(void *)(a1 + 48) toSpecificMembers:*(void *)(a1 + 56) shouldTrackDistribution:0 shouldIncludeCachedPeerKeyMaterial:*(unsigned __int8 *)(a1 + 64) requireMKM:1 requireSKM:v2];
}

void sub_1001B4DC0(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) sessionController];
  uint64_t v3 = [v2 sessionWithGroupID:*(void *)(a1 + 40)];

  int v4 = +[IDSFoundationLog RealTimeEncryptionController];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 40);
    int v6 = 138412290;
    uint64_t v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Account is no longer registered, ending group: %@", (uint8_t *)&v6, 0xCu);
  }

  [v3 endSessionWithReason:47];
}

void sub_1001B5368(void *a1, uint64_t a2, uint64_t a3, const char *a4)
{
  _os_log_fault_impl(a1, v4, OS_LOG_TYPE_FAULT, a4, v5, 0xCu);
}

id sub_1001B5388(uint64_t a1, void *a2)
{
  return [a2 wrapMode];
}

void sub_1001B5408(id a1)
{
  qword_100A4A950 = objc_alloc_init(IDSUserNotificationsCenter);

  _objc_release_x1();
}

void sub_1001B58A4(id a1)
{
  qword_100A4A958 = IMWeakLinkClass();
  qword_100A4A960 = IMWeakLinkClass();
  qword_100A4A968 = IMWeakLinkClass();
}

void sub_1001B5910(id a1, NSError *a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = +[IDSFoundationLog delivery];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    uint64_t v5 = v2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Added ids notification request {error: %@}", (uint8_t *)&v4, 0xCu);
  }
}

id sub_1001B6810(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) _timerFired:a2];
}

void sub_1001B7FB4(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v8 = a2;
  id v9 = a3;
  id v10 = a5;
  id v15 = v8;
  int v11 = [v15 responseEntries];
  if (v11)
  {
    id v12 = [*(id *)(a1 + 32) arrayByAddingObjectsFromArray:v11];
    uint64_t v13 = [v11 lastObject];
    uint64_t v14 = [v13 objectForKeyedSubscript:@"next-key"];
    if (v14) {
      [*(id *)(a1 + 40) _queryGroupServerENID:v14 withPreviousEntries:v12 completion:*(void *)(a1 + 48)];
    }
    else {
      (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    }
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
}

void sub_1001B81A8(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v8 = a2;
  id v9 = a3;
  id v10 = a5;
  id v11 = v8;
  id v12 = [v11 responseEntries];
  if (v12)
  {
    uint64_t v13 = *(void **)(a1 + 32);
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472;
    void v15[2] = sub_1001B82DC;
    v15[3] = &unk_100984D70;
    id v16 = v11;
    id v17 = *(id *)(a1 + 40);
    id v14 = [v13 _getMessageCompletionCurrentEntries:v12 withCompletion:v15];
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

void sub_1001B82DC(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5, void *a6)
{
  id v10 = a6;
  id v11 = a5;
  id v13 = a3;
  id v12 = [a2 responseEntries];
  [*(id *)(a1 + 32) setResponseEntries:v12];

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

id sub_1001B9BDC(int a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (!v6)
  {
    uint64_t v7 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v8 = @"decrypt";
      if (a1) {
        CFStringRef v8 = @"encrypt";
      }
      *(_DWORD *)buf = 138412290;
      *(void *)&uint8_t buf[4] = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "asked to %@, but key is NULL!", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      CFStringRef v9 = @"decrypt";
      if (a1) {
        CFStringRef v9 = @"encrypt";
      }
      CFStringRef v18 = v9;
      _IDSLogV();
    }
  }
  if (!v5)
  {
    id v12 = 0;
    goto LABEL_23;
  }
  *(void *)buf = 0;
  id v10 = v6;
  if (CCCryptorCreate(a1 ^ 1, 0, 1u, [v10 bytes], (size_t)objc_msgSend(v10, "length"), 0, (CCCryptorRef *)buf))
  {
    id v11 = 0;
  }
  else
  {
    id v13 = [v5 length];
    size_t OutputLength = CCCryptorGetOutputLength(*(CCCryptorRef *)buf, (size_t)v13, 1);
    size_t v19 = 0;
    size_t dataOutMoved = 0;
    id v11 = (char *)malloc_type_malloc(OutputLength, 0xDAA8E725uLL);
    if (!CCCryptorUpdate(*(CCCryptorRef *)buf, [v5 bytes], (size_t)v13, v11, OutputLength, &dataOutMoved)&& !CCCryptorFinal(*(CCCryptorRef *)buf, &v11[dataOutMoved], OutputLength - dataOutMoved, &v19))
    {
      id v16 = objc_alloc((Class)NSData);
      if (a1) {
        size_t v17 = OutputLength;
      }
      else {
        size_t v17 = v19 + dataOutMoved;
      }
      id v12 = objc_msgSend(v16, "initWithBytesNoCopy:length:freeWhenDone:", v11, v17, 1, v18);
      goto LABEL_18;
    }
  }
  id v12 = 0;
LABEL_18:
  if (*(void *)buf) {
    CCCryptorRelease(*(CCCryptorRef *)buf);
  }
  if (!v12 && v11) {
    free(v11);
  }
LABEL_23:

  return v12;
}

void sub_1001BAB94(id a1)
{
  off_100A4A978 = (uint64_t (*)(void, void, void, void, void))IMWeakLinkSymbol();
}

void sub_1001BABC4(id a1)
{
  off_100A4A988 = (uint64_t (*)(void, void, void))IMWeakLinkSymbol();
}

void sub_1001BABF4(uint64_t a1)
{
  memset_s(*(void **)(a1 + 32), 0x10uLL, 0, 0x10uLL);
  uint64_t v2 = *(void **)(a1 + 32);

  free(v2);
}

void sub_1001BB900(id a1)
{
  off_100A4A998 = (uint64_t (*)(void, void, void))IMWeakLinkSymbol();
}

void sub_1001BB930(id a1)
{
  off_100A4A9A8 = (uint64_t (*)(void, void, void, void, void))IMWeakLinkSymbol();
}

void sub_1001BBA20(id a1)
{
  off_100A4A9B8 = (uint64_t (*)(void, void, void))IMWeakLinkSymbol();
}

void sub_1001BBA50(id a1)
{
  off_100A4A9C8 = (uint64_t (*)(void, void, void))IMWeakLinkSymbol();
}

id sub_1001BBA80()
{
  if (qword_100A4A9E0 != -1) {
    dispatch_once(&qword_100A4A9E0, &stru_100984E98);
  }
  uint64_t v0 = (void *)qword_100A4A9D8;

  return v0;
}

void sub_1001BBAD4(id a1)
{
  id v1 = objc_alloc_init((Class)+[FTMessageDelivery APNSMessageDeliveryClass]);
  uint64_t v2 = (void *)qword_100A4A9D8;
  qword_100A4A9D8 = (uint64_t)v1;

  uint64_t v3 = (void *)qword_100A4A9D8;
  uint64_t v4 = IMGetDomainIntForKey();
  if (v4 <= 0) {
    uint64_t v5 = 8;
  }
  else {
    uint64_t v5 = v4;
  }

  _[v3 setMaxConcurrentMessages:v5];
}

uint64_t sub_1001BBB48(void *a1, unsigned char *a2)
{
  id v3 = a1;
  if (!qword_100A4A9E8)
  {
    uint64_t v4 = (void **)IMWeakLinkSymbol();
    if (v4) {
      uint64_t v5 = *v4;
    }
    else {
      uint64_t v5 = 0;
    }
    objc_storeStrong((id *)&qword_100A4A9E8, v5);
  }
  id v6 = [v3 domain];
  unsigned int v7 = [v6 isEqualToString:IMRemoteURLConnectionErrorDomain];

  if (v7) {
    int v8 = [v3 code] == (id)-1;
  }
  else {
    int v8 = 0;
  }
  if ([v3 code] == (id)-1009)
  {
    BOOL v9 = 1;
    if (!a2) {
      goto LABEL_18;
    }
  }
  else
  {
    id v10 = [v3 domain];
    if ([v10 isEqualToString:FTErrorDomain]) {
      BOOL v9 = [v3 code] == (id)10000;
    }
    else {
      BOOL v9 = 0;
    }

    if (!a2) {
      goto LABEL_18;
    }
  }
  if (v9) {
    *a2 = 1;
  }
LABEL_18:
  id v11 = [v3 domain];
  if ([v11 isEqualToString:NSURLErrorDomain])
  {

LABEL_21:
    uint64_t v14 = (uint64_t)[v3 code];
    if (v14 <= -2)
    {
      switch(v14)
      {
        case -1019:
        case -1011:
        case -1009:
        case -1008:
        case -1006:
        case -1005:
        case -1004:
        case -1003:
        case -1002:
        case -1001:
        case -999:
        case -998:
          goto LABEL_23;
        case -1018:
        case -1017:
        case -1016:
        case -1015:
        case -1014:
        case -1013:
        case -1012:
        case -1010:
        case -1007:
        case -1000:
          goto LABEL_24;
        default:
          if (v14 == -2000 || v14 == -1200) {
            goto LABEL_23;
          }
          break;
      }
      goto LABEL_24;
    }
    if (v14 > 1)
    {
      if (v14 != 311 && v14 != 310 && v14 != 2) {
        goto LABEL_24;
      }
LABEL_23:
      LOBYTE(v8) = 1;
      goto LABEL_24;
    }
    if (v14 == -1) {
      goto LABEL_23;
    }
LABEL_41:
    if (v14 != 1) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }
  id v12 = [v3 domain];
  unsigned int v13 = [v12 isEqualToString:kCFErrorDomainCFNetwork];

  if (v13) {
    goto LABEL_21;
  }
  if (qword_100A4A9E8
    && ([v3 domain],
        id v16 = objc_claimAutoreleasedReturnValue(),
        unsigned int v17 = [v16 isEqualToString:qword_100A4A9E8],
        v16,
        v17))
  {
    if ((char *)[v3 code] - 4 < (char *)3) {
      LOBYTE(v8) = 1;
    }
  }
  else
  {
    CFStringRef v18 = [v3 domain];
    unsigned int v19 = [v18 isEqualToString:IDSRemoteURLConnectionErrorDomain];

    if (v19)
    {
      uint64_t v14 = (uint64_t)[v3 code];
      if (v14 == 2) {
        goto LABEL_23;
      }
      goto LABEL_41;
    }
    id v20 = [v3 domain];
    unsigned int v21 = [v20 isEqualToString:NSPOSIXErrorDomain];

    if (v21)
    {
      id v22 = (char *)[v3 code];
      if ((unint64_t)(v22 - 50) <= 0xF) {
        v8 |= 0xCC9Fu >> ((_BYTE)v22 - 50);
      }
    }
  }
LABEL_24:

  return v8 & 1;
}

uint64_t sub_1001BBE88(void *a1)
{
  id v1 = a1;
  uint64_t v2 = [v1 domain];
  if ([v2 isEqualToString:NSURLErrorDomain])
  {
  }
  else
  {
    id v3 = [v1 domain];
    unsigned int v4 = [v3 isEqualToString:kCFErrorDomainCFNetwork];

    if (!v4)
    {
      int v8 = [v1 domain];
      unsigned int v9 = [v8 isEqualToString:NSPOSIXErrorDomain];

      if (v9)
      {
        id v10 = (char *)[v1 code];
        if ((unint64_t)(v10 - 52) <= 0xD) {
          uint64_t v6 = (0x3327u >> ((_BYTE)v10 - 52)) & 1;
        }
        else {
          uint64_t v6 = 0;
        }
      }
      else
      {
        uint64_t v6 = 0;
      }
      goto LABEL_7;
    }
  }
  uint64_t v5 = (uint64_t)[v1 code];
  uint64_t v6 = 0;
  if (v5 > -2)
  {
    if (v5 > 309)
    {
      if (v5 != 310 && v5 != 311) {
        goto LABEL_7;
      }
    }
    else if (v5 != -1 && v5 != 2)
    {
      goto LABEL_7;
    }
LABEL_6:
    uint64_t v6 = 1;
    goto LABEL_7;
  }
  switch(v5)
  {
    case -1011:
    case -1008:
    case -1004:
    case -1002:
    case -1001:
    case -999:
    case -998:
      goto LABEL_6;
    case -1010:
    case -1009:
    case -1007:
    case -1006:
    case -1005:
    case -1003:
    case -1000:
      break;
    default:
      if (v5 == -2000 || v5 == -1200) {
        goto LABEL_6;
      }
      break;
  }
LABEL_7:

  return v6;
}

uint64_t sub_1001BC02C(uint64_t result)
{
  if (result > 5199)
  {
    if (result <= 6999)
    {
      switch(result)
      {
        case 6000:
          id result = 71;
          break;
        case 6001:
          id result = 94;
          break;
        case 6002:
          id result = 95;
          break;
        case 6003:
          id result = 96;
          break;
        case 6004:
          id result = 97;
          break;
        case 6005:
          id result = 98;
          break;
        case 6006:
          id result = 101;
          break;
        case 6007:
          return result;
        case 6008:
          id result = 99;
          break;
        case 6009:
          id result = 100;
          break;
        case 6010:
          id result = 102;
          break;
        case 6011:
          id result = 103;
          break;
        case 6012:
          id result = 104;
          break;
        case 6013:
          id result = 105;
          break;
        default:
          switch(result)
          {
            case 5200:
              id result = 86;
              break;
            case 5201:
              id result = 87;
              break;
            case 5202:
              id result = 88;
              break;
            case 5203:
              id result = 89;
              break;
            case 5204:
              id result = 91;
              break;
            case 5205:
              id result = 90;
              break;
            case 5206:
              id result = 92;
              break;
            case 5207:
              id result = 93;
              break;
            default:
              return result;
          }
          break;
      }
    }
    else
    {
      if (result == 20001) {
        int v1 = 74;
      }
      else {
        int v1 = result;
      }
      if (result == 20000) {
        int v2 = 74;
      }
      else {
        int v2 = v1;
      }
      if (result == 10000) {
        unsigned int v3 = 73;
      }
      else {
        unsigned int v3 = v2;
      }
      if (result == 8001) {
        int v4 = 72;
      }
      else {
        int v4 = result;
      }
      if (result == 8000) {
        int v5 = 72;
      }
      else {
        int v5 = v4;
      }
      if (result == 7000) {
        unsigned int v6 = 77;
      }
      else {
        unsigned int v6 = v5;
      }
      if (result <= 9999) {
        return v6;
      }
      else {
        return v3;
      }
    }
  }
  else if (result <= 4999)
  {
    if (result > 999)
    {
      switch(result)
      {
        case 1000:
          id result = 70;
          break;
        case 1001:
          id result = 78;
          break;
        case 1002:
          id result = 79;
          break;
        case 1003:
          id result = 80;
          break;
        case 1004:
          id result = 81;
          break;
        case 1005:
          id result = 82;
          break;
        case 1006:
          id result = 83;
          break;
        default:
          return result;
      }
    }
    else if (result <= 439)
    {
      if (result == 200) {
        unsigned int v7 = 2;
      }
      else {
        unsigned int v7 = result;
      }
      if (result == 1) {
        unsigned int v7 = 0;
      }
      if (result) {
        return v7;
      }
      else {
        return 1;
      }
    }
    else
    {
      switch(result)
      {
        case 440:
          id result = 108;
          break;
        case 441:
          id result = 106;
          break;
        case 442:
          id result = 107;
          break;
        case 443:
          id result = 109;
          break;
        default:
          return result;
      }
    }
  }
  else
  {
    switch(result)
    {
      case 5000:
        id result = 3;
        break;
      case 5001:
        id result = 4;
        break;
      case 5002:
        id result = 5;
        break;
      case 5003:
        id result = 6;
        break;
      case 5004:
        id result = 7;
        break;
      case 5005:
        id result = 8;
        break;
      case 5006:
        id result = 9;
        break;
      case 5007:
        id result = 10;
        break;
      case 5008:
        id result = 11;
        break;
      case 5009:
        id result = 12;
        break;
      case 5010:
        id result = 13;
        break;
      case 5011:
        id result = 14;
        break;
      case 5012:
        id result = 15;
        break;
      case 5013:
        id result = 16;
        break;
      case 5014:
        id result = 17;
        break;
      case 5015:
        id result = 18;
        break;
      case 5016:
        id result = 19;
        break;
      case 5017:
        id result = 20;
        break;
      case 5018:
        id result = 21;
        break;
      case 5019:
        id result = 22;
        break;
      case 5020:
        id result = 23;
        break;
      case 5021:
        id result = 24;
        break;
      case 5022:
        id result = 25;
        break;
      case 5023:
        id result = 26;
        break;
      case 5024:
        id result = 27;
        break;
      case 5025:
        id result = 28;
        break;
      case 5026:
        id result = 29;
        break;
      case 5027:
        id result = 30;
        break;
      case 5028:
        id result = 31;
        break;
      case 5029:
        id result = 32;
        break;
      case 5030:
        id result = 33;
        break;
      case 5031:
        id result = 34;
        break;
      case 5032:
        id result = 35;
        break;
      case 5033:
        id result = 36;
        break;
      case 5034:
        id result = 37;
        break;
      case 5035:
        id result = 41;
        break;
      case 5036:
        id result = 42;
        break;
      case 5037:
        id result = 43;
        break;
      case 5038:
        id result = 44;
        break;
      case 5039:
        id result = 38;
        break;
      case 5040:
        id result = 39;
        break;
      case 5041:
        id result = 40;
        break;
      case 5046:
        id result = 45;
        break;
      case 5047:
        id result = 46;
        break;
      case 5048:
        id result = 47;
        break;
      case 5051:
        id result = 48;
        break;
      case 5052:
        id result = 49;
        break;
      case 5055:
        id result = 76;
        break;
      case 5057:
        id result = 50;
        break;
      case 5058:
        id result = 51;
        break;
      case 5059:
        id result = 52;
        break;
      case 5060:
        id result = 53;
        break;
      case 5061:
        id result = 54;
        break;
      case 5062:
        id result = 55;
        break;
      case 5063:
        id result = 56;
        break;
      case 5064:
        id result = 57;
        break;
      case 5068:
        id result = 58;
        break;
      case 5076:
        id result = 64;
        break;
      case 5078:
        id result = 59;
        break;
      case 5079:
        id result = 60;
        break;
      case 5080:
        id result = 61;
        break;
      case 5085:
        id result = 65;
        break;
      case 5086:
        id result = 66;
        break;
      case 5087:
        id result = 67;
        break;
      case 5088:
        id result = 68;
        break;
      case 5089:
        id result = 62;
        break;
      case 5090:
        id result = 63;
        break;
      case 5092:
        id result = 69;
        break;
      case 5099:
        id result = 75;
        break;
      case 5100:
        id result = 84;
        break;
      case 5103:
        id result = 85;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t sub_1001BC738(uint64_t result)
{
  if ((unint64_t)(result + 2) <= 0x33) {
    return dword_100794490[result + 2];
  }
  return result;
}

void sub_1001BC7A8(id a1)
{
  qword_100A4A9F0 = IMWeakLinkClass();
}

void sub_1001BCE58(id a1)
{
  qword_100A4AA08 = objc_alloc_init(IDSAppleIDNotificationCenter);

  _objc_release_x1();
}

void sub_1001BD05C(id a1, IDSAppleIDNotificationCenter *a2)
{
}

void sub_1001BD064(id a1, IDSAppleIDNotificationCenter *a2)
{
}

id sub_1001BD7EC(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  id v5 = v3;
  if (IDSIsiMessageRegistrationServiceType()
    || (unsigned int v6 = v5, IDSIsFaceTimeRegistrationServiceType()))
  {
    unsigned int v6 = IMLocalizedStringFromTableInBundle();
  }

  return v6;
}

void sub_1001BD8A8(id *a1, void *a2)
{
  id v3 = [a2 response];
  BOOL v17 = v3 == 0;
  id v4 = +[IMRGLog registration];
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v5)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, " => User hit no, ignoring", buf, 2u);
    }

    unsigned int v6 = (uint64_t *)(a1 + 4);
    if ([a1[4] length])
    {
      unsigned int v7 = 0;
LABEL_10:
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      id v8 = a1[5];
      id v9 = [v8 countByEnumeratingWithState:&v23 objects:v28 count:16];
      if (v9)
      {
        id v10 = v9;
        uint64_t v11 = *(void *)v24;
        do
        {
          for (uint64_t i = 0; i != v10; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v24 != v11) {
              objc_enumerationMutation(v8);
            }
            unsigned int v13 = [a1[6] objectForKey:*(void *)(*((void *)&v23 + 1) + 8 * i)];
            if (v13)
            {
              uint64_t v14 = im_primary_queue();
              block[0] = _NSConcreteStackBlock;
              block[1] = 3221225472;
              block[2] = sub_1001BDB28;
              block[3] = &unk_100980A68;
              id v21 = v13;
              BOOL v22 = v17;
              id v15 = v7;
              uint64_t v16 = *v6;
              id v19 = v15;
              uint64_t v20 = v16;
              dispatch_async(v14, block);
            }
          }
          id v10 = [v8 countByEnumeratingWithState:&v23 objects:v28 count:16];
        }
        while (v10);
      }
    }
  }
  else
  {
    if (v5)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, " => User hit yes, adding and validating", buf, 2u);
    }

    unsigned int v6 = (uint64_t *)(a1 + 4);
    if ([a1[4] length])
    {
      unsigned int v7 = IMSingleObjectArray();
      goto LABEL_10;
    }
  }
}

uint64_t sub_1001BDB28(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void))(*(void *)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned __int8 *)(a1 + 56), *(void *)(a1 + 32), *(void *)(a1 + 40));
}

void sub_1001BE374(id a1, NSError *a2)
{
  id v3 = +[IMRGLog registration];
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v4)
    {
      __int16 v8 = 0;
      BOOL v5 = "Error posting new device notification.";
      unsigned int v6 = (uint8_t *)&v8;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, v5, v6, 2u);
    }
  }
  else if (v4)
  {
    __int16 v7 = 0;
    BOOL v5 = "Posted new device notification.";
    unsigned int v6 = (uint8_t *)&v7;
    goto LABEL_6;
  }
}

id sub_1001BF508(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_1001BF5EC;
  v10[3] = &unk_100984FA8;
  id v11 = v3;
  id v5 = objc_alloc_init((Class)NSMutableSet);
  id v12 = v5;
  id v6 = v3;
  [v4 enumerateObjectsUsingBlock:v10];

  __int16 v7 = v12;
  id v8 = v5;

  return v8;
}

void sub_1001BF5EC(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = *(void **)(a1 + 32);
  id v8 = v3;
  id v5 = [v3 prefixedURI];
  id v6 = [v4 objectForKeyedSubscript:v5];
  unsigned __int8 v7 = [v6 BOOLValue];

  if ((v7 & 1) == 0) {
    [*(id *)(a1 + 40) addObject:v8];
  }
}

uint64_t sub_1001BF67C(void *a1, void *a2, void *a3, void *a4)
{
  id v7 = a4;
  id v8 = a3;
  id v9 = sub_1001BF508(a1, a2);
  id v10 = sub_1001BF508(v8, v7);

  uint64_t v11 = [v9 isEqualToSet:v10] ^ 1;
  return v11;
}

uint64_t sub_1001C0E68()
{
  qword_100A4AA10 = CSDBCreateThreadedRecordStoreWithQOSClassAndLookAsideBufferConfig();

  return _objc_release_x1();
}

void sub_1001C0EB0()
{
}

void sub_1001C0EBC(uint64_t a1, void *a2)
{
  id v2 = a2;
  os_unfair_lock_assert_owner((const os_unfair_lock *)&unk_100A4AA20);
  sub_10000627C();
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  CSDBPerformUnlockedSectionForQueryForWriting();
}

void sub_1001C0F28(uint64_t a1, void *a2)
{
  id v2 = a2;
  os_unfair_lock_assert_owner((const os_unfair_lock *)&unk_100A4AA20);
  sub_10000627C();
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  CSDBPerformUnlockedSectionForQueryForReading();
}

void sub_1001C0F94()
{
  os_unfair_lock_assert_owner((const os_unfair_lock *)&unk_100A4AA20);
  sub_10000627C();
  id v0 = (id)objc_claimAutoreleasedReturnValue();
  CSDBPerformLockedSectionForRecordStoreWithoutInitialize();
}

void sub_1001C0FE8(id a1, CSDBRecordStore *a2)
{
}

uint64_t sub_1001C0FF0()
{
  os_unfair_lock_assert_owner((const os_unfair_lock *)&unk_100A4AA20);

  return CSDBSqliteSetDefaultPageCacheSize();
}

id sub_1001C1130(uint64_t a1)
{
  id v1 = *(id *)(a1 + 32);
  uint64_t v3 = CSDBGetMobileUserDirectory();
  if (v3)
  {
    uint64_t v4 = v3;
    id v5 = +[NSProcessInfo processInfo];
    id v6 = [v5 processName];

    id v7 = +[NSString stringWithFormat:@"ids-firewall-%@.db", v6];

    if ([v1 length])
    {
      v14[0] = v1;
      v14[1] = v7;
      id v8 = +[NSArray arrayWithObjects:v14 count:2];
      id v9 = +[NSString pathWithComponents:v8];
    }
    else
    {
      id v10 = +[NSString stringWithUTF8String:v4];
      uint64_t v11 = +[NSArray arrayWithObjects:v10, @"/Library/IdentityServices/", v7, 0];
      id v9 = +[NSString pathWithComponents:v11];
    }
    id v12 = v9;
    [v12 fileSystemRepresentation];
    CSDBGetMobileUserUID();
    CSDBGetMobileUserGID();
    CSDBCreateDirectoriesToPath();
    id v1 = [v12 stringByResolvingAndStandardizingPath];
  }
  return v1;
}

uint64_t sub_1001C1304()
{
  CSDBRecordStoreCreateTablesForClass();
  id v0 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)id v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Creating indexes as needed for faster lookup", v2, 2u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  CSDBSqliteConnectionPerformSQL();
  return CSDBSqliteConnectionPerformSQL();
}

uint64_t sub_1001C13FC()
{
  id v0 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Enabling auto vacuum.", buf, 2u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  CSDBSqliteConnectionPerformSQL();
  id v1 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)id v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "Enabling WAL journal mode.", v5, 2u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  CSDBSqliteConnectionPerformSQL();
  id v2 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Enabling Foreign Key support.", v4, 2u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  return CSDBSqliteConnectionPerformSQL();
}

BOOL sub_1001C162C(uint64_t a1, uint64_t a2, unsigned int a3)
{
  _IMWarn();
  unsigned int v4 = a3 >> 7;
  if (v4 <= 0x7C) {
    _IMWarn();
  }
  return v4 < 0x7D;
}

uint64_t sub_1001C1688()
{
  return 0;
}

void sub_1001C1690(id a1, CSDBThreadedRecordStore *a2)
{
}

void sub_1001C16A0(void *a1, void *a2, void *a3, void *a4)
{
  id v12 = a1;
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if ([v7 length])
  {
    id v10 = +[FTPasswordManager sharedInstance];
    uint64_t v11 = [v7 lowercaseString];
    [v10 setPasswordForProfileID:v8 username:v11 service:v9 password:v12 outRequestID:0 completionBlock:&stru_100985268];
  }
}

void sub_1001C177C(id a1, NSString *a2, NSString *a3, NSString *a4, BOOL a5)
{
  BOOL v5 = a5;
  id v7 = a3;
  id v8 = a4;
  id v9 = +[IMRGLog registration];
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v10 = @"NO";
    int v11 = 138412802;
    id v12 = v7;
    __int16 v13 = 2112;
    if (v5) {
      CFStringRef v10 = @"YES";
    }
    uint64_t v14 = v8;
    __int16 v15 = 2112;
    CFStringRef v16 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Successfully updated password for account (%@:%@): %@", (uint8_t *)&v11, 0x20u);
  }
}

void sub_1001C1878(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  id v15 = a1;
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  if ([v9 length])
  {
    __int16 v13 = +[FTPasswordManager sharedInstance];
    uint64_t v14 = [v9 lowercaseString];
    [v13 setAuthTokenForProfileID:v10 username:v14 service:v12 authToken:v15 selfHandle:v11 accountStatus:&off_1009D1800 outRequestID:0 completionBlock:&stru_100985288];
  }
}

void sub_1001C1970(id a1, NSString *a2, NSString *a3, NSString *a4, BOOL a5)
{
  BOOL v5 = a5;
  id v7 = a3;
  id v8 = a4;
  id v9 = +[IMRGLog registration];
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v10 = @"NO";
    int v11 = 138412802;
    id v12 = v7;
    __int16 v13 = 2112;
    if (v5) {
      CFStringRef v10 = @"YES";
    }
    uint64_t v14 = v8;
    __int16 v15 = 2112;
    CFStringRef v16 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Successfully updated auth token for account (%@:%@): %@", (uint8_t *)&v11, 0x20u);
  }
}

void sub_1001C2838(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v4 = +[IMRGLog registration];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    id v6 = *(void **)(a1 + 40);
    *(_DWORD *)buf = 138412546;
    uint64_t v34 = v5;
    __int16 v35 = 2112;
    id v36 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Transaction ID %@  messageContext %@", buf, 0x16u);
  }

  if ([*(id *)(a1 + 32) length])
  {
    id v7 = +[IMRGLog registration];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void *)(a1 + 48);
      *(_DWORD *)buf = 138412546;
      uint64_t v34 = v8;
      __int16 v35 = 2112;
      id v36 = v3;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Notifying listener %@ that account %@  is setup", buf, 0x16u);
    }

    id v9 = *(id *)(a1 + 56);
    if (!v9)
    {
      CFStringRef v10 = [v3 accountInfo];
      int v11 = [v10 objectForKey:kIDSServiceDefaultsRegistrationInfoKey];
      uint64_t v12 = kIDSServiceDefaultsRegistrationInfoErrorCodeKey;
      __int16 v13 = [v11 objectForKey:kIDSServiceDefaultsRegistrationInfoErrorCodeKey];
      unsigned int v14 = [v13 intValue];

      if (v14 == -1)
      {
        id v9 = 0;
      }
      else
      {
        __int16 v15 = [v11 objectForKey:kIDSServiceDefaultsRegistrationInfoAlertInfoKey];
        CFStringRef v16 = [v11 objectForKey:v12];
        id v17 = [v16 integerValue];

        id v18 = objc_alloc((Class)NSError);
        id v9 = [v18 initWithDomain:IDSAccountRegistrationErrorDomain code:v17 userInfo:v15];
        id v19 = +[IMRGLog warning];
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
          sub_100716214();
        }
      }
    }
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    uint64_t v20 = objc_msgSend(v3, "accountAndAdHocAccounts", 0);
    id v21 = [v20 countByEnumeratingWithState:&v28 objects:v32 count:16];
    if (v21)
    {
      id v22 = v21;
      uint64_t v23 = *(void *)v29;
      do
      {
        long long v24 = 0;
        do
        {
          if (*(void *)v29 != v23) {
            objc_enumerationMutation(v20);
          }
          long long v25 = *(void **)(*((void *)&v28 + 1) + 8 * (void)v24);
          long long v26 = [*(id *)(a1 + 64) listenerRemoteObjectForLocalObject:*(void *)(a1 + 48)];
          __int16 v27 = [v25 uniqueID];
          [v26 setupCompleteForAccount:v27 transactionID:*(void *)(a1 + 32) setupError:v9];

          long long v24 = (char *)v24 + 1;
        }
        while (v22 != v24);
        id v22 = [v20 countByEnumeratingWithState:&v28 objects:v32 count:16];
      }
      while (v22);
    }

    if (*(id *)(a1 + 56) != v9)
    {

      id v9 = 0;
    }
  }
}

void sub_1001C2B88(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v4 = +[IMRGLog registration];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = [v3 uniqueID];
    *(_DWORD *)buf = 138412290;
    __int16 v15 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Calling out to linked account: %@", buf, 0xCu);
  }
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1001C2D00;
  v8[3] = &unk_1009852B0;
  id v9 = *(id *)(a1 + 32);
  id v10 = *(id *)(a1 + 40);
  id v11 = *(id *)(a1 + 48);
  id v6 = *(id *)(a1 + 56);
  uint64_t v7 = *(void *)(a1 + 64);
  id v12 = v6;
  uint64_t v13 = v7;
  [v3 setupAccountWithCompletionBlock:v8];
}

void sub_1001C2D00(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v4 = +[IMRGLog registration];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    id v6 = *(void **)(a1 + 40);
    *(_DWORD *)buf = 138412546;
    uint64_t v34 = v5;
    __int16 v35 = 2112;
    id v36 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Linked account Transaction ID %@  messageContext %@", buf, 0x16u);
  }

  if ([*(id *)(a1 + 32) length])
  {
    uint64_t v7 = +[IMRGLog registration];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void *)(a1 + 48);
      *(_DWORD *)buf = 138412546;
      uint64_t v34 = v8;
      __int16 v35 = 2112;
      id v36 = v3;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Notifying listener %@ that linked account %@  is setup", buf, 0x16u);
    }

    id v9 = *(id *)(a1 + 56);
    if (!v9)
    {
      id v10 = [v3 accountInfo];
      id v11 = [v10 objectForKey:kIDSServiceDefaultsRegistrationInfoKey];
      uint64_t v12 = kIDSServiceDefaultsRegistrationInfoErrorCodeKey;
      uint64_t v13 = [v11 objectForKey:kIDSServiceDefaultsRegistrationInfoErrorCodeKey];
      unsigned int v14 = [v13 intValue];

      if (v14 == -1)
      {
        id v9 = 0;
      }
      else
      {
        __int16 v15 = [v11 objectForKey:kIDSServiceDefaultsRegistrationInfoAlertInfoKey];
        CFStringRef v16 = [v11 objectForKey:v12];
        id v17 = [v16 integerValue];

        id v18 = objc_alloc((Class)NSError);
        id v9 = [v18 initWithDomain:IDSAccountRegistrationErrorDomain code:v17 userInfo:v15];
        id v19 = +[IMRGLog warning];
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
          sub_10071627C();
        }
      }
    }
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    uint64_t v20 = objc_msgSend(v3, "accountAndAdHocAccounts", 0);
    id v21 = [v20 countByEnumeratingWithState:&v28 objects:v32 count:16];
    if (v21)
    {
      id v22 = v21;
      uint64_t v23 = *(void *)v29;
      do
      {
        long long v24 = 0;
        do
        {
          if (*(void *)v29 != v23) {
            objc_enumerationMutation(v20);
          }
          long long v25 = *(void **)(*((void *)&v28 + 1) + 8 * (void)v24);
          long long v26 = [*(id *)(a1 + 64) listenerRemoteObjectForLocalObject:*(void *)(a1 + 48)];
          __int16 v27 = [v25 uniqueID];
          [v26 setupCompleteForAccount:v27 transactionID:0 setupError:v9];

          long long v24 = (char *)v24 + 1;
        }
        while (v22 != v24);
        id v22 = [v20 countByEnumeratingWithState:&v28 objects:v32 count:16];
      }
      while (v22);
    }

    if (*(id *)(a1 + 56) != v9)
    {

      id v9 = 0;
    }
  }
}

void sub_1001C390C(id a1, id a2)
{
  id v2 = a2;
  id v3 = [v2 uniqueID];
  unsigned int v4 = +[IMRGLog registration];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 138412290;
    uint64_t v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Removing linked account: %@", (uint8_t *)&v6, 0xCu);
  }

  uint64_t v5 = +[IDSDAccountController sharedInstance];
  [v5 removeAccount:v2];
}

void sub_1001C3BAC(id a1, id a2)
{
  id v2 = a2;
  id v3 = [v2 uniqueID];
  unsigned int v4 = +[IMRGLog registration];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 138412290;
    uint64_t v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Disabling and removing linked account: %@", (uint8_t *)&v7, 0xCu);
  }

  [v2 unregisterAccount];
  uint64_t v5 = +[IDSDAccountController sharedInstance];
  [v5 disableAccountWithUniqueID:v3];

  int v6 = +[IDSDAccountController sharedInstance];
  [v6 removeAccount:v2];
}

void sub_1001C4170(id a1, id a2)
{
  id v2 = a2;
  id v3 = +[IMRGLog registration];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v4 = [v2 uniqueID];
    int v7 = 138412290;
    uint64_t v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Enabling linked account: %@", (uint8_t *)&v7, 0xCu);
  }
  uint64_t v5 = +[IDSDAccountController sharedInstance];
  int v6 = [v2 uniqueID];
  [v5 enableAccountWithUniqueID:v6];

  [v2 registerAccount];
}

void sub_1001C43E0(id a1, id a2)
{
  id v2 = a2;
  id v3 = +[IMRGLog registration];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v4 = [v2 uniqueID];
    int v7 = 138412290;
    uint64_t v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Disabling linked account: %@", (uint8_t *)&v7, 0xCu);
  }
  uint64_t v5 = +[IDSDAccountController sharedInstance];
  int v6 = [v2 uniqueID];
  [v5 disableAccountWithUniqueID:v6];
}

void sub_1001C4648(id a1, id a2)
{
  id v2 = a2;
  id v3 = +[IMRGLog registration];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v4 = [v2 uniqueID];
    int v7 = 138412290;
    uint64_t v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Disabling linked account: %@", (uint8_t *)&v7, 0xCu);
  }
  uint64_t v5 = +[IDSDAccountController sharedInstance];
  int v6 = [v2 uniqueID];
  [v5 disableAccountWithUniqueID:v6];
}

void sub_1001C4958(id a1, id a2)
{
  id v2 = a2;
  id v3 = +[IMRGLog registration];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v4 = [v2 uniqueID];
    int v5 = 138412290;
    int v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Calling out to linked account: %@", (uint8_t *)&v5, 0xCu);
  }
  [v2 authenticationChanged];
}

void sub_1001C4C50(id a1, id a2)
{
  id v2 = a2;
  id v3 = +[IMRGLog registration];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v4 = [v2 uniqueID];
    int v5 = 138412290;
    int v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Calling out to linked account: %@", (uint8_t *)&v5, 0xCu);
  }
  [v2 authenticationChanged];
}

void sub_1001C4E60(id a1, id a2)
{
  id v2 = a2;
  id v3 = +[IMRGLog registration];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v4 = [v2 uniqueID];
    int v5 = 138412290;
    int v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Calling out to linked account: %@", (uint8_t *)&v5, 0xCu);
  }
  [v2 authenticateAccount];
}

void sub_1001C5070(id a1, id a2)
{
  id v2 = a2;
  id v3 = +[IMRGLog registration];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v4 = [v2 uniqueID];
    int v5 = 138412290;
    int v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Calling out to linked account: %@", (uint8_t *)&v5, 0xCu);
  }
  [v2 passwordUpdated];
}

void sub_1001C5324(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v4 = +[IMRGLog registration];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = [v3 uniqueID];
    int v6 = 138412290;
    int v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Calling out to linked account: %@", (uint8_t *)&v6, 0xCu);
  }
  [v3 updateAuthorizationCredentials:*(void *)(a1 + 32) token:*(void *)(a1 + 40)];
}

void sub_1001C553C(id a1, id a2)
{
  id v2 = a2;
  id v3 = +[IMRGLog registration];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v4 = [v2 uniqueID];
    int v5 = 138412290;
    int v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Calling out to linked account: %@", (uint8_t *)&v5, 0xCu);
  }
  [v2 validateProfile];
}

void sub_1001C57C4(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v4 = +[IMRGLog registration];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = [v3 uniqueID];
    int v6 = 138412290;
    int v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Calling out to linked account: %@", (uint8_t *)&v6, 0xCu);
  }
  [v3 addAliases:*(void *)(a1 + 32)];
}

void sub_1001C5A54(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v4 = +[IMRGLog registration];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = [v3 uniqueID];
    int v6 = 138412290;
    int v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Calling out to linked account: %@", (uint8_t *)&v6, 0xCu);
  }
  [v3 removeAliases:*(void *)(a1 + 32)];
}

void sub_1001C5CE4(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v4 = +[IMRGLog registration];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = [v3 uniqueID];
    int v6 = 138412290;
    int v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Calling out to linked account: %@", (uint8_t *)&v6, 0xCu);
  }
  [v3 validateAliases:*(void *)(a1 + 32)];
}

void sub_1001C5F74(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v4 = +[IMRGLog registration];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = [v3 uniqueID];
    int v6 = 138412290;
    int v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Calling out to linked account: %@", (uint8_t *)&v6, 0xCu);
  }
  [v3 unvalidateAliases:*(void *)(a1 + 32)];
}

void sub_1001C6184(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1001C619C(uint64_t a1, void *a2)
{
  id v3 = a2;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  id v4 = *(id *)(a1 + 32);
  id v5 = [v4 countByEnumeratingWithState:&v20 objects:v27 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v21;
    uint64_t v19 = kIDSStatusKitPublishingForStatusTypeEntitlement;
    uint64_t v18 = kIDSStatusKitPublishingForAllStatusTypeEntitlement;
    uint64_t v17 = kIDSStatusKitSubscriptionForStatusTypeEntitlement;
    uint64_t v16 = kIDSStatusKitSubscriptionForAllStatusTypeEntitlement;
    while (2)
    {
      for (uint64_t i = 0; i != v6; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v21 != v7) {
          objc_enumerationMutation(v4);
        }
        id v9 = *(void **)(*((void *)&v20 + 1) + 8 * i);
        unsigned __int8 v10 = objc_msgSend(v9, "isEqualToIgnoringCase:", @"com.apple.private.alloy.status.keysharing", v16, v17, v18, v19, (void)v20);
        uint64_t v11 = *(void *)(*(void *)(a1 + 56) + 8);
        if (v10)
        {
          if (*(unsigned char *)(v11 + 24))
          {
            uint64_t v12 = *(void **)(a1 + 40);
            v26[0] = v19;
            v26[1] = v18;
            v26[2] = v17;
            v26[3] = v16;
            uint64_t v13 = +[NSArray arrayWithObjects:v26 count:4];
            *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = [v12 client:v3 isEntitledToAccessService:0 forAnyOfEntitlements:v13 shouldWarn:1];
          }
          else
          {
            *(unsigned char *)(v11 + 24) = 0;
          }
        }
        else
        {
          if (*(unsigned char *)(v11 + 24))
          {
            unsigned __int8 v14 = [*(id *)(a1 + 40) client:v3 isEntitledToAccessService:v9 forEntitlement:*(void *)(a1 + 48) shouldWarn:1];
            uint64_t v11 = *(void *)(*(void *)(a1 + 56) + 8);
          }
          else
          {
            unsigned __int8 v14 = 0;
          }
          *(unsigned char *)(v11 + 24) = v14;
        }
        if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24))
        {
          __int16 v15 = +[IMRGLog registration];
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412290;
            long long v25 = v9;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Pseudonym request failed entitlement check for service %@", buf, 0xCu);
          }

          goto LABEL_21;
        }
      }
      id v6 = [v4 countByEnumeratingWithState:&v20 objects:v27 count:16];
      if (v6) {
        continue;
      }
      break;
    }
  }
LABEL_21:
}

void sub_1001C65E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1001C6604(uint64_t a1, void *a2)
{
  id v3 = a2;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  id v4 = *(id *)(a1 + 32);
  id v5 = [v4 countByEnumeratingWithState:&v19 objects:v24 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v20;
    uint64_t v17 = kIDSStatusKitPublishingForAllStatusTypeEntitlement;
    uint64_t v18 = kIDSStatusKitPublishingForStatusTypeEntitlement;
    uint64_t v16 = kIDSStatusKitSubscriptionForStatusTypeEntitlement;
    uint64_t v8 = kIDSStatusKitSubscriptionForAllStatusTypeEntitlement;
LABEL_3:
    uint64_t v9 = 0;
    while (1)
    {
      if (*(void *)v20 != v7) {
        objc_enumerationMutation(v4);
      }
      unsigned __int8 v10 = *(void **)(*((void *)&v19 + 1) + 8 * v9);
      unsigned __int8 v11 = [v10 isEqualToIgnoringCase:@"com.apple.private.alloy.status.keysharing"];
      uint64_t v12 = *(void *)(*(void *)(a1 + 56) + 8);
      if (v11)
      {
        if (*(unsigned char *)(v12 + 24))
        {
          *(unsigned char *)(v12 + 24) = 1;
        }
        else
        {
          unsigned __int8 v14 = *(void **)(a1 + 40);
          v23[0] = v18;
          v23[1] = v17;
          v23[2] = v16;
          v23[3] = v8;
          __int16 v15 = +[NSArray arrayWithObjects:v23 count:4];
          *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = [v14 client:v3 isEntitledToAccessService:0 forAnyOfEntitlements:v15 shouldWarn:1];
        }
      }
      else
      {
        if (*(unsigned char *)(v12 + 24))
        {
          unsigned __int8 v13 = 1;
        }
        else
        {
          unsigned __int8 v13 = [*(id *)(a1 + 40) client:v3 isEntitledToAccessService:v10 forEntitlement:*(void *)(a1 + 48) shouldWarn:1];
          uint64_t v12 = *(void *)(*(void *)(a1 + 56) + 8);
        }
        *(unsigned char *)(v12 + 24) = v13;
      }
      if (*(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24)) {
        break;
      }
      if (v6 == (id)++v9)
      {
        id v6 = [v4 countByEnumeratingWithState:&v19 objects:v24 count:16];
        if (v6) {
          goto LABEL_3;
        }
        break;
      }
    }
  }
}

uint64_t sub_1001C6C90()
{
  id v0 = +[IDSServerBag sharedInstanceForBagType:0];
  id v1 = [v0 objectForKey:@"enable-pseudonym-aliases"];
  if (v1 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    uint64_t v2 = (uint64_t)[v1 BOOLValue];
  }
  else {
    uint64_t v2 = 1;
  }

  return v2;
}

void sub_1001C6D20(void *a1, void *a2, uint64_t a3, void *a4)
{
  uint64_t v7 = (void *)a1[4];
  uint64_t v8 = a1[5];
  id v9 = a4;
  id v10 = a2;
  id v11 = [v7 listenerRemoteObjectForLocalObject:v8];
  [v11 finishedProvisioningPseudonym:v10 success:a3 error:v9 forRequestUUID:a1[6]];
}

void sub_1001C725C(void *a1, void *a2, uint64_t a3, void *a4)
{
  uint64_t v7 = (void *)a1[4];
  uint64_t v8 = a1[5];
  id v9 = a4;
  id v10 = a2;
  id v11 = [v7 listenerRemoteObjectForLocalObject:v8];
  [v11 finishedRenewingPseudonym:v10 success:a3 error:v9 requestUUID:a1[6]];
}

void sub_1001C7774(void *a1, uint64_t a2, void *a3)
{
  id v5 = (void *)a1[4];
  uint64_t v6 = a1[5];
  id v7 = a3;
  id v8 = [v5 listenerRemoteObjectForLocalObject:v6];
  [v8 finishedRevokingPseudonymWithSuccess:a2 error:v7 requestUUID:a1[6]];
}

void sub_1001C7B68(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (v3)
  {
    uint64_t v5 = IDSServiceReportingErrorDomain;
    NSErrorUserInfoKey v9 = NSUnderlyingErrorKey;
    id v10 = v3;
    uint64_t v6 = +[NSDictionary dictionaryWithObjects:&v10 forKeys:&v9 count:1];
    id v7 = +[NSError errorWithDomain:v5 code:200 userInfo:v6];
  }
  else
  {
    id v7 = 0;
  }
  id v8 = [*(id *)(a1 + 32) listenerRemoteObjectForLocalObject:*(void *)(a1 + 40)];
  [v8 finishedReportingRequestUUID:*(void *)(a1 + 48) withError:v7];
}

void sub_1001C7DA4(id a1, id a2)
{
  id v2 = a2;
  id v3 = +[IMRGLog registration];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    id v4 = [v2 uniqueID];
    int v5 = 138412290;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Calling out to linked account: %@", (uint8_t *)&v5, 0xCu);
  }
  [v2 registerAccount];
}

void sub_1001C7FB4(id a1, id a2)
{
  id v2 = a2;
  id v3 = +[IMRGLog registration];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    id v4 = [v2 uniqueID];
    int v5 = 138412290;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Calling out to linked account: %@", (uint8_t *)&v5, 0xCu);
  }
  [v2 unregisterAccount];
}

void sub_1001C8470(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IMRGLog registration];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = [v3 uniqueID];
    int v6 = 138412290;
    id v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Calling out to linked account: %@", (uint8_t *)&v6, 0xCu);
  }
  objc_msgSend(v3, "_reregisterAndReidentify:", objc_msgSend(*(id *)(a1 + 32), "BOOLValue"));
}

void sub_1001C8690(id a1, id a2)
{
  id v2 = a2;
  id v3 = +[IMRGLog registration];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    id v4 = [v2 uniqueID];
    int v5 = 138412290;
    int v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Calling out to linked account: %@", (uint8_t *)&v5, 0xCu);
  }
  [v2 deactivateAndPurgeIdentify];
}

void sub_1001C8E58(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 32));
  _Unwind_Resume(a1);
}

void sub_1001C8E90(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  xpc_activity_state_t state = xpc_activity_get_state(v3);
  if (state == 2)
  {
    id v11 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v12 = @"YES";
      if (!v3) {
        CFStringRef v12 = @"NO";
      }
      *(_DWORD *)buf = 138412290;
      CFStringRef v16 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Got called to checkpoint Registration Account Status Metric run state with non null activity %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      CFStringRef v13 = @"YES";
      if (!v3) {
        CFStringRef v13 = @"NO";
      }
      CFStringRef v14 = v13;
      _IDSLogV();
    }
    objc_msgSend(WeakRetained, "_submitRegistrationAccountStatusMetric", v14);
  }
  else if (!state)
  {
    int v6 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v7 = @"YES";
      if (!v3) {
        CFStringRef v7 = @"NO";
      }
      *(_DWORD *)buf = 138412290;
      CFStringRef v16 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Told to Check In for Registration Account Status Metric with activity %@ ", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_string(v8, XPC_ACTIVITY_PRIORITY, XPC_ACTIVITY_PRIORITY_MAINTENANCE);
    xpc_dictionary_set_int64(v8, XPC_ACTIVITY_INTERVAL, 43200);
    xpc_object_t v9 = xpc_activity_copy_criteria(v3);
    id v10 = v9;
    if (!v9 || !xpc_equal(v9, v8)) {
      xpc_activity_set_criteria(v3, v8);
    }
  }
}

void sub_1001C92A8(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 32));
  _Unwind_Resume(a1);
}

void sub_1001C92E0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  xpc_activity_state_t state = xpc_activity_get_state(v3);
  if (state == 2)
  {
    id v11 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v12 = @"YES";
      if (!v3) {
        CFStringRef v12 = @"NO";
      }
      *(_DWORD *)buf = 138412290;
      CFStringRef v16 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Got called to checkpoint Registration Event Tracker Cleanup run state with non null activity %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      CFStringRef v13 = @"YES";
      if (!v3) {
        CFStringRef v13 = @"NO";
      }
      CFStringRef v14 = v13;
      _IDSLogV();
    }
    xpc_object_t v8 = objc_msgSend(WeakRetained, "persistenceManager", v14);
    [v8 cleanupOldRegistrationEvents];
    goto LABEL_24;
  }
  if (!state)
  {
    int v6 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v7 = @"YES";
      if (!v3) {
        CFStringRef v7 = @"NO";
      }
      *(_DWORD *)buf = 138412290;
      CFStringRef v16 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Told to Check In for Registration Event Tracker Cleanup with activity %@ ", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_string(v8, XPC_ACTIVITY_PRIORITY, XPC_ACTIVITY_PRIORITY_MAINTENANCE);
    xpc_dictionary_set_int64(v8, XPC_ACTIVITY_INTERVAL, XPC_ACTIVITY_INTERVAL_1_DAY);
    xpc_dictionary_set_BOOL(v8, XPC_ACTIVITY_REQUIRES_CLASS_C, 1);
    xpc_object_t v9 = xpc_activity_copy_criteria(v3);
    id v10 = v9;
    if (!v9 || !xpc_equal(v9, v8)) {
      xpc_activity_set_criteria(v3, v8);
    }

LABEL_24:
  }
}

void sub_1001C9724(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 32));
  _Unwind_Resume(a1);
}

void sub_1001C975C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  xpc_activity_state_t state = xpc_activity_get_state(v3);
  if (state == 2)
  {
    CFStringRef v12 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v13 = @"YES";
      if (!v3) {
        CFStringRef v13 = @"NO";
      }
      *(_DWORD *)buf = 138412290;
      CFStringRef v17 = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Got called to checkpoint Sender Key Cleanup run state with non null activity %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      CFStringRef v14 = @"YES";
      if (!v3) {
        CFStringRef v14 = @"NO";
      }
      CFStringRef v15 = v14;
      _IDSLogV();
    }
    xpc_object_t v8 = objc_msgSend(WeakRetained, "persistenceManager", v15);
    [v8 cleanupInvalidSenderKeyEntriesWithCompletion:&stru_1009854E8];
    goto LABEL_24;
  }
  if (!state)
  {
    int v6 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v7 = @"YES";
      if (!v3) {
        CFStringRef v7 = @"NO";
      }
      *(_DWORD *)buf = 138412290;
      CFStringRef v17 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Told to Check In for Sender Key Cleanup with activity %@ ", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_string(v8, XPC_ACTIVITY_PRIORITY, XPC_ACTIVITY_PRIORITY_MAINTENANCE);
    +[IDSSenderKeyDistributionManager cleanupKeysTimeInterval];
    xpc_dictionary_set_int64(v8, XPC_ACTIVITY_INTERVAL, (uint64_t)v9);
    xpc_object_t v10 = xpc_activity_copy_criteria(v3);
    id v11 = v10;
    if (!v10 || !xpc_equal(v10, v8)) {
      xpc_activity_set_criteria(v3, v8);
    }

LABEL_24:
  }
}

void sub_1001C9B34(id a1, OS_xpc_object *a2)
{
  uint64_t v2 = a2;
  xpc_activity_state_t state = xpc_activity_get_state(v2);
  if (state == 2)
  {
    xpc_object_t v10 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v11 = @"YES";
      if (!v2) {
        CFStringRef v11 = @"NO";
      }
      *(_DWORD *)buf = 138412290;
      CFStringRef v15 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Got called to checkpoint Query DB cleanup run state with non null activity %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      CFStringRef v12 = @"YES";
      if (!v2) {
        CFStringRef v12 = @"NO";
      }
      CFStringRef v13 = v12;
      _IDSLogV();
    }
    int v6 = +[IDSPeerIDManager sharedInstance];
    [v6 performCleanupTasks];
    goto LABEL_24;
  }
  if (!state)
  {
    id v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v5 = @"YES";
      if (!v2) {
        CFStringRef v5 = @"NO";
      }
      *(_DWORD *)buf = 138412290;
      CFStringRef v15 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Told to Check In for Query DB cleanup with activity %@ ", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    int v6 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_string(v6, XPC_ACTIVITY_PRIORITY, XPC_ACTIVITY_PRIORITY_MAINTENANCE);
    +[IDSQuerySDPersistenceManager dbCleanupTimeInterval];
    xpc_dictionary_set_int64(v6, XPC_ACTIVITY_INTERVAL, (uint64_t)v7);
    xpc_object_t v8 = xpc_activity_copy_criteria(v2);
    double v9 = v8;
    if (!v8 || !xpc_equal(v8, v6)) {
      xpc_activity_set_criteria(v2, v6);
    }

LABEL_24:
  }
}

void sub_1001CA468(_Unwind_Exception *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  if (a2 == 1)
  {
    objc_begin_catch(exc_buf);
    objc_end_catch();
    JUMPOUT(0x1001CA3B4);
  }
  _Block_object_dispose(&a17, 8);
  _Unwind_Resume(exc_buf);
}

id sub_1001CA4C8(uint64_t a1, uint64_t a2)
{
  id result = [*(id *)(a1 + 32) client:a2 isEntitledToAccessService:0 forEntitlement:kIDSStateResetEntitlement shouldWarn:1];
  if (result) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
  }
  return result;
}

void sub_1001CA8E4(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (objc_msgSend(*(id *)(a1 + 32), "client:isEntitledToAccessService:forEntitlement:shouldWarn:")
    && (![*(id *)(a1 + 40) count]
     || [*(id *)(a1 + 32) client:v3 isEntitledToAccessService:0 forEntitlement:kIDSPreferInfraWiFiEntitlement shouldWarn:1]))
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
  }
}

void sub_1001CAC50(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (objc_msgSend(*(id *)(a1 + 32), "client:isEntitledToAccessService:forEntitlement:shouldWarn:")
    && (![*(id *)(a1 + 40) count]
     || [*(id *)(a1 + 32) client:v3 isEntitledToAccessService:0 forEntitlement:kIDSPreferInfraWiFiEntitlement shouldWarn:1]))
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
  }
}

void sub_1001CBE50(id a1, NSString *a2, NSString *a3, NSString *a4, BOOL a5)
{
  BOOL v5 = a5;
  int v6 = +[IMRGLog registration];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v7 = @"NO";
    if (v5) {
      CFStringRef v7 = @"YES";
    }
    int v8 = 138412290;
    CFStringRef v9 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Finished setting password {success: %@}", (uint8_t *)&v8, 0xCu);
  }
}

id sub_1001CC808(uint64_t a1, uint64_t a2)
{
  id result = [*(id *)(a1 + 32) client:a2 isEntitledToAccessService:*(void *)(a1 + 40) forEntitlement:kIDSDeviceUUIDEntitlement shouldWarn:1];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
  return result;
}

void sub_1001CC858(id a1)
{
  id v1 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Sending continuity reset to IDS clients", v3, 2u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      _IDSLogTransport();
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
  }
  uint64_t v2 = +[IDSWPLinkManager sharedInstance];
  [v2 sendReset];
}

void sub_1001CCD08(id a1)
{
  id v1 = +[IMRGLog registration];
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "   => posting deferred device update", buf, 2u);
  }

  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  uint64_t v2 = +[IDSDAccountController sharedInstance];
  id v3 = [v2 enabledAccounts];

  id v4 = [v3 countByEnumeratingWithState:&v13 objects:v18 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v14;
    do
    {
      CFStringRef v7 = 0;
      do
      {
        if (*(void *)v14 != v6) {
          objc_enumerationMutation(v3);
        }
        uint64_t v8 = *(void *)(*((void *)&v13 + 1) + 8 * (void)v7);
        CFStringRef v9 = +[IDSDAccountController sharedInstance];
        xpc_object_t v10 = [v9 accountWithUniqueID:v8];

        if (v10)
        {
          v11[0] = _NSConcreteStackBlock;
          v11[1] = 3221225472;
          _DWORD v11[2] = sub_1001CCEF8;
          void v11[3] = &unk_1009826E0;
          id v12 = v10;
          [v12 _broadcastAccountMessageBlock:v11];
        }
        CFStringRef v7 = (char *)v7 + 1;
      }
      while (v5 != v7);
      id v5 = [v3 countByEnumeratingWithState:&v13 objects:v18 count:16];
    }
    while (v5);
  }
}

void sub_1001CCEF8(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSDaemon sharedInstance];
  id v5 = [v3 service];
  uint64_t v6 = [v5 pushTopic];
  CFStringRef v7 = [v4 broadcasterForTopic:v6 ignoreServiceListener:1 messageContext:0];

  uint64_t v8 = [v3 dependentRegistrations];
  if (![v8 count])
  {
    CFStringRef v9 = [*(id *)(a1 + 32) dependentRegistrations];
    id v10 = [v9 count];

    if (v10)
    {
      CFStringRef v11 = +[IMRGLog warning];
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100716450();
      }
    }
  }
  id v12 = [v3 uniqueID];
  [v7 account:v12 dependentDevicesUpdated:v8];
}

uint64_t sub_1001CDC00(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (*(unsigned char *)(v1 + 403) == 2) {
    *(unsigned char *)(v1 + 403) = 3;
  }
  return result;
}

uint64_t sub_1001CDC28(void *a1)
{
  if ([a1 isGuest]) {
    return 3;
  }
  else {
    return 0;
  }
}

void sub_1001CDD50(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2555915];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setGuid:*(void *)(a1 + 40)];
    objc_msgSend(v2, "setSessionProtocolVersionNumber:", objc_msgSend(*(id *)(a1 + 48), "unsignedIntValue"));
    [v2 setServiceName:*(void *)(a1 + 56)];
    [v2 setClientType:*(unsigned int *)(a1 + 64)];
    [*(id *)(a1 + 32) _submitIDSSessionAWDMetric:v2 withContainer:v3];
  }
}

void sub_1001CDEDC(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2555916];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setGuid:*(void *)(a1 + 40)];
    objc_msgSend(v2, "setNumberOfRecipients:", objc_msgSend(*(id *)(a1 + 48), "intValue"));
    [*(id *)(a1 + 32) _submitIDSSessionAWDMetric:v2 withContainer:v3];
  }
}

void sub_1001CE024(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2555917];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setGuid:*(void *)(a1 + 40)];
    [*(id *)(a1 + 32) _submitIDSSessionAWDMetric:v2 withContainer:v3];
  }
}

void sub_1001CE18C(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2555918];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setGuid:*(void *)(a1 + 40)];
    objc_msgSend(v2, "setNumberOfRecipients:", objc_msgSend(*(id *)(a1 + 48), "intValue"));
    [v2 setRemoteSessionEndReason:*(unsigned int *)(a1 + 56)];
    [*(id *)(a1 + 32) _submitIDSSessionAWDMetric:v2 withContainer:v3];
  }
}

void sub_1001CE2E0(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2555919];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setGuid:*(void *)(a1 + 40)];
    [*(id *)(a1 + 32) _submitIDSSessionAWDMetric:v2 withContainer:v3];
  }
}

void sub_1001CE414(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2555927];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setGuid:*(void *)(a1 + 40)];
    [*(id *)(a1 + 32) _submitIDSSessionAWDMetric:v2 withContainer:v3];
  }
}

void sub_1001CE548(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2555928];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setGuid:*(void *)(a1 + 40)];
    [*(id *)(a1 + 32) _submitIDSSessionAWDMetric:v2 withContainer:v3];
  }
}

void sub_1001CE67C(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2555920];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setGuid:*(void *)(a1 + 40)];
    [*(id *)(a1 + 32) _submitIDSSessionAWDMetric:v2 withContainer:v3];
  }
}

void sub_1001CE7B0(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2555921];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setGuid:*(void *)(a1 + 40)];
    [*(id *)(a1 + 32) _submitIDSSessionAWDMetric:v2 withContainer:v3];
  }
}

void sub_1001CE8E4(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2555922];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setGuid:*(void *)(a1 + 40)];
    [*(id *)(a1 + 32) _submitIDSSessionAWDMetric:v2 withContainer:v3];
  }
}

void sub_1001CEA18(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2555923];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setGuid:*(void *)(a1 + 40)];
    [*(id *)(a1 + 32) _submitIDSSessionAWDMetric:v2 withContainer:v3];
  }
}

void sub_1001CEB4C(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2555924];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setGuid:*(void *)(a1 + 40)];
    [*(id *)(a1 + 32) _submitIDSSessionAWDMetric:v2 withContainer:v3];
  }
}

void sub_1001CEC80(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) _metricContainerForMetricType:2555925];
  if (v3)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setGuid:*(void *)(a1 + 40)];
    [*(id *)(a1 + 32) _submitIDSSessionAWDMetric:v2 withContainer:v3];
  }
}

void sub_1001CEF2C(uint64_t a1)
{
  id v7 = [*(id *)(a1 + 32) _metricContainerForMetricType:2555926];
  if (v7)
  {
    id v4 = objc_alloc_init((Class)IMWeakLinkClass());
    [*(id *)(a1 + 40) floatValue];
    LODWORD(v1) = vcvtas_u32_f32(v5 * 1000.0);
    [*(id *)(a1 + 48) floatValue];
    LODWORD(v2) = vcvtas_u32_f32(v6 * 1000.0);
    [v4 setGuid:*(void *)(a1 + 56)];
    objc_msgSend(v4, "setSessionProtocolVersionNumber:", objc_msgSend(*(id *)(a1 + 64), "unsignedIntValue"));
    [v4 setServiceName:*(void *)(a1 + 72)];
    [v4 setClientType:*(unsigned int *)(a1 + 80)];
    [v4 setIsQREnabled:*(unsigned __int8 *)(a1 + 120)];
    [v4 setIsUsingQRDirectly:*(unsigned __int8 *)(a1 + 121)];
    [v4 setIsInitiator:*(unsigned __int8 *)(a1 + 122)];
    [v4 setIsLegacySessionType:*(unsigned __int8 *)(a1 + 123)];
    [v4 setIsWithDefaultPairedDevice:*(unsigned __int8 *)(a1 + 124)];
    [v4 setTransportType:*(unsigned int *)(a1 + 88)];
    [v4 setLinkType:*(unsigned int *)(a1 + 96)];
    [v4 setLinkProtocol:*(unsigned int *)(a1 + 104)];
    [v4 setEndedReason:*(unsigned int *)(a1 + 112)];
    [v4 setDurationOfSession:v1];
    [v4 setDurationToConnect:v2];
    [v4 setIsNetworkEnabled:*(unsigned __int8 *)(a1 + 125)];
    [v4 setIsNetworkActive:*(unsigned __int8 *)(a1 + 126)];
    [v4 setIsNetworkReachable:*(unsigned __int8 *)(a1 + 127)];
    [v4 setIsWifiInterfaceDisallowed:*(unsigned __int8 *)(a1 + 128)];
    [v4 setIsCellularInterfaceDisallowed:*(unsigned __int8 *)(a1 + 129)];
    [v4 setDestinationType:*(unsigned int *)(a1 + 116)];
    [*(id *)(a1 + 32) _submitIDSSessionAWDMetric:v4 withContainer:v7];
  }
}

void sub_1001CF390(uint64_t a1)
{
  id v5 = [*(id *)(a1 + 32) _metricContainerForMetricType:2588679];
  if (v5)
  {
    id v2 = objc_alloc_init((Class)IMWeakLinkClass());
    [v2 setGuid:*(void *)(a1 + 40)];
    [v2 setEndedReason:*(unsigned int *)(a1 + 120)];
    [v2 setGenericError:*(unsigned int *)(a1 + 124)];
    [v2 setGameKitError:*(unsigned int *)(a1 + 128)];
    [v2 setConferenceMiscError:*(unsigned int *)(a1 + 132)];
    [*(id *)(a1 + 48) doubleValue];
    IDSAWDLogFuzzTimeTo10sSecondsForHotShip();
    [v2 setCallDuration:v3];
    [v2 setIsNetworkEnabled:*(unsigned __int8 *)(a1 + 152)];
    [v2 setIsNetworkActive:*(unsigned __int8 *)(a1 + 153)];
    [v2 setIsNetworkReachable:*(unsigned __int8 *)(a1 + 154)];
    [v2 setNetworkCheckResult:*(unsigned int *)(a1 + 136)];
    [*(id *)(a1 + 56) unsignedIntValue];
    IDSAWDLogGenerateDataRate();
    [v2 setDataRate:v4];
    objc_msgSend(v2, "setGksError:", objc_msgSend(*(id *)(a1 + 64), "unsignedIntValue"));
    objc_msgSend(v2, "setConnectDuration:", objc_msgSend(*(id *)(a1 + 72), "unsignedIntValue"));
    [v2 setRemoteNetworkConnection:*(unsigned int *)(a1 + 140)];
    [v2 setLocalNetworkConnection:*(unsigned int *)(a1 + 144)];
    [v2 setConnectionType:*(unsigned int *)(a1 + 148)];
    [v2 setUsesRelay:*(unsigned __int8 *)(a1 + 155)];
    objc_msgSend(v2, "setCurrentNatType:", objc_msgSend(*(id *)(a1 + 80), "unsignedIntValue"));
    objc_msgSend(v2, "setRemoteNatType:", objc_msgSend(*(id *)(a1 + 88), "unsignedIntValue"));
    objc_msgSend(v2, "setRemoteNetworkConnection:", objc_msgSend(*(id *)(a1 + 88), "unsignedIntValue"));
    objc_msgSend(v2, "setRelayConnectDuration:", objc_msgSend(*(id *)(a1 + 96), "unsignedIntValue"));
    [v2 setIsInitiator:*(unsigned __int8 *)(a1 + 156)];
    objc_msgSend(v2, "setLinkQuality:", objc_msgSend(*(id *)(a1 + 104), "intValue"));
    objc_msgSend(v2, "setGksReturnCode:", objc_msgSend(*(id *)(a1 + 112), "intValue"));
    [*(id *)(a1 + 32) _submitIDSSessionAWDMetric:v2 withContainer:v5];
  }
}

void sub_1001CF58C(id a1)
{
  qword_100A4AA30 = objc_alloc_init(IDSDeliveryController);

  _objc_release_x1();
}

void sub_1001CFA58(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 24));
  _Unwind_Resume(a1);
}

void sub_1001CFA7C(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v7 = (id *)(a1 + 32);
  id v8 = a5;
  id v9 = a3;
  id v10 = a2;
  long long v15 = (id *)objc_loadWeakRetained(v7);
  CFStringRef v11 = [v8 pushToken];

  id v12 = [v9 prefixedURI];

  long long v13 = [v15 _tokenURIForToken:v11 uri:v12];

  long long v14 = +[IDSDeliveryController tokenURINegativeCacheItemForTokenURI:v13 service:v10];

  if (v14) {
    [v15[4] clearItem:v14];
  }
}

uint64_t sub_1001CFDF0(uint64_t a1)
{
  uint64_t v2 = +[IDSPushHandler sharedInstanceWithPortName:@"com.apple.identityservicesd.aps"];
  unsigned int v3 = [v2 isConnected];

  if (v3)
  {
    double v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      id v5 = [*(id *)(a1 + 32) count];
      *(_DWORD *)buf = 134217984;
      id v28 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Push is still connected - replaying %lu offline message sends.", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      id v21 = [*(id *)(a1 + 32) count];
      _IDSLogV();
    }
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    id v7 = *(void **)(a1 + 32);
    float v6 = (id *)(a1 + 32);
    id v8 = v7;
    id v9 = [v8 countByEnumeratingWithState:&v22 objects:v26 count:16];
    if (v9)
    {
      uint64_t v10 = *(void *)v23;
      do
      {
        CFStringRef v11 = 0;
        do
        {
          if (*(void *)v23 != v10) {
            objc_enumerationMutation(v8);
          }
          uint64_t v12 = *(void *)(*((void *)&v22 + 1) + 8 * (void)v11);
          (*(void (**)(uint64_t))(v12 + 16))(v12);
          CFStringRef v11 = (char *)v11 + 1;
        }
        while (v9 != v11);
        id v9 = [v8 countByEnumeratingWithState:&v22 objects:v26 count:16];
      }
      while (v9);
    }

    long long v14 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      id v15 = [*v6 count];
      *(_DWORD *)buf = 134217984;
      id v28 = v15;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Done replaying %lu offline message sends.", buf, 0xCu);
    }

    uint64_t result = os_log_shim_legacy_logging_enabled();
    if (result)
    {
      uint64_t result = _IDSShouldLog();
      if (result) {
        goto LABEL_31;
      }
    }
  }
  else
  {
    CFStringRef v17 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      id v18 = [*(id *)(a1 + 32) count];
      *(_DWORD *)buf = 134217984;
      id v28 = v18;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Push is NOT still connected - readding %lu offline message sends.", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      id v21 = [*(id *)(a1 + 32) count];
      _IDSLogV();
    }
    if (objc_msgSend(*(id *)(*(void *)(a1 + 40) + 24), "count", v21)) {
      [*(id *)(a1 + 32) addObjectsFromArray:*(void *)(*(void *)(a1 + 40) + 24)];
    }
    objc_storeStrong((id *)(*(void *)(a1 + 40) + 24), *(id *)(a1 + 32));
    long long v19 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      id v20 = [*(id *)(*(void *)(a1 + 40) + 24) count];
      *(_DWORD *)buf = 134217984;
      id v28 = v20;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Total offline message sends enqueued: %lu.", buf, 0xCu);
    }

    uint64_t result = os_log_shim_legacy_logging_enabled();
    if (result)
    {
      uint64_t result = _IDSShouldLog();
      if (result)
      {
        float v6 = (id *)(*(void *)(a1 + 40) + 24);
LABEL_31:
        objc_msgSend(*v6, "count", v21);
        return _IDSLogV();
      }
    }
  }
  return result;
}

void sub_1001D01F4(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1001D0164);
  }
  _Unwind_Resume(a1);
}

void sub_1001D0A84(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1001D0654);
  }
  _Unwind_Resume(a1);
}

void sub_1001D0F8C(void *a1, void *a2)
{
  id v3 = a2;
  double v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = a1[4];
    uint64_t v6 = a1[5];
    *(_DWORD *)buf = 138412546;
    uint64_t v16 = v5;
    __int16 v17 = 2112;
    uint64_t v18 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "  Finished sending message: %@  to accessory: %@", buf, 0x16u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v13 = a1[4];
    uint64_t v14 = a1[5];
    _IDSLogV();
  }
  id v7 = objc_msgSend(v3, "deliveryError", v13, v14);

  if (v7)
  {
    id v8 = [v3 deliveryError];
    id v9 = +[NSDictionary dictionaryWithObjectsAndKeys:](NSDictionary, "dictionaryWithObjectsAndKeys:", v8, NSUnderlyingErrorKey, 0);

    id v10 = objc_alloc((Class)NSError);
    id v11 = [v10 initWithDomain:IDSSendErrorDomain code:21 userInfo:v9];
    [v3 setIdsResponseCode:21];
    [v3 setResponseError:v11];
    uint64_t v12 = a1[6];
    if (v12) {
      (*(void (**)(uint64_t, id))(v12 + 16))(v12, v3);
    }
  }
  else if (a1[6])
  {
    [v3 setIdsResponseCode:0];
    (*(void (**)(void))(a1[6] + 16))();
  }
}

void sub_1001D3044(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1001D2CE4);
  }
  _Unwind_Resume(a1);
}

void sub_1001D3068(uint64_t a1, void *a2, void *a3, const __CFString *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a5;
  uint64_t v12 = (__CFString *)v9;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v13 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      id v14 = [(__CFString *)v12 targetToken];
      *(_DWORD *)buf = 138412546;
      CFStringRef v57 = v12;
      __int16 v58 = 2112;
      id v59 = v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "    Delivered FTMessage: %@ to token: %@", buf, 0x16u);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      [(__CFString *)v12 targetToken];
      v55 = __int16 v54 = v12;
      _IDSLogV();
    }
  }
  else
  {
    id v15 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      CFStringRef v57 = v12;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "    Delivered FTMessage: %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      __int16 v54 = v12;
      _IDSLogV();
    }
  }
  uint64_t v16 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    CFStringRef v57 = a4;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "                  Result code: %ld", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    __int16 v54 = (void *)a4;
    _IDSLogV();
  }
  __int16 v17 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v18 = *(const __CFString **)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    CFStringRef v57 = v18;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "                        To ID: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    __int16 v54 = *(void **)(a1 + 32);
    _IDSLogV();
  }
  long long v19 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v20 = *(const __CFString **)(a1 + 40);
    *(_DWORD *)buf = 138412290;
    CFStringRef v57 = v20;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "                      From ID: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    __int16 v54 = *(void **)(a1 + 40);
    _IDSLogV();
  }
  id v21 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    CFStringRef v57 = v11;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "            Result dictionary: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    __int16 v54 = v11;
    _IDSLogV();
  }
  long long v22 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    CFStringRef v57 = v10;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "                        Error: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    __int16 v54 = v10;
    _IDSLogV();
  }
  long long v23 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    long long v24 = [(__CFString *)v12 wantsDeliveryStatus];
    unsigned int v25 = [v24 intValue];
    CFStringRef v26 = @"YES";
    if (!v25) {
      CFStringRef v26 = @"NO";
    }
    *(_DWORD *)buf = 138412290;
    CFStringRef v57 = v26;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "    Requested Delivery Status: %@", buf, 0xCu);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    __int16 v27 = [(__CFString *)v12 wantsDeliveryStatus];
    unsigned int v28 = [v27 intValue];
    CFStringRef v29 = @"YES";
    if (!v28) {
      CFStringRef v29 = @"NO";
    }
    __int16 v54 = (void *)v29;
    _IDSLogV();
  }
  long long v30 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v31 = [(__CFString *)v12 wantsCertifiedDelivery];
    CFStringRef v32 = @"NO";
    if (v31) {
      CFStringRef v32 = @"YES";
    }
    *(_DWORD *)buf = 138412290;
    CFStringRef v57 = v32;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, " Requested Certified Delivery: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    unsigned int v33 = [(__CFString *)v12 wantsCertifiedDelivery];
    CFStringRef v34 = @"NO";
    if (v33) {
      CFStringRef v34 = @"YES";
    }
    __int16 v54 = (void *)v34;
    _IDSLogV();
  }
  __int16 v35 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
  {
    id v36 = [(__CFString *)v12 messageBodyUsingCache];
    id v37 = [(__CFString *)v12 service];
    IDSLoggableDescriptionForObjectOnService();
    uint64_t v38 = (__CFString *)(id)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 138412290;
    CFStringRef v57 = v38;
    _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "                 Message Body: %@", buf, 0xCu);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v39 = [(__CFString *)v12 messageBodyUsingCache];
    char v40 = [(__CFString *)v12 service];
    __int16 v54 = IDSLoggableDescriptionForObjectOnService();
    _IDSLogV();
  }
  uint64_t v41 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Sending callback for FTMessage send", buf, 2u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  uint64_t v42 = *(void *)(a1 + 32);
  if (v42) {
    [*(id *)(a1 + 48) _processMessageResponse:v12 error:v10 resultCode:a4 toURI:v42 fromURI:*(void *)(a1 + 40) service:*(void *)(a1 + 56) fromIdentity:*(void *)(a1 + 64)];
  }
  uint64_t v43 = 0;
  if (a4 >= 2 && (a4 - 1002) >= 2) {
    uint64_t v43 = 2;
  }
  if (*(void *)(a1 + 80))
  {
    id v44 = [(__CFString *)v11 objectForKey:@"D"];

    if (v44)
    {
      id v45 = [(__CFString *)v11 objectForKey:@"D"];
      unsigned int v46 = [v45 BOOLValue];

      uint64_t v47 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v48 = @"NO";
        if (v46) {
          CFStringRef v48 = @"YES";
        }
        *(_DWORD *)buf = 138412290;
        CFStringRef v57 = v48;
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "Was accessory online?: %@", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        CFStringRef v49 = @"NO";
        if (v46) {
          CFStringRef v49 = @"YES";
        }
        __int16 v54 = (void *)v49;
        _IDSLogV();
      }
      if (v46)
      {
        id v44 = 0;
      }
      else
      {
        long long v50 = +[NSDictionary dictionaryWithObjectsAndKeys:](NSDictionary, "dictionaryWithObjectsAndKeys:", v10, NSUnderlyingErrorKey, 0);
        id v44 = +[NSError errorWithDomain:IDSSendErrorDomain code:21 userInfo:v50];
      }
    }
    if (v10)
    {
      long long v51 = +[NSDictionary dictionaryWithObjectsAndKeys:](NSDictionary, "dictionaryWithObjectsAndKeys:", v10, NSUnderlyingErrorKey, 0);
      uint64_t v52 = +[NSError errorWithDomain:IDSSendErrorDomain code:v43 userInfo:v51];

      id v44 = (void *)v52;
    }
    id v53 = [objc_alloc((Class)IDSDeliveryContext) initWithResponseCode:v43 error:v44 lastCall:1];
    [v53 setDisplayURIs:*(void *)(a1 + 72)];
    (*(void (**)(void, id))(*(void *)(a1 + 80) + 16))(*(void *)(a1 + 80), v53);
  }
  objc_msgSend(*(id *)(a1 + 48), "_checkFastDormancy", v54, v55);
}

void sub_1001D43C0(uint64_t a1, void *a2, void *a3, const __CFString *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a5;
  uint64_t v12 = (__CFString *)v9;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v13 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      id v14 = [(__CFString *)v12 targetToken];
      *(_DWORD *)buf = 138412546;
      CFStringRef v51 = v12;
      __int16 v52 = 2112;
      id v53 = v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "    Delivered FTMessage: %@ to token: %@", buf, 0x16u);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      [(__CFString *)v12 targetToken];
      v49 = CFStringRef v48 = v12;
      _IDSLogV();
    }
  }
  else
  {
    id v15 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      CFStringRef v51 = v12;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "    Delivered FTMessage: %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      CFStringRef v48 = v12;
      _IDSLogV();
    }
  }
  uint64_t v16 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    CFStringRef v51 = a4;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "                  Result code: %ld", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    CFStringRef v48 = (void *)a4;
    _IDSLogV();
  }
  __int16 v17 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v18 = *(const __CFString **)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    CFStringRef v51 = v18;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "              To Destinations: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    CFStringRef v48 = *(void **)(a1 + 32);
    _IDSLogV();
  }
  long long v19 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v20 = *(const __CFString **)(a1 + 40);
    *(_DWORD *)buf = 138412290;
    CFStringRef v51 = v20;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "                      From ID: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    CFStringRef v48 = *(void **)(a1 + 40);
    _IDSLogV();
  }
  id v21 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    CFStringRef v51 = v11;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "            Result dictionary: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    CFStringRef v48 = v11;
    _IDSLogV();
  }
  long long v22 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    CFStringRef v51 = v10;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "                        Error: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    CFStringRef v48 = v10;
    _IDSLogV();
  }
  long long v23 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    long long v24 = [(__CFString *)v12 wantsDeliveryStatus];
    unsigned int v25 = [v24 intValue];
    CFStringRef v26 = @"YES";
    if (!v25) {
      CFStringRef v26 = @"NO";
    }
    *(_DWORD *)buf = 138412290;
    CFStringRef v51 = v26;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "    Requested Delivery Status: %@", buf, 0xCu);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    __int16 v27 = [(__CFString *)v12 wantsDeliveryStatus];
    unsigned int v28 = [v27 intValue];
    CFStringRef v29 = @"YES";
    if (!v28) {
      CFStringRef v29 = @"NO";
    }
    CFStringRef v48 = (void *)v29;
    _IDSLogV();
  }
  long long v30 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v31 = [(__CFString *)v12 wantsCertifiedDelivery];
    CFStringRef v32 = @"NO";
    if (v31) {
      CFStringRef v32 = @"YES";
    }
    *(_DWORD *)buf = 138412290;
    CFStringRef v51 = v32;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, " Requested Certified Delivery: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    unsigned int v33 = [(__CFString *)v12 wantsCertifiedDelivery];
    CFStringRef v34 = @"NO";
    if (v33) {
      CFStringRef v34 = @"YES";
    }
    CFStringRef v48 = (void *)v34;
    _IDSLogV();
  }
  __int16 v35 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
  {
    id v36 = [(__CFString *)v12 messageBodyUsingCache];
    id v37 = [(__CFString *)v12 service];
    IDSLoggableDescriptionForObjectOnService();
    uint64_t v38 = (__CFString *)(id)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 138412290;
    CFStringRef v51 = v38;
    _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "                 Message Body: %@", buf, 0xCu);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v39 = [(__CFString *)v12 messageBodyUsingCache];
    char v40 = [(__CFString *)v12 service];
    CFStringRef v48 = IDSLoggableDescriptionForObjectOnService();
    _IDSLogV();
  }
  uint64_t v41 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Sending callback for FTMessage send", buf, 2u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  uint64_t v42 = 0;
  if (a4 >= 2 && (a4 - 1002) >= 2) {
    uint64_t v42 = 2;
  }
  if (*(void *)(a1 + 64))
  {
    if (v10)
    {
      uint64_t v43 = +[NSDictionary dictionaryWithObjectsAndKeys:](NSDictionary, "dictionaryWithObjectsAndKeys:", v10, NSUnderlyingErrorKey, 0);
      id v44 = +[NSError errorWithDomain:IDSSendErrorDomain code:v42 userInfo:v43];
    }
    else
    {
      id v44 = 0;
    }
    id v45 = [objc_alloc((Class)IDSDeliveryContext) initWithResponseCode:v42 error:v44 lastCall:1];
    [v45 setDisplayURIs:*(void *)(a1 + 48)];
    unsigned int v46 = [(__CFString *)v11 _numberForKey:@"e"];

    if (v46)
    {
      uint64_t v47 = [(__CFString *)v11 _numberForKey:@"e"];
      [v45 setResponseTimeStamp:v47];
    }
    if (!*(unsigned char *)(a1 + 72)) {
      [v45 setEndpointState:&off_1009D1818];
    }
    (*(void (**)(void, id))(*(void *)(a1 + 64) + 16))(*(void *)(a1 + 64), v45);
  }
  objc_msgSend(*(id *)(a1 + 56), "_checkFastDormancy", v48, v49);
}

void sub_1001D4DAC(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {

    objc_end_catch();
    JUMPOUT(0x1001D44C0);
  }
  _Unwind_Resume(a1);
}

void sub_1001D5554(id a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  id v7 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134218496;
    unint64_t v9 = a2;
    __int16 v10 = 2048;
    unint64_t v11 = a3;
    __int16 v12 = 2048;
    unint64_t v13 = a4;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Send attachment message progress updated to %lld of %lld (%lld bps)", buf, 0x20u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLog()) {
      _IDSLogV();
    }
  }
}

void sub_1001D5680(uint64_t a1, void *a2, int a3, void *a4, void *a5, void *a6, void *a7, void *a8, void *a9, uint64_t a10)
{
  id v60 = a2;
  id v63 = a4;
  id v58 = a5;
  id value = a6;
  id v61 = a7;
  id v64 = a8;
  id v59 = a9;
  if (a3)
  {
    __int16 v17 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      id v77 = v60;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Succeeded uploading file transfer: %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      id v48 = v60;
      _IDSLogV();
    }
    theDict = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
    if (value) {
      CFDictionarySetValue(theDict, @"mmcs-owner", value);
    }
    if (v64) {
      CFDictionarySetValue(theDict, @"mmcs-url", v64);
    }
    CFStringRef v18 = objc_msgSend(v61, "__imHexString", v48);
    if (v18) {
      CFDictionarySetValue(theDict, @"mmcs-signature-hex", v18);
    }

    id v19 = objc_alloc_init((Class)NSMutableDictionary);
    CFStringRef v20 = *(void **)(a1 + 32);
    v74[0] = _NSConcreteStackBlock;
    v74[1] = 3221225472;
    v74[2] = sub_1001D5EA8;
    v74[3] = &unk_100980928;
    id v65 = (__CFDictionary *)v19;
    long long v75 = v65;
    [v20 enumerateKeysAndObjectsUsingBlock:v74];
    id v21 = +[NSNumber numberWithInteger:104];
    if (v21)
    {
      CFDictionarySetValue(v65, IDSCommandKey, v21);
    }
    else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      sub_1007164C4();
    }

    uint64_t v38 = *(const void **)(a1 + 40);
    if (v38) {
      CFDictionarySetValue(v65, IDSOriginalCommandKey, v38);
    }
    uint64_t v39 = +[NSNumber numberWithUnsignedInteger:a10];
    if (v39) {
      CFDictionarySetValue(v65, IDSDataLengthKey, v39);
    }

    v70[0] = _NSConcreteStackBlock;
    v70[1] = 3221225472;
    v70[2] = sub_1001D5EB4;
    v70[3] = &unk_100985758;
    id v71 = *(id *)(a1 + 48);
    id v73 = *(id *)(a1 + 136);
    id v72 = *(id *)(a1 + 56);
    CFStringRef v57 = objc_retainBlock(v70);
    __int16 v56 = *(void **)(a1 + 64);
    char v40 = JWEncodeDictionary();
    BOOL v55 = *(unsigned char *)(a1 + 152) != 0;
    uint64_t v41 = *(void *)(a1 + 80);
    uint64_t v54 = *(void *)(a1 + 72);
    uint64_t v42 = *(void *)(a1 + 48);
    uint64_t v43 = *(void *)(a1 + 88);
    uint64_t v44 = *(void *)(a1 + 96);
    uint64_t v45 = *(void *)(a1 + 104);
    unsigned int v46 = [*(id *)(a1 + 64) _tokenURIForToken:*(void *)(a1 + 112) uri:v45];
    uint64_t v47 = IMSingleObjectArray();
    LOBYTE(v53) = 0;
    LOWORD(v52) = 0;
    BYTE2(v51) = 0;
    LOWORD(v51) = 0;
    LOBYTE(v50) = v41 != 0;
    LODWORD(v49) = 0x10000;
    objc_msgSend(v56, "_sendMessageDictionary:lastRetryInterval:dataToEncrypt:withEncryptedAttributes:onService:wantsResponse:canUseLargePayload:sendOnePerToken:allowPartialSendsToSucceed:highPriority:fireAndForget:expirationDate:enforceRemoteTimeouts:messageID:fromID:fromShortHandle:fromIdentity:toID:toURIs:accessToken:topic:registrationProperties:fakeMessage:alwaysSkipSelf:alwaysIncludeSelf:forceQuery:pushPriority:ignoreMaxRetryCount:disallowRefresh:originalTimestamp:prioritizedTokenList:wantsFirewallDonation:destinationObject:deliveryMinimumTimeDelay:deliveryMinimumTime:sendMode:KTURIVerificationMap:ackBlock:willSendBlock:sendCompletionBlock:", v65, v40, 0, v54, 0, v55, 0.0, v49, v41, v50, v42, v43,
      0,
      v44,
      v45,
      v47,
      0,
      *(void *)(a1 + 120),
      0,
      v51,
      0,
      0,
      v52,
      0,
      0,
      v53,
      *(void *)(a1 + 128),
      0,
      0,
      0,
      0,
      *(void *)(a1 + 144),
      0,
      v57);

    id v37 = (id *)&v75;
    id v36 = v71;
  }
  else
  {
    long long v22 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      long long v23 = *(void **)(a1 + 56);
      *(_DWORD *)buf = 138412290;
      id v77 = v23;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Failed uploading attachment file transfer: %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      id v48 = *(id *)(a1 + 56);
      _IDSLogV();
    }
    theDict = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
    if (v64) {
      CFDictionarySetValue(theDict, @"url", v64);
    }
    long long v24 = objc_msgSend(v63, "domain", v48);
    if (v24) {
      CFDictionarySetValue(theDict, @"eD", v24);
    }

    unsigned int v25 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [v63 code]);
    if (v25) {
      CFDictionarySetValue(theDict, @"eC", v25);
    }

    CFStringRef v26 = +[NSNumber numberWithInteger:a10];
    if (v26) {
      CFDictionarySetValue(theDict, @"fS", v26);
    }

    id v65 = [[IDSServerMessage alloc] initWithPayload:theDict command:&off_1009D1830];
    __int16 v27 = *(void **)(a1 + 64);
    unsigned int v28 = *(void **)(a1 + 120);
    v68[0] = _NSConcreteStackBlock;
    v68[1] = 3221225472;
    v68[2] = sub_1001D6114;
    v68[3] = &unk_100980FD8;
    id v69 = v28;
    [v27 sendIDSMessage:v65 service:0 topic:v69 completionBlock:v68];
    if (*(void *)(a1 + 136))
    {
      id v29 = objc_msgSend(objc_alloc((Class)NSDictionary), "initWithObjectsAndKeys:", @"Failed uploading attachment file transfer", NSLocalizedDescriptionKey, 0);
      id v30 = objc_alloc((Class)NSError);
      id v31 = [v30 initWithDomain:IDSSendErrorDomain code:4 userInfo:v29];
      id v32 = objc_msgSend(objc_alloc((Class)IDSDeliveryContext), "initWithResponseCode:error:lastCall:", objc_msgSend(v31, "code"), v31, 1);
      (*(void (**)(void))(*(void *)(a1 + 136) + 16))();
    }
    unsigned int v33 = +[NSFileManager defaultManager];
    uint64_t v34 = *(void *)(a1 + 56);
    id v67 = 0;
    unsigned __int8 v35 = [v33 removeItemAtPath:v34 error:&v67];
    id v36 = v67;

    id v37 = &v69;
    if ((v35 & 1) == 0 && _IMWillLog()) {
      _IMAlwaysLog();
    }
  }
}

id sub_1001D5EA8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [*(id *)(a1 + 32) setObject:a3 forKey:a2];
}

void sub_1001D5EB4(void *a1, void *a2)
{
  id v3 = a2;
  double v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = a1[4];
    id v6 = [v3 idsResponseCode];
    id v7 = [v3 responseError];
    unsigned int v8 = [v3 lastCall];
    CFStringRef v9 = @"NO";
    *(_DWORD *)buf = 138413058;
    uint64_t v26 = v5;
    __int16 v27 = 2048;
    if (v8) {
      CFStringRef v9 = @"YES";
    }
    id v28 = v6;
    __int16 v29 = 2112;
    id v30 = v7;
    __int16 v31 = 2112;
    CFStringRef v32 = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Finished sending attachment message %@. Result code: %ld. Error: %@   lastCall: %@", buf, 0x2Au);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v10 = a1[4];
    id v11 = [v3 idsResponseCode];
    __int16 v12 = [v3 responseError];
    unsigned int v13 = [v3 lastCall];
    CFStringRef v14 = @"NO";
    if (v13) {
      CFStringRef v14 = @"YES";
    }
    long long v22 = v12;
    CFStringRef v23 = v14;
    uint64_t v20 = v10;
    id v21 = v11;
    _IDSLogV();
  }
  uint64_t v15 = a1[6];
  if (v15) {
    (*(void (**)(uint64_t, id))(v15 + 16))(v15, v3);
  }
  uint64_t v16 = +[NSFileManager defaultManager];
  uint64_t v17 = a1[5];
  id v24 = 0;
  unsigned __int8 v18 = [v16 removeItemAtPath:v17 error:&v24];
  id v19 = v24;

  if ((v18 & 1) == 0 && _IMWillLog()) {
    _IMAlwaysLog();
  }
}

void sub_1001D6114(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    id v6 = [v3 idsResponseCode];
    id v7 = [v3 responseCode];
    unsigned int v8 = [v3 lastCall];
    CFStringRef v9 = @"NO";
    *(_DWORD *)buf = 138413058;
    uint64_t v11 = v5;
    __int16 v12 = 2048;
    if (v8) {
      CFStringRef v9 = @"YES";
    }
    id v13 = v6;
    __int16 v14 = 2048;
    id v15 = v7;
    __int16 v16 = 2112;
    CFStringRef v17 = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Update for uploadFailure message: topic %@  response %ld  error %ld lastCall %@", buf, 0x2Au);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    [v3 idsResponseCode];
    [v3 responseCode];
    [v3 lastCall];
    _IDSLogV();
  }
}

void sub_1001D7740(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {

    objc_end_catch();
    JUMPOUT(0x1001D72D8);
  }
  os_activity_scope_leave((os_activity_scope_state_t)&STACK[0x2C8]);
  cut_arc_os_release();
  _Unwind_Resume(a1);
}

void sub_1001D78C4(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog delivery_oversized];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    if (*(unsigned char *)(a1 + 56)) {
      CFStringRef v5 = @"YES";
    }
    else {
      CFStringRef v5 = @"NO";
    }
    uint64_t v6 = *(void *)(a1 + 48);
    int v7 = 138413058;
    uint64_t v8 = v3;
    __int16 v9 = 2112;
    uint64_t v10 = v4;
    __int16 v11 = 2112;
    CFStringRef v12 = v5;
    __int16 v13 = 2112;
    uint64_t v14 = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Message: %@ to be sent to people: %@   (have tokens: %@). People to query %@", (uint8_t *)&v7, 0x2Au);
  }
}

void sub_1001D79B0(uint64_t a1, void *a2, void *a3, void *a4, void *a5, int a6, void *a7, int a8, void *a9)
{
  id v92 = a2;
  id v93 = a3;
  id v94 = a4;
  id v95 = a5;
  __int16 v97 = a7;
  id v96 = a9;
  uint64_t v98 = (__CFString *)*(id *)(a1 + 32);
  __int16 v16 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v17 = @"NO";
    if (a6) {
      CFStringRef v18 = @"YES";
    }
    else {
      CFStringRef v18 = @"NO";
    }
    int v19 = *(unsigned __int8 *)(a1 + 184);
    if (a8) {
      CFStringRef v20 = @"YES";
    }
    else {
      CFStringRef v20 = @"NO";
    }
    *(_DWORD *)buf = 138412802;
    CFStringRef v127 = v18;
    __int16 v128 = 2112;
    CFStringRef v129 = v20;
    if (v19) {
      CFStringRef v17 = @"YES";
    }
    __int16 v130 = 2112;
    CFStringRef v131 = v17;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Query completed: success %@  offline %@  allowPartialSendsToSucceed %@", buf, 0x20u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    CFStringRef v21 = @"NO";
    if (a6) {
      CFStringRef v22 = @"YES";
    }
    else {
      CFStringRef v22 = @"NO";
    }
    if (a8) {
      CFStringRef v23 = @"YES";
    }
    else {
      CFStringRef v23 = @"NO";
    }
    if (*(unsigned char *)(a1 + 184)) {
      CFStringRef v21 = @"YES";
    }
    CFStringRef v83 = v23;
    CFStringRef v85 = v21;
    CFStringRef v81 = v22;
    _IDSLogV();
  }
  id v24 = objc_msgSend(*(id *)(a1 + 40), "expirationDate", v81, v83, v85);
  if (v24)
  {
    unsigned int v25 = [*(id *)(a1 + 40) expirationDate];
    [v25 timeIntervalSinceNow];
    BOOL v27 = v26 < -5.0;

    if (v27)
    {
      uint64_t v28 = *(void *)(a1 + 152);
      if (v28) {
        (*(void (**)(uint64_t, void *))(v28 + 16))(v28, &__NSArray0__struct);
      }
      [*(id *)(a1 + 48) _discardMessage:*(void *)(a1 + 40) forURIs:*(void *)(a1 + 32) service:*(void *)(a1 + 56)];
      __int16 v29 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v30 = *(const __CFString **)(a1 + 32);
        *(_DWORD *)buf = 138412290;
        CFStringRef v127 = v30;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Query completed but message for IDs %@ has already expired. Failing.", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
        _IDSLogV();
      }
      id v31 = objc_alloc((Class)NSError);
      id v32 = [v31 initWithDomain:IDSSendErrorDomain code:2 userInfo:0];
      if (*(void *)(a1 + 160))
      {
        id v33 = [objc_alloc((Class)IDSDeliveryContext) initWithResponseCode:2 error:v32 lastCall:1];
        [v33 setDisplayURIs:v98];
        (*(void (**)(void))(*(void *)(a1 + 160) + 16))(*(void *)(a1 + 160));
      }
LABEL_91:
      __int16 v56 = v98;
      goto LABEL_92;
    }
  }
  [*(id *)(a1 + 40) timeout];
  BOOL v35 = v34 <= 300.0;
  [*(id *)(a1 + 64) timeIntervalSinceNow];
  double v37 = v36;
  [*(id *)(a1 + 40) timeout];
  if (((a8 ^ 1 | a6 | v35) & 1) == 0 && fabs(v37) <= v38)
  {
    uint64_t v39 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v40 = (const __CFString *)[*(id *)(*(void *)(a1 + 48) + 24) count];
      *(_DWORD *)buf = 134217984;
      CFStringRef v127 = v40;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "Query failed because the device is offline. Enqueuing for the return of networking since we have timeout time left. Number of offline sends enqueued ahead of us: %lu.", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      [*(id *)(*(void *)(a1 + 48) + 24) count];
      _IDSLogV();
    }
    uint64_t v41 = *(void *)(a1 + 48);
    if (!*(void *)(v41 + 24))
    {
      id v42 = objc_alloc_init((Class)NSMutableArray);
      uint64_t v43 = *(void *)(a1 + 48);
      uint64_t v44 = *(void **)(v43 + 24);
      *(void *)(v43 + 24) = v42;

      uint64_t v41 = *(void *)(a1 + 48);
    }
    v106[0] = _NSConcreteStackBlock;
    v106[1] = 3221225472;
    v106[2] = sub_1001D86F4;
    v106[3] = &unk_1009857E8;
    v106[4] = v41;
    id v107 = *(id *)(a1 + 40);
    id v108 = *(id *)(a1 + 72);
    id v109 = *(id *)(a1 + 80);
    id v110 = *(id *)(a1 + 56);
    id v111 = *(id *)(a1 + 88);
    id v112 = *(id *)(a1 + 96);
    id v113 = *(id *)(a1 + 104);
    id v114 = *(id *)(a1 + 112);
    id v115 = *(id *)(a1 + 32);
    BYTE4(v45) = *(unsigned char *)(a1 + 185);
    char v91 = *(unsigned char *)(a1 + 184);
    LODWORD(v45) = HIDWORD(v45);
    BYTE1(v45) = *(unsigned char *)(a1 + 186);
    uint64_t v99 = v45;
    id v46 = *(id *)(a1 + 120);
    char v47 = *(unsigned char *)(a1 + 188);
    char v48 = *(unsigned char *)(a1 + 189);
    uint64_t v49 = *(void *)(a1 + 176);
    id v116 = v46;
    uint64_t v123 = v49;
    uint64_t v50 = v99;
    BYTE2(v50) = v91;
    BYTE3(v50) = *(unsigned char *)(a1 + 187);
    BYTE4(v50) = v47;
    BYTE5(v50) = v48;
    BYTE6(v50) = *(unsigned char *)(a1 + 190);
    uint64_t v100 = v50;
    id v117 = *(id *)(a1 + 128);
    uint64_t v51 = v100;
    HIBYTE(v51) = *(unsigned char *)(a1 + 191);
    uint64_t v124 = v51;
    id v118 = *(id *)(a1 + 136);
    id v121 = *(id *)(a1 + 168);
    id v122 = *(id *)(a1 + 160);
    id v119 = *(id *)(a1 + 64);
    id v120 = *(id *)(a1 + 144);
    uint64_t v52 = objc_retainBlock(v106);
    id v53 = [v52 copy];

    uint64_t v54 = *(void **)(*(void *)(a1 + 48) + 24);
    id v55 = objc_retainBlock(v53);
    [v54 addObject:v55];

    goto LABEL_91;
  }
  if ((a6 & 1) == 0)
  {
    if (*(unsigned char *)(a1 + 184))
    {
      uint64_t v101 = (__CFString *)objc_alloc_init((Class)NSMutableSet);
      long long v104 = 0u;
      long long v105 = 0u;
      long long v102 = 0u;
      long long v103 = 0u;
      id v57 = *(id *)(a1 + 32);
      id v58 = [v57 countByEnumeratingWithState:&v102 objects:v125 count:16];
      if (v58)
      {
        uint64_t v59 = *(void *)v103;
        do
        {
          id v60 = 0;
          do
          {
            if (*(void *)v103 != v59) {
              objc_enumerationMutation(v57);
            }
            uint64_t v61 = *(void *)(*((void *)&v102 + 1) + 8 * (void)v60);
            id v62 = [*(id *)(a1 + 48) peerIDManager];
            id v63 = +[IDSURI URIWithPrefixedURI:*(void *)(a1 + 88) withServiceLoggingHint:*(void *)(a1 + 56)];
            unsigned int v64 = [v62 hasPeerTokensForURI:v61 fromURI:v63 service:*(void *)(a1 + 56)];

            if (v64) {
              [(__CFString *)v101 addObject:v61];
            }
            id v60 = (char *)v60 + 1;
          }
          while (v58 != v60);
          id v58 = [v57 countByEnumeratingWithState:&v102 objects:v125 count:16];
        }
        while (v58);
      }

      id v65 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        CFStringRef v127 = v101;
        _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "Found messagable people: %@", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        long long v82 = v101;
        _IDSLogV();
      }
      if ((unint64_t)[(__CFString *)v101 count] > 1
        || [(__CFString *)v101 count] == (id)1
        && ([(__CFString *)v101 anyObject],
            id v69 = objc_claimAutoreleasedReturnValue(),
            [v69 prefixedURI],
            id v70 = objc_claimAutoreleasedReturnValue(),
            unsigned __int8 v71 = [v70 isEqualToString:*(void *)(a1 + 88)],
            v70,
            v69,
            (v71 & 1) == 0))
      {
        [*(id *)(a1 + 48) _emptyMessagesForURIs:*(void *)(a1 + 32) service:*(void *)(a1 + 56)];
        __int16 v56 = [(__CFString *)v101 allObjects];

        LOBYTE(v90) = *(unsigned char *)(a1 + 192);
        LOBYTE(v89) = *(unsigned char *)(a1 + 191);
        LOBYTE(v88) = *(unsigned char *)(a1 + 190);
        *(_WORD *)((char *)&v87 + 1) = *(_WORD *)(a1 + 188);
        LOBYTE(v87) = *(unsigned char *)(a1 + 187);
        LOWORD(v86) = *(_WORD *)(a1 + 185);
        objc_msgSend(*(id *)(a1 + 48), "_queueMessage:service:dataToEncrypt:withEncryptedAttributes:fromID:fromShortHandle:fromIdentity:toID:toURIs:originallyToURIs:ktURIVerificationMap:canUseLargePayload:sendOnePerToken:registrationProperties:fakeMessage:alwaysSkipSelf:alwaysIncludeSelf:forceQuery:disallowRefresh:prioritizedTokenList:wantsFirewallDonation:destinationObject:willSendBlock:completionBlock:fromCoalesceQueue:", *(void *)(a1 + 40), *(void *)(a1 + 56), *(void *)(a1 + 72), *(void *)(a1 + 80), *(void *)(a1 + 88), *(void *)(a1 + 96), *(void *)(a1 + 104), *(void *)(a1 + 112), v56, *(void *)(a1 + 32), *(void *)(a1 + 144), v86, *(void *)(a1 + 120), v87,
          *(void *)(a1 + 176),
          v88,
          *(void *)(a1 + 128),
          v89,
          *(void *)(a1 + 136),
          *(void *)(a1 + 168),
          *(void *)(a1 + 160),
          v90);

        goto LABEL_63;
      }
    }
    id v72 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v73 = *(const __CFString **)(a1 + 32);
      *(_DWORD *)buf = 138412546;
      CFStringRef v127 = v73;
      __int16 v128 = 2112;
      CFStringRef v129 = v97;
      _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "Peer ID manager failed lookup for IDs: %@   (Errors: %@)", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      long long v82 = *(__CFString **)(a1 + 32);
      long long v84 = v97;
      _IDSLogV();
    }
    uint64_t v74 = *(void *)(a1 + 152);
    if (v74) {
      (*(void (**)(uint64_t, void *))(v74 + 16))(v74, &__NSArray0__struct);
    }
    objc_msgSend(*(id *)(a1 + 48), "_emptyMessagesForURIs:service:", *(void *)(a1 + 32), *(void *)(a1 + 56), v82, v84);
    if ([*(id *)(a1 + 32) count])
    {
      long long v75 = [*(id *)(a1 + 32) lastObject];
      long long v76 = [(__CFString *)v97 objectForKey:v75];

      if (v76) {
        id v77 = objc_msgSend(objc_alloc((Class)NSDictionary), "initWithObjectsAndKeys:", v76, NSUnderlyingErrorKey, 0);
      }
      else {
        id v77 = 0;
      }
    }
    else
    {
      id v77 = 0;
      long long v76 = 0;
    }
    id v78 = objc_alloc((Class)NSError);
    id v79 = [v78 initWithDomain:IDSSendErrorDomain code:1 userInfo:v77];
    if (*(void *)(a1 + 160))
    {
      id v80 = [objc_alloc((Class)IDSDeliveryContext) initWithResponseCode:1 error:v79 lastCall:1];
      [v80 setDisplayURIs:v98];
      (*(void (**)(void))(*(void *)(a1 + 160) + 16))();
    }
    goto LABEL_91;
  }
  __int16 v56 = v98;
LABEL_63:
  id v66 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v67 = v56;
    if (!v56) {
      CFStringRef v67 = *(const __CFString **)(a1 + 32);
    }
    *(_DWORD *)buf = 138412290;
    CFStringRef v127 = v67;
    _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "Peer ID manager succeeded lookup for IDs: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    id v68 = v56;
    if (!v56) {
      id v68 = *(__CFString **)(a1 + 32);
    }
    long long v82 = v68;
    _IDSLogV();
  }
  objc_msgSend(*(id *)(a1 + 48), "_handleMessagesForURIs:originalURIs:service:fromID:fromCoalesceQueue:withQueryCompletion:", v56, *(void *)(a1 + 32), *(void *)(a1 + 56), *(void *)(a1 + 88), *(unsigned __int8 *)(a1 + 192), *(void *)(a1 + 152), v82);
LABEL_92:
}

id sub_1001D86F4(uint64_t a1)
{
  LOBYTE(v6) = 0;
  LOBYTE(v5) = *(unsigned char *)(a1 + 183);
  LOBYTE(v4) = *(unsigned char *)(a1 + 182);
  *(_WORD *)((char *)&v3 + 1) = *(_WORD *)(a1 + 180);
  LOBYTE(v3) = *(unsigned char *)(a1 + 179);
  *(_WORD *)((char *)&v2 + 1) = *(_WORD *)(a1 + 177);
  LOBYTE(v2) = *(unsigned char *)(a1 + 176);
  return objc_msgSend(*(id *)(a1 + 32), "_sendMessage:dataToEncrypt:withEncryptedAttributes:onService:fromID:fromShortHandle:fromIdentity:toID:toURIs:canUseLargePayload:sendOnePerToken:allowPartialSendsToSucceed:registrationProperties:fakeMessage:alwaysSkipSelf:alwaysIncludeSelf:forceQuery:disallowRefresh:prioritizedTokenList:wantsFirewallDonation:destinationObject:willSendBlock:completionBlock:firstAttemptDate:ktURIVerificationMap:fromCoalesceQueue:withQueryCompletion:", *(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 64), *(void *)(a1 + 72), *(void *)(a1 + 80), *(void *)(a1 + 88), *(void *)(a1 + 96), *(void *)(a1 + 104), v2, *(void *)(a1 + 112), v3, *(void *)(a1 + 168), v4,
           *(void *)(a1 + 120),
           v5,
           *(void *)(a1 + 128),
           *(void *)(a1 + 152),
           *(void *)(a1 + 160),
           *(void *)(a1 + 136),
           *(void *)(a1 + 144),
           v6,
           &stru_1009857C0);
}

void sub_1001D93C0(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = [a2 pushAckTimestamp];
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v3);
}

uint64_t sub_1001D9AA4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1001D9EF0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  id v7 = [v5 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v13;
    do
    {
      for (uint64_t i = 0; i != v8; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v13 != v9) {
          objc_enumerationMutation(v5);
        }
        [*(id *)(a1 + 32) setObject:v6 forKey:*(void *)(*((void *)&v12 + 1) + 8 * i)];
      }
      id v8 = [v5 countByEnumeratingWithState:&v12 objects:v16 count:16];
    }
    while (v8);
  }
  if (v5) {
    __int16 v11 = v5;
  }
  else {
    __int16 v11 = &__NSArray0__struct;
  }
  [*(id *)(a1 + 40) fulfillWithValue:v11];
}

void sub_1001DA018(void *a1, void *a2)
{
  id v3 = [a2 value];
  uint64_t v4 = +[NSString stringGUID];
  id v5 = +[IDSFoundationLog delivery];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 138412802;
    id v8 = v3;
    __int16 v9 = 2048;
    id v10 = [v3 count];
    __int16 v11 = 2112;
    long long v12 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Pipelines done processing all fanouts %@ count %ld for mmlGUID %@", (uint8_t *)&v7, 0x20u);
  }

  id v6 = [[IDSFanoutSender alloc] initWithGUID:v4 service:a1[4] messageDelivery:*(void *)(a1[5] + 8) completionActivity:a1[6] coalesceQueueManager:*(void *)(a1[5] + 40)];
  [(IDSFanoutSender *)v6 sendMMLs:a1[7] guidToDeliveryAcknowledgementBlock:a1[8] guidToSendCompletionBlock:a1[9] forService:a1[4] sendMode:a1[10] messageQueue:*(void *)(a1[5] + 16)];
}

void sub_1001DA228(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  id v28 = a2;
  os_activity_t v6 = _os_activity_create((void *)&_mh_execute_header, "All sends complete", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
  uint64_t v7 = IDSDeliveryMessageKey;
  id v8 = [*(id *)(a1 + 32) objectForKey:IDSDeliveryMessageKey];
  uint64_t v9 = [v8 messageID];

  id v10 = objc_alloc_init((Class)NSMutableDictionary);
  id v11 = objc_alloc_init((Class)NSMutableDictionary);
  long long v12 = [*(id *)(a1 + 32) objectForKey:v7];
  long long v13 = [v12 deliveryAcknowledgementBlock];

  long long v14 = [*(id *)(a1 + 32) objectForKey:IDSDeliveryCompletionBlockKey];
  id v15 = objc_retainBlock(v13);
  [v10 setObject:v15 forKey:v9];

  id v16 = objc_retainBlock(v14);
  [v11 setObject:v16 forKey:v9];

  __int16 v29 = (void *)v9;
  os_activity_t v30 = v6;
  CFStringRef v17 = [[IDSFanoutSender alloc] initWithGUID:v9 service:*(void *)(a1 + 40) messageDelivery:*(void *)(*(void *)(a1 + 48) + 8) completionActivity:v6 coalesceQueueManager:*(void *)(*(void *)(a1 + 48) + 40)];
  [(IDSFanoutSender *)v17 sendFanouts:v28 guidToDeliveryAcknowledgementBlock:v10 guidToSendCompletionBlock:v11 forURIs:v5 messageQueue:*(void *)(*(void *)(a1 + 48) + 16)];

  if (_os_feature_enabled_impl())
  {
    CFStringRef v18 = v13;
    uint64_t v19 = objc_opt_class();
    CFStringRef v20 = [*(id *)(a1 + 32) objectForKey:v7];
    CFStringRef v21 = [v20 messageBody];
    CFStringRef v22 = sub_1001DA568(v19, v21, IDSCommandKey);

    if ([*(id *)(a1 + 40) isEqualToString:IDSServiceNameiMessage]
      && [v22 unsignedIntegerValue] == (id)100)
    {
      id v23 = objc_alloc((Class)IDSURI);
      id v24 = [*(id *)(a1 + 32) objectForKey:IDSDeliveryFromIDKey];
      id v25 = [v23 initWithPrefixedURI:v24];

      double v26 = im_primary_queue();
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_1001DA624;
      block[3] = &unk_10097E418;
      void block[4] = *(void *)(a1 + 48);
      id v32 = v5;
      id v33 = v25;
      id v27 = v25;
      dispatch_async(v26, block);
    }
    long long v13 = v18;
  }
}

id sub_1001DA568(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  os_activity_t v6 = [a2 objectForKey:v5];
  if (objc_opt_isKindOfClass())
  {
    id v7 = v6;
  }
  else
  {
    if (v6)
    {
      id v8 = +[IMRGLog registration];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
        sub_100716564((uint64_t)v5, a1, v8);
      }
    }
    id v7 = 0;
  }

  return v7;
}

void sub_1001DA624(void *a1)
{
  uint64_t v2 = a1[5];
  id v3 = *(void **)(a1[4] + 48);
  uint64_t v4 = a1[6];
  id v5 = +[IDSSenderKeySendContext iMessageSend];
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  _DWORD v6[2] = sub_1001DA704;
  v6[3] = &unk_100980D88;
  id v7 = (id)a1[5];
  id v8 = (id)a1[6];
  [v3 generateAndSendKeyIfNeededToURIs:v2 fromURI:v4 context:v5 completion:v6];
}

uint64_t sub_1001DA704(uint64_t a1, int a2)
{
  uint64_t v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v5 = @"NO";
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v7 = *(void *)(a1 + 40);
    if (a2) {
      CFStringRef v5 = @"YES";
    }
    *(_DWORD *)buf = 138412802;
    CFStringRef v10 = v5;
    __int16 v11 = 2112;
    uint64_t v12 = v6;
    __int16 v13 = 2112;
    uint64_t v14 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Did trigger generateAndSendKeyIfNeededToURIs: %@ { toURIs: %@ fromURI: %@ }", buf, 0x20u);
  }

  uint64_t result = os_log_shim_legacy_logging_enabled();
  if (result)
  {
    uint64_t result = _IDSShouldLog();
    if (result) {
      return _IDSLogV();
    }
  }
  return result;
}

void sub_1001DAD10(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

void sub_1001DAD30(uint64_t a1)
{
  uint64_t v2 = +[IDSFoundationLog delivery_oversized];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    int v5 = 138412546;
    uint64_t v6 = v3;
    __int16 v7 = 2112;
    uint64_t v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Guid %@ full pipeline input: %@", (uint8_t *)&v5, 0x16u);
  }
}

uint64_t sub_1001DADEC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1001DADFC(uint64_t a1)
{
}

void sub_1001DAE04(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (_os_feature_enabled_impl() && IDSCommandIsGroupSessionCommand())
  {
    [*(id *)(a1 + 32) integerValue];
    kdebug_trace();
  }
  uint64_t v4 = &IDSRegistrationPropertySupportsAVLess_ptr;
  if ([v3 state] == (id)1)
  {
    int v5 = [v3 error];
    uint64_t v6 = [v5 userInfo];
    id v7 = [v6 mutableCopy];

    uint64_t v8 = [v7 objectForKey:@"IDSPipelineParameter"];
    [v7 removeObjectForKey:@"IDSPipelineParameter"];
    uint64_t v9 = [v8 guid];
    CFStringRef v10 = [v8 endpoints];
    unsigned int v31 = [v8 usedMMCS];
    id v30 = [v5 code];
    __int16 v11 = +[IDSFoundationLog delivery];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      BOOL v35 = v9;
      __int16 v36 = 2112;
      double v37 = v5;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "GUID %@ Failed with error: %@", buf, 0x16u);
    }

    if ([v5 code] == (id)4)
    {
      uint64_t v12 = [v7 objectForKey:@"MMCSUploadErrorKey"];
      if (v12)
      {
        [v7 removeObjectForKey:@"MMCSUploadErrorKey"];
        __int16 v13 = [[IDSServerMessage alloc] initWithPayload:v12 command:&off_1009D1830];
        uint64_t v14 = *(void *)(a1 + 48);
        __int16 v29 = *(void **)(a1 + 40);
        v32[0] = _NSConcreteStackBlock;
        v32[1] = 3221225472;
        v32[2] = sub_1001DB2B8;
        v32[3] = &unk_100980FD8;
        id v33 = v9;
        [v29 sendIDSMessage:v13 service:0 topic:v14 completionBlock:v32];
      }
    }
    id v15 = objc_msgSend(v5, "domain", v29);
    id v16 = +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", v15, [v5 code], v7);

    id v17 = objc_msgSend(objc_alloc((Class)IDSDeliveryContext), "initWithResponseCode:error:lastCall:", objc_msgSend(v16, "code"), v16, 1);
    [v17 setDisplayURIs:*(void *)(a1 + 56)];
    uint64_t v18 = *(void *)(a1 + 72);
    if (v18) {
      (*(void (**)(uint64_t, id))(v18 + 16))(v18, v17);
    }

    uint64_t v4 = &IDSRegistrationPropertySupportsAVLess_ptr;
    id v19 = (id)v31;
    id v20 = v30;
  }
  else
  {
    uint64_t v21 = [v3 value];
    uint64_t v22 = *(void *)(*(void *)(a1 + 88) + 8);
    id v23 = *(void **)(v22 + 40);
    *(void *)(v22 + 40) = v21;

    uint64_t v9 = [*(id *)(*(void *)(*(void *)(a1 + 88) + 8) + 40) guid];
    CFStringRef v10 = [*(id *)(*(void *)(*(void *)(a1 + 88) + 8) + 40) endpoints];
    id v19 = [*(id *)(*(void *)(*(void *)(a1 + 88) + 8) + 40) usedMMCS];
    id v20 = 0;
  }
  id v24 = +[NSDate date];
  objc_msgSend(*(id *)(a1 + 40), "sendRTCMetricWithStartDate:endDate:endpointCount:usedPipeline:usedMMCS:responseCode:", *(void *)(a1 + 64), v24, objc_msgSend(v10, "count"), 1, v19, v20);
  id v25 = [v4[288] delivery];
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    BOOL v35 = v9;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Pipeline done with all fanouts %@", buf, 0xCu);
  }

  uint64_t v26 = *(void *)(a1 + 80);
  id v27 = [*(id *)(*(void *)(*(void *)(a1 + 88) + 8) + 40) aggregateMessages];
  id v28 = [*(id *)(*(void *)(*(void *)(a1 + 88) + 8) + 40) uris];
  (*(void (**)(uint64_t, void *, void *))(v26 + 16))(v26, v27, v28);
}

void sub_1001DB2B8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = +[IDSFoundationLog delivery];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    id v6 = [v3 idsResponseCode];
    id v7 = [v3 responseCode];
    unsigned int v8 = [v3 lastCall];
    CFStringRef v9 = @"NO";
    int v10 = 138413058;
    uint64_t v11 = v5;
    __int16 v12 = 2048;
    if (v8) {
      CFStringRef v9 = @"YES";
    }
    id v13 = v6;
    __int16 v14 = 2048;
    id v15 = v7;
    __int16 v16 = 2112;
    CFStringRef v17 = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "GUID %@ Upload failure metric sent with response: %ld error: %ld lastCall: %@", (uint8_t *)&v10, 0x2Au);
  }
}

id sub_1001DC150(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) fulfillWithValue:a2];
}

void sub_1001DC15C(uint64_t a1, void *a2)
{
  id v3 = [a2 value];
  id v4 = objc_alloc_init((Class)NSMutableArray);
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  id v5 = v3;
  id v6 = [v5 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v12;
    do
    {
      for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v12 != v8) {
          objc_enumerationMutation(v5);
        }
        int v10 = *(void **)(*((void *)&v11 + 1) + 8 * i);
        if (objc_msgSend(v10, "count", (void)v11)) {
          [v4 addObjectsFromArray:v10];
        }
      }
      id v7 = [v5 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }
    while (v7);
  }

  [*(id *)(a1 + 32) _pipelinesHandleMessagesToCoalesce:v4 forService:*(void *)(a1 + 40) sendMode:*(void *)(a1 + 48)];
}

void sub_1001DCDD4(id a1)
{
  qword_100A4AA40 = objc_alloc_init(IDSDRegistrationListener);

  _objc_release_x1();
}

void sub_1001DD2E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001DD2FC(uint64_t result)
{
  uint64_t v1 = *(void *)(*(void *)(result + 40) + 8);
  if (!*(unsigned char *)(v1 + 24))
  {
    *(unsigned char *)(v1 + 24) = 1;
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
  }
  return result;
}

uint64_t sub_1001DE1A4()
{
  uint64_t result = _os_feature_enabled_impl();
  if (result)
  {
    return _IDSIsVirtualMachine();
  }
  return result;
}

uint64_t sub_1001DE1E8(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(a2 + 4 * (result >> 5)) |= 1 << result;
  return result;
}

uint64_t sub_1001DE204(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(a2 + 4 * (result >> 5)) &= ~(1 << result);
  return result;
}

uint64_t sub_1001DE220(unsigned int a1, uint64_t a2)
{
  return *(_DWORD *)(a2 + 4 * (a1 >> 5)) & (1 << a1);
}

void sub_1001DE238(void *a1)
{
}

void sub_1001DE6C4(id a1)
{
  qword_100A4AA50 = objc_alloc_init(IDSUTunDeliveryController);

  _objc_release_x1();
}

uint64_t sub_1001DEF3C(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) _copyPairedDevice];
  id v3 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    id v4 = [v2 identifier];
    id v5 = [v2 btUUID];
    if ([*(id *)(a1 + 32) defaultPeerIsNearby]) {
      CFStringRef v6 = @"YES";
    }
    else {
      CFStringRef v6 = @"NO";
    }
    if ([*(id *)(a1 + 32) defaultPeerIsConnected]) {
      CFStringRef v7 = @"YES";
    }
    else {
      CFStringRef v7 = @"NO";
    }
    unsigned int v8 = [*(id *)(a1 + 32) isTerminusNearby];
    unsigned int v9 = [*(id *)(a1 + 32) isTerminusConnected];
    if (v8) {
      CFStringRef v10 = @"YES";
    }
    else {
      CFStringRef v10 = @"NO";
    }
    *(_DWORD *)buf = 138413570;
    if (v9) {
      CFStringRef v11 = @"YES";
    }
    else {
      CFStringRef v11 = @"NO";
    }
    uint64_t v26 = v4;
    __int16 v27 = 2112;
    id v28 = v5;
    __int16 v29 = 2112;
    CFStringRef v30 = v6;
    __int16 v31 = 2112;
    CFStringRef v32 = v7;
    __int16 v33 = 2112;
    CFStringRef v34 = v10;
    __int16 v35 = 2112;
    CFStringRef v36 = v11;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Device %@ cbuuid %@.  Is IDS nearby? %@ Connected? %@. Is terminus nearby? %@ Connected? %@ ", buf, 0x3Eu);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
  {
    long long v12 = [v2 identifier];
    long long v13 = [v2 btUUID];
    long long v14 = (id *)(a1 + 32);
    if ([*(id *)(a1 + 32) defaultPeerIsNearby]) {
      CFStringRef v15 = @"YES";
    }
    else {
      CFStringRef v15 = @"NO";
    }
    if ([*v14 defaultPeerIsConnected]) {
      CFStringRef v16 = @"YES";
    }
    else {
      CFStringRef v16 = @"NO";
    }
    if ([*v14 isTerminusNearby]) {
      CFStringRef v17 = @"YES";
    }
    else {
      CFStringRef v17 = @"NO";
    }
    if ([*v14 isTerminusConnected]) {
      CFStringRef v18 = @"YES";
    }
    else {
      CFStringRef v18 = @"NO";
    }
    CFStringRef v24 = v18;
    _IDSLogTransport();

    if (_IDSShouldLog())
    {
      id v19 = objc_msgSend(v2, "identifier", v12, v13, v15, v16, v17, v24);
      id v20 = [v2 btUUID];
      uint64_t v22 = *(void **)(a1 + 32);
      uint64_t v21 = (id *)(a1 + 32);
      [v22 defaultPeerIsNearby];
      [*v21 defaultPeerIsConnected];
      [*v21 isTerminusNearby];
      [*v21 isTerminusConnected];
      _IDSLogV();
    }
  }

  return 0;
}

void sub_1001DF36C(id a1, id a2, IDSUTunPeer *a3, BOOL *a4)
{
}

id sub_1001DFBD8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [*(id *)(a1 + 32) deviceWithUniqueID:a2 updatedUUID:a3];
}

void sub_1001E1180(uint64_t a1)
{
  uint64_t v51 = [*(id *)(a1 + 32) hashForString:*(void *)(a1 + 40)];
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  CFStringRef v81 = _os_activity_create((void *)&_mh_execute_header, "UTUN sendData", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v81, &state);
  id v2 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *(void *)(a1 + 40);
    CFStringRef v3 = *(const __CFString **)(a1 + 48);
    *(_DWORD *)buf = 138412546;
    CFStringRef v83 = v3;
    __int16 v84 = 2112;
    *(void *)CFStringRef v85 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "OUTGOING-UTUN_DELIVERY:%@ SERVICE:%@", buf, 0x16u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v43 = *(void *)(a1 + 48);
    uint64_t v44 = *(void *)(a1 + 40);
    _IDSLogV();
  }
  id v5 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 192);
    CFStringRef v7 = @"Sync";
    if (v6 == 200) {
      CFStringRef v7 = @"Default";
    }
    if (v6 == 300) {
      CFStringRef v8 = @"URGENT";
    }
    else {
      CFStringRef v8 = v7;
    }
    CFStringRef v48 = v8;
    unsigned int v47 = objc_msgSend(*(id *)(a1 + 56), "length", v43, v44);
    unsigned int v9 = [*(id *)(a1 + 64) data];
    unsigned int v10 = [v9 length];
    if (*(unsigned char *)(a1 + 212)) {
      CFStringRef v11 = @"YES";
    }
    else {
      CFStringRef v11 = @"NO";
    }
    uint64_t v13 = *(void *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 48);
    uint64_t v14 = *(void *)(a1 + 72);
    uint64_t v15 = *(void *)(a1 + 80);
    CFStringRef v16 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [*(id *)(a1 + 88) count]);
    *(_DWORD *)buf = 138545410;
    CFStringRef v83 = v48;
    __int16 v84 = 1024;
    *(_DWORD *)CFStringRef v85 = v10 + v47;
    *(_WORD *)&v85[4] = 2114;
    *(void *)&v85[6] = v12;
    __int16 v86 = 2112;
    uint64_t v87 = v14;
    __int16 v88 = 2112;
    CFStringRef v89 = v11;
    __int16 v90 = 2114;
    uint64_t v91 = v13;
    __int16 v92 = 2114;
    id v93 = v51;
    __int16 v94 = 2112;
    uint64_t v95 = v15;
    __int16 v96 = 2114;
    __int16 v97 = v16;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "UTUN request to send %{public}@ priority local message payload of data size: %d  guid: %{public}@  expirationDate %@ enforceRemoteTimeout %@ for topic: %{public}@:%{public}@ and command %@ to deviceIDs (count: %{public}@)", buf, 0x58u);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
  {
    uint64_t v17 = *(void *)(a1 + 192);
    CFStringRef v18 = @"Sync";
    if (v17 == 200) {
      CFStringRef v18 = @"Default";
    }
    if (v17 == 300) {
      CFStringRef v19 = @"URGENT";
    }
    else {
      CFStringRef v19 = v18;
    }
    CFStringRef v49 = v19;
    unsigned int v20 = objc_msgSend(*(id *)(a1 + 56), "length", v43, v44);
    uint64_t v21 = [*(id *)(a1 + 64) data];
    unsigned int v22 = [v21 length];
    if (*(unsigned char *)(a1 + 212)) {
      CFStringRef v23 = @"YES";
    }
    else {
      CFStringRef v23 = @"NO";
    }
    uint64_t v25 = *(void *)(a1 + 40);
    uint64_t v24 = *(void *)(a1 + 48);
    uint64_t v27 = *(void *)(a1 + 72);
    uint64_t v26 = *(void *)(a1 + 80);
    uint64_t v45 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [*(id *)(a1 + 88) count]);
    _IDSLogTransport();

    if (_IDSShouldLog())
    {
      objc_msgSend(*(id *)(a1 + 56), "length", v49, v22 + v20, v24, v27, v23, v25, v51, v26, v45);
      id v28 = [*(id *)(a1 + 64) data];
      [v28 length];
      id v46 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [*(id *)(a1 + 88) count]);
      _IDSLogV();
    }
  }
  id v29 = objc_alloc_init((Class)NSMutableSet);
  v54[0] = _NSConcreteStackBlock;
  v54[1] = 3221225472;
  v54[2] = sub_1001E1A98;
  v54[3] = &unk_100985A40;
  v54[4] = *(void *)(a1 + 32);
  CFStringRef v30 = *(void **)(a1 + 88);
  id v55 = *(id *)(a1 + 96);
  id v72 = *(id *)(a1 + 168);
  id v31 = v29;
  id v56 = v31;
  id v57 = *(id *)(a1 + 56);
  id v58 = *(id *)(a1 + 64);
  id v59 = *(id *)(a1 + 104);
  id v60 = *(id *)(a1 + 112);
  id v61 = *(id *)(a1 + 48);
  id v32 = *(id *)(a1 + 72);
  uint64_t v33 = *(void *)(a1 + 192);
  id v62 = v32;
  uint64_t v75 = v33;
  int v77 = *(_DWORD *)(a1 + 208);
  LODWORD(v34) = *(_DWORD *)(a1 + 212);
  WORD2(v34) = *(_WORD *)(a1 + 216);
  BYTE6(v34) = *(unsigned char *)(a1 + 218);
  uint64_t v50 = v34;
  id v63 = *(id *)(a1 + 120);
  id v35 = v51;
  id v64 = v35;
  id v65 = *(id *)(a1 + 80);
  id v66 = *(id *)(a1 + 40);
  id v67 = *(id *)(a1 + 128);
  id v68 = *(id *)(a1 + 136);
  id v73 = *(id *)(a1 + 176);
  id v74 = *(id *)(a1 + 184);
  id v69 = *(id *)(a1 + 144);
  uint64_t v36 = v50;
  HIBYTE(v36) = *(unsigned char *)(a1 + 219);
  uint64_t v78 = v36;
  __int16 v79 = *(_WORD *)(a1 + 220);
  id v70 = *(id *)(a1 + 152);
  id v37 = *(id *)(a1 + 160);
  uint64_t v38 = *(void *)(a1 + 200);
  id v71 = v37;
  uint64_t v76 = v38;
  [v30 enumerateKeysAndObjectsUsingBlock:v54];
  if (![v31 count])
  {
    uint64_t v39 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v40 = *(const __CFString **)(a1 + 88);
      uint64_t v41 = *(void *)(*(void *)(a1 + 32) + 72);
      *(_DWORD *)buf = 138412546;
      CFStringRef v83 = v40;
      __int16 v84 = 2112;
      *(void *)CFStringRef v85 = v41;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "Unable to find peer for deviceIDs %@ failing the message.  (Peers: %@)", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
    id v42 = *(void **)(a1 + 88);
    v52[0] = _NSConcreteStackBlock;
    v52[1] = 3221225472;
    v52[2] = sub_1001E2154;
    v52[3] = &unk_100985A68;
    id v53 = *(id *)(a1 + 168);
    [v42 enumerateKeysAndObjectsUsingBlock:v52];
  }
  os_activity_scope_leave(&state);
  cut_arc_os_release();
}

void sub_1001E1A98(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  CFStringRef v7 = [v6 objectForKey:IDSDevicePairedDeviceID];
  if (![v7 isEqualToString:IDSDeviceDefaultPairedDeviceUniqueID]
    || (id v8 = [*(id *)(a1 + 32) _copyPairedDevice], v8, v8))
  {
    unsigned int v9 = [*(id *)(a1 + 32) _createPeerFromDeviceInfo:v6];
    if (v9)
    {
      if (![*(id *)(a1 + 48) containsObject:v7])
      {
        id v12 = [*(id *)(a1 + 32) _nextMessageID];
        uint64_t v13 = objc_alloc_init(IDSLocalDeliveryMessage);
        [(IDSLocalDeliveryMessage *)v13 setPayload:*(void *)(a1 + 56)];
        [(IDSLocalDeliveryMessage *)v13 setProtobuf:*(void *)(a1 + 64)];
        [(IDSLocalDeliveryMessage *)v13 setResourcePath:*(void *)(a1 + 72)];
        [(IDSLocalDeliveryMessage *)v13 setResourceMetadata:*(void *)(a1 + 80)];
        [(IDSLocalDeliveryMessage *)v13 setMessageUUID:*(void *)(a1 + 88)];
        [(IDSLocalDeliveryMessage *)v13 setMessageID:v12];
        [(IDSLocalDeliveryMessage *)v13 setExpirationDate:*(void *)(a1 + 96)];
        [(IDSLocalDeliveryMessage *)v13 setShouldEnforceRemoteTimeout:*(unsigned __int8 *)(a1 + 220)];
        [(IDSLocalDeliveryMessage *)v13 setPriority:*(void *)(a1 + 200)];
        [(IDSLocalDeliveryMessage *)v13 setDataProtectionClass:*(unsigned int *)(a1 + 216)];
        [(IDSLocalDeliveryMessage *)v13 setNonWaking:*(unsigned __int8 *)(a1 + 221)];
        [(IDSLocalDeliveryMessage *)v13 setNonCloudWaking:*(unsigned __int8 *)(a1 + 222)];
        [(IDSLocalDeliveryMessage *)v13 setExpectsPeerResponse:*(unsigned __int8 *)(a1 + 223)];
        [(IDSLocalDeliveryMessage *)v13 setWantsAppAck:*(unsigned __int8 *)(a1 + 224)];
        [(IDSLocalDeliveryMessage *)v13 setCompressPayload:*(unsigned __int8 *)(a1 + 225)];
        [(IDSLocalDeliveryMessage *)v13 setCompressed:*(unsigned __int8 *)(a1 + 226)];
        [(IDSLocalDeliveryMessage *)v13 setPeerResponseIdentifier:*(void *)(a1 + 104)];
        [(IDSLocalDeliveryMessage *)v13 setDomainHash:*(void *)(a1 + 112)];
        [(IDSLocalDeliveryMessage *)v13 setCommand:*(void *)(a1 + 120)];
        [(IDSLocalDeliveryMessage *)v13 setTopic:*(void *)(a1 + 128)];
        [(IDSLocalDeliveryMessage *)v13 setAwdTopic:*(void *)(a1 + 136)];
        [(IDSLocalDeliveryMessage *)v13 setFromID:*(void *)(a1 + 144)];
        [(IDSLocalDeliveryMessage *)v13 setToDeviceID:v7];
        [(IDSLocalDeliveryMessage *)v13 setToURI:v5];
        [(IDSLocalDeliveryMessage *)v13 setCompletionBlock:*(void *)(a1 + 176)];
        [(IDSLocalDeliveryMessage *)v13 setFallbackBlock:*(void *)(a1 + 184)];
        [(IDSLocalDeliveryMessage *)v13 setProgressBlock:*(void *)(a1 + 192)];
        [(IDSLocalDeliveryMessage *)v13 setQueueOneIdentifier:*(void *)(a1 + 152)];
        [(IDSLocalDeliveryMessage *)v13 setRequireBluetooth:*(unsigned __int8 *)(a1 + 227)];
        [(IDSLocalDeliveryMessage *)v13 setRequireLocalWiFi:*(unsigned __int8 *)(a1 + 228)];
        [(IDSLocalDeliveryMessage *)v13 setBypassDuet:*(unsigned __int8 *)(a1 + 229)];
        [(IDSLocalDeliveryMessage *)v13 setDuetIdentifiersOverride:*(void *)(a1 + 160)];
        -[IDSLocalDeliveryMessage setMinCompatibilityVersion:](v13, "setMinCompatibilityVersion:", [*(id *)(a1 + 168) minCompatibilityVersion]);
        [(IDSLocalDeliveryMessage *)v13 setMessageType:*(void *)(a1 + 208)];
        [v9 sendMessage:v13 priority:*(void *)(a1 + 200) messageType:*(void *)(a1 + 208)];
        if (v7) {
          [*(id *)(a1 + 48) addObject:v7];
        }

        goto LABEL_27;
      }
      unsigned int v10 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        id v28 = v7;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Skipping device %@ which we already sent to.", buf, 0xCu);
      }

      if (!os_log_shim_legacy_logging_enabled() || !_IDSShouldLog())
      {
LABEL_27:

        goto LABEL_28;
      }
    }
    else
    {
      CFStringRef v11 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        id v28 = v6;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "WARNING: Unable to create the peer for the device %@", buf, 0xCu);
      }

      if (!os_log_shim_legacy_logging_enabled()) {
        goto LABEL_27;
      }
      if (!_IDSShouldLogTransport()) {
        goto LABEL_27;
      }
      _IDSLogTransport();
      if (!_IDSShouldLog()) {
        goto LABEL_27;
      }
    }
    _IDSLogV();
    goto LABEL_27;
  }
  uint64_t v14 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = *(void **)(a1 + 40);
    CFStringRef v16 = [*(id *)(a1 + 32) pairingManager];
    uint64_t v17 = [v16 pairedDeviceUniqueID];
    *(_DWORD *)buf = 138412546;
    id v28 = v15;
    __int16 v29 = 2112;
    CFStringRef v30 = v17;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "WARNING: A message for the local default paired device has reached the delivery controller but we do not have a peer already for it, It was likley sent before QWS was completed. Purging message. Destination Device: %@, Current Device:%@ ", buf, 0x16u);
  }
  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      uint64_t v18 = *(void *)(a1 + 40);
      CFStringRef v19 = [*(id *)(a1 + 32) pairingManager];
      unsigned int v22 = [v19 pairedDeviceUniqueID];
      _IDSLogTransport();

      if (_IDSShouldLog())
      {
        unsigned int v20 = objc_msgSend(*(id *)(a1 + 32), "pairingManager", v18, v22);
        CFStringRef v23 = [v20 pairedDeviceUniqueID];
        _IDSLogV();
      }
    }
  }
  if (*(void *)(a1 + 176))
  {
    uint64_t v21 = +[IDSDaemonPriorityQueueController sharedInstance];
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 3221225472;
    v24[2] = sub_1001E20E8;
    v24[3] = &unk_1009814F8;
    id v25 = v7;
    id v26 = *(id *)(a1 + 176);
    [v21 performBlockMainQueue:v24];

    unsigned int v9 = v25;
    goto LABEL_27;
  }
LABEL_28:
}

void sub_1001E20E8(uint64_t a1)
{
  id v2 = [objc_alloc((Class)IDSDeliveryContext) initWithResponseCode:24 deviceID:*(void *)(a1 + 32)];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_1001E2154(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = [a3 objectForKey:IDSDevicePairedDeviceID];
  if (*(void *)(a1 + 32))
  {
    id v5 = +[IDSDaemonPriorityQueueController sharedInstance];
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    _DWORD v6[2] = sub_1001E223C;
    v6[3] = &unk_1009814F8;
    id v7 = v4;
    id v8 = *(id *)(a1 + 32);
    [v5 performBlockMainQueue:v6];
  }
}

void sub_1001E223C(uint64_t a1)
{
  id v2 = [objc_alloc((Class)IDSDeliveryContext) initWithResponseCode:2 deviceID:*(void *)(a1 + 32)];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_1001E30F8(uint64_t a1, void *a2)
{
  id v2 = *(void **)(a1 + 32);
  CFStringRef v3 = (void *)v2[19];
  id v4 = a2;
  id v5 = [v2 hashForString:v4];
  [v3 setObject:v4 forKey:v5];
}

void sub_1001E366C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  if (([a2 isEqualToString:IDSDeviceDefaultPairedDeviceUniqueID] & 1) == 0
    && [v5 isNearby])
  {
    [v5 setIsNearby:0];
    [*(id *)(a1 + 32) peerNearbyStateChanged:v5 forceNotify:1];
  }
}

void sub_1001E3EB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001E3ECC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1001E3EDC(uint64_t a1)
{
}

void sub_1001E3EE4(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  id v8 = a2;
  if (*(void *)(a1 + 32) == a3)
  {
    id v9 = v8;
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
    id v8 = v9;
    *a4 = 1;
  }
}

void sub_1001E48FC(uint64_t a1)
{
  CFStringRef v3 = [*(id *)(*(void *)(a1 + 32) + 200) allObjects];
  id v4 = [v3 copy];

  id v5 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v6 = [*(id *)(a1 + 40) isNearby];
    CFStringRef v7 = @"NO";
    uint64_t v8 = *(void *)(a1 + 48);
    if (v6) {
      CFStringRef v7 = @"YES";
    }
    *(_DWORD *)buf = 138412546;
    CFStringRef v23 = v7;
    __int16 v24 = 2112;
    uint64_t v25 = v8;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Broadcasting isNearby %@ for %@", buf, 0x16u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
  {
    id v9 = [*(id *)(a1 + 40) isNearby] ? @"YES" : @"NO";
    uint64_t v15 = v9;
    uint64_t v16 = *(void *)(a1 + 48);
    _IDSLogTransport();
    if (_IDSShouldLog())
    {
      objc_msgSend(*(id *)(a1 + 40), "isNearby", v15, v16);
      _IDSLogV();
    }
  }
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  id v10 = v4;
  id v11 = [v10 countByEnumeratingWithState:&v17 objects:v21 count:16];
  if (v11)
  {
    uint64_t v12 = *(void *)v18;
    do
    {
      for (uint64_t i = 0; i != v11; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v18 != v12) {
          objc_enumerationMutation(v10);
        }
        uint64_t v14 = *(void **)(*((void *)&v17 + 1) + 8 * i);
        if (objc_opt_respondsToSelector()) {
          objc_msgSend(v14, "deliveryController:uniqueID:isNearby:", *(void *)(a1 + 32), *(void *)(a1 + 48), objc_msgSend(*(id *)(a1 + 40), "isNearby"));
        }
      }
      id v11 = [v10 countByEnumeratingWithState:&v17 objects:v21 count:16];
    }
    while (v11);
  }
}

void sub_1001E5040(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 32) + 200) allObjects];
  id v3 = [v2 copy];

  id v4 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v5 = [*(id *)(a1 + 32) isConnected];
    CFStringRef v6 = @"NO";
    uint64_t v7 = *(void *)(a1 + 40);
    if (v5) {
      CFStringRef v6 = @"YES";
    }
    *(_DWORD *)buf = 138412546;
    CFStringRef v22 = v6;
    __int16 v23 = 2112;
    uint64_t v24 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Broadcasting isConnected %@ for %@", buf, 0x16u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
  {
    uint64_t v8 = [*(id *)(a1 + 32) isConnected] ? @"YES" : @"NO";
    uint64_t v14 = v8;
    uint64_t v15 = *(void *)(a1 + 40);
    _IDSLogTransport();
    if (_IDSShouldLog())
    {
      objc_msgSend(*(id *)(a1 + 32), "isConnected", v14, v15);
      _IDSLogV();
    }
  }
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  id v9 = v3;
  id v10 = [v9 countByEnumeratingWithState:&v16 objects:v20 count:16];
  if (v10)
  {
    uint64_t v11 = *(void *)v17;
    do
    {
      for (uint64_t i = 0; i != v10; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v17 != v11) {
          objc_enumerationMutation(v9);
        }
        uint64_t v13 = *(void **)(*((void *)&v16 + 1) + 8 * i);
        if (objc_opt_respondsToSelector()) {
          objc_msgSend(v13, "deliveryController:uniqueID:isConnected:", *(void *)(a1 + 32), *(void *)(a1 + 40), objc_msgSend(*(id *)(a1 + 32), "isConnected"));
        }
      }
      id v10 = [v9 countByEnumeratingWithState:&v16 objects:v20 count:16];
    }
    while (v10);
  }
}

id sub_1001E84BC(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _enableOTRForDefaultPairedDevice];
}

id sub_1001E8D38(uint64_t a1, uint64_t a2, void *a3)
{
  return [a3 admissionPolicyChangedForTopic:*(void *)(a1 + 32) allowed:*(unsigned __int8 *)(a1 + 40)];
}

void sub_1001EAEF4(id a1, IDSStewieProvisionMessage *a2)
{
  id v2 = a2;
  id v3 = +[IDSFoundationLog stewieProvisioning];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    unsigned int v5 = v2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Adding heartbeat to message: %@", (uint8_t *)&v4, 0xCu);
  }
}

void sub_1001EAFA8(os_unfair_lock_s *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    int v4 = a1 + 2;
    os_unfair_lock_lock(a1 + 2);
    unsigned int v5 = [(os_unfair_lock_s *)a1 enqueuedMessage];

    if (!v5)
    {
      CFStringRef v6 = objc_alloc_init(IDSStewieProvisionMessage);
      [(os_unfair_lock_s *)a1 setEnqueuedMessage:v6];
    }
    uint64_t v7 = [(os_unfair_lock_s *)a1 enqueuedMessage];
    v3[2](v3, v7);

    [(os_unfair_lock_s *)a1 setCurrentInfoEditCount:[(os_unfair_lock_s *)a1 currentInfoEditCount] + 1];
    uint64_t v8 = [(os_unfair_lock_s *)a1 inProgressMessage];

    id v9 = [(os_unfair_lock_s *)a1 debounceTimer];
    if (v9)
    {
      int v10 = [(os_unfair_lock_s *)a1 currentInfoEditCount];
      BOOL v11 = v10 < (int)sub_1001EB93C(a1);
    }
    else
    {
      BOOL v11 = 0;
    }

    signed int v12 = [(os_unfair_lock_s *)a1 currentInfoEditCount];
    signed int v13 = sub_1001EB93C(a1);
    if (v8)
    {
      uint64_t v14 = +[IDSFoundationLog stewieProvisioning];
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v15 = [(os_unfair_lock_s *)a1 enqueuedMessage];
        long long v16 = [(os_unfair_lock_s *)a1 inProgressMessage];
        *(_DWORD *)buf = 138412546;
        CFStringRef v22 = v15;
        __int16 v23 = 2112;
        uint64_t v24 = v16;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Not dispatching stewie send yet { enqueuedMessage: %@, inProgressMessage: %@ }", buf, 0x16u);
      }
      goto LABEL_15;
    }
    if (v11)
    {
      sub_1001EC000((uint64_t)a1);
LABEL_14:
      [(os_unfair_lock_s *)a1 debounceTime];
      sub_1001EC0A0((uint64_t)a1, v17);
LABEL_15:
      os_unfair_lock_unlock(v4);
      goto LABEL_16;
    }
    if (v12 < v13) {
      goto LABEL_14;
    }
    sub_1001EC000((uint64_t)a1);
    id v20 = 0;
    int v18 = sub_1001EC234(a1, &v20);
    id v19 = v20;
    os_unfair_lock_unlock(a1 + 2);
    if (v18) {
      [(os_unfair_lock_s *)a1 addSignaturesAndSendMessage:v19];
    }
  }
LABEL_16:
}

void sub_1001EB2A0(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = +[IDSFoundationLog stewieProvisioning];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = 138412546;
    uint64_t v7 = v5;
    __int16 v8 = 2112;
    id v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Adding device info to message { deviceInfo: %@, message: %@ }", (uint8_t *)&v6, 0x16u);
  }

  [v3 addDeviceInfo:*(void *)(a1 + 32)];
}

void sub_1001EB410(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = +[IDSFoundationLog stewieProvisioning];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = 138412546;
    uint64_t v7 = v5;
    __int16 v8 = 2112;
    id v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Adding sms config to message { SMSConfig: %@, message: %@ }", (uint8_t *)&v6, 0x16u);
  }

  [v3 addSMSConfig:*(void *)(a1 + 32)];
}

void sub_1001EB580(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = +[IDSFoundationLog stewieProvisioning];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = 138412546;
    uint64_t v7 = v5;
    __int16 v8 = 2112;
    id v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Adding phone info to message { phoneInfos: %@, message: %@ }", (uint8_t *)&v6, 0x16u);
  }

  [v3 addPhoneNumberInfos:*(void *)(a1 + 32)];
}

void sub_1001EB6F0(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = +[IDSFoundationLog stewieProvisioning];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = 138412546;
    uint64_t v7 = v5;
    __int16 v8 = 2112;
    id v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Adding session key info to message { sessionKeyInfos: %@, message: %@ }", (uint8_t *)&v6, 0x16u);
  }

  [v3 addSessionKeyInfos:*(void *)(a1 + 32)];
}

void sub_1001EB860(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = +[IDSFoundationLog stewieProvisioning];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = 138412546;
    uint64_t v7 = v5;
    __int16 v8 = 2112;
    id v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Adding clear info to message { clearInfo: %@, message: %@ }", (uint8_t *)&v6, 0x16u);
  }

  [v3 addClearInfo:*(void *)(a1 + 32)];
}

uint64_t sub_1001EB93C(void *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = [a1 bag];
  id v2 = [v1 objectForKey:@"sps-prov-debounce-max-edit-count"];

  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    uint64_t v3 = (uint64_t)[v2 intValue];
  }
  else {
    uint64_t v3 = 20;
  }

  return v3;
}

void sub_1001EBBF8(void *a1, void *a2, void *a3)
{
  if (a1)
  {
    id v5 = a3;
    id v6 = a2;
    [a1 addPhoneNumberSigsToMessage:v6];
    sub_1001EBC78((uint64_t)a1, v6, v5);
  }
}

void sub_1001EBC78(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    if ([v5 needsPushIdentity])
    {
      IDSAssignPushIdentityToMessage();
      if (_os_feature_enabled_impl())
      {
        uint64_t v7 = +[IMRGLog registration];
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Using push signing API to sign over nil payload", buf, 2u);
        }

        __int16 v8 = *(void **)(a1 + 48);
        id v9 = [v5 serverTimestamp];
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 3221225472;
        v13[2] = sub_1001EBE84;
        void v13[3] = &unk_100985BC0;
        id v14 = v5;
        uint64_t v15 = v6;
        [v8 signDataWithPushIdentity:0 serverTimestamp:v9 withCompletion:v13];
      }
      else
      {
        [v5 pushPublicKey];
        [v5 pushPrivateKey];
        int v10 = [v5 serverTimestamp];
        _FTGenerateNonceAndSignatureFromPayload();
        id v11 = 0;
        id v12 = 0;

        [v5 setPushNonce:v11];
        [v5 setPushSig:v12];
        v6[2](v6);
      }
    }
    else
    {
      v6[2](v6);
    }
  }
}

uint64_t sub_1001EBE84(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  uint64_t v7 = *(void **)(a1 + 32);
  id v8 = a3;
  id v9 = a2;
  [v7 setPushNonce:a4];
  [*(id *)(a1 + 32) setPushSig:v9];

  if ([v8 count] == (id)1)
  {
    int v10 = [v8 objectAtIndexedSubscript:0];

    [*(id *)(a1 + 32) setPushCertificate:v10];
  }
  else
  {
    int v10 = IDSPEMFormatCertificatesForPushHeader();

    [*(id *)(a1 + 32) setPushCerts:v10];
  }

  id v11 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16);

  return v11();
}

void sub_1001EC000(uint64_t a1)
{
  if (a1)
  {
    if (os_unfair_lock_trylock((os_unfair_lock_t)(a1 + 8))) {
      sub_1007165EC();
    }
    id v2 = +[IDSFoundationLog stewieProvisioning];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Clearing debounce timer", v5, 2u);
    }

    uint64_t v3 = *(void **)(a1 + 88);
    if (v3)
    {
      [v3 invalidate];
      int v4 = *(void **)(a1 + 88);
      *(void *)(a1 + 88) = 0;
    }
  }
}

void sub_1001EC0A0(uint64_t a1, double a2)
{
  if (a1)
  {
    if (os_unfair_lock_trylock((os_unfair_lock_t)(a1 + 8))) {
      sub_100716618();
    }
    int v4 = +[IDSFoundationLog stewieProvisioning];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      id v5 = [(id)a1 enqueuedMessage];
      *(_DWORD *)buf = 67109378;
      int v13 = (int)a2;
      __int16 v14 = 2112;
      uint64_t v15 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Starting debounce timer, scheduling stewie send in %d seconds { enqueuedMessage : %@ }", buf, 0x12u);
    }
    if (!*(void *)(a1 + 88))
    {
      id v6 = objc_alloc((Class)IMDispatchTimer);
      uint64_t v7 = im_primary_queue();
      [(id)a1 debounceTime];
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 3221225472;
      _DWORD v11[2] = sub_1001EC3B8;
      void v11[3] = &unk_100980598;
      void v11[4] = a1;
      id v9 = [v6 initWithQueue:v7 interval:(unint64_t)v8 repeats:0 handlerBlock:v11];
      int v10 = *(void **)(a1 + 88);
      *(void *)(a1 + 88) = v9;
    }
  }
}

uint64_t sub_1001EC234(os_unfair_lock_s *a1, void *a2)
{
  if (!a1) {
    return 0;
  }
  if (os_unfair_lock_trylock(a1 + 2)) {
    sub_100716644();
  }
  int v4 = [(os_unfair_lock_s *)a1 enqueuedMessage];
  [(os_unfair_lock_s *)a1 addDeviceAndPhoneFieldsToMessage:v4];
  unsigned int v5 = [v4 needsDeviceInfo];
  if (!v5)
  {
    [(os_unfair_lock_s *)a1 setInProgressMessage:v4];
    [(os_unfair_lock_s *)a1 setEnqueuedMessage:0];
    [(os_unfair_lock_s *)a1 setCurrentInfoEditCount:0];
    if (a2) {
      *a2 = v4;
    }
    id v6 = +[IDSFoundationLog stewieProvisioning];
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_11;
    }
    int v10 = 138412290;
    id v11 = v4;
    uint64_t v7 = "Sending message %@";
    goto LABEL_10;
  }
  id v6 = +[IDSFoundationLog stewieProvisioning];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = 138412290;
    id v11 = v4;
    uint64_t v7 = "Message has no device info. Delaying send until populated %@";
LABEL_10:
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v10, 0xCu);
  }
LABEL_11:

  uint64_t v8 = v5 ^ 1;
  return v8;
}

id sub_1001EC3B8(uint64_t a1)
{
  return _[*(id *)(a1 + 32) debounceTimerFired];
}

void sub_1001EC564(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_1001EC580(uint64_t a1)
{
  id WeakRetained = (os_unfair_lock_s *)objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v3 = [*(id *)(a1 + 32) pushSig];
  if (!v3) {
    goto LABEL_8;
  }
  int v4 = (void *)v3;
  uint64_t v5 = [*(id *)(a1 + 32) pushNonce];
  if (!v5)
  {

    goto LABEL_8;
  }
  id v6 = (void *)v5;
  uint64_t v7 = [*(id *)(a1 + 32) pushCertificate];
  if (!v7)
  {
    uint64_t v8 = [*(id *)(a1 + 32) pushCerts];

    if (v8) {
      goto LABEL_7;
    }
LABEL_8:
    os_unfair_lock_lock(WeakRetained + 2);
    [(os_unfair_lock_s *)WeakRetained setInProgressMessage:0];
    os_unfair_lock_unlock(WeakRetained + 2);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_1001EC6D8;
    v9[3] = &unk_100985B98;
    id v10 = *(id *)(a1 + 32);
    sub_1001EAFA8(WeakRetained, v9);

    goto LABEL_9;
  }

LABEL_7:
  [(os_unfair_lock_s *)WeakRetained addCompletionBlockToMessage:*(void *)(a1 + 32)];
  sub_1001EC6E4(WeakRetained, *(void **)(a1 + 32));
LABEL_9:
}

id sub_1001EC6D8(uint64_t a1, void *a2)
{
  return [a2 addMessage:*(void *)(a1 + 32)];
}

void sub_1001EC6E4(void *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id location = (id)0xAAAAAAAAAAAAAAAALL;
    objc_initWeak(&location, a1);
    int v4 = [a1 validationQueue];
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472;
    v8[2] = sub_1001EC86C;
    v8[3] = &unk_100981198;
    objc_copyWeak(&v10, &location);
    id v5 = v3;
    id v9 = v5;
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    _DWORD v6[2] = sub_1001EC998;
    v6[3] = &unk_100985BE8;
    objc_copyWeak(&v7, &location);
    [v4 queueBuildingValidationDataIfNecessaryForMessage:v5 subsystem:2 withQueueCompletion:v8 sendBlock:v6];

    objc_destroyWeak(&v7);
    objc_destroyWeak(&v10);
    objc_destroyWeak(&location);
  }
}

void sub_1001EC840(_Unwind_Exception *a1)
{
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v3 - 72));
  _Unwind_Resume(a1);
}

void sub_1001EC86C(uint64_t a1, char a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v5 = +[IDSFoundationLog stewieProvisioning];
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v6)
    {
      uint64_t v7 = *(void *)(a1 + 32);
      int v9 = 138412290;
      uint64_t v10 = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Message queued while building validation data %@", (uint8_t *)&v9, 0xCu);
    }
  }
  else
  {
    if (v6)
    {
      uint64_t v8 = *(void *)(a1 + 32);
      int v9 = 138412290;
      uint64_t v10 = v8;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Validation data ready, sending message %@", (uint8_t *)&v9, 0xCu);
    }

    id v5 = [WeakRetained messageDelivery];
    [v5 sendMessage:*(void *)(a1 + 32)];
  }
}

void sub_1001EC998(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v5 = +[IDSFoundationLog stewieProvisioning];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 138412290;
    id v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Finished building validation data, sending message %@", (uint8_t *)&v7, 0xCu);
  }

  BOOL v6 = [WeakRetained messageDelivery];
  [v6 sendMessage:v3];
}

void sub_1001ECB48(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_1001ECB64(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9 = a2;
  uint64_t v10 = a3;
  id v11 = a5;
  id WeakRetained = (os_unfair_lock_s *)objc_loadWeakRetained((id *)(a1 + 40));
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    int v13 = v9;
    __int16 v14 = +[IDSFoundationLog stewieProvisioning];
    uint64_t v15 = v14;
    if (a4)
    {
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134218754;
        uint64_t v68 = a4;
        __int16 v69 = 2112;
        id v70 = v10;
        __int16 v71 = 2112;
        id v72 = v13;
        __int16 v73 = 2112;
        id v74 = v11;
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Message failed { responseCode: %ld, error: %@, message: %@, resultDictionary: %@ }", buf, 0x2Au);
      }

      [(os_unfair_lock_s *)WeakRetained debounceTime];
      double v17 = v16;
      int v18 = [v13 retryCount];
      double v19 = v17 * (double)((uint64_t)[v18 integerValue] + 1);

      [(os_unfair_lock_s *)WeakRetained maxRetryTime];
      if (v19 > v20)
      {
        [(os_unfair_lock_s *)WeakRetained maxRetryTime];
        double v19 = v21;
      }
      if (a4 > 6000)
      {
        switch(a4)
        {
          case 6001:
            goto LABEL_73;
          case 6002:
            goto LABEL_63;
          case 6003:
            goto LABEL_26;
          case 6004:
          case 6006:
          case 6007:
          case 6008:
          case 6009:
          case 6010:
          case 6011:
            goto LABEL_56;
          case 6005:
            goto LABEL_49;
          case 6012:
            CFStringRef v22 = +[IDSFoundationLog stewieProvisioning];
            if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
              sub_100716964();
            }

            __int16 v23 = [(os_unfair_lock_s *)WeakRetained delegate];
            [v23 requester:*(void *)(a1 + 32) receivedReplaceAllSessionKeysForRequest:v13];
            a4 = 6012;
            goto LABEL_69;
          default:
            if (a4 != 8000) {
              goto LABEL_56;
            }
            id v53 = +[IDSFoundationLog stewieProvisioning];
            if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
              sub_1007168FC();
            }

            __int16 v23 = [(os_unfair_lock_s *)WeakRetained validationQueue];
            [v23 cleanupValidationInfoForSubsystemMechanism:2];
            a4 = 8000;
            break;
        }
        goto LABEL_69;
      }
      if (a4 == 440)
      {
        uint64_t v54 = [v13 baaSigningError];
        unsigned int v55 = +[IDSBAASigner shouldRetryError:v54];

        if (!v55)
        {
LABEL_73:
          id v64 = +[IDSFoundationLog stewieProvisioning];
          if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR)) {
            sub_100716750();
          }

          [(os_unfair_lock_s *)WeakRetained removeAndReportFailuresFromMessage:v13 differingFromResponseCode:6001];
          sub_1001ED850(WeakRetained);
          goto LABEL_72;
        }
        id v56 = +[IDSFoundationLog stewieProvisioning];
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
        {
          id v57 = [v13 baaSigningError];
          *(_DWORD *)buf = 138412290;
          uint64_t v68 = (uint64_t)v57;
          _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "Received BAA DoNotRetry, but see we should retry due to client error %@", buf, 0xCu);
        }
LABEL_63:
        id v58 = [v11 objectForKeyedSubscript:@"retry-interval"];
        __int16 v23 = v58;
        if (v58)
        {
          [v58 doubleValue];
          double v19 = v59;
          [(os_unfair_lock_s *)WeakRetained debounceTime];
          if (v19 < v60)
          {
            [(os_unfair_lock_s *)WeakRetained debounceTime];
            double v19 = v61;
          }
        }
        id v62 = +[IDSFoundationLog stewieProvisioning];
        if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
          sub_1007166E8();
        }

        a4 = 6002;
        goto LABEL_69;
      }
      if (a4 == 441)
      {
LABEL_49:
        uint64_t v51 = +[IDSFoundationLog stewieProvisioning];
        if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
          sub_100716894();
        }

        uint64_t v52 = [(os_unfair_lock_s *)WeakRetained validationQueue];
        [v52 purgeCachedCertsForSubsystemMechanism:2];

        __int16 v23 = [(os_unfair_lock_s *)WeakRetained validationQueue];
        [v23 cleanupValidationInfoForSubsystemMechanism:2];
        goto LABEL_69;
      }
      if (a4 != 443)
      {
LABEL_56:
        __int16 v23 = +[IDSFoundationLog stewieProvisioning];
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          sub_100716670((uint64_t)v13, a4, v23);
        }
        goto LABEL_69;
      }
LABEL_26:
      __int16 v23 = [v11 objectForKeyedSubscript:@"current-timestamp-ms"];
      if (!_os_feature_enabled_impl() || v23)
      {
LABEL_36:
        if (v23)
        {
          [v13 setServerTimestamp:v23];
          uint64_t v41 = +[NSDate date];
          [v41 timeIntervalSince1970];
          id v42 = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:");
          [v13 setServerTimestampReceivedDate:v42];
        }
        uint64_t v43 = +[IDSFoundationLog stewieProvisioning];
        if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
          sub_1007167B8();
        }

LABEL_69:
        [(os_unfair_lock_s *)WeakRetained removeAndReportFailuresFromMessage:v13 differingFromResponseCode:a4];
        id v63 = +[IDSFoundationLog stewieProvisioning];
        if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134218242;
          uint64_t v68 = (uint64_t)v19;
          __int16 v69 = 2112;
          id v70 = v13;
          _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "Scheduling retry { nextRetry: %ld, message: %@ }", buf, 0x16u);
        }

        im_dispatch_after_primary_queue();
        goto LABEL_72;
      }
      uint64_t v38 = [v11 objectForKey:@"x-apple-server-time"];
      if (v38)
      {
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          id v39 = objc_alloc_init((Class)NSNumberFormatter);
          __int16 v23 = [v39 numberFromString:v38];

          if (v23) {
            goto LABEL_35;
          }
        }
        CFStringRef v40 = +[IDSFoundationLog stewieProvisioning];
        if (os_log_type_enabled(v40, OS_LOG_TYPE_FAULT)) {
          sub_100716820();
        }
      }
      __int16 v23 = 0;
LABEL_35:

      goto LABEL_36;
    }
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134218242;
      uint64_t v68 = 0;
      __int16 v69 = 2112;
      id v70 = v13;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Received successful response for stewie provision { responseCode: %ld, message: %@ }", buf, 0x16u);
    }
    id v66 = v10;

    uint64_t v24 = [(os_unfair_lock_s *)WeakRetained delegate];
    [v24 requester:WeakRetained succeededRequest:v13];

    uint64_t v25 = [v13 successfulResponsesOfType:3];
    if (v25)
    {
      id v26 = [(os_unfair_lock_s *)WeakRetained delegate];
      uint64_t v27 = [v25 lastObject];
      id v28 = [v27 request];
      [v26 requester:WeakRetained receivedSuccessForClearInfo:v28];
    }
    __int16 v29 = [v13 successfulResponsesOfType:0];
    if (v29)
    {
      CFStringRef v30 = [(os_unfair_lock_s *)WeakRetained delegate];
      id v31 = [v29 lastObject];
      id v32 = [v31 request];
      [v30 requester:WeakRetained receivedSuccessForDeviceInfo:v32];
    }
    uint64_t v33 = -[NSObject successfulResponsesOfType:](v13, "successfulResponsesOfType:", 1, v11);
    uint64_t v34 = [v13 failuresOfType:1];
    id v35 = (void *)v34;
    if (v33)
    {
      uint64_t v36 = objc_msgSend(v33, "__imArrayByApplyingBlock:", &stru_100985C50);
      id v37 = [(os_unfair_lock_s *)WeakRetained delegate];
      [v37 requester:WeakRetained receivedSuccessForPhoneNumberInfos:v36];

      if (!v35) {
        goto LABEL_44;
      }
    }
    else if (!v34)
    {
      uint64_t v44 = [(os_unfair_lock_s *)WeakRetained delegate];
      [v44 requester:WeakRetained receivedSuccessForPhoneNumberInfos:&__NSArray0__struct];
      goto LABEL_43;
    }
    uint64_t v44 = [(os_unfair_lock_s *)WeakRetained delegate];
    [v44 requester:WeakRetained receivedFailuresForPhoneNumberInfos:v35];
LABEL_43:

LABEL_44:
    uint64_t v45 = [v13 successfulResponsesOfType:2];
    id v46 = v45;
    if (v45)
    {
      unsigned int v47 = objc_msgSend(v45, "__imArrayByApplyingBlock:", &stru_100985C90);
      CFStringRef v48 = [(os_unfair_lock_s *)WeakRetained delegate];
      [v48 requester:WeakRetained receivedSuccessForSessionKeyInfos:v47];
    }
    CFStringRef v49 = [v13 failuresOfType:2];
    if (v49)
    {
      uint64_t v50 = [(os_unfair_lock_s *)WeakRetained delegate];
      [v50 requester:WeakRetained receivedFailuresForSessionKeyInfos:v49];
    }
    sub_1001ED850(WeakRetained);

    id v11 = v65;
    uint64_t v10 = v66;
    goto LABEL_72;
  }
  int v13 = +[IDSFoundationLog stewieProvisioning];
  if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT)) {
    sub_1007169CC();
  }
LABEL_72:
}

void sub_1001ED54C(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 8));
  uint64_t v2 = +[IDSFoundationLog stewieProvisioning];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(a1 + 32) enqueuedMessage];
    int v4 = [*(id *)(a1 + 32) inProgressMessage];
    *(_DWORD *)buf = 138412546;
    *(void *)&uint8_t buf[4] = v3;
    __int16 v18 = 2112;
    double v19 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Retrying message. Merging in enqueued data { enqueued: %@, inProgress: %@ }", buf, 0x16u);
  }
  id v5 = [*(id *)(a1 + 32) enqueuedMessage];

  if (v5)
  {
    BOOL v6 = [*(id *)(a1 + 32) inProgressMessage];
    int v7 = [*(id *)(a1 + 32) enqueuedMessage];
    [v6 addMessage:v7];

    [*(id *)(a1 + 32) setEnqueuedMessage:0];
  }
  id v8 = [*(id *)(a1 + 32) inProgressMessage];
  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 8));
  id v9 = [v8 retryCount];
  uint64_t v10 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", (char *)[v9 integerValue] + 1);
  [v8 setRetryCount:v10];

  *(void *)buf = 0xAAAAAAAAAAAAAAAALL;
  objc_initWeak((id *)buf, *(id *)(a1 + 32));
  id v11 = *(void **)(a1 + 32);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_1001ED7DC;
  void v13[3] = &unk_100985C10;
  objc_copyWeak(&v15, (id *)buf);
  char v16 = *(unsigned char *)(a1 + 40);
  id v12 = v8;
  id v14 = v12;
  sub_1001EBBF8(v11, v12, v13);

  objc_destroyWeak(&v15);
  objc_destroyWeak((id *)buf);
}

void sub_1001ED7B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1001ED7DC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v4 = WeakRetained;
  if (*(unsigned char *)(a1 + 48))
  {
    sub_1001EC6E4(WeakRetained, *(void **)(a1 + 32));
  }
  else
  {
    id v3 = [WeakRetained messageDelivery];
    [v3 sendMessage:*(void *)(a1 + 32)];
  }
}

void sub_1001ED850(os_unfair_lock_s *a1)
{
  if (a1)
  {
    uint64_t v2 = a1 + 2;
    os_unfair_lock_lock(a1 + 2);
    [(os_unfair_lock_s *)a1 setInProgressMessage:0];
    id v3 = [(os_unfair_lock_s *)a1 enqueuedMessage];

    os_unfair_lock_unlock(v2);
    if (v3)
    {
      id v4 = +[IDSFoundationLog stewieProvisioning];
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        sub_100716A40(v4);
      }

      sub_1001EAFA8(a1, &stru_100985CD8);
    }
  }
}

IDSStewiePhoneNumberInfo *__cdecl sub_1001ED8F8(id a1, IDSStewieProvisionInfoResponse *a2)
{
  return (IDSStewiePhoneNumberInfo *)[(IDSStewieProvisionInfoResponse *)a2 request];
}

IDSStewieSessionKeyInfo *__cdecl sub_1001ED900(id a1, IDSStewieProvisionInfoResponse *a2)
{
  return (IDSStewieSessionKeyInfo *)[(IDSStewieProvisionInfoResponse *)a2 request];
}

IDSStewieProvisionInfoRequest *__cdecl sub_1001EDA64(id a1, IDSStewieProvisionInfoResponse *a2)
{
  return [(IDSStewieProvisionInfoResponse *)a2 request];
}

IDSStewieProvisionInfoRequest *__cdecl sub_1001EDA6C(id a1, IDSStewieProvisionInfoResponse *a2)
{
  return [(IDSStewieProvisionInfoResponse *)a2 request];
}

void sub_1001EDD18(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_1001EDE98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_1001EDEB0()
{
  uint64_t v4 = 0;
  id v5 = &v4;
  uint64_t v6 = 0x2050000000;
  id v0 = (void *)qword_100A4AA68;
  uint64_t v7 = qword_100A4AA68;
  if (!qword_100A4AA68)
  {
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_1001EF080;
    v3[3] = &unk_10097ED88;
    void v3[4] = &v4;
    sub_1001EF080((uint64_t)v3);
    id v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);

  return v1;
}

void sub_1001EDF80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1001EE568(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

uint64_t sub_1001EE5B0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1001EE5C0(uint64_t a1)
{
}

id sub_1001EE5C8()
{
  uint64_t v4 = 0;
  id v5 = &v4;
  uint64_t v6 = 0x2050000000;
  id v0 = (void *)qword_100A4AA78;
  uint64_t v7 = qword_100A4AA78;
  if (!qword_100A4AA78)
  {
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_1001EF130;
    v3[3] = &unk_10097ED88;
    void v3[4] = &v4;
    sub_1001EF130((uint64_t)v3);
    id v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);

  return v1;
}

void sub_1001EE698(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_1001EE6B0()
{
  uint64_t v4 = 0;
  id v5 = &v4;
  uint64_t v6 = 0x2020000000;
  id v0 = (void **)qword_100A4AA80;
  uint64_t v7 = qword_100A4AA80;
  if (!qword_100A4AA80)
  {
    id v1 = (void *)sub_1001EEF14();
    v5[3] = (uint64_t)dlsym(v1, "CNContactEmailAddressesKey");
    qword_100A4AA80 = v5[3];
    id v0 = (void **)v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (!v0) {
    sub_100716A84();
  }
  uint64_t v2 = *v0;

  return v2;
}

void sub_1001EE7A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_1001EE7BC()
{
  uint64_t v4 = 0;
  id v5 = &v4;
  uint64_t v6 = 0x2020000000;
  id v0 = (void **)qword_100A4AA88;
  uint64_t v7 = qword_100A4AA88;
  if (!qword_100A4AA88)
  {
    id v1 = (void *)sub_1001EEF14();
    v5[3] = (uint64_t)dlsym(v1, "CNContactPhoneNumbersKey");
    qword_100A4AA88 = v5[3];
    id v0 = (void **)v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (!v0) {
    sub_100716AFC();
  }
  uint64_t v2 = *v0;

  return v2;
}

void sub_1001EE8B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_1001EE8C8()
{
  uint64_t v4 = 0;
  id v5 = &v4;
  uint64_t v6 = 0x2020000000;
  id v0 = (void **)qword_100A4AAA0;
  uint64_t v7 = qword_100A4AAA0;
  if (!qword_100A4AAA0)
  {
    id v1 = (void *)sub_1001EEF14();
    v5[3] = (uint64_t)dlsym(v1, "CNContactTypeKey");
    qword_100A4AAA0 = v5[3];
    id v0 = (void **)v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (!v0) {
    sub_100716B74();
  }
  uint64_t v2 = *v0;

  return v2;
}

void sub_1001EE9BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_1001EE9D4()
{
  uint64_t v4 = 0;
  id v5 = &v4;
  uint64_t v6 = 0x2050000000;
  id v0 = (void *)qword_100A4AAA8;
  uint64_t v7 = qword_100A4AAA8;
  if (!qword_100A4AAA8)
  {
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_1001EF318;
    v3[3] = &unk_10097ED88;
    void v3[4] = &v4;
    sub_1001EF318((uint64_t)v3);
    id v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);

  return v1;
}

void sub_1001EEAA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001EEABC(uint64_t a1, void *a2, unsigned char *a3)
{
  id v17 = a2;
  id v7 = [v17 contactType];
  id v8 = v17;
  if (!v7)
  {
    id v9 = [v17 givenName];
    id v10 = [v9 length];
    id v11 = v17;
    id v12 = v10;
    if (!v10)
    {
      id v3 = [v17 familyName];
      if (![v3 length])
      {

        id v8 = v17;
        goto LABEL_13;
      }
      id v11 = v17;
    }
    int v13 = [v11 emailAddresses];
    if ([v13 count])
    {

      if (!v12) {
LABEL_12:
      }
      objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), a2);
      id v8 = v17;
      *a3 = 1;
      goto LABEL_13;
    }
    id v14 = [v17 phoneNumbers];
    id v15 = [v14 count];

    if (!v12) {
    id v8 = v17;
    }
    if (v15) {
      goto LABEL_12;
    }
  }
LABEL_13:

  return _objc_release_x1(v7, v8);
}

void sub_1001EEDCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1001EEDF8(uint64_t a1, void *a2)
{
  id v5 = a2;
  if (![v5 contactType])
  {
    id v3 = [v5 emailAddresses];
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += [v3 count];

    uint64_t v4 = [v5 phoneNumbers];
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += [v4 count];
  }
}

Class sub_1001EEEBC(uint64_t a1)
{
  sub_1001EEF14();
  Class result = objc_getClass("CNContactStore");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    sub_100716BEC();
  }
  qword_100A4AA58 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t sub_1001EEF14()
{
  v2[0] = 0;
  if (!qword_100A4AA60)
  {
    v2[1] = _NSConcreteStackBlock;
    v2[2] = (void *)3221225472;
    v2[3] = sub_1001EF00C;
    void v2[4] = &unk_10097EA18;
    void v2[5] = v2;
    long long v3 = off_100985D80;
    uint64_t v4 = 0;
    qword_100A4AA60 = _sl_dlopen();
  }
  uint64_t v0 = qword_100A4AA60;
  if (!qword_100A4AA60) {
    sub_100716C68(v2);
  }
  if (v2[0]) {
    free(v2[0]);
  }
  return v0;
}

uint64_t sub_1001EF00C()
{
  uint64_t result = _sl_dlopen();
  qword_100A4AA60 = result;
  return result;
}

Class sub_1001EF080(uint64_t a1)
{
  sub_1001EEF14();
  Class result = objc_getClass("CNContact");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    sub_100716CE8();
  }
  qword_100A4AA68 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

Class sub_1001EF0D8(uint64_t a1)
{
  sub_1001EEF14();
  Class result = objc_getClass("CNPhoneNumber");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    sub_100716D64();
  }
  qword_100A4AA70 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

Class sub_1001EF130(uint64_t a1)
{
  sub_1001EEF14();
  Class result = objc_getClass("CNContactFormatter");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    sub_100716DE0();
  }
  qword_100A4AA78 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *sub_1001EF188(uint64_t a1)
{
  uint64_t v2 = (void *)sub_1001EEF14();
  Class result = dlsym(v2, "CNContactEmailAddressesKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  qword_100A4AA80 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *sub_1001EF1D8(uint64_t a1)
{
  uint64_t v2 = (void *)sub_1001EEF14();
  Class result = dlsym(v2, "CNContactPhoneNumbersKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  qword_100A4AA88 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *sub_1001EF228(uint64_t a1)
{
  uint64_t v2 = (void *)sub_1001EEF14();
  Class result = dlsym(v2, "CNContactGivenNameKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  qword_100A4AA90 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *sub_1001EF278(uint64_t a1)
{
  uint64_t v2 = (void *)sub_1001EEF14();
  Class result = dlsym(v2, "CNContactFamilyNameKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  qword_100A4AA98 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *sub_1001EF2C8(uint64_t a1)
{
  uint64_t v2 = (void *)sub_1001EEF14();
  Class result = dlsym(v2, "CNContactTypeKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  qword_100A4AAA0 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

Class sub_1001EF318(uint64_t a1)
{
  sub_1001EEF14();
  Class result = objc_getClass("CNContactFetchRequest");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    sub_100716E5C();
  }
  qword_100A4AAA8 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_1001EF7D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1001EF7F0(uint64_t a1, void *a2, unsigned char *a3)
{
  id v5 = *(void **)(a1 + 32);
  uint64_t v6 = [a2 keyIndex];
  id v7 = [v6 UUIDString];
  LODWORD(v5) = [v5 isEqualToString:v7];

  if (v5)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
    *a3 = 1;
  }
}

void sub_1001F03F4(id a1)
{
  byte_100A4AAB0 = sub_100009A28(kIDSRegistrationEntitlement);
  byte_100A4AAB1 = sub_100009A28(kIDSSessionEntitlement);
  byte_100A4AAB2 = sub_100009A28(kIDSMessagingEntitlement);
}

void sub_1001F0714(id a1, NSArray *a2, NSError *a3)
{
  uint64_t v4 = a2;
  id v5 = a3;
  uint64_t v6 = +[IDSFoundationLog stewieProvisioning];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 138412546;
    id v8 = v4;
    __int16 v9 = 2112;
    id v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "ACMonitoredAccountStore registration found accounts: %@ with error: %@", (uint8_t *)&v7, 0x16u);
  }
}

void sub_1001F07EC(uint64_t a1)
{
  id v1 = *(void **)(a1 + 32);
  v3[0] = @"networking.st.text-911";
  v3[1] = @"networking.st.find-my";
  v3[2] = @"networking.st.roadside";
  v3[3] = @"networking.st.imessage-lite";
  void v3[4] = @"networking.st.sms";
  uint64_t v2 = +[NSArray arrayWithObjects:v3 count:5];
  [v1 requestAccessTokensForFeatures:v2];
}

id sub_1001F0B14(uint64_t a1)
{
  if (a1)
  {
    id v1 = IMCurrentPreferredLanguage();
    if (([v1 containsString:@"-"] & 1) == 0)
    {
      uint64_t v2 = +[NSLocale autoupdatingCurrentLocale];
      long long v3 = [v2 objectForKey:NSLocaleLanguageCode];

      uint64_t v4 = +[NSLocale autoupdatingCurrentLocale];
      id v5 = [v4 objectForKey:NSLocaleCountryCode];

      uint64_t v6 = [v5 uppercaseString];
      uint64_t v7 = +[NSString stringWithFormat:@"%@-%@", v3, v6];

      id v1 = (void *)v7;
    }
  }
  else
  {
    id v1 = 0;
  }

  return v1;
}

void sub_1001F0C28(void *a1)
{
  if (a1)
  {
    uint64_t v2 = sub_1001F1390(a1);
    if (v2)
    {
      id v4 = v2;
      long long v3 = [a1 delegate];
      [v3 deviceInfoManager:a1 deviceInfoChanged:v4];

      uint64_t v2 = v4;
    }
  }
}

void sub_1001F0ECC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = [*(id *)(a1 + 32) mainQueue];
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  _DWORD v11[2] = sub_1001F0FB8;
  void v11[3] = &unk_10097E5A8;
  id v12 = v5;
  id v13 = v6;
  id v8 = *(void **)(a1 + 48);
  uint64_t v14 = *(void *)(a1 + 40);
  id v15 = v8;
  id v9 = v6;
  id v10 = v5;
  dispatch_async(v7, v11);
}

id sub_1001F0FB8(uint64_t a1)
{
  if (*(void *)(a1 + 32) && !*(void *)(a1 + 40))
  {
    id v6 = +[IDSFoundationLog stewieProvisioning];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = [*(id *)(a1 + 32) accessToken];
      uint64_t v8 = *(void *)(a1 + 48);
      int v9 = 138478083;
      id v10 = v7;
      __int16 v11 = 2112;
      uint64_t v12 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Received cloud feature access token %{private}@ for featureID %@", (uint8_t *)&v9, 0x16u);
    }
    return [*(id *)(a1 + 56) fulfillWithValue:*(void *)(a1 + 32)];
  }
  else
  {
    uint64_t v2 = +[IDSFoundationLog stewieProvisioning];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      long long v3 = *(void **)(a1 + 40);
      uint64_t v4 = *(void *)(a1 + 48);
      int v9 = 138412546;
      id v10 = v3;
      __int16 v11 = 2112;
      uint64_t v12 = v4;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Received error %@ fetching cloud feature access token for featureID %@", (uint8_t *)&v9, 0x16u);
    }

    return [*(id *)(a1 + 56) failWithError:*(void *)(a1 + 40)];
  }
}

void sub_1001F1124(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init((Class)NSMutableArray);
  id v5 = objc_alloc_init((Class)NSMutableArray);
  double v19 = v3;
  id v6 = [v3 value];
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  id v7 = [v6 countByEnumeratingWithState:&v20 objects:v24 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v21;
    do
    {
      for (uint64_t i = 0; i != v8; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v21 != v9) {
          objc_enumerationMutation(v6);
        }
        __int16 v11 = *(void **)(*((void *)&v20 + 1) + 8 * i);
        if (![v11 state])
        {
          uint64_t v12 = [v11 value];

          if (v12)
          {
            id v13 = [v11 value];
            uint64_t v14 = [v13 accessToken];
            if (v14)
            {
              id v15 = (void *)v14;
              char v16 = [v13 featureID];

              if (v16)
              {
                id v17 = [v13 accessToken];
                [v5 addObject:v17];

                __int16 v18 = [v13 featureID];
                [v4 addObject:v18];
              }
            }
          }
        }
      }
      id v8 = [v6 countByEnumeratingWithState:&v20 objects:v24 count:16];
    }
    while (v8);
  }
  [*(id *)(a1 + 32) setAccessTokens:v5];
  [*(id *)(a1 + 32) setFeatureIDs:v4];
  sub_1001F0C28(*(void **)(a1 + 32));
}

IDSStewieDeviceInfo *sub_1001F1390(void *a1)
{
  if (a1)
  {
    uint64_t v2 = [a1 locale];
    if (v2)
    {
      id v3 = [a1 pushToken];

      if (v3)
      {
        id v4 = [IDSStewieDeviceInfo alloc];
        id v5 = [a1 locale];
        id v6 = [a1 pushToken];
        id v7 = [a1 dsid];
        id v8 = [a1 accessTokens];
        uint64_t v9 = [a1 featureIDs];
        uint64_t v2 = [(IDSStewieDeviceInfo *)v4 initWithLocale:v5 pushToken:v6 dsid:v7 accessTokens:v8 featureIDs:v9];
      }
      else
      {
        uint64_t v2 = 0;
      }
    }
    id v10 = +[IDSFoundationLog stewieProvisioning];
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v11 = [a1 pushToken];
      uint64_t v12 = [v11 debugDescription];
      id v13 = [a1 locale];
      uint64_t v14 = [a1 dsid];
      id v15 = [a1 accessTokens];
      char v16 = [a1 featureIDs];
      int v18 = 138413314;
      double v19 = v12;
      __int16 v20 = 2112;
      long long v21 = v13;
      __int16 v22 = 2112;
      long long v23 = v14;
      __int16 v24 = 2112;
      uint64_t v25 = v15;
      __int16 v26 = 2112;
      uint64_t v27 = v16;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Constructing stewie device info for delegate { pushToken: %@, locale: %@, dsid: %@, accessTokens: %@, featureIDs: %@ }", (uint8_t *)&v18, 0x34u);
    }
  }
  else
  {
    uint64_t v2 = 0;
  }

  return v2;
}

void sub_1001F1900(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    id v5 = [v3 accountPropertyForKey:@"primaryAccount"];
    unsigned int v6 = [v5 BOOLValue];

    if (v6)
    {
      id v7 = [a1 accountStore];
      id v8 = objc_msgSend(v7, "aa_primaryAppleAccount");
      uint64_t v9 = [v8 normalizedDSID];

      id v10 = [a1 dsid];
      if ([v9 isEqualToString:v10])
      {

LABEL_11:
        goto LABEL_12;
      }
      if (v9)
      {
      }
      else
      {
        __int16 v11 = [a1 dsid];

        if (!v11) {
          goto LABEL_11;
        }
      }
      uint64_t v12 = +[IDSFoundationLog stewieProvisioning];
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        id v13 = [a1 dsid];
        int v14 = 138412546;
        id v15 = v13;
        __int16 v16 = 2112;
        id v17 = v9;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Found new dsid { old : %@, new: %@ }", (uint8_t *)&v14, 0x16u);
      }
      [a1 setDsid:v9];
      sub_1001F0C28(a1);
      goto LABEL_11;
    }
  }
LABEL_12:
}

void sub_1001F1BE4(uint64_t a1)
{
}

void sub_1001F1D28(uint64_t a1)
{
}

void sub_1001F1E6C(uint64_t a1)
{
}

void sub_1001F1FB0(uint64_t a1)
{
}

void sub_1001F2148(id a1)
{
  id v1 = *(const void **)IMWeakLinkSymbol();
  qword_100A4AAC8 = (uint64_t)v1;
  if (v1)
  {
    CFRetain(v1);
  }
}

void sub_1001F21EC(id a1)
{
  id v1 = objc_alloc_init(IDSDaemonXPCInterface);
  uint64_t v2 = qword_100A4AAD8;
  qword_100A4AAD8 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_1001F23FC(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = a2;
  id v4 = [v2 observer];
  [v3 appendMiddleware:v4];
}

uint64_t sub_1001F2860(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) object];
  id v3 = [v2 observerProxies];
  [v3 removeObject:*(void *)(a1 + 40)];

  id v4 = [*(id *)(a1 + 32) object];
  id v5 = [v4 observerProxies];
  id v6 = [v5 count];

  if (!v6)
  {
    id v7 = [*(id *)(a1 + 32) object];
    [v7 setObserverProxies:0];
  }
  id v8 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v10 = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Daemon Invalidation Handled", v10, 2u);
  }

  uint64_t result = os_log_shim_legacy_logging_enabled();
  if (result)
  {
    uint64_t result = _IDSShouldLog();
    if (result) {
      return _IDSLogV();
    }
  }
  return result;
}

uint64_t sub_1001F29A8(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) object];
  id v3 = [v2 observerProxies];
  [v3 removeObject:*(void *)(a1 + 40)];

  id v4 = [*(id *)(a1 + 32) object];
  id v5 = [v4 observerProxies];
  id v6 = [v5 count];

  if (!v6)
  {
    id v7 = [*(id *)(a1 + 32) object];
    [v7 setObserverProxies:0];
  }
  id v8 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v10 = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Daemon Interruption Handled", v10, 2u);
  }

  uint64_t result = os_log_shim_legacy_logging_enabled();
  if (result)
  {
    uint64_t result = _IDSShouldLog();
    if (result) {
      return _IDSLogV();
    }
  }
  return result;
}

void sub_1001F2C64(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 32);
      uint64_t v6 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138478339;
      uint64_t v8 = v5;
      __int16 v9 = 2114;
      uint64_t v10 = v6;
      __int16 v11 = 2114;
      id v12 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Daemon failed to broadcast didCreateGroup {group: %{private}@, observerProxy: %{public}@, error: %{public}@", buf, 0x20u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
  }
}

void sub_1001F2F14(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 32);
      uint64_t v6 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138478339;
      uint64_t v8 = v5;
      __int16 v9 = 2114;
      uint64_t v10 = v6;
      __int16 v11 = 2114;
      id v12 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Daemon failed to broadcast didCacheGroup {group: %{private}@, observerProxy: %{public}@, error: %{public}@", buf, 0x20u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
  }
}

void sub_1001F31F0(void *a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = a1[4];
      uint64_t v6 = a1[5];
      uint64_t v7 = a1[6];
      *(_DWORD *)buf = 138478595;
      uint64_t v9 = v5;
      __int16 v10 = 2113;
      uint64_t v11 = v6;
      __int16 v12 = 2114;
      uint64_t v13 = v7;
      __int16 v14 = 2114;
      id v15 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Daemon failed to broadcast didUpdateGroup {previousGroup: %{private}@, updatedGroup: %{private}@, observerProxy: %{public}@, error:%{public}@}", buf, 0x2Au);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
  }
}

void sub_1001F34B4(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 32);
      uint64_t v6 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138478339;
      uint64_t v8 = v5;
      __int16 v9 = 2114;
      uint64_t v10 = v6;
      __int16 v11 = 2114;
      id v12 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Daemon failed to broadcast didReceiveDecryptionFailureForGroup {group: %{private}@, observerProxy: %{public}@, error:%{public}@}", buf, 0x20u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
  }
}

void sub_1001F3738(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138543618;
      uint64_t v7 = v5;
      __int16 v8 = 2114;
      id v9 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Daemon failed to broadcast didReceiveRegistrationIdentityUpdate {observerProxy: %{public}@, error:%{public}@}", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
  }
}

void sub_1001F3ED8(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSFoundationLog delivery];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = [v3 chunkNumber];
    *(_DWORD *)buf = 138412546;
    uint64_t v20 = v5;
    __int16 v21 = 2112;
    __int16 v22 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "GUID %@ Received APNS ack for MML %@", buf, 0x16u);
  }
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  uint64_t v7 = objc_msgSend(v3, "aggregateMessages", 0);
  id v8 = [v7 countByEnumeratingWithState:&v14 objects:v18 count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v15;
    do
    {
      for (uint64_t i = 0; i != v9; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v15 != v10) {
          objc_enumerationMutation(v7);
        }
        id v12 = *(void **)(*((void *)&v14 + 1) + 8 * i);
        uint64_t v13 = [v12 deliveryAcknowledgementBlock];
        ((void (**)(void, void *))v13)[2](v13, v12);
      }
      id v9 = [v7 countByEnumeratingWithState:&v14 objects:v18 count:16];
    }
    while (v9);
  }
}

void sub_1001F4138(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSFoundationLog delivery];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = [v3 chunkNumber];
    int v7 = 138412546;
    uint64_t v8 = v5;
    __int16 v9 = 2112;
    uint64_t v10 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "GUID %@ Received APNS ack for Fanout %@", (uint8_t *)&v7, 0x16u);
  }
  [v3 callAllAckBlocks];
}

void sub_1001F43CC(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSFoundationLog delivery];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = *(void *)(a1 + 40);
    int v9 = 138412546;
    uint64_t v10 = v5;
    __int16 v11 = 2112;
    uint64_t v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "GUID %@ APNS ack received for destination %@", (uint8_t *)&v9, 0x16u);
  }

  int v7 = [*(id *)(a1 + 48) delegate];
  [v7 receivedAPNSAckForMessage:v3 guid:*(void *)(a1 + 32)];

  [*(id *)(a1 + 56) removeObject:*(void *)(a1 + 64)];
  if (![*(id *)(a1 + 56) count])
  {
    uint64_t v8 = [*(id *)(a1 + 48) delegate];
    [v8 finishedTrackingAPNSAcksWithURIs:*(void *)(a1 + 72) guid:*(void *)(a1 + 32)];
  }
}

void sub_1001F4AFC(id a1)
{
  id v1 = objc_alloc_init(IDSDSessionController);
  uint64_t v2 = qword_100A4AAE8;
  qword_100A4AAE8 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

id sub_1001F542C(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = a2;
  id v4 = [v2 identifier];
  uint64_t v5 = +[IDSURI URIWithPrefixedURI:v3 withServiceLoggingHint:v4];

  return v5;
}

id sub_1001F6828(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = [a2 objectForKey:v5];
  if (objc_opt_isKindOfClass())
  {
    id v7 = v6;
  }
  else
  {
    if (v6)
    {
      uint64_t v8 = +[IMRGLog registration];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
        sub_10071743C((uint64_t)v5, a1, v8);
      }
    }
    id v7 = 0;
  }

  return v7;
}

void sub_1001F68E4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 96));
  id v5 = [WeakRetained setupNewIncomingSessionWithOptions:*(void *)(a1 + 32)];
  if (v5)
  {
    uint64_t v6 = objc_opt_class();
    id v7 = sub_1001F6828(v6, *(void **)(a1 + 48), IDSDSessionMessageTransportType);
    uint64_t v8 = IDSDSessionMessageQuickRelaySessionToken;
    int v9 = [*(id *)(a1 + 48) objectForKey:IDSDSessionMessageQuickRelaySessionToken];
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      uint64_t v10 = [*(id *)(a1 + 48) objectForKey:v8];
      uint64_t v11 = +[NSData _IDSDataFromBase64String:v10];
    }
    else
    {
      uint64_t v10 = [*(id *)(a1 + 48) objectForKey:v8];
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        [v5 setQuickRelaySessionToken:0];
        goto LABEL_11;
      }
      uint64_t v11 = [*(id *)(a1 + 48) objectForKey:v8];
    }
    uint64_t v13 = (void *)v11;
    [v5 setQuickRelaySessionToken:v11];

LABEL_11:
    uint64_t v14 = objc_opt_class();
    long long v15 = sub_1001F6828(v14, *(void **)(a1 + 48), IDSDSessionMessageUseCloudPairedControlChannel);
    [v5 setRemoteUseCloudPairedControlChannel:v15];
    uint64_t v16 = objc_opt_class();
    long long v17 = sub_1001F6828(v16, *(void **)(a1 + 48), IDSDSessionMessageUsePhoneContinuityLocalMessage);
    [v5 setRemoteUsePhoneContinuityLocalMessage:v17];
    [v5 submitAWDMetricsForIDSSessionInvitationReceived];
    uint64_t v18 = objc_opt_class();
    double v19 = (void *)IDSDSessionMessageDeclineOnNetworkError;
    uint64_t v20 = sub_1001F6828(v18, *(void **)(a1 + 48), IDSDSessionMessageDeclineOnNetworkError);
    uint64_t v21 = objc_opt_class();
    __int16 v22 = sub_1001F6828(v21, *(void **)(a1 + 48), v19);
    unsigned __int8 v23 = [v22 BOOLValue];

    v25[0] = _NSConcreteStackBlock;
    v25[1] = 3221225472;
    v25[2] = sub_1001F6CE8;
    v25[3] = &unk_100986048;
    id v26 = v5;
    id v27 = *(id *)(a1 + 48);
    id v28 = *(id *)(a1 + 40);
    id v29 = WeakRetained;
    uint64_t v36 = v3;
    unsigned __int8 v37 = v23;
    id v30 = *(id *)(a1 + 56);
    id v31 = *(id *)(a1 + 64);
    id v32 = *(id *)(a1 + 72);
    id v33 = *(id *)(a1 + 80);
    id v34 = v7;
    id v35 = *(id *)(a1 + 88);
    id v24 = v7;
    [v26 networkingIsAvailable:v25];

    goto LABEL_12;
  }
  uint64_t v12 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Couldn't create session for invite, bailing...", buf, 2u);
  }

  DLCWarn();
  v3[2](v3);
LABEL_12:
}

void sub_1001F6CE8(uint64_t a1, int a2)
{
  id v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v5 = @"NO";
    if (a2) {
      CFStringRef v5 = @"YES";
    }
    *(_DWORD *)buf = 138412290;
    CFStringRef v50 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Done with incoming network availability check; networkOkForSession: %@",
      buf,
      0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  if (!a2)
  {
    uint64_t v10 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Network availability check indicated that we should not continue to process this session invitation", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    if (*(unsigned char *)(a1 + 120))
    {
      id v11 = objc_alloc((Class)NSDictionary);
      id v12 = objc_msgSend(v11, "initWithObjectsAndKeys:", &off_1009D18A8, IDSDSessionMessageDeclineReason, 0);
      uint64_t v13 = *(void **)(a1 + 32);
      uint64_t v14 = JWEncodeDictionary();
      [v13 declineInvitationWithData:v14];
    }
    long long v15 = (os_unfair_lock_s *)(*(void *)(a1 + 56) + 8);
    os_unfair_lock_lock(v15);
    uint64_t v16 = *(void **)(*(void *)(a1 + 56) + 16);
    long long v17 = [*(id *)(a1 + 32) uniqueID];
    [v16 removeObjectForKey:v17];

    (*(void (**)(void))(*(void *)(a1 + 112) + 16))(*(void *)(a1 + 112));
    os_unfair_lock_unlock(v15);
    return;
  }
  if (![*(id *)(a1 + 32) isScreenSharingSession])
  {
LABEL_28:
    id v30 = *(void **)(a1 + 32);
    v37[0] = _NSConcreteStackBlock;
    v37[1] = 3221225472;
    v37[2] = sub_1001F7378;
    v37[3] = &unk_100986020;
    char v48 = *(unsigned char *)(a1 + 120);
    id v31 = v30;
    uint64_t v32 = *(void *)(a1 + 56);
    id v38 = v31;
    uint64_t v39 = v32;
    id v47 = *(id *)(a1 + 112);
    id v40 = *(id *)(a1 + 64);
    id v41 = *(id *)(a1 + 40);
    id v42 = *(id *)(a1 + 72);
    id v43 = *(id *)(a1 + 80);
    id v44 = *(id *)(a1 + 88);
    id v45 = *(id *)(a1 + 96);
    id v46 = *(id *)(a1 + 104);
    [v31 runConnectivityCheckWithCompletionBlock:v37];

    return;
  }
  uint64_t v6 = IDSDSessionMessageKeyMaterial;
  id v7 = [*(id *)(a1 + 40) objectForKey:IDSDSessionMessageKeyMaterial];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v8 = [*(id *)(a1 + 40) objectForKey:v6];
    uint64_t v9 = +[NSData _IDSDataFromBase64String:v8];
LABEL_22:
    uint64_t v18 = (void *)v9;
    goto LABEL_24;
  }
  uint64_t v8 = [*(id *)(a1 + 40) objectForKey:v6];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v9 = [*(id *)(a1 + 40) objectForKey:v6];
    goto LABEL_22;
  }
  uint64_t v18 = 0;
LABEL_24:

  uint64_t v19 = objc_opt_class();
  uint64_t v20 = sub_1001F6828(v19, *(void **)(a1 + 40), IDSDSessionMessageSelfSSRC);
  uint64_t v21 = objc_opt_class();
  uint64_t v22 = sub_1001F6828(v21, *(void **)(a1 + 40), IDSDSessionMessageSelfSeqStart);
  unsigned __int8 v23 = (void *)v22;
  if (v18 && v20 && v22)
  {
    id v24 = [*(id *)(a1 + 32) keyMaterial];
    id v25 = v18;
    id v26 = (long long *)[v25 bytes];
    long long v27 = *v26;
    long long v28 = v26[1];
    long long v29 = v26[2];
    *(_OWORD *)((char *)v24 + 44) = *(long long *)((char *)v26 + 44);
    v24[1] = v28;
    v24[2] = v29;
    _OWORD *v24 = v27;
    objc_msgSend(*(id *)(a1 + 32), "setSSRCRecv:", objc_msgSend(v20, "unsignedIntValue"));
    objc_msgSend(*(id *)(a1 + 32), "setSeqRecvStart:", objc_msgSend(v23, "unsignedShortValue"));

    goto LABEL_28;
  }
  id v33 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Missing encryption setup info, bailing...", buf, 2u);
  }

  DLCWarn();
  [*(id *)(a1 + 32) endSessionWithReason:17];
  id v34 = (os_unfair_lock_s *)(*(void *)(a1 + 56) + 8);
  os_unfair_lock_lock(v34);
  id v35 = *(void **)(*(void *)(a1 + 56) + 16);
  uint64_t v36 = [*(id *)(a1 + 32) uniqueID];
  [v35 removeObjectForKey:v36];

  (*(void (**)(void))(*(void *)(a1 + 112) + 16))(*(void *)(a1 + 112));
  os_unfair_lock_unlock(v34);
}

void sub_1001F7378(uint64_t a1, char a2)
{
  if (a2)
  {
    id v3 = +[IDSDaemon sharedInstance];
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 3221225472;
    void v14[2] = sub_1001F7644;
    v14[3] = &unk_100985FF8;
    id v15 = *(id *)(a1 + 48);
    int8x16_t v13 = *(int8x16_t *)(a1 + 32);
    id v4 = (id)v13.i64[0];
    int8x16_t v16 = vextq_s8(v13, v13, 8uLL);
    id v17 = *(id *)(a1 + 56);
    id v18 = *(id *)(a1 + 64);
    id v19 = *(id *)(a1 + 72);
    id v20 = *(id *)(a1 + 80);
    id v21 = *(id *)(a1 + 88);
    [v3 enqueueBroadcast:v14 forTopic:*(void *)(a1 + 48) entitlement:kIDSSessionEntitlement command:0 capabilities:kIDSListenerCapConsumesLaunchOnDemandSessionMessages messageContext:*(void *)(a1 + 96)];

    (*(void (**)(void))(*(void *)(a1 + 104) + 16))();
  }
  else
  {
    CFStringRef v5 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Wifi connectivity check failed, declining invitation!", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    if (*(unsigned char *)(a1 + 112))
    {
      id v6 = objc_alloc((Class)NSDictionary);
      id v7 = objc_msgSend(v6, "initWithObjectsAndKeys:", &off_1009D18A8, IDSDSessionMessageDeclineReason, 0);
      uint64_t v8 = *(void **)(a1 + 32);
      uint64_t v9 = JWEncodeDictionary();
      [v8 declineInvitationWithData:v9];
    }
    uint64_t v10 = (os_unfair_lock_s *)(*(void *)(a1 + 40) + 8);
    os_unfair_lock_lock(v10);
    id v11 = *(void **)(*(void *)(a1 + 40) + 16);
    id v12 = [*(id *)(a1 + 32) uniqueID];
    [v11 removeObjectForKey:v12];

    (*(void (**)(void))(*(void *)(a1 + 104) + 16))();
    os_unfair_lock_unlock(v10);
  }
}

void sub_1001F7644(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v6 = *(void *)(a1 + 56);
    uint64_t v5 = *(void *)(a1 + 64);
    id v7 = [*(id *)(a1 + 72) prefixedURI];
    uint64_t v8 = [*(id *)(a1 + 80) prefixedURI];
    [v3 sessionInvitationReceivedWithPayload:v6 forTopic:v4 sessionID:v5 toIdentifier:v7 fromID:v8 transportType:*(void *)(a1 + 88)];
  }
  else
  {
    uint64_t v9 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138412290;
      uint64_t v15 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Did not find a client that could handle the invitation for service %@, ignoring invitation...", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    id v11 = (os_unfair_lock_s *)(*(void *)(a1 + 40) + 8);
    os_unfair_lock_lock(v11);
    id v12 = *(void **)(*(void *)(a1 + 40) + 16);
    int8x16_t v13 = [*(id *)(a1 + 48) uniqueID];
    [v12 removeObjectForKey:v13];

    os_unfair_lock_unlock(v11);
  }
}

void sub_1001F7AC4(void *a1, void *a2)
{
  uint64_t v2 = (void *)a1[4];
  uint64_t v3 = a1[5];
  uint64_t v4 = a1[6];
  uint64_t v5 = a2;
  [v2 receivedAcceptMessage:v3 fromURI:v4];
  v5[2]();
}

void sub_1001F7DD0(void *a1, void *a2)
{
  uint64_t v2 = (void *)a1[4];
  uint64_t v3 = a1[5];
  uint64_t v4 = a1[6];
  uint64_t v5 = a2;
  [v2 receivedDeclineMessage:v3 fromURI:v4];
  v5[2]();
}

void sub_1001F80DC(void *a1, void *a2)
{
  uint64_t v2 = (void *)a1[4];
  uint64_t v3 = a1[5];
  uint64_t v4 = a1[6];
  uint64_t v5 = a2;
  [v2 receivedCancelMessage:v3 fromURI:v4];
  v5[2]();
}

void sub_1001F83E8(void *a1, void *a2)
{
  uint64_t v2 = (void *)a1[4];
  uint64_t v3 = a1[5];
  uint64_t v4 = a1[6];
  uint64_t v5 = a2;
  [v2 receivedSessionMessage:v3 fromURI:v4];
  v5[2]();
}

void sub_1001F86F4(void *a1, void *a2)
{
  uint64_t v2 = (void *)a1[4];
  uint64_t v3 = a1[5];
  uint64_t v4 = a1[6];
  uint64_t v5 = a2;
  [v2 receivedEndMessage:v3 fromURI:v4];
  v5[2]();
}

void sub_1001F8A00(void *a1, void *a2)
{
  uint64_t v2 = (void *)a1[4];
  uint64_t v3 = a1[5];
  uint64_t v4 = a1[6];
  uint64_t v5 = a2;
  [v2 receivedReinitiateMessage:v3 fromURI:v4];
  v5[2]();
}

void sub_1001F8F30(_Unwind_Exception *exception_object, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(exception_object);
    objc_end_catch();
    JUMPOUT(0x1001F8CA0);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001F8F74(uint64_t a1, void *a2)
{
  v143 = a2;
  uint64_t v3 = IDSDSessionMessageJoinNotificationKey;
  uint64_t v4 = [*(id *)(a1 + 32) objectForKey:IDSDSessionMessageJoinNotificationKey];

  if (v4)
  {
    uint64_t v5 = [*(id *)(a1 + 32) objectForKey:v3];
    uint64_t v6 = (char *)[v5 unsignedIntegerValue];

    if ((unint64_t)(v6 - 1) >= 3)
    {
      if (v6 != (char *)4) {
        goto LABEL_9;
      }
      id v7 = +[IDSDGroupStatusNotificationController sharedInstance];
      [v7 processIncomingParticipantDataUpdateMessage:*(void *)(a1 + 32) fromToken:*(void *)(a1 + 40) fromURI:*(void *)(a1 + 48) toURI:*(void *)(a1 + 56) topic:*(void *)(a1 + 64) idsMessageContext:*(void *)(a1 + 72)];
    }
    else
    {
      id v7 = +[IDSDGroupStatusNotificationController sharedInstance];
      [v7 processIncomingParticipantUpdateMessage:*(void *)(a1 + 32) fromToken:*(void *)(a1 + 40) fromURI:*(void *)(a1 + 48) toURI:*(void *)(a1 + 56) topic:*(void *)(a1 + 64) idsMessageContext:*(void *)(a1 + 72)];
    }
    goto LABEL_8;
  }
  if (!*(unsigned char *)(a1 + 136))
  {
    uint64_t v22 = (void *)IDSDSessionMessageRealTimeEncryptionKeyMaterialKey;
    unsigned __int8 v23 = [*(id *)(a1 + 32) objectForKey:IDSDSessionMessageRealTimeEncryptionKeyMaterialKey];
    if (v23)
    {

      id v24 = (void *)IDSDSessionMessageRealTimeEncryptionStableKeyMaterialKey;
    }
    else
    {
      id v24 = (void *)IDSDSessionMessageRealTimeEncryptionStableKeyMaterialKey;
      uint64_t v32 = [*(id *)(a1 + 32) objectForKey:IDSDSessionMessageRealTimeEncryptionStableKeyMaterialKey];

      if (!v32)
      {
        uint64_t v69 = IDSDSessionMessageRealTimeEncryptionPreKeyRecoveryRequestKey;
        id v70 = [*(id *)(a1 + 32) objectForKey:IDSDSessionMessageRealTimeEncryptionPreKeyRecoveryRequestKey];

        __int16 v71 = *(void **)(a1 + 32);
        if (v70)
        {
          id v72 = [v71 objectForKey:v69];
          unsigned int v73 = [v72 BOOLValue];

          if (v73)
          {
            id v74 = [*(id *)(a1 + 48) prefixedURI];
            uint64_t v75 = [*(id *)(a1 + 40) rawToken];
            uint64_t v76 = +[IDSDestination destinationWithAlias:v74 pushToken:v75];

            int v77 = OSLogHandleForIDSCategory();
            if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v78 = *(void **)(a1 + 104);
              *(_DWORD *)buf = 138412546;
              id v154 = v78;
              __int16 v155 = 2112;
              CFStringRef v156 = (const __CFString *)v76;
              _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "Received the prekey recovery request for group %@ destination %@", buf, 0x16u);
            }

            if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
            {
              __int16 v130 = *(void **)(a1 + 104);
              p_isa = v76;
              _IDSLogV();
            }
            __int16 v79 = +[IDSGroupEncryptionController sharedInstance];
            [v79 sendPublicKeyToDestination:v76 group:*(void *)(a1 + 104) sessionID:*(void *)(a1 + 112)];
          }
          goto LABEL_9;
        }
        uint64_t v114 = IDSDSessionMessageRealTimeEncryptionMKMRecoveryRequestKey;
        id v115 = [v71 objectForKey:IDSDSessionMessageRealTimeEncryptionMKMRecoveryRequestKey];
        if (v115)
        {

          uint64_t v116 = IDSDSessionMessageRealTimeEncryptionSKMRecoveryRequestKey;
        }
        else
        {
          uint64_t v116 = IDSDSessionMessageRealTimeEncryptionSKMRecoveryRequestKey;
          id v117 = [*(id *)(a1 + 32) objectForKey:IDSDSessionMessageRealTimeEncryptionSKMRecoveryRequestKey];

          if (!v117)
          {
            CFStringRef v129 = [*(id *)(a1 + 32) objectForKey:IDSDSessionMessageRealTimeEncryptionPublicKeyAck];

            if (v129)
            {
              id v7 = +[IDSGroupEncryptionController sharedInstance];
              [v7 processIncomingPrekeyAckForGroup:*(void *)(a1 + 104)];
LABEL_8:
            }
LABEL_9:
            uint64_t v9 = IDSDSessionMessageRealTimeEncryptionPublicKey;
            uint64_t v10 = [*(id *)(a1 + 32) objectForKey:IDSDSessionMessageRealTimeEncryptionPublicKey];

            if (!v10)
            {
LABEL_31:
              v143[2]();
              id WeakRetained = objc_loadWeakRetained((id *)(a1 + 128));
              [WeakRetained updateCriticalReliabilityState];

              goto LABEL_32;
            }
            id v11 = OSLogHandleForIDSCategory();
            if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
            {
              id v12 = *(void **)(a1 + 80);
              ids_monotonic_time();
              *(_DWORD *)buf = 138412546;
              id v154 = v12;
              __int16 v155 = 2048;
              CFStringRef v156 = v13;
              _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Receiving Key Material (%@) [PreKey] -- %f", buf, 0x16u);
            }

            if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
            {
              uint64_t v14 = *(void **)(a1 + 80);
              ids_monotonic_time();
              p_isa = v15;
              __int16 v130 = v14;
              _IDSLogV();
            }
            int8x16_t v16 = *(void **)(a1 + 88);
            id v17 = objc_msgSend(*(id *)(a1 + 40), "rawToken", v130, p_isa);
            [v16 reportPreKeyReceivedOverPushFromToken:v17];

            id v18 = [*(id *)(a1 + 32) objectForKey:v9];
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              id v19 = [*(id *)(a1 + 32) objectForKey:v9];
              id v20 = +[NSData _IDSDataFromBase64String:v19];
            }
            else
            {
              id v19 = [*(id *)(a1 + 32) objectForKey:v9];
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) == 0)
              {
                id v21 = 0;
                goto LABEL_23;
              }
              id v20 = [*(id *)(a1 + 32) objectForKey:v9];
            }
            id v21 = v20;

LABEL_23:
            uint64_t v25 = objc_opt_class();
            id v26 = sub_1001F6828(v25, *(void **)(a1 + 32), IDSDSessionMessageRealTimeEncryptionWrapModeKey);
            if (v21)
            {
              long long v27 = OSLogHandleForIDSCategory();
              if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
              {
                CFStringRef v28 = *(const __CFString **)(a1 + 96);
                CFStringRef v29 = *(const __CFString **)(a1 + 40);
                *(_DWORD *)buf = 138478339;
                id v154 = v21;
                __int16 v155 = 2112;
                CFStringRef v156 = v28;
                __int16 v157 = 2112;
                CFStringRef v158 = v29;
                _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Storing the public key %{private}@ for %@ token %@", buf, 0x20u);
              }

              if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
              {
                uint64_t v135 = *(void *)(a1 + 96);
                CFStringRef v136 = *(const __CFString **)(a1 + 40);
                id v131 = v21;
                _IDSLogV();
              }
              id v30 = +[IDSGroupEncryptionController sharedInstance];
              objc_msgSend(v30, "setRealTimeEncryptionPublicKey:forDevice:fromURI:groupID:sessionID:serverDate:wrapMode:", v21, *(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 104), *(void *)(a1 + 112), *(void *)(a1 + 120), objc_msgSend(v26, "integerValue"));
            }
            goto LABEL_31;
          }
        }
        id v118 = [*(id *)(a1 + 32) objectForKey:v114];
        unsigned int v119 = [v118 BOOLValue];

        id v120 = [*(id *)(a1 + 32) objectForKey:v116];
        unsigned int v121 = [v120 BOOLValue];

        if ((v119 | v121) == 1)
        {
          id v122 = OSLogHandleForIDSCategory();
          if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v123 = *(void **)(a1 + 104);
            CFStringRef v124 = @"NO";
            if (v119) {
              CFStringRef v125 = @"YES";
            }
            else {
              CFStringRef v125 = @"NO";
            }
            *(_DWORD *)buf = 138412802;
            id v154 = v123;
            __int16 v155 = 2112;
            if (v121) {
              CFStringRef v124 = @"YES";
            }
            CFStringRef v156 = v125;
            __int16 v157 = 2112;
            CFStringRef v158 = v124;
            _os_log_impl((void *)&_mh_execute_header, v122, OS_LOG_TYPE_DEFAULT, "Received the key recovery request for group %@, needsToRecoverMKM: %@, needsToRecoverSKM: %@", buf, 0x20u);
          }

          if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
          {
            CFStringRef v126 = @"NO";
            if (v119) {
              CFStringRef v127 = @"YES";
            }
            else {
              CFStringRef v127 = @"NO";
            }
            if (v121) {
              CFStringRef v126 = @"YES";
            }
            p_isa = &v127->isa;
            CFStringRef v136 = v126;
            __int16 v130 = *(void **)(a1 + 104);
            _IDSLogV();
          }
          __int16 v128 = +[IDSGroupEncryptionController sharedInstance];
          BYTE1(v133) = v121;
          LOBYTE(v133) = v119;
          objc_msgSend(v128, "processIncomingKeyMaterialsRecoveryRequest:fromDevice:fromURI:groupID:sessionID:serverDate:requireMKM:requireSKM:", *(void *)(a1 + 32), *(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 104), *(void *)(a1 + 112), *(void *)(a1 + 120), v133);
        }
        goto LABEL_9;
      }
    }
    uint64_t v33 = objc_opt_class();
    id v142 = sub_1001F6828(v33, *(void **)(a1 + 32), v22);
    v144 = +[NSMutableArray array];
    uint64_t v34 = objc_opt_class();
    sub_1001F6828(v34, *(void **)(a1 + 32), v24);
    __int16 v141 = (__CFString *)objc_claimAutoreleasedReturnValue();
    if (v142)
    {
      id v35 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v36 = *(void **)(a1 + 80);
        ids_monotonic_time();
        *(_DWORD *)buf = 138412546;
        id v154 = v36;
        __int16 v155 = 2048;
        CFStringRef v156 = v37;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "Receiving Key Material (%@) [MKM] -- %f", buf, 0x16u);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        id v38 = *(void **)(a1 + 80);
        ids_monotonic_time();
        p_isa = v39;
        __int16 v130 = v38;
        _IDSLogV();
      }
      if (!v141)
      {
        char v40 = 0;
        goto LABEL_49;
      }
    }
    else if (!v141)
    {
      char v68 = 1;
LABEL_96:
      uint64_t v83 = objc_opt_class();
      id v140 = sub_1001F6828(v83, *(void **)(a1 + 32), IDSDSessionMessageRealTimeEncryptionKeyAllValidKeyMaterialsKey);
      __int16 v84 = [*(id *)(a1 + 32) objectForKey:IDSDSessionMessageRealTimeEncryptionKeyAllValidKeyMaterialsURIsKey];
      __int16 v139 = objc_msgSend(v84, "__imArrayByApplyingBlock:", &stru_1009860B8);

      char v85 = v68 ^ 1;
      if (!v140) {
        char v85 = 1;
      }
      if ((v85 & 1) == 0)
      {
        long long v149 = 0u;
        long long v150 = 0u;
        long long v147 = 0u;
        long long v148 = 0u;
        id obj = v140;
        id v86 = [obj countByEnumeratingWithState:&v147 objects:v152 count:16];
        if (v86)
        {
          uint64_t v87 = *(void *)v148;
          uint64_t v88 = IDSRealTimeEncryptionParticipantID;
          while (2)
          {
            CFStringRef v89 = 0;
            do
            {
              if (*(void *)v148 != v87) {
                objc_enumerationMutation(obj);
              }
              __int16 v90 = *(void **)(*((void *)&v147 + 1) + 8 * (void)v89);
              uint64_t v91 = OSLogHandleForIDSCategory();
              if (os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT))
              {
                CFStringRef v92 = *(const __CFString **)(a1 + 96);
                CFStringRef v93 = *(const __CFString **)(a1 + 40);
                *(_DWORD *)buf = 138478339;
                id v154 = v90;
                __int16 v155 = 2112;
                CFStringRef v156 = v92;
                __int16 v157 = 2112;
                CFStringRef v158 = v93;
                _os_log_impl((void *)&_mh_execute_header, v91, OS_LOG_TYPE_DEFAULT, "Storing all valid master key materials %{private}@ for %@ token %@", buf, 0x20u);
              }

              if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
              {
                p_isa = *(id **)(a1 + 96);
                CFStringRef v136 = *(const __CFString **)(a1 + 40);
                __int16 v130 = v90;
                _IDSLogV();
              }
              __int16 v94 = objc_msgSend(v90, "objectForKeyedSubscript:", v88, v130, p_isa, v136);
              id v95 = [v94 unsignedLongLongValue];

              [*(id *)(a1 + 88) reportMKMReceivedOverPushViaCacheForParticipantID:v95 material:v90];
              __int16 v96 = +[IDSGroupEncryptionController sharedInstance];
              uint64_t v97 = *(void *)(a1 + 40);
              uint64_t v98 = *(void *)(a1 + 48);
              uint64_t v99 = *(void *)(a1 + 104);
              uint64_t v100 = *(void *)(a1 + 112);
              id v146 = 0;
              LOWORD(v136) = 1;
              p_isa = &v146;
              LOBYTE(v130) = 0;
              uint64_t v101 = objc_msgSend(v96, "receivedAndSetKeyMaterial:stableKeyMaterial:forDevice:fromURI:groupID:sessionID:fromSender:error:forMKM:forSKM:", v90, 0, v97, v98, v99, v100);
              id v102 = v146;

              if (v101)
              {
                long long v103 = [v101 objectForKey:@"ids-rtencryption-master-key-material-key"];
                if (v103)
                {
                  [v144 addObject:v103];
                }
                else if (v102)
                {
                  id v107 = [v102 domain];
                  if ([v107 isEqualToString:@"IDSRealTimeEncryptionControllerErrorDomain"])
                  {
                    BOOL v108 = [v102 code] == (id)-2000;

                    if (v108)
                    {
                      id v110 = OSLogHandleForIDSCategory();
                      if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_WORD *)buf = 0;
                        _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "Failed to decrypt a key material in the broadcast group -- skipping the remaining key material", buf, 2u);
                      }

                      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
                        _IDSLogV();
                      }

                      goto LABEL_133;
                    }
                  }
                  else
                  {
                  }
                }
              }
              else
              {
                long long v104 = OSLogHandleForIDSCategory();
                if (os_log_type_enabled(v104, OS_LOG_TYPE_DEFAULT))
                {
                  long long v105 = *(void **)(a1 + 96);
                  CFStringRef v106 = *(const __CFString **)(a1 + 40);
                  *(_DWORD *)buf = 138412546;
                  id v154 = v105;
                  __int16 v155 = 2112;
                  CFStringRef v156 = v106;
                  _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEFAULT, "not received any valid remote cached MKMs for %@ token %@", buf, 0x16u);
                }

                if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
                {
                  __int16 v130 = *(void **)(a1 + 96);
                  p_isa = *(id **)(a1 + 40);
                  _IDSLogV();
                }
              }

              CFStringRef v89 = (char *)v89 + 1;
            }
            while (v86 != v89);
            id v109 = [obj countByEnumeratingWithState:&v147 objects:v152 count:16];
            id v86 = v109;
            if (v109) {
              continue;
            }
            break;
          }
        }
LABEL_133:
      }
      if (objc_msgSend(v144, "count", v130) && objc_msgSend(v139, "count"))
      {
        id v112 = +[IDSGroupEncryptionController sharedInstance];
        [v112 noteReceivedGroupMasterKeyMaterials:v144 URIs:v139 sessionID:*(void *)(a1 + 112)];
      }
      id v113 = +[IDSGroupEncryptionController sharedInstance];
      [v113 requestPendingKeyMaterialsForGroup:*(void *)(a1 + 104) sessionID:*(void *)(a1 + 112)];

      goto LABEL_9;
    }
    id v41 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
    {
      id v42 = *(void **)(a1 + 80);
      ids_monotonic_time();
      *(_DWORD *)buf = 138412546;
      id v154 = v42;
      __int16 v155 = 2048;
      CFStringRef v156 = v43;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Receiving Key Material (%@) [SKM] -- %f", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      id v44 = *(void **)(a1 + 80);
      ids_monotonic_time();
      p_isa = v45;
      __int16 v130 = v44;
      _IDSLogV();
    }
    char v40 = 1;
    if (!v142)
    {
LABEL_53:
      CFStringRef v49 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v50 = *(const __CFString **)(a1 + 96);
        uint64_t v51 = *(void *)(a1 + 40);
        *(_DWORD *)buf = 138478595;
        id v154 = v142;
        __int16 v155 = 2113;
        CFStringRef v156 = v141;
        __int16 v157 = 2112;
        CFStringRef v158 = v50;
        __int16 v159 = 2112;
        uint64_t v160 = v51;
        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "Storing the master key material %{private}@ stableKeyMaterial: %{private}@ for %@ token %@", buf, 0x2Au);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        CFStringRef v136 = *(const __CFString **)(a1 + 96);
        uint64_t v138 = *(void *)(a1 + 40);
        __int16 v130 = v142;
        p_isa = &v141->isa;
        _IDSLogV();
      }
      uint64_t v52 = +[IDSGroupEncryptionController sharedInstance];
      uint64_t v53 = *(void *)(a1 + 40);
      uint64_t v54 = *(void *)(a1 + 48);
      uint64_t v55 = *(void *)(a1 + 104);
      uint64_t v56 = *(void *)(a1 + 112);
      id v151 = 0;
      BYTE1(v137) = v40;
      LOBYTE(v137) = v142 != 0;
      LOBYTE(v132) = 1;
      id v57 = objc_msgSend(v52, "receivedAndSetKeyMaterial:stableKeyMaterial:forDevice:fromURI:groupID:sessionID:fromSender:error:forMKM:forSKM:", v142, v141, v53, v54, v55, v56, v132, &v151, v137);
      id v58 = v151;

      if (v57)
      {
        double v59 = [v57 objectForKey:@"ids-rtencryption-master-key-material-key"];
        if (v59)
        {
          [v144 addObject:v59];
          id v60 = objc_loadWeakRetained((id *)(a1 + 128));
          double v61 = v60;
          uint64_t v62 = *(void *)(a1 + 72);
          if (*(void *)(a1 + 64))
          {
            if (v62 && v60 && !*((unsigned char *)v60 + 40))
            {
              *((unsigned char *)v60 + 40) = 1;
              id v63 = *(void **)(a1 + 88);
              ids_monotonic_time();
              objc_msgSend(v63, "reportFirstMKMReceivedFromPush:");
            }
          }
          else if (!v62 && v60 && !*((unsigned char *)v60 + 41))
          {
            *((unsigned char *)v60 + 41) = 1;
            id v80 = *(void **)(a1 + 88);
            ids_monotonic_time();
            objc_msgSend(v80, "reportFirstMKMReceivedFromQR:");
          }
        }
        CFStringRef v81 = [v57 objectForKey:@"ids-rtencryption-stable-key-material-key"];
        if (v81)
        {
          long long v82 = +[IDSGroupEncryptionController sharedInstance];
          [v82 receivedGroupStableKeyMaterial:v81 fromPushToken:*(void *)(a1 + 40) sessionID:*(void *)(a1 + 112) groupID:*(void *)(a1 + 104)];
        }
      }
      else
      {
        id v64 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
        {
          id v65 = *(void **)(a1 + 96);
          CFStringRef v66 = *(const __CFString **)(a1 + 40);
          *(_DWORD *)buf = 138412546;
          id v154 = v65;
          __int16 v155 = 2112;
          CFStringRef v156 = v66;
          _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "not received any valid MKM or MKM for %@ token %@", buf, 0x16u);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
        {
          __int16 v130 = *(void **)(a1 + 96);
          p_isa = *(id **)(a1 + 40);
          _IDSLogV();
        }
        if (v58)
        {
          id v67 = OSLogHandleForIDSCategory();
          if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "key material not decrypted", buf, 2u);
          }

          if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
            _IDSLogV();
          }
          char v68 = 0;
          goto LABEL_95;
        }
      }
      char v68 = 1;
LABEL_95:

      goto LABEL_96;
    }
LABEL_49:
    BOOL v46 = *(unsigned char *)(a1 + 137) == 0;
    id v47 = *(void **)(a1 + 88);
    char v48 = objc_msgSend(*(id *)(a1 + 40), "rawToken", v130, p_isa);
    if (v46) {
      [v47 reportMKMReceivedOverPushFromToken:v48 material:v142];
    }
    else {
      [v47 reportMKMReceivedOverQRFromToken:v48 material:v142];
    }

    goto LABEL_53;
  }
  v143[2]();
  id v8 = objc_loadWeakRetained((id *)(a1 + 128));
  [v8 updateCriticalReliabilityState];

LABEL_32:
}

id sub_1001FA37C(id a1, id a2)
{
  id v2 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v3 = +[IDSURI URIWithPrefixedURI:v2];
  }
  else
  {
    uint64_t v3 = 0;
  }

  return v3;
}

void sub_1001FA8A8(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1001FAE1C(id a1, IDSDSession *a2, unint64_t a3, BOOL *a4)
{
  uint64_t v4 = a2;
  [(IDSDSession *)v4 endSession];
  [(IDSDSession *)v4 cleanupSessionWithCleanStatus:1];
}

void sub_1001FB284(uint64_t a1, void *a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 32);
  id v3 = a2;
  [v3 endSessionWithReason:v2];
  [v3 cleanupSessionWithCleanStatus:1];
}

void sub_1001FB5D4(id a1, IDSDSession *a2, unint64_t a3, BOOL *a4)
{
}

uint64_t sub_1001FC508(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1001FC518(uint64_t a1)
{
}

void sub_1001FC520(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  id v9 = a2;
  id v7 = [v9 groupID];
  unsigned int v8 = [v7 isEqualToString:*(void *)(a1 + 32)];

  if (v8)
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
    *a4 = 1;
  }
}

void sub_1001FC85C(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  id v10 = a2;
  id v7 = objc_alloc((Class)NSUUID);
  unsigned int v8 = [v10 groupID];
  id v9 = [v7 initWithUUIDString:v8];

  if ([v9 isEqual:*(void *)(a1 + 32)])
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
    *a4 = 1;
  }
}

void sub_1001FCAA0(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1001FCC3C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

id sub_1001FD460(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) _retryTimeForAttempt:a2];
}

void sub_1001FD46C(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v6 = [*(id *)(a1 + 32) _publishRequestForStatusPayload:*(void *)(a1 + 40)];
  uint64_t v7 = *(void *)(a1 + 32);
  unsigned int v8 = *(void **)(v7 + 16);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_1001FD550;
  v10[3] = &unk_1009861B0;
  uint64_t v13 = a3;
  void v10[4] = v7;
  id v11 = *(id *)(a1 + 48);
  id v12 = v5;
  id v9 = v5;
  [v8 publishStatusRequest:v6 completion:v10];
}

void sub_1001FD550(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = +[IDSFoundationLog IDSSKStatusClient];
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(a1 + 56);
    int v12 = 138412802;
    id v13 = v5;
    __int16 v14 = 2048;
    uint64_t v15 = v8;
    __int16 v16 = 2112;
    id v17 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Requested publish with identifier %@ attempts (%ld) for error %@", (uint8_t *)&v12, 0x20u);
  }

  if ([*(id *)(a1 + 32) _shouldRetryForError:v6]
    && (unint64_t v9 = *(void *)(a1 + 56), v9 <= (unint64_t)[*(id *)(a1 + 32) _retryMaximumAttempts]))
  {
    id v11 = *(void (**)(void))(*(void *)(a1 + 48) + 16);
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 40);
    if (v10) {
      (*(void (**)(uint64_t, id))(v10 + 16))(v10, v6);
    }
    id v11 = *(void (**)(void))(*(void *)(a1 + 48) + 16);
  }
  v11();
}

id sub_1001FD908(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) _retryTimeForAttempt:a2];
}

void sub_1001FD914(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 40);
  uint64_t v8 = *(void **)(v6 + 16);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_1001FD9E4;
  v10[3] = &unk_100986200;
  uint64_t v13 = a3;
  void v10[4] = v6;
  id v11 = *(id *)(a1 + 48);
  id v12 = v5;
  id v9 = v5;
  [v8 provisionPayloads:v7 completion:v10];
}

void sub_1001FD9E4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = +[IDSFoundationLog IDSSKStatusClient];
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(a1 + 56);
    int v12 = 134218242;
    uint64_t v13 = v8;
    __int16 v14 = 2112;
    id v15 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Requested provision attempts (%ld) for error %@", (uint8_t *)&v12, 0x16u);
  }

  if ([*(id *)(a1 + 32) _shouldRetryForError:v6]
    && (unint64_t v9 = *(void *)(a1 + 56), v9 <= (unint64_t)[*(id *)(a1 + 32) _retryMaximumAttempts]))
  {
    id v11 = *(void (**)(void))(*(void *)(a1 + 48) + 16);
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 40);
    if (v10) {
      (*(void (**)(uint64_t, id, id))(v10 + 16))(v10, v5, v6);
    }
    id v11 = *(void (**)(void))(*(void *)(a1 + 48) + 16);
  }
  v11();
}

void sub_1001FDBE8(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = a2;
  id v4 = objc_alloc((Class)IDSURI);
  id v6 = [v3 handleString];

  id v5 = [v4 initWithPrefixedURI:v6];
  [v2 addObject:v5];
}

void sub_1001FDDEC(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v2 = *(void **)(a1 + 40);
  id v4 = (void *)v2[2];
  id v5 = [*(id *)(a1 + 48) allObjects];
  id v6 = [v2 _skHandlesForURIs:v5];
  uint64_t v7 = *(void **)(a1 + 40);
  if (v3)
  {
    uint64_t v22 = *(void *)(a1 + 32);
    uint64_t v8 = +[NSArray arrayWithObjects:&v22 count:1];
    unint64_t v9 = [v7 _skHandlesForURIs:v8];
    uint64_t v10 = [v9 firstObject];
    id v11 = [*(id *)(a1 + 40) _skInvitationPayloadForDictionary:*(void *)(a1 + 56)];
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 3221225472;
    v18[2] = sub_1001FE03C;
    v18[3] = &unk_100981C10;
    int v12 = &v19;
    id v19 = *(id *)(a1 + 48);
    uint64_t v13 = &v20;
    id v20 = *(id *)(a1 + 32);
    id v21 = *(id *)(a1 + 64);
    [v4 inviteHandles:v6 fromSenderHandle:v10 withInvitationPayload:v11 completion:v18];

    id v5 = v21;
  }
  else
  {
    __int16 v14 = [*(id *)(a1 + 40) _skInvitationPayloadForDictionary:*(void *)(a1 + 56)];
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472;
    void v15[2] = sub_1001FE12C;
    v15[3] = &unk_100981C38;
    int v12 = &v16;
    id v16 = *(id *)(a1 + 48);
    uint64_t v13 = &v17;
    id v17 = *(id *)(a1 + 64);
    [v4 inviteHandlesFromPrimaryAccountHandle:v6 withInvitationPayload:v14 completion:v15];
  }
}

void sub_1001FE03C(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSFoundationLog IDSSKStatusClient];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = a1[4];
    uint64_t v6 = a1[5];
    int v8 = 138412802;
    uint64_t v9 = v5;
    __int16 v10 = 2112;
    uint64_t v11 = v6;
    __int16 v12 = 2112;
    id v13 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Completed request - inviteHandles  %@ from sender %@ with error %@", (uint8_t *)&v8, 0x20u);
  }

  uint64_t v7 = a1[6];
  if (v7) {
    (*(void (**)(uint64_t, id))(v7 + 16))(v7, v3);
  }
}

void sub_1001FE12C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSFoundationLog IDSSKStatusClient];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v7 = 138412546;
    uint64_t v8 = v5;
    __int16 v9 = 2112;
    id v10 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Completed request - inviteHandles %@ from primary sender account handle with error %@", (uint8_t *)&v7, 0x16u);
  }

  uint64_t v6 = *(void *)(a1 + 40);
  if (v6) {
    (*(void (**)(uint64_t, id))(v6 + 16))(v6, v3);
  }
}

void sub_1001FE338(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = (void *)v2[2];
  id v4 = [*(id *)(a1 + 40) allObjects];
  uint64_t v5 = [v2 _skHandlesForURIs:v4];
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  _DWORD v6[2] = sub_1001FE414;
  v6[3] = &unk_100981C38;
  id v7 = *(id *)(a1 + 40);
  id v8 = *(id *)(a1 + 48);
  [v3 removeInvitedHandles:v5 completion:v6];
}

void sub_1001FE414(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSFoundationLog IDSSKStatusClient];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v7 = 138412546;
    uint64_t v8 = v5;
    __int16 v9 = 2112;
    id v10 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Completed request - removeHandles %@ with error %@", (uint8_t *)&v7, 0x16u);
  }

  uint64_t v6 = *(void *)(a1 + 40);
  if (v6) {
    (*(void (**)(uint64_t, id))(v6 + 16))(v6, v3);
  }
}

void sub_1001FE594(uint64_t a1)
{
  id v1 = *(void **)(*(void *)(a1 + 32) + 16);
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_1001FE624;
  v2[3] = &unk_100981C88;
  id v3 = *(id *)(a1 + 40);
  [v1 removeAllInvitedHandlesWithCompletion:v2];
}

void sub_1001FE624(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSFoundationLog IDSSKStatusClient];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 138412290;
    id v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Completed request - removeAllHandles with error %@", (uint8_t *)&v6, 0xCu);
  }

  uint64_t v5 = *(void *)(a1 + 32);
  if (v5) {
    (*(void (**)(uint64_t, id))(v5 + 16))(v5, v3);
  }
}

void sub_1001FE7D8(uint64_t a1, void *a2)
{
  id v3 = *(objc_class **)(a1 + 40);
  id v4 = a2;
  id v5 = [v3 alloc];
  int v6 = [v4 prefixedURI];

  id v7 = [v5 initWithString:v6];
  [*(id *)(a1 + 32) addObject:v7];
}

uint64_t sub_1001FF02C(uint64_t a1)
{
  id v1 = objc_alloc_init(*(Class *)(a1 + 32));
  uint64_t v2 = qword_100A4AAF0;
  qword_100A4AAF0 = (uint64_t)v1;

  return _objc_release_x1(v1, v2);
}

void sub_1001FF288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001FF2A0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1001FF2B0(uint64_t a1)
{
}

void sub_1001FF2B8(uint64_t a1)
{
  if (([*(id *)(a1 + 32) hasPerformedMigration] & 1) == 0)
  {
    if (qword_100A4AB08 != -1) {
      dispatch_once(&qword_100A4AB08, &stru_100986248);
    }
    if (off_100A4AB00) {
      off_100A4AB00();
    }
    os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 12));
    *(unsigned char *)(*(void *)(a1 + 32) + 8) = 1;
    os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 12));
  }
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 12));
  uint64_t v2 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
  id v3 = +[NSNull null];
  [v2 fulfillWithValue:v3];

  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = *(void **)(v4 + 16);
  *(void *)(v4 + 16) = 0;

  int v6 = (os_unfair_lock_s *)(*(void *)(a1 + 32) + 12);

  os_unfair_lock_unlock(v6);
}

void sub_1001FF3AC(id a1)
{
  off_100A4AB00 = (uint64_t (*)(void))IMWeakLinkSymbol();
}

id sub_100201E6C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (([*(id *)(a1 + 32) shouldRegisterUsingDSHandle] & 1) != 0
    || ([v3 _appearsToBeDSID] & 1) == 0)
  {
    id v4 = v3;
  }
  else
  {
    id v4 = 0;
  }

  return v4;
}

void sub_100201ED4(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6)
{
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id v13 = a6;
  __int16 v14 = +[IMRGLog registration];
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    int v20 = 138413058;
    id v21 = v10;
    __int16 v22 = 2112;
    id v23 = v11;
    __int16 v24 = 2112;
    id v25 = v12;
    __int16 v26 = 2112;
    id v27 = v13;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "*** Accounts response:   username: %@   serviceUserName: %@   profileID: %@   selfHandle: %@", (uint8_t *)&v20, 0x2Au);
  }

  if ([v13 length])
  {
    id v15 = +[IMRGLog registration];
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      int v20 = 138412290;
      id v21 = v13;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "   Setting self ID: %@", (uint8_t *)&v20, 0xCu);
    }

    [*(id *)(*(void *)(a1 + 32) + 16) setDSHandle:v13];
    if (![v12 length]) {
      goto LABEL_12;
    }
  }
  else if (![v12 length])
  {
    goto LABEL_15;
  }
  id v16 = +[IMRGLog registration];
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    int v20 = 138412290;
    id v21 = v12;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "   Setting profile ID: %@", (uint8_t *)&v20, 0xCu);
  }

  [*(id *)(*(void *)(a1 + 32) + 16) setProfileID:v12];
  id v17 = *(void **)(a1 + 32);
  id v18 = +[NSDictionary dictionaryWithObject:v12 forKey:kIDSServiceDefaultsAuthorizationIDKey];
  [v17 _writeAccountDefaults:v18 force:1];

LABEL_12:
  id v19 = +[IMRGLog registration];
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v20) = 0;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "   Saving fixed account", (uint8_t *)&v20, 2u);
  }

  [*(id *)(*(void *)(a1 + 32) + 16) saveToKeychain];
LABEL_15:
}

id sub_10020395C(uint64_t a1, void *a2)
{
  id v3 = [a2 objectForKey:kIDSServiceDefaultsAliasKey];
  if ([*(id *)(a1 + 32) shouldRegisterUsingDSHandle]
    && [v3 _FZIDType] == (id)2
    || ([v3 isEqualToIgnoringCase:kIDSServiceDefaultsSentinelAlias] & 1) != 0
    || ([*(id *)(a1 + 40) containsObject:v3] & 1) != 0)
  {
    id v4 = 0;
  }
  else
  {
    id v4 = v3;
  }

  return v4;
}

id sub_1002051E0(uint64_t a1)
{
  return [*(id *)(a1 + 32) _reregister];
}

void sub_100205BA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
}

void sub_10020679C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, os_activity_scope_state_s state, char a17)
{
}

void sub_100206D74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
}

void sub_10020815C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, os_activity_scope_state_s state,char a21)
{
}

void sub_1002081D0(id a1, id a2)
{
}

void sub_100208604(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
}

void sub_10020A534(_Unwind_Exception *a1)
{
}

uint64_t sub_10020A5F0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10020A600(uint64_t a1)
{
}

id sub_10020A608(id a1, id a2)
{
  id v2 = a2;
  if (IMStringIsEmail()) {
    id v3 = v2;
  }
  else {
    id v3 = 0;
  }

  return v3;
}

id sub_10020A65C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([*(id *)(a1 + 32) _validationStatusForAlias:v3] == (id)2) {
    goto LABEL_4;
  }
  if ([*(id *)(a1 + 40) containsObject:v3])
  {
LABEL_5:
    id v4 = 0;
    goto LABEL_6;
  }
  if ([*(id *)(a1 + 48) containsObject:v3])
  {
LABEL_4:
    [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) addObject:v3];
    goto LABEL_5;
  }
  id v4 = v3;
LABEL_6:

  return v4;
}

void sub_10020A6F4(uint64_t a1, int a2, void *a3, uint64_t a4)
{
  id v7 = a3;
  uint64_t v8 = *(void **)(a1 + 32);
  id v9 = v7;
  if (a2)
  {
    [v8 addAliases:v7];
    [*(id *)(a1 + 32) validateAliases:v9];
  }
  else
  {
    [v8 markAsUnselectedAlias:a4 withReason:3];
  }
}

void sub_10020AC08(uint64_t a1, uint64_t a2, uint64_t a3, int a4, void *a5)
{
  id v7 = a5;
  *(unsigned char *)(*(void *)(a1 + 32) + 80) &= ~0x10u;
  uint64_t v8 = [v7 objectForKey:@"handles"];
  id v9 = v8;
  if (!a4) {
    goto LABEL_8;
  }
  if ([v8 count])
  {
    id v10 = objc_alloc_init((Class)NSDate);
    uint64_t v11 = *(void *)(a1 + 32);
    id v12 = *(void **)(v11 + 64);
    *(void *)(v11 + 64) = v10;

    id v13 = +[IMRGLog registration];
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v14 = [*(id *)(a1 + 32) uniqueID];
      int v19 = 138412546;
      id v20 = v7;
      __int16 v21 = 2112;
      __int16 v22 = v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Handles query completed with result: %@   account: %@", (uint8_t *)&v19, 0x16u);
    }
    if ([*(id *)(a1 + 32) accountType] == 1) {
      [*(id *)(a1 + 32) _parseHandlesInfo:v9 currentAliases:*(void *)(a1 + 40) currentVettedAliases:*(void *)(a1 + 48)];
    }
    goto LABEL_11;
  }
  if (![v9 count])
  {
    id v18 = +[IMRGLog registration];
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v19) = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, " *** This was successful, but handles were empty? Ignoring...", (uint8_t *)&v19, 2u);
    }
  }
  else
  {
LABEL_8:
    id v15 = [v7 objectForKey:@"status"];
    int v16 = [v15 intValue];

    id v17 = +[IMRGLog warning];
    if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT)) {
      sub_1007187B8(v16, v17);
    }
  }
LABEL_11:
}

void sub_10020C2F8(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSDaemon sharedInstance];
  id v5 = [v3 service];
  int v6 = [v5 pushTopic];
  id v7 = [v4 broadcasterForTopic:v6 ignoreServiceListener:1 messageContext:*(void *)(a1 + 32)];

  uint64_t v8 = [v3 dependentRegistrations];
  if (![v8 count])
  {
    id v9 = [*(id *)(a1 + 40) dependentRegistrations];
    id v10 = [v9 count];

    if (v10)
    {
      uint64_t v11 = +[IMRGLog warning];
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100718A70();
      }
    }
  }
  id v12 = [v3 service];
  id v13 = [v12 identifier];
  unsigned int v14 = [v13 isEqualToIgnoringCase:@"com.apple.private.alloy.icloudpairing"];

  if (v14)
  {
    if ([v3 isRegistered]
      && ([v3 primaryRegistration], (uint64_t v15 = objc_claimAutoreleasedReturnValue()) != 0)
      && (v16 = (void *)v15, unsigned int v17 = [v3 isEnabled], v16, v17))
    {
      id v18 = +[IMRGLog GDR];
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)id v25 = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "iCloud pairing account is usable, updating device properties", v25, 2u);
      }

      int v19 = [*(id *)(a1 + 40) accountController];
      [v19 updateDevicePropertiesWithDevices:v8];
    }
    else
    {
      int v19 = +[IMRGLog GDR];
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        if ([v3 isRegistered]) {
          CFStringRef v20 = @"YES";
        }
        else {
          CFStringRef v20 = @"NO";
        }
        __int16 v21 = [v3 primaryRegistration];
        if (v21) {
          CFStringRef v22 = @"YES";
        }
        else {
          CFStringRef v22 = @"NO";
        }
        *(_DWORD *)id v25 = 138412802;
        if ([v3 isEnabled]) {
          CFStringRef v23 = @"YES";
        }
        else {
          CFStringRef v23 = @"NO";
        }
        *(void *)&void v25[4] = v20;
        __int16 v26 = 2112;
        CFStringRef v27 = v22;
        __int16 v28 = 2112;
        CFStringRef v29 = v23;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "iCloud pairing account is not usable, not updating device properties (registered: %@, primaryRegistration: %@, isEnabled: %@)", v25, 0x20u);
      }
    }
  }
  __int16 v24 = objc_msgSend(v3, "uniqueID", *(void *)v25);
  [v7 account:v24 dependentDevicesUpdated:v8];
}

void sub_10020C998(uint64_t a1, void *a2, uint64_t a3, int a4, void *a5)
{
  id v9 = a2;
  id v10 = a5;
  *(unsigned char *)(*(void *)(a1 + 32) + 80) &= ~8u;
  uint64_t v11 = +[NSNumber numberWithInteger:a3];
  [v9 setDependentRegistrationResponseCode:v11];

  if (a4)
  {
    id v12 = +[IMRGLog GDR];
    uint64_t v56 = a1;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      id v13 = [*(id *)(a1 + 32) uniqueID];
      unsigned int v14 = [*(id *)(a1 + 32) service];
      uint64_t v15 = [v14 queryService];
      *(_DWORD *)buf = 138412546;
      char v68 = v13;
      __int16 v69 = 2112;
      id v70 = v15;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Device query completed with   Account ID: %@   service: %@", buf, 0x16u);

      a1 = v56;
    }

    int v16 = [v10 _numberForKey:@"expiry-epoch-milli-sec"];
    [v16 doubleValue];
    id v18 = +[NSNumber numberWithDouble:v17 / 1000.0];

    id v19 = objc_alloc((Class)NSDate);
    uint64_t v54 = v18;
    [v18 doubleValue];
    id v51 = objc_msgSend(v19, "initWithTimeIntervalSince1970:");
    objc_msgSend(v9, "setDependentRegistrationsTTL:");
    [v9 setDependentRegistrationAuthRetries:&off_1009D18C0];
    CFStringRef v20 = *(void **)(a1 + 32);
    __int16 v21 = +[NSDate date];
    CFStringRef v22 = +[NSDictionary dictionaryWithObject:v21 forKey:kIDSServiceDefaultsLastGDRDateKey];
    [v20 writeAccountDefaults:v22];

    CFStringRef v23 = +[IMRGLog deviceHeartbeat];
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      [v18 doubleValue];
      *(_DWORD *)buf = 134217984;
      char v68 = v24;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "  => seconds: %f", buf, 0xCu);
    }

    id v53 = v10;
    id v25 = [v10 _arrayForKey:@"registrations"];
    __int16 v26 = v9;
    uint64_t v27 = [v9 dependentRegistrations];
    __int16 v28 = [*(id *)(v56 + 32) service];
    unsigned __int8 v29 = [v28 tunnelService];

    uint64_t v55 = (void *)v27;
    if (v29)
    {
      long long v63 = 0u;
      long long v64 = 0u;
      long long v61 = 0u;
      long long v62 = 0u;
      id v30 = [*(id *)(v56 + 32) adHocAccounts];
      id v31 = [v30 countByEnumeratingWithState:&v61 objects:v66 count:16];
      if (v31)
      {
        id v32 = v31;
        uint64_t v33 = *(void *)v62;
        do
        {
          for (uint64_t i = 0; i != v32; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v62 != v33) {
              objc_enumerationMutation(v30);
            }
            id v35 = *(void **)(*((void *)&v61 + 1) + 8 * i);
            uint64_t v36 = [*(id *)(v56 + 32) primaryRegistration];
            CFStringRef v37 = [v36 uris];

            [v35 _updateSessionsWithRegisteredURIs:v37];
            [*(id *)(v56 + 32) _flushTokensForRegisteredURIs:v37];
          }
          id v32 = [v30 countByEnumeratingWithState:&v61 objects:v66 count:16];
        }
        while (v32);
      }
    }
    else
    {
      uint64_t v39 = [*(id *)(v56 + 32) primaryRegistration];
      id v30 = [v39 uris];

      [*(id *)(v56 + 32) _updateSessionsWithRegisteredURIs:v30];
      [*(id *)(v56 + 32) _flushTokensForRegisteredURIs:v30];
    }

    long long v59 = 0u;
    long long v60 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    id v40 = v25;
    id v41 = [v40 countByEnumeratingWithState:&v57 objects:v65 count:16];
    if (v41)
    {
      id v42 = v41;
      uint64_t v43 = *(void *)v58;
      uint64_t v44 = IDSDevicePropertyService;
      do
      {
        for (j = 0; j != v42; j = (char *)j + 1)
        {
          if (*(void *)v58 != v43) {
            objc_enumerationMutation(v40);
          }
          BOOL v46 = *(void **)(*((void *)&v57 + 1) + 8 * (void)j);
          id v47 = [v46 objectForKey:v44];
          char v48 = [v26 serviceIdentifier];
          unsigned int v49 = [v47 isEqualToString:v48];

          if (v49) {
            [*(id *)(v56 + 32) _processReceivedDependentRegistration:v46 oldDependentRegistrations:v55];
          }
        }
        id v42 = [v40 countByEnumeratingWithState:&v57 objects:v65 count:16];
      }
      while (v42);
    }

    id v9 = v26;
    id v10 = v53;
    if (!v55)
    {
      CFStringRef v50 = +[IMRGLog GDR];
      if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, " *** This is our first dependent handles check, we're just storing them", buf, 2u);
      }
    }
    [*(id *)(v56 + 32) _notifyListenersAndSetDependentRegistrations:v40 onRegistrationInfo:v9];
    [*(id *)(v56 + 32) _saveAndNotifyGDRUpdate];
  }
  else
  {
    id v38 = +[IMRGLog warning];
    if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT)) {
      sub_100718ADC(v38);
    }

    [v9 setDependentRegistrationsTTL:0];
    [*(id *)(a1 + 32) _notifyListenersAndSetDependentRegistrations:0 onRegistrationInfo:v9];
    [*(id *)(a1 + 32) _saveAndNotifyGDRUpdate];
    sub_100289F94();
    im_dispatch_after_primary_queue();
  }
}

id sub_10020CFDC(uint64_t a1)
{
  return [*(id *)(a1 + 32) gdrReAuthenticateIfNecessary];
}

id sub_10020CFE4(void *a1)
{
  id v1 = a1;
  if (IDSIsMultiwayRegistrationServiceType())
  {
    id v2 = (id *)&IDSRegistrationServiceTypeFaceTime;
LABEL_5:
    id v3 = *v2;
    goto LABEL_7;
  }
  if (IDSIsFaceTimeRegistrationServiceType())
  {
    id v2 = (id *)&IDSRegistrationServiceTypeCalling;
    goto LABEL_5;
  }
  id v3 = 0;
LABEL_7:

  return v3;
}

id sub_10020DEBC(uint64_t a1, void *a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = a2;
  id v4 = [v2 service];
  id v5 = [v4 identifier];
  int v6 = +[IDSURI URIWithPrefixedURI:v3 withServiceLoggingHint:v5];

  return v6;
}

void sub_10020E564(_Unwind_Exception *a1)
{
  objc_destroyWeak((id *)(v1 - 160));
  _Unwind_Resume(a1);
}

void sub_10020E580(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  [WeakRetained _updateSessionsWithRegisteredURIs:*(void *)(a1 + 32) retryIfNotRegistered:0];
}

id sub_10020E5D4(uint64_t a1, void *a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = a2;
  id v4 = [v2 service];
  id v5 = [v4 identifier];
  int v6 = +[IDSURI URIWithPrefixedURI:v3 withServiceLoggingHint:v5];

  return v6;
}

void sub_1002103E4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSDaemon sharedInstance];
  id v5 = [v3 service];
  int v6 = [v5 pushTopic];
  id v7 = [v4 registrationBroadcasterForTopic:v6 messageContext:*(void *)(a1 + 32)];

  if (IMShouldLog() && v7)
  {
    uint64_t v8 = +[IMRGLog registration];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      id v9 = [*(id *)(a1 + 40) smallDescription];
      int v12 = 138412290;
      id v13 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Broadcasting registration failed for account %@", (uint8_t *)&v12, 0xCu);
    }
  }
  id v10 = [v3 uniqueID];
  uint64_t v11 = +[NSNumber numberWithBool:*(unsigned __int8 *)(a1 + 48)];
  [v7 registrationFailedForAccount:v10 needsDeletion:v11];
}

id sub_100211330(id a1, id a2)
{
  return [a2 objectForKey:@"uri"];
}

id sub_100211C24(id a1, id a2)
{
  id v2 = a2;
  id v3 = [v2 objectForKey:kIDSServiceDefaultsAliasKey];

  if (v3) {
    id v3 = v2;
  }

  return v3;
}

id sub_1002127E4(id a1, id a2)
{
  id v2 = [a2 trimmedString];
  id v3 = objc_msgSend(v2, "_im_normalizedURIString");

  if (IMStringIsPhoneNumber())
  {
    uint64_t v4 = IMCanonicalizeFormattedString();

    id v3 = (void *)v4;
  }

  return v3;
}

id sub_100212E54(uint64_t a1, void *a2)
{
  id v3 = [a2 trimmedString];
  uint64_t v4 = objc_msgSend(v3, "_im_normalizedURIString");

  id v5 = +[FTDeviceSupport sharedInstance];
  if ([v5 supportsSMS])
  {
  }
  else
  {
    unsigned __int8 v6 = [v4 isEqualToIgnoringCase:kIDSServiceDefaultsSentinelAlias];

    if (v6)
    {
LABEL_6:
      id v7 = 0;
      goto LABEL_7;
    }
  }
  if (([*(id *)(a1 + 32) containsObject:v4] & 1) != 0
    || ([*(id *)(a1 + 40) containsObject:v4] & 1) != 0)
  {
    goto LABEL_6;
  }
  if (IMStringIsPhoneNumber())
  {
    uint64_t v9 = IMCanonicalizeFormattedString();

    uint64_t v4 = (void *)v9;
  }
  id v7 = v4;
  uint64_t v4 = v7;
LABEL_7:

  return v7;
}

id sub_1002136F4(uint64_t a1, void *a2)
{
  id v3 = [a2 trimmedString];
  uint64_t v4 = objc_msgSend(v3, "_im_normalizedURIString");

  if (IMStringIsPhoneNumber())
  {
    uint64_t v5 = IMCanonicalizeFormattedString();

    uint64_t v4 = (void *)v5;
  }
  if ([*(id *)(a1 + 32) containsObject:v4]) {
    id v6 = v4;
  }
  else {
    id v6 = 0;
  }

  return v6;
}

BOOL sub_10021379C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [*(id *)(a1 + 32) _validationStatusForAlias:v3];
  if (v4 != (id)3)
  {
    uint64_t v5 = +[IMRGLog registration];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 138412290;
      id v8 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%@ needs to be validated", (uint8_t *)&v7, 0xCu);
    }
  }
  return v4 != (id)3;
}

uint64_t sub_100213880(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([*(id *)(a1 + 32) _validationStatusForAlias:v3] == (id)3
    && ([*(id *)(a1 + 40) containsObject:v3] & 1) == 0)
  {
    uint64_t v5 = +[IMRGLog registration];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 138412290;
      id v8 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%@ should be registered", (uint8_t *)&v7, 0xCu);
    }

    uint64_t v4 = 1;
  }
  else
  {
    uint64_t v4 = 0;
  }

  return v4;
}

id sub_1002140F0(uint64_t a1, void *a2)
{
  id v3 = [a2 trimmedString];
  uint64_t v4 = objc_msgSend(v3, "_im_normalizedURIString");

  if IMStringIsEmail() && *(void *)(a1 + 32) && (IMAreEmailsLogicallyTheSame()) {
    id v5 = 0;
  }
  else {
    id v5 = v4;
  }

  return v5;
}

void sub_100214868(uint64_t a1, uint64_t a2, uint64_t a3, int a4, void *a5)
{
  if (!a4)
  {
    id v7 = objc_msgSend(*(id *)(a1 + 32), "_handleAndConvertFeatureToggleError:");
    uint64_t v8 = *(void *)(a1 + 40);
    id v12 = +[IDSFeatureToggleRetrievalResult resultWithError:v7];
    (*(void (**)(uint64_t, id))(v8 + 16))(v8, v12);
    goto LABEL_13;
  }
  id v12 = [a5 objectForKeyedSubscript:@"user-flag-status"];
  if ([v12 isEqualToString:@"enabled"])
  {
    uint64_t v6 = 1;
  }
  else if ([v12 isEqualToString:@"disabled"])
  {
    uint64_t v6 = 2;
  }
  else if ([v12 isEqualToString:@"not-applicable"])
  {
    uint64_t v6 = 4;
  }
  else
  {
    if (([v12 isEqualToString:@"mismatch"] & 1) == 0)
    {
      uint64_t v9 = *(void *)(a1 + 40);
      uint64_t v10 = +[IDSFeatureToggleRetrievalResult resultWithError:7];
      goto LABEL_12;
    }
    uint64_t v6 = 3;
  }
  uint64_t v9 = *(void *)(a1 + 40);
  uint64_t v10 = +[IDSFeatureToggleRetrievalResult resultWithState:v6];
LABEL_12:
  uint64_t v11 = (void *)v10;
  (*(void (**)(uint64_t, uint64_t))(v9 + 16))(v9, v10);

LABEL_13:
}

void sub_100214ABC(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a4)
  {
    uint64_t v5 = *(void *)(a1 + 40);
    +[IDSFeatureToggleUpdateResult successfulResult];
  }
  else
  {
    id v6 = objc_msgSend(*(id *)(a1 + 32), "_handleAndConvertFeatureToggleError:");
    uint64_t v5 = *(void *)(a1 + 40);
    +[IDSFeatureToggleUpdateResult resultWithError:v6];
  }
  id v7 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t))(v5 + 16))(v5);
}

void sub_100214E68(uint64_t a1, uint64_t a2, uint64_t a3, char a4, void *a5, void *a6)
{
  id v25 = a5;
  id v10 = a6;
  [*(id *)(a1 + 32) _handlePseudonymProvisionError:a3];
  if (a4)
  {
    uint64_t v11 = [v25 objectForKey:@"alias"];
    uint64_t v12 = [v25 objectForKey:@"expiry-epoch-seconds"];
    id v13 = (void *)v12;
    if (v11 && v12)
    {
      id v14 = objc_alloc((Class)IDSPseudonym);
      uint64_t v15 = +[IDSURI URIWithPrefixedURI:v11];
      uint64_t v16 = *(void *)(a1 + 40);
      double v17 = *(void **)(a1 + 48);
      [v13 doubleValue];
      id v18 = objc_msgSend(v17, "withUpdatedExpiryEpoch:");
      id v19 = [v14 initWithURI:v15 maskedURI:v16 properties:v18];

      [*(id *)(a1 + 32) _addPseudonym:v19];
      CFStringRef v20 = *(void (**)(void))(*(void *)(a1 + 56) + 16);
    }
    else
    {
      uint64_t v22 = *(void *)(a1 + 56);
      id v19 = +[NSError errorWithDomain:IDSPseudonymErrorDomain code:300 userInfo:0];
      CFStringRef v20 = *(void (**)(void))(v22 + 16);
    }
    v20();
  }
  else
  {
    if (v10)
    {
      id v21 = v10;
    }
    else
    {
      uint64_t v23 = 200;
      if (a3 == 6011) {
        uint64_t v23 = 700;
      }
      if (a3 == 20000) {
        uint64_t v24 = 800;
      }
      else {
        uint64_t v24 = v23;
      }
      id v21 = +[NSError errorWithDomain:IDSPseudonymErrorDomain code:v24 userInfo:0];
    }
    uint64_t v11 = v21;
    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
  }
}

void sub_1002151DC(uint64_t a1, uint64_t a2, uint64_t a3, char a4, void *a5, void *a6)
{
  id v21 = a5;
  id v10 = a6;
  [*(id *)(a1 + 32) _handlePseudonymProvisionError:a3];
  if (a4)
  {
    uint64_t v11 = [v21 objectForKey:@"expiry-epoch-seconds"];
    if (v11)
    {
      uint64_t v12 = *(void **)(a1 + 40);
      id v13 = [v12 properties];
      [v11 doubleValue];
      id v14 = objc_msgSend(v13, "withUpdatedExpiryEpoch:");
      uint64_t v15 = [v12 withUpdatedProperties:v14];

      [*(id *)(a1 + 32) _addPseudonym:v15];
      uint64_t v16 = *(void (**)(void))(*(void *)(a1 + 48) + 16);
    }
    else
    {
      uint64_t v18 = *(void *)(a1 + 48);
      uint64_t v15 = +[NSError errorWithDomain:IDSPseudonymErrorDomain code:300 userInfo:0];
      uint64_t v16 = *(void (**)(void))(v18 + 16);
    }
    v16();
  }
  else
  {
    if (v10)
    {
      id v17 = v10;
    }
    else
    {
      uint64_t v19 = 200;
      if (a3 == 6011) {
        uint64_t v19 = 700;
      }
      if (a3 == 20000) {
        uint64_t v20 = 800;
      }
      else {
        uint64_t v20 = v19;
      }
      id v17 = +[NSError errorWithDomain:IDSPseudonymErrorDomain code:v20 userInfo:0];
    }
    uint64_t v11 = v17;
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
}

void sub_1002154F8(uint64_t a1, uint64_t a2, uint64_t a3, char a4, void *a5, void *a6)
{
  id v10 = a5;
  id v11 = a6;
  [*(id *)(a1 + 32) _handlePseudonymProvisionError:a3];
  if (a4)
  {
    uint64_t v12 = [v10 _numberForKey:@"deleted"];
    id v13 = v12;
    if (v12 && ([v12 BOOLValue] & 1) == 0)
    {
      id v14 = +[IMRGLog registration];
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v15 = *(void *)(a1 + 40);
        uint64_t v16 = [*(id *)(a1 + 32) uniqueID];
        int v21 = 138412546;
        uint64_t v22 = v15;
        __int16 v23 = 2112;
        uint64_t v24 = v16;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Server indicated we are out of sync with pseudonyms, kicking deletion {pseudonym: %@, uniqueID: %@}", (uint8_t *)&v21, 0x16u);
      }
      [*(id *)(a1 + 32) _updateHandles:1];
    }
    [*(id *)(a1 + 32) _removePseudonym:*(void *)(a1 + 40)];
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  else
  {
    if (v11)
    {
      id v17 = v11;
    }
    else
    {
      uint64_t v18 = 200;
      if (a3 == 6011) {
        uint64_t v18 = 700;
      }
      if (a3 == 20000) {
        uint64_t v19 = 800;
      }
      else {
        uint64_t v19 = v18;
      }
      id v17 = +[NSError errorWithDomain:IDSPseudonymErrorDomain code:v19 userInfo:0];
    }
    uint64_t v20 = v17;
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    if (a3 == 6005 || a3 == 1) {
      [*(id *)(a1 + 32) _removePseudonym:*(void *)(a1 + 40)];
    }
  }
}

uint64_t sub_100215B3C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = kIDSServiceDefaultsURIKey;
  uint64_t v5 = [v3 objectForKey:kIDSServiceDefaultsURIKey];
  if (v5)
  {
    id v6 = [v3 objectForKey:v4];
    id v7 = [*(id *)(a1 + 32) URI];
    uint64_t v8 = [v7 prefixedURI];
    uint64_t v9 = [v6 isEqualToString:v8] ^ 1;
  }
  else
  {
    uint64_t v9 = 0;
  }

  return v9;
}

uint64_t sub_100215FB0(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = kIDSServiceDefaultsURIKey;
  uint64_t v5 = [v3 objectForKey:kIDSServiceDefaultsURIKey];
  if (v5)
  {
    id v6 = [v3 objectForKey:v4];
    id v7 = [*(id *)(a1 + 32) URI];
    uint64_t v8 = [v7 prefixedURI];
    uint64_t v9 = [v6 isEqualToString:v8] ^ 1;
  }
  else
  {
    uint64_t v9 = 0;
  }

  return v9;
}

void sub_100216C20(uint64_t a1, uint64_t a2, uint64_t a3, char a4, void *a5, void *a6)
{
  id v10 = a5;
  id v11 = a6;
  [*(id *)(a1 + 32) _handleKTOptInStatusUpdateError:a3];
  id v12 = objc_alloc_init((Class)NSMutableArray);
  id v13 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
  if (+[IMUserDefaults keyTransparencyDropOptInMessageAfterSending]&& CUTIsInternalInstall())
  {
    id v14 = +[IDSFoundationLog KeyTransparency];
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Dropping Opt In/Out server response because user default is set.", buf, 2u);
    }

    uint64_t v15 = [*(id *)(*(void *)(a1 + 32) + 24) identifier];
    unsigned int v16 = [v15 isEqualToString:@"com.apple.madrid"];

    if (v16)
    {
      long long v72 = 0u;
      long long v73 = 0u;
      long long v70 = 0u;
      long long v71 = 0u;
      uint64_t v56 = a1;
      id v17 = [*(id *)(a1 + 32) vettedAliases];
      id v18 = [v17 countByEnumeratingWithState:&v70 objects:v84 count:16];
      if (v18)
      {
        id v19 = v18;
        uint64_t v20 = *(void *)v71;
        do
        {
          for (uint64_t i = 0; i != v19; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v71 != v20) {
              objc_enumerationMutation(v17);
            }
            id v22 = [objc_alloc((Class)IDSURI) initWithPrefixedURI:*(void *)(*((void *)&v70 + 1) + 8 * i)];
            [v12 addObject:v22];
          }
          id v19 = [v17 countByEnumeratingWithState:&v70 objects:v84 count:16];
        }
        while (v19);
      }

      a1 = v56;
    }
    uint64_t v23 = -8005;
    goto LABEL_44;
  }
  if ((a4 & 1) == 0)
  {
    uint64_t v43 = [*(id *)(*(void *)(a1 + 32) + 24) identifier];
    unsigned int v44 = [v43 isEqualToString:@"com.apple.madrid"];

    if (v44)
    {
      CFMutableDictionaryRef theDicta = v13;
      long long v68 = 0u;
      long long v69 = 0u;
      long long v66 = 0u;
      long long v67 = 0u;
      uint64_t v58 = a1;
      id v45 = [*(id *)(a1 + 32) vettedAliases];
      id v46 = [v45 countByEnumeratingWithState:&v66 objects:v83 count:16];
      if (v46)
      {
        id v47 = v46;
        uint64_t v48 = *(void *)v67;
        do
        {
          for (j = 0; j != v47; j = (char *)j + 1)
          {
            if (*(void *)v67 != v48) {
              objc_enumerationMutation(v45);
            }
            id v50 = [objc_alloc((Class)IDSURI) initWithUnprefixedURI:*(void *)(*((void *)&v66 + 1) + 8 * (void)j)];
            [v12 addObject:v50];
          }
          id v47 = [v45 countByEnumeratingWithState:&v66 objects:v83 count:16];
        }
        while (v47);
      }

      id v13 = theDicta;
      a1 = v58;
    }
    if (a3 == 6013)
    {
      uint64_t v23 = -8101;
    }
    else
    {
      if (v11)
      {
        id v51 = v11;
LABEL_45:
        id v25 = v51;
        uint64_t v37 = *(void *)(a1 + 40);
        id v38 = objc_alloc((Class)IDSKTOptInResult);
        uint64_t v39 = 0;
        id v40 = v12;
        id v41 = v13;
        id v42 = v25;
        goto LABEL_46;
      }
      uint64_t v23 = -8100;
    }
LABEL_44:
    id v51 = +[NSError errorWithDomain:@"IDSKeyTransparencyVerifierErrorDomain" code:v23 userInfo:0];
    goto LABEL_45;
  }
  uint64_t v24 = [v10 objectForKeyedSubscript:@"kt-opt-in-results"];
  id v25 = [v24 firstObject];

  if (v25)
  {
    id v55 = v10;
    uint64_t v57 = a1;
    theDict = v13;
    id v53 = v25;
    id v54 = v11;
    long long v64 = 0u;
    long long v65 = 0u;
    long long v62 = 0u;
    long long v63 = 0u;
    id obj = [v25 objectForKeyedSubscript:@"uris"];
    id v26 = [obj countByEnumeratingWithState:&v62 objects:v82 count:16];
    if (v26)
    {
      id v27 = v26;
      uint64_t v28 = *(void *)v63;
      do
      {
        for (k = 0; k != v27; k = (char *)k + 1)
        {
          if (*(void *)v63 != v28) {
            objc_enumerationMutation(obj);
          }
          id v30 = *(void **)(*((void *)&v62 + 1) + 8 * (void)k);
          id v31 = [v30 objectForKey:@"uri"];
          id v32 = [v30 objectForKey:@"kt-blob"];
          uint64_t v33 = [v30 objectForKey:@"status"];
          uint64_t v34 = [v30 objectForKey:@"kt-status"];
          id v35 = +[IDSFoundationLog KeyTransparency];
          if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138413058;
            uint64_t v75 = v31;
            __int16 v76 = 2112;
            int v77 = v32;
            __int16 v78 = 2112;
            __int16 v79 = v33;
            __int16 v80 = 2112;
            CFStringRef v81 = v34;
            _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "KT Opt In/Out Result Response. {URI: %@, SMT: %@, IDS Server Status: %@, KT Server Status: %@}", buf, 0x2Au);
          }

          id v36 = [objc_alloc((Class)IDSURI) initWithPrefixedURI:v31];
          [v12 addObject:v36];
          if (v32) {
            CFDictionarySetValue(theDict, v36, v32);
          }
        }
        id v27 = [obj countByEnumeratingWithState:&v62 objects:v82 count:16];
      }
      while (v27);
    }

    id v11 = v54;
    id v10 = v55;
    id v13 = theDict;
    a1 = v57;
    id v25 = v53;
  }
  uint64_t v37 = *(void *)(a1 + 40);
  id v38 = objc_alloc((Class)IDSKTOptInResult);
  uint64_t v39 = 1;
  id v40 = v12;
  id v41 = v13;
  id v42 = 0;
LABEL_46:
  id v52 = [v38 initWithSuccess:v39 optedInOutURIs:v40 serverSMTByURI:v41 error:v42];
  (*(void (**)(uint64_t, id))(v37 + 16))(v37, v52);
}

void sub_100217540(uint64_t a1, uint64_t a2, uint64_t a3, char a4, void *a5, void *a6)
{
  id v10 = a5;
  id v11 = a6;
  [*(id *)(a1 + 32) _handleKTOptInStatusUpdateError:a3];
  id v12 = objc_alloc_init((Class)NSMutableArray);
  id v13 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
  if (!+[IMUserDefaults keyTransparencyDropOptInMessageAfterSending]|| !CUTIsInternalInstall())
  {
    if (a4)
    {
      id v30 = [v10 objectForKeyedSubscript:@"kt-opt-in-results"];
      uint64_t v23 = [v30 firstObject];

      if (v23)
      {
        id v60 = v10;
        uint64_t v62 = a1;
        theDict = v13;
        uint64_t v58 = v23;
        id v59 = v11;
        long long v69 = 0u;
        long long v70 = 0u;
        long long v67 = 0u;
        long long v68 = 0u;
        id obj = [v23 objectForKeyedSubscript:@"uris"];
        id v31 = [obj countByEnumeratingWithState:&v67 objects:v87 count:16];
        if (v31)
        {
          id v32 = v31;
          uint64_t v33 = *(void *)v68;
          do
          {
            for (uint64_t i = 0; i != v32; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v68 != v33) {
                objc_enumerationMutation(obj);
              }
              id v35 = *(void **)(*((void *)&v67 + 1) + 8 * i);
              id v36 = [v35 objectForKey:@"uri"];
              uint64_t v37 = [v35 objectForKey:@"kt-blob"];
              id v38 = [v35 objectForKey:@"status"];
              uint64_t v39 = [v35 objectForKey:@"kt-status"];
              id v40 = +[IDSFoundationLog KeyTransparency];
              if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 138413058;
                __int16 v80 = v36;
                __int16 v81 = 2112;
                long long v82 = v37;
                __int16 v83 = 2112;
                __int16 v84 = v38;
                __int16 v85 = 2112;
                id v86 = v39;
                _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "KT Opt In/Out Result Response. {URI: %@, SMT: %@, IDS Server Status: %@, KT Server Status: %@}", buf, 0x2Au);
              }

              id v41 = [objc_alloc((Class)IDSURI) initWithPrefixedURI:v36];
              [v12 addObject:v41];
              if (v37) {
                CFDictionarySetValue(theDict, v41, v37);
              }
            }
            id v32 = [obj countByEnumeratingWithState:&v67 objects:v87 count:16];
          }
          while (v32);
        }

        id v11 = v59;
        id v10 = v60;
        id v13 = theDict;
        a1 = v62;
        uint64_t v23 = v58;
      }
      uint64_t v24 = *(void *)(a1 + 40);
      id v25 = objc_alloc((Class)IDSKTOptInResult);
      uint64_t v26 = 1;
      id v27 = v12;
      uint64_t v28 = v13;
      unsigned __int8 v29 = 0;
      goto LABEL_30;
    }
    uint64_t v43 = [*(id *)(*(void *)(a1 + 32) + 24) identifier];
    unsigned int v44 = [v43 isEqualToString:@"com.apple.madrid"];

    if (v44)
    {
      CFMutableDictionaryRef theDicta = v13;
      long long v73 = 0u;
      long long v74 = 0u;
      long long v71 = 0u;
      long long v72 = 0u;
      uint64_t v63 = a1;
      id v45 = [*(id *)(a1 + 32) vettedAliases];
      id v46 = [v45 countByEnumeratingWithState:&v71 objects:v90 count:16];
      if (v46)
      {
        id v47 = v46;
        uint64_t v48 = *(void *)v72;
        do
        {
          for (j = 0; j != v47; j = (char *)j + 1)
          {
            if (*(void *)v72 != v48) {
              objc_enumerationMutation(v45);
            }
            id v50 = [objc_alloc((Class)IDSURI) initWithUnprefixedURI:*(void *)(*((void *)&v71 + 1) + 8 * (void)j)];
            [v12 addObject:v50];
          }
          id v47 = [v45 countByEnumeratingWithState:&v71 objects:v90 count:16];
        }
        while (v47);
      }

      id v13 = theDicta;
      a1 = v63;
    }
    uint64_t v51 = +[NSError errorWithDomain:FTErrorDomain code:a3 userInfo:0];
    id v42 = (id)v51;
    if (v51)
    {
      NSErrorUserInfoKey v88 = NSUnderlyingErrorKey;
      uint64_t v89 = v51;
      id v52 = +[NSDictionary dictionaryWithObjects:&v89 forKeys:&v88 count:1];
    }
    else
    {
      id v52 = 0;
    }
    if (a3 == 6013)
    {
      uint64_t v53 = -8101;
      id v54 = 0;
    }
    else
    {
      if (v11)
      {
        id v55 = v11;
LABEL_49:
        uint64_t v23 = v55;
        uint64_t v56 = *(void *)(a1 + 40);
        id v57 = [objc_alloc((Class)IDSKTOptInResult) initWithSuccess:0 optedInOutURIs:v12 serverSMTByURI:v13 error:v55];
        (*(void (**)(uint64_t, id))(v56 + 16))(v56, v57);

        goto LABEL_50;
      }
      uint64_t v53 = -8100;
      id v54 = v52;
    }
    id v55 = +[NSError errorWithDomain:@"IDSKeyTransparencyVerifierErrorDomain" code:v53 userInfo:v54];
    goto LABEL_49;
  }
  id v14 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Dropping Opt In/Out server response because user default is set.", buf, 2u);
  }

  uint64_t v15 = [*(id *)(*(void *)(a1 + 32) + 24) identifier];
  unsigned int v16 = [v15 isEqualToString:@"com.apple.madrid"];

  if (v16)
  {
    long long v77 = 0u;
    long long v78 = 0u;
    long long v75 = 0u;
    long long v76 = 0u;
    uint64_t v61 = a1;
    id v17 = [*(id *)(a1 + 32) vettedAliases];
    id v18 = [v17 countByEnumeratingWithState:&v75 objects:v91 count:16];
    if (v18)
    {
      id v19 = v18;
      uint64_t v20 = *(void *)v76;
      do
      {
        for (k = 0; k != v19; k = (char *)k + 1)
        {
          if (*(void *)v76 != v20) {
            objc_enumerationMutation(v17);
          }
          id v22 = [objc_alloc((Class)IDSURI) initWithPrefixedURI:*(void *)(*((void *)&v75 + 1) + 8 * (void)k)];
          [v12 addObject:v22];
        }
        id v19 = [v17 countByEnumeratingWithState:&v75 objects:v91 count:16];
      }
      while (v19);
    }

    a1 = v61;
  }
  uint64_t v23 = +[NSError errorWithDomain:@"IDSKeyTransparencyVerifierErrorDomain" code:-8005 userInfo:0];
  uint64_t v24 = *(void *)(a1 + 40);
  id v25 = objc_alloc((Class)IDSKTOptInResult);
  uint64_t v26 = 0;
  id v27 = v12;
  uint64_t v28 = v13;
  unsigned __int8 v29 = v23;
LABEL_30:
  id v42 = [v25 initWithSuccess:v26 optedInOutURIs:v27 serverSMTByURI:v28 error:v29];
  (*(void (**)(uint64_t, id))(v24 + 16))(v24, v42);
LABEL_50:
}

void sub_100217EAC(id a1, IDSDeliveryContext *a2)
{
  id v2 = a2;
  id v3 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    id v4 = [(IDSDeliveryContext *)v2 idsResponseCode];
    uint64_t v5 = [(IDSDeliveryContext *)v2 responseError];
    int v6 = 134218242;
    id v7 = v4;
    __int16 v8 = 2112;
    uint64_t v9 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Finished sending 132 to peers with response { code: %ld error: %@ }", (uint8_t *)&v6, 0x16u);
  }
}

void sub_10021839C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSDaemon sharedInstance];
  uint64_t v5 = [v3 service];
  int v6 = [v5 pushTopic];
  id v7 = [v4 registrationBroadcasterForTopic:v6 messageContext:*(void *)(a1 + 32)];

  if (IMShouldLog() && v7)
  {
    __int16 v8 = +[IMRGLog registration];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = [*(id *)(a1 + 40) smallDescription];
      int v11 = 138412290;
      id v12 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Broadcasting refresh registration for account %@", (uint8_t *)&v11, 0xCu);
    }
  }
  id v10 = [v3 uniqueID];
  [v7 refreshRegistrationForAccount:v10];
}

void sub_100219F08(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 lastCall])
  {
    id v4 = +[IDSFoundationLog delivery];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 32);
      id v6 = [v3 idsResponseCode];
      id v7 = [v3 responseError];
      int v11 = 138412802;
      uint64_t v12 = v5;
      __int16 v13 = 2048;
      id v14 = v6;
      __int16 v15 = 2112;
      unsigned int v16 = v7;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Finished sending 133 with GUID: %@ and response { code: %ld error: %@ }", (uint8_t *)&v11, 0x20u);
    }
    id v8 = [v3 idsResponseCode];
    uint64_t v9 = *(void *)(a1 + 40);
    if (v8)
    {
      id v10 = [v3 responseError];
      (*(void (**)(uint64_t, void, void *))(v9 + 16))(v9, 0, v10);
    }
    else
    {
      (*(void (**)(uint64_t, uint64_t, void))(v9 + 16))(v9, 1, 0);
    }
  }
}

id sub_10021A068(id a1, id a2)
{
  return [a2 objectForKey:@"uri"];
}

void sub_10021A08C(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0xCu);
}

uint64_t sub_10021A0A4(uint64_t result, uint64_t a2, float a3)
{
  *(float *)a2 = a3;
  *(void *)(a2 + 4) = result;
  *(_WORD *)(a2 + 12) = 2080;
  return result;
}

void sub_10021B5D0(uint64_t a1, void *a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = a2;
  id v5 = [v2 accountController];
  id v4 = [v3 uniqueID];

  [v5 enableAccountWithUniqueID:v4];
}

void sub_10021B648(uint64_t a1, void *a2)
{
  id v5 = a2;
  unsigned int v3 = [*(id *)(a1 + 32) registrationStatus];
  if (v3 != -1 && v3 != 5) {
    [v5 registerAccount];
  }
}

void sub_10021BB20(uint64_t a1, void *a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = a2;
  id v4 = [v2 accountController];
  [v4 removeAccount:v3];
}

id sub_10021C2DC(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = kIDSServiceDefaultsInvisibleAliasesKey;
  uint64_t v5 = [*(id *)(a1 + 32) objectForKey:kIDSServiceDefaultsInvisibleAliasesKey];
  if (!v5) {
    goto LABEL_5;
  }
  id v6 = (void *)v5;
  id v7 = [v3 invisibleAliases];
  id v8 = [v7 count];

  if (!v8) {
    goto LABEL_5;
  }
  id v9 = objc_alloc((Class)NSSet);
  id v10 = [*(id *)(a1 + 32) objectForKey:v4];
  id v11 = [v9 initWithArray:v10];

  id v12 = objc_alloc((Class)NSMutableSet);
  __int16 v13 = [v3 invisibleAliases];
  id v14 = [v12 initWithArray:v13];

  [v14 unionSet:v11];
  if ([v14 isEqualToSet:v11])
  {

LABEL_5:
    id v15 = *(id *)(a1 + 32);
    goto LABEL_7;
  }
  id v15 = [*(id *)(a1 + 32) mutableCopy];
  unsigned int v16 = [v14 allObjects];
  [v15 setObject:v16 forKey:v4];

LABEL_7:

  return v15;
}

id sub_10021C44C(uint64_t a1, void *a2)
{
  return [a2 _updateAccountWithAccountInfo:*(void *)(a1 + 32)];
}

void sub_10021CCA0(id a1)
{
  uint64_t v1 = *(const void **)IMWeakLinkSymbol();
  qword_100A4AB18 = (uint64_t)v1;
  if (v1)
  {
    CFRetain(v1);
  }
}

void sub_10021CCF0(id a1)
{
  uint64_t v1 = *(const void **)IMWeakLinkSymbol();
  qword_100A4AB28 = (uint64_t)v1;
  if (v1)
  {
    CFRetain(v1);
  }
}

void sub_10021CD94(id a1)
{
  uint64_t v1 = objc_alloc_init(IDSServerStorageStateMachine);
  uint64_t v2 = qword_100A4AB38;
  qword_100A4AB38 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

id sub_10021D838(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) _stateMachineTimedOut:a2];
}

id sub_10021D9BC(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) _stateMachineTimedOut:a2];
}

void sub_10021E330(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 idsResponseCode])
  {
    [*(id *)(a1 + 40) terminateStateMachineForTopic:*(void *)(a1 + 32)];
    uint64_t v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 32);
      id v6 = [v3 idsResponseCode];
      id v7 = [v3 responseError];
      *(_DWORD *)buf = 138412802;
      uint64_t v16 = v5;
      __int16 v17 = 2048;
      id v18 = v6;
      __int16 v19 = 2112;
      uint64_t v20 = v7;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Failed sending pending message request response for topic %@. Result code %ld. Error %@.", buf, 0x20u);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      [v3 idsResponseCode];
      id v14 = [v3 responseError];
      _IDSLogV();
    }
  }
  else
  {
    id v8 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(a1 + 32);
      id v10 = [v3 responseError];
      *(_DWORD *)buf = 138412546;
      uint64_t v16 = v9;
      __int16 v17 = 2112;
      id v18 = v10;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Finished sending pending message request response for topic %@  [%@]", buf, 0x16u);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      uint64_t v11 = *(void *)(a1 + 32);
      [v3 responseError];
      v13 = uint64_t v12 = v11;
      _IDSLogV();
    }
    objc_msgSend(*(id *)(a1 + 40), "_startTimeoutTimerForTopic:", *(void *)(a1 + 32), v12, v13);
  }
}

CFStringRef sub_10021F028(int a1)
{
  if ((a1 - 1) > 2) {
    return @"Disabled";
  }
  else {
    return *(&off_100986618 + a1 - 1);
  }
}

id sub_10021F2BC(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (!v2[3])
  {
    [v2 initSKPresenceObject];
    uint64_t v2 = *(void **)(a1 + 32);
  }
  id result = [v2 isMonitoring];
  if ((result & 1) == 0)
  {
    [*(id *)(a1 + 32) _subscribe];
    uint64_t v4 = *(void **)(a1 + 32);
    return [v4 setIsMonitoring:1];
  }
  return result;
}

void *sub_10021F3AC(uint64_t a1)
{
  id result = *(void **)(a1 + 32);
  if (result[3])
  {
    id result = [result isMonitoring];
    if (result)
    {
      [*(id *)(a1 + 32) _unsubscribe];
      [*(id *)(a1 + 32) setIsMonitoring:0];
      id v3 = *(void **)(a1 + 32);
      return _[v3 releaseSKPresenceObjectIfPossible];
    }
  }
  return result;
}

id sub_10021F49C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (!v2[3])
  {
    [v2 initSKPresenceObject];
    uint64_t v2 = *(void **)(a1 + 32);
  }
  id result = [v2 isAssertingPresence];
  if ((result & 1) == 0)
  {
    [*(id *)(a1 + 32) _assertPresence];
    uint64_t v4 = *(void **)(a1 + 32);
    return [v4 setIsAssertingPresence:1];
  }
  return result;
}

void *sub_10021F58C(uint64_t a1)
{
  id result = *(void **)(a1 + 32);
  if (result[3])
  {
    id result = [result isAssertingPresence];
    if (result)
    {
      [*(id *)(a1 + 32) _releasePresence];
      [*(id *)(a1 + 32) setIsAssertingPresence:0];
      id v3 = *(void **)(a1 + 32);
      return _[v3 releaseSKPresenceObjectIfPossible];
    }
  }
  return result;
}

void sub_10021F894(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [*(id *)(a1 + 32) queue];
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_10021F94C;
  v7[3] = &unk_10097E440;
  uint64_t v5 = *(void *)(a1 + 32);
  id v8 = v3;
  uint64_t v9 = v5;
  id v6 = v3;
  dispatch_async(v4, v7);
}

void sub_10021F94C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = +[IDSFoundationLog IPsecLink];
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      uint64_t v5 = *(void **)(a1 + 32);
      int v7 = 138412290;
      id v8 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "presence: could not assert due to error %@", (uint8_t *)&v7, 0xCu);
    }

    *(_DWORD *)(*(void *)(a1 + 40) + 12) = 1;
    *(unsigned char *)(*(void *)(a1 + 40) + 9) = 0;
  }
  else
  {
    if (v4)
    {
      id v6 = [*(id *)(*(void *)(a1 + 40) + 24) presenceIdentifier];
      int v7 = 138412290;
      id v8 = v6;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "presence: succesfully asserted for %@", (uint8_t *)&v7, 0xCu);
    }
  }
}

void sub_10021FB1C(uint64_t a1, void *a2)
{
  id v3 = a2;
  BOOL v4 = +[IDSFoundationLog IPsecLink];
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v5)
    {
      int v8 = 138412290;
      id v9 = v3;
      id v6 = "presence: could not release assertion due to error %@";
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v8, 0xCu);
    }
  }
  else if (v5)
  {
    int v7 = *(void **)(a1 + 32);
    int v8 = 138412290;
    id v9 = v7;
    id v6 = "presence: succesfully released for %@";
    goto LABEL_6;
  }
}

void sub_10021FC84(uint64_t a1, void *a2)
{
  id v3 = a2;
  BOOL v4 = [*(id *)(a1 + 32) queue];
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_10021FD3C;
  v7[3] = &unk_10097E440;
  uint64_t v5 = *(void *)(a1 + 32);
  id v8 = v3;
  uint64_t v9 = v5;
  id v6 = v3;
  dispatch_async(v4, v7);
}

void sub_10021FD3C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = +[IDSFoundationLog IPsecLink];
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      uint64_t v5 = *(void **)(a1 + 32);
      int v9 = 138412290;
      id v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "presence: could not subscribe due to error %@", (uint8_t *)&v9, 0xCu);
    }

    *(_DWORD *)(*(void *)(a1 + 40) + 12) = 1;
    *(unsigned char *)(*(void *)(a1 + 40) + _Block_object_dispose(&STACK[0x300], 8) = 0;
  }
  else
  {
    if (v4)
    {
      id v6 = [*(id *)(*(void *)(a1 + 40) + 24) presenceIdentifier];
      int v9 = 138412290;
      id v10 = v6;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "presence: succesfully subscribed for %@", (uint8_t *)&v9, 0xCu);
    }
    int v7 = +[IDSFoundationLog IPsecLink];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      id v8 = [*(id *)(*(void *)(a1 + 40) + 24) presentDevices];
      int v9 = 138412290;
      id v10 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "presence: current devices: %@", (uint8_t *)&v9, 0xCu);
    }
  }
}

void sub_10021FF78(uint64_t a1, void *a2)
{
  id v3 = a2;
  BOOL v4 = +[IDSFoundationLog IPsecLink];
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v5)
    {
      int v8 = 138412290;
      id v9 = v3;
      id v6 = "presence: could not release subscription due to error %@";
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v8, 0xCu);
    }
  }
  else if (v5)
  {
    int v7 = *(void **)(a1 + 32);
    int v8 = 138412290;
    id v9 = v7;
    id v6 = "presence: succesfully released subscription for %@";
    goto LABEL_6;
  }
}

uint64_t sub_1002204A4(uint64_t result, unsigned __int8 *a2, int a3)
{
  if (a3 >= 1)
  {
    uint64_t v3 = a3;
    BOOL v4 = (unsigned char *)(result + 1);
    do
    {
      unsigned int v6 = *a2++;
      char v5 = v6;
      unsigned int v7 = v6 & 0xF;
      int v8 = (v6 >> 4) + 55;
      int v9 = (v6 >> 4) | 0x30;
      if (v6 >= 0xA0) {
        LOBYTE(v9) = v8;
      }
      *(v4 - 1) = v9;
      if (v7 >= 0xA) {
        char v10 = v7 + 55;
      }
      else {
        char v10 = v5 & 0xF | 0x30;
      }
      *BOOL v4 = v10;
      v4 += 2;
      --v3;
    }
    while (v3);
  }
  *(unsigned char *)(result + 2 * a3) = 0;
  return result;
}

uint64_t sub_100220500(uint64_t a1)
{
  if (!*(_DWORD *)a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = *(_CCCryptor **)(a1 + 264);
  if (v2)
  {
    CCCryptorRelease(v2);
    *(void *)(a1 + 264) = 0;
    *(_OWORD *)(a1 + 272) = 0u;
    *(_OWORD *)(a1 + 28_Block_object_dispose(&STACK[0x300], 8) = 0u;
    *(_OWORD *)(a1 + 304) = 0u;
    *(_OWORD *)(a1 + 320) = 0u;
    *(_OWORD *)(a1 + 336) = 0u;
    *(_OWORD *)(a1 + 352) = 0u;
    *(_OWORD *)(a1 + 36_Block_object_dispose(&STACK[0x300], 8) = 0u;
    *(_OWORD *)(a1 + 384) = 0u;
    *(_OWORD *)(a1 + 400) = 0u;
    *(_OWORD *)(a1 + 416) = 0u;
    *(_OWORD *)(a1 + 432) = 0u;
    *(_OWORD *)(a1 + 44_Block_object_dispose(&STACK[0x300], 8) = 0u;
    *(_OWORD *)(a1 + 464) = 0u;
    *(_OWORD *)(a1 + 480) = 0u;
    *(_OWORD *)(a1 + 496) = 0u;
    *(_OWORD *)(a1 + 512) = 0u;
    *(_OWORD *)(a1 + 52_Block_object_dispose(&STACK[0x300], 8) = 0u;
    *(_OWORD *)(a1 + 544) = 0u;
    *(_OWORD *)(a1 + 560) = 0u;
    *(_OWORD *)(a1 + 576) = 0u;
    *(_OWORD *)(a1 + 592) = 0u;
    *(_OWORD *)(a1 + 60_Block_object_dispose(&STACK[0x300], 8) = 0u;
    *(_OWORD *)(a1 + 624) = 0u;
    *(_OWORD *)(a1 + 640) = 0u;
    *(_OWORD *)(a1 + 656) = 0u;
    *(_DWORD *)(a1 + 672) = 0;
  }
  uint64_t v3 = *(void **)(a1 + 256);
  if (v3) {
    free(v3);
  }
  *(void *)(a1 + 24_Block_object_dispose(&STACK[0x300], 8) = 0;
  *(void *)(a1 + 256) = 0;
  sub_10022059C((void ***)(a1 + 2288));
  return 0;
}

void sub_10022059C(void ***a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    if (*v2)
    {
      free(*v2);
      uint64_t v2 = *a1;
    }
    free(v2);
  }
}

uint64_t sub_1002205F4(void *key, uint64_t a2, _OWORD *a3, void *a4)
{
  char v8 = 0;
  *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  dataIn[0] = v9;
  dataIn[1] = v9;
  long long dataOut = v9;
  long long v24 = v9;
  char v10 = *(unsigned char *)(a2 + 7);
  char v11 = 1;
  uint64_t v12 = dataIn;
  do
  {
    char v13 = v11;
    *(void *)uint64_t v12 = *(void *)a2;
    *(void *)((char *)v12 + 6) = *(void *)(a2 + 6);
    *((unsigned char *)v12 + 14) = 0;
    *((unsigned char *)v12 + 15) = v8;
    *((unsigned char *)v12++ + 7) = v10;
    char v8 = 1;
    char v11 = 0;
  }
  while ((v13 & 1) != 0);
  size_t dataOutMoved = 0xAAAAAAAAAAAAAAAALL;
  CCCryptorStatus v14 = CCCrypt(0, 0, 0, key, 0x10uLL, 0, dataIn, 0x20uLL, &dataOut, 0x20uLL, &dataOutMoved);
  if (v14)
  {
    id v15 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      CCCryptorStatus v22 = v14;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "CCCrypt failed with status: %d", buf, 8u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      _IDSLogTransport();
    }
  }
  long long v16 = v24;
  *a3 = dataOut;
  a3[1] = v16;
  *(void *)&dataIn[0] = *(void *)a2;
  *(void *)((char *)dataIn + 6) = *(void *)(a2 + 6);
  HIWORD(dataIn[0]) = 0;
  BYTE7(dataIn[0]) = *(unsigned char *)(a2 + 7) ^ 2;
  uint64_t result = CCCrypt(0, 0, 0, key, 0x10uLL, 0, dataIn, 0x10uLL, &dataOut, 0x10uLL, &dataOutMoved);
  CCCryptorStatus v18 = result;
  if (result)
  {
    __int16 v19 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      CCCryptorStatus v22 = v18;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "CCCrypt failed with status: %d", buf, 8u);
    }

    uint64_t result = os_log_shim_legacy_logging_enabled();
    if (result)
    {
      _IDSWarnV();
      _IDSLogV();
      uint64_t result = _IDSLogTransport();
    }
  }
  *a4 = dataOut;
  *(void *)((char *)a4 + 6) = *(void *)((char *)&dataOut + 6);
  return result;
}

uint64_t sub_100220918(uint64_t a1, _OWORD *a2)
{
  BOOL v4 = malloc_type_malloc(0x20uLL, 0xB021E1EDuLL);
  *(void *)(a1 + 24_Block_object_dispose(&STACK[0x300], 8) = 32;
  *(void *)(a1 + 256) = v4;
  long long v5 = a2[1];
  *BOOL v4 = *a2;
  v4[1] = v5;
  size_t v7 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = CCCryptorCreateFromData(0, 0, 2u, *(const void **)(a1 + 256), 0x20uLL, 0, (const void *)(a1 + 272), 0x194uLL, (CCCryptorRef *)(a1 + 264), &v7);
  if (result == -4301) {
    return CCCryptorCreate(0, 0, 2u, *(const void **)(a1 + 256), 0x20uLL, 0, (CCCryptorRef *)(a1 + 264));
  }
  return result;
}

uint64_t sub_1002209D0(uint64_t a1, unsigned int a2, unsigned int a3)
{
  if (a3 > 0x640) {
    return 4294967291;
  }
  unsigned int v5 = *(unsigned __int16 *)(a1 + 138);
  BOOL v6 = a2 >= v5;
  __int16 v8 = a2 - v5;
  BOOL v7 = a2 > v5;
  unsigned int v9 = *(_DWORD *)(a1 + 132);
  if (v8 < 0)
  {
    int v10 = v7;
    v9 -= v10;
  }
  else
  {
    if (!v6)
    {
      BOOL v6 = __CFADD__(v9++, 1);
      *(_DWORD *)(a1 + 132) = v9;
      if (v6)
      {
        *(_DWORD *)(a1 + 4) = 1;
        return 0xFFFFFFFFLL;
      }
    }
    *(_WORD *)(a1 + 13_Block_object_dispose(&STACK[0x300], 8) = a2;
  }
  size_t dataOutAvailable = (a3 + 15) & 0xFFFFFFF0;
  uint64_t v12 = (_OWORD *)(a1 + 682);
  unsigned int v13 = *(_DWORD *)(a1 + 128);
  *(void *)((char *)&v20 + 6) = *(void *)(a1 + 216);
  *(void *)&long long v20 = *(void *)(a1 + 210);
  *(uint32x2_t *)v14.i8 = vshl_u32((uint32x2_t)vdup_n_s32(v13), (uint32x2_t)0xFFFFFFF0FFFFFFE8);
  *(uint32x2_t *)v15.i8 = vshl_u32((uint32x2_t)vdup_n_s32(v9), (uint32x2_t)0xFFFFFFF0FFFFFFE8);
  v14.i32[2] = v13 >> 8;
  v14.i32[3] = v13;
  v15.i32[2] = v9 >> 8;
  v15.i32[3] = v9;
  *(int8x8_t *)((char *)&v20 + 4) = veor_s8(*(int8x8_t *)((char *)&v20 + 4), vmovn_s16(vuzp1q_s16(v14, v15)));
  char v16 = 8;
  if (!*(_DWORD *)(a1 + 2284)) {
    char v16 = 1;
  }
  BYTE12(v20) ^= a2 >> v16;
  BYTE13(v20) ^= a2;
  HIWORD(v20) = 0;
  if (dword_100A531EC)
  {
    memset(__b, 170, sizeof(__b));
    --dword_100A531EC;
    sub_1002204A4((uint64_t)__b, (unsigned __int8 *)&v20, 16);
    fprintf(__stderrp, "  counters: [%s]\n", (const char *)__b);
  }
  *uint64_t v12 = v20;
  if (dataOutAvailable >= 0x11)
  {
    unint64_t v17 = a1 + 698;
    do
    {
      *(_OWORD *)unint64_t v17 = *(_OWORD *)(v17 - 16);
      __int16 v18 = (*(unsigned char *)(v17 + 15))++ + 1;
      if ((v18 & 0x100) != 0) {
        ++*(unsigned char *)(v17 + 14);
      }
      v17 += 16;
    }
    while (v17 < (unint64_t)v12 + dataOutAvailable);
  }
  __b[0] = 0xAAAAAAAAAAAAAAAALL;
  __int16 v19 = *(_CCCryptor **)(a1 + 264);
  if (v19 && !CCCryptorReset(v19, 0)) {
    CCCryptorUpdate(*(CCCryptorRef *)(a1 + 264), (const void *)(a1 + 682), dataOutAvailable, (void *)(a1 + 682), dataOutAvailable, __b);
  }
  else {
    CCCrypt(0, 0, 2u, *(const void **)(a1 + 256), 0x20uLL, 0, (const void *)(a1 + 682), dataOutAvailable, (void *)(a1 + 682), dataOutAvailable, __b);
  }
  return 0;
}

uint64_t sub_100220C2C(uint64_t a1, unsigned int a2, unsigned __int8 *a3, signed int a4)
{
  if (a4)
  {
    uint64_t result = sub_1002209D0(a1, a2, a4);
    if (result) {
      return result;
    }
    if (dword_100A531EC >= 1)
    {
      int v20 = -1431655766;
      *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v18 = v8;
      long long v19 = v8;
      long long v16 = v8;
      long long v17 = v8;
      long long v14 = v8;
      long long v15 = v8;
      sub_1002204A4((uint64_t)&v14, (unsigned __int8 *)(a1 + 682), 8);
      fprintf(__stderrp, "  iLen=%d KS=[%s]", a4, (const char *)&v14);
      sub_1002204A4((uint64_t)&v14, a3, 8);
      fprintf(__stderrp, " In=[%s]", (const char *)&v14);
    }
    if (a4 >= 1)
    {
      unsigned int v9 = (char *)(a1 + 682);
      unsigned int v10 = a4 + 1;
      char v11 = a3;
      do
      {
        char v12 = *v9++;
        *v11++ ^= v12;
        --v10;
      }
      while (v10 > 1);
    }
    if (dword_100A531EC >= 1)
    {
      int v20 = -1431655766;
      *(void *)&long long v13 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v18 = v13;
      long long v19 = v13;
      long long v16 = v13;
      long long v17 = v13;
      long long v14 = v13;
      long long v15 = v13;
      sub_1002204A4((uint64_t)&v14, a3, 8);
      fprintf(__stderrp, " Out=[%s]\n", (const char *)&v14);
    }
  }
  return 0;
}

uint64_t sub_100220DA4(_DWORD *a1, uint64_t a2, int a3, int a4, int a5, __int16 a6, int a7, __int16 a8, int a9)
{
  if (a3 > 59)
  {
    bzero(a1, 0x11F0uLL);
    long long v19 = (uint64_t *)(a2 + 16);
    int v20 = (_OWORD *)(a2 + 30);
    if (a4)
    {
      *(_OWORD *)(a1 + 37) = *(_OWORD *)a2;
      uint64_t v21 = *v19;
      *(void *)((char *)a1 + 170) = *(void *)(a2 + 22);
      *(void *)(a1 + 41) = v21;
      *(_OWORD *)(a1 + 611) = *v20;
      CCCryptorStatus v22 = a1 + 615;
    }
    else
    {
      *(_OWORD *)(a1 + 611) = *(_OWORD *)a2;
      uint64_t v23 = *v19;
      *(void *)((char *)a1 + 2466) = *(void *)(a2 + 22);
      *(void *)(a1 + 615) = v23;
      *(_OWORD *)(a1 + 37) = *v20;
      CCCryptorStatus v22 = a1 + 41;
    }
    uint64_t v24 = *(void *)(a2 + 46);
    *(void *)((char *)v22 + 6) = *(void *)(a2 + 52);
    void *v22 = v24;
    a1[32] = a5;
    *((_WORD *)a1 + 6_Block_object_dispose(&STACK[0x300], 8) = a6;
    a1[606] = a7;
    *((_WORD *)a1 + 1216) = a8;
    a1[1145] = a9;
    a1[571] = a9;
    id v25 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      int v26 = a1[32];
      int v27 = *((unsigned __int16 *)a1 + 68);
      int v28 = a1[606];
      int v29 = *((unsigned __int16 *)a1 + 1216);
      *(_DWORD *)buf = 67110144;
      int v32 = a9;
      __int16 v33 = 1024;
      int v34 = v26;
      __int16 v35 = 1024;
      int v36 = v27;
      __int16 v37 = 1024;
      int v38 = v28;
      __int16 v39 = 1024;
      int v40 = v29;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "encryption setup (v%d):\n\tsend ssrc:%08x start-seq:%04x\n\trecv ssrc:%08x start-seq:%04x", buf, 0x20u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
    sub_1002205F4(a1 + 37, (uint64_t)(a1 + 41), (_DWORD *)((char *)a1 + 178), (_DWORD *)((char *)a1 + 210));
    sub_100220918((uint64_t)a1, (_DWORD *)((char *)a1 + 178));
    sub_1002205F4(a1 + 611, (uint64_t)(a1 + 615), (_DWORD *)((char *)a1 + 2474), (_DWORD *)((char *)a1 + 2506));
    sub_100220918((uint64_t)(a1 + 574), (_DWORD *)((char *)a1 + 2474));
    *a1 |= 2u;
    a1[574] |= 4u;
    id v30 = sub_100221174();
    uint64_t result = 0;
    *((void *)a1 + 573) = v30;
  }
  else
  {
    unsigned int v10 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109376;
      int v32 = a3;
      __int16 v33 = 1024;
      int v34 = 60;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "IDSStreamEncryption_Init not enough key material bytes: have %d but need %d", buf, 0xEu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
    {
      _IDSLogTransport();
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
    return 1;
  }
  return result;
}

_WORD *sub_100221174()
{
  uint64_t v0 = malloc_type_malloc(0x10uLL, 0x1010040A08D555BuLL);
  if (!v0)
  {
    uint64_t v3 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "Malloc Failed to allocate replayWindow!", buf, 2u);
    }

    if (!os_log_shim_legacy_logging_enabled() || !_IDSShouldLog()) {
      return 0;
    }
LABEL_13:
    _IDSLogV();
    return 0;
  }
  uint64_t v1 = v0;
  v0[4] = 8;
  uint64_t v2 = malloc_type_malloc(0x40uLL, 0x100004000313F17uLL);
  *(void *)uint64_t v1 = v2;
  if (!v2)
  {
    BOOL v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      v6[0] = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Malloc Failed to allocate replayWindow->list!", (uint8_t *)v6, 2u);
    }

    if (!os_log_shim_legacy_logging_enabled() || !_IDSShouldLog()) {
      return 0;
    }
    goto LABEL_13;
  }
  v1[5] = 0;
  *((unsigned char *)v1 + 12) = 0;
  __memset_chk();
  return v1;
}

uint64_t sub_100221340(uint64_t a1)
{
  return 0;
}

uint64_t sub_100221370(uint64_t a1, unsigned int a2, unsigned __int8 *a3, signed int a4, int a5)
{
  uint64_t v8 = a1;
  if (a5)
  {
    if (a5 != 1) {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    uint64_t v8 = a1 + 2296;
  }
  if (*(_DWORD *)v8)
  {
    if (*(_DWORD *)(v8 + 4))
    {
      unsigned int v10 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "srtp rollover counter reached end - hard stop before reusing key", buf, 2u);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
      return 2;
    }
    else
    {
      if (a5) {
        goto LABEL_21;
      }
      uint64_t v12 = *(void *)(v8 + 2288);
      if (!v12) {
        return 3;
      }
      if (sub_100221688(v12, a2))
      {
LABEL_21:
        return sub_100220C2C(v8, a2, a3, a4);
      }
      else
      {
        long long v13 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          int v14 = *(unsigned __int16 *)(*(void *)(v8 + 2288) + 10);
          *(_DWORD *)buf = 67109376;
          int v16 = v14;
          __int16 v17 = 1024;
          unsigned int v18 = a2;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "packet with sequence number: %u->%u dropped by replay protection", buf, 0xEu);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
          _IDSLogV();
        }
        return 4;
      }
    }
  }
  else
  {
    char v11 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "srtp not initialized for transform", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    return 1;
  }
}

uint64_t sub_100221688(uint64_t a1, int a2)
{
  if (*(unsigned char *)(a1 + 12))
  {
    __int16 v4 = *(_WORD *)(a1 + 10);
  }
  else
  {
    __int16 v4 = a2 - 1;
    *(_WORD *)(a1 + 10) = a2 - 1;
    *(unsigned char *)(a1 + 12) = 1;
  }
  int v5 = (__int16)(a2 - v4);
  if (v5 < 1)
  {
    if (v5 == -32768) {
      LOWORD(v9) = 0x7FFF;
    }
    else {
      int v9 = -v5;
    }
    int v10 = (unsigned __int16)v9;
    if ((unsigned __int16)v9 >= 0x200u)
    {
      char v11 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        int v12 = *(unsigned __int16 *)(a1 + 10);
        *(_DWORD *)buf = 67109632;
        int v22 = v12;
        __int16 v23 = 1024;
        int v24 = a2;
        __int16 v25 = 1024;
        int v26 = v10;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "packet too old. seq(%u->%u) = -%u", buf, 0x14u);
      }

      uint64_t result = os_log_shim_legacy_logging_enabled();
      if (result)
      {
        uint64_t result = _IDSShouldLog();
        if (result) {
          goto LABEL_41;
        }
      }
      return result;
    }
    uint64_t v13 = (unsigned __int16)v9 >> 6;
    if (v13 >= *(unsigned __int16 *)(a1 + 8)
      || (uint64_t v14 = *(void *)(*(void *)a1 + 8 * v13), (v14 & (1 << v10)) != 0))
    {
      long long v15 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        int v16 = *(unsigned __int16 *)(a1 + 10);
        *(_DWORD *)buf = 67109632;
        int v22 = v16;
        __int16 v23 = 1024;
        int v24 = a2;
        __int16 v25 = 1024;
        int v26 = v10;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "IDSStreamEncryption_GetbitReplayList returned YES. seq(%u->%u) = -%u", buf, 0x14u);
      }

      uint64_t result = os_log_shim_legacy_logging_enabled();
      if (result)
      {
        uint64_t result = _IDSShouldLog();
        if (result) {
          goto LABEL_41;
        }
      }
      return result;
    }
    *(void *)(*(void *)a1 + 8 * v13) = v14 | (1 << v10);
    return 1;
  }
  if (v5 > 0x1FF)
  {
    bzero(*(void **)a1, 8 * *(unsigned __int16 *)(a1 + 8));
    if (!*(_WORD *)(a1 + 8))
    {
      long long v19 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        int v20 = *(unsigned __int16 *)(a1 + 10);
        *(_DWORD *)buf = 67109632;
        int v22 = v20;
        __int16 v23 = 1024;
        int v24 = a2;
        __int16 v25 = 1024;
        int v26 = v5;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "IDSStreamEncryption_SetbitReplayList after clear returned NO. seq(%u->%u) = %u", buf, 0x14u);
      }

      uint64_t result = os_log_shim_legacy_logging_enabled();
      if (result)
      {
        uint64_t result = _IDSShouldLog();
        if (result) {
          goto LABEL_41;
        }
      }
      return result;
    }
LABEL_23:
    **(void **)a1 |= 1uLL;
    *(_WORD *)(a1 + 10) = a2;
    return 1;
  }
  if ((sub_100221BCC(a1, (unsigned __int16)(a2 - v4)) & 1) == 0)
  {
    __int16 v17 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      int v18 = *(unsigned __int16 *)(a1 + 10);
      *(_DWORD *)buf = 67109632;
      int v22 = v18;
      __int16 v23 = 1024;
      int v24 = a2;
      __int16 v25 = 1024;
      int v26 = v5;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "IDSStreamEncryption_LeftShiftReplayList returned NO. seq(%u->%u) = %u", buf, 0x14u);
    }

    uint64_t result = os_log_shim_legacy_logging_enabled();
    if (result)
    {
      uint64_t result = _IDSShouldLog();
      if (result) {
        goto LABEL_41;
      }
    }
    return result;
  }
  if (*(_WORD *)(a1 + 8)) {
    goto LABEL_23;
  }
  BOOL v6 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = *(unsigned __int16 *)(a1 + 10);
    *(_DWORD *)buf = 67109632;
    int v22 = v7;
    __int16 v23 = 1024;
    int v24 = a2;
    __int16 v25 = 1024;
    int v26 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "IDSStreamEncryption_SetbitReplayList returned NO. seq(%u->%u) = %u", buf, 0x14u);
  }

  uint64_t result = os_log_shim_legacy_logging_enabled();
  if (result)
  {
    uint64_t result = _IDSShouldLog();
    if (result)
    {
LABEL_41:
      _IDSLogV();
      return 0;
    }
  }
  return result;
}

uint64_t sub_100221BCC(uint64_t a1, unsigned int a2)
{
  char v2 = a2;
  if (a2 <= 0x3F)
  {
    LODWORD(v4) = *(unsigned __int16 *)(a1 + 8);
    if (!*(_WORD *)(a1 + 8)) {
      return 1;
    }
LABEL_11:
    unint64_t v10 = 0;
    char v11 = *(unint64_t **)a1;
    uint64_t v12 = v4;
    do
    {
      unint64_t v13 = (*v11 << (v2 & 0x3F)) | (v10 >> (64 - (v2 & 0x3Fu)));
      unint64_t v10 = *v11 & (-1 << -(v2 & 0x3F));
      *v11++ = v13;
      --v12;
    }
    while (v12);
    return 1;
  }
  unint64_t v5 = a2 >> 6;
  uint64_t v4 = *(unsigned __int16 *)(a1 + 8);
  if (v5 < v4)
  {
    BOOL v6 = *(unint64_t **)a1;
    uint64_t v7 = v4 - 1;
    uint64_t v8 = *(void *)a1 - 8 * v5;
    do
      v6[v7] = *(void *)(v8 + 8 * v7);
    while (v7-- > (uint64_t)v5);
    if (v5 <= 1) {
      unint64_t v5 = 1;
    }
    bzero(v6, 8 * v5);
    if (!v4) {
      return 1;
    }
    goto LABEL_11;
  }
  return 0;
}

id sub_10022219C(id a1, IDSCTSIM *a2)
{
  return [(IDSCTSIM *)a2 SIMIdentifier];
}

id sub_100222DFC(id a1, IDSTemporaryPhoneUser *a2)
{
  return [(IDSTemporaryPhoneUser *)a2 labelID];
}

NSString *__cdecl sub_100222E04(id a1, IDSCTSIM *a2)
{
  return (NSString *)[(IDSCTSIM *)a2 SIMIdentifier];
}

id sub_100222E0C(id a1, id a2)
{
  return [a2 uniqueIdentifier];
}

id sub_100222E84(uint64_t a1)
{
  char v2 = +[IMRGLog registration];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Received selectedSubscriptionLabelDidChange", v4, 2u);
  }

  return [*(id *)(a1 + 32) _setupForCurrentSubscriptionState];
}

id sub_100222FE8(uint64_t a1)
{
  char v2 = +[IMRGLog registration];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Received SIMInformationDidChange", v4, 2u);
  }

  return [*(id *)(a1 + 32) _setupForCurrentSubscriptionState];
}

char *sub_1002237D8(uint64_t a1, uint64_t a2)
{
  uint64_t result = byte_100A4AB40;
  if (a2 >= 1)
  {
    uint64_t v4 = 0;
    int v5 = 0;
    uint64_t v6 = 2000;
    if (a2 < 2000) {
      uint64_t v6 = a2;
    }
    while (1)
    {
      unsigned int v7 = *(unsigned __int8 *)(a1 + v4);
      int v8 = (v7 >> 4) + 87;
      if (v7 < 0xA0) {
        LOBYTE(v_Block_object_dispose(&STACK[0x300], 8) = (*(unsigned char *)(a1 + v4) >> 4) | 0x30;
      }
      unsigned int v9 = v7 & 0xF;
      char v10 = v7 & 0xF | 0x30;
      char v11 = (v7 & 0xF) + 87;
      char v12 = v9 >= 0xA ? v11 : v10;
      unint64_t v13 = &byte_100A4AB40[v5];
      char *v13 = v8;
      uint64_t v14 = v5 + 2;
      v13[1] = v12;
      if ((~v4 & 0xF) == 0) {
        break;
      }
      if (v4)
      {
        char v15 = 32;
        goto LABEL_13;
      }
LABEL_14:
      ++v4;
      int v5 = v14;
      if (v6 == v4) {
        goto LABEL_17;
      }
    }
    char v15 = 10;
LABEL_13:
    byte_100A4AB40[v14] = v15;
    LODWORD(v14) = v5 + 3;
    goto LABEL_14;
  }
  LODWORD(v14) = 0;
LABEL_17:
  byte_100A4AB40[(int)v14] = 0;
  return result;
}

void sub_10022388C(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v4 = a4;
  int v5 = os_channel_available_slot_count();
  if (v5)
  {
    int v35 = v5;
    int v6 = v5;
    id v36 = v4;
    while (1)
    {
      *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v52 = v7;
      long long v53 = v7;
      *(_OWORD *)id v50 = v7;
      long long v51 = v7;
      os_channel_get_next_slot();
      if (!os_channel_slot_get_packet())
      {
        int v26 = +[IDSFoundationLog Multiplexer];
        if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_75;
        }
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)__int16 v39 = v35;
        int v27 = "readOSChannel - have slots %u no packet to read!";
        int v28 = v26;
        uint32_t v29 = 8;
LABEL_74:
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, v27, buf, v29);
LABEL_75:

LABEL_76:
        int v30 = os_channel_advance_slot();
        if (v30)
        {
          int v31 = v30;
          int v32 = +[IDSFoundationLog Multiplexer];
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)id v50 = 67109120;
            *(_DWORD *)&uint8_t v50[4] = v31;
            _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "os_channel_advance_slot failed for read %d", v50, 8u);
          }
        }
        int v33 = os_channel_sync();
        if (v33)
        {
          int v34 = v33;
          int v22 = +[IDSFoundationLog Multiplexer];
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)id v50 = 67109120;
            *(_DWORD *)&uint8_t v50[4] = v34;
            __int16 v23 = "os_channel_sync for RX failed %d";
            int v24 = v22;
            uint32_t v25 = 8;
LABEL_83:
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, v23, v50, v25);
          }
          goto LABEL_84;
        }
        goto LABEL_85;
      }
      if (!os_packet_get_next_buflet())
      {
        int v26 = +[IDSFoundationLog Multiplexer];
        if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_75;
        }
        *(_WORD *)buf = 0;
        int v27 = "readOSChannel - have packet but no buflet!";
LABEL_73:
        int v28 = v26;
        uint32_t v29 = 2;
        goto LABEL_74;
      }
      unsigned int data_length = os_packet_get_data_length();
      if (!data_length)
      {
        int v26 = +[IDSFoundationLog Multiplexer];
        if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_75;
        }
        *(_WORD *)buf = 0;
        int v27 = "readOSChannel - have packet and buflet but 0 length!";
        goto LABEL_73;
      }
      unsigned int v9 = data_length;
      kdebug_trace();
      uint64_t object_address = os_buflet_get_object_address();
      unsigned int data_offset = os_buflet_get_data_offset();
      uint64_t v12 = _IDSLinkPacketBufferCreate();
      uint64_t v13 = v12;
      if (*(void *)(v12 + 8) < (unint64_t)v9)
      {
        uint64_t v14 = +[IDSFoundationLog Multiplexer];
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v15 = *(void *)(v13 + 8);
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)__int16 v39 = v9;
          *(_WORD *)&v39[4] = 1024;
          *(_DWORD *)&v39[6] = v15;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "readOSChannel - outgoing packet larger than IDSLinkPacketBuffer max length! (%u > %u)", buf, 0xEu);
        }

        _IDSLinkPacketBufferRelease();
        goto LABEL_63;
      }
      memcpy(*(void **)v12, (const void *)(object_address + data_offset), v9);
      *(void *)(v13 + 16) = v9;
      int service_class = os_packet_get_service_class();
      int v17 = service_class;
      if (service_class <= 2621727)
      {
        if (service_class <= 1048703)
        {
          if (service_class != 524432)
          {
LABEL_28:
            int v37 = 0;
            goto LABEL_35;
          }
          int v18 = 100;
        }
        else
        {
          switch(service_class)
          {
            case 1048704:
              int v18 = 200;
              break;
            case 1572880:
              int v18 = 300;
              break;
            case 2097184:
              int v18 = 400;
              break;
            default:
              goto LABEL_28;
          }
        }
      }
      else
      {
        if (service_class <= 3670319)
        {
          if (service_class == 2621728)
          {
            int v18 = 500;
            goto LABEL_34;
          }
          if (service_class == 3146000)
          {
            int v18 = 600;
            goto LABEL_34;
          }
          if (service_class != 3670272) {
            goto LABEL_28;
          }
LABEL_27:
          int v18 = 700;
          goto LABEL_34;
        }
        switch(service_class)
        {
          case 3670320:
            goto LABEL_27;
          case 4194688:
            int v18 = 800;
            break;
          case 4718992:
            int v18 = 900;
            break;
          default:
            goto LABEL_28;
        }
      }
LABEL_34:
      int v37 = v18;
LABEL_35:
      v49[0] = 0xAAAAAAAAAAAAAAAALL;
      v49[1] = 0xAAAAAAAAAAAAAAAALL;
      os_packet_get_flow_uuid();
      id v19 = [objc_alloc((Class)NSUUID) initWithUUIDBytes:v49];
      int v20 = +[IDSFoundationLog Multiplexer];
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        if (v17 <= 2621727)
        {
          if (v17 <= 1048703)
          {
            if (!v17)
            {
              uint64_t v21 = "BE";
              goto LABEL_61;
            }
            uint64_t v21 = "BK_SYS";
            if (v17 == 524432)
            {
LABEL_61:
              *(_DWORD *)buf = 138413570;
              *(void *)__int16 v39 = v19;
              *(_WORD *)&v39[8] = 1024;
              unsigned int v40 = v9;
              __int16 v41 = 2048;
              uint64_t v42 = object_address;
              __int16 v43 = 1024;
              unsigned int v44 = data_offset;
              __int16 v45 = 2080;
              id v46 = v21;
              __int16 v47 = 1024;
              int v48 = v37;
              _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "multiplexer outgoing [%@] packetLength %u bufletAddress %p bufletOffset %u serviceClass %s trafficClass %d\n", buf, 0x32u);
              goto LABEL_62;
            }
          }
          else
          {
            switch(v17)
            {
              case 1048704:
                uint64_t v21 = "BK";
                goto LABEL_61;
              case 1572880:
                uint64_t v21 = "RD";
                goto LABEL_61;
              case 2097184:
                uint64_t v21 = "OAM";
                goto LABEL_61;
            }
          }
        }
        else if (v17 > 3670319)
        {
          switch(v17)
          {
            case 3670320:
              uint64_t v21 = "SIG";
              goto LABEL_61;
            case 4194688:
              uint64_t v21 = "VO";
              goto LABEL_61;
            case 4718992:
              uint64_t v21 = "CTL";
              goto LABEL_61;
          }
        }
        else
        {
          switch(v17)
          {
            case 2621728:
              uint64_t v21 = "AV";
              goto LABEL_61;
            case 3146000:
              uint64_t v21 = "RV";
              goto LABEL_61;
            case 3670272:
              uint64_t v21 = "VI";
              goto LABEL_61;
          }
        }
        uint64_t v21 = "UNKNOWN";
        goto LABEL_61;
      }
LABEL_62:

      id v4 = v36;
      (*((void (**)(id, uint64_t))v36 + 2))(v36, v13);
      _IDSLinkPacketBufferRelease();

LABEL_63:
      if (!--v6) {
        goto LABEL_76;
      }
    }
  }
  int v22 = +[IDSFoundationLog Multiplexer];
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v50 = 0;
    __int16 v23 = "readOSChannel - no slots to read";
    int v24 = v22;
    uint32_t v25 = 2;
    goto LABEL_83;
  }
LABEL_84:

LABEL_85:
}

uint64_t sub_100223FFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v6 = os_channel_available_slot_count();
  if (v6)
  {
LABEL_2:
    *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v42 = v7;
    long long v43 = v7;
    *(_OWORD *)buf = v7;
    long long v41 = v7;
    os_channel_get_next_slot();
    if (os_channel_slot_get_packet())
    {
      if (os_packet_get_next_buflet())
      {
        unsigned int data_limit = os_buflet_get_data_limit();
        uint64_t object_address = os_buflet_get_object_address();
        unsigned int data_offset = os_buflet_get_data_offset();
        if (data_limit >= *(_DWORD *)(a3 + 16))
        {
          unsigned int v25 = data_offset;
          kdebug_trace();
          memcpy((void *)(object_address + v25), *(const void **)a3, *(void *)(a3 + 16));
          os_buflet_set_data_length();
          os_packet_set_flow_uuid();
          char v11 = [objc_alloc((Class)NSUUID) initWithUUIDBytes:a4];
          int v26 = +[IDSFoundationLog Multiplexer];
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v27 = *(void *)(a3 + 16);
            int v34 = 138413058;
            *(void *)int v35 = v11;
            *(_WORD *)&v35[8] = 2048;
            *(void *)&v35[10] = v27;
            __int16 v36 = 2048;
            uint64_t v37 = object_address;
            __int16 v38 = 1024;
            unsigned int v39 = v25;
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "multiplexer incoming [%@] packetLength %ld bufletAddress %p bufletOffset %u", (uint8_t *)&v34, 0x26u);
          }

          *(_WORD *)&uint8_t buf[2] = *(void *)(a3 + 16);
          os_channel_set_slot_properties();
          int v28 = os_channel_advance_slot();
          if (v28)
          {
            int v29 = v28;
            int v30 = +[IDSFoundationLog Multiplexer];
            if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
            {
              int v34 = 67109120;
              *(_DWORD *)int v35 = v29;
              _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "os_channel_advance_slot failed for read %d", (uint8_t *)&v34, 8u);
            }
          }
          int v31 = os_channel_sync();
          if (v31)
          {
            int v32 = v31;
            int v33 = +[IDSFoundationLog Multiplexer];
            if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
            {
              int v34 = 67109120;
              *(_DWORD *)int v35 = v32;
              _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "os_channel_sync for TX failed %d", (uint8_t *)&v34, 8u);
            }
          }
          uint64_t v23 = 1;
          goto LABEL_20;
        }
        char v11 = +[IDSFoundationLog Multiplexer];
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v12 = *(void *)(a3 + 16);
          int v34 = 67109376;
          *(_DWORD *)int v35 = data_limit;
          *(_WORD *)&v35[4] = 2048;
          *(void *)&v35[6] = v12;
          uint64_t v13 = "writeOSChannel - buflet size %u insufficeint for data length %ld!";
          uint64_t v14 = v11;
          uint32_t v15 = 18;
LABEL_18:
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v13, (uint8_t *)&v34, v15);
        }
      }
      else
      {
        char v11 = +[IDSFoundationLog Multiplexer];
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v34) = 0;
          uint64_t v13 = "writeOSChannel - have packet but no buflet!";
          uint64_t v14 = v11;
          uint32_t v15 = 2;
          goto LABEL_18;
        }
      }
    }
    else
    {
      char v11 = +[IDSFoundationLog Multiplexer];
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        int v34 = 67109120;
        *(_DWORD *)int v35 = v6;
        uint64_t v13 = "writeOSChannel - have slots %u no packet to read!";
        uint64_t v14 = v11;
        uint32_t v15 = 8;
        goto LABEL_18;
      }
    }
    uint64_t v23 = 0;
LABEL_20:

    return v23;
  }
  int v16 = +[IDSFoundationLog Multiplexer];
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "writeOSChannel - no slots for write, try syncing", buf, 2u);
  }

  int v17 = os_channel_sync();
  if (v17)
  {
    int v18 = v17;
    id v19 = +[IDSFoundationLog Multiplexer];
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v18;
      int v20 = "os_channel_sync for TX failed %d";
      uint64_t v21 = v19;
      uint32_t v22 = 8;
LABEL_12:
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, v20, buf, v22);
    }
  }
  else
  {
    int v6 = os_channel_available_slot_count();
    if (v6) {
      goto LABEL_2;
    }
    id v19 = +[IDSFoundationLog Multiplexer];
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      int v20 = "writeOSChannel - no slots for write, try syncing";
      uint64_t v21 = v19;
      uint32_t v22 = 2;
      goto LABEL_12;
    }
  }

  return 0;
}

uint64_t sub_100224A04(uint64_t a1)
{
  id v1 = objc_alloc_init(*(Class *)(a1 + 32));
  uint64_t v2 = qword_100A4C2B8;
  qword_100A4C2B8 = (uint64_t)v1;

  return _objc_release_x1(v1, v2);
}

void sub_100224BFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100224C1C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 32));
  if ([v3 isEqualToString:@"com.apple.madrid"])
  {
    int v5 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Clearing cache", v6, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    pthread_mutex_lock((pthread_mutex_t *)(WeakRetained + 32));
    [*((id *)WeakRetained + 3) clearCache];
    pthread_mutex_unlock((pthread_mutex_t *)(WeakRetained + 32));
  }
}

NSDictionary *__cdecl sub_100225614(id a1, NSDictionary *a2, NSDictionary *a3)
{
  id v4 = a2;
  int v5 = (NSDictionary *)[(NSDictionary *)a3 mutableCopy];
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  int v6 = v4;
  id v7 = [(NSDictionary *)v6 countByEnumeratingWithState:&v24 objects:v28 count:16];
  if (!v7) {
    goto LABEL_16;
  }
  id v8 = v7;
  uint64_t v23 = *(void *)v25;
  do
  {
    for (uint64_t i = 0; i != v8; uint64_t i = (char *)i + 1)
    {
      if (*(void *)v25 != v23) {
        objc_enumerationMutation(v6);
      }
      uint64_t v10 = *(void *)(*((void *)&v24 + 1) + 8 * i);
      char v11 = [(NSDictionary *)v5 objectForKey:v10];
      if (v11)
      {
        uint64_t v12 = [(NSDictionary *)v6 objectForKey:v10];
        uint64_t v13 = [v11 user];
        uint64_t v14 = [v13 unprefixedIdentifier];
        if (v14)
        {

          goto LABEL_9;
        }
        int v18 = [v12 user];
        id v19 = [v18 unprefixedIdentifier];

        if (v19)
        {
LABEL_12:
          [(NSDictionary *)v5 setObject:v12 forKey:v10];
        }
        else
        {
LABEL_9:
          uint32_t v15 = [v12 user];
          int v16 = [v11 user];
          unsigned int v17 = [v15 shouldReplace:v16];

          if (v17) {
            goto LABEL_12;
          }
        }
      }
    }
    id v8 = [(NSDictionary *)v6 countByEnumeratingWithState:&v24 objects:v28 count:16];
  }
  while (v8);
LABEL_16:

  if (v5) {
    int v20 = v5;
  }
  else {
    int v20 = v6;
  }
  uint64_t v21 = v20;

  return v21;
}

NSMutableDictionary *__cdecl sub_100225818(id a1, NSDictionary *a2, int64_t a3)
{
  id v4 = a2;
  if (a3 == 1)
  {
    id v5 = objc_alloc_init((Class)NSMutableDictionary);
    long long v16 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    int v6 = v4;
    id v7 = [(NSDictionary *)v6 countByEnumeratingWithState:&v16 objects:v24 count:16];
    if (v7)
    {
      id v8 = v7;
      uint64_t v9 = *(void *)v17;
      do
      {
        for (uint64_t i = 0; i != v8; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v17 != v9) {
            objc_enumerationMutation(v6);
          }
          uint64_t v11 = *(void *)(*((void *)&v16 + 1) + 8 * i);
          uint64_t v12 = -[NSDictionary objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", v11, (void)v16);
          uint64_t v13 = [[IDSUserDescription alloc] initWithUser:v12 properties:0];
          [v5 setObject:v13 forKeyedSubscript:v11];
        }
        id v8 = [(NSDictionary *)v6 countByEnumeratingWithState:&v16 objects:v24 count:16];
      }
      while (v8);
    }

    uint64_t v14 = +[IMRGLog registration];
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      uint64_t v21 = v6;
      __int16 v22 = 2112;
      id v23 = v5;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Migrating user store to new format {oldMap: %@, newMap: %@}", buf, 0x16u);
    }
  }
  else
  {
    id v5 = 0;
  }

  return (NSMutableDictionary *)v5;
}

id sub_100225C7C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 user];
  if ([v4 realm] == *(id *)(a1 + 32))
  {
    id v5 = [v3 user];
  }
  else
  {
    id v5 = 0;
  }

  return v5;
}

id sub_100225DCC(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = *(void **)(a1 + 32);
  id v5 = [v3 user];
  int v6 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [v5 realm]);
  if ([v4 containsObject:v6])
  {
    id v7 = [v3 user];
  }
  else
  {
    id v7 = 0;
  }

  return v7;
}

id sub_10022642C(uint64_t a1, void *a2)
{
  return _[a2 userStore:*(void *)(a1 + 32) didUpdateUser:*(void *)(a1 + 40)];
}

id sub_1002269EC(uint64_t a1, void *a2)
{
  return _[a2 userStore:*(void *)(a1 + 32) didAddUser:*(void *)(a1 + 40)];
}

id sub_100226BD0(void *a1, void *a2)
{
  return _[a2 userStore:a1[4] didRemoveUser:a1[5] withAuthenticationCertificate:a1[6]];
}

id sub_100227138(uint64_t a1, void *a2)
{
  return _[a2 userStore:*(void *)(a1 + 32) didRemoveAuthenticationCertificateForUser:*(void *)(a1 + 40)];
}

id sub_100227144(void *a1, void *a2)
{
  return _[a2 userStore:a1[4] didAddAuthenticationCertificate:a1[5] forUser:a1[6]];
}

id sub_100227510(uint64_t a1, void *a2)
{
  return _[a2 userStore:*(void *)(a1 + 32) didUpdateUser:*(void *)(a1 + 40)];
}

void sub_1002287B8(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) stateManager];
  [v2 ackUpdatesForActivity:*(void *)(a1 + 40)];
}

void sub_10022BCEC(id a1)
{
  id v1 = objc_alloc_init(IDSRegistrationKeychainManager);
  uint64_t v2 = qword_100A4C2D0;
  qword_100A4C2D0 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_10022BF10(_Unwind_Exception *a1)
{
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v3 - 72));
  _Unwind_Resume(a1);
}

void sub_10022BF3C(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained[5] invalidate];
  id v1 = WeakRetained[5];
  WeakRetained[5] = 0;
}

void sub_10022BF90(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v2 = (void *)WeakRetained[5];
  if (v2)
  {
    [v2 setFireTimeInterval:120.0];
  }
  else
  {
    id v3 = objc_alloc((Class)IMTimer);
    uint64_t v4 = *(void *)(a1 + 32);
    id v5 = im_primary_queue();
    id v6 = [v3 initWithTimeInterval:@"com.apple.identityservices.keychain-manager" name:0 shouldWake:v4 target:"_flush" selector:0 userInfo:v5 queue:120.0];
    id v7 = (void *)WeakRetained[5];
    WeakRetained[5] = v6;
  }
}

id sub_10022C14C(uint64_t a1)
{
  return [*(id *)(a1 + 32) _flush];
}

void sub_10022CDF0(uint64_t a1)
{
  uint64_t v2 = +[IMRGLog keychainManager];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v3 = [*(id *)(a1 + 32) length];
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v5 = *(void *)(a1 + 48);
    uint64_t v6 = *(void *)(a1 + 56);
    int v7 = *(_DWORD *)(a1 + 64);
    *(_DWORD *)buf = 67110146;
    unsigned int v21 = v3;
    __int16 v22 = 2112;
    uint64_t v23 = v4;
    __int16 v24 = 2112;
    uint64_t v25 = v5;
    __int16 v26 = 2112;
    uint64_t v27 = v6;
    __int16 v28 = 1024;
    int v29 = v7;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Saving %d bytes under service: %@   account: %@   accessGroup: %@   saveIdentifier: %d", buf, 0x2Cu);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    id v8 = [*(id *)(a1 + 32) length];
    uint64_t v17 = *(void *)(a1 + 56);
    uint64_t v18 = *(unsigned int *)(a1 + 64);
    long long v16 = *(_OWORD *)(a1 + 40);
    id v14 = v8;
    MarcoLogRegistration();
  }
  unsigned int v19 = 0;
  uint64_t v9 = +[IDSDependencyProvider keychainAdapter];
  unsigned __int8 v10 = [v9 setKeychainData:*(void *)(a1 + 32) service:*(void *)(a1 + 40) account:*(void *)(a1 + 48) accessGroup:*(void *)(a1 + 56) allowSync:0 error:&v19];

  if ((v10 & 1) == 0)
  {
    uint64_t v11 = +[IMRGLog keychainManager];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      unsigned int v21 = v19;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Unable to save registrations to keychain (error: %d)", buf, 8u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      uint64_t v15 = v19;
      MarcoLogRegistration();
    }
  }
  uint64_t v12 = +[IMRGLog keychainManager];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "** Saving registration data to keychain: Done **", buf, 2u);
  }

  if (os_log_shim_legacy_logging_enabled()) {
    MarcoLogRegistration();
  }
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterPostNotificationWithOptions(DarwinNotifyCenter, IDSRegistrationKeychainChangedNotification, 0, 0, 0);
}

id sub_10022D134(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "__saveToKeychain");
}

id sub_10022E368(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1 || ![v1 count])
  {
    id v9 = 0;
    goto LABEL_39;
  }
  id v3 = v2;
  uint64_t v4 = [v3 objectForKey:@"version"];
  unint64_t v5 = (unint64_t)[v4 unsignedIntegerValue];
  unint64_t v6 = IDSKeychainBlobCurrentVersion;
  int v7 = +[IMRGLog keychainManager];
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  if (v5 <= v6)
  {
    if (v8)
    {
      *(_DWORD *)buf = 67109120;
      LODWORD(v19[0]) = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Updating keychain dict to current version (%d)", buf, 8u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      unint64_t v16 = v6;
      MarcoLogRegistration();
    }
    unsigned __int8 v10 = +[IMRGLog keychainManager];
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v19[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Keychain dictionary before upgrade : %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      id v17 = v3;
      MarcoLogRegistration();
    }
    if (v5 >= v6)
    {
LABEL_33:
      id v14 = +[IMRGLog keychainManager];
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v19[0] = v3;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Keychain dictionary after upgrade : %@", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled()) {
        MarcoLogRegistration();
      }
      id v9 = v3;
      id v3 = v9;
      goto LABEL_38;
    }
    while (v5 != 1)
    {
      if (!v5)
      {
        uint64_t v11 = +[IMRGLog keychainManager];
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "  => Updating from V0 to V1", buf, 2u);
        }

        if (os_log_shim_legacy_logging_enabled()) {
          MarcoLogRegistration();
        }
        uint64_t v12 = sub_10022EF10(v3);
        unint64_t v5 = 1;
LABEL_31:

        id v3 = (id)v12;
      }
      if (v5 >= v6) {
        goto LABEL_33;
      }
    }
    uint64_t v13 = +[IMRGLog keychainManager];
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "  => Updating from V1 to V2", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled()) {
      MarcoLogRegistration();
    }
    uint64_t v12 = sub_10022F268(v3);
    unint64_t v5 = 2;
    goto LABEL_31;
  }
  if (v8)
  {
    *(_DWORD *)buf = 67109376;
    LODWORD(v19[0]) = v5;
    WORD2(v19[0]) = 1024;
    *(_DWORD *)((char *)v19 + 6) = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Invalid keychain dict version (%d) -- current is %d", buf, 0xEu);
  }

  if (os_log_shim_legacy_logging_enabled()) {
    MarcoLogRegistration();
  }
  id v9 = 0;
LABEL_38:

LABEL_39:

  return v9;
}

id sub_10022EF10(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1 && [v1 count])
  {
    id v3 = +[NSMutableDictionary dictionary];
    uint64_t v4 = (__CFDictionary *)[v2 mutableCopy];
    unint64_t v5 = (__CFDictionary *)[v2 mutableCopy];
    unint64_t v6 = [v2 objectForKey:@"type"];
    unsigned int v7 = [v6 intValue];

    if (v7)
    {
      if (v7 != 1)
      {
LABEL_24:
        CFDictionarySetValue(v4, @"migrated-v0-dictionary", v2);
        CFDictionarySetValue(v5, @"migrated-v0-dictionary", v2);
        uint64_t v15 = _StringForIDSRegistrationServiceType();
        [(__CFDictionary *)v4 setObject:v15 forKey:@"service"];

        unint64_t v16 = _StringForIDSRegistrationServiceType();
        [(__CFDictionary *)v5 setObject:v16 forKey:@"service"];

        id v17 = +[NSNumber numberWithUnsignedInteger:1];
        [v3 setObject:v17 forKey:@"version"];

        uint64_t v18 = +[NSArray arrayWithObjects:](NSArray, "arrayWithObjects:", v4, v5, 0);
        [v3 setObject:v18 forKey:@"data"];

        goto LABEL_25;
      }
      BOOL v8 = [v2 objectForKey:@"phone-number"];
      if (v8) {
        CFDictionarySetValue(v4, @"main-id", v8);
      }

      id v9 = [v2 objectForKey:@"phone-number"];
      if (v9) {
        CFDictionarySetValue(v5, @"main-id", v9);
      }

      unsigned __int8 v10 = [v2 objectForKey:@"user-id"];
      if (v10) {
        CFDictionarySetValue(v4, @"profile-id", v10);
      }

      uint64_t v11 = [v2 objectForKey:@"user-id"];
      if (!v11)
      {
LABEL_23:

        goto LABEL_24;
      }
      CFStringRef v12 = @"profile-id";
    }
    else
    {
      id v14 = [v2 objectForKey:@"phone-number"];
      if (v14) {
        CFDictionarySetValue(v4, @"main-id", v14);
      }

      uint64_t v11 = [v2 objectForKey:@"phone-number"];
      if (!v11) {
        goto LABEL_23;
      }
      CFStringRef v12 = @"main-id";
    }
    CFDictionarySetValue(v5, v12, v11);
    goto LABEL_23;
  }
  uint64_t v13 = +[IMRGLog keychainManager];
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Unable to upgrade an empty keychain data from V0 to V1", buf, 2u);
  }

  if (os_log_shim_legacy_logging_enabled()) {
    MarcoLogRegistration();
  }
  id v3 = 0;
LABEL_25:

  return v3;
}

id sub_10022F268(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1 && [v1 count])
  {
    id v3 = [v2 objectForKey:@"sms-signatures"];
    id v4 = [v3 mutableCopy];

    unint64_t v5 = [v4 objectForKey:@"phone-number-registration-main-id"];
    unint64_t v6 = [v4 objectForKey:@"phone-number-registration"];
    [v4 removeAllObjects];
    id v7 = [v5 length];
    id v8 = [v6 length];
    if (v7 && v8) {
      [v4 setObject:v6 forKey:v5];
    }
    id v9 = [v2 mutableCopy];
    unsigned __int8 v10 = v9;
    if (v4) {
      uint64_t v11 = v4;
    }
    else {
      uint64_t v11 = &__NSDictionary0__struct;
    }
    [v9 setObject:v11 forKey:@"sms-signatures"];
    id v12 = [v10 copy];
  }
  else
  {
    uint64_t v13 = +[IMRGLog keychainManager];
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v15 = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Unable to upgrade an empty keychain data from V1 to V2", v15, 2u);
    }

    if (os_log_shim_legacy_logging_enabled()) {
      MarcoLogRegistration();
    }
    id v12 = 0;
  }

  return v12;
}

void sub_100230028(id a1)
{
  id v1 = objc_alloc_init(IDSDaemonCapabilities);
  uint64_t v2 = qword_100A4C2E8;
  qword_100A4C2E8 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

id sub_1002302FC(void *a1, id a2)
{
  id v3 = a1;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  id v4 = +[IDSCTAdapter sharedInstance];
  uint64_t v5 = objc_opt_class();
  unint64_t v6 = +[NSNumber numberWithBool:a2];
  id v7 = [v4 carrierBundleValueFromAllSIMsForKey:v3 ofType:v5 withFallback:v6];

  id v8 = [v7 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v14;
    LOBYTE(a2) = 1;
    do
    {
      uint64_t v11 = 0;
      do
      {
        if (*(void *)v14 != v10) {
          objc_enumerationMutation(v7);
        }
        if (a2) {
          a2 = [*(id *)(*((void *)&v13 + 1) + 8 * (void)v11) BOOLValue];
        }
        else {
          a2 = 0;
        }
        uint64_t v11 = (char *)v11 + 1;
      }
      while (v9 != v11);
      id v9 = [v7 countByEnumeratingWithState:&v13 objects:v17 count:16];
    }
    while (v9);
  }

  return a2;
}

id sub_10023054C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = +[IMRGLog registration];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 138412546;
    uint64_t v9 = a2;
    __int16 v10 = 2112;
    uint64_t v11 = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Daemon MG capabilities changed: %@  (%@)", (uint8_t *)&v8, 0x16u);
  }

  return [*(id *)(a1 + 32) _deferredUpdateCapabilities];
}

id sub_100230788(uint64_t a1)
{
  return [*(id *)(a1 + 32) _updateCapabilities];
}

uint64_t sub_100230850(uint64_t a1)
{
  id v1 = objc_alloc_init(*(Class *)(a1 + 32));
  uint64_t v2 = qword_100A4C2F0;
  qword_100A4C2F0 = (uint64_t)v1;

  return _objc_release_x1(v1, v2);
}

void sub_100230AEC(id a1)
{
  id v1 = objc_alloc_init(IDSRegistrationCenter);
  uint64_t v2 = qword_100A4C308;
  qword_100A4C308 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

id sub_100230F4C(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(*(id *)(a1 + 32), "__sendMessage:", a2);
}

void sub_100230F58(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 setTimeout:36000.0];
  objc_msgSend(*(id *)(a1 + 32), "__sendMessage:", v3);
}

id sub_100230FB4(uint64_t a1)
{
  uint64_t v2 = +[IMRGLog registration];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Processed getDependent queue", v4, 2u);
  }

  return [*(id *)(a1 + 32) _dequeuePendingRequestsIfNecessary];
}

void sub_100231030(id a1, IDSRegistrationCenter *a2)
{
}

void sub_100231038(id a1, IDSRegistrationCenter *a2)
{
}

void sub_100231040(id a1, IDSRegistrationCenter *a2)
{
}

void sub_100231048(id a1, IDSRegistrationCenter *a2)
{
  uint64_t v2 = a2;
  id v3 = +[IMRGLog registration];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "  Absinthe cleanup timer hit!", buf, 2u);
  }

  if ([(IDSRegistrationCenter *)v2 _hasCurrentAuthenticationsOrRegistrations])
  {
    id v4 = +[IMRGLog registration];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "We have current authentications or registrations -- not cleaning up Absinthe validation info yet", v5, 2u);
    }
  }
  else
  {
    [(IDSValidationQueue *)v2->_validationQueue cleanupValidationInfoForSubsystemMechanism:1];
    [(IDSRegistrationCenter *)v2 __dumpState];
  }
}

void sub_100231498()
{
}

id sub_100231FDC(uint64_t a1)
{
  return [*(id *)(a1 + 32) _dequeuePendingRequestsIfNecessary];
}

void sub_100231FE4(uint64_t a1)
{
  *(unsigned char *)(*(void *)(a1 + 32) + 4_Block_object_dispose(&STACK[0x300], 8) = 0;
  uint64_t v2 = [*(id *)(*(void *)(a1 + 32) + 16) lastObject];
  if (v2)
  {
    id v3 = [*(id *)(*(void *)(a1 + 32) + 24) count];
    id v4 = +[IMRGLog registration];
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (v3)
    {
      if (v5)
      {
        unint64_t v6 = *(void **)(*(void *)(a1 + 32) + 24);
        *(_DWORD *)buf = 138412290;
        unsigned int v21 = v6;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, " ** Not sending, we have current authentications in flight, %@", buf, 0xCu);
      }

      objc_msgSend(*(id *)(a1 + 32), "__dumpState");
    }
    else
    {
      if (v5)
      {
        *(_DWORD *)buf = 138412290;
        unsigned int v21 = v2;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, " Sending pending authentication: %@", buf, 0xCu);
      }

      [*(id *)(a1 + 32) _sendAuthenticateRegistration:v2];
    }
  }
  else
  {
    id v7 = +[IMRGLog registration];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, " No pending authentication", buf, 2u);
    }
  }
  int v8 = [*(id *)(*(void *)(a1 + 32) + 8) lastObject];
  if (v8)
  {
    if ([*(id *)(*(void *)(a1 + 32) + 32) count])
    {
      uint64_t v9 = +[IMRGLog registration];
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v10 = *(void **)(*(void *)(a1 + 32) + 32);
        *(_DWORD *)buf = 138412290;
        unsigned int v21 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " ** Not sending, we have current registrations in flight, %@", buf, 0xCu);
      }

      objc_msgSend(*(id *)(a1 + 32), "__dumpState");
    }
    else
    {
      unsigned int v12 = [v8 canSendRegistration];
      long long v13 = +[IMRGLog registration];
      BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
      if (v12)
      {
        if (v14)
        {
          *(_DWORD *)buf = 138412290;
          unsigned int v21 = v8;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, " Sending pending registration: %@", buf, 0xCu);
        }

        [*(id *)(a1 + 32) sendRegistration:v8];
      }
      else
      {
        if (v14)
        {
          *(_DWORD *)buf = 138412290;
          unsigned int v21 = v8;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, " Removing pending registration, can't register: %@", buf, 0xCu);
        }

        [*(id *)(*(void *)(a1 + 32) + 8) removeObjectIdenticalTo:v8];
        if ([*(id *)(*(void *)(a1 + 32) + 8) count]) {
          im_dispatch_after_primary_queue();
        }
      }
    }
  }
  else
  {
    uint64_t v11 = +[IMRGLog registration];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " No pending registration", buf, 2u);
    }
  }
  long long v15 = *(unsigned char **)(a1 + 32);
  if (v15[49])
  {
    long long v16 = +[IMRGLog registration];
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, " Sending pending deregistration...", buf, 2u);
    }

    [*(id *)(a1 + 32) _sendRegistrationAsDeregister:1];
    long long v15 = *(unsigned char **)(a1 + 32);
  }
  unsigned int v17 = [v15 _hasCurrentAuthenticationsOrRegistrations];
  uint64_t v18 = +[IMRGLog registration];
  BOOL v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
  if (v17)
  {
    if (v19)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "We have current authentications or registrations -- canceling pending Absinthe cleanup operations", buf, 2u);
    }

    [*(id *)(*(void *)(a1 + 32) + 176) cancelPendingExecutions];
  }
  else
  {
    if (v19)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "We have no current authentications or registrations -- enqueueing Absinthe cleanup operation", buf, 2u);
    }

    objc_msgSend(*(id *)(*(void *)(a1 + 32) + 176), "enqueueExecutionWithTarget:afterDelay:", 30.0);
  }
  objc_msgSend(*(id *)(a1 + 32), "__dumpState");
}

id sub_100232498(uint64_t a1)
{
  return [*(id *)(a1 + 32) _dequeuePendingRequestsIfNecessary];
}

void sub_100232C08()
{
}

void sub_100232C58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,os_activity_scope_state_s state,char a29)
{
}

void sub_100232C70(uint64_t a1, int a2)
{
  if (!a2) {
    sub_100232C74();
  }
  objc_terminate();
}

void sub_100233164()
{
}

void sub_1002331AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,os_activity_scope_state_s state,char a25)
{
}

void sub_1002331C4(uint64_t a1, int a2)
{
  if (!a2) {
    sub_1002331C8();
  }
  objc_terminate();
}

void sub_100233AF8()
{
}

void sub_100233B58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,os_activity_scope_state_s state,char a45)
{
}

void sub_100233B70(uint64_t a1, int a2)
{
  if (!a2) {
    sub_100233B74();
  }
  objc_terminate();
}

void sub_100233B84(void *a1, uint64_t a2)
{
  switch(a2)
  {
    case 4:
      id v4 = +[IDSFoundationLog KeyTransparency];
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Need to refresh KT Account key, and CDP is ready.", buf, 2u);
      }

      BOOL v5 = +[IDSServerBag sharedInstance];
      unint64_t v6 = [v5 objectForKey:@"kt-rereg-after-ak-refresh-with-cdp-ready"];

      if (v6 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      {
        unsigned int v7 = [v6 BOOLValue];

        if (!v7) {
          goto LABEL_21;
        }
      }
      else
      {
      }
      [*(id *)(a1[4] + 136) registrationDataNeedsUpdate];
LABEL_21:
      uint64_t v9 = 49;
      goto LABEL_22;
    case 3:
      int v8 = +[IDSFoundationLog KeyTransparency];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Need to refresh KT Account key, but CDP is syncing.", buf, 2u);
      }

      goto LABEL_21;
    case 2:
      id v3 = +[IDSFoundationLog KeyTransparency];
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Need to refresh KT Account key, but we're waiting for user.", buf, 2u);
      }
      break;
    default:
      id v3 = +[IDSFoundationLog KeyTransparency];
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Need to refresh KT Account key, but we're confused.", buf, 2u);
      }
      break;
  }

  uint64_t v9 = 48;
LABEL_22:
  id v10 = [*(id *)(a1[4] + 40) _copyForEnumerating];
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  id v11 = v10;
  id v12 = [v11 countByEnumeratingWithState:&v16 objects:v21 count:16];
  if (v12)
  {
    uint64_t v13 = *(void *)v17;
    do
    {
      for (uint64_t i = 0; i != v12; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v17 != v13) {
          objc_enumerationMutation(v11);
        }
        long long v15 = *(void **)(*((void *)&v16 + 1) + 8 * i);
        if (objc_opt_respondsToSelector()) {
          [v15 center:a1[4] failedRegistration:a1[5] error:v9 info:a1[6]];
        }
      }
      id v12 = [v11 countByEnumeratingWithState:&v16 objects:v21 count:16];
    }
    while (v12);
  }
}

void sub_100233EE0()
{
}

void sub_1002343F8()
{
}

void sub_100234440(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,os_activity_scope_state_s state,char a25)
{
}

void sub_100234458(uint64_t a1, int a2)
{
  if (!a2) {
    sub_10023445C();
  }
  objc_terminate();
}

void sub_10023465C()
{
}

void sub_100234BBC()
{
}

void sub_100234EB4()
{
}

void sub_10023509C(_Unwind_Exception *a1)
{
}

void sub_100239308()
{
}

void sub_1002395DC(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x1002395E0);
  }
  objc_terminate();
}

void sub_100239638(id a1)
{
  id v1 = +[IMLockdownManager sharedInstance];
  unsigned int v2 = [v1 isInternalInstall];

  if (v2)
  {
    byte_100A4C310 = IMGetDomainBoolForKey();
    byte_100A4C311 = IMGetDomainBoolForKey();
  }
}

void sub_1002396B0(void *a1)
{
  id v1 = a1;
  unsigned int v2 = +[IMLockdownManager sharedInstance];
  if ([v2 isInternalInstall])
  {
    int v3 = IMGetCachedDomainBoolForKey();

    if (v3)
    {
      id v4 = +[IMRGLog sms];
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Suppressing registration server alert due to presence of internal default", buf, 2u);
      }
      goto LABEL_17;
    }
  }
  else
  {
  }
  id v4 = [v1 objectForKey:kIDSRegistrationFailedAlertTitleKey];
  BOOL v5 = [v1 objectForKey:kIDSRegistrationFailedAlertButtonKey];
  unint64_t v6 = [v1 objectForKey:kIDSRegistrationFailedAlertMessageKey];
  unsigned int v7 = [v1 objectForKey:kIDSRegistrationFailedActionInfoKey];
  int v8 = [v7 objectForKey:kIDSRegistrationFailedActionButtonKey];
  uint64_t v9 = [v7 objectForKey:kIDSRegistrationFailedActionURLKey];
  if (v4) {
    BOOL v10 = 0;
  }
  else {
    BOOL v10 = v6 == 0;
  }
  if (!v10 || v5 != 0)
  {
    id v12 = +[IMUserNotification userNotificationWithIdentifier:@"ServerAlerts" title:v4 message:v6 defaultButton:v8 alternateButton:0 otherButton:v5];
    if (v12)
    {
      uint64_t v13 = +[IMUserNotificationCenter sharedInstance];
      v14[0] = _NSConcreteStackBlock;
      v14[1] = 3221225472;
      void v14[2] = sub_100247E8C;
      v14[3] = &unk_100986E10;
      id v15 = v9;
      [v13 addUserNotification:v12 listener:0 completionHandler:v14];
    }
  }

LABEL_17:
}

void sub_100239910(id a1, NSError *a2)
{
  unsigned int v2 = a2;
  int v3 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    BOOL v5 = v2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Reported to transparency of bad account key. { error: %@ }", (uint8_t *)&v4, 0xCu);
  }
}

uint64_t sub_1002399C4()
{
  uint64_t v0 = +[IDSServerBag sharedInstance];
  id v1 = [v0 objectForKey:@"ids-allow-empty-uri-registration"];

  if (v1 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    uint64_t v2 = (uint64_t)[v1 BOOLValue];
  }
  else {
    uint64_t v2 = 1;
  }

  return v2;
}

id sub_100239B84(id a1, id a2)
{
  id v2 = a2;
  id v3 = [objc_alloc((Class)IDSURI) initWithPrefixedURI:v2];

  return v3;
}

id sub_100239BDC(id a1, id a2)
{
  id v2 = a2;
  if ([v2 isEqualToIgnoringCase:kIDSServiceDefaultsSentinelAlias]) {
    id v3 = 0;
  }
  else {
    id v3 = [objc_alloc((Class)IDSURI) initWithPrefixedURI:v2];
  }

  return v3;
}

id sub_10023A010(uint64_t a1, void *a2)
{
  id v3 = [a2 serviceType];
  id v4 = [v3 isEqualToString:*(void *)(a1 + 32)];

  return v4;
}

id sub_10023A054(id a1, IDSURI *a2)
{
  return [(IDSURI *)a2 prefixedURI];
}

void sub_10023ADAC(_Unwind_Exception *a1)
{
  os_activity_scope_leave((os_activity_scope_state_t)(v1 - 152));
  cut_arc_os_release();
  _Unwind_Resume(a1);
}

id sub_10023AE18(uint64_t a1)
{
  return [*(id *)(a1 + 32) _dequeuePendingRequestsIfNecessary];
}

id sub_10023AE20(uint64_t a1)
{
  return [*(id *)(a1 + 32) _dequeuePendingRequestsIfNecessary];
}

id sub_10023AE28(uint64_t a1)
{
  return [*(id *)(a1 + 32) _dequeuePendingRequestsIfNecessary];
}

void sub_10023AE30(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 state];
  uint64_t v258 = a1;
  if (v4 == (id)1)
  {
    v220 = [v3 error];
    [(__CFString *)v220 code];
    long long v263 = 0u;
    long long v264 = 0u;
    long long v265 = 0u;
    long long v266 = 0u;
    id v245 = *(id *)(a1 + 40);
    id v174 = [v245 countByEnumeratingWithState:&v263 objects:v313 count:16];
    if (v174)
    {
      id v175 = v174;
      uint64_t v176 = *(void *)v264;
      do
      {
        for (uint64_t i = 0; i != v175; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v264 != v176) {
            objc_enumerationMutation(v245);
          }
          v178 = *(const char **)(*((void *)&v263 + 1) + 8 * i);
          v179 = +[IMRGLog registration];
          if (os_log_type_enabled(v179, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 138412546;
            CFStringRef v316 = v220;
            __int16 v317 = 2112;
            v318 = v178;
            _os_log_fault_impl((void *)&_mh_execute_header, v179, OS_LOG_TYPE_FAULT, "Registration failed getting client data -- error %@ registration %@", buf, 0x16u);
          }

          [*(id *)(*(void *)(a1 + 32) + 8) removeObject:v178];
          [*(id *)(*(void *)(a1 + 32) + 32) removeObject:v178];
          [*(id *)(a1 + 32) _notifyRegistrationFailure:v178 responseCode:1 registrationError:40 error:0 info:0];
        }
        id v175 = [v245 countByEnumeratingWithState:&v263 objects:v313 count:16];
      }
      while (v175);
    }
LABEL_235:
  }
  else if (!v4)
  {
    id v215 = v3;
    BOOL v5 = [v3 value];
    id v245 = [(__CFString *)v5 clientDatasByServiceType];
    v220 = v5;
    v223 = [(__CFString *)v5 ktRegDataByServiceType];
    unint64_t v6 = (id *)IMRGLog_ptr;
    unsigned int v7 = +[IMRGLog registration];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = [v245 allKeys];
      *(_DWORD *)buf = 138412290;
      CFStringRef v316 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Done constructing client data objects {serviceTypes: %@}", buf, 0xCu);
    }
    uint64_t v9 = +[IDSKeyTransparencyVerifier sharedInstance];
    BOOL v10 = [v9 fetchKTEligibleServices];
    id v11 = [v10 containsObject:@"com.apple.madrid"];

    id v12 = +[IDSRegistrationKeyManager sharedInstance];
    [v12 updateKVSForKTRegistrationData];

    uint64_t v13 = +[FTDeviceSupport sharedInstance];
    v219 = [v13 model];

    BOOL v14 = +[FTDeviceSupport sharedInstance];
    v218 = [v14 productOSVersion];

    id v15 = +[FTDeviceSupport sharedInstance];
    v217 = [v15 productBuildVersion];

    long long v16 = +[FTDeviceSupport sharedInstance];
    long long v17 = [v16 deviceName];

    v224 = v17;
    long long v18 = [v17 stringByReplacingOccurrencesOfString:@"&" withString:@"&amp;amp;"];
    long long v19 = [v18 stringByReplacingOccurrencesOfString:@"\"" withString:@"&amp;quot;"];
    int v20 = [v19 stringByReplacingOccurrencesOfString:@"'" withString:@"&amp;#39;"];
    unsigned int v21 = [v20 stringByReplacingOccurrencesOfString:@">" withString:@"&amp;gt;"];
    id v22 = [v21 stringByReplacingOccurrencesOfString:@"<" withString:@"&amp;lt;"];

    v216 = [*(id *)(a1 + 32) privateDeviceDataForKVSSuccess:v11];
    v226 = (__CFString *)objc_alloc_init((Class)NSMutableDictionary);
    *(unsigned char *)(*(void *)(a1 + 32) + 49) = 0;
    uint64_t v23 = +[IDSRegistrationController sharedInstance];
    __int16 v24 = [v23 activeRegistrations];

    long long v312 = 0u;
    long long v311 = 0u;
    long long v310 = 0u;
    long long v309 = 0u;
    id v25 = v24;
    id v26 = [v25 countByEnumeratingWithState:&v309 objects:v325 count:16];
    if (v26)
    {
      id v27 = v26;
      uint64_t v28 = *(void *)v310;
      do
      {
        for (j = 0; j != v27; j = (char *)j + 1)
        {
          if (*(void *)v310 != v28) {
            objc_enumerationMutation(v25);
          }
          int v30 = *(__CFString **)(*((void *)&v309 + 1) + 8 * (void)j);
          if (([(__CFString *)v30 canSendRegistration] & 1) == 0)
          {
            int v31 = +[IMRGLog registration];
            if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 138412290;
              CFStringRef v316 = v30;
              _os_log_debug_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEBUG, "   *** Removing registration (from active) from queued/current, it is not possible to register: %@", buf, 0xCu);
            }

            [*(id *)(*(void *)(a1 + 32) + 32) removeObject:v30];
            [*(id *)(*(void *)(a1 + 32) + 8) removeObject:v30];
          }
        }
        id v27 = [v25 countByEnumeratingWithState:&v309 objects:v325 count:16];
      }
      while (v27);
    }
    v214 = v25;

    long long v307 = 0u;
    long long v308 = 0u;
    long long v305 = 0u;
    long long v306 = 0u;
    id v32 = [*(id *)(*(void *)(a1 + 32) + 8) _copyForEnumerating];
    id v33 = [v32 countByEnumeratingWithState:&v305 objects:v324 count:16];
    if (v33)
    {
      id v34 = v33;
      uint64_t v35 = *(void *)v306;
      do
      {
        for (k = 0; k != v34; k = (char *)k + 1)
        {
          if (*(void *)v306 != v35) {
            objc_enumerationMutation(v32);
          }
          uint64_t v37 = *(__CFString **)(*((void *)&v305 + 1) + 8 * (void)k);
          if (([(__CFString *)v37 canSendRegistration] & 1) == 0)
          {
            __int16 v38 = +[IMRGLog registration];
            if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 138412290;
              CFStringRef v316 = v37;
              _os_log_debug_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEBUG, "   *** Removing registration (from queued) from queued/current, it is not possible to register: %@", buf, 0xCu);
            }

            [*(id *)(*(void *)(a1 + 32) + 32) removeObject:v37];
            [*(id *)(*(void *)(a1 + 32) + 8) removeObject:v37];
          }
        }
        id v34 = [v32 countByEnumeratingWithState:&v305 objects:v324 count:16];
      }
      while (v34);
    }

    id v221 = objc_alloc_init((Class)NSMutableArray);
    long long v301 = 0u;
    long long v302 = 0u;
    long long v303 = 0u;
    long long v304 = 0u;
    id obj = *(id *)(a1 + 40);
    id v39 = [obj countByEnumeratingWithState:&v301 objects:v323 count:16];
    if (!v39)
    {
      char v259 = 0;
      char v41 = 0;
      goto LABEL_212;
    }
    id v40 = v39;
    char v259 = 0;
    char v41 = 0;
    uint64_t v42 = *(void *)v302;
    uint64_t v222 = *(void *)v302;
    while (1)
    {
      long long v43 = 0;
      id v225 = v40;
      do
      {
        if (*(void *)v302 != v42) {
          objc_enumerationMutation(obj);
        }
        unsigned int v44 = *(__CFString **)(*((void *)&v301 + 1) + 8 * (void)v43);
        uint64_t v45 = [(__CFString *)v44 authenticationCert];
        if (!v45
          || (id v46 = (void *)v45,
              [(__CFString *)v44 idsUserID],
              __int16 v47 = objc_claimAutoreleasedReturnValue(),
              v47,
              v46,
              !v47))
        {
          unsigned int v49 = [*v6 registration];
          if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412290;
            CFStringRef v316 = v44;
            _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "   => Skipping, we have no auth user ID or cert: %@", buf, 0xCu);
          }

          [*(id *)(*(void *)(a1 + 32) + 32) removeObject:v44];
          [*(id *)(*(void *)(a1 + 32) + 8) removeObject:v44];
          goto LABEL_198;
        }
        if (![(__CFString *)v44 registrationType])
        {
          int v48 = +[IDSCTAdapter sharedInstance];
          if ([v48 isAnySIMInserted])
          {
          }
          else
          {
            id v50 = +[IMMobileNetworkManager sharedInstance];
            unsigned int v51 = [v50 requiresSIMInserted];

            if (v51)
            {
              long long v52 = [*v6 registration];
              if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 138412290;
                CFStringRef v316 = v44;
                _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "   => Skipping, we have no sim present, and we require it: %@", buf, 0xCu);
              }

              [*(id *)(*(void *)(a1 + 32) + 32) removeObject:v44];
              [*(id *)(*(void *)(a1 + 32) + 8) removeObject:v44];
              id v40 = v225;
              goto LABEL_198;
            }
          }
        }
        long long v53 = [(__CFString *)v44 serviceType];
        uint64_t v54 = sub_100148844(v53);

        v246 = (void *)v54;
        id v55 = [(__CFString *)v226 objectForKey:v54];
        uint64_t v56 = [(__CFString *)v44 serviceType];
        id value = [v245 objectForKeyedSubscript:v56];

        id v57 = [(__CFString *)v44 serviceType];
        uint64_t v58 = [v223 objectForKeyedSubscript:v57];

        uint64_t v237 = [v58 ktDataForRegistration];
        uint64_t v59 = [v58 ktPublicAccountKey];
        id v60 = [v58 ktAccountKeyTimestamp];
        v240 = v60;
        uint64_t v61 = a1;
        if (v60)
        {
          [v60 timeIntervalSince1970];
          unint64_t v63 = +[NSString stringWithFormat:@"%llu", (unint64_t)v62];
        }
        else
        {
          unint64_t v63 = 0;
        }
        long long v64 = v6;
        long long v65 = [v58 ktOptInTimestamp];
        v239 = v65;
        if (v65)
        {
          [v65 timeIntervalSince1970];
          id v67 = +[NSString stringWithFormat:@"%llu", (unint64_t)v66];
        }
        else
        {
          id v67 = 0;
        }
        id v68 = [v58 ktOptInStatus];
        long long v69 = @"true";
        if (v68 != (id)1) {
          long long v69 = 0;
        }
        v231 = v69;
        v233 = v67;
        id v255 = 0;
        id v235 = v68;
        if (!v67 && v68 != (id)1)
        {
          id v255 = [v58 ktOptInErrorCode];
        }
        id v249 = (id)v63;
        unint64_t v70 = v63 | v59;
        [(__CFString *)v44 setDidRegisterWithKTAccountKey:v70 != 0];
        long long v71 = [v58 ktDataSignature];

        [(__CFString *)v44 setDidRegisterWithDeviceSignature:v71 != 0];
        long long v72 = v64;
        if (v70)
        {
          id v230 = 0;
        }
        else
        {
          id v230 = [v58 ktAccountKeyErrorCode];
        }
        uint64_t v73 = v61;
        long long v74 = [(__CFString *)v44 serviceType];
        int v75 = IDSIsFaceTimeRegistrationServiceType();

        v241 = v58;
        if (v75
          || ([(__CFString *)v44 serviceType],
              long long v76 = objc_claimAutoreleasedReturnValue(),
              int v77 = IDSIsCallingRegistrationServiceType(),
              v76,
              v77))
        {
          long long v78 = _IDSInvitationProtocolVersionNumber();
        }
        else
        {
          v143 = [(__CFString *)v44 serviceType];
          int v144 = IDSIsiMessageRegistrationServiceType();

          if (v144) {
            _IDSiMessageProtocolVersionNumber();
          }
          else {
          long long v78 = _IDSAlloyProtocolVersionNumber();
          }
        }
        __int16 v79 = v78;
        [v78 integerValue];

        v243 = v43;
        v247 = v44;
        id v251 = (id)v59;
        if (!v55)
        {
          id v80 = objc_alloc_init((Class)NSMutableDictionary);
          [(__CFString *)v226 setObject:v80 forKey:v246];
          id v81 = objc_alloc_init((Class)NSMutableArray);
          long long v82 = [*v72 registration];
          if (os_log_type_enabled(v82, OS_LOG_TYPE_DEBUG))
          {
            IMGetEnvironmentName();
            long long v149 = (__CFString *)(id)objc_claimAutoreleasedReturnValue();
            long long v150 = [*(id *)(*(void *)(v61 + 32) + 120) pushToken];
            *(_DWORD *)buf = 138412546;
            CFStringRef v316 = v149;
            __int16 v317 = 2112;
            v318 = v150;
            _os_log_debug_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEBUG, "environment: %@    token: %@", buf, 0x16u);

            unsigned int v44 = v247;
          }

          __int16 v83 = _FTIDSFlagsNumber();
          [v83 unsignedIntegerValue];

          [(__CFString *)v44 serviceType];
          v85 = __int16 v84 = v44;
          id v86 = sub_1001487A4(v85);

          uint64_t v87 = _DeviceCapabilitiesFromParameters();
          [v81 addObject:v87];

          [v80 setObject:v81 forKey:@"capabilities"];
          NSErrorUserInfoKey v88 = v80;
          [v80 setObject:v246 forKey:@"service"];
          id v89 = objc_alloc_init((Class)NSMutableArray);
          long long v297 = 0u;
          long long v298 = 0u;
          long long v299 = 0u;
          long long v300 = 0u;
          __int16 v90 = [(__CFString *)v84 adHocServiceNames];
          id v91 = [v90 countByEnumeratingWithState:&v297 objects:v322 count:16];
          if (v91)
          {
            id v92 = v91;
            uint64_t v93 = *(void *)v298;
            do
            {
              for (m = 0; m != v92; m = (char *)m + 1)
              {
                if (*(void *)v298 != v93) {
                  objc_enumerationMutation(v90);
                }
                id v95 = *(void **)(*((void *)&v297 + 1) + 8 * (void)m);
                if (([v95 isEqualToIgnoringCase:@"com.apple.private.alloy.telephonyutilitiestemporary"] & 1) == 0&& (objc_msgSend(v95, "isEqualToIgnoringCase:", @"com.apple.private.alloy.mediaidstest") & 1) == 0&& (objc_msgSend(v95, "isEqualToIgnoringCase:", @"com.apple.private.alloy.callhistorysynctemporary") & 1) == 0&& (objc_msgSend(v95, "isEqualToIgnoringCase:", @"com.apple.private.alloy.musictemporary") & 1) == 0)
                {
                  [v89 addObject:v95];
                }
              }
              id v92 = [v90 countByEnumeratingWithState:&v297 objects:v322 count:16];
            }
            while (v92);
          }

          id v55 = v88;
          [v88 setObject:v89 forKey:@"sub-services"];

          unsigned int v44 = v247;
          uint64_t v73 = v258;
        }
        __int16 v96 = +[IDSRegistrationKeyManager sharedInstance];
        uint64_t v97 = [v96 keyPairSignature];
        [(__CFString *)v44 setKeyPairSignature:v97];

        [(__CFString *)v44 setDeviceName:v224];
        uint64_t v98 = [(__CFString *)v44 serviceIdentifier];
        LODWORD(v97) = IDSIsGameCenterRegistrationServiceType();

        if (v97) {
          [(__CFString *)v44 setContextInfo:value];
        }
        id v99 = [v55 objectForKey:@"users"];
        if (!v99)
        {
          id v99 = objc_alloc_init((Class)NSMutableArray);
          [v55 setObject:v99 forKey:@"users"];
        }
        uint64_t v100 = (__CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
        uint64_t v101 = [*(id *)(v73 + 32) _URIsToRegisterForRegistration:v44];
        id v102 = [v101 allObjects];
        uint64_t v103 = objc_msgSend(v102, "__imArrayByApplyingBlock:", &stru_100986A70);

        if (!v103)
        {
          uint64_t v103 = +[NSArray array];
        }
        v228 = (void *)v103;
        theDict = v100;
        v242 = v55;
        long long v104 = [(__CFString *)v44 idsUserID];
        int v105 = _os_feature_enabled_impl();
        CFStringRef v106 = @"Home";
        if (v105) {
          CFStringRef v106 = @"Personal";
        }
        v262 = v106;
        long long v293 = 0u;
        long long v294 = 0u;
        long long v295 = 0u;
        long long v296 = 0u;
        id v107 = v99;
        id v108 = [v107 countByEnumeratingWithState:&v293 objects:v321 count:16];
        if (!v108)
        {
          v260 = 0;
          id v110 = 0;
          id v111 = 0;
          goto LABEL_109;
        }
        id v109 = v108;
        v260 = 0;
        id v110 = 0;
        id v111 = 0;
        uint64_t v112 = *(void *)v294;
        do
        {
          for (n = 0; n != v109; n = (char *)n + 1)
          {
            if (*(void *)v294 != v112) {
              objc_enumerationMutation(v107);
            }
            uint64_t v114 = *(void **)(*((void *)&v293 + 1) + 8 * (void)n);
            id v115 = [v114 objectForKey:@"user-id"];
            uint64_t v116 = [v114 objectForKey:@"tag"];
            if ([v115 length])
            {
              if ([v115 _FZIDType]
                || ([v116 isEqualToString:v262] & 1) != 0)
              {
                if ([v115 _FZIDType] == (id)1)
                {
                  if (v110)
                  {
                    id v117 = v110;
                  }
                  else
                  {
                    id v117 = (__CFString *)objc_alloc_init((Class)NSMutableSet);
                    id v110 = v117;
                  }
                  goto LABEL_100;
                }
              }
              else
              {
                id v117 = v260;
                if (v260)
                {
                  char v259 = 1;
                }
                else
                {
                  id v117 = (__CFString *)objc_alloc_init((Class)NSMutableSet);
                  char v259 = 1;
                  v260 = v117;
                }
LABEL_100:
                [(__CFString *)v117 addObject:v115];
              }
              if (!v111)
              {
                if ([v115 isEqualToIgnoringCase:v104]) {
                  id v111 = v114;
                }
                else {
                  id v111 = 0;
                }
              }
            }
          }
          id v109 = [v107 countByEnumeratingWithState:&v293 objects:v321 count:16];
        }
        while (v109);
LABEL_109:

        id v118 = v104;
        if (v118)
        {
          unsigned int v119 = theDict;
          CFDictionarySetValue(theDict, @"user-id", v118);
          unsigned int v121 = v255;
          uint64_t v120 = v258;
          id v122 = (id *)IMRGLog_ptr;
        }
        else
        {
          id v123 = &_os_log_default;
          uint64_t v120 = v258;
          id v122 = (id *)IMRGLog_ptr;
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412546;
            CFStringRef v316 = @"user-id";
            __int16 v317 = 2080;
            v318 = "userDictionary";
            _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "REQUIRED_ATTRIBUTE - Warning, missing %@ to add to %s", buf, 0x16u);
          }

          unsigned int v121 = v255;
          unsigned int v119 = theDict;
        }
        CFStringRef v124 = (void *)v237;
        v238 = v118;

        id v125 = v228;
        v256 = v125;
        if (v125)
        {
          CFStringRef v126 = v125;
          CFDictionarySetValue(v119, @"uris", v125);
          unint64_t v6 = v122;
        }
        else
        {
          id v127 = &_os_log_default;
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412546;
            CFStringRef v316 = @"uris";
            __int16 v317 = 2080;
            v318 = "userDictionary";
            _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "REQUIRED_ATTRIBUTE - Warning, missing %@ to add to %s", buf, 0x16u);
          }

          unint64_t v6 = v122;
          CFStringRef v126 = 0;
        }

        id v128 = value;
        a1 = v120;
        if (v128) {
          CFDictionarySetValue(v119, @"client-data", v128);
        }

        id v129 = v124;
        if (v129) {
          CFDictionarySetValue(v119, @"kt-loggable-data", v129);
        }
        v229 = v129;

        id v130 = v251;
        if (v251) {
          CFDictionarySetValue(v119, @"kt-account-key", v130);
        }

        id v131 = v249;
        valuea = v131;
        if (v249)
        {
          CFDictionarySetValue(v119, @"kt-account-key-ts", v131);
          id v131 = valuea;
        }

        id v132 = v233;
        id v252 = v132;
        if (v233)
        {
          CFDictionarySetValue(v119, @"kt-opt-ts", v132);
          id v132 = v252;
        }

        uint64_t v133 = v231;
        if (v235 == (id)1) {
          CFDictionarySetValue(v119, @"kt-opt-in", @"true");
        }

        id v134 = v121;
        if (v134) {
          CFDictionarySetValue(v119, @"kt-opt-absent", v134);
        }

        id v135 = v230;
        id v250 = v135;
        if (v135)
        {
          CFDictionarySetValue(v119, @"kt-account-key-absent", v135);
          id v135 = v250;
        }
        v236 = v130;

        v232 = v134;
        v234 = v133;
        if (!v111)
        {
          unsigned int v138 = [(__CFString *)v247 registrationType];
          __int16 v139 = [*v6 registration];
          if (os_log_type_enabled(v139, OS_LOG_TYPE_DEFAULT))
          {
            CFStringRef v140 = @"YES";
            if (!*(unsigned char *)(a1 + 80)) {
              CFStringRef v140 = @"NO";
            }
            *(_DWORD *)buf = 138412802;
            CFStringRef v316 = v260;
            __int16 v317 = 2112;
            v318 = (const char *)v110;
            __int16 v319 = 2112;
            CFStringRef v320 = v140;
            _os_log_impl((void *)&_mh_execute_header, v139, OS_LOG_TYPE_DEFAULT, "     already existing phone: %@         already existing appleID: %@   isInDualSIMMode: %@", buf, 0x20u);
          }

          if (v138 == 2)
          {
            id v142 = v262;
            CFDictionarySetValue(v119, @"tag", v142);
            int v136 = 0;
            goto LABEL_153;
          }
          if (v138 == 1)
          {
            uint64_t v137 = v247;
            if (![(__CFString *)v110 count])
            {
              int v136 = 0;
              goto LABEL_174;
            }
            id v142 = [*v6 warning];
            if (os_log_type_enabled(v142, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 138412546;
              CFStringRef v316 = (const __CFString *)v119;
              __int16 v317 = 2112;
              v318 = (const char *)v110;
              _os_log_fault_impl((void *)&_mh_execute_header, v142, OS_LOG_TYPE_FAULT, "********* Not adding user dictionary, we already had another apple ID based registration: %@  (registrations: %@)", buf, 0x16u);
            }
            int v136 = 1;
            goto LABEL_173;
          }
          if (v138) {
            goto LABEL_136;
          }
          unint64_t v141 = *(unsigned __int8 *)(a1 + 80);
          if ((unint64_t)[(__CFString *)v260 count] > v141)
          {
            id v142 = [*v6 warning];
            if (os_log_type_enabled(v142, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 138412546;
              CFStringRef v316 = (const __CFString *)v119;
              __int16 v317 = 2112;
              v318 = (const char *)v260;
              _os_log_fault_impl((void *)&_mh_execute_header, v142, OS_LOG_TYPE_FAULT, "********* Not adding user dictionary, we already had another phone based registration: %@  (registrations: %@)", buf, 0x16u);
            }
            int v136 = 1;
LABEL_153:
            uint64_t v137 = v247;
LABEL_173:

            unint64_t v6 = (id *)IMRGLog_ptr;
            goto LABEL_174;
          }
          id v142 = [(__CFString *)v247 userUniqueIdentifier];
          v145 = +[IDSCTAdapter sharedInstance];
          id v146 = [v145 SIMForIdentifier:v142];

          id v147 = [v146 slot];
          if (v147)
          {
            if (v147 == (id)2)
            {
              id v151 = +[IMRGLog warning];
              if (os_log_type_enabled(v151, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)buf = 138412290;
                CFStringRef v316 = (const __CFString *)v142;
                _os_log_fault_impl((void *)&_mh_execute_header, v151, OS_LOG_TYPE_FAULT, "Trying to register account without corresponding SIM -- failing {userUniqueIdentifier: %@}", buf, 0xCu);
              }

              int v136 = 1;
            }
            else
            {
              if (v147 == (id)1)
              {
                CFStringRef v148 = @"SIM2";
                goto LABEL_164;
              }
              int v136 = 0;
            }
            id v152 = &_os_log_default;
            if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138412546;
              CFStringRef v316 = @"tag";
              __int16 v317 = 2080;
              v318 = "userDictionary";
              _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "REQUIRED_ATTRIBUTE - Warning, missing %@ to add to %s", buf, 0x16u);
            }
          }
          else
          {
            CFStringRef v148 = @"SIM";
LABEL_164:
            CFDictionarySetValue(v119, @"tag", v148);
            int v136 = 0;
          }
          uint64_t v137 = v247;

          goto LABEL_173;
        }
LABEL_136:
        int v136 = 0;
        uint64_t v137 = v247;
LABEL_174:
        if ([v256 count]
          || ([(__CFString *)v137 hasSentinel] & 1) != 0
          || ([(__CFString *)v137 shouldRegisterUsingDSHandle] & 1) != 0)
        {
          if (v136) {
            goto LABEL_178;
          }
LABEL_187:
          uint64_t v160 = [*v6 registration];
          v161 = v160;
          if (v111)
          {
            if (os_log_type_enabled(v160, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 138412546;
              CFStringRef v316 = v111;
              __int16 v317 = 2112;
              v318 = (const char *)v119;
              _os_log_debug_impl((void *)&_mh_execute_header, v161, OS_LOG_TYPE_DEBUG, "   ** Not adding user dictionary, already had one: %@  (%@)", buf, 0x16u);
            }
          }
          else
          {
            if (os_log_type_enabled(v160, OS_LOG_TYPE_DEFAULT))
            {
              v162 = [(__CFString *)v137 serviceType];
              *(_DWORD *)buf = 138412546;
              CFStringRef v316 = (const __CFString *)v119;
              __int16 v317 = 2112;
              v318 = v162;
              _os_log_impl((void *)&_mh_execute_header, v161, OS_LOG_TYPE_DEFAULT, "   Adding user dictionary: %@  for service: %@", buf, 0x16u);
            }
            [v107 addObject:v119];
          }
          v163 = [*v6 registration];
          if (os_log_type_enabled(v163, OS_LOG_TYPE_DEFAULT))
          {
            v164 = [(__CFString *)v137 idsUserID];
            v165 = [(__CFString *)v137 authenticationCert];
            *(_DWORD *)buf = 138412546;
            CFStringRef v316 = v164;
            __int16 v317 = 2112;
            v318 = v165;
            _os_log_impl((void *)&_mh_execute_header, v163, OS_LOG_TYPE_DEFAULT, "   => Adding auth user ID: %@    cert: %@", buf, 0x16u);

            uint64_t v137 = v247;
          }

          v248 = *(void **)(a1 + 48);
          v166 = [(__CFString *)v137 idsUserID];
          [(__CFString *)v137 authenticationCert];
          v168 = v167 = v137;
          v169 = +[IDSRegistrationKeyManager sharedInstance];
          id v170 = [v169 identityPrivateKey];
          v171 = +[IDSRegistrationKeyManager sharedInstance];
          id v172 = [v171 identityPublicKey];
          id v173 = v170;
          a1 = v258;
          [v248 addAuthUserID:v166 certificate:v168 privateKey:v173 publicKey:v172];

          [v221 addObject:v167];
          unint64_t v6 = (id *)IMRGLog_ptr;
          unsigned int v119 = theDict;
        }
        else
        {
          if (((v136 | sub_1002399C4() ^ 1) & 1) == 0) {
            goto LABEL_187;
          }
          if (v136)
          {
LABEL_178:
            v153 = [*v6 registration];
            if (os_log_type_enabled(v153, OS_LOG_TYPE_DEFAULT))
            {
              id v154 = [(__CFString *)v137 serviceType];
              *(_DWORD *)buf = 138412546;
              CFStringRef v316 = (const __CFString *)v119;
              __int16 v317 = 2112;
              v318 = v154;
              _os_log_impl((void *)&_mh_execute_header, v153, OS_LOG_TYPE_DEFAULT, "   Failing registration for user dictionary: %@,  service: %@", buf, 0x16u);
            }
            [*(id *)(*(void *)(a1 + 32) + 8) removeObject:v137];
            [*(id *)(*(void *)(a1 + 32) + 32) removeObject:v137];
            __int16 v155 = *(void **)(a1 + 32);
            CFStringRef v156 = v137;
            uint64_t v157 = 0;
          }
          else
          {
            CFStringRef v158 = [*v6 registration];
            if (os_log_type_enabled(v158, OS_LOG_TYPE_DEFAULT))
            {
              __int16 v159 = [(__CFString *)v137 serviceType];
              *(_DWORD *)buf = 138412546;
              CFStringRef v316 = (const __CFString *)v119;
              __int16 v317 = 2112;
              v318 = v159;
              _os_log_impl((void *)&_mh_execute_header, v158, OS_LOG_TYPE_DEFAULT, "   Skipping user dictionary: %@, no URIs   for service: %@", buf, 0x16u);
            }
            [*(id *)(*(void *)(a1 + 32) + 8) removeObject:v137];
            [*(id *)(*(void *)(a1 + 32) + 32) removeObject:v137];
            __int16 v155 = *(void **)(a1 + 32);
            CFStringRef v156 = v137;
            uint64_t v157 = 43;
          }
          [v155 _notifyRegistrationFailure:v156 responseCode:1 registrationError:v157 error:0 info:0];
        }

        char v41 = 1;
        id v40 = v225;
        long long v43 = v243;
        uint64_t v42 = v222;
LABEL_198:
        long long v43 = (char *)v43 + 1;
      }
      while (v43 != v40);
      id v40 = [obj countByEnumeratingWithState:&v301 objects:v323 count:16];
      if (!v40)
      {
LABEL_212:

        IDSAssignPushIdentityToMessage();
        v180 = [*v6 registration];
        if (os_log_type_enabled(v180, OS_LOG_TYPE_DEFAULT))
        {
          v181 = *(const char **)(a1 + 56);
          *(_DWORD *)buf = 138412546;
          CFStringRef v316 = v226;
          __int16 v317 = 2112;
          v318 = v181;
          _os_log_impl((void *)&_mh_execute_header, v180, OS_LOG_TYPE_DEFAULT, "   Services: %@ for register: %@", buf, 0x16u);
        }
        char v261 = v41;

        v182 = *(void **)(a1 + 48);
        v183 = [(__CFString *)v226 allValues];
        [v182 setServices:v183];

        [*(id *)(a1 + 48) setDeviceName:v224];
        v184 = *(void **)(a1 + 48);
        v185 = [*(id *)(*(void *)(a1 + 32) + 120) pushToken];
        [v184 setPushToken:v185];

        v186 = [*v6 registration];
        if (os_log_type_enabled(v186, OS_LOG_TYPE_DEFAULT))
        {
          v187 = [*(id *)(*(void *)(a1 + 32) + 120) pushToken];
          *(_DWORD *)buf = 138412290;
          CFStringRef v316 = v187;
          _os_log_impl((void *)&_mh_execute_header, v186, OS_LOG_TYPE_DEFAULT, "Push handler returned push token: %@", buf, 0xCu);
        }
        [*(id *)(a1 + 48) setHardwareVersion:v219];
        [*(id *)(a1 + 48) setOsVersion:v218];
        [*(id *)(a1 + 48) setSoftwareVersion:v217];
        [*(id *)(a1 + 48) setPrivateDeviceData:v216];
        v188 = *(void **)(a1 + 48);
        v189 = [*(id *)(a1 + 32) registrationReasonTracker];
        v190 = [v189 registrationRequestReasonString];
        [v188 setRequestReasonString:v190];

        v191 = [*(id *)(a1 + 32) registrationReasonTracker];
        [v191 clearRegistrationRequestReason];

        v285[0] = _NSConcreteStackBlock;
        v285[1] = 3221225472;
        v285[2] = sub_10023D11C;
        v285[3] = &unk_100986A98;
        v192 = *(void **)(a1 + 48);
        id v193 = *(id *)(a1 + 40);
        uint64_t v194 = *(void *)(a1 + 32);
        id v286 = v193;
        uint64_t v287 = v194;
        id v257 = v221;
        id v288 = v257;
        id v289 = *(id *)(a1 + 64);
        id v290 = *(id *)(a1 + 56);
        id v291 = *(id *)(a1 + 72);
        char v292 = *(unsigned char *)(a1 + 81);
        [v192 setCompletionBlock:v285];
        [*(id *)(a1 + 48) setTimeout:36000.0];
        sub_1001DE1A4();
        long long v283 = 0u;
        long long v284 = 0u;
        long long v281 = 0u;
        long long v282 = 0u;
        v195 = v226;
        id v196 = [(__CFString *)v195 countByEnumeratingWithState:&v281 objects:v314 count:16];
        if (v196)
        {
          id v197 = v196;
          uint64_t v198 = *(void *)v282;
          do
          {
            for (iuint64_t i = 0; ii != v197; iuint64_t i = (char *)ii + 1)
            {
              if (*(void *)v282 != v198) {
                objc_enumerationMutation(v195);
              }
              CFStringRef v200 = *(const __CFString **)(*((void *)&v281 + 1) + 8 * (void)ii);
              v201 = +[NSString stringGUID];
              v202 = [(__CFString *)v195 objectForKey:v200];
              v203 = +[IDSLogFormatter descriptionForObject:v202 options:2];

              v204 = +[IMRGLog registration];
              if (os_log_type_enabled(v204, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 138412546;
                CFStringRef v316 = v200;
                __int16 v317 = 2112;
                v318 = v201;
                _os_log_impl((void *)&_mh_execute_header, v204, OS_LOG_TYPE_DEFAULT, "Registering service %@ timestampGUID: %@", buf, 0x16u);
              }

              v274 = _NSConcreteStackBlock;
              uint64_t v275 = 3221225472;
              v276 = sub_10023D2E0;
              v277 = &unk_10097E418;
              CFStringRef v278 = v200;
              v279 = v201;
              id v280 = v203;
              cut_dispatch_log_queue();
            }
            id v197 = [(__CFString *)v195 countByEnumeratingWithState:&v281 objects:v314 count:16];
          }
          while (v197);
        }

        if (v259)
        {
          ct_green_tea_logger_create_static();
          v205 = getCTGreenTeaOsLogHandle();
          v206 = v205;
          if (v205)
          {
            v207 = v205;
            if (os_log_type_enabled(v207, OS_LOG_TYPE_INFO))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v207, OS_LOG_TYPE_INFO, "Transmitting phone number", buf, 2u);
            }
          }
        }
        if ((v261 & 1) != 0 || *(unsigned char *)(v258 + 81))
        {
          v208 = [*(id *)(v258 + 32) validationQueue];
          uint64_t v209 = *(void *)(v258 + 48);
          v268[0] = _NSConcreteStackBlock;
          v268[1] = 3221225472;
          v268[2] = sub_10023D3A8;
          v268[3] = &unk_100986AE0;
          id v269 = *(id *)(v258 + 64);
          id v210 = *(id *)(v258 + 56);
          uint64_t v211 = *(void *)(v258 + 32);
          id v270 = v210;
          uint64_t v271 = v211;
          id v272 = *(id *)(v258 + 48);
          id v273 = *(id *)(v258 + 72);
          v267[0] = _NSConcreteStackBlock;
          v267[1] = 3221225472;
          v267[2] = sub_10023D598;
          v267[3] = &unk_100985F88;
          v267[4] = *(void *)(v258 + 32);
          [v208 queueBuildingValidationDataIfNecessaryForMessage:v209 subsystem:1 withQueueCompletion:v268 sendBlock:v267];
        }
        else
        {
          v212 = +[IMRGLog registration];
          if (os_log_type_enabled(v212, OS_LOG_TYPE_DEFAULT))
          {
            CFStringRef v213 = *(const __CFString **)(v258 + 64);
            *(_DWORD *)buf = 138412290;
            CFStringRef v316 = v213;
            _os_log_impl((void *)&_mh_execute_header, v212, OS_LOG_TYPE_DEFAULT, "Not sending %@ we didn't have any authenticated registrations", buf, 0xCu);
          }

          objc_msgSend(*(id *)(v258 + 32), "__dumpState");
        }

        id v3 = v215;
        goto LABEL_235;
      }
    }
  }
}

id sub_10023D0B4(id a1, IDSURI *a2)
{
  id v2 = [(IDSURI *)a2 prefixedURI];
  id v3 = +[NSDictionary dictionaryWithObject:v2 forKey:@"uri"];

  return v3;
}

void sub_10023D11C(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a5;
  id v12 = +[IMRGLog registration];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    id v25 = v11;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "****** Received registration response: %@", buf, 0xCu);
  }

  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  id v13 = *(id *)(a1 + 32);
  id v14 = [v13 countByEnumeratingWithState:&v19 objects:v23 count:16];
  if (v14)
  {
    id v15 = v14;
    uint64_t v16 = *(void *)v20;
    do
    {
      for (uint64_t i = 0; i != v15; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v20 != v16) {
          objc_enumerationMutation(v13);
        }
        uint64_t v18 = *(void *)(*((void *)&v19 + 1) + 8 * i);
        [*(id *)(*(void *)(a1 + 40) + 32) removeObjectIdenticalTo:v18];
        [*(id *)(*(void *)(a1 + 40) + 8) removeObjectIdenticalTo:v18];
      }
      id v15 = [v13 countByEnumeratingWithState:&v19 objects:v23 count:16];
    }
    while (v15);
  }

  [*(id *)(a1 + 40) _processRegistrationMessage:v9 sentRegistrations:*(void *)(a1 + 48) descriptionString:*(void *)(a1 + 56) actionID:*(void *)(a1 + 64) actionString:*(void *)(a1 + 72) isDeregister:*(unsigned __int8 *)(a1 + 80) deliveredWithError:v10 resultCode:a4 resultDictionary:v11];
}

void sub_10023D2E0(void *a1)
{
  id v2 = +[IMRGLog FTMessageDelivery_oversized];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = a1[5];
    uint64_t v5 = a1[6];
    int v6 = 138412802;
    uint64_t v7 = v3;
    __int16 v8 = 2112;
    uint64_t v9 = v4;
    __int16 v10 = 2112;
    uint64_t v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%@ Service hash info for register with timestampGUID: %@ info: %@", (uint8_t *)&v6, 0x20u);
  }
}

void sub_10023D3A8(uint64_t a1, int a2)
{
  uint64_t v4 = +[IMRGLog registration];
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = *(void *)(a1 + 40);
      int v12 = 138412546;
      uint64_t v13 = v6;
      __int16 v14 = 2112;
      uint64_t v15 = v7;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Queued %@ for validation (%@)", (uint8_t *)&v12, 0x16u);
    }
  }
  else
  {
    if (v5)
    {
      uint64_t v8 = *(void *)(a1 + 32);
      uint64_t v9 = *(void *)(a1 + 40);
      __int16 v10 = +[FTDeviceSupport sharedInstance];
      uint64_t v11 = [v10 deviceInformationString];
      int v12 = 138412802;
      uint64_t v13 = v8;
      __int16 v14 = 2112;
      uint64_t v15 = v9;
      __int16 v16 = 2112;
      long long v17 = v11;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Sending %@   (ID: %@ Environment: %@)", (uint8_t *)&v12, 0x20u);
    }
    objc_msgSend(*(id *)(a1 + 48), "__sendMessage:", *(void *)(a1 + 56));
  }
  if (qword_100A4C328 != -1) {
    dispatch_once(&qword_100A4C328, &stru_100986AB8);
  }
  if (off_100A4C320) {
    ((void (*)(uint64_t, const __CFString *, NSDictionary *, void))off_100A4C320)(13, @"IdentityServicesRegistration", +[NSDictionary dictionaryWithObject:*(void *)(a1 + 64) forKey:@"action"], 0);
  }
}

void sub_10023D568(id a1)
{
  off_100A4C320 = (_UNKNOWN *)IMWeakLinkSymbol();
}

id sub_10023D598(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(*(id *)(a1 + 32), "__sendMessage:", a2);
}

void sub_10023DD08(_Unwind_Exception *a1)
{
  os_activity_scope_leave((os_activity_scope_state_t)(v1 - 168));
  cut_arc_os_release();
  _Unwind_Resume(a1);
}

uint64_t sub_10023DD78(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  [*(id *)(a1 + 32) _processRegistrationMessage:a2 sentRegistrations:0 descriptionString:*(void *)(a1 + 40) actionID:*(void *)(a1 + 48) actionString:*(void *)(a1 + 56) isDeregister:1 deliveredWithError:a3 resultCode:a4 resultDictionary:a5];
  uint64_t result = *(void *)(a1 + 64);
  if (result)
  {
    uint64_t v7 = *(uint64_t (**)(void))(result + 16);
    return v7();
  }
  return result;
}

void sub_10023DDF8(uint64_t a1, int a2)
{
  uint64_t v4 = +[IMRGLog registration];
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = *(void *)(a1 + 40);
      int v12 = 138412546;
      uint64_t v13 = v6;
      __int16 v14 = 2112;
      uint64_t v15 = v7;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Queued %@ for validation (%@)", (uint8_t *)&v12, 0x16u);
    }
  }
  else
  {
    if (v5)
    {
      uint64_t v8 = *(void *)(a1 + 32);
      uint64_t v9 = *(void *)(a1 + 40);
      __int16 v10 = +[FTDeviceSupport sharedInstance];
      uint64_t v11 = [v10 deviceInformationString];
      int v12 = 138412802;
      uint64_t v13 = v8;
      __int16 v14 = 2112;
      uint64_t v15 = v9;
      __int16 v16 = 2112;
      long long v17 = v11;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Sending %@   (ID: %@ Environment: %@)", (uint8_t *)&v12, 0x20u);
    }
    objc_msgSend(*(id *)(a1 + 48), "__sendMessage:", *(void *)(a1 + 56));
  }
  if (qword_100A4C338 != -1) {
    dispatch_once(&qword_100A4C338, &stru_100986B50);
  }
  if (off_100A4C330) {
    ((void (*)(uint64_t, const __CFString *, NSDictionary *, void))off_100A4C330)(13, @"IdentityServicesRegistration", +[NSDictionary dictionaryWithObject:*(void *)(a1 + 64) forKey:@"action"], 0);
  }
}

void sub_10023DFB8(id a1)
{
  off_100A4C330 = (_UNKNOWN *)IMWeakLinkSymbol();
}

void sub_10023DFE8(uint64_t a1, void *a2)
{
  id v2 = (id *)(a1 + 32);
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained(v2);
  objc_msgSend(WeakRetained, "__sendMessage:", v3);
}

void sub_10023E14C(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a5;
  [*(id *)(*(void *)(a1 + 32) + 24) removeObjectIdenticalTo:*(void *)(a1 + 40)];
  [*(id *)(*(void *)(a1 + 32) + 16) removeObjectIdenticalTo:*(void *)(a1 + 40)];
  int v12 = +[IMRGLog registration];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = (objc_class *)objc_opt_class();
    __int16 v14 = NSStringFromClass(v13);
    int v23 = 138413058;
    id v24 = v14;
    __int16 v25 = 2112;
    id v26 = v10;
    __int16 v27 = 1024;
    int v28 = a4;
    __int16 v29 = 2112;
    id v30 = v11;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Message class: %@  delivered with error: %@  code: %d result: %@", (uint8_t *)&v23, 0x26u);
  }
  int v15 = [*(id *)(a1 + 40) absintheRetries];
  [*(id *)(a1 + 40) setAbsintheRetries:0];
  if (qword_100A4C348 != -1) {
    dispatch_once(&qword_100A4C348, &stru_100986B70);
  }
  if (byte_100A4C340)
  {
    a4 = IMGetDomainIntForKey();
    __int16 v16 = +[IMRGLog warning];
    if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
      sub_10071B0CC(a4, v16);
    }
  }
  if (a4 == 6008 || a4 == 6005)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      long long v19 = v9;
      long long v20 = +[IMRGLog registration];
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        long long v21 = [v19 authenticationInfo];
        int v23 = 138412290;
        id v24 = v21;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, " *** Unauthenticated, need new auth token { auth info: %@ } ***", (uint8_t *)&v23, 0xCu);
      }
    }
    else
    {
      long long v19 = +[IMRGLog registration];
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        int v23 = 138412290;
        id v24 = v9;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, " *** Unauthenticated, need new auth token { message: %@ }", (uint8_t *)&v23, 0xCu);
      }
    }

    if ([*(id *)(a1 + 40) registrationType] == 1) {
      [*(id *)(a1 + 40) setAuthenticationToken:0];
    }
    goto LABEL_26;
  }
  if (a4 != 6004)
  {
    if ((a4 & 0xFFFFFFFFFFFFFFF7) == 0x1771)
    {
      long long v22 = +[IMRGLog warning];
      if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
        sub_10071B098();
      }
    }
    else if (!a4)
    {
      (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
      goto LABEL_27;
    }
    goto LABEL_26;
  }
  long long v17 = +[IMRGLog warning];
  if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT)) {
    sub_10071B064();
  }

  objc_msgSend(*(id *)(*(void *)(a1 + 32) + 144), "cleanupValidationInfoForSubsystemMechanism:", objc_msgSend(*(id *)(a1 + 32), "_authSubsystemForInfo:", *(void *)(a1 + 40)));
  if (v15 > 2)
  {
LABEL_26:
    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
    goto LABEL_27;
  }
  uint64_t v18 = +[IMRGLog registration];
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    int v23 = 67109120;
    LODWORD(v24) = v15;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, " Retries so far: %d  trying again", (uint8_t *)&v23, 8u);
  }

  [*(id *)(a1 + 40) setAbsintheRetries:(v15 + 1)];
  objc_msgSend(*(id *)(*(void *)(a1 + 32) + 144), "removeFromQueue:subsystem:", v9, objc_msgSend(*(id *)(a1 + 32), "_authSubsystemForInfo:", *(void *)(a1 + 40)));
  [*(id *)(a1 + 32) _sendAuthenticateRegistration:*(void *)(a1 + 40)];
LABEL_27:
  [*(id *)(*(void *)(a1 + 32) + 144) removeFromQueue:v9 subsystem:1];
  [*(id *)(a1 + 32) _dequeuePendingRequestsIfNecessary];
}

void sub_10023E5C4(id a1)
{
  byte_100A4C340 = IMGetDomainBoolForKey();
}

void sub_10023E970(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [v3 userInfo];
  BOOL v5 = [v4 objectForKey:@"info"];

  uint64_t v6 = [v3 responseCertificate];
  uint64_t v7 = [v3 responseUserID];
  uint64_t v8 = +[FTDeviceSupport sharedInstance];
  unsigned int v28 = [v8 isC2KEquipment];

  id v9 = +[IDSRegistrationController sharedInstance];
  id v10 = [*(id *)(a1 + 32) mainID];
  id v11 = [v9 activeRegistrationsMatchingUserID:v10];

  int v12 = +[IMRGLog registration];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    uint64_t v35 = v7;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Setting auth cert for user ID: %@", buf, 0xCu);
  }

  uint64_t v13 = +[IDSRegistrationKeychainManager sharedInstance];
  [v13 setAuthenticationCert:v6 forID:v7];

  __int16 v14 = +[IMRGLog registration];
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    uint64_t v35 = v11;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Found existing registrations to authenticate: %@", buf, 0xCu);
  }

  if (([v11 containsObjectIdenticalTo:*(void *)(a1 + 32)] & 1) == 0)
  {
    uint64_t v15 = [v11 arrayByAddingObject:*(void *)(a1 + 32)];

    id v11 = (void *)v15;
  }
  id v26 = (void *)v6;
  if (![v11 count])
  {
    uint64_t v16 = IMSingleObjectArray();

    id v11 = (void *)v16;
  }
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  id obj = v11;
  id v17 = [obj countByEnumeratingWithState:&v29 objects:v33 count:16];
  if (v17)
  {
    id v18 = v17;
    uint64_t v19 = *(void *)v30;
    do
    {
      for (uint64_t i = 0; i != v18; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v30 != v19) {
          objc_enumerationMutation(obj);
        }
        long long v21 = *(void **)(*((void *)&v29 + 1) + 8 * i);
        long long v22 = v7;
        [v21 setIdsUserID:v7];
        int v23 = +[NSNumber numberWithBool:v28];
        [v21 setIsCDMA:v23];

        id v24 = +[IDSRegistrationKeyManager sharedInstance];
        __int16 v25 = [v24 keyPairSignature];
        [v21 setKeyPairSignature:v25];

        [v21 saveToKeychain];
        if (v21 == *(void **)(a1 + 32)
          || ([*(id *)(*(void *)(a1 + 40) + 24) containsObjectIdenticalTo:v21] & 1) != 0
          || [*(id *)(*(void *)(a1 + 40) + 16) containsObjectIdenticalTo:v21])
        {
          [*(id *)(a1 + 40) _notifyIDSAuthenticationSuccess:v21];
        }
        uint64_t v7 = v22;
      }
      id v18 = [obj countByEnumeratingWithState:&v29 objects:v33 count:16];
    }
    while (v18);
  }
}

void sub_10023ED1C(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v11 = a4;
  uint64_t v7 = +[NSString stringWithFormat:@"IDS Authentication failed: %d", a2];
  sub_1001484DC(0, @"Registration", v7, 1073);

  [*(id *)(a1 + 32) saveToKeychain];
  if (![*(id *)(a1 + 32) registrationType])
  {
    uint64_t v8 = [*(id *)(a1 + 40) registrationReasonTracker];
    id v9 = [*(id *)(a1 + 32) userUniqueIdentifier];
    [v8 setPNRReason:15 forUserUniqueIdentifier:v9];
  }
  [*(id *)(a1 + 32) setAuthenticationToken:0];
  if (a3 == 6008) {
    uint64_t v10 = 18;
  }
  else {
    uint64_t v10 = a2;
  }
  [*(id *)(a1 + 40) _notifyProvisionFailure:*(void *)(a1 + 32) responseCode:a3 registrationError:v10 error:v11 fatal:a3 != 6008 info:0];
}

void sub_10023F404(id *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = +[FTDeviceSupport sharedInstance];
  unsigned int v43 = [v4 isC2KEquipment];

  __int16 v38 = [a1[4] usersWithRealm:0];
  uint64_t v35 = v3;
  [v3 authenticationResponses];
  long long v52 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  id obj = (id)objc_claimAutoreleasedReturnValue();
  id v39 = [obj countByEnumeratingWithState:&v52 objects:v63 count:16];
  if (v39)
  {
    uint64_t v37 = *(void *)v53;
    BOOL v5 = (id *)IMRGLog_ptr;
    do
    {
      uint64_t v6 = 0;
      do
      {
        if (*(void *)v53 != v37) {
          objc_enumerationMutation(obj);
        }
        uint64_t v42 = v6;
        uint64_t v7 = *(void **)(*((void *)&v52 + 1) + 8 * v6);
        unsigned int v44 = [v7 userID];
        uint64_t v8 = [v7 cert];
        unint64_t v9 = (unint64_t)[v7 responseCode];
        v51[0] = _NSConcreteStackBlock;
        v51[1] = 3221225472;
        v51[2] = sub_10023FA7C;
        v51[3] = &unk_100986C10;
        id v40 = v7;
        v51[4] = v7;
        uint64_t v10 = objc_msgSend(v38, "__imArrayByFilteringWithBlock:", v51);
        id v11 = [v10 firstObject];

        int v12 = +[IDSRegistrationController sharedInstance];
        uint64_t v13 = [v12 activeRegistrations];
        v49[0] = _NSConcreteStackBlock;
        v49[1] = 3221225472;
        void v49[2] = sub_10023FAE0;
        v49[3] = &unk_100986A30;
        id v14 = v11;
        id v50 = v14;
        uint64_t v15 = objc_msgSend(v13, "__imArrayByFilteringWithBlock:", v49);

        uint64_t v16 = +[IDSPACStateTracker sharedInstance];
        [v16 noteAuthenticationFinished];

        id v17 = [*v5 registration];
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412802;
          uint64_t v58 = v44;
          __int16 v59 = 2048;
          unint64_t v60 = v9;
          __int16 v61 = 2112;
          id v62 = v14;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Setting auth certs {userID: %@, responseCode: %lld, matchingUser: %@}", buf, 0x20u);
        }

        if (v14)
        {
          if (v9)
          {
            [a1[4] setCredential:0 forUser:v14];
          }
          else
          {
            id v18 = +[IDSPACStateTracker sharedInstance];
            [v18 notePhoneAuthCertGained];

            id v19 = [objc_alloc((Class)IDSAuthenticationCertificate) initWithDataRepresentation:v8];
            [a1[4] setAuthenticationCertificate:v19 forUser:v14];
          }
        }
        if (![v15 count] && objc_msgSend(obj, "count") == (id)1)
        {
          uint64_t v20 = IMSingleObjectArray();

          uint64_t v15 = (void *)v20;
        }
        char v41 = (void *)v8;
        long long v21 = [*v5 registration];
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          uint64_t v58 = v15;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Found existing registrations to authenticate: %@", buf, 0xCu);
        }

        long long v47 = 0u;
        long long v48 = 0u;
        long long v45 = 0u;
        long long v46 = 0u;
        id v22 = v15;
        id v23 = [v22 countByEnumeratingWithState:&v45 objects:v56 count:16];
        if (!v23) {
          goto LABEL_38;
        }
        id v24 = v23;
        uint64_t v25 = *(void *)v46;
        while (2)
        {
          for (uint64_t i = 0; i != v24; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v46 != v25) {
              objc_enumerationMutation(v22);
            }
            id v27 = *(id *)(*((void *)&v45 + 1) + 8 * i);
            if (v9)
            {
              id v33 = +[NSString stringWithFormat:@"IDS Authentication failed: %d", v9];
              sub_1001484DC(0, @"Registration", v33, 1073);

              [v27 saveToKeychain];
              if ((v9 & 0xFFFFFFFFFFFFFFF7) == 0x1771) {
                uint64_t v34 = 36;
              }
              else {
                uint64_t v34 = 10;
              }
              objc_msgSend(a1[6], "_notifyProvisionFailure:responseCode:registrationError:error:fatal:info:", v27, objc_msgSend(v40, "responseCode"), v34, 0, v9 != 6008, 0);
              goto LABEL_38;
            }
            [*(id *)(*((void *)&v45 + 1) + 8 * i) setIdsUserID:v44];
            unsigned int v28 = +[NSNumber numberWithBool:v43];
            [v27 setIsCDMA:v28];

            long long v29 = +[IDSRegistrationKeyManager sharedInstance];
            long long v30 = [v29 keyPairSignature];
            [v27 setKeyPairSignature:v30];

            [v27 saveToKeychain];
            long long v31 = [v27 phoneNumber];
            if (v31) {
              goto LABEL_26;
            }
            long long v32 = [v14 phoneNumber];

            if (v32)
            {
              long long v31 = [v14 phoneNumber];
              [v27 setPhoneNumber:v31];
LABEL_26:
            }
            if (v27 == a1[5]
              || ([*((id *)a1[6] + 3) containsObjectIdenticalTo:v27] & 1) != 0
              || [*((id *)a1[6] + 2) containsObjectIdenticalTo:v27])
            {
              [a1[6] _notifyIDSAuthenticationSuccess:v27];
            }
          }
          id v24 = [v22 countByEnumeratingWithState:&v45 objects:v56 count:16];
          if (v24) {
            continue;
          }
          break;
        }
LABEL_38:

        uint64_t v6 = v42 + 1;
        BOOL v5 = (id *)IMRGLog_ptr;
      }
      while ((id)(v42 + 1) != v39);
      id v39 = [obj countByEnumeratingWithState:&v52 objects:v63 count:16];
    }
    while (v39);
  }
}

id sub_10023FA7C(uint64_t a1, void *a2)
{
  id v3 = [a2 realmPrefixedIdentifier];
  uint64_t v4 = [*(id *)(a1 + 32) userID];
  id v5 = [v3 isEqualToString:v4];

  return v5;
}

id sub_10023FAE0(uint64_t a1, void *a2)
{
  id v3 = [a2 userUniqueIdentifier];
  uint64_t v4 = [*(id *)(a1 + 32) uniqueIdentifier];
  id v5 = [v3 isEqualToString:v4];

  return v5;
}

void sub_10023FB44(id *a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7 = a4;
  uint64_t v8 = +[NSString stringWithFormat:@"IDS Authentication failed: %d", a3];
  sub_1001484DC(0, @"Registration", v8, 1073);

  [a1[4] saveToKeychain];
  unint64_t v9 = [a1[5] usersWithRealm:0];
  uint64_t v10 = v9;
  if (a3 == 6008)
  {
    a2 = 18;
  }
  else
  {
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    id v11 = [v9 countByEnumeratingWithState:&v15 objects:v19 count:16];
    if (v11)
    {
      id v12 = v11;
      uint64_t v13 = *(void *)v16;
      do
      {
        for (uint64_t i = 0; i != v12; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v16 != v13) {
            objc_enumerationMutation(v10);
          }
          [a1[5] setCredential:0 forUser:*(void *)(*((void *)&v15 + 1) + 8 * i)];
        }
        id v12 = [v10 countByEnumeratingWithState:&v15 objects:v19 count:16];
      }
      while (v12);
    }
  }
  [a1[6] _notifyProvisionFailure:a1[4] responseCode:a3 registrationError:a2 error:v7 fatal:a3 != 6008 info:0];
}

void sub_10024005C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [v3 responseStatus];
  if (v4)
  {
    id v5 = [v3 responseStatus];
    BOOL v6 = [v5 integerValue] == 0;
  }
  else
  {
    BOOL v6 = 0;
  }

  id v7 = [v3 responseCertificate];
  if (v7)
  {
    id v8 = objc_alloc((Class)IDSAuthenticationCertificate);
    unint64_t v9 = [v3 responseCertificate];
    id v10 = [v8 initWithDataRepresentation:v9];
  }
  else
  {
    id v10 = 0;
  }

  uint64_t v43 = [v3 responseCertificateExpiration];
  id v11 = [*(id *)(a1 + 32) usersWithRealm:2];
  v51[0] = _NSConcreteStackBlock;
  v51[1] = 3221225472;
  v51[2] = sub_100240644;
  v51[3] = &unk_100986C10;
  id v52 = *(id *)(a1 + 40);
  char v41 = v11;
  id v12 = objc_msgSend(v11, "__imArrayByFilteringWithBlock:", v51);
  uint64_t v13 = [v12 firstObject];

  id v14 = +[IDSRegistrationController sharedInstance];
  long long v15 = [v14 activeRegistrations];
  v49[0] = _NSConcreteStackBlock;
  v49[1] = 3221225472;
  void v49[2] = sub_100240688;
  v49[3] = &unk_100986A30;
  id v16 = v13;
  id v50 = v16;
  long long v17 = objc_msgSend(v15, "__imArrayByFilteringWithBlock:", v49);

  if (([v17 containsObjectIdenticalTo:*(void *)(a1 + 48)] & 1) == 0)
  {
    uint64_t v18 = [v17 arrayByAddingObject:*(void *)(a1 + 48)];

    long long v17 = (void *)v18;
  }
  id v19 = (void *)v43;
  if ([v17 count])
  {
    uint64_t v42 = v17;
  }
  else
  {
    uint64_t v20 = IMSingleObjectArray();

    uint64_t v42 = (void *)v20;
  }
  long long v21 = +[IMRGLog registration];
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134218498;
    BOOL v55 = v6;
    __int16 v56 = 2112;
    id v57 = v10;
    __int16 v58 = 2112;
    uint64_t v59 = v43;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Home Number response parsed { success: %lu, cert %@, expiration %@ }", buf, 0x20u);
  }

  if (v10) {
    BOOL v22 = v6;
  }
  else {
    BOOL v22 = 0;
  }
  if (v22 && v43)
  {
    id v23 = +[IMRGLog registration];
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v24 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138412290;
      BOOL v55 = v24;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Setting auth cert for user ID: %@", buf, 0xCu);
    }

    uint64_t v25 = [v16 temporaryPhoneUserWithUpdatedExpirationDate:v43];
    id v26 = +[IDSPACStateTracker sharedInstance];
    [v26 notePhoneAuthCertGained];

    id v40 = v10;
    [*(id *)(a1 + 32) setAuthenticationCertificate:v10 forUser:v16];
    [*(id *)(a1 + 32) setCredential:0 forUser:v16];
    id v39 = (void *)v25;
    [*(id *)(a1 + 32) updateUser:v25];
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    id obj = v42;
    id v27 = [obj countByEnumeratingWithState:&v45 objects:v53 count:16];
    if (v27)
    {
      id v28 = v27;
      uint64_t v29 = *(void *)v46;
      do
      {
        for (uint64_t i = 0; i != v28; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v46 != v29) {
            objc_enumerationMutation(obj);
          }
          long long v31 = *(void **)(*((void *)&v45 + 1) + 8 * i);
          [v31 setIdsUserID:*(void *)(a1 + 40)];
          long long v32 = +[FTDeviceSupport sharedInstance];
          id v33 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", [v32 isC2KEquipment]);
          [v31 setIsCDMA:v33];

          uint64_t v34 = +[IDSRegistrationKeyManager sharedInstance];
          uint64_t v35 = [v34 keyPairSignature];
          [v31 setKeyPairSignature:v35];

          [v31 saveToKeychain];
          if (v31 == *(void **)(a1 + 48)
            || ([*(id *)(*(void *)(a1 + 56) + 24) containsObjectIdenticalTo:v31] & 1) != 0
            || [*(id *)(*(void *)(a1 + 56) + 16) containsObjectIdenticalTo:v31])
          {
            [*(id *)(a1 + 56) _notifyIDSAuthenticationSuccess:v31];
          }
        }
        id v28 = [obj countByEnumeratingWithState:&v45 objects:v53 count:16];
      }
      while (v28);
    }

    id v10 = v40;
    id v19 = (void *)v43;
  }
  else
  {
    __int16 v36 = +[IDSDaemon sharedInstance];
    uint64_t v37 = [v36 registrationConductor];
    __int16 v38 = [v37 userStore];
    [v38 forceRemoveUser:v16 silently:1];

    [*(id *)(a1 + 56) _notifyProvisionFailure:*(void *)(a1 + 48) responseCode:0 registrationError:-1 error:0 fatal:1 info:0];
  }
}

id sub_100240644(uint64_t a1, void *a2)
{
  id v3 = [a2 realmPrefixedIdentifier];
  id v4 = [v3 isEqualToString:*(void *)(a1 + 32)];

  return v4;
}

id sub_100240688(uint64_t a1, void *a2)
{
  id v3 = [a2 userUniqueIdentifier];
  id v4 = [*(id *)(a1 + 32) uniqueIdentifier];
  id v5 = [v3 isEqualToString:v4];

  return v5;
}

void sub_1002406EC(id *a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v6 = a4;
  id v7 = +[NSString stringWithFormat:@"IDS Temporary Phone Provisioning failed: %d", a3];
  sub_1001484DC(0, @"Registration", v7, 1073);

  [a1[4] saveToKeychain];
  id v8 = [a1[5] usersWithRealm:2];
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  void v15[2] = sub_100240890;
  v15[3] = &unk_100986C10;
  id v16 = a1[6];
  unint64_t v9 = objc_msgSend(v8, "__imArrayByFilteringWithBlock:", v15);
  id v10 = [v9 firstObject];

  if (a3 == 6010)
  {
    uint64_t v11 = 37;
  }
  else
  {
    id v12 = +[IDSDaemon sharedInstance];
    uint64_t v13 = [v12 registrationConductor];
    id v14 = [v13 userStore];
    [v14 forceRemoveUser:v10 silently:1];

    uint64_t v11 = 36;
  }
  [a1[7] _notifyProvisionFailure:a1[4] responseCode:a3 registrationError:v11 error:v6 fatal:1 info:0];
}

id sub_100240890(uint64_t a1, void *a2)
{
  id v3 = [a2 realmPrefixedIdentifier];
  id v4 = [v3 isEqualToString:*(void *)(a1 + 32)];

  return v4;
}

void sub_100240EE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
}

void sub_100241248(id a1, IDSBaseMessage *a2, NSError *a3, int64_t a4, NSDictionary *a5)
{
  int v6 = a4;
  id v8 = a2;
  unint64_t v9 = a3;
  id v10 = a5;
  uint64_t v11 = +[IMRGLog spamReporting];
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = 138413058;
    uint64_t v13 = v8;
    __int16 v14 = 2112;
    long long v15 = v9;
    __int16 v16 = 1024;
    int v17 = v6;
    __int16 v18 = 2112;
    id v19 = v10;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Sent report spam message (responseMessage: %@) (error: %@) (resultCode: %d) (resultDictionary: %@)", (uint8_t *)&v12, 0x26u);
  }
}

void sub_100241560(id a1, IDSBaseMessage *a2, NSError *a3, int64_t a4, NSDictionary *a5)
{
  int v6 = a4;
  id v8 = a2;
  unint64_t v9 = a3;
  id v10 = a5;
  uint64_t v11 = +[IMRGLog spamReporting];
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = 138413058;
    uint64_t v13 = v8;
    __int16 v14 = 2112;
    long long v15 = v9;
    __int16 v16 = 1024;
    int v17 = v6;
    __int16 v18 = 2112;
    id v19 = v10;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Sent report unknown sender message (responseMessage: %@) (error: %@) (resultCode: %d) (resultDictionary: %@)", (uint8_t *)&v12, 0x26u);
  }
}

void sub_1002417CC(id a1, IDSBaseMessage *a2, NSError *a3, int64_t a4, NSDictionary *a5)
{
  int v6 = a4;
  id v8 = a2;
  unint64_t v9 = a3;
  id v10 = a5;
  uint64_t v11 = +[IMRGLog iMessageSpam];
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = 138413058;
    uint64_t v13 = v8;
    __int16 v14 = 2112;
    long long v15 = v9;
    __int16 v16 = 1024;
    int v17 = v6;
    __int16 v18 = 2112;
    id v19 = v10;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Sent report spam message (responseMessage: %@) (error: %@) (resultCode: %d) (resultDictionary: %@)", (uint8_t *)&v12, 0x26u);
  }
}

void sub_100241B60(uint64_t a1, void *a2, void *a3, int a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a5;
  int v12 = +[IMRGLog registration];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = [v9 splunkHint];
    *(_DWORD *)buf = 138413058;
    long long v21 = v13;
    __int16 v22 = 2112;
    id v23 = v10;
    __int16 v24 = 1024;
    int v25 = a4;
    __int16 v26 = 2112;
    id v27 = v11;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Sent report client event message (responseMessage: %@) (error: %@) (resultCode: %d) (resultDictionary: %@)", buf, 0x26u);
  }
  if (v10)
  {
    NSErrorDomain v14 = [v10 domain];
    if (v14 != NSURLErrorDomain)
    {
LABEL_7:

      goto LABEL_8;
    }
    id v15 = [v10 code];

    if (v15 == (id)-1001)
    {
      uint64_t v16 = IDSEventReportingManagerErrorDomain;
      NSErrorUserInfoKey v18 = NSDebugDescriptionErrorKey;
      CFStringRef v19 = @"Timed out while reporting event.";
      NSErrorDomain v14 = +[NSDictionary dictionaryWithObjects:&v19 forKeys:&v18 count:1];
      uint64_t v17 = +[NSError errorWithDomain:v16 code:300 userInfo:v14];

      id v10 = (id)v17;
      goto LABEL_7;
    }
  }
LABEL_8:
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100241F30(id a1, IDSBaseMessage *a2, NSError *a3, int64_t a4, NSDictionary *a5)
{
  int v6 = a4;
  id v8 = a2;
  id v9 = a3;
  id v10 = a5;
  id v11 = +[IMRGLog iMessageSpam];
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = 138413058;
    uint64_t v13 = v8;
    __int16 v14 = 2112;
    id v15 = v9;
    __int16 v16 = 1024;
    int v17 = v6;
    __int16 v18 = 2112;
    CFStringRef v19 = v10;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Sent report iMessage unknown sender message (responseMessage: %@) (error: %@) (resultCode: %d) (resultDictionary: %@)", (uint8_t *)&v12, 0x26u);
  }
}

void sub_100242250(uint64_t a1, void *a2, void *a3, int a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a5;
  int v12 = +[IMRGLog registration];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = 138413058;
    id v15 = v9;
    __int16 v16 = 2112;
    id v17 = v10;
    __int16 v18 = 1024;
    int v19 = a4;
    __int16 v20 = 2112;
    id v21 = v11;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Sent report approved temp handle message (responseMessage: %@) (error: %@) (resultCode: %d) (resultDictionary: %@)", (uint8_t *)&v14, 0x26u);
  }

  uint64_t v13 = *(void *)(a1 + 32);
  if (v13) {
    (*(void (**)(uint64_t, id))(v13 + 16))(v13, v10);
  }
}

void sub_100242554(uint64_t a1, void *a2, void *a3)
{
  id v9 = a2;
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5)
  {
    id v6 = a3;
    id v7 = [v9 status];
    id v8 = [v9 abusive];
    [v9 delay];
    (*(void (**)(uint64_t, id, id, id))(v5 + 16))(v5, v7, v8, v6);
  }
}

void sub_100242EE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,os_activity_scope_state_s state,char a41)
{
}

void sub_1002434F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, os_activity_scope_state_s state,char a21)
{
}

void sub_100243540(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a5;
  int v12 = [*(id *)(*(void *)(a1 + 32) + 64) objectForKey:*(void *)(a1 + 40)];
  id v13 = [v12 copy];

  [*(id *)(*(void *)(a1 + 32) + 64) removeObjectForKey:*(void *)(a1 + 40)];
  id v31 = [objc_alloc((Class)NSDictionary) initWithDictionary:*(void *)(*(void *)(a1 + 32) + 56) copyItems:1];
  id v28 = v9;
  [*(id *)(a1 + 32) _processGetHandlesMessage:v9 registrations:v13 deliveredWithError:v10 resultCode:a4 resultDictionary:v11 allowPasswordPrompt:*(unsigned __int8 *)(a1 + 48)];
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  id obj = v13;
  id v33 = [obj countByEnumeratingWithState:&v39 objects:v44 count:16];
  if (v33)
  {
    uint64_t v32 = *(void *)v40;
    uint64_t v30 = a1;
    do
    {
      for (uint64_t i = 0; i != v33; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v40 != v32) {
          objc_enumerationMutation(obj);
        }
        id v15 = *(void **)(*((void *)&v39 + 1) + 8 * i);
        __int16 v16 = [v15 guid];
        if (v16)
        {
          [*(id *)(*(void *)(a1 + 32) + 56) removeObjectForKey:v16];
          id v17 = [v31 objectForKey:v16];
          long long v35 = 0u;
          long long v36 = 0u;
          long long v37 = 0u;
          long long v38 = 0u;
          id v18 = [v17 countByEnumeratingWithState:&v35 objects:v43 count:16];
          if (v18)
          {
            id v19 = v18;
            uint64_t v20 = *(void *)v36;
            do
            {
              for (j = 0; j != v19; j = (char *)j + 1)
              {
                if (*(void *)v36 != v20) {
                  objc_enumerationMutation(v17);
                }
                uint64_t v22 = *(void *)(*((void *)&v35 + 1) + 8 * (void)j);
                if (v22) {
                  (*(void (**)(uint64_t, void *, uint64_t, BOOL, id))(v22 + 16))(v22, v15, a4, v10 == 0, v11);
                }
              }
              id v19 = [v17 countByEnumeratingWithState:&v35 objects:v43 count:16];
            }
            while (v19);
          }

          a1 = v30;
        }
      }
      id v33 = [obj countByEnumeratingWithState:&v39 objects:v44 count:16];
    }
    while (v33);
  }

  if (![*(id *)(*(void *)(a1 + 32) + 64) count])
  {
    uint64_t v23 = *(void *)(a1 + 32);
    __int16 v24 = *(void **)(v23 + 64);
    *(void *)(v23 + 64) = 0;
  }
  if (![*(id *)(*(void *)(a1 + 32) + 56) count])
  {
    uint64_t v25 = *(void *)(a1 + 32);
    __int16 v26 = *(void **)(v25 + 56);
    *(void *)(v25 + 56) = 0;
  }
  id v27 = +[IMRGLog registration];
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Processed getHandles queue", buf, 2u);
  }
}

void sub_100243A74(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a5;
  if (a4 == 6006) {
    [*(id *)(a1 + 32) sendRegistration:*(void *)(a1 + 40)];
  }
  int v12 = +[IMRGLog registration];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    v13[0] = 67109634;
    v13[1] = a4;
    __int16 v14 = 2112;
    id v15 = v11;
    __int16 v16 = 2112;
    id v17 = v10;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Processed retrieve feature toggle state message {resultCode: %d, resultDictionary: %@, error: %@}", (uint8_t *)v13, 0x1Cu);
  }

  (*(void (**)(void, void, uint64_t, BOOL, id))(*(void *)(a1 + 48) + 16))(*(void *)(a1 + 48), *(void *)(a1 + 40), a4, v10 == 0, v11);
}

void sub_100243DD0(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a5;
  if (a4 == 6006) {
    [*(id *)(a1 + 32) sendRegistration:*(void *)(a1 + 40)];
  }
  int v12 = +[IMRGLog registration];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    v13[0] = 67109634;
    v13[1] = a4;
    __int16 v14 = 2112;
    id v15 = v11;
    __int16 v16 = 2112;
    id v17 = v10;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Processed feature toggle state message {resultCode: %d, resultDictionary: %@, error: %@}", (uint8_t *)v13, 0x1Cu);
  }

  (*(void (**)(void, void, uint64_t, BOOL, id))(*(void *)(a1 + 48) + 16))(*(void *)(a1 + 48), *(void *)(a1 + 40), a4, v10 == 0, v11);
}

id sub_1002441BC(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 operation])
  {
    id v4 = 0;
  }
  else
  {
    uint64_t v5 = [v3 featureID];
    id v6 = [*(id *)(a1 + 32) featureID];
    id v4 = [v5 isEqualToString:v6];
  }
  return v4;
}

void sub_100244DAC(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a5;
  if (a4 == 6006) {
    [*(id *)(a1 + 32) sendRegistration:*(void *)(a1 + 40)];
  }
  int v12 = +[IMRGLog registration];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    v13[0] = 67109634;
    v13[1] = a4;
    __int16 v14 = 2112;
    id v15 = v11;
    __int16 v16 = 2112;
    id v17 = v10;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Processed pseudonym message {resultCode: %d, resultDictionary: %@, error: %@}", (uint8_t *)v13, 0x1Cu);
  }

  (*(void (**)(void, void, uint64_t, BOOL, id, void))(*(void *)(a1 + 48) + 16))(*(void *)(a1 + 48), *(void *)(a1 + 40), a4, v10 == 0, v11, 0);
}

void sub_1002456B8(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a5;
  switch(a4)
  {
    case 6001:
      int v12 = +[IDSFoundationLog KeyTransparency];
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_19;
      }
      LOWORD(v16) = 0;
      id v13 = "KT opt in status update failed -- Server says not to retry.";
      goto LABEL_18;
    case 6002:
      int v12 = +[IDSFoundationLog KeyTransparency];
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_19;
      }
      LOWORD(v16) = 0;
      id v13 = "Server cannot process KT opt in status update at this time.";
      goto LABEL_18;
    case 6003:
      int v12 = +[IDSFoundationLog KeyTransparency];
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_19;
      }
      LOWORD(v16) = 0;
      id v13 = "Server says to retry, client clock is too far off from the server clock.";
      goto LABEL_18;
    case 6004:
    case 6007:
    case 6008:
    case 6009:
    case 6010:
    case 6011:
    case 6012:
      goto LABEL_20;
    case 6005:
      int v12 = +[IDSFoundationLog KeyTransparency];
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_19;
      }
      LOWORD(v16) = 0;
      id v13 = "Server says to refresh credentials.";
      goto LABEL_18;
    case 6006:
      __int16 v14 = +[IDSFoundationLog KeyTransparency];
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v16) = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Server asks for refresh of registration.", (uint8_t *)&v16, 2u);
      }

      [*(id *)(a1 + 32) sendRegistration:*(void *)(a1 + 40)];
      goto LABEL_20;
    case 6013:
      int v12 = +[IDSFoundationLog KeyTransparency];
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_19;
      }
      LOWORD(v16) = 0;
      id v13 = "Server says account key is out of date.";
      goto LABEL_18;
    default:
      if (a4) {
        goto LABEL_20;
      }
      int v12 = +[IDSFoundationLog KeyTransparency];
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_19;
      }
      LOWORD(v16) = 0;
      id v13 = "KT opt in status update succeeded.";
LABEL_18:
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v13, (uint8_t *)&v16, 2u);
LABEL_19:

LABEL_20:
      id v15 = +[IDSFoundationLog KeyTransparency];
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(v16) = 67109634;
        HIDWORD(v16) = a4;
        __int16 v17 = 2112;
        id v18 = v11;
        __int16 v19 = 2112;
        id v20 = v10;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Processed KT opt-in status update message {resultCode: %d, resultDictionary: %@, error: %@}", (uint8_t *)&v16, 0x1Cu);
      }

      (*(void (**)(void, void, uint64_t, BOOL, id, void))(*(void *)(a1 + 48) + 16))(*(void *)(a1 + 48), *(void *)(a1 + 40), a4, v10 == 0, v11, 0);
      return;
  }
}

void sub_100245DEC(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a5;
  if (a4 == 6006) {
    [*(id *)(a1 + 32) sendRegistration:*(void *)(a1 + 40)];
  }
  int v12 = +[IDSFoundationLog KeyTransparency];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    v13[0] = 67109634;
    v13[1] = a4;
    __int16 v14 = 2112;
    id v15 = v11;
    __int16 v16 = 2112;
    id v17 = v10;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Processed KT opt-in status update message {resultCode: %d, resultDictionary: %@, error: %@}", (uint8_t *)v13, 0x1Cu);
  }

  (*(void (**)(void, void, uint64_t, BOOL, id, void))(*(void *)(a1 + 48) + 16))(*(void *)(a1 + 48), *(void *)(a1 + 40), a4, v10 == 0, v11, 0);
}

void sub_100246600(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
}

void sub_1002469F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
}

void sub_100246BA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
}

void sub_100247ACC(id a1, IDSBaseMessage *a2, NSError *a3, int64_t a4, NSDictionary *a5)
{
  id v6 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    id v8 = +[IMRGLog registration];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      sub_10071B3A0((uint64_t)v6, v8);
    }
    goto LABEL_10;
  }
  id v7 = +[IMRGLog registration];
  id v8 = v7;
  if (!a4)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v9[0] = 67109120;
      v9[1] = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "SIM deactivation request succeeded with code: %d", (uint8_t *)v9, 8u);
    }
LABEL_10:

    goto LABEL_11;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
    sub_10071B328(a4, v8);
  }

  switch(a4)
  {
    case 6001:
      id v8 = +[IMRGLog registration];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_10071B1F0();
      }
      goto LABEL_10;
    case 6002:
      id v8 = +[IMRGLog registration];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_10071B224();
      }
      goto LABEL_10;
    case 6003:
      id v8 = +[IMRGLog registration];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_10071B258();
      }
      goto LABEL_10;
    case 6005:
      id v8 = +[IMRGLog registration];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_10071B28C();
      }
      goto LABEL_10;
    case 6008:
      id v8 = +[IMRGLog registration];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_10071B2C0();
      }
      goto LABEL_10;
    case 6009:
      id v8 = +[IMRGLog registration];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_10071B2F4();
      }
      goto LABEL_10;
    default:
      break;
  }
LABEL_11:
}

void sub_100247E8C(uint64_t a1, void *a2)
{
  id v3 = [a2 response];
  id v4 = +[IMRGLog registration];
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v5)
    {
      LOWORD(v_Block_object_dispose(&STACK[0x300], 8) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "User hit no to IDS regitration alert -- ignoring", (uint8_t *)&v8, 2u);
    }
LABEL_9:

    return;
  }
  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 32);
    int v8 = 138412290;
    uint64_t v9 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "User hit default button on IDS registration alert { actionURL: %@ }", (uint8_t *)&v8, 0xCu);
  }

  if (*(void *)(a1 + 32))
  {
    id v4 = [objc_alloc((Class)NSURL) initWithString:*(void *)(a1 + 32)];
    if (v4)
    {
      id v7 = [(id)IMWeakLinkClass() defaultWorkspace];
      [v7 openURL:v4 withOptions:0];
    }
    goto LABEL_9;
  }
}

__CFDictionary *sub_1002487E8(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  id v18 = v3;
  BOOL v5 = [v3 componentsSeparatedByString:@"/"];
  theDict = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  id v6 = v5;
  id v7 = [v6 countByEnumeratingWithState:&v20 objects:v28 count:16];
  if (v7)
  {
    uint64_t v8 = *(void *)v21;
    do
    {
      for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v21 != v8) {
          objc_enumerationMutation(v6);
        }
        id v10 = objc_msgSend(*(id *)(*((void *)&v20 + 1) + 8 * i), "componentsSeparatedByString:", @"=", v16, v17);
        if ([v10 count] == (id)2)
        {
          id v11 = [v10 objectAtIndex:0];
          int v12 = [v10 objectAtIndex:1];
          id v13 = +[IDSSockAddrWrapper wrapperWithAddressString:v12 withPortHostOrder:49888 withInterfaceName:v4];

          __int16 v14 = OSLogHandleForIDSCategory();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412546;
            uint64_t v25 = v11;
            __int16 v26 = 2112;
            id v27 = v13;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "added mapping device ID [%@] to destination [%@]", buf, 0x16u);
          }

          if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
          {
            __int16 v16 = v11;
            id v17 = v13;
            _IDSLogV();
          }
          if (v13) {
            CFDictionarySetValue(theDict, v11, v13);
          }
        }
      }
      id v7 = [v6 countByEnumeratingWithState:&v20 objects:v28 count:16];
    }
    while (v7);
  }

  return theDict;
}

id sub_100248AAC(void *a1, double a2)
{
  id v3 = a1;
  id v4 = objc_alloc_init((Class)NSMutableString);
  uint64_t v34 = v3;
  [v3 allKeys];
  long long v43 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  id obj = (id)objc_claimAutoreleasedReturnValue();
  id v35 = [obj countByEnumeratingWithState:&v43 objects:v47 count:16];
  if (v35)
  {
    BOOL v5 = 0;
    id v6 = 0;
    id v7 = 0;
    uint64_t v42 = 0;
    uint64_t v33 = *(void *)v44;
    do
    {
      for (uint64_t i = 0; i != v35; uint64_t i = (char *)i + 1)
      {
        long long v36 = v6;
        long long v40 = v7;
        long long v41 = v5;
        if (*(void *)v44 != v33) {
          objc_enumerationMutation(obj);
        }
        uint64_t v9 = *(void **)(*((void *)&v43 + 1) + 8 * i);
        id v10 = [v34 objectForKey:v9];
        id v11 = [v10 objectForKey:@"localDeliveryQueueStatMessageCount"];
        long long v39 = (char *)[v11 unsignedLongLongValue];

        int v12 = [v10 objectForKey:@"localDeliveryQueueStatBytes"];
        id v38 = [v12 unsignedLongLongValue];

        id v13 = [v10 objectForKey:@"localDeliveryQueueStatDeliveredMessageCount"];
        long long v37 = (char *)[v13 unsignedLongLongValue];

        __int16 v14 = [v10 objectForKey:@"localDeliveryQueueStatDeliveredBytes"];
        id v15 = [v14 unsignedLongLongValue];

        __int16 v16 = [v10 objectForKey:@"localDeliveryQueueStatsLastDeliveredTime"];
        [v16 doubleValue];
        double v18 = v17;

        __int16 v19 = (const char *)[v9 UTF8String];
        int v20 = strlen(v19);
        int v21 = 55 - v20;
        if (55 - v20 >= 0) {
          int v22 = 55 - v20;
        }
        else {
          int v22 = 62 - v20;
        }
        if (a2 == 0.0 || v18 == 0.0) {
          objc_msgSend(v4, "appendFormat:", @"        %s\t", v19, v31);
        }
        else {
          objc_msgSend(v4, "appendFormat:", @"%7d %s\t", (int)(a2 - v18 + 0.5), v19);
        }
        if (v21 >= 8)
        {
          int v23 = (v22 >> 3) + 1;
          do
          {
            [v4 appendString:@"\t"];
            --v23;
          }
          while (v23 > 1);
        }
        formattedBytes();
        id v24 = objc_claimAutoreleasedReturnValue();
        id v25 = [v24 UTF8String];
        formattedBytes();
        id v26 = objc_claimAutoreleasedReturnValue();
        [v4 appendFormat:@"%3llu msgs %sB pending, %5llu msgs %sB processed\n", v39, v25, v37, objc_msgSend(v26, "UTF8String")];

        id v7 = &v40[(void)v37];
        v42 += (uint64_t)v15;
        BOOL v5 = &v41[(void)v39];
        id v6 = &v36[(void)v38];
      }
      id v35 = [obj countByEnumeratingWithState:&v43 objects:v47 count:16];
    }
    while (v35);
    formattedBytes();
    id v27 = objc_claimAutoreleasedReturnValue();
    id v28 = [v27 UTF8String];
    formattedBytes();
    id v29 = objc_claimAutoreleasedReturnValue();
    [v4 appendFormat:@"\n\tTotal\t\t\t\t\t\t\t%3llu msgs %sB pending, %5llu msgs %sB processed\n", v5, v28, v7, objc_msgSend(v29, "UTF8String")];
  }
  else
  {
    [v4 appendString:@"\tNone\n"];
  }

  return v4;
}

id sub_100248E70(void *a1)
{
  id v1 = a1;
  id v2 = objc_alloc_init((Class)NSMutableString);
  id v3 = objc_alloc((Class)NSMutableSet);
  id v4 = [v1 allKeys];
  id v5 = [v3 initWithArray:v4];

  id v6 = [(id)qword_100A4C350 allKeys];
  [v5 addObjectsFromArray:v6];

  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  id obj = v5;
  id v27 = [obj countByEnumeratingWithState:&v33 objects:v37 count:16];
  if (v27)
  {
    uint64_t v25 = *(void *)v34;
    id v26 = v1;
    do
    {
      for (uint64_t i = 0; i != v27; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v34 != v25) {
          objc_enumerationMutation(obj);
        }
        uint64_t v8 = *(void **)(*((void *)&v33 + 1) + 8 * i);
        uint64_t v9 = [(id)qword_100A4C350 objectForKey:v8];
        id v10 = [v1 objectForKey:v8];
        id v11 = v10;
        if (v10)
        {
          uint64_t v31 = [v10 packetsSent];
          uint64_t v32 = [v11 packetsReceived];
          unint64_t v29 = (unint64_t)[v11 bytesSent];
          int v12 = v11;
        }
        else
        {
          uint64_t v31 = [v9 packetsSent];
          uint64_t v32 = [v9 packetsReceived];
          unint64_t v29 = (unint64_t)[v9 bytesSent];
          int v12 = v9;
        }
        unint64_t v30 = (unint64_t)[v12 bytesReceived];
        id v28 = [v9 packetsSent];
        id v13 = [v9 packetsReceived];
        __int16 v14 = [v9 bytesSent];
        id v15 = [v9 bytesReceived];
        __int16 v16 = (const char *)[v8 UTF8String];
        int v17 = 55 - strlen(v16);
        objc_msgSend(v2, "appendFormat:", @"\t%s\t", v16);
        if (v17 >= 8)
        {
          unsigned int v18 = (v17 >> 3) + 1;
          do
          {
            [v2 appendString:@"\t"];
            --v18;
          }
          while (v18 > 1);
        }
        int64_t v19 = v32 - v13;
        objc_msgSend(v2, "appendFormat:", @"\tTx\t%5lld pkts %5lld KB  %5llu pkts %5llu KB\n", v31 - v28, (uint64_t)(v29 - (void)v14) >> 10, v31, v29 >> 10);
        int v20 = 8;
        do
        {
          [v2 appendString:@"\t"];
          --v20;
        }
        while (v20);
        objc_msgSend(v2, "appendFormat:", @"\tRx\t%5lld pkts %5lld KB  %5llu pkts %5llu KB\n", v19, (uint64_t)(v30 - (void)v15) >> 10, v32, v30 >> 10);

        id v1 = v26;
      }
      id v27 = [obj countByEnumeratingWithState:&v33 objects:v37 count:16];
    }
    while (v27);
  }

  if (qword_100A4C350)
  {
    [(id)qword_100A4C350 addEntriesFromDictionary:v1];
  }
  else
  {
    id v21 = [v1 mutableCopy];
    int v22 = (void *)qword_100A4C350;
    qword_100A4C350 = (uint64_t)v21;
  }

  return v2;
}

void sub_100249920(id a1)
{
  off_100A4C358 = (uint64_t (*)(void, void, void))IMWeakLinkSymbol();
}

void sub_100249950(id a1)
{
  off_100A4C368 = (_UNKNOWN *)IMWeakLinkSymbol();
}

void sub_100249B4C(uint64_t a1, void *value, void *key)
{
  if (value) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), key, value);
  }
}

void sub_100249C5C(uint64_t a1)
{
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v10;
    do
    {
      id v6 = 0;
      do
      {
        if (*(void *)v10 != v5) {
          objc_enumerationMutation(v2);
        }
        uint64_t v7 = *(void *)(*((void *)&v9 + 1) + 8 * (void)v6);
        id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 40) + 1376));
        objc_msgSend(WeakRetained, "link:didConnectForDeviceUniqueID:cbuuid:", *(void *)(a1 + 48), 0, v7, (void)v9);

        id v6 = (char *)v6 + 1;
      }
      while (v4 != v6);
      id v4 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
    }
    while (v4);
  }
}

uint64_t sub_10024A8F8()
{
  return IDSTransportThreadAddBlock();
}

id sub_10024A968(uint64_t a1)
{
  id v1 = *(void **)(a1 + 32);
  ids_monotonic_time();
  return objc_msgSend(v1, "generateLinkReport:forceReport:", 1);
}

void sub_10024A9A0(uint64_t a1)
{
  v96.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&v96.uint64_t tv_usec = 0xAAAAAAAAAAAAAAAALL;
  v95.tm_zone = (char *)0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v1 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v1 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v95.int tm_mon = v1;
  *(_OWORD *)&v95.tm_isdst = v1;
  *(_OWORD *)&v95.uint64_t tm_sec = v1;
  gettimeofday(&v96, 0);
  localtime_r(&v96.tv_sec, &v95);
  id v2 = objc_alloc((Class)NSMutableString);
  int tm_mon = v95.tm_mon;
  int tm_year = v95.tm_year;
  uint64_t tm_hour = v95.tm_hour;
  uint64_t tm_mday = v95.tm_mday;
  uint64_t tm_sec = v95.tm_sec;
  uint64_t tm_min = v95.tm_min;
  uint64_t tv_usec = v96.tv_usec;
  tm_zone = v95.tm_zone;
  long long v11 = +[IDSUTunDeliveryController sharedInstance];
  unsigned int v12 = [v11 isPresent];
  id v13 = "Disconnected";
  if (v12) {
    id v13 = "Connected";
  }
  id v14 = objc_msgSend(v2, "initWithFormat:", @"%d-%02d-%02d %02d:%02d:%02d.%06d %s  LocalDelivery %s\n", (tm_year + 1900), (tm_mon + 1), tm_mday, tm_hour, tm_min, tm_sec, tv_usec, tm_zone, v13);

  id v15 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    int v17 = v95.tm_mon;
    int v16 = v95.tm_year;
    int v18 = v95.tm_hour;
    int v19 = v95.tm_mday;
    int v20 = v95.tm_sec;
    int v21 = v95.tm_min;
    __darwin_suseconds_t v22 = v96.tv_usec;
    id obj = v95.tm_zone;
    int v23 = +[IDSUTunDeliveryController sharedInstance];
    unsigned int v24 = [v23 isPresent];
    *(_DWORD *)buf = 67111170;
    uint64_t v25 = "Disconnected";
    if (v24) {
      uint64_t v25 = "Connected";
    }
    *(_DWORD *)id v99 = v16 + 1900;
    *(_WORD *)&v99[4] = 1024;
    *(_DWORD *)&v99[6] = v17 + 1;
    LOWORD(v100) = 1024;
    *(_DWORD *)((char *)&v100 + 2) = v19;
    HIWORD(v100) = 1024;
    int v101 = v18;
    __int16 v102 = 1024;
    int v103 = v21;
    __int16 v104 = 1024;
    int v105 = v20;
    __int16 v106 = 1024;
    __darwin_suseconds_t v107 = v22;
    __int16 v108 = 2080;
    id v109 = obj;
    __int16 v110 = 2080;
    id v111 = v25;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%d-%02d-%02d %02d:%02d:%02d.%06d %s  LocalDelivery %s\n", buf, 0x40u);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    int v27 = v95.tm_mon;
    int v26 = v95.tm_year;
    uint64_t v29 = v95.tm_hour;
    uint64_t v28 = v95.tm_mday;
    uint64_t v30 = v95.tm_sec;
    uint64_t v31 = v95.tm_min;
    uint64_t v32 = v96.tv_usec;
    long long v33 = v95.tm_zone;
    long long v34 = +[IDSUTunDeliveryController sharedInstance];
    unsigned int v35 = [v34 isPresent];
    long long v36 = "Disconnected";
    if (v35) {
      long long v36 = "Connected";
    }
    __int16 v84 = v33;
    __int16 v85 = v36;
    uint64_t v82 = v30;
    uint64_t v83 = v32;
    uint64_t v80 = v29;
    uint64_t v81 = v31;
    uint64_t v77 = (v27 + 1);
    uint64_t v79 = v28;
    uint64_t v70 = (v26 + 1900);
    _IDSLogV();
  }
  NSErrorUserInfoKey v88 = +[IDSUTunDeliveryController sharedInstance];
  ids_monotonic_time();
  double v38 = v37;
  long long v39 = [v88 syncPriorityMessageStatistics];
  long long v40 = sub_100248AAC(v39, v38);

  [v14 appendString:@"Sync priority messages queued:\n"];
  [v14 appendString:v40];
  long long v41 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    *(void *)id v99 = v40;
    _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Sync priority messages queued: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    long long v71 = v40;
    _IDSLogV();
  }
  uint64_t v42 = objc_msgSend(v88, "defaultPriorityMessageStatistics", v71);
  long long v43 = sub_100248AAC(v42, v38);

  [v14 appendString:@"\nDefault priority messages queued:\n"];
  [v14 appendString:v43];
  long long v44 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    *(void *)id v99 = v43;
    _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "Default priority messages queued: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    long long v72 = v43;
    _IDSLogV();
  }
  long long v45 = objc_msgSend(v88, "urgentPriorityMessageStatistics", v72);
  long long v46 = sub_100248AAC(v45, v38);

  [v14 appendString:@"\nUrgent priority messages queued:\n"];
  [v14 appendString:v46];
  long long v47 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    *(void *)id v99 = v46;
    _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "Urgent priority messages queued: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v73 = v46;
    _IDSLogV();
  }
  long long v48 = objc_msgSend(v88, "urgentCloudPriorityMessageStatistics", v73);
  unsigned int v49 = sub_100248AAC(v48, v38);

  [v14 appendString:@"\nUrgent Cloud priority messages queued:\n"];
  [v14 appendString:v49];
  id v50 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    *(void *)id v99 = v49;
    _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "Urgent Cloud priority messages queued: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    long long v74 = v49;
    _IDSLogV();
  }
  unsigned int v51 = objc_msgSend(v88, "sendingMessageStatistics", v74);
  uint64_t v87 = sub_100248AAC(v51, 0.0);

  [v14 appendString:@"\nMessages being sent:\n"];
  [v14 appendString:v87];
  id v52 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    *(void *)id v99 = v87;
    _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "Messages being sent: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    int v75 = v87;
    _IDSLogV();
  }
  objc_msgSend(v14, "appendString:", @"\nIncoming messages not claimed yet:\n", v75);
  long long v53 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "Incoming messages not claimed yet:", buf, 2u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  long long v54 = [v88 queuedIncomingMessageDictionary];
  [v54 allKeys];
  long long v93 = 0u;
  long long v94 = 0u;
  long long v91 = 0u;
  long long v92 = 0u;
  id obja = (id)objc_claimAutoreleasedReturnValue();
  id v55 = [obja countByEnumeratingWithState:&v91 objects:v97 count:16];
  if (v55)
  {
    uint64_t v56 = 0;
    uint64_t v57 = *(void *)v92;
    do
    {
      for (uint64_t i = 0; i != v55; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v92 != v57) {
          objc_enumerationMutation(obja);
        }
        id v59 = *(id *)(*((void *)&v91 + 1) + 8 * i);
        unint64_t v60 = (const char *)[v59 UTF8String];
        int v61 = strlen(v60);
        objc_msgSend(v14, "appendFormat:", @"\t%s\t", v60);
        if (55 - v61 >= 8)
        {
          unsigned int v62 = ((55 - v61) >> 3) + 1;
          do
          {
            [v14 appendString:@"\t"];
            --v62;
          }
          while (v62 > 1);
        }
        CFDictionaryRef Value = 0;
        if (v54 && v59) {
          CFDictionaryRef Value = (void *)CFDictionaryGetValue((CFDictionaryRef)v54, v59);
        }
        id v64 = [Value unsignedLongLongValue];
        objc_msgSend(v14, "appendFormat:", @"%3llu msgs\n", v64);
        long long v65 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315394;
          *(void *)id v99 = v60;
          *(_WORD *)&v99[8] = 2048;
          id v100 = v64;
          _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "\t%s\t%3llu msgs", buf, 0x16u);
        }

        if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
        {
          id v78 = v64;
          _IDSLogV();
        }
        v56 += (uint64_t)v64;
      }
      id v55 = [obja countByEnumeratingWithState:&v91 objects:v97 count:16];
    }
    while (v55);

    objc_msgSend(v14, "appendFormat:", @"\n\tTotal\t\t\t\t\t\t\t%3llu msgs\n", v56);
    double v66 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      *(void *)id v99 = v56;
      _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "\tTotal\t\t\t\t\t\t\t%3llu msgs", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      uint64_t v76 = v56;
      _IDSLogV();
    }
  }
  else
  {

    [v14 appendString:@"\tNone\n"];
    id v67 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "\tNone", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
  }
  objc_msgSend(v14, "appendString:", *(void *)(a1 + 32), v76, v78);
  int v68 = *(_DWORD *)(*(void *)(a1 + 40) + 1316);
  if (v68 != -1)
  {
    id v69 = v14;
    write(v68, [v69 UTF8String], (size_t)objc_msgSend(v69, "length"));
    write(*(_DWORD *)(*(void *)(a1 + 40) + 1316), "\n", 1uLL);
  }
}

void sub_10024C060(id a1)
{
  off_100A4C378 = (uint64_t (*)(void, void))IMWeakLinkSymbol();
}

void sub_10024C090(id a1)
{
  off_100A4C388 = (uint64_t (*)(void))IMWeakLinkSymbol();
}

void sub_10024C0C0(id a1)
{
  off_100A4C398 = (uint64_t (*)(void, void, void))IMWeakLinkSymbol();
}

void sub_10024C0F0(uint64_t a1, void *a2)
{
  id v2 = a2;
  if (qword_100A4C418 != -1) {
    dispatch_once(&qword_100A4C418, &stru_1009870F0);
  }
  id v3 = [v2 objectForKey:qword_100A4C3B8];
  if (qword_100A4C428 != -1) {
    dispatch_once(&qword_100A4C428, &stru_100987110);
  }
  if (off_100A4C420) {
    id v4 = [(id)off_100A4C420(v3) copy];
  }
  else {
    id v4 = 0;
  }
  id v5 = [v2 objectForKey:qword_100A4C3C0];
  if (CFEqual(v5, (CFTypeRef)qword_100A4C3C8))
  {
    uint64_t v6 = 1;
  }
  else if (CFEqual(v5, (CFTypeRef)qword_100A4C3D0))
  {
    uint64_t v6 = 2;
  }
  else if (CFEqual(v5, (CFTypeRef)qword_100A4C3D8))
  {
    uint64_t v6 = 3;
  }
  else if (CFEqual(v5, (CFTypeRef)qword_100A4C3E0))
  {
    uint64_t v6 = 4;
  }
  else if (CFEqual(v5, (CFTypeRef)qword_100A4C3E8))
  {
    uint64_t v6 = 5;
  }
  else if (CFEqual(v5, (CFTypeRef)qword_100A4C3F0))
  {
    uint64_t v6 = 6;
  }
  else if (CFEqual(v5, (CFTypeRef)qword_100A4C3F8))
  {
    uint64_t v6 = 7;
  }
  else if (CFEqual(v5, (CFTypeRef)qword_100A4C400))
  {
    uint64_t v6 = 8;
  }
  else if (CFEqual(v5, (CFTypeRef)qword_100A4C408))
  {
    uint64_t v6 = 9;
  }
  else if (CFEqual(v5, (CFTypeRef)qword_100A4C410))
  {
    uint64_t v6 = 10;
  }
  else
  {
    uint64_t v6 = 0;
  }
  uint64_t v7 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = (&off_100A43078)[v6];
    *(_DWORD *)buf = 136315394;
    long long v11 = v8;
    __int16 v12 = 2112;
    id v13 = v4;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "_WiFiDeviceAutoJoinCallback: status = %s, SSint ID = [%@]", buf, 0x16u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      _IDSLogTransport();
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
  }
  id v9 = v4;
  IDSTransportThreadAddBlock();
}

void sub_10024C47C(id a1)
{
  off_100A4C3A8 = (_UNKNOWN *)IMWeakLinkSymbol();
}

void sub_10024CF7C(uint64_t a1)
{
  id v2 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 32)) {
      CFStringRef v3 = @"YES";
    }
    else {
      CFStringRef v3 = @"NO";
    }
    *(_DWORD *)buf = 138412290;
    CFStringRef v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "_connectivityChangedForDefaultDevice sending legacyUTunBTLinkManagerDefaultPeerConnectivityChanged: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
  {
    id v4 = *(unsigned char *)(a1 + 32) ? @"YES" : @"NO";
    uint64_t v7 = v4;
    _IDSLogTransport();
    if (_IDSShouldLog())
    {
      if (*(unsigned char *)(a1 + 32)) {
        CFStringRef v5 = @"YES";
      }
      else {
        CFStringRef v5 = @"NO";
      }
      uint64_t v7 = (__CFString *)v5;
      _IDSLogV();
    }
  }
  uint64_t v6 = +[IDSUTunDeliveryController sharedInstance];
  [v6 legacyUTunBTLinkManagerDefaultPeerConnectivityChanged:*(unsigned __int8 *)(a1 + 32)];
}

void sub_10024D114(uint64_t a1)
{
  id v2 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 32)) {
      CFStringRef v3 = @"YES";
    }
    else {
      CFStringRef v3 = @"NO";
    }
    *(_DWORD *)buf = 138412290;
    CFStringRef v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "_connectivityChangedForDefaultDevice sending legacyUTunBTLinkManagerDefaultPeerCloudConnectivityChanged: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
  {
    id v4 = *(unsigned char *)(a1 + 32) ? @"YES" : @"NO";
    uint64_t v7 = v4;
    _IDSLogTransport();
    if (_IDSShouldLog())
    {
      if (*(unsigned char *)(a1 + 32)) {
        CFStringRef v5 = @"YES";
      }
      else {
        CFStringRef v5 = @"NO";
      }
      uint64_t v7 = (__CFString *)v5;
      _IDSLogV();
    }
  }
  uint64_t v6 = +[IDSUTunDeliveryController sharedInstance];
  [v6 legacyUTunBTLinkManagerDefaultPeerCloudConnectivityChanged:*(unsigned __int8 *)(a1 + 32)];
}

void sub_10024D484(uint64_t a1)
{
  id v2 = +[IDSUTunDeliveryController sharedInstance];
  [v2 legacyUTunBTLinkManagerDefaultPeerNearbyChanged:*(unsigned __int8 *)(*(void *)(a1 + 32) + 1395)];
}

id sub_10024ED84(uint64_t a1)
{
  return [*(id *)(a1 + 32) _sendUDPLinkInterfaceAddresses:*(void *)(a1 + 40) toDeviceID:*(void *)(a1 + 48) isRetransmission:1 isReply:0];
}

id sub_10024FC50(uint64_t a1)
{
  uint64_t v2 = kIDSDefaultPairedDeviceID;
  id result = [*(id *)(a1 + 32) _suspendBTLink:0 cbuuid:kIDSDefaultPairedDeviceID];
  if (*(unsigned char *)(*(void *)(a1 + 32) + 48))
  {
    ids_monotonic_time();
    *(void *)(*(void *)(a1 + 32) + 12_Block_object_dispose(&STACK[0x300], 8) = v4;
    id v5 = [*(id *)(a1 + 32) _newUDPLinkForDeviceUniqueID:0 cbuuid:v2 IPVersion:0 port:0];
    id v6 = v5;
    if (v5)
    {
      id v7 = v5;
      id v5 = [*(id *)(a1 + 32) _sendUDPLinkInterfaceAddresses:v5 toDeviceID:v2 isRetransmission:0 isReply:0];
      id v6 = v7;
    }
    return (id)_objc_release_x1(v5, v6);
  }
  return result;
}

void sub_10024FD0C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(_DWORD *)(v2 + 56) <= *(_DWORD *)(a1 + 40))
  {
    if (*(unsigned char *)(a1 + 44))
    {
      char v7 = *(unsigned char *)(v2 + 48);
      if (v7) {
        char v7 = *(void *)(v2 + 1408) != 0;
      }
      *(unsigned char *)(v2 + 52) = v7;
      ++*(_DWORD *)(*(void *)(a1 + 32) + 60);
      uint64_t v8 = *(void *)(a1 + 32);
      int v9 = *(_DWORD *)(v8 + 60);
      v37[0] = _NSConcreteStackBlock;
      v37[1] = 3221225472;
      v37[2] = sub_100250400;
      v37[3] = &unk_10097FDE8;
      void v37[4] = v8;
      int v38 = v9;
      long long v10 = objc_retainBlock(v37);
      uint64_t v11 = *(void *)(a1 + 32);
      if (*(unsigned char *)(v11 + 48))
      {
        if (*(unsigned char *)(v11 + 1392))
        {
          __int16 v12 = OSLogHandleForTransportCategory();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            id v13 = (&off_100A43078)[*(void *)(*(void *)(a1 + 32) + 144)];
            *(_DWORD *)buf = 136315138;
            long long v40 = v13;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Trying to bring up WiFi per preferInfraWiFi request: currentWiFiAutoJoinStatus = %s", buf, 0xCu);
          }

          if (os_log_shim_legacy_logging_enabled())
          {
            if (_IDSShouldLogTransport())
            {
              uint64_t v25 = (&off_100A43078)[*(void *)(*(void *)(a1 + 32) + 144)];
              _IDSLogTransport();
              if (_IDSShouldLog())
              {
                uint64_t v25 = (&off_100A43078)[*(void *)(*(void *)(a1 + 32) + 144)];
                _IDSLogV();
              }
            }
          }
        }
        uint64_t v11 = *(void *)(a1 + 32);
        if (!*(unsigned char *)(v11 + 120))
        {
          [*(id *)(a1 + 32) _createWiFiAssociationPowerAssertion:60.0];
          uint64_t v11 = *(void *)(a1 + 32);
        }
      }
      if (*(unsigned char *)(v11 + 48) && *(unsigned char *)(v11 + 1392) && !*(unsigned char *)(v11 + 120) && *(void *)(v11 + 112))
      {
        id location = (id)0xAAAAAAAAAAAAAAAALL;
        objc_initWeak(&location, (id)v11);
        v34[0] = _NSConcreteStackBlock;
        v34[1] = 3221225472;
        v34[2] = sub_1002506C4;
        v34[3] = &unk_100981000;
        objc_copyWeak(&v35, &location);
        id v18 = [v34 copy];
        uint64_t v19 = *(void *)(a1 + 32);
        int v20 = *(void **)(v19 + 136);
        *(void *)(v19 + 136) = v18;

        int v21 = OSLogHandleForTransportCategory();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          __darwin_suseconds_t v22 = *(void **)(*(void *)(a1 + 32) + 176);
          *(_DWORD *)buf = 134217984;
          long long v40 = v22;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Setting AutoJoin tracking timer for %.1fs", buf, 0xCu);
        }

        if (os_log_shim_legacy_logging_enabled())
        {
          if (_IDSShouldLogTransport())
          {
            uint64_t v25 = *(char **)(*(void *)(a1 + 32) + 176);
            _IDSLogTransport();
            if (_IDSShouldLog())
            {
              uint64_t v25 = *(char **)(*(void *)(a1 + 32) + 176);
              _IDSLogV();
            }
          }
        }
        ++*(_DWORD *)(*(void *)(a1 + 32) + 124);
        uint64_t v23 = *(void *)(a1 + 32);
        int v24 = *(_DWORD *)(v23 + 124);
        uint64_t v28 = _NSConcreteStackBlock;
        uint64_t v29 = 3221225472;
        uint64_t v30 = sub_100250824;
        uint64_t v31 = &unk_100986F18;
        uint64_t v32 = v23;
        int v33 = v24;
        IDSTransportThreadAddBlockAfter();
        objc_destroyWeak(&v35);
        objc_destroyWeak(&location);
      }
      else
      {
        dispatch_time_t v14 = dispatch_time(0, 60000000000);
        id v15 = im_primary_queue();
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_100250B7C;
        block[3] = &unk_10097E7F0;
        int v27 = v10;
        dispatch_after(v14, v15, block);
      }
      objc_msgSend(*(id *)(a1 + 32), "_bringUpWiFi:", 1, v25);
    }
    else
    {
      [(id)v2 _bringUpWiFi:0];
    }
    if (*(unsigned char *)(a1 + 45))
    {
      uint64_t v16 = kIDSDefaultPairedDeviceID;
      id v17 = [*(id *)(a1 + 32) _newUDPLinkForDeviceUniqueID:0 cbuuid:kIDSDefaultPairedDeviceID IPVersion:0 port:0];
      if (v17) {
        [*(id *)(a1 + 32) _sendUDPLinkInterfaceAddresses:v17 toDeviceID:v16 isRetransmission:0 isReply:0];
      }
    }
  }
  else
  {
    CFStringRef v3 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v4 = @"YES";
      int v5 = *(unsigned __int8 *)(a1 + 45);
      if (*(unsigned char *)(a1 + 44)) {
        CFStringRef v6 = @"YES";
      }
      else {
        CFStringRef v6 = @"NO";
      }
      *(_DWORD *)buf = 138412802;
      if (!v5) {
        CFStringRef v4 = @"NO";
      }
      long long v40 = (void *)v6;
      __int16 v41 = 2112;
      CFStringRef v42 = v4;
      __int16 v43 = 2048;
      uint64_t v44 = 0x4024000000000000;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "_startUDPLinkHandshakeForDefaultDevice ignoring stale scheduled handshake %@ %@ %.1f seconds ago", buf, 0x20u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
    {
      _IDSLogTransport();
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
  }
}

void sub_100250380(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,id location)
{
  objc_destroyWeak(v28);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t sub_100250400()
{
  return IDSTransportThreadAddBlock();
}

id sub_100250478(uint64_t a1)
{
  uint64_t v2 = *(_DWORD **)(a1 + 32);
  if (v2[15] <= *(_DWORD *)(a1 + 40))
  {
    id result = [v2 _clearWiFiAssociationPowerAssertion];
    if (!*(unsigned char *)(*(void *)(a1 + 32) + 52))
    {
      int v5 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        uint64_t v8 = 0x404E000000000000;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "WiFi was brought up %.1f seconds ago but still didn't get an IP - Bring it back down", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLogTransport())
        {
          uint64_t v6 = 0x404E000000000000;
          _IDSLogTransport();
          if (_IDSShouldLog())
          {
            uint64_t v6 = 0x404E000000000000;
            _IDSLogV();
          }
        }
      }
      return objc_msgSend(*(id *)(a1 + 32), "_bringUpWiFi:", 0, v6);
    }
  }
  else
  {
    CFStringRef v3 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      uint64_t v8 = 0x404E000000000000;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "WiFi was brought up %.1f seconds ago but it was brought up again later - ignoring this one", buf, 0xCu);
    }

    id result = (id)os_log_shim_legacy_logging_enabled();
    if (result)
    {
      id result = (id)_IDSShouldLogTransport();
      if (result)
      {
        _IDSLogTransport();
        id result = (id)_IDSShouldLog();
        if (result) {
          return (id)_IDSLogV();
        }
      }
    }
  }
  return result;
}

void sub_1002506C4(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "WiFi failed to associate and connect - reject preferInfraWiFi request", v6, 2u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      _IDSLogTransport();
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
  }
  uint64_t v3 = kIDSDefaultPairedDeviceID;
  [WeakRetained _suspendBTLink:0 cbuuid:kIDSDefaultPairedDeviceID];
  ids_monotonic_time();
  WeakRetained[16] = v4;
  id v5 = [WeakRetained _newUDPLinkForDeviceUniqueID:0 cbuuid:v3 IPVersion:0 port:0];
  if (v5) {
    [WeakRetained _sendUDPLinkInterfaceAddresses:v5 toDeviceID:v3 isRetransmission:0 isReply:0];
  }
}

void sub_100250824(uint64_t a1)
{
  if (*(_DWORD *)(*(void *)(a1 + 32) + 124) <= *(_DWORD *)(a1 + 40))
  {
    uint64_t v4 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 176);
      *(_DWORD *)buf = 134217984;
      uint64_t v11 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "WiFi started associating %.1f seconds ago", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        _IDSLogTransport();
        if (_IDSShouldLog()) {
          _IDSLogV();
        }
      }
    }
    uint64_t v6 = *(void *)(a1 + 32);
    if (*(unsigned char *)(v6 + 120) && *(unsigned char *)(v6 + 1396))
    {
      char v7 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "WiFi associated already and has connected", buf, 2u);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLogTransport())
        {
          _IDSLogTransport();
          if (_IDSShouldLog()) {
            _IDSLogV();
          }
        }
      }
    }
    else if (*(unsigned char *)(v6 + 1392) && *(void *)(v6 + 136))
    {
      [(id)v6 _clearWiFiAssociationPowerAssertion];
      (*(void (**)(void))(*(void *)(*(void *)(a1 + 32) + 136) + 16))(*(void *)(*(void *)(a1 + 32) + 136));
    }
    uint64_t v8 = *(void *)(a1 + 32);
    int v9 = *(void **)(v8 + 136);
    *(void *)(v8 + 136) = 0;
  }
  else
  {
    uint64_t v2 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 176);
      *(_DWORD *)buf = 134217984;
      uint64_t v11 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "WiFI association started %.1f seconds ago but it was canceled already - ignoring this one", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
    {
      _IDSLogTransport();
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
  }
}

uint64_t sub_100250B7C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100250B8C(uint64_t a1)
{
  [*(id *)(a1 + 32) _clearWiFiAssociationPowerAssertion];
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16);

  return v2();
}

NSString *__cdecl sub_100252454(id a1, NSString *a2, unsigned int a3, NSString *a4, int64_t a5, unsigned __int16 a6, unint64_t a7, unsigned __int16 a8, unsigned int a9, NSData *a10, BOOL a11, BOOL a12, int a13, int a14)
{
  unsigned int v28 = a6;
  uint64_t v15 = *(void *)&a3;
  id v17 = a10;
  id v18 = a4;
  uint64_t v19 = a2;
  int v20 = +[IDSQuickRelayAllocator sharedInstance];
  HIDWORD(v24) = a13;
  LODWORD(v25) = a14;
  LOWORD(v24) = __PAIR16__(a12, a11);
  HIDWORD(v23) = a9;
  LOWORD(v23) = a8;
  int v21 = objc_msgSend(v20, "getAdditionalAllocationForAddress:selfAddress:relaySessionID:allocateType:qrReason:previousTime:previousError:previousRelayIP:previousAccessToken:requestSelfAllocation:isSessionIDRemoteDeviceID:withPreferredRemoteInterface:withPreferredLocalInterface:", v19, v15, v18, a5, v28, a7, v23, v17, v24, v25);

  return (NSString *)v21;
}

void sub_10025255C(id a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5, unint64_t a6, NSString *a7, NSString *a8, BOOL a9)
{
  uint64_t v11 = *(void *)&a5;
  uint64_t v14 = *(void *)&a2;
  uint64_t v15 = a8;
  uint64_t v16 = a7;
  id v18 = +[IDSQuickRelayAllocator sharedInstance];
  LOBYTE(v17) = a9;
  [v18 reportAWDAllocatorEvent:v14 relayProviderType:a3 transport:a4 localRAT:v11 duration:a6 idsSessionID:v16 reportingDataBlob:v15 isInitiator:v17];
}

void sub_100252624(id a1, NSString *a2, NSString *a3)
{
  uint64_t v4 = a3;
  uint64_t v5 = a2;
  id v6 = +[IDSQuickRelayAllocator sharedInstance];
  [v6 startKeepAliveTimer:v5 relaySessionID:v4];
}

void sub_1002526A4(id a1, NSString *a2, NSString *a3)
{
  uint64_t v4 = a3;
  uint64_t v5 = a2;
  id v6 = +[IDSQuickRelayAllocator sharedInstance];
  [v6 stopKeepAliveTimer:v5 relaySessionID:v4];
}

void sub_100252E24(uint64_t a1)
{
  uint64_t v2 = (void *)IMWeakLinkClass();
  uint64_t v3 = [v2 sharedInstance];
  [v3 addWoWClient:*(void *)(a1 + 32)];

  id v4 = [v2 sharedInstance];
  [v4 addWiFiAutoAssociationClientToken:@"IDSLinkManager_WiFi"];
}

void sub_100252EB4(uint64_t a1)
{
  uint64_t v2 = (void *)IMWeakLinkClass();
  uint64_t v3 = [v2 sharedInstance];
  [v3 removeWoWClient:*(void *)(a1 + 32)];

  id v4 = [v2 sharedInstance];
  [v4 removeWiFiAutoAssociationClientToken:@"IDSLinkManager_WiFi"];
}

void sub_10025323C(id a1, id a2, id a3, BOOL *a4)
{
  id v4 = a3;
  if (objc_opt_respondsToSelector()) {
    [v4 invalidate];
  }
}

void sub_100253814(uint64_t a1, void *a2, void *a3)
{
  id v6 = a3;
  id v7 = a2;
  id v4 = v7;
  id v5 = v6;
  IDSTransportThreadAddBlock();
}

void sub_100255530(uint64_t a1)
{
  uint64_t v2 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    uint64_t v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "enableConnectionForDefaultPairedDevice YES for cbuuid %@.", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      uint64_t v5 = *(void *)(a1 + 32);
      _IDSLogTransport();
      if (_IDSShouldLog())
      {
        uint64_t v5 = *(void *)(a1 + 32);
        _IDSLogV();
      }
    }
  }
  id v4 = +[IDSUTunDeliveryController sharedInstance];
  [v4 enableConnectionForDefaultPairedDevice:1];
}

void sub_100255B38(uint64_t a1)
{
  uint64_t v2 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    uint64_t v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "enableConnectionForDefaultPairedDevice NO for cbuuid %@.", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      uint64_t v5 = *(void *)(a1 + 32);
      _IDSLogTransport();
      if (_IDSShouldLog())
      {
        uint64_t v5 = *(void *)(a1 + 32);
        _IDSLogV();
      }
    }
  }
  id v4 = +[IDSUTunDeliveryController sharedInstance];
  [v4 enableConnectionForDefaultPairedDevice:0];
}

uint64_t sub_1002570CC(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), 0, *(void *)(a1 + 32));
}

uint64_t sub_100257470(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

void sub_100257F00(int8x16_t *a1)
{
  uint64_t v2 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = a1[2].i64[0];
    *(_DWORD *)buf = 138412290;
    uint64_t v18 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "start allocate request for %@.", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      uint64_t v9 = a1[2].i64[0];
      _IDSLogTransport();
      if (_IDSShouldLog())
      {
        uint64_t v9 = a1[2].i64[0];
        _IDSLogV();
      }
    }
  }
  id v4 = +[IDSQuickRelayAllocator sharedInstance];
  uint64_t v5 = [v4 setupNewAllocationToDevice:a1[2].i64[0] options:0 connectReadyHandler:0];

  if (v5)
  {
    id v6 = v12;
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472;
    v12[2] = sub_1002582E0;
    void v12[3] = &unk_10097FE10;
    int8x16_t v10 = a1[2];
    id v7 = (id)v10.i64[0];
    int8x16_t v13 = vextq_s8(v10, v10, 8uLL);
    id v14 = v5;
    IDSTransportThreadAddBlock();
  }
  else
  {
    id v6 = v15;
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472;
    void v15[2] = sub_10025816C;
    v15[3] = &unk_100980D88;
    int8x16_t v11 = a1[2];
    id v8 = (id)v11.i64[0];
    int8x16_t v16 = vextq_s8(v11, v11, 8uLL);
    IDSTransportThreadAddBlock();
  }
}

uint64_t sub_10025816C(uint64_t a1)
{
  CFDictionaryRef Value = *(const __CFDictionary **)(*(void *)(a1 + 32) + 88);
  if (Value)
  {
    uint64_t v3 = *(const void **)(a1 + 40);
    if (v3) {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Value, v3);
    }
    else {
      CFDictionaryRef Value = 0;
    }
  }
  if ([(__CFDictionary *)Value BOOLValue]) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1 + 32) + 88), *(const void **)(a1 + 40), &__kCFBooleanFalse);
  }
  id v4 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 138412290;
    uint64_t v8 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "allocate request failed for %@.", buf, 0xCu);
  }

  uint64_t result = os_log_shim_legacy_logging_enabled();
  if (result)
  {
    uint64_t result = _IDSShouldLogTransport();
    if (result)
    {
      _IDSLogTransport();
      uint64_t result = _IDSShouldLog();
      if (result) {
        return _IDSLogV();
      }
    }
  }
  return result;
}

id sub_1002582E0(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _addAllocateRequestForDevice:*(void *)(a1 + 40) requestID:*(void *)(a1 + 48)];
}

uint64_t sub_100259478(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

uint64_t sub_10025948C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100260030(uint64_t a1)
{
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v10;
    do
    {
      id v6 = 0;
      do
      {
        if (*(void *)v10 != v5) {
          objc_enumerationMutation(v2);
        }
        uint64_t v7 = *(void *)(*((void *)&v9 + 1) + 8 * (void)v6);
        id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 40) + 1376));
        objc_msgSend(WeakRetained, "link:didConnectForDeviceUniqueID:cbuuid:", *(void *)(a1 + 48), 0, v7, (void)v9);

        id v6 = (char *)v6 + 1;
      }
      while (v4 != v6);
      id v4 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
    }
    while (v4);
  }
}

void sub_100260508(uint64_t a1)
{
  id v2 = +[IDSUTunDeliveryController sharedInstance];
  [v2 defaultPeerMagnetIndicationOfAwakeStateChanged:*(unsigned __int8 *)(a1 + 32)];
}

void sub_100260F04(uint64_t a1)
{
  id v2 = +[IDSUTunDeliveryController sharedInstance];
  [v2 peerCloudConnectivityChanged:*(void *)(a1 + 32) isCloudConnected:1];
}

void sub_100261188(uint64_t a1)
{
  id v2 = +[IDSUTunDeliveryController sharedInstance];
  [v2 peerCloudConnectivityChanged:*(void *)(a1 + 32) isCloudConnected:0];
}

void sub_1002614F8(uint64_t a1)
{
  id v2 = +[IDSUTunDeliveryController sharedInstance];
  [v2 peerCloudConnectivityChanged:*(void *)(a1 + 32) isCloudConnected:0];
}

void sub_100263584(uint64_t a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    CFStringRef v2 = @"IDSLinkBTLEKey";
  }
  else
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0) {
      return;
    }
    *(unsigned char *)(*(void *)(a1 + 40) + 1394) = 0;
    long long v12 = _NSConcreteStackBlock;
    uint64_t v13 = 3221225472;
    id v14 = sub_100263744;
    uint64_t v15 = &unk_10097FE58;
    uint64_t v16 = *(void *)(a1 + 40);
    IDSTransportThreadAddBlockAfter();
    CFStringRef v2 = @"IDSLinkBTKey";
  }
  id v3 = [*(id *)(*(void *)(a1 + 40) + 8) allKeys];
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  id v4 = [v3 countByEnumeratingWithState:&v8 objects:v17 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v9;
    do
    {
      uint64_t v7 = 0;
      do
      {
        if (*(void *)v9 != v6) {
          objc_enumerationMutation(v3);
        }
        [*(id *)(a1 + 40) _removeLinkForDeviceID:*(void *)(*((void *)&v8 + 1) + 8 * (void)v7) linkKey:v2 verifyWithLink:0];
        uint64_t v7 = (char *)v7 + 1;
      }
      while (v5 != v7);
      id v5 = [v3 countByEnumeratingWithState:&v8 objects:v17 count:16];
    }
    while (v5);
  }
}

id sub_100263744(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) _nearbyChangedForDefaultDevice];
  uint64_t v3 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v3 + 1400))
  {
    *(unsigned char *)(v3 + 1400) = 0;
    id v4 = *(unsigned __int8 **)(a1 + 32);
    uint64_t v5 = v4[1397];
    return [v4 _connectivityChangedForDefaultDevice:0 isCloudConnected:v5];
  }
  return result;
}

void sub_100263834(uint64_t a1)
{
  CFStringRef v2 = [*(id *)(a1 + 32) cbuuid];
  CFDictionaryRef v3 = *(const __CFDictionary **)(*(void *)(a1 + 40) + 8);
  if (v3) {
    BOOL v4 = v2 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  key = v2;
  if (v4) {
    CFDictionaryRef Value = 0;
  }
  else {
    CFDictionaryRef Value = (void *)CFDictionaryGetValue(v3, v2);
  }
  CFDictionaryRef v6 = Value;
  uint64_t v7 = [*(id *)(a1 + 40) _linkKeyForLink:*(void *)(a1 + 32)];
  long long v8 = v7;
  if (v6)
  {
    if (v7) {
      long long v9 = (void *)CFDictionaryGetValue(v6, v7);
    }
    else {
      long long v9 = 0;
    }
    id v10 = v9;
    if (objc_opt_respondsToSelector()) {
      [v10 invalidate];
    }
    if (v8) {
      CFDictionaryRemoveValue(v6, v8);
    }
  }
  else
  {
    CFDictionaryRef v6 = (const __CFDictionary *)objc_alloc_init((Class)NSMutableDictionary);
    if (v6) {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1 + 40) + 8), key, v6);
    }
  }
  long long v11 = *(const void **)(a1 + 32);
  if (v11) {
    CFDictionarySetValue(v6, v8, v11);
  }
  [*(id *)(a1 + 32) setDelegate:*(void *)(a1 + 40)];
  if ([v8 isEqualToString:@"IDSLinkBTKey"])
  {
    if ([key isEqualToString:kIDSDefaultPairedDeviceID])
    {
      *(unsigned char *)(*(void *)(a1 + 40) + 1394) = 1;
      [*(id *)(a1 + 40) _nearbyChangedForDefaultDevice];
      long long v12 = *(unsigned char **)(a1 + 40);
      if (v12[1392]) {
        [v12 _suspendBTLink:1 cbuuid:key];
      }
    }
  }
  if (objc_opt_respondsToSelector()) {
    [*(id *)(a1 + 32) start];
  }
}

void sub_100263A68(uint64_t a1)
{
  CFStringRef v2 = [*(id *)(a1 + 32) cbuuid];
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();
  BOOL v4 = *(void **)(a1 + 40);
  if (isKindOfClass)
  {
    [v4 stopLinkForDeviceUniqueID:0 cbuuid:v2 disconnectWP:0];
  }
  else
  {
    uint64_t v5 = [v4 _linkKeyForLink:*(void *)(a1 + 32)];
    if ([v5 isEqualToString:@"IDSLinkBTKey"]
      && [v2 isEqualToString:kIDSDefaultPairedDeviceID])
    {
      *(unsigned char *)(*(void *)(a1 + 40) + 1394) = 0;
      IDSTransportThreadAddBlockAfter();
    }
    [*(id *)(a1 + 40) _removeLinkForDeviceID:v2 linkKey:v5 verifyWithLink:*(void *)(a1 + 32)];
  }
}

id sub_100263B94(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) _nearbyChangedForDefaultDevice];
  uint64_t v3 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v3 + 1400))
  {
    *(unsigned char *)(v3 + 1400) = 0;
    BOOL v4 = *(unsigned __int8 **)(a1 + 32);
    uint64_t v5 = v4[1397];
    return [v4 _connectivityChangedForDefaultDevice:0 isCloudConnected:v5];
  }
  return result;
}

void sub_100263DA4(uint64_t a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    *(unsigned char *)(*(void *)(a1 + 40) + 1394) = 0;
    [*(id *)(a1 + 40) _nearbyChangedForDefaultDevice];
    *(unsigned char *)(*(void *)(a1 + 40) + 1400) = 0;
    [*(id *)(a1 + 40) _connectivityChangedForDefaultDevice:0 isCloudConnected:*(unsigned __int8 *)(*(void *)(a1 + 40) + 1397)];
    CFStringRef v2 = [*(id *)(*(void *)(a1 + 40) + 8) allKeys];
    long long v8 = 0u;
    long long v9 = 0u;
    long long v10 = 0u;
    long long v11 = 0u;
    id v3 = [v2 countByEnumeratingWithState:&v8 objects:v12 count:16];
    if (v3)
    {
      id v4 = v3;
      uint64_t v5 = *(void *)v9;
      do
      {
        CFDictionaryRef v6 = 0;
        do
        {
          if (*(void *)v9 != v5) {
            objc_enumerationMutation(v2);
          }
          [*(id *)(a1 + 40) _removeLinkForDeviceID:*(void *)(*((void *)&v8 + 1) + 8 * (void)v6) linkKey:@"IDSLinkBTKey" verifyWithLink:0];
          CFDictionaryRef v6 = (char *)v6 + 1;
        }
        while (v4 != v6);
        id v4 = [v2 countByEnumeratingWithState:&v8 objects:v12 count:16];
      }
      while (v4);
    }
    uint64_t v7 = im_primary_queue();
    dispatch_async(v7, &stru_1009870A8);

    *(unsigned char *)(*(void *)(a1 + 40) + 1392) = 0;
    [*(id *)(a1 + 40) _bringUpWiFi:0];
  }
}

void sub_100263F30(id a1)
{
  long long v1 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "enableConnectionForDefaultPairedDevice NO for currently paired device.", v3, 2u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      _IDSLogTransport();
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
  }
  CFStringRef v2 = +[IDSUTunDeliveryController sharedInstance];
  [v2 enableConnectionForDefaultPairedDevice:0];
}

uint64_t sub_1002651AC()
{
  return IDSTransportThreadAddBlock();
}

id sub_10026521C(uint64_t a1)
{
  long long v1 = *(void **)(a1 + 32);
  id v2 = [v1 _getIDSLinkTypeFromWRMLinkType:*(void *)(a1 + 40)];

  return _[v1 _handleWRMLinkRecommendation:v2];
}

void sub_1002657F4(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 32) + 8) allKeys];
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  id v3 = [v2 countByEnumeratingWithState:&v16 objects:v20 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = 0;
    uint64_t v6 = *(void *)v17;
    do
    {
      for (uint64_t i = 0; i != v4; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v17 != v6) {
          objc_enumerationMutation(v2);
        }
        long long v8 = *(const void **)(*((void *)&v16 + 1) + 8 * i);
        CFDictionaryRef v9 = *(const __CFDictionary **)(*(void *)(a1 + 32) + 8);
        if (v9) {
          BOOL v10 = v8 == 0;
        }
        else {
          BOOL v10 = 1;
        }
        if (v10)
        {
          long long v11 = 0;
        }
        else
        {
          long long v12 = (id)CFDictionaryGetValue(v9, v8);
          long long v11 = v12;
          if (v12)
          {
            uint64_t v13 = (id)CFDictionaryGetValue((CFDictionaryRef)v12, @"IDSLinkGlobalKey");

            if (v13)
            {
              objc_opt_class();
              if (objc_opt_isKindOfClass())
              {
                id v14 = [v13 alternateDelegate];
                uint64_t v15 = v14;
                if (v14) {
                  [v14 link:*(void *)(a1 + 32) didSoMaskChange:*(unsigned int *)(a1 + 40)];
                }
              }
              uint64_t v5 = v13;
            }
            else
            {
              uint64_t v5 = 0;
            }
          }
        }
      }
      id v4 = [v2 countByEnumeratingWithState:&v16 objects:v20 count:16];
    }
    while (v4);
  }
  else
  {
    uint64_t v5 = 0;
  }
}

void sub_100265AE0(id a1)
{
  qword_100A4C3B8 = *(void *)IMWeakLinkSymbol();
  qword_100A4C3C0 = *(void *)IMWeakLinkSymbol();
  qword_100A4C3C8 = *(void *)IMWeakLinkSymbol();
  qword_100A4C3D0 = *(void *)IMWeakLinkSymbol();
  qword_100A4C3D8 = *(void *)IMWeakLinkSymbol();
  qword_100A4C3E0 = *(void *)IMWeakLinkSymbol();
  qword_100A4C3E8 = *(void *)IMWeakLinkSymbol();
  qword_100A4C3F0 = *(void *)IMWeakLinkSymbol();
  qword_100A4C3F8 = *(void *)IMWeakLinkSymbol();
  qword_100A4C400 = *(void *)IMWeakLinkSymbol();
  qword_100A4C408 = *(void *)IMWeakLinkSymbol();
  qword_100A4C410 = *(void *)IMWeakLinkSymbol();
}

void sub_100265C54(id a1)
{
  off_100A4C420 = (uint64_t (*)(void))IMWeakLinkSymbol();
}

id sub_100265C84(uint64_t a1)
{
  return _[*(id *)(a1 + 40) _handleWiFiAutoJoinStatusChange:*(void *)(a1 + 48) WiFiSSID:*(void *)(a1 + 32)];
}

id sub_100265C94(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _handleNetworkChanges:*(void *)(a1 + 40)];
}

id sub_100265CA0(void *a1)
{
  id v1 = a1;
  id v2 = sub_100148C98();
  if ([v2 length])
  {
    id v3 = v2;
  }
  else
  {
    id v4 = [v1 pushToken];
    uint64_t v5 = [v4 SHA1HexString];
    uint64_t v6 = [v5 uppercaseString];
    id v3 = +[NSString stringWithFormat:@"t:%@", v6];
  }

  return v3;
}

void sub_100265DC4(id a1)
{
  id v1 = objc_alloc_init(IDSRapportClient);
  uint64_t v2 = qword_100A4C438;
  qword_100A4C438 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_100266350(_Unwind_Exception *a1)
{
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v3 - 168));
  _Unwind_Resume(a1);
}

void sub_1002663EC(uint64_t a1, void *a2)
{
  uint64_t v2 = (id *)(a1 + 32);
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained(v2);
  [WeakRetained _handleDiscoveredDevice:v3];
}

void sub_100266448(uint64_t a1, void *a2)
{
  uint64_t v2 = (id *)(a1 + 32);
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained(v2);
  [WeakRetained _handleLostDevice:v3];
}

id sub_1002664A4()
{
  uint64_t v0 = (void *)qword_100A4C440;
  if (!qword_100A4C440)
  {
    id v1 = (void **)IMWeakLinkSymbol();
    if (v1) {
      uint64_t v2 = *v1;
    }
    else {
      uint64_t v2 = 0;
    }
    objc_storeStrong((id *)&qword_100A4C440, v2);
    uint64_t v0 = (void *)qword_100A4C440;
  }

  return v0;
}

void sub_100266514(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  id v6 = a2;
  uint64_t v7 = +[IDSFoundationLog delivery];
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CFDictionaryRef v9 = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Incoming Rapport message", v9, 2u);
  }

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained _handleIncomingIDSMessageEvent:v6 options:v5];
}

void sub_1002665CC(id a1)
{
  id v1 = +[IDSFoundationLog delivery];
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR)) {
    sub_10071B8B8(v1);
  }
}

void sub_100266618(id a1)
{
  id v1 = +[IDSFoundationLog delivery];
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR)) {
    sub_10071B8FC(v1);
  }
}

void sub_100266664(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSFoundationLog delivery];
  id v5 = v4;
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_10071B940((uint64_t)v3, v5);
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
    int v7 = 138412290;
    id v8 = WeakRetained;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Activated companionLinkClient {self: %@}", (uint8_t *)&v7, 0xCu);
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_10026675C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSFoundationLog delivery];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = [v3 publicIdentifier];
    int v7 = 138412546;
    id v8 = v3;
    __int16 v9 = 2112;
    BOOL v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Updated local device {device: %@, publicIdentifier: %@}", (uint8_t *)&v7, 0x16u);
  }
  uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
  if (!*(unsigned char *)(v6 + 24))
  {
    *(unsigned char *)(v6 + 24) = 1;
    dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
  }
}

void sub_10026685C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSFoundationLog delivery];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Start companionLinkClient setup", buf, 2u);
  }

  id v5 = *(NSObject **)(a1 + 32);
  uint64_t v6 = im_primary_queue();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100266960;
  block[3] = &unk_10097E7F0;
  id v9 = v3;
  id v7 = v3;
  dispatch_group_notify(v5, v6, block);
}

uint64_t sub_100266960(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100266CF0(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  BOOL v10 = +[IDSFoundationLog delivery];
  long long v11 = v10;
  if (v9)
  {
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      sub_10071B9B8((uint64_t)v9, a1, v11);
    }

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  else
  {
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      uint64_t v12 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138478083;
      uint64_t v22 = v12;
      __int16 v23 = 2113;
      id v24 = v7;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "Found companionLinkClient {deviceIdentifier: %{private}@, client: %{private}@}", buf, 0x16u);
    }

    uint64_t v13 = *(void *)(a1 + 40);
    id v14 = sub_1002664A4();
    long long v19 = v14;
    int v20 = &__kCFBooleanTrue;
    uint64_t v15 = +[NSDictionary dictionaryWithObjects:&v20 forKeys:&v19 count:1];
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 3221225472;
    void v16[2] = sub_100266F04;
    v16[3] = &unk_100981C38;
    id v17 = *(id *)(a1 + 32);
    id v18 = *(id *)(a1 + 48);
    [v7 sendEventID:@"ids-message" event:v13 destinationID:v8 options:v15 completion:v16];
  }
}

void sub_100266F04(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[IDSFoundationLog delivery];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = 138412546;
    uint64_t v7 = v5;
    __int16 v8 = 2112;
    id v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Finished sending message {deviceIdentifier: %@, error: %@}", (uint8_t *)&v6, 0x16u);
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_100267160(uint64_t a1, void *a2)
{
  id v6 = a2;
  id v3 = objc_alloc((Class)CUTResult);
  if (v6) {
    id v4 = [v3 initWithError:v6];
  }
  else {
    id v4 = [v3 initWithSuccess:*(void *)(a1 + 32)];
  }
  uint64_t v5 = v4;
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_1002674BC(uint64_t a1, void *a2)
{
  id v5 = a2;
  if (objc_opt_respondsToSelector())
  {
    uint64_t v3 = *(void *)(a1 + 32);
    id v4 = [*(id *)(a1 + 40) idsDeviceIdentifier];
    [v5 rapportClient:v3 didDiscoverDevice:v4];
  }
}

void sub_1002676B8(uint64_t a1, void *a2)
{
  id v5 = a2;
  if (objc_opt_respondsToSelector())
  {
    uint64_t v3 = *(void *)(a1 + 32);
    id v4 = [*(id *)(a1 + 40) idsDeviceIdentifier];
    [v5 rapportClient:v3 didLoseDevice:v4];
  }
}

void sub_100267990(void *a1, void *a2)
{
  id v3 = a2;
  if (objc_opt_respondsToSelector()) {
    [v3 rapportClient:a1[4] didReceiveMessage:a1[5] fromID:a1[6]];
  }
}

void sub_100267AD0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id v3 = [*(id *)(a1 + 32) companionLinkClient];
  (*(void (**)(uint64_t, id, void, void))(v2 + 16))(v2, v3, *(void *)(a1 + 40), 0);
}

BOOL sub_100269064(uint64_t a1, void *a2)
{
  id v3 = [a2 context];
  BOOL v4 = [v3 dataProtectionClass] == *(_DWORD *)(a1 + 32);

  return v4;
}

BOOL sub_10026913C(uint64_t a1, void *a2)
{
  id v3 = [a2 context];
  BOOL v4 = [v3 messageType] == *(id *)(a1 + 32);

  return v4;
}

void sub_10026AFAC(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8, void *a9)
{
  id v15 = a2;
  id v16 = a8;
  id v17 = a9;
  id v18 = +[IDSDaemonPriorityQueueController sharedInstance];
  [v18 assertRunningWithPriority:*(void *)(*(void *)(a1 + 32) + 192)];

  long long v19 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v20 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 138412802;
    uint64_t v57 = v20;
    __int16 v58 = 1024;
    *(_DWORD *)id v59 = a6;
    *(_WORD *)&v59[4] = 2112;
    *(void *)&v59[6] = v17;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%@ IDS internal openSocketWithOptions call returned socket %d, error %@", buf, 0x1Cu);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      uint64_t v49 = a6;
      id v51 = v17;
      uint64_t v47 = *(void *)(a1 + 32);
      _IDSLogTransport();
      if (_IDSShouldLog())
      {
        uint64_t v49 = a6;
        id v51 = v17;
        uint64_t v47 = *(void *)(a1 + 32);
        _IDSLogV();
      }
    }
  }
  if (a6 == -1)
  {
    id v35 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v36 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138412290;
      uint64_t v57 = v36;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "%@ Failed to open UTun socket, waiting...", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      uint64_t v47 = *(void *)(a1 + 32);
      _IDSLogV();
    }
    int v38 = *(void **)(a1 + 32);
    uint64_t v37 = a1 + 32;
    objc_msgSend(v38, "_nonThreadSafeStopConnection", v47, v49, v51);
    dispatch_time_t v39 = dispatch_time(0, 500000000);
    long long v40 = +[IDSDaemonPriorityQueueController sharedInstance];
    __int16 v41 = [v40 queueForPriority:*(void *)(*(void *)v37 + 192)];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10026B6FC;
    block[3] = &unk_10097E4D0;
    void block[4] = *(void *)v37;
    dispatch_after(v39, v41, block);
  }
  else
  {
    int v21 = *(id **)(a1 + 32);
    if (v21[10])
    {
      [v21[10] endSession];
      uint64_t v22 = *(void *)(a1 + 32);
      __int16 v23 = *(void **)(v22 + 80);
      *(void *)(v22 + 80) = 0;

      int v21 = *(id **)(a1 + 32);
    }
    objc_msgSend(v21, "_clearLastFallbackWithReason:", @"new local link established", v47, v49, v51);
    id v24 = *(unsigned char **)(a1 + 32);
    if (v24[329] && v24[330]) {
      [v24 _startNWConnectinForIPsecCase:a6 controlChannelVersion:v15 capabilityFlags:a3 instanceID:a4 serviceMinCompatibilityVersion:a5];
    }
    else {
      [v24 _startAndSetupSocketPairConnection:v15 capabilityFlags:a3 instanceID:a4 serviceMinCompatibilityVersion:a5 socketDescriptor:a6];
    }
    *(unsigned char *)(*(void *)(a1 + 32) + 226) = 1;
    id v25 = [objc_alloc((Class)IDSSocketPairHandshake) initWithVersionNumber:4];
    int v26 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v27 = *(void *)(a1 + 32);
      uint64_t v28 = *(void *)(v27 + 80);
      *(_DWORD *)buf = 138413058;
      uint64_t v57 = v27;
      __int16 v58 = 2112;
      *(void *)id v59 = v28;
      *(_WORD *)&v59[8] = 1024;
      *(_DWORD *)&v59[10] = a6;
      __int16 v60 = 1024;
      int v61 = 4;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%@ created %@ for socket %d - sending handshake with version %u", buf, 0x22u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        uint64_t v52 = a6;
        uint64_t v53 = 4;
        uint64_t v48 = *(void *)(a1 + 32);
        uint64_t v50 = *(void *)(v48 + 80);
        _IDSLogTransport();
        if (_IDSShouldLog())
        {
          uint64_t v52 = a6;
          uint64_t v53 = 4;
          uint64_t v48 = *(void *)(a1 + 32);
          uint64_t v50 = *(void *)(v48 + 80);
          _IDSLogV();
        }
      }
    }
    objc_msgSend(*(id *)(a1 + 32), "_sendSocketMessage:", v25, v48, v50, v52, v53);
    uint64_t v29 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v30 = *(void *)(a1 + 32);
      id v31 = [*(id *)(v30 + 16) count];
      *(_DWORD *)buf = 138412546;
      uint64_t v57 = v30;
      __int16 v58 = 2048;
      *(void *)id v59 = v31;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%@ resending %lu pending socketpair messages", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      [*(id *)(*(void *)(a1 + 32) + 16) count];
      _IDSLogV();
    }
    uint64_t v32 = *(void *)(a1 + 32);
    if (*(unsigned char *)(v32 + 256))
    {
      int v33 = *(void **)(v32 + 248);
      *(void *)(v32 + 24_Block_object_dispose(&STACK[0x300], 8) = 0;

      long long v34 = (void **)(*(void *)(a1 + 32) + 240);
    }
    else
    {
      long long v34 = (void **)(v32 + 232);
    }
    CFStringRef v42 = *v34;
    *long long v34 = 0;

    uint64_t v44 = *(void *)(a1 + 32);
    __int16 v43 = (id *)(a1 + 32);
    long long v45 = *(void **)(v44 + 16);
    v55[0] = _NSConcreteStackBlock;
    v55[1] = 3221225472;
    v55[2] = sub_10026B648;
    v55[3] = &unk_100987378;
    v55[4] = v44;
    [v45 enumerateObjectsWithOptions:2 usingBlock:v55];
    long long v46 = (void *)*((void *)*v43 + 2);
    *((void *)*v43 + 2) = 0;

    [*v43 _dequeueMessages];
    [*v43 _connectivityChanged];
  }
}

void sub_10026B648(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v6 = v3;
  if (!*(unsigned char *)(*(void *)(a1 + 32) + 256))
  {
    objc_opt_class();
    char isKindOfClass = objc_opt_isKindOfClass();
    id v3 = v6;
    if (isKindOfClass)
    {
      [v6 reset];
      id v3 = v6;
    }
  }
  id v5 = [v3 context];
  if (v5)
  {
    [*(id *)(*(void *)(a1 + 32) + 136) pushMessage:v5];
    [*(id *)(a1 + 32) _removeMessageFromStatistics:v5];
  }
}

id sub_10026B6FC(uint64_t a1)
{
  return [*(id *)(a1 + 32) _checkAndStartConnection];
}

id sub_10026BC80(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [*(id *)(a1 + 32) _encryptDataWithOTR:a2 token:a3];
}

id sub_10026BC90(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) _decryptOTREncrtypedMessage:a2];
}

id sub_10026C404(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [*(id *)(a1 + 32) _encryptDataWithOTR:a2 token:a3];
}

id sub_10026C414(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) _decryptOTREncrtypedMessage:a2];
}

void sub_10026CE28(_Unwind_Exception *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,os_activity_scope_state_s state,char a35)
{
  if (a2 == 1)
  {
    objc_begin_catch(exc_buf);
    objc_end_catch();
    JUMPOUT(0x10026CB00);
  }
  os_activity_scope_leave(&state);
  cut_arc_os_release();
  _Unwind_Resume(exc_buf);
}

void sub_10026D578(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 8));
  [WeakRetained connectionHasSpaceForMessages:*(void *)(a1 + 32) dataProtectionClass:*(unsigned int *)(a1 + 40)];
}

void sub_10026D694(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 8));
  [WeakRetained connectionIsEmpty:*(void *)(a1 + 32)];
}

void sub_10026D778(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 8));
  [WeakRetained connectionIsEmptyOfCloudMessages:*(void *)(a1 + 32)];
}

uint64_t sub_10026E384(void *a1)
{
  return (*(uint64_t (**)(void, void, void))(a1[6] + 16))(a1[6], a1[4], a1[5]);
}

id sub_10026E624(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _fallbackTimerFired];
}

void sub_10026E6C4(uint64_t a1)
{
  id v1 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v2 = *(void *)(a1 + 32);
    id v3 = [*(id *)(v2 + 24) count];
    *(_DWORD *)buf = 138412546;
    uint64_t v40 = v2;
    __int16 v41 = 2048;
    id v42 = v3;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "%@ fallback timer fired, fallback queue: %lu", buf, 0x16u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v25 = *(void *)(a1 + 32);
    id v26 = [*(id *)(v25 + 24) count];
    _IDSLogV();
  }
  id v4 = [*(id *)(*(void *)(a1 + 32) + 24) _copyForEnumerating];
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  id obj = v4;
  id v5 = [obj countByEnumeratingWithState:&v34 objects:v38 count:16];
  if (!v5)
  {

    CFMutableDictionaryRef Mutable = 0;
    id v7 = 0;
    uint64_t v30 = 0;
    uint64_t v28 = 0;
    char v31 = 0;
    double v23 = 0.0;
    goto LABEL_38;
  }
  CFMutableDictionaryRef Mutable = 0;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  id v7 = 0;
  uint64_t v28 = 0;
  char v31 = 0;
  uint64_t v8 = *(void *)v35;
  do
  {
    id v9 = 0;
    do
    {
      if (*(void *)v35 != v8) {
        objc_enumerationMutation(obj);
      }
      BOOL v10 = *(void **)(*((void *)&v34 + 1) + 8 * (void)v9);
      long long v11 = objc_msgSend(v10, "topic", v25, v26);
      uint64_t v12 = [(__CFDictionary *)Mutable objectForKey:v11];
      uint64_t v13 = v12;
      if (v12)
      {
        if (![v12 BOOLValue]) {
          goto LABEL_24;
        }
        goto LABEL_13;
      }
      if ([v10 deniedToSend])
      {
        id v14 = 0;
        if (Mutable) {
          goto LABEL_23;
        }
      }
      else
      {
        id v14 = [*(id *)(a1 + 32) _messageIsAllowedToSendMessageOnTopic:v11];
        if (Mutable) {
          goto LABEL_23;
        }
      }
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
LABEL_23:
      id v16 = +[NSNumber numberWithBool:v14];
      [(__CFDictionary *)Mutable setObject:v16 forKey:v11];

      if ((v14 & 1) == 0)
      {
LABEL_24:
        char v31 = 1;
        goto LABEL_25;
      }
LABEL_13:
      if ([*(id *)(a1 + 32) _performFallbackIfNecessary:v10])
      {
        if (v7) {
          [v7 addIndex:(char *)v9 + v29];
        }
        else {
          id v7 = [objc_alloc((Class)NSMutableIndexSet) initWithIndex:(char *)v9 + v29];
        }
      }
      else if (!v30)
      {
        [v10 timeEnqueued];
        uint64_t v30 = +[NSDate dateWithTimeIntervalSinceReferenceDate:](NSDate, "dateWithTimeIntervalSinceReferenceDate:");
        id v15 = v11;

        uint64_t v28 = v15;
      }
LABEL_25:

      id v9 = (char *)v9 + 1;
    }
    while (v5 != v9);
    id v17 = [obj countByEnumeratingWithState:&v34 objects:v38 count:16];
    id v5 = v17;
    v29 += (uint64_t)v9;
  }
  while (v17);

  if (v7)
  {
    [*(id *)(*(void *)(a1 + 32) + 24) removeObjectsAtIndexes:v7];
    if (![*(id *)(*(void *)(a1 + 32) + 24) count])
    {
      uint64_t v18 = *(void *)(a1 + 32);
      long long v19 = *(void **)(v18 + 24);
      *(void *)(v18 + 24) = 0;
    }
  }
  if (v30)
  {
    [v30 timeIntervalSinceNow];
    double v21 = v20;
    [*(id *)(a1 + 32) _fallbackTimeoutForService:v28];
    double v23 = v21 + v22;
    char v31 = 1;
  }
  else
  {
    uint64_t v30 = 0;
    if (v31) {
      double v23 = 60.0;
    }
    else {
      double v23 = 0.0;
    }
  }
LABEL_38:

  [*(id *)(*(void *)(a1 + 32) + 104) invalidate];
  id v24 = *(void **)(*(void *)(a1 + 32) + 104);
  *(void *)(*(void *)(a1 + 32) + 104) = 0;

  if (v31) {
    [*(id *)(a1 + 32) _resetFallbackTimeout:1 useNextFallback:v23];
  }
}

void sub_10026EB30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, int a17)
{
  if (a2 == 1)
  {
    objc_begin_catch(exception_object);
    objc_end_catch();
    JUMPOUT(0x10026E778);
  }
  _Unwind_Resume(exception_object);
}

id sub_10026F1A0(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _timeoutTimerFired];
}

void sub_10026F240(uint64_t a1)
{
  uint64_t v2 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    id v4 = [*(id *)(v3 + 16) count];
    id v5 = [*(id *)(*(void *)(a1 + 32) + 136) count];
    *(_DWORD *)buf = 138412802;
    uint64_t v43 = v3;
    __int16 v44 = 2048;
    id v45 = v4;
    __int16 v46 = 2048;
    id v47 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%@ timeout timer fired, sending queue: %lu %lu", buf, 0x20u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v6 = *(void *)(a1 + 32);
    id v30 = [*(id *)(v6 + 16) count];
    id v31 = [*(id *)(*(void *)(a1 + 32) + 136) count];
    uint64_t v29 = v6;
    _IDSLogV();
  }
  id v8 = [*(id *)(*(void *)(a1 + 32) + 16) _copyForEnumerating];
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  id v9 = v8;
  id v10 = [v9 countByEnumeratingWithState:&v36 objects:v41 count:16];
  if (v10)
  {
    uint64_t v11 = *(void *)v37;
    do
    {
      for (uint64_t i = 0; i != v10; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v37 != v11) {
          objc_enumerationMutation(v9);
        }
        uint64_t v13 = *(void **)(*((void *)&v36 + 1) + 8 * i);
        id v14 = objc_msgSend(v13, "context", v29, v30, v31);
        id v15 = [v14 expirationDate];
        [v15 timeIntervalSinceNow];
        BOOL v17 = v16 < 0.0;

        if (v17)
        {
          uint64_t v18 = [v13 context];
          [*(id *)(a1 + 32) _messageTimedOut:v13 localMessage:v18];
        }
      }
      id v10 = [v9 countByEnumeratingWithState:&v36 objects:v41 count:16];
    }
    while (v10);
  }

  long long v19 = [*(id *)(*(void *)(a1 + 32) + 136) messages];
  id v20 = [v19 _copyForEnumerating];

  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  id v21 = v20;
  id v22 = [v21 countByEnumeratingWithState:&v32 objects:v40 count:16];
  if (v22)
  {
    uint64_t v23 = *(void *)v33;
    do
    {
      for (j = 0; j != v22; j = (char *)j + 1)
      {
        if (*(void *)v33 != v23) {
          objc_enumerationMutation(v21);
        }
        uint64_t v25 = *(void **)(*((void *)&v32 + 1) + 8 * (void)j);
        id v26 = objc_msgSend(v25, "expirationDate", v29, v30, v31);
        [v26 timeIntervalSinceNow];
        BOOL v28 = v27 < 0.0;

        if (v28) {
          [*(id *)(a1 + 32) _messageTimedOut:0 localMessage:v25];
        }
      }
      id v22 = [v21 countByEnumeratingWithState:&v32 objects:v40 count:16];
    }
    while (v22);
  }

  [*(id *)(a1 + 32) _resetTimeout:0];
}

void sub_10026F588(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a2 == 1)
  {
    id v10 = objc_begin_catch(exception_object);
    uint64_t v11 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)(v9 - 144) = 138412290;
      *(void *)(v9 - 140) = v10;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Exception caught handling timeout timer: %@", (uint8_t *)(v9 - 144), 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      _IDSLogTransport();
    }

    objc_end_catch();
    JUMPOUT(0x10026F538);
  }
  _Unwind_Resume(exception_object);
}

void sub_100270078(uint64_t a1)
{
  uint64_t v2 = +[IDSDevicePolicyController sharedInstance];
  id v3 = [v2 shouldBlackOutDeviceWithCbuuid:*(void *)(a1 + 32)];

  id v4 = objc_alloc((Class)IDSDeliveryContext);
  uint64_t v5 = *(void *)(a1 + 72);
  uint64_t v6 = *(void *)(a1 + 40);
  id v7 = +[NSNumber numberWithDouble:*(double *)(a1 + 80)];
  id v8 = +[NSNumber numberWithBool:v3];
  uint64_t v9 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [*(id *)(a1 + 48) messageState]);
  id v14 = [v4 initWithResponseCode:v5 deviceID:v6 currentAverageRTT:v7 isDeviceBlackedOut:v8 localMessageState:v9];

  id v10 = *(void **)(a1 + 56);
  if (v10)
  {
    uint64_t v11 = [v10 domain];
    [v14 setWpConnectionErrorDomain:v11];

    uint64_t v12 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [*(id *)(a1 + 56) code]);
    [v14 setWpConnectionErrorCode:v12];

    uint64_t v13 = [*(id *)(a1 + 56) userInfo];
    [v14 setWpConnectionErrorUserInfo:v13];
  }
  (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
}

void sub_100270714(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_10027072C(uint64_t a1)
{
  return [*(id *)(a1 + 32) _dequeueMessages];
}

id sub_100270734(uint64_t a1)
{
  return [*(id *)(a1 + 32) _dequeueMessages];
}

void sub_10027073C(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  id v9 = a2;
  uint64_t v6 = [v9 topic];
  unsigned int v7 = [v6 isEqualToString:*(void *)(a1 + 32)];

  if (v7)
  {
    *a4 = 1;
    id v8 = [v9 resourcePath];

    if (v8) {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
    }
  }
}

void sub_100271084(uint64_t a1)
{
  id v1 = [*(id *)(a1 + 32) _UTunDeliveryController];
  [v1 defaultPeerSetWantsQuickRelayRequest:1];
}

uint64_t sub_100272EB8(uint64_t a1, void *a2)
{
  id v3 = [a2 topic];
  id v4 = v3;
  if (v3)
  {
    id v6 = v3;
    id v3 = [*(id *)(a1 + 32) addObject:v3];
    id v4 = v6;
  }

  return _objc_release_x1(v3, v4);
}

void sub_100272F18(uint64_t a1, void *a2)
{
  id v3 = [a2 firstObject];
  id v4 = [v3 context];
  id v6 = [v4 topic];

  uint64_t v5 = v6;
  if (v6)
  {
    [*(id *)(a1 + 32) addObject:v6];
    uint64_t v5 = v6;
  }
}

void sub_100272FA0(id a1)
{
  byte_100A4C450 = IMGetDomainBoolForKey();
}

id sub_100272FD0(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) admissionPolicyChangedForTopic:*(void *)(a1 + 40) allowed:a2];
}

id sub_100274548(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _dequeueMessagesTimerDidFire:*(void *)(a1 + 40)];
}

id sub_10027465C(uint64_t a1)
{
  uint64_t v2 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Dequeue Message Timer did Fire -- Dequeueing messages", v4, 2u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      _IDSLogTransport();
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
  }
  [*(id *)(a1 + 32) _dequeueMessages];
  return [*(id *)(a1 + 32) _invalidateMessagesDequeueTimer];
}

void sub_100274C38(uint64_t a1, void *a2, uint64_t a3)
{
  id v10 = a2;
  uint64_t v5 = [v10 context];
  id v6 = [v5 topic];
  unsigned int v7 = +[IDSDServiceController sharedInstance];
  id v8 = [v7 serviceWithPushTopic:v6];
  unsigned int v9 = [v8 dataProtectionClass];

  if (v9 == *(_DWORD *)(a1 + 48))
  {
    [*(id *)(a1 + 32) _requeueSendingMessage:v10];
    [*(id *)(a1 + 40) addIndex:a3];
  }
}

void sub_100274D10(uint64_t a1, void *a2, uint64_t a3)
{
  id v8 = a2;
  uint64_t v5 = [v8 context];
  id v6 = [v5 topic];
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();
  if ([v6 isEqualToString:*(void *)(a1 + 32)]
    && *(unsigned char *)(a1 + 56) == (isKindOfClass & 1))
  {
    [*(id *)(a1 + 40) _requeueSendingMessage:v8];
    [*(id *)(a1 + 48) addIndex:a3];
  }
}

id sub_1002756A0(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) handleOTRNegotiationComplete:a2];
}

id sub_1002756AC(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) handleOTRNegotiationTimeout:a2];
}

id sub_1002756B8(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) handleOTRNegotiationComplete:a2];
}

id sub_1002756C4(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) handleOTRNegotiationTimeout:a2];
}

void sub_10027579C(uint64_t a1)
{
  uint64_t v2 = +[IDSOTRKeyStorage sharedInstance];
  [v2 lock];

  id v3 = [*(id *)(a1 + 32) userInfo];
  id v4 = [v3 objectForKey:@"__kIDSOTRKeyStorageClassKey"];

  if ([v4 length])
  {
    uint64_t v5 = [*(id *)(*(void *)(a1 + 40) + 72) objectForKey:v4];
    id v6 = [v5 _copyForEnumerating];

    [*(id *)(*(void *)(a1 + 40) + 72) removeObjectForKey:v4];
    if ([v6 count])
    {
      unsigned int v7 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412546;
        id v30 = v4;
        __int16 v31 = 2048;
        id v32 = [v6 count];
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Class %@ storage keys are available, processing %lu pending messages", buf, 0x16u);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLogTransport())
        {
          id v20 = v4;
          id v23 = [v6 count];
          _IDSLogTransport();
          if (_IDSShouldLog())
          {
            id v8 = objc_msgSend(v6, "count", v4, v23);
            id v20 = v4;
            id v23 = v8;
            _IDSLogV();
          }
        }
      }
    }
    unsigned int v9 = +[IDSOTRKeyStorage sharedInstance];
    [v9 unlock];

    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    id v10 = v6;
    id v11 = [v10 countByEnumeratingWithState:&v24 objects:v28 count:16];
    if (v11)
    {
      uint64_t v12 = *(void *)v25;
      do
      {
        for (uint64_t i = 0; i != v11; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v25 != v12) {
            objc_enumerationMutation(v10);
          }
          id v14 = *(void **)(*((void *)&v24 + 1) + 8 * i);
          unsigned int v15 = [v14 command];
          if (v15 == 24)
          {
            [*(id *)(*(void *)(a1 + 40) + 80) processStoredIncomingMessage:v14];
          }
          else if (v15 == 23)
          {
            [*(id *)(a1 + 40) _processIncomingDataMessage:v14];
          }
        }
        id v11 = [v10 countByEnumeratingWithState:&v24 objects:v28 count:16];
      }
      while (v11);
    }
  }
  else
  {
    double v16 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      BOOL v17 = [*(id *)(a1 + 32) userInfo];
      *(_DWORD *)buf = 138412290;
      id v30 = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "UTunConnection - No class storage key specified in notification %@", buf, 0xCu);
    }
    if (os_log_shim_legacy_logging_enabled())
    {
      long long v19 = *(void **)(a1 + 32);
      uint64_t v18 = (id *)(a1 + 32);
      id v21 = [v19 userInfo];
      _IDSWarnV();

      id v22 = objc_msgSend(*v18, "userInfo", v21);
      _IDSLogV();

      id v20 = objc_msgSend(*v18, "userInfo", v22);
      _IDSLogTransport();
    }
    id v10 = +[IDSOTRKeyStorage sharedInstance];
    [v10 unlock];
  }
}

void sub_100275B8C(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x100275A98);
  }
  _Unwind_Resume(a1);
}

void sub_1002765D0(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5)
{
  id v7 = a4;
  id v8 = a5;
  unsigned int v9 = +[IDSDaemonPriorityQueueController sharedInstance];
  id v10 = [v9 queueForPriority:*(void *)(*(void *)(a1 + 32) + 192)];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1002766F0;
  block[3] = &unk_1009812A0;
  uint64_t v11 = *(void *)(a1 + 32);
  uint64_t v12 = *(void **)(a1 + 40);
  id v16 = v8;
  uint64_t v17 = v11;
  id v18 = v12;
  id v19 = v7;
  id v20 = *(id *)(a1 + 48);
  id v13 = v7;
  id v14 = v8;
  dispatch_async(v10, block);
}

uint64_t sub_1002766F0(void **a1)
{
  uint64_t v2 = sub_1002DC598(a1[4]);
  if (v2)
  {
    uint64_t v3 = v2;
    id v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      uint64_t v18 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to encrypt UTunConnection message! Error %ld", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      _IDSLogTransport();
    }
  }
  else
  {
    uint64_t v5 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *((void *)a1[5] + 26);
      id v7 = [a1[6] length];
      id v8 = [a1[7] length];
      *(_DWORD *)buf = 138412802;
      uint64_t v18 = v6;
      __int16 v19 = 2048;
      id v20 = v7;
      __int16 v21 = 2048;
      id v22 = v8;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Encrypted message for device unique ID %@  original size: %lu  encrypted size: %lu", buf, 0x20u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        uint64_t v9 = *((void *)a1[5] + 26);
        id v15 = [a1[6] length];
        id v16 = [a1[7] length];
        _IDSLogTransport();
        if (_IDSShouldLog())
        {
          objc_msgSend(a1[6], "length", v9, v15, v16);
          [a1[7] length];
          _IDSLogV();
        }
      }
    }
    if (a1[7])
    {
      id v10 = [objc_alloc((Class)IDSSocketPairEncryptedMessage) initWithData:a1[7]];
      uint64_t v11 = [a1[8] topic];
      [v10 setTopic:v11];

      uint64_t v12 = [a1[8] context];
      [v10 setContext:v12];

      objc_msgSend(*((id *)a1[5] + 10), "sendDataMessage:canFragment:", v10, objc_msgSend(a1[5], "_isMagnetConnection"));
    }
  }
  id v13 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Send public key encrypted message.", buf, 2u);
  }

  uint64_t result = os_log_shim_legacy_logging_enabled();
  if (result)
  {
    uint64_t result = _IDSShouldLog();
    if (result) {
      return _IDSLogV();
    }
  }
  return result;
}

void sub_100277060(uint64_t a1, int a2)
{
  id v4 = +[IDSDaemonPriorityQueueController sharedInstance];
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  _DWORD v6[2] = sub_100277120;
  v6[3] = &unk_100980E48;
  int v8 = a2;
  uint64_t v5 = *(void **)(a1 + 40);
  void v6[4] = *(void *)(a1 + 32);
  id v7 = v5;
  [v4 performBlockWithPriority:v6 priority:*(void *)(*(void *)(a1 + 32) + 192)];
}

void sub_100277120(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 48) == 1)
  {
    id v1 = *(void **)(a1 + 32);
    uint64_t v2 = *(void **)(a1 + 40);
    id v3 = [v2 context];
    [v1 _removeSocketPairMessage:v2 localMessage:v3 reason:@"Data protection class unavailable" responseCode:18];
  }
}

id sub_100278CF8(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _handleOTRDecryptionSuccess:*(void *)(a1 + 40)];
}

id sub_100278D04(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _handleOTRDecryptionError:*(void *)(a1 + 40)];
}

void sub_100278E0C(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, void *a6)
{
  id v8 = a4;
  id v9 = a6;
  id v10 = +[IDSDaemonPriorityQueueController sharedInstance];
  uint64_t v11 = [v10 queueForPriority:*(void *)(*(void *)(a1 + 32) + 192)];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100278F2C;
  block[3] = &unk_100981B00;
  uint64_t v12 = *(void *)(a1 + 32);
  id v13 = *(void **)(a1 + 40);
  id v17 = v9;
  uint64_t v18 = v12;
  id v19 = v13;
  id v20 = v8;
  id v21 = *(id *)(a1 + 48);
  id v14 = v8;
  id v15 = v9;
  dispatch_async(v11, block);
}

void sub_100278F2C(uint64_t a1)
{
  uint64_t v2 = sub_1002DC660(*(void **)(a1 + 32));
  if (v2)
  {
    uint64_t v3 = v2;
    id v4 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      uint64_t v23 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to decrypt UTunConnection message! Error %ld", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      _IDSLogTransport();
    }
    (*(void (**)(void))(*(void *)(a1 + 64) + 16))(*(void *)(a1 + 64));
  }
  else
  {
    uint64_t v5 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 208);
      id v7 = [*(id *)(a1 + 48) length];
      id v8 = [*(id *)(a1 + 56) length];
      *(_DWORD *)buf = 138412802;
      uint64_t v23 = v6;
      __int16 v24 = 2048;
      id v25 = v7;
      __int16 v26 = 2048;
      id v27 = v8;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Decrypted message for device unique ID %@  original size: %lu  unencrypted size: %lu", buf, 0x20u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 208);
      id v19 = [*(id *)(a1 + 48) length];
      id v21 = [*(id *)(a1 + 56) length];
      uint64_t v17 = v9;
      _IDSLogV();
    }
    id v10 = objc_msgSend(*(id *)(a1 + 40), "_UTunDeliveryController", v17, v19, v21);
    uint64_t v11 = [v10 lockedContinuityPeerID:*(void *)(*(void *)(a1 + 40) + 200)];

    if (!v11)
    {
      uint64_t v12 = *(void *)(a1 + 40);
      if (*(void *)(v12 + 208))
      {
        if (*(void *)(v12 + 200))
        {
          id v13 = OSLogHandleForIDSCategory();
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            id v14 = *(void **)(*(void *)(a1 + 40) + 200);
            uint64_t v15 = *(void *)(*(void *)(a1 + 40) + 208);
            *(_DWORD *)buf = 138412546;
            uint64_t v23 = v15;
            __int16 v24 = 2112;
            id v25 = v14;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Decrypted continuity message, lock peer %@ for btUUID %@.", buf, 0x16u);
          }

          if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
          {
            uint64_t v18 = *(void *)(*(void *)(a1 + 40) + 208);
            uint64_t v20 = *(void *)(*(void *)(a1 + 40) + 200);
            _IDSLogV();
          }
          id v16 = objc_msgSend(*(id *)(a1 + 40), "_UTunDeliveryController", v18, v20);
          [v16 lockContinuityPeer:*(void *)(*(void *)(a1 + 40) + 208) btUUID:*(void *)(*(void *)(a1 + 40) + 200)];
        }
      }
    }
    (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
  }
}

void sub_100279C48(uint64_t a1)
{
  uint64_t v2 = +[IDSDevicePolicyController sharedInstance];
  id v3 = [v2 shouldBlackOutDeviceWithCbuuid:*(void *)(a1 + 32)];

  id v4 = objc_alloc((Class)IDSDeliveryContext);
  uint64_t v5 = *(void *)(a1 + 64);
  uint64_t v6 = *(void *)(a1 + 40);
  id v7 = +[NSNumber numberWithDouble:*(double *)(a1 + 72)];
  id v8 = +[NSNumber numberWithBool:v3];
  uint64_t v9 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [*(id *)(a1 + 48) messageState]);
  id v10 = [v4 initWithResponseCode:v5 deviceID:v6 currentAverageRTT:v7 isDeviceBlackedOut:v8 localMessageState:v9];

  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
}

void sub_100279D64(uint64_t a1)
{
  id v2 = objc_alloc((Class)IDSDeliveryContext);
  uint64_t v3 = *(void *)(a1 + 64);
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = +[NSNumber numberWithDouble:*(double *)(a1 + 72)];
  uint64_t v6 = +[IDSDevicePolicyController sharedInstance];
  id v7 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", [v6 shouldBlackOutDeviceWithCbuuid:*(void *)(a1 + 40)]);
  id v8 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [*(id *)(a1 + 48) messageState]);
  id v9 = [v2 initWithResponseCode:v3 deviceID:v4 currentAverageRTT:v5 isDeviceBlackedOut:v7 localMessageState:v8];

  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
}

id sub_10027A0A0(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) sendAckForMessageWithSequenceNumber:a2];
}

void sub_10027A164(uint64_t a1, uint64_t a2)
{
  id v4 = [objc_alloc((Class)IDSSocketPairExpiredAckMessage) initWithSequenceNumber:a2];
  [*(id *)(a1 + 32) setEnabled:1];
  uint64_t v5 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412546;
    id v9 = v4;
    __int16 v10 = 1024;
    int v11 = a2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Sending Expired ack %@ for received sequence number %d", buf, 0x12u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      id v6 = v4;
      uint64_t v7 = a2;
      _IDSLogTransport();
      if (_IDSShouldLog())
      {
        id v6 = v4;
        uint64_t v7 = a2;
        _IDSLogV();
      }
    }
  }
  objc_msgSend(*(id *)(a1 + 32), "_sendSocketMessage:ignoreSequenceNumber:", v4, 1, v6, v7);
}

void sub_10027C420(void *a1)
{
  id v2 = [*(id *)(a1[4] + 232) objectForKey:a1[5]];
  if (v2)
  {
    uint64_t v3 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = a1[5];
      uint64_t v5 = a1[6];
      *(_DWORD *)buf = 138412546;
      uint64_t v9 = v4;
      __int16 v10 = 2048;
      uint64_t v11 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Aborting resource transfer receiver for %@ after %lf seconds", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        uint64_t v7 = a1[6];
        uint64_t v6 = a1[5];
        _IDSLogTransport();
        if (_IDSShouldLog())
        {
          uint64_t v7 = a1[6];
          uint64_t v6 = a1[5];
          _IDSLogV();
        }
      }
    }
    objc_msgSend(v2, "abortTransfer", v6, v7);
    [*(id *)(a1[4] + 232) removeObjectForKey:a1[5]];
  }
}

void sub_10027C5AC(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  id v7 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v8 = v7;
    uint64_t v9 = [v8 context];
    __int16 v10 = [v9 messageUUID];
    if (v10)
    {
      uint64_t v11 = [v9 messageUUID];
      unsigned int v12 = [v11 isEqualToString:*(void *)(a1 + 32)];

      if (v12)
      {
        id v13 = OSLogHandleForTransportCategory();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v14 = *(void *)(a1 + 32);
          id v15 = [*(id *)(a1 + 40) byteOffset];
          *(_DWORD *)buf = 138412802;
          uint64_t v23 = v14;
          __int16 v24 = 2048;
          id v25 = v15;
          __int16 v26 = 2048;
          id v27 = [v8 nextByte];
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "IDSSocketPairCommandResourceTransferMessage got resume message for %@ @ %llu (was sending %llu)", buf, 0x20u);
        }

        if (os_log_shim_legacy_logging_enabled())
        {
          if (_IDSShouldLogTransport())
          {
            uint64_t v16 = *(void *)(a1 + 32);
            id v20 = [*(id *)(a1 + 40) byteOffset];
            id v21 = [v8 nextByte];
            uint64_t v19 = v16;
            _IDSLogTransport();
            if (_IDSShouldLog())
            {
              uint64_t v17 = *(void *)(a1 + 32);
              id v20 = objc_msgSend(*(id *)(a1 + 40), "byteOffset", v19, v20, v21);
              id v21 = [v8 nextByte];
              uint64_t v19 = v17;
              _IDSLogV();
            }
          }
        }
        id v18 = objc_msgSend(*(id *)(a1 + 40), "byteOffset", v19, v20, v21);
        if (v18)
        {
          [v8 setNextByte:v18];
        }
        else
        {
          [*(id *)(*(void *)(a1 + 48) + 136) pushMessage:v9];
          [v8 reset];
          *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = a3;
        }
        *a4 = 1;
        *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = 1;
      }
    }
  }
}

uint64_t sub_10027C82C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10027C83C(uint64_t a1)
{
}

void sub_10027C844(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  id v8 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), a2);
    uint64_t v9 = [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) context];
    __int16 v10 = [v9 messageUUID];
    if (v10)
    {
      uint64_t v11 = [v9 messageUUID];
      unsigned int v12 = [v11 isEqualToString:*(void *)(a1 + 32)];

      if (v12)
      {
        id v13 = OSLogHandleForTransportCategory();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v14 = *(void *)(a1 + 32);
          int v15 = *(unsigned __int8 *)(a1 + 64);
          *(_DWORD *)buf = 138412546;
          uint64_t v19 = v14;
          __int16 v20 = 1024;
          int v21 = v15;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Got cancel message for %@ cancelReason %u", buf, 0x12u);
        }

        if (os_log_shim_legacy_logging_enabled())
        {
          if (_IDSShouldLogTransport())
          {
            uint64_t v16 = *(void *)(a1 + 32);
            uint64_t v17 = *(unsigned __int8 *)(a1 + 64);
            _IDSLogTransport();
            if (_IDSShouldLog())
            {
              uint64_t v16 = *(void *)(a1 + 32);
              uint64_t v17 = *(unsigned __int8 *)(a1 + 64);
              _IDSLogV();
            }
          }
        }
        objc_msgSend(*(id *)(*(void *)(a1 + 40) + 136), "dequeueMessage:", v9, v16, v17);
        *a4 = 1;
        *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = a3;
      }
    }
  }
}

void sub_10027CA70(void *a1, void *a2, uint64_t a3, unsigned char *a4)
{
  id v16 = a2;
  uint64_t v7 = [v16 messageUUID];
  if (v7)
  {
    id v8 = (void *)v7;
    uint64_t v9 = [v16 messageUUID];
    unsigned int v10 = [v9 isEqualToString:a1[4]];

    if (v10)
    {
      *a4 = 1;
      *(void *)(*(void *)(a1[5] + 8) + 24) = a3;
      uint64_t v11 = [v16 command];
      id v12 = [v11 integerValue];

      if (v12 == (id)22)
      {
        uint64_t v13 = [v16 socketPairMessage];
        uint64_t v14 = *(void *)(a1[6] + 8);
        int v15 = *(void **)(v14 + 40);
        *(void *)(v14 + 40) = v13;
      }
    }
  }
}

void sub_10027CB5C(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 56);
  if (v2 == 6)
  {
    id v10 = objc_alloc((Class)IDSDeliveryContext);
    uint64_t v4 = [*(id *)(a1 + 32) toDeviceID];
    uint64_t v5 = +[NSNumber numberWithDouble:*(double *)(a1 + 48)];
    uint64_t v6 = +[NSNumber numberWithBool:*(unsigned __int8 *)(a1 + 57)];
    uint64_t v7 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [*(id *)(a1 + 32) messageState]);
    id v8 = v10;
    uint64_t v9 = 0;
  }
  else if (v2 == 4)
  {
    id v3 = objc_alloc((Class)IDSDeliveryContext);
    uint64_t v4 = [*(id *)(a1 + 32) toDeviceID];
    uint64_t v5 = +[NSNumber numberWithDouble:*(double *)(a1 + 48)];
    uint64_t v6 = +[NSNumber numberWithBool:*(unsigned __int8 *)(a1 + 57)];
    uint64_t v7 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [*(id *)(a1 + 32) messageState]);
    id v8 = v3;
    uint64_t v9 = 16;
  }
  else
  {
    id v11 = objc_alloc((Class)IDSDeliveryContext);
    uint64_t v4 = [*(id *)(a1 + 32) toDeviceID];
    uint64_t v5 = +[NSNumber numberWithDouble:*(double *)(a1 + 48)];
    uint64_t v6 = +[NSNumber numberWithBool:*(unsigned __int8 *)(a1 + 57)];
    uint64_t v7 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [*(id *)(a1 + 32) messageState]);
    id v8 = v11;
    uint64_t v9 = 2;
  }
  id v12 = [v8 initWithResponseCode:v9 deviceID:v4 currentAverageRTT:v5 isDeviceBlackedOut:v6 localMessageState:v7];

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_10027CD5C(uint64_t a1, uint64_t a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 8));
  char v5 = objc_opt_respondsToSelector();

  if (v5)
  {
    id v14 = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 8));
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v7 = JWEncodeDictionary();
    uint64_t v8 = *(void *)(a1 + 48);
    uint64_t v9 = *(void *)(a1 + 56);
    uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 200);
    id v11 = +[NSNumber numberWithUnsignedInt:a2];
    BYTE1(v13) = *(unsigned char *)(a1 + 82);
    LOBYTE(v13) = 0;
    LOWORD(v12) = *(_WORD *)(a1 + 80);
    objc_msgSend(v14, "connection:messageReceived:topic:command:fromID:messageID:wantsAppAck:expectsPeerResponse:peerResponseIdentifier:messageUUID:isCompressed:didWakeHint:", v6, v7, v8, v9, v10, v11, v12, *(void *)(a1 + 64), *(void *)(a1 + 72), v13);
  }
}

void sub_10027D070(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = *(id *)(a1 + 32);
  if (v3)
  {
    uint64_t v5 = +[IDSSocketPairMessage messageWithData:v3];

    id v4 = (id)v5;
  }
  uint64_t v6 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v7 = *(void *)(a1 + 32);
    unsigned int v8 = [v4 command];
    uint64_t v9 = *(void *)(a1 + 40);
    if (v4 == *(id *)(a1 + 32)) {
      CFStringRef v10 = @"NO";
    }
    else {
      CFStringRef v10 = @"YES";
    }
    *(_DWORD *)buf = 138413314;
    id v20 = v4;
    __int16 v21 = 2112;
    uint64_t v22 = v7;
    __int16 v23 = 1024;
    unsigned int v24 = v8;
    __int16 v25 = 2112;
    uint64_t v26 = v9;
    __int16 v27 = 2112;
    CFStringRef v28 = v10;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "Got incoming data message {dataMessage: %@, rawMessage: %@, command %d, self: %@, didDecrypt: %@}", buf, 0x30u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v11 = *(void *)(a1 + 32);
    unsigned int v12 = [v4 command];
    if (v4 == *(id *)(a1 + 32)) {
      CFStringRef v13 = @"NO";
    }
    else {
      CFStringRef v13 = @"YES";
    }
    uint64_t v17 = *(void *)(a1 + 40);
    CFStringRef v18 = v13;
    uint64_t v15 = v11;
    uint64_t v16 = v12;
    id v14 = v4;
    _IDSLogV();
  }
  objc_msgSend(*(id *)(a1 + 40), "_processDecryptedMessage:", v4, v14, v15, v16, v17, v18);
}

void sub_10027FE9C(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {

    objc_end_catch();
    JUMPOUT(0x10027F2F4);
  }
  _Block_object_dispose(&STACK[0x280], 8);
  _Unwind_Resume(a1);
}

id sub_10028028C(uint64_t a1)
{
  return [*(id *)(a1 + 32) _checkAndStartConnection];
}

void sub_100280294(uint64_t a1, uint64_t a2)
{
  id v4 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67109120;
    unsigned int v33 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Broadcast: incoming message sequence number %u \n", buf, 8u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
  {
    uint64_t v24 = a2;
    _IDSLogTransport();
  }
  if ((objc_opt_respondsToSelector() & 1) != 0 && ([*(id *)(a1 + 32) compressed] & 1) == 0)
  {
    id v5 = *(id *)(a1 + 40);
    int v31 = 0;
  }
  else
  {
    objc_msgSend(*(id *)(a1 + 40), "_FTOptionallyDecompressData", v24);
    id v5 = (id)objc_claimAutoreleasedReturnValue();
    int v31 = 1;
  }
  objc_msgSend(*(id *)(a1 + 48), "_addIncomingMessageSize:forTopic:", objc_msgSend(v5, "length", v24), *(void *)(a1 + 56));
  id v6 = objc_msgSend(objc_alloc((Class)IDSLocalDeliveryMessageReceivedMetric), "initWithService:isFromDefaultPairedDevice:messageSize:linkType:priority:", *(void *)(a1 + 56), *(unsigned char *)(a1 + 90) != 0, objc_msgSend(v5, "length"), objc_msgSend(*(id *)(a1 + 48), "_currentLink"), *(void *)(*(void *)(a1 + 48) + 192));
  uint64_t v7 = +[IDSCoreAnalyticsLogger defaultLogger];
  [v7 logMetric:v6];

  unsigned int v8 = +[IDSAWDLogging sharedInstance];
  objc_msgSend(v8, "messageReceivedForService:isFromDefaultPairedDevice:messageSize:linkType:priority:", *(void *)(a1 + 56), *(unsigned char *)(a1 + 90) != 0, objc_msgSend(v5, "length"), objc_msgSend(*(id *)(a1 + 48), "_currentLink"), *(void *)(*(void *)(a1 + 48) + 192));

  uint64_t v9 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    unsigned int v10 = [*(id *)(a1 + 40) length];
    int v11 = *(unsigned __int16 *)(a1 + 88);
    CFStringRef v12 = @"NO";
    *(_DWORD *)buf = 67109890;
    if (v31) {
      CFStringRef v12 = @"YES";
    }
    unsigned int v33 = v10;
    __int16 v34 = 1024;
    int v35 = v11;
    __int16 v36 = 1024;
    int v37 = a2;
    __int16 v38 = 2112;
    CFStringRef v39 = v12;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "* Receiving local message payload of size: %d for streamID: %d  messageSequenceNumber %d  compressed %@", buf, 0x1Eu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    id v13 = [*(id *)(a1 + 40) length];
    CFStringRef v14 = @"NO";
    if (v31) {
      CFStringRef v14 = @"YES";
    }
    uint64_t v28 = a2;
    CFStringRef v29 = v14;
    id v25 = v13;
    uint64_t v27 = *(unsigned __int16 *)(a1 + 88);
    _IDSLogV();
  }
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 48) + 8));
  char v16 = objc_opt_respondsToSelector();

  if (v16)
  {
    id v17 = objc_loadWeakRetained((id *)(*(void *)(a1 + 48) + 8));
    uint64_t v18 = *(void *)(a1 + 48);
    uint64_t v19 = *(void *)(a1 + 56);
    uint64_t v20 = *(void *)(a1 + 64);
    if (*(unsigned char *)(a1 + 90)) {
      __int16 v21 = (uint64_t *)&kIDSDefaultPairedDeviceID;
    }
    else {
      __int16 v21 = (uint64_t *)(*(void *)(a1 + 48) + 200);
    }
    uint64_t v22 = *v21;
    __int16 v23 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a2, v25, v27, v28, v29);
    BYTE1(v30) = *(unsigned char *)(a1 + 93);
    LOBYTE(v30) = v31;
    LOWORD(v26) = *(_WORD *)(a1 + 91);
    objc_msgSend(v17, "connection:messageReceived:topic:command:fromID:messageID:wantsAppAck:expectsPeerResponse:peerResponseIdentifier:messageUUID:isCompressed:didWakeHint:", v18, v5, v19, v20, v22, v23, v26, *(void *)(a1 + 72), *(void *)(a1 + 80), v30);
  }
}

void sub_1002806E4(uint64_t a1, void *a2)
{
  int v2 = (int)a2;
  id v3 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67109120;
    LODWORD(v46) = v2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "Broadcast: incoming protobuf sequence number %u \n", buf, 8u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
  {
    id v38 = a2;
    _IDSLogTransport();
  }
  if (objc_opt_respondsToSelector()) {
    unsigned int v4 = [*(id *)(a1 + 32) compressed];
  }
  else {
    unsigned int v4 = 1;
  }
  id v5 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    id v6 = *(void **)(a1 + 40);
    int v7 = *(unsigned __int16 *)(a1 + 88);
    CFStringRef v8 = @"NO";
    if (v4) {
      CFStringRef v8 = @"YES";
    }
    *(_DWORD *)buf = 138412802;
    id v46 = v6;
    __int16 v47 = 1024;
    LODWORD(v48[0]) = v7;
    WORD2(v48[0]) = 2112;
    *(void *)((char *)v48 + 6) = v8;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "* Receiving local protobuf %@ for streamID %d  compressed %@", buf, 0x1Cu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    CFStringRef v9 = @"NO";
    if (v4) {
      CFStringRef v9 = @"YES";
    }
    id v40 = (id)*(unsigned __int16 *)(a1 + 88);
    CFStringRef v41 = v9;
    id v38 = *(id *)(a1 + 40);
    _IDSLogV();
  }
  if (v4)
  {
    unsigned int v10 = [*(id *)(a1 + 40) data];
    int v11 = [v10 _FTOptionallyDecompressData];

    CFStringRef v12 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      id v13 = [*(id *)(a1 + 40) data];
      id v14 = [v13 length];
      id v15 = [v11 length];
      *(_DWORD *)buf = 134218240;
      id v46 = v14;
      __int16 v47 = 2048;
      v48[0] = v15;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Decompressed local protobuf message data from: %lu  to: %lu", buf, 0x16u);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      char v16 = [*(id *)(a1 + 40) data];
      id v38 = [v16 length];
      id v40 = [v11 length];
      _IDSLogV();
    }
    objc_msgSend(*(id *)(a1 + 40), "setData:", v11, v38, v40, v41);
  }
  id v17 = *(void **)(a1 + 48);
  uint64_t v18 = objc_msgSend(*(id *)(a1 + 40), "data", v38);
  objc_msgSend(v17, "_addIncomingMessageSize:forTopic:", objc_msgSend(v18, "length"), *(void *)(a1 + 56));

  id v19 = objc_alloc((Class)IDSLocalDeliveryMessageReceivedMetric);
  uint64_t v20 = *(void *)(a1 + 56);
  BOOL v21 = *(unsigned char *)(a1 + 90) != 0;
  uint64_t v22 = [*(id *)(a1 + 40) data];
  id v23 = objc_msgSend(v19, "initWithService:isFromDefaultPairedDevice:messageSize:linkType:priority:", v20, v21, objc_msgSend(v22, "length"), objc_msgSend(*(id *)(a1 + 48), "_currentLink"), *(void *)(*(void *)(a1 + 48) + 192));

  uint64_t v24 = +[IDSCoreAnalyticsLogger defaultLogger];
  [v24 logMetric:v23];

  id v25 = +[IDSAWDLogging sharedInstance];
  uint64_t v26 = *(void *)(a1 + 56);
  BOOL v27 = *(unsigned char *)(a1 + 90) != 0;
  uint64_t v28 = [*(id *)(a1 + 40) data];
  objc_msgSend(v25, "messageReceivedForService:isFromDefaultPairedDevice:messageSize:linkType:priority:", v26, v27, objc_msgSend((id)v28, "length"), objc_msgSend(*(id *)(a1 + 48), "_currentLink"), *(void *)(*(void *)(a1 + 48) + 192));

  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 48) + 8));
  LOBYTE(v2_Block_object_dispose(&STACK[0x300], 8) = objc_opt_respondsToSelector();

  if (v28)
  {
    id v30 = objc_loadWeakRetained((id *)(*(void *)(a1 + 48) + 8));
    uint64_t v31 = *(void *)(a1 + 48);
    uint64_t v32 = *(void *)(a1 + 40);
    uint64_t v33 = *(void *)(a1 + 56);
    uint64_t v34 = *(void *)(a1 + 64);
    if (*(unsigned char *)(a1 + 90)) {
      int v35 = (uint64_t *)&kIDSDefaultPairedDeviceID;
    }
    else {
      int v35 = (uint64_t *)(*(void *)(a1 + 48) + 200);
    }
    uint64_t v36 = *v35;
    int v37 = +[NSNumber numberWithUnsignedInt:a2];
    BYTE1(v42) = *(unsigned char *)(a1 + 93);
    LOBYTE(v42) = v4;
    LOWORD(v39) = *(_WORD *)(a1 + 91);
    objc_msgSend(v30, "connection:protobufReceived:topic:command:fromID:messageID:wantsAppAck:expectsPeerResponse:peerResponseIdentifier:messageUUID:isCompressed:didWakeHint:", v31, v32, v33, v34, v36, v37, v39, *(void *)(a1 + 72), *(void *)(a1 + 80), v42);
  }
}

void sub_100280C84(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    unsigned int v5 = [*(id *)(a1 + 32) length];
    int v6 = *(unsigned __int16 *)(a1 + 80);
    if (*(unsigned char *)(a1 + 82)) {
      CFStringRef v7 = @"YES";
    }
    else {
      CFStringRef v7 = @"NO";
    }
    *(_DWORD *)buf = 67109890;
    unsigned int v30 = v5;
    __int16 v31 = 1024;
    int v32 = v6;
    __int16 v33 = 1024;
    int v34 = a2;
    __int16 v35 = 2112;
    CFStringRef v36 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "* Receiving local data payload of size: %d   for streamID: %d  messageSequenceNumber %d  compressed %@", buf, 0x1Eu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    id v8 = [*(id *)(a1 + 32) length];
    if (*(unsigned char *)(a1 + 82)) {
      CFStringRef v9 = @"YES";
    }
    else {
      CFStringRef v9 = @"NO";
    }
    uint64_t v26 = a2;
    CFStringRef v27 = v9;
    id v23 = v8;
    uint64_t v25 = *(unsigned __int16 *)(a1 + 80);
    _IDSLogV();
  }
  objc_msgSend(*(id *)(a1 + 40), "_addIncomingMessageSize:forTopic:", objc_msgSend(*(id *)(a1 + 32), "length", v23, v25, v26, v27), *(void *)(a1 + 48));
  id v10 = objc_msgSend(objc_alloc((Class)IDSLocalDeliveryMessageReceivedMetric), "initWithService:isFromDefaultPairedDevice:messageSize:linkType:priority:", *(void *)(a1 + 48), *(unsigned char *)(a1 + 83) != 0, objc_msgSend(*(id *)(a1 + 32), "length"), objc_msgSend(*(id *)(a1 + 40), "_currentLink"), *(void *)(*(void *)(a1 + 40) + 192));
  int v11 = +[IDSCoreAnalyticsLogger defaultLogger];
  [v11 logMetric:v10];

  CFStringRef v12 = +[IDSAWDLogging sharedInstance];
  objc_msgSend(v12, "messageReceivedForService:isFromDefaultPairedDevice:messageSize:linkType:priority:", *(void *)(a1 + 48), *(unsigned char *)(a1 + 83) != 0, objc_msgSend(*(id *)(a1 + 32), "length"), objc_msgSend(*(id *)(a1 + 40), "_currentLink"), *(void *)(*(void *)(a1 + 40) + 192));

  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 40) + 8));
  char v14 = objc_opt_respondsToSelector();

  if (v14)
  {
    id v15 = objc_loadWeakRetained((id *)(*(void *)(a1 + 40) + 8));
    uint64_t v16 = *(void *)(a1 + 40);
    uint64_t v17 = *(void *)(a1 + 32);
    uint64_t v18 = *(void *)(a1 + 48);
    uint64_t v19 = *(void *)(a1 + 56);
    if (*(unsigned char *)(a1 + 83)) {
      uint64_t v20 = (uint64_t *)&kIDSDefaultPairedDeviceID;
    }
    else {
      uint64_t v20 = (uint64_t *)(v16 + 200);
    }
    uint64_t v21 = *v20;
    uint64_t v22 = +[NSNumber numberWithUnsignedInt:a2];
    BYTE1(v2_Block_object_dispose(&STACK[0x300], 8) = *(unsigned char *)(a1 + 86);
    LOBYTE(v2_Block_object_dispose(&STACK[0x300], 8) = *(unsigned char *)(a1 + 82);
    LOWORD(v24) = *(_WORD *)(a1 + 84);
    objc_msgSend(v15, "connection:dataReceived:topic:command:fromID:messageID:wantsAppAck:expectsPeerResponse:peerResponseIdentifier:messageUUID:isCompressed:didWakeHint:", v16, v17, v18, v19, v21, v22, v24, *(void *)(a1 + 64), *(void *)(a1 + 72), v28);
  }
}

void sub_100280FEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  _DWORD v11[2] = sub_1002810A0;
  void v11[3] = &unk_100987730;
  id v8 = *(void **)(a1 + 32);
  id v9 = *(id *)(a1 + 40);
  uint64_t v10 = *(void *)(a1 + 48);
  id v12 = v9;
  uint64_t v13 = v10;
  uint64_t v14 = a4;
  uint64_t v15 = a3;
  [v8 _processMessage:a2 withSequenceNumberBlock:v11];
}

id sub_1002810A0(uint64_t a1, int a2)
{
  id result = [*(id *)(a1 + 32) sequenceNumber];
  if (result == a2)
  {
    uint64_t v5 = *(void *)(a1 + 56);
    **(unsigned char **)(a1 + 4_Block_object_dispose(&STACK[0x300], 8) = 1;
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v5;
  }
  return result;
}

void sub_1002810EC(uint64_t a1)
{
  id v2 = objc_alloc((Class)IDSDeliveryContext);
  id v3 = [*(id *)(a1 + 32) toDeviceID];
  unsigned int v4 = +[NSNumber numberWithDouble:*(double *)(a1 + 48)];
  uint64_t v5 = +[NSNumber numberWithBool:*(unsigned __int8 *)(a1 + 56)];
  int v6 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [*(id *)(a1 + 32) messageState]);
  id v7 = [v2 initWithResponseCode:12 deviceID:v3 currentAverageRTT:v4 isDeviceBlackedOut:v5 localMessageState:v6];

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_1002811E8(uint64_t a1)
{
  id v2 = objc_alloc((Class)IDSDeliveryContext);
  id v3 = [*(id *)(a1 + 32) toDeviceID];
  unsigned int v4 = +[NSNumber numberWithDouble:*(double *)(a1 + 48)];
  uint64_t v5 = +[NSNumber numberWithBool:*(unsigned __int8 *)(a1 + 56)];
  int v6 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [*(id *)(a1 + 32) messageState]);
  id v7 = [v2 initWithResponseCode:0 deviceID:v3 currentAverageRTT:v4 isDeviceBlackedOut:v5 localMessageState:v6];

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_1002812E4(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67109120;
    int v15 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Broadcast: incoming app ack sequence number %u \n", buf, 8u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
  {
    uint64_t v13 = a2;
    _IDSLogTransport();
  }
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 8));
  char v6 = objc_opt_respondsToSelector();

  if (v6)
  {
    id v7 = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 8));
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v9 = *(void *)(a1 + 40);
    if (*(unsigned char *)(a1 + 56)) {
      uint64_t v10 = (uint64_t *)&kIDSDefaultPairedDeviceID;
    }
    else {
      uint64_t v10 = (uint64_t *)(v8 + 200);
    }
    uint64_t v11 = *v10;
    id v12 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a2, v13);
    [v7 connection:v8 receivedAppLevelAckWithTopic:v9 fromID:v11 messageID:v12 peerResponseIdentifier:*(void *)(a1 + 48)];
  }
}

void sub_100281488(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v5 = [*(id *)(a1 + 32) length];
    int v6 = *(unsigned __int16 *)(a1 + 80);
    if (*(unsigned char *)(a1 + 82)) {
      CFStringRef v7 = @"YES";
    }
    else {
      CFStringRef v7 = @"NO";
    }
    *(_DWORD *)buf = 67109890;
    unsigned int v25 = v5;
    __int16 v26 = 1024;
    int v27 = v6;
    __int16 v28 = 1024;
    int v29 = a2;
    __int16 v30 = 2112;
    CFStringRef v31 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "* GOT SOCKET PAIR COMMAND MESSAGE OUTGOING NICE PROXY Receiving local data payload of size: %d   for streamID: %d  messageSequenceNumber %d  compressed %@", buf, 0x1Eu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
  {
    id v8 = [*(id *)(a1 + 32) length];
    uint64_t v9 = *(unsigned char *)(a1 + 82) ? @"YES" : @"NO";
    id v23 = v9;
    id v21 = v8;
    uint64_t v22 = *(unsigned __int16 *)(a1 + 80);
    _IDSLogTransport();
    if (_IDSShouldLog())
    {
      id v10 = objc_msgSend(*(id *)(a1 + 32), "length", v21, v22, a2, v23);
      if (*(unsigned char *)(a1 + 82)) {
        CFStringRef v11 = @"YES";
      }
      else {
        CFStringRef v11 = @"NO";
      }
      id v23 = (__CFString *)v11;
      id v21 = v10;
      _IDSLogV();
    }
  }
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 40) + 8));
  char v13 = objc_opt_respondsToSelector();

  if (v13)
  {
    id v14 = objc_loadWeakRetained((id *)(*(void *)(a1 + 40) + 8));
    uint64_t v15 = *(void *)(a1 + 40);
    uint64_t v16 = *(void *)(a1 + 32);
    uint64_t v17 = *(void *)(a1 + 48);
    uint64_t v18 = *(void *)(a1 + 56);
    uint64_t v19 = *(void *)(v15 + 200);
    uint64_t v20 = +[NSNumber numberWithUnsignedInt:a2];
    BYTE1(v23) = *(unsigned char *)(a1 + 85);
    LOBYTE(v23) = *(unsigned char *)(a1 + 82);
    LOWORD(v21) = *(_WORD *)(a1 + 83);
    objc_msgSend(v14, "connection:dataReceived:topic:command:fromID:messageID:wantsAppAck:expectsPeerResponse:peerResponseIdentifier:messageUUID:isCompressed:didWakeHint:", v15, v16, v17, v18, v19, v20, v21, *(void *)(a1 + 64), *(void *)(a1 + 72), v23);
  }
}

void sub_100281718(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v5 = [*(id *)(a1 + 32) length];
    int v6 = *(unsigned __int16 *)(a1 + 80);
    if (*(unsigned char *)(a1 + 82)) {
      CFStringRef v7 = @"YES";
    }
    else {
      CFStringRef v7 = @"NO";
    }
    *(_DWORD *)buf = 67109890;
    unsigned int v28 = v5;
    __int16 v29 = 1024;
    int v30 = v6;
    __int16 v31 = 1024;
    int v32 = a2;
    __int16 v33 = 2112;
    CFStringRef v34 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "* (PROCESSED) GOT SOCKET PAIR COMMAND MESSAGE INCOMMING NICE PROXY Receiving local data payload of size: %d   for streamID: %d  messageSequenceNumber %d  compressed %@", buf, 0x1Eu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
  {
    id v8 = [*(id *)(a1 + 32) length];
    uint64_t v9 = *(unsigned char *)(a1 + 82) ? @"YES" : @"NO";
    uint64_t v24 = a2;
    unsigned int v25 = v9;
    id v21 = v8;
    uint64_t v23 = *(unsigned __int16 *)(a1 + 80);
    _IDSLogTransport();
    if (_IDSShouldLog())
    {
      id v10 = objc_msgSend(*(id *)(a1 + 32), "length", v21, v23, a2, v25);
      if (*(unsigned char *)(a1 + 82)) {
        CFStringRef v11 = @"YES";
      }
      else {
        CFStringRef v11 = @"NO";
      }
      uint64_t v24 = a2;
      unsigned int v25 = (__CFString *)v11;
      id v21 = v10;
      uint64_t v23 = *(unsigned __int16 *)(a1 + 80);
      _IDSLogV();
    }
  }
  id v12 = objc_msgSend(*(id *)(a1 + 32), "_FTOptionallyDecompressData", v21, v23, v24, v25);
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 40) + 8));
  char v14 = objc_opt_respondsToSelector();

  if (v14)
  {
    id v15 = objc_loadWeakRetained((id *)(*(void *)(a1 + 40) + 8));
    uint64_t v16 = *(void *)(a1 + 40);
    uint64_t v17 = *(void *)(a1 + 48);
    uint64_t v18 = *(void *)(a1 + 56);
    uint64_t v19 = *(void *)(v16 + 200);
    uint64_t v20 = +[NSNumber numberWithUnsignedInt:a2];
    BYTE1(v26) = *(unsigned char *)(a1 + 85);
    LOBYTE(v26) = *(unsigned char *)(a1 + 82);
    LOWORD(v22) = *(_WORD *)(a1 + 83);
    objc_msgSend(v15, "connection:messageReceived:topic:command:fromID:messageID:wantsAppAck:expectsPeerResponse:peerResponseIdentifier:messageUUID:isCompressed:didWakeHint:", v16, v12, v17, v18, v19, v20, v22, *(void *)(a1 + 64), *(void *)(a1 + 72), v26);
  }
}

void sub_1002819B8(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v5 = [*(id *)(a1 + 32) length];
    int v6 = *(unsigned __int16 *)(a1 + 80);
    if (*(unsigned char *)(a1 + 82)) {
      CFStringRef v7 = @"YES";
    }
    else {
      CFStringRef v7 = @"NO";
    }
    *(_DWORD *)buf = 67109890;
    *(_DWORD *)CFStringRef v34 = v5;
    *(_WORD *)&void v34[4] = 1024;
    *(_DWORD *)&v34[6] = v6;
    __int16 v35 = 1024;
    int v36 = a2;
    __int16 v37 = 2112;
    CFStringRef v38 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "* (PROCESSED) GOT SOCKET PAIR COMMAND MESSAGE iMessage Command Receiving local data payload of size: %d   for streamID: %d  messageSequenceNumber %d  compressed %@", buf, 0x1Eu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
  {
    id v8 = [*(id *)(a1 + 32) length];
    uint64_t v9 = *(unsigned char *)(a1 + 82) ? @"YES" : @"NO";
    uint64_t v30 = a2;
    __int16 v31 = v9;
    id v27 = v8;
    uint64_t v29 = *(unsigned __int16 *)(a1 + 80);
    _IDSLogTransport();
    if (_IDSShouldLog())
    {
      id v10 = objc_msgSend(*(id *)(a1 + 32), "length", v27, v29, a2, v31);
      if (*(unsigned char *)(a1 + 82)) {
        CFStringRef v11 = @"YES";
      }
      else {
        CFStringRef v11 = @"NO";
      }
      uint64_t v30 = a2;
      __int16 v31 = (__CFString *)v11;
      id v27 = v10;
      uint64_t v29 = *(unsigned __int16 *)(a1 + 80);
      _IDSLogV();
    }
  }
  id v12 = objc_msgSend(*(id *)(a1 + 32), "_FTOptionallyDecompressData", v27, v29, v30, v31);
  char v13 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v14 = @"YES";
    if (!v12) {
      CFStringRef v14 = @"NO";
    }
    *(_DWORD *)buf = 138412290;
    *(void *)CFStringRef v34 = v14;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "DECOMPRESSED IMESSAGE DECRYPTED DATA NOT NIL: %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  id v15 = objc_msgSend(objc_alloc((Class)NSDictionary), "initWithObjectsAndKeys:", v12, @"dd", *(void *)(a1 + 40), @"U", 0);
  uint64_t v16 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 138412290;
    *(void *)CFStringRef v34 = v17;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Passing %@ Down to UTUN", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    uint64_t v28 = *(void *)(a1 + 40);
    _IDSLogV();
  }
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 48) + 8));
  char v19 = objc_opt_respondsToSelector();

  if (v19)
  {
    id v20 = objc_loadWeakRetained((id *)(*(void *)(a1 + 48) + 8));
    uint64_t v21 = *(void *)(a1 + 48);
    uint64_t v22 = JWEncodeDictionary();
    uint64_t v23 = *(void *)(a1 + 56);
    uint64_t v24 = *(void *)(a1 + 64);
    uint64_t v25 = *(void *)(*(void *)(a1 + 48) + 200);
    uint64_t v26 = +[NSNumber numberWithUnsignedInt:a2];
    BYTE1(v32) = *(unsigned char *)(a1 + 85);
    LOBYTE(v32) = *(unsigned char *)(a1 + 82);
    LOWORD(v2_Block_object_dispose(&STACK[0x300], 8) = *(_WORD *)(a1 + 83);
    objc_msgSend(v20, "connection:messageReceived:topic:command:fromID:messageID:wantsAppAck:expectsPeerResponse:peerResponseIdentifier:messageUUID:isCompressed:didWakeHint:", v21, v22, v23, v24, v25, v26, v28, *(void *)(a1 + 72), *(void *)(a1 + 40), v32);
  }
}

void sub_100281E6C(id a1)
{
  id v1 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Popping dialog to alert the user of the IDS version mismatch", v2, 2u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  if (qword_100A4C470 != -1) {
    dispatch_once(&qword_100A4C470, &stru_100987810);
  }
  if (off_100A4C468) {
    off_100A4C468(@"IDS", @"IDS version mismatch", 3, 152);
  }
}

void sub_100281F80(id a1)
{
  off_100A4C468 = (uint64_t (*)(void, void, void, void))CUTWeakLinkSymbol();
}

id sub_100283060(uint64_t a1)
{
  return _[*(id *)(a1 + 32) heartbeat];
}

void sub_1002831EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100283208(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained timedOutWaitingForSMS];
}

void sub_10028374C(uint64_t a1, void *a2)
{
  id v3 = +[IMRGLog sms];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    unsigned int v5 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Received notification that SIM setup did complete { observer: %@ }", (uint8_t *)&v4, 0xCu);
  }

  if (a2) {
    [a2 _SIMSetupDidComplete];
  }
}

void sub_100284674()
{
}

void sub_1002846B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,os_activity_scope_state_s state,char a35)
{
}

void sub_1002846D0(uint64_t a1, int a2)
{
  if (!a2) {
    sub_1002846D4();
  }
  objc_terminate();
}

void sub_100284BE8()
{
}

void sub_100284C30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,os_activity_scope_state_s state,char a35)
{
}

void sub_100284C48(uint64_t a1, int a2)
{
  if (!a2) {
    sub_100284C4C();
  }
  objc_terminate();
}

id sub_100285468(uint64_t a1)
{
  id v2 = +[IMRGLog sms];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 40)) {
      CFStringRef v3 = @"YES";
    }
    else {
      CFStringRef v3 = @"NO";
    }
    int v5 = 138412290;
    CFStringRef v6 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Received PNRReadyStateNotification { state: %@", (uint8_t *)&v5, 0xCu);
  }

  return [*(id *)(a1 + 32) _scheduleHeartbeat:5.0];
}

void sub_100285718(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
}

void sub_100285734(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    int v3 = *(unsigned __int8 *)(a1 + 48);
    int v4 = +[IMRGLog sms];
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (v3)
    {
      if (v5)
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Successfully sent registration request", buf, 2u);
      }

      [WeakRetained handleRegistrationSMSSuccessfullyDeliveredWithTelephonyTimeout:*(void *)(a1 + 32)];
    }
    else
    {
      if (v5)
      {
        *(_WORD *)CFStringRef v6 = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Failed to send registration request", v6, 2u);
      }

      [WeakRetained handleRegistrationSMSDeliveryFailed];
    }
  }
}

void sub_100285980(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
}

void sub_10028599C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    unsigned int v3 = [*(id *)(a1 + 32) success];
    int v4 = +[IMRGLog sms];
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (v3)
    {
      if (v5)
      {
        CFStringRef v6 = [*(id *)(a1 + 32) phoneNumber];
        CFStringRef v7 = [*(id *)(a1 + 32) signature];
        *(_DWORD *)buf = 138412546;
        id v10 = v6;
        __int16 v11 = 2112;
        id v12 = v7;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Handling incoming phone number registration response { phoneNumber: %@, signature: %@ }", buf, 0x16u);
      }
      [WeakRetained handleIncomingSMSForResponse:*(void *)(a1 + 32)];
    }
    else
    {
      if (v5)
      {
        id v8 = [*(id *)(a1 + 32) status];
        *(_DWORD *)buf = 138412290;
        id v10 = v8;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Received failed status in phone number registration response { status: %@ }", buf, 0xCu);
      }
      im_dispatch_after_primary_queue();
    }
  }
}

id sub_100285B64(uint64_t a1)
{
  return [*(id *)(a1 + 32) handleRegistrationSMSDeliveryFailed];
}

void sub_100286218(id a1)
{
  byte_100A4C480 = IMGetDomainBoolForKey();
}

id sub_1002862D0(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _smsDeliveryClear];
}

void sub_1002866D0(uint64_t a1, char a2, char a3, void *a4)
{
  id v7 = a4;
  id v8 = im_primary_queue();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10028679C;
  block[3] = &unk_100980550;
  char v14 = a2;
  char v15 = a3;
  uint64_t v9 = *(void *)(a1 + 32);
  id v12 = v7;
  uint64_t v13 = v9;
  id v10 = v7;
  dispatch_async(v8, block);
}

void sub_10028679C(uint64_t a1)
{
  id v2 = +[IMRGLog sms];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v3 = @"YES";
    if (*(unsigned char *)(a1 + 48)) {
      CFStringRef v4 = @"YES";
    }
    else {
      CFStringRef v4 = @"NO";
    }
    uint64_t v5 = *(void *)(a1 + 32);
    if (!*(unsigned char *)(a1 + 49)) {
      CFStringRef v3 = @"NO";
    }
    int v17 = 138412802;
    CFStringRef v18 = v4;
    __int16 v19 = 2112;
    CFStringRef v20 = v3;
    __int16 v21 = 2112;
    uint64_t v22 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Phone number registration request issued { sendSuccess: %@, shouldContinue: %@, error: %@ }", (uint8_t *)&v17, 0x20u);
  }

  if (*(unsigned char *)(a1 + 48))
  {
    id v6 = objc_alloc_init((Class)NSDate);
    uint64_t v7 = *(void *)(a1 + 40);
    id v8 = *(void **)(v7 + 72);
    *(void *)(v7 + 72) = v6;

    uint64_t v9 = +[IMRGLog sms];
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v17) = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Setting watch for phone number validation request timeout", (uint8_t *)&v17, 2u);
    }

    [*(id *)(a1 + 40) _scheduleSMSTimeout:1800.0];
    [*(id *)(a1 + 40) _clearSMSDeliveryTimeout];
    id v10 = *(void **)(a1 + 40);
    __int16 v11 = [v10 arbiter];
    [v11 minimumIntervalBetweenValidationAttempts];
    objc_msgSend(v10, "_setSMSDeliveryTimeout:");
  }
  else
  {
    int v12 = *(unsigned __int8 *)(a1 + 49);
    uint64_t v13 = +[IMRGLog sms];
    BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
    if (v12)
    {
      if (v14)
      {
        CFStringRef v15 = *(const __CFString **)(a1 + 32);
        int v17 = 138412290;
        CFStringRef v18 = v15;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Error sending phone number validation request -- current mechanism failed { error: %@ }", (uint8_t *)&v17, 0xCu);
      }

      [*(id *)(a1 + 40) handleRegistrationSMSDeliveryFailedWithShouldBypassRetry:1];
    }
    else
    {
      if (v14)
      {
        int v16 = *(_DWORD *)(*(void *)(a1 + 40) + 48);
        int v17 = 67109120;
        LODWORD(v1_Block_object_dispose(&STACK[0x300], 8) = v16;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Error sending phone number validation request -- CT instructed us to stop { attemptCount: %d }", (uint8_t *)&v17, 8u);
      }

      [*(id *)(a1 + 40) _notifyFailureWithError:3];
      [*(id *)(a1 + 40) resetSMSCounter];
    }
  }
}

void sub_100287200(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a5;
  int v12 = +[IMRGLog sms];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    int v21 = 138412802;
    id v22 = v10;
    __int16 v23 = 2048;
    uint64_t v24 = a4;
    __int16 v25 = 2112;
    id v26 = v11;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Received preflight response { error: %@, resultCode: %ld, resultDictionary: %@ }", (uint8_t *)&v21, 0x20u);
  }

  id v13 = v9;
  BOOL v14 = v13;
  if (a4)
  {
    unint64_t v15 = a4 & 0xFFFFFFFFFFFFFFF7;
    int v16 = +[IMRGLog sms];
    BOOL v17 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
    if (v15 == 6001)
    {
      if (v17)
      {
        LOWORD(v21) = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Failed preflight -- failing phone number validation", (uint8_t *)&v21, 2u);
      }

      [*(id *)(a1 + 32) setCurrentPreflightStack:0];
      [*(id *)(a1 + 32) _notifyFailureWithError:36];
    }
    else
    {
      if (v17)
      {
        LOWORD(v21) = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Preflight unsuccessful -- cancelling scheduled heartbeat", (uint8_t *)&v21, 2u);
      }

      [*(id *)(a1 + 32) setCurrentPreflightStack:0];
      *(void *)(*(void *)(a1 + 32) + 16) = 1;
      [*(id *)(a1 + 32) _cancelScheduledHeartbeat];
    }
  }
  else
  {
    CFStringRef v18 = [v13 responseMechanisms];
    __int16 v19 = +[IMRGLog sms];
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      int v21 = 138412290;
      id v22 = v18;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Sending phone number verification { mechanisms: %@ }", (uint8_t *)&v21, 0xCu);
    }

    CFStringRef v20 = [[IDSPreflightStack alloc] initWithIMSI:*(void *)(a1 + 40) PLMN:*(void *)(a1 + 48) validationMechanisms:v18];
    [*(id *)(a1 + 32) setCurrentPreflightStack:v20];

    [*(id *)(a1 + 32) _performHighestPriorityPreflightVerification];
  }
}

id sub_100287C3C(uint64_t a1, int a2)
{
  *(unsigned char *)(*(void *)(a1 + 32) + 60) = 0;
  CFStringRef v4 = +[IMRGLog sms];
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v5)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Obtained permission to send SMS from requestor -- kicking identification", buf, 2u);
    }

    *(unsigned char *)(*(void *)(a1 + 32) + 61) = 1;
    return [*(id *)(a1 + 32) _tryToSendSMSIdentification];
  }
  else
  {
    if (v5)
    {
      *(_WORD *)uint64_t v7 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Did not obtain permission to send SMS from requestor -- failing registration", v7, 2u);
    }

    *(unsigned char *)(*(void *)(a1 + 32) + 61) = 0;
    return [*(id *)(a1 + 32) _notifyFailureWithError:2];
  }
}

void sub_100288298(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
}

void sub_10028863C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
}

void sub_100288BA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,os_activity_scope_state_s state)
{
}

id sub_100288BF4(uint64_t a1)
{
  id v2 = +[IMRGLog sms];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    CFStringRef v4 = (objc_class *)objc_opt_class();
    BOOL v5 = NSStringFromClass(v4);
    int v7 = 138412546;
    uint64_t v8 = v3;
    __int16 v9 = 2112;
    id v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Invalid number provided: %@   Class: %@", (uint8_t *)&v7, 0x16u);
  }
  return [*(id *)(a1 + 40) _notifyFailureWithError:6];
}

id sub_100288CDC(uint64_t a1)
{
  id v2 = +[IMRGLog sms];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    CFStringRef v4 = (objc_class *)objc_opt_class();
    BOOL v5 = NSStringFromClass(v4);
    int v7 = 138412546;
    uint64_t v8 = v3;
    __int16 v9 = 2112;
    id v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Invalid signature provided: %@   Class: %@", (uint8_t *)&v7, 0x16u);
  }
  return [*(id *)(a1 + 40) _notifyFailureWithError:5];
}

id sub_100288DC4(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _notifySuccess:*(void *)(a1 + 40)];
}

void sub_1002891F4()
{
}

void sub_10028921C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,os_activity_scope_state_s state,char a25)
{
}

void sub_100289234(uint64_t a1, int a2)
{
  if (!a2) {
    sub_100289238();
  }
  objc_terminate();
}

uint64_t sub_100289F28()
{
  uint64_t v0 = +[IDSServerBag sharedInstanceForBagType:0];
  id v1 = [v0 objectForKey:@"gdr-max-auth-retries"];

  if (v1) {
    uint64_t v2 = (uint64_t)[v1 unsignedIntValue];
  }
  else {
    uint64_t v2 = 10;
  }

  return v2;
}

double sub_100289F94()
{
  uint64_t v0 = +[IDSServerBag sharedInstanceForBagType:0];
  id v1 = [v0 objectForKey:@"gdr-auth-retry-interval-seconds"];

  if (v1)
  {
    [v1 doubleValue];
    double v3 = v2;
  }
  else
  {
    double v3 = 15.0;
  }

  return v3;
}

void sub_10028A86C(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a5;
  if (IDSDebuggingShouldOverrideGDRResponseCode())
  {
    a4 = IDSDebuggingGDRReponseCodeOverride();

    id v11 = 0;
  }
  id v12 = v9;
  id v13 = +[IMRGLog registration];
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109378;
    *(_DWORD *)CFStringRef v148 = a4;
    *(_WORD *)&v148[4] = 2112;
    *(void *)&v148[6] = v10;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "  Received get dependent registration response with result: %d  error: %@", buf, 0x12u);
  }

  BOOL v14 = [v12 userIDArray];
  unint64_t v15 = +[IMRGLog registration];
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    *(void *)CFStringRef v148 = v12;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, " response for message: %@", buf, 0xCu);
  }

  int v16 = +[IMRGLog registration];
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    *(void *)CFStringRef v148 = v14;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "   response idsUserID: %@", buf, 0xCu);
  }

  id v106 = objc_alloc_init((Class)NSMutableSet);
  id v105 = objc_alloc_init((Class)NSMutableDictionary);
  uint64_t v80 = v10;
  [*(id *)(a1 + 32) _submitGDRReponseToAWDWithResultCode:a4 error:v10];
  uint64_t v108 = a1;
  uint64_t v79 = v12;
  if (!a4)
  {
    BOOL v17 = +[IMRGLog GDR_oversized];
    BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);

    if (v18)
    {
      id v77 = v11;
      id v78 = v14;
      long long v140 = 0u;
      long long v141 = 0u;
      long long v138 = 0u;
      long long v139 = 0u;
      id obj = [v11 _arrayForKey:@"registrations"];
      id v92 = [obj countByEnumeratingWithState:&v138 objects:v146 count:16];
      if (v92)
      {
        uint64_t v91 = *(void *)v139;
        uint64_t v90 = IDSDevicePropertyService;
        uint64_t v89 = IDSDevicePropertyPushToken;
        uint64_t v88 = IDSDevicePropertyName;
        uint64_t v87 = IDSDevicePropertyHardwareVersion;
        uint64_t v86 = IDSDevicePropertyPrivateDeviceData;
        uint64_t v85 = IDSDevicePropertySubServices;
        uint64_t v84 = IDSDevicePropertyIdentities;
        uint64_t v83 = IDSDevicePropertyLinkedUserURIs;
        uint64_t v82 = IDSDevicePropertyIsHSATrustedDevice;
        do
        {
          uint64_t v19 = 0;
          do
          {
            if (*(void *)v139 != v91) {
              objc_enumerationMutation(obj);
            }
            uint64_t v104 = v19;
            CFStringRef v20 = *(void **)(*((void *)&v138 + 1) + 8 * v19);
            int v21 = [v20 objectForKey:v90];
            id v102 = [v21 copy];

            id v22 = [v20 objectForKey:v89];
            id v100 = [v22 debugDescription];

            __int16 v23 = [v20 objectForKey:v88];
            id v24 = [v23 copy];

            __int16 v25 = [v20 objectForKey:v87];
            id v26 = [v25 copy];

            id v27 = [v20 objectForKey:v86];
            uint64_t v97 = +[IDSLogFormatter descriptionForDictionary:v27 options:1];

            uint64_t v28 = [v20 objectForKey:v85];
            uint64_t v29 = objc_msgSend(v28, "__imArrayByApplyingBlock:", &stru_100987870);
            uint64_t v30 = +[IDSLogFormatter descriptionForArray:v29 options:0];

            __int16 v31 = [v20 objectForKey:v84];
            uint64_t v32 = +[IDSLogFormatter descriptionForArray:v31 options:0];

            __int16 v33 = [v20 objectForKey:v83];
            CFStringRef v34 = +[IDSLogFormatter descriptionForArray:v33 options:0];

            __int16 v35 = [v20 objectForKey:v82];
            id v36 = [v35 copy];

            id v125 = _NSConcreteStackBlock;
            uint64_t v126 = 3221225472;
            id v127 = sub_10028B380;
            id v128 = &unk_100987898;
            id v129 = v24;
            id v130 = v102;
            id v131 = v26;
            id v132 = v100;
            id v133 = v34;
            id v134 = v32;
            id v135 = v97;
            id v136 = v30;
            id v137 = v36;
            id v95 = v36;
            id v94 = v30;
            id v98 = v97;
            id v93 = v32;
            id v37 = v34;
            id v38 = v100;
            id v39 = v26;
            id v40 = v102;
            id v41 = v24;
            cut_dispatch_log_queue();

            uint64_t v19 = v104 + 1;
          }
          while (v92 != (id)(v104 + 1));
          id v92 = [obj countByEnumeratingWithState:&v138 objects:v146 count:16];
        }
        while (v92);
      }

      a1 = v108;
      id v11 = v77;
      BOOL v14 = v78;
    }
  }
  uint64_t v42 = v11;
  long long v123 = 0u;
  long long v124 = 0u;
  long long v121 = 0u;
  long long v122 = 0u;
  id v96 = v14;
  id v101 = [v96 countByEnumeratingWithState:&v121 objects:v145 count:16];
  if (v101)
  {
    uint64_t v99 = *(void *)v122;
    do
    {
      uint64_t v43 = 0;
      do
      {
        if (*(void *)v122 != v99) {
          objc_enumerationMutation(v96);
        }
        uint64_t v103 = v43;
        uint64_t v44 = *(void *)(*((void *)&v121 + 1) + 8 * v43);
        long long v119 = 0u;
        long long v120 = 0u;
        long long v117 = 0u;
        long long v118 = 0u;
        id v45 = *(id *)(*(void *)(a1 + 32) + 16);
        id v46 = [v45 countByEnumeratingWithState:&v117 objects:v144 count:16];
        if (v46)
        {
          id v47 = v46;
          uint64_t v48 = *(void *)v118;
          do
          {
            for (uint64_t i = 0; i != v47; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v118 != v48) {
                objc_enumerationMutation(v45);
              }
              uint64_t v50 = *(void **)(*((void *)&v117 + 1) + 8 * i);
              id v51 = [v50 idsUserID];
              unsigned int v52 = [v51 isEqualToIgnoringCase:v44];

              if (v52)
              {
                uint64_t v53 = [v50 guid];
                if ([v53 length])
                {
                  [v106 addObject:v50];
                  uint64_t v54 = v108;
                  id v55 = [*(id *)(*(void *)(v108 + 32) + 8) objectForKey:v53];
                  if (v55)
                  {
                    id v56 = [objc_alloc((Class)NSArray) initWithArray:v55 copyItems:1];
                    [v105 setObject:v56 forKey:v53];

                    uint64_t v54 = v108;
                  }
                  [*(id *)(*(void *)(v54 + 32) + 8) removeObjectForKey:v53];
                }
                else
                {
                  id v55 = +[IMRGLog warning];
                  if (os_log_type_enabled(v55, OS_LOG_TYPE_FAULT))
                  {
                    *(_DWORD *)buf = 138412290;
                    *(void *)CFStringRef v148 = v50;
                    _os_log_fault_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_FAULT, "No GUID for registration %@, when processing getDependentRegistration response", buf, 0xCu);
                  }
                }
              }
            }
            id v47 = [v45 countByEnumeratingWithState:&v117 objects:v144 count:16];
          }
          while (v47);
        }

        uint64_t v43 = v103 + 1;
        a1 = v108;
      }
      while ((id)(v103 + 1) != v101);
      id v101 = [v96 countByEnumeratingWithState:&v121 objects:v145 count:16];
    }
    while (v101);
  }

  [*(id *)(*(void *)(a1 + 32) + 16) minusSet:v106];
  if (![*(id *)(*(void *)(a1 + 32) + 16) count])
  {
    uint64_t v57 = *(void *)(a1 + 32);
    __int16 v58 = *(void **)(v57 + 16);
    *(void *)(v57 + 16) = 0;
  }
  if (![*(id *)(*(void *)(a1 + 32) + 8) count])
  {
    uint64_t v59 = *(void *)(a1 + 32);
    __int16 v60 = *(void **)(v59 + 8);
    *(void *)(v59 + _Block_object_dispose(&STACK[0x300], 8) = 0;
  }
  long long v115 = 0u;
  long long v116 = 0u;
  long long v113 = 0u;
  long long v114 = 0u;
  id v107 = v106;
  id v61 = [v107 countByEnumeratingWithState:&v113 objects:v143 count:16];
  if (v61)
  {
    id v62 = v61;
    uint64_t v63 = *(void *)v114;
    do
    {
      for (j = 0; j != v62; j = (char *)j + 1)
      {
        if (*(void *)v114 != v63) {
          objc_enumerationMutation(v107);
        }
        long long v65 = *(void **)(*((void *)&v113 + 1) + 8 * (void)j);
        double v66 = [v65 guid];
        id v67 = [v105 objectForKey:v66];

        long long v111 = 0u;
        long long v112 = 0u;
        long long v109 = 0u;
        long long v110 = 0u;
        id v68 = v67;
        id v69 = [v68 countByEnumeratingWithState:&v109 objects:v142 count:16];
        if (v69)
        {
          id v70 = v69;
          uint64_t v71 = *(void *)v110;
          do
          {
            for (k = 0; k != v70; k = (char *)k + 1)
            {
              if (*(void *)v110 != v71) {
                objc_enumerationMutation(v68);
              }
              uint64_t v73 = *(void *)(*((void *)&v109 + 1) + 8 * (void)k);
              if (v73) {
                (*(void (**)(uint64_t, void *, uint64_t, BOOL, void *))(v73 + 16))(v73, v65, a4, a4 == 0, v42);
              }
            }
            id v70 = [v68 countByEnumeratingWithState:&v109 objects:v142 count:16];
          }
          while (v70);
        }
      }
      id v62 = [v107 countByEnumeratingWithState:&v113 objects:v143 count:16];
    }
    while (v62);
  }

  uint64_t v74 = *(void *)(v108 + 32);
  if (!*(void *)(v74 + 8))
  {
    int v75 = +[IDSDaemon sharedInstance];
    [v75 _processStoredIncomingMessages];

    uint64_t v74 = *(void *)(v108 + 32);
  }
  [*(id *)(v74 + 40) accountsChanged];
  uint64_t v76 = *(void *)(*(void *)(v108 + 32) + 64);
  if (v76) {
    (*(void (**)(void))(v76 + 16))();
  }
}

id sub_10028B368(id a1, id a2)
{
  return [a2 stringByReplacingOccurrencesOfString:@"com.apple.private.alloy." withString:&stru_10099BE78];
}

void sub_10028B380(void *a1)
{
  double v2 = +[IMRGLog GDR_oversized];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = a1[5];
    uint64_t v5 = a1[6];
    uint64_t v6 = a1[7];
    uint64_t v7 = a1[8];
    uint64_t v8 = a1[9];
    uint64_t v9 = a1[10];
    uint64_t v10 = a1[11];
    uint64_t v11 = a1[12];
    int v12 = 138414338;
    uint64_t v13 = v3;
    __int16 v14 = 2112;
    uint64_t v15 = v4;
    __int16 v16 = 2112;
    uint64_t v17 = v5;
    __int16 v18 = 2112;
    uint64_t v19 = v6;
    __int16 v20 = 2112;
    uint64_t v21 = v7;
    __int16 v22 = 2112;
    uint64_t v23 = v8;
    __int16 v24 = 2112;
    uint64_t v25 = v9;
    __int16 v26 = 2112;
    uint64_t v27 = v10;
    __int16 v28 = 2112;
    uint64_t v29 = v11;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "  * Device Name: %@   Service: %@   Hardware: %@   Token: %@   Linked URIs: %@   Identities: %@   Device Data: %@   Sub-services: %@   HSA trusted: %@", (uint8_t *)&v12, 0x5Cu);
  }
}

void sub_10028BA20(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 32));
  _Unwind_Resume(a1);
}

void sub_10028BA58(uint64_t a1, void *a2)
{
  uint64_t v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  xpc_activity_state_t state = xpc_activity_get_state(v3);
  if (state == 2)
  {
    uint64_t v11 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Got called to report daily metrics.", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    [WeakRetained reportDailyMetrics];
  }
  else if (!state)
  {
    uint64_t v6 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v7 = @"YES";
      if (!v3) {
        CFStringRef v7 = @"NO";
      }
      *(_DWORD *)buf = 138412290;
      CFStringRef v13 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Told to check in for daily metric with activity %@ ", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
    xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_string(v8, XPC_ACTIVITY_PRIORITY, XPC_ACTIVITY_PRIORITY_MAINTENANCE);
    xpc_dictionary_set_int64(v8, XPC_ACTIVITY_INTERVAL, XPC_ACTIVITY_INTERVAL_1_DAY);
    xpc_object_t v9 = xpc_activity_copy_criteria(v3);
    uint64_t v10 = v9;
    if (!v9 || !xpc_equal(v9, v8)) {
      xpc_activity_set_criteria(v3, v8);
    }
  }
}

NSString *sub_10028BE18(uint64_t a1, uint64_t a2)
{
  return +[NSString stringWithFormat:@"%@-%u-%1u", @"idsotr", a1, a2];
}

NSString *sub_10028BE5C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return +[NSString stringWithFormat:@"%@-%u-%1u-%@", @"idsotr", a1, a2, a3];
}

id sub_10028C320(void *a1)
{
  id v1 = a1;
  uint64_t v2 = [v1 componentsSeparatedByString:@"-"];
  if ((unint64_t)[v2 count] > 2)
  {
    uint64_t v4 = [v2 objectAtIndex:0];
  }
  else
  {
    uint64_t v3 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      id v7 = v1;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "_topicFromToken: invalid OTR token %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      _IDSLogTransport();
    }
    uint64_t v4 = 0;
  }

  return v4;
}

uint64_t sub_10028C4AC(void *a1)
{
  id v1 = a1;
  uint64_t v2 = [v1 componentsSeparatedByString:@"-"];
  if ((unint64_t)[v2 count] > 2)
  {
    uint64_t v5 = [v2 objectAtIndex:1];
    uint64_t v4 = (int)[v5 intValue];
  }
  else
  {
    uint64_t v3 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      id v8 = v1;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "_priorityFromToken: invalid OTR token %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      _IDSLogTransport();
    }
    uint64_t v4 = 200;
  }

  return v4;
}

id sub_10028C894(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _handleNegotiationTimeout];
}

void sub_10028C9A8(id a1)
{
  id v1 = objc_alloc_init(IDSOTRController);
  uint64_t v2 = qword_100A4C498;
  qword_100A4C498 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

uint64_t sub_10028DA8C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

uint64_t sub_10028DAA0(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

uint64_t sub_10028DAB4(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

void sub_10028E91C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (([v3 isNegotiating] & 1) == 0
    && ([v3 isReady] & 1) == 0
    && [v3 isSuspended])
  {
    uint64_t v4 = [v3 token];
    uint64_t v5 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      id v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Resume suspended OTR session negotiation for %@.", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        uint64_t v6 = v4;
        _IDSLogTransport();
        if (_IDSShouldLog())
        {
          uint64_t v6 = v4;
          _IDSLogV();
        }
      }
    }
    objc_msgSend(*(id *)(a1 + 32), "startOTRNegotiationWithDeviceIfNeeded:token:reset:errorHandler:", IDSDeviceDefaultPairedDeviceUniqueID, v4, 1, 0, v6);
  }
}

void sub_10028F9A0(void *a1)
{
  pthread_mutex_lock((pthread_mutex_t *)(a1[4] + 24));
  uint64_t v2 = *(void **)(a1[4] + 88);
  if (!v2)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    uint64_t v4 = a1[4];
    uint64_t v5 = *(void **)(v4 + 88);
    *(void *)(v4 + 8_Block_object_dispose(&STACK[0x300], 8) = Mutable;

    uint64_t v2 = *(void **)(a1[4] + 88);
  }
  uint64_t v6 = [v2 objectForKey:a1[5]];
  if (v6)
  {
    id v7 = v6;
    [(IDSOTRSessionInfo *)v6 setOtrTestBlock:a1[6]];
  }
  else
  {
    id v7 = [[IDSOTRSessionInfo alloc] initWithToken:a1[5]];
    [(IDSOTRSessionInfo *)v7 setOtrTestBlock:a1[6]];
    [*(id *)(a1[4] + 88) setObject:v7 forKey:a1[5]];
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1[4] + 24));
}

void sub_10028FD7C(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) sessionNegotiationCount:*(void *)(a1 + 40)];
  id v3 = v2;
  unsigned int v4 = *(_DWORD *)(a1 + 64);
  if ((v4 & 0x80000000) == 0 && v4 < v2)
  {
    uint64_t v5 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      id v6 = [*(id *)(a1 + 48) length];
      uint64_t v7 = *(void *)(a1 + 40);
      int v8 = *(_DWORD *)(a1 + 64);
      *(_DWORD *)buf = 134218754;
      *(void *)uint64_t v99 = v6;
      *(_WORD *)&v99[8] = 2112;
      *(void *)&unsigned char v99[10] = v7;
      __int16 v100 = 1024;
      *(_DWORD *)id v101 = v8;
      *(_WORD *)&v101[4] = 1024;
      *(_DWORD *)&v101[6] = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Receive stale OTR negotiation data %luB for %@, count:(%08x < %08x), ignore.", buf, 0x22u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLogTransport())
    {
      id v9 = [*(id *)(a1 + 48) length];
      uint64_t v94 = *(unsigned int *)(a1 + 64);
      id v86 = v9;
      uint64_t v90 = *(void *)(a1 + 40);
      _IDSLogTransport();
      if (_IDSShouldLog())
      {
        objc_msgSend(*(id *)(a1 + 48), "length", v86, v90, v94, v3);
        _IDSLogV();
      }
    }
    return;
  }
  uint64_t v10 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    id v11 = [*(id *)(a1 + 48) length];
    uint64_t v12 = *(void *)(a1 + 40);
    int v13 = *(_DWORD *)(a1 + 64);
    *(_DWORD *)buf = 134218498;
    *(void *)uint64_t v99 = v11;
    *(_WORD *)&v99[8] = 2112;
    *(void *)&unsigned char v99[10] = v12;
    __int16 v100 = 1024;
    *(_DWORD *)id v101 = v13;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Processing OTR negotiation data %luB for %@, count:%08x.", buf, 0x1Cu);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      id v14 = [*(id *)(a1 + 48) length];
      uint64_t v89 = *(void *)(a1 + 40);
      uint64_t v93 = *(unsigned int *)(a1 + 64);
      id v85 = v14;
      _IDSLogTransport();
      if (_IDSShouldLog())
      {
        id v15 = objc_msgSend(*(id *)(a1 + 48), "length", v85, v89, v93);
        uint64_t v89 = *(void *)(a1 + 40);
        uint64_t v93 = *(unsigned int *)(a1 + 64);
        id v85 = v15;
        _IDSLogV();
      }
    }
  }
  if (objc_msgSend(*(id *)(a1 + 48), "length", v85, v89, v93))
  {
    __int16 v16 = sub_10028C320(*(void **)(a1 + 40));
    if ([v16 isEqualToString:@"idsotr"])
    {
      id v17 = (id)sub_100291500(*(void **)(a1 + 40));
      if (v17 >= 3)
      {
        __int16 v18 = OSLogHandleForTransportCategory();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v19 = *(void *)(a1 + 40);
          *(_DWORD *)buf = 138412290;
          *(void *)uint64_t v99 = v19;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Invalid data protection class for token %@", buf, 0xCu);
        }

        if (!os_log_shim_legacy_logging_enabled()) {
          goto LABEL_136;
        }
        if (!_IDSShouldLogTransport()) {
          goto LABEL_136;
        }
        _IDSLogTransport();
        if (!_IDSShouldLog()) {
          goto LABEL_136;
        }
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v32 = +[IDSDServiceController sharedInstance];
      __int16 v33 = [v32 serviceWithPushTopic:v16];

      if (!v33)
      {
        uint64_t v53 = OSLogHandleForTransportCategory();
        if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v54 = *(void *)(a1 + 40);
          *(_DWORD *)buf = 138412290;
          *(void *)uint64_t v99 = v54;
          _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "Failed to find service for token %@", buf, 0xCu);
        }

        if (!os_log_shim_legacy_logging_enabled()) {
          goto LABEL_136;
        }
        if (!_IDSShouldLogTransport()) {
          goto LABEL_136;
        }
        _IDSLogTransport();
        if (!_IDSShouldLog()) {
          goto LABEL_136;
        }
LABEL_23:
        _IDSLogV();
LABEL_136:

        return;
      }
      id v17 = [v33 dataProtectionClass];
    }
    CFStringRef v34 = +[IDSRegistrationKeyManager sharedInstance];
    id v35 = [v34 latestCopyMessageProtectionIdentityForDataProtectionClass:v17];

    if (!v35)
    {
      id v47 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v48 = IDSDataProtectionClassStringFromDataProtectionClass();
        *(_DWORD *)buf = 138412290;
        *(void *)uint64_t v99 = v48;
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "Failed to get MP Identity for data protection class %@", buf, 0xCu);
      }
      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLogTransport())
        {
          IDSDataProtectionClassStringFromDataProtectionClass();
          double v87 = COERCE_DOUBLE(objc_claimAutoreleasedReturnValue());
          _IDSLogTransport();

          if (_IDSShouldLog())
          {
            IDSDataProtectionClassStringFromDataProtectionClass();
            double v87 = COERCE_DOUBLE(objc_claimAutoreleasedReturnValue());
            _IDSLogV();
          }
        }
      }
      uint64_t v50 = *(void **)(a1 + 32);
      uint64_t v49 = a1 + 32;
      objc_msgSend(v50, "setupNewSessionInfoWithToken:", *(void *)(v49 + 8), *(void *)&v87);
      [*(id *)v49 suspendSessionNegotiation:*(void *)(v49 + 8) askedByPairedDevice:0];
      goto LABEL_136;
    }
    id v36 = [*(id *)(a1 + 32) copyPairedDevicePublicIdentityWithDataProtectionClass:v17];
    if (!v36)
    {
      id v55 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v56 = *(void *)(a1 + 56);
        *(_DWORD *)buf = 138412290;
        *(void *)uint64_t v99 = v56;
        _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "No public key found for remote device: %@    ** Cannot complete OTR exchange", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLogTransport())
        {
          double v87 = *(double *)(a1 + 56);
          _IDSLogTransport();
          if (_IDSShouldLog())
          {
            double v87 = *(double *)(a1 + 56);
            _IDSLogV();
          }
        }
      }
      __int16 v58 = *(void **)(a1 + 32);
      uint64_t v57 = a1 + 32;
      objc_msgSend(v58, "setupNewSessionInfoWithToken:", *(void *)(v57 + 8), *(void *)&v87);
      [*(id *)v57 suspendSessionNegotiation:*(void *)(v57 + 8) askedByPairedDevice:0];
      [*(id *)v57 _reportOTRTestResult:*(void *)(v57 + 8) setupTime:3 result:0.0];
      CFRelease(v35);
      goto LABEL_136;
    }
    id OTRSessionWithFlags = [*(id *)(a1 + 32) copySessionForToken:*(void *)(a1 + 40)];
    if (!OTRSessionWithFlags)
    {
      id OTRSessionWithFlags = (id)SecMPFullIdentityCreateOTRSessionWithFlags();
      if (!OTRSessionWithFlags)
      {
        long long v65 = OSLogHandleForIDSCategory();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
        {
          uint64_t v66 = *(void *)(a1 + 40);
          *(_DWORD *)buf = 138412546;
          *(void *)uint64_t v99 = v66;
          *(_WORD *)&v99[8] = 2112;
          *(void *)&unsigned char v99[10] = 0;
          _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_ERROR, "SecMPFullIdentityCreateOTRSessionWithFlags failed for %@ with error %@. Kick off re-negotiation.", buf, 0x16u);
        }

        if (os_log_shim_legacy_logging_enabled())
        {
          _IDSWarnV();
          _IDSLogV();
          double v87 = *(double *)(a1 + 40);
          id v91 = 0;
          _IDSLogTransport();
        }
        int v40 = 1;
        id v77 = OSLogHandleForTransportCategory();
        if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "Unable to create session from session data", buf, 2u);
        }

        if (os_log_shim_legacy_logging_enabled())
        {
          if (_IDSShouldLogTransport())
          {
            _IDSLogTransport();
            if (_IDSShouldLog()) {
              _IDSLogV();
            }
          }
        }
        objc_msgSend(*(id *)(a1 + 32), "_reportOTRTestResult:setupTime:result:", *(void *)(a1 + 40), 2, 0.0, *(void *)&v87, v91);
        goto LABEL_134;
      }
      id v38 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v39 = *(void *)(a1 + 40);
        *(_DWORD *)buf = 134218498;
        *(void *)uint64_t v99 = OTRSessionWithFlags;
        *(_WORD *)&v99[8] = 2112;
        *(void *)&unsigned char v99[10] = v39;
        __int16 v100 = 2112;
        *(void *)id v101 = 0;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "Created new OTR session %p for token %@ error %@", buf, 0x20u);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLogTransport())
        {
          id v91 = *(id *)(a1 + 40);
          id v95 = 0;
          double v87 = *(double *)&OTRSessionWithFlags;
          _IDSLogTransport();
          if (_IDSShouldLog())
          {
            id v91 = *(id *)(a1 + 40);
            id v95 = 0;
            double v87 = *(double *)&OTRSessionWithFlags;
            _IDSLogV();
          }
        }
      }
      objc_msgSend(*(id *)(a1 + 32), "setupNewSessionInfoWithToken:", *(void *)(a1 + 40), *(void *)&v87, v91, v95);
    }
    int v40 = 0;
    [*(id *)(a1 + 32) setSessionNegotiationStart:*(void *)(a1 + 40)];
    id v41 = objc_alloc_init((Class)NSMutableData);
    uint64_t v42 = SecOTRSProcessPacket();
    if (v42)
    {
      uint64_t v43 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)uint64_t v99 = v42;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "SecOTRSProcessPacket failed with result: %d, removing session key. Kick off re-negotiation.", buf, 8u);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLogTransport())
        {
          double v87 = *(double *)&v42;
          _IDSLogTransport();
          if (_IDSShouldLog())
          {
            double v87 = *(double *)&v42;
            _IDSLogV();
          }
        }
      }
      objc_msgSend(*(id *)(a1 + 32), "_cacheSession:token:", 0, *(void *)(a1 + 40), *(void *)&v87, v91);
      uint64_t v44 = +[IDSOTRKeyStorage sharedInstance];
      [v44 removeSessionKeyForToken:*(void *)(a1 + 40)];

      if (v42 != -25293)
      {
        int v40 = 1;
        goto LABEL_126;
      }
      id v45 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "Failed due to incorrect credentials. Refreshing Paired Device Encryption Keys", buf, 2u);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLogTransport())
        {
          _IDSLogTransport();
          if (_IDSShouldLog()) {
            _IDSLogV();
          }
        }
      }
      id v46 = +[IDSPairingManager sharedInstance];
      [v46 refreshPairedDeviceEncryptionKeys];
      int v40 = 1;
    }
    else
    {
      id v61 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        id v62 = [v41 length];
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)uint64_t v99 = 0;
        *(_WORD *)&v99[4] = 2048;
        *(void *)&v99[6] = v62;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "SecOTRSProcessPacket  result: %d   data: %luB", buf, 0x12u);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLogTransport())
        {
          double v87 = 0.0;
          id v91 = [v41 length];
          _IDSLogTransport();
          if (_IDSShouldLog())
          {
            id v63 = objc_msgSend(v41, "length", 0, v91);
            double v87 = 0.0;
            id v91 = v63;
            _IDSLogV();
          }
        }
      }
      if ((v4 & 0x80000000) != 0) {
        id v64 = (void *)(*(_DWORD *)(a1 + 64) & 0x7FFFFFFF);
      }
      else {
        id v64 = (void *)(v3 | 0x80000000);
      }
      id v67 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
      {
        id v68 = [v41 length];
        uint64_t v69 = *(void *)(a1 + 40);
        *(_DWORD *)buf = 134218498;
        *(void *)uint64_t v99 = v68;
        *(_WORD *)&v99[8] = 2112;
        *(void *)&unsigned char v99[10] = v69;
        __int16 v100 = 1024;
        *(_DWORD *)id v101 = v64;
        _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "  => will, send out OTR negotiation response data %luB for %@, count:%08x.", buf, 0x1Cu);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLogTransport())
        {
          id v70 = [v41 length];
          id v91 = *(id *)(a1 + 40);
          id v95 = v64;
          double v87 = *(double *)&v70;
          _IDSLogTransport();
          if (_IDSShouldLog())
          {
            id v71 = objc_msgSend(v41, "length", *(void *)&v87, v91, v64);
            id v91 = *(id *)(a1 + 40);
            id v95 = v64;
            double v87 = *(double *)&v71;
            _IDSLogV();
          }
        }
      }
      long long v72 = +[IDSUTunController sharedInstance];
      [v72 sendOTRNegotiationMessage:*(void *)(a1 + 40) negotiationCount:v64 negotiationData:v41];

      [*(id *)(a1 + 32) serializeSession:OTRSessionWithFlags token:*(void *)(a1 + 40)];
      int IsReadyForMessages = SecOTRSGetIsReadyForMessages();
      uint64_t v74 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v75 = @"NO";
        if (IsReadyForMessages) {
          CFStringRef v75 = @"YES";
        }
        *(_DWORD *)buf = 138412290;
        *(void *)uint64_t v99 = v75;
        _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "Are we setup with with OTR now?: %@", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
      {
        CFStringRef v76 = @"NO";
        if (IsReadyForMessages) {
          CFStringRef v76 = @"YES";
        }
        double v88 = *(double *)&v76;
        _IDSLogV();
      }
      if (!IsReadyForMessages || [v41 length]) {
        goto LABEL_126;
      }
      ids_monotonic_time();
      double v79 = v78;
      [*(id *)(a1 + 32) sessionStartTimeWithToken:*(void *)(a1 + 40)];
      double v81 = v79 - v80;
      uint64_t v82 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v83 = *(void *)(a1 + 40);
        *(_DWORD *)buf = 134218754;
        *(double *)uint64_t v99 = v81;
        *(_WORD *)&v99[8] = 2114;
        *(void *)&unsigned char v99[10] = v83;
        __int16 v100 = 2048;
        *(void *)id v101 = OTRSessionWithFlags;
        *(_WORD *)&v101[8] = 2112;
        id v102 = OTRSessionWithFlags;
        _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "OTR session ready (took %.6f) for %{public}@ <%p %@>.", buf, 0x2Au);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLogTransport())
        {
          id v96 = OTRSessionWithFlags;
          id v97 = OTRSessionWithFlags;
          uint64_t v92 = *(void *)(a1 + 40);
          double v88 = v81;
          _IDSLogTransport();
          if (_IDSShouldLog())
          {
            id v96 = OTRSessionWithFlags;
            id v97 = OTRSessionWithFlags;
            uint64_t v92 = *(void *)(a1 + 40);
            double v88 = v81;
            _IDSLogV();
          }
        }
      }
      objc_msgSend(*(id *)(a1 + 32), "setSessionNegotiationComplete:", *(void *)(a1 + 40), *(void *)&v88, v92, v96, v97);
      [*(id *)(a1 + 32) _reportOTRTestResult:*(void *)(a1 + 40) setupTime:1 result:v81];
      id v46 = +[IDSAWDLogging sharedInstance];
      uint64_t v84 = sub_10028C320(*(void **)(a1 + 40));
      [v46 OTRSessionNegotiation:v84 priority:sub_10028C4AC(*(void **)(a1 + 40)) duration:(unint64_t)(v81 * 1000.0) result:0];
    }
LABEL_126:
    CFRelease(OTRSessionWithFlags);

LABEL_134:
    CFRelease(v35);
    CFRelease(v36);
    if (v40) {
      [*(id *)(a1 + 32) startOTRNegotiationWithDeviceIfNeeded:*(void *)(a1 + 56) token:*(void *)(a1 + 40) reset:1 errorHandler:0];
    }
    goto LABEL_136;
  }
  id v20 = [*(id *)(a1 + 32) copySessionForToken:*(void *)(a1 + 40)];
  if (v20)
  {
    if (SecOTRSGetIsReadyForMessages())
    {
      if ([*(id *)(a1 + 32) isSessionNegotiating:*(void *)(a1 + 40)])
      {
        ids_monotonic_time();
        double v22 = v21;
        [*(id *)(a1 + 32) sessionStartTimeWithToken:*(void *)(a1 + 40)];
        double v24 = v22 - v23;
        uint64_t v25 = OSLogHandleForTransportCategory();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v26 = *(void *)(a1 + 40);
          *(_DWORD *)buf = 134218754;
          *(double *)uint64_t v99 = v24;
          *(_WORD *)&v99[8] = 2112;
          *(void *)&unsigned char v99[10] = v26;
          __int16 v100 = 2048;
          *(void *)id v101 = v20;
          *(_WORD *)&v101[8] = 2112;
          id v102 = v20;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "OTR session ready (took %.6f) for %@ <%p %@>.", buf, 0x2Au);
        }

        if (os_log_shim_legacy_logging_enabled())
        {
          if (_IDSShouldLogTransport())
          {
            id v95 = v20;
            id v97 = v20;
            id v91 = *(id *)(a1 + 40);
            double v87 = v24;
            _IDSLogTransport();
            if (_IDSShouldLog())
            {
              id v95 = v20;
              id v97 = v20;
              id v91 = *(id *)(a1 + 40);
              double v87 = v24;
              _IDSLogV();
            }
          }
        }
        __int16 v28 = *(void **)(a1 + 32);
        uint64_t v27 = (id *)(a1 + 32);
        uint64_t v29 = v27 + 1;
        objc_msgSend(v28, "setSessionNegotiationComplete:", v27[1], *(void *)&v87, v91, v95, v97);
        [*v27 _reportOTRTestResult:v27[1] setupTime:1 result:v24];
        uint64_t v30 = +[IDSAWDLogging sharedInstance];
        __int16 v31 = sub_10028C320(*v29);
        [v30 OTRSessionNegotiation:v31 priority:sub_10028C4AC(*v29) duration:(unint64_t)(v24 * 1000.0) result:0];
      }
      else
      {
        uint64_t v59 = OSLogHandleForTransportCategory();
        if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v60 = *(void *)(a1 + 40);
          *(_DWORD *)buf = 138412802;
          *(void *)uint64_t v99 = v60;
          *(_WORD *)&v99[8] = 2048;
          *(void *)&unsigned char v99[10] = v20;
          __int16 v100 = 2112;
          *(void *)id v101 = v20;
          _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "OTR session setup is done, but the session is NOT negotiating - token:%@ session:<%p %@>.", buf, 0x20u);
        }

        if (os_log_shim_legacy_logging_enabled())
        {
          if (_IDSShouldLogTransport())
          {
            _IDSLogTransport();
            if (_IDSShouldLog()) {
              _IDSLogV();
            }
          }
        }
      }
    }
    else
    {
      id v51 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
      {
        uint64_t v52 = *(void *)(a1 + 40);
        *(_DWORD *)buf = 138412290;
        *(void *)uint64_t v99 = v52;
        _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "Empty data response for %@ but session is not ready.", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        _IDSWarnV();
        _IDSLogV();
        _IDSLogTransport();
      }
    }
    CFRelease(v20);
  }
}

uint64_t sub_100291500(void *a1)
{
  id v1 = a1;
  id v2 = [v1 componentsSeparatedByString:@"-"];
  if ((unint64_t)[v2 count] > 2)
  {
    uint64_t v5 = [v2 objectAtIndex:2];
    uint64_t v4 = (uint64_t)[v5 intValue];
  }
  else
  {
    id v3 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      id v8 = v1;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "_dataProtectionClassFromToken: invalid OTR token %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      _IDSLogTransport();
    }
    uint64_t v4 = 3;
  }

  return v4;
}

void sub_10029177C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100291794(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) copySessionForToken:*(void *)(a1 + 40)];
  id v3 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *(void **)(a1 + 40);
    *(_DWORD *)buf = 138412290;
    id v9 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "hasMessagableOTRSessionForService for %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
  if (v2)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = SecOTRSGetIsReadyForMessages();
    uint64_t v5 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24)) {
        CFStringRef v6 = @"YES";
      }
      else {
        CFStringRef v6 = @"NO";
      }
      *(_DWORD *)buf = 134218242;
      id v9 = v2;
      __int16 v10 = 2112;
      CFStringRef v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "   => found session %p, is ready: %@", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
    CFRelease(v2);
  }
  else
  {
    uint64_t v7 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "   ** Could not find session", buf, 2u);
    }

    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
      _IDSLogV();
    }
  }
}

void sub_100291DD8(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x100291BD4);
  }
  _Unwind_Resume(a1);
}

void sub_100291E0C(id a1)
{
  off_100A4C4A0 = (uint64_t (*)(void, void, void))IMWeakLinkSymbol();
}

id sub_100292140(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _onQueueStartOTRNegotiationWithDeviceIfNeeded:*(void *)(a1 + 40) token:*(void *)(a1 + 48) reset:*(unsigned __int8 *)(a1 + 64) errorHandler:*(void *)(a1 + 56)];
}

void sub_100293E98(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = +[IDSDServiceController sharedInstance];
  id v8 = [*(id *)(a1 + 32) topic];
  id v9 = [v7 serviceWithPushTopic:v8];

  __int16 v10 = +[IDSDAccountController sharedInstance];
  CFStringRef v11 = [v10 accountsOnService:v9];

  uint64_t v12 = [v11 firstObject];
  if (v12)
  {
    int v13 = +[NSString stringGUID];
    id v14 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      id v15 = *(__CFString **)(a1 + 40);
      __int16 v16 = [(__CFString *)v15 destinations];
      *(_DWORD *)buf = 138412802;
      CFStringRef v27 = v15;
      __int16 v28 = 2112;
      uint64_t v29 = v12;
      __int16 v30 = 2112;
      __int16 v31 = v16;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "sendAheadGroup { group %@, account %@, destination: %@ }", buf, 0x20u);
    }
    if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
    {
      double v23 = [*(id *)(a1 + 40) destinations];
      _IDSLogV();
    }
    id v17 = objc_alloc_init((Class)IDSSendParameters);
    [v17 setPriority:300];
    __int16 v18 = [*(id *)(a1 + 40) destinations];
    uint64_t v19 = +[IDSDestination destinationWithStrings:v18];
    [v17 setDestinations:v19];

    [v17 setCommand:&off_1009D1A28];
    [v17 setEncryptPayload:1];
    [v17 setUseDictAsTopLevel:1];
    [v17 setIdentifier:v13];
    id v20 = IDSGetUUIDData();
    [v17 setMessageUUID:v20];

    [v17 setDataToEncrypt:v5];
    [v17 setFireAndForget:1];
    [v17 setAlwaysSkipSelf:1];
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 3221225472;
    v24[2] = sub_1002942F8;
    v24[3] = &unk_100980FD8;
    id v25 = v13;
    id v21 = v13;
    [v12 sendMessageWithSendParameters:v17 willSendBlock:0 completionBlock:v24];
  }
  else
  {
    double v22 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412546;
      CFStringRef v27 = @"IDSGroupSendAheadObserver";
      __int16 v28 = 2112;
      uint64_t v29 = v9;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "%@ - No account for service name %@ found to send a message, bailing...", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      _IDSLogTransport();
    }
  }
}

void sub_1002942F8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    id v6 = [v3 idsResponseCode];
    id v7 = [v3 responseError];
    unsigned int v8 = [v3 lastCall];
    CFStringRef v9 = @"NO";
    *(_DWORD *)buf = 138413058;
    uint64_t v12 = v5;
    __int16 v13 = 2048;
    if (v8) {
      CFStringRef v9 = @"YES";
    }
    id v14 = v6;
    __int16 v15 = 2112;
    id v16 = v7;
    __int16 v17 = 2112;
    CFStringRef v18 = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Send ahead message %@ got response code %lu error %@ lastCall %@", buf, 0x2Au);
  }
  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog())
  {
    [v3 idsResponseCode];
    __int16 v10 = [v3 responseError];
    [v3 lastCall];
    _IDSLogV();
  }
}

uint64_t IDSProtoKeyTransparencyTrustedServiceSignaturesReadFrom(void *a1, uint64_t a2)
{
  while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      break;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0;
    while (1)
    {
      unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v7 == -1 || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v8 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
      v6 |= (unint64_t)(v8 & 0x7F) << v4;
      if ((v8 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      if (v5++ >= 9)
      {
        unint64_t v6 = 0;
        int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }
    *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0;
    }
LABEL_13:
    if (v10 || (v6 & 7) == 4) {
      break;
    }
    if ((v6 >> 3) == 1)
    {
      uint64_t v12 = objc_alloc_init(IDSProtoKeyTransparencyTrustedServiceSignature);
      [a1 addServiceSignatures:v12];
      if (!PBReaderPlaceMark()
        || !IDSProtoKeyTransparencyTrustedServiceSignatureReadFrom((uint64_t)v12, a2))
      {

        return 0;
      }
      PBReaderRecallMark();
    }
    else
    {
      uint64_t result = PBReaderSkipValueWithTag();
      if (!result) {
        return result;
      }
    }
  }
  return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

void sub_100296668(uint64_t a1, void *a2, void *a3, int a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a5;
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();
  __int16 v13 = +[IDSFoundationLog IDSServerMessaging];
  id v14 = v13;
  if (isKindOfClass)
  {
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138413058;
      id v33 = v9;
      __int16 v34 = 2112;
      id v35 = v10;
      __int16 v36 = 1024;
      int v37 = a4;
      __int16 v38 = 2112;
      id v39 = v11;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Sent server message with { responseMessage: %@, messageError: %@, resultCode: %d, resultDictionary: %@ }", buf, 0x26u);
    }

    __int16 v15 = [v10 domain];
    if ([v15 isEqualToString:NSURLErrorDomain]) {
      BOOL v16 = [v10 code] == (id)-1001;
    }
    else {
      BOOL v16 = 0;
    }

    __int16 v17 = [v10 domain];
    if ([v17 isEqualToString:APSErrorDomain])
    {
      if ([v10 code] == (id)4)
      {

        goto LABEL_15;
      }
      BOOL v18 = [v10 code] == (id)5;
    }
    else
    {
      BOOL v18 = 0;
    }

    if (!v16 && !v18)
    {
      if (!v10)
      {
        id v14 = 0;
LABEL_19:
        (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
        double v24 = [*(id *)(a1 + 32) cancelOnClientCrash];
        unsigned int v25 = [v24 BOOLValue];

        if (v25)
        {
          uint64_t v26 = [*(id *)(a1 + 40) messagesToCancelOnDeallocByTopic];
          CFStringRef v27 = [v26 objectForKeyedSubscript:*(void *)(a1 + 48)];
          [v27 removeObject:*(void *)(a1 + 56)];
        }
        goto LABEL_21;
      }
      uint64_t v23 = IDSServerMessagingErrorDomain;
      NSErrorUserInfoKey v28 = NSUnderlyingErrorKey;
      id v29 = v10;
      id v20 = +[NSDictionary dictionaryWithObjects:&v29 forKeys:&v28 count:1];
      uint64_t v21 = v23;
      uint64_t v22 = 4;
LABEL_18:
      id v14 = +[NSError errorWithDomain:v21 code:v22 userInfo:v20];

      goto LABEL_19;
    }
LABEL_15:
    uint64_t v19 = IDSServerMessagingErrorDomain;
    NSErrorUserInfoKey v30 = NSUnderlyingErrorKey;
    id v31 = v10;
    id v20 = +[NSDictionary dictionaryWithObjects:&v31 forKeys:&v30 count:1];
    uint64_t v21 = v19;
    uint64_t v22 = 3;
    goto LABEL_18;
  }
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
    sub_10071BEF4();
  }
LABEL_21:
}

uint64_t sub_100297294(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

id sub_100297C64(uint64_t a1, void *a2, void *a3)
{
  id v4 = a3;
  unsigned int v5 = [a2 objectForKey:v4];
  if (objc_opt_isKindOfClass())
  {
    id v6 = v5;
  }
  else
  {
    if (v5)
    {
      unint64_t v7 = +[IMRGLog registration];
      if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
        sub_10071C1B4();
      }
    }
    id v6 = 0;
  }

  return v6;
}

id sub_1002983C8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [*(id *)(a1 + 32) setObject:a3 forKey:a2];
}

id sub_100299134(uint64_t a1, void *a2)
{
  return [a2 sendXPCObject:*(void *)(a1 + 32)];
}

id sub_100299140(uint64_t a1)
{
  return [*(id *)(a1 + 32) enqueueIncomingMessageBroadcast:*(void *)(a1 + 64) broadcastData:*(void *)(a1 + 40) forTopic:*(void *)(a1 + 48) entitlement:kIDSMessagingEntitlement command:0 capabilities:*(unsigned int *)(a1 + 72) messageContext:*(void *)(a1 + 56)];
}

void sub_1002991DC(id a1)
{
  id v1 = objc_alloc_init(IDSOTRKeyStorage);
  uint64_t v2 = qword_100A4C4C0;
  qword_100A4C4C0 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_1002999D8(uint64_t a1, void *a2, void *a3)
{
  id v6 = a2;
  unsigned int v5 = objc_msgSend(a3, "__imHexString");
  if (v6 && v5) {
    [*(id *)(a1 + 32) setObject:v5 forKey:v6];
  }
}

void sub_10029A304(uint64_t a1, void *a2, uint64_t a3)
{
  id v6 = a2;
  unsigned int v5 = +[NSData __imDataWithHexString:a3];
  if (v6 && v5) {
    [*(id *)(a1 + 32) setObject:v5 forKey:v6];
  }
}

id sub_10029A664(void *a1)
{
  id v1 = a1;
  uint64_t v2 = [v1 componentsSeparatedByString:@"-"];
  if ((unint64_t)[v2 count] > 2)
  {
    id v4 = [v2 objectAtIndex:0];
  }
  else
  {
    id v3 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      id v7 = v1;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "OTRStore: invalid OTR token %@", buf, 0xCu);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      _IDSWarnV();
      _IDSLogV();
      _IDSLogTransport();
    }
    id v4 = 0;
  }

  return v4;
}

void sub_10029AFDC(_Unwind_Exception *a1)
{
  objc_destroyWeak(v4);
  objc_destroyWeak(v3);
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v5 - 104));
  _Unwind_Resume(a1);
}

void sub_10029B028(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained[4] invalidate];
  id v1 = WeakRetained[4];
  WeakRetained[4] = 0;
}

void sub_10029B07C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v2 = (void *)WeakRetained[4];
  if (v2)
  {
    [v2 setFireTimeInterval:3.0];
  }
  else
  {
    id v3 = objc_alloc((Class)IMTimer);
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = im_primary_queue();
    id v6 = [v3 initWithTimeInterval:@"com.apple.identityservices.otr-save-store" name:0 shouldWake:v4 target:"_saveNow" selector:0 userInfo:v5 queue:3.0];
    id v7 = (void *)WeakRetained[4];
    WeakRetained[4] = v6;
  }
}

void sub_10029B144(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained[3] invalidate];
  id v1 = WeakRetained[3];
  WeakRetained[3] = 0;
}

void sub_10029B198(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v2 = (void *)WeakRetained[3];
  if (v2)
  {
    [v2 setFireTimeInterval:300.0];
  }
  else
  {
    id v3 = objc_alloc((Class)IMTimer);
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = im_primary_queue();
    id v6 = [v3 initWithTimeInterval:@"com.apple.identityservices.otr-purge-cache" name:0 shouldWake:v4 target:"_purgeMap" selector:0 userInfo:v5 queue:300.0];
    id v7 = (void *)WeakRetained[3];
    WeakRetained[3] = v6;
  }
}

id sub_10029B2F0(uint64_t a1)
{
  return [*(id *)(a1 + 32) _saveNow];
}

id sub_10029B380(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _purgeMap];
}

void sub_10029C724(id a1)
{
  qword_100A4C4D0 = IMWeakLinkClass();
}

void sub_10029C754(id a1)
{
  off_100A4C4D8 = (uint64_t (*)(void, void))IMWeakLinkSymbol();
}

void sub_10029C784(id a1)
{
  off_100A4C4E8 = (uint64_t (*)(void))IMWeakLinkSymbol();
}

void sub_10029C848(id a1)
{
  id v1 = objc_alloc_init(IDSIDStatusQueryController);
  uint64_t v2 = qword_100A4C500;
  qword_100A4C500 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_10029CAE4(_Unwind_Exception *a1)
{
  objc_destroyWeak(v3);
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v4 - 120));
  _Unwind_Resume(a1);
}

void sub_10029CB24(uint64_t a1, void *a2, void *a3, void *a4, void *a5, uint64_t a6, void *a7, char a8)
{
  id v14 = a2;
  id v15 = a3;
  id v16 = a4;
  id v17 = a5;
  id v18 = a7;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v20 = objc_alloc_init((Class)NSMutableDictionary);
  uint64_t v34 = 0;
  id v35 = &v34;
  uint64_t v36 = 0x3032000000;
  int v37 = sub_10029CD90;
  __int16 v38 = sub_10029CDA0;
  id v39 = 0;
  v28[0] = _NSConcreteStackBlock;
  v28[1] = 3221225472;
  v28[2] = sub_10029CDA8;
  v28[3] = &unk_100987AE8;
  id v21 = v18;
  id v29 = v21;
  uint64_t v32 = &v34;
  uint64_t v22 = v16;
  uint64_t v23 = a6;
  id v24 = v14;
  id v30 = v24;
  char v33 = a8;
  id v25 = v20;
  id v31 = v25;
  [v15 enumerateKeysAndObjectsUsingBlock:v28];
  objc_msgSend(WeakRetained, "_updateCacheWithStatusUpdates:fromURI:fromService:success:hadError:negativeCacheHints:", v25, v24, v17, v23, objc_msgSend(v21, "count") != 0, v22);
  if ([v15 count] || !v35[5])
  {
    id v26 = objc_alloc_init((Class)NSMutableDictionary);
    [v26 setObject:v25 forKey:v17];
    [WeakRetained _sendIDStatusChanges:v26 forService:v17 URI:v24 success:v23 error:v35[5]];
  }
  else
  {
    objc_msgSend(WeakRetained, "_sendIDStatusChanges:forService:URI:success:error:", 0, v17, v24, v23);
  }

  _Block_object_dispose(&v34, 8);
}

void sub_10029CD74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10029CD90(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10029CDA0(uint64_t a1)
{
}

void sub_10029CDA8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = [*(id *)(a1 + 32) objectForKey:v5];
  uint64_t v8 = *(void *)(*(void *)(a1 + 56) + 8);
  uint64_t v10 = *(void *)(v8 + 40);
  id v9 = (id *)(v8 + 40);
  if (!v10) {
    objc_storeStrong(v9, v7);
  }
  id v11 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 138412802;
    id v29 = v5;
    __int16 v30 = 2112;
    uint64_t v31 = v12;
    __int16 v32 = 2112;
    char v33 = v7;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Completed ID query {uri: %@, fromURI: %@, error: %@}", buf, 0x20u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    MarcoLogMadridLevel();
    uint64_t v24 = *(void *)(a1 + 40);
    id v25 = v7;
    id v23 = v5;
    IMLogString();
    if (_IMWillLog())
    {
      uint64_t v24 = *(void *)(a1 + 40);
      id v25 = v7;
      id v23 = v5;
      _IMAlwaysLog();
    }
  }
  if (objc_msgSend(v6, "BOOLValue", v23, v24, v25)) {
    uint64_t v13 = 1;
  }
  else {
    uint64_t v13 = 2;
  }
  id v14 = [v7 domain];
  uint64_t v15 = IDSPeerIDManagerErrorDomain;
  if ([v14 isEqualToIgnoringCase:IDSPeerIDManagerErrorDomain])
  {
    BOOL v16 = [v7 code] == (id)3;

    if (v16)
    {
      uint64_t v13 = 2;
      goto LABEL_19;
    }
  }
  else
  {
  }
  if (v7)
  {
    if (*(unsigned char *)(a1 + 64))
    {
      NSErrorUserInfoKey v26 = NSLocalizedDescriptionKey;
      CFStringRef v27 = @"Network unavailable.";
      id v17 = +[NSDictionary dictionaryWithObjects:&v27 forKeys:&v26 count:1];
      uint64_t v18 = +[NSError errorWithDomain:v15 code:6 userInfo:v17];
      uint64_t v19 = *(void *)(*(void *)(a1 + 56) + 8);
      id v20 = *(void **)(v19 + 40);
      *(void *)(v19 + 40) = v18;
    }
    uint64_t v13 = 0;
  }
LABEL_19:
  id v21 = *(void **)(a1 + 48);
  uint64_t v22 = +[NSNumber numberWithUnsignedInt:v13];
  [v21 setObject:v22 forKey:v5];
}

void sub_10029D098(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained[1] invalidate];
  id v1 = WeakRetained[1];
  WeakRetained[1] = 0;
}

void sub_10029D0EC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v2 = (void *)WeakRetained[1];
  if (v2)
  {
    [v2 setFireTimeInterval:120.0];
  }
  else
  {
    id v3 = objc_alloc((Class)IMTimer);
    uint64_t v4 = *(void *)(a1 + 32);
    id v5 = im_primary_queue();
    id v6 = [v3 initWithTimeInterval:@"com.apple.identityservices.id-status-cache" name:0 shouldWake:v4 target:"_flush" selector:0 userInfo:v5 queue:120.0];
    id v7 = (void *)WeakRetained[1];
    WeakRetained[1] = v6;
  }
}

id sub_10029D244(uint64_t a1)
{
  return [*(id *)(a1 + 32) _flush];
}

id sub_10029E058(id a1, IDSEndpoint *a2)
{
  return [(IDSEndpoint *)a2 refreshDate];
}

int64_t sub_10029E060(id a1, NSDate *a2, NSDate *a3)
{
  return [(NSDate *)a2 compare:a3];
}

uint64_t sub_10029E170(unint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [v3 prefixedURI];
  if ([v4 length])
  {
    id v5 = [v3 unprefixedURI];
    id v6 = [v5 length];

    if ((unint64_t)v6 <= 5)
    {
      id v7 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v22[0] = v3;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Failed type check! {key: %@, class: %@}", buf, 0xCu);
      }

      if (!os_log_shim_legacy_logging_enabled()) {
        goto LABEL_37;
      }
      MarcoLogMadridLevel();
      IMLogString();
      if ((_IMWillLog() & 1) == 0) {
        goto LABEL_37;
      }
      goto LABEL_36;
    }
  }
  else
  {
  }
  uint64_t v8 = [v3 prefixedURI];
  id v9 = [v8 length];

  if (v9)
  {
    if (a1 == 1)
    {
      id v14 = [v3 prefixedURI];
      if ([v14 rangeOfString:@"@"] == (id)0x7FFFFFFFFFFFFFFFLL)
      {
      }
      else
      {
        BOOL v16 = [v3 prefixedURI];
        id v17 = [v16 rangeOfString:@"."];

        if (v17 != (id)0x7FFFFFFFFFFFFFFFLL) {
          goto LABEL_39;
        }
      }
      uint64_t v18 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v22[0] = v3;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "  => Invalid URI, email, with no '@' and '.' characters: %@", buf, 0xCu);
      }

      if (!os_log_shim_legacy_logging_enabled()) {
        goto LABEL_37;
      }
      MarcoLogMadridLevel();
      IMLogString();
      if ((_IMWillLog() & 1) == 0) {
        goto LABEL_37;
      }
    }
    else
    {
      if (!a1)
      {
        uint64_t v10 = [v3 prefixedURI];
        id v11 = [v10 rangeOfString:@"+"];

        if (v11 != (id)4)
        {
          uint64_t v12 = OSLogHandleForIDSCategory();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412290;
            v22[0] = v3;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "  => Invalid URI, phone number, with no '+' character: %@", buf, 0xCu);
          }

          if (!os_log_shim_legacy_logging_enabled()) {
            goto LABEL_37;
          }
          MarcoLogMadridLevel();
          IMLogString();
          if ((_IMWillLog() & 1) == 0) {
            goto LABEL_37;
          }
          goto LABEL_36;
        }
LABEL_39:
        uint64_t v19 = 1;
        goto LABEL_38;
      }
      if (a1 < 7) {
        goto LABEL_39;
      }
      uint64_t v15 = OSLogHandleForIDSCategory();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109378;
        LODWORD(v22[0]) = a1;
        WORD2(v22[0]) = 2112;
        *(void *)((char *)v22 + 6) = v3;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "  => Invalid URI type: %d  URI: %@", buf, 0x12u);
      }

      if (!os_log_shim_legacy_logging_enabled()) {
        goto LABEL_37;
      }
      MarcoLogMadridLevel();
      IMLogString();
      if ((_IMWillLog() & 1) == 0) {
        goto LABEL_37;
      }
    }
  }
  else
  {
    uint64_t v13 = OSLogHandleForIDSCategory();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v22[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "  => Invalid URI, empty: %@", buf, 0xCu);
    }

    if (!os_log_shim_legacy_logging_enabled()) {
      goto LABEL_37;
    }
    MarcoLogMadridLevel();
    IMLogString();
    if ((_IMWillLog() & 1) == 0) {
      goto LABEL_37;
    }
  }
LABEL_36:
  _IMAlwaysLog();
LABEL_37:
  uint64_t v19 = 0;
LABEL_38:

  return v19;
}

uint64_t sub_1002A1C18()
{
  uint64_t v0 = +[IDSServerBag sharedInstanceForBagType:0];
  id v1 = [v0 objectForKey:@"client-query-allow-forced"];

  if (v1) {
    uint64_t v2 = (uint64_t)[v1 BOOLValue];
  }
  else {
    uint64_t v2 = 1;
  }

  return v2;
}

uint64_t sub_1002A1C84()
{
  uint64_t v0 = +[IDSServerBag sharedInstanceForBagType:0];
  id v1 = [v0 objectForKey:@"client-query-respect-soft-expiry"];

  if (v1) {
    uint64_t v2 = (uint64_t)[v1 BOOLValue];
  }
  else {
    uint64_t v2 = 1;
  }

  return v2;
}

void sub_1002A1CF0(uint64_t a1, void *a2, void *a3, void *a4, void *a5, uint64_t a6, void *a7, char a8, void *a9)
{
  id v27 = a2;
  id v16 = a3;
  id v17 = a4;
  id v26 = a5;
  id v18 = a7;
  id v19 = a9;
  id v20 = objc_alloc_init((Class)NSMutableDictionary);
  uint64_t v34 = 0;
  id v35 = &v34;
  uint64_t v36 = 0x3032000000;
  int v37 = sub_10029CD90;
  __int16 v38 = sub_10029CDA0;
  id v39 = 0;
  v28[0] = _NSConcreteStackBlock;
  v28[1] = 3221225472;
  v28[2] = sub_1002A1FA8;
  v28[3] = &unk_100987AE8;
  id v21 = v18;
  id v29 = v21;
  __int16 v32 = &v34;
  id v30 = *(id *)(a1 + 32);
  char v33 = a8;
  id v22 = v20;
  id v31 = v22;
  [v16 enumerateKeysAndObjectsUsingBlock:v28];
  objc_msgSend(*(id *)(a1 + 40), "_updateCacheWithStatusUpdates:fromURI:fromService:success:hadError:negativeCacheHints:", v22, *(void *)(a1 + 32), *(void *)(a1 + 48), a6, objc_msgSend(v21, "count") != 0, v17);

  if ([v16 count] || !v35[5])
  {
    id v23 = [*(id *)(a1 + 40) _cachedResultsForURIs:*(void *)(a1 + 56) fromURI:*(void *)(a1 + 32) fromService:*(void *)(a1 + 48)];
    [*(id *)(a1 + 40) _sendIDStatusChanges:v23 forService:*(void *)(a1 + 48) URI:*(void *)(a1 + 32) success:a6 error:v35[5]];
    uint64_t v24 = *(void *)(a1 + 64);
    if (v24) {
      (*(void (**)(uint64_t, void *, void, void, uint64_t, uint64_t))(v24 + 16))(v24, v23, *(void *)(a1 + 32), *(void *)(a1 + 48), a6, v35[5]);
    }
  }
  else
  {
    objc_msgSend(*(id *)(a1 + 40), "_sendIDStatusChanges:forService:URI:success:error:", 0, *(void *)(a1 + 48), *(void *)(a1 + 32), a6);
    uint64_t v25 = *(void *)(a1 + 64);
    if (v25) {
      (*(void (**)(uint64_t, void, void, void, uint64_t, uint64_t))(v25 + 16))(v25, 0, *(void *)(a1 + 32), *(void *)(a1 + 48), a6, v35[5]);
    }
  }

  _Block_object_dispose(&v34, 8);
}

void sub_1002A1F8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1002A1FA8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = [*(id *)(a1 + 32) objectForKey:v5];
  uint64_t v8 = *(void *)(*(void *)(a1 + 56) + 8);
  uint64_t v10 = *(void *)(v8 + 40);
  id v9 = (id *)(v8 + 40);
  if (!v10) {
    objc_storeStrong(v9, v7);
  }
  id v11 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 138412802;
    id v29 = v5;
    __int16 v30 = 2112;
    uint64_t v31 = v12;
    __int16 v32 = 2112;
    char v33 = v7;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Completed ID query for URI %@ fromURI %@ (Error: %@)", buf, 0x20u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    MarcoLogMadridLevel();
    uint64_t v24 = *(void *)(a1 + 40);
    uint64_t v25 = v7;
    id v23 = v5;
    IMLogString();
    if (_IMWillLog())
    {
      uint64_t v24 = *(void *)(a1 + 40);
      uint64_t v25 = v7;
      id v23 = v5;
      _IMAlwaysLog();
    }
  }
  if (objc_msgSend(v6, "BOOLValue", v23, v24, v25)) {
    uint64_t v13 = 1;
  }
  else {
    uint64_t v13 = 2;
  }
  id v14 = [v7 domain];
  uint64_t v15 = IDSPeerIDManagerErrorDomain;
  if ([v14 isEqualToIgnoringCase:IDSPeerIDManagerErrorDomain])
  {
    BOOL v16 = [v7 code] == (id)3;

    if (v16)
    {
      uint64_t v13 = 2;
      goto LABEL_19;
    }
  }
  else
  {
  }
  if (v7)
  {
    if (*(unsigned char *)(a1 + 64))
    {
      NSErrorUserInfoKey v26 = NSLocalizedDescriptionKey;
      CFStringRef v27 = @"Network unavailable.";
      id v17 = +[NSDictionary dictionaryWithObjects:&v27 forKeys:&v26 count:1];
      uint64_t v18 = +[NSError errorWithDomain:v15 code:6 userInfo:v17];
      uint64_t v19 = *(void *)(*(void *)(a1 + 56) + 8);
      id v20 = *(void **)(v19 + 40);
      *(void *)(v19 + 40) = v18;
    }
    uint64_t v13 = 0;
  }
LABEL_19:
  id v21 = *(void **)(a1 + 48);
  id v22 = +[NSNumber numberWithUnsignedInt:v13];
  [v21 setObject:v22 forKey:v5];
}

uint64_t sub_1002A2298(void *a1)
{
  id v1 = a1;
  uint64_t v2 = +[IDSServerBag sharedInstanceForBagType:1];
  id v3 = +[NSString stringWithFormat:@"device-query-reset-interval-hours-%@", v1];
  uint64_t v4 = [v2 objectForKey:v3];

  if (v4)
  {
    uint64_t v5 = (uint64_t)[v4 intValue];
  }
  else if ([v1 isEqualToString:@"com.apple.private.alloy.arcade"])
  {
    uint64_t v5 = 5;
  }
  else
  {
    uint64_t v5 = 1;
  }

  return v5;
}

void sub_1002A235C(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5, void *a6)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a4;
  id v14 = a6;
  uint64_t v15 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v16 = @"YES";
    *(_DWORD *)buf = 138413314;
    id v27 = v11;
    if (!v13) {
      CFStringRef v16 = @"NO";
    }
    __int16 v28 = 2112;
    id v29 = v12;
    __int16 v30 = 2112;
    id v31 = v13;
    __int16 v32 = 2112;
    CFStringRef v33 = v16;
    __int16 v34 = 2112;
    id v35 = v14;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Remote ID IDs Query V2 has completed with the following: %@  FromURI: %@ ReturnedService: %@ ReturnedSucesss: %@ ReturnedError: %@ ", buf, 0x34u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    id v17 = v13 ? @"YES" : @"NO";
    MarcoLogMadridLevel();
    uint64_t v24 = v17;
    id v25 = v14;
    id v22 = v12;
    id v23 = v13;
    id v21 = v11;
    IMLogString();
    if (_IMWillLog())
    {
      uint64_t v24 = v17;
      id v25 = v14;
      id v22 = v12;
      id v23 = v13;
      id v21 = v11;
      _IMAlwaysLog();
    }
  }
  uint64_t v18 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    id v27 = v11;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Updating Cache  %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    MarcoLogMadridLevel();
    id v21 = v11;
    IMLogString();
    if (_IMWillLog())
    {
      id v21 = v11;
      _IMAlwaysLog();
    }
  }
  objc_msgSend(*(id *)(a1 + 32), "_updateCacheWithStatusUpdates:fromURI:fromService:success:hadError:negativeCacheHints:", v11, *(void *)(a1 + 40), *(void *)(a1 + 48), a5, 0, 0, v21, v22, v23, v24, v25);
  uint64_t v19 = +[NSDictionary dictionaryWithObjectsAndKeys:](NSDictionary, "dictionaryWithObjectsAndKeys:", v11, *(void *)(a1 + 48), 0);
  id v20 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    id v27 = v19;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Calling Completion Block  %@", buf, 0xCu);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    MarcoLogMadridLevel();
    IMLogString();
    if (_IMWillLog()) {
      _IMAlwaysLog();
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 56) + 16))(*(void *)(a1 + 56));
}

void sub_1002A27AC(id a1, NSString *a2, NSError *a3)
{
  uint64_t v4 = a2;
  uint64_t v5 = a3;
  id v6 = OSLogHandleForIDSCategory();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412546;
    uint64_t v8 = v4;
    __int16 v9 = 2112;
    uint64_t v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Triggered auto bug capture for query rate limiting {session : %@, error: %@}", buf, 0x16u);
  }

  if (os_log_shim_legacy_logging_enabled() && _IDSShouldLog()) {
    _IDSLogV();
  }
}

void sub_1002A4630(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5, void *a6)
{
  id v17 = a2;
  id v11 = a3;
  id v12 = a4;
  id v13 = a6;
  if (v17)
  {
    id v14 = [*(id *)(a1 + 32) peerIDManager];
    uint64_t v15 = [v14 endpointsForURIs:*(void *)(a1 + 40) service:*(void *)(a1 + 48) fromURI:*(void *)(a1 + 56) ignoringTTL:1];
  }
  else
  {
    uint64_t v15 = 0;
  }
  uint64_t v16 = *(void *)(a1 + 64);
  if (v16) {
    (*(void (**)(uint64_t, void *, void, void, uint64_t, id))(v16 + 16))(v16, v15, *(void *)(a1 + 56), *(void *)(a1 + 48), a5, v13);
  }
}

void sub_1002A4DA0(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5, void *a6)
{
  id v17 = a2;
  id v11 = a3;
  id v12 = a4;
  id v13 = a6;
  if (v17)
  {
    id v14 = [*(id *)(a1 + 32) peerIDManager];
    uint64_t v15 = [v14 idInfoResultForURIs:*(void *)(a1 + 40) service:*(void *)(a1 + 48) fromURI:*(void *)(a1 + 56) infoType:*(void *)(a1 + 80) infoOptions:*(void *)(a1 + 64) idStatusUpdates:v17];
  }
  else
  {
    uint64_t v15 = 0;
  }
  uint64_t v16 = *(void *)(a1 + 72);
  if (v16) {
    (*(void (**)(uint64_t, void *, void, void, uint64_t, id))(v16 + 16))(v16, v15, *(void *)(a1 + 56), *(void *)(a1 + 48), a5, v13);
  }
}

void sub_1002A6CF0(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1002A6C10);
  }
  _Unwind_Resume(a1);
}

void sub_1002A8984(id a1)
{
  id v1 = objc_alloc_init(IDSDMessageStoreMigrator);
  uint64_t v2 = qword_100A4C520;
  qword_100A4C520 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_1002A9B88(id a1)
{
  id v1 = objc_alloc_init((Class)NSMutableDictionary);
  if (CUTIsInternalInstall())
  {
    id v2 = [&stru_100987C88 copy];
    id v3 = objc_retainBlock(v2);
    uint64_t v4 = +[NSNumber numberWithInteger:91];
    [v1 setObject:v3 forKey:v4];
  }
  id v5 = [&stru_100987CA8 copy];
  id v6 = objc_retainBlock(v5);
  id v7 = +[NSNumber numberWithInteger:92];
  [v1 setObject:v6 forKey:v7];

  id v8 = [&stru_100987CC8 copy];
  id v9 = objc_retainBlock(v8);
  uint64_t v10 = +[NSNumber numberWithInteger:32];
  [v1 setObject:v9 forKey:v10];

  id v11 = [&stru_100987CE8 copy];
  id v12 = objc_retainBlock(v11);
  id v13 = +[NSNumber numberWithInteger:90];
  [v1 setObject:v12 forKey:v13];

  id v14 = [&stru_100987D08 copy];
  id v15 = objc_retainBlock(v14);
  uint64_t v16 = +[NSNumber numberWithInteger:66];
  [v1 setObject:v15 forKey:v16];

  id v17 = [&stru_100987D28 copy];
  id v18 = objc_retainBlock(v17);
  uint64_t v19 = +[NSNumber numberWithInteger:34];
  [v1 setObject:v18 forKey:v19];

  id v20 = [&stru_100987D48 copy];
  id v21 = objc_retainBlock(v20);
  id v22 = +[NSNumber numberWithInteger:129];
  [v1 setObject:v21 forKey:v22];

  id v23 = [&stru_100987D68 copy];
  id v24 = objc_retainBlock(v23);
  id v25 = +[NSNumber numberWithInteger:93];
  [v1 setObject:v24 forKey:v25];

  NSErrorUserInfoKey v26 = (void *)qword_100A4C528;
  qword_100A4C528 = (uint64_t)v1;
}

void sub_1002A9E54(id a1, IDSRegistrationPushHandler *a2, NSDictionary *a3)
{
  uint64_t v4 = a2;
  id v5 = a3;
  id v6 = +[IMRGLog registration];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    id v18 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Handling request sysdiagnose push {userInfo: %@}", buf, 0xCu);
  }

  id v7 = [[IDSTapToRadarPushPayload alloc] initWithPushPayload:v5];
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  id v8 = [(IDSRegistrationPushHandler *)v4 copyHandlersForEnumerating];
  id v9 = [v8 countByEnumeratingWithState:&v13 objects:v19 count:16];
  if (v9)
  {
    uint64_t v10 = *(void *)v14;
    do
    {
      for (uint64_t i = 0; i != v9; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v14 != v10) {
          objc_enumerationMutation(v8);
        }
        id v12 = *(void **)(*((void *)&v13 + 1) + 8 * i);
        if (objc_opt_respondsToSelector()) {
          [v12 handler:v4 requestedSysdiagnoseWithTapToRadarPushPayload:v7];
        }
      }
      id v9 = [v8 countByEnumeratingWithState:&v13 objects:v19 count:16];
    }
    while (v9);
  }
}

void sub_1002AA0C4(_Unwind_Exception *a1, int a2)
{
}

void sub_1002AA0F0(_Unwind_Exception *exception_object, int a2)
{
  if (a2 == 1)
  {
    id v2 = objc_begin_catch(exception_object);
    id v3 = +[IMRGLog warning];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT)) {
      sub_10071C294();
    }

    objc_end_catch();
    JUMPOUT(0x1002AA080);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002AA140()
{
}

void sub_1002AA158(id a1, IDSRegistrationPushHandler *a2, NSDictionary *a3)
{
  id v21 = a2;
  uint64_t v4 = a3;
  id v5 = +[IMRGLog registration];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    id v29 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Handling request sysdiagnose push {userInfo: %@}", buf, 0xCu);
  }

  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  id obj = [(IDSRegistrationPushHandler *)v21 copyHandlersForEnumerating];
  id v6 = [obj countByEnumeratingWithState:&v24 objects:v30 count:16];
  if (v6)
  {
    uint64_t v23 = *(void *)v25;
    do
    {
      for (uint64_t i = 0; i != v6; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v25 != v23) {
          objc_enumerationMutation(obj);
        }
        id v8 = *(void **)(*((void *)&v24 + 1) + 8 * i);
        if (objc_opt_respondsToSelector())
        {
          uint64_t v9 = objc_opt_class();
          uint64_t v10 = sub_1002AA560(v9, v4, @"t");
          uint64_t v11 = objc_opt_class();
          id v12 = sub_1002AA560(v11, v4, @"m");
          uint64_t v13 = objc_opt_class();
          long long v14 = sub_1002AA560(v13, v4, @"bd");
          uint64_t v15 = objc_opt_class();
          long long v16 = sub_1002AA560(v15, v4, @"bdurl");
          uint64_t v17 = objc_opt_class();
          id v18 = sub_1002AA560(v17, v4, @"ba");
          uint64_t v19 = objc_opt_class();
          id v20 = sub_1002AA560(v19, v4, @"baurl");
          [v8 handler:v21 requestedPromptThroughPushWithTitle:v10 message:v12 defaultButton:v14 defaultUrl:v16 alternateButton:v18 alternateUrl:v20];
        }
      }
      id v6 = [obj countByEnumeratingWithState:&v24 objects:v30 count:16];
    }
    while (v6);
  }
}

void sub_1002AA4CC(void *a1, int a2)
{
  objc_end_catch();
  if (a2 == 1)
  {
    id v4 = objc_begin_catch(a1);
    id v5 = +[IMRGLog warning];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
      sub_10071C2FC();
    }

    objc_end_catch();
    JUMPOUT(0x1002AA484);
  }
  JUMPOUT(0x1002AA558);
}

void sub_1002AA4E0()
{
}

void sub_1002AA548(_Unwind_Exception *a1)
{
}

id sub_1002AA560(uint64_t a1, void *a2, void *a3)
{
  id v4 = a3;
  id v5 = [a2 objectForKey:v4];
  if (objc_opt_isKindOfClass())
  {
    id v6 = v5;
  }
  else
  {
    if (v5)
    {
      id v7 = +[IMRGLog registration];
      if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
        sub_10071C364();
      }
    }
    id v6 = 0;
  }

  return v6;
}

void sub_1002AA61C(id a1, IDSRegistrationPushHandler *a2, NSDictionary *a3)
{
  id v18 = a2;
  id v4 = a3;
  id v5 = +[IMRGLog registration];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    long long v25 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Handling register push {userInfo: %@}", buf, 0xCu);
  }

  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  id obj = [(IDSRegistrationPushHandler *)v18 copyHandlersForEnumerating];
  id v6 = [obj countByEnumeratingWithState:&v20 objects:v26 count:16];
  if (v6)
  {
    uint64_t v8 = *(void *)v21;
    *(void *)&long long v7 = 138412802;
    long long v17 = v7;
    do
    {
      uint64_t v9 = 0;
      do
      {
        if (*(void *)v21 != v8) {
          objc_enumerationMutation(obj);
        }
        uint64_t v10 = *(void **)(*((void *)&v20 + 1) + 8 * (void)v9);
        if (objc_opt_respondsToSelector())
        {
          uint64_t v11 = objc_opt_class();
          id v12 = sub_1002AA560(v11, v4, @"i");
          uint64_t v13 = objc_opt_class();
          long long v14 = sub_1002AA560(v13, v4, @"o");
          uint64_t v15 = objc_opt_class();
          long long v16 = sub_1002AA560(v15, v4, @"e");
          objc_msgSend(v10, "handler:reregisterUserID:style:service:", v18, v12, v14, v16, v17);
        }
        uint64_t v9 = (char *)v9 + 1;
      }
      while (v6 != v9);
      id v6 = [obj countByEnumeratingWithState:&v20 objects:v26 count:16];
    }
    while (v6);
  }
}

void sub_1002AA8FC(void *a1, int a2)
{
  objc_end_catch();
  if (a2 == 1)
  {
    id v4 = objc_begin_catch(a1);
    id v5 = +[IMRGLog warning];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
      sub_10071C3E8();
    }

    objc_end_catch();
    JUMPOUT(0x1002AA8B4);
  }
  JUMPOUT(0x1002AA988);
}

void sub_1002AA910()
{
}

void sub_1002AA978(_Unwind_Exception *a1)
{
}

void sub_1002AA990(id a1, IDSRegistrationPushHandler *a2, NSDictionary *a3)
{
  uint64_t v13 = a2;
  id v4 = a3;
  id v5 = +[IMRGLog registration];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    uint64_t v19 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Handling reload bag push {userInfo: %@}", buf, 0xCu);
  }

  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  id v6 = [(IDSRegistrationPushHandler *)v13 copyHandlersForEnumerating];
  id v7 = [v6 countByEnumeratingWithState:&v14 objects:v20 count:16];
  if (v7)
  {
    uint64_t v8 = *(void *)v15;
    do
    {
      for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v15 != v8) {
          objc_enumerationMutation(v6);
        }
        uint64_t v10 = *(void **)(*((void *)&v14 + 1) + 8 * i);
        if (objc_opt_respondsToSelector())
        {
          uint64_t v11 = objc_opt_class();
          id v12 = sub_1002AA560(v11, v4, @"s");
          [v10 handler:v13 reloadBag:v12];
        }
      }
      id v7 = [v6 countByEnumeratingWithState:&v14 objects:v20 count:16];
    }
    while (v7);
  }
}

void sub_1002AAC14(_Unwind_Exception *a1, int a2)
{
}

void sub_1002AAC3C(_Unwind_Exception *exception_object, int a2)
{
  if (a2 == 1)
  {
    id v2 = objc_begin_catch(exception_object);
    id v3 = +[IMRGLog warning];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT)) {
      sub_10071C450();
    }

    objc_end_catch();
    JUMPOUT(0x1002AABCCLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002AAC94()
{
}

void sub_1002AACA8(id a1, IDSRegistrationPushHandler *a2, NSDictionary *a3)
{
  id v18 = a2;
  id v4 = a3;
  id v5 = +[IMRGLog registration];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    long long v25 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Handling handles updated push {userInfo: %@}", buf, 0xCu);
  }

  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  id obj = [(IDSRegistrationPushHandler *)v18 copyHandlersForEnumerating];
  id v6 = [obj countByEnumeratingWithState:&v20 objects:v26 count:16];
  if (v6)
  {
    uint64_t v8 = *(void *)v21;
    *(void *)&long long v7 = 138412802;
    long long v17 = v7;
    do
    {
      uint64_t v9 = 0;
      do
      {
        if (*(void *)v21 != v8) {
          objc_enumerationMutation(obj);
        }
        uint64_t v10 = *(void **)(*((void *)&v20 + 1) + 8 * (void)v9);
        if (objc_opt_respondsToSelector())
        {
          uint64_t v11 = objc_opt_class();
          id v12 = sub_1002AA560(v11, v4, @"i");
          uint64_t v13 = objc_opt_class();
          long long v14 = sub_1002AA560(v13, v4, @"s");
          uint64_t v15 = objc_opt_class();
          long long v16 = sub_1002AA560(v15, v4, @"gdr");
          objc_msgSend(v10, "handler:profileHandlesUpdated:status:allowGDR:", v18, v12, v14, v16, v17);
        }
        uint64_t v9 = (char *)v9 + 1;
      }
      while (v6 != v9);
      id v6 = [obj countByEnumeratingWithState:&v20 objects:v26 count:16];
    }
    while (v6);
  }
}

void sub_1002AAF88(void *a1, int a2)
{
  objc_end_catch();
  if (a2 == 1)
  {
    id v4 = objc_begin_catch(a1);
    id v5 = +[IMRGLog warning];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
      sub_10071C4B8();
    }

    objc_end_catch();
    JUMPOUT(0x1002AAF40);
  }
  JUMPOUT(0x1002AB014);
}

void sub_1002AAF9C()
{
}

void sub_1002AB004(_Unwind_Exception *a1)
{
}

void sub_1002AB01C(id a1, IDSRegistrationPushHandler *a2, NSDictionary *a3)
{
  long long v25 = a2;
  id v5 = a3;
  id v6 = +[IMRGLog registration];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    id v35 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Handling devices updated push {userInfo: %@}", buf, 0xCu);
  }

  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  id obj = [(IDSRegistrationPushHandler *)v25 copyHandlersForEnumerating];
  id v7 = [obj countByEnumeratingWithState:&v30 objects:v36 count:16];
  if (v7)
  {
    uint64_t v28 = *(void *)v31;
    *(void *)&long long v8 = 138412802;
    long long v22 = v8;
    do
    {
      uint64_t v9 = 0;
      id v29 = v7;
      do
      {
        if (*(void *)v31 != v28) {
          objc_enumerationMutation(obj);
        }
        uint64_t v10 = *(void **)(*((void *)&v30 + 1) + 8 * (void)v9);
        if (objc_opt_respondsToSelector())
        {
          uint64_t v11 = objc_opt_class();
          id v12 = sub_1002AA560(v11, v5, @"i");
          uint64_t v13 = [(NSDictionary *)v5 objectForKey:@"p", v22];
          objc_opt_class();
          char isKindOfClass = objc_opt_isKindOfClass();
          if (isKindOfClass)
          {
            uint64_t v15 = [(NSDictionary *)v5 objectForKey:@"p"];
            uint64_t v16 = +[NSData _IDSDataFromBase64String:v15];
            long long v24 = (void *)v16;
            long long v27 = (void *)v15;
            goto LABEL_13;
          }
          uint64_t v17 = [(NSDictionary *)v5 objectForKey:@"p"];
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            uint64_t v16 = [(NSDictionary *)v5 objectForKey:@"p"];
            id v3 = (void *)v17;
            long long v23 = (void *)v16;
LABEL_13:
            char v18 = isKindOfClass ^ 1;
          }
          else
          {
            char v18 = 0;
            uint64_t v16 = 0;
            id v3 = (void *)v17;
          }
          uint64_t v19 = objc_opt_class();
          long long v20 = sub_1002AA560(v19, v5, @"s");
          [v10 handler:v25 profile:v12 deviceUpdated:v16 service:v20];

          if (v18) {
          long long v21 = v3;
          }
          if (isKindOfClass)
          {

            long long v21 = v27;
          }
        }
        uint64_t v9 = (char *)v9 + 1;
      }
      while (v29 != v9);
      id v7 = [obj countByEnumeratingWithState:&v30 objects:v36 count:16];
    }
    while (v7);
  }
}

void sub_1002AB3F8(void *a1, int a2)
{
  objc_end_catch();
  if (a2 == 1)
  {
    id v4 = objc_begin_catch(a1);
    id v5 = +[IMRGLog warning];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
      sub_10071C520();
    }

    objc_end_catch();
    JUMPOUT(0x1002AB3B0);
  }
  JUMPOUT(0x1002AB484);
}

void sub_1002AB40C()
{
}

void sub_1002AB474(_Unwind_Exception *a1)
{
}

void sub_1002AB48C(id a1, IDSRegistrationPushHandler *a2, NSDictionary *a3)
{
  uint64_t v19 = a2;
  id v4 = a3;
  id v5 = +[IMRGLog registration];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    long long v25 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Handling flush cache push {userInfo: %@}", buf, 0xCu);
  }

  uint64_t v6 = objc_opt_class();
  id v7 = sub_1002AA560(v6, v4, @"A");
  unsigned int v8 = [v7 BOOLValue];

  if (v8)
  {
    uint64_t v9 = +[IMRGLog registration];
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Told by server to flush entire query cache", buf, 2u);
    }

    uint64_t v10 = +[IDSPeerIDManager sharedInstance];
    [v10 clearCacheAndPersistImmediately:0];

    uint64_t v11 = +[IDSIDStatusQueryController sharedInstance];
    [v11 clearCache];
  }
  else
  {
    long long v22 = 0u;
    long long v23 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    id v12 = [(IDSRegistrationPushHandler *)v19 copyHandlersForEnumerating];
    id v13 = [v12 countByEnumeratingWithState:&v20 objects:v26 count:16];
    if (v13)
    {
      uint64_t v14 = *(void *)v21;
      do
      {
        for (uint64_t i = 0; i != v13; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v21 != v14) {
            objc_enumerationMutation(v12);
          }
          uint64_t v16 = *(void **)(*((void *)&v20 + 1) + 8 * i);
          if (objc_opt_respondsToSelector())
          {
            uint64_t v17 = objc_opt_class();
            char v18 = sub_1002AA560(v17, v4, @"r");
            [v16 handler:v19 flushCacheForURIs:v18];
          }
        }
        id v13 = [v12 countByEnumeratingWithState:&v20 objects:v26 count:16];
      }
      while (v13);
    }
  }
}

void sub_1002AB7D0(_Unwind_Exception *a1, int a2)
{
}

void sub_1002AB7F8(_Unwind_Exception *exception_object, int a2)
{
  if (a2 == 1)
  {
    id v2 = objc_begin_catch(exception_object);
    id v3 = +[IMRGLog warning];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT)) {
      sub_10071C588();
    }

    objc_end_catch();
    JUMPOUT(0x1002AB788);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002AB850()
{
}

void sub_1002AB864(id a1, IDSRegistrationPushHandler *a2, NSDictionary *a3)
{
  id v13 = a2;
  id v4 = a3;
  id v5 = +[IMRGLog registration];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    uint64_t v19 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Handling cohort selected push {userInfo: %@}", buf, 0xCu);
  }

  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  id v6 = [(IDSRegistrationPushHandler *)v13 copyHandlersForEnumerating];
  id v7 = [v6 countByEnumeratingWithState:&v14 objects:v20 count:16];
  if (v7)
  {
    uint64_t v8 = *(void *)v15;
    do
    {
      for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v15 != v8) {
          objc_enumerationMutation(v6);
        }
        uint64_t v10 = *(void **)(*((void *)&v14 + 1) + 8 * i);
        if (objc_opt_respondsToSelector())
        {
          uint64_t v11 = objc_opt_class();
          id v12 = sub_1002AA560(v11, v4, @"co");
          [v10 handler:v13 cohortSelected:v12];
        }
      }
      id v7 = [v6 countByEnumeratingWithState:&v14 objects:v20 count:16];
    }
    while (v7);
  }
}

void sub_1002ABAE8(_Unwind_Exception *a1, int a2)
{
}

void sub_1002ABB10(_Unwind_Exception *exception_object, int a2)
{
  if (a2 == 1)
  {
    id v2 = objc_begin_catch(exception_object);
    id v3 = +[IMRGLog warning];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT)) {
      sub_10071C5F0();
    }

    objc_end_catch();
    JUMPOUT(0x1002ABAA0);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002ABB68()
{
}

void sub_1002AC2FC()
{
}

uint64_t sub_1002AC878(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

id sub_1002AE1B8(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _allocationTimeout];
}

id sub_1002AE7E0(void *a1)
{
  id v1 = a1;
  if ([v1 length] == (id)16)
  {
    id v2 = objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDBytes:", objc_msgSend(v1, "bytes"));
    id v3 = [v2 UUIDString];
  }
  else
  {
    id v4 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134218240;
      id v8 = [v1 length];
      __int16 v9 = 2048;
      uint64_t v10 = 16;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Error: data length: %lu != sizeof(uuid_t): %lu", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        id v6 = [v1 length];
        _IDSLogTransport();
        if (_IDSShouldLog())
        {
          objc_msgSend(v1, "length", v6, 16);
          _IDSLogV();
        }
      }
    }
    id v3 = 0;
  }

  return v3;
}

void sub_1002AEAD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_1002AEAE4(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained _purgeAllocation];
}

void sub_1002AF5E4(uint64_t a1)
{
  id v2 = +[IDSDeliveryController sharedInstance];
  uint64_t v3 = kIDSQuickRelayPushTopic;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_1002AF6A8;
  v5[3] = &unk_100980FD8;
  uint64_t v4 = *(void *)(a1 + 32);
  id v6 = *(id *)(a1 + 40);
  [v2 sendIDSMessage:v4 service:0 topic:v3 completionBlock:v5];
}

void sub_1002AF6A8(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 idsResponseCode])
  {
    uint64_t v4 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      id v5 = [v3 responseError];
      *(_DWORD *)buf = 138412546;
      id v15 = v5;
      __int16 v16 = 2048;
      id v17 = [v3 idsResponseCode];
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "failed to send server message allocation timeout QR metrics report: error: %@  code: %ld", buf, 0x16u);
    }
    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        uint64_t v11 = [v3 responseError];
        id v12 = [v3 idsResponseCode];
        _IDSLogTransport();

        if (_IDSShouldLog())
        {
          id v6 = objc_msgSend(v3, "responseError", v11, v12);
          [v3 idsResponseCode];
          _IDSLogV();
LABEL_14:
        }
      }
    }
  }
  else
  {
    id v7 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      id v8 = *(void **)(a1 + 32);
      __int16 v9 = [v3 deliveryError];
      *(_DWORD *)buf = 138412546;
      id v15 = v8;
      __int16 v16 = 2112;
      id v17 = v9;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Finished sending server message allocation timeout QR metrics report for session %@ delivery error %@", buf, 0x16u);
    }
    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        uint64_t v10 = *(void *)(a1 + 32);
        id v13 = [v3 deliveryError];
        _IDSLogTransport();

        if (_IDSShouldLog())
        {
          id v6 = objc_msgSend(v3, "deliveryError", v10, v13);
          _IDSLogV();
          goto LABEL_14;
        }
      }
    }
  }
}

void sub_1002AFC90(id a1)
{
  id v1 = objc_alloc_init(IDSQuickRelayAllocator);
  uint64_t v2 = qword_100A4C540;
  qword_100A4C540 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_1002B06DC(uint64_t a1)
{
  id v2 = +[IDSDeliveryController sharedInstance];
  [v2 sendIDSMessage:*(void *)(a1 + 32) service:kIDSQuickRelayPushTopic topic:kIDSQuickRelayPushTopic completionBlock:&stru_100987DA8];
}

void sub_1002B074C(id a1, IDSDeliveryContext *a2)
{
  id v2 = a2;
  if ([(IDSDeliveryContext *)v2 idsResponseCode])
  {
    id v3 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      id v4 = [(IDSDeliveryContext *)v2 responseError];
      *(_DWORD *)buf = 138412546;
      id v9 = v4;
      __int16 v10 = 2048;
      id v11 = [(IDSDeliveryContext *)v2 idsResponseCode];
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "failed to send keepalive request: error: %@  code: %ld", buf, 0x16u);
    }
    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        id v5 = [(IDSDeliveryContext *)v2 responseError];
        id v7 = [(IDSDeliveryContext *)v2 idsResponseCode];
        _IDSLogTransport();

        if (_IDSShouldLog())
        {
          id v6 = [(IDSDeliveryContext *)v2 responseError];
          [(IDSDeliveryContext *)v2 idsResponseCode];
          _IDSLogV();
        }
      }
    }
  }
}

void sub_1002B09E0(_Unwind_Exception *a1)
{
  objc_destroyWeak((id *)(v1 - 40));
  _Unwind_Resume(a1);
}

void sub_1002B09F4(uint64_t a1)
{
  id v2 = +[IDSDeliveryController sharedInstance];
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = kIDSQuickRelayPushTopic;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_1002B0ADC;
  v5[3] = &unk_100987DD0;
  objc_copyWeak(&v6, (id *)(a1 + 40));
  [v2 sendIDSMessage:v3 service:v4 topic:v4 completionBlock:v5];

  objc_destroyWeak(&v6);
}

void sub_1002B0AC8(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_1002B0ADC(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 idsResponseCode])
  {
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
    id v5 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      id v6 = [WeakRetained requestIDStr];
      id v7 = [v3 responseError];
      *(_DWORD *)buf = 138412802;
      id v14 = v6;
      __int16 v15 = 2112;
      id v16 = v7;
      __int16 v17 = 2048;
      id v18 = [v3 idsResponseCode];
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "failed sending allocate request: %@ error: %@  code: %ld", buf, 0x20u);
    }
    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        id v8 = [WeakRetained requestIDStr];
        __int16 v10 = [v3 responseError];
        id v12 = [v3 idsResponseCode];
        _IDSLogTransport();

        if (_IDSShouldLog())
        {
          id v9 = objc_msgSend(WeakRetained, "requestIDStr", v8, v10, v12);
          id v11 = [v3 responseError];
          [v3 idsResponseCode];
          _IDSLogV();
        }
      }
    }
  }
}

void sub_1002B2AB4(void **a1)
{
  if (a1)
  {
    free(a1[3]);
    free(a1);
  }
}

void sub_1002B2AF8(uint64_t a1)
{
  id v2 = +[IDSFoundationLog QRAllocator_oversized];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(_DWORD *)(a1 + 48);
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = *(void *)(a1 + 40);
    v6[0] = 67109634;
    v6[1] = v3;
    __int16 v7 = 2112;
    uint64_t v8 = v4;
    __int16 v9 = 2048;
    uint64_t v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Full request info for send allocate request, recipient count: %u, request: %@, time: %.6f.", (uint8_t *)v6, 0x1Cu);
  }
}

id sub_1002B33D4(uint64_t a1, void *a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = a2;
  uint64_t v4 = [v2 service];
  uint64_t v5 = [v4 identifier];
  id v6 = +[IDSURI URIWithPrefixedURI:v3 withServiceLoggingHint:v5];

  return v6;
}

id sub_1002B4B18(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  id v6 = [a2 objectForKey:v5];
  if (objc_opt_isKindOfClass())
  {
    id v7 = v6;
  }
  else
  {
    if (v6)
    {
      uint64_t v8 = +[IMRGLog registration];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
        sub_10071CC80((uint64_t)v5, a1, v8);
      }
    }
    id v7 = 0;
  }

  return v7;
}

id sub_1002B6FF0(uint64_t a1)
{
  id v2 = OSLogHandleForTransportCategory();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Purging duplicate response!", v4, 2u);
  }

  if (os_log_shim_legacy_logging_enabled())
  {
    if (_IDSShouldLogTransport())
    {
      _IDSLogTransport();
      if (_IDSShouldLog()) {
        _IDSLogV();
      }
    }
  }
  return [*(id *)(*(void *)(a1 + 32) + 96) removeObjectForKey:*(void *)(a1 + 40)];
}

void *sub_1002B780C(uint64_t a1, __int16 a2, __int16 a3, int a4, void *a5)
{
  id v9 = a5;
  uint64_t v10 = malloc_type_malloc(0x20uLL, 0x101004021337FD9uLL);
  v10[1] = a1;
  *(_WORD *)uint64_t v10 = a2;
  *((_WORD *)v10 + 1) = a3;
  *((_DWORD *)v10 + 1) = a4;
  unsigned int v11 = [v9 length];
  *((_DWORD *)v10 + 4) = v11;
  id v12 = malloc_type_malloc(v11, 0x6998C644uLL);
  v10[3] = v12;
  id v13 = v9;
  id v14 = [v13 bytes];

  memcpy(v12, v14, *((unsigned int *)v10 + 4));
  return v10;
}

id sub_1002B78CC(uint64_t a1)
{
  size_t v2 = *(unsigned int *)(a1 + 16) + 32;
  id v3 = malloc_type_malloc(v2, 0x73AE36D9uLL);
  long long v4 = *(_OWORD *)(a1 + 16);
  *id v3 = *(_OWORD *)a1;
  v3[1] = v4;
  memcpy(v3 + 2, *(const void **)(a1 + 24), *(unsigned int *)(a1 + 16));
  id v5 = [objc_alloc((Class)NSData) initWithBytes:v3 length:v2];
  free(v3);

  return v5;
}

id sub_1002B7D78(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) _handleIncomingAllocateResponse:*(void *)(a1 + 40) isFromCache:*(unsigned __int8 *)(a1 + 64) requestOptions:*(void *)(a1 + 48)];
  if (*(void *)(a1 + 56))
  {
    id v3 = +[IDSFoundationLog QRAllocator];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "_dispatchIncomingAllocateResponse: calling connectReadyHandler", v4, 2u);
    }

    return (id)(*(uint64_t (**)(void))(*(void *)(a1 + 56) + 16))();
  }
  return result;
}

void sub_1002B9684(uint64_t a1, void *a2, void *a3, void *a4, void *a5, uint64_t a6, void *a7, uint64_t a8, void *a9)
{
  id v77 = a2;
  id v74 = a3;
  id v75 = a4;
  id v78 = a5;
  id v76 = a7;
  id v14 = a9;
  uint64_t v91 = a1;
  __int16 v15 = [*(id *)(a1 + 32) _queryPolicy];
  unsigned int v16 = [v15 shouldPreventDuplicateTokensInAllocationForServiceIdentifier:v78];

  id v87 = objc_alloc_init((Class)NSMutableArray);
  id v17 = objc_alloc_init((Class)NSMutableSet);
  long long v96 = 0u;
  long long v97 = 0u;
  if (v16) {
    id v18 = 0;
  }
  else {
    id v18 = v17;
  }
  if (v16) {
    id v19 = v17;
  }
  else {
    id v19 = 0;
  }
  uint64_t v89 = v18;
  uint64_t v90 = v19;
  long long v98 = 0uLL;
  long long v99 = 0uLL;
  id obj = v14;
  id v81 = [obj countByEnumeratingWithState:&v96 objects:v108 count:16];
  if (v81)
  {
    CFStringRef v20 = @"NO";
    if (v16) {
      CFStringRef v20 = @"YES";
    }
    CFStringRef v79 = v20;
    uint64_t v80 = *(void *)v97;
    uint64_t v86 = kIDSQRAllocateKey_RecipientPushToken;
    uint64_t v85 = kIDSQRAllocateKey_RecipientSessionToken;
    uint64_t v84 = kIDSQRAllocateKey_RecipientURI;
    do
    {
      uint64_t v21 = 0;
      do
      {
        if (*(void *)v97 != v80)
        {
          uint64_t v22 = v21;
          objc_enumerationMutation(obj);
          uint64_t v21 = v22;
        }
        uint64_t v83 = v21;
        long long v23 = *(void **)(*((void *)&v96 + 1) + 8 * v21);
        long long v24 = objc_msgSend(obj, "objectForKeyedSubscript:", v23, v69, v71, v72, v73);
        long long v25 = OSLogHandleForTransportCategory();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v26 = [v24 count];
          long long v27 = [v24 valueForKey:@"pushToken"];
          *(_DWORD *)buf = 138413058;
          *(void *)uint64_t v104 = v23;
          *(_WORD *)&v104[8] = 1024;
          *(_DWORD *)id v105 = v26;
          *(_WORD *)&v105[4] = 2112;
          *(void *)&v105[6] = v79;
          __int16 v106 = 2112;
          id v107 = v27;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "look up peer with URI: %@, push token count: %u, prevent duplicates: %@,  tokens: %@", buf, 0x26u);
        }
        if (os_log_shim_legacy_logging_enabled())
        {
          if (_IDSShouldLogTransport())
          {
            id v28 = [v24 count];
            [v24 valueForKey:@"pushToken"];
            v73 = CFStringRef v72 = v79;
            uint64_t v69 = v23;
            id v71 = v28;
            _IDSLogTransport();

            if (_IDSShouldLog())
            {
              id v29 = objc_msgSend(v24, "count", v23, v28, v79, v73);
              [v24 valueForKey:@"pushToken"];
              v73 = CFStringRef v72 = v79;
              uint64_t v69 = v23;
              id v71 = v29;
              _IDSLogV();
            }
          }
        }
        long long v94 = 0u;
        long long v95 = 0u;
        long long v92 = 0u;
        long long v93 = 0u;
        id v88 = v24;
        id v30 = [v88 countByEnumeratingWithState:&v92 objects:v102 count:16];
        if (v30)
        {
          uint64_t v31 = *(void *)v93;
          do
          {
            for (uint64_t i = 0; i != v30; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v93 != v31) {
                objc_enumerationMutation(v88);
              }
              long long v33 = *(void **)(*((void *)&v92 + 1) + 8 * i);
              __int16 v34 = objc_msgSend(v33, "pushToken", v69);
              id v35 = *(void **)(v91 + 32);
              uint64_t v36 = [v23 prefixedURI];
              int v37 = [v35 _tokenURIForToken:v34 uri:v36];

              if (v16)
              {
                if (![v90 containsObject:v34]) {
                  goto LABEL_40;
                }
                __int16 v38 = OSLogHandleForTransportCategory();
                if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
                {
                  id v39 = IDSLoggableDescriptionForTokenOnService();
                  *(_DWORD *)buf = 138412290;
                  *(void *)uint64_t v104 = v39;
                  _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "Skipping duplicate token %@", buf, 0xCu);
                }
                if (os_log_shim_legacy_logging_enabled())
                {
                  if (_IDSShouldLogTransport())
                  {
                    uint64_t v69 = IDSLoggableDescriptionForTokenOnService();
                    _IDSLogTransport();

                    if (_IDSShouldLog())
                    {
                      int v40 = IDSLoggableDescriptionForTokenOnService();
                      uint64_t v69 = v40;
                      _IDSLogV();
LABEL_46:
                    }
                  }
                }
              }
              else
              {
                if (![v89 containsObject:v37])
                {
LABEL_40:
                  if (!*(void *)(v91 + 48) || objc_msgSend(v34, "isEqualToData:"))
                  {
                    if (v16) {
                      [v90 addObject:v34];
                    }
                    else {
                      [v89 addObject:v37];
                    }
                    v101[0] = v34;
                    v100[0] = v86;
                    v100[1] = v85;
                    uint64_t v43 = [v33 sessionToken];
                    v101[1] = v43;
                    v100[2] = v84;
                    uint64_t v44 = [v23 prefixedURI];
                    v101[2] = v44;
                    int v40 = +[NSDictionary dictionaryWithObjects:v101 forKeys:v100 count:3];

                    [v87 addObject:v40];
                    goto LABEL_46;
                  }
                  goto LABEL_47;
                }
                id v41 = OSLogHandleForTransportCategory();
                if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v42 = IDSLoggableDescriptionForHandleOnService();
                  *(_DWORD *)buf = 138412290;
                  *(void *)uint64_t v104 = v42;
                  _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Skipping duplicate %@", buf, 0xCu);
                }
                if (os_log_shim_legacy_logging_enabled())
                {
                  if (_IDSShouldLogTransport())
                  {
                    uint64_t v69 = IDSLoggableDescriptionForHandleOnService();
                    _IDSLogTransport();

                    if (_IDSShouldLog())
                    {
                      int v40 = IDSLoggableDescriptionForHandleOnService();
                      uint64_t v69 = v40;
                      _IDSLogV();
                      goto LABEL_46;
                    }
                  }
                }
              }
LABEL_47:
            }
            id v30 = [v88 countByEnumeratingWithState:&v92 objects:v102 count:16];
          }
          while (v30);
        }

        uint64_t v21 = v83 + 1;
      }
      while ((id)(v83 + 1) != v81);
      id v81 = [obj countByEnumeratingWithState:&v96 objects:v108 count:16];
    }
    while (v81);
  }

  id v45 = *(void **)(v91 + 32);
  uint64_t v46 = *(void *)(v91 + 56);
  id v47 = [v77 prefixedURI];
  uint64_t v48 = *(void *)(v91 + 64);
  uint64_t v49 = [*(id *)(v91 + 72) objectForKey:kIDSQRAllocateKey_GroupID];
  [v45 _storeMappingFromPushTokenToURIs:v46 fromID:v47 service:v78 cert:v48 forGroup:v49];

  if ([v87 count])
  {
    uint64_t v50 = *(void **)(v91 + 88);
    if (v50)
    {
      id v51 = v50;
      if ((unint64_t)[v51 length] > 0x1F)
      {
        uint64_t v54 = malloc_type_malloc(0x20uLL, 0x101004021337FD9uLL);
        id v64 = v51;
        long long v65 = [v64 bytes];
        long long v66 = v65[1];
        *uint64_t v54 = *v65;
        v54[1] = v66;
        id v67 = malloc_type_malloc(*((unsigned int *)v54 + 4), 0x97AB95A8uLL);
        *((void *)v54 + 3) = v67;
        memcpy(v67, (char *)[v64 bytes] + 32, *((unsigned int *)v54 + 4));
      }
      else
      {
        uint64_t v52 = OSLogHandleForTransportCategory();
        if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v53 = [v51 length];
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)uint64_t v104 = v53;
          *(_WORD *)&v104[4] = 1024;
          *(_DWORD *)&v104[6] = 32;
          _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "Failed type check! {key: %@, class: %@}", buf, 0xEu);
        }

        if (os_log_shim_legacy_logging_enabled())
        {
          if (_IDSShouldLogTransport())
          {
            id v70 = [v51 length];
            _IDSLogTransport();
            if (_IDSShouldLog())
            {
              objc_msgSend(v51, "length", v70, 32);
              _IDSLogV();
            }
          }
        }
        uint64_t v54 = 0;
      }
    }
    else
    {
      uint64_t v54 = 0;
    }
    LODWORD(v72) = 0;
    id v68 = objc_msgSend(*(id *)(v91 + 32), "_setupAllocation:fromURI:sessionID:isSessionIDRemoteDeviceID:options:prevConnectStatus:requestUUID:connectReadyHandler:withPreferredLocalInterface:", v87, *(void *)(v91 + 96), *(void *)(v91 + 80), *(unsigned __int8 *)(v91 + 121), *(void *)(v91 + 72), v54, *(void *)(v91 + 104), *(void *)(v91 + 112), v72, v73);
  }
  else
  {
    id v55 = OSLogHandleForTransportCategory();
    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v56 = *(void *)(v91 + 56);
      *(_DWORD *)buf = 138412546;
      *(void *)uint64_t v104 = v56;
      *(_WORD *)&v104[8] = 2112;
      *(void *)id v105 = v76;
      _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "could not look up recipient's push tokens, ID: %@, errors: %@ ", buf, 0x16u);
    }

    if (os_log_shim_legacy_logging_enabled())
    {
      if (_IDSShouldLogTransport())
      {
        uint64_t v69 = *(void **)(v91 + 56);
        id v71 = v76;
        _IDSLogTransport();
        if (_IDSShouldLog())
        {
          uint64_t v69 = *(void **)(v91 + 56);
          id v71 = v76;
          _IDSLogV();
        }
      }
    }
    if (*(void *)(v91 + 48))
    {
      uint64_t v57 = OSLogHandleForTransportCategory();
      if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v58 = *(void *)(v91 + 48);
        *(_DWORD *)buf = 138412290;
        *(void *)uint64_t v104 = v58;
        _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "Missing expected default paired device's push token %@", buf, 0xCu);
      }

      if (os_log_shim_legacy_logging_enabled())
      {
        if (_IDSShouldLogTransport())
        {
          uint64_t v69 = *(void **)(v91 + 48);
          _IDSLogTransport();
          if (_IDSShouldLog())
          {
            uint64_t v69 = *(void **)(v91 + 48);
            _IDSLogV();
          }
        }
      }
    }
    if (*(void *)(v91 + 112))
    {
      uint64_t v59 = +[NSDictionary dictionaryWithObject:@"No recipient is found." forKey:NSLocalizedDescriptionKey];
      uint64_t v60 = +[NSError errorWithDomain:@"QRAllocator" code:7001 userInfo:v59];

      (*(void (**)(void, void *, void, uint64_t))(*(void *)(v91 + 112) + 16))(*(void *)(v91 + 112), v60, 0, v61);
    }
    id v62 = objc_msgSend(*(id *)(v91 + 32), "_findSessionWithID:", *(void *)(v91 + 80), v69, v71, v72, v73);
    id v63 = v62;
    if (v62 && *(unsigned char *)(v91 + 120)) {
      [v62 setHasPendingAllocation:0 forIDSSession:*(void *)(v91 + 80)];
    }
  }
}