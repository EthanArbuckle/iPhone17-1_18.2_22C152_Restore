double TSDCGContextAssociatedScreenScale(uint64_t a1)
{
  double v1;
  double v2;
  void v4[6];
  uint64_t v5;
  double *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = 0;
  v6 = (double *)&v5;
  v7 = 0x2020000000;
  v8 = 0;
  v4[0] = MEMORY[0x263EF8330];
  v4[1] = 3221225472;
  v4[2] = __TSDCGContextAssociatedScreenScale_block_invoke;
  v4[3] = &unk_2646B1700;
  v4[4] = &v5;
  v4[5] = a1;
  TSDAccessCGContextInfoDictionaryWithBlock(0, 0, (uint64_t)v4);
  v1 = v6[3];
  if (v1 == 0.0)
  {
    TSUScreenScale();
    v1 = v2;
  }
  _Block_object_dispose(&v5, 8);
  return v1;
}

void sub_2235BD608(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

double __TSDCGContextAssociatedScreenScale_block_invoke(uint64_t a1, void *a2)
{
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "objectForKey:", *(void *)(a1 + 40)), "objectForKey:", @"TSDCGContextInfoDictionaryKeyAssociatedScreenScale"), "floatValue");
  double result = v3;
  *(double *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

BOOL TSDCGContextHasTileOffset(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(_OWORD *)a2 = *MEMORY[0x263F00148];
  }
  uint64_t v10 = 0;
  v11 = &v10;
  uint64_t v12 = 0x3052000000;
  v13 = __Block_byref_object_copy__11;
  v14 = __Block_byref_object_dispose__11;
  uint64_t v15 = 0;
  v9[0] = MEMORY[0x263EF8330];
  v9[1] = 3221225472;
  v9[2] = __TSDCGContextHasTileOffset_block_invoke;
  v9[3] = &unk_2646B1700;
  v9[4] = &v10;
  v9[5] = a1;
  TSDAccessCGContextInfoDictionaryWithBlock(0, 0, (uint64_t)v9);
  float v3 = v11;
  if (a2)
  {
    v4 = (void *)v11[5];
    if (v4)
    {
      [v4 CGPointValue];
      *(void *)a2 = v5;
      *(void *)(a2 + 8) = v6;
      float v3 = v11;
    }
  }
  BOOL v7 = v3[5] != 0;
  _Block_object_dispose(&v10, 8);
  return v7;
}

void sub_2235BD774(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __TSDCGContextHasTileOffset_block_invoke(uint64_t a1, void *a2)
{
  objc_opt_class();
  objc_msgSend((id)objc_msgSend(a2, "objectForKey:", *(void *)(a1 + 40)), "objectForKey:", @"TSDCGContextInfoDictionaryKeyTileOffset");
  uint64_t result = TSUDynamicCast();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = result;
  return result;
}

uint64_t TSDCGContextPrefersRasterRendering(uint64_t a1)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  char v7 = 0;
  v3[0] = MEMORY[0x263EF8330];
  v3[1] = 3221225472;
  v3[2] = __TSDCGContextPrefersRasterRendering_block_invoke;
  v3[3] = &unk_2646B1700;
  v3[4] = &v4;
  v3[5] = a1;
  TSDAccessCGContextInfoDictionaryWithBlock(0, 0, (uint64_t)v3);
  uint64_t v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_2235BD8A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __TSDCGContextPrefersRasterRendering_block_invoke(uint64_t a1, void *a2)
{
  uint64_t result = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "objectForKeyedSubscript:", *(void *)(a1 + 40)), "objectForKeyedSubscript:", @"TSDCGContextInfoDictionaryKeyPrefersRasterRendering"), "BOOLValue");
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t __TSDAccessCGContextInfoDictionaryWithBlock_block_invoke()
{
  return pthread_rwlock_init(&TSDAccessCGContextInfoDictionaryWithBlock_rwlock, 0);
}

CGFloat TSDTransformConvertingRectToRectAtPercent@<D0>(uint64_t a1@<X8>, double a2@<D0>, double a3@<D2>, double a4@<D3>, double a5@<D4>, double a6@<D5>, double a7@<D6>, double a8@<D7>, double a9)
{
  double v14 = TSDSubtractPoints(a5, a6, a2);
  double v15 = a7 / a3;
  double v16 = a8 / a4;
  double v18 = TSDMultiplyPointScalar(v14, v17, a9);
  CGFloat v20 = v19;
  double v21 = TSDMixSizes(1.0, 1.0, v15, v16, a9);
  CGFloat v23 = v22;
  uint64_t v24 = MEMORY[0x263F000D0];
  long long v25 = *MEMORY[0x263F000D0];
  long long v26 = *(_OWORD *)(MEMORY[0x263F000D0] + 16);
  *(_OWORD *)a1 = *MEMORY[0x263F000D0];
  *(_OWORD *)(a1 + 16) = v26;
  long long v27 = *(_OWORD *)(v24 + 32);
  *(_OWORD *)(a1 + 32) = v27;
  *(_OWORD *)&v32.a = v25;
  *(_OWORD *)&v32.c = v26;
  *(_OWORD *)&v32.tx = v27;
  CGAffineTransformTranslate((CGAffineTransform *)a1, &v32, v18, v20);
  long long v28 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&v31.a = *(_OWORD *)a1;
  *(_OWORD *)&v31.c = v28;
  *(_OWORD *)&v31.tx = *(_OWORD *)(a1 + 32);
  CGAffineTransformScale(&v32, &v31, v21, v23);
  long long v29 = *(_OWORD *)&v32.c;
  *(_OWORD *)a1 = *(_OWORD *)&v32.a;
  *(_OWORD *)(a1 + 16) = v29;
  CGFloat result = v32.tx;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)&v32.tx;
  return result;
}

BOOL TSDTransformsDifferOnlyByTranslation(double *a1, double *a2)
{
  return *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] && a1[3] == a2[3];
}

CGPath *TSDCreatePathFromTransformedRect(const CGAffineTransform *a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5)
{
  Mutable = CGPathCreateMutable();
  v12.origin.x = a2;
  v12.origin.y = a3;
  v12.size.width = a4;
  v12.size.height = a5;
  CGPathAddRect(Mutable, a1, v12);
  return Mutable;
}

float64x2_t TSDTransformedCornersOfRect(float64x2_t *a1, double *a2, double *a3, double *a4, double *a5, CGFloat a6, CGFloat a7, CGFloat a8, CGFloat a9)
{
  CGFloat MinX = CGRectGetMinX(*(CGRect *)&a6);
  v23.origin.x = a6;
  v23.origin.y = a7;
  v23.size.width = a8;
  v23.size.height = a9;
  CGFloat MinY = CGRectGetMinY(v23);
  v24.origin.x = a6;
  v24.origin.y = a7;
  v24.size.width = a8;
  v24.size.height = a9;
  CGFloat MaxX = CGRectGetMaxX(v24);
  v25.origin.x = a6;
  v25.origin.y = a7;
  v25.size.width = a8;
  v25.size.height = a9;
  CGFloat MaxY = CGRectGetMaxY(v25);
  *a2 = MinX;
  a2[1] = MinY;
  *a3 = MinX;
  a3[1] = MaxY;
  *a4 = MaxX;
  a4[1] = MaxY;
  *a5 = MaxX;
  a5[1] = MinY;
  *(float64x2_t *)a2 = vaddq_f64(a1[2], vmlaq_n_f64(vmulq_n_f64(a1[1], a2[1]), *a1, *a2));
  *(float64x2_t *)a3 = vaddq_f64(a1[2], vmlaq_n_f64(vmulq_n_f64(a1[1], a3[1]), *a1, *a3));
  *(float64x2_t *)a4 = vaddq_f64(a1[2], vmlaq_n_f64(vmulq_n_f64(a1[1], a4[1]), *a1, *a4));
  float64x2_t result = vaddq_f64(a1[2], vmlaq_n_f64(vmulq_n_f64(a1[1], a5[1]), *a1, *a5));
  *(float64x2_t *)a5 = result;
  return result;
}

CGAffineTransform *TSDAffineTransformShear@<X0>(_OWORD *a1@<X0>, CGAffineTransform *a2@<X8>, CGFloat a3@<D0>, CGFloat a4@<D1>)
{
  t1.a = 1.0;
  t1.b = a3;
  t1.c = a4;
  __asm { FMOV            V0.2D, #1.0 }
  *(_OWORD *)&t1.d = _Q0;
  t1.ty = 1.0;
  long long v9 = a1[1];
  *(_OWORD *)&v11.a = *a1;
  *(_OWORD *)&v11.c = v9;
  *(_OWORD *)&v11.tx = a1[2];
  return CGAffineTransformConcat(a2, &t1, &v11);
}

long double TSDTransformAngle(double *a1)
{
  double v2 = *a1;
  double v1 = a1[1];
  if (v1 * a1[2] - *a1 * a1[3] > 0.0)
  {
    double v2 = -v2;
    double v1 = -v1;
  }
  return atan2(v1, v2) * 57.2957795;
}

BOOL TSDIsTransformFlipped(double *a1)
{
  return a1[2] * a1[1] - *a1 * a1[3] > 0.0;
}

double TSDTransformScale(double *a1)
{
  return sqrt(a1[1] * a1[1] + *a1 * *a1);
}

CGAffineTransform *TSDTransformNormalizeScale@<X0>(uint64_t a1@<X0>, CGAffineTransform *a2@<X8>)
{
  CGFloat v2 = 1.0 / sqrt(*(double *)(a1 + 8) * *(double *)(a1 + 8) + *(double *)a1 * *(double *)a1);
  CGFloat v3 = 1.0 / sqrt(*(double *)(a1 + 24) * *(double *)(a1 + 24) + *(double *)(a1 + 16) * *(double *)(a1 + 16));
  long long v4 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&v6.a = *(_OWORD *)a1;
  *(_OWORD *)&v6.c = v4;
  *(_OWORD *)&v6.tx = *(_OWORD *)(a1 + 32);
  return CGAffineTransformScale(a2, &v6, v2, v3);
}

BOOL TSDIsTransformAxisAlignedWithObjectSize(double *a1, double a2, double a3)
{
  double v3 = 1.0 / (a2 * 0.5);
  double v4 = 1.0 / (a3 * 0.5);
  if (v3 >= v4) {
    double v3 = v4;
  }
  double v5 = fabs(a1[3]);
  if (fabs(*a1) < v3 && v5 < v3) {
    return 1;
  }
  if (fabs(a1[1]) >= v3) {
    return 0;
  }
  return fabs(a1[2]) < v3;
}

BOOL TSDIsTransformAxisAlignedWithThreshold(double *a1, double a2)
{
  if (fabs(*a1) < a2 && fabs(a1[3]) < a2) {
    return 1;
  }
  if (fabs(a1[1]) >= a2) {
    return 0;
  }
  return fabs(a1[2]) < a2;
}

BOOL TSDIsTransformAxisAligned(double *a1)
{
  if (fabs(*a1) < 1.0e-12 && fabs(a1[3]) < 1.0e-12) {
    return 1;
  }
  if (fabs(a1[1]) >= 1.0e-12) {
    return 0;
  }
  return fabs(a1[2]) < 1.0e-12;
}

BOOL TSDIsTransformAxisAlignedUnflipped(double *a1)
{
  return fabs(a1[1]) < 1.0e-12 && fabs(a1[2]) < 1.0e-12 && *a1 >= 0.0 && a1[3] >= 0.0;
}

CGAffineTransform *TSDAffineTransformForFlips@<X0>(CGAffineTransform *result@<X0>, int a2@<W1>, uint64_t a3@<X8>, CGFloat a4@<D0>, CGFloat a5@<D1>, CGFloat a6@<D2>, CGFloat a7@<D3>)
{
  uint64_t v13 = MEMORY[0x263F000D0];
  long long v14 = *MEMORY[0x263F000D0];
  long long v15 = *(_OWORD *)(MEMORY[0x263F000D0] + 16);
  *(_OWORD *)a3 = *MEMORY[0x263F000D0];
  *(_OWORD *)(a3 + 16) = v15;
  long long v16 = *(_OWORD *)(v13 + 32);
  *(_OWORD *)(a3 + 32) = v16;
  if (result)
  {
    long long v31 = v15;
    long long v32 = v14;
    CGFloat v17 = a4;
    CGFloat v18 = a5;
    long long v30 = v16;
    CGFloat v19 = a6;
    double MinX = CGRectGetMinX(*(CGRect *)(&a7 - 3));
    v35.origin.x = a4;
    v35.origin.y = a5;
    v35.size.width = a6;
    v35.size.height = a7;
    CGFloat MaxX = CGRectGetMaxX(v35);
    *(_OWORD *)&v34.a = v32;
    *(_OWORD *)&v34.c = v31;
    *(_OWORD *)&v34.tx = v30;
    CGAffineTransformTranslate((CGAffineTransform *)a3, &v34, MinX + MaxX, 0.0);
    long long v22 = *(_OWORD *)(a3 + 16);
    *(_OWORD *)&v33.a = *(_OWORD *)a3;
    *(_OWORD *)&v33.c = v22;
    *(_OWORD *)&v33.tx = *(_OWORD *)(a3 + 32);
    float64x2_t result = CGAffineTransformScale(&v34, &v33, -1.0, 1.0);
    long long v23 = *(_OWORD *)&v34.c;
    *(_OWORD *)a3 = *(_OWORD *)&v34.a;
    *(_OWORD *)(a3 + 16) = v23;
    *(_OWORD *)(a3 + 32) = *(_OWORD *)&v34.tx;
  }
  if (a2)
  {
    v36.origin.x = a4;
    v36.origin.y = a5;
    v36.size.width = a6;
    v36.size.height = a7;
    double MinY = CGRectGetMinY(v36);
    v37.origin.x = a4;
    v37.origin.y = a5;
    v37.size.width = a6;
    v37.size.height = a7;
    CGFloat MaxY = CGRectGetMaxY(v37);
    long long v26 = *(_OWORD *)(a3 + 16);
    *(_OWORD *)&v33.a = *(_OWORD *)a3;
    *(_OWORD *)&v33.c = v26;
    *(_OWORD *)&v33.tx = *(_OWORD *)(a3 + 32);
    CGAffineTransformTranslate(&v34, &v33, 0.0, MinY + MaxY);
    long long v27 = *(_OWORD *)&v34.c;
    *(_OWORD *)a3 = *(_OWORD *)&v34.a;
    *(_OWORD *)(a3 + 16) = v27;
    *(_OWORD *)(a3 + 32) = *(_OWORD *)&v34.tx;
    long long v28 = *(_OWORD *)(a3 + 16);
    *(_OWORD *)&v33.a = *(_OWORD *)a3;
    *(_OWORD *)&v33.c = v28;
    *(_OWORD *)&v33.tx = *(_OWORD *)(a3 + 32);
    float64x2_t result = CGAffineTransformScale(&v34, &v33, 1.0, -1.0);
    long long v29 = *(_OWORD *)&v34.c;
    *(_OWORD *)a3 = *(_OWORD *)&v34.a;
    *(_OWORD *)(a3 + 16) = v29;
    *(_OWORD *)(a3 + 32) = *(_OWORD *)&v34.tx;
  }
  return result;
}

CGAffineTransform *TSDTransformFromTransformSpace@<X0>(_OWORD *a1@<X0>, _OWORD *a2@<X1>, CGAffineTransform *a3@<X8>)
{
  long long v6 = a2[1];
  *(_OWORD *)&v10.a = *a2;
  *(_OWORD *)&v10.c = v6;
  *(_OWORD *)&v10.tx = a2[2];
  CGAffineTransformInvert(&t1, &v10);
  long long v7 = a1[1];
  *(_OWORD *)&v10.a = *a1;
  *(_OWORD *)&v10.c = v7;
  *(_OWORD *)&v10.tx = a1[2];
  CGAffineTransformConcat(&v12, &t1, &v10);
  long long v8 = a2[1];
  *(_OWORD *)&v10.a = *a2;
  *(_OWORD *)&v10.c = v8;
  *(_OWORD *)&v10.tx = a2[2];
  return CGAffineTransformConcat(a3, &v12, &v10);
}

CGAffineTransform *TSDTransformInTransformSpace@<X0>(_OWORD *a1@<X0>, _OWORD *a2@<X1>, CGAffineTransform *a3@<X8>)
{
  long long v5 = a2[1];
  *(_OWORD *)&t1.a = *a2;
  *(_OWORD *)&t1.c = v5;
  *(_OWORD *)&t1.tx = a2[2];
  long long v6 = a1[1];
  *(_OWORD *)&t2.a = *a1;
  *(_OWORD *)&t2.c = v6;
  *(_OWORD *)&t2.tx = a1[2];
  CGAffineTransformConcat(&v12, &t1, &t2);
  long long v7 = a2[1];
  *(_OWORD *)&t1.a = *a2;
  *(_OWORD *)&t1.c = v7;
  *(_OWORD *)&t1.tx = a2[2];
  CGAffineTransformInvert(&v9, &t1);
  return CGAffineTransformConcat(a3, &v12, &v9);
}

CGAffineTransform *TSDTransformConvertForNewOrigin@<X0>(_OWORD *a1@<X0>, CGAffineTransform *a2@<X8>, CGFloat a3@<D0>, CGFloat a4@<D1>)
{
  memset(&v14, 0, sizeof(v14));
  CGAffineTransformMakeTranslation(&v14, -a3, -a4);
  memset(&v13, 0, sizeof(v13));
  CGAffineTransformMakeTranslation(&v13, a3, a4);
  CGAffineTransform t1 = v13;
  long long v8 = a1[1];
  *(_OWORD *)&v10.a = *a1;
  *(_OWORD *)&v10.c = v8;
  *(_OWORD *)&v10.tx = a1[2];
  CGAffineTransformConcat(&v12, &t1, &v10);
  CGAffineTransform t1 = v14;
  return CGAffineTransformConcat(a2, &v12, &t1);
}

CGAffineTransform *TSDTransformMakeFree@<X0>(int a1@<W0>, uint64_t a2@<X8>, double a3@<D0>, double a4@<D1>, double a5@<D2>, double a6@<D3>, CGFloat a7@<D4>, double a8@<D5>, double a9@<D6>, double a10@<D7>)
{
  double v18 = TSDDistance(a3, a4, a5, a6);
  CGFloat v38 = a7;
  double v19 = TSDDistance(a7, a8, a9, a10);
  if (v18 < 0.0001 || v19 < 0.0001)
  {
    return CGAffineTransformMakeTranslation((CGAffineTransform *)a2, a7 - a3, a8 - a4);
  }
  else
  {
    double sx = v19 / v18;
    double v20 = TSDSubtractPoints(a3, a4, a5);
    double v22 = TSDAngleFromDelta(v20, v21);
    double v23 = TSDSubtractPoints(a7, a8, a9);
    double v25 = TSDAngleFromDelta(v23, v24);
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    CGAffineTransformMakeTranslation((CGAffineTransform *)a2, -a3, -a4);
    CGAffineTransformMakeRotation(&t2, -v22);
    long long v26 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)&t1.a = *(_OWORD *)a2;
    *(_OWORD *)&t1.c = v26;
    *(_OWORD *)&t1.tx = *(_OWORD *)(a2 + 32);
    CGAffineTransformConcat(&v44, &t1, &t2);
    long long v27 = *(_OWORD *)&v44.c;
    *(_OWORD *)a2 = *(_OWORD *)&v44.a;
    *(_OWORD *)(a2 + 16) = v27;
    *(_OWORD *)(a2 + 32) = *(_OWORD *)&v44.tx;
    double v28 = 1.0;
    if (!a1) {
      double v28 = sx;
    }
    CGAffineTransformMakeScale(&v41, sx, v28);
    long long v29 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)&t1.a = *(_OWORD *)a2;
    *(_OWORD *)&t1.c = v29;
    *(_OWORD *)&t1.tx = *(_OWORD *)(a2 + 32);
    CGAffineTransformConcat(&v44, &t1, &v41);
    long long v30 = *(_OWORD *)&v44.c;
    *(_OWORD *)a2 = *(_OWORD *)&v44.a;
    *(_OWORD *)(a2 + 16) = v30;
    *(_OWORD *)(a2 + 32) = *(_OWORD *)&v44.tx;
    CGAffineTransformMakeRotation(&v40, v25);
    long long v31 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)&t1.a = *(_OWORD *)a2;
    *(_OWORD *)&t1.c = v31;
    *(_OWORD *)&t1.tx = *(_OWORD *)(a2 + 32);
    CGAffineTransformConcat(&v44, &t1, &v40);
    long long v32 = *(_OWORD *)&v44.c;
    *(_OWORD *)a2 = *(_OWORD *)&v44.a;
    *(_OWORD *)(a2 + 16) = v32;
    *(_OWORD *)(a2 + 32) = *(_OWORD *)&v44.tx;
    CGAffineTransformMakeTranslation(&v39, v38, a8);
    long long v33 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)&t1.a = *(_OWORD *)a2;
    *(_OWORD *)&t1.c = v33;
    *(_OWORD *)&t1.tx = *(_OWORD *)(a2 + 32);
    float64x2_t result = CGAffineTransformConcat(&v44, &t1, &v39);
    long long v35 = *(_OWORD *)&v44.c;
    *(_OWORD *)a2 = *(_OWORD *)&v44.a;
    *(_OWORD *)(a2 + 16) = v35;
    *(_OWORD *)(a2 + 32) = *(_OWORD *)&v44.tx;
  }
  return result;
}

double TSD_CGAffineTransformDecompose(uint64_t a1, uint64_t a2)
{
  double v4 = *(double *)(a1 + 8);
  double v5 = *(double *)(a1 + 16);
  double v6 = *(double *)(a1 + 24);
  double v7 = sqrt(v4 * v4 + *(double *)a1 * *(double *)a1);
  double v8 = sqrt(v6 * v6 + v5 * v5);
  double v9 = *(double *)a1 * v6 - v5 * v4;
  double v10 = -v8;
  double v11 = -v7;
  if (*(double *)a1 < v6) {
    double v10 = v8;
  }
  else {
    double v11 = v7;
  }
  if (v9 < 0.0) {
    double v12 = v11;
  }
  else {
    double v12 = v7;
  }
  if (v9 < 0.0) {
    double v13 = v10;
  }
  else {
    double v13 = v8;
  }
  long long v14 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&v20.a = *(_OWORD *)a1;
  *(_OWORD *)&v20.c = v14;
  *(_OWORD *)&v20.tx = *(_OWORD *)(a1 + 32);
  CGAffineTransformScale(&v21, &v20, 1.0 / v12, 1.0 / v13);
  long long v15 = *(_OWORD *)&v21.c;
  *(_OWORD *)a1 = *(_OWORD *)&v21.a;
  *(_OWORD *)(a1 + 16) = v15;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)&v21.tx;
  double v16 = atan2(*(long double *)(a1 + 8), *(long double *)a1);
  long long v17 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&v20.a = *(_OWORD *)a1;
  *(_OWORD *)&v20.c = v17;
  *(_OWORD *)&v20.tx = *(_OWORD *)(a1 + 32);
  CGAffineTransformRotate(&v21, &v20, -v16);
  long long v18 = *(_OWORD *)&v21.c;
  *(_OWORD *)a1 = *(_OWORD *)&v21.a;
  *(_OWORD *)(a1 + 16) = v18;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)&v21.tx;
  *(double *)a2 = v12;
  *(double *)(a2 + 8) = v13;
  *(double *)(a2 + 16) = v16;
  *(void *)(a2 + 24) = *(void *)a1;
  *(void *)(a2 + 32) = *(void *)(a1 + 8);
  *(void *)(a2 + 40) = *(void *)(a1 + 16);
  *(void *)(a2 + 48) = *(void *)(a1 + 24);
  *(void *)(a2 + 56) = *(void *)(a1 + 32);
  double result = *(double *)(a1 + 40);
  *(double *)(a2 + 64) = result;
  return result;
}

CGFloat TSD_CGAffineTransformCompose@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  long long v4 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)a2 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 16) = v4;
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(a1 + 56);
  CGFloat v5 = *(double *)(a1 + 16);
  long long v6 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)&v13.a = *(_OWORD *)a2;
  *(_OWORD *)&v13.c = v6;
  *(_OWORD *)&v13.tx = *(_OWORD *)(a2 + 32);
  CGAffineTransformRotate((CGAffineTransform *)a2, &v13, v5);
  CGFloat v7 = *(double *)a1;
  CGFloat v8 = *(double *)(a1 + 8);
  long long v9 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)&v12.a = *(_OWORD *)a2;
  *(_OWORD *)&v12.c = v9;
  *(_OWORD *)&v12.tx = *(_OWORD *)(a2 + 32);
  CGAffineTransformScale(&v13, &v12, v7, v8);
  long long v10 = *(_OWORD *)&v13.c;
  *(_OWORD *)a2 = *(_OWORD *)&v13.a;
  *(_OWORD *)(a2 + 16) = v10;
  CGFloat result = v13.tx;
  *(_OWORD *)(a2 + 32) = *(_OWORD *)&v13.tx;
  return result;
}

void TSDTransformMixAffineTransforms(long long *a1@<X0>, _OWORD *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  long long v7 = a1[1];
  long long v16 = *a1;
  v17[0] = v7;
  v17[1] = a1[2];
  TSD_CGAffineTransformDecompose((uint64_t)&v16, (uint64_t)&v18);
  long long v8 = a2[1];
  v15[0] = *a2;
  v15[1] = v8;
  v15[2] = a2[2];
  TSD_CGAffineTransformDecompose((uint64_t)v15, (uint64_t)&v16);
  if ((v18 >= 0.0 || *((double *)&v16 + 1) >= 0.0) && (v19 >= 0.0 || *(double *)&v16 >= 0.0))
  {
    double v9 = __x;
  }
  else
  {
    double v18 = -v18;
    double v19 = -v19;
    double v9 = __x + dbl_2238394F0[__x < 0.0];
  }
  double v10 = fmod(v9, 6.28318531);
  double __x = v10;
  double v11 = fmod(*(long double *)v17, 6.28318531);
  *(double *)long long v17 = v11;
  if (vabdd_f64(v10, v11) > 3.14159265)
  {
    BOOL v12 = v10 <= v11;
    if (v10 > v11) {
      double v11 = v10;
    }
    CGAffineTransform v13 = (double *)&v16;
    if (!v12) {
      CGAffineTransform v13 = &v18;
    }
    v13[2] = v11 + -6.28318531;
  }
  for (uint64_t i = 0; i != 72; i += 8)
    *(double *)((char *)&v18 + i) = *(double *)((char *)&v18 + i)
                                  + (*(double *)((char *)&v17[-1] + i) - *(double *)((char *)&v18 + i)) * a4;
  TSD_CGAffineTransformCompose((uint64_t)&v18, a3);
}

double TSDOffsetForEdgeOfFrame(int a1, double a2, double a3, double a4, double a5)
{
  switch(a1)
  {
    case 0:
      double result = CGRectGetMinX(*(CGRect *)&a2);
      break;
    case 1:
      double result = CGRectGetMidX(*(CGRect *)&a2);
      break;
    case 2:
      double result = CGRectGetMaxX(*(CGRect *)&a2);
      break;
    case 3:
      double result = CGRectGetMinY(*(CGRect *)&a2);
      break;
    case 4:
      double result = CGRectGetMidY(*(CGRect *)&a2);
      break;
    case 5:
      double result = CGRectGetMaxY(*(CGRect *)&a2);
      break;
    default:
      double result = 0.0;
      break;
  }
  return result;
}

double TSDRectWithCenterAndSize(double a1, double a2, double a3)
{
  return a1 - a3 * 0.5;
}

double TSDRectWithPoints(double a1, double a2, double a3)
{
  if (a1 >= a3) {
    return a3;
  }
  else {
    return a1;
  }
}

double TSDRectWithSizeAlignedToRect(int a1, int a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  v17.size.height = a4;
  v17.size.double width = a3;
  v17.origin.double x = 0.0;
  v17.origin.y = 0.0;
  CGRect v18 = CGRectStandardize(v17);
  double x = v18.origin.x;
  double width = v18.size.width;
  v18.origin.double x = a5;
  v18.origin.y = a6;
  v18.size.double width = a7;
  v18.size.height = a8;
  if (!CGRectIsNull(v18))
  {
    switch(a1)
    {
      case 3:
        v20.origin.double x = a5;
        v20.origin.y = a6;
        v20.size.double width = a7;
        v20.size.height = a8;
        double x = CGRectGetMaxX(v20) - width;
        break;
      case 2:
        v21.origin.double x = a5;
        v21.origin.y = a6;
        v21.size.double width = a7;
        v21.size.height = a8;
        double x = CGRectGetMidX(v21) + width * -0.5;
        break;
      case 1:
        v19.origin.double x = a5;
        v19.origin.y = a6;
        v19.size.double width = a7;
        v19.size.height = a8;
        double x = CGRectGetMinX(v19);
        break;
    }
    switch(a2)
    {
      case 3:
        v23.origin.double x = a5;
        v23.origin.y = a6;
        v23.size.double width = a7;
        v23.size.height = a8;
        CGRectGetMaxY(v23);
        break;
      case 2:
        v24.origin.double x = a5;
        v24.origin.y = a6;
        v24.size.double width = a7;
        v24.size.height = a8;
        CGRectGetMidY(v24);
        break;
      case 1:
        v22.origin.double x = a5;
        v22.origin.y = a6;
        v22.size.double width = a7;
        v22.size.height = a8;
        CGRectGetMinY(v22);
        break;
    }
  }
  return x;
}

BOOL TSDNearlyEqualPoints(double a1, double a2, double a3, double a4)
{
  BOOL v4 = vabdd_f64(a1, a3) < 0.01;
  return vabdd_f64(a2, a4) < 0.01 && v4;
}

BOOL TSDNearlyEqualSizes(double a1, double a2, double a3, double a4)
{
  BOOL v4 = vabdd_f64(a1, a3) < 0.01;
  return vabdd_f64(a2, a4) < 0.01 && v4;
}

BOOL TSDNearlyEqualRects(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  BOOL result = 0;
  if (vabdd_f64(a1, a5) < 0.01 && vabdd_f64(a2, a6) < 0.01)
  {
    BOOL v9 = vabdd_f64(a3, a7) < 0.01;
    return vabdd_f64(a4, a8) < 0.01 && v9;
  }
  return result;
}

BOOL TSDNearlyContainsRect(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  CGRect v18 = CGRectInset(*(CGRect *)&a1, -0.01, -0.01);
  double v12 = a5;
  double v13 = a6;
  double v14 = a7;
  double v15 = a8;

  return CGRectContainsRect(v18, *(CGRect *)&v12);
}

BOOL TSDCollinearPoints(double a1, double a2, double a3, double a4, double a5, double a6)
{
  return fabs((a3 - a1) * (a6 - a2) - (a4 - a2) * (a5 - a1)) < 8.90029543e-308;
}

BOOL TSDNearlyCollinearPoints(double a1, double a2, double a3, double a4, double a5, double a6)
{
  double v6 = a3 - a1;
  return (v6 * (a6 - a2) - (a4 - a2) * (a5 - a1)) * (v6 * (a6 - a2) - (a4 - a2) * (a5 - a1)) < ((a4 - a2) * (a4 - a2)
                                                                                              + v6 * v6)
                                                                                             * 0.0001
                                                                                             * ((a6 - a2) * (a6 - a2)
                                                                                              + (a5 - a1) * (a5 - a1));
}

double TSDDistanceSquared(double a1, double a2, double a3, double a4)
{
  return (a2 - a4) * (a2 - a4) + (a1 - a3) * (a1 - a3);
}

BOOL TSDRectsOverlapVertically(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  double MinX = CGRectGetMinX(*(CGRect *)&a1);
  v22.origin.double x = a5;
  v22.origin.y = a6;
  v22.size.double width = a7;
  v22.size.height = a8;
  double v16 = CGRectGetMinX(v22);
  v23.origin.double x = a1;
  v23.origin.y = a2;
  v23.size.double width = a3;
  v23.size.height = a4;
  double MaxX = CGRectGetMaxX(v23);
  v24.origin.double x = a5;
  v24.origin.y = a6;
  v24.size.double width = a7;
  v24.size.height = a8;
  double v18 = CGRectGetMaxX(v24);
  if (MinX <= v16) {
    return MaxX >= v16;
  }
  else {
    return v18 >= MinX;
  }
}

BOOL TSDRectsOverlapHorizontally(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  double MinY = CGRectGetMinY(*(CGRect *)&a1);
  v22.origin.double x = a5;
  v22.origin.y = a6;
  v22.size.double width = a7;
  v22.size.height = a8;
  double v16 = CGRectGetMinY(v22);
  v23.origin.double x = a1;
  v23.origin.y = a2;
  v23.size.double width = a3;
  v23.size.height = a4;
  double MaxY = CGRectGetMaxY(v23);
  v24.origin.double x = a5;
  v24.origin.y = a6;
  v24.size.double width = a7;
  v24.size.height = a8;
  double v18 = CGRectGetMaxY(v24);
  if (MinY <= v16) {
    return MaxY >= v16;
  }
  else {
    return v18 >= MinY;
  }
}

uint64_t TSDLineIntersectsRect(CGFloat a1, CGFloat a2, double a3, double a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  double v12 = a4;
  double v13 = a3;
  while (1)
  {
    uint64_t v16 = p_ComputeOutcode(a1, a2, a5, a6, a7, a8);
    uint64_t v17 = p_ComputeOutcode(v13, v12, a5, a6, a7, a8);
    uint64_t result = 1;
    if (!v16 || !v17) {
      break;
    }
    if ((v17 & v16) != 0) {
      return 0;
    }
    double v19 = (v13 + a1) * 0.5;
    double v20 = (v12 + a2) * 0.5;
    int v21 = TSDLineIntersectsRect(1, a1, a2, v19, v20, a5, a6, a7, a8);
    a1 = v19;
    a2 = v20;
    double v13 = a3;
    double v12 = a4;
    if (v21) {
      return 1;
    }
  }
  return result;
}

uint64_t p_ComputeOutcode(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  v14.origin.double x = a3;
  v14.origin.y = a4;
  v14.size.double width = a5;
  v14.size.height = a6;
  if (a2 <= CGRectGetMaxY(v14))
  {
    v15.origin.double x = a3;
    v15.origin.y = a4;
    v15.size.double width = a5;
    v15.size.height = a6;
    if (a2 < CGRectGetMinY(v15)) {
      uint64_t v12 = 2;
    }
    else {
      uint64_t v12 = 0;
    }
  }
  else
  {
    uint64_t v12 = 1;
  }
  v16.origin.double x = a3;
  v16.origin.y = a4;
  v16.size.double width = a5;
  v16.size.height = a6;
  if (a1 > CGRectGetMaxX(v16)) {
    return v12 | 4;
  }
  v17.origin.double x = a3;
  v17.origin.y = a4;
  v17.size.double width = a5;
  v17.size.height = a6;
  if (a1 < CGRectGetMinX(v17)) {
    return v12 | 8;
  }
  else {
    return v12;
  }
}

double TSDAveragePoints(double a1, double a2, double a3)
{
  return (a1 + a3) * 0.5;
}

BOOL TSDSizeIsEmpty(double a1, double a2)
{
  return a2 == 0.0 || a1 == 0.0;
}

double TSDSizeWithMaxArea(double result, double a2, double a3, double a4)
{
  if (result * a2 <= a3 * a4) {
    return a3;
  }
  return result;
}

double TSDUnionRect(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  BOOL v8 = a7 <= 0.0;
  if (a8 > 0.0) {
    BOOL v8 = 0;
  }
  if (a3 > 0.0 || a4 > 0.0)
  {
    if (v8)
    {
      return a1;
    }
    else if (a1 < a5)
    {
      return a1;
    }
  }
  else if (v8)
  {
    return *MEMORY[0x263F001A8];
  }
  return a5;
}

double TSDHorizontalSpacingRect(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  double MinX = CGRectGetMinX(*(CGRect *)&a1);
  v31.origin.double x = a5;
  v31.origin.y = a6;
  v31.size.double width = a7;
  CGFloat v24 = a7;
  v31.size.height = a8;
  double v29 = fmax(MinX, CGRectGetMinX(v31));
  v32.origin.double x = a1;
  v32.origin.y = a2;
  v32.size.double width = a3;
  v32.size.height = a4;
  double MaxX = CGRectGetMaxX(v32);
  v33.origin.double x = a5;
  v33.origin.y = a6;
  v33.size.double width = a7;
  v33.size.height = a8;
  double v27 = fmin(MaxX, CGRectGetMaxX(v33));
  v34.origin.double x = a1;
  v34.origin.y = a2;
  v34.size.double width = a3;
  v34.size.height = a4;
  double MaxY = CGRectGetMaxY(v34);
  v35.origin.double x = a5;
  v35.origin.y = a6;
  v35.size.double width = v24;
  v35.size.height = a8;
  double v16 = fmin(MaxY, CGRectGetMaxY(v35));
  v36.origin.double x = a1;
  v36.origin.y = a2;
  v36.size.double width = a3;
  v36.size.height = a4;
  double MinY = CGRectGetMinY(v36);
  v37.origin.double x = a5;
  v37.origin.y = a6;
  v37.size.double width = v24;
  v37.size.height = a8;
  double v18 = fmax(MinY, CGRectGetMinY(v37));
  double v19 = v29;
  double v21 = v18 - v16;
  double v22 = v16;

  double v20 = v27 - v29;
  *(void *)&double result = (unint64_t)CGRectStandardize(*(CGRect *)&v19);
  return result;
}

double TSDVerticalSpacingRect(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  double MaxX = CGRectGetMaxX(*(CGRect *)&a1);
  v31.origin.double x = a5;
  v31.origin.y = a6;
  v31.size.double width = a7;
  CGFloat v24 = a7;
  v31.size.height = a8;
  double v29 = fmin(MaxX, CGRectGetMaxX(v31));
  v32.origin.double x = a1;
  v32.origin.y = a2;
  v32.size.double width = a3;
  v32.size.height = a4;
  double MinX = CGRectGetMinX(v32);
  v33.origin.double x = a5;
  v33.origin.y = a6;
  v33.size.double width = a7;
  v33.size.height = a8;
  double v27 = fmax(MinX, CGRectGetMinX(v33));
  v34.origin.double x = a1;
  v34.origin.y = a2;
  v34.size.double width = a3;
  v34.size.height = a4;
  double MinY = CGRectGetMinY(v34);
  v35.origin.double x = a5;
  v35.origin.y = a6;
  v35.size.double width = v24;
  v35.size.height = a8;
  double v16 = fmax(MinY, CGRectGetMinY(v35));
  v36.origin.double x = a1;
  v36.origin.y = a2;
  v36.size.double width = a3;
  v36.size.height = a4;
  double MaxY = CGRectGetMaxY(v36);
  v37.origin.double x = a5;
  v37.origin.y = a6;
  v37.size.double width = v24;
  v37.size.height = a8;
  double v18 = fmin(MaxY, CGRectGetMaxY(v37));
  double v19 = v29;
  double v21 = v18 - v16;
  double v22 = v16;

  double v20 = v27 - v29;
  *(void *)&double result = (unint64_t)CGRectStandardize(*(CGRect *)&v19);
  return result;
}

BOOL TSDIntersectsRect(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  if (a1 < a5) {
    BOOL result = a1 + a3 > a5;
  }
  else {
    BOOL result = a5 + a7 > a1;
  }
  if (a2 >= a6)
  {
    if (a6 + a8 > a2) {
      return result;
    }
    return 0;
  }
  if (a2 + a4 <= a6) {
    return 0;
  }
  return result;
}

BOOL TSDPointInRectInclusive(double a1, double a2, double a3, double a4, double a5, double a6)
{
  double v6 = a3 + a5;
  return a1 >= a3 && a1 <= v6 && a2 >= a4 && a2 <= a4 + a6;
}

double TSDAddPoints(double a1, double a2, double a3)
{
  return a1 + a3;
}

double TSDSubtractPoints(double a1, double a2, double a3)
{
  return a1 - a3;
}

double TSDAddSizes(double a1, double a2, double a3)
{
  return a1 + a3;
}

double TSDSubtractSizes(double a1, double a2, double a3)
{
  return a1 - a3;
}

double TSDMultiplyPointScalar(double a1, double a2, double a3)
{
  return a1 * a3;
}

double TSDMultiplyPointBySize(double a1, double a2, double a3)
{
  return a1 * a3;
}

double TSDMultiplyRectScalar(double a1, CGFloat a2, CGFloat a3, CGFloat a4, double a5)
{
  double v9 = a1;
  if (!CGRectIsInfinite(*(CGRect *)&a1))
  {
    v11.origin.double x = v9;
    v11.origin.y = a2;
    v11.size.double width = a3;
    v11.size.height = a4;
    if (!CGRectIsNull(v11)) {
      return v9 * a5;
    }
  }
  return v9;
}

double TSDMultiplyRectBySize(double a1, CGFloat a2, CGFloat a3, CGFloat a4, double a5)
{
  double v9 = a1;
  if (!CGRectIsInfinite(*(CGRect *)&a1))
  {
    v11.origin.double x = v9;
    v11.origin.y = a2;
    v11.size.double width = a3;
    v11.size.height = a4;
    if (!CGRectIsNull(v11)) {
      return v9 * a5;
    }
  }
  return v9;
}

double TSDFlooredPoint(double a1)
{
  return floor(a1);
}

double TSDFlooredSize(double a1)
{
  return floor(a1);
}

double TSDPointLength(double a1, double a2)
{
  return sqrt(a2 * a2 + a1 * a1);
}

double TSDPointSquaredLength(double a1, double a2)
{
  return a2 * a2 + a1 * a1;
}

double TSDDistance(double a1, double a2, double a3, double a4)
{
  return sqrt((a2 - a4) * (a2 - a4) + (a1 - a3) * (a1 - a3));
}

double TSDOrthogonalDistance(double a1, double a2, double a3, double a4)
{
  double v4 = a1 - a3;
  if (v4 < 0.0) {
    double v4 = -v4;
  }
  double v5 = a2 - a4;
  if (v5 < 0.0) {
    double v5 = -v5;
  }
  return v4 + v5;
}

void TSDDistanceToRect(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  v16.origin.double x = a3;
  v16.origin.y = a4;
  v16.size.double width = a5;
  v16.size.height = a6;
  if (a1 < CGRectGetMinX(v16))
  {
    v17.origin.double x = a3;
    v17.origin.y = a4;
    v17.size.double width = a5;
    v17.size.height = a6;
    if (a2 < CGRectGetMinY(v17))
    {
      v18.origin.double x = a3;
      v18.origin.y = a4;
      v18.size.double width = a5;
      v18.size.height = a6;
      CGRectGetMinX(v18);
LABEL_7:
      v22.origin.double x = a3;
      v22.origin.y = a4;
      v22.size.double width = a5;
      v22.size.height = a6;
      CGRectGetMinY(v22);
      return;
    }
    v23.origin.double x = a3;
    v23.origin.y = a4;
    v23.size.double width = a5;
    v23.size.height = a6;
    double MaxY = CGRectGetMaxY(v23);
    v24.origin.double x = a3;
    v24.origin.y = a4;
    v24.size.double width = a5;
    v24.size.height = a6;
    CGRectGetMinX(v24);
    if (a2 <= MaxY) {
      return;
    }
LABEL_13:
    v28.origin.double x = a3;
    v28.origin.y = a4;
    v28.size.double width = a5;
    v28.size.height = a6;
    CGRectGetMaxY(v28);
    return;
  }
  v19.origin.double x = a3;
  v19.origin.y = a4;
  v19.size.double width = a5;
  v19.size.height = a6;
  double MaxX = CGRectGetMaxX(v19);
  v20.origin.double x = a3;
  v20.origin.y = a4;
  v20.size.double width = a5;
  v20.size.height = a6;
  double MinY = CGRectGetMinY(v20);
  if (a1 <= MaxX)
  {
    if (a2 >= MinY)
    {
      v29.origin.double x = a3;
      v29.origin.y = a4;
      v29.size.double width = a5;
      v29.size.height = a6;
      if (a2 > CGRectGetMaxY(v29))
      {
        v30.origin.double x = a3;
        v30.origin.y = a4;
        v30.size.double width = a5;
        v30.size.height = a6;
        CGRectGetMaxY(v30);
      }
    }
    else
    {
      v25.origin.double x = a3;
      v25.origin.y = a4;
      v25.size.double width = a5;
      v25.size.height = a6;
      CGRectGetMinY(v25);
    }
    return;
  }
  if (a2 < MinY)
  {
    v21.origin.double x = a3;
    v21.origin.y = a4;
    v21.size.double width = a5;
    v21.size.height = a6;
    CGRectGetMaxX(v21);
    goto LABEL_7;
  }
  v26.origin.double x = a3;
  v26.origin.y = a4;
  v26.size.double width = a5;
  v26.size.height = a6;
  double v15 = CGRectGetMaxY(v26);
  v27.origin.double x = a3;
  v27.origin.y = a4;
  v27.size.double width = a5;
  v27.size.height = a6;
  CGRectGetMaxX(v27);
  if (a2 > v15) {
    goto LABEL_13;
  }
}

void TSDDistanceToRectFromRect(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  double MaxX = CGRectGetMaxX(*(CGRect *)&a1);
  v31.origin.double x = a5;
  v31.origin.y = a6;
  v31.size.double width = a7;
  v31.size.height = a8;
  if (MaxX >= CGRectGetMinX(v31))
  {
    v38.origin.double x = a1;
    v38.origin.y = a2;
    v38.size.double width = a3;
    v38.size.height = a4;
    double MinX = CGRectGetMinX(v38);
    v39.origin.double x = a5;
    v39.origin.y = a6;
    v39.size.double width = a7;
    v39.size.height = a8;
    double v26 = CGRectGetMaxX(v39);
    v40.origin.double x = a1;
    v40.origin.y = a2;
    v40.size.double width = a3;
    v40.size.height = a4;
    double MaxY = CGRectGetMaxY(v40);
    CGFloat v29 = a6;
    v41.origin.double x = a5;
    v41.origin.y = a6;
    v41.size.double width = a7;
    v41.size.height = a8;
    double MinY = CGRectGetMinY(v41);
    if (MinX <= v26)
    {
      if (MaxY >= MinY)
      {
        v61.origin.double x = a1;
        v61.origin.y = a2;
        v61.size.double width = a3;
        v61.size.height = a4;
        double v25 = CGRectGetMinY(v61);
        v62.origin.double x = a5;
        v62.origin.y = a6;
        v62.size.double width = a7;
        v62.size.height = a8;
        if (v25 <= CGRectGetMaxY(v62)) {
          return;
        }
        v63.origin.double x = a1;
        v63.origin.y = a2;
        v63.size.double width = a3;
        v63.size.height = a4;
        CGRectGetMinY(v63);
        CGFloat v20 = a5;
        CGFloat v21 = a6;
        CGFloat v22 = a7;
        CGFloat v23 = a8;
      }
      else
      {
        v52.origin.double x = a5;
        v52.origin.y = a6;
        v52.size.double width = a7;
        v52.size.height = a8;
        CGRectGetMinY(v52);
        CGFloat v20 = a1;
        CGFloat v21 = a2;
        CGFloat v22 = a3;
        CGFloat v23 = a4;
      }
      CGRectGetMaxY(*(CGRect *)&v20);
    }
    else if (MaxY >= MinY)
    {
      v53.origin.double x = a1;
      v53.origin.y = a2;
      v53.size.double width = a3;
      v53.size.height = a4;
      double v27 = CGRectGetMinY(v53);
      v54.origin.double x = a5;
      v54.origin.y = a6;
      v54.size.double width = a7;
      v54.size.height = a8;
      double v24 = CGRectGetMaxY(v54);
      v55.origin.double x = a1;
      v55.origin.y = a2;
      v55.size.double width = a3;
      v55.size.height = a4;
      CGRectGetMinX(v55);
      if (v27 > v24)
      {
        v56.origin.double x = a1;
        v56.origin.y = a2;
        v56.size.double width = a3;
        v56.size.height = a4;
        CGRectGetMinY(v56);
        v57.origin.double x = a5;
        v57.origin.y = v29;
        v57.size.double width = a7;
        v57.size.height = a8;
        CGRectGetMaxX(v57);
      }
      v58.origin.double x = a5;
      v58.origin.y = v29;
      v58.size.double width = a7;
      v58.size.height = a8;
      CGRectGetMaxY(v58);
    }
    else
    {
      v42.origin.double x = a1;
      v42.origin.y = a2;
      v42.size.double width = a3;
      v42.size.height = a4;
      CGRectGetMinX(v42);
      v43.origin.double x = a1;
      v43.origin.y = a2;
      v43.size.double width = a3;
      v43.size.height = a4;
      CGRectGetMaxY(v43);
      v44.origin.double x = a5;
      v44.origin.y = a6;
      v44.size.double width = a7;
      v44.size.height = a8;
      CGRectGetMaxX(v44);
      v45.origin.double x = a5;
      v45.origin.y = a6;
      v45.size.double width = a7;
      v45.size.height = a8;
      CGRectGetMinY(v45);
    }
  }
  else
  {
    v32.origin.double x = a1;
    v32.origin.y = a2;
    v32.size.double width = a3;
    v32.size.height = a4;
    double v16 = CGRectGetMaxY(v32);
    v33.origin.double x = a5;
    v33.origin.y = a6;
    v33.size.double width = a7;
    v33.size.height = a8;
    if (v16 >= CGRectGetMinY(v33))
    {
      v46.origin.double x = a1;
      v46.origin.y = a2;
      v46.size.double width = a3;
      v46.size.height = a4;
      double v19 = CGRectGetMinY(v46);
      v47.origin.double x = a5;
      v47.origin.y = a6;
      v47.size.double width = a7;
      v47.size.height = a8;
      if (v19 <= CGRectGetMaxY(v47))
      {
        v59.origin.double x = a5;
        v59.origin.y = a6;
        v59.size.double width = a7;
        v59.size.height = a8;
        CGRectGetMinX(v59);
        v60.origin.double x = a1;
        v60.origin.y = a2;
        v60.size.double width = a3;
        v60.size.height = a4;
        CGRectGetMaxX(v60);
      }
      else
      {
        v48.origin.double x = a1;
        v48.origin.y = a2;
        v48.size.double width = a3;
        v48.size.height = a4;
        CGRectGetMaxX(v48);
        v49.origin.double x = a1;
        v49.origin.y = a2;
        v49.size.double width = a3;
        v49.size.height = a4;
        CGRectGetMinY(v49);
        v50.origin.double x = a5;
        v50.origin.y = a6;
        v50.size.double width = a7;
        v50.size.height = a8;
        CGRectGetMinX(v50);
        v51.origin.double x = a5;
        v51.origin.y = a6;
        v51.size.double width = a7;
        v51.size.height = a8;
        CGRectGetMaxY(v51);
      }
    }
    else
    {
      v34.origin.double x = a1;
      v34.origin.y = a2;
      v34.size.double width = a3;
      v34.size.height = a4;
      CGRectGetMaxX(v34);
      v35.origin.double x = a1;
      v35.origin.y = a2;
      v35.size.double width = a3;
      v35.size.height = a4;
      CGRectGetMaxY(v35);
      v36.origin.double x = a5;
      v36.origin.y = a6;
      v36.size.double width = a7;
      v36.size.height = a8;
      CGRectGetMinX(v36);
      v37.origin.double x = a5;
      v37.origin.y = a6;
      v37.size.double width = a7;
      v37.size.height = a8;
      CGRectGetMinY(v37);
    }
  }
}

double TSDCenterOfRect(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  double MidX = CGRectGetMidX(*(CGRect *)&a1);
  v10.origin.double x = a1;
  v10.origin.y = a2;
  v10.size.double width = a3;
  v10.size.height = a4;
  CGRectGetMidY(v10);
  return MidX;
}

double TSDRectGetMaxPoint(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  double MaxX = CGRectGetMaxX(*(CGRect *)&a1);
  v10.origin.double x = a1;
  v10.origin.y = a2;
  v10.size.double width = a3;
  v10.size.height = a4;
  CGRectGetMaxY(v10);
  return MaxX;
}

double TSDComplexMultiplyPoint(double a1, double a2, double a3, double a4)
{
  return a1 * a3 - a2 * a4;
}

double TSDNormalizePoint(double a1, double a2)
{
  return a1 * (1.0 / sqrt(a2 * a2 + a1 * a1));
}

double TSDDotPoints(double a1, double a2, double a3, double a4)
{
  return a2 * a4 + a1 * a3;
}

double TSDCrossPoints(double a1, double a2, double a3, double a4)
{
  return a2 * a3 - a1 * a4;
}

double TSDGrowRectToPoint(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  if (CGRectIsNull(*(CGRect *)&a1)) {
    return a5;
  }
  v14.origin.double x = a1;
  v14.origin.y = a2;
  v14.size.double width = a3;
  v14.size.height = a4;
  double MinX = a5;
  if (CGRectGetMinX(v14) < a5)
  {
    v15.origin.double x = a1;
    v15.origin.y = a2;
    v15.size.double width = a3;
    v15.size.height = a4;
    double MinX = CGRectGetMinX(v15);
  }
  v16.origin.double x = a1;
  v16.origin.y = a2;
  v16.size.double width = a3;
  v16.size.height = a4;
  if (CGRectGetMaxX(v16) > a5)
  {
    v17.origin.double x = a1;
    v17.origin.y = a2;
    v17.size.double width = a3;
    v17.size.height = a4;
    CGRectGetMaxX(v17);
  }
  v18.origin.double x = a1;
  v18.origin.y = a2;
  v18.size.double width = a3;
  v18.size.height = a4;
  if (CGRectGetMinY(v18) < a6)
  {
    v19.origin.double x = a1;
    v19.origin.y = a2;
    v19.size.double width = a3;
    v19.size.height = a4;
    CGRectGetMinY(v19);
  }
  v20.origin.double x = a1;
  v20.origin.y = a2;
  v20.size.double width = a3;
  v20.size.height = a4;
  if (CGRectGetMaxY(v20) > a6)
  {
    v21.origin.double x = a1;
    v21.origin.y = a2;
    v21.size.double width = a3;
    v21.size.height = a4;
    CGRectGetMaxY(v21);
  }
  return MinX;
}

double TSDFlipRect(double a1, double a2, double a3, double a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  CGRectGetMidY(*(CGRect *)&a1);
  v14.origin.double x = a5;
  v14.origin.y = a6;
  v14.size.double width = a7;
  v14.size.height = a8;
  CGRectGetMidY(v14);
  return a1;
}

double TSDCenterRectOverRect(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  v26.origin.double x = a5;
  v26.origin.y = a6;
  v26.size.double width = a7;
  v26.size.height = a8;
  double MidX = CGRectGetMidX(v26);
  v27.origin.double x = a5;
  v27.origin.y = a6;
  v27.size.double width = a7;
  v27.size.height = a8;
  double MidY = CGRectGetMidY(v27);
  v28.origin.double x = a1;
  v28.origin.y = a2;
  v28.size.double width = a3;
  v28.size.height = a4;
  double v17 = CGRectGetMidX(v28);
  v29.origin.double x = a1;
  v29.origin.y = a2;
  v29.size.double width = a3;
  v29.size.height = a4;
  double v18 = MidY - CGRectGetMidY(v29);
  CGFloat v19 = a1;
  CGFloat v20 = a2;
  CGFloat v21 = a3;
  CGFloat v22 = a4;

  *(void *)&double result = (unint64_t)CGRectOffset(*(CGRect *)&v19, MidX - v17, v18);
  return result;
}

BOOL TSDRectIsFinite(double a1, double a2, double a3, double a4)
{
  BOOL result = 0;
  if (fabs(a1) != INFINITY && fabs(a2) != INFINITY && fabs(a3) != INFINITY)
  {
    double v5 = fabs(a4);
    return v5 > INFINITY || v5 < INFINITY;
  }
  return result;
}

void TSDRectDivide(CGRect *a1, CGRect *a2, CGRectEdge a3, double a4, double a5, double a6, double a7, CGFloat a8)
{
  memset(v8, 0, sizeof(v8));
  if (!a1) {
    a1 = (CGRect *)v8;
  }
  if (!a2) {
    a2 = (CGRect *)v8;
  }
  CGRectDivide(*(CGRect *)&a4, a1, a2, a8, a3);
}

uint64_t TSDGetCanvasSpaceCorners(uint64_t a1, _OWORD *a2, _OWORD *a3, _OWORD *a4, _OWORD *a5, CGFloat a6, CGFloat a7, CGFloat a8, CGFloat a9)
{
  v53[2] = *(double *)MEMORY[0x263EF8340];
  long long v18 = *(_OWORD *)(a1 + 16);
  float64x2_t v46 = *(float64x2_t *)a1;
  long long v47 = v18;
  long long v48 = *(_OWORD *)(a1 + 32);
  TSDTransformedCornersOfRect(&v46, &v49, &v51, &v52, v53, a6, a7, a8, a9);
  v54.origin.double x = a6;
  v54.origin.y = a7;
  v54.size.double width = a8;
  v54.size.height = a9;
  double MidX = CGRectGetMidX(v54);
  v55.origin.double x = a6;
  v55.origin.y = a7;
  v55.size.double width = a8;
  v55.size.height = a9;
  CGFloat MidY = CGRectGetMidY(v55);
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  double v23 = *(double *)(a1 + 32) + MidY * *(double *)(a1 + 16) + *(double *)a1 * MidX;
  double v24 = 1000000.0;
  double v25 = *(double *)(a1 + 40) + MidY * *(double *)(a1 + 24) + *(double *)(a1 + 8) * MidX;
  CGRect v26 = (double *)&v50;
  do
  {
    long double v27 = atan2(*v26 - v25, *(v26 - 1) - v23);
    double v28 = fmod(v27 * 57.2957795, 360.0);
    if (v28 < 0.0) {
      double v28 = v28 + 360.0;
    }
    if (v28 == 0.0) {
      double v29 = 225.0;
    }
    else {
      double v29 = 360.0 - v28 + -135.0;
    }
    double v30 = fabs(v29);
    if (v30 < v24)
    {
      uint64_t v21 = v22;
      double v24 = v30;
    }
    ++v22;
    v26 += 2;
  }
  while (v22 != 4);
  *a2 = *((_OWORD *)&v49 + v21);
  uint64_t v31 = (v21 + 2) & 3;
  if (v21 + 2 <= 0) {
    uint64_t v31 = -(-(v21 + 2) & 3);
  }
  *a4 = *((_OWORD *)&v49 + v31);
  long long v32 = *(_OWORD *)(a1 + 16);
  float64x2_t v46 = *(float64x2_t *)a1;
  long long v47 = v32;
  long long v48 = *(_OWORD *)(a1 + 32);
  BOOL v33 = TSDIsTransformFlipped(v46.f64);
  uint64_t v34 = v21 + 3;
  if (v33) {
    uint64_t v35 = v21 + 1;
  }
  else {
    uint64_t v35 = v21 + 3;
  }
  uint64_t v36 = v35 & 3;
  if (!v33) {
    uint64_t v34 = v21 + 1;
  }
  uint64_t v38 = -v35;
  BOOL v37 = v38 < 0;
  uint64_t v39 = v38 & 3;
  if (v37) {
    uint64_t v40 = v36;
  }
  else {
    uint64_t v40 = -v39;
  }
  *a5 = *((_OWORD *)&v49 + v40);
  uint64_t v41 = v34 & 3;
  uint64_t v42 = -v34;
  BOOL v37 = v42 < 0;
  uint64_t v43 = v42 & 3;
  if (v37) {
    uint64_t v44 = v41;
  }
  else {
    uint64_t v44 = -v43;
  }
  *a3 = *((_OWORD *)&v49 + v44);
  return v21;
}

double TSDAngleFromDelta(long double a1, long double a2)
{
  return atan2(a2, a1);
}

void TSDNormalizeAngleInDegrees(long double a1)
{
}

double TSDInterpolatePoints(double a1, double a2, double a3, double a4, double a5)
{
  return a3 * a5 + a1 * (1.0 - a5);
}

double TSDMixPoints(double a1, double a2, double a3, double a4, double a5)
{
  return a3 * a5 + a1 * (1.0 - a5);
}

double TSDInterpolateFloats(double a1, double a2, double a3)
{
  return a2 * a3 + a1 * (1.0 - a3);
}

double TSDMixFloats(double a1, double a2, double a3)
{
  return a2 * a3 + a1 * (1.0 - a3);
}

void TSDMixAnglesInDegrees(long double a1, long double a2, double a3)
{
  double v5 = fmod(a1, 360.0);
  if (v5 < 0.0) {
    double v5 = v5 + 360.0;
  }
  if (v5 == 0.0) {
    double v6 = 0.0;
  }
  else {
    double v6 = v5;
  }
  double v7 = fmod(a2, 360.0);
  if (v7 < 0.0) {
    double v7 = v7 + 360.0;
  }
  if (v7 == 0.0) {
    double v7 = 0.0;
  }
  if (vabdd_f64(v7, v6) > 180.0)
  {
    if (v6 <= v7) {
      double v7 = v7 + -360.0;
    }
    else {
      double v7 = v7 + 360.0;
    }
  }
  fmod(v7 * a3 + v6 * (1.0 - a3), 360.0);
}

double TSDMixAnglesInRadians(double a1, double a2, double a3)
{
  TSDMixAnglesInDegrees(a1 * 57.2957795, a2 * 57.2957795, a3);
  return v3 * 0.0174532925;
}

double TSDMixSizes(double a1, double a2, double a3, double a4, double a5)
{
  return a3 * a5 + a1 * (1.0 - a5);
}

double TSDMixRects(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  return a5 * a9 + a1 * (1.0 - a9);
}

double TSDClampPointInRect()
{
  TSUClamp();
  double v1 = v0;
  TSUClamp();
  return v1;
}

double TSDTranslatedRectMaximizingOverlapWithRect(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  v50.origin.double x = a5;
  v50.origin.y = a6;
  v50.size.double width = a7;
  v50.size.height = a8;
  double MaxX = CGRectGetMaxX(v50);
  double v47 = a1;
  v51.origin.double x = a1;
  v51.origin.y = a2;
  v51.size.double width = a3;
  v51.size.height = a4;
  CGFloat v46 = a1;
  if (MaxX > CGRectGetMaxX(v51))
  {
    v52.origin.double x = a5;
    v52.origin.y = a6;
    v52.size.double width = a7;
    v52.size.height = a8;
    double MinX = CGRectGetMinX(v52);
    v53.origin.double x = a1;
    v53.origin.y = a2;
    v53.size.double width = a3;
    v53.size.height = a4;
    if (MinX > CGRectGetMinX(v53))
    {
      v54.origin.double x = a5;
      v54.origin.y = a6;
      v54.size.double width = a7;
      v54.size.height = a8;
      double v38 = CGRectGetMaxX(v54);
      v55.origin.double x = a1;
      v55.origin.y = a2;
      v55.size.double width = a3;
      v55.size.height = a4;
      double v39 = v38 - CGRectGetMaxX(v55);
      v56.origin.double x = a5;
      v56.origin.y = a6;
      v56.size.double width = a7;
      v56.size.height = a8;
      double v17 = CGRectGetMinX(v56);
      v57.origin.double x = a1;
      v57.origin.y = a2;
      v57.size.double width = a3;
      v57.size.height = a4;
      if (v39 >= v17 - CGRectGetMinX(v57))
      {
        v70.origin.double x = a5;
        v70.origin.y = a6;
        v70.size.double width = a7;
        v70.size.height = a8;
        double v18 = CGRectGetMinX(v70);
        v71.origin.double x = a1;
        v71.origin.y = a2;
        v71.size.double width = a3;
        v71.size.height = a4;
        double v19 = CGRectGetMinX(v71);
      }
      else
      {
        v58.origin.double x = a5;
        v58.origin.y = a6;
        v58.size.double width = a7;
        v58.size.height = a8;
        double v18 = CGRectGetMaxX(v58);
        v59.origin.double x = a1;
        v59.origin.y = a2;
        v59.size.double width = a3;
        v59.size.height = a4;
        double v19 = CGRectGetMaxX(v59);
      }
      double v25 = v47 + v18 - v19;
LABEL_13:
      double v47 = v25;
      goto LABEL_14;
    }
  }
  v60.origin.double x = a5;
  v60.origin.y = a6;
  v60.size.double width = a7;
  v60.size.height = a8;
  double v20 = CGRectGetMinX(v60);
  v61.origin.double x = a1;
  v61.origin.y = a2;
  v61.size.double width = a3;
  v61.size.height = a4;
  if (v20 < CGRectGetMinX(v61))
  {
    v62.origin.double x = a5;
    v62.origin.y = a6;
    v62.size.double width = a7;
    v62.size.height = a8;
    double v21 = CGRectGetMaxX(v62);
    v63.origin.double x = a1;
    v63.origin.y = a2;
    v63.size.double width = a3;
    v63.size.height = a4;
    if (v21 < CGRectGetMaxX(v63))
    {
      v64.origin.double x = a1;
      v64.origin.y = a2;
      v64.size.double width = a3;
      v64.size.height = a4;
      double v40 = CGRectGetMinX(v64);
      v65.origin.double x = a5;
      v65.origin.y = a6;
      v65.size.double width = a7;
      v65.size.height = a8;
      double v41 = v40 - CGRectGetMinX(v65);
      v66.origin.double x = a1;
      v66.origin.y = a2;
      v66.size.double width = a3;
      v66.size.height = a4;
      double v22 = CGRectGetMaxX(v66);
      v67.origin.double x = a5;
      v67.origin.y = a6;
      v67.size.double width = a7;
      v67.size.height = a8;
      if (v41 >= v22 - CGRectGetMaxX(v67))
      {
        v72.origin.double x = a1;
        v72.origin.y = a2;
        v72.size.double width = a3;
        v72.size.height = a4;
        double v23 = CGRectGetMaxX(v72);
        v73.origin.double x = a5;
        v73.origin.y = a6;
        v73.size.double width = a7;
        v73.size.height = a8;
        double v24 = CGRectGetMaxX(v73);
      }
      else
      {
        v68.origin.double x = a1;
        v68.origin.y = a2;
        v68.size.double width = a3;
        v68.size.height = a4;
        double v23 = CGRectGetMinX(v68);
        v69.origin.double x = a5;
        v69.origin.y = a6;
        v69.size.double width = a7;
        v69.size.height = a8;
        double v24 = CGRectGetMinX(v69);
      }
      double v25 = v47 - (v23 - v24);
      goto LABEL_13;
    }
  }
LABEL_14:
  v74.origin.double x = a5;
  v74.origin.y = a6;
  v74.size.double width = a7;
  v74.size.height = a8;
  double MaxY = CGRectGetMaxY(v74);
  v75.origin.double x = a1;
  v75.origin.y = a2;
  v75.size.double width = a3;
  v75.size.height = a4;
  if (MaxY <= CGRectGetMaxY(v75)) {
    goto LABEL_18;
  }
  v76.origin.double x = a5;
  v76.origin.y = a6;
  v76.size.double width = a7;
  v76.size.height = a8;
  double MinY = CGRectGetMinY(v76);
  v77.origin.double x = a1;
  v77.origin.y = a2;
  v77.size.double width = a3;
  v77.size.height = a4;
  if (MinY <= CGRectGetMinY(v77))
  {
LABEL_18:
    v84.origin.double x = a5;
    v84.origin.y = a6;
    v84.size.double width = a7;
    v84.size.height = a8;
    double v29 = CGRectGetMinY(v84);
    v85.origin.double x = a1;
    v85.origin.y = a2;
    v85.size.double width = a3;
    v85.size.height = a4;
    if (v29 < CGRectGetMinY(v85))
    {
      v86.origin.double x = a5;
      v86.origin.y = a6;
      v86.size.double width = a7;
      v86.size.height = a8;
      double v30 = CGRectGetMaxY(v86);
      v87.origin.double x = a1;
      v87.origin.y = a2;
      v87.size.double width = a3;
      v87.size.height = a4;
      if (v30 < CGRectGetMaxY(v87))
      {
        v88.origin.double x = a1;
        v88.origin.y = a2;
        v88.size.double width = a3;
        v88.size.height = a4;
        double v44 = CGRectGetMinY(v88);
        v89.origin.double x = a5;
        v89.origin.y = a6;
        v89.size.double width = a7;
        v89.size.height = a8;
        double v45 = v44 - CGRectGetMinY(v89);
        v90.origin.double x = a1;
        v90.origin.y = a2;
        v90.size.double width = a3;
        v90.size.height = a4;
        double v31 = CGRectGetMaxY(v90);
        v91.origin.double x = a5;
        v91.origin.y = a6;
        v91.size.double width = a7;
        v91.size.height = a8;
        BOOL v32 = v45 < v31 - CGRectGetMaxY(v91);
        CGFloat v33 = v46;
        CGFloat v34 = a2;
        CGFloat v35 = a3;
        CGFloat v36 = a4;
        if (v32)
        {
          CGRectGetMinY(*(CGRect *)&v33);
          v92.origin.double x = a5;
          v92.origin.y = a6;
          v92.size.double width = a7;
          v92.size.height = a8;
          CGRectGetMinY(v92);
        }
        else
        {
          CGRectGetMaxY(*(CGRect *)&v33);
          v95.origin.double x = a5;
          v95.origin.y = a6;
          v95.size.double width = a7;
          v95.size.height = a8;
          CGRectGetMaxY(v95);
        }
      }
    }
  }
  else
  {
    v78.origin.double x = a5;
    v78.origin.y = a6;
    v78.size.double width = a7;
    v78.size.height = a8;
    double v42 = CGRectGetMaxY(v78);
    v79.origin.double x = a1;
    v79.origin.y = a2;
    v79.size.double width = a3;
    v79.size.height = a4;
    double v43 = v42 - CGRectGetMaxY(v79);
    v80.origin.double x = a5;
    v80.origin.y = a6;
    v80.size.double width = a7;
    v80.size.height = a8;
    double v28 = CGRectGetMinY(v80);
    v81.origin.double x = v46;
    v81.origin.y = a2;
    v81.size.double width = a3;
    v81.size.height = a4;
    if (v43 >= v28 - CGRectGetMinY(v81))
    {
      v93.origin.double x = a5;
      v93.origin.y = a6;
      v93.size.double width = a7;
      v93.size.height = a8;
      CGRectGetMinY(v93);
      v94.origin.double x = v46;
      v94.origin.y = a2;
      v94.size.double width = a3;
      v94.size.height = a4;
      CGRectGetMinY(v94);
    }
    else
    {
      v82.origin.double x = a5;
      v82.origin.y = a6;
      v82.size.double width = a7;
      v82.size.height = a8;
      CGRectGetMaxY(v82);
      v83.origin.double x = v46;
      v83.origin.y = a2;
      v83.size.double width = a3;
      v83.size.height = a4;
      CGRectGetMaxY(v83);
    }
  }
  return v47;
}

double TSDOriginRotate(double *a1, double a2, double a3)
{
  __double2 v5 = __sincos_stret(a3);
  double result = v5.__sinval * a2;
  *a1 = v5.__cosval * a2;
  a1[1] = v5.__sinval * a2;
  return result;
}

double TSDNiceAngleFromDelta(long double a1, long double a2)
{
  if (a2 != 0.0) {
    return atan2(a2, a1);
  }
  double result = 3.14159265;
  if (a1 >= 0.0) {
    return 0.0;
  }
  return result;
}

double TSDDeltaFromAngle(double a1)
{
  if (a1 == 0.0) {
    return 1.0;
  }
  return __sincos_stret(a1).__cosval;
}

double TSDShiftConstrainDelta(long double a1, long double a2)
{
  long double v4 = atan2(a2, a1);
  return sqrt(a2 * a2 + a1 * a1)
       * __sincos_stret((double)(int)((v4 + 6.28318531) / 0.785398163 + 0.5) * 0.785398163).__cosval;
}

double TSDShiftConstrainDeltaToAngle(double a1, double a2, double a3)
{
  return __sincos_stret(a3).__cosval * sqrt(a2 * a2 + a1 * a1);
}

double TSDRotatePoint90Degrees(int a1, double a2, double a3)
{
  if (a1) {
    return -a3;
  }
  else {
    return a3;
  }
}

void TSDNormalizeAngleInRadians(long double a1)
{
}

void TSDNormalizeAngleAboutZeroInRadians(double a1)
{
}

double TSDDeltaApplyAffineTransform(float64x2_t *a1, double a2, double a3)
{
  *(void *)&double result = *(_OWORD *)&vsubq_f64(vaddq_f64(a1[2], vmlaq_n_f64(vmulq_n_f64(a1[1], a3), *a1, a2)), vaddq_f64(a1[2], vmlaq_n_f64(vmulq_n_f64(a1[1], *(double *)(MEMORY[0x263F00148] + 8)), *a1, *MEMORY[0x263F00148])));
  return result;
}

void TSDDistanceBetweenAnglesInRadians(long double a1, long double a2)
{
}

double TSDNormalizedPointInRect(double a1, double a2, double a3, double a4, double a5)
{
  return (a1 - a3) / a5;
}

double TSDPointFromNormalizedRect(double a1, double a2, double a3, double a4, double a5)
{
  return a3 + a1 * a5;
}

void TSDRectFromNormalizedSubrect(double a1, double a2, double a3, double a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  v12.origin.double x = a5;
  v12.origin.y = a6;
  v12.size.double width = a7;
  v12.size.height = a8;
  CGRectGetMaxX(v12);
  v13.origin.double x = a5;
  v13.origin.y = a6;
  v13.size.double width = a7;
  v13.size.height = a8;
  CGRectGetMaxY(v13);
}

double TSDRectSubtractingRect(double a1, CGFloat a2, CGFloat a3, CGFloat a4, double a5, double a6, double a7, double a8)
{
  double v11 = a1;
  CGRect v42 = CGRectIntersection(*(CGRect *)&a1, *(CGRect *)&a5);
  CGFloat x = v42.origin.x;
  CGFloat y = v42.origin.y;
  CGFloat width = v42.size.width;
  CGFloat height = v42.size.height;
  if (!CGRectIsNull(v42))
  {
    v43.origin.CGFloat x = x;
    v43.origin.CGFloat y = y;
    v43.size.CGFloat width = width;
    v43.size.CGFloat height = height;
    double MaxY = CGRectGetMaxY(v43);
    v44.origin.CGFloat x = v11;
    v44.origin.CGFloat y = a2;
    v44.size.CGFloat width = a3;
    v44.size.CGFloat height = a4;
    double MinY = CGRectGetMinY(v44);
    v45.origin.CGFloat x = v11;
    v45.origin.CGFloat y = a2;
    v45.size.CGFloat width = a3;
    v45.size.CGFloat height = a4;
    double v37 = CGRectGetMaxY(v45);
    v46.origin.CGFloat x = x;
    v46.origin.CGFloat y = y;
    v46.size.CGFloat width = width;
    v46.size.CGFloat height = height;
    double v38 = v37 - CGRectGetMaxY(v46);
    v47.origin.CGFloat x = v11;
    v47.origin.CGFloat y = a2;
    v47.size.CGFloat width = a3;
    v47.size.CGFloat height = a4;
    double v33 = v38 * CGRectGetWidth(v47);
    CGFloat v36 = height;
    CGFloat v39 = x;
    v48.origin.CGFloat x = x;
    v48.origin.CGFloat y = y;
    v48.size.CGFloat width = width;
    v48.size.CGFloat height = height;
    double v16 = CGRectGetMinY(v48);
    v49.origin.CGFloat x = v11;
    v49.origin.CGFloat y = a2;
    v49.size.CGFloat width = a3;
    v49.size.CGFloat height = a4;
    double v17 = v16 - CGRectGetMinY(v49);
    v50.origin.CGFloat x = v11;
    v50.origin.CGFloat y = a2;
    v50.size.CGFloat width = a3;
    v50.size.CGFloat height = a4;
    double v18 = v17 * CGRectGetWidth(v50);
    double v19 = v33;
    if (v18 <= v33)
    {
      double v35 = MaxY - MinY;
      CGRectEdge v21 = CGRectMinYEdge;
    }
    else
    {
      v51.origin.CGFloat x = v11;
      v51.origin.CGFloat y = a2;
      v51.size.CGFloat width = a3;
      v51.size.CGFloat height = a4;
      double v20 = CGRectGetMaxY(v51);
      v52.size.CGFloat height = v36;
      v52.origin.CGFloat x = v39;
      v52.origin.CGFloat y = y;
      v52.size.CGFloat width = width;
      double v35 = v20 - CGRectGetMinY(v52);
      CGRectEdge v21 = CGRectMaxYEdge;
      double v19 = v18;
    }
    v53.origin.CGFloat x = v11;
    v53.origin.CGFloat y = a2;
    v53.size.CGFloat width = a3;
    v53.size.CGFloat height = a4;
    double MaxX = CGRectGetMaxX(v53);
    v54.size.CGFloat height = v36;
    v54.origin.CGFloat x = v39;
    v54.origin.CGFloat y = y;
    v54.size.CGFloat width = width;
    double v23 = MaxX - CGRectGetMaxX(v54);
    v55.origin.CGFloat x = v11;
    v55.origin.CGFloat y = a2;
    v55.size.CGFloat width = a3;
    v55.size.CGFloat height = a4;
    double v24 = v23 * CGRectGetHeight(v55);
    if (v24 > v19)
    {
      v56.size.CGFloat height = v36;
      v56.origin.CGFloat x = v39;
      v56.origin.CGFloat y = y;
      v56.size.CGFloat width = width;
      double v25 = CGRectGetMaxX(v56);
      v57.origin.CGFloat x = v11;
      v57.origin.CGFloat y = a2;
      v57.size.CGFloat width = a3;
      v57.size.CGFloat height = a4;
      CGRectEdge v21 = CGRectMinXEdge;
      double v35 = v25 - CGRectGetMinX(v57);
      double v19 = v24;
    }
    v58.size.CGFloat height = v36;
    v58.origin.CGFloat x = v39;
    v58.origin.CGFloat y = y;
    v58.size.CGFloat width = width;
    double MinX = CGRectGetMinX(v58);
    v59.origin.CGFloat x = v11;
    v59.origin.CGFloat y = a2;
    v59.size.CGFloat width = a3;
    v59.size.CGFloat height = a4;
    double v27 = MinX - CGRectGetMinX(v59);
    v60.origin.CGFloat x = v11;
    v60.origin.CGFloat y = a2;
    v60.size.CGFloat width = a3;
    v60.size.CGFloat height = a4;
    CGFloat v28 = CGRectGetHeight(v60);
    double v29 = v35;
    if (v27 * v28 > v19)
    {
      v61.origin.CGFloat x = v11;
      v61.origin.CGFloat y = a2;
      v61.size.CGFloat width = a3;
      v61.size.CGFloat height = a4;
      double v30 = CGRectGetMaxX(v61);
      v62.size.CGFloat height = v36;
      v62.origin.CGFloat x = v39;
      v62.origin.CGFloat y = y;
      v62.size.CGFloat width = width;
      double v29 = v30 - CGRectGetMinX(v62);
      CGRectEdge v21 = CGRectMaxXEdge;
    }
    memset(&remainder, 0, sizeof(remainder));
    memset(&slice, 0, sizeof(slice));
    v63.origin.CGFloat x = v11;
    v63.origin.CGFloat y = a2;
    v63.size.CGFloat width = a3;
    v63.size.CGFloat height = a4;
    CGRectDivide(v63, &slice, &remainder, v29, v21);
    return remainder.origin.x;
  }
  return v11;
}

double TSDSizeWithAspectRatio(int a1, double result, double a3, double a4, double a5)
{
  BOOL v5 = result == a4 && a3 == a5;
  if (!v5 && a4 != 0.0 && a5 != 0.0 && a4 != 3.40282347e38 && a5 != 3.40282347e38)
  {
    if (a1)
    {
      double v6 = sqrt(a5 * a5 + a4 * a4);
      return a4 / v6 * (a3 * (a5 / v6) + result * (a4 / v6));
    }
    else if (vabdd_f64(result, a4) < 0.01)
    {
      return a3 * a4 / a5;
    }
  }
  return result;
}

double TSDSizeExpandedToMatchAspectRatio(double a1, double a2, double a3, double a4)
{
  BOOL v4 = a1 != a3;
  if (a2 != a4) {
    BOOL v4 = 1;
  }
  BOOL v5 = a3 <= 0.0 || !v4;
  if (v5 || a4 <= 0.0) {
    goto LABEL_12;
  }
  double v6 = a3 / a4;
  if (v6 <= a1 / a2)
  {
    if (v6 < a1 / a2)
    {
      double v7 = a1;
      double v8 = a1 / v6;
      goto LABEL_13;
    }
LABEL_12:
    double v8 = a2;
    double v7 = a1;
    goto LABEL_13;
  }
  double v7 = a2 * v6;
  double v8 = a2;
LABEL_13:
  if (v7 < a1 || v8 < a2)
  {
    double v9 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v10 = objc_msgSend(NSString, "stringWithUTF8String:", "CGSize TSDSizeExpandedToMatchAspectRatio(CGSize, CGSize)");
    objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGeometry.m"), 992, @"TSDSizeExpandedToMatchAspectRatio() actually shrank the size");
  }
  return v7;
}

double TSDScaleSizeWithinSize(double a1, double a2, double a3, double a4)
{
  if (a1 / a2 < a3 / a4) {
    return a1 * (a4 / a2);
  }
  return a3;
}

double TSDShrinkSizeToFitInSize(double result, double a2, double a3, double a4)
{
  if (result <= a3)
  {
    BOOL v4 = a2 == a4;
    BOOL v5 = a2 < a4;
  }
  else
  {
    BOOL v4 = 0;
    BOOL v5 = 0;
  }
  if (!v5 && !v4)
  {
    if (result / a2 <= a3 / a4)
    {
      if (result / a2 < a3 / a4) {
        return result * (a4 / a2);
      }
      else {
        return a3;
      }
    }
    else
    {
      return a3;
    }
  }
  return result;
}

double TSDFitOrFillSizeInSize(int a1, double a2, double a3, double a4, double a5)
{
  double v5 = a4 / a2;
  double v6 = a5 / a3;
  if (v5 <= v6) {
    double v7 = v6;
  }
  else {
    double v7 = v5;
  }
  if (v5 >= v6) {
    double v5 = v6;
  }
  if (a1) {
    double v5 = v7;
  }
  return a2 * v5;
}

double TSDFitOrFillSizeInRect(int a1, double a2, double a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7)
{
  double v11 = a6 / a2;
  if (a6 / a2 <= a7 / a3) {
    double v12 = a7 / a3;
  }
  else {
    double v12 = a6 / a2;
  }
  if (a6 / a2 >= a7 / a3) {
    double v11 = a7 / a3;
  }
  if (a1) {
    double v13 = v12;
  }
  else {
    double v13 = v11;
  }
  return TSDCenterRectOverRect(0.0, 0.0, a2 * v13, a3 * v13, a4, a5, a6, a7);
}

void TSDScaleRectAroundPoint(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, double a5, double a6, CGFloat a7)
{
  memset(&v18, 0, sizeof(v18));
  CGAffineTransformMakeTranslation(&v18, -a5, -a6);
  memset(&v17, 0, sizeof(v17));
  CGAffineTransformMakeScale(&v17, a7, a7);
  memset(&v16, 0, sizeof(v16));
  CGAffineTransform t1 = v18;
  CGAffineTransform t2 = v17;
  CGAffineTransformConcat(&v15, &t1, &t2);
  CGAffineTransform t1 = v18;
  CGAffineTransformInvert(&v12, &t1);
  CGAffineTransformConcat(&v16, &v15, &v12);
  CGAffineTransform t1 = v16;
  v19.origin.CGFloat x = a1;
  v19.origin.CGFloat y = a2;
  v19.size.CGFloat width = a3;
  v19.size.CGFloat height = a4;
  CGRectApplyAffineTransform(v19, &t1);
}

void TSDVisibleUnscaledRectForNewScale(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, double a5, double a6, CGFloat a7, double a8)
{
  memset(&v19, 0, sizeof(v19));
  CGAffineTransformMakeScale(&v19, a7, a7);
  memset(&v18, 0, sizeof(v18));
  CGAffineTransform v17 = v19;
  CGAffineTransformInvert(&v18, &v17);
  CGAffineTransform v17 = v18;
  v20.origin.CGFloat x = a1;
  v20.origin.CGFloat y = a2;
  v20.size.CGFloat width = a3;
  v20.size.CGFloat height = a4;
  CGRect v21 = CGRectApplyAffineTransform(v20, &v17);
  float64x2_t v14 = vaddq_f64(*(float64x2_t *)&v18.tx, vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)&v18.c, a6), *(float64x2_t *)&v18.a, a5));
  TSDScaleRectAroundPoint(v21.origin.x, v21.origin.y, v21.size.width, v21.size.height, v14.f64[0], v14.f64[1], a7 / a8);
}

double TSDRectWithInverseNormalizedRect(double a1, double a2, double a3)
{
  return -a1 / a3;
}

double TSDRectByExpandingBoundingRectToContentRect(double a1, double a2, double a3, double a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8, double a9, double a10, double a11, double a12)
{
  double v25 = a1 + a5 * a3;
  v36.origin.CGFloat x = a5;
  v36.origin.CGFloat y = a6;
  v36.size.CGFloat width = a7;
  v36.size.CGFloat height = a8;
  double MaxX = CGRectGetMaxX(v36);
  v37.origin.CGFloat x = a5;
  v37.origin.CGFloat y = a6;
  v37.size.CGFloat width = a7;
  v37.size.CGFloat height = a8;
  CGRectGetMaxY(v37);
  double v26 = a1 + MaxX * a3;
  if (v25 >= v26) {
    double v27 = a1 + MaxX * a3;
  }
  else {
    double v27 = v25;
  }
  if (v25 > v26) {
    double v26 = v25;
  }
  double v35 = v27;
  double v28 = v26 - v27;
  double v29 = -a9 / a11 * (v26 - v27);
  v38.origin.CGFloat x = -a9 / a11;
  v38.origin.CGFloat y = -a10 / a12;
  v38.size.CGFloat width = 1.0 / a11;
  v38.size.CGFloat height = 1.0 / a12;
  double v30 = CGRectGetMaxX(v38);
  v39.origin.CGFloat x = -a9 / a11;
  v39.origin.CGFloat y = -a10 / a12;
  v39.size.CGFloat width = 1.0 / a11;
  v39.size.CGFloat height = 1.0 / a12;
  CGRectGetMaxY(v39);
  if (v29 >= v30 * v28) {
    double v31 = v30 * v28;
  }
  else {
    double v31 = v29;
  }
  return v35 + v31;
}

double TSDAliasRound(double a1)
{
  double v1 = fabs(a1);
  double v2 = v1 - floor(v1);
  if ((a1 >= 0.0 || v2 > 0.49) && (a1 < 0.0 || v2 < 0.49)) {
    return floor(a1);
  }
  else {
    return ceil(a1);
  }
}

double TSDAliasRoundedPoint(double a1)
{
  double v1 = fabs(a1);
  double v2 = v1 - floor(v1);
  if ((a1 >= 0.0 || v2 > 0.49) && (a1 < 0.0 || v2 < 0.49)) {
    return floor(a1);
  }
  else {
    return ceil(a1);
  }
}

double TSDRoundForScale(double a1, double a2)
{
  TSURound();
  return v3 / a2;
}

double TSDRoundedPoint()
{
  TSURound();
  double v1 = v0;
  TSURound();
  return v1;
}

double TSDRoundedPointForView(double a1, double a2)
{
  TSUScreenScale();

  return TSDRoundedPointForScale(a1, a2, v4);
}

double TSDRoundedPointForScale(double a1, double a2, double a3)
{
  if (a3 == 0.0)
  {
    double v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "CGPoint TSDRoundedPointForScale(CGPoint, CGFloat)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGeometry.m"), 1150, @"cannot give scale = 0 for TSDRoundedPointForScale!");
  }
  else
  {
    TSURound();
    double v8 = v7;
    TSURound();
    return 1.0 / a3 * v8;
  }
  return a1;
}

double TSDRoundedSize()
{
  TSURound();
  double v1 = v0;
  TSURound();
  return v1;
}

double TSDRoundedSizeForScale(double a1, double a2, double a3)
{
  if (a3 == 0.0)
  {
    double v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "CGSize TSDRoundedSizeForScale(CGSize, CGFloat)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGeometry.m"), 1172, @"cannot give scale = 0 for TSDRoundedSizeForScale!");
  }
  else
  {
    TSURound();
    double v8 = v7;
    TSURound();
    return 1.0 / a3 * v8;
  }
  return a1;
}

double TSDCeilSize(double a1)
{
  return ceil(a1);
}

double TSDRoundedRect(double a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  return TSDRoundedRectForScale(a1, a2, a3, a4, 1.0);
}

double TSDRoundedRectForScale(double a1, CGFloat a2, CGFloat a3, CGFloat a4, double a5)
{
  double v8 = a1;
  if (a5 == 0.0)
  {
    double v9 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v10 = objc_msgSend(NSString, "stringWithUTF8String:", "CGRect TSDRoundedRectForScale(CGRect, CGFloat)");
    objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGeometry.m"), 1221, @"cannot give scale = 0 for TSDRoundedRectForScale!");
  }
  else if (!CGRectIsNull(*(CGRect *)&a1))
  {
    v24.origin.CGFloat x = TSDMultiplyRectScalar(v8, a2, a3, a4, a5);
    CGFloat x = v24.origin.x;
    CGFloat y = v24.origin.y;
    CGFloat width = v24.size.width;
    CGFloat height = v24.size.height;
    CGRectGetMinX(v24);
    TSURound();
    double v17 = v16;
    v25.origin.CGFloat x = x;
    v25.origin.CGFloat y = y;
    v25.size.CGFloat width = width;
    v25.size.CGFloat height = height;
    CGRectGetMinY(v25);
    TSURound();
    CGFloat v19 = v18;
    v26.origin.CGFloat x = x;
    v26.origin.CGFloat y = y;
    v26.size.CGFloat width = width;
    v26.size.CGFloat height = height;
    CGRectGetMaxX(v26);
    TSURound();
    CGFloat v21 = v20 - v17;
    v27.origin.CGFloat x = x;
    v27.origin.CGFloat y = y;
    v27.size.CGFloat width = width;
    v27.size.CGFloat height = height;
    CGRectGetMaxY(v27);
    TSURound();
    return TSDMultiplyRectScalar(v17, v19, v21, v22 - v19, 1.0 / a5);
  }
  return v8;
}

double TSDRoundedRectForView(double a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  TSUScreenScale();

  return TSDRoundedRectForScale(a1, a2, a3, a4, v8);
}

double TSDRoundedRectForMainScreen(double a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  TSUScreenScale();

  return TSDRoundedRectForScale(a1, a2, a3, a4, v8);
}

double TSDAliasRoundedRectForScale(double a1, CGFloat a2, CGFloat a3, CGFloat a4, double a5)
{
  double v8 = a1;
  if (a5 == 0.0)
  {
    double v9 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v10 = objc_msgSend(NSString, "stringWithUTF8String:", "CGRect TSDAliasRoundedRectForScale(CGRect, CGFloat)");
    objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGeometry.m"), 1247, @"cannot give scale = 0 for TSDRoundedRectForScale!");
  }
  else if (!CGRectIsNull(*(CGRect *)&a1))
  {
    v34.origin.CGFloat x = TSDMultiplyRectScalar(v8, a2, a3, a4, a5);
    CGFloat x = v34.origin.x;
    CGFloat y = v34.origin.y;
    CGFloat width = v34.size.width;
    CGFloat height = v34.size.height;
    double MinX = CGRectGetMinX(v34);
    double v17 = fabs(MinX);
    double v18 = v17 - floor(v17);
    if ((MinX >= 0.0 || v18 > 0.49) && (MinX < 0.0 || v18 < 0.49)) {
      double v19 = floor(MinX);
    }
    else {
      double v19 = ceil(MinX);
    }
    v35.origin.CGFloat x = x;
    v35.origin.CGFloat y = y;
    v35.size.CGFloat width = width;
    v35.size.CGFloat height = height;
    double MinY = CGRectGetMinY(v35);
    double v21 = fabs(MinY);
    double v22 = v21 - floor(v21);
    if ((MinY >= 0.0 || v22 > 0.49) && (MinY < 0.0 || v22 < 0.49)) {
      double v23 = floor(MinY);
    }
    else {
      double v23 = ceil(MinY);
    }
    v36.origin.CGFloat x = x;
    v36.origin.CGFloat y = y;
    v36.size.CGFloat width = width;
    v36.size.CGFloat height = height;
    double MaxX = CGRectGetMaxX(v36);
    double v25 = fabs(MaxX);
    double v26 = v25 - floor(v25);
    if ((MaxX >= 0.0 || v26 > 0.49) && (MaxX < 0.0 || v26 < 0.49)) {
      double v27 = floor(MaxX);
    }
    else {
      double v27 = ceil(MaxX);
    }
    double v28 = v27 - v19;
    v37.origin.CGFloat x = x;
    v37.origin.CGFloat y = y;
    v37.size.CGFloat width = width;
    v37.size.CGFloat height = height;
    double MaxY = CGRectGetMaxY(v37);
    double v30 = fabs(MaxY);
    double v31 = v30 - floor(v30);
    if ((MaxY >= 0.0 || v31 > 0.49) && (MaxY < 0.0 || v31 < 0.49)) {
      double v32 = floor(MaxY);
    }
    else {
      double v32 = ceil(MaxY);
    }
    return TSDMultiplyRectScalar(v19, v23, v28, v32 - v23, 1.0 / a5);
  }
  return v8;
}

uint64_t TSDRoundedMinX(double a1, double a2, double a3, double a4)
{
  CGRectGetMinX(*(CGRect *)&a1);

  return TSURound();
}

uint64_t TSDRoundedMidX(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  TSURound();
  v10.origin.CGFloat x = a1;
  v10.origin.CGFloat y = a2;
  v10.size.CGFloat width = a3;
  v10.size.CGFloat height = a4;
  CGRectGetMaxX(v10);
  TSURound();

  return TSURound();
}

uint64_t TSDRoundedMaxX(double a1, double a2, double a3, double a4)
{
  CGRectGetMaxX(*(CGRect *)&a1);

  return TSURound();
}

uint64_t TSDRoundedMinY(double a1, double a2, double a3, double a4)
{
  CGRectGetMinY(*(CGRect *)&a1);

  return TSURound();
}

uint64_t TSDRoundedMidY(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  TSURound();
  v10.origin.CGFloat x = a1;
  v10.origin.CGFloat y = a2;
  v10.size.CGFloat width = a3;
  v10.size.CGFloat height = a4;
  CGRectGetMaxY(v10);
  TSURound();

  return TSURound();
}

uint64_t TSDRoundedMaxY(double a1, double a2, double a3, double a4)
{
  CGRectGetMaxY(*(CGRect *)&a1);

  return TSURound();
}

double TSDFloorForScale(double a1, double a2)
{
  TSURound();
  return v3 / a2;
}

double TSDFloorForMainScreen()
{
  TSUScreenScale();
  double v1 = v0;
  TSURound();
  return v2 / v1;
}

uint64_t TSDSizeHasNaNComponents()
{
  return 0;
}

uint64_t TSDRectHasNaNComponents()
{
  return 0;
}

uint64_t TSDPointHasNaNComponents()
{
  return 0;
}

uint64_t TSDTransformHasNaNComponents()
{
  return 0;
}

double TSDCeilForMainScreen(double a1)
{
  TSUScreenScale();
  float v3 = v2 * a1;
  return ceilf(v3) / v2;
}

void p_evaluateGradient(void *a1, double *a2, void *a3)
{
  id v8 = (id)[a1 newColorAtFraction:*a2];
  [v8 redComponent];
  *a3 = v4;
  [v8 greenComponent];
  a3[1] = v5;
  [v8 blueComponent];
  a3[2] = v6;
  [v8 alphaComponent];
  a3[3] = v7;
}

uint64_t gradientStopCompare(void *a1, void *a2)
{
  if (!a1 || !a2)
  {
    uint64_t v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "NSComparisonResult gradientStopCompare(id, id, void *)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGradient.m"), 1723, @"Passing in nil is invalid.");
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
  {
    uint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "NSComparisonResult gradientStopCompare(id, id, void *)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGradient.m"), 1724, @"Non-TSDGradients in array.");
  }
  [a1 fraction];
  double v9 = v8;
  [a2 fraction];
  if (v9 >= v10) {
    return v10 < v9;
  }
  else {
    return -1;
  }
}

void sub_2235C40BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CGPath *TSDCreatePathByComputingArc(int a1, int a2, double a3, double a4, double a5, double a6, long double a7, double a8, double a9)
{
  double v16 = (a3 - a8) * 0.5;
  double v17 = (a4 - a9) * 0.5;
  double angle = fmod(a7, 360.0) * 3.14159265 / 180.0;
  __double2 v18 = __sincos_stret(angle);
  double v19 = v18.__sinval * v17 + v18.__cosval * v16;
  double v20 = v18.__cosval * v17 - v18.__sinval * v16;
  double v21 = fabs(a5);
  double v22 = fabs(a6);
  double v23 = a5 * a5;
  double v24 = a6 * a6;
  double v25 = v19 * v19 / (a5 * a5) + v20 * v20 / (a6 * a6);
  if (v25 > 1.0)
  {
    double v26 = sqrt(v25);
    double v21 = v21 * v26;
    double v22 = v22 * v26;
    double v23 = v21 * v21;
    double v24 = v22 * v22;
  }
  double v27 = (v23 * v24 - v23 * (v20 * v20) - v24 * (v19 * v19)) / (v19 * v19 * v24 + v23 * (v20 * v20));
  if (v27 < 0.0) {
    double v27 = 0.0;
  }
  double v28 = sqrt(v27);
  if (a1 == a2) {
    double v28 = -v28;
  }
  double v29 = v20 * v21 / v22 * v28;
  double v30 = -(v22 * v19) / v21 * v28;
  double v42 = (a4 + a9) * 0.5 + v18.__cosval * v30 + v18.__sinval * v29;
  double v44 = (a3 + a8) * 0.5 + v30 * -v18.__sinval + v18.__cosval * v29;
  double v31 = (v20 - v30) / v22;
  double v32 = (-v19 - v29) / v21;
  double v33 = (-v20 - v30) / v22;
  double v34 = acos((v19 - v29) / v21 / sqrt(v31 * v31 + (v19 - v29) / v21 * ((v19 - v29) / v21)));
  if (v31 < 0.0) {
    double v34 = -v34;
  }
  double v35 = v34 * 180.0 / 3.14159265;
  double v36 = acos(v32 / sqrt(v33 * v33 + v32 * v32));
  if (v33 < 0.0) {
    double v36 = -v36;
  }
  double v37 = fmod(v36 * 180.0 / 3.14159265, 360.0);
  double v38 = fmod(v35, 360.0);
  Mutable = CGPathCreateMutable();
  long long v40 = *(_OWORD *)(MEMORY[0x263F000D0] + 16);
  *(_OWORD *)&m.a = *MEMORY[0x263F000D0];
  *(_OWORD *)&m.c = v40;
  *(_OWORD *)&m.tCGFloat x = *(_OWORD *)(MEMORY[0x263F000D0] + 32);
  *(_OWORD *)&v47.a = *(_OWORD *)&m.a;
  *(_OWORD *)&v47.c = v40;
  *(_OWORD *)&v47.tCGFloat x = *(_OWORD *)&m.tx;
  CGAffineTransformTranslate(&m, &v47, v44, v42);
  CGAffineTransform v46 = m;
  CGAffineTransformRotate(&v47, &v46, angle);
  CGAffineTransform m = v47;
  CGAffineTransform v46 = v47;
  CGAffineTransformScale(&v47, &v46, 1.0, v22 / v21);
  CGAffineTransform m = v47;
  CGAffineTransform v46 = v47;
  CGAffineTransformTranslate(&v47, &v46, -v44, -v42);
  CGAffineTransform m = v47;
  CGPathAddArc(Mutable, &m, v44, v42, v21, v38 * 3.14159265 / 180.0, v37 * 3.14159265 / 180.0, a2 != 1);
  return Mutable;
}

CGPath *TSDCreatePathByAppendingPathFromElementToElement(const CGPath *a1, const CGPath *a2, uint64_t a3, uint64_t a4)
{
  x[6] = *(CGFloat *)MEMORY[0x263EF8340];
  MutableCopCGFloat y = CGPathCreateMutableCopy(a1);
  if (a3 < a4)
  {
    do
    {
      switch(TSDPathGetElementTypeAtIndexAndAssociatedPoints(a2, a3, x))
      {
        case 0u:
          CGPathMoveToPoint(MutableCopy, 0, x[0], x[1]);
          break;
        case 1u:
          CGPathAddLineToPoint(MutableCopy, 0, x[0], x[0]);
          break;
        case 3u:
          CGPathAddCurveToPoint(MutableCopy, 0, x[0], x[1], x[2], x[3], x[4], x[5]);
          break;
        case 4u:
          CGPathCloseSubpath(MutableCopy);
          break;
        default:
          break;
      }
      ++a3;
    }
    while (a4 != a3);
  }
  return MutableCopy;
}

CGPath *TSDCreateTransformedPath(const CGPath *a1, const CGAffineTransform *a2)
{
  Mutable = CGPathCreateMutable();
  CGPathAddPath(Mutable, a2, a1);
  return Mutable;
}

void TSDCreateAADefeatedRectPoints(double a1, double a2, double a3, double a4, double a5, double a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  float v11 = a5 * a6;
  float v12 = fmodf(v11, 2.0);
  if (a9 >= 1)
  {
    double v13 = (float)(v12 * 0.5);
    float64x2_t v14 = (double *)(a8 + 8);
    do
    {
      *(v14 - 1) = TSDRoundedPoint() + v13;
      *float64x2_t v14 = v15 + v13;
      v14 += 2;
      --a9;
    }
    while (a9);
  }
}

void TSDCreateAADefeatedRect(uint64_t a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, double a6, double a7)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  v17[0] = CGRectGetMinX(*(CGRect *)&a2);
  v20.origin.CGFloat x = a2;
  v20.origin.CGFloat y = a3;
  v20.size.CGFloat width = a4;
  v20.size.CGFloat height = a5;
  v17[1] = CGRectGetMinY(v20);
  v21.origin.CGFloat x = a2;
  v21.origin.CGFloat y = a3;
  v21.size.CGFloat width = a4;
  v21.size.CGFloat height = a5;
  v17[2] = CGRectGetMaxX(v21);
  v22.origin.CGFloat x = a2;
  v22.origin.CGFloat y = a3;
  v22.size.CGFloat width = a4;
  v22.size.CGFloat height = a5;
  double MaxY = CGRectGetMaxY(v22);
  TSDCreateAADefeatedRectPoints(MaxY, v14, v15, v16, a6, a7, a1, (uint64_t)v17, 2);
}

CGPath *TSDCreateAADefeatedRectPath(uint64_t a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, double a6, double a7)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  v22[0] = CGRectGetMinX(*(CGRect *)&a2);
  v25.origin.CGFloat x = a2;
  v25.origin.CGFloat y = a3;
  v25.size.CGFloat width = a4;
  v25.size.CGFloat height = a5;
  v22[1] = CGRectGetMinY(v25);
  v26.origin.CGFloat x = a2;
  v26.origin.CGFloat y = a3;
  v26.size.CGFloat width = a4;
  v26.size.CGFloat height = a5;
  v22[2] = CGRectGetMaxX(v26);
  v27.origin.CGFloat x = a2;
  v27.origin.CGFloat y = a3;
  v27.size.CGFloat width = a4;
  v27.size.CGFloat height = a5;
  v22[3] = CGRectGetMinY(v27);
  v28.origin.CGFloat x = a2;
  v28.origin.CGFloat y = a3;
  v28.size.CGFloat width = a4;
  v28.size.CGFloat height = a5;
  v22[4] = CGRectGetMaxX(v28);
  v29.origin.CGFloat x = a2;
  v29.origin.CGFloat y = a3;
  v29.size.CGFloat width = a4;
  v29.size.CGFloat height = a5;
  v22[5] = CGRectGetMaxY(v29);
  v30.origin.CGFloat x = a2;
  v30.origin.CGFloat y = a3;
  v30.size.CGFloat width = a4;
  v30.size.CGFloat height = a5;
  v22[6] = CGRectGetMinX(v30);
  v31.origin.CGFloat x = a2;
  v31.origin.CGFloat y = a3;
  v31.size.CGFloat width = a4;
  v31.size.CGFloat height = a5;
  double MaxY = CGRectGetMaxY(v31);
  TSDCreateAADefeatedRectPoints(MaxY, v14, v15, v16, a6, a7, a1, (uint64_t)v22, 4);
  Mutable = CGPathCreateMutable();
  for (uint64_t i = 0; i != 8; i += 2)
  {
    CGFloat v19 = *(double *)&v22[i];
    CGFloat v20 = *(double *)&v22[i + 1];
    if (i * 8) {
      CGPathAddLineToPoint(Mutable, 0, v19, v20);
    }
    else {
      CGPathMoveToPoint(Mutable, 0, v19, v20);
    }
  }
  CGPathCloseSubpath(Mutable);
  return Mutable;
}

void TSDPathBoundsIncludingStroke(CGPathRef path, void *a2)
{
  if (a2 && [a2 shouldRender])
  {
    if ([a2 isFrame])
    {
      BoundingBoCGFloat x = CGPathGetBoundingBox(path);
      objc_msgSend(a2, "coverageRect:", BoundingBox.origin.x, BoundingBox.origin.y, BoundingBox.size.width, BoundingBox.size.height);
    }
    else
    {
      [a2 width];
      double v5 = v4;
      [a2 miterLimit];
      TSDPathBoundsIncludingStrokeWithParameters(path, [a2 cap], objc_msgSend(a2, "join"), v5, v6);
    }
  }
  else
  {
    CGPathGetBoundingBox(path);
  }
}

double TSDPathBoundsIncludingStrokeWithParameters(const CGPath *a1, int a2, int a3, double a4, double a5)
{
  BoundingBodouble x = CGPathGetBoundingBox(a1);
  double x = BoundingBox.origin.x;
  CGFloat y = BoundingBox.origin.y;
  CGFloat width = BoundingBox.size.width;
  CGFloat height = BoundingBox.size.height;
  if (!CGPathIsEmpty(a1))
  {
    v22.origin.double x = x;
    v22.origin.CGFloat y = y;
    v22.size.CGFloat width = width;
    v22.size.CGFloat height = height;
    CGRect v23 = CGRectInset(v22, -(a4 * 0.5), -(a4 * 0.5));
    double x = v23.origin.x;
    CGFloat v14 = v23.origin.y;
    CGFloat v15 = v23.size.width;
    CGFloat v16 = v23.size.height;
    if (!a3)
    {
      memset(&v20[40], 0, 200);
      *(_OWORD *)&v20[24] = *MEMORY[0x263F00148];
      *(_OWORD *)&v20[8] = *(_OWORD *)&v20[24];
      double v19 = a4 * 0.5;
      *(double *)CGFloat v20 = a5;
      CGRect info = v23;
      CGPathApply(a1, &info, (CGPathApplierFunction)TSDPathCornerBoundsApplier);
      CGFloat v14 = info.origin.y;
      double x = info.origin.x;
      CGFloat v16 = info.size.height;
      CGFloat v15 = info.size.width;
    }
    if (a2 == 2)
    {
      memset(&v20[32], 0, 112);
      *(_OWORD *)CGFloat v20 = *MEMORY[0x263F00148];
      *(_OWORD *)&v20[16] = *(_OWORD *)v20;
      info.size.CGFloat height = v16;
      double v19 = a4 * 0.5;
      info.origin.double x = x;
      info.origin.CGFloat y = v14;
      info.size.CGFloat width = v15;
      CGPathApply(a1, &info, (CGPathApplierFunction)TSDPathEndBoundsApplier);
      TSDPathEndBoundsApplierFinishSubpath((uint64_t)&info);
      return info.origin.x;
    }
  }
  return x;
}

double TSDPathBoundsIncludingStrokeWithWidth(const CGPath *a1, double a2)
{
  return TSDPathBoundsIncludingStrokeWithParameters(a1, 0, 0, a2, 10.0);
}

void TSDPathCornerBoundsApplier(uint64_t a1, unsigned int *a2)
{
  uint64_t v3 = *a2;
  if ((v3 - 1) >= 3)
  {
    if (v3 == 4)
    {
      if (*(_DWORD *)(a1 + 80))
      {
        if (*(double *)(a1 + 64) != *(double *)(a1 + 48) || *(double *)(a1 + 72) != *(double *)(a1 + 56))
        {
          uint64_t v13 = a1 + 48;
          uint64_t v12 = 1;
          TSDPathCornerBoundsApplierProcessSegment(a1, (int *)&v12);
        }
        unsigned int v11 = *(_DWORD *)(a1 + 224);
        uint64_t v13 = a1 + 232;
        uint64_t v12 = v11;
        TSDPathCornerBoundsApplierProcessSegment(a1, (int *)&v12);
      }
      *(_DWORD *)(a1 + 80) = 0;
      long long v9 = *(_OWORD *)(a1 + 48);
    }
    else
    {
      if (v3) {
        return;
      }
      *(_DWORD *)(a1 + 80) = 0;
      double v8 = (_OWORD *)*((void *)a2 + 1);
      *(_OWORD *)(a1 + 48) = *v8;
      long long v9 = *v8;
    }
    *(_OWORD *)(a1 + 64) = v9;
  }
  else
  {
    if (!*(_DWORD *)(a1 + 80))
    {
      uint64_t v4 = 0;
      *(_DWORD *)(a1 + 224) = v3;
      int v5 = kPointCountsByElementType[v3];
      if (v5 <= 1) {
        unsigned int v6 = 1;
      }
      else {
        unsigned int v6 = v5;
      }
      uint64_t v7 = 16 * v6;
      do
      {
        *(_OWORD *)(a1 + 232 + v4) = *(_OWORD *)(*((void *)a2 + 1) + v4);
        v4 += 16;
      }
      while (v7 != v4);
    }
    TSDPathCornerBoundsApplierProcessSegment(a1, (int *)a2);
  }
}

__n128 TSDPathEndBoundsApplier(uint64_t a1, int *a2)
{
  int v4 = *a2;
  if ((*a2 - 1) >= 3)
  {
    if (v4 == 4)
    {
      *(unsigned char *)(a1 + 72) = 0;
      __n128 result = *(__n128 *)(a1 + 40);
      *(__n128 *)(a1 + 56) = result;
    }
    else if (!v4)
    {
      TSDPathEndBoundsApplierFinishSubpath(a1);
      *(unsigned char *)(a1 + 72) = 0;
      unsigned int v6 = (_OWORD *)*((void *)a2 + 1);
      *(_OWORD *)(a1 + 56) = *v6;
      __n128 result = *(__n128 *)v6;
      *(_OWORD *)(a1 + 40) = *v6;
    }
  }
  else
  {
    if (!*(unsigned char *)(a1 + 72))
    {
      *(unsigned char *)(a1 + 72) = 1;
      *(_DWORD *)(a1 + 76) = v4;
      *(_OWORD *)(a1 + 80) = *(_OWORD *)(a1 + 56);
      uint64_t v5 = *a2;
      if (v5 == 4)
      {
        int v4 = 4;
      }
      else
      {
        uint64_t v8 = 0;
        int v9 = kPointCountsByElementType[v5];
        if (v9 <= 1) {
          int v9 = 1;
        }
        uint64_t v10 = 16 * v9;
        do
        {
          *(_OWORD *)(a1 + 96 + v8) = *(_OWORD *)(*((void *)a2 + 1) + v8);
          v8 += 16;
        }
        while (v10 != v8);
        int v4 = *a2;
      }
    }
    *(_DWORD *)(a1 + 128) = v4;
    *(_OWORD *)(a1 + 136) = *(_OWORD *)(a1 + 56);
    uint64_t v11 = *a2;
    int v12 = kPointCountsByElementType[v11];
    if (v11 != 4)
    {
      uint64_t v13 = 0;
      if (v12 <= 1) {
        int v12 = 1;
      }
      uint64_t v14 = 16 * v12;
      do
      {
        *(_OWORD *)(a1 + 152 + v13) = *(_OWORD *)(*((void *)a2 + 1) + v13);
        v13 += 16;
      }
      while (v14 != v13);
      int v12 = kPointCountsByElementType[*a2];
    }
    __n128 result = *(__n128 *)(*((void *)a2 + 1) + 16 * (v12 - 1));
    *(__n128 *)(a1 + 56) = result;
  }
  return result;
}

void TSDPathEndBoundsApplierFinishSubpath(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 72))
  {
    double v2 = *(double *)(a1 + 80);
    double v3 = *(double *)(a1 + 88);
    double v4 = gradientAtTFromTypeAndPoints(*(_DWORD *)(a1 + 76), (float64x2_t *)(a1 + 80));
    double v6 = TSDMultiplyPointScalar(v4, v5, *(double *)(a1 + 32));
    double v8 = v7;
    double v9 = TSDSubtractPoints(v2, v3, v6);
    double v11 = v10;
    double v12 = TSDRotatePoint90Degrees(1, v6, v8);
    double v13 = TSDAddPoints(v9, v11, v12);
    double v15 = TSDGrowRectToPoint(*(CGFloat *)a1, *(CGFloat *)(a1 + 8), *(CGFloat *)(a1 + 16), *(CGFloat *)(a1 + 24), v13, v14);
    CGFloat v17 = v16;
    CGFloat v19 = v18;
    CGFloat v21 = v20;
    double v22 = TSDSubtractPoints(v9, v11, v12);
    *(double *)a1 = TSDGrowRectToPoint(v15, v17, v19, v21, v22, v23);
    *(void *)(a1 + 8) = v24;
    *(void *)(a1 + 16) = v25;
    *(void *)(a1 + 24) = v26;
    uint64_t v27 = *(int *)(a1 + 128);
    CGRect v28 = (double *)(a1 + 136 + 16 * kPointCountsByElementType[v27]);
    double v29 = *v28;
    double v30 = v28[1];
    double v31 = gradientAtTFromTypeAndPoints(v27, (float64x2_t *)(a1 + 136));
    double v33 = TSDMultiplyPointScalar(v31, v32, *(double *)(a1 + 32));
    double v35 = v34;
    double v36 = TSDAddPoints(v29, v30, v33);
    double v38 = v37;
    double v39 = TSDRotatePoint90Degrees(1, v33, v35);
    double v40 = TSDAddPoints(v36, v38, v39);
    double v42 = TSDGrowRectToPoint(*(CGFloat *)a1, *(CGFloat *)(a1 + 8), *(CGFloat *)(a1 + 16), *(CGFloat *)(a1 + 24), v40, v41);
    CGFloat v44 = v43;
    CGFloat v46 = v45;
    CGFloat v48 = v47;
    double v49 = TSDSubtractPoints(v36, v38, v39);
    *(double *)a1 = TSDGrowRectToPoint(v42, v44, v46, v48, v49, v50);
    *(void *)(a1 + 8) = v51;
    *(void *)(a1 + 16) = v52;
    *(void *)(a1 + 24) = v53;
  }
}

CGPath *TSDCreateWobblyPathWithMaxWobbleAndSubdivisions(const CGPath *a1, unint64_t a2, double a3)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  Mutable = CGPathCreateMutable();
  uint64_t ElementCount = TSDPathGetElementCount(a1);
  if (ElementCount)
  {
    uint64_t v8 = ElementCount;
    uint64_t v9 = 0;
    double v36 = *(double *)(MEMORY[0x263F00148] + 8);
    CGFloat v37 = *MEMORY[0x263F00148];
    do
    {
      switch(TSDPathGetElementTypeAtIndexAndAssociatedPoints(a1, v9, &v38))
      {
        case 0u:
          long long v10 = v38;
          TSURandom();
          CGFloat v12 = *(double *)&v10 + (v11 + -0.5) * a3;
          TSURandom();
          double v36 = *((double *)&v10 + 1) + (v13 + -0.5) * a3;
          CGFloat v37 = v12;
          CGPathMoveToPoint(Mutable, 0, v12, v36);
          break;
        case 1u:
          int v14 = 0;
          double v16 = *((double *)&v38 + 1);
          double v15 = *(double *)&v38;
          goto LABEL_8;
        case 3u:
          double v17 = v41;
          double v18 = v42;
          TSURandom();
          CGFloat v20 = v17 + (v19 + -0.5) * a3;
          TSURandom();
          CGPathAddCurveToPoint(Mutable, 0, *(CGFloat *)&v38, *((CGFloat *)&v38 + 1), v39, v40, v20, v18 + (v21 + -0.5) * a3);
          break;
        case 4u:
          double v16 = v36;
          double v15 = v37;
          *(CGFloat *)&long long v38 = v37;
          *((double *)&v38 + 1) = v36;
          int v14 = 1;
LABEL_8:
          unint64_t v22 = 0;
          unint64_t v23 = a2;
          do
          {
            CGPoint CurrentPoint = CGPathGetCurrentPoint(Mutable);
            double v25 = TSDSubtractPoints(v15, v16, CurrentPoint.x);
            double v27 = v26;
            if (v23)
            {
              TSURandom();
              *(float *)&double v28 = 1.0 / (double)v23 * (v28 + 0.5);
              double v29 = fminf(*(float *)&v28, 1.0);
            }
            else
            {
              double v29 = 1.0;
            }
            CGFloat v30 = CurrentPoint.x + v25 * v29;
            CGFloat v31 = CurrentPoint.y + v27 * v29;
            TSURandom();
            CGFloat v33 = v30 + (v32 + -0.5) * a3;
            TSURandom();
            CGPathAddLineToPoint(Mutable, 0, v33, v31 + (v34 + -0.5) * a3);
            ++v22;
            --v23;
          }
          while (v22 <= a2);
          if (v14) {
            CGPathCloseSubpath(Mutable);
          }
          break;
        default:
          break;
      }
      ++v9;
    }
    while (v9 != v8);
  }
  return Mutable;
}

CGPath *TSDCreateRoundRectPathForRectWithRadius(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5)
{
  Mutable = CGPathCreateMutable();
  double v11 = Mutable;
  CGFloat v12 = a1;
  CGFloat v13 = a2;
  CGFloat v14 = a3;
  CGFloat v15 = a4;
  if (a5 == 0.0)
  {
    CGPathAddRect(Mutable, 0, *(CGRect *)&v12);
  }
  else
  {
    double x1 = CGRectGetMinX(*(CGRect *)&v12);
    v23.origin.double x = a1;
    v23.origin.CGFloat y = a2;
    v23.size.CGFloat width = a3;
    v23.size.CGFloat height = a4;
    double MaxY = CGRectGetMaxY(v23);
    v24.origin.double x = a1;
    v24.origin.CGFloat y = a2;
    v24.size.CGFloat width = a3;
    v24.size.CGFloat height = a4;
    double MaxX = CGRectGetMaxX(v24);
    v25.origin.double x = a1;
    v25.origin.CGFloat y = a2;
    v25.size.CGFloat width = a3;
    v25.size.CGFloat height = a4;
    CGFloat v21 = CGRectGetMaxY(v25);
    v26.origin.double x = a1;
    v26.origin.CGFloat y = a2;
    v26.size.CGFloat width = a3;
    v26.size.CGFloat height = a4;
    CGFloat v17 = CGRectGetMaxX(v26);
    v27.origin.double x = a1;
    v27.origin.CGFloat y = a2;
    v27.size.CGFloat width = a3;
    v27.size.CGFloat height = a4;
    double MinY = CGRectGetMinY(v27);
    CGPathMoveToPoint(v11, 0, x1 + 0.0, MaxY - a5);
    CGPathAddArcToPoint(v11, 0, a1, a2, a1 + a5, a2 + 0.0, a5);
    CGPathAddArcToPoint(v11, 0, v17, MinY, v17, MinY + a5, a5);
    CGPathAddArcToPoint(v11, 0, MaxX, v21, MaxX - a5, v21, a5);
    CGPathAddArcToPoint(v11, 0, x1, MaxY, x1 + 0.0, MaxY - a5, a5);
    CGPathCloseSubpath(v11);
  }
  return v11;
}

CGPath *TSDCreateRoundRectPathForRectWithRadii(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  Mutable = CGPathCreateMutable();
  v24.origin.double x = a1;
  v24.origin.CGFloat y = a2;
  v24.size.CGFloat width = a3;
  v24.size.CGFloat height = a4;
  CGFloat MinX = CGRectGetMinX(v24);
  v25.origin.double x = a1;
  v25.origin.CGFloat y = a2;
  v25.size.CGFloat width = a3;
  v25.size.CGFloat height = a4;
  double y1 = CGRectGetMaxY(v25);
  v26.origin.double x = a1;
  v26.origin.CGFloat y = a2;
  v26.size.CGFloat width = a3;
  v26.size.CGFloat height = a4;
  double x1 = CGRectGetMaxX(v26);
  v27.origin.double x = a1;
  v27.origin.CGFloat y = a2;
  v27.size.CGFloat width = a3;
  v27.size.CGFloat height = a4;
  CGFloat MaxY = CGRectGetMaxY(v27);
  v28.origin.double x = a1;
  v28.origin.CGFloat y = a2;
  v28.size.CGFloat width = a3;
  v28.size.CGFloat height = a4;
  CGFloat MaxX = CGRectGetMaxX(v28);
  v29.origin.double x = a1;
  v29.origin.CGFloat y = a2;
  v29.size.CGFloat width = a3;
  v29.size.CGFloat height = a4;
  double MinY = CGRectGetMinY(v29);
  CGPathMoveToPoint(Mutable, 0, MinX, y1 - a5);
  CGPathAddArcToPoint(Mutable, 0, a1, a2, a1 + a6, a2, a6);
  CGPathAddArcToPoint(Mutable, 0, MaxX, MinY, MaxX, MinY + a7, a7);
  CGPathAddArcToPoint(Mutable, 0, x1, MaxY, x1 - a8, MaxY, a8);
  CGPathAddArcToPoint(Mutable, 0, MinX, y1, MinX, y1 - a5, a5);
  CGPathCloseSubpath(Mutable);
  return Mutable;
}

const CGPath *TSDPathIsOpen(const CGPath *result)
{
  uint64_t info = 0;
  long long v2 = *MEMORY[0x263F00148];
  if (result)
  {
    CGPathApply(result, &info, (CGPathApplierFunction)TSDPathIsOpenApplier);
    return (const CGPath *)((_BYTE)info != 0);
  }
  return result;
}

uint64_t TSDPathIsOpenApplier(uint64_t result, unsigned int *a2)
{
  long long v2 = (unsigned char *)result;
  uint64_t v3 = *a2;
  if ((v3 - 1) >= 3)
  {
    if (v3 == 4)
    {
      *(unsigned char *)__n128 result = 0;
    }
    else if (!v3)
    {
      *(_OWORD *)(result + 8) = *(_OWORD *)*((void *)a2 + 1);
    }
  }
  else
  {
    uint64_t v4 = *((void *)a2 + 1) + 16 * kPointCountsByElementType[v3];
    __n128 result = TSDNearlyEqualPoints(*(double *)(v4 - 16), *(double *)(v4 - 8), *(double *)(result + 8), *(double *)(result + 16));
    *long long v2 = result ^ 1;
  }
  return result;
}

const CGPath *TSDPathIsLineSegment(const CGPath *result)
{
  int v1 = 0;
  if (result)
  {
    info[0] = &v1;
    info[1] = TSDPathIsLineSegmentApplier;
    long long v3 = *MEMORY[0x263F00148];
    long long v4 = v3;
    uint64_t v5 = 0;
    CGPathApply(result, info, (CGPathApplierFunction)TSDPathApplyToSegmentsApplier);
    return (const CGPath *)(v1 == 1);
  }
  return result;
}

void TSDPathApplyToSegments(const CGPath *a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    if (a3)
    {
      info[0] = a2;
      info[1] = a3;
      long long v4 = *MEMORY[0x263F00148];
      long long v5 = v4;
      uint64_t v6 = 0;
      CGPathApply(a1, info, (CGPathApplierFunction)TSDPathApplyToSegmentsApplier);
    }
  }
}

int *TSDPathIsLineSegmentApplier(int *result, _DWORD *a2)
{
  if (*result == 1)
  {
    int v2 = 2;
  }
  else
  {
    if (*result) {
      return result;
    }
    if (*a2 == 1) {
      int v2 = 1;
    }
    else {
      int v2 = 2;
    }
  }
  *__n128 result = v2;
  return result;
}

double TSDPathGetStartAndEndPoints(const CGPath *a1, _OWORD *a2, _OWORD *a3)
{
  uint64_t info = 0;
  long long v7 = *MEMORY[0x263F00148];
  long long v8 = v7;
  CGPathApply(a1, &info, (CGPathApplierFunction)TSDPathGetStartAndEndPointsApplier);
  if (a2)
  {
    double result = *(double *)&v7;
    *a2 = v7;
  }
  if (a3)
  {
    double result = *(double *)&v8;
    *a3 = v8;
  }
  return result;
}

__n128 TSDPathGetStartAndEndPointsApplier(uint64_t a1, int *a2)
{
  if (*(unsigned char *)a1) {
    goto LABEL_2;
  }
  int v2 = *a2;
  if (!*a2)
  {
    __n128 result = *(__n128 *)*((void *)a2 + 1);
    *(__n128 *)(a1 + 8) = result;
    *(unsigned char *)a1 = 1;
LABEL_2:
    int v2 = *a2;
  }
  if (v2 != 4)
  {
    __n128 result = *(__n128 *)(*((void *)a2 + 1) + 16 * kPointCountsByElementType[v2] - 16);
    *(__n128 *)(a1 + 24) = result;
  }
  return result;
}

void TSDPathApplyToSegmentsApplier(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(_DWORD *)a2;
  if ((*(_DWORD *)a2 - 1) >= 3)
  {
    if (v3 == 4)
    {
      if (*(void *)(a1 + 48))
      {
        if (*(double *)(a1 + 32) != *(double *)(a1 + 16) || *(double *)(a1 + 40) != *(double *)(a1 + 24))
        {
          v7[1] = a1 + 16;
          v7[0] = 1;
          processSegmentElement(a1, (unsigned int *)v7);
        }
      }
      *(void *)(a1 + 48) = 0;
      long long v5 = *(_OWORD *)(a1 + 16);
    }
    else
    {
      if (v3) {
        return;
      }
      *(void *)(a1 + 48) = 0;
      long long v4 = *(_OWORD **)(a2 + 8);
      *(_OWORD *)(a1 + 16) = *v4;
      long long v5 = *v4;
    }
    *(_OWORD *)(a1 + 32) = v5;
  }
  else
  {
    processSegmentElement(a1, (unsigned int *)a2);
  }
}

const CGPath *TSDPathGetSegmentCount(const CGPath *result)
{
  uint64_t v1 = 0;
  if (result)
  {
    info[0] = &v1;
    info[1] = TSDPathGetSegmentCountApplier;
    long long v3 = *MEMORY[0x263F00148];
    long long v4 = v3;
    uint64_t v5 = 0;
    CGPathApply(result, info, (CGPathApplierFunction)TSDPathApplyToSegmentsApplier);
    return (const CGPath *)v1;
  }
  return result;
}

void *TSDPathGetSegmentCountApplier(void *result)
{
  return result;
}

const CGPath *TSDPathGetSegmentAtIndex(const CGPath *result, uint64_t a2, uint64_t a3)
{
  v4[0] = 0;
  v4[1] = a3;
  v3[0] = a2;
  v3[1] = 0;
  v3[2] = v4;
  if (result)
  {
    info[0] = v3;
    info[1] = TSDPathGetSegmentAtIndexApplier;
    long long v6 = *MEMORY[0x263F00148];
    long long v7 = v6;
    uint64_t v8 = 0;
    CGPathApply(result, info, (CGPathApplierFunction)TSDPathApplyToSegmentsApplier);
    return (const CGPath *)LODWORD(v4[0]);
  }
  return result;
}

uint64_t TSDPathGetSegmentAtIndexApplier(uint64_t result, int *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  if (*(void *)result == v2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = *a2;
    **(_DWORD **)(result + 16) = v4;
    uint64_t v5 = 16 * (kPointCountsByElementType[v4] & ~(kPointCountsByElementType[v4] >> 31)) + 16;
    do
    {
      *(_OWORD *)(*(void *)(*(void *)(result + 16) + 8) + v3) = *(_OWORD *)(*((void *)a2 + 1) + v3);
      v3 += 16;
    }
    while (v5 != v3);
    uint64_t v2 = *(void *)(result + 8);
  }
  *(void *)(result + 8) = v2 + 1;
  return result;
}

void TSDPathCornerBoundsApplierProcessSegment(uint64_t a1, int *a2)
{
  int v4 = *(_DWORD *)(a1 + 80);
  if (v4)
  {
    uint64_t v5 = *(int *)(a1 + 152);
    int v6 = kPointCountsByElementType[v5];
    *(_DWORD *)(a1 + 84) = v5;
    memmove((void *)(a1 + 88), (const void *)(a1 + 160), 16 * (v6 & ~(v6 >> 31)) + 16);
  }
  *(_DWORD *)(a1 + 152) = *a2;
  *(_OWORD *)(a1 + 160) = *(_OWORD *)(a1 + 64);
  uint64_t v7 = *a2;
  int v8 = kPointCountsByElementType[v7];
  if (v7 != 4)
  {
    uint64_t v9 = 0;
    if (v8 <= 1) {
      int v8 = 1;
    }
    uint64_t v10 = 16 * v8;
    do
    {
      *(_OWORD *)(a1 + 176 + v9) = *(_OWORD *)(*((void *)a2 + 1) + v9);
      v9 += 16;
    }
    while (v10 != v9);
    int v8 = kPointCountsByElementType[*a2];
  }
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(*((void *)a2 + 1) + 16 * (v8 - 1));
  *(_DWORD *)(a1 + 80) = v4 + 1;
  if ((v4 + 1) > 1)
  {
    double v11 = gradientAtTFromTypeAndPoints(*(_DWORD *)(a1 + 84), (float64x2_t *)(a1 + 88));
    double v13 = v12;
    double v14 = gradientAtTFromTypeAndPoints(*(_DWORD *)(a1 + 152), (float64x2_t *)(a1 + 160));
    double v16 = v15;
    double v17 = TSDSubtractPoints(v11, v13, v14);
    double v19 = TSDNormalizePoint(v17, v18);
    double v21 = v20;
    double v22 = -1.0 / TSDCrossPoints(v19, v20, v14, v16);
    if (v22 * v22 < *(double *)(a1 + 40) * *(double *)(a1 + 40))
    {
      double v23 = TSDMultiplyPointScalar(v19, v21, v22 * *(double *)(a1 + 32));
      double v24 = *(double *)(a1 + 160);
      double v25 = *(double *)(a1 + 168);
      double v26 = TSDAddPoints(v24, v25, v23);
      double v28 = TSDGrowRectToPoint(*(CGFloat *)a1, *(CGFloat *)(a1 + 8), *(CGFloat *)(a1 + 16), *(CGFloat *)(a1 + 24), v26, v27);
      CGFloat v30 = v29;
      CGFloat v32 = v31;
      CGFloat v34 = v33;
      double v35 = TSDSubtractPoints(v24, v25, v23);
      *(double *)a1 = TSDGrowRectToPoint(v28, v30, v32, v34, v35, v36);
      *(void *)(a1 + 8) = v37;
      *(void *)(a1 + 16) = v38;
      *(void *)(a1 + 24) = v39;
    }
  }
}

double gradientAtTFromTypeAndPoints(int a1, float64x2_t *a2)
{
  float64x2_t v2 = *(float64x2_t *)MEMORY[0x263F00148];
  switch(a1)
  {
    case 0:
      float64x2_t v17 = *(float64x2_t *)MEMORY[0x263F00148];
      uint64_t v5 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v6 = objc_msgSend(NSString, "stringWithUTF8String:", "CGPoint gradientAtTFromTypeAndPoints(CGFloat, CGPathElementType, CGPoint *)");
      objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/CGPathAdditions.m"), 220, @"path gradient can't handle moveTo element");
      float64x2_t v2 = v17;
      break;
    case 1:
    case 4:
      v2.f64[0] = TSDSubtractPoints(a2[1].f64[0], a2[1].f64[1], a2->f64[0]);
      v2.f64[1] = v4;
      break;
    case 2:
      TSUClamp();
      float64x2_t v8 = vmlaq_n_f64(vmulq_n_f64(vaddq_f64(a2[1], a2[1]), v7 * -2.0 + 1.0), vaddq_f64(*a2, *a2), v7 + -1.0);
      float64x2_t v9 = vaddq_f64(a2[2], a2[2]);
      goto LABEL_6;
    case 3:
      TSUClamp();
      __asm
      {
        FMOV            V4.2D, #-3.0
        FMOV            V5.2D, #3.0
      }
      float64x2_t v8 = vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(vmulq_f64(a2[1], _Q5), v7 * -4.0 + 1.0 + v7 * 3.0 * v7), vmulq_n_f64(vmulq_f64(*a2, _Q4), v7 + -1.0), v7 + -1.0), vmulq_n_f64(vmulq_f64(a2[2], _Q5), v7), v7 * -3.0 + 2.0);
      float64x2_t v9 = vmulq_n_f64(vmulq_f64(a2[3], _Q5), v7);
LABEL_6:
      float64x2_t v2 = vmlaq_n_f64(v8, v9, v7);
      break;
    default:
      break;
  }

  return TSDNormalizePoint(v2.f64[0], v2.f64[1]);
}

__n128 processSegmentElement(uint64_t a1, unsigned int *a2)
{
  v13[7] = *MEMORY[0x263EF8340];
  float64_t v4 = (__n128 *)(a1 + 32);
  long long v12 = *(_OWORD *)(a1 + 32);
  unsigned int v5 = *a2;
  if (*a2 != 4)
  {
    LODWORD(v6) = kPointCountsByElementType[v5];
    double v7 = (long long *)*((void *)a2 + 1);
    if ((int)v6 <= 1) {
      uint64_t v6 = 1;
    }
    else {
      uint64_t v6 = v6;
    }
    float64x2_t v8 = v13;
    do
    {
      long long v9 = *v7++;
      *v8++ = v9;
      --v6;
    }
    while (v6);
  }
  v11[1] = &v12;
  v11[0] = v5;
  (*(void (**)(void, void *))(a1 + 8))(*(void *)a1, v11);
  __n128 result = *(__n128 *)(*((void *)a2 + 1) + 16 * kPointCountsByElementType[*a2] - 16);
  __n128 *v4 = result;
  ++*(void *)(a1 + 48);
  return result;
}

double TSDMetalLayerTimeWithHostTime(unint64_t a1)
{
  if (TSDMetalLayerTimeWithHostTime_onceToken != -1) {
    dispatch_once(&TSDMetalLayerTimeWithHostTime_onceToken, &__block_literal_global_27);
  }
  return *(double *)&__timeScale * (double)a1;
}

double __TSDMetalLayerTimeWithHostTime_block_invoke()
{
  mach_timebase_info info = 0;
  if (!mach_timebase_info(&info))
  {
    LODWORD(result) = info.numer;
    LODWORD(v1) = info.denom;
    double result = (double)*(unint64_t *)&result / (double)v1 * 0.000000001;
    __timeScale = *(void *)&result;
  }
  return result;
}

float64x2_t TSDBezierToBSpline(float64x2_t *a1, uint64_t a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = (double *)&qword_2238398C8;
  do
  {
    float64x2_t result = a1[2];
    *(float64x2_t *)(a2 + v2) = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(a1[1], *(v3 - 4)), *a1, *(v3 - 8)), result, *v3), a1[3], v3[4]);
    v2 += 16;
    ++v3;
  }
  while (v2 != 64);
  return result;
}

float64x2_t TSDBSplineToBezier(float64x2_t *a1, uint64_t a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = (double *)&qword_223839948;
  do
  {
    float64x2_t result = a1[2];
    *(float64x2_t *)(a2 + v2) = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(a1[1], *(v3 - 4)), *a1, *(v3 - 8)), result, *v3), a1[3], v3[4]);
    v2 += 16;
    ++v3;
  }
  while (v2 != 64);
  return result;
}

double TSDPointOnCurve(float64x2_t *a1, double a2)
{
  __asm { FMOV            V5.2D, #3.0 }
  *(void *)&double result = *(_OWORD *)&vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(vmulq_n_f64(vmulq_n_f64(vmulq_f64(a1[1], _Q5), a2), 1.0 - a2), 1.0 - a2), vmulq_n_f64(vmulq_n_f64(*a1, 1.0 - a2), 1.0 - a2), 1.0 - a2), vmulq_n_f64(vmulq_n_f64(vmulq_f64(a1[2], _Q5), a2), a2), 1.0 - a2), vmulq_n_f64(vmulq_n_f64(a1[3], a2), a2), a2);
  return result;
}

double TSDPointOnQuadraticCurve(float64x2_t *a1, double a2)
{
  *(void *)&double result = *(_OWORD *)&vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(vmulq_n_f64(vaddq_f64(a1[1], a1[1]), a2), 1.0 - a2), vmulq_n_f64(*a1, 1.0 - a2), 1.0 - a2), vmulq_n_f64(a1[2], a2), a2);
  return result;
}

void TSDCurveBetween(float64x2_t *a1, uint64_t a2, double a3, double a4)
{
  double v8 = 1.0 - a3;
  *(double *)a2 = F(a1, 1.0 - a3, a3, 1.0 - a3, a3, 1.0 - a3, a3);
  *(void *)(a2 + 8) = v9;
  *(double *)(a2 + 16) = F(a1, v8, a3, v8, a3, 1.0 - a4, a4);
  *(void *)(a2 + 24) = v10;
  *(double *)(a2 + 32) = F(a1, v8, a3, 1.0 - a4, a4, 1.0 - a4, a4);
  *(void *)(a2 + 40) = v11;
  *(double *)(a2 + 48) = F(a1, 1.0 - a4, a4, 1.0 - a4, a4, 1.0 - a4, a4);
  *(void *)(a2 + 56) = v12;
}

void TSDDCurveBetween(float64x2_t *a1, uint64_t a2, double a3, double a4)
{
  double v8 = 1.0 - a3;
  *(double *)a2 = F(a1, 1.0 - a3, a3, 1.0 - a3, a3, 1.0 - a3, a3);
  *(void *)(a2 + 8) = v9;
  *(double *)(a2 + 16) = F(a1, v8, a3, v8, a3, 1.0 - a4, a4);
  *(void *)(a2 + 24) = v10;
  *(double *)(a2 + 32) = F(a1, v8, a3, 1.0 - a4, a4, 1.0 - a4, a4);
  *(void *)(a2 + 40) = v11;
  *(double *)(a2 + 48) = F(a1, 1.0 - a4, a4, 1.0 - a4, a4, 1.0 - a4, a4);
  *(void *)(a2 + 56) = v12;
}

uint64_t TSDIntersectionOfLines(double *a1, double *a2, double *a3, double *a4, double *a5)
{
  double v5 = a1[1];
  double v6 = a1[2] - *a1;
  double v7 = a1[3] - v5;
  double v8 = a2[1];
  double v9 = a2[2] - *a2;
  double v10 = a2[3] - v8;
  double v11 = (v7 * (*a2 - *a1) + (v5 - v8) * v6) / (v10 * v6 - v9 * v7);
  *a4 = v11;
  if (v11 >= 0.0)
  {
    BOOL v13 = v11 == 1.0;
    BOOL v12 = v11 >= 1.0;
  }
  else
  {
    BOOL v12 = 1;
    BOOL v13 = 0;
  }
  if (!v13 && v12) {
    return 0;
  }
  double v14 = (v10 * (*a1 - *a2) + (a2[1] - a1[1]) * v9) / (v7 * v9 - v6 * v10);
  *a3 = v14;
  if (v14 >= 0.0)
  {
    BOOL v16 = v14 == 1.0;
    BOOL v15 = v14 >= 1.0;
  }
  else
  {
    BOOL v15 = 1;
    BOOL v16 = 0;
  }
  if (!v16 && v15) {
    return 0;
  }
  double v17 = a1[1];
  *a5 = *a1 + v14 * v6;
  a5[1] = v17 + *a3 * v7;
  return 1;
}

double TSDDistanceToPointFromLine(double *a1, double a2, double a3)
{
  double v4 = a1[2];
  double v3 = a1[3];
  double v5 = v3 - a1[1];
  double v6 = v4 - *a1;
  float v7 = v6 * v6 + v5 * v5;
  double v8 = (float)(1.0 / sqrtf(v7));
  return a3 * -(v6 * v8) + v5 * v8 * a2 - (v3 * -(v6 * v8) + v5 * v8 * v4);
}

double TSDDDistanceToPointFromLine(double *a1, double a2, double a3)
{
  double v4 = a1[2];
  double v3 = a1[3];
  double v5 = v3 - a1[1];
  double v6 = v4 - *a1;
  float v7 = v6 * v6 + v5 * v5;
  double v8 = (float)(1.0 / sqrtf(v7));
  return a3 * -(v6 * v8) + v5 * v8 * a2 - (v3 * -(v6 * v8) + v5 * v8 * v4);
}

uint64_t TSDNearestPointOnLineToPoint(double *a1, double a2, double a3)
{
  double v4 = *a1;
  double v5 = a1[1];
  double v6 = TSDSubtractPoints(a2, a3, *a1);
  double v8 = v7;
  double v9 = a1[2];
  double v10 = a1[3];
  double v11 = TSDSubtractPoints(v9, v10, v4);
  TSDDotPoints(v6, v8, v11, v12);
  TSDDistanceSquared(v9, v10, v4, v5);

  return TSUClamp();
}

double TSDNearestPointOnCurveToPoint(float64x2_t *a1, double a2, double a3, double a4)
{
  double v24 = a4 * a4;
  double v6 = 1.0;
  double v7 = 0.0;
  while (1)
  {
    double v8 = (v6 - v7) * 0.125;
    double v9 = 0.0;
    if (v7 <= v6)
    {
      double v10 = 3.40282347e38;
      double v11 = v7;
      do
      {
        double v12 = TSDPointOnCurve(a1, v11);
        double v14 = TSDSubtractPoints(v12, v13, a2);
        double v16 = TSDPointSquaredLength(v14, v15);
        if (v16 < v10)
        {
          double v10 = v16;
          double v9 = v11;
        }
        double v11 = v8 + v11;
      }
      while (v11 <= v6);
    }
    double v17 = TSDPointOnCurve(a1, v7);
    double v19 = v18;
    double v20 = TSDPointOnCurve(a1, v6);
    double v21 = TSDSubtractPoints(v17, v19, v20);
    if (TSDPointSquaredLength(v21, v22) < v24) {
      break;
    }
    double v7 = fmax(v9 - v8, 0.0);
    double v6 = fmin(v8 + v9, 1.0);
  }
  return v9;
}

void TSDNearestPointOnCurveToLine(float64x2_t *a1, double *a2, uint64_t a3)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  double v6 = a2[2];
  double v5 = a2[3];
  double v7 = v5 - a2[1];
  double v8 = v6 - *a2;
  float v9 = v8 * v8 + v7 * v7;
  double v10 = (float)(1.0 / sqrtf(v9));
  double v11 = v7 * v10;
  double v12 = -(v8 * v10);
  double v13 = v5 * v12 + v11 * v6;
  float64_t v14 = a1->f64[1] * v12 + v11 * a1->f64[0] - v13;
  v31.f64[0] = 0.0;
  v31.f64[1] = v14;
  double v15 = a1[1].f64[1] * v12 + v11 * a1[1].f64[0] - v13;
  uint64_t v32 = 0x3FD5555560000000;
  double v33 = v15;
  double v16 = a1[2].f64[1] * v12 + v11 * a1[2].f64[0] - v13;
  uint64_t v34 = 0x3FE5555560000000;
  double v35 = v16;
  double v17 = v12 * a1[3].f64[1] + v11 * a1[3].f64[0] - v13;
  uint64_t v36 = 0x3FF0000000000000;
  double v37 = v17;
  *(float *)&double v17 = v15 * 9.0 + v14 * -3.0 + v16 * -9.0 + v17 * 3.0;
  *(float *)&double v16 = v15 * -12.0 + v14 * 6.0 + v16 * 6.0;
  *(float *)&float64_t v14 = v15 * 3.0 + v14 * -3.0;
  *(float *)&float64_t v14 = sqrtf((float)((float)(*(float *)&v17 * -4.0) * *(float *)&v14) + (float)(*(float *)&v16
                                                                                          * *(float *)&v16));
  *(float *)&double v17 = *(float *)&v17 + *(float *)&v17;
  float v18 = (float)((float)-*(float *)&v16 - *(float *)&v14) / *(float *)&v17;
  double v19 = TSDPointOnCurve(&v31, (float)((float)(*(float *)&v14 - *(float *)&v16) / *(float *)&v17));
  double v21 = v20;
  double v22 = TSDPointOnCurve(&v31, v18);
  double v23 = fabs(v21);
  double v25 = fabs(v24);
  BOOL v27 = v22 > 1.0 || v22 < 0.0 || v23 < v25;
  if (v27 && (v19 >= 0.0 ? (BOOL v28 = v19 > 1.0) : (BOOL v28 = 1), !v28)
    || (v22 >= 0.0 ? (v29 = v22 > 1.0) : (v29 = 1), double v19 = v22, !v29))
  {
    *(double *)a3 = TSDPointOnCurve(a1, v19);
    *(void *)(a3 + 8) = v30;
  }
}

double TSDPathGetElementLengthAtIndex(const CGPath *a1, uint64_t a2)
{
  v3[0] = a2;
  v3[1] = a2;
  v3[2] = 0;
  double v4 = 0.0;
  CGPathApply(a1, v3, (CGPathApplierFunction)TSDPathGetLengthApplierFunction);
  return v4;
}

void TSDPathGetLengthApplierFunction(uint64_t a1, int *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3 >= *(void *)a1 && v3 <= *(void *)(a1 + 8))
  {
    int v4 = *a2;
    if (*a2 == 4) {
      goto LABEL_6;
    }
    if (v4 == 3)
    {
      uint64_t v8 = *((void *)a2 + 1);
      double v9 = 0.0;
      p_AddIfClose(v8, &v9);
      double v5 = v9;
      goto LABEL_8;
    }
    double v5 = 0.0;
    if (v4 == 1)
    {
LABEL_6:
      double v6 = (double *)*((void *)a2 + 1);
      float v7 = (v6[1] - v6[3]) * (v6[1] - v6[3]) + (*v6 - v6[2]) * (*v6 - v6[2]);
      double v5 = sqrtf(v7);
    }
LABEL_8:
    *(double *)(a1 + 24) = v5 + *(double *)(a1 + 24);
  }
  *(void *)(a1 + 16) = v3 + 1;
}

double TSDPathGetLength(const CGPath *a1)
{
  long long v2 = xmmword_223839988;
  long long v3 = unk_223839998;
  CGPathApply(a1, &v2, (CGPathApplierFunction)TSDPathGetLengthApplierFunction);
  return *((double *)&v3 + 1);
}

double TSDPathGetLengthToElement(const CGPath *a1, uint64_t a2)
{
  v3[0] = 0;
  long long v4 = 0u;
  v3[1] = a2;
  CGPathApply(a1, v3, (CGPathApplierFunction)TSDPathGetLengthApplierFunction);
  return *((double *)&v4 + 1);
}

double TSDPathGetLengthFromElement(const CGPath *a1, uint64_t a2)
{
  v3[0] = a2;
  v3[1] = 0x7FFFFFFFLL;
  void v3[2] = 0;
  double v4 = 0.0;
  CGPathApply(a1, v3, (CGPathApplierFunction)TSDPathGetLengthApplierFunction);
  return v4;
}

uint64_t TSDPathGetElementCount(const CGPath *a1)
{
  uint64_t info = 0;
  CGPathApply(a1, &info, (CGPathApplierFunction)TSDPathGetElementCountApplierFunction);
  return info;
}

void *TSDPathGetElementCountApplierFunction(void *result)
{
  return result;
}

uint64_t TSDPathGetElementTypeAtIndex(const CGPath *a1, uint64_t a2)
{
  long long v7 = 0u;
  long long v8 = 0u;
  long long v5 = 0u;
  long long v6 = 0u;
  long long v4 = 0u;
  uint64_t info = a2;
  CGPathApply(a1, &info, (CGPathApplierFunction)TSDPathGetElementApplierFunction);
  return DWORD2(v4);
}

uint64_t TSDPathGetElementApplierFunction(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 8);
  if (*(void *)result == v2)
  {
    *(_DWORD *)(result + 16) = *(_DWORD *)a2;
    *(_OWORD *)(result + 72) = *(_OWORD *)(*(void *)(a2 + 8) + 48);
    *(_OWORD *)(result + 56) = *(_OWORD *)(*(void *)(a2 + 8) + 32);
    *(_OWORD *)(result + 40) = *(_OWORD *)(*(void *)(a2 + 8) + 16);
    *(_OWORD *)(result + 24) = *(_OWORD *)*(void *)(a2 + 8);
  }
  *(void *)(result + 8) = v2 + 1;
  return result;
}

uint64_t TSDPathGetElementTypeAtIndexAndAllPoints(const CGPath *a1, uint64_t a2, _OWORD *a3)
{
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v8 = 0u;
  uint64_t info = a2;
  CGPathApply(a1, &info, (CGPathApplierFunction)TSDPathGetElementApplierFunction);
  long long v4 = v10;
  *a3 = v9;
  a3[1] = v4;
  long long v5 = v12;
  a3[2] = v11;
  a3[3] = v5;
  return DWORD2(v8);
}

uint64_t TSDPathGetElementTypeAtIndexAndAssociatedPoints(const CGPath *a1, uint64_t a2, _OWORD *a3)
{
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v7 = 0u;
  uint64_t info = a2;
  CGPathApply(a1, &info, (CGPathApplierFunction)TSDPathGetElementApplierFunction);
  if (!a3) {
    return DWORD2(v7);
  }
  *a3 = v8;
  uint64_t result = DWORD2(v7);
  if (DWORD2(v7) == 3)
  {
    long long v5 = v10;
    a3[1] = v9;
    a3[2] = v5;
  }
  return result;
}

void curveIntersectLine(double *a1, double *a2, uint64_t a3, uint64_t a4, int a5, void *a6)
{
  uint64_t v64 = *MEMORY[0x263EF8340];
  double v11 = *a1;
  double v12 = a1[2];
  double v13 = a1[4];
  double v14 = a1[5];
  double v15 = a1[6];
  double v16 = a1[7];
  double v18 = a2[2];
  double v17 = a2[3];
  double v19 = v17 - a2[1];
  double v20 = v18 - *a2;
  float v21 = v20 * v20 + v19 * v19;
  double v22 = (float)(1.0 / sqrtf(v21));
  double v23 = v19 * v22;
  double v24 = -(v20 * v22);
  double v25 = v17 * v24 + v23 * v18;
  double v55 = a1[3];
  double v56 = a1[1];
  v57.f64[0] = 0.0;
  v57.f64[1] = v56 * v24 + v23 * v11 - v25;
  uint64_t v58 = 0x3FD5555555555555;
  double v59 = v55 * v24 + v23 * v12 - v25;
  double v53 = v16;
  double v54 = v14;
  uint64_t v60 = 0x3FE5555555555555;
  double v61 = v14 * v24 + v23 * v13 - v25;
  uint64_t v62 = 0x3FF0000000000000;
  double v63 = v16 * v24 + v23 * v15 - v25;
  id v26 = objc_alloc_init(MEMORY[0x263EFF980]);
  curveIntersectLineR(&v57, (uint64_t)&v57, v26, 1.0);
  uint64_t v27 = [v26 count];
  if (v27 >= 1)
  {
    uint64_t v28 = v27;
    uint64_t v29 = 0;
    double v52 = v13;
    do
    {
      objc_msgSend((id)objc_msgSend(v26, "objectAtIndex:", v29), "doubleValue");
      double v31 = v30;
      double v32 = 1.0 - v30;
      double v33 = v31 * (v31 * (v15 * v31 + v32 * v13) + v32 * (v13 * v31 + v32 * v12))
          + v32 * (v31 * (v13 * v31 + v32 * v12) + v32 * (v12 * v31 + v32 * v11));
      double v34 = a2[2] - *a2;
      double v35 = v33 - *a2;
      if (v34 * v35 > -0.001)
      {
        double v36 = v31 * (v31 * (v53 * v31 + v32 * v54) + v32 * (v54 * v31 + v32 * v55))
            + v32 * (v31 * (v54 * v31 + v32 * v55) + v32 * (v55 * v31 + v32 * v56));
        double v37 = a2[1];
        double v38 = a2[3] - v37;
        double v39 = v38 * v38 + v34 * v34;
        double v40 = (v36 - v37) * (v36 - v37) + v35 * v35;
        if (v38 * (v36 - v37) > -0.001 && v40 <= v39)
        {
          if (!a6) {
            break;
          }
          double v42 = v12;
          double v43 = v15;
          double v44 = v11;
          double v45 = sqrt(v40) / sqrt(v39);
          CGFloat v46 = [TSDPathIntersection alloc];
          if (a5)
          {
            uint64_t v47 = a4;
            double v48 = v45;
            uint64_t v49 = a3;
            double v50 = v31;
          }
          else
          {
            uint64_t v47 = a3;
            double v48 = v31;
            uint64_t v49 = a4;
            double v50 = v45;
          }
          uint64_t v51 = -[TSDPathIntersection initWithSegment:atT:onSegmentB:atT:atPoint:](v46, "initWithSegment:atT:onSegmentB:atT:atPoint:", v47, v49, v48, v50, v33, v36);
          [a6 addObject:v51];

          double v11 = v44;
          double v15 = v43;
          double v12 = v42;
          double v13 = v52;
        }
      }
      ++v29;
    }
    while (v28 != v29);
  }
}

void lineIntersectsLine(double *a1, double *a2, uint64_t a3, uint64_t a4, void *a5)
{
  double v11 = 0.0;
  double v12 = 0.0;
  long long v10 = *MEMORY[0x263F00148];
  if (TSDIntersectionOfLines(a1, a2, &v12, &v11, (double *)&v10))
  {
    long long v8 = [TSDPathIntersection alloc];
    long long v9 = [(TSDPathIntersection *)v8 initWithSegment:a3 atT:a4 onSegmentB:v12 atT:v11 atPoint:v10];
    [a5 addObject:v9];
  }
}

void nearestAngleOnCurveToLine(float64x2_t *a1, double *a2, uint64_t a3)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  double v5 = *a2;
  double v6 = TSDSubtractPoints(a2[2], a2[3], *a2);
  double v8 = TSDNormalizePoint(v6, v7);
  double v10 = v9;
  double v11 = TSDSubtractPoints(a1->f64[0], a1->f64[1], v5);
  double v13 = TSDNormalizePoint(v11, v12);
  v41.f64[0] = 0.0;
  v41.f64[1] = TSDDotPoints(v8, v10, v13, v14);
  double v15 = TSDSubtractPoints(a1[1].f64[0], a1[1].f64[1], v5);
  double v17 = TSDNormalizePoint(v15, v16);
  uint64_t v42 = 0x3FD5555555555555;
  double v43 = TSDDotPoints(v8, v10, v17, v18);
  double v19 = TSDSubtractPoints(a1[2].f64[0], a1[2].f64[1], v5);
  double v21 = TSDNormalizePoint(v19, v20);
  uint64_t v44 = 0x3FE5555555555555;
  double v45 = TSDDotPoints(v8, v10, v21, v22);
  double v23 = TSDSubtractPoints(a1[3].f64[0], a1[3].f64[1], v5);
  double v25 = TSDNormalizePoint(v23, v24);
  uint64_t v46 = 0x3FF0000000000000;
  double v47 = TSDDotPoints(v8, v10, v25, v26);
  double v27 = v43 * 9.0 + v41.f64[1] * -3.0 + v45 * -9.0 + v47 * 3.0;
  double v28 = v43 * -12.0 + v41.f64[1] * 6.0 + v45 * 6.0;
  double v29 = sqrt((v43 * 3.0 + v41.f64[1] * -3.0) * (v27 * -4.0) + v28 * v28);
  double v30 = (-v28 - v29) / (v27 + v27);
  double v31 = TSDPointOnCurve(&v41, (v29 - v28) / (v27 + v27));
  double v33 = v32;
  double v34 = TSDPointOnCurve(&v41, v30);
  BOOL v37 = v34 <= 1.0 && v34 >= 0.0 && v33 <= v35;
  if (!v37 && (v31 >= 0.0 ? (BOOL v38 = v31 > 1.0) : (BOOL v38 = 1), !v38)
    || (v34 >= 0.0 ? (v39 = v34 > 1.0) : (v39 = 1), double v31 = v34, !v39))
  {
    *(double *)a3 = TSDPointOnCurve(a1, v31);
    *(void *)(a3 + 8) = v40;
  }
}

double F(float64x2_t *a1, double a2, double a3, double a4, double a5, double a6, double a7)
{
  float64x2_t v7 = a1[1];
  float64x2_t v8 = a1[2];
  float64x2_t v9 = vmlaq_n_f64(vmulq_n_f64(v8, a7), v7, a6);
  *(void *)&double result = *(_OWORD *)&vmlaq_n_f64(vmulq_n_f64(vmlaq_n_f64(vmulq_n_f64(vmlaq_n_f64(vmulq_n_f64(a1[3], a7), v8, a6), a5), v9, a4), a3), vmlaq_n_f64(vmulq_n_f64(v9, a5), vmlaq_n_f64(vmulq_n_f64(v7, a7), *a1, a6), a4), a2);
  return result;
}

uint64_t recursiveSubdivideCurve(float64x2_t *a1, void *a2, uint64_t a3, uint64_t a4, void *a5, void *a6, int a7, uint64_t a8)
{
  uint64_t v110 = *MEMORY[0x263EF8340];
  float v100 = 0.0;
  uint64_t v99 = 0;
  objc_msgSend(a2, "transformedTotalCoordinate:betweenElement:andElement:withPressure:getElement:getPercentage:", a3, a4, a5, &v99, &v100, a1->f64[0], a1->f64[1]);
  double v97 = v16;
  double v98 = v17;
  v103.f64[0] = v16;
  v103.f64[1] = v17;
  [a2 curvatureAt:v99 fromElement:v100];
  float v19 = v18;
  *(float *)&double v18 = v100;
  [a2 myGradientAt:v99 fromElement:v18];
  double v93 = v20;
  double v91 = v21;
  objc_msgSend(a2, "transformedTotalCoordinate:betweenElement:andElement:withPressure:getElement:getPercentage:", a3, a4, a5, &v99, &v100, a1[3].f64[0], a1[3].f64[1]);
  double v23 = v22;
  double v96 = v24;
  double v108 = v24;
  double v109 = v22;
  [a2 curvatureAt:v99 fromElement:v100];
  float v26 = v25;
  *(float *)&double v25 = v100;
  [a2 myGradientAt:v99 fromElement:v25];
  double v92 = v27;
  double v90 = v28;
  float v29 = 0.5;
  if (v19 <= 0.5) {
    float v30 = v19;
  }
  else {
    float v30 = 0.5;
  }
  if (v30 >= -0.5) {
    float v31 = v30;
  }
  else {
    float v31 = -0.5;
  }
  if (v26 <= 0.5) {
    float v29 = v26;
  }
  if (v29 < -0.5) {
    float v29 = -0.5;
  }
  float v89 = v29;
  [a2 lineWidth];
  float v33 = v32;
  double v34 = a1->f64[1];
  double v95 = v23;
  if (a5)
  {
    [a5 pressureAt:a1->f64[0]];
    double v36 = v33;
    double v37 = v34 * v35 * v36;
    double v38 = a1[1].f64[1];
    [a5 pressureAt:a1[1].f64[0]];
    double v40 = v38 * v39 * v36;
    double v41 = a1[2].f64[1];
    [a5 pressureAt:a1[2].f64[0]];
    double v43 = v41 * v42 * v36;
    double v44 = a1[3].f64[1];
    [a5 pressureAt:a1[3].f64[0]];
  }
  else
  {
    double v36 = v33;
    double v37 = v34 * v36;
    double v40 = a1[1].f64[1] * v36;
    double v43 = a1[2].f64[1] * v36;
    double v44 = a1[3].f64[1];
    double v45 = 1.0;
  }
  float v46 = v40;
  float v47 = v37;
  float v48 = v43;
  float v49 = v36 * (v44 * v45);
  float64_t v50 = a1[1].f64[0] - a1->f64[0];
  double v51 = (float)(v46 - v47);
  double v52 = TSDMultiplyPointScalar(v93, v91, 1.0 - (float)(v31 * v47));
  double v53 = TSDNormalizePoint(-v91, v93);
  double v54 = TSDAddPoints(v97, v98, v53 * v51 + v50 * v52);
  double v104 = v54;
  double v105 = v55;
  double v94 = v55;
  float64_t v56 = a1[2].f64[0] - a1[3].f64[0];
  double v57 = TSDMultiplyPointScalar(v92, v90, 1.0 - (float)(v89 * v49));
  double v58 = TSDNormalizePoint(-v90, v92);
  double v59 = TSDAddPoints(v96, v95, v58 * (float)(v48 - v49) + v56 * v57);
  double v61 = v60;
  double v106 = v59;
  double v107 = v60;
  if (a7)
  {
    if (a7 > 19) {
      goto LABEL_19;
    }
    double v62 = TSDSubtractPoints(v96, v95, v97);
    if (TSDPointSquaredLength(v62, v63) <= 0.5) {
      goto LABEL_19;
    }
  }
  double v64 = TSDPointOnCurve(&v103, 0.33);
  double v66 = v65;
  objc_msgSend(a2, "transformedTotalCoordinate:betweenElement:andElement:withPressure:getElement:getPercentage:", a3, a4, a5, &v99, &v100, TSDPointOnCurve(a1, 0.33));
  double v68 = TSDSubtractPoints(v64, v66, v67);
  *(float *)&double v66 = TSDPointSquaredLength(v68, v69) + 0.0;
  double v70 = TSDPointOnCurve(&v103, 0.5);
  double v72 = v71;
  objc_msgSend(a2, "transformedTotalCoordinate:betweenElement:andElement:withPressure:getElement:getPercentage:", a3, a4, a5, &v99, &v100, TSDPointOnCurve(a1, 0.5));
  double v74 = TSDSubtractPoints(v70, v72, v73);
  float v76 = TSDPointSquaredLength(v74, v75) + *(float *)&v66;
  double v77 = TSDPointOnCurve(&v103, 0.66);
  double v79 = v78;
  objc_msgSend(a2, "transformedTotalCoordinate:betweenElement:andElement:withPressure:getElement:getPercentage:", a3, a4, a5, &v99, &v100, TSDPointOnCurve(a1, 0.66));
  double v81 = TSDSubtractPoints(v77, v79, v80);
  float v83 = TSDPointSquaredLength(v81, v82) + v76;
  if (v83 <= 0.2)
  {
LABEL_19:
    if (a8)
    {
      objc_msgSend(a6, "moveToPoint:", v97, v98);
    }
    else
    {
      [a6 currentPoint];
      double v87 = TSDSubtractPoints(v97, v98, v86);
      if (TSDPointSquaredLength(v87, v88) > 1.0) {
        objc_msgSend(a6, "lineToPoint:", v97, v98);
      }
    }
    return objc_msgSend(a6, "curveToPoint:controlPoint1:controlPoint2:", v96, v95, v54, v94, v59, v61);
  }
  else
  {
    TSDCurveBetween(a1, (uint64_t)v102, 0.0, 0.5);
    TSDCurveBetween(a1, (uint64_t)v101, 0.5, 1.0);
    uint64_t v84 = (a7 + 1);
    recursiveSubdivideCurve(v102, a2, a3, a4, a5, a6, v84, a8);
    return recursiveSubdivideCurve(v101, a2, a3, a4, a5, a6, v84, 0);
  }
}

void recursiveSubdivideCurveSplit(float64x2_t *a1, void *a2, void *a3, void *a4, uint64_t a5, void *a6)
{
  uint64_t v133 = *MEMORY[0x263EF8340];
  uint64_t v10 = [a6 count];
  uint64_t v11 = v10 - 1;
  if ((unint64_t)(v10 - 1) < 2)
  {
    double v28 = 0;
    uint64_t v13 = 0;
LABEL_22:
    uint64_t v14 = v11;
    goto LABEL_23;
  }
  uint64_t v12 = v10;
  uint64_t v125 = v10 - 1;
  id v127 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  double v15 = a1[1].f64[0];
  double v16 = a1[2].f64[0];
  double v17 = a1[3].f64[0];
  float v18 = fmin(a1->f64[0], fmin(v15, fmin(v16, v17)));
  float v19 = fmax(a1->f64[0], fmax(v15, fmax(v16, v17)));
  uint64_t v20 = 2;
  do
  {
    objc_msgSend((id)objc_msgSend(a6, "objectAtIndex:", v20 - 1), "t");
    float v22 = v21;
    if (v22 > v18 && v22 < v19)
    {
      id v25 = v127;
      if (!v127) {
        id v25 = objc_alloc_init(MEMORY[0x263EFF980]);
      }
      double v24 = v22;
      v129.f64[0] = v24;
      v129.f64[1] = -100.0;
      v130.f64[0] = v24;
      v130.f64[1] = 100.0;
      id v127 = v25;
      curveIntersectLine(a1->f64, v129.f64, v20 - 1, v20 - 1, 0, v25);
    }
    else
    {
      double v24 = v22;
    }
    double v26 = a1[3].f64[0];
    if (v26 > v24) {
      uint64_t v13 = v20 - 1;
    }
    if (v26 < v24) {
      uint64_t v27 = v20 - 1;
    }
    else {
      uint64_t v27 = 0;
    }
    if (!v14) {
      uint64_t v14 = v27;
    }
    ++v20;
  }
  while (v12 != v20);
  double v28 = v127;
  uint64_t v11 = v125;
  if (!v14) {
    goto LABEL_22;
  }
LABEL_23:
  id v128 = v28;
  if (v28 && [v28 count])
  {
    [v128 sortUsingSelector:sel_compareT_];
    float v29 = -[TSDPathIntersection initWithSegment:atT:atPoint:]([TSDPathIntersection alloc], "initWithSegment:atT:atPoint:", v13, 1.0, 1000.0, 0.0);
    [v128 addObject:v29];

    uint64_t v30 = [v128 count];
    if (v30)
    {
      uint64_t v31 = v30;
      uint64_t v32 = 0;
      uint64_t v119 = v30 - 1;
      float v33 = 0.0;
      __asm { FMOV            V0.2D, #0.5 }
      int8x16_t v121 = _Q0;
      float64x2_t v122 = (float64x2_t)vdupq_n_s64(0x7FF0000000000000uLL);
      __asm { FMOV            V0.2D, #1.0 }
      float64x2_t v120 = _Q0;
      do
      {
        float v39 = v33;
        double v40 = (void *)[v128 objectAtIndex:v32];
        [v40 t];
        float64x2_t v41 = a1[1];
        float64x2_t v129 = *a1;
        float64x2_t v130 = v41;
        float64x2_t v42 = a1[3];
        float64x2_t v131 = a1[2];
        float64x2_t v132 = v42;
        float v33 = v43;
        v42.f64[0] = 1.0 - v39;
        float64x2_t v44 = vmlaq_n_f64(vmulq_n_f64(v131, v39), v130, v42.f64[0]);
        float64x2_t v126 = vmlaq_n_f64(vmulq_n_f64(vmlaq_n_f64(vmulq_n_f64(vmlaq_n_f64(vmulq_n_f64(v132, v39), v131, v42.f64[0]), v39), v44, v42.f64[0]), v39), vmlaq_n_f64(vmulq_n_f64(v44, v39), vmlaq_n_f64(vmulq_n_f64(v130, v39), v129, v42.f64[0]), v42.f64[0]), v42.f64[0]);
        double v45 = 1.0 - v33;
        float64x2_t v46 = vmlaq_n_f64(vmulq_n_f64(v130, v33), v129, v45);
        float64x2_t v47 = vmlaq_n_f64(vmulq_n_f64(v131, v33), v130, v45);
        float64x2_t v48 = vmlaq_n_f64(vmulq_n_f64(v132, v33), v131, v45);
        float64x2_t v129 = v126;
        float64x2_t v130 = vmlaq_n_f64(vmulq_n_f64(vmlaq_n_f64(vmulq_n_f64(v48, v39), v47, v42.f64[0]), v39), vmlaq_n_f64(vmulq_n_f64(v47, v39), v46, v42.f64[0]), v42.f64[0]);
        float64x2_t v49 = vmlaq_n_f64(vmulq_n_f64(v47, v33), v46, v45);
        float64x2_t v50 = vmlaq_n_f64(vmulq_n_f64(v48, v33), v47, v45);
        float64x2_t v131 = vmlaq_n_f64(vmulq_n_f64(v50, v39), v49, v42.f64[0]);
        float64x2_t v132 = vmlaq_n_f64(vmulq_n_f64(v50, v33), v49, v45);
        [v40 point];
        double v52 = v51;
        uint64_t v53 = [v40 segment];
        uint64_t v54 = [v40 segment];
        if (v126.f64[0] <= v52)
        {
          if (v32 == v119) {
            uint64_t v55 = v54 + 1;
          }
          else {
            uint64_t v55 = v54;
          }
          v53 -= v32 != v119;
        }
        else
        {
          uint64_t v55 = v54 + 1;
        }
        float64_t v56 = objc_msgSend(a6, "objectAtIndex:", v53, v126.f64[0]);
        double v57 = (void *)[a6 objectAtIndex:v55];
        [v56 t];
        double v59 = v58;
        [v57 t];
        double v61 = v60;
        [v56 skew];
        double v63 = v62;
        [v57 skew];
        double v65 = v64;
        [a2 lineWidth];
        double v67 = v66;
        [a2 length];
        uint64_t v68 = 0;
        float v69 = v63;
        *(double *)&uint64_t v70 = (float)-v69;
        float v71 = v65;
        *(double *)&uint64_t v72 = (float)(v69 + v71);
        *(float *)&double v73 = v67 / v73;
        double v74 = *(float *)&v73;
        float v75 = v61;
        float v76 = v59;
        *(double *)&uint64_t v77 = (float)(v75 - v76);
        float64x2_t v78 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(v76), 0);
        float64x2_t v79 = (float64x2_t)vdupq_lane_s64(v77, 0);
        float64x2_t v80 = (float64x2_t)vdupq_lane_s64(v72, 0);
        float64x2_t v81 = (float64x2_t)vdupq_lane_s64(v70, 0);
        do
        {
          double v82 = &v129.f64[v68];
          float64x2x2_t v135 = vld2q_f64(v82);
          float64x2_t v83 = vdivq_f64(vsubq_f64(v135.val[0], v78), v79);
          float64x2_t v84 = vabsq_f64(v83);
          float64x2_t v85 = vminnmq_f64((float64x2_t)vbslq_s8(vorrq_s8((int8x16_t)vcgtq_f64(v122, v84), (int8x16_t)vcgtq_f64(v84, v122)), (int8x16_t)v83, v121), v120);
          v135.val[0] = vmlaq_f64(v135.val[0], v135.val[1], vmulq_n_f64(vmlaq_f64(v81, v80, (float64x2_t)vbicq_s8((int8x16_t)v85, (int8x16_t)vcltzq_f64(v85))), v74));
          *double v82 = v135.val[0].f64[0];
          *(float64_t *)((char *)&v129 + v68 * 8 + 16) = v135.val[0].f64[1];
          v68 += 4;
        }
        while (v68 != 8);
        recursiveSubdivideCurve(&v129, a2, [v56 segment] + 1, objc_msgSend(v57, "segment"), a3, a4, 0, a5 & 1);
        LOBYTE(a5) = 0;
        ++v32;
      }
      while (v32 != v31);
    }
  }
  else
  {
    double v86 = (void *)[a6 objectAtIndex:v13];
    double v87 = (void *)[a6 objectAtIndex:v14];
    [v86 t];
    double v89 = v88;
    [v87 t];
    double v91 = v90;
    [v86 skew];
    double v93 = v92;
    [v87 skew];
    double v95 = v94;
    [a2 lineWidth];
    double v97 = v96;
    [a2 length];
    uint64_t v98 = 0;
    float64x2_t v99 = (float64x2_t)vdupq_n_s64(0x7FF0000000000000uLL);
    float v100 = v93;
    *(double *)&uint64_t v101 = (float)-v100;
    float v102 = v95;
    *(double *)&uint64_t v103 = (float)(v100 + v102);
    *(float *)&double v104 = v97 / v104;
    double v105 = *(float *)&v104;
    float v106 = v91;
    float v107 = v89;
    *(double *)&uint64_t v108 = (float)(v106 - v107);
    float64x2_t v109 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(v107), 0);
    float64x2_t v110 = (float64x2_t)vdupq_lane_s64(v108, 0);
    float64x2_t v111 = (float64x2_t)vdupq_lane_s64(v103, 0);
    float64x2_t v112 = (float64x2_t)vdupq_lane_s64(v101, 0);
    __asm
    {
      FMOV            V6.2D, #0.5
      FMOV            V7.2D, #1.0
    }
    do
    {
      f64 = a1[v98].f64;
      float64x2x2_t v136 = vld2q_f64(f64);
      float64x2_t v116 = vdivq_f64(vsubq_f64(v136.val[0], v109), v110);
      float64x2_t v117 = vabsq_f64(v116);
      float64x2_t v118 = vminnmq_f64((float64x2_t)vbslq_s8(vorrq_s8((int8x16_t)vcgtq_f64(v99, v117), (int8x16_t)vcgtq_f64(v117, v99)), (int8x16_t)v116, _Q6), _Q7);
      v136.val[0] = vmlaq_f64(v136.val[0], v136.val[1], vmulq_n_f64(vmlaq_f64(v112, v111, (float64x2_t)vbicq_s8((int8x16_t)v118, (int8x16_t)vcltzq_f64(v118))), v105));
      double *f64 = v136.val[0].f64[0];
      a1[v98 + 1].f64[0] = v136.val[0].f64[1];
      v98 += 2;
    }
    while (v98 != 4);
    recursiveSubdivideCurve(a1, a2, [v86 segment] + 1, objc_msgSend(v87, "segment"), a3, a4, 0, a5);
  }
}

double TSDPathNearestAngleOnPathToLine(const CGPath *a1, double *a2)
{
  double v4 = TSDSubtractPoints(a2[2], a2[3], *a2);
  double v6 = TSDNormalizePoint(v4, v5);
  v9[0] = a2;
  v9[1] = 0xC000000000000000;
  long long v10 = *MEMORY[0x263F00148];
  double v11 = v6;
  uint64_t v12 = v7;
  TSDPathApplyToSegments(a1, (uint64_t)v9, (uint64_t)TSDPathNearestAngleOnPathToLineApplier);
  return *(double *)&v10;
}

void TSDPathNearestAngleOnPathToLineApplier(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a2 == 3)
  {
    uint64_t v7 = *(float64x2_t **)(a2 + 8);
    double v5 = v7[3].f64[0];
    double v6 = v7[3].f64[1];
    long long v17 = *MEMORY[0x263F00148];
    nearestAngleOnCurveToLine(v7, *(double **)a1, (uint64_t)&v17);
    if (v8 > *(double *)(a1 + 8))
    {
      *(_OWORD *)(a1 + 16) = v17;
      *(double *)(a1 + 8) = v8;
    }
  }
  else if (*(_DWORD *)a2 == 1)
  {
    uint64_t v4 = *(void *)(a2 + 8);
    double v5 = *(double *)(v4 + 16);
    double v6 = *(double *)(v4 + 24);
  }
  else
  {
    float64x2_t v9 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v10 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSDPathNearestAngleOnPathToLineApplier(void *, const TSDPathSegment *)");
    objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDPathDistortion.m"), 2182, @"TSDPathAddIntersectionsWithLine doesn't handle quad curves or some other element type");
    uint64_t v11 = *(void *)(a2 + 8);
    double v5 = *(double *)(v11 + 32);
    double v6 = *(double *)(v11 + 40);
  }
  double v12 = TSDSubtractPoints(v5, v6, **(double **)a1);
  double v14 = TSDNormalizePoint(v12, v13);
  double v16 = TSDDotPoints(*(double *)(a1 + 32), *(double *)(a1 + 40), v14, v15);
  if (v16 > *(double *)(a1 + 8))
  {
    *(double *)(a1 + 16) = v5;
    *(double *)(a1 + 24) = v6;
    *(double *)(a1 + 8) = v16;
  }
}

void p_AddIfClose(uint64_t a1, double *a2)
{
  uint64_t v4 = 0;
  uint64_t v35 = *MEMORY[0x263EF8340];
  double v5 = *(double *)a1;
  double v6 = *(double *)(a1 + 8);
  double v7 = 0.0;
  double v8 = v6;
  double v9 = *(double *)a1;
  do
  {
    double v10 = *(double *)(a1 + v4 + 16);
    double v11 = *(double *)(a1 + v4 + 24);
    double v7 = v7 + TSDDistance(v9, v8, v10, v11);
    v4 += 16;
    double v8 = v11;
    double v9 = v10;
  }
  while (v4 != 48);
  if (v7 - TSDDistance(v5, v6, *(double *)(a1 + 48), *(double *)(a1 + 56)) <= 0.100000001)
  {
    *a2 = v7 + *a2;
  }
  else
  {
    long long v12 = *(_OWORD *)(a1 + 16);
    v34[0] = *(_OWORD *)a1;
    v34[1] = v12;
    long long v13 = *(_OWORD *)(a1 + 48);
    v34[2] = *(_OWORD *)(a1 + 32);
    v34[3] = v13;
    uint64_t v14 = 1;
    uint64_t v15 = 3;
    __asm { FMOV            V0.2D, #0.5 }
    double v21 = v34;
    do
    {
      uint64_t v22 = 0;
      float64x2_t v23 = (float64x2_t)v34[4 * v14 - 4];
      do
      {
        double v24 = (float64x2_t *)&v21[v22];
        float64x2_t v25 = v24[1];
        v24[4] = vmlaq_f64(vmulq_f64(v25, _Q0), _Q0, v23);
        ++v22;
        float64x2_t v23 = v25;
      }
      while (v15 != v22);
      ++v14;
      --v15;
      v21 += 4;
    }
    while (v14 != 4);
    uint64_t v26 = 0;
    uint64_t v27 = v34;
    do
    {
      long long v28 = *v27;
      v27 += 4;
      *(_OWORD *)&v33[v26] = v28;
      v26 += 16;
    }
    while (v26 != 64);
    float v29 = v32;
    uint64_t v30 = 3;
    uint64_t v31 = 12;
    do
    {
      *v29++ = v34[v31];
      --v30;
      v31 -= 3;
    }
    while (v30 != -1);
    p_AddIfClose(v33, a2);
    p_AddIfClose(v32, a2);
  }
}

void curveIntersectCurveR(float64x2_t *a1, double *a2, uint64_t a3, uint64_t a4, int a5, void *a6, double a7, double a8, double a9, double a10)
{
  v43[8] = *(double *)MEMORY[0x263EF8340];
  double v41 = 0.0;
  double v42 = 0.0;
  clipToFatCurve(a1->f64, a2, &v42, &v41);
  double v20 = v42;
  if (v42 <= 1.0)
  {
    double v21 = v41;
    if (v41 >= 0.0)
    {
      if ((v41 - v42) * a7 >= 0.0001)
      {
        if (v41 - v42 >= 0.8)
        {
          double v36 = (v42 + v41) * 0.5;
          TSDDCurveBetween(a1, (uint64_t)v43, v42, v36);
          uint64_t v37 = a5 ^ 1u;
          curveIntersectCurveR(a2, v43, a4, a3, v37, a6, a9, a10, (v21 - v36) * a7, a8 + v20 * a7);
          TSDDCurveBetween(a1, (uint64_t)v43, (v20 + v21) * 0.5, v21);
          double v28 = a8 + v36 * a7;
          uint64_t v30 = a2;
          double v31 = a9;
          double v32 = a10;
          double v33 = (v21 - v36) * a7;
          uint64_t v34 = a4;
          uint64_t v35 = a3;
          uint64_t v29 = v37;
        }
        else
        {
          TSDDCurveBetween(a1, (uint64_t)v43, v42, v41);
          double v28 = a8 + v20 * a7;
          uint64_t v29 = a5 ^ 1u;
          uint64_t v30 = a2;
          double v31 = a9;
          double v32 = a10;
          double v33 = (v21 - v20) * a7;
          uint64_t v34 = a4;
          uint64_t v35 = a3;
        }
        curveIntersectCurveR(v30, v43, v34, v35, v29, a6, v31, v32, v33, v28);
      }
      else
      {
        double v39 = 0.0;
        double v40 = 0.0;
        TSDDCurveBetween(a1, (uint64_t)v43, v42, v41);
        clipToFatCurve(a2, v43, &v40, &v39);
        if ((v39 - v40) * a9 < 0.1)
        {
          double v22 = (v39 + v40) * a9 * 0.5 + a10;
          float64x2_t v23 = [TSDPathIntersection alloc];
          if (a5)
          {
            uint64_t v24 = a4;
            double v25 = v22;
            uint64_t v26 = a3;
            double v27 = (v20 + v21) * a7 * 0.5 + a8;
          }
          else
          {
            uint64_t v24 = a3;
            double v25 = (v20 + v21) * a7 * 0.5 + a8;
            uint64_t v26 = a4;
            double v27 = v22;
          }
          double v38 = -[TSDPathIntersection initWithSegment:atT:onSegmentB:atT:atPoint:](v23, "initWithSegment:atT:onSegmentB:atT:atPoint:", v24, v26, v25, v27, *MEMORY[0x263F00148], *(double *)(MEMORY[0x263F00148] + 8));
          [a6 addObject:v38];
        }
      }
    }
  }
}

double *clipToFatCurve(double *a1, double *a2, double *a3, double *a4)
{
  v28[8] = *MEMORY[0x263EF8340];
  double v6 = a2[6];
  double v7 = a2[7];
  double v8 = v7 - a2[1];
  double v9 = v6 - *a2;
  float v10 = v9 * v9 + v8 * v8;
  double v11 = (float)(1.0 / sqrtf(v10));
  double v12 = v8 * v11;
  double v13 = -(v9 * v11);
  double v14 = v7 * v13 + v12 * v6;
  double v15 = a1[1] * v13 + v12 * *a1 - v14;
  v28[0] = 0;
  *(double *)&v28[1] = v15;
  double v16 = a1[3] * v13 + v12 * a1[2] - v14;
  v28[2] = 0x3FD5555555555555;
  *(double *)&v28[3] = v16;
  double v17 = v13 * a1[5] + v12 * a1[4] - v14;
  v28[4] = 0x3FE5555555555555;
  *(double *)&v28[5] = v17;
  double v18 = v13 * a1[7] + v12 * a1[6] - v14;
  v28[6] = 0x3FF0000000000000;
  *(double *)&v28[7] = v18;
  double v19 = v13 * a2[3] + v12 * a2[2] - v14;
  double v20 = v13 * a2[5] + v12 * a2[4] - v14;
  double v21 = fmin(v19, fmin(v20, 0.0));
  double v22 = fmax(v19, fmax(v20, 0.0));
  *a3 = 2.0;
  *a4 = -1.0;
  shrinkIntervalWithIntersectionsFromCurve(a3, a4, (uint64_t)v28, v21);
  double result = shrinkIntervalWithIntersectionsFromCurve(a3, a4, (uint64_t)v28, v22);
  for (uint64_t i = 0; i != 8; i += 2)
  {
    double v25 = *(double *)&v28[i + 1];
    if (v25 > v21 && v25 < v22)
    {
      double v27 = *(double *)&v28[i];
      *a3 = fmin(*a3, v27);
      *a4 = fmax(*a4, v27);
    }
  }
  return result;
}

double *shrinkIntervalWithIntersectionsFromCurve(double *result, double *a2, uint64_t a3, double a4)
{
  unint64_t v4 = 0;
  double v5 = (double *)(a3 + 24);
  uint64_t v6 = 3;
  do
  {
    if (v4 <= 2)
    {
      double v7 = (double *)(a3 + 16 * v4);
      double v8 = v7 + 1;
      double v9 = v5;
      uint64_t v10 = v6;
      do
      {
        double v11 = *v8;
        if ((*v8 <= a4 || *v9 <= a4) && (v11 >= a4 || *v9 >= a4))
        {
          double v12 = *v7;
          double v13 = *(v9 - 1) - *v7;
          if (v13 != 0.0) {
            double v12 = v13 * (a4 - (v11 - v12 * (*v9 - v11) / v13)) / (*v9 - v11);
          }
          if (v12 < *result) {
            *double result = v12;
          }
          if (v12 > *a2) {
            *a2 = v12;
          }
        }
        v9 += 2;
        --v10;
      }
      while (v10);
    }
    ++v4;
    --v6;
    v5 += 2;
  }
  while (v4 != 4);
  return result;
}

double *curveIntersectLineR(float64x2_t *a1, uint64_t a2, void *a3, double a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  double v14 = -1.0;
  double v15 = 2.0;
  double result = shrinkIntervalWithIntersectionsFromCurve(&v15, &v14, a2, 0.0);
  double v8 = v15;
  if (v15 <= 1.0)
  {
    double v9 = v14;
    if (v14 >= 0.0)
    {
      if (v14 - v15 >= 0.00005)
      {
        if (v14 - v15 >= a4 * 0.8)
        {
          double v13 = (v15 + v14) * 0.5;
          TSDDCurveBetween(a1, (uint64_t)v16, v15, v13);
          curveIntersectLineR(a1, v16, a3, v13 - v8);
          TSDDCurveBetween(a1, (uint64_t)v16, (v8 + v9) * 0.5, v9);
          double v12 = v9 - v13;
          double v11 = a1;
        }
        else
        {
          TSDDCurveBetween(a1, (uint64_t)v16, v15, v14);
          double v11 = a1;
          double v12 = v9 - v8;
        }
        return (double *)curveIntersectLineR(v11, v16, a3, v12);
      }
      else
      {
        uint64_t v10 = [NSNumber numberWithDouble:(v15 + v14) * 0.5];
        return (double *)[a3 addObject:v10];
      }
    }
  }
  return result;
}

uint64_t TSDAdjustGeometryForAlignPathSourceToOrigin(void *a1, void *a2)
{
  [a1 transformedBounds];
  CGFloat v5 = v4;
  CGFloat v7 = v6;
  CGFloat v9 = v8;
  CGFloat v11 = v10;
  BoundingBoCGFloat x = CGPathGetBoundingBox((CGPathRef)[a2 pathWithoutFlips]);
  CGFloat x = BoundingBox.origin.x;
  CGFloat y = BoundingBox.origin.y;
  double width = BoundingBox.size.width;
  double height = BoundingBox.size.height;
  memset(&v31, 0, sizeof(v31));
  if (a2) {
    [a2 pathFlipTransform];
  }
  long long v16 = *(_OWORD *)(MEMORY[0x263F000D0] + 16);
  *(_OWORD *)&v30.a = *MEMORY[0x263F000D0];
  *(_OWORD *)&v30.c = v16;
  *(_OWORD *)&v30.tCGFloat x = *(_OWORD *)(MEMORY[0x263F000D0] + 32);
  *(_OWORD *)&t1.a = *(_OWORD *)&v30.a;
  *(_OWORD *)&t1.c = v16;
  *(_OWORD *)&t1.tCGFloat x = *(_OWORD *)&v30.tx;
  CGAffineTransform t2 = v31;
  CGAffineTransformConcat(&v30, &t1, &t2);
  if (a1) {
    [a1 transform];
  }
  else {
    memset(&v27, 0, sizeof(v27));
  }
  CGAffineTransform t2 = v30;
  CGAffineTransformConcat(&t1, &t2, &v27);
  CGAffineTransform v30 = t1;
  v33.origin.CGFloat x = v5;
  v33.origin.CGFloat y = v7;
  v33.size.double width = v9;
  v33.size.double height = v11;
  *(void *)&double v17 = (unint64_t)CGRectApplyAffineTransform(v33, &t1);
  CGAffineTransform t1 = v30;
  v34.origin.CGFloat x = x;
  v34.origin.CGFloat y = y;
  v34.size.double width = width;
  v34.size.double height = height;
  CGRect v35 = CGRectApplyAffineTransform(v34, &t1);
  double v18 = TSDSubtractPoints(v35.origin.x, v35.origin.y, v17);
  [a1 center];
  objc_msgSend(a1, "setCenter:", TSDAddPoints(v19, v20, v18));
  int v21 = objc_msgSend((id)objc_msgSend(a2, "bezierPath"), "isLineSegment");
  if (width >= 1.0) {
    double v22 = width;
  }
  else {
    double v22 = 1.0;
  }
  if (height >= 1.0) {
    double v23 = height;
  }
  else {
    double v23 = 1.0;
  }
  if (v21) {
    double v24 = width;
  }
  else {
    double v24 = v22;
  }
  if (v21) {
    double v25 = height;
  }
  else {
    double v25 = v23;
  }
  return objc_msgSend(a1, "setSize:", v24, v25, v23, *(_OWORD *)&v27.a, *(_OWORD *)&v27.c, *(_OWORD *)&v27.tx);
}

void sub_2235E5250(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t TSDSpatialDrawableComparator_block_invoke()
{
  double v0 = (void *)TSUProtocolCast();
  unint64_t v1 = (void *)TSUProtocolCast();
  objc_msgSend((id)objc_msgSend(v0, "geometry"), "position");
  double v3 = v2;
  double v5 = v4;
  objc_msgSend((id)objc_msgSend(v1, "geometry"), "position");
  if (v5 < v7) {
    return -1;
  }
  if (v5 > v7) {
    return 1;
  }
  if (v3 >= v6) {
    return v3 > v6;
  }
  else {
    return -1;
  }
}

uint64_t TSDMaskForKnob(char a1)
{
  return 1 << a1;
}

uint64_t TSDKnobTagByRotating270Degrees(uint64_t a1)
{
  uint64_t v1 = a1 - 1;
  if (unint64_t)(a1 - 1) < 9 && ((0x1EFu >> v1)) {
    return qword_223839A50[v1];
  }
  double v2 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
  uint64_t v3 = [NSString stringWithUTF8String:"TSDKnobTag TSDKnobTagByRotating270Degrees(TSDKnobTag)"];
  objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDKnob.m"), 58, @"Unexpected knob tag");
  return 0;
}

uint64_t TSDKnobTagByRotating180Degrees(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) > 0xA) {
    return 0;
  }
  else {
    return qword_223839AE0[a1 - 1];
  }
}

uint64_t TSDOppositeKnobTag(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) > 0xA) {
    return 0;
  }
  else {
    return qword_223839AE0[a1 - 1];
  }
}

uint64_t TSDKnobTagByRotating90Degrees(uint64_t a1)
{
  uint64_t v1 = a1 - 1;
  if (unint64_t)(a1 - 1) < 9 && ((0x1EFu >> v1)) {
    return qword_223839A98[v1];
  }
  double v2 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
  uint64_t v3 = [NSString stringWithUTF8String:"TSDKnobTag TSDKnobTagByRotating90Degrees(TSDKnobTag)"];
  objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDKnob.m"), 89, @"Unexpected knob tag");
  return 0;
}

uint64_t TSDKnobTagForAngle(double a1)
{
  if (a1 > 22.5 && a1 <= 67.5) {
    return 7;
  }
  if (a1 > 67.5 && a1 <= 112.5) {
    return 4;
  }
  if (a1 > 112.5 && a1 <= 157.5) {
    return 1;
  }
  if (a1 > 157.5 && a1 <= 202.5) {
    return 2;
  }
  if (a1 > 202.5 && a1 <= 247.5) {
    return 3;
  }
  if (a1 > 247.5 && a1 <= 292.5) {
    return 6;
  }
  if (a1 > 292.5 && a1 <= 337.5) {
    return 9;
  }
  if (a1 >= 22.5 && a1 <= 337.5) {
    return 0;
  }
  else {
    return 8;
  }
}

uint64_t TSDKnobTagByRotatingKnobByAngle(uint64_t a1)
{
  TSURound();
  TSDNormalizeAngleInDegrees(v2 * 90.0);
  if (fabs(v3 + -90.0) < 0.00999999978)
  {
    return TSDKnobTagByRotating90Degrees(a1);
  }
  if (fabs(v3 + -180.0) < 0.00999999978)
  {
    if ((unint64_t)(a1 - 1) >= 0xB) {
      return 0;
    }
    else {
      return qword_223839AE0[a1 - 1];
    }
  }
  if (fabs(v3 + -270.0) >= 0.00999999978) {
    return a1;
  }

  return TSDKnobTagByRotating270Degrees(a1);
}

double TSDPositionOfKnobOnRectangle(uint64_t a1, double a2, double a3, double a4, double a5)
{
  if ((unint64_t)(a1 - 1) > 8) {
    return *MEMORY[0x263F00148];
  }
  uint64_t v9 = 2 - (a1 - 1) % 3u;
  if (a4 >= 0.0) {
    uint64_t v9 = (a1 - 1) % 3u;
  }
  if (a5 >= 0.0) {
    uint64_t v10 = (a1 - 1) / 3u;
  }
  else {
    uint64_t v10 = 2 - (a1 - 1) / 3u;
  }
  double v11 = qword_26D686C98[v9]();
  qword_26D686CB0[v10](a2, a3, a4, a5);
  return v11;
}

BOOL TSDKnobTagIsCorner(char a1)
{
  return ((1 << a1) & 0x28A) != 0;
}

uint64_t TSDKnobTagWithFlip(uint64_t a1)
{
  uint64_t v2 = a1 - 1;
  uint64_t result = 3;
  switch(v2)
  {
    case 0:
      return result;
    case 1:
    case 7:
    case 11:
      return a1;
    case 2:
      return 1;
    case 3:
      return 6;
    case 4:
    case 9:
    case 10:
      goto LABEL_4;
    case 5:
      return 4;
    case 6:
      return 9;
    case 8:
      return 7;
    default:
      if (a1 != 31)
      {
LABEL_4:
        double v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v5 = [NSString stringWithUTF8String:"TSDKnobTag TSDKnobTagWithFlip(TSDKnobTag)"];
        objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDKnob.m"), 246, @"don't know how to flip knob tag %lu", a1);
      }
      return a1;
  }
}

void sub_2235F25F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_2235F40EC(_Unwind_Exception *a1)
{
  _Block_object_dispose(&STACK[0x280], 8);
  _Block_object_dispose((const void *)(v1 - 256), 8);
  _Block_object_dispose((const void *)(v1 - 208), 8);
  _Unwind_Resume(a1);
}

void sub_2235F4464(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_2235F470C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_2235F51A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_2235F5F30(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 192), 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__12(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__12(uint64_t a1)
{
}

void sub_2235F87D8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_2235FB2C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_2235FC9F4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2235FCAB8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2235FCB50(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t p_bezierPathFittingPointsCallback(uint64_t a1, double *a2, void *a3)
{
  double v4 = *a2;
  double v5 = a2[1];
  double v6 = a2[2];
  double v7 = a2[3];
  double v8 = a2[4];
  double v9 = a2[5];
  double v10 = a2[6];
  double v11 = a2[7];
  if (![a3 elementCount]) {
    objc_msgSend(a3, "moveToPoint:", v4, v5);
  }

  return objc_msgSend(a3, "curveToPoint:controlPoint1:controlPoint2:", v10, v11, v6, v7, v8, v9);
}

double TSDCurveFitterPointOnCurve(uint64_t a1, double a2)
{
  return BezierII(3, a1, a2);
}

double BezierII(int a1, uint64_t a2, double a3)
{
  double v5 = (float64x2_t *)malloc_type_malloc((16 * a1 + 16), 0x522F83A0uLL);
  if ((a1 & 0x80000000) == 0)
  {
    uint64_t v6 = 0;
    do
    {
      v5[v6] = *(float64x2_t *)(a2 + v6 * 16);
      ++v6;
    }
    while (a1 + 1 != v6);
    if (a1 >= 1)
    {
      float64x2_t v7 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(1.0 - a3), 0);
      int v8 = 1;
      unsigned int v9 = a1;
      do
      {
        if (v8 <= a1)
        {
          float64x2_t v10 = *v5;
          uint64_t v11 = v9;
          double v12 = v5 + 1;
          do
          {
            float64x2_t v13 = *v12;
            v12[-1] = vmlaq_f64(vmulq_n_f64(*v12, a3), v10, v7);
            ++v12;
            float64x2_t v10 = v13;
            --v11;
          }
          while (v11);
        }
        --v9;
      }
      while (v8++ != a1);
    }
  }
  double v15 = v5->f64[0];
  free(v5);
  return v15;
}

double TSDCurvePointToCGPoint(double a1)
{
  return (float)a1;
}

void FitCubic(uint64_t a1, uint64_t a2, uint64_t a3, double ***a4, __n128 a5, __n128 a6, __n128 a7, __n128 a8, double a9)
{
  while (1)
  {
    unsigned int v9 = a4;
    __n128 v83 = a8;
    __n128 v84 = a7;
    uint64_t v10 = a3;
    uint64_t v11 = a1;
    uint64_t v93 = *MEMORY[0x263EF8340];
    uint64_t v12 = a3 - a2;
    __n128 v85 = a6;
    __n128 v86 = a5;
    if (a3 - a2 == 1) {
      break;
    }
    double v24 = a9;
    uint64_t size = 8 * v12 + 8;
    uint64_t v88 = a2;
    double v25 = (double *)malloc_type_malloc(size & 0x7FFFFFFF8, 0x100004000313F17uLL);
    uint64_t v26 = v25;
    *double v25 = 0.0;
    if (v10 > v88)
    {
      CGAffineTransform v27 = v25 + 1;
      double v28 = *v25;
      uint64_t v29 = (double *)(v11 + 16 * v88 + 16);
      uint64_t v30 = v12;
      do
      {
        double v28 = v28 + sqrt((v29[1] - *(v29 - 1)) * (v29[1] - *(v29 - 1)) + (*v29 - *(v29 - 2)) * (*v29 - *(v29 - 2)));
        *v27++ = v28;
        v29 += 2;
        --v30;
      }
      while (v30);
      CGAffineTransform v31 = v25 + 1;
      uint64_t v32 = v12;
      do
      {
        *CGAffineTransform v31 = *v31 / v25[v12];
        ++v31;
        --v32;
      }
      while (v32);
    }
    uint64_t v90 = 0;
    GenerateBezier(v11, v88, v10, v25, v9, v86.n128_f64[0], v85.n128_f64[0], v84.n128_f64[0], v83.n128_f64[0]);
    CGRect v34 = (float64x2_t *)v33;
    v35.n128_f64[0] = ComputeMaxError(v11, v88, v10, v33, (uint64_t)v26, &v90, (uint64_t)v9);
    if (v35.n128_f64[0] < v24)
    {
      DrawBezierCurve((uint64_t)v34, (uint64_t)v9, v35);
      double v36 = v26;
LABEL_36:
      free(v36);
      double v23 = v34;
      goto LABEL_37;
    }
    float64x2_t v80 = v9;
    if (v35.n128_f64[0] < v24 * v24)
    {
      int v37 = 0;
      __asm { FMOV            V0.2D, #3.0 }
      float64x2_t v87 = _Q0;
      while (1)
      {
        int v82 = v37;
        double v43 = (double *)malloc_type_malloc(size, 0x100004000313F17uLL);
        uint64_t v44 = v10;
        uint64_t v45 = v88;
        if (v10 >= v88)
        {
          uint64_t v46 = v88;
          do
          {
            uint64_t v47 = v11;
            float64x2_t v48 = (double *)(v11 + 16 * v46);
            uint64_t v49 = v46 - v45;
            double v50 = v26[v46 - v45];
            double v51 = *v48;
            double v52 = v48[1];
            double v53 = BezierII(3, (uint64_t)v34, v50);
            double v55 = v54;
            uint64_t v56 = 0;
            float64x2_t v57 = *v34;
            do
            {
              float64x2_t v58 = v34[v56 + 1];
              v92[v56++] = vmulq_f64(vsubq_f64(v58, v57), v87);
              float64x2_t v57 = v58;
            }
            while (v56 != 3);
            uint64_t v59 = 0;
            char v60 = 1;
            float64x2_t v61 = v92[0];
            do
            {
              char v62 = v60;
              float64x2_t v63 = v92[v59 + 1];
              float64x2_t v64 = vsubq_f64(v63, v61);
              v91[v59] = vaddq_f64(v64, v64);
              uint64_t v59 = 1;
              float64x2_t v61 = v63;
              char v60 = 0;
            }
            while ((v62 & 1) != 0);
            double v65 = BezierII(2, (uint64_t)v92, v50);
            double v67 = v66;
            double v68 = BezierII(1, (uint64_t)v91, v50);
            double v70 = v67 * v67 + v65 * v65 + (v53 - v51) * v68 + (v55 - v52) * v69;
            if (v70 != 0.0) {
              double v50 = v50 - ((v55 - v52) * v67 + (v53 - v51) * v65) / v70;
            }
            uint64_t v45 = v88;
            v43[v49] = v50;
            _ZF = v46++ == v44;
            uint64_t v11 = v47;
          }
          while (!_ZF);
        }
        uint64_t v71 = v45;
        free(v34);
        uint64_t v10 = v44;
        GenerateBezier(v11, v71, v44, v43, v80, v86.n128_f64[0], v85.n128_f64[0], v84.n128_f64[0], v83.n128_f64[0]);
        CGRect v34 = (float64x2_t *)v72;
        v73.n128_f64[0] = ComputeMaxError(v11, v71, v44, v72, (uint64_t)v43, &v90, (uint64_t)v80);
        if (v73.n128_f64[0] < v24) {
          break;
        }
        free(v26);
        int v37 = v82 + 1;
        uint64_t v26 = v43;
        if (v82 == 3) {
          goto LABEL_30;
        }
      }
      DrawBezierCurve((uint64_t)v34, (uint64_t)v80, v73);
      free(v26);
      double v36 = v43;
      goto LABEL_36;
    }
    double v43 = v26;
LABEL_30:
    free(v43);
    free(v34);
    uint64_t v74 = v90;
    __asm { FMOV            V1.2D, #0.5 }
    __n128 v76 = (__n128)vmulq_f64(vaddq_f64(vsubq_f64(*(float64x2_t *)(v11 + 16 * v90 - 16), *(float64x2_t *)(v11 + 16 * v90)), vsubq_f64(*(float64x2_t *)(v11 + 16 * v90), *(float64x2_t *)(v11 + 16 * v90 + 16))), _Q1);
    double v77 = sqrt(vmlad_n_f64(COERCE_DOUBLE(*(void *)&vmulq_f64(*(float64x2_t *)&v76, *(float64x2_t *)&v76).f64[1]), v76.n128_f64[0], v76.n128_f64[0]));
    if (v77 != 0.0) {
      __n128 v76 = (__n128)vdivq_f64((float64x2_t)v76, (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v77, 0));
    }
    uint64_t v78 = v88;
    double v79 = v76.n128_f64[1];
    __n128 v89 = v76;
    FitCubic(v11, v78, v90, v80, v86, v85, v76, v76.n128_f64[1], v24);
    a5.n128_u64[1] = v89.n128_u64[1];
    a5.n128_f64[0] = -v89.n128_f64[0];
    a6.n128_f64[0] = -v79;
    a1 = v11;
    a2 = v74;
    a3 = v10;
    a8 = v83;
    a7 = v84;
    a9 = v24;
    a4 = v80;
  }
  float64x2_t v13 = (double *)(a1 + 16 * a3);
  double v14 = (double *)(a1 + 16 * a2);
  double v15 = sqrt((v13[1] - v14[1]) * (v13[1] - v14[1]) + (*v13 - *v14) * (*v13 - *v14)) / 3.0;
  long long v16 = (float64x2_t *)malloc_type_malloc(0x40uLL, 0x1000040451B5BE8uLL);
  double v17 = v16;
  *long long v16 = *(float64x2_t *)v14;
  v16[3] = *(float64x2_t *)v13;
  *(void *)&v19.f64[0] = v86.n128_u64[0];
  double v18 = sqrt(v85.n128_f64[0] * v85.n128_f64[0] + v19.f64[0] * v19.f64[0]);
  *(void *)&v19.f64[1] = v85.n128_u64[0];
  if (v18 != 0.0) {
    float64x2_t v19 = vmulq_n_f64(v19, v15 / v18);
  }
  v16[1] = vaddq_f64(v19, *v16);
  *(void *)&v21.f64[0] = v84.n128_u64[0];
  double v20 = sqrt(v83.n128_f64[0] * v83.n128_f64[0] + v21.f64[0] * v21.f64[0]);
  *(void *)&v21.f64[1] = v83.n128_u64[0];
  if (v20 != 0.0) {
    float64x2_t v21 = vmulq_n_f64(v21, v15 / v20);
  }
  __n128 v22 = (__n128)vaddq_f64(v21, v16[3]);
  v16[2] = (float64x2_t)v22;
  DrawBezierCurve((uint64_t)v16, (uint64_t)v9, v22);
  double v23 = v17;
LABEL_37:

  free(v23);
}

uint64_t DrawBezierCurve(uint64_t a1, uint64_t a2, __n128 a3)
{
  a3.n128_u64[0] = *(void *)(a1 + 56);
  double v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, __n128))(a2 + 24);
  uint64_t v3 = *(void *)(a2 + 32);

  return v4(3, a1, v3, a3);
}

double GenerateBezier(uint64_t a1, uint64_t a2, uint64_t a3, double *a4, double ***a5, double a6, double a7, double a8, double a9)
{
  double v15 = *a5;
  long long v16 = (float64x2_t *)malloc_type_malloc(0x40uLL, 0x1000040451B5BE8uLL);
  double v17 = 0.0;
  double v18 = 0.0;
  double v19 = 0.0;
  double v20 = 0.0;
  double v21 = 0.0;
  if (a3 >= a2)
  {
    double v22 = sqrt(a7 * a7 + a6 * a6);
    uint64_t v23 = a3 - a2 + 1;
    uint64_t v24 = v23;
    double v25 = a4;
    uint64_t v26 = v15;
    double v27 = sqrt(a9 * a9 + a8 * a8);
    do
    {
      double v28 = 1.0 - *v25;
      double v29 = *v25 * 3.0;
      double v30 = a6;
      double v31 = a7;
      if (v22 != 0.0)
      {
        double v32 = v29 * (v28 * v28) / v22;
        double v30 = a6 * v32;
        double v31 = a7 * v32;
      }
      double v33 = a8;
      double v34 = a9;
      if (v27 != 0.0)
      {
        double v35 = v28 * (*v25 * v29) / v27;
        double v33 = a8 * v35;
        double v34 = a9 * v35;
      }
      double v36 = *v26++;
      *double v36 = v30;
      v36[1] = v31;
      v36[2] = v33;
      v36[3] = v34;
      ++v25;
      --v24;
    }
    while (v24);
    uint64_t v37 = a1 + 16 * a2;
    double v39 = *(double *)(v37 + 8);
    double v38 = (double *)(v37 + 8);
    double v40 = v39;
    double v41 = (double *)(a1 + 16 * a3);
    double v21 = 0.0;
    double v20 = 0.0;
    double v19 = 0.0;
    double v18 = 0.0;
    double v17 = 0.0;
    do
    {
      double v42 = *v15++;
      double v43 = *v42;
      double v44 = v42[1];
      double v45 = v42[2];
      double v46 = v42[3];
      double v47 = v44 * v46 + *v42 * v45;
      double v48 = *a4++;
      double v49 = 1.0 - v48;
      double v50 = v49 * (v49 * v49);
      double v51 = v48 * 3.0 * (v49 * v49);
      double v19 = v19 + v44 * v44 + v43 * v43;
      double v52 = (1.0 - v48) * (v48 * (v48 * 3.0));
      double v20 = v20 + v47;
      double v53 = v48 * (v48 * v48);
      double v21 = v21 + v46 * v46 + v45 * v45;
      double v54 = *(v38 - 1) - (*(double *)(a1 + 16 * a2) * v50 + *(double *)(a1 + 16 * a2) * v51 + *v41 * v52 + v53 * *v41);
      double v55 = *v38 - (v40 * v50 + v40 * v51 + v52 * v41[1] + v53 * v41[1]);
      double v17 = v17 + v44 * v55 + v43 * v54;
      double v18 = v18 + v46 * v55 + v45 * v54;
      v38 += 2;
      --v23;
    }
    while (v23);
  }
  double v56 = v19 * v21 - v20 * v20;
  double v57 = v17 * v21 - v18 * v20;
  double v58 = v19 * v21 * 1.0e-11;
  if (v56 == 0.0) {
    double v56 = v58;
  }
  if (v57 / v56 < 0.000001 || (double v59 = (v19 * v18 - v20 * v17) / v56, v59 < 0.000001))
  {
    float64x2_t v63 = (double *)(a1 + 16 * a3);
    float64x2_t v64 = (double *)(a1 + 16 * a2);
    double v65 = v63[1] - v64[1];
    double v59 = sqrt(v65 * v65 + (*v63 - *v64) * (*v63 - *v64)) / 3.0;
    *long long v16 = *(float64x2_t *)v64;
    v16[3] = *(float64x2_t *)v63;
    v61.f64[0] = a6;
    double v66 = sqrt(a7 * a7 + v61.f64[0] * v61.f64[0]);
    v61.f64[1] = a7;
    if (v66 == 0.0) {
      goto LABEL_19;
    }
    double v62 = v59 / v66;
  }
  else
  {
    *long long v16 = *(float64x2_t *)(a1 + 16 * a2);
    v16[3] = *(float64x2_t *)(a1 + 16 * a3);
    v61.f64[0] = a6;
    double v60 = sqrt(a7 * a7 + v61.f64[0] * v61.f64[0]);
    v61.f64[1] = a7;
    if (v60 == 0.0) {
      goto LABEL_19;
    }
    double v62 = v57 / v56 / v60;
  }
  float64x2_t v61 = vmulq_n_f64(v61, v62);
LABEL_19:
  v16[1] = vaddq_f64(v61, *v16);
  double v67 = sqrt(a9 * a9 + a8 * a8);
  if (v67 != 0.0)
  {
    double v68 = v59 / v67;
    a8 = a8 * v68;
    a9 = a9 * v68;
  }
  double result = a8 + v16[3].f64[0];
  double v70 = a9 + v16[3].f64[1];
  v16[2].f64[0] = result;
  v16[2].f64[1] = v70;
  return result;
}

double ComputeMaxError(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7)
{
  if (a3 - a2 + 1 >= 0) {
    uint64_t v7 = a3 - a2 + 1;
  }
  else {
    uint64_t v7 = a3 - a2 + 2;
  }
  *a6 = v7 >> 1;
  uint64_t v8 = a2 + 1;
  double v9 = 0.0;
  if (a2 + 1 < a3)
  {
    double v13 = *(double *)(a7 + 16);
    uint64_t v14 = a2;
    do
    {
      uint64_t v32 = v8;
      if (v13 <= 0.0)
      {
        double v21 = 0.0;
      }
      else
      {
        uint64_t v15 = v8 - a2;
        uint64_t v16 = v8 - a2 - 1;
        double v17 = (double *)(a1 + 16 * v8);
        double v18 = (double *)(a1 + 16 * v14);
        double v19 = 0.0;
        int v20 = 1;
        double v21 = 0.0;
        do
        {
          double v22 = 1.0 - v19 / v13;
          double v23 = *v18 + (*v17 - *v18) * v22;
          double v24 = v18[1] + (v17[1] - v18[1]) * v22;
          double v25 = BezierII(3, a4, *(double *)(a5 + 8 * v16) + (*(double *)(a5 + 8 * v15) - *(double *)(a5 + 8 * v16)) * v22);
          double v21 = v21 + (v26 - v24) * (v26 - v24) + (v25 - v23) * (v25 - v23);
          double v19 = (double)v20;
          double v13 = *(double *)(a7 + 16);
          ++v20;
        }
        while (v13 > v19);
      }
      if (v21 / v13 >= v9)
      {
        *a6 = v32;
        double v9 = v21 / v13;
      }
      uint64_t v8 = v32 + 1;
      uint64_t v14 = v32;
    }
    while (v32 + 1 != a3);
  }
  return v9;
}

void _SFRSetLineWidth(CGContextRef c, CGFloat a2)
{
  if (a2 == 0.0)
  {
    NSLog((NSString *)@"BOGUS - lineWidth is 0.");
    CGContextGetCTM(&v3, c);
    CGAffineTransformInvert(&v4, &v3);
    a2 = v4.a + v4.c;
  }
  CGContextSetLineWidth(c, a2);
}

void *pBuildBezierPath(void *result, uint64_t a2)
{
  CGAffineTransform v3 = result;
  switch(*(_DWORD *)a2)
  {
    case 0:
      CGAffineTransform v4 = *(double **)(a2 + 8);
      double v5 = *v4;
      double v6 = v4[1];
      double result = objc_msgSend(result, "moveToPoint:", v5, v6);
      break;
    case 1:
      goto LABEL_6;
    case 2:
      uint64_t v7 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v8 = objc_msgSend(NSString, "stringWithUTF8String:", "void pBuildBezierPath(void *, const CGPathElement *)");
      objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBezierPath.m"), 203, @"kCGPathElementAddQuadCurveToPoint not supported yet");
LABEL_6:
      double v9 = *(double **)(a2 + 8);
      double v10 = *v9;
      double v11 = v9[1];
      double result = objc_msgSend(v3, "lineToPoint:", v10, v11);
      break;
    case 3:
      uint64_t v12 = *(double **)(a2 + 8);
      double v13 = v12[4];
      double v14 = v12[5];
      double v15 = *v12;
      double v16 = v12[1];
      double v17 = v12[2];
      double v18 = v12[3];
      double result = objc_msgSend(result, "curveToPoint:controlPoint1:controlPoint2:", v13, v14, v15, v16, v17, v18);
      break;
    case 4:
      double result = (void *)[result closePath];
      break;
    default:
      return result;
  }
  return result;
}

void addifclose(uint64_t a1, float *a2)
{
  uint64_t v4 = 0;
  uint64_t v36 = *MEMORY[0x263EF8340];
  double v5 = *(double *)a1;
  double v6 = *(double *)(a1 + 8);
  float v7 = 0.0;
  double v8 = v6;
  double v9 = *(double *)a1;
  do
  {
    double v10 = *(double *)(a1 + v4 + 16);
    double v11 = *(double *)(a1 + v4 + 24);
    float v7 = TSDDistance(v9, v8, v10, v11) + v7;
    v4 += 16;
    double v8 = v11;
    double v9 = v10;
  }
  while (v4 != 48);
  float v12 = TSDDistance(v5, v6, *(double *)(a1 + 48), *(double *)(a1 + 56));
  if ((float)(v7 - v12) <= 0.1)
  {
    *a2 = *a2 + v7;
  }
  else
  {
    long long v13 = *(_OWORD *)(a1 + 16);
    v35[0] = *(_OWORD *)a1;
    v35[1] = v13;
    long long v14 = *(_OWORD *)(a1 + 48);
    v35[2] = *(_OWORD *)(a1 + 32);
    v35[3] = v14;
    uint64_t v15 = 3;
    uint64_t v16 = 1;
    __asm { FMOV            V0.2D, #0.5 }
    double v22 = v35;
    do
    {
      uint64_t v23 = 0;
      float64x2_t v24 = (float64x2_t)v35[4 * v16 - 4];
      do
      {
        double v25 = (float64x2_t *)&v22[v23];
        float64x2_t v26 = v25[1];
        v25[4] = vmlaq_f64(vmulq_f64(v26, _Q0), _Q0, v24);
        ++v23;
        float64x2_t v24 = v26;
      }
      while (v15 != v23);
      ++v16;
      --v15;
      v22 += 4;
    }
    while (v16 != 4);
    uint64_t v27 = 0;
    double v28 = v35;
    do
    {
      long long v29 = *v28;
      v28 += 4;
      *(_OWORD *)&v34[v27] = v29;
      v27 += 16;
    }
    while (v27 != 64);
    double v30 = v33;
    uint64_t v31 = 3;
    uint64_t v32 = 12;
    do
    {
      *v30++ = v35[v32];
      --v31;
      v32 -= 3;
    }
    while (v31 != -1);
    addifclose(v34, a2);
    addifclose(v33, a2);
  }
}

double p_getMaxMinTailSize(double *a1, double *a2, double *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  double v18 = TSDSubtractPoints(a4, a5, a8);
  double v20 = TSDDotPoints(a6, a7, v18, v19);
  double v21 = TSDDistanceToPointFromLine(a1, a4, a5) * a10 / v20;
  *a2 = fmax(*a2, v21);
  double result = fmin(*a3, v21);
  *a3 = result;
  return result;
}

void TSDEllipseParametricAngleWithPolarAngle(double a1, double a2, double a3)
{
  if (a2 != 0.0 && a3 != 0.0)
  {
    double v5 = a1;
    for (i = 0.0; v5 >= 360.0; double v5 = v5 + -360.0)
      double i = i + 1.0;
    for (; v5 < 0.0; double v5 = v5 + 360.0)
      double i = i + -1.0;
    if (v5 < 0.0 || v5 >= 360.0)
    {
      float v7 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v8 = objc_msgSend(NSString, "stringWithUTF8String:", "CGFloat TSDEllipseParametricAngleWithPolarAngle(CGFloat, CGFloat, CGFloat)");
      objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBezierPathAdditions.mm"), 714, @"Angle out of range");
    }
    if (v5 / 90.0 - floor(v5 / 90.0) >= 0.01 && ceil(v5 / 90.0) - v5 / 90.0 >= 0.01)
    {
      __double2 v9 = __sincos_stret(v5 * 3.14159265 / 180.0);
      for (double j = atan2(v9.__sinval / a3, v9.__cosval / a2) * 180.0 / 3.14159265; j < 0.0; double j = j + 360.0)
        ;
      for (; j >= 360.0; double j = j + -360.0)
        ;
      if (j < 0.0 || j >= 360.0)
      {
        double v11 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v12 = objc_msgSend(NSString, "stringWithUTF8String:", "CGFloat TSDEllipseParametricAngleWithPolarAngle(CGFloat, CGFloat, CGFloat)");
        objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBezierPathAdditions.mm"), 736, @"Angle out of range");
      }
    }
  }
}

double TSDEllipsePolarAngleWithParametricAngle(double a1, double a2, double a3)
{
  if (a2 == 0.0 || a3 == 0.0) {
    return 0.0;
  }
  TSDEllipseParametricAngleWithPolarAngle(a1, 1.0 / a2, 1.0 / a3);
  return result;
}

BOOL triangleIsClockwise(CGPoint a1, CGPoint a2, CGPoint a3)
{
  float v3 = a1.x * a2.y - a1.y * a2.x + 0.0;
  float v4 = a2.x * a3.y - a2.y * a3.x + v3;
  float v5 = a3.x * a1.y - a3.y * a1.x + v4;
  return v5 >= 0.0;
}

void sub_22360C874(_Unwind_Exception *a1)
{
  MEMORY[0x223CB8F20](v1, 0x1030C402473FF45);
  _Unwind_Resume(a1);
}

void sub_22360CA8C(_Unwind_Exception *a1)
{
  MEMORY[0x223CB8F20](v1, 0x1030C4099B07130);
  _Unwind_Resume(a1);
}

void sub_22360CF50(_Unwind_Exception *a1)
{
  MEMORY[0x223CB8F20](v1, 0x1030C4099B07130);
  _Unwind_Resume(a1);
}

void sub_22360D7F0(_Unwind_Exception *a1)
{
  MEMORY[0x223CB8F20](v1, 0x1030C4099B07130);
  _Unwind_Resume(a1);
}

int *polygonFromBezier(void *a1)
{
  uint64_t v1 = a1;
  uint64_t v18 = *MEMORY[0x263EF8340];
  if (([a1 isFlat] & 1) == 0) {
    uint64_t v1 = (void *)[v1 bezierPathByFlatteningPath];
  }
  size_t v2 = [v1 elementCount];
  if (v2 == (int)v2)
  {
    float v3 = (int *)malloc_type_calloc(1uLL, 0x18uLL, 0x1030040B05087B7uLL);
    if (v3 && v2)
    {
      LODWORD(v15) = v2;
      uint64_t v16 = malloc_type_calloc(0x10uLL, v2, 0x2D833B6EuLL);
      if ((int)v2 >= 1)
      {
        uint64_t v4 = 0;
        int v5 = 0;
        double v6 = INFINITY;
        double v7 = INFINITY;
        while (2)
        {
          switch(objc_msgSend(v1, "elementAtIndex:associatedPoints:", v4, v17, v15))
          {
            case 0:
              if (v5 >= 2)
              {
                LODWORD(v15) = v5;
                TSDgpc_add_contour(v3, (int *)&v15, 0);
                int v5 = 0;
              }
              *((_OWORD *)v16 + v5) = *(_OWORD *)v17;
              uint64_t v8 = *(void *)&v17[1];
              uint64_t v9 = *(void *)&v17[0];
              goto LABEL_17;
            case 1:
              uint64_t v8 = *(void *)&v17[1];
              uint64_t v9 = *(void *)&v17[0];
              if (vabdd_f64(v17[0], v6) <= 0.699999988 && vabdd_f64(v17[1], v7) <= 0.699999988)
              {
                int v11 = v5 - 1;
                uint64_t v8 = *(void *)&v7;
                uint64_t v9 = *(void *)&v6;
              }
              else
              {
                double v10 = (char *)v16 + 16 * v5;
                *double v10 = *(void *)&v17[0];
                v10[1] = v8;
LABEL_17:
                int v11 = v5;
              }
LABEL_20:
              ++v4;
              int v5 = v11 + 1;
              double v6 = *(double *)&v9;
              double v7 = *(double *)&v8;
              if (v2 != v4) {
                continue;
              }
              if (v11 >= 1)
              {
                LODWORD(v15) = v11 + 1;
                TSDgpc_add_contour(v3, (int *)&v15, 0);
              }
              break;
            case 2:
              NSLog((NSString *)@"Warning: Path should be flat. Illegal NSCurveToBezierPathElement.");
              goto LABEL_16;
            case 3:
              LODWORD(v15) = v5;
              TSDgpc_add_contour(v3, (int *)&v15, 0);
              int v11 = -1;
              uint64_t v8 = 0x7FF0000000000000;
              uint64_t v9 = 0x7FF0000000000000;
              goto LABEL_20;
            default:
LABEL_16:
              uint64_t v8 = *(void *)&v7;
              uint64_t v9 = *(void *)&v6;
              goto LABEL_17;
          }
          break;
        }
      }
      free(v16);
    }
  }
  else
  {
    long long v13 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v14 = [NSString stringWithUTF8String:"gpc_polygon *polygonFromBezier(TSDBezierPath *)"];
    objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBezierPathAdditions.mm"), 2545, @"Out-of-bounds type assignment failed");
    return 0;
  }
  return v3;
}

id bezierFromPolygon(int *a1)
{
  id v2 = +[TSDBezierPath bezierPath];
  if (*a1 >= 1)
  {
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    do
    {
      int v5 = (double **)(*((void *)a1 + 2) + v3);
      boundsForVertexList((uint64_t)v5);
      if (v7 > 0.00999999978 && v6 > 0.00999999978) {
        addVertexListToPath(v5, v2);
      }
      ++v4;
      v3 += 16;
    }
    while (v4 < *a1);
  }
  return v2;
}

double boundsForVertexList(uint64_t a1)
{
  if (!a1)
  {
    id v2 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v3 = [NSString stringWithUTF8String:"CGRect boundsForVertexList(gpc_vertex_list *)"];
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBezierPathAdditions.mm"), 2647, @"Bad list ptr");
  }
  int v4 = *(_DWORD *)a1;
  if (*(int *)a1 < 1)
  {
    int v5 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v6 = [NSString stringWithUTF8String:"CGRect boundsForVertexList(gpc_vertex_list *)"];
    objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBezierPathAdditions.mm"), 2648, @"Bad vertex count");
    int v4 = *(_DWORD *)a1;
  }
  double v7 = *(double **)(a1 + 8);
  float v8 = *v7;
  float v9 = v7[1];
  if (v4 <= 1)
  {
    return (float)*v7;
  }
  else
  {
    uint64_t v10 = v4;
    int v11 = v7 + 3;
    uint64_t v12 = v10 - 1;
    float v13 = v9;
    float v14 = v8;
    do
    {
      double v15 = *(v11 - 1);
      if (v15 <= v14) {
        float v14 = v15;
      }
      if (v15 >= v8) {
        float v8 = v15;
      }
      double v16 = *v11;
      v11 += 2;
      double v17 = v16;
      float v18 = v16;
      if (v16 <= v13) {
        float v13 = v18;
      }
      if (v17 >= v9) {
        float v9 = v18;
      }
      --v12;
    }
    while (v12);
  }
  return v14;
}

uint64_t addVertexListToPath(double **a1, void *a2)
{
  objc_msgSend(a2, "moveToPoint:", *a1[1], a1[1][1]);
  if (*(int *)a1 >= 2)
  {
    uint64_t v4 = 0;
    uint64_t v5 = 1;
    do
    {
      objc_msgSend(a2, "lineToPoint:", a1[1][v4 + 2], a1[1][v4 + 3]);
      ++v5;
      v4 += 2;
    }
    while (v5 < *(int *)a1);
  }

  return [a2 closePath];
}

int *copyPolygon(int *a1)
{
  id v2 = (int *)malloc_type_calloc(1uLL, 0x18uLL, 0x1030040B05087B7uLL);
  if (*a1 >= 1)
  {
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    do
    {
      TSDgpc_add_contour(v2, (int *)(*((void *)a1 + 2) + v3), *(_DWORD *)(*((void *)a1 + 1) + 4 * v4++));
      v3 += 16;
    }
    while (v4 < *a1);
  }
  return v2;
}

int *validatePolygon(int *result, double a2)
{
  id v2 = result;
  if (*result <= 0)
  {
    uint64_t v3 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v4 = [NSString stringWithUTF8String:"void validatePolygon(gpc_polygon *)"];
    double result = (int *)objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBezierPathAdditions.mm"), 2678, @"Bad contour count");
  }
  if (!*((void *)v2 + 1))
  {
    uint64_t v5 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v6 = [NSString stringWithUTF8String:"void validatePolygon(gpc_polygon *)"];
    double result = (int *)objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBezierPathAdditions.mm"), 2679, @"Missing hole");
  }
  if (!*((void *)v2 + 2))
  {
    double v7 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v8 = [NSString stringWithUTF8String:"void validatePolygon(gpc_polygon *)"];
    double result = (int *)objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBezierPathAdditions.mm"), 2680, @"Bad contour ptr");
  }
  if (*v2 >= 1)
  {
    uint64_t v9 = 0;
    do
    {
      uint64_t v10 = (int *)(*((void *)v2 + 2) + 16 * v9);
      if (*v10 <= 0)
      {
        int v11 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v12 = [NSString stringWithUTF8String:"void validatePolygon(gpc_polygon *)"];
        double result = (int *)objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBezierPathAdditions.mm"), 2685, @"Bad vertex count");
      }
      if (!*((void *)v10 + 1))
      {
        float v13 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v14 = [NSString stringWithUTF8String:"void validatePolygon(gpc_polygon *)"];
        double result = (int *)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBezierPathAdditions.mm"), 2686, @"Bad vertex list");
      }
      if (*v10 >= 1)
      {
        uint64_t v15 = 0;
        uint64_t v16 = 0;
        do
        {
          a2 = *(double *)(*((void *)v10 + 1) + v15 + 8);
          ++v16;
          v15 += 16;
        }
        while (v16 < *v10);
      }
      if (*(_DWORD *)(*((void *)v2 + 1) + 4 * v9) >= 2u)
      {
        double v17 = objc_msgSend(MEMORY[0x263F7C7F0], "currentHandler", a2);
        uint64_t v18 = [NSString stringWithUTF8String:"void validatePolygon(gpc_polygon *)"];
        double result = (int *)objc_msgSend(v17, "handleFailureInFunction:file:lineNumber:description:", v18, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBezierPathAdditions.mm"), 2693, @"Bad flags");
      }
      ++v9;
    }
    while (v9 < *v2);
  }
  return result;
}

void *gpc_malloc(size_t a1)
{
  pthread_once(&gpc_malloc_once, (void (*)(void))initialize_blocks);
  pthread_mutex_lock(&gpc_malloc_lock);
  if (a1 <= 0x20 && first_free_block)
  {
    id v2 = (void *)(first_free_block + 8);
    first_free_block = *(void *)first_free_block;
    pthread_mutex_unlock(&gpc_malloc_lock);
  }
  else
  {
    id v2 = malloc_type_malloc(a1, 0x8E34E3BuLL);
    pthread_mutex_unlock(&gpc_malloc_lock);
    if (!v2) {
      NSLog((NSString *)@"gpc_malloc allocation failure");
    }
  }
  return v2;
}

uint64_t initialize_blocks()
{
  uint64_t result = pthread_mutex_init(&gpc_malloc_lock, 0);
  if (!blocks)
  {
    uint64_t result = (uint64_t)malloc_type_malloc(0x28000uLL, 0x102004065753CD5uLL);
    uint64_t v1 = 0;
    blocks = result;
    first_free_block = result;
    do
    {
      *(void *)(result + v1) = result + v1 + 40;
      v1 += 40;
    }
    while (v1 != 163840);
    *(void *)(result + 163800) = 0;
  }
  return result;
}

void gpc_free(void *a1)
{
  if (a1)
  {
    if (blocks <= (unint64_t)a1 && blocks + 163840 > (unint64_t)a1)
    {
      pthread_mutex_lock(&gpc_malloc_lock);
      *(a1 - 1) = first_free_block;
      first_free_block = (uint64_t)(a1 - 1);
      pthread_mutex_unlock(&gpc_malloc_lock);
    }
    else
    {
      free(a1);
    }
  }
}

void AVLTree::AVLTree(AVLTree *this)
{
  DblLinked::DblLinked(this);
  *(void *)(v1 + 16) = 0;
  *(void *)(v1 + 24) = 0;
  *(_DWORD *)(v1 + 40) = 0;
  *(void *)(v1 + 32) = 0;
}

{
  uint64_t v1;

  DblLinked::DblLinked(this);
  *(void *)(v1 + 16) = 0;
  *(void *)(v1 + 24) = 0;
  *(_DWORD *)(v1 + 40) = 0;
  *(void *)(v1 + 32) = 0;
}

void *AVLTree::MakeNew(AVLTree *this)
{
  uint64_t result = DblLinked::MakeNew(this);
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 10) = 0;
  *((void *)this + 4) = 0;
  return result;
}

AVLTree *AVLTree::Leftmost(AVLTree *this)
{
  do
  {
    uint64_t v1 = this;
    this = (AVLTree *)*((void *)this + 3);
  }
  while (this);
  return v1;
}

AVLTree *AVLTree::LeftLeaf(AVLTree *this, AVLTree *a2, char a3)
{
  do
  {
    while (1)
    {
      while (1)
      {
        uint64_t result = this;
        if ((a3 & 1) == 0) {
          break;
        }
        this = (AVLTree *)*((void *)this + 3);
        a3 = 1;
        a2 = result;
        if (!this) {
          return result;
        }
      }
      this = (AVLTree *)*((void *)this + 3);
      if (*((AVLTree **)result + 4) != a2) {
        break;
      }
      a3 = 1;
      a2 = result;
      if (!this) {
        goto LABEL_6;
      }
    }
    if (this != a2) {
      return 0;
    }
LABEL_6:
    a3 = 0;
    this = (AVLTree *)*((void *)result + 2);
    a2 = result;
  }
  while (this);
  return 0;
}

AVLTree *AVLTree::RightLeaf(AVLTree **this, AVLTree *a2, char a3)
{
  do
  {
    while (1)
    {
      while (1)
      {
        uint64_t result = (AVLTree *)this;
        if ((a3 & 1) == 0) {
          break;
        }
        this = (AVLTree **)this[4];
        a3 = 1;
        a2 = result;
        if (!this) {
          return result;
        }
      }
      uint64_t v5 = this[3];
      this = (AVLTree **)this[4];
      if (v5 != a2) {
        break;
      }
      a3 = 1;
      a2 = result;
      if (!this) {
        goto LABEL_6;
      }
    }
    if (this != (AVLTree **)a2) {
      return 0;
    }
LABEL_6:
    a3 = 0;
    this = (AVLTree **)*((void *)result + 2);
    a2 = result;
  }
  while (this);
  return 0;
}

uint64_t AVLTree::RestoreBalances(uint64_t this, AVLTree *a2, AVLTree **a3)
{
  while (1)
  {
    uint64_t v3 = (AVLTree *)this;
    if (a2) {
      break;
    }
LABEL_7:
    this = *(void *)(this + 16);
    a2 = v3;
    if (!this) {
      return this;
    }
  }
  int v4 = *(_DWORD *)(this + 40);
  if (!v4)
  {
    if (*(AVLTree **)(this + 24) == a2) {
      *(_DWORD *)(this + 40) = 1;
    }
    if (*(AVLTree **)(this + 32) == a2) {
      *(_DWORD *)(this + 40) = -1;
    }
    goto LABEL_7;
  }
  if (v4 < 1)
  {
    uint64_t v10 = *(AVLTree **)(this + 24);
    if (v10 != a2)
    {
      uint64_t v6 = *(void *)(this + 32);
      if (v6)
      {
        uint64_t v11 = *(void *)(v6 + 24);
        uint64_t v12 = *(void *)(v6 + 32);
        uint64_t v13 = *(void *)(this + 16);
        if ((*(_DWORD *)(v6 + 40) & 0x80000000) != 0)
        {
          *(void *)(v6 + 24) = this;
          *(void *)(this + 16) = v6;
          *(void *)(this + 24) = v10;
          if (v10) {
            *((void *)v10 + 2) = this;
          }
          *(void *)(this + 32) = v11;
          if (v11) {
            *(void *)(v11 + 16) = this;
          }
          *(void *)(v6 + 32) = v12;
          if (v12) {
            *(void *)(v12 + 16) = v6;
          }
          *(void *)(v6 + 16) = v13;
          if (v13)
          {
            if (*(void *)(v13 + 24) == this) {
              *(void *)(v13 + 24) = v6;
            }
            if (*(void *)(v13 + 32) == this) {
              *(void *)(v13 + 32) = v6;
            }
          }
LABEL_78:
          if (*a3 == (AVLTree *)this) {
            *a3 = (AVLTree *)v6;
          }
          goto LABEL_80;
        }
        if (v11)
        {
          uint64_t v15 = *(void *)(v11 + 24);
          uint64_t v14 = *(void *)(v11 + 32);
          *(void *)(this + 16) = v11;
          *(void *)(v6 + 16) = v11;
          *(void *)(v11 + 24) = this;
          *(void *)(v11 + 32) = v6;
          *(void *)(this + 32) = v15;
          if (v15) {
            *(void *)(v15 + 16) = this;
          }
          *(void *)(this + 24) = v10;
          if (v10) {
            *((void *)v10 + 2) = this;
          }
          *(void *)(v6 + 32) = v12;
          if (v12) {
            *(void *)(v12 + 16) = v6;
          }
          *(void *)(v6 + 24) = v14;
          if (v14) {
            *(void *)(v14 + 16) = v6;
          }
          *(void *)(v11 + 16) = v13;
          if (v13)
          {
            if (*(void *)(v13 + 24) == this) {
              *(void *)(v13 + 24) = v11;
            }
            if (*(void *)(v13 + 32) == this) {
              *(void *)(v13 + 32) = v11;
            }
          }
          if (*a3 == (AVLTree *)this) {
            *a3 = (AVLTree *)v11;
          }
          int v16 = *(_DWORD *)(v11 + 40);
          *(_DWORD *)(v11 + 40) = 0;
          if (v16)
          {
            if (v16 >= 1)
            {
              this = 0;
              *((_DWORD *)v3 + 10) = 0;
              int v17 = -1;
              goto LABEL_85;
            }
            this = 0;
            int v22 = 1;
LABEL_83:
            *((_DWORD *)v3 + 10) = v22;
            goto LABEL_81;
          }
LABEL_80:
          this = 0;
          *((_DWORD *)v3 + 10) = 0;
LABEL_81:
          *(_DWORD *)(v6 + 40) = 0;
          return this;
        }
      }
      return 1;
    }
LABEL_46:
    this = 0;
    *((_DWORD *)v3 + 10) = 0;
    return this;
  }
  uint64_t v5 = *(AVLTree **)(this + 32);
  if (v5 == a2) {
    goto LABEL_46;
  }
  uint64_t v6 = *(void *)(this + 24);
  if (!v6) {
    return 1;
  }
  uint64_t v8 = *(void *)(v6 + 24);
  uint64_t v7 = *(void *)(v6 + 32);
  if (*(int *)(v6 + 40) >= 1)
  {
    uint64_t v9 = *(void *)(this + 16);
    *(void *)(this + 16) = v6;
    *(void *)(v6 + 32) = this;
    *(void *)(this + 32) = v5;
    if (v5) {
      *((void *)v5 + 2) = this;
    }
    *(void *)(this + 24) = v7;
    if (v7) {
      *(void *)(v7 + 16) = this;
    }
    *(void *)(v6 + 24) = v8;
    if (v8) {
      *(void *)(v8 + 16) = v6;
    }
    *(void *)(v6 + 16) = v9;
    if (v9)
    {
      if (*(void *)(v9 + 24) == this) {
        *(void *)(v9 + 24) = v6;
      }
      if (*(void *)(v9 + 32) == this) {
        *(void *)(v9 + 32) = v6;
      }
    }
    goto LABEL_78;
  }
  if (!v7) {
    return 1;
  }
  uint64_t v18 = *(void *)(v7 + 24);
  uint64_t v19 = *(void *)(v7 + 32);
  uint64_t v20 = *(void *)(this + 16);
  *(void *)(v7 + 24) = v6;
  *(void *)(v7 + 32) = this;
  *(void *)(this + 16) = v7;
  *(void *)(v6 + 16) = v7;
  *(void *)(this + 24) = v19;
  if (v19) {
    *(void *)(v19 + 16) = this;
  }
  *(void *)(this + 32) = v5;
  if (v5) {
    *((void *)v5 + 2) = this;
  }
  *(void *)(v6 + 24) = v8;
  if (v8) {
    *(void *)(v8 + 16) = v6;
  }
  *(void *)(v6 + 32) = v18;
  if (v18) {
    *(void *)(v18 + 16) = v6;
  }
  *(void *)(v7 + 16) = v20;
  if (v20)
  {
    if (*(void *)(v20 + 24) == this) {
      *(void *)(v20 + 24) = v7;
    }
    if (*(void *)(v20 + 32) == this) {
      *(void *)(v20 + 32) = v7;
    }
  }
  if (*a3 == (AVLTree *)this) {
    *a3 = (AVLTree *)v7;
  }
  int v21 = *(_DWORD *)(v7 + 40);
  *(_DWORD *)(v7 + 40) = 0;
  if (!v21) {
    goto LABEL_80;
  }
  if (v21 >= 1)
  {
    this = 0;
    int v22 = -1;
    goto LABEL_83;
  }
  this = 0;
  *((_DWORD *)v3 + 10) = 0;
  int v17 = 1;
LABEL_85:
  *(_DWORD *)(v6 + 40) = v17;
  return this;
}

uint64_t AVLTree::RestoreBalances(uint64_t this, int a2, AVLTree **a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v3 = this;
      int v4 = *(_DWORD *)(this + 40);
      if (v4 < 1) {
        break;
      }
      if (a2 < 0)
      {
LABEL_26:
        *(_DWORD *)(this + 40) = 0;
        this = *(void *)(this + 16);
        if (!this) {
          return this;
        }
        a2 = 1;
        if (*(void *)(this + 32) != v3)
        {
          uint64_t v5 = *(void *)(this + 24);
          goto LABEL_29;
        }
      }
      else
      {
        if (!a2) {
          return 0;
        }
        uint64_t v5 = *(void *)(this + 24);
        if (!v5) {
          return 1;
        }
        this = *(void *)(this + 16);
        uint64_t v6 = *(void *)(v3 + 32);
        uint64_t v8 = *(void *)(v5 + 24);
        uint64_t v7 = *(void *)(v5 + 32);
        int v9 = *(_DWORD *)(v5 + 40);
        if (v9 < 1)
        {
          if (!v9)
          {
            *(void *)(v5 + 32) = v3;
            *(void *)(v3 + 24) = v7;
            *(void *)(v3 + 32) = v6;
            *(void *)(v3 + 16) = v5;
            if (v8) {
              *(void *)(v8 + 16) = v5;
            }
            if (v6) {
              *(void *)(v6 + 16) = v3;
            }
            if (v7) {
              *(void *)(v7 + 16) = v3;
            }
            *(void *)(v5 + 16) = this;
            if (this)
            {
              if (*(void *)(this + 24) == v3) {
                *(void *)(this + 24) = v5;
              }
              if (*(void *)(this + 32) == v3) {
                *(void *)(this + 32) = v5;
              }
            }
            if (*a3 == (AVLTree *)v3) {
              *a3 = (AVLTree *)v5;
            }
            *(_DWORD *)(v5 + 40) = -1;
LABEL_97:
            int v19 = 1;
            goto LABEL_113;
          }
          if (!v7) {
            return 1;
          }
          uint64_t v10 = *(void *)(v7 + 24);
          uint64_t v11 = *(void *)(v7 + 32);
          *(void *)(v7 + 24) = v5;
          *(void *)(v7 + 32) = v3;
          *(void *)(v3 + 24) = v11;
          *(void *)(v3 + 32) = v6;
          *(void *)(v5 + 24) = v8;
          *(void *)(v5 + 32) = v10;
          if (v6) {
            *(void *)(v6 + 16) = v3;
          }
          if (v11) {
            *(void *)(v11 + 16) = v3;
          }
          if (v8) {
            *(void *)(v8 + 16) = v5;
          }
          if (v10) {
            *(void *)(v10 + 16) = v5;
          }
          *(void *)(v3 + 16) = v7;
          *(void *)(v5 + 16) = v7;
          *(void *)(v7 + 16) = this;
          if (this)
          {
            if (*(void *)(this + 24) == v3) {
              *(void *)(this + 24) = v7;
            }
            if (*(void *)(this + 32) == v3) {
              *(void *)(this + 32) = v7;
            }
          }
          if (*a3 == (AVLTree *)v3) {
            *a3 = (AVLTree *)v7;
          }
          int v12 = *(_DWORD *)(v7 + 40);
          *(_DWORD *)(v7 + 40) = 0;
          if (v12 < 1)
          {
            int v13 = v12 != 0;
            *(_DWORD *)(v3 + 40) = 0;
          }
          else
          {
            int v13 = 0;
            *(_DWORD *)(v3 + 40) = -1;
          }
          goto LABEL_75;
        }
        *(void *)(v5 + 32) = v3;
        *(void *)(v3 + 24) = v7;
        *(void *)(v3 + 32) = v6;
LABEL_7:
        *(void *)(v3 + 16) = v5;
        if (v8) {
          *(void *)(v8 + 16) = v5;
        }
        if (v6) {
          *(void *)(v6 + 16) = v3;
        }
        if (v7) {
          *(void *)(v7 + 16) = v3;
        }
        *(void *)(v5 + 16) = this;
        if (this)
        {
          if (*(void *)(this + 24) == v3) {
            *(void *)(this + 24) = v5;
          }
          if (*(void *)(this + 32) == v3) {
            *(void *)(this + 32) = v5;
          }
        }
        if (*a3 == (AVLTree *)v3) {
          *a3 = (AVLTree *)v5;
        }
        *(_DWORD *)(v5 + 40) = 0;
        *(_DWORD *)(v3 + 40) = 0;
        if (!this) {
          return this;
        }
        a2 = 1;
        if (v5 != *(void *)(this + 32))
        {
          uint64_t v3 = *(void *)(this + 24);
LABEL_29:
          a2 = -1;
          if (v5 != v3) {
            return 0;
          }
        }
      }
    }
    if (!v4) {
      break;
    }
    if ((a2 & 0x80000000) == 0)
    {
      if (!a2) {
        return 0;
      }
      goto LABEL_26;
    }
    uint64_t v5 = *(void *)(this + 32);
    if (!v5) {
      return 1;
    }
    this = *(void *)(this + 16);
    uint64_t v6 = *(void *)(v3 + 24);
    uint64_t v7 = *(void *)(v5 + 24);
    uint64_t v8 = *(void *)(v5 + 32);
    int v14 = *(_DWORD *)(v5 + 40);
    if (v14 < 0)
    {
      *(void *)(v5 + 24) = v3;
      *(void *)(v3 + 24) = v6;
      *(void *)(v3 + 32) = v7;
      goto LABEL_7;
    }
    if (!v14)
    {
      *(void *)(v5 + 24) = v3;
      *(void *)(v3 + 24) = v6;
      *(void *)(v3 + 32) = v7;
      *(void *)(v3 + 16) = v5;
      if (v8) {
        *(void *)(v8 + 16) = v5;
      }
      if (v6) {
        *(void *)(v6 + 16) = v3;
      }
      if (v7) {
        *(void *)(v7 + 16) = v3;
      }
      *(void *)(v5 + 16) = this;
      if (this)
      {
        if (*(void *)(this + 24) == v3) {
          *(void *)(this + 24) = v5;
        }
        if (*(void *)(this + 32) == v3) {
          *(void *)(this + 32) = v5;
        }
      }
      if (*a3 == (AVLTree *)v3) {
        *a3 = (AVLTree *)v5;
      }
      *(_DWORD *)(v5 + 40) = 1;
      goto LABEL_112;
    }
    if (!v7) {
      return 1;
    }
    uint64_t v16 = *(void *)(v7 + 24);
    uint64_t v15 = *(void *)(v7 + 32);
    *(void *)(v7 + 24) = v3;
    *(void *)(v7 + 32) = v5;
    *(void *)(v3 + 24) = v6;
    *(void *)(v3 + 32) = v16;
    *(void *)(v5 + 24) = v15;
    *(void *)(v5 + 32) = v8;
    if (v6) {
      *(void *)(v6 + 16) = v3;
    }
    if (v16) {
      *(void *)(v16 + 16) = v3;
    }
    if (v8) {
      *(void *)(v8 + 16) = v5;
    }
    if (v15) {
      *(void *)(v15 + 16) = v5;
    }
    *(void *)(v3 + 16) = v7;
    *(void *)(v5 + 16) = v7;
    *(void *)(v7 + 16) = this;
    if (this)
    {
      if (*(void *)(this + 24) == v3) {
        *(void *)(this + 24) = v7;
      }
      if (*(void *)(this + 32) == v3) {
        *(void *)(this + 32) = v7;
      }
    }
    if (*a3 == (AVLTree *)v3) {
      *a3 = (AVLTree *)v7;
    }
    int v17 = *(_DWORD *)(v7 + 40);
    *(_DWORD *)(v7 + 40) = 0;
    unsigned int v18 = v17 >> 31;
    if (v17 <= 0) {
      int v13 = 0;
    }
    else {
      int v13 = -1;
    }
    *(_DWORD *)(v3 + 40) = v18;
LABEL_75:
    *(_DWORD *)(v5 + 40) = v13;
    if (!this) {
      return this;
    }
    a2 = 1;
    if (v7 != *(void *)(this + 32))
    {
      a2 = -1;
      if (v7 != *(void *)(this + 24)) {
        return 0;
      }
    }
  }
  if ((a2 & 0x80000000) == 0)
  {
    if (!a2) {
      return 0;
    }
    goto LABEL_97;
  }
LABEL_112:
  int v19 = -1;
LABEL_113:
  this = 0;
  *(_DWORD *)(v3 + 40) = v19;
  return this;
}

uint64_t AVLTree::Remove(AVLTree *this, AVLTree **a2, int a3)
{
  int v9 = 0;
  int v8 = 0;
  uint64_t result = AVLTree::Remove(this, a2, &v9, &v8);
  if (!result && a3 && v9)
  {
    int v6 = v8;
    uint64_t v7 = v9;
    return AVLTree::RestoreBalances((uint64_t)v7, v6, a2);
  }
  return result;
}

uint64_t AVLTree::Remove(AVLTree *this, AVLTree **a2, AVLTree **a3, int *a4)
{
  DblLinked::Extract((uint64_t *)this);
  int v9 = (AVLTree *)*((void *)this + 3);
  uint64_t v8 = *((void *)this + 4);
  if (v9)
  {
    if (v8)
    {
      uint64_t v10 = *((void *)this + 3);
      do
      {
        uint64_t v11 = v10;
        uint64_t v10 = *(void *)(v10 + 32);
      }
      while (v10);
      if ((AVLTree *)v11 == v9)
      {
        *a3 = v9;
        *a4 = -1;
        *(void *)(v11 + 32) = *((void *)this + 4);
        *(void *)(*((void *)this + 4) + 16) = v9;
        *((void *)v9 + 2) = *((void *)this + 2);
        uint64_t v22 = *((void *)this + 2);
        if (v22)
        {
          if (*(AVLTree **)(v22 + 24) == this) {
            *(void *)(v22 + 24) = v9;
          }
          if (*(AVLTree **)(v22 + 32) == this) {
            *(void *)(v22 + 32) = v9;
          }
        }
      }
      else
      {
        int v12 = *(AVLTree **)(v11 + 16);
        *a3 = v12;
        *a4 = 1;
        uint64_t v13 = *(void *)(v11 + 24);
        *((void *)v12 + 4) = v13;
        if (v13) {
          *(void *)(v13 + 16) = v12;
        }
        *(_OWORD *)(v11 + 16) = *((_OWORD *)this + 1);
        *(void *)(v11 + 32) = *((void *)this + 4);
        uint64_t v14 = *((void *)this + 2);
        if (v14)
        {
          if (*(AVLTree **)(v14 + 24) == this) {
            *(void *)(v14 + 24) = v11;
          }
          if (*(AVLTree **)(v14 + 32) == this) {
            *(void *)(v14 + 32) = v11;
          }
        }
        uint64_t v15 = *((void *)this + 3);
        if (v15) {
          *(void *)(v15 + 16) = v11;
        }
        uint64_t v16 = *((void *)this + 4);
        if (v16) {
          *(void *)(v16 + 16) = v11;
        }
      }
      *(_DWORD *)(v11 + 40) = *((_DWORD *)this + 10);
      goto LABEL_57;
    }
    *a3 = (AVLTree *)*((void *)this + 2);
    *a4 = 0;
    uint64_t v17 = *((void *)this + 2);
    if (v17)
    {
      uint64_t v20 = *(AVLTree **)(v17 + 24);
      if (v20 == this) {
        *a4 = -1;
      }
      int v21 = *(AVLTree **)(v17 + 32);
      if (v21 == this) {
        *a4 = 1;
      }
      if (v20 == this) {
        *(void *)(v17 + 24) = *((void *)this + 3);
      }
      uint64_t v11 = *((void *)this + 3);
      if (v21 == this) {
        *(void *)(v17 + 32) = v11;
      }
    }
    else
    {
      uint64_t v11 = *((void *)this + 3);
    }
LABEL_55:
    if (*(AVLTree **)(v11 + 16) == this) {
      *(void *)(v11 + 16) = v17;
    }
LABEL_57:
    if (*a2 == this) {
      goto LABEL_58;
    }
    goto LABEL_59;
  }
  *a3 = (AVLTree *)*((void *)this + 2);
  *a4 = 0;
  uint64_t v17 = *((void *)this + 2);
  if (v8)
  {
    if (v17)
    {
      unsigned int v18 = *(AVLTree **)(v17 + 24);
      if (v18 == this) {
        *a4 = -1;
      }
      int v19 = *(AVLTree **)(v17 + 32);
      if (v19 == this) {
        *a4 = 1;
      }
      if (v18 == this) {
        *(void *)(v17 + 24) = *((void *)this + 4);
      }
      if (v19 == this) {
        *(void *)(v17 + 32) = *((void *)this + 4);
      }
    }
    uint64_t v11 = *((void *)this + 4);
    goto LABEL_55;
  }
  if (v17)
  {
    uint64_t v23 = *(AVLTree **)(v17 + 24);
    if (v23 == this) {
      *a4 = -1;
    }
    float64x2_t v24 = *(AVLTree **)(v17 + 32);
    if (v24 == this) {
      *a4 = 1;
    }
    if (v23 == this) {
      *(void *)(v17 + 24) = 0;
    }
    if (v24 == this) {
      *(void *)(v17 + 32) = 0;
    }
  }
  if (*a2 == this)
  {
    uint64_t v11 = 0;
LABEL_58:
    *a2 = (AVLTree *)v11;
  }
LABEL_59:
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 10) = 0;
  *((void *)this + 4) = 0;
  return 0;
}

uint64_t AVLTree::Insert(AVLTree *this, AVLTree **a2, int a3, AVLTree *a4, AVLTree *a5, int a6)
{
  uint64_t result = AVLTree::Insert(this, a2, a3, a4, a5);
  if (!result && a6)
  {
    return AVLTree::RestoreBalances((uint64_t)this, 0, a2);
  }
  return result;
}

uint64_t AVLTree::Insert(AVLTree *this, AVLTree **a2, int a3, AVLTree *a4, AVLTree *a5)
{
  uint64_t v5 = (uint64_t)*a2;
  if (*a2)
  {
    switch(a3)
    {
      case 1:
        if (!a4) {
          return 3;
        }
        int v6 = (AVLTree *)*((void *)a4 + 4);
        if (v6)
        {
          do
          {
            uint64_t v7 = v6;
            int v6 = (AVLTree *)*((void *)v6 + 3);
          }
          while (v6);
          *((void *)v7 + 3) = this;
          *((void *)this + 2) = v7;
          uint64_t v8 = *(DblLinked **)v7;
        }
        else
        {
          *((void *)a4 + 4) = this;
          *((void *)this + 2) = a4;
          uint64_t v7 = (AVLTree *)*((void *)a4 + 1);
          uint64_t v8 = a4;
        }
        goto LABEL_23;
      case 2:
        if (!a5 || *((void *)a5 + 3)) {
          return 3;
        }
        *((void *)a5 + 3) = this;
        *((void *)this + 2) = a5;
        DblLinked::InsertOnLeft((uint64_t)this, a5);
        goto LABEL_24;
      case 3:
        if (!a4 || *((void *)a4 + 4)) {
          return 3;
        }
        *((void *)a4 + 4) = this;
        *((void *)this + 2) = a4;
        DblLinked::InsertOnRight(this, a4);
        goto LABEL_24;
      case 4:
        uint64_t v5 = 3;
        if (!a4 || !a5) {
          return v5;
        }
        int v9 = (char *)a5 + 24;
        if (*((void *)a5 + 3))
        {
          int v9 = (char *)a4 + 32;
          if (*((void *)a4 + 4)) {
            return 3;
          }
          uint64_t v10 = a4;
        }
        else
        {
          uint64_t v10 = a5;
        }
        *(void *)int v9 = this;
        *((void *)this + 2) = v10;
        uint64_t v8 = a4;
        uint64_t v7 = a5;
LABEL_23:
        DblLinked::InsertBetween(this, v8, v7);
LABEL_24:
        uint64_t v5 = 0;
        break;
      default:
        return 3;
    }
  }
  else
  {
    *a2 = this;
  }
  return v5;
}

uint64_t *AVLTree::Relocate(AVLTree *this, AVLTree *a2)
{
  uint64_t result = DblLinked::Relocate((uint64_t *)this, a2);
  uint64_t v5 = *((void *)this + 2);
  if (v5)
  {
    if (*(AVLTree **)(v5 + 24) == this) {
      *(void *)(v5 + 24) = a2;
    }
    if (*(AVLTree **)(v5 + 32) == this) {
      *(void *)(v5 + 32) = a2;
    }
  }
  uint64_t v6 = *((void *)this + 4);
  if (v6) {
    *(void *)(v6 + 16) = a2;
  }
  uint64_t v7 = *((void *)this + 3);
  if (v7) {
    *(void *)(v7 + 16) = a2;
  }
  uint64_t v8 = *((void *)this + 2);
  *((void *)a2 + 3) = v7;
  *((void *)a2 + 4) = v6;
  *((void *)a2 + 2) = v8;
  return result;
}

void DblLinked::DblLinked(DblLinked *this)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
}

{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
}

void *DblLinked::MakeNew(void *this)
{
  *this = 0;
  this[1] = 0;
  return this;
}

void DblLinked::~DblLinked(DblLinked *this)
{
  uint64_t v1 = *(void *)this;
  if (*(void *)this) {
    *(void *)(v1 + 8) = *((void *)this + 1);
  }
  id v2 = (void *)*((void *)this + 1);
  if (v2) {
    *id v2 = v1;
  }
  *(void *)this = 0;
  *((void *)this + 1) = 0;
}

{
  uint64_t v1;
  void *v2;

  uint64_t v1 = *(void *)this;
  if (*(void *)this) {
    *(void *)(v1 + 8) = *((void *)this + 1);
  }
  id v2 = (void *)*((void *)this + 1);
  if (v2) {
    *id v2 = v1;
  }
  *(void *)this = 0;
  *((void *)this + 1) = 0;
}

uint64_t *DblLinked::MakeDelete(uint64_t *this)
{
  uint64_t v1 = *this;
  if (*this) {
    *(void *)(v1 + 8) = this[1];
  }
  id v2 = (void *)this[1];
  if (v2) {
    *id v2 = v1;
  }
  *this = 0;
  this[1] = 0;
  return this;
}

uint64_t *DblLinked::Extract(uint64_t *this)
{
  uint64_t v1 = *this;
  if (*this) {
    *(void *)(v1 + 8) = this[1];
  }
  id v2 = (void *)this[1];
  if (v2) {
    *id v2 = v1;
  }
  *this = 0;
  this[1] = 0;
  return this;
}

uint64_t DblLinked::InsertOnLeft(uint64_t this, DblLinked *a2)
{
  *(void *)(this + 8) = a2;
  if (a2) {
    *(void *)a2 = this;
  }
  return this;
}

void *DblLinked::InsertOnRight(void *this, DblLinked *a2)
{
  *this = a2;
  if (a2) {
    *((void *)a2 + 1) = this;
  }
  return this;
}

void *DblLinked::InsertBetween(void *this, DblLinked *a2, DblLinked *a3)
{
  if (a2) {
    *((void *)a2 + 1) = this;
  }
  if (a3) {
    *(void *)a3 = this;
  }
  *this = a2;
  this[1] = a3;
  return this;
}

uint64_t *DblLinked::Relocate(uint64_t *this, DblLinked *a2)
{
  uint64_t v2 = *this;
  if (*this) {
    *(void *)(v2 + 8) = a2;
  }
  uint64_t v3 = (void *)this[1];
  if (v3)
  {
    *uint64_t v3 = a2;
    uint64_t v2 = *this;
  }
  *(void *)a2 = v2;
  *((void *)a2 + 1) = v3;
  return this;
}

void FloatLigne::FloatLigne(FloatLigne *this)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((void *)this + 4) = -1;
  *((void *)this + 5) = -1;
}

{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((void *)this + 4) = -1;
  *((void *)this + 5) = -1;
}

void FloatLigne::~FloatLigne(void **this)
{
  if (*((int *)this + 1) >= 1)
  {
    free(this[1]);
    *this = 0;
    this[1] = 0;
  }
  if (*((int *)this + 5) >= 1)
  {
    free(this[3]);
    this[2] = 0;
    this[3] = 0;
  }
}

uint64_t FloatLigne::Reset(uint64_t this)
{
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 16) = 0;
  *(void *)(this + 32) = -1;
  *(void *)(this + 40) = -1;
  return this;
}

uint64_t FloatLigne::AddBord(FloatLigne *this, float a2, float a3, float a4, float a5, signed int a6)
{
  if (a2 >= a4) {
    return 0xFFFFFFFFLL;
  }
  signed int v12 = *(_DWORD *)this;
  int v13 = *(_DWORD *)this + 1;
  if (v13 >= *((_DWORD *)this + 1))
  {
    uint64_t v16 = 2 * v12 + 2;
    *((_DWORD *)this + 1) = v16;
    uint64_t v14 = (char *)malloc_type_realloc(*((void **)this + 1), 44 * v16, 0x10000402DEC8469uLL);
    *((void *)this + 1) = v14;
    signed int v12 = *(_DWORD *)this;
    int v13 = *(_DWORD *)this + 1;
  }
  else
  {
    uint64_t v14 = (char *)*((void *)this + 1);
  }
  *(_DWORD *)this = v13;
  uint64_t v17 = &v14[44 * v12];
  *(float *)uint64_t v17 = a2;
  _OWORD v17[4] = 1;
  *((_DWORD *)v17 + 4) = v13;
  float v18 = (float)(a5 - a3) / (float)(a4 - a2);
  if (v12 <= a6) {
    unsigned int v19 = -1;
  }
  else {
    unsigned int v19 = a6;
  }
  *((float *)v17 + 2) = a3;
  *((float *)v17 + 3) = v18;
  *(void *)(v17 + 20) = -1;
  *(void *)(v17 + 28) = -1;
  FloatLigne::InsertBord((uint64_t)this, v12, v18, v19);
  uint64_t v15 = *(int *)this;
  *(_DWORD *)this = v15 + 1;
  uint64_t v20 = *((void *)this + 1);
  uint64_t v21 = v20 + 44 * (int)v15;
  *(float *)uint64_t v21 = a4;
  *(unsigned char *)(v21 + 4) = 0;
  *(_DWORD *)(v21 + 16) = v15 - 1;
  float v22 = *(float *)(v20 + 44 * ((int)v15 - 1) + 12);
  *(float *)(v21 + 8) = a5;
  *(float *)(v21 + 12) = v22;
  *(void *)(v21 + 20) = -1;
  *(void *)(v21 + 28) = -1;
  FloatLigne::InsertBord((uint64_t)this, v15, v22, v15 - 1);
  return v15;
}

uint64_t FloatLigne::InsertBord(uint64_t this, unsigned int a2, float a3, unsigned int a4)
{
  if ((a2 & 0x80000000) != 0) {
    return this;
  }
  int v4 = *(_DWORD *)this;
  if (*(_DWORD *)this <= (signed int)a2) {
    return this;
  }
  unsigned int v5 = *(_DWORD *)(this + 40);
  if ((v5 & 0x80000000) != 0)
  {
    *(_DWORD *)(this + 40) = a2;
    *(_DWORD *)(this + 44) = a2;
    *(void *)(*(void *)(this + 8) + 44 * a2 + 28) = -1;
    return this;
  }
  uint64_t v6 = a4;
  if ((a4 & 0x80000000) != 0 || v4 <= (int)a4)
  {
    while ((int)v5 < v4)
    {
      uint64_t v10 = *(void *)(this + 8);
      float v11 = *(float *)(v10 + 44 * v5);
      float v12 = *(float *)(v10 + 44 * a2);
      if (v11 == v12)
      {
        if (*(unsigned char *)(v10 + 44 * v5 + 4)) {
          BOOL v13 = 1;
        }
        else {
          BOOL v13 = *(unsigned char *)(v10 + 44 * a2 + 4) == 0;
        }
        if (v13)
        {
LABEL_33:
          uint64_t v19 = *(void *)(this + 8);
          uint64_t v20 = v19 + 44 * v5;
          unsigned int v23 = *(_DWORD *)(v20 + 28);
          uint64_t v21 = (unsigned int *)(v20 + 28);
          unsigned int v22 = v23;
          *(_DWORD *)(v19 + 44 * a2 + 28) = v23;
          if ((v23 & 0x80000000) != 0) {
            *(_DWORD *)(this + 40) = a2;
          }
          else {
            *(_DWORD *)(v19 + 44 * v22 + 32) = a2;
          }
          *(_DWORD *)(v19 + 44 * a2 + 32) = v5;
          *uint64_t v21 = a2;
          return this;
        }
      }
      else if (v11 >= v12)
      {
        goto LABEL_33;
      }
      unsigned int v5 = *(_DWORD *)(v10 + 44 * v5 + 32);
      if ((v5 & 0x80000000) != 0) {
        break;
      }
    }
    int v14 = *(_DWORD *)(this + 44);
    uint64_t v15 = *(void *)(this + 8);
    *(_DWORD *)(v15 + 44 * a2 + 28) = v14;
    uint64_t v16 = v15 + 44 * v14;
LABEL_47:
    *(_DWORD *)(v16 + 32) = a2;
    *(_DWORD *)(this + 44) = a2;
    return this;
  }
  uint64_t v7 = *(void *)(this + 8);
  float v8 = *(float *)(v7 + 44 * a4);
  float v9 = *(float *)(v7 + 44 * a2);
  if (v8 != v9)
  {
    if (v8 >= v9) {
      goto LABEL_23;
    }
LABEL_36:
    while ((int)v6 < v4)
    {
      float v24 = *(float *)(v7 + 44 * v6);
      if (v24 == v9)
      {
        if (*(unsigned char *)(v7 + 44 * v6 + 4)) {
          BOOL v25 = 1;
        }
        else {
          BOOL v25 = *(unsigned char *)(v7 + 44 * a2 + 4) == 0;
        }
        if (v25)
        {
LABEL_55:
          uint64_t v27 = v7 + 44 * v6;
          goto LABEL_56;
        }
      }
      else if (v24 >= v9)
      {
        goto LABEL_55;
      }
      uint64_t v6 = *(unsigned int *)(v7 + 44 * v6 + 32);
      if ((v6 & 0x80000000) != 0) {
        break;
      }
    }
    int v26 = *(_DWORD *)(this + 44);
    *(_DWORD *)(v7 + 44 * a2 + 28) = v26;
    uint64_t v16 = v7 + 44 * v26;
    goto LABEL_47;
  }
  if (*(unsigned char *)(v7 + 44 * a4 + 4))
  {
    if (!*(unsigned char *)(v7 + 44 * a2 + 4))
    {
      while (1)
      {
LABEL_23:
        if ((int)v6 >= v4)
        {
LABEL_32:
          *(_DWORD *)(v7 + 44 * a2 + 32) = v5;
          *(_DWORD *)(v7 + 44 * (int)v5 + 28) = a2;
          *(_DWORD *)(this + 40) = a2;
          return this;
        }
        float v17 = *(float *)(v7 + 44 * v6);
        if (v17 == v9)
        {
          if (*(unsigned char *)(v7 + 44 * v6 + 4)) {
            BOOL v18 = *(unsigned char *)(v7 + 44 * a2 + 4) == 0;
          }
          else {
            BOOL v18 = 0;
          }
          if (!v18)
          {
LABEL_50:
            uint64_t v28 = v7 + 44 * v6;
            int v29 = *(_DWORD *)(v28 + 32);
            uint64_t v30 = v7 + 44 * a2;
            *(_DWORD *)(v30 + 32) = v29;
            uint64_t v31 = (unsigned int *)(v7 + 44 * v29 + 28);
            if (v29 < 0) {
              uint64_t v31 = (unsigned int *)(this + 44);
            }
            *uint64_t v31 = a2;
            *(_DWORD *)(v30 + 28) = v6;
            *(_DWORD *)(v28 + 32) = a2;
            return this;
          }
        }
        else if (v17 < v9)
        {
          goto LABEL_50;
        }
        uint64_t v6 = *(unsigned int *)(v7 + 44 * v6 + 28);
        if ((v6 & 0x80000000) != 0) {
          goto LABEL_32;
        }
      }
    }
  }
  else if (*(unsigned char *)(v7 + 44 * a2 + 4))
  {
    goto LABEL_36;
  }
  uint64_t v27 = v7 + 44 * a4;
LABEL_56:
  unsigned int v34 = *(_DWORD *)(v27 + 28);
  uint64_t v32 = (unsigned int *)(v27 + 28);
  unsigned int v33 = v34;
  *(_DWORD *)(v7 + 44 * a2 + 28) = v34;
  if ((v34 & 0x80000000) != 0) {
    *(_DWORD *)(this + 40) = a2;
  }
  else {
    *(_DWORD *)(v7 + 44 * v33 + 32) = a2;
  }
  *(_DWORD *)(v7 + 44 * a2 + 32) = v6;
  *uint64_t v32 = a2;
  return this;
}

uint64_t FloatLigne::AddBord(FloatLigne *this, float a2, float a3, float a4, float a5, float a6, signed int a7)
{
  if (a2 >= a4) {
    return 0xFFFFFFFFLL;
  }
  signed int v14 = *(_DWORD *)this;
  uint64_t v15 = (*(_DWORD *)this + 1);
  if ((int)v15 >= *((_DWORD *)this + 1))
  {
    uint64_t v17 = 2 * v14 + 2;
    *((_DWORD *)this + 1) = v17;
    uint64_t v16 = (char *)malloc_type_realloc(*((void **)this + 1), 44 * v17, 0x10000402DEC8469uLL);
    *((void *)this + 1) = v16;
    signed int v14 = *(_DWORD *)this;
    uint64_t v15 = (*(_DWORD *)this + 1);
  }
  else
  {
    uint64_t v16 = (char *)*((void *)this + 1);
  }
  BOOL v18 = &v16[44 * v14];
  *(float *)BOOL v18 = a2;
  v18[4] = 1;
  if (v14 <= a7) {
    unsigned int v19 = -1;
  }
  else {
    unsigned int v19 = a7;
  }
  *((_DWORD *)v18 + 4) = v15;
  *((float *)v18 + 2) = a3;
  *((float *)v18 + 3) = a6;
  *(void *)(v18 + 20) = -1;
  *(void *)(v18 + 28) = -1;
  *(_DWORD *)this = v14 + 2;
  uint64_t v20 = &v16[44 * (int)v15];
  *(float *)uint64_t v20 = a4;
  v20[4] = 0;
  *((_DWORD *)v20 + 4) = v14;
  *((float *)v20 + 2) = a5;
  *((float *)v20 + 3) = a6;
  *(void *)(v20 + 20) = -1;
  *(void *)(v20 + 28) = -1;
  FloatLigne::InsertBord((uint64_t)this, v14, a2, v19);
  FloatLigne::InsertBord((uint64_t)this, v15, v21, v14);
  return v15;
}

uint64_t FloatLigne::AddBordR(FloatLigne *this, float a2, float a3, float a4, float a5, float a6, int a7)
{
  if (a2 >= a4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v14 = *(unsigned int *)this;
  signed int v15 = v14 + 1;
  if ((int)v14 + 1 >= *((_DWORD *)this + 1))
  {
    uint64_t v17 = 2 * (int)v14 + 2;
    *((_DWORD *)this + 1) = v17;
    uint64_t v16 = (char *)malloc_type_realloc(*((void **)this + 1), 44 * v17, 0x10000402DEC8469uLL);
    *((void *)this + 1) = v16;
    uint64_t v14 = *(unsigned int *)this;
    signed int v15 = v14 + 1;
  }
  else
  {
    uint64_t v16 = (char *)*((void *)this + 1);
  }
  BOOL v18 = &v16[44 * (int)v14];
  *(float *)BOOL v18 = a2;
  v18[4] = 1;
  if ((int)v14 <= a7) {
    unsigned int v19 = -1;
  }
  else {
    unsigned int v19 = a7;
  }
  *((_DWORD *)v18 + 4) = v15;
  *((float *)v18 + 2) = a3;
  *((float *)v18 + 3) = a6;
  *(void *)(v18 + 20) = -1;
  *(void *)(v18 + 28) = -1;
  *(_DWORD *)this = v14 + 2;
  uint64_t v20 = &v16[44 * v15];
  *(float *)uint64_t v20 = a4;
  v20[4] = 0;
  *((_DWORD *)v20 + 4) = v14;
  *((float *)v20 + 2) = a5;
  *((float *)v20 + 3) = a6;
  *(void *)(v20 + 20) = -1;
  *(void *)(v20 + 28) = -1;
  FloatLigne::InsertBord((uint64_t)this, v15, a2, v19);
  FloatLigne::InsertBord((uint64_t)this, v14, v21, v15);
  return v14;
}

uint64_t FloatLigne::AppendBord(FloatLigne *this, float a2, float a3, float a4, float a5, float a6)
{
  if (a2 >= a4) {
    return 0xFFFFFFFFLL;
  }
  int v13 = *(_DWORD *)this;
  int v12 = *((_DWORD *)this + 1);
  uint64_t result = (*(_DWORD *)this + 1);
  if ((int)result >= v12)
  {
    uint64_t v16 = 2 * v13 + 2;
    *((_DWORD *)this + 1) = v16;
    signed int v15 = malloc_type_realloc(*((void **)this + 1), 44 * v16, 0x10000402DEC8469uLL);
    *((void *)this + 1) = v15;
    int v13 = *(_DWORD *)this;
    uint64_t result = (*(_DWORD *)this + 1);
  }
  else
  {
    signed int v15 = (_DWORD *)*((void *)this + 1);
  }
  uint64_t v17 = (char *)&v15[11 * v13];
  *(float *)uint64_t v17 = a2;
  _OWORD v17[4] = 1;
  *((_DWORD *)v17 + 4) = result;
  *((float *)v17 + 2) = a3;
  *((float *)v17 + 3) = a6;
  *(void *)(v17 + 20) = -1;
  int v18 = *((_DWORD *)this + 11);
  *((_DWORD *)v17 + 7) = v18;
  *((_DWORD *)v17 + 8) = result;
  if ((v18 & 0x80000000) == 0) {
    v15[11 * v18 + 8] = v13;
  }
  if ((*((_DWORD *)this + 10) & 0x80000000) != 0) {
    *((_DWORD *)this + 10) = v13;
  }
  *(_DWORD *)this = v13 + 2;
  unsigned int v19 = (char *)&v15[11 * (int)result];
  *(float *)unsigned int v19 = a4;
  v19[4] = 0;
  *((_DWORD *)v19 + 4) = v13;
  *((float *)v19 + 2) = a5;
  *((float *)v19 + 3) = a6;
  *(void *)(v19 + 20) = -1;
  *((_DWORD *)v19 + 7) = v13;
  *((_DWORD *)v19 + 8) = -1;
  *((_DWORD *)this + 11) = result;
  return result;
}

float FloatLigne::RemainingValAt(FloatLigne *this, float a2, int a3)
{
  if (a3 < 1) {
    return 0.0;
  }
  uint64_t v3 = *((void *)this + 1);
  uint64_t v4 = a3;
  unsigned int v5 = (int *)(v3 + 36);
  float v6 = 0.0;
  do
  {
    int v7 = *v5;
    v5 += 11;
    float v6 = v6
       + (float)(*(float *)(v3 + 44 * v7 + 8)
               + (float)((float)(a2 - *(float *)(v3 + 44 * v7)) * *(float *)(v3 + 44 * v7 + 12)));
    --v4;
  }
  while (v4);
  return v6;
}

uint64_t FloatLigne::Flatten(uint64_t this)
{
  uint64_t v1 = (FloatLigne *)this;
  if (*(int *)this > 1)
  {
    *(_DWORD *)(this + 16) = 0;
    *(void *)(this + 32) = -1;
    uint64_t v2 = *(unsigned int *)(this + 40);
    if ((v2 & 0x80000000) == 0)
    {
      int v3 = 0;
      BOOL v4 = 0;
      float v5 = **(float **)(this + 8);
      float v6 = 0.0;
      float v7 = 0.0;
      float v8 = 0.0;
      float v9 = 0.0;
      do
      {
        int v10 = *(_DWORD *)v1;
        if ((int)v2 >= *(_DWORD *)v1) {
          break;
        }
        uint64_t v11 = *((void *)v1 + 1);
        float v12 = *(float *)(v11 + 44 * v2);
        float v13 = 0.0;
        do
        {
          if (*(float *)(v11 + 44 * v2) != v12 || *(unsigned char *)(v11 + 44 * v2 + 4)) {
            break;
          }
          uint64_t v14 = v11 + 44 * v2;
          int v15 = *(_DWORD *)(v14 + 16);
          if ((v15 & 0x80000000) == 0 && v15 < v10)
          {
            int v16 = *(_DWORD *)(v11 + 44 * v15 + 40);
            if ((v16 & 0x80000000) == 0 && v16 < v3)
            {
              int v17 = *(_DWORD *)(v11 + 44 * (v3 - 1) + 36);
              *(_DWORD *)(v11 + 44 * v16 + 36) = v17;
              *(_DWORD *)(v11 + 44 * v17 + 40) = v16;
            }
          }
          float v13 = v13 + *(float *)(v14 + 12);
          --v3;
          uint64_t v2 = *(unsigned int *)(v11 + 44 * v2 + 32);
          if ((v2 & 0x80000000) != 0) {
            break;
          }
        }
        while ((int)v2 < v10);
        float v18 = 0.0;
        if ((v2 & 0x80000000) == 0 && (int)v2 < v10)
        {
          unsigned int v19 = (_DWORD *)(v11 + 44 * v3 + 36);
          do
          {
            if (*(float *)(v11 + 44 * v2) != v12) {
              break;
            }
            if (!*(unsigned char *)(v11 + 44 * v2 + 4)) {
              break;
            }
            uint64_t v20 = v11 + 44 * v2;
            float v18 = v18 + *(float *)(v20 + 12);
            *unsigned int v19 = v2;
            v19 += 11;
            *(_DWORD *)(v20 + 40) = v3;
            uint64_t v2 = *(unsigned int *)(v20 + 32);
            ++v3;
            if ((v2 & 0x80000000) != 0) {
              break;
            }
          }
          while ((int)v2 < v10);
        }
        if (v4) {
          this = FloatLigne::AddRun(v1, v7, v12, v6, v8 + (float)(v9 * (float)(v12 - v5)), v9);
        }
        BOOL v4 = v3 > 0;
        if (v3 < 1)
        {
          float v8 = 0.0;
        }
        else
        {
          uint64_t v21 = *((void *)v1 + 1);
          uint64_t v22 = v3;
          unsigned int v23 = (int *)(v21 + 36);
          float v8 = 0.0;
          do
          {
            int v24 = *v23;
            v23 += 11;
            float v8 = v8
               + (float)(*(float *)(v21 + 44 * v24 + 8)
                       + (float)((float)(v12 - *(float *)(v21 + 44 * v24)) * *(float *)(v21 + 44 * v24 + 12)));
            --v22;
          }
          while (v22);
          float v7 = v12;
          float v6 = v8;
        }
        float v9 = v9 + (float)(v18 - v13);
        float v5 = v12;
      }
      while ((v2 & 0x80000000) == 0);
    }
  }
  else
  {
    *(_DWORD *)this = 0;
    *(_DWORD *)(this + 16) = 0;
    *(void *)(this + 32) = -1;
    *(void *)(this + 40) = -1;
  }
  return this;
}

uint64_t FloatLigne::AddRun(FloatLigne *this, float a2, float a3, float a4, float a5, float a6)
{
  if (a2 >= a3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = *((unsigned int *)this + 4);
  if ((int)result >= *((_DWORD *)this + 5))
  {
    uint64_t v14 = (2 * (int)result) | 1;
    *((_DWORD *)this + 5) = v14;
    float v13 = (char *)malloc_type_realloc(*((void **)this + 3), 20 * v14, 0x1000040A86A77D5uLL);
    *((void *)this + 3) = v13;
    uint64_t result = *((unsigned int *)this + 4);
  }
  else
  {
    float v13 = (char *)*((void *)this + 3);
  }
  *((_DWORD *)this + 4) = result + 1;
  int v15 = (float *)&v13[20 * (int)result];
  *int v15 = a2;
  v15[1] = a3;
  v15[2] = a4;
  _OWORD v15[3] = a5;
  v15[4] = a6;
  return result;
}

uint64_t FloatLigne::Affiche(FloatLigne *this)
{
  printf("%i : \n", *(_DWORD *)this);
  if (*(int *)this >= 1)
  {
    uint64_t v2 = 0;
    uint64_t v3 = 0;
    do
    {
      printf("(%f %f %f %i) ", *(float *)(*((void *)this + 1) + v2), *(float *)(*((void *)this + 1) + v2 + 8), *(float *)(*((void *)this + 1) + v2 + 12), *(unsigned __int8 *)(*((void *)this + 1) + v2 + 4));
      ++v3;
      v2 += 44;
    }
    while (v3 < *(int *)this);
  }
  putchar(10);
  printf("%i : \n", *((_DWORD *)this + 4));
  if (*((int *)this + 4) >= 1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = 0;
    do
    {
      printf("(%f %f -> %f %f) ", *(float *)(*((void *)this + 3) + v4), *(float *)(*((void *)this + 3) + v4 + 8), *(float *)(*((void *)this + 3) + v4 + 4), *(float *)(*((void *)this + 3) + v4 + 12));
      ++v5;
      v4 += 20;
    }
    while (v5 < *((int *)this + 4));
  }

  return putchar(10);
}

float FloatLigne::AddRun(FloatLigne *this, float result, float a3, float a4, float a5)
{
  if (result < a3)
  {
    float v8 = result;
    int v10 = *((_DWORD *)this + 4);
    if (v10 >= *((_DWORD *)this + 5))
    {
      uint64_t v12 = (2 * v10) | 1;
      *((_DWORD *)this + 5) = v12;
      uint64_t v11 = (char *)malloc_type_realloc(*((void **)this + 3), 20 * v12, 0x1000040A86A77D5uLL);
      *((void *)this + 3) = v11;
      int v10 = *((_DWORD *)this + 4);
    }
    else
    {
      uint64_t v11 = (char *)*((void *)this + 3);
    }
    *((_DWORD *)this + 4) = v10 + 1;
    float v13 = (float *)&v11[20 * v10];
    *float v13 = v8;
    v13[1] = a3;
    v13[2] = a4;
    v13[3] = a5;
    uint64_t result = (float)(a5 - a4) / (float)(a3 - v8);
    v13[4] = result;
  }
  return result;
}

void **FloatLigne::Copy(void **this, FloatLigne *a2)
{
  uint64_t v2 = this;
  uint64_t v3 = *((unsigned int *)a2 + 4);
  *(_DWORD *)this = 0;
  if ((int)v3 <= 0)
  {
    *((_DWORD *)this + 4) = 0;
    this[4] = (void *)-1;
    this[5] = (void *)-1;
  }
  else
  {
    *((_DWORD *)this + 4) = v3;
    if ((int)v3 <= *((_DWORD *)this + 5))
    {
      uint64_t v5 = this[3];
    }
    else
    {
      *((_DWORD *)this + 5) = v3;
      uint64_t v5 = malloc_type_realloc(this[3], 20 * v3, 0x1000040A86A77D5uLL);
      v2[3] = v5;
      LODWORD(v3) = *((_DWORD *)v2 + 4);
    }
    float v6 = (const void *)*((void *)a2 + 3);
    return (void **)memcpy(v5, v6, 20 * (int)v3);
  }
  return this;
}

void **FloatLigne::Copy(void **result, uint64_t a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *(unsigned int *)(a2 + 16);
  *(_DWORD *)uint64_t result = 0;
  if ((int)v3 <= 0)
  {
    *((_DWORD *)result + 4) = 0;
    result[4] = (void *)-1;
    result[5] = (void *)-1;
  }
  else
  {
    *((_DWORD *)result + 4) = v3;
    if ((int)v3 <= *((_DWORD *)result + 5)
      || (*((_DWORD *)result + 5) = 2 * v3,
          uint64_t result = (void **)malloc_type_realloc(result[3], 40 * v3, 0x1000040A86A77D5uLL),
          v2[3] = result,
          LODWORD(v3) = *((_DWORD *)v2 + 4),
          (int)v3 >= 1))
    {
      uint64_t v3 = v3;
      uint64_t v5 = (char *)v2[3] + 8;
      float v6 = (uint64_t *)(*(void *)(a2 + 24) + 8);
      do
      {
        *(v5 - 1) = vcvt_f32_s32((int32x2_t)*(v6 - 1));
        uint64_t v7 = *v6;
        v6 += 2;
        *uint64_t v5 = v7;
        uint64_t v5 = (void *)((char *)v5 + 20);
        --v3;
      }
      while (v3);
    }
  }
  return result;
}

void FloatLigne::Booleen(uint64_t a1, uint64_t a2, FloatLigne *a3, unsigned int a4)
{
  uint64_t v5 = a3;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(void *)(a1 + 32) = -1;
  *(void *)(a1 + 40) = -1;
  int v6 = *(_DWORD *)(a2 + 16);
  int v7 = *((_DWORD *)a3 + 4);
  if (v6 <= 0)
  {
    if (v7 < 1 || a4 && a4 != 3) {
      return;
    }
    goto LABEL_115;
  }
  if (v7 <= 0)
  {
    if (a4 > 3) {
      return;
    }
    uint64_t v5 = (FloatLigne *)a2;
    if (a4 == 1) {
      return;
    }
LABEL_115:
    FloatLigne::Copy((void **)a1, v5);
    return;
  }
  float v9 = *(float **)(a2 + 24);
  int v10 = (float *)*((void *)a3 + 3);
  if (*v9 >= *v10) {
    float v11 = *v10;
  }
  else {
    float v11 = *v9;
  }
  float v12 = 0.0;
  float v13 = 0.0;
  if (v11 == *v9) {
    float v13 = v9[2];
  }
  if (v11 == *v10) {
    float v12 = v10[2];
  }
  if (*((int *)a3 + 4) < 1)
  {
    LODWORD(v14) = 0;
    LODWORD(v15) = 0;
  }
  else
  {
    uint64_t v14 = 0;
    LODWORD(v15) = 0;
    float v16 = v11;
    do
    {
      int v17 = (float *)(*(void *)(a2 + 24) + 20 * (int)v15);
      float v18 = *v17;
      float v19 = v17[1];
      uint64_t v20 = (float *)(*((void *)v5 + 3) + 20 * (int)v14);
      float v21 = *v20;
      float v22 = v20[1];
      BOOL v23 = v16 < v19 && v16 >= *v17;
      BOOL v24 = v16 < v22 && v16 >= v21;
      uint64_t v80 = v14;
      if (v16 >= v18)
      {
        if (v16 >= v21)
        {
          BOOL v34 = v19 == v22;
          if (v19 == v22) {
            float v35 = v17[1];
          }
          else {
            float v35 = v20[1];
          }
          if (v19 >= v22)
          {
            int v36 = 1;
          }
          else
          {
            BOOL v34 = 1;
            int v36 = 0;
          }
          if (v19 < v22) {
            float v35 = v17[1];
          }
          BOOL v37 = v19 == v22;
          if (v19 == v22) {
            float v38 = v17[1];
          }
          else {
            float v38 = v20[1];
          }
          if (v19 >= v22)
          {
            int v39 = 1;
          }
          else
          {
            BOOL v37 = 1;
            int v39 = 0;
          }
          if (v19 < v22) {
            float v38 = v17[1];
          }
          if (v16 == v21) {
            BOOL v30 = v37;
          }
          else {
            BOOL v30 = v34;
          }
          if (v16 == v21) {
            int v31 = v39;
          }
          else {
            int v31 = v36;
          }
          BOOL v32 = 0;
          BOOL v33 = 0;
          if (v16 == v21) {
            float v11 = v38;
          }
          else {
            float v11 = v35;
          }
        }
        else
        {
          BOOL v30 = v19 < v21 || v19 == v21;
          int v31 = 0;
          BOOL v32 = v19 >= v21;
          BOOL v33 = 0;
          if (v19 >= v21) {
            float v11 = *v20;
          }
          else {
            float v11 = v17[1];
          }
        }
      }
      else
      {
        BOOL v25 = v18 == v22;
        if (v18 == v22) {
          float v26 = *v17;
        }
        else {
          float v26 = v20[1];
        }
        BOOL v27 = v18 >= v22;
        if (v18 < v22)
        {
          BOOL v25 = 1;
          float v26 = *v17;
        }
        if (v16 < v21)
        {
          BOOL v27 = 0;
          BOOL v25 = 0;
          float v26 = v16;
        }
        BOOL v28 = v18 == v21;
        if (v18 == v21) {
          float v29 = *v17;
        }
        else {
          float v29 = *v20;
        }
        if (v18 < v21)
        {
          BOOL v28 = 1;
          float v29 = *v17;
        }
        BOOL v30 = 0;
        int v31 = v16 >= v21 && v27;
        BOOL v32 = v16 < v21 && v18 >= v21;
        if (v16 < v21) {
          BOOL v33 = v28;
        }
        else {
          BOOL v33 = v25;
        }
        if (v16 < v21) {
          float v11 = v29;
        }
        else {
          float v11 = v26;
        }
      }
      float v40 = v17[2];
      float v41 = 0.0;
      float v42 = 0.0;
      if (v23) {
        float v42 = (float)((float)(v40 * (float)(v19 - v11)) + (float)((float)(v11 - v18) * v17[3])) / (float)(v19 - v18);
      }
      float v43 = v20[2];
      if (v24) {
        float v41 = (float)((float)(v43 * (float)(v22 - v11)) + (float)((float)(v11 - v21) * v20[3])) / (float)(v22 - v21);
      }
      switch(a4)
      {
        case 0u:
          if (v23 || v24)
          {
            float v44 = v12 + v13;
            float v45 = v42 + v41;
            goto LABEL_90;
          }
          break;
        case 1u:
          if (v23 && v24)
          {
            float v44 = v12 * v13;
            float v45 = v42 * v41;
            goto LABEL_90;
          }
          break;
        case 2u:
          if (v23)
          {
            float v44 = v13 - v12;
            float v45 = v42 - v41;
            goto LABEL_90;
          }
          break;
        case 3u:
          if (!v24 && v23) {
            FloatLigne::AddRun((FloatLigne *)a1, v16, v11, v13 - v12, v42 - v41);
          }
          if (!v23 && v24)
          {
            float v44 = v12 - v13;
            float v45 = v41 - v42;
LABEL_90:
            FloatLigne::AddRun((FloatLigne *)a1, v16, v11, v44, v45);
          }
          break;
        default:
          break;
      }
      if (v33) {
        float v13 = v40;
      }
      else {
        float v13 = v42;
      }
      if (v32) {
        float v12 = v43;
      }
      else {
        float v12 = v41;
      }
      if (v30)
      {
        uint64_t v15 = (int)v15 + 1;
        float v13 = 0.0;
        uint64_t v14 = v80;
        if ((int)v15 < *(_DWORD *)(a2 + 16))
        {
          uint64_t v46 = *(void *)(a2 + 24);
          if (*(float *)(v46 + 20 * v15) == v11) {
            float v13 = *(float *)(v46 + 20 * v15 + 8);
          }
        }
      }
      else
      {
        uint64_t v14 = v80;
      }
      if (v31)
      {
        uint64_t v14 = (int)v14 + 1;
        float v12 = 0.0;
        if ((int)v14 < *((_DWORD *)v5 + 4))
        {
          uint64_t v47 = *((void *)v5 + 3);
          if (*(float *)(v47 + 20 * v14) == v11) {
            float v12 = *(float *)(v47 + 20 * v14 + 8);
          }
        }
      }
      int v6 = *(_DWORD *)(a2 + 16);
      if ((int)v15 >= v6) {
        break;
      }
      float v16 = v11;
    }
    while ((int)v14 < *((_DWORD *)v5 + 4));
  }
  if ((int)v15 < v6)
  {
    do
    {
      float v48 = v11;
      double v49 = (float *)(*(void *)(a2 + 24) + 20 * (int)v15);
      float v51 = *v49;
      float v50 = v49[1];
      float v52 = v49[2];
      BOOL v53 = v11 >= *v49;
      if (v11 < *v49) {
        float v54 = *v49;
      }
      else {
        float v54 = v11;
      }
      if (v11 < *v49) {
        float v11 = v54;
      }
      else {
        float v11 = v49[1];
      }
      if (v48 >= v50) {
        BOOL v53 = 0;
      }
      float v55 = 0.0;
      if (v53) {
        float v55 = (float)((float)(v52 * (float)(v50 - v11)) + (float)((float)(v11 - v51) * v49[3])) / (float)(v50 - v51);
      }
      if (a4 == 3 || a4 == 2)
      {
        if (v53)
        {
          float v56 = v13 - v12;
          double v58 = (FloatLigne *)a1;
          float v59 = v48;
          float v60 = v11;
          float v57 = v55;
          goto LABEL_137;
        }
      }
      else if (!a4 && v53)
      {
        float v56 = v12 + v13;
        float v57 = v55 + 0.0;
        double v58 = (FloatLigne *)a1;
        float v59 = v48;
        float v60 = v11;
LABEL_137:
        FloatLigne::AddRun(v58, v59, v60, v56, v57);
      }
      if (v48 < v51) {
        float v13 = v52;
      }
      else {
        float v13 = v55;
      }
      int v61 = *(_DWORD *)(a2 + 16);
      if (v48 >= v51)
      {
        uint64_t v15 = (int)v15 + 1;
        float v13 = 0.0;
        if ((int)v15 < v61)
        {
          uint64_t v62 = *(void *)(a2 + 24);
          if (*(float *)(v62 + 20 * v15) == v50) {
            float v13 = *(float *)(v62 + 20 * v15 + 8);
          }
        }
      }
      float v12 = 0.0;
    }
    while ((int)v15 < v61);
  }
  if ((int)v14 < *((_DWORD *)v5 + 4))
  {
    LODWORD(v63) = v14;
    do
    {
      float v64 = v11;
      double v65 = (float *)(*((void *)v5 + 3) + 20 * (int)v63);
      float v67 = *v65;
      float v66 = v65[1];
      float v68 = v65[2];
      BOOL v69 = v11 >= *v65;
      if (v11 < *v65) {
        float v70 = *v65;
      }
      else {
        float v70 = v11;
      }
      if (v11 < *v65) {
        float v11 = v70;
      }
      else {
        float v11 = v65[1];
      }
      if (v64 >= v66) {
        BOOL v69 = 0;
      }
      float v71 = 0.0;
      if (v69) {
        float v71 = (float)((float)(v68 * (float)(v66 - v11)) + (float)((float)(v11 - v67) * v65[3])) / (float)(v66 - v67);
      }
      if (a4 == 3)
      {
        if (v69)
        {
          float v72 = v12 - v13;
          uint64_t v74 = (FloatLigne *)a1;
          float v75 = v64;
          float v76 = v11;
          float v73 = v71;
          goto LABEL_164;
        }
      }
      else if (!a4 && v69)
      {
        float v72 = v12 + v13;
        float v73 = v71 + 0.0;
        uint64_t v74 = (FloatLigne *)a1;
        float v75 = v64;
        float v76 = v11;
LABEL_164:
        FloatLigne::AddRun(v74, v75, v76, v72, v73);
      }
      if (v64 < v67) {
        float v12 = v68;
      }
      else {
        float v12 = v71;
      }
      int v77 = *((_DWORD *)v5 + 4);
      if (v64 >= v67)
      {
        uint64_t v63 = (int)v63 + 1;
        float v12 = 0.0;
        if ((int)v63 < v77)
        {
          uint64_t v78 = *((void *)v5 + 3);
          if (*(float *)(v78 + 20 * v63) == v66) {
            float v12 = *(float *)(v78 + 20 * v63 + 8);
          }
        }
      }
      float v13 = 0.0;
    }
    while ((int)v63 < v77);
  }
}

void FloatLigne::Min(FloatLigne *this, FloatLigne *a2, float a3, int a4)
{
  *(_DWORD *)this = 0;
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 4) = -1;
  *((void *)this + 5) = -1;
  if (*((int *)a2 + 4) < 1) {
    return;
  }
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  int v10 = 0;
  float v11 = 0.0;
  float v12 = 0.0;
  do
  {
    float v13 = (float *)(*((void *)a2 + 3) + v8);
    float v15 = *v13;
    float v14 = v13[1];
    float v17 = v13[2];
    float v16 = v13[3];
    if (v17 <= a3)
    {
      if (v16 <= a3)
      {
        if (v10)
        {
          double v24 = v15 + -0.00001;
          if (v24 <= v12) {
            float v25 = v11;
          }
          else {
            float v25 = *v13;
          }
          if (v24 <= v12 || a4 == 0)
          {
            int v10 = 1;
            float v12 = v13[1];
            float v11 = v25;
            goto LABEL_34;
          }
          FloatLigne::AddRun(this, v11, v12, a3, a3);
        }
        int v10 = 1;
        float v12 = v14;
        float v11 = v15;
        goto LABEL_34;
      }
      float v23 = (float)((float)(v14 * (float)(v17 - a3)) + (float)(v15 * (float)(a3 - v16))) / (float)(v17 - v16);
      if (v10)
      {
        if (v15 + -0.00001 <= v12)
        {
          if (a4)
          {
            BOOL v27 = this;
            float v28 = v11;
            goto LABEL_30;
          }
        }
        else if (a4)
        {
          FloatLigne::AddRun(this, v11, v12, a3, a3);
LABEL_27:
          BOOL v27 = this;
          float v28 = v15;
LABEL_30:
          FloatLigne::AddRun(v27, v28, v23, a3, a3);
        }
      }
      else if (a4)
      {
        goto LABEL_27;
      }
      float v19 = this;
      float v20 = v23;
      float v21 = v14;
      float v22 = a3;
LABEL_32:
      FloatLigne::AddRun(v19, v20, v21, v22, v16);
      int v10 = 0;
      goto LABEL_34;
    }
    int v18 = v10 & a4;
    if (v16 > a3)
    {
      if (v18 == 1) {
        FloatLigne::AddRun(this, v11, v12, a3, a3);
      }
      float v19 = this;
      float v20 = v15;
      float v21 = v14;
      float v22 = v17;
      goto LABEL_32;
    }
    if (v18 == 1) {
      FloatLigne::AddRun(this, v11, v12, a3, a3);
    }
    float v11 = (float)((float)(v14 * (float)(a3 - v17)) + (float)(v15 * (float)(v16 - a3))) / (float)(v16 - v17);
    FloatLigne::AddRun(this, v15, v11, v17, a3);
    int v10 = 1;
    float v12 = v14;
LABEL_34:
    ++v9;
    v8 += 20;
  }
  while (v9 < *((int *)a2 + 4));
  if (v10 & a4)
  {
    FloatLigne::AddRun(this, v11, v12, a3, a3);
  }
}

void FloatLigne::Split(FloatLigne *this, FloatLigne *a2, float a3, FloatLigne *a4)
{
  *(_DWORD *)this = 0;
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 4) = -1;
  *((void *)this + 5) = -1;
  if (*((int *)a2 + 4) >= 1)
  {
    uint64_t v8 = 0;
    for (uint64_t i = 0; i < *((int *)a2 + 4); ++i)
    {
      int v10 = (float *)(*((void *)a2 + 3) + v8);
      float v11 = *v10;
      float v12 = v10[1];
      float v13 = v10[2];
      float v14 = v10[3];
      if (v13 >= a3)
      {
        if (v14 < a3)
        {
          float v16 = (float)(v12 * (float)(v13 - a3)) + (float)(v11 * (float)(a3 - v14));
          float v17 = v16 / (float)(v13 - v14);
          if (a4) {
            FloatLigne::AddRun(a4, v11, v16 / (float)(v13 - v14), v13, a3);
          }
          float v15 = this;
LABEL_12:
          float v11 = v17;
          float v18 = v12;
          float v13 = a3;
LABEL_16:
          FloatLigne::AddRun(v15, v11, v18, v13, v14);
          goto LABEL_17;
        }
        if (a4)
        {
          float v15 = a4;
LABEL_15:
          float v18 = v10[1];
          goto LABEL_16;
        }
      }
      else
      {
        if (v14 < a3)
        {
          float v15 = this;
          goto LABEL_15;
        }
        float v17 = (float)((float)(v12 * (float)(a3 - v13)) + (float)(v11 * (float)(v14 - a3))) / (float)(v14 - v13);
        FloatLigne::AddRun(this, v11, v17, v13, a3);
        if (a4)
        {
          float v15 = a4;
          goto LABEL_12;
        }
      }
LABEL_17:
      v8 += 20;
    }
  }
}

void FloatLigne::Max(FloatLigne *this, FloatLigne *a2, float a3, int a4)
{
  *(_DWORD *)this = 0;
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 4) = -1;
  *((void *)this + 5) = -1;
  if (*((int *)a2 + 4) < 1) {
    return;
  }
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  int v10 = 0;
  float v11 = 0.0;
  float v12 = 0.0;
  do
  {
    float v13 = (float *)(*((void *)a2 + 3) + v8);
    float v15 = *v13;
    float v14 = v13[1];
    float v17 = v13[2];
    float v16 = v13[3];
    if (v17 >= a3)
    {
      if (v16 >= a3)
      {
        if (v10)
        {
          double v24 = v15 + -0.00001;
          if (v24 <= v12) {
            float v25 = v11;
          }
          else {
            float v25 = *v13;
          }
          if (v24 <= v12 || a4 == 0)
          {
            int v10 = 1;
            float v12 = v13[1];
            float v11 = v25;
            goto LABEL_34;
          }
          FloatLigne::AddRun(this, v11, v12, a3, a3);
        }
        int v10 = 1;
        float v12 = v14;
        float v11 = v15;
        goto LABEL_34;
      }
      float v23 = (float)((float)(v14 * (float)(v17 - a3)) + (float)(v15 * (float)(a3 - v16))) / (float)(v17 - v16);
      if (v10)
      {
        if (v15 + -0.00001 <= v12)
        {
          if (a4)
          {
            BOOL v27 = this;
            float v28 = v11;
            goto LABEL_30;
          }
        }
        else if (a4)
        {
          FloatLigne::AddRun(this, v11, v12, a3, a3);
LABEL_27:
          BOOL v27 = this;
          float v28 = v15;
LABEL_30:
          FloatLigne::AddRun(v27, v28, v23, a3, a3);
        }
      }
      else if (a4)
      {
        goto LABEL_27;
      }
      float v19 = this;
      float v20 = v23;
      float v21 = v14;
      float v22 = a3;
LABEL_32:
      FloatLigne::AddRun(v19, v20, v21, v22, v16);
      int v10 = 0;
      goto LABEL_34;
    }
    int v18 = v10 & a4;
    if (v16 < a3)
    {
      if (v18 == 1) {
        FloatLigne::AddRun(this, v11, v12, a3, a3);
      }
      float v19 = this;
      float v20 = v15;
      float v21 = v14;
      float v22 = v17;
      goto LABEL_32;
    }
    if (v18 == 1) {
      FloatLigne::AddRun(this, v11, v12, a3, a3);
    }
    float v11 = (float)((float)(v14 * (float)(a3 - v17)) + (float)(v15 * (float)(v16 - a3))) / (float)(v16 - v17);
    FloatLigne::AddRun(this, v15, v11, v17, a3);
    int v10 = 1;
    float v12 = v14;
LABEL_34:
    ++v9;
    v8 += 20;
  }
  while (v9 < *((int *)a2 + 4));
  if (v10 & a4)
  {
    FloatLigne::AddRun(this, v11, v12, a3, a3);
  }
}

void FloatLigne::Over(FloatLigne *this, FloatLigne *a2, float a3)
{
  *(_DWORD *)this = 0;
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 4) = -1;
  *((void *)this + 5) = -1;
  if (*((int *)a2 + 4) < 1) {
    return;
  }
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  char v8 = 0;
  float v9 = 0.0;
  float v10 = 0.0;
  do
  {
    float v11 = (float *)(*((void *)a2 + 3) + v6);
    float v12 = *v11;
    float v13 = v11[1];
    float v14 = v11[2];
    float v15 = v11[3];
    if (v14 < a3)
    {
      if (v15 >= a3)
      {
        float v12 = (float)((float)(v13 * (float)(a3 - v14)) + (float)(v12 * (float)(v15 - a3))) / (float)(v15 - v14);
        if (v8) {
LABEL_16:
        }
          FloatLigne::AddRun(this, v9, v10, a3, a3);
LABEL_17:
        char v8 = 1;
        float v10 = v13;
        float v9 = v12;
        goto LABEL_22;
      }
      if ((v8 & 1) == 0) {
        goto LABEL_21;
      }
      float v16 = this;
      float v17 = v9;
      float v18 = v10;
LABEL_20:
      FloatLigne::AddRun(v16, v17, v18, a3, a3);
LABEL_21:
      char v8 = 0;
      goto LABEL_22;
    }
    if (v15 < a3)
    {
      float v19 = (float)((float)(v13 * (float)(v14 - a3)) + (float)(v12 * (float)(a3 - v15))) / (float)(v14 - v15);
      if (v8)
      {
        float v16 = this;
        if (v12 + -0.00001 <= v10)
        {
          float v17 = v9;
          goto LABEL_19;
        }
        FloatLigne::AddRun(this, v9, v10, a3, a3);
      }
      float v16 = this;
      float v17 = v12;
LABEL_19:
      float v18 = v19;
      goto LABEL_20;
    }
    if ((v8 & 1) == 0) {
      goto LABEL_17;
    }
    if (v12 + -0.00001 > v10) {
      goto LABEL_16;
    }
    char v8 = 1;
    float v10 = v11[1];
LABEL_22:
    ++v7;
    v6 += 20;
  }
  while (v7 < *((int *)a2 + 4));
  if (v8)
  {
    FloatLigne::AddRun(this, v9, v10, a3, a3);
  }
}

double FloatLigne::Enqueue(FloatLigne *this, int a2)
{
  if ((*((_DWORD *)this + 8) & 0x80000000) != 0)
  {
    *((_DWORD *)this + 8) = a2;
    *((_DWORD *)this + 9) = a2;
    double result = NAN;
    *(void *)(*((void *)this + 1) + 44 * a2 + 20) = -1;
  }
  else
  {
    uint64_t v2 = *((void *)this + 1);
    uint64_t v3 = v2 + 44 * a2;
    int v4 = *((_DWORD *)this + 9);
    *(_DWORD *)(v3 + 20) = v4;
    *(_DWORD *)(v3 + 24) = -1;
    *(_DWORD *)(v2 + 44 * v4 + 24) = a2;
    *((_DWORD *)this + 9) = a2;
  }
  return result;
}

double FloatLigne::Dequeue(FloatLigne *this, int a2)
{
  int v2 = *((_DWORD *)this + 9);
  if (*((_DWORD *)this + 8) == a2)
  {
    if (v2 == a2) {
      *((void *)this + 4) = -1;
    }
    else {
      *((_DWORD *)this + 8) = *(_DWORD *)(*((void *)this + 1) + 44 * a2 + 24);
    }
  }
  else if (v2 == a2)
  {
    *((_DWORD *)this + 9) = *(_DWORD *)(*((void *)this + 1) + 44 * a2 + 20);
  }
  uint64_t v3 = *((void *)this + 1);
  uint64_t v4 = v3 + 44 * a2;
  unsigned int v7 = *(_DWORD *)(v4 + 20);
  uint64_t v5 = (void *)(v4 + 20);
  unsigned int v6 = v7;
  if ((v7 & 0x80000000) == 0) {
    *(_DWORD *)(v3 + 44 * v6 + 24) = *(_DWORD *)(v3 + 44 * a2 + 24);
  }
  unsigned int v8 = *(_DWORD *)(v3 + 44 * a2 + 24);
  if ((v8 & 0x80000000) == 0) {
    *(_DWORD *)(v3 + 44 * v8 + 20) = v6;
  }
  double result = NAN;
  *uint64_t v5 = -1;
  return result;
}

void IntLigne::IntLigne(IntLigne *this)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((void *)this + 4) = -1;
}

{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((void *)this + 4) = -1;
}

void IntLigne::~IntLigne(void **this)
{
  if (*((int *)this + 1) >= 1)
  {
    free(this[1]);
    *this = 0;
    this[1] = 0;
  }
  if (*((int *)this + 5) >= 1)
  {
    free(this[3]);
    this[2] = 0;
    this[3] = 0;
  }
}

double IntLigne::Reset(IntLigne *this)
{
  *(_DWORD *)this = 0;
  *((_DWORD *)this + 4) = 0;
  double result = NAN;
  *((void *)this + 4) = -1;
  return result;
}

double IntLigne::AddBord(IntLigne *this, int a2, float a3, int a4, float a5)
{
  int v10 = *(_DWORD *)this;
  int v11 = v10 + 1;
  if (v10 + 1 >= *((_DWORD *)this + 1))
  {
    uint64_t v13 = 2 * v10 + 2;
    *((_DWORD *)this + 1) = v13;
    float v12 = (char *)malloc_type_realloc(*((void **)this + 1), 24 * v13, 0x1000040C4EE764BuLL);
    *((void *)this + 1) = v12;
    int v10 = *(_DWORD *)this;
    int v11 = *(_DWORD *)this + 1;
  }
  else
  {
    float v12 = (char *)*((void *)this + 1);
  }
  float v14 = (float *)&v12[24 * v10];
  *(_DWORD *)float v14 = a2;
  v14[2] = a3;
  *((unsigned char *)v14 + 4) = 1;
  *((_DWORD *)v14 + 3) = v11;
  double result = NAN;
  *((void *)v14 + 2) = -1;
  *(_DWORD *)this = v10 + 2;
  float v16 = (float *)&v12[24 * v11];
  *(_DWORD *)float v16 = a4;
  v16[2] = a5;
  *((unsigned char *)v16 + 4) = 0;
  *((_DWORD *)v16 + 3) = v10;
  *((void *)v16 + 2) = -1;
  return result;
}

double IntLigne::RemainingValAt(IntLigne *this, int a2)
{
  uint64_t v2 = *((unsigned int *)this + 8);
  if ((v2 & 0x80000000) != 0) {
    return 0.0;
  }
  uint64_t v3 = *((void *)this + 1);
  double result = 0.0;
  do
  {
    uint64_t v5 = v3 + 24 * v2;
    uint64_t v6 = v3 + 24 * *(int *)(v5 + 12);
    *(float *)&double result = *(float *)&result
                      + (float)((float)((float)(*(float *)(v6 + 8) * (float)(*(_DWORD *)v5 - a2))
                                      + (float)((float)(a2 - *(_DWORD *)v6) * *(float *)(v5 + 8)))
                              / (float)(*(_DWORD *)v5 - *(_DWORD *)v6));
    uint64_t v2 = *(unsigned int *)(v5 + 20);
  }
  while ((v2 & 0x80000000) == 0);
  return result;
}

void IntLigne::Flatten(IntLigne *this)
{
  uint64_t v2 = *(unsigned int *)this;
  if ((int)v2 > 1)
  {
    uint64_t v3 = 0;
    *((_DWORD *)this + 4) = 0;
    *((void *)this + 4) = -1;
    uint64_t v4 = (char *)*((void *)this + 1);
    uint64_t v5 = 16;
    do
    {
      *(_DWORD *)&v4[v5] = v3++;
      v5 += 24;
    }
    while (v2 != v3);
    qsort(v4, (int)v2, 0x18uLL, (int (__cdecl *)(const void *, const void *))IntLigne::CmpBord);
    uint64_t v6 = *(unsigned int *)this;
    if ((int)v6 >= 1)
    {
      uint64_t v7 = 0;
      uint64_t v8 = *((void *)this + 1);
      float v9 = (int *)(v8 + 16);
      do
      {
        int v10 = *v9;
        v9 += 6;
        *(_DWORD *)(v8 + 24 * v10 + 20) = v7++;
      }
      while (v6 != v7);
      uint64_t v11 = *((void *)this + 1);
      float v12 = (int *)(v11 + 12);
      uint64_t v13 = v6;
      do
      {
        *float v12 = *(_DWORD *)(v11 + 24 * *v12 + 20);
        v12 += 6;
        --v13;
      }
      while (v13);
      int v14 = 0;
      BOOL v15 = 0;
      int v16 = 0;
      float v17 = 0.0;
      do
      {
        uint64_t v18 = *((void *)this + 1);
        int v19 = *(_DWORD *)(v18 + 24 * v14);
        if (v14 >= (int)v6)
        {
          float v22 = 0.0;
        }
        else
        {
          uint64_t v20 = 24 * v14;
          uint64_t v21 = v14 + 1;
          float v22 = 0.0;
          while (!*(unsigned char *)(v18 + v20 + 4))
          {
            IntLigne::Dequeue(this, v14);
            uint64_t v18 = *((void *)this + 1);
            float v22 = v22 + *(float *)(v18 + v20 + 8);
            uint64_t v6 = *(int *)this;
            if (v21 >= v6)
            {
              ++v14;
              break;
            }
            int v23 = *(_DWORD *)(v18 + v20 + 24);
            ++v14;
            v20 += 24;
            ++v21;
            if (v23 != v19) {
              break;
            }
          }
        }
        double v24 = IntLigne::RemainingValAt(this, v19);
        float v25 = *(float *)&v24;
        float v26 = 0.0;
        if (v14 < (int)v6)
        {
          uint64_t v27 = v14;
          uint64_t v28 = *((void *)this + 1);
          if (*(_DWORD *)(v28 + 24 * v14) == v19)
          {
            uint64_t v29 = 24 * v14;
            do
            {
              uint64_t v30 = v28 + v29;
              if (!*(unsigned char *)(v30 + 4)) {
                break;
              }
              float v26 = v26 + *(float *)(v30 + 8);
              IntLigne::Enqueue(this, *(_DWORD *)(v30 + 12));
              ++v27;
              uint64_t v6 = *(int *)this;
              if (v27 >= v6) {
                break;
              }
              uint64_t v28 = *((void *)this + 1);
              int v31 = *(_DWORD *)(v28 + v29 + 24);
              v29 += 24;
            }
            while (v31 == v19);
          }
          int v14 = v27;
        }
        if (v15)
        {
          IntLigne::AddRun(this, v16, v19, v17, v22 + v25);
          LODWORD(v6) = *(_DWORD *)this;
        }
        int v32 = *((_DWORD *)this + 8);
        BOOL v15 = v32 >= 0;
        if (v32 >= 0)
        {
          int v16 = v19;
          float v17 = v25 + v26;
        }
      }
      while (v14 < (int)v6);
    }
  }
  else
  {
    *(_DWORD *)this = 0;
    *((_DWORD *)this + 4) = 0;
    *((void *)this + 4) = -1;
  }
}

uint64_t IntLigne::CmpBord(IntLigne *this, unsigned char *a2, const void *a3)
{
  if (*(_DWORD *)this == *(_DWORD *)a2)
  {
    if (*((unsigned char *)this + 4))
    {
      if (!a2[4]) {
        return 1;
      }
    }
    else if (a2[4])
    {
      return 0xFFFFFFFFLL;
    }
    return 0;
  }
  else if (*(_DWORD *)this < *(_DWORD *)a2)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return 1;
  }
}

double IntLigne::Dequeue(IntLigne *this, int a2)
{
  int v2 = *((_DWORD *)this + 9);
  if (*((_DWORD *)this + 8) == a2)
  {
    if (v2 == a2) {
      *((void *)this + 4) = -1;
    }
    else {
      *((_DWORD *)this + 8) = *(_DWORD *)(*((void *)this + 1) + 24 * a2 + 20);
    }
  }
  else if (v2 == a2)
  {
    *((_DWORD *)this + 9) = *(_DWORD *)(*((void *)this + 1) + 24 * a2 + 16);
  }
  uint64_t v3 = *((void *)this + 1);
  uint64_t v4 = v3 + 24 * a2;
  unsigned int v7 = *(_DWORD *)(v4 + 16);
  uint64_t v5 = (void *)(v4 + 16);
  unsigned int v6 = v7;
  if ((v7 & 0x80000000) == 0) {
    *(_DWORD *)(v3 + 24 * v6 + 20) = *(_DWORD *)(v3 + 24 * a2 + 20);
  }
  unsigned int v8 = *(_DWORD *)(v3 + 24 * a2 + 20);
  if ((v8 & 0x80000000) == 0) {
    *(_DWORD *)(v3 + 24 * v8 + 16) = v6;
  }
  double result = NAN;
  *uint64_t v5 = -1;
  return result;
}

double IntLigne::Enqueue(IntLigne *this, int a2)
{
  if ((*((_DWORD *)this + 8) & 0x80000000) != 0)
  {
    *((_DWORD *)this + 8) = a2;
    *((_DWORD *)this + 9) = a2;
    double result = NAN;
    *(void *)(*((void *)this + 1) + 24 * a2 + 16) = -1;
  }
  else
  {
    uint64_t v2 = *((void *)this + 1);
    uint64_t v3 = v2 + 24 * a2;
    int v4 = *((_DWORD *)this + 9);
    *(_DWORD *)(v3 + 16) = v4;
    *(_DWORD *)(v3 + 20) = -1;
    *(_DWORD *)(v2 + 24 * v4 + 20) = a2;
    *((_DWORD *)this + 9) = a2;
  }
  return result;
}

uint64_t IntLigne::AddRun(IntLigne *this, int a2, int a3, float a4, float a5)
{
  if (a2 >= a3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = *((unsigned int *)this + 4);
  if ((int)result >= *((_DWORD *)this + 5))
  {
    int v12 = (2 * result) | 1;
    *((_DWORD *)this + 5) = v12;
    uint64_t v11 = (char *)malloc_type_realloc(*((void **)this + 3), 16 * v12, 0x1000040451B5BE8uLL);
    *((void *)this + 3) = v11;
    uint64_t result = *((unsigned int *)this + 4);
  }
  else
  {
    uint64_t v11 = (char *)*((void *)this + 3);
  }
  *((_DWORD *)this + 4) = result + 1;
  uint64_t v13 = &v11[16 * (int)result];
  *(_DWORD *)uint64_t v13 = a2;
  *((_DWORD *)v13 + 1) = a3;
  *((float *)v13 + 2) = a4;
  *((float *)v13 + 3) = a5;
  return result;
}

uint64_t IntLigne::Affiche(IntLigne *this)
{
  printf("%i : \n", *((_DWORD *)this + 4));
  if (*((int *)this + 4) >= 1)
  {
    uint64_t v2 = 0;
    uint64_t v3 = 0;
    do
    {
      printf("(%i %f -> %i %f) ", *(_DWORD *)(*((void *)this + 3) + v2), *(float *)(*((void *)this + 3) + v2 + 8), *(_DWORD *)(*((void *)this + 3) + v2 + 4), *(float *)(*((void *)this + 3) + v2 + 12));
      ++v3;
      v2 += 16;
    }
    while (v3 < *((int *)this + 4));
  }

  return putchar(10);
}

uint64_t IntLigne::Booleen(uint64_t result, uint64_t a2, IntLigne *a3, unsigned int a4)
{
  uint64_t v5 = a3;
  *(_DWORD *)uint64_t result = 0;
  *(_DWORD *)(result + 16) = 0;
  float v72 = (IntLigne *)result;
  *(void *)(result + 32) = -1;
  int v6 = *(_DWORD *)(a2 + 16);
  int v7 = *((_DWORD *)a3 + 4);
  if (v6 <= 0)
  {
    if (v7 < 1 || a4 && a4 != 3) {
      return result;
    }
    goto LABEL_114;
  }
  if (v7 <= 0)
  {
    if (a4 > 3) {
      return result;
    }
    uint64_t v5 = (IntLigne *)a2;
    if (a4 == 1) {
      return result;
    }
LABEL_114:
    return (uint64_t)IntLigne::Copy((void **)result, v5);
  }
  uint64_t v9 = *(void *)(a2 + 24);
  int v10 = *(_DWORD *)v9;
  uint64_t v11 = *((void *)a3 + 3);
  int v12 = *(_DWORD *)v11;
  float v13 = 0.0;
  float v14 = 0.0;
  if (*(_DWORD *)v9 >= *(_DWORD *)v11) {
    int v15 = *(_DWORD *)v11;
  }
  else {
    int v15 = *(_DWORD *)v9;
  }
  if (v10 <= v12) {
    float v14 = *(float *)(v9 + 8);
  }
  if (v12 <= v10) {
    float v13 = *(float *)(v11 + 8);
  }
  if (*((int *)a3 + 4) < 1)
  {
    LODWORD(v16) = 0;
    LODWORD(v17) = 0;
  }
  else
  {
    uint64_t v16 = 0;
    LODWORD(v17) = 0;
    int v18 = v15;
    do
    {
      uint64_t v19 = *(void *)(a2 + 24) + 16 * (int)v17;
      int v20 = *(_DWORD *)v19;
      int v21 = *(_DWORD *)(v19 + 4);
      uint64_t v22 = *((void *)v5 + 3) + 16 * (int)v16;
      int v23 = *(_DWORD *)v22;
      int v24 = *(_DWORD *)(v22 + 4);
      BOOL v25 = v18 < v21 && v18 >= *(_DWORD *)v19;
      BOOL v27 = v18 >= v23 && v18 < v24;
      uint64_t v73 = v16;
      if (v18 >= v20)
      {
        if (v18 >= v23)
        {
          BOOL v36 = v21 == v24;
          if (v21 >= v24)
          {
            int v37 = 1;
          }
          else
          {
            BOOL v36 = 1;
            int v37 = 0;
          }
          if (v21 >= v24) {
            int v38 = *(_DWORD *)(v22 + 4);
          }
          else {
            int v38 = *(_DWORD *)(v19 + 4);
          }
          uint64_t result = v21 < v24 || v21 == v24;
          if (v21 >= v24) {
            int v39 = *(_DWORD *)(v22 + 4);
          }
          else {
            int v39 = *(_DWORD *)(v19 + 4);
          }
          int v32 = 0;
          BOOL v33 = 0;
          if (v18 == v23) {
            int v34 = result;
          }
          else {
            int v34 = v36;
          }
          if (v18 == v23) {
            BOOL v35 = v21 >= v24;
          }
          else {
            BOOL v35 = v37;
          }
          if (v18 == v23) {
            int v15 = v39;
          }
          else {
            int v15 = v38;
          }
        }
        else
        {
          int v32 = 0;
          BOOL v33 = v21 >= v23;
          int v34 = v21 < v23 || v21 == v23;
          BOOL v35 = 0;
          if (v21 >= v23) {
            int v15 = *(_DWORD *)v22;
          }
          else {
            int v15 = *(_DWORD *)(v19 + 4);
          }
        }
      }
      else
      {
        BOOL v28 = v20 == v24;
        if (v20 >= v24)
        {
          int v29 = 1;
        }
        else
        {
          BOOL v28 = 1;
          int v29 = 0;
        }
        if (v20 >= v24) {
          int v30 = *(_DWORD *)(v22 + 4);
        }
        else {
          int v30 = *(_DWORD *)v19;
        }
        uint64_t result = v20 < v23 || v20 == v23;
        if (v20 >= v23) {
          int v31 = *(_DWORD *)v22;
        }
        else {
          int v31 = *(_DWORD *)v19;
        }
        if (v18 < v23) {
          int v32 = result;
        }
        else {
          int v32 = v28;
        }
        BOOL v33 = v18 < v23 && v20 >= v23;
        int v34 = 0;
        if (v18 < v23) {
          BOOL v35 = 0;
        }
        else {
          BOOL v35 = v29;
        }
        if (v18 < v23) {
          int v15 = v31;
        }
        else {
          int v15 = v30;
        }
      }
      float v40 = *(float *)(v19 + 8);
      float v41 = 0.0;
      float v42 = 0.0;
      if (v25) {
        float v42 = (float)((float)(v40 * (float)(v21 - v15)) + (float)((float)(v15 - v20) * *(float *)(v19 + 12)))
      }
            / (float)(v21 - v20);
      float v43 = *(float *)(v22 + 8);
      if (v27) {
        float v41 = (float)((float)(v43 * (float)(v24 - v15)) + (float)((float)(v15 - v23) * *(float *)(v22 + 12)))
      }
            / (float)(v24 - v23);
      switch(a4)
      {
        case 0u:
          if (v25 || v27)
          {
            float v44 = v13 + v14;
            float v45 = v42 + v41;
            goto LABEL_89;
          }
          break;
        case 1u:
          if (v25 && v27)
          {
            float v44 = v13 * v14;
            float v45 = v42 * v41;
            goto LABEL_89;
          }
          break;
        case 2u:
          if (v25)
          {
            float v44 = v14 - v13;
            float v45 = v42 - v41;
            goto LABEL_89;
          }
          break;
        case 3u:
          if (!v27 && v25)
          {
            BOOL v70 = v35;
            uint64_t result = IntLigne::AddRun(v72, v18, v15, v14 - v13, v42 - v41);
            BOOL v35 = v70;
          }
          if (!v25 && v27)
          {
            float v44 = v13 - v14;
            float v45 = v41 - v42;
LABEL_89:
            BOOL v46 = v35;
            uint64_t result = IntLigne::AddRun(v72, v18, v15, v44, v45);
            BOOL v35 = v46;
          }
          break;
        default:
          break;
      }
      if (v32) {
        float v14 = v40;
      }
      else {
        float v14 = v42;
      }
      if (v33) {
        float v13 = v43;
      }
      else {
        float v13 = v41;
      }
      if (v34)
      {
        uint64_t v17 = (int)v17 + 1;
        float v14 = 0.0;
        uint64_t v5 = a3;
        uint64_t v16 = v73;
        if ((int)v17 < *(_DWORD *)(a2 + 16))
        {
          uint64_t v47 = *(void *)(a2 + 24);
          if (*(_DWORD *)(v47 + 16 * v17) == v15) {
            float v14 = *(float *)(v47 + 16 * v17 + 8);
          }
        }
      }
      else
      {
        uint64_t v5 = a3;
        uint64_t v16 = v73;
      }
      if (v35)
      {
        uint64_t v16 = (int)v16 + 1;
        float v13 = 0.0;
        if ((int)v16 < *((_DWORD *)v5 + 4))
        {
          uint64_t v48 = *((void *)v5 + 3);
          if (*(_DWORD *)(v48 + 16 * v16) == v15) {
            float v13 = *(float *)(v48 + 16 * v16 + 8);
          }
        }
      }
      int v6 = *(_DWORD *)(a2 + 16);
      if ((int)v17 >= v6) {
        break;
      }
      int v18 = v15;
    }
    while ((int)v16 < *((_DWORD *)v5 + 4));
  }
  if ((int)v17 < v6)
  {
    while (1)
    {
      int v49 = v15;
      uint64_t v50 = *(void *)(a2 + 24) + 16 * (int)v17;
      int v52 = *(_DWORD *)v50;
      int v51 = *(_DWORD *)(v50 + 4);
      float v53 = *(float *)(v50 + 8);
      BOOL v54 = v15 >= *(_DWORD *)v50;
      if (v15 >= *(_DWORD *)v50) {
        int v15 = *(_DWORD *)(v50 + 4);
      }
      else {
        int v15 = *(_DWORD *)v50;
      }
      if (v49 >= v51) {
        BOOL v54 = 0;
      }
      float v55 = 0.0;
      if (v54) {
        float v55 = (float)((float)(v53 * (float)(v51 - v15)) + (float)((float)(v15 - v52) * *(float *)(v50 + 12)))
      }
            / (float)(v51 - v52);
      if (a4 == 3 || a4 == 2)
      {
        if (!v54) {
          goto LABEL_134;
        }
        float v56 = v14 - v13;
      }
      else
      {
        if (a4 || !v54) {
          goto LABEL_134;
        }
        float v56 = v13 + v14;
        float v55 = v55 + 0.0;
      }
      uint64_t result = IntLigne::AddRun(v72, v49, v15, v56, v55);
LABEL_134:
      int v57 = *(_DWORD *)(a2 + 16);
      if (v49 >= v52)
      {
        uint64_t v17 = (int)v17 + 1;
        float v53 = 0.0;
        if ((int)v17 < v57)
        {
          uint64_t v58 = *(void *)(a2 + 24);
          if (*(_DWORD *)(v58 + 16 * v17) == v51) {
            float v53 = *(float *)(v58 + 16 * v17 + 8);
          }
        }
      }
      float v13 = 0.0;
      float v14 = v53;
      if ((int)v17 >= v57) {
        goto LABEL_141;
      }
    }
  }
  float v53 = v14;
LABEL_141:
  if ((int)v16 < *((_DWORD *)v5 + 4))
  {
    LODWORD(v59) = v16;
    do
    {
      int v60 = v15;
      uint64_t v61 = *((void *)v5 + 3) + 16 * (int)v59;
      int v63 = *(_DWORD *)v61;
      int v62 = *(_DWORD *)(v61 + 4);
      float v64 = *(float *)(v61 + 8);
      BOOL v65 = v15 >= *(_DWORD *)v61;
      if (v15 >= *(_DWORD *)v61) {
        int v15 = *(_DWORD *)(v61 + 4);
      }
      else {
        int v15 = *(_DWORD *)v61;
      }
      if (v60 >= v62) {
        BOOL v65 = 0;
      }
      float v66 = 0.0;
      if (v65) {
        float v66 = (float)((float)(v64 * (float)(v62 - v15)) + (float)((float)(v15 - v63) * *(float *)(v61 + 12)))
      }
            / (float)(v62 - v63);
      if (a4 == 3)
      {
        if (!v65) {
          goto LABEL_157;
        }
        float v67 = v13 - v53;
      }
      else
      {
        if (a4 || !v65) {
          goto LABEL_157;
        }
        float v67 = v13 + v53;
        float v66 = v66 + 0.0;
      }
      uint64_t result = IntLigne::AddRun(v72, v60, v15, v67, v66);
LABEL_157:
      int v68 = *((_DWORD *)v5 + 4);
      if (v60 >= v63)
      {
        uint64_t v59 = (int)v59 + 1;
        float v64 = 0.0;
        if ((int)v59 < v68)
        {
          uint64_t v69 = *((void *)v5 + 3);
          if (*(_DWORD *)(v69 + 16 * v59) == v62) {
            float v64 = *(float *)(v69 + 16 * v59 + 8);
          }
        }
      }
      float v53 = 0.0;
      float v13 = v64;
    }
    while ((int)v59 < v68);
  }
  return result;
}

void **IntLigne::Copy(void **this, IntLigne *a2)
{
  uint64_t v2 = this;
  uint64_t v3 = *((unsigned int *)a2 + 4);
  *(_DWORD *)this = 0;
  if ((int)v3 <= 0)
  {
    *((_DWORD *)this + 4) = 0;
    this[4] = (void *)-1;
  }
  else
  {
    *((_DWORD *)this + 4) = v3;
    if ((int)v3 <= *((_DWORD *)this + 5))
    {
      uint64_t v5 = this[3];
    }
    else
    {
      *((_DWORD *)this + 5) = v3;
      uint64_t v5 = malloc_type_realloc(this[3], 16 * v3, 0x1000040451B5BE8uLL);
      v2[3] = v5;
      LODWORD(v3) = *((_DWORD *)v2 + 4);
    }
    int v6 = (const void *)*((void *)a2 + 3);
    return (void **)memcpy(v5, v6, 16 * (int)v3);
  }
  return this;
}

uint64_t IntLigne::Copy(uint64_t this, FloatLigne *a2)
{
  int v2 = *((_DWORD *)a2 + 4);
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 16) = 0;
  *(void *)(this + 32) = -1;
  if (v2 < 1) {
    return this;
  }
  int v4 = (IntLigne *)this;
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  char v7 = 0;
  int v8 = (int)**((float **)a2 + 3) - 1;
  float v9 = 0.0;
  do
  {
    int v10 = (float *)(*((void *)a2 + 3) + v5);
    float v11 = *v10;
    float v12 = v10[1];
    float v13 = v10[2];
    float v14 = v10[3];
    float v15 = v10[4];
    float v16 = floorf(*v10);
    int v17 = vcvtms_s32_f32(*v10);
    double v18 = (float)(*v10 - v16);
    float v19 = v16 + 1.0;
    if (v18 < 0.00001) {
      int v20 = v17;
    }
    else {
      int v20 = v17 + 1;
    }
    if (v18 < 0.00001) {
      float v19 = v16;
    }
    float v21 = v10[2];
    if (v11 != (float)v20)
    {
      float v21 = v10[3];
      if (v12 != (float)v20) {
        float v21 = v13 + (float)((float)(v19 - v11) * v15);
      }
    }
    float v22 = floorf(v12);
    int v23 = vcvtms_s32_f32(v12);
    float v24 = v10[2];
    if (v11 != (float)v23)
    {
      float v24 = v10[3];
      if (v12 != (float)v23) {
        float v24 = v13 + (float)((float)(v22 - v11) * v15);
      }
    }
    double v25 = (float)(v12 - v22);
    if (v18 >= 0.00001)
    {
      if (v25 < 0.00001 || v23 > v17)
      {
        if (v7)
        {
          if (v8 >= v17)
          {
            double v29 = v9 + (float)(v21 + v13) * 0.5 * (v16 + 1.0 - v11);
            goto LABEL_26;
          }
          IntLigne::AddRun(v4, v8, v8 + 1, v9, v9);
          float v26 = (float *)(*((void *)a2 + 3) + v5);
          double v27 = (float)(v21 + v26[2]) * 0.5;
          double v28 = v16 + 1.0 - *v26;
        }
        else
        {
          double v28 = (float)(v21 + v13) * 0.5;
          double v27 = v16 + 1.0 - v11;
        }
        double v29 = v27 * v28;
LABEL_26:
        float v9 = v29;
        this = IntLigne::AddRun(v4, v17, v17 + 1, v9, v9);
        char v7 = 0;
        goto LABEL_27;
      }
      if ((v7 & 1) == 0)
      {
        double v30 = (float)(v14 + v13) * 0.5 * (float)(v12 - v11);
        goto LABEL_41;
      }
      if (v8 < v17)
      {
        this = IntLigne::AddRun(v4, v8, v8 + 1, v9, v9);
        double v30 = (float)(*(float *)(*((void *)a2 + 3) + v5 + 12) + *(float *)(*((void *)a2 + 3) + v5 + 8))
            * 0.5
            * (float)(*(float *)(*((void *)a2 + 3) + v5 + 4) - *(float *)(*((void *)a2 + 3) + v5));
LABEL_41:
        float v9 = v30;
        char v7 = 1;
        int v8 = v17;
        goto LABEL_27;
      }
      float v9 = v9 + (float)(v14 + v13) * 0.5 * (float)(v12 - v11);
      char v7 = 1;
    }
LABEL_27:
    if (v20 < v23)
    {
      if ((v7 & (v8 < v20)) == 1) {
        IntLigne::AddRun(v4, v8, v8 + 1, v9, v9);
      }
      this = IntLigne::AddRun(v4, v20, v23, v21, v24);
      char v7 = 0;
    }
    if (v25 >= 0.00001)
    {
      if (v23 <= v17)
      {
        if (v18 >= 0.00001) {
          goto LABEL_38;
        }
        if (v7) {
          this = IntLigne::AddRun(v4, v8, v8 + 1, v9, v9);
        }
        float v24 = v21;
      }
      float v9 = (float)(v24 + *(float *)(*((void *)a2 + 3) + v5 + 12))
         * 0.5
         * (float)(*(float *)(*((void *)a2 + 3) + v5 + 4) - v22);
      char v7 = 1;
      int v8 = v23;
    }
LABEL_38:
    ++v6;
    v5 += 20;
  }
  while (v6 < *((int *)a2 + 4));
  if (v7)
  {
    return IntLigne::AddRun(v4, v8, v8 + 1, v9, v9);
  }
  return this;
}

void Path::Path(Path *this)
{
  this->var2 = 0;
  *(void *)&this->var0 = 0;
  this->var3 = 0;
  *(void *)&this->var4 = -1;
  *(_WORD *)&this->var6 = 0;
  *(void *)&this->var10 = 0;
  *(void *)&this->var8 = 0;
  HIDWORD(this->var11) = 0;
}

{
  this->var2 = 0;
  *(void *)&this->var0 = 0;
  this->var3 = 0;
  *(void *)&this->var4 = -1;
  *(_WORD *)&this->var6 = 0;
  *(void *)&this->var10 = 0;
  *(void *)&this->var8 = 0;
  HIDWORD(this->var11) = 0;
}

void Path::~Path(Path *this)
{
  var3 = this->var3;
  if (var3)
  {
    free(var3);
    this->var3 = 0;
  }
  var11 = this->var11;
  if (var11) {
    free(var11);
  }
  this->var1 = 0;
  this->var2 = 0;
  this->var3 = 0;
  *(void *)&this->var10 = 0;
  *(void *)&this->var8 = 0;
  HIDWORD(this->var11) = 0;
}

uint64_t Path::Affiche(Path *this)
{
  uint64_t result = printf("path descr %i elems\n", this->var2);
  if (this->var2 >= 1)
  {
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    do
    {
      printf("  ");
      uint64_t result = printf("[ %i %f %f ] ", *(_DWORD *)((char *)this->var3 + v3 + 4), *(float *)((char *)this->var3 + v3 + 8), *(float *)((char *)this->var3 + v3 + 12));
      int v5 = *(_DWORD *)((char *)this->var3 + v3);
      if ((v5 & 0x10) != 0)
      {
        uint64_t result = printf(" w ");
        int v5 = *(_DWORD *)((char *)this->var3 + v3);
      }
      switch(v5 & 0xF)
      {
        case 0:
          uint64_t result = printf("M %f %f %i\n");
          break;
        case 1:
          uint64_t result = printf("L %f %f\n");
          break;
        case 2:
          uint64_t result = printf("C %f %f %f %f %f %f\n");
          break;
        case 3:
          uint64_t result = printf("B %f %f %i\n");
          break;
        case 4:
          uint64_t result = printf("A %f %f %f %f %i %i\n");
          break;
        case 5:
          uint64_t v6 = "Z";
          goto LABEL_15;
        case 6:
          uint64_t result = printf("I %f %f\n");
          break;
        case 7:
          uint64_t v6 = "F";
LABEL_15:
          uint64_t result = puts(v6);
          break;
        default:
          break;
      }
      ++v4;
      v3 += 44;
    }
    while (v4 < this->var2);
  }
  return result;
}

double Path::Reset(Path *this)
{
  this->var2 = 0;
  double result = NAN;
  *(void *)&this->var4 = -1;
  this->var0 = 0;
  return result;
}

void *Path::Copy(Path *this, Path *a2)
{
  Path::ResetPoints(this, 0);
  int var2 = a2->var2;
  if (var2 > this->var1)
  {
    this->var1 = var2;
    this->var3 = (path_descr *)malloc_type_realloc(this->var3, 44 * var2, 0x1000040D4159EFEuLL);
  }
  Path::SetWeighted(this, a2->var6);
  int v5 = a2->var2;
  this->int var2 = v5;
  var3 = this->var3;
  char v7 = a2->var3;

  return memcpy(var3, v7, 44 * v5);
}

Path *Path::ResetPoints(Path *this, int a2)
{
  this->var8 = 0;
  int v2 = 12 * a2;
  if (this->var6)
  {
    int v2 = 16 * a2;
    int v3 = 24 * a2;
  }
  else
  {
    int v3 = 20 * a2;
  }
  if (this->var7) {
    int v4 = v3;
  }
  else {
    int v4 = v2;
  }
  this->var10 = v4;
  if (v4 > this->var9)
  {
    int v5 = this;
    this->var9 = v4;
    this = (Path *)malloc_type_realloc(this->var11, v4, 0x5CE81E30uLL);
    v5->var11 = (char *)this;
  }
  return this;
}

Path *Path::SetWeighted(Path *this, int a2)
{
  if (a2)
  {
    if (this->var6) {
      return this;
    }
    BOOL v2 = 1;
  }
  else
  {
    if (!this->var6) {
      return this;
    }
    BOOL v2 = 0;
  }
  this->var6 = v2;
  return Path::ResetPoints(this, this->var8);
}

Path *Path::Alloue(Path *this, int a2)
{
  int var2 = this->var2;
  if (var2 + a2 > this->var1)
  {
    int v3 = this;
    int v4 = a2 + 2 * var2;
    this->var1 = v4;
    this = (Path *)malloc_type_realloc(this->var3, 44 * v4, 0x1000040D4159EFEuLL);
    v3->var3 = (path_descr *)this;
  }
  return this;
}

Path *Path::CloseSubpath(Path *this, int a2)
{
  int var2 = this->var2;
  uint64_t v3 = 44 * var2;
  while (1)
  {
    BOOL v4 = __OFSUB__(var2--, 1);
    if (var2 < 0 != v4) {
      break;
    }
    var3 = this->var3;
    uint64_t v6 = (char *)var3 + v3;
    ++a2;
    v3 -= 44;
    if ((*(v6 - 44) & 0xF) == 0)
    {
      *(_DWORD *)((char *)var3 + v3 + 24) = a2;
      break;
    }
  }
  this->var0 &= ~2u;
  this->var5 = -1;
  return this;
}

double Path::ForcePoint(Path *this)
{
  int var0 = this->var0;
  if (this->var0)
  {
    if ((var0 & 4) != 0)
    {
      var0 &= 0xFFFFFFFA;
      this->int var0 = var0;
      int var4 = this->var4;
      if ((var4 & 0x80000000) == 0)
      {
        this->int var2 = var4;
        this->int var4 = -1;
      }
    }
    else
    {
      this->int var4 = -1;
      var0 &= 0xFFFFFFFA;
      this->int var0 = var0;
    }
  }
  if ((var0 & 2) != 0)
  {
    Path::Alloue(this, 1);
    int var2 = this->var2;
    int v5 = (void *)((char *)this->var3 + 44 * var2);
    this->int var2 = var2 + 1;
    double result = 0.0078125;
    *int v5 = 0xFFFFFFFF00000007;
    v5[1] = 0x3F80000000000000;
  }
  return result;
}

uint64_t Path::EndBezierTo(Path *this)
{
  int var0 = this->var0;
  if ((this->var0 & 4) != 0)
  {
    this->int var0 = var0 & 0xFFFFFFFA;
    int var4 = this->var4;
    if ((var4 & 0x80000000) == 0)
    {
      this->int var2 = var4;
      this->int var4 = -1;
    }
  }
  else
  {
    this->int var4 = -1;
    this->int var0 = var0 & 0xFFFFFFFA;
  }
  return 0xFFFFFFFFLL;
}

uint64_t Path::Close(Path *this)
{
  int var0 = this->var0;
  if (this->var0)
  {
    var0 &= 0xFFFFFFFA;
    this->int var0 = var0;
    int var4 = this->var4;
    if ((var4 & 0x80000000) == 0)
    {
      this->uint64_t var2 = var4;
      this->int var4 = -1;
    }
  }
  uint64_t v4 = 0xFFFFFFFFLL;
  if ((var0 & 2) != 0)
  {
    Path::CloseSubpath(this, 1);
    Path::Alloue(this, 1);
    uint64_t var2 = this->var2;
    uint64_t v6 = (void *)((char *)this->var3 + 44 * (int)var2);
    this->uint64_t var2 = var2 + 1;
    *uint64_t v6 = -4294967291;
    v6[1] = 0x3F80000000000000;
    this->var0 &= ~2u;
    this->var5 = -1;
    return var2;
  }
  return v4;
}

Path *Path::CancelBezier(Path *this)
{
  this->var0 &= 0xFFFFFFFA;
  int var4 = this->var4;
  if ((var4 & 0x80000000) == 0)
  {
    this->uint64_t var2 = var4;
    this->int var4 = -1;
  }
  return this;
}

uint64_t Path::MoveTo(Path *this, float a2, float a3)
{
  int var0 = this->var0;
  if (this->var0)
  {
    Path::EndBezierTo(this, a2, a3);
    int var0 = this->var0;
  }
  if ((var0 & 2) != 0) {
    Path::CloseSubpath(this, 0);
  }
  this->var5 = this->var2;
  Path::Alloue(this, 1);
  int var2 = this->var2;
  int v8 = (char *)this->var3 + 44 * var2;
  this->int var2 = var2 + 1;
  *(void *)int v8 = 0xFFFFFFFF00000000;
  *((void *)v8 + 1) = 0x3F80000000000000;
  *((float *)v8 + 4) = a2;
  *((float *)v8 + 5) = a3;
  *((_DWORD *)v8 + 6) = 0;
  this->var0 |= 2u;
  return (this->var2 - 1);
}

uint64_t Path::EndBezierTo(Path *this, float a2, float a3)
{
  int var0 = this->var0;
  if ((this->var0 & 1) == 0) {
    return Path::LineTo(this, a2, a3);
  }
  if ((var0 & 2) == 0) {
    return Path::MoveTo(this, a2, a3);
  }
  if ((var0 & 4) != 0)
  {
    *((float *)this->var3 + 11 * this->var4 + 5) = a2;
    *((float *)this->var3 + 11 * this->var4 + 6) = a3;
    var3 = this->var3;
    int var4 = this->var4;
    if ((*((unsigned char *)var3 + 44 * var4) & 0x10) != 0) {
      *((_DWORD *)var3 + 11 * var4 + 7) = 1065353216;
    }
    this->int var4 = -1;
    int var0 = this->var0;
  }
  else
  {
    this->int var4 = -1;
  }
  this->int var0 = var0 & 0xFFFFFFFA;
  return 0xFFFFFFFFLL;
}

uint64_t Path::MoveTo(Path *this, float a2, float a3, float a4)
{
  int var0 = this->var0;
  if (this->var0)
  {
    Path::EndBezierTo(this, a2, a3, a4);
    int var0 = this->var0;
  }
  if ((var0 & 2) != 0) {
    Path::CloseSubpath(this, 0);
  }
  this->var5 = this->var2;
  Path::Alloue(this, 1);
  int var2 = this->var2;
  int v10 = (char *)this->var3 + 44 * var2;
  this->int var2 = var2 + 1;
  *(void *)int v10 = 0xFFFFFFFF00000010;
  *((void *)v10 + 1) = 0x3F80000000000000;
  *((float *)v10 + 4) = a2;
  *((float *)v10 + 5) = a3;
  *((float *)v10 + 7) = a4;
  *((_DWORD *)v10 + 6) = 0;
  this->var0 |= 2u;
  return (this->var2 - 1);
}

uint64_t Path::EndBezierTo(Path *this, float a2, float a3, float a4)
{
  int var0 = this->var0;
  if ((this->var0 & 1) == 0) {
    return Path::LineTo(this, a2, a3, a4);
  }
  if ((var0 & 2) == 0) {
    return Path::MoveTo(this, a2, a3, a4);
  }
  if ((var0 & 4) != 0)
  {
    *((float *)this->var3 + 11 * this->var4 + 5) = a2;
    *((float *)this->var3 + 11 * this->var4 + 6) = a3;
    *((float *)this->var3 + 11 * this->var4 + 7) = a4;
    this->int var4 = -1;
    int var0 = this->var0;
  }
  else
  {
    this->int var4 = -1;
  }
  this->int var0 = var0 & 0xFFFFFFFA;
  return 0xFFFFFFFFLL;
}

uint64_t Path::LineTo(Path *this, float a2, float a3)
{
  int var0 = this->var0;
  if (this->var0)
  {
    Path::EndBezierTo(this, a2, a3);
    int var0 = this->var0;
  }
  if ((var0 & 2) != 0)
  {
    Path::Alloue(this, 1);
    int var2 = this->var2;
    float v9 = (char *)this->var3 + 44 * var2;
    this->int var2 = var2 + 1;
    *(void *)float v9 = 0xFFFFFFFF00000001;
    *((void *)v9 + 1) = 0x3F80000000000000;
    *((float *)v9 + 4) = a2;
    *((float *)v9 + 5) = a3;
    return (this->var2 - 1);
  }
  else
  {
    return Path::MoveTo(this, a2, a3);
  }
}

uint64_t Path::LineTo(Path *this, float a2, float a3, float a4)
{
  int var0 = this->var0;
  if (this->var0)
  {
    Path::EndBezierTo(this, a2, a3, a4);
    int var0 = this->var0;
  }
  if ((var0 & 2) != 0)
  {
    Path::Alloue(this, 1);
    int var2 = this->var2;
    float v11 = (char *)this->var3 + 44 * var2;
    this->int var2 = var2 + 1;
    *(void *)float v11 = -4294967279;
    *((void *)v11 + 1) = 0x3F80000000000000;
    *((float *)v11 + 4) = a2;
    *((float *)v11 + 5) = a3;
    *((float *)v11 + 6) = a4;
    return (this->var2 - 1);
  }
  else
  {
    return Path::MoveTo(this, a2, a3, a4);
  }
}

uint64_t Path::CubicTo(Path *this, float a2, float a3, float a4, float a5, float a6, float a7)
{
  int var0 = this->var0;
  if (this->var0)
  {
    Path::EndBezierTo(this, a2, a3);
    int var0 = this->var0;
  }
  if ((var0 & 2) != 0)
  {
    Path::Alloue(this, 1);
    int var2 = this->var2;
    int v17 = (char *)this->var3 + 44 * var2;
    this->int var2 = var2 + 1;
    *(void *)int v17 = 0xFFFFFFFF00000002;
    *((void *)v17 + 1) = 0x3F80000000000000;
    *((float *)v17 + 4) = a2;
    *((float *)v17 + 5) = a3;
    *((float *)v17 + 6) = a4;
    *((float *)v17 + 7) = a5;
    *((float *)v17 + 8) = a6;
    *((float *)v17 + 9) = a7;
    return (this->var2 - 1);
  }
  else
  {
    return Path::MoveTo(this, a2, a3);
  }
}

uint64_t Path::CubicTo(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8)
{
  int var0 = this->var0;
  if (this->var0)
  {
    Path::EndBezierTo(this, a2, a3, a8);
    int var0 = this->var0;
  }
  if ((var0 & 2) != 0)
  {
    Path::Alloue(this, 1);
    int var2 = this->var2;
    float v19 = (char *)this->var3 + 44 * var2;
    this->int var2 = var2 + 1;
    *(void *)float v19 = -4294967278;
    *((void *)v19 + 1) = 0x3F80000000000000;
    *((float *)v19 + 4) = a2;
    *((float *)v19 + 5) = a3;
    *((float *)v19 + 9) = a7;
    *((float *)v19 + 10) = a8;
    *((float *)v19 + 6) = a4;
    *((float *)v19 + 7) = a5;
    *((float *)v19 + 8) = a6;
    return (this->var2 - 1);
  }
  else
  {
    return Path::MoveTo(this, a2, a3, a8);
  }
}

uint64_t Path::ArcTo(Path *this, float a2, float a3, float a4, float a5, float a6, char a7, char a8)
{
  int var0 = this->var0;
  if (this->var0)
  {
    Path::EndBezierTo(this, a2, a3);
    int var0 = this->var0;
  }
  if ((var0 & 2) != 0)
  {
    Path::Alloue(this, 1);
    int var2 = this->var2;
    float v19 = (char *)this->var3 + 44 * var2;
    this->int var2 = var2 + 1;
    *(void *)float v19 = 0xFFFFFFFF00000004;
    *((void *)v19 + 1) = 0x3F80000000000000;
    *((float *)v19 + 4) = a2;
    *((float *)v19 + 5) = a3;
    *((float *)v19 + 6) = a4;
    *((float *)v19 + 7) = a5;
    *((float *)v19 + 8) = a6;
    v19[36] = a7;
    v19[37] = a8;
    return (this->var2 - 1);
  }
  else
  {
    return Path::MoveTo(this, a2, a3);
  }
}

uint64_t Path::ArcTo(Path *this, float a2, float a3, float a4, float a5, float a6, char a7, char a8, float a9)
{
  int var0 = this->var0;
  if (this->var0)
  {
    Path::EndBezierTo(this, a2, a3, a9);
    int var0 = this->var0;
  }
  if ((var0 & 2) != 0)
  {
    Path::Alloue(this, 1);
    int var2 = this->var2;
    float v21 = (char *)this->var3 + 44 * var2;
    this->int var2 = var2 + 1;
    *(void *)float v21 = -4294967276;
    *((void *)v21 + 1) = 0x3F80000000000000;
    *((float *)v21 + 4) = a2;
    *((float *)v21 + 5) = a3;
    *((float *)v21 + 10) = a9;
    *((float *)v21 + 6) = a4;
    *((float *)v21 + 7) = a5;
    *((float *)v21 + 8) = a6;
    v21[36] = a7;
    v21[37] = a8;
    return (this->var2 - 1);
  }
  else
  {
    return Path::MoveTo(this, a2, a3, a9);
  }
}

uint64_t Path::TempBezierTo(Path *this)
{
  int var0 = this->var0;
  if (this->var0)
  {
    var0 &= 0xFFFFFFFA;
    this->int var0 = var0;
    int var4 = this->var4;
    if ((var4 & 0x80000000) == 0)
    {
      this->int var2 = var4;
      this->int var4 = -1;
    }
  }
  if ((var0 & 2) == 0) {
    return 0xFFFFFFFFLL;
  }
  this->int var4 = this->var2;
  Path::Alloue(this, 1);
  int var2 = this->var2;
  uint64_t v6 = (char *)this->var3 + 44 * var2;
  this->int var2 = var2 + 1;
  *(void *)uint64_t v6 = 0xFFFFFFFF00000003;
  *((void *)v6 + 1) = 0x3F80000000000000;
  *((_DWORD *)v6 + 4) = 0;
  this->var0 |= 5u;
  return (this->var2 - 1);
}

uint64_t Path::TempBezierToW(Path *this)
{
  int var0 = this->var0;
  if (this->var0)
  {
    var0 &= 0xFFFFFFFA;
    this->int var0 = var0;
    int var4 = this->var4;
    if ((var4 & 0x80000000) == 0)
    {
      this->int var2 = var4;
      this->int var4 = -1;
    }
  }
  if ((var0 & 2) == 0) {
    return 0xFFFFFFFFLL;
  }
  this->int var4 = this->var2;
  Path::Alloue(this, 1);
  int var2 = this->var2;
  uint64_t v6 = (char *)this->var3 + 44 * var2;
  this->int var2 = var2 + 1;
  *(void *)uint64_t v6 = -4294967277;
  *((void *)v6 + 1) = 0x3F80000000000000;
  *((_DWORD *)v6 + 4) = 0;
  this->var0 |= 5u;
  return (this->var2 - 1);
}

uint64_t Path::IntermBezierTo(Path *this, float a2, float a3)
{
  if (this->var0)
  {
    if ((this->var0 & 2) != 0)
    {
      if ((*((unsigned char *)this->var3 + 44 * this->var4) & 0x10) != 0)
      {
        return Path::IntermBezierTo(this, a2, a3, 1.0);
      }
      else
      {
        Path::Alloue(this, 1);
        int var2 = this->var2;
        int v8 = (char *)this->var3 + 44 * var2;
        this->int var2 = var2 + 1;
        *(void *)int v8 = -4294967290;
        *((void *)v8 + 1) = 0x3F80000000000000;
        *((float *)v8 + 4) = a2;
        *((float *)v8 + 5) = a3;
        float v9 = (char *)this->var3 + 44 * this->var4;
        ++*((_DWORD *)v9 + 4);
        return (this->var2 - 1);
      }
    }
    else
    {
      return Path::MoveTo(this, a2, a3);
    }
  }
  else
  {
    return Path::LineTo(this, a2, a3);
  }
}

uint64_t Path::IntermBezierTo(Path *this, float a2, float a3, float a4)
{
  if (this->var0)
  {
    if ((this->var0 & 2) != 0)
    {
      if ((*((unsigned char *)this->var3 + 44 * this->var4) & 0x10) != 0)
      {
        Path::Alloue(this, 1);
        int var2 = this->var2;
        int v10 = (char *)this->var3 + 44 * var2;
        this->int var2 = var2 + 1;
        *(void *)int v10 = -4294967274;
        *((void *)v10 + 1) = 0x3F80000000000000;
        *((float *)v10 + 4) = a2;
        *((float *)v10 + 5) = a3;
        *((float *)v10 + 6) = a4;
        float v11 = (char *)this->var3 + 44 * this->var4;
        ++*((_DWORD *)v11 + 4);
        return (this->var2 - 1);
      }
      else
      {
        return Path::IntermBezierTo(this, a2, a3);
      }
    }
    else
    {
      return Path::MoveTo(this, a2, a3, a4);
    }
  }
  else
  {
    return Path::LineTo(this, a2, a3, a4);
  }
}

uint64_t Path::BezierTo(Path *this, float a2, float a3)
{
  int var0 = this->var0;
  if (this->var0)
  {
    Path::EndBezierTo(this, a2, a3);
    int var0 = this->var0;
  }
  if ((var0 & 2) != 0)
  {
    this->int var4 = this->var2;
    Path::Alloue(this, 1);
    int var2 = this->var2;
    float v9 = (char *)this->var3 + 44 * var2;
    this->int var2 = var2 + 1;
    *(void *)float v9 = 0xFFFFFFFF00000003;
    *((void *)v9 + 1) = 0x3F80000000000000;
    *((_DWORD *)v9 + 4) = 0;
    *((float *)v9 + 5) = a2;
    *((float *)v9 + 6) = a3;
    this->int var0 = this->var0 & 0xFFFFFFFA | 1;
    return (this->var2 - 1);
  }
  else
  {
    return Path::MoveTo(this, a2, a3);
  }
}

uint64_t Path::BezierTo(Path *this, float a2, float a3, float a4)
{
  int var0 = this->var0;
  if (this->var0)
  {
    Path::EndBezierTo(this, a2, a3, a4);
    int var0 = this->var0;
  }
  if ((var0 & 2) != 0)
  {
    this->int var4 = this->var2;
    Path::Alloue(this, 1);
    int var2 = this->var2;
    float v11 = (char *)this->var3 + 44 * var2;
    this->int var2 = var2 + 1;
    *(void *)float v11 = -4294967277;
    *((void *)v11 + 1) = 0x3F80000000000000;
    *((_DWORD *)v11 + 4) = 0;
    *((float *)v11 + 5) = a2;
    *((float *)v11 + 6) = a3;
    *((float *)v11 + 7) = a4;
    this->int var0 = this->var0 & 0xFFFFFFFA | 1;
    return (this->var2 - 1);
  }
  else
  {
    return Path::MoveTo(this, a2, a3, a4);
  }
}

Path *Path::SetBackData(Path *this, char a2)
{
  if (this->var7)
  {
    if (a2) {
      return this;
    }
    BOOL v2 = 0;
  }
  else
  {
    if ((a2 & 1) == 0) {
      return this;
    }
    BOOL v2 = 1;
  }
  this->var7 = v2;
  return Path::ResetPoints(this, this->var8);
}

uint64_t Path::AddPoint(Path *this, float a2, float a3, BOOL a4)
{
  if (this->var7)
  {
    return Path::AddPoint(this, a2, a3, -1, 0.0, a4);
  }
  else if (this->var6)
  {
    return Path::AddPoint(this, a2, a3, 1.0, a4);
  }
  else
  {
    int var10 = this->var10;
    int v10 = var10 + 12;
    if (var10 + 12 > this->var9)
    {
      int v11 = 2 * var10 + 12;
      this->var9 = v11;
      this->var11 = (char *)malloc_type_realloc(this->var11, v11, 0x62A63B71uLL);
    }
    uint64_t result = this->var8;
    int var8 = this->var8;
    if (a4)
    {
      this->int var8 = result + 1;
      this->int var10 = v10;
      var11 = this->var11;
      *(_DWORD *)&var11[12 * var8] = 1;
    }
    else
    {
      var11 = this->var11;
      int v14 = result - 1;
      if ((int)result >= 1 && *(float *)&var11[12 * v14 + 4] == a2 && *(float *)&var11[12 * v14 + 8] == a3) {
        return 0xFFFFFFFFLL;
      }
      this->int var8 = result + 1;
      this->int var10 = v10;
      *(_DWORD *)&var11[12 * var8] = 0;
    }
    float v15 = &var11[12 * var8];
    *((float *)v15 + 1) = a2;
    *((float *)v15 + 2) = a3;
  }
  return result;
}

uint64_t Path::AddPoint(Path *this, float a2, float a3, int a4, float a5, BOOL a6)
{
  if (this->var7)
  {
    if (this->var6)
    {
      return Path::AddPoint(this, a2, a3, 1.0, a4, a5, a6);
    }
    else
    {
      int var10 = this->var10;
      int v14 = var10 + 20;
      if (var10 + 20 > this->var9)
      {
        int v15 = 2 * var10 + 20;
        this->var9 = v15;
        this->var11 = (char *)malloc_type_realloc(this->var11, v15, 0x6D330906uLL);
      }
      uint64_t result = this->var8;
      int var8 = this->var8;
      if (a6)
      {
        this->int var8 = result + 1;
        this->int var10 = v14;
        var11 = this->var11;
        *(_DWORD *)&var11[20 * var8] = 1;
      }
      else
      {
        var11 = this->var11;
        if ((int)result >= 1)
        {
          double v18 = &var11[20 * (result - 1)];
          if (*((float *)v18 + 1) == a2 && *((float *)v18 + 2) == a3) {
            return 0xFFFFFFFFLL;
          }
        }
        this->int var8 = result + 1;
        this->int var10 = v14;
        *(_DWORD *)&var11[20 * var8] = 0;
      }
      float v19 = &var11[20 * var8];
      *((float *)v19 + 1) = a2;
      *((float *)v19 + 2) = a3;
      *((_DWORD *)v19 + 3) = a4;
      *((float *)v19 + 4) = a5;
    }
  }
  else
  {
    return Path::AddPoint(this, a2, a3, a6);
  }
  return result;
}

uint64_t Path::AddPoint(Path *this, float a2, float a3, float a4, BOOL a5)
{
  if (this->var7)
  {
    return Path::AddPoint(this, a2, a3, a4, -1, 0.0, a5);
  }
  else if (this->var6)
  {
    int var10 = this->var10;
    int v12 = var10 + 16;
    if (var10 + 16 > this->var9)
    {
      int v13 = 2 * var10 + 16;
      this->var9 = v13;
      this->var11 = (char *)malloc_type_realloc(this->var11, v13, 0xA7B035DAuLL);
    }
    uint64_t result = this->var8;
    if (a5)
    {
      this->int var8 = result + 1;
      this->int var10 = v12;
      var11 = this->var11;
      *(_DWORD *)&var11[16 * (int)result] = 1;
    }
    else
    {
      var11 = this->var11;
      if ((int)result >= 1)
      {
        int v15 = &var11[16 * (result - 1)];
        if (*((float *)v15 + 1) == a2 && *((float *)v15 + 2) == a3) {
          return 0xFFFFFFFFLL;
        }
      }
      this->int var8 = result + 1;
      this->int var10 = v12;
      *(_DWORD *)&var11[16 * (int)result] = 0;
    }
    float v16 = (float *)&var11[16 * (int)result];
    v16[1] = a2;
    v16[2] = a3;
    v16[3] = a4;
  }
  else
  {
    return Path::AddPoint(this, a2, a3, a5);
  }
  return result;
}

uint64_t Path::AddPoint(Path *this, float a2, float a3, float a4, int a5, float a6, BOOL a7)
{
  if (this->var7)
  {
    if (this->var6)
    {
      int var10 = this->var10;
      int v15 = var10 + 24;
      if (var10 + 24 > this->var9)
      {
        int v16 = 2 * var10 + 24;
        this->var9 = v16;
        this->var11 = (char *)malloc_type_realloc(this->var11, v16, 0x30488573uLL);
      }
      uint64_t result = this->var8;
      int var8 = this->var8;
      if (a7)
      {
        this->int var8 = result + 1;
        this->int var10 = v15;
        var11 = this->var11;
        *(_DWORD *)&var11[24 * var8] = 1;
      }
      else
      {
        var11 = this->var11;
        if ((int)result >= 1)
        {
          int v20 = &var11[24 * (result - 1)];
          if (*((float *)v20 + 1) == a2 && *((float *)v20 + 2) == a3) {
            return 0xFFFFFFFFLL;
          }
        }
        this->int var8 = result + 1;
        this->int var10 = v15;
        *(_DWORD *)&var11[24 * var8] = 0;
      }
      float v21 = &var11[24 * var8];
      *((float *)v21 + 1) = a2;
      *((float *)v21 + 2) = a3;
      *((float *)v21 + 3) = a4;
      *((_DWORD *)v21 + 4) = a5;
      *((float *)v21 + 5) = a6;
    }
    else
    {
      return Path::AddPoint(this, a2, a3, a5, a6, a7);
    }
  }
  else
  {
    return Path::AddPoint(this, a2, a3, a4, a7);
  }
  return result;
}

double Path::AddForcedPoint(Path *this, double result, float a3)
{
  if (this->var7)
  {
    Path::AddForcedPoint(this, *(float *)&result, a3, -1, 0.0);
  }
  else if (this->var6)
  {
    *(float *)&uint64_t result = Path::AddForcedPoint(this, *(float *)&result, a3, 1.0);
  }
  else
  {
    int var10 = this->var10;
    int v5 = var10 + 12;
    if (var10 + 12 > this->var9)
    {
      int v6 = 2 * var10 + 12;
      this->var9 = v6;
      this->var11 = (char *)malloc_type_realloc(this->var11, v6, 0x39144A8uLL);
    }
    int var8 = this->var8;
    int v8 = var8 - 1;
    if (var8 >= 1)
    {
      var11 = this->var11;
      if (!*(_DWORD *)&var11[12 * v8])
      {
        this->int var8 = var8 + 1;
        this->int var10 = v5;
        int v10 = &var11[12 * var8];
        *(_DWORD *)int v10 = 2;
        uint64_t result = *(double *)&var11[12 * v8 + 4];
        *(double *)(v10 + 4) = result;
      }
    }
  }
  return result;
}

float Path::AddForcedPoint(Path *this, double a2, float a3, int a4, float a5)
{
  if (this->var7)
  {
    if (this->var6)
    {
      *(float *)&a2 = Path::AddForcedPoint(this, *(float *)&a2, a3, 1.0, a4, a5);
    }
    else
    {
      int var10 = this->var10;
      int v7 = var10 + 20;
      if (var10 + 20 > this->var9)
      {
        int v8 = 2 * var10 + 20;
        this->var9 = v8;
        this->var11 = (char *)malloc_type_realloc(this->var11, v8, 0x431BE692uLL);
      }
      int var8 = this->var8;
      int v10 = var8 - 1;
      if (var8 >= 1)
      {
        var11 = this->var11;
        if (!*(_DWORD *)&var11[20 * v10])
        {
          this->int var8 = var8 + 1;
          this->int var10 = v7;
          int v12 = &var11[20 * var8];
          *(_DWORD *)int v12 = 2;
          int v13 = &var11[20 * v10];
          *(void *)(v12 + 4) = *(void *)(v13 + 4);
          *((_DWORD *)v12 + 3) = *((_DWORD *)v13 + 3);
          LODWORD(a2) = *((_DWORD *)v13 + 4);
          *((_DWORD *)v12 + 4) = LODWORD(a2);
        }
      }
    }
  }
  else
  {
    a2 = Path::AddForcedPoint(this, a2, a3);
  }
  return *(float *)&a2;
}

float Path::AddForcedPoint(Path *this, float result, float a3, float a4)
{
  if (this->var7)
  {
    return Path::AddForcedPoint(this, result, a3, a4, -1, 0.0);
  }
  else if (this->var6)
  {
    int var10 = this->var10;
    int v6 = var10 + 16;
    if (var10 + 16 > this->var9)
    {
      int v7 = 2 * var10 + 16;
      this->var9 = v7;
      this->var11 = (char *)malloc_type_realloc(this->var11, v7, 0x300662EFuLL);
    }
    uint64_t var8 = this->var8;
    if ((int)var8 >= 1)
    {
      var11 = this->var11;
      if (!*(_DWORD *)&var11[16 * (var8 - 1)])
      {
        this->uint64_t var8 = var8 + 1;
        this->int var10 = v6;
        int v10 = &var11[16 * var8];
        *(_DWORD *)int v10 = 2;
        int v11 = &var11[16 * (var8 - 1)];
        *(void *)(v10 + 4) = *(void *)(v11 + 4);
        uint64_t result = *((float *)v11 + 3);
        *((float *)v10 + 3) = result;
      }
    }
  }
  else
  {
    Path::AddForcedPoint(this, result, a3);
  }
  return result;
}

float Path::AddForcedPoint(Path *this, float result, float a3, float a4, int a5, float a6)
{
  if (this->var7)
  {
    if (this->var6)
    {
      int var10 = this->var10;
      int v8 = var10 + 24;
      if (var10 + 24 > this->var9)
      {
        int v9 = 2 * var10 + 24;
        this->var9 = v9;
        this->var11 = (char *)malloc_type_realloc(this->var11, v9, 0x9E2B540AuLL);
      }
      int var8 = this->var8;
      int v11 = var8 - 1;
      if (var8 >= 1)
      {
        var11 = this->var11;
        if (!*(_DWORD *)&var11[12 * v11])
        {
          this->int var8 = var8 + 1;
          this->int var10 = v8;
          int v13 = &var11[24 * var8];
          *(_DWORD *)int v13 = 2;
          int v14 = &var11[24 * v11];
          *(void *)(v13 + 4) = *(void *)(v14 + 4);
          *((_DWORD *)v13 + 3) = *((_DWORD *)v14 + 3);
          *((_DWORD *)v13 + 4) = *((_DWORD *)v14 + 4);
          uint64_t result = *((float *)v14 + 5);
          *((float *)v13 + 5) = result;
        }
      }
    }
    else
    {
      Path::AddForcedPoint(this, result, a3, a5, a6);
    }
  }
  else
  {
    Path::AddForcedPoint(this, result, a3, a4);
  }
  return result;
}

uint64_t Path::Winding(Path *this)
{
  int var8 = this->var8;
  if (var8 < 2) {
    return 0;
  }
  uint64_t v3 = (var8 - 1);
  var11 = this->var11;
  if (this->var6)
  {
    int v5 = (float *)(var11 + 24);
    float v6 = 0.0;
    uint64_t v7 = v3;
    float v8 = *((float *)var11 + 2);
    float v9 = *((float *)var11 + 1);
    do
    {
      float v10 = *(v5 - 1);
      float v11 = *v5;
      float v6 = v6 + (float)((float)(v9 + v10) * (float)(*v5 - v8));
      v5 += 4;
      float v8 = v11;
      float v9 = v10;
      --v7;
    }
    while (v7);
    int v12 = &var11[16 * (int)v3];
  }
  else
  {
    int v13 = (float *)(var11 + 20);
    float v6 = 0.0;
    uint64_t v14 = v3;
    float v15 = *((float *)var11 + 2);
    float v16 = *((float *)var11 + 1);
    do
    {
      float v17 = *(v13 - 1);
      float v18 = *v13;
      float v6 = v6 + (float)((float)(v16 + v17) * (float)(*v13 - v15));
      v13 += 3;
      float v15 = v18;
      float v16 = v17;
      --v14;
    }
    while (v14);
    int v12 = &var11[12 * (int)v3];
  }
  if ((float)(v6
             + (float)((float)(*((float *)v12 + 1) + *((float *)var11 + 1))
                     * (float)(*((float *)var11 + 2) - *((float *)v12 + 2)))) > 0.0)
    return 1;
  else {
    return 0xFFFFFFFFLL;
  }
}

void Path::PointAt(Path *a1, int a2, float32x2_t *a3, float a4)
{
  if (a2 < 0 || a1->var2 <= a2)
  {
    *a3 = 0;
    return;
  }
  var3 = a1->var3;
  float v9 = (_OWORD *)((char *)var3 + 44 * a2);
  __n128 v10 = *(__n128 *)((char *)v9 + 28);
  long long v11 = v9[1];
  long long v44 = *v9;
  *(_OWORD *)v45[0].f32 = v11;
  *(__n128 *)&v45[1].i32[1] = v10;
  if ((v44 & 0xF) == 0)
  {
    uint64_t v12 = (a2 + 1);
    v10.n128_u64[0] = 0;
    goto LABEL_8;
  }
  if ((v44 & 0xD) != 5)
  {
    switch(v44 & 0xF)
    {
      case 1:
        Path::PrevPoint(a1, a2 - 1, (float *)&v36, &v37);
        v40[0] = 0.0;
        Path::TangentOnSegAt((float *)v45, (float *)a3, &v42, v40, a4, *(float *)&v36, v37);
        return;
      case 2:
        Path::PrevPoint(a1, a2 - 1, (float *)&v36, &v37);
        v40[0] = 0.0;
        int v41 = 0;
        v24.i32[0] = v36;
        Path::TangentOnCubAt(v45, 0, a3, (uint64_t)&v42, v40, (float *)&v41, a4, v24, v37);
        return;
      case 3:
      case 6:
        int v13 = 0;
        do
        {
          unsigned int v15 = a2 + v13;
          if (a2 + v13 < 0) {
            goto LABEL_5;
          }
          --v13;
        }
        while ((*((_DWORD *)var3 + 11 * v15) & 0xF) != 3);
        float v16 = (char *)var3 + 44 * v15;
        int v19 = *((_DWORD *)v16 + 4);
        float v17 = (int *)(v16 + 16);
        int v18 = v19;
        if (a2 + v13 + v19 + 1 < a2) {
          break;
        }
        if (v18 == 1 || ~v13 <= 0)
        {
          Path::PrevPoint(a1, a2 + v13, (float *)&v36, &v37);
          v40[0] = 0.0;
          int v41 = 0;
          LODWORD(v11) = v36;
          float32_t v21 = v37;
          float v22 = a1->var3;
          int v23 = (float32x2_t *)((char *)v22 + 44 * (a2 + v13 + 2) + 16);
          float v17 = (int *)((char *)v22 + 44 * v15 + 16);
        }
        else
        {
          if (v13 == -2)
          {
            Path::PrevPoint(a1, a2 - 2, &v42, &v43);
            int v41 = 0;
            int v39 = 0;
            int v36 = 1;
            double v25 = a1->var3;
            float v26 = (float32x2_t *)((char *)v25 + 44 * a2);
            float v27 = v26[2].f32[0];
            int v23 = v26 + 2;
            double v28 = (float *)((char *)v25 + 44 * (a2 + 1));
            float v37 = (float)(v27 + v28[4]) * 0.5;
            float v38 = (float)(v23->f32[1] + v28[5]) * 0.5;
            *(float *)&long long v11 = v42;
            float32_t v21 = v43;
            float v17 = &v36;
            double v29 = v40;
            double v30 = (float *)&v41;
            int v31 = (float *)&v39;
LABEL_29:
            Path::TangentOnBezAt(v23, (uint64_t)v17, 0, a3, (uint64_t)v29, v30, v31, a4, *(float32x2_t *)&v11, v21);
            return;
          }
          int v23 = (float32x2_t *)((char *)var3 + 44 * a2 + 16);
          int v32 = (float *)((char *)var3 + 44 * a2 - 28);
          if (v18 + v13 == -1)
          {
            float v42 = 0.0;
            v40[0] = 0.0;
            *(float *)&long long v11 = (float)(v23->f32[0] + *v32) * 0.5;
            float32_t v21 = (float)(*((float *)var3 + 11 * a2 + 5) + *((float *)var3 + 11 * a2 - 6)) * 0.5;
            double v29 = (float *)&v36;
            double v30 = &v42;
            int v31 = v40;
            goto LABEL_29;
          }
          v40[0] = 0.0;
          int v41 = 0;
          float v33 = v23->f32[0];
          float v34 = *((float *)var3 + 11 * a2 + 5);
          *(float *)&long long v11 = (float)(v23->f32[0] + *v32) * 0.5;
          float32_t v21 = (float)(v34 + *((float *)var3 + 11 * a2 - 6)) * 0.5;
          int v36 = 1;
          BOOL v35 = (float *)((char *)var3 + 44 * a2);
          float v37 = (float)(v33 + v35[15]) * 0.5;
          float v38 = (float)(v34 + v35[16]) * 0.5;
          float v17 = &v36;
        }
        double v29 = &v42;
        double v30 = v40;
        int v31 = (float *)&v41;
        goto LABEL_29;
      case 4:
        Path::PrevPoint(a1, a2 - 1, (float *)&v36, &v37);
        v40[0] = 0.0;
        int v41 = 0;
        Path::TangentOnArcAt((uint64_t)v45, (float *)a3, (uint64_t)&v42, v40, (float *)&v41, a4, *(float *)&v36, v37);
        return;
      default:
        return;
    }
  }
LABEL_5:
  uint64_t v12 = (a2 - 1);
  v10.n128_u32[0] = 1.0;
LABEL_8:
  Path::PointAt(a1, v12, a3, v10);
}

void Path::PointAndTangentAt(Path *a1, int a2, float32x2_t *a3, float *a4, float a5)
{
  if (a2 < 0 || a1->var2 <= a2)
  {
    *a3 = 0;
    *(void *)a4 = 0;
    return;
  }
  var3 = a1->var3;
  long long v11 = (_OWORD *)((char *)var3 + 44 * a2);
  __n128 v12 = *(__n128 *)((char *)v11 + 28);
  long long v13 = v11[1];
  long long v44 = *v11;
  *(_OWORD *)v45[0].f32 = v13;
  *(__n128 *)&v45[1].i32[1] = v12;
  if ((v44 & 0xF) == 0)
  {
    uint64_t v14 = (a2 + 1);
    v12.n128_u64[0] = 0;
    goto LABEL_8;
  }
  if ((v44 & 0xD) != 5)
  {
    switch(v44 & 0xF)
    {
      case 1:
        Path::PrevPoint(a1, a2 - 1, &v37, &v38);
        float v41 = 0.0;
        Path::TangentOnSegAt((float *)v45, (float *)a3, a4, &v41, a5, v37, v38);
        return;
      case 2:
        Path::PrevPoint(a1, a2 - 1, &v37, &v38);
        float v41 = 0.0;
        int v43 = 0;
        v26.f32[0] = v37;
        Path::TangentOnCubAt(v45, 0, a3, (uint64_t)a4, &v41, (float *)&v43, a5, v26, v38);
        return;
      case 3:
      case 6:
        int v15 = 0;
        do
        {
          unsigned int v17 = a2 + v15;
          if (a2 + v15 < 0) {
            goto LABEL_5;
          }
          --v15;
        }
        while ((*((_DWORD *)var3 + 11 * v17) & 0xF) != 3);
        int v18 = (char *)var3 + 44 * v17;
        int v21 = *((_DWORD *)v18 + 4);
        int v19 = (float *)(v18 + 16);
        int v20 = v21;
        if (a2 + v15 + v21 + 1 < a2) {
          break;
        }
        if (v20 == 1 || ~v15 <= 0)
        {
          Path::PrevPoint(a1, a2 + v15, &v37, &v38);
          float v41 = 0.0;
          int v43 = 0;
          *(float *)&long long v13 = v37;
          float32_t v23 = v38;
          float32x2_t v24 = a1->var3;
          double v25 = (float32x2_t *)((char *)v24 + 44 * (a2 + v15 + 2) + 16);
          int v19 = (float *)((char *)v24 + 44 * v17 + 16);
        }
        else
        {
          if (v15 == -2)
          {
            Path::PrevPoint(a1, a2 - 2, &v41, &v42);
            int v43 = 0;
            int v40 = 0;
            LODWORD(v37) = 1;
            float v27 = a1->var3;
            double v28 = (float32x2_t *)((char *)v27 + 44 * a2);
            float v29 = v28[2].f32[0];
            double v25 = v28 + 2;
            double v30 = (float *)((char *)v27 + 44 * (a2 + 1));
            float v38 = (float)(v29 + v30[4]) * 0.5;
            float v39 = (float)(v25->f32[1] + v30[5]) * 0.5;
            *(float *)&long long v13 = v41;
            float32_t v23 = v42;
            int v19 = &v37;
            int v31 = (float *)&v43;
            int v32 = (float *)&v40;
LABEL_29:
            Path::TangentOnBezAt(v25, (uint64_t)v19, 0, a3, (uint64_t)a4, v31, v32, a5, *(float32x2_t *)&v13, v23);
            return;
          }
          double v25 = (float32x2_t *)((char *)var3 + 44 * a2 + 16);
          float v33 = (float *)((char *)var3 + 44 * a2 - 28);
          if (v20 + v15 == -1)
          {
            float v37 = 0.0;
            float v41 = 0.0;
            *(float *)&long long v13 = (float)(v25->f32[0] + *v33) * 0.5;
            float32_t v23 = (float)(*((float *)var3 + 11 * a2 + 5) + *((float *)var3 + 11 * a2 - 6)) * 0.5;
            int v31 = &v37;
            int v32 = &v41;
            goto LABEL_29;
          }
          float v41 = 0.0;
          int v43 = 0;
          float v34 = v25->f32[0];
          float v35 = *((float *)var3 + 11 * a2 + 5);
          *(float *)&long long v13 = (float)(v25->f32[0] + *v33) * 0.5;
          float32_t v23 = (float)(v35 + *((float *)var3 + 11 * a2 - 6)) * 0.5;
          LODWORD(v37) = 1;
          int v36 = (float *)((char *)var3 + 44 * a2);
          float v38 = (float)(v34 + v36[15]) * 0.5;
          float v39 = (float)(v35 + v36[16]) * 0.5;
          int v19 = &v37;
        }
        int v31 = &v41;
        int v32 = (float *)&v43;
        goto LABEL_29;
      case 4:
        Path::PrevPoint(a1, a2 - 1, &v37, &v38);
        float v41 = 0.0;
        int v43 = 0;
        Path::TangentOnArcAt((uint64_t)v45, (float *)a3, (uint64_t)a4, &v41, (float *)&v43, a5, v37, v38);
        return;
      default:
        return;
    }
  }
LABEL_5:
  uint64_t v14 = (a2 - 1);
  v12.n128_u32[0] = 1.0;
LABEL_8:
  Path::PointAndTangentAt(a1, v14, a3, a4, v12);
}

void Path::ConvertWithBackData(Path *this, float a2)
{
  int var0 = this->var0;
  if (this->var0)
  {
    Path::CancelBezier(this);
    int var0 = this->var0;
  }
  if ((var0 & 2) != 0) {
    Path::CloseSubpath(this, 0);
  }
  Path::SetBackData(this, 1);
  Path::ResetPoints(this, this->var2);
  if (this->var2 >= 1)
  {
    var3 = this->var3;
    float v5 = 1.0;
    if ((*(unsigned char *)var3 & 0x10) != 0) {
      float v5 = *((float *)var3 + 7);
    }
    float v6 = *((float *)var3 + 4);
    float v7 = *((float *)var3 + 5);
    if (this->var6) {
      uint64_t v8 = Path::AddPoint(this, v6, v7, v5, 0, 0.0, 1);
    }
    else {
      uint64_t v8 = Path::AddPoint(this, v6, v7, 0, 0.0, 1);
    }
    uint64_t v10 = v8;
    if (this->var2 >= 2)
    {
      float v11 = 0.5;
      int v12 = 1;
      while (2)
      {
        long long v13 = this->var3;
        int v14 = *((_DWORD *)v13 + 11 * v12);
        float v15 = 0.0;
        float v16 = 0.0;
        float v17 = 0.0;
        switch(v14 & 0xF)
        {
          case 0:
            int v18 = (float *)((char *)v13 + 44 * v12);
            float v20 = v18[4];
            int v19 = (char *)(v18 + 4);
            float v15 = v20;
            float v17 = 1.0;
            if ((v14 & 0x10) != 0) {
              float v17 = *((float *)v19 + 3);
            }
            float v16 = *((float *)v19 + 1);
            if (this->var6) {
              uint64_t v21 = Path::AddPoint(this, v15, v16, v17, v12, 0.0, 1);
            }
            else {
              uint64_t v21 = Path::AddPoint(this, v15, v16, v12, 0.0, 1);
            }
            float v11 = 0.5;
            uint64_t v10 = v21;
            goto LABEL_62;
          case 1:
            float v22 = (float *)((char *)v13 + 44 * v12);
            float v24 = v22[4];
            float32_t v23 = (char *)(v22 + 4);
            float v15 = v24;
            float v17 = 1.0;
            if ((v14 & 0x10) != 0) {
              float v17 = *((float *)v23 + 2);
            }
            float v16 = *((float *)v23 + 1);
            if (!this->var6) {
              goto LABEL_60;
            }
            goto LABEL_35;
          case 2:
            double v25 = (float *)((char *)v13 + 44 * v12);
            float v27 = v25[4];
            float32x2_t v26 = v25 + 4;
            float v15 = v27;
            float v17 = 1.0;
            if ((v14 & 0x10) != 0) {
              float v17 = v26[6];
            }
            float v16 = v26[1];
            float v28 = v26[2];
            float v29 = v26[3];
            float v30 = v26[4];
            float v31 = v26[5];
            if (this->var6)
            {
              Path::RecCubicTo(this, v6, v7, v5, v28, v29, v15, v16, v17, 8, v12, v30, v31, a2, 0.0, 1.0);
              goto LABEL_35;
            }
            Path::RecCubicTo(this, v6, v7, v28, v29, v15, v16, v30, v31, 8, v12, a2, 0.0, 1.0);
            goto LABEL_60;
          case 3:
            int v32 = (char *)v13 + 44 * v12;
            int v35 = *((_DWORD *)v32 + 4);
            float v33 = (float *)(v32 + 16);
            int v34 = v35;
            float v15 = v33[1];
            float v16 = v33[2];
            if ((v14 & 0x10) != 0)
            {
              float v91 = v33[3];
              if (v34 <= 0) {
                goto LABEL_77;
              }
              float v89 = v33[2];
              float v90 = v33[1];
              uint64_t v36 = v12 + 1;
              int v49 = (float *)((char *)v13 + 44 * v36);
              float v37 = v49 + 4;
              float v38 = v49[6];
            }
            else
            {
              if (v34 <= 0)
              {
                float v91 = 1.0;
                goto LABEL_77;
              }
              float v89 = v33[2];
              float v90 = v33[1];
              uint64_t v36 = v12 + 1;
              float v37 = (float *)((char *)v13 + 44 * v36 + 16);
              float v91 = 1.0;
              float v38 = 1.0;
            }
            float v50 = *v37;
            float v51 = *((float *)v13 + 11 * v36 + 5);
            float v52 = -(float)(*v37 - (float)(v6 * 2.0));
            float v53 = -(float)(v51 - (float)(v7 * 2.0));
            float v54 = 2.0;
            float v55 = -(float)(v38 - (float)(v5 * 2.0));
            if (v34 < 2)
            {
              float v74 = -v50;
              float v75 = -v51;
              float v76 = -v38;
            }
            else
            {
              uint64_t v87 = v10;
              int v56 = 0;
              int v57 = (float *)((char *)v13 + 44 * v36 + 68);
              int v58 = v12;
              do
              {
                float v59 = v50;
                float v60 = v51;
                float v61 = v38;
                float v62 = 1.0;
                if ((v14 & 0x10) != 0) {
                  float v62 = *v57;
                }
                float v50 = *(v57 - 2);
                float v51 = *(v57 - 1);
                float v63 = (float)(v52 + v59) * v11;
                float v64 = v53 + v60;
                float v65 = v64 * v11;
                float v66 = (float)(v55 + v38) * v11;
                if (v56)
                {
                  int v67 = v58 - 1;
                  float v93 = *(v57 - 1);
                  float v68 = *(v57 - 2);
                  float v69 = v62;
                  float v70 = (float)(v55 + v38) * v11;
                  if (this->var6) {
                    Path::AddPoint(this, v63, v65, v66, v67, 1.0, 0);
                  }
                  else {
                    Path::AddPoint(this, (float)(v52 + v59) * v11, v64 * v11, v67, 1.0, 0);
                  }
                  float v66 = v70;
                  float v62 = v69;
                  float v50 = v68;
                  float v51 = v93;
                  float v11 = 0.5;
                }
                float v71 = (float)(v59 + v50) * v11;
                float v72 = (float)(v60 + v51) * v11;
                float v73 = v62;
                if (this->var6) {
                  Path::RecBezierTo(this, v59, v60, v61, v63, v65, v66, v71, v72, 8, v58, (float)(v61 + v62) * v11, a2, 0.0, 1.0);
                }
                else {
                  Path::RecBezierTo(this, v59, v60, v63, v65, v71, v72, a2, 8, 0.0, v58, 1.0);
                }
                float v38 = v73;
                float v11 = 0.5;
                --v56;
                ++v58;
                v57 += 11;
                float v55 = v61;
                float v53 = v60;
                float v52 = v59;
              }
              while (1 - v34 != v56);
              float v74 = -v50;
              float v75 = -v51;
              float v76 = -v73;
              float v52 = v59;
              float v53 = v60;
              float v55 = v61;
              float v54 = 2.0;
              uint64_t v10 = v87;
            }
            float v78 = v52 + v50;
            float v79 = v78 * v11;
            float v80 = (float)(v53 + v51) * v11;
            float v81 = (float)(v55 + v38) * v11;
            if (v34 > 1)
            {
              float v88 = v76;
              float v94 = v38;
              int v82 = v12 + v34 - 2;
              if (this->var6) {
                Path::AddPoint(this, v79, v80, v81, v82, 1.0, 0);
              }
              else {
                Path::AddPoint(this, v78 * v11, (float)(v53 + v51) * v11, v82, 1.0, 0);
              }
              float v11 = 0.5;
              float v38 = v94;
              float v76 = v88;
            }
            float v83 = (float)(v50 + (float)(v74 + (float)(v90 * v54))) * v11;
            float v84 = (float)(v51 + (float)(v75 + (float)(v89 * v54))) * v11;
            if (this->var6) {
              Path::RecBezierTo(this, v50, v51, v38, v79, v80, v81, v83, v84, 8, v12 + v34 - 1, (float)(v38 + (float)(v76 + (float)(v91 * v54))) * v11, a2, 0.0, 1.0);
            }
            else {
              Path::RecBezierTo(this, v50, v51, v79, v80, v83, v84, a2, 8, 0.0, v12 + v34 - 1, 1.0);
            }
            float v16 = v89;
            float v15 = v90;
LABEL_77:
            int v85 = v12 + v34 - 1;
            if (this->var6)
            {
              float v17 = v91;
              Path::AddPoint(this, v15, v16, v91, v85, 1.0, 0);
              float v11 = 0.5;
            }
            else
            {
              Path::AddPoint(this, v15, v16, v85, 1.0, 0);
              float v11 = 0.5;
              float v17 = v91;
            }
            v12 += v34 + 1;
            goto LABEL_63;
          case 4:
            float v39 = (float *)((char *)v13 + 44 * v12);
            float v41 = v39[4];
            int v40 = (char *)(v39 + 4);
            float v15 = v41;
            float v17 = 1.0;
            if ((v14 & 0x10) != 0) {
              float v17 = *((float *)v40 + 6);
            }
            float v16 = *((float *)v40 + 1);
            float v42 = *((float *)v40 + 2);
            float v43 = *((float *)v40 + 3);
            float v44 = *((float *)v40 + 4);
            BOOL v45 = v40[21] != 0;
            BOOL v46 = v40[20] != 0;
            if (this->var6)
            {
              Path::DoArc(this, v6, v7, v5, v15, v16, v17, v42, v43, v46, v45, v12, v44, v86);
              goto LABEL_35;
            }
            Path::DoArc(this, v6, v7, v15, v16, v42, v43, v44, v46, v45, v43, v12);
            goto LABEL_60;
          case 5:
            var11 = this->var11;
            if (this->var6)
            {
              uint64_t v48 = (float *)&var11[24 * (int)v10];
              float v15 = v48[1];
              float v16 = v48[2];
              float v17 = v48[3];
LABEL_35:
              Path::AddPoint(this, v15, v16, v17, v12, 1.0, 0);
            }
            else
            {
              int v77 = &var11[20 * (int)v10];
              float v15 = *((float *)v77 + 1);
              float v16 = *((float *)v77 + 2);
LABEL_60:
              Path::AddPoint(this, v15, v16, v12, 1.0, 0);
            }
LABEL_61:
            float v11 = 0.5;
LABEL_62:
            ++v12;
LABEL_63:
            float v5 = v17;
            float v7 = v16;
            float v6 = v15;
            if (v12 >= this->var2) {
              return;
            }
            continue;
          case 6:
            goto LABEL_63;
          case 7:
            if (this->var6)
            {
              Path::AddForcedPoint(this, v6, v7, v5, v12, 1.0);
            }
            else
            {
              *(float *)&double v9 = v6;
              Path::AddForcedPoint(this, v9, v7, v12, 1.0);
            }
            goto LABEL_61;
          default:
            float v15 = 0.0;
            float v16 = 0.0;
            float v17 = 0.0;
            goto LABEL_63;
        }
      }
    }
  }
}

Path *Path::RecCubicTo(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9, int a10, int a11, float a12, float a13, float a14, float a15, float a16)
{
  float v20 = this;
  while (1)
  {
    float v24 = a7 - a2;
    float v25 = a8 - a3;
    float v26 = sqrtf((float)(v25 * v25) + (float)(v24 * v24));
    if (v26 >= 0.01) {
      break;
    }
    float v27 = a14;
    if ((float)((float)(a5 * a5) + (float)(a6 * a6)) >= a14)
    {
      if (a10 < 1) {
        return this;
      }
    }
    else if ((float)((float)(a12 * a12) + (float)(a13 * a13)) < a14 || a10 < 1)
    {
      return this;
    }
LABEL_20:
    float v33 = (float)(a4 + a9) * 0.5;
    float v34 = (float)((float)(a2 + a7) * 0.5) + (float)((float)(a5 - a12) * 0.125);
    float v35 = (float)((float)(a3 + a8) * 0.5) + (float)((float)(a6 - a13) * 0.125);
    float v38 = (float)((float)(v24 * 3.0) * 0.25) - (float)((float)(a5 + a12) * 0.125);
    float v39 = (float)((float)(v25 * 3.0) * 0.25) - (float)((float)(a6 + a13) * 0.125);
    float v36 = (float)(a15 + a16) * 0.5;
    Path::RecCubicTo(v20, a2, a3, a4, a5 * 0.5, a6 * 0.5, v34, v35, v33, v38, v39, v27, --a10, a15, v36, a11);
    this = (Path *)Path::AddPoint(v20, v34, v35, v33, a11, v36, 0);
    a12 = a12 * 0.5;
    a2 = v34;
    a3 = v35;
    a13 = a13 * 0.5;
    a4 = v33;
    a5 = v38;
    a6 = v39;
    a15 = v36;
  }
  float v29 = (float)(v24 * a6) - (float)(v25 * a5);
  float v30 = -v29;
  if (v29 >= 0.0) {
    float v30 = (float)(v24 * a6) - (float)(v25 * a5);
  }
  float v31 = -(float)((float)(v24 * a13) - (float)(v25 * a12));
  if ((float)((float)(v24 * a13) - (float)(v25 * a12)) >= 0.0) {
    float v31 = (float)(v24 * a13) - (float)(v25 * a12);
  }
  float v27 = a14;
  BOOL v32 = (float)(v30 / v26) < a14;
  if ((float)(v31 / v26) >= a14) {
    BOOL v32 = 0;
  }
  if (a10 >= 1 && !v32) {
    goto LABEL_20;
  }
  return this;
}

Path *Path::RecCubicTo(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9, int a10, int a11, float a12, float a13, float a14)
{
  float v20 = this;
  while (1)
  {
    float v22 = a6 - a2;
    float v23 = a7 - a3;
    float v24 = sqrtf((float)(v23 * v23) + (float)(v22 * v22));
    if (v24 >= 0.01) {
      break;
    }
    float v25 = a12;
    if ((float)((float)(a4 * a4) + (float)(a5 * a5)) >= a12)
    {
      if (a10 < 1) {
        return this;
      }
    }
    else if ((float)((float)(a8 * a8) + (float)(a9 * a9)) < a12 || a10 < 1)
    {
      return this;
    }
LABEL_20:
    float v31 = (float)((float)(a2 + a6) * 0.5) + (float)((float)(a4 - a8) * 0.125);
    float v32 = (float)((float)(a3 + a7) * 0.5) + (float)((float)(a5 - a9) * 0.125);
    float v34 = (float)((float)(v23 * 3.0) * 0.25) - (float)((float)(a5 + a9) * 0.125);
    float v35 = (float)((float)(v22 * 3.0) * 0.25) - (float)((float)(a4 + a8) * 0.125);
    float v33 = (float)(a13 + a14) * 0.5;
    Path::RecCubicTo(v20, a2, a3, a4 * 0.5, a5 * 0.5, v31, v32, v35, v34, v25, --a10, a13, v33, a11);
    this = (Path *)Path::AddPoint(v20, v31, v32, a11, v33, 0);
    a8 = a8 * 0.5;
    a2 = v31;
    a9 = a9 * 0.5;
    a3 = v32;
    a5 = v34;
    a4 = v35;
    a13 = v33;
  }
  float v27 = (float)(v22 * a5) - (float)(v23 * a4);
  float v28 = -v27;
  if (v27 >= 0.0) {
    float v28 = (float)(v22 * a5) - (float)(v23 * a4);
  }
  float v29 = -(float)((float)(v22 * a9) - (float)(v23 * a8));
  if ((float)((float)(v22 * a9) - (float)(v23 * a8)) >= 0.0) {
    float v29 = (float)(v22 * a9) - (float)(v23 * a8);
  }
  float v25 = a12;
  BOOL v30 = (float)(v28 / v24) < a12;
  if ((float)(v29 / v24) >= a12) {
    BOOL v30 = 0;
  }
  if (a10 >= 1 && !v30) {
    goto LABEL_20;
  }
  return this;
}

void Path::DoArc(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9, int a10, int a11, int a12, float a13, float a14)
{
  if (a8 > 0.0001 && a9 > 0.0001)
  {
    float v20 = a5 - a2;
    float v21 = a6 - a3;
    __float2 v22 = __sincosf_stret(a13);
    float cosval = v22.__cosval;
    float sinval = v22.__sinval;
    float v77 = a8;
    float v78 = a9;
    float v25 = (float)((float)(v21 * v22.__sinval) + (float)(v22.__cosval * v20)) / a8;
    float v26 = (float)((float)(v21 * v22.__cosval) - (float)(v22.__sinval * v20)) / a9;
    float v27 = 4.0;
    if ((float)((float)(v26 * v26) + (float)(v25 * v25)) < 4.0) {
      float v27 = (float)(v26 * v26) + (float)(v25 * v25);
    }
    float v28 = (float)(v27 * -0.25) + 1.0;
    if (v28 < 0.0) {
      float v28 = 0.0;
    }
    float v29 = sqrtf(v28);
    float v30 = sqrtf(v27);
    float v31 = (float)-v25 / v30;
    float v32 = (float)(v26 / v30) * v29;
    float v33 = v25 * 0.5;
    float v34 = (float)-v32 - (float)(v25 * 0.5);
    float v35 = v26 * 0.5;
    float v36 = 3.1416;
    float v37 = 3.1416;
    if (v34 >= -1.0)
    {
      float v37 = 0.0;
      if (v34 <= 1.0)
      {
        float v38 = acosf(v34);
        float sinval = v22.__sinval;
        float v37 = v38;
        float cosval = v22.__cosval;
        if ((float)((float)-(float)(v31 * v29) - v35) < 0.0) {
          float v37 = 6.28318531 - v38;
        }
      }
    }
    float v39 = v31 * v29;
    float v40 = -sinval;
    float v41 = v33 - v32;
    if ((float)(v33 - v32) >= -1.0)
    {
      float v36 = 0.0;
      if (v41 <= 1.0)
      {
        float v42 = v35 - v39;
        float v43 = cosval;
        float v44 = sinval;
        float v45 = acosf(v41);
        float sinval = v44;
        float cosval = v43;
        float v36 = v45;
        if (v42 < 0.0) {
          float v36 = 6.28318531 - v45;
        }
      }
    }
    float v46 = (float)((float)(v39 * v78) * v40) + (float)(cosval * (float)(v32 * v77));
    float v47 = (float)(cosval * (float)(v39 * v78)) + (float)(sinval * (float)(v32 * v77));
    if (a11)
    {
      if (a10)
      {
        float v46 = -v46;
        float v47 = -v47;
        float v48 = v37 + 3.14159265;
        float v49 = v36 + 3.14159265;
        if (v48 >= 6.28318531)
        {
          float v50 = v48 + -6.28318531;
          float v36 = v50;
        }
        else
        {
          float v36 = v37 + 3.14159265;
        }
        if (v49 >= 6.28318531)
        {
          float v51 = v49 + -6.28318531;
          float v37 = v51;
        }
        else
        {
          float v37 = v49;
        }
      }
      float v52 = a6;
      float v53 = v37 + 6.28318531;
      if (v37 >= v36) {
        float v53 = v37;
      }
      float v86 = v53;
      float v54 = v53 + -0.1;
      if (v36 < v54)
      {
        float v55 = (float)((float)(a2 + a5) * 0.5) + v46;
        float v80 = (float)((float)(a3 + v52) * 0.5) + v47;
        float v83 = v55;
        float v56 = cosval * v77;
        float v57 = v40 * v78;
        float v58 = sinval * v77;
        float v59 = cosval * v78;
        float v60 = v53 - v36;
        do
        {
          __float2 v61 = __sincosf_stret(v54);
          Path::AddPoint(this, (float)(v83 + (float)(v56 * v61.__cosval)) + (float)(v57 * v61.__sinval), (float)(v80 + (float)(v58 * v61.__cosval)) + (float)(v59 * v61.__sinval), (float)((float)((float)(v86 - v54) * a7) + (float)(a4 * (float)(v54 - v36))) / v60, a12, (float)(v86 - v54) / v60, 0);
          float v54 = v54 + -0.1;
        }
        while (v36 < v54);
      }
    }
    else
    {
      if ((a10 & 1) == 0)
      {
        float v46 = -v46;
        float v47 = -v47;
        float v62 = v37 + 3.14159265;
        float v63 = v36 + 3.14159265;
        if (v62 >= 6.28318531)
        {
          float v64 = v62 + -6.28318531;
          float v36 = v64;
        }
        else
        {
          float v36 = v37 + 3.14159265;
        }
        if (v63 >= 6.28318531)
        {
          float v65 = v63 + -6.28318531;
          float v37 = v65;
        }
        else
        {
          float v37 = v63;
        }
      }
      float v66 = a6;
      float v67 = v37 + -6.28318531;
      if (v37 <= v36) {
        float v67 = v37;
      }
      float v87 = v67;
      float v68 = v67 + 0.1;
      if (v36 > v68)
      {
        float v69 = (float)((float)(a2 + a5) * 0.5) + v46;
        float v81 = (float)((float)(a3 + v66) * 0.5) + v47;
        float v84 = v69;
        float v70 = cosval * v77;
        float v71 = v40 * v78;
        float v72 = sinval * v77;
        float v73 = cosval * v78;
        float v74 = v36 - v67;
        do
        {
          __float2 v75 = __sincosf_stret(v68);
          Path::AddPoint(this, (float)(v84 + (float)(v70 * v75.__cosval)) + (float)(v71 * v75.__sinval), (float)(v81 + (float)(v72 * v75.__cosval)) + (float)(v73 * v75.__sinval), (float)((float)((float)(v68 - v87) * a7) + (float)(a4 * (float)(v36 - v68))) / v74, a12, (float)(v68 - v87) / v74, 0);
          float v68 = v68 + 0.1;
        }
        while (v36 > v68);
      }
    }
  }
}

void Path::DoArc(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8, int a9, int a10, float a11, int a12)
{
  if (a6 > 0.0001 && a7 > 0.0001)
  {
    float v18 = a4 - a2;
    float v19 = a5 - a3;
    __float2 v20 = __sincosf_stret(a8);
    float cosval = v20.__cosval;
    float sinval = v20.__sinval;
    float v79 = a6;
    float v23 = (float)((float)(v19 * v20.__sinval) + (float)(v20.__cosval * v18)) / a6;
    float v24 = (float)((float)(v19 * v20.__cosval) - (float)(v20.__sinval * v18)) / a7;
    float v25 = 4.0;
    if ((float)((float)(v24 * v24) + (float)(v23 * v23)) < 4.0) {
      float v25 = (float)(v24 * v24) + (float)(v23 * v23);
    }
    float v26 = (float)(v25 * -0.25) + 1.0;
    if (v26 < 0.0) {
      float v26 = 0.0;
    }
    float v27 = sqrtf(v26);
    float v28 = sqrtf(v25);
    float v29 = (float)-v23 / v28;
    float v30 = (float)(v24 / v28) * v27;
    float v31 = v23 * 0.5;
    float v32 = (float)-v30 - (float)(v23 * 0.5);
    float v33 = v24 * 0.5;
    float v34 = 3.1416;
    float v35 = 3.1416;
    if (v32 >= -1.0)
    {
      float v35 = 0.0;
      if (v32 <= 1.0)
      {
        float v78 = (float)-(float)(v29 * v27) - v33;
        float v36 = v33;
        float v37 = acosf(v32);
        float v33 = v36;
        float v34 = 3.1416;
        float sinval = v20.__sinval;
        float cosval = v20.__cosval;
        float v35 = v37;
        if (v78 < 0.0) {
          float v35 = 6.28318531 - v37;
        }
      }
    }
    float v38 = v29 * v27;
    float v39 = -sinval;
    float v40 = v31 - v30;
    if ((float)(v31 - v30) >= -1.0)
    {
      float v34 = 0.0;
      if (v40 <= 1.0)
      {
        float v41 = v33 - v38;
        float v42 = cosval;
        float v43 = sinval;
        float v44 = -sinval;
        float v45 = acosf(v40);
        float v39 = v44;
        float sinval = v43;
        float cosval = v42;
        float v34 = v45;
        if (v41 < 0.0) {
          float v34 = 6.28318531 - v45;
        }
      }
    }
    float v46 = (float)((float)(v38 * a7) * v39) + (float)(cosval * (float)(v30 * v79));
    float v47 = (float)(cosval * (float)(v38 * a7)) + (float)(sinval * (float)(v30 * v79));
    if (a10)
    {
      if (a9)
      {
        float v46 = -v46;
        float v47 = -v47;
        float v48 = v35 + 3.14159265;
        float v49 = v34 + 3.14159265;
        float v34 = v48 + -6.28318531;
        if (v48 < 6.28318531) {
          float v34 = v35 + 3.14159265;
        }
        if (v49 >= 6.28318531)
        {
          float v50 = v49 + -6.28318531;
          float v35 = v50;
        }
        else
        {
          float v35 = v49;
        }
      }
      float v51 = a5;
      float v52 = v35 + 6.28318531;
      if (v35 >= v34) {
        float v52 = v35;
      }
      float v88 = v52;
      float v53 = v52 + -0.1;
      if (v34 < v53)
      {
        float v54 = (float)((float)(a2 + a4) * 0.5) + v46;
        float v82 = (float)((float)(a3 + v51) * 0.5) + v47;
        float v85 = v54;
        float v55 = cosval * v79;
        float v56 = v39 * a7;
        float v57 = a7;
        float v58 = sinval * v79;
        float v59 = cosval * v57;
        float v60 = v52 - v34;
        do
        {
          float v61 = v34;
          __float2 v62 = __sincosf_stret(v53);
          Path::AddPoint(this, (float)(v85 + (float)(v55 * v62.__cosval)) + (float)(v56 * v62.__sinval), (float)(v82 + (float)(v58 * v62.__cosval)) + (float)(v59 * v62.__sinval), a12, (float)(v88 - v53) / v60, 0);
          float v34 = v61;
          float v53 = v53 + -0.1;
        }
        while (v61 < v53);
      }
    }
    else
    {
      if ((a9 & 1) == 0)
      {
        float v46 = -v46;
        float v47 = -v47;
        float v63 = v35 + 3.14159265;
        float v64 = v34 + 3.14159265;
        float v34 = v63 + -6.28318531;
        if (v63 < 6.28318531) {
          float v34 = v35 + 3.14159265;
        }
        if (v64 >= 6.28318531)
        {
          float v65 = v64 + -6.28318531;
          float v35 = v65;
        }
        else
        {
          float v35 = v64;
        }
      }
      float v66 = a5;
      float v67 = v35 + -6.28318531;
      if (v35 <= v34) {
        float v67 = v35;
      }
      float v89 = v67;
      float v68 = v67 + 0.1;
      if (v34 > v68)
      {
        float v69 = (float)((float)(a2 + a4) * 0.5) + v46;
        float v83 = (float)((float)(a3 + v66) * 0.5) + v47;
        float v86 = v69;
        float v70 = cosval * v79;
        float v71 = v39 * a7;
        float v72 = a7;
        float v73 = sinval * v79;
        float v74 = cosval * v72;
        float v75 = v34 - v67;
        do
        {
          float v76 = v34;
          __float2 v77 = __sincosf_stret(v68);
          Path::AddPoint(this, (float)(v86 + (float)(v70 * v77.__cosval)) + (float)(v71 * v77.__sinval), (float)(v83 + (float)(v73 * v77.__cosval)) + (float)(v74 * v77.__sinval), a12, (float)(v68 - v89) / v75, 0);
          float v34 = v76;
          float v68 = v68 + 0.1;
        }
        while (v76 > v68);
      }
    }
  }
}

Path *Path::RecBezierTo(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9, int a10, int a11, float a12, float a13, float a14, float a15)
{
  if (a10 >= 1)
  {
    float v21 = this;
    int v23 = a10 + 1;
    do
    {
      float v24 = (float)((float)(a5 - a2) * (float)(a9 - a3)) - (float)((float)(a6 - a3) * (float)(a8 - a2));
      float v25 = -v24;
      if (v24 >= 0.0) {
        float v25 = (float)((float)(a5 - a2) * (float)(a9 - a3)) - (float)((float)(a6 - a3) * (float)(a8 - a2));
      }
      if (v25 < a13) {
        break;
      }
      float v26 = (float)((float)(a5 + a8) + (float)(a2 * 2.0)) * 0.25;
      float v27 = (float)((float)(a6 + a9) + (float)(a3 * 2.0)) * 0.25;
      float v30 = (float)((float)(a7 + a12) + (float)(a4 * 2.0)) * 0.25;
      float v28 = (float)(a14 + a15) * 0.5;
      float v29 = a4;
      Path::RecBezierTo(v21, (float)(a2 + a5) * 0.5, (float)(a3 + a6) * 0.5, (float)(a4 + a7) * 0.5, a5, a6, a7, v26, v27, v30, a13, v23 - 2, a14, v28, a11);
      this = (Path *)Path::AddPoint(v21, v26, v27, v30, a11, v28, 0);
      a2 = (float)(a2 + a8) * 0.5;
      a3 = (float)(a3 + a9) * 0.5;
      a5 = v26;
      --v23;
      a14 = v28;
      a4 = (float)(v29 + a12) * 0.5;
      a7 = v30;
      a6 = v27;
    }
    while (v23 > 1);
  }
  return this;
}

Path *Path::RecBezierTo(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8, int a9, float a10, int a11, float a12)
{
  if (a9 >= 1)
  {
    float v18 = this;
    int v19 = a9 + 1;
    do
    {
      float v20 = (float)((float)(a4 - a2) * (float)(a7 - a3)) - (float)((float)(a5 - a3) * (float)(a6 - a2));
      float v21 = -v20;
      if (v20 >= 0.0) {
        float v21 = (float)((float)(a4 - a2) * (float)(a7 - a3)) - (float)((float)(a5 - a3) * (float)(a6 - a2));
      }
      if (v21 < a8) {
        break;
      }
      float v22 = (float)((float)(a4 + a6) + (float)(a2 * 2.0)) * 0.25;
      float v23 = (float)((float)(a5 + a7) + (float)(a3 * 2.0)) * 0.25;
      float v24 = (float)(a10 + a12) * 0.5;
      Path::RecBezierTo(v18, (float)(a2 + a4) * 0.5, (float)(a3 + a5) * 0.5, a4, a5, v22, v23, a8, v19 - 2, a10, v24, a11);
      this = (Path *)Path::AddPoint(v18, v22, v23, a11, v24, 0);
      a2 = (float)(a2 + a6) * 0.5;
      --v19;
      a3 = (float)(a3 + a7) * 0.5;
      a10 = v24;
      a5 = v23;
      a4 = v22;
    }
    while (v19 > 1);
  }
  return this;
}

void Path::ConvertForOffset(Path *this, float a2, Path *a3, float a4)
{
  int var0 = this->var0;
  if (this->var0)
  {
    Path::CancelBezier(this);
    int var0 = this->var0;
  }
  if ((var0 & 2) != 0) {
    Path::CloseSubpath(this, 0);
  }
  Path::SetBackData(this, 1);
  Path::ResetPoints(this, this->var2);
  if (this->var2 >= 1)
  {
    var3 = this->var3;
    float v10 = *((float *)var3 + 4);
    float v9 = *((float *)var3 + 5);
    int v11 = Path::AddPoint(this, v10, v9, 0, 0.0, 1);
    float v63 = a3;
    float v66 = a4;
    if (this->var2 >= 2)
    {
      int v15 = v11;
      uint64_t v16 = 1;
      float v17 = 2.0;
      do
      {
        float v18 = this->var3;
        float v19 = 0.0;
        float v20 = 0.0;
        switch(*((_DWORD *)v18 + 11 * (int)v16) & 0xF)
        {
          case 0:
            float v21 = (float *)((char *)v18 + 44 * (int)v16);
            float v19 = v21[4];
            float v20 = v21[5];
            int v15 = Path::AddPoint(this, v19, v20, v16, 0.0, 1);
            goto LABEL_25;
          case 1:
            float v22 = (float *)((char *)v18 + 44 * (int)v16);
            float v19 = v22[4];
            float v20 = v22[5];
            goto LABEL_24;
          case 2:
            float v23 = (float *)((char *)v18 + 44 * (int)v16);
            float v19 = v23[4];
            float v20 = v23[5];
            int v64 = *((_DWORD *)v23 + 1);
            uint64_t v65 = *((void *)v23 + 1);
            float v24 = v23[6];
            float v25 = v23[7];
            float v26 = v23[8];
            float v27 = v23[9];
            if (v64 < 0) {
              Path::RecCubicTo(this, v10, v9, v24, v25, v19, v20, v26, v27, 8, v16, a2, 0.0, 1.0);
            }
            else {
              Path::RecCubicTo(this, 8, v16, (uint64_t)&v63, v10, v9, v24, v25, v19, v20, v26, v27, a2, 0.0, 1.0);
            }
            goto LABEL_24;
          case 3:
            float v28 = (char *)v18 + 44 * (int)v16;
            int v29 = *((_DWORD *)v28 + 4);
            float v19 = *((float *)v28 + 5);
            float v20 = *((float *)v28 + 6);
            uint64_t v30 = (int)v16 + 1;
            if (v29 <= 0)
            {
              LODWORD(v16) = v16 + v29 - 1;
            }
            else
            {
              float v31 = (float *)((char *)v18 + 44 * v30);
              float v32 = v31[4];
              float v33 = v31[5];
              float v34 = -(float)(v32 - (float)(v10 * v17));
              float v35 = -(float)(v33 - (float)(v9 * v17));
              if (v29 == 1)
              {
                float v36 = -v32;
                float v37 = -v33;
              }
              else
              {
                int v60 = v15;
                int v45 = 0;
                float v46 = (void *)((char *)v18 + 44 * v30 + 96);
                float v47 = 0.5;
                do
                {
                  float v48 = v34;
                  float v49 = v35;
                  float v34 = v32;
                  float v35 = v33;
                  float v32 = *((float *)v46 - 9);
                  float v33 = *((float *)v46 - 8);
                  float v50 = (float)(v48 + v34) * v47;
                  float v51 = (float)(v49 + v35) * 0.5;
                  if (v45) {
                    Path::AddPoint(this, v50, v51, v16 - 1 + v45, 1.0, 0);
                  }
                  int v64 = *((_DWORD *)v46 - 1);
                  uint64_t v65 = *v46;
                  float v52 = (float)(v34 + v32) * 0.5;
                  float v53 = (float)(v35 + v33) * 0.5;
                  uint64_t v54 = (v16 + v45);
                  if (v64 < 0)
                  {
                    Path::RecBezierTo(this, v34, v35, v50, v51, v52, v53, a2, 8, 0.0, v54, 1.0);
                  }
                  else
                  {
                    *(float *)&double v13 = v35;
                    Path::RecBezierTo(this, 8, v54, (uint64_t)&v63, v34, v13, v50, v51, v52, v53, a2, 0.0, 1.0);
                  }
                  float v47 = 0.5;
                  ++v45;
                  float v46 = (void *)((char *)v46 + 44);
                }
                while (v29 - 1 != v45);
                float v36 = -v32;
                float v37 = -v33;
                int v15 = v60;
              }
              float v55 = (float)(v34 + v32) * 0.5;
              float v56 = (float)(v35 + v33) * 0.5;
              if (v29 >= 2)
              {
                float v61 = v37;
                Path::AddPoint(this, v55, (float)(v35 + v33) * 0.5, v16 + v29 - 2, 1.0, 0);
                float v37 = v61;
                float v56 = (float)(v35 + v33) * 0.5;
                float v55 = (float)(v34 + v32) * 0.5;
              }
              float v17 = 2.0;
              float v57 = (char *)v18 + 44 * v30;
              int v64 = *((_DWORD *)v57 + 1);
              uint64_t v65 = *((void *)v57 + 1);
              float v58 = (float)(v32 + (float)(v36 + (float)(v19 * 2.0))) * 0.5;
              float v59 = (float)(v33 + (float)(v37 + (float)(v20 * 2.0))) * 0.5;
              uint64_t v16 = (v16 + v29 - 1);
              if (v64 < 0)
              {
                Path::RecBezierTo(this, v32, v33, v55, v56, v58, v59, a2, 8, 0.0, v16, 1.0);
              }
              else
              {
                *(float *)&double v13 = v33;
                Path::RecBezierTo(this, 8, v16, (uint64_t)&v63, v32, v13, v55, v56, v58, v59, a2, 0.0, 1.0);
              }
            }
            Path::AddPoint(this, v19, v20, v16, 1.0, 0);
            uint64_t v16 = (v30 + v29);
            break;
          case 4:
            float v38 = (float *)((char *)v18 + 44 * (int)v16);
            float v19 = v38[4];
            float v20 = v38[5];
            int v64 = *((_DWORD *)v38 + 1);
            uint64_t v65 = *((void *)v38 + 1);
            float v39 = v38[6];
            float v40 = v38[7];
            float v41 = v38[8];
            BOOL v42 = *((unsigned __int8 *)v38 + 37) != 0;
            BOOL v43 = *((unsigned __int8 *)v38 + 36) != 0;
            if (v64 < 0) {
              Path::DoArc(this, v10, v9, v19, v20, v39, v40, v41, v43, v42, v14, v16);
            }
            else {
              Path::DoArc(this, v43, v42, v16, v10, v9, v19, v20, v39, v40, v41);
            }
            goto LABEL_24;
          case 5:
            float v44 = &this->var11[20 * v15];
            float v19 = *((float *)v44 + 1);
            float v20 = *((float *)v44 + 2);
LABEL_24:
            Path::AddPoint(this, v19, v20, v16, 1.0, 0);
            goto LABEL_25;
          case 6:
            break;
          case 7:
            *(float *)&double v12 = v10;
            Path::AddForcedPoint(this, v12, v9, v16, 1.0);
LABEL_25:
            uint64_t v16 = (v16 + 1);
            break;
          default:
            float v19 = 0.0;
            float v20 = 0.0;
            break;
        }
        float v9 = v20;
        float v10 = v19;
      }
      while ((int)v16 < this->var2);
    }
  }
}

void Path::RecCubicTo(Path *a1, int a2, uint64_t a3, uint64_t a4, float a5, float a6, float a7, float a8, float a9, float a10, float a11, float a12, float a13, float a14, float a15)
{
  float v26 = a9 - a5;
  float v27 = a10 - a6;
  float v28 = sqrtf((float)(v27 * v27) + (float)(v26 * v26));
  if (v28 >= 0.01)
  {
    float v30 = (float)(v26 * a8) - (float)(v27 * a7);
    float v31 = -v30;
    if (v30 >= 0.0) {
      float v31 = v30;
    }
    float v32 = -(float)((float)(v26 * a12) - (float)(v27 * a11));
    if ((float)((float)(v26 * a12) - (float)(v27 * a11)) >= 0.0) {
      float v32 = (float)(v26 * a12) - (float)(v27 * a11);
    }
    BOOL v29 = (float)(v31 / v28) < a13;
    if ((float)(v32 / v28) >= a13) {
      BOOL v29 = 0;
    }
  }
  else
  {
    BOOL v29 = (float)((float)(a7 * a7) + (float)(a8 * a8)) < a13 && (float)((float)(a11 * a11) + (float)(a12 * a12)) < a13;
  }
  int v33 = a2 < 1 || v29;
  Path::PointAndTangentAt(*(Path **)a4, *(_DWORD *)(a4 + 8), &v63, &v61, (float)(*(float *)(a4 + 16) * a14) + (float)(*(float *)(a4 + 12) * (float)(1.0 - a14)));
  double v34 = a14 * 0.5 + a15 * 0.5;
  *(float *)&double v34 = v34 * *(float *)(a4 + 16) + *(float *)(a4 + 12) * (1.0 - v34);
  Path::PointAndTangentAt(*(Path **)a4, *(_DWORD *)(a4 + 8), &v58, &v56, *(float *)&v34);
  Path::PointAndTangentAt(*(Path **)a4, *(_DWORD *)(a4 + 8), &v60, v59, (float)(*(float *)(a4 + 16) * a15) + (float)(*(float *)(a4 + 12) * (float)(1.0 - a15)));
  float v35 = *(float *)(a4 + 20);
  float v36 = v58.f32[0] - (float)(v35 * v57);
  float v37 = v58.f32[1] + (float)(v35 * v56);
  float v38 = v36 - (float)(v63.f32[0] - (float)(v35 * v62));
  float v39 = v37 - (float)(v63.f32[1] + (float)(v35 * v61));
  float v40 = (float)(v60.f32[0] - (float)(v35 * v59[1])) - v36;
  float v41 = (float)(v60.f32[1] + (float)(v35 * v59[0])) - v37;
  float v42 = (float)(v39 * v39) + (float)(v38 * v38);
  if (v42 > 0.0001)
  {
    float v43 = sqrtf(v42);
    float v38 = v38 / v43;
    float v39 = v39 / v43;
  }
  float v44 = (float)(v41 * v41) + (float)(v40 * v40);
  if (v44 > 0.0001)
  {
    float v45 = sqrtf(v44);
    float v40 = v40 / v45;
    float v41 = v41 / v45;
  }
  float v46 = (float)((float)(v57 - v62) * (float)(v41 - v39)) + (float)((float)(v56 - v61) * (float)(v40 - v38));
  if (v46 < 0.0) {
    int v47 = v33;
  }
  else {
    int v47 = 0;
  }
  if (v47 == 1)
  {
    Path::AddPoint(a1, v63.f32[0], v63.f32[1], -1, 0.0, 0);
    Path::AddPoint(a1, a9, a10, a3, a15, 0);
    Path::AddPoint(a1, a5, a6, a3, a14, 0);
    Path::AddPoint(a1, v60.f32[0], v60.f32[1], -1, 0.0, 0);
    return;
  }
  if (v46 >= 0.0)
  {
    if (v33) {
      return;
    }
  }
  else if (a2 < 1)
  {
    return;
  }
  float v50 = a10;
  float v48 = (float)((float)(a5 + a9) * 0.5) + (float)((float)(a7 - a11) * 0.125);
  float v49 = (float)((float)(a6 + a10) * 0.5) + (float)((float)(a8 - a12) * 0.125);
  Path::RecCubicTo(a1, (a2 - 1), a3, a4, a5, a6, a7 * 0.5, a8 * 0.5, v48, v49);
  Path::AddPoint(a1, v48, v49, a3, (float)(a14 + a15) * 0.5, 0);
  Path::RecCubicTo(a1, (a2 - 1), a3, a4, v48, v49, (float)((float)(v26 * 3.0) * 0.25) - (float)((float)(a7 + a11) * 0.125), (float)((float)(v27 * 3.0) * 0.25) - (float)((float)(a8 + a12) * 0.125), a9, v50);
}

void Path::DoArc(Path *a1, int a2, int a3, int a4, float a5, float a6, float a7, float a8, float a9, float a10, float a11)
{
  if (a9 > 0.0001 && a10 > 0.0001)
  {
    float v17 = a7 - a5;
    float v18 = a8 - a6;
    __float2 v19 = __sincosf_stret(a11);
    float cosval = v19.__cosval;
    float sinval = v19.__sinval;
    float v78 = a9;
    float v22 = (float)((float)(v18 * v19.__sinval) + (float)(v19.__cosval * v17)) / a9;
    float v23 = (float)((float)(v18 * v19.__cosval) - (float)(v19.__sinval * v17)) / a10;
    float v24 = 4.0;
    if ((float)((float)(v23 * v23) + (float)(v22 * v22)) < 4.0) {
      float v24 = (float)(v23 * v23) + (float)(v22 * v22);
    }
    float v25 = (float)(v24 * -0.25) + 1.0;
    if (v25 < 0.0) {
      float v25 = 0.0;
    }
    float v26 = sqrtf(v25);
    float v27 = sqrtf(v24);
    float v28 = (float)-v22 / v27;
    float v29 = (float)(v23 / v27) * v26;
    float v30 = v22 * 0.5;
    float v31 = (float)-v29 - (float)(v22 * 0.5);
    float v32 = v23 * 0.5;
    float v33 = 3.1416;
    float v34 = 3.1416;
    if (v31 >= -1.0)
    {
      float v34 = 0.0;
      if (v31 <= 1.0)
      {
        float v77 = (float)-(float)(v28 * v26) - v32;
        float v35 = v32;
        float v36 = acosf(v31);
        float v32 = v35;
        float v33 = 3.1416;
        float sinval = v19.__sinval;
        float cosval = v19.__cosval;
        float v34 = v36;
        if (v77 < 0.0) {
          float v34 = 6.28318531 - v36;
        }
      }
    }
    float v37 = v28 * v26;
    float v38 = -sinval;
    float v39 = v30 - v29;
    if ((float)(v30 - v29) >= -1.0)
    {
      float v33 = 0.0;
      if (v39 <= 1.0)
      {
        float v40 = v32 - v37;
        float v41 = cosval;
        float v42 = sinval;
        float v43 = -sinval;
        float v44 = acosf(v39);
        float v38 = v43;
        float sinval = v42;
        float cosval = v41;
        float v33 = v44;
        if (v40 < 0.0) {
          float v33 = 6.28318531 - v44;
        }
      }
    }
    float v45 = (float)((float)(v37 * a10) * v38) + (float)(cosval * (float)(v29 * v78));
    float v46 = (float)(cosval * (float)(v37 * a10)) + (float)(sinval * (float)(v29 * v78));
    if (a3)
    {
      if (a2)
      {
        float v45 = -v45;
        float v46 = -v46;
        float v47 = v34 + 3.14159265;
        float v48 = v33 + 3.14159265;
        float v33 = v47 + -6.28318531;
        if (v47 < 6.28318531) {
          float v33 = v34 + 3.14159265;
        }
        if (v48 >= 6.28318531)
        {
          float v49 = v48 + -6.28318531;
          float v34 = v49;
        }
        else
        {
          float v34 = v48;
        }
      }
      float v50 = a8;
      float v51 = v34 + 6.28318531;
      if (v34 >= v33) {
        float v51 = v34;
      }
      float v87 = v51;
      float v52 = v51 + -0.1;
      if (v33 < v52)
      {
        float v53 = (float)((float)(a5 + a7) * 0.5) + v45;
        float v81 = (float)((float)(a6 + v50) * 0.5) + v46;
        float v84 = v53;
        float v54 = cosval * v78;
        float v55 = v38 * a10;
        float v56 = a10;
        float v57 = sinval * v78;
        float v58 = cosval * v56;
        float v59 = v51 - v33;
        do
        {
          float v60 = v33;
          __float2 v61 = __sincosf_stret(v52);
          Path::AddPoint(a1, (float)(v84 + (float)(v54 * v61.__cosval)) + (float)(v55 * v61.__sinval), (float)(v81 + (float)(v57 * v61.__cosval)) + (float)(v58 * v61.__sinval), a4, (float)(v87 - v52) / v59, 0);
          float v33 = v60;
          float v52 = v52 + -0.1;
        }
        while (v60 < v52);
      }
    }
    else
    {
      if ((a2 & 1) == 0)
      {
        float v45 = -v45;
        float v46 = -v46;
        float v62 = v34 + 3.14159265;
        float v63 = v33 + 3.14159265;
        float v33 = v62 + -6.28318531;
        if (v62 < 6.28318531) {
          float v33 = v34 + 3.14159265;
        }
        if (v63 >= 6.28318531)
        {
          float v64 = v63 + -6.28318531;
          float v34 = v64;
        }
        else
        {
          float v34 = v63;
        }
      }
      float v65 = a8;
      float v66 = v34 + -6.28318531;
      if (v34 <= v33) {
        float v66 = v34;
      }
      float v88 = v66;
      float v67 = v66 + 0.1;
      if (v33 > v67)
      {
        float v68 = (float)((float)(a5 + a7) * 0.5) + v45;
        float v82 = (float)((float)(a6 + v65) * 0.5) + v46;
        float v85 = v68;
        float v69 = cosval * v78;
        float v70 = v38 * a10;
        float v71 = a10;
        float v72 = sinval * v78;
        float v73 = cosval * v71;
        float v74 = v33 - v66;
        do
        {
          float v75 = v33;
          __float2 v76 = __sincosf_stret(v67);
          Path::AddPoint(a1, (float)(v85 + (float)(v69 * v76.__cosval)) + (float)(v70 * v76.__sinval), (float)(v82 + (float)(v72 * v76.__cosval)) + (float)(v73 * v76.__sinval), a4, (float)(v67 - v88) / v74, 0);
          float v33 = v75;
          float v67 = v67 + 0.1;
        }
        while (v75 > v67);
      }
    }
  }
}

void Path::RecBezierTo(Path *a1, int a2, uint64_t a3, uint64_t a4, float a5, double a6, float a7, float32_t a8, float a9, float a10, float a11, float a12, float a13)
{
  float v19 = *(float *)&a6;
  float v21 = (float)((float)(a7 - a5) * (float)(a10 - *(float *)&a6))
      - (float)((float)(a8 - *(float *)&a6) * (float)(a9 - a5));
  float v22 = -v21;
  if (v21 >= 0.0) {
    float v22 = v21;
  }
  uint64_t v23 = (a2 - 1);
  if (a2 >= 1)
  {
    float v32 = v22;
    uint64_t v38 = 0;
    unint64_t v37 = __PAIR64__(LODWORD(a6), LODWORD(a5));
    v36[0] = 1;
    *(float *)&v36[1] = a9;
    *(float *)&v36[2] = a10;
    *(float *)&a6 = a7;
    Path::TangentOnBezAt((float32x2_t *)&v37, (uint64_t)v36, 0, &v39, (uint64_t)&v40, (float *)&v38 + 1, (float *)&v38, 0.0, *(float32x2_t *)&a6, a8);
    Path::PointAndTangentAt(*(Path **)a4, *(_DWORD *)(a4 + 8), &v45, v44, (float)(*(float *)(a4 + 16) * a12) + (float)(*(float *)(a4 + 12) * (float)(1.0 - a12)));
    float v28 = (float)(v41 * v44[1]) + (float)(v40 * v44[0]);
    v29.f32[0] = a7;
    Path::TangentOnBezAt((float32x2_t *)&v37, (uint64_t)v36, 0, &v39, (uint64_t)&v40, (float *)&v38 + 1, (float *)&v38, 1.0, v29, a8);
    Path::PointAndTangentAt(*(Path **)a4, *(_DWORD *)(a4 + 8), &v43, v42, (float)(*(float *)(a4 + 16) * a13) + (float)(*(float *)(a4 + 12) * (float)(1.0 - a13)));
    float v30 = (float)(v41 * v42[1]) + (float)(v40 * v42[0]);
    if (v28 >= 0.0 || v30 >= 0.0)
    {
      if (v32 >= a11 || v28 < 0.0 || v30 < 0.0)
      {
        float v31 = (float)((float)(a8 + a10) + (float)(v19 * 2.0)) * 0.25;
        Path::RecBezierTo(a1, v23, a3, a4, (float)(a5 + a7) * 0.5, (float)(v19 + a8) * 0.5, a7, a8);
        Path::AddPoint(a1, (float)((float)(a7 + a9) + (float)(a5 * 2.0)) * 0.25, v31, a3, (float)(a12 + a13) * 0.5, 0);
        Path::RecBezierTo(a1, v23, a3, a4, (float)(a5 + a9) * 0.5, (float)(v19 + a10) * 0.5, (float)((float)(a7 + a9) + (float)(a5 * 2.0)) * 0.25, v31);
      }
    }
    else
    {
      Path::AddPoint(a1, v45.f32[0], v45.f32[1], -1, 0.0, 0);
      Path::AddPoint(a1, a9, a10, a3, a13, 0);
      Path::AddPoint(a1, a7, a8, a3, a12, 0);
      Path::AddPoint(a1, v43.f32[0], v43.f32[1], -1, 0.0, 0);
    }
  }
}

void Path::Convert(Path *this, float a2)
{
  int var0 = this->var0;
  if (this->var0)
  {
    Path::CancelBezier(this);
    int var0 = this->var0;
  }
  if ((var0 & 2) != 0) {
    Path::CloseSubpath(this, 0);
  }
  Path::SetBackData(this, 0);
  Path::ResetPoints(this, this->var2);
  if (this->var2 >= 1)
  {
    var3 = this->var3;
    float v5 = 1.0;
    if ((*(unsigned char *)var3 & 0x10) != 0) {
      float v5 = *((float *)var3 + 7);
    }
    float v7 = *((float *)var3 + 4);
    float v6 = *((float *)var3 + 5);
    if (this->var6) {
      uint64_t v8 = Path::AddPoint(this, v7, v6, v5, 1);
    }
    else {
      uint64_t v8 = Path::AddPoint(this, v7, v6, 1);
    }
    uint64_t v10 = v8;
    *((_DWORD *)this->var3 + 1) = v8;
    if (this->var2 >= 2)
    {
      int v11 = 1;
      float v12 = 2.0;
      while (2)
      {
        double v13 = this->var3;
        float v14 = (int *)((char *)v13 + 44 * v11);
        int v15 = *v14;
        float v16 = 0.0;
        uint64_t v17 = v11;
        float v18 = 0.0;
        float v19 = 0.0;
        switch(*v14 & 0xF)
        {
          case 0:
            float v20 = (float *)((char *)v13 + 44 * v11);
            float v22 = v20[4];
            float v21 = (char *)(v20 + 4);
            float v16 = v22;
            float v19 = 1.0;
            if ((v15 & 0x10) != 0) {
              float v19 = *((float *)v21 + 3);
            }
            float v18 = *((float *)v21 + 1);
            if (this->var6) {
              uint64_t v23 = Path::AddPoint(this, v16, v18, v19, 1);
            }
            else {
              uint64_t v23 = Path::AddPoint(this, v16, v18, 1);
            }
            uint64_t v10 = v23;
            goto LABEL_64;
          case 1:
            float v24 = (float *)((char *)v13 + 44 * v11);
            float v26 = v24[4];
            float v25 = (char *)(v24 + 4);
            float v16 = v26;
            float v19 = 1.0;
            if ((v15 & 0x10) != 0) {
              float v19 = *((float *)v25 + 2);
            }
            float v18 = *((float *)v25 + 1);
            if (this->var6) {
              int v27 = Path::AddPoint(this, v16, v18, v19, 0);
            }
            else {
              int v27 = Path::AddPoint(this, v16, v18, 0);
            }
            __float2 v61 = (char *)v13 + 44 * v11;
            *((_DWORD *)v61 + 1) = v27;
            float v62 = v61 + 4;
            if ((v27 & 0x80000000) == 0) {
              goto LABEL_65;
            }
            if (v11) {
              goto LABEL_61;
            }
            int v63 = 0;
            goto LABEL_62;
          case 2:
            float v28 = (float *)((char *)v13 + 44 * v11);
            float v30 = v28[4];
            float32x2_t v29 = v28 + 4;
            float v16 = v30;
            float v19 = 1.0;
            if ((v15 & 0x10) != 0) {
              float v19 = v29[6];
            }
            float v18 = v29[1];
            float v31 = v29[2];
            float v32 = v29[3];
            float v33 = v29[4];
            float v34 = v29[5];
            float v35 = (_DWORD *)((char *)v13 + 44 * v11 + 4);
            if (!this->var6)
            {
              Path::RecCubicTo(this, v7, v6, v31, v32, v16, v18, v33, v34, 8, a2, -1.0);
              goto LABEL_53;
            }
            Path::RecCubicTo(this, v7, v6, v5, v31, v32, v16, v18, v19, 8, v33, v34, a2, -1.0);
            int v36 = Path::AddPoint(this, v16, v18, v19, 0);
            *float v35 = v36;
            if ((v36 & 0x80000000) == 0) {
              goto LABEL_65;
            }
            if (!v11) {
              goto LABEL_27;
            }
            goto LABEL_56;
          case 3:
            uint64_t v106 = v10;
            uint64_t v38 = (char *)v13 + 44 * v11;
            int v41 = *((_DWORD *)v38 + 4);
            float32x2_t v39 = (float *)(v38 + 16);
            int v40 = v41;
            float v19 = 1.0;
            if ((v15 & 0x10) != 0) {
              float v19 = v39[3];
            }
            float v16 = v39[1];
            float v18 = v39[2];
            uint64_t v42 = v17 + 1;
            if (v40 >= 1)
            {
              float32x2_t v43 = (float *)((char *)v13 + 44 * v42);
              float v46 = v43[4];
              float v45 = v43[5];
              float v44 = (char *)(v43 + 4);
              int v47 = v40 - 1;
              if (v40 == 1)
              {
                float v48 = 1.0;
                if ((v15 & 0x10) != 0) {
                  float v48 = *((float *)v44 + 2);
                }
                if (this->var6) {
                  Path::RecBezierTo(this, v46, v45, v48, v7, v6, v5, v16, v18, 8, v19, a2, -1.0);
                }
                else {
                  Path::RecBezierTo(this, v46, v45, v7, v6, v16, v18, a2, 8, -1.0);
                }
              }
              else
              {
                int v102 = v40;
                float v104 = v16;
                float v105 = v18;
                float v103 = v19;
                float v66 = 1.0;
                if ((v15 & 0x10) != 0) {
                  float v66 = *((float *)v44 + 2);
                }
                int v67 = 0;
                float v68 = -(float)(v46 - (float)(v7 * v12));
                float v69 = -(float)(v45 - (float)(v6 * v12));
                float v70 = -(float)(v66 - (float)(v5 * v12));
                float v71 = (float *)((char *)v13 + 44 * v42 + 68);
                do
                {
                  float v72 = v46;
                  float v73 = v45;
                  float v74 = v66;
                  float v75 = 1.0;
                  if ((v15 & 0x10) != 0) {
                    float v75 = *v71;
                  }
                  float v77 = *(v71 - 2);
                  float v76 = *(v71 - 1);
                  float v78 = v68 + v72;
                  float v79 = v78 * 0.5;
                  float v80 = (float)(v69 + v45) * 0.5;
                  float v81 = (float)(v70 + v74) * 0.5;
                  float v82 = v76;
                  float v108 = v75;
                  float v109 = v77;
                  if (v67)
                  {
                    int v83 = this->var6
                        ? Path::AddPoint(this, v78 * 0.5, (float)(v69 + v45) * 0.5, v81, 0)
                        : Path::AddPoint(this, v78 * 0.5, (float)(v69 + v45) * 0.5, 0);
                    *((_DWORD *)v71 - 16) = v83;
                    float v76 = v82;
                    float v75 = v108;
                    float v77 = v109;
                    if (v83 < 0)
                    {
                      if (v17 == -1) {
                        int v84 = 0;
                      }
                      else {
                        int v84 = *((_DWORD *)v71 - 27);
                      }
                      *((_DWORD *)v71 - 16) = v84;
                    }
                  }
                  float v85 = (float)(v72 + v77) * 0.5;
                  float v86 = (float)(v73 + v76) * 0.5;
                  if (this->var6)
                  {
                    float v87 = v79;
                    float v88 = v81;
                    float v89 = v85;
                    float v90 = (float)(v73 + v76) * 0.5;
                    Path::RecBezierTo(this, v72, v73, v74, v87, v80, v88, v85, v86, 8, (float)(v74 + v75) * 0.5, a2, -1.0);
                  }
                  else
                  {
                    float v91 = v79;
                    float v89 = (float)(v72 + v77) * 0.5;
                    float v90 = (float)(v73 + v76) * 0.5;
                    Path::RecBezierTo(this, v72, v73, v91, v80, v89, v86, a2, 8, -1.0);
                  }
                  float v66 = v108;
                  float v46 = v109;
                  float v45 = v82;
                  ++v67;
                  v71 += 11;
                  float v70 = v74;
                  float v69 = v73;
                  float v68 = v72;
                }
                while (v47 != v67);
                if (this->var6) {
                  int v92 = Path::AddPoint(this, v89, v90, (float)(v74 + v108) * 0.5, 0);
                }
                else {
                  int v92 = Path::AddPoint(this, v89, v90, 0);
                }
                float v19 = v103;
                float v16 = v104;
                int v40 = v102;
                *((_DWORD *)v71 - 16) = v92;
                float v93 = v82;
                if (v92 < 0)
                {
                  if (v17 == -1) {
                    int v94 = 0;
                  }
                  else {
                    int v94 = *((_DWORD *)v71 - 27);
                  }
                  *((_DWORD *)v71 - 16) = v94;
                }
                float v95 = v109 - (float)(v109 - (float)(v104 * 2.0));
                float v96 = (float)(v82 - (float)(v82 - (float)(v105 * 2.0))) * 0.5;
                float v12 = 2.0;
                if (this->var6) {
                  Path::RecBezierTo(this, v109, v93, v108, v89, v90, (float)(v74 + v108) * 0.5, v95 * 0.5, v96, 8, (float)(v108 - (float)(v108 - (float)(v103 * 2.0))) * 0.5, a2, -1.0);
                }
                else {
                  Path::RecBezierTo(this, v109, v93, v89, v90, v95 * 0.5, v96, a2, 8, -1.0);
                }
                float v18 = v105;
              }
            }
            if (this->var6) {
              int v97 = Path::AddPoint(this, v16, v18, v19, 0);
            }
            else {
              int v97 = Path::AddPoint(this, v16, v18, 0);
            }
            uint64_t v98 = (char *)v13 + 44 * (int)v17;
            *((_DWORD *)v98 + 1) = v97;
            float64x2_t v99 = v98 + 4;
            if (v97 < 0)
            {
              if (v17 == -1) {
                int v100 = 0;
              }
              else {
                int v100 = *(v14 - 10);
              }
              *float64x2_t v99 = v100;
            }
            int v11 = v40 + v42;
            uint64_t v10 = v106;
            goto LABEL_66;
          case 4:
            float v49 = (float *)((char *)v13 + 44 * v11);
            float v51 = v49[4];
            float v50 = (char *)(v49 + 4);
            float v16 = v51;
            float v19 = 1.0;
            if ((v15 & 0x10) != 0) {
              float v19 = *((float *)v50 + 6);
            }
            float v18 = *((float *)v50 + 1);
            float v52 = *((float *)v50 + 2);
            float v53 = *((float *)v50 + 3);
            float v54 = *((float *)v50 + 4);
            float v35 = (_DWORD *)((char *)v13 + 44 * v11 + 4);
            BOOL v55 = v50[21] != 0;
            BOOL v56 = v50[20] != 0;
            if (this->var6)
            {
              Path::DoArc(this, v7, v6, v5, v16, v18, v19, v52, v53, v56, v55, v54, v101);
              int v57 = Path::AddPoint(this, v16, v18, v19, 0);
            }
            else
            {
              Path::DoArc(this, v7, v6, v16, v18, v52, v53, v54, v56, v55, v53);
LABEL_53:
              int v57 = Path::AddPoint(this, v16, v18, 0);
            }
            *float v35 = v57;
            if ((v57 & 0x80000000) == 0) {
              goto LABEL_65;
            }
            if (v11) {
LABEL_56:
            }
              int v37 = *(v14 - 10);
            else {
LABEL_27:
            }
              int v37 = 0;
            *float v35 = v37;
LABEL_65:
            ++v11;
LABEL_66:
            float v5 = v19;
            float v6 = v18;
            float v7 = v16;
            if (v11 >= this->var2) {
              return;
            }
            continue;
          case 5:
            var11 = this->var11;
            if (this->var6)
            {
              float v59 = (float *)&var11[16 * (int)v10];
              float v16 = v59[1];
              float v18 = v59[2];
              float v19 = v59[3];
              int v60 = Path::AddPoint(this, v16, v18, v19, 0);
            }
            else
            {
              float v64 = &var11[12 * (int)v10];
              float v16 = *((float *)v64 + 1);
              float v18 = *((float *)v64 + 2);
              int v60 = Path::AddPoint(this, v16, v18, 0);
            }
            float v65 = (char *)v13 + 44 * v11;
            *((_DWORD *)v65 + 1) = v60;
            float v62 = v65 + 4;
            if ((v60 & 0x80000000) == 0) {
              goto LABEL_65;
            }
            if (v11)
            {
LABEL_61:
              int v63 = *(v14 - 10);
LABEL_62:
              *float v62 = v63;
            }
            else
            {
              *float v62 = 0;
            }
            goto LABEL_65;
          case 6:
            goto LABEL_66;
          case 7:
            if (this->var6)
            {
              Path::AddForcedPoint(this, v7, v6, v5);
            }
            else
            {
              *(float *)&double v9 = v7;
              double v9 = Path::AddForcedPoint(this, v9, v6);
            }
LABEL_64:
            *((_DWORD *)v13 + 11 * v11 + 1) = v23;
            goto LABEL_65;
          default:
            float v18 = 0.0;
            float v19 = 0.0;
            goto LABEL_66;
        }
      }
    }
  }
}

Path *Path::RecCubicTo(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9, int a10, float a11, float a12, float a13, float a14)
{
  uint64_t v17 = this;
  float v19 = a13;
  float v18 = a14;
  for (float i = 0.5; ; float i = 0.5)
  {
    float v23 = a7 - a2;
    float v24 = a8 - a3;
    float v25 = sqrtf((float)(v24 * v24) + (float)(v23 * v23));
    if (v25 < 0.01)
    {
      if ((float)((float)(a5 * a5) + (float)(a6 * a6)) >= v19)
      {
LABEL_18:
        if (a10 < 1) {
          return this;
        }
      }
      else if ((float)((float)(a11 * a11) + (float)(a12 * a12)) < v19 || a10 < 1)
      {
        return this;
      }
      float v32 = (float)(a4 + a9) * i;
      float v33 = (float)((float)(a2 + a7) * i) + (float)((float)(a5 - a11) * 0.125);
      float v34 = a8;
      float v35 = (float)((float)(a3 + a8) * i) + (float)((float)(a6 - a12) * 0.125);
      float v36 = (float)((float)(v23 * 3.0) * 0.25) - (float)((float)(a5 + a11) * 0.125);
      float v37 = (float)(a6 + a12) * 0.125;
      float v47 = a11;
      float v49 = a12;
      float v38 = a7;
      float v39 = v34;
      float v40 = (float)((float)(v24 * 3.0) * 0.25) - v37;
      --a10;
      float v41 = 0.5;
      Path::RecCubicTo(v17, a2, a3, a4, a5 * i, a6 * i, v33, v35, v32, v36, v40, v19, a10, v18);
      this = (Path *)Path::AddPoint(v17, v33, v35, v32, 0);
      a2 = v33;
      a3 = v35;
      a4 = v32;
      a5 = v36;
      a6 = v40;
      a8 = v39;
      a7 = v38;
      a11 = v47;
      a12 = v49;
      goto LABEL_26;
    }
    float v27 = (float)(v23 * a6) - (float)(v24 * a5);
    float v28 = -v27;
    if (v27 >= 0.0) {
      float v28 = (float)(v23 * a6) - (float)(v24 * a5);
    }
    float v29 = -(float)((float)(v23 * a12) - (float)(v24 * a11));
    if ((float)((float)(v23 * a12) - (float)(v24 * a11)) >= 0.0) {
      float v29 = (float)(v23 * a12) - (float)(v24 * a11);
    }
    float v30 = v29 / v25;
    if ((float)(v28 / v25) >= v19 || v30 >= v19) {
      goto LABEL_18;
    }
    if (v18 <= 0.0) {
      break;
    }
    if (v25 <= v18 || a10 < 1) {
      break;
    }
    float v43 = (float)(a4 + a9) * i;
    float v44 = (float)((float)(a2 + a7) * i) + (float)((float)(a5 - a11) * 0.125);
    float v45 = (float)((float)(a3 + a8) * i) + (float)((float)(a6 - a12) * 0.125);
    float v48 = (float)((float)(v23 * 3.0) * 0.25) - (float)((float)(a5 + a11) * 0.125);
    float v50 = (float)((float)(v24 * 3.0) * 0.25) - (float)((float)(a6 + a12) * 0.125);
    --a10;
    float v41 = 0.5;
    Path::RecCubicTo(v17, a2, a3, a4, a5 * i, a6 * i, v44, v45, v43, v48, v50, v19, a10, v18);
    this = (Path *)Path::AddPoint(v17, v44, v45, v43, 0);
    a2 = v44;
    a3 = v45;
    a4 = v43;
    a5 = v48;
    a6 = v50;
LABEL_26:
    a12 = a12 * v41;
    a11 = a11 * v41;
    float v19 = a13;
    float v18 = a14;
  }
  return this;
}

Path *Path::RecCubicTo(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9, int a10, float a11, float a12)
{
  int v15 = this;
  float v16 = a12;
  float v31 = a6;
  float v32 = a7;
  while (1)
  {
    float v17 = a6 - a2;
    float v18 = a7 - a3;
    float v19 = sqrtf((float)(v18 * v18) + (float)(v17 * v17));
    if (v19 >= 0.01) {
      break;
    }
    if ((float)((float)(a4 * a4) + (float)(a5 * a5)) >= a11) {
      goto LABEL_18;
    }
    if ((float)((float)(a8 * a8) + (float)(a9 * a9)) < a11 || a10 < 1) {
      return this;
    }
LABEL_25:
    float v27 = (float)((float)(a2 + a6) * 0.5) + (float)((float)(a4 - a8) * 0.125);
    float v28 = (float)((float)(a3 + a7) * 0.5) + (float)((float)(a5 - a9) * 0.125);
    float v29 = (float)((float)(v17 * 3.0) * 0.25) - (float)((float)(a4 + a8) * 0.125);
    float v30 = (float)((float)(v18 * 3.0) * 0.25) - (float)((float)(a5 + a9) * 0.125);
    Path::RecCubicTo(v15, a2, a3, a4 * 0.5, a5 * 0.5, v27, v28, v29, v30, a11, --a10, v16);
    this = (Path *)Path::AddPoint(v15, v27, v28, 0);
    a2 = v27;
    a3 = v28;
    a4 = v29;
    a5 = v30;
    a9 = a9 * 0.5;
    a8 = a8 * 0.5;
    a6 = v31;
    a7 = v32;
    float v16 = a12;
  }
  float v21 = (float)(v17 * a5) - (float)(v18 * a4);
  float v22 = -v21;
  if (v21 >= 0.0) {
    float v22 = (float)(v17 * a5) - (float)(v18 * a4);
  }
  float v23 = -(float)((float)(v17 * a9) - (float)(v18 * a8));
  if ((float)((float)(v17 * a9) - (float)(v18 * a8)) >= 0.0) {
    float v23 = (float)(v17 * a9) - (float)(v18 * a8);
  }
  float v24 = v23 / v19;
  if ((float)(v22 / v19) >= a11 || v24 >= a11)
  {
LABEL_18:
    if (a10 < 1) {
      return this;
    }
    goto LABEL_25;
  }
  if (v16 > 0.0 && v19 > v16 && a10 >= 1) {
    goto LABEL_25;
  }
  return this;
}

void Path::DoArc(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9, int a10, int a11, float a12, float a13)
{
  if (a8 > 0.0001 && a9 > 0.0001)
  {
    float v18 = a5 - a2;
    float v19 = a6 - a3;
    __float2 v20 = __sincosf_stret(a12);
    float cosval = v20.__cosval;
    float sinval = v20.__sinval;
    float v77 = a8;
    float v78 = a9;
    float v23 = (float)((float)(v19 * v20.__sinval) + (float)(v20.__cosval * v18)) / a8;
    float v24 = (float)((float)(v19 * v20.__cosval) - (float)(v20.__sinval * v18)) / a9;
    float v25 = 4.0;
    if ((float)((float)(v24 * v24) + (float)(v23 * v23)) < 4.0) {
      float v25 = (float)(v24 * v24) + (float)(v23 * v23);
    }
    float v26 = (float)(v25 * -0.25) + 1.0;
    if (v26 < 0.0) {
      float v26 = 0.0;
    }
    float v27 = sqrtf(v26);
    float v28 = sqrtf(v25);
    float v29 = (float)-v23 / v28;
    float v30 = (float)(v24 / v28) * v27;
    float v31 = v23 * 0.5;
    float v32 = (float)-v30 - (float)(v23 * 0.5);
    float v33 = v24 * 0.5;
    float v34 = 3.1416;
    float v35 = 3.1416;
    if (v32 >= -1.0)
    {
      float v35 = 0.0;
      if (v32 <= 1.0)
      {
        float v74 = (float)-(float)(v29 * v27) - v33;
        float v75 = v33;
        float v36 = acosf(v32);
        float sinval = v20.__sinval;
        float cosval = v20.__cosval;
        float v35 = v36;
        float v33 = v75;
        if (v74 < 0.0) {
          float v35 = 6.28318531 - v36;
        }
      }
    }
    float v37 = v29 * v27;
    float v38 = -sinval;
    float v39 = v31 - v30;
    if ((float)(v31 - v30) >= -1.0)
    {
      float v34 = 0.0;
      if (v39 <= 1.0)
      {
        float v40 = v33 - v37;
        float v41 = cosval;
        float v42 = sinval;
        float v43 = acosf(v39);
        float sinval = v42;
        float cosval = v41;
        float v34 = v43;
        if (v40 < 0.0) {
          float v34 = 6.28318531 - v43;
        }
      }
    }
    float v44 = (float)((float)(v37 * v78) * v38) + (float)(cosval * (float)(v30 * v77));
    float v45 = (float)(cosval * (float)(v37 * v78)) + (float)(sinval * (float)(v30 * v77));
    if (a11)
    {
      if (a10)
      {
        float v44 = -v44;
        float v45 = -v45;
        float v46 = v35 + 3.14159265;
        float v47 = v34 + 3.14159265;
        if (v46 >= 6.28318531)
        {
          float v48 = v46 + -6.28318531;
          float v34 = v48;
        }
        else
        {
          float v34 = v35 + 3.14159265;
        }
        if (v47 >= 6.28318531)
        {
          float v49 = v47 + -6.28318531;
          float v35 = v49;
        }
        else
        {
          float v35 = v47;
        }
      }
      float v50 = a6;
      float v51 = v35 + 6.28318531;
      if (v35 >= v34) {
        float v51 = v35;
      }
      float v86 = v51;
      float v52 = v51 + -0.1;
      if (v34 < v52)
      {
        float v53 = (float)((float)(a2 + a5) * 0.5) + v44;
        float v80 = (float)((float)(a3 + v50) * 0.5) + v45;
        float v83 = v53;
        float v54 = cosval * v77;
        float v55 = v38 * v78;
        float v56 = sinval * v77;
        float v57 = cosval * v78;
        float v58 = v51 - v34;
        do
        {
          __float2 v59 = __sincosf_stret(v52);
          Path::AddPoint(this, (float)(v83 + (float)(v54 * v59.__cosval)) + (float)(v55 * v59.__sinval), (float)(v80 + (float)(v56 * v59.__cosval)) + (float)(v57 * v59.__sinval), (float)((float)((float)(v86 - v52) * a7) + (float)(a4 * (float)(v52 - v34))) / v58, 0);
          float v52 = v52 + -0.1;
        }
        while (v34 < v52);
      }
    }
    else
    {
      if ((a10 & 1) == 0)
      {
        float v44 = -v44;
        float v45 = -v45;
        float v60 = v35 + 3.14159265;
        float v61 = v34 + 3.14159265;
        if (v60 >= 6.28318531)
        {
          float v62 = v60 + -6.28318531;
          float v34 = v62;
        }
        else
        {
          float v34 = v35 + 3.14159265;
        }
        if (v61 >= 6.28318531)
        {
          float v63 = v61 + -6.28318531;
          float v35 = v63;
        }
        else
        {
          float v35 = v61;
        }
      }
      float v64 = a6;
      float v65 = v35 + -6.28318531;
      if (v35 <= v34) {
        float v65 = v35;
      }
      float v87 = v65;
      float v66 = v65 + 0.1;
      if (v34 > v66)
      {
        float v67 = (float)((float)(a2 + a5) * 0.5) + v44;
        float v81 = (float)((float)(a3 + v64) * 0.5) + v45;
        float v84 = v67;
        float v68 = cosval * v77;
        float v69 = v38 * v78;
        float v70 = sinval * v77;
        float v71 = cosval * v78;
        float v72 = v34 - v65;
        do
        {
          __float2 v73 = __sincosf_stret(v66);
          Path::AddPoint(this, (float)(v84 + (float)(v68 * v73.__cosval)) + (float)(v69 * v73.__sinval), (float)(v81 + (float)(v70 * v73.__cosval)) + (float)(v71 * v73.__sinval), (float)((float)((float)(v66 - v87) * a7) + (float)(a4 * (float)(v34 - v66))) / v72, 0);
          float v66 = v66 + 0.1;
        }
        while (v34 > v66);
      }
    }
  }
}

void Path::DoArc(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8, int a9, int a10, float a11)
{
  if (a6 > 0.0001 && a7 > 0.0001)
  {
    float v15 = a4 - a2;
    float v17 = a5 - a3;
    __float2 v20 = __sincosf_stret(a8);
    float cosval = v20.__cosval;
    float sinval = v20.__sinval;
    float v21 = (float)(v17 * v20.__sinval) + (float)(v20.__cosval * v15);
    float v22 = v17 * v20.__cosval;
    float v23 = a7;
    float v80 = a6;
    float v24 = v21 / a6;
    float v25 = (float)(v22 - (float)(v20.__sinval * v15)) / a7;
    float v26 = 4.0;
    if ((float)((float)(v25 * v25) + (float)(v24 * v24)) < 4.0) {
      float v26 = (float)(v25 * v25) + (float)(v24 * v24);
    }
    float v27 = (float)(v26 * -0.25) + 1.0;
    if (v27 < 0.0) {
      float v27 = 0.0;
    }
    float v28 = sqrtf(v27);
    float v29 = sqrtf(v26);
    float v30 = (float)-v24 / v29;
    float v31 = (float)(v25 / v29) * v28;
    float v32 = v24 * 0.5;
    float v33 = (float)-v31 - (float)(v24 * 0.5);
    float v34 = v25 * 0.5;
    float v35 = 3.1416;
    float v36 = 3.1416;
    if (v33 >= -1.0)
    {
      float v36 = 0.0;
      if (v33 <= 1.0)
      {
        float v76 = (float)-(float)(v30 * v28) - v34;
        float v37 = v34;
        float v38 = acosf(v33);
        float v34 = v37;
        float cosval = v20.__cosval;
        float v35 = 3.1416;
        float sinval = v20.__sinval;
        float v36 = v38;
        float v23 = a7;
        if (v76 < 0.0) {
          float v36 = 6.28318531 - v38;
        }
      }
    }
    float v39 = v30 * v28;
    float v40 = -sinval;
    float v41 = v32 - v31;
    if ((float)(v32 - v31) >= -1.0)
    {
      float v35 = 0.0;
      if (v41 <= 1.0)
      {
        float v42 = v34 - v39;
        float v43 = cosval;
        float v44 = sinval;
        float v45 = acosf(v41);
        float sinval = v44;
        float cosval = v43;
        float v35 = v45;
        if (v42 < 0.0) {
          float v35 = 6.28318531 - v45;
        }
      }
    }
    float v46 = (float)((float)(v39 * v23) * v40) + (float)(cosval * (float)(v31 * v80));
    float v47 = (float)(cosval * (float)(v39 * v23)) + (float)(sinval * (float)(v31 * v80));
    if (a10)
    {
      if (a9)
      {
        float v46 = -v46;
        float v47 = -v47;
        float v48 = v36 + 3.14159265;
        float v49 = v35 + 3.14159265;
        if (v48 >= 6.28318531)
        {
          float v50 = v48 + -6.28318531;
          float v35 = v50;
        }
        else
        {
          float v35 = v36 + 3.14159265;
        }
        if (v49 >= 6.28318531)
        {
          float v51 = v49 + -6.28318531;
          float v36 = v51;
        }
        else
        {
          float v36 = v49;
        }
      }
      float v52 = a5;
      float v53 = v36 + 6.28318531;
      if (v36 >= v35) {
        float v53 = v36;
      }
      float v54 = v53 + -0.1;
      if (v35 < v54)
      {
        float v82 = (float)((float)(a2 + a4) * 0.5) + v46;
        float v55 = (float)((float)(a3 + v52) * 0.5) + v47;
        float v56 = cosval * v80;
        float v57 = v40 * v23;
        float v58 = sinval * v80;
        float v59 = cosval * v23;
        do
        {
          float v60 = v35;
          __float2 v61 = __sincosf_stret(v54);
          Path::AddPoint(this, (float)(v82 + (float)(v56 * v61.__cosval)) + (float)(v57 * v61.__sinval), (float)(v55 + (float)(v58 * v61.__cosval)) + (float)(v59 * v61.__sinval), 0);
          float v35 = v60;
          float v54 = v54 + -0.1;
        }
        while (v60 < v54);
      }
    }
    else
    {
      if ((a9 & 1) == 0)
      {
        float v46 = -v46;
        float v47 = -v47;
        float v62 = v36 + 3.14159265;
        float v63 = v35 + 3.14159265;
        if (v62 >= 6.28318531)
        {
          float v64 = v62 + -6.28318531;
          float v35 = v64;
        }
        else
        {
          float v35 = v36 + 3.14159265;
        }
        if (v63 >= 6.28318531)
        {
          float v65 = v63 + -6.28318531;
          float v36 = v65;
        }
        else
        {
          float v36 = v63;
        }
      }
      float v66 = a5;
      float v67 = v36 + -6.28318531;
      if (v36 <= v35) {
        float v67 = v36;
      }
      float v68 = v67 + 0.1;
      if (v35 > v68)
      {
        float v83 = (float)((float)(a2 + a4) * 0.5) + v46;
        float v69 = (float)((float)(a3 + v66) * 0.5) + v47;
        float v70 = cosval * v80;
        float v71 = v40 * v23;
        float v72 = sinval * v80;
        float v73 = cosval * v23;
        do
        {
          float v74 = v35;
          __float2 v75 = __sincosf_stret(v68);
          Path::AddPoint(this, (float)(v83 + (float)(v70 * v75.__cosval)) + (float)(v71 * v75.__sinval), (float)(v69 + (float)(v72 * v75.__cosval)) + (float)(v73 * v75.__sinval), 0);
          float v35 = v74;
          float v68 = v68 + 0.1;
        }
        while (v74 > v68);
      }
    }
  }
}

Path *Path::RecBezierTo(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9, int a10, float a11, float a12, float a13)
{
  if (a10 >= 1)
  {
    int v13 = a10;
    float v19 = this;
    float v20 = a12;
    float v21 = a13;
    float v22 = 0.5;
    do
    {
      float v23 = (float)((float)(a5 - a2) * (float)(a9 - a3)) - (float)((float)(a6 - a3) * (float)(a8 - a2));
      float v24 = -v23;
      if (v23 >= 0.0) {
        float v24 = (float)((float)(a5 - a2) * (float)(a9 - a3)) - (float)((float)(a6 - a3) * (float)(a8 - a2));
      }
      float v29 = a4;
      if (v24 < v20
        && (v21 <= 0.0
         || sqrtf((float)((float)(a9 - a6) * (float)(a9 - a6)) + (float)((float)(a8 - a5) * (float)(a8 - a5))) <= v21))
      {
        break;
      }
      float v25 = (float)((float)(a5 + a8) + (float)(a2 * 2.0)) * 0.25;
      float v26 = (float)((float)(a6 + a9) + (float)(a3 * 2.0)) * 0.25;
      float v28 = (float)((float)(a7 + a11) + (float)(a4 * 2.0)) * 0.25;
      Path::RecBezierTo(v19, (float)(a2 + a5) * v22, (float)(a3 + a6) * v22, (float)(a4 + a7) * v22, a5, a6, a7, v25, v26, v28, v20, --v13, v21);
      this = (Path *)Path::AddPoint(v19, v25, v26, v28, 0);
      a5 = v25;
      a6 = v27;
      a7 = v28;
      float v21 = a13;
      a4 = (float)(v29 + a11) * 0.5;
      a3 = (float)(a3 + a9) * 0.5;
      a2 = (float)(a2 + a8) * 0.5;
      float v22 = 0.5;
      float v20 = a12;
    }
    while (v13 >= 1);
  }
  return this;
}

Path *Path::RecBezierTo(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8, int a9, float a10)
{
  if (a9 >= 1)
  {
    int v10 = a9;
    float v16 = this;
    float v21 = a10;
    do
    {
      float v17 = (float)((float)(a4 - a2) * (float)(a7 - a3)) - (float)((float)(a5 - a3) * (float)(a6 - a2));
      float v18 = -v17;
      if (v17 >= 0.0) {
        float v18 = (float)((float)(a4 - a2) * (float)(a7 - a3)) - (float)((float)(a5 - a3) * (float)(a6 - a2));
      }
      if (v18 < a8
        && (a10 <= 0.0
         || sqrtf((float)((float)(a7 - a5) * (float)(a7 - a5)) + (float)((float)(a6 - a4) * (float)(a6 - a4))) <= a10))
      {
        break;
      }
      float v19 = (float)((float)(a4 + a6) + (float)(a2 * 2.0)) * 0.25;
      float v20 = (float)((float)(a5 + a7) + (float)(a3 * 2.0)) * 0.25;
      Path::RecBezierTo(v16, (float)(a2 + a4) * 0.5, (float)(a3 + a5) * 0.5, a4, a5, v19, v20, a8, --v10, a10);
      this = (Path *)Path::AddPoint(v16, v19, v20, 0);
      a4 = v19;
      a5 = v20;
      a3 = (float)(a3 + a7) * 0.5;
      a2 = (float)(a2 + a6) * 0.5;
      a10 = v21;
    }
    while (v10 >= 1);
  }
  return this;
}

void Path::ConvertEvenLines(Path *this, float a2)
{
  int var0 = this->var0;
  if (this->var0)
  {
    Path::CancelBezier(this);
    int var0 = this->var0;
  }
  if ((var0 & 2) != 0) {
    Path::CloseSubpath(this, 0);
  }
  Path::SetBackData(this, 0);
  Path::ResetPoints(this, this->var2);
  if (this->var2 >= 1)
  {
    var3 = this->var3;
    float v5 = 1.0;
    if ((*(unsigned char *)var3 & 0x10) != 0) {
      float v5 = *((float *)var3 + 7);
    }
    float v7 = *((float *)var3 + 4);
    float v6 = *((float *)var3 + 5);
    float v8 = v6;
    uint64_t v9 = this->var6 ? Path::AddPoint(this, v7, v6, v5, 1) : Path::AddPoint(this, v7, v6, 1);
    float v11 = v8;
    uint64_t v12 = v9;
    *((_DWORD *)this->var3 + 1) = v9;
    if (this->var2 >= 2)
    {
      float v151 = a2 * 4.0;
      int v13 = 1;
      float v14 = 2.0;
      while (1)
      {
        float v15 = this->var3;
        float v16 = (int *)((char *)v15 + 44 * v13);
        int v17 = *v16;
        float v18 = 0.0;
        uint64_t v19 = v13;
        float v20 = 0.0;
        float v21 = 0.0;
        switch(*v16 & 0xF)
        {
          case 0:
            float v22 = (float *)((char *)v15 + 44 * v13);
            float v24 = v22[4];
            float v23 = (char *)(v22 + 4);
            float v18 = v24;
            float v21 = 1.0;
            if ((v17 & 0x10) != 0) {
              float v21 = *((float *)v23 + 3);
            }
            float v20 = *((float *)v23 + 1);
            float v25 = v11;
            if (this->var6) {
              uint64_t v26 = Path::AddPoint(this, v18, v20, v21, 1);
            }
            else {
              uint64_t v26 = Path::AddPoint(this, v18, v20, 1);
            }
            float v11 = v25;
            uint64_t v12 = v26;
            *((_DWORD *)v15 + 11 * v13 + 1) = v26;
            goto LABEL_113;
          case 1:
            float v27 = v7;
            float v28 = (float *)((char *)v15 + 44 * v13);
            float v30 = v28[4];
            float v29 = (char *)(v28 + 4);
            float v31 = v30;
            float v32 = 1.0;
            if ((v17 & 0x10) != 0) {
              float v32 = *((float *)v29 + 2);
            }
            float v33 = sqrtf((float)((float)(*((float *)v29 + 1) - v11) * (float)(*((float *)v29 + 1) - v11))+ (float)((float)(v31 - v27) * (float)(v31 - v27)));
            if (this->var6)
            {
              float v147 = v11;
              float v18 = v31;
              float v20 = *((float *)v29 + 1);
              if (v33 > v151)
              {
                float v34 = fmaxf(v151, v33 / 100.0);
                if (v34 < v33)
                {
                  float v35 = v34;
                  do
                  {
                    Path::AddPoint(this, (float)((float)(v18 * v35) + (float)((float)(v33 - v35) * v27)) / v33, (float)((float)(v20 * v35) + (float)((float)(v33 - v35) * v147)) / v33, (float)((float)(v32 * v35) + (float)((float)(v33 - v35) * v5)) / v33, 0);
                    float v35 = v34 + v35;
                  }
                  while (v35 < v33);
                }
              }
              int v36 = Path::AddPoint(this, v18, v20, v32, 0);
              float v37 = (char *)v15 + 44 * v13;
              *((_DWORD *)v37 + 1) = v36;
              float v38 = v37 + 4;
              float v14 = 2.0;
              float v21 = v32;
              float v7 = v27;
              float v11 = v147;
              if (v36 < 0)
              {
                if (v13) {
                  goto LABEL_27;
                }
LABEL_65:
                *float v38 = 0;
              }
            }
            else
            {
              float v92 = v11;
              float v93 = *((float *)v29 + 1);
              if (v33 > v151)
              {
                float v94 = fmaxf(v151, v33 / 100.0);
                if (v94 < v33)
                {
                  float v95 = v94;
                  do
                  {
                    Path::AddPoint(this, (float)((float)(v31 * v95) + (float)((float)(v33 - v95) * v27)) / v33, (float)((float)(v93 * v95) + (float)((float)(v33 - v95) * v92)) / v33, 0);
                    float v95 = v94 + v95;
                  }
                  while (v95 < v33);
                }
              }
              int v96 = Path::AddPoint(this, v31, v93, 0);
              int v97 = (char *)v15 + 44 * v13;
              *((_DWORD *)v97 + 1) = v96;
              float v38 = v97 + 4;
              float v14 = 2.0;
              float v21 = v32;
              float v7 = v27;
              float v11 = v92;
              float v18 = v31;
              float v20 = v93;
              if (v96 < 0)
              {
                if (v13)
                {
LABEL_27:
                  *float v38 = *(v16 - 10);
                  goto LABEL_113;
                }
                goto LABEL_65;
              }
            }
LABEL_113:
            ++v13;
LABEL_114:
            double v10 = vabds_f32(v7, v18);
            if (v10 > 0.00001 || (double v10 = vabds_f32(v11, v20), v10 > 0.00001))
            {
              float v7 = v18;
              float v11 = v20;
            }
            float v5 = v21;
            if (v13 >= this->var2) {
              return;
            }
            break;
          case 2:
            float v39 = (float *)((char *)v15 + 44 * v13);
            float v41 = v39[4];
            float v40 = v39 + 4;
            float v18 = v41;
            float v21 = 1.0;
            if ((v17 & 0x10) != 0) {
              float v21 = v40[6];
            }
            float v20 = v40[1];
            float v42 = v40[2];
            float v43 = v40[3];
            float v44 = v40[4];
            float v45 = v40[5];
            float v46 = (_DWORD *)((char *)v15 + 44 * v13 + 4);
            if (!this->var6)
            {
              float v70 = v11;
              Path::RecCubicTo(this, v7, v11, v42, v43, v18, v20, v44, v45, 8, a2, v151);
              goto LABEL_68;
            }
            float v47 = v11;
            Path::RecCubicTo(this, v7, v11, v5, v42, v43, v18, v20, v21, 8, v44, v45, a2, v151);
            int v48 = Path::AddPoint(this, v18, v20, v21, 0);
            float v11 = v47;
            *float v46 = v48;
            if ((v48 & 0x80000000) == 0) {
              goto LABEL_113;
            }
            if (!v13) {
              goto LABEL_33;
            }
            goto LABEL_71;
          case 3:
            float v148 = v11;
            uint64_t v146 = v12;
            float v50 = (char *)v15 + 44 * v13;
            int v53 = *((_DWORD *)v50 + 4);
            float v51 = (float *)(v50 + 16);
            int v52 = v53;
            float v21 = 1.0;
            if ((v17 & 0x10) != 0) {
              float v21 = v51[3];
            }
            float v54 = v51[1];
            float v20 = v51[2];
            uint64_t v55 = v19 + 1;
            if (v52 >= 1)
            {
              float v56 = (float *)((char *)v15 + 44 * v55);
              float v59 = v56[4];
              float v58 = v56[5];
              float v57 = (char *)(v56 + 4);
              if (v52 == 1)
              {
                float v60 = 1.0;
                if ((v17 & 0x10) != 0) {
                  float v60 = *((float *)v57 + 2);
                }
                float v61 = v54;
                if (this->var6) {
                  Path::RecBezierTo(this, v59, v58, v60, v7, v11, v5, v54, v20, 8, v21, a2, v151);
                }
                else {
                  Path::RecBezierTo(this, v59, v58, v7, v11, v54, v20, a2, 8, v151);
                }
                float v54 = v61;
              }
              else
              {
                float v143 = v21;
                float v106 = 1.0;
                if ((v17 & 0x10) != 0) {
                  float v106 = *((float *)v57 + 2);
                }
                int v107 = 0;
                float v144 = v7;
                float v145 = v54;
                float v108 = -(float)(v59 - (float)(v7 * v14));
                float v109 = -(float)(v58 - (float)(v11 * v14));
                float v110 = -(float)(v106 - (float)(v5 * v14));
                float64x2_t v111 = (float *)((char *)v15 + 44 * v55 + 68);
                float v149 = v20;
                do
                {
                  float v112 = v59;
                  float v113 = v58;
                  float v114 = v106;
                  float v115 = 1.0;
                  if ((v17 & 0x10) != 0) {
                    float v115 = *v111;
                  }
                  float v117 = *(v111 - 2);
                  float v116 = *(v111 - 1);
                  float v118 = v108 + v59;
                  float v119 = v118 * 0.5;
                  float v120 = (float)(v109 + v58) * 0.5;
                  float v121 = (float)(v110 + v114) * 0.5;
                  float v122 = v116;
                  float v123 = v117;
                  float v153 = v115;
                  if (v107)
                  {
                    int v124 = this->var6
                         ? Path::AddPoint(this, v118 * 0.5, (float)(v109 + v58) * 0.5, v121, 0)
                         : Path::AddPoint(this, v118 * 0.5, (float)(v109 + v58) * 0.5, 0);
                    *((_DWORD *)v111 - 16) = v124;
                    float v116 = v122;
                    float v117 = v123;
                    float v115 = v153;
                    if (v124 < 0)
                    {
                      if (v19 == -1) {
                        int v125 = 0;
                      }
                      else {
                        int v125 = *((_DWORD *)v111 - 27);
                      }
                      *((_DWORD *)v111 - 16) = v125;
                    }
                  }
                  float v126 = (float)(v112 + v117) * 0.5;
                  if (this->var6)
                  {
                    float v127 = v119;
                    float v128 = v120;
                    float v129 = v126;
                    float v130 = (float)(v113 + v116) * 0.5;
                    Path::RecBezierTo(this, v112, v113, v114, v127, v128, v121, v126, v130, 8, (float)(v114 + v115) * 0.5, a2, v151);
                  }
                  else
                  {
                    float v131 = v119;
                    float v132 = v120;
                    float v129 = v126;
                    float v130 = (float)(v113 + v116) * 0.5;
                    Path::RecBezierTo(this, v112, v113, v131, v132, v126, v130, a2, 8, v151);
                  }
                  float v106 = v153;
                  float v59 = v123;
                  float v58 = v122;
                  float v20 = v149;
                  ++v107;
                  v111 += 11;
                  float v110 = v114;
                  float v109 = v113;
                  float v108 = v112;
                }
                while (v52 - 1 != v107);
                if (this->var6) {
                  int v133 = Path::AddPoint(this, v129, v130, (float)(v114 + v153) * 0.5, 0);
                }
                else {
                  int v133 = Path::AddPoint(this, v129, v130, 0);
                }
                *((_DWORD *)v111 - 16) = v133;
                float v7 = v144;
                float v134 = v123;
                if (v133 < 0)
                {
                  if (v19 == -1) {
                    int v135 = 0;
                  }
                  else {
                    int v135 = *((_DWORD *)v111 - 27);
                  }
                  *((_DWORD *)v111 - 16) = v135;
                }
                float v136 = (float)(v123 - (float)(v123 - (float)(v145 * 2.0))) * 0.5;
                float v137 = (float)(v122 - (float)(v122 - (float)(v149 * 2.0))) * 0.5;
                float v14 = 2.0;
                if (this->var6)
                {
                  float v21 = v143;
                  Path::RecBezierTo(this, v134, v122, v153, v129, v130, (float)(v114 + v153) * 0.5, v136, v137, 8, (float)(v153 - (float)(v153 - (float)(v143 * 2.0))) * 0.5, a2, v151);
                }
                else
                {
                  Path::RecBezierTo(this, v134, v122, v129, v130, v136, v137, a2, 8, v151);
                  float v21 = v143;
                }
                float v54 = v145;
              }
            }
            float v18 = v54;
            if (this->var6) {
              int v138 = Path::AddPoint(this, v54, v20, v21, 0);
            }
            else {
              int v138 = Path::AddPoint(this, v54, v20, 0);
            }
            float v11 = v148;
            v139 = (char *)v15 + 44 * (int)v19;
            *((_DWORD *)v139 + 1) = v138;
            v140 = v139 + 4;
            if (v138 < 0)
            {
              if (v19 == -1) {
                int v141 = 0;
              }
              else {
                int v141 = *(v16 - 10);
              }
              _DWORD *v140 = v141;
            }
            int v13 = v52 + v55;
            uint64_t v12 = v146;
            goto LABEL_114;
          case 4:
            float v62 = (float *)((char *)v15 + 44 * v13);
            float v64 = v62[4];
            float v63 = (char *)(v62 + 4);
            float v18 = v64;
            float v21 = 1.0;
            if ((v17 & 0x10) != 0) {
              float v21 = *((float *)v63 + 6);
            }
            float v20 = *((float *)v63 + 1);
            float v65 = *((float *)v63 + 2);
            float v66 = *((float *)v63 + 3);
            float v67 = *((float *)v63 + 4);
            float v46 = (_DWORD *)((char *)v15 + 44 * v13 + 4);
            BOOL v68 = v63[21] != 0;
            BOOL v69 = v63[20] != 0;
            if (this->var6)
            {
              float v70 = v11;
              Path::DoArc(this, v7, v11, v5, v18, v20, v21, v65, v66, v69, v68, v67, v142);
              int v71 = Path::AddPoint(this, v18, v20, v21, 0);
            }
            else
            {
              float v70 = v11;
              Path::DoArc(this, v7, v11, v18, v20, v65, v66, v67, v69, v68, v66);
LABEL_68:
              int v71 = Path::AddPoint(this, v18, v20, 0);
            }
            float v11 = v70;
            *float v46 = v71;
            if ((v71 & 0x80000000) == 0) {
              goto LABEL_113;
            }
            if (v13) {
LABEL_71:
            }
              int v49 = *(v16 - 10);
            else {
LABEL_33:
            }
              int v49 = 0;
            *float v46 = v49;
            goto LABEL_113;
          case 5:
            var11 = this->var11;
            if (!this->var6)
            {
              uint64_t v98 = &var11[12 * (int)v12];
              float v99 = *((float *)v98 + 1);
              float v20 = *((float *)v98 + 2);
              float v100 = sqrtf((float)((float)(v20 - v11) * (float)(v20 - v11)) + (float)((float)(v99 - v7)
                                                                                    * (float)(v99 - v7)));
              float v86 = v11;
              float v18 = v99;
              if (v100 > v151)
              {
                float v101 = fmaxf(v151, v100 / 100.0);
                if (v101 < v100)
                {
                  float v102 = v101;
                  do
                  {
                    Path::AddPoint(this, (float)((float)(v99 * v102) + (float)((float)(v100 - v102) * v7)) / v100, (float)((float)(v20 * v102) + (float)((float)(v100 - v102) * v86)) / v100, 0);
                    float v99 = v18;
                    float v102 = v101 + v102;
                  }
                  while (v102 < v100);
                }
              }
              int v103 = Path::AddPoint(this, v99, v20, 0);
              float v104 = (char *)v15 + 44 * v13;
              *((_DWORD *)v104 + 1) = v103;
              float v105 = v104 + 4;
              float v21 = 0.0;
              if (v103 < 0)
              {
                if (v13) {
                  *float v105 = *(v16 - 10);
                }
                else {
                  *float v105 = 0;
                }
              }
LABEL_112:
              float v14 = 2.0;
              float v11 = v86;
              goto LABEL_113;
            }
            float v73 = (float *)&var11[16 * (int)v12];
            float v74 = v73[1];
            float v20 = v73[2];
            float v75 = v11;
            float v76 = v7;
            float v77 = v73[3];
            float v78 = sqrtf((float)((float)(v20 - v11) * (float)(v20 - v11)) + (float)((float)(v74 - v7) * (float)(v74 - v7)));
            if (v78 > v151)
            {
              float v152 = fmaxf(v151, v78 / 100.0);
              if (v152 < v78)
              {
                float v79 = v5;
                float v80 = v152;
                do
                {
                  float v81 = (float)((float)(v20 * v80) + (float)((float)(v78 - v80) * v75)) / v78;
                  float v82 = v20;
                  float v83 = v77;
                  float v84 = v76;
                  float v85 = v79;
                  Path::AddPoint(this, (float)((float)(v74 * v80) + (float)((float)(v78 - v80) * v76)) / v78, v81, (float)((float)(v77 * v80) + (float)((float)(v78 - v80) * v79)) / v78, 0);
                  float v76 = v84;
                  float v79 = v85;
                  float v77 = v83;
                  float v20 = v82;
                  float v80 = v152 + v80;
                }
                while (v80 < v78);
              }
            }
            float v86 = v75;
            float v7 = v76;
            float v18 = v74;
            float v21 = v77;
            int v87 = Path::AddPoint(this, v74, v20, v77, 0);
            float v88 = (char *)v15 + 44 * v13;
            *((_DWORD *)v88 + 1) = v87;
            float v89 = v88 + 4;
            if ((v87 & 0x80000000) == 0) {
              goto LABEL_112;
            }
            if (v13) {
              *float v89 = *(v16 - 10);
            }
            else {
              *float v89 = 0;
            }
            float v11 = v86;
            float v14 = 2.0;
            goto LABEL_113;
          case 6:
            goto LABEL_114;
          case 7:
            if (this->var6)
            {
              float v90 = v11;
              Path::AddForcedPoint(this, v7, v11, v5);
            }
            else
            {
              *(float *)&double v10 = v7;
              float v90 = v11;
              Path::AddForcedPoint(this, v10, v11);
            }
            float v11 = v90;
            *((_DWORD *)v15 + 11 * v13++ + 1) = v91;
            goto LABEL_82;
          default:
            float v20 = 0.0;
LABEL_82:
            float v21 = 0.0;
            goto LABEL_114;
        }
      }
    }
  }
}

float Path::PrevPoint(Path *this, unsigned int a2, float *a3, float *a4)
{
  if ((a2 & 0x80000000) == 0)
  {
    uint64_t v4 = (float *)((char *)this->var3 + 44 * a2 + 24);
    uint64_t v5 = a2 + 1;
    while ((*(_DWORD *)(v4 - 6) & 0xFu) - 5 < 3)
    {
      v4 -= 11;
      if (--v5 < 1) {
        return result;
      }
    }
    switch(*(_DWORD *)(v4 - 6) & 0xF)
    {
      case 0:
      case 1:
      case 2:
      case 4:
        *a3 = *(v4 - 2);
        --v4;
        goto LABEL_10;
      case 3:
        *a3 = *(v4 - 1);
LABEL_10:
        float result = *v4;
        *a4 = *v4;
        break;
      default:
        return result;
    }
  }
  return result;
}

float Path::QuadraticPoint(Path *this, float a2, float *a3, float *a4, float a5, float a6, float a7, float a8, float a9, float a10)
{
  *(float *)&this->int var0 = (float)((float)((float)((float)(a5 * -2.0) + (float)(a7 * 2.0)) * a2)
                                + (float)((float)((float)((float)(a9 + (float)(a7 * -2.0)) + a5) * a2) * a2))
                        + a5;
  float result = (float)((float)((float)((float)(a6 * -2.0) + (float)(a8 * 2.0)) * a2)
                 + (float)((float)((float)((float)(a10 + (float)(a8 * -2.0)) + a6) * a2) * a2))
         + a6;
  *a3 = result;
  return result;
}

float Path::CubicTangent(Path *this, float a2, float *a3, float *a4, float a5, float a6, float a7, float a8, float a9, float a10, float a11, float a12)
{
  float v12 = (float)((float)(a11 + (float)(a9 * -2.0)) + (float)(a5 * 2.0)) + a7;
  float v13 = (float)((float)(a7 * -2.0) - (float)(a11 - (float)(a9 * 3.0))) + (float)(a5 * -3.0);
  float v14 = (float)((float)(a12 + (float)(a10 * -2.0)) + (float)(a6 * 2.0)) + a8;
  float v15 = (float)((float)(a8 * -2.0) - (float)(a12 - (float)(a10 * 3.0))) + (float)(a6 * -3.0);
  *(float *)&this->int var0 = (float)((float)((float)(v13 + v13) * a2) + (float)((float)((float)(v12 * 3.0) * a2) * a2))
                        + a7;
  float result = (float)((float)((float)(v15 + v15) * a2) + (float)((float)((float)(v14 * 3.0) * a2) * a2)) + a8;
  *a3 = result;
  return result;
}

void Path::ArcAngles(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8, int a9, float *a10, float *a11, float *a12)
{
  int v15 = (int)this;
  float v18 = a4 - a2;
  float v19 = a5 - a3;
  __float2 v20 = __sincosf_stret(a8);
  float v21 = (float)((float)(v19 * v20.__sinval) + (float)(v20.__cosval * v18)) / a6;
  float v22 = (float)((float)(v19 * v20.__cosval) - (float)(v20.__sinval * v18)) / a7;
  float v23 = (float)(v22 * v22) + (float)(v21 * v21);
  float v24 = (float)(v23 * -0.25) + 1.0;
  float v25 = 0.0;
  if (v24 < 0.0) {
    float v24 = 0.0;
  }
  float v26 = sqrtf(v24);
  float v27 = sqrtf(v23);
  float v28 = (float)-v21 / v27;
  float v29 = (float)(v22 / v27) * v26;
  float v30 = v21 * 0.5;
  float v31 = (float)-v29 - (float)(v21 * 0.5);
  float v32 = v22 * 0.5;
  if (v31 >= -1.0)
  {
    if (v31 <= 1.0)
    {
      float v33 = acosf(v31);
      *a10 = v33;
      if ((float)((float)-(float)(v28 * v26) - v32) >= 0.0) {
        goto LABEL_9;
      }
      float v25 = 6.28318531 - v33;
    }
  }
  else
  {
    float v25 = 3.1416;
  }
  *a10 = v25;
LABEL_9:
  if ((float)(v30 - v29) >= -1.0)
  {
    float v34 = 0.0;
    if ((float)(v30 - v29) <= 1.0)
    {
      float v34 = acosf(v30 - v29);
      *a11 = v34;
      if ((float)(v32 - (float)(v28 * v26)) >= 0.0) {
        goto LABEL_15;
      }
      float v34 = 6.28318531 - v34;
    }
  }
  else
  {
    float v34 = 3.1416;
  }
  *a11 = v34;
LABEL_15:
  if (a9)
  {
    if (!v15) {
      return;
    }
  }
  else if (v15)
  {
    return;
  }
  *a11 = *a10;
  *a10 = v34;
  float v35 = *a11 + 3.14159265;
  *a11 = v35;
  float v36 = *a10 + 3.14159265;
  *a10 = v36;
  double v37 = *a11;
  if (v37 >= 6.28318531)
  {
    float v38 = v37 + -6.28318531;
    *a11 = v38;
    float v36 = *a10;
  }
  double v39 = v36;
  if (v39 >= 6.28318531)
  {
    float v40 = v39 + -6.28318531;
    *a10 = v40;
  }
}

void Path::Fill(Path *this, void **a2, int a3, char a4, int a5, char a6)
{
  if (!a2) {
    return;
  }
  if ((a4 & 1) == 0) {
    Shape::Reset(a2, this->var8);
  }
  if (this->var8 < 2) {
    return;
  }
  int v11 = *((_DWORD *)a2 + 4);
  if (this->var7) {
    Shape::MakeBackData((Shape *)a2, 1);
  }
  if (a6) {
    return;
  }
  int var8 = this->var8;
  int v91 = a5;
  if (!this->var7)
  {
    if (this->var6)
    {
      if (var8 >= 1)
      {
        uint64_t v33 = 0;
        uint64_t v34 = 0;
        do
        {
          Shape::AddPoint((Shape *)a2, *(float *)&this->var11[v33 + 4], *(float *)&this->var11[v33 + 8]);
          ++v34;
          uint64_t v35 = this->var8;
          v33 += 16;
        }
        while (v34 < v35);
        if ((int)v35 >= 2)
        {
          uint64_t v36 = 0;
          BOOL v37 = 0;
          int v38 = 0;
          int v39 = 0;
          int v40 = -1;
          uint64_t v41 = 1;
          while (1)
          {
            var11 = this->var11;
            float v43 = &var11[v36];
            if (*(_DWORD *)&var11[v36 + 16] == 1)
            {
              if (v91)
              {
                unsigned int v44 = v39 + v11;
                if (v37 && v40 >= 0)
                {
                  Shape::DisconnectEnd((uint64_t)a2, v40);
                  Shape::ConnectEnd((uint64_t)a2, v44, v40);
                }
                else
                {
                  Shape::AddEdge((Shape *)a2, v38 + v11, v44);
                }
              }
              BOOL v37 = 0;
              int v40 = -1;
              int v39 = v41;
            }
            else
            {
              float v45 = &var11[16 * v38];
              if (vabds_f32(*((float *)v43 + 5), *((float *)v45 + 1)) < 0.00001
                && vabds_f32(*(float *)&var11[v36 + 24], *((float *)v45 + 2)) < 0.00001)
              {
                goto LABEL_58;
              }
              float v46 = &var11[16 * v39];
              int v40 = Shape::AddEdge((Shape *)a2, v38 + v11, v11 + (int)v41);
              BOOL v37 = vabds_f32(*((float *)v43 + 5), *((float *)v46 + 1)) < 0.00001
                 && vabds_f32(*(float *)&var11[v36 + 24], *((float *)v46 + 2)) < 0.00001;
            }
            int v38 = v41;
LABEL_58:
            ++v41;
            v36 += 16;
            if (v41 >= this->var8) {
              goto LABEL_93;
            }
          }
        }
      }
      int v39 = 0;
      int v38 = 0;
      BOOL v37 = 0;
      int v40 = -1;
LABEL_93:
      if (!v91) {
        return;
      }
      unsigned int v72 = v39 + v11;
      if (!v37 || v40 < 0)
      {
        unsigned int v73 = v38 + v11;
LABEL_131:
        Shape::AddEdge((Shape *)a2, v73, v72);
        return;
      }
      goto LABEL_123;
    }
    if (var8 < 1) {
      goto LABEL_120;
    }
    uint64_t v77 = 0;
    uint64_t v78 = 0;
    do
    {
      Shape::AddPoint((Shape *)a2, *(float *)&this->var11[v77 + 4], *(float *)&this->var11[v77 + 8]);
      ++v78;
      uint64_t v79 = this->var8;
      v77 += 12;
    }
    while (v78 < v79);
    if ((int)v79 < 2)
    {
LABEL_120:
      int v83 = 0;
      int v82 = 0;
      BOOL v81 = 0;
      int v40 = -1;
LABEL_121:
      if (!v91) {
        return;
      }
      unsigned int v72 = v83 + v11;
      if (!v81 || v40 < 0)
      {
        unsigned int v73 = v82 + v11;
        goto LABEL_131;
      }
LABEL_123:
      Shape::DisconnectEnd((uint64_t)a2, v40);
      float v75 = (Shape *)a2;
      int v74 = v72;
      int v76 = v40;
      goto LABEL_124;
    }
    uint64_t v80 = 0;
    BOOL v81 = 0;
    int v82 = 0;
    int v83 = 0;
    int v40 = -1;
    uint64_t v84 = 1;
    while (1)
    {
      float v85 = this->var11;
      float v86 = &v85[v80];
      if (*(_DWORD *)&v85[v80 + 12] == 1)
      {
        if (v91)
        {
          unsigned int v87 = v83 + v11;
          if (v81 && v40 >= 0)
          {
            Shape::DisconnectEnd((uint64_t)a2, v40);
            Shape::ConnectEnd((uint64_t)a2, v87, v40);
          }
          else
          {
            Shape::AddEdge((Shape *)a2, v82 + v11, v87);
          }
        }
        BOOL v81 = 0;
        int v40 = -1;
        int v83 = v84;
      }
      else
      {
        if (vabds_f32(*((float *)v86 + 4), *(float *)&v85[12 * v82 + 4]) < 0.00001
          && vabds_f32(*(float *)&v85[v80 + 20], *(float *)&v85[12 * v82 + 8]) < 0.00001)
        {
          goto LABEL_118;
        }
        int v40 = Shape::AddEdge((Shape *)a2, v82 + v11, v11 + (int)v84);
        BOOL v81 = vabds_f32(*((float *)v86 + 4), *(float *)&v85[12 * v83 + 4]) < 0.00001
           && vabds_f32(*(float *)&v85[v80 + 20], *(float *)&v85[12 * v83 + 8]) < 0.00001;
      }
      int v82 = v84;
LABEL_118:
      ++v84;
      v80 += 12;
      if (v84 >= this->var8) {
        goto LABEL_121;
      }
    }
  }
  int v90 = a3;
  if (this->var6)
  {
    if (var8 >= 1)
    {
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      do
      {
        Shape::AddPoint((Shape *)a2, *(float *)&this->var11[v13 + 4], *(float *)&this->var11[v13 + 8]);
        ++v14;
        uint64_t v15 = this->var8;
        v13 += 24;
      }
      while (v14 < v15);
      if ((int)v15 >= 2)
      {
        uint64_t v16 = 0;
        BOOL v17 = 0;
        int v18 = 0;
        int v19 = 0;
        int v20 = -1;
        uint64_t v21 = 1;
        while (1)
        {
          float v22 = this->var11;
          float v23 = &v22[v16];
          if (*(_DWORD *)&v22[v16 + 24] != 1) {
            break;
          }
          if ((v91 & 1) == 0)
          {
            BOOL v17 = 0;
            goto LABEL_26;
          }
          if (v17 && v20 >= 0)
          {
            Shape::DisconnectEnd((uint64_t)a2, v20);
            Shape::ConnectEnd((uint64_t)a2, v19 + v11, v20);
          }
          else
          {
            Shape::AddEdge((Shape *)a2, v18 + v11, v19 + v11);
            if ((v20 & 0x80000000) == 0)
            {
              BOOL v17 = 0;
              uint64_t v31 = (uint64_t)a2[12] + 16 * v20;
              int v32 = *(_DWORD *)&v22[24 * v19 + 16];
              *(_DWORD *)uint64_t v31 = v90;
              *(_DWORD *)(v31 + 4) = v32;
              *(void *)(v31 + 8) = 0x3F80000000000000;
LABEL_26:
              int v20 = -1;
              int v19 = v21;
LABEL_35:
              int v18 = v21;
              goto LABEL_36;
            }
          }
          BOOL v17 = 0;
          int v20 = -1;
          int v19 = v21;
          int v18 = v21;
LABEL_36:
          ++v21;
          v16 += 24;
          if (v21 >= this->var8) {
            goto LABEL_61;
          }
        }
        float v24 = &v22[24 * v18];
        if (vabds_f32(*((float *)v23 + 7), *((float *)v24 + 1)) < 0.00001
          && vabds_f32(*(float *)&v22[v16 + 32], *((float *)v24 + 2)) < 0.00001)
        {
          goto LABEL_36;
        }
        unsigned int v25 = Shape::AddEdge((Shape *)a2, v18 + v11, v11 + (int)v21);
        int v20 = v25;
        if ((v25 & 0x80000000) == 0)
        {
          float v26 = a2[12];
          float v27 = &v26[4 * v25];
          int v28 = *(_DWORD *)&v22[v16 + 40];
          *float v27 = v90;
          v27[1] = v28;
          if (v28 == *(_DWORD *)&v22[24 * v18 + 16])
          {
            v26[4 * v25 + 2] = *(_DWORD *)&v22[24 * v18 + 20];
            float v29 = *(float *)&v22[v16 + 44];
          }
          else
          {
            v26[4 * v25 + 2] = 0;
            float v29 = 1.0;
          }
          *(float *)&v26[4 * v25 + 3] = v29;
        }
        float v30 = &v22[24 * v19];
        BOOL v17 = vabds_f32(*((float *)v23 + 7), *((float *)v30 + 1)) < 0.00001
           && vabds_f32(*(float *)&v22[v16 + 32], *((float *)v30 + 2)) < 0.00001;
        goto LABEL_35;
      }
    }
    int v19 = 0;
    int v18 = 0;
    BOOL v17 = 0;
    int v20 = -1;
LABEL_61:
    int v47 = v90;
    if (v91)
    {
      if (!v17 || v20 < 0)
      {
        int v48 = this->var11;
        unsigned int v49 = Shape::AddEdge((Shape *)a2, v18 + v11, v19 + v11);
        if ((v49 & 0x80000000) != 0) {
          return;
        }
        uint64_t v50 = (uint64_t)a2[12] + 16 * v49;
        int v51 = *(_DWORD *)&v48[24 * v19 + 16];
        goto LABEL_129;
      }
LABEL_99:
      Shape::DisconnectEnd((uint64_t)a2, v20);
      int v74 = v19 + v11;
      float v75 = (Shape *)a2;
      int v76 = v20;
LABEL_124:
      Shape::ConnectEnd((uint64_t)v75, v74, v76);
      return;
    }
    return;
  }
  if (var8 >= 1)
  {
    uint64_t v52 = 0;
    uint64_t v53 = 0;
    do
    {
      Shape::AddPoint((Shape *)a2, *(float *)&this->var11[v52 + 4], *(float *)&this->var11[v52 + 8]);
      ++v53;
      uint64_t v54 = this->var8;
      v52 += 20;
    }
    while (v53 < v54);
    if ((int)v54 >= 2)
    {
      uint64_t v55 = 0;
      BOOL v56 = 0;
      int v57 = 0;
      int v19 = 0;
      int v20 = -1;
      uint64_t v58 = 1;
      while (1)
      {
        float v59 = this->var11;
        float v60 = &v59[v55];
        if (*(_DWORD *)&v59[v55 + 20] != 1)
        {
          float v61 = &v59[20 * v57];
          if (vabds_f32(*((float *)v60 + 6), *((float *)v61 + 1)) < 0.00001
            && vabds_f32(*(float *)&v59[v55 + 28], *((float *)v61 + 2)) < 0.00001)
          {
            goto LABEL_87;
          }
          unsigned int v62 = Shape::AddEdge((Shape *)a2, v57 + v11, v11 + (int)v58);
          int v20 = v62;
          if ((v62 & 0x80000000) == 0)
          {
            float v63 = (char *)a2[12];
            float v64 = &v63[16 * v62];
            int v65 = *(_DWORD *)&v59[v55 + 32];
            *(_DWORD *)float v64 = v90;
            *((_DWORD *)v64 + 1) = v65;
            int v66 = 0;
            if (v65 == *(_DWORD *)&v59[20 * v57 + 12]) {
              int v66 = *(_DWORD *)&v59[20 * v57 + 16];
            }
            int v67 = *(_DWORD *)&v59[v55 + 36];
            BOOL v68 = &v63[16 * v62];
            *((_DWORD *)v68 + 2) = v66;
            *((_DWORD *)v68 + 3) = v67;
          }
          BOOL v69 = &v59[20 * v19];
          BOOL v56 = vabds_f32(*((float *)v60 + 6), *((float *)v69 + 1)) < 0.00001
             && vabds_f32(*(float *)&v59[v55 + 28], *((float *)v69 + 2)) < 0.00001;
          goto LABEL_86;
        }
        if (v91)
        {
          if (!v56 || v20 < 0)
          {
            Shape::AddEdge((Shape *)a2, v57 + v11, v19 + v11);
            BOOL v56 = 0;
            if (v20 < 0)
            {
              int v20 = -1;
              int v19 = v58;
              int v57 = v58;
              goto LABEL_87;
            }
            uint64_t v70 = (uint64_t)a2[12] + 16 * v20;
            int v71 = *(_DWORD *)&v59[20 * v19 + 12];
            *(_DWORD *)uint64_t v70 = v90;
            *(_DWORD *)(v70 + 4) = v71;
            *(void *)(v70 + 8) = 0x3F80000000000000;
            goto LABEL_75;
          }
          Shape::DisconnectEnd((uint64_t)a2, v20);
          Shape::ConnectEnd((uint64_t)a2, v19 + v11, v20);
        }
        BOOL v56 = 0;
LABEL_75:
        int v20 = -1;
        int v19 = v58;
LABEL_86:
        int v57 = v58;
LABEL_87:
        ++v58;
        v55 += 20;
        if (v58 >= this->var8) {
          goto LABEL_97;
        }
      }
    }
  }
  int v19 = 0;
  int v57 = 0;
  BOOL v56 = 0;
  int v20 = -1;
LABEL_97:
  int v47 = v90;
  if (v91)
  {
    if (!v56 || v20 < 0)
    {
      float v88 = this->var11;
      unsigned int v89 = Shape::AddEdge((Shape *)a2, v57 + v11, v19 + v11);
      if ((v89 & 0x80000000) != 0) {
        return;
      }
      uint64_t v50 = (uint64_t)a2[12] + 16 * v89;
      int v51 = *(_DWORD *)&v88[20 * v19 + 12];
LABEL_129:
      *(_DWORD *)uint64_t v50 = v47;
      *(_DWORD *)(v50 + 4) = v51;
      *(void *)(v50 + 8) = 0x3F80000000000000;
      return;
    }
    goto LABEL_99;
  }
}

uint64_t directionForVector(CGPoint a1)
{
  CGFloat x = a1.x;
  if (a1.x == 0.0 && a1.y == -1.0) {
    return 0;
  }
  CGFloat y = a1.y;
  if (a1.x == 1.0 && a1.y == -1.0) {
    return 1;
  }
  if (a1.x == 1.0 && a1.y == 0.0) {
    return 2;
  }
  if (a1.x == 1.0 && a1.y == 1.0) {
    return 3;
  }
  if (a1.x == 0.0 && a1.y == 1.0) {
    return 4;
  }
  if (a1.x == -1.0 && a1.y == 1.0) {
    return 5;
  }
  if (a1.x == -1.0 && a1.y == 0.0) {
    return 6;
  }
  if (a1.x == -1.0 && a1.y == -1.0) {
    return 7;
  }
  float v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
  uint64_t v7 = [NSString stringWithUTF8String:"TSDDirection directionForVector(CGPoint)"];
  [v6 handleFailureInFunction:v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDImageTracer.mm"), 81, @"can't find direction for invalid vector (%f, %f)", *(void *)&x, *(void *)&y file lineNumber description];
  return 8;
}

__n128 nextPivotAndBlackVectors(CGPoint a1, CGPoint a2, CGPoint *a3, CGPoint *a4)
{
  double v4 = a2.x - a1.x;
  double v5 = a2.y - a1.y;
  if (v4 == -0.5 && v5 == -0.5)
  {
LABEL_24:
    __n128 result = (__n128)*v14;
    *a4 = (CGPoint)*v14;
    return result;
  }
  if (v4 == 0.5 && v5 == -0.5)
  {
    goto LABEL_24;
  }
  if (v4 == 0.5 && v5 == 0.5)
  {
    goto LABEL_24;
  }
  if (v4 == -0.5 && v5 == 0.5)
  {
    goto LABEL_24;
  }
  double v10 = objc_msgSend(MEMORY[0x263F7C7F0], "currentHandler", v5);
  uint64_t v11 = objc_msgSend(NSString, "stringWithUTF8String:", "void nextPivotAndBlackVectors(CGPoint, CGPoint, CGPoint &, CGPoint &)");
  uint64_t v12 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDImageTracer.mm"];

  [v10 handleFailureInFunction:v11 file:v12 lineNumber:124 description:@"unexpected pivot and black points while tracing"];
  return result;
}

void buildSimplifiedPathFromPoints(void *a1, long long **a2, double a3)
{
  float v6 = *a2;
  double v5 = a2[1];
  unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * (((char *)v5 - (char *)*a2) >> 3);
  if (v7 > 0x31) {
    goto LABEL_12;
  }
  double v8 = *(double *)(MEMORY[0x263F001A0] + 16);
  double v9 = *(double *)(MEMORY[0x263F001A0] + 24);
  if (v5 != v6)
  {
    double v10 = *MEMORY[0x263F001A0];
    CGFloat v11 = *(double *)(MEMORY[0x263F001A0] + 8);
    if (v7 <= 1) {
      unint64_t v12 = 1;
    }
    else {
      unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * (((char *)v5 - (char *)v6) >> 3);
    }
    uint64_t v13 = (CGFloat *)v6 + 1;
    do
    {
      double v10 = TSDGrowRectToPoint(v10, v11, v8, v9, *(v13 - 1), *v13);
      v13 += 3;
      --v12;
    }
    while (v12);
  }
  if (v8 >= 5.0 && v9 >= 5.0)
  {
LABEL_12:
    unsigned int v62 = 0;
    uint64_t v15 = (double *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>((uint64_t)&v62, 1uLL);
    int v57 = a1;
    long long v17 = *v6;
    v15[2] = *((double *)v6 + 2);
    *(_OWORD *)uint64_t v15 = v17;
    int v18 = v15 + 3;
    __p = v15;
    unsigned int v62 = (char *)&v15[3 * v16];
    float v61 = v15 + 3;
    if (v7 != 1)
    {
      unint64_t v19 = 0;
      do
      {
        float v59 = (char *)v18;
        unint64_t v20 = v19;
        unint64_t v21 = v19 + 1;
        float v22 = *a2;
        if (v19 + 1 < v7)
        {
          float v23 = (double *)v22 + 3 * v19;
          double v24 = *v23;
          double v25 = v23[1];
          float v26 = v23 + 4;
          unint64_t v27 = v19 + 1;
          do
          {
            unint64_t v19 = v27++;
            if (v20 >= v19)
            {
              BOOL v37 = 1;
            }
            else
            {
              int v28 = (double *)v22 + 3 * v27;
              double v30 = *v28;
              double v29 = v28[1];
              double v31 = *v28 - v24;
              int v32 = v26;
              unint64_t v33 = v21;
              do
              {
                double v34 = (v29 - v25) * (*(v32 - 1) - v24);
                double v35 = v31 * (*v32 - v25);
                if (v34 == v35)
                {
                  BOOL v37 = 1;
                }
                else
                {
                  float v36 = vabdd_f64(v34, v35) / TSDDistance(v30, v29, v24, v25);
                  BOOL v37 = v36 <= a3;
                }
                if (v33 >= v19) {
                  break;
                }
                ++v33;
                v32 += 3;
              }
              while (v37);
            }
          }
          while (v27 < v7 && v37);
        }
        int v38 = (long long *)((char *)v22 + 24 * v19);
        if (v59 >= v62)
        {
          unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((v59 - (char *)__p) >> 3) + 1;
          if (v40 > 0xAAAAAAAAAAAAAAALL) {
            abort();
          }
          if (0x5555555555555556 * ((v62 - (char *)__p) >> 3) > v40) {
            unint64_t v40 = 0x5555555555555556 * ((v62 - (char *)__p) >> 3);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((v62 - (char *)__p) >> 3) >= 0x555555555555555) {
            unint64_t v41 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v41 = v40;
          }
          if (v41) {
            float v42 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>((uint64_t)&v62, v41);
          }
          else {
            float v42 = 0;
          }
          float v43 = &v42[8 * ((v59 - (char *)__p) >> 3)];
          long long v44 = *v38;
          *((void *)v43 + 2) = *((void *)v38 + 2);
          *(_OWORD *)float v43 = v44;
          float v45 = v61;
          float v46 = (double *)v43;
          if (v61 != __p)
          {
            do
            {
              long long v47 = *(_OWORD *)(v45 - 3);
              *(v46 - 1) = *(v45 - 1);
              *(_OWORD *)(v46 - 3) = v47;
              v46 -= 3;
              v45 -= 3;
            }
            while (v45 != __p);
            float v45 = __p;
          }
          int v18 = (double *)(v43 + 24);
          __p = v46;
          unsigned int v62 = &v42[24 * v41];
          if (v45) {
            operator delete(v45);
          }
        }
        else
        {
          long long v39 = *v38;
          *((void *)v59 + 2) = *((void *)v38 + 2);
          *(_OWORD *)float v59 = v39;
          int v18 = (double *)(v59 + 24);
        }
        float v61 = v18;
      }
      while (v19 < v7 - 1);
    }
    int v48 = __p;
    uint64_t v49 = (char *)v18 - (char *)__p;
    unint64_t v50 = 0xAAAAAAAAAAAAAAABLL * (v18 - __p);
    if (v50 >= 3)
    {
      double v51 = *__p;
      double v52 = __p[1];
      if (v49 == 72 && v51 == __p[6] && v52 == __p[7])
      {
LABEL_54:
        operator delete(v48);
        return;
      }
      uint64_t v54 = v57;
      objc_msgSend(v57, "moveToPoint:", v51, v52, v57);
      uint64_t v55 = 0;
      unint64_t v56 = v50 - 1;
      do
      {
        objc_msgSend(v54, "lineToPoint:", __p[v55 + 3], __p[v55 + 4]);
        v55 += 3;
        --v56;
      }
      while (v56);
      [v54 closePath];
      int v48 = __p;
    }
    if (!v48) {
      return;
    }
    goto LABEL_54;
  }
}

void sub_22361ABCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_22361B254(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,uint64_t a30,char a31,void *a32)
{
  if (__p) {
    operator delete(__p);
  }
  std::__tree<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::__map_value_compare<std::pair<unsigned short,EQKit::Config::Operator::Form>,std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::less<std::pair<unsigned short,EQKit::Config::Operator::Form>>,true>,std::allocator<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>>>::destroy((uint64_t)&a31, a32);
  _Unwind_Resume(a1);
}

void sub_22361B898(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,uint64_t a22,char a23,void *a24)
{
  if (__p) {
    operator delete(__p);
  }
  std::__tree<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::__map_value_compare<std::pair<unsigned short,EQKit::Config::Operator::Form>,std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::less<std::pair<unsigned short,EQKit::Config::Operator::Form>>,true>,std::allocator<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>>>::destroy((uint64_t)&a23, a24);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<CGPoint>::__emplace_unique_key_args<CGPoint,CGPoint>(uint64_t **a1, double *a2, _OWORD *a3)
{
  double v5 = (void **)std::__tree<CGPoint>::__find_equal<CGPoint>((uint64_t)a1, &v9, a2);
  float v6 = (uint64_t *)*v5;
  if (!*v5)
  {
    unint64_t v7 = (uint64_t **)v5;
    float v6 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v6 + 2) = *a3;
    std::__tree<std::__value_type<std::string,unsigned short>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned short>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned short>>>::__insert_node_at(a1, v9, v7, v6);
  }
  return v6;
}

void *std::__tree<CGPoint>::__find_equal<CGPoint>(uint64_t a1, void *a2, double *a3)
{
  double v5 = *(uint64_t **)(a1 + 8);
  __n128 result = (void *)(a1 + 8);
  double v4 = v5;
  if (v5)
  {
    double v7 = *a3;
    double v6 = a3[1];
    while (1)
    {
      while (1)
      {
        double v8 = v4;
        double v9 = *((double *)v4 + 5);
        if (v6 >= v9) {
          break;
        }
LABEL_6:
        double v4 = (uint64_t *)*v4;
        __n128 result = v8;
        if (!*v8) {
          goto LABEL_18;
        }
      }
      if (v6 == v9)
      {
        double v10 = *((double *)v4 + 4);
        if (v7 < v10) {
          goto LABEL_6;
        }
        if (v9 >= v6 && v10 >= v7) {
          goto LABEL_18;
        }
      }
      else if (v9 >= v6)
      {
        goto LABEL_18;
      }
      __n128 result = v4 + 1;
      double v4 = (uint64_t *)v4[1];
      if (!v4) {
        goto LABEL_18;
      }
    }
  }
  double v8 = result;
LABEL_18:
  *a2 = v8;
  return result;
}

uint64_t std::__tree<CGPoint>::__erase_unique<CGPoint>(uint64_t **a1, double *a2)
{
  uint64_t v3 = (uint64_t *)std::__tree<CGPoint>::find<CGPoint>((uint64_t)a1, a2);
  if (a1 + 1 == (uint64_t **)v3) {
    return 0;
  }
  double v4 = v3;
  std::__tree<std::__value_type<unsigned short,EQKit::Config::Operator::Form>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,EQKit::Config::Operator::Form>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,EQKit::Config::Operator::Form>>>::__remove_node_pointer(a1, v3);
  operator delete(v4);
  return 1;
}

double *std::__tree<CGPoint>::find<CGPoint>(uint64_t a1, double *a2)
{
  double v4 = *(double **)(a1 + 8);
  BOOL v2 = (double *)(a1 + 8);
  uint64_t v3 = v4;
  if (!v4) {
    return v2;
  }
  double v5 = *a2;
  double v6 = a2[1];
  double v7 = v2;
  do
  {
    double v8 = v3[5];
    if (v8 >= v6)
    {
      if (v8 == v6)
      {
        if (v3[4] < v5) {
          ++v3;
        }
        else {
          double v7 = v3;
        }
      }
      else
      {
        double v7 = v3;
      }
    }
    else
    {
      ++v3;
    }
    uint64_t v3 = *(double **)v3;
  }
  while (v3);
  if (v7 == v2) {
    return v2;
  }
  double v9 = v7[5];
  if (v6 < v9 || v6 == v9 && v5 < v7[4]) {
    return v2;
  }
  return v7;
}

BOOL TSDMetalPixelFormatIsWideGamut(uint64_t a1)
{
  return a1 == 115 || a1 == 552;
}

uint64_t TSDMetalBytesPerRowFromPixelFormatAndWidth(uint64_t a1, uint64_t a2)
{
  BOOL v2 = a1 == 552 || a1 == 115;
  char v3 = 2;
  if (v2) {
    char v3 = 3;
  }
  return a2 << v3;
}

double TSDUnpackPackedFloat16FromUint64(int a1)
{
  return *(float *)&a1;
}

float32x2_t TSDMetalColor4fWithUIntAndFormat(unint64_t a1, uint64_t a2)
{
  if (a2 == 552)
  {
    return vcvt_f32_f64(vmlaq_f64((float64x2_t)vdupq_n_s64(0xBFE81817B95A2941), (float64x2_t)vdupq_n_s64(0x3F600811FE510404uLL), vcvtq_f64_u64((uint64x2_t)vandq_s8((int8x16_t)vshlq_u64((uint64x2_t)vdupq_n_s64(a1), (uint64x2_t)xmmword_223839D20), (int8x16_t)vdupq_n_s64(0x3FFuLL)))));
  }
  else
  {
    result.i32[0] = (unsigned __int16)a1;
    if (a2 != 115) {
      result.f32[0] = 0.0;
    }
  }
  return result;
}

double TSDMetalColor4fWithUIntAndFormatOnlyAlpha(uint64_t a1, uint64_t a2)
{
  if (a2 == 552) {
    return 0.0;
  }
  *(float *)&double result = 0.0;
  return result;
}

float TSDMetalColor4fWith32BitUIntAndFormat(int a1, uint64_t a2)
{
  if (a2 == 70) {
    unsigned __int8 v2 = a1;
  }
  else {
    unsigned __int8 v2 = BYTE2(a1);
  }
  return (double)v2 * 0.00390640259;
}

unint64_t *TSDMetalThreadgroupSizeToCoverRect@<X0>(unint64_t *result@<X0>, double *a2@<X1>, unint64_t a3@<X2>, int a4@<W3>, unint64_t *a5@<X8>, double a6@<D2>, double a7@<D3>)
{
  if (a6 == 0.0 || a7 == 0.0)
  {
    *a5 = 0;
    a5[1] = 0;
    a5[2] = 0;
  }
  else
  {
    if (a4) {
      double v7 = a6;
    }
    else {
      double v7 = a7;
    }
    if (a4) {
      double v8 = a7;
    }
    else {
      double v8 = a6;
    }
    unint64_t v9 = (unint64_t)v7;
    unint64_t v10 = 1;
    if ((unint64_t)v8 > a3)
    {
      unint64_t v11 = (unint64_t)v8;
      do
      {
        v11 >>= 1;
        v10 *= 2;
      }
      while (v11 > a3);
    }
    unint64_t v12 = (unint64_t)v8 / v10;
    unint64_t v13 = a3 / v12;
    if (v12 < a3 / v12) {
      unint64_t v13 = (unint64_t)v8 / v10;
    }
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    unint64_t v14 = (v9 + v13 - 1) / v13;
    unint64_t v15 = 1;
    if (v14 >= 0x29)
    {
      unint64_t v16 = (v9 + v13 - 1) / v13;
      do
      {
        unint64_t v14 = v16 >> 1;
        v15 *= 2;
        BOOL v17 = v16 > 0x51;
        v16 >>= 1;
      }
      while (v17);
    }
    unint64_t v18 = v15 * v14 * (v13 - 1);
    while (v18 > v9)
    {
      v18 -= v15 * v14;
      --v13;
    }
    *double result = v14;
    if (a4)
    {
      *a2 = (double)v15;
      a2[1] = (double)v10;
      *a5 = v13;
      a5[1] = v12;
    }
    else
    {
      *a2 = (double)v10;
      a2[1] = (double)v15;
      *a5 = v12;
      a5[1] = v13;
    }
    a5[2] = 1;
  }
  return result;
}

id TSDMetalDevice()
{
  if (TSDMetalDevice_s_onceToken != -1) {
    dispatch_once(&TSDMetalDevice_s_onceToken, &__block_literal_global_34);
  }
  double v0 = (void *)TSDMetalDevice_s_metalDevice;

  return v0;
}

uint64_t __TSDMetalDevice_block_invoke()
{
  TSDMetalDevice_s_metalDevice = (uint64_t)MTLCreateSystemDefaultDevice();

  return MEMORY[0x270F9A758]();
}

id TSDMetalDevicePreferringLowPower()
{
  if (TSDMetalDevicePreferringLowPower_s_onceToken != -1) {
    dispatch_once(&TSDMetalDevicePreferringLowPower_s_onceToken, &__block_literal_global_11);
  }
  double v0 = (void *)TSDMetalDevicePreferringLowPower_s_metalDevice;

  return v0;
}

uint64_t __TSDMetalDevicePreferringLowPower_block_invoke()
{
  TSDMetalDevicePreferringLowPower_s_metalDevice = (uint64_t)MTLCreateSystemDefaultDevice();

  return MEMORY[0x270F9A758]();
}

CGImageRef TSDMetalCreateCGImageFromTexture(void *a1)
{
  id v1 = a1;
  if ([v1 pixelFormat] == 110
    || [v1 pixelFormat] == 112
    || [v1 pixelFormat] == 113
    || [v1 pixelFormat] == 114)
  {
    size_t v2 = 16;
  }
  else if ([v1 pixelFormat] == 115)
  {
    size_t v2 = 16;
  }
  else
  {
    size_t v2 = 8;
  }
  uint64_t v3 = [v1 height];
  size_t v4 = (v2 >> 1) * v3 * [v1 width];
  double v5 = malloc_type_malloc(v4, 0x91277B6CuLL);
  size_t v6 = [v1 width] * (v2 >> 1);
  memset(v12, 0, 24);
  v12[3] = [v1 width];
  v12[4] = [v1 height];
  v12[5] = 1;
  [v1 getBytes:v5 bytesPerRow:v6 fromRegion:v12 mipmapLevel:0];
  if ([v1 pixelFormat] == 80
    || [v1 pixelFormat] == 81
    || [v1 pixelFormat] == 552
    || [v1 pixelFormat] == 553)
  {
    CGBitmapInfo v7 = 8194;
  }
  else
  {
    CGBitmapInfo v7 = 16385;
  }
  double v8 = CGDataProviderCreateWithData(0, v5, v4, (CGDataProviderReleaseDataCallback)p_freeImageData);
  DeviceRGB = CGColorSpaceCreateDeviceRGB();
  CGImageRef v10 = CGImageCreate([v1 width], objc_msgSend(v1, "height"), v2, 4 * v2, v6, DeviceRGB, v7, v8, 0, 0, kCGRenderingIntentDefault);
  CGDataProviderRelease(v8);
  CGColorSpaceRelease(DeviceRGB);

  return v10;
}

void p_freeImageData(int a1, void *a2)
{
}

id TSDMetalCommandQueueForRenderingDrawables(void *a1)
{
  id v1 = a1;
  if (TSDMetalCommandQueueForRenderingDrawables_sOnceToken != -1) {
    dispatch_once(&TSDMetalCommandQueueForRenderingDrawables_sOnceToken, &__block_literal_global_13);
  }
  uint64_t v9 = 0;
  CGImageRef v10 = &v9;
  uint64_t v11 = 0x3032000000;
  unint64_t v12 = __Block_byref_object_copy__13;
  unint64_t v13 = __Block_byref_object_dispose__13;
  id v14 = 0;
  size_t v2 = TSDMetalCommandQueueForRenderingDrawables_sCommandQueueAcessingQueue;
  v6[0] = MEMORY[0x263EF8330];
  v6[1] = 3221225472;
  v6[2] = __TSDMetalCommandQueueForRenderingDrawables_block_invoke_16;
  v6[3] = &unk_2646B1A40;
  id v7 = v1;
  double v8 = &v9;
  id v3 = v1;
  dispatch_sync(v2, v6);
  id v4 = (id)v10[5];

  _Block_object_dispose(&v9, 8);

  return v4;
}

uint64_t __TSDMetalCommandQueueForRenderingDrawables_block_invoke()
{
  uint64_t v0 = [MEMORY[0x263EFF9A0] dictionary];
  id v1 = (void *)TSDMetalCommandQueueForRenderingDrawables_sCommandQueueDictionary;
  TSDMetalCommandQueueForRenderingDrawables_sCommandQueueDictionarCGFloat y = v0;

  TSDMetalCommandQueueForRenderingDrawables_sCommandQueueAcessingQueue = (uint64_t)dispatch_queue_create("com.apple.iwork.TSDMetalDrawableCommandQueueAccessingQueue", 0);

  return MEMORY[0x270F9A758]();
}

uint64_t __Block_byref_object_copy__13(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__13(uint64_t a1)
{
}

void __TSDMetalCommandQueueForRenderingDrawables_block_invoke_16(uint64_t a1)
{
  size_t v2 = (void *)TSDMetalCommandQueueForRenderingDrawables_sCommandQueueDictionary;
  id v3 = objc_msgSend(NSNumber, "numberWithUnsignedLongLong:", objc_msgSend(*(id *)(a1 + 32), "registryID"));
  uint64_t v4 = [v2 objectForKeyedSubscript:v3];
  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  size_t v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;

  if (!*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40))
  {
    uint64_t v7 = [*(id *)(a1 + 32) newCommandQueue];
    uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8);
    uint64_t v9 = *(void **)(v8 + 40);
    *(void *)(v8 + 40) = v7;

    CGImageRef v10 = *(void **)(a1 + 32);
    uint64_t v11 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    unint64_t v12 = (void *)TSDMetalCommandQueueForRenderingDrawables_sCommandQueueDictionary;
    objc_msgSend(NSNumber, "numberWithUnsignedLongLong:", objc_msgSend(v10, "registryID"));
    id v13 = (id)objc_claimAutoreleasedReturnValue();
    [v12 setObject:v11 forKeyedSubscript:v13];
  }
}

Path *Path::Outline(Path *this, Path *a2)
{
  id v3 = this;
  if (this->var0)
  {
    this = Path::CancelBezier(this);
    if ((v3->var0 & 2) == 0)
    {
LABEL_3:
      if (!a2) {
        return this;
      }
      goto LABEL_7;
    }
  }
  else if ((this->var0 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = Path::CloseSubpath(v3, 0);
  if (!a2) {
    return this;
  }
LABEL_7:
  if (v3->var2 >= 2)
  {
    Path::Reset(a2);
    Path::SetWeighted(a2, 0);
    Path::SetBackData(a2, 0);
    operator new();
  }
  return this;
}

uint64_t Path::StdCubicTo(long long *a1, float a2, double a3)
{
  return Path::RecStdCubicTo(a1, 8, a2, a3);
}

uint64_t Path::StdBezierTo(uint64_t a1, float a2, float32_t a3)
{
  int v21 = 1;
  float32x2_t v6 = *(float32x2_t *)(a1 + 48);
  uint64_t v22 = *(void *)(a1 + 40);
  float32x2_t v20 = v6;
  uint64_t v13 = 0;
  __int32 v7 = *(_DWORD *)(a1 + 32);
  float32_t v8 = *(float *)(a1 + 36);
  v6.i32[0] = v7;
  Path::TangentOnBezAt(&v20, (uint64_t)&v21, 0, &v19, (uint64_t)&v17, (float *)&v13 + 1, &v15, 0.0, v6, v8);
  v9.i32[0] = v7;
  Path::TangentOnBezAt(&v20, (uint64_t)&v21, 1, &v18, (uint64_t)&v16, (float *)&v13, &v14, 1.0, v9, v8);
  v10.i64[0] = __PAIR64__(v13, HIDWORD(v13));
  v11.i64[0] = v17;
  v11.i64[1] = v16;
  *(float32x4_t *)(a1 + 48) = vmulq_f32((float32x4_t)vzip1q_s32(v10, v10), v11);
  v11.f32[0] = a3;

  return Path::RecStdCubicTo((long long *)a1, 8, a2, *(double *)v11.i64);
}

void Path::StdArcTo(uint64_t a1, float a2, float a3)
{
  *(void *)(a1 + 64) = 0x3F80000000000000;
  Path::RecStdArcTo((long long *)a1, 8, a2, a3);
}

uint64_t Path::SubContractOutline(uint64_t result, path_descr *a2, uint64_t a3, int a4, __n128 a5, float a6, float a7, double a8, double a9, double a10, __n128 a11, uint64_t a12, int a13, int a14, float32x2_t *a15, void *a16)
{
  float v168 = a5.n128_f32[0];
  uint64_t v200 = result;
  v203 = a2;
  if (*(int *)(result + 8) >= 2)
  {
    uint64_t v16 = a15;
    int v18 = a4;
    float32x2_t v19 = (Path *)a2;
    uint64_t v20 = result;
    uint64_t v21 = *(void *)(result + 16);
    __int32 v23 = *(_DWORD *)(v21 + 16);
    float v22 = *(float *)(v21 + 20);
    int v167 = a13 ^ 1;
    double v24 = &qword_223839000;
    int v25 = 1;
    float v26 = 0.0;
    float v27 = 0.0;
    float v28 = 0.0;
    a5.n128_u32[1] = 0;
    v173.i32[0] = 0;
    float v177 = 0.0;
    float v186 = 0.0;
    int v176 = 1;
    while (1)
    {
      uint64_t v29 = *(void *)(v20 + 16);
      double result = v29 + 44 * v25;
      char v30 = *(_DWORD *)result;
      uint64_t v193 = 0;
      uint64_t v194 = 0;
      float v31 = 0.0;
      float v32 = 0.0;
      float v33 = 0.0;
      a11.n128_u64[0] = 0;
      switch(v30 & 0xF)
      {
        case 0:
          uint64_t v34 = v29 + 44 * v25;
          a11.n128_u32[0] = *(_DWORD *)(v34 + 16);
          float v33 = *(float *)(v34 + 20);
          if (((v176 | v167) & 1) == 0)
          {
            __n128 v179 = a11;
            if (vabds_f32(*(float *)&v23, v173.f32[0]) >= 0.0001 || vabds_f32(v22, v28) >= 0.0001)
            {
              float v92 = v173.f32[0] - *(float *)&v23;
              float v93 = v28 - v22;
              float v94 = sqrtf((float)(v93 * v93) + (float)(v92 * v92));
              if (v94 <= 0.000001)
              {
                v198.f32[1] = v22;
                float v95 = 0.0;
                LODWORD(v96) = v23;
                float v97 = v22;
                float v94 = 0.0;
                float v98 = *(float *)&v23;
                float v99 = 0.0;
                float v100 = (float *)&v195 + 1;
              }
              else
              {
                float v32 = v92 / v94;
                float v95 = v93 / v94;
                float v96 = (float)(v173.f32[0] * 0.0) + *(float *)&v23;
                float v97 = (float)(v28 * 0.0) + v22;
                *((float *)&v195 + 1) = v95;
                float v98 = v173.f32[0] + (float)(*(float *)&v23 * 0.0);
                float v99 = v28 + (float)(v22 * 0.0);
                float v100 = (float *)&v198 + 1;
              }
              float v174 = v98;
              float v196 = v32;
              float v197 = v95;
              unint64_t v199 = __PAIR64__(LODWORD(v97), LODWORD(v96));
              *(float *)&uint64_t v193 = v94;
              *((float *)&v193 + 1) = v94;
              *(float *)&uint64_t v195 = v32;
              v198.f32[0] = v98;
              *float v100 = v99;
              float v126 = -v95;
              float v127 = *((float *)&v195 + 1);
              float v31 = -*((float *)&v195 + 1);
              float v128 = *(float *)&v23;
              float v129 = v22;
              float v36 = a7;
              float v37 = a6;
              Path::OutlineJoin(v19, v18, v128, v129, v27, v26, v126, v32, a6, a7);
              float v130 = v174 - (float)(a6 * v127);
              float v28 = v198.f32[1];
              Path::LineTo(v19, v130, v198.f32[1] + (float)(a6 * v32));
              float v35 = v174;
              float v27 = v31;
              float v26 = v32;
            }
            else
            {
              float v35 = v173.f32[0];
              float v36 = a7;
              float v37 = a6;
            }
            Path::OutlineJoin(v19, v18, v35, v28, v27, v26, v186, v177, v37, v36);
            double result = Path::Close(v19);
            a11 = v179;
          }
          ++v25;
          v173.i32[0] = a11.n128_u32[0];
          float v28 = v33;
          goto LABEL_90;
        case 1:
          uint64_t v38 = v29 + 44 * v25;
          a5.n128_u32[0] = *(_DWORD *)(v38 + 16);
          float v33 = *(float *)(v38 + 20);
          __n128 v180 = a5;
          double result = Path::IsNulCurve((Path *)result, a2, *(float *)&v23, v22);
          if (result)
          {
            ++v25;
            float v31 = v27;
            float v32 = v26;
            float v33 = v22;
            a11.n128_u32[0] = v23;
          }
          else
          {
            float v63 = v180.n128_f32[0] - *(float *)&v23;
            float v64 = v33 - v22;
            float v65 = sqrtf((float)(v64 * v64) + (float)(v63 * v63));
            float v66 = v180.n128_f32[0];
            float v175 = v28;
            if (v65 <= 0.000001)
            {
              v198.f32[1] = v22;
              float v67 = 0.0;
              LODWORD(v68) = v23;
              float v69 = v22;
              float v65 = 0.0;
              float v70 = *(float *)&v23;
              float v71 = 0.0;
              unsigned int v72 = (float *)&v195 + 1;
            }
            else
            {
              float v32 = v63 / v65;
              float v67 = v64 / v65;
              float v68 = *(float *)&v23 + (float)(v180.n128_f32[0] * 0.0);
              float v69 = v22 + (float)(v33 * 0.0);
              *((float *)&v195 + 1) = v64 / v65;
              float v70 = v180.n128_f32[0] + (float)(*(float *)&v23 * 0.0);
              float v71 = v33 + (float)(v22 * 0.0);
              unsigned int v72 = (float *)&v198 + 1;
            }
            float v196 = v32;
            float v197 = v67;
            unint64_t v199 = __PAIR64__(LODWORD(v69), LODWORD(v68));
            *(float *)&uint64_t v193 = v65;
            *((float *)&v193 + 1) = v65;
            *(float *)&uint64_t v195 = v32;
            v198.f32[0] = v70;
            *unsigned int v72 = v71;
            float v109 = -v67;
            float v110 = *((float *)&v195 + 1);
            *uint64_t v16 = v198;
            *a16 = v195;
            if (v176)
            {
              if (a14)
              {
                a14 = 0;
                float v186 = -v67;
                float v177 = v32;
                v173.f32[0] = v68;
                float v28 = v69;
                float v111 = a6;
              }
              else
              {
                float v111 = a6;
                float v140 = v110;
                float v141 = v22 + (float)(a6 * v32);
                float v142 = v68;
                Path::MoveTo(v19, *(float *)&v23 + (float)(a6 * v109), v141);
                float v110 = v140;
                float v66 = v180.n128_f32[0];
                a14 = 0;
                float v186 = v109;
                float v177 = v32;
                v173.f32[0] = v142;
                float v28 = v69;
              }
            }
            else
            {
              float v113 = v110;
              float v114 = v27;
              float v111 = a6;
              Path::OutlineJoin(v19, v18, *(float *)&v23, v22, v114, v26, v109, v32, a6, a7);
              float v110 = v113;
              float v66 = v180.n128_f32[0];
              float v28 = v175;
            }
            float v31 = -v110;
            double result = Path::LineTo(v19, v66 + (float)(v111 * (float)-v110), v33 + (float)(v111 * v32));
            if ((result & 0x80000000) == 0)
            {
              uint64_t v143 = (uint64_t)v19->var3 + 44 * result;
              *(_DWORD *)(v143 + 4) = v25;
              a5.n128_u64[0] = v24[395];
              *(void *)(v143 + 8) = a5.n128_u64[0];
            }
            int v176 = 0;
            ++v25;
            a11 = v180;
          }
          goto LABEL_90;
        case 2:
          long long v39 = (float32x2_t *)(v29 + 44 * v25);
          a5.n128_u32[0] = v39[2].u32[0];
          float v33 = v39[2].f32[1];
          unint64_t v40 = v39 + 2;
          __n128 v181 = a5;
          double result = Path::IsNulCurve((Path *)result, a2, *(float *)&v23, v22);
          if (result) {
            goto LABEL_17;
          }
          v173.f32[1] = v28;
          v41.i32[0] = v23;
          Path::TangentOnCubAt(v40, 0, (float32x2_t *)&v199, (uint64_t)&v196, (float *)&v193 + 1, (float *)&v194 + 1, 0.0, v41, v22);
          v42.i32[0] = v23;
          Path::TangentOnCubAt(v40, 1, &v198, (uint64_t)&v195, (float *)&v193, (float *)&v194, 1.0, v42, v22);
          float v43 = v196;
          float v44 = -v197;
          float v45 = *((float *)&v195 + 1);
          float v32 = *(float *)&v195;
          *uint64_t v16 = v198;
          *a16 = v195;
          if (v176)
          {
            float32x2_t v173 = (float32x2_t)v199;
            if (a14)
            {
              a14 = 0;
              float v46 = a6;
              long long v47 = (uint64_t (**)(uint64_t *, float, float))a3;
              unsigned __int32 v48 = v181.n128_u32[0];
              float v49 = v43;
LABEL_63:
              float v31 = -v45;
              int v201 = v25;
              uint64_t v202 = v24[395];
              unint64_t v204 = __PAIR64__(LODWORD(v22), v23);
              *(void *)&long long v205 = __PAIR64__(LODWORD(v33), v48);
              *((float32x2_t *)&v205 + 1) = v40[1];
              __int32 v206 = v40[2].i32[0];
              __int32 v207 = v40[2].i32[1];
              double result = (*v47)(&v200, v168, v46);
              goto LABEL_67;
            }
            float v46 = a6;
            float v49 = v43;
            Path::MoveTo(v19, *(float *)&v23 + (float)(a6 * v44), v22 + (float)(a6 * v43));
            a14 = 0;
          }
          else
          {
            float v108 = v27;
            float v46 = a6;
            Path::OutlineJoin(v19, v18, *(float *)&v23, v22, v108, v26, v44, v43, a6, a7);
            float v44 = v186;
            float v49 = v177;
          }
          long long v47 = (uint64_t (**)(uint64_t *, float, float))a3;
          unsigned __int32 v48 = v181.n128_u32[0];
          goto LABEL_63;
        case 3:
          int v170 = a14;
          unint64_t v50 = v24;
          uint64_t v51 = v29 + 44 * v25;
          int v54 = *(_DWORD *)(v51 + 16);
          uint64_t v53 = v51 + 16;
          int v52 = v54;
          a5.n128_u64[0] = *(void *)(v53 + 4);
          __n128 v182 = a5;
          double result = Path::IsNulCurve((Path *)result, a2, *(float *)&v23, v22);
          int v56 = v25 + 1;
          if (result)
          {
            int v25 = v56 + v52;
            float v31 = v27;
            float v32 = v26;
            float v33 = v22;
            a11.n128_u32[0] = v23;
            a14 = v170;
            goto LABEL_90;
          }
          int v73 = v52;
          if (v52 <= 0)
          {
            int v115 = v25 + 1;
            int v116 = v73;
            v173.f32[1] = v28;
            float v117 = v182.n128_f32[0];
            float v118 = v182.n128_f32[0] - *(float *)&v23;
            float v119 = v182.n128_f32[1] - v22;
            float v120 = sqrtf((float)(v119 * v119) + (float)(v118 * v118));
            if (v120 <= 0.000001)
            {
              v198.f32[1] = v22;
              float v121 = 0.0;
              LODWORD(v122) = v23;
              float v28 = v22;
              float v120 = 0.0;
              float v123 = *(float *)&v23;
              float v124 = 0.0;
              int v125 = (float *)&v195 + 1;
            }
            else
            {
              float v32 = v118 / v120;
              float v121 = v119 / v120;
              float v122 = *(float *)&v23 + (float)(v182.n128_f32[0] * 0.0);
              float v28 = v22 + (float)(v182.n128_f32[1] * 0.0);
              *((float *)&v195 + 1) = v119 / v120;
              float v123 = v182.n128_f32[0] + (float)(*(float *)&v23 * 0.0);
              float v124 = v182.n128_f32[1] + (float)(v22 * 0.0);
              int v125 = (float *)&v198 + 1;
            }
            float v196 = v32;
            float v197 = v121;
            unint64_t v199 = __PAIR64__(LODWORD(v28), LODWORD(v122));
            *(float *)&uint64_t v193 = v120;
            *((float *)&v193 + 1) = v120;
            *(float *)&uint64_t v195 = v32;
            v198.f32[0] = v123;
            *int v125 = v124;
            float v144 = -v121;
            float v145 = *((float *)&v195 + 1);
            *uint64_t v16 = v198;
            *a16 = v195;
            a14 = v170;
            if (v176)
            {
              unsigned __int32 v187 = LODWORD(v122);
              if (v170)
              {
                a14 = 0;
                float v177 = v32;
                float v146 = a6;
                float v84 = -v121;
              }
              else
              {
                float v146 = a6;
                float v84 = -v121;
                Path::MoveTo(v19, *(float *)&v23 + (float)(a6 * v144), v22 + (float)(a6 * v32));
                float v117 = v182.n128_f32[0];
                a14 = 0;
                float v177 = v32;
              }
            }
            else if (v120 <= 0.0)
            {
              float v84 = v186;
              float v28 = v173.f32[1];
              unsigned __int32 v187 = v173.i32[0];
              float v146 = a6;
            }
            else
            {
              float v147 = v27;
              float v146 = a6;
              Path::OutlineJoin(v19, v18, *(float *)&v23, v22, v147, v26, v144, v32, a6, a7);
              float v117 = v182.n128_f32[0];
              float v84 = v186;
              float v28 = v173.f32[1];
              unsigned __int32 v187 = v173.i32[0];
            }
            float v31 = -v145;
            double result = Path::LineTo(v19, v117 + (float)(v146 * v31), v182.n128_f32[1] + (float)(v146 * v32));
            if ((result & 0x80000000) == 0)
            {
              uint64_t v148 = (uint64_t)v19->var3 + 44 * result;
              *(_DWORD *)(v148 + 4) = v25;
              a5.n128_u64[0] = v24[395];
              *(void *)(v148 + 8) = a5.n128_u64[0];
            }
            a11 = v182;
            a5.n128_u32[0] = v187;
            goto LABEL_89;
          }
          int v74 = v25 + 1;
          float v75 = (float32x2_t *)(v29 + 44 * v56);
          float32x2_t v77 = v75[2];
          int v76 = v75 + 2;
          float32x2_t v184 = v77;
          v55.i32[0] = v23;
          int v166 = v73;
          Path::TangentOnBezAt(v76, v53, 0, (float32x2_t *)&v199, (uint64_t)&v196, (float *)&v193 + 1, (float *)&v194 + 1, 0.0, v55, v22);
          int v79 = v166 - 1;
          if (v166 == 1)
          {
            v78.i32[0] = v23;
            Path::TangentOnBezAt(v76, v53, 1, &v198, (uint64_t)&v195, (float *)&v193, (float *)&v194, 1.0, v78, v22);
            float v81 = v196;
            float v80 = v197;
            float v82 = -v197;
            float v83 = *((float *)&v195 + 1);
            float v32 = *(float *)&v195;
            uint64_t v16 = a15;
            *a15 = v198;
            *a16 = v195;
            if (v176)
            {
              float v84 = -v80;
              float32x2_t v173 = (float32x2_t)v199;
              if (v170)
              {
                int v18 = a4;
                float v85 = a6;
                uint64_t v86 = a3;
                float32x2_t v19 = (Path *)a2;
              }
              else
              {
                float v85 = a6;
                float32x2_t v19 = (Path *)a2;
                Path::MoveTo((Path *)a2, *(float *)&v23 + (float)(a6 * v82), v22 + (float)(a6 * v81));
                int v18 = a4;
                uint64_t v86 = a3;
              }
              double v24 = v50;
              a14 = 0;
            }
            else
            {
              v173.f32[1] = v28;
              float32x2_t v19 = (Path *)a2;
              float v85 = a6;
              int v18 = a4;
              Path::OutlineJoin((Path *)a2, a4, *(float *)&v23, v22, v27, v26, v82, v81, a6, a7);
              float v84 = v186;
              float v81 = v177;
              uint64_t v86 = a3;
              double v24 = v50;
              a14 = v170;
            }
            float v31 = -v83;
            int v201 = v25 + 1;
            uint64_t v202 = v24[395];
            unint64_t v204 = __PAIR64__(LODWORD(v22), v23);
            *(void *)&long long v149 = v182.n128_u64[0];
            *((float32x2_t *)&v149 + 1) = v184;
            long long v205 = v149;
            double result = (*(uint64_t (**)(uint64_t *, float, float))(v86 + 8))(&v200, v168, v85);
            a11 = v182;
            float v177 = v81;
            float v28 = v173.f32[1];
            a5.n128_u32[0] = v173.i32[0];
            int v116 = 1;
            int v115 = v25 + 1;
LABEL_89:
            int v176 = 0;
            int v25 = v116 + v115;
            float v33 = a11.n128_f32[1];
            float v186 = v84;
            v173.i32[0] = a5.n128_u32[0];
            goto LABEL_90;
          }
          if (*((float *)&v193 + 1) <= 0.0)
          {
            v173.f32[1] = v28;
            float v161 = v177;
            float v162 = v186;
            float v137 = a15;
            float v138 = a6;
LABEL_93:
            float v139 = v168;
            goto LABEL_94;
          }
          float v136 = -v197;
          if ((v176 & 1) == 0)
          {
            v173.f32[1] = v28;
            float v138 = a6;
            Path::OutlineJoin((Path *)a2, a4, *(float *)&v23, v22, v196, v197, v136, v196, a6, a7);
            int v176 = 0;
            float v162 = v186;
            float v161 = v177;
            float v137 = a15;
            goto LABEL_93;
          }
          float32x2_t v173 = (float32x2_t)v199;
          float v137 = a15;
          float v138 = a6;
          float v139 = v168;
          float v161 = v196;
          float v162 = -v197;
          if ((v170 & 1) == 0) {
            Path::MoveTo((Path *)a2, *(float *)&v23 + (float)(a6 * v136), v22 + (float)(a6 * v196));
          }
          int v176 = 0;
          int v170 = 0;
LABEL_94:
          float32x2_t v150 = v184;
          v78.f32[0] = -(float)(v184.f32[0] - (float)(*(float *)&v23 * 2.0));
          float v151 = -(float)(v184.f32[1] - (float)(v22 * 2.0));
          float v152 = (void *)(v29 + 44 * (v25 + 1) + 60);
          do
          {
            float32x2_t v153 = *(float32x2_t *)v152;
            float v152 = (void *)((char *)v152 + 44);
            float32x2_t v185 = v153;
            float32x2_t v188 = v150;
            float32_t v155 = v150.f32[1];
            *(float *)&unsigned int v156 = (float)(v151 + v150.f32[1]) * 0.5;
            int v191 = 1;
            float32x2_t v178 = vmul_f32(vadd_f32(v150, v153), (float32x2_t)0x3F0000003F000000);
            float32x2_t v192 = v178;
            float32x2_t v190 = v150;
            v78.f32[0] = (float)(v78.f32[0] + v150.f32[0]) * 0.5;
            unsigned int v154 = v78.u32[0];
            Path::TangentOnBezAt(&v190, (uint64_t)&v191, 1, &v198, (uint64_t)&v195, (float *)&v193, (float *)&v194, 1.0, v78, *(float32_t *)&v156);
            *float v137 = v198;
            *a16 = v195;
            int v201 = v74;
            uint64_t v157 = v50[395];
            uint64_t v202 = v157;
            unint64_t v204 = __PAIR64__(v156, v154);
            *(float32x2_t *)&long long v158 = v178;
            *((float32x2_t *)&v158 + 1) = v188;
            long long v205 = v158;
            (*(void (**)(uint64_t *, float, float))(a3 + 8))(&v200, v139, v138);
            float32x2_t v150 = v153;
            float32x2_t v78 = v188;
            ++v74;
            float v151 = v155;
            --v79;
          }
          while (v79);
          int v191 = 1;
          float32x2_t v189 = vmul_f32(vadd_f32(v185, vmla_f32(vneg_f32(v185), (float32x2_t)0x4000000040000000, (float32x2_t)v182.n128_u64[0])), (float32x2_t)0x3F0000003F000000);
          float32x2_t v192 = v189;
          float32x2_t v190 = v185;
          Path::TangentOnBezAt(&v190, (uint64_t)&v191, 1, &v198, (uint64_t)&v195, (float *)&v193, (float *)&v194, 1.0, v178, v178.f32[1]);
          float v31 = -*((float *)&v195 + 1);
          float v159 = v139;
          float v32 = *(float *)&v195;
          *float v137 = v198;
          *a16 = v195;
          int v201 = v166 + v25;
          uint64_t v202 = v157;
          unint64_t v204 = (unint64_t)v178;
          *(float32x2_t *)&long long v160 = v189;
          *((float32x2_t *)&v160 + 1) = v185;
          long long v205 = v160;
          double result = (*(uint64_t (**)(uint64_t *, float, float))(a3 + 8))(&v200, v159, v138);
          a11 = v182;
          float32x2_t v19 = (Path *)a2;
          v25 += v166 + 1;
          float v33 = v182.n128_f32[1];
          float v186 = v162;
          float v177 = v161;
          double v24 = v50;
          a14 = v170;
          uint64_t v16 = v137;
          int v18 = a4;
LABEL_68:
          float v28 = v173.f32[1];
LABEL_90:
          __int32 v23 = a11.n128_u32[0];
          float v22 = v33;
          float v26 = v32;
          float v27 = v31;
          if (v25 >= *(_DWORD *)(v20 + 8)) {
            return result;
          }
          break;
        case 4:
          uint64_t v57 = v29 + 44 * v25;
          a5.n128_u32[0] = *(_DWORD *)(v57 + 16);
          float v33 = *(float *)(v57 + 20);
          uint64_t v58 = v57 + 16;
          __n128 v181 = a5;
          double result = Path::IsNulCurve((Path *)result, a2, *(float *)&v23, v22);
          if (result)
          {
LABEL_17:
            ++v25;
            float v31 = v27;
            float v32 = v26;
            float v33 = v22;
            a11.n128_u32[0] = v23;
            goto LABEL_90;
          }
          v173.f32[1] = v28;
          Path::TangentOnArcAt(v58, (float *)&v199, (uint64_t)&v196, (float *)&v193 + 1, (float *)&v194 + 1, 0.0, *(float *)&v23, v22);
          Path::TangentOnArcAt(v58, (float *)&v198, (uint64_t)&v195, (float *)&v193, (float *)&v194, 1.0, *(float *)&v23, v22);
          float v87 = v196;
          float v44 = -v197;
          float v88 = *((float *)&v195 + 1);
          float v32 = *(float *)&v195;
          *uint64_t v16 = v198;
          *a16 = v195;
          if (v176)
          {
            float32x2_t v173 = (float32x2_t)v199;
            if (a14)
            {
              a14 = 0;
              float v89 = a6;
              uint64_t v90 = a3;
              unsigned __int32 v91 = v181.n128_u32[0];
              float v49 = v87;
              goto LABEL_66;
            }
            float v89 = a6;
            float v49 = v87;
            Path::MoveTo(v19, *(float *)&v23 + (float)(a6 * v44), v22 + (float)(a6 * v87));
            a14 = 0;
          }
          else
          {
            float v112 = v27;
            float v89 = a6;
            Path::OutlineJoin(v19, v18, *(float *)&v23, v22, v112, v26, v44, v87, a6, a7);
            float v44 = v186;
            float v49 = v177;
          }
          uint64_t v90 = a3;
          unsigned __int32 v91 = v181.n128_u32[0];
LABEL_66:
          float v31 = -v88;
          int v201 = v25;
          uint64_t v202 = v24[395];
          unint64_t v204 = __PAIR64__(LODWORD(v22), v23);
          *(void *)&long long v205 = __PAIR64__(LODWORD(v33), v91);
          *((void *)&v205 + 1) = *(void *)(v58 + 8);
          __int32 v206 = *(_DWORD *)(v58 + 16);
          LOBYTE(v207) = *(unsigned char *)(v58 + 21);
          BYTE1(v207) = *(unsigned char *)(v58 + 20);
          double result = (*(uint64_t (**)(uint64_t *, float, float))(v90 + 16))(&v200, v168, v89);
LABEL_67:
          a11 = v181;
          int v176 = 0;
          ++v25;
          float v186 = v44;
          float v177 = v49;
          goto LABEL_68;
        case 5:
          a11.n128_u32[0] = 0;
          if ((v176 & 1) == 0)
          {
            float v59 = v173.f32[0];
            v173.f32[1] = v28;
            if (vabds_f32(*(float *)&v23, v173.f32[0]) >= 0.0001 || vabds_f32(v22, v28) >= 0.0001)
            {
              float v101 = v173.f32[0] - *(float *)&v23;
              float v102 = v28 - v22;
              float v103 = sqrtf((float)(v102 * v102) + (float)(v101 * v101));
              if (v103 <= 0.000001)
              {
                v198.f32[1] = v22;
                float v104 = 0.0;
                float v103 = 0.0;
                float v105 = *(float *)&v23;
                int v107 = (float *)&v195 + 1;
                float v106 = 0.0;
              }
              else
              {
                float v32 = v101 / v103;
                float v104 = v102 / v103;
                float v105 = v173.f32[0] + (float)(*(float *)&v23 * 0.0);
                *(float *)&__int32 v23 = (float)(v173.f32[0] * 0.0) + *(float *)&v23;
                float v106 = v28 + (float)(v22 * 0.0);
                float v22 = (float)(v28 * 0.0) + v22;
                *((float *)&v195 + 1) = v104;
                int v107 = (float *)&v198 + 1;
              }
              float v196 = v32;
              float v197 = v104;
              unint64_t v199 = __PAIR64__(LODWORD(v22), v23);
              *(float *)&uint64_t v193 = v103;
              *((float *)&v193 + 1) = v103;
              *(float *)&uint64_t v195 = v32;
              v198.f32[0] = v105;
              *int v107 = v106;
              float v131 = *((float *)&v195 + 1);
              float v31 = -*((float *)&v195 + 1);
              float v132 = *(float *)&v23;
              float v133 = v27;
              float v61 = a7;
              float v62 = a6;
              float v134 = v105;
              Path::OutlineJoin(v19, v18, v132, v22, v133, v26, -v104, v32, a6, a7);
              float v60 = v198.f32[1];
              Path::LineTo(v19, v134 - (float)(v62 * v131), v198.f32[1] + (float)(v62 * v32));
              float v59 = v134;
              float v27 = v31;
              float v26 = v32;
              float v33 = v173.f32[1];
              v135.n128_u32[0] = v173.i32[0];
              __n128 v183 = v135;
            }
            else
            {
              float v60 = v28;
              a5.n128_u64[0] = 0;
              __n128 v183 = a5;
              float v61 = a7;
              float v62 = a6;
            }
            Path::OutlineJoin(v19, v18, v59, v60, v27, v26, v186, v177, v62, v61);
            double result = Path::Close(v19);
            float v28 = v173.f32[1];
            a11 = v183;
          }
          ++v25;
          int v176 = 1;
          goto LABEL_90;
        case 6:
          goto LABEL_90;
        case 7:
          ++v25;
          goto LABEL_24;
        default:
          float v31 = 0.0;
          float v32 = 0.0;
          float v33 = 0.0;
LABEL_24:
          a11.n128_u32[0] = 0;
          goto LABEL_90;
      }
    }
  }
  return result;
}

Path *Path::OutsideOutline(Path *this, Path *a2, int a3, float a4, float a5)
{
  float32x2_t v9 = this;
  if (this->var0)
  {
    this = Path::CancelBezier(this);
    if ((v9->var0 & 2) == 0)
    {
LABEL_3:
      if (!a2) {
        return this;
      }
      goto LABEL_7;
    }
  }
  else if ((this->var0 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = Path::CloseSubpath(v9, 0);
  if (!a2) {
    return this;
  }
LABEL_7:
  if (v9->var2 >= 3)
  {
    Path::Reset(a2);
    Path::SetWeighted(a2, 0);
    Path::SetBackData(a2, 0);
    v18[0] = Path::StdCubicTo;
    v18[1] = Path::StdBezierTo;
    v18[2] = Path::StdArcTo;
    v10.n128_f64[0] = a4 * 0.0025 * a4;
    v10.n128_f32[0] = v10.n128_f64[0];
    return (Path *)Path::SubContractOutline((uint64_t)v9, (path_descr *)a2, (uint64_t)v18, a3, v10, a4, a5, v12, v13, v14, v15, v11, 1, 0, &v16, &v17);
  }
  return this;
}

Path *Path::InsideOutline(Path *this, Path *a2)
{
  size_t v2 = this;
  int var0 = this->var0;
  if (this->var0)
  {
    this = Path::CancelBezier(this);
    int var0 = v2->var0;
  }
  if ((var0 & 2) != 0) {
    this = Path::CloseSubpath(v2, 0);
  }
  if (a2)
  {
    if (v2->var2 >= 3)
    {
      Path::Reset(a2);
      Path::SetWeighted(a2, 0);
      Path::SetBackData(a2, 0);
      operator new();
    }
  }
  return this;
}

Path *Path::OutlineJoin(Path *this, int a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9, float a10)
{
  float v13 = a4;
  __n128 v15 = this;
  double v16 = (float)((float)(a5 * a8) - (float)(a6 * a7));
  if (a9 >= 0.0 && v16 > -0.001 || a9 < 0.0 && v16 < 0.001)
  {
    double v17 = (float)((float)(a6 * a8) + (float)(a5 * a7));
    if (v17 > 0.999) {
      return this;
    }
    if (v17 < -0.999) {
      goto LABEL_14;
    }
    float v18 = a3;
LABEL_8:
    Path::LineTo(this, v18, a4);
LABEL_14:
    return (Path *)Path::LineTo(v15, a3 + (float)(a9 * a7), v13 + (float)(a9 * a8));
  }
  if (a2 == 2)
  {
    float v24 = a5 + a7;
    float v25 = sqrtf((float)((float)(a6 + a8) * (float)(a6 + a8)) + (float)(v24 * v24));
    float v26 = v24 / v25;
    float v27 = (float)(a6 + a8) / v25;
    float v28 = a9 / (float)((float)(a8 * v27) + (float)(v26 * a7));
    if ((float)(v28 / a9) > a10) {
      goto LABEL_14;
    }
    float v18 = a3 + (float)(v28 * v26);
    a4 = v13 + (float)(v28 * v27);
    goto LABEL_8;
  }
  if (a2 != 1) {
    goto LABEL_14;
  }
  float v19 = a4 + (float)(a9 * a8);
  double v20 = a9;
  if (a9 <= 0.0)
  {
    float v21 = v20 * -1.0001;
    float v22 = v21;
    char v23 = 0;
  }
  else
  {
    float v21 = v20 * 1.0001;
    float v22 = v21;
    char v23 = 1;
  }

  return (Path *)Path::ArcTo(this, a3 + (float)(a9 * a7), v19, v21, v22, 0.0, 0, v23);
}

float *Path::TangentOnSegAt(float *result, float *a2, float *a3, float *a4, float a5, float a6, float a7)
{
  float v8 = *result;
  float v7 = result[1];
  float v9 = *result - a6;
  float v10 = v7 - a7;
  float v11 = sqrtf((float)(v10 * v10) + (float)(v9 * v9));
  if (v11 <= 0.000001)
  {
    *a2 = a6;
    a2[1] = a7;
    float v12 = 0.0;
    float v11 = 0.0;
    *a3 = 0.0;
  }
  else
  {
    *a3 = v9 / v11;
    a3[1] = v10 / v11;
    *a2 = (float)(v8 * a5) + (float)((float)(1.0 - a5) * a6);
    float v12 = (float)(v7 * a5) + (float)((float)(1.0 - a5) * a7);
    a3 = a2;
  }
  a3[1] = v12;
  *a4 = v11;
  return result;
}

BOOL Path::IsNulCurve(Path *this, path_descr *a2, float a3, float a4)
{
  switch(this->var0 & 0xF)
  {
    case 1:
      if (vabds_f32(*(float *)&this->var3, a3) >= 0.00001) {
        return 0;
      }
      int var3_high = HIDWORD(this->var3);
      goto LABEL_25;
    case 2:
      int var4 = this->var4;
      float v11 = *(float *)&this->var6;
      float v12 = *(float *)&this->var3;
      double v7 = 0.0001;
      if (fabsf((float)((float)(*(float *)&var4 + v11) + (float)(a3 * 2.0)) + (float)(v12 * -2.0)) >= 0.0001) {
        return 0;
      }
      if (vabds_f32((float)((float)(a3 * -3.0) + (float)(v12 * 3.0)) + (float)(*(float *)&var4 * -2.0), v11) >= 0.0001) {
        return 0;
      }
      if (fabsf(*(float *)&var4) >= 0.0001) {
        return 0;
      }
      int var5 = this->var5;
      int var8 = this->var8;
      float v15 = *((float *)&this->var3 + 1);
      if (fabsf((float)((float)(*(float *)&var5 + *(float *)&var8) + (float)(a4 * 2.0)) + (float)(v15 * -2.0)) >= 0.0001
        || fabsf((float)((float)((float)(a4 * -3.0) + (float)(v15 * 3.0)) + (float)(*(float *)&var5 * -2.0))- *(float *)&var8) >= 0.0001)
      {
        return 0;
      }
      float v8 = fabsf(*(float *)&var5);
      return v8 < v7;
    case 3:
      uint64_t var3_low = LODWORD(this->var3);
      if ((int)var3_low <= 0)
      {
        if (vabds_f32(*((float *)&this->var3 + 1), a3) >= 0.00001) {
          return 0;
        }
        int var3_high = this->var4;
LABEL_25:
        float v9 = vabds_f32(*(float *)&var3_high, a4);
        return v9 < 0.00001;
      }
      double v6 = vabds_f32(*((float *)&this->var3 + 1), a3);
      if (var3_low == 1)
      {
        double v7 = 0.00001;
        if (v6 >= 0.00001
          || vabds_f32(*(float *)&this->var4, a4) >= 0.00001
          || vabds_f32(*(float *)&this[1].var1, a3) >= 0.00001)
        {
          return 0;
        }
        float v8 = vabds_f32(*(float *)&this[1].var2, a4);
        return v8 < v7;
      }
      if (v6 < 0.00001 && vabds_f32(*(float *)&this->var4, a4) < 0.00001)
      {
        p_int var2 = (float *)&this[1].var2;
        BOOL result = 1;
        while (vabds_f32(*(p_var2 - 1), a3) <= 0.00001 && vabds_f32(*p_var2, a4) <= 0.00001)
        {
          p_var2 += 11;
          if (!--var3_low) {
            return result;
          }
        }
      }
      return 0;
    case 4:
      if (vabds_f32(*(float *)&this->var3, a3) >= 0.00001 || vabds_f32(*((float *)&this->var3 + 1), a4) >= 0.00001) {
        return 0;
      }
      if (!LOBYTE(this->var8) || fabsf(*(float *)&this->var4) < 0.00001) {
        return 1;
      }
      float v9 = fabsf(*(float *)&this->var5);
      return v9 < 0.00001;
    default:
      return 1;
  }
}

float32x2_t *Path::TangentOnCubAt(float32x2_t *result, int a2, float32x2_t *a3, uint64_t a4, float *a5, float *a6, float a7, float32x2_t a8, float32_t a9)
{
  a8.f32[1] = a9;
  __asm { FMOV            V2.2S, #-6.0 }
  float v14 = a7 + -0.5;
  float32x2_t v16 = result[1];
  float32x2_t v15 = result[2];
  float32x2_t v17 = *result;
  *(void *)a4 = 0;
  *a6 = 0.0;
  float32x2_t v18 = vmla_f32(vmla_f32(vadd_f32(v15, v16), (float32x2_t)0xC0000000C0000000, v17), (float32x2_t)0x4000000040000000, a8);
  float32x2_t v19 = vmul_f32(vsub_f32(v15, v16), (float32x2_t)0x3F0000003F000000);
  __asm { FMOV            V16.2S, #6.0 }
  float32x2_t v21 = vsub_f32(vsub_f32(vmla_f32(vmul_f32(a8, _D2), _D16, v17), v16), v15);
  __asm { FMOV            V16.2S, #0.25 }
  float32x2_t v23 = vmul_f32(v21, _D16);
  __asm { FMOV            V16.2S, #4.0 }
  *a3 = vadd_f32(vmul_f32(vadd_f32(vsub_f32(vmla_f32(vmul_f32(v17, _D16), _D16, a8), v15), v16), (float32x2_t)0x3E0000003E000000), vmla_n_f32(vmla_n_f32(vmul_n_f32(vmul_n_f32(v19, v14), v14), vmul_n_f32(vmul_n_f32(v18, v14), v14), v14), v23, v14));
  float v25 = v23.f32[0]
      + (float)((float)(v14 * (float)(v19.f32[0] + v19.f32[0])) + (float)((float)(v14 * (float)(3.0 * v18.f32[0])) * v14));
  float v26 = v23.f32[1]
      + (float)((float)(v14 * (float)(v19.f32[1] + v19.f32[1]))
              + (float)((float)(v14 * vmuls_lane_f32(3.0, v18, 1)) * v14));
  float v27 = 6.0 * v18.f32[0];
  float v28 = (float)(v19.f32[0] + v19.f32[0]) + (float)((float)(6.0 * v18.f32[0]) * v14);
  float v29 = vmuls_lane_f32(6.0, v18, 1);
  float v30 = (float)(v19.f32[1] + v19.f32[1]) + (float)(v29 * v14);
  float v31 = (float)(v26 * v26) + (float)(v25 * v25);
  float v32 = sqrtf(v31);
  if (v32 > 0.0001)
  {
    *a5 = v32;
    *a6 = (float)-(float)(v32 * v31) / (float)((float)(v25 * v30) - (float)(v26 * v28));
    *(float *)a4 = v25 / v32;
    float v33 = v26 / v32;
LABEL_10:
    *(float *)(a4 + 4) = v33;
    return result;
  }
  *a5 = 0.0;
  float v34 = (float)(v30 * v30) + (float)(v28 * v28);
  float v35 = sqrtf(v34);
  if (v35 > 0.0001)
  {
    *a6 = (float)-(float)(v35 * v34) / (float)((float)(v28 * v29) - (float)(v30 * v27));
    float v36 = v30 / v35;
    *(float *)a4 = v28 / v35;
    *(float *)(a4 + 4) = v36;
    if (!a2) {
      return result;
    }
    float v37 = -(float)(v28 / v35);
    goto LABEL_9;
  }
  float v38 = sqrtf((float)(v29 * v29) + (float)(v27 * v27));
  if (v38 > 0.0001)
  {
    *a6 = 100000000.0;
    float v39 = v27 / v38;
    float v36 = v29 / v38;
    *(float *)a4 = v39;
    *(float *)(a4 + 4) = v36;
    if (a2)
    {
      float v37 = -v39;
LABEL_9:
      *(float *)a4 = v37;
      float v33 = -v36;
      goto LABEL_10;
    }
  }
  return result;
}

void Path::TangentOnArcAt(uint64_t a1, float *a2, uint64_t a3, float *a4, float *a5, float a6, float a7, float a8)
{
  float v12 = *(float *)a1;
  float v11 = *(float *)(a1 + 4);
  float v14 = *(float *)(a1 + 8);
  float v13 = *(float *)(a1 + 12);
  float v15 = *(float *)(a1 + 16);
  int v16 = *(unsigned __int8 *)(a1 + 20);
  int v17 = *(unsigned __int8 *)(a1 + 21);
  *a2 = a7;
  a2[1] = a8;
  *(void *)a3 = 0;
  if (v14 > 0.0001 && v13 > 0.0001)
  {
    float v72 = v13;
    __float2 v23 = __sincosf_stret(v15);
    float cosval = v23.__cosval;
    float sinval = v23.__sinval;
    float v25 = (float)((float)((float)(v11 - a8) * v23.__sinval) + (float)(v23.__cosval * (float)(v12 - a7))) / v14;
    float v26 = (float)((float)((float)(v11 - a8) * v23.__cosval) - (float)(v23.__sinval * (float)(v12 - a7))) / v72;
    float v27 = (float)(v26 * v26) + (float)(v25 * v25);
    if (v27 < 4.0)
    {
      float v28 = v12;
      float v29 = v11;
      float v71 = a6;
      float v30 = (float)(v27 * -0.25) + 1.0;
      if (v30 < 0.0) {
        float v30 = 0.0;
      }
      float v31 = sqrtf(v30);
      float v32 = sqrtf(v27);
      float v33 = (float)-v25 / v32;
      float v34 = (float)(v26 / v32) * v31;
      float v35 = v25 * 0.5;
      float v36 = (float)-v34 - (float)(v25 * 0.5);
      float v37 = v26 * 0.5;
      float v38 = 3.1416;
      float v39 = -1.0;
      float v40 = 3.1416;
      if (v36 >= -1.0)
      {
        float v40 = 0.0;
        if (v36 <= 1.0)
        {
          float v66 = (float)-(float)(v33 * v31) - v37;
          float v67 = v33;
          float v68 = v26 * 0.5;
          float v41 = v34;
          float v42 = acosf(v36);
          float v39 = -1.0;
          float v33 = v67;
          float v37 = v68;
          float v34 = v41;
          float v38 = 3.1416;
          float v28 = v12;
          float cosval = v23.__cosval;
          float sinval = v23.__sinval;
          float v29 = v11;
          float v40 = v42;
          if (v66 < 0.0) {
            float v40 = 6.28318531 - v42;
          }
        }
      }
      float v43 = v33 * v31;
      float v70 = -sinval;
      float v44 = v35 - v34;
      if ((float)(v35 - v34) >= v39)
      {
        float v38 = 0.0;
        if (v44 <= 1.0)
        {
          float v69 = v37 - v43;
          float v45 = v34;
          float v46 = acosf(v44);
          float v34 = v45;
          float v28 = v12;
          float cosval = v23.__cosval;
          float sinval = v23.__sinval;
          float v29 = v11;
          float v38 = v46;
          if (v69 < 0.0) {
            float v38 = 6.28318531 - v46;
          }
        }
      }
      float v47 = v14 * v34;
      float v48 = (float)((float)(v72 * v43) * v70) + (float)(cosval * (float)(v14 * v34));
      float v49 = (float)(cosval * (float)(v72 * v43)) + (float)(sinval * v47);
      if (v17)
      {
        if (v16)
        {
          float v48 = -v48;
          float v49 = -v49;
          float v50 = v40 + 3.14159265;
          float v51 = v38 + 3.14159265;
          if (v50 >= 6.28318531)
          {
            float v52 = v50 + -6.28318531;
            float v38 = v52;
          }
          else
          {
            float v38 = v40 + 3.14159265;
          }
          if (v51 >= 6.28318531)
          {
            float v53 = v51 + -6.28318531;
            float v40 = v53;
          }
          else
          {
            float v40 = v51;
          }
        }
        float v54 = (float)((float)(v28 + a7) * 0.5) + v48;
        float v55 = (float)((float)(v29 + a8) * 0.5) + v49;
        float v56 = v40 + 6.28318531;
        if (v40 >= v38) {
          float v56 = v40;
        }
      }
      else
      {
        if (!v16)
        {
          float v48 = -v48;
          float v49 = -v49;
          float v57 = v40 + 3.14159265;
          float v58 = v38 + 3.14159265;
          if (v57 >= 6.28318531)
          {
            float v59 = v57 + -6.28318531;
            float v38 = v59;
          }
          else
          {
            float v38 = v40 + 3.14159265;
          }
          if (v58 >= 6.28318531)
          {
            float v60 = v58 + -6.28318531;
            float v40 = v60;
          }
          else
          {
            float v40 = v58;
          }
        }
        float v54 = (float)((float)(v28 + a7) * 0.5) + v48;
        float v55 = (float)((float)(v29 + a8) * 0.5) + v49;
        float v56 = v40 + -6.28318531;
        if (v40 <= v38) {
          float v56 = v40;
        }
      }
      __float2 v61 = __sincosf_stret((float)(v38 * v71) + (float)(v56 * (float)(1.0 - v71)));
      *a2 = (float)(v54 + (float)((float)(v14 * v23.__cosval) * v61.__cosval))
          - (float)((float)(v72 * v23.__sinval) * v61.__sinval);
      a2[1] = (float)(v55 + (float)((float)(v14 * v23.__sinval) * v61.__cosval))
            + (float)((float)(v72 * v23.__cosval) * v61.__sinval);
      float v62 = (float)((float)(v72 * v23.__sinval) * v61.__cosval) + (float)((float)(v14 * v23.__cosval) * v61.__sinval);
      float v63 = (float)((float)(v14 * v23.__sinval) * v61.__sinval) - (float)((float)(v72 * v23.__cosval) * v61.__cosval);
      *(float *)a3 = v62;
      *(float *)(a3 + 4) = v63;
      float v64 = sqrtf((float)(v63 * v63) + (float)(v62 * v62));
      *a4 = v64;
      *a5 = (float)(v64
                  * (float)((float)(*(float *)(a3 + 4) * *(float *)(a3 + 4)) + (float)(*(float *)a3 * *(float *)a3)))
          / (float)((float)(*(float *)a3
                          * (float)((float)((float)(v14 * v70) * v61.__cosval)
                                  - (float)((float)(v72 * v23.__cosval) * v61.__sinval)))
                  - (float)(*(float *)(a3 + 4)
                          * (float)((float)((float)(v72 * v23.__sinval) * v61.__sinval)
                                  + (float)((float)-(float)(v23.__cosval * v14) * v61.__cosval))));
      float v65 = *(float *)(a3 + 4);
      *(float *)a3 = *(float *)a3 / *a4;
      *(float *)(a3 + 4) = v65 / *a4;
    }
  }
}

float32x2_t *Path::TangentOnBezAt(float32x2_t *result, uint64_t a2, int a3, float32x2_t *a4, uint64_t a5, float *a6, float *a7, float a8, float32x2_t a9, float32_t a10)
{
  a9.f32[1] = a10;
  float32x2_t v10 = *(float32x2_t *)(a2 + 4);
  float32x2_t v11 = *result;
  *(void *)a5 = 0;
  *a7 = 0.0;
  float32x2_t v12 = vmla_f32(vadd_f32(v10, a9), (float32x2_t)0xC0000000C0000000, v11);
  float32x2_t v13 = vmla_f32(vmul_f32(a9, (float32x2_t)0xC0000000C0000000), (float32x2_t)0x4000000040000000, v11);
  *a4 = vadd_f32(vmla_n_f32(vmul_n_f32(v13, a8), vmul_n_f32(v12, a8), a8), a9);
  float v14 = v12.f32[0] + v12.f32[0];
  float v15 = v13.f32[0] + (float)((float)(v12.f32[0] + v12.f32[0]) * a8);
  float v16 = v12.f32[1] + v12.f32[1];
  float v17 = v13.f32[1] + (float)((float)(v12.f32[1] + v12.f32[1]) * a8);
  float v18 = (float)(v17 * v17) + (float)(v15 * v15);
  float v19 = sqrtf(v18);
  if (v19 > 0.0001)
  {
    *a6 = v19;
    *a7 = (float)-(float)(v19 * v18) / (float)((float)(v15 * v16) - (float)(v17 * v14));
    *(float *)a5 = v15 / v19;
    float v20 = v17 / v19;
LABEL_6:
    *(float *)(a5 + 4) = v20;
    return result;
  }
  *a6 = 0.0;
  float v21 = sqrtf((float)(v16 * v16) + (float)(v14 * v14));
  if (v21 > 0.0001)
  {
    *a7 = 100000000.0;
    float v22 = v14 / v21;
    float v23 = v16 / v21;
    *(float *)a5 = v22;
    *(float *)(a5 + 4) = v23;
    if (a3)
    {
      *(float *)a5 = -v22;
      float v20 = -v23;
      goto LABEL_6;
    }
  }
  return result;
}

uint64_t Path::RecStdCubicTo(long long *a1, int a2, float a3, double a4)
{
  float v5 = *(float *)&a4;
  float v63 = 0.0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  long long v51 = *(long long *)((char *)a1 + 40);
  *(void *)&long long v52 = *((void *)a1 + 7);
  __int32 v8 = *((_DWORD *)a1 + 8);
  float32_t v9 = *((float32_t *)a1 + 9);
  LODWORD(a4) = v8;
  Path::TangentOnCubAt((float32x2_t *)&v51, 0, &v69, (uint64_t)&v66, (float *)&v61, &v63, 0.0, *(float32x2_t *)&a4, v9);
  v10.i32[0] = v8;
  Path::TangentOnCubAt((float32x2_t *)&v51, 0, &v68, (uint64_t)&v64, (float *)&v60 + 1, &v62, 0.5, v10, v9);
  float v11 = 1.0;
  v12.i32[0] = v8;
  Path::TangentOnCubAt((float32x2_t *)&v51, 1, &v67, (uint64_t)&v65, (float *)&v60, (float *)&v61 + 1, 1.0, v12, v9);
  double v14 = fabsf(v63);
  BOOL v13 = v14 <= 0.01;
  LODWORD(v14) = 1.0;
  if (!v13) {
    *(float *)&double v14 = (float)(v5 / v63) + 1.0;
  }
  if (fabsf(*((float *)&v61 + 1)) > 0.01) {
    float v11 = (float)(v5 / *((float *)&v61 + 1)) + 1.0;
  }
  float v15 = -v65.f32[1];
  float v16 = *(float *)&v61;
  float v17 = *(float *)&v14 * *(float *)&v61;
  float v18 = v11 * *(float *)&v60;
  if (a2 <= 0)
  {
    float v33 = (Path *)*((void *)a1 + 3);
    float v34 = v67.f32[0] + (float)(v5 * v15);
    float v35 = vmlas_n_f32(v67.f32[1], v5, v65.f32[0]);
    float v36 = v17 * v66.f32[0];
    float v37 = v66.f32[1] * v17;
    float v38 = v18 * v65.f32[0];
    float v39 = v65.f32[1] * v18;
  }
  else
  {
    unsigned int v46 = v60;
    __int32 v48 = v68.i32[0];
    float v49 = v68.f32[0] + (float)(v5 * (float)-v64.f32[1]);
    float v19 = v67.f32[0] + (float)(v5 * v15);
    *(float *)&double v14 = v69.f32[0] + (float)(v5 * (float)-v66.f32[1]);
    __int32 v47 = v68.i32[1];
    float v20 = vmlas_n_f32(v68.f32[1], v5, v64.f32[0]);
    float v21 = vmlas_n_f32(v67.f32[1], v5, v65.f32[0]);
    *(float *)&long long v51 = v19;
    *((float *)&v51 + 1) = v21;
    float32x2_t v42 = vmul_n_f32(v66, v17);
    float32x2_t v43 = v65;
    *((float32x2_t *)&v51 + 1) = v42;
    *(float32x2_t *)&long long v52 = vmul_n_f32(v65, v18);
    uint64_t v44 = v52;
    float32x2_t v45 = v64;
    float32x2_t v41 = v66;
    Path::TangentOnCubAt((float32x2_t *)&v51, 0, &v59, (uint64_t)v56, &v58, &v57, 0.5, *(float32x2_t *)&v14, vmlas_n_f32(v69.f32[1], v5, v66.f32[0]));
    if ((float)((float)((float)(v20 - v59.f32[1]) * (float)(v20 - v59.f32[1]))
               + (float)((float)(v49 - v59.f32[0]) * (float)(v49 - v59.f32[0]))) > (float)(a3 * a3))
    {
      long long v22 = a1[1];
      long long v51 = *a1;
      long long v52 = v22;
      float32x4_t v23 = (float32x4_t)a1[3];
      long long v53 = a1[2];
      float32x4_t v54 = v23;
      uint64_t v55 = *((void *)a1 + 8);
      v23.f32[0] = (float)(*((float *)a1 + 3) + *((float *)a1 + 4)) * 0.5;
      HIDWORD(v51) = *((_DWORD *)a1 + 3);
      LODWORD(v52) = v23.i32[0];
      *(void *)&long long v53 = __PAIR64__(LODWORD(v9), v8);
      *((void *)&v53 + 1) = __PAIR64__(v47, v48);
      uint64_t v24 = (a2 - 1);
      __asm { FMOV            V4.2D, #0.5 }
      float64x2_t v30 = vmulq_f64(vcvtq_f64_f32((float32x2_t)__PAIR64__(v46, HIDWORD(v60))), _Q4);
      *(float32x2_t *)v54.f32 = vcvt_f32_f64(vmulq_n_f64(vcvtq_f64_f32(v41), v16 * 0.5));
      *(float32x2_t *)&v54.u32[2] = vcvt_f32_f64(vmulq_n_f64(vcvtq_f64_f32(v45), v30.f64[0]));
      float32x4_t v50 = vcvt_hight_f32_f64(*(int32x2_t *)&v54.u32[2], vmulq_laneq_f64(vcvtq_f64_f32(v43), v30, 1));
      Path::RecStdCubicTo(&v51, v24, a3, v5);
      float v31 = *((float *)a1 + 4);
      *((float *)&v51 + 3) = (float)(*((float *)a1 + 3) + v31) * 0.5;
      *(float *)&long long v52 = v31;
      *(void *)&long long v53 = __PAIR64__(v47, v48);
      *((void *)&v53 + 1) = *((void *)a1 + 5);
      float32x4_t v54 = v50;
      return Path::RecStdCubicTo(&v51, v24, a3, v5);
    }
    float v33 = (Path *)*((void *)a1 + 3);
    float v37 = v42.f32[1];
    float v36 = v42.f32[0];
    float v39 = *((float *)&v44 + 1);
    float v38 = *(float *)&v44;
    float v34 = v19;
    float v35 = v21;
  }
  uint64_t result = Path::CubicTo(v33, v34, v35, v36, v37, v38, v39);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v40 = *(void *)(*((void *)a1 + 3) + 16) + 44 * result;
    *(_DWORD *)(v40 + 4) = *((_DWORD *)a1 + 2);
    *(void *)(v40 + 8) = *(void *)((char *)a1 + 12);
  }
  return result;
}

void Path::RecStdArcTo(long long *a1, int a2, float a3, float a4)
{
  float v74 = 0.0;
  uint64_t v71 = 0;
  uint64_t v72 = 0;
  float v56 = *((float *)a1 + 11);
  float v58 = *((float *)a1 + 10);
  *(void *)&long long v60 = __PAIR64__(LODWORD(v56), LODWORD(v58));
  float v52 = *((float *)a1 + 13);
  float v54 = *((float *)a1 + 12);
  *((void *)&v60 + 1) = __PAIR64__(LODWORD(v52), LODWORD(v54));
  float v7 = *((float *)a1 + 14);
  *(float *)&long long v61 = v7;
  int v8 = *((unsigned __int8 *)a1 + 60);
  BYTE5(v61) = *((unsigned char *)a1 + 60);
  int v9 = *((unsigned __int8 *)a1 + 61);
  BYTE4(v61) = *((unsigned char *)a1 + 61);
  float v10 = *((float *)a1 + 16);
  float v12 = *((float *)a1 + 8);
  float v11 = *((float *)a1 + 9);
  Path::TangentOnArcAt((uint64_t)&v60, v82, (uint64_t)v78, (float *)&v72, &v74, v10, v12, v11);
  float v13 = *((float *)a1 + 17);
  Path::TangentOnArcAt((uint64_t)&v60, v81, (uint64_t)v75, (float *)&v71 + 1, &v73, (float)(v10 + v13) * 0.5, v12, v11);
  Path::TangentOnArcAt((uint64_t)&v60, &v79, (uint64_t)&v76, (float *)&v71, (float *)&v72 + 1, v13, v12, v11);
  float v15 = v77;
  float v49 = *(float *)&v78[1];
  float v51 = *(float *)v78;
  float v16 = v76;
  float v44 = *(float *)&v75[1];
  float v45 = *(float *)v75;
  float v47 = -v77;
  float v17 = (float)(a4 / v74) + 1.0;
  if (fabsf(v74) <= 0.01) {
    float v17 = 1.0;
  }
  float v18 = (float)(a4 / *((float *)&v72 + 1)) + 1.0;
  if (fabsf(*((float *)&v72 + 1)) <= 0.01) {
    float v18 = 1.0;
  }
  float v19 = v17 * *(float *)&v72;
  float v20 = v18 * *(float *)&v71;
  uint64_t v70 = 0;
  Path::ArcAngles((Path *)(v9 != 0), v12, v11, v58, v56, v54, v52, v7, v8 == 0, (float *)&v70 + 1, (float *)&v70, v14);
  float v21 = *(float *)&v70 - *((float *)&v70 + 1);
  if ((float)(*(float *)&v70 - *((float *)&v70 + 1)) < 0.0)
  {
    float v22 = (float)(*(float *)&v70 - *((float *)&v70 + 1)) + 6.28318531;
    float v21 = v22;
  }
  double v23 = v21;
  if (v21 > 6.28318531)
  {
    float v24 = v21 + -6.28318531;
    float v21 = v24;
  }
  float v25 = *((float *)a1 + 16);
  float v26 = *((float *)a1 + 17);
  float v27 = (float)(v26 - v25) * v21;
  if (a2 <= 0)
  {
    float v35 = (Path *)*((void *)a1 + 3);
    float v36 = v79 + (float)(a4 * v47);
    float v37 = v80 + (float)(a4 * v16);
    float v38 = (float)(v51 * v19) * v27;
    float v39 = (float)(v49 * v19) * v27;
    float v40 = (float)(v16 * v20) * v27;
    float v41 = (float)(v15 * v20) * v27;
  }
  else
  {
    float v28 = -v49;
    float v57 = v81[1] + (float)(a4 * v45);
    float v59 = v81[0] + (float)(a4 * (float)-v44);
    float v53 = v79 + (float)(a4 * v47);
    float v55 = v80 + (float)(a4 * v16);
    *(float *)&long long v60 = v53;
    *((float *)&v60 + 1) = v55;
    float v48 = (float)(v49 * v19) * v27;
    float v50 = (float)(v51 * v19) * v27;
    *((float *)&v60 + 2) = v50;
    *((float *)&v60 + 3) = v48;
    float v29 = (float)(v16 * v20) * v27;
    float v30 = (float)(v15 * v20) * v27;
    *(float *)&long long v61 = v29;
    *((float *)&v61 + 1) = v30;
    *(float *)&double v23 = v82[0] + (float)(a4 * v28);
    Path::TangentOnCubAt((float32x2_t *)&v60, 0, &v69, (uint64_t)v66, &v68, &v67, 0.5, *(float32x2_t *)&v23, v82[1] + (float)(a4 * v51));
    if ((float)((float)((float)(v57 - v69.f32[1]) * (float)(v57 - v69.f32[1]))
               + (float)((float)(v59 - v69.f32[0]) * (float)(v59 - v69.f32[0]))) > (float)(a3 * a3))
    {
      long long v31 = a1[1];
      long long v60 = *a1;
      long long v61 = v31;
      long long v32 = a1[3];
      long long v62 = a1[2];
      long long v63 = v32;
      float v64 = v25;
      float v65 = (float)(v26 + v25) * 0.5;
      uint64_t v33 = (a2 - 1);
      Path::RecStdArcTo(&v60, v33, a3, a4);
      float v34 = *((float *)a1 + 17);
      float v64 = (float)(*((float *)a1 + 16) + v34) * 0.5;
      float v65 = v34;
      Path::RecStdArcTo(&v60, v33, a3, a4);
      return;
    }
    float v35 = (Path *)*((void *)a1 + 3);
    float v36 = v53;
    float v37 = v55;
    float v39 = v48;
    float v38 = v50;
    float v40 = v29;
    float v41 = v30;
  }
  unsigned int v42 = Path::CubicTo(v35, v36, v37, v38, v39, v40, v41);
  if ((v42 & 0x80000000) == 0)
  {
    float32x2_t v43 = (_DWORD *)(*(void *)(*((void *)a1 + 3) + 16) + 44 * v42);
    v43[1] = *((_DWORD *)a1 + 2);
    v43[2] = *((_DWORD *)a1 + 16);
    v43[3] = *((_DWORD *)a1 + 17);
  }
}

void Path::Simplify(Path *this, float a2)
{
  if (this->var8 >= 2)
  {
    Path::Reset(this);
    var11 = this->var11;
    uint64_t var8 = this->var8;
    if ((int)var8 >= 1)
    {
      int v6 = 0;
      do
      {
        int v7 = v6 + 1;
        if (this->var7)
        {
          if (this->var6)
          {
            if (v7 < (int)var8)
            {
              uint64_t v8 = v7;
              int v9 = &var11[24 * v7];
              while (1)
              {
                int v10 = *(_DWORD *)v9;
                v9 += 24;
                if ((v10 | 2) != 2) {
                  break;
                }
                if (var8 == ++v8)
                {
                  int v7 = var8;
                  goto LABEL_28;
                }
              }
              int v7 = v8;
            }
LABEL_28:
            float v20 = &var11[24 * v6];
          }
          else
          {
            if (v7 < (int)var8)
            {
              uint64_t v14 = v7;
              float v15 = &var11[20 * v7];
              while (1)
              {
                int v16 = *(_DWORD *)v15;
                v15 += 20;
                if ((v16 | 2) != 2) {
                  break;
                }
                if (var8 == ++v14)
                {
                  int v7 = var8;
                  goto LABEL_32;
                }
              }
              int v7 = v14;
            }
LABEL_32:
            float v20 = &var11[20 * v6];
          }
        }
        else if (this->var6)
        {
          if (v7 < (int)var8)
          {
            uint64_t v11 = v7;
            float v12 = &var11[16 * v7];
            while (1)
            {
              int v13 = *(_DWORD *)v12;
              v12 += 16;
              if ((v13 | 2) != 2) {
                break;
              }
              if (var8 == ++v11)
              {
                int v7 = var8;
                goto LABEL_30;
              }
            }
            int v7 = v11;
          }
LABEL_30:
          float v20 = &var11[16 * v6];
        }
        else
        {
          if (v7 < (int)var8)
          {
            uint64_t v17 = v7;
            float v18 = &var11[12 * v7];
            while (1)
            {
              int v19 = *(_DWORD *)v18;
              v18 += 12;
              if ((v19 | 2) != 2) {
                break;
              }
              if (var8 == ++v17)
              {
                int v7 = var8;
                goto LABEL_34;
              }
            }
            int v7 = v17;
          }
LABEL_34:
          float v20 = &var11[12 * v6];
        }
        this->var11 = v20;
        this->uint64_t var8 = v7 - v6;
        Path::DoSimplify(this, a2);
        int v6 = v7;
      }
      while (v7 < (int)var8);
    }
    this->var11 = var11;
    this->uint64_t var8 = var8;
  }
}

Path *Path::DoSimplify(Path *this, float a2)
{
  uint64_t var8 = this->var8;
  if ((int)var8 >= 2)
  {
    uint64_t v4 = this;
    var11 = this->var11;
    float v7 = *((float *)var11 + 1);
    float v6 = *((float *)var11 + 2);
    Path::MoveTo(this, v7, v6);
    int v8 = 0;
    do
    {
      v4->uint64_t var8 = 2;
      if (v4->var7)
      {
        int v9 = &var11[20 * v8];
        int v10 = &var11[24 * v8];
      }
      else
      {
        int v9 = &var11[12 * v8];
        int v10 = &var11[16 * v8];
      }
      if (v4->var6) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = v9;
      }
      uint64_t v12 = (v8 + 1);
      v4->var11 = v11;
      uint64_t v13 = (int)v12;
      uint64_t v14 = v12 << 32;
      float v15 = &var11[12 * (int)v12];
      uint64_t v16 = (int)v12 + 1;
      while (1)
      {
        uint64_t v17 = v13;
        uint64_t v18 = v14;
        BOOL var7 = v4->var7;
        if (v4->var7) {
          float v20 = v4->var6 ? &var11[24 * v13] : &var11[20 * v13];
        }
        else {
          float v20 = v4->var6 ? &var11[16 * v13] : v15;
        }
        int v21 = *(_DWORD *)v20;
        int v22 = v4->var8 + 1;
        v4->uint64_t var8 = v22;
        if (v21 == 2 || v16 >= var8) {
          break;
        }
        char v24 = Path::AttemptSimplify((uint64_t)v4, v43, a2);
        uint64_t v14 = v18 + 0x100000000;
        uint64_t v13 = v17 + 1;
        v15 += 12;
        ++v16;
        if ((v24 & 1) == 0)
        {
          int v22 = v4->var8;
          BOOL var7 = v4->var7;
          break;
        }
      }
      v4->uint64_t var8 = v22 - 1;
      float v25 = &var11[12 * SHIDWORD(v18)];
      float v26 = (float *)(v25 + 4);
      float v27 = (float *)(v25 + 8);
      float v28 = &var11[16 * (v18 >> 32)];
      float v29 = (float *)(v28 + 4);
      float v30 = (float *)(v28 + 8);
      if (v4->var6)
      {
        float v26 = v29;
        float v27 = v30;
      }
      long long v31 = &var11[20 * SHIDWORD(v18)];
      long long v32 = (float *)(v31 + 4);
      uint64_t v33 = (float *)(v31 + 8);
      float v34 = &var11[24 * SHIDWORD(v18)];
      float v35 = (float *)(v34 + 4);
      float v36 = (float *)(v34 + 8);
      if (v4->var6) {
        float v37 = v35;
      }
      else {
        float v37 = v32;
      }
      if (!v4->var6) {
        float v36 = v33;
      }
      BOOL v38 = !var7;
      if (var7) {
        float v39 = v37;
      }
      else {
        float v39 = v26;
      }
      if (v38) {
        float v40 = v27;
      }
      else {
        float v40 = v36;
      }
      float v41 = *v40;
      float v42 = *v39;
      if (v22 > 3) {
        this = (Path *)Path::CubicTo(v4, *v39, *v40, v43[2], v43[3], v43[4], v43[5]);
      }
      else {
        this = (Path *)Path::LineTo(v4, *v39, *v40);
      }
      int v8 = v17;
    }
    while ((int)var8 - 1 > (int)v17);
    if (vabds_f32(v42, v7) < 0.00001 && vabds_f32(v41, v6) < 0.00001) {
      this = (Path *)Path::Close(v4);
    }
    v4->var11 = var11;
    v4->uint64_t var8 = var8;
  }
  return this;
}

uint64_t Path::AttemptSimplify(uint64_t a1, float *a2, float a3)
{
  uint64_t v3 = *(int *)(a1 + 36);
  if (v3 == 2) {
    return 1;
  }
  int v6 = *(unsigned __int8 *)(a1 + 33);
  int v7 = *(unsigned __int8 *)(a1 + 32);
  int v8 = *(float **)(a1 + 48);
  uint64_t v9 = v3 - 1;
  int v10 = v8 + 4;
  uint64_t v11 = v8 + 5;
  uint64_t v12 = &v8[3 * v3 - 3];
  uint64_t v13 = v12 + 1;
  uint64_t v14 = v12 + 2;
  float v15 = &v8[4 * v3 - 4];
  uint64_t v16 = v15 + 1;
  uint64_t v17 = v15 + 2;
  if (v7)
  {
    int v10 = v8 + 5;
    uint64_t v11 = v8 + 6;
    uint64_t v13 = v16;
    uint64_t v14 = v17;
  }
  uint64_t v18 = &v8[5 * v9];
  int v19 = v18 + 1;
  float v20 = v18 + 2;
  int v21 = &v8[6 * v9];
  int v22 = v21 + 1;
  double v23 = v21 + 2;
  BOOL v24 = v7 == 0;
  if (v7) {
    float v25 = v8 + 7;
  }
  else {
    float v25 = v8 + 6;
  }
  if (v24) {
    float v26 = v8 + 7;
  }
  else {
    float v26 = v8 + 8;
  }
  if (v24) {
    float v27 = v19;
  }
  else {
    float v27 = v22;
  }
  if (v24) {
    double v23 = v20;
  }
  BOOL v28 = v6 == 0;
  if (v6) {
    float v29 = v25;
  }
  else {
    float v29 = v10;
  }
  if (v28) {
    float v30 = v11;
  }
  else {
    float v30 = v26;
  }
  if (v28) {
    long long v31 = v13;
  }
  else {
    long long v31 = v27;
  }
  if (v28) {
    double v23 = v14;
  }
  float v33 = v8[1];
  float v32 = v8[2];
  float v34 = *v23;
  float v35 = *v31;
  if (v3 == 3)
  {
    float v36 = *v30;
    float v37 = *v29;
    *a2 = v35;
    a2[1] = v34;
    a2[2] = v37 - v33;
    a2[3] = v36 - v32;
    a2[4] = v35 - v37;
    a2[5] = v34 - v36;
    return 1;
  }
  float v40 = (double *)malloc_type_malloc(8 * v3, 0x100004000313F17uLL);
  float v41 = (double *)malloc_type_malloc(8 * *(int *)(a1 + 36), 0x100004000313F17uLL);
  float v42 = (double *)malloc_type_malloc(8 * *(int *)(a1 + 36), 0x100004000313F17uLL);
  float32x2_t v43 = (double *)malloc_type_malloc(8 * *(int *)(a1 + 36), 0x100004000313F17uLL);
  *float v40 = 0.0;
  uint64_t v44 = *(unsigned int *)(a1 + 36);
  if ((int)v44 >= 2)
  {
    unint64_t v45 = 0;
    int v46 = *(unsigned __int8 *)(a1 + 33);
    float v47 = *(float **)(a1 + 48);
    float v48 = v42 + 1;
    float v49 = v47 + 5;
    int v50 = *(unsigned __int8 *)(a1 + 32);
    float v51 = v47 + 8;
    float v52 = v47 + 7;
    float v53 = v47 + 6;
    float v54 = v32;
    float v55 = v33;
    do
    {
      if (v46)
      {
        if (v50)
        {
          v48[v45 / 8] = *(v51 - 1);
          float v56 = *v51;
        }
        else
        {
          v48[v45 / 8] = *(v52 - 1);
          float v56 = *v52;
        }
      }
      else if (v50)
      {
        v48[v45 / 8] = *(v53 - 1);
        float v56 = *v53;
      }
      else
      {
        v48[v45 / 8] = *(v49 - 1);
        float v56 = *v49;
      }
      double v57 = v56;
      v43[v45 / 8 + 1] = v57;
      double v58 = v48[v45 / 8];
      float v59 = v58 - v55;
      float v60 = v57 - v54;
      float v55 = v58;
      float v54 = v57;
      long long v61 = &v40[v45 / 8];
      double v62 = v40[v45 / 8];
      v45 += 8;
      v49 += 3;
      v61[1] = v62 + sqrtf((float)(v60 * v60) + (float)(v59 * v59));
      v51 += 6;
      v52 += 5;
      v53 += 4;
    }
    while (8 * v44 - 8 != v45);
  }
  if (v40[(int)v44 - 1] < 0.00001) {
    goto LABEL_69;
  }
  uint64_t v63 = (int)v44 - 1;
  double v64 = 0.0;
  double v65 = 0.0;
  double v66 = 0.0;
  double v67 = 0.0;
  if ((int)v44 >= 3)
  {
    float v68 = v40 + 1;
    uint64_t v69 = (v44 - 1) - 1;
    uint64_t v70 = v69;
    do
    {
      *float v68 = *v68 / v40[v63];
      ++v68;
      --v70;
    }
    while (v70);
    uint64_t v71 = v40 + 1;
    double v67 = 0.0;
    double v66 = 0.0;
    double v65 = 0.0;
    double v64 = 0.0;
    do
    {
      double v72 = *v71++;
      double v73 = (1.0 - v72) * (v72 * 3.0 * (1.0 - v72));
      double v64 = v64 + v73 * v73;
      double v74 = (1.0 - v72) * (v72 * (v72 * 3.0));
      double v65 = v65 + v74 * v73;
      double v66 = v66 + v73 * v74;
      double v67 = v67 + v74 * v74;
      --v69;
    }
    while (v69);
  }
  double v75 = v64 * v67 - v65 * v66;
  if (fabs(v75) < 0.000001) {
    goto LABEL_69;
  }
  double v76 = -v66;
  double v77 = v67 / v75;
  double v78 = -v65 / v75;
  double v79 = v33;
  *float v42 = v33;
  double v80 = v32;
  *float32x2_t v43 = v32;
  double v81 = v35;
  v42[v63] = v35;
  double v82 = v34;
  v43[v63] = v34;
  double v83 = v76 / v75;
  double v84 = 0.0;
  double v85 = 0.0;
  double v86 = v64 / v75;
  double v87 = 0.0;
  if ((int)v44 >= 3)
  {
    uint64_t v88 = 1;
    do
    {
      double v89 = v40[v88];
      v41[v88] = v42[v88] + (1.0 - v89) * -((1.0 - v89) * (1.0 - v89)) * *v42 + v89 * -(v89 * v89) * v42[v63];
      ++v88;
    }
    while ((v44 - 1) != v88);
    uint64_t v90 = v41 + 1;
    unsigned __int32 v91 = v40 + 1;
    uint64_t v92 = (v44 - 1) - 1;
    double v87 = 0.0;
    double v85 = 0.0;
    do
    {
      double v93 = *v91++;
      double v94 = v93;
      double v95 = v93 * 3.0;
      double v96 = 1.0 - v93;
      double v97 = v93 * 3.0 * (1.0 - v93);
      double v98 = *v90++;
      double v85 = v85 + v96 * v97 * v98;
      double v87 = v87 + v96 * (v94 * v95) * v98;
      --v92;
    }
    while (v92);
  }
  double v99 = v78 * v87 + v77 * v85;
  double v100 = v86 * v87 + v83 * v85;
  double v101 = 0.0;
  if ((int)v44 >= 3)
  {
    uint64_t v102 = 1;
    do
    {
      double v103 = v40[v102];
      v41[v102] = v43[v102] + (1.0 - v103) * -((1.0 - v103) * (1.0 - v103)) * *v43 + v103 * -(v103 * v103) * v43[v63];
      ++v102;
    }
    while ((v44 - 1) != v102);
    float v104 = v41 + 1;
    float v105 = v40 + 1;
    uint64_t v106 = (v44 - 1) - 1;
    double v101 = 0.0;
    double v84 = 0.0;
    do
    {
      double v107 = *v105++;
      double v108 = v107;
      double v109 = v107 * 3.0;
      double v110 = 1.0 - v107;
      double v111 = v107 * 3.0 * (1.0 - v107);
      double v112 = *v104++;
      double v84 = v84 + v110 * v111 * v112;
      double v101 = v101 + v110 * (v108 * v109) * v112;
      --v106;
    }
    while (v106);
  }
  float v218 = v32;
  float v113 = v99;
  float v114 = v100;
  float v115 = v78 * v101 + v77 * v84;
  float v116 = v86 * v101 + v83 * v84;
  float v117 = 0.0;
  if ((int)v44 >= 3)
  {
    float v118 = v43 + 1;
    float v119 = v42 + 1;
    float v120 = v40 + 1;
    uint64_t v121 = (v44 - 1) - 1;
    do
    {
      double v122 = *v120++;
      double v123 = v122;
      double v124 = 1.0 - v122;
      double v125 = (1.0 - v122) * (v122 * 3.0 * (1.0 - v122));
      double v126 = (1.0 - v122) * (v122 * (v122 * 3.0));
      float v127 = v126 * v114 + v125 * v113;
      double v128 = *v119++;
      double v129 = v124 * -(v124 * v124);
      *(float *)&double v126 = v126 * v116 + v125 * v115;
      double v130 = v123 * -(v123 * v123);
      double v131 = v127 - (v128 + v129 * *v42 + v130 * v42[v63]);
      double v132 = *v118++;
      double v133 = v132 + v129 * *v43 + v130 * v43[v63];
      *(float *)&double v129 = v131;
      *(float *)&double v133 = *(float *)&v126 - v133;
      float v117 = v117 + (float)((float)(*(float *)&v133 * *(float *)&v133) + (float)(*(float *)&v129 * *(float *)&v129));
      --v121;
    }
    while (v121);
  }
  if (v117 >= (float)(a3 * a3))
  {
LABEL_69:
    free(v40);
    free(v41);
    free(v42);
    free(v43);
  }
  else
  {
    a2[2] = (float)(v113 - v33) * 3.0;
    a2[3] = (float)(v115 - v218) * 3.0;
    a2[4] = (float)(v114 - v35) * -3.0;
    a2[5] = (float)(v116 - v34) * -3.0;
    *a2 = v35;
    a2[1] = v34;
    double v134 = 0.0;
    double v135 = 0.0;
    double v136 = 0.0;
    double v137 = 0.0;
    float v219 = v33;
    if ((int)v44 >= 3)
    {
      double v214 = v80;
      double v215 = v33;
      int v216 = v44;
      v217 = a2;
      float v138 = v40 + 1;
      double v139 = *v40;
      float v140 = v43 + 1;
      float v141 = v42 + 1;
      uint64_t v142 = (v44 - 1) - 1;
      uint64_t v143 = v142;
      do
      {
        double v144 = *v141++;
        float v145 = v144;
        double v146 = *v140++;
        float v147 = v146;
        float v148 = *v138;
        float v149 = v115;
        float v150 = v116;
        float v151 = v113;
        float v152 = Path::RaffineTk(v145, v147, v219, v218, v113, v115, v114, v116, v35, v34, v148);
        float v113 = v151;
        float v116 = v150;
        float v115 = v149;
        double v153 = v152;
        if (v139 <= v153) {
          double v139 = v153;
        }
        *v138++ = v139;
        --v143;
      }
      while (v143);
      unsigned int v154 = v40 + 1;
      double v137 = 0.0;
      double v136 = 0.0;
      double v135 = 0.0;
      double v134 = 0.0;
      LODWORD(v44) = v216;
      a2 = v217;
      double v79 = v215;
      double v81 = v35;
      double v80 = v214;
      double v82 = v34;
      do
      {
        double v155 = *v154++;
        double v156 = (1.0 - v155) * (v155 * 3.0 * (1.0 - v155));
        double v134 = v134 + v156 * v156;
        double v157 = (1.0 - v155) * (v155 * (v155 * 3.0));
        double v135 = v135 + v157 * v156;
        double v136 = v136 + v156 * v157;
        double v137 = v137 + v157 * v157;
        --v142;
      }
      while (v142);
    }
    double v158 = v134 * v137 - v135 * v136;
    if (fabs(v158) < 0.000001)
    {
      free(v40);
      free(v41);
      free(v42);
      free(v43);
      return 1;
    }
    double v159 = -v136;
    double v160 = v137 / v158;
    double v161 = -v135 / v158;
    *float v42 = v79;
    *float32x2_t v43 = v80;
    v42[v63] = v81;
    v43[v63] = v82;
    double v162 = v159 / v158;
    double v163 = 0.0;
    double v164 = 0.0;
    double v165 = 0.0;
    double v166 = v134 / v158;
    if ((int)v44 >= 3)
    {
      uint64_t v167 = 1;
      do
      {
        double v168 = v40[v167];
        v41[v167] = v42[v167] + (1.0 - v168) * -((1.0 - v168) * (1.0 - v168)) * *v42 + v168 * -(v168 * v168) * v42[v63];
        ++v167;
      }
      while (v63 != v167);
      v169 = v41 + 1;
      int v170 = v40 + 1;
      uint64_t v171 = v63 - 1;
      double v165 = 0.0;
      double v164 = 0.0;
      do
      {
        double v172 = *v170++;
        double v173 = v172;
        double v174 = v172 * 3.0;
        double v175 = 1.0 - v172;
        double v176 = v172 * 3.0 * (1.0 - v172);
        double v177 = *v169++;
        double v164 = v164 + v175 * v176 * v177;
        double v165 = v165 + v175 * (v173 * v174) * v177;
        --v171;
      }
      while (v171);
    }
    double v178 = v161 * v165 + v160 * v164;
    double v179 = v166 * v165 + v162 * v164;
    double v180 = 0.0;
    if ((int)v44 >= 3)
    {
      uint64_t v181 = 1;
      do
      {
        double v182 = v40[v181];
        v41[v181] = v43[v181] + (1.0 - v182) * -((1.0 - v182) * (1.0 - v182)) * *v43 + v182 * -(v182 * v182) * v43[v63];
        ++v181;
      }
      while (v63 != v181);
      __n128 v183 = v41 + 1;
      float32x2_t v184 = v40 + 1;
      uint64_t v185 = v63 - 1;
      double v180 = 0.0;
      double v163 = 0.0;
      do
      {
        double v186 = *v184++;
        double v187 = v186;
        double v188 = v186 * 3.0;
        double v189 = 1.0 - v186;
        double v190 = v186 * 3.0 * (1.0 - v186);
        double v191 = *v183++;
        double v163 = v163 + v189 * v190 * v191;
        double v180 = v180 + v189 * (v187 * v188) * v191;
        --v185;
      }
      while (v185);
    }
    float v192 = v178;
    float v193 = v179;
    float v194 = v161 * v180 + v160 * v163;
    float v195 = v166 * v180 + v162 * v163;
    double v196 = 0.0;
    if ((int)v44 >= 3)
    {
      float v197 = v43 + 1;
      float32x2_t v198 = v42 + 1;
      unint64_t v199 = v40 + 1;
      uint64_t v200 = v63 - 1;
      float v201 = 0.0;
      do
      {
        double v202 = *v199++;
        double v203 = v202;
        double v204 = 1.0 - v202;
        double v205 = (1.0 - v202) * (v202 * 3.0 * (1.0 - v202));
        double v206 = (1.0 - v202) * (v202 * (v202 * 3.0));
        float v207 = v206 * v193 + v205 * v192;
        double v208 = *v198++;
        double v209 = v204 * -(v204 * v204);
        *(float *)&double v206 = v206 * v195 + v205 * v194;
        double v210 = v203 * -(v203 * v203);
        double v211 = v207 - (v208 + v209 * *v42 + v210 * v42[v63]);
        double v212 = *v197++;
        double v213 = v212 + v209 * *v43 + v210 * v43[v63];
        *(float *)&double v209 = v211;
        *(float *)&double v213 = *(float *)&v206 - v213;
        float v201 = v201 + (float)((float)(*(float *)&v213 * *(float *)&v213) + (float)(*(float *)&v209 * *(float *)&v209));
        --v200;
      }
      while (v200);
      double v196 = v201;
    }
    free(v40);
    free(v41);
    free(v42);
    free(v43);
    if (v117 + 0.00001 > v196)
    {
      a2[2] = (float)(v192 - v219) * 3.0;
      a2[3] = (float)(v194 - v218) * 3.0;
      a2[4] = (float)(v193 - v35) * -3.0;
      a2[5] = (float)(v195 - v34) * -3.0;
      *a2 = v35;
      a2[1] = v34;
      return 1;
    }
  }
  return 0;
}

float Path::RaffineTk(float a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9, float a10, float a11)
{
  float result = a11;
  double v21 = 1.0 - a11;
  double v22 = v21 * (v21 * v21);
  double v23 = v21 * (v21 * (float)(a11 * 3.0));
  double v24 = v21 * (float)((float)(a11 * 3.0) * a11);
  float v25 = (float)(result * result) * result;
  double v26 = a1 - a3 * v22 - a5 * v23 - a7 * v24 - (float)(a9 * v25);
  double v27 = v21 * (float)(result + result);
  double v28 = v27 * (float)(a7 - a5) + (float)(a5 - a3) * (v21 * v21) + (float)((float)(a9 - a7) * (float)(result * result));
  double v29 = (float)((float)(a5 + (float)(a9 + (float)(a7 * -2.0))) * a11)
      + (float)((float)(a3 + (float)(a5 * -2.0)) + a7) * v21;
  double v30 = a2 - a4 * v22 - a6 * v23 - a8 * v24 - (float)(a10 * v25);
  double v31 = v27 * (float)(a8 - a6) + (float)(a6 - a4) * (v21 * v21) + (float)((float)(a10 - a8) * (float)(result * result));
  double v32 = (((float)((float)(a6 + (float)(a10 + (float)(a8 * -2.0))) * a11)
        + (float)((float)(a4 + (float)(a6 * -2.0)) + a8) * v21)
       * v30
       + v26 * v29)
      * -12.0
      + (v31 * v31 + v28 * v28) * 18.0;
  if (fabs(v32) > 0.0000001) {
    return (v31 * v30 + v26 * v28) * 6.0 / v32 + a11;
  }
  return result;
}

void Path::Coalesce(Path *this, float a2)
{
  int var0 = this->var0;
  if (this->var0)
  {
    Path::CancelBezier(this);
    int var0 = this->var0;
  }
  if ((var0 & 2) != 0) {
    Path::CloseSubpath(this, 0);
  }
  if (this->var2 >= 3)
  {
    Path::SetWeighted(this, 0);
    Path::SetBackData(this, 0);
    Path::ConvertEvenLines(this, a2);
    if (this->var2 < 1)
    {
      int v17 = 0;
    }
    else
    {
      int v13 = 0;
      int v14 = 0;
      uint64_t v15 = 0;
      int v16 = 0;
      int v17 = 0;
      uint64_t v18 = *((unsigned int *)this->var3 + 1);
      float v19 = a2 * 0.1;
      float v64 = v19;
      do
      {
        var3 = this->var3;
        double v21 = (char *)var3 + 44 * v13;
        int v22 = *(_DWORD *)v21;
        switch(*(_DWORD *)v21 & 0xF)
        {
          case 0:
            if (v14)
            {
              double v28 = (char *)var3 + 44 * v17++;
              *(_DWORD *)double v28 = v14;
              *((_DWORD *)v28 + 1) = v15;
              *((void *)v28 + 1) = v2;
              *((_DWORD *)v28 + 4) = v3;
              *((_DWORD *)v28 + 5) = v4;
              *((_DWORD *)v28 + 6) = v6;
              *((_DWORD *)v28 + 7) = v7;
              *((_DWORD *)v28 + 8) = v8;
              *((_DWORD *)v28 + 9) = v9;
              *((_DWORD *)v28 + 10) = v5;
              var3 = this->var3;
              int v22 = *((_DWORD *)var3 + 11 * v13);
            }
            double v29 = (char *)var3 + 44 * v13;
            uint64_t v15 = *((unsigned int *)v29 + 1);
            uint64_t v2 = *((void *)v29 + 1);
            int v3 = *((_DWORD *)v29 + 4);
            int v4 = *((_DWORD *)v29 + 5);
            int v6 = *((_DWORD *)v29 + 6);
            int v7 = *((_DWORD *)v29 + 7);
            int v8 = *((_DWORD *)v29 + 8);
            int v9 = *((_DWORD *)v29 + 9);
            int v5 = *((_DWORD *)v29 + 10);
            double v30 = (char *)var3 + 44 * v17++;
            *(_DWORD *)double v30 = v22;
            *((_DWORD *)v30 + 1) = v15;
            *((void *)v30 + 1) = v2;
            *((_DWORD *)v30 + 4) = v3;
            *((_DWORD *)v30 + 5) = v4;
            *((_DWORD *)v30 + 6) = v6;
            *((_DWORD *)v30 + 7) = v7;
            *((_DWORD *)v30 + 8) = v8;
            *((_DWORD *)v30 + 9) = v9;
            *((_DWORD *)v30 + 10) = v5;
            uint64_t v18 = *((unsigned int *)this->var3 + 11 * v13 + 1);
            int v16 = v13;
            goto LABEL_16;
          case 1:
          case 2:
          case 4:
            if (v14)
            {
              int v23 = v16;
              int v24 = v15;
              int v25 = *((_DWORD *)var3 + 11 * v13 + 1);
              int var8 = this->var8;
              var11 = this->var11;
              this->var11 = &var11[12 * (int)v18];
              this->int var8 = v25 - v18 + 1;
              uint64_t v26 = v18;
              if (Path::AttemptSimplify((uint64_t)this, (float *)&v68, a2))
              {
                int v4 = v69;
                int v6 = v70;
                int v7 = v71;
                int v8 = v72;
                int v14 = 2;
                double v27 = &v68;
                uint64_t v15 = v26;
                int v9 = v73;
                uint64_t v18 = v26;
              }
              else
              {
                float v56 = this->var3;
                uint64_t v18 = *((unsigned int *)v56 + 11 * v23 + 1);
                double v57 = (char *)v56 + 44 * v17++;
                *(_DWORD *)double v57 = v14;
                *((_DWORD *)v57 + 1) = v24;
                *((void *)v57 + 1) = v2;
                *((_DWORD *)v57 + 4) = v3;
                *((_DWORD *)v57 + 5) = v4;
                *((_DWORD *)v57 + 6) = v6;
                *((_DWORD *)v57 + 7) = v7;
                *((_DWORD *)v57 + 8) = v8;
                *((_DWORD *)v57 + 9) = v9;
                *((_DWORD *)v57 + 10) = v5;
                double v58 = (char *)this->var3 + 44 * v13;
                int v14 = *(_DWORD *)v58;
                uint64_t v15 = *((unsigned int *)v58 + 1);
                uint64_t v2 = *((void *)v58 + 1);
                double v27 = (int *)(v58 + 16);
                int v4 = *((_DWORD *)v58 + 5);
                int v6 = *((_DWORD *)v58 + 6);
                int v7 = *((_DWORD *)v58 + 7);
                int v8 = *((_DWORD *)v58 + 8);
                int v9 = *((_DWORD *)v58 + 9);
                int v5 = *((_DWORD *)v58 + 10);
              }
              int v3 = *v27;
              this->var11 = var11;
              int v16 = v13;
              this->int var8 = var8;
            }
            else
            {
              uint64_t v18 = *((unsigned int *)var3 + 11 * v13 - 10);
              uint64_t v15 = *((unsigned int *)v21 + 1);
              uint64_t v2 = *((void *)v21 + 1);
              int v3 = *((_DWORD *)v21 + 4);
              int v4 = *((_DWORD *)v21 + 5);
              int v6 = *((_DWORD *)v21 + 6);
              int v7 = *((_DWORD *)v21 + 7);
              int v8 = *((_DWORD *)v21 + 8);
              int v9 = *((_DWORD *)v21 + 9);
              int v5 = *((_DWORD *)v21 + 10);
LABEL_16:
              int v14 = v22;
            }
            break;
          case 3:
            if (v14)
            {
              double v31 = (char *)var3 + 44 * v17++;
              *(_DWORD *)double v31 = v14;
              *((_DWORD *)v31 + 1) = v15;
              *((void *)v31 + 1) = v2;
              *((_DWORD *)v31 + 4) = v3;
              *((_DWORD *)v31 + 5) = v4;
              *((_DWORD *)v31 + 6) = v6;
              *((_DWORD *)v31 + 7) = v7;
              *((_DWORD *)v31 + 8) = v8;
              *((_DWORD *)v31 + 9) = v9;
              *((_DWORD *)v31 + 10) = v5;
              var3 = this->var3;
            }
            double v32 = (char *)var3 + 44 * v13;
            uint64_t v18 = *((unsigned int *)v32 + 1);
            LODWORD(v33) = *((_DWORD *)v32 + 4);
            if ((int)v33 >= 1)
            {
              uint64_t v34 = 0;
              uint64_t v35 = 44 * v17;
              uint64_t v36 = 44 * v13 + 44;
              do
              {
                float v37 = (long long *)((char *)var3 + v36);
                BOOL v38 = (_OWORD *)((char *)var3 + v35);
                long long v39 = *v37;
                long long v40 = v37[1];
                *(_OWORD *)((char *)v38 + 28) = *(long long *)((char *)v37 + 28);
                *BOOL v38 = v39;
                v38[1] = v40;
                var3 = this->var3;
                uint64_t v33 = *((int *)var3 + 11 * v13 + 4);
                v35 += 44;
                ++v34;
                v36 += 44;
              }
              while (v34 < v33);
              v17 += v34;
            }
            int v14 = 0;
            int v16 = v13;
            v13 += v33;
            break;
          case 5:
            uint64_t v41 = *((unsigned int *)var3 + 11 * v13 + 1);
            if (v14)
            {
              uint64_t v42 = v15;
              float32x2_t v43 = this->var11;
              int v44 = this->var8;
              this->var11 = &v43[12 * (int)v18];
              this->int var8 = v41 - v18 + 1;
              if (Path::AttemptSimplify((uint64_t)this, (float *)&v68, a2))
              {
                int v3 = v68;
                int v4 = v69;
                int v6 = v70;
                int v7 = v71;
                int v14 = 2;
                int v8 = v72;
                int v9 = v73;
              }
              unint64_t v45 = (char *)this->var3 + 44 * v17;
              *(_DWORD *)unint64_t v45 = v14;
              *((_DWORD *)v45 + 1) = v42;
              uint64_t v15 = v42;
              *((void *)v45 + 1) = v2;
              *((_DWORD *)v45 + 4) = v3;
              *((_DWORD *)v45 + 5) = v4;
              *((_DWORD *)v45 + 6) = v6;
              *((_DWORD *)v45 + 7) = v7;
              *((_DWORD *)v45 + 8) = v8;
              *((_DWORD *)v45 + 9) = v9;
              *((_DWORD *)v45 + 10) = v5;
              int v46 = this->var3;
              float v47 = (char *)v46 + 44 * v17++;
              float v48 = (long long *)((char *)v46 + 44 * v13);
              long long v49 = *v48;
              long long v50 = v48[1];
              *(_OWORD *)(v47 + 72) = *(long long *)((char *)v48 + 28);
              *(_OWORD *)(v47 + 60) = v50;
              *(_OWORD *)(v47 + 44) = v49;
              this->var11 = v43;
              this->int var8 = v44;
            }
            else
            {
              float v59 = (_OWORD *)((char *)var3 + 44 * v17);
              long long v60 = *(_OWORD *)v21;
              long long v61 = *((_OWORD *)v21 + 1);
              *(_OWORD *)((char *)v59 + 28) = *(_OWORD *)(v21 + 28);
              *float v59 = v60;
              v59[1] = v61;
            }
            int v14 = 0;
            ++v17;
            uint64_t v18 = v41;
            int v16 = v13;
            break;
          case 7:
            if (v14)
            {
              int v67 = v16;
              uint64_t v51 = v15;
              uint64_t v52 = *((unsigned int *)var3 + 11 * v13 + 1);
              float v53 = this->var11;
              int v54 = this->var8;
              this->var11 = &v53[12 * (int)v18];
              this->int var8 = v52 - v18 + 1;
              uint64_t v55 = v18;
              if (Path::AttemptSimplify((uint64_t)this, (float *)&v68, v64))
              {
                uint64_t v15 = v51;
                uint64_t v18 = v55;
                int v16 = v67;
              }
              else
              {
                double v62 = (char *)this->var3 + 44 * v17++;
                *(_DWORD *)double v62 = v14;
                *((_DWORD *)v62 + 1) = v51;
                uint64_t v15 = v51;
                *((void *)v62 + 1) = v2;
                *((_DWORD *)v62 + 4) = v3;
                *((_DWORD *)v62 + 5) = v4;
                *((_DWORD *)v62 + 6) = v6;
                *((_DWORD *)v62 + 7) = v7;
                *((_DWORD *)v62 + 8) = v8;
                *((_DWORD *)v62 + 9) = v9;
                *((_DWORD *)v62 + 10) = v5;
                uint64_t v18 = v52;
                int v16 = v13;
                int v14 = 0;
              }
              this->var11 = v53;
              this->int var8 = v54;
            }
            break;
          default:
            break;
        }
        ++v13;
      }
      while (v13 < this->var2);
      if (v14)
      {
        uint64_t v63 = (char *)this->var3 + 44 * v17++;
        *(_DWORD *)uint64_t v63 = v14;
        *((_DWORD *)v63 + 1) = v15;
        *((void *)v63 + 1) = v2;
        *((_DWORD *)v63 + 4) = v3;
        *((_DWORD *)v63 + 5) = v4;
        *((_DWORD *)v63 + 6) = v6;
        *((_DWORD *)v63 + 7) = v7;
        *((_DWORD *)v63 + 8) = v8;
        *((_DWORD *)v63 + 9) = v9;
        *((_DWORD *)v63 + 10) = v5;
      }
    }
    this->int var2 = v17;
  }
}

void Path::Stroke(uint64_t a1, void **this, int a3, int a4, int a5, char a6, float a7, float a8)
{
  if (this)
  {
    if ((a6 & 1) == 0) {
      Shape::Reset(this, 3 * *(_DWORD *)(a1 + 36));
    }
    if (*(int *)(a1 + 36) >= 2)
    {
      Shape::MakeBackData((Shape *)this, 0);
      uint64_t v17 = *(void *)(a1 + 48);
      uint64_t v18 = *(unsigned int *)(a1 + 36);
      if ((int)v18 >= 1)
      {
        int v19 = 0;
        do
        {
          int v20 = v19 + 1;
          if (*(unsigned char *)(a1 + 33))
          {
            if (*(unsigned char *)(a1 + 32))
            {
              if (v20 < (int)v18)
              {
                uint64_t v21 = v20;
                int v22 = (int *)(v17 + 24 * v20);
                while (1)
                {
                  int v23 = *v22;
                  v22 += 6;
                  if ((v23 | 2) != 2) {
                    break;
                  }
                  if (v18 == ++v21)
                  {
                    int v20 = v18;
                    goto LABEL_31;
                  }
                }
                int v20 = v21;
              }
LABEL_31:
              uint64_t v33 = v17 + 24 * v19;
            }
            else
            {
              if (v20 < (int)v18)
              {
                uint64_t v27 = v20;
                double v28 = (int *)(v17 + 20 * v20);
                while (1)
                {
                  int v29 = *v28;
                  v28 += 5;
                  if ((v29 | 2) != 2) {
                    break;
                  }
                  if (v18 == ++v27)
                  {
                    int v20 = v18;
                    goto LABEL_35;
                  }
                }
                int v20 = v27;
              }
LABEL_35:
              uint64_t v33 = v17 + 20 * v19;
            }
          }
          else if (*(unsigned char *)(a1 + 32))
          {
            if (v20 < (int)v18)
            {
              uint64_t v24 = v20;
              int v25 = (int *)(v17 + 16 * v20);
              while (1)
              {
                int v26 = *v25;
                v25 += 4;
                if ((v26 | 2) != 2) {
                  break;
                }
                if (v18 == ++v24)
                {
                  int v20 = v18;
                  goto LABEL_33;
                }
              }
              int v20 = v24;
            }
LABEL_33:
            uint64_t v33 = v17 + 16 * v19;
          }
          else
          {
            if (v20 < (int)v18)
            {
              uint64_t v30 = v20;
              double v31 = (int *)(v17 + 12 * v20);
              while (1)
              {
                int v32 = *v31;
                v31 += 3;
                if ((v32 | 2) != 2) {
                  break;
                }
                if (v18 == ++v30)
                {
                  int v20 = v18;
                  goto LABEL_37;
                }
              }
              int v20 = v30;
            }
LABEL_37:
            uint64_t v33 = v17 + 12 * v19;
          }
          *(void *)(a1 + 48) = v33;
          *(_DWORD *)(a1 + 36) = v20 - v19;
          Path::DoStroke(a1, (Shape *)this, a3, a4, a5, a7, a8, 0, v15, v16);
          int v19 = v20;
        }
        while (v20 < (int)v18);
      }
      *(void *)(a1 + 48) = v17;
      *(_DWORD *)(a1 + 36) = v18;
    }
  }
}

uint64_t Path::DoStroke(uint64_t result, Shape *this, int a3, int a4, int a5, float a6, float a7, uint64_t a8, int a9, int a10)
{
  int v10 = *(_DWORD *)(result + 36);
  if (v10 >= 2)
  {
    uint64_t v13 = result;
    int v14 = *(float **)(result + 48);
    if (*(unsigned char *)(result + 32)) {
      float v15 = v14[3];
    }
    else {
      float v15 = 1.0;
    }
    float v16 = v14[1];
    float v17 = v14[2];
    uint64_t v18 = (v10 - 1);
    float v19 = v16;
    float v20 = v17;
    if (a3)
    {
      uint64_t v21 = 12 * v18;
      if (*(unsigned char *)(result + 32)) {
        uint64_t v21 = 16 * v18;
      }
      uint64_t v22 = 24 * v18;
      if (!*(unsigned char *)(result + 32)) {
        uint64_t v22 = 20 * v18;
      }
      if (*(unsigned char *)(result + 33)) {
        uint64_t v21 = v22;
      }
      uint64_t v23 = -24;
      if (!*(unsigned char *)(result + 32)) {
        uint64_t v23 = -20;
      }
      uint64_t v24 = -16;
      if (!*(unsigned char *)(result + 32)) {
        uint64_t v24 = -12;
      }
      if (!*(unsigned char *)(result + 33)) {
        uint64_t v23 = v24;
      }
      int v25 = (float *)((char *)v14 + v21 + 8);
      while (1)
      {
        float v19 = *(v25 - 1);
        float v20 = *v25;
        if ((float)((float)((float)(v17 - *v25) * (float)(v17 - *v25))
                   + (float)((float)(v16 - v19) * (float)(v16 - v19))) > 0.001)
          break;
        --v10;
        int v25 = (float *)((char *)v25 + v23);
        if (v10 <= 1) {
          return result;
        }
      }
      LODWORD(v18) = v10 - 1;
    }
    int v26 = 0;
    uint64_t v27 = 24;
    if (!*(unsigned char *)(result + 32)) {
      uint64_t v27 = 20;
    }
    uint64_t v28 = 16;
    if (!*(unsigned char *)(result + 32)) {
      uint64_t v28 = 12;
    }
    if (*(unsigned char *)(result + 33)) {
      uint64_t v29 = v27;
    }
    else {
      uint64_t v29 = v28;
    }
    uint64_t v30 = (float *)((char *)v14 + v29 + 12);
    while (1)
    {
      float v31 = *(unsigned char *)(result + 32) ? *v30 : 1.0;
      float v32 = *(v30 - 2);
      float v33 = *(v30 - 1);
      if ((float)((float)((float)(v17 - v33) * (float)(v17 - v33)) + (float)((float)(v16 - v32) * (float)(v16 - v32))) > 0.001) {
        break;
      }
      ++v26;
      uint64_t v30 = (float *)((char *)v30 + v29);
      if (v18 == v26)
      {
        int v34 = v18 + 1;
        goto LABEL_38;
      }
    }
    int v34 = v26 + 1;
LABEL_38:
    if (v34 <= (int)v18)
    {
      unsigned int v89 = -1;
      int v90 = -1;
      unsigned int v87 = -1;
      unsigned int v88 = -1;
      float v35 = v16 - v19;
      float v36 = v17 - v20;
      float v37 = v32 - v16;
      float v38 = v33 - v17;
      float v39 = (float)(v36 * v36) + (float)(v35 * v35);
      float v40 = sqrtf(v39);
      float v41 = (float)(v38 * v38) + (float)(v37 * v37);
      if (v39 > 0.0001)
      {
        float v35 = v35 / v40;
        float v36 = v36 / v40;
      }
      float v42 = sqrtf(v41);
      if (v41 > 0.0001)
      {
        float v37 = v37 / v42;
        float v38 = v38 / v42;
      }
      float v43 = v37;
      float v44 = v38;
      float v45 = v31;
      int v46 = LODWORD(v42);
      if (a3) {
        Path::DoJoin(this, a4, (unsigned int *)&v90, &v88, &v89, &v87, a9, a10, v15 * a6, v16, v17, v35, v36, v37, v38, a7, SLODWORD(v40), SLODWORD(v42));
      }
      else {
        Path::DoButt(this, a5, &v87, &v88, v15 * a6, v16, v17, -v37, -v38);
      }
      int v49 = v46;
      float v50 = v45;
      float v51 = v44;
      float v52 = v43;
      unsigned int v53 = v87;
      unsigned int v54 = v88;
      while (1)
      {
        int v55 = v34 + 1;
        uint64_t v56 = *(void *)(v13 + 48);
        if (*(unsigned char *)(v13 + 33))
        {
          uint64_t v57 = 20 * v55;
          uint64_t v58 = 24 * v55;
        }
        else
        {
          uint64_t v57 = 12 * v55;
          uint64_t v58 = 16 * v55;
        }
        if (*(unsigned char *)(v13 + 32))
        {
          int v59 = 0;
        }
        else
        {
          uint64_t v58 = v57;
          int v59 = 1;
        }
        float v60 = v50;
        float v61 = v32;
        float v62 = v33;
        if (v34 < (int)v18)
        {
          uint64_t v63 = 24;
          if (v59) {
            uint64_t v63 = 20;
          }
          uint64_t v64 = 16;
          if (v59) {
            uint64_t v64 = 12;
          }
          if (*(unsigned char *)(v13 + 33)) {
            uint64_t v65 = v63;
          }
          else {
            uint64_t v65 = v64;
          }
          uint64_t v66 = v56 + v58 + 8;
          while (1)
          {
            float v60 = 1.0;
            if ((v59 & 1) == 0) {
              float v60 = *(float *)(v66 + 4);
            }
            float v61 = *(float *)(v66 - 4);
            float v62 = *(float *)v66;
            if ((float)((float)((float)(v33 - *(float *)v66) * (float)(v33 - *(float *)v66))
                       + (float)((float)(v32 - v61) * (float)(v32 - v61))) > 0.001)
              break;
            ++v34;
            v66 += v65;
            if (v18 == v34)
            {
              int v55 = v18 + 1;
              goto LABEL_68;
            }
          }
          int v55 = v34 + 1;
        }
LABEL_68:
        if (v55 > (int)v18) {
          break;
        }
        float v67 = v61 - v32;
        float v68 = v62 - v33;
        float v69 = (float)(v68 * v68) + (float)(v67 * v67);
        float v70 = sqrtf(v69);
        if (v69 > 0.0001)
        {
          float v67 = v67 / v70;
          float v68 = v68 / v70;
        }
        v86[0] = -1;
        v86[1] = -1;
        unsigned int v84 = -1;
        unsigned int v85 = -1;
        Path::DoJoin(this, a4, (unsigned int *)&v86[1], &v85, (unsigned int *)v86, &v84, v47, v48, v50 * a6, v32, v33, v52, v51, v67, v68, a7, v49, SLODWORD(v70));
        Shape::AddEdge(this, v86[1], v54);
        unsigned int v54 = v85;
        Shape::AddEdge(this, v53, v86[0]);
        int v49 = LODWORD(v70);
        float v52 = v67;
        unsigned int v53 = v84;
        float v51 = v68;
        int v34 = v55;
        float v50 = v60;
        float v32 = v61;
        float v33 = v62;
      }
      if (a3)
      {
        float v71 = *(float *)(v56 + 4) - v32;
        float v72 = *(float *)(v56 + 8) - v33;
        float v73 = (float)(v72 * v72) + (float)(v71 * v71);
        float v74 = sqrtf(v73);
        if (v73 > 0.0001)
        {
          float v71 = v71 / v74;
          float v72 = v72 / v74;
        }
        v86[0] = -1;
        v86[1] = -1;
        unsigned int v84 = -1;
        unsigned int v85 = -1;
        Path::DoJoin(this, a4, (unsigned int *)&v86[1], &v85, (unsigned int *)v86, &v84, v47, v48, v50 * a6, v32, v33, v52, v51, v71, v72, a7, v49, SLODWORD(v74));
        Shape::AddEdge(this, v86[1], v54);
        unsigned int v75 = v85;
        Shape::AddEdge(this, v53, v86[0]);
        unsigned int v76 = v84;
        Shape::AddEdge(this, v90, v75);
        unsigned int v77 = v89;
        double v78 = this;
        unsigned int v79 = v76;
      }
      else
      {
        *(void *)double v86 = 0;
        Path::DoButt(this, a5, (unsigned int *)v86, (unsigned int *)&v86[1], v50 * a6, v32, v33, v52, v51);
        Shape::AddEdge(this, v86[0], v54);
        unsigned int v77 = v86[1];
        double v78 = this;
        unsigned int v79 = v53;
      }
      return Shape::AddEdge(v78, v79, v77);
    }
  }
  return result;
}

uint64_t Path::DoJoin(Shape *this, int a2, unsigned int *a3, unsigned int *a4, unsigned int *a5, unsigned int *a6, int a7, int a8, float a9, float a10, float a11, float a12, float a13, float a14, float a15, float a16, int a17, int a18)
{
  float v31 = -a12;
  float v32 = (float)(a12 * a15) - (float)(a13 * a14);
  if (v32 > -0.0001 && v32 < 0.0001)
  {
    double v33 = (float)((float)(a13 * a15) + (float)(a12 * a14));
    unsigned int v34 = Shape::AddPoint(this, a10 + (float)(a9 * a13), a11 + (float)(a9 * v31));
    float v35 = a10 - (float)(a9 * a13);
    float v36 = a11 + (float)(a9 * a12);
    if (v33 > 0.9999)
    {
      *a4 = v34;
      *a3 = v34;
      uint64_t result = Shape::AddPoint(this, v35, v36);
      *a6 = result;
      *a5 = result;
      return result;
    }
    *a6 = v34;
    *a3 = v34;
    unsigned int v45 = Shape::AddPoint(this, v35, v36);
    *a4 = v45;
    *a5 = v45;
    Shape::AddEdge(this, *a4, *a3);
    unsigned int v46 = *a5;
    unsigned int v47 = *a6;
    goto LABEL_45;
  }
  float v38 = a14 - a12;
  float v39 = a15 - a13;
  float v40 = (float)(a13 * (float)(a15 - a13)) + (float)((float)(a14 - a12) * a12);
  double v41 = *(float *)&a17 * 0.5;
  float v123 = -a14;
  if (v32 >= 0.0)
  {
    float v48 = a9 / (float)((float)(a14 * v39) - (float)(a15 * v38));
    if (v41 < (float)-(float)(v48 * v40)
      || *(float *)&a18 * 0.5 < (float)((float)((float)(a15 * v39) + (float)(v38 * a14)) * v48))
    {
      *a5 = Shape::AddPoint(this, a10 - (float)(a9 * a13), a11 + (float)(a9 * a12));
      unsigned int v50 = Shape::AddPoint(this, a10 - (float)(a9 * a15), a11 + (float)(a9 * a14));
      *a6 = v50;
      Shape::AddEdge(this, *a5, v50);
    }
    else
    {
      unsigned int v86 = Shape::AddPoint(this, a10 + (float)(v48 * v38), a11 + (float)(v48 * v39));
      *a5 = v86;
      *a6 = v86;
    }
    if (a2 != 1)
    {
      if (a2 == 2)
      {
        *a3 = Shape::AddPoint(this, a10 + (float)(a9 * a13), a11 + (float)(a9 * v31));
        *a4 = Shape::AddPoint(this, a10 + (float)(a9 * a15), a11 + (float)(a9 * v123));
        float v87 = a13 + a15;
        float v88 = v123 - a12;
        float v89 = (float)(v88 * v88) + (float)(v87 * v87);
        if (v89 > 0.0001)
        {
          float v90 = sqrtf(v89);
          float v87 = v87 / v90;
          float v88 = v88 / v90;
        }
        float v91 = (float)(v88 * v123) + (float)(v87 * a15);
        float v92 = a9 / v91;
        float v93 = v91 * a9;
        if ((float)(v91 * a9) < a16) {
          float v93 = a16;
        }
        if (v92 <= v93)
        {
          unsigned int v98 = Shape::AddPoint(this, a10 + (float)(v92 * v87), a11 + (float)(v92 * v88));
          unsigned int v97 = v98;
        }
        else
        {
          float v94 = (float)(v91 * (float)(v92 - v93)) / (float)((float)(v87 * v123) - (float)(v88 * a15));
          float v95 = a10 + (float)(v93 * v87);
          float v96 = a11 + (float)(v93 * v88);
          unsigned int v97 = Shape::AddPoint(this, v95 + (float)(v94 * v88), v96 - (float)(v94 * v87));
          unsigned int v98 = Shape::AddPoint(this, v95 - (float)(v94 * v88), v96 + (float)(v94 * v87));
        }
        unsigned int v113 = v98;
        Shape::AddEdge(this, *a4, v98);
        Shape::AddEdge(this, v113, v97);
        unsigned int v47 = *a3;
        double v110 = this;
        unsigned int v46 = v97;
        goto LABEL_46;
      }
      *a3 = Shape::AddPoint(this, a10 + (float)(a9 * a13), a11 + (float)(a9 * v31));
      unsigned int v46 = Shape::AddPoint(this, a10 + (float)(a9 * a15), a11 + (float)(a9 * v123));
      *a4 = v46;
      unsigned int v47 = *a3;
      goto LABEL_45;
    }
    float v115 = a11 + (float)(a9 * v31);
    float v117 = a10 + (float)(a9 * a13);
    *a3 = Shape::AddPoint(this, v117, v115);
    float v119 = a11 + (float)(a9 * v123);
    float v122 = a10 + (float)(a9 * a15);
    double v81 = (Shape *)Shape::AddPoint(this, v122, v119);
    *a4 = v81;
    float v99 = a13 + a15;
    float v100 = v123 - a12;
    float v101 = (float)(v100 * v100) + (float)(v99 * v99);
    if (v101 > 0.0001)
    {
      float v102 = sqrtf(v101);
      float v99 = v99 / v102;
      float v100 = v100 / v102;
    }
    float v103 = (float)(v100 * v123) + (float)(v99 * a15);
    float v104 = a9 / v103;
    if ((float)((float)(a12 * a14) + (float)(a13 * a15)) >= 0.0)
    {
      float v82 = a10 + (float)(v104 * v99);
      float v83 = a11 + (float)(v104 * v100);
      unsigned int v64 = *a3;
      float v79 = 5.0;
      double v80 = (Path *)this;
      float v85 = a11 + (float)(a9 * v123);
      float v84 = a10 + (float)(a9 * a15);
    }
    else
    {
      float v105 = (float)(v103 * (float)(v104 - a9)) / (float)((float)(v99 * v123) - (float)(v100 * a15));
      float v106 = a10 + (float)(a9 * v99);
      float v107 = a11 + (float)(a9 * v100);
      float v108 = v99;
      uint64_t v109 = Shape::AddPoint(this, v106, v107);
      Path::RecRound((Path *)this, (Shape *)*a4, v109, 8, v106 - (float)(v105 * v100), v107 + (float)(v105 * v108), v122, v119, v106, v107, 5.0);
      unsigned int v64 = *a3;
      float v79 = 5.0;
      double v80 = (Path *)this;
      double v81 = (Shape *)v109;
      float v82 = v106 + (float)(v105 * v100);
      float v83 = v107 - (float)(v105 * v108);
      float v84 = v106;
      float v85 = v107;
    }
    float v111 = v117;
    float v112 = v115;
  }
  else
  {
    float v42 = a9 / (float)((float)(v38 * a15) - (float)(v39 * a14));
    if (v41 < (float)-(float)(v42 * v40)
      || *(float *)&a18 * 0.5 < (float)((float)((float)(a15 * v39) + (float)(v38 * a14)) * v42))
    {
      *a3 = Shape::AddPoint(this, a10 + (float)(a9 * a13), a11 + (float)(a9 * v31));
      unsigned int v44 = Shape::AddPoint(this, a10 + (float)(a9 * a15), a11 + (float)(a9 * (float)-a14));
      *a4 = v44;
      Shape::AddEdge(this, v44, *a3);
    }
    else
    {
      unsigned int v51 = Shape::AddPoint(this, a10 + (float)(v42 * v38), a11 + (float)(v42 * v39));
      *a3 = v51;
      *a4 = v51;
    }
    if (a2 != 1)
    {
      if (a2 == 2)
      {
        *a5 = Shape::AddPoint(this, a10 - (float)(a9 * a13), a11 + (float)(a9 * a12));
        *a6 = Shape::AddPoint(this, a10 - (float)(a9 * a15), a11 + (float)(a9 * a14));
        float v52 = a13 + a15;
        float v53 = v123 - a12;
        float v54 = (float)(v53 * v53) + (float)(v52 * v52);
        if (v54 > 0.0001)
        {
          float v55 = sqrtf(v54);
          float v52 = v52 / v55;
          float v53 = v53 / v55;
        }
        float v56 = (float)(v53 * v123) + (float)(v52 * a15);
        float v57 = a9 / v56;
        float v58 = v56 * a9;
        if ((float)(v56 * a9) < a16) {
          float v58 = a16;
        }
        if (v57 <= v58)
        {
          unsigned int v63 = Shape::AddPoint(this, a10 - (float)(v57 * v52), a11 - (float)(v57 * v53));
          unsigned int v62 = v63;
        }
        else
        {
          float v59 = (float)(v56 * (float)(v57 - v58)) / (float)((float)(v52 * v123) - (float)(v53 * a15));
          float v60 = a10 - (float)(v58 * v52);
          float v61 = a11 - (float)(v58 * v53);
          unsigned int v62 = Shape::AddPoint(this, v60 - (float)(v59 * v53), v61 + (float)(v59 * v52));
          unsigned int v63 = Shape::AddPoint(this, v60 + (float)(v59 * v53), v61 - (float)(v59 * v52));
        }
        Shape::AddEdge(this, *a5, v62);
        Shape::AddEdge(this, v62, v63);
        unsigned int v47 = *a6;
        double v110 = this;
        unsigned int v46 = v63;
        goto LABEL_46;
      }
      *a5 = Shape::AddPoint(this, a10 - (float)(a9 * a13), a11 + (float)(a9 * a12));
      unsigned int v47 = Shape::AddPoint(this, a10 - (float)(a9 * a15), a11 + (float)(a9 * a14));
      *a6 = v47;
      unsigned int v46 = *a5;
LABEL_45:
      double v110 = this;
LABEL_46:
      return Shape::AddEdge(v110, v46, v47);
    }
    float v116 = a11 + (float)(a9 * a12);
    float v118 = a10 - (float)(a9 * a13);
    *a5 = Shape::AddPoint(this, v118, v116);
    float v114 = a10 - (float)(a9 * a15);
    float v121 = a11 + (float)(a9 * a14);
    unsigned int v64 = Shape::AddPoint(this, v114, v121);
    *a6 = v64;
    float v65 = a13 + a15;
    float v66 = v123 - a12;
    float v67 = (float)(v66 * v66) + (float)(v65 * v65);
    if (v67 > 0.0001)
    {
      float v68 = sqrtf(v67);
      float v65 = v65 / v68;
      float v66 = v66 / v68;
    }
    float v69 = (float)(v66 * v123) + (float)(v65 * a15);
    float v70 = a9 / v69;
    if ((float)((float)(a12 * a14) + (float)(a13 * a15)) >= 0.0)
    {
      float v82 = a10 - (float)(v70 * v65);
      float v83 = a11 - (float)(v70 * v66);
      double v81 = (Shape *)*a5;
      float v79 = 5.0;
      double v80 = (Path *)this;
      float v85 = a11 + (float)(a9 * a12);
      float v84 = a10 - (float)(a9 * a13);
    }
    else
    {
      float v71 = (float)(v69 * (float)(v70 - a9)) / (float)((float)(v65 * v123) - (float)(v66 * a15));
      float v72 = a10 + (float)((float)-a9 * v65);
      float v73 = v72 - (float)(v71 * v66);
      float v74 = a11 + (float)((float)-a9 * v66);
      float v75 = v74 + (float)(v71 * v65);
      float v76 = v72 + (float)(v71 * v66);
      float v77 = v74 - (float)(v71 * v65);
      uint64_t v78 = Shape::AddPoint(this, v72, v74);
      Path::RecRound((Path *)this, (Shape *)*a5, v78, 8, v73, v75, v118, v116, v72, v74, 5.0);
      unsigned int v64 = *a6;
      float v79 = 5.0;
      double v80 = (Path *)this;
      double v81 = (Shape *)v78;
      float v82 = v76;
      float v83 = v77;
      float v84 = v72;
      float v85 = v74;
    }
    float v111 = v114;
    float v112 = v121;
  }

  return Path::RecRound(v80, v81, v64, 8, v82, v83, v84, v85, v111, v112, v79);
}

uint64_t Path::DoButt(Shape *this, int a2, unsigned int *a3, unsigned int *a4, float a5, float a6, float a7, float a8, float a9)
{
  float v17 = -a8;
  if (a2 == 3)
  {
    *a3 = Shape::AddPoint(this, a6 + (float)(a5 * a9), a7 + (float)(a5 * v17));
    *a4 = Shape::AddPoint(this, a6 - (float)(a5 * a9), a7 + (float)(a5 * a8));
    unsigned int v20 = Shape::AddPoint(this, a6 + (float)(a5 * a8), a7 + (float)(a5 * a9));
    unsigned int v24 = *a4;
    uint64_t v23 = this;
    goto LABEL_6;
  }
  if (a2 != 2)
  {
    if (a2 != 1)
    {
      *a3 = Shape::AddPoint(this, a6 + (float)(a5 * a9), a7 + (float)(a5 * v17));
      unsigned int v27 = Shape::AddPoint(this, a6 - (float)(a5 * a9), a7 + (float)(a5 * a8));
      *a4 = v27;
      unsigned int v25 = *a3;
      int v26 = this;
      goto LABEL_11;
    }
    float v18 = a6 + (float)(a5 * a8);
    float v19 = a7 + (float)(a5 * a9);
    unsigned int v20 = Shape::AddPoint(this, v18 + (float)(a5 * a9), v19 + (float)(a5 * v17));
    unsigned int v21 = Shape::AddPoint(this, v18 - (float)(a5 * a9), v19 + (float)(a5 * a8));
    *a3 = Shape::AddPoint(this, a6 + (float)(a5 * a9), a7 + (float)(a5 * v17));
    unsigned int v22 = Shape::AddPoint(this, a6 - (float)(a5 * a9), a7 + (float)(a5 * a8));
    *a4 = v22;
    Shape::AddEdge(this, v22, v21);
    uint64_t v23 = this;
    unsigned int v24 = v21;
LABEL_6:
    Shape::AddEdge(v23, v24, v20);
    unsigned int v25 = *a3;
    int v26 = this;
    unsigned int v27 = v20;
LABEL_11:
    return Shape::AddEdge(v26, v27, v25);
  }
  float v36 = a6 + (float)(a5 * a9);
  float v28 = a7 + (float)(a5 * v17);
  float v29 = a6 - (float)(a5 * a9);
  float v30 = a7 + (float)(a5 * a8);
  float v31 = a6 + (float)(a5 * a8);
  float v32 = a7 + (float)(a5 * a9);
  *a3 = Shape::AddPoint(this, v36, v28);
  *a4 = Shape::AddPoint(this, v29, v30);
  double v33 = (Shape *)Shape::AddPoint(this, v31, v32);
  Path::RecRound((Path *)this, (Shape *)*a4, v33, 8, v29 + (float)(a5 * a8), v30 + (float)(a5 * a9), v29, v30, v31, v32, 5.0);
  unsigned int v34 = *a3;

  return Path::RecRound((Path *)this, v33, v34, 8, v36 + (float)(a5 * a8), v28 + (float)(a5 * a9), v31, v32, v36, v28, 5.0);
}

uint64_t Path::RecRound(Path *this, Shape *a2, unsigned int a3, int a4, float a5, float a6, float a7, float a8, float a9, float a10, float a11)
{
  if (a4 >= 1)
  {
    int v19 = a4 + 1;
    float v27 = a9;
    float v28 = a10;
    while (1)
    {
      float v20 = (float)((float)(a7 - a5) * (float)(a10 - a6)) - (float)((float)(a8 - a6) * (float)(a9 - a5));
      float v21 = -v20;
      if (v20 >= 0.0) {
        float v21 = (float)((float)(a7 - a5) * (float)(a10 - a6)) - (float)((float)(a8 - a6) * (float)(a9 - a5));
      }
      if (v21 < a11) {
        break;
      }
      float v22 = (float)((float)(a7 + a9) + (float)(a5 * 2.0)) * 0.25;
      float v23 = (float)((float)(a8 + a10) + (float)(a6 * 2.0)) * 0.25;
      unsigned int v24 = (Shape *)Shape::AddPoint((Shape *)this, v22, v23);
      Path::RecRound(this, a2, (int)v24, v19 - 2, (float)(a5 + a7) * 0.5, (float)(a6 + a8) * 0.5, a7, a8, v22, v23, a11, v25);
      a9 = v27;
      a10 = v28;
      a5 = (float)(a5 + v27) * 0.5;
      --v19;
      a6 = (float)(a6 + v28) * 0.5;
      a8 = v23;
      a7 = v22;
      a2 = v24;
      if (v19 <= 1) {
        goto LABEL_9;
      }
    }
  }
  LODWORD(v24) = a2;
LABEL_9:

  return Shape::AddEdge((Shape *)this, v24, a3);
}

uint64_t Path::DoLeftJoin(Shape *this, int a2, unsigned int *a3, unsigned int *a4, float a5, float a6, float a7, float a8, float a9, float a10, float a11, float a12)
{
  float v23 = -a8;
  float v24 = (float)(a8 * a11) - (float)(a9 * a10);
  if (v24 > -0.0001 && v24 < 0.0001)
  {
    double v25 = (float)((float)(a9 * a11) + (float)(a8 * a10));
    uint64_t result = Shape::AddPoint(this, a6 + (float)(a5 * a9), a7 + (float)(a5 * v23));
    *a3 = result;
    if (v25 > 0.9999)
    {
      *a4 = result;
      return result;
    }
    float v37 = a6 - (float)(a5 * a9);
    float v38 = a7 + (float)(a5 * a8);
    goto LABEL_23;
  }
  if (v24 < 0.0)
  {
    *a3 = Shape::AddPoint(this, a6 + (float)(a5 * a9), a7 + (float)(a5 * v23));
    *a4 = Shape::AddPoint(this, a6 + (float)(a5 * a11), a7 + (float)(a5 * (float)-a10));
    float v27 = this;
    float v28 = a6;
    float v29 = a7;
    goto LABEL_7;
  }
  if (a2 != 1)
  {
    float v39 = -a10;
    if (a2 != 2)
    {
      *a3 = Shape::AddPoint(this, a6 + (float)(a5 * a9), a7 + (float)(a5 * v23));
      float v37 = a6 + (float)(a5 * a11);
      float v38 = a7 + (float)(a5 * v39);
LABEL_23:
      unsigned int v36 = Shape::AddPoint(this, v37, v38);
      *a4 = v36;
      unsigned int v34 = *a3;
      float v35 = this;
      goto LABEL_24;
    }
    *a3 = Shape::AddPoint(this, a6 + (float)(a5 * a9), a7 + (float)(a5 * v23));
    *a4 = Shape::AddPoint(this, a6 + (float)(a5 * a11), a7 + (float)(a5 * v39));
    float v40 = a9 + a11;
    float v41 = v39 - a8;
    float v42 = (float)(v41 * v41) + (float)(v40 * v40);
    if (v42 > 0.0001)
    {
      float v43 = sqrtf(v42);
      float v40 = v40 / v43;
      float v41 = v41 / v43;
    }
    float v44 = (float)(v41 * v39) + (float)(v40 * a11);
    float v45 = a5 / v44;
    float v46 = v44 * a5;
    if ((float)(v44 * a5) < a12) {
      float v46 = a12;
    }
    if (v45 > v46)
    {
      float v47 = (float)(v44 * (float)(v45 - v46)) / (float)((float)(v40 * v39) - (float)(v41 * a11));
      float v48 = a6 + (float)(v46 * v40);
      float v49 = a7 + (float)(v46 * v41);
      unsigned int v30 = Shape::AddPoint(this, v48 + (float)(v47 * v41), v49 - (float)(v47 * v40));
      unsigned int v50 = Shape::AddPoint(this, v48 - (float)(v47 * v41), v49 + (float)(v47 * v40));
      Shape::AddEdge(this, v50, v30);
      unsigned int v31 = *a4;
      float v32 = this;
      unsigned int v33 = v50;
      goto LABEL_8;
    }
    float v28 = a6 + (float)(v45 * v40);
    float v29 = a7 + (float)(v45 * v41);
    float v27 = this;
LABEL_7:
    unsigned int v30 = Shape::AddPoint(v27, v28, v29);
    unsigned int v31 = *a4;
    float v32 = this;
    unsigned int v33 = v30;
LABEL_8:
    Shape::AddEdge(v32, v31, v33);
    unsigned int v34 = *a3;
    float v35 = this;
    unsigned int v36 = v30;
LABEL_24:
    return Shape::AddEdge(v35, v36, v34);
  }
  float v72 = a7 + (float)(a5 * v23);
  float v73 = a6 + (float)(a5 * a9);
  *a3 = Shape::AddPoint(this, v73, v72);
  float v74 = a7 + (float)(a5 * (float)-a10);
  float v75 = a6 + (float)(a5 * a11);
  uint64_t v51 = Shape::AddPoint(this, v75, v74);
  float v52 = -a10;
  float v53 = (Shape *)v51;
  *a4 = v51;
  float v54 = a9 + a11;
  float v55 = (float)-a10 - a8;
  float v56 = (float)(v55 * v55) + (float)(v54 * v54);
  if (v56 > 0.0001)
  {
    float v57 = sqrtf(v56);
    float v54 = v54 / v57;
    float v55 = v55 / v57;
  }
  float v58 = (float)(v55 * v52) + (float)(v54 * a11);
  float v59 = a5 / v58;
  if ((float)((float)(a8 * a10) + (float)(a9 * a11)) >= 0.0)
  {
    float v68 = a6 + (float)(v59 * v54);
    float v69 = a7 + (float)(v59 * v55);
    unsigned int v65 = *a3;
    float v66 = 5.0;
    float v67 = (Path *)this;
    float v71 = a7 + (float)(a5 * (float)-a10);
    float v70 = a6 + (float)(a5 * a11);
  }
  else
  {
    float v60 = (float)(v58 * (float)(v59 - a5)) / (float)((float)(v54 * v52) - (float)(v55 * a11));
    float v61 = a6 + (float)(a5 * v54);
    float v62 = a7 + (float)(a5 * v55);
    float v63 = v54;
    uint64_t v64 = Shape::AddPoint(this, v61, v62);
    Path::RecRound((Path *)this, (Shape *)*a4, v64, 8, v61 - (float)(v60 * v55), v62 + (float)(v60 * v63), v75, v74, v61, v62, 5.0);
    unsigned int v65 = *a3;
    float v66 = 5.0;
    float v67 = (Path *)this;
    float v53 = (Shape *)v64;
    float v68 = v61 + (float)(v60 * v55);
    float v69 = v62 - (float)(v60 * v63);
    float v70 = v61;
    float v71 = v62;
  }

  return Path::RecRound(v67, v53, v65, 8, v68, v69, v70, v71, v73, v72, v66);
}

uint64_t Path::DoRightJoin(Shape *this, int a2, unsigned int *a3, unsigned int *a4, float a5, float a6, float a7, float a8, float a9, float a10, float a11, float a12)
{
  float v23 = (float)(a8 * a11) - (float)(a9 * a10);
  if (v23 > -0.0001 && v23 < 0.0001)
  {
    if ((float)((float)(a9 * a11) + (float)(a8 * a10)) > 0.9999)
    {
      uint64_t result = Shape::AddPoint(this, a6 - (float)(a5 * a9), a7 + (float)(a5 * a8));
      *a3 = result;
      *a4 = result;
      return result;
    }
    *a4 = Shape::AddPoint(this, a6 + (float)(a5 * a9), a7 + (float)(a5 * (float)-a8));
    unsigned int v41 = Shape::AddPoint(this, a6 - (float)(a5 * a9), a7 + (float)(a5 * a8));
    *a3 = v41;
    unsigned int v39 = *a4;
    goto LABEL_22;
  }
  if (v23 >= 0.0)
  {
    *a3 = Shape::AddPoint(this, a6 - (float)(a5 * a9), a7 + (float)(a5 * a8));
    *a4 = Shape::AddPoint(this, a6 - (float)(a5 * a11), a7 + (float)(a5 * a10));
    float v42 = this;
    float v43 = a6;
    float v44 = a7;
    goto LABEL_16;
  }
  if (a2 != 1)
  {
    if (a2 != 2)
    {
      *a3 = Shape::AddPoint(this, a6 - (float)(a5 * a9), a7 + (float)(a5 * a8));
      unsigned int v39 = Shape::AddPoint(this, a6 - (float)(a5 * a11), a7 + (float)(a5 * a10));
      *a4 = v39;
      unsigned int v41 = *a3;
LABEL_22:
      float v40 = this;
      goto LABEL_23;
    }
    *a3 = Shape::AddPoint(this, a6 - (float)(a5 * a9), a7 + (float)(a5 * a8));
    unsigned int v25 = Shape::AddPoint(this, a6 - (float)(a5 * a11), a7 + (float)(a5 * a10));
    float v26 = -a10;
    *a4 = v25;
    float v27 = a9 + a11;
    float v28 = (float)-a10 - a8;
    float v29 = (float)(v28 * v28) + (float)(v27 * v27);
    if (v29 > 0.0001)
    {
      float v30 = sqrtf(v29);
      float v27 = v27 / v30;
      float v28 = v28 / v30;
    }
    float v31 = (float)(v28 * v26) + (float)(v27 * a11);
    float v32 = a5 / v31;
    float v33 = v31 * a5;
    if ((float)(v31 * a5) < a12) {
      float v33 = a12;
    }
    if (v32 > v33)
    {
      float v34 = (float)(v31 * (float)(v32 - v33)) / (float)((float)(v27 * v26) - (float)(v28 * a11));
      float v35 = a6 - (float)(v33 * v27);
      float v36 = a7 - (float)(v33 * v28);
      unsigned int v37 = Shape::AddPoint(this, v35 - (float)(v34 * v28), v36 + (float)(v34 * v27));
      unsigned int v38 = Shape::AddPoint(this, v35 + (float)(v34 * v28), v36 - (float)(v34 * v27));
      Shape::AddEdge(this, *a3, v37);
      Shape::AddEdge(this, v37, v38);
      unsigned int v39 = *a4;
      float v40 = this;
      unsigned int v41 = v38;
LABEL_23:
      return Shape::AddEdge(v40, v41, v39);
    }
    float v43 = a6 - (float)(v32 * v27);
    float v44 = a7 - (float)(v32 * v28);
    float v42 = this;
LABEL_16:
    unsigned int v45 = Shape::AddPoint(v42, v43, v44);
    Shape::AddEdge(this, *a3, v45);
    unsigned int v39 = *a4;
    float v40 = this;
    unsigned int v41 = v45;
    goto LABEL_23;
  }
  float v71 = a7 + (float)(a5 * a8);
  float v72 = a6 - (float)(a5 * a9);
  *a3 = Shape::AddPoint(this, v72, v71);
  float v69 = a7 + (float)(a5 * a10);
  float v70 = a6 - (float)(a5 * a11);
  unsigned int v46 = Shape::AddPoint(this, v70, v69);
  *a4 = v46;
  float v47 = a9 + a11;
  float v48 = (float)-a10 - a8;
  float v49 = (float)(v48 * v48) + (float)(v47 * v47);
  if (v49 > 0.0001)
  {
    float v50 = sqrtf(v49);
    float v47 = v47 / v50;
    float v48 = v48 / v50;
  }
  float v51 = (float)(v48 * (float)-a10) + (float)(v47 * a11);
  float v52 = a5 / v51;
  if ((float)((float)(a8 * a10) + (float)(a9 * a11)) >= 0.0)
  {
    float v65 = a6 - (float)(v52 * v47);
    float v66 = a7 - (float)(v52 * v48);
    uint64_t v64 = (Shape *)*a3;
    float v62 = 5.0;
    float v63 = (Path *)this;
    float v68 = v71;
    float v67 = v72;
  }
  else
  {
    float v53 = -a5;
    float v54 = (float)(v51 * (float)(v52 - a5)) / (float)((float)(v47 * (float)-a10) - (float)(v48 * a11));
    float v55 = a6 + (float)((float)-a5 * v47);
    float v56 = v55 - (float)(v54 * v48);
    float v57 = a7 + (float)(v53 * v48);
    float v58 = v57 + (float)(v54 * v47);
    float v59 = v55 + (float)(v54 * v48);
    float v60 = v57 - (float)(v54 * v47);
    uint64_t v61 = Shape::AddPoint(this, v55, v57);
    Path::RecRound((Path *)this, (Shape *)*a3, v61, 8, v56, v58, v72, v71, v55, v57, 5.0);
    unsigned int v46 = *a4;
    float v62 = 5.0;
    float v63 = (Path *)this;
    uint64_t v64 = (Shape *)v61;
    float v65 = v59;
    float v66 = v60;
    float v67 = v55;
    float v68 = v57;
  }

  return Path::RecRound(v63, v64, v46, 8, v65, v66, v67, v68, v70, v69, v62);
}

uint64_t Path::Stroke(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(unsigned int *)(result + 36);
    if ((int)v2 >= 2)
    {
      int v3 = *(int **)(result + 48);
      if (*(unsigned char *)(result + 33))
      {
        if (*(unsigned char *)(result + 32))
        {
          uint64_t v4 = 1;
          int v5 = v3 + 6;
          while (1)
          {
            int v6 = *v5;
            v5 += 6;
            if ((v6 | 2) != 2) {
              break;
            }
            if (v2 == ++v4)
            {
              int v7 = *(_DWORD *)(result + 36);
              goto LABEL_23;
            }
          }
          int v7 = v4;
LABEL_23:
          uint64_t v17 = *(void *)(result + 48);
        }
        else
        {
          uint64_t v11 = 1;
          uint64_t v12 = v3 + 5;
          while (1)
          {
            int v13 = *v12;
            v12 += 5;
            if ((v13 | 2) != 2) {
              break;
            }
            if (v2 == ++v11)
            {
              int v7 = *(_DWORD *)(result + 36);
              goto LABEL_27;
            }
          }
          int v7 = v11;
LABEL_27:
          uint64_t v17 = *(void *)(result + 48);
        }
      }
      else if (*(unsigned char *)(result + 32))
      {
        uint64_t v8 = 1;
        int v9 = v3 + 4;
        while (1)
        {
          int v10 = *v9;
          v9 += 4;
          if ((v10 | 2) != 2) {
            break;
          }
          if (v2 == ++v8)
          {
            int v7 = *(_DWORD *)(result + 36);
            goto LABEL_25;
          }
        }
        int v7 = v8;
LABEL_25:
        uint64_t v17 = *(void *)(result + 48);
      }
      else
      {
        uint64_t v14 = 1;
        float v15 = v3 + 3;
        while (1)
        {
          int v16 = *v15;
          v15 += 3;
          if ((v16 | 2) != 2) {
            break;
          }
          if (v2 == ++v14)
          {
            int v7 = *(_DWORD *)(result + 36);
            goto LABEL_29;
          }
        }
        int v7 = v14;
LABEL_29:
        uint64_t v17 = *(void *)(result + 48);
      }
      *(void *)(result + 48) = v17;
      *(_DWORD *)(result + 36) = v7;
      Path::DoStroke();
    }
  }
  return result;
}

void Path::DoStroke()
{
}

void Path::DoJoin()
{
}

void Path::DoButt(uint64_t a1, int a2)
{
  if (a2) {
    operator new();
  }
}

void Path::DoSeg()
{
}

void Path::Stroke(uint64_t a1, void **this, int a3, int a4, int a5, int a6, uint64_t a7, char a8, float a9, float a10)
{
  if (a6 <= 0)
  {
    Path::Stroke(a1, this, a3, a4, a5, a8, a9, a10);
  }
  else if (this)
  {
    if ((a8 & 1) == 0) {
      Shape::Reset(this, 3 * *(_DWORD *)(a1 + 36));
    }
    if (*(int *)(a1 + 36) >= 2)
    {
      Shape::MakeBackData((Shape *)this, 0);
      uint64_t v19 = *(void *)(a1 + 48);
      uint64_t v20 = *(unsigned int *)(a1 + 36);
      if ((int)v20 >= 1)
      {
        int v21 = 0;
        do
        {
          int v22 = v21 + 1;
          if (*(unsigned char *)(a1 + 33))
          {
            if (*(unsigned char *)(a1 + 32))
            {
              if (v22 < (int)v20)
              {
                uint64_t v23 = v22;
                float v24 = (int *)(v19 + 24 * v22);
                while (1)
                {
                  int v25 = *v24;
                  v24 += 6;
                  if ((v25 | 2) != 2) {
                    break;
                  }
                  if (v20 == ++v23)
                  {
                    int v22 = v20;
                    goto LABEL_32;
                  }
                }
                int v22 = v23;
              }
LABEL_32:
              int v35 = 24;
            }
            else
            {
              if (v22 < (int)v20)
              {
                uint64_t v29 = v22;
                float v30 = (int *)(v19 + 20 * v22);
                while (1)
                {
                  int v31 = *v30;
                  v30 += 5;
                  if ((v31 | 2) != 2) {
                    break;
                  }
                  if (v20 == ++v29)
                  {
                    int v22 = v20;
                    goto LABEL_36;
                  }
                }
                int v22 = v29;
              }
LABEL_36:
              int v35 = 20;
            }
          }
          else
          {
            if (*(unsigned char *)(a1 + 32))
            {
              if (v22 < (int)v20)
              {
                uint64_t v26 = v22;
                float v27 = (int *)(v19 + 16 * v22);
                while (1)
                {
                  int v28 = *v27;
                  v27 += 4;
                  if ((v28 | 2) != 2) {
                    break;
                  }
                  if (v20 == ++v26)
                  {
                    int v22 = v20;
                    goto LABEL_34;
                  }
                }
                int v22 = v26;
              }
LABEL_34:
              uint64_t v36 = v19 + 16 * v21;
              goto LABEL_40;
            }
            if (v22 < (int)v20)
            {
              uint64_t v32 = v22;
              float v33 = (int *)(v19 + 12 * v22);
              while (1)
              {
                int v34 = *v33;
                v33 += 3;
                if ((v34 | 2) != 2) {
                  break;
                }
                if (v20 == ++v32)
                {
                  int v22 = v20;
                  goto LABEL_38;
                }
              }
              int v22 = v32;
            }
LABEL_38:
            int v35 = 12;
          }
          uint64_t v36 = v19 + v21 * (uint64_t)v35;
LABEL_40:
          *(void *)(a1 + 48) = v36;
          *(_DWORD *)(a1 + 36) = v22 - v21;
          Path::DoStroke(a1, (Shape *)this, a3, a4, a5, a6, a7, 0, a9, a10);
          int v21 = v22;
        }
        while (v22 < (int)v20);
      }
      *(void *)(a1 + 48) = v19;
      *(_DWORD *)(a1 + 36) = v20;
    }
  }
}

uint64_t Path::DoStroke(uint64_t result, Shape *this, int a3, int a4, int a5, int a6, uint64_t a7, int a8, float a9, float a10)
{
  if (this)
  {
    uint64_t v10 = result;
    int v11 = *(_DWORD *)(result + 36);
    if (v11 >= 2)
    {
      int v132 = 0;
      float v15 = *(float **)(result + 48);
      if (*(unsigned char *)(result + 32)) {
        float v16 = v15[3];
      }
      else {
        float v16 = 1.0;
      }
      float v17 = v15[1];
      float v18 = v15[2];
      uint64_t v19 = (v11 - 1);
      float v20 = v17;
      float v21 = v18;
      if (a3)
      {
        uint64_t v22 = 12 * v19;
        if (*(unsigned char *)(result + 32)) {
          uint64_t v22 = 16 * v19;
        }
        uint64_t v23 = 24 * v19;
        if (!*(unsigned char *)(result + 32)) {
          uint64_t v23 = 20 * v19;
        }
        if (*(unsigned char *)(result + 33)) {
          uint64_t v22 = v23;
        }
        uint64_t v24 = -24;
        if (!*(unsigned char *)(result + 32)) {
          uint64_t v24 = -20;
        }
        uint64_t v25 = -16;
        if (!*(unsigned char *)(result + 32)) {
          uint64_t v25 = -12;
        }
        if (!*(unsigned char *)(result + 33)) {
          uint64_t v24 = v25;
        }
        uint64_t v26 = (float *)((char *)v15 + v22 + 8);
        while (1)
        {
          float v20 = *(v26 - 1);
          float v21 = *v26;
          if ((float)((float)((float)(v18 - *v26) * (float)(v18 - *v26))
                     + (float)((float)(v17 - v20) * (float)(v17 - v20))) > 0.001)
            break;
          --v11;
          uint64_t v26 = (float *)((char *)v26 + v24);
          if (v11 <= 1) {
            return result;
          }
        }
        LODWORD(v19) = v11 - 1;
      }
      int v27 = 0;
      uint64_t v28 = 24;
      if (!*(unsigned char *)(result + 32)) {
        uint64_t v28 = 20;
      }
      uint64_t v29 = 16;
      if (!*(unsigned char *)(result + 32)) {
        uint64_t v29 = 12;
      }
      uint64_t v30 = *(unsigned char *)(result + 33) ? v28 : v29;
      int v31 = (float *)((char *)v15 + v30 + 12);
      while (1)
      {
        float v32 = *(unsigned char *)(result + 32) ? *v31 : 1.0;
        float v34 = *(v31 - 2);
        float v33 = *(v31 - 1);
        if ((float)((float)((float)(v18 - v33) * (float)(v18 - v33)) + (float)((float)(v17 - v34) * (float)(v17 - v34))) > 0.001) {
          break;
        }
        ++v27;
        int v31 = (float *)((char *)v31 + v30);
        if (v19 == v27)
        {
          int v35 = v19 + 1;
          goto LABEL_39;
        }
      }
      int v35 = v27 + 1;
LABEL_39:
      if (v35 <= (int)v19)
      {
        unsigned int v129 = -1;
        int v130 = -1;
        int v127 = -1;
        int v128 = -1;
        float v36 = v17 - v20;
        float v37 = v18 - v21;
        float v38 = v34 - v17;
        float v39 = v33 - v18;
        float v40 = (float)(v37 * v37) + (float)(v36 * v36);
        float v41 = (float)(v39 * v39) + (float)(v38 * v38);
        float v42 = sqrtf(v40);
        if (v40 > 0.0001)
        {
          float v36 = v36 / v42;
          float v37 = v37 / v42;
        }
        BOOL v43 = v41 <= 0.0001;
        float v44 = sqrtf(v41);
        if (!v43)
        {
          float v38 = v38 / v44;
          float v39 = v39 / v44;
        }
        int v45 = 0;
        do
        {
          if ((float)(*(float *)(a7 + 8 * v45 + 4) + 0.0) > 0.0) {
            break;
          }
          int v46 = v45 + 1;
          int v47 = v46 >= a6 ? a6 : 0;
          int v45 = v46 - v47;
        }
        while (v45);
        int v131 = v45;
        v133[0] = 0.0;
        int v48 = *(unsigned __int8 *)(a7 + 8 * v45);
        if (a3)
        {
          if (v48)
          {
            int v97 = 0;
            char v126 = 1;
LABEL_58:
            float v59 = v44;
            while (1)
            {
              float v60 = v33;
              float v61 = v34;
              float v62 = v32;
              float v63 = v39;
              float v64 = v38;
              int v65 = v35 + 1;
              float v66 = *(float **)(v10 + 48);
              if (*(unsigned char *)(v10 + 33))
              {
                uint64_t v67 = 20 * v65;
                uint64_t v68 = 24 * v65;
              }
              else
              {
                uint64_t v67 = 12 * v65;
                uint64_t v68 = 16 * v65;
              }
              if (*(unsigned char *)(v10 + 32))
              {
                int v69 = 0;
              }
              else
              {
                uint64_t v68 = v67;
                int v69 = 1;
              }
              if (v35 < (int)v19)
              {
                uint64_t v70 = 24;
                if (v69) {
                  uint64_t v70 = 20;
                }
                uint64_t v71 = 16;
                if (v69) {
                  uint64_t v71 = 12;
                }
                if (*(unsigned char *)(v10 + 33)) {
                  uint64_t v72 = v70;
                }
                else {
                  uint64_t v72 = v71;
                }
                uint64_t v73 = (uint64_t)v66 + v68 + 8;
                while (1)
                {
                  float v32 = 1.0;
                  if ((v69 & 1) == 0) {
                    float v32 = *(float *)(v73 + 4);
                  }
                  float v34 = *(float *)(v73 - 4);
                  float v33 = *(float *)v73;
                  if ((float)((float)((float)(v60 - *(float *)v73) * (float)(v60 - *(float *)v73))
                             + (float)((float)(v61 - v34) * (float)(v61 - v34))) > 0.001)
                    break;
                  ++v35;
                  v73 += v72;
                  if (v19 == v35)
                  {
                    int v65 = v19 + 1;
                    goto LABEL_80;
                  }
                }
                int v65 = v35 + 1;
              }
LABEL_80:
              int v106 = LODWORD(v44);
              if (v65 > (int)v19) {
                break;
              }
              float v74 = v34 - v61;
              float v75 = v33 - v60;
              float v76 = (float)(v75 * v75) + (float)(v74 * v74);
              float v77 = sqrtf(v76);
              if (v76 > 0.0001)
              {
                float v74 = v74 / v77;
                float v75 = v75 / v77;
              }
              float v107 = v75;
              float v111 = v74;
              float v78 = v59 + v77;
              float v117 = v59;
              float v118 = v17;
              float v119 = v18;
              float v120 = v61;
              float v121 = v60;
              float v122 = v64;
              float v123 = v63;
              float v124 = v16 * a9;
              float v103 = v63;
              float v125 = v62 * a9;
              float v102 = v64;
              Path::DashTo((uint64_t)this, &v117, (float *)&v132, &v131, v133, &v126, (unsigned int *)&v128, (unsigned int *)&v127, a6, a7);
              float v44 = v77;
              float v59 = v78;
              int v35 = v65;
              float v16 = v62;
              float v17 = v61;
              float v18 = v60;
              float v39 = v107;
              float v38 = v111;
              if (!v126)
              {
                int v115 = -1;
                int v116 = -1;
                int v113 = -1;
                int v114 = -1;
                Path::DoJoin(this, a4, (unsigned int *)&v116, (unsigned int *)&v114, (unsigned int *)&v115, (unsigned int *)&v113, v79, v80, v62 * a9, v61, v60, v102, v103, v111, v107, a10, v106, SLODWORD(v77));
                Shape::AddEdge(this, v116, v128);
                int v128 = v114;
                Shape::AddEdge(this, v127, v115);
                float v44 = v77;
                float v39 = v107;
                float v38 = v111;
                float v59 = v78;
                int v127 = v113;
                int v35 = v65;
                float v16 = v62;
                float v17 = v61;
                float v18 = v60;
              }
            }
            if (!a3)
            {
              float v117 = v59;
              float v118 = v17;
              float v119 = v18;
              float v120 = v61;
              float v121 = v60;
              float v122 = v38;
              float v123 = v39;
              float v124 = v16 * a9;
              float v125 = v62 * a9;
              float v93 = v39;
              float v94 = v38;
              uint64_t result = Path::DashTo((uint64_t)this, &v117, (float *)&v132, &v131, v133, &v126, (unsigned int *)&v128, (unsigned int *)&v127, a6, a7);
              if (v126) {
                return result;
              }
              int v115 = 0;
              int v116 = 0;
              Path::DoButt(this, a5, (unsigned int *)&v115, (unsigned int *)&v116, v62 * a9, v61, v60, v94, v93);
              Shape::AddEdge(this, v115, v128);
              unsigned int v92 = v127;
              unsigned int v95 = v116;
              return Shape::AddEdge(this, v92, v95);
            }
            float v81 = v62;
            float v82 = 1.0;
            if ((v69 & 1) == 0) {
              float v82 = v66[3];
            }
            float v108 = v66[1];
            float v112 = v82;
            float v83 = v108 - v61;
            float v84 = v66[2] - v60;
            float v85 = (float)(v84 * v84) + (float)(v83 * v83);
            float v86 = sqrtf(v85);
            float v105 = v66[2];
            if (v85 > 0.0001)
            {
              float v83 = v83 / v86;
              float v84 = v84 / v86;
            }
            float v104 = v59 + v86;
            float v117 = v59;
            float v118 = v17;
            float v119 = v18;
            float v120 = v61;
            float v121 = v60;
            float v122 = v38;
            float v123 = v39;
            float v124 = v16 * a9;
            float v87 = v81 * a9;
            float v125 = v81 * a9;
            float v88 = v39;
            float v89 = v38;
            Path::DashTo((uint64_t)this, &v117, (float *)&v132, &v131, v133, &v126, (unsigned int *)&v128, (unsigned int *)&v127, a6, a7);
            if (!v126)
            {
              int v115 = -1;
              int v116 = -1;
              int v113 = -1;
              int v114 = -1;
              Path::DoJoin(this, a4, (unsigned int *)&v116, (unsigned int *)&v114, (unsigned int *)&v115, (unsigned int *)&v113, v90, v91, v87, v61, v60, v89, v88, v83, v84, a10, v106, SLODWORD(v86));
              Shape::AddEdge(this, v116, v128);
              int v128 = v114;
              Shape::AddEdge(this, v127, v115);
              int v127 = v113;
            }
            float v117 = v104;
            float v118 = v61;
            float v119 = v60;
            float v120 = v108;
            float v121 = v105;
            float v122 = v83;
            float v123 = v84;
            float v124 = v87;
            float v125 = v112 * a9;
            uint64_t result = Path::DashTo((uint64_t)this, &v117, (float *)&v132, &v131, v133, &v126, (unsigned int *)&v128, (unsigned int *)&v127, a6, a7);
            if (v126)
            {
              if (!v97) {
                return result;
              }
              unsigned int v92 = v130;
            }
            else
            {
              unsigned int v95 = v128;
              if (!v97)
              {
                unsigned int v92 = v127;
                return Shape::AddEdge(this, v92, v95);
              }
              Shape::AddEdge(this, v130, v128);
              unsigned int v92 = v127;
            }
            unsigned int v95 = v129;
            return Shape::AddEdge(this, v92, v95);
          }
          float v109 = v16;
          float v49 = v17;
          float v50 = v18;
          float v51 = v38;
          float v52 = v39;
          float v53 = v44;
          Path::DoJoin(this, a4, (unsigned int *)&v130, (unsigned int *)&v128, &v129, (unsigned int *)&v127, a7, a8, v16 * a9, v17, v18, v36, v37, v38, v39, a10, SLODWORD(v42), SLODWORD(v44));
          float v44 = v53;
          float v39 = v52;
          float v38 = v51;
          float v18 = v50;
          float v17 = v49;
          float v16 = v109;
        }
        else
        {
          if (v48)
          {
            int v97 = 1;
            char v126 = 1;
            goto LABEL_58;
          }
          float v54 = v16;
          float v55 = v17;
          float v56 = v18;
          float v57 = v38;
          float v58 = v39;
          float v110 = v44;
          Path::DoButt(this, a5, (unsigned int *)&v127, (unsigned int *)&v128, v16 * a9, v17, v18, -v38, -v39);
          float v44 = v110;
          float v39 = v58;
          float v38 = v57;
          float v18 = v56;
          float v17 = v55;
          float v16 = v54;
        }
        char v126 = 0;
        int v97 = 1;
        goto LABEL_58;
      }
    }
  }
  return result;
}

uint64_t Path::DashTo(uint64_t result, float *a2, float *a3, _DWORD *a4, float *a5, char *a6, unsigned int *a7, unsigned int *a8, int a9, uint64_t a10)
{
  float v39 = (Shape *)result;
  float v10 = *a3;
  uint64_t v11 = *a4;
  if (*a3 < *a2)
  {
    float v17 = a2[5];
    float v16 = a2[6];
    float v18 = -v17;
    float v37 = a3;
    float v38 = a6;
    while (1)
    {
      uint64_t v19 = v11;
      while (1)
      {
        float v20 = *(float *)(a10 + 8 * (int)v19 + 4) - *a5;
        float v21 = *a2 - *a3;
        if (v20 > v21) {
          break;
        }
        int v22 = v19 + 1;
        *a4 = v22;
        *a5 = 0.0;
        if (v22 >= a9)
        {
          *a4 = v22 - a9;
          v22 -= a9;
        }
        int v23 = v11;
        if (v22 != v11)
        {
          while (*(float *)(a10 + 8 * v22 + 4) <= 0.0)
          {
            *a4 = ++v22;
            *a5 = 0.0;
            if (v22 >= a9)
            {
              *a4 = v22 - a9;
              v22 -= a9;
            }
            if (v22 == v11)
            {
              int v23 = v11;
              goto LABEL_14;
            }
          }
          int v23 = v22;
        }
LABEL_14:
        if (*(float *)(a10 + 8 * v23 + 4) <= 0.0) {
          goto LABEL_21;
        }
        float v24 = v20 + *a3;
        *a3 = v24;
        float v25 = *a2 - v24;
        float v26 = v24 - v10;
        float v27 = *a2 - v10;
        float v28 = (float)((float)(v26 * a2[3]) + (float)(a2[1] * v25)) / v27;
        float v29 = (float)((float)(v26 * a2[4]) + (float)(a2[2] * v25)) / v27;
        float v30 = (float)((float)(v26 * a2[8]) + (float)(a2[7] * v25)) / v27;
        if (*a6)
        {
          if (!*(unsigned char *)(a10 + 8 * v23))
          {
            unsigned int v31 = Shape::AddPoint(v39, v28 + (float)(v30 * v16), v29 + (float)(v30 * v18));
            unsigned int v32 = Shape::AddPoint(v39, v28 - (float)(v30 * v16), v29 + (float)(v30 * v17));
            uint64_t result = Shape::AddEdge(v39, v31, v32);
            char v33 = 0;
LABEL_20:
            *a7 = v31;
            *a8 = v32;
            a3 = v37;
            a6 = v38;
            *float v38 = v33;
          }
        }
        else if (*(unsigned char *)(a10 + 8 * v23))
        {
          unsigned int v34 = Shape::AddPoint(v39, v28 + (float)(v30 * v16), v29 + (float)(v30 * v18));
          unsigned int v35 = Shape::AddPoint(v39, v28 - (float)(v30 * v16), v29 + (float)(v30 * v17));
          Shape::AddEdge(v39, v35, v34);
          Shape::AddEdge(v39, *a8, v35);
          uint64_t result = Shape::AddEdge(v39, v34, *a7);
          char v33 = 1;
          unsigned int v31 = -1;
          unsigned int v32 = -1;
          goto LABEL_20;
        }
LABEL_21:
        uint64_t v19 = *a4;
        if (v19 == v11)
        {
          float v36 = *a3;
          goto LABEL_24;
        }
      }
      *a5 = *a5 + v21;
      float v36 = *a2;
      *a3 = *a2;
      uint64_t v11 = v19;
LABEL_24:
      if (v36 >= *a2)
      {
        LODWORD(v11) = *a4;
        break;
      }
    }
  }
  *a6 = *(unsigned char *)(a10 + 8 * (int)v11);
  return result;
}

double TSDMetalEdgeDistanceFieldTextureAdjustmentMix()
{
  TSUMix();
  double v1 = v0;
  TSUMix();
  TSUMix();
  return v1;
}

float halfToFloat(unsigned int a1)
{
  LODWORD(result) = ((a1 << 16) & 0x80000000 | (((a1 >> 10) & 0x1F) << 23) | ((a1 & 0x3FF) << 13)) + 939524096;
  return result;
}

BOOL TSDMetalEdgeDistanceFieldBufferPixelIsInsideTexture(double a1, double a2, double a3, double a4)
{
  BOOL result = 0;
  if (a1 >= 0.0 && a2 >= 0.0 && a1 < a3) {
    return a2 < a4;
  }
  return result;
}

uint64_t TSDMetalEdgeDistanceFieldBufferIndexFromPixel(double a1, double a2, double a3)
{
  return (uint64_t)(a1 + a3 * a2);
}

double TSDMetalEdgeDistanceFieldBufferPixelFromIndex(uint64_t a1, double a2)
{
  return (double)(a1 % (uint64_t)a2);
}

uint64_t TSDMetalEdgeDistanceFieldBufferOffsetFromPixel(double a1, double a2, double a3)
{
  return 4 * (uint64_t)(a1 + a3 * a2);
}

double TSDMetalEdgeDistanceFieldBufferValueAtPixel(uint64_t a1, double a2, double a3, double a4)
{
  return *(float *)(a1 + 4 * (uint64_t)(a2 + a4 * a3));
}

double TSDMetalEdgeDistanceFieldBufferGradientAtPixel(uint64_t a1, double a2, double a3, double a4)
{
  return *(float *)(a1 + 16 * (uint64_t)(a2 + a4 * a3) + 4) + -0.5;
}

float TSDMetalEdgeDistanceFieldBufferColorValueAtPixel(uint64_t a1, double a2, double a3, double a4)
{
  return *(float *)(a1 + 16 * (uint64_t)(a2 + a4 * a3)) + -0.5;
}

BOOL TSDMetalEdgeDistanceFieldBufferPixelIsLocalMaximum(uint64_t a1, double a2, double a3, double a4, double a5)
{
  uint64_t v10 = 0;
  float v11 = fabsf(*(float *)(a1 + 4 * (uint64_t)(a2 + a4 * a3)));
  int v12 = 1;
  while (1)
  {
    while (1)
    {
      int v13 = v12;
      double v14 = TSDAddPoints(a2, a3, *(double *)&kNeighboring8Points[2 * v10]);
      if (v14 >= 0.0)
      {
        double v16 = v14;
        double v17 = v15;
        BOOL v18 = v15 >= 0.0 && v14 < a4;
        if (v18 && v15 < a5)
        {
          double v20 = TSDAddPoints(a2, a3, *(double *)((char *)kNeighboring8Points + ((16 * v10) | 0x10)));
          if (v20 >= 0.0)
          {
            BOOL v22 = v21 >= 0.0 && v20 < a4;
            if (v22 && v21 < a5) {
              break;
            }
          }
        }
      }
      int v12 = 0;
      BOOL result = 0;
      uint64_t v10 = 2;
      if ((v13 & 1) == 0) {
        return result;
      }
    }
    double v24 = v20 + a4 * v21;
    float v25 = fabsf(*(float *)(a1 + 4 * (uint64_t)(v16 + a4 * v17)));
    float v26 = fabsf(*(float *)(a1 + 4 * (uint64_t)v24));
    if (v25 <= v11 && v26 < v11) {
      break;
    }
    BOOL result = v26 <= v11 && v25 < v11;
    if (!result)
    {
      int v12 = 0;
      uint64_t v10 = 2;
      if (((v13 ^ 1) & 1) == 0) {
        continue;
      }
    }
    return result;
  }
  return 1;
}

BOOL TSDMetalEdgeDistanceFieldBufferTracePixelContainsData(uint64_t a1, double a2, double a3, double a4)
{
  return *(unsigned char *)(a1 + 4 * (uint64_t)(a2 + a4 * a3) + 3) != 0;
}

uint64_t TSDMetalEdgeDistanceFieldBufferTracePixelValue(uint64_t a1, int a2, double a3, double a4, double a5)
{
  double v5 = a3 + a5 * a4;
  if (a2) {
    return *(unsigned __int16 *)(a1 + 4 * (uint64_t)v5);
  }
  else {
    return *(unsigned __int16 *)(a1 + 4 * (uint64_t)v5) - 0x8000;
  }
}

double TSDMetalEdgeDistanceFieldBufferSetTracePixelValue(uint64_t a1, uint64_t a2, int a3, double a4, double a5, double a6)
{
  uint64_t v6 = a2 + 0x8000;
  if (a3) {
    uint64_t v6 = a2;
  }
  __int16 v7 = v6 + 255;
  if (v6 >= 0) {
    HIBYTE(v7) = BYTE1(v6);
  }
  double result = a4 + a6 * a5;
  int v9 = (unsigned char *)(a1 + 4 * (uint64_t)result);
  *int v9 = v6;
  v9[1] = HIBYTE(v7);
  v9[3] = -1;
  return result;
}

uint64_t TSDMetalEdgeDistanceFieldBufferSurroundingTracePixelValueClosestToZero(uint64_t a1, int a2, double a3, double a4, double a5, double a6)
{
  char v6 = a2;
  uint64_t v12 = 0;
  if (a2) {
    uint64_t v13 = 0x8000000000000000;
  }
  else {
    uint64_t v13 = 0x7FFFFFFFFFFFFFFFLL;
  }
  do
  {
    double v14 = TSDAddPoints(a3, a4, *(double *)&kNeighboring8Points[v12]);
    if (v14 >= 0.0)
    {
      BOOL v16 = v15 >= 0.0 && v14 < a5;
      if (v16 && v15 < a6)
      {
        BOOL v18 = (unsigned __int16 *)(a1 + 4 * (uint64_t)(v14 + a5 * v15));
        if (*((unsigned char *)v18 + 3))
        {
          uint64_t v19 = *v18;
          uint64_t v20 = v19 - 0x8000;
          BOOL v16 = v19 - 0x8000 < 0;
          unint64_t v21 = 0x8000 - v19;
          if (!v16) {
            unint64_t v21 = v20;
          }
          if (v13 >= 0) {
            unint64_t v22 = v13;
          }
          else {
            unint64_t v22 = -v13;
          }
          if ((v6 & 1) == 0)
          {
            if (v21 >= v22) {
              goto LABEL_24;
            }
LABEL_23:
            uint64_t v13 = v20;
            goto LABEL_24;
          }
          if (v21 > v22) {
            goto LABEL_23;
          }
        }
      }
    }
LABEL_24:
    v12 += 2;
  }
  while (v12 != 8);
  return v13;
}

uint64_t TSDMetalEdgeDistanceFieldBufferNeighborPixelsClosestToZero(uint64_t a1, int64_t a2, _OWORD *a3, double a4, double a5, double a6, double a7)
{
  uint64_t v14 = 0;
  int64_t v15 = 0;
  v26[23] = *MEMORY[0x263EF8340];
  do
  {
    double v16 = TSDAddPoints(a4, a5, *(double *)&kNeighboring8Points[v14]);
    if (v16 >= 0.0)
    {
      BOOL v18 = v17 >= 0.0 && v16 < a6;
      if (v18 && v17 < a7)
      {
        uint64_t v20 = (double *)&__base[24 * v15++];
        *uint64_t v20 = *(float *)(a1 + 4 * (uint64_t)(v16 + a6 * v17));
        v20[1] = v16;
        v20[2] = v17;
      }
    }
    v14 += 2;
  }
  while (v14 != 16);
  if (v15 >= a2) {
    uint64_t v21 = a2;
  }
  else {
    uint64_t v21 = v15;
  }
  if (v21 > 0)
  {
    qsort_b(__base, v15, 0x18uLL, &__block_literal_global_35);
    if (a3)
    {
      unint64_t v22 = (long long *)v26;
      do
      {
        long long v23 = *v22;
        unint64_t v22 = (long long *)((char *)v22 + 24);
        *a3++ = v23;
        --a2;
      }
      while (a2);
    }
  }
  return v21;
}

uint64_t __TSDMetalEdgeDistanceFieldBufferNeighborPixelsClosestToZero_block_invoke(uint64_t a1, double *a2, double *a3)
{
  double v3 = fabs(*a2);
  double v4 = fabs(*a3);
  if (v3 < v4) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v3 > v4;
  }
}

uint64_t TSDMetalEdgeDistanceFieldBufferNeighborPixelIsZero(uint64_t a1, double a2, double a3, double a4, double a5)
{
  uint64_t v10 = 0;
  float v11 = fabsf(*(float *)(a1 + 4 * (uint64_t)(a2 + a4 * a3)));
  while (1)
  {
    double v12 = TSDAddPoints(a2, a3, *(double *)&kNeighboring8Points[v10]);
    if (v12 >= 0.0)
    {
      BOOL v14 = v13 >= 0.0 && v12 < a4;
      BOOL v15 = v14 && v13 < a5;
      if (v15 && fabsf(*(float *)(a1 + 4 * (uint64_t)(v12 + a4 * v13))) < v11) {
        break;
      }
    }
    v10 += 2;
    if (v10 == 16) {
      return 1;
    }
  }
  return 0;
}

BOOL TSDMetalEdgeDistanceFieldValueIsGreaterThanStrokeWidth(double a1, double a2, double a3, double a4)
{
  double v4 = fabs(a1);
  if (a3 <= a4) {
    a3 = a4;
  }
  return v4 > a2 / a3;
}

void Shape::Shape(Shape *this)
{
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  *((void *)this + 6) = 1;
  *((void *)this + 16) = 0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
}

{
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  *((void *)this + 6) = 1;
  *((void *)this + 16) = 0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
}

void Shape::~Shape(void **this)
{
  if (*((int *)this + 5) >= 1) {
    free(this[3]);
  }
  this[2] = 0;
  this[3] = 0;
  if (*((int *)this + 9) >= 1) {
    free(this[5]);
  }
  this[4] = 0;
  this[5] = 0;
  uint64_t v2 = this[7];
  if (v2) {
    free(v2);
  }
  double v3 = this[12];
  if (v3) {
    free(v3);
  }
  double v4 = this[8];
  if (v4) {
    free(v4);
  }
  double v5 = this[9];
  if (v5) {
    free(v5);
  }
  char v6 = this[10];
  if (v6) {
    free(v6);
  }
  __int16 v7 = this[16];
  if (v7) {
    free(v7);
  }
  uint64_t v8 = this[11];
  if (v8) {
    free(v8);
  }
  int v9 = this[13];
  if (v9) {
    free(v9);
  }
  uint64_t v10 = this[14];
  if (v10) {
    free(v10);
  }
}

void Shape::MakePointData(Shape *this, int a2)
{
  int v3 = *((_DWORD *)this + 13);
  if (a2)
  {
    if ((v3 & 4) == 0)
    {
      *((_DWORD *)this + 13) = v3 | 4;
      double v4 = (void *)*((void *)this + 11);
      if (v4) {
        free(v4);
      }
      *((void *)this + 11) = malloc_type_malloc(48 * *((int *)this + 5), 0x102004023ED6C3AuLL);
    }
  }
  else if ((v3 & 4) != 0)
  {
    *((_DWORD *)this + 13) = v3 & 0xFFFFFFFB;
    double v5 = (void *)*((void *)this + 11);
    if (v5)
    {
      free(v5);
      *((void *)this + 11) = 0;
    }
  }
}

void Shape::MakeEdgeData(Shape *this, int a2)
{
  int v3 = *((_DWORD *)this + 13);
  if (a2)
  {
    if ((v3 & 8) == 0)
    {
      *((_DWORD *)this + 13) = v3 | 8;
      double v4 = (void *)*((void *)this + 7);
      if (v4) {
        free(v4);
      }
      *((void *)this + 7) = malloc_type_malloc((uint64_t)*((int *)this + 9) << 6, 0x100004094D12286uLL);
    }
  }
  else if ((v3 & 8) != 0)
  {
    *((_DWORD *)this + 13) = v3 & 0xFFFFFFF7;
    double v5 = (void *)*((void *)this + 7);
    if (v5)
    {
      free(v5);
      *((void *)this + 7) = 0;
    }
  }
}

void Shape::MakeRasterData(Shape *this, int a2)
{
  int v3 = *((_DWORD *)this + 13);
  if (a2)
  {
    if ((v3 & 0x80) == 0)
    {
      *((_DWORD *)this + 13) = v3 | 0x80;
      double v4 = (void *)*((void *)this + 10);
      if (v4) {
        free(v4);
      }
      *((void *)this + 10) = malloc_type_malloc(48 * *((int *)this + 9), 0x10200403C9B7522uLL);
    }
  }
  else if ((v3 & 0x80) != 0)
  {
    *((_DWORD *)this + 13) = v3 & 0xFFFFFF7F;
    double v5 = (void *)*((void *)this + 10);
    if (v5)
    {
      free(v5);
      *((void *)this + 10) = 0;
    }
  }
}

void Shape::MakeQuickRasterData(Shape *this, int a2)
{
  int v3 = *((_DWORD *)this + 13);
  if (a2)
  {
    if ((v3 & 0x100) == 0)
    {
      *((_DWORD *)this + 13) = v3 | 0x100;
      double v4 = (void *)*((void *)this + 16);
      if (v4) {
        free(v4);
      }
      *((void *)this + 16) = malloc_type_malloc(16 * *((int *)this + 9), 0x10000408B6DE1C6uLL);
    }
  }
  else if ((v3 & 0x100) != 0)
  {
    *((_DWORD *)this + 13) = v3 & 0xFFFFFEFF;
    double v5 = (void *)*((void *)this + 16);
    if (v5)
    {
      free(v5);
      *((void *)this + 16) = 0;
    }
  }
}

void Shape::MakeSweepSrcData(Shape *this, int a2)
{
  int v3 = *((_DWORD *)this + 13);
  if (a2)
  {
    if ((v3 & 0x10) == 0)
    {
      *((_DWORD *)this + 13) = v3 | 0x10;
      double v4 = (void *)*((void *)this + 8);
      if (v4) {
        free(v4);
      }
      *((void *)this + 8) = malloc_type_malloc(56 * *((int *)this + 9), 0x10A0040A41B8C3EuLL);
    }
  }
  else if ((v3 & 0x10) != 0)
  {
    *((_DWORD *)this + 13) = v3 & 0xFFFFFFEF;
    double v5 = (void *)*((void *)this + 8);
    if (v5)
    {
      free(v5);
      *((void *)this + 8) = 0;
    }
  }
}

void Shape::MakeSweepDestData(Shape *this, int a2)
{
  int v3 = *((_DWORD *)this + 13);
  if (a2)
  {
    if ((v3 & 0x20) == 0)
    {
      *((_DWORD *)this + 13) = v3 | 0x20;
      double v4 = (void *)*((void *)this + 9);
      if (v4) {
        free(v4);
      }
      *((void *)this + 9) = malloc_type_malloc(32 * *((int *)this + 9), 0x1080040DCAC275BuLL);
    }
  }
  else if ((v3 & 0x20) != 0)
  {
    *((_DWORD *)this + 13) = v3 & 0xFFFFFFDF;
    double v5 = (void *)*((void *)this + 9);
    if (v5)
    {
      free(v5);
      *((void *)this + 9) = 0;
    }
  }
}

void Shape::MakeBackData(Shape *this, int a2)
{
  int v3 = *((_DWORD *)this + 13);
  if (a2)
  {
    if ((v3 & 0x200) == 0)
    {
      *((_DWORD *)this + 13) = v3 | 0x200;
      double v4 = (void *)*((void *)this + 12);
      if (v4) {
        free(v4);
      }
      *((void *)this + 12) = malloc_type_malloc(16 * *((int *)this + 9), 0x1000040451B5BE8uLL);
    }
  }
  else if ((v3 & 0x200) != 0)
  {
    *((_DWORD *)this + 13) = v3 & 0xFFFFFDFF;
    double v5 = (void *)*((void *)this + 12);
    if (v5)
    {
      free(v5);
      *((void *)this + 12) = 0;
    }
  }
}

void Shape::MakeVoronoiData(Shape *this, int a2)
{
  int v3 = *((_DWORD *)this + 13);
  if (a2)
  {
    if ((v3 & 0x400) == 0)
    {
      *((_DWORD *)this + 13) = v3 | 0x400;
      double v4 = (void *)*((void *)this + 13);
      if (v4) {
        free(v4);
      }
      double v5 = (void *)*((void *)this + 14);
      if (v5) {
        free(v5);
      }
      *((void *)this + 13) = malloc_type_malloc(8 * *((int *)this + 5), 0x100004000313F17uLL);
      *((void *)this + 14) = malloc_type_malloc(40 * *((int *)this + 9), 0x10000400A747E1EuLL);
    }
  }
  else if ((v3 & 0x400) != 0)
  {
    *((_DWORD *)this + 13) = v3 & 0xFFFFFBFF;
    char v6 = (void *)*((void *)this + 13);
    if (v6)
    {
      free(v6);
      *((void *)this + 13) = 0;
    }
    __int16 v7 = (void *)*((void *)this + 14);
    if (v7)
    {
      free(v7);
      *((void *)this + 14) = 0;
    }
  }
}

void **Shape::Copy(Shape *this, Shape *a2)
{
  if (a2)
  {
    int v4 = *((_DWORD *)this + 13);
    if ((v4 & 4) != 0)
    {
      v4 &= ~4u;
      *((_DWORD *)this + 13) = v4;
      double v5 = (void *)*((void *)this + 11);
      if (v5)
      {
        free(v5);
        *((void *)this + 11) = 0;
        int v4 = *((_DWORD *)this + 13);
      }
    }
    if ((v4 & 8) != 0)
    {
      v4 &= ~8u;
      *((_DWORD *)this + 13) = v4;
      char v6 = (void *)*((void *)this + 7);
      if (v6)
      {
        free(v6);
        *((void *)this + 7) = 0;
        int v4 = *((_DWORD *)this + 13);
      }
    }
    if ((v4 & 0x10) != 0)
    {
      v4 &= ~0x10u;
      *((_DWORD *)this + 13) = v4;
      __int16 v7 = (void *)*((void *)this + 8);
      if (v7)
      {
        free(v7);
        *((void *)this + 8) = 0;
        int v4 = *((_DWORD *)this + 13);
      }
    }
    if ((v4 & 0x20) != 0)
    {
      v4 &= ~0x20u;
      *((_DWORD *)this + 13) = v4;
      uint64_t v8 = (void *)*((void *)this + 9);
      if (v8)
      {
        free(v8);
        *((void *)this + 9) = 0;
        int v4 = *((_DWORD *)this + 13);
      }
    }
    if ((v4 & 0x80) != 0)
    {
      v4 &= ~0x80u;
      *((_DWORD *)this + 13) = v4;
      int v9 = (void *)*((void *)this + 10);
      if (v9)
      {
        free(v9);
        *((void *)this + 10) = 0;
        int v4 = *((_DWORD *)this + 13);
      }
    }
    if ((v4 & 0x100) != 0)
    {
      v4 &= ~0x100u;
      *((_DWORD *)this + 13) = v4;
      uint64_t v10 = (void *)*((void *)this + 16);
      if (v10)
      {
        free(v10);
        *((void *)this + 16) = 0;
        int v4 = *((_DWORD *)this + 13);
      }
    }
    if ((v4 & 0x200) != 0)
    {
      v4 &= ~0x200u;
      *((_DWORD *)this + 13) = v4;
      float v11 = (void *)*((void *)this + 12);
      if (v11)
      {
        free(v11);
        *((void *)this + 12) = 0;
        int v4 = *((_DWORD *)this + 13);
      }
    }
    if ((v4 & 0x40) != 0)
    {
      SweepTree::DestroyList((void *)this + 21);
      SweepEvent::DestroyQueue((void *)this + 24);
      int v12 = *((_DWORD *)this + 13);
      if ((v12 & 0x40) != 0) {
        *((_DWORD *)this + 13) = v12 & 0xFFFFFFBF;
      }
    }
    Shape::Reset((void **)this, *((_DWORD *)a2 + 4));
    uint64_t v13 = *((int *)a2 + 4);
    *((_DWORD *)this + 4) = v13;
    *((_DWORD *)this + 8) = *((_DWORD *)a2 + 8);
    int v14 = *((_DWORD *)a2 + 13) & 3;
    *((_DWORD *)this + 12) = *((_DWORD *)a2 + 12);
    *((_DWORD *)this + 13) = v14;
    memcpy(*((void **)this + 3), *((const void **)a2 + 3), 28 * v13);
    BOOL v15 = (void *)*((void *)this + 5);
    double v16 = (const void *)*((void *)a2 + 5);
    size_t v17 = 32 * *((int *)this + 8);
    return (void **)memcpy(v15, v16, v17);
  }
  else
  {
    return Shape::Reset((void **)this, 0);
  }
}

void **Shape::Reset(void **this, int a2)
{
  int v3 = this;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_DWORD *)this + 12) = 1;
  if (*((_DWORD *)this + 5) < a2)
  {
    *((_DWORD *)this + 5) = a2;
    this = (void **)malloc_type_realloc(this[3], 28 * a2, 0x100004027586B93uLL);
    void v3[3] = this;
    int v4 = *((_DWORD *)v3 + 13);
    if ((v4 & 4) != 0)
    {
      this = (void **)malloc_type_realloc(v3[11], 48 * *((int *)v3 + 5), 0x102004023ED6C3AuLL);
      v3[11] = this;
      int v4 = *((_DWORD *)v3 + 13);
    }
    if ((v4 & 0x400) != 0)
    {
      this = (void **)malloc_type_realloc(v3[13], 8 * *((int *)v3 + 5), 0x100004000313F17uLL);
      v3[13] = this;
    }
  }
  if (*((_DWORD *)v3 + 9) >= a2) {
    goto LABEL_13;
  }
  *((_DWORD *)v3 + 9) = a2;
  this = (void **)malloc_type_realloc(v3[5], 32 * a2, 0x1000040E0EAB150uLL);
  v3[5] = this;
  int v5 = *((_DWORD *)v3 + 13);
  if ((v5 & 8) != 0)
  {
    this = (void **)malloc_type_realloc(v3[7], (uint64_t)*((int *)v3 + 9) << 6, 0x100004094D12286uLL);
    v3[7] = this;
    int v5 = *((_DWORD *)v3 + 13);
    if ((v5 & 0x20) == 0)
    {
LABEL_9:
      if ((v5 & 0x10) == 0) {
        goto LABEL_10;
      }
LABEL_18:
      this = (void **)malloc_type_realloc(v3[8], 56 * *((int *)v3 + 9), 0x10A0040A41B8C3EuLL);
      v3[8] = this;
      int v5 = *((_DWORD *)v3 + 13);
      if ((v5 & 0x200) == 0)
      {
LABEL_11:
        if ((v5 & 0x400) == 0) {
          goto LABEL_13;
        }
        goto LABEL_12;
      }
      goto LABEL_19;
    }
  }
  else if ((v5 & 0x20) == 0)
  {
    goto LABEL_9;
  }
  this = (void **)malloc_type_realloc(v3[9], 32 * *((int *)v3 + 9), 0x1080040DCAC275BuLL);
  v3[9] = this;
  int v5 = *((_DWORD *)v3 + 13);
  if ((v5 & 0x10) != 0) {
    goto LABEL_18;
  }
LABEL_10:
  if ((v5 & 0x200) == 0) {
    goto LABEL_11;
  }
LABEL_19:
  this = (void **)malloc_type_realloc(v3[12], 16 * *((int *)v3 + 9), 0x1000040451B5BE8uLL);
  v3[12] = this;
  if ((*((_DWORD *)v3 + 13) & 0x400) != 0)
  {
LABEL_12:
    this = (void **)malloc_type_realloc(v3[14], 40 * *((int *)v3 + 9), 0x10000400A747E1EuLL);
    v3[14] = this;
  }
LABEL_13:
  if ((*((_DWORD *)v3 + 13) & 3) != 0) {
    *((_DWORD *)v3 + 13) &= *((_DWORD *)v3 + 13) & 2 ^ 0xFFFFFFFE;
  }
  return this;
}

BOOL Shape::GetFlag(Shape *this, int a2)
{
  return (*((_DWORD *)this + 13) & a2) != 0;
}

uint64_t Shape::SetFlag(Shape *this, int a2, int a3)
{
  int v3 = *((_DWORD *)this + 13);
  int v4 = v3 & a2;
  if (a3)
  {
    if (!v4)
    {
      int v5 = v3 | a2;
LABEL_6:
      *((_DWORD *)this + 13) = v5;
      return 1;
    }
  }
  else if (v4)
  {
    int v5 = v3 & ~a2;
    goto LABEL_6;
  }
  return 0;
}

uint64_t Shape::AddPoint(Shape *this, float a2, float a3)
{
  uint64_t v6 = *((int *)this + 4);
  if ((int)v6 >= *((_DWORD *)this + 5))
  {
    uint64_t v7 = (2 * v6) | 1;
    *((_DWORD *)this + 5) = v7;
    *((void *)this + 3) = malloc_type_realloc(*((void **)this + 3), 28 * v7, 0x100004027586B93uLL);
    int v8 = *((_DWORD *)this + 13);
    if ((v8 & 4) != 0)
    {
      *((void *)this + 11) = malloc_type_realloc(*((void **)this + 11), 48 * *((int *)this + 5), 0x102004023ED6C3AuLL);
      int v8 = *((_DWORD *)this + 13);
    }
    if ((v8 & 0x400) != 0) {
      *((void *)this + 13) = malloc_type_realloc(*((void **)this + 13), 8 * *((int *)this + 5), 0x100004000313F17uLL);
    }
  }
  uint64_t result = *((int *)this + 4);
  *((_DWORD *)this + 4) = result + 1;
  uint64_t v10 = *((void *)this + 3) + 28 * (int)result;
  *(float *)uint64_t v10 = a2;
  *(float *)(v10 + 4) = a3;
  *(_OWORD *)(v10 + 8) = xmmword_223839E40;
  int v11 = *((_DWORD *)this + 13);
  if ((v11 & 4) != 0)
  {
    uint64_t v12 = *((void *)this + 11) + 48 * (int)result;
    *(void *)(v12 + 8) = 0xFFFFFFFF00000000;
    *(_DWORD *)(v12 + 16) = -1;
    *(void *)(v12 + 24) = 0;
    *(_DWORD *)(v12 + 32) = -1;
    if ((v11 & 0x400) == 0)
    {
LABEL_8:
      if (v11) {
        return result;
      }
      goto LABEL_9;
    }
  }
  else if ((v11 & 0x400) == 0)
  {
    goto LABEL_8;
  }
  *(void *)(*((void *)this + 13) + 8 * result) = 0xFFFFFFFE00000000;
  if (v11) {
    return result;
  }
LABEL_9:
  *((_DWORD *)this + 13) = v11 | 1;
  return result;
}

uint64_t Shape::SubPoint(uint64_t this, int a2)
{
  if ((a2 & 0x80000000) == 0)
  {
    uint64_t v2 = this;
    int v3 = *(_DWORD *)(this + 16);
    if (v3 > a2)
    {
      int v4 = *(_DWORD *)(this + 52);
      if ((v4 & 1) == 0) {
        *(_DWORD *)(this + 52) = v4 | 1;
      }
      uint64_t v5 = *(void *)(this + 24) + 28 * a2;
      unsigned int v8 = *(_DWORD *)(v5 + 16);
      uint64_t v6 = (void *)(v5 + 16);
      uint64_t v7 = v8;
      if ((v8 & 0x80000000) == 0)
      {
        int v9 = *(_DWORD *)(this + 32);
        do
        {
          if ((int)v7 >= v9) {
            break;
          }
          uint64_t v10 = *(void *)(this + 40);
          int v11 = (_DWORD *)(v10 + 32 * v7);
          uint64_t v12 = v11 + 2;
          if (v11[2] == a2)
          {
            uint64_t v13 = v11 + 4;
            int v14 = v11 + 5;
          }
          else
          {
            int v16 = v11[3];
            BOOL v15 = v11 + 3;
            if (v16 != a2) {
              break;
            }
            uint64_t v17 = v10 + 32 * v7;
            uint64_t v13 = (_DWORD *)(v17 + 24);
            int v14 = (_DWORD *)(v17 + 28);
            uint64_t v12 = v15;
          }
          uint64_t v7 = *v13;
          *int v14 = -1;
          *uint64_t v13 = -1;
          *uint64_t v12 = -1;
        }
        while ((v7 & 0x80000000) == 0);
      }
      *uint64_t v6 = -1;
      int v18 = v3 - 1;
      if (v3 - 1 > a2)
      {
        this = Shape::SwapPoints(this, a2, v18);
        int v18 = *(_DWORD *)(v2 + 16) - 1;
      }
      *(_DWORD *)(v2 + 16) = v18;
    }
  }
  return this;
}

uint64_t Shape::SwapPoints(uint64_t this, int a2, int a3)
{
  if (a2 == a3) {
    return this;
  }
  uint64_t v3 = *(void *)(this + 24);
  if (*(_DWORD *)(v3 + 28 * a2 + 12) + *(_DWORD *)(v3 + 28 * a2 + 8) == 2
    && *(_DWORD *)(v3 + 28 * a3 + 12) + *(_DWORD *)(v3 + 28 * a3 + 8) == 2)
  {
    uint64_t v4 = a3;
    uint64_t v5 = *(int *)(v3 + 28 * a2 + 16);
    uint64_t v6 = *(void *)(this + 40);
    uint64_t v7 = v6 + 32 * v5;
    unsigned int v8 = (_DWORD *)(v7 + 8);
    int v9 = (_DWORD *)(v7 + 8);
    if (*(_DWORD *)(v7 + 8) != a2)
    {
      int v11 = *(_DWORD *)(v7 + 12);
      uint64_t v10 = (_DWORD *)(v7 + 12);
      if (v11 != a2) {
        goto LABEL_8;
      }
      int v9 = v10;
    }
    *int v9 = *(_DWORD *)(this + 16);
LABEL_8:
    uint64_t v12 = *(int *)(v3 + 28 * a2 + 20);
    uint64_t v13 = v6 + 32 * v12;
    int v14 = (_DWORD *)(v13 + 8);
    BOOL v15 = (_DWORD *)(v13 + 8);
    if (*(_DWORD *)(v13 + 8) != a2)
    {
      int v17 = *(_DWORD *)(v13 + 12);
      int v16 = (_DWORD *)(v13 + 12);
      if (v17 != a2) {
        goto LABEL_12;
      }
      BOOL v15 = v16;
    }
    *BOOL v15 = *(_DWORD *)(this + 16);
LABEL_12:
    uint64_t v18 = v6 + 32 * *(int *)(v3 + 28 * a3 + 16);
    uint64_t v19 = (_DWORD *)(v18 + 8);
    if (*(_DWORD *)(v18 + 8) != a3)
    {
      int v21 = *(_DWORD *)(v18 + 12);
      uint64_t v20 = (_DWORD *)(v18 + 12);
      if (v21 != a3) {
        goto LABEL_16;
      }
      uint64_t v19 = v20;
    }
    *uint64_t v19 = a2;
LABEL_16:
    uint64_t v22 = v6 + 32 * *(int *)(v3 + 28 * a3 + 20);
    long long v23 = (_DWORD *)(v22 + 8);
    if (*(_DWORD *)(v22 + 8) != a3)
    {
      int v25 = *(_DWORD *)(v22 + 12);
      double v24 = (_DWORD *)(v22 + 12);
      if (v25 != a3) {
        goto LABEL_20;
      }
      long long v23 = v24;
    }
    *long long v23 = a2;
LABEL_20:
    int v26 = *(_DWORD *)(this + 16);
    if (*v8 == v26 || (uint64_t v27 = v6 + 32 * v5, v28 = *(_DWORD *)(v27 + 12), v8 = (_DWORD *)(v27 + 12), v28 == v26)) {
      *unsigned int v8 = a3;
    }
    if (*v14 == v26 || (v29 = v6 + 32 * v12, v30 = *(_DWORD *)(v29 + 12), int v14 = (_DWORD *)(v29 + 12), v30 == v26)) {
      *int v14 = a3;
    }
    goto LABEL_56;
  }
  uint64_t v31 = *(unsigned int *)(v3 + 28 * a2 + 16);
  if ((v31 & 0x80000000) == 0)
  {
    uint64_t v32 = *(void *)(this + 40);
    uint64_t v33 = *(unsigned int *)(v3 + 28 * a2 + 16);
    do
    {
      unsigned int v34 = (_DWORD *)(v32 + 32 * v33);
      if (v34[2] == a2)
      {
        uint64_t v33 = v34[4];
        unsigned int v35 = v34 + 2;
      }
      else
      {
        int v36 = v34[3];
        unsigned int v35 = v34 + 3;
        if (v36 == a2) {
          uint64_t v33 = *(unsigned int *)(v32 + 32 * v33 + 24);
        }
        else {
          uint64_t v33 = 0xFFFFFFFFLL;
        }
        if (*v35 != a2) {
          continue;
        }
      }
      *unsigned int v35 = *(_DWORD *)(this + 16);
    }
    while ((v33 & 0x80000000) == 0);
  }
  uint64_t v4 = a3;
  uint64_t v37 = *(unsigned int *)(v3 + 28 * a3 + 16);
  if ((v37 & 0x80000000) == 0)
  {
    uint64_t v38 = *(void *)(this + 40);
    do
    {
      float v39 = (_DWORD *)(v38 + 32 * v37);
      if (v39[2] == a3)
      {
        uint64_t v37 = v39[4];
        float v40 = v39 + 2;
      }
      else
      {
        int v41 = v39[3];
        float v40 = v39 + 3;
        if (v41 == a3) {
          uint64_t v37 = *(unsigned int *)(v38 + 32 * v37 + 24);
        }
        else {
          uint64_t v37 = 0xFFFFFFFFLL;
        }
        if (*v40 != a3) {
          continue;
        }
      }
      *float v40 = a2;
    }
    while ((v37 & 0x80000000) == 0);
  }
  if ((v31 & 0x80000000) == 0)
  {
    int v42 = *(_DWORD *)(this + 16);
    uint64_t v43 = *(void *)(this + 40);
    do
    {
      float v44 = (_DWORD *)(v43 + 32 * v31);
      if (v44[2] == v42)
      {
        uint64_t v31 = v44[4];
        int v45 = v44 + 2;
      }
      else
      {
        int v46 = v44[3];
        int v45 = v44 + 3;
        if (v46 == v42) {
          uint64_t v31 = *(unsigned int *)(v43 + 32 * v31 + 24);
        }
        else {
          uint64_t v31 = 0xFFFFFFFFLL;
        }
        if (*v45 != v42) {
          continue;
        }
      }
      *int v45 = a3;
    }
    while ((v31 & 0x80000000) == 0);
  }
LABEL_56:
  int v47 = (_OWORD *)(v3 + 28 * a2);
  *(_OWORD *)float v63 = *v47;
  *(_OWORD *)&v63[12] = *(_OWORD *)((char *)v47 + 12);
  int v48 = (_OWORD *)(v3 + 28 * v4);
  long long v49 = *(_OWORD *)((char *)v48 + 12);
  *int v47 = *v48;
  *(_OWORD *)((char *)v47 + 12) = v49;
  float v50 = (_OWORD *)(*(void *)(this + 24) + 28 * v4);
  *float v50 = *(_OWORD *)v63;
  *(_OWORD *)((char *)v50 + 12) = *(_OWORD *)&v63[12];
  int v51 = *(_DWORD *)(this + 52);
  if ((v51 & 4) != 0)
  {
    uint64_t v52 = *(void *)(this + 88);
    float v53 = (long long *)(v52 + 48 * a2);
    long long v55 = v53[1];
    long long v54 = v53[2];
    long long v56 = *v53;
    float v57 = (long long *)(v52 + 48 * v4);
    long long v59 = v57[1];
    long long v58 = v57[2];
    *float v53 = *v57;
    v53[1] = v59;
    v53[2] = v58;
    float v60 = (_OWORD *)(*(void *)(this + 88) + 48 * v4);
    *float v60 = v56;
    v60[1] = v55;
    v60[2] = v54;
    int v51 = *(_DWORD *)(this + 52);
  }
  if ((v51 & 0x400) != 0)
  {
    uint64_t v61 = *(void *)(this + 104);
    uint64_t v62 = *(void *)(v61 + 8 * a2);
    *(void *)(v61 + 8 * a2) = *(void *)(v61 + 8 * v4);
    *(void *)(*(void *)(this + 104) + 8 * v4) = v62;
  }
  return this;
}

uint64_t Shape::SwapPoints(uint64_t this, int a2, int a3, int a4)
{
  if (a2 != a4 && a2 != a3 && a3 != a4)
  {
    uint64_t v6 = this;
    Shape::SwapPoints(this, a2, a3);
    return Shape::SwapPoints(v6, a3, a4);
  }
  return this;
}

Shape *Shape::SortPoints(Shape *this)
{
  int v1 = *((_DWORD *)this + 13);
  if (v1)
  {
    uint64_t v2 = this;
    int v3 = *((_DWORD *)this + 4);
    if (v3 < 1 || (this = Shape::SortPoints(this, 0, v3 - 1), int v1 = *((_DWORD *)v2 + 13), (v1 & 1) != 0)) {
      *((_DWORD *)v2 + 13) = v1 & 0xFFFFFFFE;
    }
  }
  return this;
}

Shape *Shape::SortPoints(Shape *this, int a2, int a3)
{
  if (a2 < a3)
  {
    int v4 = a2;
    uint64_t v5 = this;
    while (v4 + 1 != a3)
    {
      int v6 = v4 + a3;
      if (v4 + a3 < 0 != __OFADD__(v4, a3)) {
        ++v6;
      }
      int v7 = v6 >> 1;
      unsigned int v8 = (float *)(*((void *)v5 + 3) + 28 * (v6 >> 1));
      float v9 = *v8;
      float v10 = v8[1];
      BOOL v11 = v6 >> 1 < a3;
      BOOL v12 = v4 < v6 >> 1;
      if (v12 || v7 < a3)
      {
        int v14 = a3;
        int v15 = v4;
        int v13 = v7;
        do
        {
          if (v12)
          {
            do
            {
              int v16 = (float *)(*((void *)v5 + 3) + 28 * v15);
              float v17 = v16[1];
              if (v17 > v10) {
                break;
              }
              if (v17 != v10) {
                goto LABEL_19;
              }
              if (*v16 > v9) {
                break;
              }
              if (*v16 == v9)
              {
                if (v15 >= v13 - 1)
                {
                  if (v15 == v13 - 1) {
                    --v13;
                  }
                  if (v11)
                  {
                    while (1)
                    {
LABEL_22:
                      uint64_t v18 = (float *)(*((void *)v5 + 3) + 28 * v14);
                      float v19 = v18[1];
                      if (v19 > v10) {
                        goto LABEL_25;
                      }
                      if (v19 != v10) {
                        goto LABEL_30;
                      }
                      if (*v18 <= v9)
                      {
                        if (*v18 != v9) {
                          goto LABEL_30;
                        }
                        if (v14 <= v7 + 1)
                        {
                          if (v14 == v7 + 1) {
                            ++v7;
                          }
                          goto LABEL_30;
                        }
                        Shape::SwapPoints((uint64_t)v5, v14, v7 + 1, v7);
                        ++v7;
                      }
                      else
                      {
LABEL_25:
                        --v14;
                      }
                      if (v14 <= v7) {
                        goto LABEL_30;
                      }
                    }
                  }
                  goto LABEL_30;
                }
                Shape::SwapPoints((uint64_t)v5, v15, v13 - 1, v13);
                --v13;
              }
              else
              {
LABEL_19:
                ++v15;
              }
            }
            while (v15 < v13);
          }
          if (v11) {
            goto LABEL_22;
          }
LABEL_30:
          if (v15 >= v13)
          {
            if (v14 <= v7 + 1)
            {
              if (v14 != v7 + 1) {
                break;
              }
              Shape::SwapPoints((uint64_t)v5, v13++, v14);
              int v7 = v14;
            }
            else
            {
              Shape::SwapPoints((uint64_t)v5, ++v7, v13++, v14);
            }
          }
          else if (v14 <= v7)
          {
            if (v15 >= v13 - 1)
            {
              if (v15 == v13 - 1)
              {
                Shape::SwapPoints((uint64_t)v5, v7--, v15);
                int v13 = v15;
              }
            }
            else
            {
              Shape::SwapPoints((uint64_t)v5, --v13, v7--, v15);
            }
          }
          else
          {
            Shape::SwapPoints((uint64_t)v5, v15++, v14--);
          }
          BOOL v11 = v14 > v7;
          BOOL v12 = v15 < v13;
        }
        while (v15 < v13 || v14 > v7);
      }
      else
      {
        int v13 = v7;
      }
      this = (Shape *)Shape::SortPoints(v5, v4, v13 - 1);
      int v4 = v7 + 1;
      if (v7 + 1 >= a3) {
        return this;
      }
    }
    uint64_t v20 = *((void *)v5 + 3);
    int v21 = (float *)(v20 + 28 * v4);
    float v22 = v21[1];
    long long v23 = (float *)(v20 + 28 * a3);
    float v24 = v23[1];
    if (v22 > v24 || v22 == v24 && *v21 > *v23)
    {
      return (Shape *)Shape::SwapPoints((uint64_t)v5, v4, a3);
    }
  }
  return this;
}

Shape *Shape::SortPointsRounded(Shape *this)
{
  int v1 = *((_DWORD *)this + 4);
  if (v1 >= 1) {
    return Shape::SortPointsRounded(this, 0, v1 - 1);
  }
  return this;
}

Shape *Shape::SortPointsRounded(Shape *this, int a2, int a3)
{
  if (a2 < a3)
  {
    int v4 = a2;
    uint64_t v5 = this;
    while (v4 + 1 != a3)
    {
      int v6 = v4 + a3;
      if (v4 + a3 < 0 != __OFADD__(v4, a3)) {
        ++v6;
      }
      int v7 = v6 >> 1;
      uint64_t v8 = *((void *)v5 + 11) + 48 * (v6 >> 1);
      float v9 = *(float *)(v8 + 36);
      float v10 = *(float *)(v8 + 40);
      BOOL v11 = v6 >> 1 < a3;
      BOOL v12 = v4 < v6 >> 1;
      if (v12 || v7 < a3)
      {
        int v14 = a3;
        int v15 = v4;
        int v13 = v7;
        do
        {
          if (v12)
          {
            do
            {
              uint64_t v16 = *((void *)v5 + 11);
              float v17 = *(float *)(v16 + 48 * v15 + 40);
              if (v17 > v10) {
                break;
              }
              if (v17 != v10) {
                goto LABEL_19;
              }
              float v18 = *(float *)(v16 + 48 * v15 + 36);
              if (v18 > v9) {
                break;
              }
              if (v18 == v9)
              {
                if (v15 >= v13 - 1)
                {
                  if (v15 == v13 - 1) {
                    --v13;
                  }
                  if (v11)
                  {
                    while (1)
                    {
LABEL_22:
                      uint64_t v19 = *((void *)v5 + 11);
                      float v20 = *(float *)(v19 + 48 * v14 + 40);
                      if (v20 > v10) {
                        goto LABEL_25;
                      }
                      if (v20 != v10) {
                        goto LABEL_30;
                      }
                      float v21 = *(float *)(v19 + 48 * v14 + 36);
                      if (v21 <= v9)
                      {
                        if (v21 != v9) {
                          goto LABEL_30;
                        }
                        if (v14 <= v7 + 1)
                        {
                          if (v14 == v7 + 1) {
                            ++v7;
                          }
                          goto LABEL_30;
                        }
                        Shape::SwapPoints((uint64_t)v5, v14, v7 + 1, v7);
                        ++v7;
                      }
                      else
                      {
LABEL_25:
                        --v14;
                      }
                      if (v14 <= v7) {
                        goto LABEL_30;
                      }
                    }
                  }
                  goto LABEL_30;
                }
                Shape::SwapPoints((uint64_t)v5, v15, v13 - 1, v13);
                --v13;
              }
              else
              {
LABEL_19:
                ++v15;
              }
            }
            while (v15 < v13);
          }
          if (v11) {
            goto LABEL_22;
          }
LABEL_30:
          if (v15 >= v13)
          {
            if (v14 <= v7 + 1)
            {
              if (v14 != v7 + 1) {
                break;
              }
              Shape::SwapPoints((uint64_t)v5, v13++, v14);
              int v7 = v14;
            }
            else
            {
              Shape::SwapPoints((uint64_t)v5, ++v7, v13++, v14);
            }
          }
          else if (v14 <= v7)
          {
            if (v15 >= v13 - 1)
            {
              if (v15 == v13 - 1)
              {
                Shape::SwapPoints((uint64_t)v5, v7--, v15);
                int v13 = v15;
              }
            }
            else
            {
              Shape::SwapPoints((uint64_t)v5, --v13, v7--, v15);
            }
          }
          else
          {
            Shape::SwapPoints((uint64_t)v5, v15++, v14--);
          }
          BOOL v11 = v14 > v7;
          BOOL v12 = v15 < v13;
        }
        while (v15 < v13 || v14 > v7);
      }
      else
      {
        int v13 = v7;
      }
      this = (Shape *)Shape::SortPointsRounded(v5, v4, v13 - 1);
      int v4 = v7 + 1;
      if (v7 + 1 >= a3) {
        return this;
      }
    }
    uint64_t v22 = *((void *)v5 + 11);
    float v23 = *(float *)(v22 + 48 * v4 + 40);
    float v24 = *(float *)(v22 + 48 * a3 + 40);
    if (v23 > v24 || v23 == v24 && *(float *)(v22 + 48 * v4 + 36) > *(float *)(v22 + 48 * a3 + 36))
    {
      return (Shape *)Shape::SwapPoints((uint64_t)v5, v4, a3);
    }
  }
  return this;
}

Shape *Shape::SortPointsByOldInd(Shape *this, int a2, int a3)
{
  if (a2 < a3)
  {
    int v3 = this;
    int v26 = a3;
    while (a2 + 1 != a3)
    {
      int v4 = a2 + a3;
      if (a2 + a3 < 0 != __OFADD__(a2, a3)) {
        ++v4;
      }
      int v5 = v4 >> 1;
      int v6 = (float *)(*((void *)v3 + 3) + 28 * (v4 >> 1));
      float v7 = *v6;
      float v8 = v6[1];
      int v9 = *(_DWORD *)(*((void *)v3 + 11) + 48 * (v4 >> 1));
      BOOL v10 = v4 >> 1 < a3;
      BOOL v11 = a2 < v4 >> 1;
      int v27 = a2;
      if (v11 || v5 < a3)
      {
        int v13 = a3;
        int v14 = a2;
        int v12 = v5;
        do
        {
          if (v11)
          {
            do
            {
              int v15 = (float *)(*((void *)v3 + 3) + 28 * v14);
              float v16 = v15[1];
              if (v16 > v8) {
                break;
              }
              if (v16 != v8) {
                goto LABEL_19;
              }
              if (*v15 > v7) {
                break;
              }
              if (*v15 != v7) {
                goto LABEL_19;
              }
              int v17 = *(_DWORD *)(*((void *)v3 + 11) + 48 * v14);
              if (v17 > v9) {
                break;
              }
              if (v17 == v9)
              {
                if (v14 >= v12 - 1)
                {
                  if (v14 == v12 - 1) {
                    --v12;
                  }
                  if (v10)
                  {
                    while (1)
                    {
LABEL_22:
                      float v18 = (float *)(*((void *)v3 + 3) + 28 * v13);
                      float v19 = v18[1];
                      if (v19 > v8) {
                        goto LABEL_27;
                      }
                      if (v19 != v8) {
                        goto LABEL_39;
                      }
                      if (*v18 > v7) {
                        goto LABEL_27;
                      }
                      if (*v18 != v7) {
                        goto LABEL_39;
                      }
                      int v20 = *(_DWORD *)(*((void *)v3 + 11) + 48 * v13);
                      if (v20 <= v9)
                      {
                        if (v20 != v9) {
                          goto LABEL_39;
                        }
                        if (v13 <= v5 + 1)
                        {
                          if (v13 == v5 + 1) {
                            ++v5;
                          }
                          goto LABEL_39;
                        }
                        Shape::SwapPoints((uint64_t)v3, v13, v5 + 1, v5);
                        ++v5;
                      }
                      else
                      {
LABEL_27:
                        --v13;
                      }
                      if (v13 <= v5) {
                        goto LABEL_39;
                      }
                    }
                  }
                  goto LABEL_39;
                }
                Shape::SwapPoints((uint64_t)v3, v14, v12 - 1, v12);
                --v12;
              }
              else
              {
LABEL_19:
                ++v14;
              }
            }
            while (v14 < v12);
          }
          if (v10) {
            goto LABEL_22;
          }
LABEL_39:
          if (v14 >= v12)
          {
            if (v13 <= v5 + 1)
            {
              if (v13 != v5 + 1) {
                break;
              }
              Shape::SwapPoints((uint64_t)v3, v12++, v13);
              int v5 = v13;
            }
            else
            {
              Shape::SwapPoints((uint64_t)v3, ++v5, v12++, v13);
            }
          }
          else if (v13 <= v5)
          {
            if (v14 >= v12 - 1)
            {
              if (v14 == v12 - 1)
              {
                Shape::SwapPoints((uint64_t)v3, v5--, v14);
                int v12 = v14;
              }
            }
            else
            {
              Shape::SwapPoints((uint64_t)v3, --v12, v5--, v14);
            }
          }
          else
          {
            Shape::SwapPoints((uint64_t)v3, v14++, v13--);
          }
          BOOL v10 = v13 > v5;
          BOOL v11 = v14 < v12;
        }
        while (v14 < v12 || v13 > v5);
      }
      else
      {
        int v12 = v5;
      }
      this = (Shape *)Shape::SortPointsByOldInd(v3, v27, v12 - 1);
      a2 = v5 + 1;
      a3 = v26;
      if (v5 + 1 >= v26) {
        return this;
      }
    }
    uint64_t v21 = *((void *)v3 + 3);
    uint64_t v22 = (float *)(v21 + 28 * a2);
    float v23 = v22[1];
    float v24 = (float *)(v21 + 28 * a3);
    float v25 = v24[1];
    if (v23 > v25
      || v23 == v25
      && (*v22 > *v24
       || *v22 == *v24 && *(_DWORD *)(*((void *)v3 + 11) + 48 * a2) > *(_DWORD *)(*((void *)v3 + 11) + 48 * a3)))
    {
      return (Shape *)Shape::SwapPoints((uint64_t)v3, a2, a3);
    }
  }
  return this;
}

uint64_t Shape::AddEdge(Shape *this, unsigned int a2, unsigned int a3)
{
  uint64_t v3 = 0xFFFFFFFFLL;
  if (a2 == a3 || ((a3 | a2) & 0x80000000) != 0) {
    return v3;
  }
  *((_DWORD *)this + 12) = 0;
  int v7 = *((_DWORD *)this + 8);
  if (v7 < *((_DWORD *)this + 9)) {
    goto LABEL_11;
  }
  int v8 = (2 * v7) | 1;
  *((_DWORD *)this + 9) = v8;
  *((void *)this + 5) = malloc_type_realloc(*((void **)this + 5), 32 * v8, 0x1000040E0EAB150uLL);
  int v9 = *((_DWORD *)this + 13);
  if ((v9 & 8) != 0)
  {
    *((void *)this + 7) = malloc_type_realloc(*((void **)this + 7), (uint64_t)*((int *)this + 9) << 6, 0x100004094D12286uLL);
    int v9 = *((_DWORD *)this + 13);
    if ((v9 & 0x10) == 0)
    {
LABEL_6:
      if ((v9 & 0x20) == 0) {
        goto LABEL_7;
      }
      goto LABEL_25;
    }
  }
  else if ((v9 & 0x10) == 0)
  {
    goto LABEL_6;
  }
  *((void *)this + 8) = malloc_type_realloc(*((void **)this + 8), 56 * *((int *)this + 9), 0x10A0040A41B8C3EuLL);
  int v9 = *((_DWORD *)this + 13);
  if ((v9 & 0x20) == 0)
  {
LABEL_7:
    if ((v9 & 0x80) == 0) {
      goto LABEL_8;
    }
LABEL_26:
    *((void *)this + 10) = malloc_type_realloc(*((void **)this + 10), 48 * *((int *)this + 9), 0x10200403C9B7522uLL);
    int v9 = *((_DWORD *)this + 13);
    if ((v9 & 0x200) == 0)
    {
LABEL_9:
      if ((v9 & 0x400) == 0) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
    goto LABEL_27;
  }
LABEL_25:
  *((void *)this + 9) = malloc_type_realloc(*((void **)this + 9), 32 * *((int *)this + 9), 0x1080040DCAC275BuLL);
  int v9 = *((_DWORD *)this + 13);
  if ((v9 & 0x80) != 0) {
    goto LABEL_26;
  }
LABEL_8:
  if ((v9 & 0x200) == 0) {
    goto LABEL_9;
  }
LABEL_27:
  *((void *)this + 12) = malloc_type_realloc(*((void **)this + 12), 16 * *((int *)this + 9), 0x1000040451B5BE8uLL);
  if ((*((_DWORD *)this + 13) & 0x400) != 0) {
LABEL_10:
  }
    *((void *)this + 14) = malloc_type_realloc(*((void **)this + 14), 40 * *((int *)this + 9), 0x10000400A747E1EuLL);
LABEL_11:
  uint64_t v3 = *((unsigned int *)this + 8);
  *((_DWORD *)this + 8) = v3 + 1;
  BOOL v10 = (float32x2_t *)(*((void *)this + 5) + 32 * (int)v3);
  v10[2] = (float32x2_t)-1;
  v10[3] = (float32x2_t)-1;
  v10[1] = (float32x2_t)-1;
  *BOOL v10 = vsub_f32(*(float32x2_t *)(*((void *)this + 3) + 28 * a3), *(float32x2_t *)(*((void *)this + 3) + 28 * a2));
  Shape::ConnectStart((uint64_t)this, a2, v3);
  Shape::ConnectEnd((uint64_t)this, a3, v3);
  int v11 = *((_DWORD *)this + 13);
  if ((v11 & 8) != 0)
  {
    uint64_t v13 = *((void *)this + 7) + ((uint64_t)(int)v3 << 6);
    *(_DWORD *)uint64_t v13 = 1;
    *(void *)(v13 + 4) = *(void *)(*((void *)this + 5) + 32 * (int)v3);
    if ((v11 & 0x10) == 0)
    {
LABEL_13:
      if ((v11 & 0x200) == 0) {
        goto LABEL_14;
      }
      goto LABEL_20;
    }
  }
  else if ((v11 & 0x10) == 0)
  {
    goto LABEL_13;
  }
  uint64_t v14 = *((void *)this + 8) + 56 * (int)v3;
  *(void *)uint64_t v14 = 0;
  *(_DWORD *)(v14 + 8) = -1;
  if ((v11 & 0x200) == 0)
  {
LABEL_14:
    if ((v11 & 0x400) == 0) {
      goto LABEL_15;
    }
LABEL_21:
    *(void *)(*((void *)this + 14) + 40 * (int)v3) = -1;
    if ((v11 & 2) != 0) {
      return v3;
    }
    goto LABEL_16;
  }
LABEL_20:
  int v15 = (void *)(*((void *)this + 12) + 16 * (int)v3);
  *int v15 = -1;
  v15[1] = 0;
  if ((v11 & 0x400) != 0) {
    goto LABEL_21;
  }
LABEL_15:
  if ((v11 & 2) == 0) {
LABEL_16:
  }
    *((_DWORD *)this + 13) = v11 | 2;
  return v3;
}

uint64_t Shape::ConnectStart(uint64_t this, int a2, int a3)
{
  uint64_t v5 = this;
  uint64_t v6 = *(void *)(this + 40);
  uint64_t v7 = a3;
  if ((*(_DWORD *)(v6 + 32 * a3 + 8) & 0x80000000) == 0)
  {
    this = Shape::DisconnectStart(this, a3);
    uint64_t v6 = *(void *)(v5 + 40);
  }
  int v8 = (_DWORD *)(v6 + 32 * v7);
  _OWORD v8[2] = a2;
  uint64_t v9 = *(void *)(v5 + 24);
  uint64_t v10 = v9 + 28 * a2;
  unsigned int v13 = *(_DWORD *)(v10 + 20);
  int v11 = (int *)(v10 + 20);
  uint64_t v12 = v13;
  ++*(v11 - 2);
  v8[4] = -1;
  v8[5] = v13;
  if ((v13 & 0x80000000) == 0)
  {
    uint64_t v14 = (_DWORD *)(v6 + 32 * v12);
    if (v14[2] == a2)
    {
      int v15 = v14 + 4;
    }
    else
    {
      if (v14[3] != a2) {
        goto LABEL_9;
      }
      int v15 = (int *)(v6 + 32 * v12 + 24);
    }
    *int v15 = a3;
  }
LABEL_9:
  int *v11 = a3;
  uint64_t v16 = v9 + 28 * a2;
  int v18 = *(_DWORD *)(v16 + 16);
  int v17 = (int *)(v16 + 16);
  if (v18 < 0) {
    *int v17 = a3;
  }
  return this;
}

uint64_t Shape::ConnectEnd(uint64_t this, int a2, int a3)
{
  uint64_t v5 = this;
  uint64_t v6 = *(void *)(this + 40);
  uint64_t v7 = a3;
  if ((*(_DWORD *)(v6 + 32 * a3 + 12) & 0x80000000) == 0)
  {
    this = Shape::DisconnectEnd(this, a3);
    uint64_t v6 = *(void *)(v5 + 40);
  }
  int v8 = (_DWORD *)(v6 + 32 * v7);
  v8[3] = a2;
  uint64_t v9 = *(void *)(v5 + 24);
  uint64_t v10 = v9 + 28 * a2;
  unsigned int v13 = *(_DWORD *)(v10 + 20);
  int v11 = (int *)(v10 + 20);
  uint64_t v12 = v13;
  ++*(v11 - 3);
  v8[6] = -1;
  v8[7] = v13;
  if ((v13 & 0x80000000) == 0)
  {
    uint64_t v14 = (_DWORD *)(v6 + 32 * v12);
    if (v14[2] == a2)
    {
      int v15 = v14 + 4;
    }
    else
    {
      if (v14[3] != a2) {
        goto LABEL_9;
      }
      int v15 = (int *)(v6 + 32 * v12 + 24);
    }
    *int v15 = a3;
  }
LABEL_9:
  int *v11 = a3;
  uint64_t v16 = v9 + 28 * a2;
  int v18 = *(_DWORD *)(v16 + 16);
  int v17 = (int *)(v16 + 16);
  if (v18 < 0) {
    *int v17 = a3;
  }
  return this;
}

uint64_t Shape::AddEdge(Shape *this, unsigned int a2, unsigned int a3, int a4, int a5)
{
  uint64_t v5 = 0xFFFFFFFFLL;
  if (a2 == a3 || ((a3 | a2) & 0x80000000) != 0) {
    return v5;
  }
  uint64_t v11 = *(unsigned int *)(*((void *)this + 3) + 28 * a2 + 16);
  if ((v11 & 0x80000000) != 0)
  {
LABEL_14:
    *((_DWORD *)this + 12) = 0;
    int v18 = *((_DWORD *)this + 8);
    if (v18 < *((_DWORD *)this + 9)) {
      goto LABEL_22;
    }
    int v19 = (2 * v18) | 1;
    *((_DWORD *)this + 9) = v19;
    *((void *)this + 5) = malloc_type_realloc(*((void **)this + 5), 32 * v19, 0x1000040E0EAB150uLL);
    int v20 = *((_DWORD *)this + 13);
    if ((v20 & 8) != 0)
    {
      *((void *)this + 7) = malloc_type_realloc(*((void **)this + 7), (uint64_t)*((int *)this + 9) << 6, 0x100004094D12286uLL);
      int v20 = *((_DWORD *)this + 13);
      if ((v20 & 0x10) == 0)
      {
LABEL_17:
        if ((v20 & 0x20) == 0) {
          goto LABEL_18;
        }
        goto LABEL_37;
      }
    }
    else if ((v20 & 0x10) == 0)
    {
      goto LABEL_17;
    }
    *((void *)this + 8) = malloc_type_realloc(*((void **)this + 8), 56 * *((int *)this + 9), 0x10A0040A41B8C3EuLL);
    int v20 = *((_DWORD *)this + 13);
    if ((v20 & 0x20) == 0)
    {
LABEL_18:
      if ((v20 & 0x80) == 0) {
        goto LABEL_19;
      }
      goto LABEL_38;
    }
LABEL_37:
    *((void *)this + 9) = malloc_type_realloc(*((void **)this + 9), 32 * *((int *)this + 9), 0x1080040DCAC275BuLL);
    int v20 = *((_DWORD *)this + 13);
    if ((v20 & 0x80) == 0)
    {
LABEL_19:
      if ((v20 & 0x200) == 0) {
        goto LABEL_20;
      }
      goto LABEL_39;
    }
LABEL_38:
    *((void *)this + 10) = malloc_type_realloc(*((void **)this + 10), 48 * *((int *)this + 9), 0x10200403C9B7522uLL);
    int v20 = *((_DWORD *)this + 13);
    if ((v20 & 0x200) == 0)
    {
LABEL_20:
      if ((v20 & 0x400) == 0) {
        goto LABEL_22;
      }
      goto LABEL_21;
    }
LABEL_39:
    *((void *)this + 12) = malloc_type_realloc(*((void **)this + 12), 16 * *((int *)this + 9), 0x1000040451B5BE8uLL);
    if ((*((_DWORD *)this + 13) & 0x400) == 0)
    {
LABEL_22:
      uint64_t v5 = *((unsigned int *)this + 8);
      *((_DWORD *)this + 8) = v5 + 1;
      uint64_t v21 = (float32x2_t *)(*((void *)this + 5) + 32 * (int)v5);
      v21[2] = (float32x2_t)-1;
      v21[3] = (float32x2_t)-1;
      v21[1] = (float32x2_t)-1;
      *uint64_t v21 = vsub_f32(*(float32x2_t *)(*((void *)this + 3) + 28 * a3), *(float32x2_t *)(*((void *)this + 3) + 28 * a2));
      Shape::ConnectStart((uint64_t)this, a2, v5);
      Shape::ConnectEnd((uint64_t)this, a3, v5);
      int v22 = *((_DWORD *)this + 13);
      if ((v22 & 8) != 0)
      {
        uint64_t v23 = *((void *)this + 7) + ((uint64_t)(int)v5 << 6);
        *(_DWORD *)uint64_t v23 = 1;
        *(void *)(v23 + 4) = *(void *)(*((void *)this + 5) + 32 * (int)v5);
        if ((v22 & 0x10) == 0)
        {
LABEL_24:
          if ((v22 & 0x200) == 0) {
            goto LABEL_25;
          }
          goto LABEL_30;
        }
      }
      else if ((v22 & 0x10) == 0)
      {
        goto LABEL_24;
      }
      uint64_t v24 = *((void *)this + 8) + 56 * (int)v5;
      *(void *)uint64_t v24 = 0;
      *(_DWORD *)(v24 + 8) = -1;
      if ((v22 & 0x200) == 0)
      {
LABEL_25:
        if ((v22 & 0x400) == 0) {
          goto LABEL_26;
        }
        goto LABEL_31;
      }
LABEL_30:
      float v25 = (void *)(*((void *)this + 12) + 16 * (int)v5);
      *float v25 = -1;
      v25[1] = 0;
      if ((v22 & 0x400) == 0)
      {
LABEL_26:
        if ((v22 & 2) != 0) {
          return v5;
        }
        goto LABEL_32;
      }
LABEL_31:
      int v26 = (_DWORD *)(*((void *)this + 14) + 40 * (int)v5);
      *int v26 = a4;
      v26[1] = a5;
      if ((v22 & 2) != 0) {
        return v5;
      }
LABEL_32:
      *((_DWORD *)this + 13) = v22 | 2;
      return v5;
    }
LABEL_21:
    *((void *)this + 14) = malloc_type_realloc(*((void **)this + 14), 40 * *((int *)this + 9), 0x10000400A747E1EuLL);
    goto LABEL_22;
  }
  uint64_t v12 = *((void *)this + 5);
  while (1)
  {
    uint64_t v13 = v12 + 32 * v11;
    int v14 = *(_DWORD *)(v13 + 8);
    if (v14 == a2 && *(_DWORD *)(v13 + 12) == a3) {
      return 0xFFFFFFFFLL;
    }
    if (v14 == a3 && *(_DWORD *)(v12 + 32 * v11 + 12) == a2) {
      return 0xFFFFFFFFLL;
    }
    int v15 = (_DWORD *)(v12 + 32 * v11);
    if (v14 == a2)
    {
      uint64_t v16 = v15 + 4;
    }
    else
    {
      if (v15[3] != a2) {
        goto LABEL_14;
      }
      uint64_t v16 = v15 + 6;
    }
    uint64_t v11 = *v16;
    if ((v11 & 0x80000000) != 0) {
      goto LABEL_14;
    }
  }
}

void Shape::SubEdge(Shape *this, int a2)
{
  if ((a2 & 0x80000000) == 0 && *((_DWORD *)this + 8) > a2)
  {
    *((_DWORD *)this + 12) = 0;
    Shape::DisconnectStart((uint64_t)this, a2);
    Shape::DisconnectEnd((uint64_t)this, a2);
    int v4 = *((_DWORD *)this + 8) - 1;
    if (v4 > a2)
    {
      Shape::SwapEdges(this, a2, v4);
      int v4 = *((_DWORD *)this + 8) - 1;
    }
    *((_DWORD *)this + 8) = v4;
    int v5 = *((_DWORD *)this + 13);
    if ((v5 & 2) == 0) {
      *((_DWORD *)this + 13) = v5 | 2;
    }
  }
}

uint64_t Shape::DisconnectStart(uint64_t this, int a2)
{
  uint64_t v2 = *(void *)(this + 40);
  uint64_t v3 = v2 + 32 * a2;
  int v4 = (_DWORD *)(v3 + 8);
  unsigned int v5 = *(_DWORD *)(v3 + 8);
  if ((v5 & 0x80000000) != 0) {
    return this;
  }
  uint64_t v6 = *(void *)(this + 24);
  --*(_DWORD *)(v6 + 28 * v5 + 12);
  unsigned int v9 = *(_DWORD *)(v3 + 20);
  uint64_t v7 = (_DWORD *)(v3 + 20);
  uint64_t v8 = v9;
  if ((v9 & 0x80000000) == 0)
  {
    uint64_t v10 = (_DWORD *)(v2 + 32 * v8);
    if (v10[2] == v5)
    {
      v10[4] = *(_DWORD *)(v2 + 32 * a2 + 16);
    }
    else if (v10[3] == v5)
    {
      *(_DWORD *)(v2 + 32 * v8 + 24) = *(_DWORD *)(v2 + 32 * a2 + 16);
    }
  }
  uint64_t v11 = *(unsigned int *)(v2 + 32 * a2 + 16);
  if ((v11 & 0x80000000) == 0)
  {
    uint64_t v12 = (_DWORD *)(v2 + 32 * v11);
    if (v12[2] == v5)
    {
      uint64_t v13 = v12 + 5;
LABEL_12:
      *uint64_t v13 = v8;
      goto LABEL_13;
    }
    if (v12[3] == v5)
    {
      uint64_t v13 = (_DWORD *)(v2 + 32 * v11 + 28);
      goto LABEL_12;
    }
  }
LABEL_13:
  uint64_t v14 = v6 + 28 * v5;
  int v16 = *(_DWORD *)(v14 + 16);
  int v15 = (_DWORD *)(v14 + 16);
  if (v16 == a2) {
    *int v15 = v11;
  }
  uint64_t v17 = v6 + 28 * v5;
  int v19 = *(_DWORD *)(v17 + 20);
  int v18 = (_DWORD *)(v17 + 20);
  if (v19 == a2) {
    *int v18 = *v7;
  }
  _DWORD *v4 = -1;
  return this;
}

uint64_t Shape::DisconnectEnd(uint64_t this, int a2)
{
  uint64_t v2 = *(void *)(this + 40);
  uint64_t v3 = v2 + 32 * a2;
  int v4 = (_DWORD *)(v3 + 12);
  unsigned int v5 = *(_DWORD *)(v3 + 12);
  if ((v5 & 0x80000000) != 0) {
    return this;
  }
  uint64_t v6 = *(void *)(this + 24);
  --*(_DWORD *)(v6 + 28 * v5 + 8);
  unsigned int v9 = *(_DWORD *)(v3 + 28);
  uint64_t v7 = (_DWORD *)(v3 + 28);
  uint64_t v8 = v9;
  if ((v9 & 0x80000000) == 0)
  {
    uint64_t v10 = (_DWORD *)(v2 + 32 * v8);
    if (v10[2] == v5)
    {
      v10[4] = *(_DWORD *)(v2 + 32 * a2 + 24);
    }
    else if (v10[3] == v5)
    {
      *(_DWORD *)(v2 + 32 * v8 + 24) = *(_DWORD *)(v2 + 32 * a2 + 24);
    }
  }
  uint64_t v11 = *(unsigned int *)(v2 + 32 * a2 + 24);
  if ((v11 & 0x80000000) == 0)
  {
    uint64_t v12 = (_DWORD *)(v2 + 32 * v11);
    if (v12[2] == v5)
    {
      uint64_t v13 = v12 + 5;
LABEL_12:
      *uint64_t v13 = v8;
      goto LABEL_13;
    }
    if (v12[3] == v5)
    {
      uint64_t v13 = (_DWORD *)(v2 + 32 * v11 + 28);
      goto LABEL_12;
    }
  }
LABEL_13:
  uint64_t v14 = v6 + 28 * v5;
  int v16 = *(_DWORD *)(v14 + 16);
  int v15 = (_DWORD *)(v14 + 16);
  if (v16 == a2) {
    *int v15 = v11;
  }
  uint64_t v17 = v6 + 28 * v5;
  int v19 = *(_DWORD *)(v17 + 20);
  int v18 = (_DWORD *)(v17 + 20);
  if (v19 == a2) {
    *int v18 = *v7;
  }
  _DWORD *v4 = -1;
  return this;
}

__n128 Shape::SwapEdges(Shape *this, int a2, int a3)
{
  if (a2 != a3)
  {
    uint64_t v3 = *((void *)this + 5);
    uint64_t v4 = v3 + 32 * a2;
    unsigned int v5 = (_DWORD *)(v4 + 20);
    uint64_t v6 = *(unsigned int *)(v4 + 20);
    if ((*(_DWORD *)(v4 + 20) & 0x80000000) == 0 && v6 != a3)
    {
      uint64_t v7 = (_DWORD *)(v3 + 32 * v6);
      int v8 = *(_DWORD *)(v3 + 32 * a2 + 8);
      if (v7[2] == v8)
      {
        unsigned int v9 = v7 + 4;
LABEL_8:
        *unsigned int v9 = a3;
        goto LABEL_9;
      }
      if (v7[3] == v8)
      {
        unsigned int v9 = (_DWORD *)(v3 + 32 * v6 + 24);
        goto LABEL_8;
      }
    }
LABEL_9:
    unsigned int v12 = *(_DWORD *)(v4 + 16);
    uint64_t v10 = (_DWORD *)(v4 + 16);
    uint64_t v11 = v12;
    if ((v12 & 0x80000000) == 0 && v11 != a3)
    {
      uint64_t v13 = (_DWORD *)(v3 + 32 * v11);
      int v14 = *(_DWORD *)(v3 + 32 * a2 + 8);
      if (v13[2] == v14)
      {
        int v15 = v13 + 5;
LABEL_15:
        *int v15 = a3;
        goto LABEL_16;
      }
      if (v13[3] == v14)
      {
        int v15 = (_DWORD *)(v3 + 32 * v11 + 28);
        goto LABEL_15;
      }
    }
LABEL_16:
    uint64_t v16 = v3 + 32 * a2;
    int v18 = (_DWORD *)(v16 + 28);
    uint64_t v17 = *(unsigned int *)(v16 + 28);
    if ((*(_DWORD *)(v16 + 28) & 0x80000000) == 0 && v17 != a3)
    {
      int v19 = (_DWORD *)(v3 + 32 * v17);
      int v20 = *(_DWORD *)(v3 + 32 * a2 + 12);
      if (v19[2] == v20)
      {
        uint64_t v21 = v19 + 4;
LABEL_22:
        *uint64_t v21 = a3;
        goto LABEL_23;
      }
      if (v19[3] == v20)
      {
        uint64_t v21 = (_DWORD *)(v3 + 32 * v17 + 24);
        goto LABEL_22;
      }
    }
LABEL_23:
    unsigned int v24 = *(_DWORD *)(v16 + 24);
    uint64_t v23 = (_DWORD *)(v16 + 24);
    uint64_t v22 = v24;
    if ((v24 & 0x80000000) == 0 && v22 != a3)
    {
      float v25 = (_DWORD *)(v3 + 32 * v22);
      int v26 = *(_DWORD *)(v3 + 32 * a2 + 12);
      if (v25[2] == v26)
      {
        int v27 = v25 + 5;
      }
      else
      {
        if (v25[3] != v26) {
          goto LABEL_30;
        }
        int v27 = (_DWORD *)(v3 + 32 * v22 + 28);
      }
      *int v27 = a3;
    }
LABEL_30:
    uint64_t v28 = v3 + 32 * a2;
    unsigned int v29 = *(_DWORD *)(v28 + 8);
    if ((v29 & 0x80000000) == 0)
    {
      uint64_t v30 = *((void *)this + 3);
      uint64_t v31 = v30 + 28 * v29;
      int v33 = *(_DWORD *)(v31 + 16);
      uint64_t v32 = (_DWORD *)(v31 + 16);
      if (v33 == a2) {
        *uint64_t v32 = *((_DWORD *)this + 8);
      }
      uint64_t v34 = v30 + 28 * v29;
      int v36 = *(_DWORD *)(v34 + 20);
      unsigned int v35 = (_DWORD *)(v34 + 20);
      if (v36 == a2) {
        *unsigned int v35 = *((_DWORD *)this + 8);
      }
    }
    unsigned int v37 = *(_DWORD *)(v28 + 12);
    if ((v37 & 0x80000000) == 0)
    {
      uint64_t v38 = *((void *)this + 3);
      uint64_t v39 = v38 + 28 * v37;
      int v41 = *(_DWORD *)(v39 + 16);
      float v40 = (_DWORD *)(v39 + 16);
      if (v41 == a2) {
        *float v40 = *((_DWORD *)this + 8);
      }
      uint64_t v42 = v38 + 28 * v37;
      int v44 = *(_DWORD *)(v42 + 20);
      uint64_t v43 = (_DWORD *)(v42 + 20);
      if (v44 == a2) {
        *uint64_t v43 = *((_DWORD *)this + 8);
      }
    }
    uint64_t v45 = v3 + 32 * a3;
    int v46 = (_DWORD *)(v45 + 20);
    uint64_t v47 = *(unsigned int *)(v45 + 20);
    if ((*(_DWORD *)(v45 + 20) & 0x80000000) == 0 && v47 != a2)
    {
      int v48 = (_DWORD *)(v3 + 32 * v47);
      int v49 = *(_DWORD *)(v3 + 32 * a3 + 8);
      if (v48[2] == v49)
      {
        float v50 = v48 + 4;
LABEL_46:
        *float v50 = a2;
        goto LABEL_47;
      }
      if (v48[3] == v49)
      {
        float v50 = (_DWORD *)(v3 + 32 * v47 + 24);
        goto LABEL_46;
      }
    }
LABEL_47:
    unsigned int v53 = *(_DWORD *)(v45 + 16);
    uint64_t v52 = (_DWORD *)(v45 + 16);
    uint64_t v51 = v53;
    if ((v53 & 0x80000000) == 0 && v51 != a2)
    {
      long long v54 = (_DWORD *)(v3 + 32 * v51);
      int v55 = *(_DWORD *)(v3 + 32 * a3 + 8);
      if (v54[2] == v55)
      {
        long long v56 = v54 + 5;
LABEL_53:
        *long long v56 = a2;
        goto LABEL_54;
      }
      if (v54[3] == v55)
      {
        long long v56 = (_DWORD *)(v3 + 32 * v51 + 28);
        goto LABEL_53;
      }
    }
LABEL_54:
    uint64_t v57 = v3 + 32 * a3;
    long long v58 = (_DWORD *)(v57 + 28);
    uint64_t v59 = *(unsigned int *)(v57 + 28);
    if ((*(_DWORD *)(v57 + 28) & 0x80000000) == 0 && v59 != a2)
    {
      float v60 = (_DWORD *)(v3 + 32 * v59);
      int v61 = *(_DWORD *)(v3 + 32 * a3 + 12);
      if (v60[2] == v61)
      {
        uint64_t v62 = v60 + 4;
LABEL_60:
        *uint64_t v62 = a2;
        goto LABEL_61;
      }
      if (v60[3] == v61)
      {
        uint64_t v62 = (_DWORD *)(v3 + 32 * v59 + 24);
        goto LABEL_60;
      }
    }
LABEL_61:
    unsigned int v65 = *(_DWORD *)(v57 + 24);
    float v63 = (_DWORD *)(v57 + 24);
    uint64_t v64 = v65;
    if ((v65 & 0x80000000) == 0 && v64 != a2)
    {
      float v66 = (_DWORD *)(v3 + 32 * v64);
      int v67 = *(_DWORD *)(v3 + 32 * a3 + 12);
      if (v66[2] == v67)
      {
        uint64_t v68 = v66 + 5;
      }
      else
      {
        if (v66[3] != v67) {
          goto LABEL_68;
        }
        uint64_t v68 = (_DWORD *)(v3 + 32 * v64 + 28);
      }
      *uint64_t v68 = a2;
    }
LABEL_68:
    uint64_t v69 = v3 + 32 * a3;
    unsigned int v70 = *(_DWORD *)(v69 + 8);
    if ((v70 & 0x80000000) == 0)
    {
      uint64_t v71 = *((void *)this + 3);
      uint64_t v72 = v71 + 28 * v70;
      int v74 = *(_DWORD *)(v72 + 16);
      uint64_t v73 = (_DWORD *)(v72 + 16);
      if (v74 == a3) {
        *uint64_t v73 = a2;
      }
      uint64_t v75 = v71 + 28 * v70;
      int v77 = *(_DWORD *)(v75 + 20);
      float v76 = (_DWORD *)(v75 + 20);
      if (v77 == a3) {
        *float v76 = a2;
      }
    }
    unsigned int v78 = *(_DWORD *)(v69 + 12);
    if ((v78 & 0x80000000) == 0)
    {
      uint64_t v79 = *((void *)this + 3);
      uint64_t v80 = v79 + 28 * v78;
      int v82 = *(_DWORD *)(v80 + 16);
      float v81 = (_DWORD *)(v80 + 16);
      if (v82 == a3) {
        *float v81 = a2;
      }
      uint64_t v83 = v79 + 28 * v78;
      int v85 = *(_DWORD *)(v83 + 20);
      float v84 = (_DWORD *)(v83 + 20);
      if (v85 == a3) {
        *float v84 = a2;
      }
    }
    if ((v29 & 0x80000000) == 0)
    {
      uint64_t v86 = *((void *)this + 3);
      uint64_t v87 = v86 + 28 * v29;
      int v89 = *(_DWORD *)(v87 + 16);
      float v88 = (_DWORD *)(v87 + 16);
      int v90 = *((_DWORD *)this + 8);
      if (v89 == v90) {
        *float v88 = a3;
      }
      uint64_t v91 = v86 + 28 * v29;
      int v93 = *(_DWORD *)(v91 + 20);
      unsigned int v92 = (_DWORD *)(v91 + 20);
      if (v93 == v90) {
        *unsigned int v92 = a3;
      }
    }
    if ((v37 & 0x80000000) == 0)
    {
      uint64_t v94 = *((void *)this + 3);
      uint64_t v95 = v94 + 28 * v37;
      int v97 = *(_DWORD *)(v95 + 16);
      float v96 = (_DWORD *)(v95 + 16);
      int v98 = *((_DWORD *)this + 8);
      if (v97 == v98) {
        *float v96 = a3;
      }
      uint64_t v99 = v94 + 28 * v37;
      int v101 = *(_DWORD *)(v99 + 20);
      float v100 = (_DWORD *)(v99 + 20);
      if (v101 == v98) {
        *float v100 = a3;
      }
    }
    if (*v5 == a3) {
      *unsigned int v5 = a2;
    }
    if (*v18 == a3) {
      *int v18 = a2;
    }
    if (*v10 == a3) {
      *uint64_t v10 = a2;
    }
    if (*v23 == a3) {
      *uint64_t v23 = a2;
    }
    if (*v46 == a2) {
      *unsigned int v5 = a3;
    }
    if (*v58 == a2) {
      *int v18 = a3;
    }
    if (*v52 == a2) {
      *uint64_t v10 = a3;
    }
    if (*v63 == a2) {
      *uint64_t v23 = a3;
    }
    uint64_t v102 = v3 + 32 * a2;
    __n128 result = *(__n128 *)v102;
    long long v153 = *(_OWORD *)(v102 + 16);
    float v104 = (_OWORD *)(v3 + 32 * a3);
    long long v105 = v104[1];
    *(_OWORD *)uint64_t v102 = *v104;
    *(_OWORD *)(v102 + 16) = v105;
    uint64_t v106 = *((void *)this + 5) + 32 * a3;
    *(__n128 *)uint64_t v106 = result;
    *(_OWORD *)(v106 + 16) = v153;
    int v107 = *((_DWORD *)this + 13);
    if ((v107 & 8) != 0)
    {
      uint64_t v116 = *((void *)this + 7);
      float v117 = (__n128 *)(v116 + ((uint64_t)a2 << 6));
      __n128 v145 = *v117;
      __n128 v147 = v117[1];
      __n128 v149 = v117[2];
      __n128 v151 = v117[3];
      float v118 = (__n128 *)(v116 + ((uint64_t)a3 << 6));
      __n128 v119 = v118[3];
      __n128 v121 = *v118;
      __n128 v120 = v118[1];
      v117[2] = v118[2];
      v117[3] = v119;
      *float v117 = v121;
      v117[1] = v120;
      float v122 = (__n128 *)(*((void *)this + 7) + ((uint64_t)a3 << 6));
      *float v122 = v145;
      v122[1] = v147;
      __n128 result = v149;
      v122[2] = v149;
      v122[3] = v151;
      int v107 = *((_DWORD *)this + 13);
      if ((v107 & 0x10) == 0)
      {
LABEL_106:
        if ((v107 & 0x20) == 0) {
          goto LABEL_107;
        }
        goto LABEL_114;
      }
    }
    else if ((v107 & 0x10) == 0)
    {
      goto LABEL_106;
    }
    uint64_t v123 = *((void *)this + 8);
    float v124 = (long long *)(v123 + 56 * a2);
    long long v146 = *v124;
    long long v148 = v124[1];
    __n128 v150 = (__n128)v124[2];
    uint64_t v152 = *((void *)v124 + 6);
    float v125 = (long long *)(v123 + 56 * a3);
    long long v127 = v125[1];
    long long v126 = v125[2];
    long long v128 = *v125;
    *((void *)v124 + 6) = *((void *)v125 + 6);
    v124[1] = v127;
    v124[2] = v126;
    *float v124 = v128;
    uint64_t v129 = *((void *)this + 8) + 56 * a3;
    *(_OWORD *)uint64_t v129 = v146;
    *(_OWORD *)(v129 + 16) = v148;
    __n128 result = v150;
    *(__n128 *)(v129 + 32) = v150;
    *(void *)(v129 + 48) = v152;
    int v107 = *((_DWORD *)this + 13);
    if ((v107 & 0x20) == 0)
    {
LABEL_107:
      if ((v107 & 0x80) == 0) {
        goto LABEL_108;
      }
      goto LABEL_115;
    }
LABEL_114:
    uint64_t v130 = *((void *)this + 9);
    int v131 = (long long *)(v130 + 32 * a2);
    long long v132 = *v131;
    __n128 result = (__n128)v131[1];
    double v133 = (long long *)(v130 + 32 * a3);
    long long v134 = v133[1];
    *int v131 = *v133;
    v131[1] = v134;
    uint64_t v135 = *((void *)this + 9) + 32 * a3;
    *(_OWORD *)uint64_t v135 = v132;
    *(__n128 *)(v135 + 16) = result;
    int v107 = *((_DWORD *)this + 13);
    if ((v107 & 0x80) == 0)
    {
LABEL_108:
      if ((v107 & 0x200) == 0) {
        goto LABEL_109;
      }
      goto LABEL_116;
    }
LABEL_115:
    uint64_t v136 = *((void *)this + 10);
    double v137 = (long long *)(v136 + 48 * a2);
    long long v138 = v137[1];
    __n128 result = (__n128)v137[2];
    long long v139 = *v137;
    float v140 = (long long *)(v136 + 48 * a3);
    long long v142 = v140[1];
    long long v141 = v140[2];
    *double v137 = *v140;
    v137[1] = v142;
    v137[2] = v141;
    uint64_t v143 = *((void *)this + 10) + 48 * a3;
    *(_OWORD *)uint64_t v143 = v139;
    *(_OWORD *)(v143 + 16) = v138;
    *(__n128 *)(v143 + 32) = result;
    int v107 = *((_DWORD *)this + 13);
    if ((v107 & 0x200) == 0)
    {
LABEL_109:
      if ((v107 & 0x400) == 0) {
        return result;
      }
      goto LABEL_110;
    }
LABEL_116:
    uint64_t v144 = *((void *)this + 12);
    __n128 result = *(__n128 *)(v144 + 16 * a2);
    *(_OWORD *)(v144 + 16 * a2) = *(_OWORD *)(v144 + 16 * a3);
    *(__n128 *)(*((void *)this + 12) + 16 * a3) = result;
    if ((*((_DWORD *)this + 13) & 0x400) == 0) {
      return result;
    }
LABEL_110:
    uint64_t v108 = *((void *)this + 14);
    float v109 = (long long *)(v108 + 40 * a2);
    uint64_t v110 = *((void *)v109 + 4);
    long long v111 = *v109;
    __n128 result = (__n128)v109[1];
    float v112 = (long long *)(v108 + 40 * a3);
    uint64_t v113 = *((void *)v112 + 4);
    long long v114 = v112[1];
    *float v109 = *v112;
    v109[1] = v114;
    *((void *)v109 + 4) = v113;
    uint64_t v115 = *((void *)this + 14) + 40 * a3;
    *(_OWORD *)uint64_t v115 = v111;
    *(__n128 *)(v115 + 16) = result;
    *(void *)(v115 + 32) = v110;
  }
  return result;
}

double Shape::SwapEdges(Shape *this, int a2, int a3, int a4)
{
  if (a2 != a4 && a2 != a3 && a3 != a4)
  {
    Shape::SwapEdges(this, a2, a3);
    *(void *)&double result = Shape::SwapEdges(this, a3, a4).n128_u64[0];
  }
  return result;
}

void Shape::SortEdges(Shape *this)
{
  int v1 = *((_DWORD *)this + 13);
  if ((v1 & 2) != 0)
  {
    *((_DWORD *)this + 13) = v1 & 0xFFFFFFFD;
    uint64_t v3 = malloc_type_malloc(16 * *((int *)this + 8), 0x1000040A517B1A3uLL);
    if (*((int *)this + 4) >= 1)
    {
      uint64_t v4 = 0;
      uint64_t v5 = *((void *)this + 3);
      do
      {
        if (*(_DWORD *)(v5 + 28 * v4 + 12) + *(_DWORD *)(v5 + 28 * v4 + 8) >= 2)
        {
          uint64_t v6 = *(unsigned int *)(v5 + 28 * v4 + 16);
          if ((v6 & 0x80000000) != 0)
          {
            int v10 = 0;
          }
          else
          {
            uint64_t v7 = *((void *)this + 5);
            int v8 = 1;
            unsigned int v9 = (float *)(v3 + 2);
            do
            {
              int v10 = v8;
              *((_DWORD *)v9 - 2) = v6;
              uint64_t v11 = v7 + 32 * v6;
              float v12 = *(float *)v11;
              if (v4 == *(_DWORD *)(v11 + 8))
              {
                float v13 = *(float *)(v11 + 4);
                char v14 = 1;
              }
              else
              {
                char v14 = 0;
                float v12 = -v12;
                float v13 = -*(float *)(v11 + 4);
              }
              *unsigned int v9 = v12;
              v9[1] = v13;
              *((unsigned char *)v9 - 4) = v14;
              int v15 = (_DWORD *)(v7 + 32 * v6);
              if (v4 == *(_DWORD *)(v11 + 8))
              {
                uint64_t v16 = v15 + 4;
              }
              else
              {
                if (v4 != v15[3]) {
                  break;
                }
                uint64_t v16 = v15 + 6;
              }
              uint64_t v6 = *v16;
              v9 += 4;
              ++v8;
            }
            while ((v6 & 0x80000000) == 0);
          }
          int v17 = v10 - 1;
          Shape::SortEdgesList(this, (uint64_t)v3, 0, (v10 - 1));
          uint64_t v5 = *((void *)this + 3);
          uint64_t v18 = v5 + 28 * v4;
          int v19 = v3[4 * v10 - 4];
          *(_DWORD *)(v18 + 16) = *v3;
          *(_DWORD *)(v18 + 20) = v19;
          if (v10)
          {
            uint64_t v20 = 0;
            uint64_t v21 = v3 + 4;
            do
            {
              if (*((unsigned char *)v21 - 12))
              {
                if (v20) {
                  int v22 = v3[4 * (v20 - 1)];
                }
                else {
                  int v22 = -1;
                }
                uint64_t v24 = *((void *)this + 5) + 32 * (int)*(v21 - 4);
                *(_DWORD *)(v24 + 20) = v22;
                if (v20 >= v17) {
                  *(_DWORD *)(v24 + 16) = -1;
                }
                else {
                  *(_DWORD *)(v24 + 16) = *v21;
                }
              }
              else
              {
                if (v20) {
                  int v23 = v3[4 * (v20 - 1)];
                }
                else {
                  int v23 = -1;
                }
                uint64_t v25 = *((void *)this + 5) + 32 * (int)*(v21 - 4);
                *(_DWORD *)(v25 + 28) = v23;
                if (v20 >= v17) {
                  *(_DWORD *)(v25 + 24) = -1;
                }
                else {
                  *(_DWORD *)(v25 + 24) = *v21;
                }
              }
              ++v20;
              v21 += 4;
            }
            while (v10 != v20);
          }
        }
        ++v4;
      }
      while (v4 < *((int *)this + 4));
    }
    free(v3);
  }
}

Shape *Shape::SortEdgesList(Shape *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v33 = result;
  if ((int)a3 >= (int)a4) {
    return result;
  }
  uint64_t v5 = a3;
LABEL_3:
  if (v5 + 1 != a4)
  {
    int v7 = v5 + a4;
    if ((int)v5 + (int)a4 < 0 != __OFADD__(v5, a4)) {
      ++v7;
    }
    uint64_t v8 = (v7 >> 1);
    uint64_t v9 = a2 + 16 * (int)v8;
    float v10 = *(float *)(v9 + 8);
    float v11 = *(float *)(v9 + 12);
    BOOL v12 = (int)v8 < (int)a4;
    BOOL v13 = (int)v5 < v7 >> 1;
    if (!v13 && (int)v8 >= (int)a4)
    {
      LODWORD(v14) = v8;
      goto LABEL_58;
    }
    uint64_t v15 = a4;
    uint64_t v16 = v5;
    uint64_t v14 = v8;
    while (1)
    {
      if (!v13)
      {
        uint64_t v19 = v14;
LABEL_24:
        if (v12) {
          goto LABEL_25;
        }
LABEL_39:
        uint64_t v24 = v8;
        goto LABEL_43;
      }
      while (1)
      {
        int v17 = (float *)(a2 + 16 * (int)v16);
        double result = (Shape *)Shape::CmpToVert(result, v10, v11, v17[2], v17[3]);
        if (result)
        {
          BOOL v18 = (int)result < 1;
          if ((int)result >= 1) {
            uint64_t v16 = v16;
          }
          else {
            uint64_t v16 = (v16 + 1);
          }
          uint64_t v19 = v14;
          goto LABEL_18;
        }
        uint64_t v19 = (int)v14 - 1;
        if ((int)v16 >= (int)v19) {
          break;
        }
        long long v20 = *(_OWORD *)v17;
        *(_OWORD *)int v17 = *(_OWORD *)(a2 + 16 * v19);
        *(_OWORD *)(a2 + 16 * v19) = *(_OWORD *)(a2 + 16 * (int)v14);
        *(_OWORD *)(a2 + 16 * (int)v14) = v20;
        BOOL v18 = 1;
LABEL_18:
        BOOL v21 = v18 && (int)v16 < (int)v19;
        uint64_t v14 = v19;
        if (!v21) {
          goto LABEL_24;
        }
      }
      if (v16 == v19) {
        uint64_t v19 = v19;
      }
      else {
        uint64_t v19 = v14;
      }
      if (!v12) {
        goto LABEL_39;
      }
LABEL_25:
      while (2)
      {
        int v22 = (float *)(a2 + 16 * (int)v15);
        double result = (Shape *)Shape::CmpToVert(result, v10, v11, v22[2], v22[3]);
        if (result)
        {
          BOOL v23 = (int)result >= 0;
          uint64_t v15 = (v15 - v23);
          uint64_t v24 = v8;
          goto LABEL_29;
        }
        uint64_t v24 = (int)v8 + 1;
        if ((int)v15 > (int)v24)
        {
          long long v25 = *(_OWORD *)v22;
          *(_OWORD *)int v22 = *(_OWORD *)(a2 + 16 * v24);
          *(_OWORD *)(a2 + 16 * v24) = *(_OWORD *)(a2 + 16 * (int)v8);
          *(_OWORD *)(a2 + 16 * (int)v8) = v25;
          BOOL v23 = 1;
LABEL_29:
          BOOL v26 = !v23 || (int)v15 <= (int)v24;
          uint64_t v8 = v24;
          if (v26) {
            goto LABEL_43;
          }
          continue;
        }
        break;
      }
      if (v15 == v24) {
        uint64_t v24 = v24;
      }
      else {
        uint64_t v24 = v8;
      }
LABEL_43:
      if ((int)v16 >= (int)v19)
      {
        uint64_t v8 = (int)v24 + 1;
        if ((int)v15 > (int)v8)
        {
          long long v28 = *(_OWORD *)(a2 + 16 * v8);
          *(_OWORD *)(a2 + 16 * v8) = *(_OWORD *)(a2 + 16 * (int)v19);
          *(_OWORD *)(a2 + 16 * (int)v19) = *(_OWORD *)(a2 + 16 * (int)v15);
          *(_OWORD *)(a2 + 16 * (int)v15) = v28;
          uint64_t v14 = (v19 + 1);
          goto LABEL_54;
        }
        if (v15 == v8)
        {
          long long v30 = *(_OWORD *)(a2 + 16 * (int)v19);
          *(_OWORD *)(a2 + 16 * (int)v19) = *(_OWORD *)(a2 + 16 * (int)v15);
          *(_OWORD *)(a2 + 16 * (int)v15) = v30;
          uint64_t v14 = (v19 + 1);
          uint64_t v8 = v15;
          goto LABEL_54;
        }
        goto LABEL_57;
      }
      if ((int)v15 <= (int)v24)
      {
        uint64_t v14 = (int)v19 - 1;
        if ((int)v16 < (int)v14)
        {
          long long v29 = *(_OWORD *)(a2 + 16 * v14);
          *(_OWORD *)(a2 + 16 * v14) = *(_OWORD *)(a2 + 16 * (int)v24);
          *(_OWORD *)(a2 + 16 * (int)v24) = *(_OWORD *)(a2 + 16 * (int)v16);
          *(_OWORD *)(a2 + 16 * (int)v16) = v29;
          uint64_t v8 = (v24 - 1);
          goto LABEL_54;
        }
        if (v16 == v14)
        {
          long long v31 = *(_OWORD *)(a2 + 16 * (int)v24);
          *(_OWORD *)(a2 + 16 * (int)v24) = *(_OWORD *)(a2 + 16 * (int)v16);
          *(_OWORD *)(a2 + 16 * (int)v16) = v31;
          uint64_t v8 = (v24 - 1);
          uint64_t v14 = v16;
          goto LABEL_54;
        }
LABEL_57:
        LODWORD(v14) = v19;
        LODWORD(v8) = v24;
        goto LABEL_58;
      }
      long long v27 = *(_OWORD *)(a2 + 16 * (int)v16);
      *(_OWORD *)(a2 + 16 * (int)v16) = *(_OWORD *)(a2 + 16 * (int)v15);
      *(_OWORD *)(a2 + 16 * (int)v15) = v27;
      uint64_t v16 = (v16 + 1);
      uint64_t v15 = (v15 - 1);
      uint64_t v14 = v19;
      uint64_t v8 = v24;
LABEL_54:
      BOOL v12 = (int)v15 > (int)v8;
      BOOL v13 = (int)v16 < (int)v14;
      if ((int)v16 >= (int)v14 && (int)v15 <= (int)v8)
      {
LABEL_58:
        double result = (Shape *)Shape::SortEdgesList(v33, a2, v5, (v14 - 1));
        uint64_t v5 = (v8 + 1);
        if ((int)v5 >= (int)a4) {
          return result;
        }
        goto LABEL_3;
      }
    }
  }
  double result = (Shape *)Shape::CmpToVert(result, *(float *)(a2 + 16 * (int)a4 + 8), *(float *)(a2 + 16 * (int)a4 + 12), *(float *)(a2 + 16 * (int)v5 + 8), *(float *)(a2 + 16 * (int)v5 + 12));
  if ((int)result >= 1)
  {
    long long v32 = *(_OWORD *)(a2 + 16 * (int)v5);
    *(_OWORD *)(a2 + 16 * (int)v5) = *(_OWORD *)(a2 + 16 * (int)a4);
    *(_OWORD *)(a2 + 16 * (int)a4) = v32;
  }
  return result;
}

uint64_t Shape::CmpToVert(Shape *this, float a2, float a3, float a4, float a5)
{
  if (a2 >= 0.0)
  {
    if (a3 > 0.0) {
      int v7 = 3;
    }
    else {
      int v7 = 2;
    }
    if (a3 >= 0.0) {
      int v6 = v7;
    }
    else {
      int v6 = 1;
    }
    if (a3 <= 0.0) {
      int v8 = -1;
    }
    else {
      int v8 = 4;
    }
    if (a3 < 0.0) {
      int v8 = 0;
    }
    if (a2 <= 0.0) {
      int v6 = v8;
    }
  }
  else
  {
    if (a3 > 0.0) {
      int v5 = 5;
    }
    else {
      int v5 = 6;
    }
    if (a3 >= 0.0) {
      int v6 = v5;
    }
    else {
      int v6 = 7;
    }
  }
  if (a5 > 0.0) {
    int v9 = 3;
  }
  else {
    int v9 = 2;
  }
  if (a5 >= 0.0) {
    int v10 = v9;
  }
  else {
    int v10 = 1;
  }
  if (a5 <= 0.0) {
    int v11 = -1;
  }
  else {
    int v11 = 4;
  }
  if (a5 < 0.0) {
    int v11 = 0;
  }
  if (a4 <= 0.0) {
    int v10 = v11;
  }
  if (a5 > 0.0) {
    int v12 = 5;
  }
  else {
    int v12 = 6;
  }
  if (a5 >= 0.0) {
    int v13 = v12;
  }
  else {
    int v13 = 7;
  }
  if (a4 < 0.0) {
    int v10 = v13;
  }
  if (v6 < v10) {
    return 1;
  }
  if (v6 > v10) {
    return 0xFFFFFFFFLL;
  }
  float v15 = (float)(a2 * a5) - (float)(a3 * a4);
  if (v15 < 0.0) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v15 > 0.0;
  }
}

BOOL Shape::Eulerian(Shape *this, char a2)
{
  uint64_t v2 = *((unsigned int *)this + 4);
  if (a2)
  {
    if ((int)v2 >= 1)
    {
      uint64_t v3 = v2 - 1;
      uint64_t v4 = (int *)(*((void *)this + 3) + 12);
      do
      {
        int v5 = *(v4 - 1);
        int v6 = *v4;
        BOOL v7 = v3-- != 0;
        char v8 = v7;
        BOOL result = v5 == v6;
        if (v5 != v6) {
          break;
        }
        v4 += 7;
      }
      while ((v8 & 1) != 0);
      return result;
    }
    return 1;
  }
  if ((int)v2 < 1) {
    return 1;
  }
  uint64_t v10 = v2 - 1;
  int v11 = (_DWORD *)(*((void *)this + 3) + 12);
  do
  {
    unsigned int v12 = (*v11 + *(v11 - 1)) & 0x80000001;
    BOOL v7 = v10-- != 0;
    char v13 = v7;
    BOOL result = v12 != 1;
    if (v12 == 1) {
      break;
    }
    v11 += 7;
  }
  while ((v13 & 1) != 0);
  return result;
}

float32x2_t Shape::Inverse(Shape *this, int a2)
{
  uint64_t v2 = (float32x2_t *)(*((void *)this + 5) + 32 * a2);
  unsigned __int32 v3 = v2[1].u32[0];
  unsigned __int32 v4 = v2[1].u32[1];
  float32x2_t v5 = v2[3];
  v2[3] = v2[2];
  *(void *)&long long v6 = __PAIR64__(v3, v4);
  *((float32x2_t *)&v6 + 1) = v5;
  *(_OWORD *)v2[1].f32 = v6;
  float32x2_t result = vneg_f32(*v2);
  *uint64_t v2 = result;
  if ((v4 & 0x80000000) == 0)
  {
    char v8 = (int32x2_t *)(*((void *)this + 3) + 28 * v4);
    float32x2_t result = (float32x2_t)vadd_s32(v8[1], (int32x2_t)0x1FFFFFFFFLL);
    v8[1] = (int32x2_t)result;
  }
  if ((v3 & 0x80000000) == 0)
  {
    int v9 = (int32x2_t *)(*((void *)this + 3) + 28 * v3);
    float32x2_t result = (float32x2_t)vadd_s32(v9[1], (int32x2_t)0xFFFFFFFF00000001);
    v9[1] = (int32x2_t)result;
  }
  int v10 = *((_DWORD *)this + 13);
  if ((v10 & 8) != 0)
  {
    *(_DWORD *)(*((void *)this + 7) + ((uint64_t)a2 << 6)) = -*(_DWORD *)(*((void *)this + 7) + ((uint64_t)a2 << 6));
    if ((v10 & 0x20) == 0)
    {
LABEL_7:
      if ((v10 & 0x200) == 0) {
        goto LABEL_8;
      }
      goto LABEL_12;
    }
  }
  else if ((v10 & 0x20) == 0)
  {
    goto LABEL_7;
  }
  int v11 = (int32x2_t *)(*((void *)this + 9) + 32 * a2);
  float32x2_t result = (float32x2_t)vrev64_s32(v11[2]);
  void v11[2] = (int32x2_t)result;
  if ((v10 & 0x200) == 0)
  {
LABEL_8:
    if ((v10 & 0x400) == 0) {
      return result;
    }
LABEL_13:
    uint64_t v13 = *((void *)this + 14);
    uint64_t v14 = 40 * a2;
    float32x2_t result = (float32x2_t)vrev64_s32(*(int32x2_t *)(v13 + v14));
    *(float32x2_t *)(v13 + v14) = result;
    return result;
  }
LABEL_12:
  unsigned int v12 = (int32x2_t *)(*((void *)this + 12) + 16 * a2);
  float32x2_t result = (float32x2_t)vrev64_s32(v12[1]);
  v12[1] = (int32x2_t)result;
  if ((v10 & 0x400) != 0) {
    goto LABEL_13;
  }
  return result;
}

uint64_t Shape::CalcBBox(uint64_t this)
{
  uint64_t v1 = *(unsigned int *)(this + 16);
  if ((int)v1 <= 0)
  {
    *(void *)this = 0;
    *(void *)(this + 8) = 0;
  }
  else
  {
    uint64_t v2 = *(float **)(this + 24);
    float v3 = *v2;
    float v4 = v2[1];
    *(float *)(this + 8) = *v2;
    *(float *)(this + 12) = v4;
    *(float *)this = v3;
    *(float *)(this + 4) = v4;
    if (v1 != 1)
    {
      float32x2_t v5 = v2 + 8;
      uint64_t v6 = v1 - 1;
      float v7 = v4;
      float v8 = v3;
      do
      {
        float v9 = *(v5 - 1);
        if (v9 < v8)
        {
          *(float *)this = v9;
          float v8 = v9;
        }
        if (v9 > v3)
        {
          *(float *)(this + 8) = v9;
          float v3 = v9;
        }
        float v10 = *v5;
        if (*v5 < v7)
        {
          *(float *)(this + 4) = v10;
          float v7 = v10;
        }
        if (v10 > v4)
        {
          *(float *)(this + 12) = v10;
          float v4 = v10;
        }
        v5 += 7;
        --v6;
      }
      while (v6);
    }
  }
  return this;
}

const CGPath *TSDCreatePathFromSVGString(uint64_t a1)
{
  uint64_t v81 = *MEMORY[0x263EF8340];
  Mutable = CGPathCreateMutable();
  double v77 = 0.0;
  double v78 = 0.0;
  float v3 = (void *)[MEMORY[0x263F08B08] scannerWithString:a1];
  uint64_t v79 = *(void *)asc_223839E50;
  int v80 = 2883717;
  objc_msgSend(v3, "setCharactersToBeSkipped:", objc_msgSend(MEMORY[0x263F08708], "characterSetWithCharactersInString:", objc_msgSend(NSString, "stringWithCharacters:length:", &v79, 6)));
  id v76 = 0;
  if (objc_msgSend(v3, "scanCharactersFromSet:intoString:", objc_msgSend(MEMORY[0x263F08708], "letterCharacterSet"), &v76))
  {
    unsigned __int16 v4 = 0;
    double v5 = *MEMORY[0x263F00148];
    double v6 = *(double *)(MEMORY[0x263F00148] + 8);
    double v7 = 3.0;
    double v8 = *MEMORY[0x263F00148];
    double v9 = v6;
    do
    {
      int v10 = [v76 characterAtIndex:0];
      unsigned __int16 v11 = v10;
      if (v10 > 96)
      {
        switch(v10)
        {
          case 'a':
            CGPoint CurrentPoint = CGPathGetCurrentPoint(Mutable);
            double v70 = 0.0;
            double v68 = 0.0;
            CGFloat v66 = 0.0;
            uint64_t v74 = 0;
            uint64_t v75 = 0;
            double v72 = 0.0;
            double v73 = 0.0;
            objc_msgSend(v3, "tsu_scanCGFloat:", &v70);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v68);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v66);
            [v3 scanInteger:&v75];
            [v3 scanInteger:&v74];
            objc_msgSend(v3, "tsu_scanCGFloat:", &v73);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v72);
            double v72 = CurrentPoint.y + v72;
            double v73 = CurrentPoint.x + v73;
            uint64_t v13 = TSDCreatePathByComputingArc(v75 != 0, v74 != 0, CurrentPoint.x, CurrentPoint.y, v70, v68, v66, v73, v72);
            uint64_t ElementCount = TSDPathGetElementCount(v13);
            float v15 = Mutable;
            uint64_t v16 = v13;
            uint64_t v17 = 1;
LABEL_8:
            uint64_t v19 = TSDCreatePathByAppendingPathFromElementToElement(v15, v16, v17, ElementCount);
            CGPathRelease(v13);
            CGPathRelease(Mutable);
            Mutable = CGPathCreateMutableCopy(v19);
            CGPathRelease(v19);
            break;
          case 'b':
          case 'd':
          case 'e':
          case 'f':
          case 'g':
          case 'i':
          case 'j':
          case 'k':
          case 'n':
          case 'o':
          case 'p':
          case 'r':
          case 'u':
            goto LABEL_10;
          case 'c':
            CGPoint v48 = CGPathGetCurrentPoint(Mutable);
            double v70 = 0.0;
            double v71 = 0.0;
            double v68 = 0.0;
            double v69 = 0.0;
            CGFloat v66 = 0.0;
            double v67 = 0.0;
            objc_msgSend(v3, "tsu_scanCGFloat:", &v70);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v71);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v68);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v69);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v66);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v67);
            double v20 = v48.x + v70;
            double v22 = v48.x + v68;
            double v24 = v48.x + v66;
            double v21 = v48.y + v71;
            double v70 = v48.x + v70;
            double v71 = v48.y + v71;
            double v23 = v48.y + v69;
            double v68 = v48.x + v68;
            double v69 = v48.y + v69;
            double v25 = v48.y + v67;
            CGFloat v66 = v48.x + v66;
            double v67 = v48.y + v67;
LABEL_31:
            CGPathAddCurveToPoint(Mutable, 0, v20, v21, v22, v23, v24, v25);
            double v5 = v68;
            double v6 = v69;
            break;
          case 'h':
            objc_msgSend(v3, "tsu_scanCGFloat:", &v77);
            CGPoint v49 = CGPathGetCurrentPoint(Mutable);
            double y = v49.y;
            double v27 = v77 - v49.x;
            goto LABEL_52;
          case 'l':
            if (objc_msgSend(v3, "tsu_scanCGFloat:", &v77))
            {
              do
              {
                objc_msgSend(v3, "tsu_scanCGFloat:", &v78);
                CGPoint v50 = CGPathGetCurrentPoint(Mutable);
                CGPathAddLineToPoint(Mutable, 0, v77 - v50.x, v78 - v50.y);
              }
              while ((objc_msgSend(v3, "tsu_scanCGFloat:", &v77) & 1) != 0);
            }
            break;
          case 'm':
            CGPoint v51 = CGPathGetCurrentPoint(Mutable);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v77);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v78);
            if (TSDPathGetElementCount(Mutable) < 1)
            {
              double v52 = v77;
              double v53 = v78;
            }
            else
            {
              double v52 = v77 - v51.x;
              double v53 = v78 - v51.y;
            }
            CGPathMoveToPoint(Mutable, 0, v52, v53);
            if (objc_msgSend(v3, "tsu_scanCGFloat:", &v77))
            {
              do
              {
                objc_msgSend(v3, "tsu_scanCGFloat:", &v78);
                CGPoint v64 = CGPathGetCurrentPoint(Mutable);
                CGPathAddLineToPoint(Mutable, 0, v77 - v64.x, v78 - v64.y);
              }
              while ((objc_msgSend(v3, "tsu_scanCGFloat:", &v77) & 1) != 0);
            }
            break;
          case 'q':
            CGPoint v54 = CGPathGetCurrentPoint(Mutable);
            double v70 = 0.0;
            double v71 = 0.0;
            double v68 = 0.0;
            double v69 = 0.0;
            objc_msgSend(v3, "tsu_scanCGFloat:", &v70);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v71);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v68);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v69);
            double v29 = v54.x + v70;
            double v30 = v54.y + v71;
            double v70 = v29;
            double v71 = v30;
            double v33 = v54.x + v68;
            double v34 = v54.y + v69;
            double v68 = v54.x + v68;
            double v69 = v54.y + v69;
            double v31 = v54.x + (v29 - v54.x + v29 - v54.x) / v7;
            double v32 = v54.y + (v30 - v54.y + v30 - v54.y) / v7;
LABEL_39:
            CGPathAddCurveToPoint(Mutable, 0, v31, v32, v29 + (v33 - v29) / v7, v30 + (v34 - v30) / v7, v33, v34);
            double v8 = v70;
            double v9 = v71;
            break;
          case 's':
            CGPoint v55 = CGPathGetCurrentPoint(Mutable);
            __int16 v56 = (unsigned __int16)(v4 - 67) >> 4;
            double v57 = v55.x - v5;
            if (v56 & 0xFFFC | (unsigned __int16)((v4 - 67) << 12)) {
              double v57 = -0.0;
            }
            double v58 = v55.x + v57;
            if (v56 & 0xFFFC | (unsigned __int16)((v4 - 67) << 12)) {
              double v59 = -0.0;
            }
            else {
              double v59 = v55.y - v6;
            }
            double v70 = 0.0;
            double v71 = 0.0;
            CGFloat v60 = v55.y + v59;
            double v68 = 0.0;
            double v69 = 0.0;
            objc_msgSend(v3, "tsu_scanCGFloat:", &v70);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v71);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v68);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v69);
            double v38 = v55.x + v70;
            double v39 = v55.y + v71;
            double v70 = v55.x + v70;
            double v71 = v55.y + v71;
            double v40 = v55.x + v68;
            double v41 = v55.y + v69;
            double v68 = v55.x + v68;
            double v69 = v55.y + v69;
            uint64_t v42 = Mutable;
            CGFloat v43 = v58;
            double v44 = v60;
LABEL_46:
            CGPathAddCurveToPoint(v42, 0, v43, v44, v38, v39, v40, v41);
            double v5 = v70;
            double v6 = v71;
            break;
          case 't':
            CGPoint v61 = CGPathGetCurrentPoint(Mutable);
            if (v4 - 81 > 0x23)
            {
              double x = v61.x;
              double v9 = v61.y;
            }
            else
            {
              double x = v61.x;
              double v9 = v61.y;
              if (((1 << (v4 - 81)) & 0x900000009) != 0)
              {
                double x = v61.x + v61.x - v8;
                double v9 = v61.y + v61.y - v61.y;
              }
            }
            double v70 = 0.0;
            double v71 = 0.0;
            objc_msgSend(v3, "tsu_scanCGFloat:", &v70);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v71);
            double v70 = v61.x + v70;
            double v71 = v61.y + v71;
            CGPathAddCurveToPoint(Mutable, 0, x, v61.y + (v9 - v61.y + v9 - v61.y) / v7, x + (v70 - x) / v7, v9 + (v71 - v9) / v7, v70, v71);
            double v8 = x;
            break;
          case 'v':
            objc_msgSend(v3, "tsu_scanCGFloat:", &v78);
            CGPoint v63 = CGPathGetCurrentPoint(Mutable);
            double v27 = v63.x;
            double y = v78 - v63.y;
LABEL_52:
            CGPathAddLineToPoint(Mutable, 0, v27, y);
            break;
          default:
            if (v10 == 122) {
LABEL_12:
            }
              CGPathCloseSubpath(Mutable);
            else {
LABEL_10:
            }
              NSLog((NSString *)@"Cannot process path of type '%@'", v76, *(void *)&v66, *(void *)&v67, *(void *)&v68, *(void *)&v69, *(void *)&v70, *(void *)&v71, *(void *)&v72, *(void *)&v73);
            break;
        }
      }
      else
      {
        switch(v10)
        {
          case 'A':
            CGPoint v12 = CGPathGetCurrentPoint(Mutable);
            double v70 = 0.0;
            double v68 = 0.0;
            CGFloat v66 = 0.0;
            uint64_t v74 = 0;
            uint64_t v75 = 0;
            double v72 = 0.0;
            double v73 = 0.0;
            objc_msgSend(v3, "tsu_scanCGFloat:", &v70);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v68);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v66);
            [v3 scanInteger:&v75];
            [v3 scanInteger:&v74];
            objc_msgSend(v3, "tsu_scanCGFloat:", &v73);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v72);
            uint64_t v13 = TSDCreatePathByComputingArc(v75 != 0, v74 != 0, v12.x, v12.y, v70, v68, v66, v73, v72);
            uint64_t ElementCount = TSDPathGetElementCount(v13);
            float v15 = Mutable;
            uint64_t v16 = v13;
            uint64_t v17 = 2;
            goto LABEL_8;
          case 'B':
          case 'D':
          case 'E':
          case 'F':
          case 'G':
          case 'I':
          case 'J':
          case 'K':
          case 'N':
          case 'O':
          case 'P':
          case 'R':
          case 'U':
            goto LABEL_10;
          case 'C':
            double v70 = 0.0;
            double v71 = 0.0;
            double v68 = 0.0;
            double v69 = 0.0;
            CGFloat v66 = 0.0;
            double v67 = 0.0;
            objc_msgSend(v3, "tsu_scanCGFloat:", &v70);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v71);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v68);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v69);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v66);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v67);
            double v20 = v70;
            double v21 = v71;
            double v22 = v68;
            double v23 = v69;
            double v24 = v66;
            double v25 = v67;
            goto LABEL_31;
          case 'H':
            objc_msgSend(v3, "tsu_scanCGFloat:", &v77);
            double y = CGPathGetCurrentPoint(Mutable).y;
            double v27 = v77;
            goto LABEL_52;
          case 'L':
            if (objc_msgSend(v3, "tsu_scanCGFloat:", &v77))
            {
              do
              {
                objc_msgSend(v3, "tsu_scanCGFloat:", &v78);
                CGPathAddLineToPoint(Mutable, 0, v77, v78);
              }
              while ((objc_msgSend(v3, "tsu_scanCGFloat:", &v77) & 1) != 0);
            }
            break;
          case 'M':
            objc_msgSend(v3, "tsu_scanCGFloat:", &v77);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v78);
            CGPathMoveToPoint(Mutable, 0, v77, v78);
            if (objc_msgSend(v3, "tsu_scanCGFloat:", &v77))
            {
              do
              {
                objc_msgSend(v3, "tsu_scanCGFloat:", &v78);
                CGPathAddLineToPoint(Mutable, 0, v77, v78);
              }
              while ((objc_msgSend(v3, "tsu_scanCGFloat:", &v77) & 1) != 0);
            }
            break;
          case 'Q':
            CGPoint v28 = CGPathGetCurrentPoint(Mutable);
            double v70 = 0.0;
            double v71 = 0.0;
            double v68 = 0.0;
            double v69 = 0.0;
            objc_msgSend(v3, "tsu_scanCGFloat:", &v70);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v71);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v68);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v69);
            double v29 = v70;
            double v30 = v71;
            double v31 = v28.x + (v70 - v28.x + v70 - v28.x) / v7;
            double v32 = v28.y + (v71 - v28.y + v71 - v28.y) / v7;
            double v33 = v68;
            double v34 = v69;
            goto LABEL_39;
          case 'S':
            CGPoint v35 = CGPathGetCurrentPoint(Mutable);
            double v36 = v35.x - v5;
            if (((unsigned __int16)(v4 - 67) >> 4) & 0xFFFC | (unsigned __int16)((v4 - 67) << 12)) {
              double v36 = -0.0;
            }
            CGFloat v37 = v35.x + v36;
            double v70 = 0.0;
            double v71 = 0.0;
            double v68 = 0.0;
            double v69 = 0.0;
            objc_msgSend(v3, "tsu_scanCGFloat:", &v70);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v71);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v68);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v69);
            double v38 = v70;
            double v39 = v71;
            double v40 = v68;
            double v41 = v69;
            uint64_t v42 = Mutable;
            CGFloat v43 = v37;
            double v44 = v35.y + v35.x;
            goto LABEL_46;
          case 'T':
            CGPoint v45 = CGPathGetCurrentPoint(Mutable);
            if (v4 - 81 > 0x23)
            {
              double v46 = v45.x;
              double v47 = v45.y;
            }
            else
            {
              double v46 = v45.x;
              double v47 = v45.y;
              if (((1 << (v4 - 81)) & 0x900000009) != 0)
              {
                double v46 = v45.x + v45.x - v8;
                double v47 = v45.y + v45.y - v9;
              }
            }
            double v70 = 0.0;
            double v71 = 0.0;
            objc_msgSend(v3, "tsu_scanCGFloat:", &v70);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v71);
            double v7 = 3.0;
            CGPathAddCurveToPoint(Mutable, 0, v45.x + (v46 - v45.x + v46 - v45.x) / 3.0, v45.y + (v47 - v45.y + v47 - v45.y) / 3.0, v46 + (v70 - v46) / 3.0, v47 + (v71 - v47) / 3.0, v70, v71);
            double v9 = v47;
            double v8 = v46;
            break;
          case 'V':
            objc_msgSend(v3, "tsu_scanCGFloat:", &v78);
            *(void *)&double v27 = *(_OWORD *)&CGPathGetCurrentPoint(Mutable);
            double y = v78;
            goto LABEL_52;
          default:
            if (v10 != 90) {
              goto LABEL_10;
            }
            goto LABEL_12;
        }
      }
      unsigned __int16 v4 = v11;
    }
    while ((objc_msgSend(v3, "scanCharactersFromSet:intoString:", objc_msgSend(MEMORY[0x263F08708], "letterCharacterSet"), &v76) & 1) != 0);
  }
  return Mutable;
}

void Shape::ConvertToForme(Shape *this, Path *a2)
{
  if (*((int *)this + 4) >= 2 && *((int *)this + 8) >= 2 && Shape::Eulerian(this, 1))
  {
    Path::Reset(a2);
    Path::SetWeighted(a2, 0);
    Shape::MakePointData(this, 1);
    Shape::MakeEdgeData(this, 1);
    Shape::MakeSweepDestData(this, 1);
    uint64_t v4 = *((unsigned int *)this + 4);
    if ((int)v4 >= 1)
    {
      double v5 = (float *)(*((void *)this + 3) + 4);
      double v6 = (float *)(*((void *)this + 11) + 40);
      do
      {
        float v7 = ldexpf(*(v5 - 1), 5);
        *(v6 - 1) = ldexpf(roundf(v7), -5);
        float v8 = *v5;
        v5 += 7;
        float v9 = ldexpf(v8, 5);
        *double v6 = ldexpf(roundf(v9), -5);
        v6 += 12;
        --v4;
      }
      while (v4);
    }
    uint64_t v10 = *((unsigned int *)this + 8);
    if ((int)v10 >= 1)
    {
      uint64_t v11 = *((void *)this + 11);
      CGPoint v12 = (int *)(*((void *)this + 5) + 12);
      uint64_t v13 = (float32x2_t *)(*((void *)this + 7) + 4);
      do
      {
        *uint64_t v13 = vsub_f32(*(float32x2_t *)(v11 + 48 * *v12 + 36), *(float32x2_t *)(v11 + 48 * *(v12 - 1) + 36));
        v13 += 8;
        v12 += 8;
        --v10;
      }
      while (v10);
    }
    Shape::SortEdges(this);
    uint64_t v14 = *((unsigned int *)this + 8);
    if ((int)v14 >= 1)
    {
      float v15 = (void *)(*((void *)this + 9) + 8);
      do
      {
        *(v15 - 1) = 0;
        *float v15 = -1;
        v15 += 4;
        --v14;
      }
      while (v14);
    }
    int v40 = 0;
    uint64_t v16 = 0;
    int v17 = *((_DWORD *)this + 4);
    while (1)
    {
      if ((int)v16 >= v17) {
        goto LABEL_20;
      }
      uint64_t v18 = *((void *)this + 3);
      uint64_t v19 = v16 << 32;
      double v20 = (unsigned int *)(v18 + 28 * (int)v16 + 16);
      while (1)
      {
        unsigned int v22 = *v20;
        v20 += 7;
        uint64_t v21 = v22;
        if ((v22 & 0x80000000) == 0 && !*(void *)(*((void *)this + 9) + 32 * v21)) {
          break;
        }
        v19 += 0x100000000;
        LODWORD(v16) = v16 + 1;
        if (v17 == v16)
        {
          LODWORD(v16) = v17;
          goto LABEL_20;
        }
      }
      unsigned int v23 = *(_DWORD *)(v18 + 28 * SHIDWORD(v19) + 16);
      if ((v23 & 0x80000000) == 0) {
        break;
      }
LABEL_20:
      uint64_t v16 = (v16 + 1);
      if ((int)v16 >= v17)
      {
        Shape::MakePointData(this, 0);
        Shape::MakeEdgeData(this, 0);
        Shape::MakeSweepDestData(this, 0);
        return;
      }
    }
    uint64_t v24 = *((void *)this + 5);
    while (1)
    {
      uint64_t v25 = v24 + 32 * v23;
      int v26 = *(_DWORD *)(v25 + 8);
      int v27 = *(_DWORD *)(v25 + 12);
      if (v26 == v16) {
        break;
      }
      if (v27 == v16)
      {
        unsigned int v23 = *(_DWORD *)(v24 + 32 * v23 + 24);
        if ((v23 & 0x80000000) == 0) {
          continue;
        }
      }
      goto LABEL_20;
    }
    Path::MoveTo(a2, *(float *)(v18 + 28 * v27), *(float *)(v18 + 28 * v27 + 4));
    CGPoint v28 = (void *)(*((void *)this + 9) + 32 * v23);
    *CGPoint v28 = 1;
    v28[1] = -1;
LABEL_29:
    char v29 = 0;
    unsigned int v30 = v23;
LABEL_30:
    uint64_t v31 = *((void *)this + 5);
    int v32 = *(_DWORD *)(v31 + 32 * v30 + 12);
    LODWORD(v33) = v30;
    while (1)
    {
      int v34 = v33;
      CGPoint v35 = (_DWORD *)(v31 + 32 * (int)v33);
      if (v35[2] != v32) {
        break;
      }
      unsigned int v23 = v35[4];
      if ((v23 & 0x80000000) != 0) {
        goto LABEL_33;
      }
LABEL_34:
      if (v23 == v33) {
        uint64_t v33 = 0xFFFFFFFFLL;
      }
      else {
        uint64_t v33 = v23;
      }
      if (v23 == v34
        || (v23 & 0x80000000) != 0
        || v23 == v30
        || !*(void *)(*((void *)this + 9) + 32 * (int)v33) && *(_DWORD *)(v31 + 32 * (int)v33 + 8) == v32)
      {
        if ((v33 & 0x80000000) == 0 && v33 != v30)
        {
          uint64_t v36 = *((void *)this + 3);
          if (v29)
          {
            Path::MoveTo(a2, *(float *)(v36 + 28 * v32), *(float *)(v36 + 28 * v32 + 4));
            uint64_t v36 = *((void *)this + 3);
            uint64_t v31 = *((void *)this + 5);
          }
          uint64_t v37 = *((void *)this + 9);
          uint64_t v38 = v37 + 32 * v33;
          *(void *)uint64_t v38 = 1;
          *(_DWORD *)(v38 + 24) = v40;
          *(_DWORD *)(v38 + 12) = v30;
          *(_DWORD *)(v37 + 32 * v30 + 8) = v33;
          double v39 = (float *)(v36 + 28 * *(int *)(v31 + 32 * v33 + 12));
          Path::LineTo(a2, *v39, v39[1]);
          ++v40;
          goto LABEL_29;
        }
LABEL_48:
        if ((v29 & 1) == 0) {
          Path::Close(a2);
        }
        unsigned int v30 = *(_DWORD *)(*((void *)this + 9) + 32 * v30 + 12);
        char v29 = 1;
        if ((v30 & 0x80000000) != 0)
        {
          int v17 = *((_DWORD *)this + 4);
          goto LABEL_20;
        }
        goto LABEL_30;
      }
    }
    if (v35[3] != v32) {
      goto LABEL_48;
    }
    unsigned int v23 = *(_DWORD *)(v31 + 32 * (int)v33 + 24);
    if ((v23 & 0x80000000) == 0) {
      goto LABEL_34;
    }
LABEL_33:
    unsigned int v23 = *(_DWORD *)(*((void *)this + 3) + 28 * v32 + 16);
    goto LABEL_34;
  }
}

void Shape::ConvertToForme(Shape *this, Path *a2, int a3, Path **a4)
{
  if (*((int *)this + 4) < 2 || *((int *)this + 8) < 2 || !Shape::Eulerian(this, 1)) {
    return;
  }
  if ((*((unsigned char *)this + 53) & 2) == 0)
  {
    Shape::ConvertToForme(this, a2);
    return;
  }
  Path::Reset(a2);
  double v39 = a2;
  Path::SetWeighted(a2, 0);
  Shape::MakePointData(this, 1);
  Shape::MakeEdgeData(this, 1);
  Shape::MakeSweepDestData(this, 1);
  uint64_t v6 = *((unsigned int *)this + 4);
  if ((int)v6 >= 1)
  {
    float v7 = (float *)(*((void *)this + 3) + 4);
    float v8 = (float *)(*((void *)this + 11) + 40);
    do
    {
      float v9 = ldexpf(*(v7 - 1), 5);
      *(v8 - 1) = ldexpf(roundf(v9), -5);
      float v10 = *v7;
      v7 += 7;
      float v11 = ldexpf(v10, 5);
      *float v8 = ldexpf(roundf(v11), -5);
      v8 += 12;
      --v6;
    }
    while (v6);
  }
  uint64_t v12 = *((unsigned int *)this + 8);
  if ((int)v12 >= 1)
  {
    uint64_t v13 = *((void *)this + 11);
    uint64_t v14 = (int *)(*((void *)this + 5) + 12);
    float v15 = (float32x2_t *)(*((void *)this + 7) + 4);
    do
    {
      *float v15 = vsub_f32(*(float32x2_t *)(v13 + 48 * *v14 + 36), *(float32x2_t *)(v13 + 48 * *(v14 - 1) + 36));
      v15 += 8;
      v14 += 8;
      --v12;
    }
    while (v12);
  }
  Shape::SortEdges(this);
  uint64_t v16 = *((unsigned int *)this + 8);
  if ((int)v16 >= 1)
  {
    int v17 = (void *)(*((void *)this + 9) + 8);
    do
    {
      *(v17 - 1) = 0;
      *int v17 = -1;
      v17 += 4;
      --v16;
    }
    while (v16);
  }
  int v18 = 0;
  uint64_t v19 = 0;
  int v20 = *((_DWORD *)this + 4);
  do
  {
    if ((int)v19 >= v20) {
      goto LABEL_25;
    }
    uint64_t v21 = *((void *)this + 3);
    uint64_t v22 = v19 << 32;
    unsigned int v23 = (unsigned int *)(v21 + 28 * (int)v19 + 16);
    while (1)
    {
      unsigned int v25 = *v23;
      v23 += 7;
      uint64_t v24 = v25;
      if ((v25 & 0x80000000) == 0)
      {
        uint64_t v26 = *((void *)this + 9);
        if (!*(void *)(v26 + 32 * v24)) {
          break;
        }
      }
      v22 += 0x100000000;
      LODWORD(v19) = v19 + 1;
      if (v20 == v19)
      {
        LODWORD(v19) = v20;
        goto LABEL_25;
      }
    }
    unsigned int v27 = *(_DWORD *)(v21 + 28 * SHIDWORD(v22) + 16);
    if ((v27 & 0x80000000) == 0)
    {
      uint64_t v28 = *((void *)this + 5);
      while (1)
      {
        uint64_t v29 = v28 + 32 * v27;
        if (*(_DWORD *)(v29 + 8) == v19) {
          break;
        }
        if (*(_DWORD *)(v29 + 12) == v19)
        {
          unsigned int v27 = *(_DWORD *)(v28 + 32 * v27 + 24);
          if ((v27 & 0x80000000) == 0) {
            continue;
          }
        }
        goto LABEL_25;
      }
      char v30 = 0;
      uint64_t v31 = (void *)(v26 + 32 * v27);
      *uint64_t v31 = 1;
      v31[1] = -1;
      unsigned int v32 = v27;
      int v40 = v19;
LABEL_34:
      int v33 = *(_DWORD *)(v28 + 32 * v32 + 12);
      LODWORD(v34) = v32;
      while (1)
      {
        int v35 = v34;
        uint64_t v36 = (_DWORD *)(v28 + 32 * (int)v34);
        if (v36[2] != v33) {
          break;
        }
        unsigned int v37 = v36[4];
        if ((v37 & 0x80000000) != 0) {
          goto LABEL_37;
        }
LABEL_38:
        if (v37 == v34) {
          uint64_t v34 = 0xFFFFFFFFLL;
        }
        else {
          uint64_t v34 = v37;
        }
        if (v37 == v35
          || (v37 & 0x80000000) != 0
          || v37 == v32
          || !*(void *)(v26 + 32 * (int)v34) && *(_DWORD *)(v28 + 32 * (int)v34 + 8) == v33)
        {
          if ((v34 & 0x80000000) == 0 && v34 != v32)
          {
            if (v30)
            {
              int v40 = *(_DWORD *)(v28 + 32 * v34 + 8);
              goto LABEL_62;
            }
            if (v33 == v40)
            {
              *(_DWORD *)(v26 + 32 * v32 + 8) = -1;
              Shape::AddContour(this, v39, a3, a4, v27);
              uint64_t v26 = *((void *)this + 9);
LABEL_62:
              unsigned int v27 = v37;
            }
            char v30 = 0;
            uint64_t v38 = v26 + 32 * v34;
            *(void *)uint64_t v38 = 1;
            *(_DWORD *)(v38 + 24) = v18++;
            *(_DWORD *)(v38 + 12) = v32;
            *(_DWORD *)(v26 + 32 * v32 + 8) = v34;
LABEL_64:
            uint64_t v28 = *((void *)this + 5);
            unsigned int v32 = v37;
            goto LABEL_34;
          }
LABEL_54:
          if ((v30 & 1) == 0 && v32 != v27 && (v32 & 0x80000000) == 0)
          {
            *(_DWORD *)(v26 + 32 * v32 + 8) = -1;
            Shape::AddContour(this, v39, a3, a4, v27);
            uint64_t v26 = *((void *)this + 9);
          }
          unsigned int v37 = *(_DWORD *)(v26 + 32 * v32 + 12);
          if ((v37 & 0x80000000) == 0)
          {
            char v30 = 1;
            goto LABEL_64;
          }
          int v20 = *((_DWORD *)this + 4);
          goto LABEL_25;
        }
      }
      if (v36[3] != v33) {
        goto LABEL_54;
      }
      unsigned int v37 = *(_DWORD *)(v28 + 32 * (int)v34 + 24);
      if ((v37 & 0x80000000) == 0) {
        goto LABEL_38;
      }
LABEL_37:
      unsigned int v37 = *(_DWORD *)(*((void *)this + 3) + 28 * v33 + 16);
      goto LABEL_38;
    }
LABEL_25:
    uint64_t v19 = (v19 + 1);
  }
  while ((int)v19 < v20);
  Shape::MakePointData(this, 0);
  Shape::MakeEdgeData(this, 0);

  Shape::MakeSweepDestData(this, 0);
}

uint64_t Shape::AddContour(Shape *this, Path *a2, int a3, Path **a4, signed int a5)
{
  unsigned int v5 = a5;
  float v10 = (float *)(*((void *)this + 3) + 28 * *(int *)(*((void *)this + 5) + 32 * a5 + 8));
  Path::MoveTo(a2, *v10, v10[1]);
  while ((v5 & 0x80000000) == 0)
  {
    while (1)
    {
      uint64_t v12 = (unsigned int *)(*((void *)this + 12) + 16 * v5);
      uint64_t v13 = *v12;
      if ((v13 & 0x80000000) == 0 && (int)v13 < a3)
      {
        uint64_t v14 = a4[v13];
        if (v14)
        {
          unsigned int v15 = v12[1];
          if ((v15 & 0x80000000) == 0 && (signed int)v15 < v14->var2) {
            break;
          }
        }
      }
      int v20 = (float *)(*((void *)this + 3) + 28 * *(int *)(*((void *)this + 5) + 32 * v5 + 12));
      Path::LineTo(a2, *v20, v20[1]);
      unsigned int v5 = *(_DWORD *)(*((void *)this + 9) + 32 * v5 + 8);
      if ((v5 & 0x80000000) != 0) {
        goto LABEL_26;
      }
    }
    var3 = v14->var3;
    int v17 = *((_DWORD *)var3 + 11 * v15) & 0xF;
    if ((*((_DWORD *)var3 + 11 * v15) & 0xD) == 5 || v17 == 0)
    {
LABEL_12:
      uint64_t v19 = (float *)(*((void *)this + 3) + 28 * *(int *)(*((void *)this + 5) + 32 * v5 + 12));
      Path::LineTo(a2, *v19, v19[1]);
      unsigned int v5 = *(_DWORD *)(*((void *)this + 9) + 32 * v5 + 8);
      if ((v5 & 0x80000000) != 0) {
        break;
      }
    }
    else
    {
      switch(v17)
      {
        case 1:
          goto LABEL_20;
        case 2:
          unsigned int v21 = Shape::ReFormeCubicTo(this, v5, v11, a2, v14);
          break;
        case 3:
          if (*((_DWORD *)var3 + 11 * v15 + 4)) {
            goto LABEL_19;
          }
LABEL_20:
          unsigned int v21 = Shape::ReFormeLineTo(this, v5, v11, a2, v14);
          break;
        case 4:
          unsigned int v21 = Shape::ReFormeArcTo(this, v5, v11, a2, v14);
          break;
        case 6:
LABEL_19:
          unsigned int v21 = Shape::ReFormeBezierTo(this, v5, v11, a2, v14);
          break;
        default:
          goto LABEL_12;
      }
      unsigned int v5 = v21;
      if ((v21 & 0x80000000) != 0) {
        break;
      }
    }
    uint64_t v22 = *((void *)this + 3) + 28 * *(int *)(*((void *)this + 5) + 32 * v5 + 8);
    if (*(_DWORD *)(v22 + 12) + *(_DWORD *)(v22 + 8) >= 3) {
      Path::ForcePoint(a2);
    }
  }
LABEL_26:

  return Path::Close(a2);
}

uint64_t Shape::MakeOffset(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  Shape::Reset((void **)a1, 0);
  Shape::MakeBackData((Shape *)a1, 0);
  int v10 = *(_DWORD *)(a2 + 16);
  if (a4 == 0.0)
  {
    *(_DWORD *)(a1 + 16) = v10;
    if (v10 > *(_DWORD *)(a1 + 20))
    {
      *(_DWORD *)(a1 + 20) = v10;
      *(void *)(a1 + 24) = malloc_type_realloc(*(void **)(a1 + 24), 28 * v10, 0x100004027586B93uLL);
      if ((*(unsigned char *)(a1 + 52) & 4) != 0) {
        *(void *)(a1 + 88) = malloc_type_realloc(*(void **)(a1 + 88), 48 * *(int *)(a1 + 20), 0x102004023ED6C3AuLL);
      }
    }
    memcpy(*(void **)(a1 + 24), *(const void **)(a2 + 24), 28 * *(int *)(a1 + 16));
    int v11 = *(_DWORD *)(a2 + 32);
    *(_DWORD *)(a1 + 32) = v11;
    if (v11 <= *(_DWORD *)(a1 + 36)) {
      goto LABEL_11;
    }
    *(_DWORD *)(a1 + 36) = v11;
    *(void *)(a1 + 40) = malloc_type_realloc(*(void **)(a1 + 40), 32 * v11, 0x1000040E0EAB150uLL);
    int v12 = *(_DWORD *)(a1 + 52);
    if ((v12 & 8) != 0)
    {
      *(void *)(a1 + 56) = malloc_type_realloc(*(void **)(a1 + 56), (uint64_t)*(int *)(a1 + 36) << 6, 0x100004094D12286uLL);
      int v12 = *(_DWORD *)(a1 + 52);
      if ((v12 & 0x10) == 0)
      {
LABEL_8:
        if ((v12 & 0x20) == 0) {
          goto LABEL_9;
        }
        goto LABEL_44;
      }
    }
    else if ((v12 & 0x10) == 0)
    {
      goto LABEL_8;
    }
    *(void *)(a1 + 64) = malloc_type_realloc(*(void **)(a1 + 64), 56 * *(int *)(a1 + 36), 0x10A0040A41B8C3EuLL);
    int v12 = *(_DWORD *)(a1 + 52);
    if ((v12 & 0x20) == 0)
    {
LABEL_9:
      if ((v12 & 0x80) == 0)
      {
LABEL_11:
        memcpy(*(void **)(a1 + 40), *(const void **)(a2 + 40), 32 * *(int *)(a1 + 32));
        return 0;
      }
LABEL_10:
      *(void *)(a1 + 80) = malloc_type_realloc(*(void **)(a1 + 80), 48 * *(int *)(a1 + 36), 0x10200403C9B7522uLL);
      goto LABEL_11;
    }
LABEL_44:
    *(void *)(a1 + 72) = malloc_type_realloc(*(void **)(a1 + 72), 32 * *(int *)(a1 + 36), 0x1080040DCAC275BuLL);
    if ((*(_DWORD *)(a1 + 52) & 0x80) == 0) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  if (v10 >= 2 && *(int *)(a2 + 32) >= 2 && *(_DWORD *)(a2 + 48) == 1)
  {
    Shape::SortEdges((Shape *)a2);
    Shape::MakeSweepDestData((Shape *)a2, 1);
    Shape::MakeSweepSrcData((Shape *)a2, 1);
    LODWORD(v14) = *(_DWORD *)(a2 + 32);
    if ((int)v14 < 1)
    {
LABEL_32:
      if (a4 < 0.0 && *(int *)(a1 + 32) >= 1)
      {
        int v38 = 0;
        do
          Shape::Inverse((Shape *)a1, v38++);
        while (v38 < *(_DWORD *)(a1 + 32));
        LODWORD(v14) = *(_DWORD *)(a2 + 32);
      }
      if ((int)v14 >= 1)
      {
        uint64_t v39 = 0;
        uint64_t v40 = 0;
        do
        {
          Shape::AddEdge((Shape *)a1, *(_DWORD *)(*(void *)(a2 + 64) + v39 + 12), *(_DWORD *)(*(void *)(a2 + 64) + v39 + 16));
          ++v40;
          v39 += 56;
        }
        while (v40 < *(int *)(a2 + 32));
      }
      Shape::MakeSweepSrcData((Shape *)a2, 0);
      Shape::MakeSweepDestData((Shape *)a2, 0);
      return 0;
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    uint64_t v17 = 12;
    while (1)
    {
      uint64_t v18 = *(void *)(a2 + 40);
      uint64_t v19 = (int *)(v18 + v15);
      int v20 = *(_DWORD *)(v18 + v15 + 8);
      if (a4 <= 0.0)
      {
        int v21 = v19[5];
        if (v21 < 0)
        {
          uint64_t v22 = (int *)(*(void *)(a2 + 24) + 28 * v20 + 20);
          goto LABEL_23;
        }
      }
      else
      {
        int v21 = v19[4];
        if (v21 < 0)
        {
          uint64_t v22 = (int *)(*(void *)(a2 + 24) + 28 * v20 + 16);
LABEL_23:
          int v21 = *v22;
        }
      }
      int v23 = v21;
      uint64_t v24 = (float *)(v18 + 32 * v21);
      float v25 = *v24;
      float v26 = v24[1];
      float v27 = (float)(v26 * v26) + (float)(v25 * v25);
      float v28 = sqrtf(v27);
      if (v27 > 0.0001)
      {
        float v25 = v25 / v28;
        float v26 = v26 / v28;
      }
      uint64_t v29 = (float *)(v18 + v15);
      float v30 = *v29;
      float v31 = v29[1];
      float v32 = (float)(v31 * v31) + (float)(v30 * v30);
      float v33 = sqrtf(v32);
      if (v32 > 0.0001)
      {
        float v30 = v30 / v33;
        float v31 = v31 / v33;
      }
      uint64_t v41 = 0;
      uint64_t v34 = (float *)(*(void *)(a2 + 24) + 28 * v19[2]);
      float v35 = *v34;
      float v36 = v34[1];
      if (a4 <= 0.0) {
        Path::DoLeftJoin((Shape *)a1, a3, (unsigned int *)&v41 + 1, (unsigned int *)&v41, -a4, v35, v36, v25, v26, v30, v31, a5);
      }
      else {
        Path::DoRightJoin((Shape *)a1, a3, (unsigned int *)&v41 + 1, (unsigned int *)&v41, a4, v35, v36, v25, v26, v30, v31, a5);
      }
      uint64_t v37 = *(void *)(a2 + 64);
      *(_DWORD *)(v37 + v17) = v41;
      *(_DWORD *)(v37 + 56 * v23 + 16) = HIDWORD(v41);
      ++v16;
      uint64_t v14 = *(int *)(a2 + 32);
      v17 += 56;
      v15 += 32;
      if (v16 >= v14) {
        goto LABEL_32;
      }
    }
  }
  return 5;
}

uint64_t Shape::ReFormeLineTo(Shape *this, int a2, int a3, Path *a4, Path *a5)
{
  uint64_t v5 = *((void *)this + 12);
  uint64_t v6 = a2;
  float v7 = (int *)(v5 + 16 * a2);
  int v9 = *v7;
  int v8 = v7[1];
  uint64_t v10 = *((void *)this + 3);
  uint64_t v11 = *((void *)this + 5);
  do
  {
    uint64_t v12 = v6;
    uint64_t v6 = *(unsigned int *)(*((void *)this + 9) + 32 * v6 + 8);
    if ((v6 & 0x80000000) != 0) {
      break;
    }
    int v13 = *(_DWORD *)(v11 + 32 * v6 + 8);
    if (*(_DWORD *)(v10 + 28 * v13 + 12) + *(_DWORD *)(v10 + 28 * v13 + 8) > 2) {
      break;
    }
  }
  while (*(int *)(v10 + 28 * v13 + 24) <= 2
       && *(_DWORD *)(v5 + 16 * v6 + 4) == v8
       && *(_DWORD *)(v5 + 16 * v6) == v9
       && vabds_f32(*(float *)(v5 + 16 * v12 + 12), *(float *)(v5 + 16 * v6 + 8)) <= 0.0001);
  uint64_t v14 = (float *)(v10 + 28 * *(int *)(v11 + 32 * v12 + 12));
  Path::LineTo(a4, *v14, v14[1]);
  return v6;
}

uint64_t Shape::ReFormeArcTo(Shape *this, int a2, int a3, Path *a4, Path *a5)
{
  uint64_t v7 = *((void *)this + 12);
  uint64_t v8 = a2;
  int v9 = (float *)(v7 + 16 * a2);
  float v10 = *v9;
  int v11 = *((_DWORD *)v9 + 1);
  float v12 = v9[2];
  uint64_t v13 = *((void *)this + 3);
  uint64_t v14 = *((void *)this + 5);
  do
  {
    uint64_t v15 = v8;
    uint64_t v16 = v7 + 16 * v8;
    uint64_t v8 = *(unsigned int *)(*((void *)this + 9) + 32 * v8 + 8);
    float v17 = *(float *)(v16 + 12);
    if ((v8 & 0x80000000) != 0) {
      break;
    }
    int v18 = *(_DWORD *)(v14 + 32 * v8 + 8);
    if (*(_DWORD *)(v13 + 28 * v18 + 12) + *(_DWORD *)(v13 + 28 * v18 + 8) > 2) {
      break;
    }
  }
  while (*(int *)(v13 + 28 * v18 + 24) <= 2
       && *(_DWORD *)(v7 + 16 * v8 + 4) == v11
       && *(_DWORD *)(v7 + 16 * v8) == LODWORD(v10)
       && vabds_f32(v17, *(float *)(v7 + 16 * v8 + 8)) <= 0.0001);
  uint64_t v19 = (float *)(v13 + 28 * *(int *)(v14 + 32 * v15 + 12));
  float v21 = *v19;
  float v20 = v19[1];
  uint64_t v37 = 0;
  uint64_t v22 = (char *)a5->var3 + 44 * v11;
  int v23 = (Path *)v22[36];
  int v24 = v22[37];
  BOOL v25 = v22[37] != 0;
  uint64_t v36 = 0;
  Path::PrevPoint(a5, v11 - 1, (float *)&v36 + 1, (float *)&v36);
  float v26 = (float *)((char *)a5->var3 + 44 * v11);
  Path::ArcAngles(v23, *((float *)&v36 + 1), *(float *)&v36, v26[4], v26[5], v26[6], v26[7], v26[8], v24, (float *)&v37 + 1, (float *)&v37, v27);
  float v28 = *((float *)&v37 + 1);
  if (v24)
  {
    if (*((float *)&v37 + 1) >= *(float *)&v37) {
      goto LABEL_14;
    }
    double v29 = *((float *)&v37 + 1);
    double v30 = 6.28318531;
  }
  else
  {
    if (*((float *)&v37 + 1) <= *(float *)&v37) {
      goto LABEL_14;
    }
    double v29 = *((float *)&v37 + 1);
    double v30 = -6.28318531;
  }
  float v28 = v29 + v30;
  *((float *)&v37 + 1) = v28;
LABEL_14:
  if (v12 > v17) {
    char v31 = v24 == 0;
  }
  else {
    char v31 = v25;
  }
  float v32 = (float)(v17 - v12) * (float)(*(float *)&v37 - v28);
  float v33 = -v32;
  if (v32 >= 0.0) {
    float v33 = (float)(v17 - v12) * (float)(*(float *)&v37 - v28);
  }
  uint64_t v34 = (float *)((char *)a5->var3 + 44 * v11);
  Path::ArcTo(a4, v21, v20, v34[6], v34[7], v34[8], v33 > 3.14159265, v31);
  return v8;
}

uint64_t Shape::ReFormeCubicTo(Shape *this, int a2, int a3, Path *a4, Path *a5)
{
  uint64_t v7 = *((void *)this + 12);
  uint64_t v8 = a2;
  int v9 = (float *)(v7 + 16 * a2);
  float v10 = *v9;
  int v11 = *((_DWORD *)v9 + 1);
  float v12 = v9[2];
  uint64_t v13 = *((void *)this + 3);
  uint64_t v14 = *((void *)this + 5);
  do
  {
    uint64_t v15 = v8;
    float v16 = *(float *)(v7 + 16 * v8 + 12);
    uint64_t v8 = *(unsigned int *)(*((void *)this + 9) + 32 * v8 + 8);
    if ((v8 & 0x80000000) != 0) {
      break;
    }
    int v17 = *(_DWORD *)(v14 + 32 * v8 + 8);
    if (*(_DWORD *)(v13 + 28 * v17 + 12) + *(_DWORD *)(v13 + 28 * v17 + 8) > 2) {
      break;
    }
  }
  while (*(int *)(v13 + 28 * v17 + 24) <= 2
       && *(_DWORD *)(v7 + 16 * v8 + 4) == v11
       && *(_DWORD *)(v7 + 16 * v8) == LODWORD(v10)
       && vabds_f32(v16, *(float *)(v7 + 16 * v8 + 8)) <= 0.0001);
  int v18 = (float *)(v13 + 28 * *(int *)(v14 + 32 * v15 + 12));
  float v20 = *v18;
  float v19 = v18[1];
  v26.var3 = 0;
  Path::PrevPoint(a5, v11 - 1, (float *)&v26.var3 + 1, (float *)&v26.var3);
  *(void *)&v26.int var0 = 0;
  *(void *)&v26.int var2 = 0;
  float v21 = (float *)((char *)a5->var3 + 44 * v11);
  Path::CubicTangent((Path *)(&v26.var2 + 1), v12, (float *)&v26.var2, v22, *((float *)&v26.var3 + 1), *(float *)&v26.var3, v21[6], v21[7], v21[4], v21[5], v21[8], v21[9]);
  int v23 = (float *)((char *)a5->var3 + 44 * v11);
  Path::CubicTangent((Path *)&v26.var1, v16, (float *)&v26.var0, v24, *((float *)&v26.var3 + 1), *(float *)&v26.var3, v23[6], v23[7], v23[4], v23[5], v23[8], v23[9]);
  Path::CubicTo(a4, v20, v19, (float)(v16 - v12) * *((float *)&v26.var2 + 1), (float)(v16 - v12) * *(float *)&v26.var2, (float)(v16 - v12) * *(float *)&v26.var1, (float)(v16 - v12) * *(float *)&v26.var0);
  return v8;
}

uint64_t Shape::ReFormeBezierTo(Shape *this, int a2, int a3, Path *a4, Path *a5)
{
  uint64_t v7 = *((void *)this + 12);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  float v9 = *v8;
  uint64_t v10 = *((unsigned int *)v8 + 1);
  uint64_t v11 = (int)v10;
  float v13 = v8[2];
  float v12 = v8[3];
  uint64_t v14 = *((void *)this + 3);
  uint64_t v15 = *((void *)this + 5);
  uint64_t v16 = v15 + 32 * a2;
  int v17 = (float *)(v14 + 28 * *(int *)(v16 + 8));
  float v19 = *v17;
  float v18 = v17[1];
  float v20 = (float *)(v14 + 28 * *(int *)(v16 + 12));
  float v22 = *v20;
  float v21 = v20[1];
  var3 = a5->var3;
  int v24 = v10;
  uint64_t v25 = (int)v10;
  if ((*((_DWORD *)var3 + 11 * (int)v10) & 0xF) == 3)
  {
LABEL_6:
    int v28 = *((_DWORD *)var3 + 11 * v25 + 4);
    uint64_t v29 = *((void *)this + 9);
    uint64_t v30 = *(unsigned int *)(v29 + 32 * a2 + 8);
    if ((v30 & 0x80000000) != 0
      || (uint64_t v31 = *(int *)(v15 + 32 * v30 + 8),
          *(_DWORD *)(v14 + 28 * (int)v31 + 12) + *(_DWORD *)(v14 + 28 * (int)v31 + 8) > 2))
    {
      int v32 = v10;
    }
    else
    {
      int v32 = v10;
      do
      {
        if (*(int *)(v14 + 28 * v31 + 24) > 2 || *(_DWORD *)(v7 + 16 * v30) != LODWORD(v9)) {
          break;
        }
        uint64_t v50 = v7 + 16 * v30;
        int v51 = *(_DWORD *)(v50 + 4);
        if (v51 < v24 || v51 >= v28 + v24) {
          break;
        }
        float v53 = *(float *)(v50 + 8);
        if (v51 == v32)
        {
          if (vabds_f32(v12, v53) > 0.0001) {
            break;
          }
        }
        else
        {
          double v54 = v53;
          if (v54 > 0.0001 && v54 < 0.9999 || v12 > 0.0001 && v12 < 0.9999) {
            break;
          }
        }
        CGPoint v55 = (float *)(v14 + 28 * *(int *)(v15 + 32 * v30 + 12));
        float v22 = *v55;
        float v21 = v55[1];
        float v12 = *(float *)(v7 + 16 * v30 + 12);
        uint64_t v30 = *(unsigned int *)(v29 + 32 * v30 + 8);
        if ((v30 & 0x80000000) != 0)
        {
          int v32 = v51;
          break;
        }
        uint64_t v31 = *(int *)(v15 + 32 * v30 + 8);
        int v32 = v51;
      }
      while (*(_DWORD *)(v14 + 28 * (int)v31 + 12) + *(_DWORD *)(v14 + 28 * (int)v31 + 8) <= 2);
    }
    uint64_t v78 = 0;
    Path::PrevPoint(a5, v24 - 1, (float *)&v78 + 1, (float *)&v78);
    int v34 = v32 - v10;
    if (v32 == v10)
    {
      float v35 = v19;
      float v36 = v18;
      float v37 = v22;
      float v38 = v21;
      uint64_t v39 = a4;
      int v40 = v24;
      int v41 = v28;
      uint64_t v42 = a5;
      int v43 = v10;
      float v44 = v13;
LABEL_63:
      Shape::ReFormeBezierChunk(v33, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v12);
      return v30;
    }
    CGPoint v45 = a5->var3;
    double v46 = v13;
    double v47 = v12;
    if (v32 <= (int)v10)
    {
      if (v46 <= 0.9999)
      {
        uint64_t v60 = (int)v10 + 1;
        Shape::ReFormeBezierChunk(v33, v19, v18, (float)(*((float *)v45 + 11 * v60 + 4) + *((float *)v45 + 11 * (int)v10 + 4)) * 0.5, (float)(*((float *)v45 + 11 * v60 + 5) + *((float *)v45 + 11 * (int)v10 + 5)) * 0.5, a4, v24, v28, a5, v10, v13, 0.0);
        if (v47 < 0.0001)
        {
          Path::BezierTo(a4, v22, v21);
          uint64_t v61 = v32;
          uint64_t v62 = (int)v10 + 2;
          uint64_t v63 = 44 * v60;
          do
          {
            Path::IntermBezierTo(a4, *(float *)((char *)a5->var3 + v63 + 16), *(float *)((char *)a5->var3 + v63 + 20));
            --v62;
            v63 -= 44;
          }
          while (v62 > v61);
          goto LABEL_48;
        }
        uint64_t v75 = (float *)((char *)a5->var3 + 44 * v32);
        float v65 = (float)(v75[15] + v75[26]) * 0.5;
        float v66 = (float)(v75[16] + v75[27]) * 0.5;
        Path::BezierTo(a4, v65, v66);
        uint64_t v76 = 44 * v60;
        do
        {
          Path::IntermBezierTo(a4, *(float *)((char *)a5->var3 + v76 + 16), *(float *)((char *)a5->var3 + v76 + 20));
          --v60;
          v76 -= 44;
        }
        while (v60 > v32);
      }
      else
      {
        if (v47 < 0.0001)
        {
          Path::BezierTo(a4, v22, v21);
          uint64_t v56 = v32;
          uint64_t v57 = (int)v10 + 1;
          uint64_t v58 = 44 * (int)v10;
          do
          {
            Path::IntermBezierTo(a4, *(float *)((char *)a5->var3 + v58 + 60), *(float *)((char *)a5->var3 + v58 + 64));
            --v57;
            v58 -= 44;
          }
          while (v57 > v56);
          goto LABEL_48;
        }
        double v69 = (float *)((char *)v45 + 44 * v32);
        float v65 = (float)(v69[15] + v69[26]) * 0.5;
        float v66 = (float)(v69[16] + v69[27]) * 0.5;
        Path::BezierTo(a4, v65, v66);
        if (v32 < (int)v10)
        {
          uint64_t v70 = 44 * (int)v10;
          do
          {
            Path::IntermBezierTo(a4, *(float *)((char *)a5->var3 + v70 + 60), *(float *)((char *)a5->var3 + v70 + 64));
            --v11;
            v70 -= 44;
          }
          while (v11 > v32);
        }
      }
      float v33 = (Shape *)Path::EndBezierTo(a4);
      float v44 = 1.0;
    }
    else
    {
      if (v46 >= 0.0001)
      {
        Shape::ReFormeBezierChunk(v33, v19, v18, (float)(*((float *)v45 + 11 * (int)v10 + 15) + *((float *)v45 + 11 * (int)v10 + 26)) * 0.5, (float)(*((float *)v45 + 11 * (int)v10 + 16) + *((float *)v45 + 11 * (int)v10 + 27)) * 0.5, a4, v24, v28, a5, v10, v13, 1.0);
        if (v47 > 0.9999)
        {
          Path::BezierTo(a4, v22, v21);
          uint64_t v59 = 44 * (int)v10;
          do
          {
            Path::IntermBezierTo(a4, *(float *)((char *)a5->var3 + v59 + 104), *(float *)((char *)a5->var3 + v59 + 108));
            v59 += 44;
            --v34;
          }
          while (v34);
          goto LABEL_48;
        }
        double v71 = a5->var3;
        double v72 = (float *)((char *)v71 + 44 * v32 + 44);
        double v73 = (float *)((char *)v71 + 44 * v32);
        float v65 = (float)(v72[4] + v73[4]) * 0.5;
        float v66 = (float)(v72[5] + v73[5]) * 0.5;
        Path::BezierTo(a4, v65, v66);
        uint64_t v74 = 44 * (int)v10;
        do
        {
          Path::IntermBezierTo(a4, *(float *)((char *)a5->var3 + v74 + 104), *(float *)((char *)a5->var3 + v74 + 108));
          LODWORD(v10) = v10 + 1;
          v74 += 44;
        }
        while (v32 != v10);
      }
      else
      {
        if (v47 > 0.9999)
        {
          Path::BezierTo(a4, v22, v21);
          uint64_t v48 = v32 + 1 - (uint64_t)(int)v10;
          uint64_t v49 = 44 * (int)v10;
          do
          {
            Path::IntermBezierTo(a4, *(float *)((char *)a5->var3 + v49 + 60), *(float *)((char *)a5->var3 + v49 + 64));
            v49 += 44;
            --v48;
          }
          while (v48);
LABEL_48:
          Path::EndBezierTo(a4);
          return v30;
        }
        CGPoint v64 = (float *)((char *)v45 + 44 * v32);
        float v65 = (float)(v64[15] + v64[4]) * 0.5;
        float v66 = (float)(v64[16] + v64[5]) * 0.5;
        Path::BezierTo(a4, v65, v66);
        uint64_t v67 = v32 - (uint64_t)(int)v10;
        uint64_t v68 = 44 * (int)v11;
        do
        {
          Path::IntermBezierTo(a4, *(float *)((char *)a5->var3 + v68 + 60), *(float *)((char *)a5->var3 + v68 + 64));
          v68 += 44;
          --v67;
        }
        while (v67);
      }
      float v33 = (Shape *)Path::EndBezierTo(a4);
      float v44 = 0.0;
    }
    float v35 = v65;
    float v36 = v66;
    float v37 = v22;
    float v38 = v21;
    uint64_t v39 = a4;
    int v40 = v24;
    int v41 = v28;
    uint64_t v42 = a5;
    int v43 = v32;
    goto LABEL_63;
  }
  Path v26 = (int *)((char *)var3 + 44 * v10 - 44);
  uint64_t v25 = v10;
  while ((int)v25 >= 2)
  {
    --v25;
    int v27 = *v26;
    v26 -= 11;
    if ((v27 & 0xF) == 3)
    {
      int v24 = v25;
      goto LABEL_6;
    }
  }
  uint64_t v30 = *(unsigned int *)(*((void *)this + 9) + 32 * a2 + 8);
  Path::LineTo(a4, v22, v21);
  return v30;
}

uint64_t Shape::ReFormeBezierChunk(Shape *this, float a2, float a3, float a4, float a5, Path *a6, int a7, int a8, Path *a9, int a10, float a11, float a12)
{
  *(void *)&v30.int var2 = 0;
  Path::PrevPoint(a9, a7 - 1, (float *)&v30.var2 + 1, (float *)&v30.var2);
  var3 = a9->var3;
  float32x2_t v25 = *(float32x2_t *)((char *)var3 + 44 * a7 + 20);
  if (a10 == a7)
  {
    float32x2_t v26 = *(float32x2_t *)((char *)var3 + 44 * a7 + 60);
    if (a8 >= 2)
    {
      int v27 = (char *)var3 + 44 * a7;
LABEL_7:
      float32x2_t v25 = vmul_f32(vadd_f32(v26, *(float32x2_t *)(v27 + 104)), (float32x2_t)0x3F0000003F000000);
    }
  }
  else
  {
    float v28 = *((float *)var3 + 11 * a10 + 4);
    if (a8 + a7 - 1 != a10)
    {
      int v27 = (char *)var3 + 44 * a10;
      float32x2_t v26 = *(float32x2_t *)(v27 + 60);
      *((float *)&v30.var2 + 1) = (float)(v26.f32[0] + v28) * 0.5;
      *(float *)&v30.int var2 = (float)(v26.f32[1] + *((float *)v27 + 5)) * 0.5;
      goto LABEL_7;
    }
    float32x2_t v26 = *(float32x2_t *)((char *)var3 + 44 * a8 + 44 * a7 + 16);
    *((float *)&v30.var2 + 1) = (float)(v26.f32[0] + v28) * 0.5;
    *(float *)&v30.int var2 = (float)(v26.f32[1] + *((float *)var3 + 11 * a10 + 5)) * 0.5;
  }
  *(void *)&v30.int var0 = 0;
  Path::QuadraticPoint((Path *)&v30.var1, (float)(a11 + a12) * 0.5, (float *)&v30.var0, v23, *((float *)&v30.var2 + 1), *(float *)&v30.var2, v26.f32[0], v26.f32[1], v25.f32[0], v25.f32[1]);
  *(float *)&v30.int var0 = (float)((float)(a3 + a5) * -0.5) + (float)(*(float *)&v30.var0 * 2.0);
  *(float *)&v30.var1 = (float)((float)(a2 + a4) * -0.5) + (float)(*(float *)&v30.var1 * 2.0);
  Path::BezierTo(a6, a4, a5);
  Path::IntermBezierTo(a6, *(float *)&v30.var1, *(float *)&v30.var0);
  return Path::EndBezierTo(a6);
}

void Shape::ResetSweep(Shape *this)
{
  Shape::MakePointData(this, 1);
  Shape::MakeEdgeData(this, 1);

  Shape::MakeSweepSrcData(this, 1);
}

void Shape::CleanupSweep(Shape *this)
{
  Shape::MakePointData(this, 0);
  Shape::MakeEdgeData(this, 0);

  Shape::MakeSweepSrcData(this, 0);
}

uint64_t Shape::ForceToPolygon(uint64_t this)
{
  *(_DWORD *)(this + 48) = 1;
  return this;
}

uint64_t Shape::Reoriente(void **this, Shape *a2)
{
  Shape::Reset(this, 0);
  uint64_t result = 0;
  if (*((int *)a2 + 4) < 2) {
    return result;
  }
  if (*((int *)a2 + 8) < 2) {
    return 0;
  }
  if (!Shape::Eulerian(a2, 1)) {
    return 5;
  }
  int v5 = *((_DWORD *)a2 + 4);
  *((_DWORD *)this + 4) = v5;
  if (v5 > *((_DWORD *)this + 5))
  {
    *((_DWORD *)this + 5) = v5;
    this[3] = reallocf(this[3], 28 * v5);
    if ((*((unsigned char *)this + 52) & 4) != 0) {
      this[11] = reallocf(this[11], 48 * *((int *)this + 5));
    }
  }
  memcpy(this[3], *((const void **)a2 + 3), 28 * *((int *)this + 4));
  int v6 = *((_DWORD *)a2 + 8);
  *((_DWORD *)this + 8) = v6;
  if (v6 <= *((_DWORD *)this + 9)) {
    goto LABEL_14;
  }
  *((_DWORD *)this + 9) = v6;
  this[5] = malloc_type_realloc(this[5], 32 * v6, 0x1000040E0EAB150uLL);
  int v7 = *((_DWORD *)this + 13);
  if ((v7 & 8) != 0)
  {
    this[7] = reallocf(this[7], (uint64_t)*((int *)this + 9) << 6);
    int v7 = *((_DWORD *)this + 13);
    if ((v7 & 0x10) == 0)
    {
LABEL_11:
      if ((v7 & 0x20) == 0) {
        goto LABEL_12;
      }
LABEL_50:
      this[9] = reallocf(this[9], 32 * *((int *)this + 9));
      if ((*((_DWORD *)this + 13) & 0x80) == 0) {
        goto LABEL_14;
      }
      goto LABEL_13;
    }
  }
  else if ((v7 & 0x10) == 0)
  {
    goto LABEL_11;
  }
  this[8] = reallocf(this[8], 56 * *((int *)this + 9));
  int v7 = *((_DWORD *)this + 13);
  if ((v7 & 0x20) != 0) {
    goto LABEL_50;
  }
LABEL_12:
  if ((v7 & 0x80) != 0) {
LABEL_13:
  }
    this[10] = reallocf(this[10], 48 * *((int *)this + 9));
LABEL_14:
  memcpy(this[5], *((const void **)a2 + 5), 32 * *((int *)this + 8));
  Shape::MakePointData((Shape *)this, 1);
  Shape::MakeEdgeData((Shape *)this, 1);
  Shape::MakeSweepDestData((Shape *)this, 1);
  uint64_t v8 = *((unsigned int *)this + 4);
  if ((int)v8 >= 1)
  {
    float v9 = (float *)((char *)this[11] + 40);
    uint64_t v10 = (float *)((char *)this[3] + 4);
    uint64_t v11 = *((unsigned int *)this + 4);
    do
    {
      *((void *)v9 - 4) = 0xFFFFFFFF00000000;
      *(v9 - 6) = NAN;
      float v12 = ldexpf(*(v10 - 1), 5);
      float v13 = ldexpf(roundf(v12), -5);
      *(v9 - 1) = v13;
      float v14 = ldexpf(*v10, 5);
      float v15 = ldexpf(roundf(v14), -5);
      *float v9 = v15;
      v9 += 12;
      *(v10 - 1) = v13;
      *uint64_t v10 = v15;
      v10 += 7;
      --v11;
    }
    while (v11);
    uint64_t v16 = (char *)this[3] + 12;
    do
    {
      v16[3] = *v16 + *(v16 - 1);
      v16 += 7;
      --v8;
    }
    while (v8);
  }
  uint64_t v17 = *((unsigned int *)a2 + 8);
  if ((int)v17 >= 1)
  {
    float v18 = (char *)this[11];
    float v19 = (int *)((char *)this[5] + 12);
    float v20 = (float32x2_t *)((char *)this[7] + 4);
    do
    {
      float32x2_t v21 = vsub_f32(*(float32x2_t *)&v18[48 * *v19 + 36], *(float32x2_t *)&v18[48 * *(v19 - 1) + 36]);
      *float v20 = v21;
      v20[-1].i32[1] = 1;
      *(float32x2_t *)(v19 - 3) = v21;
      v19 += 8;
      v20 += 8;
      --v17;
    }
    while (v17);
  }
  Shape::SortPointsRounded((Shape *)this);
  Shape::SetFlag((Shape *)this, 2, 1);
  Shape::GetWindings((Shape *)this, v22, v23, v24, 1);
  if (*((int *)this + 8) >= 1)
  {
    for (int i = 0; i < *((_DWORD *)this + 8); ++i)
    {
      uint64_t v26 = (uint64_t)this[9] + 32 * i;
      int v28 = *(_DWORD *)(v26 + 16);
      int v27 = (int *)(v26 + 16);
      int v29 = v28 & 1;
      if (v28 >= 0) {
        int v30 = v29;
      }
      else {
        int v30 = -v29;
      }
      *int v27 = v30;
      uint64_t v31 = v27 + 1;
      if (v27[1] >= 0) {
        int v32 = v27[1] & 1;
      }
      else {
        int v32 = -(v27[1] & 1);
      }
      *uint64_t v31 = v32;
      if (v30 < 0)
      {
        *int v27 = -v30;
        int v30 = 1;
        if ((v32 & 0x80000000) == 0)
        {
LABEL_32:
          if (v30) {
            goto LABEL_33;
          }
          goto LABEL_37;
        }
      }
      else if ((v32 & 0x80000000) == 0)
      {
        goto LABEL_32;
      }
      *uint64_t v31 = -v32;
      int v32 = 1;
      if (v30)
      {
LABEL_33:
        float v33 = this[7];
        if (v32) {
          goto LABEL_41;
        }
        goto LABEL_39;
      }
LABEL_37:
      if (!v32)
      {
        float v33 = this[7];
LABEL_41:
        v33[16 * (uint64_t)i] = 0;
        Shape::SubEdge((Shape *)this, i--);
        continue;
      }
      Shape::Inverse((Shape *)this, i);
      float v33 = this[7];
LABEL_39:
      v33[16 * (uint64_t)i] = 1;
    }
  }
  Shape::MakePointData((Shape *)this, 0);
  Shape::MakeEdgeData((Shape *)this, 0);
  Shape::MakeSweepDestData((Shape *)this, 0);
  if (Shape::Eulerian((Shape *)this, 1))
  {
    uint64_t result = 0;
    *((_DWORD *)this + 12) = 1;
  }
  else
  {
    *((_DWORD *)this + 8) = 0;
    *((_DWORD *)this + 4) = 0;
    return 4;
  }
  return result;
}

void Shape::GetWindings(Shape *this, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *((unsigned int *)this + 8);
  if ((int)v6 >= 1)
  {
    int v7 = (void *)(*((void *)this + 9) + 8);
    do
    {
      *(v7 - 1) = 0;
      *int v7 = -1;
      v7 += 4;
      --v6;
    }
    while (v6);
  }
  Shape::SortEdges(this);
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  int v10 = *((_DWORD *)this + 4);
  do
  {
    if ((int)v9 >= v10) {
      goto LABEL_64;
    }
    uint64_t v11 = *((void *)this + 3);
    uint64_t v12 = v9 << 32;
    float v13 = (unsigned int *)(v11 + 28 * (int)v9 + 16);
    while (1)
    {
      unsigned int v15 = *v13;
      v13 += 7;
      uint64_t v14 = v15;
      if ((v15 & 0x80000000) == 0)
      {
        uint64_t v16 = *((void *)this + 9);
        if (!*(void *)(v16 + 32 * v14)) {
          break;
        }
      }
      v12 += 0x100000000;
      LODWORD(v9) = v9 + 1;
      if (v10 == v9)
      {
        LODWORD(v9) = v10;
        goto LABEL_64;
      }
    }
    uint64_t v17 = v12 >> 32;
    uint64_t v18 = v11 + 28 * SHIDWORD(v12);
    uint64_t v19 = *(unsigned int *)(v18 + 16);
    if ((v19 & 0x80000000) == 0)
    {
      if (v9)
      {
        if (a5)
        {
          uint64_t v20 = v8;
          int v21 = Shape::Winding(this, *(float *)v18, *(float *)(v11 + 28 * (int)v17 + 4));
          uint64_t v8 = v20;
          int v22 = v21;
          goto LABEL_19;
        }
        uint64_t v23 = *(unsigned int *)(*((void *)this + 11) + 48 * (int)v17 + 32);
        if ((v23 & 0x80000000) == 0)
        {
          uint64_t v24 = *((void *)this + 5) + 32 * v23;
          uint64_t v25 = v16 + 32 * v23;
          if (*(_DWORD *)(v24 + 8) >= *(_DWORD *)(v24 + 12)) {
            int v22 = *(_DWORD *)(v25 + 20);
          }
          else {
            int v22 = *(_DWORD *)(v25 + 16);
          }
LABEL_19:
          uint64_t v26 = *((void *)this + 5);
          if (*(_DWORD *)(v11 + 28 * (int)v17 + 12) + *(_DWORD *)(v11 + 28 * (int)v17 + 8) == 1
            && *(_DWORD *)(v26 + 32 * v19 + 12) == v9)
          {
            if (*(_DWORD *)(*((void *)this + 7) + (v19 << 6)))
            {
              *(_DWORD *)(*((void *)this + 11) + 48 * *(int *)(v26 + 32 * v19 + 8) + 32) = *(_DWORD *)(*((void *)this + 11) + 48 * (int)v17 + 32);
            }
            else
            {
              uint64_t v27 = v8;
              Shape::Inverse(this, v19);
              uint64_t v8 = v27;
              uint64_t v26 = *((void *)this + 5);
            }
          }
          uint64_t v28 = *((void *)this + 7);
          int v29 = *(_DWORD *)(v28 + (v19 << 6));
          if (*(_DWORD *)(v26 + 32 * v19 + 12) == v9) {
            int v30 = *(_DWORD *)(v28 + (v19 << 6));
          }
          else {
            int v30 = 0;
          }
          int v31 = v22 + v30;
          uint64_t v32 = *((void *)this + 9);
          uint64_t v33 = v32 + 32 * v19;
          BOOL v34 = 1;
          *(void *)uint64_t v33 = 1;
          *(_DWORD *)(v33 + 16) = v31;
          *(_DWORD *)(v33 + 20) = v31 - v29;
          *(void *)(v33 + 8) = -1;
LABEL_29:
          LODWORD(v35) = v19;
LABEL_30:
          if (v34) {
            uint64_t v36 = 12;
          }
          else {
            uint64_t v36 = 8;
          }
          int v37 = *(_DWORD *)(*((void *)this + 5) + 32 * v35 + v36);
          LODWORD(v19) = v35;
          while (1)
          {
            int v38 = v19;
            uint64_t v39 = v26 + 32 * (int)v19;
            int v41 = *(_DWORD *)(v39 + 8);
            int v40 = *(_DWORD *)(v39 + 12);
            uint64_t v42 = v32 + 32 * (int)v19;
            if (v40 == v37) {
              break;
            }
            int v43 = *(_DWORD *)(v42 + 16);
            if (v41 == v37) {
              goto LABEL_39;
            }
            LODWORD(v19) = -1;
LABEL_42:
            if (v19 == v38) {
              goto LABEL_52;
            }
            BOOL v44 = (int)v19 < 0 || v19 == v35;
            BOOL v45 = v44;
            if (v44) {
              goto LABEL_52;
            }
            if (!*(void *)(v32 + 32 * v19))
            {
              if (!v45)
              {
                uint64_t v49 = v32 + 32 * v19;
                *(void *)uint64_t v49 = 1;
                uint64_t v50 = v26 + 32 * v19;
                int v51 = *(_DWORD *)(v50 + 8);
                int v52 = *(_DWORD *)(v28 + ((unint64_t)v19 << 6));
                BOOL v53 = v37 == v51;
                if (v37 == v51) {
                  int v54 = 0;
                }
                else {
                  int v54 = *(_DWORD *)(v28 + ((unint64_t)v19 << 6));
                }
                if (!v53) {
                  int v52 = 0;
                }
                *(_DWORD *)(v49 + 20) = v43 - v54;
                *(_DWORD *)(v49 + 24) = v8;
                *(_DWORD *)(v49 + 12) = v35;
                *(_DWORD *)(v49 + 16) = v43 + v52;
                *(_DWORD *)(v32 + 32 * (int)v35 + 8) = v19;
                BOOL v34 = v37 != *(_DWORD *)(v50 + 12);
                uint64_t v8 = (v8 + 1);
                goto LABEL_29;
              }
LABEL_52:
              uint64_t v46 = (int)v35;
              uint64_t v35 = *(unsigned int *)(v32 + 32 * (int)v35 + 12);
              if ((v35 & 0x80000000) == 0)
              {
                uint64_t v47 = v26 + 32 * v46;
                if (v34) {
                  uint64_t v48 = 8;
                }
                else {
                  uint64_t v48 = 12;
                }
                BOOL v34 = *(_DWORD *)(v47 + v48) == *(_DWORD *)(v26 + 32 * v35 + 12);
                goto LABEL_30;
              }
              int v10 = *((_DWORD *)this + 4);
              goto LABEL_64;
            }
          }
          int v43 = *(_DWORD *)(v42 + 20);
          if (v41 == v37)
          {
LABEL_39:
            LODWORD(v19) = *(_DWORD *)(v26 + 32 * (int)v19 + 20);
            if ((v19 & 0x80000000) == 0) {
              goto LABEL_42;
            }
          }
          else
          {
            LODWORD(v19) = *(_DWORD *)(v26 + 32 * (int)v19 + 28);
            if ((v19 & 0x80000000) == 0) {
              goto LABEL_42;
            }
          }
          LODWORD(v19) = *(_DWORD *)(*((void *)this + 3) + 28 * v37 + 20);
          goto LABEL_42;
        }
      }
      int v22 = 0;
      goto LABEL_19;
    }
LABEL_64:
    uint64_t v9 = (v9 + 1);
  }
  while ((int)v9 < v10);
}

uint64_t Shape::ConvertToShape(void **a1, uint64_t a2, int a3, char a4)
{
  Shape::Reset(a1, 0);
  uint64_t result = 0;
  if (*(int *)(a2 + 16) < 2) {
    return result;
  }
  if (*(int *)(a2 + 32) < 2) {
    return 0;
  }
  if (!Shape::Eulerian((Shape *)a2, 1)) {
    return 5;
  }
  int v254 = a3;
  char v253 = a4;
  Shape::ResetSweep((Shape *)a2);
  if (!Shape::GetFlag((Shape *)a1, 64))
  {
    SweepTree::CreateList((uint64_t)(a1 + 21), *(_DWORD *)(a2 + 32));
    SweepEvent::CreateQueue((uint64_t)(a1 + 24), *(_DWORD *)(a2 + 32));
    Shape::SetFlag((Shape *)a1, 64, 1);
  }
  Shape::MakePointData((Shape *)a1, 1);
  Shape::MakeEdgeData((Shape *)a1, 1);
  Shape::MakeSweepSrcData((Shape *)a1, 1);
  Shape::MakeSweepDestData((Shape *)a1, 1);
  v260 = (Shape *)a1;
  Shape::MakeBackData((Shape *)a1, (*(_DWORD *)(a2 + 52) >> 9) & 1);
  uint64_t v9 = *(unsigned int *)(a2 + 16);
  if ((int)v9 >= 1)
  {
    int v10 = (float *)(*(void *)(a2 + 88) + 40);
    uint64_t v11 = (float *)(*(void *)(a2 + 24) + 4);
    do
    {
      *((void *)v10 - 4) = 0xFFFFFFFF00000000;
      *(v10 - 6) = NAN;
      float v12 = ldexpf(*(v11 - 1), 5);
      *(v10 - 1) = ldexpf(roundf(v12), -5);
      float v13 = *v11;
      v11 += 7;
      float v14 = ldexpf(v13, 5);
      *int v10 = ldexpf(roundf(v14), -5);
      v10 += 12;
      --v9;
    }
    while (v9);
  }
  uint64_t v15 = *(unsigned int *)(a2 + 32);
  uint64_t v16 = (uint64_t)v260;
  if ((int)v15 >= 1)
  {
    uint64_t v17 = 0;
    uint64_t v18 = *(void *)(a2 + 88);
    uint64_t v19 = *(void *)(a2 + 64);
    uint64_t v20 = 56 * v15;
    int v21 = (int *)(*(void *)(a2 + 40) + 12);
    uint64_t v22 = *(void *)(a2 + 56) + 32;
    do
    {
      float32x2_t v23 = vsub_f32(*(float32x2_t *)(v18 + 48 * *v21 + 36), *(float32x2_t *)(v18 + 48 * *(v21 - 1) + 36));
      *(float32x2_t *)(v22 - 28) = v23;
      double v24 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v23, v23).i32[1]), v23.f32[0], v23.f32[0]);
      double v25 = sqrt(v24);
      *(double *)(v22 - 16) = v24;
      *(double *)(v22 - 8) = v25;
      *(double *)uint64_t v22 = 1.0 / v24;
      *(double *)(v22 + 8) = 1.0 / v25;
      int8x16_t v26 = (int8x16_t)vmulq_n_f64(vcvtq_f64_f32(v23), 1.0 / v25);
      double v27 = *(double *)&v26.i64[1];
      float64x2_t v28 = (float64x2_t)vextq_s8(v26, v26, 8uLL);
      *(float64x2_t *)(v22 + 16) = v28;
      if (v27 < 0.0) {
        *(float64x2_t *)(v22 + 16) = vnegq_f64(v28);
      }
      uint64_t v29 = v19 + v17;
      *(void *)uint64_t v29 = 0;
      v21 += 8;
      *(_DWORD *)(v29 + 16) = -1;
      *(void *)(v29 + 8) = -1;
      *(void *)(v29 + 24) = -1;
      *(void *)(v29 + 32) = 0;
      *(void *)(v29 + 40) = -1;
      v17 += 56;
      v22 += 64;
      *(_DWORD *)(v29 + 48) = -1;
    }
    while (v20 != v17);
  }
  Shape::SortPointsRounded((Shape *)a2);
  int v30 = 0;
  int v31 = 0;
  *((void *)v260 + 17) = 0;
  v256 = (void *)((char *)v260 + 136);
  *((void *)v260 + 18) = 0;
  float v32 = *(float *)(*(void *)(a2 + 88) + 40) + -1.0;
  v272[0] = -1;
  *((void *)v260 + 19) = 0;
  uint64_t v33 = (int *)((char *)v260 + 192);
  v271 = 0;
  v262 = (int *)((char *)v260 + 168);
  *((void *)v260 + 20) = 0;
  v265 = (int *)((char *)v260 + 192);
  uint64_t v255 = a2;
  while (v30 < *(_DWORD *)(a2 + 16) || *v33 >= 1)
  {
    float v270 = 0.0;
    float v269 = 0.0;
    v267 = 0;
    uint64_t v268 = 0;
    v266 = 0;
    BOOL v34 = SweepEvent::PeekInQueue(&v267, &v266, &v270, &v269, (_DWORD *)&v268 + 1, &v268, (uint64_t)v33);
    uint64_t v35 = *(void *)(a2 + 88);
    if (v34)
    {
      if (*(int *)(v35 + 48 * v30 + 8) > 0
        || (uint64_t v36 = v35 + 48 * v30, v38 = *(float *)(v36 + 40), v37 = (float *)(v36 + 40), v39 = v38, v38 > v269)
        || ((uint64_t v40 = v35 + 48 * v30, v41 = *(float *)(v40 + 36), v39 == v269) ? (v42 = v41 <= v270) : (v42 = 1), !v42))
      {
        SweepEvent::ExtractFromQueue(&v267, &v266, &v270, &v269, (_DWORD *)&v268 + 1, &v268, (uint64_t)v33);
        uint64_t v48 = 0;
        float v41 = v270;
        int v47 = 1;
        float v45 = v269;
        int v263 = v30;
        int v30 = -1;
LABEL_32:
        float v49 = ldexpf(v41, 5);
        float v50 = ldexpf(roundf(v49), -5);
        float v51 = ldexpf(v45, 5);
        float v52 = ldexpf(roundf(v51), -5);
        uint64_t v53 = Shape::AddPoint((Shape *)v16, v50, v52);
        signed int v54 = v53;
        uint64_t v55 = *(void *)(v16 + 88) + 48 * (int)v53;
        *(float *)(v55 + 36) = v50;
        *(float *)(v55 + 40) = v52;
        if (v52 <= v32)
        {
          int v79 = v53;
          if (v47) {
            goto LABEL_124;
          }
LABEL_53:
          unsigned int v89 = *(_DWORD *)(*(void *)(v48 + 24) + 28 * v30 + 16);
          if ((v89 & 0x80000000) == 0)
          {
            unsigned int v90 = 0;
            int v91 = 0;
            unsigned int v92 = -1;
            unsigned int v93 = -1;
            unsigned int v94 = *(_DWORD *)(*(void *)(v48 + 24) + 28 * v30 + 16);
            do
            {
              if ((signed int)v94 >= *(_DWORD *)(v48 + 32)) {
                break;
              }
              uint64_t v95 = *(void *)(v48 + 40);
              uint64_t v96 = v95 + 32 * v94;
              int v98 = *(_DWORD *)(v96 + 8);
              int v97 = *(_DWORD *)(v96 + 12);
              BOOL v99 = v98 < v97 && v30 == v97;
              if (v99 || (v30 == v98 ? (BOOL v100 = v98 <= v97) : (BOOL v100 = 1), !v100))
              {
                ++v91;
                unsigned int v93 = v94;
              }
              BOOL v101 = v30 == v98;
              BOOL v102 = v98 > v97;
              if (v98 >= v97) {
                BOOL v101 = 0;
              }
              if (v30 != v97) {
                BOOL v102 = 0;
              }
              int v103 = v102 || v101;
              if (v103) {
                unsigned int v92 = v94;
              }
              v90 += v103;
              if (v30 == v98)
              {
                float v104 = (unsigned int *)(v95 + 32 * v94 + 16);
              }
              else
              {
                if (v30 != v97) {
                  break;
                }
                float v104 = (unsigned int *)(v95 + 32 * v94 + 24);
              }
              unsigned int v94 = *v104;
            }
            while ((v94 & 0x80000000) == 0);
            unsigned int v105 = -1;
            int v264 = v31;
            if (v90 && (v93 & 0x80000000) == 0)
            {
              if (*(void *)(*(void *)(v48 + 64) + 56 * v93)) {
                unsigned int v105 = v93;
              }
              else {
                unsigned int v105 = -1;
              }
            }
            int v261 = v79;
            if (v91 >= 1)
            {
              unsigned int v258 = v105;
              do
              {
                if ((signed int)v89 >= *(_DWORD *)(v48 + 32)) {
                  break;
                }
                uint64_t v106 = v89;
                uint64_t v107 = *(void *)(v48 + 40) + 32 * v89;
                int v108 = *(_DWORD *)(v107 + 8);
                int v109 = *(_DWORD *)(v107 + 12);
                if (v108 < v109 && v30 == v109)
                {
                  if (v89 != v105) {
                    goto LABEL_98;
                  }
                }
                else if (v30 == v108 && v108 > v109 && v89 != v105)
                {
LABEL_98:
                  uint64_t v113 = *(uint64_t **)(*(void *)(v48 + 64) + 56 * v89);
                  if (v113)
                  {
                    int v114 = -1;
                    Shape::AddChgt(v260, v79, v264, &v271, v272, 1, (Shape *)v113[8], *((_DWORD *)v113 + 18), 0, -1);
                    *(void *)(*(void *)(v48 + 64) + 56 * v106) = 0;
                    uint64_t v115 = *v113;
                    if (*v113)
                    {
                      int v114 = *(_DWORD *)(v115 + 72);
                      uint64_t v116 = *(void *)(v115 + 64);
                    }
                    else
                    {
                      uint64_t v116 = 0;
                    }
                    uint64_t v117 = v113[1];
                    if (v117)
                    {
                      int v257 = *(_DWORD *)(v117 + 72);
                      uint64_t v118 = *(void *)(v117 + 64);
                    }
                    else
                    {
                      uint64_t v118 = 0;
                      int v257 = -1;
                    }
                    SweepTree::Remove((AVLTree *)v113, (uint64_t)v262, v265, 1);
                    int v79 = v261;
                    unsigned int v105 = v258;
                    if (v116)
                    {
                      if (v118)
                      {
                        if (v116 != v48
                          || (uint64_t v124 = *(void *)(v48 + 40) + 32 * v114, *(_DWORD *)(v124 + 12) != v30)
                          && *(_DWORD *)(v124 + 8) != v30)
                        {
                          if (v118 != v48
                            || (uint64_t v125 = *(void *)(v48 + 40) + 32 * v257, *(_DWORD *)(v125 + 12) != v30)
                            && *(_DWORD *)(v125 + 8) != v30)
                          {
                            Shape::TesteIntersection((uint64_t)v260, *(SweepTree **)(*(void *)(v116 + 64) + 56 * v114), 0, 0, v119, v120, v121, v122, v123);
                            unsigned int v105 = v258;
                            int v79 = v261;
                          }
                        }
                      }
                    }
                  }
                }
                uint64_t v126 = *(void *)(v48 + 40);
                long long v127 = (_DWORD *)(v126 + 32 * v106);
                if (v127[2] == v30)
                {
                  long long v128 = v127 + 4;
                }
                else
                {
                  if (v127[3] != v30) {
                    break;
                  }
                  long long v128 = (unsigned int *)(v126 + 32 * v106 + 24);
                }
                unsigned int v89 = *v128;
              }
              while ((v89 & 0x80000000) == 0);
            }
            uint64_t v16 = (uint64_t)v260;
            if ((v92 & 0x80000000) != 0)
            {
              v259 = 0;
              char v131 = 1;
              int v31 = v264;
            }
            else if ((v105 & 0x80000000) != 0)
            {
              int v154 = v79;
              double v155 = (SweepTree *)SweepTree::AddInList(v48, v92, 1, v79, v262);
              *(void *)(*(void *)(v48 + 64) + 56 * v92) = v155;
              SweepTree::Insert(v155, (uint64_t)v262, v265, (uint64_t)v260, v154, 1, 1);
              v259 = v155;
              uint64_t v161 = *(void *)v155;
              if (*(void *)v155)
              {
                uint64_t v162 = *((void *)v260 + 11) + 48 * v154;
                *(void *)(v162 + 24) = *(void *)(v161 + 64);
                *(_DWORD *)(v162 + 32) = *(_DWORD *)(v161 + 72);
              }
              else
              {
                *(_DWORD *)(*((void *)v260 + 11) + 48 * v154 + 32) = -1;
              }
              int v31 = v264;
              Shape::TesteIntersection((uint64_t)v260, v259, 0, 0, v156, v157, v158, v159, v160);
              Shape::TesteIntersection((uint64_t)v260, v259, 1, 0, v163, v164, v165, v166, v167);
              *(_DWORD *)(*(void *)(v48 + 64) + 56 * v92 + 44) = v154;
              Shape::AddChgt(v260, v154, v264, &v271, v272, 0, *((Shape **)v259 + 8), *((_DWORD *)v259 + 18), 0, -1);
              char v131 = 0;
            }
            else
            {
              uint64_t v129 = 56 * v105;
              uint64_t v130 = *(void *)(*(void *)(v48 + 64) + v129);
              char v131 = 1;
              int v132 = v79;
              Shape::AddChgt(v260, v79, v264, &v271, v272, 1, *(Shape **)(v130 + 64), *(_DWORD *)(v130 + 72), 0, -1);
              *(void *)(*(void *)(v48 + 64) + v129) = 0;
              int v31 = v264;
              SweepTree::RemoveEvents(v130, v265);
              SweepTree::ConvertTo(v130, (Shape *)v48, v92, 1, v132);
              *(void *)(*(void *)(v48 + 64) + 56 * v92) = v130;
              Shape::TesteIntersection((uint64_t)v260, (SweepTree *)v130, 0, 0, v133, v134, v135, v136, v137);
              Shape::TesteIntersection((uint64_t)v260, (SweepTree *)v130, 1, 0, v138, v139, v140, v141, v142);
              *(_DWORD *)(*(void *)(v48 + 64) + 56 * v92 + 44) = v132;
              v259 = (SweepTree *)v130;
              Shape::AddChgt(v260, v132, v264, &v271, v272, 0, *(Shape **)(v130 + 64), *(_DWORD *)(v130 + 72), 0, -1);
            }
            if (v90 < 2)
            {
LABEL_160:
              a2 = v255;
              uint64_t v33 = (int *)((char *)v260 + 192);
            }
            else
            {
              unsigned int v168 = *(_DWORD *)(*(void *)(v48 + 24) + 28 * v30 + 16);
              if ((v168 & 0x80000000) == 0)
              {
                int v169 = v261;
                do
                {
                  if ((signed int)v168 >= *(_DWORD *)(v48 + 32)) {
                    break;
                  }
                  uint64_t v170 = *(void *)(v48 + 40);
                  uint64_t v171 = v168;
                  uint64_t v172 = v170 + 32 * v168;
                  int v173 = *(_DWORD *)(v172 + 8);
                  int v174 = *(_DWORD *)(v172 + 12);
                  if (v173 > v174 && v30 == v174)
                  {
                    if (v168 != v92) {
                      goto LABEL_148;
                    }
                  }
                  else if (v30 == v173 && v173 < v174 && v168 != v92)
                  {
LABEL_148:
                    uint64_t v178 = SweepTree::AddInList(v48, v168, 1, v169, v262);
                    *(void *)(*(void *)(v48 + 64) + 56 * v171) = v178;
                    int v31 = v264;
                    SweepTree::InsertAt((AVLTree *)v178, (uint64_t)v262, v265, (int)v260, (AVLTree **)v259, v30, 1, 1);
                    if (v131)
                    {
                      uint64_t v184 = *(void *)v178;
                      uint64_t v185 = *((void *)v260 + 11);
                      if (*(void *)v178)
                      {
                        int v186 = v261;
                        *(void *)(v185 + 48 * v261 + 24) = *(void *)(v184 + 64);
                        int v187 = *(_DWORD *)(v184 + 72);
                      }
                      else
                      {
                        int v187 = -1;
                        int v186 = v261;
                      }
                      *(_DWORD *)(v185 + 48 * v186 + 32) = v187;
                      int v169 = v261;
                    }
                    Shape::TesteIntersection((uint64_t)v260, (SweepTree *)v178, 0, 0, v179, v180, v181, v182, v183);
                    Shape::TesteIntersection((uint64_t)v260, (SweepTree *)v178, 1, 0, v188, v189, v190, v191, v192);
                    *(_DWORD *)(*(void *)(v48 + 64) + 56 * v171 + 44) = v169;
                    Shape::AddChgt(v260, v169, v264, &v271, v272, 0, *(Shape **)(v178 + 64), *(_DWORD *)(v178 + 72), 0, -1);
                    char v131 = 0;
                    uint64_t v170 = *(void *)(v48 + 40);
                    int v173 = *(_DWORD *)(v170 + 32 * v171 + 8);
                  }
                  float v193 = (_DWORD *)(v170 + 32 * v171);
                  if (v173 == v30)
                  {
                    float v194 = v193 + 4;
                  }
                  else
                  {
                    if (v193[3] != v30) {
                      goto LABEL_160;
                    }
                    float v194 = v193 + 6;
                  }
                  unsigned int v168 = *v194;
                }
                while ((*v194 & 0x80000000) == 0);
              }
              a2 = v255;
              uint64_t v33 = (int *)((char *)v260 + 192);
            }
          }
        }
        else
        {
          int v56 = Shape::AssemblePoints((Shape *)v16, v31, v53);
          if (v31 < v56)
          {
            uint64_t v58 = (int *)(*(void *)(v16 + 88) + 48 * v31 + 32);
            uint64_t v59 = v56 - (uint64_t)v31;
            int v60 = v31;
            do
            {
              uint64_t v61 = *((void *)v58 - 1);
              if (v61)
              {
                uint64_t v62 = *(void *)(v61 + 64) + 56 * *v58;
                *(v58 - 4) = *(_DWORD *)(v62 + 8);
                *(_DWORD *)(v62 + 8) = v60;
              }
              ++v60;
              v58 += 12;
              --v59;
            }
            while (v59);
          }
          uint64_t v63 = v271;
          if (v271)
          {
            uint64_t v64 = *(void *)(v16 + 88);
            float v65 = v272;
            do
            {
              uint64_t v66 = *((void *)v63 + 8) + 56 * *v65;
              int v67 = *(_DWORD *)(v66 + 28);
              *(_DWORD *)(v66 + 24) = *(_DWORD *)(v64 + 48 * *(int *)(v66 + 24) + 4);
              *(_DWORD *)(v66 + 28) = *(_DWORD *)(v64 + 48 * v67 + 4);
              float v65 = (int *)(v66 + 40);
              uint64_t v63 = *(Shape **)(v66 + 32);
            }
            while (v63);
          }
          uint64_t v68 = a2;
          uint64_t v69 = *(unsigned int *)v256;
          if ((int)v69 >= 1)
          {
            uint64_t v70 = *(void *)(v16 + 88);
            double v71 = (int *)(*(void *)(v16 + 144) + 8);
            while (1)
            {
              int v72 = *(v71 - 2);
              int v73 = *(_DWORD *)(v70 + 48 * *(v71 - 1) + 4);
              *(v71 - 1) = v73;
              if (v72 == 1) {
                break;
              }
              if (!v72)
              {
                uint64_t v74 = v71[2];
                uint64_t v75 = *(void *)(*(void *)v71 + 40) + 32 * v74;
                uint64_t v76 = *(void *)(*(void *)v71 + 64);
                if (*(_DWORD *)(v75 + 8) >= *(_DWORD *)(v75 + 12)) {
                  goto LABEL_48;
                }
LABEL_46:
                *(_DWORD *)(v76 + 56 * (int)v74 + 12) = v73;
              }
LABEL_49:
              v71 += 18;
              if (!--v69) {
                goto LABEL_50;
              }
            }
            uint64_t v74 = v71[2];
            uint64_t v77 = *(void *)(*(void *)v71 + 40) + 32 * v74;
            uint64_t v76 = *(void *)(*(void *)v71 + 64);
            if (*(_DWORD *)(v77 + 8) <= *(_DWORD *)(v77 + 12))
            {
LABEL_48:
              *(_DWORD *)(v76 + 56 * (int)v74 + 16) = v73;
              goto LABEL_49;
            }
            goto LABEL_46;
          }
LABEL_50:
          signed int v78 = v56;
          Shape::CheckAdjacencies(v16, v56, v31, v57);
          Shape::CheckEdges(v16, v78, v31, v68, 0, 0);
          int v79 = v78;
          if (v78 < v54)
          {
            uint64_t v80 = *(void *)(v16 + 24);
            uint64_t v81 = (long long *)(v80 + 28 * v54);
            int v82 = (_OWORD *)(v80 + 28 * v78);
            long long v83 = *v81;
            *(_OWORD *)((char *)v82 + 12) = *(long long *)((char *)v81 + 12);
            *int v82 = v83;
            uint64_t v84 = *(void *)(v16 + 88);
            int v85 = (long long *)(v84 + 48 * v54);
            uint64_t v86 = (_OWORD *)(v84 + 48 * v78);
            long long v87 = *v85;
            long long v88 = v85[2];
            v86[1] = v85[1];
            int v86[2] = v88;
            *uint64_t v86 = v87;
          }
          *(_DWORD *)(v16 + 16) = v78 + 1;
          *(_DWORD *)(v16 + 136) = 0;
          v272[0] = -1;
          v271 = 0;
          int v31 = v78;
          float v32 = v52;
          a2 = v68;
          uint64_t v33 = (int *)((char *)v260 + 192);
          if (!v47) {
            goto LABEL_53;
          }
LABEL_124:
          int v143 = v79;
          SweepTree::RemoveEvent((uint64_t)v267, v33, 1);
          SweepTree::RemoveEvent((uint64_t)v266, v33, 0);
          Shape::AddChgt((Shape *)v16, v143, v31, &v271, v272, 2, *((Shape **)v267 + 8), *((_DWORD *)v267 + 18), *((Shape **)v266 + 8), *((_DWORD *)v266 + 18));
          SweepTree::SwapWithRight((uint64_t)v267);
          Shape::TesteIntersection(v16, v267, 1, 0, v144, v145, v146, v147, v148);
          Shape::TesteIntersection(v16, v266, 0, 0, v149, v150, v151, v152, v153);
        }
        int v44 = v263;
        goto LABEL_162;
      }
      float v270 = *(float *)(v40 + 36);
    }
    else
    {
      uint64_t v43 = v35 + 48 * v30;
      float v41 = *(float *)(v43 + 36);
      float v270 = v41;
      int v37 = (float *)(v43 + 40);
    }
    int v44 = v30 + 1;
    float v45 = *v37;
    float v269 = *v37;
    uint64_t v46 = *(void *)(a2 + 24);
    if (*(_DWORD *)(v46 + 28 * v30 + 8) || *(_DWORD *)(v46 + 28 * v30 + 12))
    {
      int v263 = v30 + 1;
      int v47 = 0;
      uint64_t v48 = a2;
      goto LABEL_32;
    }
LABEL_162:
    int v30 = v44;
  }
  int v195 = Shape::AssemblePoints((Shape *)v16, v31, *(unsigned int *)(v16 + 16));
  signed int v197 = v195;
  if (v31 < v195)
  {
    float32x2_t v198 = (int *)(*(void *)(v16 + 88) + 48 * v31 + 32);
    uint64_t v199 = v195 - (uint64_t)v31;
    int v200 = v31;
    do
    {
      uint64_t v201 = *((void *)v198 - 1);
      if (v201)
      {
        uint64_t v202 = *(void *)(v201 + 64) + 56 * *v198;
        *(v198 - 4) = *(_DWORD *)(v202 + 8);
        *(_DWORD *)(v202 + 8) = v200;
      }
      ++v200;
      v198 += 12;
      --v199;
    }
    while (v199);
  }
  double v203 = v271;
  if (v271)
  {
    uint64_t v204 = *(void *)(v16 + 88);
    double v205 = v272;
    do
    {
      uint64_t v206 = *((void *)v203 + 8) + 56 * *v205;
      int v207 = *(_DWORD *)(v206 + 28);
      *(_DWORD *)(v206 + 24) = *(_DWORD *)(v204 + 48 * *(int *)(v206 + 24) + 4);
      *(_DWORD *)(v206 + 28) = *(_DWORD *)(v204 + 48 * v207 + 4);
      double v205 = (int *)(v206 + 40);
      double v203 = *(Shape **)(v206 + 32);
    }
    while (v203);
  }
  uint64_t v208 = *(unsigned int *)v256;
  if ((int)v208 >= 1)
  {
    uint64_t v209 = *(void *)(v16 + 88);
    double v210 = (int *)(*(void *)(v16 + 144) + 8);
    while (1)
    {
      int v211 = *(v210 - 2);
      int v212 = *(_DWORD *)(v209 + 48 * *(v210 - 1) + 4);
      *(v210 - 1) = v212;
      if (v211 == 1) {
        break;
      }
      if (!v211)
      {
        uint64_t v213 = v210[2];
        uint64_t v214 = *(void *)(*(void *)v210 + 40) + 32 * v213;
        uint64_t v215 = *(void *)(*(void *)v210 + 64);
        if (*(_DWORD *)(v214 + 8) >= *(_DWORD *)(v214 + 12)) {
          goto LABEL_179;
        }
LABEL_177:
        *(_DWORD *)(v215 + 56 * (int)v213 + 12) = v212;
      }
LABEL_180:
      v210 += 18;
      if (!--v208) {
        goto LABEL_181;
      }
    }
    uint64_t v213 = v210[2];
    uint64_t v216 = *(void *)(*(void *)v210 + 40) + 32 * v213;
    uint64_t v215 = *(void *)(*(void *)v210 + 64);
    if (*(_DWORD *)(v216 + 8) <= *(_DWORD *)(v216 + 12))
    {
LABEL_179:
      *(_DWORD *)(v215 + 56 * (int)v213 + 16) = v212;
      goto LABEL_180;
    }
    goto LABEL_177;
  }
LABEL_181:
  Shape::CheckAdjacencies(v16, v195, v31, v196);
  Shape::CheckEdges(v16, v197, v31, a2, 0, 0);
  *(_DWORD *)(v16 + 16) = v197;
  v272[0] = -1;
  v271 = 0;
  v217 = *(void **)(v16 + 144);
  if (v217) {
    free(v217);
  }
  void *v256 = 0;
  *((void *)v260 + 18) = 0;
  float v218 = *(void **)(v16 + 160);
  if (v218) {
    free(v218);
  }
  *((void *)v260 + 19) = 0;
  *((void *)v260 + 20) = 0;
  Shape::AssembleAretes((Shape *)v16);
  uint64_t v219 = *(unsigned int *)(v16 + 16);
  if ((int)v219 >= 1)
  {
    v220 = (_DWORD *)(*(void *)(v16 + 24) + 12);
    do
    {
      v220[3] = *v220 + *(v220 - 1);
      v220 += 7;
      --v219;
    }
    while (v219);
  }
  Shape::SetFlag((Shape *)v16, 2, 1);
  Shape::GetWindings((Shape *)v16, v221, v222, v223, 0);
  if (v254 == 2)
  {
    int v233 = *(_DWORD *)(v16 + 32);
    if (v253)
    {
      if (v233 < 1) {
        goto LABEL_266;
      }
      int v234 = 0;
      while (1)
      {
        uint64_t v235 = *(void *)(v16 + 72) + 32 * v234;
        int v236 = *(_DWORD *)(v235 + 20);
        if ((*(_DWORD *)(v235 + 16) & 0x80000000) != 0)
        {
          uint64_t v237 = *(void *)(v16 + 56);
          if ((v236 & 0x80000000) == 0) {
            goto LABEL_222;
          }
        }
        else
        {
          if (v236 < 0)
          {
            Shape::Inverse((Shape *)v16, v234);
            uint64_t v237 = *(void *)(v16 + 56);
LABEL_222:
            *(_DWORD *)(v237 + ((uint64_t)v234 << 6)) = 1;
            goto LABEL_223;
          }
          uint64_t v237 = *(void *)(v16 + 56);
        }
        *(_DWORD *)(v237 + ((uint64_t)v234 << 6)) = 0;
        Shape::SubEdge((Shape *)v16, v234--);
LABEL_223:
        if (++v234 >= *(_DWORD *)(v16 + 32)) {
          goto LABEL_266;
        }
      }
    }
    if (v233 < 1) {
      goto LABEL_266;
    }
    int v244 = 0;
    while (1)
    {
      uint64_t v245 = *(void *)(v16 + 72) + 32 * v244;
      int v246 = *(_DWORD *)(v245 + 20);
      if (*(int *)(v245 + 16) < 1)
      {
        if (v246 <= 0)
        {
          uint64_t v247 = *(void *)(v16 + 56);
LABEL_249:
          *(_DWORD *)(v247 + ((uint64_t)v244 << 6)) = 0;
          Shape::SubEdge((Shape *)v16, v244--);
          goto LABEL_250;
        }
        Shape::Inverse((Shape *)v16, v244);
        uint64_t v247 = *(void *)(v16 + 56);
      }
      else
      {
        uint64_t v247 = *(void *)(v16 + 56);
        if (v246 > 0) {
          goto LABEL_249;
        }
      }
      *(_DWORD *)(v247 + ((uint64_t)v244 << 6)) = 1;
LABEL_250:
      if (++v244 >= *(_DWORD *)(v16 + 32)) {
        goto LABEL_266;
      }
    }
  }
  if (v254 != 1)
  {
    if (!v254 && *(int *)(v16 + 32) >= 1)
    {
      int v224 = 0;
      while (1)
      {
        uint64_t v225 = *(void *)(v16 + 72) + 32 * v224;
        int v227 = *(_DWORD *)(v225 + 16);
        v226 = (int *)(v225 + 16);
        int v228 = v227 & 1;
        if (v227 >= 0) {
          int v229 = v228;
        }
        else {
          int v229 = -v228;
        }
        int *v226 = v229;
        v230 = v226 + 1;
        if (v226[1] >= 0) {
          int v231 = v226[1] & 1;
        }
        else {
          int v231 = -(v226[1] & 1);
        }
        int *v230 = v231;
        if (v229 < 0)
        {
          int *v226 = -v229;
          int v229 = 1;
          if ((v231 & 0x80000000) == 0)
          {
LABEL_201:
            if (v229) {
              goto LABEL_202;
            }
            goto LABEL_206;
          }
        }
        else if ((v231 & 0x80000000) == 0)
        {
          goto LABEL_201;
        }
        int *v230 = -v231;
        int v231 = 1;
        if (v229)
        {
LABEL_202:
          uint64_t v232 = *(void *)(v16 + 56);
          if (v231) {
            goto LABEL_210;
          }
          goto LABEL_208;
        }
LABEL_206:
        if (!v231)
        {
          uint64_t v232 = *(void *)(v16 + 56);
LABEL_210:
          *(_DWORD *)(v232 + ((uint64_t)v224 << 6)) = 0;
          Shape::SubEdge((Shape *)v16, v224--);
          goto LABEL_211;
        }
        Shape::Inverse((Shape *)v16, v224);
        uint64_t v232 = *(void *)(v16 + 56);
LABEL_208:
        *(_DWORD *)(v232 + ((uint64_t)v224 << 6)) = 1;
LABEL_211:
        if (++v224 >= *(_DWORD *)(v16 + 32)) {
          goto LABEL_266;
        }
      }
    }
    goto LABEL_266;
  }
  int v238 = *(_DWORD *)(v16 + 32);
  if ((v253 & 1) == 0)
  {
    if (v238 < 1) {
      goto LABEL_266;
    }
    int v248 = 0;
    while (1)
    {
      uint64_t v249 = *(void *)(v16 + 72) + 32 * v248;
      int v250 = *(_DWORD *)(v249 + 16);
      if (v250 >= 1) {
        break;
      }
      int v251 = *(_DWORD *)(v249 + 20);
      if (v250 < 0) {
        goto LABEL_256;
      }
      if (v251 >= 1 || v251 < 0)
      {
        Shape::Inverse((Shape *)v16, v248);
        uint64_t v252 = *(void *)(v16 + 56);
LABEL_261:
        *(_DWORD *)(v252 + ((uint64_t)v248 << 6)) = 1;
        goto LABEL_262;
      }
      uint64_t v252 = *(void *)(v16 + 56);
LABEL_257:
      *(_DWORD *)(v252 + ((uint64_t)v248 << 6)) = 0;
      Shape::SubEdge((Shape *)v16, v248--);
LABEL_262:
      if (++v248 >= *(_DWORD *)(v16 + 32)) {
        goto LABEL_266;
      }
    }
    int v251 = *(_DWORD *)(v249 + 20);
LABEL_256:
    uint64_t v252 = *(void *)(v16 + 56);
    if (!v251) {
      goto LABEL_261;
    }
    goto LABEL_257;
  }
  if (v238 >= 1)
  {
    int v239 = 0;
    while (1)
    {
      uint64_t v240 = *(void *)(v16 + 72) + 32 * v239;
      int v241 = *(_DWORD *)(v240 + 16);
      if (v241 < 0) {
        break;
      }
      int v242 = *(_DWORD *)(v240 + 20);
      if (v241) {
        goto LABEL_234;
      }
      if (v242 < 0 || v242)
      {
        Shape::Inverse((Shape *)v16, v239);
        uint64_t v243 = *(void *)(v16 + 56);
LABEL_236:
        *(_DWORD *)(v243 + ((uint64_t)v239 << 6)) = 1;
        goto LABEL_237;
      }
      uint64_t v243 = *(void *)(v16 + 56);
LABEL_235:
      *(_DWORD *)(v243 + ((uint64_t)v239 << 6)) = 0;
      Shape::SubEdge((Shape *)v16, v239--);
LABEL_237:
      if (++v239 >= *(_DWORD *)(v16 + 32)) {
        goto LABEL_266;
      }
    }
    int v242 = *(_DWORD *)(v240 + 20);
LABEL_234:
    uint64_t v243 = *(void *)(v16 + 56);
    if (!v242) {
      goto LABEL_236;
    }
    goto LABEL_235;
  }
LABEL_266:
  if (Shape::GetFlag((Shape *)v16, 64))
  {
    SweepTree::DestroyList(v262);
    SweepEvent::DestroyQueue(v265);
    Shape::SetFlag((Shape *)v16, 64, 0);
  }
  Shape::MakePointData((Shape *)v16, 0);
  Shape::MakeEdgeData((Shape *)v16, 0);
  Shape::MakeSweepSrcData((Shape *)v16, 0);
  Shape::MakeSweepDestData((Shape *)v16, 0);
  Shape::CleanupSweep((Shape *)a2);
  if (Shape::Eulerian((Shape *)v16, 1))
  {
    uint64_t result = 0;
    *(_DWORD *)(v16 + 48) = 1;
  }
  else
  {
    *(_DWORD *)(v16 + 32) = 0;
    *(_DWORD *)(v16 + 16) = 0;
    return 4;
  }
  return result;
}

uint64_t Shape::AssemblePoints(Shape *this, int a2, uint64_t a3)
{
  if ((int)a3 > a2)
  {
    uint64_t v4 = 0;
    uint64_t v5 = a2;
    uint64_t v6 = a2;
    uint64_t v7 = (int)a3;
    uint64_t v8 = (_DWORD *)(*((void *)this + 11) + 48 * a2);
    do
    {
      *uint64_t v8 = a2 + v4;
      v8 += 12;
      ++v4;
    }
    while ((int)a3 - (uint64_t)a2 != v4);
    Shape::SortPointsByOldInd(this, a2, a3 - 1);
    uint64_t v9 = 0;
    uint64_t v10 = *((void *)this + 11);
    uint64_t v11 = (int *)(v10 + 48 * (int)v6);
    uint64_t v12 = v7 - v6;
    do
    {
      int v13 = *v11;
      v11 += 12;
      *(_DWORD *)(v10 + 48 * v13 + 4) = v5 + v9++;
    }
    while (v12 != v9);
    uint64_t v14 = *((void *)this + 11);
    uint64_t v15 = (_DWORD *)(v14 + 48 * (int)v6 + 32);
    uint64_t v16 = 28 * v6;
    uint64_t v17 = v6;
    a3 = v5;
    while (1)
    {
      *(v15 - 6) = a3;
      if (v17 <= v6) {
        break;
      }
      uint64_t v18 = (float *)(*((void *)this + 3) + v16);
      if (*(v18 - 7) != *v18 || *(v18 - 6) != v18[1]) {
        break;
      }
      int v19 = *(v15 - 18);
      *(v15 - 6) = v19;
      uint64_t v20 = v14 + 48 * v19;
      uint64_t v22 = *(void *)(v20 + 24);
      int v21 = (void *)(v20 + 24);
      if (!v22)
      {
        *int v21 = *((void *)v15 - 1);
LABEL_14:
        *(_DWORD *)(v14 + 48 * v19 + 32) = *v15;
      }
LABEL_16:
      ++v17;
      v15 += 12;
      v16 += 28;
      if (v7 == v17)
      {
        uint64_t v25 = *((void *)this + 11);
        int8x16_t v26 = (int *)(v25 + 48 * (int)v6 + 4);
        do
        {
          *int8x16_t v26 = *(_DWORD *)(v25 + 48 * *v26 + 8);
          v26 += 12;
          --v12;
        }
        while (v12);
        return a3;
      }
    }
    if (v17 <= (int)a3)
    {
      a3 = (a3 + 1);
      goto LABEL_16;
    }
    int v19 = a3;
    uint64_t v23 = *((void *)this + 3);
    *(void *)(v23 + 28 * (int)a3) = *(void *)(v23 + v16);
    uint64_t v24 = v14 + 48 * (int)a3;
    *(void *)(v24 + 36) = *(void *)(v23 + v16);
    *(void *)(v24 + 24) = *((void *)v15 - 1);
    a3 = (a3 + 1);
    goto LABEL_14;
  }
  return a3;
}

uint64_t Shape::CheckAdjacencies(uint64_t this, int a2, int a3, Shape *a4)
{
  if (*(int *)(this + 136) >= 1)
  {
    int v4 = a2;
    uint64_t v5 = this;
    uint64_t v6 = 0;
    int v93 = 2 - a2;
    while (1)
    {
      uint64_t v7 = *(void *)(v5 + 144);
      uint64_t v8 = v7 + 72 * v6;
      int v9 = *(_DWORD *)(v8 + 4);
      uint64_t v10 = *(Shape **)(v8 + 8);
      if (v10)
      {
        int v11 = *(_DWORD *)(v7 + 72 * v6 + 16);
        uint64_t v12 = *((void *)v10 + 8) + 56 * v11;
        uint64_t v14 = *(int *)(v12 + 24);
        uint64_t v13 = *(int *)(v12 + 28);
        if ((int)v14 >= v9) {
          int v15 = *(_DWORD *)(v8 + 4);
        }
        else {
          int v15 = *(_DWORD *)(v12 + 24);
        }
        if ((int)v13 > v9) {
          int v9 = v13;
        }
        int v96 = v9;
        int v99 = v15;
        if ((int)v14 > a3)
        {
          int v16 = v14 - 1;
          uint64_t v17 = 28 * v14;
          do
          {
            this = Shape::TesteAdjacency((Shape *)v5, v10, v11, *(float *)(*(void *)(v5 + 24) + v17 - 28), *(float *)(*(void *)(v5 + 24) + v17 - 24), v16, 0);
            if (!this) {
              break;
            }
            --v14;
            *(_DWORD *)(*((void *)v10 + 8) + 56 * v11 + 24) = v16--;
            v17 -= 28;
          }
          while (v14 > a3);
        }
        uint64_t v18 = v13 + 1;
        if ((int)v13 + 1 < v4)
        {
          uint64_t v19 = 28 * v18;
          do
          {
            this = Shape::TesteAdjacency((Shape *)v5, v10, v11, *(float *)(*(void *)(v5 + 24) + v19), *(float *)(*(void *)(v5 + 24) + v19 + 4), v18, 0);
            if (!this) {
              break;
            }
            *(_DWORD *)(*((void *)v10 + 8) + 56 * v11 + 28) = v18;
            v19 += 28;
            LODWORD(v18) = v18 + 1;
          }
          while (v4 != v18);
        }
        int v9 = v96;
      }
      else
      {
        int v99 = *(_DWORD *)(v8 + 4);
      }
      uint64_t v20 = *(void *)(v5 + 144);
      int v21 = *(Shape **)(v20 + 72 * v6 + 24);
      if (v21)
      {
        int v22 = *(_DWORD *)(v20 + 72 * v6 + 32);
        uint64_t v23 = *((void *)v21 + 8) + 56 * v22;
        uint64_t v25 = *(int *)(v23 + 24);
        uint64_t v24 = *(int *)(v23 + 28);
        if ((int)v25 >= v99) {
          int v26 = v99;
        }
        else {
          int v26 = *(_DWORD *)(v23 + 24);
        }
        if ((int)v24 > v9) {
          int v9 = v24;
        }
        int v97 = v9;
        int v99 = v26;
        if ((int)v25 > a3)
        {
          int v27 = v25 - 1;
          uint64_t v28 = 28 * v25;
          do
          {
            this = Shape::TesteAdjacency((Shape *)v5, v21, v22, *(float *)(*(void *)(v5 + 24) + v28 - 28), *(float *)(*(void *)(v5 + 24) + v28 - 24), v27, 0);
            if (!this) {
              break;
            }
            --v25;
            *(_DWORD *)(*((void *)v21 + 8) + 56 * v22 + 24) = v27--;
            v28 -= 28;
          }
          while (v25 > a3);
        }
        uint64_t v29 = v24 + 1;
        if ((int)v24 + 1 < v4)
        {
          uint64_t v30 = 28 * v29;
          do
          {
            this = Shape::TesteAdjacency((Shape *)v5, v21, v22, *(float *)(*(void *)(v5 + 24) + v30), *(float *)(*(void *)(v5 + 24) + v30 + 4), v29, 0);
            if (!this) {
              break;
            }
            *(_DWORD *)(*((void *)v21 + 8) + 56 * v22 + 28) = v29;
            v30 += 28;
            LODWORD(v29) = v29 + 1;
          }
          while (v4 != v29);
        }
        int v9 = v97;
      }
      int v31 = v99;
      int v98 = v9;
      uint64_t v32 = *(void *)(v5 + 144);
      uint64_t v33 = *(Shape **)(v32 + 72 * v6 + 40);
      uint64_t v94 = v6;
      if (v33)
      {
        int v34 = *(_DWORD *)(v32 + 72 * v6 + 48);
        if (*(_DWORD *)(*((void *)v33 + 8) + 56 * v34 + 24) < a3)
        {
          while (v98 < v31)
          {
            char v35 = 0;
LABEL_49:
            int v31 = v99;
            if (v99 > a3)
            {
              this = Shape::TesteAdjacency((Shape *)v5, v33, v34, *(float *)(*(void *)(v5 + 24) + 28 * (v99 - 1)), *(float *)(*(void *)(v5 + 24) + 28 * (v99 - 1) + 4), v99 - 1, 0);
              if (this)
              {
                int v48 = v34;
                uint64_t v49 = 28 * v99;
                uint64_t v50 = v99;
                int v51 = v99 - 1;
                while (1)
                {
                  uint64_t v52 = v50 - 1;
                  uint64_t v53 = *((void *)v33 + 8);
                  uint64_t v54 = v53 + 56 * v34;
                  uint64_t v57 = *(int *)(v54 + 24);
                  uint64_t v55 = (int *)(v54 + 24);
                  uint64_t v56 = v57;
                  if ((int)v57 >= a3)
                  {
                    if (v50 <= v56) {
                      *uint64_t v55 = v51;
                    }
                    uint64_t v59 = v53 + 56 * v34;
                    uint64_t v60 = *(int *)(v59 + 28);
                    uint64_t v58 = (int *)(v59 + 28);
                    if (v52 <= v60) {
                      goto LABEL_58;
                    }
                  }
                  else
                  {
                    *uint64_t v55 = v51;
                    uint64_t v58 = (int *)(v53 + 56 * v34 + 28);
                  }
                  *uint64_t v58 = v51;
LABEL_58:
                  if (v52 <= a3) {
                    goto LABEL_63;
                  }
                  this = Shape::TesteAdjacency((Shape *)v5, v33, v34, *(float *)(*(void *)(v5 + 24) + v49 - 56), *(float *)(*(void *)(v5 + 24) + v49 - 52), --v51, 0);
                  v49 -= 28;
                  uint64_t v50 = v52;
                  if (!this) {
                    goto LABEL_62;
                  }
                }
              }
            }
            if ((v35 & 1) == 0) {
              goto LABEL_66;
            }
LABEL_62:
            uint64_t v53 = *((void *)v33 + 8);
            int v48 = v34;
LABEL_63:
            uint64_t v61 = *(uint64_t **)(v53 + 56 * v48);
            if (v61)
            {
              uint64_t v62 = *v61;
              if (v62)
              {
                uint64_t v33 = *(Shape **)(v62 + 64);
                int v34 = *(_DWORD *)(v62 + 72);
                if (*(_DWORD *)(*((void *)v33 + 8) + 56 * v34 + 24) < a3) {
                  continue;
                }
              }
            }
LABEL_66:
            uint64_t v32 = *(void *)(v5 + 144);
            int v4 = a2;
            goto LABEL_67;
          }
          char v35 = 0;
          uint64_t v36 = 28 * v98;
          int v37 = v98;
          uint64_t v38 = v98;
          while (1)
          {
            this = Shape::TesteAdjacency((Shape *)v5, v33, v34, *(float *)(*(void *)(v5 + 24) + v36), *(float *)(*(void *)(v5 + 24) + v36 + 4), v37, 0);
            if (this) {
              break;
            }
LABEL_47:
            --v37;
            v36 -= 28;
            if (v38-- <= v99) {
              goto LABEL_49;
            }
          }
          uint64_t v39 = *((void *)v33 + 8);
          uint64_t v40 = v39 + 56 * v34;
          uint64_t v43 = *(int *)(v40 + 24);
          float v41 = (int *)(v40 + 24);
          uint64_t v42 = v43;
          if ((int)v43 >= a3)
          {
            if (v38 < v42) {
              *float v41 = v37;
            }
            uint64_t v45 = v39 + 56 * v34;
            uint64_t v46 = *(int *)(v45 + 28);
            int v44 = (int *)(v45 + 28);
            if (v38 <= v46) {
              goto LABEL_46;
            }
          }
          else
          {
            *float v41 = v37;
            int v44 = (int *)(v39 + 56 * v34 + 28);
          }
          *int v44 = v37;
LABEL_46:
          char v35 = 1;
          goto LABEL_47;
        }
      }
LABEL_67:
      uint64_t v63 = *(Shape **)(v32 + 72 * v6 + 56);
      if (v63)
      {
        int v64 = *(_DWORD *)(v32 + 72 * v6 + 64);
        if (*(_DWORD *)(*((void *)v63 + 8) + 56 * v64 + 24) < a3) {
          break;
        }
      }
LABEL_99:
      uint64_t v6 = v94 + 1;
      if (v94 + 1 >= *(int *)(v5 + 136)) {
        return this;
      }
    }
    uint64_t v65 = v98 + 1;
    while (v99 > v98)
    {
      char v66 = 0;
LABEL_82:
      int v4 = a2;
      if ((int)v65 < a2)
      {
        signed int v78 = (float *)(*(void *)(v5 + 24) + 28 * (int)v65);
        this = Shape::TesteAdjacency((Shape *)v5, v63, v64, *v78, v78[1], v65, 0);
        if (this)
        {
          uint64_t v79 = 0;
          int v80 = v64;
          uint64_t v81 = 28 * v65;
          while (1)
          {
            int v82 = v98 + v79 + 1;
            uint64_t v83 = *((void *)v63 + 8);
            uint64_t v84 = v83 + 56 * v64;
            uint64_t v87 = *(int *)(v84 + 24);
            int v85 = (_DWORD *)(v84 + 24);
            uint64_t v86 = v87;
            if ((int)v87 >= a3)
            {
              if (v65 + v79 < v86) {
                *int v85 = v82;
              }
              uint64_t v89 = v83 + 56 * v64;
              int v90 = *(_DWORD *)(v89 + 28);
              long long v88 = (_DWORD *)(v89 + 28);
              if (v98 + (int)v79 < v90) {
                goto LABEL_91;
              }
            }
            else
            {
              *int v85 = v82;
              long long v88 = (_DWORD *)(v83 + 56 * v64 + 28);
            }
            *long long v88 = v82;
LABEL_91:
            if (!(v93 + v98 + v79)) {
              goto LABEL_96;
            }
            this = Shape::TesteAdjacency((Shape *)v5, v63, v64, *(float *)(*(void *)(v5 + 24) + v81 + 28), *(float *)(*(void *)(v5 + 24) + v81 + 32), v98 + v79++ + 2, 0);
            v81 += 28;
            if (!this) {
              goto LABEL_95;
            }
          }
        }
      }
      if ((v66 & 1) == 0) {
        goto LABEL_99;
      }
LABEL_95:
      uint64_t v83 = *((void *)v63 + 8);
      int v80 = v64;
LABEL_96:
      uint64_t v91 = *(void *)(v83 + 56 * v80);
      if (v91)
      {
        uint64_t v92 = *(void *)(v91 + 8);
        if (v92)
        {
          uint64_t v63 = *(Shape **)(v92 + 64);
          int v64 = *(_DWORD *)(v92 + 72);
          if (*(_DWORD *)(*((void *)v63 + 8) + 56 * v64 + 24) < a3) {
            continue;
          }
        }
      }
      goto LABEL_99;
    }
    char v66 = 0;
    uint64_t v68 = 28 * v99;
    uint64_t v67 = v99;
    int v69 = v99;
    while (1)
    {
      this = Shape::TesteAdjacency((Shape *)v5, v63, v64, *(float *)(*(void *)(v5 + 24) + v68), *(float *)(*(void *)(v5 + 24) + v68 + 4), v69, 0);
      if (this) {
        break;
      }
LABEL_81:
      ++v67;
      ++v69;
      v68 += 28;
      if (v65 == v69) {
        goto LABEL_82;
      }
    }
    uint64_t v70 = *((void *)v63 + 8);
    uint64_t v71 = v70 + 56 * v64;
    uint64_t v74 = *(int *)(v71 + 24);
    int v72 = (int *)(v71 + 24);
    uint64_t v73 = v74;
    if ((int)v74 >= a3)
    {
      if (v67 < v73) {
        *int v72 = v69;
      }
      uint64_t v76 = v70 + 56 * v64;
      uint64_t v77 = *(int *)(v76 + 28);
      uint64_t v75 = (int *)(v76 + 28);
      if (v67 <= v77) {
        goto LABEL_80;
      }
    }
    else
    {
      *int v72 = v69;
      uint64_t v75 = (int *)(v70 + 56 * v64 + 28);
    }
    *uint64_t v75 = v69;
LABEL_80:
    char v66 = 1;
    goto LABEL_81;
  }
  return this;
}

void Shape::CheckEdges(uint64_t a1, signed int a2, int a3, uint64_t a4, Shape *a5, uint64_t a6)
{
  uint64_t v6 = *(unsigned int *)(a1 + 136);
  if ((int)v6 >= 1)
  {
    int v7 = a6;
    uint64_t v12 = (int *)(*(void *)(a1 + 144) + 8);
    do
    {
      if (!*(v12 - 2)) {
        *(_DWORD *)(*(void *)(*(void *)v12 + 64) + 56 * v12[2] + 44) = *(v12 - 1);
      }
      v12 += 18;
      --v6;
    }
    while (v6);
    uint64_t v13 = 0;
    do
    {
      uint64_t v14 = *(void *)(a1 + 144);
      int v15 = *(Shape **)(v14 + 72 * v13 + 8);
      if (v15)
      {
        Shape::Avance(a1, a2, a3, v15, *(_DWORD *)(v14 + 72 * v13 + 16), a6, a5, v7);
        uint64_t v14 = *(void *)(a1 + 144);
      }
      int v16 = *(Shape **)(v14 + 72 * v13 + 24);
      if (v16)
      {
        Shape::Avance(a1, a2, a3, v16, *(_DWORD *)(v14 + 72 * v13 + 32), a6, a5, v7);
        uint64_t v14 = *(void *)(a1 + 144);
      }
      uint64_t v17 = *(Shape **)(v14 + 72 * v13 + 40);
      if (v17)
      {
        int v18 = *(_DWORD *)(v14 + 72 * v13 + 48);
        if (*(_DWORD *)(*((void *)v17 + 8) + 56 * v18 + 24) >= a3)
        {
          uint64_t v19 = v18;
          do
          {
            Shape::Avance(a1, a2, a3, v17, v18, a6, a5, v7);
            uint64_t v20 = *(uint64_t **)(*((void *)v17 + 8) + 56 * v19);
            if (!v20) {
              break;
            }
            uint64_t v21 = *v20;
            if (!v21) {
              break;
            }
            uint64_t v17 = *(Shape **)(v21 + 64);
            int v18 = *(_DWORD *)(v21 + 72);
            uint64_t v19 = v18;
          }
          while (*(_DWORD *)(*((void *)v17 + 8) + 56 * v18 + 24) >= a3);
          uint64_t v14 = *(void *)(a1 + 144);
        }
      }
      int v22 = *(Shape **)(v14 + 72 * v13 + 56);
      if (v22)
      {
        int v23 = *(_DWORD *)(v14 + 72 * v13 + 64);
        if (*(_DWORD *)(*((void *)v22 + 8) + 56 * v23 + 28) >= a3)
        {
          uint64_t v24 = v23;
          do
          {
            Shape::Avance(a1, a2, a3, v22, v23, a6, a5, v7);
            uint64_t v25 = *(void *)(*((void *)v22 + 8) + 56 * v24);
            if (!v25) {
              break;
            }
            uint64_t v26 = *(void *)(v25 + 8);
            if (!v26) {
              break;
            }
            int v22 = *(Shape **)(v26 + 64);
            int v23 = *(_DWORD *)(v26 + 72);
            uint64_t v24 = v23;
          }
          while (*(_DWORD *)(*((void *)v22 + 8) + 56 * v23 + 28) >= a3);
        }
      }
      ++v13;
    }
    while (v13 < *(int *)(a1 + 136));
  }
}

void *Shape::AddChgt(Shape *this, int a2, int a3, Shape **a4, int *a5, int a6, Shape *a7, int a8, Shape *a9, int a10)
{
  int v18 = *((_DWORD *)this + 34);
  if (v18 >= *((_DWORD *)this + 35))
  {
    uint64_t v20 = (2 * v18) | 1;
    *((_DWORD *)this + 35) = v20;
    uint64_t result = malloc_type_realloc(*((void **)this + 18), 72 * v20, 0x10200400F996F24uLL);
    *((void *)this + 18) = result;
    int v18 = *((_DWORD *)this + 34);
  }
  else
  {
    uint64_t result = (void *)*((void *)this + 18);
  }
  *((_DWORD *)this + 34) = v18 + 1;
  int v21 = v18;
  int v22 = (char *)&result[9 * v18];
  *(_DWORD *)int v22 = a6;
  *((_DWORD *)v22 + 1) = a2;
  *((void *)v22 + 1) = a7;
  *((_DWORD *)v22 + 4) = a8;
  *((void *)v22 + 3) = a9;
  *((_DWORD *)v22 + 8) = a10;
  if (a7)
  {
    uint64_t v23 = *((void *)a7 + 8);
    uint64_t v24 = *(uint64_t **)(v23 + 56 * a8);
    if (v24 && (uint64_t v25 = *v24) != 0)
    {
      result[9 * v21 + 5] = *(void *)(v25 + 64);
      int v26 = *(_DWORD *)(v25 + 72);
    }
    else
    {
      result[9 * v21 + 5] = 0;
      int v26 = -1;
    }
    LODWORD(result[9 * v21 + 6]) = v26;
    uint64_t v27 = v23 + 56 * a8;
    int v30 = *(_DWORD *)(v27 + 24);
    uint64_t v28 = (_DWORD *)(v27 + 24);
    int v29 = v30;
    if (v30 >= a3)
    {
      if (*(float *)(*((void *)this + 3) + 28 * v29) > *(float *)(*((void *)this + 3) + 28 * a2)) {
        *uint64_t v28 = a2;
      }
    }
    else
    {
      *uint64_t v28 = a2;
      uint64_t v31 = v23 + 56 * a8;
      *(void *)(v31 + 32) = *a4;
      *(_DWORD *)(v31 + 40) = *a5;
      *a5 = a8;
      *a4 = a7;
      uint64_t v23 = *((void *)a7 + 8);
    }
    uint64_t v32 = v23 + 56 * a8;
    int v35 = *(_DWORD *)(v32 + 28);
    uint64_t v33 = (_DWORD *)(v32 + 28);
    int v34 = v35;
    if (v35 < a3 || *(float *)(*((void *)this + 3) + 28 * v34) < *(float *)(*((void *)this + 3) + 28 * a2)) {
      *uint64_t v33 = a2;
    }
  }
  if (!a9)
  {
    uint64_t v40 = *(void *)(*((void *)a7 + 8) + 56 * a8);
    if (v40)
    {
      uint64_t v41 = *(void *)(v40 + 8);
      uint64_t v42 = *((void *)this + 18);
      if (v41)
      {
        uint64_t v43 = v42 + 72 * v21;
        *(void *)(v43 + 56) = *(void *)(v41 + 64);
        int v44 = *(_DWORD *)(v41 + 72);
LABEL_32:
        *(_DWORD *)(v43 + 64) = v44;
        return result;
      }
    }
    else
    {
      uint64_t v42 = *((void *)this + 18);
    }
    uint64_t v43 = v42 + 72 * v21;
    *(void *)(v43 + 56) = 0;
    int v44 = -1;
    goto LABEL_32;
  }
  uint64_t v36 = *((void *)a9 + 8);
  uint64_t v37 = *(void *)(*(void *)(v36 + 56 * a10) + 8);
  uint64_t v38 = *((void *)this + 18);
  if (v37)
  {
    *(void *)(v38 + 72 * v21 + 56) = *(void *)(v37 + 64);
    int v39 = *(_DWORD *)(v37 + 72);
  }
  else
  {
    *(void *)(v38 + 72 * v21 + 56) = 0;
    int v39 = -1;
  }
  *(_DWORD *)(v38 + 72 * v21 + 64) = v39;
  uint64_t v45 = v36 + 56 * a10;
  int v48 = *(_DWORD *)(v45 + 24);
  uint64_t v46 = (_DWORD *)(v45 + 24);
  int v47 = v48;
  if (v48 >= a3)
  {
    if (*(float *)(*((void *)this + 3) + 28 * v47) > *(float *)(*((void *)this + 3) + 28 * a2)) {
      *uint64_t v46 = a2;
    }
  }
  else
  {
    *uint64_t v46 = a2;
    uint64_t v49 = v36 + 56 * a10;
    *(void *)(v49 + 32) = *a4;
    *(_DWORD *)(v49 + 40) = *a5;
    *a5 = a10;
    *a4 = a9;
    uint64_t v36 = *((void *)a9 + 8);
  }
  uint64_t v50 = v36 + 56 * a10;
  int v53 = *(_DWORD *)(v50 + 28);
  int v51 = (_DWORD *)(v50 + 28);
  int v52 = v53;
  if (v53 < a3 || *(float *)(*((void *)this + 3) + 28 * v52) < *(float *)(*((void *)this + 3) + 28 * a2)) {
    *int v51 = a2;
  }
  return result;
}

uint64_t Shape::TesteIntersection(uint64_t this, SweepTree *a2, int a3, char a4, double a5, double a6, double a7, int32x4_t a8, int32x4_t a9)
{
  uint64_t v10 = this;
  if (a3)
  {
    uint64_t v11 = *(void *)a2;
    if (*(void *)a2)
    {
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      this = Shape::TesteIntersection(a5, a6, a7, a8, a9, this, v11, (uint64_t)a2, (float *)&v21 + 1, (float *)&v21, (float *)&v20 + 1, (float *)&v20, a4);
      if (this)
      {
        float v12 = *((float *)&v21 + 1);
        float v13 = *(float *)&v21;
        float v14 = *((float *)&v20 + 1);
        float v15 = *(float *)&v20;
        uint64_t v16 = v10 + 192;
        uint64_t v17 = (SweepTree *)v11;
        int v18 = a2;
        return SweepEvent::AddInQueue((uint64_t)v17, (uint64_t)v18, v16, v12, v13, v14, v15);
      }
    }
  }
  else
  {
    uint64_t v19 = *((void *)a2 + 1);
    if (v19)
    {
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      this = Shape::TesteIntersection(a5, a6, a7, a8, a9, this, (uint64_t)a2, v19, (float *)&v21 + 1, (float *)&v21, (float *)&v20 + 1, (float *)&v20, a4);
      if (this)
      {
        float v12 = *((float *)&v21 + 1);
        float v13 = *(float *)&v21;
        float v14 = *((float *)&v20 + 1);
        float v15 = *(float *)&v20;
        uint64_t v16 = v10 + 192;
        uint64_t v17 = a2;
        int v18 = (SweepTree *)v19;
        return SweepEvent::AddInQueue((uint64_t)v17, (uint64_t)v18, v16, v12, v13, v14, v15);
      }
    }
  }
  return this;
}

void Shape::AssembleAretes(Shape *this)
{
  if (*((int *)this + 4) >= 1)
  {
    for (uint64_t i = 0; i < *((int *)this + 4); ++i)
    {
      uint64_t v3 = *((void *)this + 3);
      int v4 = (_DWORD *)(v3 + 28 * i);
      uint64_t v5 = v4[4];
      if (v4[3] + v4[2] == 2)
      {
        int v6 = *(_DWORD *)(v3 + 28 * i + 20);
        uint64_t v7 = *((void *)this + 5);
        uint64_t v8 = v7 + 32 * (int)v5;
        int v9 = *(_DWORD *)(v8 + 8);
        uint64_t v10 = v7 + 32 * v6;
        int v11 = *(_DWORD *)(v10 + 8);
        if (v9 == v11)
        {
          int v12 = *(_DWORD *)(v8 + 12);
          int v13 = *(_DWORD *)(v10 + 12);
          if (v12 == v13) {
            goto LABEL_58;
          }
        }
        else
        {
          int v13 = *(_DWORD *)(v10 + 12);
        }
        if (v9 == v13 && *(_DWORD *)(v7 + 32 * (int)v5 + 12) == v9)
        {
          if (v9 == v11)
          {
LABEL_58:
            uint64_t v44 = *((void *)this + 7);
            uint64_t v45 = (uint64_t)(int)v5 << 6;
            int v46 = *(_DWORD *)(v44 + v45) + *(_DWORD *)(v44 + ((uint64_t)v6 << 6));
          }
          else
          {
            uint64_t v44 = *((void *)this + 7);
            uint64_t v45 = (uint64_t)(int)v5 << 6;
            int v46 = *(_DWORD *)(v44 + v45) - *(_DWORD *)(v44 + ((uint64_t)v6 << 6));
          }
          *(_DWORD *)(v44 + v45) = v46;
          *(_DWORD *)(v44 + ((uint64_t)v6 << 6)) = 0;
          uint64_t v47 = *((void *)this + 8);
          int v48 = *(_DWORD *)(v47 + 56 * v6 + 8);
          if ((v48 & 0x80000000) == 0)
          {
            uint64_t v49 = *((void *)this + 11);
            uint64_t v50 = *(unsigned int *)(v47 + 56 * v6 + 8);
            do
            {
              uint64_t v51 = v49 + 48 * v50;
              *(_DWORD *)(v51 + 32) = v5;
              uint64_t v50 = *(unsigned int *)(v51 + 16);
            }
            while ((v50 & 0x80000000) == 0);
            uint64_t v52 = v47 + 56 * (int)v5;
            unsigned int v55 = *(_DWORD *)(v52 + 8);
            int v53 = (_DWORD *)(v52 + 8);
            uint64_t v54 = v55;
            if ((v55 & 0x80000000) == 0)
            {
              do
              {
                uint64_t v56 = v49 + 48 * v54;
                unsigned int v57 = *(_DWORD *)(v56 + 16);
                int v53 = (_DWORD *)(v56 + 16);
                uint64_t v54 = v57;
              }
              while ((v57 & 0x80000000) == 0);
            }
            *int v53 = v48;
          }
          Shape::DisconnectStart((uint64_t)this, v6);
          Shape::DisconnectEnd((uint64_t)this, v6);
          int v58 = *((_DWORD *)this + 8);
          unsigned int v59 = v58 - 1;
          if (v58 > 1)
          {
            uint64_t v60 = *(unsigned int *)(*((void *)this + 8) + 56 * v59 + 8);
            if ((v60 & 0x80000000) == 0)
            {
              uint64_t v61 = *((void *)this + 11);
              do
              {
                uint64_t v62 = v61 + 48 * v60;
                *(_DWORD *)(v62 + 32) = v6;
                uint64_t v60 = *(unsigned int *)(v62 + 16);
              }
              while ((v60 & 0x80000000) == 0);
            }
          }
          Shape::SwapEdges(this, v6, v59);
          --*((_DWORD *)this + 8);
        }
      }
      else if ((v5 & 0x80000000) == 0)
      {
        int v14 = *((_DWORD *)this + 8);
        while (1)
        {
          if ((int)v5 >= v14) {
            goto LABEL_71;
          }
          uint64_t v15 = *((void *)this + 5);
          uint64_t v16 = v15 + 32 * v5;
          uint64_t v17 = *(unsigned int *)(v16 + 8);
          if (i == v17) {
            LODWORD(v17) = *(_DWORD *)(v16 + 12);
          }
          uint64_t v18 = *(unsigned int *)(*((void *)this + 3) + 28 * i + 16);
          if ((v18 & 0x80000000) == 0) {
            break;
          }
LABEL_48:
          uint64_t v42 = (_DWORD *)(v15 + 32 * (int)v5);
          if (i == v42[2])
          {
            uint64_t v43 = v42 + 4;
          }
          else
          {
            if (i != v42[3]) {
              goto LABEL_71;
            }
            uint64_t v43 = (unsigned int *)(v15 + 32 * (int)v5 + 24);
          }
          uint64_t v5 = *v43;
          if ((v5 & 0x80000000) != 0) {
            goto LABEL_71;
          }
        }
        while (2)
        {
          uint64_t v15 = *((void *)this + 5);
          if ((int)v18 >= v14) {
            goto LABEL_48;
          }
          uint64_t v19 = (unsigned int *)(v15 + 32 * v18);
          uint64_t v20 = v19[2];
          if (i == v20)
          {
            uint64_t v21 = v19[4];
            if (v18 != v5)
            {
              unsigned int v22 = *(_DWORD *)(v15 + 32 * v18 + 12);
              goto LABEL_22;
            }
          }
          else if (i == v19[3])
          {
            uint64_t v21 = *(unsigned int *)(v15 + 32 * v18 + 24);
            unsigned int v22 = v19[2];
            if (v18 != v5) {
              goto LABEL_22;
            }
          }
          else
          {
            if (v18 == v5)
            {
              LODWORD(v5) = v18;
LABEL_47:
              uint64_t v15 = *((void *)this + 5);
              goto LABEL_48;
            }
            uint64_t v21 = 0xFFFFFFFFLL;
            unsigned int v22 = v19[2];
LABEL_22:
            if (v22 == v17)
            {
              uint64_t v24 = *((void *)this + 7);
              uint64_t v23 = *((void *)this + 8);
              if (*(_DWORD *)(v15 + 32 * v5 + 8) == v20) {
                int v25 = *(_DWORD *)(v24 + ((unint64_t)v18 << 6));
              }
              else {
                int v25 = -*(_DWORD *)(v24 + ((unint64_t)v18 << 6));
              }
              *(_DWORD *)(v24 + ((unint64_t)v5 << 6)) += v25;
              *(_DWORD *)(v24 + ((unint64_t)v18 << 6)) = 0;
              int v26 = *(_DWORD *)(v23 + 56 * v18 + 8);
              if ((v26 & 0x80000000) == 0)
              {
                uint64_t v27 = *((void *)this + 11);
                uint64_t v28 = *(unsigned int *)(v23 + 56 * v18 + 8);
                do
                {
                  uint64_t v29 = v27 + 48 * v28;
                  *(_DWORD *)(v29 + 32) = v5;
                  uint64_t v28 = *(unsigned int *)(v29 + 16);
                }
                while ((v28 & 0x80000000) == 0);
                uint64_t v30 = v23 + 56 * v5;
                unsigned int v33 = *(_DWORD *)(v30 + 8);
                uint64_t v31 = (_DWORD *)(v30 + 8);
                uint64_t v32 = v33;
                if ((v33 & 0x80000000) == 0)
                {
                  do
                  {
                    uint64_t v34 = v27 + 48 * v32;
                    unsigned int v35 = *(_DWORD *)(v34 + 16);
                    uint64_t v31 = (_DWORD *)(v34 + 16);
                    uint64_t v32 = v35;
                  }
                  while ((v35 & 0x80000000) == 0);
                }
                *uint64_t v31 = v26;
              }
              Shape::DisconnectStart((uint64_t)this, v18);
              Shape::DisconnectEnd((uint64_t)this, v18);
              int v36 = *((_DWORD *)this + 8);
              unsigned int v37 = v36 - 1;
              if (v36 > 1)
              {
                uint64_t v38 = *(unsigned int *)(*((void *)this + 8) + 56 * v37 + 8);
                if ((v38 & 0x80000000) == 0)
                {
                  uint64_t v39 = *((void *)this + 11);
                  do
                  {
                    uint64_t v40 = v39 + 48 * v38;
                    *(_DWORD *)(v40 + 32) = v18;
                    uint64_t v38 = *(unsigned int *)(v40 + 16);
                  }
                  while ((v38 & 0x80000000) == 0);
                }
              }
              Shape::SwapEdges(this, v18, v37);
              int v14 = *((_DWORD *)this + 8) - 1;
              if (v5 == v14) {
                uint64_t v41 = v18;
              }
              else {
                uint64_t v41 = v5;
              }
              if (v21 == v14) {
                uint64_t v21 = v18;
              }
              else {
                uint64_t v21 = v21;
              }
              *((_DWORD *)this + 8) = v14;
              uint64_t v18 = v41;
            }
            else
            {
              uint64_t v18 = v5;
            }
          }
          uint64_t v5 = v18;
          uint64_t v18 = v21;
          if ((v21 & 0x80000000) != 0) {
            goto LABEL_47;
          }
          continue;
        }
      }
LABEL_71:
      ;
    }
  }
  int v63 = *((_DWORD *)this + 8);
  if (v63 >= 1)
  {
    uint64_t v64 = 0;
    for (uint64_t j = 0; j < v63; ++j)
    {
      if ((*(_DWORD *)(*((void *)this + 7) + v64) & 0x80000000) != 0)
      {
        Shape::Inverse(this, j);
        int v63 = *((_DWORD *)this + 8);
      }
      v64 += 64;
    }
  }
}

uint64_t Shape::Booleen(void **this, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t result = 5;
  if (!a3) {
    return result;
  }
  if (!a2) {
    return result;
  }
  uint64_t v7 = a3;
  if (a2 == a3) {
    return result;
  }
  Shape::Reset(this, 0);
  uint64_t result = 0;
  if (*(int *)(a2 + 16) < 2) {
    return result;
  }
  if (*(int *)(a2 + 32) < 2 || *(int *)(v7 + 16) < 2 || *(int *)(v7 + 32) < 2) {
    return 0;
  }
  if (*(_DWORD *)(a2 + 48) != 1 || *(_DWORD *)(v7 + 48) != 1) {
    return 5;
  }
  Shape::ResetSweep((Shape *)a2);
  Shape::ResetSweep((Shape *)v7);
  if (!Shape::GetFlag((Shape *)this, 64))
  {
    SweepTree::CreateList((uint64_t)(this + 21), *(_DWORD *)(v7 + 32) + *(_DWORD *)(a2 + 32));
    SweepEvent::CreateQueue((uint64_t)(this + 24), *(_DWORD *)(v7 + 32) + *(_DWORD *)(a2 + 32));
    Shape::SetFlag((Shape *)this, 64, 1);
  }
  Shape::MakePointData((Shape *)this, 1);
  Shape::MakeEdgeData((Shape *)this, 1);
  Shape::MakeSweepSrcData((Shape *)this, 1);
  Shape::MakeSweepDestData((Shape *)this, 1);
  unsigned int v293 = a4;
  BOOL v9 = (*(unsigned char *)(a2 + 53) & 2) != 0 && (*(unsigned char *)(v7 + 53) & 2) != 0;
  Shape::MakeBackData((Shape *)this, v9);
  v291 = (Shape *)a2;
  uint64_t v10 = *(unsigned int *)(a2 + 16);
  if ((int)v10 >= 1)
  {
    int v11 = (float *)(*((void *)v291 + 11) + 40);
    int v12 = (float *)(*((void *)v291 + 3) + 4);
    do
    {
      *((void *)v11 - 4) = 0xFFFFFFFF00000000;
      *(v11 - 6) = NAN;
      float v13 = ldexpf(*(v12 - 1), 5);
      *(v11 - 1) = ldexpf(roundf(v13), -5);
      float v14 = *v12;
      v12 += 7;
      float v15 = ldexpf(v14, 5);
      float *v11 = ldexpf(roundf(v15), -5);
      v11 += 12;
      --v10;
    }
    while (v10);
  }
  uint64_t v16 = *(unsigned int *)(v7 + 16);
  if ((int)v16 >= 1)
  {
    uint64_t v17 = (float *)(*(void *)(v7 + 88) + 40);
    uint64_t v18 = (float *)(*(void *)(v7 + 24) + 4);
    do
    {
      *((void *)v17 - 4) = 0xFFFFFFFF00000000;
      *(v17 - 6) = NAN;
      float v19 = ldexpf(*(v18 - 1), 5);
      *(v17 - 1) = ldexpf(roundf(v19), -5);
      float v20 = *v18;
      v18 += 7;
      float v21 = ldexpf(v20, 5);
      *uint64_t v17 = ldexpf(roundf(v21), -5);
      v17 += 12;
      --v16;
    }
    while (v16);
  }
  uint64_t v22 = (uint64_t)v291;
  uint64_t v23 = *((unsigned int *)v291 + 8);
  if ((int)v23 >= 1)
  {
    uint64_t v24 = 0;
    uint64_t v25 = *((void *)v291 + 11);
    uint64_t v26 = *((void *)v291 + 8);
    uint64_t v27 = 56 * v23;
    uint64_t v28 = (int *)(*((void *)v291 + 5) + 12);
    uint64_t v29 = *((void *)v291 + 7) + 32;
    do
    {
      float32x2_t v30 = vsub_f32(*(float32x2_t *)(v25 + 48 * *v28 + 36), *(float32x2_t *)(v25 + 48 * *(v28 - 1) + 36));
      *(float32x2_t *)(v29 - 28) = v30;
      double v31 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v30, v30).i32[1]), v30.f32[0], v30.f32[0]);
      double v32 = sqrt(v31);
      *(double *)(v29 - 16) = v31;
      *(double *)(v29 - 8) = v32;
      *(double *)uint64_t v29 = 1.0 / v31;
      *(double *)(v29 + 8) = 1.0 / v32;
      int8x16_t v33 = (int8x16_t)vmulq_n_f64(vcvtq_f64_f32(v30), 1.0 / v32);
      double v34 = *(double *)&v33.i64[1];
      float64x2_t v35 = (float64x2_t)vextq_s8(v33, v33, 8uLL);
      *(float64x2_t *)(v29 + 16) = v35;
      if (v34 < 0.0) {
        *(float64x2_t *)(v29 + 16) = vnegq_f64(v35);
      }
      uint64_t v36 = v26 + v24;
      *(void *)uint64_t v36 = 0;
      v28 += 8;
      *(_DWORD *)(v36 + 16) = -1;
      *(void *)(v36 + 8) = -1;
      *(void *)(v36 + 24) = -1;
      *(void *)(v36 + 32) = 0;
      *(void *)(v36 + 40) = -1;
      v24 += 56;
      v29 += 64;
      *(_DWORD *)(v36 + 48) = -1;
    }
    while (v27 != v24);
  }
  uint64_t v37 = *(unsigned int *)(v7 + 32);
  if ((int)v37 >= 1)
  {
    uint64_t v38 = 0;
    uint64_t v39 = *(void *)(v7 + 88);
    uint64_t v40 = *(void *)(v7 + 64);
    uint64_t v41 = 56 * v37;
    uint64_t v42 = (int *)(*(void *)(v7 + 40) + 12);
    uint64_t v43 = *(void *)(v7 + 56) + 32;
    do
    {
      float32x2_t v44 = vsub_f32(*(float32x2_t *)(v39 + 48 * *v42 + 36), *(float32x2_t *)(v39 + 48 * *(v42 - 1) + 36));
      *(float32x2_t *)(v43 - 28) = v44;
      double v45 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v44, v44).i32[1]), v44.f32[0], v44.f32[0]);
      double v46 = sqrt(v45);
      *(double *)(v43 - 16) = v45;
      *(double *)(v43 - 8) = v46;
      *(double *)uint64_t v43 = 1.0 / v45;
      *(double *)(v43 + 8) = 1.0 / v46;
      int8x16_t v47 = (int8x16_t)vmulq_n_f64(vcvtq_f64_f32(v44), 1.0 / v46);
      double v48 = *(double *)&v47.i64[1];
      float64x2_t v49 = (float64x2_t)vextq_s8(v47, v47, 8uLL);
      *(float64x2_t *)(v43 + 16) = v49;
      if (v48 < 0.0) {
        *(float64x2_t *)(v43 + 16) = vnegq_f64(v49);
      }
      uint64_t v50 = v40 + v38;
      *(void *)uint64_t v50 = 0;
      v42 += 8;
      *(_DWORD *)(v50 + 16) = -1;
      *(void *)(v50 + 8) = -1;
      *(void *)(v50 + 24) = -1;
      *(void *)(v50 + 32) = 0;
      *(void *)(v50 + 40) = -1;
      v38 += 56;
      v43 += 64;
      *(_DWORD *)(v50 + 48) = -1;
    }
    while (v41 != v38);
  }
  Shape::SortPointsRounded(v291);
  Shape::SortPointsRounded((Shape *)v7);
  uint64_t v51 = 0;
  uint64_t v52 = 0;
  int v53 = 0;
  this[17] = 0;
  v292 = this + 17;
  this[18] = 0;
  float v54 = *(float *)(*((void *)v291 + 11) + 40);
  if (v54 >= *(float *)(*(void *)(v7 + 88) + 40)) {
    float v54 = *(float *)(*(void *)(v7 + 88) + 40);
  }
  float v55 = v54 + -1.0;
  v309[0] = -1;
  this[19] = 0;
  v302 = (int *)(this + 24);
  v308 = 0;
  v296 = (Shape *)v7;
  v297 = (int *)(this + 21);
  v290 = this + 19;
  this[20] = 0;
  v295 = (Shape *)this;
  while ((int)v52 < *(_DWORD *)(v22 + 16) || (int)v51 < *(_DWORD *)(v7 + 16) || *v302 >= 1)
  {
    uint64_t v307 = 0;
    int v306 = 0;
    int v305 = 0;
    v303 = 0;
    v304 = 0;
    BOOL v56 = SweepEvent::PeekInQueue(&v304, &v303, (_DWORD *)&v307 + 1, &v307, &v306, &v305, (uint64_t)v302);
    int v57 = *(_DWORD *)(v22 + 16);
    if (!v56)
    {
      if ((int)v52 < v57
        && ((int)v51 >= *(_DWORD *)(v7 + 16)
         || (uint64_t v74 = *(void *)(v22 + 88),
             float v75 = *(float *)(v74 + 48 * (int)v52 + 40),
             uint64_t v76 = *(void *)(v7 + 88),
             float v77 = *(float *)(v76 + 48 * (int)v51 + 40),
             v75 < v77)
         || v75 == v77 && *(float *)(v74 + 48 * (int)v52 + 36) < *(float *)(v76 + 48 * (int)v51 + 36)))
      {
        uint64_t v72 = v51;
        LODWORD(v51) = v52;
        uint64_t v78 = v22;
        uint64_t v7 = v22;
        uint64_t v52 = (v52 + 1);
      }
      else
      {
        uint64_t v78 = v22;
        uint64_t v72 = (v51 + 1);
      }
      int v59 = v51;
      uint64_t v79 = *(void *)(v7 + 88) + 48 * (int)v51;
      HIDWORD(v307) = *(_DWORD *)(v79 + 36);
      int v80 = *(_DWORD *)(v79 + 40);
LABEL_64:
      LODWORD(v307) = v80;
      goto LABEL_65;
    }
    if ((int)v52 >= v57)
    {
      uint64_t v83 = *(void *)(v7 + 88);
      if (*(int *)(v83 + 48 * (int)v51 + 8) > 0
        || (int v59 = v51,
            uint64_t v84 = v83 + 48 * (int)v51,
            float v86 = *(float *)(v84 + 40),
            int v85 = (int *)(v84 + 40),
            float v87 = v86,
            v86 > *(float *)&v307)
        || ((float v88 = *(float *)(v83 + 48 * (int)v51 + 36), v87 == *(float *)&v307)
          ? (BOOL v89 = v88 <= *((float *)&v307 + 1))
          : (BOOL v89 = 1),
            !v89))
      {
LABEL_94:
        uint64_t v78 = v22;
        uint64_t v298 = v51;
        uint64_t v299 = v52;
        SweepEvent::ExtractFromQueue(&v304, &v303, (_DWORD *)&v307 + 1, &v307, &v306, &v305, (uint64_t)v302);
        uint64_t v7 = 0;
        LODWORD(v51) = -1;
        int v82 = 1;
        goto LABEL_95;
      }
      uint64_t v78 = v22;
      uint64_t v72 = (v51 + 1);
      *((float *)&v307 + 1) = v88;
      int v80 = *v85;
      goto LABEL_64;
    }
    uint64_t v58 = *(void *)(v22 + 88);
    int v59 = v52;
    if ((int)v51 >= *(_DWORD *)(v7 + 16))
    {
      if (*(int *)(v58 + 48 * (int)v52 + 8) > 0) {
        goto LABEL_94;
      }
      uint64_t v90 = v58 + 48 * (int)v52;
      float v91 = *(float *)(v90 + 40);
      uint64_t v61 = (_DWORD *)(v90 + 40);
      float v92 = v91;
      if (v91 > *(float *)&v307) {
        goto LABEL_94;
      }
      float v93 = *(float *)(v58 + 48 * (int)v52 + 36);
      if (v92 == *(float *)&v307 && v93 > *((float *)&v307 + 1)) {
        goto LABEL_94;
      }
      uint64_t v72 = v51;
      LODWORD(v51) = v52;
      uint64_t v73 = (v52 + 1);
      *((float *)&v307 + 1) = v93;
      goto LABEL_84;
    }
    uint64_t v60 = v58 + 48 * (int)v52;
    float v62 = *(float *)(v60 + 40);
    uint64_t v61 = (_DWORD *)(v60 + 40);
    float v63 = v62;
    uint64_t v64 = *(void *)(v7 + 88);
    uint64_t v65 = v64 + 48 * (int)v51;
    float v67 = *(float *)(v65 + 40);
    char v66 = (_DWORD *)(v65 + 40);
    float v68 = v67;
    BOOL v69 = v63 == v67;
    if (v63 < v67 || v69 && *(float *)(v58 + 48 * (int)v52 + 36) < *(float *)(v64 + 48 * (int)v51 + 36))
    {
      if (*(int *)(v58 + 48 * (int)v52 + 8) > 0 || v63 > *(float *)&v307) {
        goto LABEL_94;
      }
      float v70 = *(float *)(v58 + 48 * (int)v52 + 36);
      if (v63 == *(float *)&v307 && v70 > *((float *)&v307 + 1)) {
        goto LABEL_94;
      }
      uint64_t v72 = v51;
      LODWORD(v51) = v52;
      uint64_t v73 = (v52 + 1);
      *((float *)&v307 + 1) = v70;
LABEL_84:
      LODWORD(v307) = *v61;
      uint64_t v78 = v22;
      uint64_t v7 = v22;
      uint64_t v52 = v73;
      goto LABEL_65;
    }
    if (*(int *)(v64 + 48 * (int)v51 + 8) > 0 || v68 > *(float *)&v307) {
      goto LABEL_94;
    }
    uint64_t v95 = v64 + 48 * (int)v51;
    if (v68 == *(float *)&v307 && *(float *)(v95 + 36) > *((float *)&v307 + 1)) {
      goto LABEL_94;
    }
    uint64_t v78 = v22;
    uint64_t v72 = (v51 + 1);
    HIDWORD(v307) = *(_DWORD *)(v95 + 36);
    LODWORD(v307) = *v66;
    int v59 = v51;
LABEL_65:
    uint64_t v81 = *(void *)(v7 + 24);
    if (!*(_DWORD *)(v81 + 28 * v59 + 8) && !*(_DWORD *)(v81 + 28 * v59 + 12))
    {
      uint64_t v51 = v72;
      goto LABEL_189;
    }
    uint64_t v299 = v52;
    int v82 = 0;
    uint64_t v298 = v72;
LABEL_95:
    float v97 = ldexpf(*((float *)&v307 + 1), 5);
    float v98 = ldexpf(roundf(v97), -5);
    float v99 = ldexpf(*(float *)&v307, 5);
    float v100 = ldexpf(roundf(v99), -5);
    uint64_t v101 = Shape::AddPoint((Shape *)this, v98, v100);
    signed int v102 = v101;
    uint64_t v103 = (uint64_t)this[11] + 48 * (int)v101;
    *(float *)(v103 + 36) = v98;
    *(float *)(v103 + 40) = v100;
    if (v100 <= v55)
    {
      int v126 = v101;
    }
    else
    {
      int v104 = Shape::AssemblePoints((Shape *)this, v53, v101);
      signed int v106 = v104;
      if (v53 < v104)
      {
        uint64_t v107 = (int *)((char *)this[11] + 48 * v53 + 32);
        uint64_t v108 = v104 - (uint64_t)v53;
        int v109 = v53;
        do
        {
          uint64_t v110 = *((void *)v107 - 1);
          if (v110)
          {
            uint64_t v111 = *(void *)(v110 + 64) + 56 * *v107;
            *(v107 - 4) = *(_DWORD *)(v111 + 8);
            *(_DWORD *)(v111 + 8) = v109;
          }
          ++v109;
          v107 += 12;
          --v108;
        }
        while (v108);
      }
      float v112 = v308;
      if (v308)
      {
        uint64_t v113 = this[11];
        int v114 = v309;
        do
        {
          uint64_t v115 = *((void *)v112 + 8) + 56 * *v114;
          int v116 = *(_DWORD *)(v115 + 28);
          *(_DWORD *)(v115 + 24) = v113[12 * *(int *)(v115 + 24) + 1];
          *(_DWORD *)(v115 + 28) = v113[12 * v116 + 1];
          int v114 = (int *)(v115 + 40);
          float v112 = *(Shape **)(v115 + 32);
        }
        while (v112);
      }
      uint64_t v117 = *(unsigned int *)v292;
      if ((int)v117 >= 1)
      {
        uint64_t v118 = this[11];
        double v119 = (int *)((char *)this[18] + 8);
        while (1)
        {
          int v120 = *(v119 - 2);
          int v121 = v118[12 * *(v119 - 1) + 1];
          *(v119 - 1) = v121;
          if (v120 == 1) {
            break;
          }
          if (!v120)
          {
            uint64_t v122 = v119[2];
            uint64_t v123 = *(void *)(*(void *)v119 + 40) + 32 * v122;
            uint64_t v124 = *(void *)(*(void *)v119 + 64);
            if (*(_DWORD *)(v123 + 8) >= *(_DWORD *)(v123 + 12)) {
              goto LABEL_111;
            }
LABEL_109:
            *(_DWORD *)(v124 + 56 * (int)v122 + 12) = v121;
          }
LABEL_112:
          v119 += 18;
          if (!--v117) {
            goto LABEL_113;
          }
        }
        uint64_t v122 = v119[2];
        uint64_t v125 = *(void *)(*(void *)v119 + 40) + 32 * v122;
        uint64_t v124 = *(void *)(*(void *)v119 + 64);
        if (*(_DWORD *)(v125 + 8) <= *(_DWORD *)(v125 + 12))
        {
LABEL_111:
          *(_DWORD *)(v124 + 56 * (int)v122 + 16) = v121;
          goto LABEL_112;
        }
        goto LABEL_109;
      }
LABEL_113:
      Shape::CheckAdjacencies((uint64_t)this, v104, v53, v105);
      Shape::CheckEdges((uint64_t)this, v106, v53, v78, v296, v293);
      int v126 = v106;
      if (v106 < v102)
      {
        long long v127 = (char *)this[3];
        long long v128 = &v127[28 * v102];
        uint64_t v129 = &v127[28 * v106];
        long long v130 = *(_OWORD *)v128;
        *(_OWORD *)(v129 + 12) = *(_OWORD *)(v128 + 12);
        *(_OWORD *)uint64_t v129 = v130;
        char v131 = (char *)this[11];
        int v132 = &v131[48 * v102];
        double v133 = &v131[48 * v106];
        long long v134 = *(_OWORD *)v132;
        long long v135 = *((_OWORD *)v132 + 2);
        *((_OWORD *)v133 + 1) = *((_OWORD *)v132 + 1);
        *((_OWORD *)v133 + 2) = v135;
        *(_OWORD *)double v133 = v134;
      }
      *((_DWORD *)this + 4) = v106 + 1;
      *((_DWORD *)this + 34) = 0;
      v309[0] = -1;
      v308 = 0;
      int v53 = v106;
      float v55 = v100;
    }
    if (v82)
    {
      int v136 = v126;
      SweepTree::RemoveEvent((uint64_t)v304, v302, 1);
      SweepTree::RemoveEvent((uint64_t)v303, v302, 0);
      Shape::AddChgt((Shape *)this, v136, v53, &v308, v309, 2, *((Shape **)v304 + 8), *((_DWORD *)v304 + 18), *((Shape **)v303 + 8), *((_DWORD *)v303 + 18));
      SweepTree::SwapWithRight((uint64_t)v304);
      Shape::TesteIntersection((uint64_t)this, v304, 1, 1, v137, v138, v139, v140, v141);
      Shape::TesteIntersection((uint64_t)this, v303, 0, 1, v142, v143, v144, v145, v146);
    }
    else
    {
      unsigned int v147 = *(_DWORD *)(*(void *)(v7 + 24) + 28 * (int)v51 + 16);
      if ((v147 & 0x80000000) == 0)
      {
        unsigned int v148 = 0;
        int v149 = 0;
        unsigned int v150 = -1;
        unsigned int v151 = -1;
        unsigned int v152 = *(_DWORD *)(*(void *)(v7 + 24) + 28 * (int)v51 + 16);
        do
        {
          if ((signed int)v152 >= *(_DWORD *)(v7 + 32)) {
            break;
          }
          uint64_t v153 = *(void *)(v7 + 40);
          uint64_t v154 = v153 + 32 * v152;
          int v156 = *(_DWORD *)(v154 + 8);
          int v155 = *(_DWORD *)(v154 + 12);
          BOOL v157 = v156 < v155 && v51 == v155;
          if (v157 || (v51 == v156 ? (BOOL v158 = v156 <= v155) : (BOOL v158 = 1), !v158))
          {
            ++v149;
            unsigned int v151 = v152;
          }
          BOOL v159 = v51 == v156;
          BOOL v160 = v156 > v155;
          if (v156 >= v155) {
            BOOL v159 = 0;
          }
          if (v51 != v155) {
            BOOL v160 = 0;
          }
          int v161 = v160 || v159;
          if (v161) {
            unsigned int v150 = v152;
          }
          v148 += v161;
          if (v51 == v156)
          {
            uint64_t v162 = (unsigned int *)(v153 + 32 * v152 + 16);
          }
          else
          {
            if (v51 != v155) {
              break;
            }
            uint64_t v162 = (unsigned int *)(v153 + 32 * v152 + 24);
          }
          unsigned int v152 = *v162;
        }
        while ((v152 & 0x80000000) == 0);
        unsigned int v163 = -1;
        int v301 = v53;
        if (v148 && (v151 & 0x80000000) == 0)
        {
          if (*(void *)(*(void *)(v7 + 64) + 56 * v151)) {
            unsigned int v163 = v151;
          }
          else {
            unsigned int v163 = -1;
          }
        }
        int v300 = v126;
        if (v149 >= 1)
        {
          while ((signed int)v147 < *(_DWORD *)(v7 + 32))
          {
            uint64_t v164 = v147;
            uint64_t v165 = *(void *)(v7 + 40) + 32 * v147;
            int v166 = *(_DWORD *)(v165 + 8);
            int v167 = *(_DWORD *)(v165 + 12);
            if (v166 < v167 && v51 == v167)
            {
              if (v147 != v163)
              {
LABEL_163:
                uint64_t v171 = *(uint64_t **)(*(void *)(v7 + 64) + 56 * v147);
                if (v171)
                {
                  int v172 = -1;
                  Shape::AddChgt(v295, v126, v301, &v308, v309, 1, (Shape *)v171[8], *((_DWORD *)v171 + 18), 0, -1);
                  *(void *)(*(void *)(v7 + 64) + 56 * v164) = 0;
                  uint64_t v173 = *v171;
                  if (*v171)
                  {
                    int v172 = *(_DWORD *)(v173 + 72);
                    uint64_t v174 = *(void *)(v173 + 64);
                  }
                  else
                  {
                    uint64_t v174 = 0;
                  }
                  uint64_t v175 = v171[1];
                  if (v175)
                  {
                    int v294 = *(_DWORD *)(v175 + 72);
                    uint64_t v176 = *(void *)(v175 + 64);
                  }
                  else
                  {
                    uint64_t v176 = 0;
                    int v294 = -1;
                  }
                  SweepTree::Remove((AVLTree *)v171, (uint64_t)v297, v302, 1);
                  int v126 = v300;
                  if (v174)
                  {
                    if (v176)
                    {
                      if (v174 != v7
                        || (uint64_t v182 = *(void *)(v7 + 40) + 32 * v172, *(_DWORD *)(v182 + 12) != v51)
                        && *(_DWORD *)(v182 + 8) != v51)
                      {
                        if (v176 != v7
                          || (uint64_t v183 = *(void *)(v7 + 40) + 32 * v294, *(_DWORD *)(v183 + 12) != v51)
                          && *(_DWORD *)(v183 + 8) != v51)
                        {
                          Shape::TesteIntersection((uint64_t)v295, *(SweepTree **)(*(void *)(v174 + 64) + 56 * v172), 0, 1, v177, v178, v179, v180, v181);
                          int v126 = v300;
                        }
                      }
                    }
                  }
                }
              }
            }
            else if (v51 == v166 && v166 > v167 && v147 != v163)
            {
              goto LABEL_163;
            }
            uint64_t v184 = *(void *)(v7 + 40);
            uint64_t v185 = (_DWORD *)(v184 + 32 * v164);
            if (v185[2] == v51)
            {
              int v186 = v185 + 4;
            }
            else
            {
              if (v185[3] != v51) {
                break;
              }
              int v186 = (unsigned int *)(v184 + 32 * v164 + 24);
            }
            unsigned int v147 = *v186;
            if ((v147 & 0x80000000) != 0) {
              break;
            }
            continue;
          }
        }
        this = (void **)v295;
        int v53 = v301;
        if ((v150 & 0x80000000) != 0)
        {
          uint64_t v188 = 0;
          char v189 = 1;
        }
        else if ((v163 & 0x80000000) != 0)
        {
          int v201 = v126;
          uint64_t v188 = SweepTree::AddInList(v7, v150, 1, v126, v297);
          *(void *)(*(void *)(v7 + 64) + 56 * v150) = v188;
          SweepTree::Insert((SweepTree *)v188, (uint64_t)v297, v302, (uint64_t)v295, v201, 1, 1);
          uint64_t v207 = *(void *)v188;
          if (*(void *)v188)
          {
            uint64_t v208 = *((void *)v295 + 11) + 48 * v201;
            *(void *)(v208 + 24) = *(void *)(v207 + 64);
            *(_DWORD *)(v208 + 32) = *(_DWORD *)(v207 + 72);
          }
          else
          {
            *(_DWORD *)(*((void *)v295 + 11) + 48 * v201 + 32) = -1;
          }
          Shape::TesteIntersection((uint64_t)v295, (SweepTree *)v188, 0, 1, v202, v203, v204, v205, v206);
          Shape::TesteIntersection((uint64_t)v295, (SweepTree *)v188, 1, 1, v209, v210, v211, v212, v213);
          *(_DWORD *)(*(void *)(v7 + 64) + 56 * v150 + 44) = v201;
          Shape::AddChgt(v295, v201, v301, &v308, v309, 0, *(Shape **)(v188 + 64), *(_DWORD *)(v188 + 72), 0, -1);
          char v189 = 0;
        }
        else
        {
          uint64_t v187 = 56 * v163;
          uint64_t v188 = *(void *)(*(void *)(v7 + 64) + v187);
          char v189 = 1;
          int v190 = v126;
          Shape::AddChgt(v295, v126, v301, &v308, v309, 1, *(Shape **)(v188 + 64), *(_DWORD *)(v188 + 72), 0, -1);
          *(void *)(*(void *)(v7 + 64) + v187) = 0;
          SweepTree::RemoveEvents(v188, v302);
          SweepTree::ConvertTo(v188, (Shape *)v7, v150, 1, v190);
          *(void *)(*(void *)(v7 + 64) + 56 * v150) = v188;
          Shape::TesteIntersection((uint64_t)v295, (SweepTree *)v188, 0, 1, v191, v192, v193, v194, v195);
          Shape::TesteIntersection((uint64_t)v295, (SweepTree *)v188, 1, 1, v196, v197, v198, v199, v200);
          int v53 = v301;
          *(_DWORD *)(*(void *)(v7 + 64) + 56 * v150 + 44) = v190;
          Shape::AddChgt(v295, v190, v301, &v308, v309, 0, *(Shape **)(v188 + 64), *(_DWORD *)(v188 + 72), 0, -1);
        }
        if (v148 < 2 || (unsigned int v214 = *(_DWORD *)(*(void *)(v7 + 24) + 28 * (int)v51 + 16), (v214 & 0x80000000) != 0))
        {
LABEL_225:
          uint64_t v7 = (uint64_t)v296;
          uint64_t v22 = (uint64_t)v291;
          uint64_t v51 = v298;
          uint64_t v52 = v299;
          continue;
        }
        int v215 = v300;
LABEL_198:
        if ((signed int)v214 >= *(_DWORD *)(v7 + 32))
        {
LABEL_224:
          uint64_t v7 = (uint64_t)v296;
          uint64_t v22 = (uint64_t)v291;
          uint64_t v51 = v298;
          uint64_t v52 = v299;
          continue;
        }
        uint64_t v216 = *(void *)(v7 + 40);
        uint64_t v217 = v214;
        uint64_t v218 = v216 + 32 * v214;
        int v219 = *(_DWORD *)(v218 + 8);
        int v220 = *(_DWORD *)(v218 + 12);
        if (v219 > v220 && v51 == v220)
        {
          if (v214 != v150) {
            goto LABEL_213;
          }
        }
        else if (v51 == v219 && v219 < v220 && v214 != v150)
        {
LABEL_213:
          uint64_t v224 = SweepTree::AddInList(v7, v214, 1, v215, v297);
          *(void *)(*(void *)(v7 + 64) + 56 * v217) = v224;
          SweepTree::InsertAt((AVLTree *)v224, (uint64_t)v297, v302, (int)v295, (AVLTree **)v188, v51, 1, 1);
          if (v189)
          {
            uint64_t v230 = *(void *)v224;
            uint64_t v231 = *((void *)v295 + 11);
            if (*(void *)v224)
            {
              int v232 = v300;
              *(void *)(v231 + 48 * v300 + 24) = *(void *)(v230 + 64);
              int v233 = *(_DWORD *)(v230 + 72);
            }
            else
            {
              int v233 = -1;
              int v232 = v300;
            }
            *(_DWORD *)(v231 + 48 * v232 + 32) = v233;
          }
          Shape::TesteIntersection((uint64_t)v295, (SweepTree *)v224, 0, 1, v225, v226, v227, v228, v229);
          Shape::TesteIntersection((uint64_t)v295, (SweepTree *)v224, 1, 1, v234, v235, v236, v237, v238);
          *(_DWORD *)(*(void *)(v7 + 64) + 56 * v217 + 44) = v300;
          int v53 = v301;
          Shape::AddChgt(v295, v300, v301, &v308, v309, 0, *(Shape **)(v224 + 64), *(_DWORD *)(v224 + 72), 0, -1);
          int v215 = v300;
          char v189 = 0;
          uint64_t v216 = *(void *)(v7 + 40);
          int v219 = *(_DWORD *)(v216 + 32 * v217 + 8);
LABEL_219:
          int v239 = (_DWORD *)(v216 + 32 * v217);
          if (v219 == v51)
          {
            uint64_t v240 = v239 + 4;
          }
          else
          {
            if (v239[3] != v51) {
              goto LABEL_225;
            }
            uint64_t v240 = v239 + 6;
          }
          unsigned int v214 = *v240;
          if ((*v240 & 0x80000000) != 0) {
            goto LABEL_224;
          }
          goto LABEL_198;
        }
        int v53 = v301;
        goto LABEL_219;
      }
    }
    uint64_t v51 = v298;
    uint64_t v52 = v299;
LABEL_189:
    uint64_t v22 = v78;
    uint64_t v7 = (uint64_t)v296;
  }
  int v241 = Shape::AssemblePoints((Shape *)this, v53, *((unsigned int *)this + 4));
  signed int v243 = v241;
  if (v53 < v241)
  {
    int v244 = (int *)((char *)this[11] + 48 * v53 + 32);
    uint64_t v245 = v241 - (uint64_t)v53;
    int v246 = v53;
    do
    {
      uint64_t v247 = *((void *)v244 - 1);
      if (v247)
      {
        uint64_t v248 = *(void *)(v247 + 64) + 56 * *v244;
        *(v244 - 4) = *(_DWORD *)(v248 + 8);
        *(_DWORD *)(v248 + 8) = v246;
      }
      ++v246;
      v244 += 12;
      --v245;
    }
    while (v245);
  }
  uint64_t v249 = v308;
  if (v308)
  {
    int v250 = this[11];
    int v251 = v309;
    do
    {
      uint64_t v252 = *((void *)v249 + 8) + 56 * *v251;
      int v253 = *(_DWORD *)(v252 + 28);
      *(_DWORD *)(v252 + 24) = v250[12 * *(int *)(v252 + 24) + 1];
      *(_DWORD *)(v252 + 28) = v250[12 * v253 + 1];
      int v251 = (int *)(v252 + 40);
      uint64_t v249 = *(Shape **)(v252 + 32);
    }
    while (v249);
  }
  uint64_t v254 = *(unsigned int *)v292;
  if ((int)v254 >= 1)
  {
    uint64_t v255 = this[11];
    v256 = (int *)((char *)this[18] + 8);
    while (1)
    {
      int v257 = *(v256 - 2);
      int v258 = v255[12 * *(v256 - 1) + 1];
      *(v256 - 1) = v258;
      if (v257 == 1) {
        break;
      }
      if (!v257)
      {
        uint64_t v259 = v256[2];
        uint64_t v260 = *(void *)(*(void *)v256 + 40) + 32 * v259;
        uint64_t v261 = *(void *)(*(void *)v256 + 64);
        if (*(_DWORD *)(v260 + 8) >= *(_DWORD *)(v260 + 12)) {
          goto LABEL_241;
        }
LABEL_239:
        *(_DWORD *)(v261 + 56 * (int)v259 + 12) = v258;
      }
LABEL_242:
      v256 += 18;
      if (!--v254) {
        goto LABEL_243;
      }
    }
    uint64_t v259 = v256[2];
    uint64_t v262 = *(void *)(*(void *)v256 + 40) + 32 * v259;
    uint64_t v261 = *(void *)(*(void *)v256 + 64);
    if (*(_DWORD *)(v262 + 8) <= *(_DWORD *)(v262 + 12))
    {
LABEL_241:
      *(_DWORD *)(v261 + 56 * (int)v259 + 16) = v258;
      goto LABEL_242;
    }
    goto LABEL_239;
  }
LABEL_243:
  Shape::CheckAdjacencies((uint64_t)this, v241, v53, v242);
  Shape::CheckEdges((uint64_t)this, v243, v53, v22, (Shape *)v7, v293);
  *((_DWORD *)this + 4) = v243;
  int v263 = this[18];
  if (v263) {
    free(v263);
  }
  void *v292 = 0;
  v292[1] = 0;
  int v264 = this[20];
  if (v264) {
    free(v264);
  }
  void *v290 = 0;
  v290[1] = 0;
  Shape::AssembleAretes((Shape *)this);
  uint64_t v265 = *((unsigned int *)this + 4);
  if ((int)v265 >= 1)
  {
    v266 = (char *)this[3] + 12;
    do
    {
      v266[3] = *v266 + *(v266 - 1);
      v266 += 7;
      --v265;
    }
    while (v265);
  }
  Shape::SetFlag((Shape *)this, 2, 1);
  Shape::GetWindings((Shape *)this, v267, v268, v269, 0);
  if (v293 == 3)
  {
    if (*((int *)this + 8) >= 1)
    {
      int v270 = 0;
      while (1)
      {
        uint64_t v271 = (uint64_t)this[9] + 32 * v270;
        int v274 = *(_DWORD *)(v271 + 20);
        v273 = (_DWORD *)(v271 + 20);
        int v272 = v274;
        int v275 = *(v273 - 1) & 1;
        *(v273 - 1) = v275;
        if (v274 < 0)
        {
          _DWORD *v273 = -v272;
          int v272 = 1;
        }
        if (v275)
        {
          v276 = this[7];
          if (v272) {
            goto LABEL_261;
          }
          v276[16 * (uint64_t)v270] = 1;
        }
        else
        {
          if (!v272)
          {
            v276 = this[7];
LABEL_261:
            v276[16 * (uint64_t)v270] = 0;
            Shape::SubEdge((Shape *)this, v270--);
            goto LABEL_262;
          }
          Shape::Inverse((Shape *)this, v270);
          *((_DWORD *)this[7] + 16 * (uint64_t)v270) = 1;
        }
LABEL_262:
        if (++v270 >= *((_DWORD *)this + 8)) {
          goto LABEL_301;
        }
      }
    }
    goto LABEL_301;
  }
  if ((v293 & 0xFFFFFFFD) == 0)
  {
    if (*((int *)this + 8) < 1) {
      goto LABEL_301;
    }
    int v282 = 0;
    while (1)
    {
      uint64_t v283 = (uint64_t)this[9] + 32 * v282;
      int v284 = *(_DWORD *)(v283 + 20);
      if (*(int *)(v283 + 16) < 1)
      {
        if (v284 <= 0)
        {
          v285 = this[7];
LABEL_287:
          v285[16 * (uint64_t)v282] = 0;
          Shape::SubEdge((Shape *)this, v282--);
          goto LABEL_288;
        }
        Shape::Inverse((Shape *)this, v282);
        v285 = this[7];
      }
      else
      {
        v285 = this[7];
        if (v284 > 0) {
          goto LABEL_287;
        }
      }
      v285[16 * (uint64_t)v282] = 1;
LABEL_288:
      if (++v282 >= *((_DWORD *)this + 8)) {
        goto LABEL_301;
      }
    }
  }
  int v277 = *((_DWORD *)this + 8);
  if (v293 != 1)
  {
    if (v277 < 1) {
      goto LABEL_301;
    }
    int v286 = 0;
    while (1)
    {
      uint64_t v287 = (uint64_t)this[9] + 32 * v286;
      int v288 = *(_DWORD *)(v287 + 20);
      if (*(int *)(v287 + 16) < 1)
      {
        if (v288 <= 0)
        {
          v289 = this[7];
LABEL_299:
          v289[16 * (uint64_t)v286] = 0;
          Shape::SubEdge((Shape *)this, v286--);
          goto LABEL_300;
        }
        Shape::Inverse((Shape *)this, v286);
        v289 = this[7];
      }
      else
      {
        v289 = this[7];
        if (v288 > 0) {
          goto LABEL_299;
        }
      }
      v289[16 * (uint64_t)v286] = 1;
LABEL_300:
      if (++v286 >= *((_DWORD *)this + 8)) {
        goto LABEL_301;
      }
    }
  }
  if (v277 >= 1)
  {
    for (int i = 0; i < *((_DWORD *)this + 8); ++i)
    {
      uint64_t v279 = (uint64_t)this[9] + 32 * i;
      int v280 = *(_DWORD *)(v279 + 20);
      if (*(int *)(v279 + 16) < 2)
      {
        if (v280 <= 1)
        {
          v281 = this[7];
LABEL_275:
          v281[16 * (uint64_t)i] = 0;
          Shape::SubEdge((Shape *)this, i--);
          continue;
        }
        Shape::Inverse((Shape *)this, i);
        v281 = this[7];
      }
      else
      {
        v281 = this[7];
        if (v280 > 1) {
          goto LABEL_275;
        }
      }
      v281[16 * (uint64_t)i] = 1;
    }
  }
LABEL_301:
  if (Shape::GetFlag((Shape *)this, 64))
  {
    SweepTree::DestroyList(v297);
    SweepEvent::DestroyQueue(v302);
    Shape::SetFlag((Shape *)this, 64, 0);
  }
  Shape::MakePointData((Shape *)this, 0);
  Shape::MakeEdgeData((Shape *)this, 0);
  Shape::MakeSweepSrcData((Shape *)this, 0);
  Shape::MakeSweepDestData((Shape *)this, 0);
  Shape::CleanupSweep(v291);
  Shape::CleanupSweep((Shape *)v7);
  if (Shape::Eulerian((Shape *)this, 1))
  {
    uint64_t result = 0;
    *((_DWORD *)this + 12) = 1;
  }
  else
  {
    *((_DWORD *)this + 8) = 0;
    *((_DWORD *)this + 4) = 0;
    return 4;
  }
  return result;
}

uint64_t Shape::TesteIntersection(double a1, double a2, double a3, int32x4_t a4, int32x4_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float *a9, float *a10, float *a11, float *a12, char a13)
{
  float v13 = *(void **)(a7 + 64);
  uint64_t v14 = *(int *)(a7 + 72);
  uint64_t v15 = v13[5] + 32 * v14;
  signed __int32 v16 = *(_DWORD *)(v15 + 8);
  signed __int32 v17 = *(_DWORD *)(v15 + 12);
  uint64_t v18 = *(void **)(a8 + 64);
  uint64_t v19 = *(int *)(a8 + 72);
  uint64_t v20 = v18[5] + 32 * v19;
  __int32 v21 = *(_DWORD *)(v20 + 8);
  __int32 v22 = *(_DWORD *)(v20 + 12);
  uint64_t v23 = v13[7];
  uint64_t v24 = v18[7];
  if (v16 >= v17) {
    signed __int32 v25 = v16;
  }
  else {
    signed __int32 v25 = v17;
  }
  if (v16 >= v17) {
    signed __int32 v26 = v17;
  }
  else {
    signed __int32 v26 = v16;
  }
  if (v21 >= v22) {
    __int32 v27 = v21;
  }
  else {
    __int32 v27 = v22;
  }
  if (v21 >= v22) {
    __int32 v28 = v22;
  }
  else {
    __int32 v28 = v21;
  }
  uint64_t v29 = v13[11];
  float v30 = *(float *)(v29 + 48 * v26 + 36);
  float v31 = *(float *)(v29 + 48 * v25 + 36);
  uint64_t v32 = v18[11];
  float v33 = *(float *)(v32 + 48 * v28 + 36);
  float v34 = *(float *)(v32 + 48 * v27 + 36);
  if (v30 >= v31)
  {
    if (v33 >= v34)
    {
      if (v31 > v33 || v30 < v34) {
        return 0;
      }
    }
    else if (v30 < v33 || v31 > v34)
    {
      return 0;
    }
  }
  else if (v33 >= v34)
  {
    if (v30 > v33 || v31 < v34) {
      return 0;
    }
  }
  else if (v31 < v33 || v30 > v34)
  {
    return 0;
  }
  float64x2_t v39 = vcvtq_f64_f32(*(float32x2_t *)(v23 + (v14 << 6) + 4));
  float64x2_t v40 = vcvtq_f64_f32(*(float32x2_t *)(v24 + (v19 << 6) + 4));
  a4.i32[0] = v16;
  a5.i32[0] = v17;
  int8x16_t v41 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(a5, a4), 0);
  int32x4_t v42 = (int32x4_t)vnegq_f64(v39);
  int8x16_t v43 = vbslq_s8(v41, (int8x16_t)v39, (int8x16_t)v42);
  LODWORD(v39.f64[0]) = v21;
  v42.i32[0] = v22;
  int8x16_t v44 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v42, (int32x4_t)v39), 0), (int8x16_t)v40, (int8x16_t)vnegq_f64(v40));
  double v45 = -*(double *)&v43.i64[1];
  if (vmlad_n_f64(-*(double *)&v43.i64[1] * *(double *)v44.i64, *(double *)&v44.i64[1], *(double *)v43.i64) <= 0.0) {
    return 0;
  }
  if (v13 == v18 && v26 == v28)
  {
    if (v25 != v27)
    {
      *a9 = v30;
      *a10 = *(float *)(v29 + 48 * v26 + 40);
      *a11 = -1.0;
      *a12 = -1.0;
      return 1;
    }
    return 0;
  }
  if (v25 == v27) {
    a13 = 1;
  }
  if (v13 == v18 && (a13 & 1) != 0) {
    return 0;
  }
  uint64_t v48 = v29 + 48 * v16;
  float v50 = *(float *)(v48 + 40);
  float64x2_t v49 = (float *)(v48 + 40);
  float v51 = v50;
  float v52 = *(v49 - 1);
  uint64_t v53 = v32 + 48 * v21;
  float v55 = *(float *)(v53 + 40);
  float v54 = (float *)(v53 + 40);
  float v56 = v55;
  float v57 = *(v54 - 1);
  double v58 = (float)(v51 - v55);
  uint64_t v59 = v29 + 48 * v17;
  float v61 = *(float *)(v59 + 40);
  uint64_t v60 = (float *)(v59 + 40);
  float v62 = *(v60 - 1);
  double v63 = *(double *)v44.i64 * v58 - *(double *)&v44.i64[1] * (float)(v52 - v57);
  double v64 = *(double *)v44.i64 * (float)(v61 - v56) - *(double *)&v44.i64[1] * (float)(v62 - v57);
  double v65 = (float)(v56 - v51);
  uint64_t v66 = v32 + 48 * v22;
  float v68 = *(float *)(v66 + 40);
  float v67 = (float *)(v66 + 40);
  float v69 = *(v67 - 1);
  double v70 = v45 * (float)(v57 - v52) + *(double *)v43.i64 * v65;
  double v71 = v45 * (float)(v69 - v52) + *(double *)v43.i64 * (float)(v68 - v51);
  if ((v63 < 0.0 || v64 < 0.0) && (v63 > 0.0 || v64 > 0.0))
  {
    if ((v70 < 0.0 || v71 < 0.0) && (v70 > 0.0 || v71 > 0.0))
    {
      if (*(double *)(v23 + (v14 << 6) + 48) <= *(double *)(v24 + (v19 << 6) + 48))
      {
        double v79 = v63 - v64;
        float v80 = (v63 * v62 - v64 * v52) / (v63 - v64);
        *a9 = v80;
        double v78 = (v63 * *v60 - v64 * *v49) / (v63 - v64);
        double v76 = v70 - v71;
      }
      else
      {
        double v76 = v70 - v71;
        float v77 = (v70 * v69 - v71 * v57) / (v70 - v71);
        *a9 = v77;
        double v78 = (v70 * *v67 - v71 * *v54) / (v70 - v71);
        double v79 = v63 - v64;
      }
      float v81 = v78;
      *a10 = v81;
      float v82 = v63 / v79;
      *a11 = v82;
      double v72 = v70 / v76;
      goto LABEL_59;
    }
    if (v70 == 0.0)
    {
LABEL_66:
      if (v21 >= v22) {
        return 0;
      }
      goto LABEL_67;
    }
    if (v71 == 0.0)
    {
      if (v21 <= v22) {
        return 0;
      }
      goto LABEL_79;
    }
    if (v16 < v17 && v70 > 0.0 && v71 > 0.0)
    {
      if (v70 >= v71)
      {
        if (v22 < v21) {
          goto LABEL_79;
        }
      }
      else if (v21 < v22)
      {
LABEL_67:
        *a9 = v57;
        *a10 = *v54;
        *a12 = 0.0;
LABEL_80:
        float v75 = v63 / (v63 - v64);
        *a11 = v75;
        return 1;
      }
    }
    uint64_t result = 0;
    if (v17 >= v16 || v70 >= 0.0 || v71 >= 0.0) {
      return result;
    }
    if (v70 > v71) {
      goto LABEL_66;
    }
    if (v22 >= v21) {
      return 0;
    }
LABEL_79:
    *a9 = v69;
    *a10 = *v67;
    *a12 = 1.0;
    goto LABEL_80;
  }
  if (v63 == 0.0) {
    goto LABEL_53;
  }
  if (v64 == 0.0)
  {
    if (v16 <= v17) {
      return 0;
    }
    goto LABEL_57;
  }
  if (v63 > 0.0 && v64 > 0.0 && v22 < v21)
  {
    if (v63 >= v64)
    {
      if (v17 < v16) {
        goto LABEL_57;
      }
    }
    else if (v16 < v17)
    {
LABEL_54:
      *a9 = v52;
      *a10 = *v49;
      *a11 = 0.0;
LABEL_58:
      double v72 = v70 / (v70 - v71);
LABEL_59:
      float v73 = v72;
      *a12 = v73;
      return 1;
    }
  }
  uint64_t result = 0;
  if (v21 < v22 && v63 < 0.0 && v64 < 0.0)
  {
    if (v63 > v64)
    {
LABEL_53:
      if (v16 >= v17) {
        return 0;
      }
      goto LABEL_54;
    }
    if (v17 >= v16) {
      return 0;
    }
LABEL_57:
    *a9 = v62;
    *a10 = *v60;
    *a11 = 1.0;
    goto LABEL_58;
  }
  return result;
}

uint64_t Shape::PushIncidence(Shape *this, Shape *a2, int a3, int a4, float a5)
{
  if (a5 < 0.0 || a5 > 1.0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = *((unsigned int *)this + 38);
  if ((int)result >= *((_DWORD *)this + 39))
  {
    uint64_t v13 = (2 * (int)result) | 1;
    *((_DWORD *)this + 39) = v13;
    int v12 = (char *)malloc_type_realloc(*((void **)this + 20), 12 * v13, 0x10000403E1C8BA9uLL);
    *((void *)this + 20) = v12;
    uint64_t result = *((unsigned int *)this + 38);
  }
  else
  {
    int v12 = (char *)*((void *)this + 20);
  }
  *((_DWORD *)this + 38) = result + 1;
  uint64_t v14 = *((void *)a2 + 8) + 56 * a3;
  uint64_t v15 = &v12[12 * (int)result];
  *(_DWORD *)uint64_t v15 = *(_DWORD *)(v14 + 8);
  *((_DWORD *)v15 + 1) = a4;
  *((float *)v15 + 2) = a5;
  *(_DWORD *)(v14 + 8) = result;
  return result;
}

uint64_t Shape::CreateIncidence(Shape *this, Shape *a2, int a3, int a4)
{
  uint64_t v4 = *((void *)a2 + 7) + ((uint64_t)a3 << 6);
  uint64_t v5 = (float *)(*((void *)this + 3) + 28 * a4);
  uint64_t v6 = *((void *)a2 + 11) + 48 * *(int *)(*((void *)a2 + 5) + 32 * a3 + 8);
  float v7 = *(double *)(v4 + 32)
     * (*(float *)(v4 + 8) * (float)(v5[1] - *(float *)(v6 + 40))
      + (float)(*v5 - *(float *)(v6 + 36)) * *(float *)(v4 + 4));
  return Shape::PushIncidence(this, a2, a3, a4, v7);
}

uint64_t Shape::Winding(Shape *this, int a2)
{
  uint64_t v2 = *(unsigned int *)(*((void *)this + 11) + 48 * a2 + 32);
  if ((v2 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v3 = *((void *)this + 5) + 32 * v2;
  uint64_t v4 = *((void *)this + 9) + 32 * v2;
  if (*(_DWORD *)(v3 + 8) >= *(_DWORD *)(v3 + 12)) {
    return *(unsigned int *)(v4 + 20);
  }
  else {
    return *(unsigned int *)(v4 + 16);
  }
}

uint64_t Shape::Winding(Shape *this, float a2, float a3)
{
  uint64_t v3 = *((unsigned int *)this + 8);
  if ((int)v3 < 1) {
    return 0;
  }
  int v4 = 0;
  int v5 = 0;
  int v6 = 0;
  uint64_t v7 = *((void *)this + 11);
  uint64_t v8 = (float *)(*((void *)this + 7) + 8);
  BOOL v9 = (int *)(*((void *)this + 5) + 12);
  do
  {
    uint64_t v10 = v7 + 48 * *(v9 - 1);
    float v11 = *(float *)(v10 + 36);
    float v12 = *(float *)(v10 + 40);
    uint64_t v13 = v7 + 48 * *v9;
    float v15 = *(float *)(v13 + 36);
    float v14 = *(float *)(v13 + 40);
    int v16 = *((_DWORD *)v8 - 2);
    if (v11 >= v15)
    {
      if (v11 < a2 || v15 > a2) {
        goto LABEL_39;
      }
    }
    else if (v11 > a2 || v15 < a2)
    {
      goto LABEL_39;
    }
    if (v11 == a2)
    {
      if (v12 < a3 && v15 != a2)
      {
        if (v15 >= a2) {
          int v20 = *((_DWORD *)v8 - 2);
        }
        else {
          int v20 = 0;
        }
        if (v15 >= a2) {
          int v16 = 0;
        }
        v6 -= v20;
        v5 += v16;
      }
    }
    else if (v15 == a2)
    {
      if (v14 < a3)
      {
        if (v11 >= a2) {
          int v21 = *((_DWORD *)v8 - 2);
        }
        else {
          int v21 = 0;
        }
        v6 += v21;
        if (v11 >= a2) {
          int v16 = 0;
        }
        v5 -= v16;
      }
    }
    else
    {
      if (v12 >= v14)
      {
        if (v14 >= a3) {
          goto LABEL_39;
        }
      }
      else if (v12 >= a3)
      {
        goto LABEL_39;
      }
      double v22 = *(v8 - 1) * (a3 - v12) - (a2 - v11) * *v8;
      if (v22 != 0.0)
      {
        if (v22 >= 0.0)
        {
          if (v11 < a2) {
            v4 -= v16;
          }
        }
        else if (v11 > a2)
        {
          v4 += v16;
        }
      }
    }
LABEL_39:
    v8 += 16;
    v9 += 8;
    --v3;
  }
  while (v3);
  int v23 = v5 + v6;
  if (v5 + v6 < 0 != __OFADD__(v5, v6)) {
    ++v23;
  }
  return (v4 + (v23 >> 1));
}

unsigned int *Shape::AssemblePoints(unsigned int *this, Shape *a2)
{
  uint64_t v2 = this[4];
  if ((int)v2 >= 1)
  {
    int v4 = this;
    this = (unsigned int *)Shape::AssemblePoints((Shape *)this, 0, v2);
    uint64_t v5 = *((unsigned int *)a2 + 8);
    if ((int)v5 >= 1)
    {
      uint64_t v6 = *((void *)v4 + 11);
      uint64_t v7 = (int *)(*((void *)a2 + 8) + 16);
      do
      {
        *(v7 - 1) = *(_DWORD *)(v6 + 48 * *(v7 - 1) + 4);
        *uint64_t v7 = *(_DWORD *)(v6 + 48 * *v7 + 4);
        v7 += 14;
        --v5;
      }
      while (v5);
    }
    uint64_t v8 = v4[38];
    if ((int)v8 >= 1)
    {
      uint64_t v9 = *((void *)v4 + 11);
      uint64_t v10 = (int *)(*((void *)v4 + 20) + 4);
      do
      {
        *uint64_t v10 = *(_DWORD *)(v9 + 48 * *v10 + 4);
        v10 += 3;
        --v8;
      }
      while (v8);
    }
    v4[4] = this;
  }
  return this;
}

uint64_t Shape::TesteIntersection(Shape *this, Shape *a2, Shape *a3, int a4, int a5, float *a6, float *a7, float *a8, float *a9, BOOL a10)
{
  uint64_t v10 = *((void *)a2 + 5) + 32 * a4;
  int v11 = *(_DWORD *)(v10 + 8);
  uint64_t v12 = *((void *)a3 + 5) + 32 * a5;
  int v13 = *(_DWORD *)(v12 + 8);
  int v14 = *(_DWORD *)(v12 + 12);
  if (v11 == v13 || v11 == v14) {
    return 0;
  }
  int v16 = *(_DWORD *)(v10 + 12);
  if (v16 == v13 || v16 == v14) {
    return 0;
  }
  uint64_t v18 = *((void *)a2 + 11);
  uint64_t v19 = v18 + 48 * v11;
  float32x2_t v20 = *(float32x2_t *)(v19 + 36);
  uint64_t v21 = v18 + 48 * v16;
  float32x2_t v22 = *(float32x2_t *)(v21 + 36);
  uint64_t v23 = *((void *)a3 + 11);
  uint64_t v24 = v23 + 48 * v13;
  float32x2_t v25 = *(float32x2_t *)(v24 + 36);
  uint64_t v26 = v23 + 48 * v14;
  float32x2_t v27 = *(float32x2_t *)(v26 + 36);
  *(float32x2_t *)v28.f32 = v20;
  *(float32x2_t *)&v28.u32[2] = v25;
  *(float32x2_t *)v29.f32 = v22;
  *(float32x2_t *)&v29.u32[2] = v27;
  int32x4_t v30 = vcgtq_f32(v28, v29);
  int8x8_t v31 = (int8x8_t)vmovn_s32(v30);
  *(float32x2_t *)v32.i8 = v27;
  v32.u64[1] = (unint64_t)v22;
  *(float32x2_t *)v33.i8 = v25;
  v33.u64[1] = (unint64_t)v20;
  if (vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32(vcgtq_f32((float32x4_t)vbslq_s8((int8x16_t)vmovl_s16((int16x4_t)vext_s8(v31, v31, 4uLL)), v32, v33), (float32x4_t)vbslq_s8((int8x16_t)v30, (int8x16_t)v28, (int8x16_t)v29))), 0xFuLL))))return 0; {
  uint64_t v34 = *((void *)a2 + 7) + ((uint64_t)a4 << 6);
  }
  float v35 = *(float *)(v34 + 4);
  float v36 = *(float *)(v34 + 8);
  uint64_t v37 = *((void *)a3 + 7) + ((uint64_t)a5 << 6);
  double v38 = *(float *)(v37 + 8);
  double v39 = *(float *)(v37 + 4);
  float32x2_t v40 = vsub_f32(v22, v25);
  double v41 = v39 * (float)(v20.f32[1] - v25.f32[1]) - v38 * vsub_f32(v20, v25).f32[0];
  double v42 = v39 * v40.f32[1] - v38 * v40.f32[0];
  if (v41 >= 0.0 && v42 >= 0.0) {
    return 0;
  }
  if (v41 <= 0.0 && v42 <= 0.0) {
    return 0;
  }
  double v43 = v35;
  double v44 = v36;
  float32x2_t v45 = vsub_f32(v27, v20);
  double v46 = v35 * (float)(v25.f32[1] - v20.f32[1]) - v44 * vsub_f32(v25, v20).f32[0];
  double v47 = v43 * v45.f32[1] - v44 * v45.f32[0];
  if (v46 >= 0.0 && v47 >= 0.0) {
    return 0;
  }
  if (v46 <= 0.0 && v47 <= 0.0) {
    return 0;
  }
  double v49 = v46 - v47;
  double v50 = v41 - v42;
  double v51 = -(v46 - v47);
  if (v46 - v47 >= 0.0) {
    double v51 = v46 - v47;
  }
  double v52 = -v50;
  if (v50 >= 0.0) {
    double v52 = v41 - v42;
  }
  if (v51 <= v52)
  {
    uint64_t v53 = (float *)(v19 + 40);
    float v54 = (float *)(v21 + 40);
    double v59 = v20.f32[0];
    double v55 = -v42;
    double v56 = (v41 * v22.f32[0] - v42 * v59) / v50;
    double v57 = v41;
    double v58 = v41 - v42;
  }
  else
  {
    uint64_t v53 = (float *)(v24 + 40);
    float v54 = (float *)(v26 + 40);
    double v55 = -v47;
    double v56 = (v46 * v27.f32[0] - v47 * v25.f32[0]) / v49;
    double v57 = v46;
    double v58 = v46 - v47;
  }
  float v60 = v56;
  *a6 = v60;
  float v61 = (v55 * *v53 + v57 * *v54) / v58;
  *a7 = v61;
  float v62 = v41 / v50;
  *a8 = v62;
  float v63 = v46 / v49;
  *a9 = v63;
  return 1;
}

BOOL Shape::TesteAdjacency(Shape *this, Shape *a2, int a3, float a4, float a5, int a6, int a7)
{
  uint64_t v7 = *((void *)a2 + 8);
  if (*(_DWORD *)(v7 + 56 * a3 + 12) == a6 || *(_DWORD *)(v7 + 56 * a3 + 16) == a6) {
    return 0;
  }
  uint64_t v13 = *((void *)a2 + 11) + 48 * *(int *)(*((void *)a2 + 5) + 32 * a3 + 8);
  uint64_t v14 = *((void *)a2 + 7) + ((uint64_t)a3 << 6);
  double v15 = *(float *)(v14 + 4);
  double v16 = *(float *)(v14 + 8);
  double v17 = *(double *)(v14 + 16);
  double v18 = a4 - *(float *)(v13 + 36);
  double v19 = a5 - *(float *)(v13 + 40);
  double v20 = *(double *)(v14 + 32);
  float v21 = (v15 * v19 - v18 * v16) * *(double *)(v14 + 40);
  float v22 = ldexpf(v21, 5);
  if (v22 <= -3.0 || v22 >= 3.0) {
    return 0;
  }
  double v25 = ldexpf(0.505, -5);
  double v26 = v18 - v25;
  double v27 = v19 - v25;
  double v28 = v18 + v25;
  double v29 = v19 + v25;
  double v30 = -(v26 * v16);
  double v31 = v30 + v15 * v27;
  double v32 = -(v28 * v16);
  double v33 = v32 + v15 * v29;
  if (v31 < 0.0 && v33 > 0.0
    || v31 > 0.0 && v33 < 0.0
    || (double v34 = v32 + v15 * v27, v35 = v30 + v15 * v29, v34 < 0.0) && v35 > 0.0
    || (BOOL result = 0, v34 > 0.0) && v35 < 0.0)
  {
    double v36 = v19 * v16 + v18 * v15;
    BOOL v37 = v36 <= 0.0;
    if (v36 >= v17) {
      BOOL v37 = 1;
    }
    BOOL result = !v37;
    if (!v37)
    {
      if (a7)
      {
        float v38 = v20 * v36;
        Shape::PushIncidence(this, a2, a3, a6, v38);
        return 1;
      }
    }
  }
  return result;
}

uint64_t Shape::Validate(uint64_t this)
{
  uint64_t v1 = (Shape *)this;
  uint64_t v2 = *(unsigned int *)(this + 16);
  if ((int)v2 >= 1)
  {
    uint64_t v3 = *(uint64_t **)(this + 24);
    int v4 = (void *)(*(void *)(this + 88) + 36);
    do
    {
      uint64_t v5 = *v3;
      uint64_t v3 = (uint64_t *)((char *)v3 + 28);
      void *v4 = v5;
      v4 += 6;
      --v2;
    }
    while (v2);
  }
  int v6 = *(_DWORD *)(this + 32);
  if (v6 >= 1)
  {
    uint64_t v7 = *(uint64_t **)(this + 40);
    uint64_t v8 = (void *)(*(void *)(this + 56) + 4);
    uint64_t v9 = *(unsigned int *)(this + 32);
    do
    {
      uint64_t v10 = *v7;
      v7 += 4;
      *uint64_t v8 = v10;
      v8 += 8;
      --v9;
    }
    while (v9);
    int v11 = 0;
    do
    {
      int v12 = v11++;
      if (v11 < v6)
      {
        int v13 = v11;
        do
        {
          uint64_t v16 = 0;
          this = Shape::TesteIntersection((Shape *)this, v1, v1, v12, v13, (float *)&v16 + 1, (float *)&v16, &v15, &v14, 0);
          if (this)
          {
            this = printf("%i %i  %f %f \n", v12, v13, *((float *)&v16 + 1), *(float *)&v16);
            int v6 = *((_DWORD *)v1 + 8);
          }
          ++v13;
        }
        while (v13 < v6);
      }
    }
    while (v11 < v6);
  }
  return this;
}

void Shape::Avance(uint64_t a1, signed int a2, int a3, Shape *a4, int a5, uint64_t a6, Shape *a7, int a8)
{
  float v15 = ldexpf(1.0, -5);
  BOOL v17 = a4 != a7 || (a8 & 0xFFFFFFFE) != 2;
  uint64_t v18 = *((void *)a4 + 8);
  int v19 = a5;
  double v20 = (_DWORD *)(v18 + 56 * a5);
  if (v20[12] < a3)
  {
    float v21 = v15;
    int v23 = v20[6];
    signed int v22 = v20[7];
    unsigned int v24 = *(_DWORD *)(v18 + 56 * a5 + 44);
    BOOL v25 = (v24 & 0x80000000) == 0
       && (float)(v15 + *(float *)(*(void *)(a1 + 24) + 28 * v24 + 4)) == *(float *)(*(void *)(a1 + 24)
                                                                                       + 28 * a3
                                                                                       + 4);
    uint64_t v26 = *((void *)a4 + 7) + ((uint64_t)a5 << 6);
    float v27 = *(float *)(v26 + 8);
    BOOL v28 = v27 <= 0.0;
    if (v27 == 0.0)
    {
      if (*(float *)(v26 + 4) >= 0.0)
      {
        int v19 = a5;
        if (v23 <= v22)
        {
          int v29 = a5;
          do
            Shape::DoEdgeTo((Shape *)a1, a4, a5, v23++, v17, 1);
          while (v22 + 1 != v23);
          goto LABEL_41;
        }
      }
      else
      {
        int v19 = a5;
        if (v23 <= v22)
        {
          int v29 = a5;
          do
            Shape::DoEdgeTo((Shape *)a1, a4, a5, v23++, v17, 0);
          while (v22 + 1 != v23);
LABEL_41:
          unsigned int v24 = v22;
          int v19 = v29;
        }
      }
LABEL_103:
      uint64_t v18 = *((void *)a4 + 8);
      *(_DWORD *)(v18 + 56 * v19 + 44) = v24;
      goto LABEL_104;
    }
    float v30 = *(float *)(v26 + 4);
    if (v28)
    {
      if (v30 >= 0.0)
      {
        if (v22 >= v23)
        {
          signed int v76 = a2;
          int v63 = 0;
          signed int v64 = v22 + 1;
          do
          {
            signed int v65 = v24;
            unsigned int v24 = v22 + v63;
            if (v63) {
              BOOL v66 = 0;
            }
            else {
              BOOL v66 = v25;
            }
            if (v66
              && (uint64_t v67 = *(void *)(a1 + 24),
                  float v68 = *(float *)(v67 + 28 * v65),
                  *(float *)(v67 + 28 * v22) == (float)(v68 - v21)))
            {
              BOOL v69 = v22 < *(_DWORD *)(a1 + 16) && v64 < a2;
              if (v69 && *(float *)(v67 + 28 * v64) == v68) {
                Shape::DoEdgeTo((Shape *)a1, a4, a5, v22 + 1, v17, 0);
              }
              double v70 = (Shape *)a1;
              double v71 = a4;
              int v72 = a5;
              unsigned int v73 = v22;
            }
            else
            {
              double v70 = (Shape *)a1;
              double v71 = a4;
              int v72 = a5;
              unsigned int v73 = v22 + v63;
            }
            Shape::DoEdgeTo(v70, v71, v72, v73, v17, 0);
            signed int v64 = v22 + 1;
            --v63;
          }
          while (v22 + v63 + 1 > v23);
          goto LABEL_100;
        }
LABEL_102:
        int v19 = a5;
        goto LABEL_103;
      }
      if (v23 > v22) {
        goto LABEL_102;
      }
      signed int v76 = a2;
      int v41 = 0;
      unsigned int v74 = v23 - 1;
      BOOL v43 = v23 < 1 || v23 <= a3;
      BOOL v77 = v43;
      do
      {
        signed int v44 = v24;
        unsigned int v24 = v23 + v41;
        if (v41) {
          BOOL v45 = 0;
        }
        else {
          BOOL v45 = v25;
        }
        if (v45
          && (uint64_t v46 = *(void *)(a1 + 24),
              float v47 = *(float *)(v46 + 28 * v44),
              *(float *)(v46 + 28 * v23) == (float)(v21 + v47)))
        {
          if (!v77 && *(float *)(v46 + 28 * v74) == v47) {
            Shape::DoEdgeTo((Shape *)a1, a4, a5, v74, v17, 0);
          }
          uint64_t v48 = (Shape *)a1;
          double v49 = a4;
          int v50 = a5;
          unsigned int v51 = v23;
        }
        else
        {
          uint64_t v48 = (Shape *)a1;
          double v49 = a4;
          int v50 = a5;
          unsigned int v51 = v23 + v41;
        }
        Shape::DoEdgeTo(v48, v49, v50, v51, v17, 0);
        ++v41;
      }
      while (v22 - v23 + 1 != v41);
    }
    else
    {
      if (v30 < 0.0)
      {
        if (v22 >= v23)
        {
          signed int v76 = a2;
          int v31 = 0;
          signed int v79 = v22 + 1;
          do
          {
            signed int v32 = v24;
            unsigned int v24 = v22 + v31;
            if (v31) {
              BOOL v33 = 0;
            }
            else {
              BOOL v33 = v25;
            }
            if (v33
              && (uint64_t v34 = *(void *)(a1 + 24),
                  float v35 = *(float *)(v34 + 28 * v32),
                  *(float *)(v34 + 28 * v22) == (float)(v35 - v21)))
            {
              BOOL v36 = v22 < *(_DWORD *)(a1 + 16) && v79 < a2;
              if (v36 && *(float *)(v34 + 28 * v79) == v35) {
                Shape::DoEdgeTo((Shape *)a1, a4, a5, v79, v17, 1);
              }
              BOOL v37 = (Shape *)a1;
              float v38 = a4;
              int v39 = a5;
              unsigned int v40 = v22;
            }
            else
            {
              BOOL v37 = (Shape *)a1;
              float v38 = a4;
              int v39 = a5;
              unsigned int v40 = v22 + v31;
            }
            Shape::DoEdgeTo(v37, v38, v39, v40, v17, 1);
            --v31;
          }
          while (v22 + v31 + 1 > v23);
LABEL_100:
          unsigned int v24 = v23;
          goto LABEL_101;
        }
        goto LABEL_102;
      }
      if (v23 > v22) {
        goto LABEL_102;
      }
      signed int v76 = a2;
      int v52 = 0;
      unsigned int v75 = v23 - 1;
      BOOL v54 = v23 < 1 || v23 <= a3;
      BOOL v78 = v54;
      do
      {
        signed int v55 = v24;
        unsigned int v24 = v23 + v52;
        if (v52) {
          BOOL v56 = 0;
        }
        else {
          BOOL v56 = v25;
        }
        if (v56
          && (uint64_t v57 = *(void *)(a1 + 24),
              float v58 = *(float *)(v57 + 28 * v55),
              *(float *)(v57 + 28 * v23) == (float)(v21 + v58)))
        {
          if (!v78 && *(float *)(v57 + 28 * v75) == v58) {
            Shape::DoEdgeTo((Shape *)a1, a4, a5, v75, v17, 1);
          }
          double v59 = (Shape *)a1;
          float v60 = a4;
          int v61 = a5;
          unsigned int v62 = v23;
        }
        else
        {
          double v59 = (Shape *)a1;
          float v60 = a4;
          int v61 = a5;
          unsigned int v62 = v23 + v52;
        }
        Shape::DoEdgeTo(v59, v60, v61, v62, v17, 1);
        ++v52;
      }
      while (v22 - v23 + 1 != v52);
    }
    unsigned int v24 = v22;
LABEL_101:
    a2 = v76;
    goto LABEL_102;
  }
LABEL_104:
  *(_DWORD *)(v18 + 56 * v19 + 48) = a2 - 1;
}

uint64_t Shape::DoEdgeTo(Shape *this, Shape *a2, int a3, unsigned int a4, int a5, int a6)
{
  uint64_t v9 = a3;
  uint64_t v10 = *((void *)a2 + 8) + 56 * a3;
  unsigned int v11 = *(_DWORD *)(v10 + 44);
  if (a6)
  {
    if (!a5)
    {
LABEL_3:
      unsigned int v12 = a4;
      goto LABEL_6;
    }
  }
  else if (a5)
  {
    goto LABEL_3;
  }
  unsigned int v12 = *(_DWORD *)(v10 + 44);
  unsigned int v11 = a4;
LABEL_6:
  uint64_t result = Shape::AddEdge(this, v12, v11);
  if ((result & 0x80000000) != 0)
  {
    *(_DWORD *)(*((void *)a2 + 8) + 56 * (int)v9 + 44) = a4;
  }
  else
  {
    if ((*((unsigned char *)this + 53) & 2) != 0)
    {
      uint64_t v15 = *((void *)a2 + 12);
      uint64_t v16 = *((void *)this + 12);
      unsigned int v14 = result;
      *(void *)(v16 + 16 * result) = *(void *)(v15 + 16 * v9);
      uint64_t v17 = *((void *)a2 + 7) + (v9 << 6);
      if (*(double *)(v17 + 16) >= 0.00001)
      {
        float v20 = *(double *)(v17 + 32);
        uint64_t v21 = *((void *)a2 + 11) + 48 * *(int *)(*((void *)a2 + 5) + 32 * v9 + 8);
        float v22 = *(float *)(v21 + 36);
        float v23 = *(float *)(v21 + 40);
        float v24 = *(float *)(v17 + 4);
        float v25 = *(float *)(v17 + 8);
        uint64_t v26 = *((void *)this + 3);
        uint64_t v27 = *((void *)this + 5) + 32 * result;
        BOOL v28 = (float *)(v26 + 28 * *(int *)(v27 + 8));
        int v29 = (float *)(v26 + 28 * *(int *)(v27 + 12));
        float v30 = (float)((float)(v25 * (float)(v28[1] - v23)) + (float)((float)(*v28 - v22) * v24)) * v20;
        float v31 = (float)((float)(v25 * (float)(v29[1] - v23)) + (float)((float)(*v29 - v22) * v24)) * v20;
        uint64_t v32 = v15 + 16 * v9;
        float v33 = *(float *)(v32 + 8);
        float v34 = *(float *)(v32 + 12);
        uint64_t v35 = v16 + 16 * result;
        *(float *)(v35 + 8) = (float)(v30 * v34) + (float)(v33 * (float)(1.0 - v30));
        *(float *)(v35 + 12) = (float)(v34 * v31) + (float)(v33 * (float)(1.0 - v31));
      }
      else
      {
        uint64_t v18 = (const float *)(v15 + 16 * v9 + 8);
        float32x2_t v19 = vld1_dup_f32(v18);
        *(float32x2_t *)(v16 + 16 * result + 8) = v19;
      }
    }
    else
    {
      unsigned int v14 = result;
    }
    uint64_t v36 = *((void *)a2 + 8) + 56 * (int)v9;
    unsigned int v39 = *(_DWORD *)(v36 + 8);
    BOOL v37 = (_DWORD *)(v36 + 8);
    uint64_t v38 = v39;
    v37[9] = a4;
    *(_DWORD *)(*((void *)this + 8) + 56 * v14 + 8) = v39;
    if ((v39 & 0x80000000) == 0)
    {
      uint64_t v40 = *((void *)this + 11);
      do
      {
        uint64_t v41 = v40 + 48 * v38;
        *(_DWORD *)(v41 + 32) = result;
        uint64_t v38 = *(unsigned int *)(v41 + 16);
      }
      while ((v38 & 0x80000000) == 0);
    }
    *BOOL v37 = -1;
  }
  return result;
}

void SweepEvent::~SweepEvent(SweepEvent *this)
{
}

{
  SweepEvent::MakeDelete((uint64_t *)this);
}

uint64_t *SweepEvent::MakeDelete(uint64_t *this)
{
  uint64_t v1 = *this;
  if (*this)
  {
    uint64_t v2 = *(void *)(v1 + 64);
    uint64_t v3 = *(void *)(v2 + 40) + 32 * *(int *)(v1 + 72);
    int v5 = *(_DWORD *)(v3 + 8);
    int v4 = *(_DWORD *)(v3 + 12);
    uint64_t v6 = *(void *)(v2 + 88);
    if (v5 > v4) {
      int v4 = v5;
    }
    --*(_DWORD *)(v6 + 48 * v4 + 8);
    *(void *)(v1 + 56) = 0;
  }
  uint64_t v7 = this[1];
  if (v7)
  {
    uint64_t v8 = *(void *)(v7 + 64);
    uint64_t v9 = *(void *)(v8 + 40) + 32 * *(int *)(v7 + 72);
    int v11 = *(_DWORD *)(v9 + 8);
    int v10 = *(_DWORD *)(v9 + 12);
    uint64_t v12 = *(void *)(v8 + 88);
    if (v11 > v10) {
      int v10 = v11;
    }
    --*(_DWORD *)(v12 + 48 * v10 + 8);
    *(void *)(v7 + 48) = 0;
  }
  *this = 0;
  this[1] = 0;
  return this;
}

uint64_t SweepEvent::MakeNew(uint64_t result, uint64_t a2, uint64_t a3, float a4, float a5, float a6, float a7)
{
  *(_DWORD *)(result + 32) = -1;
  *(float *)(result + 16) = a4;
  *(float *)(result + 20) = a5;
  *(float *)(result + 24) = a6;
  *(float *)(result + 28) = a7;
  *(void *)uint64_t result = a2;
  *(void *)(result + 8) = a3;
  *(void *)(a2 + 56) = result;
  *(void *)(a3 + 48) = result;
  return result;
}

void *SweepEvent::CreateQueue(uint64_t a1, int a2)
{
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = a2;
  *(void *)(a1 + 16) = malloc_type_malloc(40 * a2, 0x1020040EF90260EuLL);
  uint64_t result = malloc_type_malloc(4 * *(int *)(a1 + 4), 0x100004052888210uLL);
  *(void *)(a1 + 8) = result;
  return result;
}

void SweepEvent::DestroyQueue(void *a1)
{
  uint64_t v2 = (void *)a1[2];
  if (v2) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[1];
  if (v3) {
    free(v3);
  }
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

uint64_t SweepEvent::AddInQueue(uint64_t a1, uint64_t a2, uint64_t a3, float a4, float a5, float a6, float a7)
{
  int v7 = *(_DWORD *)a3;
  if (*(_DWORD *)a3 >= *(_DWORD *)(a3 + 4)) {
    return 0;
  }
  *(_DWORD *)a3 = v7 + 1;
  uint64_t v9 = *(void *)(a3 + 8);
  uint64_t v8 = *(void *)(a3 + 16);
  uint64_t v10 = v8 + 40 * v7;
  *(float *)(v10 + 16) = a4;
  *(float *)(v10 + 20) = a5;
  *(float *)(v10 + 24) = a6;
  *(float *)(v10 + 28) = a7;
  *(void *)uint64_t v10 = a1;
  *(void *)(v10 + 8) = a2;
  *(void *)(a1 + 56) = v10;
  *(void *)(a2 + 48) = v10;
  uint64_t v11 = *(void *)(a1 + 64);
  uint64_t v12 = *(void *)(v11 + 40) + 32 * *(int *)(a1 + 72);
  int v14 = *(_DWORD *)(v12 + 8);
  int v13 = *(_DWORD *)(v12 + 12);
  uint64_t v15 = *(void *)(v11 + 88);
  if (v14 > v13) {
    int v13 = v14;
  }
  ++*(_DWORD *)(v15 + 48 * v13 + 8);
  *(_DWORD *)(v10 + 32) = v7;
  uint64_t v16 = *(void *)(a2 + 64);
  uint64_t v17 = *(void *)(v16 + 40) + 32 * *(int *)(a2 + 72);
  int v18 = *(_DWORD *)(v17 + 8);
  int v19 = *(_DWORD *)(v17 + 12);
  if (v18 > v19) {
    int v19 = v18;
  }
  uint64_t v20 = *(void *)(v16 + 88) + 48 * v19;
  ++*(_DWORD *)(v20 + 8);
  *(_DWORD *)(v9 + 4 * v7) = v7;
  if (v7 >= 1)
  {
    unsigned int v21 = v7;
    do
    {
      unsigned int v22 = v21 - 1;
      uint64_t v23 = (v21 - 1) >> 1;
      int v24 = *(_DWORD *)(v9 + 4 * v23);
      float v25 = *(float *)(v8 + 40 * v24 + 20);
      if (v25 <= a5 && (v25 != a5 || *(float *)(v8 + 40 * v24 + 16) <= a4)) {
        break;
      }
      *(_DWORD *)(v10 + 32) = v23;
      *(_DWORD *)(v8 + 40 * v24 + 32) = v21;
      *(_DWORD *)(v9 + 4 * v23) = v7;
      *(_DWORD *)(v9 + 4 * v21) = v24;
      unsigned int v21 = v22 >> 1;
    }
    while (v22 > 1);
  }
  return v10;
}

void SweepEvent::SupprFromQueue(uint64_t a1, int *a2)
{
  if (*a2 <= 1)
  {
    SweepEvent::MakeDelete((uint64_t *)a1);
    *a2 = 0;
    return;
  }
  int v3 = *(_DWORD *)(a1 + 32);
  int v4 = *(_DWORD *)(*((void *)a2 + 1) + 4 * v3);
  SweepEvent::MakeDelete((uint64_t *)a1);
  uint64_t v5 = *((void *)a2 + 2);
  uint64_t v6 = *a2 - 1;
  *a2 = v6;
  SweepEvent::Relocate((__n128 *)(v5 + 40 * v6), (uint64_t)a2, v4);
  uint64_t v7 = *a2;
  if (v7 != v3)
  {
    uint64_t v8 = *((void *)a2 + 1);
    uint64_t v9 = *((void *)a2 + 2);
    int v10 = *(_DWORD *)(v8 + 4 * v7);
    uint64_t v11 = v9 + 40 * v10;
    *(_DWORD *)(v11 + 32) = v3;
    uint64_t v12 = (int *)(v11 + 32);
    *(_DWORD *)(v8 + 4 * v3) = v10;
    float v13 = *((float *)v12 - 4);
    float v14 = *((float *)v12 - 3);
    if (v3 >= 1)
    {
      for (char i = 0; ; char i = 1)
      {
        unsigned int v16 = v3 - 1;
        uint64_t v17 = (v3 - 1) >> 1;
        int v18 = *(_DWORD *)(v8 + 4 * v17);
        float v19 = *(float *)(v9 + 40 * v18 + 20);
        if (v14 >= v19 && (v14 != v19 || v13 >= *(float *)(v9 + 40 * v18 + 16))) {
          break;
        }
        *uint64_t v12 = v17;
        *(_DWORD *)(v9 + 40 * v18 + 32) = v3;
        *(_DWORD *)(v8 + 4 * v17) = v10;
        *(_DWORD *)(v8 + 4 * v3) = v18;
        int v3 = v16 >> 1;
        if (v16 < 2) {
          return;
        }
      }
      if (i) {
        return;
      }
    }
    int v20 = (2 * v3) | 1;
    int v21 = *a2;
    if (v20 >= *a2) {
      return;
    }
    int v22 = 2 * v3;
    while (1)
    {
      int v23 = v22 + 2;
      int v24 = (int *)(v8 + 4 * v20);
      int v25 = *v24;
      int v26 = *v24;
      float v27 = *(float *)(v9 + 40 * *v24 + 20);
      if (v23 >= v21)
      {
        if (v14 > v27 || v14 == v27 && v13 > *(float *)(v9 + 40 * v26 + 16))
        {
          *uint64_t v12 = v20;
          *(_DWORD *)(v9 + 40 * v26 + 32) = v3;
          *int v24 = v10;
          *(_DWORD *)(v8 + 4 * v3) = v25;
        }
        return;
      }
      BOOL v28 = (int *)(v8 + 4 * v23);
      int v29 = *v28;
      if (v14 > v27 || v14 == v27 && v13 > *(float *)(v9 + 40 * v26 + 16)) {
        break;
      }
      float v31 = *(float *)(v9 + 40 * v29 + 20);
      if (v14 > v31) {
        goto LABEL_23;
      }
      if (v14 != v31) {
        return;
      }
      int v20 = v23;
      int v26 = *v28;
      int v24 = (int *)(v8 + 4 * v23);
      int v25 = *v28;
      if (v13 <= *(float *)(v9 + 40 * *v28 + 16)) {
        return;
      }
LABEL_26:
      int v32 = v20;
      *uint64_t v12 = v20;
      *(_DWORD *)(v9 + 40 * v26 + 32) = v3;
      *int v24 = v10;
      *(_DWORD *)(v8 + 4 * v3) = v25;
      int v22 = 2 * v20;
      int v20 = (2 * v20) | 1;
      int v21 = *a2;
      int v3 = v32;
      if (v20 >= *a2) {
        return;
      }
    }
    float v30 = *(float *)(v9 + 40 * v29 + 20);
    if (v30 > v27 || v30 == v27 && *(float *)(v9 + 40 * v29 + 16) > *(float *)(v9 + 40 * v26 + 16)) {
      goto LABEL_26;
    }
LABEL_23:
    int v20 = v23;
    int v26 = *v28;
    int v24 = (int *)(v8 + 4 * v23);
    int v25 = *v28;
    goto LABEL_26;
  }
}

__n128 SweepEvent::Relocate(__n128 *a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v4 = a1[2].n128_i32[0];
  if (*(_DWORD *)(v3 + 4 * v4) != a3)
  {
    uint64_t v5 = *(void *)(a2 + 16) + 40 * a3;
    __n128 result = a1[1];
    *(__n128 *)uint64_t v5 = *a1;
    *(__n128 *)(v5 + 16) = result;
    unint64_t v7 = a1->n128_u64[1];
    *(void *)(a1->n128_u64[0] + 56) = v5;
    *(void *)(v7 + 48) = v5;
    *(_DWORD *)(v5 + 32) = v4;
    *(_DWORD *)(v3 + 4 * a1[2].n128_i32[0]) = a3;
  }
  return result;
}

BOOL SweepEvent::PeekInQueue(void *a1, void *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, uint64_t a7)
{
  int v7 = *(_DWORD *)a7;
  if (*(int *)a7 >= 1)
  {
    *a1 = *(void *)(*(void *)(a7 + 16) + 40 * **(int **)(a7 + 8));
    *a2 = *(void *)(*(void *)(a7 + 16) + 40 * **(int **)(a7 + 8) + 8);
    uint64_t v8 = (_DWORD *)(*(void *)(a7 + 16) + 40 * **(int **)(a7 + 8));
    *a3 = v8[4];
    *a4 = v8[5];
    *a5 = v8[6];
    *a6 = v8[7];
  }
  return v7 > 0;
}

BOOL SweepEvent::ExtractFromQueue(void *a1, void *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, uint64_t a7)
{
  int v7 = *(_DWORD *)a7;
  if (*(int *)a7 >= 1)
  {
    *a1 = *(void *)(*(void *)(a7 + 16) + 40 * **(int **)(a7 + 8));
    *a2 = *(void *)(*(void *)(a7 + 16) + 40 * **(int **)(a7 + 8) + 8);
    uint64_t v8 = (_DWORD *)(*(void *)(a7 + 16) + 40 * **(int **)(a7 + 8));
    *a3 = v8[4];
    *a4 = v8[5];
    *a5 = v8[6];
    *a6 = v8[7];
    SweepEvent::SupprFromQueue((uint64_t)v8, (int *)a7);
  }
  return v7 > 0;
}

void SweepTree::SweepTree(SweepTree *this)
{
  AVLTree::AVLTree(this);
  *(_DWORD *)(v1 + 72) = -1;
  *(_DWORD *)(v1 + 80) = -1;
  *(void *)(v1 + 56) = 0;
  *(void *)(v1 + 64) = 0;
  *(void *)(v1 + 48) = 0;
  *(unsigned char *)(v1 + 76) = 1;
}

{
  uint64_t v1;

  AVLTree::AVLTree(this);
  *(_DWORD *)(v1 + 72) = -1;
  *(_DWORD *)(v1 + 80) = -1;
  *(void *)(v1 + 56) = 0;
  *(void *)(v1 + 64) = 0;
  *(void *)(v1 + 48) = 0;
  *(unsigned char *)(v1 + 76) = 1;
}

void SweepTree::~SweepTree(SweepTree *this)
{
  uint64_t v2 = *((void *)this + 6);
  if (v2) {
    *(void *)(v2 + 8) = 0;
  }
  uint64_t v3 = (void *)*((void *)this + 7);
  if (v3) {
    *uint64_t v3 = 0;
  }
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  AVLTree::MakeDelete(this);

  AVLTree::~AVLTree(this);
}

uint64_t SweepTree::MakeDelete(SweepTree *this)
{
  uint64_t v1 = *((void *)this + 6);
  if (v1) {
    *(void *)(v1 + 8) = 0;
  }
  uint64_t v2 = (void *)*((void *)this + 7);
  if (v2) {
    *uint64_t v2 = 0;
  }
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  return AVLTree::MakeDelete(this);
}

void *SweepTree::MakeNew(SweepTree *this, Shape *a2, int a3, int a4, int a5)
{
  __n128 result = AVLTree::MakeNew(this);
  *((void *)this + 7) = 0;
  *((void *)this + 8) = a2;
  *((_DWORD *)this + 18) = a3;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 20) = a5;
  uint64_t v11 = *((void *)a2 + 5) + 32 * a3;
  *((unsigned char *)this + 76) = (a4 >= 0) ^ (*(_DWORD *)(v11 + 8) >= *(_DWORD *)(v11 + 12));
  return result;
}

uint64_t SweepTree::ConvertTo(uint64_t this, Shape *a2, int a3, int a4, int a5)
{
  *(void *)(this + 56) = 0;
  *(void *)(this + 64) = a2;
  *(_DWORD *)(this + 72) = a3;
  *(void *)(this + 48) = 0;
  *(_DWORD *)(this + 80) = a5;
  uint64_t v5 = *((void *)a2 + 5) + 32 * a3;
  *(unsigned char *)(this + 76) = (a4 >= 0) ^ (*(_DWORD *)(v5 + 8) >= *(_DWORD *)(v5 + 12));
  return this;
}

void *SweepTree::CreateList(uint64_t a1, int a2)
{
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = a2;
  __n128 result = malloc_type_malloc(88 * a2, 0x1020040EB7F0E25uLL);
  *(void *)(a1 + 8) = result;
  *(void *)(a1 + 16) = 0;
  return result;
}

void SweepTree::DestroyList(void *a1)
{
  uint64_t v2 = (void *)a1[1];
  if (v2) {
    free(v2);
  }
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

uint64_t SweepTree::AddInList(uint64_t a1, int a2, int a3, int a4, int *a5)
{
  int v5 = *a5;
  if (*a5 >= a5[1]) {
    return 0;
  }
  *a5 = v5 + 1;
  uint64_t v11 = *((void *)a5 + 1) + 88 * v5;
  AVLTree::MakeNew((AVLTree *)v11);
  *(void *)(v11 + 56) = 0;
  *(void *)(v11 + 64) = a1;
  *(_DWORD *)(v11 + 72) = a2;
  *(void *)(v11 + 48) = 0;
  *(_DWORD *)(v11 + 80) = a4;
  uint64_t v12 = *(void *)(a1 + 40) + 32 * a2;
  *(unsigned char *)(v11 + 76) = (a3 >= 0) ^ (*(_DWORD *)(v12 + 8) >= *(_DWORD *)(v12 + 12));
  return *((void *)a5 + 1) + 88 * v5;
}

uint64_t SweepTree::Find(SweepTree *this, float a2, float a3, SweepTree *a4, SweepTree **a5, SweepTree **a6, int a7)
{
  double v7 = a2;
  double v8 = a3;
  do
  {
    while (1)
    {
      uint64_t v9 = this;
      int v10 = (void *)*((void *)this + 8);
      uint64_t v11 = *((int *)this + 18);
      uint64_t v12 = v10[5] + 32 * v11;
      int v13 = *(_DWORD *)(v12 + 8);
      uint64_t v14 = v10[11] + 48 * v13;
      uint64_t v15 = v10[7] + (v11 << 6);
      float v16 = *(float *)(v15 + 4);
      double v17 = *(float *)(v15 + 8);
      if (v13 <= *(_DWORD *)(v12 + 12)) {
        float v16 = -v16;
      }
      else {
        double v17 = -v17;
      }
      double v18 = v16;
      double v19 = (v8 - *(float *)(v14 + 40)) * v18 + v17 * (v7 - *(float *)(v14 + 36));
      if (fabs(v19) < 0.000001)
      {
        uint64_t v20 = *((void *)a4 + 8);
        uint64_t v21 = *((int *)a4 + 18);
        uint64_t v22 = *(void *)(v20 + 56) + (v21 << 6);
        float v23 = *(float *)(v22 + 4);
        double v24 = *(float *)(v22 + 8);
        if (*(_DWORD *)(*(void *)(v20 + 40) + 32 * v21 + 8) <= *(_DWORD *)(*(void *)(v20 + 40) + 32 * v21 + 12)) {
          float v23 = -v23;
        }
        else {
          double v24 = -v24;
        }
        double v25 = v23;
        double v19 = a7 ? v17 * v25 - v24 * v18 : v24 * v18 - v17 * v25;
        if (v19 == 0.0)
        {
          double v19 = v18 * v25 + v17 * v24;
          if (v19 == 0.0)
          {
            *a5 = this;
            *a6 = (SweepTree *)*((void *)this + 1);
            return 1;
          }
        }
      }
      if (v19 >= 0.0) {
        break;
      }
      this = (SweepTree *)*((void *)this + 3);
      if (!this)
      {
        *a6 = v9;
        BOOL v28 = *(SweepTree **)v9;
        *a5 = v28;
        if (v28) {
          return 4;
        }
        else {
          return 2;
        }
      }
    }
    this = (SweepTree *)*((void *)this + 4);
  }
  while (this);
  *a5 = v9;
  int v26 = (SweepTree *)*((void *)v9 + 1);
  *a6 = v26;
  if (v26) {
    return 4;
  }
  else {
    return 3;
  }
}

uint64_t SweepTree::Find(SweepTree *this, float a2, float a3, SweepTree **a4, SweepTree **a5)
{
  double v5 = a2;
  double v6 = a3;
  do
  {
    while (1)
    {
      double v7 = this;
      double v8 = (void *)*((void *)this + 8);
      uint64_t v9 = *((int *)this + 18);
      uint64_t v10 = v8[5] + 32 * v9;
      int v11 = *(_DWORD *)(v10 + 8);
      uint64_t v12 = v8[11] + 48 * v11;
      uint64_t v13 = v8[7] + (v9 << 6);
      float v14 = *(float *)(v13 + 4);
      double v15 = *(float *)(v13 + 8);
      if (v11 <= *(_DWORD *)(v10 + 12)) {
        float v14 = -v14;
      }
      else {
        double v15 = -v15;
      }
      double v16 = (v6 - *(float *)(v12 + 40)) * v14 + v15 * (v5 - *(float *)(v12 + 36));
      if (fabs(v16) < 0.000001)
      {
        *a4 = this;
        *a5 = (SweepTree *)*((void *)this + 1);
        return 1;
      }
      if (v16 >= 0.0) {
        break;
      }
      this = (SweepTree *)*((void *)this + 3);
      if (!this)
      {
        *a5 = v7;
        double v19 = *(SweepTree **)v7;
        *a4 = *(SweepTree **)v7;
        if (v19) {
          return 4;
        }
        else {
          return 2;
        }
      }
    }
    this = (SweepTree *)*((void *)this + 4);
  }
  while (this);
  *a4 = v7;
  double v17 = (SweepTree *)*((void *)v7 + 1);
  *a5 = v17;
  if (v17) {
    return 4;
  }
  else {
    return 3;
  }
}

void SweepTree::RemoveEvents(uint64_t a1, int *a2)
{
  uint64_t v4 = *(void *)(a1 + 48);
  if (v4) {
    SweepEvent::SupprFromQueue(v4, a2);
  }
  *(void *)(a1 + 48) = 0;
  uint64_t v5 = *(void *)(a1 + 56);
  if (v5) {
    SweepEvent::SupprFromQueue(v5, a2);
  }
  *(void *)(a1 + 56) = 0;
}

void SweepTree::RemoveEvent(uint64_t a1, int *a2, int a3)
{
  if (a3)
  {
    uint64_t v4 = (void *)(a1 + 48);
    uint64_t v3 = *(void *)(a1 + 48);
    if (!v3) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  uint64_t v4 = (void *)(a1 + 56);
  uint64_t v3 = *(void *)(a1 + 56);
  if (v3) {
LABEL_5:
  }
    SweepEvent::SupprFromQueue(v3, a2);
LABEL_6:
  void *v4 = 0;
}

uint64_t SweepTree::Remove(AVLTree *a1, uint64_t a2, int *a3, int a4)
{
  SweepTree::RemoveEvents((uint64_t)a1, a3);
  uint64_t v13 = *(AVLTree **)(a2 + 16);
  uint64_t v7 = AVLTree::Remove(a1, &v13, a4);
  *(void *)(a2 + 16) = v13;
  uint64_t v8 = *((void *)a1 + 6);
  if (v8) {
    *(void *)(v8 + 8) = 0;
  }
  uint64_t v9 = (void *)*((void *)a1 + 7);
  if (v9) {
    *uint64_t v9 = 0;
  }
  *((void *)a1 + 6) = 0;
  *((void *)a1 + 7) = 0;
  AVLTree::MakeDelete(a1);
  unsigned int v10 = *(_DWORD *)a2 - 1;
  if (*(int *)a2 > 1)
  {
    int v11 = (uint64_t *)(*(void *)(a2 + 8) + 88 * v10);
    if (*(uint64_t **)(a2 + 16) == v11) {
      *(void *)(a2 + 16) = a1;
    }
    *(_DWORD *)a2 = v10;
    SweepTree::Relocate(v11, a1);
  }
  else
  {
    *(_DWORD *)a2 = 0;
    *(void *)(a2 + 16) = 0;
  }
  return v7;
}

uint64_t *SweepTree::Relocate(uint64_t *this, SweepTree *a2)
{
  if (this != (uint64_t *)a2)
  {
    uint64_t v3 = this;
    this = AVLTree::Relocate((AVLTree *)this, a2);
    *((void *)a2 + 8) = v3[8];
    *((_DWORD *)a2 + 18) = *((_DWORD *)v3 + 18);
    *((unsigned char *)a2 + 76) = *((unsigned char *)v3 + 76);
    *((_OWORD *)a2 + 3) = *((_OWORD *)v3 + 3);
    *((_DWORD *)a2 + 20) = *((_DWORD *)v3 + 20);
    uint64_t v4 = v3[8];
    uint64_t v5 = *(void *)(v4 + 64);
    if (v5) {
      *(void *)(v5 + 56 * *((int *)v3 + 18)) = a2;
    }
    uint64_t v6 = *(void *)(v4 + 80);
    if (v6) {
      *(void *)(v6 + 48 * *((int *)v3 + 18)) = a2;
    }
    uint64_t v7 = v3[6];
    if (v7) {
      *(void *)(v7 + 8) = a2;
    }
    uint64_t v8 = (void *)v3[7];
    if (v8) {
      *uint64_t v8 = a2;
    }
  }
  return this;
}

SweepTree *SweepTree::Insert(SweepTree *a1, uint64_t a2, int *a3, uint64_t a4, int a5, int a6, int a7)
{
  __n128 result = *(SweepTree **)(a2 + 16);
  if (!result)
  {
    *(void *)(a2 + 16) = a1;
    return result;
  }
  double v24 = 0;
  double v25 = 0;
  uint64_t v12 = (float *)(*(void *)(a4 + 24) + 28 * a5);
  int v13 = SweepTree::Find(result, *v12, v12[1], a1, &v25, &v24, a7);
  int v14 = v13;
  if ((v13 & 6) != 2)
  {
    if (v13 == 4)
    {
      double v18 = v24;
      uint64_t v19 = *((void *)v24 + 6);
      if (v19) {
        SweepEvent::SupprFromQueue(v19, a3);
      }
      *((void *)v18 + 6) = 0;
      double v17 = v25;
    }
    else
    {
      if (v13 != 1) {
        goto LABEL_18;
      }
      double v15 = v24;
      if (v24)
      {
        uint64_t v16 = *((void *)v24 + 6);
        if (v16) {
          SweepEvent::SupprFromQueue(v16, a3);
        }
        *((void *)v15 + 6) = 0;
      }
      double v17 = v25;
      if (!v25) {
        goto LABEL_18;
      }
    }
    uint64_t v22 = *((void *)v17 + 7);
    uint64_t v21 = (void *)((char *)v17 + 56);
    uint64_t v20 = v22;
    if (v22) {
      SweepEvent::SupprFromQueue(v20, a3);
    }
    *uint64_t v21 = 0;
  }
LABEL_18:
  float v23 = *(AVLTree **)(a2 + 16);
  __n128 result = (SweepTree *)AVLTree::Insert(a1, &v23, v14, v25, v24, a6);
  *(void *)(a2 + 16) = v23;
  return result;
}

uint64_t SweepTree::InsertAt(AVLTree *this, uint64_t a2, int *a3, int a4, AVLTree **a5, int a6, int a7, int a8)
{
  unsigned int v10 = *(AVLTree **)(a2 + 16);
  if (v10)
  {
    uint64_t v12 = (AVLTree *)a5;
    uint64_t v14 = *((void *)this + 8);
    uint64_t v15 = *(void *)(v14 + 40);
    uint64_t v16 = v15 + 32 * *((int *)this + 18);
    double v17 = *(float *)(v16 + 4);
    double v18 = -*(float *)v16;
    if (*(_DWORD *)(v16 + 8) <= *(_DWORD *)(v16 + 12)) {
      double v18 = *(float *)v16;
    }
    else {
      double v17 = -v17;
    }
    double v19 = -v17;
    if (a8)
    {
      double v19 = v17;
      double v20 = v18;
    }
    else
    {
      double v20 = -v18;
    }
    uint64_t v21 = *((void *)a5[8] + 5) + 32 * *((int *)a5 + 18);
    double v22 = *(float *)v21;
    double v23 = *(float *)(v21 + 4);
    if (*(_DWORD *)(v21 + 8) <= *(_DWORD *)(v21 + 12)) {
      double v23 = -v23;
    }
    else {
      double v22 = -v22;
    }
    double v24 = v20 * v23 + v22 * v19;
    if (v24 == 0.0)
    {
      double v25 = a5[1];
LABEL_13:
      if (v25) {
        int v26 = 4;
      }
      else {
        int v26 = 3;
      }
      if (v25)
      {
        uint64_t v27 = *((void *)v25 + 6);
        if (v27) {
          SweepEvent::SupprFromQueue(v27, a3);
        }
        *((void *)v25 + 6) = 0;
        uint64_t v28 = *((void *)v12 + 7);
        if (v28) {
          SweepEvent::SupprFromQueue(v28, a3);
        }
        *((void *)v12 + 7) = 0;
        unsigned int v10 = *(AVLTree **)(a2 + 16);
      }
    }
    else
    {
      uint64_t v30 = *(void *)(v14 + 88) + 48 * a6;
      float v31 = *(float *)(v30 + 36);
      float v32 = *(float *)(v30 + 40);
      if (v24 > 0.0)
      {
        double v25 = a5[1];
        while (1)
        {
          float v33 = v12;
          uint64_t v34 = *((void *)v12 + 8);
          if (v34 == v14)
          {
            uint64_t v35 = *((int *)v12 + 18);
            uint64_t v40 = v15 + 32 * v35;
            if (*(_DWORD *)(v40 + 8) != a6 && *(_DWORD *)(v40 + 12) != a6) {
              goto LABEL_13;
            }
          }
          else
          {
            uint64_t v35 = *((int *)v12 + 18);
            uint64_t v36 = *(void *)(v34 + 40) + 32 * v35;
            int v38 = *(_DWORD *)(v36 + 8);
            int v37 = *(_DWORD *)(v36 + 12);
            uint64_t v39 = *(void *)(v34 + 88);
            if ((*(float *)(v39 + 48 * v38 + 36) != v31 || *(float *)(v39 + 48 * v38 + 40) != v32)
              && (*(float *)(v39 + 48 * v37 + 36) != v31 || *(float *)(v39 + 48 * v37 + 40) != v32))
            {
              goto LABEL_13;
            }
          }
          uint64_t v41 = *(void *)(v34 + 40) + 32 * v35;
          double v42 = *(float *)v41;
          double v43 = *(float *)(v41 + 4);
          if (*(_DWORD *)(v41 + 8) <= *(_DWORD *)(v41 + 12)) {
            double v43 = -v43;
          }
          else {
            double v42 = -v42;
          }
          if (v20 * v43 + v42 * v19 <= 0.0) {
            goto LABEL_13;
          }
          uint64_t v12 = *(AVLTree **)v12;
          double v25 = v33;
          if (!*(void *)v33) {
            goto LABEL_58;
          }
        }
      }
      if (v24 >= 0.0)
      {
        uint64_t v12 = 0;
      }
      else
      {
        double v25 = (AVLTree *)a5;
        while (1)
        {
          uint64_t v12 = v25;
          double v25 = (AVLTree *)*((void *)v25 + 1);
          if (!v25) {
            break;
          }
          uint64_t v44 = *((void *)v25 + 8);
          if (v44 == v14)
          {
            uint64_t v45 = *((int *)v25 + 18);
            uint64_t v50 = v15 + 32 * v45;
            if (*(_DWORD *)(v50 + 8) != a6 && *(_DWORD *)(v50 + 12) != a6) {
              goto LABEL_13;
            }
          }
          else
          {
            uint64_t v45 = *((int *)v25 + 18);
            uint64_t v46 = *(void *)(v44 + 40) + 32 * v45;
            int v48 = *(_DWORD *)(v46 + 8);
            int v47 = *(_DWORD *)(v46 + 12);
            uint64_t v49 = *(void *)(v44 + 88);
            if ((*(float *)(v49 + 48 * v48 + 36) != v31 || *(float *)(v49 + 48 * v48 + 40) != v32)
              && (*(float *)(v49 + 48 * v47 + 36) != v31 || *(float *)(v49 + 48 * v47 + 40) != v32))
            {
              goto LABEL_13;
            }
          }
          uint64_t v51 = *(void *)(v44 + 40) + 32 * v45;
          double v52 = *(float *)v51;
          double v53 = *(float *)(v51 + 4);
          if (*(_DWORD *)(v51 + 8) <= *(_DWORD *)(v51 + 12)) {
            double v53 = -v53;
          }
          else {
            double v52 = -v52;
          }
          if (v20 * v53 + v52 * v19 > 0.0) {
            goto LABEL_13;
          }
        }
      }
      float v33 = 0;
LABEL_58:
      if (v12) {
        int v54 = 4;
      }
      else {
        int v54 = 2;
      }
      if (v33) {
        int v26 = v54;
      }
      else {
        int v26 = 3;
      }
      double v25 = v33;
    }
    signed int v55 = v10;
    uint64_t result = AVLTree::Insert(this, &v55, v26, v12, v25, a7);
    *(void *)(a2 + 16) = v55;
  }
  else
  {
    uint64_t result = 0;
    *(void *)(a2 + 16) = this;
  }
  return result;
}

uint64_t SweepTree::SwapWithRight(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 64);
  int v3 = *(_DWORD *)(result + 72);
  *(void *)(*(void *)(v2 + 64) + 56 * v3) = v1;
  uint64_t v4 = *(void *)(v1 + 64);
  int v5 = *(_DWORD *)(v1 + 72);
  *(void *)(*(void *)(v4 + 64) + 56 * v5) = result;
  *(void *)(result + 64) = v4;
  *(void *)(v1 + 64) = v2;
  *(_DWORD *)(result + 72) = v5;
  *(_DWORD *)(v1 + 72) = v3;
  LODWORD(v2) = *(_DWORD *)(result + 80);
  *(_DWORD *)(result + 80) = *(_DWORD *)(v1 + 80);
  *(_DWORD *)(v1 + 80) = v2;
  LOBYTE(v2) = *(unsigned char *)(result + 76);
  *(unsigned char *)(result + 76) = *(unsigned char *)(v1 + 76);
  *(unsigned char *)(v1 + 76) = v2;
  return result;
}

void sub_223637228(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22363733C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2236374C0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22363772C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_223637938(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_2236387E8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_223639DC4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_223639E94(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_223639F64(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

__CFString *TSDImageStylePackageString()
{
  return @"image";
}

uint64_t TSDImageStyleIdentifierString(uint64_t a1)
{
  return String(@"image", a1, @"imageStyle");
}

__CFString *TSDMovieStylePackageString()
{
  return @"movie";
}

uint64_t TSDMovieStyleIdentifierString(uint64_t a1)
{
  return String(@"movie", a1, @"movieStyle");
}

void sub_22363E73C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22363EA9C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22363ECA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void TSDColorFill_DrawClearColorRepresentation(CGContext *a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5)
{
  if (!CGRectIsNull(*(CGRect *)&a2))
  {
    CGContextSaveGState(a1);
    CGContextSetFillColorWithColor(a1, (CGColorRef)objc_msgSend((id)objc_msgSend(MEMORY[0x263F7C808], "whiteColor"), "CGColor"));
    v16.origin.double x = a2;
    v16.origin.double y = a3;
    v16.size.double width = a4;
    v16.size.double height = a5;
    CGContextFillRect(a1, v16);
    CGContextSetLineWidth(a1, 1.0);
    CGContextSetStrokeColorWithColor(a1, (CGColorRef)objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x263F7C808], "redColor"), "colorWithAlphaComponent:", 0.38), "CGColor"));
    Mutable = CGPathCreateMutable();
    v17.origin.double x = a2;
    v17.origin.double y = a3;
    v17.size.double width = a4;
    v17.size.double height = a5;
    CGFloat MinX = CGRectGetMinX(v17);
    v18.origin.double x = a2;
    v18.origin.double y = a3;
    v18.size.double width = a4;
    v18.size.double height = a5;
    CGFloat MaxY = CGRectGetMaxY(v18);
    CGPathMoveToPoint(Mutable, 0, MinX, MaxY);
    v19.origin.double x = a2;
    v19.origin.double y = a3;
    v19.size.double width = a4;
    v19.size.double height = a5;
    CGFloat MaxX = CGRectGetMaxX(v19);
    v20.origin.double x = a2;
    v20.origin.double y = a3;
    v20.size.double width = a4;
    v20.size.double height = a5;
    CGFloat MinY = CGRectGetMinY(v20);
    CGPathAddLineToPoint(Mutable, 0, MaxX, MinY);
    CGContextAddPath(a1, Mutable);
    CGContextStrokePath(a1);
    CGPathRelease(Mutable);
    CGContextRestoreGState(a1);
  }
}

void sub_2236439DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_2236466B4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2236467E4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_223646CA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_223646EF0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22364709C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_223647294(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2236473E4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_223647490(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2236477AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_2236479E0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_223647EDC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_223648160(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t TSDTextInputResponderClass()
{
  TSUSupportsTextInteraction();

  return objc_opt_class();
}

__CFString *UI_GRANULARITY_NAME(unint64_t a1)
{
  if (a1 >= 6) {
    return (__CFString *)objc_msgSend(NSString, "stringWithFormat:", @"unknown granularity: %ld", a1);
  }
  else {
    return off_2646B1BE8[a1];
  }
}

__CFString *UI_DIRECTION_NAME(unint64_t a1)
{
  if (a1 >= 6) {
    return (__CFString *)objc_msgSend(NSString, "stringWithFormat:", @"unknown direction: %ld", a1);
  }
  else {
    return off_2646B1C18[a1];
  }
}

__CFString *BOOL_NAME(int a1)
{
  if (a1) {
    return @"YES";
  }
  else {
    return @"NO";
  }
}

void sub_22364AAE0(_Unwind_Exception *a1)
{
}

void sub_22364AB2C(void *a1)
{
}

void sub_22364AC8C()
{
}

void sub_22364ACDC()
{
}

void sub_22364AD3C()
{
}

void sub_22364AD8C()
{
}

void sub_22364B10C()
{
}

void sub_22364B16C()
{
}

void sub_22364C3B0()
{
}

void sub_22364C42C(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x22364C40CLL);
  }
  JUMPOUT(0x22364C3D8);
}

uint64_t p_reflectionMask(void)
{
  uint64_t result = s_reflectionMaskImageRef;
  if (!s_reflectionMaskImageRef)
  {
    uint64_t v1 = (char *)malloc_type_calloc(4uLL, 0x40uLL, 0xA21791E2uLL);
    DeviceRGB = CGColorSpaceCreateDeviceRGB();
    int v3 = CGBitmapContextCreate(v1, 1uLL, 0x40uLL, 8uLL, 4uLL, DeviceRGB, 2u);
    CGColorSpaceRelease(DeviceRGB);
    uint64_t v4 = 0;
    int32x4_t v5 = (int32x4_t)xmmword_22383A320;
    int32x4_t v6 = (int32x4_t)xmmword_22383A330;
    int32x4_t v7 = (int32x4_t)xmmword_22383A340;
    int32x4_t v8 = (int32x4_t)xmmword_22383A350;
    float64x2_t v30 = (float64x2_t)vdupq_n_s64(0x404F800000000000uLL);
    float64x2_t v29 = (float64x2_t)vdupq_n_s64(0x406FFFF7CED91687uLL);
    do
    {
      int32x4_t v47 = v8;
      int32x4_t v48 = v6;
      int32x4_t v49 = v7;
      int32x4_t v50 = v5;
      v9.i64[0] = v8.i32[2];
      v9.i64[1] = v8.i32[3];
      float64x2_t v10 = vcvtq_f64_s64(v9);
      v9.i64[0] = v8.i32[0];
      v9.i64[1] = v8.i32[1];
      float64x2_t v11 = vcvtq_f64_s64(v9);
      v9.i64[0] = v49.i32[2];
      v9.i64[1] = v49.i32[3];
      float64x2_t v12 = vcvtq_f64_s64(v9);
      int32x4_t v13 = v5;
      v9.i64[0] = v49.i32[0];
      v9.i64[1] = v49.i32[1];
      float64x2_t v14 = vcvtq_f64_s64(v9);
      v9.i64[0] = v6.i32[2];
      v9.i64[1] = v6.i32[3];
      float64x2_t v15 = vcvtq_f64_s64(v9);
      v9.i64[0] = v6.i32[0];
      v9.i64[1] = v6.i32[1];
      float64x2_t v16 = vcvtq_f64_s64(v9);
      v9.i64[0] = v13.i32[2];
      v9.i64[1] = v13.i32[3];
      float64x2_t v17 = vcvtq_f64_s64(v9);
      v9.i64[0] = v13.i32[0];
      v9.i64[1] = v13.i32[1];
      float64x2_t v46 = vdivq_f64(vcvtq_f64_s64(v9), v30);
      float64x2_t v42 = vdivq_f64(v16, v30);
      float64x2_t v44 = vdivq_f64(v17, v30);
      float64x2_t v38 = vdivq_f64(v14, v30);
      float64x2_t v40 = vdivq_f64(v15, v30);
      float64x2_t v34 = vdivq_f64(v11, v30);
      float64x2_t v36 = vdivq_f64(v12, v30);
      float64x2_t __x = vdivq_f64(v10, v30);
      long double v32 = pow(__x.f64[1], 1.8);
      v18.f64[0] = pow(__x.f64[0], 1.8);
      v18.f64[1] = v32;
      float64x2_t v33 = v18;
      __x.f64[0] = pow(v34.f64[1], 1.8);
      v19.f64[0] = pow(v34.f64[0], 1.8);
      v19.f64[1] = __x.f64[0];
      float64x2_t v35 = v19;
      __x.f64[0] = pow(v36.f64[1], 1.8);
      v20.f64[0] = pow(v36.f64[0], 1.8);
      v20.f64[1] = __x.f64[0];
      float64x2_t v37 = v20;
      __x.f64[0] = pow(v38.f64[1], 1.8);
      v21.f64[0] = pow(v38.f64[0], 1.8);
      v21.f64[1] = __x.f64[0];
      float64x2_t v39 = v21;
      __x.f64[0] = pow(v40.f64[1], 1.8);
      v22.f64[0] = pow(v40.f64[0], 1.8);
      v22.f64[1] = __x.f64[0];
      float64x2_t v41 = v22;
      __x.f64[0] = pow(v42.f64[1], 1.8);
      v23.f64[0] = pow(v42.f64[0], 1.8);
      v23.f64[1] = __x.f64[0];
      float64x2_t v43 = v23;
      __x.f64[0] = pow(v44.f64[1], 1.8);
      v24.f64[0] = pow(v44.f64[0], 1.8);
      v24.f64[1] = __x.f64[0];
      float64x2_t v45 = v24;
      __x.f64[0] = pow(v46.f64[1], 1.8);
      v25.f64[0] = pow(v46.f64[0], 1.8);
      v25.f64[1] = __x.f64[0];
      *(int16x4_t *)v26.i8 = vuzp1_s16((int16x4_t)vmovn_s64(vcvtq_s64_f64(vmulq_f64(v35, v29))), (int16x4_t)vmovn_s64(vcvtq_s64_f64(vmulq_f64(v33, v29))));
      v26.u64[1] = (unint64_t)vuzp1_s16((int16x4_t)vmovn_s64(vcvtq_s64_f64(vmulq_f64(v39, v29))), (int16x4_t)vmovn_s64(vcvtq_s64_f64(vmulq_f64(v37, v29))));
      *(int16x4_t *)v27.i8 = vuzp1_s16((int16x4_t)vmovn_s64(vcvtq_s64_f64(vmulq_f64(v43, v29))), (int16x4_t)vmovn_s64(vcvtq_s64_f64(vmulq_f64(v41, v29))));
      v27.u64[1] = (unint64_t)vuzp1_s16((int16x4_t)vmovn_s64(vcvtq_s64_f64(vmulq_f64(v25, v29))), (int16x4_t)vmovn_s64(vcvtq_s64_f64(vmulq_f64(v45, v29))));
      v51.val[0] = vuzp1q_s8(v26, v27);
      v51.val[1] = v51.val[0];
      v51.val[2] = v51.val[0];
      v51.val[3] = v51.val[0];
      uint64_t v28 = &v1[v4];
      vst4q_s8(v28, v51);
      v51.val[2].i64[0] = 0x1000000010;
      v51.val[2].i64[1] = 0x1000000010;
      int32x4_t v8 = vaddq_s32(v47, (int32x4_t)v51.val[2]);
      int32x4_t v7 = vaddq_s32(v49, (int32x4_t)v51.val[2]);
      int32x4_t v6 = vaddq_s32(v48, (int32x4_t)v51.val[2]);
      int32x4_t v5 = vaddq_s32(v50, (int32x4_t)v51.val[2]);
      v4 += 64;
    }
    while (v4 != 256);
    s_reflectionMaskImageRef = (uint64_t)CGBitmapContextCreateImage(v3);
    CGContextRelease(v3);
    return s_reflectionMaskImageRef;
  }
  return result;
}

__CFString *TSDStringFromTextureType(int a1)
{
  switch(a1)
  {
    case 0:
      uint64_t result = @"unknown";
      break;
    case 1:
      uint64_t result = @"background";
      break;
    case 2:
      uint64_t result = @"shadow";
      break;
    case 3:
      uint64_t result = @"contact shadow";
      break;
    case 4:
      uint64_t result = @"grouped shadow";
      break;
    case 5:
      uint64_t result = @"object";
      break;
    case 6:
      uint64_t result = @"text";
      break;
    case 7:
      uint64_t result = @"parameterizedStroke";
      break;
    case 8:
      uint64_t result = @"stroke";
      break;
    case 9:
      uint64_t result = @"reflection";
      break;
    case 10:
      uint64_t v2 = [MEMORY[0x263F7C7F0] currentHandler];
      int v3 = [NSString stringWithUTF8String:"NSString * _Nonnull TSDStringFromTextureType(TSDTextureType)"];
      uint64_t v4 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDTexturedRectangle.m"];
      [v2 handleFailureInFunction:v3 file:v4 lineNumber:57 description:@"Invalid texture type"];

      uint64_t result = @"ERROR";
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

void sub_2236577F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  objc_sync_exit(v18);
  _Unwind_Resume(a1);
}

void *TSDTopmostInfoFromInfo(void *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = [a1 parentInfo];
  if (v2)
  {
    for (char i = (void *)v2; ([i conformsToProtocol:&unk_26D7EEDD0] & 1) == 0; char i = (void *)v4)
    {
      uint64_t v1 = i;
      uint64_t v4 = [i parentInfo];
      if (!v4) {
        break;
      }
    }
  }
  return v1;
}

uint64_t TSDTopmostOwningAttachmentFromInfo(void *a1)
{
  uint64_t v2 = [a1 owningAttachment];
  uint64_t v3 = [a1 parentInfo];
  if (v3)
  {
    uint64_t v4 = (void *)v3;
    do
    {
      if ([v4 conformsToProtocol:&unk_26D7EEDD0]) {
        break;
      }
      if ([v4 owningAttachment]) {
        uint64_t v2 = [v4 owningAttachment];
      }
      uint64_t v4 = (void *)[v4 parentInfo];
    }
    while (v4);
  }
  return v2;
}

void p_calculateDerivedValuesFromFrameSpecAndAssetScale(void *a1, double *a2, double *a3, double *a4, double *a5, uint64_t a6, double a7)
{
  double v14 = 0.0;
  double v15 = 0.0;
  double v16 = 0.0;
  double v17 = 0.0;
  if (objc_msgSend(a1, "i_hasImages"))
  {
    objc_msgSend(a1, "i_leftWidth");
    *(float *)&double v18 = v18 * a7;
    double v17 = ceilf(*(float *)&v18);
    objc_msgSend(a1, "i_rightWidth");
    *(float *)&double v19 = v19 * a7;
    double v16 = ceilf(*(float *)&v19);
    objc_msgSend(a1, "i_topHeight");
    *(float *)&double v20 = v20 * a7;
    double v15 = ceilf(*(float *)&v20);
    objc_msgSend(a1, "i_bottomHeight");
    *(float *)&double v21 = v21 * a7;
    double v14 = ceilf(*(float *)&v21);
  }
  if (!objc_msgSend(a1, "i_hasAdornment"))
  {
    double v24 = *MEMORY[0x263F001B0];
    uint64_t v25 = *(void *)(MEMORY[0x263F001B0] + 8);
    if (!a2) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  objc_msgSend(a1, "i_adornmentSize");
  double v24 = TSDMultiplySizeScalar(v22, v23, a7);
  if (a2) {
LABEL_7:
  }
    *a2 = v17;
LABEL_8:
  if (a3) {
    *a3 = v16;
  }
  if (a4) {
    *a4 = v15;
  }
  if (a5) {
    *a5 = v14;
  }
  if (a6)
  {
    *(double *)a6 = v24;
    *(void *)(a6 + 8) = v25;
  }
}

void sub_223667A50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  _Block_object_dispose(&a29, 8);
  _Block_object_dispose(&a35, 8);
  _Block_object_dispose((const void *)(v35 - 160), 8);
  _Unwind_Resume(a1);
}

void sub_223668570(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22366A21C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__14(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__14(uint64_t a1)
{
}

uint64_t TSDMaxSingleTileDimension()
{
  id v0 = +[TSDCapabilities currentCapabilities];

  return [v0 maximumTextureSize];
}

double TSDDefaultTileDimension()
{
  objc_msgSend(+[TSDCapabilities currentCapabilities](TSDCapabilities, "currentCapabilities"), "maximumTextureSize");
  *(float *)&double v0 = v0 * 0.25;
  return fmaxf(*(float *)&v0, 640.0);
}

void sub_223671F6C(void *a1)
{
  objc_begin_catch(a1);
  *(unsigned char *)(v1 + 120) = 0;
  objc_exception_rethrow();
}

void sub_223671F84(_Unwind_Exception *a1)
{
}

uint64_t TSDMetalMotionBlurEffect_WriteRGBATexture2DToPNG()
{
  return 0;
}

void sub_2236768C0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_223676B14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id obj)
{
}

void sub_223676FD8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_223677228(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2236773B0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22367752C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t do_line_segments_intersect(float *a1, float *a2, float *a3, float *a4)
{
  float v4 = a1[1];
  double v5 = (float)(*a2 - *a1);
  double v6 = (float)(a2[1] - v4);
  float v7 = a3[1];
  double v8 = (float)(*a3 - *a4);
  double v9 = (float)(v7 - a4[1]);
  double v10 = (float)(*a1 - *a3);
  double v11 = (float)(v4 - v7);
  double v12 = v6 * v8 - v5 * v9;
  double v13 = v9 * v10 - v8 * v11;
  if (v12 > 0.0 && (v13 >= 0.0 ? (BOOL v14 = v13 > v12) : (BOOL v14 = 1), !v14)
    || v12 < 0.0 && (v13 <= 0.0 ? (BOOL v15 = v13 < v12) : (BOOL v15 = 1), !v15))
  {
    double v16 = v5 * v11 - v6 * v10;
    if (v12 > 0.0)
    {
      if (v16 > 0.0 && v16 < v12) {
        return 1;
      }
    }
    else if (v16 < 0.0 && v16 > v12)
    {
      return 1;
    }
  }
  return 0;
}

BOOL get_line_segment_intersection(const CGPoint *a1, const CGPoint *a2, const CGPoint *a3, const CGPoint *a4, CGPoint *a5)
{
  double x = a1->x;
  double y = a1->y;
  double v10 = TSDSubtractPoints(a2->x, a2->y, a1->x);
  double v12 = v11;
  double v13 = a3->x;
  double v14 = a3->y;
  double v15 = TSDSubtractPoints(a4->x, a4->y, a3->x);
  double v17 = v10 * v16 - v15 * v12;
  double v18 = (v10 * (y - v14) - v12 * (x - v13)) / v17;
  double v19 = (v15 * (y - v14) - v16 * (x - v13)) / v17;
  BOOL v20 = v18 >= 0.0;
  if (v18 > 1.0) {
    BOOL v20 = 0;
  }
  if (v19 < 0.0) {
    BOOL v20 = 0;
  }
  BOOL result = v19 <= 1.0 && v20;
  if (a5)
  {
    if (result)
    {
      a5->double x = x + v19 * v10;
      a5->double y = y + v19 * v12;
    }
  }
  return result;
}

BOOL is_point_in_triangle(float *a1, float *a2)
{
  float v3 = a2[2];
  float v2 = a2[3];
  float v4 = a2[1];
  double v5 = *a1;
  double v6 = a1[1];
  double v7 = -((float)-(float)(v3 - *a2) * v4)
     - (float)(v2 - v4) * *a2
     + (float)-(float)(v3 - *a2) * v6
     + (float)(v2 - v4) * v5;
  float v9 = a2[4];
  float v8 = a2[5];
  return v7
       * (v6 * (float)-(float)(v9 - v3)
        + (float)(v8 - v2) * v5
        + -((float)-(float)(v9 - v3) * v2)
        - (float)(v8 - v2) * v3) > 0.0
      && v7
       * (v6 * (float)-(float)(*a2 - v9)
        + (float)(v4 - v8) * v5
        + -((float)-(float)(*a2 - v9) * v8)
        - (float)(v4 - v8) * v9) > 0.0;
}

BOOL do_triangles_intersect(float *a1, float *a2)
{
  uint64_t v4 = 0;
  while (2)
  {
    uint64_t v5 = v4;
    double v6 = &a1[2 * v4++];
    if (v4 == 3) {
      uint64_t v7 = 0;
    }
    else {
      uint64_t v7 = v5 + 1;
    }
    float v8 = &a1[2 * v7];
    uint64_t v9 = -3;
    double v10 = a2;
    while (v9)
    {
      uint64_t v11 = v9 + 4;
      if (__CFADD__(v9++, 1)) {
        uint64_t v11 = 0;
      }
      char v13 = do_line_segments_intersect(v6, v8, v10, &a2[2 * v11]);
      v10 += 2;
      if (v13) {
        return 1;
      }
    }
    if (v4 != 3) {
      continue;
    }
    break;
  }
  if (is_point_in_triangle(a1, a2)) {
    return 1;
  }

  return is_point_in_triangle(a2, a1);
}

BOOL clip_points_to_rect(CGPoint *a1, CGPoint *a2, const CGRect *a3)
{
  v27[8] = *MEMORY[0x263EF8340];
  double x = a3->origin.x;
  double y = a3->origin.y;
  double width = a3->size.width;
  double height = a3->size.height;
  if (!TSDPointInRectInclusive(a1->x, a1->y, a3->origin.x, y, width, height)
    || !(BOOL result = TSDPointInRectInclusive(a2->x, a2->y, x, y, width, height)))
  {
    v28.origin.double x = x;
    v28.origin.double y = y;
    v28.size.double width = width;
    v28.size.double height = height;
    CGFloat MinX = CGRectGetMinX(v28);
    CGRect v29 = *a3;
    *(CGFloat *)int8x16_t v27 = MinX;
    v27[1] = CGRectGetMinY(v29);
    CGFloat MaxX = CGRectGetMaxX(*a3);
    CGRect v30 = *a3;
    *(CGFloat *)&v27[2] = MaxX;
    v27[3] = CGRectGetMinY(v30);
    CGFloat v13 = CGRectGetMaxX(*a3);
    CGRect v31 = *a3;
    *(CGFloat *)&v27[4] = v13;
    v27[5] = CGRectGetMaxY(v31);
    CGFloat v14 = CGRectGetMinX(*a3);
    CGRect v32 = *a3;
    unint64_t v15 = 0;
    *(CGFloat *)&v27[6] = v14;
    v27[7] = CGRectGetMaxY(v32);
    double v16 = (CGPoint *)v27;
    while (1)
    {
      CGPoint v17 = *v16;
      CGPoint v24 = *(CGPoint *)&v27[2 * ((v15 + 1) & 3)];
      CGPoint v25 = v17;
      BOOL result = get_line_segment_intersection(a1, a2, &v25, &v24, &v26);
      if (result)
      {
        double v18 = a3->origin.x;
        double v19 = a3->origin.y;
        double v20 = a3->size.width;
        double v21 = a3->size.height;
        BOOL v22 = TSDPointInRectInclusive(a1->x, a1->y, a3->origin.x, v19, v20, v21);
        if (!v22)
        {
          *a1 = v26;
          double v18 = a3->origin.x;
          double v19 = a3->origin.y;
          double v20 = a3->size.width;
          double v21 = a3->size.height;
        }
        BOOL result = TSDPointInRectInclusive(a2->x, a2->y, v18, v19, v20, v21);
        if (!result)
        {
          *a2 = v26;
          return result;
        }
        BOOL v23 = !v22;
      }
      else
      {
        BOOL v23 = 0;
      }
      if (v15 <= 2)
      {
        ++v16;
        ++v15;
        if (!v23) {
          continue;
        }
      }
      return result;
    }
  }
  return result;
}

CGFloat segment_from_edge_clipped_to_rect@<D0>(uint64_t a1@<X0>, CGPoint *a2@<X8>, CGFloat a3@<D0>, CGFloat a4@<D1>, CGFloat a5@<D2>, CGFloat a6@<D3>)
{
  v12.origin.double x = a3;
  v12.origin.double y = a4;
  v12.size.double width = a5;
  v12.size.double height = a6;
  CGPoint v7 = *(CGPoint *)*(void *)(a1 + 8);
  CGPoint v10 = *(CGPoint *)*(void *)(*(void *)(a1 + 16) + 8);
  CGPoint v11 = v7;
  clip_points_to_rect(&v11, &v10, &v12);
  CGPoint v9 = v10;
  CGFloat result = v11.x;
  *a2 = v11;
  a2[1] = v9;
  return result;
}

double area_of_cell(double **a1)
{
  uint64_t v1 = *a1;
  float v2 = a1[1];
  double result = 0.0;
  if (*a1 != v2)
  {
    do
    {
      double result = result + (v1[2] - *v1) * ((v1[1] + v1[3]) * 0.5);
      v1 += 4;
    }
    while (v1 != v2);
  }
  return result;
}

void sub_22367AC04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_22367BC28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,void *__p,uint64_t a49,uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,char a62,uint64_t a63)
{
  a41 = &a38;
  std::vector<std::vector<boost::polygon::segment_data<double>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a41);
  a41 = &a45;
  std::vector<std::vector<boost::polygon::segment_data<double>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a41);
  if (__p)
  {
    a49 = (uint64_t)__p;
    operator delete(__p);
  }
  boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::~voronoi_diagram((uint64_t)&a51);
  std::__tree<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::__map_value_compare<std::pair<unsigned short,EQKit::Config::Operator::Form>,std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::less<std::pair<unsigned short,EQKit::Config::Operator::Form>>,true>,std::allocator<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>>>::destroy((uint64_t)&a62, (void *)a63);
  if (a65)
  {
    a66 = (uint64_t)a65;
    operator delete(a65);
  }
  _Unwind_Resume(a1);
}

void boost::polygon::construct_voronoi<std::__wrap_iter<boost::polygon::point_data<double> *>,std::__wrap_iter<boost::polygon::segment_data<double> *>,boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>(uint64_t a1, double *a2, double *a3, double *a4, void **a5)
{
  __p = 0;
  CGFloat v13 = 0;
  __int16 v15 = 0;
  uint64_t v14 = 0;
  *(_OWORD *)CGPoint v9 = 0u;
  long long v10 = 0u;
  memset(v11, 0, 25);
  v16[0] = v16;
  v16[1] = v16;
  v18[0] = 0;
  v18[1] = 0;
  __int16 v19 = 0;
  v16[2] = 0;
  CGPoint v17 = v18;
  uint64_t v20 = 0;
  boost::polygon::insert<std::__wrap_iter<boost::polygon::point_data<double> *>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>>(a1, a2, &v8);
  while (a3 != a4)
  {
    boost::polygon::insert<boost::polygon::segment_data<double>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>>(a3, &v8);
    a3 += 4;
  }
  boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::construct<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>(&v8, a5);
  std::__tree<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::__map_value_compare<std::pair<unsigned short,EQKit::Config::Operator::Form>,std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::less<std::pair<unsigned short,EQKit::Config::Operator::Form>>,true>,std::allocator<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>>>::destroy((uint64_t)&v17, v18[0]);
  std::__list_imp<EQKit::StemStretch::FeatureRange::Span>::clear(v16);
  if (__p)
  {
    CGFloat v13 = __p;
    operator delete(__p);
  }
  if (v11[0])
  {
    v11[1] = v11[0];
    operator delete(v11[0]);
  }
  if (v9[0])
  {
    v9[1] = v9[0];
    operator delete(v9[0]);
  }
}

void sub_22367BE6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *std::vector<boost::polygon::segment_data<double>>::insert(void *a1, uint64_t a2, void *a3)
{
  uint64_t v4 = (void *)a2;
  unint64_t v6 = a1[1];
  uint64_t v8 = (uint64_t)(a1 + 2);
  unint64_t v7 = a1[2];
  if (v6 >= v7)
  {
    CGPoint v9 = (void *)*a1;
    unint64_t v10 = ((uint64_t)(v6 - *a1) >> 5) + 1;
    if (v10 >> 59) {
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = a2 - (void)v9;
    uint64_t v12 = (a2 - (uint64_t)v9) >> 5;
    uint64_t v13 = v7 - (void)v9;
    if (v13 >> 4 > v10) {
      unint64_t v10 = v13 >> 4;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v14 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v10;
    }
    CGPoint v26 = a1 + 2;
    if (v14) {
      __int16 v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::segment_data<double>>>((uint64_t)(a1 + 2), v14);
    }
    else {
      __int16 v15 = 0;
    }
    double v16 = &v15[32 * v12];
    __p = v15;
    BOOL v23 = v16;
    CGPoint v24 = v16;
    CGPoint v25 = &v15[32 * v14];
    if (v12 == v14)
    {
      if (v11 < 1)
      {
        if (v9 == v4) {
          unint64_t v18 = 1;
        }
        else {
          unint64_t v18 = v11 >> 4;
        }
        __int16 v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::segment_data<double>>>(v8, v18);
        double v16 = &v19[32 * (v18 >> 2)];
        __p = v19;
        BOOL v23 = v16;
        CGPoint v25 = &v19[32 * v20];
        if (v15) {
          operator delete(v15);
        }
      }
      else
      {
        unint64_t v17 = v12 + 2;
        if (v12 >= -1) {
          unint64_t v17 = v12 + 1;
        }
        v16 -= 32 * (v17 >> 1);
        BOOL v23 = v16;
      }
    }
    *(_OWORD *)double v16 = 0u;
    *((_OWORD *)v16 + 1) = 0u;
    *(void *)double v16 = *a3;
    *((void *)v16 + 1) = a3[1];
    *((void *)v16 + 2) = a3[2];
    *((void *)v16 + 3) = a3[3];
    CGPoint v24 = v16 + 32;
    uint64_t v4 = std::vector<boost::polygon::segment_data<double>>::__swap_out_circular_buffer(a1, &__p, v4);
    if (v24 != v23) {
      v24 += (v23 - v24 + 31) & 0xFFFFFFFFFFFFFFE0;
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else if (a2 == v6)
  {
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    *(void *)a2 = *a3;
    *(void *)(a2 + 8) = a3[1];
    *(void *)(a2 + 16) = a3[2];
    *(void *)(a2 + 24) = a3[3];
    a1[1] = a2 + 32;
  }
  else
  {
    std::vector<boost::polygon::segment_data<double>>::__move_range((uint64_t)a1, a2, v6, a2 + 32);
    if (v4 <= a3) {
      a3 += 4 * (a1[1] > (unint64_t)a3);
    }
    void *v4 = *a3;
    v4[1] = a3[1];
    void v4[2] = a3[2];
    v4[3] = a3[3];
  }
  return v4;
}

void sub_22367C0BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::~voronoi_diagram(uint64_t a1)
{
  float v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
  float v3 = *(void **)(a1 + 24);
  if (v3)
  {
    *(void *)(a1 + 32) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v4;
    operator delete(v4);
  }
  return a1;
}

char *std::vector<boost::polygon::segment_data<double>>::__init_with_size[abi:ne180100]<boost::polygon::segment_data<double>*,boost::polygon::segment_data<double>*>(char *result, void *a2, void *a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    double result = std::vector<boost::polygon::segment_data<double>>::__vallocate[abi:ne180100](result, a4);
    for (uint64_t i = *((void *)v6 + 1); a2 != a3; a2 += 4)
    {
      *(_OWORD *)uint64_t i = 0uLL;
      *(_OWORD *)(i + 16) = 0uLL;
      *(void *)uint64_t i = *a2;
      *(void *)(i + 8) = a2[1];
      *(void *)(i + 16) = a2[2];
      *(void *)(i + 24) = a2[3];
      i += 32;
    }
    *((void *)v6 + 1) = i;
  }
  return result;
}

void sub_22367C508(_Unwind_Exception *exception_object)
{
  float v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<boost::polygon::segment_data<double>>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 59) {
    std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
  }
  double result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::segment_data<double>>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * v4];
  return result;
}

uint64_t *std::__tree<boost::polygon::point_data<double>>::__emplace_unique_key_args<boost::polygon::point_data<double>,boost::polygon::point_data<double> const&>(uint64_t **a1, double *a2, _OWORD *a3)
{
  uint64_t v5 = (void **)std::__tree<boost::polygon::point_data<double>>::__find_equal<boost::polygon::point_data<double>>((uint64_t)a1, &v9, a2);
  unint64_t v6 = (uint64_t *)*v5;
  if (!*v5)
  {
    unint64_t v7 = (uint64_t **)v5;
    unint64_t v6 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v6 + 2) = *a3;
    std::__tree<std::__value_type<std::string,unsigned short>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned short>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned short>>>::__insert_node_at(a1, v9, v7, v6);
  }
  return v6;
}

void *std::__tree<boost::polygon::point_data<double>>::__find_equal<boost::polygon::point_data<double>>(uint64_t a1, void *a2, double *a3)
{
  uint64_t v5 = *(uint64_t **)(a1 + 8);
  double result = (void *)(a1 + 8);
  uint64_t v4 = v5;
  if (v5)
  {
    double v6 = *a3;
    double v7 = a3[1];
    while (1)
    {
      while (1)
      {
        uint64_t v8 = v4;
        double v9 = *((double *)v4 + 4);
        if (v6 >= v9) {
          break;
        }
LABEL_6:
        uint64_t v4 = (uint64_t *)*v4;
        double result = v8;
        if (!*v8) {
          goto LABEL_18;
        }
      }
      if (v6 == v9)
      {
        double v10 = *((double *)v4 + 5);
        if (v7 < v10) {
          goto LABEL_6;
        }
        if (v9 >= v6 && v10 >= v7) {
          goto LABEL_18;
        }
      }
      else if (v9 >= v6)
      {
        goto LABEL_18;
      }
      double result = v4 + 1;
      uint64_t v4 = (uint64_t *)v4[1];
      if (!v4) {
        goto LABEL_18;
      }
    }
  }
  uint64_t v8 = result;
LABEL_18:
  *a2 = v8;
  return result;
}

double *std::__tree<boost::polygon::point_data<double>>::find<boost::polygon::point_data<double>>(uint64_t a1, double *a2)
{
  uint64_t v4 = *(double **)(a1 + 8);
  float v2 = (double *)(a1 + 8);
  float v3 = v4;
  if (!v4) {
    return v2;
  }
  double v6 = *a2;
  double v5 = a2[1];
  double v7 = v2;
  do
  {
    double v8 = v3[4];
    if (v8 >= v6)
    {
      if (v8 == v6)
      {
        if (v3[5] < v5) {
          ++v3;
        }
        else {
          double v7 = v3;
        }
      }
      else
      {
        double v7 = v3;
      }
    }
    else
    {
      ++v3;
    }
    float v3 = *(double **)v3;
  }
  while (v3);
  if (v7 == v2) {
    return v2;
  }
  double v9 = v7[4];
  if (v6 < v9 || v6 == v9 && v5 < v7[5]) {
    return v2;
  }
  return v7;
}

uint64_t boost::polygon::insert<std::__wrap_iter<boost::polygon::point_data<double> *>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>>(uint64_t result, double *a2, void *a3)
{
  if ((double *)result != a2)
  {
    uint64_t v12 = v3;
    uint64_t v13 = v4;
    double v7 = (double *)result;
    do
    {
      double v8 = *v7;
      double v9 = v7[1];
      v7 += 2;
      int v10 = (int)v9;
      int v11 = (int)v8;
      double result = boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::insert_point(a3, &v11, &v10);
    }
    while (v7 != a2);
  }
  return result;
}

void boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::construct<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>(uint64_t *a1, void **a2)
{
  boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::_reserve(a2, -858993459 * ((unint64_t)(a1[2] - a1[1]) >> 3));
  boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::init_sites_queue((uint64_t)a1);
  boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::init_beach_line<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>(a1, a2);
  uint64_t v4 = a1[9];
  uint64_t v5 = a1[10];
LABEL_2:
  while (1)
  {
    double v6 = (int *)a1[2];
    double v7 = (int *)a1[4];
    if (v4 == v5) {
      break;
    }
    if (v7 == v6
      || !boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()((uint64_t)v10, v7, *(void *)v4 + 16))
    {
      boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::process_circle_event<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>((uint64_t)a1, a2);
      goto LABEL_8;
    }
LABEL_7:
    boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::process_site_event<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>((uint64_t)a1, (char **)a2);
LABEL_8:
    uint64_t v4 = a1[9];
    uint64_t v5 = v4;
    if (v4 != a1[10])
    {
      uint64_t v5 = a1[10];
      if (!*(unsigned char *)(*(void *)v4 + 40))
      {
        while (1)
        {
          boost::polygon::detail::ordered_queue<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::event_comparison_type>::pop((uint64_t)(a1 + 9));
          uint64_t v4 = a1[9];
          uint64_t v5 = a1[10];
          if (v4 == v5) {
            break;
          }
          if (*(unsigned char *)(*(void *)v4 + 40)) {
            goto LABEL_2;
          }
        }
        uint64_t v5 = a1[9];
      }
    }
  }
  if (v7 != v6) {
    goto LABEL_7;
  }
  double v9 = (void *)a1[17];
  double v8 = a1 + 17;
  std::__tree<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::__map_value_compare<std::pair<unsigned short,EQKit::Config::Operator::Form>,std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::less<std::pair<unsigned short,EQKit::Config::Operator::Form>>,true>,std::allocator<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>>>::destroy((uint64_t)(v8 - 1), v9);
  *(v8 - 1) = v8;
  *double v8 = 0;
  v8[1] = 0;
  boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::_build((uint64_t *)a2);
}

uint64_t boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::~voronoi_builder(uint64_t a1)
{
  std::__tree<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::__map_value_compare<std::pair<unsigned short,EQKit::Config::Operator::Form>,std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::less<std::pair<unsigned short,EQKit::Config::Operator::Form>>,true>,std::allocator<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>>>::destroy(a1 + 128, *(void **)(a1 + 136));
  std::__list_imp<EQKit::StemStretch::FeatureRange::Span>::clear((void *)(a1 + 104));
  float v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 40);
  if (v3)
  {
    *(void *)(a1 + 48) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    *(void *)(a1 + 16) = v4;
    operator delete(v4);
  }
  return a1;
}

uint64_t boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::insert_point(void *a1, int *a2, int *a3)
{
  uint64_t v4 = (uint64_t)(a1 + 3);
  unint64_t v5 = a1[3];
  int v6 = *a2;
  int v7 = *a3;
  double v8 = (char *)a1[2];
  if ((unint64_t)v8 >= v5)
  {
    int v10 = (void **)(a1 + 1);
    int v11 = (char *)a1[1];
    unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((v8 - v11) >> 3);
    unint64_t v13 = v12 + 1;
    if (v12 + 1 > 0x666666666666666) {
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v14 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v5 - (void)v11) >> 3);
    if (2 * v14 > v13) {
      unint64_t v13 = 2 * v14;
    }
    if (v14 >= 0x333333333333333) {
      unint64_t v15 = 0x666666666666666;
    }
    else {
      unint64_t v15 = v13;
    }
    if (v15)
    {
      double v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::detail::site_event<int>>>(v4, v15);
      int v11 = (char *)a1[1];
      double v8 = (char *)a1[2];
    }
    else
    {
      double v16 = 0;
    }
    unint64_t v17 = &v16[40 * v12];
    *(_DWORD *)unint64_t v17 = v6;
    *((_DWORD *)v17 + 1) = v7;
    *((_DWORD *)v17 + 2) = v6;
    *((_DWORD *)v17 + 3) = v7;
    unint64_t v18 = &v16[40 * v15];
    *((void *)v17 + 2) = 0;
    *((void *)v17 + 4) = 0;
    double v9 = v17 + 40;
    if (v8 != v11)
    {
      do
      {
        long long v19 = *(_OWORD *)(v8 - 40);
        long long v20 = *(_OWORD *)(v8 - 24);
        *((void *)v17 - 1) = *((void *)v8 - 1);
        *(_OWORD *)(v17 - 24) = v20;
        *(_OWORD *)(v17 - 40) = v19;
        v17 -= 40;
        v8 -= 40;
      }
      while (v8 != v11);
      int v11 = (char *)*v10;
    }
    a1[1] = v17;
    a1[2] = v9;
    a1[3] = v18;
    if (v11) {
      operator delete(v11);
    }
  }
  else
  {
    *(_DWORD *)double v8 = v6;
    *((_DWORD *)v8 + 1) = v7;
    *((_DWORD *)v8 + 2) = v6;
    *((_DWORD *)v8 + 3) = v7;
    *((void *)v8 + 2) = 0;
    double v9 = v8 + 40;
    *((void *)v8 + 4) = 0;
  }
  a1[2] = v9;
  uint64_t result = a1[347];
  *((void *)v9 - 2) = result;
  a1[347] = result + 1;
  return result;
}

uint64_t boost::polygon::insert<boost::polygon::segment_data<double>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>>(double *a1, void *a2)
{
  double v2 = a1[1];
  int v9 = (int)*a1;
  int v3 = (int)v2;
  double v4 = a1[3];
  int v7 = (int)a1[2];
  int v8 = v3;
  int v6 = (int)v4;
  return boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::insert_segment(a2, (unsigned int *)&v9, (unsigned int *)&v8, (unsigned int *)&v7, (unsigned int *)&v6);
}

uint64_t boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::insert_segment(void *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4, unsigned int *a5)
{
  uint64_t v8 = *a2;
  uint64_t v9 = *a3;
  uint64_t v11 = (uint64_t)(a1 + 3);
  unint64_t v10 = a1[3];
  unint64_t v12 = (char **)(a1 + 1);
  uint64_t v13 = v8 | (v9 << 32);
  unint64_t v14 = (uint64_t *)a1[2];
  unsigned int v73 = (char **)(a1 + 1);
  if ((unint64_t)v14 >= v10)
  {
    unint64_t v16 = 0xCCCCCCCCCCCCCCCDLL * (((char *)v14 - *v12) >> 3);
    unint64_t v17 = v16 + 1;
    if (v16 + 1 > 0x666666666666666) {
      goto LABEL_72;
    }
    unint64_t v18 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v10 - (void)*v12) >> 3);
    if (2 * v18 > v17) {
      unint64_t v17 = 2 * v18;
    }
    if (v18 >= 0x333333333333333) {
      unint64_t v19 = 0x666666666666666;
    }
    else {
      unint64_t v19 = v17;
    }
    if (v19)
    {
      long long v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::detail::site_event<int>>>((uint64_t)(a1 + 3), v19);
      unint64_t v12 = v73;
    }
    else
    {
      long long v20 = 0;
    }
    double v21 = &v20[40 * v16];
    BOOL v22 = &v20[40 * v19];
    *(void *)double v21 = v13;
    *((void *)v21 + 1) = v13;
    *((void *)v21 + 2) = 0;
    *((void *)v21 + 4) = 0;
    unint64_t v15 = (uint64_t *)(v21 + 40);
    CGPoint v24 = (char *)a1[1];
    BOOL v23 = (char *)a1[2];
    if (v23 != v24)
    {
      do
      {
        long long v25 = *(_OWORD *)(v23 - 40);
        long long v26 = *(_OWORD *)(v23 - 24);
        *((void *)v21 - 1) = *((void *)v23 - 1);
        *(_OWORD *)(v21 - 24) = v26;
        *(_OWORD *)(v21 - 40) = v25;
        v21 -= 40;
        v23 -= 40;
      }
      while (v23 != v24);
      BOOL v23 = *v12;
    }
    a1[1] = v21;
    a1[2] = v15;
    a1[3] = v22;
    if (v23)
    {
      operator delete(v23);
      unint64_t v12 = v73;
    }
  }
  else
  {
    *unint64_t v14 = v13;
    v14[1] = v13;
    v14[2] = 0;
    unint64_t v15 = v14 + 5;
    v14[4] = 0;
  }
  a1[2] = v15;
  uint64_t v27 = *(v15 - 1) | 1;
  *(v15 - 2) = a1[347];
  *(v15 - 1) = v27;
  uint64_t v28 = *a4;
  uint64_t v29 = *a5;
  uint64_t v30 = v28 | (v29 << 32);
  unint64_t v31 = a1[3];
  if ((unint64_t)v15 >= v31)
  {
    unint64_t v33 = 0xCCCCCCCCCCCCCCCDLL * (((char *)v15 - *v12) >> 3);
    if (v33 + 1 > 0x666666666666666) {
      goto LABEL_72;
    }
    unint64_t v34 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v31 - (void)*v12) >> 3);
    uint64_t v35 = 2 * v34;
    if (2 * v34 <= v33 + 1) {
      uint64_t v35 = v33 + 1;
    }
    if (v34 >= 0x333333333333333) {
      unint64_t v36 = 0x666666666666666;
    }
    else {
      unint64_t v36 = v35;
    }
    if (v36)
    {
      float64x2_t v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::detail::site_event<int>>>(v11, v36);
      unint64_t v12 = v73;
    }
    else
    {
      float64x2_t v37 = 0;
    }
    float64x2_t v38 = &v37[40 * v33];
    float64x2_t v39 = &v37[40 * v36];
    *(void *)float64x2_t v38 = v30;
    *((void *)v38 + 1) = v30;
    *((void *)v38 + 2) = 0;
    *((void *)v38 + 4) = 0;
    CGRect v32 = (uint64_t *)(v38 + 40);
    float64x2_t v41 = (char *)a1[1];
    float64x2_t v40 = (char *)a1[2];
    if (v40 != v41)
    {
      do
      {
        long long v42 = *(_OWORD *)(v40 - 40);
        long long v43 = *(_OWORD *)(v40 - 24);
        *((void *)v38 - 1) = *((void *)v40 - 1);
        *(_OWORD *)(v38 - 24) = v43;
        *(_OWORD *)(v38 - 40) = v42;
        v38 -= 40;
        v40 -= 40;
      }
      while (v40 != v41);
      float64x2_t v40 = *v12;
    }
    a1[1] = v38;
    a1[2] = v32;
    a1[3] = v39;
    if (v40)
    {
      operator delete(v40);
      unint64_t v12 = v73;
    }
  }
  else
  {
    *unint64_t v15 = v30;
    v15[1] = v30;
    v15[2] = 0;
    CGRect v32 = v15 + 5;
    v15[4] = 0;
  }
  a1[2] = v32;
  uint64_t v44 = *(v32 - 1) | 2;
  *(v32 - 2) = a1[347];
  *(v32 - 1) = v44;
  BOOL v45 = (int)v8 < (int)v28;
  if (v8 == v28) {
    BOOL v45 = (int)v9 < (int)v29;
  }
  unint64_t v46 = a1[3];
  if (v45)
  {
    if ((unint64_t)v32 < v46)
    {
      *CGRect v32 = v13;
      v32[1] = v30;
      v32[2] = 0;
      int32x4_t v47 = v32 + 5;
      uint64_t v48 = 8;
LABEL_40:
      v32[4] = 0;
      goto LABEL_71;
    }
    unint64_t v49 = 0xCCCCCCCCCCCCCCCDLL * (((char *)v32 - *v12) >> 3);
    if (v49 + 1 <= 0x666666666666666)
    {
      unint64_t v50 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v46 - (void)*v12) >> 3);
      uint64_t v51 = 2 * v50;
      if (2 * v50 <= v49 + 1) {
        uint64_t v51 = v49 + 1;
      }
      if (v50 >= 0x333333333333333) {
        unint64_t v52 = 0x666666666666666;
      }
      else {
        unint64_t v52 = v51;
      }
      if (v52)
      {
        double v53 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::detail::site_event<int>>>(v11, v52);
        unint64_t v12 = v73;
      }
      else
      {
        double v53 = 0;
      }
      double v59 = &v53[40 * v49];
      float v60 = &v53[40 * v52];
      *(void *)double v59 = v13;
      *((void *)v59 + 1) = v30;
      *((void *)v59 + 2) = 0;
      *((void *)v59 + 4) = 0;
      int32x4_t v47 = v59 + 40;
      unsigned int v62 = (char *)a1[1];
      int v61 = (char *)a1[2];
      if (v61 != v62)
      {
        do
        {
          long long v63 = *(_OWORD *)(v61 - 40);
          long long v64 = *(_OWORD *)(v61 - 24);
          *((void *)v59 - 1) = *((void *)v61 - 1);
          *(_OWORD *)(v59 - 24) = v64;
          *(_OWORD *)(v59 - 40) = v63;
          v59 -= 40;
          v61 -= 40;
        }
        while (v61 != v62);
        int v61 = *v12;
      }
      a1[1] = v59;
      a1[2] = v47;
      a1[3] = v60;
      if (v61) {
        operator delete(v61);
      }
      uint64_t v48 = 8;
      goto LABEL_71;
    }
LABEL_72:
    std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
  }
  if ((unint64_t)v32 < v46)
  {
    *CGRect v32 = v30;
    v32[1] = v13;
    v32[2] = 0;
    int32x4_t v47 = v32 + 5;
    uint64_t v48 = 9;
    goto LABEL_40;
  }
  unint64_t v54 = 0xCCCCCCCCCCCCCCCDLL * (((char *)v32 - *v12) >> 3);
  if (v54 + 1 > 0x666666666666666) {
    goto LABEL_72;
  }
  unint64_t v55 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v46 - (void)*v12) >> 3);
  uint64_t v56 = 2 * v55;
  if (2 * v55 <= v54 + 1) {
    uint64_t v56 = v54 + 1;
  }
  if (v55 >= 0x333333333333333) {
    unint64_t v57 = 0x666666666666666;
  }
  else {
    unint64_t v57 = v56;
  }
  if (v57)
  {
    float v58 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::detail::site_event<int>>>(v11, v57);
    unint64_t v12 = v73;
  }
  else
  {
    float v58 = 0;
  }
  signed int v65 = &v58[40 * v54];
  BOOL v66 = &v58[40 * v57];
  *(void *)signed int v65 = v30;
  *((void *)v65 + 1) = v13;
  *((void *)v65 + 2) = 0;
  *((void *)v65 + 4) = 0;
  int32x4_t v47 = v65 + 40;
  float v68 = (char *)a1[1];
  uint64_t v67 = (char *)a1[2];
  if (v67 != v68)
  {
    do
    {
      long long v69 = *(_OWORD *)(v67 - 40);
      long long v70 = *(_OWORD *)(v67 - 24);
      *((void *)v65 - 1) = *((void *)v67 - 1);
      *(_OWORD *)(v65 - 24) = v70;
      *(_OWORD *)(v65 - 40) = v69;
      v65 -= 40;
      v67 -= 40;
    }
    while (v67 != v68);
    uint64_t v67 = *v12;
  }
  a1[1] = v65;
  a1[2] = v47;
  a1[3] = v66;
  if (v67) {
    operator delete(v67);
  }
  uint64_t v48 = 9;
LABEL_71:
  a1[2] = v47;
  uint64_t v71 = *(v47 - 1);
  uint64_t result = a1[347];
  *(v47 - 2) = result;
  *(v47 - 1) = v71 | v48;
  a1[347] = result + 1;
  return result;
}

void boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::_reserve(void **a1, int a2)
{
  std::vector<boost::polygon::voronoi_cell<double>>::reserve(a1, a2);
  std::vector<boost::polygon::voronoi_vertex<double>>::reserve(a1 + 3, 2 * a2);

  std::vector<boost::polygon::voronoi_edge<double>>::reserve(a1 + 6, 6 * a2);
}

unsigned int *boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::init_sites_queue(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  int v3 = *(long long **)(a1 + 16);
  unint64_t v4 = 126 - 2 * __clz(0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v3 - v2) >> 3));
  __int16 v11 = 0;
  if (v3 == (long long *)v2) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = v4;
  }
  std::__introsort<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*,false>(v2, v3, (uint64_t)&v11, v5, 1);
  uint64_t result = std::__unique[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<boost::polygon::detail::site_event<int> *>,std::__wrap_iter<boost::polygon::detail::site_event<int> *>,std::__equal_to &>(*(unsigned int **)(a1 + 8), *(unsigned int **)(a1 + 16));
  uint64_t v7 = *(void *)(a1 + 8);
  if (*(unsigned int **)(a1 + 16) != result) {
    *(void *)(a1 + 16) = result;
  }
  if (result != (unsigned int *)v7)
  {
    uint64_t v8 = 0;
    unint64_t v9 = ((uint64_t)result - v7) / 40;
    if (v9 <= 1) {
      unint64_t v9 = 1;
    }
    unint64_t v10 = (void *)(v7 + 16);
    do
    {
      *unint64_t v10 = v8;
      v10 += 5;
      ++v8;
    }
    while (v9 != v8);
  }
  *(void *)(a1 + 32) = v7;
  return result;
}

void boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::init_beach_line<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>(uint64_t *a1, void **a2)
{
  int v3 = (long long *)a1[1];
  unint64_t v4 = (long long *)a1[2];
  if (v3 != v4)
  {
    if ((char *)v4 - (char *)v3 == 40)
    {
      boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::_process_single_site<int>(a2, (uint64_t)v3);
LABEL_11:
      a1[4] += 40;
      return;
    }
    int v6 = (long long *)a1[4];
    if (v6 != v4)
    {
      int v7 = 0;
      int v8 = *(_DWORD *)v3;
      do
      {
        if (*(_DWORD *)v6 != v8) {
          break;
        }
        if (v8 != *((_DWORD *)v6 + 2)) {
          break;
        }
        int v6 = (long long *)((char *)v6 + 40);
        a1[4] = (uint64_t)v6;
        ++v7;
      }
      while (v6 != v4);
      if (v7 == 1)
      {
        boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::insert_new_arc<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>((uint64_t)a1, v3, (uint64_t)v3, (uint64_t)v3 + 40, a1 + 17, (char **)a2);
        goto LABEL_11;
      }
    }
    boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::init_beach_line_collinear_sites<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>(a1, (char **)a2);
  }
}

void boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::process_site_event<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>(uint64_t a1, char **a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(void *)(v4 + 32);
  long long v6 = *(_OWORD *)(v4 + 16);
  long long v47 = *(_OWORD *)v4;
  long long v48 = v6;
  uint64_t v49 = v5;
  int v7 = (int *)(v4 + 40);
  int v8 = v47;
  if (v47 == DWORD2(v47) && (int v9 = DWORD1(v47), DWORD1(v47) == HIDWORD(v47)))
  {
    uint64_t v10 = *(void *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 48);
    if (v10 != v11)
    {
      do
      {
        if (*(_DWORD *)v10 != v8 || *(_DWORD *)(v10 + 4) != v9) {
          break;
        }
        unint64_t v12 = *(uint64_t **)(v10 + 8);
        LOBYTE(v42[0]) = *(unsigned char *)(a1 + 64);
        if (v11 - v10 >= 17)
        {
          uint64_t v13 = *(void *)v10;
          unint64_t v14 = (void *)std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::end_point_comparison &,std::__wrap_iter<std::pair<boost::polygon::detail::point_2d<int>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>> *>>((void *)v10, (uint64_t)v42, (unint64_t)(v11 - v10) >> 4);
          if ((void *)(v11 - 16) == v14)
          {
            *unint64_t v14 = v13;
            v14[1] = v12;
          }
          else
          {
            *unint64_t v14 = *(void *)(v11 - 16);
            v14[1] = *(void *)(v11 - 8);
            *(void *)(v11 - 16) = v13;
            *(void *)(v11 - 8) = v12;
            std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::end_point_comparison &,std::__wrap_iter<std::pair<boost::polygon::detail::point_2d<int>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>> *>>(v10, (uint64_t)(v14 + 2), (uint64_t)v42, ((uint64_t)v14 - v10 + 16) >> 4);
          }
        }
        *(void *)(a1 + 48) -= 16;
        std::__tree<std::__value_type<unsigned short,EQKit::Config::Operator::Form>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,EQKit::Config::Operator::Form>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,EQKit::Config::Operator::Form>>>::__remove_node_pointer((uint64_t **)(a1 + 128), v12);
        operator delete(v12);
        uint64_t v10 = *(void *)(a1 + 40);
        uint64_t v11 = *(void *)(a1 + 48);
      }
      while (v10 != v11);
      uint64_t v4 = *(void *)(a1 + 32);
    }
  }
  else
  {
    unint64_t v15 = *(int **)(a1 + 16);
    if (v7 != v15)
    {
      do
      {
        int v16 = *v7;
        if (*v7 == v7[2])
        {
          int v17 = v7[1];
          BOOL v18 = v16 != v47 || v17 == v7[3];
          if (v18) {
            goto LABEL_25;
          }
        }
        else
        {
          if (v16 != v47) {
            goto LABEL_25;
          }
          int v17 = v7[1];
        }
        if (v17 != DWORD1(v47)) {
          goto LABEL_25;
        }
        v7 += 10;
      }
      while (v7 != v15);
      int v7 = *(int **)(a1 + 16);
    }
  }
LABEL_25:
  long long v19 = *(_OWORD *)v4;
  long long v20 = *(_OWORD *)(v4 + 16);
  uint64_t v43 = *(void *)(v4 + 32);
  v42[0] = v19;
  v42[1] = v20;
  long long v21 = *(_OWORD *)v4;
  long long v22 = *(_OWORD *)(v4 + 16);
  uint64_t v46 = *(void *)(v4 + 32);
  long long v45 = v22;
  long long v44 = v21;
  CGPoint v24 = (uint64_t *)(a1 + 136);
  BOOL v23 = *(void **)(a1 + 136);
  long long v25 = (uint64_t *)(a1 + 136);
  if (v23)
  {
    long long v25 = (uint64_t *)(a1 + 136);
    do
    {
      int v26 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>::operator()(a1 + 152, (uint64_t)(v23 + 4), (uint64_t)v42);
      uint64_t v27 = v23 + 1;
      if (!v26)
      {
        uint64_t v27 = v23;
        long long v25 = v23;
      }
      BOOL v23 = (void *)*v27;
    }
    while (*v27);
    uint64_t v4 = *(void *)(a1 + 32);
  }
  while ((int *)v4 != v7)
  {
    long long v28 = *(_OWORD *)v4;
    long long v29 = *(_OWORD *)(v4 + 16);
    uint64_t v49 = *(void *)(v4 + 32);
    long long v47 = v28;
    long long v48 = v29;
    if (v25 == v24)
    {
      uint64_t v37 = *v24;
      uint64_t v38 = a1 + 136;
      if (*v24)
      {
        do
        {
          uint64_t v39 = v37;
          uint64_t v37 = *(void *)(v37 + 8);
        }
        while (v37);
      }
      else
      {
        do
        {
          uint64_t v39 = *(void *)(v38 + 16);
          BOOL v18 = *(void *)v39 == v38;
          uint64_t v38 = v39;
        }
        while (v18);
      }
      float64x2_t v40 = (int *)(v39 + 32);
      float64x2_t v41 = (int *)(v39 + 72);
      long long v25 = boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::insert_new_arc<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>(a1, (long long *)(v39 + 72), v39 + 72, (uint64_t)&v47, v25, a2);
      boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::activate_circle_event(a1, v40, v41, (int *)&v47, (uint64_t)v25);
    }
    else
    {
      if (v25 == *(uint64_t **)(a1 + 128))
      {
        unint64_t v36 = boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::insert_new_arc<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>(a1, (long long *)v25 + 2, (uint64_t)(v25 + 4), (uint64_t)&v47, v25, a2);
      }
      else
      {
        uint64_t v30 = v25[14];
        if (v30)
        {
          *(unsigned char *)(v30 + 24) = 0;
          v25[14] = 0;
        }
        uint64_t v31 = *v25;
        CGRect v32 = v25;
        if (*v25)
        {
          do
          {
            uint64_t v33 = v31;
            uint64_t v31 = *(void *)(v31 + 8);
          }
          while (v31);
        }
        else
        {
          do
          {
            uint64_t v33 = v32[2];
            BOOL v18 = *(void *)v33 == (void)v32;
            CGRect v32 = (uint64_t *)v33;
          }
          while (v18);
        }
        unint64_t v34 = (int *)(v33 + 32);
        uint64_t v35 = (int *)(v33 + 72);
        unint64_t v36 = boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::insert_new_arc<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>(a1, (long long *)(v33 + 72), (uint64_t)(v25 + 4), (uint64_t)&v47, v25, a2);
        boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::activate_circle_event(a1, v34, v35, (int *)&v47, (uint64_t)v36);
      }
      if ((void)v47 != *((void *)&v47 + 1)) {
        v49 ^= 0x20uLL;
      }
      boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::activate_circle_event(a1, (int *)&v47, (int *)v25 + 8, (int *)v25 + 18, (uint64_t)v25);
      long long v25 = v36;
    }
    uint64_t v4 = *(void *)(a1 + 32) + 40;
    *(void *)(a1 + 32) = v4;
  }
}

void boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::process_circle_event<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>(uint64_t a1, void *a2)
{
  uint64_t v3 = a1 + 72;
  uint64_t v4 = **(void **)(a1 + 72);
  uint64_t v5 = (uint64_t *)(v4 + 16);
  uint64_t v6 = *(void *)(v4 + 48);
  long long v7 = *(_OWORD *)(v6 + 88);
  long long v27 = *(_OWORD *)(v6 + 72);
  long long v28 = v7;
  uint64_t v29 = *(void *)(v6 + 104);
  int v8 = *(void **)(v6 + 120);
  uint64_t v9 = *(void *)v6;
  if (*(void *)v6)
  {
    do
    {
      uint64_t v10 = v9;
      uint64_t v9 = *(void *)(v9 + 8);
    }
    while (v9);
  }
  else
  {
    uint64_t v11 = v6;
    do
    {
      uint64_t v10 = *(void *)(v11 + 16);
      BOOL v12 = *(void *)v10 == v11;
      uint64_t v11 = v10;
    }
    while (v12);
  }
  uint64_t v13 = *(void **)(v10 + 120);
  long long v14 = *(_OWORD *)(v10 + 48);
  v25[0] = *(_OWORD *)(v10 + 32);
  v25[1] = v14;
  uint64_t v26 = *(void *)(v10 + 64);
  if (*(void *)&v25[0] == *((void *)&v25[0] + 1))
  {
    int v15 = v27;
    if ((void)v27 != *((void *)&v27 + 1))
    {
      if ((v29 & 0x20) == 0) {
        int v15 = DWORD2(v27);
      }
      if (v15 == LODWORD(v25[0]))
      {
        int v16 = (_DWORD *)&v27 + 1;
        if ((v29 & 0x20) == 0) {
          int v16 = (_DWORD *)((unint64_t)&v27 | 0xC);
        }
        if (*v16 == DWORD1(v25[0])) {
          v29 ^= 0x20uLL;
        }
      }
    }
  }
  long long v17 = v28;
  *(_OWORD *)(v10 + 72) = v27;
  *(_OWORD *)(v10 + 88) = v17;
  *(void *)(v10 + 104) = v29;
  *(void *)(v10 + 120) = boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::_insert_new_edge<int,double>(a2, (uint64_t)v25, (uint64_t)&v27, v5, v13, v8);
  std::__tree<std::__value_type<unsigned short,EQKit::Config::Operator::Form>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,EQKit::Config::Operator::Form>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,EQKit::Config::Operator::Form>>>::__remove_node_pointer((uint64_t **)(a1 + 128), (uint64_t *)v6);
  operator delete((void *)v6);
  boost::polygon::detail::ordered_queue<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::event_comparison_type>::pop(v3);
  if (v10 != *(void *)(a1 + 128))
  {
    uint64_t v18 = *(void *)(v10 + 112);
    if (v18)
    {
      *(unsigned char *)(v18 + 24) = 0;
      *(void *)(v10 + 112) = 0;
    }
    uint64_t v19 = *(void *)v10;
    if (*(void *)v10)
    {
      do
      {
        uint64_t v20 = v19;
        uint64_t v19 = *(void *)(v19 + 8);
      }
      while (v19);
    }
    else
    {
      uint64_t v21 = v10;
      do
      {
        uint64_t v20 = *(void *)(v21 + 16);
        BOOL v12 = *(void *)v20 == v21;
        uint64_t v21 = v20;
      }
      while (v12);
    }
    boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::activate_circle_event(a1, (int *)(v20 + 32), (int *)v25, (int *)&v27, v10);
  }
  long long v22 = *(void **)(v10 + 8);
  if (v22)
  {
    do
    {
      uint64_t v23 = (uint64_t)v22;
      long long v22 = (void *)*v22;
    }
    while (v22);
  }
  else
  {
    do
    {
      uint64_t v23 = *(void *)(v10 + 16);
      BOOL v12 = *(void *)v23 == v10;
      uint64_t v10 = v23;
    }
    while (!v12);
  }
  if (v23 != a1 + 136)
  {
    uint64_t v24 = *(void *)(v23 + 112);
    if (v24)
    {
      *(unsigned char *)(v24 + 24) = 0;
      *(void *)(v23 + 112) = 0;
    }
    boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::activate_circle_event(a1, (int *)v25, (int *)&v27, (int *)(v23 + 72), v23);
  }
}

BOOL boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(uint64_t a1, int *a2, uint64_t a3)
{
  int v3 = *a2;
  uint64_t v4 = *(void *)(a3 + 16);
  if (*a2 >= 0) {
    *(void *)&double v5 = 0x8000000000000000 - COERCE__INT64((double)v3);
  }
  else {
    double v5 = (double)v3;
  }
  if (v4 >= 0) {
    uint64_t v4 = 0x8000000000000000 - v4;
  }
  if ((unint64_t)(*(void *)&v5 - v4) <= 0x40) {
    int v6 = 0;
  }
  else {
    int v6 = -1;
  }
  if (*(void *)&v5 > (unint64_t)v4) {
    int v7 = v6;
  }
  else {
    int v7 = (unint64_t)(v4 - *(void *)&v5) > 0x40;
  }
  if (!v7)
  {
    int v8 = a2[1];
    uint64_t v9 = *(void *)(a3 + 8);
    if (v8 >= 0) {
      *(void *)&double v10 = 0x8000000000000000 - COERCE__INT64((double)v8);
    }
    else {
      double v10 = (double)v8;
    }
    unint64_t v11 = 0x8000000000000000 - v9;
    if (v9 < 0) {
      unint64_t v11 = *(void *)(a3 + 8);
    }
    if (*(void *)&v10 - v11 <= 0x40) {
      int v12 = 0;
    }
    else {
      int v12 = -1;
    }
    if (*(void *)&v10 > v11) {
      int v7 = v12;
    }
    else {
      int v7 = v11 - *(void *)&v10 > 0x40;
    }
  }
  return v7 == -1;
}

void boost::polygon::detail::ordered_queue<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::event_comparison_type>::pop(uint64_t a1)
{
  uint64_t v2 = *(uint64_t ***)a1;
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = **(uint64_t ***)a1;
  __int16 v8 = *(_WORD *)(a1 + 24);
  if (v3 - (uint64_t)v2 >= 9)
  {
    double v5 = std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::ordered_queue<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::event_comparison_type>::comparison &,std::__wrap_iter<std::__list_iterator<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,void *> *>>(v2, (uint64_t)&v8, (unint64_t)(v3 - (void)v2) >> 3);
    int v6 = (uint64_t **)(v3 - 8);
    if ((void *)(v3 - 8) == v5)
    {
      *double v5 = v4;
    }
    else
    {
      *double v5 = *v6;
      *int v6 = v4;
      std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::ordered_queue<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::event_comparison_type>::comparison &,std::__wrap_iter<std::__list_iterator<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,void *> *>>((BOOL)v2, (uint64_t)(v5 + 1), (uint64_t)&v8, (uint64_t **)(v5 + 1) - v2);
    }
  }
  *(void *)(a1 + 8) -= 8;
  uint64_t v7 = *v4;
  *(void *)(v7 + 8) = v4[1];
  *(void *)v4[1] = v7;
  --*(void *)(a1 + 48);
  operator delete(v4);
}

void boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::_build(uint64_t *a1)
{
  uint64_t v2 = a1[6];
  if (v2 != a1[7])
  {
    uint64_t v3 = -v2;
    uint64_t v4 = (char *)a1[6];
    do
    {
      double v5 = (unint64_t *)*((void *)v4 + 1);
      int v6 = *(uint64_t **)(*((void *)v4 + 2) + 8);
      if (v5) {
        BOOL v7 = v6 == 0;
      }
      else {
        BOOL v7 = 1;
      }
      if (v7
        || !boost::polygon::voronoi_diagram_traits<double>::vertex_equality_predicate_type::operator()((uint64_t)(a1 + 9), v5, v6))
      {
        if (v4 != (char *)v2)
        {
          long long v8 = *(_OWORD *)v4;
          long long v9 = *((_OWORD *)v4 + 2);
          *(_OWORD *)(v2 + 16) = *((_OWORD *)v4 + 1);
          *(_OWORD *)(v2 + 32) = v9;
          *(_OWORD *)uint64_t v2 = v8;
          uint64_t v10 = v2 + 48;
          long long v11 = *((_OWORD *)v4 + 5);
          long long v12 = *((_OWORD *)v4 + 3);
          *(_OWORD *)(v2 + 64) = *((_OWORD *)v4 + 4);
          *(_OWORD *)(v2 + 80) = v11;
          *(_OWORD *)(v2 + 48) = v12;
          *(void *)(v2 + 16) = v2 + 48;
          *(void *)(v2 + 64) = v2;
          uint64_t v13 = *(void *)(v2 + 32);
          if (v13)
          {
            *(void *)(v13 + 24) = v2;
            *(void *)(*(void *)(v2 + 72) + 32) = v10;
          }
          if (*(void *)(v2 + 80))
          {
            *(void *)(*(void *)(v2 + 24) + 32) = v2;
            *(void *)(*(void *)(v2 + 80) + 24) = v10;
          }
        }
        v2 += 96;
      }
      else
      {
        boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::remove_edge((uint64_t)a1, v4);
      }
      v4 += 96;
      v3 -= 96;
    }
    while (v4 != (char *)a1[7]);
    long long v14 = (char *)a1[6];
    if (v4 != (char *)v2)
    {
      int v15 = &v14[48 * ((v2 - (uint64_t)v14) / 48)];
      int v16 = &v15[-v2 - v3];
      size_t v17 = -v3 - (void)v16;
      if (v4 != v16)
      {
        memmove(v15, v16, v17);
        long long v14 = (char *)a1[6];
      }
      uint64_t v4 = &v15[v17];
      a1[7] = (uint64_t)&v15[v17];
    }
    while (v14 != v4)
    {
      uint64_t v18 = *((void *)v14 + 1);
      *(void *)(*(void *)v14 + 8) = v14;
      if (v18) {
        *(void *)(v18 + 16) = v14;
      }
      v14 += 48;
    }
  }
  uint64_t v20 = (_OWORD *)a1[3];
  uint64_t v19 = (_OWORD *)a1[4];
  if (v20 == v19) {
    goto LABEL_46;
  }
  uint64_t v21 = (_OWORD *)a1[3];
  do
  {
    if (*((void *)v21 + 2))
    {
      if (v21 != v20)
      {
        long long v22 = v21[1];
        *uint64_t v20 = *v21;
        v20[1] = v22;
        uint64_t v23 = *((void *)v20 + 2);
        uint64_t v24 = v23;
        do
        {
          *(void *)(v24 + 8) = v20;
          uint64_t v24 = *(void *)(*(void *)(v24 + 32) + 16);
        }
        while (v24 != v23);
        uint64_t v19 = (_OWORD *)a1[4];
      }
      v20 += 2;
    }
    v21 += 2;
  }
  while (v21 != v19);
  long long v25 = (_OWORD *)a1[3];
  if (v20 != v19)
  {
    uint64_t v19 = v20;
    a1[4] = (uint64_t)v20;
  }
  if (v25 == v19)
  {
LABEL_46:
    CGRect v32 = (void *)a1[6];
    uint64_t v33 = (void *)a1[7];
    if (v32 != v33)
    {
      v32[3] = v32;
      v32[4] = v32;
      for (uint64_t i = v32 + 12; i != v33; uint64_t i = v35 + 24)
      {
        uint64_t v35 = v32;
        unint64_t v36 = v32 + 6;
        v32 += 12;
        v35[9] = v32;
        v35[10] = v32;
        v35[15] = v36;
        _OWORD v35[16] = v36;
      }
      v32[9] = v32 + 6;
      v32[10] = v32 + 6;
    }
  }
  else
  {
    uint64_t v26 = *a1;
    uint64_t v27 = a1[1];
    while (v26 != v27)
    {
      uint64_t v28 = *(void *)(v26 + 8);
      if (v28)
      {
        uint64_t v29 = *(void *)(v26 + 8);
        while (1)
        {
          uint64_t v30 = *(void *)(v29 + 32);
          if (!v30) {
            break;
          }
          uint64_t v29 = *(void *)(v29 + 32);
          if (v30 == v28)
          {
            uint64_t v29 = *(void *)(v26 + 8);
            if (*(void *)(v28 + 32)) {
              goto LABEL_45;
            }
            goto LABEL_43;
          }
        }
        do
        {
LABEL_43:
          uint64_t v31 = v28;
          uint64_t v28 = *(void *)(v28 + 24);
        }
        while (v28);
        *(void *)(v29 + 32) = v31;
        *(void *)(v31 + 24) = v29;
      }
LABEL_45:
      v26 += 24;
    }
  }
}

void std::vector<boost::polygon::voronoi_cell<double>>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - (unsigned char *)*a1) >> 3) < a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL) {
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = ((unsigned char *)a1[1] - (unsigned char *)*a1) / 24;
    int v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::voronoi_cell<double>>>(v3, a2);
    BOOL v7 = &v6[24 * v5];
    long long v9 = &v6[24 * v8];
    long long v11 = (char *)*a1;
    uint64_t v10 = (char *)a1[1];
    long long v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        long long v13 = *(_OWORD *)(v10 - 24);
        *((void *)v12 - 1) = *((void *)v10 - 1);
        *(_OWORD *)(v12 - 24) = v13;
        v12 -= 24;
        v10 -= 24;
      }
      while (v10 != v11);
      uint64_t v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void std::vector<boost::polygon::voronoi_vertex<double>>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 5)
  {
    if (a2 >> 59) {
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    int v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::segment_data<double>>>(v3, a2);
    BOOL v7 = &v6[v5 & 0xFFFFFFFFFFFFFFE0];
    long long v9 = &v6[32 * v8];
    long long v11 = (char *)*a1;
    uint64_t v10 = (char *)a1[1];
    long long v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        long long v13 = *((_OWORD *)v10 - 1);
        *((_OWORD *)v12 - 2) = *((_OWORD *)v10 - 2);
        *((_OWORD *)v12 - 1) = v13;
        v12 -= 32;
        v10 -= 32;
      }
      while (v10 != v11);
      uint64_t v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void std::vector<boost::polygon::voronoi_edge<double>>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - (unsigned char *)*a1) >> 4) < a2)
  {
    if (a2 >= 0x555555555555556) {
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = ((unsigned char *)a1[1] - (unsigned char *)*a1) / 48;
    int v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::voronoi_edge<double>>>(v3, a2);
    BOOL v7 = &v6[48 * v5];
    long long v9 = &v6[48 * v8];
    long long v11 = (char *)*a1;
    uint64_t v10 = (char *)a1[1];
    long long v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        long long v13 = *((_OWORD *)v10 - 3);
        long long v14 = *((_OWORD *)v10 - 1);
        *((_OWORD *)v12 - 2) = *((_OWORD *)v10 - 2);
        *((_OWORD *)v12 - 1) = v14;
        *((_OWORD *)v12 - 3) = v13;
        v12 -= 48;
        v10 -= 48;
      }
      while (v10 != v11);
      uint64_t v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::voronoi_cell<double>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(24 * a2);
}

void std::__introsort<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*,false>(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, char a5)
{
uint64_t boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(uint64_t a1, int *a2, int *a3)
{
  int v3 = *a2;
  BOOL v4 = *a2 < *a3;
  if (*a2 != *a3) {
    return v4;
  }
  if (v3 != a2[2])
  {
    if (v3 == a3[2]) {
      return 0;
    }
    int v11 = a2[1];
    int v12 = a3[1];
    BOOL v4 = v11 < v12;
    if (v11 == v12) {
      return boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::orientation_test::eval<boost::polygon::detail::point_2d<int>>(a2 + 2, a2, a3 + 2) == 1;
    }
    return v4;
  }
  int v5 = a2[1];
  int v6 = a3[2];
  if (v5 != a2[3])
  {
    if (v3 != v6) {
      return 1;
    }
    return v5 < a3[1];
  }
  if (v3 != v6) {
    return 1;
  }
  int v7 = a3[1];
  BOOL v4 = v5 < v7;
  BOOL v8 = v5 <= v7;
  unsigned int v9 = v4;
  if (v7 == a3[3]) {
    return v9;
  }
  else {
    return v8;
  }
}

uint64_t std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result != a2)
  {
    uint64_t v21 = v3;
    uint64_t v22 = v4;
    uint64_t v6 = result;
    int v7 = (int *)(result + 40);
    if (result + 40 != a2)
    {
      uint64_t v9 = 0;
      uint64_t v10 = result;
      do
      {
        int v11 = (int *)v10;
        uint64_t v10 = (uint64_t)v7;
        uint64_t result = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, v7, v11);
        if (result)
        {
          long long v12 = *(_OWORD *)(v10 + 16);
          long long v18 = *(_OWORD *)v10;
          long long v19 = v12;
          uint64_t v20 = *(void *)(v10 + 32);
          uint64_t v13 = v9;
          while (1)
          {
            uint64_t v14 = v6 + v13;
            long long v15 = *(_OWORD *)(v6 + v13 + 16);
            *(_OWORD *)(v14 + 40) = *(_OWORD *)(v6 + v13);
            *(_OWORD *)(v14 + 56) = v15;
            *(void *)(v14 + 72) = *(void *)(v6 + v13 + 32);
            if (!v13) {
              break;
            }
            v13 -= 40;
            uint64_t result = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)&v18, (int *)(v13 + v6));
            if ((result & 1) == 0)
            {
              uint64_t v16 = v6 + v13 + 40;
              goto LABEL_10;
            }
          }
          uint64_t v16 = v6;
LABEL_10:
          long long v17 = v19;
          *(_OWORD *)uint64_t v16 = v18;
          *(_OWORD *)(v16 + 16) = v17;
          *(void *)(v16 + 32) = v20;
        }
        int v7 = (int *)(v10 + 40);
        v9 += 40;
      }
      while (v10 + 40 != a2);
    }
  }
  return result;
}

uint64_t std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result != a2)
  {
    uint64_t v18 = v3;
    uint64_t v19 = v4;
    uint64_t v6 = result;
    int v7 = (int *)(result + 40);
    if (result + 40 != a2)
    {
      uint64_t v9 = result - 40;
      do
      {
        uint64_t v10 = (int *)v6;
        uint64_t v6 = (uint64_t)v7;
        uint64_t result = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, v7, v10);
        if (result)
        {
          long long v11 = *(_OWORD *)(v6 + 16);
          long long v15 = *(_OWORD *)v6;
          long long v16 = v11;
          uint64_t v17 = *(void *)(v6 + 32);
          uint64_t v12 = v9;
          do
          {
            long long v13 = *(_OWORD *)(v12 + 56);
            *(_OWORD *)(v12 + 80) = *(_OWORD *)(v12 + 40);
            *(_OWORD *)(v12 + 96) = v13;
            *(void *)(v12 + 112) = *(void *)(v12 + 72);
            uint64_t result = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)&v15, (int *)v12);
            v12 -= 40;
          }
          while ((result & 1) != 0);
          long long v14 = v16;
          *(_OWORD *)(v12 + 80) = v15;
          *(_OWORD *)(v12 + 96) = v14;
          *(void *)(v12 + 112) = v17;
        }
        int v7 = (int *)(v6 + 40);
        v9 += 40;
      }
      while (v6 + 40 != a2);
    }
  }
  return result;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(int *a1, int *a2, int *a3, uint64_t a4)
{
  char v8 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a4, a2, a1);
  uint64_t result = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a4, a3, a2);
  if (v8)
  {
    if (result)
    {
      long long v10 = *(_OWORD *)a1;
      long long v11 = *((_OWORD *)a1 + 1);
      uint64_t v12 = *((void *)a1 + 4);
      uint64_t v13 = *((void *)a3 + 4);
      long long v14 = *((_OWORD *)a3 + 1);
      *(_OWORD *)a1 = *(_OWORD *)a3;
      *((_OWORD *)a1 + 1) = v14;
      *((void *)a1 + 4) = v13;
      *((void *)a3 + 4) = v12;
      uint64_t result = 1;
LABEL_9:
      *(_OWORD *)a3 = v10;
      *((_OWORD *)a3 + 1) = v11;
      return result;
    }
    long long v25 = *(_OWORD *)a1;
    long long v26 = *((_OWORD *)a1 + 1);
    uint64_t v27 = *((void *)a1 + 4);
    uint64_t v28 = *((void *)a2 + 4);
    long long v29 = *((_OWORD *)a2 + 1);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *((_OWORD *)a1 + 1) = v29;
    *((void *)a1 + 4) = v28;
    *((void *)a2 + 4) = v27;
    *(_OWORD *)a2 = v25;
    *((_OWORD *)a2 + 1) = v26;
    if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a4, a3, a2))
    {
      long long v10 = *(_OWORD *)a2;
      long long v11 = *((_OWORD *)a2 + 1);
      uint64_t v30 = *((void *)a2 + 4);
      uint64_t v31 = *((void *)a3 + 4);
      long long v32 = *((_OWORD *)a3 + 1);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_OWORD *)a2 + 1) = v32;
      *((void *)a2 + 4) = v31;
      *((void *)a3 + 4) = v30;
      uint64_t result = 2;
      goto LABEL_9;
    }
  }
  else
  {
    if (!result) {
      return result;
    }
    long long v15 = *(_OWORD *)a2;
    long long v16 = *((_OWORD *)a2 + 1);
    uint64_t v17 = *((void *)a2 + 4);
    uint64_t v18 = *((void *)a3 + 4);
    long long v19 = *((_OWORD *)a3 + 1);
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *((_OWORD *)a2 + 1) = v19;
    *((void *)a2 + 4) = v18;
    *((void *)a3 + 4) = v17;
    *(_OWORD *)a3 = v15;
    *((_OWORD *)a3 + 1) = v16;
    if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a4, a2, a1))
    {
      long long v20 = *(_OWORD *)a1;
      long long v21 = *((_OWORD *)a1 + 1);
      uint64_t v22 = *((void *)a1 + 4);
      uint64_t v23 = *((void *)a2 + 4);
      long long v24 = *((_OWORD *)a2 + 1);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *((_OWORD *)a1 + 1) = v24;
      *((void *)a1 + 4) = v23;
      *((void *)a2 + 4) = v22;
      uint64_t result = 2;
      *(_OWORD *)a2 = v20;
      *((_OWORD *)a2 + 1) = v21;
      return result;
    }
  }
  return 1;
}

int *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::site_event<int> *,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &>(int *a1, unint64_t a2, uint64_t a3)
{
  unint64_t v4 = a2;
  long long v6 = *((_OWORD *)a1 + 1);
  long long v22 = *(_OWORD *)a1;
  long long v23 = v6;
  uint64_t v24 = *((void *)a1 + 4);
  if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)&v22, (int *)(a2 - 40)))
  {
    int v7 = a1;
    do
      v7 += 10;
    while ((boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)&v22, v7) & 1) == 0);
  }
  else
  {
    char v8 = a1 + 10;
    do
    {
      int v7 = v8;
      if ((unint64_t)v8 >= v4) {
        break;
      }
      int v9 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)&v22, v8);
      char v8 = v7 + 10;
    }
    while (!v9);
  }
  if ((unint64_t)v7 < v4)
  {
    do
      v4 -= 40;
    while ((boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)&v22, (int *)v4) & 1) != 0);
  }
  while ((unint64_t)v7 < v4)
  {
    long long v10 = *(_OWORD *)v7;
    long long v11 = *((_OWORD *)v7 + 1);
    uint64_t v27 = *((void *)v7 + 4);
    long long v25 = v10;
    long long v26 = v11;
    long long v12 = *(_OWORD *)v4;
    long long v13 = *(_OWORD *)(v4 + 16);
    *((void *)v7 + 4) = *(void *)(v4 + 32);
    *(_OWORD *)int v7 = v12;
    *((_OWORD *)v7 + 1) = v13;
    long long v14 = v25;
    long long v15 = v26;
    *(void *)(v4 + 32) = v27;
    *(_OWORD *)unint64_t v4 = v14;
    *(_OWORD *)(v4 + 16) = v15;
    do
      v7 += 10;
    while (!boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)&v22, v7));
    do
      v4 -= 40;
    while ((boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)&v22, (int *)v4) & 1) != 0);
  }
  long long v16 = v7 - 10;
  if (v7 - 10 != a1)
  {
    long long v17 = *(_OWORD *)v16;
    long long v18 = *(_OWORD *)(v7 - 6);
    *((void *)a1 + 4) = *((void *)v7 - 1);
    *(_OWORD *)a1 = v17;
    *((_OWORD *)a1 + 1) = v18;
  }
  long long v19 = v22;
  long long v20 = v23;
  *((void *)v7 - 1) = v24;
  *(_OWORD *)long long v16 = v19;
  *(_OWORD *)(v7 - 6) = v20;
  return v7;
}

uint64_t std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::site_event<int> *,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &>(long long *a1, int *a2, uint64_t a3)
{
  uint64_t v6 = 0;
  long long v7 = a1[1];
  long long v22 = *a1;
  long long v23 = v7;
  uint64_t v24 = *((void *)a1 + 4);
  do
    v6 += 40;
  while ((boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)((char *)a1 + v6), (int *)&v22) & 1) != 0);
  unint64_t v8 = (unint64_t)a1 + v6;
  uint64_t v9 = (uint64_t)a1 + v6 - 40;
  if (v6 == 40)
  {
    do
    {
      if (v8 >= (unint64_t)a2) {
        break;
      }
      a2 -= 10;
    }
    while ((boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, a2, (int *)&v22) & 1) == 0);
  }
  else
  {
    do
      a2 -= 10;
    while (!boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, a2, (int *)&v22));
  }
  if (v8 < (unint64_t)a2)
  {
    unint64_t v10 = (unint64_t)a1 + v6;
    long long v11 = a2;
    do
    {
      long long v13 = *(_OWORD *)(v10 + 16);
      long long v25 = *(_OWORD *)v10;
      long long v12 = v25;
      long long v26 = v13;
      uint64_t v27 = *(void *)(v10 + 32);
      uint64_t v14 = v27;
      long long v16 = *(_OWORD *)v11;
      long long v15 = *((_OWORD *)v11 + 1);
      *(void *)(v10 + 32) = *((void *)v11 + 4);
      *(_OWORD *)unint64_t v10 = v16;
      *(_OWORD *)(v10 + 16) = v15;
      *((void *)v11 + 4) = v14;
      *(_OWORD *)long long v11 = v12;
      *((_OWORD *)v11 + 1) = v13;
      do
        v10 += 40;
      while ((boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)v10, (int *)&v22) & 1) != 0);
      do
        v11 -= 10;
      while (!boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, v11, (int *)&v22));
    }
    while (v10 < (unint64_t)v11);
    uint64_t v9 = v10 - 40;
  }
  if ((long long *)v9 != a1)
  {
    long long v17 = *(_OWORD *)v9;
    long long v18 = *(_OWORD *)(v9 + 16);
    *((void *)a1 + 4) = *(void *)(v9 + 32);
    *a1 = v17;
    a1[1] = v18;
  }
  long long v19 = v22;
  long long v20 = v23;
  *(void *)(v9 + 32) = v24;
  *(_OWORD *)uint64_t v9 = v19;
  *(_OWORD *)(v9 + 16) = v20;
  return v9;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(0xCCCCCCCCCCCCCCCDLL * v6)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      uint64_t v8 = a2 - 40;
      if (!boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)(a2 - 40), (int *)a1))return 1; {
      long long v9 = *(_OWORD *)a1;
      }
      long long v10 = *(_OWORD *)(a1 + 16);
      uint64_t v11 = *(void *)(a1 + 32);
      uint64_t v12 = *(void *)(v8 + 32);
      long long v13 = *(_OWORD *)(v8 + 16);
      *(_OWORD *)a1 = *(_OWORD *)v8;
      *(_OWORD *)(a1 + 16) = v13;
      *(void *)(a1 + 32) = v12;
      *(void *)(v8 + 32) = v11;
      BOOL result = 1;
      *(_OWORD *)uint64_t v8 = v9;
      *(_OWORD *)(v8 + 16) = v10;
      return result;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>((int *)a1, (int *)(a1 + 40), (int *)(a2 - 40), a3);
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(a1, (int *)(a1 + 40), (int *)(a1 + 80), (long long *)(a2 - 40), a3);
      return 1;
    case 5uLL:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(a1, (int *)(a1 + 40), (int *)(a1 + 80), (long long *)(a1 + 120), (long long *)(a2 - 40), a3);
      return 1;
    default:
      uint64_t v14 = (int *)(a1 + 80);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>((int *)a1, (int *)(a1 + 40), (int *)(a1 + 80), a3);
      uint64_t v15 = a1 + 120;
      if (a1 + 120 == a2) {
        return 1;
      }
      uint64_t v16 = 0;
      int v17 = 0;
      break;
  }
  while (1)
  {
    if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)v15, v14))
    {
      long long v18 = *(_OWORD *)(v15 + 16);
      long long v24 = *(_OWORD *)v15;
      long long v25 = v18;
      uint64_t v26 = *(void *)(v15 + 32);
      uint64_t v19 = v16;
      while (1)
      {
        uint64_t v20 = a1 + v19;
        long long v21 = *(_OWORD *)(a1 + v19 + 96);
        *(_OWORD *)(v20 + 120) = *(_OWORD *)(a1 + v19 + 80);
        *(_OWORD *)(v20 + 136) = v21;
        *(void *)(v20 + 152) = *(void *)(a1 + v19 + 112);
        if (v19 == -80) {
          break;
        }
        v19 -= 40;
        if ((boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)&v24, (int *)(v20 + 40)) & 1) == 0)
        {
          uint64_t v22 = a1 + v19 + 120;
          goto LABEL_12;
        }
      }
      uint64_t v22 = a1;
LABEL_12:
      long long v23 = v25;
      *(_OWORD *)uint64_t v22 = v24;
      *(_OWORD *)(v22 + 16) = v23;
      *(void *)(v22 + 32) = v26;
      if (++v17 == 8) {
        return v15 + 40 == a2;
      }
    }
    uint64_t v14 = (int *)v15;
    v16 += 40;
    v15 += 40;
    if (v15 == a2) {
      return 1;
    }
  }
}

uint64_t boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::orientation_test::eval<boost::polygon::detail::point_2d<int>>(int *a1, int *a2, int *a3)
{
  double v3 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(*a1 - (uint64_t)*a2, a1[1] - (uint64_t)a2[1], *a2 - (uint64_t)*a3, a2[1] - (uint64_t)a3[1]);
  if (v3 >= 0.0) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = -1;
  }
  if (v3 == 0.0) {
    return 0;
  }
  else {
    return v4;
  }
}

double boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 >= 0) {
    uint64_t v4 = a1;
  }
  else {
    uint64_t v4 = -a1;
  }
  if (a2 >= 0) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = -a2;
  }
  if (a3 >= 0) {
    uint64_t v6 = a3;
  }
  else {
    uint64_t v6 = -a3;
  }
  if (a4 >= 0) {
    uint64_t v7 = a4;
  }
  else {
    uint64_t v7 = -a4;
  }
  unint64_t v8 = v7 * v4;
  unint64_t v9 = v6 * v5;
  uint64_t v10 = a2 ^ a3;
  double result = (double)(v8 - v9);
  double v12 = (double)(v9 - v8);
  if (v8 < v9) {
    double result = -v12;
  }
  if (v10 < 0) {
    double result = (double)(v8 + v9);
  }
  if (v8 > v9) {
    double v12 = -(double)(v8 - v9);
  }
  if (v10 >= 0) {
    double v12 = -(double)(v8 + v9);
  }
  if ((a4 ^ a1) < 0) {
    return v12;
  }
  return result;
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(uint64_t a1, int *a2, int *a3, long long *a4, uint64_t a5)
{
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>((int *)a1, a2, a3, a5);
  if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a5, (int *)a4, a3))
  {
    long long v11 = *(_OWORD *)a3;
    long long v12 = *((_OWORD *)a3 + 1);
    uint64_t v13 = *((void *)a3 + 4);
    uint64_t v14 = *((void *)a4 + 4);
    long long v15 = a4[1];
    *(_OWORD *)a3 = *a4;
    *((_OWORD *)a3 + 1) = v15;
    *((void *)a3 + 4) = v14;
    *((void *)a4 + 4) = v13;
    *a4 = v11;
    a4[1] = v12;
    if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a5, a3, a2))
    {
      long long v16 = *(_OWORD *)a2;
      long long v17 = *((_OWORD *)a2 + 1);
      uint64_t v18 = *((void *)a2 + 4);
      uint64_t v19 = *((void *)a3 + 4);
      long long v20 = *((_OWORD *)a3 + 1);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_OWORD *)a2 + 1) = v20;
      *((void *)a2 + 4) = v19;
      *((void *)a3 + 4) = v18;
      *(_OWORD *)a3 = v16;
      *((_OWORD *)a3 + 1) = v17;
      if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a5, a2, (int *)a1))
      {
        __n128 result = *(__n128 *)a1;
        long long v21 = *(_OWORD *)(a1 + 16);
        uint64_t v22 = *(void *)(a1 + 32);
        uint64_t v23 = *((void *)a2 + 4);
        long long v24 = *((_OWORD *)a2 + 1);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v24;
        *(void *)(a1 + 32) = v23;
        *((void *)a2 + 4) = v22;
        *(__n128 *)a2 = result;
        *((_OWORD *)a2 + 1) = v21;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(uint64_t a1, int *a2, int *a3, long long *a4, long long *a5, uint64_t a6)
{
  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(a1, a2, a3, a4, a6);
  if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a6, (int *)a5, (int *)a4))
  {
    long long v13 = *a4;
    long long v14 = a4[1];
    uint64_t v15 = *((void *)a4 + 4);
    uint64_t v16 = *((void *)a5 + 4);
    long long v17 = a5[1];
    *a4 = *a5;
    a4[1] = v17;
    *((void *)a4 + 4) = v16;
    *((void *)a5 + 4) = v15;
    *a5 = v13;
    a5[1] = v14;
    if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a6, (int *)a4, a3))
    {
      long long v18 = *(_OWORD *)a3;
      long long v19 = *((_OWORD *)a3 + 1);
      uint64_t v20 = *((void *)a3 + 4);
      uint64_t v21 = *((void *)a4 + 4);
      long long v22 = a4[1];
      *(_OWORD *)a3 = *a4;
      *((_OWORD *)a3 + 1) = v22;
      *((void *)a3 + 4) = v21;
      *((void *)a4 + 4) = v20;
      *a4 = v18;
      a4[1] = v19;
      if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a6, a3, a2))
      {
        long long v23 = *(_OWORD *)a2;
        long long v24 = *((_OWORD *)a2 + 1);
        uint64_t v25 = *((void *)a2 + 4);
        uint64_t v26 = *((void *)a3 + 4);
        long long v27 = *((_OWORD *)a3 + 1);
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *((_OWORD *)a2 + 1) = v27;
        *((void *)a2 + 4) = v26;
        *((void *)a3 + 4) = v25;
        *(_OWORD *)a3 = v23;
        *((_OWORD *)a3 + 1) = v24;
        if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a6, a2, (int *)a1))
        {
          __n128 result = *(__n128 *)a1;
          long long v28 = *(_OWORD *)(a1 + 16);
          uint64_t v29 = *(void *)(a1 + 32);
          uint64_t v30 = *((void *)a2 + 4);
          long long v31 = *((_OWORD *)a2 + 1);
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(_OWORD *)(a1 + 16) = v31;
          *(void *)(a1 + 32) = v30;
          *((void *)a2 + 4) = v29;
          *(__n128 *)a2 = result;
          *((_OWORD *)a2 + 1) = v28;
        }
      }
    }
  }
  return result;
}

long long *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*,boost::polygon::detail::site_event<int>*>(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
  if ((long long *)a1 != a2)
  {
    uint64_t v8 = (uint64_t)a2 - a1;
    uint64_t v9 = ((uint64_t)a2 - a1) / 40;
    if ((uint64_t)a2 - a1 >= 41)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      long long v12 = (__n128 *)(a1 + 40 * v10);
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(a1, a4, v9, v12);
        long long v12 = (__n128 *)((char *)v12 - 40);
        --v11;
      }
      while (v11);
    }
    long long v13 = a2;
    if (a2 != a3)
    {
      long long v14 = a2;
      do
      {
        if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a4, (int *)v14, (int *)a1))
        {
          long long v15 = *v14;
          long long v16 = v14[1];
          uint64_t v17 = *((void *)v14 + 4);
          uint64_t v18 = *(void *)(a1 + 32);
          long long v19 = *(_OWORD *)(a1 + 16);
          *long long v14 = *(_OWORD *)a1;
          v14[1] = v19;
          *((void *)v14 + 4) = v18;
          *(void *)(a1 + 32) = v17;
          *(_OWORD *)a1 = v15;
          *(_OWORD *)(a1 + 16) = v16;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(a1, a4, v9, (__n128 *)a1);
        }
        long long v14 = (long long *)((char *)v14 + 40);
      }
      while (v14 != a3);
      long long v13 = a3;
    }
    if (v8 >= 41)
    {
      int64_t v20 = v8 / 0x28uLL;
      uint64_t v21 = (uint64_t)a2 - 40;
      do
      {
        __n128 v27 = *(__n128 *)a1;
        long long v28 = *(_OWORD *)(a1 + 16);
        uint64_t v29 = *(void *)(a1 + 32);
        uint64_t v22 = std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(a1, a4, v20);
        if (v21 == v22)
        {
          *(__n128 *)uint64_t v22 = v27;
          *(_OWORD *)(v22 + 16) = v28;
          *(void *)(v22 + 32) = v29;
        }
        else
        {
          __n128 v23 = *(__n128 *)v21;
          long long v24 = *(_OWORD *)(v21 + 16);
          *(void *)(v22 + 32) = *(void *)(v21 + 32);
          *(__n128 *)uint64_t v22 = v23;
          *(_OWORD *)(v22 + 16) = v24;
          *(void *)(v21 + 32) = v29;
          *(__n128 *)uint64_t v21 = v27;
          *(_OWORD *)(v21 + 16) = v28;
          std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(a1, v22 + 40, a4, 0xCCCCCCCCCCCCCCCDLL * ((v22 + 40 - a1) >> 3));
        }
        v21 -= 40;
      }
      while (v20-- > 2);
    }
    return v13;
  }
  return a3;
}

__n128 std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(uint64_t a1, uint64_t a2, uint64_t a3, __n128 *a4)
{
  unint64_t v6 = a3 - 2;
  if (a3 >= 2)
  {
    uint64_t v26 = v4;
    uint64_t v27 = v5;
    uint64_t v7 = a4;
    int64_t v9 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) >= (uint64_t)(0xCCCCCCCCCCCCCCCDLL * (((uint64_t)a4 - a1) >> 3)))
    {
      int64_t v12 = (0x999999999999999ALL * (((uint64_t)a4 - a1) >> 3)) | 1;
      long long v13 = (long long *)(a1 + 40 * v12);
      int64_t v14 = 0x999999999999999ALL * (((uint64_t)a4 - a1) >> 3) + 2;
      if (v14 < a3
        && boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a2, (int *)(a1 + 40 * v12), (int *)v13 + 10))
      {
        long long v13 = (long long *)((char *)v13 + 40);
        int64_t v12 = v14;
      }
      if ((boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a2, (int *)v13, (int *)v7) & 1) == 0)
      {
        __n128 v16 = v7[1];
        __n128 v23 = *v7;
        __n128 v24 = v16;
        uint64_t v25 = v7[2].n128_i64[0];
        do
        {
          uint64_t v17 = (__n128 *)v13;
          __n128 v18 = (__n128)*v13;
          long long v19 = v13[1];
          v7[2].n128_u64[0] = *((void *)v13 + 4);
          *uint64_t v7 = v18;
          v7[1] = (__n128)v19;
          if (v9 < v12) {
            break;
          }
          uint64_t v20 = (2 * v12) | 1;
          long long v13 = (long long *)(a1 + 40 * v20);
          uint64_t v21 = 2 * v12 + 2;
          if (v21 < a3)
          {
            if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a2, (int *)(a1 + 40 * v20), (int *)v13 + 10))
            {
              long long v13 = (long long *)((char *)v13 + 40);
              uint64_t v20 = v21;
            }
          }
          uint64_t v7 = v17;
          int64_t v12 = v20;
        }
        while (!boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a2, (int *)v13, (int *)&v23));
        __n128 result = v23;
        __n128 v22 = v24;
        v17[2].n128_u64[0] = v25;
        *uint64_t v17 = result;
        v17[1] = v22;
      }
    }
  }
  return result;
}

uint64_t std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = a3 - 2;
  if (a3 < 2) {
    uint64_t v7 = a3 - 1;
  }
  uint64_t v8 = v7 >> 1;
  do
  {
    uint64_t v9 = a1 + 40 * v6 + 40;
    uint64_t v10 = (2 * v6) | 1;
    uint64_t v11 = 2 * v6 + 2;
    if (v11 < a3
      && boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a2, (int *)(a1 + 40 * v6 + 40), (int *)(a1 + 40 * v6 + 80)))
    {
      v9 += 40;
      uint64_t v10 = v11;
    }
    long long v12 = *(_OWORD *)v9;
    long long v13 = *(_OWORD *)(v9 + 16);
    *(void *)(a1 + 32) = *(void *)(v9 + 32);
    *(_OWORD *)a1 = v12;
    *(_OWORD *)(a1 + 16) = v13;
    a1 = v9;
    uint64_t v6 = v10;
  }
  while (v10 <= v8);
  return v9;
}

double std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4 >= 2)
  {
    uint64_t v20 = v4;
    uint64_t v21 = v5;
    unint64_t v8 = (unint64_t)(a4 - 2) >> 1;
    uint64_t v9 = (long long *)(a1 + 40 * v8);
    uint64_t v10 = (long long *)(a2 - 40);
    if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)v9, (int *)(a2 - 40)))
    {
      long long v12 = v10[1];
      long long v17 = *v10;
      long long v18 = v12;
      uint64_t v19 = *((void *)v10 + 4);
      do
      {
        long long v13 = v9;
        long long v14 = *v9;
        long long v15 = v9[1];
        *((void *)v10 + 4) = *((void *)v9 + 4);
        *uint64_t v10 = v14;
        v10[1] = v15;
        if (!v8) {
          break;
        }
        unint64_t v8 = (v8 - 1) >> 1;
        uint64_t v9 = (long long *)(a1 + 40 * v8);
        uint64_t v10 = v13;
      }
      while ((boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)v9, (int *)&v17) & 1) != 0);
      double result = *(double *)&v17;
      long long v16 = v18;
      *long long v13 = v17;
      v13[1] = v16;
      *((void *)v13 + 4) = v19;
    }
  }
  return result;
}

unsigned int *std::__unique[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<boost::polygon::detail::site_event<int> *>,std::__wrap_iter<boost::polygon::detail::site_event<int> *>,std::__equal_to &>(unsigned int *a1, unsigned int *a2)
{
  double result = std::__adjacent_find[abi:ne180100]<std::__wrap_iter<boost::polygon::detail::site_event<int> *>,std::__wrap_iter<boost::polygon::detail::site_event<int> *>,std::__equal_to &>(a1, a2);
  if (result != a2)
  {
    for (uint64_t i = result + 20; i != a2; i += 10)
    {
      if (*result != *i || result[1] != i[1] || result[2] != i[2] || result[3] != i[3])
      {
        long long v5 = *(_OWORD *)i;
        long long v6 = *((_OWORD *)i + 1);
        *((void *)result + 9) = *((void *)i + 4);
        *(_OWORD *)(result + 14) = v6;
        *(_OWORD *)(result + 10) = v5;
        result += 10;
      }
    }
    result += 10;
  }
  return result;
}

unsigned int *std::__adjacent_find[abi:ne180100]<std::__wrap_iter<boost::polygon::detail::site_event<int> *>,std::__wrap_iter<boost::polygon::detail::site_event<int> *>,std::__equal_to &>(unsigned int *result, unsigned int *a2)
{
  if (result != a2)
  {
    uint64_t v2 = result + 10;
    if (result + 10 == a2)
    {
      return a2;
    }
    else
    {
      unsigned int v3 = *result;
      while (1)
      {
        unsigned int v4 = v3;
        unsigned int v3 = *v2;
        if (__PAIR64__(*(v2 - 9), v4) == *(void *)v2 && *(v2 - 8) == v2[2] && *(v2 - 7) == v2[3]) {
          break;
        }
        v2 += 10;
        if (v2 == a2) {
          return a2;
        }
      }
      return v2 - 10;
    }
  }
  return result;
}

void boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::_process_single_site<int>(void **a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 32) & 0x1FLL;
  unint64_t v7 = (unint64_t)a1[2];
  uint64_t v5 = (uint64_t)(a1 + 2);
  unint64_t v6 = v7;
  unint64_t v8 = *(void **)(v5 - 8);
  if ((unint64_t)v8 >= v7)
  {
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (((char *)v8 - (unsigned char *)*a1) >> 3);
    unint64_t v11 = v10 + 1;
    if (v10 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - (void)*a1) >> 3);
    if (2 * v12 > v11) {
      unint64_t v11 = 2 * v12;
    }
    if (v12 >= 0x555555555555555) {
      unint64_t v13 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v13 = v11;
    }
    if (v13) {
      long long v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::voronoi_cell<double>>>(v5, v13);
    }
    else {
      long long v14 = 0;
    }
    long long v15 = &v14[24 * v10];
    long long v16 = &v14[24 * v13];
    *(void *)long long v15 = v3;
    *((void *)v15 + 1) = 0;
    *((void *)v15 + 2) = v4;
    uint64_t v9 = v15 + 24;
    long long v18 = (char *)*a1;
    long long v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        long long v19 = *(_OWORD *)(v17 - 24);
        *((void *)v15 - 1) = *((void *)v17 - 1);
        *(_OWORD *)(v15 - 24) = v19;
        v15 -= 24;
        v17 -= 24;
      }
      while (v17 != v18);
      long long v17 = (char *)*a1;
    }
    *a1 = v15;
    a1[1] = v9;
    a1[2] = v16;
    if (v17) {
      operator delete(v17);
    }
  }
  else
  {
    *unint64_t v8 = v3;
    v8[1] = 0;
    uint64_t v9 = v8 + 3;
    _OWORD v8[2] = v4;
  }
  a1[1] = v9;
}

uint64_t *boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::init_beach_line_collinear_sites<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>(uint64_t *result, char **a2)
{
  uint64_t v2 = result[1];
  if (v2 + 40 != result[4])
  {
    uint64_t v4 = result;
    uint64_t v5 = (uint64_t **)(result + 16);
    unint64_t v6 = result + 17;
    do
    {
      long long v7 = *(_OWORD *)(v2 + 16);
      long long v14 = *(_OWORD *)v2;
      long long v15 = v7;
      *(void *)long long v16 = *(void *)(v2 + 32);
      long long v8 = *(_OWORD *)(v2 + 56);
      *(_OWORD *)&v16[8] = *(_OWORD *)(v2 + 40);
      *(_OWORD *)&v16[24] = v8;
      *(void *)&v16[40] = *(void *)(v2 + 72);
      inserted = boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::_insert_new_edge<int>(a2, v2, v2 + 40);
      void v11[2] = *(_OWORD *)v16;
      v11[3] = *(_OWORD *)&v16[16];
      v11[4] = *(_OWORD *)&v16[32];
      v11[0] = v14;
      v11[1] = v15;
      uint64_t v12 = 0;
      unint64_t v13 = inserted;
      double result = std::__tree<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__map_value_compare<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>,false>,std::allocator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>>::__emplace_hint_unique_key_args<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::pair<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>(v5, v6, (uint64_t)v11, v11);
      uint64_t v10 = v2 + 80;
      v2 += 40;
    }
    while (v10 != v4[4]);
  }
  return result;
}

uint64_t *boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::insert_new_arc<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, void *a5, char **a6)
{
  uint64_t v52 = *MEMORY[0x263EF8340];
  long long v9 = a2[1];
  long long v46 = *a2;
  long long v47 = v9;
  uint64_t v10 = *((void *)a2 + 4);
  long long v11 = *(_OWORD *)(a4 + 16);
  *(_OWORD *)&v48[8] = *(_OWORD *)a4;
  *(_OWORD *)&v48[24] = *(_OWORD *)(a4 + 16);
  uint64_t v12 = *(void *)(a4 + 32);
  *(void *)long long v48 = v10;
  *(void *)&v48[40] = v12;
  long long v44 = *(_OWORD *)a4;
  long long v45 = v11;
  uint64_t v13 = *(void *)(a4 + 32);
  long long v14 = *(_OWORD *)(a3 + 16);
  long long v41 = *(_OWORD *)a3;
  long long v42 = v14;
  uint64_t v43 = *(void *)(a3 + 32);
  if (*(_DWORD *)a4 != *(_DWORD *)(a4 + 8) || *(_DWORD *)(a4 + 4) != *(_DWORD *)(a4 + 12)) {
    v13 ^= 0x20uLL;
  }
  inserted = boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::_insert_new_edge<int>(a6, a3, a4);
  long long v36 = v44;
  long long v37 = v45;
  *(_OWORD *)&v38[8] = v41;
  *(void *)uint64_t v38 = v13;
  *(_OWORD *)&v38[24] = v42;
  *(void *)&v38[40] = v43;
  uint64_t v39 = 0;
  float64x2_t v40 = v16;
  long long v17 = std::__tree<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__map_value_compare<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>,false>,std::allocator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>>::__emplace_hint_unique_key_args<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::pair<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>> const,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>((uint64_t **)(a1 + 128), a5, (uint64_t)&v36, &v36);
  if (*(_DWORD *)a4 != *(_DWORD *)(a4 + 8) || *(_DWORD *)(a4 + 4) != *(_DWORD *)(a4 + 12))
  {
    long long v18 = *(_OWORD *)a4;
    long long v19 = *(_OWORD *)(a4 + 16);
    *(void *)uint64_t v51 = *(void *)(a4 + 32);
    *(_OWORD *)&v51[24] = v19;
    *(_OWORD *)&v51[8] = v18;
    *(_OWORD *)uint64_t v38 = *(_OWORD *)v51;
    *(_OWORD *)&v38[16] = *(_OWORD *)&v51[16];
    long long v49 = v18;
    long long v50 = v19;
    long long v36 = v18;
    long long v37 = v19;
    *(void *)&v38[32] = *((void *)&v19 + 1);
    *(void *)&v38[40] = *(void *)v51 ^ 0x20;
    uint64_t v39 = 0;
    float64x2_t v40 = 0;
    long long v17 = std::__tree<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__map_value_compare<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>,false>,std::allocator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>>::__emplace_hint_unique_key_args<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::pair<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>> const,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>((uint64_t **)(a1 + 128), v17, (uint64_t)&v36, &v36);
    unint64_t v20 = *(void *)(a1 + 56);
    uint64_t v21 = *(void *)(a4 + 8);
    __n128 v22 = *(void **)(a1 + 48);
    if ((unint64_t)v22 >= v20)
    {
      uint64_t v24 = *(void *)(a1 + 40);
      uint64_t v25 = ((uint64_t)v22 - v24) >> 4;
      unint64_t v26 = v25 + 1;
      if ((unint64_t)(v25 + 1) >> 60) {
        std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v27 = v20 - v24;
      if (v27 >> 3 > v26) {
        unint64_t v26 = v27 >> 3;
      }
      if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v28 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v28 = v26;
      }
      if (v28) {
        uint64_t v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CGPoint>>(a1 + 56, v28);
      }
      else {
        uint64_t v29 = 0;
      }
      uint64_t v30 = &v29[16 * v25];
      long long v31 = &v29[16 * v28];
      *(void *)uint64_t v30 = v21;
      *((void *)v30 + 1) = v17;
      uint64_t v23 = (uint64_t)(v30 + 16);
      long long v33 = *(char **)(a1 + 40);
      long long v32 = *(char **)(a1 + 48);
      if (v32 != v33)
      {
        do
        {
          *((_OWORD *)v30 - 1) = *((_OWORD *)v32 - 1);
          v30 -= 16;
          v32 -= 16;
        }
        while (v32 != v33);
        long long v32 = *(char **)(a1 + 40);
      }
      *(void *)(a1 + 40) = v30;
      *(void *)(a1 + 48) = v23;
      *(void *)(a1 + 56) = v31;
      if (v32) {
        operator delete(v32);
      }
    }
    else
    {
      *__n128 v22 = v21;
      v22[1] = v17;
      uint64_t v23 = (uint64_t)(v22 + 2);
    }
    *(void *)(a1 + 48) = v23;
    uint64_t v34 = *(void *)(a1 + 40);
    LOBYTE(v36) = *(unsigned char *)(a1 + 64);
    std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::end_point_comparison &,std::__wrap_iter<std::pair<boost::polygon::detail::point_2d<int>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>> *>>(v34, v23, (uint64_t)&v36, (v23 - v34) >> 4);
  }
  *(_OWORD *)uint64_t v38 = *(_OWORD *)v48;
  *(_OWORD *)&v38[16] = *(_OWORD *)&v48[16];
  *(_OWORD *)&v38[32] = *(_OWORD *)&v48[32];
  long long v36 = v46;
  long long v37 = v47;
  uint64_t v39 = 0;
  float64x2_t v40 = inserted;
  return std::__tree<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__map_value_compare<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>,false>,std::allocator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>>::__emplace_hint_unique_key_args<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::pair<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>> const,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>((uint64_t **)(a1 + 128), v17, (uint64_t)&v36, &v36);
}

char *boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::_insert_new_edge<int>(char **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a2 + 16);
  unint64_t v7 = *(void *)(a3 + 16);
  unsigned int v8 = boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::is_linear_edge<boost::polygon::detail::site_event<int>>((uint64_t)a1, (int *)a2, (int *)a3);
  int v9 = boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::is_primary_edge<boost::polygon::detail::site_event<int>>((uint64_t)a1, (int *)a2, (int *)a3);
  unint64_t v10 = (unint64_t)a1[8];
  long long v11 = a1 + 6;
  if (v9) {
    uint64_t v12 = v8 | 2;
  }
  else {
    uint64_t v12 = v8;
  }
  unint64_t v13 = (unint64_t)a1[7];
  if (v13 >= v10)
  {
    unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - *v11) >> 4);
    unint64_t v16 = v15 + 1;
    if (v15 + 1 > 0x555555555555555) {
      goto LABEL_67;
    }
    unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - *v11) >> 4);
    if (2 * v17 > v16) {
      unint64_t v16 = 2 * v17;
    }
    if (v17 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v18 = 0x555555555555555;
    }
    else {
      unint64_t v18 = v16;
    }
    if (v18) {
      long long v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::voronoi_edge<double>>>((uint64_t)(a1 + 8), v18);
    }
    else {
      long long v19 = 0;
    }
    unint64_t v20 = &v19[48 * v15];
    uint64_t v21 = &v19[48 * v18];
    *(_OWORD *)unint64_t v20 = 0u;
    *((_OWORD *)v20 + 1) = 0u;
    *((void *)v20 + 4) = 0;
    *((void *)v20 + 5) = v12;
    long long v14 = v20 + 48;
    uint64_t v23 = a1[6];
    __n128 v22 = a1[7];
    if (v22 != v23)
    {
      do
      {
        long long v24 = *((_OWORD *)v22 - 3);
        long long v25 = *((_OWORD *)v22 - 1);
        *((_OWORD *)v20 - 2) = *((_OWORD *)v22 - 2);
        *((_OWORD *)v20 - 1) = v25;
        *((_OWORD *)v20 - 3) = v24;
        v20 -= 48;
        v22 -= 48;
      }
      while (v22 != v23);
      __n128 v22 = (char *)*v11;
    }
    a1[6] = v20;
    a1[7] = v14;
    a1[8] = v21;
    if (v22) {
      operator delete(v22);
    }
  }
  else
  {
    *(_OWORD *)unint64_t v13 = 0u;
    *(_OWORD *)(v13 + 16) = 0u;
    *(void *)(v13 + 32) = 0;
    *(void *)(v13 + 40) = v12;
    long long v14 = (char *)(v13 + 48);
  }
  a1[7] = v14;
  unint64_t v26 = (unint64_t)a1[8];
  if ((unint64_t)v14 < v26)
  {
    *(_OWORD *)long long v14 = 0u;
    *((_OWORD *)v14 + 1) = 0u;
    *((void *)v14 + 4) = 0;
    *((void *)v14 + 5) = v12;
    uint64_t v27 = v14 + 48;
    goto LABEL_36;
  }
  int v28 = v6;
  int v29 = v7;
  unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v14[-*v11] >> 4);
  if (v7 + 1 > 0x555555555555555) {
LABEL_67:
  }
    std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
  unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v26 - *v11) >> 4);
  uint64_t v31 = 2 * v30;
  if (2 * v30 <= v7 + 1) {
    uint64_t v31 = v7 + 1;
  }
  if (v30 >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v32 = 0x555555555555555;
  }
  else {
    unint64_t v32 = v31;
  }
  if (v32) {
    long long v33 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::voronoi_edge<double>>>((uint64_t)(a1 + 8), v32);
  }
  else {
    long long v33 = 0;
  }
  uint64_t v34 = &v33[48 * v7];
  uint64_t v35 = &v33[48 * v32];
  *(_OWORD *)uint64_t v34 = 0u;
  *((_OWORD *)v34 + 1) = 0u;
  *((void *)v34 + 4) = 0;
  *((void *)v34 + 5) = v12;
  uint64_t v27 = v34 + 48;
  long long v37 = a1[6];
  long long v36 = a1[7];
  LODWORD(v7) = v29;
  if (v36 != v37)
  {
    do
    {
      long long v38 = *((_OWORD *)v36 - 3);
      long long v39 = *((_OWORD *)v36 - 1);
      *((_OWORD *)v34 - 2) = *((_OWORD *)v36 - 2);
      *((_OWORD *)v34 - 1) = v39;
      *((_OWORD *)v34 - 3) = v38;
      v34 -= 48;
      v36 -= 48;
    }
    while (v36 != v37);
    long long v36 = (char *)*v11;
  }
  LODWORD(v6) = v28;
  a1[6] = v34;
  a1[7] = v27;
  a1[8] = v35;
  if (v36) {
    operator delete(v36);
  }
LABEL_36:
  a1[7] = v27;
  float64x2_t v40 = *a1;
  long long v41 = a1[1];
  if (*a1 == v41)
  {
    uint64_t v42 = *(void *)(a2 + 24);
    uint64_t v43 = *(void *)(a2 + 32) & 0x1FLL;
    unint64_t v44 = (unint64_t)a1[2];
    if ((unint64_t)v40 >= v44)
    {
      unint64_t v45 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v44 - (void)v40) >> 3);
      uint64_t v46 = 2 * v45;
      if (2 * v45 <= 1) {
        uint64_t v46 = 1;
      }
      if (v45 >= 0x555555555555555) {
        unint64_t v47 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v47 = v46;
      }
      long long v48 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::voronoi_cell<double>>>((uint64_t)(a1 + 2), v47);
      long long v50 = &v48[24 * v49];
      *(void *)long long v48 = v42;
      *((void *)v48 + 1) = 0;
      *((void *)v48 + 2) = v43;
      long long v41 = v48 + 24;
      uint64_t v52 = *a1;
      uint64_t v51 = a1[1];
      if (v51 != *a1)
      {
        do
        {
          long long v53 = *(_OWORD *)(v51 - 24);
          *((void *)v48 - 1) = *((void *)v51 - 1);
          *(_OWORD *)(v48 - 24) = v53;
          v48 -= 24;
          v51 -= 24;
        }
        while (v51 != v52);
        uint64_t v51 = *a1;
      }
      *a1 = v48;
      a1[1] = v41;
      a1[2] = v50;
      if (v51) {
        operator delete(v51);
      }
    }
    else
    {
      *(void *)float64x2_t v40 = v42;
      *((void *)v40 + 1) = 0;
      long long v41 = v40 + 24;
      *((void *)v40 + 2) = v43;
    }
    a1[1] = v41;
  }
  uint64_t v54 = *(void *)(a3 + 24);
  uint64_t v55 = *(void *)(a3 + 32) & 0x1FLL;
  unint64_t v56 = (unint64_t)a1[2];
  if ((unint64_t)v41 >= v56)
  {
    unint64_t v58 = 0xAAAAAAAAAAAAAAABLL * ((v41 - *a1) >> 3);
    if (v58 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v59 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v56 - (void)*a1) >> 3);
    uint64_t v60 = 2 * v59;
    if (2 * v59 <= v58 + 1) {
      uint64_t v60 = v58 + 1;
    }
    if (v59 >= 0x555555555555555) {
      unint64_t v61 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v61 = v60;
    }
    if (v61) {
      unsigned int v62 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::voronoi_cell<double>>>((uint64_t)(a1 + 2), v61);
    }
    else {
      unsigned int v62 = 0;
    }
    long long v63 = &v62[24 * v58];
    long long v64 = &v62[24 * v61];
    *(void *)long long v63 = v54;
    *((void *)v63 + 1) = 0;
    *((void *)v63 + 2) = v55;
    unint64_t v57 = v63 + 24;
    BOOL v66 = *a1;
    signed int v65 = a1[1];
    if (v65 != *a1)
    {
      do
      {
        long long v67 = *(_OWORD *)(v65 - 24);
        *((void *)v63 - 1) = *((void *)v65 - 1);
        *(_OWORD *)(v63 - 24) = v67;
        v63 -= 24;
        v65 -= 24;
      }
      while (v65 != v66);
      signed int v65 = *a1;
    }
    *a1 = v63;
    a1[1] = v57;
    a1[2] = v64;
    if (v65) {
      operator delete(v65);
    }
  }
  else
  {
    *(void *)long long v41 = v54;
    *((void *)v41 + 1) = 0;
    unint64_t v57 = v41 + 24;
    *((void *)v41 + 2) = v55;
  }
  a1[1] = v57;
  float v68 = *a1;
  *((void *)v14 - 6) = &(*a1)[24 * (int)v6];
  long long v69 = v14 - 48;
  *((void *)v27 - 6) = &v68[24 * (int)v7];
  long long v70 = v27 - 48;
  *((void *)v69 + 2) = v70;
  *((void *)v70 + 2) = v69;
  return v69;
}

uint64_t boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::is_linear_edge<boost::polygon::detail::site_event<int>>(uint64_t a1, int *a2, int *a3)
{
  if (!boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::is_primary_edge<boost::polygon::detail::site_event<int>>(a1, a2, a3))return 1; {
  BOOL v6 = *a2 != a2[2] || a2[1] != a2[3];
  }
  BOOL v8 = *a3 != a3[2] || a3[1] != a3[3];
  return v6 ^ v8 ^ 1u;
}

uint64_t boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::is_primary_edge<boost::polygon::detail::site_event<int>>(uint64_t a1, int *a2, int *a3)
{
  int v4 = *a2;
  int v3 = a2[1];
  int v6 = a2[2];
  int v5 = a2[3];
  BOOL v8 = *a2 != v6 || v3 != v5;
  int v9 = *a3;
  int v10 = a3[2];
  if (*a3 == v10)
  {
    int v11 = a3[1];
    int v12 = a3[3];
    BOOL v13 = v11 != v12;
    if (v8 && v11 == v12)
    {
      BOOL v16 = v6 != v9 || v5 != v11;
      return (v4 != v9 || v3 != v11) && v16;
    }
  }
  else
  {
    BOOL v13 = 1;
  }
  if (v8 || !v13) {
    return 1;
  }
  if (v9 == v4 && a3[1] == v3) {
    return 0;
  }
  if (v10 != v4) {
    return 1;
  }
  return a3[3] != v3;
}

uint64_t *std::__tree<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__map_value_compare<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>,false>,std::allocator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>>::__emplace_hint_unique_key_args<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::pair<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>> const,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>(uint64_t **a1, void *a2, uint64_t a3, _OWORD *a4)
{
  int v6 = std::__tree<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__map_value_compare<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>,false>,std::allocator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>>::__find_equal<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>(a1, a2, &v14, &v13, a3);
  unint64_t v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    BOOL v8 = (uint64_t **)v6;
    unint64_t v7 = (uint64_t *)operator new(0x80uLL);
    long long v9 = a4[3];
    *((_OWORD *)v7 + 4) = a4[2];
    *((_OWORD *)v7 + 5) = v9;
    long long v10 = a4[5];
    *((_OWORD *)v7 + 6) = a4[4];
    *((_OWORD *)v7 + 7) = v10;
    long long v11 = a4[1];
    *((_OWORD *)v7 + 2) = *a4;
    *((_OWORD *)v7 + 3) = v11;
    std::__tree<std::__value_type<std::string,unsigned short>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned short>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned short>>>::__insert_node_at(a1, v14, v8, v7);
  }
  return v7;
}

uint64_t *std::__tree<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__map_value_compare<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>,false>,std::allocator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>>::__find_equal<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>(void *a1, void *a2, void *a3, uint64_t *a4, uint64_t a5)
{
  long long v9 = a1 + 1;
  if (a1 + 1 != a2
    && !boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>::operator()((uint64_t)(a1 + 3), a5, (uint64_t)(a2 + 4)))
  {
    if (!boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>::operator()((uint64_t)(a1 + 3), (uint64_t)(a2 + 4), a5))
    {
      *a3 = a2;
      *a4 = (uint64_t)a2;
      return a4;
    }
    a4 = a2 + 1;
    uint64_t v13 = a2[1];
    if (v13)
    {
      uint64_t v14 = (void *)a2[1];
      do
      {
        unint64_t v15 = v14;
        uint64_t v14 = (void *)*v14;
      }
      while (v14);
    }
    else
    {
      unint64_t v18 = a2;
      do
      {
        unint64_t v15 = (void *)v18[2];
        BOOL v17 = *v15 == (void)v18;
        unint64_t v18 = v15;
      }
      while (!v17);
    }
    if (v15 != v9)
    {
      if (!boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>::operator()((uint64_t)(a1 + 3), a5, (uint64_t)(v15 + 4)))goto LABEL_28; {
      uint64_t v13 = *a4;
      }
    }
    if (v13)
    {
      *a3 = v15;
      return v15;
    }
    else
    {
      *a3 = a2;
    }
    return a4;
  }
  if ((void *)*a1 == a2)
  {
    int v12 = a2;
LABEL_16:
    if (*a2)
    {
      *a3 = v12;
      return v12 + 1;
    }
    else
    {
      *a3 = a2;
      return a2;
    }
  }
  long long v11 = (void *)*a2;
  if (*a2)
  {
    do
    {
      int v12 = v11;
      long long v11 = (void *)v11[1];
    }
    while (v11);
  }
  else
  {
    BOOL v16 = a2;
    do
    {
      int v12 = (void *)v16[2];
      BOOL v17 = *v12 == (void)v16;
      BOOL v16 = v12;
    }
    while (v17);
  }
  if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>::operator()((uint64_t)(a1 + 3), (uint64_t)(v12 + 4), a5))goto LABEL_16; {
LABEL_28:
  }

  return std::__tree<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__map_value_compare<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>,false>,std::allocator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>>::__find_equal<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>((uint64_t)a1, a3, a5);
}

void *std::__tree<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__map_value_compare<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>,false>,std::allocator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>>::__find_equal<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>(uint64_t a1, void *a2, uint64_t a3)
{
  int v5 = (void *)(a1 + 8);
  int v4 = *(void **)(a1 + 8);
  if (v4)
  {
    uint64_t v7 = a1 + 24;
    do
    {
      while (1)
      {
        BOOL v8 = v4;
        uint64_t v9 = (uint64_t)(v4 + 4);
        if (!boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>::operator()(v7, a3, (uint64_t)(v4 + 4)))break; {
        int v4 = (void *)*v8;
        }
        int v5 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (!boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>::operator()(v7, v9, a3))break; {
      int v5 = v8 + 1;
      }
      int v4 = (void *)v8[1];
    }
    while (v4);
  }
  else
  {
    BOOL v8 = (void *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

uint64_t boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4 = *(void *)(a2 + 16);
  unint64_t v5 = *(void *)(a2 + 56);
  uint64_t v6 = 40;
  if (v4 <= v5) {
    uint64_t v7 = 40;
  }
  else {
    uint64_t v7 = 0;
  }
  if (v4 <= v5) {
    uint64_t v8 = a2 + 40;
  }
  else {
    uint64_t v8 = a2;
  }
  unint64_t v9 = *(void *)(a3 + 16);
  unint64_t v10 = *(void *)(a3 + 56);
  if (v9 <= v10)
  {
    uint64_t v11 = a3 + 40;
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v11 = a3;
  }
  int v12 = *(_DWORD *)(a2 + v7);
  int v13 = *(_DWORD *)(a3 + v6);
  if (v12 >= v13)
  {
    if (v12 <= v13)
    {
      unint64_t v15 = *(void *)(v8 + 16);
      unint64_t v16 = *(void *)(v11 + 16);
      if (v15 == v16)
      {
        if (v4 == v5)
        {
          unint64_t v17 = *(unsigned int *)(a2 + 4);
        }
        else if (v4 > v5)
        {
          unint64_t v17 = *(unsigned int *)(a2 + 4) | 0x100000000;
        }
        else
        {
          unint64_t v17 = *(unsigned int *)(a2 + 44) | 0xFFFFFFFF00000000;
        }
        if (v9 == v10)
        {
          unint64_t v29 = *(unsigned int *)(a3 + 4);
        }
        else if (v9 > v10)
        {
          unint64_t v29 = *(unsigned int *)(a3 + 4) | 0x100000000;
        }
        else
        {
          unint64_t v29 = *(unsigned int *)(a3 + 44) | 0xFFFFFFFF00000000;
        }
        BOOL v30 = (int)v29 >= (int)v17 && SHIDWORD(v17) < SHIDWORD(v29);
        unsigned int v31 = v30;
        if ((int)v17 >= (int)v29) {
          return v31;
        }
        else {
          return 1;
        }
      }
      else if (v15 >= v16)
      {
        long long v25 = (int *)(a2 + 44);
        if (v4 > v5) {
          long long v25 = (int *)(a2 + 4);
        }
        if (v4 == v5) {
          long long v25 = (int *)(a2 + 4);
        }
        int v26 = *v25;
        comparison_double y = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>::get_comparison_y(a1, a3, 0);
        if (v26 == comparison_y)
        {
          BOOL v28 = *(_DWORD *)v11 != *(_DWORD *)(v11 + 8) || *(_DWORD *)(v11 + 4) != *(_DWORD *)(v11 + 12);
          return SHIDWORD(comparison_y) > 0 || v28;
        }
        else
        {
          return v26 < (int)comparison_y;
        }
      }
      else
      {
        int64_t v18 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>::get_comparison_y(a1, a2, 0);
        unint64_t v19 = *(void *)(a3 + 16);
        unint64_t v20 = *(void *)(a3 + 56);
        BOOL v21 = v19 == v20;
        BOOL v30 = v19 > v20;
        __n128 v22 = (int *)(a3 + 44);
        if (v30) {
          __n128 v22 = (int *)(a3 + 4);
        }
        if (v21) {
          __n128 v22 = (int *)(a3 + 4);
        }
        int v23 = *v22;
        if (v23 == v18)
        {
          BOOL v24 = *(_DWORD *)v8 == *(_DWORD *)(v8 + 8) && *(_DWORD *)(v8 + 4) == *(_DWORD *)(v8 + 12);
          return v18 < 0 && v24;
        }
        else
        {
          return v23 > (int)v18;
        }
      }
    }
    else
    {
      return boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::operator()(a1, (int *)a3, (int *)(a3 + 40), (int *)v8) ^ 1;
    }
  }
  else
  {
    return boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::operator()(a1, (int *)a2, (int *)(a2 + 40), (int *)v11);
  }
}

uint64_t boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::operator()(uint64_t a1, int *a2, int *a3, int *a4)
{
  unint64_t v4 = a2;
  if (*a2 == a2[2] && a2[1] == a2[3])
  {
    if (*a3 == a3[2] && a3[1] == a3[3]) {
      return boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::pp(a1, a2, a3, a4);
    }
    int v6 = 0;
    return boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::ps(a1, a2, a3, a4, v6);
  }
  if (*a3 == a3[2] && a3[1] == a3[3])
  {
    a2 = a3;
    a3 = v4;
    int v6 = 1;
    return boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::ps(a1, a2, a3, a4, v6);
  }
  return boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::ss(a1, a2, a3, a4);
}

unint64_t boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>::get_comparison_y(uint64_t a1, uint64_t a2, char a3)
{
  unint64_t v3 = *(void *)(a2 + 16);
  unint64_t v4 = *(void *)(a2 + 56);
  if (v3 == v4) {
    return *(unsigned int *)(a2 + 4);
  }
  if (v3 <= v4) {
    return *(unsigned int *)(a2 + 44) | 0xFFFFFFFF00000000;
  }
  if ((a3 & 1) != 0
    || *(_DWORD *)a2 != *(_DWORD *)(a2 + 8)
    || (uint64_t v6 = *(unsigned int *)(a2 + 12), *(_DWORD *)(a2 + 4) == v6))
  {
    uint64_t v6 = *(unsigned int *)(a2 + 4);
  }
  return v6 | 0x100000000;
}

uint64_t boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::pp(uint64_t a1, int *a2, int *a3, int *a4)
{
  int v4 = *a2;
  int v5 = *a3;
  if (*a2 <= *a3)
  {
    if (v4 >= v5) {
      return a3[1] + (uint64_t)a2[1] < 2 * a4[1];
    }
    int v6 = a4[1];
    int v8 = a3[1];
    if (v6 < v8)
    {
      int v7 = a2[1];
      goto LABEL_8;
    }
    return 1;
  }
  else
  {
    int v6 = a4[1];
    int v7 = a2[1];
    if (v6 > v7)
    {
      int v8 = a3[1];
LABEL_8:
      double v9 = (double)v4;
      int v10 = *a4;
      return (((double)v7 - (double)v6) * ((double)v7 - (double)v6) + (v9 - (double)v10) * (v9 - (double)v10))
           / (v9 - (double)v10 + v9 - (double)v10) < (((double)v8 - (double)v6) * ((double)v8 - (double)v6)
                                                    + ((double)v5 - (double)v10) * ((double)v5 - (double)v10))
                                                   / ((double)v5 - (double)v10 + (double)v5 - (double)v10);
    }
    return 0;
  }
}

uint64_t boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::ps(uint64_t a1, int *a2, int *a3, int *a4, int a5)
{
  int v10 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::fast_ps(a1, a2, (uint64_t)a3, a4, a5);
  if (v10) {
    return v10 == -1;
  }
  double v12 = (double)*a2 - (double)*a4;
  double v13 = (((double)a2[1] - (double)a4[1]) * ((double)a2[1] - (double)a4[1]) + v12 * v12) / (v12 + v12);
  boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::find_distance_to_segment_arc(a1, a3, a4);
  return (v13 < v14) ^ a5;
}

BOOL boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::ss(uint64_t a1, int *a2, int *a3, int *a4)
{
  if (*a2 == *a3 && a2[1] == a3[1] && a2[2] == a3[2] && a2[3] == a3[3]) {
    return boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::orientation_test::eval<boost::polygon::detail::point_2d<int>>(a2, a2 + 2, a4) == 1;
  }
  boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::find_distance_to_segment_arc(a1, a2, a4);
  double v9 = v8;
  boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::find_distance_to_segment_arc(a1, a3, a4);
  return v9 < v10;
}

uint64_t boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::fast_ps(uint64_t a1, int *a2, uint64_t a3, int *a4, int a5)
{
  unint64_t v9 = *(void *)(a3 + 32);
  if ((v9 & 0x20) != 0) {
    double v10 = (int *)(a3 + 8);
  }
  else {
    double v10 = (int *)a3;
  }
  if ((v9 & 0x20) != 0) {
    uint64_t v11 = (int *)a3;
  }
  else {
    uint64_t v11 = (int *)(a3 + 8);
  }
  if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::orientation_test::eval<boost::polygon::detail::point_2d<int>>(v10, v11, a4) == -1)
  {
    uint64_t v13 = a4[1];
    uint64_t v14 = a2[1];
    if (*(_DWORD *)a3 == *(_DWORD *)(a3 + 8))
    {
      if ((int)v13 >= (int)v14 || a5)
      {
        if ((int)v13 > (int)v14) {
          int v22 = a5;
        }
        else {
          int v22 = 0;
        }
        return (v22 << 31 >> 31);
      }
      else
      {
        return 1;
      }
    }
    else
    {
      uint64_t v15 = (v9 >> 2) & 8;
      uint64_t v16 = *a4;
      uint64_t v17 = *a2;
      uint64_t v18 = *(int *)(a3 + 8 * ((v9 & 0x20) == 0));
      uint64_t v19 = *(int *)(a3 + v15);
      uint64_t v20 = v11[1];
      uint64_t v21 = v10[1];
      if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v18 - v19, v20 - v21, v16 - v17, v13 - v14) <= 0.0)
      {
        double v23 = (double)(int)v16 - (double)(int)v17;
        double v24 = (double)(int)v13 - (double)(int)v14;
        double v25 = (v24 - v23) * ((v23 + v24) * ((double)(int)v18 - (double)(int)v19));
        double v26 = v24 * (v23 * ((double)(int)v20 - (double)(int)v21 + (double)(int)v20 - (double)(int)v21));
        double v27 = v25;
        double v28 = v26;
        if (v25 >= 0.0) {
          *(void *)&double v27 = 0x8000000000000000 - *(void *)&v25;
        }
        if (v26 >= 0.0) {
          *(void *)&double v28 = 0x8000000000000000 - *(void *)&v26;
        }
        if (*(void *)&v27 - *(void *)&v28 <= 4uLL) {
          int v29 = 0;
        }
        else {
          int v29 = -1;
        }
        if (*(void *)&v27 > *(void *)&v28) {
          BOOL v30 = v29;
        }
        else {
          BOOL v30 = *(void *)&v28 - *(void *)&v27 > 4uLL;
        }
        BOOL v31 = v30;
        int v32 = v30 ^ a5;
        if (a5) {
          unsigned int v33 = -1;
        }
        else {
          unsigned int v33 = 1;
        }
        if ((v31 & v32) != 0) {
          return v33;
        }
        else {
          return 0;
        }
      }
      else if ((*(unsigned char *)(a3 + 32) & 0x20) != 0)
      {
        return a5 ^ 1u;
      }
      else
      {
        return (a5 << 31 >> 31);
      }
    }
  }
  else if ((*(unsigned char *)(a3 + 32) & 0x20) != 0)
  {
    return 1;
  }
  else
  {
    return 0xFFFFFFFFLL;
  }
}

void boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::find_distance_to_segment_arc(uint64_t a1, int *a2, int *a3)
{
  unint64_t v3 = a2 + 2;
  int v4 = *a2;
  if (*a2 != a2[2])
  {
    if ((*((void *)a2 + 4) & 0x20) != 0) {
      int v5 = a2[2];
    }
    else {
      int v5 = *a2;
    }
    if ((*((void *)a2 + 4) & 0x20) != 0) {
      int v6 = a2 + 2;
    }
    else {
      int v6 = a2;
    }
    if ((*((void *)a2 + 4) & 0x20) != 0) {
      unint64_t v3 = a2;
    }
    else {
      int v4 = a2[2];
    }
    boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v4 - (uint64_t)v5, v3[1] - (uint64_t)v6[1], *a3 - (uint64_t)v5, a3[1] - (uint64_t)v6[1]);
  }
}

uint64_t std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::end_point_comparison &,std::__wrap_iter<std::pair<boost::polygon::detail::point_2d<int>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>> *>>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4 >= 2)
  {
    unint64_t v4 = (unint64_t)(a4 - 2) >> 1;
    uint64_t v5 = result + 16 * v4;
    int v7 = *(_DWORD *)(a2 - 16);
    int v8 = *(_DWORD *)(a2 - 12);
    int v6 = (_OWORD *)(a2 - 16);
    BOOL v9 = v8 < *(_DWORD *)(v5 + 4);
    BOOL v10 = v7 == *(_DWORD *)v5;
    BOOL v11 = v7 < *(_DWORD *)v5;
    if (v10) {
      BOOL v11 = v9;
    }
    if (v11)
    {
      long long v12 = *v6;
      uint64_t v13 = *(void *)v6;
      uint64_t v14 = HIDWORD(*(void *)v6);
      do
      {
        uint64_t v15 = v6;
        int v6 = (_OWORD *)v5;
        *uint64_t v15 = *(void *)v5;
        v15[1] = *(void *)(v5 + 8);
        if (!v4) {
          break;
        }
        unint64_t v4 = (v4 - 1) >> 1;
        uint64_t v5 = result + 16 * v4;
        BOOL v16 = *(_DWORD *)v5 > (int)v13;
        if (*(_DWORD *)v5 == v13) {
          BOOL v16 = *(_DWORD *)(v5 + 4) > (int)v14;
        }
      }
      while (v16);
      *int v6 = v12;
    }
  }
  return result;
}

uint64_t *std::__tree<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__map_value_compare<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>,false>,std::allocator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>>::__emplace_hint_unique_key_args<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::pair<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>(uint64_t **a1, void *a2, uint64_t a3, _OWORD *a4)
{
  int v6 = std::__tree<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__map_value_compare<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>,false>,std::allocator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>>::__find_equal<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>(a1, a2, &v14, &v13, a3);
  int v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    int v8 = (uint64_t **)v6;
    int v7 = (uint64_t *)operator new(0x80uLL);
    long long v9 = a4[3];
    *((_OWORD *)v7 + 4) = a4[2];
    *((_OWORD *)v7 + 5) = v9;
    long long v10 = a4[1];
    *((_OWORD *)v7 + 2) = *a4;
    *((_OWORD *)v7 + 3) = v10;
    long long v11 = a4[5];
    *((_OWORD *)v7 + 6) = a4[4];
    *((_OWORD *)v7 + 7) = v11;
    std::__tree<std::__value_type<std::string,unsigned short>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned short>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned short>>>::__insert_node_at(a1, v14, v8, v7);
  }
  return v7;
}

uint64_t boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::activate_circle_event(uint64_t a1, int *a2, int *a3, int *a4, uint64_t a5)
{
  BYTE8(v11) = 1;
  uint64_t result = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::circle_formation_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::circle_existence_predicate<boost::polygon::detail::site_event<int>>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::lazy_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>>::operator()(a1 + 160, a2, a3, a4, (uint64_t)&v10);
  if (result)
  {
    v8[0] = v10;
    v8[1] = v11;
    uint64_t v9 = a5;
    uint64_t result = boost::polygon::detail::ordered_queue<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::event_comparison_type>::push((char **)(a1 + 72), (uint64_t)v8);
    *(void *)(a5 + 112) = result;
  }
  return result;
}

uint64_t std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::end_point_comparison &,std::__wrap_iter<std::pair<boost::polygon::detail::point_2d<int>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>> *>>(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = a3 - 2;
  if (a3 < 2) {
    uint64_t v4 = a3 - 1;
  }
  uint64_t v5 = v4 >> 1;
  do
  {
    uint64_t v6 = (uint64_t)&a1[2 * v3 + 2];
    uint64_t v7 = (2 * v3) | 1;
    uint64_t v8 = 2 * v3 + 2;
    if (v8 < a3)
    {
      int v9 = *(_DWORD *)(v6 + 16);
      BOOL v10 = v9 == *(_DWORD *)v6;
      BOOL v11 = v9 < *(_DWORD *)v6;
      if (v10) {
        BOOL v11 = *(_DWORD *)(v6 + 20) < *(_DWORD *)(v6 + 4);
      }
      if (v11)
      {
        v6 += 16;
        uint64_t v7 = v8;
      }
    }
    *a1 = *(void *)v6;
    a1[1] = *(void *)(v6 + 8);
    a1 = (void *)v6;
    uint64_t v3 = v7;
  }
  while (v7 <= v5);
  return v6;
}

uint64_t boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::circle_formation_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::circle_existence_predicate<boost::polygon::detail::site_event<int>>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::lazy_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>>::operator()(uint64_t a1, int *a2, int *a3, int *a4, uint64_t a5)
{
  int v10 = a2[2];
  if (*a2 == v10 && a2[1] == a2[3])
  {
    int v11 = a3[2];
    if (*a3 == v11 && a3[1] == a3[3])
    {
      if (*a4 == a4[2] && a4[1] == a4[3])
      {
        if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::orientation_test::eval<boost::polygon::detail::point_2d<int>>(a2, a3, a4) == -1)
        {
          boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::lazy_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::ppp(a1 + 4, a2, a3, a4, a5);
          return 1;
        }
        return 0;
      }
      if (!boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::circle_existence_predicate<boost::polygon::detail::site_event<int>>::pps(a1, a2, a3, (uint64_t)a4, 3))return 0; {
      uint64_t v21 = a1 + 4;
      }
      int v22 = a2;
      double v23 = a3;
      uint64_t v24 = (uint64_t)a4;
      uint64_t v25 = 3;
    }
    else
    {
      int v20 = a4[2];
      if (*a4 != v20 || a4[1] != a4[3])
      {
        if (*a3 != *a4 || v11 != v20 || a3[1] != a4[1] || a3[3] != a4[3])
        {
          uint64_t v14 = 1;
          boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::lazy_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::pss(a1 + 4, a2, (uint64_t)a3, (uint64_t)a4, 1, a5);
          return v14;
        }
        return 0;
      }
      if (!boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::circle_existence_predicate<boost::polygon::detail::site_event<int>>::pps(a1, a2, a4, (uint64_t)a3, 2))return 0; {
      uint64_t v21 = a1 + 4;
      }
      int v22 = a2;
      double v23 = a4;
      uint64_t v24 = (uint64_t)a3;
      uint64_t v25 = 2;
    }
    boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::lazy_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::pps(v21, v22, v23, v24, v25, a5);
    return 1;
  }
  int v12 = a3[2];
  if (*a3 != v12 || a3[1] != a3[3])
  {
    if (*a4 != a4[2] || a4[1] != a4[3])
    {
      if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::circle_existence_predicate<boost::polygon::detail::site_event<int>>::sss(a1, a2, a3, a4))
      {
        boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::lazy_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::sss(a1 + 4, (uint64_t)a2, (uint64_t)a3, (uint64_t)a4, a5);
        return 1;
      }
      return 0;
    }
    if (*a2 == *a3 && v10 == v12 && a2[1] == a3[1] && a2[3] == a3[3]) {
      return 0;
    }
    uint64_t v15 = a1 + 4;
    BOOL v16 = a4;
    uint64_t v17 = (uint64_t)a2;
    uint64_t v18 = (uint64_t)a3;
    uint64_t v19 = 3;
LABEL_30:
    boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::lazy_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::pss(v15, v16, v17, v18, v19, a5);
    return 1;
  }
  if (*a4 != a4[2] || a4[1] != a4[3])
  {
    if (!boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::circle_existence_predicate<boost::polygon::detail::site_event<int>>::pss(a1, a3, (uint64_t)a2, (uint64_t)a4, 2))return 0; {
    uint64_t v15 = a1 + 4;
    }
    BOOL v16 = a3;
    uint64_t v17 = (uint64_t)a2;
    uint64_t v18 = (uint64_t)a4;
    uint64_t v19 = 2;
    goto LABEL_30;
  }
  if (!boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::circle_existence_predicate<boost::polygon::detail::site_event<int>>::pps(a1, a3, a4, (uint64_t)a2, 1))return 0; {
  uint64_t v13 = a1 + 4;
  }
  uint64_t v14 = 1;
  boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::lazy_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::pps(v13, a3, a4, (uint64_t)a2, 1, a5);
  return v14;
}

uint64_t boost::polygon::detail::ordered_queue<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::event_comparison_type>::push(char **a1, uint64_t a2)
{
  uint64_t v4 = a1 + 4;
  uint64_t v5 = operator new(0x38uLL);
  long long v6 = *(_OWORD *)(a2 + 16);
  v5[1] = *(_OWORD *)a2;
  v5[2] = v6;
  *((void *)v5 + 6) = *(void *)(a2 + 32);
  uint64_t v7 = a1[5];
  *(void *)uint64_t v5 = v4;
  *((void *)v5 + 1) = v7;
  *(void *)uint64_t v7 = v5;
  unint64_t v8 = (unint64_t)a1[2];
  a1[5] = (char *)v5;
  ++a1[6];
  int v9 = a1[1];
  if ((unint64_t)v9 >= v8)
  {
    uint64_t v11 = (v9 - *a1) >> 3;
    if ((unint64_t)(v11 + 1) >> 61) {
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v8 - (void)*a1;
    uint64_t v13 = v12 >> 2;
    if (v12 >> 2 <= (unint64_t)(v11 + 1)) {
      uint64_t v13 = v11 + 1;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v13;
    }
    if (v14) {
      uint64_t v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>((uint64_t)(a1 + 2), v14);
    }
    else {
      uint64_t v15 = 0;
    }
    BOOL v16 = &v15[8 * v11];
    uint64_t v17 = &v15[8 * v14];
    *(void *)BOOL v16 = v5;
    uint64_t v10 = (uint64_t)(v16 + 8);
    uint64_t v19 = *a1;
    uint64_t v18 = a1[1];
    if (v18 != *a1)
    {
      do
      {
        uint64_t v20 = *((void *)v18 - 1);
        v18 -= 8;
        *((void *)v16 - 1) = v20;
        v16 -= 8;
      }
      while (v18 != v19);
      uint64_t v18 = *a1;
    }
    *a1 = v16;
    a1[1] = (char *)v10;
    a1[2] = v17;
    if (v18) {
      operator delete(v18);
    }
  }
  else
  {
    *(void *)int v9 = v5;
    uint64_t v10 = (uint64_t)(v9 + 8);
  }
  a1[1] = (char *)v10;
  uint64_t v21 = *a1;
  __int16 v23 = *((_WORD *)a1 + 12);
  std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::ordered_queue<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::event_comparison_type>::comparison &,std::__wrap_iter<std::__list_iterator<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,void *> *>>((BOOL)v21, v10, (uint64_t)&v23, (v10 - (uint64_t)v21) >> 3);
  return (uint64_t)(a1[5] + 16);
}

void boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::lazy_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::ppp(uint64_t a1, int *a2, int *a3, int *a4, uint64_t a5)
{
  uint64_t v9 = *a2;
  uint64_t v10 = a2[1];
  uint64_t v11 = *a3;
  uint64_t v12 = a3[1];
  double v13 = (double)(int)v9 - (double)(int)v11;
  uint64_t v14 = *a4;
  uint64_t v15 = a4[1];
  double v16 = (double)(int)v11 - (double)(int)v14;
  double v17 = (double)(int)v10 - (double)(int)v12;
  double v18 = (double)(int)v12 - (double)(int)v15;
  double v19 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v9 - v11, v11 - v14, v10 - v12, v12 - v15);
  double v20 = (double)*a2;
  double v21 = (double)*a3;
  double v22 = (double)*a4;
  double v23 = 0.5 / v19;
  double v24 = v20 + v21;
  double v25 = v21 + v22;
  double v26 = (double)a2[1];
  double v27 = (double)a3[1];
  double v28 = (double)a4[1];
  double v29 = v26 + v27;
  double v30 = v27 + v28;
  double v44 = v20 - v22;
  double v45 = v23;
  double v43 = v26 - v28;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  double v31 = v13 * v24;
  *(double *)&long long v47 = v18 * (v13 * v24);
  *((void *)&v47 + 1) = 0x4000000000000000;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v51, (double *)&v47);
  double v32 = v17 * v29;
  *(double *)&long long v47 = v18 * v32;
  *((void *)&v47 + 1) = 0x4000000000000000;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v51, (double *)&v47);
  double v33 = v16 * v25;
  *(double *)&long long v47 = v17 * v33;
  *((void *)&v47 + 1) = 0x4000000000000000;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v51, (double *)&v47);
  double v34 = v18 * v30;
  *(double *)&long long v47 = v17 * v34;
  *((void *)&v47 + 1) = 0x4000000000000000;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v51, (double *)&v47);
  *(double *)&long long v47 = v13 * v33;
  *((void *)&v47 + 1) = 0x4000000000000000;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v49, (double *)&v47);
  *(double *)&long long v47 = v13 * v34;
  *((void *)&v47 + 1) = 0x4000000000000000;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v49, (double *)&v47);
  *(double *)&long long v47 = v16 * v31;
  *((void *)&v47 + 1) = 0x4000000000000000;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v49, (double *)&v47);
  *(double *)&long long v47 = v16 * v32;
  *((void *)&v47 + 1) = 0x4000000000000000;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v49, (double *)&v47);
  long long v47 = v51;
  long long v48 = v52;
  v46[0] = sqrt((v17 * v17 + v13 * v13) * (v18 * v18 + v16 * v16) * (v43 * v43 + v44 * v44));
  v46[1] = 5.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v47, v46);
  double v35 = v45 * boost::polygon::detail::robust_fpt<double>::operator-((double *)&v51, (double *)&v52);
  double v36 = v45 * boost::polygon::detail::robust_fpt<double>::operator-((double *)&v49, (double *)&v50);
  double v37 = boost::polygon::detail::robust_fpt<double>::operator-((double *)&v47, (double *)&v48);
  *(double *)a5 = v35;
  *(double *)(a5 + 8) = v36;
  *(double *)(a5 + 16) = v45 * v37;
  *(unsigned char *)(a5 + 24) = 1;
  boost::polygon::detail::robust_fpt<double>::operator-((double *)&v51, (double *)&v52);
  double v39 = v38;
  boost::polygon::detail::robust_fpt<double>::operator-((double *)&v49, (double *)&v50);
  double v41 = v40;
  boost::polygon::detail::robust_fpt<double>::operator-((double *)&v47, (double *)&v48);
  if (v39 > 64.0 || v41 > 64.0 || v42 > 64.0) {
    boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::ppp();
  }
}

uint64_t boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::circle_existence_predicate<boost::polygon::detail::site_event<int>>::pps(uint64_t a1, int *a2, int *a3, uint64_t a4, int a5)
{
  uint64_t v8 = *(void *)(a4 + 32);
  uint64_t v9 = (int *)(a4 + 8);
  if ((v8 & 0x20) != 0) {
    uint64_t v10 = (int *)(a4 + 8);
  }
  else {
    uint64_t v10 = (int *)a4;
  }
  if (a5 == 2)
  {
    if (*v10 != *a2 || v10[1] != a2[1]) {
      return 1;
    }
    uint64_t v11 = (v8 & 0x20) != 0 ? a4 : a4 + 8;
    return *(_DWORD *)(a4 + 8 * ((*(void *)(a4 + 32) & 0x20) == 0)) != *a3 || *(_DWORD *)(v11 + 4) != a3[1];
  }
  int v13 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::orientation_test::eval<boost::polygon::detail::point_2d<int>>(a2, a3, v10);
  if ((*(void *)(a4 + 32) & 0x20) != 0) {
    uint64_t v14 = (int *)a4;
  }
  else {
    uint64_t v14 = v9;
  }
  int v15 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::orientation_test::eval<boost::polygon::detail::point_2d<int>>(a2, a3, v14);
  if (a5 == 3)
  {
    if (*a3 >= *a2) {
      return v15 == -1;
    }
    return v13 == -1 || v15 == -1;
  }
  if (a5 != 1 || *a2 < *a3) {
    return v13 == -1 || v15 == -1;
  }
  return v13 == -1;
}

void boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::lazy_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::pps(uint64_t a1, int *a2, int *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  BOOL v12 = (*(void *)(a4 + 32) & 0x20) == 0;
  uint64_t v13 = a4 + 8;
  if (v12) {
    uint64_t v14 = a4 + 8;
  }
  else {
    uint64_t v14 = a4;
  }
  uint64_t v15 = *(int *)(v14 + 4);
  if (v12) {
    uint64_t v16 = a4;
  }
  else {
    uint64_t v16 = a4 + 8;
  }
  uint64_t v17 = *(int *)(a4 + ((*(void *)(a4 + 32) >> 2) & 8));
  double v18 = (double)(int)v17;
  uint64_t v19 = *(int *)(a4 + 8 * v12);
  uint64_t v20 = *(int *)(v16 + 4);
  uint64_t v22 = *a3;
  uint64_t v21 = a3[1];
  uint64_t v24 = *a2;
  uint64_t v23 = a2[1];
  double v25 = (double)(int)v21 - (double)(int)v23;
  double v87 = (double)(int)v24;
  double v88 = (double)(int)v19;
  double v26 = (double)(int)v22;
  double v27 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v15 - v20, v17 - v19, v22 - v24, v21 - v23);
  BOOL v28 = (*(void *)(a4 + 32) & 0x20) == 0;
  if (v28) {
    uint64_t v29 = v13;
  }
  else {
    uint64_t v29 = a4;
  }
  uint64_t v30 = *(int *)(v29 + 4);
  if (v28) {
    uint64_t v31 = a4;
  }
  else {
    uint64_t v31 = v13;
  }
  double v32 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v30 - *(int *)(v31 + 4), *(int *)(a4 + ((*(void *)(a4 + 32) >> 2) & 8)) - (uint64_t)*(int *)(a4 + 8 * v28), *(int *)(a4 + 12) - (uint64_t)a2[1], *a2 - (uint64_t)*(int *)(a4 + 8));
  v104[0] = v32;
  BOOL v33 = (*(void *)(a4 + 32) & 0x20) == 0;
  if (v33) {
    uint64_t v34 = v13;
  }
  else {
    uint64_t v34 = a4;
  }
  uint64_t v35 = *(int *)(v34 + 4);
  if (v33) {
    uint64_t v36 = a4;
  }
  else {
    uint64_t v36 = v13;
  }
  uint64_t v37 = v35 - *(int *)(v36 + 4);
  uint64_t v38 = *(int *)(a4 + ((*(void *)(a4 + 32) >> 2) & 8)) - (uint64_t)*(int *)(a4 + 8 * v33);
  uint64_t v39 = *a3;
  uint64_t v40 = *(int *)(a4 + 8);
  uint64_t v41 = *(int *)(a4 + 12) - (uint64_t)a3[1];
  v104[1] = 1.0;
  double v42 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v37, v38, v41, v39 - v40);
  v103[0] = v42;
  v103[1] = 1.0;
  BOOL v43 = (*(void *)(a4 + 32) & 0x20) == 0;
  if (v43) {
    uint64_t v44 = v13;
  }
  else {
    uint64_t v44 = a4;
  }
  uint64_t v45 = *(int *)(v44 + 4);
  if (v43) {
    uint64_t v46 = a4;
  }
  else {
    uint64_t v46 = v13;
  }
  double v47 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(a3[1] - (uint64_t)a2[1], *a2 - (uint64_t)*a3, v45 - *(int *)(v46 + 4), *(int *)(a4 + ((*(void *)(a4 + 32) >> 2) & 8)) - (uint64_t)*(int *)(a4 + 8 * v43));
  double v48 = 1.0;
  long long v101 = 0u;
  *(_OWORD *)signed int v102 = 0u;
  if (v47 == 0.0)
  {
    *(double *)&long long v99 = v27 / (v32 * 8.0);
    *((void *)&v99 + 1) = 0x4010000000000000;
    boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v101, (double *)&v99);
    *(double *)&long long v99 = v32 / (v27 + v27);
    *((void *)&v99 + 1) = 0x4010000000000000;
    boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v101, (double *)&v99);
  }
  else
  {
    *(double *)&long long v99 = v27 * v27;
    *((void *)&v99 + 1) = 0x4008000000000000;
    *(double *)&long long v97 = v47 * v47;
    *((void *)&v97 + 1) = 0x4008000000000000;
    double v48 = 1.0;
    *(double *)&long long v99 = sqrt(boost::polygon::detail::robust_fpt<double>::operator+((double *)&v99, (double *)&v97)* v32* v42)/ (v47* v47);
    *((double *)&v99 + 1) = (v49 + 1.0 + 1.0 + 1.0 + 1.0) * 0.5 + 1.0 + 3.0 + 1.0;
    if (a5 == 2) {
      boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v101, (double *)&v99);
    }
    else {
      boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v101, (double *)&v99);
    }
    *(double *)&long long v99 = v27 * boost::polygon::detail::robust_fpt<double>::operator+(v104, v103) / (v47 * (v47 + v47));
    *((double *)&v99 + 1) = v50 + 1.0 + 1.0 + 4.0 + 1.0;
    boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v101, (double *)&v99);
  }
  double v51 = v18 - v88;
  double v52 = v87 - v26;
  long long v99 = 0u;
  long long v100 = 0u;
  double v53 = (double)*a2;
  int v54 = *a3;
  long long v97 = 0u;
  long long v98 = 0u;
  long long v95 = COERCE_UNSIGNED_INT64((v53 + (double)v54) * 0.5);
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v99, (double *)&v95);
  if (v25 >= 0.0)
  {
    double v55 = *((double *)&v101 + 1);
    double v56 = v25 * *(double *)&v101;
    double v57 = v102[1];
    double v58 = v25 * v102[0];
  }
  else
  {
    double v55 = v102[1];
    double v56 = -(v25 * v102[0]);
    double v57 = *((double *)&v101 + 1);
    double v58 = -(v25 * *(double *)&v101);
  }
  double v59 = (double)(int)v15 - (double)(int)v20;
  *(double *)&long long v95 = v56;
  *((double *)&v95 + 1) = v55 + 0.0 + 1.0;
  *(double *)&long long v96 = v58;
  *((double *)&v96 + 1) = v57 + 0.0 + 1.0;
  boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v99, (double *)&v95);
  boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v100, (double *)&v96);
  *(double *)&long long v95 = ((double)a2[1] + (double)a3[1]) * 0.5;
  *((void *)&v95 + 1) = 0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v97, (double *)&v95);
  if (v52 >= 0.0)
  {
    double v60 = *((double *)&v101 + 1);
    double v61 = v52 * *(double *)&v101;
    double v62 = v102[1];
    double v63 = v52 * v102[0];
  }
  else
  {
    double v60 = v102[1];
    double v61 = -(v52 * v102[0]);
    double v62 = *((double *)&v101 + 1);
    double v63 = -(v52 * *(double *)&v101);
  }
  *(double *)&long long v95 = v61;
  *((double *)&v95 + 1) = v60 + 0.0 + 1.0;
  *(double *)&long long v96 = v63;
  *((double *)&v96 + 1) = v62 + 0.0 + 1.0;
  boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v97, (double *)&v95);
  boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v98, (double *)&v96);
  long long v95 = 0u;
  long long v96 = 0u;
  long long v93 = v99;
  long long v94 = v100;
  double v89 = v59 * (double)*(int *)a4;
  double v90 = 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v95, &v89);
  double v89 = v51 * (double)*(int *)(a4 + 4);
  double v90 = 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v95, &v89);
  if (v59 >= 0.0)
  {
    double v64 = *((double *)&v99 + 1);
    double v65 = v59 * *(double *)&v99;
    double v66 = *((double *)&v100 + 1);
    double v67 = v59 * *(double *)&v100;
  }
  else
  {
    double v64 = *((double *)&v100 + 1);
    double v65 = -(v59 * *(double *)&v100);
    double v66 = *((double *)&v99 + 1);
    double v67 = -(v59 * *(double *)&v99);
  }
  double v68 = sqrt(v51 * v51 + v59 * v59);
  double v89 = v65;
  double v90 = v64 + 0.0 + 1.0;
  double v91 = v67;
  double v92 = v66 + 0.0 + 1.0;
  boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v95, &v89);
  boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v96, &v91);
  if (v51 >= 0.0)
  {
    double v69 = *((double *)&v97 + 1);
    double v70 = v51 * *(double *)&v97;
    double v71 = *((double *)&v98 + 1);
    double v72 = v51 * *(double *)&v98;
  }
  else
  {
    double v69 = *((double *)&v98 + 1);
    double v70 = -(v51 * *(double *)&v98);
    double v71 = *((double *)&v97 + 1);
    double v72 = -(v51 * *(double *)&v97);
  }
  double v73 = v48 / v68;
  double v89 = v70;
  double v90 = v69 + 0.0 + 1.0;
  double v91 = v72;
  double v92 = v71 + 0.0 + 1.0;
  boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v95, &v89);
  boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v96, &v91);
  long long v74 = v95;
  double v76 = *((double *)&v96 + 1);
  double v75 = *(double *)&v96;
  if (*(double *)&v95 >= *(double *)&v96)
  {
    double v77 = *((double *)&v96 + 1);
    double v78 = *(double *)&v96;
    double v76 = *((double *)&v95 + 1);
    double v75 = *(double *)&v95;
  }
  else
  {
    long long v95 = v96;
    double v77 = *((double *)&v74 + 1);
    double v78 = *(double *)&v74;
    long long v96 = v74;
  }
  double v89 = v73 * v75;
  double v90 = v76 + 3.0 + 1.0;
  double v91 = v73 * v78;
  double v92 = v77 + 3.0 + 1.0;
  boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v93, &v89);
  boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v94, &v91);
  double v79 = boost::polygon::detail::robust_fpt<double>::operator-((double *)&v99, (double *)&v100);
  double v80 = boost::polygon::detail::robust_fpt<double>::operator-((double *)&v97, (double *)&v98);
  double v81 = boost::polygon::detail::robust_fpt<double>::operator-((double *)&v93, (double *)&v94);
  *(double *)a6 = v79;
  *(double *)(a6 + 8) = v80;
  *(double *)(a6 + 16) = v81;
  *(unsigned char *)(a6 + 24) = 1;
  boost::polygon::detail::robust_fpt<double>::operator-((double *)&v99, (double *)&v100);
  double v83 = v82;
  boost::polygon::detail::robust_fpt<double>::operator-((double *)&v97, (double *)&v98);
  double v85 = v84;
  boost::polygon::detail::robust_fpt<double>::operator-((double *)&v93, (double *)&v94);
  if (v83 > 64.0 || v85 > 64.0 || v86 > 64.0) {
    boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::pps(a1, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, v83 > 64.0, v85 > 64.0, v86 > 64.0);
  }
}

uint64_t boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::circle_existence_predicate<boost::polygon::detail::site_event<int>>::pss(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, int a5)
{
  if (*(_DWORD *)a3 == *(_DWORD *)a4
    && *(_DWORD *)(a3 + 4) == *(_DWORD *)(a4 + 4)
    && *(_DWORD *)(a3 + 8) == *(_DWORD *)(a4 + 8)
    && *(_DWORD *)(a3 + 12) == *(_DWORD *)(a4 + 12))
  {
    return 0;
  }
  if (a5 == 2)
  {
    uint64_t v5 = *(void *)(a3 + 32);
    uint64_t v6 = *(void *)(a4 + 32) & 0x20;
    if ((v5 & 0x20) != 0)
    {
      if (!v6) {
        return 1;
      }
    }
    else if (v6)
    {
      return 0;
    }
    if ((v5 & 0x20) != 0) {
      uint64_t v7 = (int *)(a3 + 8);
    }
    else {
      uint64_t v7 = (int *)a3;
    }
    if (v6) {
      uint64_t v8 = (int *)a4;
    }
    else {
      uint64_t v8 = (int *)(a4 + 8);
    }
    if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::orientation_test::eval<boost::polygon::detail::point_2d<int>>(v7, a2, v8) != -1)return 0; {
  }
    }
  return 1;
}

void boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::lazy_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::pss(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _ZF = (*(void *)(a3 + 32) & 0x20) == 0;
  uint64_t v9 = 8 * _ZF;
  if (_ZF) {
    uint64_t v10 = (int *)(a3 + 8);
  }
  else {
    uint64_t v10 = (int *)a3;
  }
  if (_ZF) {
    uint64_t v11 = (int *)a3;
  }
  else {
    uint64_t v11 = (int *)(a3 + 8);
  }
  BOOL v12 = (*(void *)(a4 + 32) & 0x20) == 0;
  if (v12) {
    uint64_t v13 = (int *)a4;
  }
  else {
    uint64_t v13 = (int *)(a4 + 8);
  }
  uint64_t v14 = *(int *)(a3 + ((*(void *)(a3 + 32) >> 2) & 8));
  uint64_t v15 = *(int *)(a3 + v9);
  double v16 = (double)(int)v14 - (double)(int)v15;
  uint64_t v17 = v11[1];
  uint64_t v18 = v10[1];
  if (v12) {
    uint64_t v19 = (int *)(a4 + 8);
  }
  else {
    uint64_t v19 = (int *)a4;
  }
  double v20 = (double)(int)v17 - (double)(int)v18;
  uint64_t v21 = *(int *)(a4 + 8 * v12);
  uint64_t v22 = *(int *)(a4 + ((*(void *)(a4 + 32) >> 2) & 8));
  uint64_t v23 = v19[1];
  uint64_t v24 = v13[1];
  double v25 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v17 - v18, v14 - v15, v23 - v24, v21 - v22);
  if (v25 == 0.0)
  {
    double v26 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v11[1] - (uint64_t)v10[1], *v11 - (uint64_t)*v10, v13[1] - (uint64_t)v10[1], *v13 - (uint64_t)*v10);
    double v27 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(*v11 - (uint64_t)*v10, v11[1] - (uint64_t)v10[1], *a2 - (uint64_t)*v10, a2[1] - (uint64_t)v10[1]);
    double v28 = v27
        * boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v11[1] - (uint64_t)v10[1], *v11 - (uint64_t)*v10, a2[1] - (uint64_t)v13[1], *a2 - (uint64_t)*v13);
    float64x2_t v140 = 0u;
    float64x2_t v141 = 0u;
    *(double *)&long long v138 = v16 * -((double)*a2 - ((double)*v10 + (double)*v13) * 0.5);
    *((void *)&v138 + 1) = 0x3FF0000000000000;
    boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=(v140.f64, (double *)&v138);
    *(double *)&long long v138 = v20 * -((double)a2[1] - ((double)v10[1] + (double)v13[1]) * 0.5);
    *((void *)&v138 + 1) = 0x3FF0000000000000;
    boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=(v140.f64, (double *)&v138);
    *(void *)&long long v138 = sqrt(v28);
    *((void *)&v138 + 1) = 0x4004000000000000;
    if (a5 == 2) {
      boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=(v140.f64, (double *)&v138);
    }
    else {
      boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=(v140.f64, (double *)&v138);
    }
    __asm { FMOV            V0.2D, #3.0 }
    float64x2_t v35 = vaddq_f64(v140, _Q0);
    float64x2_t v36 = vaddq_f64(v141, _Q0);
    _Q0.f64[0] = v20 * v20 + v16 * v16;
    *(void *)&v37.f64[0] = *(_OWORD *)&vdivq_f64(v140, _Q0);
    v37.f64[1] = v35.f64[1];
    *(void *)&_Q0.f64[0] = *(_OWORD *)&vdivq_f64(v141, _Q0);
    _Q0.f64[1] = v36.f64[1];
    float64x2_t v140 = v37;
    float64x2_t v141 = _Q0;
    long long v138 = 0u;
    long long v139 = 0u;
    v37.f64[0] = (double)*v10;
    int v38 = *v13;
    long long v136 = 0u;
    long long v137 = 0u;
    long long v134 = COERCE_UNSIGNED_INT64((v37.f64[0] + (double)v38) * 0.5);
    boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v138, (double *)&v134);
    if (v16 >= 0.0)
    {
      double v39 = v140.f64[1];
      double v40 = v16 * v140.f64[0];
      double v41 = v141.f64[1];
      double v42 = v16 * v141.f64[0];
    }
    else
    {
      double v39 = v141.f64[1];
      double v40 = -(v16 * v141.f64[0]);
      double v41 = v140.f64[1];
      double v42 = -(v16 * v140.f64[0]);
    }
    *(double *)&long long v134 = v40;
    *((double *)&v134 + 1) = v39 + 0.0 + 1.0;
    *(double *)&long long v135 = v42;
    *((double *)&v135 + 1) = v41 + 0.0 + 1.0;
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v138, (double *)&v134);
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v139, (double *)&v135);
    *(double *)&long long v134 = ((double)v10[1] + (double)v13[1]) * 0.5;
    *((void *)&v134 + 1) = 0;
    boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v136, (double *)&v134);
    if (v20 >= 0.0)
    {
      double v43 = v140.f64[1];
      double v44 = v20 * v140.f64[0];
      double v45 = v141.f64[1];
      double v46 = v20 * v141.f64[0];
    }
    else
    {
      double v43 = v141.f64[1];
      double v44 = -(v20 * v141.f64[0]);
      double v45 = v140.f64[1];
      double v46 = -(v20 * v140.f64[0]);
    }
    *(double *)&long long v134 = v44;
    *((double *)&v134 + 1) = v43 + 0.0 + 1.0;
    *(double *)&long long v135 = v46;
    *((double *)&v135 + 1) = v45 + 0.0 + 1.0;
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v136, (double *)&v134);
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v137, (double *)&v135);
    long long v134 = v138;
    long long v135 = v139;
    *(double *)&long long v130 = v26 * 0.5 / sqrt(v20 * v20 + v16 * v16);
    *((void *)&v130 + 1) = 0x4014000000000000;
    if (v26 >= 0.0) {
      boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v134, (double *)&v130);
    }
    else {
      boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v134, (double *)&v130);
    }
    boost::polygon::detail::robust_fpt<double>::operator-((double *)&v138, (double *)&v139);
    double v48 = v47;
    boost::polygon::detail::robust_fpt<double>::operator-((double *)&v136, (double *)&v137);
    double v50 = v49;
    double v51 = (double *)&v135;
    boost::polygon::detail::robust_fpt<double>::operator-((double *)&v134, (double *)&v135);
    double v53 = v52;
    double v54 = boost::polygon::detail::robust_fpt<double>::operator-((double *)&v138, (double *)&v139);
    double v55 = boost::polygon::detail::robust_fpt<double>::operator-((double *)&v136, (double *)&v137);
    double v56 = (double *)&v134;
  }
  else
  {
    double v29 = (double)(int)v21 - (double)(int)v22;
    double v116 = (double)(int)v23 - (double)(int)v24;
    double v132 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(*v11 - (uint64_t)*v10, v11[1] - (uint64_t)v10[1], v13[1] - (uint64_t)v19[1], *v19 - (uint64_t)*v13);
    double v133 = 1.0;
    double v120 = sqrt(v116 * v116 + v29 * v29);
    double v114 = sqrt(v20 * v20 + v16 * v16);
    v140.f64[0] = v114 * v120;
    v140.f64[1] = 5.0;
    if (v132 < 0.0)
    {
      double v132 = v25 * v25 / boost::polygon::detail::robust_fpt<double>::operator-(v140.f64, &v132);
      double v133 = v30 + 3.0 + 1.0;
    }
    else
    {
      boost::polygon::detail::robust_fpt<double>::operator+=(&v132, v140.f64);
    }
    double v112 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v11[1] - (uint64_t)v10[1], *v11 - (uint64_t)*v10, v11[1] - (uint64_t)a2[1], *v11 - (uint64_t)*a2);
    double v113 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(*v19 - (uint64_t)*v13, v19[1] - (uint64_t)v13[1], *v19 - (uint64_t)*a2, v19[1] - (uint64_t)a2[1]);
    double v111 = v132;
    double v57 = v133 + 0.0 + 1.0 + 1.0;
    double v58 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v11[1] - (uint64_t)v10[1], *v11 - (uint64_t)*v10, v11[1], *v11);
    double v59 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(*v19 - (uint64_t)*v13, v19[1] - (uint64_t)v13[1], *v19, v19[1]);
    double v115 = v25;
    double v60 = 1.0 / v25;
    float64x2_t v140 = 0u;
    float64x2_t v141 = 0u;
    long long v138 = 0u;
    long long v139 = 0u;
    long long v136 = 0u;
    long long v137 = 0u;
    long long v134 = 0u;
    long long v135 = 0u;
    *(double *)&long long v130 = v60 * (v29 * v58);
    *((void *)&v130 + 1) = 0x4014000000000000;
    boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v136, (double *)&v130);
    *(double *)&long long v130 = v60 * (v16 * v59);
    *((void *)&v130 + 1) = 0x4014000000000000;
    boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v136, (double *)&v130);
    *(double *)&long long v130 = v60 * (v20 * v59);
    *((void *)&v130 + 1) = 0x4014000000000000;
    boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v134, (double *)&v130);
    *(double *)&long long v130 = v60 * (v116 * v58);
    *((void *)&v130 + 1) = 0x4014000000000000;
    boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v134, (double *)&v130);
    double v61 = v16 * v120;
    if (v61 >= 0.0)
    {
      double v62 = *((double *)&v136 + 1);
      double v63 = *(double *)&v136;
      double v64 = *((double *)&v137 + 1);
      double v65 = *(double *)&v137;
    }
    else
    {
      double v62 = *((double *)&v137 + 1);
      double v63 = -*(double *)&v137;
      double v64 = *((double *)&v136 + 1);
      double v65 = -*(double *)&v136;
    }
    double v66 = v57 + 1.0;
    *(double *)&long long v130 = v61 * v63;
    *((double *)&v130 + 1) = v62 + 3.0 + 1.0;
    *(double *)&long long v131 = v61 * v65;
    *((double *)&v131 + 1) = v64 + 3.0 + 1.0;
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v138, (double *)&v130);
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v139, (double *)&v131);
    double v67 = v29 * v114;
    if (v29 * v114 >= 0.0)
    {
      double v68 = *((double *)&v136 + 1);
      double v69 = *(double *)&v136;
      double v70 = *((double *)&v137 + 1);
      double v71 = *(double *)&v137;
    }
    else
    {
      double v68 = *((double *)&v137 + 1);
      double v69 = -*(double *)&v137;
      double v70 = *((double *)&v136 + 1);
      double v71 = -*(double *)&v136;
    }
    double v72 = v66 + 1.0;
    *(double *)&long long v130 = v67 * v69;
    *((double *)&v130 + 1) = v68 + 3.0 + 1.0;
    *(double *)&long long v131 = v67 * v71;
    *((double *)&v131 + 1) = v70 + 3.0 + 1.0;
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v138, (double *)&v130);
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v139, (double *)&v131);
    double v73 = v20 * v120;
    if (v20 * v120 >= 0.0)
    {
      double v74 = *((double *)&v134 + 1);
      double v75 = *(double *)&v134;
      double v76 = *((double *)&v135 + 1);
      double v77 = *(double *)&v135;
    }
    else
    {
      double v74 = *((double *)&v135 + 1);
      double v75 = -*(double *)&v135;
      double v76 = *((double *)&v134 + 1);
      double v77 = -*(double *)&v134;
    }
    *(double *)&long long v130 = v73 * v75;
    *((double *)&v130 + 1) = v74 + 3.0 + 1.0;
    *(double *)&long long v131 = v73 * v77;
    *((double *)&v131 + 1) = v76 + 3.0 + 1.0;
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v138, (double *)&v130);
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v139, (double *)&v131);
    double v78 = v114 * v116;
    if (v114 * v116 >= 0.0)
    {
      double v79 = *((double *)&v134 + 1);
      double v80 = *(double *)&v134;
      double v81 = *((double *)&v135 + 1);
      double v82 = *(double *)&v135;
    }
    else
    {
      double v79 = *((double *)&v135 + 1);
      double v80 = -*(double *)&v135;
      double v81 = *((double *)&v134 + 1);
      double v82 = -*(double *)&v134;
    }
    *(double *)&long long v130 = v78 * v80;
    *((double *)&v130 + 1) = v79 + 3.0 + 1.0;
    *(double *)&long long v131 = v78 * v82;
    *((double *)&v131 + 1) = v81 + 3.0 + 1.0;
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v138, (double *)&v130);
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v139, (double *)&v131);
    *(double *)&long long v130 = v114
                     * boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(*v19 - (uint64_t)*v13, v19[1] - (uint64_t)v13[1], -(uint64_t)a2[1], *a2);
    *((void *)&v130 + 1) = 0x4010000000000000;
    boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v138, (double *)&v130);
    *(double *)&long long v130 = v120
                     * boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(*v11 - (uint64_t)*v10, v11[1] - (uint64_t)v10[1], -(uint64_t)a2[1], *a2);
    *((void *)&v130 + 1) = 0x4010000000000000;
    boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v138, (double *)&v130);
    boost::polygon::detail::robust_fpt<double>::operator+=(v140.f64, (double *)&v139);
    boost::polygon::detail::robust_fpt<double>::operator+=(v141.f64, (double *)&v138);
    *(void *)&long long v130 = sqrt(v113 * (v112 * (v111 + v111)));
    *((double *)&v130 + 1) = (v72 + 1.0) * 0.5 + 1.0;
    if (a5 == 2) {
      boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=(v140.f64, (double *)&v130);
    }
    else {
      boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=(v140.f64, (double *)&v130);
    }
    double v83 = v133 + v133 + 1.0 + 1.0;
    double v84 = v140.f64[1] + v83;
    double v85 = v140.f64[0] / (v132 * v132);
    v140.f64[0] = v85;
    v140.f64[1] = v140.f64[1] + v83;
    double v86 = v83 + v141.f64[1];
    double v87 = v141.f64[0] / (v132 * v132);
    v141.f64[0] = v87;
    v141.f64[1] = v86;
    long long v130 = v136;
    long long v131 = v137;
    long long v128 = v134;
    long long v129 = v135;
    if (v61 >= 0.0)
    {
      double v89 = v84;
      double v84 = v86;
    }
    else
    {
      double v88 = -v87;
      double v87 = -v85;
      double v85 = v88;
      double v89 = v86;
    }
    *(double *)&long long v126 = v61 * v85;
    *((double *)&v126 + 1) = v89 + 3.0 + 1.0;
    *(double *)&long long v127 = v61 * v87;
    *((double *)&v127 + 1) = v84 + 3.0 + 1.0;
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v130, (double *)&v126);
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v131, (double *)&v127);
    if (v67 >= 0.0)
    {
      double v90 = v140.f64[1];
      double v91 = v140.f64[0];
      double v92 = v141.f64[1];
      double v93 = v141.f64[0];
    }
    else
    {
      double v90 = v141.f64[1];
      double v91 = -v141.f64[0];
      double v92 = v140.f64[1];
      double v93 = -v140.f64[0];
    }
    *(double *)&long long v126 = v67 * v91;
    *((double *)&v126 + 1) = v90 + 3.0 + 1.0;
    *(double *)&long long v127 = v67 * v93;
    *((double *)&v127 + 1) = v92 + 3.0 + 1.0;
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v130, (double *)&v126);
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v131, (double *)&v127);
    if (v73 >= 0.0)
    {
      double v94 = v140.f64[1];
      double v95 = v140.f64[0];
      double v96 = v141.f64[1];
      double v97 = v141.f64[0];
    }
    else
    {
      double v94 = v141.f64[1];
      double v95 = -v141.f64[0];
      double v96 = v140.f64[1];
      double v97 = -v140.f64[0];
    }
    *(double *)&long long v126 = v73 * v95;
    *((double *)&v126 + 1) = v94 + 3.0 + 1.0;
    *(double *)&long long v127 = v73 * v97;
    *((double *)&v127 + 1) = v96 + 3.0 + 1.0;
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v128, (double *)&v126);
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v129, (double *)&v127);
    if (v78 >= 0.0)
    {
      double v98 = v140.f64[1];
      double v99 = v140.f64[0];
      double v100 = v141.f64[1];
      double v101 = v141.f64[0];
    }
    else
    {
      double v98 = v141.f64[1];
      double v99 = -v141.f64[0];
      double v100 = v140.f64[1];
      double v101 = -v140.f64[0];
    }
    *(double *)&long long v126 = v78 * v99;
    *((double *)&v126 + 1) = v98 + 3.0 + 1.0;
    *(double *)&long long v127 = v78 * v101;
    *((double *)&v127 + 1) = v100 + 3.0 + 1.0;
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v128, (double *)&v126);
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v129, (double *)&v127);
    float64_t v102 = v140.f64[0];
    double v103 = v141.f64[0];
    if (v140.f64[0] >= v141.f64[0])
    {
      double v105 = v141.f64[0];
      double v103 = v140.f64[0];
    }
    else
    {
      float64_t v104 = v140.f64[1];
      float64x2_t v140 = v141;
      v141.f64[0] = v102;
      v141.f64[1] = v104;
      double v105 = v102;
    }
    long long v126 = v130;
    long long v127 = v131;
    if (v115 >= 0.0)
    {
      double v122 = v115 * v103;
      double v123 = v140.f64[1] + 1.0 + 1.0;
      double v124 = v115 * v105;
      double v125 = v141.f64[1] + 1.0 + 1.0;
      boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v126, &v122);
      signed int v106 = &v124;
    }
    else
    {
      double v122 = -(v105 * v115);
      double v123 = v141.f64[1] + 1.0 + 1.0;
      double v124 = -(v103 * v115);
      double v125 = v140.f64[1] + 1.0 + 1.0;
      boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v126, &v124);
      signed int v106 = &v122;
    }
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v127, v106);
    boost::polygon::detail::robust_fpt<double>::operator-((double *)&v130, (double *)&v131);
    double v48 = v107;
    boost::polygon::detail::robust_fpt<double>::operator-((double *)&v128, (double *)&v129);
    double v50 = v108;
    double v51 = (double *)&v127;
    boost::polygon::detail::robust_fpt<double>::operator-((double *)&v126, (double *)&v127);
    double v53 = v109;
    double v54 = boost::polygon::detail::robust_fpt<double>::operator-((double *)&v130, (double *)&v131);
    double v55 = boost::polygon::detail::robust_fpt<double>::operator-((double *)&v128, (double *)&v129);
    double v56 = (double *)&v126;
  }
  double v110 = boost::polygon::detail::robust_fpt<double>::operator-(v56, v51);
  *(double *)a6 = v54;
  *(double *)(a6 + 8) = v55;
  *(double *)(a6 + 16) = v110;
  *(unsigned char *)(a6 + 24) = 1;
  if (v48 > 64.0 || v50 > 64.0 || v53 > 64.0) {
    boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::pss(a1, (uint64_t)a2, a3, a4, a5, a6, v48 > 64.0, v50 > 64.0, v53 > 64.0);
  }
}

BOOL boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::circle_existence_predicate<boost::polygon::detail::site_event<int>>::sss(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  return (*a2 != *a3 || a2[1] != a3[1] || a2[2] != a3[2] || a2[3] != a3[3])
      && (*a3 != *a4 || a3[1] != a4[1] || a3[2] != a4[2] || a3[3] != a4[3]);
}

void boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::lazy_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::sss(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v8 = *(_DWORD *)(a2 + 8);
  double v93 = (int *)(a2 + 8);
  if ((*(void *)(a2 + 32) & 0x20) != 0) {
    int v9 = *(_DWORD *)a2;
  }
  else {
    int v9 = *(_DWORD *)(a2 + 8);
  }
  double v10 = (double)v9;
  if ((*(void *)(a2 + 32) & 0x20) == 0) {
    int v8 = *(_DWORD *)a2;
  }
  double v11 = (double)v8;
  int v12 = *(_DWORD *)(a2 + 4);
  double v92 = (int *)(a2 + 4);
  double v105 = (int *)(a2 + 12);
  if ((*(void *)(a2 + 32) & 0x20) != 0) {
    int v13 = *(_DWORD *)(a2 + 4);
  }
  else {
    int v13 = *(_DWORD *)(a2 + 12);
  }
  if ((*(void *)(a2 + 32) & 0x20) != 0) {
    int v12 = *(_DWORD *)(a2 + 12);
  }
  double v14 = v10 - v11;
  double v104 = v10 - v11;
  double v15 = (double)v13 - (double)v12;
  double v106 = v15;
  double v97 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v8, v12, v9, v13);
  uint64_t v17 = (int *)(a3 + 8);
  int v16 = *(_DWORD *)(a3 + 8);
  if ((*(void *)(a3 + 32) & 0x20) != 0) {
    int v18 = *(_DWORD *)a3;
  }
  else {
    int v18 = *(_DWORD *)(a3 + 8);
  }
  double v19 = (double)v18;
  if ((*(void *)(a3 + 32) & 0x20) == 0) {
    int v16 = *(_DWORD *)a3;
  }
  double v20 = (double)v16;
  int v21 = *(_DWORD *)(a3 + 4);
  if ((*(void *)(a3 + 32) & 0x20) != 0) {
    int v22 = *(_DWORD *)(a3 + 4);
  }
  else {
    int v22 = *(_DWORD *)(a3 + 12);
  }
  if ((*(void *)(a3 + 32) & 0x20) != 0) {
    int v21 = *(_DWORD *)(a3 + 12);
  }
  double v23 = v19 - v20;
  double v94 = v19 - v20;
  double v24 = (double)v22 - (double)v21;
  double v98 = v24;
  double v96 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v16, v21, v18, v22);
  double v26 = (int *)(a4 + 8);
  int v25 = *(_DWORD *)(a4 + 8);
  if ((*(void *)(a4 + 32) & 0x20) != 0) {
    int v27 = *(_DWORD *)a4;
  }
  else {
    int v27 = *(_DWORD *)(a4 + 8);
  }
  double v28 = (double)v27;
  if ((*(void *)(a4 + 32) & 0x20) == 0) {
    int v25 = *(_DWORD *)a4;
  }
  double v29 = (double)v25;
  int v30 = *(_DWORD *)(a4 + 4);
  if ((*(void *)(a4 + 32) & 0x20) != 0) {
    int v31 = *(_DWORD *)(a4 + 4);
  }
  else {
    int v31 = *(_DWORD *)(a4 + 12);
  }
  if ((*(void *)(a4 + 32) & 0x20) != 0) {
    int v30 = *(_DWORD *)(a4 + 12);
  }
  double v32 = v28 - v29;
  double v95 = v28 - v29;
  double v33 = (double)v31 - (double)v30;
  double v99 = v33;
  double v103 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v25, v30, v27, v31);
  *(double *)&long long v115 = v14 * v14;
  *((void *)&v115 + 1) = 0x3FF0000000000000;
  *(double *)double v114 = v15 * v15;
  *((void *)&v114[0] + 1) = 0x3FF0000000000000;
  double v34 = boost::polygon::detail::robust_fpt<double>::operator+((double *)&v115, (double *)v114);
  double v102 = v35 * 0.5 + 1.0;
  *(double *)&long long v115 = v23 * v23;
  *((void *)&v115 + 1) = 0x3FF0000000000000;
  *(double *)double v114 = v24 * v24;
  *((void *)&v114[0] + 1) = 0x3FF0000000000000;
  double v36 = sqrt(v34);
  double v37 = boost::polygon::detail::robust_fpt<double>::operator+((double *)&v115, (double *)v114);
  *(double *)&long long v115 = v32 * v32;
  *((void *)&v115 + 1) = 0x3FF0000000000000;
  *(double *)double v114 = v33 * v33;
  *((void *)&v114[0] + 1) = 0x3FF0000000000000;
  double v39 = sqrt(v37);
  double v101 = v38 * 0.5 + 1.0;
  double v40 = sqrt(boost::polygon::detail::robust_fpt<double>::operator+((double *)&v115, (double *)v114));
  double v42 = v41 * 0.5 + 1.0;
  int v43 = *v93;
  if ((*(void *)(a2 + 32) & 0x20) != 0) {
    int v44 = *(_DWORD *)a2;
  }
  else {
    int v44 = *v93;
  }
  if ((*(void *)(a2 + 32) & 0x20) != 0)
  {
    double v45 = v93;
  }
  else
  {
    int v43 = *(_DWORD *)a2;
    double v45 = (int *)a2;
  }
  double v46 = v105;
  if ((*(void *)(a2 + 32) & 0x20) != 0) {
    double v46 = v92;
  }
  uint64_t v47 = v44 - (uint64_t)v43;
  uint64_t v48 = *v46 - (uint64_t)v45[1];
  int v49 = *v17;
  if ((*(void *)(a3 + 32) & 0x20) != 0) {
    int v50 = *(_DWORD *)a3;
  }
  else {
    int v50 = *v17;
  }
  if ((*(void *)(a3 + 32) & 0x20) != 0)
  {
    uint64_t v51 = a3 + 8;
  }
  else
  {
    int v49 = *(_DWORD *)a3;
    uint64_t v51 = a3;
  }
  if ((*(void *)(a3 + 32) & 0x20) != 0) {
    double v52 = (int *)(a3 + 4);
  }
  else {
    double v52 = (int *)(a3 + 12);
  }
  double v53 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v47, v48, v50 - (uint64_t)v49, *v52 - (uint64_t)*(int *)(v51 + 4));
  int v54 = *v17;
  if ((*(void *)(a3 + 32) & 0x20) != 0) {
    int v55 = *(_DWORD *)a3;
  }
  else {
    int v55 = *v17;
  }
  if ((*(void *)(a3 + 32) & 0x20) != 0)
  {
    uint64_t v56 = a3 + 8;
  }
  else
  {
    int v54 = *(_DWORD *)a3;
    uint64_t v56 = a3;
  }
  if ((*(void *)(a3 + 32) & 0x20) != 0) {
    double v57 = (int *)(a3 + 4);
  }
  else {
    double v57 = (int *)(a3 + 12);
  }
  uint64_t v58 = v55 - (uint64_t)v54;
  uint64_t v59 = *v57 - (uint64_t)*(int *)(v56 + 4);
  int v60 = *v26;
  if ((*(void *)(a4 + 32) & 0x20) != 0) {
    int v61 = *(_DWORD *)a4;
  }
  else {
    int v61 = *v26;
  }
  if ((*(void *)(a4 + 32) & 0x20) != 0)
  {
    uint64_t v62 = a4 + 8;
  }
  else
  {
    int v60 = *(_DWORD *)a4;
    uint64_t v62 = a4;
  }
  if ((*(void *)(a4 + 32) & 0x20) != 0) {
    double v63 = (int *)(a4 + 4);
  }
  else {
    double v63 = (int *)(a4 + 12);
  }
  double v64 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v58, v59, v61 - (uint64_t)v60, *v63 - (uint64_t)*(int *)(v62 + 4));
  int v65 = *v26;
  if ((*(void *)(a4 + 32) & 0x20) != 0) {
    int v66 = *(_DWORD *)a4;
  }
  else {
    int v66 = *v26;
  }
  if ((*(void *)(a4 + 32) & 0x20) != 0)
  {
    uint64_t v67 = a4 + 8;
  }
  else
  {
    int v65 = *(_DWORD *)a4;
    uint64_t v67 = a4;
  }
  if ((*(void *)(a4 + 32) & 0x20) != 0) {
    double v68 = (int *)(a4 + 4);
  }
  else {
    double v68 = (int *)(a4 + 12);
  }
  uint64_t v69 = v66 - (uint64_t)v65;
  uint64_t v70 = *v68 - (uint64_t)*(int *)(v67 + 4);
  int v71 = *v93;
  if ((*(void *)(a2 + 32) & 0x20) != 0) {
    int v72 = *(_DWORD *)a2;
  }
  else {
    int v72 = *v93;
  }
  if ((*(void *)(a2 + 32) & 0x20) != 0)
  {
    double v73 = v93;
  }
  else
  {
    int v71 = *(_DWORD *)a2;
    double v73 = (int *)a2;
  }
  double v74 = v105;
  if ((*(void *)(a2 + 32) & 0x20) != 0) {
    double v74 = v92;
  }
  double v75 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v69, v70, v72 - (uint64_t)v71, *v74 - (uint64_t)v73[1]);
  long long v115 = 0u;
  long long v116 = 0u;
  *(double *)double v114 = v40 * v53;
  *((double *)v114 + 1) = v42 + 1.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v115, (double *)v114);
  *(double *)double v114 = v36 * v64;
  *((double *)v114 + 1) = v102 + 1.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v115, (double *)v114);
  *(double *)double v114 = v39 * v75;
  *((double *)v114 + 1) = v101 + 1.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v115, (double *)v114);
  memset(v114, 0, sizeof(v114));
  *(double *)&long long v112 = v103 * v53;
  *((void *)&v112 + 1) = 0x4008000000000000;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)v114, (double *)&v112);
  *(double *)&long long v112 = v97 * v64;
  *((void *)&v112 + 1) = 0x4008000000000000;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)v114, (double *)&v112);
  *(double *)&long long v112 = v96 * v75;
  *((void *)&v112 + 1) = 0x4008000000000000;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)v114, (double *)&v112);
  long long v112 = 0u;
  long long v113 = 0u;
  *(double *)&long long v110 = v104 * v96 * v40;
  *((double *)&v110 + 1) = v42 + 2.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v112, (double *)&v110);
  *(double *)&long long v110 = v97 * v94 * v40;
  *((double *)&v110 + 1) = v42 + 2.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v112, (double *)&v110);
  *(double *)&long long v110 = v94 * v103 * v36;
  *((double *)&v110 + 1) = v102 + 2.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v112, (double *)&v110);
  *(double *)&long long v110 = v96 * v95 * v36;
  *((double *)&v110 + 1) = v102 + 2.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v112, (double *)&v110);
  *(double *)&long long v110 = v97 * v95 * v39;
  *((double *)&v110 + 1) = v101 + 2.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v112, (double *)&v110);
  *(double *)&long long v110 = v104 * v103 * v39;
  *((double *)&v110 + 1) = v101 + 2.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v112, (double *)&v110);
  long long v110 = 0u;
  long long v111 = 0u;
  double v107 = v106 * v96 * v40;
  double v108 = v42 + 2.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v110, &v107);
  double v107 = v97 * v98 * v40;
  double v108 = v42 + 2.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v110, &v107);
  double v107 = v98 * v103 * v36;
  double v108 = v102 + 2.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v110, &v107);
  double v107 = v96 * v99 * v36;
  double v108 = v102 + 2.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v110, &v107);
  double v107 = v97 * v99 * v39;
  double v108 = v101 + 2.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v110, &v107);
  double v107 = v106 * v103 * v39;
  double v108 = v101 + 2.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v110, &v107);
  double v107 = boost::polygon::detail::operator+<boost::polygon::detail::robust_fpt<double>>(&v112, v114);
  double v108 = v76;
  v109[0] = v77;
  v109[1] = v78;
  double v79 = boost::polygon::detail::robust_fpt<double>::operator-((double *)&v115, (double *)&v116);
  double v81 = v80;
  double v82 = boost::polygon::detail::robust_fpt<double>::operator-((double *)&v112, (double *)&v113);
  double v84 = v81 + v83 + 1.0;
  double v85 = v82 / v79;
  double v86 = boost::polygon::detail::robust_fpt<double>::operator-((double *)&v110, (double *)&v111);
  double v88 = v81 + v87 + 1.0;
  double v89 = v86 / v79;
  double v91 = boost::polygon::detail::robust_fpt<double>::operator-(&v107, v109) / v79;
  *(double *)a5 = v85;
  *(double *)(a5 + 8) = v89;
  *(double *)(a5 + 16) = v91;
  *(unsigned char *)(a5 + 24) = 1;
  if (v84 > 64.0 || v88 > 64.0 || v81 + v90 + 1.0 > 64.0) {
    boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::sss();
  }
}

double *boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=(double *a1, double *a2)
{
  if (*a2 >= 0.0) {
    boost::polygon::detail::robust_fpt<double>::operator+=(a1, a2);
  }
  else {
    boost::polygon::detail::robust_fpt<double>::operator-=(a1 + 2, a2);
  }
  return a1;
}

double *boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=(double *a1, double *a2)
{
  if (*a2 >= 0.0) {
    boost::polygon::detail::robust_fpt<double>::operator+=(a1 + 2, a2);
  }
  else {
    boost::polygon::detail::robust_fpt<double>::operator-=(a1, a2);
  }
  return a1;
}

void boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::ppp()
{
  MEMORY[0x270FA5388]();
  int v4 = v3;
  int v6 = v5;
  char v8 = v7;
  uint64_t v10 = v9;
  uint64_t v101 = *MEMORY[0x263EF8340];
  uint64_t v11 = *v0;
  uint64_t v12 = *v1;
  uint64_t v13 = v11 - v12;
  if (v11 > v12)
  {
    int v14 = 1;
LABEL_3:
    v95[0] = v13;
    goto LABEL_6;
  }
  if (v13 < 0)
  {
    uint64_t v13 = v12 - v11;
    int v14 = -1;
    goto LABEL_3;
  }
  int v14 = 0;
LABEL_6:
  int v96 = v14;
  uint64_t v15 = *v2;
  uint64_t v16 = v12 - v15;
  if (v12 > v15)
  {
    int v17 = 1;
LABEL_8:
    v97[0] = v16;
    goto LABEL_11;
  }
  if (v16 < 0)
  {
    uint64_t v16 = v15 - v12;
    int v17 = -1;
    goto LABEL_8;
  }
  int v17 = 0;
LABEL_11:
  int v98 = v17;
  uint64_t v18 = v11 - v15;
  if (v11 > v15)
  {
    int v19 = 1;
LABEL_13:
    v99[0] = v18;
    goto LABEL_16;
  }
  if (v18 < 0)
  {
    uint64_t v18 = v15 - v11;
    int v19 = -1;
    goto LABEL_13;
  }
  int v19 = 0;
LABEL_16:
  int v100 = v19;
  uint64_t v20 = v0[1];
  uint64_t v21 = v1[1];
  uint64_t v22 = v20 - v21;
  if (v20 > v21)
  {
    int v23 = 1;
LABEL_18:
    *(void *)double v89 = v22;
    goto LABEL_21;
  }
  if (v22 < 0)
  {
    uint64_t v22 = v21 - v20;
    int v23 = -1;
    goto LABEL_18;
  }
  int v23 = 0;
LABEL_21:
  int v90 = v23;
  uint64_t v24 = v2[1];
  uint64_t v25 = v21 - v24;
  if (v21 > v24)
  {
    int v26 = 1;
LABEL_23:
    v91[0] = v25;
    goto LABEL_26;
  }
  if (v25 < 0)
  {
    uint64_t v25 = v24 - v21;
    int v26 = -1;
    goto LABEL_23;
  }
  int v26 = 0;
LABEL_26:
  int v92 = v26;
  uint64_t v27 = v20 - v24;
  if (v20 > v24)
  {
    int v28 = 1;
LABEL_28:
    *(void *)double v93 = v27;
    goto LABEL_31;
  }
  if (v27 < 0)
  {
    uint64_t v27 = v24 - v20;
    int v28 = -1;
    goto LABEL_28;
  }
  int v28 = 0;
LABEL_31:
  int v94 = v28;
  uint64_t v29 = v12 + v11;
  if (v29 < 1)
  {
    if (v29 < 0)
    {
      v85[0] = -v29;
      if ((unint64_t)-v29 >> 32) {
        int v30 = -2;
      }
      else {
        int v30 = -1;
      }
    }
    else
    {
      int v30 = 0;
    }
  }
  else
  {
    v85[0] = v29;
    int v30 = 1;
  }
  int v86 = v30;
  uint64_t v31 = v15 + v12;
  if (v31 < 1)
  {
    if (v31 < 0)
    {
      v87[0] = -v31;
      if ((unint64_t)-v31 >> 32) {
        int v32 = -2;
      }
      else {
        int v32 = -1;
      }
    }
    else
    {
      int v32 = 0;
    }
  }
  else
  {
    v87[0] = v31;
    int v32 = 1;
  }
  int v88 = v32;
  uint64_t v33 = v21 + v20;
  if (v21 + v20 < 1)
  {
    if (v33 < 0)
    {
      v81[0] = -v33;
      if ((unint64_t)-v33 >> 32) {
        int v34 = -2;
      }
      else {
        int v34 = -1;
      }
    }
    else
    {
      int v34 = 0;
    }
  }
  else
  {
    v81[0] = v21 + v20;
    int v34 = 1;
  }
  int v82 = v34;
  uint64_t v35 = v24 + v21;
  if (v24 + v21 < 1)
  {
    if (v35 < 0)
    {
      v83[0] = -v35;
      if ((unint64_t)-v35 >> 32) {
        int v36 = -2;
      }
      else {
        int v36 = -1;
      }
    }
    else
    {
      int v36 = 0;
    }
  }
  else
  {
    v83[0] = v24 + v21;
    int v36 = 1;
  }
  int v84 = v36;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, (unsigned int *)v95, (uint64_t)v91);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v78, (unsigned int *)v97, (uint64_t)v89);
  boost::polygon::detail::extended_int<64ul>::dif (__dst, __src, (int *)v78);
  boost::polygon::detail::extended_int<64ul>::p(__dst, v37, v38);
  double v41 = 0.5 / ldexp(v39, v40);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, (unsigned int *)v95, (uint64_t)v85);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v78, v89, (uint64_t)v81);
  boost::polygon::detail::extended_int<64ul>::add(__dst, __src, v78);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v78, (unsigned int *)v97, (uint64_t)v87);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v77, (unsigned int *)v91, (uint64_t)v83);
  boost::polygon::detail::extended_int<64ul>::add(__src, v78, v77);
  if ((v8 & 1) != 0 || v4)
  {
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v77, __dst, (uint64_t)v91);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v76, __src, (uint64_t)v89);
    boost::polygon::detail::extended_int<64ul>::dif (v78, v77, (int *)v76);
    boost::polygon::detail::extended_int<64ul>::p(v78, v42, v43);
    *(long double *)uint64_t v10 = v41 * ldexp(v44, v45);
    if (v4)
    {
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v74, (unsigned int *)v95, (uint64_t)v95);
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v73, v89, (uint64_t)v89);
      boost::polygon::detail::extended_int<64ul>::add(v75, v74, v73);
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v71, (unsigned int *)v97, (uint64_t)v97);
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v70, (unsigned int *)v91, (uint64_t)v91);
      boost::polygon::detail::extended_int<64ul>::add(v72, v71, v70);
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v76, v75, (uint64_t)v72);
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v68, (unsigned int *)v99, (uint64_t)v99);
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v67, v93, (uint64_t)v93);
      boost::polygon::detail::extended_int<64ul>::add(v69, v68, v67);
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v77, v76, (uint64_t)v69);
      boost::polygon::detail::extended_int<64ul>::p(v77, v46, v47);
      double v50 = ldexp(v48, v49);
      double v51 = *(double *)v10;
      double v52 = sqrt(v50);
      if (*(double *)v10 >= 0.0)
      {
        if (v41 >= 0.0) {
          double v62 = v51 + v52 * v41;
        }
        else {
          double v62 = v51 - v52 * v41;
        }
      }
      else
      {
        boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v75, v78, (uint64_t)v78);
        boost::polygon::detail::extended_int<64ul>::dif (v76, v75, (int *)v77);
        boost::polygon::detail::extended_int<64ul>::p(v76, v53, v54);
        double v57 = ldexp(v55, v56);
        double v58 = v41 * v57;
        boost::polygon::detail::extended_int<64ul>::p(v78, v57, v59);
        double v62 = v58 / (v52 + ldexp(v60, v61));
      }
      *(double *)(v10 + 16) = v62;
    }
  }
  if (v6)
  {
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v77, __src, (uint64_t)v95);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v76, __dst, (uint64_t)v97);
    boost::polygon::detail::extended_int<64ul>::dif (v78, v77, (int *)v76);
    boost::polygon::detail::extended_int<64ul>::p(v78, v63, v64);
    *(long double *)(v10 + 8) = v41 * ldexp(v65, v66);
  }
}

double *boost::polygon::detail::robust_fpt<double>::operator+=(double *result, double *a2)
{
  double v2 = *result;
  double v3 = *a2;
  double v4 = *result + *a2;
  if ((*result < 0.0 || v3 < 0.0) && (v2 > 0.0 || v3 > 0.0))
  {
    double v5 = (v2 * result[1] - v3 * a2[1]) / v4;
    double v6 = -v5;
    BOOL v7 = v5 < 0.0;
  }
  else
  {
    double v5 = result[1];
    double v6 = a2[1];
    BOOL v7 = v5 < v6;
  }
  if (v7) {
    double v5 = v6;
  }
  *uint64_t result = v4;
  result[1] = v5 + 1.0;
  return result;
}

double *boost::polygon::detail::robust_fpt<double>::operator-=(double *result, double *a2)
{
  double v2 = *result;
  double v3 = *a2;
  double v4 = *result - *a2;
  if ((*result < 0.0 || v3 > 0.0) && (v2 > 0.0 || v3 < 0.0))
  {
    double v5 = (v3 * a2[1] + v2 * result[1]) / v4;
    double v6 = -v5;
    BOOL v7 = v5 < 0.0;
  }
  else
  {
    double v5 = result[1];
    double v6 = a2[1];
    BOOL v7 = v5 < v6;
  }
  if (v7) {
    double v5 = v6;
  }
  *uint64_t result = v4;
  result[1] = v5 + 1.0;
  return result;
}

double boost::polygon::detail::robust_fpt<double>::operator-(double *a1, double *a2)
{
  return *a1 - *a2;
}

double boost::polygon::detail::extended_int<64ul>::p(_DWORD *a1, double result, double a3)
{
  int v4 = a1[64];
  if (v4 >= 0) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = -v4;
  }
  if (v5)
  {
    if (v5 == 1)
    {
      LODWORD(result) = *a1;
      uint64_t result = (double)*(unint64_t *)&result;
    }
    else if (v5 == 2)
    {
      LODWORD(a3) = *a1;
      LODWORD(result) = a1[1];
      uint64_t result = (double)*(unint64_t *)&a3 + (double)*(unint64_t *)&result * 4294967300.0;
    }
    else
    {
      uint64_t v6 = 0;
      uint64_t v7 = (uint64_t)&a1[v5 - 1];
      uint64_t result = 0.0;
      do
      {
        HIDWORD(v8) = 1106247680;
        LODWORD(v8) = *(_DWORD *)(v7 + v6);
        uint64_t result = result * 4294967300.0 + (double)v8;
        v6 -= 4;
      }
      while (v6 != -12);
    }
    if (v4 < 0) {
      return -result;
    }
  }
  return result;
}

uint64_t boost::polygon::detail::extended_int<64ul>::mul(uint64_t result, unsigned int *a2, uint64_t a3)
{
  uint64_t v3 = result;
  int v4 = a2[64];
  if (v4 && (int v6 = *(_DWORD *)(a3 + 256)) != 0)
  {
    if (v4 >= 0) {
      uint64_t v8 = v4;
    }
    else {
      uint64_t v8 = -v4;
    }
    if (v6 >= 0) {
      unint64_t v9 = v6;
    }
    else {
      unint64_t v9 = -v6;
    }
    uint64_t result = boost::polygon::detail::extended_int<64ul>::mul(result, a2, v8, a3, v9);
    if ((int)a2[64] > 0 != *(_DWORD *)(a3 + 256) > 0) {
      *(_DWORD *)(v3 + 256) = -*(_DWORD *)(v3 + 256);
    }
  }
  else
  {
    *(_DWORD *)(result + 256) = 0;
  }
  return result;
}

uint64_t boost::polygon::detail::extended_int<64ul>::mul(uint64_t result, unsigned int *a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v5 = a3 - 1 + a5;
  if (v5 >= 0x40) {
    unint64_t v5 = 64;
  }
  *(_DWORD *)(result + 256) = v5;
  if (v5)
  {
    unint64_t v6 = 0;
    unint64_t v7 = 0;
    do
    {
      if (v6 >= a3 - 1) {
        unint64_t v8 = a3 - 1;
      }
      else {
        unint64_t v8 = v6;
      }
      if (a3)
      {
        uint64_t v9 = 0;
        uint64_t v10 = 0;
        unint64_t v11 = ~v8;
        uint64_t v12 = a2;
        do
        {
          if (v6 + v9 < a5)
          {
            unint64_t v13 = *(unsigned int *)(a4 + 4 * v9) * (unint64_t)*v12;
            v7 += v13;
            v10 += HIDWORD(v13);
          }
          --v9;
          ++v12;
        }
        while (v11 != v9);
      }
      else
      {
        uint64_t v10 = 0;
      }
      *(_DWORD *)(result + 4 * v6) = v7;
      unint64_t v7 = v10 + HIDWORD(v7);
      ++v6;
      unint64_t v14 = *(int *)(result + 256);
      a4 += 4;
    }
    while (v6 < v14);
    if (v7)
    {
      if (v14 != 64)
      {
        *(_DWORD *)(result + 4 * v14) = v7;
        ++*(_DWORD *)(result + 256);
      }
    }
  }
  return result;
}

void *boost::polygon::detail::extended_int<64ul>::dif (_DWORD *__dst, unsigned int *__src, int *a3)
{
  int v5 = __src[64];
  if (!v5)
  {
    uint64_t result = memcpy(__dst, a3, 0x104uLL);
LABEL_17:
    __dst[64] = -__dst[64];
    return result;
  }
  int v7 = a3[64];
  if (v7)
  {
    if (v5 >= 0) {
      unint64_t v8 = v5;
    }
    else {
      unint64_t v8 = -v5;
    }
    if (v7 >= 0) {
      unint64_t v9 = v7;
    }
    else {
      unint64_t v9 = -v7;
    }
    if (v5 > 0 == v7 > 0) {
      uint64_t result = (void *)boost::polygon::detail::extended_int<64ul>::dif ((uint64_t)__dst, (uint64_t)__src, v8, (uint64_t)a3, v9, 0);
    }
    else {
      uint64_t result = boost::polygon::detail::extended_int<64ul>::add(__dst, __src, v8, (unsigned int *)a3, v9);
    }
    if ((__src[64] & 0x80000000) != 0) {
      goto LABEL_17;
    }
  }
  else
  {
    return memcpy(__dst, __src, 0x104uLL);
  }
  return result;
}

_DWORD *boost::polygon::detail::extended_int<64ul>::add(_DWORD *result, unsigned int *a2, unint64_t a3, unsigned int *a4, unint64_t a5)
{
  do
  {
    unint64_t v5 = a5;
    unint64_t v6 = a4;
    a5 = a3;
    a4 = a2;
    a2 = v6;
    a3 = v5;
  }
  while (a5 < v5);
  result[64] = a5;
  unint64_t v7 = 0;
  if (v5)
  {
    unint64_t v8 = a4;
    unint64_t v9 = result;
    unint64_t v10 = v5;
    do
    {
      unsigned int v12 = *v8++;
      uint64_t v11 = v12;
      unsigned int v13 = *v6++;
      unint64_t v14 = v7 + v11 + v13;
      *v9++ = v14;
      unint64_t v7 = HIDWORD(v14);
      --v10;
    }
    while (v10);
  }
  unint64_t v15 = a5 - v5;
  if (a5 > v5)
  {
    uint64_t v16 = &result[v5];
    int v17 = &a4[v5];
    do
    {
      unsigned int v18 = *v17++;
      unint64_t v19 = v7 + v18;
      *v16++ = v19;
      unint64_t v7 = HIDWORD(v19);
      --v15;
    }
    while (v15);
  }
  if (v7)
  {
    uint64_t v20 = (int)result[64];
    if (v20 != 64)
    {
      result[v20] = 1;
      ++result[64];
    }
  }
  return result;
}

uint64_t boost::polygon::detail::extended_int<64ul>::dif (uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, char a6)
{
  unint64_t v6 = a3;
  uint64_t v8 = result;
  if (a3 >= a5)
  {
    if (a3 != a5 || (a6 & 1) != 0)
    {
      unint64_t v14 = (_DWORD *)(result + 256);
      *(_DWORD *)(result + 256) = a3 - 1;
      if (a5)
      {
LABEL_15:
        uint64_t v16 = 0;
        char v15 = 0;
        do
        {
          *(_DWORD *)(result + 4 * v16) = *(_DWORD *)(a2 + 4 * v16) - (v15 & 1) - *(_DWORD *)(a4 + 4 * v16);
          unsigned int v17 = *(_DWORD *)(a2 + 4 * v16);
          unsigned int v18 = *(_DWORD *)(a4 + 4 * v16);
          v15 &= v17 == v18;
          if (v17 < v18) {
            char v15 = 1;
          }
          ++v16;
        }
        while (a5 != v16);
      }
      else
      {
        char v15 = 0;
      }
      BOOL v19 = v6 > a5;
      unint64_t v20 = v6 - a5;
      if (v19)
      {
        uint64_t v21 = (_DWORD *)(result + 4 * a5);
        uint64_t v22 = (int *)(a2 + 4 * a5);
        do
        {
          *v21++ = *v22 - (v15 & 1);
          int v23 = *v22++;
          v15 &= v23 == 0;
          --v20;
        }
        while (v20);
      }
      uint64_t v24 = *(int *)(result + 256);
      if (*(_DWORD *)(result + 4 * v24)) {
        *unint64_t v14 = v24 + 1;
      }
    }
    else
    {
      while (1)
      {
        unint64_t v11 = v6 - 1;
        unsigned int v12 = *(_DWORD *)(a2 - 4 + 4 * v6);
        unsigned int v13 = *(_DWORD *)(a4 - 4 + 4 * v6);
        if (v12 < v13)
        {
          uint64_t v9 = a4;
          unint64_t v10 = v6;
          goto LABEL_3;
        }
        if (v12 > v13) {
          break;
        }
        --v6;
        if (!v11) {
          goto LABEL_25;
        }
      }
      if (v6)
      {
        unint64_t v14 = (_DWORD *)(result + 256);
        *(_DWORD *)(result + 256) = v6 - 1;
        a5 = v6;
        goto LABEL_15;
      }
LABEL_25:
      *(_DWORD *)(result + 256) = 0;
    }
  }
  else
  {
    uint64_t v9 = a4;
    unint64_t v10 = a5;
LABEL_3:
    uint64_t result = boost::polygon::detail::extended_int<64ul>::dif (result, v9, v10, a2, v6, 1);
    *(_DWORD *)(v8 + 256) = -*(_DWORD *)(v8 + 256);
  }
  return result;
}

void *boost::polygon::detail::extended_int<64ul>::add(_DWORD *__dst, unsigned int *__src, unsigned int *a3)
{
  int v5 = __src[64];
  if (v5)
  {
    unint64_t v6 = __src;
    int v7 = a3[64];
    if (v7)
    {
      if (v5 >= 0) {
        unint64_t v8 = v5;
      }
      else {
        unint64_t v8 = -v5;
      }
      if (v7 >= 0) {
        unint64_t v9 = v7;
      }
      else {
        unint64_t v9 = -v7;
      }
      if (v5 > 0 == v7 > 0) {
        uint64_t result = boost::polygon::detail::extended_int<64ul>::add(__dst, __src, v8, a3, v9);
      }
      else {
        uint64_t result = (void *)boost::polygon::detail::extended_int<64ul>::dif ((uint64_t)__dst, (uint64_t)__src, v8, (uint64_t)a3, v9, 0);
      }
      if ((v6[64] & 0x80000000) != 0) {
        __dst[64] = -__dst[64];
      }
      return result;
    }
  }
  else
  {
    __src = a3;
  }

  return memcpy(__dst, __src, 0x104uLL);
}

double boost::polygon::detail::robust_fpt<double>::operator+(double *a1, double *a2)
{
  return *a1 + *a2;
}

void boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::pps(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9 = MEMORY[0x270FA5388]();
  int v12 = v11;
  int v14 = v13;
  uint64_t v16 = v15;
  int v18 = v17;
  BOOL v19 = v10;
  uint64_t v21 = v20;
  int v23 = v22;
  double v106 = (unsigned int *)v9;
  uint64_t v162 = *MEMORY[0x263EF8340];
  uint64_t v24 = v10 + 2;
  if ((*((void *)v10 + 4) & 0x20) != 0) {
    uint64_t v25 = v10;
  }
  else {
    uint64_t v25 = v10 + 2;
  }
  uint64_t v26 = v25[1];
  if ((*((void *)v10 + 4) & 0x20) != 0) {
    uint64_t v27 = v10 + 2;
  }
  else {
    uint64_t v27 = v10;
  }
  uint64_t v28 = v27[1];
  BOOL v29 = v26 <= v28;
  uint64_t v30 = v26 - v28;
  if (!v29)
  {
    int v31 = 1;
LABEL_9:
    *(void *)double v132 = v30;
    goto LABEL_12;
  }
  if (v30 < 0)
  {
    uint64_t v30 = -v30;
    int v31 = -1;
    goto LABEL_9;
  }
  int v31 = 0;
LABEL_12:
  int v133 = v31;
  uint64_t v32 = *v27;
  uint64_t v33 = *v25;
  BOOL v34 = __OFSUB__(v32, v33);
  uint64_t v35 = v32 - v33;
  if (!((v35 < 0) ^ v34 | (v35 == 0)))
  {
    int v36 = 1;
LABEL_14:
    v130[0] = v35;
    goto LABEL_17;
  }
  if (v35 < 0)
  {
    uint64_t v35 = -v35;
    int v36 = -1;
    goto LABEL_14;
  }
  int v36 = 0;
LABEL_17:
  int v131 = v36;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v141, v132, (uint64_t)v132);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v136, (unsigned int *)v130, (uint64_t)v130);
  boost::polygon::detail::extended_int<64ul>::add(__src, v141, v136);
  uint64_t v37 = v21[1];
  uint64_t v38 = v23[1];
  uint64_t v39 = v37 - v38;
  if (v37 > v38)
  {
    int v40 = 1;
LABEL_19:
    *(void *)&v127[0] = v39;
    goto LABEL_22;
  }
  if (v39 < 0)
  {
    uint64_t v39 = v38 - v37;
    int v40 = -1;
    goto LABEL_19;
  }
  int v40 = 0;
LABEL_22:
  int v128 = v40;
  uint64_t v41 = *v23;
  uint64_t v42 = *v21;
  uint64_t v43 = v41 - v42;
  if (v41 > v42)
  {
    int v44 = 1;
LABEL_24:
    *(void *)&v125[0] = v43;
    goto LABEL_27;
  }
  if (v43 < 0)
  {
    uint64_t v43 = v42 - v41;
    int v44 = -1;
    goto LABEL_24;
  }
  int v44 = 0;
LABEL_27:
  int v126 = v44;
  uint64_t v45 = v42 + v41;
  if (v45 < 1)
  {
    if (v45 < 0)
    {
      *(void *)double v123 = -v45;
      if ((unint64_t)-v45 >> 32) {
        int v46 = -2;
      }
      else {
        int v46 = -1;
      }
    }
    else
    {
      int v46 = 0;
    }
  }
  else
  {
    *(void *)double v123 = v45;
    int v46 = 1;
  }
  int v124 = v46;
  uint64_t v47 = v38 + v37;
  if (v47 < 1)
  {
    if (v47 < 0)
    {
      v121[0] = -v47;
      if ((unint64_t)-v47 >> 32) {
        int v48 = -2;
      }
      else {
        int v48 = -1;
      }
    }
    else
    {
      int v48 = 0;
    }
  }
  else
  {
    v121[0] = v47;
    int v48 = 1;
  }
  int v122 = v48;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v141, v132, (uint64_t)v127);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v136, (unsigned int *)v130, (uint64_t)v125);
  boost::polygon::detail::extended_int<64ul>::add(__dst, v141, v136);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v141, (unsigned int *)v127, (uint64_t)v130);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v136, (unsigned int *)v125, (uint64_t)v132);
  boost::polygon::detail::extended_int<64ul>::dif (v118, v141, (int *)v136);
  uint64_t v49 = v19[3];
  uint64_t v50 = v23[1];
  BOOL v29 = v49 <= v50;
  uint64_t v51 = v49 - v50;
  if (!v29)
  {
    int v52 = 1;
LABEL_47:
    v116[0] = v51;
    goto LABEL_50;
  }
  if (v51 < 0)
  {
    uint64_t v51 = -v51;
    int v52 = -1;
    goto LABEL_47;
  }
  int v52 = 0;
LABEL_50:
  int v117 = v52;
  uint64_t v53 = *v23;
  uint64_t v54 = *v24;
  BOOL v29 = v53 <= v54;
  uint64_t v55 = v53 - v54;
  if (!v29)
  {
    int v56 = 1;
LABEL_52:
    v114[0] = v55;
    goto LABEL_55;
  }
  if (v55 < 0)
  {
    uint64_t v55 = -v55;
    int v56 = -1;
    goto LABEL_52;
  }
  int v56 = 0;
LABEL_55:
  int v115 = v56;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v141, v132, (uint64_t)v114);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v136, (unsigned int *)v130, (uint64_t)v116);
  boost::polygon::detail::extended_int<64ul>::dif (v113, v141, (int *)v136);
  uint64_t v57 = v19[3];
  uint64_t v58 = v21[1];
  BOOL v29 = v57 <= v58;
  uint64_t v59 = v57 - v58;
  if (!v29)
  {
    int v60 = 1;
LABEL_57:
    v116[0] = v59;
    goto LABEL_60;
  }
  if (v59 < 0)
  {
    uint64_t v59 = -v59;
    int v60 = -1;
    goto LABEL_57;
  }
  int v60 = 0;
LABEL_60:
  int v117 = v60;
  uint64_t v61 = *v21;
  uint64_t v62 = *v24;
  BOOL v29 = v61 <= v62;
  uint64_t v63 = v61 - v62;
  if (!v29)
  {
    int v64 = 1;
LABEL_62:
    v114[0] = v63;
    goto LABEL_65;
  }
  if (v63 < 0)
  {
    uint64_t v63 = -v63;
    int v64 = -1;
    goto LABEL_62;
  }
  int v64 = 0;
LABEL_65:
  int v115 = v64;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v141, v132, (uint64_t)v114);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v136, (unsigned int *)v130, (uint64_t)v116);
  boost::polygon::detail::extended_int<64ul>::dif (v112, v141, (int *)v136);
  boost::polygon::detail::extended_int<64ul>::add(v111, v113, v112);
  if (!v118[64])
  {
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v141, (unsigned int *)__dst, (uint64_t)__dst);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v136, v111, (uint64_t)v111);
    boost::polygon::detail::extended_int<64ul>::dif (v135, v141, (int *)v136);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v110, (unsigned int *)__dst, (uint64_t)v111);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v134, v110, (uint64_t)v123);
    v141[0] = 2;
    int v142 = 1;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v136, v134, (uint64_t)v141);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v109, (unsigned int *)v135, (uint64_t)v127);
    boost::polygon::detail::extended_int<64ul>::add(v141, v136, v109);
    memcpy(v136, __src, sizeof(v136));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v108, v110, (uint64_t)v111);
    v134[0] = 2;
    v134[64] = 1;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v109, v108, (uint64_t)v134);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v107, (unsigned int *)v135, (uint64_t)__dst);
    boost::polygon::detail::extended_int<64ul>::add(v134, v109, v107);
    memcpy(v143, v134, sizeof(v143));
    v137[0] = 1;
    v137[64] = 1;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v108, v110, (uint64_t)v121);
    v134[0] = 2;
    v134[64] = 1;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v109, v108, (uint64_t)v134);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v107, (unsigned int *)v135, (uint64_t)v125);
    boost::polygon::detail::extended_int<64ul>::add(v134, v109, v107);
    memcpy(v144, v134, sizeof(v144));
    boost::polygon::detail::extended_int<64ul>::p(v110, v88, v89);
    double v92 = ldexp(v90, v91);
    double v93 = 1.0;
    double v70 = 1.0 / v92;
    if (v14)
    {
      boost::polygon::detail::extended_int<64ul>::p(v141, v92, 1.0);
      long double v96 = ldexp(v94, v95);
      double v93 = 0.25;
      double v92 = v70 * (v96 * 0.25);
      *uint64_t v16 = v92;
      if (!v12)
      {
LABEL_84:
        if (!a9) {
          return;
        }
LABEL_88:
        uint64_t v100 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2((uint64_t)v106, v141, v136, v92, v93);
        double v86 = ldexp(*(long double *)&v100, v101);
        double v87 = 0.25;
LABEL_89:
        double v102 = v86 * v87;
        double v103 = v70 * v102;
        boost::polygon::detail::extended_int<64ul>::p(__src, v102, v87);
        v16[2] = v103 / sqrt(ldexp(v104, v105));
        return;
      }
    }
    else if (!v12)
    {
      goto LABEL_84;
    }
    boost::polygon::detail::extended_int<64ul>::p(v144, v92, v93);
    long double v99 = ldexp(v97, v98);
    double v93 = 0.25;
    double v92 = v70 * (v99 * 0.25);
    v16[1] = v92;
    if (!a9) {
      return;
    }
    goto LABEL_88;
  }
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v109, (unsigned int *)__dst, (uint64_t)__dst);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v108, v118, (uint64_t)v118);
  boost::polygon::detail::extended_int<64ul>::add(v110, v109, v108);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v135, v110, (uint64_t)v113);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v136, (unsigned int *)v135, (uint64_t)v112);
  v141[0] = 4;
  int v142 = 1;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v134, v136, (uint64_t)v141);
  boost::polygon::detail::extended_int<64ul>::p(v118, v65, v66);
  long double v69 = ldexp(v67, v68);
  double v70 = 1.0 / v69 * (1.0 / v69);
  if ((v14 & 1) != 0 || a9)
  {
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v135, v123, (uint64_t)v118);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v136, (unsigned int *)v135, (uint64_t)v118);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v109, (unsigned int *)__dst, (uint64_t)v111);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v110, v109, (uint64_t)v127);
    boost::polygon::detail::extended_int<64ul>::add(v141, v136, v110);
    v136[0] = 1;
    v136[64] = 1;
    *(_OWORD *)&v135[192] = v127[12];
    *(_OWORD *)&v135[208] = v127[13];
    *(_OWORD *)&v135[224] = v127[14];
    *(_OWORD *)&v135[240] = v127[15];
    *(_OWORD *)&v135[128] = v127[8];
    *(_OWORD *)&v135[144] = v127[9];
    *(_OWORD *)&v135[160] = v127[10];
    *(_OWORD *)&v135[176] = v127[11];
    *(_OWORD *)&v135[64] = v127[4];
    *(_OWORD *)&v135[80] = v127[5];
    *(_OWORD *)&v135[96] = v127[6];
    *(_OWORD *)&v135[112] = v127[7];
    *(_OWORD *)long long v135 = v127[0];
    *(_OWORD *)&v135[16] = v127[1];
    *(_OWORD *)&v135[32] = v127[2];
    *(_OWORD *)&v135[48] = v127[3];
    int v71 = v128;
    if (v18 == 2) {
      int v71 = -v128;
    }
    *(_OWORD *)&v143[192] = *(_OWORD *)&v135[192];
    *(_OWORD *)&v143[208] = *(_OWORD *)&v135[208];
    *(_OWORD *)&v143[224] = *(_OWORD *)&v135[224];
    *(_OWORD *)&v143[240] = *(_OWORD *)&v135[240];
    *(_OWORD *)&v143[128] = *(_OWORD *)&v135[128];
    *(_OWORD *)&v143[144] = *(_OWORD *)&v135[144];
    *(_OWORD *)&v143[160] = *(_OWORD *)&v135[160];
    *(_OWORD *)&v143[176] = *(_OWORD *)&v135[176];
    *(_OWORD *)&v143[64] = *(_OWORD *)&v135[64];
    *(_OWORD *)&v143[80] = *(_OWORD *)&v135[80];
    *(_OWORD *)&v143[96] = *(_OWORD *)&v135[96];
    *(_OWORD *)&v143[112] = *(_OWORD *)&v135[112];
    *(_OWORD *)double v143 = *(_OWORD *)v135;
    *(_OWORD *)&v143[16] = *(_OWORD *)&v135[16];
    *(_OWORD *)&v143[32] = *(_OWORD *)&v135[32];
    *(_OWORD *)&v143[48] = *(_OWORD *)&v135[48];
    *(_DWORD *)&v143[256] = v71;
    memcpy(v137, v134, sizeof(v137));
    if (v14)
    {
      uint64_t v74 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2((uint64_t)v106, v141, v136, v72, v73);
      *uint64_t v16 = v70 * (ldexp(*(long double *)&v74, v75) * 0.5);
    }
  }
  if ((v12 & 1) != 0 || a9)
  {
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v109, (unsigned int *)v121, (uint64_t)v118);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v110, v109, (uint64_t)v118);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v107, (unsigned int *)__dst, (uint64_t)v111);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v108, v107, (uint64_t)v125);
    boost::polygon::detail::extended_int<64ul>::add(v135, v110, v108);
    memcpy(v144, v135, sizeof(v144));
    v138[0] = 1;
    int v139 = 1;
    *(_OWORD *)&v135[192] = v125[12];
    *(_OWORD *)&v135[208] = v125[13];
    *(_OWORD *)&v135[224] = v125[14];
    *(_OWORD *)&v135[240] = v125[15];
    *(_OWORD *)&v135[128] = v125[8];
    *(_OWORD *)&v135[144] = v125[9];
    *(_OWORD *)&v135[160] = v125[10];
    *(_OWORD *)&v135[176] = v125[11];
    *(_OWORD *)&v135[64] = v125[4];
    *(_OWORD *)&v135[80] = v125[5];
    *(_OWORD *)&v135[96] = v125[6];
    *(_OWORD *)&v135[112] = v125[7];
    *(_OWORD *)long long v135 = v125[0];
    *(_OWORD *)&v135[16] = v125[1];
    *(_OWORD *)&v135[32] = v125[2];
    *(_OWORD *)&v135[48] = v125[3];
    int v76 = v126;
    if (v18 == 2) {
      int v76 = -v126;
    }
    long long v157 = *(_OWORD *)&v135[192];
    long long v158 = *(_OWORD *)&v135[208];
    long long v159 = *(_OWORD *)&v135[224];
    long long v160 = *(_OWORD *)&v135[240];
    long long v153 = *(_OWORD *)&v135[128];
    long long v154 = *(_OWORD *)&v135[144];
    long long v155 = *(_OWORD *)&v135[160];
    long long v156 = *(_OWORD *)&v135[176];
    long long v149 = *(_OWORD *)&v135[64];
    long long v150 = *(_OWORD *)&v135[80];
    long long v151 = *(_OWORD *)&v135[96];
    long long v152 = *(_OWORD *)&v135[112];
    long long v145 = *(_OWORD *)v135;
    long long v146 = *(_OWORD *)&v135[16];
    long long v147 = *(_OWORD *)&v135[32];
    long long v148 = *(_OWORD *)&v135[48];
    int v161 = v76;
    memcpy(v140, v134, sizeof(v140));
    if (v12)
    {
      uint64_t v79 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2((uint64_t)v106, v144, v138, v77, v78);
      v16[1] = v70 * (ldexp(*(long double *)&v79, v80) * 0.5);
    }
  }
  if (a9)
  {
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v135, v136, (uint64_t)__src);
    memcpy(v136, v135, sizeof(v136));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v135, v137, (uint64_t)__src);
    memcpy(v137, v135, sizeof(v137));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v109, v118, (uint64_t)v118);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v108, (unsigned int *)__dst, (uint64_t)__dst);
    boost::polygon::detail::extended_int<64ul>::add(v110, v109, v108);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v135, v111, (uint64_t)v110);
    memcpy(v144, v135, sizeof(v144));
    v138[0] = 1;
    int v139 = 1;
    *(_OWORD *)&v135[192] = __dst[12];
    *(_OWORD *)&v135[208] = __dst[13];
    *(_OWORD *)&v135[224] = __dst[14];
    *(_OWORD *)&v135[240] = __dst[15];
    *(_OWORD *)&v135[128] = __dst[8];
    *(_OWORD *)&v135[144] = __dst[9];
    *(_OWORD *)&v135[160] = __dst[10];
    *(_OWORD *)&v135[176] = __dst[11];
    *(_OWORD *)&v135[64] = __dst[4];
    *(_OWORD *)&v135[80] = __dst[5];
    *(_OWORD *)&v135[96] = __dst[6];
    *(_OWORD *)&v135[112] = __dst[7];
    *(_OWORD *)long long v135 = __dst[0];
    *(_OWORD *)&v135[16] = __dst[1];
    *(_OWORD *)&v135[32] = __dst[2];
    *(_OWORD *)&v135[48] = __dst[3];
    int v81 = v120;
    if (v18 == 2) {
      int v81 = -v120;
    }
    long long v157 = *(_OWORD *)&v135[192];
    long long v158 = *(_OWORD *)&v135[208];
    long long v159 = *(_OWORD *)&v135[224];
    long long v160 = *(_OWORD *)&v135[240];
    long long v153 = *(_OWORD *)&v135[128];
    long long v154 = *(_OWORD *)&v135[144];
    long long v155 = *(_OWORD *)&v135[160];
    long long v156 = *(_OWORD *)&v135[176];
    long long v149 = *(_OWORD *)&v135[64];
    long long v150 = *(_OWORD *)&v135[80];
    long long v151 = *(_OWORD *)&v135[96];
    long long v152 = *(_OWORD *)&v135[112];
    long long v145 = *(_OWORD *)v135;
    long long v146 = *(_OWORD *)&v135[16];
    long long v147 = *(_OWORD *)&v135[32];
    long long v148 = *(_OWORD *)&v135[48];
    int v161 = v81;
    memcpy(v140, v134, sizeof(v140));
    uint64_t v84 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval4(v106, v141, v136, v82, v83);
    double v86 = ldexp(*(long double *)&v84, v85);
    double v87 = 0.5;
    goto LABEL_89;
  }
}

uint64_t boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2(uint64_t a1, unsigned int *a2, _DWORD *a3, double a4, double a5)
{
  double v8 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval1(a4, a5, a1, a2, a3);
  double v10 = v9;
  v27[0] = v9;
  v27[1] = v11;
  boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval1(v8, v12, a1, a2 + 65, a3 + 65);
  v26[0] = v13;
  v26[1] = v14;
  if (v10 >= 0.0 && v13 >= 0.0 || v10 <= 0.0 && v13 <= 0.0) {
    return boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::operator+(v27, v26);
  }
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v23, a2, (uint64_t)a2);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, v23, (uint64_t)a3);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v21, a2 + 65, (uint64_t)(a2 + 65));
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v22, v21, (uint64_t)(a3 + 65));
  boost::polygon::detail::extended_int<64ul>::dif (__dst, __src, v22);
  boost::polygon::detail::extended_int<64ul>::p(__dst, v16, v17);
  double v19 = frexp(v18, &v28);
  double v20 = COERCE_DOUBLE(boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::operator-(v27, (uint64_t)v26));
  return frexp(v19 / v20, &v28);
}

uint64_t boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval4(unsigned int *a1, unsigned int *a2, unsigned int *a3, double a4, double a5)
{
  double v8 = COERCE_DOUBLE(boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2((uint64_t)a1, a2, a3, a4, a5));
  *(double *)uint64_t v30 = v8;
  v30[1] = v9;
  double v12 = COERCE_DOUBLE(boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2((uint64_t)a1, a2 + 130, a3 + 130, v10, v11));
  v29[0] = v12;
  v29[1] = v13;
  if (v8 >= 0.0 && v12 >= 0.0 || v8 <= 0.0 && v12 <= 0.0) {
    return boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::operator+(v30, v29);
  }
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v25, a2, (uint64_t)a2);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v26, v25, (uint64_t)a3);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v23, a2 + 65, (uint64_t)(a2 + 65));
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v24, v23, (uint64_t)(a3 + 65));
  boost::polygon::detail::extended_int<64ul>::add(__dst, v26, v24);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v21, a2 + 130, (uint64_t)(a2 + 130));
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v22, v21, (uint64_t)(a3 + 130));
  boost::polygon::detail::extended_int<64ul>::dif (v28, __dst, v22);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v19, a2 + 195, (uint64_t)(a2 + 195));
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v20, v19, (uint64_t)(a3 + 195));
  boost::polygon::detail::extended_int<64ul>::dif (__src, v28, v20);
  memcpy(a1, __src, 0x104uLL);
  a1[325] = 1;
  a1[389] = 1;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__dst, a2, (uint64_t)(a2 + 65));
  LODWORD(__src[0]) = 2;
  LODWORD(__src[32]) = 1;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v28, __dst, (uint64_t)__src);
  memcpy(a1 + 65, v28, 0x104uLL);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, a3, (uint64_t)(a3 + 65));
  memcpy(a1 + 390, __src, 0x104uLL);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__dst, a2 + 130, (uint64_t)(a2 + 195));
  LODWORD(__src[0]) = 2;
  LODWORD(__src[32]) = -1;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v28, __dst, (uint64_t)__src);
  memcpy(a1 + 130, v28, 0x104uLL);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, a3 + 130, (uint64_t)(a3 + 195));
  memcpy(a1 + 455, __src, 0x104uLL);
  double v17 = COERCE_DOUBLE(boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval3(a1, a1, a1 + 325, v15, v16));
  double v18 = COERCE_DOUBLE(boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::operator-(v30, (uint64_t)v29));
  return frexp(v17 / v18, (int *)&__src[1]);
}

long double boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval1(double a1, double a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  boost::polygon::detail::extended_int<64ul>::p(a4, a1, a2);
  double v7 = frexp(v6, (int *)&v15);
  boost::polygon::detail::extended_int<64ul>::p(a5, v7, v8);
  LODWORD(a5) = v9;
  long double v11 = frexp(v10, (int *)&v15);
  LODWORD(v15) = v15 + a5;
  *(long double *)long double v14 = v11;
  v14[1] = v15;
  boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::sqrt((uint64_t)v14);
  return frexp(v7 * v12, (int *)&v15);
}

uint64_t boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::operator+(_DWORD *a1, long double *a2)
{
  long double v2 = *(double *)a1;
  if (*(double *)a1 == 0.0) {
    return *(_OWORD *)a2;
  }
  int v3 = *((_DWORD *)a2 + 2);
  int v4 = a1[2];
  if (v3 > v4 + 54) {
    return *(_OWORD *)a2;
  }
  double v7 = *a2;
  if (*a2 == 0.0 || v4 > v3 + 54) {
    return *(_OWORD *)a1;
  }
  if (v4 >= v3)
  {
    long double v11 = ldexp(v2, v4 - v3);
    *(void *)&long long v12 = frexp(v7 + v11, (int *)&v12 + 2);
    int v10 = DWORD2(v12) + v3;
  }
  else
  {
    long double v9 = ldexp(*a2, v3 - v4);
    *(void *)&long long v12 = frexp(v2 + v9, (int *)&v12 + 2);
    int v10 = DWORD2(v12) + v4;
  }
  DWORD2(v12) = v10;
  return v12;
}

uint64_t boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::operator-(_DWORD *a1, uint64_t a2)
{
  long double v2 = *(double *)a1;
  int v3 = *(_DWORD *)(a2 + 8);
  if (*(double *)a1 == 0.0 || (int v4 = a1[2], v3 > v4 + 54))
  {
    long double v5 = -*(double *)a2;
    goto LABEL_4;
  }
  double v9 = *(double *)a2;
  if (*(double *)a2 != 0.0 && v4 <= v3 + 54)
  {
    if (v4 < v3)
    {
      long double v11 = ldexp(-v9, v3 - v4);
      double v6 = frexp(v2 + v11, (int *)&v12 + 2);
      int v7 = DWORD2(v12) + v4;
      goto LABEL_5;
    }
    long double v5 = ldexp(v2, v4 - v3) - v9;
LABEL_4:
    double v6 = frexp(v5, (int *)&v12 + 2);
    int v7 = DWORD2(v12) + v3;
LABEL_5:
    DWORD2(v12) = v7;
    return *(void *)&v6;
  }
  return *(_OWORD *)a1;
}

long double boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::sqrt(uint64_t a1)
{
  double v1 = *(double *)a1;
  if (*(_DWORD *)(a1 + 8)) {
    double v1 = v1 + v1;
  }
  return frexp(sqrt(v1), (int *)&v3);
}

uint64_t boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval3(_DWORD *a1, unsigned int *a2, unsigned int *a3, double a4, double a5)
{
  double v8 = COERCE_DOUBLE(boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2((uint64_t)a1, a2, a3, a4, a5));
  v27[0] = v8;
  v27[1] = v9;
  boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval1(v10, v11, (uint64_t)a1, a2 + 130, a3 + 130);
  v26[0] = v12;
  v26[1] = v13;
  if (v8 >= 0.0 && v12 >= 0.0 || v8 <= 0.0 && v12 <= 0.0) {
    return boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::operator+(v27, v26);
  }
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v23, a2, (uint64_t)a2);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v24, v23, (uint64_t)a3);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v21, a2 + 65, (uint64_t)(a2 + 65));
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v22, v21, (uint64_t)(a3 + 65));
  boost::polygon::detail::extended_int<64ul>::add(__dst, v24, v22);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v19, a2 + 130, (uint64_t)(a2 + 130));
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v20, v19, (uint64_t)(a3 + 130));
  boost::polygon::detail::extended_int<64ul>::dif (__src, __dst, v20);
  memcpy(a1 + 195, __src, 0x104uLL);
  a1[520] = 1;
  a1[584] = 1;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v24, a2, (uint64_t)(a2 + 65));
  __src[0] = 2;
  __src[64] = 1;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__dst, v24, (uint64_t)__src);
  memcpy(a1 + 260, __dst, 0x104uLL);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, a3, (uint64_t)(a3 + 65));
  memcpy(a1 + 585, __src, 0x104uLL);
  double v17 = COERCE_DOUBLE(boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2((uint64_t)a1, a1 + 195, a1 + 520, v15, v16));
  double v18 = COERCE_DOUBLE(boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::operator-(v27, (uint64_t)v26));
  return frexp(v17 / v18, &__src[2]);
}

void boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::pss(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9 = MEMORY[0x270FA5388]();
  int v13 = v12;
  int v110 = v14;
  uint64_t v16 = v15;
  int v18 = v17;
  double v20 = v19;
  long long v111 = (_DWORD *)v9;
  uint64_t v147 = *MEMORY[0x263EF8340];
  BOOL v21 = (*((void *)v10 + 4) & 0x20) == 0;
  if (v21) {
    uint64_t v22 = v10 + 2;
  }
  else {
    uint64_t v22 = v10;
  }
  if (v21) {
    int v23 = v10;
  }
  else {
    int v23 = v10 + 2;
  }
  uint64_t v24 = *((void *)v11 + 4);
  if ((v24 & 0x20) != 0) {
    uint64_t v25 = v11 + 2;
  }
  else {
    uint64_t v25 = v11;
  }
  if ((v24 & 0x20) != 0) {
    uint64_t v26 = v11;
  }
  else {
    uint64_t v26 = v11 + 2;
  }
  uint64_t v27 = *(int *)((char *)v10 + ((*((void *)v10 + 4) >> 2) & 8));
  uint64_t v28 = v10[2 * v21];
  BOOL v29 = __OFSUB__(v27, v28);
  uint64_t v30 = v27 - v28;
  if (!((v30 < 0) ^ v29 | (v30 == 0)))
  {
    int v31 = 1;
LABEL_15:
    *(void *)int v142 = v30;
    goto LABEL_18;
  }
  if (v30 < 0)
  {
    uint64_t v30 = -v30;
    int v31 = -1;
    goto LABEL_15;
  }
  int v31 = 0;
LABEL_18:
  int v143 = v31;
  uint64_t v32 = v23[1];
  uint64_t v33 = v22[1];
  BOOL v34 = v32 <= v33;
  uint64_t v35 = v32 - v33;
  if (!v34)
  {
    int v36 = 1;
LABEL_20:
    *(void *)long long v138 = v35;
    goto LABEL_23;
  }
  if (v35 < 0)
  {
    uint64_t v35 = -v35;
    int v36 = -1;
    goto LABEL_20;
  }
  int v36 = 0;
LABEL_23:
  int v139 = v36;
  uint64_t v37 = *v26;
  uint64_t v38 = *v25;
  BOOL v34 = v37 <= v38;
  uint64_t v39 = v37 - v38;
  if (!v34)
  {
    int v40 = 1;
LABEL_25:
    v144[0] = v39;
    goto LABEL_28;
  }
  if (v39 < 0)
  {
    uint64_t v39 = -v39;
    int v40 = -1;
    goto LABEL_25;
  }
  int v40 = 0;
LABEL_28:
  int v145 = v40;
  uint64_t v41 = v26[1];
  uint64_t v42 = v25[1];
  BOOL v29 = __OFSUB__(v41, v42);
  uint64_t v43 = v41 - v42;
  if (!((v43 < 0) ^ v29 | (v43 == 0)))
  {
    int v44 = 1;
LABEL_30:
    v140[0] = v43;
    goto LABEL_33;
  }
  if (v43 < 0)
  {
    uint64_t v43 = -v43;
    int v44 = -1;
    goto LABEL_30;
  }
  int v44 = 0;
LABEL_33:
  int v141 = v44;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v131, (unsigned int *)v144, (uint64_t)v138);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v127, v142, (uint64_t)v140);
  boost::polygon::detail::extended_int<64ul>::dif (v125, v131, (int *)v127);
  if (v126)
  {
    int v45 = *v23;
    if (*v23 <= 0)
    {
      if ((v45 & 0x80000000) == 0)
      {
        unsigned int v46 = 0;
LABEL_56:
        v131[64] = v46;
        boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v127, v138, (uint64_t)v131);
        int v69 = v23[1];
        if (v69 <= 0)
        {
          if ((v69 & 0x80000000) == 0)
          {
            unsigned int v70 = 0;
LABEL_61:
            v131[64] = v70;
            boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v146, v142, (uint64_t)v131);
            boost::polygon::detail::extended_int<64ul>::dif (v135, v127, (int *)v146);
            int v71 = v26[1];
            if (v71 <= 0)
            {
              if ((v71 & 0x80000000) == 0)
              {
                unsigned int v72 = 0;
LABEL_66:
                v131[64] = v72;
                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v127, (unsigned int *)v144, (uint64_t)v131);
                int v73 = *v26;
                if (*v26 <= 0)
                {
                  if ((v73 & 0x80000000) == 0)
                  {
                    unsigned int v74 = 0;
LABEL_71:
                    v131[64] = v74;
                    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v146, (unsigned int *)v140, (uint64_t)v131);
                    boost::polygon::detail::extended_int<64ul>::dif (v131, v127, (int *)v146);
                    memcpy(v137, v131, sizeof(v137));
                    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v131, v142, (uint64_t)v137);
                    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v127, (unsigned int *)v144, (uint64_t)v135);
                    boost::polygon::detail::extended_int<64ul>::add(v124, v131, v127);
                    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v131, v138, (uint64_t)v137);
                    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v127, (unsigned int *)v140, (uint64_t)v135);
                    boost::polygon::detail::extended_int<64ul>::add(v123, v131, v127);
                    int v75 = *v20;
                    if (*v20 <= 0)
                    {
                      if ((v75 & 0x80000000) == 0)
                      {
                        unsigned int v76 = 0;
LABEL_76:
                        v131[64] = v76;
                        boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v127, v125, (uint64_t)v131);
                        boost::polygon::detail::extended_int<64ul>::dif (__src, v124, (int *)v127);
                        int v77 = v20[1];
                        if (v77 <= 0)
                        {
                          if ((v77 & 0x80000000) == 0)
                          {
                            unsigned int v78 = 0;
LABEL_81:
                            v131[64] = v78;
                            boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v127, v125, (uint64_t)v131);
                            boost::polygon::detail::extended_int<64ul>::dif (v121, v123, (int *)v127);
                            if (!(__src[64] | v121[64]))
                            {
                              boost::polygon::detail::extended_int<64ul>::p(v125, v79, v80);
                              double v83 = ldexp(v81, v82);
                              boost::polygon::detail::extended_int<64ul>::p(v124, v83, v84);
                              double v87 = ldexp(v85, v86);
                              double v88 = v87 / v83;
                              boost::polygon::detail::extended_int<64ul>::p(v123, v87, v89);
                              long double v92 = ldexp(v90, v91);
                              *(double *)uint64_t v16 = v88;
                              *(long double *)(v16 + 8) = v92 / v83;
                              *(double *)(v16 + 16) = v88;
                              *(unsigned char *)(v16 + 24) = 1;
                              return;
                            }
                            if (v126 >= 0) {
                              int v93 = -1;
                            }
                            else {
                              int v93 = 1;
                            }
                            if (v18 == 2) {
                              int v94 = v93;
                            }
                            else {
                              int v94 = -v93;
                            }
                            unsigned int v95 = 1;
                            if (v94 <= 0)
                            {
                              if ((v94 & 0x80000000) == 0)
                              {
                                unsigned int v95 = 0;
LABEL_97:
                                v120[64] = v95;
                                memcpy(v146, __src, sizeof(v146));
                                *(_DWORD *)&v146[256] = -*(_DWORD *)&v146[256];
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v127, (unsigned int *)v144, (uint64_t)v146);
                                memcpy(__dst, v121, sizeof(__dst));
                                __dst[64] = -__dst[64];
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v119, (unsigned int *)v140, (uint64_t)__dst);
                                boost::polygon::detail::extended_int<64ul>::add(v131, v127, v119);
                                memcpy(v119, __src, sizeof(v119));
                                v119[64] = -v119[64];
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v146, v142, (uint64_t)v119);
                                memcpy(v117, v121, sizeof(v117));
                                v117[64] = -v117[64];
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__dst, v138, (uint64_t)v117);
                                boost::polygon::detail::extended_int<64ul>::add(v127, (unsigned int *)v146, __dst);
                                memcpy(v132, v127, sizeof(v132));
                                memcpy(v133, v120, sizeof(v133));
                                v134[64] = 0;
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v146, v142, (uint64_t)v142);
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v119, v138, (uint64_t)v138);
                                boost::polygon::detail::extended_int<64ul>::add(v127, (unsigned int *)v146, v119);
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v119, (unsigned int *)v144, (uint64_t)v144);
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__dst, (unsigned int *)v140, (uint64_t)v140);
                                boost::polygon::detail::extended_int<64ul>::add(v146, v119, __dst);
                                memcpy(v128, v146, sizeof(v128));
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v119, v142, (uint64_t)v144);
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__dst, v138, (uint64_t)v140);
                                boost::polygon::detail::extended_int<64ul>::add(v146, v119, __dst);
                                memcpy(v129, v146, sizeof(v129));
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v116, v142, (uint64_t)v121);
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v115, v138, (uint64_t)__src);
                                boost::polygon::detail::extended_int<64ul>::dif (v117, v116, (int *)v115);
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v113, (unsigned int *)v144, (uint64_t)v121);
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v112, (unsigned int *)v140, (uint64_t)__src);
                                boost::polygon::detail::extended_int<64ul>::dif (v114, v113, (int *)v112);
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__dst, v117, (uint64_t)v114);
                                *(_DWORD *)long long v146 = 2;
                                *(_DWORD *)&v146[256] = -1;
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v119, __dst, (uint64_t)v146);
                                memcpy(v130, v119, sizeof(v130));
                                uint64_t v96 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::sqrt_expr_evaluator_pss4<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>>();
                                double v98 = ldexp(*(long double *)&v96, v97);
                                boost::polygon::detail::extended_int<64ul>::p(v125, v98, v99);
                                double v102 = v98 * ldexp(v100, v101);
                                if (v13)
                                {
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v117, __src, (uint64_t)__src);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v116, v121, (uint64_t)v121);
                                  boost::polygon::detail::extended_int<64ul>::add(__dst, v117, v116);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v119, (unsigned int *)v140, (uint64_t)__dst);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v113, __src, (uint64_t)v144);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v112, v121, (uint64_t)v140);
                                  boost::polygon::detail::extended_int<64ul>::add(v114, v113, v112);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v115, v123, (uint64_t)v114);
                                  boost::polygon::detail::extended_int<64ul>::dif (v146, v119, (int *)v115);
                                  memcpy(v131, v146, sizeof(v131));
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v117, __src, (uint64_t)__src);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v116, v121, (uint64_t)v121);
                                  boost::polygon::detail::extended_int<64ul>::add(__dst, v117, v116);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v119, v138, (uint64_t)__dst);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v113, __src, (uint64_t)v142);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v112, v121, (uint64_t)v138);
                                  boost::polygon::detail::extended_int<64ul>::add(v114, v113, v112);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v115, v123, (uint64_t)v114);
                                  boost::polygon::detail::extended_int<64ul>::dif (v146, v119, (int *)v115);
                                  memcpy(v132, v146, sizeof(v132));
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v146, v123, (uint64_t)v120);
                                  memcpy(v133, v146, sizeof(v133));
                                  uint64_t v103 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::sqrt_expr_evaluator_pss4<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>>();
                                  *(long double *)(v16 + 8) = ldexp(*(long double *)&v103, v104) / v102;
                                }
                                if ((v110 & 1) != 0 || a9)
                                {
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v117, __src, (uint64_t)__src);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v116, v121, (uint64_t)v121);
                                  boost::polygon::detail::extended_int<64ul>::add(__dst, v117, v116);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v119, (unsigned int *)v144, (uint64_t)__dst);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v113, __src, (uint64_t)v144);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v112, v121, (uint64_t)v140);
                                  boost::polygon::detail::extended_int<64ul>::add(v114, v113, v112);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v115, v124, (uint64_t)v114);
                                  boost::polygon::detail::extended_int<64ul>::dif (v146, v119, (int *)v115);
                                  memcpy(v131, v146, sizeof(v131));
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v117, __src, (uint64_t)__src);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v116, v121, (uint64_t)v121);
                                  boost::polygon::detail::extended_int<64ul>::add(__dst, v117, v116);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v119, v142, (uint64_t)__dst);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v113, __src, (uint64_t)v142);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v112, v121, (uint64_t)v138);
                                  boost::polygon::detail::extended_int<64ul>::add(v114, v113, v112);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v115, v124, (uint64_t)v114);
                                  boost::polygon::detail::extended_int<64ul>::dif (v146, v119, (int *)v115);
                                  memcpy(v132, v146, sizeof(v132));
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v146, v124, (uint64_t)v120);
                                  memcpy(v133, v146, sizeof(v133));
                                  if (v110)
                                  {
                                    uint64_t v105 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::sqrt_expr_evaluator_pss4<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>>();
                                    *(long double *)uint64_t v16 = ldexp(*(long double *)&v105, v106) / v102;
                                  }
                                  if (a9)
                                  {
                                    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v116, __src, (uint64_t)__src);
                                    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v115, v121, (uint64_t)v121);
                                    boost::polygon::detail::extended_int<64ul>::add(v117, v116, v115);
                                    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__dst, v125, (uint64_t)v117);
                                    if (v98 >= 0.0) {
                                      int v107 = 1;
                                    }
                                    else {
                                      int v107 = -1;
                                    }
                                    *(_DWORD *)long long v146 = 1;
                                    *(_DWORD *)&v146[256] = v107;
                                    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v119, __dst, (uint64_t)v146);
                                    memcpy(v134, v119, sizeof(v134));
                                    uint64_t v108 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::sqrt_expr_evaluator_pss4<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>>();
                                    double v68 = ldexp(*(long double *)&v108, v109) / v102;
LABEL_108:
                                    *(double *)(v16 + 16) = v68;
                                    return;
                                  }
                                }
                                return;
                              }
                              unsigned int v95 = -1;
                            }
                            v120[0] = 1;
                            goto LABEL_97;
                          }
                          int v77 = -v77;
                          unsigned int v78 = -1;
                        }
                        else
                        {
                          unsigned int v78 = 1;
                        }
                        v131[0] = v77;
                        goto LABEL_81;
                      }
                      int v75 = -v75;
                      unsigned int v76 = -1;
                    }
                    else
                    {
                      unsigned int v76 = 1;
                    }
                    v131[0] = v75;
                    goto LABEL_76;
                  }
                  int v73 = -v73;
                  unsigned int v74 = -1;
                }
                else
                {
                  unsigned int v74 = 1;
                }
                v131[0] = v73;
                goto LABEL_71;
              }
              int v71 = -v71;
              unsigned int v72 = -1;
            }
            else
            {
              unsigned int v72 = 1;
            }
            v131[0] = v71;
            goto LABEL_66;
          }
          int v69 = -v69;
          unsigned int v70 = -1;
        }
        else
        {
          unsigned int v70 = 1;
        }
        v131[0] = v69;
        goto LABEL_61;
      }
      int v45 = -v45;
      unsigned int v46 = -1;
    }
    else
    {
      unsigned int v46 = 1;
    }
    v131[0] = v45;
    goto LABEL_56;
  }
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v127, v142, (uint64_t)v142);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v135, v138, (uint64_t)v138);
  boost::polygon::detail::extended_int<64ul>::add(v131, v127, (unsigned int *)v135);
  boost::polygon::detail::extended_int<64ul>::p(v131, v47, v48);
  long double v51 = ldexp(v49, v50);
  double v52 = v51 + v51;
  boost::polygon::detail::extended_int<64ul>::operator*(v138, *v25 - (uint64_t)*v22, (uint64_t)v131);
  boost::polygon::detail::extended_int<64ul>::operator*(v142, v25[1] - (uint64_t)v22[1], (uint64_t)v127);
  boost::polygon::detail::extended_int<64ul>::dif (v135, v131, (int *)v127);
  boost::polygon::detail::extended_int<64ul>::operator*(v142, v20[1] - (uint64_t)v22[1], (uint64_t)v131);
  boost::polygon::detail::extended_int<64ul>::operator*(v138, *v20 - (uint64_t)*v22, (uint64_t)v127);
  boost::polygon::detail::extended_int<64ul>::dif (v124, v131, (int *)v127);
  boost::polygon::detail::extended_int<64ul>::operator*(v138, *v20 - (uint64_t)*v25, (uint64_t)v131);
  boost::polygon::detail::extended_int<64ul>::operator*(v142, v20[1] - (uint64_t)v25[1], (uint64_t)v127);
  boost::polygon::detail::extended_int<64ul>::dif (v123, v131, (int *)v127);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v127, v124, (uint64_t)v123);
  v128[0] = 1;
  v128[64] = 1;
  if (v13)
  {
    if (v18 == 2) {
      int v53 = 1;
    }
    else {
      int v53 = -1;
    }
    *(_DWORD *)long long v146 = 2;
    *(_DWORD *)&v146[256] = v53;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v131, v138, (uint64_t)v146);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v120, v142, (uint64_t)v142);
    boost::polygon::detail::extended_int<64ul>::operator*(v120, v25[1] + (uint64_t)v22[1], (uint64_t)v121);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__dst, v142, (uint64_t)v138);
    boost::polygon::detail::extended_int<64ul>::operator*(__dst, *v25 + (uint64_t)*v22 - 2 * *v20, (uint64_t)v119);
    boost::polygon::detail::extended_int<64ul>::dif (__src, v121, (int *)v119);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v116, v138, (uint64_t)v138);
    boost::polygon::detail::extended_int<64ul>::operator*(v116, 2 * v20[1], (uint64_t)v117);
    boost::polygon::detail::extended_int<64ul>::add(v146, __src, v117);
    memcpy(v132, v146, sizeof(v132));
    uint64_t v56 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2((uint64_t)v111, v131, v127, v54, v55);
    *(long double *)(v16 + 8) = ldexp(*(long double *)&v56, v57) / v52;
  }
  if ((v110 & 1) != 0 || a9)
  {
    if (v18 == 2) {
      int v58 = 1;
    }
    else {
      int v58 = -1;
    }
    *(_DWORD *)long long v146 = 2;
    *(_DWORD *)&v146[256] = v58;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, v142, (uint64_t)v146);
    memcpy(v131, __src, sizeof(v131));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v120, v138, (uint64_t)v138);
    boost::polygon::detail::extended_int<64ul>::operator*(v120, *v25 + (uint64_t)*v22, (uint64_t)v121);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__dst, v142, (uint64_t)v138);
    boost::polygon::detail::extended_int<64ul>::operator*(__dst, v25[1] + (uint64_t)v22[1] - 2 * v20[1], (uint64_t)v119);
    boost::polygon::detail::extended_int<64ul>::dif (__src, v121, (int *)v119);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v116, v142, (uint64_t)v142);
    boost::polygon::detail::extended_int<64ul>::operator*(v116, 2 * *v20, (uint64_t)v117);
    boost::polygon::detail::extended_int<64ul>::add(v146, __src, v117);
    memcpy(v132, v146, sizeof(v132));
    if (v110)
    {
      uint64_t v61 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2((uint64_t)v111, v131, v127, v59, v60);
      *(long double *)uint64_t v16 = ldexp(*(long double *)&v61, v62) / v52;
    }
    if (a9)
    {
      *(_OWORD *)&v146[192] = v135[12];
      *(_OWORD *)&v146[208] = v135[13];
      *(_OWORD *)&v146[224] = v135[14];
      *(_OWORD *)&v146[240] = v135[15];
      *(_OWORD *)&v146[128] = v135[8];
      *(_OWORD *)&v146[144] = v135[9];
      *(_OWORD *)&v146[160] = v135[10];
      *(_OWORD *)&v146[176] = v135[11];
      *(_OWORD *)&v146[64] = v135[4];
      *(_OWORD *)&v146[80] = v135[5];
      *(_OWORD *)&v146[96] = v135[6];
      *(_OWORD *)&v146[112] = v135[7];
      *(_OWORD *)long long v146 = v135[0];
      *(_OWORD *)&v146[16] = v135[1];
      *(_OWORD *)&v146[32] = v135[2];
      *(_OWORD *)&v146[48] = v135[3];
      if (v136 >= 0) {
        int v63 = v136;
      }
      else {
        int v63 = -v136;
      }
      *(_OWORD *)&v133[192] = *(_OWORD *)&v146[192];
      *(_OWORD *)&v133[208] = *(_OWORD *)&v146[208];
      *(_OWORD *)&v133[224] = *(_OWORD *)&v146[224];
      *(_OWORD *)&v133[240] = *(_OWORD *)&v146[240];
      *(_OWORD *)&v133[128] = *(_OWORD *)&v146[128];
      *(_OWORD *)&v133[144] = *(_OWORD *)&v146[144];
      *(_OWORD *)&v133[160] = *(_OWORD *)&v146[160];
      *(_OWORD *)&v133[176] = *(_OWORD *)&v146[176];
      *(_OWORD *)&v133[64] = *(_OWORD *)&v146[64];
      *(_OWORD *)&v133[80] = *(_OWORD *)&v146[80];
      *(_OWORD *)&v133[96] = *(_OWORD *)&v146[96];
      *(_OWORD *)&v133[112] = *(_OWORD *)&v146[112];
      *(_OWORD *)int v133 = *(_OWORD *)v146;
      *(_OWORD *)&v133[16] = *(_OWORD *)&v146[16];
      *(_OWORD *)&v133[32] = *(_OWORD *)&v146[32];
      *(_OWORD *)&v133[48] = *(_OWORD *)&v146[48];
      *(_DWORD *)&v133[256] = v63;
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, v142, (uint64_t)v142);
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v121, v138, (uint64_t)v138);
      boost::polygon::detail::extended_int<64ul>::add(v146, __src, v121);
      memcpy(v129, v146, sizeof(v129));
      uint64_t v66 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval3(v111, v131, v127, v64, v65);
      double v68 = ldexp(*(long double *)&v66, v67) / v52;
      goto LABEL_108;
    }
  }
}

uint64_t boost::polygon::detail::extended_int<64ul>::operator*@<X0>(unsigned int *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2 < 1)
  {
    if (a2 < 0)
    {
      v7[0] = -a2;
      if ((unint64_t)-a2 >> 32) {
        int v5 = -2;
      }
      else {
        int v5 = -1;
      }
    }
    else
    {
      int v5 = 0;
    }
  }
  else
  {
    v7[0] = a2;
    if (HIDWORD(a2)) {
      int v5 = 2;
    }
    else {
      int v5 = 1;
    }
  }
  int v8 = v5;
  return boost::polygon::detail::extended_int<64ul>::mul(a3, a1, (uint64_t)v7);
}

uint64_t boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::sqrt_expr_evaluator_pss4<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>>()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  int v5 = v2;
  double v6 = v1;
  int v7 = (_DWORD *)v0;
  uint64_t v74 = *MEMORY[0x263EF8340];
  if (v1[259])
  {
    __dst[0] = 1;
    __dst[64] = 1;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v67, v2, (uint64_t)(v2 + 65));
    memcpy(v71, v5 + 130, sizeof(v71));
    v68[0] = 1;
    v68[64] = 1;
    long double v51 = v6 + 130;
    uint64_t v52 = (uint64_t)(v5 + 195);
    double v10 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval1(v8, v9, (uint64_t)v7, v6 + 130, v5 + 195);
    int v12 = v11;
    double v14 = v13;
    __src[0] = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2((uint64_t)v7, __dst, v67, v10, v15);
    __src[1] = v16;
    boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::sqrt((uint64_t)__src);
    int v19 = v18 + v12;
    double v20 = frexp(v14 * v17, (int *)&v66[1]);
    LODWORD(v66[1]) += v19;
    *(double *)int v57 = v20;
    v57[1] = v66[1];
    memcpy(__dst, v6, sizeof(__dst));
    memcpy(v67, v5, sizeof(v67));
    memcpy(v71, v6 + 65, sizeof(v71));
    uint64_t v53 = (uint64_t)(v5 + 65);
    memcpy(v68, v5 + 65, 0x104uLL);
    memcpy(v72, v6 + 195, sizeof(v72));
    unsigned int v68[65] = 1;
    v68[129] = 1;
    double v23 = COERCE_DOUBLE(boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval3(v7, __dst, v67, v21, v22));
    *(double *)uint64_t v56 = v23;
    v56[1] = v24;
    if (v23 >= 0.0 && v20 >= 0.0 || v23 <= 0.0 && v20 <= 0.0)
    {
      uint64_t v25 = v56;
      uint64_t v26 = (long double *)v57;
      return boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::operator+(v25, v26);
    }
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v64, v6 + 195, (uint64_t)v6);
    LODWORD(v66[0]) = 2;
    LODWORD(v66[32]) = 1;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, v64, (uint64_t)v66);
    memcpy(__dst, __src, sizeof(__dst));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v64, v6 + 195, (uint64_t)(v6 + 65));
    LODWORD(v66[0]) = 2;
    LODWORD(v66[32]) = 1;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, v64, (uint64_t)v66);
    memcpy(v71, __src, sizeof(v71));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v62, v6, (uint64_t)v6);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v63, v62, (uint64_t)v5);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v60, v6 + 65, (uint64_t)(v6 + 65));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v61, v60, v53);
    boost::polygon::detail::extended_int<64ul>::add(v64, v63, v61);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v59, v6 + 195, (uint64_t)(v6 + 195));
    boost::polygon::detail::extended_int<64ul>::add(__src, v64, v59);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v54, v51, (uint64_t)v51);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v55, (unsigned int *)v54, (uint64_t)(v5 + 130));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v58, (unsigned int *)v55, v52);
    boost::polygon::detail::extended_int<64ul>::dif (v66, (unsigned int *)__src, (int *)v58);
    memcpy(v72, v66, sizeof(v72));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v64, v6, (uint64_t)(v6 + 65));
    LODWORD(v66[0]) = 2;
    LODWORD(v66[32]) = 1;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, v64, (uint64_t)v66);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v62, v51, (uint64_t)v51);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v63, v62, v52);
    boost::polygon::detail::extended_int<64ul>::dif (v66, (unsigned int *)__src, (int *)v63);
    memcpy(v73, v66, sizeof(v73));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v66, v5, v53);
    memcpy(v69, v66, sizeof(v69));
    double v45 = COERCE_DOUBLE(boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::sqrt_expr_evaluator_pss3<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>>((uint64_t)v7, __dst, v67, v43, v44));
    unsigned int v46 = v56;
    double v47 = v57;
  }
  else
  {
    double v27 = COERCE_DOUBLE(boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2(v0, v1, v2, v3, v4));
    *(double *)double v55 = v27;
    v55[1] = v28;
    __dst[0] = 1;
    __dst[64] = 1;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v67, v5, (uint64_t)(v5 + 65));
    memcpy(v71, v5 + 130, sizeof(v71));
    v68[0] = 1;
    v68[64] = 1;
    double v31 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval1(v29, v30, (uint64_t)v7, v6 + 130, v5 + 195);
    int v33 = v32;
    double v35 = v34;
    __src[0] = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2((uint64_t)v7, __dst, v67, v31, v36);
    __src[1] = v37;
    boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::sqrt((uint64_t)__src);
    int v40 = v39 + v33;
    double v41 = frexp(v35 * v38, (int *)&v66[1]);
    LODWORD(v66[1]) += v40;
    *(double *)double v54 = v41;
    v54[1] = v66[1];
    if (v27 >= 0.0 && v41 >= 0.0 || v27 <= 0.0 && v41 <= 0.0)
    {
      uint64_t v25 = v55;
      uint64_t v26 = (long double *)v54;
      return boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::operator+(v25, v26);
    }
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v63, v6, (uint64_t)v6);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v64, v63, (uint64_t)v5);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v61, v6 + 65, (uint64_t)(v6 + 65));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v62, v61, (uint64_t)(v5 + 65));
    boost::polygon::detail::extended_int<64ul>::add(__src, v64, v62);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v58, v6 + 130, (uint64_t)(v6 + 130));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v59, v58, (uint64_t)(v5 + 195));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v60, v59, (uint64_t)(v5 + 130));
    boost::polygon::detail::extended_int<64ul>::dif (v66, (unsigned int *)__src, (int *)v60);
    memcpy(__dst, v66, sizeof(__dst));
    v67[0] = 1;
    v67[64] = 1;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v64, v6, (uint64_t)(v6 + 65));
    LODWORD(v66[0]) = 2;
    LODWORD(v66[32]) = 1;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, v64, (uint64_t)v66);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v62, v6 + 130, (uint64_t)(v6 + 130));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v63, v62, (uint64_t)(v5 + 195));
    boost::polygon::detail::extended_int<64ul>::dif (v66, (unsigned int *)__src, (int *)v63);
    memcpy(v71, v66, sizeof(v71));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v66, v5, (uint64_t)(v5 + 65));
    memcpy(v68, v66, 0x104uLL);
    double v45 = COERCE_DOUBLE(boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2((uint64_t)v7, __dst, v67, v48, v49));
    unsigned int v46 = v55;
    double v47 = v54;
  }
  double v50 = COERCE_DOUBLE(boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::operator-(v46, (uint64_t)v47));
  return frexp(v45 / v50, (int *)&v66[1]);
}

uint64_t boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::sqrt_expr_evaluator_pss3<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>>(uint64_t a1, unsigned int *a2, _DWORD *a3, double a4, double a5)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  double v8 = COERCE_DOUBLE(boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2(a1, a2, a3, a4, a5));
  *(double *)uint64_t v28 = v8;
  v28[1] = v9;
  double v12 = COERCE_DOUBLE(boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2(a1, a2 + 130, a3 + 130, v10, v11));
  v27[0] = v12;
  v27[1] = v13;
  if (v8 >= 0.0 && v12 >= 0.0 || v8 <= 0.0 && v12 <= 0.0) {
    return boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::operator+(v28, v27);
  }
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v25, a2, (uint64_t)a2);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, v25, (uint64_t)a3);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v23, a2 + 65, (uint64_t)(a2 + 65));
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v24, v23, (uint64_t)(a3 + 65));
  boost::polygon::detail::extended_int<64ul>::add(&__dst, __src, v24);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v22, a2 + 130, (uint64_t)(a2 + 130));
  boost::polygon::detail::extended_int<64ul>::dif (v32, &__dst, v22);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v19, a2 + 195, (uint64_t)(a2 + 195));
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v20, v19, (uint64_t)a3);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v21, v20, (uint64_t)(a3 + 65));
  boost::polygon::detail::extended_int<64ul>::dif (v34, v32, v21);
  v32[0] = 1;
  unsigned char v32[64] = 1;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v24, a2, (uint64_t)(a2 + 65));
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v23, a2 + 130, (uint64_t)(a2 + 195));
  boost::polygon::detail::extended_int<64ul>::dif (v25, v24, (int *)v23);
  unsigned int __dst = 2;
  int v31 = 1;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, v25, (uint64_t)&__dst);
  memcpy(v35, __src, sizeof(v35));
  memcpy(v33, a3 + 195, sizeof(v33));
  double v17 = COERCE_DOUBLE(boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2(a1, v34, v32, v15, v16));
  double v18 = COERCE_DOUBLE(boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::operator-(v28, (uint64_t)v27));
  return frexp(v17 / v18, v30);
}

double boost::polygon::detail::operator+<boost::polygon::detail::robust_fpt<double>>(long long *a1, long long *a2)
{
  long long v4 = *a1;
  long long v10 = *a2;
  long long v11 = v4;
  double v5 = boost::polygon::detail::robust_fpt<double>::operator+((double *)&v11, (double *)&v10);
  long long v6 = a1[1];
  long long v8 = a2[1];
  long long v9 = v6;
  boost::polygon::detail::robust_fpt<double>::operator+((double *)&v9, (double *)&v8);
  return v5;
}

void boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::sss()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  int v92 = v4;
  int v88 = v5;
  char v90 = v6;
  uint64_t v89 = v7;
  int v91 = (unsigned int *)v0;
  uint64_t v117 = *MEMORY[0x263EF8340];
  uint64_t v8 = *((void *)v1 + 4);
  int v9 = *v1;
  if ((v8 & 0x20) != 0) {
    int v10 = *v1;
  }
  else {
    int v10 = v1[2];
  }
  if ((v8 & 0x20) != 0)
  {
    int v9 = v1[2];
    long long v11 = v1 + 2;
  }
  else
  {
    long long v11 = v1;
  }
  uint64_t v12 = v10 - (uint64_t)v9;
  if (v12 > 0)
  {
    int v13 = 1;
LABEL_9:
    v111[0] = v12;
    goto LABEL_12;
  }
  if (v12 < 0)
  {
    uint64_t v12 = v9 - (uint64_t)v10;
    int v13 = -1;
    goto LABEL_9;
  }
  int v13 = 0;
LABEL_12:
  int v112 = v13;
  uint64_t v14 = *((void *)v2 + 4);
  int v15 = v2[2];
  if ((v14 & 0x20) != 0) {
    int v16 = *v2;
  }
  else {
    int v16 = v2[2];
  }
  if ((v14 & 0x20) != 0)
  {
    double v17 = v2 + 2;
  }
  else
  {
    int v15 = *v2;
    double v17 = v2;
  }
  uint64_t v18 = v16 - (uint64_t)v15;
  if (v18 > 0)
  {
    int v19 = 1;
LABEL_20:
    uint64_t v113 = v18;
    goto LABEL_23;
  }
  if (v18 < 0)
  {
    uint64_t v18 = v15 - (uint64_t)v16;
    int v19 = -1;
    goto LABEL_20;
  }
  int v19 = 0;
LABEL_23:
  int v114 = v19;
  uint64_t v20 = *((void *)v3 + 4);
  double v21 = v3 + 2;
  int v22 = v3[2];
  if ((v20 & 0x20) != 0) {
    int v23 = *v3;
  }
  else {
    int v23 = v3[2];
  }
  if ((v20 & 0x20) == 0)
  {
    int v22 = *v3;
    double v21 = v3;
  }
  uint64_t v24 = v23 - (uint64_t)v22;
  if (v24 > 0)
  {
    int v25 = 1;
LABEL_30:
    uint64_t v115 = v24;
    goto LABEL_33;
  }
  if (v24 < 0)
  {
    uint64_t v24 = v22 - (uint64_t)v23;
    int v25 = -1;
    goto LABEL_30;
  }
  int v25 = 0;
LABEL_33:
  int v116 = v25;
  uint64_t v26 = v1 + 1;
  double v27 = v1 + 3;
  if ((v8 & 0x20) != 0) {
    uint64_t v28 = v26;
  }
  else {
    uint64_t v28 = v27;
  }
  uint64_t v29 = *v28;
  uint64_t v30 = v11[1];
  uint64_t v31 = v29 - v30;
  if (v29 > v30)
  {
    int v32 = 1;
LABEL_38:
    v105[0] = v31;
    goto LABEL_41;
  }
  if (v31 < 0)
  {
    uint64_t v31 = v30 - v29;
    int v32 = -1;
    goto LABEL_38;
  }
  int v32 = 0;
LABEL_41:
  int v33 = v9;
  int v106 = v32;
  double v34 = v2 + 1;
  if ((v14 & 0x20) == 0) {
    double v34 = v2 + 3;
  }
  uint64_t v35 = *v34;
  uint64_t v36 = v17[1];
  uint64_t v37 = v35 - v36;
  if (v35 > v36)
  {
    int v38 = 1;
LABEL_45:
    uint64_t v107 = v37;
    goto LABEL_48;
  }
  if (v37 < 0)
  {
    uint64_t v37 = v36 - v35;
    int v38 = -1;
    goto LABEL_45;
  }
  int v38 = 0;
LABEL_48:
  int v39 = v15;
  int v108 = v38;
  int v40 = v3 + 1;
  if ((v20 & 0x20) == 0) {
    int v40 = v3 + 3;
  }
  uint64_t v41 = *v40;
  uint64_t v42 = v21[1];
  uint64_t v43 = v41 - v42;
  if (v41 <= v42)
  {
    if ((v43 & 0x8000000000000000) == 0)
    {
      int v44 = 0;
      goto LABEL_55;
    }
    uint64_t v43 = v42 - v41;
    int v44 = -1;
  }
  else
  {
    int v44 = 1;
  }
  uint64_t v109 = v43;
LABEL_55:
  int v110 = v44;
  uint64_t v45 = (int)v29 * (uint64_t)v33 - (int)v30 * (uint64_t)v10;
  if (v45 < 1)
  {
    if (v45 < 0)
    {
      v99[0] = -v45;
      if ((unint64_t)-v45 >> 32) {
        int v46 = -2;
      }
      else {
        int v46 = -1;
      }
    }
    else
    {
      int v46 = 0;
    }
  }
  else
  {
    v99[0] = v45;
    if (HIDWORD(v45)) {
      int v46 = 2;
    }
    else {
      int v46 = 1;
    }
  }
  int v100 = v46;
  uint64_t v47 = (int)v35 * (uint64_t)v39 - (int)v36 * (uint64_t)v16;
  if (v47 < 1)
  {
    if (v47 < 0)
    {
      uint64_t v101 = -v47;
      if ((unint64_t)-v47 >> 32) {
        int v48 = -2;
      }
      else {
        int v48 = -1;
      }
    }
    else
    {
      int v48 = 0;
    }
  }
  else
  {
    uint64_t v101 = v47;
    if (HIDWORD(v47)) {
      int v48 = 2;
    }
    else {
      int v48 = 1;
    }
  }
  int v102 = v48;
  uint64_t v49 = (int)v41 * (uint64_t)v22 - (int)v42 * (uint64_t)v23;
  if (v49 < 1)
  {
    if (v49 < 0)
    {
      uint64_t v103 = (int)v42 * (uint64_t)v23 - (int)v41 * (uint64_t)v22;
      if (HIDWORD(v103)) {
        int v50 = -2;
      }
      else {
        int v50 = -1;
      }
    }
    else
    {
      int v50 = 0;
    }
  }
  else
  {
    uint64_t v103 = (int)v41 * (uint64_t)v22 - (int)v42 * (uint64_t)v23;
    if (HIDWORD(v49)) {
      int v50 = 2;
    }
    else {
      int v50 = 1;
    }
  }
  unint64_t v51 = 0;
  int v104 = v50;
  do
  {
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__dst, (unsigned int *)((char *)v111 + v51), (uint64_t)v111 + v51);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v94, (unsigned int *)((char *)v105 + v51), (uint64_t)v105 + v51);
    boost::polygon::detail::extended_int<64ul>::add(__src, __dst, v94);
    memcpy(&v96[v51 / 4], __src, 0x104uLL);
    v51 += 260;
  }
  while (v51 != 780);
  uint64_t v52 = 0;
  uint64_t v53 = 0xFFFFFFFF00000000;
  for (uint64_t i = 1; i != 4; ++i)
  {
    uint64_t v55 = v53 >> 32;
    if (v52 == 130) {
      uint64_t v56 = 0;
    }
    else {
      uint64_t v56 = i;
    }
    uint64_t v57 = 65 * v56;
    if (!(v52 * 4)) {
      uint64_t v55 = 2;
    }
    uint64_t v58 = 65 * v55;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v94, (unsigned int *)v111 + 65 * v56, (uint64_t)v105 + 260 * v55);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v93, (unsigned int *)v111 + v58, (uint64_t)v105 + 4 * v57);
    boost::polygon::detail::extended_int<64ul>::dif (__dst, v94, v93);
    memcpy(&__src[v52], __dst, 0x104uLL);
    v53 += 0x100000000;
    v52 += 65;
  }
  uint64_t v61 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval3(v91, __src, v96, v59, v60);
  double v63 = ldexp(*(long double *)&v61, v62);
  if (v88)
  {
    uint64_t v64 = 0;
    uint64_t v65 = 0xFFFFFFFF00000000;
    for (uint64_t j = 1; j != 4; ++j)
    {
      uint64_t v67 = v65 >> 32;
      if (v64 == 130) {
        uint64_t v68 = 0;
      }
      else {
        uint64_t v68 = j;
      }
      uint64_t v69 = 65 * v68;
      if (!(v64 * 4)) {
        uint64_t v67 = 2;
      }
      uint64_t v70 = 65 * v67;
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v94, (unsigned int *)v105 + 65 * v68, (uint64_t)v99 + 260 * v67);
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v93, (unsigned int *)v105 + v70, (uint64_t)v99 + 4 * v69);
      boost::polygon::detail::extended_int<64ul>::dif (__dst, v94, v93);
      memcpy(&__src[v64], __dst, 0x104uLL);
      v65 += 0x100000000;
      v64 += 65;
    }
    uint64_t v73 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval3(v91, __src, v96, v71, v72);
    *(long double *)(v89 + 8) = ldexp(*(long double *)&v73, v74) / v63;
  }
  if ((v90 & 1) != 0 || v92)
  {
    uint64_t v75 = 0;
    v98[64] = 0;
    uint64_t v76 = 0xFFFFFFFF00000000;
    uint64_t v77 = 1;
    do
    {
      uint64_t v78 = v76 >> 32;
      if (v75 == 130) {
        uint64_t v79 = 0;
      }
      else {
        uint64_t v79 = v77;
      }
      uint64_t v80 = 65 * v79;
      if (!(v75 * 4)) {
        uint64_t v78 = 2;
      }
      uint64_t v81 = 65 * v78;
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v94, (unsigned int *)v111 + 65 * v79, (uint64_t)v99 + 260 * v78);
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v93, (unsigned int *)v111 + v81, (uint64_t)v99 + 4 * v80);
      boost::polygon::detail::extended_int<64ul>::dif (__dst, v94, v93);
      memcpy(&__src[v75], __dst, 0x104uLL);
      if (v92)
      {
        boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v94, &__src[v75], (uint64_t)v105 + v75 * 4);
        boost::polygon::detail::extended_int<64ul>::add(__dst, v98, v94);
        memcpy(v98, __dst, sizeof(v98));
      }
      v76 += 0x100000000;
      v75 += 65;
      ++v77;
    }
    while (v75 != 195);
    if (v90)
    {
      uint64_t v84 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval3(v91, __src, v96, v82, v83);
      double v82 = ldexp(*(long double *)&v84, v85) / v63;
      *(double *)uint64_t v89 = v82;
    }
    if (v92)
    {
      v96[195] = 1;
      v96[259] = 1;
      uint64_t v86 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval4(v91, __src, v96, v82, v83);
      *(long double *)(v89 + 16) = ldexp(*(long double *)&v86, v87) / v63;
    }
  }
}

BOOL std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::ordered_queue<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::event_comparison_type>::comparison &,std::__wrap_iter<std::__list_iterator<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,void *> *>>(BOOL result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    BOOL v6 = result;
    unint64_t v7 = v4 >> 1;
    uint64_t v8 = (void *)(result + 8 * (v4 >> 1));
    int v9 = (void *)(a2 - 8);
    uint64_t result = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, *(void *)(a2 - 8) + 16, *v8 + 16);
    if (result)
    {
      uint64_t v10 = *v9;
      uint64_t v11 = *v9 + 16;
      do
      {
        uint64_t v12 = v9;
        int v9 = v8;
        *uint64_t v12 = *v8;
        if (!v7) {
          break;
        }
        unint64_t v7 = (v7 - 1) >> 1;
        uint64_t v8 = (void *)(v6 + 8 * v7);
        uint64_t result = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, v11, *v8 + 16);
      }
      while (result);
      *int v9 = v10;
    }
  }
  return result;
}

BOOL boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = *(void *)(a3 + 16);
  if (v3 >= 0) {
    uint64_t v3 = 0x8000000000000000 - v3;
  }
  if (v4 >= 0) {
    uint64_t v4 = 0x8000000000000000 - v4;
  }
  if ((unint64_t)(v3 - v4) <= 0x80) {
    int v5 = 0;
  }
  else {
    int v5 = -1;
  }
  if (v3 > (unint64_t)v4) {
    int v6 = v5;
  }
  else {
    int v6 = (unint64_t)(v4 - v3) > 0x80;
  }
  if (!v6)
  {
    uint64_t v7 = *(void *)(a2 + 8);
    uint64_t v8 = *(void *)(a3 + 8);
    if (v7 >= 0) {
      uint64_t v7 = 0x8000000000000000 - v7;
    }
    unint64_t v9 = 0x8000000000000000 - v8;
    if (v8 < 0) {
      unint64_t v9 = *(void *)(a3 + 8);
    }
    if (v7 - v9 <= 0x80) {
      int v10 = 0;
    }
    else {
      int v10 = -1;
    }
    if (v7 > v9) {
      int v6 = v10;
    }
    else {
      int v6 = v9 - v7 > 0x80;
    }
  }
  return v6 == -1;
}

char *boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::_insert_new_edge<int,double>(void *a1, uint64_t a2, uint64_t a3, uint64_t *a4, void *a5, void *a6)
{
  uint64_t v8 = a3;
  unint64_t v13 = a1[5];
  uint64_t v11 = (uint64_t)(a1 + 5);
  unint64_t v12 = v13;
  uint64_t v15 = *a4;
  uint64_t v14 = a4[1];
  int v16 = *(void **)(v11 - 8);
  if ((unint64_t)v16 >= v13)
  {
    int v19 = (void **)(v11 - 16);
    uint64_t v20 = *(void *)(v11 - 16);
    uint64_t v21 = ((uint64_t)v16 - v20) >> 5;
    unint64_t v22 = v21 + 1;
    if ((unint64_t)(v21 + 1) >> 59) {
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v23 = v12 - v20;
    if (v23 >> 4 > v22) {
      unint64_t v22 = v23 >> 4;
    }
    if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v24 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v24 = v22;
    }
    if (v24) {
      int v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::segment_data<double>>>(v11, v24);
    }
    else {
      int v25 = 0;
    }
    uint64_t v26 = &v25[32 * v21];
    double v27 = &v25[32 * v24];
    *(void *)uint64_t v26 = v15;
    *((void *)v26 + 1) = v14;
    *((void *)v26 + 2) = 0;
    *((void *)v26 + 3) = 0;
    double v17 = v26 + 32;
    uint64_t v29 = (char *)a1[3];
    uint64_t v28 = (char *)a1[4];
    uint64_t v8 = a3;
    if (v28 != v29)
    {
      do
      {
        long long v30 = *((_OWORD *)v28 - 1);
        *((_OWORD *)v26 - 2) = *((_OWORD *)v28 - 2);
        *((_OWORD *)v26 - 1) = v30;
        v26 -= 32;
        v28 -= 32;
      }
      while (v28 != v29);
      uint64_t v28 = (char *)*v19;
    }
    a1[3] = v26;
    a1[4] = v17;
    a1[5] = v27;
    if (v28) {
      operator delete(v28);
    }
  }
  else
  {
    *int v16 = v15;
    v16[1] = v14;
    double v17 = v16 + 4;
    v16[2] = 0;
    void v16[3] = 0;
  }
  a1[4] = v17;
  uint64_t v31 = v17 - 4;
  a5[1] = v17 - 4;
  a6[1] = v17 - 4;
  unsigned int v32 = boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::is_linear_edge<boost::polygon::detail::site_event<int>>((uint64_t)a1, (int *)a2, (int *)v8);
  int v33 = boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::is_primary_edge<boost::polygon::detail::site_event<int>>((uint64_t)a1, (int *)a2, (int *)v8);
  unint64_t v34 = a1[8];
  uint64_t v35 = (char **)(a1 + 6);
  if (v33) {
    uint64_t v36 = v32 | 2;
  }
  else {
    uint64_t v36 = v32;
  }
  unint64_t v37 = a1[7];
  if (v37 >= v34)
  {
    unint64_t v39 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v37 - (void)*v35) >> 4);
    unint64_t v40 = v39 + 1;
    if (v39 + 1 > 0x555555555555555) {
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v41 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v34 - (void)*v35) >> 4);
    if (2 * v41 > v40) {
      unint64_t v40 = 2 * v41;
    }
    if (v41 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v42 = 0x555555555555555;
    }
    else {
      unint64_t v42 = v40;
    }
    if (v42) {
      uint64_t v43 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::voronoi_edge<double>>>((uint64_t)(a1 + 8), v42);
    }
    else {
      uint64_t v43 = 0;
    }
    int v44 = &v43[48 * v39];
    uint64_t v45 = &v43[48 * v42];
    *(_OWORD *)int v44 = 0u;
    *((_OWORD *)v44 + 1) = 0u;
    *((void *)v44 + 4) = 0;
    *((void *)v44 + 5) = v36;
    int v38 = v44 + 48;
    uint64_t v47 = (char *)a1[6];
    int v46 = (char *)a1[7];
    if (v46 != v47)
    {
      do
      {
        long long v48 = *((_OWORD *)v46 - 3);
        long long v49 = *((_OWORD *)v46 - 1);
        *((_OWORD *)v44 - 2) = *((_OWORD *)v46 - 2);
        *((_OWORD *)v44 - 1) = v49;
        *((_OWORD *)v44 - 3) = v48;
        v44 -= 48;
        v46 -= 48;
      }
      while (v46 != v47);
      int v46 = *v35;
    }
    a1[6] = v44;
    a1[7] = v38;
    a1[8] = v45;
    if (v46) {
      operator delete(v46);
    }
  }
  else
  {
    *(_OWORD *)unint64_t v37 = 0u;
    *(_OWORD *)(v37 + 16) = 0u;
    *(void *)(v37 + 32) = 0;
    *(void *)(v37 + 40) = v36;
    int v38 = (char *)(v37 + 48);
  }
  a1[7] = v38;
  *((void *)v38 - 6) = *a1 + 24 * *(void *)(a2 + 16);
  int v50 = v38 - 48;
  unint64_t v51 = a1[8];
  if ((unint64_t)v38 >= v51)
  {
    uint64_t v53 = v8;
    uint64_t v54 = a1[6];
    unint64_t v55 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v38[-v54] >> 4);
    if (v55 + 1 > 0x555555555555555) {
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v56 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v51 - v54) >> 4);
    uint64_t v57 = 2 * v56;
    if (2 * v56 <= v55 + 1) {
      uint64_t v57 = v55 + 1;
    }
    if (v56 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v58 = 0x555555555555555;
    }
    else {
      unint64_t v58 = v57;
    }
    if (v58) {
      double v59 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::voronoi_edge<double>>>((uint64_t)(a1 + 8), v58);
    }
    else {
      double v59 = 0;
    }
    double v60 = &v59[48 * v55];
    uint64_t v61 = &v59[48 * v58];
    *(_OWORD *)double v60 = 0u;
    *((_OWORD *)v60 + 1) = 0u;
    *((void *)v60 + 4) = 0;
    *((void *)v60 + 5) = v36;
    uint64_t v52 = v60 + 48;
    double v63 = (char *)a1[6];
    int v62 = (char *)a1[7];
    uint64_t v8 = v53;
    if (v62 != v63)
    {
      do
      {
        long long v64 = *((_OWORD *)v62 - 3);
        long long v65 = *((_OWORD *)v62 - 1);
        *((_OWORD *)v60 - 2) = *((_OWORD *)v62 - 2);
        *((_OWORD *)v60 - 1) = v65;
        *((_OWORD *)v60 - 3) = v64;
        v60 -= 48;
        v62 -= 48;
      }
      while (v62 != v63);
      int v62 = (char *)a1[6];
    }
    a1[6] = v60;
    a1[7] = v52;
    a1[8] = v61;
    if (v62) {
      operator delete(v62);
    }
  }
  else
  {
    *(_OWORD *)int v38 = 0u;
    *((_OWORD *)v38 + 1) = 0u;
    *((void *)v38 + 4) = 0;
    *((void *)v38 + 5) = v36;
    uint64_t v52 = v38 + 48;
  }
  a1[7] = v52;
  *((void *)v52 - 6) = *a1 + 24 * *(void *)(v8 + 16);
  *((void *)v38 - 4) = v52 - 48;
  *((void *)v52 - 5) = v31;
  *((void *)v52 - 4) = v50;
  a5[4] = v50;
  *((void *)v38 - 3) = a5;
  uint64_t v66 = a5[2];
  *(void *)(v66 + 24) = a6;
  a6[4] = v66;
  uint64_t v67 = a6[2];
  *(void *)(v67 + 24) = v52 - 48;
  *((void *)v52 - 2) = v67;
  return v38 - 48;
}

void *std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::ordered_queue<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::event_comparison_type>::comparison &,std::__wrap_iter<std::__list_iterator<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,void *> *>>(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = a3 - 2;
  if (a3 < 2) {
    uint64_t v7 = a3 - 1;
  }
  uint64_t v8 = v7 >> 1;
  do
  {
    unint64_t v9 = &a1[v6 + 1];
    uint64_t v10 = (2 * v6) | 1;
    uint64_t v11 = 2 * v6 + 2;
    if (v11 < a3
      && boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a2, a1[v6 + 2] + 16, *v9 + 16))
    {
      ++v9;
      uint64_t v10 = v11;
    }
    *a1 = *v9;
    a1 = v9;
    uint64_t v6 = v10;
  }
  while (v10 <= v8);
  return v9;
}

BOOL boost::polygon::voronoi_diagram_traits<double>::vertex_equality_predicate_type::operator()(uint64_t a1, unint64_t *a2, uint64_t *a3)
{
  unint64_t v3 = *a2;
  uint64_t v4 = *a3;
  if ((*a2 & 0x8000000000000000) == 0) {
    unint64_t v3 = 0x8000000000000000 - *a2;
  }
  if (v4 >= 0) {
    uint64_t v4 = 0x8000000000000000 - v4;
  }
  if (v3 - v4 <= 0x80) {
    int v5 = 0;
  }
  else {
    int v5 = -1;
  }
  if (v3 > v4) {
    BOOL v6 = v5;
  }
  else {
    BOOL v6 = v4 - v3 > 0x80;
  }
  if (v6) {
    return 0;
  }
  uint64_t v8 = a2[1];
  uint64_t v9 = a3[1];
  if (v8 >= 0) {
    uint64_t v8 = 0x8000000000000000 - v8;
  }
  unint64_t v10 = 0x8000000000000000 - v9;
  if (v9 < 0) {
    unint64_t v10 = a3[1];
  }
  if (v8 - v10 <= 0x80) {
    int v11 = 0;
  }
  else {
    int v11 = -1;
  }
  if (v8 > v10) {
    BOOL v12 = v11;
  }
  else {
    BOOL v12 = v10 - v8 > 0x80;
  }
  return !v12;
}

void boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::remove_edge(uint64_t a1, void *a2)
{
  long double v2 = (void *)a2[2];
  unint64_t v3 = *(void **)(v2[4] + 16);
  if (v3 != v2)
  {
    uint64_t v4 = a2[1];
    int v5 = *(void **)(v2[4] + 16);
    do
    {
      v5[1] = v4;
      int v5 = *(void **)(v5[4] + 16);
    }
    while (v5 != v2);
  }
  uint64_t v6 = v2[3];
  uint64_t v7 = *(void *)(v2[2] + 24);
  uint64_t v8 = *(void *)(*(void *)(a2[4] + 16) + 16);
  *(void *)(v8 + 24) = v7;
  *(void *)(v7 + 32) = v8;
  uint64_t v9 = v3[2];
  *(void *)(v6 + 32) = v9;
  *(void *)(v9 + 24) = v6;
}

void std::vector<std::vector<boost::polygon::segment_data<double>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  long double v2 = *a1;
  if (*v2)
  {
    std::vector<std::vector<boost::polygon::segment_data<double>>>::__clear[abi:ne180100]((uint64_t *)v2);
    unint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<std::vector<boost::polygon::segment_data<double>>>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  if (v2 != *a1)
  {
    uint64_t v4 = a1[1];
    do
    {
      uint64_t v6 = *(void **)(v4 - 24);
      v4 -= 24;
      int v5 = v6;
      if (v6)
      {
        *(void *)(v2 - 16) = v5;
        operator delete(v5);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

uint64_t std::vector<boost::polygon::segment_data<double>>::__push_back_slow_path<boost::polygon::segment_data<double> const&>(uint64_t *a1, void *a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (a1[1] - *a1) >> 5;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 59) {
    std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2] - v3;
  if (v8 >> 4 > v5) {
    unint64_t v5 = v8 >> 4;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v9 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v18 = a1 + 2;
  if (v9) {
    unint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::segment_data<double>>>(v7, v9);
  }
  else {
    unint64_t v10 = 0;
  }
  int v11 = &v10[32 * v4];
  __p = v10;
  uint64_t v15 = v11;
  double v17 = &v10[32 * v9];
  *(_OWORD *)int v11 = 0u;
  *((_OWORD *)v11 + 1) = 0u;
  *(void *)int v11 = *a2;
  *((void *)v11 + 1) = a2[1];
  *((void *)v11 + 2) = a2[2];
  *((void *)v11 + 3) = a2[3];
  int v16 = v11 + 32;
  std::vector<boost::polygon::segment_data<double>>::__swap_out_circular_buffer(a1, &__p);
  uint64_t v12 = a1[1];
  if (v16 != v15) {
    v16 += (v15 - v16 + 31) & 0xFFFFFFFFFFFFFFE0;
  }
  if (__p) {
    operator delete(__p);
  }
  return v12;
}

void sub_223687E10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<boost::polygon::segment_data<double>>::__swap_out_circular_buffer(void *result, void *a2)
{
  uint64_t v3 = (void *)*result;
  uint64_t v2 = (void *)result[1];
  uint64_t v4 = (void *)a2[1];
  if (v2 != (void *)*result)
  {
    do
    {
      *((_OWORD *)v4 - 2) = 0uLL;
      *((_OWORD *)v4 - 1) = 0uLL;
      v4 -= 4;
      uint64_t v5 = *(v2 - 4);
      v2 -= 4;
      void *v4 = v5;
      v4[1] = v2[1];
      void v4[2] = v2[2];
      v4[3] = v2[3];
    }
    while (v2 != v3);
  }
  a2[1] = v4;
  uint64_t v6 = (void *)*result;
  *uint64_t result = v4;
  a2[1] = v6;
  uint64_t v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::vector<std::vector<boost::polygon::segment_data<double>>>::__push_back_slow_path<std::vector<boost::polygon::segment_data<double>> const&>(uint64_t *a1, void **a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x555555555555555) {
    unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  double v17 = a1 + 2;
  if (v9) {
    unint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::voronoi_cell<double>>>(v7, v9);
  }
  else {
    unint64_t v10 = 0;
  }
  int v11 = &v10[24 * v4];
  v14[0] = v10;
  v14[1] = v11;
  uint64_t v15 = v11;
  int v16 = &v10[24 * v9];
  *(void *)int v11 = 0;
  *((void *)v11 + 1) = 0;
  *((void *)v11 + 2) = 0;
  std::vector<boost::polygon::segment_data<double>>::__init_with_size[abi:ne180100]<boost::polygon::segment_data<double>*,boost::polygon::segment_data<double>*>(v11, *a2, a2[1], ((char *)a2[1] - (char *)*a2) >> 5);
  v15 += 24;
  std::vector<std::vector<boost::polygon::segment_data<double>>>::__swap_out_circular_buffer(a1, v14);
  uint64_t v12 = a1[1];
  std::__split_buffer<std::vector<boost::polygon::segment_data<double>>>::~__split_buffer((uint64_t)v14);
  return v12;
}

void sub_223687FC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<boost::polygon::segment_data<double>>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<boost::polygon::segment_data<double>>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<boost::polygon::segment_data<double>>>,std::reverse_iterator<std::vector<boost::polygon::segment_data<double>>*>,std::reverse_iterator<std::vector<boost::polygon::segment_data<double>>*>,std::reverse_iterator<std::vector<boost::polygon::segment_data<double>>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<boost::polygon::segment_data<double>>>,std::reverse_iterator<std::vector<boost::polygon::segment_data<double>>*>,std::reverse_iterator<std::vector<boost::polygon::segment_data<double>>*>,std::reverse_iterator<std::vector<boost::polygon::segment_data<double>>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  void v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      long long v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(void *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      uint64_t v7 = *((void *)&v14 + 1) - 24;
      *((void *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<boost::polygon::segment_data<double>>>,std::reverse_iterator<std::vector<boost::polygon::segment_data<double>>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<boost::polygon::segment_data<double>>>,std::reverse_iterator<std::vector<boost::polygon::segment_data<double>>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<boost::polygon::segment_data<double>>>,std::reverse_iterator<std::vector<boost::polygon::segment_data<double>>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<boost::polygon::segment_data<double>>>,std::reverse_iterator<std::vector<boost::polygon::segment_data<double>>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(void **)v1;
    if (*(void *)v1)
    {
      *(void *)(v1 + 8) = v3;
      operator delete(v3);
    }
    v1 += 24;
  }
}

uint64_t std::__split_buffer<std::vector<boost::polygon::segment_data<double>>>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__split_buffer<std::vector<boost::polygon::segment_data<double>>>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != a2)
  {
    uint64_t v5 = *(void **)(v2 - 24);
    *(void *)(a1 + 16) = v2 - 24;
    if (v5)
    {
      *(void *)(v2 - 16) = v5;
      operator delete(v5);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
}

double std::vector<boost::polygon::segment_data<double>>::__move_range(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = (void *)(a2 + v4 - a4);
  if ((unint64_t)v5 >= a3)
  {
    uint64_t v7 = *(void *)(a1 + 8);
  }
  else
  {
    long long v6 = 0uLL;
    uint64_t v7 = *(void *)(a1 + 8);
    do
    {
      *(_OWORD *)uint64_t v7 = 0uLL;
      *(_OWORD *)(v7 + 16) = 0uLL;
      *(void *)uint64_t v7 = *v5;
      *(void *)(v7 + 8) = v5[1];
      *(void *)(v7 + 16) = v5[2];
      *(void *)(v7 + 24) = v5[3];
      v7 += 32;
      v5 += 4;
    }
    while ((unint64_t)v5 < a3);
  }
  *(void *)(a1 + 8) = v7;
  if (v4 != a4)
  {
    uint64_t v8 = 32 * ((v4 - a4) >> 5);
    uint64_t v9 = a2 - 16;
    unint64_t v10 = (void *)(v4 - 16);
    do
    {
      *(v10 - 2) = *(void *)(v9 + v8 - 16);
      *(v10 - 1) = *(void *)(v9 + v8 - 8);
      *unint64_t v10 = *(void *)(v9 + v8);
      *(void *)&long long v6 = *(void *)(v9 + v8 + 8);
      v10[1] = v6;
      v10 -= 4;
      v8 -= 32;
    }
    while (v8);
  }
  return *(double *)&v6;
}

void *std::vector<boost::polygon::segment_data<double>>::__swap_out_circular_buffer(void *a1, void *a2, void *a3)
{
  uint64_t result = (void *)a2[1];
  uint64_t v5 = (void *)*a1;
  long long v6 = result;
  if ((void *)*a1 != a3)
  {
    uint64_t v7 = a3;
    long long v6 = (void *)a2[1];
    do
    {
      *((_OWORD *)v6 - 2) = 0uLL;
      *((_OWORD *)v6 - 1) = 0uLL;
      v6 -= 4;
      uint64_t v8 = *(v7 - 4);
      v7 -= 4;
      *long long v6 = v8;
      v6[1] = v7[1];
      v6[2] = v7[2];
      v6[3] = v7[3];
    }
    while (v7 != v5);
  }
  a2[1] = v6;
  uint64_t v9 = (void *)a1[1];
  uint64_t v10 = a2[2];
  if (v9 != a3)
  {
    do
    {
      *(_OWORD *)uint64_t v10 = 0uLL;
      *(_OWORD *)(v10 + 16) = 0uLL;
      *(void *)uint64_t v10 = *a3;
      *(void *)(v10 + 8) = a3[1];
      *(void *)(v10 + 16) = a3[2];
      *(void *)(v10 + 24) = a3[3];
      v10 += 32;
      a3 += 4;
    }
    while (a3 != v9);
    long long v6 = (void *)a2[1];
  }
  a2[2] = v10;
  int v11 = (void *)*a1;
  *a1 = v6;
  a2[1] = v11;
  uint64_t v12 = a1[1];
  a1[1] = a2[2];
  a2[2] = v12;
  uint64_t v13 = a1[2];
  a1[2] = a2[3];
  a2[3] = v13;
  *a2 = a2[1];
  return result;
}

void sub_223688624(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2236887F0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2236888B8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_223688AB0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id PerformXPathQuery(xmlDoc *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = xmlXPathNewContext(a1);
  if (!v4)
  {
    NSLog((NSString *)@"Unable to create XPath context.");
LABEL_13:
    uint64_t v9 = 0;
    goto LABEL_14;
  }
  uint64_t v5 = v4;
  xmlXPathRegisterNs(v4, (const xmlChar *)"svg", (const xmlChar *)"http://www.w3.org/2000/svg");
  uint64_t v6 = MEMORY[0x223CB9E80]([v3 cStringUsingEncoding:4], v5);
  if (!v6)
  {
    NSLog((NSString *)@"Unable to evaluate XPath.");
    goto LABEL_13;
  }
  uint64_t v7 = (xmlXPathObject *)v6;
  uint64_t v8 = *(int **)(v6 + 8);
  if (!v8)
  {
    NSLog((NSString *)@"Nodes was nil.");
    goto LABEL_13;
  }
  uint64_t v9 = [MEMORY[0x263EFF980] array];
  if (*v8 >= 1)
  {
    uint64_t v10 = 0;
    do
    {
      int v11 = DictionaryForNode(*(void **)(*((void *)v8 + 1) + 8 * v10), 0);
      if (v11) {
        [v9 addObject:v11];
      }

      ++v10;
    }
    while (v10 < *v8);
  }
  xmlXPathFreeObject(v7);
  xmlXPathFreeContext(v5);
LABEL_14:

  return v9;
}

id DictionaryForNode(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [MEMORY[0x263EFF9A0] dictionary];
  uint64_t v5 = a1[2];
  if (v5)
  {
    uint64_t v6 = [NSString stringWithCString:v5 encoding:4];
    [v4 setObject:v6 forKey:@"nodeName"];
  }
  if ((unint64_t)(a1[10] + 1) >= 2)
  {
    uint64_t v20 = objc_msgSend(NSString, "stringWithCString:encoding:");
    uint64_t v21 = [v4 objectForKey:@"nodeName"];
    int v22 = [v21 isEqual:@"text"];

    if (v3 && v22)
    {
      uint64_t v23 = [MEMORY[0x263F08708] whitespaceAndNewlineCharacterSet];
      unint64_t v24 = [v20 stringByTrimmingCharactersInSet:v23];

      int v25 = [v3 objectForKey:@"nodeContent"];
      uint64_t v26 = v25;
      if (v25)
      {
        id v27 = [v25 stringByAppendingString:v24];
      }
      else
      {
        id v27 = v24;
      }
      uint64_t v28 = v27;
      [v3 setObject:v27 forKey:@"nodeContent"];

      id v18 = 0;
      goto LABEL_22;
    }
    [v4 setObject:v20 forKey:@"nodeContent"];
  }
  uint64_t v7 = (void *)a1[11];
  if (v7)
  {
    id v29 = v3;
    uint64_t v8 = [MEMORY[0x263EFF9A0] dictionary];
    do
    {
      uint64_t v9 = [MEMORY[0x263EFF9A0] dictionary];
      uint64_t v10 = [NSString stringWithCString:v7[2] encoding:4];
      uint64_t v11 = v7[3];
      if (v11) {
        id v12 = (id)DictionaryForNode(v11, v9);
      }
      if (v10)
      {
        uint64_t v13 = [v9 objectForKey:@"nodeContent"];

        if (v13)
        {
          long long v14 = [v9 objectForKey:@"nodeContent"];
          [v8 setObject:v14 forKey:v10];
        }
      }
      uint64_t v7 = (void *)v7[6];
    }
    while (v7);
    [v4 setObject:v8 forKey:@"nodeAttributes"];

    id v3 = v29;
  }
  uint64_t v15 = a1[3];
  if (v15)
  {
    int v16 = [MEMORY[0x263EFF980] array];
    do
    {
      double v17 = DictionaryForNode(v15, v4);
      if (v17) {
        [v16 addObject:v17];
      }
      uint64_t v15 = *(void *)(v15 + 48);
    }
    while (v15);
    if ([v16 count]) {
      [v4 setObject:v16 forKey:@"nodeChildArray"];
    }
  }
  id v18 = v4;
LABEL_22:

  return v18;
}

id PerformXMLXPathQuery(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  unint64_t v5 = [v3 length];
  if (v5 >> 31)
  {
    uint64_t v10 = [MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v11 = objc_msgSend(NSString, "stringWithUTF8String:", "NSArray * _Nullable PerformXMLXPathQuery(NSData * _Nonnull __strong, NSString * _Nonnull __strong)");
    id v12 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBrushStrokeLoader.m"];
    [v10 handleFailureInFunction:v11 file:v12 lineNumber:689 description:@"Out-of-bounds type assignment failed"];

    uint64_t v13 = [MEMORY[0x263F7C7F0] currentHandler];
    long long v14 = objc_msgSend(NSString, "stringWithUTF8String:", "NSArray * _Nullable PerformXMLXPathQuery(NSData * _Nonnull __strong, NSString * _Nonnull __strong)");
    uint64_t v15 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBrushStrokeLoader.m"];
    [v13 handleFailureInFunction:v14 file:v15 lineNumber:690 description:@"Document too long to load with xmlReadMemory."];
  }
  else
  {
    Memordouble y = xmlReadMemory((const char *)[v3 bytes], v5, "", 0, 1);
    if (Memory)
    {
      uint64_t v7 = Memory;
      uint64_t v8 = PerformXPathQuery(Memory, v4);
      xmlFreeDoc(v7);
      goto LABEL_6;
    }
    NSLog((NSString *)@"Unable to parse.");
  }
  uint64_t v8 = 0;
LABEL_6:

  return v8;
}

uint64_t TSDGPUDataBufferDataTypeSize(uint64_t a1)
{
  switch(a1)
  {
    case 0:
      uint64_t v2 = [MEMORY[0x263F7C7F0] currentHandler];
      id v3 = [NSString stringWithUTF8String:"size_t TSDGPUDataBufferDataTypeSize(TSDGPUDataBufferDataType)"];
      id v4 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUDataBuffer.m"];
      [v2 handleFailureInFunction:v3 file:v4 lineNumber:42 description:@"Unknown TSDGPUDataBufferDataType!"];

      uint64_t result = 0;
      break;
    case 1:
    case 2:
      uint64_t result = 1;
      break;
    case 3:
    case 4:
      uint64_t result = 2;
      break;
    case 5:
      uint64_t result = 4;
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t TSDGPUUpdateDataPointerAtIndex(void *a1, uint64_t a2, uint64_t a3)
{
  return a1[3] + a1[4] + a1[5] * a2 + a1[10] * a3;
}

float TSDGPUDataBufferMetalfloatWithDataType(__int16 *a1, uint64_t a2, int a3, float a4)
{
  float v4 = -1.0;
  switch(a2)
  {
    case 0:
      unint64_t v5 = [MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v6 = objc_msgSend(NSString, "stringWithUTF8String:", "float TSDGPUDataBufferMetalfloatWithDataType(uint8_t *, TSDGPUDataBufferDataType, BOOL)");
      uint64_t v7 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUDataBuffer.m"];
      [v5 handleFailureInFunction:v6 file:v7 lineNumber:71 description:@"Unknown data type!"];

      return v4;
    case 1:
      LOBYTE(a4) = *(unsigned char *)a1;
      float v8 = (float)LODWORD(a4);
      int v9 = 1123942400;
      goto LABEL_5;
    case 2:
      LOBYTE(a4) = *(unsigned char *)a1;
      float v8 = (float)LODWORD(a4);
      int v9 = 1132396544;
LABEL_5:
      float v10 = *(float *)&v9;
      goto LABEL_8;
    case 3:
      float v8 = (float)*a1;
      float v10 = 32767.0;
      goto LABEL_8;
    case 4:
      LOWORD(a4) = *a1;
      float v8 = (float)LODWORD(a4);
      float v10 = 65535.0;
LABEL_8:
      float v11 = v8 / v10;
      if (a3) {
        float v4 = v11;
      }
      else {
        float v4 = v8;
      }
      break;
    case 5:
      float v4 = *(float *)a1;
      break;
    default:
      return v4;
  }
  return v4;
}

void TSDGPUDataBufferSetMetalfloatWithDataType(unsigned char *a1, uint64_t a2, int a3, float a4)
{
  switch(a2)
  {
    case 0:
      id v9 = [MEMORY[0x263F7C7F0] currentHandler];
      float v4 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSDGPUDataBufferSetMetalfloatWithDataType(uint8_t *, TSDGPUDataBufferDataType, BOOL, float)");
      unint64_t v5 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUDataBuffer.m"];
      [v9 handleFailureInFunction:v4 file:v5 lineNumber:99 description:@"Unknown data type!"];

      return;
    case 1:
      float v6 = 127.0;
      goto LABEL_7;
    case 2:
      float v6 = 255.0;
LABEL_7:
      if (a3) {
        a4 = a4 * v6;
      }
      *a1 = llroundf(a4);
      return;
    case 3:
      float v7 = 32767.0;
      goto LABEL_12;
    case 4:
      float v7 = 65535.0;
LABEL_12:
      float v8 = a4 * v7;
      if (a3) {
        a4 = v8;
      }
      *(_WORD *)a1 = llroundf(a4);
      break;
    case 5:
      *(float *)a1 = a4;
      break;
    default:
      return;
  }
}

float TSDGPUDataBufferMetalPoint2DWithDataType(__int16 *a1, uint64_t a2, int a3, float a4)
{
  float v4 = 0.0;
  switch(a2)
  {
    case 0:
      unint64_t v5 = [MEMORY[0x263F7C7F0] currentHandler];
      float v6 = objc_msgSend(NSString, "stringWithUTF8String:", "TSDMetalPoint2D TSDGPUDataBufferMetalPoint2DWithDataType(uint8_t *, TSDGPUDataBufferDataType, BOOL)");
      float v7 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUDataBuffer.m"];
      [v5 handleFailureInFunction:v6 file:v7 lineNumber:123 description:@"Unknown data type!"];

      break;
    case 1:
      LOBYTE(a4) = *(unsigned char *)a1;
      float v8 = (float)LODWORD(a4);
      float v9 = 127.0;
      goto LABEL_5;
    case 2:
      LOBYTE(a4) = *(unsigned char *)a1;
      float v8 = (float)LODWORD(a4);
      float v9 = 255.0;
LABEL_5:
      if (a3) {
        float v4 = v8 / v9;
      }
      else {
        float v4 = v8;
      }
      break;
    case 3:
      if (a3) {
        float v4 = (float)*a1 / 32767.0;
      }
      else {
        float v4 = (float)*a1;
      }
      break;
    case 4:
      LOWORD(a4) = *a1;
      float v10 = (float)LODWORD(a4);
      if (a3) {
        float v4 = v10 / 65535.0;
      }
      else {
        float v4 = v10;
      }
      break;
    case 5:
      float v4 = *(float *)a1;
      break;
    default:
      return v4;
  }
  return v4;
}

void TSDGPUDataBufferSetMetalPoint2DWithDataType(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  switch(a2)
  {
    case 0:
      id v16 = [MEMORY[0x263F7C7F0] currentHandler];
      unint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSDGPUDataBufferSetMetalPoint2DWithDataType(uint8_t *, TSDGPUDataBufferDataType, BOOL, TSDMetalPoint2D)");
      float v6 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUDataBuffer.m"];
      [v16 handleFailureInFunction:v5 file:v6 lineNumber:151 description:@"Unknown data type!"];

      return;
    case 1:
      float v7 = 127.0;
      goto LABEL_7;
    case 2:
      float v7 = 255.0;
LABEL_7:
      float v8 = v7;
      if (a3) {
        a4 = a4 * v7;
      }
      __int16 v9 = llroundf(a4);
      float v10 = a5 * v8;
      if (!a3) {
        float v10 = a5;
      }
      *(_WORD *)a1 = v9 | ((unsigned __int16)llroundf(v10) << 8);
      return;
    case 3:
      if (a3) {
        a4 = a4 * 32767.0;
      }
      unsigned __int16 v11 = llroundf(a4);
      float v12 = a5 * 32767.0;
      if (!a3) {
        float v12 = a5;
      }
      unsigned int v13 = v11 | ((unsigned __int16)llroundf(v12) << 16);
      goto LABEL_22;
    case 4:
      if (a3) {
        a4 = a4 * 65535.0;
      }
      unsigned int v14 = llroundf(a4);
      float v15 = a5 * 65535.0;
      if (!a3) {
        float v15 = a5;
      }
      unsigned int v13 = v14 | (llroundf(v15) << 16);
LABEL_22:
      *(_DWORD *)a1 = v13;
      break;
    case 5:
      *(float *)a1 = a4;
      *(float *)(a1 + 4) = a5;
      break;
    default:
      return;
  }
}

float TSDGPUDataBufferMetalPoint3DWithDataType(__int16 *a1, uint64_t a2, int a3, float a4)
{
  float v4 = 0.0;
  switch(a2)
  {
    case 0:
      unint64_t v5 = [MEMORY[0x263F7C7F0] currentHandler];
      float v6 = objc_msgSend(NSString, "stringWithUTF8String:", "TSDMetalPoint3D TSDGPUDataBufferMetalPoint3DWithDataType(uint8_t *, TSDGPUDataBufferDataType, BOOL)");
      float v7 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUDataBuffer.m"];
      [v5 handleFailureInFunction:v6 file:v7 lineNumber:175 description:@"Unknown data type!"];

      break;
    case 1:
      LOBYTE(a4) = *(unsigned char *)a1;
      float v8 = (float)LODWORD(a4);
      float v9 = 127.0;
      goto LABEL_5;
    case 2:
      LOBYTE(a4) = *(unsigned char *)a1;
      float v8 = (float)LODWORD(a4);
      float v9 = 255.0;
LABEL_5:
      if (a3) {
        float v4 = v8 / v9;
      }
      else {
        float v4 = v8;
      }
      break;
    case 3:
      if (a3) {
        float v4 = (float)*a1 / 32767.0;
      }
      else {
        float v4 = (float)*a1;
      }
      break;
    case 4:
      LOWORD(a4) = *a1;
      float v10 = (float)LODWORD(a4);
      if (a3) {
        float v4 = v10 / 65535.0;
      }
      else {
        float v4 = v10;
      }
      break;
    case 5:
      float v4 = *(float *)a1;
      break;
    default:
      return v4;
  }
  return v4;
}

void TSDGPUDataBufferSetMetalPoint3DWithDataType(uint64_t a1, uint64_t a2, int a3, float a4, float a5, float a6)
{
  switch(a2)
  {
    case 0:
      id v24 = [MEMORY[0x263F7C7F0] currentHandler];
      float v6 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSDGPUDataBufferSetMetalPoint3DWithDataType(uint8_t *, TSDGPUDataBufferDataType, BOOL, TSDMetalPoint3D)");
      float v7 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUDataBuffer.m"];
      [v24 handleFailureInFunction:v6 file:v7 lineNumber:203 description:@"Unknown data type!"];

      return;
    case 1:
      float v8 = 127.0;
      goto LABEL_7;
    case 2:
      float v8 = 255.0;
LABEL_7:
      float v9 = v8;
      if (a3) {
        a4 = a4 * v8;
      }
      __int16 v10 = llroundf(a4);
      float v11 = a5 * v9;
      if (!a3) {
        float v11 = a5;
      }
      __int16 v12 = llroundf(v11);
      float v13 = a6 * v9;
      if (!a3) {
        float v13 = a6;
      }
      *(unsigned char *)(a1 + 2) = llroundf(v13);
      *(_WORD *)a1 = v10 | (v12 << 8);
      return;
    case 3:
      if (a3) {
        a4 = a4 * 32767.0;
      }
      unsigned __int16 v14 = llroundf(a4);
      float v15 = a5 * 32767.0;
      if (!a3) {
        float v15 = a5;
      }
      unsigned __int16 v16 = llroundf(v15);
      float v17 = a6 * 32767.0;
      if (!a3) {
        float v17 = a6;
      }
      __int16 v18 = llroundf(v17);
      int v19 = v14 | (v16 << 16);
      goto LABEL_28;
    case 4:
      if (a3) {
        a4 = a4 * 65535.0;
      }
      unsigned int v20 = llroundf(a4);
      float v21 = a5 * 65535.0;
      if (!a3) {
        float v21 = a5;
      }
      unsigned int v22 = llroundf(v21);
      float v23 = a6 * 65535.0;
      if (!a3) {
        float v23 = a6;
      }
      __int16 v18 = llroundf(v23);
      int v19 = v20 | (v22 << 16);
LABEL_28:
      *(_DWORD *)a1 = v19;
      *(_WORD *)(a1 + 4) = v18;
      break;
    case 5:
      *(float *)a1 = a4;
      *(float *)(a1 + 4) = a5;
      *(float *)(a1 + 8) = a6;
      break;
    default:
      return;
  }
}

int8x16_t TSDGPUDataBufferMetalPoint4DWithDataType(int16x4_t *a1, uint64_t a2, unsigned int a3)
{
  int8x16_t result = (int8x16_t)TSDMetalPoint4DZero;
  switch(a2)
  {
    case 0:
      float v4 = [MEMORY[0x263F7C7F0] currentHandler];
      unint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "TSDMetalPoint4D TSDGPUDataBufferMetalPoint4DWithDataType(uint8_t *, TSDGPUDataBufferDataType, BOOL)");
      float v6 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUDataBuffer.m"];
      [v4 handleFailureInFunction:v5 file:v6 lineNumber:227 description:@"Unknown data type!"];

      return (int8x16_t)TSDMetalPoint4DZero;
    case 1:
      result.i32[0] = a1->i32[0];
      float32x4_t v7 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)result.i8)));
      unsigned int v8 = 1123942400;
      goto LABEL_7;
    case 2:
      result.i32[0] = a1->i32[0];
      float32x4_t v7 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)result.i8)));
      unsigned int v8 = 1132396544;
      goto LABEL_7;
    case 3:
      float32x4_t v7 = vcvtq_f32_s32(vmovl_s16(*a1));
      unsigned int v8 = 1191181824;
      goto LABEL_7;
    case 4:
      float32x4_t v7 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)*a1));
      unsigned int v8 = 1199570688;
LABEL_7:
      int8x16_t result = vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(a3)), 0x1FuLL)), (int8x16_t)vdivq_f32(v7, (float32x4_t)vdupq_n_s32(v8)), (int8x16_t)v7);
      break;
    case 5:
      int8x16_t result = *(int8x16_t *)a1->i8;
      break;
    default:
      return result;
  }
  return result;
}

void TSDGPUDataBufferSetMetalPoint4DWithDataType(uint64_t a1, uint64_t a2, int a3, float a4, float a5, float a6, float a7)
{
  switch(a2)
  {
    case 0:
      id v30 = [MEMORY[0x263F7C7F0] currentHandler];
      __int16 v10 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSDGPUDataBufferSetMetalPoint4DWithDataType(uint8_t *, TSDGPUDataBufferDataType, BOOL, TSDMetalPoint4D)");
      float v11 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUDataBuffer.m"];
      [v30 handleFailureInFunction:v10 file:v11 lineNumber:255 description:@"Unknown data type!"];

      break;
    case 1:
      float v12 = 127.0;
      goto LABEL_7;
    case 2:
      float v12 = 255.0;
LABEL_7:
      float v13 = v12;
      if (a3) {
        a4 = a4 * v12;
      }
      unsigned int v14 = llroundf(a4);
      float v15 = a5 * v13;
      if (!a3) {
        float v15 = a5;
      }
      unsigned int v16 = llroundf(v15);
      float v17 = a6 * v13;
      if (!a3) {
        float v17 = a6;
      }
      unsigned int v18 = llroundf(v17);
      float v19 = a7 * v13;
      if (!a3) {
        float v19 = a7;
      }
      *(_DWORD *)a1 = (v18 << 16) | (llroundf(v19) << 24) | (v16 << 8) | v14;
      break;
    case 3:
      if (a3) {
        a4 = a4 * 32767.0;
      }
      unsigned __int16 v20 = llroundf(a4);
      float v21 = a5 * 32767.0;
      if (!a3) {
        float v21 = a5;
      }
      unsigned __int16 v22 = llroundf(v21);
      float v23 = a6 * 32767.0;
      if (!a3) {
        float v23 = a6;
      }
      unsigned __int16 v24 = llroundf(v23);
      float v25 = a7 * 32767.0;
      if (!a3) {
        float v25 = a7;
      }
      LODWORD(v9) = llroundf(v25);
      *(void *)a1 = ((unint64_t)v24 << 32) | (v9 << 48) | ((unint64_t)v22 << 16) | v20;
      break;
    case 4:
      unint64_t v26 = (unint64_t)&unk_22383A000;
      if (a3) {
        a4 = a4 * 65535.0;
      }
      LODWORD(v26) = llroundf(a4);
      float v27 = a5 * 65535.0;
      if (!a3) {
        float v27 = a5;
      }
      LODWORD(v7) = llroundf(v27);
      float v28 = a6 * 65535.0;
      if (!a3) {
        float v28 = a6;
      }
      LODWORD(v8) = llroundf(v28);
      float v29 = a7 * 65535.0;
      if (!a3) {
        float v29 = a7;
      }
      LODWORD(v9) = llroundf(v29);
      *(void *)a1 = (v8 << 32) | (v9 << 48) | (v7 << 16) | v26;
      break;
    case 5:
      *(float *)a1 = a4;
      *(float *)(a1 + 4) = a5;
      *(float *)(a1 + 8) = a6;
      *(float *)(a1 + 12) = a7;
      break;
    default:
      return;
  }
}

void TSDGPUUpdateDataSetMetalFloatAtIndex(uint64_t a1, uint64_t a2, float a3)
{
}

float TSDGPUUpdateDataMetalPoint2DAtIndex(uint64_t a1, uint64_t a2, float a3)
{
  return TSDGPUDataBufferMetalPoint2DWithDataType((__int16 *)(*(void *)(a1 + 24) + *(void *)(a1 + 32) + *(void *)(a1 + 40) * a2), *(void *)a1, *(unsigned __int8 *)(a1 + 16), a3);
}

void TSDGPUUpdateDataSetMetalPoint2DAtIndex(uint64_t a1, uint64_t a2, float a3, float a4)
{
}

float TSDGPUUpdateDataMetalPoint3DAtIndex(uint64_t a1, uint64_t a2, float a3)
{
  return TSDGPUDataBufferMetalPoint3DWithDataType((__int16 *)(*(void *)(a1 + 24) + *(void *)(a1 + 32) + *(void *)(a1 + 40) * a2), *(void *)a1, *(unsigned __int8 *)(a1 + 16), a3);
}

void TSDGPUUpdateDataSetMetalPoint3DAtIndex(uint64_t a1, uint64_t a2, float a3, float a4, float a5)
{
}

void TSDGPUUpdateDataSetMetalPoint4DAtIndex(uint64_t a1, uint64_t a2, float a3, float a4, float a5, float a6)
{
}

uint64_t TSDGLGetRenderQueue()
{
  if (TSDGLGetRenderQueue_pred != -1) {
    dispatch_once(&TSDGLGetRenderQueue_pred, &__block_literal_global_46);
  }
  return TSDGLGetRenderQueue_renderQueue;
}

void __TSDGLGetRenderQueue_block_invoke()
{
  uint64_t v0 = dispatch_queue_create("TSDGLRenderQueue", 0);
  TSDGLGetRenderQueue_renderQueue = (uint64_t)v0;
  if (v0)
  {
    uint64_t v1 = (const void *)TSDGLRenderQueueContext;
    uint64_t v2 = (void *)TSDGLRenderQueueContext;
    dispatch_queue_set_specific(v0, v1, v2, 0);
  }
}

void TSDTransform3DMakeProjection(uint64_t a1@<X8>, double a2@<D0>, double a3@<D1>, double a4@<D2>, double a5@<D3>)
{
  if (a2 <= 0.0)
  {
    __int16 v10 = (_OWORD *)MEMORY[0x263F15740];
    long long v11 = *(_OWORD *)(MEMORY[0x263F15740] + 80);
    *(_OWORD *)(a1 + 64) = *(_OWORD *)(MEMORY[0x263F15740] + 64);
    *(_OWORD *)(a1 + 80) = v11;
    long long v12 = v10[7];
    *(_OWORD *)(a1 + 96) = v10[6];
    *(_OWORD *)(a1 + 112) = v12;
    long long v13 = v10[1];
    *(_OWORD *)a1 = *v10;
    *(_OWORD *)(a1 + 16) = v13;
    long long v14 = v10[3];
    *(_OWORD *)(a1 + 32) = v10[2];
    *(_OWORD *)(a1 + 48) = v14;
  }
  else
  {
    long double v9 = 1.0 / tan(a2 * 0.5);
    *(long double *)a1 = v9 / a3;
    *(_OWORD *)(a1 + 8) = 0u;
    *(_OWORD *)(a1 + 24) = 0u;
    *(long double *)(a1 + 40) = v9;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(double *)(a1 + 80) = a5 / (a4 - a5);
    *(void *)(a1 + 96) = 0;
    *(void *)(a1 + 104) = 0;
    *(void *)(a1 + 88) = 0xBFF0000000000000;
    *(double *)(a1 + 112) = a4 * a5 / (a4 - a5);
    *(void *)(a1 + 120) = 0;
  }
}

CGFloat TSDTransform3DMakeProjectionWithSlideSubrect@<D0>(uint64_t a1@<X8>, CGFloat a2@<D0>, CGFloat a3@<D1>, CGFloat a4@<D2>, CGFloat a5@<D3>, double a6@<D4>, double a7@<D5>, CGFloat a8@<D6>, CGFloat a9@<D7>, double a10, double a11, double a12)
{
  double v17 = TSDCenterOfRect(a2, a3, a4, a5);
  double v18 = TSDSubtractPoints(a6, a7, v17);
  CGFloat v37 = v19;
  CGFloat v38 = v18;
  v42.origin.CGFloat x = TSDMultiplyRectScalar(v18, v19, a8, a9, a10 / a12);
  CGFloat x = v42.origin.x;
  CGFloat y = v42.origin.y;
  CGFloat width = v42.size.width;
  CGFloat height = v42.size.height;
  double MinX = CGRectGetMinX(v42);
  v43.origin.CGFloat x = x;
  v43.origin.CGFloat y = y;
  v43.size.CGFloat width = width;
  v43.size.CGFloat height = height;
  double MaxX = CGRectGetMaxX(v43);
  v44.origin.CGFloat x = x;
  v44.origin.CGFloat y = y;
  v44.size.CGFloat width = width;
  v44.size.CGFloat height = height;
  double MinY = CGRectGetMinY(v44);
  v45.origin.CGFloat x = x;
  v45.origin.CGFloat y = y;
  v45.size.CGFloat width = width;
  v45.size.CGFloat height = height;
  CGFloat MaxY = CGRectGetMaxY(v45);
  *(double *)a1 = (a10 + a10) / (MaxX - MinX);
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(double *)(a1 + 40) = (a10 + a10) / (MaxY - MinY);
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(double *)(a1 + 64) = (MinX + MaxX) / (MaxX - MinX);
  *(double *)(a1 + 72) = (MinY + MaxY) / (MaxY - MinY);
  *(double *)(a1 + 80) = (a10 + a11) / (a10 - a11);
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 88) = 0xBFF0000000000000;
  *(double *)(a1 + 112) = (a11 + a11) * a10 / (a10 - a11);
  *(void *)(a1 + 120) = 0;
  CATransform3DMakeTranslation(&a, v38, v37, 0.0);
  long long v28 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)&b.m31 = *(_OWORD *)(a1 + 64);
  *(_OWORD *)&b.m33 = v28;
  long long v29 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)&b.m41 = *(_OWORD *)(a1 + 96);
  *(_OWORD *)&b.m43 = v29;
  long long v30 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&b.m11 = *(_OWORD *)a1;
  *(_OWORD *)&b.m13 = v30;
  long long v31 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)&b.m21 = *(_OWORD *)(a1 + 32);
  *(_OWORD *)&b.m23 = v31;
  CATransform3DConcat(&v41, &a, &b);
  long long v32 = *(_OWORD *)&v41.m33;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)&v41.m31;
  *(_OWORD *)(a1 + 80) = v32;
  long long v33 = *(_OWORD *)&v41.m43;
  *(_OWORD *)(a1 + 96) = *(_OWORD *)&v41.m41;
  *(_OWORD *)(a1 + 112) = v33;
  long long v34 = *(_OWORD *)&v41.m13;
  *(_OWORD *)a1 = *(_OWORD *)&v41.m11;
  *(_OWORD *)(a1 + 16) = v34;
  CGFloat result = v41.m21;
  long long v36 = *(_OWORD *)&v41.m23;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)&v41.m21;
  *(_OWORD *)(a1 + 48) = v36;
  return result;
}

double TSDTransform3DMakeOrtho@<D0>(uint64_t a1@<X8>, double a2@<D0>, double a3@<D1>, double a4@<D2>, double a5@<D3>, double a6@<D4>, double a7@<D5>)
{
  *(double *)a1 = 2.0 / (a3 - a2);
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(double *)(a1 + 40) = 2.0 / (a5 - a4);
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(double *)(a1 + 80) = -2.0 / (a7 - a6);
  *(void *)(a1 + 88) = 0;
  *(double *)(a1 + 96) = -(a2 + a3) / (a3 - a2);
  *(double *)(a1 + 104) = -(a4 + a5) / (a5 - a4);
  double result = -(a6 + a7) / (a7 - a6);
  *(double *)(a1 + 112) = result;
  *(void *)(a1 + 120) = 0x3FF0000000000000;
  return result;
}

uint64_t p_URLFromPathname(void *a1)
{
  uint64_t v2 = (void *)[MEMORY[0x263F08850] defaultManager];
  id v3 = (void *)[a1 stringByDeletingPathExtension];
  uint64_t v4 = [v3 stringByAppendingPathExtension:@"png"];
  if ([v2 fileExistsAtPath:v4]
    && [v2 fileExistsAtPath:v4])
  {
    uint64_t v5 = 1;
    do
    {
      uint64_t v6 = (v5 + 1);
      uint64_t v4 = objc_msgSend((id)objc_msgSend(v3, "stringByAppendingFormat:", @"-%d", v5), "stringByAppendingPathExtension:", @"png");
      char v7 = [v2 fileExistsAtPath:v4];
      uint64_t v5 = v6;
    }
    while ((v7 & 1) != 0);
  }
  uint64_t v8 = NSURL;

  return [v8 fileURLWithPath:v4 isDirectory:0];
}

uint64_t p_writeDataToPNG(const void *a1, uint64_t a2, CGFloat *a3, size_t a4, void *a5)
{
  if (!a1)
  {
    uint64_t v8 = [MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "NSString *p_writeDataToPNG(uint8_t *, int32_t, int32_t, size_t, NSString *)");
    uint64_t v10 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUUtility.m"];
    long long v11 = @"buffer is NULL!";
    long long v12 = (void *)v8;
    uint64_t v13 = v9;
    uint64_t v14 = 208;
LABEL_7:
    objc_msgSend(v12, "handleFailureInFunction:file:lineNumber:description:", v13, v10, v14, v11, decode);
    return 0;
  }
  if ((a2 - 32769) <= 0xFFFF7FFF)
  {
    uint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "NSString *p_writeDataToPNG(uint8_t *, int32_t, int32_t, size_t, NSString *)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUUtility.m"), 212, @"width is invalid: %d", a2);
    return 0;
  }
  if ((a3 - 32769) <= 0xFFFF7FFF)
  {
    uint64_t v16 = [MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v17 = objc_msgSend(NSString, "stringWithUTF8String:", "NSString *p_writeDataToPNG(uint8_t *, int32_t, int32_t, size_t, NSString *)");
    uint64_t v10 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUUtility.m"];
    long long v11 = @"height is invalid: %d";
    decode = a3;
    long long v12 = (void *)v16;
    uint64_t v13 = v17;
    uint64_t v14 = 216;
    goto LABEL_7;
  }
  CFURLRef v21 = (const __CFURL *)p_URLFromPathname(a5);
  CGImageDestinationRef v22 = CGImageDestinationCreateWithURL(v21, (CFStringRef)[(id)*MEMORY[0x263F1DC08] identifier], 1uLL, 0);
  if (v22)
  {
    float v23 = v22;
    size_t v24 = a2;
    size_t v25 = ((a4 >> 1) & 0x1FFFFFFFFFFFFFFFLL) * a2;
    size_t v26 = a3;
    CGDataProviderRef v27 = CGDataProviderCreateWithData(0, a1, v25 * a3, 0);
    if (v27)
    {
      long long v28 = v27;
      long long v29 = (CGColorSpace *)TSUDeviceRGBColorSpace();
      long long v30 = CGImageCreate(v24, v26, a4, 4 * a4, v25, v29, 1u, v28, 0, 0, kCGRenderingIntentDefault);
      if (v30)
      {
        long long v31 = v30;
        CGImageDestinationAddImage(v23, v30, 0);
        CGImageDestinationFinalize(v23);
        CGImageRelease(v31);
      }
      else
      {
        long long v36 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v37 = objc_msgSend(NSString, "stringWithUTF8String:", "NSString *p_writeDataToPNG(uint8_t *, int32_t, int32_t, size_t, NSString *)");
        objc_msgSend(v36, "handleFailureInFunction:file:lineNumber:description:", v37, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUUtility.m"), 244, @"Couldn't create CGImage!");
        CFURLRef v21 = 0;
      }
      CGDataProviderRelease(v28);
    }
    else
    {
      long long v34 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v35 = objc_msgSend(NSString, "stringWithUTF8String:", "NSString *p_writeDataToPNG(uint8_t *, int32_t, int32_t, size_t, NSString *)");
      objc_msgSend(v34, "handleFailureInFunction:file:lineNumber:description:", v35, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUUtility.m"), 234, @"Couldn't create CGDataProvider!");
      CFURLRef v21 = 0;
    }
    CFRelease(v23);
  }
  else
  {
    long long v32 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v33 = objc_msgSend(NSString, "stringWithUTF8String:", "NSString *p_writeDataToPNG(uint8_t *, int32_t, int32_t, size_t, NSString *)");
    [v32 handleFailureInFunction:v33, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUUtility.m"), 223, @"Couldn't create CGImageDestination for URL %@!", v21 file lineNumber description];
    CFURLRef v21 = 0;
  }

  return [(__CFURL *)v21 path];
}

__CFString *NSStringFromTSDGestureState(unsigned int a1)
{
  if (a1 < 5) {
    return off_2646B1FB8[a1];
  }
  if (a1 == 5) {
    return @"TSDGestureStateFailed";
  }
  return @"#Unknown TSDGestureState#";
}

void sub_22369C9F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_22369CB90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_22369CBF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  uint64_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)TSDBrushStrokeDirectSurfaceRenderingContext;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_22369CDA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_22369CE9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_22369CF3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_22369CFF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_22369D074(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_22369D134(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_22369D21C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_22369D2C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_22369D3E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_22369D590(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_22369D664(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_22369D780(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_22369E408(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,void *a30)
{
  _Unwind_Resume(a1);
}

void sub_22369ED40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19, void *a20,uint64_t a21,uint64_t a22,id a23)
{
  _Unwind_Resume(a1);
}

void sub_22369F184(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_22369F380(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2236A0C54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,void *__p,uint64_t a35)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_2236A273C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,void *a38,void *a39,void *a40,void *a41,void *a42,void *a43,void *a44,_Unwind_Exception *exception_objecta,uint64_t a46,void *a47,void *a48,uint64_t a49,uint64_t a50,void *a51,void *a52,void *a53)
{
  _Unwind_Resume(a1);
}

void *__copy_helper_block_ea8_56c60_ZTSNSt3__16vectorI18TSDBrushVertexDataNS_9allocatorIS1_EEEE(uint64_t a1, uint64_t a2)
{
  return std::vector<TSDBrushVertexData>::vector((void *)(a1 + 56), a2 + 56);
}

void __destroy_helper_block_ea8_56c60_ZTSNSt3__16vectorI18TSDBrushVertexDataNS_9allocatorIS1_EEEE(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 56);
  if (v2)
  {
    *(void *)(a1 + 64) = v2;
    operator delete(v2);
  }
}

void sub_2236A3080(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2236A318C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2236A32E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2236A33F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2236A3498(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2236A359C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2236A3838(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22)
{
  _Block_object_dispose(&a17, 8);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__15(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__15(uint64_t a1)
{
}

void sub_2236A3B70(_Unwind_Exception *a1)
{
  uint64_t v8 = v4;

  _Unwind_Resume(a1);
}

void sub_2236A3D68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22)
{
  _Block_object_dispose(&a17, 8);

  _Unwind_Resume(a1);
}

void sub_2236A3F5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  long long v12 = v10;

  _Unwind_Resume(a1);
}

void sub_2236A40F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22)
{
  _Block_object_dispose(&a17, 8);

  _Unwind_Resume(a1);
}

void sub_2236A42D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  long long v12 = v10;

  _Unwind_Resume(a1);
}

void sub_2236A4474(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::vector<TSDBrushVertexData>::vector<std::__wrap_iter<TSDBrushVertexData*>,0>(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  int64_t v4 = a3 - a2;
  if (a3 != a2)
  {
    std::vector<TSDBrushVertexData>::__vallocate[abi:nn180100]((void *)a1, v4 >> 5);
    uint64_t v7 = *(void *)(a1 + 8);
    if (a3 != a2) {
      memmove(*(void **)(a1 + 8), a2, v4);
    }
    *(void *)(a1 + 8) = v7 + 32 * (v4 >> 5);
  }
  return a1;
}

char *std::vector<TSDBrushVertexData>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 59) {
    abort();
  }
  double result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKit::OpticalKern::Edge::CGPointVector>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * v4];
  return result;
}

void *std::vector<TSDBrushVertexData>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(const void **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  int64_t v5 = v3 - *(void *)a2;
  if (v3 != *(void *)a2)
  {
    std::vector<TSDBrushVertexData>::__vallocate[abi:nn180100](a1, v5 >> 5);
    uint64_t v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

uint64_t TSDMixingTypeBestFromMixingTypes(uint64_t result, uint64_t a2)
{
  if (result >= a2) {
    return a2;
  }
  return result;
}

__CFString *TSDMixingTypeAsString(unint64_t a1)
{
  if (a1 < 6) {
    return off_2646B2170[a1];
  }
  uint64_t v3 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
  uint64_t v4 = [NSString stringWithUTF8String:"NSString *TSDMixingTypeAsString(TSDMixingType)"];
  objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDMagicMove.m"), 67, @"Unknown mixing type (%ld)!", a1);
  return 0;
}

uint64_t TSDMixingTypeWithPossiblyNilObjects(unint64_t a1, unint64_t a2)
{
  if (!(a1 | a2)) {
    return 5;
  }
  if (!a1 || [MEMORY[0x263EFF9D0] null] == a1)
  {
    objc_opt_class();
    if (objc_opt_respondsToSelector()) {
      int v7 = [(id)objc_opt_class() canMixWithNilObjects];
    }
    else {
      int v7 = 0;
    }
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0 || v7)
    {
      uint64_t v4 = (void *)a2;
      unint64_t v5 = a1;
      goto LABEL_17;
    }
    return 1;
  }
  if (!a2 || [MEMORY[0x263EFF9D0] null] == a2)
  {
    objc_opt_class();
    if ((objc_opt_respondsToSelector() & 1) == 0
      || ![(id)objc_opt_class() canMixWithNilObjects])
    {
      return 1;
    }
  }
  uint64_t v4 = (void *)a1;
  unint64_t v5 = a2;
LABEL_17:

  return [v4 mixingTypeWithObject:v5];
}

uint64_t TSDMixedObjectWithPossiblyNilObjects(void *a1, void *a2, double a3)
{
  if (!a1 || (void *)[MEMORY[0x263EFF9D0] null] == a1)
  {
    double v7 = 1.0 - a3;
    uint64_t v6 = a2;
    uint64_t v8 = a1;
  }
  else
  {
    uint64_t v6 = a1;
    double v7 = a3;
    uint64_t v8 = a2;
  }

  return [v6 mixedObjectWithFraction:v8 ofObject:v7];
}

uint64_t TSDMixingTypeWithObjects(unint64_t a1, unint64_t a2)
{
  BOOL v3 = (a1 | a2) == 0;
  uint64_t result = 5;
  if (a1 != a2 && !v3)
  {
    if ([(id)a1 isEqual:a2]) {
      return 5;
    }
    if (!a1 || [MEMORY[0x263EFF9D0] null] == a1)
    {
      if ([(id)a2 conformsToProtocol:&unk_26D7858E0]
        && (objc_opt_class(), (objc_opt_respondsToSelector() & 1) != 0))
      {
        int v6 = [(id)objc_opt_class() canMixWithNilObjects];
      }
      else
      {
        int v6 = 0;
      }
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0 && !v6) {
        return 1;
      }
    }
    else
    {
      if (!a2 || [MEMORY[0x263EFF9D0] null] == a2)
      {
        if (![(id)a1 conformsToProtocol:&unk_26D7858E0]) {
          return 1;
        }
        objc_opt_class();
        if ((objc_opt_respondsToSelector() & 1) == 0
          || ![(id)objc_opt_class() canMixWithNilObjects])
        {
          return 1;
        }
        goto LABEL_27;
      }
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          objc_opt_class();
          if ((objc_opt_respondsToSelector() & 1) == 0
            || (long long v11 = (void *)[(id)objc_opt_class() mixableObjectClasses],
                ([v11 containsObject:objc_opt_class()] & 1) == 0))
          {
            objc_opt_class();
            if ((objc_opt_respondsToSelector() & 1) == 0) {
              return 1;
            }
            long long v12 = (void *)[(id)objc_opt_class() mixableObjectClasses];
            if (![v12 containsObject:objc_opt_class()]) {
              return 1;
            }
          }
        }
      }
      if (![(id)a1 conformsToProtocol:&unk_26D7858E0]
        || ![(id)a2 conformsToProtocol:&unk_26D7858E0])
      {
        return 2;
      }
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
LABEL_27:
        double v7 = (void *)a1;
        unint64_t v8 = a2;
LABEL_22:
        uint64_t result = [v7 mixingTypeWithObject:v8];
        if (!result)
        {
          uint64_t v9 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v10 = objc_msgSend(NSString, "stringWithUTF8String:", "TSDMixingType TSDMixingTypeWithObjects(NSObject<TSDMixing> *, NSObject<TSDMixing> *)");
          objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDMagicMove.m"), 168, @"TSDMixingType is Undefined!");
          return 0;
        }
        return result;
      }
    }
    double v7 = (void *)a2;
    unint64_t v8 = a1;
    goto LABEL_22;
  }
  return result;
}

uint64_t TSDMixingTypeWithObject(unint64_t a1, unint64_t a2, uint64_t a3)
{
  BOOL v4 = (a1 | a2) == 0;
  uint64_t result = 5;
  if (a1 == a2 || v4) {
    return result;
  }
  if ([(id)a1 isEqual:a2]) {
    return 5;
  }
  if (!a1 || [MEMORY[0x263EFF9D0] null] == a1)
  {
    objc_opt_class();
    if (objc_opt_respondsToSelector())
    {
LABEL_16:
      if ([(id)objc_opt_class() canMixWithNilObjects]) {
        return 4;
      }
    }
    return 1;
  }
  if (!a2 || [MEMORY[0x263EFF9D0] null] == a2)
  {
    objc_opt_class();
    if (objc_opt_respondsToSelector()) {
      goto LABEL_16;
    }
    return 1;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      objc_opt_class();
      if ((objc_opt_respondsToSelector() & 1) == 0
        || (uint64_t v10 = (void *)[(id)objc_opt_class() mixableObjectClasses],
            ([v10 containsObject:objc_opt_class()] & 1) == 0))
      {
        objc_opt_class();
        if ((objc_opt_respondsToSelector() & 1) == 0) {
          return 1;
        }
        long long v11 = (void *)[(id)objc_opt_class() mixableObjectClasses];
        if (![v11 containsObject:objc_opt_class()]) {
          return 1;
        }
      }
    }
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
  if (!result)
  {
    unint64_t v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "TSDMixingType TSDMixingTypeWithObject(NSObject<TSDMixing> *, NSObject<TSDMixing> *, TSDMixingType (^)(void))");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDMagicMove.m"), 222, @"TSDMixingType is Undefined!");
    return 0;
  }
  return result;
}

uint64_t TSDMixingMixedObjectWithFraction(void *a1, void *a2, uint64_t a3)
{
  if ([a1 mixingTypeWithObject:a2] == 1)
  {
    int v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "id TSDMixingMixedObjectWithFraction(NSObject<TSDMixing> *, NSObject<TSDMixing> *, CGFloat, id (^)(void))");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDMagicMove.m"), 230, @"Cannot mix with object!");
  }
  if (a1 == a2 || ([a1 isEqual:a2] & 1) != 0) {
    return (uint64_t)a1;
  }
  uint64_t v9 = *(uint64_t (**)(uint64_t))(a3 + 16);

  return v9(a3);
}

uint64_t TSDMixingMixedObjectWithFractionEx(void *a1, unint64_t a2, double a3)
{
  if (TSDMixingTypeWithObjects((unint64_t)a1, a2) == 1)
  {
    int v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "id TSDMixingMixedObjectWithFractionEx(NSObject<TSDMixing> *, NSObject<TSDMixing> *, CGFloat)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDMagicMove.m"), 243, @"Cannot mix with object!");
  }
  if (a1 == (void *)a2 || ([a1 isEqual:a2] & 1) != 0) {
    return (uint64_t)a1;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v9 = a1;
    double v10 = a3;
    long long v11 = (void *)a2;
  }
  else
  {
    double v10 = 1.0 - a3;
    uint64_t v9 = (void *)a2;
    long long v11 = a1;
  }

  return [v9 mixedObjectWithFraction:v11 ofObject:v10];
}

void sub_2236A66B0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2236A6894(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2236A6958(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t TSKPlayerRepeatModeForMovieLoopOption(uint64_t a1)
{
  if (a1 == 1) {
    return 1;
  }
  else {
    return 2 * (a1 == 2);
  }
}

id universalReset(void *a1, const char *a2)
{
  objc_msgSend((id)objc_msgSend(MEMORY[0x263F08A00], "defaultCenter"), "postNotificationName:object:", @"TSDControllingGRDidResetNotification", a1);
  Class = object_getClass(a1);
  if ([NSStringFromClass(Class) hasPrefix:@"__TSDResetNotifying"])
  {
    v7.receiver = a1;
    unint64_t v5 = object_getClass(a1);
    v7.super_class = class_getSuperclass(v5);
    return objc_msgSendSuper(&v7, a2);
  }
  else
  {
    return (id)[a1 reset];
  }
}

void sub_2236ADD40(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2236ADE88(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2236B1A08(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 216), 8);
  _Block_object_dispose((const void *)(v1 - 184), 8);
  _Unwind_Resume(a1);
}

void sub_2236B7C2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__16(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__16(uint64_t a1)
{
}

void sub_2236BB798(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 120), 8);
  _Unwind_Resume(a1);
}

void sub_2236C6968(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 208), 8);
  _Unwind_Resume(a1);
}

double calculateReflectionShadingValues(double *a1, double *a2, uint64_t a3)
{
  float v4 = 1.0 - *a2;
  float v5 = a1[1];
  double result = *a1 * powf(v4, v5);
  *(void *)a3 = 0;
  *(double *)(a3 + 8) = result;
  return result;
}

void sub_2236D1494(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__17(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__17(uint64_t a1)
{
}

uint64_t TSDCapabilitiesDeviceTypeFromHWModelString(void *a1)
{
  uint64_t v1 = objc_msgSend((id)objc_msgSend(a1, "componentsSeparatedByCharactersInSet:", objc_msgSend(MEMORY[0x263F08708], "decimalDigitCharacterSet")), "firstObject");
  uint64_t result = [v1 length];
  if (result)
  {
    if ([v1 isEqualToString:@"iPad"])
    {
      return 1;
    }
    else if ([v1 isEqualToString:@"iPhone"])
    {
      return 2;
    }
    else if ([v1 isEqualToString:@"iPod"])
    {
      return 3;
    }
    else if ([v1 isEqualToString:@"iMac"])
    {
      return 4;
    }
    else if ([v1 isEqualToString:@"MacBook"])
    {
      return 5;
    }
    else if ([v1 isEqualToString:@"MacBookAir"])
    {
      return 6;
    }
    else if ([v1 isEqualToString:@"MacBookPro"])
    {
      return 7;
    }
    else if ([v1 isEqualToString:@"Macmini"])
    {
      return 8;
    }
    else if ([v1 isEqualToString:@"MacPro"])
    {
      return 9;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t TSDBundle()
{
  if (TSDBundle::onceToken != -1) {
    dispatch_once(&TSDBundle::onceToken, &__block_literal_global_56);
  }
  return TSDBundle::bundle;
}

uint64_t __TSDBundle_block_invoke()
{
  uint64_t result = [MEMORY[0x263F086E0] bundleForClass:objc_opt_class()];
  TSDBundle::bundle = result;
  return result;
}

__CFString *KNAnimationTypeAsString(int a1)
{
  if ((a1 - 1) > 3) {
    return @"None";
  }
  else {
    return off_2646B2618[a1 - 1];
  }
}

uint64_t KNAnimationTypeFromString(void *a1)
{
  if ([a1 isEqualToString:@"None"]) {
    return 0;
  }
  if ([a1 isEqualToString:@"In"]) {
    return 1;
  }
  if ([a1 isEqualToString:@"Out"]) {
    return 2;
  }
  if ([a1 isEqualToString:@"Transition"]) {
    return 3;
  }
  if ([a1 isEqualToString:@"Action"]) {
    return 4;
  }
  return 0;
}

uint64_t KNAnimationTypeAsNumber(uint64_t a1)
{
  return [NSNumber numberWithInt:a1];
}

uint64_t KNAnimationTypeFromNumber(void *a1)
{
  LODWORD(result) = [a1 intValue];
  if (result >= 5) {
    return 0;
  }
  else {
    return result;
  }
}

uint64_t KNEffectIsEmphasisEffect(uint64_t a1)
{
  if (KNEffectIsEmphasisEffect_onceToken != -1) {
    dispatch_once(&KNEffectIsEmphasisEffect_onceToken, &__block_literal_global_58);
  }
  uint64_t v2 = (void *)KNEffectIsEmphasisEffect_sEmphasisEffectsSet;

  return [v2 containsObject:a1];
}

uint64_t __KNEffectIsEmphasisEffect_block_invoke()
{
  uint64_t result = objc_msgSend(objc_alloc(MEMORY[0x263EFFA08]), "initWithObjects:", @"apple:action-pop", @"apple:action-pulse", @"apple:action-blink", @"apple:action-flip", @"apple:action-bounce", @"apple:action-jiggle", 0);
  KNEffectIsEmphasisEffect_sEmphasisEffectsSet = result;
  return result;
}

uint64_t KNEffectIsActionEffect(uint64_t a1)
{
  if (KNEffectIsActionEffect_onceToken != -1) {
    dispatch_once(&KNEffectIsActionEffect_onceToken, &__block_literal_global_34);
  }
  if ([(id)KNEffectIsActionEffect_sActionEffectsSet containsObject:a1]) {
    return 1;
  }

  return KNEffectIsEmphasisEffect(a1);
}

uint64_t __KNEffectIsActionEffect_block_invoke()
{
  uint64_t result = objc_msgSend(objc_alloc(MEMORY[0x263EFFA08]), "initWithObjects:", @"apple:action-opacity", @"apple:action-motion-path", @"apple:action-rotation", @"apple:action-scale", 0);
  KNEffectIsActionEffect_sActionEffectsSet = result;
  return result;
}

void TSDgpc_free_polygon(uint64_t a1)
{
  int v2 = *(_DWORD *)a1;
  if (*(int *)a1 >= 1)
  {
    uint64_t v3 = 0;
    uint64_t v4 = *(void *)(a1 + 16);
    uint64_t v5 = 8;
    do
    {
      int v6 = *(void **)(v4 + v5);
      if (v6)
      {
        gpc_free(v6);
        uint64_t v4 = *(void *)(a1 + 16);
        *(void *)(v4 + v5) = 0;
        int v2 = *(_DWORD *)a1;
      }
      ++v3;
      v5 += 16;
    }
    while (v3 < v2);
  }
  objc_super v7 = *(void **)(a1 + 8);
  if (v7)
  {
    gpc_free(v7);
    *(void *)(a1 + 8) = 0;
  }
  unint64_t v8 = *(void **)(a1 + 16);
  if (v8)
  {
    gpc_free(v8);
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)a1 = 0;
}

uint64_t TSDgpc_dump_polygon(char *a1, size_t a2, int a3, int *a4)
{
  uint64_t result = snprintf(a1, a2, "contours: %d\n", *a4);
  if (result != -1 && a2 > (int)result && *a4 >= 1)
  {
    uint64_t v9 = 0;
    size_t v10 = a2 - (int)result;
    long long v11 = &a1[(int)result];
    uint64_t v12 = *((void *)a4 + 2);
    do
    {
      uint64_t result = snprintf(v11, v10, "vertices: %d\n", *(_DWORD *)(v12 + 16 * v9));
      if (result == -1 || v10 <= (int)result) {
        break;
      }
      v11 += (int)result;
      v10 -= (int)result;
      if (a3)
      {
        uint64_t result = snprintf(v11, v10, "flag: %d\n", *(_DWORD *)(*((void *)a4 + 1) + 4 * v9));
        if (result == -1 || v10 <= (int)result) {
          return result;
        }
        v11 += (int)result;
        v10 -= (int)result;
      }
      uint64_t v12 = *((void *)a4 + 2);
      if (*(int *)(v12 + 16 * v9) >= 1)
      {
        uint64_t v13 = 0;
        uint64_t v14 = 0;
        do
        {
          float v15 = (double *)(*(void *)(v12 + 16 * v9 + 8) + v13);
          uint64_t result = snprintf(v11, v10, "% .*f\t% .*f\n", 15, *v15, 15, v15[1]);
          if (result == -1 || v10 <= (int)result) {
            return result;
          }
          v11 += (int)result;
          v10 -= (int)result;
          ++v14;
          uint64_t v12 = *((void *)a4 + 2);
          v13 += 16;
        }
        while (v14 < *(int *)(v12 + 16 * v9));
      }
      ++v9;
    }
    while (v9 < *a4);
  }
  return result;
}

size_t TSDgpc_log_polygon(int *a1)
{
  return TSDgpc_write_polygon((FILE *)*MEMORY[0x263EF8348], 1, a1);
}

size_t TSDgpc_write_polygon(FILE *a1, int a2, int *a3)
{
  size_t result = fprintf(a1, "%d\n", *a3);
  if (*((void *)a3 + 2))
  {
    if (*a3 >= 1)
    {
      uint64_t v7 = 0;
      do
      {
        size_t result = fprintf(a1, "%d\n", *(_DWORD *)(*((void *)a3 + 2) + 16 * v7));
        if (a2) {
          size_t result = fprintf(a1, "%d\n", *(_DWORD *)(*((void *)a3 + 1) + 4 * v7));
        }
        uint64_t v8 = *((void *)a3 + 2);
        if (*(void *)(v8 + 16 * v7 + 8))
        {
          if (*(int *)(v8 + 16 * v7) >= 1)
          {
            uint64_t v9 = 0;
            uint64_t v10 = 0;
            do
            {
              long long v11 = (double *)(*(void *)(v8 + 16 * v7 + 8) + v9);
              size_t result = fprintf(a1, "% .*f % .*f\n", 15, *v11, 15, v11[1]);
              ++v10;
              uint64_t v8 = *((void *)a3 + 2);
              v9 += 16;
            }
            while (v10 < *(int *)(v8 + 16 * v7));
          }
        }
        else
        {
          size_t result = fwrite("### NIL VERTEX PTR\n", 0x13uLL, 1uLL, a1);
        }
        ++v7;
      }
      while (v7 < *a3);
    }
  }
  else
  {
    return fwrite("### NIL CONTOUR PTR\n", 0x14uLL, 1uLL, a1);
  }
  return result;
}

void TSDgpc_add_contour(int *a1, int *a2, int a3)
{
  if (*a1 == -1)
  {
    int v6 = 0;
    uint64_t v7 = 0;
LABEL_5:
    int v8 = -1;
    goto LABEL_6;
  }
  uint64_t v7 = gpc_malloc(4 * (*a1 + 1));
  if (*a1 == -1)
  {
    int v6 = 0;
    goto LABEL_5;
  }
  double v18 = (char *)gpc_malloc(16 * (*a1 + 1));
  int v6 = v18;
  int v8 = *a1;
  if (*a1 > 0)
  {
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    do
    {
      uint64_t v21 = *((void *)a1 + 2);
      v7[v20] = *(_DWORD *)(*((void *)a1 + 1) + 4 * v20);
      *(_OWORD *)&v18[v19] = *(_OWORD *)(v21 + v19);
      ++v20;
      uint64_t v9 = *a1;
      v19 += 16;
    }
    while (v20 < v9);
    goto LABEL_7;
  }
LABEL_6:
  uint64_t v9 = v8;
LABEL_7:
  v7[v9] = a3;
  *(_DWORD *)&v6[16 * v9] = *a2;
  uint64_t v10 = *a2;
  if (v10) {
    long long v11 = gpc_malloc(16 * v10);
  }
  else {
    long long v11 = 0;
  }
  uint64_t v12 = &v6[16 * v9];
  *((void *)v12 + 1) = v11;
  uint64_t v13 = v12 + 8;
  if (*a2 >= 1)
  {
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    do
    {
      *(_OWORD *)(*v13 + v14) = *(_OWORD *)(*((void *)a2 + 1) + v14);
      ++v15;
      v14 += 16;
    }
    while (v15 < *a2);
  }
  uint64_t v16 = (void *)*((void *)a1 + 2);
  if (v16)
  {
    gpc_free(v16);
    *((void *)a1 + 2) = 0;
  }
  uint64_t v17 = (void *)*((void *)a1 + 1);
  if (v17) {
    gpc_free(v17);
  }
  ++*a1;
  *((void *)a1 + 1) = v7;
  *((void *)a1 + 2) = v6;
}

int *clean_polygon(int *result)
{
  if (*result >= 1)
  {
    uint64_t v1 = result;
    uint64_t v2 = 0;
    while (1)
    {
      uint64_t v3 = *((void *)v1 + 2) + 16 * v2;
      int v4 = *(_DWORD *)v3;
      uint64_t v5 = *(void **)(v3 + 8);
      if (*(int *)v3 < 2) {
        break;
      }
      uint64_t v6 = 0;
      int v7 = v4 - 1;
      int v8 = (double *)(v5 + 2);
      int v9 = -1;
      do
      {
        size_t result = (int *)(v8 - 2);
        if (vabdd_f64(*(v8 - 2), *v8) <= 2.22044605e-16 && vabdd_f64(*(v8 - 1), v8[1]) <= 2.22044605e-16)
        {
          size_t result = (int *)memmove(result, v8, 16 * (v4 + v9));
          int v4 = v7;
        }
        ++v6;
        int v7 = v4 - 1;
        --v9;
        v8 += 2;
      }
      while (v6 < v4 - 1);
      if (v4 < 3) {
        goto LABEL_12;
      }
      int v10 = *v1;
      ++v2;
LABEL_14:
      if (v2 >= v10) {
        return result;
      }
    }
    if (v5) {
LABEL_12:
    }
      gpc_free(v5);
    size_t result = (int *)memmove((void *)(*((void *)v1 + 2) + 16 * v2), (const void *)(*((void *)v1 + 2) + 16 * (v2 + 1)), 16 * (*v1 + ~v2));
    int v10 = *v1 - 1;
    *uint64_t v1 = v10;
    ++v2;
    goto LABEL_14;
  }
  return result;
}

uint64_t TSDprint_polygon(int *a1)
{
  puts("begin poly");
  if (*a1 >= 1)
  {
    uint64_t v2 = 0;
    do
    {
      uint64_t v3 = (unsigned int *)(*((void *)a1 + 2) + 16 * v2);
      uint64_t v4 = *v3;
      uint64_t v5 = *((void *)v3 + 1);
      puts("\tbegin contour");
      if ((int)v4 >= 1)
      {
        uint64_t v6 = (double *)(v5 + 8);
        do
        {
          printf("\t\t%g, %g\n", *(v6 - 1), *v6);
          v6 += 2;
          --v4;
        }
        while (v4);
      }
      puts("\tend contour");
      ++v2;
    }
    while (v2 < *a1);
  }

  return puts("end poly\n");
}

void TSDgpc_polygon_clip(unsigned int a1, unsigned int *a2, int *a3, unsigned int *a4)
{
  uint64_t v4 = (uint64_t)a4;
  int v7 = a1;
  v278 = 0;
  v279[0] = 0;
  v276 = 0;
  uint64_t v277 = 0;
  uint64_t v275 = 0;
  int v8 = *a2;
  int v9 = *a3;
  if (!*a2)
  {
    if (a1 >= 2 && v9)
    {
      LODWORD(v274) = 0;
      goto LABEL_15;
    }
LABEL_18:
    if (a2 == a4) {
      TSDgpc_free_polygon((uint64_t)a2);
    }
    if (a3 == (int *)v4) {
      TSDgpc_free_polygon(v4);
    }
    *(_DWORD *)uint64_t v4 = 0;
    *(void *)(v4 + 8) = 0;
    *(void *)(v4 + 16) = 0;
    return;
  }
  if (a1 == 1 && !v9) {
    goto LABEL_18;
  }
  LODWORD(v274) = a1 == 0;
  if (a1 <= 1 && v8 >= 1 && v9 >= 1)
  {
    minimax_test((uint64_t)a2, a3, a1);
    int v7 = a1;
    int v8 = *a2;
  }
  if (v8 >= 1)
  {
    long long v11 = build_lmt((double **)&v276, (double *)v279, &v275, a2, 1, v7);
    goto LABEL_16;
  }
LABEL_15:
  long long v11 = 0;
LABEL_16:
  if (*a3 < 1) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = build_lmt((double **)&v276, (double *)v279, &v275, (unsigned int *)a3, 0, a1);
  }
  if (v276)
  {
    int v246 = (double *)v276;
    int v13 = v275;
    if (v275) {
      uint64_t v14 = (double *)gpc_malloc(8 * (int)v275);
    }
    else {
      uint64_t v14 = 0;
    }
    int v244 = v14;
    build_sbt((int *)&v275 + 1, (uint64_t)v14, (uint64_t)v279[0]);
    free_sbtree(v279);
    if (a2 == (unsigned int *)v4) {
      TSDgpc_free_polygon((uint64_t)a2);
    }
    int v242 = v12;
    signed int v243 = v11;
    if (a3 == (int *)v4) {
      TSDgpc_free_polygon(v4);
    }
    if (v13 <= 0)
    {
      *(void *)(v4 + 8) = 0;
      *(void *)(v4 + 16) = 0;
      uint64_t v216 = v12;
      uint64_t v217 = v11;
    }
    else
    {
      int v241 = (int *)v4;
      uint64_t v16 = 0;
      uint64_t v17 = 0;
      int v18 = 0;
      uint64_t v19 = 0;
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      uint64_t v22 = 0;
      int v245 = 0;
      HIDWORD(v274) = 0;
      uint64_t v23 = 0;
      uint64_t v263 = 0;
      double v24 = 0.0;
      double v25 = 0.0;
      unsigned int v26 = a1;
      do
      {
        uint64_t v27 = v18 + 1;
        HIDWORD(v275) = v27;
        double v28 = v244[v18];
        if ((int)v27 < v13)
        {
          double v25 = v244[v27];
          double v24 = v25 - v28;
        }
        long long v29 = v246;
        if (v246 && *v246 == v28)
        {
          uint64_t v30 = *((void *)v246 + 1);
          if (v30)
          {
            uint64_t v31 = v19;
            uint64_t v32 = v22;
            uint64_t v33 = v20;
            uint64_t v34 = v21;
            do
            {
              add_edge_to_aet(&v277, v30, 0);
              uint64_t v30 = *(void *)(v30 + 160);
            }
            while (v30);
            uint64_t v16 = v277;
            unsigned int v26 = a1;
            uint64_t v21 = v34;
            uint64_t v20 = v33;
            uint64_t v22 = v32;
            uint64_t v19 = v31;
          }
          long long v29 = (double *)*((void *)v246 + 2);
          uint64_t v17 = v16;
        }
        *(_DWORD *)(v17 + 76 + 4 * *(int *)(v17 + 72)) = *(double *)(v17 + 40) != v28;
        *(_DWORD *)(v17 + 76 + 4 * (*(_DWORD *)(v17 + 72) == 0)) = 0;
        *(_DWORD *)(v17 + 100) = 0;
        uint64_t v35 = *(void *)(v17 + 136);
        uint64_t v36 = v17;
        int v246 = v29;
        if (!v35) {
          goto LABEL_61;
        }
        do
        {
          uint64_t v37 = v35 + 76;
          *(_DWORD *)(v35 + 76 + 4 * *(int *)(v35 + 72)) = *(double *)(v35 + 40) != v28;
          uint64_t v38 = *(int *)(v35 + 72);
          *(_DWORD *)(v35 + 76 + 4 * (*(_DWORD *)(v35 + 72) == 0)) = 0;
          *(_DWORD *)(v35 + 100) = 0;
          int v39 = *(_DWORD *)(v35 + 76 + 4 * v38);
          if (v39)
          {
            uint64_t v40 = v35;
            if (vabdd_f64(*(double *)(v36 + 48), *(double *)(v35 + 48)) <= 2.22044605e-16)
            {
              uint64_t v40 = v35;
              if (vabdd_f64(*(double *)(v36 + 64), *(double *)(v35 + 64)) <= 2.22044605e-16)
              {
                uint64_t v40 = v35;
                if (*(double *)(v36 + 40) != v28)
                {
                  *(_DWORD *)(v37 + 4 * v38) = *(_DWORD *)(v36 + 76 + 4 * v38) ^ v39;
                  BOOL v41 = *(_DWORD *)(v35 + 72) == 0;
                  int v42 = *(_DWORD *)(v36 + 76 + 4 * (*(_DWORD *)(v35 + 72) == 0));
                  *(_DWORD *)(v35 + 100) = 1;
                  *(_DWORD *)(v37 + 4 * v41) = v42;
                  *(_DWORD *)(v36 + 76) = 0;
                  *(_DWORD *)(v36 + 80) = 0;
                  *(_DWORD *)(v36 + 100) = 2;
                  uint64_t v40 = v35;
                }
              }
            }
          }
          else
          {
            uint64_t v40 = v36;
          }
          uint64_t v35 = *(void *)(v35 + 136);
          uint64_t v36 = v40;
        }
        while (v35);
        if (v17)
        {
LABEL_61:
          uint64_t v272 = v23;
          uint64_t v43 = 0;
          uint64_t v44 = 0;
          double v45 = -1.79769313e308;
          uint64_t v46 = v17;
          int v47 = v245;
          while (1)
          {
            int v49 = *(_DWORD *)(v46 + 76);
            int v48 = *(_DWORD *)(v46 + 80);
            int v51 = *(_DWORD *)(v46 + 84);
            int v50 = *(_DWORD *)(v46 + 88);
            int v52 = v49 + 2 * v51;
            int v53 = v48 + 2 * v50;
            if (v52 | v53) {
              break;
            }
LABEL_172:
            uint64_t v46 = *(void *)(v46 + 136);
            if (!v46)
            {
              int v245 = v47;
              uint64_t v23 = v272;
              do
              {
                double v139 = *(double *)(v17 + 40);
                if (v139 == v28)
                {
                  uint64_t v140 = *(void *)(v17 + 128);
                  uint64_t v141 = *(void *)(v17 + 136);
                  uint64_t v142 = v141;
                  if (v140)
                  {
                    *(void *)(v140 + 136) = v141;
                    uint64_t v142 = v16;
                  }
                  if (v141) {
                    *(void *)(v141 + 128) = v140;
                  }
                  if (v140)
                  {
                    if (*(_DWORD *)(v17 + 104) == 1 && *(_DWORD *)(v140 + 104) == 2)
                    {
                      *(void *)(v140 + 120) = *(void *)(v17 + 120);
                      *(_DWORD *)(v140 + 104) = 0;
                      uint64_t v143 = *(void *)(v140 + 128);
                      if (v143)
                      {
                        if (*(_DWORD *)(v143 + 104) == 2) {
                          *(_DWORD *)(v140 + 104) = 1;
                        }
                      }
                    }
                  }
                  uint64_t v16 = v142;
                }
                else
                {
                  if (v139 == v25) {
                    double v144 = *(double *)(v17 + 32);
                  }
                  else {
                    double v144 = *(double *)(v17 + 16) + *(double *)(v17 + 64) * (v25 - *(double *)(v17 + 24));
                  }
                  *(double *)(v17 + 56) = v144;
                }
                uint64_t v17 = *(void *)(v17 + 136);
              }
              while (v17);
              uint64_t v277 = v16;
              uint64_t v17 = v16;
              goto LABEL_192;
            }
          }
          *(void *)(v46 + 92) = v274;
          if (v26 >= 2)
          {
            if (v26 == 2)
            {
              uint64_t v21 = HIDWORD(v274) ^ v274;
              uint64_t v22 = v21 ^ v49 ^ v48;
              uint64_t v19 = v274 ^ HIDWORD(v274) ^ (v43 != 0) ^ (v44 != 0);
              uint64_t v20 = v19 ^ v51 ^ v50;
              int v47 = 1;
            }
            else if (v26 == 3)
            {
              if (!v52 || (int v47 = 1, HIDWORD(v274)) && !v44)
              {
                if (!v53 || (int v47 = 1, v274) && !v43)
                {
                  if (v52) {
                    BOOL v54 = v53 == 0;
                  }
                  else {
                    BOOL v54 = 1;
                  }
                  int v47 = !v54 && v274 == HIDWORD(v274);
                }
              }
              uint64_t v21 = v274 != 0;
              uint64_t v22 = v274 != v49 || HIDWORD(v274) != v48;
              int v57 = v274 ^ (v43 != 0);
              int v58 = v44 != 0;
              if (v57) {
                BOOL v59 = 0;
              }
              else {
                BOOL v59 = HIDWORD(v274) == v58;
              }
              uint64_t v19 = !v59;
              int v60 = v50 ^ v58;
              BOOL v61 = v57 == v51 && v60 == HIDWORD(v274);
LABEL_132:
              uint64_t v20 = !v61;
            }
            LODWORD(v274) = v49 ^ v274;
            if (v52) {
              uint64_t v43 = TSDnext_h_state[6 * v43 - 2 + 2 * v52 + (int)v274];
            }
            HIDWORD(v274) ^= v48;
            if (v53) {
              uint64_t v44 = TSDnext_h_state[6 * v44 - 2 + 2 * v53 + HIDWORD(v274)];
            }
            if (v47)
            {
              int v47 = 1;
              double v70 = *(double *)(v46 + 48);
              switch(4 * v21 + 8 * v22 + 2 * v20 + v19)
              {
                case 1:
                  uint64_t v78 = v19;
                  uint64_t v79 = v22;
                  unsigned int v264 = v20;
                  uint64_t v80 = v21;
                  if (v70 != v45)
                  {
                    uint64_t v81 = (double *)gpc_malloc(0x18uLL);
                    *uint64_t v81 = v70;
                    v81[1] = v28;
                    uint64_t v82 = *(void *)(v272 + 32);
                    float v81[2] = *(double *)(v82 + 8);
                    *(void *)(v82 + 8) = v81;
                    double v45 = v70;
                  }
                  merge_right(v272, *(void *)(v46 + 120), v263);
                  uint64_t v272 = 0;
                  goto LABEL_170;
                case 2:
                  uint64_t v83 = *(void *)(v46 + 120);
                  uint64_t v84 = v21;
                  uint64_t v85 = v20;
                  uint64_t v86 = v22;
                  uint64_t v87 = v43;
                  uint64_t v88 = v19;
                  uint64_t v89 = (double *)gpc_malloc(0x18uLL);
                  uint64_t v19 = v88;
                  uint64_t v43 = v87;
                  uint64_t v22 = v86;
                  uint64_t v20 = v85;
                  uint64_t v21 = v84;
                  unsigned int v26 = a1;
                  *uint64_t v89 = v70;
                  v89[1] = v28;
                  uint64_t v90 = *(void *)(v83 + 32);
                  v89[2] = *(double *)(v90 + 8);
                  *(void *)(v90 + 8) = v89;
                  uint64_t v272 = *(void *)(v46 + 120);
                  goto LABEL_166;
                case 4:
                  uint64_t v91 = v272;
                  if (v70 == v45) {
                    goto LABEL_164;
                  }
                  uint64_t v92 = v21;
                  uint64_t v93 = v20;
                  uint64_t v94 = v22;
                  uint64_t v95 = v43;
                  uint64_t v96 = v19;
                  int v97 = (double *)gpc_malloc(0x18uLL);
                  uint64_t v19 = v96;
                  uint64_t v43 = v95;
                  uint64_t v22 = v94;
                  uint64_t v20 = v93;
                  uint64_t v21 = v92;
                  unsigned int v26 = a1;
                  *int v97 = v70;
                  v97[1] = v28;
                  v97[2] = 0.0;
                  uint64_t v98 = *(void *)(v272 + 32);
                  *(void *)(*(void *)(v98 + 16) + 16) = v97;
                  *(void *)(v98 + 16) = v97;
                  goto LABEL_163;
                case 5:
                  if (*(double *)(v46 + 24) == v28)
                  {
                    uint64_t v99 = *(void *)(v46 + 120);
                    uint64_t v100 = v21;
                    uint64_t v101 = v20;
                    uint64_t v102 = v22;
                    uint64_t v103 = v43;
                    uint64_t v104 = v19;
                    uint64_t v105 = (double *)gpc_malloc(0x18uLL);
                    uint64_t v19 = v104;
                    uint64_t v43 = v103;
                    uint64_t v22 = v102;
                    uint64_t v20 = v101;
                    uint64_t v21 = v100;
                    unsigned int v26 = a1;
                    *uint64_t v105 = v70;
                    v105[1] = v28;
                    v105[2] = 0.0;
                    uint64_t v106 = *(void *)(v99 + 32);
                    *(void *)(*(void *)(v106 + 16) + 16) = v105;
                    *(void *)(v106 + 16) = v105;
                  }
                  goto LABEL_160;
                case 6:
                  uint64_t v78 = v19;
                  uint64_t v79 = v22;
                  unsigned int v264 = v20;
                  unsigned int v251 = v21;
                  if (v70 != v45)
                  {
                    uint64_t v107 = (double *)gpc_malloc(0x18uLL);
                    *uint64_t v107 = v70;
                    v107[1] = v28;
                    v107[2] = 0.0;
                    uint64_t v108 = *(void *)(v272 + 32);
                    *(void *)(*(void *)(v108 + 16) + 16) = v107;
                    *(void *)(v108 + 16) = v107;
                    double v45 = v70;
                  }
                  uint64_t v109 = v263;
                  merge_left(v272, *(void *)(v46 + 120), v263);
                  goto LABEL_157;
                case 7:
                case 8:
                  uint64_t v71 = v21;
                  uint64_t v72 = v20;
                  uint64_t v73 = v22;
                  uint64_t v74 = v43;
                  uint64_t v75 = v19;
                  uint64_t v76 = gpc_malloc(0x28uLL);
                  uint64_t v77 = (double *)gpc_malloc(0x18uLL);
                  uint64_t v19 = v75;
                  uint64_t v43 = v74;
                  uint64_t v22 = v73;
                  uint64_t v20 = v72;
                  uint64_t v21 = v71;
                  unsigned int v26 = a1;
                  *uint64_t v77 = v70;
                  v77[1] = v28;
                  v77[2] = 0.0;
                  int v47 = 1;
                  *(_DWORD *)uint64_t v76 = 1;
                  v76[3] = v263;
                  v76[4] = v76;
                  v76[1] = v77;
                  v76[2] = v77;
                  uint64_t v263 = (uint64_t)v76;
                  double v45 = v70;
                  uint64_t v272 = (uint64_t)v76;
                  *(void *)(v46 + 112) = v76;
                  goto LABEL_172;
                case 9:
                  uint64_t v78 = v19;
                  uint64_t v79 = v22;
                  unsigned int v264 = v20;
                  unsigned int v251 = v21;
                  if (v70 != v45)
                  {
                    int v110 = (double *)gpc_malloc(0x18uLL);
                    *int v110 = v70;
                    v110[1] = v28;
                    uint64_t v111 = *(void *)(v272 + 32);
                    v110[2] = *(double *)(v111 + 8);
                    *(void *)(v111 + 8) = v110;
                    double v45 = v70;
                  }
                  uint64_t v109 = v263;
                  merge_right(v272, *(void *)(v46 + 120), v263);
LABEL_157:
                  *(void *)(v46 + 120) = 0;
                  int v112 = gpc_malloc(0x28uLL);
                  uint64_t v113 = (double *)gpc_malloc(0x18uLL);
                  *uint64_t v113 = v70;
                  v113[1] = v28;
                  v113[2] = 0.0;
                  int v47 = 1;
                  *(_DWORD *)int v112 = 1;
                  v112[3] = v109;
                  v112[4] = v112;
                  v112[1] = v113;
                  v112[2] = v113;
                  uint64_t v263 = (uint64_t)v112;
                  uint64_t v272 = (uint64_t)v112;
                  *(void *)(v46 + 112) = v112;
                  unsigned int v26 = a1;
                  uint64_t v21 = v251;
                  goto LABEL_171;
                case 10:
                  if (*(double *)(v46 + 24) == v28)
                  {
                    uint64_t v114 = *(void *)(v46 + 120);
                    uint64_t v115 = v21;
                    uint64_t v116 = v20;
                    uint64_t v117 = v22;
                    uint64_t v118 = v43;
                    uint64_t v119 = v19;
                    int v120 = (double *)gpc_malloc(0x18uLL);
                    uint64_t v19 = v119;
                    uint64_t v43 = v118;
                    uint64_t v22 = v117;
                    uint64_t v20 = v116;
                    uint64_t v21 = v115;
                    unsigned int v26 = a1;
                    *int v120 = v70;
                    v120[1] = v28;
                    uint64_t v121 = *(void *)(v114 + 32);
                    v120[2] = *(double *)(v121 + 8);
                    *(void *)(v121 + 8) = v120;
                  }
LABEL_160:
                  *(void *)(v46 + 112) = *(void *)(v46 + 120);
                  goto LABEL_166;
                case 11:
                  uint64_t v91 = v272;
                  if (v70 == v45) {
                    goto LABEL_164;
                  }
                  uint64_t v122 = v21;
                  uint64_t v123 = v20;
                  uint64_t v124 = v22;
                  uint64_t v125 = v43;
                  uint64_t v126 = v19;
                  long long v127 = (double *)gpc_malloc(0x18uLL);
                  uint64_t v19 = v126;
                  uint64_t v43 = v125;
                  uint64_t v22 = v124;
                  uint64_t v20 = v123;
                  uint64_t v21 = v122;
                  unsigned int v26 = a1;
                  *long long v127 = v70;
                  v127[1] = v28;
                  uint64_t v128 = *(void *)(v272 + 32);
                  v127[2] = *(double *)(v128 + 8);
                  *(void *)(v128 + 8) = v127;
LABEL_163:
                  double v45 = v70;
LABEL_164:
                  *(void *)(v46 + 112) = v91;
                  int v47 = 1;
                  uint64_t v272 = 0;
                  break;
                case 13:
                  uint64_t v129 = *(void *)(v46 + 120);
                  uint64_t v130 = v21;
                  uint64_t v131 = v20;
                  uint64_t v132 = v22;
                  uint64_t v133 = v43;
                  uint64_t v134 = v19;
                  long long v135 = (double *)gpc_malloc(0x18uLL);
                  uint64_t v19 = v134;
                  uint64_t v43 = v133;
                  uint64_t v22 = v132;
                  uint64_t v20 = v131;
                  uint64_t v21 = v130;
                  unsigned int v26 = a1;
                  *long long v135 = v70;
                  v135[1] = v28;
                  v135[2] = 0.0;
                  uint64_t v136 = *(void *)(v129 + 32);
                  *(void *)(*(void *)(v136 + 16) + 16) = v135;
                  *(void *)(v136 + 16) = v135;
                  uint64_t v272 = *(void *)(v46 + 120);
                  *(void *)(v46 + 120) = 0;
LABEL_166:
                  int v47 = 1;
                  double v45 = v70;
                  break;
                case 14:
                  uint64_t v78 = v19;
                  uint64_t v79 = v22;
                  unsigned int v264 = v20;
                  uint64_t v80 = v21;
                  if (v70 != v45)
                  {
                    long long v137 = (double *)gpc_malloc(0x18uLL);
                    *long long v137 = v70;
                    v137[1] = v28;
                    v137[2] = 0.0;
                    uint64_t v138 = *(void *)(v272 + 32);
                    *(void *)(*(void *)(v138 + 16) + 16) = v137;
                    *(void *)(v138 + 16) = v137;
                    double v45 = v70;
                  }
                  merge_left(v272, *(void *)(v46 + 120), v263);
                  uint64_t v272 = 0;
                  *(void *)(v46 + 120) = 0;
LABEL_170:
                  int v47 = 1;
                  unsigned int v26 = a1;
                  uint64_t v21 = v80;
LABEL_171:
                  uint64_t v20 = v264;
                  uint64_t v22 = v79;
                  uint64_t v19 = v78;
                  break;
                default:
                  goto LABEL_172;
              }
            }
            goto LABEL_172;
          }
          if (!v52 || (int v47 = 1, !HIDWORD(v274)) && !v44)
          {
            if (!v53 || (int v47 = 1, !v274) && !v43)
            {
              if (v52) {
                BOOL v62 = v53 == 0;
              }
              else {
                BOOL v62 = 1;
              }
              int v47 = !v62 && v274 == HIDWORD(v274);
            }
          }
          if (v274) {
            BOOL v64 = HIDWORD(v274) == 0;
          }
          else {
            BOOL v64 = 1;
          }
          uint64_t v21 = !v64;
          uint64_t v22 = v274 != v49 && HIDWORD(v274) != v48;
          int v66 = v274 ^ (v43 != 0);
          int v67 = v44 != 0;
          if (v66) {
            BOOL v68 = HIDWORD(v274) == v67;
          }
          else {
            BOOL v68 = 1;
          }
          uint64_t v19 = !v68;
          int v69 = v50 ^ v67;
          BOOL v61 = v66 == v51 || v69 == HIDWORD(v274);
          goto LABEL_132;
        }
LABEL_192:
        int v13 = v275;
        int v18 = HIDWORD(v275);
        if (SHIDWORD(v275) < (int)v275)
        {
          uint64_t v145 = v19;
          uint64_t v146 = v22;
          uint64_t v147 = v20;
          uint64_t v148 = v21;
          uint64_t v273 = v23;
          build_intersection_table((double **)&v278, v16, v24);
          long long v149 = v278;
          if (v278)
          {
            unsigned int v26 = a1;
            uint64_t v21 = v148;
            uint64_t v20 = v147;
            uint64_t v22 = v146;
            uint64_t v19 = v145;
            while (1)
            {
              uint64_t v151 = *v149;
              uint64_t v150 = v149[1];
              int v152 = *(_DWORD *)(*v149 + 76);
              if (v152)
              {
                int v153 = *(_DWORD *)(v150 + 76);
                if (v153)
                {
                  long long v154 = (uint64_t *)(v151 + 112);
                  uint64_t v155 = *(void *)(v151 + 112);
                  long long v156 = (uint64_t *)(v150 + 112);
                  uint64_t v157 = *(void *)(v150 + 112);
                  long long v158 = *((_OWORD *)v149 + 1);
                  if (*(_DWORD *)(v151 + 92)) {
                    goto LABEL_198;
                  }
                  int v160 = 1;
                }
                else
                {
                  if (!*(_DWORD *)(v150 + 80)) {
                    goto LABEL_275;
                  }
                  int v153 = 0;
                  long long v154 = (uint64_t *)(v151 + 112);
                  uint64_t v155 = *(void *)(v151 + 112);
                  long long v156 = (uint64_t *)(v150 + 112);
                  uint64_t v157 = *(void *)(v150 + 112);
                  long long v158 = *((_OWORD *)v149 + 1);
                  int v160 = *(_DWORD *)(v151 + 92) == 0;
                }
              }
              else
              {
                if (!*(_DWORD *)(v151 + 80)) {
                  goto LABEL_275;
                }
                int v153 = *(_DWORD *)(v150 + 76);
                if (v153)
                {
                  long long v154 = (uint64_t *)(v151 + 112);
                  uint64_t v155 = *(void *)(v151 + 112);
                  long long v156 = (uint64_t *)(v150 + 112);
                  uint64_t v157 = *(void *)(v150 + 112);
                  long long v158 = *((_OWORD *)v149 + 1);
                  int v159 = *(_DWORD *)(v150 + 92);
                  goto LABEL_202;
                }
                if (!*(_DWORD *)(v150 + 80)) {
                  goto LABEL_275;
                }
                long long v154 = (uint64_t *)(v151 + 112);
                uint64_t v155 = *(void *)(v151 + 112);
                long long v156 = (uint64_t *)(v150 + 112);
                uint64_t v157 = *(void *)(v150 + 112);
                long long v158 = *((_OWORD *)v149 + 1);
                int v153 = *(_DWORD *)(v151 + 92);
                if (v153)
                {
                  int v153 = 0;
LABEL_198:
                  int v159 = *(_DWORD *)(v150 + 92);
LABEL_202:
                  int v160 = v159 != 0;
                  goto LABEL_206;
                }
                int v160 = 0;
              }
LABEL_206:
              int v161 = *(_DWORD *)(v151 + 80);
              if (v161)
              {
                if (!*(_DWORD *)(v151 + 96))
                {
                  int v162 = 1;
                  goto LABEL_214;
                }
                int v162 = *(_DWORD *)(v150 + 80);
                if (!v162) {
                  goto LABEL_214;
                }
              }
              else if (!*(_DWORD *)(v150 + 80))
              {
                int v162 = *(_DWORD *)(v151 + 96);
                if (!v162) {
                  goto LABEL_214;
                }
              }
              int v162 = *(_DWORD *)(v150 + 96) != 0;
LABEL_214:
              if (v26 < 2)
              {
                uint64_t v20 = v153 != v160 && *(_DWORD *)(v150 + 80) != v162;
                uint64_t v21 = v152 != v160 && v161 != v162;
                uint64_t v22 = (v153 ^ v152) != v160 && (*(_DWORD *)(v150 + 80) ^ v161) != v162;
                uint64_t v19 = v160 & v162;
              }
              else if (v26 == 2)
              {
                uint64_t v19 = v162 ^ v160;
                int v163 = v153 ^ v160;
                int v164 = *(_DWORD *)(v150 + 80) ^ v162;
                uint64_t v20 = v164 ^ v163;
                int v165 = v161 ^ v152;
                uint64_t v21 = v165 ^ v160 ^ v162;
                uint64_t v22 = v165 ^ v163 ^ v164;
              }
              else if (v26 == 3)
              {
                uint64_t v20 = v153 != v160 || *(_DWORD *)(v150 + 80) != v162;
                uint64_t v21 = v152 != v160 || v161 != v162;
                uint64_t v22 = (v153 ^ v152) != v160 || (*(_DWORD *)(v150 + 80) ^ v161) != v162;
                uint64_t v19 = v160 | v162;
              }
              double v168 = v28 + *((double *)&v158 + 1);
              switch(4 * v21 + 8 * v22 + 2 * v20 + v19)
              {
                case 1:
                  if (v155 && v157)
                  {
                    unsigned int v249 = v22;
                    unsigned int v253 = v21;
                    unsigned int v265 = v20;
                    unsigned int v247 = v19;
                    uint64_t v256 = v158;
                    uint64_t v174 = (double *)gpc_malloc(0x18uLL);
                    *(void *)uint64_t v174 = v256;
                    v174[1] = v168;
                    uint64_t v175 = *(void *)(v155 + 32);
                    v174[2] = *(double *)(v175 + 8);
                    *(void *)(v175 + 8) = v174;
                    merge_right(v155, v157, v263);
                    goto LABEL_273;
                  }
                  goto LABEL_275;
                case 2:
                  if (v157)
                  {
                    uint64_t v176 = v21;
                    unsigned int v266 = v20;
                    uint64_t v177 = v22;
                    uint64_t v178 = v19;
                    uint64_t v257 = v158;
                    double v179 = (double *)gpc_malloc(0x18uLL);
                    uint64_t v19 = v178;
                    uint64_t v22 = v177;
                    uint64_t v20 = v266;
                    unsigned int v26 = a1;
                    uint64_t v21 = v176;
                    *(void *)double v179 = v257;
                    v179[1] = v168;
                    uint64_t v180 = *(void *)(v157 + 32);
                    v179[2] = *(double *)(v180 + 8);
                    *(void *)(v180 + 8) = v179;
                    goto LABEL_269;
                  }
                  goto LABEL_275;
                case 4:
                  if (v155)
                  {
                    uint64_t v181 = v21;
                    unsigned int v267 = v20;
                    uint64_t v182 = v22;
                    uint64_t v183 = v19;
                    uint64_t v258 = v158;
                    uint64_t v184 = (double *)gpc_malloc(0x18uLL);
                    uint64_t v19 = v183;
                    uint64_t v22 = v182;
                    uint64_t v20 = v267;
                    unsigned int v26 = a1;
                    uint64_t v21 = v181;
                    *(void *)uint64_t v184 = v258;
                    v184[1] = v168;
                    v184[2] = 0.0;
                    uint64_t v185 = *(void *)(v155 + 32);
                    *(void *)(*(void *)(v185 + 16) + 16) = v184;
                    *(void *)(v185 + 16) = v184;
                    goto LABEL_266;
                  }
                  goto LABEL_275;
                case 6:
                  if (v155 && v157)
                  {
                    unsigned int v250 = v22;
                    unsigned int v254 = v21;
                    unsigned int v268 = v20;
                    unsigned int v248 = v19;
                    uint64_t v259 = v158;
                    int v186 = (double *)gpc_malloc(0x18uLL);
                    *(void *)int v186 = v259;
                    v186[1] = v168;
                    v186[2] = 0.0;
                    uint64_t v187 = *(void *)(v155 + 32);
                    *(void *)(*(void *)(v187 + 16) + 16) = v186;
                    *(void *)(v187 + 16) = v186;
                    uint64_t v188 = v157;
                    uint64_t v189 = v263;
                    merge_left(v155, v188, v263);
                    goto LABEL_262;
                  }
                  goto LABEL_275;
                case 7:
                case 8:
                  unsigned int v252 = v21;
                  uint64_t v169 = v20;
                  uint64_t v170 = v22;
                  uint64_t v171 = v19;
                  uint64_t v255 = v158;
                  int v172 = gpc_malloc(0x28uLL);
                  uint64_t v173 = (double *)gpc_malloc(0x18uLL);
                  uint64_t v19 = v171;
                  uint64_t v22 = v170;
                  uint64_t v20 = v169;
                  uint64_t v21 = v252;
                  unsigned int v26 = a1;
                  *(void *)uint64_t v173 = v255;
                  v173[1] = v168;
                  v173[2] = 0.0;
                  *(_DWORD *)int v172 = 1;
                  v172[3] = v263;
                  v172[4] = v172;
                  goto LABEL_263;
                case 9:
                  if (v155 && v157)
                  {
                    unsigned int v250 = v22;
                    unsigned int v254 = v21;
                    unsigned int v268 = v20;
                    unsigned int v248 = v19;
                    uint64_t v259 = v158;
                    int v190 = (double *)gpc_malloc(0x18uLL);
                    *(void *)int v190 = v259;
                    v190[1] = v168;
                    uint64_t v191 = *(void *)(v155 + 32);
                    v190[2] = *(double *)(v191 + 8);
                    *(void *)(v191 + 8) = v190;
                    uint64_t v192 = v157;
                    uint64_t v189 = v263;
                    merge_right(v155, v192, v263);
LABEL_262:
                    int v172 = gpc_malloc(0x28uLL);
                    uint64_t v173 = (double *)gpc_malloc(0x18uLL);
                    uint64_t v19 = v248;
                    uint64_t v22 = v250;
                    uint64_t v20 = v268;
                    unsigned int v26 = a1;
                    uint64_t v21 = v254;
                    *(void *)uint64_t v173 = v259;
                    v173[1] = v168;
                    v173[2] = 0.0;
                    *(_DWORD *)int v172 = 1;
                    v172[3] = v189;
                    v172[4] = v172;
LABEL_263:
                    v172[1] = v173;
                    v172[2] = v173;
                    *long long v154 = (uint64_t)v172;
                    uint64_t v263 = (uint64_t)v172;
                    *long long v156 = (uint64_t)v172;
                  }
                  goto LABEL_275;
                case 11:
                  if (v155)
                  {
                    uint64_t v193 = v21;
                    unsigned int v269 = v20;
                    uint64_t v194 = v22;
                    uint64_t v195 = v19;
                    uint64_t v260 = v158;
                    double v196 = (double *)gpc_malloc(0x18uLL);
                    uint64_t v19 = v195;
                    uint64_t v22 = v194;
                    uint64_t v20 = v269;
                    unsigned int v26 = a1;
                    uint64_t v21 = v193;
                    *(void *)double v196 = v260;
                    v196[1] = v168;
                    uint64_t v197 = *(void *)(v155 + 32);
                    v196[2] = *(double *)(v197 + 8);
                    *(void *)(v197 + 8) = v196;
LABEL_266:
                    *long long v156 = v155;
                    *long long v154 = 0;
                  }
                  goto LABEL_275;
                case 13:
                  if (!v157) {
                    goto LABEL_275;
                  }
                  uint64_t v198 = v21;
                  unsigned int v270 = v20;
                  uint64_t v199 = v22;
                  uint64_t v200 = v19;
                  uint64_t v261 = v158;
                  int v201 = (double *)gpc_malloc(0x18uLL);
                  uint64_t v19 = v200;
                  uint64_t v22 = v199;
                  uint64_t v20 = v270;
                  unsigned int v26 = a1;
                  uint64_t v21 = v198;
                  *(void *)int v201 = v261;
                  v201[1] = v168;
                  v201[2] = 0.0;
                  uint64_t v202 = *(void *)(v157 + 32);
                  *(void *)(*(void *)(v202 + 16) + 16) = v201;
                  *(void *)(v202 + 16) = v201;
LABEL_269:
                  *long long v154 = v157;
                  break;
                case 14:
                  if (!v155 || !v157) {
                    goto LABEL_275;
                  }
                  unsigned int v249 = v22;
                  unsigned int v253 = v21;
                  unsigned int v265 = v20;
                  unsigned int v247 = v19;
                  uint64_t v262 = v158;
                  double v203 = (double *)gpc_malloc(0x18uLL);
                  *(void *)double v203 = v262;
                  v203[1] = v168;
                  v203[2] = 0.0;
                  uint64_t v204 = *(void *)(v155 + 32);
                  *(void *)(*(void *)(v204 + 16) + 16) = v203;
                  *(void *)(v204 + 16) = v203;
                  merge_left(v155, v157, v263);
LABEL_273:
                  uint64_t v19 = v247;
                  uint64_t v22 = v249;
                  uint64_t v20 = v265;
                  unsigned int v26 = a1;
                  uint64_t v21 = v253;
                  *long long v154 = 0;
                  break;
                default:
                  goto LABEL_275;
              }
              *long long v156 = 0;
LABEL_275:
              if (*(_DWORD *)(v151 + 76)) {
                *(_DWORD *)(v150 + 92) = *(_DWORD *)(v150 + 92) == 0;
              }
              if (*(_DWORD *)(v150 + 76)) {
                *(_DWORD *)(v151 + 92) = *(_DWORD *)(v151 + 92) == 0;
              }
              if (*(_DWORD *)(v151 + 80)) {
                *(_DWORD *)(v150 + 96) = *(_DWORD *)(v150 + 96) == 0;
              }
              if (*(_DWORD *)(v150 + 80)) {
                *(_DWORD *)(v151 + 96) = *(_DWORD *)(v151 + 96) == 0;
              }
              uint64_t v205 = *(void *)(v151 + 128);
              uint64_t v206 = *(void *)(v150 + 136);
              if (v206) {
                *(void *)(v206 + 128) = v151;
              }
              if (*(_DWORD *)(v151 + 100) == 1)
              {
                while (1)
                {
                  uint64_t v205 = *(void *)(v205 + 128);
                  if (!v205) {
                    break;
                  }
                  if (*(_DWORD *)(v205 + 100) != 2) {
                    goto LABEL_290;
                  }
                }
LABEL_291:
                uint64_t v205 = 0;
                *(void *)(v16 + 128) = v150;
                *(void *)(v150 + 136) = v16;
                uint64_t v208 = *(void *)(v151 + 136);
                uint64_t v209 = v16;
                uint64_t v16 = v208;
                goto LABEL_292;
              }
              if (!v205) {
                goto LABEL_291;
              }
LABEL_290:
              uint64_t v207 = *(void *)(v205 + 136);
              *(void *)(v207 + 128) = v150;
              *(void *)(v150 + 136) = v207;
              *(void *)(v205 + 136) = *(void *)(v151 + 136);
              uint64_t v208 = *(void *)(v151 + 136);
              uint64_t v209 = *(void *)(v150 + 136);
LABEL_292:
              *(void *)(v208 + 128) = v205;
              *(void *)(v209 + 128) = v150;
              *(void *)(v151 + 136) = v206;
              long long v149 = (void *)v149[4];
              if (!v149) {
                goto LABEL_296;
              }
            }
          }
          unsigned int v26 = a1;
          uint64_t v21 = v148;
          uint64_t v20 = v147;
          uint64_t v22 = v146;
          uint64_t v19 = v145;
LABEL_296:
          if (v16)
          {
            uint64_t v210 = v16;
            uint64_t v23 = v273;
            do
            {
              uint64_t v211 = *(void *)(v16 + 136);
              uint64_t v212 = *(void *)(v16 + 152);
              uint64_t v213 = *(void *)(v16 + 112);
              if (*(double *)(v16 + 40) != v25 || v212 == 0)
              {
                *(void *)(v16 + 120) = v213;
                *(_DWORD *)(v16 + 104) = *(_DWORD *)(v16 + 100);
                *(void *)(v16 + 84) = *(void *)(v16 + 76);
                *(void *)(v16 + 48) = *(void *)(v16 + 56);
                uint64_t v17 = v210;
              }
              else
              {
                *(void *)(v212 + 120) = v213;
                *(_DWORD *)(v212 + 104) = *(_DWORD *)(v16 + 100);
                *(_DWORD *)(v212 + 84) = *(_DWORD *)(v16 + 76);
                *(_DWORD *)(v212 + 88) = *(_DWORD *)(v16 + 80);
                uint64_t v215 = *(void *)(v16 + 128);
                uint64_t v17 = v212;
                if (v215)
                {
                  *(void *)(v215 + 136) = v212;
                  uint64_t v17 = v210;
                }
                if (v211) {
                  *(void *)(v211 + 128) = v212;
                }
                *(void *)(v212 + 128) = v215;
                *(void *)(v212 + 136) = v211;
                uint64_t v210 = v17;
              }
              *(void *)(v16 + 112) = 0;
              uint64_t v16 = v211;
            }
            while (v211);
          }
          else
          {
            uint64_t v17 = 0;
            uint64_t v23 = v273;
          }
          uint64_t v277 = v17;
          int v13 = v275;
          int v18 = HIDWORD(v275);
          uint64_t v16 = v17;
        }
      }
      while (v18 < v13);
      uint64_t v4 = (uint64_t)v241;
      uint64_t v216 = v242;
      *((void *)v241 + 1) = 0;
      *((void *)v241 + 2) = 0;
      uint64_t v217 = v243;
      uint64_t v218 = (void *)v263;
      if (v263)
      {
        int v219 = 0;
        uint64_t v220 = v263;
        while (1)
        {
          if (*(_DWORD *)v220)
          {
            uint64_t v221 = *(void **)(*(void *)(v220 + 32) + 8);
            if (!v221) {
              goto LABEL_323;
            }
            unsigned int v222 = -1;
            uint64_t v223 = *(void *)(*(void *)(v220 + 32) + 8);
            do
            {
              uint64_t v223 = *(void *)(v223 + 16);
              ++v222;
            }
            while (v223);
            if (v222 <= 1)
            {
              do
              {
                uint64_t v224 = (void *)v221[2];
                gpc_free(v221);
                uint64_t v221 = v224;
              }
              while (v224);
LABEL_323:
              *(_DWORD *)uint64_t v220 = 0;
              goto LABEL_324;
            }
            *(_DWORD *)uint64_t v220 = v222 + 1;
            ++v219;
          }
LABEL_324:
          uint64_t v220 = *(void *)(v220 + 24);
          if (!v220)
          {
            *int v241 = v219;
            if (v219 >= 1)
            {
              *((void *)v241 + 1) = gpc_malloc(4 * v219);
              uint64_t v225 = *v241;
              if (v225) {
                double v226 = gpc_malloc(16 * v225);
              }
              else {
                double v226 = 0;
              }
              int v227 = 0;
              *((void *)v241 + 2) = v226;
              do
              {
                int32x4_t v228 = (void *)v218[3];
                if (*(_DWORD *)v218)
                {
                  uint64_t v229 = v218[4];
                  *(_DWORD *)(*((void *)v241 + 1) + 4 * v227) = *(_DWORD *)(v229 + 4);
                  uint64_t v230 = *(int *)v218;
                  uint64_t v231 = *((void *)v241 + 2);
                  *(_DWORD *)(v231 + 16 * v227) = v230;
                  if (v230)
                  {
                    int v232 = gpc_malloc(16 * v230);
                    uint64_t v233 = *((void *)v241 + 2) + 16 * v227;
                    *(void *)(v233 + 8) = v232;
                    LODWORD(v230) = *(_DWORD *)v233;
                    uint64_t v229 = v218[4];
                  }
                  else
                  {
                    *(void *)(v231 + 16 * v227 + 8) = 0;
                  }
                  double v234 = *(void **)(v229 + 8);
                  if (v234)
                  {
                    uint64_t v235 = 16 * (int)v230 - 16;
                    do
                    {
                      double v236 = (void *)v234[2];
                      *(_OWORD *)(*(void *)(*((void *)v241 + 2) + 16 * v227 + 8) + v235) = *(_OWORD *)v234;
                      gpc_free(v234);
                      v235 -= 16;
                      double v234 = v236;
                    }
                    while (v236);
                  }
                  ++v227;
                }
                gpc_free(v218);
                uint64_t v218 = v228;
              }
              while (v228);
            }
LABEL_341:
            clean_polygon((int *)v4);
            int32x4_t v237 = v278;
            if (v278)
            {
              do
              {
                int32x4_t v238 = (void *)v237[4];
                gpc_free(v237);
                int32x4_t v237 = v238;
              }
              while (v238);
            }
            int v239 = v276;
            if (v276)
            {
              do
              {
                uint64_t v240 = (void *)v239[2];
                gpc_free(v239);
                int v239 = v240;
              }
              while (v240);
            }
            if (v216) {
              gpc_free(v216);
            }
            if (v217) {
              gpc_free(v217);
            }
            uint64_t v15 = v244;
            if (v244)
            {
LABEL_350:
              gpc_free(v15);
            }
            return;
          }
        }
      }
    }
    *(_DWORD *)uint64_t v4 = 0;
    goto LABEL_341;
  }
  if (a2 == (unsigned int *)v4) {
    TSDgpc_free_polygon((uint64_t)a2);
  }
  if (a3 == (int *)v4) {
    TSDgpc_free_polygon(v4);
  }
  *(_DWORD *)uint64_t v4 = 0;
  *(void *)(v4 + 8) = 0;
  *(void *)(v4 + 16) = 0;
  if (v11) {
    gpc_free(v11);
  }
  if (v12)
  {
    uint64_t v15 = v12;
    goto LABEL_350;
  }
}

void minimax_test(uint64_t a1, int *a2, int a3)
{
  contour_bboxes = create_contour_bboxes((int *)a1);
  int v7 = create_contour_bboxes(a2);
  int v8 = *(_DWORD *)a1;
  LODWORD(v9) = *a2;
  int v10 = *a2 * *(_DWORD *)a1;
  if (v10)
  {
    long long v11 = gpc_malloc(4 * v10);
    int v8 = *(_DWORD *)a1;
    LODWORD(v9) = *a2;
  }
  else
  {
    long long v11 = 0;
  }
  if (v8 >= 1)
  {
    for (uint64_t i = 0; i < v8; ++i)
    {
      if ((int)v9 >= 1)
      {
        uint64_t v13 = 0;
        uint64_t v14 = (double *)&contour_bboxes[32 * i];
        double v15 = v14[2];
        uint64_t v16 = (double *)(v7 + 16);
        do
        {
          if (v15 >= *(v16 - 2) && *v14 <= *v16)
          {
            BOOL v18 = v14[3] < *(v16 - 1) || v14[1] > v16[1];
            int v17 = !v18;
          }
          else
          {
            int v17 = 0;
          }
          *((_DWORD *)v11 + (int)i + *(_DWORD *)a1 * (int)v13++) = v17;
          uint64_t v9 = *a2;
          v16 += 4;
        }
        while (v13 < v9);
        int v8 = *(_DWORD *)a1;
      }
    }
  }
  if ((int)v9 >= 1)
  {
    uint64_t v19 = 0;
    uint64_t v20 = (int *)v11;
    do
    {
      uint64_t v21 = v20;
      uint64_t v22 = v8 & ~(v8 >> 31);
      while (v22)
      {
        int v23 = *v21++;
        --v22;
        if (v23) {
          goto LABEL_25;
        }
      }
      *(_DWORD *)(*((void *)a2 + 2) + 16 * v19) = -*(_DWORD *)(*((void *)a2 + 2) + 16 * v19);
LABEL_25:
      ++v19;
      v20 += v8;
    }
    while (v19 != v9);
  }
  if (a3 == 1 && v8 >= 1)
  {
    uint64_t v24 = 0;
    uint64_t v25 = v8;
    uint64_t v26 = (v9 & ~((int)v9 >> 31)) + 1;
    uint64_t v27 = 4 * v8;
    double v28 = (int *)v11;
    do
    {
      long long v29 = v28;
      uint64_t v30 = v26;
      while (--v30)
      {
        int v31 = *v29;
        long long v29 = (int *)((char *)v29 + v27);
        if (v31) {
          goto LABEL_34;
        }
      }
      *(_DWORD *)(*(void *)(a1 + 16) + 16 * v24) = -*(_DWORD *)(*(void *)(a1 + 16) + 16 * v24);
LABEL_34:
      ++v24;
      ++v28;
    }
    while (v24 != v25);
  }
  if (contour_bboxes) {
    gpc_free(contour_bboxes);
  }
  if (v7) {
    gpc_free(v7);
  }
  if (v11)
  {
    gpc_free(v11);
  }
}

double *build_lmt(double **a1, double *a2, _DWORD *a3, unsigned int *a4, int a5, int a6)
{
  uint64_t v6 = *a4;
  if ((int)v6 < 1) {
    return 0;
  }
  uint64_t v9 = (int *)a4;
  uint64_t v10 = 0;
  int v11 = 0;
  do
  {
    uint64_t v12 = (uint64_t *)(*((void *)a4 + 2) + 16 * v10);
    uint64_t v13 = *v12;
    int v14 = *v12 - 1;
    if ((int)*v12 < 1)
    {
      int v16 = 0;
    }
    else
    {
      uint64_t v15 = 0;
      int v16 = 0;
      uint64_t v17 = v12[1];
      BOOL v18 = (double *)(v17 + 8);
      do
      {
        uint64_t v19 = v15 + 1;
        if (*(double *)(v17 + 16 * ((v14 + (int)v15) % (int)v13) + 8) != *v18
          || (v13 - 1 != v15 ? (uint64_t v20 = v15 + 1) : (uint64_t v20 = 0), *(double *)(v17 + 16 * v20 + 8) != *v18))
        {
          ++v16;
        }
        v18 += 2;
        uint64_t v15 = v19;
      }
      while (v13 != v19);
    }
    v11 += v16;
    ++v10;
  }
  while (v10 != v6);
  if (v11)
  {
    uint64_t v21 = (double *)gpc_malloc(168 * v11);
    LODWORD(v6) = *v9;
  }
  else
  {
    uint64_t v21 = 0;
  }
  if ((int)v6 >= 1)
  {
    uint64_t v22 = 0;
    int v23 = 0;
    BOOL v24 = a6 == 0;
    long long v25 = 0uLL;
    uint64_t v86 = v9;
    uint64_t v26 = a3;
    do
    {
      uint64_t v27 = *((void *)v9 + 2);
      double v28 = (_DWORD *)(v27 + 16 * v22);
      LODWORD(v29) = *v28;
      int v89 = v23;
      if ((*v28 & 0x80000000) != 0)
      {
        *double v28 = -(int)v29;
      }
      else if (v29)
      {
        uint64_t v30 = 0;
        int v31 = 0;
        do
        {
          uint64_t v32 = *(void *)(v27 + 16 * v22 + 8);
          double v33 = *(double *)(v32 + 16 * v30 + 8);
          if (*(double *)(v32 + 16 * (((int)v30 + (int)v29 - 1) % (int)v29) + 8) == v33
            && *(double *)(v32 + 16 * (((int)v30 + 1) % (int)v29) + 8) == v33)
          {
            ++v30;
          }
          else
          {
            uint64_t v34 = &v21[21 * v31];
            *uint64_t v34 = *(double *)(v32 + 16 * v30);
            v34[1] = v33;
            uint64_t v35 = a2;
            while (1)
            {
              uint64_t v36 = *(double **)v35;
              if (!*(void *)v35) {
                break;
              }
              if (*v36 <= v33)
              {
                if (*v36 >= v33) {
                  goto LABEL_33;
                }
                uint64_t v35 = v36 + 2;
              }
              else
              {
                uint64_t v35 = v36 + 1;
              }
            }
            uint64_t v37 = (double *)gpc_malloc(0x18uLL);
            long long v25 = 0uLL;
            *(void *)uint64_t v35 = v37;
            *uint64_t v37 = v33;
            v37[1] = 0.0;
            *(void *)(*(void *)v35 + 16) = 0;
            ++*v26;
            uint64_t v27 = *((void *)v9 + 2);
LABEL_33:
            ++v31;
            ++v30;
          }
          uint64_t v29 = *(int *)(v27 + 16 * v22);
        }
        while (v30 < v29);
        int v38 = v31 - 1;
        if (v31 >= 1)
        {
          uint64_t v39 = 0;
          do
          {
            int v40 = v39;
            double v41 = v21[21 * ((v38 + (int)v39) % v31) + 1];
            double v42 = v21[21 * v39++ + 1];
            if (v41 >= v42)
            {
              int v43 = v39 == v31 ? 0 : v39;
              if (v21[21 * v43 + 1] > v42)
              {
                uint64_t v44 = 0;
                double v45 = v21[21 * v43 + 1];
                do
                {
                  uint64_t v46 = v44;
                  int v43 = (v43 + 1) % v31;
                  --v44;
                  BOOL v47 = v21[21 * v43 + 1] <= v45;
                  double v45 = v21[21 * v43 + 1];
                }
                while (!v47);
                uint64_t v48 = 0;
                unint64_t v49 = 0;
                int v50 = &v21[21 * v89];
                *((_DWORD *)v50 + 26) = 0;
                *((_DWORD *)v50 + 21) = 0;
                *((_DWORD *)v50 + 22) = 0;
                int v51 = &v21[21 * v40];
                double v53 = *v51;
                double v52 = v51[1];
                do
                {
                  BOOL v54 = -(int)v44 > 1;
                  unint64_t v55 = &v50[v48];
                  v55[6] = v53;
                  v55[2] = v53;
                  v55[3] = v52;
                  int v40 = (v40 + 1) % v31;
                  unint64_t v56 = &v21[21 * v40];
                  double v57 = *v56;
                  double v58 = v56[1];
                  v55[4] = *v56;
                  v55[5] = v58;
                  v55[8] = (v57 - v53) / (v58 - v52);
                  *((_DWORD *)v55 + 18) = a5;
                  LODWORD(v56) = v49++ < ~v44;
                  if ((v54 & v56) != 0) {
                    BOOL v59 = v55 + 21;
                  }
                  else {
                    BOOL v59 = 0;
                  }
                  *((_OWORD *)v55 + 7) = v25;
                  *((_OWORD *)v55 + 8) = v25;
                  BOOL v60 = !v54 || v48 == 0;
                  BOOL v61 = v55 - 21;
                  if (v60) {
                    BOOL v61 = 0;
                  }
                  *((void *)v55 + 18) = v61;
                  *((void *)v55 + 19) = v59;
                  v55[20] = 0.0;
                  *((_DWORD *)v55 + 23) = v24;
                  *((_DWORD *)v55 + 24) = 0;
                  v48 += 21;
                  double v52 = v58;
                  double v53 = v57;
                }
                while (v46 + v49 != 1);
                v89 -= v44;
                BOOL v62 = (uint64_t *)bound_list(a1, v42);
                insert_bound(v62, (uint64_t)v50);
                long long v25 = 0uLL;
                uint64_t v26 = a3;
              }
            }
          }
          while (v39 != v31);
          uint64_t v63 = 0;
          do
          {
            int v64 = (v38 + (int)v63) % v31;
            double v65 = v21[21 * v64 + 1];
            double v66 = v21[21 * v63 + 1];
            uint64_t v67 = v63 + 1;
            if (v65 > v66)
            {
              unsigned int v68 = v63 + 1;
              if (v67 == v31) {
                unsigned int v68 = 0;
              }
              if (v21[21 * v68 + 1] >= v66)
              {
                uint64_t v69 = 0;
                do
                {
                  uint64_t v70 = v69;
                  int v64 = (v38 + v64) % v31;
                  --v69;
                  BOOL v47 = v21[21 * v64 + 1] <= v65;
                  double v65 = v21[21 * v64 + 1];
                }
                while (!v47);
                uint64_t v71 = 0;
                unint64_t v72 = 0;
                uint64_t v73 = &v21[21 * v89];
                *((_DWORD *)v73 + 26) = 0;
                *((_DWORD *)v73 + 21) = 0;
                *((_DWORD *)v73 + 22) = 0;
                uint64_t v74 = &v21[21 * (int)v63];
                double v76 = *v74;
                double v75 = v74[1];
                do
                {
                  BOOL v77 = -(int)v69 > 1;
                  uint64_t v78 = &v73[v71];
                  v78[6] = v76;
                  _DWORD v78[2] = v76;
                  v78[3] = v75;
                  LODWORD(v63) = (v38 + (int)v63) % v31;
                  uint64_t v79 = &v21[21 * (int)v63];
                  double v80 = *v79;
                  double v81 = v79[1];
                  v78[4] = *v79;
                  v78[5] = v81;
                  v78[8] = (v80 - v76) / (v81 - v75);
                  *((_DWORD *)v78 + 18) = a5;
                  LODWORD(v79) = v72++ < ~v69;
                  if ((v77 & v79) != 0) {
                    uint64_t v82 = v78 + 21;
                  }
                  else {
                    uint64_t v82 = 0;
                  }
                  *((_OWORD *)v78 + 7) = v25;
                  *((_OWORD *)v78 + 8) = v25;
                  BOOL v60 = !v77 || v71 == 0;
                  uint64_t v83 = v78 - 21;
                  if (v60) {
                    uint64_t v83 = 0;
                  }
                  *((void *)v78 + 18) = v83;
                  *((void *)v78 + 19) = v82;
                  v78[20] = 0.0;
                  *((_DWORD *)v78 + 23) = v24;
                  *((_DWORD *)v78 + 24) = 0;
                  v71 += 21;
                  double v75 = v81;
                  double v76 = v80;
                }
                while (v70 + v72 != 1);
                v89 -= v69;
                uint64_t v84 = (uint64_t *)bound_list(a1, v66);
                insert_bound(v84, (uint64_t)v73);
                long long v25 = 0uLL;
                uint64_t v26 = a3;
              }
            }
            uint64_t v63 = v67;
          }
          while (v67 != v31);
        }
      }
      ++v22;
      uint64_t v9 = v86;
      int v23 = v89;
    }
    while (v22 < *v86);
  }
  return v21;
}

double build_sbt(int *a1, uint64_t a2, uint64_t a3)
{
  do
  {
    if (*(void *)(a3 + 8)) {
      build_sbt(a1, a2);
    }
    double result = *(double *)a3;
    uint64_t v7 = *a1;
    *(void *)(a2 + 8 * v7) = *(void *)a3;
    *a1 = v7 + 1;
    a3 = *(void *)(a3 + 16);
  }
  while (a3);
  return result;
}

void free_sbtree(void **a1)
{
  if (*a1)
  {
    free_sbtree(*a1 + 1);
    free_sbtree(*a1 + 2);
    if (*a1)
    {
      gpc_free(*a1);
      *a1 = 0;
    }
  }
}

uint64_t *add_edge_to_aet(uint64_t *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *result;
  if (*result)
  {
    double v4 = *(double *)(a2 + 48);
    while (1)
    {
      double v5 = *(double *)(v3 + 48);
      if (v4 < v5) {
        break;
      }
      uint64_t v6 = v3;
      if (v4 == v5 && *(double *)(a2 + 64) < *(double *)(v3 + 64)) {
        break;
      }
      double result = (uint64_t *)(v3 + 136);
      uint64_t v3 = *(void *)(v3 + 136);
      a3 = v6;
      if (!v3) {
        goto LABEL_9;
      }
    }
    *(void *)(a2 + 128) = a3;
    *(void *)(a2 + 136) = *result;
    *(void *)(*result + 128) = a2;
    *double result = a2;
  }
  else
  {
    uint64_t v6 = a3;
LABEL_9:
    *double result = a2;
    *(void *)(a2 + 128) = v6;
    *(void *)(a2 + 136) = 0;
  }
  return result;
}

uint64_t merge_right(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 + 32);
  *(_DWORD *)(v3 + 4) = 0;
  uint64_t v4 = *(void *)(result + 32);
  if (v4 != v3)
  {
    *(void *)(*(void *)(v3 + 16) + 16) = *(void *)(v4 + 8);
    *(void *)(v3 + 16) = *(void *)(v4 + 16);
    if (a3)
    {
      uint64_t v5 = *(void *)(result + 32);
      do
      {
        if (*(void *)(a3 + 32) == v5)
        {
          *(_DWORD *)a3 = 0;
          *(void *)(a3 + 32) = *(void *)(a2 + 32);
        }
        a3 = *(void *)(a3 + 24);
      }
      while (a3);
    }
  }
  return result;
}

uint64_t merge_left(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 + 32);
  *(_DWORD *)(v3 + 4) = 1;
  uint64_t v4 = *(void *)(result + 32);
  if (v4 != v3)
  {
    *(void *)(*(void *)(v4 + 16) + 16) = *(void *)(v3 + 8);
    *(void *)(v3 + 8) = *(void *)(v4 + 8);
    if (a3)
    {
      uint64_t v5 = *(void *)(result + 32);
      do
      {
        if (*(void *)(a3 + 32) == v5)
        {
          *(_DWORD *)a3 = 0;
          *(void *)(a3 + 32) = *(void *)(a2 + 32);
        }
        a3 = *(void *)(a3 + 24);
      }
      while (a3);
    }
  }
  return result;
}

double *build_intersection_table(double **a1, uint64_t a2, double a3)
{
  double result = *a1;
  if (result)
  {
    do
    {
      uint64_t v7 = (double *)*((void *)result + 4);
      gpc_free(result);
      *a1 = v7;
      double result = v7;
    }
    while (v7);
  }
  double v33 = 0;
  if (a2)
  {
    while (1)
    {
      if (*(_DWORD *)(a2 + 100) == 1 || *(_DWORD *)(a2 + 76) || *(_DWORD *)(a2 + 80))
      {
        int v8 = (double *)v33;
        if (v33)
        {
          uint64_t v9 = (double *)(a2 + 64);
          uint64_t v10 = &v33;
          while (1)
          {
            double v11 = v8[2];
            double v12 = *(double *)(a2 + 56);
            if (v12 >= v11
              || ((double v13 = v8[1],
                   double v14 = v11 - v13,
                   double v15 = *(double *)(a2 + 48),
                   double v16 = v14 - (v12 - v15),
                   double v17 = fabs(v16),
                   *v9 != v8[3])
                ? (BOOL v18 = v17 > 2.22044605e-16)
                : (BOOL v18 = 0),
                  !v18))
            {
              uint64_t v29 = gpc_malloc(0x28uLL);
              *uint64_t v10 = v29;
              *uint64_t v29 = a2;
              uint64_t v30 = (double *)*v10;
              *(_OWORD *)((char *)*v10 + 8) = *(_OWORD *)(a2 + 48);
              goto LABEL_28;
            }
            double v19 = (v15 - v13) / v16;
            double v20 = v19 * a3;
            double v21 = *v8;
            uint64_t v22 = *a1;
            int v23 = a1;
            if (!*a1) {
              goto LABEL_22;
            }
            int v23 = a1;
            if (v22[3] <= v20) {
              break;
            }
LABEL_20:
            long long v25 = (double *)gpc_malloc(0x28uLL);
LABEL_23:
            *int v23 = v25;
            *long long v25 = v21;
            *((void *)*v23 + 1) = a2;
            uint64_t v26 = *v23;
            long double v26[2] = v13 + v19 * v14;
            v26[3] = v20;
            *((void *)v26 + 4) = v22;
            uint64_t v27 = (char *)*v10;
            double v28 = (double *)*((void *)v27 + 4);
            uint64_t v10 = (void **)(v27 + 32);
            int v8 = v28;
            if (!v28) {
              goto LABEL_27;
            }
          }
          while (1)
          {
            BOOL v24 = v22;
            uint64_t v22 = (double *)*((void *)v22 + 4);
            if (!v22) {
              break;
            }
            if (v22[3] > v20)
            {
              int v23 = (double **)(v24 + 4);
              goto LABEL_20;
            }
          }
          int v23 = (double **)(v24 + 4);
LABEL_22:
          long long v25 = (double *)gpc_malloc(0x28uLL);
          uint64_t v22 = 0;
          goto LABEL_23;
        }
        uint64_t v10 = &v33;
LABEL_27:
        int v31 = gpc_malloc(0x28uLL);
        int v8 = 0;
        *uint64_t v10 = v31;
        *int v31 = a2;
        uint64_t v30 = (double *)*v10;
        *(_OWORD *)((char *)*v10 + 8) = *(_OWORD *)(a2 + 48);
        uint64_t v9 = (double *)(a2 + 64);
LABEL_28:
        v30[3] = *v9;
        *((void *)v30 + 4) = v8;
      }
      a2 = *(void *)(a2 + 136);
      if (!a2)
      {
        double result = (double *)v33;
        if (v33)
        {
          do
          {
            uint64_t v32 = (double *)*((void *)result + 4);
            gpc_free(result);
            double result = v32;
          }
          while (v32);
        }
        return result;
      }
    }
  }
  return result;
}

void TSDgpc_free_tristrip(uint64_t a1)
{
  int v2 = *(_DWORD *)a1;
  if (*(int *)a1 >= 1)
  {
    uint64_t v3 = 0;
    uint64_t v4 = 8;
    do
    {
      uint64_t v5 = *(void **)(*(void *)(a1 + 8) + v4);
      if (v5)
      {
        gpc_free(v5);
        *(void *)(*(void *)(a1 + 8) + v4) = 0;
        int v2 = *(_DWORD *)a1;
      }
      ++v3;
      v4 += 16;
    }
    while (v3 < v2);
  }
  uint64_t v6 = *(void **)(a1 + 8);
  if (v6)
  {
    gpc_free(v6);
    *(void *)(a1 + 8) = 0;
  }
  *(_DWORD *)a1 = 0;
}

void TSDgpc_polygon_to_tristrip(unsigned int *a1, uint64_t a2)
{
  memset(v2, 0, sizeof(v2));
  TSDgpc_tristrip_clip(0, a1, (int *)v2, a2);
}

void TSDgpc_tristrip_clip(uint64_t a1, unsigned int *a2, int *a3, uint64_t a4)
{
  uint64_t v5 = a1;
  v448 = 0;
  v449[0] = 0;
  v446 = 0;
  uint64_t v447 = 0;
  uint64_t v444 = 0;
  v445 = 0;
  int v6 = *a2;
  int v7 = *a3;
  if (!*a2)
  {
    if (a1 >= 2 && v7)
    {
      uint64_t v407 = a4;
      uint64_t v9 = 0;
      goto LABEL_15;
    }
LABEL_18:
    *(_DWORD *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    return;
  }
  if (a1 == 1 && !v7) {
    goto LABEL_18;
  }
  uint64_t v407 = a4;
  uint64_t v9 = a1 == 0;
  if (a1 <= 1 && v6 >= 1 && v7 >= 1)
  {
    minimax_test((uint64_t)a2, a3, a1);
    int v6 = *a2;
  }
  if (v6 >= 1)
  {
    double v11 = build_lmt((double **)&v446, (double *)v449, &v444, a2, 1, v5);
    goto LABEL_16;
  }
LABEL_15:
  double v11 = 0;
LABEL_16:
  if (*a3 < 1) {
    double v12 = 0;
  }
  else {
    double v12 = build_lmt((double **)&v446, (double *)v449, &v444, (unsigned int *)a3, 0, v5);
  }
  v410 = (double *)v446;
  if (v446)
  {
    v406 = v11;
    int v13 = v444;
    if (v444) {
      double v14 = (double *)gpc_malloc(8 * (int)v444);
    }
    else {
      double v14 = 0;
    }
    v408 = v14;
    build_sbt((int *)&v444 + 1, (uint64_t)v14, (uint64_t)v449[0]);
    free_sbtree(v449);
    v405 = v12;
    if (v13 <= 0)
    {
      v384 = (_DWORD *)v407;
      *(void *)(v407 + 8) = 0;
    }
    else
    {
      uint64_t v16 = 0;
      uint64_t v17 = 0;
      int v18 = 0;
      uint64_t v19 = 0;
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      uint64_t v22 = 0;
      uint64_t v23 = 0;
      uint64_t v24 = 0;
      int v415 = 0;
      unsigned int v416 = v5;
      uint64_t v409 = 0;
      double v25 = 0.0;
      double v26 = 0.0;
      do
      {
        uint64_t v27 = v18 + 1;
        HIDWORD(v444) = v27;
        double v28 = v408[v18];
        if ((int)v27 < v13)
        {
          double v26 = v408[v27];
          double v25 = v26 - v28;
        }
        uint64_t v29 = v410;
        if (v410 && *v410 == v28)
        {
          uint64_t v30 = *((void *)v410 + 1);
          if (v30)
          {
            uint64_t v31 = v22;
            uint64_t v32 = v23;
            uint64_t v33 = v19;
            uint64_t v34 = v20;
            uint64_t v35 = v21;
            do
            {
              add_edge_to_aet(&v447, v30, 0);
              uint64_t v30 = *(void *)(v30 + 160);
            }
            while (v30);
            uint64_t v16 = v447;
            uint64_t v21 = v35;
            uint64_t v20 = v34;
            uint64_t v19 = v33;
            uint64_t v23 = v32;
            uint64_t v5 = v416;
            uint64_t v22 = v31;
          }
          uint64_t v29 = (double *)*((void *)v410 + 2);
          uint64_t v17 = v16;
        }
        *(_DWORD *)(v17 + 76 + 4 * *(int *)(v17 + 72)) = *(double *)(v17 + 40) != v28;
        *(_DWORD *)(v17 + 76 + 4 * (*(_DWORD *)(v17 + 72) == 0)) = 0;
        *(_DWORD *)(v17 + 100) = 0;
        uint64_t v36 = *(void *)(v17 + 136);
        uint64_t v37 = v17;
        v410 = v29;
        if (!v36) {
          goto LABEL_49;
        }
        do
        {
          uint64_t v38 = v36 + 76;
          *(_DWORD *)(v36 + 76 + 4 * *(int *)(v36 + 72)) = *(double *)(v36 + 40) != v28;
          uint64_t v39 = *(int *)(v36 + 72);
          *(_DWORD *)(v36 + 76 + 4 * (*(_DWORD *)(v36 + 72) == 0)) = 0;
          *(_DWORD *)(v36 + 100) = 0;
          int v40 = *(_DWORD *)(v36 + 76 + 4 * v39);
          if (v40)
          {
            uint64_t v41 = v36;
            if (vabdd_f64(*(double *)(v37 + 48), *(double *)(v36 + 48)) <= 2.22044605e-16)
            {
              uint64_t v41 = v36;
              if (vabdd_f64(*(double *)(v37 + 64), *(double *)(v36 + 64)) <= 2.22044605e-16)
              {
                uint64_t v41 = v36;
                if (*(double *)(v37 + 40) != v28)
                {
                  *(_DWORD *)(v38 + 4 * v39) = *(_DWORD *)(v37 + 76 + 4 * v39) ^ v40;
                  BOOL v42 = *(_DWORD *)(v36 + 72) == 0;
                  int v43 = *(_DWORD *)(v37 + 76 + 4 * (*(_DWORD *)(v36 + 72) == 0));
                  *(_DWORD *)(v36 + 100) = 1;
                  *(_DWORD *)(v38 + 4 * v42) = v43;
                  *(_DWORD *)(v37 + 76) = 0;
                  *(_DWORD *)(v37 + 80) = 0;
                  *(_DWORD *)(v37 + 100) = 2;
                  uint64_t v41 = v36;
                }
              }
            }
          }
          else
          {
            uint64_t v41 = v37;
          }
          uint64_t v36 = *(void *)(v36 + 136);
          uint64_t v37 = v41;
        }
        while (v36);
        if (v17)
        {
LABEL_49:
          uint64_t v44 = 0;
          uint64_t v45 = 0;
          uint64_t v46 = v409;
          while (1)
          {
            int v48 = *(_DWORD *)(v17 + 76);
            int v47 = *(_DWORD *)(v17 + 80);
            int v50 = *(_DWORD *)(v17 + 84);
            int v49 = *(_DWORD *)(v17 + 88);
            int v51 = v48 + 2 * v50;
            int v52 = v47 + 2 * v49;
            if (!(v51 | v52)) {
              goto LABEL_198;
            }
            *(_DWORD *)(v17 + 92) = v9;
            *(_DWORD *)(v17 + 96) = v24;
            if (v5 < 2)
            {
              if (!v51 || (uint64_t v23 = 1, !v24) && !v45)
              {
                if (!v52 || (uint64_t v23 = 1, !v9) && !v44)
                {
                  if (v51) {
                    BOOL v61 = v52 == 0;
                  }
                  else {
                    BOOL v61 = 1;
                  }
                  uint64_t v23 = !v61 && v9 == v24;
                }
              }
              if (v9) {
                BOOL v63 = v24 == 0;
              }
              else {
                BOOL v63 = 1;
              }
              uint64_t v21 = !v63;
              uint64_t v22 = v9 != v48 && v24 != v47;
              int v65 = v9 ^ (v44 != 0);
              int v66 = v45 != 0;
              if (v65) {
                BOOL v67 = v24 == v66;
              }
              else {
                BOOL v67 = 1;
              }
              uint64_t v19 = !v67;
              int v68 = v49 ^ v66;
              BOOL v60 = v65 == v50 || v68 == v24;
            }
            else
            {
              if (v5 == 2)
              {
                uint64_t v21 = v24 ^ v9;
                uint64_t v22 = v21 ^ v48 ^ v47;
                uint64_t v19 = v9 ^ v24 ^ (v44 != 0) ^ (v45 != 0);
                uint64_t v20 = v19 ^ v50 ^ v49;
                uint64_t v23 = 1;
                goto LABEL_124;
              }
              if (v5 != 3) {
                goto LABEL_124;
              }
              if (!v51 || (uint64_t v23 = 1, v24) && !v45)
              {
                if (!v52 || (uint64_t v23 = 1, v9) && !v44)
                {
                  if (v51) {
                    BOOL v53 = v52 == 0;
                  }
                  else {
                    BOOL v53 = 1;
                  }
                  uint64_t v23 = !v53 && v9 == v24;
                }
              }
              uint64_t v21 = (v9 | v24) != 0;
              uint64_t v22 = v9 != v48 || v24 != v47;
              int v56 = v9 ^ (v44 != 0);
              int v57 = v45 != 0;
              if (v56) {
                BOOL v58 = 0;
              }
              else {
                BOOL v58 = v24 == v57;
              }
              uint64_t v19 = !v58;
              int v59 = v49 ^ v57;
              BOOL v60 = v56 == v50 && v59 == v24;
            }
            uint64_t v20 = !v60;
LABEL_124:
            uint64_t v9 = v48 ^ v9;
            if (v51) {
              uint64_t v44 = TSDnext_h_state[6 * v44 - 2 + 2 * v51 + (int)v9];
            }
            uint64_t v24 = v47 ^ v24;
            if (v52) {
              uint64_t v45 = TSDnext_h_state[6 * v45 - 2 + 2 * v52 + (int)v24];
            }
            if (v23)
            {
              uint64_t v23 = 1;
              double v69 = *(double *)(v17 + 48);
              switch(4 * v21 + 8 * v22 + 2 * v20 + v19)
              {
                case 1:
                  if (v69 != *(double *)(v46 + 48))
                  {
                    uint64_t v70 = v22;
                    uint64_t v71 = v19;
                    uint64_t v72 = v20;
                    uint64_t v73 = v21;
                    uint64_t v74 = (double **)(*(void *)(v17 + 120) + 16);
                    do
                    {
                      double v75 = v74;
                      double v76 = *v74;
                      uint64_t v74 = (double **)(*v74 + 2);
                    }
                    while (v76);
                    BOOL v77 = (double *)gpc_malloc(0x18uLL);
                    *double v75 = v77;
                    *BOOL v77 = v69;
                    v77[1] = v28;
                    v77[2] = 0.0;
                    ++**(_DWORD **)(v17 + 120);
                    uint64_t v21 = v73;
                    uint64_t v20 = v72;
                    uint64_t v19 = v71;
                    uint64_t v22 = v70;
                    uint64_t v5 = v416;
                  }
                  uint64_t v46 = 0;
                  *(void *)(v17 + 112) = 0;
                  uint64_t v23 = 1;
                  break;
                case 2:
                  unsigned int v435 = v22;
                  uint64_t v78 = v19;
                  uint64_t v79 = v20;
                  uint64_t v80 = v21;
                  double v81 = (double **)(*(void *)(v17 + 120) + 8);
                  do
                  {
                    uint64_t v82 = v81;
                    uint64_t v83 = *v81;
                    double v81 = (double **)(*v81 + 2);
                  }
                  while (v83);
                  uint64_t v84 = (double *)gpc_malloc(0x18uLL);
                  *uint64_t v82 = v84;
                  *uint64_t v84 = v69;
                  v84[1] = v28;
                  v84[2] = 0.0;
                  ++**(_DWORD **)(v17 + 120);
                  *(void *)(v17 + 112) = 0;
                  uint64_t v46 = v17;
                  uint64_t v21 = v80;
                  uint64_t v20 = v79;
                  uint64_t v19 = v78;
                  uint64_t v23 = 1;
                  goto LABEL_197;
                case 4:
                  uint64_t v85 = *(void *)(v46 + 112);
                  *(void *)(v17 + 112) = v85;
                  if (v69 == *(double *)(v46 + 48))
                  {
                    uint64_t v46 = 0;
                    break;
                  }
                  uint64_t v86 = v22;
                  uint64_t v87 = v19;
                  uint64_t v88 = v20;
                  uint64_t v89 = v21;
                  uint64_t v90 = (double **)(v85 + 16);
                  do
                  {
                    uint64_t v91 = v90;
                    uint64_t v92 = *v90;
                    uint64_t v90 = (double **)(*v90 + 2);
                  }
                  while (v92);
                  uint64_t v93 = (double *)gpc_malloc(0x18uLL);
                  uint64_t v46 = 0;
                  *uint64_t v91 = v93;
                  *uint64_t v93 = v69;
                  v93[1] = v28;
                  v93[2] = 0.0;
                  ++**(_DWORD **)(v17 + 112);
                  uint64_t v21 = v89;
                  uint64_t v20 = v88;
                  uint64_t v19 = v87;
LABEL_189:
                  uint64_t v23 = 1;
                  goto LABEL_190;
                case 5:
                  *(void *)(v17 + 112) = *(void *)(v46 + 112);
                  unsigned int v438 = v19;
                  if (v415 != 10)
                  {
                    unsigned int v435 = v22;
                    uint64_t v174 = v20;
                    uint64_t v175 = v21;
                    uint64_t v176 = (double **)(*(void *)(v17 + 120) + 16);
                    do
                    {
                      uint64_t v177 = v176;
                      uint64_t v178 = *v176;
                      uint64_t v176 = (double **)(*v176 + 2);
                    }
                    while (v178);
                    double v179 = (double *)gpc_malloc(0x18uLL);
                    *uint64_t v177 = v179;
                    *double v179 = v69;
                    v179[1] = v28;
                    v179[2] = 0.0;
                    ++**(_DWORD **)(v17 + 120);
                    uint64_t v180 = (double **)(*(void *)(v17 + 112) + 16);
                    do
                    {
                      uint64_t v181 = v180;
                      uint64_t v182 = *v180;
                      uint64_t v180 = (double **)(*v180 + 2);
                    }
                    while (v182);
                    uint64_t v183 = (double *)gpc_malloc(0x18uLL);
                    uint64_t v46 = 0;
                    *uint64_t v181 = v183;
                    *uint64_t v183 = v69;
                    v183[1] = v28;
                    v183[2] = 0.0;
                    ++**(_DWORD **)(v17 + 112);
                    uint64_t v23 = 1;
LABEL_196:
                    uint64_t v21 = v175;
                    uint64_t v20 = v174;
                    uint64_t v19 = v438;
LABEL_197:
                    uint64_t v22 = v435;
                    break;
                  }
                  if (*(double *)(v46 + 24) != v28)
                  {
                    if (*(double *)(v17 + 24) != v28)
                    {
                      uint64_t v46 = 0;
                      int v415 = 10;
                      break;
                    }
                    unsigned int v435 = v22;
                    uint64_t v174 = v20;
                    uint64_t v175 = v21;
                    uint64_t v184 = (double **)(*(void *)(v46 + 120) + 8);
                    uint64_t v185 = v46;
                    uint64_t v186 = *(void *)(v46 + 48);
                    do
                    {
                      uint64_t v187 = v184;
                      uint64_t v188 = *v184;
                      uint64_t v184 = (double **)(*v184 + 2);
                    }
                    while (v188);
                    uint64_t v189 = (double *)gpc_malloc(0x18uLL);
                    *uint64_t v187 = v189;
                    *(void *)uint64_t v189 = v186;
                    v189[1] = v28;
                    v189[2] = 0.0;
                    ++**(_DWORD **)(v185 + 120);
                    int v190 = (double **)(*(void *)(v17 + 120) + 16);
                    do
                    {
                      uint64_t v191 = v190;
                      uint64_t v192 = *v190;
                      int v190 = (double **)(*v190 + 2);
                    }
                    while (v192);
                    uint64_t v193 = (double *)gpc_malloc(0x18uLL);
                    uint64_t v46 = 0;
                    *uint64_t v191 = v193;
                    *uint64_t v193 = v69;
                    v193[1] = v28;
                    v193[2] = 0.0;
                    ++**(_DWORD **)(v17 + 120);
                    uint64_t v23 = 1;
                    int v415 = 10;
                    goto LABEL_196;
                  }
                  uint64_t v86 = v22;
                  uint64_t v94 = v20;
                  uint64_t v95 = v21;
                  uint64_t v96 = (double **)(*(void *)(v17 + 120) + 16);
                  do
                  {
                    int v97 = v96;
                    uint64_t v98 = *v96;
                    uint64_t v96 = (double **)(*v96 + 2);
                  }
                  while (v98);
                  uint64_t v99 = (double *)gpc_malloc(0x18uLL);
                  uint64_t v46 = 0;
                  *int v97 = v99;
                  *uint64_t v99 = v69;
                  v99[1] = v28;
                  v99[2] = 0.0;
                  ++**(_DWORD **)(v17 + 120);
                  uint64_t v23 = 1;
                  int v415 = 10;
LABEL_167:
                  uint64_t v21 = v95;
                  uint64_t v20 = v94;
                  uint64_t v19 = v438;
LABEL_190:
                  uint64_t v22 = v86;
                  uint64_t v5 = v416;
                  break;
                case 6:
                  uint64_t v100 = v46;
                  unsigned int v439 = v19;
                  unsigned int v430 = v20;
                  uint64_t v101 = v21;
                  uint64_t v102 = (double **)(*(void *)(v17 + 120) + 8);
                  do
                  {
                    uint64_t v103 = v102;
                    uint64_t v104 = *v102;
                    uint64_t v102 = (double **)(*v102 + 2);
                  }
                  while (v104);
                  uint64_t v105 = (double *)gpc_malloc(0x18uLL);
                  *uint64_t v103 = v105;
                  *uint64_t v105 = v69;
                  v105[1] = v28;
                  v105[2] = 0.0;
                  ++**(_DWORD **)(v17 + 120);
                  *(void *)(v17 + 112) = *(void *)(v100 + 112);
                  if (v69 != *(double *)(v100 + 48))
                  {
                    uint64_t v106 = (double **)(*(void *)(v100 + 112) + 16);
                    do
                    {
                      uint64_t v107 = v106;
                      uint64_t v108 = *v106;
                      uint64_t v106 = (double **)(*v106 + 2);
                    }
                    while (v108);
                    uint64_t v109 = (double *)gpc_malloc(0x18uLL);
                    *uint64_t v107 = v109;
                    *uint64_t v109 = v69;
                    v109[1] = v28;
                    double v109[2] = 0.0;
                    ++**(_DWORD **)(v100 + 112);
                  }
                  uint64_t v23 = 1;
                  uint64_t v46 = v17;
                  uint64_t v21 = v101;
                  uint64_t v20 = v430;
                  uint64_t v19 = v439;
                  break;
                case 7:
                  unsigned int v435 = v22;
                  if (v415 == 10)
                  {
                    uint64_t v110 = v19;
                    uint64_t v111 = v20;
                    uint64_t v112 = v21;
                    if (*(double *)(v46 + 24) != v28)
                    {
                      uint64_t v113 = (double **)(*(void *)(v46 + 120) + 8);
                      uint64_t v114 = v46;
                      uint64_t v115 = *(void *)(v46 + 48);
                      do
                      {
                        uint64_t v116 = v113;
                        uint64_t v117 = *v113;
                        uint64_t v113 = (double **)(*v113 + 2);
                      }
                      while (v117);
                      uint64_t v118 = (double *)gpc_malloc(0x18uLL);
                      *uint64_t v116 = v118;
                      *(void *)uint64_t v118 = v115;
                      v118[1] = v28;
                      v118[2] = 0.0;
                      uint64_t v46 = v114;
                      ++**(_DWORD **)(v114 + 120);
                    }
                    uint64_t v119 = v46;
                    new_tristrip(&v445, v46, *(double *)(v46 + 48), v28);
                    uint64_t v46 = v119;
                    uint64_t v21 = v112;
                    uint64_t v20 = v111;
                    uint64_t v19 = v110;
                  }
                  uint64_t v120 = v19;
                  uint64_t v121 = v20;
                  uint64_t v122 = v21;
                  uint64_t v123 = v46;
                  uint64_t v124 = *(void *)(v46 + 112);
                  *(void *)(v17 + 112) = v124;
                  uint64_t v125 = (double **)(v124 + 16);
                  do
                  {
                    uint64_t v126 = v125;
                    long long v127 = *v125;
                    uint64_t v125 = (double **)(*v125 + 2);
                  }
                  while (v127);
                  uint64_t v128 = (double *)gpc_malloc(0x18uLL);
                  *uint64_t v126 = v128;
                  *uint64_t v128 = v69;
                  v128[1] = v28;
                  v128[2] = 0.0;
                  ++**(_DWORD **)(v17 + 112);
                  goto LABEL_185;
                case 8:
                  uint64_t v129 = v21;
                  uint64_t v130 = v20;
                  uint64_t v131 = v5;
                  uint64_t v132 = v22;
                  uint64_t v133 = v19;
                  new_tristrip(&v445, v17, *(double *)(v17 + 48), v28);
                  uint64_t v19 = v133;
                  uint64_t v22 = v132;
                  uint64_t v5 = v131;
                  uint64_t v20 = v130;
                  uint64_t v21 = v129;
                  uint64_t v23 = 1;
                  goto LABEL_175;
                case 9:
                  uint64_t v86 = v22;
                  unsigned int v438 = v19;
                  uint64_t v94 = v20;
                  uint64_t v95 = v21;
                  uint64_t v134 = (double **)(*(void *)(v17 + 120) + 16);
                  do
                  {
                    long long v135 = v134;
                    uint64_t v136 = *v134;
                    uint64_t v134 = (double **)(*v134 + 2);
                  }
                  while (v136);
                  long long v137 = (double *)gpc_malloc(0x18uLL);
                  *long long v135 = v137;
                  *long long v137 = v69;
                  v137[1] = v28;
                  v137[2] = 0.0;
                  ++**(_DWORD **)(v17 + 120);
                  *(void *)(v17 + 112) = 0;
                  new_tristrip(&v445, v17, v69, v28);
                  uint64_t v23 = 1;
                  uint64_t v46 = v17;
                  goto LABEL_167;
                case 10:
                  uint64_t v138 = *(_DWORD **)(v17 + 120);
                  if (*(double *)(v17 + 24) == v28)
                  {
                    uint64_t v139 = v22;
                    uint64_t v140 = v19;
                    uint64_t v141 = v20;
                    uint64_t v142 = v21;
                    uint64_t v143 = (double **)(v138 + 2);
                    do
                    {
                      double v144 = v143;
                      uint64_t v145 = *v143;
                      uint64_t v143 = (double **)(*v143 + 2);
                    }
                    while (v145);
                    uint64_t v146 = (double *)gpc_malloc(0x18uLL);
                    *double v144 = v146;
                    *uint64_t v146 = v69;
                    v146[1] = v28;
                    v146[2] = 0.0;
                    uint64_t v138 = *(_DWORD **)(v17 + 120);
                    ++*v138;
                    uint64_t v21 = v142;
                    uint64_t v20 = v141;
                    uint64_t v19 = v140;
                    uint64_t v22 = v139;
                    uint64_t v5 = v416;
                  }
                  *(void *)(v17 + 112) = v138;
                  uint64_t v23 = 1;
                  int v147 = 10;
                  goto LABEL_174;
                case 11:
                  uint64_t v148 = v21;
                  uint64_t v149 = v20;
                  uint64_t v150 = v5;
                  uint64_t v151 = v22;
                  uint64_t v152 = v19;
                  new_tristrip(&v445, v17, *(double *)(v17 + 48), v28);
                  uint64_t v19 = v152;
                  uint64_t v22 = v151;
                  uint64_t v5 = v150;
                  uint64_t v20 = v149;
                  uint64_t v21 = v148;
                  uint64_t v23 = 1;
                  int v147 = 11;
LABEL_174:
                  int v415 = v147;
LABEL_175:
                  uint64_t v46 = v17;
                  break;
                case 13:
                  unsigned int v435 = v22;
                  if (v415 == 10)
                  {
                    uint64_t v153 = v19;
                    uint64_t v154 = v20;
                    uint64_t v155 = v21;
                    if (*(double *)(v46 + 24) != v28)
                    {
                      long long v156 = (double **)(*(void *)(v46 + 120) + 8);
                      uint64_t v157 = v46;
                      uint64_t v158 = *(void *)(v46 + 48);
                      do
                      {
                        int v159 = v156;
                        int v160 = *v156;
                        long long v156 = (double **)(*v156 + 2);
                      }
                      while (v160);
                      int v161 = (double *)gpc_malloc(0x18uLL);
                      *int v159 = v161;
                      *(void *)int v161 = v158;
                      v161[1] = v28;
                      v161[2] = 0.0;
                      uint64_t v46 = v157;
                      ++**(_DWORD **)(v157 + 120);
                    }
                    uint64_t v162 = v46;
                    new_tristrip(&v445, v46, *(double *)(v46 + 48), v28);
                    uint64_t v46 = v162;
                    uint64_t v21 = v155;
                    uint64_t v20 = v154;
                    uint64_t v19 = v153;
                  }
                  uint64_t v123 = v46;
                  uint64_t v120 = v19;
                  uint64_t v121 = v20;
                  uint64_t v122 = v21;
                  int v163 = (double **)(*(void *)(v17 + 120) + 16);
                  do
                  {
                    int v164 = v163;
                    int v165 = *v163;
                    int v163 = (double **)(*v163 + 2);
                  }
                  while (v165);
                  int v166 = (double *)gpc_malloc(0x18uLL);
                  *int v164 = v166;
                  *int v166 = v69;
                  v166[1] = v28;
                  v166[2] = 0.0;
                  ++**(_DWORD **)(v17 + 120);
                  *(void *)(v17 + 112) = 0;
LABEL_185:
                  uint64_t v21 = v122;
                  uint64_t v20 = v121;
                  uint64_t v19 = v120;
                  uint64_t v23 = 1;
                  uint64_t v46 = v123;
                  uint64_t v5 = v416;
                  goto LABEL_197;
                case 14:
                  uint64_t v86 = v22;
                  uint64_t v167 = v46;
                  unsigned int v440 = v19;
                  uint64_t v168 = v20;
                  uint64_t v169 = v21;
                  uint64_t v170 = (double **)(*(void *)(v17 + 120) + 8);
                  do
                  {
                    uint64_t v171 = v170;
                    int v172 = *v170;
                    uint64_t v170 = (double **)(*v170 + 2);
                  }
                  while (v172);
                  uint64_t v173 = (double *)gpc_malloc(0x18uLL);
                  *uint64_t v171 = v173;
                  *uint64_t v173 = v69;
                  v173[1] = v28;
                  v173[2] = 0.0;
                  ++**(_DWORD **)(v17 + 120);
                  *(void *)(v17 + 112) = 0;
                  int v415 = 14;
                  uint64_t v21 = v169;
                  uint64_t v20 = v168;
                  uint64_t v19 = v440;
                  uint64_t v46 = v167;
                  goto LABEL_189;
                default:
                  break;
              }
            }
LABEL_198:
            uint64_t v17 = *(void *)(v17 + 136);
            if (!v17)
            {
              uint64_t v409 = v46;
              uint64_t v16 = v447;
              uint64_t v194 = v447;
              if (v447)
              {
                do
                {
                  double v195 = *(double *)(v194 + 40);
                  if (v195 == v28)
                  {
                    uint64_t v196 = *(void *)(v194 + 128);
                    uint64_t v197 = *(void *)(v194 + 136);
                    uint64_t v198 = v197;
                    if (v196)
                    {
                      *(void *)(v196 + 136) = v197;
                      uint64_t v198 = v16;
                    }
                    if (v197) {
                      *(void *)(v197 + 128) = v196;
                    }
                    if (v196)
                    {
                      if (*(_DWORD *)(v194 + 104) == 1 && *(_DWORD *)(v196 + 104) == 2)
                      {
                        *(void *)(v196 + 120) = *(void *)(v194 + 120);
                        *(_DWORD *)(v196 + 104) = 0;
                        uint64_t v199 = *(void *)(v196 + 128);
                        if (v199)
                        {
                          if (*(_DWORD *)(v199 + 104) == 2) {
                            *(_DWORD *)(v196 + 104) = 1;
                          }
                        }
                      }
                    }
                    uint64_t v16 = v198;
                  }
                  else
                  {
                    if (v195 == v26) {
                      double v200 = *(double *)(v194 + 32);
                    }
                    else {
                      double v200 = *(double *)(v194 + 16) + *(double *)(v194 + 64) * (v26 - *(double *)(v194 + 24));
                    }
                    *(double *)(v194 + 56) = v200;
                  }
                  uint64_t v194 = *(void *)(v194 + 136);
                }
                while (v194);
                uint64_t v447 = v16;
                uint64_t v17 = v16;
              }
              else
              {
                uint64_t v17 = 0;
              }
              break;
            }
          }
        }
        int v13 = v444;
        int v18 = HIDWORD(v444);
        if (SHIDWORD(v444) < (int)v444)
        {
          unsigned int v411 = v23;
          uint64_t v201 = v19;
          uint64_t v202 = v20;
          uint64_t v203 = v21;
          build_intersection_table((double **)&v448, v16, v25);
          uint64_t v204 = (uint64_t *)v448;
          if (v448)
          {
            uint64_t v21 = v203;
            uint64_t v20 = v202;
            uint64_t v19 = v201;
            uint64_t v23 = v411;
            while (1)
            {
              uint64_t v206 = *v204;
              uint64_t v205 = v204[1];
              int v207 = *(_DWORD *)(*v204 + 76);
              if (v207)
              {
                int v208 = *(_DWORD *)(v205 + 76);
                if (v208)
                {
                  uint64_t v209 = (_DWORD **)(v206 + 112);
                  uint64_t v210 = *(void *)(v206 + 112);
                  uint64_t v212 = (void *)(v205 + 112);
                  uint64_t v211 = *(void *)(v205 + 112);
                  long long v213 = *((_OWORD *)v204 + 1);
                  if (*(_DWORD *)(v206 + 92)) {
                    goto LABEL_234;
                  }
                  int v215 = 1;
                }
                else
                {
                  if (!*(_DWORD *)(v205 + 80)) {
                    goto LABEL_363;
                  }
                  int v208 = 0;
                  uint64_t v209 = (_DWORD **)(v206 + 112);
                  uint64_t v210 = *(void *)(v206 + 112);
                  uint64_t v212 = (void *)(v205 + 112);
                  uint64_t v211 = *(void *)(v205 + 112);
                  long long v213 = *((_OWORD *)v204 + 1);
                  int v215 = *(_DWORD *)(v206 + 92) == 0;
                }
              }
              else
              {
                if (!*(_DWORD *)(v206 + 80)) {
                  goto LABEL_363;
                }
                int v208 = *(_DWORD *)(v205 + 76);
                if (v208)
                {
                  uint64_t v209 = (_DWORD **)(v206 + 112);
                  uint64_t v210 = *(void *)(v206 + 112);
                  uint64_t v212 = (void *)(v205 + 112);
                  uint64_t v211 = *(void *)(v205 + 112);
                  long long v213 = *((_OWORD *)v204 + 1);
                  int v214 = *(_DWORD *)(v205 + 92);
                  goto LABEL_238;
                }
                if (!*(_DWORD *)(v205 + 80)) {
                  goto LABEL_363;
                }
                uint64_t v209 = (_DWORD **)(v206 + 112);
                uint64_t v210 = *(void *)(v206 + 112);
                uint64_t v212 = (void *)(v205 + 112);
                uint64_t v211 = *(void *)(v205 + 112);
                long long v213 = *((_OWORD *)v204 + 1);
                int v208 = *(_DWORD *)(v206 + 92);
                if (v208)
                {
                  int v208 = 0;
LABEL_234:
                  int v214 = *(_DWORD *)(v205 + 92);
LABEL_238:
                  int v215 = v214 != 0;
                  goto LABEL_242;
                }
                int v215 = 0;
              }
LABEL_242:
              int v216 = *(_DWORD *)(v206 + 80);
              if (v216)
              {
                if (!*(_DWORD *)(v206 + 96))
                {
                  int v217 = 1;
                  goto LABEL_250;
                }
                int v217 = *(_DWORD *)(v205 + 80);
                if (!v217) {
                  goto LABEL_250;
                }
              }
              else if (!*(_DWORD *)(v205 + 80))
              {
                int v217 = *(_DWORD *)(v206 + 96);
                if (!v217) {
                  goto LABEL_250;
                }
              }
              int v217 = *(_DWORD *)(v205 + 96) != 0;
LABEL_250:
              if (v5 < 2)
              {
                uint64_t v20 = v208 != v215 && *(_DWORD *)(v205 + 80) != v217;
                uint64_t v21 = v207 != v215 && v216 != v217;
                uint64_t v22 = (v208 ^ v207) != v215 && (*(_DWORD *)(v205 + 80) ^ v216) != v217;
                uint64_t v19 = v215 & v217;
              }
              else if (v5 == 2)
              {
                uint64_t v19 = v217 ^ v215;
                int v218 = v208 ^ v215;
                int v219 = *(_DWORD *)(v205 + 80) ^ v217;
                uint64_t v20 = v219 ^ v218;
                int v220 = v216 ^ v207;
                uint64_t v21 = v220 ^ v215 ^ v217;
                uint64_t v22 = v220 ^ v218 ^ v219;
              }
              else if (v5 == 3)
              {
                uint64_t v20 = v208 != v215 || *(_DWORD *)(v205 + 80) != v217;
                uint64_t v21 = v207 != v215 || v216 != v217;
                uint64_t v22 = (v208 ^ v207) != v215 || (*(_DWORD *)(v205 + 80) ^ v216) != v217;
                uint64_t v19 = v215 | v217;
              }
              double v223 = v28 + *((double *)&v213 + 1);
              switch(4 * v21 + 8 * v22 + 2 * v20 + v19)
              {
                case 1:
                  if (v210 && v211)
                  {
                    uint64_t v224 = v209;
                    uint64_t v421 = v213;
                    unsigned int v441 = v19;
                    unsigned int v431 = v20;
                    unsigned int v417 = v21;
                    uint64_t v225 = (double **)(v210 + 8);
                    do
                    {
                      double v226 = v225;
                      int v227 = *v225;
                      uint64_t v225 = (double **)(*v225 + 2);
                    }
                    while (v227);
                    int32x4_t v228 = (double *)gpc_malloc(0x18uLL);
                    void *v226 = v228;
                    *(void *)int32x4_t v228 = v421;
                    v228[1] = v223;
                    v228[2] = 0.0;
                    ++**v224;
                    *uint64_t v224 = 0;
                    *uint64_t v212 = 0;
                    uint64_t v5 = v416;
                    uint64_t v21 = v417;
                    uint64_t v20 = v431;
                    uint64_t v22 = v22;
                    goto LABEL_311;
                  }
                  goto LABEL_363;
                case 2:
                  if (v211)
                  {
                    unsigned int v436 = v22;
                    uint64_t v229 = v204[1];
                    do
                      uint64_t v229 = *(void *)(v229 + 136);
                    while (!*(void *)(v229 + 112));
                    uint64_t v230 = v209;
                    uint64_t v422 = v213;
                    unsigned int v442 = v19;
                    unsigned int v432 = v20;
                    unsigned int v418 = v21;
                    double v231 = *(double *)(v229 + 64);
                    double v232 = *(double *)(v229 + 16);
                    double v233 = v223 - *(double *)(v229 + 24);
                    double v234 = (double **)(v211 + 8);
                    do
                    {
                      uint64_t v235 = v234;
                      double v236 = *v234;
                      double v234 = (double **)(*v234 + 2);
                    }
                    while (v236);
                    int32x4_t v237 = (double *)gpc_malloc(0x18uLL);
                    *uint64_t v235 = v237;
                    *(void *)int32x4_t v237 = v422;
                    v237[1] = v223;
                    v237[2] = 0.0;
                    ++*(_DWORD *)*v212;
                    int32x4_t v238 = (double **)(*(void *)(v229 + 112) + 16);
                    do
                    {
                      int v239 = v238;
                      uint64_t v240 = *v238;
                      int32x4_t v238 = (double **)(*v238 + 2);
                    }
                    while (v240);
                    int v241 = (double *)gpc_malloc(0x18uLL);
                    *int v239 = v241;
                    *int v241 = v232 + v231 * v233;
                    v241[1] = v223;
                    v241[2] = 0.0;
                    ++**(_DWORD **)(v229 + 112);
                    void *v230 = *v212;
                    goto LABEL_361;
                  }
                  goto LABEL_363;
                case 4:
                  if (v210)
                  {
                    uint64_t v423 = v213;
                    unsigned int v436 = v22;
                    uint64_t v242 = *v204;
                    do
                    {
                      uint64_t v242 = *(void *)(v242 + 128);
                      uint64_t v243 = *(void *)(v242 + 112);
                    }
                    while (!v243);
                    int v244 = v209;
                    unsigned int v442 = v19;
                    unsigned int v432 = v20;
                    unsigned int v418 = v21;
                    int v245 = (double **)(v243 + 8);
                    do
                    {
                      int v246 = v245;
                      unsigned int v247 = *v245;
                      int v245 = (double **)(*v245 + 2);
                    }
                    while (v247);
                    double v248 = *(double *)(v242 + 16) + *(double *)(v242 + 64) * (v223 - *(double *)(v242 + 24));
                    unsigned int v249 = (double *)gpc_malloc(0x18uLL);
                    *int v246 = v249;
                    *unsigned int v249 = v248;
                    v249[1] = v223;
                    v249[2] = 0.0;
                    ++**(_DWORD **)(v242 + 112);
                    unsigned int v250 = (double **)(*v244 + 16);
                    do
                    {
                      unsigned int v251 = v250;
                      unsigned int v252 = *v250;
                      unsigned int v250 = (double **)(*v250 + 2);
                    }
                    while (v252);
                    unsigned int v253 = (double *)gpc_malloc(0x18uLL);
                    *unsigned int v251 = v253;
                    *(void *)unsigned int v253 = v423;
                    v253[1] = v223;
                    v253[2] = 0.0;
                    unsigned int v254 = (_DWORD *)*v244;
                    *unsigned int v254 = *(_DWORD *)*v244 + 1;
                    *uint64_t v212 = v254;
                    *int v244 = 0;
                    break;
                  }
                  goto LABEL_363;
                case 6:
                  if (v210 && v211)
                  {
                    v278 = v209;
                    double v426 = *(double *)&v213;
                    unsigned int v436 = v22;
                    unsigned int v442 = v19;
                    unsigned int v432 = v20;
                    unsigned int v418 = v21;
                    uint64_t v279 = (double **)(v210 + 16);
                    do
                    {
                      int v280 = v279;
                      v281 = *v279;
                      uint64_t v279 = (double **)(*v279 + 2);
                    }
                    while (v281);
                    int v282 = (double *)gpc_malloc(0x18uLL);
                    *int v280 = v282;
                    *int v282 = v426;
                    v282[1] = v223;
                    v282[2] = 0.0;
                    ++**v278;
                    uint64_t v283 = (double **)(*v212 + 8);
                    do
                    {
                      int v284 = v283;
                      v285 = *v283;
                      uint64_t v283 = (double **)(*v283 + 2);
                    }
                    while (v285);
                    int v286 = (double *)gpc_malloc(0x18uLL);
                    *int v284 = v286;
                    *int v286 = v426;
                    v286[1] = v223;
                    v286[2] = 0.0;
                    ++*(_DWORD *)*v212;
                    uint64_t v287 = v206;
                    do
                    {
                      uint64_t v287 = *(void *)(v287 + 128);
                      uint64_t v288 = *(void *)(v287 + 112);
                    }
                    while (!v288);
                    v289 = (double **)(v288 + 8);
                    do
                    {
                      v290 = v289;
                      v291 = *v289;
                      v289 = (double **)(*v289 + 2);
                    }
                    while (v291);
                    double v292 = *(double *)(v287 + 16) + *(double *)(v287 + 64) * (v223 - *(double *)(v287 + 24));
                    unsigned int v293 = (double *)gpc_malloc(0x18uLL);
                    void *v290 = v293;
                    *unsigned int v293 = v292;
                    v293[1] = v223;
                    v293[2] = 0.0;
                    ++**(_DWORD **)(v287 + 112);
                    new_tristrip(&v445, v287, v292, v223);
                    uint64_t v294 = v205;
                    do
                    {
                      uint64_t v294 = *(void *)(v294 + 136);
                      uint64_t v295 = *(void *)(v294 + 112);
                    }
                    while (!v295);
                    v296 = (double **)(v295 + 16);
                    do
                    {
                      v297 = v296;
                      uint64_t v298 = *v296;
                      v296 = (double **)(*v296 + 2);
                    }
                    while (v298);
                    double v299 = *(double *)(v294 + 16) + *(double *)(v294 + 64) * (v223 - *(double *)(v294 + 24));
                    int v300 = (double *)gpc_malloc(0x18uLL);
                    int *v297 = v300;
                    *int v300 = v299;
                    v300[1] = v223;
                    v300[2] = 0.0;
                    ++**(_DWORD **)(v294 + 112);
                    uint64_t v301 = *(void *)(v287 + 112);
                    *uint64_t v212 = v301;
                    v302 = (double **)(v301 + 16);
                    do
                    {
                      v303 = v302;
                      v304 = *v302;
                      v302 = (double **)(*v302 + 2);
                    }
                    while (v304);
                    int v305 = (double *)gpc_malloc(0x18uLL);
                    SweepTree *v303 = v305;
                    *int v305 = v426;
                    v305[1] = v223;
                    v305[2] = 0.0;
                    ++*(_DWORD *)*v212;
                    new_tristrip(&v445, v206, v426, v223);
                    uint64_t v306 = *(void *)(v206 + 112);
                    *(void *)(v294 + 112) = v306;
                    uint64_t v307 = (double **)(v306 + 16);
                    do
                    {
                      v308 = v307;
                      v309 = *v307;
                      uint64_t v307 = (double **)(*v307 + 2);
                    }
                    while (v309);
                    v310 = (double *)gpc_malloc(0x18uLL);
                    Shape *v308 = v310;
                    double *v310 = v299;
                    goto LABEL_352;
                  }
                  goto LABEL_363;
                case 7:
                  double v427 = *(double *)&v213;
                  unsigned int v436 = v22;
                  uint64_t v311 = *v204;
                  do
                  {
                    uint64_t v311 = *(void *)(v311 + 128);
                    uint64_t v312 = *(void *)(v311 + 112);
                  }
                  while (!v312);
                  unsigned int v442 = v19;
                  unsigned int v432 = v20;
                  unsigned int v418 = v21;
                  v313 = (double **)(v312 + 8);
                  do
                  {
                    v314 = v313;
                    v315 = *v313;
                    v313 = (double **)(*v313 + 2);
                  }
                  while (v315);
                  double v316 = *(double *)(v311 + 16) + *(double *)(v311 + 64) * (v223 - *(double *)(v311 + 24));
                  v317 = (double *)gpc_malloc(0x18uLL);
                  *v314 = v317;
                  double *v317 = v316;
                  v317[1] = v223;
                  v317[2] = 0.0;
                  ++**(_DWORD **)(v311 + 112);
                  uint64_t v294 = v205;
                  do
                  {
                    uint64_t v294 = *(void *)(v294 + 136);
                    uint64_t v318 = *(void *)(v294 + 112);
                  }
                  while (!v318);
                  v319 = (double **)(v318 + 16);
                  do
                  {
                    v320 = v319;
                    v321 = *v319;
                    v319 = (double **)(*v319 + 2);
                  }
                  while (v321);
                  double v322 = *(double *)(v294 + 16) + *(double *)(v294 + 64) * (v223 - *(double *)(v294 + 24));
                  v323 = (double *)gpc_malloc(0x18uLL);
                  *v320 = v323;
                  double *v323 = v322;
                  v323[1] = v223;
                  v323[2] = 0.0;
                  ++**(_DWORD **)(v294 + 112);
                  new_tristrip(&v445, v311, v316, v223);
                  uint64_t v324 = *(void *)(v311 + 112);
                  *uint64_t v212 = v324;
                  v325 = (double **)(v324 + 16);
                  do
                  {
                    v326 = v325;
                    v327 = *v325;
                    v325 = (double **)(*v325 + 2);
                  }
                  while (v327);
                  v328 = (double *)gpc_malloc(0x18uLL);
                  *v326 = v328;
                  double *v328 = v427;
                  v328[1] = v223;
                  v328[2] = 0.0;
                  ++*(_DWORD *)*v212;
                  new_tristrip(&v445, v206, v427, v223);
                  uint64_t v329 = *(void *)(v206 + 112);
                  *(void *)(v294 + 112) = v329;
                  v330 = (double **)(v329 + 16);
                  do
                  {
                    v331 = v330;
                    v332 = *v330;
                    v330 = (double **)(*v330 + 2);
                  }
                  while (v332);
                  v310 = (double *)gpc_malloc(0x18uLL);
                  *v331 = v310;
                  double *v310 = v322;
LABEL_352:
                  v310[1] = v223;
                  v310[2] = 0.0;
                  ++**(_DWORD **)(v294 + 112);
                  break;
                case 8:
                  v412 = v209;
                  uint64_t v255 = v21;
                  uint64_t v256 = v22;
                  uint64_t v257 = v24;
                  uint64_t v258 = v9;
                  uint64_t v259 = v5;
                  uint64_t v260 = v20;
                  uint64_t v261 = v19;
                  new_tristrip(&v445, v205, *(double *)&v213, v28 + *((double *)&v213 + 1));
                  uint64_t v19 = v261;
                  uint64_t v23 = v411;
                  uint64_t v20 = v260;
                  uint64_t v5 = v259;
                  uint64_t v9 = v258;
                  uint64_t v24 = v257;
                  uint64_t v22 = v256;
                  uint64_t v21 = v255;
                  void *v412 = *(void *)(v205 + 112);
                  goto LABEL_363;
                case 9:
                  if (v210 && v211)
                  {
                    uint64_t v262 = v209;
                    double v424 = *(double *)&v213;
                    unsigned int v441 = v19;
                    unsigned int v433 = v20;
                    unsigned int v419 = v21;
                    uint64_t v263 = (double **)(v210 + 8);
                    do
                    {
                      unsigned int v264 = v263;
                      unsigned int v265 = *v263;
                      uint64_t v263 = (double **)(*v263 + 2);
                    }
                    while (v265);
                    unsigned int v266 = (double *)gpc_malloc(0x18uLL);
                    *unsigned int v264 = v266;
                    double *v266 = v424;
                    v266[1] = v223;
                    v266[2] = 0.0;
                    ++**v262;
                    new_tristrip(&v445, v205, v424, v223);
                    int *v262 = *(_DWORD **)(v205 + 112);
                    uint64_t v21 = v419;
                    uint64_t v20 = v433;
LABEL_311:
                    uint64_t v19 = v441;
                    uint64_t v23 = v411;
                  }
                  goto LABEL_363;
                case 11:
                  if (!v210) {
                    goto LABEL_363;
                  }
                  v413 = v209;
                  uint64_t v425 = v213;
                  unsigned int v436 = v22;
                  unsigned int v442 = v19;
                  unsigned int v432 = v20;
                  unsigned int v418 = v21;
                  unsigned int v267 = (double **)(v210 + 8);
                  do
                  {
                    unsigned int v268 = v267;
                    unsigned int v269 = *v267;
                    unsigned int v267 = (double **)(*v267 + 2);
                  }
                  while (v269);
                  unsigned int v270 = (double *)gpc_malloc(0x18uLL);
                  *unsigned int v268 = v270;
                  *(void *)unsigned int v270 = v425;
                  v270[1] = v223;
                  v270[2] = 0.0;
                  ++**v413;
                  uint64_t v271 = v205;
                  do
                  {
                    uint64_t v271 = *(void *)(v271 + 136);
                    uint64_t v272 = *(void *)(v271 + 112);
                  }
                  while (!v272);
                  uint64_t v273 = (double **)(v272 + 16);
                  do
                  {
                    uint64_t v274 = v273;
                    uint64_t v275 = *v273;
                    uint64_t v273 = (double **)(*v273 + 2);
                  }
                  while (v275);
                  double v276 = *(double *)(v271 + 16) + *(double *)(v271 + 64) * (v223 - *(double *)(v271 + 24));
                  uint64_t v277 = (double *)gpc_malloc(0x18uLL);
                  *uint64_t v274 = v277;
                  *uint64_t v277 = v276;
                  v277[1] = v223;
                  v277[2] = 0.0;
                  ++**(_DWORD **)(v271 + 112);
                  *uint64_t v212 = *v413;
                  *v413 = 0;
                  break;
                case 13:
                  if (!v211) {
                    goto LABEL_363;
                  }
                  v414 = v209;
                  uint64_t v428 = v213;
                  unsigned int v436 = v22;
                  unsigned int v442 = v19;
                  unsigned int v432 = v20;
                  unsigned int v418 = v21;
                  v333 = (double **)(v211 + 16);
                  do
                  {
                    v334 = v333;
                    v335 = *v333;
                    v333 = (double **)(*v333 + 2);
                  }
                  while (v335);
                  v336 = (double *)gpc_malloc(0x18uLL);
                  *v334 = v336;
                  *(void *)v336 = v428;
                  v336[1] = v223;
                  v336[2] = 0.0;
                  ++*(_DWORD *)*v212;
                  uint64_t v337 = v206;
                  do
                  {
                    uint64_t v337 = *(void *)(v337 + 128);
                    uint64_t v338 = *(void *)(v337 + 112);
                  }
                  while (!v338);
                  v339 = (double **)(v338 + 8);
                  do
                  {
                    v340 = v339;
                    v341 = *v339;
                    v339 = (double **)(*v339 + 2);
                  }
                  while (v341);
                  double v342 = *(double *)(v337 + 16) + *(double *)(v337 + 64) * (v223 - *(double *)(v337 + 24));
                  v343 = (double *)gpc_malloc(0x18uLL);
                  *v340 = v343;
                  double *v343 = v342;
                  v343[1] = v223;
                  v343[2] = 0.0;
                  ++**(_DWORD **)(v337 + 112);
                  void *v414 = *v212;
LABEL_361:
                  *uint64_t v212 = 0;
                  break;
                case 14:
                  if (v210 && v211)
                  {
                    v348 = v209;
                    uint64_t v429 = v213;
                    unsigned int v437 = v22;
                    unsigned int v443 = v19;
                    unsigned int v434 = v20;
                    unsigned int v420 = v21;
                    v349 = (double **)(v210 + 16);
                    do
                    {
                      v350 = v349;
                      v351 = *v349;
                      v349 = (double **)(*v349 + 2);
                    }
                    while (v351);
                    v352 = (double *)gpc_malloc(0x18uLL);
                    *v350 = v352;
                    *(void *)v352 = v429;
                    v352[1] = v223;
                    v352[2] = 0.0;
                    ++**v348;
                    v353 = (double **)(*v212 + 8);
                    do
                    {
                      v354 = v353;
                      v355 = *v353;
                      v353 = (double **)(*v353 + 2);
                    }
                    while (v355);
                    v356 = (double *)gpc_malloc(0x18uLL);
                    *v354 = v356;
                    *(void *)v356 = v429;
                    v356[1] = v223;
                    v356[2] = 0.0;
                    ++*(_DWORD *)*v212;
                    *v348 = 0;
                    *uint64_t v212 = 0;
                    uint64_t v357 = v206;
                    do
                    {
                      uint64_t v357 = *(void *)(v357 + 128);
                      uint64_t v358 = *(void *)(v357 + 112);
                    }
                    while (!v358);
                    v359 = (double **)(v358 + 8);
                    do
                    {
                      v360 = v359;
                      v361 = *v359;
                      v359 = (double **)(*v359 + 2);
                    }
                    while (v361);
                    double v362 = *(double *)(v357 + 16) + *(double *)(v357 + 64) * (v223 - *(double *)(v357 + 24));
                    v363 = (double *)gpc_malloc(0x18uLL);
                    *v360 = v363;
                    double *v363 = v362;
                    v363[1] = v223;
                    v363[2] = 0.0;
                    ++**(_DWORD **)(v357 + 112);
                    new_tristrip(&v445, v357, v362, v223);
                    uint64_t v364 = v205;
                    do
                    {
                      uint64_t v364 = *(void *)(v364 + 136);
                      uint64_t v365 = *(void *)(v364 + 112);
                    }
                    while (!v365);
                    v366 = (double **)(v365 + 16);
                    do
                    {
                      v367 = v366;
                      v368 = *v366;
                      v366 = (double **)(*v366 + 2);
                    }
                    while (v368);
                    double v369 = *(double *)(v364 + 16) + *(double *)(v364 + 64) * (v223 - *(double *)(v364 + 24));
                    v370 = (double *)gpc_malloc(0x18uLL);
                    *v367 = v370;
                    double *v370 = v369;
                    v370[1] = v223;
                    v370[2] = 0.0;
                    ++**(_DWORD **)(v364 + 112);
                    uint64_t v371 = *(void *)(v357 + 112);
                    *(void *)(v364 + 112) = v371;
                    v372 = (double **)(v371 + 16);
                    do
                    {
                      v373 = v372;
                      v374 = *v372;
                      v372 = (double **)(*v372 + 2);
                    }
                    while (v374);
                    v375 = (double *)gpc_malloc(0x18uLL);
                    *v373 = v375;
                    double *v375 = v369;
                    v375[1] = v223;
                    v375[2] = 0.0;
                    ++**(_DWORD **)(v364 + 112);
                    uint64_t v5 = v416;
                    uint64_t v21 = v420;
                    uint64_t v20 = v434;
                    uint64_t v22 = v437;
                    uint64_t v19 = v443;
                  }
                  goto LABEL_363;
                default:
                  goto LABEL_363;
              }
              uint64_t v5 = v416;
              uint64_t v21 = v418;
              uint64_t v20 = v432;
              uint64_t v22 = v436;
              uint64_t v19 = v442;
LABEL_363:
              if (*(_DWORD *)(v206 + 76)) {
                *(_DWORD *)(v205 + 92) = *(_DWORD *)(v205 + 92) == 0;
              }
              if (*(_DWORD *)(v205 + 76)) {
                *(_DWORD *)(v206 + 92) = *(_DWORD *)(v206 + 92) == 0;
              }
              if (*(_DWORD *)(v206 + 80)) {
                *(_DWORD *)(v205 + 96) = *(_DWORD *)(v205 + 96) == 0;
              }
              if (*(_DWORD *)(v205 + 80)) {
                *(_DWORD *)(v206 + 96) = *(_DWORD *)(v206 + 96) == 0;
              }
              uint64_t v344 = *(void *)(v206 + 128);
              uint64_t v345 = *(void *)(v205 + 136);
              if (v345) {
                *(void *)(v345 + 128) = v206;
              }
              if (*(_DWORD *)(v206 + 100) == 1)
              {
                while (1)
                {
                  uint64_t v344 = *(void *)(v344 + 128);
                  if (!v344) {
                    break;
                  }
                  if (*(_DWORD *)(v344 + 76) || *(_DWORD *)(v344 + 80) || *(_DWORD *)(v344 + 100) == 1) {
                    goto LABEL_380;
                  }
                }
LABEL_381:
                uint64_t v344 = 0;
                uint64_t v347 = v447;
                *(void *)(v205 + 136) = v447;
                uint64_t v346 = *(void *)(v206 + 136);
                uint64_t v447 = v346;
                goto LABEL_382;
              }
              if (!v344) {
                goto LABEL_381;
              }
LABEL_380:
              *(void *)(v205 + 136) = *(void *)(v344 + 136);
              *(void *)(v344 + 136) = *(void *)(v206 + 136);
              uint64_t v346 = *(void *)(v206 + 136);
              uint64_t v347 = *(void *)(v205 + 136);
LABEL_382:
              *(void *)(v346 + 128) = v344;
              *(void *)(v347 + 128) = v205;
              *(void *)(v206 + 136) = v345;
              uint64_t v204 = (uint64_t *)v204[4];
              if (!v204) {
                goto LABEL_403;
              }
            }
          }
          uint64_t v21 = v203;
          uint64_t v20 = v202;
          uint64_t v19 = v201;
          uint64_t v23 = v411;
LABEL_403:
          uint64_t v376 = v447;
          if (v447)
          {
            uint64_t v377 = v447;
            do
            {
              uint64_t v378 = *(void *)(v376 + 136);
              uint64_t v379 = *(void *)(v376 + 152);
              uint64_t v380 = *(void *)(v376 + 112);
              if (*(double *)(v376 + 40) != v26 || v379 == 0)
              {
                *(void *)(v376 + 120) = v380;
                *(_DWORD *)(v376 + 104) = *(_DWORD *)(v376 + 100);
                *(void *)(v376 + 84) = *(void *)(v376 + 76);
                *(void *)(v376 + 48) = *(void *)(v376 + 56);
                uint64_t v16 = v377;
              }
              else
              {
                *(void *)(v379 + 120) = v380;
                *(_DWORD *)(v379 + 104) = *(_DWORD *)(v376 + 100);
                *(_DWORD *)(v379 + 84) = *(_DWORD *)(v376 + 76);
                *(_DWORD *)(v379 + 88) = *(_DWORD *)(v376 + 80);
                uint64_t v382 = *(void *)(v376 + 128);
                uint64_t v16 = v379;
                if (v382)
                {
                  *(void *)(v382 + 136) = v379;
                  uint64_t v16 = v377;
                }
                if (v378) {
                  *(void *)(v378 + 128) = v379;
                }
                *(void *)(v379 + 128) = v382;
                *(void *)(v379 + 136) = v378;
                uint64_t v377 = v16;
              }
              *(void *)(v376 + 112) = 0;
              uint64_t v376 = v378;
            }
            while (v378);
          }
          else
          {
            uint64_t v16 = 0;
          }
          uint64_t v447 = v16;
          int v13 = v444;
          int v18 = HIDWORD(v444);
          uint64_t v17 = v16;
        }
      }
      while (v18 < v13);
      v383 = v445;
      v384 = (_DWORD *)v407;
      *(void *)(v407 + 8) = 0;
      if (v383)
      {
        unsigned int v385 = 0;
        v386 = v383;
        do
        {
          if (*v386 > 2) {
            ++v385;
          }
          v386 = (int *)*((void *)v386 + 3);
        }
        while (v386);
        *(_DWORD *)uint64_t v407 = v385;
        if (v385)
        {
          int v387 = 0;
          *(void *)(v407 + 8) = gpc_malloc(16 * v385);
          do
          {
            v388 = v383;
            v383 = (int *)*((void *)v383 + 3);
            uint64_t v389 = *v388;
            if ((int)v389 < 3)
            {
              v397 = (void *)*((void *)v388 + 1);
              if (v397)
              {
                do
                {
                  v398 = (void *)v397[2];
                  gpc_free(v397);
                  v397 = v398;
                }
                while (v398);
              }
              v399 = (void *)*((void *)v388 + 2);
              if (v399)
              {
                do
                {
                  v400 = (void *)v399[2];
                  gpc_free(v399);
                  v399 = v400;
                }
                while (v400);
              }
            }
            else
            {
              *(_DWORD *)(*(void *)(v407 + 8) + 16 * v387) = v389;
              *(void *)(*(void *)(v407 + 8) + 16 * v387 + 8) = gpc_malloc(16 * v389);
              unint64_t v390 = *((void *)v388 + 1);
              unint64_t v391 = *((void *)v388 + 2);
              BOOL v392 = v390 != 0;
              BOOL v393 = v391 != 0;
              if (*(_OWORD *)(v388 + 2) != 0)
              {
                int v394 = 0;
                do
                {
                  if (v392)
                  {
                    v395 = *(void **)(v390 + 16);
                    *(_OWORD *)(*(void *)(*(void *)(v407 + 8) + 16 * v387 + 8) + 16 * v394++) = *(_OWORD *)v390;
                    gpc_free((void *)v390);
                    unint64_t v390 = (unint64_t)v395;
                    if (v393) {
                      goto LABEL_435;
                    }
                  }
                  else
                  {
                    unint64_t v390 = 0;
                    if (v393)
                    {
LABEL_435:
                      v396 = *(void **)(v391 + 16);
                      *(_OWORD *)(*(void *)(*(void *)(v407 + 8) + 16 * v387 + 8) + 16 * v394++) = *(_OWORD *)v391;
                      gpc_free((void *)v391);
                      unint64_t v391 = (unint64_t)v396;
                      goto LABEL_436;
                    }
                  }
                  unint64_t v391 = 0;
LABEL_436:
                  BOOL v392 = v390 != 0;
                  BOOL v393 = v391 != 0;
                }
                while (v390 | v391);
              }
              ++v387;
            }
            gpc_free(v388);
          }
          while (v383);
        }
LABEL_446:
        v401 = v448;
        if (v448)
        {
          do
          {
            v402 = (void *)v401[4];
            gpc_free(v401);
            v401 = v402;
          }
          while (v402);
        }
        v403 = v446;
        if (v446)
        {
          do
          {
            v404 = (void *)v403[2];
            gpc_free(v403);
            v403 = v404;
          }
          while (v404);
        }
        if (v405) {
          gpc_free(v405);
        }
        if (v406) {
          gpc_free(v406);
        }
        double v15 = v408;
        if (v408) {
          goto LABEL_455;
        }
        return;
      }
    }
    _DWORD *v384 = 0;
    goto LABEL_446;
  }
  *(_DWORD *)uint64_t v407 = 0;
  *(void *)(v407 + 8) = 0;
  if (v11) {
    gpc_free(v11);
  }
  if (v12)
  {
    double v15 = v12;
LABEL_455:
    gpc_free(v15);
  }
}

double *new_tristrip(void *a1, uint64_t a2, double a3, double a4)
{
  do
  {
    int v7 = a1;
    uint64_t v8 = *a1;
    a1 = (void *)(*a1 + 24);
  }
  while (v8);
  uint64_t v9 = gpc_malloc(0x28uLL);
  *int v7 = v9;
  v9[3] = 0;
  *(void *)(*v7 + 8) = 0;
  *(void *)(*v7 + 16) = 0;
  uint64_t v10 = (_DWORD *)*v7;
  *uint64_t v10 = 1;
  double v11 = (double **)(v10 + 2);
  do
  {
    double v12 = v11;
    int v13 = *v11;
    double v11 = (double **)(*v11 + 2);
  }
  while (v13);
  double result = (double *)gpc_malloc(0x18uLL);
  *double v12 = result;
  *double result = a3;
  result[1] = a4;
  result[2] = 0.0;
  *(void *)(a2 + 112) = *v7;
  return result;
}

char *create_contour_bboxes(int *a1)
{
  uint64_t v1 = *a1;
  if (!v1) {
    return 0;
  }
  double result = (char *)gpc_malloc(32 * v1);
  uint64_t v4 = *a1;
  if ((int)v4 >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = *((void *)a1 + 2);
    int64x2_t v7 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    int64x2_t v8 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
    do
    {
      uint64_t v9 = (int64x2_t *)&result[32 * v5];
      *uint64_t v9 = v7;
      v9[1] = v8;
      uint64_t v10 = *(unsigned int *)(v6 + 16 * v5);
      if ((int)v10 >= 1)
      {
        double v11 = (double *)(*(void *)(v6 + 16 * v5 + 8) + 8);
        double v12 = 1.79769313e308;
        double v13 = -1.79769313e308;
        double v14 = -1.79769313e308;
        double v15 = 1.79769313e308;
        do
        {
          double v16 = *(v11 - 1);
          if (v16 < v15)
          {
            *(double *)v9->i64 = v16;
            double v15 = v16;
          }
          double v17 = *v11;
          if (*v11 < v12)
          {
            *(double *)&v9->i64[1] = v17;
            double v12 = v17;
          }
          if (v16 > v14)
          {
            *(double *)v9[1].i64 = v16;
            double v14 = v16;
          }
          if (v17 > v13)
          {
            *(double *)&v9[1].i64[1] = v17;
            double v13 = v17;
          }
          v11 += 2;
          --v10;
        }
        while (v10);
      }
      ++v5;
    }
    while (v5 != v4);
  }
  return result;
}

uint64_t *insert_bound(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  if (*result)
  {
    double v3 = *(double *)(a2 + 16);
    while (1)
    {
      double v4 = *(double *)(v2 + 16);
      if (v3 < v4 || v3 == v4 && *(double *)(a2 + 64) < *(double *)(v2 + 64)) {
        break;
      }
      double result = (uint64_t *)(v2 + 160);
      uint64_t v2 = *(void *)(v2 + 160);
      if (!v2) {
        goto LABEL_7;
      }
    }
    *double result = a2;
    *(void *)(a2 + 160) = v2;
  }
  else
  {
LABEL_7:
    *double result = a2;
  }
  return result;
}

double *bound_list(double **a1, double a2)
{
  double v3 = a1;
  double v4 = *a1;
  if (!*a1)
  {
LABEL_9:
    int64x2_t v7 = (double *)gpc_malloc(0x18uLL);
    double v4 = 0;
    goto LABEL_10;
  }
  double v5 = *v4;
  if (*v4 > a2)
  {
LABEL_7:
    int64x2_t v7 = (double *)gpc_malloc(0x18uLL);
LABEL_10:
    *double v3 = v7;
    *int64x2_t v7 = a2;
    v7[1] = 0.0;
    *((void *)*v3 + 2) = v4;
    uint64_t v6 = *v3;
    return v6 + 1;
  }
  while (1)
  {
    uint64_t v6 = v4;
    if (v5 >= a2) {
      return v6 + 1;
    }
    double v4 = (double *)*((void *)v4 + 2);
    if (!v4)
    {
      double v3 = (double **)(v6 + 2);
      goto LABEL_9;
    }
    double v5 = *v4;
    if (*v4 > a2)
    {
      double v3 = (double **)(v6 + 2);
      goto LABEL_7;
    }
  }
}

void sub_2236DCB90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Unwind_Resume(a1);
}

void sub_2236DD6B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,void *a58,void *a59)
{
  _Unwind_Resume(a1);
}

void sub_2236DD7AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,void *a30)
{
  _Unwind_Resume(a1);
}

void sub_2236DD8D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,void *a29)
{
  _Unwind_Resume(a1);
}

void sub_2236DDA24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,void *a29)
{
  _Unwind_Resume(a1);
}

uint64_t TSDIntPointFromCGPoint(double a1)
{
  return (uint64_t)a1;
}

double TSDIntPointFromCGPointWithScale(double a1, double a2, double a3)
{
  return a2 * a3;
}

double CGPointFromIntPoint(uint64_t a1)
{
  return (double)a1;
}

BOOL TSDIntPointEquals(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a1 == a3 && a2 == a4;
}

double TSDIntPointMultiplyScalar(double a1, uint64_t a2, uint64_t a3)
{
  return (double)a3 * a1;
}

uint64_t TSDIntRectMake@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  *a5 = result;
  a5[1] = a2;
  a5[2] = a3;
  a5[3] = a4;
  return result;
}

CGFloat TSDIntRectFromCGRect@<D0>(uint64_t *a1@<X8>, CGFloat a2@<D0>, CGFloat a3@<D1>, CGFloat a4@<D2>, CGFloat a5@<D3>)
{
  uint64_t v10 = (uint64_t)a2;
  uint64_t v11 = (uint64_t)a3;
  uint64_t v12 = (uint64_t)(CGRectGetMaxX(*(CGRect *)&a2) - (double)(uint64_t)a2);
  v14.origin.CGFloat x = a2;
  v14.origin.CGFloat y = a3;
  v14.size.CGFloat width = a4;
  v14.size.CGFloat height = a5;
  CGFloat result = CGRectGetMaxY(v14) - (double)(uint64_t)a3;
  *a1 = v10;
  a1[1] = v11;
  a1[2] = v12;
  a1[3] = (uint64_t)result;
  return result;
}

CGFloat TSDIntRectFromCGRectWithScale@<D0>(uint64_t *a1@<X8>, double a2@<D0>, CGFloat a3@<D1>, CGFloat a4@<D2>, CGFloat a5@<D3>, double a6@<D4>)
{
  double v7 = TSDMultiplyRectScalar(a2, a3, a4, a5, a6);

  return TSDIntRectFromCGRect(a1, v7, v8, v9, v10);
}

double CGRectFromIntRect(uint64_t *a1)
{
  return (double)*a1;
}

int64x2_t TSDIntRectMultiplyScalar@<Q0>(int64x2_t *a1@<X0>, int64x2_t *a2@<X8>, double a3@<D0>)
{
  int64x2_t v3 = vcvtq_s64_f64(vmulq_n_f64(vcvtq_f64_s64(*a1), a3));
  int64x2_t result = vcvtq_s64_f64(vmulq_n_f64(vcvtq_f64_s64(a1[1]), a3));
  *a2 = v3;
  a2[1] = result;
  return result;
}

BOOL CGRectContainsIntPoint(uint64_t a1, uint64_t a2, double a3, double a4, double a5, double a6)
{
  v7.CGFloat x = (double)a1;
  v7.CGFloat y = (double)a2;
  return CGRectContainsPoint(*(CGRect *)&a3, v7);
}

BOOL TSDIntRectContainsPointInclusive(void *a1, uint64_t a2, uint64_t a3)
{
  if (a2 >= *a1 && a2 <= a1[2] + *a1 && (uint64_t v3 = a1[1], a3 >= v3)) {
    return a3 <= a1[3] + v3;
  }
  else {
    return 0;
  }
}

uint64_t TSDIntRectGetMinX(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t TSDIntRectGetMaxX(void *a1)
{
  return a1[2] + *a1;
}

uint64_t TSDIntRectGetMinY(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t TSDIntRectGetMaxY(uint64_t a1)
{
  return *(void *)(a1 + 24) + *(void *)(a1 + 8);
}

BOOL TSDIntRectContainsPoint(void *a1, uint64_t a2, uint64_t a3)
{
  if (a2 <= *a1) {
    return 0;
  }
  if (a2 >= a1[2] + *a1) {
    return 0;
  }
  uint64_t v3 = a1[1];
  return a3 > v3 && a3 < a1[3] + v3;
}

BOOL TSDIntRectIsEmpty(uint64_t a1)
{
  return !*(void *)(a1 + 16) && *(void *)(a1 + 24) == 0;
}

int64x2_t TSDIntRectInset@<Q0>(int64x2_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int64x2_t *a4@<X8>)
{
  uint64_t v4 = a1->i64[1] + a3;
  v5.i64[0] = a2;
  v5.i64[1] = a3;
  a4->i64[0] = a1->i64[0] + a2;
  a4->i64[1] = v4;
  int64x2_t result = vsubq_s64(a1[1], vaddq_s64(v5, v5));
  a4[1] = result;
  return result;
}

uint64_t TSDIntRectCenter(void *a1)
{
  return *a1 + a1[2] / 2;
}

uint64_t TSDIntRectGetMidX(void *a1)
{
  return *a1 + a1[2] / 2;
}

uint64_t TSDIntRectGetMidY(uint64_t a1)
{
  return *(void *)(a1 + 8) + *(void *)(a1 + 24) / 2;
}

int64x2_t TSDIntRectGrowToPoint@<Q0>(int64x2_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int64x2_t *a4@<X8>)
{
  v4.i64[0] = a2;
  v4.i64[1] = a3;
  int64x2_t v5 = (int64x2_t)vbslq_s8((int8x16_t)vcgtq_s64(v4, *a1), *(int8x16_t *)a1, (int8x16_t)v4);
  int64x2_t v6 = vaddq_s64(a1[1], *a1);
  int64x2_t result = vsubq_s64((int64x2_t)vbslq_s8((int8x16_t)vcgtq_s64(v6, v4), (int8x16_t)v6, (int8x16_t)v4), v5);
  *a4 = v5;
  a4[1] = result;
  return result;
}

uint64_t TSDDirectionIntDelta(uint64_t a1)
{
  return TSDDirectionIntDelta_deltas[2 * a1];
}

uint64_t TSDIntAddPoints(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 + a1;
}

uint64_t TSDIntSubtractPoints(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a1 - a3;
}

uint64_t TSDIntDotPoints(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a4 * a2 + a3 * a1;
}

uint64_t TSDIntOrthogonalDistance(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a1 - a3;
  if (a1 - a3 < 0) {
    uint64_t v4 = a3 - a1;
  }
  uint64_t v5 = a2 - a4;
  if (a2 - a4 < 0) {
    uint64_t v5 = a4 - a2;
  }
  return v4 + v5;
}

__n128 TSDExpandShapeRectToIncludePoint@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _OWORD *a4@<X8>)
{
  uint64_t v7 = *(void *)(a1 + 24);
  if (!v7)
  {
    if (!*(void *)(a1 + 16)) {
      goto LABEL_13;
    }
    goto LABEL_9;
  }
  long long v9 = *(_OWORD *)(a1 + 16);
  v20[0] = *(_OWORD *)a1;
  v20[1] = v9;
  uint64_t MinX = TSDIntRectGetMinX((uint64_t)v20);
  uint64_t v11 = *(void *)(a1 + 16);
  if (a2 == MinX)
  {
    --*(void *)a1;
    *(void *)(a1 + 16) = ++v11;
  }
  long long v12 = *(_OWORD *)(a1 + 16);
  v19[0] = *(_OWORD *)a1;
  v19[1] = v12;
  if (a2 == TSDIntRectGetMaxX(v19)) {
    *(void *)(a1 + 16) = ++v11;
  }
  if (v11)
  {
LABEL_9:
    long long v13 = *(_OWORD *)(a1 + 16);
    v18[0] = *(_OWORD *)a1;
    v18[1] = v13;
    if (a3 == TSDIntRectGetMinY((uint64_t)v18))
    {
      --*(void *)(a1 + 8);
      *(void *)(a1 + 24) = ++v7;
    }
    long long v14 = *(_OWORD *)(a1 + 16);
    v17[0] = *(_OWORD *)a1;
    v17[1] = v14;
    if (a3 == TSDIntRectGetMaxY((uint64_t)v17)) {
      *(void *)(a1 + 24) = v7 + 1;
    }
  }
LABEL_13:
  __n128 result = *(__n128 *)a1;
  long long v16 = *(_OWORD *)(a1 + 16);
  *a4 = *(_OWORD *)a1;
  a4[1] = v16;
  return result;
}

void sub_2236E0714(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25)
{
  if (__p) {
    operator delete(__p);
  }
  if (a21) {
    operator delete(a21);
  }
  if (a24) {
    operator delete(a24);
  }
  _Unwind_Resume(exception_object);
}

void routePath()
{
  uint64_t v0 = 0;
  createGraph();
}

void sub_2236E0FE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, void *a15, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  if (a15) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_2236E18BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29)
{
  if (__p) {
    operator delete(__p);
  }
  uint64_t v31 = *(void **)(v29 - 160);
  if (v31)
  {
    *(void *)(v29 - 152) = v31;
    operator delete(v31);
  }
  uint64_t v32 = *(void **)(v29 - 136);
  if (v32)
  {
    *(void *)(v29 - 128) = v32;
    operator delete(v32);
  }
  _Unwind_Resume(exception_object);
}

BOOL nodeCompare(uint64_t a1, uint64_t a2)
{
  return TSDOrthoPathCost::operator<((unsigned __int8 *)(a2 + 128), (unsigned __int8 *)(a1 + 128));
}

BOOL TSDOrthoPathCost::operator<(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2 = *a1;
  if (v2 != *a2) {
    return v2 == 0;
  }
  int v2 = a1[1];
  if (v2 != a2[1]) {
    return v2 == 0;
  }
  uint64_t v3 = *((void *)a1 + 1);
  uint64_t v4 = *((void *)a2 + 1);
  BOOL v5 = v3 < v4;
  if (v3 != v4) {
    return v5;
  }
  uint64_t v6 = *((void *)a1 + 2);
  uint64_t v7 = *((void *)a2 + 2);
  BOOL v5 = v6 < v7;
  if (v6 != v7) {
    return v5;
  }
  double v8 = *((double *)a1 + 3);
  double v9 = *((double *)a2 + 3);
  BOOL v10 = v8 < v9;
  if (v8 != v9) {
    return v10;
  }
  double v11 = *((double *)a1 + 4);
  double v12 = *((double *)a2 + 4);
  BOOL v10 = v11 < v12;
  if (v11 != v12) {
    return v10;
  }
  double v14 = *((double *)a1 + 5);
  double v15 = *((double *)a2 + 5);
  return v14 == v15 || v14 < v15;
}

void __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> addPointToXYs(uint64_t a1, uint64_t a2, uint64_t **a3, uint64_t **a4)
{
  uint64_t v5 = a2;
  std::__tree<long>::__emplace_unique_key_args<long,long const&>(a3, &v6, &v6);
  std::__tree<long>::__emplace_unique_key_args<long,long const&>(a4, &v5, &v5);
}

uint64_t shapeAnchorInDirection(uint64_t a1, uint64_t a2)
{
  switch(a2)
  {
    case 0:
      uint64_t v3 = *(void *)(a1 + 32);
      long long v4 = *(_OWORD *)(a1 + 16);
      v15[0] = *(_OWORD *)a1;
      v15[1] = v4;
      uint64_t MaxY = TSDIntRectGetMaxY((uint64_t)v15);
      goto LABEL_5;
    case 1:
      uint64_t v3 = *(void *)(a1 + 32);
      long long v7 = *(_OWORD *)(a1 + 16);
      v14[0] = *(_OWORD *)a1;
      v14[1] = v7;
      uint64_t MaxY = TSDIntRectGetMinY((uint64_t)v14);
LABEL_5:
      uint64_t v8 = MaxY;
      uint64_t MinX = v3;
      goto LABEL_9;
    case 2:
      long long v10 = *(_OWORD *)(a1 + 16);
      v13[0] = *(_OWORD *)a1;
      v13[1] = v10;
      uint64_t MinX = TSDIntRectGetMinX((uint64_t)v13);
      goto LABEL_8;
    case 3:
      long long v11 = *(_OWORD *)(a1 + 16);
      v12[0] = *(_OWORD *)a1;
      v12[1] = v11;
      uint64_t MinX = TSDIntRectGetMaxX(v12);
LABEL_8:
      uint64_t v8 = *(void *)(a1 + 40);
LABEL_9:
      uint64_t result = TSDIntPointMake(MinX, v8);
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t insertShapeEdgeNodes(void **a1, uint64_t *a2, _OWORD *a3, int a4)
{
  uint64_t v8 = 0;
  uint64_t v36 = (uint64_t)(a1 + 2);
  if (a4) {
    char v9 = 66;
  }
  else {
    char v9 = 2;
  }
  char v37 = v9;
  do
  {
    long long v10 = a3[1];
    long long v38 = *a3;
    long long v39 = v10;
    uint64_t v11 = *a2;
    uint64_t v12 = a2[1];
    long long v13 = a2;
    if (TSDIntRectContainsPoint(&v38, *a2, v12))
    {
      do
      {
        long long v13 = (uint64_t *)v13[v8 + 2];
        long long v14 = a3[1];
        long long v38 = *a3;
        long long v39 = v14;
      }
      while (TSDIntRectContainsPoint(&v38, *v13, v13[1]));
      uint64_t v11 = *v13;
      uint64_t v12 = v13[1];
    }
    else
    {
      long long v13 = a2;
    }
    uint64_t v15 = shapeAnchorInDirection((uint64_t)a3, v8);
    uint64_t v17 = v16;
    uint64_t result = TSDIntPointEquals(v15, v16, v11, v12);
    if ((result & 1) == 0)
    {
      v4 &= 0x80u;
      uint64_t v19 = (char *)a1[1];
      uint64_t v20 = (char *)a1[2];
      if (v19 >= v20)
      {
        uint64_t v22 = 0x2E8BA2E8BA2E8BA3 * ((v19 - (unsigned char *)*a1) >> 3);
        unint64_t v23 = v22 + 1;
        if ((unint64_t)(v22 + 1) > 0x2E8BA2E8BA2E8BALL) {
          abort();
        }
        unint64_t v24 = 0x2E8BA2E8BA2E8BA3 * ((v20 - (unsigned char *)*a1) >> 3);
        if (2 * v24 > v23) {
          unint64_t v23 = 2 * v24;
        }
        if (v24 >= 0x1745D1745D1745DLL) {
          unint64_t v25 = 0x2E8BA2E8BA2E8BALL;
        }
        else {
          unint64_t v25 = v23;
        }
        if (v25) {
          double v26 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<TSDOrthoGraphPoint>>(v36, v25);
        }
        else {
          double v26 = 0;
        }
        uint64_t v27 = &v26[88 * v22];
        *(void *)uint64_t v27 = v15;
        *((void *)v27 + 1) = v17;
        *((_OWORD *)v27 + 1) = 0u;
        *((_OWORD *)v27 + 2) = 0u;
        *((_OWORD *)v27 + 3) = 0u;
        *((_OWORD *)v27 + 4) = 0u;
        v27[80] = v4;
        uint64_t v29 = (char *)*a1;
        double v28 = (char *)a1[1];
        uint64_t v30 = v27;
        if (v28 != *a1)
        {
          do
          {
            long long v31 = *(_OWORD *)(v28 - 88);
            *(_OWORD *)(v30 - 72) = *(_OWORD *)(v28 - 72);
            *(_OWORD *)(v30 - 88) = v31;
            long long v32 = *(_OWORD *)(v28 - 56);
            long long v33 = *(_OWORD *)(v28 - 40);
            long long v34 = *(_OWORD *)(v28 - 24);
            *((_DWORD *)v30 - 2) = *((_DWORD *)v28 - 2);
            *(_OWORD *)(v30 - 24) = v34;
            *(_OWORD *)(v30 - 40) = v33;
            *(_OWORD *)(v30 - 56) = v32;
            v30 -= 88;
            v28 -= 88;
          }
          while (v28 != v29);
          double v28 = (char *)*a1;
        }
        uint64_t v21 = v27 + 88;
        *a1 = v30;
        a1[1] = v27 + 88;
        a1[2] = &v26[88 * v25];
        if (v28) {
          operator delete(v28);
        }
      }
      else
      {
        *(void *)uint64_t v19 = v15;
        *((void *)v19 + 1) = v17;
        *((_OWORD *)v19 + 1) = 0u;
        *((_OWORD *)v19 + 2) = 0u;
        *((_OWORD *)v19 + 3) = 0u;
        *((_OWORD *)v19 + 4) = 0u;
        uint64_t v21 = v19 + 88;
        v19[80] = v4;
      }
      a1[1] = v21;
      uint64_t result = TSDDirectionOpposite(v8);
      *(void *)&v21[8 * v8 - 72] = v13;
      uint64_t v35 = &v13[result];
      *(void *)&v21[8 * result - 72] = v35[2];
      *(void *)(v35[2] + 8 * v8 + 16) = v21 - 88;
      v35[2] = (uint64_t)(v21 - 88);
      long long v13 = (uint64_t *)(v21 - 88);
    }
    *((unsigned char *)v13 + 80) = v37 | v13[10] & 0xBD;
    *((void *)a3 + v8++ + 7) = v13;
  }
  while (v8 != 4);
  return result;
}

void createGraph()
{
  uint64_t v0 = *MEMORY[0x263EF8340];
  operator new();
}

void sub_2236E2614(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,void *__p,uint64_t a51)
{
  if (__p) {
    operator delete(__p);
  }
  std::__tree<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::__map_value_compare<std::pair<unsigned short,EQKit::Config::Operator::Form>,std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::less<std::pair<unsigned short,EQKit::Config::Operator::Form>>,true>,std::allocator<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>>>::destroy(v51 - 200, *(void **)(v51 - 192));
  std::__tree<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::__map_value_compare<std::pair<unsigned short,EQKit::Config::Operator::Form>,std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::less<std::pair<unsigned short,EQKit::Config::Operator::Form>>,true>,std::allocator<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>>>::destroy(v51 - 176, *(void **)(v51 - 168));
  _Unwind_Resume(a1);
}

void std::vector<TSDOrthoGraphPoint>::reserve(void **a1, unint64_t a2)
{
  char v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (0x2E8BA2E8BA2E8BA3 * ((v4 - (unsigned char *)*a1) >> 3) < a2)
  {
    if (a2 >= 0x2E8BA2E8BA2E8BBLL) {
      abort();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<TSDOrthoGraphPoint>>(v3, a2);
    long long v7 = &v6[v5];
    char v9 = &v6[88 * v8];
    uint64_t v11 = (char *)*a1;
    long long v10 = (char *)a1[1];
    uint64_t v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        long long v13 = *(_OWORD *)(v10 - 88);
        *(_OWORD *)(v12 - 72) = *(_OWORD *)(v10 - 72);
        *(_OWORD *)(v12 - 88) = v13;
        long long v14 = *(_OWORD *)(v10 - 56);
        long long v15 = *(_OWORD *)(v10 - 40);
        long long v16 = *(_OWORD *)(v10 - 24);
        *((_DWORD *)v12 - 2) = *((_DWORD *)v10 - 2);
        *(_OWORD *)(v12 - 24) = v16;
        *(_OWORD *)(v12 - 40) = v15;
        *(_OWORD *)(v12 - 56) = v14;
        v12 -= 88;
        v10 -= 88;
      }
      while (v10 != v11);
      long long v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void std::vector<TSDOrthoGraphPoint *>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 8 * a2;
    }
  }
  else
  {
    std::vector<TSDOrthoGraphPoint *>::__append((void **)a1, a2 - v2);
  }
}

double othoPathOverlap(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1)
  {
    uint64_t v2 = a1;
    uint64_t v3 = *(uint64_t **)a1;
    double v4 = 0.0;
    double v5 = 0.0;
    double v6 = 0.0;
    double v7 = 0.0;
    do
    {
      char v8 = *(unsigned char *)(v2 + 176);
      uint64_t v2 = v1;
      char v9 = *(uint64_t **)v1;
      if ((v8 & 2) == 0 || (*(unsigned char *)(v1 + 176) & 2) == 0)
      {
        uint64_t v10 = TSDIntSubtractPoints(*v3, v3[1], *v9);
        double v12 = (double)v11;
        double v13 = -0.0;
        if (v10 == 0 && v11 > 0) {
          double v14 = (double)v11;
        }
        else {
          double v14 = -0.0;
        }
        double v4 = v4 + v14;
        if (v10 != 0 || v11 >= 0) {
          double v12 = 0.0;
        }
        double v5 = v5 - v12;
        double v15 = (double)v10;
        if (v11 == 0 && v10 > 0) {
          double v13 = (double)v10;
        }
        double v7 = v7 + v13;
        if (v11 != 0 || v10 >= 0) {
          double v15 = 0.0;
        }
        double v6 = v6 - v15;
      }
      uint64_t v1 = *(void *)(v2 + 24);
      uint64_t v3 = v9;
    }
    while (v1);
  }
  else
  {
    double v7 = 0.0;
    double v6 = 0.0;
    double v5 = 0.0;
    double v4 = 0.0;
  }
  return fmin(v6, v7) + fmin(v4, v5);
}

double othoPathVariance(uint64_t a1)
{
  __p = 0;
  uint64_t v22 = 0;
  unint64_t v23 = 0;
  uint64_t v2 = (uint64_t *)(a1 + 24);
  uint64_t v1 = *(uint64_t ***)(a1 + 24);
  if (v1)
  {
    uint64_t v3 = 0;
    do
    {
      double v4 = (double)TSDIntOrthogonalDistance(**(void **)a1, *(void *)(*(void *)a1 + 8), **v1, (*v1)[1]);
      if (v3 >= v23)
      {
        double v5 = __p;
        uint64_t v6 = v3 - __p;
        unint64_t v7 = v6 + 1;
        if ((unint64_t)(v6 + 1) >> 61) {
          abort();
        }
        uint64_t v8 = (char *)v23 - (char *)__p;
        if (((char *)v23 - (char *)__p) >> 2 > v7) {
          unint64_t v7 = v8 >> 2;
        }
        if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v9 = v7;
        }
        if (v9)
        {
          uint64_t v10 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLayoutContext *>>((uint64_t)&v23, v9);
          double v5 = __p;
          uint64_t v3 = v22;
        }
        else
        {
          uint64_t v10 = 0;
        }
        uint64_t v11 = (double *)&v10[8 * v6];
        double *v11 = v4;
        double v12 = v11 + 1;
        while (v3 != v5)
        {
          uint64_t v13 = *((void *)v3-- - 1);
          *((void *)v11-- - 1) = v13;
        }
        __p = v11;
        unint64_t v23 = (double *)&v10[8 * v9];
        if (v5) {
          operator delete(v5);
        }
        uint64_t v3 = v12;
      }
      else
      {
        *v3++ = v4;
      }
      uint64_t v22 = v3;
      a1 = *v2;
      uint64_t v14 = *v2;
      double v15 = *(uint64_t ***)(v14 + 24);
      uint64_t v2 = (uint64_t *)(v14 + 24);
      uint64_t v1 = v15;
    }
    while (v15);
    long long v16 = __p;
    double v17 = 0.0;
    if (__p != v3)
    {
      int v18 = __p;
      do
      {
        double v19 = *v18++;
        double v17 = v17 + v19 * v19;
      }
      while (v18 != v3);
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v3 = 0;
    long long v16 = 0;
    double v17 = 0.0;
  }
  return v17 / (double)(unint64_t)(v3 - v16);
}

void sub_2236E2A38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t pathByAddingGraphPoint(uint64_t **a1, uint64_t *a2)
{
  if (a2)
  {
    TSDIntOrthogonalDistance(**a1, (*a1)[1], *a2, a2[1]);
    double v4 = a1;
    do
    {
      if (*v4 == a2) {
        break;
      }
      double v4 = (uint64_t **)v4[3];
    }
    while (v4);
    operator new();
  }
  return 0;
}

uint64_t nodeInDirection(uint64_t **a1, uint64_t a2)
{
  return pathByAddingGraphPoint(a1, (uint64_t *)(*a1)[a2 + 2]);
}

uint64_t extendInDirection(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)(result + 176) |= 2u;
  do
  {
    if (*(void *)result == a3) {
      break;
    }
    uint64_t result = pathByAddingGraphPoint((uint64_t **)result, *(uint64_t **)(*(void *)result + 8 * a2 + 16));
  }
  while (result);
  return result;
}

uint64_t estimateNumberOfCorners(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = TSDDirectionOpposite(a6);
  if (a1 == a4 && a2 == a5)
  {
    if (a3 == a6) {
      unsigned int v13 = 4;
    }
    else {
      unsigned int v13 = 1;
    }
    BOOL v14 = v12 == a3;
LABEL_7:
    if (v14) {
      return 0;
    }
    else {
      return v13;
    }
  }
  if (v12 == a3)
  {
    uint64_t v16 = TSDDirectionIntDelta(a3);
    uint64_t v18 = v17;
    uint64_t v19 = TSDIntSubtractPoints(a4, a5, a1);
    if (TSDIntDotPoints(v16, v18, v19, v20) < 0) {
      return 4;
    }
    double v21 = TSDDirectionDelta(a3);
    if (a1 == a4 && v21 == 0.0) {
      return 0;
    }
    BOOL v14 = a2 == a5 && v22 == 0.0;
    unsigned int v13 = 2;
    goto LABEL_7;
  }
  if (a3 == a6)
  {
    double v23 = TSDDirectionDelta(a6);
    uint64_t result = 4;
    if (a1 != a4 || v23 != 0.0)
    {
      if (a2 == a5 && v24 == 0.0) {
        return 4;
      }
      else {
        return 2;
      }
    }
  }
  else
  {
    uint64_t v26 = TSDDirectionIntDelta(a3);
    uint64_t v28 = v27;
    uint64_t v29 = TSDIntSubtractPoints(a4, a5, a1);
    uint64_t v31 = TSDIntDotPoints(v26, v28, v29, v30);
    uint64_t v32 = TSDDirectionIntDelta(a6);
    uint64_t v34 = v33;
    uint64_t v35 = TSDIntSubtractPoints(a1, a2, a4);
    if ((v31 | TSDIntDotPoints(v32, v34, v35, v36)) >= 0) {
      return 1;
    }
    else {
      return 3;
    }
  }
  return result;
}

uint64_t estimateCostToShape@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, double *a5@<X8>)
{
  *((_OWORD *)a5 + 1) = 0u;
  *((_OWORD *)a5 + 2) = 0u;
  *(_OWORD *)a5 = 0u;
  uint64_t v8 = *(uint64_t **)(a3 + 8 * a4 + 88);
  uint64_t v9 = *a1;
  int v31 = *((unsigned __int8 *)a1 + 16);
  uint64_t v32 = a5;
  uint64_t v30 = v8;
  if (*((unsigned char *)a1 + 16) || (*(unsigned char *)(v9 + 80) & 8) != 0)
  {
    uint64_t v24 = *(void *)v9;
    uint64_t v25 = *(void *)(v9 + 8);
    uint64_t v26 = *v8;
    uint64_t v27 = v8[1];
    a5[4] = (double)TSDIntOrthogonalDistance(*(void *)v9, v25, *v8, v27);
    uint64_t result = estimateNumberOfCorners(v24, v25, a1[1], v26, v27, a4);
    uint64_t v19 = a4;
    uint64_t v20 = result;
  }
  else
  {
    uint64_t v10 = *(void *)a2;
    uint64_t v11 = *(void *)(a2 + 8);
    uint64_t v33 = *(void *)v9;
    uint64_t v12 = *(void *)(v9 + 8);
    double v13 = (double)TSDIntOrthogonalDistance(*(void *)v9, v12, *(void *)a2, v11);
    BOOL v14 = v8;
    uint64_t v15 = *v8;
    uint64_t v16 = v14[1];
    uint64_t v17 = 0;
    a5[4] = v13 + (double)TSDIntOrthogonalDistance(v10, v11, v15, v16);
    uint64_t v18 = a1[1];
    uint64_t v19 = a4;
    uint64_t v20 = 0x7FFFFFFFFFFFFFFFLL;
    do
    {
      int v21 = estimateNumberOfCorners(v33, v12, v18, v10, v11, v17);
      uint64_t v22 = TSDDirectionOpposite(v17);
      uint64_t result = estimateNumberOfCorners(v10, v11, v22, v15, v16, v19);
      if (v20 >= (result + v21)) {
        uint64_t v20 = (result + v21);
      }
      ++v17;
    }
    while (v17 != 4);
  }
  *((void *)v32 + 1) = v20;
  if (!v31 && (*(unsigned char *)(a2 + 80) & 0x10) != 0
    || (v30[10] & 0x10) != 0
    || (*(unsigned char *)(*(void *)(a3 + 8 * v19 + 56) + 80) & 0x10) != 0)
  {
    *((unsigned char *)v32 + 1) = 1;
  }
  return result;
}

double estimateCost@<D0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned __int8 *a4@<X8>)
{
  uint64_t v8 = 0;
  *(_OWORD *)a4 = xmmword_22383AB58;
  *((_OWORD *)a4 + 1) = unk_22383AB68;
  *((_OWORD *)a4 + 2) = xmmword_22383AB78;
  do
  {
    estimateCostToShape(a1, a2, a3, v8, v12);
    if (TSDOrthoPathCost::operator<(a4, (unsigned __int8 *)v12))
    {
      long long v9 = *((_OWORD *)a4 + 1);
      long long v13 = *(_OWORD *)a4;
      long long v14 = v9;
      long long v15 = *((_OWORD *)a4 + 2);
    }
    else
    {
      estimateCostToShape(a1, a2, a3, v8, (double *)&v13);
    }
    long long v10 = v14;
    *(_OWORD *)a4 = v13;
    *((_OWORD *)a4 + 1) = v10;
    double result = *(double *)&v15;
    *((_OWORD *)a4 + 2) = v15;
    ++v8;
  }
  while (v8 != 4);
  return result;
}

uint64_t *std::__tree<long>::__emplace_unique_key_args<long,long const&>(uint64_t **a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = a1 + 1;
  double v5 = a1[1];
  if (v5)
  {
    uint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        uint64_t v9 = v5[4];
        if (v7 >= v9) {
          break;
        }
        double v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      double v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v8 = a1 + 1;
LABEL_10:
    long long v10 = (uint64_t *)operator new(0x28uLL);
    v10[4] = *a3;
    std::__tree<std::__value_type<std::string,unsigned short>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned short>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned short>>>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return v10;
  }
  return (uint64_t *)v8;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<TSDOrthoGraphPoint>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2E8BA2E8BA2E8BBLL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(88 * a2);
}

void std::vector<TSDOrthoGraphPoint *>::__append(void **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  double v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - (unsigned char *)*a1;
    unint64_t v9 = a2 + (v8 >> 3);
    if (v9 >> 61) {
      abort();
    }
    uint64_t v10 = v8 >> 3;
    uint64_t v11 = v5 - (unsigned char *)*a1;
    if (v11 >> 2 > v9) {
      unint64_t v9 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      long long v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLayoutContext *>>(v4, v12);
    }
    else {
      long long v13 = 0;
    }
    long long v14 = &v13[8 * v10];
    long long v15 = &v13[8 * v12];
    bzero(v14, 8 * a2);
    uint64_t v16 = &v14[8 * a2];
    uint64_t v18 = (char *)*a1;
    uint64_t v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        uint64_t v19 = *((void *)v17 - 1);
        v17 -= 8;
        *((void *)v14 - 1) = v19;
        v14 -= 8;
      }
      while (v17 != v18);
      uint64_t v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
    {
      operator delete(v17);
    }
  }
}

uint64_t std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::__wrap_iter<TSDOrthoPathNode **>>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  if (a3 >= 2)
  {
    uint64_t v4 = (uint64_t)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 3)
    {
      uint64_t v6 = v4 >> 2;
      uint64_t v7 = (v4 >> 2) | 1;
      uint64_t v8 = (unint64_t *)(result + 8 * v7);
      uint64_t v9 = v6 + 2;
      if (v9 >= a3)
      {
        unint64_t v10 = *v8;
      }
      else
      {
        unint64_t v10 = *v8;
        if (*v8 < v8[1])
        {
          unint64_t v10 = v8[1];
          ++v8;
          uint64_t v7 = v9;
        }
      }
      unint64_t v11 = *a4;
      if (v10 >= *a4)
      {
        do
        {
          *a4 = v10;
          a4 = v8;
          if (v5 < v7) {
            break;
          }
          uint64_t v12 = (2 * v7) | 1;
          uint64_t v8 = (unint64_t *)(result + 8 * v12);
          uint64_t v7 = 2 * v7 + 2;
          if (v7 >= a3)
          {
            unint64_t v10 = *v8;
            uint64_t v7 = v12;
          }
          else
          {
            unint64_t v10 = *v8;
            if (*v8 >= v8[1])
            {
              uint64_t v7 = v12;
            }
            else
            {
              unint64_t v10 = v8[1];
              ++v8;
            }
          }
        }
        while (v10 >= v11);
        *a4 = v11;
      }
    }
  }
  return result;
}

void *std::__floyd_sift_down[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSDOrthoPathNode *,TSDOrthoPathNode *),std::__wrap_iter<TSDOrthoPathNode **>>(void *a1, unsigned int (**a2)(void, void), uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = a3 - 2;
  if (a3 < 2) {
    uint64_t v7 = a3 - 1;
  }
  uint64_t v8 = v7 >> 1;
  do
  {
    uint64_t v9 = &a1[v6 + 1];
    uint64_t v10 = (2 * v6) | 1;
    uint64_t v11 = 2 * v6 + 2;
    if (v11 < a3 && (*a2)(a1[v6 + 1], a1[v6 + 2]))
    {
      ++v9;
      uint64_t v10 = v11;
    }
    *a1 = *v9;
    a1 = v9;
    uint64_t v6 = v10;
  }
  while (v10 <= v8);
  return v9;
}

uint64_t std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSDOrthoPathNode *,TSDOrthoPathNode *),std::__wrap_iter<TSDOrthoPathNode **>>(uint64_t result, uint64_t a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    uint64_t v6 = result;
    unint64_t v7 = v4 >> 1;
    uint64_t v8 = (uint64_t *)(result + 8 * (v4 >> 1));
    uint64_t v9 = (uint64_t *)(a2 - 8);
    double result = (*a3)(*v8, *(void *)(a2 - 8));
    if (result)
    {
      uint64_t v10 = *v9;
      do
      {
        uint64_t v11 = v8;
        *uint64_t v9 = *v8;
        if (!v7) {
          break;
        }
        unint64_t v7 = (v7 - 1) >> 1;
        uint64_t v8 = (uint64_t *)(v6 + 8 * v7);
        double result = (*a3)(*v8, v10);
        uint64_t v9 = v11;
      }
      while ((result & 1) != 0);
      uint64_t *v11 = v10;
    }
  }
  return result;
}

void sub_2236EA854(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__18(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__18(uint64_t a1)
{
}

void sub_2236F099C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2236F0A88(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2236F5E38(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2236F5E94(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2236F5FC4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__tree<objc_object  {objcproto19TSWPStorageObserver}*>::__erase_unique<objc_object  {objcproto19TSWPStorageObserver}>(uint64_t a1, unint64_t *a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (!v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  unint64_t v4 = (uint64_t *)(a1 + 8);
  do
  {
    unint64_t v5 = v2[4];
    BOOL v6 = v5 >= v3;
    if (v5 >= v3) {
      unint64_t v7 = v2;
    }
    else {
      unint64_t v7 = v2 + 1;
    }
    if (v6) {
      unint64_t v4 = v2;
    }
    uint64_t v2 = (void *)*v7;
  }
  while (*v7);
  if (v4 == (uint64_t *)(a1 + 8) || v3 < v4[4]) {
    return 0;
  }
  std::__tree<std::__value_type<unsigned short,EQKit::Config::Operator::Form>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,EQKit::Config::Operator::Form>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,EQKit::Config::Operator::Form>>>::__remove_node_pointer((uint64_t **)a1, v4);
  operator delete(v4);
  return 1;
}

void sub_2236F63D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_2236F64A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_2236F65E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2236F6664(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  uint64_t v10 = v9;

  a9.super_class = (Class)TSWPEditMenuController;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_2236F67D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_2236F7030(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2236F824C(_Unwind_Exception *a1)
{
  MEMORY[0x223CB8F20](v1, 0x10E1C405C8FB0CCLL);
  _Unwind_Resume(a1);
}

void sub_2236F8480(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void TSWPLayoutColumnChore::TSWPLayoutColumnChore(uint64_t a1, void *a2, void *a3, void *a4, int a5, uint64_t a6, uint64_t a7)
{
}

{
  TSWPLayoutColumnChore::TSWPLayoutColumnChore(a1, a2, a3, a4, a5, a6, a7);
}

void sub_2236FC0B4(_Unwind_Exception *a1)
{
  TSWPLayoutChore::~TSWPLayoutChore(v1);
  _Unwind_Resume(a1);
}

void TSWPLayoutColumnChore::~TSWPLayoutColumnChore(TSWPLayoutColumnChore *this)
{
  TSWPLayoutChore::~TSWPLayoutChore(this);

  JUMPOUT(0x223CB8F20);
}

uint64_t TSWPLayoutColumnChore::layoutColumnsIntoTarget(uint64_t a1, void *a2, unint64_t a3, uint64_t a4, void *a5)
{
  *(void *)(a1 + 2056) = a2;
  uint64_t v10 = objc_msgSend((id)objc_msgSend(a2, "columns"), "objectAtIndexedSubscript:", a3);
  uint64_t v11 = 0x8000;
  if (objc_opt_respondsToSelector())
  {
    if ([*(id *)(a1 + 16) invalidateOnExactTextRangeLayout]) {
      uint64_t v11 = 32769;
    }
    else {
      uint64_t v11 = 0x8000;
    }
  }
  TSWPLayoutChore::protectedSetupLayoutState(a1, a2, a3, [v10 startCharIndex], a5);
  TSWPLayoutChore::protectedLayoutColumnsWithFlags(a1, v11, a3, a4, a2);

  return TSWPLayoutChore::pSetTargetColumnsTransform((id *)a1);
}

void sub_2236FC3E8(_Unwind_Exception *a1)
{
  MEMORY[0x223CB8F20](v1, 0x20C40960023A9);
  _Unwind_Resume(a1);
}

void sub_2236FC7C0(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t compareAttachments(objc_object *a1, objc_object *a2, void *a3)
{
  unint64_t v4 = objc_msgSend((id)-[objc_object objectAtIndexedSubscript:](a1, "objectAtIndexedSubscript:", 1), "unsignedIntegerValue");
  unint64_t v5 = objc_msgSend((id)-[objc_object objectAtIndexedSubscript:](a2, "objectAtIndexedSubscript:", 1), "unsignedIntegerValue");
  if (v4 < v5) {
    return -1;
  }
  else {
    return v4 > v5;
  }
}

void TSWPLineStylingCTState::TSWPLineStylingCTState(TSWPLineStylingCTState *this, const TSWPLineStylingCTState *a2)
{
  *(void *)this = *(id *)a2;
  long long v4 = *(_OWORD *)((char *)a2 + 24);
  *(_OWORD *)((char *)this + 8) = *(_OWORD *)((char *)a2 + 8);
  *(_OWORD *)((char *)this + 24) = v4;
}

{
  long long v4;

  *(void *)this = *(id *)a2;
  long long v4 = *(_OWORD *)((char *)a2 + 24);
  *(_OWORD *)((char *)this + 8) = *(_OWORD *)((char *)a2 + 8);
  *(_OWORD *)((char *)this + 24) = v4;
}

uint64_t TSWPLineStylingCTState::isAffectingCTAttributesEquallyTo(TSWPLineStylingCTState *this, const TSWPLineStylingCTState *a2)
{
  uint64_t v3 = *((void *)this + 3);
  if (v3)
  {
    int v4 = *((unsigned __int8 *)this + 8);
    uint64_t v5 = *((void *)a2 + 3);
    if (v5)
    {
      if ((v4 ^ *((unsigned __int8 *)a2 + 8))) {
        return 0;
      }
    }
    else
    {
      if (v4) {
        return 0;
      }
      uint64_t v5 = 0;
    }
  }
  else
  {
    uint64_t v5 = *((void *)a2 + 3);
    if (v5 && (*((unsigned char *)a2 + 8) & 1) != 0) {
      return 0;
    }
  }
  if ((*((unsigned __int8 *)a2 + 8) ^ *((unsigned __int8 *)this + 8))) {
    return 0;
  }
  BOOL v6 = *((void *)this + 2) == *((void *)a2 + 2) && v3 == v5;
  if (!v6 || *((void *)this + 4) != *((void *)a2 + 4)) {
    return 0;
  }
  unint64_t v7 = objc_msgSend((id)objc_msgSend(*(id *)this, "overrideCharacterStylePropertyMap"), "propertyMapWithProperties:", +[TSWPCharacterStyle properties](TSWPCharacterStyle, "properties"));
  uint64_t v8 = objc_msgSend((id)objc_msgSend(*(id *)a2, "overrideCharacterStylePropertyMap"), "propertyMapWithProperties:", +[TSWPCharacterStyle properties](TSWPCharacterStyle, "properties"));
  if (v7 == (void *)v8) {
    return 1;
  }

  return [v7 isEqual:v8];
}

uint64_t TSWPLineStylingCTState::textProperties(id *this)
{
  uint64_t v1 = (void *)[*this overrideCharacterStylePropertyMap];
  id v2 = +[TSWPCharacterStyle properties];

  return [v1 propertyMapWithProperties:v2];
}

TSWPCharacterStyle *TSWPLineStylingCTState::modifiedCharacterStyle(TSWPLineStylingCTState *this, TSSStylesheet *a2, TSWPCharacterStyle *a3)
{
  if ((*((unsigned char *)this + 8) & 1) == 0) {
    return a3;
  }
  if (a3)
  {
    uint64_t v6 = objc_msgSend((id)objc_msgSend(*(id *)this, "overrideCharacterStylePropertyMap"), "propertyMapWithProperties:", +[TSWPCharacterStyle properties](TSWPCharacterStyle, "properties"));
    return (TSWPCharacterStyle *)[(TSSStylesheet *)a2 variationOfStyle:a3 propertyMap:v6];
  }
  else
  {
    unint64_t v7 = -[TSSStyle initWithContext:name:overridePropertyMap:isVariation:]([TSWPCharacterStyle alloc], "initWithContext:name:overridePropertyMap:isVariation:", -[TSPObject context](a2, "context"), 0, objc_msgSend((id)objc_msgSend(*(id *)this, "overrideCharacterStylePropertyMap"), "propertyMapWithProperties:", +[TSWPCharacterStyle properties](TSWPCharacterStyle, "properties")), 0);
    return v7;
  }
}

void TSWPLineStylingCTState::prepareForRelayout(void **a1, void *a2, void *a3)
{
  if (*a1 != a2)
  {
    TSWPLineStylingCTState::TSWPLineStylingCTState((uint64_t)v4, a2, a3);
    TSWPLineStylingCTState::operator=((uint64_t)a1, (uint64_t)v4);
  }
}

void sub_2236FEA0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void TSWPLineStylingLayoutState::TSWPLineStylingLayoutState(TSWPLineStylingLayoutState *this, id *a2)
{
  *((void *)this + 1) = a2[1];
  long long v4 = *((_OWORD *)a2 + 2);
  *((_OWORD *)this + 1) = *((_OWORD *)a2 + 1);
  *((_OWORD *)this + 2) = v4;
  *(void *)this = *a2;
  long long v5 = *((_OWORD *)a2 + 3);
  *((void *)this + 8) = a2[8];
  *((_OWORD *)this + 3) = v5;
}

void sub_2236FEA78(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = 0;
  _Unwind_Resume(a1);
}

uint64_t TSWPLineStylingLayoutState::clearLayoutState(uint64_t this)
{
  *(void *)(this + 48) = 0;
  *(unsigned char *)(this + 64) &= ~1u;
  return this;
}

uint64_t TSWPLineStylingLayoutState::prepareForLayoutIteration(uint64_t this)
{
  *(void *)(this + 48) = 0;
  *(unsigned char *)(this + 64) &= ~1u;
  return this;
}

void TSWPLineStylingLayoutState::prepareForRelayout(void **a1, void *a2)
{
}

void sub_223700010(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__19(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__19(uint64_t a1)
{
}

const char *TSWPHighlightAttributeArray::className(TSWPHighlightAttributeArray *this)
{
  return "TSWPHighlightAttributeArray";
}

void TSWPHighlightAttributeArray::~TSWPHighlightAttributeArray(TSWPAttributeArray *this)
{
  TSWPStyleAttributeArray::~TSWPStyleAttributeArray(this);

  JUMPOUT(0x223CB8F20);
}

uint64_t TSWPAttributeArray::hasPairedData(TSWPAttributeArray *this)
{
  return 0;
}

uint64_t TSWPAttributeArray::hasSingleData(TSWPAttributeArray *this)
{
  return 0;
}

uint64_t TSWPAttributeArray::shouldInsertAttributesForMarkers(TSWPAttributeArray *this)
{
  return 0;
}

void TSWPEnumerateWordsInStringWithBlock(CFStringRef string, CFRange range, CFLocaleRef locale, uint64_t a4)
{
  long long v5 = CFStringTokenizerCreate(0, string, range, 4uLL, locale);
  if (v5)
  {
    uint64_t v6 = v5;
    CFStringTokenizerTokenType Token = CFStringTokenizerAdvanceToNextToken(v5);
    if (Token)
    {
      LOBYTE(v8) = Token;
      do
      {
        if ((v8 & 0x10) == 0) {
          (*(void (**)(uint64_t, __CFStringTokenizer *))(a4 + 16))(a4, v6);
        }
        CFStringTokenizerTokenType v8 = CFStringTokenizerAdvanceToNextToken(v6);
      }
      while (v8);
    }
    CFRelease(v6);
  }
}

void sub_223701DB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void TSWPParagraphAttributeArray::~TSWPParagraphAttributeArray(TSWPParagraphAttributeArray *this)
{
  this->int var0 = (void **)&unk_26D6875A8;
  if (this->var2)
  {
    uint64_t v2 = 0;
    unint64_t v3 = 0;
    do
    {
      (*((void (**)(TSWPParagraphAttributeArray *, char *))this->var0 + 24))(this, (char *)this->var4 + v2);
      ++v3;
      v2 += 16;
    }
    while (v3 < this->var2);
  }

  TSWPAttributeArray::~TSWPAttributeArray((TSWPAttributeArray *)this);
}

{
  uint64_t vars8;

  TSWPParagraphAttributeArray::~TSWPParagraphAttributeArray(this);

  JUMPOUT(0x223CB8F20);
}

void sub_2237037D8(_Unwind_Exception *a1)
{
  TSWPAttributeArray::~TSWPAttributeArray(v1);
  _Unwind_Resume(a1);
}

uint64_t TSWPParagraphAttributeArray::replaceParagraphDataForAttributeIndex(uint64_t result, _DWORD *a2, uint64_t a3)
{
  *(_DWORD *)(*(void *)(result + 32) + 16 * a3 + 8) = *a2;
  return result;
}

void TSWPParagraphAttributeArray::adoptStylesheetWithMapper(TSWPAttributeArray *a1, uint64_t a2, void *a3)
{
  if (a1->var1 == 8)
  {
    if (a1->var2)
    {
      unint64_t v6 = 0;
      uint64_t v7 = 8;
      do
      {
        CFStringTokenizerTokenType v8 = *(void **)((char *)a1->var4 + v7);
        if (v8)
        {
          if (objc_opt_respondsToSelector()) {
            [v8 adoptStylesheet:a2 withMapper:a3];
          }
        }
        ++v6;
        v7 += 16;
      }
      while (v6 < a1->var2);
    }
  }
  else if ((*((unsigned int (**)(TSWPAttributeArray *))a1->var0 + 3))(a1))
  {
    unint64_t var2 = a1->var2;
    if (var2)
    {
      unint64_t v10 = 0;
      uint64_t v11 = 8;
      do
      {
        int var4 = a1->var4;
        uint64_t v13 = *(void *)((char *)var4 + v11);
        if (v13)
        {
          uint64_t v14 = (objc_object *)[a3 mappedStyleForStyle:*(void *)((char *)var4 + v11)];
          if (!v14 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
          {
            uint64_t v15 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v16 = objc_msgSend(NSString, "stringWithUTF8String:", "virtual void TSWPParagraphAttributeArray::adoptStylesheetWithMapper(TSSStylesheet *, id<TSKStyleMapper>)");
            uint64_t v17 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPParagraphAttributeArray.mm"];
            uint64_t v18 = (objc_class *)objc_opt_class();
            uint64_t v19 = NSStringFromClass(v18);
            uint64_t v20 = (objc_class *)objc_opt_class();
            [v15 handleFailureInFunction:v16, v17, 103, @"Bad style mapping [%@ %p] -> [%@ %p]", v19, v13, NSStringFromClass(v20), v14 file lineNumber description];
          }
          TSWPAttributeArray::replaceObjectForAttributeIndex(a1, v14, v10, 0, 0);
          unint64_t var2 = a1->var2;
        }
        ++v10;
        v11 += 16;
      }
      while (v10 < var2);
    }
  }
}

uint64_t TSWPParagraphAttributeArray::deletingWholeParagraphs(TSWPParagraphAttributeArray *this, _NSRange a2, TSWPAttributeArray *a3)
{
  if (!a3) {
    return 0;
  }
  NSUInteger length = a2.length;
  NSUInteger location = a2.location;
  unint64_t v6 = TSWPAttributeArray::effectiveAttributeIndexForCharIndex(a3, a2.location);
  unint64_t v7 = location + length;
  unint64_t v8 = TSWPAttributeArray::effectiveAttributeIndexForCharIndex(a3, v7);
  unint64_t var2 = a3->var2;
  if (v6 >= var2)
  {
    BOOL v10 = 0;
  }
  else
  {
    BOOL v10 = TSWPAttributeArray::charIndexForAttributeIndex(a3, v6) == location;
    unint64_t var2 = a3->var2;
  }
  BOOL v12 = v8 < var2 && TSWPAttributeArray::charIndexForAttributeIndex(a3, v8) == v7;
  return v10 & v12;
}

void TSWPParagraphAttributeArray::assignAttributesAtFrontOfRange(TSWPParagraphAttributeArray *this, _NSRange a2, TSWPParagraphAttributeArray *a3, TSWPStorageTransaction *a4)
{
  NSUInteger length = a2.length;
  NSUInteger location = a2.location;
  NSUInteger v9 = TSWPParagraphAttributeArray::paragraphRangeForCharRange(a3, a2);
  NSUInteger v11 = v10;
  int v12 = (*((uint64_t (**)(TSWPParagraphAttributeArray *))this->var0 + 3))(this);
  unint64_t v13 = TSWPAttributeArray::effectiveAttributeIndexForCharIndex((TSWPAttributeArray *)this, location + length);
  if (v12)
  {
    if (v13 != 0x7FFFFFFFFFFFFFFFLL)
    {
      double v23 = (objc_object *)*((void *)this->var4 + 2 * v13 + 1);
      uint64_t v22 = v23;
      v26.NSUInteger location = v9;
      v26.NSUInteger length = v11;
      TSWPParagraphAttributeArray::applyObjectToParagraphRange(this, v23, v26, a3, a4);

      return;
    }
    uint64_t v14 = [MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v15 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPParagraphAttributeArray::assignAttributesAtFrontOfRange(NSRange, TSWPParagraphAttributeArray *, TSWPStorageTransaction *)");
    uint64_t v16 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPParagraphAttributeArray.mm"];
    uint64_t v17 = (void *)v14;
    uint64_t v18 = v15;
    uint64_t v19 = 150;
  }
  else
  {
    if (v13 != 0x7FFFFFFFFFFFFFFFLL)
    {
      int v24 = *((_DWORD *)this->var4 + 4 * v13 + 2);
      TSWPParagraphAttributeArray::applyParagraphDataToParagraphRange(this, (unsigned __int16 *)&v24, v9, v11, (TSWPAttributeArray *)a3, a4);
      return;
    }
    uint64_t v20 = [MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v21 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPParagraphAttributeArray::assignAttributesAtFrontOfRange(NSRange, TSWPParagraphAttributeArray *, TSWPStorageTransaction *)");
    uint64_t v16 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPParagraphAttributeArray.mm"];
    uint64_t v17 = (void *)v20;
    uint64_t v18 = v21;
    uint64_t v19 = 162;
  }

  [v17 handleFailureInFunction:v18 file:v16 lineNumber:v19 description:@"Bad attribute index in break table."];
}

uint64_t TSWPParagraphAttributeArray::applyParagraphDataToParagraphRange(TSWPParagraphAttributeArray *this, unsigned __int16 *a2, unint64_t a3, NSUInteger a4, TSWPAttributeArray *a5, TSWPStorageTransaction *a6)
{
  if (!a4 || !a5 || (unint64_t v11 = a3 + a4, var2 = a5->var2, a3 + a4 > var2))
  {
    unint64_t v13 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v14 = objc_msgSend(NSString, "stringWithUTF8String:", "BOOL TSWPParagraphAttributeArray::applyParagraphDataToParagraphRange(const TSWPParagraphData &, NSRange, TSWPParagraphAttributeArray *, TSWPStorageTransaction *)");
    objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPParagraphAttributeArray.mm"), 718, @"Bad par index range.");
    if (!a4)
    {
      char v19 = 0;
      char v20 = 0;
      unint64_t v11 = a3;
      if (!a5) {
        return v20 & 1;
      }
      goto LABEL_16;
    }
    unint64_t var2 = a5->var2;
    unint64_t v11 = a3 + a4;
  }
  if (v11 < var2 && TSWPParagraphAttributeArray::isParagraphBreakSparse(this, v11, a5))
  {
    unint64_t v15 = TSWPAttributeArray::charIndexForAttributeIndex(a5, v11);
    unint64_t v16 = TSWPAttributeArray::effectiveAttributeIndexForCharIndex((TSWPAttributeArray *)this, v15);
    if (v16 != 0x7FFFFFFFFFFFFFFFLL)
    {
      unint64_t v21 = v16;
      uint64_t v22 = (unsigned __int16 *)((char *)this->var4 + 16 * v16 + 8);
      BOOL IsSame = TSWPParagraphAttributeArray::dataIsSame((uint64_t)this, a2, v22);
      if (!IsSame)
      {
        int v24 = *(_DWORD *)v22;
        unint64_t v35 = v15;
        int v36 = v24;
        TSWPAttributeArray::insertAttribute((TSWPAttributeArray *)this, (const TSWPAttributeRecord *)&v35, v21 + 1, 0, a6);
      }
      char v19 = !IsSame;
      goto LABEL_16;
    }
    uint64_t v17 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v18 = objc_msgSend(NSString, "stringWithUTF8String:", "BOOL TSWPParagraphAttributeArray::applyParagraphDataToParagraphRange(const TSWPParagraphData &, NSRange, TSWPParagraphAttributeArray *, TSWPStorageTransaction *)");
    objc_msgSend(v17, "handleFailureInFunction:file:lineNumber:description:", v18, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPParagraphAttributeArray.mm"), 728, @"Bad attribute index.");
  }
  char v19 = 0;
LABEL_16:
  if (v11 <= a5->var2)
  {
    NSUInteger v33 = a3;
    if (a3 < v11)
    {
      for (unint64_t i = a3; v11 != i; ++i)
      {
        unint64_t v26 = TSWPAttributeArray::charIndexForAttributeIndex(a5, i);
        unint64_t v27 = TSWPAttributeArray::effectiveAttributeIndexForCharIndex((TSWPAttributeArray *)this, v26);
        if (v27 == 0x7FFFFFFFFFFFFFFFLL) {
          unint64_t v28 = 0;
        }
        else {
          unint64_t v28 = v27;
        }
        uint64_t v29 = TSWPAttributeArray::charIndexForAttributeIndex((TSWPAttributeArray *)this, v28);
        BOOL v30 = TSWPParagraphAttributeArray::dataIsSame((uint64_t)this, a2, (unsigned __int16 *)this->var4 + 8 * v28 + 4);
        if (v29 == v26)
        {
          if (!v30)
          {
            if (!v28
              || !TSWPParagraphAttributeArray::dataIsSame((uint64_t)this, a2, (unsigned __int16 *)this->var4 + 8 * v28 - 4))
            {
              *((_DWORD *)this->var4 + 4 * v28 + 2) = *(_DWORD *)a2;
              goto LABEL_30;
            }
            char v19 = 1;
            (*((void (**)(TSWPParagraphAttributeArray *, unint64_t, uint64_t, TSWPStorageTransaction *))this->var0
             + 7))(this, v28, 1, a6);
          }
        }
        else if (!v30)
        {
          int v31 = *(_DWORD *)a2;
          unint64_t v35 = v26;
          int v36 = v31;
          TSWPAttributeArray::insertAttribute((TSWPAttributeArray *)this, (const TSWPAttributeRecord *)&v35, v28 + 1, 0, a6);
LABEL_30:
          char v19 = 1;
        }
      }
    }
    v37.NSUInteger location = v33;
    v37.NSUInteger length = a4;
    TSWPParagraphAttributeArray::didApplyAttributes(this, v37, a5, a6);
  }
  char v20 = v19;
  return v20 & 1;
}

BOOL TSWPParagraphAttributeArray::isParagraphBreakSparse(TSWPParagraphAttributeArray *this, unint64_t a2, TSWPAttributeArray *a3)
{
  if ((this->var1 | 8) == 8 || a3->var2 <= a2) {
    return 0;
  }
  unint64_t v7 = 0x7FFFFFFFFFFFFFFFLL;
  TSWPParagraphAttributeArray::attributeIndexForParagraphIndex(this, a2, a3, &v7);
  unint64_t v5 = v7;
  return v5 != TSWPAttributeArray::charIndexForAttributeIndex(a3, a2);
}

const char *TSWPParagraphAttributeArray::className(TSWPParagraphAttributeArray *this)
{
  return "TSWPParagraphAttributeArray";
}

BOOL TSWPParagraphAttributeArray::canCollapseAttributes(TSWPParagraphAttributeArray *this, const TSWPAttributeRecord *a2, const TSWPAttributeRecord *a3)
{
  int v6 = (*((uint64_t (**)(TSWPParagraphAttributeArray *))this->var0 + 3))(this);
  unint64_t v7 = (unsigned __int16 *)((char *)a2 + 8);
  if (v6) {
    return *(void *)v7 == *((void *)a3 + 1);
  }

  return TSWPParagraphAttributeArray::dataIsSame((uint64_t)this, v7, (unsigned __int16 *)a3 + 4);
}

BOOL TSWPParagraphAttributeArray::dataIsSame(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 32))(a1))
  {
    return *a2 == *a3 && a2[1] == a3[1];
  }
  else
  {
    if (!(*(unsigned int (**)(uint64_t))(*(void *)a1 + 40))(a1))
    {
      unint64_t v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "BOOL TSWPParagraphAttributeArray::dataIsSame(const TSWPParagraphData &, const TSWPParagraphData &) const");
      objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPParagraphAttributeArray.mm"), 711, @"Do not call dataIsSame for this table.");
      return 0;
    }
    return *(_DWORD *)a2 == *(_DWORD *)a3;
  }
}

TSWPParagraphAttributeArray *TSWPParagraphAttributeArray::collapseAttributesAtAttributeIndex(TSWPParagraphAttributeArray *this, unint64_t a2, TSWPStorageTransaction *a3)
{
  unint64_t v5 = (TSWPAttributeArray *)this;
  if (a2
    && this->var2 > a2
    && (this = (TSWPParagraphAttributeArray *)(*((uint64_t (**)(TSWPParagraphAttributeArray *, char *, char *))this->var0
                                               + 26))(this, (char *)this->var4 + 16 * a2, (char *)this->var4 + 16 * a2 - 16), (this & 1) != 0)|| v5->var2 - 1 == a2&& (unint64_t v6 = TSWPAttributeArray::charIndexForAttributeIndex(v5, a2), this = (TSWPParagraphAttributeArray *)TSWPAttributeArray::characterCount(v5), v6 > (unint64_t)this))
  {
    unint64_t v7 = (uint64_t (*)(TSWPAttributeArray *, unint64_t, uint64_t, TSWPStorageTransaction *))*((void *)v5->var0 + 7);
    return (TSWPParagraphAttributeArray *)v7(v5, a2, 1, a3);
  }
  return this;
}

void *TSWPParagraphAttributeArray::description(TSWPParagraphAttributeArray *this)
{
  signed int var1 = this->var1;
  if (var1 > 10)
  {
    if (var1 == 11)
    {
      unint64_t v3 = (void *)[MEMORY[0x263F089D8] string];
      [v3 appendFormat:@"%s <%p> %@: Count: %lu.\n", (*((uint64_t (**)(TSWPParagraphAttributeArray *))this->var0 + 22))(this), this, @"ParagraphListStarts", this->var2];
      if (this->var2)
      {
        unint64_t v10 = 0;
        uint64_t v11 = 8;
        do
        {
          [v3 appendFormat:@"\t%u CharIndex: %lu, start %lu\n"], v10, TSWPAttributeArray::charIndexForAttributeIndex((TSWPAttributeArray *)this, v10), *(unsigned int *)((char *)this->var4 + v11));
          ++v10;
          v11 += 16;
        }
        while (v10 < this->var2);
      }
      return v3;
    }
    if (var1 == 18)
    {
      unint64_t v3 = (void *)[MEMORY[0x263F089D8] string];
      [v3 appendFormat:@"%s <%p> %@: Count: %lu.\n", (*((uint64_t (**)(TSWPParagraphAttributeArray *))this->var0 + 22))(this), this, @"ParagraphWritingDirection", this->var2];
      if (this->var2)
      {
        unint64_t v6 = 0;
        uint64_t v7 = 8;
        do
        {
          [v3 appendFormat:@"\t%u CharIndex: %lu, direction %d\n"], v6, TSWPAttributeArray::charIndexForAttributeIndex((TSWPAttributeArray *)this, v6), *(unsigned int *)((char *)this->var4 + v7));
          ++v6;
          v7 += 16;
        }
        while (v6 < this->var2);
      }
      return v3;
    }
  }
  else
  {
    if (var1 == 1)
    {
      unint64_t v3 = (void *)[MEMORY[0x263F089D8] string];
      [v3 appendFormat:@"%s <%p> %@: Count: %lu.\n", (*((uint64_t (**)(TSWPParagraphAttributeArray *))this->var0 + 22))(this), this, @"ParagraphData", this->var2];
      if (this->var2)
      {
        uint64_t v8 = 0;
        unint64_t v9 = 0;
        do
        {
          [v3 appendFormat:@"\t%u CharIndex: %lu, level %d flags %d\n"], v9, TSWPAttributeArray::charIndexForAttributeIndex((TSWPAttributeArray *)this, v9), *(unsigned __int16 *)((char *)this->var4 + v8 + 8), *(unsigned __int16 *)((char *)this->var4 + v8 + 10));
          ++v9;
          v8 += 16;
        }
        while (v9 < this->var2);
      }
      return v3;
    }
    if (var1 == 10)
    {
      unint64_t v3 = (void *)[MEMORY[0x263F089D8] string];
      [v3 appendFormat:@"%s <%p> %@: Count: %u.\n", (*((uint64_t (**)(TSWPParagraphAttributeArray *))this->var0 + 22))(this), this, @"CellData", this->var2];
      if (this->var2)
      {
        uint64_t v4 = 0;
        unint64_t v5 = 0;
        do
        {
          [v3 appendFormat:@"\t%u CharIndex: %lu, row %d column %d\n"], v5, TSWPAttributeArray::charIndexForAttributeIndex((TSWPAttributeArray *)this, v5), *(unsigned __int16 *)((char *)this->var4 + v4 + 8), *(unsigned __int16 *)((char *)this->var4 + v4 + 10));
          ++v5;
          v4 += 16;
        }
        while (v5 < this->var2);
      }
      return v3;
    }
  }

  return TSWPAttributeArray::description((TSWPAttributeArray *)this);
}

uint64_t TSWPParagraphAttributeArray::allowsNilObjects(TSWPParagraphAttributeArray *this)
{
  return 0;
}

uint64_t TSWPParagraphAttributeArray::attributeIndexForOrderedParagraphData(void *a1, int *a2)
{
  int v3 = *a2;
  uint64_t v9 = 0;
  int v10 = v3;
  uint64_t v4 = (const void *)a1[4];
  size_t v5 = a1[2];
  if ((*(unsigned int (**)(void *))(*a1 + 40))(a1)) {
    unint64_t v6 = (int (__cdecl *)(const void *, const void *))singleComparator;
  }
  else {
    unint64_t v6 = (int (__cdecl *)(const void *, const void *))pairedComparator;
  }
  uint64_t v7 = bsearch(&v9, v4, v5, 0x10uLL, v6);
  if (v7) {
    return ((uint64_t)v7 - a1[4]) >> 4;
  }
  else {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
}

uint64_t singleComparator(_DWORD *a1, _DWORD *a2)
{
  unsigned int v2 = a1[2];
  unsigned int v3 = a2[2];
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 != v3;
  if (v4) {
    return v5;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t pairedComparator(unsigned __int16 *a1, unsigned __int16 *a2)
{
  unsigned int v2 = a1[4];
  unsigned int v3 = a2[4];
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  if (v2 != v3) {
    return 1;
  }
  unsigned int v5 = a1[5];
  unsigned int v6 = a2[5];
  BOOL v7 = v5 >= v6;
  BOOL v8 = v5 != v6;
  if (v7) {
    return v8;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t TSWPParagraphAttributeArray::hasPairedData(TSWPParagraphAttributeArray *this)
{
  return (*((unsigned int (**)(TSWPParagraphAttributeArray *))this->var0 + 3))(this) ^ 1;
}

BOOL TSWPParagraphAttributeArray::hasSingleData(TSWPParagraphAttributeArray *this)
{
  if ((*((uint64_t (**)(TSWPParagraphAttributeArray *))this->var0 + 3))(this)) {
    return 0;
  }
  unsigned int var1 = this->var1;
  return var1 == 11 || var1 == 18;
}

BOOL TSWPTopicNumberHints::operator==(uint64_t a1, void *a2)
{
  if (*(void *)(a1 + 24) == a2[3] && *(void *)(a1 + 16) == a2[2])
  {
    BOOL v4 = (void *)(a1 + 8);
    unsigned int v5 = *(void **)a1;
    if (*(void *)a1 == a1 + 8) {
      return *(void *)(a1 + 40) == a2[5];
    }
    unsigned int v6 = (void *)*a2;
    while (std::__equal_to::operator()[abi:nn180100]<std::pair<TSWPListStyle const* const,std::vector<TSWPTopicNumberEntry>>,std::pair<TSWPListStyle const* const,std::vector<TSWPTopicNumberEntry>>>((uint64_t)&v13, v5 + 4, v6 + 4))
    {
      BOOL v7 = (void *)v5[1];
      BOOL v8 = v5;
      if (v7)
      {
        do
        {
          unsigned int v5 = v7;
          BOOL v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          unsigned int v5 = (void *)v8[2];
          BOOL v9 = *v5 == (void)v8;
          BOOL v8 = v5;
        }
        while (!v9);
      }
      int v10 = (void *)v6[1];
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          int v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v11 = (void *)v6[2];
          BOOL v9 = *v11 == (void)v6;
          unsigned int v6 = v11;
        }
        while (!v9);
      }
      unsigned int v6 = v11;
      if (v5 == v4) {
        return *(void *)(a1 + 40) == a2[5];
      }
    }
  }
  return 0;
}

BOOL TSWPTopicNumberHints::operator!=(uint64_t a1, void *a2)
{
  return !TSWPTopicNumberHints::operator==(a1, a2);
}

uint64_t TSWPTopicNumberHints::equivalentState(TSWPTopicNumberHints *this, const TSWPTopicNumberHints *a2)
{
  if (this->_numbersForListStyle.__tree_.__pair3_.__value_ != a2->_numbersForListStyle.__tree_.__pair3_.__value_) {
    return 0;
  }
  begin_node = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *)this->_numbersForListStyle.__tree_.__begin_node_;
  p_pair1 = &this->_numbersForListStyle.__tree_.__pair1_;
  unsigned int v3 = begin_node;
  if (begin_node == p_pair1)
  {
    char v8 = 1;
  }
  else
  {
    left = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *)a2->_numbersForListStyle.__tree_.__pair1_.__value_.__left_;
    unsigned int v5 = &a2->_numbersForListStyle.__tree_.__pair1_;
    unsigned int v6 = left;
    if (left)
    {
      char v8 = 1;
      while (1)
      {
        BOOL v9 = v3[4].__value_.__left_;
        int v10 = v5;
        uint64_t v11 = v6;
        do
        {
          int v12 = v11[4].__value_.__left_;
          BOOL v13 = v12 >= v9;
          if (v12 >= v9) {
            uint64_t v14 = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> **)v11;
          }
          else {
            uint64_t v14 = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> **)&v11[1];
          }
          if (v13) {
            int v10 = v11;
          }
          uint64_t v11 = *v14;
        }
        while (*v14);
        if (v10 == v5) {
          break;
        }
        if (v9 < v10[4].__value_.__left_) {
          break;
        }
        unint64_t v15 = (char *)v3[5].__value_.__left_;
        unint64_t v16 = (char *)v3[6].__value_.__left_;
        unint64_t v17 = (v16 - v15) >> 4;
        char v19 = v10 + 5;
        uint64_t v18 = (uint64_t *)v10[5].__value_.__left_;
        if (v17 != ((char *)v19[1].__value_.__left_ - (char *)v18) >> 4) {
          break;
        }
        if ((v8 & 1) != 0 && v16 != v15)
        {
          uint64_t v20 = 0;
          while (1)
          {
            uint64_t v22 = *(void *)v15;
            v15 += 16;
            uint64_t v21 = v22;
            uint64_t v23 = *v18;
            v18 += 2;
            if (v21 != v23) {
              break;
            }
            if (++v20 >= v17) {
              goto LABEL_23;
            }
          }
          char v8 = 0;
        }
LABEL_23:
        int v24 = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *)v3[1].__value_.__left_;
        if (v24)
        {
          do
          {
            uint64_t v25 = v24;
            int v24 = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *)v24->__value_.__left_;
          }
          while (v24);
        }
        else
        {
          do
          {
            uint64_t v25 = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *)v3[2].__value_.__left_;
            BOOL v26 = v25->__value_.__left_ == v3;
            unsigned int v3 = v25;
          }
          while (!v26);
        }
        unsigned int v3 = v25;
        if (v25 == p_pair1) {
          return v8 & 1;
        }
      }
    }
    char v8 = 0;
  }
  return v8 & 1;
}

TSWPTopicNumberHints *TSWPTopicNumberHints::offsetCharIndex(TSWPTopicNumberHints *this, uint64_t a2, unint64_t a3)
{
  charIndeCGFloat x = this->_charIndex;
  validThroughCharIndeCGFloat x = this->_validThroughCharIndex;
  BOOL v6 = charIndex < a3 || charIndex == 0x7FFFFFFFFFFFFFFFLL;
  if (!v6)
  {
    charIndex += a2;
    begin_node = this->_numbersForListStyle.__tree_.__begin_node_;
    if (this->_numbersForListStyle.__tree_.__begin_node_ != &this->_numbersForListStyle.__tree_.__pair1_)
    {
      do
      {
        uint64_t v8 = begin_node[5];
        uint64_t v9 = begin_node[6] - v8;
        if (v9)
        {
          unint64_t v10 = v9 >> 4;
          if (v10 <= 1) {
            unint64_t v10 = 1;
          }
          uint64_t v11 = (unint64_t *)(v8 + 8);
          do
          {
            if (*v11 >= a3) {
              *v11 += a2;
            }
            v11 += 2;
            --v10;
          }
          while (v10);
        }
        int v12 = (TSWPTopicNumberHints *)begin_node[1];
        if (v12)
        {
          do
          {
            BOOL v13 = v12;
            int v12 = (TSWPTopicNumberHints *)v12->_numbersForListStyle.__tree_.__begin_node_;
          }
          while (v12);
        }
        else
        {
          do
          {
            BOOL v13 = (TSWPTopicNumberHints *)begin_node[2];
            BOOL v6 = v13->_numbersForListStyle.__tree_.__begin_node_ == begin_node;
            begin_node = &v13->_numbersForListStyle.__tree_.__begin_node_;
          }
          while (!v6);
        }
        begin_node = &v13->_numbersForListStyle.__tree_.__begin_node_;
      }
      while (v13 != (TSWPTopicNumberHints *)&this->_numbersForListStyle.__tree_.__pair1_);
    }
  }
  if (validThroughCharIndex == 0x7FFFFFFFFFFFFFFFLL || validThroughCharIndex < a3) {
    a2 = 0;
  }
  unint64_t v15 = a2 + validThroughCharIndex;
  if (charIndex <= v15) {
    unint64_t v16 = v15;
  }
  else {
    unint64_t v16 = charIndex;
  }
  return TSWPTopicNumberHints::setCharIndexAndValidCharIndex(this, charIndex, v16);
}

uint64_t TSWPTopicNumberHints::nextTopicNumberForList(TSWPTopicNumberHints *this, TSWPListStyle *a2, unint64_t a3)
{
  if (!a2)
  {
    BOOL v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "NSUInteger TSWPTopicNumberHints::nextTopicNumberForList(TSWPListStyle *, TSWPParagraphLevel) const");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPTopicNumberHints.mm"), 159, @"invalid nil value for '%s'", "listStyle");
  }
  if (a3 >= 9)
  {
    uint64_t v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "NSUInteger TSWPTopicNumberHints::nextTopicNumberForList(TSWPListStyle *, TSWPParagraphLevel) const");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPTopicNumberHints.mm"), 160, @"Bad level value: %lu", a3);
  }
  id v10 = [(TSWPListStyle *)a2 baseStyleForTopicNumbers];
  left = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *)this->_numbersForListStyle.__tree_.__pair1_.__value_.__left_;
  p_pair1 = &this->_numbersForListStyle.__tree_.__pair1_;
  uint64_t v11 = left;
  if (!left) {
    return 1;
  }
  uint64_t v14 = p_pair1;
  do
  {
    unint64_t v15 = (unint64_t)v11[4].__value_.__left_;
    BOOL v16 = v15 >= (unint64_t)v10;
    if (v15 >= (unint64_t)v10) {
      unint64_t v17 = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> **)v11;
    }
    else {
      unint64_t v17 = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> **)&v11[1];
    }
    if (v16) {
      uint64_t v14 = v11;
    }
    uint64_t v11 = *v17;
  }
  while (*v17);
  if (v14 == p_pair1) {
    return 1;
  }
  if (v10 < v14[4].__value_.__left_) {
    return 1;
  }
  char v19 = v14 + 5;
  uint64_t v18 = v14[5].__value_.__left_;
  if (a3 >= ((char *)v19[1].__value_.__left_ - (char *)v18) >> 4) {
    return 1;
  }
  else {
    return v18[2 * a3] + 1;
  }
}

uint64_t TSWPTopicNumberHints::previousCharIndexForList(TSWPTopicNumberHints *this, TSWPListStyle *a2, unint64_t a3)
{
  if (!a2)
  {
    BOOL v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "TSWPCharIndex TSWPTopicNumberHints::previousCharIndexForList(TSWPListStyle *, TSWPParagraphLevel) const");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPTopicNumberHints.mm"), 186, @"invalid nil value for '%s'", "listStyle");
  }
  if (a3 >= 9)
  {
    uint64_t v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "TSWPCharIndex TSWPTopicNumberHints::previousCharIndexForList(TSWPListStyle *, TSWPParagraphLevel) const");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPTopicNumberHints.mm"), 187, @"Bad level value: %lu", a3);
  }
  id v10 = [(TSWPListStyle *)a2 baseStyleForTopicNumbers];
  left = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *)this->_numbersForListStyle.__tree_.__pair1_.__value_.__left_;
  p_pair1 = &this->_numbersForListStyle.__tree_.__pair1_;
  uint64_t v11 = left;
  if (left)
  {
    id v14 = v10;
    unint64_t v15 = p_pair1;
    do
    {
      unint64_t v16 = (unint64_t)v11[4].__value_.__left_;
      BOOL v17 = v16 >= (unint64_t)v10;
      if (v16 >= (unint64_t)v10) {
        uint64_t v18 = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> **)v11;
      }
      else {
        uint64_t v18 = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> **)&v11[1];
      }
      if (v17) {
        unint64_t v15 = v11;
      }
      uint64_t v11 = *v18;
    }
    while (*v18);
    if (v15 != p_pair1)
    {
      uint64_t result = 0x7FFFFFFFFFFFFFFFLL;
      if (v14 < v15[4].__value_.__left_) {
        return result;
      }
      uint64_t v21 = v15 + 5;
      uint64_t v20 = (char *)v15[5].__value_.__left_;
      unint64_t v22 = ((char *)v21[1].__value_.__left_ - (char *)v20) >> 4;
      if (v22 >= a3 + 1) {
        unint64_t v22 = a3 + 1;
      }
      unint64_t v23 = v22 + 1;
      int v24 = (uint64_t *)&v20[16 * v22 - 8];
      while (--v23)
      {
        uint64_t v26 = *v24;
        v24 -= 2;
        uint64_t v25 = v26;
        if (v26 != 0x7FFFFFFFFFFFFFFFLL) {
          return v25;
        }
      }
    }
  }
  return 0x7FFFFFFFFFFFFFFFLL;
}

void TSWPTopicNumberHints::setTopicNumberForList(TSWPTopicNumberHints *this, TSWPListStyle *a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  if (!a2)
  {
    id v10 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v11 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPTopicNumberHints::setTopicNumberForList(TSWPListStyle *, TSWPParagraphLevel, NSUInteger, TSWPCharIndex)");
    objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPTopicNumberHints.mm"), 214, @"invalid nil value for '%s'", "listStyle");
  }
  if (a3 >= 9)
  {
    int v12 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v13 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPTopicNumberHints::setTopicNumberForList(TSWPListStyle *, TSWPParagraphLevel, NSUInteger, TSWPCharIndex)");
    objc_msgSend(v12, "handleFailureInFunction:file:lineNumber:description:", v13, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPTopicNumberHints.mm"), 215, @"Bad level value: %lu", a3);
  }
  if (a4 && [(TSWPListStyle *)a2 labelTypeForLevel:a3] == 3)
  {
    id v14 = [(TSWPListStyle *)a2 baseStyleForTopicNumbers];
    int v40 = 0;
    id v41 = v14;
    __p = 0;
    long long v39 = 0;
    left = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *)this->_numbersForListStyle.__tree_.__pair1_.__value_.__left_;
    if (!left) {
      goto LABEL_20;
    }
    p_pair1 = &this->_numbersForListStyle.__tree_.__pair1_;
    do
    {
      unint64_t v17 = (unint64_t)left[4].__value_.__left_;
      BOOL v18 = v17 >= (unint64_t)v14;
      if (v17 >= (unint64_t)v14) {
        char v19 = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> **)left;
      }
      else {
        char v19 = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> **)&left[1];
      }
      if (v18) {
        p_pair1 = left;
      }
      left = *v19;
    }
    while (*v19);
    if (p_pair1 == &this->_numbersForListStyle.__tree_.__pair1_
      || v14 < p_pair1[4].__value_.__left_
      || &__p == (void **)&p_pair1[5])
    {
LABEL_20:
      uint64_t v20 = 0;
      uint64_t v21 = 0;
    }
    else
    {
      std::vector<TSWPTopicNumberEntry>::__assign_with_size[abi:nn180100]<TSWPTopicNumberEntry*,TSWPTopicNumberEntry*>(&__p, (long long *)p_pair1[5].__value_.__left_, (long long *)p_pair1[6].__value_.__left_, ((char *)p_pair1[6].__value_.__left_ - (char *)p_pair1[5].__value_.__left_) >> 4);
      uint64_t v20 = __p;
      uint64_t v21 = v39;
    }
    for (unint64_t i = ((char *)v21 - v20) >> 4; i <= a3; unint64_t i = ((char *)v21 - (unsigned char *)__p) >> 4)
    {
      if (v21 >= v40)
      {
        if ((i + 1) >> 60) {
          abort();
        }
        uint64_t v23 = (char *)v40 - v20;
        uint64_t v24 = v23 >> 3;
        if (v23 >> 3 <= i + 1) {
          uint64_t v24 = i + 1;
        }
        if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v25 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v25 = v24;
        }
        uint64_t v26 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLength>>((uint64_t)&v40, v25);
        unint64_t v28 = (long long *)&v26[16 * i];
        *unint64_t v28 = xmmword_22383ACE0;
        uint64_t v21 = v28 + 1;
        uint64_t v29 = (long long *)__p;
        for (uint64_t j = v39; j != v29; --j)
        {
          long long v31 = *(j - 1);
          *--unint64_t v28 = v31;
        }
        __p = v28;
        long long v39 = v21;
        int v40 = (long long *)&v26[16 * v27];
        if (v29) {
          operator delete(v29);
        }
      }
      else
      {
        *v21++ = xmmword_22383ACE0;
      }
      long long v39 = v21;
      uint64_t v20 = __p;
    }
    if (i > a3 + 1)
    {
      uint64_t v32 = (char *)v21 - v20 - 16;
      do
      {
        --v21;
        BOOL v18 = a3 + 1 >= v32 >> 4;
        v32 -= 16;
      }
      while (!v18);
      long long v39 = v21;
    }
    NSUInteger v33 = &v20[16 * a3];
    *NSUInteger v33 = a4;
    v33[1] = a5;
    BOOL v42 = (unint64_t *)&v41;
    uint64_t v34 = std::__tree<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::__map_value_compare<TSWPListStyle const*,std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::less<TSWPListStyle const*>,true>,std::allocator<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>>>::__emplace_unique_key_args<TSWPListStyle const*,std::piecewise_construct_t const&,std::tuple<TSWPListStyle const* const&>,std::tuple<>>((uint64_t **)this, (unint64_t *)&v41, (uint64_t)&std::piecewise_construct, (uint64_t **)&v42)+ 5;
    if (v34 != (uint64_t *)&__p) {
      std::vector<TSWPTopicNumberEntry>::__assign_with_size[abi:nn180100]<TSWPTopicNumberEntry*,TSWPTopicNumberEntry*>(v34, (long long *)__p, v39, ((char *)v39 - (unsigned char *)__p) >> 4);
    }
    validThroughCharIndeCGFloat x = this->_validThroughCharIndex;
    if (validThroughCharIndex != 0x7FFFFFFFFFFFFFFFLL && validThroughCharIndex > a5)
    {
      int v36 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v37 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPTopicNumberHints::setTopicNumberForList(TSWPListStyle *, TSWPParagraphLevel, NSUInteger, TSWPCharIndex)");
      objc_msgSend(v36, "handleFailureInFunction:file:lineNumber:description:", v37, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPTopicNumberHints.mm"), 245, @"Bad char index relative to _validThroughCharIndex");
    }
    TSWPTopicNumberHints::setCharIndexAndValidCharIndex(this, a5, a5);
    if (__p)
    {
      long long v39 = (long long *)__p;
      operator delete(__p);
    }
  }
}

void sub_2237051D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *TSWPTopicNumberHints::unarchiveSetEntriesForListStyle(uint64_t **a1, unint64_t a2, long long **a3)
{
  unint64_t v5 = a2;
  BOOL v6 = &v5;
  uint64_t result = std::__tree<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::__map_value_compare<TSWPListStyle const*,std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::less<TSWPListStyle const*>,true>,std::allocator<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>>>::__emplace_unique_key_args<TSWPListStyle const*,std::piecewise_construct_t const&,std::tuple<TSWPListStyle const* const&>,std::tuple<>>(a1, &v5, (uint64_t)&std::piecewise_construct, (uint64_t **)&v6)+ 5;
  if (result != (uint64_t *)a3) {
    return (uint64_t *)std::vector<TSWPTopicNumberEntry>::__assign_with_size[abi:nn180100]<TSWPTopicNumberEntry*,TSWPTopicNumberEntry*>(result, *a3, a3[1], a3[1] - *a3);
  }
  return result;
}

TSWPTopicNumberHints *TSWPTopicNumberHints::backUpByOneParagraph(TSWPTopicNumberHints *this, TSWPTopicNumberHints *a2, TSWPStorage *a3)
{
  charIndeCGFloat x = this->_charIndex;
  if (charIndex != 0x7FFFFFFFFFFFFFFFLL)
  {
    unint64_t v5 = TSWPTopicNumberHints::operator=(this, a2);
    return TSWPTopicNumberHints::advanceToCharIndex(v5, charIndex, a3);
  }
  return this;
}

id TSWPTopicNumberHints::resetWithStyleProvider(uint64_t a1, void *a2)
{
  *(int64x2_t *)(a1 + 24) = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
  BOOL v4 = (void *)(a1 + 8);
  std::__tree<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::__map_value_compare<TSWPListStyle const*,std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::less<TSWPListStyle const*>,true>,std::allocator<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>>>::destroy(a1, *(void **)(a1 + 8));
  *(void *)a1 = v4;
  *(void *)(a1 + 16) = 0;
  void *v4 = 0;

  id result = a2;
  *(void *)(a1 + 40) = result;
  return result;
}

uint64_t std::pair<TSWPListStyle const*&,std::vector<TSWPTopicNumberEntry> &>::operator=[abi:nn180100]<TSWPListStyle const* const,std::vector<TSWPTopicNumberEntry>,(void *)0>(uint64_t a1, uint64_t a2)
{
  **(void **)a1 = *(void *)a2;
  unsigned int v3 = *(void **)(a1 + 8);
  if (v3 != (void *)(a2 + 8)) {
    std::vector<TSWPTopicNumberEntry>::__assign_with_size[abi:nn180100]<TSWPTopicNumberEntry*,TSWPTopicNumberEntry*>(v3, *(long long **)(a2 + 8), *(long long **)(a2 + 16), (uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 4);
  }
  return a1;
}

uint64_t std::__tree<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::__map_value_compare<TSWPListStyle const*,std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::less<TSWPListStyle const*>,true>,std::allocator<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>>>::_DetachedTreeCache::~_DetachedTreeCache[abi:nn180100](uint64_t a1)
{
  std::__tree<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::__map_value_compare<TSWPListStyle const*,std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::less<TSWPListStyle const*>,true>,std::allocator<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>>>::destroy(*(void *)a1, *(void **)(a1 + 16));
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    unsigned int v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        unsigned int v2 = v3;
        unsigned int v3 = (void *)v3[2];
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    std::__tree<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::__map_value_compare<TSWPListStyle const*,std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::less<TSWPListStyle const*>,true>,std::allocator<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>>>::destroy(*(void *)a1, v2);
  }
  return a1;
}

uint64_t *std::__tree<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::__map_value_compare<TSWPListStyle const*,std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::less<TSWPListStyle const*>,true>,std::allocator<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>>>::__emplace_multi<std::pair<TSWPListStyle const* const,std::vector<TSWPTopicNumberEntry>> const&>(uint64_t a1, uint64_t a2)
{
  std::__tree<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::__map_value_compare<TSWPListStyle const*,std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::less<TSWPListStyle const*>,true>,std::allocator<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>>>::__construct_node<std::pair<TSWPListStyle const* const,std::vector<TSWPTopicNumberEntry>> const&>(a1, a2, (uint64_t)&v7);
  unsigned int v3 = (uint64_t **)(a1 + 8);
  BOOL v4 = *(uint64_t **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        unsigned int v3 = (uint64_t **)v4;
        if (v7[4] >= (unint64_t)v4[4]) {
          break;
        }
        BOOL v4 = (uint64_t *)*v4;
        unint64_t v5 = v3;
        if (!*v3) {
          goto LABEL_8;
        }
      }
      BOOL v4 = (uint64_t *)v4[1];
    }
    while (v4);
    unint64_t v5 = v3 + 1;
  }
  else
  {
    unint64_t v5 = (uint64_t **)(a1 + 8);
  }
LABEL_8:
  std::__tree<std::__value_type<std::string,unsigned short>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned short>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned short>>>::__insert_node_at((uint64_t **)a1, (uint64_t)v3, v5, v7);
  return v7;
}

char *std::__tree<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::__map_value_compare<TSWPListStyle const*,std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::less<TSWPListStyle const*>,true>,std::allocator<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>>>::__construct_node<std::pair<TSWPListStyle const* const,std::vector<TSWPTopicNumberEntry>> const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  BOOL v6 = operator new(0x40uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  uint64_t v7 = *(long long **)(a2 + 8);
  *((void *)v6 + 4) = *(void *)a2;
  *((void *)v6 + 6) = 0;
  *((void *)v6 + 7) = 0;
  *((void *)v6 + 5) = 0;
  id result = std::vector<TSWPTopicNumberEntry>::__init_with_size[abi:nn180100]<TSWPTopicNumberEntry*,TSWPTopicNumberEntry*>((char *)v6 + 40, v7, *(long long **)(a2 + 16), (uint64_t)(*(void *)(a2 + 16) - (void)v7) >> 4);
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_2237054C8(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,void *>>>::operator()[abi:nn180100](v3, v2);
  _Unwind_Resume(a1);
}

char *std::vector<TSWPTopicNumberEntry>::__init_with_size[abi:nn180100]<TSWPTopicNumberEntry*,TSWPTopicNumberEntry*>(char *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    BOOL v6 = result;
    id result = std::vector<CGPoint>::__vallocate[abi:nn180100](result, a4);
    uint64_t v7 = (_OWORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      long long v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,void *>>>::operator()[abi:nn180100](uint64_t a1, void *__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v3 = (void *)__p[5];
    if (v3)
    {
      __p[6] = v3;
      operator delete(v3);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

BOOL std::__equal_to::operator()[abi:nn180100]<std::pair<TSWPListStyle const* const,std::vector<TSWPTopicNumberEntry>>,std::pair<TSWPListStyle const* const,std::vector<TSWPTopicNumberEntry>>>(uint64_t a1, void *a2, void *a3)
{
  if (*a2 != *a3) {
    return 0;
  }
  BOOL v4 = (char *)a2[1];
  uint64_t v3 = (char *)a2[2];
  uint64_t v5 = (uint64_t *)a3[1];
  if (v3 - v4 != a3[2] - (void)v5) {
    return 0;
  }
  if (v4 == v3) {
    return 1;
  }
  do
  {
    uint64_t v6 = *(void *)v4;
    uint64_t v7 = *((void *)v4 + 1);
    v4 += 16;
    uint64_t v8 = *v5;
    uint64_t v9 = v5[1];
    v5 += 2;
    BOOL result = v6 == v8 && v7 == v9;
  }
  while (result && v4 != v3);
  return result;
}

_OWORD *std::vector<TSWPTopicNumberEntry>::__assign_with_size[abi:nn180100]<TSWPTopicNumberEntry*,TSWPTopicNumberEntry*>(void *a1, long long *a2, long long *a3, unint64_t a4)
{
  uint64_t v6 = a2;
  uint64_t v8 = a1[2];
  BOOL result = (_OWORD *)*a1;
  if (a4 > (v8 - (uint64_t)result) >> 4)
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 >> 60) {
      abort();
    }
    uint64_t v10 = v8 >> 3;
    if (v8 >> 3 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    std::vector<CGPoint>::__vallocate[abi:nn180100](a1, v11);
    uint64_t v13 = (_OWORD *)a1[1];
    int v12 = (_OWORD **)(a1 + 1);
    BOOL result = v13;
    id v14 = (char *)v13;
    if (v6 != a3)
    {
      id v14 = (char *)result;
      do
      {
        long long v15 = *v6++;
        *(_OWORD *)id v14 = v15;
        v14 += 16;
      }
      while (v6 != a3);
    }
LABEL_26:
    int64_t v25 = v14 - (char *)result;
    goto LABEL_27;
  }
  unint64_t v17 = (_OWORD *)a1[1];
  int v12 = (_OWORD **)(a1 + 1);
  unint64_t v16 = v17;
  unint64_t v18 = v17 - result;
  if (v18 >= a4)
  {
    id v14 = (char *)result;
    if (a2 != a3)
    {
      uint64_t v26 = result;
      do
      {
        long long v27 = *v6++;
        *v26++ = v27;
        v14 += 16;
      }
      while (v6 != a3);
    }
    goto LABEL_26;
  }
  char v19 = &a2[v18];
  if (v16 != result)
  {
    uint64_t v20 = 16 * v18;
    do
    {
      long long v21 = *v6++;
      *result++ = v21;
      v20 -= 16;
    }
    while (v20);
    BOOL result = *v12;
  }
  unint64_t v22 = (char *)result;
  if (v19 != a3)
  {
    unint64_t v22 = (char *)result;
    uint64_t v23 = result;
    do
    {
      long long v24 = *v19++;
      *v23++ = v24;
      v22 += 16;
    }
    while (v19 != a3);
  }
  int64_t v25 = v22 - (char *)result;
LABEL_27:
  *int v12 = (_OWORD *)((char *)result + v25);
  return result;
}

uint64_t *std::__tree<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::__map_value_compare<TSWPListStyle const*,std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::less<TSWPListStyle const*>,true>,std::allocator<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>>>::__emplace_unique_key_args<TSWPListStyle const*,std::piecewise_construct_t const&,std::tuple<TSWPListStyle const* const&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  uint64_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    unint64_t v11 = (uint64_t *)operator new(0x40uLL);
    uint64_t v12 = **a4;
    v11[6] = 0;
    v11[7] = 0;
    v11[4] = v12;
    _OWORD v11[5] = 0;
    std::__tree<std::__value_type<std::string,unsigned short>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned short>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned short>>>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

void sub_2237059B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_223705F40(_Unwind_Exception *a1, uint64_t a2, TSWPTopicNumberHints *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

void sub_223706094(_Unwind_Exception *a1)
{
  MEMORY[0x223CB8F20](v1, 0x10E1C405C8FB0CCLL);
  _Unwind_Resume(a1);
}

void sub_223706FA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
}

uint64_t TSWPAttributeEnumerator::TSWPAttributeEnumerator(uint64_t a1, void *a2, NSUInteger a3, NSUInteger a4, uint64_t a5)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = [a2 length];
  *(void *)(a1 + 24) = [a2 attributeArrayForKind:a5];
  *(unsigned char *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0x7FFFFFFFFFFFFFFFLL;
  v11.NSUInteger location = a3;
  v11.NSUInteger length = a4;
  TSWPAttributeEnumerator::resetRange((TSWPAttributeEnumerator *)a1, v11);
  return a1;
}

{
  _NSRange v11;

  *(void *)a1 = a2;
  *(void *)(a1 + 8) = [a2 length];
  *(void *)(a1 + 24) = [a2 attributeArrayForKind:a5];
  *(unsigned char *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0x7FFFFFFFFFFFFFFFLL;
  v11.NSUInteger location = a3;
  v11.NSUInteger length = a4;
  TSWPAttributeEnumerator::resetRange((TSWPAttributeEnumerator *)a1, v11);
  return a1;
}

TSWPAttributeArray *TSWPAttributeEnumerator::resetRange(TSWPAttributeEnumerator *this, _NSRange a2)
{
  *((void *)this + 2) = a2.location + a2.length;
  BOOL result = (TSWPAttributeArray *)*((void *)this + 3);
  if (result)
  {
    BOOL result = (TSWPAttributeArray *)TSWPAttributeArray::effectiveAttributeIndexForCharIndex(result, a2.location);
    *((void *)this + 5) = result;
    BOOL v4 = *((void *)this + 3) != 0;
  }
  else
  {
    BOOL v4 = 0;
  }
  *((unsigned char *)this + 32) = v4;
  return result;
}

uint64_t TSWPAttributeEnumerator::nextAttributeIndex(id *this, _NSRange *a2)
{
  if ((id)[*this length] != this[1])
  {
    BOOL v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = [NSString stringWithUTF8String:"TSWPAttributeRecord *TSWPAttributeEnumerator::nextAttributeIndex(NSRange *)"];
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPAttributeEnumerator.mm"), 56, @"Storage was modified while enumerating attributes");
  }
  if (*((unsigned char *)this + 32))
  {
    uint64_t v6 = (TSWPAttributeArray *)this[3];
    unint64_t v7 = (unint64_t)this[5];
    uint64_t v8 = (uint64_t)v6->var4 + 16 * v7;
    NSUInteger v9 = TSWPAttributeArray::charIndexForAttributeIndex(v6, v7);
    unint64_t v10 = (unint64_t)this[5] + 1;
    this[5] = (id)v10;
    _NSRange v11 = (TSWPAttributeArray *)this[3];
    if (v10 >= v11->var2)
    {
      *((unsigned char *)this + 32) = 0;
      uint64_t v13 = [*this length];
      if (!a2) {
        return v8;
      }
      goto LABEL_16;
    }
    unint64_t v12 = TSWPAttributeArray::charIndexForAttributeIndex(v11, v10);
    uint64_t v13 = v12;
    id v14 = this[2];
    if (v12 < (unint64_t)v14 || (id)v12 == v14 && v12 == [*this length])
    {
      *((unsigned char *)this + 32) = 1;
      if (!a2) {
        return v8;
      }
      goto LABEL_16;
    }
    *((unsigned char *)this + 32) = 0;
    if (a2)
    {
LABEL_16:
      NSUInteger v15 = v13 - v9;
      goto LABEL_17;
    }
  }
  else
  {
    if (a2)
    {
      NSUInteger v9 = [*this length];
      NSUInteger v15 = 0;
      uint64_t v8 = 0;
LABEL_17:
      a2->NSUInteger location = v9;
      a2->NSUInteger length = v15;
      return v8;
    }
    return 0;
  }
  return v8;
}

uint64_t TSWPCharacterStylePropertyEnumerator::TSWPCharacterStylePropertyEnumerator(uint64_t a1, void *a2, NSUInteger a3, NSUInteger a4, int a5)
{
  *(_DWORD *)a1 = a5;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = a4;
  *(void *)(a1 + 24) = a2;
  NSUInteger v9 = (TSWPAttributeEnumerator *)(a1 + 24);
  *(void *)(a1 + 32) = [a2 length];
  *(void *)(a1 + 48) = [a2 attributeArrayForKind:0];
  *(unsigned char *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0x7FFFFFFFFFFFFFFFLL;
  v14.NSUInteger location = a3;
  v14.NSUInteger length = a4;
  TSWPAttributeEnumerator::resetRange(v9, v14);
  *(void *)(a1 + 72) = TSWPAttributeEnumerator::nextAttributeIndex((id *)v9, (_NSRange *)(a1 + 80));
  NSUInteger v10 = TSUIntersectionRangeWithEdge();
  NSUInteger v12 = v11;
  *(void *)(a1 + 80) = v10;
  *(void *)(a1 + 88) = v11;
  *(void *)(a1 + 96) = a2;
  *(void *)(a1 + 104) = [a2 length];
  *(void *)(a1 + 120) = [a2 attributeArrayForKind:3];
  *(unsigned char *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0x7FFFFFFFFFFFFFFFLL;
  v15.NSUInteger location = v10;
  v15.NSUInteger length = v12;
  TSWPAttributeEnumerator::resetRange((TSWPAttributeEnumerator *)(a1 + 96), v15);
  *(void *)(a1 + 144) = TSWPAttributeEnumerator::nextAttributeIndex((id *)(a1 + 96), (_NSRange *)(a1 + 152));
  *(void *)(a1 + 168) = (id)TSWPCharacterStylePropertyEnumerator::pNextBoxedValue((TSWPCharacterStylePropertyEnumerator *)a1, (_NSRange *)(a1 + 176));
  return a1;
}

uint64_t TSWPCharacterStylePropertyEnumerator::pNextBoxedValue(TSWPCharacterStylePropertyEnumerator *this, _NSRange *a2)
{
  uint64_t v3 = *((void *)this + 9);
  if (!v3)
  {
    NSUInteger length = 0;
    uint64_t v7 = 0;
    NSUInteger location = 0x7FFFFFFFFFFFFFFFLL;
    goto LABEL_18;
  }
  uint64_t v5 = *((void *)this + 18);
  if (!v5)
  {
    uint64_t v13 = *(void **)(v3 + 8);
    if (!v13 || (uint64_t v7 = [v13 boxedValueForProperty:*(unsigned int *)this]) == 0) {
      uint64_t v7 = [MEMORY[0x263EFF9D0] null];
    }
    NSUInteger location = *((void *)this + 10);
    NSUInteger length = *((void *)this + 11);
    goto LABEL_17;
  }
  uint64_t v6 = *(void **)(v5 + 8);
  if (v6)
  {
    uint64_t v7 = [v6 boxedValueForProperty:*(unsigned int *)this];
    if (v7) {
      goto LABEL_9;
    }
    uint64_t v3 = *((void *)this + 9);
  }
  uint64_t v8 = *(void **)(v3 + 8);
  if (!v8 || (uint64_t v7 = [v8 boxedValueForProperty:*(unsigned int *)this]) == 0) {
    uint64_t v7 = [MEMORY[0x263EFF9D0] null];
  }
LABEL_9:
  NSRange v9 = NSIntersectionRange(*(NSRange *)((char *)this + 152), *((NSRange *)this + 5));
  NSUInteger location = v9.location;
  NSUInteger length = v9.length;
  AttributeIndeCGFloat x = TSWPAttributeEnumerator::nextAttributeIndex((id *)this + 12, (_NSRange *)((char *)this + 152));
  *((void *)this + 18) = AttributeIndex;
  if (!AttributeIndex)
  {
    NSUInteger v15 = *((void *)this + 10) - (v9.location + v9.length) + *((void *)this + 11);
    *((void *)this + 10) = v9.location + v9.length;
    *((void *)this + 11) = v15;
    if (v15) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  if (!*((void *)this + 11))
  {
LABEL_17:
    *((void *)this + 9) = TSWPAttributeEnumerator::nextAttributeIndex((id *)this + 3, (_NSRange *)this + 5);
    _NSRange v16 = NSIntersectionRange(*((NSRange *)this + 5), *(NSRange *)((char *)this + 8));
    *((NSRange *)this + 5) = v16;
    TSWPAttributeEnumerator::resetRange((TSWPCharacterStylePropertyEnumerator *)((char *)this + 96), v16);
    *((void *)this + 18) = TSWPAttributeEnumerator::nextAttributeIndex((id *)this + 12, (_NSRange *)((char *)this + 152));
  }
LABEL_18:
  a2->NSUInteger location = location;
  a2->NSUInteger length = length;
  return v7;
}

void TSWPCharacterStylePropertyEnumerator::~TSWPCharacterStylePropertyEnumerator(id *this)
{
}

{
}

id TSWPCharacterStylePropertyEnumerator::nextBoxedValue(NSRange *this, _NSRange *a2)
{
  NSUInteger length = (void *)this[10].length;
  if (!length)
  {
    NSUInteger i = 0;
    id v5 = 0;
    NSUInteger location = 0x7FFFFFFFFFFFFFFFLL;
    if (!a2) {
      return v5;
    }
    goto LABEL_12;
  }
  id v5 = length;
  NSUInteger location = this[11].location;
  for (NSUInteger i = this[11].length; ; NSUInteger i = v9.length)
  {
    id BoxedValue = (id)TSWPCharacterStylePropertyEnumerator::pNextBoxedValue((TSWPCharacterStylePropertyEnumerator *)this, this + 11);
    this[10].NSUInteger length = (NSUInteger)BoxedValue;
    if (!BoxedValue)
    {
      NSUInteger v10 = 0;
      goto LABEL_11;
    }
    if (BoxedValue != v5 && ([BoxedValue isEqual:v5] & 1) == 0) {
      break;
    }
    v13.NSUInteger location = location;
    v13.NSUInteger length = i;
    NSRange v9 = NSUnionRange(v13, this[11]);
    NSUInteger location = v9.location;
  }
  NSUInteger v10 = (void *)this[10].length;
LABEL_11:
  id v11 = v10;
  if (a2)
  {
LABEL_12:
    a2->NSUInteger location = location;
    a2->NSUInteger length = i;
  }
  return v5;
}

void sub_223707904(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_223708700(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_2237090AC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_223709364(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_223709690(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id obj)
{
}

void sub_223709B88(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_223709DF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id obj)
{
}

void sub_22370A0AC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22370A1B0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void TSWPParagraphEnumerator::TSWPParagraphEnumerator(TSWPParagraphEnumerator *this, const TSWPParagraphEnumerator *a2)
{
  *(_OWORD *)&this->int var0 = *(_OWORD *)&a2->var0;
  *(_OWORD *)&this->unint64_t var2 = *(_OWORD *)&a2->var2;
  *(_OWORD *)&this->int var4 = *(_OWORD *)&a2->var4;
  this->var6 = 1;
}

{
  *(_OWORD *)&this->int var0 = *(_OWORD *)&a2->var0;
  *(_OWORD *)&this->unint64_t var2 = *(_OWORD *)&a2->var2;
  *(_OWORD *)&this->int var4 = *(_OWORD *)&a2->var4;
  this->var6 = 1;
}

unint64_t TSWPParagraphEnumerator::firstValidParIndex(TSWPParagraphEnumerator *this)
{
  return this->var4;
}

void *TSWPParagraphEnumerator::operator--(void *result)
{
  uint64_t v1 = result[4] - 1;
  result[4] = v1;
  result[5] = v1;
  result[2] = v1;
  return result;
}

void *TSWPParagraphEnumerator::operator++(void *result)
{
  uint64_t v1 = result[5] + 1;
  result[4] = v1;
  result[5] = v1;
  result[2] = v1;
  return result;
}

BOOL TSWPParagraphEnumerator::operator==(void *a1, void *a2)
{
  return *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] && a1[3] == a2[3] && a1[4] == a2[4] && a1[5] == a2[5];
}

BOOL TSWPParagraphEnumerator::operator!=(void *a1, void *a2)
{
  return !TSWPParagraphEnumerator::operator==(a1, a2);
}

__n128 TSWPParagraphEnumerator::previous@<Q0>(TSWPParagraphEnumerator *this@<X0>, uint64_t a2@<X8>)
{
  __n128 result = *(__n128 *)&this->var0;
  *(_OWORD *)a2 = *(_OWORD *)&this->var0;
  unint64_t var3 = this->var3;
  unint64_t var4 = this->var4;
  *(unsigned char *)(a2 + 48) = 1;
  *(void *)(a2 + 32) = --var4;
  *(void *)(a2 + 40) = var4;
  *(void *)(a2 + 16) = var4;
  *(void *)(a2 + 24) = var3;
  return result;
}

__n128 TSWPParagraphEnumerator::next@<Q0>(TSWPParagraphEnumerator *this@<X0>, uint64_t a2@<X8>)
{
  __n128 result = *(__n128 *)&this->var0;
  *(_OWORD *)a2 = *(_OWORD *)&this->var0;
  unint64_t var3 = this->var3;
  unint64_t var5 = this->var5;
  *(unsigned char *)(a2 + 48) = 1;
  *(void *)(a2 + 32) = ++var5;
  *(void *)(a2 + 40) = var5;
  *(void *)(a2 + 16) = var5;
  *(void *)(a2 + 24) = var3;
  return result;
}

uint64_t TSWPParagraphEnumerator::parTable(TSWPParagraphEnumerator *this)
{
  return [this->var0 attributeArrayForKind:0];
}

uint64_t TSWPParagraphEnumerator::listLabelParagraphStyleOverride(TSWPParagraphEnumerator *this)
{
  if (this->var2 >= this->var3 || !this->var1 || (objc_opt_respondsToSelector() & 1) == 0) {
    return 0;
  }
  id var1 = this->var1;
  unint64_t var2 = this->var2;

  return [var1 listLabelParagraphStyleOverrideAtParIndex:var2];
}

uint64_t TSWPParagraphEnumerator::paragraphString(TSWPParagraphEnumerator *this)
{
  NSUInteger v3 = TSWPParagraphEnumerator::paragraphTextRange(this);
  id var0 = this->var0;

  return objc_msgSend(var0, "substringWithRange:", v3, v2);
}

uint64_t TSWPParagraphEnumerator::attachmentOrFootnoteAtCharIndex(TSWPParagraphEnumerator *this, uint64_t a2)
{
  NSUInteger v4 = TSWPParagraphEnumerator::paragraphTextRange(this);
  if (!v5) {
    return 0;
  }
  NSUInteger v6 = v4 + a2;
  id var0 = this->var0;

  return [var0 attachmentOrFootnoteAtCharIndex:v6];
}

uint64_t TSWPParagraphEnumerator::paragraphListStart(TSWPParagraphEnumerator *this)
{
  id var0 = this->var0;
  uint64_t v2 = [this->var0 textRangeForParagraphAtIndex:this->var2];

  return [var0 listStartAtCharIndex:v2];
}

uint64_t TSWPParagraphEnumerator::paragraphListNumber(TSWPParagraphEnumerator *this, void *a2)
{
  if (!this->var1 || (objc_opt_respondsToSelector() & 1) == 0) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  id var1 = this->var1;
  unint64_t var2 = this->var2;

  return [var1 listNumberAtParIndex:var2 numberingData:a2];
}

void *TSWPParagraphEnumerator::paragraphHasListLabel(TSWPParagraphEnumerator *this)
{
  __n128 result = (void *)TSWPParagraphEnumerator::paragraphListStyle(this);
  if (result) {
    return (void *)([result firstLabelType] != 0);
  }
  return result;
}

BOOL TSWPParagraphEnumerator::isLastParagraph(TSWPParagraphEnumerator *this)
{
  return this->var5 + 1 >= this->var3;
}

void sub_223713374(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_223714578(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, TSWPParagraphEnumerator *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
}

void sub_2237171A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__20(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__20(uint64_t a1)
{
}

void sub_223717B74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24)
{
  if (__p) {
    operator delete(__p);
  }
  uint64_t v26 = *(void **)(v24 - 120);
  if (v26)
  {
    *(void *)(v24 - 112) = v26;
    operator delete(v26);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<TSWPLFWritingDirectionRun>::push_back[abi:nn180100](void **a1, long long *a2)
{
  NSUInteger v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= (unint64_t)v6)
  {
    unint64_t v11 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v7 - (void)*a1) >> 3);
    unint64_t v12 = v11 + 1;
    if (v11 + 1 > 0x666666666666666) {
      abort();
    }
    unint64_t v13 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - (unsigned char *)*a1) >> 3);
    if (2 * v13 > v12) {
      unint64_t v12 = 2 * v13;
    }
    if (v13 >= 0x333333333333333) {
      unint64_t v14 = 0x666666666666666;
    }
    else {
      unint64_t v14 = v12;
    }
    if (v14) {
      NSUInteger v15 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<EQKit::StemStretch::Key,unsigned long>>>(v4, v14);
    }
    else {
      NSUInteger v15 = 0;
    }
    _NSRange v16 = &v15[40 * v11];
    unint64_t v17 = &v15[40 * v14];
    long long v18 = *a2;
    long long v19 = a2[1];
    *((void *)v16 + 4) = *((void *)a2 + 4);
    *(_OWORD *)_NSRange v16 = v18;
    *((_OWORD *)v16 + 1) = v19;
    NSUInteger v10 = v16 + 40;
    long long v21 = (char *)*a1;
    uint64_t v20 = (char *)a1[1];
    if (v20 != *a1)
    {
      do
      {
        long long v22 = *(_OWORD *)(v20 - 40);
        long long v23 = *(_OWORD *)(v20 - 24);
        *((void *)v16 - 1) = *((void *)v20 - 1);
        *(_OWORD *)(v16 - 24) = v23;
        *(_OWORD *)(v16 - 40) = v22;
        v16 -= 40;
        v20 -= 40;
      }
      while (v20 != v21);
      uint64_t v20 = (char *)*a1;
    }
    *a1 = v16;
    a1[1] = v10;
    a1[2] = v17;
    if (v20) {
      operator delete(v20);
    }
  }
  else
  {
    long long v8 = *a2;
    long long v9 = a2[1];
    *(void *)(v7 + 32) = *((void *)a2 + 4);
    *(_OWORD *)unint64_t v7 = v8;
    *(_OWORD *)(v7 + 16) = v9;
    NSUInteger v10 = (char *)(v7 + 40);
  }
  a1[1] = v10;
}

void sub_223718168(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_22371BC74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_22371BED0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double TSWPLineFragment::lowestBaselineInRange(TSWPLineFragment *this, _NSRange a2, TSWPColumn *a3)
{
  NSUInteger length = a2.length;
  NSUInteger location = a2.location;
  v35[2] = *MEMORY[0x263EF8340];
  double v7 = *((double *)this + 4) + *((double *)this + 5);
  long long v8 = [(TSWPColumn *)a3 storage];
  NSUInteger v9 = location + length;
  if (location < v9)
  {
    NSUInteger v10 = v8;
    do
    {
      double v11 = *((double *)this + 4);
      double v12 = *((double *)this + 5);
      uint64_t v13 = [(TSWPStorage *)v10 characterStyleAtCharIndex:location effectiveRange:&v33];
      if (![(TSWPColumn *)a3 styleProvider])
      {
        unint64_t v14 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v15 = objc_msgSend(NSString, "stringWithUTF8String:", "CGFloat TSWPLineFragment::lowestBaselineInRange(NSRange, TSWPColumn *) const");
        objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", v15, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 147, @"No style provider.");
      }
      double v16 = v11 + v12;
      unint64_t v17 = (void *)[(TSWPStyleProvider *)[(TSWPColumn *)a3 styleProvider] paragraphStyleAtParIndex:[(TSWPStorage *)v10 paragraphIndexAtCharIndex:location] effectiveRange:&v31];
      v35[0] = v13;
      v35[1] = v17;
      long long v18 = (void *)TSWPResolvePropertyForStyles((uint64_t)v35, 2uLL, 36, 0);
      if (v18)
      {
        int v19 = [v18 intValue];
        if (v19)
        {
          int v20 = v19;
          FontForStyle = TSWPFastCreateFontForStyle(v13, v17, [(TSWPColumn *)a3 scaleTextPercent]);
          CGFloat Size = CTFontGetSize(FontForStyle);
          CopyWithAttributes = CTFontCreateCopyWithAttributes(FontForStyle, Size * 1.5, 0, 0);
          if (v20 == 2)
          {
            double Descent = CTFontGetDescent(FontForStyle);
            double v16 = v16 - (Descent + CTFontGetDescent(CopyWithAttributes));
          }
          else if (v20 == 1)
          {
            double Ascent = CTFontGetAscent(FontForStyle);
            double v16 = v16 + Ascent - CTFontGetAscent(CopyWithAttributes);
          }
          CFRelease(CopyWithAttributes);
          CFRelease(FontForStyle);
        }
      }
      uint64_t v26 = (void *)TSWPResolvePropertyForStyles((uint64_t)v35, 2uLL, 33, 0);
      if (v26) {
        [v26 doubleValue];
      }
      else {
        double v27 = 0.0;
      }
      double v28 = v16 - v27;
      if (v28 > v7) {
        double v7 = v28;
      }
      NSUInteger v29 = v34 + v33;
      if (v34 + v33 >= (unint64_t)(v32 + v31)) {
        NSUInteger v29 = v32 + v31;
      }
      if (v34) {
        NSUInteger location = v29;
      }
      else {
        NSUInteger location = v32 + v31;
      }
    }
    while (location < v9);
  }
  return v7;
}

double TSWPLineFragment::baselineShiftFromRunAttributes(TSWPLineFragment *this, const __CFDictionary *a2)
{
  NSUInteger v3 = (void *)[(TSWPLineFragment *)this objectForKeyedSubscript:@"TSWPBaselineShift"];
  if (v3)
  {
    [v3 doubleValue];
    double v5 = v4;
  }
  else
  {
    double v5 = 0.0;
  }
  NSUInteger v6 = (void *)[(TSWPLineFragment *)this objectForKeyedSubscript:@"TSWPSuperscript"];
  if (v6)
  {
    int v7 = [v6 unsignedIntValue];
    if (v7)
    {
      int v8 = v7;
      NSUInteger v9 = (const __CTFont *)[(TSWPLineFragment *)this objectForKeyedSubscript:@"TSWPUnadjustedFont"];
      uint64_t v10 = *MEMORY[0x263F039A0];
      double v11 = (const __CTFont *)[(TSWPLineFragment *)this objectForKeyedSubscript:*MEMORY[0x263F039A0]];
      double v12 = (void *)[(TSWPLineFragment *)this objectForKeyedSubscript:kTSWPAttachmentMap];
      if (v12)
      {
        uint64_t v13 = (const __CTLine *)[v12 lineRef];
        if (v13)
        {
          unint64_t v14 = (const __CTRun *)[(__CFArray *)CTLineGetGlyphRuns(v13) firstObject];
          if (v14)
          {
            double v11 = (const __CTFont *)[(__CFDictionary *)CTRunGetAttributes(v14) objectForKeyedSubscript:v10];
          }
          else
          {
            uint64_t v15 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v16 = [NSString stringWithUTF8String:"static CGFloat TSWPLineFragment::baselineShiftFromRunAttributes(const CFDictionaryRef)"];
            objc_msgSend(v15, "handleFailureInFunction:file:lineNumber:description:", v16, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 210, @"invalid nil value for '%s'", "run");
          }
        }
      }
      if (v8 == 2)
      {
        double Descent = CTFontGetDescent(v11);
        double Ascent = CTFontGetDescent(v9);
        return v5 + Descent - Ascent;
      }
      if (v8 == 1)
      {
        double Descent = CTFontGetAscent(v9);
        double Ascent = CTFontGetAscent(v11);
        return v5 + Descent - Ascent;
      }
    }
  }
  return v5;
}

void TSWPLineFragment::rectsForVisualRange(TSWPLineFragment *this@<X0>, _NSRange a2@<0:X1, 8:X2>, unint64_t a3@<X3>, unint64_t a4@<X4>, char a5@<W5>, char a6@<W6>, int a7@<W7>, double **a8@<X8>, NSArray **a9)
{
  NSUInteger length = a2.length;
  NSUInteger location = a2.location;
  v78[1] = *MEMORY[0x263EF8340];
  if (a2.location < *(void *)this || a2.location + a2.length > *((void *)this + 1) + *(void *)this)
  {
    char v74 = a6;
    int v20 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v21 = objc_msgSend(NSString, "stringWithUTF8String:", "CGRectVector TSWPLineFragment::rectsForVisualRange(NSRange, NSUInteger, NSUInteger, BOOL, BOOL, BOOL, NSArray **) const");
    objc_msgSend(v20, "handleFailureInFunction:file:lineNumber:description:", v21, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 489, @"Bad range");
    a6 = v74;
  }
  if (a5) {
    double v22 = *((double *)this + 9);
  }
  else {
    double v22 = *((double *)this + 14) + *((double *)this + 18) + *((double *)this + 16) + *((double *)this + 17);
  }
  double v23 = *((double *)this + 7);
  if ((a6 & 1) == 0)
  {
    double v24 = *((double *)this + 14);
    double v23 = v23 + v24;
    double v22 = v22 - v24;
  }
  if (length)
  {
    double width = *((double *)this + 8);
    double v71 = *((double *)this + 6);
    uint64_t v25 = *((void *)this + 24);
    if (*((void *)this + 25) != v25)
    {
      CGFloat descent = 0.0;
      CGFloat ascent = 0.0;
      if (a7)
      {
        if (*((void *)this + 29) != *((void *)this + 28))
        {
          CTLineGetTypographicBounds(*(CTLineRef *)v25, &ascent, &descent, 0);
          uint64_t v26 = *((void *)this + 28);
          if (v26 != *((void *)this + 29))
          {
            double v27 = *(double *)(v25 + 16) - ascent;
            do
            {
              double TypographicBounds = CTLineGetTypographicBounds(*(CTLineRef *)v26, &ascent, &descent, 0);
              CGFloat x = *(double *)(v26 + 8);
              double height = ascent + descent;
              if (v26 == *((void *)this + 28))
              {
                double y = *(double *)(v26 + 16) - ascent;
              }
              else
              {
                v79.origin.CGFloat x = v12;
                v79.origin.double y = y;
                v79.size.double width = v11;
                v79.size.double height = v10;
                double v30 = *(double *)(v26 + 16) - ascent;
                CGRect v80 = CGRectUnion(v79, *(CGRect *)&x);
                CGFloat x = v80.origin.x;
                double y = v80.origin.y;
                double TypographicBounds = v80.size.width;
                double height = v80.size.height;
              }
              v26 += 48;
              CGFloat v10 = height;
              CGFloat v11 = TypographicBounds;
              CGFloat v12 = x;
            }
            while (v26 != *((void *)this + 29));
            if (y < v27)
            {
              double v32 = v27 - y - *((double *)this + 18);
              double v23 = v23 - v32;
              double v22 = v22 + v32;
            }
          }
        }
      }
      double v33 = *(double *)(MEMORY[0x263F001A0] + 8);
      CGFloat v34 = *(double *)(MEMORY[0x263F001A0] + 24);
      CGFloat v73 = *(double *)(MEMORY[0x263F001A0] + 16);
      double v75 = *MEMORY[0x263F001A0];
      CharIndexDatCATransform3D a = (void *)TSWPLineFragment::getCharIndexData(this);
      uint64_t v36 = CharIndexData[1] - *CharIndexData;
      if (v36)
      {
        unint64_t v37 = v36 >> 6;
        if (v37 <= 1) {
          unint64_t v37 = 1;
        }
        long long v38 = (double *)(*CharIndexData + 40);
        CGFloat v39 = v34;
        CGFloat v40 = v73;
        double v41 = v75;
        double v42 = v33;
        do
        {
          unint64_t v43 = *((void *)v38 - 5);
          unint64_t v44 = *((void *)v38 - 4);
          BOOL v45 = a3 < v43 || a3 - v43 >= v44;
          int v46 = !v45;
          if (v45 && (a4 < v43 || a4 - v43 >= v44)) {
            goto LABEL_44;
          }
          double v48 = *(v38 - 1);
          double v49 = *v38 - v48;
          double v50 = v48 + *((double *)this + 6);
          double v51 = *(double *)(v25 + 8);
          double v52 = *(double *)(v25 + 16);
          double v53 = v50 + v51;
          double v54 = v23 + v52;
          if (v46)
          {
            CGFloat v73 = v49;
            double v75 = v50 + v51;
            double v33 = v23 + v52;
            CGFloat v34 = v22;
          }
          BOOL v45 = a4 >= v43;
          unint64_t v55 = a4 - v43;
          if (!v45 || v55 >= v44)
          {
LABEL_44:
            double v53 = v41;
            double v54 = v42;
            double v49 = v40;
          }
          else
          {
            CGFloat v39 = v22;
          }
          v38 += 8;
          CGFloat v40 = v49;
          double v42 = v54;
          double v41 = v53;
          --v37;
        }
        while (v37);
      }
      else
      {
        double v49 = v73;
        double v53 = v75;
        double v54 = v33;
        CGFloat v39 = v34;
      }
      int v57 = *((_DWORD *)this + 6);
      v81.size.double width = v73;
      v81.origin.CGFloat x = v75;
      v81.origin.double y = v33;
      v81.size.double height = v34;
      if (CGRectIsEmpty(v81))
      {
        double v58 = width + -1.0;
        if ((v57 & 0x1000) == 0) {
          double v58 = -0.0;
        }
        CGFloat v73 = 1.0;
        double v75 = v71 + v58;
        double v33 = v23;
        CGFloat v34 = v22;
      }
      v82.origin.CGFloat x = v53;
      v82.origin.double y = v54;
      v82.size.double width = v49;
      v82.size.double height = v39;
      if (CGRectIsEmpty(v82))
      {
        double v59 = width + -1.0;
        if ((v57 & 0x1000) != 0) {
          double v59 = -0.0;
        }
        double v53 = v71 + v59;
        double v49 = 1.0;
        double v54 = v23;
        CGFloat v39 = v22;
      }
      v83.size.double width = v73;
      v83.origin.CGFloat x = v75;
      v83.origin.double y = v33;
      v83.size.double height = v34;
      v85.origin.CGFloat x = v53;
      v85.origin.double y = v54;
      v85.size.double width = v49;
      v85.size.double height = v39;
      CGRect v84 = CGRectUnion(v83, v85);
      double width = v84.size.width;
      double v71 = v84.origin.x;
      double v23 = v84.origin.y;
      double v22 = v84.size.height;
    }
  }
  else
  {
    double v71 = TSWPLineFragment::wpOffsetForCharIndex(this, location, 0, 1, 0);
    double width = 0.0;
  }
  *a8 = 0;
  a8[1] = 0;
  a8[2] = 0;
  BOOL v60 = (double *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::segment_data<double>>>((uint64_t)(a8 + 2), 1uLL);
  BOOL v61 = *a8;
  BOOL v62 = a8[1];
  int v64 = &v60[4 * v63];
  *BOOL v60 = v71;
  v60[1] = v23;
  v60[2] = width;
  v60[3] = v22;
  int v65 = v60 + 4;
  if (v62 != v61)
  {
    int v66 = v60;
    do
    {
      long long v67 = *((_OWORD *)v62 - 1);
      BOOL v60 = v66 - 4;
      *((_OWORD *)v66 - 2) = *((_OWORD *)v62 - 2);
      *((_OWORD *)v66 - 1) = v67;
      v62 -= 4;
      v66 -= 4;
    }
    while (v62 != v61);
  }
  *a8 = v60;
  a8[1] = v65;
  a8[2] = v64;
  if (v61) {
    operator delete(v61);
  }
  a8[1] = v65;
  if (a9)
  {
    if (a3 <= a4) {
      unint64_t v68 = a4;
    }
    else {
      unint64_t v68 = a3;
    }
    if (a3 >= a4) {
      uint64_t v69 = a4;
    }
    else {
      uint64_t v69 = a3;
    }
    v78[0] = objc_msgSend(MEMORY[0x263F08D40], "valueWithRange:", v69, v68 - v69, *(void *)&width);
    *a9 = (NSArray *)[MEMORY[0x263EFF8C0] arrayWithObjects:v78 count:1];
  }
}

void sub_22371CA14(_Unwind_Exception *exception_object)
{
  NSUInteger v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TSWPLineFragment::GetFakeContext(TSWPLineFragment *this)
{
  if (TSWPLineFragment::GetFakeContext(void)::onceToken != -1) {
    dispatch_once(&TSWPLineFragment::GetFakeContext(void)::onceToken, &__block_literal_global_67);
  }
  return TSWPLineFragment::GetFakeContext(void)::sFakeContext;
}

CGContextRef ___ZN16TSWPLineFragment14GetFakeContextEv_block_invoke()
{
  uint64_t v0 = (CGColorSpace *)TSUDeviceRGBColorSpace();
  CGContextRef result = CGBitmapContextCreate(0, 1uLL, 1uLL, 8uLL, 4uLL, v0, 5u);
  TSWPLineFragment::GetFakeContext(void)::sFakeContext = (uint64_t)result;
  return result;
}

double TSWPLineFragment::glyphRectForLineRange(TSWPLineFragment *this, _NSRange a2, TSWPStorage *a3, int a4)
{
  uint64_t v98 = *MEMORY[0x263EF8340];
  double v5 = *MEMORY[0x263F001A0];
  CGFloat v6 = *(double *)(MEMORY[0x263F001A0] + 8);
  CGFloat v7 = *(double *)(MEMORY[0x263F001A0] + 16);
  CGFloat v8 = *(double *)(MEMORY[0x263F001A0] + 24);
  double v9 = *((double *)this + 4) + *((double *)this + 5);
  double v76 = v9
      + TSWPLineFragment::baselineAdjustAtCharIndex((TSWPLineFragment *)a2.location, (void *)[(TSWPStorage *)a3 storage], a3, 0, [(TSWPStorage *)a3 scaleTextPercent]);
  CGFloat v10 = (CTLineRef *)*((void *)this + 31);
  unint64_t v68 = (CTLineRef *)*((void *)this + 32);
  if (v10 == v68) {
    goto LABEL_98;
  }
  char v11 = 0;
  do
  {
    NSUInteger v13 = (NSUInteger)v10[3];
    NSUInteger v12 = (NSUInteger)v10[4];
    unint64_t v14 = (void *)*((void *)this + 23);
    if (!v14)
    {
      uint64_t v15 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v16 = objc_msgSend(NSString, "stringWithUTF8String:", "CGRect TSWPLineFragment::glyphRectForLineRange(NSRange, TSWPColumn *, BOOL) const");
      objc_msgSend(v15, "handleFailureInFunction:file:lineNumber:description:", v16, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 631, @"invalid nil value for '%s'", "_textSource");
      unint64_t v14 = (void *)*((void *)this + 23);
    }
    v109.NSUInteger location = objc_msgSend(v14, "charRangeMappedFromStorage:", a2.location, a2.length);
    v109.NSUInteger length = v17;
    v99.NSUInteger location = v13;
    v99.NSUInteger length = v12;
    NSRange v18 = NSIntersectionRange(v99, v109);
    if (v18.length)
    {
      obCFIndex j = CTLineGetGlyphRuns(*v10);
      long long v94 = 0u;
      long long v95 = 0u;
      long long v92 = 0u;
      long long v93 = 0u;
      uint64_t v74 = [(__CFArray *)obj countByEnumeratingWithState:&v92 objects:v97 count:16];
      if (v74)
      {
        uint64_t v72 = *(void *)v93;
        do
        {
          for (uint64_t i = 0; i != v74; ++i)
          {
            if (*(void *)v93 != v72) {
              objc_enumerationMutation(obj);
            }
            int v20 = *(const __CTRun **)(*((void *)&v92 + 1) + 8 * i);
            CFIndex GlyphCount = CTRunGetGlyphCount(v20);
            std::vector<long>::vector(&buffer, GlyphCount);
            v101.NSUInteger location = 0;
            v101.NSUInteger length = GlyphCount;
            CTRunGetStringIndices(v20, v101, buffer);
            std::vector<unsigned short>::vector(&v89, GlyphCount);
            v102.NSUInteger location = 0;
            v102.NSUInteger length = GlyphCount;
            CTRunGetGlyphs(v20, v102, *(CGGlyph **)&v89.x);
            CTRunGetStringRange(v20);
            v103.NSUInteger location = 0;
            v103.NSUInteger length = 1;
            CTRunGetPositions(v20, v103, &r2);
            if (GlyphCount >= 1)
            {
              for (CFIndex j = 0; j != GlyphCount; ++j)
              {
                NSUInteger v23 = buffer[j] + v13;
                BOOL v25 = v23 >= v18.location;
                NSUInteger v24 = v23 - v18.location;
                BOOL v25 = !v25 || v24 >= v18.length;
                if (!v25 && *(__int16 *)(*(void *)&v89.x + 2 * j) != -1)
                {
                  if (TSWPLineFragment::GetFakeContext(void)::onceToken != -1) {
                    dispatch_once(&TSWPLineFragment::GetFakeContext(void)::onceToken, &__block_literal_global_67);
                  }
                  v110.NSUInteger location = j;
                  v110.NSUInteger length = 1;
                  CGRect ImageBounds = CTRunGetImageBounds(v20, (CGContextRef)TSWPLineFragment::GetFakeContext(void)::sFakeContext, v110);
                  CGFloat x = ImageBounds.origin.x;
                  CGFloat y = ImageBounds.origin.y;
                  CGFloat width = ImageBounds.size.width;
                  CGFloat height = ImageBounds.size.height;
                  memset(&v87, 0, sizeof(v87));
                  CGAffineTransformMakeTranslation(&v87, *((double *)this + 6) + *((double *)v10 + 1), v76 + *((double *)v10 + 2));
                  CGAffineTransform v85 = v87;
                  CGAffineTransformRotate(&v86, &v85, -1.57079633);
                  CGAffineTransform v87 = v86;
                  CGAffineTransform v84 = v86;
                  CGAffineTransformScale(&v86, &v84, 1.0, -1.0);
                  CGAffineTransform v87 = v86;
                  CGAffineTransform v83 = v86;
                  v113.origin.CGFloat x = x;
                  v113.origin.CGFloat y = y;
                  v113.size.CGFloat width = width;
                  v113.size.CGFloat height = height;
                  CGRect v114 = CGRectApplyAffineTransform(v113, &v83);
                  v124.origin.CGFloat x = v114.origin.x;
                  v124.size.CGFloat width = v114.size.width;
                  v124.size.CGFloat height = v114.size.height;
                  v124.origin.CGFloat y = v114.origin.y - r2.x;
                  v114.origin.CGFloat x = v5;
                  v114.origin.CGFloat y = v6;
                  v114.size.CGFloat width = v7;
                  v114.size.CGFloat height = v8;
                  CGRect v115 = CGRectUnion(v114, v124);
                  double v5 = v115.origin.x;
                  CGFloat v6 = v115.origin.y;
                  CGFloat v7 = v115.size.width;
                  CGFloat v8 = v115.size.height;
                }
              }
            }
            if (*(void *)&v89.x)
            {
              v89.CGFloat y = v89.x;
              operator delete(*(void **)&v89.x);
            }
            if (buffer)
            {
              uint64_t v91 = buffer;
              operator delete(buffer);
            }
          }
          uint64_t v74 = [(__CFArray *)obj countByEnumeratingWithState:&v92 objects:v97 count:16];
        }
        while (v74);
      }
      char v11 = 1;
    }
    v10 += 6;
  }
  while (v10 != v68);
  if ((v11 & 1) == 0)
  {
LABEL_98:
    if (*((void *)this + 25) != *((void *)this + 24))
    {
      if (TSWPLineFragment::GetFakeContext(void)::onceToken != -1) {
        dispatch_once(&TSWPLineFragment::GetFakeContext(void)::onceToken, &__block_literal_global_67);
      }
      CGContextSetTextPosition((CGContextRef)TSWPLineFragment::GetFakeContext(void)::sFakeContext, 0.0, 0.0);
      uint64_t v30 = *((void *)this + 25) - *((void *)this + 24);
      if (v30)
      {
        unint64_t v31 = 0xAAAAAAAAAAAAAAABLL * (v30 >> 4);
        keCGFloat y = (void *)*MEMORY[0x263F039A0];
        NSUInteger location = a2.location;
        NSUInteger length = a2.length;
        do
        {
          --v31;
          uint64_t v34 = *((void *)this + 24) + 48 * v31;
          v87.CATransform3D a = *(CGFloat *)v34;
          *(_OWORD *)&v87.CATransform3D b = *(_OWORD *)(v34 + 8);
          *(_OWORD *)&v87.d = *(_OWORD *)(v34 + 24);
          LODWORD(v87.ty) = *(_DWORD *)(v34 + 40);
          CGFloat cf = v87.a;
          if (*(void *)&v87.a)
          {
            CFRetain(*(CFTypeRef *)&v87.a);
            NSUInteger location = a2.location;
            NSUInteger length = a2.length;
          }
          if (v31)
          {
            v100.NSUInteger location = location;
            v100.NSUInteger length = length;
            if (!NSIntersectionRange(v100, *(NSRange *)(&v87 + 24)).length) {
              goto LABEL_89;
            }
          }
          else if (*((unsigned char *)this + 24))
          {
            v120.origin.CGFloat x = v5;
            v120.origin.CGFloat y = v6;
            v120.size.CGFloat width = v7;
            v120.size.CGFloat height = v8;
            CGRect v121 = CGRectUnion(v120, *(CGRect *)((char *)this + 48));
            double v5 = v121.origin.x;
            CGFloat v6 = v121.origin.y;
            CGFloat v7 = v121.size.width;
            CGFloat v8 = v121.size.height;
            goto LABEL_89;
          }
          long long v81 = 0u;
          long long v82 = 0u;
          long long v79 = 0u;
          long long v80 = 0u;
          CFArrayRef GlyphRuns = CTLineGetGlyphRuns(*(CTLineRef *)&cf);
          uint64_t v35 = [(__CFArray *)GlyphRuns countByEnumeratingWithState:&v79 objects:v96 count:16];
          if (!v35) {
            goto LABEL_89;
          }
          uint64_t v73 = *(void *)v80;
          do
          {
            uint64_t v36 = 0;
            objCATransform3D a = (id)v35;
            do
            {
              if (*(void *)v80 != v73) {
                objc_enumerationMutation(GlyphRuns);
              }
              uint64_t v75 = v36;
              unint64_t v37 = *(const __CTRun **)(*((void *)&v79 + 1) + 8 * v36);
              CFIndex v38 = CTRunGetGlyphCount(v37);
              if ((unint64_t)(v38 - 65537) <= 0xFFFFFFFFFFFEFFFFLL)
              {
                BOOL v61 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
                uint64_t v62 = objc_msgSend(NSString, "stringWithUTF8String:", "CGRect TSWPLineFragment::glyphRectForLineRange(NSRange, TSWPColumn *, BOOL) const");
                objc_msgSend(v61, "handleFailureInFunction:file:lineNumber:description:", v62, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 701, @"bad glyph count: %ld", v38);
                goto LABEL_89;
              }
              std::vector<long>::vector(&v86, v38);
              v104.NSUInteger location = 0;
              v104.NSUInteger length = v38;
              CTRunGetStringIndices(v37, v104, *(CFIndex **)&v86.a);
              std::vector<unsigned short>::vector(&buffer, v38);
              v105.NSUInteger location = 0;
              v105.NSUInteger length = v38;
              CTRunGetGlyphs(v37, v105, (CGGlyph *)buffer);
              char Status = CTRunGetStatus(v37);
              v106.NSUInteger location = 0;
              v106.NSUInteger length = 1;
              CTRunGetPositions(v37, v106, &v89);
              double v40 = 0.0;
              if ((*((unsigned char *)this + 25) & 0x20) != 0)
              {
                if ((Status & 4) != 0)
                {
                  CFDictionaryRef Attributes = CTRunGetAttributes(v37);
                  Value = (const __CTFont *)CFDictionaryGetValue(Attributes, key);
                  CTFontGetVerticalTranslationsForGlyphs(Value, (const CGGlyph *)buffer, (CGSize *)&r2, 1);
                  v89.CGFloat x = r2.y - v89.y;
                }
                else
                {
                  r2.CGFloat x = 0.0;
                  CGFloat leading = 0.0;
                  CGFloat descent = 0.0;
                  v107.NSUInteger location = 0;
                  v107.NSUInteger length = 0;
                  CTRunGetTypographicBounds(v37, v107, &r2.x, &descent, &leading);
                  double v40 = (r2.x - descent) * 0.5;
                }
              }
              CFIndex v43 = 0;
              double v44 = v76 + v40;
              do
              {
                if (!*((void *)this + 23))
                {
                  BOOL v45 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
                  uint64_t v46 = objc_msgSend(NSString, "stringWithUTF8String:", "CGRect TSWPLineFragment::glyphRectForLineRange(NSRange, TSWPColumn *, BOOL) const");
                  objc_msgSend(v45, "handleFailureInFunction:file:lineNumber:description:", v46, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 738, @"invalid nil value for '%s'", "_textSource");
                }
                if (v31)
                {
                  int v47 = buffer;
LABEL_57:
                  if (*((__int16 *)v47 + v43) == -1) {
                    goto LABEL_67;
                  }
                  if (TSWPLineFragment::GetFakeContext(void)::onceToken != -1) {
                    dispatch_once(&TSWPLineFragment::GetFakeContext(void)::onceToken, &__block_literal_global_67);
                  }
                  v111.NSUInteger location = v43;
                  v111.NSUInteger length = 1;
                  CGRect v116 = CTRunGetImageBounds(v37, (CGContextRef)TSWPLineFragment::GetFakeContext(void)::sFakeContext, v111);
                  v125.size.CGFloat width = v116.size.width;
                  v125.size.CGFloat height = v116.size.height;
                  v125.origin.CGFloat x = v116.origin.x + v89.x + *((double *)this + 6) + v87.b;
                  v125.origin.CGFloat y = v44 - v116.origin.y - v116.size.height + v87.c;
                  v116.origin.CGFloat x = v5;
                  v116.origin.CGFloat y = v6;
                  v116.size.CGFloat width = v7;
                  v116.size.CGFloat height = v8;
                  CGRect v117 = CGRectUnion(v116, v125);
LABEL_61:
                  double v5 = v117.origin.x;
                  CGFloat v6 = v117.origin.y;
                  CGFloat v7 = v117.size.width;
                  CGFloat v8 = v117.size.height;
                  goto LABEL_67;
                }
                unint64_t v48 = [*((id *)this + 23) charIndexMappedToStorage:*(void *)(*(void *)&v86.a + 8 * v43)];
                if (v48 >= location && v48 - location < length)
                {
                  int v47 = buffer;
                  if ((*((unsigned char *)this + 24) & 4) == 0
                    || [*((id *)this + 23) characterAtIndex:*(void *)(*(void *)&v86.a + 8 * v43)] != 65532)
                  {
                    goto LABEL_57;
                  }
                  double v50 = (void *)[*((id *)this + 23) attachmentAtCharIndex:*(void *)(*(void *)&v86.a + 8 * v43)];
                  objc_opt_class();
                  if (objc_opt_isKindOfClass())
                  {
                    uint64_t v51 = *((void *)this + 46);
                    uint64_t v52 = *((void *)this + 47);
                    if (v51 != v52)
                    {
                      while (*(void *)(v51 + 24) != *(void *)(*(void *)&v86.a + 8 * v43))
                      {
                        v51 += 32;
                        if (v51 == v52) {
                          goto LABEL_67;
                        }
                      }
                      double v53 = *(double *)(v51 + 8);
                      double v54 = *(double *)(v51 + 16);
                      uint64_t v55 = [*(id *)v51 size];
                      v127.origin.CGFloat x = TSDRectWithOriginAndSize(v55, v53, v54, v56, v57);
                      v127.origin.CGFloat y = v58;
                      v127.size.CGFloat width = v59;
                      v127.size.CGFloat height = v60;
                      v119.origin.CGFloat x = v5;
                      v119.origin.CGFloat y = v6;
                      v119.size.CGFloat width = v7;
                      v119.size.CGFloat height = v8;
                      CGRect v117 = CGRectUnion(v119, v127);
                      goto LABEL_61;
                    }
                  }
                  else if ([v50 isDrawable] && (objc_msgSend(v50, "isAnchored") & 1) == 0)
                  {
                    CGPoint r2 = (CGPoint)*MEMORY[0x263F001B0];
                    v108.NSUInteger location = v43;
                    v108.NSUInteger length = 1;
                    CTRunGetAdvances(v37, v108, (CGSize *)&r2);
                    v126.size.CGFloat height = *((CGFloat *)this + 15);
                    v126.size.CGFloat width = r2.x;
                    v126.origin.CGFloat x = v89.x + *((double *)this + 6) + v87.b;
                    v126.origin.CGFloat y = v44 - v126.size.height + v87.c;
                    v118.origin.CGFloat x = v5;
                    v118.origin.CGFloat y = v6;
                    v118.size.CGFloat width = v7;
                    v118.size.CGFloat height = v8;
                    CGRect v117 = CGRectUnion(v118, v126);
                    goto LABEL_61;
                  }
                }
LABEL_67:
                ++v43;
              }
              while (v43 != v38);
              if (buffer)
              {
                uint64_t v91 = buffer;
                operator delete(buffer);
              }
              if (*(void *)&v86.a)
              {
                v86.CATransform3D b = v86.a;
                operator delete(*(void **)&v86.a);
              }
              uint64_t v36 = v75 + 1;
            }
            while ((id)(v75 + 1) != obja);
            uint64_t v35 = [(__CFArray *)GlyphRuns countByEnumeratingWithState:&v79 objects:v96 count:16];
          }
          while (v35);
LABEL_89:
          if (cf != 0.0) {
            CFRelease(*(CFTypeRef *)&cf);
          }
        }
        while (v31);
      }
    }
  }
  if (a4)
  {
    v122.origin.CGFloat x = v5;
    v122.origin.CGFloat y = v6;
    v122.size.CGFloat width = v7;
    v122.size.CGFloat height = v8;
    if (!CGRectIsEmpty(v122))
    {
      v123.origin.CGFloat x = v5;
      v123.origin.CGFloat y = v6;
      v123.size.CGFloat width = v7;
      v123.size.CGFloat height = v8;
      *(void *)&double v5 = (unint64_t)CGRectInset(v123, -1.0, -1.0);
    }
  }
  return v5;
}

void sub_22371D53C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,const void *a57)
{
}

void TSWPLineRef::~TSWPLineRef(const void **this)
{
  uint64_t v1 = *this;
  if (v1) {
    CFRelease(v1);
  }
}

double TSWPLineFragment::glyphRectForRubyField(TSWPLineFragment *this, uint64_t a2, _NSRange a3)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  double x = *MEMORY[0x263F001A0];
  CGFloat y = *(double *)(MEMORY[0x263F001A0] + 8);
  CGFloat width = *(double *)(MEMORY[0x263F001A0] + 16);
  CGFloat height = *(double *)(MEMORY[0x263F001A0] + 24);
  uint64_t v8 = *((void *)this + 28);
  uint64_t v7 = *((void *)this + 29);
  if (v8 != v7)
  {
    while (*(void *)(v8 + 24) != a2)
    {
      v8 += 48;
      if (v8 == v7) {
        return x;
      }
    }
    CFArrayRef GlyphRuns = CTLineGetGlyphRuns(*(CTLineRef *)v8);
    long long v25 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    obCFIndex j = GlyphRuns;
    uint64_t v11 = [(__CFArray *)GlyphRuns countByEnumeratingWithState:&v25 objects:v29 count:16];
    if (v11)
    {
      uint64_t v12 = v11;
      unsigned int v13 = 0;
      uint64_t v14 = *(void *)v26;
      do
      {
        for (uint64_t i = 0; i != v12; ++i)
        {
          if (*(void *)v26 != v14) {
            objc_enumerationMutation(obj);
          }
          uint64_t v16 = *(const __CTRun **)(*((void *)&v25 + 1) + 8 * i);
          NSUInteger GlyphCount = CTRunGetGlyphCount(v16);
          unsigned int v18 = v13;
          v32.NSUInteger location = v13;
          v32.NSUInteger length = GlyphCount;
          NSRange v19 = NSIntersectionRange(a3, v32);
          if (v19.length)
          {
            CFIndex v20 = v19.location - v13;
            v31.NSUInteger location = v20;
            v31.NSUInteger length = 1;
            CTRunGetPositions(v16, v31, &buffer);
            if (TSWPLineFragment::GetFakeContext(void)::onceToken != -1) {
              dispatch_once(&TSWPLineFragment::GetFakeContext(void)::onceToken, &__block_literal_global_67);
            }
            v33.NSUInteger location = v20;
            v33.NSUInteger length = v19.length;
            CGRect ImageBounds = CTRunGetImageBounds(v16, (CGContextRef)TSWPLineFragment::GetFakeContext(void)::sFakeContext, v33);
            v36.size.CGFloat width = ImageBounds.size.width;
            v36.size.CGFloat height = ImageBounds.size.height;
            v36.origin.double x = *((double *)this + 6) + ImageBounds.origin.x + *(double *)(v8 + 8) + buffer.x;
            v36.origin.CGFloat y = *(double *)(v8 + 16)
                         + *((double *)this + 4)
                         + *((double *)this + 5)
                         - ImageBounds.origin.y
                         - ImageBounds.size.height;
            ImageBounds.origin.double x = x;
            ImageBounds.origin.CGFloat y = y;
            ImageBounds.size.CGFloat width = width;
            ImageBounds.size.CGFloat height = height;
            CGRect v35 = CGRectUnion(ImageBounds, v36);
            double x = v35.origin.x;
            CGFloat y = v35.origin.y;
            CGFloat width = v35.size.width;
            CGFloat height = v35.size.height;
          }
          unsigned int v13 = GlyphCount + v18;
        }
        uint64_t v12 = [(__CFArray *)obj countByEnumeratingWithState:&v25 objects:v29 count:16];
      }
      while (v12);
    }
  }
  return x;
}

void TSWPLineFragment::emphasisMarkRectForLineRange(TSWPLineFragment *this, _NSRange a2)
{
  uint64_t v2 = *MEMORY[0x263F001A0];
  uint64_t v3 = *(void *)(MEMORY[0x263F001A0] + 8);
  uint64_t v4 = *(void *)(MEMORY[0x263F001A0] + 16);
  uint64_t v5 = *(void *)(MEMORY[0x263F001A0] + 24);
  uint64_t v6 = *((void *)this + 55);
  uint64_t v7 = *((void *)this + 56);
  if (v7 != v6 && *((void *)this + 25) != *((void *)this + 24))
  {
    NSUInteger length = a2.length;
    NSUInteger location = a2.location;
    uint64_t v11 = 0;
    unsigned int v12 = 0;
    do
    {
      if (*(_DWORD *)(v6 + 200 * v11) == 4)
      {
        uint64_t v13 = v6 + 200 * v11;
        uint64_t v14 = *(void *)(v13 + 104);
        if (*(void *)(v13 + 112) != v14)
        {
          unint64_t v15 = 0;
          double v16 = *(double *)(v13 + 176);
          double v17 = *(double *)(v13 + 184);
          unsigned int v18 = 1;
          do
          {
            NSUInteger v19 = *(void *)(*(void *)(v6 + 200 * v11 + 32) + 8 * v15);
            BOOL v21 = v19 >= location;
            NSUInteger v20 = v19 - location;
            BOOL v21 = !v21 || v20 >= length;
            if (!v21)
            {
              uint64_t v22 = v6 + 200 * v11;
              v23.size.CGFloat height = *(CGFloat *)(v22 + 152);
              v23.size.CGFloat width = *(CGFloat *)(v22 + 168);
              v23.origin.double x = *(double *)(v14 + 16 * v15)
                           + v16
                           + *((double *)this + 6)
                           + *(double *)(*((void *)this + 24) + 8);
              v23.origin.CGFloat y = v17 + *((double *)this + 4) + *((double *)this + 5) - v23.size.height;
              *(CGRect *)&uint64_t v2 = CGRectUnion(*(CGRect *)&v2, v23);
              uint64_t v6 = *((void *)this + 55);
            }
            unint64_t v15 = v18;
            uint64_t v14 = *(void *)(v6 + 200 * v11 + 104);
            ++v18;
          }
          while (v15 < (*(void *)(v6 + 200 * v11 + 112) - v14) >> 4);
          uint64_t v7 = *((void *)this + 56);
        }
      }
      uint64_t v11 = ++v12;
    }
    while (0x8F5C28F5C28F5C29 * ((v7 - v6) >> 3) > v12);
  }
}

BOOL TSWPLineFragment::requiresGlyphVectorsForHeightMeasurement(TSWPLineFragment *this)
{
  if ((*((unsigned char *)this + 24) & 0x80) != 0 || *((void *)this + 29) != *((void *)this + 28)) {
    return 1;
  }
  uint64_t v2 = *((void *)this + 55);
  uint64_t v3 = *((void *)this + 56) - v2;
  if (!v3) {
    return 0;
  }
  unint64_t v4 = 0;
  unint64_t v5 = 0x8F5C28F5C28F5C29 * (v3 >> 3);
  unsigned int v6 = 1;
  do
  {
    BOOL v7 = *(_DWORD *)(v2 + 200 * v4) == 4;
    BOOL result = v7;
    unint64_t v4 = v6++;
  }
  while (!v7 && v5 > v4);
  return result;
}

void TSWPLineFragment::labelRect(TSWPLineFragment *this)
{
  uint64_t v1 = *((void *)this + 22);
  if (v1 && (*(_DWORD *)(v1 + 64) - 1) <= 2)
  {
    double v3 = *(double *)v1;
    double v4 = *(double *)(v1 + 8);
    double v6 = -*(double *)(v1 + 56);
    double v7 = *(double *)(v1 + 72);
    if (*(unsigned char *)(v1 + 80)) {
      double v7 = *((double *)this + 8) - v7 - v3;
    }
    double v5 = *((double *)this + 14) + (*((double *)this + 16) + *((double *)this + 17) - v4) * 0.5;
    CGRect v8 = CGRectOffset(*(CGRect *)&v7, 0.0, *((CGFloat *)this + 18));
    CGRect v9 = CGRectOffset(v8, 0.0, v6);
    CGRectOffset(v9, *((CGFloat *)this + 6), *((CGFloat *)this + 7));
  }
}

double TSWPLineFragment::labelTextPosition(TSWPLineFragment *this)
{
  double v1 = *MEMORY[0x263F00148];
  uint64_t v2 = *((void *)this + 22);
  if (!v2) {
    return v1;
  }
  if ((*(_DWORD *)(v2 + 64) & 0xFFFFFFFE) != 2)
  {
    uint64_t v6 = [MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = [NSString stringWithUTF8String:"CGPoint TSWPLineFragment::labelTextPosition() const"];
    uint64_t v8 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"];
    CGRect v9 = @"Text position only applies to text and numbers.";
    CGFloat v10 = (void *)v6;
    uint64_t v11 = v7;
    uint64_t v12 = 992;
    goto LABEL_9;
  }
  TSWPLineFragment::labelRect(this);
  double v1 = v4;
  if ((*((unsigned char *)this + 25) & 0x20) == 0)
  {
    double v5 = (const __CTFont *)TSWPListLabel::labelFont((CTLineRef *)v2);
    if (v5)
    {
      if (*(_DWORD *)(v2 + 64) == 2)
      {
        memset(v16, 0, sizeof(v16));
        TSWPFontHeightInfoForFont(v5, v16);
      }
      return v1;
    }
    if (!CTLineGetGlyphCount(*(CTLineRef *)(v2 + 16))) {
      return v1;
    }
    uint64_t v13 = [MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v14 = [NSString stringWithUTF8String:"CGPoint TSWPLineFragment::labelTextPosition() const"];
    uint64_t v8 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"];
    CGRect v9 = @"No label font but we need to render something";
    CGFloat v10 = (void *)v13;
    uint64_t v11 = v14;
    uint64_t v12 = 968;
LABEL_9:
    [v10 handleFailureInFunction:v11 file:v8 lineNumber:v12 description:v9];
    return v1;
  }
  if (*(unsigned char *)(v2 + 81))
  {
    *(void *)&v16[0] = 0;
    CTLineGetTypographicBounds(*(CTLineRef *)(v2 + 16), (CGFloat *)v16, 0, 0);
    return v1 + *(double *)v16;
  }
  return v1;
}

uint64_t TSWPLineFragment::leftMostCharIndex(TSWPLineFragment *this)
{
  CharIndexDatCATransform3D a = (TSWPLineFragment **)TSWPLineFragment::getCharIndexData(this);
  double v3 = *CharIndexData;
  if (*CharIndexData == CharIndexData[1]) {
    double v3 = this;
  }
  return *(void *)v3;
}

uint64_t TSWPLineFragment::rightMostCharIndex(TSWPLineFragment *this)
{
  CharIndexDatCATransform3D a = (void *)TSWPLineFragment::getCharIndexData(this);
  uint64_t v3 = CharIndexData[1];
  if (*CharIndexData == v3) {
    double v4 = this;
  }
  else {
    double v4 = (TSWPLineFragment *)(v3 - 64);
  }
  return *(void *)v4;
}

double TSWPLineFragment::wpOffsetForCharIndexForVisualSelection(TSWPLineFragment *this, unint64_t a2, int a3)
{
  int v4 = *((_DWORD *)this + 6);
  double v5 = (CTLineRef *)*((void *)this + 24);
  if (*((CTLineRef **)this + 25) != v5 && CTLineGetGlyphCount(*v5))
  {
    if (*((void *)this + 1) + *(void *)this <= a2)
    {
      uint64_t v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "CGFloat TSWPLineFragment::wpOffsetForCharIndexForVisualSelection(TSWPCharIndex, BOOL) const");
      objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 1206, @"Bad char index");
    }
    uint64_t v11 = *((void *)this + 24);
    uint64_t v10 = *((void *)this + 25);
    if (v10 == v11)
    {
      uint64_t v12 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v13 = objc_msgSend(NSString, "stringWithUTF8String:", "CGFloat TSWPLineFragment::wpOffsetForCharIndexForVisualSelection(TSWPCharIndex, BOOL) const");
      objc_msgSend(v12, "handleFailureInFunction:file:lineNumber:description:", v13, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 1207, @"Expected Line Refs");
      uint64_t v11 = *((void *)this + 24);
      uint64_t v10 = *((void *)this + 25);
    }
    double v14 = 0.0;
    if (v10 == v11) {
      goto LABEL_51;
    }
    CharIndexDatCATransform3D a = (uint64_t *)TSWPLineFragment::getCharIndexData(this);
    uint64_t v16 = *CharIndexData;
    uint64_t v17 = CharIndexData[1];
    if (*CharIndexData == v17)
    {
      if (a3)
      {
        double v14 = *(double *)(v11 + 8);
      }
      else
      {
        uint64_t v36 = objc_msgSend(*((id *)this + 23), "characterAtIndex:", objc_msgSend(*((id *)this + 23), "charIndexMappedFromStorage:", a2));
        unsigned int v37 = v36;
        int v38 = IsParagraphBreakingCharacter(v36);
        if (v37 == 8232 || v38)
        {
          if (v37 > 0xC || ((1 << v37) & 0x1030) == 0)
          {
            double v39 = 7.0;
            if ((v4 & 0x1000) != 0) {
              double v39 = -7.0;
            }
            double v14 = v39 + *(double *)(v11 + 8);
            goto LABEL_51;
          }
LABEL_46:
          if ((v4 & 0x1000) == 0) {
            double v14 = *((double *)this + 8);
          }
        }
      }
    }
    else
    {
      unint64_t v18 = (v17 - v16) >> 6;
      if (v18 <= 1) {
        unint64_t v18 = 1;
      }
      NSUInteger v19 = (double *)(v16 + 32);
      while (1)
      {
        unint64_t v20 = *((void *)v19 - 4);
        BOOL v22 = a2 >= v20;
        unint64_t v21 = a2 - v20;
        BOOL v22 = !v22 || v21 >= *((void *)v19 - 3);
        if (!v22) {
          break;
        }
        v19 += 8;
        if (!--v18) {
          goto LABEL_51;
        }
      }
      double v25 = *v19;
      double v24 = v19[1];
      double v26 = v24 - *v19;
      int v27 = a3 ^ ((unsigned __int16)(v4 & 0x1000) >> 12);
      if (v27) {
        double v28 = v26;
      }
      else {
        double v28 = -v26;
      }
      if (v27) {
        double v24 = v25;
      }
      double v29 = v24 + *(double *)(v11 + 8);
      if ((a3 & 1) == 0)
      {
        uint64_t v30 = objc_msgSend(*((id *)this + 23), "characterAtIndex:", objc_msgSend(*((id *)this + 23), "charIndexMappedFromStorage:", a2));
        unsigned int v31 = v30;
        int v32 = IsParagraphBreakingCharacter(v30);
        if (v31 == 8232 || v32 != 0)
        {
          if (v31 > 0xC || ((1 << v31) & 0x1030) == 0)
          {
            double v35 = 7.0;
            if ((v4 & 0x1000) != 0) {
              double v35 = -7.0;
            }
            double v14 = v29 + v35 + v28;
            goto LABEL_51;
          }
          goto LABEL_46;
        }
      }
      double v14 = v29;
    }
LABEL_51:
    CGRect v23 = (double *)((char *)this + 48);
    return v14 + *v23;
  }
  double v14 = *((double *)this + 6);
  if ((v4 & 0x1000) != 0)
  {
    CGRect v23 = (double *)((char *)this + 64);
    return v14 + *v23;
  }
  return v14;
}

double TSWPLineFragment::wpOffsetForGlyphIndex(TSWPLineFragment *this, unint64_t a2, int a3)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  int v4 = *((_DWORD *)this + 6);
  double v5 = (CTLineRef *)*((void *)this + 24);
  if (*((CTLineRef **)this + 25) != v5 && CTLineGetGlyphCount(*v5))
  {
    uint64_t v8 = (CTLineRef *)*((void *)this + 24);
    if (*((CTLineRef **)this + 25) == v8 || CTLineGetGlyphCount(*v8) <= a2)
    {
      uint64_t v9 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v10 = objc_msgSend(NSString, "stringWithUTF8String:", "CGFloat TSWPLineFragment::wpOffsetForGlyphIndex(NSUInteger, BOOL) const");
      objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 1308, @"Bad glyph index");
    }
    uint64_t v11 = *((void *)this + 24);
    double v12 = 0.0;
    if (*((void *)this + 25) != v11)
    {
      long long v39 = 0u;
      long long v40 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      CFArrayRef GlyphRuns = CTLineGetGlyphRuns(*(CTLineRef *)v11);
      uint64_t v14 = [(__CFArray *)GlyphRuns countByEnumeratingWithState:&v37 objects:v41 count:16];
      if (v14)
      {
        uint64_t v15 = v14;
        int v33 = a3;
        __int16 v34 = v4;
        CFIndex v16 = 0;
        uint64_t v17 = *(void *)v38;
        while (2)
        {
          uint64_t v18 = 0;
          CFIndex v19 = v16;
          do
          {
            if (*(void *)v38 != v17) {
              objc_enumerationMutation(GlyphRuns);
            }
            unint64_t v20 = *(const __CTRun **)(*((void *)&v37 + 1) + 8 * v18);
            CFIndex GlyphCount = CTRunGetGlyphCount(v20);
            CFIndex v22 = GlyphCount;
            if ((unint64_t)(GlyphCount - 65537) <= 0xFFFFFFFFFFFEFFFFLL)
            {
              double v24 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
              uint64_t v25 = objc_msgSend(NSString, "stringWithUTF8String:", "CGFloat TSWPLineFragment::wpOffsetForGlyphIndex(NSUInteger, BOOL) const");
              objc_msgSend(v24, "handleFailureInFunction:file:lineNumber:description:", v25, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 1321, @"bad glyph count: %ld", v22);
              goto LABEL_33;
            }
            CFIndex v16 = GlyphCount + v19;
            if (GlyphCount + v19 > a2)
            {
              CFIndex v26 = a2 - v19;
              v43.NSUInteger location = v26;
              v43.NSUInteger length = 1;
              double TypographicBounds = CTRunGetTypographicBounds(v20, v43, 0, 0, 0);
              v44.NSUInteger location = v26;
              v44.NSUInteger length = 1;
              CTRunGetPositions(v20, v44, &buffer);
              if (v33 == (unsigned __int16)(v34 & 0x1000) >> 12)
              {
                double v12 = TypographicBounds + buffer.x + *(double *)(v11 + 8);
                double TypographicBounds = -TypographicBounds;
              }
              else
              {
                double v12 = buffer.x + *(double *)(v11 + 8);
              }
              if ((v33 & 1) == 0)
              {
                CFIndex v35 = 0;
                v45.NSUInteger location = v26;
                v45.NSUInteger length = 1;
                CTRunGetStringIndices(v20, v45, &v35);
                uint64_t v28 = [*((id *)this + 23) characterAtIndex:v35];
                unsigned int v29 = v28;
                int v30 = IsParagraphBreakingCharacter(v28);
                if (v29 == 8232 || v30)
                {
                  if (v29 <= 0xC && ((1 << v29) & 0x1030) != 0)
                  {
                    double v12 = 0.0;
                    if ((v34 & 0x1000) == 0) {
                      double v12 = *((double *)this + 8);
                    }
                  }
                  else
                  {
                    double v31 = 7.0;
                    if ((v34 & 0x1000) != 0) {
                      double v31 = -7.0;
                    }
                    double v12 = v12 + v31 + TypographicBounds;
                  }
                }
              }
              goto LABEL_33;
            }
            ++v18;
            v19 += GlyphCount;
          }
          while (v15 != v18);
          uint64_t v15 = [(__CFArray *)GlyphRuns countByEnumeratingWithState:&v37 objects:v41 count:16];
          if (v15) {
            continue;
          }
          break;
        }
      }
    }
LABEL_33:
    CGRect v23 = (double *)((char *)this + 48);
    return v12 + *v23;
  }
  double v12 = *((double *)this + 6);
  if ((v4 & 0x1000) != 0)
  {
    CGRect v23 = (double *)((char *)this + 64);
    return v12 + *v23;
  }
  return v12;
}

double TSWPLineFragment::wpOffsetForCharIndex(TSWPLineFragment *this, unint64_t a2, int a3)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  double v39 = 0.0;
  double v6 = TSWPLineFragment::wpOffsetForCharIndex(this, a2, 0, 0, &v39);
  uint64_t v7 = (void *)*((void *)this + 23);
  if (!v7)
  {
    if (*((unsigned char *)this + 24))
    {
      uint64_t v7 = 0;
    }
    else
    {
      uint64_t v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "CGFloat TSWPLineFragment::wpOffsetForCharIndex(TSWPCharIndex, BOOL) const");
      objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 1383, @"Unexpected nil _textSource");
      uint64_t v7 = (void *)*((void *)this + 23);
    }
  }
  uint64_t v10 = [v7 charIndexMappedFromStorage:a2];
  uint64_t v11 = (CTLineRef *)*((void *)this + 24);
  if (*((CTLineRef **)this + 25) != v11)
  {
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    CFArrayRef GlyphRuns = CTLineGetGlyphRuns(*v11);
    uint64_t v13 = [(__CFArray *)GlyphRuns countByEnumeratingWithState:&v35 objects:v40 count:16];
    if (v13)
    {
      unint64_t v14 = v10 - ((v10 != 0) & ~a3);
      uint64_t v15 = *(void *)v36;
      while (2)
      {
        for (uint64_t i = 0; i != v13; ++i)
        {
          if (*(void *)v36 != v15) {
            objc_enumerationMutation(GlyphRuns);
          }
          uint64_t v17 = *(const __CTRun **)(*((void *)&v35 + 1) + 8 * i);
          CFIndex GlyphCount = CTRunGetGlyphCount(v17);
          if ((unint64_t)(GlyphCount - 65537) < 0xFFFFFFFFFFFF0000)
          {
            double v31 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v32 = objc_msgSend(NSString, "stringWithUTF8String:", "CGFloat TSWPLineFragment::wpOffsetForCharIndex(TSWPCharIndex, BOOL) const");
            objc_msgSend(v31, "handleFailureInFunction:file:lineNumber:description:", v32, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 1403, @"bad glyph count: %ld", GlyphCount);
            return v6;
          }
          std::vector<long>::vector(buffer, GlyphCount);
          v42.NSUInteger location = 0;
          v42.NSUInteger length = GlyphCount;
          CTRunGetStringIndices(v17, v42, buffer[0]);
          CFIndex v19 = 0;
          int v20 = 0;
          int v21 = 0;
          int v22 = 0;
          do
          {
            unint64_t v23 = buffer[0][v19];
            BOOL v24 = v23 == v14;
            BOOL v25 = v23 > v14;
            BOOL v26 = v23 == v14;
            int v27 = !v25;
            int v28 = v25;
            int v29 = v28 | v21;
            int v30 = v27 | v20;
            v22 |= v26;
            if (!v24)
            {
              int v21 = v29;
              int v20 = v30;
            }
            ++v19;
          }
          while (v19 < GlyphCount && (v22 & (v21 | v20) & 1) == 0);
          if (((v22 | v21 & v20) & 1) != 0
            && ((CTRunGetStatus(v17) & 1) == 0) == (*((unsigned char *)this + 25) & 0x10) >> 4)
          {
            double v6 = v39;
          }
          if (buffer[0])
          {
            buffer[1] = buffer[0];
            operator delete(buffer[0]);
          }
        }
        uint64_t v13 = [(__CFArray *)GlyphRuns countByEnumeratingWithState:&v35 objects:v40 count:16];
        if (v13) {
          continue;
        }
        break;
      }
    }
  }
  return v6;
}

void sub_22371E678(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const void *TSWPLineFragment::fontAtCharIndex(TSWPLineFragment *this, unint64_t a2, BOOL *a3)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  uint64_t v7 = *((void *)this + 24);
  uint64_t v6 = *((void *)this + 25);
  if (v6 == v7)
  {
    uint64_t v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "CTFontRef TSWPLineFragment::fontAtCharIndex(TSWPCharIndex, BOOL &) const");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 1442, @"No line refs");
    uint64_t v7 = *((void *)this + 24);
    uint64_t v6 = *((void *)this + 25);
  }
  if (v6 == v7) {
    return 0;
  }
  unint64_t v10 = *(void *)this;
  if (*(void *)this <= a2) {
    unint64_t v10 = a2;
  }
  uint64_t v11 = *((void *)this + 1) + *(void *)this >= v10 ? v10 : *((void *)this + 1) + *(void *)this;
  unint64_t v12 = [*((id *)this + 23) charIndexMappedFromStorage:v11];
  *a3 = 0;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  CFArrayRef GlyphRuns = CTLineGetGlyphRuns(**((CTLineRef **)this + 24));
  uint64_t v14 = [(__CFArray *)GlyphRuns countByEnumeratingWithState:&v25 objects:v29 count:16];
  if (!v14) {
    return 0;
  }
  uint64_t v15 = v14;
  uint64_t v16 = *(void *)v26;
  while (2)
  {
    for (uint64_t i = 0; i != v15; ++i)
    {
      if (*(void *)v26 != v16) {
        objc_enumerationMutation(GlyphRuns);
      }
      uint64_t v18 = *(const __CTRun **)(*((void *)&v25 + 1) + 8 * i);
      CFRange StringRange = CTRunGetStringRange(v18);
      if (v12 >= StringRange.location && v12 - StringRange.location < StringRange.length)
      {
        CFDictionaryRef Attributes = CTRunGetAttributes(v18);
        Value = CFDictionaryGetValue(Attributes, @"TSWPUnadjustedFont");
        int v21 = Value;
        if (!Value) {
          int v21 = CFDictionaryGetValue(Attributes, (const void *)*MEMORY[0x263F039A0]);
        }
        *a3 = (CTRunGetStatus(v18) & 4) != 0;
        return v21;
      }
    }
    uint64_t v15 = [(__CFArray *)GlyphRuns countByEnumeratingWithState:&v25 objects:v29 count:16];
    int v21 = 0;
    if (v15) {
      continue;
    }
    break;
  }
  return v21;
}

void TSWPLineFragment::wpOffsetForInsertionPoint(TSWPLineFragment *this, unint64_t a2, BOOL a3, int a4, char a5)
{
  BOOL v22 = a3;
  uint64_t v7 = TSWPLineFragment::glyphIndexForInsertionPoint(this, a2, &v22, a4);
  uint64_t v8 = *((void *)this + 24);
  if (*((void *)this + 25) == v8)
  {
    double v16 = 0.0;
    if (a5) {
      return;
    }
    goto LABEL_9;
  }
  unint64_t v9 = v7;
  CharIndexDatCATransform3D a = (uint64_t *)TSWPLineFragment::getCharIndexData(this);
  uint64_t v12 = *CharIndexData;
  uint64_t v11 = CharIndexData[1];
  if (v11 == *CharIndexData)
  {
    double v18 = *(double *)(v8 + 8);
    int v19 = *((_DWORD *)this + 6);
    if ((v19 & 0x800) != 0)
    {
      double v20 = -7.0;
      if ((v19 & 0x1000) == 0) {
        double v20 = 7.0;
      }
      double v21 = v18 + v20;
      if (!v22) {
        double v18 = v21;
      }
    }
  }
  else
  {
    unint64_t v13 = (v11 - *CharIndexData) >> 6;
    if (v9 < v13 && *(unsigned char *)(v12 + (v9 << 6) + 48) != v22) {
      ++v9;
    }
    if (v9 == v13)
    {
      double v14 = *(double *)(v8 + 8);
      double v15 = *(double *)(v11 - 24);
    }
    else
    {
      double v14 = *(double *)(v12 + (v9 << 6) + 32);
      double v15 = *(double *)(v8 + 8);
    }
    double v18 = v14 + v15;
  }
  double v16 = v18 + *((double *)this + 6);
  if ((a5 & 1) == 0)
  {
LABEL_9:
    double v17 = fmin(v16, CGRectGetMaxX(*(CGRect *)((char *)this + 48)) + -1.0);
    fmax(v17, CGRectGetMinX(*(CGRect *)((char *)this + 48)));
  }
}

uint64_t TSWPLineFragment::glyphIndexForInsertionPoint(TSWPLineFragment *this, unint64_t a2, BOOL *a3, int a4)
{
  if ([*((id *)this + 23) length])
  {
    unsigned int v8 = *((_DWORD *)this + 6) & 0x1000;
    unint64_t v9 = [*((id *)this + 23) charIndexRemappedFromStorage:*(void *)this];
    unint64_t v10 = v9;
    int v11 = 0;
    uint64_t v12 = *((void *)this + 1);
    if ((a4 & 1) == 0 && v9 < a2)
    {
      uint64_t v13 = TSWPPreviousCharFromTextSource(a2, *((void **)this + 23));
      int v11 = TSWPLineFragment::writingDirectionForCharIndex(this, v13) != 0;
    }
    uint64_t v14 = v12 + v10;
    BOOL v15 = *a3;
    if (v12 + v10 == a2 && v15)
    {
      if (!a4)
      {
        uint64_t v25 = TSWPPreviousCharFromTextSource(a2, *((void **)this + 23));
        int v28 = TSWPLineFragment::writingDirectionForCharIndex(this, v25);
        if (v28 != v8 >> 12 && v28 == v11)
        {
          char v26 = 0;
LABEL_38:
          *a3 = v26;
          a2 = v25;
          goto LABEL_39;
        }
      }
LABEL_22:
      CharIndexDatCATransform3D a = TSWPLineFragment::getCharIndexData(this);
      double v21 = *(uint64_t **)CharIndexData;
      BOOL v22 = *(uint64_t **)(CharIndexData + 8);
      if (!v8) {
        goto LABEL_23;
      }
      goto LABEL_28;
    }
    if (v10 > a2 && !v15)
    {
      uint64_t v27 = TSWPLineFragment::getCharIndexData(this);
      double v21 = *(uint64_t **)v27;
      BOOL v22 = *(uint64_t **)(v27 + 8);
      if (v8)
      {
        if (v21 == v22) {
          int v29 = (uint64_t *)this;
        }
        else {
          int v29 = v22 - 8;
        }
        uint64_t v25 = *v29;
        char v26 = TSWPLineFragment::writingDirectionForCharIndex(this, *v29) != 0;
        goto LABEL_38;
      }
      goto LABEL_28;
    }
    if (a4) {
      goto LABEL_39;
    }
    int v18 = TSWPLineFragment::writingDirectionForCharIndex(this, a2);
    int v19 = v18;
    if (v10 == a2 && *a3)
    {
      if (v18 != v8 >> 12 && v18 != v11)
      {
        uint64_t v20 = TSWPLineFragment::getCharIndexData(this);
        double v21 = *(uint64_t **)v20;
        BOOL v22 = *(uint64_t **)(v20 + 8);
        if (v8)
        {
LABEL_23:
          if (v21 == v22) {
            BOOL v24 = (uint64_t *)this;
          }
          else {
            BOOL v24 = v22 - 8;
          }
          uint64_t v25 = *v24;
          char v26 = TSWPLineFragment::writingDirectionForCharIndex(this, *v24);
          goto LABEL_38;
        }
LABEL_28:
        if (v21 == v22) {
          double v21 = (uint64_t *)this;
        }
        uint64_t v25 = *v21;
        char v26 = TSWPLineFragment::writingDirectionForCharIndex(this, *v21) == 0;
        goto LABEL_38;
      }
    }
    else
    {
      if (v14 - 1 != a2 || *a3)
      {
        double v31 = (void *)*((void *)this + 23);
        if (*a3) {
          uint64_t v32 = TSWPPreviousCharFromTextSource(a2, v31);
        }
        else {
          uint64_t v32 = TSWPNextCharFromTextSource(a2, v31);
        }
        uint64_t v25 = v32;
        if (v19 == TSWPLineFragment::writingDirectionForCharIndex(this, v32) || v19 == v11) {
          goto LABEL_39;
        }
        char v26 = !*a3;
        goto LABEL_38;
      }
      if (v18 != v8 >> 12 && v18 != v11) {
        goto LABEL_22;
      }
    }
  }
LABEL_39:

  return TSWPLineFragment::visualIndexForCharIndex(this, a2);
}

uint64_t TSWPLineFragment::writingDirectionForCharIndex(TSWPLineFragment *this, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  unsigned int v2 = *((_DWORD *)this + 6);
  if (v2) {
    return 0;
  }
  uint64_t v5 = *((void *)this + 1) + *(void *)this;
  if (v5 == a2 || (v2 & 0x800) != 0 && v5 - 1 == a2) {
    return (v2 >> 12) & 1;
  }
  uint64_t v7 = (void *)*((void *)this + 23);
  if (!v7)
  {
    unsigned int v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v9 = [NSString stringWithUTF8String:"TSWPWritingDirection TSWPLineFragment::writingDirectionForCharIndex(TSWPCharIndex) const"];
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 2462, @"invalid nil value for '%s'", "_textSource");
    uint64_t v7 = (void *)*((void *)this + 23);
  }
  uint64_t v10 = [v7 charIndexMappedFromStorage:a2];
  unint64_t v11 = v10;
  uint64_t v12 = (CTLineRef *)*((void *)this + 24);
  uint64_t v13 = (CTLineRef *)*((void *)this + 25);
  if (v13 == v12 && v10 == 0x7FFFFFFFFFFFFFFFLL)
  {
    uint64_t v14 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v15 = [NSString stringWithUTF8String:"TSWPWritingDirection TSWPLineFragment::writingDirectionForCharIndex(TSWPCharIndex) const"];
    objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", v15, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 2466, @"bad character index: %d", a2);
    return 0;
  }
  uint64_t result = 0;
  if (v13 != v12 && v11 != 0x7FFFFFFFFFFFFFFFLL)
  {
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    CFArrayRef GlyphRuns = CTLineGetGlyphRuns(*v12);
    uint64_t result = [(__CFArray *)GlyphRuns countByEnumeratingWithState:&v23 objects:v27 count:16];
    if (result)
    {
      uint64_t v17 = result;
      uint64_t v18 = *(void *)v24;
      do
      {
        for (uint64_t i = 0; i != v17; ++i)
        {
          if (*(void *)v24 != v18) {
            objc_enumerationMutation(GlyphRuns);
          }
          uint64_t v20 = *(const __CTRun **)(*((void *)&v23 + 1) + 8 * i);
          CFRange StringRange = CTRunGetStringRange(v20);
          if (v11 >= StringRange.location && v11 - StringRange.location < StringRange.length) {
            return CTRunGetStatus(v20) & 1;
          }
        }
        uint64_t v17 = [(__CFArray *)GlyphRuns countByEnumeratingWithState:&v23 objects:v27 count:16];
        uint64_t result = 0;
      }
      while (v17);
    }
  }
  return result;
}

uint64_t TSWPLineFragment::visualIndexForCharIndex(TSWPLineFragment *this, unint64_t a2)
{
  CharIndexDatCATransform3D a = (uint64_t *)TSWPLineFragment::getCharIndexData(this);
  uint64_t v5 = CharIndexData;
  if ((*((unsigned char *)this + 25) & 0x10) != 0)
  {
    uint64_t result = 0;
    uint64_t v6 = *v5;
    uint64_t v7 = v5[1];
  }
  else
  {
    uint64_t v6 = *CharIndexData;
    uint64_t v7 = CharIndexData[1];
    if (*CharIndexData == v7) {
      return 0;
    }
    uint64_t result = ((v7 - v6) >> 6) - 1;
  }
  uint64_t v9 = v7 - v6;
  if (v9)
  {
    uint64_t v10 = 0;
    unint64_t v11 = v9 >> 6;
    if (v11 <= 1) {
      unint64_t v11 = 1;
    }
    for (uint64_t i = (unint64_t *)(v6 + 8); ; i += 8)
    {
      unint64_t v13 = *(i - 1);
      BOOL v15 = a2 >= v13;
      unint64_t v14 = a2 - v13;
      BOOL v15 = !v15 || v14 >= *i;
      if (!v15) {
        break;
      }
      if (v11 == ++v10) {
        return result;
      }
    }
    return v10;
  }
  return result;
}

unint64_t TSWPLineFragment::charIndexForWPOffsetWithDirection(TSWPLineFragment *this, int a2, int a3, double a4)
{
  uint64_t v6 = *((void *)this + 24);
  if (*((void *)this + 25) == v6) {
    goto LABEL_42;
  }
  double v7 = *((double *)this + 6);
  double v8 = a4 - v7;
  double v9 = v8 - *(double *)(v6 + 8);
  if (v9 <= *((double *)this + 10) - v7 + 1.0)
  {
    unint64_t v11 = *(void *)this;
    if ((*((unsigned char *)this + 25) & 0x10) != 0) {
      unint64_t v11 = v11 + *((void *)this + 1) - 1;
    }
    goto LABEL_43;
  }
  if (v9 >= 0.0)
  {
    if (v8 >= *((double *)this + 27) && (a3 & 1) != 0) {
      goto LABEL_42;
    }
  }
  else if (a3)
  {
    unint64_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    goto LABEL_47;
  }
  CharIndexDatCATransform3D a = (double **)TSWPLineFragment::getCharIndexData(this);
  unint64_t v13 = *CharIndexData;
  uint64_t v14 = (char *)CharIndexData[1] - (char *)*CharIndexData;
  if (v14)
  {
    double v15 = v13[4];
    double v16 = v13[5];
    double v17 = v15 + (v16 - v15) * 0.5;
    BOOL v18 = v9 > v17;
    if (a2 || (v9 <= v17 ? (BOOL v19 = v9 < v15) : (BOOL v19 = 1), v19))
    {
      uint64_t v21 = 0;
      unint64_t v22 = v14 >> 6;
      long long v23 = v13 + 13;
      double v24 = 0.0;
      while (1)
      {
        uint64_t v20 = v21;
        double v25 = v17;
        if (!a2 && v9 >= v17 && v9 <= v16) {
          break;
        }
        BOOL v27 = a2 != 1 || v18 || v9 < v24;
        BOOL v28 = v9 > v15 || a2 != 1;
        if (!v27) {
          break;
        }
        if (!v28 || v21 + 1 >= v22) {
          break;
        }
        double v15 = *(v23 - 1);
        double v16 = *v23;
        double v17 = v15 + (*v23 - v15) * 0.5;
        BOOL v18 = v9 > v17;
        v23 += 8;
        ++v21;
        double v24 = v25;
        if (!a2)
        {
          BOOL v30 = v9 > v17 || v9 < v15;
          double v24 = v25;
          if (!v30) {
            break;
          }
        }
      }
    }
    else
    {
      uint64_t v20 = -1;
    }
    if (v9 < 0.0 && a3 == 0)
    {
      uint64_t v20 = 0;
    }
    else if (v20 == -1)
    {
      goto LABEL_42;
    }
    unint64_t v11 = *(void *)&v13[8 * v20];
    if ((*((unsigned char *)this + 25) & 0x40) != 0) {
      unint64_t v11 = *(void *)this + v11 - *((void *)this + 2);
    }
    goto LABEL_43;
  }
LABEL_42:
  unint64_t v11 = 0x7FFFFFFFFFFFFFFFLL;
LABEL_43:
  if ((a3 & 1) == 0 && v11 == 0x7FFFFFFFFFFFFFFFLL)
  {
    unint64_t v11 = *(void *)this;
    if ((*((unsigned char *)this + 25) & 0x10) != 0) {
      v11 += *((void *)this + 1);
    }
  }
LABEL_47:
  if ((v11 != 0x7FFFFFFFFFFFFFFFLL || (a3 & 1) == 0)
    && (v11 < *(void *)this || v11 > *((void *)this + 1) + *(void *)this))
  {
    uint64_t v32 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v33 = objc_msgSend(NSString, "stringWithUTF8String:", "TSWPCharIndex TSWPLineFragment::charIndexForWPOffsetWithDirection(CGFloat, TSWPWritingDirection, BOOL) const");
    objc_msgSend(v32, "handleFailureInFunction:file:lineNumber:description:", v33, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 1763, @"TSWPLineFragment::charIndexForWPOffset: out-of-bounds result");
  }
  return v11;
}

unint64_t TSWPLineFragment::charIndexForWPOffset(TSWPLineFragment *this, double a2, int a3, char a4, BOOL *a5, char a6)
{
  uint64_t v9 = *((void *)this + 24);
  if (*((void *)this + 25) != v9)
  {
    double v11 = a2 - *((double *)this + 6);
    double v12 = v11 - *(double *)(v9 + 8);
    if (v12 < 0.0 || v11 >= *((double *)this + 27)) && (a4) {
      goto LABEL_5;
    }
    if (a3 && (a6 & 1) == 0)
    {
      v35.CGFloat y = 0.0;
      v35.double x = v11 - *(double *)(v9 + 8);
      CFIndex StringIndexForPosition = CTLineGetStringIndexForPosition(*(CTLineRef *)v9, v35);
      if ((StringIndexForPosition & 0x8000000000000000) == 0)
      {
        unint64_t v22 = StringIndexForPosition;
        unint64_t v23 = objc_msgSend(*((id *)this + 23), "charRangeMappedFromStorage:", *(void *)this, *((void *)this + 1));
        BOOL v25 = v22 < v23 || v22 - v23 >= v24;
        if (!v25 || v23 + v24 == v22)
        {
          unint64_t v13 = [*((id *)this + 23) charIndexMappedToStorage:v22];
          goto LABEL_6;
        }
      }
LABEL_5:
      unint64_t v13 = 0x7FFFFFFFFFFFFFFFLL;
LABEL_6:
      char v14 = 1;
      goto LABEL_7;
    }
    CharIndexDatCATransform3D a = (uint64_t *)TSWPLineFragment::getCharIndexData(this);
    uint64_t v27 = *CharIndexData;
    uint64_t v28 = CharIndexData[1] - *CharIndexData;
    if (!v28) {
      goto LABEL_5;
    }
    unint64_t v29 = v28 >> 6;
    if (v29 <= 1) {
      unint64_t v29 = 1;
    }
    double v30 = *(double *)(v27 + 32);
    if (v30 <= v12)
    {
      uint64_t v32 = 0;
      uint64_t v33 = v29 - 1;
      uint64_t v34 = v27 + 40;
      while (1)
      {
        uint64_t v31 = v32;
        if (v30 + *(double *)v34) * 0.5 > v12 && (a3)
        {
          char v14 = *(unsigned char *)(v34 + 8);
          goto LABEL_53;
        }
        if (v33 == v32) {
          break;
        }
        double v30 = *(double *)(v34 + 56);
        v34 += 64;
        ++v32;
        if (v30 > v12)
        {
          char v14 = *(unsigned char *)(v34 - 56) ^ 1;
          if (!a3) {
            char v14 = 1;
          }
          goto LABEL_47;
        }
      }
      char v14 = *(unsigned char *)(v34 + 8) ^ 1;
      if (!a3) {
        char v14 = 1;
      }
      uint64_t v31 = v33;
    }
    else
    {
      char v14 = 1;
      uint64_t v31 = -1;
LABEL_47:
      if (v31 == -1)
      {
        unint64_t v13 = 0x7FFFFFFFFFFFFFFFLL;
        goto LABEL_7;
      }
    }
LABEL_53:
    unint64_t v13 = *(void *)(v27 + (v31 << 6));
    if ((*((unsigned char *)this + 25) & 0x40) != 0) {
      unint64_t v13 = *(void *)this + v13 - *((void *)this + 2);
    }
LABEL_7:
    BOOL v15 = v14 != 0;
    if (a4) {
      goto LABEL_14;
    }
    goto LABEL_10;
  }
  unint64_t v13 = 0x7FFFFFFFFFFFFFFFLL;
  BOOL v15 = 1;
  if (a4) {
    goto LABEL_14;
  }
LABEL_10:
  if (v13 == 0x7FFFFFFFFFFFFFFFLL)
  {
    uint64_t v16 = TSWPLineFragment::getCharIndexData(this);
    double v17 = *(uint64_t **)v16;
    if (*(void *)v16 == *(void *)(v16 + 8)) {
      double v17 = (uint64_t *)this;
    }
    unint64_t v13 = *v17;
    BOOL v15 = TSWPLineFragment::writingDirectionForCharIndex(this, *v17) == 0;
  }
LABEL_14:
  if ((v13 != 0x7FFFFFFFFFFFFFFFLL || (a4 & 1) == 0)
    && (v13 < *(void *)this || v13 > *((void *)this + 1) + *(void *)this))
  {
    BOOL v18 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v19 = objc_msgSend(NSString, "stringWithUTF8String:", "TSWPCharIndex TSWPLineFragment::charIndexForWPOffset(CGFloat, BOOL, BOOL, BOOL *, BOOL) const");
    [v18 handleFailureInFunction:v19, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 1855, @"TSWPLineFragment::charIndexForWPOffset: out-of-bounds result: %lu {%lu, %lu}", v13, *(void *)this, *((void *)this + 1) file lineNumber description];
  }
  if (a5)
  {
    *a5 = v15;
  }
  else if (v13 == 0x7FFFFFFFFFFFFFFFLL)
  {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  else
  {
    v13 += !v15;
  }
  return v13;
}

double TSWPLineFragment::getLocalRunOffsetForCharIndex(TSWPLineFragment *this, unint64_t a2, double *a3)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  *a3 = 0.0;
  uint64_t v3 = (CTLineRef *)*((void *)this + 24);
  double v4 = 0.0;
  if (*((CTLineRef **)this + 25) != v3 && (*((unsigned char *)this + 25) & 0x40) == 0)
  {
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    CFArrayRef GlyphRuns = CTLineGetGlyphRuns(*v3);
    uint64_t v8 = [(__CFArray *)GlyphRuns countByEnumeratingWithState:&v27 objects:v31 count:16];
    if (v8)
    {
      uint64_t v9 = *(void *)v28;
      while (2)
      {
        for (uint64_t i = 0; i != v8; ++i)
        {
          if (*(void *)v28 != v9) {
            objc_enumerationMutation(GlyphRuns);
          }
          double v11 = *(const __CTRun **)(*((void *)&v27 + 1) + 8 * i);
          CFRange StringRange = CTRunGetStringRange(v11);
          if (a2 >= StringRange.location && a2 - StringRange.location < StringRange.length)
          {
            CFIndex GlyphCount = CTRunGetGlyphCount(v11);
            CFIndex v15 = GlyphCount;
            if (GlyphCount >= 1)
            {
              std::vector<long>::vector(buffer, GlyphCount);
              v33.NSUInteger location = 0;
              v33.NSUInteger length = v15;
              CTRunGetStringIndices(v11, v33, buffer[0]);
              CFIndex v16 = 0;
              do
              {
                CFIndex v17 = v16 + 1;
                if (v16 >= v15) {
                  break;
                }
                CFIndex v18 = buffer[0][v16++];
              }
              while (v18 != a2);
              CFIndex v19 = v17 - 1;
              v34.NSUInteger location = v17 - 1;
              v34.NSUInteger length = 1;
              double TypographicBounds = CTRunGetTypographicBounds(v11, v34, 0, 0, 0);
              v35.NSUInteger location = v19;
              v35.NSUInteger length = 1;
              CTRunGetPositions(v11, v35, &v25);
              double x = v25.x;
              *a3 = v25.x;
              double TrailingWhitespaceWidth = CTLineGetTrailingWhitespaceWidth(*v3);
              double v23 = TypographicBounds + x;
              if (buffer[0])
              {
                buffer[1] = buffer[0];
                operator delete(buffer[0]);
              }
              return v23 - TrailingWhitespaceWidth;
            }
            return v4;
          }
        }
        uint64_t v8 = [(__CFArray *)GlyphRuns countByEnumeratingWithState:&v27 objects:v31 count:16];
        if (v8) {
          continue;
        }
        break;
      }
    }
  }
  return v4;
}

void sub_22371F650(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TSWPLineFragment::layoutOrderCharIndexForCaretCharIndex(TSWPLineFragment *this, uint64_t a2, TSWPStorage *a3)
{
  unint64_t v5 = *((void *)this + 1);
  __p = 0;
  CFIndex v15 = 0;
  uint64_t v16 = 0;
  std::vector<TSWPLFCharIndexData>::reserve(&__p, v5);
  TSWPLineFragment::fillCharIndicesAndOffsets((uint64_t)this, (uint64_t)&__p);
  unint64_t v7 = 126 - 2 * __clz(((char *)v15 - (unsigned char *)__p) >> 6);
  CFIndex v17 = (uint64_t (*)(long long *, long long *))compareByCaretPosition;
  if (v15 == __p) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = v7;
  }
  std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*,false>((long long *)__p, v15, &v17, v8, 1, v6);
  uint64_t v10 = (__n128 *)__p;
  if (__p == v15)
  {
LABEL_8:
    if (!__p) {
      return a2;
    }
  }
  else
  {
    unsigned int v11 = 0;
    double v12 = (__n128 *)__p;
    while (v12->n128_u64[0] != a2)
    {
      ++v11;
      v12 += 4;
      if (v12 == v15) {
        goto LABEL_8;
      }
    }
    CFIndex v17 = (uint64_t (*)(long long *, long long *))compareByGlyphPosition;
    std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*,false>((long long *)__p, v15, &v17, 126 - 2 * __clz(((char *)v15 - (unsigned char *)__p) >> 6), 1, v9);
    uint64_t v10 = (__n128 *)__p;
    a2 = *((void *)__p + 8 * (unint64_t)v11);
  }
  CFIndex v15 = v10;
  operator delete(v10);
  return a2;
}

void sub_22371F780(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<TSWPLFCharIndexData>::reserve(void **a1, unint64_t a2)
{
  double v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 6)
  {
    if (a2 >> 58) {
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    __n128 v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TSWPLFCharIndexData>>(v3, a2);
    unint64_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFC0];
    __n128 v9 = &v6[64 * v8];
    unsigned int v11 = (char *)*a1;
    uint64_t v10 = (char *)a1[1];
    double v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        long long v13 = *((_OWORD *)v10 - 4);
        long long v14 = *((_OWORD *)v10 - 3);
        long long v15 = *((_OWORD *)v10 - 1);
        *((_OWORD *)v12 - 2) = *((_OWORD *)v10 - 2);
        *((_OWORD *)v12 - 1) = v15;
        *((_OWORD *)v12 - 4) = v13;
        *((_OWORD *)v12 - 3) = v14;
        v12 -= 64;
        v10 -= 64;
      }
      while (v10 != v11);
      uint64_t v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void TSWPLineFragment::fillCharIndicesAndOffsets(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 200) != *(void *)(a1 + 192) && (*(unsigned char *)(a1 + 25) & 0x40) == 0)
  {
    if (!*(void *)(a1 + 184))
    {
      double v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v5 = [NSString stringWithUTF8String:"void TSWPLineFragment::fillCharIndicesAndOffsets(std::vector<TSWPLFCharIndexData> &) const"];
      objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 2201, @"invalid nil value for '%s'", "_textSource");
    }
    __p = 0;
    CFRange v35 = 0;
    uint64_t v36 = 0;
    TSWPLineFragment::fillWritingDirectionRuns((uint64_t *)a1, &__p);
    CharIndexDatCATransform3D a = TSWPLineFragment::getCharIndexData((TSWPLineFragment *)a1);
    if (CharIndexData != a2) {
      std::vector<TSWPLFCharIndexData>::__assign_with_size[abi:ne180100]<TSWPLFCharIndexData*,TSWPLFCharIndexData*>((char *)a2, *(char **)CharIndexData, *(void *)(CharIndexData + 8), (uint64_t)(*(void *)(CharIndexData + 8) - *(void *)CharIndexData) >> 6);
    }
    int v7 = *(_DWORD *)(a1 + 24);
    if ((v7 & 0x200000) != 0)
    {
      *(void *)&long long v30 = *(void *)(a1 + 8) + *(void *)a1;
      *((void *)&v30 + 1) = 1;
      double v8 = *(double *)(a1 + 48);
      if ((v7 & 0x1000) != 0)
      {
        *(void *)&long long v31 = *(void *)(a1 + 48);
        *((double *)&v31 + 1) = v8;
        *(double *)&long long v32 = v8;
        *((double *)&v32 + 1) = v8;
        LOBYTE(v33) = 0;
        *((void *)&v33 + 1) = 0;
        std::vector<TSWPLFCharIndexData>::insert(a2, *(char **)a2, (char *)&v30);
      }
      else
      {
        *(double *)&long long v31 = v8 + *(double *)(a1 + 64);
        *((void *)&v31 + 1) = v31;
        *(void *)&long long v32 = v31;
        *((void *)&v32 + 1) = v31;
        LOBYTE(v33) = 1;
        *((void *)&v33 + 1) = 0xCCCCCCCCCCCCCCCDLL * ((v35 - (unsigned char *)__p) >> 3) - 1;
        unint64_t v9 = *(void *)(a2 + 16);
        uint64_t v10 = *(_OWORD **)(a2 + 8);
        if ((unint64_t)v10 >= v9)
        {
          uint64_t v15 = ((uint64_t)v10 - *(void *)a2) >> 6;
          unint64_t v16 = v15 + 1;
          if ((unint64_t)(v15 + 1) >> 58) {
            std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v17 = v9 - *(void *)a2;
          if (v17 >> 5 > v16) {
            unint64_t v16 = v17 >> 5;
          }
          if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFC0) {
            unint64_t v18 = 0x3FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v18 = v16;
          }
          if (v18) {
            CFIndex v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TSWPLFCharIndexData>>(a2 + 16, v18);
          }
          else {
            CFIndex v19 = 0;
          }
          uint64_t v20 = &v19[64 * v15];
          uint64_t v21 = &v19[64 * v18];
          long long v22 = v30;
          long long v23 = v31;
          long long v24 = v33;
          *((_OWORD *)v20 + 2) = v32;
          *((_OWORD *)v20 + 3) = v24;
          *(_OWORD *)uint64_t v20 = v22;
          *((_OWORD *)v20 + 1) = v23;
          long long v14 = v20 + 64;
          long long v26 = *(char **)a2;
          CGPoint v25 = *(char **)(a2 + 8);
          if (v25 != *(char **)a2)
          {
            do
            {
              long long v27 = *((_OWORD *)v25 - 4);
              long long v28 = *((_OWORD *)v25 - 3);
              long long v29 = *((_OWORD *)v25 - 1);
              *((_OWORD *)v20 - 2) = *((_OWORD *)v25 - 2);
              *((_OWORD *)v20 - 1) = v29;
              *((_OWORD *)v20 - 4) = v27;
              *((_OWORD *)v20 - 3) = v28;
              v20 -= 64;
              v25 -= 64;
            }
            while (v25 != v26);
            CGPoint v25 = *(char **)a2;
          }
          *(void *)a2 = v20;
          *(void *)(a2 + 8) = v14;
          *(void *)(a2 + 16) = v21;
          if (v25) {
            operator delete(v25);
          }
        }
        else
        {
          long long v11 = v30;
          long long v12 = v31;
          long long v13 = v33;
          unsigned char v10[2] = v32;
          v10[3] = v13;
          *uint64_t v10 = v11;
          v10[1] = v12;
          long long v14 = v10 + 4;
        }
        *(void *)(a2 + 8) = v14;
      }
    }
    if (__p)
    {
      CFRange v35 = __p;
      operator delete(__p);
    }
  }
}

void sub_22371FAC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL compareByCaretPosition(double *a1, double *a2)
{
  double v2 = a1[2];
  double v3 = a2[2];
  if (v2 != v3) {
    return v2 < v3;
  }
  unint64_t v4 = *((void *)a1 + 7);
  unint64_t v5 = *((void *)a2 + 7);
  BOOL v6 = v4 >= v5;
  if (v4 == v5)
  {
    if (*((unsigned char *)a1 + 48))
    {
      unint64_t v7 = *(void *)a1;
      unint64_t v8 = *(void *)a2;
    }
    else
    {
      unint64_t v7 = *(void *)a2;
      unint64_t v8 = *(void *)a1;
    }
    BOOL v6 = v7 >= v8;
  }
  return !v6;
}

uint64_t TSWPLineFragment::caretCharIndexForLayoutOrderCharIndex(TSWPLineFragment *this, uint64_t a2, TSWPStorage *a3)
{
  unint64_t v5 = *((void *)this + 1);
  __p = 0;
  long long v12 = 0;
  uint64_t v13 = 0;
  std::vector<TSWPLFCharIndexData>::reserve(&__p, v5);
  TSWPLineFragment::fillCharIndicesAndOffsets((uint64_t)this, (uint64_t)&__p);
  unint64_t v7 = (__n128 *)__p;
  if (__p == v12)
  {
LABEL_5:
    if (!__p) {
      return a2;
    }
  }
  else
  {
    unsigned int v8 = 0;
    unint64_t v9 = (__n128 *)__p;
    while (v9->n128_u64[0] != a2)
    {
      ++v8;
      v9 += 4;
      if (v9 == v12) {
        goto LABEL_5;
      }
    }
    long long v14 = compareByCaretPosition;
    std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*,false>((long long *)__p, v12, (uint64_t (**)(long long *, long long *))&v14, 126 - 2 * __clz(((char *)v12 - (unsigned char *)__p) >> 6), 1, v6);
    unint64_t v7 = (__n128 *)__p;
    a2 = *((void *)__p + 8 * (unint64_t)v8);
  }
  long long v12 = v7;
  operator delete(v7);
  return a2;
}

void sub_22371FC00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<TSWPLFCharIndexData>::insert(uint64_t a1, char *__src, char *a3)
{
  double v3 = a3;
  unint64_t v4 = __src;
  __n128 v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    uint64_t v15 = *(char **)a1;
    unint64_t v16 = ((uint64_t)&v6[-*(void *)a1] >> 6) + 1;
    if (v16 >> 58) {
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v17 = __src - v15;
    uint64_t v18 = (__src - v15) >> 6;
    uint64_t v19 = v7 - (void)v15;
    if (v19 >> 5 > v16) {
      unint64_t v16 = v19 >> 5;
    }
    if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFC0) {
      unint64_t v20 = 0x3FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v20 = v16;
    }
    uint64_t v41 = a1 + 16;
    if (v20) {
      uint64_t v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TSWPLFCharIndexData>>(a1 + 16, v20);
    }
    else {
      uint64_t v21 = 0;
    }
    long long v28 = &v21[64 * v18];
    __p = v21;
    long long v38 = v28;
    double v39 = v28;
    long long v40 = &v21[64 * v20];
    if (v18 == v20)
    {
      if (v17 < 1)
      {
        if (v15 == v4) {
          unint64_t v30 = 1;
        }
        else {
          unint64_t v30 = v17 >> 5;
        }
        long long v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TSWPLFCharIndexData>>(v8, v30);
        long long v28 = &v31[64 * (v30 >> 2)];
        __p = v31;
        long long v38 = v28;
        long long v40 = &v31[64 * v32];
        if (v21) {
          operator delete(v21);
        }
      }
      else
      {
        unint64_t v29 = v18 + 2;
        if (v18 >= -1) {
          unint64_t v29 = v18 + 1;
        }
        v28 -= 64 * (v29 >> 1);
        long long v38 = v28;
      }
    }
    long long v33 = *((_OWORD *)v3 + 2);
    long long v34 = *((_OWORD *)v3 + 3);
    long long v35 = *((_OWORD *)v3 + 1);
    *(_OWORD *)long long v28 = *(_OWORD *)v3;
    *((_OWORD *)v28 + 1) = v35;
    *((_OWORD *)v28 + 2) = v33;
    *((_OWORD *)v28 + 3) = v34;
    double v39 = v28 + 64;
    unint64_t v4 = (char *)std::vector<TSWPLFCharIndexData>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v4);
    if (v39 != v38) {
      v39 += (v38 - v39 + 63) & 0xFFFFFFFFFFFFFFC0;
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else if (__src == v6)
  {
    long long v25 = *(_OWORD *)a3;
    long long v26 = *((_OWORD *)a3 + 1);
    long long v27 = *((_OWORD *)a3 + 3);
    *((_OWORD *)__src + 2) = *((_OWORD *)a3 + 2);
    *((_OWORD *)__src + 3) = v27;
    *(_OWORD *)__src = v25;
    *((_OWORD *)__src + 1) = v26;
    *(void *)(a1 + 8) = __src + 64;
  }
  else
  {
    unint64_t v9 = __src + 64;
    uint64_t v10 = v6 - 64;
    long long v11 = *(_OWORD **)(a1 + 8);
    while (v10 < v6)
    {
      long long v12 = *(_OWORD *)v10;
      long long v13 = *((_OWORD *)v10 + 1);
      long long v14 = *((_OWORD *)v10 + 3);
      void v11[2] = *((_OWORD *)v10 + 2);
      void v11[3] = v14;
      _OWORD *v11 = v12;
      v11[1] = v13;
      v11 += 4;
      v10 += 64;
    }
    *(void *)(a1 + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-64 * ((v6 - v9) >> 6)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 64 * (unint64_t)(*(void *)(a1 + 8) > (unint64_t)v3);
    }
    long long v22 = *(_OWORD *)v3;
    long long v23 = *((_OWORD *)v3 + 1);
    long long v24 = *((_OWORD *)v3 + 3);
    *((_OWORD *)v4 + 2) = *((_OWORD *)v3 + 2);
    *((_OWORD *)v4 + 3) = v24;
    *(_OWORD *)unint64_t v4 = v22;
    *((_OWORD *)v4 + 1) = v23;
  }
  return v4;
}

void sub_22371FE54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t TSWPLineFragment::nextOrPreviousNonAnchoredDataIndexForDirection(uint64_t a1, unint64_t a2, void *a3, int a4, void *a5)
{
  uint64_t v5 = 0x7FFFFFFFFFFFFFFFLL;
  if (a2 == 0x7FFFFFFFFFFFFFFFLL) {
    return v5;
  }
  unint64_t v7 = a2;
  if (a3[1] == *a3) {
    return v7;
  }
  unint64_t v10 = [a5 length];
  unint64_t v11 = v10;
  if (a4 != 2)
  {
    if (a4 == 3)
    {
      uint64_t v12 = (v7 << 6) - 64;
      do
      {
        uint64_t v5 = v7;
        if (!v7) {
          break;
        }
        if (*(void *)(*a3 + v12) >= v11) {
          break;
        }
        v12 -= 64;
        --v7;
      }
      while ((objc_msgSend(a5, "anchoredDrawableAttachmentCharacterAtCharIndex:") & 1) != 0);
      return v5;
    }
    unint64_t v16 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v17 = objc_msgSend(NSString, "stringWithUTF8String:", "TSWPCharIndex TSWPLineFragment::nextOrPreviousNonAnchoredDataIndexForDirection(TSWPCharIndex, vector<TSWPLFCharIndexData> &, TSWPTextLayoutDirection, TSWPStorage *) const");
    objc_msgSend(v16, "handleFailureInFunction:file:lineNumber:description:", v17, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 2530, @"This routine supports left and right only.");
    return v7;
  }
  if (v7 >= (uint64_t)(a3[1] - *a3) >> 6) {
    goto LABEL_22;
  }
  if (*(void *)(*a3 + (v7 << 6)) >= v10)
  {
    char v13 = 0;
  }
  else
  {
    char v13 = 0;
    uint64_t v14 = (v7 << 6) + 64;
    do
    {
      if (!objc_msgSend(a5, "anchoredDrawableAttachmentCharacterAtCharIndex:")) {
        break;
      }
      if (++v7 >= (uint64_t)(a3[1] - *a3) >> 6) {
        return v7;
      }
      unint64_t v15 = *(void *)(*a3 + v14);
      v14 += 64;
      char v13 = 1;
    }
    while (v15 < v11);
  }
  uint64_t v5 = v7;
  if ((v13 & 1) == 0)
  {
LABEL_22:
    uint64_t v19 = (v7 << 6) + 64;
    do
    {
      uint64_t v5 = v7++;
      if (v7 >= (uint64_t)(a3[1] - *a3) >> 6) {
        break;
      }
      if (*(void *)(*a3 + v19) >= v11) {
        break;
      }
      v19 += 64;
    }
    while ((objc_msgSend(a5, "anchoredDrawableAttachmentCharacterAtCharIndex:") & 1) != 0);
  }
  return v5;
}

uint64_t TSWPLineFragment::nextOrPreviousCharIndexForDirection(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  if (*(unsigned char *)(a1 + 24)) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  unint64_t v8 = *(void *)(a1 + 8);
  if (!*(void *)(a1 + 184))
  {
    unint64_t v9 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v10 = objc_msgSend(NSString, "stringWithUTF8String:", "TSWPCharIndex TSWPLineFragment::nextOrPreviousCharIndexForDirection(TSWPCharIndex, TSWPTextLayoutDirection, TSWPStorage *) const");
    objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 2547, @"invalid nil value for '%s'", "_textSource");
  }
  __p = 0;
  long long v33 = 0;
  uint64_t v34 = 0;
  std::vector<TSWPLFCharIndexData>::reserve(&__p, v8);
  TSWPLineFragment::fillCharIndicesAndOffsets(a1, (uint64_t)&__p);
  uint64_t v12 = __p;
  unint64_t v11 = v33;
  unint64_t v13 = [*(id *)(a1 + 184) charIndexRemappedFromStorage:a2];
  unint64_t v14 = (v11 - v12) >> 6;
  if (v11 == v12)
  {
    unint64_t v15 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else
  {
    unint64_t v15 = 0;
    unsigned int v16 = 1;
    while (1)
    {
      uint64_t v17 = (unint64_t *)((char *)__p + 64 * v15);
      unint64_t v19 = *v17;
      unint64_t v18 = v17[1];
      BOOL v21 = v13 >= v19;
      unint64_t v20 = v13 - v19;
      BOOL v21 = !v21 || v20 >= v18;
      if (!v21) {
        break;
      }
      unint64_t v15 = v16;
      if (v14 <= v16++)
      {
        if ((*(unsigned char *)(a1 + 25) & 0x10) != 0) {
          unint64_t v15 = 0;
        }
        else {
          unint64_t v15 = v14 - 1;
        }
        break;
      }
    }
  }
  unint64_t v24 = TSWPLineFragment::nextOrPreviousNonAnchoredDataIndexForDirection(v13, v15, &__p, a3, a4);
  unint64_t v25 = v24;
  if (v24 != 0x7FFFFFFFFFFFFFFFLL)
  {
    if (a3 == 3)
    {
      if (v24)
      {
        long long v27 = __p;
        long long v28 = (char *)__p + 64 * v25 - 64;
        goto LABEL_24;
      }
    }
    else if (a3 == 2)
    {
      unint64_t v26 = v24 + 1;
      if (v24 + 1 < v14)
      {
        long long v27 = __p;
        long long v28 = (char *)__p + 64 * v26;
LABEL_24:
        uint64_t v23 = *(void *)v28;
LABEL_27:
        long long v33 = v27;
        operator delete(v27);
        return v23;
      }
    }
    else
    {
      unint64_t v29 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v30 = objc_msgSend(NSString, "stringWithUTF8String:", "TSWPCharIndex TSWPLineFragment::nextOrPreviousCharIndexForDirection(TSWPCharIndex, TSWPTextLayoutDirection, TSWPStorage *) const");
      objc_msgSend(v29, "handleFailureInFunction:file:lineNumber:description:", v30, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 2601, @"This routine supports left and right only.");
    }
  }
  long long v27 = __p;
  uint64_t v23 = 0x7FFFFFFFFFFFFFFFLL;
  if (__p) {
    goto LABEL_27;
  }
  return v23;
}

void sub_223720258(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TSWPLineFragment::countOfGlyphRuns(TSWPLineFragment *this)
{
  double v1 = (CTLineRef *)*((void *)this + 24);
  if (*((CTLineRef **)this + 25) == v1) {
    return 0;
  }
  CFArrayRef GlyphRuns = CTLineGetGlyphRuns(*v1);

  return [(__CFArray *)GlyphRuns count];
}

CFIndex TSWPLineFragment::glyphCountForRunIndex(TSWPLineFragment *this, unsigned int a2)
{
  double v2 = (CTLineRef *)*((void *)this + 24);
  if (*((CTLineRef **)this + 25) == v2) {
    return 0;
  }
  CFArrayRef GlyphRuns = CTLineGetGlyphRuns(*v2);
  if ([(__CFArray *)GlyphRuns count] <= (unint64_t)a2) {
    return 0;
  }
  uint64_t v5 = (const __CTRun *)[(__CFArray *)GlyphRuns objectAtIndexedSubscript:a2];

  return CTRunGetGlyphCount(v5);
}

BOOL TSWPLineFragment::isRunIndexLeftToRight(TSWPLineFragment *this, unsigned int a2)
{
  double v2 = (CTLineRef *)*((void *)this + 24);
  if (*((CTLineRef **)this + 25) == v2) {
    return 1;
  }
  CFArrayRef GlyphRuns = CTLineGetGlyphRuns(*v2);
  return [(__CFArray *)GlyphRuns count] <= (unint64_t)a2
      || (CTRunGetStatus((CTRunRef)[(__CFArray *)GlyphRuns objectAtIndexedSubscript:a2]) & 1) == 0;
}

uint64_t TSWPLineFragment::characterCountOfGlyphAtCharIndex(TSWPLineFragment *this, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  double v2 = (const __CTLine **)*((void *)this + 24);
  if (*((const __CTLine ***)this + 25) == v2) {
    return 1;
  }
  if (*((void *)this + 1) < 2uLL) {
    return 1;
  }
  line = *v2;
  unint64_t v4 = TSWPNextCharFromTextSource(a2, *((void **)this + 23));
  unint64_t v19 = *((void *)this + 1) + *(void *)this;
  if (v4 >= v19)
  {
    return 1;
  }
  else
  {
    unint64_t v5 = v4;
    unsigned int v21 = 1;
    do
    {
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      CFArrayRef GlyphRuns = CTLineGetGlyphRuns(line);
      uint64_t v7 = [(__CFArray *)GlyphRuns countByEnumeratingWithState:&v23 objects:v27 count:16];
      if (v7)
      {
        uint64_t v8 = *(void *)v24;
        while (2)
        {
          for (uint64_t i = 0; i != v7; ++i)
          {
            if (*(void *)v24 != v8) {
              objc_enumerationMutation(GlyphRuns);
            }
            uint64_t v10 = *(const __CTRun **)(*((void *)&v23 + 1) + 8 * i);
            CFIndex GlyphCount = CTRunGetGlyphCount(v10);
            if ((unint64_t)(GlyphCount - 65537) <= 0xFFFFFFFFFFFEFFFFLL)
            {
              unsigned int v16 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
              uint64_t v17 = [NSString stringWithUTF8String:"uint TSWPLineFragment::characterCountOfGlyphAtCharIndex(TSWPCharIndex) const"];
              objc_msgSend(v16, "handleFailureInFunction:file:lineNumber:description:", v17, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 2694, @"bad glyph count: %ld", GlyphCount);
              goto LABEL_23;
            }
            std::vector<long>::vector(buffer, GlyphCount);
            v29.NSUInteger location = 0;
            v29.NSUInteger length = GlyphCount;
            CTRunGetStringIndices(v10, v29, buffer[0]);
            if (!*((void *)this + 23))
            {
              uint64_t v12 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
              uint64_t v13 = [NSString stringWithUTF8String:"uint TSWPLineFragment::characterCountOfGlyphAtCharIndex(TSWPCharIndex) const"];
              objc_msgSend(v12, "handleFailureInFunction:file:lineNumber:description:", v13, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 2700, @"invalid nil value for '%s'", "_textSource");
            }
            uint64_t v14 = 0;
            BOOL v15 = 1;
            do
            {
              if ([*((id *)this + 23) charIndexMappedToStorage:buffer[0][v14]] == v5) {
                break;
              }
              BOOL v15 = GlyphCount > ++v14;
            }
            while (GlyphCount != v14);
            if (buffer[0])
            {
              buffer[1] = buffer[0];
              operator delete(buffer[0]);
            }
            if (v15) {
              return v21;
            }
          }
          uint64_t v7 = [(__CFArray *)GlyphRuns countByEnumeratingWithState:&v23 objects:v27 count:16];
          if (v7) {
            continue;
          }
          break;
        }
      }
LABEL_23:
      unint64_t v5 = TSWPNextCharFromTextSource(v5, *((void **)this + 23));
      ++v21;
    }
    while (v5 < v19);
  }
  return v21;
}

void sub_22372065C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TSWPLineFragment::isInsideTateChuYokoLineAtCharIndex(TSWPLineFragment *this, uint64_t a2, double *a3, double *a4, double *a5, double *a6, double *a7)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  if (*((void *)this + 32) != *((void *)this + 31))
  {
    uint64_t v14 = (void *)*((void *)this + 23);
    if (!v14)
    {
      BOOL v15 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v16 = objc_msgSend(NSString, "stringWithUTF8String:", "BOOL TSWPLineFragment::isInsideTateChuYokoLineAtCharIndex(TSWPCharIndex, CGFloat &, CGFloat &, CGFloat &, CGFloat &, CGFloat &) const");
      objc_msgSend(v15, "handleFailureInFunction:file:lineNumber:description:", v16, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 2821, @"invalid nil value for '%s'", "_textSource");
      uint64_t v14 = (void *)*((void *)this + 23);
    }
    unint64_t v17 = [v14 charIndexMappedFromStorage:a2];
    uint64_t v19 = *((void *)this + 31);
    uint64_t v18 = *((void *)this + 32);
    uint64_t v20 = v18 - v19;
    if (v18 != v19)
    {
      uint64_t v21 = 0;
      unint64_t v22 = 0xAAAAAAAAAAAAAAABLL * (v20 >> 4);
      unsigned int v23 = 1;
      while (1)
      {
        uint64_t v24 = v19 + 48 * v21;
        unint64_t v25 = *(void *)(v24 + 24);
        unint64_t v26 = *(void *)(v24 + 32) + v25;
        if (v17 > v25 && v17 < v26) {
          break;
        }
        uint64_t v21 = v23;
        BOOL v37 = v22 > v23++;
        if (!v37) {
          return 0;
        }
      }
      uint64_t v28 = 48 * v21;
      unint64_t v29 = v17 - v25 + CTLineGetStringRange((CTLineRef)*(void *)(v19 + 48 * v21)).location;
      *a3 = CTLineGetOffsetForStringIndex(*(CTLineRef *)(v19 + v28), v29, 0);
      *a4 = CTLineGetTypographicBounds(*(CTLineRef *)(v19 + v28), 0, 0, 0);
      CTLineGetGlyphRuns(*(CTLineRef *)(v19 + v28));
      long long v48 = 0u;
      long long v49 = 0u;
      long long v50 = 0u;
      long long v51 = 0u;
      CFArrayRef GlyphRuns = CTLineGetGlyphRuns(*(CTLineRef *)(v19 + v28));
      uint64_t v31 = [(__CFArray *)GlyphRuns countByEnumeratingWithState:&v48 objects:v52 count:16];
      if (v31)
      {
        uint64_t v32 = v31;
        uint64_t v33 = *(void *)v49;
        do
        {
          for (uint64_t i = 0; i != v32; ++i)
          {
            if (*(void *)v49 != v33) {
              objc_enumerationMutation(GlyphRuns);
            }
            long long v35 = *(const __CTRun **)(*((void *)&v48 + 1) + 8 * i);
            CFRange StringRange = CTRunGetStringRange(v35);
            BOOL v37 = StringRange.location >= v29 || v29 > StringRange.location + StringRange.length;
            if (!v37)
            {
              CFDictionaryRef Attributes = CTRunGetAttributes(v35);
              Value = (const __CTFont *)CFDictionaryGetValue(Attributes, (const void *)*MEMORY[0x263F039A0]);
              long long v46 = 0u;
              long long v47 = 0u;
              long long v44 = 0u;
              long long v45 = 0u;
              TSWPFontHeightInfoForFont(Value, &v44);
              uint64_t v42 = *((void *)&v45 + 1);
              *(void *)a5 = v45;
              *(void *)a6 = v42;
              *(void *)a7 = v46;
              return 1;
            }
          }
          uint64_t v32 = [(__CFArray *)GlyphRuns countByEnumeratingWithState:&v48 objects:v52 count:16];
        }
        while (v32);
      }
      long long v38 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v39 = objc_msgSend(NSString, "stringWithUTF8String:", "BOOL TSWPLineFragment::isInsideTateChuYokoLineAtCharIndex(TSWPCharIndex, CGFloat &, CGFloat &, CGFloat &, CGFloat &, CGFloat &) const");
      objc_msgSend(v38, "handleFailureInFunction:file:lineNumber:description:", v39, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 2860, @"Could not find the CTRun for the tate chu yoko run.");
    }
  }
  return 0;
}

TSWPLineFragment *TSWPLineFragment::setHyphenated(TSWPLineFragment *this, int a2)
{
  if (a2) {
    int v2 = 2;
  }
  else {
    int v2 = 0;
  }
  *((_DWORD *)this + 6) = *((_DWORD *)this + 6) & 0xFFFFFFFD | v2;
  return this;
}

TSWPLineFragment *TSWPLineFragment::setWasReused(TSWPLineFragment *this)
{
  *((_DWORD *)this + 6) |= 0x400000u;
  return this;
}

BOOL TSWPLineFragment::isDifferentFromLineFragment(TSWPLineFragment *this, const TSWPLineFragment *a2, uint64_t a3)
{
  if (a2 == this) {
    return 0;
  }
  v15.origin.double x = *((CGFloat *)this + 6);
  v15.origin.CGFloat y = *((CGFloat *)this + 7);
  v15.size.CGFloat width = *((CGFloat *)this + 8);
  v15.size.CGFloat height = *((CGFloat *)this + 9);
  v16.origin.double x = *((CGFloat *)a2 + 6);
  v16.origin.CGFloat y = *((CGFloat *)a2 + 7);
  v16.size.CGFloat width = *((CGFloat *)a2 + 8);
  v16.size.CGFloat height = *((CGFloat *)a2 + 9);
  if (!CGRectEqualToRect(v15, v16)) {
    return 1;
  }
  if (!CGRectEqualToRect(*(CGRect *)((char *)this + 80), *(CGRect *)((char *)a2 + 80))) {
    return 1;
  }
  if (*((double *)this + 4) != *((double *)a2 + 4)) {
    return 1;
  }
  if (*((double *)this + 5) != *((double *)a2 + 5)) {
    return 1;
  }
  if (*(void *)this != *(void *)a2 + a3) {
    return 1;
  }
  if (*((void *)this + 2) != *((void *)a2 + 2) + a3) {
    return 1;
  }
  if (*((void *)this + 1) != *((void *)a2 + 1)) {
    return 1;
  }
  if (*((_DWORD *)this + 6) != *((_DWORD *)a2 + 6)) {
    return 1;
  }
  uint64_t v7 = *((void *)a2 + 24);
  uint64_t v6 = *((void *)a2 + 25);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 4);
  if (v8 != 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)this + 25) - *((void *)this + 24)) >> 4)) {
    return 1;
  }
  if (v6 != v7)
  {
    uint64_t v9 = 0;
    unsigned int v10 = 1;
    while (!operator!=(*((void *)a2 + 24) + 48 * v9, *((void *)this + 24) + 48 * v9))
    {
      uint64_t v9 = v10;
      if (v8 <= v10++) {
        goto LABEL_15;
      }
    }
    return 1;
  }
LABEL_15:
  uint64_t v12 = (TSWPListLabel *)*((void *)this + 22);
  uint64_t v13 = (const TSWPListLabel *)*((void *)a2 + 22);
  if (!v12) {
    return v13 || (*((unsigned char *)this + 24) & 1) != 0;
  }
  return !v13 || (TSWPListLabel::isEqual(v12, v13) & 1) == 0;
}

BOOL operator!=(uint64_t a1, uint64_t a2)
{
  BOOL v2 = *(double *)(a1 + 8) == *(double *)(a2 + 8) && *(double *)(a1 + 16) == *(double *)(a2 + 16);
  if (v2
    && CFEqual(*(CFTypeRef *)a1, *(CFTypeRef *)a2)
    && (*(void *)(a1 + 24) == *(void *)(a2 + 24) ? (BOOL v5 = *(void *)(a1 + 32) == *(void *)(a2 + 32)) : (BOOL v5 = 0), v5))
  {
    return *(_DWORD *)(a1 + 40) != *(_DWORD *)(a2 + 40);
  }
  else
  {
    return 1;
  }
}

BOOL TSWPLineFragment::preventWidowCorrection(TSWPLineFragment *this, CGRect a2)
{
  CGFloat height = a2.size.height;
  CGFloat width = a2.size.width;
  CGFloat y = a2.origin.y;
  CGFloat x = a2.origin.x;
  v10.origin.CGFloat x = *((CGFloat *)this + 6);
  v10.origin.CGFloat y = *((CGFloat *)this + 7);
  v10.size.CGFloat width = *((CGFloat *)this + 8);
  v10.size.CGFloat height = *((CGFloat *)this + 9);
  double v7 = round(CGRectGetMinX(v10));
  v11.origin.CGFloat x = x;
  v11.origin.CGFloat y = y;
  v11.size.CGFloat width = width;
  v11.size.CGFloat height = height;
  if (v7 != round(CGRectGetMinX(v11))) {
    return 1;
  }
  double v9 = round(CGRectGetMaxX(*(CGRect *)((char *)this + 48)));
  v12.origin.CGFloat x = x;
  v12.origin.CGFloat y = y;
  v12.size.CGFloat width = width;
  v12.size.CGFloat height = height;
  return v9 != round(CGRectGetMaxX(v12));
}

CGFloat TSWPLineFragment::offsetBy(TSWPLineFragment *this, CGPoint a2)
{
  CGFloat v2 = a2.y + *((double *)this + 7);
  *((double *)this + 6) = a2.x + *((double *)this + 6);
  *((CGFloat *)this + 7) = v2;
  CGFloat v3 = a2.y + *((double *)this + 11);
  *((double *)this + 10) = a2.x + *((double *)this + 10);
  *((CGFloat *)this + 11) = v3;
  CGFloat result = a2.y + *((double *)this + 4);
  *((CGFloat *)this + 4) = result;
  return result;
}

uint64_t TSWPLineFragment::hintForAttachmentLayout(TSWPLineFragment *this)
{
  if ((*((unsigned char *)this + 24) & 1) == 0) {
    return 0;
  }
  uint64_t v1 = *((void *)this + 54);
  if (!v1) {
    return 0;
  }
  CGFloat v2 = objc_msgSend((id)objc_msgSend(*((id *)this + 54), "info"), "partitioner");

  return [v2 hintForLayout:v1];
}

void TSWPLineFragment::setHyphenInfo(TSWPLineFragment *this, CFTypeRef cf, int a3)
{
  uint64_t v6 = *((void *)this + 49);
  if (!v6) {
    operator new();
  }
  if (cf) {
    CFRetain(cf);
  }
  double v7 = *(const void **)(v6 + 16);
  if (v7) {
    CFRelease(v7);
  }
  *(void *)(v6 + 16) = cf;
  *(_DWORD *)(*((void *)this + 49) + 24) = a3;
}

TSWPLineFragment *TSWPLineFragment::getHyphenInfo(TSWPLineFragment *this, const __CFDictionary **a2, unsigned int *a3)
{
  BOOL v5 = this;
  uint64_t v6 = *((void *)this + 49);
  if (v6
    || (double v7 = (void *)[MEMORY[0x263F7C7F0] currentHandler],
        v8 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPLineFragment::getHyphenInfo(CFDictionaryRef &, UTF32Char &) const"), this = (TSWPLineFragment *)objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 3104, @"Typesetter state not initialized"), (uint64_t v6 = *((void *)v5 + 49)) != 0))
  {
    *a2 = *(const __CFDictionary **)(v6 + 16);
    LODWORD(v6) = *(_DWORD *)(*((void *)v5 + 49) + 24);
  }
  else
  {
    *a2 = 0;
  }
  *a3 = v6;
  return this;
}

uint64_t TSWPLineFragment::setOikomiSquish(TSWPLineFragment *this, char a2)
{
  uint64_t result = *((void *)this + 49);
  if (!result) {
    operator new();
  }
  *(unsigned char *)(result + 28) = a2;
  return result;
}

void TSWPLineFragment::restoreLayoutState(TSWPLineFragment *this)
{
  *((_DWORD *)this + 6) = *((_DWORD *)this + 120) & 0xFFFFFFFD;
  CGFloat v3 = (CFTypeRef *)*((void *)this + 24);
  for (uint64_t i = (CFTypeRef *)*((void *)this + 25);
        i != v3;
        std::allocator<TSWPLineRef>::destroy[abi:ne180100]((uint64_t)this + 208, i))
  {
    i -= 6;
  }
  *((void *)this + 25) = v3;
  uint64_t v5 = *((void *)this + 55);
  for (uint64_t j = *((void *)this + 56); j != v5; TSWPAdornments::~TSWPAdornments((CGColorRef *)(j - 200)))
    ;
  *((void *)this + 56) = v5;
  uint64_t v7 = *((void *)this + 34);
  for (uint64_t k = *((void *)this + 35);
        k != v7;
        std::allocator<TSWPAdornmentLine>::destroy[abi:ne180100]((uint64_t)this + 288, k))
  {
    k -= 80;
  }
  *((void *)this + 35) = v7;
  uint64_t v9 = *((void *)this + 37);
  for (uint64_t m = *((void *)this + 38);
        m != v9;
        std::allocator<TSWPAdornmentLine>::destroy[abi:ne180100]((uint64_t)this + 312, m))
  {
    m -= 80;
  }
  *((void *)this + 38) = v9;
  uint64_t v11 = *((void *)this + 40);
  for (uint64_t n = *((void *)this + 41);
        n != v11;
        std::allocator<TSWPAdornmentLine>::destroy[abi:ne180100]((uint64_t)this + 336, n))
  {
    n -= 80;
  }
  *((void *)this + 41) = v11;
  uint64_t v13 = *((void *)this + 43);
  for (iuint64_t i = *((void *)this + 44);
        ii != v13;
        std::allocator<TSWPAdornmentLine>::destroy[abi:ne180100]((uint64_t)this + 360, ii))
  {
    ii -= 80;
  }
  *((void *)this + 44) = v13;

  *((void *)this + 64) = 0;
  uint64_t v14 = *((void *)this + 58);
  if (v14)
  {
    CGColorRelease(*(CGColorRef *)(v14 + 24));

    MEMORY[0x223CB8F20](v14, 0x10A0C406E8A3FE5);
    *((void *)this + 58) = 0;
  }
}

uint64_t TSWPLineFragment::appendAdornment(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    id v4 = *(id *)(result + 528);
    if (!v4)
    {
      id v4 = objc_alloc_init(MEMORY[0x263EFF980]);
      *(void *)(v3 + 528) = v4;
    }
    return [v4 addObject:a2];
  }
  return result;
}

uint64_t TSWPLineFragment::defaultMarkupColor(TSWPLineFragment *this)
{
  if (TSWPLineFragment::defaultMarkupColor(void)const::onceChangeTrackingColor != -1) {
    dispatch_once(&TSWPLineFragment::defaultMarkupColor(void)const::onceChangeTrackingColor, &__block_literal_global_106);
  }
  return TSWPLineFragment::defaultMarkupColor(void)const::sDefaultChangeTrackingColor;
}

id ___ZNK16TSWPLineFragment18defaultMarkupColorEv_block_invoke()
{
  id result = (id)[MEMORY[0x263F7C808] colorWithWhite:0.156800002 alpha:1.0];
  TSWPLineFragment::defaultMarkupColor(void)const::sDefaultChangeTrackingColor = (uint64_t)result;
  return result;
}

uint64_t TSWPLineFragment::changeAdornmentMarkupColor(TSWPLineFragment *this)
{
  uint64_t result = *((void *)this + 59);
  if (!result)
  {
    if (TSWPLineFragment::defaultMarkupColor(void)const::onceChangeTrackingColor != -1) {
      dispatch_once(&TSWPLineFragment::defaultMarkupColor(void)const::onceChangeTrackingColor, &__block_literal_global_106);
    }
    return TSWPLineFragment::defaultMarkupColor(void)const::sDefaultChangeTrackingColor;
  }
  return result;
}

TSWPLineFragment *TSWPLineFragment::setChangeAdornmentMarkupColor(TSWPLineFragment *this, TSUColor *a2)
{
  CGFloat v2 = (TSUColor *)*((void *)this + 59);
  if (v2 != a2)
  {
    id v4 = this;

    this = a2;
    *((void *)v4 + 59) = this;
  }
  return this;
}

BOOL TSWPLineFragment::markupColorIsDefault(TSWPLineFragment *this)
{
  return *((void *)this + 59) == 0;
}

void std::allocator<TSWPAdornmentLine>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
}

void std::vector<TSWPUIAttachmentData>::__base_destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 8); i != a2; i -= 32)
  {
    uint64_t v5 = *(void **)(i - 32);
  }
  *(void *)(a1 + 8) = a2;
}

void *std::vector<unsigned short>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned short>::__vallocate[abi:ne180100](a1, a2);
    id v4 = (char *)a1[1];
    bzero(v4, 2 * a2);
    a1[1] = &v4[2 * a2];
  }
  return a1;
}

void sub_223721230(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*>(uint64_t result, _OWORD *a2, uint64_t (**a3)(long long *, _OWORD *))
{
  if ((_OWORD *)result != a2)
  {
    uint64_t v22 = v3;
    uint64_t v23 = v4;
    uint64_t v6 = (_OWORD *)result;
    uint64_t v7 = (_OWORD *)(result + 64);
    if ((_OWORD *)(result + 64) != a2)
    {
      uint64_t v9 = (_OWORD *)(result - 64);
      do
      {
        CGRect v10 = v6;
        uint64_t v6 = v7;
        uint64_t result = (*a3)(v7, v10);
        if (result)
        {
          long long v11 = v6[1];
          long long v18 = *v6;
          long long v19 = v11;
          long long v12 = v6[3];
          long long v20 = v6[2];
          long long v21 = v12;
          uint64_t v13 = v9;
          do
          {
            long long v14 = v13[5];
            void v13[8] = v13[4];
            v13[9] = v14;
            long long v15 = v13[7];
            v13[10] = v13[6];
            v13[11] = v15;
            uint64_t result = (*a3)(&v18, v13);
            v13 -= 4;
          }
          while ((result & 1) != 0);
          long long v16 = v19;
          void v13[8] = v18;
          v13[9] = v16;
          long long v17 = v21;
          v13[10] = v20;
          v13[11] = v17;
        }
        uint64_t v7 = v6 + 4;
        v9 += 4;
      }
      while (v6 + 4 != a2);
    }
  }
  return result;
}

long long *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,TSWPLFCharIndexData *,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&)>(long long *a1, long long *a2, uint64_t (**a3)(long long *, long long *))
{
  uint64_t v4 = a2;
  long long v6 = a1[1];
  long long v28 = *a1;
  long long v29 = v6;
  long long v7 = a1[3];
  long long v30 = a1[2];
  long long v31 = v7;
  if ((*a3)(&v28, a2 - 4))
  {
    uint64_t v8 = a1;
    do
      v8 += 4;
    while (((*a3)(&v28, v8) & 1) == 0);
  }
  else
  {
    uint64_t v9 = a1 + 4;
    do
    {
      uint64_t v8 = v9;
      if (v9 >= v4) {
        break;
      }
      int v10 = (*a3)(&v28, v9);
      uint64_t v9 = v8 + 4;
    }
    while (!v10);
  }
  if (v8 < v4)
  {
    do
      v4 -= 4;
    while (((*a3)(&v28, v4) & 1) != 0);
  }
  while (v8 < v4)
  {
    long long v11 = *v8;
    long long v12 = v8[1];
    long long v13 = v8[3];
    long long v34 = v8[2];
    long long v35 = v13;
    long long v32 = v11;
    long long v33 = v12;
    long long v14 = *v4;
    long long v15 = v4[1];
    long long v16 = v4[3];
    _OWORD v8[2] = v4[2];
    v8[3] = v16;
    *uint64_t v8 = v14;
    v8[1] = v15;
    long long v17 = v32;
    long long v18 = v33;
    long long v19 = v35;
    void v4[2] = v34;
    v4[3] = v19;
    long long *v4 = v17;
    v4[1] = v18;
    do
      v8 += 4;
    while (!(*a3)(&v28, v8));
    do
      v4 -= 4;
    while (((*a3)(&v28, v4) & 1) != 0);
  }
  long long v20 = v8 - 4;
  if (v8 - 4 != a1)
  {
    long long v21 = *v20;
    long long v22 = *(v8 - 3);
    long long v23 = *(v8 - 1);
    a1[2] = *(v8 - 2);
    a1[3] = v23;
    *a1 = v21;
    a1[1] = v22;
  }
  long long v24 = v28;
  long long v25 = v29;
  long long v26 = v31;
  *(v8 - 2) = v30;
  *(v8 - 1) = v26;
  *long long v20 = v24;
  *(v8 - 3) = v25;
  return v8;
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*>(uint64_t a1, long long *a2, long long *a3, long long *a4, uint64_t (**a5)(long long *, long long *))
{
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*>((long long *)a1, a2, a3, a5);
  if ((*a5)(a4, a3))
  {
    long long v12 = a3[2];
    long long v11 = a3[3];
    long long v14 = *a3;
    long long v13 = a3[1];
    long long v15 = a4[3];
    long long v17 = *a4;
    long long v16 = a4[1];
    a3[2] = a4[2];
    a3[3] = v15;
    *a3 = v17;
    a3[1] = v16;
    *a4 = v14;
    a4[1] = v13;
    a4[2] = v12;
    a4[3] = v11;
    if ((*a5)(a3, a2))
    {
      long long v19 = a2[2];
      long long v18 = a2[3];
      long long v21 = *a2;
      long long v20 = a2[1];
      long long v22 = a3[3];
      long long v24 = *a3;
      long long v23 = a3[1];
      a2[2] = a3[2];
      a2[3] = v22;
      *a2 = v24;
      a2[1] = v23;
      *a3 = v21;
      a3[1] = v20;
      a3[2] = v19;
      a3[3] = v18;
      if ((*a5)(a2, (long long *)a1))
      {
        long long v25 = *(_OWORD *)(a1 + 32);
        __n128 result = *(__n128 *)(a1 + 48);
        long long v27 = *(_OWORD *)a1;
        long long v26 = *(_OWORD *)(a1 + 16);
        long long v28 = a2[3];
        long long v30 = *a2;
        long long v29 = a2[1];
        *(_OWORD *)(a1 + 32) = a2[2];
        *(_OWORD *)(a1 + 48) = v28;
        *(_OWORD *)a1 = v30;
        *(_OWORD *)(a1 + 16) = v29;
        *a2 = v27;
        a2[1] = v26;
        a2[2] = v25;
        a2[3] = (__int128)result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*>(uint64_t a1, long long *a2, long long *a3, long long *a4, long long *a5, uint64_t (**a6)(long long *, long long *))
{
  __n128 v12 = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*>(a1, a2, a3, a4, a6);
  if (((unsigned int (*)(long long *, long long *, __n128))*a6)(a5, a4, v12))
  {
    long long v15 = a4[2];
    long long v14 = a4[3];
    long long v17 = *a4;
    long long v16 = a4[1];
    long long v18 = a5[3];
    long long v20 = *a5;
    long long v19 = a5[1];
    a4[2] = a5[2];
    a4[3] = v18;
    *a4 = v20;
    a4[1] = v19;
    *a5 = v17;
    a5[1] = v16;
    a5[2] = v15;
    a5[3] = v14;
    if ((*a6)(a4, a3))
    {
      long long v22 = a3[2];
      long long v21 = a3[3];
      long long v24 = *a3;
      long long v23 = a3[1];
      long long v25 = a4[3];
      long long v27 = *a4;
      long long v26 = a4[1];
      a3[2] = a4[2];
      a3[3] = v25;
      *a3 = v27;
      a3[1] = v26;
      *a4 = v24;
      a4[1] = v23;
      a4[2] = v22;
      a4[3] = v21;
      if ((*a6)(a3, a2))
      {
        long long v29 = a2[2];
        long long v28 = a2[3];
        long long v31 = *a2;
        long long v30 = a2[1];
        long long v32 = a3[3];
        long long v34 = *a3;
        long long v33 = a3[1];
        a2[2] = a3[2];
        a2[3] = v32;
        *a2 = v34;
        a2[1] = v33;
        *a3 = v31;
        a3[1] = v30;
        a3[2] = v29;
        a3[3] = v28;
        if ((*a6)(a2, (long long *)a1))
        {
          long long v35 = *(_OWORD *)(a1 + 32);
          __n128 result = *(__n128 *)(a1 + 48);
          long long v37 = *(_OWORD *)a1;
          long long v36 = *(_OWORD *)(a1 + 16);
          long long v38 = a2[3];
          long long v40 = *a2;
          long long v39 = a2[1];
          *(_OWORD *)(a1 + 32) = a2[2];
          *(_OWORD *)(a1 + 48) = v38;
          *(_OWORD *)a1 = v40;
          *(_OWORD *)(a1 + 16) = v39;
          *a2 = v37;
          a2[1] = v36;
          a2[2] = v35;
          a2[3] = (__int128)result;
        }
      }
    }
  }
  return result;
}

__n128 *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*,TSWPLFCharIndexData*>(uint64_t a1, __n128 *a2, __n128 *a3, unsigned int (**a4)(__n128 *, __n128 *), __n128 a5)
{
  if ((__n128 *)a1 != a2)
  {
    long long v7 = a2;
    uint64_t v9 = (uint64_t)a2 - a1;
    uint64_t v10 = ((uint64_t)a2 - a1) >> 6;
    if ((uint64_t)a2 - a1 >= 65)
    {
      unint64_t v11 = (unint64_t)(v10 - 2) >> 1;
      unint64_t v12 = v11 + 1;
      long long v13 = (__n128 *)(a1 + (v11 << 6));
      do
      {
        a5 = std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*>(a1, a4, v10, v13);
        v13 -= 4;
        --v12;
      }
      while (v12);
    }
    long long v14 = v7;
    if (v7 != a3)
    {
      long long v15 = v7;
      do
      {
        if (((unsigned int (*)(__n128 *, uint64_t, __n128))*a4)(v15, a1, a5))
        {
          __n128 v17 = v15[2];
          __n128 v16 = v15[3];
          __n128 v19 = *v15;
          __n128 v18 = v15[1];
          __n128 v20 = *(__n128 *)(a1 + 48);
          __n128 v22 = *(__n128 *)a1;
          __n128 v21 = *(__n128 *)(a1 + 16);
          _OWORD v15[2] = *(__n128 *)(a1 + 32);
          _OWORD v15[3] = v20;
          *long long v15 = v22;
          v15[1] = v21;
          *(__n128 *)a1 = v19;
          *(__n128 *)(a1 + 16) = v18;
          *(__n128 *)(a1 + 32) = v17;
          *(__n128 *)(a1 + 48) = v16;
          a5 = std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*>(a1, a4, v10, (__n128 *)a1);
        }
        v15 += 4;
      }
      while (v15 != a3);
      long long v14 = a3;
    }
    if (v9 < 65)
    {
      return v14;
    }
    else
    {
      long long v37 = v14;
      uint64_t v23 = (unint64_t)v9 >> 6;
      do
      {
        uint64_t v24 = 0;
        __n128 v38 = *(__n128 *)a1;
        __n128 v39 = *(__n128 *)(a1 + 16);
        __n128 v40 = *(__n128 *)(a1 + 32);
        __n128 v41 = *(__n128 *)(a1 + 48);
        long long v25 = (_OWORD *)a1;
        do
        {
          long long v26 = (__n128 *)&v25[4 * v24 + 4];
          uint64_t v27 = (2 * v24) | 1;
          uint64_t v28 = 2 * v24 + 2;
          if (v28 < v23 && (*a4)((__n128 *)&v25[4 * v24 + 4], (__n128 *)&v25[4 * v24 + 8]))
          {
            v26 += 4;
            uint64_t v27 = v28;
          }
          __n128 v29 = *v26;
          __n128 v30 = v26[1];
          __n128 v31 = v26[3];
          _OWORD v25[2] = v26[2];
          v25[3] = v31;
          *long long v25 = v29;
          v25[1] = v30;
          long long v25 = v26;
          uint64_t v24 = v27;
        }
        while (v27 <= (uint64_t)((unint64_t)(v23 - 2) >> 1));
        v7 -= 4;
        if (v26 == v7)
        {
          long double v26[2] = v40;
          v26[3] = v41;
          *long long v26 = v38;
          v26[1] = v39;
        }
        else
        {
          __n128 v32 = *v7;
          __n128 v33 = v7[1];
          __n128 v34 = v7[3];
          long double v26[2] = v7[2];
          v26[3] = v34;
          *long long v26 = v32;
          v26[1] = v33;
          *long long v7 = v38;
          v7[1] = v39;
          void v7[2] = v40;
          v7[3] = v41;
          std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*>(a1, (uint64_t)&v26[4], (uint64_t (**)(long long *, long long *))a4, ((uint64_t)&v26[4] - a1) >> 6);
        }
      }
      while (v23-- > 2);
      return v37;
    }
  }
  return a3;
}

__n128 std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*>(uint64_t a1, unsigned int (**a2)(__n128 *, __n128 *), uint64_t a3, __n128 *a4)
{
  unint64_t v6 = a3 - 2;
  if (a3 >= 2)
  {
    uint64_t v31 = v4;
    uint64_t v32 = v5;
    long long v7 = a4;
    int64_t v9 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) >= ((uint64_t)a4 - a1) >> 6)
    {
      uint64_t v12 = ((uint64_t)a4 - a1) >> 5;
      uint64_t v13 = v12 + 1;
      long long v14 = (__n128 *)(a1 + ((v12 + 1) << 6));
      uint64_t v15 = v12 + 2;
      if (v12 + 2 < a3 && (*a2)(v14, v14 + 4))
      {
        v14 += 4;
        uint64_t v13 = v15;
      }
      if ((((uint64_t (*)(__n128 *, __n128 *))*a2)(v14, v7) & 1) == 0)
      {
        __n128 v17 = v7[1];
        __n128 v27 = *v7;
        __n128 v28 = v17;
        __n128 v18 = v7[3];
        __n128 v29 = v7[2];
        __n128 v30 = v18;
        do
        {
          __n128 v19 = v14;
          __n128 v20 = *v14;
          __n128 v21 = v14[1];
          __n128 v22 = v14[3];
          void v7[2] = v14[2];
          v7[3] = v22;
          *long long v7 = v20;
          v7[1] = v21;
          if (v9 < v13) {
            break;
          }
          uint64_t v23 = (2 * v13) | 1;
          long long v14 = (__n128 *)(a1 + (v23 << 6));
          uint64_t v24 = 2 * v13 + 2;
          if (v24 < a3)
          {
            if ((*a2)((__n128 *)(a1 + (v23 << 6)), v14 + 4))
            {
              v14 += 4;
              uint64_t v23 = v24;
            }
          }
          long long v7 = v19;
          uint64_t v13 = v23;
        }
        while (!(*a2)(v14, &v27));
        __n128 result = v27;
        __n128 v25 = v28;
        __n128 v26 = v30;
        _OWORD v19[2] = v29;
        v19[3] = v26;
        *__n128 v19 = result;
        v19[1] = v25;
      }
    }
  }
  return result;
}

double std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*>(uint64_t a1, uint64_t a2, uint64_t (**a3)(long long *, long long *), uint64_t a4)
{
  unint64_t v6 = a4 - 2;
  if (a4 >= 2)
  {
    uint64_t v25 = v4;
    uint64_t v26 = v5;
    unint64_t v9 = v6 >> 1;
    uint64_t v10 = (long long *)(a1 + (v6 >> 1 << 6));
    unint64_t v11 = (long long *)(a2 - 64);
    if ((*a3)(v10, (long long *)(a2 - 64)))
    {
      long long v13 = v11[1];
      long long v21 = *v11;
      long long v22 = v13;
      long long v14 = v11[3];
      long long v23 = v11[2];
      long long v24 = v14;
      do
      {
        uint64_t v15 = v10;
        long long v16 = *v10;
        long long v17 = v10[1];
        long long v18 = v10[3];
        void v11[2] = v10[2];
        void v11[3] = v18;
        long long *v11 = v16;
        v11[1] = v17;
        if (!v9) {
          break;
        }
        unint64_t v9 = (v9 - 1) >> 1;
        uint64_t v10 = (long long *)(a1 + (v9 << 6));
        unint64_t v11 = v15;
      }
      while (((*a3)(v10, &v21) & 1) != 0);
      long long v19 = v22;
      *uint64_t v15 = v21;
      v15[1] = v19;
      double result = *(double *)&v23;
      long long v20 = v24;
      _OWORD v15[2] = v23;
      _OWORD v15[3] = v20;
    }
  }
  return result;
}

char *std::vector<TSWPLFCharIndexData>::__assign_with_size[abi:ne180100]<TSWPLFCharIndexData*,TSWPLFCharIndexData*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  long long v7 = result;
  uint64_t v8 = *((void *)result + 2);
  unint64_t v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 6)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *long long v7 = 0;
      v7[1] = 0;
      void v7[2] = 0;
    }
    if (a4 >> 58) {
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 5;
    if (v8 >> 5 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFC0) {
      unint64_t v11 = 0x3FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    double result = std::vector<TSWPLFCharIndexData>::__vallocate[abi:ne180100](v7, v11);
    long long v13 = (char *)v7[1];
    uint64_t v12 = (void **)(v7 + 1);
    unint64_t v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      long long v18 = v9;
      long long v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  uint64_t v12 = (void **)(result + 8);
  long long v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 6;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  long long v16 = &__src[64 * v15];
  if (v14 != v9)
  {
    double result = (char *)memmove(*(void **)result, __src, v14 - v9);
    unint64_t v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    long long v18 = v9;
    long long v19 = v16;
LABEL_18:
    double result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *uint64_t v12 = &v9[v17];
  return result;
}

char *std::vector<TSWPLFCharIndexData>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 58) {
    std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
  }
  double result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TSWPLFCharIndexData>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[64 * v4];
  return result;
}

void *std::vector<TSWPLFCharIndexData>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  uint64_t v5 = *(void **)(a2 + 8);
  unint64_t v6 = (char *)*a1;
  long long v7 = v5;
  if (*a1 != __src)
  {
    uint64_t v8 = __src;
    uint64_t v9 = *(void *)(a2 + 8);
    do
    {
      long long v10 = *((_OWORD *)v8 - 4);
      long long v11 = *((_OWORD *)v8 - 3);
      long long v12 = *((_OWORD *)v8 - 1);
      long long v7 = (void *)(v9 - 64);
      *(_OWORD *)(v9 - 32) = *((_OWORD *)v8 - 2);
      *(_OWORD *)(v9 - 16) = v12;
      *(_OWORD *)(v9 - 64) = v10;
      *(_OWORD *)(v9 - 48) = v11;
      v8 -= 64;
      v9 -= 64;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  long long v13 = a1[1];
  uint64_t v14 = *(void *)(a2 + 16);
  int64_t v15 = v13 - __src;
  if (v13 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v13 - __src);
    long long v7 = *(void **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v14 + v15;
  long long v16 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v16;
  size_t v17 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v17;
  long long v18 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v18;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

void std::vector<TSWPLineRef>::__assign_with_size[abi:ne180100]<TSWPLineRef*,TSWPLineRef*>(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = a1 + 16;
  uint64_t v9 = *(CFTypeRef **)a1;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4) < a4)
  {
    std::vector<TSWPLineRef>::__vdeallocate((CFTypeRef **)a1);
    if (a4 > 0x555555555555555) {
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0x5555555555555556 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4);
    if (v10 <= a4) {
      unint64_t v10 = a4;
    }
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v11 = 0x555555555555555;
    }
    else {
      unint64_t v11 = v10;
    }
    std::vector<TSWPLineRef>::__vallocate[abi:ne180100]((void *)a1, v11);
    uint64_t v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<TSWPLineRef>,TSWPLineRef*,TSWPLineRef*,TSWPLineRef*>(v8, a2, a3, *(void *)(a1 + 8));
    goto LABEL_11;
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 4) < a4)
  {
    uint64_t v13 = a2 + 16 * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 4);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<TSWPLineRef *,TSWPLineRef *,TSWPLineRef *>((uint64_t)&v17, a2, v13, (uint64_t)v9);
    uint64_t v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<TSWPLineRef>,TSWPLineRef*,TSWPLineRef*,TSWPLineRef*>(v8, v13, a3, *(void *)(a1 + 8));
LABEL_11:
    *(void *)(a1 + 8) = v12;
    return;
  }
  std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<TSWPLineRef *,TSWPLineRef *,TSWPLineRef *>((uint64_t)&v18, a2, a3, (uint64_t)v9);
  int64_t v15 = v14;
  long long v16 = *(CFTypeRef **)(a1 + 8);
  if (v16 != v14)
  {
    do
    {
      v16 -= 6;
      std::allocator<TSWPLineRef>::destroy[abi:ne180100](v8, v16);
    }
    while (v16 != v15);
  }
  *(void *)(a1 + 8) = v15;
}

void sub_223721E88(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_223721E90(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<TSWPLineRef>,TSWPLineRef*,TSWPLineRef*,TSWPLineRef*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v11 = a4;
  uint64_t v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  void v9[2] = &v12;
  char v10 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      long long v7 = *(const void **)v6;
      *(void *)uint64_t v4 = *(void *)v6;
      *(_OWORD *)(v4 + 8) = *(_OWORD *)(v6 + 8);
      *(_OWORD *)(v4 + 24) = *(_OWORD *)(v6 + 24);
      *(_DWORD *)(v4 + 40) = *(_DWORD *)(v6 + 40);
      if (v7)
      {
        CFRetain(v7);
        uint64_t v4 = v12;
      }
      v4 += 48;
      uint64_t v12 = v4;
      v6 += 48;
    }
    while (v6 != a3);
  }
  char v10 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TSWPLineRef>,TSWPLineRef*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v9);
  return v4;
}

void sub_223721F44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TSWPLineRef>,TSWPLineRef*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<TSWPLineRef>,TSWPLineRef*>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<TSWPLineRef>,TSWPLineRef*>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = (CFTypeRef **)a1[1];
  uint64_t v1 = (CFTypeRef **)a1[2];
  uint64_t v3 = *v1;
  uint64_t v4 = *v2;
  if (*v1 != *v2)
  {
    uint64_t v5 = *a1;
    do
    {
      v3 -= 6;
      std::allocator<TSWPLineRef>::destroy[abi:ne180100](v5, v3);
    }
    while (v3 != v4);
  }
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<TSWPLineRef *,TSWPLineRef *,TSWPLineRef *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  do
  {
    if (*(void *)v5) {
      CFRetain(*(CFTypeRef *)v5);
    }
    if (*(void *)a4) {
      CFRelease(*(CFTypeRef *)a4);
    }
    *(void *)a4 = *(void *)v5;
    *(_DWORD *)(a4 + 40) = *(_DWORD *)(v5 + 40);
    *(_OWORD *)(a4 + 8) = *(_OWORD *)(v5 + 8);
    *(_OWORD *)(a4 + 24) = *(_OWORD *)(v5 + 24);
    a4 += 48;
    v5 += 48;
  }
  while (v5 != v6);
  return v6;
}

uint64_t compareHyperlinkRangeValues(void *a1, void *a2)
{
  unint64_t v3 = objc_msgSend((id)objc_msgSend(a1, "objectForKeyedSubscript:", kTSWPDataDetectorRangeKey), "rangeValue");
  unint64_t v4 = objc_msgSend((id)objc_msgSend(a2, "objectForKeyedSubscript:", kTSWPDataDetectorRangeKey), "rangeValue");
  if (v3 < v4) {
    return -1;
  }
  else {
    return v3 > v4;
  }
}

__CFString *NSStringFromTSWPSelectionType(uint64_t a1)
{
  if (a1 < 8) {
    return off_2646B2AA0[(int)a1];
  }
  unint64_t v3 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
  uint64_t v4 = [NSString stringWithUTF8String:"NSString *NSStringFromTSWPSelectionType(TSWPSelectionType)"];
  objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPSelection.mm"), 53, @"Unknown selection type: %d", a1);
  return @"<UNKNOWN SELECTION TYPE>";
}

void sub_223727134(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)(v1 - 120);
  if (v3)
  {
    *(void *)(v1 - 112) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_223728170(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  TSWPAttributeEnumerator::~TSWPAttributeEnumerator((TSWPAttributeEnumerator *)va);
  _Unwind_Resume(a1);
}

void sub_2237294A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 96), 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__21(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__21(uint64_t a1)
{
}

void sub_22372A11C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_22372AC20(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_22372B0AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

int *polygonFromRect(CGRect a1)
{
  CGFloat height = a1.size.height;
  CGFloat width = a1.size.width;
  CGFloat y = a1.origin.y;
  CGFloat x = a1.origin.x;
  v17[8] = *MEMORY[0x263EF8340];
  uint64_t v5 = (int *)malloc_type_calloc(1uLL, 0x18uLL, 0x1030040B05087B7uLL);
  int v15 = 4;
  long long v16 = v17;
  v18.origin.CGFloat x = x;
  v18.origin.CGFloat y = y;
  v18.size.CGFloat width = width;
  v18.size.CGFloat height = height;
  CGFloat MinX = CGRectGetMinX(v18);
  v19.origin.CGFloat x = x;
  v19.origin.CGFloat y = y;
  v19.size.CGFloat width = width;
  v19.size.CGFloat height = height;
  CGFloat MinY = CGRectGetMinY(v19);
  *(CGFloat *)char v17 = MinX;
  *(CGFloat *)&v17[1] = MinY;
  v20.origin.CGFloat x = x;
  v20.origin.CGFloat y = y;
  v20.size.CGFloat width = width;
  v20.size.CGFloat height = height;
  CGFloat MaxX = CGRectGetMaxX(v20);
  v21.origin.CGFloat x = x;
  v21.origin.CGFloat y = y;
  v21.size.CGFloat width = width;
  v21.size.CGFloat height = height;
  CGFloat v9 = CGRectGetMinY(v21);
  *(CGFloat *)&_OWORD v17[2] = MaxX;
  *(CGFloat *)&void v17[3] = v9;
  v22.origin.CGFloat x = x;
  v22.origin.CGFloat y = y;
  v22.size.CGFloat width = width;
  v22.size.CGFloat height = height;
  CGFloat v10 = CGRectGetMaxX(v22);
  v23.origin.CGFloat x = x;
  v23.origin.CGFloat y = y;
  v23.size.CGFloat width = width;
  v23.size.CGFloat height = height;
  CGFloat MaxY = CGRectGetMaxY(v23);
  *(CGFloat *)&_OWORD v17[4] = v10;
  *(CGFloat *)&v17[5] = MaxY;
  v24.origin.CGFloat x = x;
  v24.origin.CGFloat y = y;
  v24.size.CGFloat width = width;
  v24.size.CGFloat height = height;
  CGFloat v12 = CGRectGetMinX(v24);
  v25.origin.CGFloat x = x;
  v25.origin.CGFloat y = y;
  v25.size.CGFloat width = width;
  v25.size.CGFloat height = height;
  CGFloat v13 = CGRectGetMaxY(v25);
  *(CGFloat *)&v17[6] = v12;
  *(CGFloat *)&double v17[7] = v13;
  TSDgpc_add_contour(v5, &v15, 0);
  return v5;
}

uint64_t compareRects(objc_object *a1, objc_object *a2, void *a3)
{
  [(objc_object *)a1 CGRectValue];
  CGFloat v5 = v4;
  CGFloat v7 = v6;
  CGFloat v9 = v8;
  CGFloat v11 = v10;
  [(objc_object *)a2 CGRectValue];
  CGFloat v13 = v12;
  CGFloat v15 = v14;
  CGFloat v17 = v16;
  CGFloat v19 = v18;
  CGFloat rect = v5;
  v24.origin.CGFloat x = v5;
  v24.origin.CGFloat y = v7;
  v24.size.CGFloat width = v9;
  v24.size.CGFloat height = v11;
  double MinX = CGRectGetMinX(v24);
  v25.origin.CGFloat x = v13;
  v25.origin.CGFloat y = v15;
  v25.size.CGFloat width = v17;
  v25.size.CGFloat height = v19;
  if (MinX < CGRectGetMinX(v25)) {
    return -1;
  }
  v26.origin.CGFloat x = rect;
  v26.origin.CGFloat y = v7;
  v26.size.CGFloat width = v9;
  v26.size.CGFloat height = v11;
  double v22 = CGRectGetMinX(v26);
  v27.origin.CGFloat x = v13;
  v27.origin.CGFloat y = v15;
  v27.size.CGFloat width = v17;
  v27.size.CGFloat height = v19;
  return v22 > CGRectGetMinX(v27);
}

uint64_t TSWPOverlapsRectHorizontally(CGRect a1, CGRect a2)
{
  uint64_t result = 0;
  if (a1.size.width > 0.0 && a2.size.width > 0.0)
  {
    if (a1.origin.x >= a2.origin.x)
    {
      if (a2.origin.x + a2.size.width <= a1.origin.x) {
        return 0;
      }
    }
    else if (a1.origin.x + a1.size.width <= a2.origin.x)
    {
      return 0;
    }
    return 1;
  }
  return result;
}

void *mergeRects(NSArray *a1)
{
  uint64_t v2 = (void *)[MEMORY[0x263EFF980] array];
  unint64_t v3 = [(NSArray *)a1 objectEnumerator];
  id v4 = [(NSEnumerator *)v3 nextObject];
  if (v4)
  {
    [v4 CGRectValue];
    double v6 = v5;
    double v8 = v7;
    double v10 = v9;
    double v12 = v11;
    while (1)
    {
      do
      {
        id v13 = [(NSEnumerator *)v3 nextObject];
        if (!v13)
        {
          objc_msgSend(v2, "addObject:", objc_msgSend(MEMORY[0x263F08D40], "valueWithCGRect:", v6, v8, v10, v12));
          return v2;
        }
        [v13 CGRectValue];
        double x = v19.origin.x;
        CGFloat y = v19.origin.y;
        double width = v19.size.width;
        CGFloat height = v19.size.height;
      }
      while (CGRectGetWidth(v19) == 0.0);
      if (width <= 0.0 || v10 <= 0.0) {
        goto LABEL_9;
      }
      if (x >= v6)
      {
        if (v6 + v10 > x) {
          goto LABEL_11;
        }
LABEL_9:
        objc_msgSend(v2, "addObject:", objc_msgSend(MEMORY[0x263F08D40], "valueWithCGRect:", v6, v8, v10, v12));
        double v6 = x;
        double v8 = y;
        double v10 = width;
        double v12 = height;
      }
      else
      {
        if (x + width <= v6) {
          goto LABEL_9;
        }
LABEL_11:
        v20.origin.double x = x;
        v20.origin.CGFloat y = y;
        v20.size.double width = width;
        v20.size.CGFloat height = height;
        v22.origin.double x = v6;
        v22.origin.CGFloat y = v8;
        v22.size.double width = v10;
        v22.size.CGFloat height = v12;
        CGRect v21 = CGRectUnion(v20, v22);
        double v6 = v21.origin.x;
        double v8 = v21.origin.y;
        double v10 = v21.size.width;
        double v12 = v21.size.height;
      }
    }
  }
  return v2;
}

unint64_t wrappedSubrectsFromPolygon(int *a1, double *a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  double v12 = (NSArray *)[MEMORY[0x263EFF980] array];
  if (*a1 >= 1)
  {
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    do
    {
      -[NSArray addObject:](v12, "addObject:", [MEMORY[0x263F08D40] valueWithCGRect:boundsForVertexList(*((void *)a1 + 2) + v13)]);
      ++v14;
      v13 += 16;
    }
    while (v14 < *a1);
  }
  [(NSArray *)v12 sortUsingFunction:compareRects context:0];
  CGFloat v15 = mergeRects(v12);
  uint64_t v16 = [v15 count];
  if (!v16)
  {
    *a2 = a3;
    a2[1] = a4;
    unint64_t v26 = 1;
    a2[2] = a5;
    a2[3] = a6;
    return v26;
  }
  size_t v17 = v16;
  double v18 = (void *)[v15 objectEnumerator];
  CGRect v19 = (double *)malloc_type_calloc(v17, 0x10uLL, 0x1000040451B5BE8uLL);
  CGRect v20 = (void *)[v18 nextObject];
  if (v20)
  {
    CGRect v21 = v19 + 1;
    do
    {
      [v20 CGRectValue];
      CGFloat x = v45.origin.x;
      CGFloat y = v45.origin.y;
      CGFloat width = v45.size.width;
      CGFloat height = v45.size.height;
      *(v21 - 1) = CGRectGetMinX(v45);
      v46.origin.CGFloat x = x;
      v46.origin.CGFloat y = y;
      v46.size.CGFloat width = width;
      v46.size.CGFloat height = height;
      *CGRect v21 = CGRectGetMaxX(v46);
      v21 += 2;
      CGRect v20 = (void *)[v18 nextObject];
    }
    while (v20);
  }
  unint64_t v26 = 0;
  CGRect v27 = v19 - 1;
  unint64_t v28 = 1;
  do
  {
    if (v28 != 1)
    {
      CGFloat MinX = *v27;
      v51.origin.CGFloat x = a3;
      v51.origin.CGFloat y = a4;
      v51.size.CGFloat width = a5;
      v51.size.CGFloat height = a6;
      CGFloat MinY = CGRectGetMinY(v51);
      double v33 = v27[1] - *v27;
      goto LABEL_13;
    }
    double v29 = *v19;
    v47.origin.CGFloat x = a3;
    v47.origin.CGFloat y = a4;
    v47.size.CGFloat width = a5;
    v47.size.CGFloat height = a6;
    if (v29 > CGRectGetMinX(v47))
    {
      v48.origin.CGFloat x = a3;
      v48.origin.CGFloat y = a4;
      v48.size.CGFloat width = a5;
      v48.size.CGFloat height = a6;
      CGFloat MinX = CGRectGetMinX(v48);
      v49.origin.CGFloat x = a3;
      v49.origin.CGFloat y = a4;
      v49.size.CGFloat width = a5;
      v49.size.CGFloat height = a6;
      CGFloat MinY = CGRectGetMinY(v49);
      double v32 = *v19;
      v50.origin.CGFloat x = a3;
      v50.origin.CGFloat y = a4;
      v50.size.CGFloat width = a5;
      v50.size.CGFloat height = a6;
      double v33 = v32 - CGRectGetMinX(v50);
LABEL_13:
      v52.origin.CGFloat x = a3;
      v52.origin.CGFloat y = a4;
      v52.size.CGFloat width = a5;
      v52.size.CGFloat height = a6;
      CGFloat v34 = CGRectGetHeight(v52);
      long long v35 = &a2[4 * v26];
      *long long v35 = MinX;
      v35[1] = MinY;
      ++v26;
      v35[2] = v33;
      void v35[3] = v34;
    }
    if (v28 >= v17) {
      break;
    }
    ++v28;
    v27 += 2;
  }
  while (v26 < 0x80);
  long long v36 = &v19[2 * v17];
  double v38 = *(v36 - 1);
  long long v37 = v36 - 1;
  v53.origin.CGFloat x = a3;
  v53.origin.CGFloat y = a4;
  v53.size.CGFloat width = a5;
  v53.size.CGFloat height = a6;
  if (v38 < CGRectGetMaxX(v53) && v26 < 0x80)
  {
    double v39 = *v37;
    v54.origin.CGFloat x = a3;
    v54.origin.CGFloat y = a4;
    v54.size.CGFloat width = a5;
    v54.size.CGFloat height = a6;
    CGFloat v40 = CGRectGetMinY(v54);
    v55.origin.CGFloat x = a3;
    v55.origin.CGFloat y = a4;
    v55.size.CGFloat width = a5;
    v55.size.CGFloat height = a6;
    CGFloat v41 = CGRectGetMaxX(v55) - *v37;
    v56.origin.CGFloat x = a3;
    v56.origin.CGFloat y = a4;
    v56.size.CGFloat width = a5;
    v56.size.CGFloat height = a6;
    CGFloat v42 = CGRectGetHeight(v56);
    CFRange v43 = &a2[4 * v26];
    *CFRange v43 = v39;
    v43[1] = v40;
    ++v26;
    v43[2] = v41;
    v43[3] = v42;
  }
  free(v19);
  return v26;
}

CGFloat xIntersection(double a1, CGPoint a2, CGPoint a3)
{
  return a3.x + (a1 - a3.y) / (a2.y - a3.y) * (a2.x - a3.x);
}

uint64_t TSWPTextWrapMarkerCompare(double *a1, double *a2)
{
  double v2 = a1[1];
  double v3 = a2[1];
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v2 > v3;
  }
}

void sub_22372E618(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, TSWPParagraphEnumerator *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
}

void sub_223730C94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_223730EC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_223731034(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_223731F38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,void *__p,uint64_t a51)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_2237333F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_223733498(_Unwind_Exception *exception_object)
{
  double v3 = *(void **)(v1 - 40);
  if (v3)
  {
    *(void *)(v1 - 32) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void TSWPDrawingState::~TSWPDrawingState(TSWPDrawingState *this)
{
  double v2 = (void *)*((void *)this + 15);
  if (v2)
  {
    *((void *)this + 16) = v2;
    operator delete(v2);
  }
  double v3 = (void *)*((void *)this + 12);
  if (v3)
  {
    *((void *)this + 13) = v3;
    operator delete(v3);
  }
}

void std::__shared_ptr_pointer<TSWPLineFragmentArray *,std::shared_ptr<TSWPLineFragmentArray>::__shared_ptr_default_delete<TSWPLineFragmentArray,TSWPLineFragmentArray>,std::allocator<TSWPLineFragmentArray>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223CB8F20);
}

void std::allocator<TSWPAdornmentRect>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
}

__n128 std::vector<TSWPAdornmentRect>::__construct_one_at_end[abi:ne180100]<TSWPAdornmentRect const&>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  *(_DWORD *)uint64_t v4 = *(_DWORD *)a2;
  *(void *)(v4 + 8) = *(id *)(a2 + 8);
  *(void *)(v4 + 16) = *(id *)(a2 + 16);
  __n128 result = *(__n128 *)(a2 + 24);
  *(_OWORD *)(v4 + 40) = *(_OWORD *)(a2 + 40);
  *(__n128 *)(v4 + 24) = result;
  *(void *)(a1 + 8) = v4 + 56;
  return result;
}

void sub_223733770(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<TSWPAdornmentRect>::__push_back_slow_path<TSWPAdornmentRect const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x492492492492492) {
    std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x6DB6DB6DB6DB6DB7 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x249249249249249) {
    unint64_t v9 = 0x492492492492492;
  }
  else {
    unint64_t v9 = v5;
  }
  CGRect v20 = a1 + 2;
  if (v9) {
    double v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TSWPAdornmentRect>>(v7, v9);
  }
  else {
    double v10 = 0;
  }
  uint64_t v16 = v10;
  size_t v17 = &v10[56 * v4];
  double v18 = v17;
  CGRect v19 = &v10[56 * v9];
  *(_DWORD *)size_t v17 = *(_DWORD *)a2;
  *(void *)&v10[56 * v4 + 8] = *(id *)(a2 + 8);
  id v11 = *(id *)(a2 + 16);
  double v12 = &v10[56 * v4];
  *((void *)v12 + 2) = v11;
  long long v13 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(v12 + 40) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(v12 + 24) = v13;
  v18 += 56;
  std::vector<TSWPAdornmentRect>::__swap_out_circular_buffer(a1, &v16);
  uint64_t v14 = a1[1];
  std::__split_buffer<TSWPAdornmentRect>::~__split_buffer(&v16);
  return v14;
}

void sub_2237338BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TSWPAdornmentRect>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<TSWPAdornmentRect>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<TSWPAdornmentRect>,std::reverse_iterator<TSWPAdornmentRect*>,std::reverse_iterator<TSWPAdornmentRect*>,std::reverse_iterator<TSWPAdornmentRect*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<TSWPAdornmentRect>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x492492492492493) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(56 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<TSWPAdornmentRect>,std::reverse_iterator<TSWPAdornmentRect*>,std::reverse_iterator<TSWPAdornmentRect*>,std::reverse_iterator<TSWPAdornmentRect*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v18 = a6;
  *((void *)&v18 + 1) = a7;
  long long v17 = v18;
  v15[0] = a1;
  v15[1] = &v17;
  _OWORD v15[2] = &v18;
  char v16 = 0;
  if (a3 == a5)
  {
    uint64_t v13 = a6;
  }
  else
  {
    uint64_t v9 = a3;
    uint64_t v10 = a3;
    do
    {
      int v11 = *(_DWORD *)(v10 - 56);
      v10 -= 56;
      *(_DWORD *)(v7 - 56) = v11;
      *(void *)(v7 - 48) = *(id *)(v10 + 8);
      *(void *)(v7 - 40) = *(id *)(v9 - 40);
      long long v12 = *(_OWORD *)(v9 - 16);
      *(_OWORD *)(v7 - 32) = *(_OWORD *)(v9 - 32);
      *(_OWORD *)(v7 - 16) = v12;
      uint64_t v7 = *((void *)&v18 + 1) - 56;
      *((void *)&v18 + 1) -= 56;
      uint64_t v9 = v10;
    }
    while (v10 != a5);
    uint64_t v13 = v18;
  }
  char v16 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TSWPAdornmentRect>,std::reverse_iterator<TSWPAdornmentRect*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v15);
  return v13;
}

void sub_223733A5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TSWPAdornmentRect>,std::reverse_iterator<TSWPAdornmentRect*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<TSWPAdornmentRect>,std::reverse_iterator<TSWPAdornmentRect*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<TSWPAdornmentRect>,std::reverse_iterator<TSWPAdornmentRect*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1 = *(void *)(a1[2] + 8);
  uint64_t v2 = *(void *)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      std::allocator<TSWPAdornmentRect>::destroy[abi:ne180100](v3, v1);
      v1 += 56;
    }
    while (v1 != v2);
  }
}

void **std::__split_buffer<TSWPAdornmentRect>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<TSWPAdornmentRect>::clear[abi:ne180100](void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 56;
    std::allocator<TSWPAdornmentRect>::destroy[abi:ne180100](v4, i - 56);
  }
}

char *std::vector<CGRect>::__insert_with_size[abi:ne180100]<std::__wrap_iter<CGRect*>,std::__wrap_iter<CGRect*>>(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  uint64_t v5 = (char *)__dst;
  if (a5 < 1) {
    return v5;
  }
  uint64_t v7 = __src;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v9 = a1 + 16;
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 5)
  {
    uint64_t v13 = *(void **)a1;
    unint64_t v14 = a5 + ((uint64_t)(v12 - *(void *)a1) >> 5);
    if (v14 >> 59) {
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = (__dst - (uint64_t)v13) >> 5;
    uint64_t v16 = v10 - (void)v13;
    if (v16 >> 4 > v14) {
      unint64_t v14 = v16 >> 4;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v17 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v14;
    }
    uint64_t v39 = v9;
    if (v17) {
      long long v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::segment_data<double>>>(v9, v17);
    }
    else {
      long long v18 = 0;
    }
    double v29 = &v18[32 * v15];
    __p = v18;
    long long v36 = v29;
    double v38 = &v18[32 * v17];
    uint64_t v30 = 32 * a5;
    uint64_t v31 = &v29[32 * a5];
    do
    {
      long long v32 = *(_OWORD *)v7;
      long long v33 = *((_OWORD *)v7 + 1);
      v7 += 32;
      *(_OWORD *)double v29 = v32;
      *((_OWORD *)v29 + 1) = v33;
      v29 += 32;
      v30 -= 32;
    }
    while (v30);
    long long v37 = v31;
    uint64_t v5 = (char *)std::vector<CGRect>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v5);
    if (v37 != v36) {
      v37 += (v36 - v37 + 31) & 0xFFFFFFFFFFFFFFE0;
    }
    if (__p) {
      operator delete(__p);
    }
    return v5;
  }
  uint64_t v19 = v12 - __dst;
  uint64_t v20 = (uint64_t)(v12 - __dst) >> 5;
  if (v20 >= a5)
  {
    CGRect v21 = &__src[32 * a5];
    CGRect v23 = *(char **)(v9 - 8);
LABEL_17:
    CGRect v24 = &v5[32 * a5];
    CGRect v25 = &v23[-32 * a5];
    unint64_t v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      unint64_t v26 = v23;
      do
      {
        long long v27 = *(_OWORD *)v25;
        long long v28 = *((_OWORD *)v25 + 1);
        v25 += 32;
        *(_OWORD *)unint64_t v26 = v27;
        *((_OWORD *)v26 + 1) = v28;
        v26 += 32;
      }
      while ((unint64_t)v25 < v12);
    }
    *(void *)(a1 + 8) = v26;
    if (v23 != v24) {
      memmove(&v23[-32 * ((v23 - v24) >> 5)], v5, v23 - v24);
    }
    if (v21 != v7) {
      memmove(v5, v7, v21 - v7);
    }
    return v5;
  }
  CGRect v21 = &__src[32 * v20];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    memmove(*(void **)(v9 - 8), &__src[32 * v20], a4 - v21);
  }
  CGRect v23 = (char *)(v12 + v22);
  *(void *)(a1 + 8) = v12 + v22;
  if (v19 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

void sub_223733D50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<CGRect>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  uint64_t v5 = *(void **)(a2 + 8);
  uint64_t v6 = (char *)*a1;
  uint64_t v7 = v5;
  if (*a1 != __src)
  {
    uint64_t v8 = __src;
    uint64_t v9 = *(void *)(a2 + 8);
    do
    {
      long long v10 = *((_OWORD *)v8 - 1);
      uint64_t v7 = (void *)(v9 - 32);
      *(_OWORD *)(v9 - 32) = *((_OWORD *)v8 - 2);
      *(_OWORD *)(v9 - 16) = v10;
      v8 -= 32;
      v9 -= 32;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  uint64_t v11 = a1[1];
  uint64_t v12 = *(void *)(a2 + 16);
  int64_t v13 = v11 - __src;
  if (v11 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v11 - __src);
    uint64_t v7 = *(void **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v12 + v13;
  unint64_t v14 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v14;
  uint64_t v15 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v15;
  uint64_t v16 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v16;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

BOOL attributeCompareFunction(const TSWPAttributeRecord *a1, unint64_t a2)
{
  return *(void *)a1 < a2;
}

void TSWPAttributeArray::~TSWPAttributeArray(TSWPAttributeArray *this)
{
  this->id var0 = (void **)&unk_26D687880;
  free(this->var4);
}

TSWPAttributeArray *TSWPAttributeArray::setCapacity(TSWPAttributeArray *this, unint64_t a2)
{
  if (this->var2 < a2)
  {
    uint64_t v2 = this;
    this->unint64_t var3 = a2;
    this = (TSWPAttributeArray *)malloc_type_realloc(this->var4, 16 * a2, 0x10820408DE112D3uLL);
    v2->unint64_t var4 = (TSWPAttributeRecord *)this;
  }
  return this;
}

unint64_t TSWPAttributeArray::exactAttributeIndexForCharIndex(TSWPAttributeArray *this, unint64_t a2)
{
  unint64_t v4 = TSWPAttributeArray::effectiveAttributeIndexForCharIndex(this, a2);
  uint64_t v5 = 0x7FFFFFFFFFFFFFFFLL;
  if (v4 != 0x7FFFFFFFFFFFFFFFLL)
  {
    unint64_t v6 = v4;
    if (TSWPAttributeArray::charIndexForAttributeIndex(this, v4) == a2) {
      return v6;
    }
  }
  return v5;
}

void *TSWPAttributeArray::p_deleteAttributes(TSWPAttributeArray *this, unint64_t a2, uint64_t a3, TSWPStorageTransaction *a4)
{
  unint64_t v8 = a3 + a2;
  if (a3 + a2 > this->var2)
  {
    uint64_t v9 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v10 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPAttributeArray::p_deleteAttributes(TSWPAttributeIndex, TSWPAttributeCount, TSWPStorageTransaction *)");
    objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPAttributeArray.mm"), 355, @"deleteAttributes: bad input.");
  }
  if (v8 > a2)
  {
    uint64_t v11 = 16 * a2;
    uint64_t v12 = a3;
    do
    {
      (*((void (**)(TSWPAttributeArray *, char *, TSWPStorageTransaction *))this->var0 + 32))(this, (char *)this->var4 + v11, a4);
      (*((void (**)(TSWPAttributeArray *, char *))this->var0 + 24))(this, (char *)this->var4 + v11);
      v11 += 16;
      --v12;
    }
    while (v12);
  }
  uint64_t result = memmove((char *)this->var4 + 16 * a2, (char *)this->var4 + 16 * v8, 16 * (this->var2 - v8));
  this->var2 -= a3;
  return result;
}

void TSWPAttributeArray::deleteAttributes(TSWPAttributeArray *this, unint64_t a2, unint64_t a3, TSWPStorageTransaction *a4)
{
  unsigned int var1 = this->var1;
  BOOL v9 = var1 > 0x11;
  int v10 = (1 << var1) & 0x38100;
  BOOL v11 = v9 || v10 == 0;
  if (v11 || [this->var5 isDOLCSuppressed])
  {
    TSWPAttributeArray::p_deleteAttributes(this, a2, a3, a4);
  }
  else if (a3 == 1)
  {
    id v28 = (id)*((void *)this->var4 + 2 * a2 + 1);
    id v12 = v28;
    TSWPAttributeArray::p_deleteAttributes(this, a2, 1, a4);
    (*((void (**)(TSWPAttributeArray *, id, TSWPStorageTransaction *))this->var0 + 33))(this, v28, a4);
  }
  else
  {
    double v29 = 0;
    uint64_t v30 = 0;
    uint64_t v31 = 0;
    std::vector<objc_object *>::reserve((void **)&v29, a3);
    if (a3 + a2 > a2)
    {
      unint64_t v13 = a2;
      do
      {
        unint64_t v14 = (void *)*((void *)this->var4 + 2 * v13 + 1);
        if (v14)
        {
          id v15 = v14;
          uint64_t v16 = v30;
          if (v30 >= v31)
          {
            uint64_t v18 = (v30 - v29) >> 3;
            if ((unint64_t)(v18 + 1) >> 61) {
              abort();
            }
            unint64_t v19 = (v31 - v29) >> 2;
            if (v19 <= v18 + 1) {
              unint64_t v19 = v18 + 1;
            }
            if ((unint64_t)(v31 - v29) >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v20 = v19;
            }
            if (v20) {
              CGRect v21 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLayoutContext *>>((uint64_t)&v31, v20);
            }
            else {
              CGRect v21 = 0;
            }
            int64_t v22 = &v21[8 * v18];
            *(void *)int64_t v22 = v14;
            unint64_t v17 = v22 + 8;
            CGRect v24 = v29;
            CGRect v23 = v30;
            if (v30 != v29)
            {
              do
              {
                uint64_t v25 = *((void *)v23 - 1);
                v23 -= 8;
                *((void *)v22 - 1) = v25;
                v22 -= 8;
              }
              while (v23 != v24);
              CGRect v23 = v29;
            }
            double v29 = v22;
            uint64_t v30 = v17;
            uint64_t v31 = &v21[8 * v20];
            if (v23) {
              operator delete(v23);
            }
          }
          else
          {
            *(void *)uint64_t v30 = v14;
            unint64_t v17 = v16 + 8;
          }
          uint64_t v30 = v17;
        }
        ++v13;
      }
      while (v13 != a3 + a2);
    }
    TSWPAttributeArray::p_deleteAttributes(this, a2, a3, a4);
    unint64_t v26 = (id *)v29;
    long long v27 = (id *)v30;
    if (v29 != v30)
    {
      do
      {
        (*((void (**)(TSWPAttributeArray *, id, TSWPStorageTransaction *))this->var0 + 33))(this, *v26, a4);
      }
      while (v26 != v27);
      unint64_t v26 = (id *)v29;
    }
    if (v26)
    {
      uint64_t v30 = (char *)v26;
      operator delete(v26);
    }
  }
}

void sub_2237343A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<objc_object *>::reserve(void **a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 3)
  {
    if (a2 >> 61) {
      abort();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    unint64_t v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLayoutContext *>>(v3, a2);
    uint64_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    BOOL v9 = &v6[8 * v8];
    BOOL v11 = (char *)*a1;
    int v10 = (char *)a1[1];
    id v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        uint64_t v13 = *((void *)v10 - 1);
        v10 -= 8;
        *((void *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v10 != v11);
      int v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

TSWPAttributeArray *TSWPAttributeArray::replaceCharIndexForAttributeIndex(TSWPAttributeArray *this, uint64_t a2, uint64_t a3, TSWPStorageTransaction *a4)
{
  *((void *)this->var4 + 2 * a3) = a2;
  return this;
}

TSWPAttributeArray *TSWPAttributeArray::replaceObjectForAttributeIndexForShallowCopy(TSWPAttributeArray *this, objc_object *a2, uint64_t a3)
{
  uint64_t v3 = (char *)this->var4 + 16 * a3;
  if (*((objc_object **)v3 + 1) != a2)
  {
    int64_t v5 = this;
    (*((void (**)(TSWPAttributeArray *, char *))this->var0 + 24))(this, (char *)this->var4 + 16 * a3);
    *((void *)v3 + 1) = a2;
    unint64_t v6 = (uint64_t (*)(TSWPAttributeArray *, char *))*((void *)v5->var0 + 23);
    return (TSWPAttributeArray *)v6(v5, v3);
  }
  return this;
}

TSWPAttributeArray *TSWPAttributeArray::willBeAddedToDocumentRoot(TSWPAttributeArray *this, TSKDocumentRoot *a2, TSKAddedToDocumentContext *a3)
{
  unsigned int var1 = this->var1;
  BOOL v4 = var1 > 0x11;
  int v5 = (1 << var1) & 0x38100;
  if (!v4 && v5 != 0)
  {
    uint64_t v7 = this;
    unint64_t var2 = this->var2;
    if (var2)
    {
      unint64_t v11 = 0;
      uint64_t v12 = 8;
      do
      {
        this = *(TSWPAttributeArray **)((char *)v7->var4 + v12);
        if (this)
        {
          this = (TSWPAttributeArray *)[(TSWPAttributeArray *)this willBeAddedToDocumentRoot:a2 context:a3];
          unint64_t var2 = v7->var2;
        }
        ++v11;
        v12 += 16;
      }
      while (v11 < var2);
    }
  }
  return this;
}

TSWPAttributeArray *TSWPAttributeArray::wasAddedToDocumentRoot(TSWPAttributeArray *this, TSKDocumentRoot *a2, TSKAddedToDocumentContext *a3)
{
  unsigned int var1 = this->var1;
  BOOL v4 = var1 > 0x11;
  int v5 = (1 << var1) & 0x38100;
  if (!v4 && v5 != 0)
  {
    uint64_t v7 = this;
    unint64_t var2 = this->var2;
    if (var2)
    {
      unint64_t v11 = 0;
      uint64_t v12 = 8;
      do
      {
        this = *(TSWPAttributeArray **)((char *)v7->var4 + v12);
        if (this)
        {
          this = (TSWPAttributeArray *)[(TSWPAttributeArray *)this wasAddedToDocumentRoot:a2 context:a3];
          unint64_t var2 = v7->var2;
        }
        ++v11;
        v12 += 16;
      }
      while (v11 < var2);
    }
  }
  return this;
}

TSWPAttributeArray *TSWPAttributeArray::willBeRemovedFromDocumentRoot(TSWPAttributeArray *this, TSKDocumentRoot *a2)
{
  unsigned int var1 = this->var1;
  BOOL v3 = var1 > 0x11;
  int v4 = (1 << var1) & 0x38100;
  if (!v3 && v4 != 0)
  {
    unint64_t v6 = this;
    unint64_t var2 = this->var2;
    if (var2)
    {
      unint64_t v9 = 0;
      uint64_t v10 = 8;
      do
      {
        this = *(TSWPAttributeArray **)((char *)v6->var4 + v10);
        if (this)
        {
          this = (TSWPAttributeArray *)[(TSWPAttributeArray *)this willBeRemovedFromDocumentRoot:a2];
          unint64_t var2 = v6->var2;
        }
        ++v9;
        v10 += 16;
      }
      while (v9 < var2);
    }
  }
  return this;
}

TSWPAttributeArray *TSWPAttributeArray::wasRemovedFromDocumentRoot(TSWPAttributeArray *this, TSKDocumentRoot *a2)
{
  unsigned int var1 = this->var1;
  BOOL v3 = var1 > 0x11;
  int v4 = (1 << var1) & 0x38100;
  if (!v3 && v4 != 0)
  {
    unint64_t v6 = this;
    unint64_t var2 = this->var2;
    if (var2)
    {
      unint64_t v9 = 0;
      uint64_t v10 = 8;
      do
      {
        this = *(TSWPAttributeArray **)((char *)v6->var4 + v10);
        if (this)
        {
          this = (TSWPAttributeArray *)[(TSWPAttributeArray *)this wasRemovedFromDocumentRoot:a2];
          unint64_t var2 = v6->var2;
        }
        ++v9;
        v10 += 16;
      }
      while (v9 < var2);
    }
  }
  return this;
}

const char *TSWPAttributeArray::className(TSWPAttributeArray *this)
{
  return "TSWPAttributeArray";
}

void *TSWPAttributeArray::description(TSWPAttributeArray *this)
{
  uint64_t v2 = (void *)[MEMORY[0x263F089D8] string];
  unsigned int var1 = this->var1;
  if (var1 >= 0x13) {
    int v4 = (__CFString *)objc_msgSend(NSString, "stringWithFormat:", @"TSWPAttributeArrayKind-%lu", this->var1);
  }
  else {
    int v4 = off_2646B2BD0[var1];
  }
  [v2 appendFormat:@"%s <%p> %@: Count: %lu.\n", (*((uint64_t (**)(TSWPAttributeArray *))this->var0 + 22))(this), this, v4, this->var2];
  if (this->var2)
  {
    unint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      if ((*((unsigned int (**)(TSWPAttributeArray *))this->var0 + 3))(this)) {
        uint64_t v7 = *((void *)this->var4 + 2 * v5 + 1);
      }
      else {
        uint64_t v7 = 0;
      }
      unsigned int v8 = this->var1 - 13;
      uint64_t v9 = TSWPAttributeArray::charIndexForAttributeIndex(this, v5);
      if (v8 >= 2) {
        uint64_t v10 = @"\t%d CharIndex: %lu, Object: %p\n");
      }
      else {
        uint64_t v10 = @"\t%d CharIndex: %lu, Object: %@\n");
      }
      objc_msgSend(v2, "appendFormat:", v10, v6, v9, v7);
      unint64_t v5 = (v6 + 1);
      unint64_t v6 = v5;
    }
    while (this->var2 > v5);
  }
  return v2;
}

uint64_t TSWPAttributeArray::canCollapseAttributes(TSWPAttributeArray *this, const TSWPAttributeRecord *a2, const TSWPAttributeRecord *a3)
{
  return 0;
}

uint64_t TSWPAttributeArray::canCollapseEmptyAttribute(TSWPAttributeArray *this, const TSWPAttributeRecord *a2)
{
  return 0;
}

BOOL TSWPAttributeArray::isEmpty(TSWPAttributeArray *this)
{
  return this->var2 == 0;
}

TSWPAttributeArray *TSWPAttributeArray::enumerateObjectAttributes(TSWPAttributeArray *this, uint64_t a2)
{
  BOOL v3 = this;
  unint64_t v4 = 0;
  char v10 = 0;
  uint64_t v5 = 8;
  do
  {
    if (v4 >= v3->var2) {
      break;
    }
    uint64_t v6 = TSWPAttributeArray::rangeForAttributeIndex(v3, v4);
    uint64_t v8 = v7;
    uint64_t v9 = (*((unsigned int (**)(TSWPAttributeArray *))v3->var0 + 2))(v3) ? v8 : 1;
    this = (TSWPAttributeArray *)(*(uint64_t (**)(uint64_t, void, unint64_t, uint64_t, uint64_t, char *))(a2 + 16))(a2, *(void *)((char *)v3->var4 + v5), v4++, v6, v9, &v10);
    v5 += 16;
  }
  while (!v10);
  return this;
}

unint64_t TSWPAttributeArray::begin@<X0>(TSWPAttributeArray *this@<X0>, const _NSRange *a2@<X1>, TSWPAttributeArray **a3@<X8>)
{
  unint64_t result = TSWPAttributeArray::effectiveAttributeIndexForCharIndex(this, a2->location);
  if (result == 0x7FFFFFFFFFFFFFFFLL) {
    unint64_t v6 = 0;
  }
  else {
    unint64_t v6 = result;
  }
  *a3 = this;
  a3[1] = (TSWPAttributeArray *)v6;
  return result;
}

unint64_t TSWPAttributeArray::end@<X0>(TSWPAttributeArray *this@<X0>, const _NSRange *a2@<X1>, TSWPAttributeArray **a3@<X8>)
{
  NSUInteger v6 = a2->length + a2->location;
  unint64_t result = [this->var5 length];
  if (v6 == result)
  {
    unint64_t var2 = this->var2;
  }
  else
  {
    unint64_t result = TSWPAttributeArray::effectiveAttributeIndexForCharIndex(this, v6 - (a2->length != 0));
    if (result == 0x7FFFFFFFFFFFFFFFLL) {
      unint64_t var2 = 0;
    }
    else {
      unint64_t var2 = result + 1;
    }
  }
  *a3 = this;
  a3[1] = (TSWPAttributeArray *)var2;
  return result;
}

uint64_t TSWPAttributeArray::ownsObjects(TSWPAttributeArray *this)
{
  return (this->var1 > 0x12) | (0x3F7FDu >> this->var1) & 1;
}

uint64_t TSWPAttributeArray::allowsNilObjects(TSWPAttributeArray *this)
{
  return 1;
}

uint64_t TSWPAttributeArray::supportsAttributeCollapsing(TSWPAttributeArray *this)
{
  return 0;
}

void sub_223736088(_Unwind_Exception *a1)
{
  CGColorRelease(v1);
  _Unwind_Resume(a1);
}

void sub_223736344(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  std::__list_imp<TSWPRepBoundsAnalyzer::Span>::clear((uint64_t *)va);
  _Unwind_Resume(a1);
}

void TSWPRepBoundsAnalyzer::addSingleColorBounds(TSWPRepBoundsAnalyzer *this, CGColor *a2, CGRect a3)
{
  CGFloat height = a3.size.height;
  CGFloat width = a3.size.width;
  CGFloat y = a3.origin.y;
  CGFloat x = a3.origin.x;
  double v9 = floor(CGRectGetMinY(a3));
  v13.origin.CGFloat x = x;
  v13.origin.CGFloat y = y;
  v13.size.CGFloat width = width;
  v13.size.CGFloat height = height;
  *(double *)char v10 = v9;
  v10[1] = ceil(CGRectGetMaxY(v13));
  CGColorRef color = CGColorRetain(a2);
  char v12 = 0;
  TSWPRepBoundsAnalyzer::insertSpan((uint64_t)this, (uint64_t)v10);
  CGColorRelease(color);
}

void sub_223736428(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CGColorRef color)
{
}

void TSWPRepBoundsAnalyzer::addMultipleColorBounds(TSWPRepBoundsAnalyzer *this, CGRect a2)
{
  CGFloat height = a2.size.height;
  CGFloat width = a2.size.width;
  CGFloat y = a2.origin.y;
  CGFloat x = a2.origin.x;
  double v7 = floor(CGRectGetMinY(a2));
  v11.origin.CGFloat x = x;
  v11.origin.CGFloat y = y;
  v11.size.CGFloat width = width;
  v11.size.CGFloat height = height;
  *(double *)uint64_t v8 = v7;
  v8[1] = ceil(CGRectGetMaxY(v11));
  CGColorRef color = CGColorRetain(0);
  char v10 = 0;
  TSWPRepBoundsAnalyzer::insertSpan((uint64_t)this, (uint64_t)v8);
  CGColorRelease(color);
}

void sub_2237364D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CGColorRef color)
{
}

void TSWPRepBoundsAnalyzer::finalize(uint64_t a1, uint64_t a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6, double a7, double a8)
{
  std::vector<TSWPRepBoundsAnalyzer::Info>::erase(a2, *(void *)a2, *(long long **)(a2 + 8));
  uint64_t v16 = *(void *)(a1 + 8);
  unint64_t v17 = *(CGColor **)(v16 + 32);
  if (v16 != a1)
  {
    uint64_t v18 = *(void *)(a1 + 8);
    uint64_t v19 = v18;
    while (1)
    {
      uint64_t v20 = v19;
      uint64_t v19 = v18;
      if (v18 != v20)
      {
        int v21 = *(unsigned __int8 *)(v18 + 40);
        if (*(unsigned __int8 *)(v20 + 40) == v21)
        {
          int64_t v22 = *(CGColor **)(v20 + 32);
          CGRect v23 = *(CGColor **)(v19 + 32);
          if (v22 == v23 || CGColorEqualToColor(v22, v23)) {
            goto LABEL_16;
          }
          int v21 = *(unsigned __int8 *)(v19 + 40);
        }
        if (v21)
        {
          if (*(unsigned char *)(v20 + 40)) {
            goto LABEL_15;
          }
          CGRect v24 = *(CGColor **)(v20 + 32);
          if (!v24) {
            goto LABEL_15;
          }
        }
        else if (!*(unsigned char *)(v20 + 40) || (CGRect v24 = *(CGColor **)(v19 + 32)) == 0)
        {
LABEL_15:
          CGFloat v25 = *(double *)(v16 + 16);
          v31.origin.CGFloat x = a3;
          v31.origin.CGFloat y = a4;
          v31.size.CGFloat width = a5;
          v31.size.CGFloat height = a6;
          CGFloat Width = CGRectGetWidth(v31);
          TSWPRepBoundsAnalyzer::insertTilesForRect(a1, (uint64_t *)a2, v17, a3, v25, Width, *(double *)(v20 + 24) - *(double *)(v16 + 16), a7, a8);
          unint64_t v17 = *(CGColor **)(v19 + 32);
          uint64_t v16 = v19;
          goto LABEL_16;
        }
        unint64_t v17 = v24;
      }
LABEL_16:
      uint64_t v18 = *(void *)(v19 + 8);
      if (v18 == a1) {
        goto LABEL_19;
      }
    }
  }
  uint64_t v19 = a1;
  uint64_t v16 = a1;
LABEL_19:
  CGFloat v27 = *(double *)(v16 + 16);
  v32.origin.CGFloat x = a3;
  v32.origin.CGFloat y = a4;
  v32.size.CGFloat width = a5;
  v32.size.CGFloat height = a6;
  CGFloat v28 = CGRectGetWidth(v32);
  double v29 = *(double *)(v19 + 24) - *(double *)(v16 + 16);

  TSWPRepBoundsAnalyzer::insertTilesForRect(a1, (uint64_t *)a2, v17, a3, v27, v28, v29, a7, a8);
}

void TSWPRepBoundsAnalyzer::TSWPRepBoundsAnalyzer(TSWPRepBoundsAnalyzer *this, CGRect a2)
{
  CGFloat height = a2.size.height;
  CGFloat width = a2.size.width;
  CGFloat y = a2.origin.y;
  CGFloat x = a2.origin.x;
  *(void *)this = this;
  *((void *)this + 1) = this;
  *((void *)this + 2) = 0;
  double MinY = CGRectGetMinY(a2);
  v13.origin.CGFloat x = x;
  v13.origin.CGFloat y = y;
  v13.size.CGFloat width = width;
  v13.size.CGFloat height = height;
  v10[0] = floor(MinY);
  v10[1] = ceil(CGRectGetMaxY(v13));
  CGColorRef color = CGColorRetain(0);
  char v12 = 1;
  uint64_t v8 = std::__list_imp<TSWPRepBoundsAnalyzer::Span>::__create_node[abi:nn180100]<TSWPRepBoundsAnalyzer::Span>((uint64_t)this, 0, 0, (uint64_t)v10);
  uint64_t v9 = *(void *)this;
  *(void *)(v9 + 8) = v8;
  *uint64_t v8 = v9;
  *(void *)this = v8;
  v8[1] = this;
  ++*((void *)this + 2);
  CGColorRelease(color);
}

void sub_223736890(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CGColorRef color)
{
  CGColorRelease(color);
  std::__list_imp<TSWPRepBoundsAnalyzer::Span>::clear(v11);
  _Unwind_Resume(a1);
}

void *std::__list_imp<TSWPRepBoundsAnalyzer::Span>::__create_node[abi:nn180100]<TSWPRepBoundsAnalyzer::Span>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  double v7 = operator new(0x30uLL);
  *double v7 = a2;
  v7[1] = a3;
  *((_OWORD *)v7 + 1) = *(_OWORD *)a4;
  *((unsigned char *)v7 + 40) = *(unsigned char *)(a4 + 24);
  uint64_t v8 = *(CGColor **)(a4 + 16);
  v7[4] = v8;
  CGColorRetain(v8);
  return v7;
}

void sub_223736914(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__list_imp<TSWPRepBoundsAnalyzer::Span>::clear(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v2 = *a1;
    BOOL v3 = (uint64_t *)a1[1];
    uint64_t v4 = *v3;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v2 + 8) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        uint64_t v5 = (uint64_t *)v3[1];
        CGColorRelease((CGColorRef)v3[4]);
        operator delete(v3);
        BOOL v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

void TSWPRepBoundsAnalyzer::insertSpan(uint64_t a1, uint64_t a2)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  double v4 = *(double *)(a2 + 8);
  double v24 = *(double *)a2;
  uint64_t v5 = *(void *)(a1 + 8);
  char v25 = 0;
  uint64_t v6 = std::__lower_bound[abi:nn180100]<std::_ClassicAlgPolicy,std::__list_iterator<EQKit::StemStretch::FeatureRange::Span,void *>,std::__list_iterator<EQKit::StemStretch::FeatureRange::Span,void *>,double,std::__identity,std::__less<void,void>>(v5, a1, &v24);
  double v7 = (uint64_t *)v6;
  if (v6 != a1)
  {
    char v8 = 0;
    uint64_t v9 = v6;
    while (*(double *)(v9 + 16) < v4)
    {
      uint64_t v26 = 0;
      uint64_t v27 = 0;
      char v29 = 0;
      CGColorRef color = 0;
      uint64_t v31 = 0;
      uint64_t v32 = 0;
      uint64_t v30 = 0;
      char v33 = 0;
      uint64_t v35 = 0;
      uint64_t v36 = 0;
      uint64_t v34 = 0;
      char v37 = 0;
      uint64_t v10 = TSWPRepBoundsAnalyzer::Span::split(v9 + 16, a2, (uint64_t)&v26);
      uint64_t v11 = v10;
      if (v10)
      {
        uint64_t v12 = v10 - 1;
        if (v10 == 1)
        {
          uint64_t v13 = v26;
          uint64_t v14 = v27;
          char v15 = v29;
          uint64_t v16 = color;
          CGColorRetain(color);
          *(void *)(v9 + 16) = v13;
          *(void *)(v9 + 24) = v14;
        }
        else
        {
          unint64_t v17 = &v26;
          do
          {
            uint64_t v18 = std::__list_imp<TSWPRepBoundsAnalyzer::Span>::__create_node[abi:nn180100]<TSWPRepBoundsAnalyzer::Span const&>(a1, 0, 0, (uint64_t)v17);
            uint64_t v19 = *(void *)v9;
            *(void *)(v19 + 8) = v18;
            *uint64_t v18 = v19;
            *(void *)uint64_t v9 = v18;
            v18[1] = v9;
            ++*(void *)(a1 + 16);
            v17 += 4;
            --v12;
          }
          while (v12);
          uint64_t v20 = &v26 + 4 * v11;
          long long v23 = *((_OWORD *)v20 - 2);
          char v15 = *((unsigned char *)v20 - 8);
          uint64_t v16 = (CGColor *)*(v20 - 2);
          CGColorRetain(v16);
          *(_OWORD *)(v9 + 16) = v23;
        }
        *(unsigned char *)(v9 + 40) = v15;
        int v21 = *(CGColor **)(v9 + 32);
        *(void *)(v9 + 32) = v16;
        CGColorRelease(v21);
        char v8 = 1;
      }
      for (uint64_t i = 80; i != -16; i -= 32)
        CGColorRelease(*(CGColorRef *)((char *)&v26 + i));
      uint64_t v9 = *(void *)(v9 + 8);
      if (v9 == a1)
      {
        uint64_t v9 = a1;
        break;
      }
    }
    if (v8) {
      TSWPRepBoundsAnalyzer::collapse(a1, v7, v9);
    }
  }
}

void sub_223736B8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

uint64_t TSWPRepBoundsAnalyzer::Span::split(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(double *)(a2 + 8) <= *(double *)a1 || *(double *)a2 >= *(double *)(a1 + 8)) {
    return 0;
  }
  int v6 = *(unsigned __int8 *)(a1 + 24);
  if (v6 == *(unsigned __int8 *)(a2 + 24))
  {
    double v7 = *(CGColor **)(a1 + 16);
    char v8 = *(CGColor **)(a2 + 16);
    if (v7 == v8 || CGColorEqualToColor(v7, v8)) {
      return 0;
    }
    int v6 = *(unsigned __int8 *)(a1 + 24);
  }
  if (!v6 && !*(void *)(a1 + 16)) {
    return 0;
  }
  double v9 = *(double *)a1;
  double v10 = *(double *)a2;
  if (*(double *)a1 == *(double *)a2)
  {
    double v11 = *(double *)(a1 + 8);
    double v12 = *(double *)(a2 + 8);
    if (v11 == v12)
    {
      if (v6)
      {
        int v13 = *(unsigned __int8 *)(a2 + 24);
        uint64_t v14 = *(CGColor **)(a2 + 16);
        if (v13 || v14)
        {
          CGColorRetain(v14);
          *(double *)a3 = v10;
          *(double *)(a3 + 8) = v12;
          *(unsigned char *)(a3 + 24) = v13;
LABEL_15:
          char v15 = *(CGColor **)(a3 + 16);
          *(void *)(a3 + 16) = v14;
          CGColorRelease(v15);
          return 1;
        }
        goto LABEL_28;
      }
      char v25 = *(CGColor **)(a1 + 16);
      if (!v25)
      {
        uint64_t v27 = 0;
        goto LABEL_42;
      }
      int v26 = *(unsigned __int8 *)(a2 + 24);
      uint64_t v14 = *(CGColor **)(a2 + 16);
      if (!v26 && !v14)
      {
LABEL_28:
        uint64_t v27 = *(CGColor **)(a1 + 16);
LABEL_42:
        CGColorRetain(v27);
        *(double *)a3 = v9;
        *(double *)(a3 + 8) = v11;
        *(unsigned char *)(a3 + 24) = v6;
        long long v44 = *(CGColor **)(a3 + 16);
        *(void *)(a3 + 16) = v27;
        CGColorRelease(v44);
        CGColorRelease(*(CGColorRef *)(a3 + 16));
        *(void *)(a3 + 16) = 0;
        *(unsigned char *)(a3 + 24) = 0;
        return 1;
      }
      if (v26)
      {
        char v45 = 0;
LABEL_46:
        CGRect v46 = *(CGColor **)(a1 + 16);
        CGColorRetain(v46);
        *(double *)a3 = v9;
        *(double *)(a3 + 8) = v11;
        *(unsigned char *)(a3 + 24) = v45;
        CGRect v47 = *(CGColor **)(a3 + 16);
        *(void *)(a3 + 16) = v46;
        CGColorRelease(v47);
        CGColorRelease(*(CGColorRef *)(a3 + 16));
        uint64_t v16 = 0;
        *(void *)(a3 + 16) = 0;
        *(unsigned char *)(a3 + 24) = 0;
        return v16;
      }
      if (v25 == v14)
      {
        char v45 = 0;
      }
      else
      {
        BOOL v48 = CGColorEqualToColor(v25, v14);
        double v9 = *(double *)a1;
        double v11 = *(double *)(a1 + 8);
        char v45 = *(unsigned char *)(a1 + 24);
        if (!v48) {
          goto LABEL_46;
        }
        uint64_t v14 = *(CGColor **)(a1 + 16);
      }
      CGColorRetain(v14);
      *(double *)a3 = v9;
      *(double *)(a3 + 8) = v11;
      *(unsigned char *)(a3 + 24) = v45;
      goto LABEL_15;
    }
  }
  if (v9 >= v10)
  {
    uint64_t v20 = 0;
  }
  else
  {
    CGColorRef v18 = CGColorRetain(*(CGColorRef *)(a1 + 16));
    *(double *)a3 = v9;
    *(double *)(a3 + 8) = v10;
    *(unsigned char *)(a3 + 24) = v6 != 0;
    uint64_t v19 = *(CGColor **)(a3 + 16);
    *(void *)(a3 + 16) = v18;
    CGColorRelease(v19);
    int v6 = *(unsigned __int8 *)(a1 + 24);
    uint64_t v20 = 1;
  }
  int v21 = *(unsigned __int8 *)(a2 + 24);
  if (v6 == v21)
  {
    int64_t v22 = *(CGColor **)(a1 + 16);
    long long v23 = *(CGColor **)(a2 + 16);
    if (v22 == v23)
    {
      BOOL v24 = 1;
      int v21 = v6;
    }
    else
    {
      BOOL v24 = CGColorEqualToColor(v22, v23);
      int v6 = *(unsigned __int8 *)(a1 + 24);
      int v21 = *(unsigned __int8 *)(a2 + 24);
    }
  }
  else
  {
    BOOL v24 = 0;
  }
  if (v6) {
    int v28 = 1;
  }
  else {
    int v28 = v24;
  }
  if (v21) {
    BOOL v29 = v6 != 0;
  }
  else {
    BOOL v29 = 0;
  }
  BOOL v30 = v29 && v24;
  if (v28) {
    uint64_t v31 = *(CGColor **)(a2 + 16);
  }
  else {
    uint64_t v31 = 0;
  }
  uint64_t v32 = a3 + 32 * v20;
  int8x16_t v33 = *(int8x16_t *)a2;
  v34.i64[0] = *(void *)a1;
  v34.i64[1] = *(void *)(a2 + 8);
  v33.i64[1] = *(void *)(a1 + 8);
  int8x16_t v49 = vbslq_s8((int8x16_t)vcgtq_f64(*(float64x2_t *)a1, *(float64x2_t *)a2), v34, v33);
  CGColorRef v35 = CGColorRetain(v31);
  *(int8x16_t *)uint64_t v32 = v49;
  *(unsigned char *)(v32 + 24) = v30;
  uint64_t v36 = *(CGColor **)(v32 + 16);
  *(void *)(v32 + 16) = v35;
  CGColorRelease(v36);
  uint64_t v16 = v20 + 1;
  double v37 = *(double *)(a2 + 8);
  double v38 = *(double *)(a1 + 8);
  if (v37 < v38)
  {
    uint64_t v39 = *(CGColor **)(a1 + 16);
    char v40 = *(unsigned char *)(a1 + 24);
    CGColorRef v41 = CGColorRetain(v39);
    uint64_t v42 = a3 + 32 * v16;
    *(double *)uint64_t v42 = v37;
    *(double *)(v42 + 8) = v38;
    *(unsigned char *)(v42 + 24) = v40;
    CFRange v43 = *(CGColor **)(v42 + 16);
    *(void *)(v42 + 16) = v41;
    CGColorRelease(v43);
    return v20 | 2;
  }
  return v16;
}

uint64_t TSWPRepBoundsAnalyzer::collapse(uint64_t result, uint64_t *a2, uint64_t a3)
{
  BOOL v3 = a2;
  uint64_t v4 = result;
  if (*(uint64_t **)(result + 8) != a2) {
    BOOL v3 = (uint64_t *)*a2;
  }
  uint64_t v5 = result;
  if (a3 != result) {
    uint64_t v5 = *(void *)(a3 + 8);
  }
  while (v3 != (uint64_t *)v5)
  {
    int v6 = v3;
    BOOL v3 = (uint64_t *)v3[1];
    if (v3 != (uint64_t *)v4 && *((unsigned __int8 *)v6 + 40) == *((unsigned __int8 *)v3 + 40))
    {
      double v7 = (CGColor *)v6[4];
      char v8 = (CGColor *)v3[4];
      if (v7 == v8 || (unint64_t result = CGColorEqualToColor(v7, v8), result))
      {
        void v3[2] = v6[2];
        unint64_t result = std::list<TSWPRepBoundsAnalyzer::Span>::erase(v4, v6);
      }
    }
  }
  return result;
}

void *std::__list_imp<TSWPRepBoundsAnalyzer::Span>::__create_node[abi:nn180100]<TSWPRepBoundsAnalyzer::Span const&>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  double v7 = operator new(0x30uLL);
  *double v7 = a2;
  v7[1] = a3;
  *((_OWORD *)v7 + 1) = *(_OWORD *)a4;
  *((unsigned char *)v7 + 40) = *(unsigned char *)(a4 + 24);
  char v8 = *(CGColor **)(a4 + 16);
  v7[4] = v8;
  CGColorRetain(v8);
  return v7;
}

void sub_223736FC4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::list<TSWPRepBoundsAnalyzer::Span>::erase(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  *(void *)(v3 + 8) = v4;
  *(void *)a2[1] = v3;
  --*(void *)(a1 + 16);
  CGColorRelease((CGColorRef)a2[4]);
  operator delete(a2);
  return v4;
}

uint64_t std::vector<TSWPRepBoundsAnalyzer::Info>::erase(uint64_t a1, uint64_t a2, long long *a3)
{
  if ((long long *)a2 != a3)
  {
    std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSWPRepBoundsAnalyzer::Info *,TSWPRepBoundsAnalyzer::Info *,TSWPRepBoundsAnalyzer::Info *>((uint64_t)&v10, a3, *(long long **)(a1 + 8), a2);
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)(a1 + 8);
    if (v7 != v5)
    {
      do
      {
        uint64_t v8 = v7 - 40;
        CGColorRelease(*(CGColorRef *)(v7 - 8));
        uint64_t v7 = v8;
      }
      while (v8 != v6);
    }
    *(void *)(a1 + 8) = v6;
  }
  return a2;
}

void TSWPRepBoundsAnalyzer::insertTilesForRect(int a1, uint64_t *a2, CGColorRef color, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7, double a8, double a9)
{
  double v15 = fmax(ceil(a9), 32.0);
  double v26 = fmax(ceil(a8), 32.0);
  double v24 = v15;
  if (a6 > v26 || a6 > v15)
  {
    CGFloat v17 = a4;
    double MinY = CGRectGetMinY(*(CGRect *)(&a5 - 1));
    v32.origin.CGFloat x = a4;
    v32.origin.CGFloat y = a5;
    v32.size.CGFloat width = a6;
    v32.size.CGFloat height = a7;
    double MaxY = CGRectGetMaxY(v32);
    while (MinY < MaxY)
    {
      v33.origin.CGFloat x = a4;
      v33.origin.CGFloat y = a5;
      v33.size.CGFloat width = a6;
      v33.size.CGFloat height = a7;
      double v25 = fmin(CGRectGetMaxY(v33), v24 + MinY);
      v34.origin.CGFloat x = a4;
      v34.origin.CGFloat y = a5;
      v34.size.CGFloat width = a6;
      v34.size.CGFloat height = a7;
      double MinX = CGRectGetMinX(v34);
      v35.origin.CGFloat x = a4;
      v35.origin.CGFloat y = a5;
      v35.size.CGFloat width = a6;
      v35.size.CGFloat height = a7;
      if (MinX < CGRectGetMaxX(v35))
      {
        do
        {
          double v21 = MinX;
          v36.origin.CGFloat x = a4;
          v36.origin.CGFloat y = a5;
          v36.size.CGFloat width = a6;
          v36.size.CGFloat height = a7;
          double MinX = fmin(CGRectGetMaxX(v36), v26 + MinX);
          int64_t v22 = (_OWORD *)a2[1];
          CGFloat v27 = v21;
          CGFloat v28 = MinY;
          double v29 = MinX - v21;
          double v30 = v25 - MinY;
          colorCATransform3D a = CGColorRetain(color);
          std::vector<TSWPRepBoundsAnalyzer::Info>::insert(a2, v22, (uint64_t)&v27);
          CGColorRelease(colora);
          v37.origin.CGFloat x = a4;
          v37.origin.CGFloat y = a5;
          v37.size.CGFloat width = a6;
          v37.size.CGFloat height = a7;
        }
        while (MinX < CGRectGetMaxX(v37));
      }
      v38.origin.CGFloat x = a4;
      v38.origin.CGFloat y = a5;
      v38.size.CGFloat width = a6;
      v38.size.CGFloat height = a7;
      double MaxY = CGRectGetMaxY(v38);
      double MinY = v25;
    }
  }
  else
  {
    long long v23 = (_OWORD *)a2[1];
    CGFloat v27 = a4;
    CGFloat v28 = a5;
    double v29 = a6;
    double v30 = a7;
    colorCATransform3D a = CGColorRetain(color);
    std::vector<TSWPRepBoundsAnalyzer::Info>::insert(a2, v23, (uint64_t)&v27);
    CGColorRelease(colora);
  }
}

void sub_223737290(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, CGColorRef color)
{
}

long long *std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSWPRepBoundsAnalyzer::Info *,TSWPRepBoundsAnalyzer::Info *,TSWPRepBoundsAnalyzer::Info *>(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  do
  {
    long long v10 = *v5;
    long long v11 = v5[1];
    CGColorRef v7 = CGColorRetain(*((CGColorRef *)v5 + 4));
    *(_OWORD *)a4 = v10;
    *(_OWORD *)(a4 + 16) = v11;
    uint64_t v8 = *(CGColor **)(a4 + 32);
    *(void *)(a4 + 32) = v7;
    CGColorRelease(v8);
    a4 += 40;
    uint64_t v5 = (long long *)((char *)v5 + 40);
  }
  while (v5 != v6);
  return v6;
}

_OWORD *std::vector<TSWPRepBoundsAnalyzer::Info>::insert(uint64_t *a1, _OWORD *a2, uint64_t a3)
{
  uint64_t v4 = a2;
  uint64_t v7 = *a1;
  unint64_t v6 = a1[1];
  unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * (((uint64_t)a2 - *a1) >> 3);
  unint64_t v11 = a1[2];
  uint64_t v9 = (uint64_t)(a1 + 2);
  unint64_t v10 = v11;
  if (v6 >= v11)
  {
    unint64_t v17 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v6 - v7) >> 3) + 1;
    if (v17 > 0x666666666666666) {
      abort();
    }
    unint64_t v18 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v10 - v7) >> 3);
    if (2 * v18 > v17) {
      unint64_t v17 = 2 * v18;
    }
    if (v18 >= 0x333333333333333) {
      unint64_t v19 = 0x666666666666666;
    }
    else {
      unint64_t v19 = v17;
    }
    uint64_t v27 = v9;
    if (v19) {
      uint64_t v20 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<EQKit::StemStretch::Key,unsigned long>>>(v9, v19);
    }
    else {
      uint64_t v20 = 0;
    }
    long long v23 = v20;
    double v24 = &v20[40 * v8];
    double v25 = v24;
    double v26 = &v20[40 * v19];
    std::__split_buffer<TSWPRepBoundsAnalyzer::Info>::push_back(&v23, a3);
    uint64_t v4 = (_OWORD *)std::vector<TSWPRepBoundsAnalyzer::Info>::__swap_out_circular_buffer(a1, &v23, (uint64_t)v4);
    std::__split_buffer<TSWPRepBoundsAnalyzer::Info>::~__split_buffer((uint64_t)&v23);
  }
  else if (a2 == (_OWORD *)v6)
  {
    long long v21 = *(_OWORD *)(a3 + 16);
    *a2 = *(_OWORD *)a3;
    a2[1] = v21;
    *(void *)(v7 + 40 * v8 + 32) = CGColorRetain(*(CGColorRef *)(a3 + 32));
    a1[1] = (uint64_t)v4 + 40;
  }
  else
  {
    std::vector<TSWPRepBoundsAnalyzer::Info>::__move_range((uint64_t)a1, (uint64_t)a2, v6, (uint64_t)a2 + 40);
    long long v12 = *(_OWORD *)(a3 + 16);
    long long v28 = *(_OWORD *)a3;
    long long v29 = v12;
    CGColorRef v13 = CGColorRetain(*(CGColorRef *)(a3 + 32));
    long long v14 = v29;
    _OWORD *v4 = v28;
    v4[1] = v14;
    unint64_t v15 = v7 + 40 * v8;
    uint64_t v16 = *(CGColor **)(v15 + 32);
    *(void *)(v15 + 32) = v13;
    CGColorRelease(v16);
  }
  return v4;
}

void sub_2237374B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  *(void *)(v11 + 8) = v10;
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<TSWPRepBoundsAnalyzer::Info>::__move_range(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 8);
  unint64_t v7 = a2 + v6 - a4;
  uint64_t v8 = v6;
  if (v7 < a3)
  {
    unint64_t v10 = a2 + v6 - a4;
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      long long v11 = *(_OWORD *)(v10 + 16);
      *(_OWORD *)uint64_t v8 = *(_OWORD *)v10;
      *(_OWORD *)(v8 + 16) = v11;
      *(void *)(v8 + 32) = CGColorRetain(*(CGColorRef *)(v10 + 32));
      v8 += 40;
      v10 += 40;
    }
    while (v10 < a3);
  }
  *(void *)(a1 + 8) = v8;
  return std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSWPRepBoundsAnalyzer::Info *,TSWPRepBoundsAnalyzer::Info *,TSWPRepBoundsAnalyzer::Info *>((uint64_t)&v13, a2, v7, v6);
}

void sub_22373757C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

CGColorRef std::__split_buffer<TSWPRepBoundsAnalyzer::Info>::push_back(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  if (v4 == a1[3])
  {
    uint64_t v5 = (long long *)a1[1];
    if ((unint64_t)v5 <= *a1)
    {
      if (v4 == *a1) {
        unint64_t v10 = 1;
      }
      else {
        unint64_t v10 = 0x999999999999999ALL * ((v4 - *a1) >> 3);
      }
      unint64_t v11 = v10 >> 2;
      uint64_t v12 = a1[4];
      uint64_t v29 = a1[4];
      char v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<EQKit::StemStretch::Key,unsigned long>>>(v12, v10);
      long long v14 = &v13[40 * v11];
      double v26 = v13;
      v27.i64[0] = (uint64_t)v14;
      uint64_t v16 = &v13[40 * v15];
      v27.i64[1] = (uint64_t)v14;
      long long v28 = v16;
      unint64_t v17 = a1[1];
      int64_t v18 = a1[2] - v17;
      if (v18)
      {
        unint64_t v19 = &v14[40 * (v18 / 40)];
        uint64_t v20 = 40 * (v18 / 40);
        do
        {
          long long v21 = *(_OWORD *)(v17 + 16);
          *(_OWORD *)long long v14 = *(_OWORD *)v17;
          *((_OWORD *)v14 + 1) = v21;
          *((void *)v14 + 4) = CGColorRetain(*(CGColorRef *)(v17 + 32));
          v14 += 40;
          v17 += 40;
          v20 -= 40;
        }
        while (v20);
        char v13 = v26;
        long long v14 = (char *)v27.i64[0];
        int64x2_t v22 = *(int64x2_t *)(a1 + 1);
        uint64_t v16 = v28;
      }
      else
      {
        int64x2_t v22 = vdupq_n_s64(v17);
        unint64_t v19 = v14;
      }
      double v26 = (char *)*a1;
      *a1 = v13;
      a1[1] = v14;
      int64x2_t v27 = v22;
      long long v23 = (char *)a1[3];
      a1[2] = v19;
      a1[3] = v16;
      long long v28 = v23;
      std::__split_buffer<TSWPRepBoundsAnalyzer::Info>::~__split_buffer((uint64_t)&v26);
      uint64_t v4 = a1[2];
    }
    else
    {
      int64_t v6 = 0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v5 - *a1) >> 3);
      if (v6 >= -1) {
        uint64_t v7 = v6 + 1;
      }
      else {
        uint64_t v7 = v6 + 2;
      }
      uint64_t v8 = -5 * (v7 >> 1);
      std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSWPRepBoundsAnalyzer::Info *,TSWPRepBoundsAnalyzer::Info *,TSWPRepBoundsAnalyzer::Info *>((uint64_t)&v26, v5, (long long *)v4, (uint64_t)v5 - 40 * (v7 >> 1));
      uint64_t v4 = v9;
      a1[1] += 8 * v8;
      a1[2] = v9;
    }
  }
  long long v24 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)uint64_t v4 = *(_OWORD *)a2;
  *(_OWORD *)(v4 + 16) = v24;
  CGColorRef result = CGColorRetain(*(CGColorRef *)(a2 + 32));
  *(void *)(v4 + 32) = result;
  a1[2] += 40;
  return result;
}

void sub_223737710(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TSWPRepBoundsAnalyzer::Info>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<TSWPRepBoundsAnalyzer::Info>::__swap_out_circular_buffer(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v6 = a2[1];
  uint64_t v7 = *a1;
  uint64_t v8 = v6;
  if (*a1 != a3)
  {
    uint64_t v9 = a3;
    uint64_t v10 = a2[1];
    do
    {
      uint64_t v8 = v10 - 40;
      uint64_t v11 = v9 - 40;
      long long v12 = *(_OWORD *)(v9 - 40);
      *(_OWORD *)(v10 - 24) = *(_OWORD *)(v9 - 24);
      *(_OWORD *)(v10 - 40) = v12;
      *(void *)(v10 - 8) = CGColorRetain(*(CGColorRef *)(v9 - 8));
      uint64_t v9 = v11;
      v10 -= 40;
    }
    while (v11 != v7);
  }
  a2[1] = v8;
  uint64_t v13 = a1[1];
  uint64_t v14 = a2[2];
  if (v13 != v3)
  {
    do
    {
      long long v15 = *(_OWORD *)(v3 + 16);
      *(_OWORD *)uint64_t v14 = *(_OWORD *)v3;
      *(_OWORD *)(v14 + 16) = v15;
      *(void *)(v14 + 32) = CGColorRetain(*(CGColorRef *)(v3 + 32));
      v14 += 40;
      v3 += 40;
    }
    while (v3 != v13);
    uint64_t v8 = a2[1];
  }
  a2[2] = v14;
  uint64_t v16 = *a1;
  *a1 = v8;
  a2[1] = v16;
  uint64_t v17 = a1[1];
  a1[1] = a2[2];
  a2[2] = v17;
  uint64_t v18 = a1[2];
  a1[2] = a2[3];
  a2[3] = v18;
  *a2 = a2[1];
  return v6;
}

uint64_t std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSWPRepBoundsAnalyzer::Info *,TSWPRepBoundsAnalyzer::Info *,TSWPRepBoundsAnalyzer::Info *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 != a2)
  {
    uint64_t v7 = a3;
    do
    {
      uint64_t v8 = v7 - 40;
      long long v12 = *(_OWORD *)(v7 - 40);
      long long v13 = *(_OWORD *)(v7 - 24);
      CGColorRef v9 = CGColorRetain(*(CGColorRef *)(v7 - 8));
      *(_OWORD *)(a4 - 40) = v12;
      *(_OWORD *)(a4 - 24) = v13;
      uint64_t v10 = *(CGColor **)(a4 - 8);
      *(void *)(a4 - 8) = v9;
      CGColorRelease(v10);
      a4 -= 40;
      uint64_t v7 = v8;
    }
    while (v8 != a2);
  }
  return a3;
}

uint64_t std::__split_buffer<TSWPRepBoundsAnalyzer::Info>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 40;
    CGColorRelease(*(CGColorRef *)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::vector<TSWPRepBoundsAnalyzer::Info>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (CGColorRef *)**a1;
  if (v2)
  {
    uint64_t v4 = (CGColorRef *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = v4 - 5;
        CGColorRelease(*(v4 - 1));
        uint64_t v4 = v6;
      }
      while (v6 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t _shapePackageStringByPresetKind(void)
{
  if (_shapePackageStringByPresetKindonceToken != -1) {
    dispatch_once(&_shapePackageStringByPresetKindonceToken, &__block_literal_global_69);
  }
  return _shapePackageStringByPresetKindsingleton;
}

id ___Z31_shapePackageStringByPresetKindv_block_invoke()
{
  v2[4] = *MEMORY[0x263EF8340];
  v1[0] = String;
  v1[1] = String;
  v2[0] = @"line";
  v2[1] = @"shape";
  v1[2] = String;
  v1[3] = TSWPFieldEditorPresetKind;
  v2[2] = @"textbox";
  void v2[3] = @"fieldeditor";
  id result = (id)[NSDictionary dictionaryWithObjects:v2 forKeys:v1 count:4];
  _shapePackageStringByPresetKindsingletouint64_t n = (uint64_t)result;
  return result;
}

uint64_t _presetKindByShapePackageString(void)
{
  if (_presetKindByShapePackageStringonceToken != -1) {
    dispatch_once(&_presetKindByShapePackageStringonceToken, &__block_literal_global_12);
  }
  return _presetKindByShapePackageStringsingleton;
}

id ___Z31_presetKindByShapePackageStringv_block_invoke()
{
  uint64_t v0 = NSDictionary;
  if (_shapePackageStringByPresetKindonceToken != -1) {
    dispatch_once(&_shapePackageStringByPresetKindonceToken, &__block_literal_global_69);
  }
  id result = (id)objc_msgSend(v0, "tsu_dictionaryByInvertingDictionary:", _shapePackageStringByPresetKindsingleton);
  _presetKindByShapePackageStringsingletouint64_t n = (uint64_t)result;
  return result;
}

uint64_t TSWPShapePackageStringForPresetKind(uint64_t a1)
{
  if (_shapePackageStringByPresetKindonceToken != -1) {
    dispatch_once(&_shapePackageStringByPresetKindonceToken, &__block_literal_global_69);
  }
  uint64_t v2 = [(id)_shapePackageStringByPresetKindsingleton objectForKeyedSubscript:a1];
  if (!v2)
  {
    uint64_t v3 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v4 = [NSString stringWithUTF8String:"NSString *TSWPShapePackageStringForPresetKind(TSSPresetKind)"];
    [v3 handleFailureInFunction:v4, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPShapeInfo.mm"), 97, @"Unexpected preset kind %@ in TSWPShapeStylePackageStringForPresetKind()", a1 file lineNumber description];
  }
  return v2;
}

uint64_t TSWPShapePresetKindForPackageString(void *a1)
{
  if (_presetKindByShapePackageStringonceToken != -1) {
    dispatch_once(&_presetKindByShapePackageStringonceToken, &__block_literal_global_12);
  }
  uint64_t v2 = [(id)_presetKindByShapePackageStringsingleton objectForKeyedSubscript:a1];
  if (!v2)
  {
    uint64_t v2 = String;
    if (([a1 isEqualToString:@"tableName"] & 1) == 0)
    {
      uint64_t v3 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v4 = [NSString stringWithUTF8String:"TSSPresetKind TSWPShapePresetKindForPackageString(NSString *)"];
      [v3 handleFailureInFunction:v4, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPShapeInfo.mm"), 124, @"Unknown package string %@.", a1 file lineNumber description];
    }
  }
  return v2;
}

uint64_t TSWPLayoutChore::setStorageRange(TSWPLayoutChore *this, _NSRange a2)
{
  NSUInteger length = a2.length;
  NSUInteger location = a2.location;
  *((void *)this + 8) = a2.location + a2.length;
  uint64_t v5 = (void *)*((void *)this + 1);
  uint64_t v6 = [*((id *)this + 3) styleProvider];
  if (v5) {
    objc_msgSend(v5, "paragraphEnumeratorForCharRange:styleProvider:", location, length, v6);
  }
  else {
    memset(&v10, 0, sizeof(v10));
  }
  long long v7 = *(_OWORD *)&v10.var2;
  *(_OWORD *)((char *)this + 104) = *(_OWORD *)&v10.var0;
  *(_OWORD *)((char *)this + 120) = v7;
  *(_OWORD *)((char *)this + 136) = *(_OWORD *)&v10.var4;
  *((unsigned char *)this + 152) = v10.var6;
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator(&v10);
  uint64_t result = objc_msgSend(*((id *)this + 1), "attachmentIndexRangeForTextRange:", 0, *((void *)this + 8));
  *((void *)this + 9) = v9;
  *((void *)this + 10) = location;
  return result;
}

uint64_t TSWPLayoutChore::pStyleProvider(id *this)
{
  return [this[3] styleProvider];
}

uint64_t TSWPLayoutChore::clearDelta(uint64_t this)
{
  *(void *)(this + 2048) = 0;
  return this;
}

TSWPTopicNumberHints *TSWPLayoutChore::setTopicNumbers(TSWPLayoutChore *this, TSWPTopicNumberHints *a2)
{
  uint64_t v3 = (TSWPTopicNumberHints *)((char *)this + 816);
  TSWPTopicNumberHints::operator=((TSWPTopicNumberHints *)this + 17, a2);
  TSWPTopicNumberHints::advanceToCharIndex(v3, *((void *)this + 10), *((TSWPStorage **)this + 1));

  return TSWPTopicNumberHints::operator=((TSWPTopicNumberHints *)this + 16, v3);
}

uint64_t TSWPLayoutChore::pPerformIterativeAttachmentPositioning(uint64_t a1, _DWORD *a2, void *a3)
{
  if ([*(id *)(a1 + 8) attachmentCount])
  {
    uint64_t v5 = 0;
    char v55 = 1;
    while (1)
    {
      unint64_t v56 = 0;
      [*(id *)(a1 + 8) attachmentAtAttachmentIndex:v5 outCharIndex:&v56];
      objc_opt_class();
      uint64_t v6 = (TSWPDrawableAttachment *)TSUDynamicCast();
      uint64_t v7 = objc_msgSend(*(id *)(a1 + 2056), "validatedLayoutForAnchoredDrawable:", -[TSWPDrawableAttachment drawable](v6, "drawable"));
      if (v6)
      {
        uint64_t v8 = (void *)v7;
        uint64_t v9 = [*(id *)(a1 + 2056) iterativeAttachmentPositioningMaxPassCount];
        TSWPParagraphEnumerator v10 = (void *)[v8 iterativePositioningState];
        if ([v10 passCount] != v9 && !objc_msgSend(v8, "hasFinishedIterativePositioning"))
        {
          if (objc_opt_respondsToSelector()) {
            objc_msgSend(a3, "drawableAttachment:willStartNewIterationWithIndex:", v6, objc_msgSend(v10, "passCount"));
          }
          uint64_t v11 = objc_msgSend(a3, "validatedLayoutForAnchoredDrawable:", -[TSWPDrawableAttachment drawable](v6, "drawable"));
          if (!objc_msgSend((id)objc_msgSend(a3, "columns"), "count")) {
            goto LABEL_7;
          }
          uint64_t v12 = 0;
          while (1)
          {
            long long v13 = objc_msgSend((id)objc_msgSend(a3, "columns"), "objectAtIndex:", v12);
            unint64_t v14 = [v13 range];
            if (v14 <= v56)
            {
              uint64_t v15 = [v13 range];
              [v13 range];
              unint64_t v17 = v16 + v15;
              unint64_t v18 = v56;
              if (v17 > v56) {
                break;
              }
            }
            if (++v12 >= (unint64_t)objc_msgSend((id)objc_msgSend(a3, "columns"), "count")) {
              goto LABEL_7;
            }
          }
          unint64_t v19 = (void *)[v8 iterativePositioningState];
          if ([v19 hasLoopInLastPasses])
          {
            [v19 bestPosition];
            double v21 = v20;
            double v23 = round(v22 + 0.5);
            [v8 finishIterativePositioning];
            if (v23 < 0.0)
            {
              *(double *)(a1 + 744) = -v23;
              double v23 = 0.0;
            }
            [v19 smallestMismatch];
            objc_msgSend(v19, "setPosition:mismatch:", v21, v23, v24);
            if (objc_opt_respondsToSelector())
            {
              double v25 = a3;
              double v26 = v6;
              double v27 = v21;
              double v28 = v23;
              goto LABEL_39;
            }
          }
          else
          {
            if (v18) {
              uint64_t v29 = v18 - 1;
            }
            else {
              uint64_t v29 = 1;
            }
            [v13 topOfLineAtCharIndex:v29];
            double v31 = TSWPLayoutChore::pAdjustAnchorYPositionForVerticalAlignment((id *)a1, v6, v29, v30);
            if (objc_opt_respondsToSelector()) {
              int v32 = [a3 drawableAttachment:v6 withLayout:v8 shouldPositionIterativelyInColumn:v13];
            }
            else {
              int v32 = 1;
            }
            [(TSWPDrawableAttachment *)v6 attachmentAnchorY];
            double v34 = v33;
            [v11 frame];
            double v36 = v31 - v34 * v35;
            float v37 = v36;
            *(float *)&double v34 = roundf(v37);
            [v11 frame];
            float v39 = v38;
            float v40 = roundf(v39);
            uint64_t v41 = [v8 iterativePositioningState];
            if (*(float *)&v34 == v40 || v32 == 0)
            {
              if (!v41)
              {
                if (objc_opt_respondsToSelector()) {
                  [a3 startedIterativePositioningProcessForDrawableAttachment:v6];
                }
                CFRange v43 = objc_alloc_init(TSWPIterativeAttachmentPositioningState);
                [v8 setIterativePositioningState:v43];
              }
              [v8 finishIterativePositioning];
              long long v44 = (void *)[v8 iterativePositioningState];
              [v11 frame];
              objc_msgSend(v44, "setPosition:mismatch:");
              if (objc_opt_respondsToSelector())
              {
                [v11 frame];
                double v25 = a3;
                double v26 = v6;
LABEL_39:
                objc_msgSend(v25, "drawableAttachment:didFinalizePosition:", v26, v27, v28);
              }
            }
            else
            {
              if (!v41)
              {
                if (objc_opt_respondsToSelector()) {
                  [a3 startedIterativePositioningProcessForDrawableAttachment:v6];
                }
                char v45 = objc_alloc_init(TSWPIterativeAttachmentPositioningState);
                [v8 setIterativePositioningState:v45];

                CGRect v46 = (void *)[v8 iterativePositioningState];
                [v11 frame];
                objc_msgSend(v46, "setPosition:mismatch:");
              }
              [v11 frame];
              double v48 = v36 - v47;
              int8x16_t v49 = (void *)[v8 iterativePositioningState];
              [v11 frame];
              double v51 = v50;
              [v11 frame];
              objc_msgSend(v49, "setPosition:mismatch:", v51, v48 + v52, v48);
            }
          }
          char v55 = 0;
          goto LABEL_7;
        }
        [v8 finishIterativePositioning];
      }
LABEL_7:
      if (++v5 >= (unint64_t)[*(id *)(a1 + 8) attachmentCount]) {
        goto LABEL_47;
      }
    }
  }
  char v55 = 1;
LABEL_47:
  ++*a2;
  return v55 & 1;
}

id *TSWPLayoutChore::pRestoreStateFromOldState(TSWPLayoutChore *this, id *a2)
{
  uint64_t v4 = (id *)((char *)this + 80);
  char v5 = *((unsigned char *)this + 640);
  if ((id *)((char *)this + 80) == a2)
  {
    uint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = [NSString stringWithUTF8String:"void TSWPLayoutChore::pRestoreStateFromOldState(const TSWPLayoutState &)"];
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLayoutChore.mm"), 6152, @"We should not restore from our own object.");
  }
  if (a2[10] == *((id *)this + 20) && a2[11] == *((id *)this + 21))
  {
    __int16 v11 = *((_WORD *)this + 284);
    unint64_t v12 = *((void *)this + 73);
    uint64_t result = TSWPLayoutState::operator=(v4, a2);
    *((_WORD *)this + 284) = v11;
    unint64_t v10 = *((void *)this + 72);
    if (!v10)
    {
      *((void *)this + 72) = v12;
      unint64_t v10 = v12;
    }
  }
  else
  {
    uint64_t result = TSWPLayoutState::operator=(v4, a2);
    unint64_t v10 = *((void *)this + 72);
  }
  *((unsigned char *)this + 640) = v5;
  unint64_t v13 = *((void *)this + 21);
  if (v10 > v13 || *((void *)this + 73) > v13)
  {
    unint64_t v14 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v15 = [NSString stringWithUTF8String:"void TSWPLayoutChore::pRestoreStateFromOldState(const TSWPLayoutState &)"];
    uint64_t v16 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLayoutChore.mm"];
    return (id *)[v14 handleFailureInFunction:v15 file:v16 lineNumber:6175 description:@"Bad _typesetterCharIndex"];
  }
  return result;
}

BOOL TSWPLayoutChore::pIsLayingOutBody(TSWPLayoutChore *this)
{
  return *((_DWORD *)this + 14) == 0;
}

unint64_t TSWPLayoutChore::pUpdateSmartFieldsForCurrentColumn(id *a1)
{
  uint64_t v2 = [a1[23] range];
  uint64_t v4 = v3;
  unint64_t result = [a1[1] characterCount];
  if (v2 + v4 < result)
  {
    return TSWPLayoutChore::pIsLastColumn(a1);
  }
  return result;
}

uint64_t TSWPLayoutChore::validatedLayoutForAnchoredAttachment(TSWPLayoutChore *this, TSWPDrawableAttachment *a2)
{
  uint64_t v2 = (void *)*((void *)this + 257);
  uint64_t v3 = [(TSWPDrawableAttachment *)a2 drawable];

  return [v2 validatedLayoutForAnchoredDrawable:v3];
}

uint64_t TSWPLayoutChore::protectedLayoutColumnsWithFlags(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, void *a5)
{
  __int16 v9 = 0;
  __int16 v8 = 0;
  unsigned __int8 v7 = 0;
  TSWPLayoutChore::pLayoutColumns(a1, a2, a3, a4, a5, (uint64_t)&v9, (uint64_t)&v8 + 1, &v8, &v7);

  return [a5 setNeedsDisplay];
}

uint64_t TSWPLayoutChore::pResetPrevLineBlockEnd(uint64_t this)
{
  uint64_t v1 = this;
  if (*(_DWORD *)(this + 56) >= 3u)
  {
    this = *(void *)(this + 184);
    if (this) {
      this = [(id)this frameBounds];
    }
    else {
      unint64_t v2 = 0;
    }
  }
  else
  {
    unint64_t v2 = 0xFFF0000000000000;
  }
  *(void *)(v1 + 400) = v2;
  return this;
}

uint64_t TSWPLayoutChore::pCompareLineFragments(NSUInteger isDifferentFromLineFragment, TSWPLineFragmentArray **a2, TSWPLineFragmentArray **a3, TSWPColumn *a4, char a5, double a6)
{
  uint64_t v72 = (NSRange *)isDifferentFromLineFragment;
  double v10 = *MEMORY[0x263F001A0];
  CGFloat v11 = *(double *)(MEMORY[0x263F001A0] + 8);
  CGFloat v12 = *(double *)(MEMORY[0x263F001A0] + 16);
  CGFloat v13 = *(double *)(MEMORY[0x263F001A0] + 24);
  unint64_t v14 = *(TSWPLineFragment ***)*a3;
  uint64_t v15 = (TSWPLineFragment **)*((void *)*a3 + 1);
  unint64_t v17 = *(const TSWPLineFragment ***)*a2;
  uint64_t v16 = (const TSWPLineFragment **)*((void *)*a2 + 1);
  while (1)
  {
    while (v14 != v15)
    {
      unint64_t v18 = *v14;
      if (v17 == v16)
      {
        if (v18)
        {
          int v33 = (*((unsigned __int8 *)v18 + 24) >> 3) & 1;
          goto LABEL_19;
        }
      }
      else
      {
        unint64_t v19 = *v17;
        if (v18)
        {
          unsigned int v34 = *((_DWORD *)v18 + 6);
          int v33 = (v34 >> 3) & 1;
          if (!v19) {
            goto LABEL_19;
          }
          double v35 = *((double *)v19 + 7);
          double v36 = *((double *)v18 + 7);
          if (v35 < v36) {
            goto LABEL_20;
          }
          if (v35 > v36) {
            goto LABEL_19;
          }
          double v37 = *((double *)v19 + 6);
          double v38 = *((double *)v18 + 6);
          if (v37 < v38)
          {
LABEL_20:
            uint64_t v20 = *((void *)v19 + 10);
            uint64_t v21 = *((void *)v19 + 11);
            uint64_t v22 = *((void *)v19 + 12);
            uint64_t v23 = *((void *)v19 + 13);
            double v24 = v10;
            CGFloat v25 = v11;
            CGFloat v26 = v12;
            CGFloat v27 = v13;
            double v28 = a4;
            int v29 = (v34 >> 3) & 1;
            goto LABEL_10;
          }
          if (v37 <= v38)
          {
            if ((a5 & 0x40) == 0)
            {
              NSUInteger v42 = *(void *)v18;
              uint64_t v43 = *((void *)v18 + 1);
              long long v44 = v72;
              NSUInteger location = v72[127].location;
              if (location == 0x7FFFFFFFFFFFFFFFLL) {
                goto LABEL_26;
              }
              NSUInteger v46 = v43 + v42;
              if (v43 + v42 >= location || v46 > v72[4].location)
              {
                long long v44 = v72;
                if (v46 <= v72[127].length + location) {
                  goto LABEL_30;
                }
LABEL_26:
                NSUInteger v69 = *((void *)v18 + 1);
                NSUInteger v70 = *(void *)v18;
                if (TSWPLineFragment::isDifferentFromLineFragment(v18, v19, v44[128].location)) {
                  goto LABEL_30;
                }
                v74.NSUInteger length = v69;
                v74.NSUInteger location = v70;
                NSRange v47 = NSIntersectionRange(v74, v72[127]);
                isDifferentFromLineFragment = v47.location;
                if (v47.length)
                {
                  CGFloat x = *((double *)v18 + 10);
                  CGFloat y = *((double *)v18 + 11);
                  CGFloat width = *((double *)v18 + 12);
                  CGFloat height = *((double *)v18 + 13);
LABEL_31:
                  v77.origin.CGFloat x = v10;
                  v77.origin.CGFloat y = v11;
                  v77.size.CGFloat width = v12;
                  v77.size.CGFloat height = v13;
                  double v10 = TSWPLayoutChore::pInvalidateRect((TSWPLayoutChore *)isDifferentFromLineFragment, v77, *(CGRect *)&x, a4, 1, v33);
                  CGFloat v11 = v52;
                  CGFloat v12 = v53;
                  CGFloat v13 = v54;
                  goto LABEL_32;
                }
                goto LABEL_32;
              }
            }
            isDifferentFromLineFragment = TSWPLineFragment::isDifferentFromLineFragment(*v14, *v17, 0);
            if (isDifferentFromLineFragment)
            {
LABEL_30:
              CGRect v76 = CGRectUnion(*(CGRect *)((char *)v19 + 80), *(CGRect *)((char *)v18 + 80));
              CGFloat x = v76.origin.x;
              CGFloat y = v76.origin.y;
              CGFloat width = v76.size.width;
              CGFloat height = v76.size.height;
              goto LABEL_31;
            }
LABEL_32:
            v14 += 2;
LABEL_11:
            v17 += 2;
          }
          else
          {
LABEL_19:
            v75.origin.CGFloat x = v10;
            v75.origin.CGFloat y = v11;
            v75.size.CGFloat width = v12;
            v75.size.CGFloat height = v13;
            double v10 = TSWPLayoutChore::pInvalidateRect((TSWPLayoutChore *)isDifferentFromLineFragment, v75, *(CGRect *)((char *)v18 + 80), a4, 1, v33);
            CGFloat v11 = v39;
            CGFloat v12 = v40;
            CGFloat v13 = v41;
            v14 += 2;
          }
        }
        else if (v19)
        {
          goto LABEL_9;
        }
      }
    }
    if (v17 == v16) {
      break;
    }
    unint64_t v19 = *v17;
    if (*v17)
    {
LABEL_9:
      uint64_t v20 = *((void *)v19 + 10);
      uint64_t v21 = *((void *)v19 + 11);
      uint64_t v22 = *((void *)v19 + 12);
      uint64_t v23 = *((void *)v19 + 13);
      double v24 = v10;
      CGFloat v25 = v11;
      CGFloat v26 = v12;
      CGFloat v27 = v13;
      double v28 = a4;
      int v29 = 0;
LABEL_10:
      double v10 = TSWPLayoutChore::pInvalidateRect((TSWPLayoutChore *)isDifferentFromLineFragment, *(CGRect *)&v24, *(CGRect *)&v20, v28, 1, v29);
      CGFloat v11 = v30;
      CGFloat v12 = v31;
      CGFloat v13 = v32;
      goto LABEL_11;
    }
  }
  if (TSWPLineFragmentArray::count(*a2) && TSWPLineFragmentArray::count(*a3))
  {
    char v55 = v72;
  }
  else
  {
    [(TSWPColumn *)a4 wpBounds];
    CGFloat v57 = v56;
    double v59 = v58;
    CGFloat v61 = v60;
    uint64_t v62 = (TSWPLayoutChore *)[(TSWPColumn *)a4 contentBottom];
    char v55 = v72;
    if (v63 >= a6)
    {
      uint64_t v62 = (TSWPLayoutChore *)[(TSWPColumn *)a4 contentBottom];
      a6 = v64;
    }
    if (a6 - v59 != 0.0)
    {
      v78.origin.CGFloat x = v10;
      v78.origin.CGFloat y = v11;
      v78.size.CGFloat width = v12;
      v78.size.CGFloat height = v13;
      v81.origin.CGFloat x = v57;
      v81.origin.CGFloat y = v59;
      v81.size.CGFloat width = v61;
      v81.size.CGFloat height = a6 - v59;
      double v10 = TSWPLayoutChore::pInvalidateRect(v62, v78, v81, a4, 1, 0);
      CGFloat v11 = v65;
      CGFloat v12 = v66;
      CGFloat v13 = v67;
    }
  }
  if (a4) {
    [(TSWPColumn *)a4 transformFromWP];
  }
  else {
    memset(&v73, 0, sizeof(v73));
  }
  v79.origin.CGFloat x = v10;
  v79.origin.CGFloat y = v11;
  v79.size.CGFloat width = v12;
  v79.size.CGFloat height = v13;
  CGRect v80 = CGRectApplyAffineTransform(v79, &v73);
  return objc_msgSend((id)v55[128].length, "setNeedsDisplayInTargetRect:", v80.origin.x, v80.origin.y, v80.size.width, v80.size.height);
}

void TSWPAdornmentRect::~TSWPAdornmentRect(TSWPAdornmentRect *this)
{
}

id pChangeBarColorFillForLineFragment(TSWPLineFragment *a1)
{
  uint64_t v1 = TSWPLineFragment::changeAdornmentMarkupColor(a1);

  return +[TSDColorFill colorWithColor:v1];
}

double pChangeBarRectForLineFragment(uint64_t a1, void *a2, void *a3)
{
  [a2 wpBounds];
  double v6 = v5;
  double v8 = v7;
  if (a3)
  {
    [a3 adjustedInsets];
  }
  else
  {
    double v9 = *MEMORY[0x263F001B0];
    double v10 = *(double *)(MEMORY[0x263F001B0] + 8);
  }
  double v11 = v6 + v9;
  double v12 = v8 - TSDMultiplySizeScalar(v9, v10, 2.0);
  double v13 = *(double *)(a1 + 56);
  double v14 = *(double *)(a1 + 160) + *(double *)(a1 + 136) + *(double *)(a1 + 32) + *(double *)(a1 + 40) - v13;
  if ((*(unsigned char *)(a1 + 25) & 0x10) != 0)
  {
    v18.origin.CGFloat x = v11;
    v18.origin.CGFloat y = *(CGFloat *)(a1 + 56);
    v18.size.CGFloat width = v12;
    v18.size.CGFloat height = *(double *)(a1 + 160) + *(double *)(a1 + 136) + *(double *)(a1 + 32) + *(double *)(a1 + 40) - v13;
    CGRectGetMaxX(v18);
  }
  TSURound();
  double v16 = v15;
  v19.origin.CGFloat x = v11;
  v19.origin.CGFloat y = v13;
  v19.size.CGFloat width = v12;
  v19.size.CGFloat height = v14;
  CGRectGetMinY(v19);
  TSURound();
  v20.origin.CGFloat x = v11;
  v20.origin.CGFloat y = v13;
  v20.size.CGFloat width = v12;
  v20.size.CGFloat height = v14;
  CGRectGetMaxY(v20);
  TSURound();
  return v16;
}

void pAddChangeBarAdornmentRect(void *a1, void *a2, void *a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7)
{
  [a1 wpBounds];
  CGFloat v14 = v13;
  double v16 = v15;
  CGFloat v18 = v17;
  CGFloat v20 = v19;
  if (a2)
  {
    [a2 adjustedInsets];
    double v22 = v21;
  }
  else
  {
    double v22 = *(double *)(MEMORY[0x263F001B0] + 8);
  }
  v33.origin.CGFloat x = v14;
  v33.origin.CGFloat y = v16;
  v33.size.CGFloat width = v18;
  v33.size.CGFloat height = v20;
  double v23 = v22 + CGRectGetMaxY(v33) - v16;
  v34.origin.CGFloat x = a4;
  v34.origin.CGFloat y = a5;
  v34.size.CGFloat width = a6;
  v34.size.CGFloat height = a7;
  double MaxY = CGRectGetMaxY(v34);
  v35.origin.CGFloat x = v14;
  v35.origin.CGFloat y = v16;
  v35.size.CGFloat width = v18;
  v35.size.CGFloat height = v23;
  if (MaxY > floor(CGRectGetMaxY(v35)))
  {
    v36.origin.CGFloat x = v14;
    v36.origin.CGFloat y = v16;
    v36.size.CGFloat width = v18;
    v36.size.CGFloat height = v23;
    a7 = floor(CGRectGetMaxY(v36)) - a5;
  }
  int v26 = 3;
  id v27 = 0;
  id v28 = a3;
  CGFloat v29 = a4;
  CGFloat v30 = a5;
  CGFloat v31 = a6;
  CGFloat v32 = a7;
  [a1 addAdornmentRect:&v26];
}

void sub_22373A6D0(_Unwind_Exception *a1, TSWPAdornmentRect *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

TSWPLineFragment *TSWPLayoutChore::pFillAnchoredDrawableLineFragment@<X0>(uint64_t a1@<X0>, uint64_t **a2@<X1>, uint64_t **a3@<X2>, TSWPLineFragment **a4@<X8>, CGFloat a5@<D0>, CGFloat a6@<D1>, CGFloat a7@<D2>, CGFloat a8@<D3>)
{
  *a4 = 0;
  a4[1] = 0;
  double v15 = *a2;
  if (v15 == *a3) {
    goto LABEL_19;
  }
  unint64_t v16 = *(void *)(a1 + 80);
  while (1)
  {
    double v17 = (double *)*v15;
    unint64_t v18 = *(void *)*v15;
    if (v18 >= v16) {
      break;
    }
    v15 += 2;
    *a2 = v15;
    if (v15 == *a3) {
      goto LABEL_19;
    }
  }
  BOOL v19 = *((void *)v17 + 25) == *((void *)v17 + 24) && v16 == v18;
  if (!v19
    || ((*((unsigned __int8 *)v17 + 25) >> 5) & 1) != (*(unsigned char *)(a1 + 32) & 0x10) >> 4
    || (v17[6] == *(double *)(a1 + 600) ? (BOOL v20 = v17[7] == *(double *)(a1 + 608)) : (BOOL v20 = 0),
        !v20
     || v17[8] != *(double *)(a1 + 616)
     || (std::shared_ptr<TSWPLineFragment>::operator=[abi:ne180100](a4, v15),
         TSWPLineFragment::setWasReused(*a4),
         (double v21 = *a4) == 0)))
  {
LABEL_19:
    operator new();
  }
  *(void *)double v21 = *(void *)(a1 + 80);
  *((void *)v21 + 1) = 1;
  *((_DWORD *)v21 + 6) = 72;
  v28.origin.CGFloat x = a5;
  v28.origin.CGFloat y = a6;
  v28.size.CGFloat width = a7;
  v28.size.CGFloat height = a8;
  CGFloat MaxY = CGRectGetMaxY(v28);
  double v23 = *a4;
  *((CGFloat *)v23 + 4) = MaxY;
  *((CGFloat *)v23 + 6) = a5;
  *((CGFloat *)v23 + 7) = a6;
  *((CGFloat *)v23 + 8) = a7;
  *((CGFloat *)v23 + 9) = a8;
  *((CGFloat *)v23 + 10) = a5;
  *((CGFloat *)v23 + 11) = a6;
  *((CGFloat *)v23 + 12) = a7;
  *((CGFloat *)v23 + 13) = a8;
  *((void *)v23 + 14) = 0;
  *((void *)v23 + 15) = 0;
  v29.origin.CGFloat x = a5;
  v29.origin.CGFloat y = a6;
  v29.size.CGFloat width = a7;
  v29.size.CGFloat height = a8;
  CGFloat Height = CGRectGetHeight(v29);
  CGFloat v25 = *a4;
  *((CGFloat *)v25 + 16) = Height;
  *((void *)v25 + 22) = 0;
  *((void *)v25 + 52) = 0;
  *(_OWORD *)((char *)v25 + 136) = 0u;
  *(_OWORD *)((char *)v25 + 152) = 0u;
  TSWPCoreTextTypesetter::createLineRefForEmptyLineFragment(*(id **)(a1 + 2024), (id *)(a1 + 80), v25, 0, 0.0, 0.0);
  int v26 = *a4;
  *((void *)v26 + 27) = 0;
  unint64_t result = TSWPLineFragment::clearTypesetterState(v26);
  ++*(void *)(a1 + 80);
  return result;
}

void sub_22373A8B8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::shared_ptr<TSWPLineFragment>::operator=[abi:ne180100](void *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  double v5 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v3;
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
  return a1;
}

double TSWPLayoutChore::pDropCapElevationHeight(id *this)
{
  uint64_t v2 = objc_msgSend((id)objc_msgSend(this[1], "textSourceForLayoutInRange:", this[20], this[21]), "characterStyleAtCharIndex:effectiveRange:", this[113], 0);
  id v3 = this[22];
  FontForStyle = TSWPFastCreateFontForStyle(v2, v3, [this[23] scaleTextPercent]);
  double v5 = (void *)[v3 valueForProperty:85];
  memset(v11, 0, sizeof(v11));
  int v6 = objc_msgSend(v5, "mode", TSWPFontHeightInfoForFont(FontForStyle, v11));
  [v5 amount];
  double Line = TSWPLineFragmentCalculateOffsetForNextLine((double *)v11, 0, v6, v7);
  unint64_t v9 = (unint64_t)this[116];
  if (FontForStyle) {
    CFRelease(FontForStyle);
  }
  return Line * (double)v9;
}

void TSWPLayoutChore::pLayoutDropCap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, long long *a6)
{
  long long v7 = a6[11];
  long long v43 = a6[10];
  long long v44 = v7;
  long long v8 = a6[13];
  long long v45 = a6[12];
  long long v46 = v8;
  long long v9 = a6[7];
  long long v39 = a6[6];
  long long v40 = v9;
  long long v10 = a6[9];
  long long v41 = a6[8];
  long long v42 = v10;
  long long v11 = a6[3];
  long long v35 = a6[2];
  long long v36 = v11;
  long long v12 = a6[5];
  long long v37 = a6[4];
  long long v38 = v12;
  long long v13 = a6[1];
  long long v33 = *a6;
  long long v34 = v13;
  uint64_t v14 = a1 + 864;
  uint64_t v15 = *(void *)(a1 + 904);
  unint64_t v16 = objc_msgSend(*(id *)(a1 + 8), "textSourceForLayoutInRange:", *(void *)(a1 + 160), *(void *)(a1 + 168));
  uint64_t v17 = [v16 characterStyleAtCharIndex:v15 effectiveRange:0];
  unint64_t v18 = *(void **)(a1 + 176);
  FontForStyle = TSWPFastCreateFontForStyle(v17, v18, [*(id *)(a1 + 184) scaleTextPercent]);
  v32[0] = v15;
  v32[1] = 1;
  [v16 filteredCoreTextAttributesFontScaleEffectiveRange:v32 filterDelegate:TSWPParagraphEnumerator::coreTextPropertiesFilterDelegate((TSWPParagraphEnumerator *)(a1 + 104))];
  if (v20 != 1.0 && v20 > 0.0 && FontForStyle)
  {
    double v21 = v20 * CTFontGetSize(FontForStyle);
    double v22 = (__CFString *)CTFontCopyPostScriptName(FontForStyle);
    CFRelease(FontForStyle);
    FontForStyle = (const __CTFont *)TSWPCreateFontWithName((uint64_t)v22, v21);
  }
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  double v23 = objc_msgSend(v18, "valueForProperty:", 85, TSWPFontHeightInfoForFont(FontForStyle, &v28));
  int v24 = [v23 mode];
  [v23 amount];
  double Line = TSWPLineFragmentCalculateOffsetForNextLine((double *)&v28, 0, v24, v25);
  if (*(_DWORD *)(a1 + 336) == 2) {
    double v27 = *(double *)&v28 + *(double *)(a1 + 376) * *(double *)(a1 + 344);
  }
  else {
    double v27 = *(double *)&v28 + *(double *)&v30 + fmax(*(double *)&v29, *((double *)&v28 + 1));
  }
  TSWPDropCapLayoutState::dropCapHeightWithGuess(v14, v27 + (double)(unint64_t)(*(void *)(a1 + 920) - 1) * Line);
  TSWPDropCapLayoutState::lineCapHeightWithGuess(v14, *((double *)&v31 + 1));
  operator new();
}

void sub_22373B1F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  double v22 = *(std::__shared_weak_count **)(v20 + 8);
  if (v22) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v22);
  }
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a20);
  }
  _Unwind_Resume(exception_object);
}

BOOL TSWPLayoutChore::pSetupNextParagraph(TSWPLayoutChore *this)
{
  uint64_t v2 = (TSWPParagraphEnumerator *)((char *)this + 104);
  BOOL isLastParagraph = TSWPParagraphEnumerator::isLastParagraph((TSWPParagraphEnumerator *)((char *)this + 104));
  if (!isLastParagraph)
  {
    TSWPParagraphEnumerator::operator++(v2);
    *((void *)this + 10) = TSWPParagraphEnumerator::paragraphTextRange(v2);
    *((unsigned char *)this + 411) = *((unsigned char *)this + 410);
    TSWPLayoutChore::pSetupStateForParagraphIndex(this, 0);
  }
  return !isLastParagraph;
}

id TSWPLayoutChore::pSetupTextSource(id *this)
{
  id result = this[1];
  this[35] = result;
  return result;
}

id *TSWPLayoutChore::pSetupStateForLineBalancing(id *this, id *a2, double a3, int a4, int a5, double a6)
{
  char v12 = ([this[257] autosizeFlags] & 0xC) != 0;

  return TSWPLineBalancingLayoutState::prepareForRestore(a2, this + 10, v12, a3, a4, a5, a6);
}

uint64_t TSWPLayoutChore::pCreateAttachmentPartitionLineFragment(TSWPLayoutChore *this, double a2, CGSize a3, int a4, BOOL *a5)
{
  double height = a3.height;
  double width = a3.width;
  if (!*((void *)this + 67))
  {
    long long v11 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v12 = objc_msgSend(NSString, "stringWithUTF8String:", "TSWPLineFragment *TSWPLayoutChore::pCreateAttachmentPartitionLineFragment(CGFloat, CGSize, uint, BOOL &)");
    objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLayoutChore.mm"), 4334, @"Bad _state.attachmentBeingPaginated");
  }
  double v13 = TSWPLayoutChore::pCalculateSpaceBefore(this, a4);
  if (a4) {
    double v14 = v13 + 1.0;
  }
  else {
    double v14 = v13;
  }
  [*((id *)this + 23) wpBounds];
  double v15 = v14 + a2;
  double v16 = *((double *)this + 36);
  if (width - (v16 + *((double *)this + 37)) >= 18.0) {
    double v17 = width - (v16 + *((double *)this + 37));
  }
  else {
    double v17 = 18.0;
  }
  if (height - v15 >= 0.0) {
    double v18 = height - v15;
  }
  else {
    double v18 = 0.0;
  }
  BOOL v42 = 0;
  if (objc_opt_respondsToSelector()) {
    uint64_t v19 = [*((id *)this + 257) parentLayoutForInlineAttachments];
  }
  else {
    uint64_t v19 = 0;
  }
  uint64_t v20 = objc_msgSend(*((id *)this + 68), "nextLayoutForSize:parentLayout:previousHint:horizontally:outFinished:", v19, *((void *)this + 95), 0, &v42, v17, v18);
  BOOL v21 = (objc_opt_respondsToSelector() & 1) == 0
     || ![*((id *)this + 2) shouldAllowFinishingPartionedAttachmentLayout]
     || v42;
  BOOL v42 = v21;
  if (v20)
  {
    uint64_t v22 = [v20 parent];
    if (v22) {
      BOOL v23 = v22 == v19;
    }
    else {
      BOOL v23 = 1;
    }
    if (v23)
    {
      [*((id *)this + 257) addAttachmentLayout:v20];
      [v20 validate];
      *a5 = !v42;
      [v20 frame];
      double v25 = v24;
      [v20 alignmentFrame];
      double rect_8 = v26;
      if (v26 > v17 + 1.0)
      {
        double v27 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v28 = objc_msgSend(NSString, "stringWithUTF8String:", "TSWPLineFragment *TSWPLayoutChore::pCreateAttachmentPartitionLineFragment(CGFloat, CGSize, uint, BOOL &)");
        [v27 handleFailureInFunction:v28, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLayoutChore.mm"), 4381, @"%@ returned too wide a layout for a partitioned attachment (%g > %g).", objc_opt_class(), *(void *)&rect_8, v17 + 1.0 file lineNumber description];
      }
      if (v25 <= 0.0)
      {
        long long v29 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v30 = objc_msgSend(NSString, "stringWithUTF8String:", "TSWPLineFragment *TSWPLayoutChore::pCreateAttachmentPartitionLineFragment(CGFloat, CGSize, uint, BOOL &)");
        objc_msgSend(v29, "handleFailureInFunction:file:lineNumber:description:", v30, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLayoutChore.mm"), 4385, @"Illegal partition layout height");
      }
      operator new();
    }
    uint64_t v33 = [MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v34 = objc_msgSend(NSString, "stringWithUTF8String:", "TSWPLineFragment *TSWPLayoutChore::pCreateAttachmentPartitionLineFragment(CGFloat, CGSize, uint, BOOL &)");
    uint64_t v35 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLayoutChore.mm"];
    long long v36 = @"Partitioned layout already has a different parent.";
    long long v37 = (void *)v33;
    uint64_t v38 = v34;
    uint64_t v39 = 4368;
  }
  else
  {
    uint64_t v31 = [MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v32 = objc_msgSend(NSString, "stringWithUTF8String:", "TSWPLineFragment *TSWPLayoutChore::pCreateAttachmentPartitionLineFragment(CGFloat, CGSize, uint, BOOL &)");
    uint64_t v35 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLayoutChore.mm"];
    long long v36 = @"partitioner failed to create layout";
    long long v37 = (void *)v31;
    uint64_t v38 = v32;
    uint64_t v39 = 4361;
  }
  [v37 handleFailureInFunction:v38 file:v35 lineNumber:v39 description:v36];
  return 0;
}

void sub_22373BA90(_Unwind_Exception *a1)
{
  MEMORY[0x223CB8F20](v1, 0x10A0C409F2EA496);
  _Unwind_Resume(a1);
}

uint64_t TSWPLayoutChore::pGetAlignmentForParagraphStyle(TSWPLayoutChore *this, TSWPParagraphStyle *a2)
{
  uint64_t result = [(TSSStyle *)a2 intValueForProperty:86];
  if (*((void *)this + 257)) {
    BOOL v4 = result == 4;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4)
  {
    double v5 = (void *)*((void *)this + 257);
    return [v5 naturalAlignment];
  }
  return result;
}

uint64_t TSWPLayoutChore::pCreateFullContainerAnchoredDrawableLineFragment(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, CGFloat *a9, unsigned char *a10)
{
  uint64_t v10 = MEMORY[0x270FA5388]();
  uint64_t v46 = *MEMORY[0x263EF8340];
  if (*(void *)(v10 + 80) != *(void *)(v10 + 88)) {
    return 0;
  }
  uint64_t v18 = v11;
  if (*(double *)(v11 + 88) != *(double *)(v11 + 80)) {
    return 0;
  }
  uint64_t v19 = v17;
  uint64_t v20 = v16;
  BOOL v21 = v15;
  uint64_t v22 = v14;
  BOOL v23 = v13;
  double v24 = v12;
  uint64_t v25 = v10;
  objc_opt_class();
  [*(id *)(v25 + 8) attachmentAtCharIndex:*(void *)(v25 + 80)];
  double v26 = (TSWPDrawableAttachment *)TSUDynamicCast();
  if (![(TSWPDrawableAttachment *)v26 isAnchored]) {
    return 0;
  }
  double v27 = [(TSWPDrawableAttachment *)v26 drawable];
  if (([*(id *)(v18 + 128) containsObject:v27] & 1) != 0
    || ![(TSDExteriorTextWrap *)[(TSDDrawableInfo *)v27 exteriorTextWrap] type]
    || [(TSDExteriorTextWrap *)[(TSDDrawableInfo *)v27 exteriorTextWrap] type] == 5
    || [(TSDExteriorTextWrap *)[(TSDDrawableInfo *)v27 exteriorTextWrap] isHTMLWrap]
    || (objc_opt_respondsToSelector() & 1) != 0
    && ([*(id *)(v25 + 2056) siblingTargetIsManipulatingDrawable:v27] & 1) != 0)
  {
    return 0;
  }
  if (!objc_msgSend(*(id *)(v18 + 112), "splitLine:lineSegmentRects:wrappableAttachments:ignoreFloatingGraphics:floatingCausedWrap:skipHint:userInfo:", v45, 0, (*(_DWORD *)(v25 + 56) & 0xFFFFFFFB) == 1, 0, 0, *(void *)(v18 + 120), *(double *)(v18 + 48), *(double *)(v18 + 56), *(double *)(v18 + 64), *(double *)(v18 + 72)))return 0; {
  id v28 = objc_alloc_init(MEMORY[0x263EFF980]);
  }
  int v43 = 0;
  long long v42 = *MEMORY[0x263F00148];
  long long v41 = *MEMORY[0x263F001B0];
  if (!TSWPLayoutChore::pPositionAnchoredAttachment(v25, *(CGFloat *)v18, *(CGFloat *)(v18 + 8), *(CGFloat *)(v18 + 16), *(CGFloat *)(v18 + 24), *(double *)(v18 + 88), *(CGFloat *)(v18 + 96), *(CGFloat *)(v18 + 104), v29, v30, v26, *(void *)(v25 + 80), v24, 1, &v44, v28, &v43, (double *)&v42, (uint64_t)&v41,
                        0))
    goto LABEL_13;
  double v40 = 0.0;
  if (objc_msgSend(*(id *)(v18 + 112), "splitLine:lineSegmentRects:wrappableAttachments:ignoreFloatingGraphics:floatingCausedWrap:skipHint:userInfo:", v45, v28, (*(_DWORD *)(v25 + 56) & 0xFFFFFFFB) == 1, 0, &v40, *(void *)(v18 + 120), *(double *)(v18 + 48), *(double *)(v18 + 56), *(double *)(v18 + 64), *(double *)(v18 + 72)))goto LABEL_13; {
  double MaxY = CGRectGetMaxY(*(CGRect *)v18);
  }
  double v34 = *(double *)(v18 + 88);
  double v35 = v40;
  if (v40 < 1.0) {
    double v35 = 1.0;
  }
  double v36 = floor(v34 + v35);
  if (MaxY <= v36)
  {
    double v37 = *(double *)(v18 + 40);
LABEL_23:
    TSWPLayoutChore::pFillAnchoredDrawableLineFragment(v25, v23, v22, (TSWPLineFragment **)&v39, *(CGFloat *)(v18 + 48), v34, *(CGFloat *)(v18 + 64), *(double *)(v18 + 32) + v37);
    TSWPLineFragmentArray::appendObject(*v21, &v39);
    ++*v20;
    uint64_t v38 = *(void *)(v25 + 80);
    *(void *)(v25 + 88) = v38;
    *(void *)double v24 = v38;
    *((void *)v24 + 1) = v38;
    *uint64_t v19 = 0;
    *a9 = CGRectGetMaxY(*(CGRect *)v18);
    *a10 = 1;
    if (*((void *)&v39 + 1)) {
      std::__shared_weak_count::__release_shared[abi:nn180100](*((std::__shared_weak_count **)&v39 + 1));
    }
    uint64_t v31 = 1;
    goto LABEL_14;
  }
  double v37 = *(double *)(v18 + 40);
  if (MaxY - v36 < v37) {
    goto LABEL_23;
  }
LABEL_13:
  uint64_t v31 = 0;
LABEL_14:

  return v31;
}

void sub_22373BE3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TSWPDropCapLayoutState::maxWidthFactor(TSWPDropCapLayoutState *this)
{
  unint64_t v2 = *((void *)this + 6);
  if (v2 >= objc_msgSend((id)objc_msgSend(*(id *)this, "spacings"), "count")) {
    id v3 = 0;
  }
  else {
    id v3 = objc_msgSend((id)objc_msgSend(*(id *)this, "spacings"), "objectAtIndexedSubscript:", *((void *)this + 6));
  }

  return [v3 maxWidthFactor];
}

uint64_t TSWPLayoutChore::pAddFootnotesForLineRange(id *this, _NSRange a2, double a3, int a4)
{
  unint64_t location = a2.location;
  unint64_t v8 = objc_msgSend(this[1], "footnoteRangeForTextRange:", a2.location, a2.length);
  if (v8 >= v8 + v9) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  unint64_t v10 = v8;
  uint64_t v11 = v9;
  while (1)
  {
    uint64_t v17 = 0;
    objc_msgSend(this[85], "addFootnoteReferenceStorage:", objc_msgSend((id)objc_msgSend(this[1], "footnoteAtFootnoteIndex:outCharIndex:", v10, &v17), "containedStorage"));
    if (a4)
    {
      [this[85] footnoteHeight];
      if (v12 > a3 && v17 != location) {
        break;
      }
    }
    ++v10;
    if (!--v11) {
      return 0x7FFFFFFFFFFFFFFFLL;
    }
  }
  if (location <= v17 + 1) {
    unint64_t v15 = v17 + 1;
  }
  else {
    unint64_t v15 = location;
  }
  if (location >= v17 + 1) {
    v16.unint64_t location = v17 + 1;
  }
  else {
    v16.unint64_t location = location;
  }
  v16.NSUInteger length = v15 - v16.location;
  TSWPLayoutChore::removeFootnotesInRange(this, v16);
  return v17;
}

uint64_t TSWPLayoutChore::pFindCharIndexOfRunThatMadeUsGrowToLineHeightGuess(TSWPLayoutChore *this, double a2, double a3, uint64_t a4)
{
  uint64_t v7 = *((void *)this + 21) + *((void *)this + 20);
  unint64_t v8 = objc_msgSend(*((id *)this + 1), "attachmentIndexRangeForTextRange:", a4, v7 - a4);
  if (v8 < v8 + v9)
  {
    unint64_t v10 = v8;
    uint64_t v11 = v9;
    while (1)
    {
      uint64_t v17 = 0;
      objc_opt_class();
      [*((id *)this + 1) attachmentAtAttachmentIndex:v10 outCharIndex:&v17];
      double v12 = (void *)TSUDynamicCast();
      if (v12)
      {
        double v13 = v12;
        if (([v12 isAnchored] & 1) == 0)
        {
          double v14 = objc_msgSend(*((id *)this + 257), "layoutForInlineDrawable:", objc_msgSend(v13, "drawable"));
          objc_msgSend((id)objc_msgSend(v14, "layoutController"), "validateLayoutWithDependencies:", v14);
          [v14 alignmentFrame];
          if (vabdd_f64(v15 + a3, a2) <= 1.0) {
            break;
          }
        }
      }
      ++v10;
      if (!--v11) {
        return v7;
      }
    }
    return v17;
  }
  return v7;
}

BOOL TSWPLayoutChore::pAnchoredGraphicInLineRange(uint64_t a1, unint64_t a2, uint64_t a3, TSWPLineFragmentArray **a4)
{
  unint64_t v4 = a2 + a3;
  if (a2 >= a2 + a3) {
    return 0;
  }
  if ((*(unsigned char *)(TSWPLineFragmentArray::objectAtIndex(*a4, a2) + 24) & 8) != 0) {
    return 1;
  }
  unint64_t v8 = a2 + 1;
  uint64_t v9 = a3 - 1;
  do
  {
    unint64_t v10 = v8;
    if (!v9) {
      break;
    }
    uint64_t v11 = TSWPLineFragmentArray::objectAtIndex(*a4, v8);
    unint64_t v8 = v10 + 1;
    --v9;
  }
  while ((*(unsigned char *)(v11 + 24) & 8) == 0);
  return v10 < v4;
}

unint64_t TSWPLayoutChore::removeFootnotesInRange(id *this, _NSRange a2)
{
  unint64_t result = objc_msgSend(this[1], "footnoteRangeForTextRange:", a2.location, a2.length);
  if (result < result + v4)
  {
    unint64_t v5 = result;
    uint64_t v6 = v4;
    do
    {
      unint64_t result = objc_msgSend(this[85], "removeFootnoteReferenceStorage:", objc_msgSend((id)objc_msgSend(this[1], "footnoteAtFootnoteIndex:outCharIndex:", v5++, 0), "containedStorage"));
      --v6;
    }
    while (v6);
  }
  return result;
}

uint64_t TSWPLayoutChore::pPullDownWidowsFromPreviousColumn(TSWPLayoutChore *this, TSWPLayoutState *a2)
{
  uint64_t v4 = *((void *)this + 30);
  unint64_t v5 = (void *)*((void *)this + 257);
  if (v4)
  {
    uint64_t v6 = objc_msgSend((id)objc_msgSend(v5, "columns"), "objectAtIndexedSubscript:", *((void *)this + 30) - 1);
    uint64_t v7 = 0;
    if (!v6) {
      return 0;
    }
  }
  else
  {
    uint64_t v6 = (void *)[v5 previousTargetLastColumn];
    uint64_t v7 = (TSWPTopicNumberHints *)[*((id *)this + 257) previousTargetTopicNumbers];
    if (!v6) {
      return 0;
    }
  }
  unint64_t location = (char *)[v6 nextWidowPullsDownFromCharIndex];
  uint64_t v9 = [v6 startCharIndex];
  if (location == *(char **)a2) {
    return 0;
  }
  NSUInteger v11 = v9;
  TSWPLayoutState::TSWPLayoutState((TSWPLayoutState *)v44, a2);
  double v12 = (void *)*((void *)this + 1);
  uint64_t v13 = [*((id *)this + 3) styleProvider];
  if (v12) {
    [v12 paragraphEnumeratorAtCharIndex:location styleProvider:v13];
  }
  else {
    memset(&v43, 0, sizeof(v43));
  }
  if ((char *)TSWPParagraphEnumerator::paragraphTextRange(&v43) == location)
  {
    for (char i = 0; !TSWPParagraphEnumerator::isFirstParagraph(&v43); char i = 1)
    {
      TSWPParagraphEnumerator::operator--(&v43);
      double v15 = (void *)TSWPParagraphEnumerator::paragraphStyle(&v43, &v42);
      if (v42.location <= v11 || ![v15 intValueForProperty:90]) {
        break;
      }
      unint64_t location = (char *)v42.location;
      TSWPParagraphEnumerator::operator--(v45);
      *(_NSRange *)NSRange v47 = v42;
      if (!v7) {
        uint64_t v7 = (TSWPTopicNumberHints *)((char *)this + 816);
      }
      TSWPTopicNumberHints::backUpByOneParagraph((TSWPTopicNumberHints *)this + 16, v7, *((TSWPStorage **)this + 1));
      unint64_t v16 = *((void *)this + 105);
      if (*((void *)this + 99) < v16 && v16 != 0x7FFFFFFFFFFFFFFFLL) {
        TSWPTopicNumberHints::operator=((TSWPTopicNumberHints *)this + 17, (TSWPTopicNumberHints *)this + 16);
      }
    }
  }
  else
  {
    char i = 0;
  }
  uint64_t v17 = [v6 range];
  if ((unint64_t)location <= v17 + v18) {
    uint64_t v19 = (char *)(v17 + v18);
  }
  else {
    uint64_t v19 = location;
  }
  if ((unint64_t)location >= v17 + v18) {
    uint64_t v20 = (char *)(v17 + v18);
  }
  else {
    uint64_t v20 = location;
  }
  objc_msgSend(v6, "trimToCharIndex:inTarget:removeAutoNumberFootnoteCount:", location, *((void *)this + 257), objc_msgSend(*((id *)this + 1), "autoNumberFootnoteCountForRange:", v20, v19 - v20));
  if (i)
  {
    *(_OWORD *)((char *)this + 104) = v45[0];
    *(_OWORD *)((char *)this + 120) = v45[1];
    *(_OWORD *)((char *)this + 136) = v45[2];
    *((unsigned char *)this + 152) = v46;
    *((_OWORD *)this + 10) = *(_OWORD *)v47;
    *((void *)this + 10) = location;
    TSWPLayoutChore::pSetupStateForParagraphIndex(this, 0);
    if (v7) {
      BOOL v21 = v7;
    }
    else {
      BOOL v21 = (TSWPTopicNumberHints *)((char *)this + 816);
    }
    TSWPTopicNumberHints::operator=((TSWPTopicNumberHints *)this + 16, v21);
    TSWPTopicNumberHints::advanceToCharIndex((TSWPTopicNumberHints *)this + 16, *((void *)this + 10), *((TSWPStorage **)this + 1));
  }
  else
  {
    uint64_t v22 = (char *)(location - (char *)v47[0]);
    if (location >= v47[0])
    {
      v44[0] = location;
      double v48 = (char *)(location - (char *)v47[0]);
      if ((unint64_t)location > *((void *)this + 8))
      {
        BOOL v23 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v24 = [NSString stringWithUTF8String:"BOOL TSWPLayoutChore::pPullDownWidowsFromPreviousColumn(TSWPLayoutState *)"];
        objc_msgSend(v23, "handleFailureInFunction:file:lineNumber:description:", v24, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLayoutChore.mm"), 4591, @"Bad backUpLayoutState.charIndex");
        uint64_t v22 = v48;
      }
      if (v22 >= v47[1])
      {
        uint64_t v25 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v26 = [NSString stringWithUTF8String:"BOOL TSWPLayoutChore::pPullDownWidowsFromPreviousColumn(TSWPLayoutState *)"];
        objc_msgSend(v25, "handleFailureInFunction:file:lineNumber:description:", v26, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLayoutChore.mm"), 4592, @"Bad typesetterCharIndex");
      }
      BOOL v49 = v44[0] == v47[0];
      objc_opt_class();
      double v27 = (void *)TSUDynamicCast();
      id v28 = v27;
      if (v27)
      {
        [v27 wpBounds];
        fixSpaceAfterForParagraphBorder((uint64_t)this + 80, (TSWPLineFragmentArray **)[v28 lineFragmentArray], v29, v30, v31, v32);
        [v28 clearAdornments];
        TSWPLayoutChore::addParagraphAdornmentsToColumn(v28, *((void **)this + 24), [*((id *)this + 3) styleProvider]);
        uint64_t v33 = (void *)*((void *)this + 24);
        [*((id *)this + 3) styleProvider];
        TSWPLayoutChore::addChangeBarAdornmentsToColumn(v28, v33);
      }
      TSWPLayoutChore::pRestoreStateFromOldState(this, v44);
      (*(void (**)(void, void))(**((void **)this + 253) + 32))(*((void *)this + 253), *((void *)this + 72));
      if (location == (char *)TSWPParagraphEnumerator::paragraphTextRange((TSWPParagraphEnumerator *)((char *)this + 104)))
      {
        if (v7) {
          double v34 = v7;
        }
        else {
          double v34 = (TSWPTopicNumberHints *)((char *)this + 816);
        }
        TSWPTopicNumberHints::backUpByOneParagraph((TSWPTopicNumberHints *)this + 16, v34, *((TSWPStorage **)this + 1));
      }
      TSWPTopicNumberHints::advanceToCharIndex((TSWPTopicNumberHints *)this + 16, *((void *)this + 10), *((TSWPStorage **)this + 1));
    }
  }
  unint64_t v35 = *((void *)this + 99);
  unint64_t v36 = *((void *)this + 105);
  BOOL v37 = v35 < v36 || v35 == 0x7FFFFFFFFFFFFFFFLL;
  if (v37 && v36 != 0x7FFFFFFFFFFFFFFFLL) {
    TSWPTopicNumberHints::operator=((TSWPTopicNumberHints *)this + 17, (TSWPTopicNumberHints *)this + 16);
  }
  [*((id *)this + 23) setStartCharIndex:*((void *)this + 10)];
  uint64_t v38 = *((void *)this + 251) - *((void *)this + 250);
  if (v38)
  {
    uint64_t v39 = v38 / 688;
    uint64_t v40 = 688 * (v38 / 688) - 688;
    do
    {
      long long v41 = (id *)(*((void *)this + 250) + v40);
      if ((unint64_t)*v41 > *((void *)this + 10)) {
        TSWPLayoutState::operator=(v41, (id *)this + 10);
      }
      v40 -= 688;
      --v39;
    }
    while (v39);
  }
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator(&v43);
  TSWPLayoutState::~TSWPLayoutState((TSWPLayoutState *)v44);
  return 1;
}

void sub_22373C6E8(_Unwind_Exception *a1, uint64_t a2, TSWPParagraphEnumerator *a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator((TSWPParagraphEnumerator *)va);
  TSWPLayoutState::~TSWPLayoutState((TSWPLayoutState *)va1);
  _Unwind_Resume(a1);
}

uint64_t TSWPLayoutChore::pHandleOrphanAndKeepTogether(uint64_t a1, TSWPLineFragmentArray **a2, _WORD *a3, unsigned char *a4, NSUInteger a5, CGFloat a6, CGFloat a7, CGFloat a8, CGFloat a9)
{
  uint64_t Object = TSWPLineFragmentArray::lastObject(*a2);
  uint64_t v19 = (TSWPLineFragment *)Object;
  BOOL v21 = Object
     && (unint64_t v20 = *(void *)(a1 + 160), *(void *)Object >= v20)
     && *(void *)(Object + 8) + *(void *)Object < *(void *)(a1 + 168) + v20;
  if (!*(unsigned char *)(a1 + 409) && !*(unsigned char *)(a1 + 408) && !*(unsigned char *)(a1 + 410) && (!*(unsigned char *)(a1 + 411) || v21)) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  if (Object && (*(unsigned char *)(Object + 24) & 1) != 0) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  double v51 = a3;
  double v52 = a4;
  uint64_t v23 = TSWPLineFragmentArray::count(*a2);
  NSUInteger v24 = *(void *)(a1 + 80);
  if (v21)
  {
    LineIndexForCharIndeCGFloat x = TSWPLineFragmentArray::findLineIndexForCharIndex(*a2, *(void *)(a1 + 160));
    NSUInteger v26 = *(void *)TSWPLineFragmentArray::objectAtIndex(*a2, LineIndexForCharIndex);
    if (v26 > a5 && (*(unsigned char *)(a1 + 410) || *(unsigned char *)(a1 + 409)))
    {
      NSUInteger v27 = v23 - LineIndexForCharIndex;
      NSUInteger v24 = *(void *)(a1 + 160);
      goto LABEL_23;
    }
    if (*(unsigned char *)(a1 + 408))
    {
      v58.origin.CGFloat x = a6;
      v58.origin.CGFloat y = a7;
      v58.size.double width = a8;
      v58.size.double height = a9;
      if (!TSWPLineFragment::preventWidowCorrection(v19, v58))
      {
        unint64_t v50 = v23 - LineIndexForCharIndex;
        if (v23 - LineIndexForCharIndex == 1 && v26 > a5)
        {
          NSUInteger v24 = *(void *)(a1 + 160);
          uint64_t v28 = 0x7FFFFFFFFFFFFFFFLL;
          NSUInteger v27 = 1;
          goto LABEL_24;
        }
        if (v50 == 2 && v26 > a5)
        {
          uint64_t v19 = (TSWPLineFragment *)TSWPLineFragmentArray::objectAtIndex(*a2, LineIndexForCharIndex);
          v59.origin.CGFloat x = a6;
          v59.origin.CGFloat y = a7;
          v59.size.double width = a8;
          v59.size.double height = a9;
          if (TSWPLineFragment::preventWidowCorrection(v19, v59)) {
            goto LABEL_18;
          }
        }
        else if (v50 < 3)
        {
          goto LABEL_18;
        }
        NSUInteger v27 = 0;
        LineIndexForCharIndeCGFloat x = v23 - 1;
        uint64_t v28 = *(void *)v19;
        goto LABEL_24;
      }
    }
  }
LABEL_18:
  NSUInteger v27 = 0;
  LineIndexForCharIndeCGFloat x = v23 - 1;
LABEL_23:
  uint64_t v28 = 0x7FFFFFFFFFFFFFFFLL;
LABEL_24:
  TSWPParagraphEnumerator::TSWPParagraphEnumerator(&v56, (const TSWPParagraphEnumerator *)(a1 + 104));
  int v29 = !v21;
  if (v27) {
    int v29 = 1;
  }
  if (v29 == 1 && v24 && v24 < *(void *)(a1 + 64))
  {
    _NSRange v55 = *(_NSRange *)(a1 + 160);
    TSWPParagraphEnumerator::TSWPParagraphEnumerator(&v54, &v56);
    char v30 = 0;
    while (1)
    {
      char v31 = v30;
      if (TSWPParagraphEnumerator::isFirstParagraph(&v54)) {
        break;
      }
      TSWPParagraphEnumerator::operator--(&v54);
      CGFloat v32 = (void *)TSWPParagraphEnumerator::paragraphStyle(&v54, &v55);
      if (v55.length + v55.location <= a5) {
        break;
      }
      int v33 = [v32 intValueForProperty:90];
      char v30 = 1;
      if (!v33)
      {
        if (v31)
        {
          NSUInteger v24 = v55.length + v55.location;
          LineIndexForCharIndeCGFloat x = TSWPLineFragmentArray::findLineIndexForCharIndex(*a2, v55.length + v55.location);
          TSWPParagraphEnumerator::next(&v54, (uint64_t)&v53);
          NSUInteger v27 = v23 - LineIndexForCharIndex;
          TSWPParagraphEnumerator v56 = v53;
          TSWPParagraphEnumerator::~TSWPParagraphEnumerator(&v53);
        }
        break;
      }
    }
    TSWPParagraphEnumerator::~TSWPParagraphEnumerator(&v54);
  }
  if (v27)
  {
    if (!LineIndexForCharIndex)
    {
      double v34 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v35 = objc_msgSend(NSString, "stringWithUTF8String:", "TSWPCharIndex TSWPLayoutChore::pHandleOrphanAndKeepTogether(const line_fragment_array_ptr &, unichar *, BOOL *, CGRect, TSWPCharIndex)");
      objc_msgSend(v34, "handleFailureInFunction:file:lineNumber:description:", v35, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLayoutChore.mm"), 5557, @"Trying to push down the first line of a column");
    }
    for (uint64_t i = 0; i != v27; ++i)
    {
      if (*(void *)(TSWPLineFragmentArray::objectAtIndex(*a2, LineIndexForCharIndex + i) + 176)) {
        TSWPTopicNumberHints::backUpByOneParagraph((TSWPTopicNumberHints *)(a1 + 768), (TSWPTopicNumberHints *)(a1 + 816), *(TSWPStorage **)(a1 + 8));
      }
    }
    (*(void (**)(void))(**(void **)(a1 + 2024) + 24))(*(void *)(a1 + 2024));
    *(void *)(a1 + 80) = v24;
    long long v37 = *(_OWORD *)&v56.var2;
    *(_OWORD *)(a1 + 104) = *(_OWORD *)&v56.var0;
    *(_OWORD *)(a1 + 120) = v37;
    *(_OWORD *)(a1 + 136) = *(_OWORD *)&v56.var4;
    *(unsigned char *)(a1 + 152) = v56.var6;
    TSWPLayoutChore::pSetupStateForParagraphIndex((TSWPLayoutChore *)a1, 0);
    uint64_t v38 = *(void *)(a1 + 160);
    if (v38)
    {
      uint64_t v39 = v38 - 1;
      uint64_t v40 = [*(id *)(a1 + 8) characterAtIndex:v38 - 1];
      __int16 v41 = v40;
      uint64_t v42 = IsParagraphBreakingCharacter(v40);
      if (v42)
      {
        if ([*(id *)(a1 + 8) hasColumnStyleForParagraphBreakAtCharIndex:v39]) {
          uint64_t v42 = 1;
        }
        else {
          uint64_t v42 = [*(id *)(a1 + 8) hasSectionForParagraphBreakAtCharIndex:v39];
        }
      }
    }
    else
    {
      __int16 v41 = 0;
      uint64_t v42 = 0;
    }
    *double v51 = v41;
    *double v52 = v42;
    if (TSWPLayoutChore::pAnchoredGraphicInLineRange(v42, LineIndexForCharIndex, v27, a2)) {
      *(unsigned char *)(a1 + 640) = 1;
    }
    NSUInteger v43 = *(void *)TSWPLineFragmentArray::objectAtIndex(*a2, LineIndexForCharIndex);
    uint64_t v44 = (void *)TSWPLineFragmentArray::objectAtIndex(*a2, v27 + LineIndexForCharIndex - 1);
    uint64_t v45 = v44[1];
    NSUInteger v46 = v45 + *v44;
    if (v43 <= v46) {
      NSUInteger v47 = v45 + *v44;
    }
    else {
      NSUInteger v47 = v43;
    }
    if (v43 >= v46) {
      v48.unint64_t location = v46;
    }
    else {
      v48.unint64_t location = v43;
    }
    v48.NSUInteger length = v47 - v48.location;
    TSWPLayoutChore::removeFootnotesInRange((id *)a1, v48);
    v57.unint64_t location = LineIndexForCharIndex;
    v57.NSUInteger length = v27;
    TSWPLineFragmentArray::removeObjectsInRange(*a2, v57);
  }
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator(&v56);
  return v28;
}

void sub_22373CBCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, TSWPParagraphEnumerator *a10, uint64_t a11, uint64_t a12, TSWPParagraphEnumerator *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
}

uint64_t TSWPLayoutChore::pParagraphRunsRightToLeftAtCharIndex(TSWPLayoutChore *this, NSUInteger a2)
{
  uint64_t v4 = (TSWPParagraphEnumerator *)((char *)this + 104);
  NSUInteger v5 = TSWPParagraphEnumerator::paragraphTextRange((TSWPParagraphEnumerator *)((char *)this + 104));
  if (a2 < v5 || a2 - v5 >= v6)
  {
    uint64_t v8 = (void *)*((void *)this + 1);
    uint64_t v9 = [*((id *)this + 3) styleProvider];
    if (v8) {
      [v8 paragraphEnumeratorAtCharIndex:a2 styleProvider:v9];
    }
    else {
      memset(&v12, 0, sizeof(v12));
    }
    uint64_t v11 = TSWPParagraphEnumerator::paragraphRunsRightToLeft(&v12);
    TSWPParagraphEnumerator::~TSWPParagraphEnumerator(&v12);
    return v11;
  }
  else
  {
    return TSWPParagraphEnumerator::paragraphRunsRightToLeft(v4);
  }
}

void sub_22373CCDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

double TSWPLayoutChore::pMinimumLayoutHeightForColumnRange(id *this, _NSRange a2, BOOL *a3)
{
  unint64_t v20 = a3;
  NSUInteger v3 = a2.location + a2.length;
  if (a2.location >= a2.location + a2.length)
  {
    char v6 = 0;
    double v7 = 0.0;
    goto LABEL_17;
  }
  NSUInteger location = a2.location;
  char v6 = 0;
  double v7 = 0.0;
  NSUInteger v21 = a2.location + a2.length;
  do
  {
    uint64_t v8 = objc_msgSend((id)objc_msgSend(this[257], "columns", v20), "objectAtIndexedSubscript:", location);
    [v8 minimumHeightForLayoutOnPage];
    double Height = v9;
    if (v9 > 0.0) {
      goto LABEL_14;
    }
    unint64_t v11 = [v8 range];
    NSUInteger v13 = v11 + v12;
    if (v11 >= v11 + v12) {
      goto LABEL_14;
    }
    NSUInteger v14 = v11;
    NSUInteger v15 = v12;
    NSUInteger v16 = v11;
    while (1)
    {
      v22.NSUInteger location = [this[1] attachmentRangeForCharIndex:v16 forwards:1];
      v23.NSUInteger location = v14;
      v23.NSUInteger length = v15;
      NSRange v17 = NSIntersectionRange(v22, v23);
      if (v17.length != 1)
      {
        if (!v17.length) {
          goto LABEL_13;
        }
        goto LABEL_10;
      }
      objc_opt_class();
      [this[1] attachmentAtCharIndex:v17.location];
      uint64_t v18 = (void *)TSUDynamicCast();
      if ([v18 isHTMLWrap]) {
        break;
      }
LABEL_10:
      NSUInteger v16 = v17.location + v17.length;
      if (v17.location + v17.length >= v13) {
        goto LABEL_13;
      }
    }
    objc_msgSend((id)objc_msgSend((id)objc_msgSend(this[257], "validatedLayoutForAnchoredDrawable:", objc_msgSend(v18, "drawable")), "geometry"), "frame");
    double Height = CGRectGetHeight(v24);
LABEL_13:
    NSUInteger v3 = v21;
LABEL_14:
    double v7 = fmax(v7, Height);
    v6 |= [v8 countLines] != 0;
    ++location;
  }
  while (location != v3);
LABEL_17:
  if (v20) {
    *unint64_t v20 = v6 & 1;
  }
  return v7;
}

void TSWPLayoutChore::pCreateLineRefsAfterColumnBalancing(uint64_t a1, uint64_t a2, int a3)
{
  char v5 = [*(id *)(a1 + 2056) autosizeFlags];
  unint64_t v6 = *(void *)(a2 + 144);
  if (v6 < *(void *)(a2 + 152) + v6)
  {
    char v7 = 0;
    int v25 = v5 & 0xC;
    uint64_t v24 = a1 + 768;
    while (1)
    {
      uint64_t v8 = objc_msgSend((id)objc_msgSend(*(id *)(a1 + 2056), "columns", v24), "objectAtIndexedSubscript:", v6);
      *(void *)(a2 + 104) = v8;
      *(void *)(a2 + 160) = v6;
      uint64_t v9 = [v8 countLines];
      if (v9) {
        break;
      }
LABEL_15:
      TSWPLayoutChore::pPostProcessAttachments(a1, (TSWPLineFragment ****)[v8 lineFragmentArray]);
      if (++v6 >= *(void *)(a2 + 152) + *(void *)(a2 + 144)) {
        return;
      }
    }
    uint64_t v10 = v9;
    uint64_t v11 = 0;
    while (1)
    {
      NSUInteger v12 = (TSWPLineFragment *)[v8 lineFragmentAtIndex:v11];
      if (*((void *)v12 + 25) == *((void *)v12 + 24)) {
        break;
      }
LABEL_14:
      if (v10 == ++v11) {
        goto LABEL_15;
      }
    }
    NSUInteger v13 = v12;
    NSUInteger v14 = *(void *)v12;
    *(void *)a2 = *(void *)v12;
    if (v7)
    {
      NSUInteger v15 = TSWPParagraphEnumerator::paragraphTextRange((TSWPParagraphEnumerator *)(a2 + 24));
      if (v14 < v15 + v16)
      {
LABEL_13:
        TSWPCoreTextTypesetter::createLineRefsForLineFragment(*(void *)(a1 + 2024), v13, a2, v25 != 0, a3);
        char v7 = 1;
        goto LABEL_14;
      }
      NSUInteger v14 = *(void *)a2;
    }
    v28[0] = a1 + 872;
    v28[1] = a1 + 1936;
    NSRange v17 = *(void **)(a1 + 8);
    uint64_t v18 = [*(id *)(a1 + 24) styleProvider];
    if (v17) {
      [v17 paragraphEnumeratorAtCharIndex:v14 styleProvider:v18];
    }
    else {
      memset(&v27, 0, sizeof(v27));
    }
    long long v19 = *(_OWORD *)&v27.var2;
    *(_OWORD *)(a2 + 24) = *(_OWORD *)&v27.var0;
    *(_OWORD *)(a2 + 40) = v19;
    *(_OWORD *)(a2 + 56) = *(_OWORD *)&v27.var4;
    *(unsigned char *)(a2 + 72) = v27.var6;
    TSWPParagraphEnumerator::~TSWPParagraphEnumerator(&v27);
    TSWPLayoutChore::pSetupStateForParagraphIndex((TSWPLayoutChore *)a1, (TSWPLayoutState *)a2);
    unint64_t v20 = *(TSWPCoreTextTypesetter **)(a1 + 2024);
    double v21 = *MEMORY[0x263F001B0];
    double v22 = *(double *)(MEMORY[0x263F001B0] + 8);
    unint64_t v23 = TSWPParagraphEnumerator::relevantParagraphIndex((TSWPParagraphEnumerator *)(a2 + 24));
    TSWPCoreTextTypesetter::beginParagraphLayout(v20, a2, v24, v28, v23, v21, v22);
    goto LABEL_13;
  }
}

double TSWPLayoutChore::pInvalidateRect(TSWPLayoutChore *this, CGRect a2, CGRect a3, TSWPColumn *a4, int a5, int a6)
{
  double height = a3.size.height;
  CGFloat width = a3.size.width;
  double y = a3.origin.y;
  CGFloat x = a3.origin.x;
  CGFloat v11 = a2.size.height;
  CGFloat v12 = a2.size.width;
  CGFloat v13 = a2.origin.y;
  CGFloat v14 = a2.origin.x;
  if (a5)
  {
    [(TSWPColumn *)a4 wpBounds];
    v25.origin.double y = y;
    v25.size.double height = height;
    v27.origin.CGFloat x = x;
    v27.origin.double y = y;
    v27.size.CGFloat width = width;
    v27.size.double height = height;
    CGRect v26 = CGRectUnion(v25, v27);
    CGFloat x = v26.origin.x;
    double y = v26.origin.y;
    CGFloat width = v26.size.width;
    double height = v26.size.height;
  }
  if (a6) {
    double v15 = y + -6.0;
  }
  else {
    double v15 = y;
  }
  if (a6) {
    double v16 = height + 12.0;
  }
  else {
    double v16 = height;
  }
  CGFloat v17 = v14;
  CGFloat v18 = v13;
  CGFloat v19 = v12;
  CGFloat v20 = v11;
  CGFloat v21 = x;
  CGFloat v22 = width;

  *(void *)&double result = (unint64_t)CGRectUnion(*(CGRect *)&v17, *(CGRect *)(&v15 - 1));
  return result;
}

uint64_t TSWPLayoutChore::pGetColumnMetricsAtCharIndex(id *this, uint64_t a2, _NSRange *a3)
{
  return [this[257] columnMetricsForCharIndex:a2 outRange:a3];
}

uint64_t pLayoutGeometryIsBeingManipulated(TSDLayout *a1)
{
  uint64_t result = [(TSDLayout *)a1 isBeingManipulated];
  if (result)
  {
    if (objc_msgSend((id)objc_msgSend((id)objc_msgSend(-[TSDLayout layoutController](a1, "layoutController"), "canvas"), "canvasController"), "isInInspectorDynamicOperation"))
    {
      return 0;
    }
    else
    {
      NSUInteger v3 = (objc_class *)objc_opt_class();
      if (![NSStringFromClass(v3) isEqualToString:@"TSTLayout"]
        || (uint64_t result = objc_msgSend((id)objc_msgSend((id)objc_msgSend(-[TSDLayout layoutController](a1, "layoutController"), "canvas"), "canvasController"), "isInDynamicOperation"), result))
      {
        objc_opt_class();
        uint64_t v4 = (void *)TSUDynamicCast();
        if (v4) {
          return [v4 isStrokeBeingManipulated] ^ 1;
        }
        else {
          return 1;
        }
      }
    }
  }
  return result;
}

double TSWPLayoutChore::pCalculateAttachmentPosition(id *a1, TSWPDrawableAttachment *a2, unint64_t a3, const TSWPLayoutState *a4, char a5, double *a6, CGFloat a7, CGFloat a8, CGFloat a9, CGFloat a10, double a11, CGFloat a12, CGFloat a13, double a14, double a15)
{
  uint64_t v28 = [(TSDDrawableInfo *)[(TSWPDrawableAttachment *)a2 drawable] exteriorTextWrap];
  if ([(TSDExteriorTextWrap *)v28 isHTMLWrap])
  {
    int v29 = [(TSDExteriorTextWrap *)v28 direction];
    if (v29)
    {
      if (v29 == 2)
      {
        v44.origin.CGFloat x = a7;
        v44.origin.double y = a8;
        v44.size.CGFloat width = a9;
        v44.size.double height = a10;
        double MinX = CGRectGetMidX(v44) + a15 * -0.5;
      }
      else if (v29 == 1)
      {
        double MinX = *a6;
        *a6 = a15 + *a6;
      }
      else
      {
        v46.origin.CGFloat x = a7;
        v46.origin.double y = a8;
        v46.size.CGFloat width = a9;
        v46.size.double height = a10;
        double MinX = CGRectGetMinX(v46);
      }
    }
    else
    {
      double MinX = a6[1] - a15;
      a6[1] = MinX;
    }
  }
  else
  {
    [(TSWPDrawableAttachment *)a2 hOffset];
    [(TSWPDrawableAttachment *)a2 vOffset];
    int v31 = [(TSWPDrawableAttachment *)a2 hOffsetType];
    if (v31 == 2)
    {
      CGFloat v32 = a10;
      objc_opt_class();
      double v34 = (void *)TSUDynamicCast();
      [(TSWPDrawableAttachment *)a2 hOffset];
      double v36 = v35;
      if (v34) {
        [v34 frame];
      }
      else {
        double v37 = 0.0;
      }
      double MinX = v36 - v37;
    }
    else if (v31 == 1)
    {
      v45.origin.CGFloat x = a7;
      v45.origin.double y = a8;
      v45.size.CGFloat width = a9;
      CGFloat v32 = a10;
      v45.size.double height = a10;
      double v38 = CGRectGetMinX(v45);
      [(TSWPDrawableAttachment *)a2 hOffset];
      double MinX = v38 + v39;
    }
    else
    {
      if (v31)
      {
        v47.origin.CGFloat x = a7;
        v47.origin.double y = a8;
        v47.size.CGFloat width = a9;
        CGFloat v32 = a10;
        v47.size.double height = a10;
        double v33 = CGRectGetMinX(v47);
      }
      else
      {
        CGFloat v32 = a10;
        [(TSWPDrawableAttachment *)a2 hOffset];
      }
      double MinX = v33;
    }
    int v40 = [(TSWPDrawableAttachment *)a2 vOffsetType];
    if (v40 == 1)
    {
      objc_opt_class();
      __int16 v41 = (void *)TSUDynamicCast();
      [(TSWPDrawableAttachment *)a2 vOffset];
      if (v41) {
        [v41 frame];
      }
    }
    else if (v40)
    {
      v48.origin.CGFloat x = a7;
      v48.origin.double y = a8;
      v48.size.CGFloat width = a9;
      v48.size.double height = v32;
      CGRectGetMinY(v48);
    }
    else if ([a1[23] startCharIndex] <= a3)
    {
      [(TSWPDrawableAttachment *)a2 vOffset];
    }
  }
  v43.CGFloat width = a12;
  v43.double height = a13;
  TSWPLayoutChore::pAnchoredDrawableVerticalAdjustment(a1, a2, a4, v43, a5);
  return MinX;
}

double TSWPLayoutChore::pAnchoredDrawableVerticalAdjustment(id *this, TSWPDrawableAttachment *a2, const TSWPLayoutState *a3, CGSize a4, char a5)
{
  double height = a4.height;
  double v10 = 0.0;
  if ([(TSWPDrawableAttachment *)a2 vOffsetType] != 1)
  {
    CGFloat v11 = [(TSDDrawableInfo *)[(TSWPDrawableAttachment *)a2 drawable] exteriorTextWrap];
    [(TSDExteriorTextWrap *)v11 margin];
    double v13 = fmin(v12, height * 0.5);
    if (![(TSDExteriorTextWrap *)v11 isHTMLWrap])
    {
      double v14 = 0.0;
LABEL_9:
      double v10 = v13 + v14;
      goto LABEL_10;
    }
    if ((a5 & 1) == 0)
    {
      double v14 = 0.0;
      if (*(void *)a3 == *((void *)a3 + 10))
      {
        double v15 = *((double *)a3 + 38);
        BOOL isFirstParagraph = TSWPParagraphEnumerator::isFirstParagraph((TSWPParagraphEnumerator *)((char *)a3 + 24));
        double v17 = v15;
        if (!isFirstParagraph)
        {
          TSWPParagraphEnumerator::previous((TSWPParagraphEnumerator *)((char *)a3 + 24), (uint64_t)&v25);
          CGFloat v18 = (void *)TSWPParagraphEnumerator::paragraphStyle(&v25, 0);
          TSWPParagraphEnumerator::~TSWPParagraphEnumerator(&v25);
          [v18 floatValueForProperty:88];
          double v20 = (float)(v19 * (float)((float)(unint64_t)[this[23] scaleTextPercent] / 100.0));
          double v15 = fmax(*((double *)a3 + 38), v20);
          double v17 = v15 - v20;
        }
        double v14 = v17 + 0.0;
        double v13 = fmax(v13 - v15, 0.0);
      }
      goto LABEL_9;
    }
  }
LABEL_10:
  [(TSWPDrawableAttachment *)a2 drawable];
  if (objc_opt_respondsToSelector())
  {
    CGFloat v21 = (void *)[(TSDDrawableInfo *)[(TSWPDrawableAttachment *)a2 drawable] stroke];
    if (v21)
    {
      [v21 outsets];
      double v10 = v10 + v22;
    }
  }
  CharacterStyleAtCharIndeCGFloat x = TSWPLayoutChore::pGetCharacterStyleAtCharIndex(this, *(void *)a3);
  return v10
       + TSWPAttachmentVAlignmentCorrection(-[TSWPDrawableAttachment vAlignment](a2, "vAlignment"), CharacterStyleAtCharIndex, *((void **)a3 + 12), [*((id *)a3 + 13) scaleTextPercent]);
}

void sub_22373D69C(_Unwind_Exception *a1, TSWPParagraphEnumerator *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t TSWPLayoutChore::pPositionAnchoredAttachment(uint64_t a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, double a6, CGFloat a7, CGFloat a8, uint64_t a9, uint64_t a10, TSWPDrawableAttachment *a11, unint64_t a12, const TSWPLayoutState *a13, char a14, void *a15, void *a16, _DWORD *a17, double *a18, uint64_t a19, uint64_t a20)
{
  uint64_t v79 = *MEMORY[0x263EF8340];
  char v30 = (void *)[*(id *)(a1 + 2056) currentAnchoredDrawableLayouts];
  long long v74 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  uint64_t v31 = [v30 countByEnumeratingWithState:&v74 objects:v78 count:16];
  if (v31)
  {
    uint64_t v32 = v31;
    uint64_t v33 = *(void *)v75;
    while (2)
    {
      for (uint64_t i = 0; i != v32; ++i)
      {
        if (*(void *)v75 != v33) {
          objc_enumerationMutation(v30);
        }
        double v35 = *(TSDLayout **)(*((void *)&v74 + 1) + 8 * i);
        if ((TSWPDrawableAttachment *)[(TSDInfo *)[(TSDLayout *)v35 info] owningAttachment] == a11
          && pLayoutGeometryIsBeingManipulated(v35))
        {
          *a15 = a12 + 1;
          if ([(TSWPDrawableAttachment *)a11 drawable]) {
            objc_msgSend(a16, "addObject:", -[TSWPDrawableAttachment drawable](a11, "drawable"));
          }
          ++*a17;
          [(TSDAbstractLayout *)v35 alignmentFrame];
          *(void *)a18 = v52;
          *((void *)a18 + 1) = v53;
          v80.CGFloat width = a7;
          v80.double height = a8;
          a18[1] = a18[1] - TSWPLayoutChore::pAnchoredDrawableVerticalAdjustment((id *)a1, a11, a13, v80, a14);
          if (objc_opt_respondsToSelector())
          {
            objc_msgSend(*(id *)(a1 + 2056), "anchoredAttachmentPositionFromLayoutPosition:", *a18, a18[1]);
            *(void *)a18 = v54;
            *((void *)a18 + 1) = v55;
          }
          *(double *)a19 = adjustedLayoutSize(v35);
          *(void *)(a19 + 8) = v56;
          return 1;
        }
      }
      uint64_t v32 = [v30 countByEnumeratingWithState:&v74 objects:v78 count:16];
      if (v32) {
        continue;
      }
      break;
    }
  }
  double v36 = (TSDLayout *)objc_msgSend(*(id *)(a1 + 2056), "validatedLayoutForAnchoredDrawable:", -[TSWPDrawableAttachment drawable](a11, "drawable"));
  double v37 = adjustedLayoutSize(v36);
  *(double *)a19 = v37;
  *(void *)(a19 + 8) = v38;
  *a18 = TSWPLayoutChore::pCalculateAttachmentPosition((id *)a1, a11, a12, a13, a14, (double *)a20, a2, a3, a4, a5, a6, a7, a8, v39, v37);
  *((void *)a18 + 1) = v40;
  id v41 = [(TSDLayout *)v36 iterativePositioningState];
  uint64_t v42 = v41;
  if (v41)
  {
    [v41 position];
    *(void *)a18 = v43;
    *((void *)a18 + 1) = v44;
  }
  if ([(TSDLayout *)v36 hasFinishedIterativePositioning])
  {
    [v42 position];
    *(void *)a18 = v45;
    *((void *)a18 + 1) = v46;
  }
  if ([(TSDLayout *)v36 attachmentLayoutDisplacedByDropCap])
  {
    double v47 = *(double *)(a1 + 752);
    double v48 = a18[1];
    if (v47 > v48)
    {
      a18[1] = v47;
      double v48 = v47;
    }
    uint64_t v49 = *(void *)a18;
    *a18 = TSWPDropCapLayoutState::adjustedAttachmentPosition((TSWPDropCapLayoutState *)(a1 + 864), *(CGPoint *)(&v48 - 1), v36, a12);
    *((void *)a18 + 1) = v50;
  }
  CGFloat v70 = a5;
  if ([(TSWPDrawableAttachment *)a11 isHTMLWrap])
  {
    v82.origin.CGFloat x = a2;
    v82.origin.double y = a3;
    v82.size.CGFloat width = a4;
    v82.size.double height = a5;
    double MaxY = CGRectGetMaxY(v82);
  }
  else
  {
    [*(id *)(a1 + 2056) maxAnchorY];
  }
  double v57 = MaxY;
  if ([(TSWPDrawableAttachment *)a11 vOffsetType] != 1)
  {
    double v58 = a6;
    double v59 = a18[1];
    double v60 = v59 + *(double *)(a19 + 8) - v57;
    if (v60 > 0.0)
    {
      [(TSWPDrawableAttachment *)a11 vOffset];
      double v59 = a18[1];
      if (v60 <= v61)
      {
        double v59 = v59 - v60;
        a18[1] = v59;
      }
    }
    if (v59 + *(double *)(a19 + 8) > v57)
    {
      v81.CGFloat width = a7;
      v81.double height = a8;
      if (a18[1] - TSWPLayoutChore::pAnchoredDrawableVerticalAdjustment((id *)a1, a11, a13, v81, a14) != v58) {
        return 0;
      }
      v83.origin.CGFloat x = a2;
      v83.origin.double y = a3;
      v83.size.CGFloat width = a4;
      v83.size.double height = v70;
      if (CGRectGetMinY(v83) != v58) {
        return 0;
      }
      v84.origin.CGFloat x = a2;
      v84.origin.double y = a3;
      v84.size.CGFloat width = a4;
      v84.size.double height = v70;
      double MinY = CGRectGetMinY(v84);
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(*(id *)(a1 + 2056), "columns"), "objectAtIndexedSubscript:", 0), "wpBounds");
      if (MinY != CGRectGetMinY(v85)) {
        return 0;
      }
    }
  }
  if (*(void *)(a1 + 48) <= a12) {
    return 0;
  }
  if (objc_opt_respondsToSelector())
  {
    objc_msgSend(*(id *)(a1 + 2056), "layoutPositionFromAnchoredAttachmentPosition:", *a18, a18[1]);
    double v64 = v63;
    double v66 = v65;
  }
  else
  {
    double v64 = *a18;
    double v66 = a18[1];
  }
  [(TSDLayout *)v36 setAdjustedInterimPositionY:v66];
  unint64_t v68 = [(TSDDrawableInfo *)[(TSWPDrawableAttachment *)a11 drawable] exteriorTextWrap];
  if ([(TSDExteriorTextWrap *)v68 isHTMLWrap] && [(TSDExteriorTextWrap *)v68 direction] == 2)
  {
    [(TSDLayout *)v36 setAdjustedInterimPositionY:v66];
    if (a20)
    {
      id v69 = *(id *)(a20 + 24);
      if (!v69)
      {
        id v69 = objc_alloc_init(MEMORY[0x263EFF980]);
        *(void *)(a20 + 24) = v69;
      }
      [v69 addObject:a11];
    }
  }
  else
  {
    [(TSDLayout *)v36 setAdjustedInterimPositionX:v64];
    [(TSDAbstractLayout *)v36 fixTransformFromInterimPosition];
  }
  if ([(TSWPDrawableAttachment *)a11 drawable]) {
    objc_msgSend(a16, "addObject:", -[TSWPDrawableAttachment drawable](a11, "drawable"));
  }
  ++*a17;
  *a15 = a12 + 1;
  return 1;
}

double adjustedLayoutSize(TSDLayout *a1)
{
  [(TSDAbstractLayout *)a1 alignmentFrame];
  double v3 = v2;
  if (objc_opt_respondsToSelector())
  {
    uint64_t v4 = (void *)[(TSDLayout *)a1 performSelector:sel_stroke];
    if (!v4) {
      goto LABEL_7;
    }
LABEL_6:
    objc_msgSend(v4, "outsets", v5, v6, v7);
    return v3 - (v6 + v5);
  }
  [(TSDLayout *)a1 info];
  if ((objc_opt_respondsToSelector() & 1) == 0)
  {
LABEL_7:
    double v6 = 0.0;
    double v5 = 0.0;
    return v3 - (v6 + v5);
  }
  uint64_t v4 = (void *)[(TSDInfo *)[(TSDLayout *)a1 info] performSelector:sel_stroke];
  double v7 = 0.0;
  double v6 = 0.0;
  double v5 = 0.0;
  if (v4) {
    goto LABEL_6;
  }
  return v3 - (v6 + v5);
}

double TSWPLayoutChore::pAdjustAnchorYPositionForVerticalAlignment(id *this, TSWPDrawableAttachment *a2, uint64_t a3, double a4)
{
  CharacterStyleAtCharIndeCGFloat x = TSWPLayoutChore::pGetCharacterStyleAtCharIndex(this, a3);
  return TSWPAttachmentVAlignmentCorrection(-[TSWPDrawableAttachment vAlignment](a2, "vAlignment"), CharacterStyleAtCharIndex, this[22], [this[23] scaleTextPercent])+ a4;
}

uint64_t TSWPLayoutChore::pAnchoredGraphicAndTextCollisionsInTarget()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  double v2 = v1;
  uint64_t v3 = v0;
  v109[16] = *MEMORY[0x263EF8340];
  uint64_t v4 = (void *)[*(id *)(v0 + 2056) columns];
  unint64_t v5 = objc_msgSend((id)objc_msgSend(v4, "firstObject"), "anchoredRange");
  uint64_t v6 = objc_msgSend((id)objc_msgSend(v4, "lastObject"), "anchoredRange");
  if (v5 <= v6 + v7) {
    unint64_t v8 = v6 + v7;
  }
  else {
    unint64_t v8 = v5;
  }
  if (v5 >= v6 + v7) {
    unint64_t v9 = v6 + v7;
  }
  else {
    unint64_t v9 = v5;
  }
  if (v9 != 0x7FFFFFFFFFFFFFFFLL && v8 != v9)
  {
    uint64_t v11 = objc_msgSend(*(id *)(v3 + 8), "attachmentIndexRangeForTextRange:", v9, v8 - v9);
    if (v12)
    {
      unint64_t v13 = v11;
      uint64_t v14 = v12;
      CGPoint v89 = v4;
      double v15 = (void *)[objc_alloc(MEMORY[0x263EFF980]) initWithCapacity:v12];
      unint64_t v16 = v13 + v14;
      uint64_t v91 = v3;
      if (v13 < v13 + v14)
      {
        unint64_t v17 = v13;
        uint64_t v90 = v2;
        do
        {
          objc_opt_class();
          [*(id *)(v3 + 8) attachmentAtAttachmentIndex:v17 outCharIndex:0];
          CGFloat v18 = (void *)TSUDynamicCast();
          if ([v18 isAnchored])
          {
            if (([v18 isHTMLWrap] & 1) == 0)
            {
              uint64_t v19 = [v18 drawable];
              if ((objc_opt_respondsToSelector() & 1) == 0
                || ([*(id *)(v3 + 2056) siblingTargetIsManipulatingDrawable:v19] & 1) == 0)
              {
                if (objc_msgSend(*(id *)(v3 + 2056), "validatedLayoutForAnchoredDrawable:", objc_msgSend(v18, "drawable")))
                {
                  double v20 = (void *)TSUProtocolCast();
                  if (v20)
                  {
                    long long v103 = 0u;
                    long long v104 = 0u;
                    long long v101 = 0u;
                    long long v102 = 0u;
                    CGFloat v21 = (void *)[v20 descendentWrappables];
                    uint64_t v22 = [v21 countByEnumeratingWithState:&v101 objects:v109 count:16];
                    if (v22)
                    {
                      uint64_t v23 = v22;
                      uint64_t v24 = *(void *)v102;
                      do
                      {
                        for (uint64_t i = 0; i != v23; ++i)
                        {
                          if (*(void *)v102 != v24) {
                            objc_enumerationMutation(v21);
                          }
                          CGRect v26 = *(void **)(*((void *)&v101 + 1) + 8 * i);
                          if ([v26 wrapType]
                            && [v26 wrapType] != 5)
                          {
                            [v15 addObject:v26];
                          }
                        }
                        uint64_t v23 = [v21 countByEnumeratingWithState:&v101 objects:v109 count:16];
                      }
                      while (v23);
                    }
                  }
                  CGRect v27 = (void *)TSUProtocolCast();
                  double v2 = v90;
                  uint64_t v3 = v91;
                  unint64_t v16 = v13 + v14;
                  if ([v27 wrapType] && objc_msgSend(v27, "wrapType") != 5) {
                    [v15 addObject:v27];
                  }
                }
              }
            }
          }
          ++v17;
        }
        while (v17 != v16);
      }
      long long v99 = 0u;
      long long v100 = 0u;
      long long v97 = 0u;
      long long v98 = 0u;
      uint64_t v28 = [v15 countByEnumeratingWithState:&v97 objects:v108 count:16];
      if (v28)
      {
        uint64_t v29 = *(void *)v98;
        uint64_t v84 = *(void *)v98;
        do
        {
          uint64_t v30 = 0;
          uint64_t v31 = v89;
          uint64_t v85 = v28;
          do
          {
            if (*(void *)v98 != v29) {
              objc_enumerationMutation(v15);
            }
            uint64_t v86 = v30;
            uint64_t v32 = *(void **)(*((void *)&v97 + 1) + 8 * v30);
            [v32 boundsInfluencingExteriorWrap];
            double v37 = TSDRoundedRect(v33, v34, v35, v36);
            CGFloat v39 = v38;
            CGFloat v41 = v40;
            CGFloat v43 = v42;
            uint64_t v44 = *(void **)(v3 + 2056);
            if (v44) {
              [v44 transformInRoot];
            }
            else {
              memset(&v95, 0, sizeof(v95));
            }
            CGAffineTransformInvert(&v96, &v95);
            v110.origin.CGFloat x = v37;
            v110.origin.CGFloat y = v39;
            v110.size.CGFloat width = v41;
            v110.size.CGFloat height = v43;
            CGRect v111 = CGRectApplyAffineTransform(v110, &v96);
            rect2[0] = *(void *)&v111.origin.x;
            CGFloat y = v111.origin.y;
            CGFloat width = v111.size.width;
            CGFloat height = v111.size.height;
            memset(&rect2[1], 0, 32);
            long long v93 = 0u;
            long long v94 = 0u;
            uint64_t v87 = [v31 countByEnumeratingWithState:&rect2[1] objects:v107 count:16];
            if (v87)
            {
              uint64_t v88 = *(void *)rect2[3];
              do
              {
                uint64_t v48 = 0;
                while (2)
                {
                  if (*(void *)rect2[3] != v88) {
                    objc_enumerationMutation(v31);
                  }
                  uint64_t v49 = (uint64_t **)[*(id *)(rect2[2] + 8 * v48) lineFragmentArray];
                  uint64_t v50 = **v49;
                  uint64_t v51 = (*v49)[1];
                  while (v50 != v51)
                  {
                    double v52 = *(double *)(*(void *)v50 + 48);
                    double v53 = *(double *)(*(void *)v50 + 64);
                    double v54 = *(double *)(*(void *)v50 + 128);
                    if (v54 < *(double *)(*(void *)v50 + 120)) {
                      double v54 = *(double *)(*(void *)v50 + 120);
                    }
                    double v55 = *(double *)(*(void *)v50 + 144) + *(double *)(*(void *)v50 + 136) + v54;
                    double v56 = *(double *)(*(void *)v50 + 56) + *(double *)(*(void *)v50 + 112);
                    v112.origin.CGFloat x = TSDRoundedRect(*(double *)(*(void *)v50 + 48), v56, *(CGFloat *)(*(void *)v50 + 64), v55);
                    *(void *)&v115.origin.CGFloat x = rect2[0];
                    v115.origin.CGFloat y = y;
                    v115.size.CGFloat width = width;
                    v115.size.CGFloat height = height;
                    if (CGRectIntersectsRect(v112, v115))
                    {
                      objc_msgSend(v2, "rectInRoot:", v52, v56, v53, v55);
                      double v58 = v57;
                      CGFloat v60 = v59;
                      CGFloat v62 = v61;
                      CGFloat v64 = v63;
                      LODWORD(v65) = +[TSWPTextWrapper splitLine:lineSegmentRects:polygon:type:skipHint:](TSWPTextWrapper, "splitLine:lineSegmentRects:polygon:type:skipHint:", v105, [v32 wrapPolygon], 1, 0, v57, v59, v61, v63);
                      double v66 = TSDRoundedRect(v58, v60, v62, v64);
                      CGFloat v68 = v67;
                      CGFloat v70 = v69;
                      CGFloat v72 = v71;
                      if (v65 != 1)
                      {
                        if (v65)
                        {
                          char v73 = 0;
                          uint64_t v65 = v65;
                          long long v74 = v106;
                          do
                          {
                            if (*v74 >= 18.0)
                            {
                              v113.origin.CGFloat x = TSDRoundedRect(*(v74 - 2), *(v74 - 1), *v74, v74[1]);
                              v116.origin.CGFloat x = v66;
                              v116.origin.CGFloat y = v68;
                              v116.size.CGFloat width = v70;
                              v116.size.CGFloat height = v72;
                              if (!CGRectEqualToRect(v113, v116))
                              {
                                unint64_t v16 = v13 + v14;
                                goto LABEL_70;
                              }
                              char v73 = 1;
                            }
                            v74 += 4;
                            --v65;
                          }
                          while (v65);
                          unint64_t v16 = v13 + v14;
                          if (v73) {
                            goto LABEL_62;
                          }
                        }
LABEL_70:

                        uint64_t v79 = [v2 anchoredDrawablesForRelayout];
                        if (v13 < v16)
                        {
                          CGSize v80 = (void *)v79;
                          do
                          {
                            objc_opt_class();
                            [*(id *)(v91 + 8) attachmentAtAttachmentIndex:v13 outCharIndex:0];
                            CGSize v81 = (void *)TSUDynamicCast();
                            if ([v81 isAnchored]
                              && (objc_msgSend(v80, "containsObject:", objc_msgSend(v81, "drawable")) & 1) == 0)
                            {
                              objc_msgSend(v80, "addObject:", objc_msgSend(v81, "drawable"));
                            }
                            ++v13;
                            --v14;
                          }
                          while (v14);
                        }
                        if (!objc_msgSend((id)objc_msgSend(v2, "anchoredDrawablesForRelayout"), "count"))
                        {
                          CGRect v82 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
                          uint64_t v83 = objc_msgSend(NSString, "stringWithUTF8String:", "BOOL TSWPLayoutChore::pAnchoredGraphicAndTextCollisionsInTarget(TSDLayout<TSWPLayoutTarget> *, NSString *&)");
                          objc_msgSend(v82, "handleFailureInFunction:file:lineNumber:description:", v83, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLayoutChore.mm"), 6715, @"Found collision but no anchored drawables");
                        }
                        return 1;
                      }
                      v117.origin.CGFloat x = TSDRoundedRect(v105[0], v105[1], v106[0], v106[1]);
                      v117.origin.CGFloat y = v75;
                      v117.size.CGFloat width = v76;
                      v117.size.CGFloat height = v77;
                      v114.origin.CGFloat x = v66;
                      v114.origin.CGFloat y = v68;
                      v114.size.CGFloat width = v70;
                      v114.size.CGFloat height = v72;
                      if (!CGRectEqualToRect(v114, v117)) {
                        goto LABEL_70;
                      }
                    }
LABEL_62:
                    v50 += 16;
                  }
                  ++v48;
                  uint64_t v3 = v91;
                  uint64_t v31 = v89;
                  if (v48 != v87) {
                    continue;
                  }
                  break;
                }
                uint64_t v29 = v84;
                uint64_t v87 = [v89 countByEnumeratingWithState:&rect2[1] objects:v107 count:16];
              }
              while (v87);
            }
            uint64_t v30 = v86 + 1;
          }
          while (v86 + 1 != v85);
          uint64_t v28 = [v15 countByEnumeratingWithState:&v97 objects:v108 count:16];
        }
        while (v28);
      }
    }
  }
  return 0;
}

void std::__shared_ptr_pointer<TSWPLineFragment *,std::shared_ptr<TSWPLineFragment>::__shared_ptr_default_delete<TSWPLineFragment,TSWPLineFragment>,std::allocator<TSWPLineFragment>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223CB8F20);
}

TSWPLineFragment *std::unique_ptr<TSWPLineFragment>::reset[abi:ne180100](TSWPLineFragment **a1, TSWPLineFragment *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    TSWPLineFragment::~TSWPLineFragment(result);
    JUMPOUT(0x223CB8F20);
  }
  return result;
}

uint64_t TSWPShapeStyleIdentifierString(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = TSWPShapePackageStringForPresetKind(a1);

  return String(v3, a2, @"shapestyle");
}

void sub_223743C30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27)
{
  _Block_object_dispose(&a20, 8);
  if (__p)
  {
    a27 = (uint64_t)__p;
    operator delete(__p);
  }
  _Block_object_dispose((const void *)(v27 - 152), 8);
  uint64_t v29 = *(void **)(v27 - 104);
  if (v29)
  {
    *(void *)(v27 - 96) = v29;
    operator delete(v29);
  }
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__22(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__22(uint64_t a1)
{
  double v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void sub_223744D7C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)(v1 - 112);
  if (v3)
  {
    *(void *)(v1 - 104) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t anonymous namespace'::TSWPNumberFromArabicString(_anonymous_namespace_ *this, NSString *a2)
{
  uint64_t v3 = (void *)[MEMORY[0x263F08B08] scannerWithString:this];
  unsigned int v8 = 0;
  if (![v3 scanInt:&v8]
    || ![v3 isAtEnd]
    || (unint64_t result = v8, (v8 & 0x80000000) != 0))
  {
    float v7 = 0.0;
    unint64_t v5 = (void *)[MEMORY[0x263F08B08] scannerWithString:this];
    if ([v5 scanFloat:&v7])
    {
      int v6 = [v5 isAtEnd];
      unint64_t result = 0x7FFFFFFFFFFFFFFFLL;
      if (v6)
      {
        if (v7 >= 0.0) {
          return vcvtas_u32_f32(v7);
        }
      }
    }
    else
    {
      return 0x7FFFFFFFFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t anonymous namespace'::TSWPNumberFromRomanUpperLabel(_anonymous_namespace_ *this, NSString *a2)
{
  double v2 = (char *)[(_anonymous_namespace_ *)this UTF8String];
  LOBYTE(v3) = *v2;
  if (!*v2) {
    return 0;
  }
  uint64_t v4 = v2;
  uint64_t v5 = 0;
  uint64_t v6 = MEMORY[0x263EF8318];
  while (1)
  {
    if ((v3 & 0x80) != 0)
    {
      if (!__maskrune((char)v3, 0x100uLL)) {
        return 0x7FFFFFFFFFFFFFFFLL;
      }
    }
    else if ((*(_DWORD *)(v6 + 4 * (char)v3 + 60) & 0x100) == 0)
    {
      return 0x7FFFFFFFFFFFFFFFLL;
    }
    unint64_t v7 = (*v4 & 0xFFFFFFFFFFFFFFDFLL) - 65;
    if ((0x34FE4F3uLL >> v7)) {
      return 0x7FFFFFFFFFFFFFFFLL;
    }
    if (!v4[1]) {
      break;
    }
    if (v9 <= v8)
    {
      int v3 = v4[1];
    }
    else
    {
      uint64_t v8 = v9 - v8;
      int v3 = v4[2];
      ++v4;
    }
    v5 += v8;
    ++v4;
    if (!v3) {
      return v5;
    }
  }
  v5 += v8;
  return v5;
}

uint64_t anonymous namespace'::TSWPNumberFromAlphaUpperLabel(_anonymous_namespace_ *this, NSString *a2)
{
  uint64_t v3 = [(_anonymous_namespace_ *)this length];
  uint64_t v4 = (char *)[(_anonymous_namespace_ *)this UTF8String];
  char v5 = *v4;
  if (!v3) {
    return 26 * v3 + (char)(v5 & 0xDF) - 90;
  }
  uint64_t v6 = v4;
  uint64_t v7 = 0;
  uint64_t v8 = MEMORY[0x263EF8318];
  while (1)
  {
    if (v5 < 0)
    {
      if (!__maskrune(v5, 0x100uLL)) {
        return 0x7FFFFFFFFFFFFFFFLL;
      }
    }
    else if ((*(_DWORD *)(v8 + 4 * v5 + 60) & 0x100) == 0)
    {
      return 0x7FFFFFFFFFFFFFFFLL;
    }
    char v5 = *v6;
    if (((v6[v7] ^ *v6) & 0xDF) != 0) {
      break;
    }
    if (v3 == ++v7) {
      return 26 * v3 + (char)(v5 & 0xDF) - 90;
    }
  }
  return 0x7FFFFFFFFFFFFFFFLL;
}

uint64_t anonymous namespace'::TSWPArabicLabelFromNumber(_anonymous_namespace_ *this)
{
  unsigned int v1 = this;
  if (!this)
  {
    double v2 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v3 = [NSString stringWithUTF8String:"NSString *(anonymous namespace)::TSWPArabicLabelFromNumber"];
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 468, @"Illegal value for arabic numeral topic label <= 0");
  }
  if (v1 <= 1) {
    uint64_t v4 = 1;
  }
  else {
    uint64_t v4 = v1;
  }
  return objc_msgSend(NSString, "stringWithFormat:", @"%d", v4);
}

void *anonymous namespace'::TSWPRomanUpperLabelFromNumber(_anonymous_namespace_ *this)
{
  unsigned int v1 = this;
  if (!this)
  {
    double v2 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v3 = [NSString stringWithUTF8String:"NSString *(anonymous namespace)::TSWPRomanUpperLabelFromNumber"];
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 579, @"Illegal value for roman numeral topic label <= 0");
  }
  if (v1 <= 1) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v1;
  }
  char v5 = (void *)[MEMORY[0x263F089D8] string];
  uint64_t v6 = 12;
  do
  {
    if (v4 >= v7)
    {
      do
      {
        [v5 appendString:v8];
        v4 -= v7;
      }
      while (v4 >= v7);
    }
    BOOL v10 = v6-- != 0;
  }
  while (v4 && v10);
  return v5;
}

void *anonymous namespace'::TSWPFootnoteSymbolFromNumber(_anonymous_namespace_ *this)
{
  int v1 = (int)this;
  double v2 = (void *)[MEMORY[0x263F089D8] string];
  unint64_t v4 = ((unint64_t)(v1 - 1) >> 2) + 1;
  do
  {
    objc_msgSend(v2, "appendFormat:", @"%C", v3);
    --v4;
  }
  while (v4);
  return v2;
}

id anonymous namespace'::ideographicNumberStringForValue(uint64_t a1, unsigned int a2)
{
  unint64_t v4 = (void *)[MEMORY[0x263F089D8] string];
  id v5 = v4;
  uint64_t v6 = a2;
  if (a1)
  {
    unint64_t v16 = v4;
    unsigned int v17 = a2;
    char v18 = 1;
    uint64_t v19 = v7;
    uint64_t v10 = [NSString stringWithCharacters:&v15 length:1];
    if (a2 && a2 != 3)
    {
      uint64_t v11 = objc_msgSend(MEMORY[0x263EFF980], "arrayWithArray:", objc_msgSend(v5, "componentsSeparatedByString:", v10));
      [v11 removeObject:&stru_26D688A48];
      id v5 = (id)objc_msgSend((id)objc_msgSend(v11, "componentsJoinedByString:", v10), "mutableCopy");
      if ((unint64_t)[v5 length] >= 2)
      {
        int v12 = [v5 characterAtIndex:0];
        int v13 = [v5 characterAtIndex:1];
          && (v13 == *((unsigned __int16 *)v8 + 2)
        {
          objc_msgSend(v5, "deleteCharactersInRange:", 0, 1);
        }
      }
    }
    else
    {
      return (id)objc_msgSend((id)objc_msgSend(v5, "stringByReplacingOccurrencesOfString:withString:", v10, &stru_26D688A48), "mutableCopy");
    }
  }
  else
  {
  }
  return v5;
}

uint64_t anonymous namespace'::TSWPCircledNumberLabelFromNumber(_anonymous_namespace_ *this)
{
  if (!this)
  {
    double v2 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v3 = [NSString stringWithUTF8String:"NSString *(anonymous namespace)::TSWPCircledNumberLabelFromNumber"];
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 891, @"Illegal value for circled number numeral topic label <= 0");
  }
  uint64_t v4 = 0;
  while (1)
  {
      break;
    if (++v4 == 3) {
  }
    }
  uint64_t result = [NSString stringWithCharacters:&v7 length:1];
  if (!result) {
  return result;
  }
}

uint64_t anonymous namespace'::TSWPArabicLabelFromNumberAndLocale(_anonymous_namespace_ *this, uint64_t a2, NSString *a3)
{
  LODWORD(v4) = this;
  if (!this)
  {
    unsigned int v5 = objc_msgSend(MEMORY[0x263F7C7F0], "currentHandler", a3);
    uint64_t v6 = objc_msgSend(NSString, "stringWithUTF8String:", "NSString *(anonymous namespace)::TSWPArabicLabelFromNumberAndLocale(unsigned int, NSString *)");
    objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 481, @"Illegal value for arabic numeral topic label <= 0");
  }
  if (v4 <= 1) {
    uint64_t v4 = 1;
  }
  else {
    uint64_t v4 = v4;
  }
  id v7 = objc_alloc_init(MEMORY[0x263F08A30]);
  objc_msgSend(v7, "setLocale:", (id)objc_msgSend(objc_alloc(MEMORY[0x263EFF960]), "initWithLocaleIdentifier:", a2));
  uint64_t v8 = objc_msgSend(v7, "stringFromNumber:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", v4));

  return v8;
}

uint64_t anonymous namespace'::TSWPArabianAbjadLabelFromNumber(_anonymous_namespace_ *this, unsigned int a2, unsigned __int16 *a3)
{
  uint64_t v3 = this;
  uint64_t v14 = *MEMORY[0x263EF8340];
  if (this >= 0xF4240)
  {
    unsigned int v5 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v6 = [NSString stringWithUTF8String:"NSString *(anonymous namespace)::TSWPArabianAbjadLabelFromNumber(uint)"];
    objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 820, @"number out of bounds for algorithm");
    goto LABEL_6;
  }
  if (this)
  {
    if (this < 0x3E8)
    {
      int v4 = 0;
LABEL_7:
      if (v8 >= 0xC)
      {
        uint64_t v9 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v10 = [NSString stringWithUTF8String:"NSString *(anonymous namespace)::TSWPArabianAbjadLabelFromNumber(uint)"];
        objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 844, @"string out of bounds");
      }
      return [NSString stringWithCharacters:__b length:v8];
    }
LABEL_6:
    int v4 = v7 + 1;
    __b[v7] = 39;
    uint64_t v3 = (_anonymous_namespace_ *)(v3 % 0x3E8);
    goto LABEL_7;
  }
  int v12 = NSString;
}

uint64_t anonymous namespace'::TSWPHebrewBiblicalLabelFromNumber(_anonymous_namespace_ *this, unsigned int a2, unsigned __int16 *a3)
{
  uint64_t v3 = this;
  uint64_t v14 = *MEMORY[0x263EF8340];
  if (this >= 0xF4240)
  {
    unsigned int v5 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v6 = [NSString stringWithUTF8String:"NSString *(anonymous namespace)::TSWPHebrewBiblicalLabelFromNumber(uint)"];
    objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 750, @"Hebrew number out of bounds for algorithm");
    goto LABEL_6;
  }
  if (this)
  {
    if (this < 0x3E8)
    {
      int v4 = 0;
LABEL_7:
      if (v8 >= 0xC)
      {
        uint64_t v9 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v10 = [NSString stringWithUTF8String:"NSString *(anonymous namespace)::TSWPHebrewBiblicalLabelFromNumber(uint)"];
        objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 773, @"string out of bounds");
      }
      return [NSString stringWithCharacters:__b length:v8];
    }
LABEL_6:
    int v4 = v7 + 1;
    __b[v7] = 39;
    uint64_t v3 = (_anonymous_namespace_ *)(v3 % 0x3E8);
    goto LABEL_7;
  }
  int v12 = NSString;
}

void *anonymous namespace'::alphabeticLabelStringForValue(_anonymous_namespace_ *this, uint64_t a2, unint64_t a3)
{
  int v5 = (int)this;
  uint64_t v6 = (void *)[MEMORY[0x263F089D8] string];
  if (v5)
  {
    unint64_t v7 = (v5 - 1);
    unint64_t v8 = v7 / a3;
    if ((v7 / a3) <= 0x7FFFFFFE)
    {
      uint64_t v9 = *(unsigned __int16 *)(a2 + 2 * (v7 % a3));
      if ((int)v8 >= 99) {
        LODWORD(v8) = 99;
      }
      int v10 = v8 + 1;
      do
      {
        objc_msgSend(v6, "tsu_appendCharacter:", v9);
        BOOL v11 = v10-- != 0;
      }
      while (v10 != 0 && v11);
    }
  }
  return v6;
}

uint64_t std::accumulate[abi:nn180100]<anonymous namespace'::IdeographicNumber *,unsigned int,anonymous namespace'::BinderConvertIdeographicPowerOfTen<void (*)(NSMutableString *,unsigned int)>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 != a2)
  {
    uint64_t v7 = a1;
    do
    {
      unint64_t v8 = *(void **)a4;
      int v9 = *(_DWORD *)(a4 + 8);
      unsigned int v10 = *(_DWORD *)v7;
      unsigned int v11 = a3 / *(_DWORD *)v7;
      if (a3 || !v10)
      {
        BOOL v12 = v11 == 1 && *(unsigned char *)(a4 + 12) == 0;
        if (!v12 || v9 && v9 != 3) {
          (*(void (**)(void, void))(a4 + 16))(*(void *)a4, a3 / v10);
        }
      }
      if (v10 <= a3) {
        objc_msgSend(v8, "tsu_appendCharacter:", *(unsigned __int16 *)(v7 + 4));
      }
      unsigned int v13 = *(_DWORD *)v7;
      v7 += 8;
      a3 = a3 - v13 * v11;
    }
    while (v7 != a2);
  }
  return a3;
}

void *anonymous namespace'::ideographicNumberStringForSmallValue(uint64_t a1, unsigned int a2)
{
  if (a1 >> 4 >= 0x271)
  {
    int v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "NSMutableString *(anonymous namespace)::ideographicNumberStringForSmallValue(unsigned int, TSWPListIdeographicType, BOOL)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 334, @"inValue too large for ideographicNumberStringForSmallValue");
  }
  uint64_t v6 = (void *)[MEMORY[0x263F089D8] string];
  uint64_t v14 = v6;
  unsigned int v15 = a2;
  char v16 = 0;
  unsigned int v17 = v7;
  if (v8)
  {
    unsigned int v9 = v8;
    unsigned int v10 = a2;
    if (v8 >= 0xA)
    {
      unsigned int v11 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v12 = objc_msgSend(NSString, "stringWithUTF8String:", "void (anonymous namespace)::appendIdeographicDigit(NSMutableString *, unsigned int, TSWPListIdeographicType)");
      objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 206, @"inDigit is larger than single digit");
    }
  }
  return v6;
}

uint64_t anonymous namespace'::appendMultipleIdeographicDigitsJapanese(_anonymous_namespace_ *this, NSMutableString *a2)
{
  return [(_anonymous_namespace_ *)this appendString:v3];
}

uint64_t anonymous namespace'::appendMultipleIdeographicDigitsSimplifiedChinese(_anonymous_namespace_ *this, NSMutableString *a2)
{
  return [(_anonymous_namespace_ *)this appendString:v3];
}

uint64_t anonymous namespace'::appendMultipleIdeographicDigitsTraditionalChinese(_anonymous_namespace_ *this, NSMutableString *a2)
{
  return [(_anonymous_namespace_ *)this appendString:v3];
}

uint64_t anonymous namespace'::appendMultipleIdeographicDigitsFormalJapanese(_anonymous_namespace_ *this, NSMutableString *a2)
{
  return [(_anonymous_namespace_ *)this appendString:v3];
}

uint64_t anonymous namespace'::appendMultipleIdeographicDigitsFormalSimplifiedChinese(_anonymous_namespace_ *this, NSMutableString *a2)
{
  return [(_anonymous_namespace_ *)this appendString:v3];
}

uint64_t anonymous namespace'::appendMultipleIdeographicDigitsFormalTraditionalChinese(_anonymous_namespace_ *this, NSMutableString *a2)
{
  return [(_anonymous_namespace_ *)this appendString:v3];
}

uint64_t anonymous namespace'::appendIdeographicDigitJapanese(_anonymous_namespace_ *this, NSMutableString *a2)
{
  int v2 = (int)a2;
  if (a2 >= 0xA)
  {
    int v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "void (anonymous namespace)::appendIdeographicDigit(NSMutableString *, unsigned int, TSWPListIdeographicType)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 206, @"inDigit is larger than single digit");
  }

  return [(_anonymous_namespace_ *)this tsu_appendCharacter:v6];
}

uint64_t anonymous namespace'::appendIdeographicDigitSimplifiedChinese(_anonymous_namespace_ *this, NSMutableString *a2)
{
  int v2 = (int)a2;
  if (a2 >= 0xA)
  {
    int v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "void (anonymous namespace)::appendIdeographicDigit(NSMutableString *, unsigned int, TSWPListIdeographicType)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 206, @"inDigit is larger than single digit");
  }

  return [(_anonymous_namespace_ *)this tsu_appendCharacter:v6];
}

uint64_t anonymous namespace'::appendIdeographicDigitTraditionalChinese(_anonymous_namespace_ *this, NSMutableString *a2)
{
  int v2 = (int)a2;
  if (a2 >= 0xA)
  {
    int v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "void (anonymous namespace)::appendIdeographicDigit(NSMutableString *, unsigned int, TSWPListIdeographicType)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 206, @"inDigit is larger than single digit");
  }

  return [(_anonymous_namespace_ *)this tsu_appendCharacter:v6];
}

uint64_t anonymous namespace'::appendIdeographicDigitFormalJapanese(_anonymous_namespace_ *this, NSMutableString *a2)
{
  int v2 = (int)a2;
  if (a2 >= 0xA)
  {
    int v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "void (anonymous namespace)::appendIdeographicDigit(NSMutableString *, unsigned int, TSWPListIdeographicType)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 206, @"inDigit is larger than single digit");
  }

  return [(_anonymous_namespace_ *)this tsu_appendCharacter:v6];
}

uint64_t anonymous namespace'::appendIdeographicDigitFormalSimplifiedChinese(_anonymous_namespace_ *this, NSMutableString *a2)
{
  int v2 = (int)a2;
  if (a2 >= 0xA)
  {
    int v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "void (anonymous namespace)::appendIdeographicDigit(NSMutableString *, unsigned int, TSWPListIdeographicType)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 206, @"inDigit is larger than single digit");
  }

  return [(_anonymous_namespace_ *)this tsu_appendCharacter:v6];
}

uint64_t anonymous namespace'::appendIdeographicDigitFormalTraditionalChinese(_anonymous_namespace_ *this, NSMutableString *a2)
{
  int v2 = (int)a2;
  if (a2 >= 0xA)
  {
    int v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "void (anonymous namespace)::appendIdeographicDigit(NSMutableString *, unsigned int, TSWPListIdeographicType)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 206, @"inDigit is larger than single digit");
  }

  return [(_anonymous_namespace_ *)this tsu_appendCharacter:v6];
}

void *anonymous namespace'::cjkLabelStringForValue(_anonymous_namespace_ *this, uint64_t a2, unint64_t a3, int a4)
{
  LODWORD(v7) = this;
  unsigned int v8 = (void *)[MEMORY[0x263F089D8] string];
  if (v7)
  {
    unsigned int v9 = 0;
    do
    {
      unint64_t v10 = (v7 - 1);
      if (a4) {
        unsigned __int16 v11 = *(_WORD *)(a2 + 2 * (v10 % a3)) + 96;
      }
      else {
        unsigned __int16 v11 = *(_WORD *)(a2 + 2 * (v10 % a3));
      }
      objc_msgSend(v8, "tsu_insertCharacter:atIndex:", v11, 0);
      unint64_t v7 = (v10 - (v10 % a3)) / a3;
      if (!v7) {
        break;
      }
    }
    while (v9++ < 0x64);
  }
  return v8;
}

unint64_t anonymous namespace'::toAbjadUnder1000(_anonymous_namespace_ *this, void *__b, unsigned __int16 *a3)
{
  unsigned int v4 = this;
  if (this >= 0x3E8)
  {
    uint64_t v6 = objc_msgSend(MEMORY[0x263F7C7F0], "currentHandler", a3);
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "uint (anonymous namespace)::toAbjadUnder1000(uint, unichar *)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 785, @"number out of range");
  }
  else if (this < 0x190)
  {
    unint64_t v5 = 0;
    goto LABEL_6;
  }
  unint64_t v5 = v4 / 0x190uLL;
  memset_pattern16(__b, &unk_22383B100, (2 * v5));
LABEL_6:
  if (v4 % 0x190 >= 0x64)
  {
    unint64_t v5 = (v5 + 1);
  }
  unsigned int v8 = v4 % 0x190 % 0x64;
  if (v8 - 15 <= 1)
  {
    *((_WORD *)__b + v5) = 1610;
    unint64_t v9 = (v5 + 2);
    uint64_t v10 = v8 - 11;
    LODWORD(v5) = v5 + 1;
LABEL_14:
    unint64_t v5 = v9;
    goto LABEL_15;
  }
  if (v8 >= 0xA)
  {
    unint64_t v5 = (v5 + 1);
  }
  if (v4 % 0x190 % 0x64 % 0xA)
  {
    uint64_t v10 = v4 % 0x190 % 0x64 % 0xA - 1;
    unint64_t v9 = (v5 + 1);
    goto LABEL_14;
  }
LABEL_15:
  if (v5 >= 6)
  {
    unsigned __int16 v11 = objc_msgSend(MEMORY[0x263F7C7F0], "currentHandler", a3);
    uint64_t v12 = objc_msgSend(NSString, "stringWithUTF8String:", "uint (anonymous namespace)::toAbjadUnder1000(uint, unichar *)");
    objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 814, @"string out of range");
  }
  return v5;
}

unint64_t anonymous namespace'::toHebrewUnder1000(_anonymous_namespace_ *this, void *__b, unsigned __int16 *a3)
{
  unsigned int v4 = this;
  if (this >= 0x3E8)
  {
    uint64_t v6 = objc_msgSend(MEMORY[0x263F7C7F0], "currentHandler", a3);
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "uint (anonymous namespace)::toHebrewUnder1000(uint, unichar *)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 715, @"number out of range");
  }
  else if (this < 0x190)
  {
    unint64_t v5 = 0;
    goto LABEL_6;
  }
  unint64_t v5 = v4 / 0x190uLL;
  memset_pattern16(__b, &unk_22383B110, (2 * v5));
LABEL_6:
  if (v4 % 0x190 >= 0x64)
  {
    *((_WORD *)__b + v5) = v4 % 0x190 / 0x64 + 1510;
    unint64_t v5 = (v5 + 1);
  }
  unsigned __int16 v8 = v4 % 0x190 % 0x64;
  if (v8 - 15 <= 1)
  {
    *((_WORD *)__b + v5) = 1497;
    unint64_t v9 = (v5 + 2);
    __int16 v10 = v8 + 1477;
    LODWORD(v5) = v5 + 1;
LABEL_14:
    *((_WORD *)__b + v5) = v10;
    unint64_t v5 = v9;
    goto LABEL_15;
  }
  if (v4 % 0x190 % 0x64 >= 0xA)
  {
    unint64_t v5 = (v5 + 1);
  }
  if (v4 % 0x190 % 0x64 % 0xA)
  {
    __int16 v10 = v4 % 0x190 % 0x64 % 0xA + 1487;
    unint64_t v9 = (v5 + 1);
    goto LABEL_14;
  }
LABEL_15:
  if (v5 >= 6)
  {
    unsigned __int16 v11 = objc_msgSend(MEMORY[0x263F7C7F0], "currentHandler", a3);
    uint64_t v12 = objc_msgSend(NSString, "stringWithUTF8String:", "uint (anonymous namespace)::toHebrewUnder1000(uint, unichar *)");
    objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 744, @"string out of range");
  }
  return v5;
}

void sub_223749060(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__23(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__23(uint64_t a1)
{
}

void sub_2237492B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void TSWPListLabel::TSWPListLabel(TSWPListLabel *this, TSDImageProvider *a2)
{
  *(_OWORD *)this = *MEMORY[0x263F001B0];
  *((void *)this + 2) = 0;
  *((void *)this + 3) = a2;
  *((void *)this + 9) = 0;
  *((_WORD *)this + 40) = 0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_DWORD *)this + 16) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
}

{
  *(_OWORD *)this = *MEMORY[0x263F001B0];
  *((void *)this + 2) = 0;
  *((void *)this + 3) = a2;
  *((void *)this + 9) = 0;
  *((_WORD *)this + 40) = 0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_DWORD *)this + 16) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
}

void TSWPListLabel::TSWPListLabel(TSWPListLabel *this, CFTypeRef cf, uint64_t a3)
{
  *(_OWORD *)this = *MEMORY[0x263F001B0];
  *((void *)this + 2) = cf;
  unsigned int v4 = (CGFloat *)((char *)this + 48);
  *((void *)this + 9) = 0;
  *((_WORD *)this + 40) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 52) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  unint64_t v5 = (CGFloat *)((char *)this + 40);
  *((void *)this + 11) = a3;
  *((void *)this + 12) = 0;
  CFRetain(cf);
  CGFloat leading = 0.0;
  double TypographicBounds = CTLineGetTypographicBounds(*((CTLineRef *)this + 2), v5, v4, &leading);
  CGFloat v7 = *v5 + *((double *)this + 6);
  *(double *)this = TypographicBounds;
  *((CGFloat *)this + 1) = v7;
}

void TSWPListLabel::~TSWPListLabel(TSWPListLabel *this)
{
  int v2 = (const void *)*((void *)this + 2);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)*((void *)this + 12);
  if (v3) {
    CFRelease(v3);
  }
}

uint64_t TSWPListLabel::isEqual(TSWPListLabel *this, const TSWPListLabel *a2)
{
  if (!a2) {
    return 0;
  }
  BOOL v4 = *(double *)this == *(double *)a2 && *((double *)this + 1) == *((double *)a2 + 1);
  if (!v4
    || *((double *)this + 7) != *((double *)a2 + 7)
    || *((_DWORD *)this + 16) != *((_DWORD *)a2 + 16)
    || *((double *)this + 9) != *((double *)a2 + 9)
    || *((unsigned __int8 *)this + 81) != *((unsigned __int8 *)a2 + 81)
    || *((void *)this + 11) != *((void *)a2 + 11))
  {
    return 0;
  }
  uint64_t v5 = *((void *)this + 3);
  if (*((void *)this + 2))
  {
    if (v5)
    {
      uint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v7 = [NSString stringWithUTF8String:"BOOL TSWPListLabel::isEqual(const TSWPListLabel *) const"];
      objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPListLabel.mm"), 59, @"shouldn't have a text line and an image");
    }
    unsigned __int16 v8 = (const void *)*((void *)a2 + 2);
    if (v8)
    {
      uint64_t result = CFEqual(*((CFTypeRef *)this + 2), v8);
      if (!result) {
        return result;
      }
      goto LABEL_17;
    }
    return 0;
  }
  if (v5)
  {
    uint64_t v11 = *((void *)a2 + 3);
    uint64_t v12 = [*((id *)this + 3) imageData];
    uint64_t v13 = v12;
    if (v5 == v11)
    {
      if (!v12)
      {
        unsigned int v17 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v18 = [NSString stringWithUTF8String:"BOOL TSWPListLabel::isEqual(const TSWPListLabel *) const"];
        [v17 handleFailureInFunction:v18, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPListLabel.mm"), 68, @"we assume that imageData will be non-nil and then compare by pointer, and so may end up with a false-positive here" file lineNumber description];
      }
    }
    else
    {
      uint64_t v14 = [*((id *)a2 + 3) imageData];
      if (![*((id *)this + 3) imageData])
      {
        unsigned int v15 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v16 = [NSString stringWithUTF8String:"BOOL TSWPListLabel::isEqual(const TSWPListLabel *) const"];
        [v15 handleFailureInFunction:v16, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPListLabel.mm"), 68, @"we assume that imageData will be non-nil and then compare by pointer, and so may end up with a false-positive here" file lineNumber description];
      }
      if (v13 != v14) {
        return 0;
      }
    }
  }
  else if (*((void *)a2 + 2) || *((void *)a2 + 3))
  {
    return 0;
  }
LABEL_17:
  __int16 v10 = (void *)*((void *)this + 4);
  if (v10 == *((void **)a2 + 4)) {
    return 1;
  }

  return objc_msgSend(v10, "isEqual:");
}

double TSWPListLabel::naturalImageSize(TSWPListLabel *this)
{
  int v1 = (void *)*((void *)this + 3);
  if (!v1) {
    return *MEMORY[0x263F001B0];
  }
  [v1 naturalSize];
  return result;
}

const void *TSWPListLabel::labelFont(CTLineRef *this)
{
  CFArrayRef GlyphRuns = CTLineGetGlyphRuns(this[2]);
  double result = (const void *)[(__CFArray *)GlyphRuns count];
  if (result)
  {
    CFDictionaryRef Attributes = CTRunGetAttributes((CTRunRef)[(__CFArray *)GlyphRuns objectAtIndexedSubscript:0]);
    BOOL v4 = (const void *)*MEMORY[0x263F039A0];
    return CFDictionaryGetValue(Attributes, v4);
  }
  return result;
}

uint64_t comparePairs(objc_object *a1, objc_object *a2, void *a3)
{
  unint64_t v4 = objc_msgSend((id)-[objc_object objectAtIndexedSubscript:](a1, "objectAtIndexedSubscript:", 1), "unsignedIntegerValue");
  unint64_t v5 = objc_msgSend((id)-[objc_object objectAtIndexedSubscript:](a2, "objectAtIndexedSubscript:", 1), "unsignedIntegerValue");
  if (v4 < v5) {
    return -1;
  }
  else {
    return v4 > v5;
  }
}

BOOL TSWPAdornmentLine::merge(TSWPAdornmentLine *this, const TSWPAdornmentLine *a2)
{
  if (a2->var4 != this->var4) {
    return 0;
  }
  double x = this->var0.x;
  double y = this->var0.y;
  double v7 = a2->var0.x;
  double v6 = a2->var0.y;
  int var5 = this->var5;
  BOOL result = CGColorEqualToColor(this->var2, a2->var2);
  if (!result) {
    return result;
  }
  if (vabdd_f64(x + this->var1, v7) >= 0.00999999978) {
    return 0;
  }
  if (a2->var5 != this->var5) {
    return 0;
  }
  int var6 = a2->var6;
  if (var6 != this->var6
    || !var5 && (vabdd_f64(this->var3, a2->var3) >= 0.00999999978 || vabdd_f64(y, v6) >= 0.00999999978))
  {
    return 0;
  }
  if (a2->var9 != this->var9) {
    return 0;
  }
  this->unsigned int var1 = v7 - x + a2->var1;
  if (!var5) {
    goto LABEL_18;
  }
  if (this->var8 && !a2->var8)
  {
    this->var0.double y = v6;
    double var3 = a2->var3;
LABEL_26:
    this->double var3 = var3;
    goto LABEL_27;
  }
  if (this->var8 || !a2->var8)
  {
LABEL_18:
    if (var6 == 1) {
      BOOL v12 = v6 < y;
    }
    else {
      BOOL v12 = y < v6;
    }
    if (v12) {
      double v13 = v6;
    }
    else {
      double v13 = y;
    }
    this->var0.double y = v13;
    double var3 = this->var3;
    if (var3 < a2->var3) {
      double var3 = a2->var3;
    }
    goto LABEL_26;
  }
LABEL_27:
  BOOL result = 1;
  if (this->var8 && !a2->var8) {
    this->int var8 = 0;
  }
  return result;
}

void sub_22374D104(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  TSWPAttributeEnumerator::~TSWPAttributeEnumerator((TSWPAttributeEnumerator *)va);
  _Unwind_Resume(a1);
}

void sub_22374D850(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_22374DB78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_22374E938(_Unwind_Exception *a1, TSWPParagraphEnumerator *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_22374F098(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  TSWPAttributeEnumerator::~TSWPAttributeEnumerator((TSWPAttributeEnumerator *)va);
  _Unwind_Resume(a1);
}

void sub_22374F6EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  TSWPAttributeEnumerator::~TSWPAttributeEnumerator((TSWPAttributeEnumerator *)va);
  _Unwind_Resume(a1);
}

void sub_22374FA00(_Unwind_Exception *a1, TSWPParagraphEnumerator *a2, TSWPParagraphEnumerator *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
}

void sub_22375084C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_223750A98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, TSWPParagraphEnumerator *a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
}

__n128 __Block_byref_object_copy__24(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  return result;
}

void sub_223752D04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  TSWPAttributeEnumerator::~TSWPAttributeEnumerator((TSWPAttributeEnumerator *)va);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__244(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__245(uint64_t a1)
{
}

void sub_223756474(_Unwind_Exception *a1, uint64_t a2, TSWPParagraphEnumerator *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

void sub_22375682C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_223756BA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, TSWPParagraphEnumerator *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
}

void sub_2237584C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *std::__tree<std::__value_type<unsigned long,std::shared_ptr<TSWPParagraphTypesetter>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::shared_ptr<TSWPParagraphTypesetter>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::shared_ptr<TSWPParagraphTypesetter>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  double v7 = a1 + 1;
  double v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        double v6 = *v9;
        double v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      double v6 = v9[1];
      if (!v6)
      {
        double v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    unint64_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = (uint64_t *)operator new(0x38uLL);
    _OWORD v11[4] = **a4;
    _OWORD v11[5] = 0;
    v11[6] = 0;
    std::__tree<std::__value_type<std::string,unsigned short>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned short>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned short>>>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

uint64_t *std::__tree<std::__value_type<unsigned long,std::shared_ptr<TSWPParagraphTypesetter>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::shared_ptr<TSWPParagraphTypesetter>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::shared_ptr<TSWPParagraphTypesetter>>>>::erase(uint64_t **a1, uint64_t *a2)
{
  uint64_t v3 = std::__tree<std::__value_type<unsigned short,EQKit::Config::Operator::Form>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,EQKit::Config::Operator::Form>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,EQKit::Config::Operator::Form>>>::__remove_node_pointer(a1, a2);
  unint64_t v4 = (std::__shared_weak_count *)a2[6];
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  operator delete(a2);
  return v3;
}

void TSWPParagraphTypesetter::pSetupTateChuYokoForParagraph(TSWPParagraphTypesetter *this)
{
  int v2 = (uint64_t *)((char *)this + 104);
  if (*((void *)this + 13) != *((void *)this + 14))
  {
    uint64_t v3 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v4 = [NSString stringWithUTF8String:"void TSWPParagraphTypesetter::pSetupTateChuYokoForParagraph()"];
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPParagraphTypesetter.mm"), 556, @"Should be no tate chu yoko runs prior to setup");
    std::vector<_TSWPTateChuYokoRun>::__clear[abi:nn180100](v2);
  }
  unint64_t v5 = 0;
  unint64_t v6 = (uint64_t)(*((void *)this + 5) - *((void *)this + 4)) >> 1;
  contentsDeallocator = v2;
  unint64_t v7 = 0x7FFFFFFFFFFFFFFFLL;
  do
  {
    if (v5 < v6
      && TSWPIsPotentialTateChuYokoCharacter(*(unsigned __int16 *)(*((void *)this + 4) + 2 * v5)))
    {
      if (v7 == 0x7FFFFFFFFFFFFFFFLL) {
        uint64_t v8 = v5;
      }
      else {
        uint64_t v8 = v7;
      }
      goto LABEL_50;
    }
    uint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
    if (v7 == 0x7FFFFFFFFFFFFFFFLL) {
      goto LABEL_50;
    }
    unint64_t v9 = objc_msgSend(*(id *)this, "smartFieldsWithAttributeKind:intersectingRange:", 7, v7, v5 - v7);
    if (v9) {
      BOOL v10 = [v9 count] != 0;
    }
    else {
      BOOL v10 = 0;
    }
    if (v5 <= v7)
    {
LABEL_30:
      char v19 = 0;
      if (!v10) {
        goto LABEL_33;
      }
      goto LABEL_36;
    }
    BOOL v11 = 0;
    BOOL v12 = 0;
    unint64_t v13 = v7;
    while (1)
    {
      CFAttributedStringRef v14 = (const __CFAttributedString *)*((void *)this + 7);
      CFStringRef v15 = (const __CFString *)String(45);
      CFStringRef Attribute = (const __CFString *)CFAttributedStringGetAttribute(v14, v13, v15, &effectiveRange);
      if (!Attribute) {
        break;
      }
      CFStringRef v17 = Attribute;
      BOOL v18 = CFStringGetLength(Attribute) != 0;
      if (v13 == v7)
      {
        BOOL v12 = (__CFString *)v17;
        BOOL v11 = v18;
      }
      if (((v18 ^ v11) & 1) != 0 || v12 && ([(__CFString *)v12 isEqualToString:v17] & 1) == 0) {
        goto LABEL_32;
      }
LABEL_26:
      if (effectiveRange.length) {
        unint64_t v13 = effectiveRange.location + effectiveRange.length;
      }
      else {
        ++v13;
      }
      if (v13 >= v5) {
        goto LABEL_30;
      }
    }
    if (v13 == v7) {
      BOOL v12 = 0;
    }
    if (v13 == v7 || !v11)
    {
      BOOL v11 = 0;
      goto LABEL_26;
    }
LABEL_32:
    char v19 = 1;
    if (v10) {
      goto LABEL_36;
    }
LABEL_33:
    if (v5 - v7 - 6 < 0xFFFFFFFFFFFFFFFCLL) {
      char v19 = 1;
    }
    if (v19)
    {
LABEL_36:
      if (v5 > v7)
      {
        do
          TSWPParagraphTypesetter::pConvertCharacterIndexToFullWidthNumber(this, v7++);
        while (v5 != v7);
      }
    }
    else
    {
      memset(cf, 0, sizeof(cf));
      effectiveRange.CFIndex location = v7;
      effectiveRange.NSUInteger length = v5 - v7;
      unint64_t v20 = *((void *)this + 14);
      if (v20 >= *((void *)this + 15))
      {
        uint64_t v22 = std::vector<_TSWPTateChuYokoRun>::__push_back_slow_path<_TSWPTateChuYokoRun const&>(contentsDeallocator, (uint64_t)&effectiveRange);
      }
      else
      {
        *(CFRange *)unint64_t v20 = effectiveRange;
        *(void *)(v20 + 16) = 0;
        *(_OWORD *)(v20 + 24) = *(_OWORD *)&cf[1];
        *(_OWORD *)(v20 + 40) = *(_OWORD *)&cf[3];
        if (cf[0])
        {
          CFRetain(cf[0]);
          CFTypeRef v21 = cf[0];
        }
        else
        {
          CFTypeRef v21 = 0;
        }
        *(void *)(v20 + 16) = v21;
        uint64_t v22 = v20 + 56;
        *((void *)this + 14) = v20 + 56;
      }
      *((void *)this + 14) = v22;
      if (v5 > v7)
      {
        do
          TSWPParagraphTypesetter::pConvertCharacterIndexToNormalWidthNumber(this, v7++);
        while (v5 != v7);
      }
      if (cf[0]) {
        CFRelease(cf[0]);
      }
    }
    uint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
LABEL_50:
    ++v5;
    unint64_t v7 = v8;
  }
  while (v5 <= v6);
  if (*((void *)this + 13) != *((void *)this + 14))
  {
    CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    CFAttributedStringRef Mutable = CFAttributedStringCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
    uint64_t v24 = *((void *)this + 14) - *((void *)this + 13);
    if (v24)
    {
      uint64_t v25 = 0;
      unint64_t v26 = v24 / 56;
      if (v26 <= 1) {
        uint64_t v27 = 1;
      }
      else {
        uint64_t v27 = v26;
      }
      do
      {
        uint64_t v28 = (__CFString *)[[NSString alloc] initWithCharactersNoCopy:*((void *)this + 4) + 2 * *(void *)(*((void *)this + 13) + v25) length:*(void *)(*((void *)this + 13) + v25 + 8) freeWhenDone:0];
        v71.CFIndex location = CFAttributedStringGetLength(Mutable);
        v71.NSUInteger length = 0;
        CFAttributedStringReplaceString(Mutable, v71, v28);

        v25 += 56;
        --v27;
      }
      while (v27);
    }
    uint64_t v29 = (void *)[*(id *)this paragraphStyleAtCharIndex:0 effectiveRange:0];
    CFDictionaryRef v30 = (const __CFDictionary *)[v29 getTypesetterAttributes:0 scalePercent:*((void *)this + 1) isRightToLeft:0];
    v72.NSUInteger length = CFAttributedStringGetLength(Mutable);
    aStr = Mutable;
    v72.CFIndex location = 0;
    CFAttributedStringSetAttributes(Mutable, v72, v30, 1u);
    uint64_t v31 = *((void *)this + 14) - *((void *)this + 13);
    if (v31)
    {
      uint64_t v32 = 0;
      uint64_t v33 = 0;
      unint64_t v34 = v31 / 56;
      if (v34 <= 1) {
        unint64_t v34 = 1;
      }
      unint64_t v65 = v34;
      do
      {
        CGFloat v35 = (NSRange *)(*contentsDeallocator + 56 * v33);
        CFIndex location = v35->location;
        NSUInteger length = v35->length;
        unint64_t v38 = length + v35->location;
        if (v35->location < v38)
        {
          CFIndex v39 = v32 - location;
          do
          {
            uint64_t v40 = [*(id *)this characterStyleAtCharIndex:location effectiveRange:&effectiveRange];
            if (v40)
            {
              uint64_t v41 = v40;
              CFRange effectiveRange = (CFRange)NSIntersectionRange(*v35, (NSRange)effectiveRange);
              CFDictionaryRef v42 = (const __CFDictionary *)[v29 getTypesetterAttributes:v41 scalePercent:*((void *)this + 1) isRightToLeft:0];
              v73.CFIndex location = v39 + location;
              v73.NSUInteger length = effectiveRange.length;
              CFAttributedStringSetAttributes(aStr, v73, v42, 1u);
            }
            CFIndex location = effectiveRange.length + effectiveRange.location;
          }
          while (effectiveRange.length + effectiveRange.location < v38);
        }
        v32 += length;
        ++v33;
      }
      while (v33 != v65);
    }
    FontForStyle = TSWPFastCreateFontForStyle(0, v29, 0x64uLL);
    TSWPFontGetLineHeight();
    double v45 = v44;
    CFRelease(FontForStyle);
    uint64_t v46 = CTTypesetterCreateWithAttributedString(aStr);
    double v47 = (char *)*((void *)this + 13);
    if (v47 != *((char **)this + 14))
    {
      CFIndex v48 = 0;
      contentsDeallocatorCATransform3D a = (const __CFAllocator *)*MEMORY[0x263EFFB28];
      CFStringRef v49 = (const __CFString *)*MEMORY[0x263F03CA8];
      do
      {
        unint64_t v51 = *(void *)v47;
        CFIndex v50 = *((void *)v47 + 1);
        if (*((void *)v47 + 2))
        {
          double v52 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v53 = [NSString stringWithUTF8String:"void TSWPParagraphTypesetter::pSetupTateChuYokoForParagraph()"];
          objc_msgSend(v52, "handleFailureInFunction:file:lineNumber:description:", v53, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPParagraphTypesetter.mm"), 702, @"Tate chu yoko line ref should be null");
        }
        v74.CFIndex location = v48;
        v74.NSUInteger length = v50;
        double Line = CTTypesetterCreateLine(v46, v74);
        *((void *)v47 + 2) = Line;
        double TypographicBounds = CTLineGetTypographicBounds(Line, (CGFloat *)v47 + 4, (CGFloat *)v47 + 5, (CGFloat *)v47 + 6);
        *((double *)v47 + 3) = TypographicBounds;
        if (TypographicBounds >= v45)
        {
          CFIndex v60 = v50;
          if (v51 < v50 + v51)
          {
            do
            {
              TSWPParagraphTypesetter::pConvertCharacterIndexToFullWidthNumber(this, v51++);
              --v60;
            }
            while (v60);
          }
          std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,_TSWPTateChuYokoRun *,_TSWPTateChuYokoRun *,_TSWPTateChuYokoRun *,0>((uint64_t)(v47 + 56), *((void *)this + 14), (uint64_t)v47);
          double v59 = v61;
          CGFloat v62 = (char *)*((void *)this + 14);
          if (v62 != v61)
          {
            do
            {
              double v63 = (const void *)*((void *)v62 - 5);
              if (v63) {
                CFRelease(v63);
              }
              v62 -= 56;
            }
            while (v62 != v59);
          }
          *((void *)this + 14) = v59;
        }
        else
        {
          LOWORD(effectiveRange.location) = 32;
          CFStringRef v56 = CFStringCreateWithCharactersNoCopy(alloc, (const UniChar *)&effectiveRange, 1, contentsDeallocatora);
          v75.CFIndex location = v51;
          v75.NSUInteger length = 1;
          CFAttributedStringReplaceString(*((CFMutableAttributedStringRef *)this + 7), v75, v56);
          *(_WORD *)(*((void *)this + 4) + 2 * v51) = effectiveRange.location;
          CFRelease(v56);
          CTRunDelegateRef v57 = CTRunDelegateCreate(&gTateChuYokoWidthRunDelegateCallBacks, v47);
          v76.CFIndex location = v51;
          v76.NSUInteger length = 1;
          CFAttributedStringSetAttribute(*((CFMutableAttributedStringRef *)this + 7), v76, v49, v57);
          CFRelease(v57);
          CTRunDelegateRef v58 = CTRunDelegateCreate(&gTateChuYokoWidthRunDelegateCallBacks, 0);
          v77.CFIndex location = v51 + 1;
          v77.NSUInteger length = v50 - 1;
          CFAttributedStringSetAttribute(*((CFMutableAttributedStringRef *)this + 7), v77, v49, v58);
          CFRelease(v58);
          v47 += 56;
          double v59 = (char *)*((void *)this + 14);
        }
        v48 += v50;
      }
      while (v47 != v59);
    }
    CFRelease(v46);
    CFRelease(aStr);
  }
}

void sub_22375AD34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, CFTypeRef cf)
{
  *(void *)(v16 + 112) = v17;
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

double TSWPParagraphTypesetter::getPositionForLocalCharIndex(TSWPParagraphTypesetter *this, const TSWPLineFragment *a2, unint64_t a3)
{
  uint64_t v3 = *((void *)a2 + 24);
  uint64_t v4 = *((void *)a2 + 25);
  double v5 = 0.0;
  if (v3 != v4)
  {
    while (1)
    {
      CFRange StringRange = CTLineGetStringRange((CTLineRef)*(void *)v3);
      if (StringRange.location <= a3 && StringRange.location + StringRange.length >= a3) {
        break;
      }
      v3 += 48;
      if (v3 == v4) {
        return v5;
      }
    }
    double v9 = *(double *)(v3 + 8);
    return v9 + CTLineGetOffsetForStringIndex(*(CTLineRef *)v3, a3, 0);
  }
  return v5;
}

unint64_t TSWPParagraphTypesetter::pCalculateRubyOverlap(uint64_t a1, unint64_t *a2, uint64_t a3, void *a4, void *a5)
{
  *a5 = 0;
  *a4 = 0;
  uint64_t v10 = *(void *)(a3 + 8);
  uint64_t v11 = *(void *)(a3 + 16);
  unint64_t result = [*(id *)a3 baseTextScript];
  if (result == 6)
  {
    unint64_t v13 = *(const __CTLine **)(a3 + 24);
    if (v13) {
      double length = (double)(unint64_t)CTLineGetStringRange(v13).length;
    }
    else {
      double length = 0.0;
    }
    double v15 = *(double *)(a3 + 32);
    unint64_t result = objc_msgSend(*(id *)a1, "charRangeMappedToStorage:", v10, v11);
    BOOL v18 = result > *a2 && v10 != 0;
    BOOL v19 = result + v16 < a2[1] + *a2 && (unint64_t)(v11 + v10) < *(void *)(a1 + 24) + *(void *)(a1 + 16);
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    double v22 = v15 / length;
    if (v18) {
      unint64_t result = TSWPParagraphTypesetter::pAllowableRubyOverlapAtIndex((TSWPParagraphTypesetter *)a1, v22, v10 - 1);
    }
    *a4 = v21;
    if (v19)
    {
      unint64_t result = TSWPParagraphTypesetter::pAllowableRubyOverlapAtIndex((TSWPParagraphTypesetter *)a1, v22, v11 + v10);
      uint64_t v20 = v23;
    }
    *a5 = v20;
  }
  return result;
}

void *TSWPParagraphTypesetter::findTateChuYokoLineRefsForCharIndex(TSWPParagraphTypesetter *this, uint64_t a2)
{
  if (*((void *)this + 13) == *((void *)this + 14)) {
    return 0;
  }
  uint64_t v3 = [*(id *)this charIndexMappedFromStorage:a2];
  double v5 = (void *)*((void *)this + 13);
  uint64_t v4 = (void *)*((void *)this + 14);
  if (v4 != v5)
  {
    unint64_t v6 = 0x6DB6DB6DB6DB6DB7 * (v4 - v5);
    do
    {
      unint64_t v7 = v6 >> 1;
      uint64_t v8 = &v5[7 * (v6 >> 1)];
      unint64_t v10 = *v8;
      double v9 = v8 + 7;
      v6 += ~(v6 >> 1);
      if (v10 < v3) {
        double v5 = v9;
      }
      else {
        unint64_t v6 = v7;
      }
    }
    while (v6);
  }
  if (v5 == v4 || *v5 != v3) {
    return 0;
  }
  uint64_t v11 = v5 + 7;
  do
  {
    BOOL v12 = v11;
    if (v11 == v4) {
      break;
    }
    v11 += 7;
  }
  while (*v12 == v3);
  return v12 - 7;
}

BOOL TSWPParagraphTypesetter::rubyLayoutIsDisabledForField(TSWPParagraphTypesetter *this, TSWPRubyField *a2)
{
  uint64_t v2 = *((void *)this + 10);
  uint64_t v3 = *((void *)this + 11) - v2;
  if (!v3) {
    return 0;
  }
  unint64_t v4 = v3 / 72;
  if (v4 <= 1) {
    unint64_t v4 = 1;
  }
  for (uint64_t i = (TSWPRubyField **)(v2 + 64); *(i - 8) != a2; i += 9)
  {
    if (!--v4) {
      return 0;
    }
  }
  return *(unsigned char *)i != 0;
}

TSWPParagraphTypesetter *TSWPParagraphTypesetter::disableRubyLayoutForField(TSWPParagraphTypesetter *this, TSWPRubyField *a2)
{
  uint64_t v2 = *((void *)this + 10);
  uint64_t v3 = *((void *)this + 11) - v2;
  if (v3)
  {
    unint64_t v4 = v3 / 72;
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    double v5 = (unsigned char *)(v2 + 64);
    do
    {
      if (*((TSWPRubyField **)v5 - 8) == a2) {
        *double v5 = 1;
      }
      v5 += 72;
      --v4;
    }
    while (v4);
  }
  return this;
}

TSWPParagraphTypesetter *TSWPParagraphTypesetter::enableRubyLayoutForField(TSWPParagraphTypesetter *this, TSWPRubyField *a2)
{
  uint64_t v2 = *((void *)this + 10);
  uint64_t v3 = *((void *)this + 11) - v2;
  if (v3)
  {
    unint64_t v4 = v3 / 72;
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    double v5 = (TSWPRubyField **)(v2 + 64);
    do
    {
      if (*(v5 - 8) == a2) {
        *(unsigned char *)double v5 = 0;
      }
      v5 += 9;
      --v4;
    }
    while (v4);
  }
  return this;
}

uint64_t TSWPParagraphTypesetter::isZeroWidthTrailingSpace(TSWPParagraphTypesetter *this, unint64_t a2)
{
  uint64_t v2 = *((void *)this + 10);
  uint64_t v3 = *((void *)this + 11) - v2;
  if (v3)
  {
    unint64_t v4 = v3 / 72;
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    double v5 = (double *)(v2 + 56);
    do
    {
      unint64_t v6 = *((void *)v5 - 5) + *((void *)v5 - 6);
      if (v6 <= a2) {
        break;
      }
      if (v6 - 1 == a2 && *v5 == 0.0) {
        return 1;
      }
      v5 += 9;
      --v4;
    }
    while (v4);
  }
  return 0;
}

void TSWPParagraphTypesetter::pAddRubyRunDelegateAtIndexForRun()
{
}

TSWPParagraphTypesetter *TSWPParagraphTypesetter::TSWPRubyRunDelegateDeallocateCallback(TSWPParagraphTypesetter *this, void *a2)
{
  if (this) {
    JUMPOUT(0x223CB8F20);
  }
  return this;
}

double TSWPParagraphTypesetter::TSWPRubyRunDelegateGetWidthCallback(TSWPParagraphTypesetter *this, void *a2)
{
  double result = 0.0;
  if (this)
  {
    uint64_t v3 = *((void *)this + 1);
    if (v3)
    {
      if (!*(unsigned char *)(v3 + 64)) {
        return *(double *)(v3 + 56) * 0.5;
      }
    }
  }
  return result;
}

void TSWPParagraphTypesetter::pConvertCharacterIndexToFullWidthNumber(TSWPParagraphTypesetter *this, unint64_t a2)
{
  uint64_t v2 = *((void *)this + 4);
  if (a2 >= (*((void *)this + 5) - v2) >> 1)
  {
    uint64_t v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v9 = [NSString stringWithUTF8String:"void TSWPParagraphTypesetter::pConvertCharacterIndexToFullWidthNumber(const NSUInteger)"];
    uint64_t v10 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPParagraphTypesetter.mm"];
    [v8 handleFailureInFunction:v9 file:v10 lineNumber:518 description:@"Access outside array"];
  }
  else
  {
    int v5 = *(unsigned __int16 *)(v2 + 2 * a2);
    int v6 = TSWPFullWidthCharacterForCharacter(*(unsigned __int16 *)(v2 + 2 * a2));
    UniChar chars = v6;
    if (v5 != v6)
    {
      CFStringRef v7 = CFStringCreateWithCharactersNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], &chars, 1, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
      v13.CFIndex location = a2;
      v13.double length = 1;
      CFAttributedStringReplaceString(*((CFMutableAttributedStringRef *)this + 7), v13, v7);
      *(_WORD *)(*((void *)this + 4) + 2 * a2) = chars;
      CFRelease(v7);
    }
  }
}

void TSWPParagraphTypesetter::pConvertCharacterIndexToNormalWidthNumber(TSWPParagraphTypesetter *this, unint64_t a2)
{
  uint64_t v2 = *((void *)this + 4);
  if (a2 >= (*((void *)this + 5) - v2) >> 1)
  {
    uint64_t v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v9 = [NSString stringWithUTF8String:"void TSWPParagraphTypesetter::pConvertCharacterIndexToNormalWidthNumber(const NSUInteger)"];
    uint64_t v10 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPParagraphTypesetter.mm"];
    [v8 handleFailureInFunction:v9 file:v10 lineNumber:536 description:@"Access outside array"];
  }
  else
  {
    int v5 = *(unsigned __int16 *)(v2 + 2 * a2);
    int v6 = TSWPNormalWidthCharacterForCharacter(*(unsigned __int16 *)(v2 + 2 * a2));
    UniChar chars = v6;
    if (v5 != v6)
    {
      CFStringRef v7 = CFStringCreateWithCharactersNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], &chars, 1, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
      v13.CFIndex location = a2;
      v13.double length = 1;
      CFAttributedStringReplaceString(*((CFMutableAttributedStringRef *)this + 7), v13, v7);
      *(_WORD *)(*((void *)this + 4) + 2 * a2) = chars;
      CFRelease(v7);
    }
  }
}

const __CTRun *TSWPParagraphTypesetter::pGetRunForLocalCharIndex(TSWPParagraphTypesetter *this, const TSWPLineFragment *a2, unint64_t a3)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  uint64_t v3 = (CTLineRef *)*((void *)a2 + 24);
  unint64_t v4 = (CTLineRef *)*((void *)a2 + 25);
  if (v3 != v4)
  {
    while (1)
    {
      CFRange StringRange = CTLineGetStringRange(*v3);
      if (StringRange.location <= a3 && StringRange.location + StringRange.length > a3) {
        break;
      }
      v3 += 6;
      if (v3 == v4) {
        goto LABEL_21;
      }
    }
    CFArrayRef GlyphRuns = CTLineGetGlyphRuns(*v3);
    long long v19 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    uint64_t v9 = [(__CFArray *)GlyphRuns countByEnumeratingWithState:&v19 objects:v23 count:16];
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = *(void *)v20;
LABEL_10:
      uint64_t v12 = 0;
      while (1)
      {
        if (*(void *)v20 != v11) {
          objc_enumerationMutation(GlyphRuns);
        }
        CFRange v13 = *(const __CTRun **)(*((void *)&v19 + 1) + 8 * v12);
        CFRange v14 = CTRunGetStringRange(v13);
        if (v14.location <= a3 && v14.location + v14.length > a3) {
          break;
        }
        if (v10 == ++v12)
        {
          uint64_t v10 = [(__CFArray *)GlyphRuns countByEnumeratingWithState:&v19 objects:v23 count:16];
          if (v10) {
            goto LABEL_10;
          }
          goto LABEL_21;
        }
      }
      if (v13) {
        return v13;
      }
    }
  }
LABEL_21:
  uint64_t v16 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
  uint64_t v17 = objc_msgSend(NSString, "stringWithUTF8String:", "CTRunRef TSWPParagraphTypesetter::pGetRunForLocalCharIndex(const TSWPLineFragment *, NSUInteger) const");
  objc_msgSend(v16, "handleFailureInFunction:file:lineNumber:description:", v17, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPParagraphTypesetter.mm"), 793, @"Could not find run for local char index in line fragment");
  return 0;
}

uint64_t TSWPParagraphTypesetter::pAllowableRubyOverlapAtIndex(TSWPParagraphTypesetter *this, double a2, uint64_t a3)
{
  UChar32 v3 = *(unsigned __int16 *)(*((void *)this + 4) + 2 * a3);
  uint64_t result = TSWPScriptForCharacter(v3);
  if ((result - 3) < 2) {
    return result;
  }
  if (v3 <= 12288)
  {
    if (v3 <= 0x3B && ((1 << v3) & 0xC00500000000000) != 0) {
      return result;
    }
    if ((v3 - 8212) <= 0x12 && ((1 << (v3 - 20)) & 0x60001) != 0) {
      return result;
    }
LABEL_22:
    uint64_t result = IsOpeningBracketCharacter(v3);
    if ((result & 1) == 0) {
      return IsClosingBracketCharacter(v3);
    }
    return result;
  }
  if (((v3 - 12289) > 0x34 || ((1 << (v3 - 1)) & 0x1C000000000003) == 0)
    && (v3 - 12539) >= 2)
  {
    goto LABEL_22;
  }
  return result;
}

uint64_t IsOpeningBracketCharacter(int a1)
{
  uint64_t result = 1;
  if (a1 <= 8219)
  {
    if (a1 <= 122)
    {
      if (a1 != 40 && a1 != 91) {
        return 0;
      }
      return result;
    }
    if (a1 == 123 || a1 == 171) {
      return result;
    }
    int v3 = 8216;
  }
  else
  {
    if ((a1 - 12296) <= 0x15 && ((1 << (a1 - 8)) & 0x215155) != 0 || a1 == 8220) {
      return result;
    }
    int v3 = 10629;
  }
  if (a1 != v3) {
    return 0;
  }
  return result;
}

uint64_t IsClosingBracketCharacter(int a1)
{
  uint64_t result = 1;
  if (a1 <= 8220)
  {
    if (a1 <= 124)
    {
      if (a1 != 41 && a1 != 93) {
        return 0;
      }
      return result;
    }
    if (a1 == 125 || a1 == 187) {
      return result;
    }
    int v3 = 8217;
  }
  else
  {
    if ((a1 - 12297) <= 0x16 && ((1 << (a1 - 9)) & 0x415155) != 0 || a1 == 8221) {
      return result;
    }
    int v3 = 10630;
  }
  if (a1 != v3) {
    return 0;
  }
  return result;
}

double TSWPParagraphTypesetter::pRubyRunDelegateGetWidth(uint64_t a1, uint64_t a2)
{
  double result = 0.0;
  if (a2)
  {
    if (!*(unsigned char *)(a2 + 64)) {
      return *(double *)(a2 + 56) * 0.5;
    }
  }
  return result;
}

double TSWPTateChuYokoRunDelegateGetWidthCallback(double *a1)
{
  if (a1) {
    return a1[4] + a1[5];
  }
  else {
    return 0.0;
  }
}

CFTypeRef std::vector<TSWPLineRef>::__construct_one_at_end[abi:nn180100]<TSWPLineRef const&>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  CFTypeRef result = *(CFTypeRef *)a2;
  *(void *)uint64_t v3 = *(void *)a2;
  *(_OWORD *)(v3 + 8) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(v3 + 24) = *(_OWORD *)(a2 + 24);
  *(_DWORD *)(v3 + 40) = *(_DWORD *)(a2 + 40);
  if (result) {
    CFTypeRef result = CFRetain(result);
  }
  *(void *)(a1 + 8) = v3 + 48;
  return result;
}

void sub_22375B8CC(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<TSWPLineRef>::__push_back_slow_path<TSWPLineRef const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 4);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0x555555555555555) {
    abort();
  }
  uint64_t v8 = a1[2];
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v8 - v2) >> 4);
  if (2 * v9 > v4) {
    unint64_t v4 = 2 * v9;
  }
  if (v9 >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v10 = 0x555555555555555;
  }
  else {
    unint64_t v10 = v4;
  }
  uint64_t v20 = v7;
  uint64_t v11 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<TSWPLineRef>>(v7, v10);
  uint64_t v12 = &v11[48 * v3];
  v17[0] = v11;
  v17[1] = v12;
  BOOL v18 = v12;
  long long v19 = &v11[48 * v13];
  CFRange v14 = *(const void **)a2;
  *(void *)uint64_t v12 = *(void *)a2;
  *(_OWORD *)(v12 + 8) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(v12 + 24) = *(_OWORD *)(a2 + 24);
  *((_DWORD *)v12 + 10) = *(_DWORD *)(a2 + 40);
  if (v14)
  {
    CFRetain(v14);
    uint64_t v12 = v18;
  }
  BOOL v18 = v12 + 48;
  std::vector<TSWPLineRef>::__swap_out_circular_buffer(a1, v17);
  uint64_t v15 = a1[1];
  std::__split_buffer<TSWPLineRef>::~__split_buffer(v17);
  return v15;
}

void sub_22375B9D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TSWPLineRef>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<TSWPLineRef>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:nn180100]<std::allocator<TSWPLineRef>,std::reverse_iterator<TSWPLineRef*>,std::reverse_iterator<TSWPLineRef*>,std::reverse_iterator<TSWPLineRef*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<TSWPLineRef>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(48 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:nn180100]<std::allocator<TSWPLineRef>,std::reverse_iterator<TSWPLineRef*>,std::reverse_iterator<TSWPLineRef*>,std::reverse_iterator<TSWPLineRef*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  if (a3 != a5)
  {
    uint64_t v10 = a3;
    uint64_t v11 = a7 - 24;
    do
    {
      uint64_t v13 = *(const void **)(v10 - 48);
      v10 -= 48;
      uint64_t v12 = v13;
      *(void *)(v11 - 24) = v13;
      *(_OWORD *)(v11 - 16) = *(_OWORD *)(v10 + 8);
      *(_OWORD *)uint64_t v11 = *(_OWORD *)(v10 + 24);
      *(_DWORD *)(v11 + 16) = *(_DWORD *)(v10 + 40);
      if (v13) {
        CFRetain(v12);
      }
      v11 -= 48;
      v7 -= 48;
    }
    while (v10 != a5);
  }
  return a6;
}

void **std::__split_buffer<TSWPLineRef>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<TSWPLineRef>::clear[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  while (v1 != v2)
  {
    uint64_t v5 = *(const void **)(v1 - 48);
    v1 -= 48;
    unint64_t v4 = v5;
    *(void *)(a1 + 16) = v1;
    if (v5)
    {
      CFRelease(v4);
      uint64_t v1 = *(void *)(a1 + 16);
    }
  }
}

void std::vector<_TSWPRubyRun>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 72)
  {
    unint64_t v4 = *(const void **)(i - 48);
    if (v4) {
      CFRelease(v4);
    }
  }
  a1[1] = v2;
}

void std::vector<_TSWPTateChuYokoRun>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 56)
  {
    unint64_t v4 = *(const void **)(i - 40);
    if (v4) {
      CFRelease(v4);
    }
  }
  a1[1] = v2;
}

uint64_t std::vector<_TSWPRubyRun>::__push_back_slow_path<_TSWPRubyRun const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  unint64_t v3 = 0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 3);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0x38E38E38E38E38ELL) {
    abort();
  }
  uint64_t v8 = a1[2];
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v9 = 0x8E38E38E38E38E39 * ((v8 - v2) >> 3);
  if (2 * v9 > v4) {
    unint64_t v4 = 2 * v9;
  }
  if (v9 >= 0x1C71C71C71C71C7) {
    unint64_t v10 = 0x38E38E38E38E38ELL;
  }
  else {
    unint64_t v10 = v4;
  }
  uint64_t v18 = v7;
  if (v10) {
    uint64_t v11 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKit::OpticalKern::Spec::Entry>>(v7, v10);
  }
  else {
    uint64_t v11 = 0;
  }
  CFRange v14 = v11;
  uint64_t v15 = &v11[72 * v3];
  uint64_t v17 = &v11[72 * v10];
  _TSWPRubyRun::_TSWPRubyRun((uint64_t)v15, a2);
  uint64_t v16 = v15 + 72;
  std::vector<_TSWPRubyRun>::__swap_out_circular_buffer(a1, &v14);
  uint64_t v12 = a1[1];
  std::__split_buffer<_TSWPRubyRun>::~__split_buffer(&v14);
  return v12;
}

void sub_22375BD44(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<_TSWPRubyRun>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t _TSWPRubyRun::_TSWPRubyRun(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(void *)(a1 + 24) = 0;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(unsigned char *)(a1 + 64) = *(unsigned char *)(a2 + 64);
  unint64_t v3 = *(const void **)(a2 + 24);
  if (v3)
  {
    CFRetain(v3);
    uint64_t v5 = *(void *)(a2 + 24);
  }
  else
  {
    uint64_t v5 = 0;
  }
  *(void *)(a1 + 24) = v5;
  return a1;
}

uint64_t std::vector<_TSWPRubyRun>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t result = a2[1];
  while (v4 != v5)
  {
    v4 -= 72;
    uint64_t result = _TSWPRubyRun::_TSWPRubyRun(result - 72, v4);
  }
  a2[1] = result;
  uint64_t v7 = *a1;
  *a1 = result;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void **std::__split_buffer<_TSWPRubyRun>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<_TSWPRubyRun>::clear[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  while (v1 != v2)
  {
    *(void *)(a1 + 16) = v1 - 72;
    uint64_t v4 = *(const void **)(v1 - 48);
    if (v4)
    {
      CFRelease(v4);
      uint64_t v1 = *(void *)(a1 + 16);
    }
    else
    {
      v1 -= 72;
    }
  }
}

uint64_t std::vector<_TSWPTateChuYokoRun>::__push_back_slow_path<_TSWPTateChuYokoRun const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 3);
  unint64_t v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) > 0x492492492492492) {
    abort();
  }
  uint64_t v8 = a1[2];
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v9 = 0x6DB6DB6DB6DB6DB7 * ((v8 - v2) >> 3);
  if (2 * v9 > v4) {
    unint64_t v4 = 2 * v9;
  }
  if (v9 >= 0x249249249249249) {
    unint64_t v10 = 0x492492492492492;
  }
  else {
    unint64_t v10 = v4;
  }
  uint64_t v18 = v7;
  if (v10) {
    uint64_t v11 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKit::ILayout>>(v7, v10);
  }
  else {
    uint64_t v11 = 0;
  }
  CFRange v14 = v11;
  uint64_t v15 = &v11[56 * v3];
  uint64_t v17 = &v11[56 * v10];
  _TSWPTateChuYokoRun::_TSWPTateChuYokoRun((uint64_t)v15, a2);
  uint64_t v16 = v15 + 56;
  std::vector<_TSWPTateChuYokoRun>::__swap_out_circular_buffer(a1, &v14);
  uint64_t v12 = a1[1];
  std::__split_buffer<_TSWPTateChuYokoRun>::~__split_buffer(&v14);
  return v12;
}

void sub_22375BFDC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<_TSWPTateChuYokoRun>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t _TSWPTateChuYokoRun::_TSWPTateChuYokoRun(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  uint64_t v3 = *(const void **)(a2 + 16);
  if (v3)
  {
    CFRetain(v3);
    uint64_t v5 = *(void *)(a2 + 16);
  }
  else
  {
    uint64_t v5 = 0;
  }
  *(void *)(a1 + 16) = v5;
  return a1;
}

uint64_t std::vector<_TSWPTateChuYokoRun>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t result = a2[1];
  while (v4 != v5)
  {
    v4 -= 56;
    uint64_t result = _TSWPTateChuYokoRun::_TSWPTateChuYokoRun(result - 56, v4);
  }
  a2[1] = result;
  uint64_t v7 = *a1;
  *a1 = result;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void **std::__split_buffer<_TSWPTateChuYokoRun>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<_TSWPTateChuYokoRun>::clear[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  while (v1 != v2)
  {
    *(void *)(a1 + 16) = v1 - 56;
    uint64_t v4 = *(const void **)(v1 - 40);
    if (v4)
    {
      CFRelease(v4);
      uint64_t v1 = *(void *)(a1 + 16);
    }
    else
    {
      v1 -= 56;
    }
  }
}

uint64_t std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,_TSWPTateChuYokoRun *,_TSWPTateChuYokoRun *,_TSWPTateChuYokoRun *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a1 != a2)
  {
    do
    {
      _TSWPTateChuYokoRun::operator=(a3, v4);
      v4 += 56;
      a3 += 56;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

uint64_t _TSWPTateChuYokoRun::operator=(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(const void **)(a2 + 16);
  if (v4) {
    CFRetain(v4);
  }
  uint64_t v5 = *(const void **)(a1 + 16);
  if (v5) {
    CFRelease(v5);
  }
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  return a1;
}

uint64_t TSWPReplaceActionComparator_block_invoke(uint64_t a1, void *a2, void *a3)
{
  unint64_t v4 = [a2 targetCharIndex];
  unint64_t v5 = [a3 targetCharIndex];
  if (v4 < v5) {
    return -1;
  }
  else {
    return v4 > v5;
  }
}

void TSWPStyleAttributeArray::~TSWPStyleAttributeArray(TSWPAttributeArray *this)
{
  this->id var0 = (void **)&unk_26D687C30;
  if (this->var2)
  {
    uint64_t v2 = 0;
    unint64_t v3 = 0;
    do
    {
      (*((void (**)(TSWPAttributeArray *, char *))this->var0 + 24))(this, (char *)this->var4 + v2);
      ++v3;
      v2 += 16;
    }
    while (v3 < this->var2);
  }

  TSWPAttributeArray::~TSWPAttributeArray(this);
}

{
  uint64_t vars8;

  TSWPStyleAttributeArray::~TSWPStyleAttributeArray(this);

  JUMPOUT(0x223CB8F20);
}

void sub_22375CC10(_Unwind_Exception *a1)
{
  TSWPAttributeArray::~TSWPAttributeArray(v1);
  _Unwind_Resume(a1);
}

const char *TSWPStyleAttributeArray::className(TSWPStyleAttributeArray *this)
{
  return "TSWPStyleAttributeArray";
}

BOOL TSWPStyleAttributeArray::canCollapseAttributes(TSWPStyleAttributeArray *this, const TSWPAttributeRecord *a2, const TSWPAttributeRecord *a3)
{
  return *((void *)a2 + 1) == *((void *)a3 + 1);
}

uint64_t TSWPStyleAttributeArray::deleteAttributesInRangeWithString(uint64_t a1, _NSRange a2, uint64_t a3, uint64_t a4, uint64_t a5, TSWPStorageTransaction *a6)
{
  if (!(a2.length | a4)) {
    return 1;
  }
  NSUInteger length = a2.length;
  unint64_t location = a2.location;
  unint64_t v10 = TSWPAttributeArray::calculateAttributeRangeForCharacterRange((TSWPAttributeArray *)a1, a2);
  unint64_t v11 = v10;
  uint64_t v13 = v12;
  if (v10
    && v10 < *(void *)(a1 + 16)
    && TSWPAttributeArray::charIndexForAttributeIndex((TSWPAttributeArray *)a1, v10) > location)
  {
    --v11;
    ++v13;
    goto LABEL_12;
  }
  uint64_t v14 = *(void *)(a1 + 16);
  if (!v14 || v11 != v14 || v13)
  {
LABEL_12:
    if (!v13) {
      goto LABEL_91;
    }
    goto LABEL_13;
  }
  --v11;
  if (!*(void *)(*(void *)(a1 + 32) + 16 * v11 + 8)) {
    goto LABEL_91;
  }
  v55.unint64_t location = TSWPAttributeArray::rangeForAttributeIndex((TSWPAttributeArray *)a1, v11);
  v57.unint64_t location = location;
  v57.NSUInteger length = length;
  if (NSIntersectionRange(v55, v57).length) {
    goto LABEL_11;
  }
  if (length) {
    goto LABEL_91;
  }
  unint64_t v48 = TSWPAttributeArray::rangeForAttributeIndex((TSWPAttributeArray *)a1, v11);
  char v18 = 1;
  if (location >= v48 && location - v48 < v49)
  {
LABEL_11:
    uint64_t v13 = 1;
LABEL_13:
    unint64_t v15 = v13 + v11;
    if (a4)
    {
      if (v11 < v15)
      {
        unint64_t v16 = 0;
        uint64_t v17 = (16 * v11) | 8;
        char v18 = 1;
        uint64_t v19 = 0x7FFFFFFFFFFFFFFFLL;
        while (1)
        {
          NSUInteger v20 = TSWPAttributeArray::rangeForAttributeIndex((TSWPAttributeArray *)a1, v11);
          v22.unint64_t location = v20;
          v22.NSUInteger length = v21;
          if (length)
          {
            v56.unint64_t location = location;
            v56.NSUInteger length = length;
            if (NSIntersectionRange(v56, v22).length) {
              goto LABEL_21;
            }
          }
          else if (location >= v20 && location - v20 < v21)
          {
LABEL_21:
            if (v11)
            {
              if (v19 == 0x7FFFFFFFFFFFFFFFLL)
              {
                char v18 = 0;
                if (*(void *)(*(void *)(a1 + 32) + v17))
                {
                  unint64_t v16 = 1;
                  uint64_t v19 = v11;
                }
                else
                {
                  uint64_t v19 = 0x7FFFFFFFFFFFFFFFLL;
                }
              }
              else
              {
                char v18 = 0;
                ++v16;
              }
            }
            else
            {
              if (*(void *)(*(void *)(a1 + 32) + 8)) {
                TSWPAttributeArray::replaceObjectForAttributeIndex((TSWPAttributeArray *)a1, 0, 0, 0, a6);
              }
              char v18 = 0;
            }
          }
          ++v11;
          v17 += 16;
          if (!--v13)
          {
            if (!v16) {
              return v18 & 1;
            }
LABEL_89:
            *(unsigned char *)(a1 + 56) = 0;
            (*(void (**)(uint64_t, uint64_t, unint64_t, TSWPStorageTransaction *))(*(void *)a1 + 56))(a1, v19, v16, a6);
            (*(void (**)(uint64_t, uint64_t, TSWPStorageTransaction *))(*(void *)a1 + 232))(a1, v19, a6);
            return v18 & 1;
          }
        }
      }
LABEL_91:
      char v18 = 1;
      return v18 & 1;
    }
    if (v11 >= v15) {
      goto LABEL_91;
    }
    unint64_t v51 = location;
    unint64_t v52 = v13 + v11;
    uint64_t v24 = 0;
    unint64_t v16 = 0;
    unint64_t v53 = location + length;
    uint64_t v25 = (16 * v11) | 8;
    uint64_t v26 = 0x7FFFFFFFFFFFFFFFLL;
    while (1)
    {
      unint64_t v27 = v16;
      unint64_t v28 = v11 + v24;
      unint64_t v29 = TSWPAttributeArray::rangeForAttributeIndex((TSWPAttributeArray *)a1, v11 + v24);
      if (v29 >= location)
      {
        if (v29 != location)
        {
          if (v29 >= v53)
          {
            if (v29 > v53 && v28 && !*(void *)(*(void *)(a1 + 32) + v25))
            {
              unint64_t v45 = v26;
              if (TSWPAttributeArray::charIndexForAttributeIndex((TSWPAttributeArray *)a1, v11 + v24 - 1) < v53)
              {
                if (v26 == 0x7FFFFFFFFFFFFFFFLL) {
                  unint64_t v16 = 1;
                }
                else {
                  ++v16;
                }
                if (v26 == 0x7FFFFFFFFFFFFFFFLL) {
                  unint64_t v45 = v11 + v24;
                }
                if (v45 > v28 || v11 + v24 - v45 >= v16)
                {
                  uint64_t v46 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
                  uint64_t v47 = objc_msgSend(NSString, "stringWithUTF8String:", "BOOL TSWPStyleAttributeArray::deleteAttributesInRangeWithString(NSRange, NSString *, NSUInteger, markerArray &, TSWPStorageTransaction *)");
                  objc_msgSend(v46, "handleFailureInFunction:file:lineNumber:description:", v47, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStyleAttributeArray.mm"), 619, @"Deletion range should have been sequential and therefore incrementing it above should include this iteration(i)");
                }
              }
              uint64_t v26 = v45;
            }
            goto LABEL_81;
          }
LABEL_58:
          BOOL v44 = v26 == 0x7FFFFFFFFFFFFFFFLL;
          if (v26 == 0x7FFFFFFFFFFFFFFFLL) {
            unint64_t v16 = 1;
          }
          else {
            unint64_t v16 = v27 + 1;
          }
LABEL_61:
          if (v44) {
            uint64_t v26 = v11 + v24;
          }
          goto LABEL_81;
        }
        uint64_t v37 = v30;
        if (v28 != *(void *)(a1 + 16) - 1
          && TSWPAttributeArray::charIndexForAttributeIndex((TSWPAttributeArray *)a1, v11 + v24 + 1) <= location)
        {
          CFIndex v50 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v38 = v26;
          uint64_t v39 = objc_msgSend(NSString, "stringWithUTF8String:", "BOOL TSWPStyleAttributeArray::deleteAttributesInRangeWithString(NSRange, NSString *, NSUInteger, markerArray &, TSWPStorageTransaction *)");
          uint64_t v40 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStyleAttributeArray.mm"];
          uint64_t v41 = v39;
          uint64_t v26 = v38;
          unint64_t location = v51;
          [v50 handleFailureInFunction:v41 file:v40 lineNumber:549 description:@"Bad attributeRange."];
        }
        if (v52 < *(void *)(a1 + 16)
          && TSWPAttributeArray::charIndexForAttributeIndex((TSWPAttributeArray *)a1, v52) == v53)
        {
          goto LABEL_58;
        }
        if (!v28) {
          goto LABEL_54;
        }
        if (v28 == *(void *)(a1 + 16) - 1)
        {
          unint64_t v42 = [*(id *)(a1 + 40) length];
          uint64_t v43 = *(void *)(a1 + 32);
          if (location + v37 >= v42 && *(void *)(v43 + v25)) {
            goto LABEL_58;
          }
        }
        else
        {
          uint64_t v43 = *(void *)(a1 + 32);
        }
        unint64_t v16 = v27;
        if (!*(void *)(v43 + v25 - 16))
        {
          BOOL v44 = v26 == 0x7FFFFFFFFFFFFFFFLL;
          if (v26 == 0x7FFFFFFFFFFFFFFFLL) {
            unint64_t v16 = 1;
          }
          else {
            unint64_t v16 = v27 + 1;
          }
          goto LABEL_61;
        }
        if (*(void *)(v43 + v25)) {
LABEL_80:
        }
          TSWPAttributeArray::replaceObjectForAttributeIndex((TSWPAttributeArray *)a1, 0, v11 + v24, 0, a6);
      }
      else
      {
        if (v28 + 1 != *(void *)(a1 + 16)
          && TSWPAttributeArray::charIndexForAttributeIndex((TSWPAttributeArray *)a1, v28 + 1) <= location)
        {
          uint64_t v31 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v32 = v26;
          uint64_t v33 = objc_msgSend(NSString, "stringWithUTF8String:", "BOOL TSWPStyleAttributeArray::deleteAttributesInRangeWithString(NSRange, NSString *, NSUInteger, markerArray &, TSWPStorageTransaction *)");
          uint64_t v34 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStyleAttributeArray.mm"];
          uint64_t v35 = v33;
          uint64_t v26 = v32;
          unint64_t location = v51;
          [v31 handleFailureInFunction:v35 file:v34 lineNumber:516 description:@"Bad attributeRange."];
        }
        if (!v28)
        {
LABEL_54:
          if (*(void *)(*(void *)(a1 + 32) + 8)) {
            TSWPAttributeArray::replaceObjectForAttributeIndex((TSWPAttributeArray *)a1, 0, 0, 0, a6);
          }
          unint64_t v16 = v27;
          goto LABEL_81;
        }
        uint64_t v36 = *(void *)(a1 + 32);
        if (!*(void *)(v36 + v25 - 16)) {
          goto LABEL_58;
        }
        unint64_t v16 = v27;
        if (*(void *)(v36 + v25)) {
          goto LABEL_80;
        }
      }
LABEL_81:
      ++v24;
      v25 += 16;
      if (v13 == v24)
      {
        uint64_t v19 = v26;
        char v18 = 0;
        if (!v16) {
          return v18 & 1;
        }
        goto LABEL_89;
      }
    }
  }
  return v18 & 1;
}

void TSWPStyleAttributeArray::adoptStylesheetWithMapper(TSWPAttributeArray *a1, uint64_t a2, void *a3)
{
  unint64_t var2 = a1->var2;
  if (var2)
  {
    unint64_t v6 = 0;
    uint64_t v7 = 8;
    do
    {
      if (*(void *)((char *)a1->var4 + v7))
      {
        TSWPAttributeArray::replaceObjectForAttributeIndex(a1, (objc_object *)objc_msgSend(a3, "mappedStyleForStyle:"), v6, 0, 0);
        unint64_t var2 = a1->var2;
      }
      ++v6;
      v7 += 16;
    }
    while (v6 < var2);
  }
}

uint64_t TSWPStyleAttributeArray::shouldDeleteAttributeBeforeReplace(TSWPStyleAttributeArray *this)
{
  return 1;
}

const char *TSWPStringAttributeArray::className(TSWPStringAttributeArray *this)
{
  return "TSWPStringAttributeArray";
}

void TSWPStringAttributeArray::~TSWPStringAttributeArray(TSWPAttributeArray *this)
{
  TSWPStyleAttributeArray::~TSWPStyleAttributeArray(this);

  JUMPOUT(0x223CB8F20);
}

void TSWPLineBalancingRestoreLayoutInfo::TSWPLineBalancingRestoreLayoutInfo(TSWPLineBalancingRestoreLayoutInfo *this)
{
  *((_OWORD *)this + 43) = 0u;
}

{
  TSWPParagraphEnumerator::TSWPParagraphEnumerator((TSWPParagraphEnumerator *)((char *)this + 24));
  bzero(this, 0x2B0uLL);
  *((_OWORD *)this + 43) = 0u;
}

id *TSWPLineBalancingRestoreLayoutInfo::prepareForRestore(id *this, id *a2, int a3, int a4, double a5)
{
  uint64_t result = TSWPLayoutState::operator=(this, a2);
  *((_DWORD *)this + 172) = a3;
  *((_DWORD *)this + 173) = a4;
  *((double *)this + 87) = a5;
  return result;
}

double TSWPLineBalancingRestoreLayoutInfo::restoreLocalState(uint64_t a1, TSWPLineFragmentArray **a2, _DWORD *a3, _DWORD *a4, double *a5)
{
  int v10 = TSWPLineFragmentArray::count(*a2);
  v12.unint64_t location = *(unsigned int *)(a1 + 688);
  v12.NSUInteger length = (v10 - LODWORD(v12.location));
  TSWPLineFragmentArray::removeObjectsInRange(*a2, v12);
  *a3 = *(_DWORD *)(a1 + 688);
  *a4 = *(_DWORD *)(a1 + 692);
  double result = *(double *)(a1 + 696);
  *a5 = result;
  return result;
}

void TSWPLineBalancingLayoutState::restoreLocalState(uint64_t a1, TSWPLineFragmentArray **a2, _DWORD *a3, _DWORD *a4, double *a5)
{
  *(_DWORD *)(a1 + 732) = *a3;
  *(void *)(a1 + 744) = *(void *)(a1 + 736);
}

double TSWPLineBalancingLayoutState::pMaxLineWidth(TSWPLineBalancingLayoutState *this)
{
  uint64_t v1 = (double *)*((void *)this + 92);
  uint64_t v2 = (double *)*((void *)this + 93);
  if (v1 == v2) {
    return 0.0;
  }
  unint64_t v3 = v1 + 1;
  if (v1 + 1 != v2)
  {
    double v4 = *v1;
    unint64_t v5 = v1 + 1;
    do
    {
      double v6 = *v5++;
      double v7 = v6;
      if (v4 < v6)
      {
        double v4 = v7;
        uint64_t v1 = v3;
      }
      unint64_t v3 = v5;
    }
    while (v5 != v2);
  }
  return *v1;
}

double TSWPLineBalancingLayoutState::pComputeScore(TSWPLineBalancingLayoutState *this)
{
  uint64_t v1 = (double *)*((void *)this + 92);
  double result = 0.0;
  while (v1 != *((double **)this + 93))
  {
    double v3 = *v1++;
    double result = result + v3 * v3;
  }
  return result;
}

uint64_t TSWPLineBalancingLayoutState::forceCompletion(uint64_t this)
{
  int v1 = *(_DWORD *)(this + 728);
  if (v1 == 2)
  {
    _NSRange v12 = (void *)(this + 776);
    int v13 = 3;
LABEL_15:
    *(void *)(this + 768) = *v12;
    *(_DWORD *)(this + 728) = v13;
    goto LABEL_16;
  }
  if (v1 == 1)
  {
    uint64_t v2 = *(double **)(this + 736);
    double v3 = *(double **)(this + 744);
    if (v2 == v3)
    {
      *(void *)(this + 776) = 0;
      double v10 = 0.0;
    }
    else
    {
      double v4 = v2 + 1;
      unint64_t v5 = *(double **)(this + 736);
      if (v2 + 1 != v3)
      {
        double v6 = *v2;
        unint64_t v5 = *(double **)(this + 736);
        double v7 = v2 + 1;
        do
        {
          double v8 = *v7++;
          double v9 = v8;
          if (v6 < v8)
          {
            double v6 = v9;
            unint64_t v5 = v4;
          }
          double v4 = v7;
        }
        while (v7 != v3);
      }
      *(double *)(this + 776) = *v5;
      double v10 = 0.0;
      do
      {
        double v11 = *v2++;
        double v10 = v10 + v11 * v11;
      }
      while (v2 != v3);
    }
    int v13 = 0;
    *(double *)(this + 784) = v10;
    _NSRange v12 = (void *)(this + 704);
    goto LABEL_15;
  }
LABEL_16:
  *(unsigned char *)(this + 792) = 1;
  return this;
}

double TSWPLineBalancingLayoutState::updateWithEndOfColumn(TSWPLineBalancingLayoutState *this, uint64_t a2, double a3)
{
  return TSWPLineBalancingLayoutState::pUpdateWithEndOfParagraphOrColumn(this, a2, 0, a3);
}

BOOL FloatArraysEqual(double *a1, double *a2, unint64_t a3)
{
  if (!a3) {
    return 1;
  }
  unint64_t v3 = 0;
  unsigned int v4 = 1;
  do
  {
    double v5 = a1[v3];
    double v6 = a2[v3];
    BOOL v7 = v5 == v6;
    unint64_t v3 = v4++;
  }
  while (v5 == v6 && v3 < a3);
  return v7;
}

TSWPLineFragmentArray *TSWPLineFragmentArray::disableClippingForObjectAtIndex(TSWPLineFragmentArray *this, unint64_t a2)
{
  if (a2 < (uint64_t)(*((void *)this + 1) - *(void *)this) >> 4) {
    *(_DWORD *)(*(void *)(*(void *)this + 16 * a2) + 24) |= 0x1000000u;
  }
  return this;
}

uint64_t TSWPLineFragmentArray::firstObject(TSWPLineFragmentArray *this)
{
  if (*((void *)this + 1) == *(void *)this) {
    return 0;
  }
  else {
    return **(void **)this;
  }
}

void TSWPLineFragmentArray::removeLastObject(TSWPLineFragmentArray *this)
{
  uint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *(std::__shared_weak_count **)(v2 - 8);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  *((void *)this + 1) = v2 - 16;
  if (*(void *)this == v2 - 16) {
    __int16 v4 = 0;
  }
  else {
    __int16 v4 = *(_WORD *)(*(void *)(v2 - 32) + 552);
  }
  *((_WORD *)this + 12) = v4;
}

uint64_t TSWPLineFragmentArray::removeObjectsInRange(TSWPLineFragmentArray *this, _NSRange a2)
{
  uint64_t result = std::vector<std::shared_ptr<TSWPLineFragment>>::erase((uint64_t)this, *(void *)this + 16 * a2.location, (long long *)(*(void *)this + 16 * a2.location + 16 * a2.length));
  *((_WORD *)this + 12) = 0;
  __int16 v4 = *(uint64_t **)this;
  double v5 = (uint64_t *)*((void *)this + 1);
  if (*(uint64_t **)this != v5)
  {
    __int16 v6 = 0;
    uint64_t v7 = 0x7FFFFFFFFFFFFFFFLL;
    do
    {
      uint64_t v9 = *v4;
      v4 += 2;
      uint64_t v8 = v9;
      uint64_t v10 = *(unsigned __int16 *)(v9 + 552);
      if (v7 != v10) {
        ++v6;
      }
      *(_WORD *)(v8 + 552) = v6 - 1;
      uint64_t v7 = v10;
    }
    while (v4 != v5);
    *((_WORD *)this + 12) = v6;
  }
  return result;
}

uint64_t std::vector<std::shared_ptr<TSWPLineFragment>>::erase(uint64_t a1, uint64_t a2, long long *a3)
{
  if ((long long *)a2 != a3)
  {
    std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::shared_ptr<TSWPLineFragment> *,std::shared_ptr<TSWPLineFragment> *,std::shared_ptr<TSWPLineFragment> *>((uint64_t)&v10, a3, *(long long **)(a1 + 8), a2);
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)(a1 + 8);
    if (v7 != v5)
    {
      do
      {
        uint64_t v8 = *(std::__shared_weak_count **)(v7 - 8);
        if (v8) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v8);
        }
        v7 -= 16;
      }
      while (v7 != v6);
    }
    *(void *)(a1 + 8) = v6;
  }
  return a2;
}

void TSWPLineFragmentArray::removeAllObjects(TSWPLineFragmentArray *this)
{
  *((_WORD *)this + 12) = 0;
}

__n64 TSWPLineFragmentArray::boundsRect(TSWPLineFragmentArray *this)
{
  result.n64_u64[0] = *MEMORY[0x263F001A0];
  uint64_t v2 = *(void *)(MEMORY[0x263F001A0] + 8);
  uint64_t v3 = *(void *)(MEMORY[0x263F001A0] + 16);
  uint64_t v4 = *(void *)(MEMORY[0x263F001A0] + 24);
  uint64_t v5 = *(uint64_t **)this;
  uint64_t v6 = (uint64_t *)*((void *)this + 1);
  while (v5 != v6)
  {
    uint64_t v7 = *v5;
    v5 += 2;
    *(CGRect *)result.n64_u64 = CGRectUnion(*(CGRect *)result.n64_u64, *(CGRect *)(v7 + 48));
  }
  return result;
}

TSWPLineFragmentArray *TSWPLineFragmentArray::incrementStartCharIndexes(TSWPLineFragmentArray *this, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)this;
  uint64_t v3 = (uint64_t *)*((void *)this + 1);
  if (*(uint64_t **)this != v3)
  {
    do
    {
      uint64_t v5 = *v2;
      v2 += 2;
      *(void *)v5 += a2;
      *(void *)(v5 + 16) += a2;
      this = (TSWPLineFragmentArray *)[*(id *)(v5 + 184) adjustRangesByDelta:a2];
      *(void *)(v5 + 496) = *(void *)(v5 + 488);
    }
    while (v2 != v3);
  }
  return this;
}

void TSWPLineFragmentArray::offsetLineFragmentsBy(TSWPLineFragmentArray *this, CGPoint a2)
{
  uint64_t v2 = *(TSWPLineFragment ***)this;
  uint64_t v3 = (TSWPLineFragment **)*((void *)this + 1);
  if (*(TSWPLineFragment ***)this != v3)
  {
    CGFloat y = a2.y;
    CGFloat x = a2.x;
    do
    {
      uint64_t v6 = *v2;
      v2 += 2;
      v7.CGFloat x = x;
      v7.CGFloat y = y;
      TSWPLineFragment::offsetBy(v6, v7);
    }
    while (v2 != v3);
  }
}

void TSWPLineFragmentArray::setStorage(TSWPLineFragmentArray *this, TSWPStorage *a2, uint64_t a3)
{
  uint64_t v3 = *(uint64_t **)this;
  uint64_t v4 = (uint64_t *)*((void *)this + 1);
  if (*(uint64_t **)this != v4)
  {
    id v7 = 0;
    do
    {
      uint64_t v9 = *v3;
      uint64_t v8 = (std::__shared_weak_count *)v3[1];
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      }

      *(void *)(v9 + 184) = 0;
      *(void *)v9 += a3;
      *(void *)(v9 + 16) += a3;
      [0 adjustRangesByDelta:a3];
      *(void *)(v9 + 496) = *(void *)(v9 + 488);
      uint64_t v10 = *(void *)(v9 + 16);
      if (!v7 || v10) {
        id v7 = -[TSWPStorage textSourceForLayoutInRange:](a2, "textSourceForLayoutInRange:", v10, [*(id *)(v9 + 512) length]);
      }
      *(void *)(v9 + 184) = v7;
      if (v8) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v8);
      }
      v3 += 2;
    }
    while (v3 != v4);
  }
}

void sub_22375E574(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TSWPLineFragmentArray::lineFragmentCountForBaseline(TSWPLineFragmentArray *this, double a2)
{
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *((void *)this + 1);
  if (*(void *)this == v3)
  {
    return 0;
  }
  else
  {
    unsigned int v4 = 0;
    do
    {
      double v5 = *(double *)(*(void *)v2 + 32) + *(double *)(*(void *)v2 + 40);
      if (v5 == a2)
      {
        ++v4;
      }
      else if (v5 > a2)
      {
        return v4;
      }
      v2 += 16;
    }
    while (v2 != v3);
  }
  return v4;
}

uint64_t TSWPLineFragmentArray::findLineIndexForCharIndex(TSWPLineFragmentArray *this, unint64_t a2)
{
  uint64_t v2 = *((void *)this + 1);
  uint64_t v3 = v2 - *(void *)this + 16;
  while (v2 != *(void *)this)
  {
    unsigned int v4 = *(unint64_t **)(v2 - 16);
    v2 -= 16;
    v3 -= 16;
    if (*v4 < a2) {
      return v3 >> 4;
    }
  }
  return 0;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<TSWPLineFragment>>,std::reverse_iterator<std::shared_ptr<TSWPLineFragment>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v3);
    }
    v1 += 16;
  }
}

long long *std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::shared_ptr<TSWPLineFragment> *,std::shared_ptr<TSWPLineFragment> *,std::shared_ptr<TSWPLineFragment> *>(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
  double v5 = a2;
  if (a2 != a3)
  {
    do
    {
      long long v7 = *v5;
      *(void *)double v5 = 0;
      *((void *)v5 + 1) = 0;
      uint64_t v8 = *(std::__shared_weak_count **)(a4 + 8);
      *(_OWORD *)a4 = v7;
      if (v8) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v8);
      }
      ++v5;
      a4 += 16;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

void TSWPChangeEnumerator::TSWPChangeEnumerator(TSWPChangeEnumerator *this, TSWPStorage *a2)
{
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  v5.unint64_t location = [(TSWPStorage *)a2 range];
  v5.NSUInteger length = v4;
  TSWPChangeEnumerator::setupWithStorageAndRange(this, a2, v5);
}

{
  NSUInteger v4;
  _NSRange v5;

  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  v5.unint64_t location = [(TSWPStorage *)a2 range];
  v5.NSUInteger length = v4;
  TSWPChangeEnumerator::setupWithStorageAndRange(this, a2, v5);
}

TSWPAttributeArray **TSWPChangeEnumerator::setupWithStorageAndRange(TSWPChangeEnumerator *this, TSWPStorage *a2, _NSRange a3)
{
  _NSRange v16 = a3;
  _NSRange v5 = [(TSWPStorage *)a2 insertionChangesTable];
  if (v5)
  {
    uint64_t v6 = (TSWPAttributeArray *)v5;
    TSWPAttributeArray::begin((TSWPAttributeArray *)v5, &v16, &v14);
    uint64_t v7 = v15;
    *(void *)this = v14;
    *((void *)this + 1) = v7;
    TSWPAttributeArray::end(v6, &v16, &v14);
    uint64_t v8 = v15;
    *((void *)this + 2) = v14;
    *((void *)this + 3) = v8;
  }
  uint64_t v9 = [(TSWPStorage *)a2 deletionChangesTable];
  if (v9)
  {
    uint64_t v10 = (TSWPAttributeArray *)v9;
    TSWPAttributeArray::begin((TSWPAttributeArray *)v9, &v16, &v14);
    uint64_t v11 = v15;
    *((void *)this + 4) = v14;
    *((void *)this + 5) = v11;
    TSWPAttributeArray::end(v10, &v16, &v14);
    uint64_t v12 = v15;
    *((void *)this + 6) = v14;
    *((void *)this + 7) = v12;
  }
  return TSWPChangeEnumerator::advanceToNonNilObject(this);
}

void TSWPChangeEnumerator::TSWPChangeEnumerator(TSWPChangeEnumerator *this, TSWPStorage *a2, _NSRange a3)
{
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  TSWPChangeEnumerator::setupWithStorageAndRange(this, a2, a3);
}

{
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  TSWPChangeEnumerator::setupWithStorageAndRange(this, a2, a3);
}

TSWPChangeEnumerator *TSWPChangeEnumerator::operator++(TSWPChangeEnumerator *a1)
{
  uint64_t v2 = TSWPChangeEnumerator::iter(a1);
  if (v2)
  {
    v2[1] = (TSWPAttributeArray *)((char *)v2[1] + 1);
    TSWPChangeEnumerator::advanceToNonNilObject(a1);
  }
  return a1;
}

TSWPAttributeArray **TSWPChangeEnumerator::iter(TSWPChangeEnumerator *this)
{
  if (*((void *)this + 1) == *((void *)this + 3)) {
    uint64_t v1 = 0;
  }
  else {
    uint64_t v1 = this;
  }
  unint64_t v2 = *((void *)this + 5);
  if (v2 == *((void *)this + 7)) {
    return (TSWPAttributeArray **)v1;
  }
  uint64_t v3 = this;
  NSUInteger v4 = (TSWPAttributeArray **)((char *)this + 32);
  if (!v1) {
    return v4;
  }
  unint64_t v5 = TSWPAttributeArray::charIndexForAttributeIndex(*v4, v2);
  if (v5 < TSWPAttributeArray::charIndexForAttributeIndex(*(TSWPAttributeArray **)v1, *((void *)v1 + 1))) {
    return v4;
  }
  return (TSWPAttributeArray **)v3;
}

TSWPAttributeArray **TSWPChangeEnumerator::advanceToNonNilObject(TSWPChangeEnumerator *this)
{
  for (uint64_t i = this; ; this = i)
  {
    __n64 result = TSWPChangeEnumerator::iter(this);
    if (!result) {
      break;
    }
    uint64_t v3 = result[1];
    if (*((void *)(*result)->var4 + 2 * (void)v3 + 1)) {
      break;
    }
    result[1] = (TSWPAttributeArray *)((char *)&v3->var0 + 1);
  }
  return result;
}

TSWPAttributeArray **TSWPChangeEnumerator::change(TSWPChangeEnumerator *this)
{
  __n64 result = TSWPChangeEnumerator::iter(this);
  if (result) {
    return (TSWPAttributeArray **)*((void *)(*result)->var4 + 2 * (void)result[1] + 1);
  }
  return result;
}

uint64_t TSWPChangeEnumerator::changeRange(TSWPChangeEnumerator *this)
{
  uint64_t v1 = TSWPChangeEnumerator::iter(this);
  if (!v1) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  unint64_t v2 = (unint64_t)v1[1];
  uint64_t v3 = *v1;

  return TSWPAttributeArray::rangeForAttributeIndex(v3, v2);
}

uint64_t TSWPChangeEnumerator::changeIsHidden(TSWPChangeEnumerator *this)
{
  uint64_t v1 = TSWPChangeEnumerator::iter(this);
  if (v1) {
    uint64_t v1 = (TSWPAttributeArray **)*((void *)(*v1)->var4 + 2 * (void)v1[1] + 1);
  }

  return [v1 isHidden];
}

uint64_t TSWPChangeEnumerator::changeIsDeletion(TSWPChangeEnumerator *this)
{
  uint64_t v1 = TSWPChangeEnumerator::iter(this);
  if (v1) {
    uint64_t v1 = (TSWPAttributeArray **)*((void *)(*v1)->var4 + 2 * (void)v1[1] + 1);
  }

  return [v1 isDeletion];
}

NSUInteger NSIntersectionRangeWithEdge(_NSRange a1, _NSRange a2, int a3)
{
  NSUInteger length = a2.length;
  NSUInteger location = a2.location;
  NSUInteger v6 = a1.length;
  NSUInteger v7 = a1.location;
  NSRange v8 = NSIntersectionRange(a1, a2);
  if (length) {
    BOOL v9 = v6 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = 0x7FFFFFFFFFFFFFFFLL;
  }
  if (v7 | location) {
    uint64_t v11 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v11 = v10;
  }
  if (v8 == 0uLL) {
    NSUInteger v12 = v11;
  }
  else {
    NSUInteger v12 = v8.location;
  }
  if (location + length == v7) {
    NSUInteger v13 = v7;
  }
  else {
    NSUInteger v13 = v12;
  }
  if (v7 + v6 == location) {
    NSUInteger v14 = location;
  }
  else {
    NSUInteger v14 = v13;
  }
  if (a3) {
    return v14;
  }
  else {
    return v12;
  }
}

uint64_t TSWPRangeVector::characterCount(TSWPRangeVector *this)
{
  begiuint64_t n = this->__begin_;
  end = this->__end_;
  if (this->__begin_ == end) {
    return 0;
  }
  uint64_t result = 0;
  do
  {
    result += begin->length;
    ++begin;
  }
  while (begin != end);
  return result;
}

uint64_t TSWPRangeVector::containsCharacterAtIndex(TSWPRangeVector *this, NSUInteger a2, int a3)
{
  int64_t v3 = (char *)this->__end_ - (char *)this->__begin_;
  if (!v3) {
    return 0;
  }
  unint64_t v4 = v3 >> 4;
  begiuint64_t n = this->__begin_;
  do
  {
    unint64_t v6 = v4 >> 1;
    NSUInteger v7 = &begin[v4 >> 1];
    NSUInteger location = v7->location;
    NSRange v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (location > a2) {
      unint64_t v4 = v6;
    }
    else {
      begiuint64_t n = v8;
    }
  }
  while (v4);
  if (begin == this->__begin_) {
    return 0;
  }
  NSUInteger v10 = begin[-1].location;
  NSUInteger length = begin[-1].length;
  if (a2 >= v10 && a2 - v10 < length) {
    return 1;
  }
  uint64_t result = 0;
  if (a3)
  {
    if (length + v10 == a2) {
      return 1;
    }
  }
  return result;
}

BOOL TSWPRangeVector::containsRange(TSWPRangeVector *this, const _NSRange *a2)
{
  NSUInteger location = a2->location;
  NSUInteger v5 = TSWPRangeVector::rangeContainingPosition(this, a2->location, 0);
  BOOL result = 0;
  if (v5 != 0x7FFFFFFFFFFFFFFFLL && v5 <= location) {
    return v5 + v4 >= a2->length + location;
  }
  return result;
}

NSUInteger TSWPRangeVector::rangeContainingPosition(TSWPRangeVector *this, NSUInteger a2, unsigned __int8 a3)
{
  NSUInteger result = *MEMORY[0x263F7C7C8];
  begiuint64_t n = this->__begin_;
  int64_t v6 = (char *)this->__end_ - (char *)this->__begin_;
  if (v6)
  {
    unint64_t v7 = v6 >> 4;
    NSRange v8 = begin;
    do
    {
      unint64_t v9 = v7 >> 1;
      NSUInteger v10 = &v8[v7 >> 1];
      NSUInteger location = v10->location;
      uint64_t v11 = v10 + 1;
      v7 += ~(v7 >> 1);
      if (location > a2) {
        unint64_t v7 = v9;
      }
      else {
        NSRange v8 = v11;
      }
    }
    while (v7);
    if (v8 != begin)
    {
      NSUInteger v14 = v8[-1].location;
      NSUInteger length = v8[-1].length;
      BOOL v15 = a2 < v14 || a2 - v14 >= length;
      if (!v15 && ((a2 == v14) & a3) == 0) {
        return v14;
      }
    }
  }
  return result;
}

BOOL TSWPRangeVector::hasExactRange(TSWPRangeVector *this, const _NSRange *a2)
{
  NSUInteger location = a2->location;
  NSUInteger v5 = TSWPRangeVector::rangeContainingPosition(this, a2->location, 0);
  BOOL result = 0;
  if (v5 != 0x7FFFFFFFFFFFFFFFLL) {
    return location == v5 && a2->length == v4;
  }
  return result;
}

BOOL TSWPRangeVector::intersectsRange(TSWPRangeVector *this, const _NSRange *a2)
{
  begiuint64_t n = this->__begin_;
  end = this->__end_;
  if (end == this->__begin_)
  {
    int64_t v6 = this->__begin_;
  }
  else
  {
    unint64_t v5 = end - this->__begin_;
    int64_t v6 = this->__begin_;
    do
    {
      unint64_t v7 = v5 >> 1;
      p_NSUInteger location = &v6[v5 >> 1].location;
      NSUInteger v10 = *p_location;
      unint64_t v9 = (_NSRange *)(p_location + 2);
      v5 += ~(v5 >> 1);
      if (a2->location < v10) {
        unint64_t v5 = v7;
      }
      else {
        int64_t v6 = v9;
      }
    }
    while (v5);
  }
  if (v6 != end && NSIntersectionRange(*a2, *v6).length) {
    return 1;
  }
  if (v6 == begin) {
    return 0;
  }
  return NSIntersectionRange(*a2, *(v6 - 16)).length != 0;
}

uint64_t TSWPRangeVector::indexForRange(TSWPRangeVector *this, _NSRange a2)
{
  end = this->__end_;
  if (end == this->__begin_)
  {
    begiuint64_t n = this->__begin_;
  }
  else
  {
    unint64_t v3 = end - this->__begin_;
    begiuint64_t n = this->__begin_;
    do
    {
      unint64_t v5 = v3 >> 1;
      int64_t v6 = &begin[v3 >> 1];
      NSUInteger location = v6->location;
      unint64_t v7 = v6 + 1;
      v3 += ~(v3 >> 1);
      if (location < a2.location) {
        begiuint64_t n = v7;
      }
      else {
        unint64_t v3 = v5;
      }
    }
    while (v3);
  }
  if (begin == end)
  {
    begiuint64_t n = this->__end_;
  }
  else if (begin->location == a2.location)
  {
    begin += a2.length < begin->length;
  }
  return begin - this->__begin_;
}

void TSWPRangeVector::addRange(TSWPRangeVector *this, const _NSRange *a2)
{
  if (a2->location != 0x7FFFFFFFFFFFFFFFLL)
  {
    begiuint64_t n = this->__begin_;
    end = (char *)this->__end_;
    if ((char *)this->__begin_ != end)
    {
      if (!a2->length) {
        return;
      }
      _NSRange v43 = *a2;
      NSUInteger length = v43.length;
      NSUInteger location = v43.location;
      unint64_t v8 = (end - (char *)begin) >> 4;
      unint64_t v9 = begin;
      do
      {
        unint64_t v10 = v8 >> 1;
        uint64_t v11 = &v9[v8 >> 1];
        NSUInteger v13 = v11->location;
        NSUInteger v12 = v11 + 1;
        v8 += ~(v8 >> 1);
        if (v13 < v43.location) {
          unint64_t v9 = v12;
        }
        else {
          unint64_t v8 = v10;
        }
      }
      while (v8);
      if (end == (char *)v9)
      {
        int v20 = 0;
        BOOL v15 = end;
        unint64_t v9 = (_NSRange *)end;
      }
      else
      {
        unint64_t v14 = (end - (char *)v9) >> 4;
        BOOL v15 = (char *)v9;
        do
        {
          unint64_t v16 = v14 >> 1;
          uint64_t v17 = (NSUInteger *)&v15[16 * (v14 >> 1)];
          NSUInteger v19 = *v17;
          char v18 = (char *)(v17 + 2);
          v14 += ~(v14 >> 1);
          if (v19 < v43.length + v43.location) {
            BOOL v15 = v18;
          }
          else {
            unint64_t v14 = v16;
          }
        }
        while (v14);
        if (NSIntersectionRangeWithEdge(v43, *v9, 1) == 0x7FFFFFFFFFFFFFFFLL)
        {
          int v20 = 0;
        }
        else
        {
          NSRange v32 = NSUnionRange(v43, *v9);
          NSUInteger location = v32.location;
          NSUInteger length = v32.length;
          _NSRange v43 = v32;
          int v20 = 1;
        }
      }
      if (v9 == begin)
      {
        unint64_t v9 = begin;
      }
      else
      {
        v44.NSUInteger location = location;
        v44.NSUInteger length = length;
        if (NSIntersectionRangeWithEdge(v44, v9[-1], 1) != 0x7FFFFFFFFFFFFFFFLL)
        {
          v45.NSUInteger location = location;
          v45.NSUInteger length = length;
          NSRange v33 = NSUnionRange(v45, v9[-1]);
          NSUInteger location = v33.location;
          NSUInteger length = v33.length;
          _NSRange v43 = v33;
          int v20 = 1;
          --v9;
        }
      }
      uint64_t v35 = v15 == end && v15 != (char *)begin;
      uint64_t v36 = (_NSRange *)&v15[16 * (v35 << 63 >> 63)];
      if (v36 == (_NSRange *)end
        || (v46.NSUInteger location = location,
            v46.NSUInteger length = length,
            NSIntersectionRangeWithEdge(v46, *v36, 1) == 0x7FFFFFFFFFFFFFFFLL))
      {
        if (!v20) {
          goto LABEL_59;
        }
      }
      else
      {
        NSRange v48 = *v36++;
        v47.NSUInteger location = location;
        v47.NSUInteger length = length;
        _NSRange v43 = NSUnionRange(v47, v48);
      }
      if (v9 >= v36)
      {
        if (v36 < v9)
        {
          uint64_t v41 = this->__end_;
          size_t v38 = (char *)v41 - (char *)v9;
          if (v41 != v9) {
            memmove(v36, v9, (char *)v41 - (char *)v9);
          }
          unint64_t v9 = v36;
          goto LABEL_58;
        }
        if (v9 == (_NSRange *)end)
        {
LABEL_60:
          std::vector<_NSRange>::insert((uint64_t)this, end, (char *)&v43);
          return;
        }
        uint64_t v40 = v9 + 1;
        unint64_t v42 = this->__end_;
        size_t v38 = (char *)v42 - (char *)&v9[1];
        if (v42 == &v9[1]) {
          goto LABEL_58;
        }
        uint64_t v39 = v9;
      }
      else
      {
        uint64_t v37 = this->__end_;
        size_t v38 = (char *)v37 - (char *)v36;
        if (v37 == v36)
        {
LABEL_58:
          this->__end_ = (_NSRange *)((char *)v9 + v38);
LABEL_59:
          end = (char *)v9;
          goto LABEL_60;
        }
        uint64_t v39 = v9;
        uint64_t v40 = v36;
      }
      memmove(v39, v40, v38);
      goto LABEL_58;
    }
    p_end_cap = &this->__end_cap_;
    value = this->__end_cap_.__value_;
    if (begin >= value)
    {
      uint64_t v24 = (char *)value - (char *)begin;
      uint64_t v25 = v24 >> 3;
      if ((unint64_t)(v24 >> 3) <= 1) {
        uint64_t v25 = 1;
      }
      if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v26 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v26 = v25;
      }
      unint64_t v27 = (_NSRange *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLength>>((uint64_t)p_end_cap, v26);
      unint64_t v29 = &v27[v28];
      *unint64_t v27 = *a2;
      uint64_t v23 = v27 + 1;
      uint64_t v31 = this->__begin_;
      uint64_t v30 = this->__end_;
      if (v30 != this->__begin_)
      {
        do
        {
          v27[-1] = v30[-1];
          --v27;
          --v30;
        }
        while (v30 != v31);
        uint64_t v30 = this->__begin_;
      }
      this->__begin_ = v27;
      this->__end_ = v23;
      this->__end_cap_.__value_ = v29;
      if (v30) {
        operator delete(v30);
      }
    }
    else
    {
      *begiuint64_t n = *a2;
      uint64_t v23 = begin + 1;
    }
    this->__end_ = v23;
  }
}

char *std::vector<_NSRange>::insert(uint64_t a1, char *__src, char *a3)
{
  unint64_t v3 = a3;
  uint64_t v4 = __src;
  int64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    NSUInteger v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 4) + 1;
    if (v14 >> 60) {
      abort();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 4;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 3 > v14) {
      unint64_t v14 = v17 >> 3;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v18 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      NSUInteger v19 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLength>>(a1 + 16, v18);
    }
    else {
      NSUInteger v19 = 0;
    }
    int v20 = &v19[16 * v16];
    __p = v19;
    unint64_t v27 = v20;
    uint64_t v28 = v20;
    unint64_t v29 = &v19[16 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1;
        }
        else {
          unint64_t v22 = v15 >> 3;
        }
        uint64_t v23 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLength>>(v8, v22);
        int v20 = &v23[16 * (v22 >> 2)];
        __p = v23;
        unint64_t v27 = v20;
        unint64_t v29 = &v23[16 * v24];
        if (v19) {
          operator delete(v19);
        }
      }
      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 16 * (v21 >> 1);
        unint64_t v27 = v20;
      }
    }
    *(_OWORD *)int v20 = *(_OWORD *)v3;
    uint64_t v28 = v20 + 16;
    uint64_t v4 = (char *)std::vector<EQKitPath::PathElement>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 15) & 0xFFFFFFFFFFFFFFF0;
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else if (__src == v6)
  {
    *(_OWORD *)__src = *(_OWORD *)a3;
    *(void *)(a1 + 8) = __src + 16;
  }
  else
  {
    unint64_t v9 = __src + 16;
    unint64_t v10 = v6 - 16;
    uint64_t v11 = *(_OWORD **)(a1 + 8);
    while (v10 < v6)
    {
      long long v12 = *(_OWORD *)v10;
      v10 += 16;
      *v11++ = v12;
    }
    *(void *)(a1 + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-16 * ((v6 - v9) >> 4)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 16 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(_OWORD *)uint64_t v4 = *(_OWORD *)v3;
  }
  return v4;
}

void sub_22375F988(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL TSWPRangeVector::removeRange(TSWPRangeVector *this, const _NSRange *a2)
{
  begiuint64_t n = this->__begin_;
  end = this->__end_;
  NSUInteger location = a2->location;
  NSUInteger length = a2->length;
  NSUInteger v7 = a2->location;
  if (end == this->__begin_)
  {
    BOOL result = 0;
    uint64_t v15 = begin;
  }
  else
  {
    unint64_t v8 = end - this->__begin_;
    unint64_t v9 = v8;
    unint64_t v10 = (char *)this->__begin_;
    do
    {
      unint64_t v11 = v9 >> 1;
      long long v12 = &v10[16 * (v9 >> 1)];
      NSUInteger v14 = *(void *)v12;
      NSUInteger v13 = v12 + 16;
      v9 += ~(v9 >> 1);
      if (v14 > location) {
        unint64_t v9 = v11;
      }
      else {
        unint64_t v10 = v13;
      }
    }
    while (v9);
    uint64_t v15 = this->__begin_;
    do
    {
      unint64_t v16 = v8 >> 1;
      uint64_t v17 = &v15[v8 >> 1];
      NSUInteger v19 = v17->location;
      unint64_t v18 = v17 + 1;
      v8 += ~(v8 >> 1);
      if (v19 < length + location) {
        uint64_t v15 = v18;
      }
      else {
        unint64_t v8 = v16;
      }
    }
    while (v8);
    if (v10 == (char *)begin)
    {
      BOOL result = 0;
    }
    else
    {
      BOOL result = 0;
      begiuint64_t n = (_NSRange *)(v10 - 16);
      NSUInteger v21 = *((void *)v10 - 2);
      NSUInteger v22 = location - v21;
      if (location < v21 || (NSUInteger v23 = *((void *)v10 - 1), v22 >= v23))
      {
        begiuint64_t n = (_NSRange *)v10;
      }
      else
      {
        BOOL result = location != v21;
        if (location != v21)
        {
          *((void *)v10 - 1) = v22;
          NSUInteger v7 = a2->location;
          NSUInteger length = a2->length;
          begiuint64_t n = (_NSRange *)v10;
        }
        NSUInteger v24 = length + v7;
        if (length + v7 >= v21 && length + v7 - v21 < v23)
        {
          NSUInteger v25 = v23 + v21;
          if (v24 <= v23 + v21) {
            NSUInteger v26 = v23 + v21;
          }
          else {
            NSUInteger v26 = length + v7;
          }
          if (v24 < v23 + v21) {
            NSUInteger v25 = length + v7;
          }
          v40.NSUInteger location = v25;
          v40.NSUInteger length = v26 - v25;
          if (location == v21) {
            *begiuint64_t n = v40;
          }
          else {
            std::vector<_NSRange>::insert((uint64_t)this, v10, (char *)&v40);
          }
          return 1;
        }
      }
    }
  }
  if (v15 != end)
  {
    NSUInteger v27 = v15->location;
    NSUInteger v28 = v15->length;
    NSUInteger v29 = length + v7;
    BOOL v31 = length + v7 >= v15->location;
    NSUInteger v30 = length + v7 - v15->location;
    BOOL v31 = v30 == 0 || !v31 || v30 >= v28;
    if (!v31)
    {
      if (v29 <= v28 + v27) {
        NSUInteger v32 = v28 + v27;
      }
      else {
        NSUInteger v32 = v29;
      }
      if (v29 >= v28 + v27) {
        NSUInteger v29 = v28 + v27;
      }
      v15->NSUInteger location = v29;
      v15->NSUInteger length = v32 - v29;
      BOOL result = 1;
    }
  }
  if (begin != v15)
  {
    NSUInteger v33 = v15[-1].location;
    NSUInteger v34 = v15[-1].length;
    NSUInteger v35 = a2->length + a2->location;
    if (v35 >= v33 && v35 - v33 < v34)
    {
      NSUInteger v37 = v34 + v33;
      if (v35 <= v37) {
        NSUInteger v38 = v37;
      }
      else {
        NSUInteger v38 = a2->length + a2->location;
      }
      if (v35 < v37) {
        NSUInteger v37 = a2->length + a2->location;
      }
      v15[-1].NSUInteger location = v37;
      v15[-1].NSUInteger length = v38 - v37;
      --v15;
    }
    if (begin != v15)
    {
      int64_t v39 = (char *)end - (char *)v15;
      if (end != v15) {
        memmove(begin, v15, (char *)end - (char *)v15);
      }
      this->__end_ = (_NSRange *)((char *)begin + v39);
    }
    return 1;
  }
  return result;
}

TSWPRangeVector *TSWPRangeVector::removeCharacterAtIndex(TSWPRangeVector *this, unint64_t a2)
{
  int64_t v2 = (char *)this->__end_ - (char *)this->__begin_;
  if (v2)
  {
    uint64_t v4 = this;
    uint64_t v5 = v2 >> 4;
    unint64_t v6 = a2 + 1;
    unint64_t v7 = v2 & 0xFFFFFFFFFFFFFFF0;
    uint64_t v8 = -(uint64_t)(v2 & 0xFFFFFFFFFFFFFFF0);
    do
    {
      begiuint64_t n = v4->__begin_;
      unint64_t v10 = (char *)v4->__begin_ + v7;
      this = (TSWPRangeVector *)(v10 - 16);
      unint64_t v11 = *((void *)v10 - 2);
      unint64_t v12 = *((void *)v10 - 1);
      unint64_t v13 = a2 - v11;
      if (a2 >= v11 && v13 < v12)
      {
        unint64_t v15 = v12 + v11;
        *(void *)&long long v20 = v6;
        *((void *)&v20 + 1) = v15 - v6;
        if (a2 == v11)
        {
          if (v15 == v6)
          {
            unint64_t v16 = (_NSRange *)((char *)begin + v7);
            end = v4->__end_;
            int64_t v18 = (char *)end - (char *)begin;
            uint64_t v19 = v8 + v18;
            if (v16 != end) {
              this = (TSWPRangeVector *)memmove(this, v16, v8 + v18);
            }
            v4->__end_ = (_NSRange *)((char *)v16 + (v19 & 0xFFFFFFFFFFFFFFF0) - 16);
          }
          else
          {
            *(_OWORD *)&this->__begin_ = v20;
          }
        }
        else
        {
          *((void *)v10 - 2) = v11;
          *((void *)v10 - 1) = v13;
          if (*((void *)&v20 + 1)) {
            this = (TSWPRangeVector *)std::vector<_NSRange>::insert((uint64_t)v4, (char *)begin + v7, (char *)&v20);
          }
        }
      }
      v7 -= 16;
      v8 += 16;
      --v5;
    }
    while (v5);
  }
  return this;
}

TSWPRangeVector *TSWPRangeVector::insertedTextAtIndex(TSWPRangeVector *this, NSUInteger a2, uint64_t a3)
{
  int64_t v3 = (char *)this->__end_ - (char *)this->__begin_;
  if (v3)
  {
    unint64_t v4 = v3 >> 4;
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    p_NSUInteger length = &this->__begin_->length;
    do
    {
      NSUInteger v6 = *(p_length - 1);
      if (*p_length + v6 >= a2)
      {
        if (v6 <= a2) {
          uint64_t v7 = a3;
        }
        else {
          uint64_t v7 = 0;
        }
        NSUInteger v8 = v7 + *p_length;
        if (v6 <= a2) {
          uint64_t v9 = 0;
        }
        else {
          uint64_t v9 = a3;
        }
        *(p_length - 1) = v9 + v6;
        *p_NSUInteger length = v8;
      }
      p_length += 2;
      --v4;
    }
    while (v4);
  }
  return this;
}

TSWPRangeVector *TSWPRangeVector::insertGapAtIndex(TSWPRangeVector *this, NSUInteger a2, uint64_t a3)
{
  int64_t v3 = (char *)this->__end_ - (char *)this->__begin_;
  if (v3)
  {
    NSUInteger v6 = this;
    unint64_t v7 = 0;
    unint64_t v8 = v3 >> 4;
    uint64_t v9 = a3 + a2;
    do
    {
      begiuint64_t n = v6->__begin_;
      unint64_t v11 = &v6->__begin_[v7];
      NSUInteger location = v11->location;
      NSUInteger v13 = v11->length + v11->location;
      BOOL v14 = v13 > a2;
      NSUInteger v15 = v13 - a2;
      if (v14)
      {
        if (a2 <= location)
        {
          v11->NSUInteger location = location + a3;
        }
        else
        {
          v16[0] = v9;
          v16[1] = v15;
          v11->NSUInteger location = location;
          v11->NSUInteger length = a2 - location;
          this = (TSWPRangeVector *)std::vector<_NSRange>::insert((uint64_t)v6, (char *)&begin[++v7], (char *)v16);
          ++v8;
        }
      }
      ++v7;
    }
    while (v7 < v8);
  }
  return this;
}

TSWPRangeVector *TSWPRangeVector::deletedTextAtRange(TSWPRangeVector *this, const _NSRange *a2)
{
  end = this->__end_;
  if (end != this->__begin_)
  {
    unint64_t v4 = this;
    unint64_t v5 = 0;
    unint64_t v6 = end - this->__begin_;
    do
    {
      unint64_t v7 = &v4->__begin_[v5];
      NSUInteger location = v7->location;
      NSUInteger length = v7->length;
      NSUInteger v10 = length + v7->location;
      NSUInteger v11 = a2->location;
      if (v10 > a2->location)
      {
        NSUInteger v12 = a2->length;
        NSUInteger v13 = v12 + v11;
        if (v11 <= location)
        {
          BOOL v17 = v10 > v13;
          NSUInteger v15 = v10 - v13;
          if (!v17) {
            goto LABEL_33;
          }
          NSUInteger v16 = location - v12;
          BOOL v17 = v13 > location;
          if (v13 <= location) {
            NSUInteger v18 = v16;
          }
          else {
            NSUInteger v18 = a2->location;
          }
          if (v17) {
            NSUInteger length = v15;
          }
          if (v5)
          {
            uint64_t v19 = (uint64_t)&v4->__begin_[v5];
            NSUInteger v21 = *(void *)(v19 - 16);
            uint64_t v22 = *(void *)(v19 - 8);
            long long v20 = (void *)(v19 - 16);
            if (v18 <= v22 + v21)
            {
              NSUInteger v24 = v18 + length;
              if (v21 <= v24) {
                NSUInteger v25 = v24;
              }
              else {
                NSUInteger v25 = v21;
              }
              if (v21 < v24) {
                NSUInteger v24 = v21;
              }
              *long long v20 = v24;
              v20[1] = v25 - v24;
LABEL_33:
              int64_t v26 = (char *)end - (char *)&v7[1];
              if (end != &v7[1]) {
                this = (TSWPRangeVector *)memmove(v7, &v7[1], (char *)end - (char *)&v7[1]);
              }
              end = (_NSRange *)((char *)v7 + v26);
              v4->__end_ = (_NSRange *)((char *)v7 + v26);
              --v6;
              continue;
            }
          }
          v7->NSUInteger location = v18;
          v7->NSUInteger length = length;
        }
        else
        {
          if (v10 <= v13)
          {
            if (location <= v11) {
              NSUInteger v23 = a2->location;
            }
            else {
              NSUInteger v23 = v7->location;
            }
            if (location >= v11) {
              NSUInteger location = a2->location;
            }
            NSUInteger v14 = v23 - location;
            v7->NSUInteger location = location;
          }
          else
          {
            NSUInteger v14 = length - v12;
          }
          v7->NSUInteger length = v14;
        }
      }
      ++v5;
    }
    while (v5 < v6);
  }
  return this;
}

TSWPRangeVector *TSWPRangeVector::replacedTextAtRange(TSWPRangeVector *this, const _NSRange *a2, uint64_t a3)
{
  end = this->__end_;
  if (end != this->__begin_)
  {
    unint64_t v6 = this;
    unint64_t v7 = 0;
    unint64_t v8 = end - this->__begin_;
    do
    {
      uint64_t v9 = &v6->__begin_[v7];
      NSUInteger location = v9->location;
      NSUInteger length = v9->length;
      NSUInteger v12 = length + v9->location;
      NSUInteger v13 = a2->location;
      if (v12 >= a2->location)
      {
        NSUInteger v14 = a2->length;
        NSUInteger v15 = v14 + v13;
        if (v13 <= location)
        {
          if (v15 < v12)
          {
            NSUInteger v16 = v12 + a3 - v15;
            NSUInteger v17 = location + a3 - v14;
            if (v15 > location)
            {
              NSUInteger v18 = v16;
            }
            else
            {
              NSUInteger v13 = v17;
              NSUInteger v18 = v9->length;
            }
LABEL_17:
            v9->NSUInteger location = v13;
            v9->NSUInteger length = v18;
            goto LABEL_20;
          }
          if (!a3)
          {
            int64_t v20 = (char *)end - (char *)&v9[1];
            if (end != &v9[1]) {
              this = (TSWPRangeVector *)memmove(&v6->__begin_[v7], &v9[1], (char *)end - (char *)&v9[1]);
            }
            end = (_NSRange *)((char *)v9 + v20);
            v6->__end_ = (_NSRange *)((char *)v9 + v20);
            --v8;
            continue;
          }
          v9->NSUInteger location = v13;
          v9->NSUInteger length = a3;
        }
        else
        {
          if (v15 >= v12)
          {
            if (location <= v13) {
              NSUInteger v19 = a2->location;
            }
            else {
              NSUInteger v19 = v9->location;
            }
            if (location < v13) {
              NSUInteger v13 = v9->location;
            }
            NSUInteger v18 = v19 - v13;
            goto LABEL_17;
          }
          v9->NSUInteger length = length - v14 + a3;
        }
      }
LABEL_20:
      ++v7;
    }
    while (v7 < v8);
  }
  return this;
}

NSUInteger TSWPRangeVector::changedRange(TSWPRangeVector *this, _NSRange a2, uint64_t a3)
{
  NSUInteger v3 = *MEMORY[0x263F7C7C8];
  NSUInteger length = *(void *)(MEMORY[0x263F7C7C8] + 8);
  if (a3)
  {
    int64_t v6 = (char *)this->__end_ - (char *)this->__begin_;
    if (v6)
    {
      NSUInteger location = a2.location;
      NSUInteger v8 = a2.length - a3 + a2.location;
      NSUInteger v9 = (v6 >> 4) - 1;
      unint64_t v10 = v6 & 0xFFFFFFFFFFFFFFF0;
      uint64_t v11 = -(uint64_t)(v6 & 0xFFFFFFFFFFFFFFF0);
      do
      {
        begiuint64_t n = this->__begin_;
        NSUInteger v13 = (char *)this->__begin_ + v10;
        NSUInteger v15 = *((void *)v13 - 2);
        uint64_t v16 = *((void *)v13 - 1);
        NSUInteger v14 = v13 - 16;
        if (v16 + v15 <= location) {
          break;
        }
        if (v15 >= v8)
        {
          *(void *)NSUInteger v14 = v15 + a3;
        }
        else
        {
          NSUInteger v17 = (_NSRange *)((char *)begin + v10);
          end = this->__end_;
          int64_t v19 = (char *)end - (char *)begin;
          uint64_t v20 = v11 + v19;
          if (v17 != end) {
            memmove(v14, v17, v11 + v19);
          }
          this->__end_ = (_NSRange *)((char *)v17 + (v20 & 0xFFFFFFFFFFFFFFF0) - 16);
          if (v3 == 0x7FFFFFFFFFFFFFFFLL)
          {
            NSUInteger v3 = v9;
            NSUInteger length = 1;
          }
          else
          {
            v24.NSUInteger location = v3;
            v24.NSUInteger length = length;
            v25.NSUInteger location = v9;
            v25.NSUInteger length = 1;
            NSRange v21 = NSUnionRange(v24, v25);
            NSUInteger v3 = v21.location;
            NSUInteger length = v21.length;
          }
        }
        --v9;
        v10 -= 16;
        v11 += 16;
      }
      while (v9 != -1);
    }
  }
  return v3;
}

void TSWPRangeVector::unionWith(TSWPRangeVector *this, const TSWPRangeVector *a2)
{
  int64_t v2 = (char *)a2->__end_ - (char *)a2->__begin_;
  if (v2)
  {
    uint64_t v5 = 0;
    unint64_t v6 = v2 >> 4;
    if (v6 <= 1) {
      uint64_t v7 = 1;
    }
    else {
      uint64_t v7 = v6;
    }
    do
    {
      TSWPRangeVector::addRange(this, &a2->__begin_[v5++]);
      --v7;
    }
    while (v7);
  }
}

TSWPRangeVector *TSWPRangeVector::intersection@<X0>(TSWPRangeVector *this@<X0>, TSWPRangeVector *a2@<X8>)
{
  a2->__begin_ = 0;
  a2->__end_ = 0;
  a2->__end_cap_.__value_ = 0;
  begiuint64_t n = this->__begin_;
  end = this->__end_;
  if (this->__begin_ != end)
  {
    uint64_t v6 = v5;
    this = *(TSWPRangeVector **)v5;
    uint64_t v8 = *(void *)(v5 + 8);
    do
    {
      _NSRange v13 = NSIntersectionRange(*(NSRange *)&this, *begin);
      if (v13.length) {
        TSWPRangeVector::addRange(a2, &v13);
      }
      this = *(TSWPRangeVector **)v6;
      uint64_t v9 = *(void *)(v6 + 8);
      NSUInteger location = begin->location;
      NSUInteger length = begin->length;
      ++begin;
    }
    while (v9 + *(void *)v6 >= length + location && begin != end);
  }
  return this;
}

void sub_223760228(_Unwind_Exception *exception_object)
{
  NSUInteger v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

TSWPRangeVector *TSWPRangeVector::rangesIntersecting@<X0>(TSWPRangeVector *this@<X0>, TSWPRangeVector *a2@<X8>)
{
  a2->__begin_ = 0;
  a2->__end_ = 0;
  a2->__end_cap_.__value_ = 0;
  begiuint64_t n = this->__begin_;
  end = this->__end_;
  if (this->__begin_ != end)
  {
    uint64_t v6 = v5;
    this = *(TSWPRangeVector **)v5;
    uint64_t v8 = *(void *)(v5 + 8);
    do
    {
      if (NSIntersectionRange(*(NSRange *)&this, *begin).length) {
        TSWPRangeVector::addRange(a2, begin);
      }
      this = *(TSWPRangeVector **)v6;
      uint64_t v9 = *(void *)(v6 + 8);
      NSUInteger location = begin->location;
      NSUInteger length = begin->length;
      ++begin;
    }
    while (v9 + *(void *)v6 >= length + location && begin != end);
  }
  return this;
}

void sub_2237602BC(_Unwind_Exception *exception_object)
{
  NSUInteger v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void TSWPRangeVector::intersectWith(TSWPRangeVector *this, const _NSRange *a2)
{
  if (this->__begin_ != this->__end_)
  {
    TSWPRangeVector::intersection(this, &v3);
    std::vector<CGPoint>::vector(&__p, (uint64_t)this);
    if (&v3 != this) {
      std::vector<EQKitLength>::__assign_with_size[abi:nn180100]<EQKitLength*,EQKitLength*>((char *)this, (char *)v3.__begin_, (uint64_t)v3.__end_, v3.__end_ - v3.__begin_);
    }
    std::vector<EQKitLength>::__assign_with_size[abi:nn180100]<EQKitLength*,EQKitLength*>((char *)&v3, (char *)__p, (uint64_t)v5, (v5 - (unsigned char *)__p) >> 4);
    if (__p)
    {
      uint64_t v5 = __p;
      operator delete(__p);
    }
    if (v3.__begin_)
    {
      v3.__end_ = v3.__begin_;
      operator delete(v3.__begin_);
    }
  }
}

void sub_223760374(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void TSWPRangeVector::intersectWith(TSWPRangeVector *this, const TSWPRangeVector *a2)
{
  memset(&v19, 0, sizeof(v19));
  begiuint64_t n = this->__begin_;
  int64_t v4 = (char *)this->__end_ - (char *)this->__begin_;
  if (v4)
  {
    int64_t v5 = (char *)a2->__end_ - (char *)a2->__begin_;
    if (v5)
    {
      uint64_t v6 = 0;
      unint64_t v7 = 0;
      unint64_t v17 = v5 >> 4;
      NSUInteger v18 = a2;
      NSUInteger location = begin->location;
      NSUInteger length = begin->length;
      uint64_t v10 = (v4 >> 4) - 1;
      do
      {
        uint64_t v11 = &a2->__begin_[v7];
        NSUInteger v12 = v11->location;
        NSUInteger v13 = v11->length;
        NSUInteger v14 = v13 + v11->location;
        for (uint64_t i = v6; ; ++i)
        {
          v21.NSUInteger location = v12;
          v21.NSUInteger length = v13;
          v22.NSUInteger location = location;
          v22.NSUInteger length = length;
          _NSRange __p = NSIntersectionRange(v21, v22);
          if (__p.length) {
            TSWPRangeVector::addRange(&v19, &__p);
          }
          if (v14 < length + location) {
            break;
          }
          if (v10 == v6) {
            goto LABEL_11;
          }
          uint64_t v16 = &this->__begin_[i];
          NSUInteger location = v16[1].location;
          NSUInteger length = v16[1].length;
          ++v6;
        }
        ++v7;
        a2 = v18;
      }
      while (v7 < v17);
    }
  }
LABEL_11:
  std::vector<CGPoint>::vector(&__p, (uint64_t)this);
  if (&v19 != this) {
    std::vector<EQKitLength>::__assign_with_size[abi:nn180100]<EQKitLength*,EQKitLength*>((char *)this, (char *)v19.__begin_, (uint64_t)v19.__end_, v19.__end_ - v19.__begin_);
  }
  std::vector<EQKitLength>::__assign_with_size[abi:nn180100]<EQKitLength*,EQKitLength*>((char *)&v19, (char *)__p.location, __p.length, (uint64_t)(__p.length - __p.location) >> 4);
  if (__p.location)
  {
    __p.NSUInteger length = __p.location;
    operator delete((void *)__p.location);
  }
  if (v19.__begin_)
  {
    v19.__end_ = v19.__begin_;
    operator delete(v19.__begin_);
  }
}

void sub_223760504(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, void *a14, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void TSWPRangeVector::diff(TSWPRangeVector *this, const TSWPRangeVector *a2)
{
  std::vector<CGPoint>::vector(&__p, (uint64_t)this);
  TSWPRangeVector::intersectWith(&__p, a2);
  TSWPRangeVector::unionWith(this, a2);
  end = __p.__end_;
  if (__p.__end_ != __p.__begin_)
  {
    uint64_t v5 = 0;
    if ((unint64_t)(__p.__end_ - __p.__begin_) <= 1) {
      int64_t v6 = 1;
    }
    else {
      int64_t v6 = __p.__end_ - __p.__begin_;
    }
    do
    {
      TSWPRangeVector::removeRange(this, &__p.__begin_[v5++]);
      --v6;
    }
    while (v6);
    end = __p.__begin_;
  }
  if (end)
  {
    __p.__end_ = end;
    operator delete(end);
  }
}

void sub_2237605DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TSWPRangeVector::subtract(TSWPRangeVector *this, const TSWPRangeVector *a2)
{
  if (this->__end_ == this->__begin_) {
    return 0;
  }
  int64_t v3 = (char *)a2->__end_ - (char *)a2->__begin_;
  if (!v3) {
    return 0;
  }
  uint64_t v5 = 0;
  char v6 = 0;
  unint64_t v7 = v3 >> 4;
  if (v7 <= 1) {
    uint64_t v8 = 1;
  }
  else {
    uint64_t v8 = v7;
  }
  do
  {
    if (TSWPRangeVector::removeRange(this, &a2->__begin_[v5])) {
      char v6 = 1;
    }
    ++v5;
    --v8;
  }
  while (v8);
  return v6 & 1;
}

void *TSWPRangeVector::description(TSWPRangeVector *this)
{
  int64_t v2 = objc_msgSend(MEMORY[0x263F089D8], "stringWithFormat:", @"<TSWPRangeVector %p> RangeCount: %ld {", this, this->__end_ - this->__begin_);
  begiuint64_t n = this->__begin_;
  end = this->__end_;
  while (begin != end)
  {
    NSRange v6 = *begin++;
    [v2 appendString:NSStringFromRange(v6)];
  }
  [v2 appendString:@"}"];
  return v2;
}

uint64_t TSWPRangeVector::shortDescription(TSWPRangeVector *this)
{
  begiuint64_t n = this->__begin_;
  end = this->__end_;
  if (this->__begin_ == end)
  {
    NSUInteger location = 0;
    NSUInteger v5 = 0;
  }
  else
  {
    NSUInteger location = begin->location;
    NSUInteger v5 = end[-1].length + end[-1].location;
  }
  uint64_t v6 = end - begin;
  if (location <= v5) {
    NSUInteger v7 = v5;
  }
  else {
    NSUInteger v7 = location;
  }
  if (location >= v5) {
    v8.NSUInteger location = v5;
  }
  else {
    v8.NSUInteger location = location;
  }
  v8.NSUInteger length = v7 - v8.location;
  return [NSString stringWithFormat:@"<TSWPRangeVector %p> count: %ld super: %@", this, v6, NSStringFromRange(v8)];
}

void TSWPChangeAttributeArray::TSWPChangeAttributeArray(uint64_t a1, int a2)
{
  TSWPAttributeArray::TSWPAttributeArray(a1, a2);
  *(unsigned char *)(v2 + 56) = 0;
  *(void *)(v2 + 64) = 0;
  *(void *)uint64_t v2 = &unk_26D687E80;
  *(_DWORD *)(v2 + 72) = 0;
}

{
  uint64_t v2;

  TSWPAttributeArray::TSWPAttributeArray(a1, a2);
  *(unsigned char *)(v2 + 56) = 0;
  *(void *)(v2 + 64) = 0;
  *(void *)uint64_t v2 = &unk_26D687E80;
  *(_DWORD *)(v2 + 72) = 0;
}

uint64_t TSWPChangeAttributeArray::setInsertionBehavior(uint64_t result, int a2)
{
  *(_DWORD *)(result + 72) = a2;
  return result;
}

const char *TSWPChangeAttributeArray::className(TSWPChangeAttributeArray *this)
{
  return "TSWPChangeAttributeArray";
}

void TSWPChangeAttributeArray::willReplaceCharactersInRangeWithString(TSWPAttributeArray *this, _NSRange a2, uint64_t a3, uint64_t a4, uint64_t a5, TSWPStorageTransaction *a6)
{
  NSUInteger length = a2.length;
  NSUInteger location = a2.location;
  if (a2.length && a2.location != 0x7FFFFFFFFFFFFFFFLL && a4)
  {
    LOBYTE(this[1].var0) = 0;
    unint64_t v10 = TSWPAttributeArray::effectiveAttributeIndexForCharIndex(this, a2.location);
    v14.NSUInteger location = location;
    v14.NSUInteger length = length;
    TSWPChangeAttributeArray::clipObjectForReplacement((TSWPChangeAttributeArray *)this, v10, v14, a6);
    unint64_t v11 = TSWPAttributeArray::effectiveAttributeIndexForCharIndex(this, length + location - 1);
    v15.NSUInteger location = location;
    v15.NSUInteger length = length;
    TSWPChangeAttributeArray::clipObjectForReplacement((TSWPChangeAttributeArray *)this, v11, v15, a6);
    v12.NSUInteger location = location;
    v12.NSUInteger length = length;
    TSWPChangeAttributeArray::deleteInnerObjectsForReplacement((TSWPChangeAttributeArray *)this, v12, a6);
  }
  else
  {
    TSWPSmartFieldAttributeArray::willReplaceCharactersInRangeWithString(this, a2, a3, a4, a5, a6);
  }
}

TSWPChangeAttributeArray *TSWPChangeAttributeArray::clipObjectForReplacement(TSWPChangeAttributeArray *this, unint64_t a2, _NSRange a3, TSWPStorageTransaction *a4)
{
  if (*((void *)this->var4 + 2 * a2 + 1))
  {
    NSUInteger length = a3.length;
    NSUInteger location = a3.location;
    unint64_t v7 = a2;
    NSRange v8 = (TSWPAttributeArray *)this;
    this = (TSWPChangeAttributeArray *)TSWPAttributeArray::rangeForAttributeIndex((TSWPAttributeArray *)this, a2);
    uint64_t v10 = v9;
    unint64_t v11 = location + length;
    _NSRange v12 = (char *)this + v10;
    if (location > (unint64_t)this)
    {
      if (v11 < (unint64_t)v12) {
        return this;
      }
      ++v7;
      v15[0] = location;
      goto LABEL_7;
    }
    if (v11 < (unint64_t)v12)
    {
      NSUInteger v13 = this;
      TSWPAttributeArray::replaceCharIndexForAttributeIndex(v8, v11, v7, a4);
      v15[0] = v13;
LABEL_7:
      v15[1] = 0;
      TSWPAttributeArray::insertAttribute(v8, (const TSWPAttributeRecord *)v15, v7, 0, a4);
      return (TSWPChangeAttributeArray *)(*((uint64_t (**)(TSWPAttributeArray *, unint64_t, TSWPStorageTransaction *))v8->var0
                                          + 29))(v8, v7, a4);
    }
    TSWPAttributeArray::replaceObjectForAttributeIndex(v8, 0, v7, 0, a4);
    _NSRange v14 = (uint64_t (*)(TSWPAttributeArray *, unint64_t, TSWPStorageTransaction *))*((void *)v8->var0 + 29);
    return (TSWPChangeAttributeArray *)v14(v8, v7, a4);
  }
  return this;
}

unint64_t TSWPChangeAttributeArray::deleteInnerObjectsForReplacement(TSWPChangeAttributeArray *this, _NSRange a2, TSWPStorageTransaction *a3)
{
  NSUInteger length = a2.length;
  NSUInteger location = a2.location;
  unint64_t v7 = TSWPAttributeArray::effectiveAttributeIndexForCharIndex((TSWPAttributeArray *)this, a2.location);
  unint64_t result = TSWPAttributeArray::effectiveAttributeIndexForCharIndex((TSWPAttributeArray *)this, length + location - 1);
  if (result > v7 + 1)
  {
    (*((void (**)(TSWPChangeAttributeArray *, unint64_t, unint64_t, TSWPStorageTransaction *))this->var0
     + 7))(this, v7 + 1, result - (v7 + 1), a3);
    uint64_t v9 = (uint64_t (*)(TSWPChangeAttributeArray *, unint64_t, TSWPStorageTransaction *))*((void *)this->var0 + 29);
    return v9(this, v7, a3);
  }
  return result;
}

uint64_t TSWPChangeAttributeArray::styleInsertionBehaviorForReplacingSelection(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

void TSWPChangeAttributeArray::~TSWPChangeAttributeArray(TSWPChangeAttributeArray *this)
{
  TSWPStyleAttributeArray::~TSWPStyleAttributeArray((TSWPAttributeArray *)this);

  JUMPOUT(0x223CB8F20);
}

void sub_223761A04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

TSSStyle *TSWPAddNonNilStyleToArray(TSSStyle *result, TSSStyle **a2, unsigned int *a3)
{
  if (result)
  {
    uint64_t v3 = *a3;
    *a3 = v3 + 1;
    a2[v3] = result;
  }
  return result;
}

void TSWPCoreTextTypesetter::pChangeTextToUppercaseForRange(TSWPCoreTextTypesetter *this, _NSRange a2)
{
  int64_t length = a2.length;
  NSUInteger location = a2.location;
  if (a2.location + a2.length > *((void *)this + 7))
  {
    NSUInteger v5 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v6 = [NSString stringWithUTF8String:"void TSWPCoreTextTypesetter::pChangeTextToUppercaseForRange(NSRange)"];
    objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 3761, @"Invalid local range");
  }
  Systeuint64_t m = CFLocaleGetSystem();
  if (length >= 1)
  {
    CFLocaleRef v8 = System;
    uint64_t v9 = (UniChar *)(*((void *)this + 10) + 2 * location);
    CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x263EFFB28];
    uint64_t v11 = length + 1;
    do
    {
      UniChar v12 = *v9;
      MutableWithExternalCharactersNoCopCGFloat y = CFStringCreateMutableWithExternalCharactersNoCopy(0, v9, 1, 1, v10);
      if (MutableWithExternalCharactersNoCopy)
      {
        CFStringRef v14 = MutableWithExternalCharactersNoCopy;
        CFStringUppercase(MutableWithExternalCharactersNoCopy, v8);
        if (CFStringGetLength(v14) != 1) {
          *uint64_t v9 = v12;
        }
        CFRelease(v14);
      }
      else
      {
        _NSRange v15 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v16 = [NSString stringWithUTF8String:"void TSWPCoreTextTypesetter::pChangeTextToUppercaseForRange(NSRange)"];
        objc_msgSend(v15, "handleFailureInFunction:file:lineNumber:description:", v16, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 3774, @"Failed to create temporary string for _textBuffer");
      }
      ++v9;
      --v11;
    }
    while (v11 > 1);
  }
}

uint64_t TSWPCoreTextTypesetter::pChangeToSmallCapsForRange(TSWPCoreTextTypesetter *this, _NSRange a2, int a3, int a4)
{
  NSUInteger length = a2.length;
  NSUInteger location = a2.location;
  v70[2] = *MEMORY[0x263EF8340];
  if (a3)
  {
    if (a2.length) {
      goto LABEL_3;
    }
  }
  else
  {
    _NSRange v46 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v47 = objc_msgSend(NSString, "stringWithUTF8String:", "uint TSWPCoreTextTypesetter::pChangeToSmallCapsForRange(NSRange, uint, BOOL)");
    objc_msgSend(v46, "handleFailureInFunction:file:lineNumber:description:", v47, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 3814, @"runIndex should >= 1");
    if (length) {
      goto LABEL_3;
    }
  }
  NSRange v48 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
  uint64_t v49 = objc_msgSend(NSString, "stringWithUTF8String:", "uint TSWPCoreTextTypesetter::pChangeToSmallCapsForRange(NSRange, uint, BOOL)");
  objc_msgSend(v48, "handleFailureInFunction:file:lineNumber:description:", v49, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 3815, @"localRange.length must be >= 1");
LABEL_3:
  uint64_t v8 = (a3 - 1);
  uint64_t v9 = *((void *)this + 15) + 104 * v8;
  uint64_t v58 = *(void *)(v9 + 16);
  font = *(const __CTFont **)(v9 + 24);
  CFDictionaryRef theDict = *(const __CFDictionary **)(v9 + 32);
  long long v10 = *(_OWORD *)(v9 + 56);
  long long v62 = *(_OWORD *)(v9 + 40);
  long long v63 = v10;
  long long v11 = *(_OWORD *)(v9 + 88);
  long long v64 = *(_OWORD *)(v9 + 72);
  long long v65 = v11;
  NSUInteger v12 = location + length;
  CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetLowercaseLetter);
  if (location < location + length)
  {
    CFCharacterSetRef v14 = Predefined;
    CTFontRef v15 = 0;
    uint64_t v53 = *MEMORY[0x263F03AA0];
    uint64_t v52 = *MEMORY[0x263F03A90];
    uint64_t v51 = *MEMORY[0x263F03AF0];
    uint64_t v50 = *MEMORY[0x263F03A98];
    CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    keCGFloat y = (void *)*MEMORY[0x263F039A0];
    do
    {
      CTFontRef v60 = v15;
      int IsCharacterMember = CFCharacterSetIsCharacterMember(v14, *(_WORD *)(*((void *)this + 10) + 2 * location));
      uint64_t v17 = 1;
      do
      {
        NSUInteger v18 = v17;
        NSUInteger v19 = location + v17;
        if (location + v17 >= v12) {
          break;
        }
        int v20 = CFCharacterSetIsCharacterMember(v14, *(_WORD *)(*((void *)this + 10) + 2 * location + 2 * v17));
        uint64_t v17 = v18 + 1;
      }
      while (IsCharacterMember == v20);
      if (v8 >= *((_DWORD *)this + 28))
      {
        NSRange v21 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v22 = objc_msgSend(NSString, "stringWithUTF8String:", "uint TSWPCoreTextTypesetter::pChangeToSmallCapsForRange(NSRange, uint, BOOL)");
        objc_msgSend(v21, "handleFailureInFunction:file:lineNumber:description:", v22, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 3835, @"Bad runIndex");
      }
      *(void *)(*((void *)this + 16) + 8 * v8) = v18;
      uint64_t v23 = *((void *)this + 15) + 104 * v8;
      *(void *)uint64_t v23 = location;
      *(void *)(v23 + 16) = v58;
      *(_DWORD *)(v23 + 8) = 2 * (IsCharacterMember != 0);
      if (IsCharacterMember)
      {
        if (a4 && TSWPCTFontSupportsNativeSmallCaps(font))
        {
          NSRange v24 = CTFontCopyFontDescriptor(font);
          double Size = CTFontGetSize(font);
          if (v24)
          {
            CGFloat v26 = Size;
            v68[0] = v53;
            v68[1] = v52;
            v69[0] = &unk_26D73A158;
            v69[1] = &unk_26D73A170;
            v70[0] = [NSDictionary dictionaryWithObjects:v69 forKeys:v68 count:2];
            uint64_t v66 = v51;
            double v67 = @"smcp";
            v70[1] = [NSDictionary dictionaryWithObjects:&v67 forKeys:&v66 count:1];
            uint64_t v27 = [MEMORY[0x263EFF8C0] arrayWithObjects:v70 count:2];
            CFDictionaryRef v28 = (const __CFDictionary *)objc_msgSend(objc_alloc(NSDictionary), "initWithObjectsAndKeys:", v27, v50, 0);
            CopyWithCFDictionaryRef Attributes = CTFontDescriptorCreateCopyWithAttributes(v24, v28);
            if (CopyWithAttributes)
            {
              NSUInteger v30 = CopyWithAttributes;
              CTFontRef v60 = CTFontCreateWithFontDescriptor(CopyWithAttributes, v26, 0);
              CFRelease(v30);
            }
            CFRelease(v24);
          }
          CTFontRef v15 = v60;
        }
        else
        {
          v71.NSUInteger location = location;
          v71.NSUInteger length = v18;
          TSWPCoreTextTypesetter::pChangeTextToUppercaseForRange(this, v71);
          double v31 = CTFontGetSize(font);
          NSUInteger v32 = CTFontCopyFontDescriptor(font);
          CTFontRef v15 = v60;
          if (v32)
          {
            NSUInteger v33 = v32;
            CTFontRef v15 = CTFontCreateWithFontDescriptor(v32, v31 * 0.800000012, 0);
            CFRelease(v33);
          }
        }
        if (v15)
        {
          MutableCopCGFloat y = CFDictionaryCreateMutableCopy(allocator, 0, theDict);
          CFDictionarySetValue(MutableCopy, key, v15);
          *(void *)(*((void *)this + 15) + 104 * v8 + 32) = MutableCopy;
          *(void *)(*((void *)this + 15) + 104 * v8 + 24) = CFRetain(v15);
          TSWPFontHeightInfoForFont(v15, v61);
          uint64_t v35 = *((void *)this + 15) + 104 * v8;
          long long v36 = v61[0];
          long long v37 = v61[1];
          long long v38 = v61[2];
          *(_OWORD *)(v35 + 88) = v61[3];
          *(_OWORD *)(v35 + 72) = v38;
          *(_OWORD *)(v35 + 56) = v37;
          *(_OWORD *)(v35 + 40) = v36;
        }
      }
      else
      {
        *(void *)(*((void *)this + 15) + 104 * v8 + 32) = CFRetain(theDict);
        CFTypeRef v39 = CFRetain(font);
        uint64_t v40 = *((void *)this + 15) + 104 * v8;
        *(void *)(v40 + 24) = v39;
        long long v41 = v64;
        *(_OWORD *)(v40 + 88) = v65;
        *(_OWORD *)(v40 + 72) = v41;
        long long v42 = v62;
        *(_OWORD *)(v40 + 56) = v63;
        *(_OWORD *)(v40 + 40) = v42;
        CTFontRef v15 = v60;
      }
      uint64_t v8 = (v8 + 1);
      unsigned int v43 = *((_DWORD *)this + 28);
      if (v8 >= v43)
      {
        unsigned int v44 = 2 * v43;
        *((_DWORD *)this + 28) = v44;
        *((void *)this + 15) = malloc_type_realloc(*((void **)this + 15), 104 * v44, 0x10E0040261DCC7AuLL);
        *((void *)this + 16) = malloc_type_realloc(*((void **)this + 16), 8 * *((unsigned int *)this + 28), 0x100004000313F17uLL);
      }
      NSUInteger location = v19;
    }
    while (v19 < v12);
    if (v15) {
      CFRelease(v15);
    }
  }
  CFRelease(font);
  CFRelease(theDict);
  return v8;
}

void TSWPCoreTextTypesetter::pChangeTextToTitledForRange(TSWPCoreTextTypesetter *this, _NSRange a2)
{
  NSUInteger length = a2.length;
  NSUInteger location = a2.location;
  if (a2.location + a2.length > *((void *)this + 7))
  {
    NSUInteger v5 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v6 = [NSString stringWithUTF8String:"void TSWPCoreTextTypesetter::pChangeTextToTitledForRange(NSRange)"];
    objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 3796, @"Invalid local range");
  }
  Systeuint64_t m = CFLocaleGetSystem();
  MutableWithExternalCharactersNoCopCGFloat y = CFStringCreateMutableWithExternalCharactersNoCopy(0, (UniChar *)(*((void *)this + 10) + 2 * location), length, length, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
  if (MutableWithExternalCharactersNoCopy)
  {
    uint64_t v9 = MutableWithExternalCharactersNoCopy;
    CFStringCapitalize(MutableWithExternalCharactersNoCopy, System);
    CFRelease(v9);
  }
  else
  {
    long long v10 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v11 = [NSString stringWithUTF8String:"void TSWPCoreTextTypesetter::pChangeTextToTitledForRange(NSRange)"];
    uint64_t v12 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"];
    [v10 handleFailureInFunction:v11 file:v12 lineNumber:3802 description:@"Failed to create temporary string for _textBuffer"];
  }
}

__CFString *TSWPCoreTextTypesetter::pNumberedListLabel(TSWPCoreTextTypesetter *this, const TSWPLayoutState *a2, TSWPParagraphEnumerator *a3, unint64_t a4, BOOL a5)
{
  if (a4 >= 9)
  {
    NSUInteger v13 = objc_msgSend(MEMORY[0x263F7C7F0], "currentHandler", a3);
    uint64_t v14 = objc_msgSend(NSString, "stringWithUTF8String:", "NSString *TSWPCoreTextTypesetter::pNumberedListLabel(const TSWPLayoutState *, TSWPParagraphEnumerator, TSWPParagraphLevel, BOOL)");
    objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 1797, @"illegal list level");
    return &stru_26D688A48;
  }
  long long v10 = (TSWPListStyle *)TSWPParagraphEnumerator::paragraphListStyle(a3);
  id v11 = [(TSSStyle *)v10 valueForProperty:184];
  if (v11) {
    uint64_t v12 = objc_msgSend((id)objc_msgSend(v11, "objectAtIndexedSubscript:", a4), "intValue");
  }
  else {
    uint64_t v12 = +[TSWPListStyle defaultLabelNumberType];
  }
  uint64_t v16 = v12;
  uint64_t v17 = TSWPParagraphEnumerator::paragraphListNumber(a3, v33);
  if (v17 == 0x7FFFFFFFFFFFFFFFLL)
  {
    unint64_t TopicNumberForList = TSWPParagraphEnumerator::paragraphListStart(a3);
    if (!TopicNumberForList)
    {
      unint64_t TopicNumberForList = TSWPTopicNumberHints::nextTopicNumberForList(*((TSWPTopicNumberHints **)this + 35), v10, a4);
      BOOL v19 = TSWPParagraphEnumerator::operator!=(a3, (void *)a2 + 3);
      uint64_t v20 = TopicNumberForList - 1;
      if (TopicNumberForList - 1 <= 1) {
        uint64_t v20 = 1;
      }
      if (v19) {
        unint64_t TopicNumberForList = v20;
      }
    }
    goto LABEL_15;
  }
  unint64_t TopicNumberForList = v17;
  if (!v33[0]) {
    return &stru_26D688A48;
  }
LABEL_15:
  id v21 = [(TSSStyle *)v10 valueForProperty:185];
  if (v21) {
    char v22 = objc_msgSend((id)objc_msgSend(v21, "objectAtIndexedSubscript:", a4), "BOOLValue");
  }
  else {
    char v22 = +[TSWPListStyle defaultTieredNumber];
  }
  char v23 = v22;
  if (HIDWORD(TopicNumberForList))
  {
    NSUInteger v29 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v30 = objc_msgSend(NSString, "stringWithUTF8String:", "NSString *TSWPCoreTextTypesetter::pNumberedListLabel(const TSWPLayoutState *, TSWPParagraphEnumerator, TSWPParagraphLevel, BOOL)");
    objc_msgSend(v29, "handleFailureInFunction:file:lineNumber:description:", v30, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 1843, @"Out-of-bounds type assignment was clamped to max");
    unint64_t TopicNumberForList = 0xFFFFFFFFLL;
  }
  if ([(TSWPListStyle *)v10 labelTypeForLevel:a4] == 3) {
    CTFontRef v15 = (__CFString *)[NSString stringForValue:TopicNumberForList withListNumberFormat:v16 includeFormatting:a5];
  }
  else {
    CTFontRef v15 = &stru_26D688A48;
  }
  char v24 = v23 ^ 1;
  if (!a4) {
    char v24 = 1;
  }
  if ((v24 & 1) == 0)
  {
    uint64_t v25 = TSWPTopicNumberHints::previousCharIndexForList(*((TSWPTopicNumberHints **)this + 35), v10, a4 - 1);
    if (v25 != 0x7FFFFFFFFFFFFFFFLL)
    {
      uint64_t v26 = [*((id *)this + 2) paragraphIndexAtCharIndex:v25];
      TSWPParagraphEnumerator::TSWPParagraphEnumerator((uint64_t)&v32, *((void *)this + 2), [*((id *)a2 + 13) styleProvider], v26, v26 + 1, 1);
      if (TSWPParagraphEnumerator::paragraphLevel(&v32) < a4
        && [(id)TSWPParagraphEnumerator::paragraphListStyle(&v32) labelTypeForLevel:a4 - 1] == 3)
      {
        TSWPParagraphEnumerator::TSWPParagraphEnumerator(&v31, &v32);
        uint64_t v27 = (void *)TSWPCoreTextTypesetter::pNumberedListLabel(this, a2, &v31, a4 - 1, a5);
        TSWPParagraphEnumerator::~TSWPParagraphEnumerator(&v31);
        CTFontRef v15 = (__CFString *)[v27 stringByAppendingString:v15];
      }
      TSWPParagraphEnumerator::~TSWPParagraphEnumerator(&v32);
    }
  }
  return v15;
}

void sub_223762780(_Unwind_Exception *a1, TSWPParagraphEnumerator *a2, TSWPParagraphEnumerator *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
}

uint64_t TSWPCoreTextTypesetter::pLabelFont(TSWPCoreTextTypesetter *this, NSString *a2, CFTypeRef cf2, CGFloat a4)
{
  CGFloat v4 = a4;
  if (!*((void *)this + 31)
    || *((double *)this + 34) != a4
    || (id v11 = (NSString *)*((void *)this + 32), v11 != a2) && ![(NSString *)v11 isEqual:a2]
    || (uint64_t v12 = (const void *)*((void *)this + 33)) == 0
    || !CFEqual(v12, cf2))
  {
    TSWPCoreTextTypesetter::pDestroyCachedLabelFont((id *)this);
    *((void *)this + 32) = a2;
    *((void *)this + 33) = cf2;
    CFRetain(cf2);
    *((CGFloat *)this + 34) = v4;
    CFStringRef v8 = (const __CFString *)*((void *)this + 32);
    if (v8)
    {
      uint64_t v9 = CTFontDescriptorCreateWithNameAndSize(v8, 0.0);
      CGFloat v4 = *((double *)this + 34);
    }
    else
    {
      uint64_t v9 = 0;
    }
    *((void *)this + 31) = CTFontCreateCopyWithAttributes(*((CTFontRef *)this + 33), v4, 0, v9);
    if (v9) {
      CFRelease(v9);
    }
  }
  return *((void *)this + 31);
}

CFStringRef TSWPListLabel::setListLabelString(TSWPListLabel *this, CFStringRef theString)
{
  CGFloat v4 = (const void *)*((void *)this + 12);
  if (v4) {
    CFRelease(v4);
  }
  CFStringRef result = CFStringCreateCopy(0, theString);
  *((void *)this + 12) = result;
  return result;
}

void TSWPCoreTextTypesetter::createLineRefForEmptyLineFragment(id *this, id *a2, TSWPLineFragment *a3, int a4, double a5, double a6)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  NSUInteger v13 = (CFTypeRef *)*((void *)a3 + 24);
  uint64_t v12 = (CFTypeRef *)*((void *)a3 + 25);
  id v11 = (char *)a3 + 192;
  while (v12 != v13)
  {
    v12 -= 6;
    std::allocator<TSWPLineRef>::destroy[abi:ne180100]((uint64_t)a3 + 208, v12);
  }
  *((void *)a3 + 25) = v13;
  double v14 = TSWPCoreTextTypesetter::pLineRefStartForLineFragment((TSWPCoreTextTypesetter *)this, a2, a3, a5);
  CTFontRef v15 = (_OWORD *)MEMORY[0x263F7C7C8];
  if (a4)
  {
    uint64_t v16 = (void *)[objc_alloc(MEMORY[0x263EFF9A0]) initWithCapacity:2];
    CTFontRef UIFontForLanguage = CTFontCreateUIFontForLanguage(kCTFontUIFontSystem, 25.1950798, 0);
    [v16 setObject:UIFontForLanguage forKeyedSubscript:*MEMORY[0x263F039A0]];
    CFRelease(UIFontForLanguage);
    uint64_t v18 = objc_msgSend((id)objc_msgSend(a2[13], "storage"), "createFontAtCharIndex:scaleTextPercent:effectiveRange:styleProvider:", *(void *)a3, objc_msgSend(a2[13], "scaleTextPercent"), 0, objc_msgSend(a2[13], "styleProvider"));
    if (v18)
    {
      BOOL v19 = (const void *)v18;
      [v16 setObject:v18 forKeyedSubscript:@"TSWPUnadjustedFont"];
      CFRelease(v19);
    }
    CFAttributedStringRef v20 = CFAttributedStringCreate(0, @"\n", (CFDictionaryRef)v16);
    CTLineRef v21 = CTLineCreateWithAttributedString(v20);
    if (v20) {
      CFRelease(v20);
    }

    cf[0] = v21;
    cf[1] = *(CFTypeRef *)&v14;
    *(void *)&v30[0] = 0;
    *(_OWORD *)((char *)v30 + 8) = *MEMORY[0x263F7C7C8];
    DWORD2(v30[1]) = 0;
    if (v21) {
      CFRetain(v21);
    }
    if (*((void *)a3 + 25) != *((void *)a3 + 24))
    {
      char v22 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v23 = [NSString stringWithUTF8String:"void TSWPLineFragment::setLineRef(const TSWPLineRef &)"];
      objc_msgSend(v22, "handleFailureInFunction:file:lineNumber:description:", v23, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.h"), 518, @"Line ref is already set");
    }
    std::vector<TSWPLineRef>::assign((uint64_t)v11, 1uLL, (uint64_t)cf);
    if (cf[0]) {
      CFRelease(cf[0]);
    }
    *(_DWORD *)&v34[7] = 0x10000;
    uint64_t v33 = 0;
    *(void *)NSUInteger v34 = 0;
    uint64_t v32 = 0;
    long long v31 = 0u;
    memset(v30, 0, sizeof(v30));
    *(_OWORD *)CGFloat cf = 0u;
    objc_msgSend(this[8], "attributesAtCharIndex:attributesOfInterest:attributesTable:effectiveRange:", objc_msgSend(this[8], "charIndexMappedFromStorage:", *(void *)a3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0,
        0,
        0,
        0),
      &v33,
      cf,
      0);
    char v24 = (TSWPCoreTextTypesetter *)[*((id *)&v31 + 1) author];
    if (v24) {
      TSWPCoreTextTypesetter::pAddHighlightAdornmentToLineFragment(v24, a3, 7.0, a5, (TSKAnnotationAuthor *)v24);
    }
    if (v21) {
      CFRelease(v21);
    }
    if (*((void *)a3 + 1))
    {
      *((_DWORD *)a3 + 6) |= 0x800u;
      TSWPCoreTextTypesetter::pAddInvisibleBreakToLineFragment(this, (const TSWPLayoutState *)a2, a3, a4, 0.0, 0);
    }
  }
  else
  {
    uint64_t v25 = (const void *)TSWPCoreTextTypesetter::createLineRefForEmptyLineFragment(TSWPLayoutState const*,TSWPLineFragment *,unsigned short,double,double)const::emptyLine;
    if (!TSWPCoreTextTypesetter::createLineRefForEmptyLineFragment(TSWPLayoutState const*,TSWPLineFragment *,unsigned short,double,double)const::emptyLine)
    {
      CFAttributedStringRef v26 = CFAttributedStringCreate(0, &stru_26D688A48, 0);
      TSWPCoreTextTypesetter::createLineRefForEmptyLineFragment(TSWPLayoutState const*,TSWPLineFragment *,unsigned short,double,double)const::emptydouble Line = (uint64_t)CTLineCreateWithAttributedString(v26);
      CFRelease(v26);
      uint64_t v25 = (const void *)TSWPCoreTextTypesetter::createLineRefForEmptyLineFragment(TSWPLayoutState const*,TSWPLineFragment *,unsigned short,double,double)const::emptyLine;
    }
    cf[0] = v25;
    cf[1] = *(CFTypeRef *)&v14;
    *(void *)&v30[0] = 0;
    *(_OWORD *)((char *)v30 + 8) = *v15;
    DWORD2(v30[1]) = 0;
    if (v25) {
      CFRetain(v25);
    }
    if (*((void *)a3 + 25) != *((void *)a3 + 24))
    {
      uint64_t v27 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v28 = [NSString stringWithUTF8String:"void TSWPLineFragment::setLineRef(const TSWPLineRef &)"];
      objc_msgSend(v27, "handleFailureInFunction:file:lineNumber:description:", v28, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.h"), 518, @"Line ref is already set");
    }
    std::vector<TSWPLineRef>::assign((uint64_t)v11, 1uLL, (uint64_t)cf);
    if (cf[0]) {
      CFRelease(cf[0]);
    }
    *((double *)a3 + 27) = a5;
  }
  *((_DWORD *)a3 + 6) |= 0x4000u;
  TSWPCoreTextTypesetter::pApplyChangeTrackingToLineFragment(this, a3);
}

void sub_223762CDC(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

unint64_t TSWPCoreTextTypesetter::pNextCharIndex(TSWPCoreTextTypesetter *this, unint64_t a2)
{
  unint64_t v2 = a2;
  uint64_t v3 = *(void **)(*((void *)this + 29) + 56);
  if ([v3 length] > a2)
  {
    uint64_t v4 = objc_msgSend((id)objc_msgSend(v3, "string"), "rangeOfComposedCharacterSequenceAtIndex:", v2);
    return v4 + v5;
  }
  return v2;
}

uint64_t TSWPCoreTextTypesetter::pKinsokuCanBreak(TSWPCoreTextTypesetter *this, unint64_t *a2, _NSRange *a3)
{
  unint64_t v6 = *a2;
  if (*a2)
  {
    unint64_t v6 = objc_msgSend((id)objc_msgSend(*(id *)(*((void *)this + 29) + 56), "string"), "rangeOfComposedCharacterSequenceAtIndex:", v6 - 1);
    unint64_t v7 = *a2;
  }
  else
  {
    unint64_t v7 = 0;
  }
  if (v7 == *((void *)this + 7)) {
    return 1;
  }
  CFStringRef v8 = (_NSRange *)MEMORY[0x263F7C7C8];
  _NSRange v27 = (_NSRange)*MEMORY[0x263F7C7C8];
  objc_opt_class();
  [*((id *)this + 8) smartFieldAtCharIndex:v7 attributeKind:7 effectiveRange:&v27];
  uint64_t v9 = TSUDynamicCast();
  long long v10 = (TSWPRubyField *)v9;
  if (v9)
  {
    _NSRange v26 = v27;
    unint64_t location = v27.location;
    if (v7 + 1 == v27.length + v27.location)
    {
      uint64_t v12 = *(void **)(*((void *)this + 29) + 56);
      if ([v12 length] > v7)
      {
        uint64_t v13 = objc_msgSend((id)objc_msgSend(v12, "string"), "rangeOfComposedCharacterSequenceAtIndex:", v7);
        unint64_t v7 = v13 + v14;
      }
      objc_opt_class();
      [*((id *)this + 8) smartFieldAtCharIndex:v7 attributeKind:7 effectiveRange:&v26];
      uint64_t v9 = TSUDynamicCast();
      unint64_t location = v26.location;
    }
    unint64_t v15 = v7;
    if (v9)
    {
      unint64_t v15 = v7;
      if (v7 == location)
      {
        uint64_t v16 = *(void **)(*((void *)this + 29) + 56);
        if ([v16 length] <= location)
        {
          unint64_t v15 = location;
        }
        else
        {
          uint64_t v17 = objc_msgSend((id)objc_msgSend(v16, "string"), "rangeOfComposedCharacterSequenceAtIndex:", location);
          unint64_t v15 = v17 + v18;
        }
      }
    }
  }
  else
  {
    unint64_t v15 = v7;
  }
  _NSRange v26 = *v8;
  objc_opt_class();
  [*((id *)this + 8) smartFieldAtCharIndex:v6 attributeKind:7 effectiveRange:&v26];
  if (TSUDynamicCast())
  {
    NSUInteger v19 = v26.location;
    if (v6 == v26.location)
    {
      if (v6) {
        uint64_t v20 = objc_msgSend((id)objc_msgSend(*(id *)(*((void *)this + 29) + 56), "string"), "rangeOfComposedCharacterSequenceAtIndex:", v6 - 1);
      }
      else {
        uint64_t v20 = 0;
      }
      objc_opt_class();
      [*((id *)this + 8) smartFieldAtCharIndex:v20 attributeKind:7 effectiveRange:&v26];
      if (!TSUDynamicCast()) {
        goto LABEL_27;
      }
      NSUInteger v19 = v26.location;
    }
    else
    {
      uint64_t v20 = v6;
      unint64_t v6 = v7;
    }
    if (v20 + 1 == v26.length + v19)
    {
      unint64_t v7 = v6;
      if (v20) {
        unint64_t v6 = objc_msgSend((id)objc_msgSend(*(id *)(*((void *)this + 29) + 56), "string"), "rangeOfComposedCharacterSequenceAtIndex:", v20 - 1);
      }
      else {
        unint64_t v6 = 0;
      }
      goto LABEL_29;
    }
LABEL_27:
    unint64_t v7 = v6;
    unint64_t v6 = v20;
  }
LABEL_29:
  uint64_t v21 = TSWPCoreTextTypesetter::pComposedCharacterAtIndex((id *)this, v6);
  uint64_t v22 = TSWPCoreTextTypesetter::pComposedCharacterAtIndex((id *)this, v15);
  if (a3) {
    *a3 = *v8;
  }
  char v23 = IsParagraphBreakingCharacter(v21);
  if (v21 == 8232
    || (v23 & 1) != 0
    || !KinsokuIllegalEndChar(v21) && !KinsokuIllegalStartChar(v22) && KinsokuAllowSplit(v21, v22))
  {
    if (a3) {
      *a3 = v27;
    }
    if (!v10
      || TSWPParagraphTypesetter::rubyLayoutIsDisabledForField(*((TSWPParagraphTypesetter **)this + 29), v10)
      || v7 <= v27.location
      || v7 >= v27.length + v27.location)
    {
LABEL_42:
      *a2 = v7;
      return 1;
    }
    return 0;
  }
  uint64_t result = IsWhitespaceCharacter(v21);
  if (result)
  {
    if (IsWhitespaceCharacter(v22)) {
      return 0;
    }
    BOOL v25 = IsBreakingSpaceCharacter(*(unsigned __int16 *)(*((void *)this + 10) + 2 * v6));
    uint64_t result = 0;
    if (v6 && !v25)
    {
      do
      {
        uint64_t result = IsWhitespaceCharacter(*(unsigned __int16 *)(*((void *)this + 10) + 2 * v6));
        if (!result) {
          break;
        }
        if (IsBreakingSpaceCharacter(*(unsigned __int16 *)(*((void *)this + 10) + 2 * v6))) {
          goto LABEL_42;
        }
        unint64_t v6 = objc_msgSend((id)objc_msgSend(*(id *)(*((void *)this + 29) + 56), "string"), "rangeOfComposedCharacterSequenceAtIndex:", v6 - 1);
        uint64_t result = 0;
      }
      while (v6);
    }
  }
  return result;
}

uint64_t TSWPCoreTextTypesetter::pPrevCharIndex(TSWPCoreTextTypesetter *this, uint64_t a2)
{
  if (a2) {
    return objc_msgSend((id)objc_msgSend(*(id *)(*((void *)this + 29) + 56), "string"), "rangeOfComposedCharacterSequenceAtIndex:", a2 - 1);
  }
  else {
    return 0;
  }
}

uint64_t TSWPCoreTextTypesetter::pCanBreakLineInRange(TSWPCoreTextTypesetter *this, unint64_t a2, unint64_t a3)
{
  unint64_t v6 = a3 - a2;
  if (a3 <= a2 || *((void *)this + 7) < a3)
  {
    unint64_t v7 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v8 = objc_msgSend(NSString, "stringWithUTF8String:", "BOOL TSWPCoreTextTypesetter::pCanBreakLineInRange(TSWPCharIndex, TSWPCharIndex)");
    objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 1904, @"Bad localMaxCharIndex");
  }
  CFCharacterSetRef v9 = (const __CFCharacterSet *)TSWPCoreTextTypesetter::pCanBreakLineInRange(unsigned long,unsigned long)::sBreakPointCharacterSet;
  if (!TSWPCoreTextTypesetter::pCanBreakLineInRange(unsigned long,unsigned long)::sBreakPointCharacterSet)
  {
    CFAttributedStringRef Mutable = CFCharacterSetCreateMutable(0);
    TSWPCoreTextTypesetter::pCanBreakLineInRange(unsigned long,unsigned long)::sBreakPointCharacterSet = (uint64_t)Mutable;
    CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespaceAndNewline);
    CFCharacterSetUnion(Mutable, Predefined);
    v19.unint64_t location = 8232;
    v19.NSUInteger length = 1;
    CFCharacterSetAddCharactersInRange((CFMutableCharacterSetRef)TSWPCoreTextTypesetter::pCanBreakLineInRange(unsigned long,unsigned long)::sBreakPointCharacterSet, v19);
    v20.unint64_t location = 65532;
    v20.NSUInteger length = 1;
    CFCharacterSetAddCharactersInRange((CFMutableCharacterSetRef)TSWPCoreTextTypesetter::pCanBreakLineInRange(unsigned long,unsigned long)::sBreakPointCharacterSet, v20);
    v21.unint64_t location = 45;
    v21.NSUInteger length = 1;
    CFCharacterSetAddCharactersInRange((CFMutableCharacterSetRef)TSWPCoreTextTypesetter::pCanBreakLineInRange(unsigned long,unsigned long)::sBreakPointCharacterSet, v21);
    v22.unint64_t location = 160;
    v22.NSUInteger length = 1;
    CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)TSWPCoreTextTypesetter::pCanBreakLineInRange(unsigned long,unsigned long)::sBreakPointCharacterSet, v22);
    v23.unint64_t location = 8239;
    v23.NSUInteger length = 1;
    CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)TSWPCoreTextTypesetter::pCanBreakLineInRange(unsigned long,unsigned long)::sBreakPointCharacterSet, v23);
    v24.unint64_t location = 8199;
    v24.NSUInteger length = 1;
    CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)TSWPCoreTextTypesetter::pCanBreakLineInRange(unsigned long,unsigned long)::sBreakPointCharacterSet, v24);
    v25.unint64_t location = 65279;
    v25.NSUInteger length = 1;
    CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)TSWPCoreTextTypesetter::pCanBreakLineInRange(unsigned long,unsigned long)::sBreakPointCharacterSet, v25);
    CFCharacterSetRef v9 = (const __CFCharacterSet *)TSWPCoreTextTypesetter::pCanBreakLineInRange(unsigned long,unsigned long)::sBreakPointCharacterSet;
  }
  if (CFCharacterSetIsCharacterMember(v9, *(_WORD *)(*((void *)this + 10) + 2 * a3 - 2))) {
    return 1;
  }
  id v13 = (id)*((void *)this + 27);
  if (!v13)
  {
    id v13 = objc_alloc_init(MEMORY[0x263F089C8]);
    CFStringRef v14 = CFStringCreateWithCharactersNoCopy(0, *((const UniChar **)this + 10), *((void *)this + 7), (CFAllocatorRef)*MEMORY[0x263EFFB28]);
    v26.NSUInteger length = *((void *)this + 7);
    v26.unint64_t location = 0;
    unint64_t v15 = CFStringTokenizerCreate(0, v14, v26, 3uLL, 0);
    uint64_t v16 = v15;
    while (CFStringTokenizerAdvanceToNextToken(v15))
    {
      CFRange CurrentTokenRange = CFStringTokenizerGetCurrentTokenRange(v16);
      [v13 addIndex:CurrentTokenRange.location + CurrentTokenRange.length];
      unint64_t v15 = v16;
    }
    CFRelease(v16);
    CFRelease(v14);
    *((void *)this + 27) = v13;
  }

  return objc_msgSend(v13, "containsIndexesInRange:", a2, v6 + 1);
}

BOOL TSWPCoreTextTypesetter::pRoomForHyphen(TSWPCoreTextTypesetter *this, CFRange a2, double a3, int a4, TSWPLineFragment *a5)
{
  CFIndex length = a2.length;
  CFIndex location = a2.location;
  FontRunIndexForLocalCharIndeCGFloat x = TSWPCoreTextTypesetter::pFindFontRunIndexForLocalCharIndex(this, a2.location + a2.length);
  TSWPLineFragment::setHyphenInfo(a5, *(CFTypeRef *)(*((void *)this + 15) + 104 * FontRunIndexForLocalCharIndex + 32), a4);
  uint64_t v12 = *(const __CTFont **)(*((void *)this + 15) + 104 * FontRunIndexForLocalCharIndex + 24);
  if ((a4 - 0x10000) >> 20)
  {
    CFIndex v14 = 1;
    LOWORD(v13) = a4;
  }
  else
  {
    unsigned int v13 = ((a4 + 67043328) >> 10) - 10240;
    characters[1] = a4 & 0x3FF | 0xDC00;
    CFIndex v14 = 2;
  }
  characters[0] = v13;
  CTFontGetGlyphsForCharacters(v12, characters, glyphs, v14);
  CTFontGetAdvancesForGlyphs(v12, kCTFontOrientationDefault, glyphs, &advances, 1);
  unint64_t v15 = (const __CTTypesetter *)TSWPCoreTextTypesetter::pCTTypesetter(this);
  v28.CFIndex location = location;
  v28.CFIndex length = length;
  double Line = CTTypesetterCreateLine(v15, v28);
  if (Line)
  {
    uint64_t v17 = Line;
    double TypographicBounds = CTLineGetTypographicBounds(Line, 0, 0, 0);
    Truncateddouble Line = CTLineCreateTruncatedLine(v17, a3 - advances.width, kCTLineTruncationEnd, 0);
    if (TruncatedLine)
    {
      CFRange v20 = TruncatedLine;
      double v21 = CTLineGetTypographicBounds(TruncatedLine, 0, 0, 0);
      CFRelease(v20);
    }
    else
    {
      double v21 = NAN;
    }
    CFRelease(v17);
  }
  else
  {
    CFRange v22 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v23 = objc_msgSend(NSString, "stringWithUTF8String:", "BOOL TSWPCoreTextTypesetter::pRoomForHyphen(CFRange, UTF32Char, CGFloat, TSWPLineFragment *)");
    objc_msgSend(v22, "handleFailureInFunction:file:lineNumber:description:", v23, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 3725, @"CTTypesetterCreateLine returned nil");
    double TypographicBounds = 0.0;
    double v21 = NAN;
  }
  return v21 == TypographicBounds;
}

uint64_t TSWPCoreTextTypesetter::pHyphenateLocalRange(id *this, CFRange *a2, const TSWPLayoutState *a3, double a4, TSWPLineFragment *a5)
{
  if (*((double *)a3 + 52) >= a4) {
    return 0xFFFFFFFFLL;
  }
  CFIndex location = a2->location;
  CFIndex v11 = a2->length + a2->location;
  uint64_t v12 = [this[8] wordAtCharIndex:v11 includePreviousWord:1];
  if (v12 == 0x7FFFFFFFFFFFFFFFLL) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v14 = v13;
  BOOL v15 = v13 < *((void *)a3 + 54) || v11 <= location;
  if (v15) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v16 = v12;
  long long v36 = a5;
  unsigned int v17 = 0;
  uint64_t v37 = v12 + v13;
  while (1)
  {
    unsigned int v38 = 0;
    uint64_t v18 = *((void *)a3 + 53);
    if (!v18)
    {
      CFRange v19 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v20 = objc_msgSend(NSString, "stringWithUTF8String:", "TSWPHyphenationResult TSWPCoreTextTypesetter::pHyphenateLocalRange(CFRange &, const TSWPLayoutState *, CGFloat, TSWPLineFragment *)");
      objc_msgSend(v19, "handleFailureInFunction:file:lineNumber:description:", v20, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 3629, @"invalid nil value for '%s'", "state->hyphenationLocale");
      uint64_t v18 = *((void *)a3 + 53);
    }
    CFIndex v21 = objc_msgSend(this[8], "hyphenationLocationBeforeIndex:inRange:locale:hyphenChar:", v11, v16, v14, v18, &v38);
    CFIndex v22 = v21;
    if ((uint64_t)(*((void *)a3 + 55) + v16) <= v21 && v21 <= v37 - *((void *)a3 + 56))
    {
      v23.CFIndex location = a2->location;
      if (v11 <= v21 || v21 <= v23.location) {
        return 0xFFFFFFFFLL;
      }
      if (v21 != -1)
      {
        if (v21 < v16 || v21 - v16 >= v14)
        {
          _NSRange v27 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v28 = objc_msgSend(NSString, "stringWithUTF8String:", "TSWPHyphenationResult TSWPCoreTextTypesetter::pHyphenateLocalRange(CFRange &, const TSWPLayoutState *, CGFloat, TSWPLineFragment *)");
          objc_msgSend(v27, "handleFailureInFunction:file:lineNumber:description:", v28, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 3650, @"Bad hyphenation result");
          return 0xFFFFFFFFLL;
        }
        v23.CFIndex length = v21 - v23.location;
        if (TSWPCoreTextTypesetter::pRoomForHyphen((TSWPCoreTextTypesetter *)this, v23, a4, v38, v36)) {
          break;
        }
      }
    }
    BOOL v25 = v22 <= location || v17++ >= 0x13;
    CFIndex v11 = v22;
    if (v25) {
      return 0xFFFFFFFFLL;
    }
  }
  CFIndex v29 = a2->location;
  CFIndex v30 = v16 - a2->location;
  if (v30 >= 1)
  {
    long long v31 = (const __CTTypesetter *)TSWPCoreTextTypesetter::pCTTypesetter((TSWPCoreTextTypesetter *)this);
    v39.CFIndex location = v29;
    v39.CFIndex length = v30;
    double Line = CTTypesetterCreateLine(v31, v39);
    if (Line)
    {
      uint64_t v33 = Line;
      if (a4 - CTLineGetTypographicBounds(Line, 0, 0, 0) < *((double *)a3 + 52))
      {
        a2->CFIndex length = v16 - a2->location;
        CFRelease(v33);
        return 0xFFFFFFFFLL;
      }
      CFRelease(v33);
    }
  }
  BOOL v15 = v22 <= a2->location;
  a2->CFIndex length = v22 - a2->location;
  if (v15)
  {
    NSUInteger v34 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v35 = objc_msgSend(NSString, "stringWithUTF8String:", "TSWPHyphenationResult TSWPCoreTextTypesetter::pHyphenateLocalRange(CFRange &, const TSWPLayoutState *, CGFloat, TSWPLineFragment *)");
    objc_msgSend(v34, "handleFailureInFunction:file:lineNumber:description:", v35, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 3690, @"Bad hyphenation result range");
  }
  return 1;
}

uint64_t TSWPCoreTextTypesetter::skipLine(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v4 = *a2 + *(void *)(*(void *)(a3 + 200) + 8);
  if (v4) {
    uint64_t v5 = v4 - 1;
  }
  else {
    uint64_t v5 = 0;
  }
  *(void *)(a3 + 216) = v5;
  if (v4) {
    __int16 v6 = objc_msgSend(*(id *)(a1 + 16), "characterAtIndex:");
  }
  else {
    __int16 v6 = 0;
  }
  *(_WORD *)(a3 + 208) = v6;
  return v4;
}

void TSWPCoreTextTypesetter::truncateLineFragment(uint64_t a1, uint64_t a2, TSWPLineFragment *this, char a4, int a5)
{
  *((_DWORD *)this + 6) = *((_DWORD *)this + 6) & 0xFF7FFFFD | 0x800000;
  CFIndex v11 = (CFTypeRef *)*((void *)this + 24);
  for (uint64_t i = (CFTypeRef *)*((void *)this + 25);
        i != v11;
        std::allocator<TSWPLineRef>::destroy[abi:ne180100]((uint64_t)this + 208, i))
  {
    i -= 6;
  }
  *((void *)this + 25) = v11;
  uint64_t v13 = *((void *)this + 34);
  for (uint64_t j = *((void *)this + 35);
        j != v13;
        std::allocator<TSWPAdornmentLine>::destroy[abi:ne180100]((uint64_t)this + 288, j))
  {
    j -= 80;
  }
  *((void *)this + 35) = v13;
  uint64_t v15 = *((void *)this + 37);
  for (uint64_t k = *((void *)this + 38);
        k != v15;
        std::allocator<TSWPAdornmentLine>::destroy[abi:ne180100]((uint64_t)this + 312, k))
  {
    k -= 80;
  }
  *((void *)this + 38) = v15;
  uint64_t v17 = *((void *)this + 40);
  for (uint64_t m = *((void *)this + 41);
        m != v17;
        std::allocator<TSWPAdornmentLine>::destroy[abi:ne180100]((uint64_t)this + 336, m))
  {
    m -= 80;
  }
  int v18 = a4 & 0xC;
  *((void *)this + 41) = v17;
  uint64_t v20 = *((void *)this + 43);
  for (uint64_t n = *((void *)this + 44);
        n != v20;
        std::allocator<TSWPAdornmentLine>::destroy[abi:ne180100]((uint64_t)this + 360, n))
  {
    n -= 80;
  }
  *((void *)this + 44) = v20;
  TSWPCoreTextTypesetter::createLineRefsForLineFragment(a1, this, a2, v18 != 0, a5);
  uint64_t v21 = *((void *)this + 24);
  if (0xAAAAAAAAAAAAAAABLL * ((*((void *)this + 25) - v21) >> 4) >= 2)
  {
    unsigned int v22 = 2;
    uint64_t v23 = 1;
    do
    {
      uint64_t v24 = v21 + 48 * v23;
      double v25 = *(double *)(v24 + 8);
      uint64_t v28 = 0;
      CGFloat ascent = 0.0;
      double v26 = v25 + CTLineGetTypographicBounds(*(CTLineRef *)v24, &ascent, (CGFloat *)&v28, 0);
      if (*((double *)this + 27) >= v26) {
        double v26 = *((double *)this + 27);
      }
      *((double *)this + 27) = v26;
      uint64_t v23 = v22;
      uint64_t v21 = *((void *)this + 24);
    }
    while (0xAAAAAAAAAAAAAAABLL * ((*((void *)this + 25) - v21) >> 4) > v22++);
  }
}

double TSWPCoreTextTypesetter::pMaxRubyHeightAboveLineFragment(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v3 = 0.0;
  if (*(void *)(a3 + 232) != *(void *)(a3 + 224))
  {
    double v5 = TSWPLayoutChore::calculateBaselineOffsetWithHeightInfo((double *)(a3 + 112), a2);
    uint64_t v6 = *(void *)(a3 + 224);
    if (*(void *)(a3 + 232) != v6)
    {
      double v7 = v5;
      uint64_t v8 = 0;
      unsigned int v9 = 1;
      do
      {
        uint64_t v10 = v6 + 48 * v8;
        CGFloat ascent = 0.0;
        CTLineGetTypographicBounds(*(CTLineRef *)v10, &ascent, 0, 0);
        if (v3 <= -(v7 + *(double *)(v10 + 16) - ascent)) {
          double v3 = -(v7 + *(double *)(v10 + 16) - ascent);
        }
        uint64_t v8 = v9;
        uint64_t v6 = *(void *)(a3 + 224);
      }
      while (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a3 + 232) - v6) >> 4) > v9++);
    }
  }
  return v3;
}

BOOL TSWPCoreTextTypesetter::pSetUpEmphasisMarkAdornments(id *this, const TSWPLayoutState *a2, TSWPAdornments *a3, CTRunRef *a4, TSWPLineFragment *a5, NSString *a6, unsigned __int16 *a7, CGSize *a8)
{
  buffer[1] = *MEMORY[0x263EF8340];
  uint64_t v15 = [this[8] characterStyleAtCharIndex:CTRunGetStringRange(*a4).location effectiveRange:0];
  objc_msgSend((id)TSWPResolvePropertyForStyles(v15, *((void *)a2 + 12), 17, 0), "doubleValue");
  double v17 = v16;
  CFDictionaryRef Attributes = CTRunGetAttributes(*a4);
  CFIndex GlyphCount = CTRunGetGlyphCount(*a4);
  if (![(__CFDictionary *)Attributes objectForKeyedSubscript:*MEMORY[0x263F03CA8]]) {
    goto LABEL_8;
  }
  v40.CFIndex location = 0;
  v40.CFIndex length = 1;
  CTRunGetStringIndices(*a4, v40, buffer);
  if (*((unsigned __int16 *)this[10] + buffer[0]) == (unsigned __int16)kTateChuYokoDummySpaceCharacter
    && GlyphCount == 1
    && (uint64_t v20 = (TSWPParagraphTypesetter *)this[29]) != 0)
  {
    TateChuYokoLineRefsForCharIndeCGFloat x = TSWPParagraphTypesetter::findTateChuYokoLineRefsForCharIndex(v20, buffer[0]);
    BOOL v22 = TateChuYokoLineRefsForCharIndex != 0;
    if (v15 && TateChuYokoLineRefsForCharIndex)
    {
      objc_msgSend((id)TSWPResolvePropertyForStyles(0, *((void *)a2 + 12), 17, 0), "doubleValue");
      double v17 = v23;
LABEL_8:
      BOOL v22 = 1;
    }
  }
  else
  {
    BOOL v22 = 0;
  }
  CTFontRef v24 = CTFontCreateWithName(@"HiraMinProN-W3", v17 * (float)((float)(unint64_t)[*((id *)a2 + 13) scaleTextPercent] / 100.0) / 3.0, 0);
  if (v24)
  {
    CTFontRef v25 = v24;
    if (v22)
    {
      double v26 = (CGColor *)[(__CFDictionary *)Attributes objectForKeyedSubscript:*MEMORY[0x263F03C60]];
      CFRetain(v25);
      _NSRange v27 = (const void *)*((void *)a3 + 3);
      if (v27) {
        CFRelease(v27);
      }
      *((void *)a3 + 3) = v25;
      CGColorRetain(v26);
      CGColorRelease(*((CGColorRef *)a3 + 2));
      *((void *)a3 + 2) = v26;
      int v28 = [(NSString *)a6 characterAtIndex:0];
      LOWORD(buffer[0]) = v28;
      int v29 = TSWPGetAdornmentLocation(this[12], *((unsigned __int8 *)this + 30), 4);
      int v30 = TSWPCJKLanguageForInputLanguageString(this[12]);
      if (v28 == 65093)
      {
        if (v29 == 2 || v30 == 1)
        {
          int v28 = 8226;
          LOWORD(buffer[0]) = 8226;
        }
        else
        {
          int v28 = 65093;
        }
      }
      *((unsigned char *)a3 + 192) = (v28 == 65093) & (*((_DWORD *)a5 + 6) >> 13);
      BOOL GlyphsForCharacters = CTFontGetGlyphsForCharacters(v25, (const UniChar *)buffer, a7, 1);
      if (GlyphsForCharacters)
      {
        CTFontGetAdvancesForGlyphs(*((CTFontRef *)a3 + 3), kCTFontOrientationDefault, a7, a8, 1);
        CGFloat Ascent = CTFontGetAscent(v25);
        CGFloat Descent = CTFontGetDescent(v25);
        CGFloat width = a8->width;
        *((CGFloat *)a3 + 19) = Ascent;
        *((CGFloat *)a3 + 20) = Descent;
        *((CGFloat *)a3 + 21) = width;
        *((_DWORD *)a3 + 1) = v29;
      }
    }
    else
    {
      BOOL GlyphsForCharacters = 0;
    }
    CFRelease(v25);
  }
  else
  {
    long long v31 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v32 = objc_msgSend(NSString, "stringWithUTF8String:", "BOOL TSWPCoreTextTypesetter::pSetUpEmphasisMarkAdornments(const TSWPLayoutState *, TSWPAdornments &, const CTRunRef &, TSWPLineFragment *, NSString *, CGGlyph &, CGSize &) const");
    [v31 handleFailureInFunction:v32, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 4153, @"Emphasis marks, no font." file lineNumber description];
    return 0;
  }
  return GlyphsForCharacters;
}

void *TSWPCoreTextTypesetter::pFindTateRun(TSWPCoreTextTypesetter *this, uint64_t a2, uint64_t a3)
{
  if (*(unsigned __int16 *)(*((void *)this + 10) + 2 * a2) == (unsigned __int16)kTateChuYokoDummySpaceCharacter
    && a3 == 1
    && (double v3 = (TSWPParagraphTypesetter *)*((void *)this + 29)) != 0)
  {
    return TSWPParagraphTypesetter::findTateChuYokoLineRefsForCharIndex(v3, a2);
  }
  else
  {
    return 0;
  }
}

unint64_t addAdornmentLine(uint64_t *a1, TSWPAdornmentLine *a2)
{
  unint64_t v4 = a1[1];
  if (v4 == *a1 || (BOOL v5 = TSWPAdornmentLine::merge((TSWPAdornmentLine *)(v4 - 80), a2), v4 = a1[1], !v5))
  {
    if (v4 >= a1[2])
    {
      unint64_t v4 = std::vector<TSWPAdornmentLine>::__push_back_slow_path<TSWPAdornmentLine const&>(a1, (uint64_t)a2);
    }
    else
    {
      std::allocator<TSWPAdornmentLine>::construct[abi:ne180100]<TSWPAdornmentLine,TSWPAdornmentLine const&>((uint64_t)(a1 + 2), v4, (uint64_t)a2);
      v4 += 80;
      a1[1] = v4;
    }
    a1[1] = v4;
  }
  return v4 - 80;
}

void sub_223763F88(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void TSWPAdornmentLine::~TSWPAdornmentLine(TSWPAdornmentLine *this)
{
}

void TSWPCoreTextTypesetter::pAddHighlightAdornmentToLineFragment(TSWPCoreTextTypesetter *this, TSWPLineFragment *a2, double a3, CGFloat a4, TSKAnnotationAuthor *a5)
{
  uint64_t v8 = [[TSKAnnotationAuthorTextHighlightColorProvider alloc] initWithAnnotationAuthor:a5];
  v10.var0.CGFloat x = a4;
  v10.var0.CGFloat y = 0.0;
  v10.unsigned int var1 = a3;
  v10.BOOL var7 = 0.0;
  v10.int var8 = 0;
  memset(&v10.var2, 0, 28);
  v10.var9 = v8;
  CGColorRetain(0);
  unsigned int v9 = v8;
  addAdornmentLine((uint64_t *)a2 + 43, &v10);

  CGColorRelease(v10.var2);
}

void sub_223764070(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void TSWPCoreTextTypesetter::pAddEmphasisMarkGlyph(uint64_t a1, TSWPAdornments *a2, uint64_t a3, CTRunRef run, CFRange range, uint64_t a6, const __CTFont *a7, CGFloat a8, double a9, double a10, double a11, double a12, unint64_t charIndex, char a14, unsigned __int16 a15)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  if (range.length
    || (IsWordBoundaryCharacter(a6) & 1) == 0
    && (objc_msgSend((id)objc_msgSend(MEMORY[0x263F08708], "punctuationCharacterSet"), "characterIsMember:", a6) & 1) == 0)
  {
    if (*((_DWORD *)a2 + 1) != 1
      || ((v36.origiuint64_t n = (CGPoint)*MEMORY[0x263F7C7C8], *(void *)&v36.origin.x == *MEMORY[0x263F7C7C8])
        ? (BOOL v26 = *(void *)&v36.origin.y == *(void *)(MEMORY[0x263F7C7C8] + 8))
        : (BOOL v26 = 0),
          !v26
       || ![*(id *)(a1 + 64) smartFieldAtCharIndex:charIndex attributeKind:7 effectiveRange:&v36]
       || charIndex < *(void *)&v36.origin.x
       || charIndex - *(void *)&v36.origin.x >= *(void *)&v36.origin.y))
    {
      CGSize v27 = *(CGSize *)(MEMORY[0x263F001A8] + 16);
      v36.origiuint64_t n = (CGPoint)*MEMORY[0x263F001A8];
      v36.uint64_t size = v27;
      if (length)
      {
        double width = *(double *)(length + 32);
        double v29 = *(double *)(a3 + 8);
        double v30 = v29 + CTLineGetOffsetForStringIndex(*(CTLineRef *)a3, charIndex, 0);
        double v31 = 0.5;
        double v32 = width * 0.5 + v30;
      }
      else
      {
        LOWORD(v35.x) = 0;
        v37.CFIndex location = location;
        v37.CFIndex length = 1;
        CTRunGetGlyphs(run, v37, (CGGlyph *)&v35);
        if (a14) {
          CTFontOrientation v34 = kCTFontOrientationVertical;
        }
        else {
          CTFontOrientation v34 = kCTFontOrientationDefault;
        }
        CGRect BoundingRectsForGlyphs = CTFontGetBoundingRectsForGlyphs(a7, v34, (const CGGlyph *)&v35, 0, 1);
        if (!a14)
        {
          v35.CGFloat x = a8 + (a10 - a12) * 0.5;
          v35.CGFloat y = 0.0;
          v36.origin.CGFloat x = a8;
          double width = a10;
          goto LABEL_22;
        }
        double width = BoundingRectsForGlyphs.size.width;
        double v30 = -a9;
        double v31 = 0.5;
        double v32 = -a9 - BoundingRectsForGlyphs.size.width * 0.5;
      }
      v35.CGFloat x = v32 - a12 * v31;
      v35.CGFloat y = 0.0;
      v36.origin.CGFloat x = v30;
LABEL_22:
      v36.origin.CGFloat y = 0.0;
      v36.size.double width = width;
      v36.size.CGFloat height = 1.0;
      TSWPAdornments::add(a2, objc_msgSend(*(id *)(a1 + 64), "charIndexMappedToStorage:", charIndex, *(void *)&v35.x, *(void *)&v35.y, *(void *)&v36.origin.x, 0, *(void *)&width, 0x3FF0000000000000), &v35, &a15, &v36);
    }
  }
}

void TSWPCoreTextTypesetter::pAddInvisibleBreakToLineFragment(id *this, const TSWPLayoutState *a2, TSWPLineFragment *a3, int a4, double a5, char a6)
{
  uint64_t v12 = objc_msgSend(this[8], "charRangeMappedFromStorage:", *(void *)a3, *((void *)a3 + 1));
  double v14 = *(double *)(*((void *)a3 + 24) + 8);
  int v15 = a4 - 4;
  double v16 = 2.0;
  uint64_t v17 = 7;
  switch(v15)
  {
    case 0:
      goto LABEL_15;
    case 1:
      int v18 = [this[8] hasColumnStyleForParagraphBreakAtCharIndex:v13 + v12 - 1];
      if (v18) {
        double v16 = 1.0;
      }
      else {
        double v16 = 2.0;
      }
      if (v18) {
        uint64_t v17 = 5;
      }
      else {
        uint64_t v17 = 6;
      }
      goto LABEL_15;
    case 6:
    case 7:
    case 9:
      int v19 = [this[8] hasColumnStyleForParagraphBreakAtCharIndex:v13 + v12 - 1];
      if (v19) {
        double v16 = 1.0;
      }
      else {
        double v16 = 0.0;
      }
      if (v19) {
        uint64_t v17 = 5;
      }
      else {
        uint64_t v17 = 3;
      }
      goto LABEL_15;
    case 8:
      double v16 = 1.0;
      uint64_t v17 = 4;
LABEL_15:
      double v20 = v14 + a5;
      if (TSWPParagraphEnumerator::paragraphTextRange((TSWPParagraphEnumerator *)((char *)a2 + 24)) != *((void *)a3 + 2))
      {
        uint64_t v21 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v22 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPCoreTextTypesetter::pAddInvisibleBreakToLineFragment(const TSWPLayoutState *, TSWPLineFragment *, unichar, CGFloat, BOOL) const");
        objc_msgSend(v21, "handleFailureInFunction:file:lineNumber:description:", v22, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 3419, @"line fragment isn't from the current paragraph");
      }
      double v23 = *((double *)&gInvisibles + 5 * v17 + 1);
      int v24 = *((_DWORD *)a3 + 6);
      if (fabs(v20) == INFINITY)
      {
        if ((v24 & 0x1000) == 0)
        {
          double v20 = *((double *)a3 + 27) + 0.0;
          goto LABEL_29;
        }
        double v25 = 0.0;
        goto LABEL_28;
      }
      if ((v24 & 0x1000) != 0)
      {
        double v25 = 0.0;
        if (v20 >= 0.0) {
          double v25 = v20;
        }
LABEL_28:
        double v20 = v25 - v23;
        goto LABEL_29;
      }
      if ((a6 & 1) == 0 && *((double *)a3 + 8) < v20) {
        double v20 = *((double *)a3 + 8);
      }
LABEL_29:
      BOOL v26 = (long long *)MEMORY[0x263F00148];
      CGPoint v50 = (CGPoint)*MEMORY[0x263F00148];
      if (!*((unsigned char *)&gInvisibles + 40 * v17 + 2))
      {
        double v28 = (7.0 - v23) * 0.5 + v20;
        goto LABEL_44;
      }
      if ((v24 & 0x1000) != 0)
      {
        double v28 = fmin(v20, 0.0);
        v50.CGFloat x = v28;
        double v29 = v23 + v20 - (v23 + v28);
      }
      else
      {
        double v27 = *((double *)a3 + 8) - v23;
        if (v27 >= v20) {
          double v28 = v27;
        }
        else {
          double v28 = v20;
        }
        double v29 = v28 - v20;
        if (v28 - v20 < 0.0) {
          goto LABEL_44;
        }
      }
      if (v29 > 0.0)
      {
        if (v16 <= 0.0)
        {
          double v30 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v31 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPCoreTextTypesetter::pAddInvisibleBreakToLineFragment(const TSWPLayoutState *, TSWPLineFragment *, unichar, CGFloat, BOOL) const");
          objc_msgSend(v30, "handleFailureInFunction:file:lineNumber:description:", v31, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 3477, @"break line has no thickness");
        }
        if (!TSWPCoreTextTypesetter::pAddInvisibleBreakToLineFragment(TSWPLayoutState const*,TSWPLineFragment *,unsigned short,double,BOOL)const::invisiblesColor) {
          TSWPCoreTextTypesetter::pAddInvisibleBreakToLineFragment(TSWPLayoutState const*,TSWPLineFragment *,unsigned short,double,BOOL)const::invisiblesColor = (uint64_t)CGColorRetain((CGColorRef)objc_msgSend((id)objc_msgSend(MEMORY[0x263F7C808], "colorWithRed:green:blue:alpha:", 0.180392161, 0.533333361, 0.921568632, 1.0), "CGColor"));
        }
        operator new();
      }
LABEL_44:
      v50.CGFloat x = v28 - v14;
      double v32 = +[TSWPRenderer invisiblesFont];
      v36[0] = 0x100000002;
      v36[1] = 0;
      CGColorRef color = 0;
      CFTypeRef cf = v32;
      *(_OWORD *)CFRange v39 = 0u;
      *(_OWORD *)CFRange v40 = 0u;
      long long v41 = 0u;
      *(_OWORD *)long long v42 = 0u;
      *(_OWORD *)unsigned int v43 = 0u;
      long long v44 = 0u;
      *(_OWORD *)TSWPRangeVector __p = 0u;
      long long v46 = 0u;
      long long v33 = *v26;
      long long v47 = 0u;
      long long v48 = v33;
      char v49 = 0;
      CGColorRetain(0);
      if (v32) {
        CFRetain(v32);
      }
      TSWPAdornments::add((TSWPAdornments *)v36, &v50, (const unsigned __int16 *)&gInvisibles + 20 * v17 + 16);
      unint64_t v34 = *((void *)a3 + 56);
      if (v34 >= *((void *)a3 + 57))
      {
        uint64_t v35 = std::vector<TSWPAdornments>::__push_back_slow_path<TSWPAdornments const&>((uint64_t *)a3 + 55, (const TSWPAdornments *)v36);
      }
      else
      {
        TSWPAdornments::TSWPAdornments(*((TSWPAdornments **)a3 + 56), (const TSWPAdornments *)v36);
        uint64_t v35 = v34 + 200;
        *((void *)a3 + 56) = v34 + 200;
      }
      *((void *)a3 + 56) = v35;
      TSWPLineFragment::adjustBreakLine(a3);
      CGColorRelease(color);
      if (cf) {
        CFRelease(cf);
      }
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
      if (v43[1])
      {
        *(void **)&long long v44 = v43[1];
        operator delete(v43[1]);
      }
      if (v42[0])
      {
        v42[1] = v42[0];
        operator delete(v42[0]);
      }
      if (v40[1])
      {
        *(void **)&long long v41 = v40[1];
        operator delete(v40[1]);
      }
      if (v39[0])
      {
        v39[1] = v39[0];
        operator delete(v39[0]);
      }
      return;
    default:
      return;
  }
}

void sub_223764764(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  *(void *)(v2 + 448) = v3;
  TSWPAdornments::~TSWPAdornments((CGColorRef *)va);
  _Unwind_Resume(a1);
}

uint64_t TSWPCoreTextTypesetter::pComposedCharacterAtIndex(id *this, unint64_t a2)
{
  unint64_t v4 = [this[8] length];
  if (v4 <= a2) {
    return 0;
  }
  unint64_t v5 = v4;
  uint64_t v6 = (unsigned __int16 *)this[10];
  uint64_t result = v6[a2];
  if (a2 + 1 < v5)
  {
    int v8 = v6[a2 + 1];
    if ((result & 0xFC00) == 0xD800 && (v8 & 0xFC00) == 56320) {
      return (v8 + (result << 10) - 56613888);
    }
  }
  return result;
}

void TSWPAdornments::add(TSWPAdornments *this, uint64_t a2, const CGPoint *a3, const unsigned __int16 *a4, const CGRect *a5)
{
  TSWPAdornmentLine v10 = (char *)this + 48;
  unint64_t v11 = *((void *)this + 6);
  uint64_t v12 = (char *)*((void *)this + 5);
  if ((unint64_t)v12 >= v11)
  {
    double v14 = (char *)*((void *)this + 4);
    uint64_t v15 = (v12 - v14) >> 3;
    if ((unint64_t)(v15 + 1) >> 61) {
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v16 = v11 - (void)v14;
    unint64_t v17 = (uint64_t)(v11 - (void)v14) >> 2;
    if (v17 <= v15 + 1) {
      unint64_t v17 = v15 + 1;
    }
    if (v16 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v17;
    }
    if (v18)
    {
      int v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>((uint64_t)v10, v18);
      double v14 = (char *)*((void *)this + 4);
      uint64_t v12 = (char *)*((void *)this + 5);
    }
    else
    {
      int v19 = 0;
    }
    double v20 = &v19[8 * v15];
    uint64_t v21 = &v19[8 * v18];
    *(void *)double v20 = a2;
    uint64_t v13 = v20 + 8;
    while (v12 != v14)
    {
      uint64_t v22 = *((void *)v12 - 1);
      v12 -= 8;
      *((void *)v20 - 1) = v22;
      v20 -= 8;
    }
    *((void *)this + 4) = v20;
    *((void *)this + 5) = v13;
    *((void *)this + 6) = v21;
    if (v14) {
      operator delete(v14);
    }
  }
  else
  {
    *(void *)uint64_t v12 = a2;
    uint64_t v13 = v12 + 8;
  }
  unint64_t v23 = *((void *)this + 15);
  *((void *)this + 5) = v13;
  int v24 = (CGPoint *)*((void *)this + 14);
  if ((unint64_t)v24 >= v23)
  {
    uint64_t v26 = *((void *)this + 13);
    uint64_t v27 = ((uint64_t)v24 - v26) >> 4;
    unint64_t v28 = v27 + 1;
    if ((unint64_t)(v27 + 1) >> 60) {
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v29 = v23 - v26;
    if (v29 >> 3 > v28) {
      unint64_t v28 = v29 >> 3;
    }
    if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v30 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v30 = v28;
    }
    if (v30) {
      uint64_t v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CGPoint>>((uint64_t)this + 120, v30);
    }
    else {
      uint64_t v31 = 0;
    }
    double v32 = (CGPoint *)&v31[16 * v27];
    long long v33 = &v31[16 * v30];
    *double v32 = *a3;
    double v25 = v32 + 1;
    uint64_t v35 = (CGPoint *)*((void *)this + 13);
    unint64_t v34 = (CGPoint *)*((void *)this + 14);
    if (v34 != v35)
    {
      do
      {
        v32[-1] = v34[-1];
        --v32;
        --v34;
      }
      while (v34 != v35);
      unint64_t v34 = (CGPoint *)*((void *)this + 13);
    }
    *((void *)this + 13) = v32;
    *((void *)this + 14) = v25;
    *((void *)this + 15) = v33;
    if (v34) {
      operator delete(v34);
    }
  }
  else
  {
    *int v24 = *a3;
    double v25 = v24 + 1;
  }
  unint64_t v36 = *((void *)this + 9);
  *((void *)this + 14) = v25;
  CFRange v37 = (char *)*((void *)this + 8);
  if ((unint64_t)v37 >= v36)
  {
    CFRange v39 = (char *)*((void *)this + 7);
    uint64_t v40 = v37 - v39;
    if (v37 - v39 <= -3) {
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v41 = v40 >> 1;
    unint64_t v42 = v36 - (void)v39;
    if (v42 <= (v40 >> 1) + 1) {
      unint64_t v43 = v41 + 1;
    }
    else {
      unint64_t v43 = v42;
    }
    if (v42 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v44 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v44 = v43;
    }
    if (v44)
    {
      NSRange v45 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>((uint64_t)this + 72, v44);
      CFRange v39 = (char *)*((void *)this + 7);
      CFRange v37 = (char *)*((void *)this + 8);
    }
    else
    {
      NSRange v45 = 0;
    }
    long long v46 = &v45[2 * v41];
    long long v47 = &v45[2 * v44];
    *(_WORD *)long long v46 = *a4;
    unsigned int v38 = v46 + 2;
    while (v37 != v39)
    {
      __int16 v48 = *((_WORD *)v37 - 1);
      v37 -= 2;
      *((_WORD *)v46 - 1) = v48;
      v46 -= 2;
    }
    *((void *)this + 7) = v46;
    *((void *)this + 8) = v38;
    *((void *)this + 9) = v47;
    if (v39) {
      operator delete(v39);
    }
  }
  else
  {
    *(_WORD *)CFRange v37 = *a4;
    unsigned int v38 = v37 + 2;
  }
  unint64_t v49 = *((void *)this + 12);
  *((void *)this + 8) = v38;
  unint64_t v50 = *((void *)this + 11);
  if (v50 >= v49)
  {
    uint64_t v53 = *((void *)this + 10);
    uint64_t v54 = (uint64_t)(v50 - v53) >> 5;
    unint64_t v55 = v54 + 1;
    if ((unint64_t)(v54 + 1) >> 59) {
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v56 = v49 - v53;
    if (v56 >> 4 > v55) {
      unint64_t v55 = v56 >> 4;
    }
    if ((unint64_t)v56 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v57 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v57 = v55;
    }
    if (v57) {
      uint64_t v58 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::segment_data<double>>>((uint64_t)this + 96, v57);
    }
    else {
      uint64_t v58 = 0;
    }
    double v59 = (CGSize *)&v58[32 * v54];
    CTFontRef v60 = &v58[32 * v57];
    CGSize size = a5->size;
    *double v59 = (CGSize)a5->origin;
    v59[1] = size;
    uint64_t v52 = (char *)&v59[2];
    long long v63 = (char *)*((void *)this + 10);
    long long v62 = (char *)*((void *)this + 11);
    if (v62 != v63)
    {
      do
      {
        CGSize v64 = (CGSize)*((_OWORD *)v62 - 1);
        v59[-2] = *((CGSize *)v62 - 2);
        v59[-1] = v64;
        v59 -= 2;
        v62 -= 32;
      }
      while (v62 != v63);
      long long v62 = (char *)*((void *)this + 10);
    }
    *((void *)this + 10) = v59;
    *((void *)this + 11) = v52;
    *((void *)this + 12) = v60;
    if (v62) {
      operator delete(v62);
    }
  }
  else
  {
    CGSize v51 = a5->size;
    *(CGPoint *)unint64_t v50 = a5->origin;
    *(CGSize *)(v50 + 16) = v51;
    uint64_t v52 = (char *)(v50 + 32);
  }
  *((void *)this + 11) = v52;
}

void TSWPCoreTextTypesetter::pFilterEmphasisMarksForRuby(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = a3[55];
  uint64_t v3 = a3[56];
  if (v3 != v4)
  {
    uint64_t v6 = 0;
    unsigned int v7 = 0;
    do
    {
      uint64_t v8 = v4 + 200 * v6;
      uint64_t v9 = *(void *)(v8 + 80);
      uint64_t v10 = *(void *)(v8 + 88);
      unint64_t v11 = (void *)(v8 + 80);
      uint64_t v12 = v10 - v9;
      if (v12)
      {
        unsigned int v58 = v7;
        uint64_t v13 = v12 >> 5;
        double v59 = v11;
        do
        {
          unint64_t v14 = v13 - 1;
          uint64_t v15 = a3[28];
          if (a3[29] != v15)
          {
            uint64_t v16 = 0;
            uint64_t v17 = *v11 + 32 * v14;
            CGFloat v18 = *(double *)(v17 + 8);
            double v19 = *(double *)v17 + *(double *)(a3[24] + 8);
            CGFloat v21 = *(double *)(v17 + 16);
            CGFloat v20 = *(double *)(v17 + 24);
            unsigned int v22 = 1;
            while (1)
            {
              uint64_t v23 = v15 + 48 * v16;
              v61.size.double width = CTLineGetTypographicBounds(*(CTLineRef *)v23, 0, 0, 0);
              v61.origin.CGFloat x = *(CGFloat *)(v23 + 8);
              v61.origin.CGFloat y = 0.0;
              v61.size.CGFloat height = 1.0;
              v60.origin.CGFloat x = v19;
              v60.origin.CGFloat y = v18;
              v60.size.double width = v21;
              v60.size.CGFloat height = v20;
              if (CGRectIntersectsRect(v60, v61)) {
                break;
              }
              uint64_t v16 = v22;
              uint64_t v15 = a3[28];
              if (0xAAAAAAAAAAAAAAABLL * ((a3[29] - v15) >> 4) <= v22++) {
                goto LABEL_26;
              }
            }
            uint64_t v25 = a3[55];
            uint64_t v26 = v25 + 200 * v6;
            uint64_t v29 = *(unsigned char **)(v26 + 40);
            unint64_t v28 = (void *)(v26 + 40);
            uint64_t v27 = v29;
            uint64_t v30 = *(v28 - 1);
            if (v14 < (uint64_t)&v29[-v30] >> 3)
            {
              uint64_t v31 = v30 + 8 * v14;
              double v32 = (unsigned char *)(v30 + 8 * v13);
              int64_t v33 = v27 - v32;
              if (v27 != v32) {
                memmove((void *)(v30 + 8 * v14), v32, v27 - v32);
              }
              *unint64_t v28 = v31 + v33;
            }
            uint64_t v34 = v25 + 200 * v6;
            CFRange v37 = *(unsigned char **)(v34 + 64);
            unint64_t v36 = (void *)(v34 + 64);
            uint64_t v35 = v37;
            uint64_t v38 = *(v36 - 1);
            if (v14 < (uint64_t)&v37[-v38] >> 1)
            {
              uint64_t v39 = v38 + 2 * v14;
              uint64_t v40 = (unsigned char *)(v38 + 2 * v13);
              int64_t v41 = v35 - v40;
              if (v35 != v40) {
                memmove((void *)(v38 + 2 * v14), v40, v35 - v40);
              }
              *unint64_t v36 = v39 + v41;
            }
            uint64_t v42 = v25 + 200 * v6;
            NSRange v45 = *(unsigned char **)(v42 + 88);
            uint64_t v44 = (void *)(v42 + 88);
            unint64_t v43 = v45;
            uint64_t v46 = *(v44 - 1);
            if (v14 < (uint64_t)&v45[-v46] >> 5)
            {
              uint64_t v47 = v46 + 32 * v14;
              __int16 v48 = (unsigned char *)(v46 + 32 * v13);
              int64_t v49 = v43 - v48;
              if (v43 != v48) {
                memmove((void *)(v46 + 32 * v14), v48, v43 - v48);
              }
              *uint64_t v44 = v47 + v49;
            }
            uint64_t v50 = v25 + 200 * v6;
            uint64_t v53 = *(unsigned char **)(v50 + 112);
            uint64_t v52 = (void *)(v50 + 112);
            CGSize v51 = v53;
            uint64_t v54 = *(v52 - 1);
            unint64_t v11 = v59;
            if (v14 < (uint64_t)&v53[-v54] >> 4)
            {
              uint64_t v55 = v54 + 16 * v14;
              uint64_t v56 = (unsigned char *)(v54 + 16 * v13);
              int64_t v57 = v51 - v56;
              if (v51 != v56) {
                memmove((void *)(v54 + 16 * v14), v56, v51 - v56);
              }
              *uint64_t v52 = v55 + v57;
            }
          }
LABEL_26:
          --v13;
        }
        while (v14);
        uint64_t v4 = a3[55];
        uint64_t v3 = a3[56];
        unsigned int v7 = v58;
      }
      uint64_t v6 = ++v7;
    }
    while (0x8F5C28F5C28F5C29 * ((v3 - v4) >> 3) > v7);
  }
}

void TSWPCoreTextTypesetter::pAddHiddenDeletionForLineFragment(TSWPCoreTextTypesetter *this, TSWPLineFragment *a2, TSUColor *a3, const TSWPLineRef *a4, double a5)
{
  uint64_t v9 = +[TSWPRenderer invisiblesFont];
  v19[0] = 0x100000006;
  v19[1] = 0;
  CGColorRef color = 0;
  CFTypeRef cf = v9;
  *(_OWORD *)unsigned int v22 = 0u;
  *(_OWORD *)uint64_t v23 = 0u;
  long long v24 = 0u;
  *(_OWORD *)uint64_t v25 = 0u;
  *(_OWORD *)uint64_t v26 = 0u;
  long long v27 = 0u;
  *(_OWORD *)TSWPRangeVector __p = 0u;
  long long v29 = 0u;
  long long v10 = *MEMORY[0x263F00148];
  long long v30 = 0u;
  long long v31 = v10;
  char v32 = 0;
  CGColorRetain(0);
  if (v9) {
    CFRetain(v9);
  }
  if (a3)
  {
    unint64_t v11 = (CGColor *)[(TSUColor *)a3 CGColor];
    CGColorRetain(v11);
    CGColorRelease(color);
    CGColorRef color = v11;
  }
  CGRect BoundingRectsForGlyphs = CTFontGetBoundingRectsForGlyphs(v9, kCTFontOrientationDefault, word_26AB70590, 0, 1);
  CGRect v18 = BoundingRectsForGlyphs;
  double v12 = a5 + *(double *)&qword_26AB70578 * -0.5;
  if ((*((unsigned char *)a2 + 25) & 0x10) != 0)
  {
    double v13 = -*((double *)a4 + 1);
    BOOL v14 = v12 < v13;
  }
  else
  {
    double v13 = *((double *)a2 + 8) - *((double *)a4 + 1) - *(double *)&qword_26AB70578;
    BOOL v14 = v13 < v12;
  }
  if (v14) {
    double v12 = v13;
  }
  v17.CGFloat x = v12;
  v17.CGFloat y = BoundingRectsForGlyphs.size.height * -0.5;
  TSWPAdornments::add((TSWPAdornments *)v19, 0, &v17, word_26AB70590, &v18);
  if ((void *)v27 != v26[1])
  {
    unint64_t v15 = *((void *)a2 + 56);
    if (v15 >= *((void *)a2 + 57))
    {
      uint64_t v16 = std::vector<TSWPAdornments>::__push_back_slow_path<TSWPAdornments const&>((uint64_t *)a2 + 55, (const TSWPAdornments *)v19);
    }
    else
    {
      TSWPAdornments::TSWPAdornments(*((TSWPAdornments **)a2 + 56), (const TSWPAdornments *)v19);
      uint64_t v16 = v15 + 200;
      *((void *)a2 + 56) = v15 + 200;
    }
    *((void *)a2 + 56) = v16;
  }
  CGColorRelease(color);
  if (cf) {
    CFRelease(cf);
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v26[1])
  {
    *(void **)&long long v27 = v26[1];
    operator delete(v26[1]);
  }
  if (v25[0])
  {
    v25[1] = v25[0];
    operator delete(v25[0]);
  }
  if (v23[1])
  {
    *(void **)&long long v24 = v23[1];
    operator delete(v23[1]);
  }
  if (v22[0])
  {
    v22[1] = v22[0];
    operator delete(v22[0]);
  }
}

void sub_223765024(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, CGColorRef a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,void *__p)
{
  *(void *)(v32 + 448) = v33;
  TSWPAdornments::~TSWPAdornments(&a16);
  _Unwind_Resume(a1);
}

void TSWPCoreTextTypesetter::pAddHiddenDeletionForLineFragment(id *this, TSWPLineFragment *a2, TSUColor *a3, uint64_t a4)
{
  CFIndex v6 = [this[8] charIndexMappedFromStorage:a4];
  uint64_t v7 = *((void *)a2 + 24);
  uint64_t v8 = *(const void **)v7;
  unint64_t v11 = v8;
  long long v12 = *(_OWORD *)(v7 + 8);
  long long v13 = *(_OWORD *)(v7 + 24);
  int v14 = *(_DWORD *)(v7 + 40);
  if (v8) {
    CFRetain(v8);
  }
  OffsetForStringIndeCGFloat x = CTLineGetOffsetForStringIndex((CTLineRef)v8, v6, 0);
  TSWPCoreTextTypesetter::pAddHiddenDeletionForLineFragment(v10, a2, a3, (const TSWPLineRef *)&v11, OffsetForStringIndex);
  if (v8) {
    CFRelease(v8);
  }
}

void sub_223765138(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

double TSWPMeasureTextualAttachment(TSWPTypesetterAttachmentMap *a1)
{
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  if ([(TSWPTypesetterAttachmentMap *)a1 lineRef]) {
    return CTLineGetTypographicBounds([(TSWPTypesetterAttachmentMap *)a1 lineRef], (CGFloat *)&v3, (CGFloat *)&v4, 0);
  }
  else {
    return 0.0;
  }
}

CFTypeRef std::vector<TSWPLineRef>::__construct_one_at_end[abi:ne180100]<TSWPLineRef const&>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  CFTypeRef result = *(CFTypeRef *)a2;
  *(void *)uint64_t v3 = *(void *)a2;
  *(_OWORD *)(v3 + 8) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(v3 + 24) = *(_OWORD *)(a2 + 24);
  *(_DWORD *)(v3 + 40) = *(_DWORD *)(a2 + 40);
  if (result) {
    CFTypeRef result = CFRetain(result);
  }
  *(void *)(a1 + 8) = v3 + 48;
  return result;
}

void sub_223765208(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<TSWPLineRef>,std::reverse_iterator<TSWPLineRef*>,std::reverse_iterator<TSWPLineRef*>,std::reverse_iterator<TSWPLineRef*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v17 = a6;
  *((void *)&v17 + 1) = a7;
  long long v16 = v17;
  v14[0] = a1;
  v14[1] = &v16;
  _OWORD v14[2] = &v17;
  char v15 = 0;
  if (a3 == a5)
  {
    uint64_t v12 = a6;
  }
  else
  {
    uint64_t v9 = a3;
    do
    {
      unint64_t v11 = *(const void **)(v9 - 48);
      v9 -= 48;
      long long v10 = v11;
      *(void *)(v7 - 48) = v11;
      *(_OWORD *)(v7 - 40) = *(_OWORD *)(v9 + 8);
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(v9 + 24);
      *(_DWORD *)(v7 - 8) = *(_DWORD *)(v9 + 40);
      if (v11) {
        CFRetain(v10);
      }
      uint64_t v7 = *((void *)&v17 + 1) - 48;
      *((void *)&v17 + 1) -= 48;
    }
    while (v9 != a5);
    uint64_t v12 = v17;
  }
  char v15 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TSWPLineRef>,std::reverse_iterator<TSWPLineRef*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v14);
  return v12;
}

void sub_2237652D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TSWPLineRef>,std::reverse_iterator<TSWPLineRef*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<TSWPLineRef>,std::reverse_iterator<TSWPLineRef*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<TSWPLineRef>,std::reverse_iterator<TSWPLineRef*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1 = *(CFTypeRef **)(a1[2] + 8);
  uint64_t v2 = *(CFTypeRef **)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      std::allocator<TSWPLineRef>::destroy[abi:ne180100](v3, v1);
      v1 += 6;
    }
    while (v1 != v2);
  }
}

void std::__split_buffer<TSWPLineRef>::clear[abi:ne180100](void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 48;
    std::allocator<TSWPLineRef>::destroy[abi:ne180100](v4, (CFTypeRef *)(i - 48));
  }
}

uint64_t std::vector<TSWPAdornmentLine>::__push_back_slow_path<TSWPAdornmentLine const&>(uint64_t *a1, uint64_t a2)
{
  unint64_t v3 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 4);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0x333333333333333) {
    std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
  }
  if (0x999999999999999ALL * ((a1[2] - *a1) >> 4) > v4) {
    unint64_t v4 = 0x999999999999999ALL * ((a1[2] - *a1) >> 4);
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - *a1) >> 4) >= 0x199999999999999) {
    unint64_t v6 = 0x333333333333333;
  }
  else {
    unint64_t v6 = v4;
  }
  int v14 = a1 + 2;
  if (v6) {
    uint64_t v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TSWPAdornmentLine>>((uint64_t)(a1 + 2), v6);
  }
  else {
    uint64_t v7 = 0;
  }
  long long v10 = v7;
  unint64_t v11 = &v7[80 * v3];
  long long v13 = &v7[80 * v6];
  std::allocator<TSWPAdornmentLine>::construct[abi:ne180100]<TSWPAdornmentLine,TSWPAdornmentLine const&>((uint64_t)(a1 + 2), (uint64_t)v11, a2);
  uint64_t v12 = v11 + 80;
  std::vector<TSWPAdornmentLine>::__swap_out_circular_buffer(a1, &v10);
  uint64_t v8 = a1[1];
  std::__split_buffer<TSWPAdornmentLine>::~__split_buffer(&v10);
  return v8;
}

void sub_2237654B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TSWPAdornmentLine>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

id std::allocator<TSWPAdornmentLine>::construct[abi:ne180100]<TSWPAdornmentLine,TSWPAdornmentLine const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(void *)(a2 + 16) = *(void *)(a3 + 16);
  unint64_t v4 = *(CGColor **)(a3 + 24);
  *(void *)(a2 + 24) = v4;
  *(void *)(a2 + 32) = *(void *)(a3 + 32);
  *(void *)(a2 + 40) = *(void *)(a3 + 40);
  *(_DWORD *)(a2 + 48) = *(_DWORD *)(a3 + 48);
  *(void *)(a2 + 56) = *(void *)(a3 + 56);
  *(unsigned char *)(a2 + 64) = *(unsigned char *)(a3 + 64);
  *(void *)(a2 + 72) = *(void *)(a3 + 72);
  CGColorRetain(v4);
  unint64_t v5 = *(void **)(a2 + 72);

  return v5;
}

uint64_t std::vector<TSWPAdornmentLine>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<TSWPAdornmentLine>,std::reverse_iterator<TSWPAdornmentLine*>,std::reverse_iterator<TSWPAdornmentLine*>,std::reverse_iterator<TSWPAdornmentLine*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<TSWPAdornmentLine>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x333333333333334) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(80 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<TSWPAdornmentLine>,std::reverse_iterator<TSWPAdornmentLine*>,std::reverse_iterator<TSWPAdornmentLine*>,std::reverse_iterator<TSWPAdornmentLine*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  _OWORD v13[2] = &v16;
  char v14 = 0;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v9 = a3;
    do
    {
      v9 -= 80;
      std::allocator<TSWPAdornmentLine>::construct[abi:ne180100]<TSWPAdornmentLine,TSWPAdornmentLine const&>(a1, v7 - 80, v9);
      uint64_t v7 = *((void *)&v16 + 1) - 80;
      *((void *)&v16 + 1) -= 80;
    }
    while (v9 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TSWPAdornmentLine>,std::reverse_iterator<TSWPAdornmentLine*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

void sub_2237656C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TSWPAdornmentLine>,std::reverse_iterator<TSWPAdornmentLine*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<TSWPAdornmentLine>,std::reverse_iterator<TSWPAdornmentLine*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<TSWPAdornmentLine>,std::reverse_iterator<TSWPAdornmentLine*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1 = *(void *)(a1[2] + 8);
  uint64_t v2 = *(void *)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      std::allocator<TSWPAdornmentLine>::destroy[abi:ne180100](v3, v1);
      v1 += 80;
    }
    while (v1 != v2);
  }
}

void **std::__split_buffer<TSWPAdornmentLine>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<TSWPAdornmentLine>::clear[abi:ne180100](void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 80;
    std::allocator<TSWPAdornmentLine>::destroy[abi:ne180100](v4, i - 80);
  }
}

void ___ZL19TSWPPlaceholderFontv_block_invoke()
{
  if (!TSWPPlaceholderFont(void)::placeholderFont) {
    TSWPPlaceholderFont(void)::placeholderFont = (uint64_t)CTFontCreateUIFontForLanguage(kCTFontUIFontSystem, 1.0, 0);
  }
}

uint64_t ___ZL17iOSIsGreaterThan7v_block_invoke()
{
  uint64_t result = objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x263F1C5C0], "currentDevice"), "systemVersion"), "compare:options:", @"7.0.2", 64);
  iOSIsGreaterThan7(void)::uint64_t result = result == 1;
  return result;
}

void std::__shared_ptr_pointer<TSWPParagraphTypesetter *,std::shared_ptr<TSWPParagraphTypesetter>::__shared_ptr_default_delete<TSWPParagraphTypesetter,TSWPParagraphTypesetter>,std::allocator<TSWPParagraphTypesetter>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223CB8F20);
}

TSWPParagraphTypesetter *std::unique_ptr<TSWPParagraphTypesetter>::reset[abi:ne180100](TSWPParagraphTypesetter **a1, TSWPParagraphTypesetter *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    TSWPParagraphTypesetter::~TSWPParagraphTypesetter(result);
    JUMPOUT(0x223CB8F20);
  }
  return result;
}

uint64_t std::vector<TSWPUIAttachmentData>::__push_back_slow_path<TSWPUIAttachmentData const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = (a1[1] - *a1) >> 5;
  unint64_t v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) >> 59) {
    std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v6 = a1[2] - *a1;
  if (v6 >> 4 > v4) {
    unint64_t v4 = v6 >> 4;
  }
  if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v7 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v7 = v4;
  }
  long long v15 = a1 + 2;
  if (v7) {
    uint64_t v8 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::segment_data<double>>>((uint64_t)(a1 + 2), v7);
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v11 = v8;
  uint64_t v12 = &v8[32 * v3];
  char v14 = &v8[32 * v7];
  std::allocator<TSWPUIAttachmentData>::construct[abi:ne180100]<TSWPUIAttachmentData,TSWPUIAttachmentData const&>((uint64_t)(a1 + 2), (uint64_t)v12, a2);
  long long v13 = v12 + 32;
  std::vector<TSWPUIAttachmentData>::__swap_out_circular_buffer(a1, &v11);
  uint64_t v9 = a1[1];
  std::__split_buffer<TSWPUIAttachmentData>::~__split_buffer((uint64_t)&v11);
  return v9;
}

void sub_2237659C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TSWPUIAttachmentData>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

id std::allocator<TSWPUIAttachmentData>::construct[abi:ne180100]<TSWPUIAttachmentData,TSWPUIAttachmentData const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void **)a3;
  *(void *)a2 = *(void *)a3;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a3 + 8);
  *(void *)(a2 + 24) = *(void *)(a3 + 24);
  if (!v3)
  {
    uint64_t v5 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v6 = [NSString stringWithUTF8String:"TSWPUIAttachmentData::TSWPUIAttachmentData(const TSWPUIAttachmentData &)"];
    objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.h"), 65, @"invalid nil value for '%s'", "_attachment");
    uint64_t v3 = *(void **)a2;
  }

  return v3;
}

uint64_t std::vector<TSWPUIAttachmentData>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<TSWPUIAttachmentData>,std::reverse_iterator<TSWPUIAttachmentData*>,std::reverse_iterator<TSWPUIAttachmentData*>,std::reverse_iterator<TSWPUIAttachmentData*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<TSWPUIAttachmentData>,std::reverse_iterator<TSWPUIAttachmentData*>,std::reverse_iterator<TSWPUIAttachmentData*>,std::reverse_iterator<TSWPUIAttachmentData*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  _OWORD v13[2] = &v16;
  char v14 = 0;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v9 = a3;
    do
    {
      v9 -= 32;
      std::allocator<TSWPUIAttachmentData>::construct[abi:ne180100]<TSWPUIAttachmentData,TSWPUIAttachmentData const&>(a1, v7 - 32, v9);
      uint64_t v7 = *((void *)&v16 + 1) - 32;
      *((void *)&v16 + 1) -= 32;
    }
    while (v9 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TSWPUIAttachmentData>,std::reverse_iterator<TSWPUIAttachmentData*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

void sub_223765BC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TSWPUIAttachmentData>,std::reverse_iterator<TSWPUIAttachmentData*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<TSWPUIAttachmentData>,std::reverse_iterator<TSWPUIAttachmentData*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<TSWPUIAttachmentData>,std::reverse_iterator<TSWPUIAttachmentData*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  uint64_t v1 = (uint64_t *)a1[2];
  uint64_t v3 = *v1;
  uint64_t v2 = v1[1];
  uint64_t v14 = v3;
  uint64_t v15 = v2;
  uint64_t v16 = v3;
  uint64_t v17 = v2;
  uint64_t v4 = *a1;
  uint64_t v5 = (uint64_t *)a1[1];
  uint64_t v7 = *v5;
  uint64_t v6 = v5[1];
  uint64_t v9 = v7;
  uint64_t v10 = v6;
  uint64_t v11 = v7;
  uint64_t v12 = v6;
  std::__allocator_destroy[abi:ne180100]<std::allocator<TSWPUIAttachmentData>,std::reverse_iterator<std::reverse_iterator<TSWPUIAttachmentData*>>,std::reverse_iterator<std::reverse_iterator<TSWPUIAttachmentData*>>>(v4, (uint64_t)v13, (uint64_t)v8);
}

void std::__allocator_destroy[abi:ne180100]<std::allocator<TSWPUIAttachmentData>,std::reverse_iterator<std::reverse_iterator<TSWPUIAttachmentData*>>,std::reverse_iterator<std::reverse_iterator<TSWPUIAttachmentData*>>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  for (uint64_t i = *(id **)(a2 + 32); i != *(id **)(a3 + 32); *(void *)(a2 + 32) = i)
  {

    uint64_t i = (id *)(*(void *)(a2 + 32) + 32);
  }
}

uint64_t std::__split_buffer<TSWPUIAttachmentData>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__split_buffer<TSWPUIAttachmentData>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  while (1)
  {
    uint64_t v4 = *(void *)(a1 + 16);
    if (v4 == a2) {
      break;
    }
    uint64_t v5 = *(void **)(v4 - 32);
    *(void *)(a1 + 16) = v4 - 32;
  }
}

BOOL isUpwardFacingCJKCharacterInVerticalMode(UChar32 a1)
{
  unsigned int IntPropertyValue = u_getIntPropertyValue(a1, UCHAR_SCRIPT);
  BOOL result = 1;
  if (IntPropertyValue > 0x36 || ((1 << IntPropertyValue) & 0x40020008560020) == 0)
  {
    unsigned int v4 = IntPropertyValue - 73;
    if (v4 > 0x3A || ((1 << v4) & 0x400400100000003) == 0)
    {
      UBlockCode Code = ublock_getCode(a1);
      BOOL result = 0;
      switch(Code)
      {
        case UBLOCK_ARROWS:
        case UBLOCK_ENCLOSED_ALPHANUMERICS:
        case UBLOCK_BOX_DRAWING:
        case UBLOCK_BLOCK_ELEMENTS:
        case UBLOCK_GEOMETRIC_SHAPES:
        case UBLOCK_MISCELLANEOUS_SYMBOLS:
        case UBLOCK_DINGBATS:
        case UBLOCK_CJK_RADICALS_SUPPLEMENT:
        case UBLOCK_CJK_SYMBOLS_AND_PUNCTUATION:
        case UBLOCK_HIRAGANA:
        case UBLOCK_KATAKANA:
        case UBLOCK_BOPOMOFO:
        case UBLOCK_HANGUL_COMPATIBILITY_JAMO:
        case UBLOCK_BOPOMOFO_EXTENDED:
        case UBLOCK_ENCLOSED_CJK_LETTERS_AND_MONTHS:
        case UBLOCK_CJK_COMPATIBILITY:
        case UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A:
        case UBLOCK_CJK_UNIFIED_IDEOGRAPHS:
        case UBLOCK_YI_SYLLABLES:
        case UBLOCK_YI_RADICALS:
        case UBLOCK_HANGUL_SYLLABLES:
        case UBLOCK_LOW_SURROGATES:
        case UBLOCK_CJK_COMPATIBILITY_IDEOGRAPHS:
        case UBLOCK_CJK_COMPATIBILITY_FORMS:
        case UBLOCK_HALFWIDTH_AND_FULLWIDTH_FORMS:
        case UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B:
        case UBLOCK_CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT:
        case UBLOCK_SUPPLEMENTAL_ARROWS_A:
        case UBLOCK_SUPPLEMENTAL_ARROWS_B:
        case UBLOCK_KATAKANA_PHONETIC_EXTENSIONS:
        case UBLOCK_MISCELLANEOUS_SYMBOLS_AND_ARROWS:
        case UBLOCK_TAI_XUAN_JING_SYMBOLS:
          goto LABEL_7;
        case UBLOCK_MATHEMATICAL_OPERATORS:
        case UBLOCK_MISCELLANEOUS_TECHNICAL:
        case UBLOCK_CONTROL_PICTURES:
        case UBLOCK_OPTICAL_CHARACTER_RECOGNITION:
        case UBLOCK_BRAILLE_PATTERNS:
        case UBLOCK_KANGXI_RADICALS:
        case UBLOCK_IDEOGRAPHIC_DESCRIPTION_CHARACTERS:
        case UBLOCK_KANBUN:
        case UBLOCK_HIGH_SURROGATES:
        case UBLOCK_HIGH_PRIVATE_USE_SURROGATES:
        case UBLOCK_PRIVATE_USE_AREA:
        case UBLOCK_ALPHABETIC_PRESENTATION_FORMS:
        case UBLOCK_ARABIC_PRESENTATION_FORMS_A:
        case UBLOCK_COMBINING_HALF_MARKS:
        case UBLOCK_SMALL_FORM_VARIANTS:
        case UBLOCK_ARABIC_PRESENTATION_FORMS_B:
        case UBLOCK_SPECIALS:
        case UBLOCK_OLD_ITALIC:
        case UBLOCK_GOTHIC:
        case UBLOCK_DESERET:
        case UBLOCK_BYZANTINE_MUSICAL_SYMBOLS:
        case UBLOCK_MUSICAL_SYMBOLS:
        case UBLOCK_MATHEMATICAL_ALPHANUMERIC_SYMBOLS:
        case UBLOCK_TAGS:
        case UBLOCK_CYRILLIC_SUPPLEMENT:
        case UBLOCK_TAGALOG:
        case UBLOCK_HANUNOO:
        case UBLOCK_BUHID:
        case UBLOCK_TAGBANWA:
        case UBLOCK_MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A:
        case UBLOCK_MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B:
        case UBLOCK_SUPPLEMENTAL_MATHEMATICAL_OPERATORS:
        case UBLOCK_VARIATION_SELECTORS:
        case UBLOCK_SUPPLEMENTARY_PRIVATE_USE_AREA_A:
        case UBLOCK_SUPPLEMENTARY_PRIVATE_USE_AREA_B:
        case UBLOCK_LIMBU:
        case UBLOCK_TAI_LE:
        case UBLOCK_KHMER_SYMBOLS:
        case UBLOCK_PHONETIC_EXTENSIONS:
        case UBLOCK_YIJING_HEXAGRAM_SYMBOLS:
        case UBLOCK_LINEAR_B_SYLLABARY:
        case UBLOCK_LINEAR_B_IDEOGRAMS:
        case UBLOCK_AEGEAN_NUMBERS:
        case UBLOCK_UGARITIC:
        case UBLOCK_SHAVIAN:
        case UBLOCK_OSMANYA:
        case UBLOCK_CYPRIOT_SYLLABARY:
          return result;
        default:
          if ((Code - 145) <= 0x1A && ((1 << (Code + 111)) & 0x6000201) != 0 || Code == UBLOCK_MONGOLIAN) {
LABEL_7:
          }
            BOOL result = a1 != 12540 && a1 != 65392;
          break;
      }
    }
  }
  return result;
}

uint64_t TSWPIsPotentialTateChuYokoCharacter(uint64_t a1)
{
  if (TSWPIsPotentialTateChuYokoCharacter::s_predicate != -1) {
    dispatch_once(&TSWPIsPotentialTateChuYokoCharacter::s_predicate, &__block_literal_global_78);
  }
  uint64_t v2 = (void *)TSWPIsPotentialTateChuYokoCharacter::_tateChuYokoCharacterSet;

  return [v2 longCharacterIsMember:a1];
}

uint64_t __TSWPIsPotentialTateChuYokoCharacter_block_invoke()
{
  id v0 = objc_alloc_init(MEMORY[0x263F089C0]);
  objc_msgSend(v0, "addCharactersInRange:", 48, 10);
  objc_msgSend(v0, "addCharactersInRange:", 65296, 10);
  objc_msgSend(v0, "addCharactersInRange:", 8352, 18);
  objc_msgSend(v0, "addCharactersInRange:", 36, 1);
  objc_msgSend(v0, "addCharactersInRange:", 162, 1);
  objc_msgSend(v0, "addCharactersInRange:", 163, 1);
  objc_msgSend(v0, "addCharactersInRange:", 164, 1);
  objc_msgSend(v0, "addCharactersInRange:", 165, 1);
  objc_msgSend(v0, "addCharactersInRange:", 2546, 1);
  objc_msgSend(v0, "addCharactersInRange:", 2547, 1);
  objc_msgSend(v0, "addCharactersInRange:", 3647, 1);
  objc_msgSend(v0, "addCharactersInRange:", 6107, 1);
  objc_msgSend(v0, "addCharactersInRange:", 65020, 1);
  objc_msgSend(v0, "addCharactersInRange:", 46, 1);
  objc_msgSend(v0, "addCharactersInRange:", 44, 1);
  objc_msgSend(v0, "addCharactersInRange:", 39, 1);
  objc_msgSend(v0, "addCharactersInRange:", 45, 1);
  objc_msgSend(v0, "addCharactersInRange:", 47, 1);
  objc_msgSend(v0, "addCharactersInRange:", 40, 1);
  objc_msgSend(v0, "addCharactersInRange:", 41, 1);
  objc_msgSend(v0, "addCharactersInRange:", 123, 1);
  objc_msgSend(v0, "addCharactersInRange:", 125, 1);
  objc_msgSend(v0, "addCharactersInRange:", 91, 1);
  uint64_t result = objc_msgSend(v0, "addCharactersInRange:", 93, 1);
  TSWPIsPotentialTateChuYokoCharacter::_tateChuYokoCharacterSet = (uint64_t)v0;
  return result;
}

uint64_t TSWPNormalWidthCharacterForCharacter(uint64_t result)
{
  if ((result - 65296) < 0xA) {
    goto LABEL_2;
  }
  if ((int)result > 65504)
  {
    if (result == 65505)
    {
      LOWORD(result) = 163;
    }
    else if (result == 65509)
    {
      LOWORD(result) = 165;
    }
  }
  else
  {
    if (result == 65284)
    {
LABEL_2:
      LOWORD(result) = result + 288;
      return (unsigned __int16)result;
    }
    if (result == 65504) {
      LOWORD(result) = 162;
    }
  }
  return (unsigned __int16)result;
}

uint64_t TSWPFullWidthCharacterForCharacter(uint64_t result)
{
  if ((result - 48) < 0xA) {
    goto LABEL_2;
  }
  if ((int)result > 162)
  {
    if (result == 163)
    {
      LOWORD(result) = -31;
    }
    else if (result == 165)
    {
      LOWORD(result) = -27;
    }
  }
  else
  {
    if (result == 36)
    {
LABEL_2:
      LOWORD(result) = result - 288;
      return (unsigned __int16)result;
    }
    if (result == 162) {
      LOWORD(result) = -32;
    }
  }
  return (unsigned __int16)result;
}

void TSWPFillVerticalFacingRangesFromBuffer(uint64_t a1, unint64_t a2, void *a3)
{
  if (a2)
  {
    uint64_t v6 = 0;
    unsigned int v7 = 0;
    unint64_t v43 = a3 + 2;
    do
    {
      uint64_t v8 = *(unsigned __int16 *)(a1 + 2 * v6);
      int v9 = v8 & 0xFC00;
      BOOL v11 = v9 == 55296 || v9 == 56320;
      unint64_t v12 = v7 + 1;
      if (v12 >= a2 || !v11)
      {
        ++v7;
      }
      else
      {
        int v14 = *(unsigned __int16 *)(a1 + 2 * v12);
        BOOL v15 = v9 == 55296;
        if (v9 == 55296) {
          int v16 = *(unsigned __int16 *)(a1 + 2 * v6);
        }
        else {
          int v16 = v14;
        }
        if (!v15) {
          int v14 = *(unsigned __int16 *)(a1 + 2 * v6);
        }
        uint64_t v8 = (v14 + (v16 << 10) - 56613888);
        v7 += 2;
      }
      if (isUpwardFacingCJKCharacterInVerticalMode(v8)) {
        int v17 = 1;
      }
      else {
        int v17 = TSWPIsPotentialTateChuYokoCharacter(v8);
      }
      uint64_t v18 = v43;
      double v19 = (char *)*a3;
      CGFloat v20 = (char *)a3[1];
      uint64_t v21 = (uint64_t)&v20[-*a3] / 24;
      if (v20 == (char *)*a3)
      {
        if ((unint64_t)v20 >= *v43)
        {
          unint64_t v22 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*v43 - (void)v19) >> 3);
          uint64_t v23 = 2 * v22;
          if (2 * v22 <= v21 + 1) {
            uint64_t v23 = v21 + 1;
          }
          if (v22 >= 0x555555555555555) {
            unint64_t v24 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v24 = v23;
          }
          uint64_t v25 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>((uint64_t)v43, v24);
          long long v27 = &v25[24 * v21];
          *(void *)long long v27 = 0;
          *((void *)v27 + 1) = 0;
          v27[16] = v17;
          long long v29 = (char *)*a3;
          unint64_t v28 = (char *)a3[1];
          long long v30 = v27;
          if (v28 != (char *)*a3)
          {
            do
            {
              long long v31 = *(_OWORD *)(v28 - 24);
              *((void *)v30 - 1) = *((void *)v28 - 1);
              *(_OWORD *)(v30 - 24) = v31;
              v30 -= 24;
              v28 -= 24;
            }
            while (v28 != v29);
            unint64_t v28 = (char *)*a3;
          }
          CGFloat v20 = v27 + 24;
          *a3 = v30;
          a3[1] = v27 + 24;
          a3[2] = &v25[24 * v26];
          if (v28) {
            operator delete(v28);
          }
          uint64_t v18 = v43;
        }
        else
        {
          *(void *)CGFloat v20 = 0;
          *((void *)v20 + 1) = 0;
          v20[16] = v17;
          v20 += 24;
        }
        a3[1] = v20;
        double v19 = (char *)*a3;
        uint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v20[-*a3] >> 3);
      }
      if (v19[24 * v21 - 8] == v17)
      {
        *(void *)&v19[24 * v21 - 16] = v7 - *(void *)&v19[24 * v21 - 24];
      }
      else
      {
        uint64_t v32 = v7 - v6;
        if ((unint64_t)v20 >= *v18)
        {
          if ((unint64_t)(v21 + 1) > 0xAAAAAAAAAAAAAAALL) {
            abort();
          }
          unint64_t v34 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*v18 - (void)v19) >> 3);
          uint64_t v35 = 2 * v34;
          if (2 * v34 <= v21 + 1) {
            uint64_t v35 = v21 + 1;
          }
          if (v34 >= 0x555555555555555) {
            unint64_t v36 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v36 = v35;
          }
          if (v36) {
            CFRange v37 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>((uint64_t)v18, v36);
          }
          else {
            CFRange v37 = 0;
          }
          uint64_t v38 = &v37[24 * v21];
          *(void *)uint64_t v38 = v6;
          *((void *)v38 + 1) = v32;
          v38[16] = v17;
          uint64_t v40 = (char *)*a3;
          uint64_t v39 = (char *)a3[1];
          int64_t v41 = v38;
          if (v39 != (char *)*a3)
          {
            do
            {
              long long v42 = *(_OWORD *)(v39 - 24);
              *((void *)v41 - 1) = *((void *)v39 - 1);
              *(_OWORD *)(v41 - 24) = v42;
              v41 -= 24;
              v39 -= 24;
            }
            while (v39 != v40);
            uint64_t v39 = (char *)*a3;
          }
          uint64_t v33 = v38 + 24;
          *a3 = v41;
          a3[1] = v38 + 24;
          a3[2] = &v37[24 * v36];
          if (v39) {
            operator delete(v39);
          }
        }
        else
        {
          *(void *)CGFloat v20 = v6;
          *((void *)v20 + 1) = v32;
          uint64_t v33 = v20 + 24;
          v20[16] = v17;
        }
        a3[1] = v33;
      }
      uint64_t v6 = v7;
    }
    while (v7 < a2);
  }
}

uint64_t TSWPScriptForCharacter(UChar32 a1)
{
  UBlockCode Code = ublock_getCode(a1);
  uint64_t result = 0;
  if (Code <= UBLOCK_CJK_SYMBOLS_AND_PUNCTUATION)
  {
    switch(Code)
    {
      case UBLOCK_BASIC_LATIN:
      case UBLOCK_LATIN_1_SUPPLEMENT:
      case UBLOCK_LATIN_EXTENDED_A:
      case UBLOCK_LATIN_EXTENDED_B:
        return 2;
      case UBLOCK_IPA_EXTENSIONS:
      case UBLOCK_SPACING_MODIFIER_LETTERS:
      case UBLOCK_COMBINING_DIACRITICAL_MARKS:
      case UBLOCK_GREEK:
      case UBLOCK_ARMENIAN:
        return result;
      case UBLOCK_CYRILLIC:
        return 9;
      case UBLOCK_HEBREW:
        return 8;
      case UBLOCK_ARABIC:
        return 7;
      default:
        if (Code == UBLOCK_HANGUL_JAMO) {
          return 10;
        }
        if (Code != UBLOCK_LATIN_EXTENDED_ADDITIONAL) {
          return result;
        }
        break;
    }
    return 2;
  }
  if (Code <= UBLOCK_MATHEMATICAL_ALPHANUMERIC_SYMBOLS)
  {
    switch(Code)
    {
      case UBLOCK_HIRAGANA:
        uint64_t result = 3;
        break;
      case UBLOCK_KATAKANA:
        return 4;
      case UBLOCK_BOPOMOFO:
      case UBLOCK_BOPOMOFO_EXTENDED:
        uint64_t result = 5;
        break;
      case UBLOCK_HANGUL_COMPATIBILITY_JAMO:
      case UBLOCK_HANGUL_SYLLABLES:
        return 10;
      case UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A:
      case UBLOCK_CJK_UNIFIED_IDEOGRAPHS:
        return 6;
      default:
        return result;
    }
    return result;
  }
  if ((Code - 148) < 2) {
    return 2;
  }
  if (Code == UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B) {
    return 6;
  }
  if (Code == UBLOCK_KATAKANA_PHONETIC_EXTENSIONS) {
    return 4;
  }
  return result;
}

uint64_t TSWPBackgroundInit()
{
  if ([MEMORY[0x263F08B88] isMainThread])
  {
    id v0 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v1 = [NSString stringWithUTF8String:"void TSWPBackgroundInit()"];
    objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", v1, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPUtilities.mm"), 442, @"TSWPBackgroundInit should be called on a background thread");
  }
  uint64_t v2 = +[TSWPLoadableFonts sharedInstance];

  return [(TSWPLoadableFonts *)v2 backgroundLoadAll];
}

BOOL TSWPFontNameIsValid(uint64_t a1)
{
  BOOL v1 = a1;
  if (a1)
  {
    uint64_t v2 = (const __CTFont *)TSWPCreateFontWithNameAttributesAndWeight(a1, 0, 12.0, *MEMORY[0x263F1D338]);
    if (v2)
    {
      uint64_t v3 = v2;
      CFStringRef v4 = CTFontCopyPostScriptName(v2);
      if (v4)
      {
        CFStringRef v5 = v4;
        BOOL v1 = CFEqual((CFTypeRef)v1, v4) != 0;
        CFRelease(v3);
        uint64_t v3 = (const __CTFont *)v5;
      }
      else
      {
        BOOL v1 = 0;
      }
      CFRelease(v3);
    }
    else
    {
      return 0;
    }
  }
  return v1;
}

uint64_t TSWPCreateFontWithName(uint64_t a1, double a2)
{
  return TSWPCreateFontWithNameAttributesAndWeight(a1, 0, a2, *MEMORY[0x263F1D338]);
}

uint64_t TSWPPageBreakString()
{
  return objc_msgSend(NSString, "stringWithFormat:", @"%C", 5);
}

uint64_t TSWPLineBreakString()
{
  return objc_msgSend(NSString, "stringWithFormat:", @"%C", 8232);
}

const __CTFont *TSWPCreateFontWithFamilyName(uint64_t a1, int a2, int a3, CGFloat a4)
{
  v13[1] = *MEMORY[0x263EF8340];
  if (a2) {
    int v5 = 2;
  }
  else {
    int v5 = 0;
  }
  CTFontSymbolicTraits v6 = v5 | a3;
  uint64_t v12 = *MEMORY[0x263F03A80];
  v13[0] = a1;
  unsigned int v7 = CTFontDescriptorCreateWithAttributes((CFDictionaryRef)[NSDictionary dictionaryWithObjects:v13 forKeys:&v12 count:1]);
  uint64_t v8 = CTFontCreateWithFontDescriptor(v7, a4, 0);
  CFRelease(v7);
  if ((CTFontGetSymbolicTraits(v8) & 3) != v6)
  {
    if (v8)
    {
      CTFontRef CopyWithSymbolicTraits = CTFontCreateCopyWithSymbolicTraits(v8, a4, 0, v6, 3u);
      if (CopyWithSymbolicTraits)
      {
        CTFontRef v10 = CopyWithSymbolicTraits;
        CFRelease(v8);
        return v10;
      }
    }
  }
  return v8;
}

uint64_t TSWPCreateUIFontWithName(uint64_t result, double a2)
{
  if (result)
  {
    uint64_t v3 = result;
    [+[TSWPLoadableFonts sharedInstance] loadFontWithName:result];
    CFStringRef v4 = (void *)MEMORY[0x263F1C658];
    return [v4 fontWithName:v3 size:a2];
  }
  return result;
}

const __CTFont *TSWPFontCopyGraphicsFont()
{
  CTFontGetTypeID();
  uint64_t result = (const __CTFont *)TSUCFTypeCast();
  if (result)
  {
    return CTFontCopyGraphicsFont(result, 0);
  }
  return result;
}

const __CTFont *TSWPUIFontForCTFont(const __CTFont *result)
{
  if (result)
  {
    BOOL v1 = result;
    double Size = CTFontGetSize(result);
    uint64_t result = (const __CTFont *)[MEMORY[0x263F1C658] fontWithName:(id)CTFontCopyPostScriptName(v1) size:Size];
    if (!result)
    {
      uint64_t v3 = (void *)MEMORY[0x263F1C658];
      return (const __CTFont *)[v3 systemFontOfSize:Size];
    }
  }
  return result;
}

__CFString *TSWPFontPostScriptNameForFamilyName(void *a1)
{
  v11[1] = *MEMORY[0x263EF8340];
  uint64_t v10 = *MEMORY[0x263F03A80];
  v11[0] = a1;
  uint64_t v2 = CTFontDescriptorCreateWithAttributes((CFDictionaryRef)[NSDictionary dictionaryWithObjects:v11 forKeys:&v10 count:1]);
  uint64_t v3 = CTFontCreateWithFontDescriptor(v2, 0.0, 0);
  if (!v3)
  {
    uint64_t v8 = 0;
    if (!v2) {
      return v8;
    }
    goto LABEL_12;
  }
  CFStringRef v4 = v3;
  CFStringRef v5 = CTFontCopyFamilyName(v3);
  if (v5)
  {
    CFStringRef v6 = v5;
    if ([a1 isEqualToString:v5]
      && (unsigned int v7 = (__CFString *)CTFontCopyPostScriptName(v4)) != 0)
    {
      uint64_t v8 = v7;
    }
    else
    {
      uint64_t v8 = 0;
    }
    CFRelease(v6);
  }
  else
  {
    uint64_t v8 = 0;
  }
  CFRelease(v4);
  if (v2) {
LABEL_12:
  }
    CFRelease(v2);
  return v8;
}

CFStringRef TSWPFontNameWithFamilyName(uint64_t a1, int a2, int a3)
{
  CFStringRef v3 = (const __CFString *)a1;
  CFStringRef v4 = TSWPCreateFontWithFamilyName(a1, a2, a3, 12.0);
  if (v4)
  {
    CFStringRef v5 = v4;
    CFStringRef v3 = (id)CTFontCopyFullName(v4);
    CFRelease(v5);
  }
  return v3;
}

CFTypeRef TSWPFontFamilyNameForFontName(uint64_t a1)
{
  v8[1] = *MEMORY[0x263EF8340];
  if (!a1)
  {
    CFStringRef v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = [NSString stringWithUTF8String:"NSString *TSWPFontFamilyNameForFontName(NSString *)"];
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPUtilities.mm"), 716, @"invalid nil value for '%s'", "fontName");
    return 0;
  }
  uint64_t v7 = *MEMORY[0x263F03AE8];
  v8[0] = a1;
  BOOL v1 = CTFontDescriptorCreateWithAttributes((CFDictionaryRef)[NSDictionary dictionaryWithObjects:v8 forKeys:&v7 count:1]);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = v1;
  CFTypeRef v3 = (id)CTFontDescriptorCopyAttribute(v1, (CFStringRef)*MEMORY[0x263F03A80]);
  CFRelease(v2);
  return v3;
}

BOOL TSWPFontHasTraits(const __CTFont *a1, int a2)
{
  CTFontGetTypeID();
  CFTypeRef v3 = (const __CTFont *)TSUCFTypeCast();
  if (v3) {
    LODWORD(v3) = CTFontGetSymbolicTraits(v3);
  }
  return (a2 & ~v3) == 0;
}

BOOL TSWPFontIsBold(const __CTFont *a1)
{
  return TSWPFontHasTraits(a1, 2);
}

BOOL TSWPFontIsItalic(const __CTFont *a1)
{
  return TSWPFontHasTraits(a1, 1);
}

BOOL TSWPFontIsSymbolic(const __CTFont *a1)
{
  return TSWPFontHasTraits(a1, -1073741824);
}

uint64_t TSWPFontGetAttributes(uint64_t a1, uint64_t *a2, BOOL *a3, unsigned char *a4, CGFloat *a5)
{
  CTFontGetTypeID();
  uint64_t result = TSUCFTypeCast();
  if (result)
  {
    uint64_t v10 = (const __CTFont *)result;
    if (a5) {
      *a5 = CTFontGetSize((CTFontRef)result);
    }
    uint64_t result = CTFontGetSymbolicTraits(v10);
    *a3 = (result & 2) != 0;
    *a4 = result & 1;
    if (a2)
    {
      uint64_t result = (id)CTFontCopyFullName(v10);
LABEL_10:
      *a2 = result;
    }
  }
  else
  {
    if (a5) {
      *a5 = 0.0;
    }
    *a4 = 0;
    *a3 = 0;
    if (a2)
    {
      uint64_t result = 0;
      goto LABEL_10;
    }
  }
  return result;
}

void TSWPFontGetLineHeight()
{
  CTFontGetTypeID();
  id v0 = (const __CTFont *)TSUCFTypeCast();
  if (v0)
  {
    BOOL v1 = v0;
    CTFontGetAscent(v0);
    CTFontGetDescent(v1);
    CTFontGetLeading(v1);
  }
}

uint64_t TSWPFontFamilyNames()
{
  v18[1] = *MEMORY[0x263EF8340];
  uint64_t result = TSWPFontFamilyNames::fontNames;
  if (!TSWPFontFamilyNames::fontNames)
  {
    [+[TSWPLoadableFonts sharedInstance] loadAll];
    TSWPFontFamilyNames::fontNames = (uint64_t)objc_alloc_init(MEMORY[0x263EFF980]);
    uint64_t v17 = *MEMORY[0x263F039B8];
    v18[0] = MEMORY[0x263EFFA88];
    BOOL v1 = CTFontCollectionCreateFromAvailableFonts((CFDictionaryRef)[NSDictionary dictionaryWithObjects:v18 forKeys:&v17 count:1]);
    if (v1)
    {
      uint64_t v2 = v1;
      CFArrayRef MatchingFontDescriptors = CTFontCollectionCreateMatchingFontDescriptors(v1);
      if (MatchingFontDescriptors)
      {
        CFArrayRef v4 = MatchingFontDescriptors;
        long long v14 = 0u;
        long long v15 = 0u;
        long long v12 = 0u;
        long long v13 = 0u;
        uint64_t v5 = [(__CFArray *)MatchingFontDescriptors countByEnumeratingWithState:&v12 objects:v16 count:16];
        if (v5)
        {
          uint64_t v6 = v5;
          uint64_t v7 = *(void *)v13;
          CFStringRef v8 = (const __CFString *)*MEMORY[0x263F03A80];
          do
          {
            uint64_t v9 = 0;
            do
            {
              if (*(void *)v13 != v7) {
                objc_enumerationMutation(v4);
              }
              CFTypeRef v10 = CTFontDescriptorCopyAttribute(*(CTFontDescriptorRef *)(*((void *)&v12 + 1) + 8 * v9), v8);
              if (v10)
              {
                BOOL v11 = v10;
                [(id)TSWPFontFamilyNames::fontNames addObject:v10];
                CFRelease(v11);
              }
              ++v9;
            }
            while (v6 != v9);
            uint64_t v6 = [(__CFArray *)v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
          }
          while (v6);
        }
        CFRelease(v4);
      }
      CFRelease(v2);
    }
    [(id)TSWPFontFamilyNames::fontNames sortUsingSelector:sel_compare_];
    return TSWPFontFamilyNames::fontNames;
  }
  return result;
}

unint64_t TSWPMostCompatibleStringEncodingForFont()
{
  CTFontGetTypeID();
  id v0 = (const __CTFont *)TSUCFTypeCast();
  if (v0) {
    LODWORD(v0) = CTFontGetStringEncoding(v0);
  }

  return CFStringConvertEncodingToNSStringEncoding((CFStringEncoding)v0);
}

const __CTFont *TSWPCreateSubstituteFontForString(uint64_t a1, __CFString *a2)
{
  CFIndex v3 = [(__CFString *)a2 length];
  CTFontGetTypeID();
  uint64_t result = (const __CTFont *)TSUCFTypeCast();
  if (result)
  {
    v5.CFIndex location = 0;
    v5.CFIndex length = v3;
    return CTFontCreateForString(result, a2, v5);
  }
  return result;
}

uint64_t TSWPGlyphForChar(uint64_t a1, UniChar a2)
{
  UniChar characters = a2;
  CGGlyph glyphs = 0;
  CTFontGetTypeID();
  uint64_t v2 = (const __CTFont *)TSUCFTypeCast();
  BOOL GlyphsForCharacters = CTFontGetGlyphsForCharacters(v2, &characters, &glyphs, 1);
  CGGlyph v4 = glyphs;
  if (!GlyphsForCharacters) {
    return (CGGlyph)-1;
  }
  return v4;
}

CGFloat TSWPAdvancementForGlyph(uint64_t a1, CGGlyph a2)
{
  CGGlyph glyphs = a2;
  CTFontGetTypeID();
  uint64_t v2 = (const __CTFont *)TSUCFTypeCast();
  CTFontGetAdvancesForGlyphs(v2, kCTFontOrientationDefault, &glyphs, &advances, 1);
  return advances.width;
}

void *TSWPPropertyMapByResolvingFontSizeDeltaInPropertyMapAgainstStyle(void *a1, void *a2)
{
  [a1 floatValueForProperty:52];
  float v5 = v4;
  if (v4 == INFINITY) {
    return 0;
  }
  [a2 floatValueForProperty:17];
  if (v6 == INFINITY)
  {
    BOOL v11 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v12 = objc_msgSend(NSString, "stringWithUTF8String:", "TSSPropertyMap *TSWPPropertyMapByResolvingFontSizeDeltaInPropertyMapAgainstStyle(TSSPropertyMap *, TSSStyle *)");
    [v11 handleFailureInFunction:v12, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPUtilities.mm"), 896, @"Did not get fontSize property from style: %@", a2 file lineNumber description];
    return 0;
  }
  float v7 = v5 + v6;
  if (v7 < 9.0 || v7 > 288.0) {
    return 0;
  }
  uint64_t v9 = objc_msgSend(a1, "propertyMapByRemovingValuesForProperties:", +[TSSPropertySet propertySetWithProperty:](TSSPropertySet, "propertySetWithProperty:", 52));
  *(float *)&double v10 = v7;
  [v9 setFloatValue:17 forProperty:v10];
  return v9;
}

uint64_t TSWPParagraphBreakingCharacterSet()
{
  if (TSWPParagraphBreakingCharacterSet::sTSWPParagraphBreakingCharacterSetOnceToken != -1) {
    dispatch_once(&TSWPParagraphBreakingCharacterSet::sTSWPParagraphBreakingCharacterSetOnceToken, &__block_literal_global_26);
  }
  return TSWPParagraphBreakingCharacterSet::sParagraphBreakingCharacterSet;
}

uint64_t TSWPFullNameForCharacter(unsigned __int16 a1, int a2)
{
  if (a1 <= 0x2006u)
  {
    if (a1 <= 0x9Fu)
    {
      switch(a1)
      {
        case 4u:
          CFIndex v3 = (void *)TSWPBundle();
          if (a2) {
            float v4 = @"Section Breaks";
          }
          else {
            float v4 = @"Section Break";
          }
          goto LABEL_48;
        case 5u:
          CFIndex v3 = (void *)TSWPBundle();
          if (a2) {
            float v4 = @"Page Breaks";
          }
          else {
            float v4 = @"Page Break";
          }
          goto LABEL_48;
        case 6u:
        case 7u:
        case 8u:
          return 0;
        case 9u:
          CFIndex v3 = (void *)TSWPBundle();
          if (a2) {
            float v4 = @"Tabs";
          }
          else {
            float v4 = @"Tab";
          }
          goto LABEL_48;
        case 0xAu:
        case 0xBu:
        case 0xDu:
          goto LABEL_21;
        case 0xCu:
          CFIndex v3 = (void *)TSWPBundle();
          if (a2) {
            float v4 = @"Column Breaks";
          }
          else {
            float v4 = @"Column Break";
          }
          goto LABEL_48;
        default:
          if (a1 != 32) {
            return 0;
          }
          goto LABEL_13;
      }
    }
    if (a1 - 0x2000 < 7) {
      goto LABEL_13;
    }
    if (a1 == 160) {
      goto LABEL_29;
    }
    return 0;
  }
  if (a1 > 0x2028u)
  {
    if (a1 >= 0x3000u)
    {
      if (a1 != 12288)
      {
        if (a1 == 65532)
        {
          CFIndex v3 = (void *)TSWPBundle();
          if (a2) {
            float v4 = @"Attachments";
          }
          else {
            float v4 = @"Attachment";
          }
          goto LABEL_48;
        }
        if (a1 != 65279) {
          return 0;
        }
LABEL_29:
        CFIndex v3 = (void *)TSWPBundle();
        if (a2) {
          float v4 = @"Non Breaking Spaces";
        }
        else {
          float v4 = @"Non Breaking Space";
        }
        goto LABEL_48;
      }
    }
    else
    {
      if (a1 == 8233)
      {
LABEL_21:
        CFIndex v3 = (void *)TSWPBundle();
        if (a2) {
          float v4 = @"Paragraph Breaks";
        }
        else {
          float v4 = @"Paragraph Break";
        }
        goto LABEL_48;
      }
      if (a1 == 8239) {
        goto LABEL_29;
      }
      if (a1 != 8287) {
        return 0;
      }
    }
LABEL_13:
    CFIndex v3 = (void *)TSWPBundle();
    if (a2) {
      float v4 = @"Spaces";
    }
    else {
      float v4 = @"Space";
    }
    goto LABEL_48;
  }
  if (a1 - 8200 < 4) {
    goto LABEL_13;
  }
  if (a1 == 8199) {
    goto LABEL_29;
  }
  if (a1 != 8232) {
    return 0;
  }
  CFIndex v3 = (void *)TSWPBundle();
  if (a2) {
    float v4 = @"Line Breaks";
  }
  else {
    float v4 = @"Line Break";
  }
LABEL_48:

  return [v3 localizedStringForKey:v4 value:&stru_26D688A48 table:@"TSText"];
}

BOOL isDeletableWithoutCombining(UChar32 a1)
{
  UBlockCode Code = ublock_getCode(a1);
  return Code == UBLOCK_ARABIC_SUPPLEMENT || (Code - 11) < 2;
}

uint64_t IsWhitespaceCharacter(uint64_t theChar)
{
  if (IsWhitespaceCharacter::sIsWhitespaceCharacterDispatchOnceToken != -1) {
    dispatch_once(&IsWhitespaceCharacter::sIsWhitespaceCharacterDispatchOnceToken, &__block_literal_global_88_0);
  }
  if (CFCharacterSetIsLongCharacterMember((CFCharacterSetRef)IsWhitespaceCharacter::sWhitespaceCharacterSet, theChar)) {
    return 1;
  }
  LODWORD(result) = IsParagraphBreakingCharacter(theChar);
  if (theChar == 8232) {
    return 1;
  }
  else {
    return result;
  }
}

id __IsWhitespaceCharacter_block_invoke()
{
  id result = (id)[MEMORY[0x263F08708] whitespaceCharacterSet];
  IsWhitespaceCharacter::sWhitespaceCharacterSet = (uint64_t)result;
  return result;
}

BOOL IsSpecialCharacter(int a1)
{
  return a1 == 65532 || a1 == 14;
}

BOOL IsBreakingSpaceCharacter(UTF32Char theChar)
{
  CFCharacterSetRef v2 = (const __CFCharacterSet *)IsBreakingSpaceCharacter::sBreakingSpaceCharacterSet;
  if (!IsBreakingSpaceCharacter::sBreakingSpaceCharacterSet)
  {
    CFCharacterSetRef v2 = (const __CFCharacterSet *)(id)[MEMORY[0x263F08708] breakingSpaceCharacterSet];
    IsBreakingSpaceCharacter::sBreakingSpaceCharacterSet = (uint64_t)v2;
  }
  return CFCharacterSetIsLongCharacterMember(v2, theChar) != 0;
}

uint64_t IsWordBoundaryCharacter(uint64_t a1)
{
  if ((int)a1 <= 8211)
  {
    if (!a1 || a1 == 14) {
      return 1;
    }
  }
  else if (a1 == 8212 || a1 == 8232 || a1 == 65532)
  {
    return 1;
  }
  char v2 = IsParagraphBreakingCharacter(a1);
  if a1 == 8232 || (v2) {
    return 1;
  }
  CFIndex v3 = (void *)[MEMORY[0x263F08708] spaceCharacterSet];

  return [v3 longCharacterIsMember:a1];
}

BOOL KinsokuIllegalEndChar(UTF32Char theChar)
{
  if (KinsokuIllegalEndChar::sKinsokuIllegalEndCharDispatchOnceToken != -1) {
    dispatch_once(&KinsokuIllegalEndChar::sKinsokuIllegalEndCharDispatchOnceToken, &__block_literal_global_91);
  }
  return CFCharacterSetIsLongCharacterMember((CFCharacterSetRef)KinsokuIllegalEndChar::sSet, theChar) != 0;
}

void ___Z21KinsokuIllegalEndCharj_block_invoke()
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  v4[0] = xmmword_22383B2D0;
  v4[1] = unk_22383B2E0;
  void v4[2] = xmmword_22383B2F0;
  v4[3] = unk_22383B300;
  int v5 = 10551138;
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFAttributedStringRef Mutable = CFCharacterSetCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08]);
  CFStringRef v2 = CFStringCreateWithCharacters(v0, (const UniChar *)v4, 34);
  if (v2)
  {
    CFStringRef v3 = v2;
    CFCharacterSetAddCharactersInString(Mutable, v2);
    CFRelease(v3);
  }
  KinsokuIllegalEndChar::sSet = (uint64_t)Mutable;
}

BOOL KinsokuIllegalStartChar(UTF32Char theChar)
{
  if (KinsokuIllegalStartChar::sKinsokuIllegalStartCharDispatchOnceToken != -1) {
    dispatch_once(&KinsokuIllegalStartChar::sKinsokuIllegalStartCharDispatchOnceToken, &__block_literal_global_93);
  }
  return CFCharacterSetIsLongCharacterMember((CFCharacterSetRef)KinsokuIllegalStartChar::sSet, theChar) != 0;
}

void ___Z23KinsokuIllegalStartCharj_block_invoke()
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  long long v16 = xmmword_22383B3D4;
  long long v17 = unk_22383B3E4;
  long long v18 = xmmword_22383B3F4;
  unint64_t v19 = 0xFF64FF61FE52FE51;
  long long v12 = xmmword_22383B394;
  long long v13 = unk_22383B3A4;
  long long v14 = xmmword_22383B3B4;
  long long v15 = unk_22383B3C4;
  long long v8 = xmmword_22383B354;
  long long v9 = unk_22383B364;
  long long v10 = xmmword_22383B374;
  long long v11 = unk_22383B384;
  long long v4 = xmmword_22383B314;
  long long v5 = unk_22383B324;
  long long v6 = xmmword_22383B334;
  long long v7 = unk_22383B344;
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFAttributedStringRef Mutable = CFCharacterSetCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08]);
  CFStringRef v2 = CFStringCreateWithCharacters(v0, (const UniChar *)&v4, 124);
  if (v2)
  {
    CFStringRef v3 = v2;
    CFCharacterSetAddCharactersInString(Mutable, v2);
    CFRelease(v3);
    CFCharacterSetUnion(Mutable, (CFCharacterSetRef)objc_msgSend(MEMORY[0x263F08708], "whitespaceCharacterSet", v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,
                           v19,
                           v20));
  }
  KinsokuIllegalStartChar::sSet = (uint64_t)Mutable;
}

BOOL KinsokuWesternChar(UTF32Char theChar)
{
  if (KinsokuWesternChar::sKinsokuWesternCharDispatchOnceToken != -1) {
    dispatch_once(&KinsokuWesternChar::sKinsokuWesternCharDispatchOnceToken, &__block_literal_global_95);
  }
  return CFCharacterSetIsLongCharacterMember((CFCharacterSetRef)KinsokuWesternChar::sSet, theChar) != 0;
}

void ___Z18KinsokuWesternCharj_block_invoke()
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  memcpy(__dst, asc_22383B40C, sizeof(__dst));
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFAttributedStringRef Mutable = CFCharacterSetCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08]);
  CFStringRef v2 = CFStringCreateWithCharacters(v0, __dst, 767);
  if (v2)
  {
    CFStringRef v3 = v2;
    CFCharacterSetAddCharactersInString(Mutable, v2);
    CFRelease(v3);
  }
  KinsokuWesternChar::sSet = (uint64_t)Mutable;
}

BOOL KinsokuAllowSplit(uint64_t theChar, uint64_t a2)
{
  UTF32Char v3 = theChar;
  if ((int)theChar > 12338)
  {
    if ((theChar - 12339) >= 2)
    {
      int v6 = 65073;
      if (theChar != 65073) {
        goto LABEL_20;
      }
    }
    else
    {
      int v6 = 12341;
    }
    BOOL v7 = a2 == v6;
    return !v7;
  }
  if ((theChar - 8208) <= 0x16)
  {
    int v4 = 1 << (theChar - 16);
    if ((v4 & 0x3D) != 0)
    {
LABEL_4:
      if ((a2 - 8208) > 5) {
        return a2 != 45;
      }
      BOOL result = 0;
      if (a2 == 8209) {
        return a2 != 45;
      }
      return result;
    }
    if ((v4 & 0x600000) != 0)
    {
      BOOL v7 = a2 == theChar;
      return !v7;
    }
  }
  if (theChar == 45) {
    goto LABEL_4;
  }
  if (theChar == 47)
  {
    BOOL v7 = a2 == 47;
    return !v7;
  }
LABEL_20:
  if IsWhitespaceCharacter(theChar) && (IsWhitespaceCharacter(a2)) {
    return 0;
  }
  if (KinsokuWesternChar(v3)) {
    return !KinsokuWesternChar(a2);
  }
  return 1;
}

double OikomiSquishAmountForCharacter(int a1)
{
  double result = 0.0;
  if (a1 > 10628)
  {
    if (((a1 - 12289) > 0x1E || ((1 << (a1 - 1)) & 0x51F9FF81) == 0) && (a1 - 10629) >= 2)
    {
      if (a1 != 12539) {
        return result;
      }
      return 0.5;
    }
    return 0.25;
  }
  if (a1 > 122)
  {
    if ((a1 - 8216) <= 5 && ((1 << (a1 - 24)) & 0x33) != 0
      || (a1 - 125) <= 0x3E && ((1 << (a1 - 125)) & 0x4000400000000001) != 0
      || a1 == 123)
    {
      return 0.25;
    }
  }
  else
  {
    char v2 = a1 - 32;
    if ((a1 - 32) > 0x3D) {
      return result;
    }
    if (((1 << v2) & 0x2800000000001300) != 0) {
      return 0.25;
    }
    if (((1 << v2) & 0xC000000) != 0) {
      return 0.5;
    }
    if (a1 == 32) {
      return 0.0833333333;
    }
  }
  return result;
}

BOOL BursageEligibleChar(UTF32Char theChar)
{
  if (BursageEligibleChar::sBursageEligibleCharDispatchOnceToken != -1) {
    dispatch_once(&BursageEligibleChar::sBursageEligibleCharDispatchOnceToken, &__block_literal_global_97);
  }
  return CFCharacterSetIsLongCharacterMember((CFCharacterSetRef)BursageEligibleChar::sSet, theChar) != 0;
}

void ___Z19BursageEligibleCharj_block_invoke()
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  *(_OWORD *)int v4 = xmmword_22383BA0A;
  *(_OWORD *)&v4[7] = *(long long *)((char *)&xmmword_22383BA0A + 14);
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFAttributedStringRef Mutable = CFCharacterSetCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08]);
  CFStringRef v2 = CFStringCreateWithCharacters(v0, v4, 15);
  if (v2)
  {
    CFStringRef v3 = v2;
    CFCharacterSetAddCharactersInString(Mutable, v2);
    CFRelease(v3);
  }
  BursageEligibleChar::sSet = (uint64_t)Mutable;
}

uint64_t TSWPPreviousCharFromTextSource(uint64_t a1, void *a2)
{
  if (!a2)
  {
    int v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "TSWPCharIndex TSWPPreviousCharFromTextSource(TSWPCharIndex, id<TSWPTextSource>)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPUtilities.mm"), 1366, @"invalid nil value for '%s'", "source");
  }
  uint64_t v6 = [a2 charIndexMappedFromStorage:a1];
  if (!v6)
  {
    long long v10 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v11 = objc_msgSend(NSString, "stringWithUTF8String:", "TSWPCharIndex TSWPPreviousCharFromTextSource(TSWPCharIndex, id<TSWPTextSource>)");
    objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPUtilities.mm"), 1368, @"charIndex should not be at the start of the text source");
    return a1;
  }
  a1 = [a2 charIndexMappedToStorage:v6 - 1];
  uint64_t v7 = [a2 charIndexMappedFromStorage:a1];
  __int16 v8 = [a2 characterAtIndex:v7];
  if (!v7 || (v8 & 0xFC00) != 0xDC00) {
    return a1;
  }

  return [a2 charIndexMappedToStorage:v7 - 1];
}

uint64_t TSWPNextCharFromTextSource(uint64_t a1, void *a2)
{
  if (!a2)
  {
    int v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "TSWPCharIndex TSWPNextCharFromTextSource(TSWPCharIndex, id<TSWPTextSource>)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPUtilities.mm"), 1388, @"invalid nil value for '%s'", "source");
  }
  unint64_t v6 = [a2 charIndexMappedFromStorage:a1];
  if (v6 >= [a2 length] - 1)
  {
    return [a2 charIndexMappedToStorage:v6 + 1];
  }
  else
  {
    while (v6 < [a2 length])
    {
      if (([a2 characterAtIndex:v6] & 0xFC00) == 0xD800) {
        uint64_t v7 = 2;
      }
      else {
        uint64_t v7 = 1;
      }
      v6 += v7;
      uint64_t v8 = [a2 charIndexMappedToStorage:v6];
      if (v8 != a1) {
        return v8;
      }
    }
    return a1;
  }
}

unint64_t TSWPRangeByExtendingRangeToWhitespaceForTextSource(unint64_t a1, uint64_t a2, void *a3)
{
  unint64_t v3 = a1;
  unint64_t v4 = a1 + a2;
  if (a1 != *MEMORY[0x263F7C7C8] || a2 != *(void *)(MEMORY[0x263F7C7C8] + 8))
  {
    if (!a3)
    {
      uint64_t v7 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v8 = objc_msgSend(NSString, "stringWithUTF8String:", "NSRange TSWPRangeByExtendingRangeToWhitespaceForTextSource(NSRange, id<TSWPTextSource>)");
      objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPUtilities.mm"), 1447, @"invalid nil value for '%s'", "textSource");
    }
    unint64_t v9 = [a3 length];
    long long v10 = (void *)[a3 string];
    do
    {
      unint64_t v11 = v3;
      if (!v3) {
        break;
      }
      --v3;
    }
    while (!IsWhitespaceCharacter([v10 characterAtIndex:v11 - 1]));
    if (v4 < v9)
    {
      while ((IsWhitespaceCharacter([v10 characterAtIndex:v4]) & 1) == 0)
      {
        if (++v4 >= v9)
        {
          unint64_t v4 = v9;
          break;
        }
      }
    }
    unint64_t v3 = v11;
  }
  if (v3 >= v4) {
    return v4;
  }
  else {
    return v3;
  }
}

__CFString *TSWPTextPackageStringForPreset()
{
  return @"text";
}

uint64_t TSWPResolveColorForStyles(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0;
  void v7[2] = *MEMORY[0x263EF8340];
  v7[0] = a1;
  v7[1] = a2;
  while (1)
  {
    unint64_t v3 = (void *)v7[v2];
    if (v3)
    {
      uint64_t v4 = [v3 boxedValueForProperty:18];
      if (v4)
      {
        uint64_t v5 = v4;
        if (v4 != [MEMORY[0x263EFF9D0] null]) {
          break;
        }
      }
    }
    if (++v2 == 2) {
      return 0;
    }
  }
  return v5;
}

const __CTFont *TSWPCreateFontWithNameAndTraits(uint64_t a1, int a2, int a3, void *a4, double a5)
{
  return TSWPCreateFontWithNameAttributesTraitsAndWeight(a1, a2, a3, 0, a4, 0, a5, *MEMORY[0x263F1D338]);
}

BOOL TSWPFontGetGlyphsForUnichars(uint64_t a1, const UniChar *a2, CGGlyph *a3, CFIndex a4)
{
  CTFontGetTypeID();
  uint64_t v7 = (const __CTFont *)TSUCFTypeCast();

  return CTFontGetGlyphsForCharacters(v7, a2, a3, a4);
}

double TSWPAttachmentVAlignmentCorrection(int a1, uint64_t a2, void *a3, unint64_t a4)
{
  double v4 = 0.0;
  if (a2)
  {
    FontForStyle = TSWPFastCreateFontForStyle(a2, a3, a4);
    if (FontForStyle)
    {
      uint64_t v7 = FontForStyle;
      switch(a1)
      {
        case 1:
          double Ascent = CTFontGetAscent(FontForStyle);
          double v4 = Ascent - CTFontGetCapHeight(v7);
          break;
        case 2:
          double v9 = CTFontGetAscent(FontForStyle);
          double v4 = -(CTFontGetCapHeight(v7) - v9 * 1.5);
          break;
        case 3:
          double v4 = CTFontGetAscent(FontForStyle);
          break;
        case 4:
          double v10 = CTFontGetAscent(FontForStyle);
          double v4 = v10 + CTFontGetDescent(v7);
          break;
        default:
          break;
      }
      CFRelease(v7);
    }
  }
  return v4;
}

double GetWavyLineHalfAmplitude(double a1)
{
  return fmax(a1, 1.75);
}

double GetWavyLineThickness(double a1)
{
  return fmin(a1, 1.0);
}

double GetWavyLineRate(void)
{
  return 0.174999997;
}

double TSWPUnderlineAdornmentMetricsForFont(const __CTFont *a1, const __CTFont *a2, int a3, int a4, void *a5, int a6, double a7, double a8, double a9, double a10, double a11)
{
  double v33 = 0.0;
  double v22 = pAdjustedLineHeight(a1, &v33);
  double UnderlineThickness = CTFontGetUnderlineThickness(a1);
  if (UnderlineThickness == 0.0) {
    double v24 = v22 * 0.0440277313;
  }
  else {
    double v24 = UnderlineThickness;
  }
  int v25 = TSWPCJKLanguageForInputLanguageString(a5);
  if (a11 == 0.0) {
    a11 = v24;
  }
  double v26 = fmax(a11, 1.0);
  if (a6 == 1)
  {
    double v27 = -a8;
    if (a4) {
      double v27 = -(a9 + a10 - (-a8 - a11) - ((a8 + a9) * 0.5 + a10));
    }
    double v28 = -0.0;
    if (a3 == 2) {
      double v28 = a11;
    }
    double v29 = v28 + v27;
    if (a3 && !a4 && v25 != 6) {
      double v29 = v29 - v26;
    }
  }
  else
  {
    if (a4)
    {
      a9 = -(a9 + a10 - (a11 + a9) - ((a8 + a9) * 0.5 + a10));
    }
    else
    {
      if (!a3 || v25 == 6)
      {
        UnderlinePositiouint64_t n = CTFontGetUnderlinePosition(a1);
        if (a1 != a2 && UnderlinePosition == 0.0) {
          UnderlinePositiouint64_t n = CTFontGetUnderlinePosition(a2);
        }
        a9 = -UnderlinePosition;
      }
      if (a9 < 1.0) {
        a9 = floor(v33) * 5.3636991 * 0.0880554625;
      }
    }
    double v31 = fmax(fmax(a11, 1.75) - a11, 0.0) + a9;
    if (a4) {
      double v31 = a9;
    }
    double v29 = a9 - a11;
    if (a3 != 2) {
      double v29 = a9;
    }
    if (a3 == 3) {
      double v29 = v31;
    }
  }
  return v29 + a7;
}

double pAdjustedLineHeight(const __CTFont *a1, double *a2)
{
  id v4 = +[TSWPFontHeightCache sharedCache];
  if (v4) {
    [v4 fontHeightInfoForFont:a1];
  }
  *a2 = 0.0 + 0.0;
  return fmin(rint(0.0 + 0.0) * 5.3636991, fmax(0.0, 0.0) + 0.0 + 0.0 + 0.0 + 0.0 + 0.0);
}

uint64_t TSWPCJKLanguageForInputLanguageString(void *a1)
{
  BOOL v1 = (void *)[a1 lowercaseString];
  if (TSWPCJKLanguageForInputLanguageString::onceToken != -1) {
    dispatch_once(&TSWPCJKLanguageForInputLanguageString::onceToken, &__block_literal_global_130);
  }
  uint64_t v2 = (void *)[(id)TSWPCJKLanguageForInputLanguageString::sMappings objectForKeyedSubscript:v1];
  if (!v2 || (uint64_t result = [v2 intValue], result == 6))
  {
    if ((unint64_t)[v1 length] >= 2
      && (uint64_t v4 = objc_msgSend(v1, "substringWithRange:", 0, 2),
          (uint64_t v5 = (void *)[(id)TSWPCJKLanguageForInputLanguageString::sMappings objectForKeyedSubscript:v4]) != 0))
    {
      return [v5 intValue];
    }
    else
    {
      return 6;
    }
  }
  return result;
}

double TSWPPositionForVerticalCenterFromPositionForBaseline(double a1, double a2, double a3, double a4)
{
  return -(a3 + a4 - a1 - ((a2 + a3) * 0.5 + a4));
}

void TSWPStrikethroughAdornmentMetricsForFont(const __CTFont *a1, double a2, double a3, double a4, double a5)
{
  pAdjustedLineHeight(a1, &v6);
  CTFontGetXHeight(a1);
}

double TSWPRound(double a1)
{
  double v1 = fabs(a1);
  double v2 = v1 - floor(v1);
  BOOL v3 = a1 >= 0.0 || v2 > 0.5;
  if (v3 && (a1 >= 0.0 ? (BOOL v4 = v2 < 0.5) : (BOOL v4 = 1), v4)) {
    return floor(a1);
  }
  else {
    return ceil(a1);
  }
}

double TSWPIntegralPoint(CGPoint a1)
{
  double v1 = fabs(a1.x);
  double v2 = v1 - floor(v1);
  BOOL v3 = a1.x >= 0.0 || v2 > 0.5;
  if (v3 && (a1.x >= 0.0 ? (BOOL v4 = v2 < 0.5) : (BOOL v4 = 1), v4)) {
    return floor(a1.x);
  }
  else {
    return ceil(a1.x);
  }
}

double TSWPIntegralRect(CGRect a1)
{
  CGFloat height = a1.size.height;
  CGFloat width = a1.size.width;
  CGFloat y = a1.origin.y;
  CGFloat x = a1.origin.x;
  CGFloat MaxX = CGRectGetMaxX(a1);
  v12.origin.CGFloat x = x;
  v12.origin.CGFloat y = y;
  v12.size.CGFloat width = width;
  v12.size.CGFloat height = height;
  v10.CGFloat y = CGRectGetMaxY(v12);
  v10.CGFloat x = MaxX;
  double v6 = TSWPIntegralPoint(v10);
  v11.CGFloat x = x;
  v11.CGFloat y = y;
  double v7 = TSWPIntegralPoint(v11);
  if (v7 >= v6) {
    return v6;
  }
  else {
    return v7;
  }
}

CGFloat TSWPRectWithPoints(CGPoint a1, CGPoint a2)
{
  if (a1.x >= a2.x) {
    return a2.x;
  }
  else {
    return a1.x;
  }
}

BOOL TSWPInsertionPointInRangeWithOptions(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v5 = !(a5 & 1) + a3;
  BOOL v7 = a1 >= v5;
  unint64_t v6 = a1 - v5;
  BOOL v7 = !v7 || v6 >= a4 + (a5 & 1) + ((a5 >> 1) & 1) - 1;
  return !v7;
}

uint64_t __TSWPCJKLanguageForInputLanguageString_block_invoke()
{
  uint64_t result = objc_msgSend(objc_alloc(NSDictionary), "initWithObjectsAndKeys:", @"zh-hans", &unk_26D73A1A0, @"zh_hans", &unk_26D73A1B8, @"zh-hant", &unk_26D73A1B8, @"zh_hant", &unk_26D73A1D0, @"ja-jp", &unk_26D73A1E8, @"ko-ko", &unk_26D73A1B8, @"zh", &unk_26D73A1D0, @"ja", &unk_26D73A1E8, @"ko",
             0);
  TSWPCJKLanguageForInputLanguageString::sMappings = result;
  return result;
}

uint64_t TSWPListLanguageForInputLanguageString(void *a1)
{
  double v1 = (void *)[a1 lowercaseString];
  if (TSWPListLanguageForInputLanguageString::onceToken != -1) {
    dispatch_once(&TSWPListLanguageForInputLanguageString::onceToken, &__block_literal_global_165);
  }
  double v2 = (void *)[(id)TSWPListLanguageForInputLanguageString::sMappings objectForKeyedSubscript:v1];
  if (!v2 || (uint64_t result = [v2 intValue], result == 6))
  {
    if ((unint64_t)[v1 length] >= 2
      && (uint64_t v4 = objc_msgSend(v1, "substringWithRange:", 0, 2),
          (unint64_t v5 = (void *)[(id)TSWPListLanguageForInputLanguageString::sMappings objectForKeyedSubscript:v4]) != 0))
    {
      return [v5 intValue];
    }
    else
    {
      return 6;
    }
  }
  return result;
}

uint64_t __TSWPListLanguageForInputLanguageString_block_invoke()
{
  uint64_t result = objc_msgSend(objc_alloc(NSDictionary), "initWithObjectsAndKeys:", @"zh-hans", &unk_26D73A1A0, @"zh_hans", &unk_26D73A1B8, @"zh-hant", &unk_26D73A1B8, @"zh_hant", &unk_26D73A1D0, @"ja-jp", &unk_26D73A1E8, @"ko-ko", &unk_26D73A1B8, @"zh", &unk_26D73A1D0, @"ja", &unk_26D73A1E8, @"ko",
             &unk_26D73A200,
             @"ar",
             &unk_26D73A218,
             @"he",
             0);
  TSWPListLanguageForInputLanguageString::sMappings = result;
  return result;
}

id TSWPLocaleForCJKLanguage(int a1, void *a2)
{
  BOOL v3 = @"zh_CN";
  switch(a1)
  {
    case 0:
      goto LABEL_8;
    case 1:
      if (objc_msgSend((id)objc_msgSend(a2, "objectForKey:", *MEMORY[0x263EFF4D0]), "isEqualToString:", @"TW"))BOOL v3 = @"zh_TW"; {
      else
      }
        BOOL v3 = @"zh_HK";
      goto LABEL_8;
    case 2:
      BOOL v3 = @"ja_JP";
      goto LABEL_8;
    case 3:
      BOOL v3 = @"ko_KR";
LABEL_8:
      unint64_t v5 = (void *)[objc_alloc(MEMORY[0x263EFF960]) initWithLocaleIdentifier:v3];
      id result = v5;
      break;
    default:
      id result = 0;
      break;
  }
  return result;
}

void ApplyVerticalFormsToAttributedString(__CFAttributedString *a1, const unsigned __int16 *a2)
{
  CFIndex Length = CFAttributedStringGetLength(a1);
  if (!a2)
  {
    CFStringRef String = CFAttributedStringGetString(a1);
    CharactersPtr = CFStringGetCharactersPtr(String);
    if (!CharactersPtr) {
      operator new[]();
    }
    a2 = CharactersPtr;
  }
  TSWPRangeVector __p = 0;
  uint64_t v35 = 0;
  unint64_t v36 = 0;
  TSWPFillVerticalFacingRangesFromBuffer((uint64_t)a2, Length, &__p);
  CFIndex v7 = CFAttributedStringGetLength(a1);
  longestEffectiveRange.CFIndex location = 0;
  longestEffectiveRange.CFIndex length = 0;
  CFStringRef v8 = (const __CFString *)*MEMORY[0x263F039A0];
  while (longestEffectiveRange.length + longestEffectiveRange.location < v7)
  {
    v37.CFIndex location = 0;
    v37.CFIndex length = v7;
    AttributeAndLongestEffectiveRange = (const __CTFont *)CFAttributedStringGetAttributeAndLongestEffectiveRange(a1, longestEffectiveRange.length+ longestEffectiveRange.location, v8, v37, &longestEffectiveRange);
    if (!AttributeAndLongestEffectiveRange) {
      break;
    }
    CFStringRef v10 = CTFontCopyPostScriptName(AttributeAndLongestEffectiveRange);
    if (CFEqual(v10, @"AppleColorEmoji"))
    {
      CFRange v32 = longestEffectiveRange;
      CGPoint v11 = v35;
      if (v35 >= v36)
      {
        unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * (((char *)v35 - (unsigned char *)__p) >> 3);
        unint64_t v14 = v13 + 1;
        if (v13 + 1 > 0xAAAAAAAAAAAAAAALL) {
          abort();
        }
        if (0x5555555555555556 * (((char *)v36 - (unsigned char *)__p) >> 3) > v14) {
          unint64_t v14 = 0x5555555555555556 * (((char *)v36 - (unsigned char *)__p) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * (((char *)v36 - (unsigned char *)__p) >> 3) >= 0x555555555555555) {
          unint64_t v15 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v15 = v14;
        }
        if (v15) {
          long long v16 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>((uint64_t)&v36, v15);
        }
        else {
          long long v16 = 0;
        }
        long long v17 = &v16[24 * v13];
        *(CFRange *)long long v17 = v32;
        v17[16] = 1;
        *(_DWORD *)(v17 + 17) = 0;
        *((_DWORD *)v17 + 5) = 0;
        unint64_t v19 = (char *)__p;
        long long v18 = (char *)v35;
        uint64_t v20 = v17;
        if (v35 != __p)
        {
          do
          {
            long long v21 = *(_OWORD *)(v18 - 24);
            *((void *)v20 - 1) = *((void *)v18 - 1);
            *(_OWORD *)(v20 - 24) = v21;
            v20 -= 24;
            v18 -= 24;
          }
          while (v18 != v19);
          long long v18 = (char *)__p;
        }
        CGRect v12 = (CFRange *)(v17 + 24);
        TSWPRangeVector __p = v20;
        uint64_t v35 = (CFRange *)(v17 + 24);
        unint64_t v36 = (CFRange *)&v16[24 * v15];
        if (v18) {
          operator delete(v18);
        }
      }
      else
      {
        *uint64_t v35 = longestEffectiveRange;
        LOBYTE(v11[1].location) = 1;
        *(_DWORD *)((char *)&v11[1].location + 1) = 0;
        HIDWORD(v11[1].location) = 0;
        CGRect v12 = (CFRange *)((char *)v11 + 24);
      }
      uint64_t v35 = v12;
    }
    CFRelease(v10);
  }
  double v22 = v35;
  if (v35 != __p)
  {
    uint64_t v23 = 0;
    unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * (((char *)v35 - (unsigned char *)__p) >> 3);
    CFStringRef v25 = (const __CFString *)*MEMORY[0x263F03D80];
    double v26 = (const void *)*MEMORY[0x263EFFB40];
    double v27 = (const void *)*MEMORY[0x263EFFB38];
    unsigned int v28 = 1;
    do
    {
      double v29 = (CFRange *)((char *)__p + 24 * v23);
      if (LOBYTE(v29[1].location)) {
        long long v30 = v26;
      }
      else {
        long long v30 = v27;
      }
      CFAttributedStringSetAttribute(a1, *v29, v25, v30);
      uint64_t v23 = v28;
    }
    while (v24 > v28++);
    double v22 = (CFRange *)__p;
  }
  if (v22)
  {
    uint64_t v35 = v22;
    operator delete(v22);
  }
}

void sub_22376911C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TSWPCTFontSupportsNativeSmallCaps(const __CTFont *a1)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  CFArrayRef v1 = CTFontCopyFeatures(a1);
  long long v31 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  uint64_t v2 = [(__CFArray *)v1 countByEnumeratingWithState:&v31 objects:v37 count:16];
  if (v2)
  {
    uint64_t v3 = v2;
    uint64_t v4 = *(void *)v32;
    uint64_t v5 = *MEMORY[0x263F03AA0];
    uint64_t v22 = *MEMORY[0x263F03AA8];
    uint64_t v6 = *MEMORY[0x263F03A90];
    while (2)
    {
      for (uint64_t i = 0; i != v3; ++i)
      {
        if (*(void *)v32 != v4) {
          objc_enumerationMutation(v1);
        }
        CFStringRef v8 = *(void **)(*((void *)&v31 + 1) + 8 * i);
        double v9 = (void *)[v8 objectForKey:v5];
        if ([v9 integerValue] == 3)
        {
          CFStringRef v10 = (void *)[v8 objectForKey:v22];
          long long v27 = 0u;
          long long v28 = 0u;
          long long v29 = 0u;
          long long v30 = 0u;
          uint64_t v11 = [v10 countByEnumeratingWithState:&v27 objects:v36 count:16];
          if (v11)
          {
            uint64_t v12 = v11;
            uint64_t v13 = *(void *)v28;
LABEL_9:
            uint64_t v14 = 0;
            while (1)
            {
              if (*(void *)v28 != v13) {
                objc_enumerationMutation(v10);
              }
              if (objc_msgSend((id)objc_msgSend(*(id *)(*((void *)&v27 + 1) + 8 * v14), "objectForKey:", v6), "integerValue") == 3)break; {
              if (v12 == ++v14)
              }
              {
                uint64_t v12 = [v10 countByEnumeratingWithState:&v27 objects:v36 count:16];
                if (v12) {
                  goto LABEL_9;
                }
                goto LABEL_25;
              }
            }
LABEL_28:
            uint64_t v20 = 1;
            goto LABEL_30;
          }
        }
        else if ([v9 integerValue] == 37)
        {
          unint64_t v15 = (void *)[v8 objectForKey:v22];
          long long v23 = 0u;
          long long v24 = 0u;
          long long v25 = 0u;
          long long v26 = 0u;
          uint64_t v16 = [v15 countByEnumeratingWithState:&v23 objects:v35 count:16];
          if (v16)
          {
            uint64_t v17 = v16;
            uint64_t v18 = *(void *)v24;
LABEL_19:
            uint64_t v19 = 0;
            while (1)
            {
              if (*(void *)v24 != v18) {
                objc_enumerationMutation(v15);
              }
              if (objc_msgSend((id)objc_msgSend(*(id *)(*((void *)&v23 + 1) + 8 * v19), "objectForKey:", v6), "integerValue") == 1)goto LABEL_28; {
              if (v17 == ++v19)
              }
              {
                uint64_t v17 = [v15 countByEnumeratingWithState:&v23 objects:v35 count:16];
                if (v17) {
                  goto LABEL_19;
                }
                break;
              }
            }
          }
        }
LABEL_25:
        ;
      }
      uint64_t v3 = [(__CFArray *)v1 countByEnumeratingWithState:&v31 objects:v37 count:16];
      uint64_t v20 = 0;
      if (v3) {
        continue;
      }
      break;
    }
  }
  else
  {
    uint64_t v20 = 0;
  }
LABEL_30:

  return v20;
}

uint64_t TSWPGetAdornmentLocation(void *a1, int a2, int a3)
{
  int v5 = TSWPCJKLanguageForInputLanguageString(a1);
  uint64_t v6 = 0;
  for (uint64_t i = &dword_22383BA34; v5 != *(i - 3) || (((0x33333uLL >> v6) & 1) == 0) == a2 || *(i - 1) != a3; i += 4)
  {
    if (++v6 == 20) {
      return 0;
    }
  }
  return *i;
}

BOOL TSWPPrimaryInputMethodIsRTL()
{
  return [MEMORY[0x263EFF960] characterDirectionForLanguage:TSWPGetPrimaryInputLanguage()] == 2;
}

__CFString *TSWPGetPrimaryInputLanguage()
{
  CFAllocatorRef v0 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x263F1C8F8], "tswp_currentFirstResponder"), "textInputMode"), "primaryLanguage");
  if (![v0 length]) {
    CFAllocatorRef v0 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x263EFFA40], "standardUserDefaults"), "arrayForKey:", @"AppleLanguages"), "firstObject");
  }
  if ([v0 length]) {
    return (__CFString *)v0;
  }
  else {
    return @"en";
  }
}

uint64_t TSWPGetListNumberTypeForString(uint64_t a1)
{
  if (TSWPGetListNumberTypeForString::onceToken != -1) {
    dispatch_once(&TSWPGetListNumberTypeForString::onceToken, &__block_literal_global_208);
  }
  uint64_t v2 = (void *)[(id)TSWPGetListNumberTypeForString::listNames objectForKey:a1];
  if (v2) {
    return [v2 integerValue];
  }
  else {
    return 62;
  }
}

uint64_t __TSWPGetListNumberTypeForString_block_invoke()
{
  CFAllocatorRef v0 = (void *)[objc_alloc(MEMORY[0x263EFF9A0]) initWithCapacity:4];
  uint64_t v1 = 0;
  do
  {
    uint64_t result = objc_msgSend(v0, "setObject:forKey:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", v1), TSWPStringFromTSWPListNumberType(v1));
    uint64_t v1 = (v1 + 1);
  }
  while (v1 != 62);
  TSWPGetListNumberTypeForString::listNames = (uint64_t)v0;
  return result;
}

uint64_t TSWPStringFromTSWPListNumberType(unsigned int a1)
{
  if (onceTokenTSWPListNumberType != -1) {
    dispatch_once(&onceTokenTSWPListNumberType, &__block_literal_global_256);
  }
  uint64_t v2 = (void *)s_TSWPListNumberTypeStrings;

  return TSWPStringFromEnumWithTableAndIndex(a1, (uint64_t)"TSWPListNumberType", v2, 0);
}

uint64_t TSWPGetCharacterFormattingOptions(void *a1)
{
  uint64_t v2 = 0;
  if (!TSUHasCJKLanguage()) {
    a1 = 0;
  }
  while (1)
  {
    uint64_t v3 = sCharacterFormattingRulesData[v2];
    if (a1)
    {
      if (!v3) {
        goto LABEL_8;
      }
    }
    else if (!v3)
    {
      return LODWORD(sCharacterFormattingRulesData[v2 + 1]);
    }
    if (objc_msgSend(a1, "hasPrefix:")) {
      return LODWORD(sCharacterFormattingRulesData[v2 + 1]);
    }
LABEL_8:
    v2 += 2;
    if (v2 == 8) {
      return 0;
    }
  }
}

double TSWPRectDifference(double a1, double a2, double a3, double a4, double a5)
{
  return a1 - a5;
}

uint64_t TSWPStringFromEnumWithTableAndIndex(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  void v11[2] = *MEMORY[0x263EF8340];
  CFIndex v7 = objc_msgSend(a3, "objectForKeyedSubscript:", objc_msgSend(NSNumber, "numberWithInteger:", a1));
  if (!v7)
  {
    CFStringRef v8 = (void *)[[NSString alloc] initWithCString:a2 encoding:4];
    uint64_t v9 = [NSString stringWithFormat:@"[Unknown %@ (%ld)]", v8, a1];

    v11[0] = v9;
    v11[1] = v9;
    CFIndex v7 = (void *)[MEMORY[0x263EFF8C0] arrayWithObjects:v11 count:2];
  }
  return [v7 objectAtIndexedSubscript:a4];
}

uint64_t TSWPStringFromTSWPListLabelType(unsigned int a1)
{
  if (onceTokenTSWPListLabelType != -1) {
    dispatch_once(&onceTokenTSWPListLabelType, &__block_literal_global_215_0);
  }
  uint64_t v2 = (void *)s_TSWPListLabelTypeStrings;

  return TSWPStringFromEnumWithTableAndIndex(a1, (uint64_t)"TSWPListLabelType", v2, 0);
}

id __TSWPStringFromTSWPListLabelType_block_invoke()
{
  id result = (id)(*((uint64_t (__cdecl **)())s_TSWPListLabelTypeStringsInitBlock + 2))();
  s_TSWPListLabelTypeStrings = (uint64_t)result;
  return result;
}

uint64_t TSWPDisplayStringFromTSWPListLabelType(unsigned int a1)
{
  if (onceTokenTSWPListLabelType != -1) {
    dispatch_once(&onceTokenTSWPListLabelType, &__block_literal_global_218);
  }
  uint64_t v2 = (void *)s_TSWPListLabelTypeStrings;

  return TSWPStringFromEnumWithTableAndIndex(a1, (uint64_t)"TSWPListLabelType", v2, 1);
}

id __TSWPDisplayStringFromTSWPListLabelType_block_invoke()
{
  id result = (id)(*((uint64_t (__cdecl **)())s_TSWPListLabelTypeStringsInitBlock + 2))();
  s_TSWPListLabelTypeStrings = (uint64_t)result;
  return result;
}

id __TSWPStringFromTSWPListNumberType_block_invoke()
{
  id result = (id)(*((uint64_t (__cdecl **)())s_TSWPListNumberTypeStringsInitBlock + 2))();
  s_TSWPListNumberTypeStrings = (uint64_t)result;
  return result;
}

uint64_t TSWPDisplayStringFromTSWPListNumberType(unsigned int a1)
{
  if (onceTokenTSWPListNumberType != -1) {
    dispatch_once(&onceTokenTSWPListNumberType, &__block_literal_global_259);
  }
  uint64_t v2 = (void *)s_TSWPListNumberTypeStrings;

  return TSWPStringFromEnumWithTableAndIndex(a1, (uint64_t)"TSWPListNumberType", v2, 1);
}

id __TSWPDisplayStringFromTSWPListNumberType_block_invoke()
{
  id result = (id)(*((uint64_t (__cdecl **)())s_TSWPListNumberTypeStringsInitBlock + 2))();
  s_TSWPListNumberTypeStrings = (uint64_t)result;
  return result;
}

uint64_t TSWPStringFromTSWPCapitalization(unsigned int a1)
{
  if (onceTokenTSWPCapitalization != -1) {
    dispatch_once(&onceTokenTSWPCapitalization, &__block_literal_global_955);
  }
  uint64_t v2 = (void *)s_TSWPCapitalizationStrings;

  return TSWPStringFromEnumWithTableAndIndex(a1, (uint64_t)"TSWPCapitalization", v2, 0);
}

id __TSWPStringFromTSWPCapitalization_block_invoke()
{
  id result = (id)(*((uint64_t (__cdecl **)())s_TSWPCapitalizationStringsInitBlock + 2))();
  s_TSWPCapitalizationStrings = (uint64_t)result;
  return result;
}

uint64_t TSWPDisplayStringFromTSWPCapitalization(unsigned int a1)
{
  if (onceTokenTSWPCapitalization != -1) {
    dispatch_once(&onceTokenTSWPCapitalization, &__block_literal_global_958);
  }
  uint64_t v2 = (void *)s_TSWPCapitalizationStrings;

  return TSWPStringFromEnumWithTableAndIndex(a1, (uint64_t)"TSWPCapitalization", v2, 1);
}

id __TSWPDisplayStringFromTSWPCapitalization_block_invoke()
{
  id result = (id)(*((uint64_t (__cdecl **)())s_TSWPCapitalizationStringsInitBlock + 2))();
  s_TSWPCapitalizationStrings = (uint64_t)result;
  return result;
}

uint64_t TSWPStringFromTSWPWritingDirection(int a1)
{
  if (onceTokenTSWPWritingDirection != -1) {
    dispatch_once(&onceTokenTSWPWritingDirection, &__block_literal_global_998);
  }
  uint64_t v2 = (void *)s_TSWPWritingDirectionStrings;

  return TSWPStringFromEnumWithTableAndIndex(a1, (uint64_t)"TSWPWritingDirection", v2, 0);
}

id __TSWPStringFromTSWPWritingDirection_block_invoke()
{
  id result = (id)(*((uint64_t (__cdecl **)())s_TSWPWritingDirectionStringsInitBlock + 2))();
  s_TSWPWritingDirectionStrings = (uint64_t)result;
  return result;
}

uint64_t TSWPDisplayStringFromTSWPWritingDirection(int a1)
{
  if (onceTokenTSWPWritingDirection != -1) {
    dispatch_once(&onceTokenTSWPWritingDirection, &__block_literal_global_1001);
  }
  uint64_t v2 = (void *)s_TSWPWritingDirectionStrings;

  return TSWPStringFromEnumWithTableAndIndex(a1, (uint64_t)"TSWPWritingDirection", v2, 1);
}

id __TSWPDisplayStringFromTSWPWritingDirection_block_invoke()
{
  id result = (id)(*((uint64_t (__cdecl **)())s_TSWPWritingDirectionStringsInitBlock + 2))();
  s_TSWPWritingDirectionStrings = (uint64_t)result;
  return result;
}

uint64_t TSWPStringFromTSWPTOCScope(unsigned int a1)
{
  if (onceTokenTSWPTOCScope != -1) {
    dispatch_once(&onceTokenTSWPTOCScope, &__block_literal_global_1038);
  }
  uint64_t v2 = (void *)s_TSWPTOCScopeStrings;

  return TSWPStringFromEnumWithTableAndIndex(a1, (uint64_t)"TSWPTOCScope", v2, 0);
}

id __TSWPStringFromTSWPTOCScope_block_invoke()
{
  id result = (id)(*((uint64_t (__cdecl **)())s_TSWPTOCScopeStringsInitBlock + 2))();
  s_TSWPTOCScopeStrings = (uint64_t)result;
  return result;
}

uint64_t TSWPDisplayStringFromTSWPTOCScope(unsigned int a1)
{
  if (onceTokenTSWPTOCScope != -1) {
    dispatch_once(&onceTokenTSWPTOCScope, &__block_literal_global_1041);
  }
  uint64_t v2 = (void *)s_TSWPTOCScopeStrings;

  return TSWPStringFromEnumWithTableAndIndex(a1, (uint64_t)"TSWPTOCScope", v2, 1);
}

id __TSWPDisplayStringFromTSWPTOCScope_block_invoke()
{
  id result = (id)(*((uint64_t (__cdecl **)())s_TSWPTOCScopeStringsInitBlock + 2))();
  s_TSWPTOCScopeStrings = (uint64_t)result;
  return result;
}

uint64_t TSWPStringFromTSWPVerticalAlignment(unsigned int a1)
{
  if (onceTokenTSWPVerticalAlignment != -1) {
    dispatch_once(&onceTokenTSWPVerticalAlignment, &__block_literal_global_1072);
  }
  uint64_t v2 = (void *)s_TSWPVerticalAlignmentStrings;

  return TSWPStringFromEnumWithTableAndIndex(a1, (uint64_t)"TSWPVerticalAlignment", v2, 0);
}

id __TSWPStringFromTSWPVerticalAlignment_block_invoke()
{
  id result = (id)(*((uint64_t (__cdecl **)())s_TSWPVerticalAlignmentStringsInitBlock + 2))();
  s_TSWPVerticalAlignmentStrings = (uint64_t)result;
  return result;
}

uint64_t TSWPDisplayStringFromTSWPVerticalAlignment(unsigned int a1)
{
  if (onceTokenTSWPVerticalAlignment != -1) {
    dispatch_once(&onceTokenTSWPVerticalAlignment, &__block_literal_global_1075);
  }
  uint64_t v2 = (void *)s_TSWPVerticalAlignmentStrings;

  return TSWPStringFromEnumWithTableAndIndex(a1, (uint64_t)"TSWPVerticalAlignment", v2, 1);
}

id __TSWPDisplayStringFromTSWPVerticalAlignment_block_invoke()
{
  id result = (id)(*((uint64_t (__cdecl **)())s_TSWPVerticalAlignmentStringsInitBlock + 2))();
  s_TSWPVerticalAlignmentStrings = (uint64_t)result;
  return result;
}

void TSWPStorageTransaction::~TSWPStorageTransaction(TSWPStorageTransaction *this)
{
  std::vector<TSWPStorageTransactionObject>::__clear[abi:nn180100]((TSWPStorageTransactionObject **)this);
  uint64_t v2 = this;
  std::vector<TSWPStorageTransactionObject>::__destroy_vector::operator()[abi:nn180100]((void ***)&v2);
}

{
  TSWPStorageTransaction *v2;

  std::vector<TSWPStorageTransactionObject>::__clear[abi:nn180100]((TSWPStorageTransactionObject **)this);
  uint64_t v2 = this;
  std::vector<TSWPStorageTransactionObject>::__destroy_vector::operator()[abi:nn180100]((void ***)&v2);
}

void TSWPStorageTransaction::TSWPStorageTransaction(TSWPStorageTransaction *this)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(int64x2_t *)((char *)this + 24) = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
}

{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(int64x2_t *)((char *)this + 24) = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
}

void TSWPStorageTransaction::TSWPStorageTransaction(TSWPStorageTransaction *this, const TSWPStorageTransaction *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  std::vector<TSWPStorageTransactionObject>::__init_with_size[abi:nn180100]<TSWPStorageTransactionObject*,TSWPStorageTransactionObject*>((TSWPStorageTransactionObject *)this, *(TSWPStorageTransactionObject **)a2, *((TSWPStorageTransactionObject **)a2 + 1), (uint64_t)(*((void *)a2 + 1) - *(void *)a2) >> 5);
  *(int64x2_t *)((char *)this + 24) = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
}

{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  std::vector<TSWPStorageTransactionObject>::__init_with_size[abi:nn180100]<TSWPStorageTransactionObject*,TSWPStorageTransactionObject*>((TSWPStorageTransactionObject *)this, *(TSWPStorageTransactionObject **)a2, *((TSWPStorageTransactionObject **)a2 + 1), (uint64_t)(*((void *)a2 + 1) - *(void *)a2) >> 5);
  *(int64x2_t *)((char *)this + 24) = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
}

int64x2_t TSWPStorageTransaction::compress(TSWPStorageTransaction *this)
{
  std::vector<TSWPStorageTransactionObject>::resize((uint64_t *)this, (uint64_t)(*((void *)this + 1) - *(void *)this) >> 5);
  int64x2_t result = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
  *(int64x2_t *)((char *)this + 24) = result;
  return result;
}

void std::vector<TSWPStorageTransactionObject>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = (v3 - *a1) >> 5;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      uint64_t v6 = *a1 + 32 * a2;
      if (v3 != v6)
      {
        CFIndex v7 = (TSWPStorageTransactionObject *)(v3 - 32);
        do
        {
          if (*(_WORD *)v7) {
            TSWPStorageTransactionObject::adjustRetainCount(v7, 0);
          }
          BOOL v8 = v7 == (TSWPStorageTransactionObject *)v6;
          CFIndex v7 = (TSWPStorageTransactionObject *)((char *)v7 - 32);
        }
        while (!v8);
      }
      a1[1] = v6;
    }
  }
  else
  {
    unint64_t v5 = a2 - v4;
    std::vector<TSWPStorageTransactionObject>::__append(a1, v5);
  }
}

uint64_t TSWPStorageTransaction::operator==(unsigned __int16 **a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  unint64_t v4 = *(unsigned __int16 **)a2;
  if ((char *)v3 - (char *)*a1 != *(void *)(a2 + 8) - *(void *)a2) {
    return 0;
  }
  if (v2 == v3) {
    return 1;
  }
  do
  {
    uint64_t result = TSWPStorageTransactionObject::operator==(v2, v4);
    if (!result) {
      break;
    }
    v2 += 16;
    v4 += 16;
  }
  while (v2 != v3);
  return result;
}

uint64_t TSWPStorageTransaction::compressTransaction(void *a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  if (a2 == 5)
  {
    uint64_t v5 = a1[4];
    if (v5 != 0x7FFFFFFFFFFFFFFFLL)
    {
      uint64_t v6 = *a1 + 32 * v5;
      uint64_t result = 1;
      *(_DWORD *)(v6 + 4) |= 1 << a3;
      return result;
    }
  }
  if (a3) {
    return 0;
  }
  uint64_t v8 = a1[1];
  if (v8 == *a1 || *(unsigned __int16 *)(v8 - 32) != a2 || *(_DWORD *)(v8 - 28)) {
    return 0;
  }
  if (a2 == 2)
  {
    int v9 = *(_DWORD *)(v8 - 20);
    if (v9 + *(_DWORD *)(v8 - 24) == a4) {
      goto LABEL_19;
    }
    return 0;
  }
  if (a2 == 7)
  {
    int v9 = *(_DWORD *)(v8 - 20);
    if (v9 + *(_DWORD *)(v8 - 24) == a4 && *(void *)(v8 - 16) == *(void *)(a5 + 8)) {
      goto LABEL_19;
    }
    return 0;
  }
  if (a2 != 3 || a1[3] != a4 || *(void *)(v8 - 16) != *(void *)(a5 + 8)) {
    return 0;
  }
  int v9 = *(_DWORD *)(v8 - 20);
LABEL_19:
  *(_DWORD *)(v8 - 20) = v9 + 1;
  return 1;
}

void TSWPStorageTransaction::appendToTransaction(uint64_t *a1, int a2, int a3, unint64_t a4, uint64_t a5, NSString *a6, unint64_t a7, unint64_t a8, uint64_t a9)
{
  uint64_t v30 = 0;
  uint64_t v29 = 0;
  int v31 = 0;
  int v16 = (unsigned __int16)a2;
  LOWORD(v28) = a2;
  int v17 = a2 - 1;
  if (a2 != 1) {
    LODWORD(v29) = a3;
  }
  if ((TSWPStorageTransaction::compressTransaction(a1, a2, a3, a4, a5) & 1) == 0)
  {
    uint64_t v18 = 0;
    switch(v17)
    {
      case 0:
        TSWPStorageTransactionObject::setTextTransaction((TSWPStorageTransactionObject *)&v28, a7, a6, a8);
        a1[4] = (a1[1] - *a1) >> 5;
        goto LABEL_30;
      case 1:
        goto LABEL_19;
      case 2:
        if (a3 <= 9)
        {
          if (!a3)
          {
            TSWPStorageTransactionObject::setCharIndexTransaction((TSWPStorageTransactionObject *)&v28, *(void *)a5, 1uLL, *(objc_object **)(a5 + 8));
            goto LABEL_30;
          }
          if (a3 == 1) {
            goto LABEL_29;
          }
          goto LABEL_39;
        }
        if (a3 == 10) {
          goto LABEL_29;
        }
        if (a3 != 11 && a3 != 18)
        {
LABEL_39:
          TSWPStorageTransactionObject::setAttributeIndexTransaction((TSWPStorageTransactionObject *)&v28, a4, *(void *)a5, *(objc_object **)(a5 + 8));
          goto LABEL_30;
        }
LABEL_26:
        TSWPStorageTransactionObject::setParagraphDataTransaction(&v28, a4, *(void *)a5, *(_DWORD *)(a5 + 8));
LABEL_30:
        unint64_t v26 = a1[1];
        if (v26 >= a1[2])
        {
          uint64_t v27 = std::vector<TSWPStorageTransactionObject>::__push_back_slow_path<TSWPStorageTransactionObject const&>(a1, (const TSWPStorageTransactionObject *)&v28);
        }
        else
        {
          std::vector<TSWPStorageTransactionObject>::__construct_one_at_end[abi:nn180100]<TSWPStorageTransactionObject const&>((uint64_t)a1, (const TSWPStorageTransactionObject *)&v28);
          uint64_t v27 = v26 + 32;
        }
        a1[1] = v27;
        int v16 = (unsigned __int16)v28;
        break;
      case 3:
      case 4:
        LOWORD(v28) = 4;
        TSWPStorageTransactionObject::setCharDeltaTransaction(&v28, *(void *)a5, a4, a9);
        goto LABEL_30;
      case 5:
        TSWPStorageTransactionObject::setReplaceCharIndexTransaction((uint64_t)&v28, a4, *(void *)a5);
        goto LABEL_30;
      case 6:
        if (a3 <= 0x12 && ((1 << a3) & 0x40C02) != 0)
        {
          long long v24 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v25 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPStorageTransaction::appendToTransaction(TSWPUndoKind, TSWPAttributeArrayKind, TSWPAttributeIndex, const TSWPAttributeRecord &, NSString *, TSWPCharIndex, NSUInteger, NSInteger)");
          objc_msgSend(v24, "handleFailureInFunction:file:lineNumber:description:", v25, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 202, @"Bad undo kind: kUndoKindReplaceObject.");
        }
        uint64_t v18 = *(objc_object **)(a5 + 8);
LABEL_19:
        TSWPStorageTransactionObject::setInsertAttributeTransaction((TSWPStorageTransactionObject *)&v28, a4, 1uLL, v18);
        goto LABEL_30;
      case 7:
        if (a3 > 10)
        {
          if (a3 == 18 || a3 == 11) {
            goto LABEL_26;
          }
        }
        else if (a3 == 1 || a3 == 10)
        {
LABEL_29:
          TSWPStorageTransactionObject::setParagraphDataTransaction((uint64_t)&v28, a4, *(void *)a5, *(_WORD *)(a5 + 8), *(_WORD *)(a5 + 10));
          goto LABEL_30;
        }
        uint64_t v19 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v20 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPStorageTransaction::appendToTransaction(TSWPUndoKind, TSWPAttributeArrayKind, TSWPAttributeIndex, const TSWPAttributeRecord &, NSString *, TSWPCharIndex, NSUInteger, NSInteger)");
        uint64_t v21 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"];
        uint64_t v22 = @"Bad undo kind: kUndoKindReplaceParagraphData.";
        uint64_t v23 = 218;
LABEL_7:
        [v19 handleFailureInFunction:v20 file:v21 lineNumber:v23 description:v22];
        goto LABEL_30;
      default:
        uint64_t v19 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v20 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPStorageTransaction::appendToTransaction(TSWPUndoKind, TSWPAttributeArrayKind, TSWPAttributeIndex, const TSWPAttributeRecord &, NSString *, TSWPCharIndex, NSUInteger, NSInteger)");
        uint64_t v21 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"];
        uint64_t v22 = @"Bad undo kind for append to transaction.";
        uint64_t v23 = 224;
        goto LABEL_7;
    }
  }
  a1[3] = a4;
  if (v16) {
    TSWPStorageTransactionObject::adjustRetainCount((TSWPStorageTransactionObject *)&v28, 0);
  }
}

void sub_22376AF1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int16 a11)
{
  if (a11) {
    TSWPStorageTransactionObject::adjustRetainCount((TSWPStorageTransactionObject *)&a11, 0);
  }
  _Unwind_Resume(exception_object);
}

void TSWPStorageTransactionObject::TSWPStorageTransactionObject(TSWPStorageTransactionObject *this)
{
  *(_WORD *)this = 0;
  *(void *)((char *)this + 12) = 0;
  *(void *)((char *)this + 4) = 0;
  *((_DWORD *)this + 5) = 0;
}

{
  *(_WORD *)this = 0;
  *(void *)((char *)this + 12) = 0;
  *(void *)((char *)this + 4) = 0;
  *((_DWORD *)this + 5) = 0;
}

NSString *TSWPStorageTransactionObject::setTextTransaction(TSWPStorageTransactionObject *this, unint64_t a2, NSString *a3, unint64_t a4)
{
  if (HIDWORD(a2))
  {
    uint64_t v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPStorageTransactionObject::setTextTransaction(TSWPCharIndex, NSString *, NSUInteger)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1103, @"Out-of-bounds type assignment was clamped to max");
    LODWORD(a2) = -1;
  }
  *((_DWORD *)this + 2) = a2;
  uint64_t result = a3;
  *((void *)this + 2) = result;
  if (HIDWORD(a4))
  {
    a4 = [MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v10 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPStorageTransactionObject::setTextTransaction(TSWPCharIndex, NSString *, NSUInteger)");
    uint64_t result = (NSString *)objc_msgSend((id)a4, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1105, @"Out-of-bounds type assignment was clamped to max");
    LODWORD(a4) = -1;
  }
  *((_DWORD *)this + 3) = a4;
  return result;
}

objc_object *TSWPStorageTransactionObject::setInsertAttributeTransaction(TSWPStorageTransactionObject *this, unint64_t a2, unint64_t a3, objc_object *a4)
{
  if (HIDWORD(a2))
  {
    uint64_t v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPStorageTransactionObject::setInsertAttributeTransaction(TSWPAttributeIndex, TSWPAttributeCount, id)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1136, @"Out-of-bounds type assignment was clamped to max");
    LODWORD(a2) = -1;
  }
  *((_DWORD *)this + 2) = a2;
  if (HIDWORD(a3))
  {
    a3 = [MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v10 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPStorageTransactionObject::setInsertAttributeTransaction(TSWPAttributeIndex, TSWPAttributeCount, id)");
    objc_msgSend((id)a3, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1137, @"Out-of-bounds type assignment was clamped to max");
    LODWORD(a3) = -1;
  }
  *((_DWORD *)this + 3) = a3;
  uint64_t result = a4;
  *((void *)this + 2) = result;
  return result;
}

objc_object *TSWPStorageTransactionObject::setCharIndexTransaction(TSWPStorageTransactionObject *this, unint64_t a2, unint64_t a3, objc_object *a4)
{
  if (HIDWORD(a2))
  {
    uint64_t v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPStorageTransactionObject::setCharIndexTransaction(TSWPCharIndex, TSWPAttributeCount, id)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1111, @"Out-of-bounds type assignment was clamped to max");
    LODWORD(a2) = -1;
  }
  *((_DWORD *)this + 2) = a2;
  if (HIDWORD(a3))
  {
    a3 = [MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v10 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPStorageTransactionObject::setCharIndexTransaction(TSWPCharIndex, TSWPAttributeCount, id)");
    objc_msgSend((id)a3, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1112, @"Out-of-bounds type assignment was clamped to max");
    LODWORD(a3) = -1;
  }
  *((_DWORD *)this + 3) = a3;
  uint64_t result = a4;
  *((void *)this + 2) = result;
  return result;
}

uint64_t TSWPStorageTransactionObject::setParagraphDataTransaction(uint64_t this, unint64_t a2, unint64_t a3, __int16 a4, __int16 a5)
{
  uint64_t v8 = this;
  if (HIDWORD(a2))
  {
    uint64_t v9 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v10 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPStorageTransactionObject::setParagraphDataTransaction(TSWPAttributeIndex, TSWPCharIndex, UInt16, UInt16)");
    this = objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1154, @"Out-of-bounds type assignment was clamped to max");
    LODWORD(a2) = -1;
  }
  *(_DWORD *)(v8 + 8) = a2;
  *(_WORD *)(v8 + 12) = a4;
  *(_WORD *)(v8 + 14) = a5;
  if (HIDWORD(a3))
  {
    a3 = [MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v11 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPStorageTransactionObject::setParagraphDataTransaction(TSWPAttributeIndex, TSWPCharIndex, UInt16, UInt16)");
    this = objc_msgSend((id)a3, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1157, @"Out-of-bounds type assignment was clamped to max");
    LODWORD(a3) = -1;
  }
  *(_DWORD *)(v8 + 16) = a3;
  return this;
}

_DWORD *TSWPStorageTransactionObject::setParagraphDataTransaction(_DWORD *this, unint64_t a2, unint64_t a3, int a4)
{
  uint64_t v6 = this;
  if (HIDWORD(a2))
  {
    CFIndex v7 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v8 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPStorageTransactionObject::setParagraphDataTransaction(TSWPAttributeIndex, TSWPCharIndex, UInt32)");
    this = (_DWORD *)objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1164, @"Out-of-bounds type assignment was clamped to max");
    LODWORD(a2) = -1;
  }
  v6[2] = a2;
  v6[3] = a4;
  if (HIDWORD(a3))
  {
    a3 = [MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPStorageTransactionObject::setParagraphDataTransaction(TSWPAttributeIndex, TSWPCharIndex, UInt32)");
    this = (_DWORD *)objc_msgSend((id)a3, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1166, @"Out-of-bounds type assignment was clamped to max");
    LODWORD(a3) = -1;
  }
  void v6[4] = a3;
  return this;
}

objc_object *TSWPStorageTransactionObject::setAttributeIndexTransaction(TSWPStorageTransactionObject *this, unint64_t a2, unint64_t a3, objc_object *a4)
{
  if (HIDWORD(a2))
  {
    uint64_t v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPStorageTransactionObject::setAttributeIndexTransaction(TSWPAttributeIndex, TSWPCharIndex, id)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1128, @"Out-of-bounds type assignment was clamped to max");
    LODWORD(a2) = -1;
  }
  *((_DWORD *)this + 2) = a2;
  if (HIDWORD(a3))
  {
    a3 = [MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v10 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPStorageTransactionObject::setAttributeIndexTransaction(TSWPAttributeIndex, TSWPCharIndex, id)");
    objc_msgSend((id)a3, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1129, @"Out-of-bounds type assignment was clamped to max");
    LODWORD(a3) = -1;
  }
  *((_DWORD *)this + 3) = a3;
  uint64_t result = a4;
  *((void *)this + 2) = result;
  return result;
}

_DWORD *TSWPStorageTransactionObject::setCharDeltaTransaction(_DWORD *this, unint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6 = this;
  if (HIDWORD(a2))
  {
    CFIndex v7 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v8 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPStorageTransactionObject::setCharDeltaTransaction(TSWPCharIndex, TSWPAttributeIndex, NSInteger)");
    this = (_DWORD *)objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1145, @"Out-of-bounds type assignment was clamped to max");
    LODWORD(a2) = -1;
  }
  v6[2] = a2;
  if (HIDWORD(a3))
  {
    a3 = [MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPStorageTransactionObject::setCharDeltaTransaction(TSWPCharIndex, TSWPAttributeIndex, NSInteger)");
    this = (_DWORD *)objc_msgSend((id)a3, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1146, @"Out-of-bounds type assignment was clamped to max");
    LODWORD(a3) = -1;
  }
  v6[3] = a3;
  if (a4 >= 0x80000000)
  {
    a4 = [MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v10 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPStorageTransactionObject::setCharDeltaTransaction(TSWPCharIndex, TSWPAttributeIndex, NSInteger)");
    this = (_DWORD *)objc_msgSend((id)a4, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1147, @"Out-of-bounds type assignment was clamped to max");
    LODWORD(a4) = 0x7FFFFFFF;
  }
  else if (a4 <= (uint64_t)0xFFFFFFFF7FFFFFFFLL)
  {
    a4 = [MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v11 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPStorageTransactionObject::setCharDeltaTransaction(TSWPCharIndex, TSWPAttributeIndex, NSInteger)");
    this = (_DWORD *)objc_msgSend((id)a4, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1147, @"Out-of-bounds type assignment was clamped to min");
    LODWORD(a4) = 0x80000000;
  }
  void v6[4] = a4;
  return this;
}

uint64_t TSWPStorageTransactionObject::setReplaceCharIndexTransaction(uint64_t this, unint64_t a2, unint64_t a3)
{
  uint64_t v4 = this;
  if (HIDWORD(a2))
  {
    uint64_t v5 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v6 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPStorageTransactionObject::setReplaceCharIndexTransaction(TSWPAttributeIndex, TSWPCharIndex)");
    this = objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1119, @"Out-of-bounds type assignment was clamped to max");
    LODWORD(a2) = -1;
  }
  *(_DWORD *)(v4 + 8) = a2;
  if (HIDWORD(a3))
  {
    a3 = [MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPStorageTransactionObject::setReplaceCharIndexTransaction(TSWPAttributeIndex, TSWPCharIndex)");
    this = objc_msgSend((id)a3, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1120, @"Out-of-bounds type assignment was clamped to max");
    LODWORD(a3) = -1;
  }
  *(_DWORD *)(v4 + 12) = a3;
  *(void *)(v4 + 16) = 0;
  return this;
}

void TSWPStorageTransactionObject::~TSWPStorageTransactionObject(TSWPStorageTransactionObject *this)
{
  if (*(_WORD *)this) {
    TSWPStorageTransactionObject::adjustRetainCount(this, 0);
  }
}

{
  if (*(_WORD *)this) {
    TSWPStorageTransactionObject::adjustRetainCount(this, 0);
  }
}

void TSWPStorageTransaction::appendToTransaction(uint64_t *a1, int a2, int a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
}

void TSWPStorageTransaction::appendToTransaction(uint64_t *a1, int a2, NSString *a3, unint64_t a4, unint64_t a5)
{
  v5[0] = 0;
  v5[1] = 0;
  TSWPStorageTransaction::appendToTransaction(a1, a2, 0, 0x7FFFFFFFFFFFFFFFuLL, (uint64_t)v5, a3, a4, a5, 0);
}

void TSWPStorageTransaction::appendToTransaction(uint64_t *a1, __int16 a2, int a3, void *a4)
{
  int v8 = 0;
  int v10 = 0;
  v7[0] = a2;
  int v9 = a3;
  id v11 = a4;
  unint64_t v5 = a1[1];
  if (v5 >= a1[2])
  {
    uint64_t v6 = std::vector<TSWPStorageTransactionObject>::__push_back_slow_path<TSWPStorageTransactionObject const&>(a1, (const TSWPStorageTransactionObject *)v7);
  }
  else
  {
    std::vector<TSWPStorageTransactionObject>::__construct_one_at_end[abi:nn180100]<TSWPStorageTransactionObject const&>((uint64_t)a1, (const TSWPStorageTransactionObject *)v7);
    uint64_t v6 = v5 + 32;
  }
  a1[1] = v6;
  a1[3] = 0x7FFFFFFFFFFFFFFFLL;
  if (v7[0]) {
    TSWPStorageTransactionObject::adjustRetainCount((TSWPStorageTransactionObject *)v7, 0);
  }
}

void sub_22376B9F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int16 a9)
{
  if (a9) {
    TSWPStorageTransactionObject::adjustRetainCount((TSWPStorageTransactionObject *)&a9, 0);
  }
  _Unwind_Resume(exception_object);
}

id TSWPStorageTransactionObject::setDOLCTransaction(uint64_t a1, int a2, void *a3)
{
  *(_DWORD *)(a1 + 8) = a2;
  id result = a3;
  *(void *)(a1 + 16) = result;
  return result;
}

void TSWPStorageTransaction::appendToTransaction(uint64_t *a1, __int16 a2, int a3, unint64_t a4, NSDate *a5)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  v8[0] = a2;
  int v9 = a3;
  TSWPStorageTransactionObject::setCTDateTransaction((TSWPStorageTransactionObject *)v8, a4, a5);
  unint64_t v6 = a1[1];
  if (v6 >= a1[2])
  {
    uint64_t v7 = std::vector<TSWPStorageTransactionObject>::__push_back_slow_path<TSWPStorageTransactionObject const&>(a1, (const TSWPStorageTransactionObject *)v8);
  }
  else
  {
    std::vector<TSWPStorageTransactionObject>::__construct_one_at_end[abi:nn180100]<TSWPStorageTransactionObject const&>((uint64_t)a1, (const TSWPStorageTransactionObject *)v8);
    uint64_t v7 = v6 + 32;
  }
  a1[1] = v7;
  a1[3] = 0x7FFFFFFFFFFFFFFFLL;
  if (v8[0]) {
    TSWPStorageTransactionObject::adjustRetainCount((TSWPStorageTransactionObject *)v8, 0);
  }
}

void sub_22376BACC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int16 a9)
{
  if (a9) {
    TSWPStorageTransactionObject::adjustRetainCount((TSWPStorageTransactionObject *)&a9, 0);
  }
  _Unwind_Resume(exception_object);
}

NSDate *TSWPStorageTransactionObject::setCTDateTransaction(TSWPStorageTransactionObject *this, unint64_t a2, NSDate *a3)
{
  if (HIDWORD(a2))
  {
    unint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSWPStorageTransactionObject::setCTDateTransaction(TSWPAttributeIndex, NSDate *)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1179, @"Out-of-bounds type assignment was clamped to max");
    LODWORD(a2) = -1;
  }
  *((_DWORD *)this + 2) = a2;
  id result = a3;
  *((void *)this + 2) = result;
  return result;
}

TSWPStorageTransaction *TSWPStorageTransaction::swap(TSWPStorageTransaction *this, TSWPStorageTransaction *a2)
{
  uint64_t v2 = *(void *)this;
  *(void *)this = *(void *)a2;
  *(void *)a2 = v2;
  uint64_t v3 = *((void *)this + 1);
  *((void *)this + 1) = *((void *)a2 + 1);
  *((void *)a2 + 1) = v3;
  uint64_t v4 = *((void *)this + 2);
  *((void *)this + 2) = *((void *)a2 + 2);
  *((void *)a2 + 2) = v4;
  return this;
}

uint64_t TSWPStorageTransaction::compressCoalescedTransaction(TSWPStorageTransaction *this, TSWPStorageTransaction *a2)
{
  uint64_t v2 = *((void *)this + 1);
  if (v2 != *(void *)this && *(_WORD *)(v2 - 32) == 1)
  {
    uint64_t v3 = *(void *)a2;
    if (*((void *)a2 + 1) - *(void *)a2 == 32 && *(_WORD *)v3 == 1)
    {
      int v4 = *(_DWORD *)(v2 - 20);
      uint64_t v5 = *(void *)(v2 - 16);
      if (v4) {
        BOOL v6 = v5 == 0;
      }
      else {
        BOOL v6 = 0;
      }
      if (v6)
      {
        int v12 = *(_DWORD *)(v3 + 12);
        if (v12) {
          BOOL v13 = *(void *)(v3 + 16) == 0;
        }
        else {
          BOOL v13 = 0;
        }
        if (!v13 || *(_DWORD *)(v2 - 24) + v4 != *(_DWORD *)(v3 + 8)) {
          return 0;
        }
        *(_DWORD *)(v2 - 20) = v12 + v4;
        return 1;
      }
      if (v4) {
        return 0;
      }
      if (!v5 || *(_DWORD *)(v3 + 12) != 0) {
        return 0;
      }
      uint64_t result = *(void *)(v3 + 16);
      if (!result) {
        return result;
      }
      uint64_t v9 = *(unsigned int *)(v3 + 8);
      uint64_t v10 = *(unsigned int *)(v2 - 24);
      if (v10 - [(id)result length] == v9)
      {
        uint64_t v11 = [[NSString alloc] initWithFormat:@"%@%@", *(void *)(v3 + 16), *(void *)(v2 - 16)];

        *(void *)(v2 - 16) = v11;
        *(_DWORD *)(v2 - 24) = *(_DWORD *)(v3 + 8);
        return 1;
      }
      if (*(_DWORD *)(v3 + 8) == *(_DWORD *)(v2 - 24))
      {
        uint64_t v14 = [[NSString alloc] initWithFormat:@"%@%@", *(void *)(v2 - 16), *(void *)(v3 + 16)];

        *(void *)(v2 - 16) = v14;
        return 1;
      }
    }
  }
  return 0;
}

void TSWPStorageTransaction::coalesceWithTransaction(TSWPStorageTransaction *this, TSWPStorageTransaction *a2)
{
  if ((TSWPStorageTransaction::compressCoalescedTransaction(this, a2) & 1) == 0)
  {
    int v4 = *(const TSWPStorageTransactionObject **)a2;
    if (*(void *)a2 != *((void *)a2 + 1))
    {
      unint64_t v5 = *((void *)this + 1);
      do
      {
        if (v5 >= *((void *)this + 2))
        {
          unint64_t v5 = std::vector<TSWPStorageTransactionObject>::__push_back_slow_path<TSWPStorageTransactionObject const&>((uint64_t *)this, v4);
        }
        else
        {
          std::vector<TSWPStorageTransactionObject>::__construct_one_at_end[abi:nn180100]<TSWPStorageTransactionObject const&>((uint64_t)this, v4);
          v5 += 32;
        }
        *((void *)this + 1) = v5;
        int v4 = (const TSWPStorageTransactionObject *)((char *)v4 + 32);
      }
      while (v4 != *((const TSWPStorageTransactionObject **)a2 + 1));
    }
  }

  std::vector<TSWPStorageTransactionObject>::__clear[abi:nn180100]((TSWPStorageTransactionObject **)a2);
}

void TSWPStorageTransactionObject::TSWPStorageTransactionObject(TSWPStorageTransactionObject *this, const TSWPStorageTransactionObject *a2)
{
  int v2 = *(unsigned __int16 *)a2;
  *(_WORD *)this = v2;
  *((_DWORD *)this + 1) = *((_DWORD *)a2 + 1);
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  if (v2) {
    TSWPStorageTransactionObject::assignFrom(this, a2);
  }
}

{
  int v2;

  int v2 = *(unsigned __int16 *)a2;
  *(_WORD *)this = v2;
  *((_DWORD *)this + 1) = *((_DWORD *)a2 + 1);
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  if (v2) {
    TSWPStorageTransactionObject::assignFrom(this, a2);
  }
}

void TSWPStorageTransactionObject::assignFrom(TSWPStorageTransactionObject *this, const TSWPStorageTransactionObject *a2)
{
  switch(*(_WORD *)this)
  {
    case 0:
    case 6:
      goto LABEL_3;
    case 1:
    case 2:
    case 7:
    case 9:
      goto LABEL_2;
    case 3:
      unsigned int v9 = *((_DWORD *)this + 1);
      if (v9 <= 0x12 && ((1 << v9) & 0x40C02) != 0) {
        goto LABEL_10;
      }
LABEL_2:
      id v4 = *((id *)a2 + 2);

LABEL_3:
      long long v5 = *(_OWORD *)((char *)a2 + 8);
      goto LABEL_4;
    case 4:
    case 5:
    case 8:
LABEL_10:
      uint64_t v10 = *((void *)a2 + 1);
      *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4);
      *((void *)this + 1) = v10;
      return;
    case 0xA:
      id v11 = *((id *)a2 + 2);

      long long v5 = *(_OWORD *)((char *)a2 + 8);
      *((void *)this + 3) = *((void *)a2 + 3);
LABEL_4:
      *(_OWORD *)((char *)this + 8) = v5;
      break;
    default:
      BOOL v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v7 = [NSString stringWithUTF8String:"void TSWPStorageTransactionObject::assignFrom(const TSWPStorageTransactionObject &)"];
      uint64_t v8 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"];
      [v6 handleFailureInFunction:v7 file:v8 lineNumber:1028 description:@"Bad undo kind for assign from."];
      break;
  }
}

TSWPStorageTransactionObject *TSWPStorageTransactionObject::operator=(TSWPStorageTransactionObject *this, TSWPStorageTransactionObject *a2)
{
  if (*(_WORD *)this) {
    TSWPStorageTransactionObject::adjustRetainCount(this, 0);
  }
  int v4 = *(unsigned __int16 *)a2;
  *(_WORD *)this = v4;
  *((_DWORD *)this + 1) = *((_DWORD *)a2 + 1);
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  if (v4) {
    TSWPStorageTransactionObject::assignFrom(this, a2);
  }
  return this;
}

void TSWPStorageTransactionObject::adjustRetainCount(TSWPStorageTransactionObject *this, int a2)
{
  unsigned int v2 = *(unsigned __int16 *)this;
  if (v2 > 0xA)
  {
    BOOL v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = [NSString stringWithUTF8String:"void TSWPStorageTransactionObject::adjustRetainCount(BOOL)"];
    uint64_t v8 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"];
    [v6 handleFailureInFunction:v7 file:v8 lineNumber:1082 description:@"Bad undo kind for adjust retain count."];
  }
  else
  {
    int v3 = 1 << v2;
    if ((v3 & 0x175) == 0)
    {
      if ((v3 & 0x682) != 0 || (unsigned int v9 = *((_DWORD *)this + 1), v9 > 0x12) || ((1 << v9) & 0x40C02) == 0)
      {
        int v4 = (void *)*((void *)this + 2);
        if (v4)
        {
          if (a2)
          {
            id v5 = v4;
          }
          else
          {
          }
        }
      }
    }
  }
}

uint64_t TSWPStorageTransactionObject::operator==(unsigned __int16 *a1, unsigned __int16 *a2)
{
  if (*a1 != *a2) {
    return 0;
  }
  int v2 = *((_DWORD *)a1 + 1);
  if (v2 != *((_DWORD *)a2 + 1)) {
    return 0;
  }
  switch(*a1)
  {
    case 0u:
      if (*((_DWORD *)a1 + 2) != *((_DWORD *)a2 + 2) || *((_DWORD *)a1 + 3) != *((_DWORD *)a2 + 3)) {
        return 0;
      }
      BOOL v8 = *((void *)a1 + 2) == *((void *)a2 + 2);
      goto LABEL_34;
    case 1u:
    case 2u:
    case 7u:
      goto LABEL_4;
    case 3u:
      if (v2 <= 9)
      {
        if (v2 == 1) {
          goto LABEL_38;
        }
        goto LABEL_4;
      }
      if (v2 == 10) {
        goto LABEL_38;
      }
      if (v2 != 11 && v2 != 18)
      {
LABEL_4:
        if (*((_DWORD *)a1 + 2) == *((_DWORD *)a2 + 2))
        {
          int v3 = *((_DWORD *)a1 + 3);
          int v4 = *((_DWORD *)a2 + 3);
LABEL_7:
          if (v3 == v4)
          {
            id v5 = (void *)*((void *)a1 + 2);
            BOOL v6 = (void *)*((void *)a2 + 2);
            if (v5 == v6 || v5 && v6 && (objc_msgSend(v5, "isEqual:") & 1) != 0) {
              return 1;
            }
          }
        }
        return 0;
      }
LABEL_29:
      if (*((_DWORD *)a1 + 2) != *((_DWORD *)a2 + 2)) {
        return 0;
      }
      int v11 = *((_DWORD *)a1 + 3);
      int v12 = *((_DWORD *)a2 + 3);
LABEL_31:
      if (v11 != v12) {
        return 0;
      }
      int v9 = *((_DWORD *)a1 + 4);
      int v10 = *((_DWORD *)a2 + 4);
LABEL_33:
      BOOL v8 = v9 == v10;
LABEL_34:
      uint64_t v7 = v8;
      break;
    case 4u:
    case 5u:
      goto LABEL_29;
    case 6u:
      if (*((_DWORD *)a1 + 2) != *((_DWORD *)a2 + 2)) {
        return 0;
      }
      int v9 = *((_DWORD *)a1 + 3);
      int v10 = *((_DWORD *)a2 + 3);
      goto LABEL_33;
    case 8u:
      uint64_t v7 = 0;
      if (v2 <= 10)
      {
        if (v2 != 1 && v2 != 10) {
          return v7;
        }
LABEL_38:
        if (*((_DWORD *)a1 + 2) == *((_DWORD *)a2 + 2) && a1[6] == a2[6])
        {
          int v11 = a1[7];
          int v12 = a2[7];
          goto LABEL_31;
        }
        return 0;
      }
      if (v2 != 11 && v2 != 18) {
        return v7;
      }
      goto LABEL_29;
    case 9u:
    case 0xAu:
      int v3 = *((_DWORD *)a1 + 2);
      int v4 = *((_DWORD *)a2 + 2);
      goto LABEL_7;
    default:
      return 0;
  }
  return v7;
}

void std::vector<TSWPStorageTransactionObject>::__clear[abi:nn180100](TSWPStorageTransactionObject **a1)
{
  int v3 = *a1;
  int v2 = a1[1];
  if (v2 != *a1)
  {
    int v4 = (TSWPStorageTransactionObject *)((char *)v2 - 32);
    do
    {
      if (*(_WORD *)v4) {
        TSWPStorageTransactionObject::adjustRetainCount(v4, 0);
      }
      BOOL v5 = v4 == v3;
      int v4 = (TSWPStorageTransactionObject *)((char *)v4 - 32);
    }
    while (!v5);
  }
  a1[1] = v3;
}

void std::vector<TSWPStorageTransactionObject>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  int v2 = *a1;
  if (*v2)
  {
    std::vector<TSWPStorageTransactionObject>::__clear[abi:nn180100]((TSWPStorageTransactionObject **)v2);
    int v3 = **a1;
    operator delete(v3);
  }
}

TSWPStorageTransactionObject *std::vector<TSWPStorageTransactionObject>::__init_with_size[abi:nn180100]<TSWPStorageTransactionObject*,TSWPStorageTransactionObject*>(TSWPStorageTransactionObject *result, TSWPStorageTransactionObject *a2, TSWPStorageTransactionObject *a3, unint64_t a4)
{
  if (a4)
  {
    BOOL v6 = result;
    std::vector<TSDBrushVertexData>::__vallocate[abi:nn180100](result, a4);
    uint64_t result = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<TSWPStorageTransactionObject>,TSWPStorageTransactionObject*,TSWPStorageTransactionObject*,TSWPStorageTransactionObject*>((int)v6 + 16, a2, a3, *((TSWPStorageTransactionObject **)v6 + 1));
    *((void *)v6 + 1) = result;
  }
  return result;
}

void sub_22376C48C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

TSWPStorageTransactionObject *std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<TSWPStorageTransactionObject>,TSWPStorageTransactionObject*,TSWPStorageTransactionObject*,TSWPStorageTransactionObject*>(int a1, TSWPStorageTransactionObject *a2, TSWPStorageTransactionObject *a3, TSWPStorageTransactionObject *this)
{
  if (a2 != a3)
  {
    BOOL v6 = a2;
    do
    {
      int v7 = *(unsigned __int16 *)v6;
      *(_WORD *)this = v7;
      *((_DWORD *)this + 1) = *((_DWORD *)v6 + 1);
      *((void *)this + 1) = 0;
      *((void *)this + 2) = 0;
      if (v7) {
        TSWPStorageTransactionObject::assignFrom(this, v6);
      }
      BOOL v6 = (TSWPStorageTransactionObject *)((char *)v6 + 32);
      this = (TSWPStorageTransactionObject *)((char *)this + 32);
    }
    while (v6 != a3);
  }
  return this;
}

uint64_t std::vector<TSWPStorageTransactionObject>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(result - 8);
  if (a2 <= (v6 - v7) >> 5)
  {
    if (a2)
    {
      uint64_t v14 = v7 + 32 * a2;
      do
      {
        *(_WORD *)uint64_t v7 = 0;
        *(void *)(v7 + 12) = 0;
        *(void *)(v7 + 4) = 0;
        *(_DWORD *)(v7 + 20) = 0;
        v7 += 32;
      }
      while (v7 != v14);
      uint64_t v7 = v14;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - *a1;
    unint64_t v9 = a2 + (v8 >> 5);
    if (v9 >> 59) {
      abort();
    }
    uint64_t v10 = v8 >> 5;
    uint64_t v11 = v5 - *a1;
    if (v11 >> 4 > v9) {
      unint64_t v9 = v11 >> 4;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v12 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    _OWORD v17[4] = result;
    if (v12) {
      BOOL v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKit::OpticalKern::Edge::CGPointVector>>(result, v12);
    }
    else {
      BOOL v13 = 0;
    }
    unint64_t v15 = &v13[32 * v10];
    v17[0] = v13;
    v17[1] = v15;
    void v17[3] = &v13[32 * v12];
    int v16 = &v15[32 * a2];
    do
    {
      *(_WORD *)unint64_t v15 = 0;
      *(void *)(v15 + 12) = 0;
      *(void *)(v15 + 4) = 0;
      *((_DWORD *)v15 + 5) = 0;
      v15 += 32;
    }
    while (v15 != v16);
    _OWORD v17[2] = v16;
    std::vector<TSWPStorageTransactionObject>::__swap_out_circular_buffer(a1, v17);
    return std::__split_buffer<TSWPStorageTransactionObject>::~__split_buffer((uint64_t)v17);
  }
  return result;
}

void sub_22376C614(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TSWPStorageTransactionObject>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<TSWPStorageTransactionObject>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:nn180100]<std::allocator<TSWPStorageTransactionObject>,std::reverse_iterator<TSWPStorageTransactionObject*>,std::reverse_iterator<TSWPStorageTransactionObject*>,std::reverse_iterator<TSWPStorageTransactionObject*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:nn180100]<std::allocator<TSWPStorageTransactionObject>,std::reverse_iterator<TSWPStorageTransactionObject*>,std::reverse_iterator<TSWPStorageTransactionObject*>,std::reverse_iterator<TSWPStorageTransactionObject*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5)
  {
    uint64_t v11 = 0;
    do
    {
      int v12 = *(unsigned __int16 *)(a3 + v11 - 32);
      *(_WORD *)(a7 + v11 - 32) = v12;
      uint64_t v13 = a7 + v11 - 32;
      *(_DWORD *)(v13 + 4) = *(_DWORD *)(a3 + v11 - 28);
      *(void *)(v13 + 8) = 0;
      *(void *)(v13 + 16) = 0;
      if (v12) {
        TSWPStorageTransactionObject::assignFrom((TSWPStorageTransactionObject *)v13, (const TSWPStorageTransactionObject *)(a3 + v11 - 32));
      }
      v11 -= 32;
    }
    while (a3 + v11 != a5);
  }
  return a6;
}

uint64_t std::__split_buffer<TSWPStorageTransactionObject>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

TSWPStorageTransactionObject *std::__split_buffer<TSWPStorageTransactionObject>::__destruct_at_end[abi:nn180100](uint64_t a1, TSWPStorageTransactionObject *a2)
{
  uint64_t result = *(TSWPStorageTransactionObject **)(a1 + 16);
  while (result != a2)
  {
    int v5 = *((unsigned __int16 *)result - 16);
    uint64_t result = (TSWPStorageTransactionObject *)((char *)result - 32);
    *(void *)(a1 + 16) = result;
    if (v5)
    {
      TSWPStorageTransactionObject::adjustRetainCount(result, 0);
      uint64_t result = *(TSWPStorageTransactionObject **)(a1 + 16);
    }
  }
  return result;
}

void std::vector<TSWPStorageTransactionObject>::__construct_one_at_end[abi:nn180100]<TSWPStorageTransactionObject const&>(uint64_t a1, const TSWPStorageTransactionObject *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  int v4 = *(unsigned __int16 *)a2;
  *(_WORD *)uint64_t v3 = v4;
  *(_DWORD *)(v3 + 4) = *((_DWORD *)a2 + 1);
  *(void *)(v3 + 8) = 0;
  *(void *)(v3 + 16) = 0;
  if (v4) {
    TSWPStorageTransactionObject::assignFrom((TSWPStorageTransactionObject *)v3, a2);
  }
  *(void *)(a1 + 8) = v3 + 32;
}

void sub_22376C7FC(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<TSWPStorageTransactionObject>::__push_back_slow_path<TSWPStorageTransactionObject const&>(uint64_t *a1, const TSWPStorageTransactionObject *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = (a1[1] - *a1) >> 5;
  unint64_t v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) >> 59) {
    abort();
  }
  uint64_t v8 = a1[2];
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v9 = v8 - v2;
  if (v9 >> 4 > v4) {
    unint64_t v4 = v9 >> 4;
  }
  if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v10 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v4;
  }
  uint64_t v19 = v7;
  if (v10) {
    uint64_t v11 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKit::OpticalKern::Edge::CGPointVector>>(v7, v10);
  }
  else {
    uint64_t v11 = 0;
  }
  int v12 = &v11[32 * v3];
  v16[0] = v11;
  v16[1] = v12;
  int v17 = v12;
  uint64_t v18 = &v11[32 * v10];
  int v13 = *(unsigned __int16 *)a2;
  *(_WORD *)int v12 = v13;
  *((_DWORD *)v12 + 1) = *((_DWORD *)a2 + 1);
  *((void *)v12 + 1) = 0;
  *((void *)v12 + 2) = 0;
  if (v13)
  {
    TSWPStorageTransactionObject::assignFrom((TSWPStorageTransactionObject *)v12, a2);
    int v12 = v17;
  }
  int v17 = v12 + 32;
  std::vector<TSWPStorageTransactionObject>::__swap_out_circular_buffer(a1, v16);
  uint64_t v14 = a1[1];
  std::__split_buffer<TSWPStorageTransactionObject>::~__split_buffer((uint64_t)v16);
  return v14;
}

void sub_22376C8E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TSWPStorageTransactionObject>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

const char *TSWPSmartFieldAttributeArray::className(TSWPSmartFieldAttributeArray *this)
{
  return "TSWPSmartFieldAttributeArray";
}

void *TSWPSmartFieldAttributeArray::adoptStylesheetWithMapper(void *result, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = result[2];
  if (v3)
  {
    uint64_t v6 = result;
    unint64_t v7 = 0;
    uint64_t v8 = 8;
    do
    {
      uint64_t result = *(void **)(v6[4] + v8);
      if (result)
      {
        uint64_t result = (void *)[result adoptStylesheet:a2 withMapper:a3];
        unint64_t v3 = v6[2];
      }
      ++v7;
      v8 += 16;
    }
    while (v7 < v3);
  }
  return result;
}

void TSWPSmartFieldAttributeArray::applyObjectToCharRange(TSWPAttributeArray *this, objc_object *a2, _NSRange a3, TSKAddedToDocumentContext *a4, TSWPStorageTransaction *a5)
{
  NSUInteger length = a3.length;
  NSUInteger location = a3.location;
  if (this->var1 == 12 && a3.location == TSWPAttributeArray::characterCount(this) && !length)
  {
    unint64_t var2 = this->var2;
    NSUInteger v14 = location;
    unint64_t v15 = a2;
    TSWPAttributeArray::insertAttribute(this, (const TSWPAttributeRecord *)&v14, var2, a4, a5);
    unint64_t v12 = this->var2;
    NSUInteger v14 = location + 1;
    unint64_t v15 = 0;
    TSWPAttributeArray::insertAttribute(this, (const TSWPAttributeRecord *)&v14, v12, a4, a5);
  }
  else
  {
    v13.NSUInteger location = location;
    v13.NSUInteger length = length;
    TSWPStyleAttributeArray::applyObjectToCharRange(this, a2, v13, a4, a5);
  }
}