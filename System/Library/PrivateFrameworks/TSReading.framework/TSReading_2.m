void TSWPSmartFieldAttributeArray::willReplaceCharactersInRangeWithString(TSWPAttributeArray *this, _NSRange a2, uint64_t a3, uint64_t a4, uint64_t a5, TSWPStorageTransaction *a6)
{
  NSUInteger length;
  NSUInteger location;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSUInteger v18;
  NSUInteger v19;
  TSWPAttributeRecord **p_var4;
  BOOL v21;
  NSUInteger v22;
  NSRange v23;
  BOOL v24;
  void *v25;
  uint64_t v26;
  _NSRange v27;
  TSWPAttributeRecord *v28;
  void (*v29)(TSWPAttributeArray *, uint64_t, TSWPStorageTransaction *);
  void v30[2];
  uint64_t vars8;
  NSRange v32;
  _NSRange v33;
  NSRange v34;

  length = a2.length;
  location = a2.location;
  LOBYTE(this[1].var0) = 1;
  if (this->var1 == 7
    && !TSWPStyleAttributeArray::deleteAttributesInRangeWithString((uint64_t)this, a2, a3, a4, a5, a6))
  {
    return;
  }
  if (!length || !a4)
  {
    v27.location = location;
    v27.length = length;
    TSWPStyleAttributeArray::willReplaceCharactersInRangeWithString(this, v27, a3, a4, a5, a6);
    return;
  }
  v33.location = location;
  v33.length = length;
  v13 = TSWPAttributeArray::calculateAttributeRangeForCharacterRange(this, v33);
  if (!v14) {
    return;
  }
  v15 = v13;
  v16 = v14;
  if (v13 >= this->var2)
  {
    p_var4 = &this->var4;
    v19 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else
  {
    v17 = TSWPAttributeArray::rangeForAttributeIndex(this, v13);
    v19 = v17;
    p_var4 = &this->var4;
    if (*((void *)this->var4 + 2 * v15 + 1)) {
      v21 = v17 == 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      v21 = 1;
    }
    if (!v21)
    {
      v22 = v18;
      v32.location = location;
      v32.length = length;
      v34.location = v19;
      v34.length = v22;
      v23 = NSIntersectionRange(v32, v34);
      v24 = v23.location == *MEMORY[0x263F7C7C8] && v23.length == *(void *)(MEMORY[0x263F7C7C8] + 8);
      if (!v24 && (location > v19 || location + length < v19 + v22))
      {
        v25 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        v26 = objc_msgSend(NSString, "stringWithUTF8String:", "virtual void TSWPSmartFieldAttributeArray::willReplaceCharactersInRangeWithString(NSRange, NSString *, NSUInteger, markerArray &, TSWPStorageTransaction *)");
        objc_msgSend(v25, "handleFailureInFunction:file:lineNumber:description:", v26, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPSmartFieldAttributeArray.mm"), 126, @"There should be no smart fields that overlap selections.");
      }
    }
  }
  if (v19 != location) {
    goto LABEL_33;
  }
  v28 = *p_var4;
  if (!*((void *)*p_var4 + 2 * v15 + 1))
  {
    ++v15;
    goto LABEL_28;
  }
  if (v15)
  {
    if (*((void *)v28 + 2 * v15 - 1))
    {
      v30[0] = location;
      v30[1] = 0;
      TSWPAttributeArray::insertAttribute(this, (const TSWPAttributeRecord *)v30, v15++, 0, a6);
    }
    goto LABEL_33;
  }
  if (!*((void *)v28 + 1))
  {
    v15 = 1;
LABEL_28:
    if (!--v16) {
      return;
    }
    goto LABEL_33;
  }
  TSWPAttributeArray::replaceObjectForAttributeIndex(this, 0, 0, 0, a6);
  if (--v16)
  {
    v15 = 1;
LABEL_33:
    LOBYTE(this[1].var0) = 0;
    (*((void (**)(TSWPAttributeArray *, unint64_t, uint64_t, TSWPStorageTransaction *))this->var0 + 7))(this, v15, v16, a6);
    (*((void (**)(TSWPAttributeArray *, unint64_t, TSWPStorageTransaction *))this->var0 + 29))(this, v15, a6);
    return;
  }
  if (this->var2 >= 2 && !*((void *)*p_var4 + 3))
  {
    v29 = (void (*)(TSWPAttributeArray *, uint64_t, TSWPStorageTransaction *))*((void *)this->var0 + 29);
    v29(this, 1, a6);
  }
}

void TSWPSmartFieldAttributeArray::didReplaceCharactersInRangeWithString(TSWPAttributeArray *this, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, TSWPStorageTransaction *a7, uint64_t a8)
{
  if (!a3 && a5)
  {
    unsigned int v22 = (*((uint64_t (**)(TSWPAttributeArray *, uint64_t))this->var0 + 35))(this, a8);
    uint64_t v15 = LOBYTE(this[1].var0) ? 5 : 4;
    unint64_t v16 = TSWPAttributeArray::calculateAttributeIndexForCharacterIndex(this, a2);
    uint64_t v17 = v16 >= this->var2
        ? [this->var5 length] - a5
        : TSWPAttributeArray::charIndexForAttributeIndex(this, v16);
    if (v17 == a2)
    {
      if (v16) {
        uint64_t v18 = *((void *)this->var4 + 2 * v16 - 1);
      }
      else {
        uint64_t v18 = 0;
      }
      unint64_t var2 = this->var2;
      if (v16 >= var2)
      {
        uint64_t v20 = 0;
        if (!v18) {
          goto LABEL_24;
        }
      }
      else
      {
        uint64_t v20 = *((void *)this->var4 + 2 * v16 + 1);
        if (!v18) {
          goto LABEL_24;
        }
      }
      if (!v20)
      {
        if ((v22 | 2) != 2) {
          goto LABEL_30;
        }
        if (v16 != var2) {
          goto LABEL_29;
        }
        goto LABEL_28;
      }
LABEL_24:
      if (v18 && v20)
      {
        if (v22 != 2)
        {
          if (v22) {
            goto LABEL_30;
          }
LABEL_28:
          unint64_t v23 = a2;
          uint64_t v24 = 0;
          TSWPAttributeArray::insertAttribute(this, (const TSWPAttributeRecord *)&v23, v16, 0, a7);
        }
      }
      else
      {
        if (v18 || !v20) {
          goto LABEL_30;
        }
        if (v22 < 2)
        {
          if (!v16)
          {
            unint64_t v23 = a2;
            uint64_t v24 = 0;
            TSWPAttributeArray::insertAttribute(this, (const TSWPAttributeRecord *)&v23, 0, 0, a7);
            uint64_t v15 = 4;
            unint64_t v16 = 1;
          }
          goto LABEL_33;
        }
        if (v22 != 2)
        {
LABEL_30:
          if (v16) {
            uint64_t v15 = v15;
          }
          else {
            uint64_t v15 = 4;
          }
LABEL_33:
          if (v16 <= 1) {
            unint64_t v21 = 1;
          }
          else {
            unint64_t v21 = v16;
          }
          TSWPAttributeArray::adjustCharIndexStartingAtAttributeIndex((uint64_t)this, v15, v21, a5);
          return;
        }
      }
LABEL_29:
      ++v16;
      LODWORD(v15) = 4;
      goto LABEL_30;
    }
  }

  TSWPStyleAttributeArray::didReplaceCharactersInRangeWithString(this, a2, a3, a4, a5, a6, a7);
}

uint64_t TSWPSmartFieldAttributeArray::styleInsertionBehaviorForReplacingSelection(uint64_t a1, uint64_t a2)
{
  return a2;
}

TSWPAttributeArray *TSWPSmartFieldAttributeArray::didInsertAttribute(TSWPAttributeArray *this, id *a2, TSKAddedToDocumentContext *a3, TSWPStorageTransaction *a4)
{
  if (![(TSKAddedToDocumentContext *)a3 changeTrackingSubstorage]) {
    [a2[1] setParentStorage:this->var5];
  }

  return TSWPAttributeArray::didInsertAttribute(this, (const TSWPAttributeRecord *)a2, a3, a4);
}

TSWPAttributeArray *TSWPSmartFieldAttributeArray::willDeleteAttribute(TSWPAttributeArray *this, const TSWPAttributeRecord *a2, TSWPStorageTransaction *a3)
{
  result = TSWPAttributeArray::willDeleteAttribute(this, a2, a3);
  v6 = (void *)*((void *)a2 + 1);
  if (v6)
  {
    result = (TSWPAttributeArray *)[v6 parentStorage];
    if (result == this->var5)
    {
      return (TSWPAttributeArray *)[v6 setParentStorage:0];
    }
  }
  return result;
}

uint64_t TSWPSmartFieldAttributeArray::shouldDeleteAttributeBeforeReplace(TSWPSmartFieldAttributeArray *this)
{
  objc_opt_class();
  v1 = (void *)TSUDynamicCast();

  return [v1 allowsEditing];
}

void TSWPSmartFieldAttributeArray::~TSWPSmartFieldAttributeArray(TSWPAttributeArray *this)
{
  TSWPStyleAttributeArray::~TSWPStyleAttributeArray(this);

  JUMPOUT(0x223CB8F20);
}

void TSWPAttachmentAttributeArray::~TSWPAttachmentAttributeArray(TSWPAttributeArray *this)
{
  this->var0 = (void **)&unk_26D688538;
  if (this->var2)
  {
    uint64_t v2 = 0;
    unsigned int v3 = 1;
    do
    {
      if ((id)[*((id *)this->var4 + 2 * v2 + 1) parentStorage] == this->var5) {
        [*((id *)this->var4 + 2 * v2 + 1) setParentStorage:0];
      }
      (*((void (**)(TSWPAttributeArray *, char *))this->var0 + 24))(this, (char *)this->var4 + 16 * v2);
      uint64_t v2 = v3;
    }
    while (this->var2 > v3++);
  }

  TSWPAttributeArray::~TSWPAttributeArray(this);
}

{
  uint64_t vars8;

  TSWPAttachmentAttributeArray::~TSWPAttachmentAttributeArray(this);

  JUMPOUT(0x223CB8F20);
}

void sub_22376D250(_Unwind_Exception *a1)
{
  TSWPAttributeArray::~TSWPAttributeArray(v1);
  _Unwind_Resume(a1);
}

const char *TSWPAttachmentAttributeArray::className(TSWPAttachmentAttributeArray *this)
{
  return "TSWPAttachmentAttributeArray";
}

void TSWPAttachmentAttributeArray::deleteAttributes(TSWPAttributeArray *this, unint64_t a2, unint64_t a3, TSWPStorageTransaction *a4)
{
  if ([this->var5 isDOLCSuppressed])
  {
    TSWPAttributeArray::deleteAttributes(this, a2, a3, a4);
  }
  else if (a3 == 1)
  {
    id v24 = (id)*((void *)this->var4 + 2 * a2 + 1);
    id v8 = v24;
    TSWPAttributeArray::deleteAttributes(this, a2, 1uLL, a4);
    (*((void (**)(TSWPAttributeArray *, id, TSWPStorageTransaction *))this->var0 + 33))(this, v24, a4);
  }
  else
  {
    v25 = 0;
    v26 = 0;
    v27 = 0;
    std::vector<objc_object *>::reserve((void **)&v25, a3);
    if (a3 + a2 > a2)
    {
      unint64_t v9 = a2;
      do
      {
        v10 = (void *)*((void *)this->var4 + 2 * v9 + 1);
        if (v10)
        {
          id v11 = v10;
          v12 = v26;
          if (v26 >= v27)
          {
            uint64_t v14 = (v26 - v25) >> 3;
            if ((unint64_t)(v14 + 1) >> 61) {
              abort();
            }
            unint64_t v15 = (v27 - v25) >> 2;
            if (v15 <= v14 + 1) {
              unint64_t v15 = v14 + 1;
            }
            if ((unint64_t)(v27 - v25) >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v16 = v15;
            }
            if (v16) {
              uint64_t v17 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLayoutContext *>>((uint64_t)&v27, v16);
            }
            else {
              uint64_t v17 = 0;
            }
            uint64_t v18 = &v17[8 * v14];
            *(void *)uint64_t v18 = v10;
            v13 = v18 + 8;
            uint64_t v20 = v25;
            v19 = v26;
            if (v26 != v25)
            {
              do
              {
                uint64_t v21 = *((void *)v19 - 1);
                v19 -= 8;
                *((void *)v18 - 1) = v21;
                v18 -= 8;
              }
              while (v19 != v20);
              v19 = v25;
            }
            v25 = v18;
            v26 = v13;
            v27 = &v17[8 * v16];
            if (v19) {
              operator delete(v19);
            }
          }
          else
          {
            *(void *)v26 = v10;
            v13 = v12 + 8;
          }
          v26 = v13;
        }
        ++v9;
      }
      while (v9 != a3 + a2);
    }
    TSWPAttributeArray::deleteAttributes(this, a2, a3, a4);
    unsigned int v22 = (id *)v25;
    unint64_t v23 = (id *)v26;
    if (v25 != v26)
    {
      do
      {
        (*((void (**)(TSWPAttributeArray *, id, TSWPStorageTransaction *))this->var0 + 33))(this, *v22, a4);
      }
      while (v22 != v23);
      unsigned int v22 = (id *)v25;
    }
    if (v22)
    {
      v26 = (char *)v22;
      operator delete(v22);
    }
  }
}

void sub_22376D570(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *TSWPAttachmentAttributeArray::adoptStylesheetWithMapper(void *result, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = result[2];
  if (v3)
  {
    v6 = result;
    unint64_t v7 = 0;
    uint64_t v8 = 8;
    do
    {
      result = *(void **)(v6[4] + v8);
      if (result)
      {
        result = (void *)[result adoptStylesheet:a2 withMapper:a3];
        unint64_t v3 = v6[2];
      }
      ++v7;
      v8 += 16;
    }
    while (v7 < v3);
  }
  return result;
}

void *TSWPAttachmentAttributeArray::willBeAddedToDocumentRoot(void *this, TSKDocumentRoot *a2, TSKAddedToDocumentContext *a3)
{
  unint64_t v3 = this[2];
  if (v3)
  {
    v6 = this;
    unint64_t v7 = 0;
    uint64_t v8 = 8;
    do
    {
      this = *(void **)(v6[4] + v8);
      if (this)
      {
        this = (void *)[this willBeAddedToDocumentRoot:a2 context:a3];
        unint64_t v3 = v6[2];
      }
      ++v7;
      v8 += 16;
    }
    while (v7 < v3);
  }
  return this;
}

void *TSWPAttachmentAttributeArray::wasAddedToDocumentRoot(void *this, TSKDocumentRoot *a2, TSKAddedToDocumentContext *a3)
{
  unint64_t v3 = this[2];
  if (v3)
  {
    v6 = this;
    unint64_t v7 = 0;
    uint64_t v8 = 8;
    do
    {
      this = *(void **)(v6[4] + v8);
      if (this)
      {
        this = (void *)[this wasAddedToDocumentRoot:a2 context:a3];
        unint64_t v3 = v6[2];
      }
      ++v7;
      v8 += 16;
    }
    while (v7 < v3);
  }
  return this;
}

void *TSWPAttachmentAttributeArray::willBeRemovedFromDocumentRoot(void *this, TSKDocumentRoot *a2)
{
  unint64_t v2 = this[2];
  if (v2)
  {
    v4 = this;
    unint64_t v5 = 0;
    uint64_t v6 = 8;
    do
    {
      this = *(void **)(v4[4] + v6);
      if (this)
      {
        this = (void *)[this willBeRemovedFromDocumentRoot:a2];
        unint64_t v2 = v4[2];
      }
      ++v5;
      v6 += 16;
    }
    while (v5 < v2);
  }
  return this;
}

void *TSWPAttachmentAttributeArray::wasRemovedFromDocumentRoot(void *this, TSKDocumentRoot *a2)
{
  unint64_t v2 = this[2];
  if (v2)
  {
    v4 = this;
    unint64_t v5 = 0;
    uint64_t v6 = 8;
    do
    {
      this = *(void **)(v4[4] + v6);
      if (this)
      {
        this = (void *)[this wasRemovedFromDocumentRoot:a2];
        unint64_t v2 = v4[2];
      }
      ++v5;
      v6 += 16;
    }
    while (v5 < v2);
  }
  return this;
}

uint64_t TSWPAttachmentAttributeArray::allowsNilObjects(TSWPAttachmentAttributeArray *this)
{
  return 0;
}

void sub_22376ECAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, TSWPParagraphEnumerator *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
}

uint64_t pSetupIndentAnimation(CABasicAnimation *a1, CALayer *a2, double a3)
{
  uint64_t v6 = [(CALayer *)a2 presentationLayer];
  if (!v6) {
    uint64_t v6 = a2;
  }
  [(CALayer *)v6 position];
  double v8 = v7;
  double v10 = v9 + a3;
  -[CABasicAnimation setFromValue:](a1, "setFromValue:", objc_msgSend(MEMORY[0x263F08D40], "valueWithCGPoint:"));
  -[CABasicAnimation setToValue:](a1, "setToValue:", objc_msgSend(MEMORY[0x263F08D40], "valueWithCGPoint:", v10, v8));

  return [(CALayer *)a2 addAnimation:a1 forKey:@"position"];
}

void sub_223776A8C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Unwind_Resume(a1);
}

void sub_223777558(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *__p,uint64_t a42,uint64_t a43,void *a44,uint64_t a45)
{
}

void sub_223779F28(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_223779F80(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22377A04C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22377A304(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22377A3EC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t anonymous namespace'::GetBytes(void *this, const char *a2, unsigned __int8 *a3)
{
  return [this readBytes:a2 count:a3];
}

uint64_t anonymous namespace'::SkipForward(void *this, const char *a2)
{
  return [this skipForwardBy:a2];
}

void TSWPDropCapCTState::TSWPDropCapCTState(TSWPDropCapCTState *this, const TSWPDropCapCTState *a2)
{
  *(void *)this = *(id *)a2;
  long long v4 = *(_OWORD *)((char *)a2 + 24);
  *(_OWORD *)((char *)this + 8) = *(_OWORD *)((char *)a2 + 8);
  *(_OWORD *)((char *)this + 24) = v4;
}

{
  long long v4;

  *(void *)this = *(id *)a2;
  long long v4 = *(_OWORD *)((char *)a2 + 24);
  *(_OWORD *)((char *)this + 8) = *(_OWORD *)((char *)a2 + 8);
  *(_OWORD *)((char *)this + 24) = v4;
}

uint64_t TSWPDropCapCTState::isAffectingCTAttributesEquallyTo(TSWPDropCapCTState *this, const TSWPDropCapCTState *a2)
{
  uint64_t v3 = *((void *)this + 4);
  if (!v3)
  {
    uint64_t v6 = (char *)a2 + 8;
    uint64_t v4 = *((void *)a2 + 4);
    if (v4 && (*((double *)a2 + 2) != 1.0 || (*v6 & 1) != 0)) {
      return 0;
    }
    goto LABEL_15;
  }
  if (*((double *)this + 2) == 1.0)
  {
    uint64_t v4 = *((void *)a2 + 4);
    if (!v4) {
      return 0;
    }
    int v5 = *((unsigned char *)this + 8) & 1;
  }
  else
  {
    uint64_t v4 = *((void *)a2 + 4);
    if (!v4) {
      return 0;
    }
    int v5 = 1;
  }
  uint64_t v6 = (char *)a2 + 8;
  if (*((double *)a2 + 2) == 1.0)
  {
    if (((v5 ^ *v6) & 1) == 0) {
      goto LABEL_15;
    }
    return 0;
  }
  if ((v5 & 1) == 0) {
    return 0;
  }
LABEL_15:
  BOOL v7 = *((void *)this + 3) == *((void *)a2 + 3) && v3 == v4;
  if (!v7
    || *((double *)this + 2) != *((double *)a2 + 2)
    || ((*v6 ^ *((unsigned __int8 *)this + 8)) & 1) != 0)
  {
    return 0;
  }
  double v8 = objc_msgSend((id)objc_msgSend(*(id *)this, "characterStyleOverridePropertyMap"), "propertyMapWithProperties:", +[TSWPCharacterStyle properties](TSWPCharacterStyle, "properties"));
  uint64_t v9 = objc_msgSend((id)objc_msgSend(*(id *)a2, "characterStyleOverridePropertyMap"), "propertyMapWithProperties:", +[TSWPCharacterStyle properties](TSWPCharacterStyle, "properties"));
  if (v8 == (void *)v9) {
    return 1;
  }

  return [v8 isEqual:v9];
}

uint64_t TSWPDropCapCTState::textProperties(id *this)
{
  uint64_t v1 = (void *)[*this characterStyleOverridePropertyMap];
  id v2 = +[TSWPCharacterStyle properties];

  return [v1 propertyMapWithProperties:v2];
}

TSWPCharacterStyle *TSWPDropCapCTState::modifiedCharacterStyle(TSWPDropCapCTState *this, TSSStylesheet *a2, TSWPCharacterStyle *a3)
{
  if ((*((unsigned char *)this + 8) & 1) == 0) {
    return a3;
  }
  if (a3)
  {
    uint64_t v6 = objc_msgSend((id)objc_msgSend(*(id *)this, "characterStyleOverridePropertyMap"), "propertyMapWithProperties:", +[TSWPCharacterStyle properties](TSWPCharacterStyle, "properties"));
    return (TSWPCharacterStyle *)[(TSSStylesheet *)a2 variationOfStyle:a3 propertyMap:v6];
  }
  else
  {
    BOOL v7 = -[TSSStyle initWithContext:name:overridePropertyMap:isVariation:]([TSWPCharacterStyle alloc], "initWithContext:name:overridePropertyMap:isVariation:", -[TSPObject context](a2, "context"), 0, objc_msgSend((id)objc_msgSend(*(id *)this, "characterStyleOverridePropertyMap"), "propertyMapWithProperties:", +[TSWPCharacterStyle properties](TSWPCharacterStyle, "properties")), 0);
    return v7;
  }
}

uint64_t TSWPDropCapCTState::reset(uint64_t this)
{
  *(void *)(this + 16) = 0x3FF0000000000000;
  return this;
}

void TSWPDropCapCTState::prepareForRelayout(void **a1, void *a2, void *a3)
{
  if (*a1 != a2)
  {
    TSWPDropCapCTState::TSWPDropCapCTState((uint64_t)v4, a2, a3);
    TSWPDropCapCTState::operator=((uint64_t)a1, (uint64_t)v4);
  }
}

void sub_22377AF28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

double TSWPDropCapLayoutState::clearIterationState(TSWPDropCapLayoutState *this)
{
  *((_DWORD *)this + 26) = 0;
  double result = 0.0;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((void *)this + 20) = 0;
  return result;
}

void TSWPDropCapLayoutState::TSWPDropCapLayoutState(TSWPDropCapLayoutState *this, id *a2)
{
  *((void *)this + 1) = a2[1];
  long long v4 = *((_OWORD *)a2 + 2);
  *((_OWORD *)this + 1) = *((_OWORD *)a2 + 1);
  *((_OWORD *)this + 2) = v4;
  *((void *)this + 31) = 0;
  *((void *)this + 32) = 0;
  *(void *)this = *a2;
  *((_OWORD *)this + 3) = *((_OWORD *)a2 + 3);
  long long v5 = *((_OWORD *)a2 + 4);
  long long v6 = *((_OWORD *)a2 + 5);
  long long v7 = *((_OWORD *)a2 + 7);
  *((_OWORD *)this + 6) = *((_OWORD *)a2 + 6);
  *((_OWORD *)this + 7) = v7;
  *((_OWORD *)this + 4) = v5;
  *((_OWORD *)this + 5) = v6;
  long long v8 = *((_OWORD *)a2 + 8);
  long long v9 = *((_OWORD *)a2 + 9);
  long long v10 = *((_OWORD *)a2 + 11);
  *((_OWORD *)this + 10) = *((_OWORD *)a2 + 10);
  *((_OWORD *)this + 11) = v10;
  *((_OWORD *)this + 8) = v8;
  *((_OWORD *)this + 9) = v9;
  long long v11 = *((_OWORD *)a2 + 12);
  long long v12 = *((_OWORD *)a2 + 13);
  long long v13 = *((_OWORD *)a2 + 14);
  *((void *)this + 30) = a2[30];
  *((_OWORD *)this + 13) = v12;
  *((_OWORD *)this + 14) = v13;
  *((_OWORD *)this + 12) = v11;
  id v15 = a2[31];
  uint64_t v14 = (atomic_ullong *)a2[32];
  if (v14) {
    atomic_fetch_add_explicit(v14 + 1, 1uLL, memory_order_relaxed);
  }
  unint64_t v16 = (std::__shared_weak_count *)*((void *)this + 32);
  *((void *)this + 31) = v15;
  *((void *)this + 32) = v14;
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v16);
  }
}

void sub_22377B004(_Unwind_Exception *a1)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 256);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }

  *(void *)(v1 + 8) = 0;
  _Unwind_Resume(a1);
}

void TSWPDropCapLayoutState::updateWithEndOfParagraph(TSWPDropCapLayoutState *this, double a2, int a3)
{
  if (a3) {
    char v3 = 5;
  }
  else {
    char v3 = 1;
  }
  *((unsigned char *)this + 240) = v3 | *((unsigned char *)this + 240) & 0xFA;
  uint64_t v4 = *((void *)this + 31);
  if (v4 && *((void *)this + 7) && (!*((unsigned char *)this + 80) || (a3 & 1) == 0)) {
    fmax(a2, ceil(CGRectGetMaxY(*(CGRect *)(v4 + 48))));
  }
}

uint64_t TSWPDropCapLayoutState::shouldReduceRequirementsToKeepInCurrentColumn(TSWPDropCapLayoutState *this)
{
  return *((unsigned __int8 *)this + 96) >> 7;
}

uint64_t TSWPDropCapLayoutState::updateWithEndOfColumn(uint64_t this)
{
  *(unsigned char *)(this + 240) |= 2u;
  return this;
}

uint64_t TSWPDropCapLayoutState::prepareForLayoutIteration(uint64_t this)
{
  *(void *)(this + 184) = 0;
  *(void *)(this + 224) = 0;
  *(void *)(this + 168) = 0;
  *(void *)(this + 200) = 0;
  *(void *)(this + 208) = 0;
  *(unsigned char *)(this + 240) &= 0xE7u;
  return this;
}

uint64_t TSWPDropCapLayoutState::clearLayoutState(uint64_t this)
{
  *(void *)(this + 184) = 0;
  *(void *)(this + 224) = 0;
  *(void *)(this + 168) = 0;
  *(void *)(this + 200) = 0;
  *(void *)(this + 208) = 0;
  *(unsigned char *)(this + 240) &= 0xE7u;
  return this;
}

double TSWPDropCapLayoutState::reduceRequirements(TSWPDropCapLayoutState *this)
{
  uint64_t v1 = *((void *)this + 6);
  if (v1 != 0x7FFFFFFFFFFFFFFFLL)
  {
    TSWPDropCapLayoutState::updateSpacing(this, v1 + 1);
    *((void *)this + 3) = 0x3FF0000000000000;
    *((void *)this + 23) = 0;
    *((void *)this + 28) = 0;
    double result = 0.0;
    *(_OWORD *)((char *)this + 200) = 0u;
    *((unsigned char *)this + 240) &= 0xE0u;
    *((_DWORD *)this + 26) = 0;
    *((_OWORD *)this + 7) = 0u;
    *((_OWORD *)this + 8) = 0u;
    *((_OWORD *)this + 9) = 0u;
    *((_OWORD *)this + 10) = 0u;
  }
  return result;
}

void TSWPDropCapLayoutState::prepareForRelayout(void **a1, void *a2)
{
}

uint64_t TSWPDropCapLayoutState::dropCapHeightWithGuess(uint64_t this, double a2)
{
  if (*(_DWORD *)(this + 104) == 1) {
    a2 = *(double *)(this + 128);
  }
  *(double *)(this + 120) = a2;
  return this;
}

uint64_t TSWPDropCapLayoutState::lineCapHeightWithGuess(uint64_t this, double a2)
{
  if (*(_DWORD *)(this + 104) == 1) {
    a2 = *(double *)(this + 160);
  }
  *(double *)(this + 152) = a2;
  return this;
}

BOOL TSWPDropCapLayoutState::canFinalize(TSWPDropCapLayoutState *this)
{
  if (!*((void *)this + 7) || (*((unsigned char *)this + 240) & 1) == 0) {
    return 0;
  }
  BOOL result = TSWPDropCapLayoutState::isSatifyingRequirements(this);
  if (result) {
    return *((void *)this + 29) != 0x7FFFFFFFFFFFFFFFLL;
  }
  return result;
}

double TSWPDropCapLayoutState::adjustedAttachmentPosition(TSWPDropCapLayoutState *this, CGPoint a2, TSDLayout *a3, unint64_t a4)
{
  CGFloat y = a2.y;
  double x = a2.x;
  if (*((void *)this + 7)
    && (*((unsigned char *)this + 96) & 0x20) != 0
    && *((void *)this + 5) + *((void *)this + 4) <= a4
    && *((void *)this + 31)
    && ceil(TSWPDropCapLayoutState::dropCapBottom(this)) > a2.y)
  {
    [(TSDAbstractLayout *)a3 frame];
    CGFloat v10 = v8;
    CGFloat v11 = v9;
    uint64_t v12 = *((void *)this + 31);
    CGFloat v13 = *(double *)(v12 + 56);
    CGFloat v14 = *(double *)(v12 + 72);
    double v15 = *(double *)(v12 + 64) + 18.0;
    if ((*(_DWORD *)(v12 + 24) & 0x1000) != 0) {
      double v16 = *(double *)(v12 + 48);
    }
    else {
      double v16 = *(double *)(v12 + 48) + -18.0;
    }
    double v17 = x;
    CGFloat v18 = y;
    double MaxX = CGRectGetMaxX(*(CGRect *)(&v8 - 2));
    v28.origin.double x = v16;
    v28.origin.CGFloat y = v13;
    v28.size.width = v15;
    v28.size.height = v14;
    double MinX = CGRectGetMinX(v28);
    v29.origin.double x = v16;
    v29.origin.CGFloat y = v13;
    v29.size.width = v15;
    v29.size.height = v14;
    double v25 = CGRectGetMaxX(v29);
    v30.origin.double x = x;
    v30.origin.CGFloat y = y;
    v30.size.width = v10;
    v30.size.height = v11;
    double v24 = CGRectGetMinX(v30);
    v31.origin.double x = x;
    v31.origin.CGFloat y = y;
    v31.size.width = v10;
    v31.size.height = v11;
    double MinY = CGRectGetMinY(v31);
    v32.origin.double x = v16;
    v32.origin.CGFloat y = v13;
    v32.size.width = v15;
    v32.size.height = v14;
    double MidY = CGRectGetMidY(v32);
    BOOL v22 = MaxX > MinX && v25 > v24 && MinY > MidY;
    if (v22 && (*((unsigned char *)this + 240) & 0x10) == 0)
    {
      *((unsigned char *)this + 240) |= 0x10u;
      *((CGFloat *)this + 17) = TSWPDropCapLayoutState::dropCapBottom(this);
    }
  }
  return x;
}

void sub_22377B7AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_22377B90C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_22377C6B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31)
{
  if (__p) {
    operator delete(__p);
  }
  if (a27) {
    operator delete(a27);
  }
  if (a30) {
    operator delete(a30);
  }
  _Unwind_Resume(exception_object);
}

void sub_22377CF7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, CGColorRef color, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void TSWPRangeVector::TSWPRangeVector(TSWPRangeVector *this, const _NSRange *a2)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  uint64_t v4 = (_NSRange *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLength>>((uint64_t)&this->__end_cap_, 1uLL);
  long long v6 = &v4[v5];
  _NSRange *v4 = *a2;
  long long v7 = v4 + 1;
  begin = this->__begin_;
  end = this->__end_;
  if (end != this->__begin_)
  {
    do
    {
      v4[-1] = end[-1];
      --v4;
      --end;
    }
    while (end != begin);
    end = this->__begin_;
  }
  this->__begin_ = v4;
  this->__end_ = v7;
  this->__end_cap_.__value_ = v6;
  if (end) {
    operator delete(end);
  }
  this->__end_ = v7;
}

void sub_22377D24C(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<TSWPAdornmentLine>::__base_destruct_at_end[abi:nn180100](uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 8); i != a2; i -= 80)
  {
    CGColorRelease(*(CGColorRef *)(i - 56));
  }
  *(void *)(a1 + 8) = a2;
}

void sub_22377D35C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_22377D618(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  TSWPChangeEnumerator::~TSWPChangeEnumerator((TSWPChangeEnumerator *)&a9);
  CGFloat v11 = *(void **)v9;
  if (*(void *)v9)
  {
    *(void *)(v9 + 8) = v11;
    operator delete(v11);
  }
  _Unwind_Resume(a1);
}

void sub_22377D6C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_22377D7A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_22377D878(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  CGFloat v14 = *(void **)(v12 - 56);
  if (v14)
  {
    *(void *)(v12 - 48) = v14;
    operator delete(v14);
  }
  _Unwind_Resume(exception_object);
}

void sub_22377E2BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
}

void sub_22377E440(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_22377E598(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t TSTCellDictionarySetCellAtCellID(uint64_t a1, int a2, uint64_t a3)
{
  if ((_WORD)a2 == 0xFFFF || (a2 & 0xFF0000) == 0xFF0000)
  {
    long long v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellDictionarySetCellAtCellID(TSTCellDictionary *, TSTCellID, TSTCell *)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellDictionary.m"), 100, @"can't insert an invalid cell ID");
  }
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 16));
  [*(id *)(a1 + 8) setObject:a3 forKey:(a2 << 16) | (unint64_t)BYTE2(a2)];

  return pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 16));
}

id TSTCellDictionaryCellAtCellID(uint64_t a1, int a2)
{
  if ((_WORD)a2 == 0xFFFF || (a2 & 0xFF0000) == 0xFF0000)
  {
    uint64_t v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTCell *TSTCellDictionaryCellAtCellID(TSTCellDictionary *, TSTCellID)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellDictionary.m"), 88, @"can't look up an invalid cell ID");
  }
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 16));
  id v6 = (id)[*(id *)(a1 + 8) objectForKey:(a2 << 16) | (unint64_t)BYTE2(a2)];
  pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 16));
  return v6;
}

void sub_22378070C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_2237807E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void sub_223780844(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,std::__unordered_map_hasher<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectHasher,TSTTableDataObjectEqual,true>,std::__unordered_map_equal<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectEqual,TSTTableDataObjectHasher,true>,std::allocator<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,std::__unordered_map_hasher<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectHasher,TSTTableDataObjectEqual,true>,std::__unordered_map_equal<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectEqual,TSTTableDataObjectHasher,true>,std::allocator<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>>>::__deallocate_node(a1, *(id **)(a1 + 16));
  id v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,std::__unordered_map_hasher<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectHasher,TSTTableDataObjectEqual,true>,std::__unordered_map_equal<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectEqual,TSTTableDataObjectHasher,true>,std::allocator<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>>>::__deallocate_node(uint64_t a1, id *a2)
{
  if (a2)
  {
    id v2 = a2;
    do
    {
      char v3 = (id *)*v2;

      operator delete(v2);
      id v2 = v3;
    }
    while (v3);
  }
}

uint64_t **std::__hash_table<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,std::__unordered_map_hasher<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectHasher,TSTTableDataObjectEqual,true>,std::__unordered_map_equal<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectEqual,TSTTableDataObjectHasher,true>,std::allocator<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>>>::find<SFUtility::ObjcSharedPtr<TSTTableDataObject>>(void *a1, id *a2)
{
  unint64_t v4 = [*a2 hash];
  int8x8_t v5 = (int8x8_t)a1[1];
  if (!*(void *)&v5) {
    return 0;
  }
  unint64_t v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v9 = v4;
    if (v4 >= *(void *)&v5) {
      unint64_t v9 = v4 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v9 = (*(void *)&v5 - 1) & v4;
  }
  CGFloat v10 = *(uint64_t ****)(*a1 + 8 * v9);
  if (!v10) {
    return 0;
  }
  for (uint64_t i = *v10; i; uint64_t i = (uint64_t **)*i)
  {
    unint64_t v12 = (unint64_t)i[1];
    if (v12 == v6)
    {
      if ([i[2] isEqual:*a2]) {
        return i;
      }
    }
    else
    {
      if (v8 > 1)
      {
        if (v12 >= *(void *)&v5) {
          v12 %= *(void *)&v5;
        }
      }
      else
      {
        v12 &= *(void *)&v5 - 1;
      }
      if (v12 != v9) {
        return 0;
      }
    }
  }
  return i;
}

void *std::__hash_table<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,std::__unordered_map_hasher<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectHasher,TSTTableDataObjectEqual,true>,std::__unordered_map_equal<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectEqual,TSTTableDataObjectHasher,true>,std::allocator<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>>>::__emplace_unique_key_args<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::pair<SFUtility::ObjcSharedPtr<TSTTableDataObject> const,unsigned int>>(uint64_t a1, id *a2, uint64_t a3)
{
  unint64_t v7 = [*a2 hash];
  unint64_t v8 = v7;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = v7;
      if (v7 >= v9) {
        unint64_t v3 = v7 % v9;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v7;
    }
    unint64_t v12 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v12)
    {
      for (uint64_t i = *v12; i; uint64_t i = *(void **)i)
      {
        unint64_t v14 = *((void *)i + 1);
        if (v14 == v8)
        {
          if ([*((id *)i + 2) isEqual:*a2]) {
            return i;
          }
        }
        else
        {
          if (v11 > 1)
          {
            if (v14 >= v9) {
              v14 %= v9;
            }
          }
          else
          {
            v14 &= v9 - 1;
          }
          if (v14 != v3) {
            break;
          }
        }
      }
    }
  }
  double v15 = (void *)(a1 + 16);
  uint64_t i = operator new(0x20uLL);
  *(void *)uint64_t i = 0;
  *((void *)i + 1) = v8;
  double v16 = *(void **)a3;
  *((void *)i + 2) = *(void *)a3;
  id v17 = v16;
  *((_DWORD *)i + 6) = *(_DWORD *)(a3 + 8);
  float v18 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v19 = *(float *)(a1 + 32);
  if (!v9 || (float)(v19 * (float)v9) < v18)
  {
    BOOL v20 = 1;
    if (v9 >= 3) {
      BOOL v20 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v9);
    unint64_t v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22) {
      size_t v23 = v22;
    }
    else {
      size_t v23 = v21;
    }
    std::__hash_table<std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::__unordered_map_hasher<EQKit::StemStretch::Key,std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::hash<EQKit::StemStretch::Key>,std::equal_to<EQKit::StemStretch::Key>,true>,std::__unordered_map_equal<EQKit::StemStretch::Key,std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::equal_to<EQKit::StemStretch::Key>,std::hash<EQKit::StemStretch::Key>,true>,std::allocator<std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>>>::__rehash<true>(a1, v23);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v24 = *(void *)a1;
  double v25 = *(void **)(*(void *)a1 + 8 * v3);
  if (v25)
  {
    *(void *)uint64_t i = *v25;
LABEL_38:
    void *v25 = i;
    goto LABEL_39;
  }
  *(void *)uint64_t i = *v15;
  *double v15 = i;
  *(void *)(v24 + 8 * v3) = v15;
  if (*(void *)i)
  {
    unint64_t v26 = *(void *)(*(void *)i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v26 >= v9) {
        v26 %= v9;
      }
    }
    else
    {
      v26 &= v9 - 1;
    }
    double v25 = (void *)(*(void *)a1 + 8 * v26);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_223780C38(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,void *>>>::operator()[abi:nn180100](v2, v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,void *>>>::operator()[abi:nn180100](uint64_t a1, id *a2)
{
  if (*(unsigned char *)(a1 + 8))
  {
  }
  else if (!a2)
  {
    return;
  }

  operator delete(a2);
}

uint64_t *std::__hash_table<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,std::__unordered_map_hasher<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectHasher,TSTTableDataObjectEqual,true>,std::__unordered_map_equal<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectEqual,TSTTableDataObjectHasher,true>,std::allocator<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>>>::__erase_unique<SFUtility::ObjcSharedPtr<TSTTableDataObject>>(void *a1, id *a2)
{
  BOOL result = (uint64_t *)std::__hash_table<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,std::__unordered_map_hasher<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectHasher,TSTTableDataObjectEqual,true>,std::__unordered_map_equal<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectEqual,TSTTableDataObjectHasher,true>,std::allocator<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>>>::find<SFUtility::ObjcSharedPtr<TSTTableDataObject>>(a1, a2);
  if (result)
  {
    std::__hash_table<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,std::__unordered_map_hasher<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectHasher,TSTTableDataObjectEqual,true>,std::__unordered_map_equal<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectEqual,TSTTableDataObjectHasher,true>,std::allocator<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>>>::erase(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,std::__unordered_map_hasher<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectHasher,TSTTableDataObjectEqual,true>,std::__unordered_map_equal<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectEqual,TSTTableDataObjectHasher,true>,std::allocator<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>>>::erase(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  std::__hash_table<std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::__unordered_map_hasher<EQKit::StemStretch::Key,std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::hash<EQKit::StemStretch::Key>,std::equal_to<EQKit::StemStretch::Key>,true>,std::__unordered_map_equal<EQKit::StemStretch::Key,std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::equal_to<EQKit::StemStretch::Key>,std::hash<EQKit::StemStretch::Key>,true>,std::allocator<std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>>>::remove(a1, a2, (uint64_t)&__p);
  unint64_t v3 = (id *)__p;
  __p = 0;
  if (v3)
  {
    if (v6) {

    }
    operator delete(v3);
  }
  return v2;
}

void std::__hash_table<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,std::__unordered_map_hasher<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectHasher,TSTTableDataObjectEqual,true>,std::__unordered_map_equal<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectEqual,TSTTableDataObjectHasher,true>,std::allocator<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>>>::clear(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,std::__unordered_map_hasher<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectHasher,TSTTableDataObjectEqual,true>,std::__unordered_map_equal<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectEqual,TSTTableDataObjectHasher,true>,std::allocator<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>>>::__deallocate_node(a1, *(id **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
}

void sub_223781620(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36)
{
  _Block_object_dispose(&a36, 8);
  _Block_object_dispose((const void *)(v36 - 200), 8);
  _Block_object_dispose((const void *)(v36 - 168), 8);
  _Block_object_dispose((const void *)(v36 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_223781E20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__25(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__25(uint64_t a1)
{
}

void sub_223781F84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t TSTCellStorageHeaderFlagsForStorage(uint64_t result)
{
  if (result) {
    return *(unsigned __int16 *)(result + 4);
  }
  return result;
}

unsigned __int8 *TSTCellStorageFormatFlagsForStorage(unsigned __int8 *result)
{
  if (result)
  {
    if (*result < 2u) {
      return 0;
    }
    else {
      return (unsigned __int8 *)*((unsigned __int16 *)result + 5);
    }
  }
  return result;
}

uint64_t p_TSTCellStorageExtraSizeForHeaderFlags(int a1)
{
  if (a1)
  {
    unsigned __int16 v1 = (2 * a1) & 4;
    if ((a1 & 0x80) != 0) {
      v1 += 4;
    }
    if ((a1 & 0x400) != 0) {
      v1 += 4;
    }
    if ((a1 & 0x800) != 0) {
      v1 += 4;
    }
    if ((a1 & 4) != 0) {
      v1 += 4;
    }
    if ((a1 & 8) != 0) {
      v1 += 4;
    }
    if ((a1 & 0x100) != 0) {
      v1 += 4;
    }
    if ((a1 & 0x200) != 0) {
      v1 += 4;
    }
    if ((a1 & 0x1000) != 0) {
      v1 += 4;
    }
    if ((a1 & 0x10) != 0) {
      v1 += 4;
    }
    if ((a1 & 0x20) != 0) {
      v1 += 8;
    }
    if ((a1 & 0x40) != 0) {
      v1 += 8;
    }
  }
  else
  {
    return 0;
  }
  return v1;
}

uint64_t p_TSTV1CellStorageSizeForHeaderFlags(int a1)
{
  if (a1) {
    return (unsigned __int16)(p_TSTCellStorageExtraSizeForHeaderFlags(a1) + 8);
  }
  else {
    return 8;
  }
}

uint64_t TSTCellStorageSizeForHeaderFlags(int a1, int a2)
{
  unsigned __int16 v2 = 12;
  if (a2 | a1)
  {
    char v3 = a2;
    __int16 v4 = p_TSTCellStorageExtraSizeForHeaderFlags(a1);
    if (v3) {
      __int16 v5 = 16;
    }
    else {
      __int16 v5 = 12;
    }
    unsigned __int16 v6 = v4 + v5;
    if ((v3 & 8) != 0) {
      v6 += 4;
    }
    if ((v3 & 2) != 0) {
      v6 += 4;
    }
    if ((v3 & 4) != 0) {
      v6 += 4;
    }
    if ((v3 & 0x20) != 0) {
      v6 += 4;
    }
    if ((v3 & 0x10) != 0) {
      v6 += 4;
    }
    if ((v3 & 0x40) != 0) {
      v6 += 4;
    }
    if (v3 < 0) {
      return (unsigned __int16)(v6 + 4);
    }
    else {
      return v6;
    }
  }
  return v2;
}

uint64_t TSTCellStorageHeaderFlagsForCell(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 56)) {
      unsigned int v1 = (2 * (*(void *)(a1 + 40) != 0)) | 0x80;
    }
    else {
      unsigned int v1 = 2 * (*(void *)(a1 + 40) != 0);
    }
    if ((*(_DWORD *)(a1 + 104) - 1) < 0xFFFFFFFE) {
      v1 |= 4u;
    }
    if (*(void *)(a1 + 72) || *(_DWORD *)(a1 + 64)) {
      v1 |= 0x200u;
    }
    if (*(void *)(a1 + 88) || *(_DWORD *)(a1 + 80)) {
      v1 |= 0x1000u;
    }
    int v2 = BYTE1(*(_DWORD *)(a1 + 8));
    if (v2 == 3) {
      v1 |= 0x10u;
    }
  }
  else
  {
    int v2 = 0;
    unsigned int v1 = 0;
  }
  if ((v2 & 0xFFFFFFFB) == 2 || v2 == 7) {
    v1 |= 0x20u;
  }
  if (v2 == 5) {
    return v1 | 0x40;
  }
  else {
    return v1;
  }
}

uint64_t TSTCellStorageFormatFlagsForCell(void *a1)
{
  if (!a1) {
    return 0;
  }
  int v2 = (void *)a1[19];
  if (v2)
  {
    [v2 getFormatStruct];
    uint64_t v3 = (v12 - 1) < 0xFFFFFFFE;
  }
  else
  {
    uint64_t v3 = 0;
  }
  __int16 v4 = (void *)a1[21];
  if (v4)
  {
    [v4 getFormatStruct];
    if ((v12 - 1) >= 0xFFFFFFFE) {
      uint64_t v3 = v3;
    }
    else {
      uint64_t v3 = v3 | 8;
    }
  }
  __int16 v5 = (void *)a1[25];
  if (v5)
  {
    [v5 getFormatStruct];
    if ((v12 - 1) >= 0xFFFFFFFE) {
      uint64_t v3 = v3;
    }
    else {
      uint64_t v3 = v3 | 2;
    }
  }
  unsigned __int16 v6 = (void *)a1[23];
  if (v6)
  {
    [v6 getFormatStruct];
    if ((v12 - 1) >= 0xFFFFFFFE) {
      uint64_t v3 = v3;
    }
    else {
      uint64_t v3 = v3 | 4;
    }
  }
  unint64_t v7 = (void *)a1[27];
  if (v7)
  {
    [v7 getFormatStruct];
    if ((v12 - 1) >= 0xFFFFFFFE) {
      uint64_t v3 = v3;
    }
    else {
      uint64_t v3 = v3 | 0x10;
    }
  }
  unint64_t v8 = (void *)a1[29];
  if (v8)
  {
    [v8 getFormatStruct];
    if ((v12 - 1) >= 0xFFFFFFFE) {
      uint64_t v3 = v3;
    }
    else {
      uint64_t v3 = v3 | 0x20;
    }
  }
  unint64_t v9 = (void *)a1[31];
  if (v9)
  {
    [v9 getFormatStruct];
    if ((v12 - 1) >= 0xFFFFFFFE) {
      uint64_t v3 = v3;
    }
    else {
      uint64_t v3 = v3 | 0x40;
    }
  }
  uint8x8_t v10 = (void *)a1[33];
  if (v10)
  {
    [v10 getFormatStruct];
    if ((v12 - 1) >= 0xFFFFFFFE) {
      return v3;
    }
    else {
      return v3 | 0x80;
    }
  }
  return v3;
}

unsigned __int8 *TSTCellStorageVersionAssert(unsigned __int8 *result)
{
  if (*result >= 4u)
  {
    unsigned int v1 = result;
    int v2 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v3 = [NSString stringWithUTF8String:"void TSTCellStorageVersionAssert(TSTCellStorage *)"];
    return (unsigned __int8 *)objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.mm"), 250, @"Can't parse cell storage header version %d!", *v1);
  }
  return result;
}

uint64_t TSTCellToCellStorage(uint64_t a1, unsigned __int8 *a2)
{
  *a2 = 3;
  if (a1) {
    unsigned __int8 v4 = *(unsigned char *)(a1 + 9);
  }
  else {
    unsigned __int8 v4 = 0;
  }
  a2[2] = v4;
  unint64_t v5 = *(void *)(a2 + 4) & 0xFFFFFFFFFFFF0000 | TSTCellStorageHeaderFlagsForCell(a1);
  *(void *)(a2 + 4) = v5;
  if (a1)
  {
    *(void *)(a2 + 4) = v5 & 0xFFFFFFFF0000FFFFLL | ((unint64_t)*(unsigned __int16 *)(a1 + 10) << 16);
    unsigned __int8 v6 = *(unsigned char *)(a1 + 272);
  }
  else
  {
    unsigned __int8 v6 = 0;
    *(void *)(a2 + 4) = v5 & 0xFFFFFFFF0000FFFFLL;
  }
  a2[3] = v6;
  unsigned __int16 v7 = TSTCellStorageFormatFlagsForCell((void *)a1);
  uint64_t v8 = *(void *)(a2 + 4);
  *(void *)(a2 + 4) = v8 & 0xFFFFFFFFFFFFLL | ((unint64_t)v7 << 48);
  if (!a1)
  {
    *(void *)(a2 + 4) = v8 | ((unint64_t)v7 << 48);
    int v12 = (unsigned __int16)v8;
    int v10 = v7;
    if ((v8 & 2) != 0)
    {
      *((_DWORD *)a2 + 3) = 0;
      int v15 = v8 & 0xFFFD;
      if ((v8 & 0x80) == 0)
      {
        unsigned int v11 = 4;
        if ((v8 & 4) == 0) {
          goto LABEL_47;
        }
LABEL_38:
        double v16 = &a2[v11 + 12];
        if (!a1)
        {
          int v20 = 0;
          LOWORD(v12) = v15;
          goto LABEL_52;
        }
        LOWORD(v12) = v15;
LABEL_51:
        int v20 = *(_DWORD *)(a1 + 100);
LABEL_52:
        *(_DWORD *)double v16 = v20;
        v11 += 4;
        v12 &= 0xFFFBu;
        if ((v12 & 0x200) == 0)
        {
LABEL_57:
          if ((v12 & 0x1000) == 0)
          {
            if ((v12 & 0x10) != 0) {
              goto LABEL_123;
            }
            goto LABEL_59;
          }
          v38 = &a2[v11 + 12];
          if (a1) {
            goto LABEL_89;
          }
          int v39 = 0;
LABEL_122:
          *(_DWORD *)v38 = v39;
          v11 += 4;
          v12 &= 0xEFFFu;
          if ((v12 & 0x10) != 0)
          {
LABEL_123:
            v47 = &a2[v11 + 12];
            if (!a1) {
              goto LABEL_128;
            }
            goto LABEL_124;
          }
LABEL_59:
          if ((v12 & 0x20) != 0) {
            goto LABEL_130;
          }
          goto LABEL_60;
        }
LABEL_53:
        unint64_t v21 = &a2[v11 + 12];
        if (!a1)
        {
          int v22 = 0;
          goto LABEL_56;
        }
LABEL_54:
        int v22 = *(_DWORD *)(a1 + 64);
LABEL_56:
        *(_DWORD *)unint64_t v21 = v22;
        v11 += 4;
        v12 &= 0xFDFFu;
        goto LABEL_57;
      }
      int v19 = 0;
      float v18 = a2 + 16;
      int v17 = 4;
      LOWORD(v12) = v12 & 0xFFFD;
    }
    else
    {
      if ((v8 & 0x80) == 0)
      {
        unsigned int v11 = 0;
        if ((v8 & 4) == 0)
        {
          if ((v8 & 0x200) == 0)
          {
            if ((v8 & 0x1000) == 0)
            {
              if ((v8 & 0x10) == 0)
              {
                if ((v8 & 0x20) == 0)
                {
                  if ((v8 & 0x40) != 0)
                  {
                    CGFloat v13 = 0;
                    unint64_t v14 = a2 + 12;
                    goto LABEL_164;
                  }
                  goto LABEL_61;
                }
                v51 = a2 + 12;
                goto LABEL_153;
              }
              v47 = a2 + 12;
              goto LABEL_128;
            }
            int v39 = 0;
            v38 = a2 + 12;
            goto LABEL_122;
          }
          int v22 = 0;
          unint64_t v21 = a2 + 12;
          goto LABEL_56;
        }
        int v20 = 0;
        double v16 = a2 + 12;
        goto LABEL_52;
      }
      int v17 = 0;
      int v19 = 0;
      float v18 = a2 + 12;
    }
LABEL_46:
    *float v18 = v19;
    unsigned int v11 = v17 + 4;
    int v15 = v12 & 0xFF7F;
    if ((v12 & 4) == 0)
    {
LABEL_47:
      int v12 = v15;
      if ((v15 & 0x200) == 0) {
        goto LABEL_57;
      }
      goto LABEL_53;
    }
    goto LABEL_38;
  }
  *(void *)(a2 + 4) = v8 | ((unint64_t)v7 << 48) | ((unint64_t)*(unsigned __int16 *)(a1 + 96) << 32);
  __int16 v9 = v8;
  int v10 = v7;
  if ((v8 & 2) == 0)
  {
    if ((v8 & 0x80) == 0)
    {
      unsigned int v11 = 0;
      if ((v8 & 4) == 0)
      {
        if ((v8 & 0x200) == 0)
        {
          if ((v8 & 0x1000) == 0)
          {
            if ((v8 & 0x10) == 0)
            {
              if ((v8 & 0x20) == 0)
              {
                if ((v8 & 0x40) == 0)
                {
                  if (!(_WORD)v8) {
                    goto LABEL_63;
                  }
LABEL_62:
                  size_t v23 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
                  uint64_t v24 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellToCellStorage(TSTCell *, TSTCellStorage *)");
                  objc_msgSend(v23, "handleFailureInFunction:file:lineNumber:description:", v24, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.mm"), 392, @"Failed to process all storage elements!");
                  goto LABEL_63;
                }
                unint64_t v14 = a2 + 12;
LABEL_157:
                if (*(unsigned char *)(a1 + 9))
                {
                  if (*(unsigned char *)(a1 + 9) == 5)
                  {
                    CGFloat v13 = *(void **)(a1 + 16);
LABEL_163:
                    LOWORD(v12) = v9;
LABEL_164:
                    [v13 timeIntervalSinceReferenceDate];
                    *(void *)unint64_t v14 = v60;
                    v11 += 8;
                    if ((v12 & 0xFFBF) != 0) {
                      goto LABEL_62;
                    }
                    goto LABEL_63;
                  }
                  v58 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
                  uint64_t v59 = [NSString stringWithUTF8String:"NSDate *TSTCellDateValue(TSTCell *)"];
                  objc_msgSend(v58, "handleFailureInFunction:file:lineNumber:description:", v59, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 1021, @"can't get date value from a non-date cell: %p", a1);
                }
                CGFloat v13 = 0;
                goto LABEL_163;
              }
              v51 = a2 + 12;
              goto LABEL_132;
            }
            v47 = a2 + 12;
            goto LABEL_125;
          }
          v38 = a2 + 12;
          LOWORD(v12) = v9;
          goto LABEL_89;
        }
        unint64_t v21 = a2 + 12;
        LOWORD(v12) = v9;
        goto LABEL_54;
      }
      double v16 = a2 + 12;
      LOWORD(v12) = v9;
      goto LABEL_51;
    }
    int v17 = 0;
    float v18 = a2 + 12;
    LOWORD(v12) = v9;
    goto LABEL_42;
  }
  *((_DWORD *)a2 + 3) = *(_DWORD *)(a1 + 32);
  LOWORD(v12) = v8 & 0xFFFD;
  if ((v8 & 0x80) != 0)
  {
    float v18 = a2 + 16;
    int v17 = 4;
LABEL_42:
    int v19 = *(_DWORD *)(a1 + 48);
    goto LABEL_46;
  }
  if ((v8 & 4) != 0)
  {
    double v16 = a2 + 16;
    unsigned int v11 = 4;
    goto LABEL_51;
  }
  if ((v8 & 0x200) != 0)
  {
    unint64_t v21 = a2 + 16;
    unsigned int v11 = 4;
    goto LABEL_54;
  }
  if ((v8 & 0x1000) != 0)
  {
    v38 = a2 + 16;
    unsigned int v11 = 4;
LABEL_89:
    int v39 = *(_DWORD *)(a1 + 80);
    goto LABEL_122;
  }
  if ((v8 & 0x10) != 0)
  {
    v47 = a2 + 16;
    unsigned int v11 = 4;
LABEL_124:
    __int16 v9 = v12;
LABEL_125:
    if (*(unsigned __int8 *)(a1 + 9) << 8 == 768)
    {
      int v48 = *(_DWORD *)(a1 + 16);
      goto LABEL_129;
    }
    LOWORD(v12) = v9;
LABEL_128:
    v49 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v50 = [NSString stringWithUTF8String:"TSTTableDataListKey TSTCellStringID(TSTCell *)"];
    objc_msgSend(v49, "handleFailureInFunction:file:lineNumber:description:", v50, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 948, @"can't get string ID from non-string cell: %p", a1);
    int v48 = 0;
    __int16 v9 = v12;
LABEL_129:
    *(_DWORD *)v47 = v48;
    v11 += 4;
    int v12 = v9 & 0xFFEF;
    if ((v9 & 0x20) != 0)
    {
LABEL_130:
      v51 = &a2[v11 + 12];
      if (a1)
      {
LABEL_131:
        __int16 v9 = v12;
LABEL_132:
        if ((*(_DWORD *)(a1 + 8) & 0xFB00) == 0x200 || BYTE1(*(_DWORD *)(a1 + 8)) == 7)
        {
          uint64_t v53 = *(void *)(a1 + 16);
        }
        else
        {
          uint64_t v53 = 0;
          if (BYTE1(*(_DWORD *)(a1 + 8)))
          {
            v54 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v55 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
            objc_msgSend(v54, "handleFailureInFunction:file:lineNumber:description:", v55, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", a1);
          }
        }
LABEL_154:
        *(void *)v51 = v53;
        v11 += 8;
        int v12 = v9 & 0xFFDF;
        if ((v9 & 0x40) != 0)
        {
LABEL_155:
          unint64_t v14 = &a2[v11 + 12];
          if (!a1)
          {
            CGFloat v13 = 0;
            goto LABEL_164;
          }
          goto LABEL_156;
        }
LABEL_61:
        if (!v12) {
          goto LABEL_63;
        }
        goto LABEL_62;
      }
LABEL_153:
      v56 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v57 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
      objc_msgSend(v56, "handleFailureInFunction:file:lineNumber:description:", v57, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 889, @"invalid nil value for '%s'", "cell");
      uint64_t v53 = 0;
      __int16 v9 = v12;
      goto LABEL_154;
    }
LABEL_60:
    if ((v12 & 0x40) != 0) {
      goto LABEL_155;
    }
    goto LABEL_61;
  }
  if ((v8 & 0x20) != 0)
  {
    v51 = a2 + 16;
    unsigned int v11 = 4;
    goto LABEL_131;
  }
  if ((v8 & 0x40) != 0)
  {
    unint64_t v14 = a2 + 16;
    unsigned int v11 = 4;
LABEL_156:
    __int16 v9 = v12;
    goto LABEL_157;
  }
  unsigned int v11 = 4;
  if ((v8 & 0xFFFD) != 0) {
    goto LABEL_62;
  }
LABEL_63:
  if (v7)
  {
    if (a1) {
      int v34 = *(_DWORD *)(a1 + 144);
    }
    else {
      int v34 = 0;
    }
    *(_DWORD *)&a2[v11 + 12] = v34;
    v11 += 4;
    v10 &= 0xFFFEu;
    if ((v10 & 8) == 0)
    {
LABEL_65:
      if ((v10 & 2) == 0) {
        goto LABEL_66;
      }
      goto LABEL_96;
    }
  }
  else if ((v10 & 8) == 0)
  {
    goto LABEL_65;
  }
  if (a1) {
    int v40 = *(_DWORD *)(a1 + 160);
  }
  else {
    int v40 = 0;
  }
  *(_DWORD *)&a2[v11 + 12] = v40;
  v11 += 4;
  v10 &= ~8u;
  if ((v10 & 2) == 0)
  {
LABEL_66:
    if ((v10 & 4) == 0) {
      goto LABEL_67;
    }
    goto LABEL_100;
  }
LABEL_96:
  if (a1) {
    int v41 = *(_DWORD *)(a1 + 192);
  }
  else {
    int v41 = 0;
  }
  *(_DWORD *)&a2[v11 + 12] = v41;
  v11 += 4;
  v10 &= 0xFFFDu;
  if ((v10 & 4) == 0)
  {
LABEL_67:
    if ((v10 & 0x10) == 0) {
      goto LABEL_68;
    }
    goto LABEL_104;
  }
LABEL_100:
  if (a1) {
    int v42 = *(_DWORD *)(a1 + 176);
  }
  else {
    int v42 = 0;
  }
  *(_DWORD *)&a2[v11 + 12] = v42;
  v11 += 4;
  v10 &= 0xFFFBu;
  if ((v10 & 0x10) == 0)
  {
LABEL_68:
    if ((v10 & 0x20) == 0) {
      goto LABEL_69;
    }
    goto LABEL_108;
  }
LABEL_104:
  if (a1) {
    int v43 = *(_DWORD *)(a1 + 208);
  }
  else {
    int v43 = 0;
  }
  *(_DWORD *)&a2[v11 + 12] = v43;
  v11 += 4;
  v10 &= 0xFFEFu;
  if ((v10 & 0x20) == 0)
  {
LABEL_69:
    if ((v10 & 0x40) == 0) {
      goto LABEL_70;
    }
    goto LABEL_112;
  }
LABEL_108:
  if (a1) {
    int v44 = *(_DWORD *)(a1 + 224);
  }
  else {
    int v44 = 0;
  }
  *(_DWORD *)&a2[v11 + 12] = v44;
  v11 += 4;
  v10 &= 0xFFDFu;
  if ((v10 & 0x40) == 0)
  {
LABEL_70:
    if ((v10 & 0x80) == 0) {
      goto LABEL_71;
    }
    goto LABEL_116;
  }
LABEL_112:
  if (a1) {
    int v45 = *(_DWORD *)(a1 + 240);
  }
  else {
    int v45 = 0;
  }
  *(_DWORD *)&a2[v11 + 12] = v45;
  LOWORD(v11) = v11 + 4;
  v10 &= 0xFFBFu;
  if ((v10 & 0x80) == 0)
  {
LABEL_71:
    if (!v10) {
      goto LABEL_73;
    }
    goto LABEL_72;
  }
LABEL_116:
  if (a1) {
    int v46 = *(_DWORD *)(a1 + 256);
  }
  else {
    int v46 = 0;
  }
  *(_DWORD *)&a2[(unsigned __int16)v11 + 12] = v46;
  LOWORD(v11) = v11 + 4;
  if ((v10 & 0xFF7F) != 0)
  {
LABEL_72:
    double v25 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v26 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellToCellStorage(TSTCell *, TSTCellStorage *)");
    objc_msgSend(v25, "handleFailureInFunction:file:lineNumber:description:", v26, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.mm"), 467, @"Failed to process all format storage elements!");
  }
LABEL_73:
  unint64_t v27 = *(void *)(a2 + 4);
  int v28 = (unsigned __int16)v27;
  unsigned int v29 = *a2;
  if (v29 <= 1) {
    int v30 = 0;
  }
  else {
    int v30 = HIWORD(v27);
  }
  uint64_t v31 = (unsigned __int16)v11 + 12;
  if (v31 != TSTCellStorageSizeForHeaderFlags((unsigned __int16)*(void *)(a2 + 4), v30))
  {
    NSLog((NSString *)@"hate");
    unint64_t v27 = *(void *)(a2 + 4);
    unsigned int v29 = *a2;
    int v28 = (unsigned __int16)v27;
  }
  if (v29 <= 1) {
    int v32 = 0;
  }
  else {
    int v32 = HIWORD(v27);
  }
  uint64_t result = TSTCellStorageSizeForHeaderFlags(v28, v32);
  if (v31 != result)
  {
    v35 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v36 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellToCellStorage(TSTCell *, TSTCellStorage *)");
    uint64_t v37 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.mm"];
    return [v35 handleFailureInFunction:v36 file:v37 lineNumber:474 description:@"Size miscalculation!"];
  }
  return result;
}

uint64_t TSTV1CellStorageToCell(unsigned __int8 *a1, uint64_t a2)
{
  if (*a1 >= 2u)
  {
    unsigned __int8 v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTV1CellStorageToCell(TSTV1CellStorage *, TSTCell *)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.mm"), 482, @"wrong version of the storage used here");
  }
  unsigned __int8 v6 = a1[2];
  TSTCellClearValue(a2);
  *(unsigned char *)(a2 + 9) = v6;
  *(_WORD *)(a2 + 10) = *((_WORD *)a1 + 3);
  *(unsigned char *)(a2 + 272) = a1[3];
  int v7 = *((_DWORD *)a1 + 1);
  if ((v7 & 2) != 0)
  {
    *(_DWORD *)(a2 + 32) = *((_DWORD *)a1 + 2);
    int v9 = v7 & 0xFFFC;
    unsigned int v8 = 4;
    if ((v7 & 0x80) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  unsigned int v8 = 0;
  int v9 = *((_DWORD *)a1 + 1) & 0xFFFE;
  if ((v7 & 0x80) != 0)
  {
LABEL_7:
    *(_DWORD *)(a2 + 48) = *(_DWORD *)&a1[v8 + 8];
    v8 += 4;
    v9 &= 0xFF7Eu;
  }
LABEL_8:
  if ((v9 & 4) != 0)
  {
    *(_DWORD *)(a2 + 100) = *(_DWORD *)&a1[v8 + 8];
    v8 += 4;
    v9 &= ~4u;
    if ((v9 & 0x200) == 0)
    {
LABEL_10:
      if ((v9 & 0x1000) == 0) {
        goto LABEL_11;
      }
      goto LABEL_20;
    }
  }
  else if ((v9 & 0x200) == 0)
  {
    goto LABEL_10;
  }
  *(_DWORD *)(a2 + 64) = *(_DWORD *)&a1[v8 + 8];
  v8 += 4;
  v9 &= 0xFDFFu;
  if ((v9 & 0x1000) == 0)
  {
LABEL_11:
    if ((v9 & 0x10) == 0) {
      goto LABEL_12;
    }
    goto LABEL_21;
  }
LABEL_20:
  *(_DWORD *)(a2 + 80) = *(_DWORD *)&a1[v8 + 8];
  v8 += 4;
  v9 &= 0xEFFFu;
  if ((v9 & 0x10) == 0)
  {
LABEL_12:
    if ((v9 & 0x20) == 0) {
      goto LABEL_13;
    }
    goto LABEL_30;
  }
LABEL_21:
  if (*(unsigned __int8 *)(a2 + 9) << 8 == 768)
  {
    *(_DWORD *)(a2 + 16) = *(_DWORD *)&a1[v8 + 8];
  }
  else
  {
    int v17 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v18 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellSetStringID(TSTCell *, TSTTableDataListKey)");
    objc_msgSend(v17, "handleFailureInFunction:file:lineNumber:description:", v18, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 958, @"can't set string ID on non-string cell: %p", a2);
  }
  v8 += 4;
  v9 &= 0xFFEFu;
  if ((v9 & 0x20) == 0)
  {
LABEL_13:
    if ((v9 & 0x40) == 0) {
      goto LABEL_14;
    }
    goto LABEL_49;
  }
LABEL_30:
  int v19 = (double *)&a1[v8 + 8];
  int v20 = a1[2];
  if (v20 == 7)
  {
    double v24 = *v19;
    int v25 = *(_DWORD *)(a2 + 8);
    if ((v25 & 0xFF00) == 0)
    {
      TSTCellClearValue(a2);
      *(unsigned char *)(a2 + 9) = 7;
      int v25 = *(_DWORD *)(a2 + 8);
    }
    if ((v25 & 0xFF00) != 0x700)
    {
      uint64_t v26 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v27 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellSetDurationValue(TSTCell *, NSTimeInterval)");
      objc_msgSend(v26, "handleFailureInFunction:file:lineNumber:description:", v27, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 1080, @"can't set duration value on a non-duration cell: %p", a2);
      goto LABEL_48;
    }
    goto LABEL_45;
  }
  if (v20 != 6)
  {
    double v24 = *v19;
    int v28 = *(_DWORD *)(a2 + 8);
    if ((v28 & 0xFF00) == 0)
    {
      TSTCellClearValue(a2);
      *(unsigned char *)(a2 + 9) = 2;
      int v28 = *(_DWORD *)(a2 + 8);
    }
    if ((v28 & 0xFF00) != 0x200)
    {
      uint64_t v31 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v32 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellSetDoubleValue(TSTCell *, double)");
      objc_msgSend(v31, "handleFailureInFunction:file:lineNumber:description:", v32, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 912, @"can't set value to non-value cell: %p", a2);
      goto LABEL_48;
    }
LABEL_45:
    *(double *)(a2 + 16) = v24;
    goto LABEL_48;
  }
  double v21 = *v19;
  int v22 = *(_DWORD *)(a2 + 8);
  if ((v22 & 0xFF00) == 0)
  {
    TSTCellClearValue(a2);
    *(unsigned char *)(a2 + 9) = 6;
    int v22 = *(_DWORD *)(a2 + 8);
  }
  if ((v22 & 0xFF00) == 0x600)
  {
    double v23 = 0.0;
    if (v21 != 0.0) {
      double v23 = 1.0;
    }
    *(double *)(a2 + 16) = v23;
  }
  else
  {
    unsigned int v29 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v30 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellSetBoolValue(TSTCell *, BOOL)");
    objc_msgSend(v29, "handleFailureInFunction:file:lineNumber:description:", v30, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 939, @"can't set BOOL value to non-BOOL cell: %p", a2);
  }
LABEL_48:
  v8 += 8;
  v9 &= 0xFFDFu;
  if ((v9 & 0x40) == 0)
  {
LABEL_14:
    if (!v9) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
LABEL_49:
  v33 = (void *)[MEMORY[0x263EFF910] dateWithTimeIntervalSinceReferenceDate:*(double *)&a1[v8 + 8]];
  int v34 = *(_DWORD *)(a2 + 8);
  if ((v34 & 0xFF00) == 0)
  {
    TSTCellClearValue(a2);
    *(unsigned char *)(a2 + 9) = 5;
    int v34 = *(_DWORD *)(a2 + 8);
  }
  if ((v34 & 0xFF00) == 0x500)
  {
    v35 = *(void **)(a2 + 16);
    if (v35 != v33)
    {

      *(void *)(a2 + 16) = v33;
    }
  }
  else
  {
    uint64_t v36 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v37 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellSetDateValue(TSTCell *, NSDate *)");
    objc_msgSend(v36, "handleFailureInFunction:file:lineNumber:description:", v37, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 1038, @"can't set date value on a non-date cell: %p", a2);
  }
  v8 += 8;
  if ((v9 & 0xFFBF) != 0)
  {
LABEL_15:
    int v10 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v11 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTV1CellStorageToCell(TSTV1CellStorage *, TSTCell *)");
    objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.mm"), 602, @"Failed to process all storage elements!");
  }
LABEL_16:
  uint64_t result = *((unsigned __int16 *)a1 + 2);
  if (*((_WORD *)a1 + 2))
  {
    uint64_t result = p_TSTCellStorageExtraSizeForHeaderFlags(result);
    uint64_t v13 = (unsigned __int16)(result + 8);
  }
  else
  {
    uint64_t v13 = 8;
  }
  if (v8 + 8 != v13)
  {
    unint64_t v14 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v15 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTV1CellStorageToCell(TSTV1CellStorage *, TSTCell *)");
    uint64_t v16 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.mm"];
    return [v14 handleFailureInFunction:v15 file:v16 lineNumber:605 description:@"Size miscalculation!"];
  }
  return result;
}

void TSTCellStorageToCell(unsigned __int8 *a1, uint64_t a2)
{
  TSTCellStorageVersionAssert(a1);
  TSTCellClear(a2);
  if (!a1) {
    return;
  }
  if (*a1 <= 1u)
  {
    TSTV1CellStorageToCell(a1, a2);
    return;
  }
  unsigned __int8 v4 = a1[2];
  TSTCellClearValue(a2);
  *(unsigned char *)(a2 + 9) = v4;
  *(_WORD *)(a2 + 10) = *((_WORD *)a1 + 3);
  *(unsigned char *)(a2 + 272) = a1[3];
  *(_WORD *)(a2 + 96) = *((_DWORD *)a1 + 2);
  unint64_t v5 = *(void *)(a1 + 4);
  int v6 = (unsigned __int16)v5;
  if ((v5 & 2) != 0)
  {
    *(_DWORD *)(a2 + 32) = *((_DWORD *)a1 + 3);
    int v6 = v5 & 0xFFFD;
    unsigned int v7 = 4;
    if ((v5 & 0x80) == 0) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  unsigned int v7 = 0;
  if ((v5 & 0x80) != 0)
  {
LABEL_10:
    *(_DWORD *)(a2 + 48) = *(_DWORD *)&a1[v7 + 12];
    v7 += 4;
    v6 &= 0xFF7Fu;
  }
LABEL_11:
  if ((v6 & 4) != 0)
  {
    *(_DWORD *)(a2 + 100) = *(_DWORD *)&a1[v7 + 12];
    v7 += 4;
    v6 &= 0xFFFBu;
    if ((v6 & 0x200) == 0)
    {
LABEL_13:
      if ((v6 & 0x1000) == 0) {
        goto LABEL_14;
      }
      goto LABEL_19;
    }
  }
  else if ((v6 & 0x200) == 0)
  {
    goto LABEL_13;
  }
  *(_DWORD *)(a2 + 64) = *(_DWORD *)&a1[v7 + 12];
  v7 += 4;
  v6 &= 0xFDFFu;
  if ((v6 & 0x1000) == 0)
  {
LABEL_14:
    if ((v6 & 0x10) == 0) {
      goto LABEL_15;
    }
    goto LABEL_20;
  }
LABEL_19:
  *(_DWORD *)(a2 + 80) = *(_DWORD *)&a1[v7 + 12];
  v7 += 4;
  v6 &= 0xEFFFu;
  if ((v6 & 0x10) == 0)
  {
LABEL_15:
    if ((v6 & 0x20) == 0) {
      goto LABEL_43;
    }
LABEL_24:
    int v10 = (double *)&a1[v7 + 12];
    int v11 = a1[2];
    if (v11 == 7)
    {
      double v15 = *v10;
      int v16 = *(_DWORD *)(a2 + 8);
      if ((v16 & 0xFF00) == 0)
      {
        TSTCellClearValue(a2);
        *(unsigned char *)(a2 + 9) = 7;
        int v16 = *(_DWORD *)(a2 + 8);
      }
      if ((v16 & 0xFF00) != 0x700)
      {
        int v17 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v18 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellSetDurationValue(TSTCell *, NSTimeInterval)");
        objc_msgSend(v17, "handleFailureInFunction:file:lineNumber:description:", v18, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 1080, @"can't set duration value on a non-duration cell: %p", a2);
LABEL_42:
        v7 += 8;
        v6 &= 0xFFDFu;
        goto LABEL_43;
      }
    }
    else
    {
      if (v11 == 6)
      {
        double v12 = *v10;
        int v13 = *(_DWORD *)(a2 + 8);
        if ((v13 & 0xFF00) == 0)
        {
          TSTCellClearValue(a2);
          *(unsigned char *)(a2 + 9) = 6;
          int v13 = *(_DWORD *)(a2 + 8);
        }
        if ((v13 & 0xFF00) == 0x600)
        {
          double v14 = 0.0;
          if (v12 != 0.0) {
            double v14 = 1.0;
          }
          *(double *)(a2 + 16) = v14;
        }
        else
        {
          int v20 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v21 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellSetBoolValue(TSTCell *, BOOL)");
          objc_msgSend(v20, "handleFailureInFunction:file:lineNumber:description:", v21, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 939, @"can't set BOOL value to non-BOOL cell: %p", a2);
        }
        goto LABEL_42;
      }
      double v15 = *v10;
      int v19 = *(_DWORD *)(a2 + 8);
      if ((v19 & 0xFF00) == 0)
      {
        TSTCellClearValue(a2);
        *(unsigned char *)(a2 + 9) = 2;
        int v19 = *(_DWORD *)(a2 + 8);
      }
      if ((v19 & 0xFF00) != 0x200)
      {
        int v22 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v23 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellSetDoubleValue(TSTCell *, double)");
        objc_msgSend(v22, "handleFailureInFunction:file:lineNumber:description:", v23, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 912, @"can't set value to non-value cell: %p", a2);
        goto LABEL_42;
      }
    }
    *(double *)(a2 + 16) = v15;
    goto LABEL_42;
  }
LABEL_20:
  if (*(unsigned __int8 *)(a2 + 9) << 8 == 768)
  {
    *(_DWORD *)(a2 + 16) = *(_DWORD *)&a1[v7 + 12];
  }
  else
  {
    unsigned int v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellSetStringID(TSTCell *, TSTTableDataListKey)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 958, @"can't set string ID on non-string cell: %p", a2);
  }
  v7 += 4;
  v6 &= 0xFFEFu;
  if ((v6 & 0x20) != 0) {
    goto LABEL_24;
  }
LABEL_43:
  unint64_t v24 = HIWORD(v5);
  if ((v6 & 0x40) != 0)
  {
    v33 = (void *)[MEMORY[0x263EFF910] dateWithTimeIntervalSinceReferenceDate:*(double *)&a1[v7 + 12]];
    int v34 = *(_DWORD *)(a2 + 8);
    if ((v34 & 0xFF00) == 0)
    {
      TSTCellClearValue(a2);
      *(unsigned char *)(a2 + 9) = 5;
      int v34 = *(_DWORD *)(a2 + 8);
    }
    if ((v34 & 0xFF00) == 0x500)
    {
      v35 = *(void **)(a2 + 16);
      if (v35 != v33)
      {

        *(void *)(a2 + 16) = v33;
      }
    }
    else
    {
      int v39 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v40 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellSetDateValue(TSTCell *, NSDate *)");
      objc_msgSend(v39, "handleFailureInFunction:file:lineNumber:description:", v40, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 1038, @"can't set date value on a non-date cell: %p", a2);
    }
    v7 += 8;
    v6 &= 0xFFBFu;
    if ((v5 & 0x1000000000000) == 0)
    {
LABEL_45:
      if ((v5 & 0x8000000000000) == 0) {
        goto LABEL_46;
      }
      goto LABEL_76;
    }
  }
  else if ((v5 & 0x1000000000000) == 0)
  {
    goto LABEL_45;
  }
  *(_DWORD *)(a2 + 144) = *(_DWORD *)&a1[v7 + 12];
  v7 += 4;
  LODWORD(v24) = HIWORD(v5) & 0xFFFE;
  if ((v5 & 0x8000000000000) == 0)
  {
LABEL_46:
    if ((v24 & 2) == 0) {
      goto LABEL_47;
    }
    goto LABEL_77;
  }
LABEL_76:
  *(_DWORD *)(a2 + 160) = *(_DWORD *)&a1[v7 + 12];
  v7 += 4;
  LODWORD(v24) = v24 & 0xFFFFFFF7;
  if ((v24 & 2) == 0)
  {
LABEL_47:
    if ((v24 & 4) == 0) {
      goto LABEL_48;
    }
    goto LABEL_78;
  }
LABEL_77:
  *(_DWORD *)(a2 + 192) = *(_DWORD *)&a1[v7 + 12];
  v7 += 4;
  LODWORD(v24) = v24 & 0xFFFD;
  if ((v24 & 4) == 0)
  {
LABEL_48:
    if ((v24 & 0x10) == 0) {
      goto LABEL_49;
    }
    goto LABEL_79;
  }
LABEL_78:
  *(_DWORD *)(a2 + 176) = *(_DWORD *)&a1[v7 + 12];
  v7 += 4;
  LODWORD(v24) = v24 & 0xFFFB;
  if ((v24 & 0x10) == 0)
  {
LABEL_49:
    if ((v24 & 0x20) == 0) {
      goto LABEL_50;
    }
    goto LABEL_80;
  }
LABEL_79:
  *(_DWORD *)(a2 + 208) = *(_DWORD *)&a1[v7 + 12];
  v7 += 4;
  LODWORD(v24) = v24 & 0xFFEF;
  if ((v24 & 0x20) == 0)
  {
LABEL_50:
    if ((v24 & 0x40) == 0) {
      goto LABEL_51;
    }
LABEL_81:
    *(_DWORD *)(a2 + 240) = *(_DWORD *)&a1[v7 + 12];
    LOWORD(v7) = v7 + 4;
    LODWORD(v24) = v24 & 0xFFBF;
    if ((v24 & 0x80) == 0) {
      goto LABEL_53;
    }
    goto LABEL_52;
  }
LABEL_80:
  *(_DWORD *)(a2 + 224) = *(_DWORD *)&a1[v7 + 12];
  v7 += 4;
  LODWORD(v24) = v24 & 0xFFDF;
  if ((v24 & 0x40) != 0) {
    goto LABEL_81;
  }
LABEL_51:
  if ((v24 & 0x80) != 0)
  {
LABEL_52:
    *(_DWORD *)(a2 + 256) = *(_DWORD *)&a1[(unsigned __int16)v7 + 12];
    LOWORD(v7) = v7 + 4;
    LODWORD(v24) = v24 & 0xFF7F;
  }
LABEL_53:
  if (v24 | v6)
  {
    int v25 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v26 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellStorageToCell(TSTCellStorage *, TSTCell *)");
    objc_msgSend(v25, "handleFailureInFunction:file:lineNumber:description:", v26, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.mm"), 831, @"Failed to process all storage elements!");
  }
  unint64_t v27 = *(void *)(a1 + 4);
  int v28 = (unsigned __int16)v27;
  unsigned int v29 = *a1;
  if (v29 <= 1) {
    int v30 = 0;
  }
  else {
    int v30 = HIWORD(v27);
  }
  uint64_t v31 = (unsigned __int16)v7 + 12;
  if (v31 != TSTCellStorageSizeForHeaderFlags((unsigned __int16)*(void *)(a1 + 4), v30))
  {
    NSLog((NSString *)@"hate");
    unint64_t v27 = *(void *)(a1 + 4);
    unsigned int v29 = *a1;
    int v28 = (unsigned __int16)v27;
  }
  if (v29 <= 1) {
    int v32 = 0;
  }
  else {
    int v32 = HIWORD(v27);
  }
  if (v31 != TSTCellStorageSizeForHeaderFlags(v28, v32))
  {
    uint64_t v36 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v37 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellStorageToCell(TSTCellStorage *, TSTCell *)");
    uint64_t v38 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.mm"];
    [v36 handleFailureInFunction:v37 file:v38 lineNumber:838 description:@"Size miscalculation!"];
  }
}

uint64_t TSTCellStorageGetElement(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a1 + 4);
  if ((v3 & 2) != 0)
  {
    if (a2 == 2) {
      return a1 + 12;
    }
    unsigned int v4 = 4;
    if ((v3 & 0x80) == 0)
    {
LABEL_3:
      if ((v3 & 0x400) == 0) {
        goto LABEL_4;
      }
      goto LABEL_18;
    }
  }
  else
  {
    unsigned int v4 = 0;
    if ((v3 & 0x80) == 0) {
      goto LABEL_3;
    }
  }
  if (a2 == 128) {
    return a1 + v4 + 12;
  }
  v4 += 4;
  if ((v3 & 0x400) == 0)
  {
LABEL_4:
    if ((v3 & 0x800) == 0) {
      goto LABEL_5;
    }
    goto LABEL_20;
  }
LABEL_18:
  if (a2 == 1024) {
    return a1 + v4 + 12;
  }
  v4 += 4;
  if ((v3 & 0x800) == 0)
  {
LABEL_5:
    if ((v3 & 4) == 0) {
      goto LABEL_6;
    }
    goto LABEL_22;
  }
LABEL_20:
  if (a2 == 2048) {
    return a1 + v4 + 12;
  }
  v4 += 4;
  if ((v3 & 4) == 0)
  {
LABEL_6:
    if ((v3 & 8) == 0) {
      goto LABEL_7;
    }
    goto LABEL_24;
  }
LABEL_22:
  if (a2 == 4) {
    return a1 + v4 + 12;
  }
  v4 += 4;
  if ((v3 & 8) == 0)
  {
LABEL_7:
    if ((v3 & 0x100) == 0) {
      goto LABEL_8;
    }
    goto LABEL_26;
  }
LABEL_24:
  if (a2 == 8) {
    return a1 + v4 + 12;
  }
  v4 += 4;
  if ((v3 & 0x100) == 0)
  {
LABEL_8:
    if ((v3 & 0x200) == 0) {
      goto LABEL_9;
    }
    goto LABEL_28;
  }
LABEL_26:
  if (a2 == 256) {
    return a1 + v4 + 12;
  }
  v4 += 4;
  if ((v3 & 0x200) == 0)
  {
LABEL_9:
    if ((v3 & 0x1000) == 0) {
      goto LABEL_10;
    }
LABEL_30:
    if (a2 == 4096) {
      return a1 + v4 + 12;
    }
    v4 += 4;
    if ((v3 & 0x10) == 0) {
      goto LABEL_11;
    }
    goto LABEL_32;
  }
LABEL_28:
  if (a2 == 512) {
    return a1 + v4 + 12;
  }
  v4 += 4;
  if ((v3 & 0x1000) != 0) {
    goto LABEL_30;
  }
LABEL_10:
  if ((v3 & 0x10) == 0)
  {
LABEL_11:
    if ((v3 & 0x20) == 0) {
      goto LABEL_36;
    }
LABEL_34:
    if (a2 != 32)
    {
      v4 += 8;
      goto LABEL_36;
    }
    return a1 + v4 + 12;
  }
LABEL_32:
  if (a2 == 16) {
    return a1 + v4 + 12;
  }
  v4 += 4;
  if ((v3 & 0x20) != 0) {
    goto LABEL_34;
  }
LABEL_36:
  if (a2 == 64 && (v3 & 0x40) != 0) {
    return a1 + v4 + 12;
  }
  int v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
  uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTCellStorageDataElement *TSTCellStorageGetElement(TSTCellStorage *, TSTCellStorageHeaderFlags)");
  objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.mm"), 942, @"Can't get offset for unknown element 0x%02x!", a2);
  return 0;
}

uint64_t TSTCellStorageGetElementForFormat(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = HIWORD(*(void *)(a1 + 4));
  unsigned int v5 = p_TSTCellStorageExtraSizeForHeaderFlags((unsigned __int16)*(void *)(a1 + 4));
  if (v4)
  {
    if (a2 == 1)
    {
      uint64_t v6 = a1 + v5;
      return v6 + 12;
    }
    LOWORD(v5) = v5 + 4;
  }
  if ((v4 & 8) != 0)
  {
    if (a2 == 8) {
      goto LABEL_25;
    }
    LOWORD(v5) = v5 + 4;
  }
  if ((v4 & 2) != 0)
  {
    if (a2 == 2) {
      goto LABEL_25;
    }
    LOWORD(v5) = v5 + 4;
  }
  if ((v4 & 4) != 0)
  {
    if (a2 == 4) {
      goto LABEL_25;
    }
    LOWORD(v5) = v5 + 4;
  }
  if ((v4 & 0x10) != 0)
  {
    if (a2 == 16) {
      goto LABEL_25;
    }
    LOWORD(v5) = v5 + 4;
  }
  if ((v4 & 0x20) != 0)
  {
    if (a2 == 32) {
      goto LABEL_25;
    }
    LOWORD(v5) = v5 + 4;
  }
  if ((v4 & 0x40) != 0)
  {
    if (a2 != 64)
    {
      LOWORD(v5) = v5 + 4;
      goto LABEL_23;
    }
LABEL_25:
    uint64_t v6 = a1 + (unsigned __int16)v5;
    return v6 + 12;
  }
LABEL_23:
  if (a2 == 128 && (v4 & 0x80) != 0) {
    goto LABEL_25;
  }
  unsigned int v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
  uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTCellStorageDataElement *TSTCellStorageGetElementForFormat(TSTCellStorage *, TSTCellStorageFormatFlags)");
  objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.mm"), 1021, @"Can't get offset for unknown element 0x%02x!", a2);
  return 0;
}

uint64_t TSTBundle()
{
  if (TSTBundle::onceToken != -1) {
    dispatch_once(&TSTBundle::onceToken, &__block_literal_global_79);
  }
  return TSTBundle::bundle;
}

uint64_t __TSTBundle_block_invoke()
{
  uint64_t result = [MEMORY[0x263F086E0] bundleForClass:objc_opt_class()];
  TSTBundle::bundle = result;
  return result;
}

unint64_t TSTCellRangeUnionCellRange(unint64_t a1, unint64_t a2)
{
  if ((_WORD)a1 == 0xFFFF || (a1 & 0xFF0000) == 0xFF0000 || (unint64_t v2 = HIWORD(a1)) == 0 || (a1 & 0xFFFF00000000) == 0)
  {
    unint64_t v3 = a2 >> 16;
    int v7 = a2 & 0xFF000000;
    unint64_t v4 = HIDWORD(a2);
    LOWORD(a1) = a2;
    unint64_t v2 = HIWORD(a2);
  }
  else if ((_WORD)a2 == 0xFFFF || (a2 & 0xFF0000) == 0xFF0000 || !HIWORD(a2) || (a2 & 0xFFFF00000000) == 0)
  {
    unint64_t v3 = a1 >> 16;
    int v7 = a1 & 0xFF000000;
    unint64_t v4 = HIDWORD(a1);
  }
  else if ((unsigned __int16)a1 <= (unsigned __int16)a2 {
         && (unsigned __int16)(a1 + HIWORD(a1) - 1) >= (unsigned __int16)a2
  }
         && (unint64_t v3 = a1 >> 16, BYTE2(a2) >= BYTE2(a1))
         && (v4 = HIDWORD(a1), unsigned int v5 = (BYTE4(a1) + BYTE2(a1) - 1), v5 >= BYTE2(a2))
         && v5 >= (BYTE4(a2) + BYTE2(a2) - 1)
         && (unsigned __int16)(a1 + HIWORD(a1) - 1) >= (unsigned __int16)(a2 + HIWORD(a2) - 1))
  {
    int v7 = a1 & 0xFF000000;
  }
  else if ((unsigned __int16)a2 <= (unsigned __int16)a1 {
         && (unsigned __int16)(a2 + HIWORD(a2) - 1) >= (unsigned __int16)a1
  }
         && (unint64_t v3 = a2 >> 16, BYTE2(a1) >= BYTE2(a2))
         && (v4 = HIDWORD(a2), unsigned int v6 = (BYTE4(a2) + BYTE2(a2) - 1), v6 >= BYTE2(a1))
         && v6 >= (BYTE4(a1) + BYTE2(a1) - 1)
         && (unsigned __int16)(a2 + HIWORD(a2) - 1) >= (unsigned __int16)(a1 + HIWORD(a1) - 1))
  {
    int v7 = a2 & 0xFF000000;
    LOWORD(a1) = a2;
    unint64_t v2 = HIWORD(a2);
  }
  else
  {
    int v7 = 0;
    if (BYTE2(a1) >= BYTE2(a2)) {
      LOWORD(v3) = BYTE2(a2);
    }
    else {
      LOWORD(v3) = BYTE2(a1);
    }
    __int16 v8 = a1;
    if ((unsigned __int16)a1 >= (unsigned __int16)a2) {
      __int16 v8 = a2;
    }
    __int16 v9 = a1 + HIWORD(a1);
    LOWORD(a1) = v8;
    unsigned int v10 = (BYTE4(a1) + BYTE2(a1) - 1);
    if (v10 <= (BYTE4(a2) + BYTE2(a2) - 1)) {
      LOWORD(v10) = (BYTE4(a2) + BYTE2(a2) - 1);
    }
    unsigned int v11 = (unsigned __int16)(v9 - 1);
    if (v11 <= (unsigned __int16)(a2 + HIWORD(a2) - 1)) {
      LOWORD(v11) = a2 + HIWORD(a2) - 1;
    }
    LOWORD(v2) = v11 - v8 + 1;
    LOWORD(v4) = v10 - v3 + 1;
    unint64_t v2 = (unsigned __int16)v2;
  }
  return ((unint64_t)(unsigned __int16)v4 << 32) | (v2 << 48) | v7 & 0xFF000000 | ((unint64_t)v3 << 16) | (unsigned __int16)a1;
}

uint64_t TSTTableRepGetCellIDForCanvasPointIgnoringFreezeHeaders(void *a1, char a2, double a3, CGFloat a4)
{
  int v7 = (TSTLayout *)[a1 tableLayout];
  if (a2)
  {
    uint64_t Space = TSTLayoutGetSpace(v7);
    uint64_t GridPointHitByCanvasPoint = TSTLayoutSpaceGetGridPointHitByCanvasPoint(Space, 0, a3, a4);
    int v10 = GridPointHitByCanvasPoint << 16;
    if (GridPointHitByCanvasPoint == -1) {
      int v10 = 16711680;
    }
    return v10 | WORD2(GridPointHitByCanvasPoint);
  }
  else
  {
    return TSTLayoutGetCellIDHitByCanvasPoint(v7, a3, a4);
  }
}

uint64_t TSTTableRepGetCellIDForCanvasPoint(void *a1, CGFloat a2, double a3)
{
  unsigned int v5 = (TSTLayout *)[a1 tableLayout];

  return TSTLayoutGetCellIDHitByCanvasPoint(v5, a2, a3);
}

uint64_t TSTTableRepGetClosestCellIDForCanvasPoint(void *a1)
{
  unsigned int v1 = (TSTLayout *)[a1 tableLayout];

  return TSTLayoutGetCellIDNearbyCanvasPoint(v1);
}

void TSTTableRepSetupUserSpaceToDeviceSpaceTransform(TSTTableRep *a1, CGFloat a2, double a3)
{
  a1->mCurrentScreenScale = a3;
  memset(&v15, 0, sizeof(v15));
  CGAffineTransformMakeScale(&v15, a3, a3);
  [(TSTTableRep *)a1 layerFrameInScaledCanvas];
  CGAffineTransform v13 = v15;
  CGAffineTransformTranslate(&v14, &v13, -v5, -v6);
  CGAffineTransform v15 = v14;
  CGAffineTransform v12 = v14;
  CGAffineTransformScale(&v14, &v12, a2, a2);
  CGAffineTransform v15 = v14;
  int v7 = [(TSDRep *)a1 layout];
  if (v7) {
    [(TSDAbstractLayout *)v7 transformInRoot];
  }
  else {
    memset(&t1, 0, sizeof(t1));
  }
  CGAffineTransform t2 = v15;
  CGAffineTransformConcat(&v14, &t1, &t2);
  CGAffineTransform v15 = v14;
  uint64_t Space = TSTLayoutGetSpace([(TSTTableRep *)a1 tableLayout]);
  CGAffineTransform v9 = v15;
  TSTLayoutSpaceSetUserSpaceToDeviceSpaceTransform(Space, (long long *)&v9);
}

void TSTTableRepGetStrokeFrameForRange(void *a1, unint64_t a2)
{
  if (BYTE2(a2) == 255) {
    unsigned int v2 = -1;
  }
  else {
    unsigned int v2 = BYTE2(a2);
  }
  uint64_t v3 = WORD2(a2) + v2 - 1;
  if (!WORD2(a2)) {
    uint64_t v3 = 0xFFFFFFFFLL;
  }
  if ((unsigned __int16)a2 == 0xFFFF) {
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v4 = (unsigned __int16)a2;
  }
  unint64_t v5 = v2 | ((unint64_t)v4 << 32);
  uint64_t v6 = ((a2 >> 16) & 0xFFFF00000000) + (v4 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0) {
    uint64_t v6 = 0xFFFFFFFF00000000;
  }
  unint64_t v7 = v3 | v6;
  uint64_t Space = (TSTLayoutSpace *)TSTLayoutGetSpace((void *)[a1 tableLayout]);
  TSTLayoutSpaceGetStrokeFrameForGridRange(Space, v5, v7);
}

uint64_t TSTTableRepDrawTableName(TSTTableRep *a1, CGContext *a2, TSTAnimation *a3)
{
  uint64_t v6 = [(TSTTableRep *)a1 tableLayout];
  v38.origin.double x = TSTLayoutGetFrameForTableName(v6);
  double x = v38.origin.x;
  double y = v38.origin.y;
  double width = v38.size.width;
  double height = v38.size.height;
  uint64_t result = CGRectIsEmpty(v38);
  if ((result & 1) == 0)
  {
    uint64_t result = TSTLayoutIsPartitionAlongLeft(v6);
    if (result)
    {
      CGAffineTransform v12 = [(TSTTableModel *)[(TSTTableRep *)a1 tableModel] tableName];
      if (!a1->mRecursivelyDrawingInContext
        && ![(TSTLayout *)v6 inPrintPreviewMode]
        && (![(TSTAnimation *)a3 enabled] || ![(TSTAnimation *)a3 drawTableName]))
      {
        [(TSDRep *)a1 setupForDrawingInLayer:a1->mOverlayTableName context:a2];
      }
      if ([(TSTEditingState *)[(TSTTableRep *)a1 editingState] editingMode] != 7) {
        objc_msgSend(-[TSTMasterLayout tableNameTextEngine](-[TSTTableRep masterLayout](a1, "masterLayout"), "tableNameTextEngine"), "drawText:inContext:minSize:maxSize:anchor:flags:viewScale:", v12, a2, 4096, width, height, width, height, x, y, 1.0);
      }
      uint64_t result = TSTLayoutTableNameBorderEnabled(v6);
      if (result)
      {
        uint64_t Space = (TSTLayoutSpace *)TSTLayoutGetSpace(v6);
        [(TSTLayoutSpace *)Space lockForRead];
        CGAffineTransform v14 = [(TSTTableModel *)[(TSTTableInfo *)[(TSTTableRep *)a1 tableInfo] tableModel] tableNameBorderStroke];
        CGAffineTransform v15 = [(TSTLayout *)v6 masterLayout];
        v39.origin.double x = TSTLayoutGetFrameForTableNameBorder(v6);
        CGFloat v16 = v39.origin.x;
        CGFloat v17 = v39.origin.y;
        CGFloat v18 = v39.size.width;
        CGFloat v19 = v39.size.height;
        CGFloat MaxX = CGRectGetMaxX(v39);
        CGFloat v36 = v16;
        CGFloat v37 = v17;
        v35.double x = MaxX;
        v35.double y = v17;
        [(TSDStroke *)v14 width];
        double v34 = v21;
        double v22 = TSTLayoutSpaceStrokeWidthForDrawing(v21, v21);
        TSTLayoutSpaceAlignStrokeCoordinates(Space, &v36, &v35, &v34);
        TSTLayoutSpaceDrawSingleStroke(v14, a2, v36, v37, v35.x, v35.y, v34, v22, v23, v24, v16, v17, v18, v19);
        unint64_t Range = TSTLayoutSpaceGetRange((uint64_t)Space);
        unsigned int VisibleRow = TSTMasterLayoutNextVisibleRow(v15, (unsigned __int16)Range);
        int VisibleColumn = TSTMasterLayoutNextVisibleColumn(v15, BYTE2(Range));
        LODWORD(v15) = TSTMasterLayoutPreviousVisibleColumn(v15, (BYTE4(Range) + BYTE2(Range) - 1));
        v40.origin.double x = TSTLayoutSpaceGetAlignedStrokeFrameForCellRange(Space, VisibleRow | (VisibleColumn << 16) | 0x1000100000000);
        CGFloat v36 = v16;
        CGFloat v37 = v37 - v34 * 0.5;
        v33.double x = v16;
        v33.double y = CGRectGetMinY(v40);
        TSTLayoutSpaceAlignStrokeCoordinates(Space, &v36, &v33, &v34);
        TSTLayoutSpaceDrawSingleStroke(v14, a2, v36, v37, v33.x, v33.y, v34, v22, v28, v29, v16, v17, v18, v19);
        v41.origin.double x = TSTLayoutSpaceGetAlignedStrokeFrameForCellRange(Space, VisibleRow | (v15 << 16) | 0x1000100000000);
        v35.double x = MaxX;
        v35.double y = v35.y - v34 * 0.5;
        v32.double x = MaxX;
        v32.double y = CGRectGetMinY(v41);
        TSTLayoutSpaceAlignStrokeCoordinates(Space, &v35.x, &v32, &v34);
        TSTLayoutSpaceDrawSingleStroke(v14, a2, v35.x, v35.y, v32.x, v32.y, v34, v22, v30, v31, v16, v17, v18, v19);
        return [(TSTLayoutSpace *)Space unlock];
      }
    }
  }
  return result;
}

void TSTTableRepDrawFrozenHeaderRegion(TSTTableRep *a1, TSTLayoutSpace *a2, CALayer *a3, CGContext *a4)
{
  __int16 v8 = a2;
  if (a2)
  {
    [(TSTLayoutSpace *)a2 lockForRead];
    Gridunint64_t Range = TSTLayoutSpaceGetGridRange((uint64_t)a2);
    if (GridRange != -1
      && v10 != -1
      && GridRange <= v10
      && HIDWORD(GridRange) != -1
      && v11 != -1
      && HIDWORD(GridRange) <= v11)
    {
      [(TSDRep *)a1 setupForDrawingInLayer:a3 context:a4];
      ClipBoundingBoCGFloat x = CGContextGetClipBoundingBox(a4);
      CGFloat x = ClipBoundingBox.origin.x;
      CGFloat y = ClipBoundingBox.origin.y;
      CGFloat width = ClipBoundingBox.size.width;
      CGFloat height = ClipBoundingBox.size.height;
      if (a1) {
        [(TSTTableRep *)a1 transformFromCanvas];
      }
      else {
        memset(&v16, 0, sizeof(v16));
      }
      CGContextConcatCTM(a4, &v16);
      v18.origin.CGFloat x = x;
      v18.origin.CGFloat y = y;
      v18.size.CGFloat width = width;
      v18.size.CGFloat height = height;
      TSTTableRepDrawSpaceInContext(a1, a2, v18, a4);
    }
    [(TSTLayoutSpace *)a2 unlock];
  }
}

void TSTTableRepDrawSpaceInContext(TSTTableRep *a1, TSTLayoutSpace *a2, CGRect a3, CGContext *a4)
{
  double height = a3.size.height;
  double width = a3.size.width;
  double y = a3.origin.y;
  double x = a3.origin.x;
  if (![(TSTAnimation *)[(TSTTableRep *)a1 currentAnimation] enabled])
  {
    unint64_t v11 = 1;
    goto LABEL_5;
  }
  unint64_t v11 = [(TSTAnimation *)[(TSTTableRep *)a1 currentAnimation] cellRangeCount];
  if (v11)
  {
LABEL_5:
    for (uint64_t i = 0; v11 != i; ++i)
    {
      unint64_t NearestRangeForLayoutRect = TSTLayoutSpaceGetNearestRangeForLayoutRect(a2, x, y, width, height);
      if (![(TSTAnimation *)[(TSTTableRep *)a1 currentAnimation] enabled])
      {
LABEL_32:
        if (a1->mIsZoomToEditOperationInProgress) {
          unint64_t NearestRangeForLayoutRect = TSTCellRangeUnionCellRange(NearestRangeForLayoutRect, *(void *)&a1->mZoomToEditVisibleCellRange);
        }
        TSTTableRepDrawSpaceRangeInContext(a1, a2, NearestRangeForLayoutRect, a4);
        continue;
      }
      $CA3468F20078D5D2DB35E78E73CA60DA v14 = [(TSTAnimation *)[(TSTTableRep *)a1 currentAnimation] cellRangeAtIndex:i];
      unint64_t v15 = 0;
      if ((_WORD)NearestRangeForLayoutRect == 0xFFFF) {
        goto LABEL_30;
      }
      uint64_t v16 = 0xFFFFLL;
      uint64_t v17 = 16711680;
      unint64_t v18 = 0;
      if ((NearestRangeForLayoutRect & 0xFF0000) == 0xFF0000) {
        goto LABEL_31;
      }
      unint64_t v15 = 0;
      if (!HIWORD(NearestRangeForLayoutRect)) {
        goto LABEL_30;
      }
      uint64_t v16 = 0xFFFFLL;
      uint64_t v17 = 16711680;
      unint64_t v18 = 0;
      if ((NearestRangeForLayoutRect & 0xFFFF00000000) == 0) {
        goto LABEL_31;
      }
      unint64_t v15 = 0;
      if (v14.var0.var0 == 0xFFFF) {
        goto LABEL_30;
      }
      uint64_t v16 = 0xFFFFLL;
      uint64_t v17 = 16711680;
      unint64_t v18 = 0;
      if ((*(void *)&v14 & 0xFF0000) == 0xFF0000) {
        goto LABEL_31;
      }
      unint64_t v15 = 0;
      if (!HIWORD(*(unint64_t *)&v14))
      {
LABEL_30:
        uint64_t v16 = 0xFFFFLL;
        uint64_t v17 = 16711680;
        unint64_t v18 = 0;
      }
      else
      {
        uint64_t v16 = 0xFFFFLL;
        uint64_t v17 = 16711680;
        unint64_t v18 = 0;
        if ((*(void *)&v14 & 0xFFFF00000000) != 0)
        {
          uint64_t v16 = 0;
          unsigned int v19 = BYTE2(NearestRangeForLayoutRect) <= v14.var0.var1
              ? v14.var0.var1
              : BYTE2(NearestRangeForLayoutRect);
          uint64_t v20 = (unsigned __int16)NearestRangeForLayoutRect <= v14.var0.var0
              ? v14.var0.var0
              : (unsigned __int16)NearestRangeForLayoutRect;
          unsigned int v21 = (BYTE4(NearestRangeForLayoutRect) + BYTE2(NearestRangeForLayoutRect) - 1) >= (LOBYTE(v14.var1.var0) + v14.var0.var1 - 1)
              ? (LOBYTE(v14.var1.var0) + v14.var0.var1 - 1)
              : (BYTE4(NearestRangeForLayoutRect) + BYTE2(NearestRangeForLayoutRect) - 1);
          unsigned int v22 = (unsigned __int16)(NearestRangeForLayoutRect + HIWORD(NearestRangeForLayoutRect) - 1) >= (unsigned __int16)(v14.var0.var0 + v14.var1.var1 - 1)
              ? (unsigned __int16)(v14.var0.var0 + v14.var1.var1 - 1)
              : (unsigned __int16)(NearestRangeForLayoutRect + HIWORD(NearestRangeForLayoutRect) - 1);
          uint64_t v17 = 0;
          unint64_t v15 = 0;
          unint64_t v18 = 0;
          if (v20 <= v22 && v19 <= v21)
          {
            unint64_t v18 = ((unint64_t)(v22 - v20) << 48) + 0x1000000000000;
            unint64_t v15 = (unint64_t)(unsigned __int16)(v21 - v19 + 1) << 32;
            uint64_t v17 = v19 << 16;
            uint64_t v16 = v20;
          }
        }
      }
LABEL_31:
      unint64_t NearestRangeForLayoutRect = v17 | v18 | v16 | v15;
      if (!TSTMasterLayoutIsEntireCellRangeHidden([(TSTTableRep *)a1 masterLayout], NearestRangeForLayoutRect))goto LABEL_32; {
    }
      }
  }
}

uint64_t TSTTableRepDrawRangeInContext(void *a1, unint64_t a2, uint64_t a3)
{
  if (BYTE2(a2) == 255) {
    unsigned int v6 = -1;
  }
  else {
    unsigned int v6 = BYTE2(a2);
  }
  unsigned int v7 = (unsigned __int16)a2;
  if (WORD2(a2)) {
    uint64_t v8 = WORD2(a2) + v6 - 1;
  }
  else {
    uint64_t v8 = 0xFFFFFFFFLL;
  }
  CGAffineTransform v9 = (void *)[a1 tableLayout];
  if (v7 == 0xFFFF) {
    uint64_t v10 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v10 = v7;
  }
  unint64_t v11 = v6 | ((unint64_t)v10 << 32);
  uint64_t v12 = ((a2 >> 16) & 0xFFFF00000000) + (v10 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0) {
    uint64_t v12 = 0xFFFFFFFF00000000;
  }
  uint64_t v13 = v8 | v12;
  $CA3468F20078D5D2DB35E78E73CA60DA v14 = (void *)[v9 spaceBundle];
  v16[0] = MEMORY[0x263EF8330];
  v16[1] = 3221225472;
  v16[2] = __TSTTableRepDrawRangeInContext_block_invoke;
  v16[3] = &unk_2646B3348;
  v16[6] = v11;
  v16[7] = v13;
  v16[4] = a1;
  v16[5] = a3;
  return [v14 performActionOnEachLayoutSpace:v16];
}

uint64_t __TSTTableRepDrawRangeInContext_block_invoke(uint64_t a1, TSTLayoutSpace *a2)
{
  if (![(TSTLayoutSpace *)a2 isFrozen])
  {
    uint64_t v4 = TSTLayoutSpaceIntersectionGridRange(a2, *(void *)(a1 + 48), *(void *)(a1 + 56));
    if (HIDWORD(v4) == -1 || HIDWORD(v5) == -1 || HIDWORD(v4) > HIDWORD(v5)) {
      unint64_t v8 = 0;
    }
    else {
      unint64_t v8 = ((v5 - (v4 & 0xFFFFFFFF00000000)) & 0xFFFFFFFF00000000 | (v5 - v4 + 1)) + 0x100000000;
    }
    if (v4 == -1 || v5 == -1 || v4 > v5) {
      unint64_t v8 = 0;
    }
    unint64_t v11 = (unint64_t)v4 << 16;
    if (v4 == -1) {
      unint64_t v11 = 16711680;
    }
    TSTTableRepDrawSpaceRangeInContext(*(TSTTableRep **)(a1 + 32), a2, v11 & 0xFFFFFFFFFFFF0000 | WORD2(v4) | (((v8 >> 16) & 0xFFFF0000 | v8) << 32), *(CGContext **)(a1 + 40));
  }
  return 0;
}

void TSTTableRepDrawSpaceRangeInContext(TSTTableRep *a1, TSTLayoutSpace *a2, unint64_t a3, CGContext *a4)
{
  int v6 = BYTE2(a3);
  if (BYTE2(a3) == 255) {
    unsigned int v7 = -1;
  }
  else {
    unsigned int v7 = BYTE2(a3);
  }
  v238[16] = *MEMORY[0x263EF8340];
  int v8 = (unsigned __int16)a3;
  if (WORD2(a3)) {
    unsigned int v9 = WORD2(a3) + v7 - 1;
  }
  else {
    unsigned int v9 = -1;
  }
  if ((unsigned __int16)a3 == 0xFFFF) {
    unsigned int v10 = -1;
  }
  else {
    unsigned int v10 = (unsigned __int16)a3;
  }
  unsigned int v11 = v10 + ((unint64_t)((HIDWORD(a3) << 16) - 0x100000000) >> 32);
  Gridunint64_t Range = TSTLayoutSpaceGetGridRange((uint64_t)a2);
  if (HIWORD(a3)) {
    unsigned int v15 = v11;
  }
  else {
    unsigned int v15 = -1;
  }
  if (v6 != 255
    && v9 != -1
    && v7 <= v9
    && v8 != 0xFFFF
    && v15 != -1
    && v10 <= v15
    && GridRange != -1
    && v13 != -1
    && GridRange <= v13
    && HIDWORD(GridRange) != -1
    && v14 != -1
    && HIDWORD(GridRange) <= v14)
  {
    if (v7 <= GridRange) {
      unsigned int v7 = GridRange;
    }
    if (v9 >= v13) {
      unsigned int v9 = v13;
    }
    if (v7 <= v9)
    {
      if (v15 >= v14) {
        unsigned int v17 = v14;
      }
      else {
        unsigned int v17 = v15;
      }
      if (v10 <= HIDWORD(GridRange)) {
        unsigned int v10 = HIDWORD(GridRange);
      }
      if (v10 <= v17 && v7 != -1 && v10 != -1)
      {
        TSTTableRepPrepareToDrawLayoutSpace(a1, a2, a4);
        unint64_t v18 = [(TSTTableRep *)a1 masterLayout];
        [(TSTTableRep *)a1 tableModel];
        uint64_t v196 = [MEMORY[0x263EFF980] array];
        v209 = a1;
        v197 = [(TSTTableRep *)a1 currentAnimation];
        unint64_t Range = TSTMasterLayoutGetRange((uint64_t)v18);
        unsigned int v20 = BYTE2(Range);
        if (BYTE2(Range) == 255) {
          unsigned int v20 = -1;
        }
        uint64_t v21 = WORD2(Range) + v20 - 1;
        if (!WORD2(Range)) {
          uint64_t v21 = 0xFFFFFFFFLL;
        }
        if ((unsigned __int16)Range == 0xFFFF) {
          uint64_t v22 = 0xFFFFFFFFLL;
        }
        else {
          uint64_t v22 = (unsigned __int16)Range;
        }
        unint64_t v23 = v20 | ((unint64_t)v22 << 32);
        uint64_t v24 = ((Range >> 16) & 0xFFFF00000000) + (v22 << 32) - 0x100000000;
        if (((Range >> 16) & 0xFFFF00000000) == 0) {
          uint64_t v24 = 0xFFFFFFFF00000000;
        }
        v237[0] = v23;
        v237[1] = v21 | v24;
        EntireHeaderColumnsCellunint64_t Range = TSTMasterLayoutGetEntireHeaderColumnsCellRange(v18);
        unsigned int v26 = BYTE2(EntireHeaderColumnsCellRange);
        if (BYTE2(EntireHeaderColumnsCellRange) == 255) {
          unsigned int v26 = -1;
        }
        uint64_t v27 = WORD2(EntireHeaderColumnsCellRange) + v26 - 1;
        if (!WORD2(EntireHeaderColumnsCellRange)) {
          uint64_t v27 = 0xFFFFFFFFLL;
        }
        if ((unsigned __int16)EntireHeaderColumnsCellRange == 0xFFFF) {
          uint64_t v28 = 0xFFFFFFFFLL;
        }
        else {
          uint64_t v28 = (unsigned __int16)EntireHeaderColumnsCellRange;
        }
        unint64_t v29 = v26 | ((unint64_t)v28 << 32);
        uint64_t v30 = ((EntireHeaderColumnsCellRange >> 16) & 0xFFFF00000000) + (v28 << 32) - 0x100000000;
        if (((EntireHeaderColumnsCellRange >> 16) & 0xFFFF00000000) == 0) {
          uint64_t v30 = 0xFFFFFFFF00000000;
        }
        v237[2] = v29;
        v237[3] = v27 | v30;
        EntireHeaderRowsCellunint64_t Range = TSTMasterLayoutGetEntireHeaderRowsCellRange(v18);
        unsigned int v32 = BYTE2(EntireHeaderRowsCellRange);
        if (BYTE2(EntireHeaderRowsCellRange) == 255) {
          unsigned int v32 = -1;
        }
        uint64_t v33 = WORD2(EntireHeaderRowsCellRange) + v32 - 1;
        if (!WORD2(EntireHeaderRowsCellRange)) {
          uint64_t v33 = 0xFFFFFFFFLL;
        }
        if ((unsigned __int16)EntireHeaderRowsCellRange == 0xFFFF) {
          uint64_t v34 = 0xFFFFFFFFLL;
        }
        else {
          uint64_t v34 = (unsigned __int16)EntireHeaderRowsCellRange;
        }
        unint64_t v35 = v32 | ((unint64_t)v34 << 32);
        uint64_t v36 = ((EntireHeaderRowsCellRange >> 16) & 0xFFFF00000000) + (v34 << 32) - 0x100000000;
        if (((EntireHeaderRowsCellRange >> 16) & 0xFFFF00000000) == 0) {
          uint64_t v36 = 0xFFFFFFFF00000000;
        }
        v237[4] = v35;
        v237[5] = v33 | v36;
        EntireFooterRowsCellunint64_t Range = TSTMasterLayoutGetEntireFooterRowsCellRange(v18);
        uint64_t v38 = 0;
        unsigned int v39 = BYTE2(EntireFooterRowsCellRange);
        if (BYTE2(EntireFooterRowsCellRange) == 255) {
          unsigned int v39 = -1;
        }
        uint64_t v40 = WORD2(EntireFooterRowsCellRange) + v39 - 1;
        if (!WORD2(EntireFooterRowsCellRange)) {
          uint64_t v40 = 0xFFFFFFFFLL;
        }
        if ((unsigned __int16)EntireFooterRowsCellRange == 0xFFFF) {
          uint64_t v41 = 0xFFFFFFFFLL;
        }
        else {
          uint64_t v41 = (unsigned __int16)EntireFooterRowsCellRange;
        }
        unint64_t v42 = v39 | ((unint64_t)v41 << 32);
        uint64_t v43 = ((EntireFooterRowsCellRange >> 16) & 0xFFFF00000000) + (v41 << 32) - 0x100000000;
        if (((EntireFooterRowsCellRange >> 16) & 0xFFFF00000000) == 0) {
          uint64_t v43 = 0xFFFFFFFF00000000;
        }
        v237[6] = v42;
        v237[7] = v40 | v43;
        do
        {
          int v44 = &v237[v38];
          LODWORD(v45) = v237[v38];
          LODWORD(v46) = v237[v38 + 1];
          if (v45 == -1 || v46 == -1 || v45 > v46) {
            goto LABEL_104;
          }
          unsigned int v49 = *((_DWORD *)v44 + 1);
          unsigned int v50 = *((_DWORD *)v44 + 3);
          BOOL v51 = v49 == -1 || v50 == -1;
          BOOL v52 = v51 || v49 > v50;
          if (v52
            || (v7 <= v45 ? (uint64_t v45 = v45) : (uint64_t v45 = v7),
                v9 >= v46 ? (uint64_t v46 = v46) : (uint64_t v46 = v9),
                v45 > v46
             || (v17 >= v50 ? (uint64_t v53 = v50) : (uint64_t v53 = v17),
                 v10 <= v49 ? (uint64_t v54 = v49) : (uint64_t v54 = v10),
                 v54 > v53)))
          {
LABEL_104:
            uint64_t v55 = -1;
            uint64_t v56 = -1;
          }
          else
          {
            uint64_t v56 = v46 | (v53 << 32);
            uint64_t v55 = v45 | (v54 << 32);
          }
          v237[v38] = v55;
          v44[1] = v56;
          v38 += 2;
        }
        while (v38 != 8);
        uint64_t v57 = 0;
        unint64_t v58 = -1;
        uint64_t v59 = 0xFFFFFFFFLL;
        LODWORD(v60) = -1;
        v61 = a4;
        v63 = (void *)v196;
        v62 = v197;
        do
        {
          unint64_t v65 = v237[v57];
          unint64_t v64 = v237[v57 + 1];
          if (v60 == -1
            || v58 == -1
            || v60 > v58
            || v59 == -1
            || HIDWORD(v58) == -1
            || v59 > HIDWORD(v58))
          {
            unint64_t v58 = v237[v57 + 1];
            unint64_t v60 = v237[v57];
          }
          else if (v65 == -1 {
                 || v64 == -1
          }
                 || v65 > v64
                 || (unint64_t v66 = HIDWORD(v65), HIDWORD(v65) == -1)
                 || (unint64_t v67 = HIDWORD(v64), HIDWORD(v64) == -1)
                 || HIDWORD(v65) > HIDWORD(v64))
          {
            LODWORD(v64) = v58;
            LODWORD(v65) = v60;
            unint64_t v60 = v60 | (unint64_t)(v59 << 32);
          }
          else
          {
            if (v60 >= v65) {
              unint64_t v65 = v65;
            }
            else {
              unint64_t v65 = v60;
            }
            if (v59 >= v66) {
              uint64_t v68 = v66;
            }
            else {
              uint64_t v68 = v59;
            }
            if (v58 <= v64) {
              unint64_t v64 = v64;
            }
            else {
              unint64_t v64 = v58;
            }
            if (HIDWORD(v58) <= v67) {
              uint64_t v69 = v67;
            }
            else {
              uint64_t v69 = HIDWORD(v58);
            }
            unint64_t v58 = v64 | (v69 << 32);
            unint64_t v60 = v65 | (v68 << 32);
          }
          BOOL v71 = v65 == -1 || v64 == -1 || v65 > v64;
          if (v71
            || (HIDWORD(v60) <= HIDWORD(v58) ? (BOOL v72 = HIDWORD(v58) == -1) : (BOOL v72 = 1),
                !v72 ? (BOOL v73 = HIDWORD(v60) == -1) : (BOOL v73 = 1),
                v73))
          {
            unint64_t v58 = -1;
            unint64_t v60 = -1;
          }
          uint64_t v59 = HIDWORD(v60);
          v57 += 2;
        }
        while (v57 != 8);
        if (v60 == -1) {
          goto LABEL_474;
        }
        if (v58 == -1) {
          goto LABEL_474;
        }
        if (v60 > v58) {
          goto LABEL_474;
        }
        if (HIDWORD(v60) == -1) {
          goto LABEL_474;
        }
        unint64_t v74 = HIDWORD(v58);
        if (HIDWORD(v58) == -1 || HIDWORD(v60) > HIDWORD(v58)) {
          goto LABEL_474;
        }
        unint64_t v193 = v60;
        unint64_t v194 = v58;
        BOOL v75 = [(TSTAnimation *)v197 enabled];
        if (v75)
        {
          v76 = [(TSDBezierPath *)TSTLayoutSpaceGetAlignedStrokeFramePathForGridRange(a2, v193, v194, 0, 0, 0.0) CGPath];
          path = CGPathRetain(v76);
        }
        else
        {
          path = 0;
        }
        if ([(TSTAnimation *)v197 drawTableName]) {
          TSTTableRepDrawTableName(a1, a4, v197);
        }
        if ((![(TSTAnimation *)v197 enabled]
           || [(TSTAnimation *)v197 drawTableBackground])
          && TSTTableGetBackgroundFill())
        {
          CGContextSaveGState(a4);
          if (v75)
          {
            CGContextAddPath(a4, path);
            CGContextClip(a4);
          }
          CGContextSetBlendMode(a4, kCGBlendModeClear);
          v239.origin.double x = TSTLayoutSpaceGetFrame((uint64_t)a2);
          CGContextFillRect(a4, v239);
          CGContextRestoreGState(a4);
        }
        BOOL v190 = v75;
        if (v193) {
          unsigned int v77 = v193 - 1;
        }
        else {
          unsigned int v77 = 0;
        }
        if (v59) {
          unsigned int v78 = v59 - 1;
        }
        else {
          unsigned int v78 = 0;
        }
        uint64_t v79 = TSTLayoutSpaceGetGridRange((uint64_t)a2);
        LODWORD(v82) = v194 + 1;
        uint64_t v83 = -1;
        uint64_t v84 = -1;
        if (v194 != -2 && v77 <= v82)
        {
          unsigned int v85 = v74 + 1;
          if (v74 != -2
            && v78 <= v85
            && v79 != -1
            && v80 != -1
            && v79 <= v80
            && HIDWORD(v79) != -1
            && v81 != -1
            && HIDWORD(v79) <= v81)
          {
            if (v77 <= v79) {
              uint64_t v86 = v79;
            }
            else {
              uint64_t v86 = v77;
            }
            if (v82 >= v80) {
              uint64_t v82 = v80;
            }
            else {
              uint64_t v82 = v82;
            }
            if (v86 <= v82
              && (v85 >= v81 ? (uint64_t v87 = v81) : (uint64_t v87 = v85),
                  v78 <= HIDWORD(v79) ? (uint64_t v88 = HIDWORD(v79)) : (uint64_t v88 = v78),
                  v88 <= v87))
            {
              uint64_t v84 = v82 | (v87 << 32);
              uint64_t v83 = v86 | (v88 << 32);
            }
            else
            {
              uint64_t v83 = -1;
            }
          }
        }
        uint64_t v191 = v84;
        uint64_t v192 = v83;
        BOOL v89 = v190;
        if ([(TSTAnimation *)v197 enabled] && ![(TSTAnimation *)v197 drawCellBackground])
        {
LABEL_231:
          if (![(TSTAnimation *)v62 enabled] || [(TSTAnimation *)v62 drawCellContent])
          {
            CGContextSaveGState(v61);
            if (v89)
            {
              CGContextAddPath(v61, path);
              CGContextClip(v61);
            }
            TSTTableRepDrawCellContent(a1, a2, v193, v194, v61);
            CGContextRestoreGState(v61);
          }
          if ([(TSTAnimation *)v62 enabled] && ![(TSTAnimation *)v62 drawStrokes])
          {
            if (![(TSTAnimation *)v62 enabled])
            {
LABEL_455:
              if ((![(TSTAnimation *)v62 enabled] || [(TSTAnimation *)v62 drawCellContent])
                && [v63 count])
              {
                CGContextSaveGState(v61);
                if (v89)
                {
                  CGContextAddPath(v61, path);
                  CGContextClip(v61);
                }
                long long v233 = 0u;
                long long v234 = 0u;
                long long v235 = 0u;
                long long v236 = 0u;
                uint64_t v183 = [v63 countByEnumeratingWithState:&v233 objects:v238 count:16];
                if (v183)
                {
                  uint64_t v184 = v183;
                  uint64_t v185 = *(void *)v234;
                  do
                  {
                    for (uint64_t i = 0; i != v184; ++i)
                    {
                      if (*(void *)v234 != v185) {
                        objc_enumerationMutation(v63);
                      }
                      [*(id *)(*((void *)&v233 + 1) + 8 * i) drawInContext:v61];
                    }
                    uint64_t v184 = [v63 countByEnumeratingWithState:&v233 objects:v238 count:16];
                  }
                  while (v184);
                }
                CGContextRestoreGState(v61);
              }
              if ((![(TSTAnimation *)v62 enabled]
                 || [(TSTAnimation *)v62 drawTableBackground])
                && TSTTableGetBackgroundFill())
              {
                v187 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
                uint64_t v188 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableRepDrawGridRange(TSTTableRep *, TSTLayoutSpace *, TSTGridRange, TSTAnimation *, CGContextRef)");
                objc_msgSend(v187, "handleFailureInFunction:file:lineNumber:description:", v188, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableRep.mm"), 5999, @"background fill is not supported yet");
              }
              if (path) {
                CGPathRelease(path);
              }
LABEL_474:
              if (a2 && a4) {
                CGContextRestoreGState(a4);
              }
              goto LABEL_30;
            }
            CGContextSaveGState(v61);
            if (v89)
            {
              CGContextAddPath(v61, path);
              CGContextClip(v61);
            }
            uint64_t v100 = v192;
            if (v192 == -1)
            {
              uint64_t v101 = v191;
            }
            else
            {
              uint64_t v101 = v191;
              if (v191 != -1
                && v192 <= v191
                && HIDWORD(v192) != -1
                && HIDWORD(v191) != -1
                && HIDWORD(v192) <= HIDWORD(v191))
              {
                uint64_t v101 = (v191 & 0xFFFFFFFF00000000 | (v191 + 1)) + 0x100000000;
              }
            }
            v181 = a2;
            int v182 = 1;
          }
          else
          {
            CGContextSaveGState(v61);
            if (v89)
            {
              CGContextAddPath(v61, path);
              CGContextClip(v61);
            }
            uint64_t v100 = v192;
            if (v192 == -1)
            {
              uint64_t v101 = v191;
            }
            else
            {
              uint64_t v101 = v191;
              if (v191 != -1
                && v192 <= v191
                && HIDWORD(v192) != -1
                && HIDWORD(v191) != -1
                && HIDWORD(v192) <= HIDWORD(v191))
              {
                uint64_t v101 = (v191 & 0xFFFFFFFF00000000 | (v191 + 1)) + 0x100000000;
              }
            }
            v181 = a2;
            int v182 = 0;
          }
          TSTLayoutSpaceDrawStrokes(v181, v100, v101, v182, v61);
          CGContextRestoreGState(v61);
          goto LABEL_455;
        }
        CGContextSaveGState(a4);
        if (v190)
        {
          CGContextAddPath(a4, path);
          CGContextClip(a4);
        }
        unint64_t v91 = v191;
        unint64_t v90 = v192;
        if (v197)
        {
          if (![(TSTAnimation *)v197 enabled]
            || (v92 = [(TSTAnimation *)v197 expandBackgroundFill], v91 = v191, unint64_t v90 = v192, !v92))
          {
            unint64_t v90 = v193;
            unint64_t v91 = v194;
          }
        }
        unint64_t v199 = v90;
        unint64_t v211 = HIDWORD(v90);
        unint64_t v198 = HIDWORD(v91);
        v93 = [(TSTTableRep *)a1 tableLayout];
        v232 = [(TSTTableRep *)a1 masterLayout];
        v217 = v93;
        v227 = [(TSTTableInfo *)[(TSTLayout *)v93 tableInfo] tableModel];
        unint64_t v94 = 0;
        if (v199 != -1 && v91 != -1 && v199 <= v91)
        {
          unint64_t v94 = 0;
          if (v211 != -1 && HIDWORD(v91) != -1 && v211 <= HIDWORD(v91)) {
            unint64_t v94 = ((v91 - (v199 & 0xFFFFFFFF00000000)) & 0xFFFFFFFF00000000 | (v91 - v199 + 1))
          }
                + 0x100000000;
        }
        if (v199 == -1) {
          unint64_t v95 = 16711680;
        }
        else {
          unint64_t v95 = (unint64_t)v199 << 16;
        }
        unint64_t v96 = (v94 >> 16) & 0xFFFF0000;
        BOOL v206 = [(TSTMasterLayout *)v232 useBandedFill];
        v219 = objc_alloc_init(TSTCell);
        v231 = objc_alloc_init(TSTCell);
        uint64_t v221 = [MEMORY[0x263EFF9D0] null];
        if ([(TSTMasterLayout *)v232 isDynamicallySwappingColumns]
          || (BOOL v97 = [(TSTMasterLayout *)v232 isDynamicallySwappingRows],
              unint64_t v98 = ((unint64_t)(v96 | v94) << 32) | WORD2(v199) | v95,
              v97))
        {
          unint64_t v98 = [(TSTTableModel *)v227 range];
        }
        id v208 = TSTTableMergeRangesForCellRange((uint64_t)v227, v98);
        uint64_t v214 = [v208 count];
        if (![(TSDCanvas *)[(TSDRep *)a1 canvas] isCanvasInteractive]) {
          CGContextBeginTransparencyLayer(a4, 0);
        }
        v99 = v219;
        if (v211 > HIDWORD(v91))
        {
LABEL_226:
          v61 = a4;
          if (!CGRectIsEmpty(a1->mSearchSelectionBounds))
          {
            CGContextSetFillColorWithColor(a4, (CGColorRef)objc_msgSend((id)objc_msgSend(MEMORY[0x263F7C808], "orangeColor"), "CGColor"));
            CGContextFillRect(a4, a1->mSearchSelectionBounds);
          }
          v63 = (void *)v196;
          v62 = v197;
          BOOL v89 = v190;
          if (![(TSDCanvas *)[(TSDRep *)a1 canvas] isCanvasInteractive]) {
            CGContextEndTransparencyLayer(a4);
          }

          CGContextRestoreGState(a4);
          goto LABEL_231;
        }
        if ((_BYTE)v94) {
          BOOL v102 = (((unint64_t)(v96 | v94) << 32) | WORD2(v199) | v95) >> 48 == 0;
        }
        else {
          BOOL v102 = 1;
        }
        char v103 = v102;
        char v213 = v103;
        int v210 = v211 + (v96 >> 16) - 1;
        unint64_t v207 = v95 >> 16;
        int v204 = v94 + WORD1(v95) + 255;
        BOOL v105 = WORD2(v199) == 0xFFFFLL || v95 == 16711680;
        char v200 = v105;
        LOWORD(VisibleRow) = v211;
        int v202 = v91;
        while (1)
        {
          unsigned int v216 = (unsigned __int16)VisibleRow;
          uint64_t RowFill = TSTTableGetRowFill((uint64_t *)v227, (unsigned __int16)VisibleRow);
          if (v199 <= v91) {
            break;
          }
LABEL_261:
          unsigned int VisibleRow = TSTMasterLayoutNextVisibleRow(v232, (unsigned __int16)(VisibleRow + 1));
          if (VisibleRow > v198) {
            goto LABEL_226;
          }
        }
        v215 = (TSDFill *)RowFill;
        int v108 = v199 << 16;
        unsigned int v109 = v199;
        unsigned __int16 v220 = VisibleRow;
        while (1)
        {
          uint64_t v110 = v108 & 0xFF0000 | v216;
          v238[0] = 0;
          int v229 = v108;
          if (!v214) {
            break;
          }
          unint64_t v218 = v218 & 0xFFFFFFFF00000000 | v110;
          [(TSTMasterLayout *)v232 modelCellIDForLayoutCellID:"modelCellIDForLayoutCellID:"];
          unint64_t v111 = objc_msgSend(v208, "mergedRangeForCellID:");
          unsigned int v112 = 0;
          if ((_WORD)v111 == 0xFFFF || (v111 & 0xFF0000) == 0xFF0000) {
            goto LABEL_273;
          }
          if (!HIWORD(v111) || (v111 & 0xFFFF00000000) == 0) {
            break;
          }
          unint64_t v203 = v203 & 0xFFFFFFFF00000000 | v111;
          $2F2D2FE54C0B9D2AA4EBD8788136C7D0 v118 = ($2F2D2FE54C0B9D2AA4EBD8788136C7D0)[(TSTMasterLayout *)v232 layoutCellIDForModelCellID:"layoutCellIDForModelCellID:"];
          unsigned int VisibleRow = HIWORD(*(unsigned int *)&v118);
          unsigned int v112 = HIBYTE(*(unsigned int *)&v118);
LABEL_274:
          unint64_t v230 = v230 & 0xFFFFFFFF00000000 | v110;
          uint64_t v114 = -[TSTMasterLayout tableAreaForCellID:](v232, "tableAreaForCellID:");
          [(TSTTableModel *)v227 defaultCell:v231 forTableArea:v114];
          CellFill = (void *)TSTCellGetCellFill(v231);
          uint64_t ColumnFill = TSTTableGetColumnFill((uint64_t *)v227, VisibleRow);
          unint64_t v116 = [(TSTLayout *)v217 editingSpillingTextRange];
          BOOL v117 = 0;
          if ((_WORD)v116 != 0xFFFF && (v116 & 0xFF0000) != 0xFF0000)
          {
            BOOL v117 = 0;
            if (HIWORD(v116))
            {
              if ((v116 & 0xFFFF00000000) != 0)
              {
                if (v118.var0 >= (unsigned __int16)v116)
                {
                  BOOL v117 = 0;
                  if ((unsigned __int16)(v116 + HIWORD(v116) - 1) >= v118.var0
                    && BYTE2(v116) <= VisibleRow)
                  {
                    BOOL v117 = (BYTE4(v116) + BYTE2(v116) - 1) >= VisibleRow;
                  }
                }
                else
                {
                  BOOL v117 = 0;
                }
              }
            }
          }
          BOOL v226 = v117;
          uint64_t v223 = v108 & 0xFF0000 | v216;
          uint64_t v119 = VisibleRow << 16;
          if (![(TSTMasterLayout *)v232 isDynamicallyChangingContent]) {
            goto LABEL_292;
          }
          if (v226)
          {
            $2F2D2FE54C0B9D2AA4EBD8788136C7D0 v120 = ($2F2D2FE54C0B9D2AA4EBD8788136C7D0)[(TSTEditingState *)[(TSTTableRep *)a1 editingState] editingCellID];
            uint64_t v121 = v120;
            if (v120.var0 == 0xFFFF || (*(_DWORD *)&v120 & 0xFF0000) == 0xFF0000)
            {
              v201 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
              uint64_t v122 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableRepDrawBackgroundFill(TSTTableRep *, TSTLayoutSpace *, TSTGridRange, CGContextRef)");
              objc_msgSend(v201, "handleFailureInFunction:file:lineNumber:description:", v122, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableRep.mm"), 5129, @"Valid editing spilling text range but no editing cell ID");
            }
          }
          else
          {
            uint64_t v121 = v119 | (v112 << 24) | v118.var0;
          }
          unint64_t v212 = v121 | v212 & 0xFFFFFFFF00000000;
          if (!-[TSTLayoutDynamicContentProtocol cell:forCellID:]([(TSTMasterLayout *)v232 dynamicContentDelegate], "cell:forCellID:", v238))
          {
            a1 = v209;
LABEL_292:
            unint64_t v124 = v119 | ((unint64_t)v112 << 24);
            unint64_t v224 = v124 | v118.var0 | v224 & 0xFFFFFFFF00000000;
            v99 = v219;
            int v125 = TSTCellAtCellIDSuppressingFormula((uint64_t)v227, v124 | v118.var0, v219, 1);
            uint64_t v123 = (uint64_t)v231;
            if (!v125) {
              goto LABEL_294;
            }
            goto LABEL_293;
          }
          uint64_t v123 = v238[0];
          a1 = v209;
          v99 = v219;
LABEL_293:
          TSTCellCopyJustStyleAndStrokes(v123, (uint64_t)v99);
LABEL_294:
          if (a1->mContainedTextEditingRep)
          {
            int v126 = v119 | v118.var0;
            if (v126 == ([(TSTEditingState *)[(TSTTableRep *)a1 editingState] editingCellID] & 0xFFFFFF))
            {
              BOOL v127 = 1;
              goto LABEL_299;
            }
          }
          else
          {
            int v126 = v119 | v118.var0;
          }
          BOOL v127 = (([(TSTMasterLayout *)[(TSTTableRep *)a1 masterLayout] dynamicSuppressingConditionalStylesCellID] ^ v126) & 0xFFFFFF) == 0;
LABEL_299:
          LOWORD(VisibleRow) = v220;
          LOBYTE(v233) = 0;
          CellFillAndIsDefault = (TSDFill *)TSTCellGetCellFillAndIsDefault(v99, CellFill, v127, (char *)&v233);
          if (v114) {
            BOOL v129 = 1;
          }
          else {
            BOOL v129 = v233 == 0;
          }
          if (v129) {
            v130 = CellFillAndIsDefault;
          }
          else {
            v130 = v215;
          }
          if (!v129 && !v215)
          {
            BOOL v131 = v206;
            if (ColumnFill)
            {
              BOOL v131 = 0;
              v130 = (TSDFill *)ColumnFill;
            }
            else
            {
              v130 = CellFillAndIsDefault;
            }
            if (v131)
            {
              unsigned __int16 v132 = v223 == (v119 | v118.var0) ? v220 : v118.var0;
              v130 = CellFillAndIsDefault;
              if ([(TSTMasterLayout *)v232 shouldRowUseBandedFill:v132]) {
                v130 = [(TSTMasterLayout *)v232 bandedFillObject];
              }
            }
          }
          if (v130) {
            BOOL v133 = v130 == (TSDFill *)v221;
          }
          else {
            BOOL v133 = 1;
          }
          char v134 = v213;
          if (v133) {
            char v134 = 1;
          }
          if ((v134 & 1) != 0
            || (unsigned __int16)v211 > v220
            || (unsigned __int16)v210 < v220
            || v207 > v109
            || v204 < v109)
          {
            goto LABEL_437;
          }
          unint64_t v135 = TSTMasterLayoutMergeRangeAtCellID([(TSTTableRep *)a1 masterLayout], v223);
          unint64_t v205 = v205 & 0xFFFFFFFF00000000 | v223;
          if (v226)
          {
            unint64_t v136 = [(TSTLayout *)v217 editingSpillingTextRange];
            if ((_WORD)v136 == 0xFFFF) {
              goto LABEL_337;
            }
            uint64_t v137 = 0xFFFFLL;
            int v138 = 16711680;
            if ((v136 & 0xFF0000) != 0xFF0000)
            {
              BOOL v139 = (v136 & 0xFFFF00000000) == 0 || HIWORD(v136) == 0;
              char v140 = v200;
              if (v139) {
                char v140 = 1;
              }
              if (v140)
              {
LABEL_337:
                uint64_t v137 = 0xFFFFLL;
                int v138 = 16711680;
              }
              else
              {
                uint64_t v137 = 0;
                unsigned int v170 = v204;
                unsigned int v171 = BYTE2(v136);
                if (BYTE2(v136) <= v207) {
                  unsigned int v171 = v207;
                }
                if ((unsigned __int16)v136 <= (unsigned __int16)v211) {
                  uint64_t v172 = (unsigned __int16)v211;
                }
                else {
                  uint64_t v172 = (unsigned __int16)v136;
                }
                if ((BYTE4(v136) + BYTE2(v136) - 1) < v204) {
                  unsigned int v170 = (BYTE4(v136) + BYTE2(v136) - 1);
                }
                unsigned int v173 = (unsigned __int16)(v136 + HIWORD(v136) - 1);
                if (v173 >= (unsigned __int16)v210) {
                  unsigned int v173 = (unsigned __int16)v210;
                }
                if (v172 > v173)
                {
                  int v138 = 0;
                }
                else
                {
                  int v138 = 0;
                  if (v171 <= v170)
                  {
                    int v138 = v171 << 16;
                    uint64_t v137 = v172;
                  }
                }
              }
            }
            uint64_t v141 = *(void *)&v138 & 0xFF0000 | v137;
            BOOL v142 = v141 == v223;
            if (v141 == v223) {
              unint64_t v143 = v136;
            }
            else {
              unint64_t v143 = v223 | 0x1000100000000;
            }
LABEL_341:
            if (!v142) {
              v130 = (TSDFill *)v221;
            }
            goto LABEL_352;
          }
          unint64_t v143 = v135;
          if ((_WORD)v135 != 0xFFFF && (v135 & 0xFF0000) != 0xFF0000 && HIWORD(v135) && (v135 & 0xFFFF00000000) != 0)
          {
            if (v200)
            {
              uint64_t v144 = 0xFFFFLL;
              int v145 = 16711680;
            }
            else
            {
              uint64_t v144 = 0;
              unsigned int v175 = v204;
              unsigned int v176 = BYTE2(v135);
              if (BYTE2(v135) <= v207) {
                unsigned int v176 = v207;
              }
              if ((unsigned __int16)v135 <= (unsigned __int16)v211) {
                uint64_t v177 = (unsigned __int16)v211;
              }
              else {
                uint64_t v177 = (unsigned __int16)v135;
              }
              if ((BYTE4(v135) + BYTE2(v135) - 1) < v204) {
                unsigned int v175 = (BYTE4(v135) + BYTE2(v135) - 1);
              }
              unsigned int v178 = (unsigned __int16)(v135 + HIWORD(v135) - 1);
              if (v178 >= (unsigned __int16)v210) {
                unsigned int v178 = (unsigned __int16)v210;
              }
              if (v177 > v178)
              {
                int v145 = 0;
              }
              else
              {
                int v145 = 0;
                if (v176 <= v175)
                {
                  int v145 = v176 << 16;
                  uint64_t v144 = v177;
                }
              }
            }
            BOOL v142 = (*(void *)&v145 & 0xFF0000 | v144) == v223;
            goto LABEL_341;
          }
          unint64_t v143 = v223 | 0x1000100000000;
LABEL_352:
          if (BYTE2(v143) == 255) {
            unsigned int v146 = -1;
          }
          else {
            unsigned int v146 = BYTE2(v143);
          }
          int v147 = (unsigned __int16)v143;
          if (WORD2(v143)) {
            unsigned int v148 = WORD2(v143) + v146 - 1;
          }
          else {
            unsigned int v148 = -1;
          }
          if ((unsigned __int16)v143 == 0xFFFF) {
            unsigned int v149 = -1;
          }
          else {
            unsigned int v149 = (unsigned __int16)v143;
          }
          uint64_t v150 = TSTLayoutSpaceGetGridRange((uint64_t)a2);
          if (HIWORD(v143)) {
            unsigned int v153 = v149 + ((unint64_t)((HIDWORD(v143) << 16) - 0x100000000) >> 32);
          }
          else {
            unsigned int v153 = -1;
          }
          unint64_t v154 = -1;
          if (BYTE2(v143) == 255 || v148 == -1)
          {
            unint64_t v155 = -1;
          }
          else
          {
            unint64_t v155 = -1;
            if (v146 <= v148
              && v147 != 0xFFFF
              && v153 != -1
              && v149 <= v153
              && v150 != -1
              && v151 != -1
              && v150 <= v151
              && HIDWORD(v150) != -1
              && v152 != -1
              && HIDWORD(v150) <= v152)
            {
              uint64_t v156 = v146 <= v150 ? v150 : v146;
              uint64_t v157 = v148 >= v151 ? v151 : v148;
              if (v156 <= v157)
              {
                uint64_t v158 = v153 >= v152 ? v152 : v153;
                uint64_t v159 = v149 <= HIDWORD(v150) ? HIDWORD(v150) : v149;
                if (v159 <= v158)
                {
                  unint64_t v155 = v157 | (v158 << 32);
                  unint64_t v154 = v156 | (v159 << 32);
                }
              }
            }
          }
          AlignedFrameForGridunint64_t Range = TSTLayoutSpaceGetAlignedFrameForGridRange(a2, v154, v155);
          if (v130 == (TSDFill *)v221)
          {
            a1 = v209;
            v99 = v219;
            LOWORD(VisibleRow) = v220;
            LODWORD(v91) = v202;
          }
          else
          {
            double v164 = AlignedFrameForGridRange;
            double v165 = v161;
            double v166 = v162;
            double v167 = v163;
            objc_opt_class();
            v99 = v219;
            LOWORD(VisibleRow) = v220;
            LODWORD(v91) = v202;
            if (objc_opt_isKindOfClass())
            {
              a1 = v209;
              if (![(TSDFill *)v130 isClear]) {
                -[TSDFill paintRect:inContext:](v130, "paintRect:inContext:", a4, v164, v165, v166, v167);
              }
            }
            else
            {
              v168 = NSString;
              if ((HIDWORD(v154) & v154) == 0xFFFFFFFF)
              {
                v174 = @"{invalid, invalid}";
              }
              else
              {
                if (v154 == -1)
                {
                  uint64_t v169 = [NSString stringWithFormat:@"{invalid, %u}", HIDWORD(v154), v189];
                }
                else if (HIDWORD(v154) == -1)
                {
                  uint64_t v169 = [NSString stringWithFormat:@"{%u, invalid}", v154, v189];
                }
                else
                {
                  uint64_t v169 = [NSString stringWithFormat:@"{%u, %u}", v154, HIDWORD(v154)];
                }
                v174 = (__CFString *)v169;
              }
              if ((HIDWORD(v155) & v155) == 0xFFFFFFFF)
              {
                v179 = @"{invalid, invalid}";
              }
              else if (v155 == -1)
              {
                v179 = (__CFString *)[NSString stringWithFormat:@"{invalid, %u}", HIDWORD(v155), v189];
              }
              else if (HIDWORD(v155) == -1)
              {
                v179 = (__CFString *)[NSString stringWithFormat:@"{%u, invalid}", v155, v189];
              }
              else
              {
                v179 = (__CFString *)[NSString stringWithFormat:@"{%u, %u}", v155, HIDWORD(v155)];
              }
              uint64_t v180 = [v168 stringWithFormat:@"{%@->%@}", v174, v179];
              v189 = v130;
              NSLog((NSString *)@"WARNING: invalid cell fill %@ %@", v180);
              a1 = v209;
            }
          }
LABEL_437:
          TSTCellClear((uint64_t)v99);
          TSTCellClear((uint64_t)v231);
          ++v109;
          int v108 = v229 + 0x10000;
          if (v109 > v91) {
            goto LABEL_261;
          }
        }
        unsigned int v112 = 0;
LABEL_273:
        v118.var0 = VisibleRow;
        LOBYTE(VisibleRow) = v109;
        goto LABEL_274;
      }
    }
  }
LABEL_30:
  [(TSDCanvas *)[(TSDRep *)a1 canvas] viewScale];
  TSTTableRepSetupUserSpaceToDeviceSpaceTransform(a1, v16, a1->mCurrentScreenScale);
}

double TSTTableRepGetImageFrameForRange(double *a1, unint64_t a2, int a3)
{
  int v6 = (TSTLayout *)[a1 tableLayout];
  AlignedStrokeFrameForunint64_t Range = TSTLayoutGetAlignedStrokeFrameForRange(v6, a2);
  CGFloat v9 = v8;
  CGFloat v11 = v10;
  CGFloat v13 = v12;
  if (a3)
  {
    v28.origin.CGFloat x = TSTLayoutGetAlignedStrokeFrameForTableNameBorder(v6);
    CGFloat x = v28.origin.x;
    CGFloat y = v28.origin.y;
    CGFloat width = v28.size.width;
    CGFloat height = v28.size.height;
    if (!CGRectIsEmpty(v28))
    {
      v29.origin.CGFloat x = x;
      v29.origin.CGFloat y = y;
      v29.size.CGFloat width = width;
      v29.size.CGFloat height = height;
      v33.origin.CGFloat x = AlignedStrokeFrameForRange;
      v33.origin.CGFloat y = v9;
      v33.size.CGFloat width = v11;
      v33.size.CGFloat height = v13;
      CGRect v30 = CGRectUnion(v29, v33);
      AlignedStrokeFrameForunint64_t Range = v30.origin.x;
      CGFloat v9 = v30.origin.y;
      CGFloat v11 = v30.size.width;
      CGFloat v13 = v30.size.height;
    }
  }
  memset(&v27, 0, sizeof(v27));
  TSTLayoutGetTransformToDevice(v6, &v27);
  CGAffineTransform v26 = v27;
  v31.origin.CGFloat x = AlignedStrokeFrameForRange;
  v31.origin.CGFloat y = v9;
  v31.size.CGFloat width = v11;
  v31.size.CGFloat height = v13;
  CGRect v32 = CGRectApplyAffineTransform(v31, &v26);
  double v18 = a1[55];
  double v19 = TSDMultiplyRectScalar(v32.origin.x, v32.origin.y, v32.size.width, v32.size.height, 1.0 / v18);
  double v23 = TSDRoundedRectForScale(v19, v20, v21, v22, v18);
  TSDCeilSize(v24);
  return v23;
}

double TSTTableRepGetDrawnFrameInsideImageFrameForRange(double *a1, unint64_t a2)
{
  uint64_t v4 = (TSTLayout *)[a1 tableLayout];
  AlignedStrokeFrameForunint64_t Range = TSTLayoutGetAlignedStrokeFrameForRange(v4, a2);
  CGFloat v7 = v6;
  CGFloat v9 = v8;
  CGFloat v11 = v10;
  memset(&v19, 0, sizeof(v19));
  TSTLayoutGetTransformToDevice(v4, &v19);
  CGAffineTransform v18 = v19;
  v20.origin.CGFloat x = AlignedStrokeFrameForRange;
  v20.origin.CGFloat y = v7;
  v20.size.CGFloat width = v9;
  v20.size.CGFloat height = v11;
  CGRect v21 = CGRectApplyAffineTransform(v20, &v18);
  double v12 = a1[55];
  double v13 = TSDMultiplyRectScalar(v21.origin.x, v21.origin.y, v21.size.width, v21.size.height, 1.0 / v12);
  TSDRoundedRectForScale(v13, v14, v15, v16, v12);
  return *MEMORY[0x263F00148];
}

uint64_t TSTTableRepGetImageForRange(TSTTableRep *a1, unint64_t a2)
{
  id v4 = +[TSTAnimation newAnimationWithLayout:[(TSTTableRep *)a1 tableLayout] andCellRange:a2];
  id v5 = v4;
  ImageFrameForunint64_t Range = TSTTableRepGetImageFrameForRange((double *)a1, a2, 0);
  CGFloat v8 = v7;
  CGFloat v10 = v9;
  CGFloat v12 = v11;
  DrawnFrameInsideImageFrameForunint64_t Range = TSTTableRepGetDrawnFrameInsideImageFrameForRange((double *)a1, a2);
  CGFloat v15 = v14;
  CGFloat v17 = v16;
  CGFloat v19 = v18;
  [(TSDCanvas *)[(TSDRep *)a1 canvas] contentsScale];
  double v21 = TSDMultiplyRectScalar(ImageFrameForRange, v8, v10, v12, v20);
  double v23 = v22;
  CGFloat v25 = v24;
  [(TSDCanvas *)[(TSDRep *)a1 canvas] contentsScale];
  double v27 = TSDMultiplyRectScalar(DrawnFrameInsideImageFrameForRange, v15, v17, v19, v26);
  CGFloat v29 = v28;
  CGFloat v31 = v30;
  CGFloat v33 = v32;
  uint64_t v34 = TSDBitmapContextCreate(3, v23);
  CGContextTranslateCTM(v34, 0.0, v25);
  CGContextScaleCTM(v34, 1.0, -1.0);
  v49.origin.CGFloat x = v27;
  v49.origin.CGFloat y = v29;
  v49.size.CGFloat width = v31;
  v49.size.CGFloat height = v33;
  CGContextClipToRect(v34, v49);
  [(TSDCanvas *)[(TSDRep *)a1 canvas] contentsScale];
  CGContextScaleCTM(v34, v35, v35);
  [(TSDCanvas *)[(TSDRep *)a1 canvas] viewScale];
  CGFloat v37 = v36;
  CGContextTranslateCTM(v34, -ImageFrameForRange, -v8);
  [(TSTTableRep *)a1 layerFrameInScaledCanvas];
  CGContextTranslateCTM(v34, -v38, -v39);
  CGContextScaleCTM(v34, v37, v37);
  uint64_t v40 = [(TSDRep *)a1 layout];
  if (v40) {
    [(TSDAbstractLayout *)v40 transformInRoot];
  }
  else {
    memset(&transform, 0, sizeof(transform));
  }
  CGContextConcatCTM(v34, &transform);
  if (a1) {
    [(TSTTableRep *)a1 transformFromCanvas];
  }
  else {
    memset(&v47, 0, sizeof(v47));
  }
  CGContextConcatCTM(v34, &v47);
  [(TSTTableRep *)a1 pushAnimation:v4];
  TSTTableRepDrawRangeInContext(a1, a2, (uint64_t)v34);
  [(TSTTableRep *)a1 popAnimation];
  Image = CGBitmapContextCreateImage(v34);
  uint64_t v42 = [MEMORY[0x263F7C858] imageWithCGImage:Image];
  CGImageRelease(Image);
  CGContextRelease(v34);
  [(TSDCanvas *)[(TSDRep *)a1 canvas] viewScale];
  CGFloat v44 = v43;
  [(TSDCanvas *)[(TSDRep *)a1 canvas] contentsScale];
  TSTTableRepSetupUserSpaceToDeviceSpaceTransform(a1, v44, v45);
  return v42;
}

uint64_t TSTTableRepPrepareToDrawLayoutSpace(TSTTableRep *a1, TSTLayoutSpace *a2, CGContextRef c)
{
  if (a2)
  {
    CGContextSaveGState(c);
    [(TSTLayoutSpace *)a2 transformToCanvas];
  }
  else
  {
    double v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableRepPrepareToDrawLayoutSpace(TSTTableRep *, TSTLayoutSpace *, CGContextRef)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableRep.mm"), 4786, @"invalid nil value for '%s'", "space");
    CGContextSaveGState(c);
    memset(&transform, 0, sizeof(transform));
  }
  CGContextConcatCTM(c, &transform);
  if ([(TSDCanvas *)[(TSDRep *)a1 canvas] isDrawingIntoPDF]) {
    goto LABEL_14;
  }
  long long v9 = 0uLL;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v13 = 0u;
  if (a2)
  {
    [(TSTLayoutSpace *)a2 transformToDevice];
    long long v9 = 0uLL;
  }
  *(_OWORD *)&v12.c = v9;
  *(_OWORD *)&v12.tCGFloat x = v9;
  *(_OWORD *)&v12.a = v9;
  CGContextGetCTM(&v12, c);
  double b = *(double *)&v13;
  if (*(double *)&v13 < 0.0) {
    goto LABEL_14;
  }
  if (*((double *)&v14 + 1) >= 0.0
    && *((double *)&v15 + 1) + *((double *)&v13 + 1) + *((double *)&v14 + 1) * 0.0 == *((double *)&v15 + 1)
                                                                                    + *((double *)&v14 + 1) * 0.0
                                                                                    + *((double *)&v13 + 1) * 0.0
    && (double b = *(double *)&v15 + *(double *)&v14 * 0.0 + *(double *)&v13 * 0.0,
        *(double *)&v15 + *(double *)&v14 + *(double *)&v13 * 0.0 == b)
    && (double b = v12.b, v12.b == 0.0)
    && (double b = v12.c, v12.c == 0.0))
  {
    uint64_t v10 = 1;
  }
  else
  {
LABEL_14:
    uint64_t v10 = 0;
  }
  -[TSTLayoutSpace setDrawPreventAntialias:](a2, "setDrawPreventAntialias:", v10, b);
  [(TSTLayoutSpace *)a2 setDrawBlackAndWhite:0];
  uint64_t result = [(TSTAnimation *)[(TSTTableRep *)a1 currentAnimation] enabled];
  if (result)
  {
    uint64_t result = [(TSTAnimation *)[(TSTTableRep *)a1 currentAnimation] drawsBlackAndWhite];
    if (result) {
      return [(TSTLayoutSpace *)a2 setDrawBlackAndWhite:1];
    }
  }
  return result;
}

uint64_t TSTTableRepDrawCellContent(void *a1, TSTLayoutSpace *a2, unint64_t a3, unint64_t a4, CGContext *a5)
{
  uint64_t v363 = *MEMORY[0x263EF8340];
  v311 = (void *)[a1 tableLayout];
  long long v9 = (void *)[v311 masterLayout];
  if (!objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "dynamicRepResize")
    || (uint64_t result = TSTTableNumberOfPopulatedCells([a1 tableModel]), result <= 0x19))
  {
    uint64_t result = [a1 isDrawingInFlippedContext];
    unsigned int v291 = result;
    BOOL v11 = a3 == -1 || a4 == -1;
    BOOL v12 = v11 || a3 > a4;
    BOOL v13 = v12;
    int v304 = v13;
    unint64_t v14 = 0;
    if (v12)
    {
      unint64_t v15 = HIDWORD(a3);
    }
    else
    {
      unint64_t v15 = HIDWORD(a3);
      if (HIDWORD(a3) != -1 && HIDWORD(a4) != -1 && HIDWORD(a3) <= HIDWORD(a4)) {
        unint64_t v14 = ((a4 - (a3 & 0xFFFFFFFF00000000)) & 0xFFFFFFFF00000000 | (a4 - a3 + 1)) + 0x100000000;
      }
    }
    unsigned __int16 v284 = v15;
    if (v15 <= HIDWORD(a4))
    {
      if (a3 == -1) {
        unint64_t v16 = 16711680;
      }
      else {
        unint64_t v16 = (unint64_t)a3 << 16;
      }
      uint64_t v301 = (a4 - a3 + 1) | 0x100000000;
      unint64_t v302 = v16;
      BOOL v18 = (~a3 & 0xFFFF00000000) != 0 && v16 != 16711680;
      BOOL v312 = v18;
      BOOL v19 = v14 != 0;
      if (((v14 >> 16) & 0xFFFF0000) == 0) {
        BOOL v19 = 0;
      }
      BOOL v300 = v19;
      unint64_t v283 = v16 >> 16;
      int v282 = v14 + WORD1(v16) + 255;
      int v281 = v15 + (((v14 >> 16) & 0xFFFF0000) >> 16) - 1;
      LODWORD(result) = v15;
      v335 = a1;
      v316 = v9;
      unint64_t v303 = HIDWORD(a4);
      do
      {
        int v317 = result;
        int v20 = v304;
        if (result == -1) {
          int v20 = 1;
        }
        BOOL v11 = v20 == 0;
        unint64_t v21 = v301;
        if (!v11) {
          unint64_t v21 = 0;
        }
        unint64_t v22 = (unsigned __int16)result | (((v21 >> 16) & 0x10000 | v21) << 32) | v302;
        uint64_t v23 = (unsigned __int16)result | v302;
        if (v23 >= 0x10000)
        {
          v356.a = 0.0;
          unint64_t v299 = v299 & 0xFFFFFFFF00000000 | v23;
          char v24 = objc_msgSend(v9, "cell:forCellID:", &v356);
          v356.a = 0.0;
          if ((v24 & 1) == 0)
          {
            unint64_t v280 = v280 & 0xFFFFFFFF00000000 | v23;
            unint64_t v279 = v279 & 0xFFFFFFFF00000000 | TSTLayoutCellLeftOfCell(v311, v280, 0);
            unint64_t v22 = TSTCellRangeUnionCellID(v22, v279);
          }
        }
        unsigned __int8 v25 = BYTE2(v22);
        unint64_t v26 = HIDWORD(v22);
        int v27 = (BYTE4(v22) + BYTE2(v22) - 1);
        if (v27 != TSTMasterLayoutGetTableNumberOfColumns((uint64_t)v9) - 1)
        {
          uint64_t v28 = (unsigned __int16)v22 | (v27 << 16);
          v356.a = 0.0;
          unint64_t v298 = v298 & 0xFFFFFFFF00000000 | v28;
          char v29 = objc_msgSend(v9, "cell:forCellID:", &v356);
          v356.a = 0.0;
          if ((v29 & 1) == 0)
          {
            unint64_t v278 = v278 & 0xFFFFFFFF00000000 | v28;
            unint64_t v277 = v277 & 0xFFFFFFFF00000000 | TSTLayoutCellRightOfCell(v311, v28, 0);
            unint64_t v22 = TSTCellRangeUnionCellID(v22, v277);
            unint64_t v26 = HIDWORD(v22);
            unsigned __int8 v25 = BYTE2(v22);
          }
        }
        unint64_t v30 = v5;
        if (v25 == 255) {
          unsigned int v31 = -1;
        }
        else {
          unsigned int v31 = v25;
        }
        if ((_WORD)v26) {
          unsigned int v32 = (unsigned __int16)v26 + v31 - 1;
        }
        else {
          unsigned int v32 = -1;
        }
        if ((unsigned __int16)v22 == 0xFFFF) {
          unsigned int v33 = -1;
        }
        else {
          unsigned int v33 = (unsigned __int16)v22;
        }
        unsigned int v34 = v33 + (((v26 << 16) - 0x100000000) >> 32);
        Gridunint64_t Range = TSTLayoutSpaceGetGridRange((uint64_t)a2);
        unint64_t v38 = 0;
        if (HIWORD(v22)) {
          unsigned int v39 = v34;
        }
        else {
          unsigned int v39 = -1;
        }
        int v40 = -1;
        unsigned int v41 = -1;
        unsigned int v42 = -1;
        if (v25 == 255)
        {
          unsigned int v44 = -1;
          long long v9 = v316;
        }
        else
        {
          BOOL v43 = v32 == -1 || v31 > v32;
          unsigned int v44 = -1;
          long long v9 = v316;
          if (!v43)
          {
            unint64_t v38 = 0;
            unsigned int v41 = -1;
            unsigned int v42 = -1;
            if ((unsigned __int16)v22 == 0xFFFF || v39 == -1) {
              goto LABEL_83;
            }
            unsigned int v44 = -1;
            if (v33 > v39) {
              goto LABEL_85;
            }
            unint64_t v38 = 0;
            unsigned int v41 = -1;
            unsigned int v42 = -1;
            if (GridRange == -1 || v36 == -1) {
              goto LABEL_83;
            }
            unsigned int v44 = -1;
            if (GridRange > v36) {
              goto LABEL_85;
            }
            unint64_t v38 = 0;
            unsigned int v41 = -1;
            unsigned int v42 = -1;
            if (HIDWORD(GridRange) == -1 || v37 == -1)
            {
LABEL_83:
              unsigned int v44 = -1;
            }
            else
            {
              unsigned int v44 = -1;
              if (HIDWORD(GridRange) <= v37)
              {
                if (v31 <= GridRange) {
                  unsigned int v44 = GridRange;
                }
                else {
                  unsigned int v44 = v31;
                }
                if (v32 >= v36) {
                  unsigned int v42 = v36;
                }
                else {
                  unsigned int v42 = v32;
                }
                if (v44 > v42) {
                  goto LABEL_82;
                }
                if (v39 >= v37) {
                  unsigned int v39 = v37;
                }
                unsigned int v41 = v33 <= HIDWORD(GridRange) ? HIDWORD(GridRange) : v33;
                if (v41 <= v39)
                {
                  unint64_t v38 = 0;
                  int v40 = v44;
                  if (v44 != -1 && v42 != -1)
                  {
                    BOOL v263 = v41 == -1 || v39 == -1;
                    if (v263 || v41 > v39) {
                      unint64_t v38 = 0;
                    }
                    else {
                      unint64_t v38 = ((v42 - v44 + 1) | ((unint64_t)(v39 - v41) << 32)) + 0x100000000;
                    }
                  }
                }
                else
                {
LABEL_82:
                  unint64_t v38 = 0;
                  unsigned int v41 = -1;
                  unsigned int v42 = -1;
                  unsigned int v44 = -1;
                }
              }
            }
          }
        }
LABEL_85:
        unsigned int v305 = v44;
        unsigned __int8 v306 = v40;
        unsigned int v307 = v42;
        if (v40 == -1) {
          unint64_t v45 = 16711680;
        }
        else {
          unint64_t v45 = (unint64_t)v40 << 16;
        }
        unint64_t v46 = (v38 >> 16) & 0xFFFF0000;
        unint64_t v47 = v45 & 0xFFFFFFFFFFFF0000 | ((unint64_t)(v46 | v38) << 32) | (unsigned __int16)v41;
        unsigned int v48 = v41;
        CGRect v49 = [[TSTLayoutCellIterator alloc] initWithLayout:v311 range:v47 flags:1];
        int v315 = [v9 isDynamicallyHidingRowsCols];
        v347 = v49;
        if (TSTLayoutCellIteratorGetNextCell((uint64_t)v49, v349))
        {
          BOOL v51 = (unsigned __int16)v48 != 0xFFFFLL && v45 != 16711680;
          BOOL v297 = v51;
          if ((_BYTE)v38) {
            BOOL v52 = HIWORD(v47) == 0;
          }
          else {
            BOOL v52 = 1;
          }
          int v53 = !v52;
          int v290 = v53;
          unint64_t v287 = v45 >> 16;
          unsigned __int16 v288 = v48;
          int v285 = v48 + (v46 >> 16) - 1;
          int v286 = v38 + WORD1(v45) + 255;
          uint64_t v341 = 0xFFFFFFLL;
          uint64_t v54 = v335;
          unint64_t v5 = v30;
          int v55 = v315;
          while (1)
          {
            unsigned int v56 = v350;
            v348 = (TSTCell *)v349[1];
            uint64_t v57 = HIBYTE(v349[0]);
            if ((_WORD)v350 == 0xFFFF) {
              goto LABEL_114;
            }
            BOOL v58 = (v350 & 0xFF0000) == 0xFF0000 || HIWORD(v350) == 0;
            BOOL v59 = v58 || (v350 & 0xFFFF00000000) == 0;
            if (v59 || (WORD2(v349[0]) | ((unint64_t)BYTE6(v349[0]) << 16)) == (v350 & 0xFFFFFF)) {
              goto LABEL_114;
            }
            unint64_t v61 = v350 >> 16;
            if (v312 && v300)
            {
              uint64_t v95 = 0;
              unsigned int v96 = BYTE2(v350);
              if (BYTE2(v350) <= v283) {
                unsigned int v96 = v283;
              }
              if ((unsigned __int16)v350 <= v284) {
                uint64_t v97 = v284;
              }
              else {
                uint64_t v97 = (unsigned __int16)v350;
              }
              if ((BYTE4(v350) + BYTE2(v350) - 1) >= v282) {
                unsigned int v98 = v282;
              }
              else {
                unsigned int v98 = (BYTE4(v350) + BYTE2(v350) - 1);
              }
              if ((unsigned __int16)(v350 + HIWORD(v350) - 1) >= (unsigned __int16)v281) {
                unsigned int v99 = (unsigned __int16)v281;
              }
              else {
                unsigned int v99 = (unsigned __int16)(v350 + HIWORD(v350) - 1);
              }
              uint64_t v100 = 0;
              unint64_t v101 = 0;
              unint64_t v102 = 0;
              if (v97 <= v99 && v96 <= v98)
              {
                unint64_t v102 = ((unint64_t)(v99 - v97) << 48) + 0x1000000000000;
                unint64_t v101 = (unint64_t)(unsigned __int16)(v98 - v96 + 1) << 32;
                uint64_t v100 = v96 << 16;
                uint64_t v95 = v97;
              }
            }
            else
            {
              unint64_t v101 = 0;
              unint64_t v102 = 0;
              uint64_t v95 = 0xFFFFLL;
              uint64_t v100 = 16711680;
            }
            unint64_t v103 = v100 | v102 | v95 | v101;
            if ((_WORD)v103 == 0xFFFF
              || (v103 & 0xFF0000) == 0xFF0000
              || !HIWORD(v103)
              || (v103 & 0xFFFF00000000) == 0
              || v317 != (unsigned __int16)v103)
            {
              goto LABEL_114;
            }
            if (v297 && v290)
            {
              uint64_t v104 = 0;
              unsigned int v105 = BYTE2(v350);
              if (BYTE2(v350) <= v287) {
                unsigned int v105 = v287;
              }
              if ((unsigned __int16)v350 <= v288) {
                uint64_t v106 = v288;
              }
              else {
                uint64_t v106 = (unsigned __int16)v350;
              }
              if ((BYTE4(v350) + BYTE2(v350) - 1) >= v286) {
                unsigned int v107 = v286;
              }
              else {
                unsigned int v107 = (BYTE4(v350) + BYTE2(v350) - 1);
              }
              if ((unsigned __int16)(v350 + HIWORD(v350) - 1) >= (unsigned __int16)v285) {
                unsigned int v108 = (unsigned __int16)v285;
              }
              else {
                unsigned int v108 = (unsigned __int16)(v350 + HIWORD(v350) - 1);
              }
              uint64_t v109 = 0;
              unint64_t v110 = 0;
              unint64_t v111 = 0;
              if (v106 <= v108 && v105 <= v107)
              {
                unint64_t v111 = ((unint64_t)(v108 - v106) << 48) + 0x1000000000000;
                unint64_t v110 = (unint64_t)(unsigned __int16)(v107 - v105 + 1) << 32;
                uint64_t v109 = v105 << 16;
                uint64_t v104 = v106;
              }
            }
            else
            {
              unint64_t v110 = 0;
              unint64_t v111 = 0;
              uint64_t v104 = 0xFFFFLL;
              uint64_t v109 = 16711680;
            }
            unint64_t v113 = v109 | v111 | v104 | v110;
            if ((_WORD)v113 == 0xFFFF
              || (v113 & 0xFF0000) == 0xFF0000
              || !HIWORD(v113)
              || (v113 & 0xFFFF00000000) == 0
              || BYTE6(v349[0]) != BYTE2(v113))
            {
LABEL_114:
              LOBYTE(v61) = BYTE6(v349[0]);
              LOWORD(v56) = WORD2(v349[0]);
            }
            else
            {
              uint64_t v57 = BYTE3(v350);
              unint64_t v269 = v269 & 0xFFFFFFFF00000000 | v350;
              if ((objc_msgSend(v9, "cell:forCellID:", &v348) & 1) == 0)
              {
                v348 = objc_alloc_init(TSTCell);
                uint64_t v114 = [v54 tableModel];
                unint64_t v265 = v56 | v265 & 0xFFFFFFFF00000000;
                TSTCellAtCellID(v114, v56, v348);
              }
            }
            if (!v348) {
              goto LABEL_169;
            }
            unint64_t v62 = (v57 << 24) | ((unint64_t)v61 << 16) | (unsigned __int16)v56;
            unint64_t v5 = v62 | v5 & 0xFFFFFFFF00000000;
            int v63 = [v9 modelCellIDForLayoutCellID:v5];
            unint64_t v64 = (void *)[v9 cellIDToWPColumnCache];
            HIDWORD(v65) = v63;
            LODWORD(v65) = v63;
            unint64_t v66 = (TSWPStorage *)objc_msgSend(v64, "objectForKey:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", (v65 >> 16) & 0xFFFF00FF));
            if (v66)
            {
              if (!v55) {
                goto LABEL_125;
              }
            }
            else
            {
              if (v348 && *((unsigned __int8 *)&v348->mPrivate + 1) << 8 == 2304) {
                unint64_t v67 = [(TSTRichTextPayload *)v348->mPrivate.mRichTextPayload storage];
              }
              else {
                unint64_t v67 = (TSWPStorage *)NSStringFromNativeTSTCell((__CFString *)v348);
              }
              unint64_t v66 = v67;
              if (!v55)
              {
LABEL_125:
                uint64_t v68 = v66;
                v344 = v348;
                int v337 = HIDWORD(v349[0]);
                v340 = (void *)[v54 tableLayout];
                uint64_t v69 = (void *)[v54 tableModel];
                int v70 = objc_msgSend((id)objc_msgSend(v54, "masterLayout"), "isDynamicallyResizingCellID:", v62);
                id v360 = 0;
                unsigned int v71 = objc_msgSend((id)objc_msgSend(v54, "masterLayout"), "modelCellIDForLayoutCellID:", v62);
                context = (void *)MEMORY[0x223CB9570]();
                objc_opt_class();
                unint64_t v346 = v5;
                if ((objc_opt_isKindOfClass() & 1) != 0
                  || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0) && [(TSWPStorage *)v66 length])
                {
                  BOOL v72 = 1;
                  goto LABEL_131;
                }
                objc_opt_class();
                if (objc_opt_isKindOfClass())
                {
                  BOOL v72 = [(TSWPStorage *)v66 length] != 0;
LABEL_131:
                  BOOL v343 = v72;
                }
                else
                {
                  BOOL v343 = 0;
                }
                unint64_t v73 = v62 | 0x1000100000000;
                if ((objc_msgSend((id)objc_msgSend(v54, "masterLayout"), "isDynamicallyHidingContentOfCellID:", v62) & 1) == 0
                  && (objc_msgSend((id)objc_msgSend(v54, "masterLayout"), "isDynamicallyHidingRowsColsCellID:", v62) & 1) == 0)
                {
                  if (!objc_msgSend((id)objc_msgSend(v54, "masterLayout"), "isDynamicallyHidingTextOfCellID:", v62))goto LABEL_139; {
                  BOOL v74 = (BOOL)v344;
                  }
                  if (v344 && (v344->mPrivate.mCellFormats.mCurrentCellFormat.mFormatType - 263) <= 4)
                  {
                    TSTCellClearValue((uint64_t)v344);
                    BOOL v74 = (BOOL)v344;
                  }
                  if (TSTTableBadgeIsDrawingControlCell(v74))
                  {
LABEL_139:
                    unint64_t v75 = TSTMasterLayoutMergeRangeAtCellID((void *)[v54 masterLayout], v62);
                    BOOL v76 = (~v75 & 0xFF0000) != 0 && (_WORD)v75 != 0xFFFF;
                    BOOL v328 = v76;
                    if (v76)
                    {
                      BOOL v77 = (v75 & 0xFFFF00000000) != 0;
                      BOOL v78 = HIWORD(v75) != 0;
                      BOOL v79 = v78 && v77;
                      if (v78 && v77) {
                        uint64_t v80 = v75;
                      }
                      else {
                        uint64_t v80 = v62 | 0x1000100000000;
                      }
                      uint64_t v81 = [v54 canvas];
                      if (!v343)
                      {
                        unint64_t v73 = v80;
                        uint64_t v54 = v335;
                        long long v9 = v316;
                        int v55 = v315;
                        goto LABEL_450;
                      }
                      v309 = (void *)v81;
                      if (v79)
                      {
                        unint64_t v73 = v75;
                        if (BYTE2(v75) == 255) {
                          unsigned int v82 = -1;
                        }
                        else {
                          unsigned int v82 = BYTE2(v75);
                        }
                        uint64_t v83 = WORD2(v75) + v82 - 1;
                        if (!WORD2(v75)) {
                          uint64_t v83 = 0xFFFFFFFFLL;
                        }
                        if ((unsigned __int16)v75 == 0xFFFF) {
                          uint64_t v84 = 0xFFFFFFFFLL;
                        }
                        else {
                          uint64_t v84 = (unsigned __int16)v75;
                        }
                        unint64_t v85 = v82 | ((unint64_t)v84 << 32);
                        uint64_t v86 = ((v75 >> 16) & 0xFFFF00000000) + (v84 << 32) - 0x100000000;
                        if (((v75 >> 16) & 0xFFFF00000000) == 0) {
                          uint64_t v86 = 0xFFFFFFFF00000000;
                        }
                        unint64_t v87 = v83 | v86;
                        AlignedContentFrameForGridunint64_t Range = TSTLayoutSpaceGetAlignedContentFrameForGridRange(a2, v85, v83 | v86);
                        CGFloat v90 = v89;
                        ContentFrameForGridunint64_t Range = TSTLayoutSpaceGetContentFrameForGridRange(a2, v85, v87);
                        double v310 = v91;
                        if (objc_msgSend((id)objc_msgSend(v335, "masterLayout"), "isDynamicallyChangingRowCount"))
                        {
                          unint64_t v92 = objc_msgSend((id)objc_msgSend(v335, "tableModel"), "bodyRowRange");
                          if (HIWORD(v92)
                            && (v92 & 0xFFFF00000000) != 0
                            && (unsigned __int16)v92 <= (unsigned __int16)v75
                            && (unsigned __int16)(v92 + HIWORD(v92) - 1) >= (unsigned __int16)v75
                            && BYTE2(v92) <= BYTE2(v75)
                            && (unsigned int v93 = (BYTE4(v92) + BYTE2(v92) - 1), v93 >= BYTE2(v75))
                            && v93 >= (BYTE4(v75) + BYTE2(v75) - 1))
                          {
                            unsigned __int16 v245 = v75 + HIWORD(v75) - 1;
                            uint64_t v94 = v87;
                            uint64_t v54 = v335;
                            if ((unsigned __int16)(v92 + HIWORD(v92) - 1) >= v245)
                            {
                              rectdouble b = v245;
                              uint64_t v246 = objc_msgSend((id)objc_msgSend(v335, "tableModel", v87), "bodyRowRange");
                              __int16 v247 = objc_msgSend((id)objc_msgSend(v335, "masterLayout"), "dynamicRowAdjustment");
                              unint64_t v248 = 0;
                              if ((_WORD)v246 == 0xFFFF)
                              {
                                uint64_t v249 = 0xFFFFLL;
                                uint64_t v250 = 16711680;
                                unint64_t v251 = 0;
                                uint64_t v54 = v335;
                              }
                              else
                              {
                                uint64_t v249 = 0xFFFFLL;
                                uint64_t v250 = 16711680;
                                unint64_t v251 = 0;
                                uint64_t v54 = v335;
                                if ((v246 & 0xFF0000) != 0xFF0000)
                                {
                                  unint64_t v248 = 0;
                                  if ((v246 & 0xFFFF00000000) != 0)
                                  {
                                    __int16 v252 = v247 + HIWORD(v246);
                                    uint64_t v249 = 0xFFFFLL;
                                    uint64_t v250 = 16711680;
                                    unint64_t v251 = 0;
                                    if (v247 + HIWORD(v246))
                                    {
                                      uint64_t v249 = 0;
                                      unsigned int v253 = BYTE2(v75);
                                      if (BYTE2(v75) <= BYTE2(v246)) {
                                        unsigned int v253 = BYTE2(v246);
                                      }
                                      if ((unsigned __int16)v75 <= (unsigned __int16)v246) {
                                        uint64_t v254 = (unsigned __int16)v246;
                                      }
                                      else {
                                        uint64_t v254 = (unsigned __int16)v75;
                                      }
                                      if ((BYTE4(v75) + BYTE2(v75) - 1) >= (BYTE4(v246) + BYTE2(v246) - 1)) {
                                        unsigned int v255 = (BYTE4(v246) + BYTE2(v246) - 1);
                                      }
                                      else {
                                        unsigned int v255 = (BYTE4(v75) + BYTE2(v75) - 1);
                                      }
                                      if (rectb >= (unsigned __int16)(v246 + v252 - 1)) {
                                        unsigned int v256 = (unsigned __int16)(v246 + v252 - 1);
                                      }
                                      else {
                                        unsigned int v256 = rectb;
                                      }
                                      uint64_t v250 = 0;
                                      unint64_t v248 = 0;
                                      unint64_t v251 = 0;
                                      if (v254 <= v256 && v253 <= v255)
                                      {
                                        unint64_t v251 = ((unint64_t)(v256 - v254) << 48) + 0x1000000000000;
                                        unint64_t v248 = (unint64_t)(unsigned __int16)(v255 - v253 + 1) << 32;
                                        uint64_t v250 = v253 << 16;
                                        uint64_t v249 = v254;
                                      }
                                    }
                                  }
                                  else
                                  {
                                    uint64_t v249 = 0xFFFFLL;
                                    uint64_t v250 = 16711680;
                                    unint64_t v251 = 0;
                                  }
                                }
                              }
                              uint64_t v257 = v250 | v251 | v249 | v248;
                              if (BYTE2(v257) == 255) {
                                unsigned int v258 = -1;
                              }
                              else {
                                unsigned int v258 = BYTE2(v257);
                              }
                              uint64_t v259 = WORD2(v257) + v258 - 1;
                              if (!WORD2(v257)) {
                                uint64_t v259 = 0xFFFFFFFFLL;
                              }
                              if ((unsigned __int16)v257 == 0xFFFF) {
                                uint64_t v257 = 0xFFFFFFFFLL;
                              }
                              else {
                                uint64_t v257 = (unsigned __int16)v257;
                              }
                              unint64_t v85 = v258 | ((unint64_t)v257 << 32);
                              uint64_t v260 = (v251 >> 16) & 0xFFFF00000000;
                              uint64_t v261 = v260 + (v257 << 32) - 0x100000000;
                              if (!v260) {
                                uint64_t v261 = 0xFFFFFFFF00000000;
                              }
                              uint64_t v94 = v259 | v261;
                            }
                          }
                          else
                          {
                            uint64_t v94 = v87;
                            uint64_t v54 = v335;
                          }
                        }
                        else
                        {
                          uint64_t v54 = v335;
                          uint64_t v94 = v87;
                        }
                        unint64_t v123 = TSTLayoutSpaceIntersectionGridRange(a2, v85, v94);
                        double v319 = TSTLayoutSpaceGetAlignedContentFrameForGridRange(a2, v123, v124);
                        CGFloat v295 = v125;
                        double width = v126;
                        CGFloat rect = v127;
                        int v55 = v315;
LABEL_232:
                        BOOL v359 = 0;
                        unsigned int v358 = 0;
                        unsigned int v357 = 1;
                        double v129 = 0.0;
                        double v128 = 0.0;
                        double v130 = 0.0;
                        double v313 = 0.0;
                        CGContextSaveGState(a5);
                        uint64_t v318 = v71;
                        TSTCellTextProperties((uint64_t)v344, v69, v71, &v359, &v358, &v357, (uint64_t *)&v360);
                        BOOL v131 = objc_msgSend((id)objc_msgSend(v54, "layout"), "parent");
                        if (objc_opt_respondsToSelector()) {
                          uint64_t v132 = [v131 pageNumber];
                        }
                        else {
                          uint64_t v132 = 0x7FFFFFFFFFFFFFFFLL;
                        }
                        if (objc_opt_respondsToSelector()) {
                          uint64_t v133 = [v131 pageCount];
                        }
                        else {
                          uint64_t v133 = 0x7FFFFFFFFFFFFFFFLL;
                        }
                        if (objc_msgSend((id)objc_msgSend(v54, "masterLayout"), "isDynamicallyChangingFontColorOfCellID:", v318))
                        {
                          objc_opt_class();
                          char v134 = (__CFString *)v66;
                          if (TSUDynamicCast())
                          {
                            if (v344 && *((unsigned __int8 *)&v344->mPrivate + 1) << 8 == 2304) {
                              unint64_t v135 = [(TSTRichTextPayload *)v344->mPrivate.mRichTextPayload storage];
                            }
                            else {
                              unint64_t v135 = NSStringFromNativeTSTCell((__CFString *)v344);
                            }
                            char v134 = v135;
                          }
                          int v138 = (void *)[v54 masterLayout];
                          LODWORD(v264) = 0;
                          uint64_t v137 = (void *)[v138 validateCellForDrawing:v318 cell:v344 contents:v134 wrap:v359 verticalAlignment:v357 padding:v360 layoutCacheFlags:v264 pageNumber:v132 pageCount:v133];
                        }
                        else
                        {
                          if (v70)
                          {
                            unint64_t v136 = (void *)[v54 masterLayout];
                            LODWORD(v264) = 15;
                            uint64_t v137 = (void *)[v136 validateCellForDrawing:v318 cell:v344 contents:v66 wrap:v359 verticalAlignment:v357 padding:v360 layoutCacheFlags:v264 pageNumber:v132 pageCount:v133];
                          }
                          else
                          {
                            objc_opt_class();
                            uint64_t v137 = (void *)TSUDynamicCast();
                          }
                          char v134 = (__CFString *)v66;
                        }
                        v330 = v66;
                        if (!v137)
                        {
                          BOOL v139 = (void *)[v54 masterLayout];
                          LODWORD(v264) = 15;
                          uint64_t v137 = (void *)[v139 validateCellForDrawing:v318 cell:v344 contents:v134 wrap:v359 verticalAlignment:v357 padding:v360 layoutCacheFlags:v264 pageNumber:v132 pageCount:v133];
                          if (!v137)
                          {
                            char v140 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
                            uint64_t v141 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTCellRange TSTTableRepDrawIndividualCellContent(TSTTableRep *, TSTLayoutSpace *, TSTGridRange, TSTCell *, TSTCellID, id, TSTCellIteratorData, TSTCellRange, BOOL, NSMutableArray *, CGContextRef)");
                            objc_msgSend(v140, "handleFailureInFunction:file:lineNumber:description:", v141, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableRep.mm"), 5533, @"No TSWPColumn layout rock found.");
                            uint64_t v137 = 0;
                          }
                        }
                        v308 = v137;
                        [v137 typographicBoundsForCell];
                        double v145 = v144;
                        double v147 = v146;
                        if (v360)
                        {
                          double v321 = v144;
                          double v323 = width;
                          double v148 = v142;
                          double v149 = v143;
                          [v360 topInset];
                          double v325 = v147;
                          double v151 = v150;
                          [v360 leftInset];
                          double v153 = v152;
                          [v360 bottomInset];
                          double v155 = v154;
                          [v360 rightInset];
                          double v156 = AlignedContentFrameForGridRange;
                          double v157 = v90;
                          double v159 = v158;
                          double v160 = v153;
                          double v161 = v155;
                          double v128 = TSTMasterLayoutApplyMinimumHorizontalInset(v160);
                          double v162 = v159;
                          CGFloat v90 = v157;
                          AlignedContentFrameForGridunint64_t Range = v156;
                          double v130 = TSTMasterLayoutApplyMinimumHorizontalInset(v162);
                          double v313 = v161;
                          double v163 = -v161;
                          double v292 = v148 - v128;
                          double v289 = v149 - v151;
                          double width = v323;
                          double v145 = v321 - (-v130 - v128);
                          double v129 = v151;
                          double v147 = v325 - (v163 - v151);
                        }
                        else
                        {
                          double v289 = v143;
                          double v292 = v142;
                        }
                        memset(&v356, 0, sizeof(v356));
                        CGAffineTransformMakeTranslation(&v356, AlignedContentFrameForGridRange, v90);
                        if (v328 && HIWORD(v75) && (v75 & 0xFFFF00000000) != 0)
                        {
                          CGAffineTransform v361 = v356;
                          CGAffineTransformInvert(&v362, &v361);
                          v364.origin.double x = v319;
                          v364.origin.CGFloat y = v295;
                          v364.size.double width = width;
                          v364.size.CGFloat height = rect;
                          CGRect v365 = CGRectApplyAffineTransform(v364, &v362);
                          double x = v365.origin.x;
                          CGFloat y = v365.origin.y;
                          double width = v365.size.width;
                          CGFloat rect = v365.size.height;
                          long long v9 = v316;
                          double v166 = v344;
                          goto LABEL_427;
                        }
                        double v166 = v344;
                        if (v344) {
                          int v167 = *(_DWORD *)&v344->mPrivate >> 8;
                        }
                        else {
                          LOBYTE(v167) = 0;
                        }
                        double x = *MEMORY[0x263F00148];
                        CGFloat y = *(double *)(MEMORY[0x263F00148] + 8);
                        if (v328 && HIWORD(v75) && (v75 & 0xFFFF00000000) != 0
                          || v167 != 9 && v167 != 3)
                        {
                          long long v9 = v316;
                          goto LABEL_427;
                        }
                        long long v9 = v316;
                        if (!v359 && v145 > v310)
                        {
                          unsigned int v168 = v358;
                          uint64_t v169 = (void *)[v54 tableLayout];
                          unsigned int v170 = v169;
                          *(void *)&long long v171 = 0xFFFFFFLL;
                          *((void *)&v171 + 1) = 0xFFFFFFLL;
                          *(_OWORD *)&v361.a = v171;
                          if (BYTE2(v337) == 255) {
                            uint64_t v172 = 0xFFFFFFFFLL;
                          }
                          else {
                            uint64_t v172 = BYTE2(v337);
                          }
                          unsigned int v324 = (unsigned __int16)v337;
                          if ((unsigned __int16)v337 == 0xFFFF) {
                            uint64_t v173 = 0xFFFFFFFFLL;
                          }
                          else {
                            uint64_t v173 = (unsigned __int16)v337;
                          }
                          *(void *)&CGFloat v174 = v172 | (v173 << 32);
                          v362.a = v174;
                          v362.double b = v174;
                          v362.c = v174;
                          v362.d = v174;
                          unsigned int TableNumberOfHeaderColumns = TSTMasterLayoutGetTableNumberOfHeaderColumns((unsigned __int16 *)[v169 masterLayout]);
                          v296 = v170;
                          unint64_t v176 = [v170 editingSpillingTextRange];
                          BOOL v177 = 0;
                          unint64_t v276 = v176;
                          if ((_WORD)v176 != 0xFFFF && (v176 & 0xFF0000) != 0xFF0000)
                          {
                            BOOL v177 = 0;
                            if (HIWORD(v176))
                            {
                              if ((v176 & 0xFFFF00000000) != 0) {
                                BOOL v177 = (unsigned __int16)v337 >= (unsigned __int16)v176
                              }
                                    && (unsigned __int16)(v176 + HIWORD(v176) - 1) >= (unsigned __int16)v337;
                            }
                          }
                          unsigned int v326 = v168;
                          if ([v296 layoutDirectionIsLeftToRight])
                          {
                            if (v168 <= 4 && ((1 << v168) & 0x15) != 0) {
                              goto LABEL_287;
                            }
LABEL_296:
                            unsigned int v178 = v168;
                            goto LABEL_297;
                          }
                          if ((v168 & 0xFFFFFFFB) == 0) {
                            goto LABEL_298;
                          }
                          if (v168 == 1)
                          {
                            unsigned int v178 = 0;
                          }
                          else
                          {
                            if (v168 != 2 && v168 != 4) {
                              goto LABEL_296;
                            }
LABEL_287:
                            unsigned int v178 = v168;
                          }
                          if (v307 != BYTE2(v337))
                          {
                            LOWORD(v361.a) = v337;
                            BYTE2(v361.a) = BYTE2(v337) + 1;
                            HIWORD(v361.a) = 1;
                            __int16 v179 = v307 - BYTE2(v337);
                            if (v307 <= BYTE2(v337)) {
                              __int16 v179 = 0;
                            }
                            WORD2(v361.a) = v179;
                          }
LABEL_297:
                          if (v178 - 1 > 1)
                          {
                            double v180 = v147;
                            double v181 = ContentFrameForGridRange;
                            unsigned int v267 = 0;
                            double v186 = 0.0;
LABEL_312:
                            unsigned __int8 v268 = -1;
                          }
                          else
                          {
LABEL_298:
                            double v180 = v147;
                            double v181 = ContentFrameForGridRange;
                            LOWORD(v361.b) = v337;
                            HIWORD(v361.b) = 1;
                            if (TableNumberOfHeaderColumns <= BYTE2(v337)) {
                              unsigned int v182 = v305 + TableNumberOfHeaderColumns;
                            }
                            else {
                              unsigned int v182 = v305;
                            }
                            if (TableNumberOfHeaderColumns <= BYTE2(v337)) {
                              unsigned __int8 v183 = v305 + TableNumberOfHeaderColumns;
                            }
                            else {
                              unsigned __int8 v183 = v306;
                            }
                            unsigned int v184 = BYTE2(v337) - v182;
                            if (BYTE2(v337) <= v182) {
                              unsigned int v184 = 0;
                            }
                            unsigned int v267 = v184;
                            unsigned __int8 v268 = v183;
                            BYTE2(v361.b) = v183;
                            WORD2(v361.b) = v184;
                            TSTLayoutSpaceGetFrameForGridRange(a2, *(unint64_t *)&v174, *(uint64_t *)&v174);
                            if (v168 == 2) {
                              double v186 = v185 * 0.5;
                            }
                            else {
                              double v186 = 0.0;
                            }
                            if (BYTE2(v337) == v305)
                            {
                              LODWORD(v361.b) = 0xFFFFFF;
                              goto LABEL_312;
                            }
                          }
                          char v187 = 0;
                          uint64_t v188 = 0;
                          char recta = 0;
                          uint64_t v294 = v337 & 0xFF000000 | (BYTE2(v337) << 16) | (unsigned __int16)v337;
                          unsigned int v270 = v337 & 0xFF000000 | (BYTE2(v337) << 16) | (unsigned __int16)v337;
                          BOOL v189 = BYTE2(v337) < BYTE2(v276) && v177;
                          BOOL v273 = v189;
                          __int16 v266 = ~BYTE2(v337) + BYTE2(v276);
                          BOOL v190 = BYTE2(v337) > (BYTE4(v276) + BYTE2(v276) - 1) && v177;
                          BOOL v272 = v190;
                          unsigned int v322 = (unsigned __int16)v337 + 1;
                          char v191 = 1;
                          while (2)
                          {
                            char v192 = v191;
                            unint64_t v193 = (char *)(&v361.a + v188);
                            unint64_t v194 = *(void *)v193;
                            if (*(_WORD *)v193 != 0xFFFF)
                            {
                              BOOL v195 = (v194 & 0xFF0000) == 0xFF0000 || HIWORD(v194) == 0;
                              if (!v195 && (v194 & 0xFFFF00000000) != 0)
                              {
                                int v338 = BYTE2(v194);
                                if (v187)
                                {
                                  unint64_t v274 = v274 & 0xFFFFFFFF00000000 | v294;
                                  int v197 = TSTLayoutCellLeftOfCell(v296, v274, 1);
                                  unint64_t v198 = v341;
                                  if (v272)
                                  {
                                    unint64_t v198 = v341;
                                    if (BYTE2(v197) < (BYTE4(v276) + BYTE2(v276) - 1))
                                    {
                                      unint64_t v198 = v276;
                                      int v197 = v276;
                                    }
                                  }
                                  if ((_WORD)v197 != 0xFFFF
                                    && (*(void *)&v197 & 0xFF0000) != 0xFF0000
                                    && (_WORD)v198 != 0xFFFF
                                    && (v198 & 0xFF0000) != 0xFF0000
                                    && HIWORD(v198)
                                    && (v198 & 0xFFFF00000000) != 0)
                                  {
                                    unsigned int v199 = HIDWORD(v198) + WORD1(v198);
                                    unsigned int v200 = -v199 | 0xFFFFFF00;
                                    unsigned int v201 = v267 + v268;
                                    BYTE2(v361.b) = v199;
                                    unsigned int v267 = v201 + v200;
                                    unsigned __int8 v268 = v199;
                                    WORD2(v361.b) = v201 + v200;
                                    int v338 = v193[2];
                                  }
                                }
                                else
                                {
                                  int v197 = TSTLayoutCellRightOfCell(v296, v294, 1);
                                  unint64_t v275 = v275 & 0xFFFFFFFF00000000 | v294;
                                  if (v273 && BYTE2(v276) < BYTE2(v197)) {
                                    WORD2(v361.a) = v266;
                                  }
                                }
                                BOOL v202 = (~v197 & 0xFF0000) != 0 && (_WORD)v197 != 0xFFFF;
                                int v203 = v338;
                                if ((v192 & 1) == 0) {
                                  int v203 = v338 + *((unsigned __int16 *)&v361.a + 4 * v188 + 2) - 1;
                                }
                                recta |= v202;
                                int v329 = BYTE2(v197);
                                v320 = (unsigned __int16 *)(((unint64_t)&v361 + 8 * v188) | 4);
                                int v204 = (unint64_t *)((char *)&v362 + 16 * v188);
                                if ((v192 & 1) == 0) {
                                  goto LABEL_353;
                                }
LABEL_351:
                                if (v203 < *v320 + v338)
                                {
                                  while ((recta & (v329 == v203)) == 0)
                                  {
                                    unint64_t v205 = (TSTMasterLayout *)[v335 masterLayout];
                                    BOOL v206 = +[TSDStroke emptyStroke];
                                    if (v192) {
                                      unsigned int v207 = v203;
                                    }
                                    else {
                                      unsigned int v207 = v203 + 1;
                                    }
                                    TSTMasterLayoutSetStrokeForGridColumn(v205, v206, v207, 0, v324, v322);
                                    TSTMasterLayoutSetStrokeForGridColumn((TSTMasterLayout *)[v335 masterLayout], (TSDStroke *)+[TSDStroke emptyStroke](TSDStroke, "emptyStroke"), v207, 1, v324, v322);
                                    if (*((_DWORD *)v204 + 2) >= v203) {
                                      id v208 = v204;
                                    }
                                    else {
                                      id v208 = v204 + 1;
                                    }
                                    *id v208 = v203;
                                    TSTLayoutSpaceGetContentFrameForGridRange(a2, *v204, v204[1]);
                                    if (v326 == 2) {
                                      BOOL v210 = v145 * 0.5 > v209 - v186;
                                    }
                                    else {
                                      BOOL v210 = v145 > v209;
                                    }
                                    unint64_t v66 = v330;
                                    if (!v210) {
                                      goto LABEL_329;
                                    }
                                    if (v192) {
                                      ++v203;
                                    }
                                    else {
                                      --v203;
                                    }
                                    if (v192) {
                                      goto LABEL_351;
                                    }
LABEL_353:
                                    if (v203 < v338)
                                    {
LABEL_372:
                                      unint64_t v212 = *(void *)&v362.a;
                                      unint64_t v211 = *(void *)&v362.b;
                                      LODWORD(c_low) = LODWORD(v362.c);
                                      LODWORD(d_low) = LODWORD(v362.d);
                                      if (LODWORD(v362.a) == -1
                                        || LODWORD(v362.b) == -1
                                        || LODWORD(v362.a) > LODWORD(v362.b)
                                        || HIDWORD(v362.a) == -1
                                        || HIDWORD(v362.b) == -1
                                        || HIDWORD(v362.a) > HIDWORD(v362.b))
                                      {
                                        unint64_t v211 = *(void *)&v362.d;
                                        unint64_t v212 = *(void *)&v362.c;
                                        long long v9 = v316;
                                        int v55 = v315;
                                        double v147 = v180;
                                      }
                                      else
                                      {
                                        long long v9 = v316;
                                        double v147 = v180;
                                        if (LODWORD(v362.c) == -1)
                                        {
                                          LODWORD(d_low) = LODWORD(v362.b);
                                          LODWORD(c_low) = LODWORD(v362.a);
                                          int v55 = v315;
                                        }
                                        else
                                        {
                                          int v55 = v315;
                                          if (LODWORD(v362.d) == -1
                                            || LODWORD(v362.c) > LODWORD(v362.d)
                                            || HIDWORD(v362.c) == -1
                                            || HIDWORD(v362.d) == -1
                                            || HIDWORD(v362.c) > HIDWORD(v362.d))
                                          {
                                            LODWORD(d_low) = LODWORD(v362.b);
                                            LODWORD(c_low) = LODWORD(v362.a);
                                          }
                                          else
                                          {
                                            if (LODWORD(v362.a) >= LODWORD(v362.c)) {
                                              uint64_t c_low = LODWORD(v362.c);
                                            }
                                            else {
                                              uint64_t c_low = LODWORD(v362.a);
                                            }
                                            if (HIDWORD(v362.a) >= HIDWORD(v362.c)) {
                                              uint64_t c_high = HIDWORD(v362.c);
                                            }
                                            else {
                                              uint64_t c_high = HIDWORD(v362.a);
                                            }
                                            if (LODWORD(v362.b) <= LODWORD(v362.d)) {
                                              uint64_t d_low = LODWORD(v362.d);
                                            }
                                            else {
                                              uint64_t d_low = LODWORD(v362.b);
                                            }
                                            if (HIDWORD(v362.b) <= HIDWORD(v362.d)) {
                                              uint64_t d_high = HIDWORD(v362.d);
                                            }
                                            else {
                                              uint64_t d_high = HIDWORD(v362.b);
                                            }
                                            unint64_t v211 = d_low | (d_high << 32);
                                            unint64_t v212 = c_low | (c_high << 32);
                                          }
                                        }
                                      }
                                      if (c_low == -1
                                        || d_low == -1
                                        || c_low > d_low
                                        || (HIDWORD(v212) <= HIDWORD(v211) ? (BOOL v220 = HIDWORD(v211) == -1) : (BOOL v220 = 1),
                                            !v220 ? (BOOL v221 = HIDWORD(v212) == -1) : (BOOL v221 = 1),
                                            v221))
                                      {
                                        unint64_t v211 = -1;
                                        unint64_t v212 = -1;
                                      }
                                      unint64_t v222 = 0;
                                      if (v212 != -1
                                        && v211 != -1
                                        && v212 <= v211)
                                      {
                                        unint64_t v222 = 0;
                                        if (HIDWORD(v212) != -1
                                          && HIDWORD(v211) != -1
                                          && HIDWORD(v212) <= HIDWORD(v211))
                                        {
                                          unint64_t v222 = ((v211 - (v212 & 0xFFFFFFFF00000000)) & 0xFFFFFFFF00000000 | (v211 - v212 + 1))
                                               + 0x100000000;
                                        }
                                      }
                                      unint64_t v223 = (unint64_t)v212 << 16;
                                      if (v212 == -1) {
                                        unint64_t v223 = 16711680;
                                      }
                                      uint64_t v224 = 0x100000000;
                                      unint64_t v225 = 0x1000000000000;
                                      if (WORD2(v212) != 0xFFFFLL && v223 != 16711680)
                                      {
                                        if ((_BYTE)v222)
                                        {
                                          unint64_t v226 = (v222 >> 16) & 0xFFFF0000 | v222;
                                          unint64_t v227 = v223 & 0xFFFFFFFFFFFF0000 | WORD2(v212) | (v226 << 32);
                                          if (HIWORD(v227))
                                          {
                                            unint64_t v228 = v226 << 32;
                                            unint64_t v225 = (v226 << 32) & 0xFFFF000000000000;
                                            TSTMasterLayoutSetStrokesValidForRange((TSTMasterLayout *)[v335 masterLayout], v223 & 0xFFFF000000FF0000 | WORD2(v212) | (v226 << 32) & 0xFFFF000000FFFFFFLL | ((v226 << 32) + 0x100000000) & 0x1FF00000000);
                                            uint64_t v224 = v228 & 0xFF00000000;
                                            unsigned int v270 = v227;
                                          }
                                        }
                                      }
                                      double v229 = TSTLayoutSpaceGetContentFrameForGridRange(a2, v212, v211);
                                      double width = v230;
                                      CGFloat rect = v231;
                                      if (v326 == 1) {
                                        goto LABEL_422;
                                      }
                                      if (v326 != 2)
                                      {
                                        char v232 = objc_msgSend(v296, "layoutDirectionIsLeftToRight", v229);
                                        if (v326 != 4 || (v232 & 1) != 0) {
                                          goto LABEL_425;
                                        }
LABEL_422:
                                        if (width <= v310) {
                                          goto LABEL_425;
                                        }
                                        double x = v310 - width;
LABEL_424:
                                        CGFloat y = 0.0;
                                        goto LABEL_426;
                                      }
                                      if (v230 > v310)
                                      {
                                        double x = v229 - v181;
                                        goto LABEL_424;
                                      }
LABEL_425:
                                      double x = *MEMORY[0x263F00148];
                                      CGFloat y = *(double *)(MEMORY[0x263F00148] + 8);
LABEL_426:
                                      double v166 = v344;
                                      unint64_t v73 = v224 | v225 | v270;
                                      uint64_t v54 = v335;
                                      goto LABEL_427;
                                    }
                                  }
                                  char recta = 1;
                                }
                              }
                            }
LABEL_329:
                            char v191 = 0;
                            char v187 = 1;
                            uint64_t v188 = 1;
                            if ((v192 & 1) == 0) {
                              goto LABEL_372;
                            }
                            continue;
                          }
                        }
LABEL_427:
                        BOOL v233 = 0;
                        if ((_WORD)v73 != 0xFFFF && (v73 & 0xFF0000) != 0xFF0000)
                        {
                          BOOL v233 = 0;
                          if (HIWORD(v73))
                          {
                            if ((v73 & 0xFFFF00000000) != 0)
                            {
                              BOOL v233 = 0;
                              if (v166)
                              {
                                if ((v73 & 0xFFFFFFFF00000000) == 0x1000100000000) {
                                  BOOL v233 = *((unsigned __int8 *)&v166->mPrivate + 1) << 8 == 2304
                                }
                                      && [(TSWPStorage *)[(TSTRichTextPayload *)v166->mPrivate.mRichTextPayload storage] listStyleCount] != 0;
                              }
                            }
                          }
                        }
                        if (objc_msgSend((id)objc_msgSend(v54, "info"), "isInlineWithText"))
                        {
                          [v340 parent];
                          objc_opt_class();
                          if ((objc_opt_isKindOfClass() & 1) == 0)
                          {
                            double v327 = v147;
                            double v331 = v130;
                            double v339 = v129;
                            memset(&transform, 0, sizeof(transform));
                            double v271 = v128;
                            CGFloat v234 = width;
                            if (v340) {
                              [v340 transformInParent];
                            }
                            else {
                              memset(&v354, 0, sizeof(v354));
                            }
                            CGAffineTransformInvert(&transform, &v354);
                            objc_msgSend((id)objc_msgSend(v340, "parent"), "frame");
                            CGAffineTransform v353 = transform;
                            CGRect v367 = CGRectApplyAffineTransform(v366, &v353);
                            CGFloat v235 = v367.origin.x;
                            CGFloat v236 = v367.origin.y;
                            CGFloat v237 = v367.size.width;
                            CGFloat height = v367.size.height;
                            CGAffineTransform v351 = v356;
                            CGAffineTransformInvert(&v352, &v351);
                            v368.origin.double x = v235;
                            v368.origin.CGFloat y = v236;
                            v368.size.double width = v237;
                            v368.size.CGFloat height = height;
                            CGRect v369 = CGRectApplyAffineTransform(v368, &v352);
                            v373.origin.CGFloat y = v369.origin.y;
                            v373.size.CGFloat height = v369.size.height;
                            v369.origin.double x = x;
                            v369.origin.CGFloat y = y;
                            v369.size.double width = v234;
                            v369.size.CGFloat height = rect;
                            v373.origin.double x = x;
                            v373.size.double width = v234;
                            CGRect v370 = CGRectIntersection(v369, v373);
                            double x = v370.origin.x;
                            CGFloat y = v370.origin.y;
                            double width = v370.size.width;
                            CGFloat rect = v370.size.height;
                            double v129 = v339;
                            double v128 = v271;
                            double v130 = v331;
                            double v147 = v327;
                          }
                        }
                        CGAffineTransform transform = v356;
                        CGContextConcatCTM(a5, &transform);
                        v371.origin.double x = x;
                        v371.origin.CGFloat y = y;
                        v371.size.double width = width;
                        v371.size.CGFloat height = rect;
                        CGContextClipToRect(a5, v371);
                        if (!v359 && ((TSTCellFormatUsesAccountingStyle(v344) | v233) & 1) == 0)
                        {
                          if (v358 == 2)
                          {
                            double v239 = v310 * 0.5 - v145 * 0.5 - v292;
LABEL_448:
                            CGContextTranslateCTM(a5, v239, 0.0);
                          }
                          else if (v358 == 1)
                          {
                            v372.origin.double x = v292;
                            v372.origin.CGFloat y = v289;
                            v372.size.double width = v145;
                            v372.size.CGFloat height = v147;
                            double v239 = v310 - CGRectGetMaxX(v372);
                            goto LABEL_448;
                          }
                        }
                        v240 = [TSTTextEngineDelegate alloc];
                        v241 = -[TSTTextEngineDelegate initWithPadding:verticalAlignment:](v240, "initWithPadding:verticalAlignment:", v357, v129, v128, v313, v130);
                        v242 = objc_msgSend((id)objc_msgSend(v54, "masterLayout"), "newTextEngineForCell:atCellID:", v344, v318);
                        [v242 setDelegate:v241];
                        [v309 viewScale];
                        objc_msgSend(v242, "drawColumn:inContext:isFlipped:viewScale:", v308, a5, v291);
                        [v242 setDelegate:0];

                        CGContextRestoreGState(a5);
LABEL_450:
                        if (!v343) {
                          unint64_t v73 = v341;
                        }
LABEL_168:

                        uint64_t v341 = v73;
                        unint64_t v5 = v346;
                        goto LABEL_169;
                      }
                      uint64_t v54 = v335;
                      int v55 = v315;
                    }
                    else
                    {
                      uint64_t v112 = [v54 canvas];
                      if (!v343)
                      {
                        long long v9 = v316;
                        goto LABEL_450;
                      }
                      v309 = (void *)v112;
                    }
                    if (BYTE2(v62) == 255) {
                      uint64_t v115 = 0xFFFFFFFFLL;
                    }
                    else {
                      uint64_t v115 = BYTE2(v62);
                    }
                    if ((unsigned __int16)v62 == 0xFFFF) {
                      uint64_t v116 = 0xFFFFFFFFLL;
                    }
                    else {
                      uint64_t v116 = (unsigned __int16)v62;
                    }
                    unint64_t v117 = v115 | (v116 << 32);
                    AlignedContentFrameForGridunint64_t Range = TSTLayoutSpaceGetAlignedContentFrameForGridRange(a2, v117, v117);
                    CGFloat v90 = v118;
                    double width = v119;
                    CGFloat rect = v121;
                    ContentFrameForGridunint64_t Range = TSTLayoutSpaceGetContentFrameForGridRange(a2, v117, v117);
                    CGFloat v295 = v90;
                    double v310 = v122;
                    double v319 = AlignedContentFrameForGridRange;
                    goto LABEL_232;
                  }
                }
                goto LABEL_168;
              }
            }
            unint64_t v342 = v62 | v342 & 0xFFFFFFFF00000000;
            if ((objc_msgSend(v9, "isDynamicallyHidingRowsColsCellID:") & 1) == 0) {
              goto LABEL_125;
            }
LABEL_169:
            if (!TSTLayoutCellIteratorGetNextCell((uint64_t)v347, v349)) {
              goto LABEL_508;
            }
          }
        }
        unint64_t v5 = v30;
LABEL_508:

        uint64_t result = TSTMasterLayoutNextVisibleRow(v9, (unsigned __int16)(v317 + 1));
      }
      while (result <= v303);
    }
  }
  return result;
}

unint64_t TSTCellRangeUnionCellID(unint64_t a1, unint64_t a2)
{
  LOWORD(v2) = 1;
  unint64_t v3 = a2 >> 16;
  unint64_t v4 = a2 >> 24;
  LOWORD(v5) = 1;
  if ((_WORD)a1 == 0xFFFF || (a1 & 0xFF0000) == 0xFF0000 || !HIWORD(a1) || (a1 & 0xFFFF00000000) == 0)
  {
    LOWORD(a1) = a2;
  }
  else if ((_WORD)a2 == 0xFFFF || (a2 & 0xFF0000) == 0xFF0000)
  {
    unint64_t v3 = a1 >> 16;
    unint64_t v4 = a1 >> 24;
    unint64_t v2 = HIDWORD(a1);
    unint64_t v5 = HIWORD(a1);
  }
  else if ((unsigned __int16)a1 <= (unsigned __int16)a2 {
         && (unsigned __int16)(a1 + HIWORD(a1) - 1) >= (unsigned __int16)a2
  }
         && BYTE2(a1) <= BYTE2(a2)
         && (unint64_t v2 = HIDWORD(a1), (BYTE4(a1) + BYTE2(a1) - 1) >= BYTE2(a2)))
  {
    unint64_t v3 = a1 >> 16;
    unint64_t v4 = a1 >> 24;
    LODWORD(v5) = HIWORD(HIDWORD(a1));
  }
  else
  {
    LODWORD(v4) = 0;
    unint64_t v6 = a1 >> 16;
    if (BYTE2(a2) <= BYTE2(a1)) {
      LOBYTE(v6) = BYTE2(a2);
    }
    if ((unsigned __int16)a2 <= (unsigned __int16)a1) {
      __int16 v7 = a2;
    }
    else {
      __int16 v7 = a1;
    }
    unsigned int v8 = HIDWORD(a1) + WORD1(a1);
    __int16 v9 = a1 + HIWORD(a1);
    LOWORD(a1) = v7;
    unsigned __int8 v10 = v8 - 1;
    if (BYTE2(a2) < v10) {
      LOBYTE(v3) = v10;
    }
    __int16 v11 = v9 - 1;
    if ((unsigned __int16)a2 >= (unsigned __int16)(v9 - 1)) {
      __int16 v11 = a2;
    }
    __int16 v12 = v11 - v7 + 1;
    LOWORD(v2) = v3 - v6 + 1;
    LOWORD(v5) = v12;
    LOBYTE(v3) = v6;
  }
  return (v4 << 24) | ((unint64_t)((unsigned __int16)v2 | ((unsigned __int16)v5 << 16)) << 32) | ((unint64_t)v3 << 16) | (unsigned __int16)a1;
}

{
  unint64_t v2;
  unint64_t v3;
  int v4;
  int v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  int v9;
  unsigned __int8 v10;
  int v11;

  unint64_t v2 = a2 >> 16;
  unint64_t v3 = a2 >> 24;
  unint64_t v4 = 0x10000;
  unint64_t v5 = 1;
  if ((_WORD)a1 == 0xFFFF || (a1 & 0xFF0000) == 0xFF0000 || !HIWORD(a1) || (a1 & 0xFFFF00000000) == 0)
  {
    LOWORD(a1) = a2;
  }
  else if ((_WORD)a2 == 0xFFFF || (a2 & 0xFF0000) == 0xFF0000)
  {
    unint64_t v2 = a1 >> 16;
    unint64_t v3 = a1 >> 24;
  }
  else if ((unsigned __int16)a1 <= (unsigned __int16)a2 {
         && (unsigned __int16)(a1 + HIWORD(a1) - 1) >= (unsigned __int16)a2
  }
         && BYTE2(a1) <= BYTE2(a2)
         && (BYTE4(a1) + BYTE2(a1) - 1) >= BYTE2(a2))
  {
    unint64_t v2 = a1 >> 16;
    unint64_t v3 = a1 >> 24;
    unint64_t v4 = 0x10000;
    unint64_t v5 = 1;
  }
  else
  {
    LODWORD(v3) = 0;
    unint64_t v6 = a1 >> 16;
    if (BYTE2(a2) <= BYTE2(a1)) {
      LOBYTE(v6) = BYTE2(a2);
    }
    if ((unsigned __int16)a2 <= (unsigned __int16)a1) {
      __int16 v7 = a2;
    }
    else {
      __int16 v7 = a1;
    }
    unsigned int v8 = HIDWORD(a1) + WORD1(a1);
    __int16 v9 = a1 + HIWORD(a1);
    LOWORD(a1) = v7;
    unsigned __int8 v10 = v8 - 1;
    if (BYTE2(a2) < v10) {
      LOBYTE(v2) = v10;
    }
    __int16 v11 = v9 - 1;
    if ((unsigned __int16)a2 >= (unsigned __int16)(v9 - 1)) {
      __int16 v11 = a2;
    }
    unint64_t v4 = ((v11 - v7) << 16) + 0x10000;
    unint64_t v5 = (unsigned __int16)(v2 - v6 + 1);
    LOBYTE(v2) = v6;
  }
  return (v3 << 24) | ((unint64_t)(v4 | v5) << 32) | ((unint64_t)v2 << 16) | (unsigned __int16)a1;
}

void sub_22378CD30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__26(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__26(uint64_t a1)
{
}

uint64_t **std::__tree<TSTMergeRangeElem,TSTMergeRangeElemCompare,std::allocator<TSTMergeRangeElem>>::__emplace_unique_key_args<TSTMergeRangeElem,TSTMergeRangeElem const&>(uint64_t **a1, uint64_t a2, _OWORD *a3)
{
  unint64_t v6 = a1 + 1;
  unint64_t v5 = a1[1];
  if (v5)
  {
    unsigned int v7 = *(_DWORD *)(a2 + 56);
    while (1)
    {
      while (1)
      {
        unsigned int v8 = (uint64_t **)v5;
        unsigned int v9 = *((_DWORD *)v5 + 22);
        if (v7 >= v9) {
          break;
        }
        unint64_t v5 = *v8;
        unint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      unint64_t v5 = v8[1];
      if (!v5)
      {
        unint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    unsigned int v8 = a1 + 1;
LABEL_10:
    unsigned __int8 v10 = (uint64_t *)operator new(0x60uLL);
    long long v11 = a3[1];
    *((_OWORD *)v10 + 2) = *a3;
    *((_OWORD *)v10 + 3) = v11;
    long long v12 = a3[3];
    *((_OWORD *)v10 + 4) = a3[2];
    *((_OWORD *)v10 + 5) = v12;
    std::__tree<std::__value_type<std::string,unsigned short>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned short>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned short>>>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t TSTTableRBTreeLeftRotate(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  uint64_t v3 = *(void *)(v2 + 8);
  *(void *)(a2 + 16) = v3;
  if ((_UNKNOWN *)v3 != &TSTTableRBTreeNil) {
    *(void *)(v3 + 24) = a2;
  }
  *(void *)(v2 + 24) = *(void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  uint64_t v5 = v2;
  if ((_UNKNOWN *)v4 != &TSTTableRBTreeNil)
  {
    uint64_t v6 = 16;
    if (*(void *)(v4 + 8) == a2) {
      uint64_t v6 = 8;
    }
    *(void *)(v4 + v6) = v2;
    uint64_t v5 = a1;
  }
  *(void *)(v2 + 8) = a2;
  *(void *)(a2 + 24) = v2;
  return v5;
}

uint64_t TSTTableRBTreeRightRotate(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  uint64_t v3 = *(void *)(v2 + 16);
  *(void *)(a2 + 8) = v3;
  if ((_UNKNOWN *)v3 != &TSTTableRBTreeNil) {
    *(void *)(v3 + 24) = a2;
  }
  *(void *)(v2 + 24) = *(void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  uint64_t v5 = v2;
  if ((_UNKNOWN *)v4 != &TSTTableRBTreeNil)
  {
    uint64_t v6 = 16;
    if (*(void *)(v4 + 8) == a2) {
      uint64_t v6 = 8;
    }
    *(void *)(v4 + v6) = v2;
    uint64_t v5 = a1;
  }
  *(void *)(v2 + 16) = a2;
  *(void *)(a2 + 24) = v2;
  return v5;
}

TSTTableRBTreeNode_s *TSTTableRBTreeInsertFixup(TSTTableRBTreeNode_s *result, TSTTableRBTreeNode_s *a2)
{
  var4 = a2->var4;
  p_char var5 = &var4->var5;
  char var5 = var4->var5;
  if (var5 == 1)
  {
    do
    {
      uint64_t v5 = var4->var4;
      unint64_t var2 = v5->var2;
      if (var4 == var2)
      {
        unint64_t var2 = v5->var3;
        if (var2->var5 != 1)
        {
          var3 = var4->var3;
          if (a2 == var3)
          {
            BOOL v19 = a2->var2;
            var4->var3 = v19;
            if (v19 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
            {
              v19->var4 = var4;
              uint64_t v5 = var4->var4;
            }
            a2->var4 = v5;
            int v20 = var4->var4;
            unint64_t v21 = a2;
            if (v20 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
            {
              if (v20->var2 == var4) {
                uint64_t v22 = 8;
              }
              else {
                uint64_t v22 = 16;
              }
              *(void *)((char *)&v20->var0 + v22) = a2;
              unint64_t v21 = result;
            }
            a2->unint64_t var2 = var4;
            var4->var4 = a2;
            uint64_t v5 = a2->var4;
            unsigned int v9 = v5->var2;
            var3 = v9->var3;
            unsigned __int8 v10 = a2;
            uint64_t result = v21;
          }
          else
          {
            unsigned int v9 = var4;
            unsigned __int8 v10 = var4;
            var4 = a2;
          }
          v10->char var5 = 0;
          v5->char var5 = var5;
          v5->unint64_t var2 = var3;
          if (var3 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil) {
            var3->var4 = v5;
          }
          v9->var4 = v5->var4;
          uint64_t v23 = v5->var4;
          uint64_t v17 = (uint64_t)v9;
          if (v23 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
          {
            if (v23->var2 == v5) {
              uint64_t v24 = 8;
            }
            else {
              uint64_t v24 = 16;
            }
            *(void *)((char *)&v23->var0 + v24) = v9;
            uint64_t v17 = (uint64_t)result;
          }
          v9->var3 = v5;
          goto LABEL_42;
        }
      }
      else if (var2->var5 != 1)
      {
        if (a2 == var4->var2)
        {
          long long v11 = a2->var3;
          var4->unint64_t var2 = v11;
          if (v11 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
          {
            v11->var4 = var4;
            uint64_t v5 = var4->var4;
          }
          a2->var4 = v5;
          long long v12 = var4->var4;
          BOOL v13 = a2;
          if (v12 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
          {
            if (v12->var2 == var4) {
              uint64_t v14 = 8;
            }
            else {
              uint64_t v14 = 16;
            }
            *(void *)((char *)&v12->var0 + v14) = a2;
            BOOL v13 = result;
          }
          a2->var3 = var4;
          var4->var4 = a2;
          uint64_t v5 = a2->var4;
          unsigned int v7 = a2;
          uint64_t result = v13;
        }
        else
        {
          unsigned int v7 = var4;
          var4 = a2;
        }
        v7->char var5 = 0;
        v5->char var5 = var5;
        unsigned int v9 = v5->var3;
        unint64_t v15 = v9->var2;
        v5->var3 = v15;
        if (v15 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil) {
          v15->var4 = v5;
        }
        v9->var4 = v5->var4;
        unint64_t v16 = v5->var4;
        uint64_t v17 = (uint64_t)v9;
        if (v16 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
        {
          if (v16->var2 == v5) {
            uint64_t v18 = 8;
          }
          else {
            uint64_t v18 = 16;
          }
          *(void *)((char *)&v16->var0 + v18) = v9;
          uint64_t v17 = (uint64_t)result;
        }
        v9->unint64_t var2 = v5;
LABEL_42:
        v5->var4 = v9;
        uint64_t result = (TSTTableRBTreeNode_s *)v17;
        goto LABEL_43;
      }
      *p_char var5 = 0;
      var2->char var5 = 0;
      var4 = v5;
      v5->char var5 = var5;
LABEL_43:
      a2 = var4;
      var4 = var4->var4;
      p_char var5 = &var4->var5;
    }
    while (var4->var5 == 1);
  }
  result->char var5 = 0;
  return result;
}

TSTTableRBTreeNode_s *TSTTableRBTreeInsert(TSTTableRBTreeNode_s *a1, TSTTableRBTreeNode_s *a2)
{
  if (a1)
  {
    if (a1 == (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
    {
      a2->var4 = (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil;
      a1 = a2;
    }
    else
    {
      uint64_t v2 = a1;
      do
      {
        uint64_t v3 = v2;
        if (a2->var0 >= v2->var0) {
          uint64_t v4 = 16;
        }
        else {
          uint64_t v4 = 8;
        }
        uint64_t v2 = *(TSTTableRBTreeNode_s **)((char *)&v3->var0 + v4);
      }
      while (v2 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil);
      a2->var4 = v3;
      if (a2->var0 >= v3->var0) {
        v3->var3 = a2;
      }
      else {
        v3->unint64_t var2 = a2;
      }
    }
    a2->unint64_t var2 = (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil;
    a2->var3 = (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil;
    a2->char var5 = 1;
    return TSTTableRBTreeInsertFixup(a1, a2);
  }
  else
  {
    a2->char var5 = 0;
    return a2;
  }
}

_WORD *TSTTableRBTreeNewNode(__int16 a1, __int16 a2)
{
  uint64_t result = malloc_type_malloc(0x28uLL, 0x1020040D3174BDAuLL);
  _WORD *result = a1;
  result[1] = a2;
  *((void *)result + 1) = &TSTTableRBTreeNil;
  *((void *)result + 2) = &TSTTableRBTreeNil;
  *((void *)result + 3) = &TSTTableRBTreeNil;
  *((unsigned char *)result + 32) = 1;
  return result;
}

void TSTTableRBTreeFree(void **a1)
{
  if (a1)
  {
    if (a1[1] != &TSTTableRBTreeNil) {
      TSTTableRBTreeFree();
    }
    if (a1[2] != &TSTTableRBTreeNil) {
      TSTTableRBTreeFree();
    }
    free(a1);
  }
}

TSTTableRBTreeNode_s *TSTTableRBTreeMaximum(TSTTableRBTreeNode_s *a1)
{
  do
  {
    unsigned int v1 = a1;
    a1 = a1->var3;
  }
  while (a1 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil);
  return v1;
}

TSTTableRBTreeNode_s *TSTTableRBTreeMinimum(TSTTableRBTreeNode_s *a1)
{
  do
  {
    unsigned int v1 = a1;
    a1 = a1->var2;
  }
  while (a1 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil);
  return v1;
}

TSTTableRBTreeNode_s **TSTTableRBTreePredecessor(TSTTableRBTreeNode_s *a1)
{
  unint64_t var2 = a1->var2;
  if (var2 == (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
  {
    uint64_t v3 = a1;
    while (1)
    {
      uint64_t result = (TSTTableRBTreeNode_s **)v3->var4;
      if (result == (TSTTableRBTreeNode_s **)&TSTTableRBTreeNil) {
        break;
      }
      BOOL v4 = v3 == result[1];
      uint64_t v3 = v3->var4;
      if (!v4) {
        return result;
      }
    }
    return (TSTTableRBTreeNode_s **)&TSTTableRBTreeNil;
  }
  else
  {
    do
    {
      uint64_t result = (TSTTableRBTreeNode_s **)var2;
      unint64_t var2 = var2->var3;
    }
    while (var2 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil);
  }
  return result;
}

TSTTableRBTreeNode_s **TSTTableRBTreeSuccessor(TSTTableRBTreeNode_s *a1)
{
  var3 = a1->var3;
  if (var3 == (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
  {
    uint64_t v3 = a1;
    while (1)
    {
      uint64_t result = (TSTTableRBTreeNode_s **)v3->var4;
      if (result == (TSTTableRBTreeNode_s **)&TSTTableRBTreeNil) {
        break;
      }
      BOOL v4 = v3 == result[2];
      uint64_t v3 = v3->var4;
      if (!v4) {
        return result;
      }
    }
    return (TSTTableRBTreeNode_s **)&TSTTableRBTreeNil;
  }
  else
  {
    do
    {
      uint64_t result = (TSTTableRBTreeNode_s **)var3;
      var3 = var3->var2;
    }
    while (var3 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil);
  }
  return result;
}

unsigned __int16 *TSTTableRBFirstNodeGreaterThanOrEqualTo(unsigned __int16 *result, unsigned int a2)
{
  if (!result) {
    return (unsigned __int16 *)&TSTTableRBTreeNil;
  }
  if (result == (unsigned __int16 *)&TSTTableRBTreeNil) {
    return 0;
  }
  do
  {
    unsigned int v2 = *result;
    if (v2 == a2) {
      break;
    }
    if (v2 >= a2)
    {
      uint64_t v3 = (unsigned __int16 *)*((void *)result + 1);
      if (v3 == (unsigned __int16 *)&TSTTableRBTreeNil) {
        return result;
      }
    }
    else
    {
      uint64_t v3 = (unsigned __int16 *)*((void *)result + 2);
      if (v3 == (unsigned __int16 *)&TSTTableRBTreeNil)
      {
        BOOL v4 = result;
        while (1)
        {
          uint64_t result = (unsigned __int16 *)*((void *)v4 + 3);
          if (result == (unsigned __int16 *)&TSTTableRBTreeNil) {
            break;
          }
          BOOL v5 = v4 == *((unsigned __int16 **)result + 2);
          BOOL v4 = (unsigned __int16 *)*((void *)v4 + 3);
          if (!v5) {
            return result;
          }
        }
        return (unsigned __int16 *)&TSTTableRBTreeNil;
      }
    }
    uint64_t result = v3;
  }
  while (v3);
  return result;
}

unsigned __int16 *TSTTableRBFirstNodeLessThanOrEqualTo(unsigned __int16 *a1, unsigned int a2)
{
  uint64_t result = (unsigned __int16 *)&TSTTableRBTreeNil;
  if (a1 && a1 != (unsigned __int16 *)&TSTTableRBTreeNil)
  {
    uint64_t result = a1;
    while (1)
    {
      unsigned int v4 = *result;
      if (v4 == a2) {
        break;
      }
      if (v4 >= a2)
      {
        BOOL v5 = (unsigned __int16 *)*((void *)result + 1);
        if (v5 == (unsigned __int16 *)&TSTTableRBTreeNil)
        {
          uint64_t v6 = result;
          while (1)
          {
            uint64_t result = (unsigned __int16 *)*((void *)v6 + 3);
            if (result == (unsigned __int16 *)&TSTTableRBTreeNil) {
              break;
            }
            BOOL v7 = v6 == *((unsigned __int16 **)result + 1);
            uint64_t v6 = (unsigned __int16 *)*((void *)v6 + 3);
            if (!v7) {
              return result;
            }
          }
          return (unsigned __int16 *)&TSTTableRBTreeNil;
        }
      }
      else
      {
        BOOL v5 = (unsigned __int16 *)*((void *)result + 2);
        if (v5 == (unsigned __int16 *)&TSTTableRBTreeNil) {
          return result;
        }
      }
      uint64_t result = v5;
      if (!v5) {
        return (unsigned __int16 *)&TSTTableRBTreeNil;
      }
    }
  }
  return result;
}

uint64_t TSTTableRBTreeStripIDForCellIndex(unsigned __int16 *a1, unsigned int a2, unsigned __int16 *a3)
{
  unsigned int v4 = TSTTableRBFirstNodeLessThanOrEqualTo(a1, a2);
  if (v4 == (unsigned __int16 *)&TSTTableRBTreeNil) {
    return 0;
  }
  if (a3) {
    *a3 = *v4;
  }
  return v4[1];
}

TSTTableRBTreeNode_s *TSTTableRBTreeDeleteFixup(TSTTableRBTreeNode_s *a1, TSTTableRBTreeNode_s *a2)
{
  if (a2 == a1) {
    goto LABEL_61;
  }
  while (1)
  {
    if (a2->var5)
    {
      var4 = a2;
      a2 = a1;
      goto LABEL_62;
    }
    var4 = a2->var4;
    unint64_t var2 = var4->var2;
    if (a2 != var2)
    {
      if (var2->var5 == 1)
      {
        var2->char var5 = 0;
        var4->char var5 = 1;
        var3 = var2->var3;
        var4->unint64_t var2 = var3;
        if (var3 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil) {
          var3->var4 = var4;
        }
        var2->var4 = var4->var4;
        BOOL v5 = var4->var4;
        uint64_t v6 = var2;
        if (v5 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
        {
          if (v5->var2 == var4) {
            uint64_t v7 = 8;
          }
          else {
            uint64_t v7 = 16;
          }
          *(void *)((char *)&v5->var0 + v7) = var2;
          uint64_t v6 = a1;
        }
        var2->var3 = var4;
        var4->var4 = var2;
        var4 = a2->var4;
        unint64_t var2 = var4->var2;
        a1 = v6;
      }
      unsigned int v9 = var2->var2;
      unsigned int v8 = var2->var3;
      if (v8->var5)
      {
        if (!v9->var5)
        {
          v8->char var5 = 0;
          var2->char var5 = 1;
          unint64_t v16 = v8->var2;
          var2->var3 = v16;
          if (v16 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil) {
            v16->var4 = var2;
          }
          v8->var4 = var2->var4;
          uint64_t v17 = var2->var4;
          uint64_t v18 = v8;
          if (v17 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
          {
            uint64_t v19 = 16;
            if (v17->var2 == var2) {
              uint64_t v19 = 8;
            }
            *(void *)((char *)&v17->var0 + v19) = v8;
            uint64_t v18 = a1;
          }
          v8->unint64_t var2 = var2;
          var2->var4 = v8;
          var4 = a2->var4;
          unint64_t var2 = var4->var2;
          unsigned int v9 = var2->var2;
          unsigned int v8 = var2->var3;
          a1 = v18;
        }
LABEL_38:
        var2->char var5 = var4->var5;
        var4->char var5 = 0;
        v9->char var5 = 0;
        var4->unint64_t var2 = v8;
        if (v8 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil) {
          v8->var4 = var4;
        }
        var2->var4 = var4->var4;
        int v20 = var4->var4;
        a2 = var2;
        if (v20 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
        {
          uint64_t v21 = 16;
          if (v20->var2 == var4) {
            uint64_t v21 = 8;
          }
          *(void *)((char *)&v20->var0 + v21) = var2;
          a2 = a1;
        }
        var2->var3 = var4;
        goto LABEL_60;
      }
      if (v9->var5) {
        goto LABEL_38;
      }
      goto LABEL_27;
    }
    unint64_t var2 = var4->var3;
    if (var2->var5 == 1)
    {
      var2->char var5 = 0;
      var4->char var5 = 1;
      unsigned __int8 v10 = var2->var2;
      var4->var3 = v10;
      if (v10 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil) {
        v10->var4 = var4;
      }
      var2->var4 = var4->var4;
      long long v11 = var4->var4;
      long long v12 = var2;
      if (v11 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
      {
        if (v11->var2 == var4) {
          uint64_t v13 = 8;
        }
        else {
          uint64_t v13 = 16;
        }
        *(void *)((char *)&v11->var0 + v13) = var2;
        long long v12 = a1;
      }
      var2->unint64_t var2 = var4;
      var4->var4 = var2;
      var4 = a2->var4;
      unint64_t var2 = var4->var3;
      a1 = v12;
    }
    uint64_t v14 = var2->var2;
    unint64_t v15 = var2->var3;
    if (v14->var5) {
      break;
    }
    if (v15->var5) {
      goto LABEL_53;
    }
LABEL_27:
    var2->char var5 = 1;
    a2 = var4;
    if (var4 == a1) {
      goto LABEL_62;
    }
  }
  if (!v15->var5)
  {
    v14->char var5 = 0;
    var2->char var5 = 1;
    uint64_t v22 = v14->var3;
    var2->unint64_t var2 = v22;
    if (v22 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil) {
      v22->var4 = var2;
    }
    v14->var4 = var2->var4;
    uint64_t v23 = var2->var4;
    uint64_t v24 = v14;
    if (v23 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
    {
      uint64_t v25 = 16;
      if (v23->var2 == var2) {
        uint64_t v25 = 8;
      }
      *(void *)((char *)&v23->var0 + v25) = v14;
      uint64_t v24 = a1;
    }
    v14->var3 = var2;
    var2->var4 = v14;
    var4 = a2->var4;
    unint64_t var2 = var4->var3;
    uint64_t v14 = var2->var2;
    unint64_t v15 = var2->var3;
    a1 = v24;
  }
LABEL_53:
  var2->char var5 = var4->var5;
  var4->char var5 = 0;
  v15->char var5 = 0;
  var4->var3 = v14;
  if (v14 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil) {
    v14->var4 = var4;
  }
  var2->var4 = var4->var4;
  unint64_t v26 = var4->var4;
  a2 = var2;
  if (v26 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
  {
    uint64_t v27 = 16;
    if (v26->var2 == var4) {
      uint64_t v27 = 8;
    }
    *(void *)((char *)&v26->var0 + v27) = var2;
    a2 = a1;
  }
  var2->unint64_t var2 = var4;
LABEL_60:
  var4->var4 = var2;
LABEL_61:
  var4 = a2;
LABEL_62:
  var4->char var5 = 0;
  return a2;
}

TSTTableRBTreeNode_s *TSTTableRBTreeDelete(TSTTableRBTreeNode_s *a1, void *a2)
{
  uint64_t v2 = a2[1];
  uint64_t v3 = a2;
  if ((_UNKNOWN *)v2 == &TSTTableRBTreeNil) {
    goto LABEL_4;
  }
  uint64_t v4 = a2[2];
  if ((_UNKNOWN *)v4 != &TSTTableRBTreeNil)
  {
    do
    {
      uint64_t v3 = (unsigned char *)v4;
      uint64_t v4 = *(void *)(v4 + 8);
    }
    while ((_UNKNOWN *)v4 != &TSTTableRBTreeNil);
LABEL_4:
    uint64_t v2 = *((void *)v3 + 2);
    goto LABEL_6;
  }
  uint64_t v3 = a2;
LABEL_6:
  *(void *)(v2 + 24) = *((void *)v3 + 3);
  uint64_t v5 = *((void *)v3 + 3);
  uint64_t v6 = (TSTTableRBTreeNode_s *)v2;
  if ((_UNKNOWN *)v5 != &TSTTableRBTreeNil)
  {
    uint64_t v7 = 16;
    if (v3 == *(unsigned char **)(v5 + 8)) {
      uint64_t v7 = 8;
    }
    *(void *)(v5 + v7) = v2;
    uint64_t v6 = a1;
  }
  if (v3 != (unsigned char *)a2) {
    *(_DWORD *)a2 = *(_DWORD *)v3;
  }
  if (!v3[32]) {
    uint64_t v6 = TSTTableRBTreeDeleteFixup(v6, (TSTTableRBTreeNode_s *)v2);
  }
  free(v3);
  return v6;
}

uint64_t TSTTableRBTreeShiftCellIndices(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = (unsigned __int16 *)result;
  if ((int)a3 >= 0) {
    unsigned int v8 = a3;
  }
  else {
    unsigned int v8 = -(int)a3;
  }
  while (1)
  {
    if (v8 >= 0xFFFF)
    {
      unsigned int v9 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v10 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableRBTreeShiftCellIndices(TSTTableRBTreeNode *, UInt16, int, BOOL)");
      uint64_t result = objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableRBTree.mm"), 443, @"shiftAmount out of range");
    }
    if (v7 == (unsigned __int16 *)&TSTTableRBTreeNil) {
      break;
    }
    unsigned int v11 = *v7;
    if (v11 == a2) {
      int v12 = a4;
    }
    else {
      int v12 = 0;
    }
    if (v11 <= a2 && v12 == 0)
    {
      uint64_t v14 = (unsigned __int16 **)(v7 + 8);
    }
    else
    {
      *uint64_t v7 = v11 + a3;
      uint64_t result = TSTTableRBTreeShiftCellIndices(*((void *)v7 + 2), a2, a3, a4);
      uint64_t v14 = (unsigned __int16 **)(v7 + 4);
    }
    uint64_t v7 = *v14;
  }
  return result;
}

unsigned __int16 *TSTTableRBTreeFind(unsigned __int16 *a1, unsigned int a2)
{
  uint64_t result = (unsigned __int16 *)&TSTTableRBTreeNil;
  if (a1 && a1 != (unsigned __int16 *)&TSTTableRBTreeNil)
  {
    while (1)
    {
      unsigned int v4 = *a1;
      if (v4 == a2) {
        break;
      }
      if (v4 <= a2) {
        uint64_t v5 = 8;
      }
      else {
        uint64_t v5 = 4;
      }
      a1 = *(unsigned __int16 **)&a1[v5];
      if (a1 == (unsigned __int16 *)&TSTTableRBTreeNil) {
        return result;
      }
    }
    return a1;
  }
  return result;
}

uint64_t TSTTableRBTreeShiftNodesAfter(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (unsigned __int16 *)result;
  if ((int)a3 >= 0) {
    unsigned int v6 = a3;
  }
  else {
    unsigned int v6 = -(int)a3;
  }
  if (v6 >= 0xFFFF)
  {
    uint64_t v7 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v8 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableRBTreeShiftNodesAfter(TSTTableRBTreeNode *, UInt16, int)");
    uint64_t result = objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableRBTree.mm"), 486, @"shiftAmount out of range");
  }
  if (v5 != (unsigned __int16 *)&TSTTableRBTreeNil)
  {
    unsigned int v9 = *v5;
    if (v9 <= a2)
    {
      uint64_t v10 = (uint64_t *)(v5 + 8);
    }
    else
    {
      *uint64_t v5 = v9 + a3;
      TSTTableRBTreeShiftCellIndices(*((void *)v5 + 2), a2, a3, 0);
      uint64_t v10 = (uint64_t *)(v5 + 4);
    }
    uint64_t v11 = *v10;
    return TSTTableRBTreeShiftCellIndices(v11, a2, a3, 0);
  }
  return result;
}

uint64_t TSTTableRBTreeShiftNodesAtOrAfter(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (unsigned __int16 *)result;
  if ((int)a3 >= 0) {
    unsigned int v6 = a3;
  }
  else {
    unsigned int v6 = -(int)a3;
  }
  if (v6 >= 0xFFFF)
  {
    uint64_t v7 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v8 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableRBTreeShiftNodesAtOrAfter(TSTTableRBTreeNode *, UInt16, int)");
    uint64_t result = objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableRBTree.mm"), 509, @"shiftAmount out of range");
  }
  if (v5 != (unsigned __int16 *)&TSTTableRBTreeNil)
  {
    unsigned int v9 = *v5;
    if (v9 >= a2)
    {
      *uint64_t v5 = v9 + a3;
      TSTTableRBTreeShiftCellIndices(*((void *)v5 + 2), a2, a3, 1);
      uint64_t v10 = (uint64_t *)(v5 + 4);
    }
    else
    {
      uint64_t v10 = (uint64_t *)(v5 + 8);
    }
    uint64_t v11 = *v10;
    return TSTTableRBTreeShiftCellIndices(v11, a2, a3, 1);
  }
  return result;
}

TSTTableRBTreeNode_s *TSTTableRBTreeDeleteKey(TSTTableRBTreeNode_s *result, unsigned int a2)
{
  if (result && result != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
  {
    uint64_t v2 = result;
    while (1)
    {
      unsigned int var0 = v2->var0;
      if (var0 == a2) {
        break;
      }
      if (var0 <= a2) {
        uint64_t v4 = 16;
      }
      else {
        uint64_t v4 = 8;
      }
      uint64_t v2 = *(TSTTableRBTreeNode_s **)((char *)&v2->var0 + v4);
      if (v2 == (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil) {
        return result;
      }
    }
    if (v2 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil) {
      return TSTTableRBTreeDelete(result, v2);
    }
  }
  return result;
}

uint64_t p_validateNode(unsigned int a1, unsigned __int16 a2, void *a3)
{
  uint64_t v4 = a1;
  if ([a3 containsIndex:a1])
  {
    uint64_t v5 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v6 = objc_msgSend(NSString, "stringWithUTF8String:", "void p_validateNode(UInt16, UInt16, void *)");
    objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableRBTree.mm"), 540, @"Duplicate keys in rbtree!");
  }

  return [a3 addIndex:v4];
}

void TSTTableRBTreeValidate(uint64_t a1)
{
  id v2 = objc_alloc_init(MEMORY[0x263F089C8]);
  TSTTableRBTreeApply(a1, (uint64_t (*)(uint64_t, uint64_t, uint64_t))p_validateNode, (uint64_t)v2);
}

uint64_t TSTTableRBTreeApply(uint64_t result, uint64_t (*a2)(uint64_t, uint64_t, uint64_t), uint64_t a3)
{
  if (result)
  {
    uint64_t v4 = a2;
    uint64_t v5 = (unsigned __int16 *)result;
    uint64_t v6 = *(void **)(result + 8);
    if (v6 != &TSTTableRBTreeNil)
    {
      TSTTableRBTreeApply(v6, a2, a3);
      uint64_t v4 = a2;
    }
    uint64_t v7 = (void *)*((void *)v5 + 2);
    if (v7 != &TSTTableRBTreeNil)
    {
      TSTTableRBTreeApply(v7, v4, a3);
      uint64_t v4 = a2;
    }
    uint64_t v8 = *v5;
    uint64_t v9 = v5[1];
    return v4(v8, v9, a3);
  }
  return result;
}

void TSTTableRBTreeDump(unsigned __int16 *a1)
{
  if (a1)
  {
    if (*((_UNKNOWN **)a1 + 1) != &TSTTableRBTreeNil) {
      TSTTableRBTreeDump();
    }
    if (*((_UNKNOWN **)a1 + 2) != &TSTTableRBTreeNil) {
      TSTTableRBTreeDump();
    }
    NSLog((NSString *)@"node %p: key:%d, value: %d", a1, *a1, a1[1]);
  }
}

uint64_t TSTTableSelectionCellCount(uint64_t a1)
{
  return [*(id *)(a1 + 16) cellCount];
}

uint64_t TSTTableSelectionSetCellRegion(uint64_t a1, void *a2)
{
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 12) = [a2 upperLeftCellID];
  uint64_t result = [a2 upperLeftCellID];
  *(_DWORD *)(a1 + 32) = result;
  return result;
}

uint64_t TSTTableSelectionSetCellRange(uint64_t a1, unint64_t a2)
{
  uint64_t result = [*(id *)(a1 + 16) equalsCellRange:a2];
  if ((result & 1) == 0)
  {

    *(void *)(a1 + 16) = 0;
    uint64_t result = (uint64_t)+[TSTCellRegion regionFromRange:a2];
    *(void *)(a1 + 16) = result;
    *(_DWORD *)(a1 + 12) = a2;
    *(_DWORD *)(a1 + 32) = (a2 + ((a2 >> 16) & 0xFF0000) + 16711680) & 0xFF0000 | (unsigned __int16)(a2 + HIWORD(a2) - 1);
  }
  return result;
}

void TSTTableSelectionAddCellRange(uint64_t a1)
{
  id v1 = *(id *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 16) = +[TSTCellRegion region:addingRange:](TSTCellRegion, "region:addingRange:");
}

void TSTTableSelectionSubtractCellRange(uint64_t a1)
{
  id v1 = *(id *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 16) = +[TSTCellRegion region:subtractingRange:](TSTCellRegion, "region:subtractingRange:");
}

uint64_t TSTTableSelectionContainsCell(uint64_t a1, unsigned int a2)
{
  return [*(id *)(a1 + 16) containsCellID:a2];
}

void sub_2237918A8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 200), 8);
  _Block_object_dispose((const void *)(v1 - 152), 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__27(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__27(uint64_t a1)
{
}

void sub_223791D2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t p_TSTCellRangeSplitForAdding(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  unint64_t v5 = 0;
  *a3 = 0xFFFFFFLL;
  unint64_t v6 = *(void *)a1;
  unint64_t v7 = *(void *)a2;
  uint64_t v8 = 16711680;
  uint64_t v9 = 0xFFFFLL;
  if ((unsigned __int16)v6 == 0xFFFFLL) {
    goto LABEL_27;
  }
  unint64_t v10 = 0;
  if ((v6 & 0xFF0000) == 0xFF0000) {
    goto LABEL_28;
  }
  unint64_t v5 = 0;
  if (HIWORD(v6)) {
    BOOL v11 = (v6 & 0xFFFF00000000) == 0;
  }
  else {
    BOOL v11 = 1;
  }
  if (v11)
  {
    unint64_t v10 = 0;
    uint64_t v8 = 16711680;
    uint64_t v9 = 0xFFFFLL;
    goto LABEL_28;
  }
  uint64_t v8 = 16711680;
  uint64_t v9 = 0xFFFFLL;
  if ((_WORD)v7 == 0xFFFF) {
    goto LABEL_27;
  }
  unint64_t v10 = 0;
  if ((v7 & 0xFF0000) == 0xFF0000) {
    goto LABEL_28;
  }
  unint64_t v5 = 0;
  uint64_t v8 = 16711680;
  uint64_t v9 = 0xFFFFLL;
  if (!HIWORD(v7))
  {
LABEL_27:
    unint64_t v10 = 0;
    goto LABEL_28;
  }
  unint64_t v10 = 0;
  if ((v7 & 0xFFFF00000000) != 0)
  {
    uint64_t v9 = 0;
    if (BYTE2(v6) <= BYTE2(v7)) {
      unsigned int v12 = BYTE2(v7);
    }
    else {
      unsigned int v12 = BYTE2(v6);
    }
    if ((unsigned __int16)v6 <= (unsigned __int16)v7) {
      uint64_t v13 = (unsigned __int16)v7;
    }
    else {
      uint64_t v13 = (unsigned __int16)v6;
    }
    if ((BYTE4(v6) + BYTE2(v6) - 1) >= (BYTE4(v7) + BYTE2(v7) - 1)) {
      unsigned int v14 = (BYTE4(v7) + BYTE2(v7) - 1);
    }
    else {
      unsigned int v14 = (BYTE4(v6) + BYTE2(v6) - 1);
    }
    unsigned int v15 = (unsigned __int16)(v6 + HIWORD(v6) - 1);
    if (v15 >= (unsigned __int16)(v7 + HIWORD(v7) - 1)) {
      unsigned int v15 = (unsigned __int16)(v7 + HIWORD(v7) - 1);
    }
    uint64_t v8 = 0;
    unint64_t v5 = 0;
    unint64_t v10 = 0;
    if (v13 <= v15 && v12 <= v14)
    {
      unint64_t v10 = ((unint64_t)(v15 - v13) << 48) + 0x1000000000000;
      unint64_t v5 = (unint64_t)(unsigned __int16)(v14 - v12 + 1) << 32;
      uint64_t v8 = v12 << 16;
      uint64_t v9 = v13;
    }
  }
LABEL_28:
  uint64_t v16 = 0;
  unint64_t v17 = v8 | v10 | v9 | v5;
  if ((_WORD)v17 != 0xFFFF && (v17 & 0xFF0000) != 0xFF0000)
  {
    uint64_t v16 = 0;
    if (HIWORD(v17))
    {
      if ((v17 & 0xFFFF00000000) != 0)
      {
        unint64_t v18 = HIWORD(v7);
        unsigned __int16 v19 = v17 - v7;
        uint64_t v20 = 0xFFFFFFLL;
        if ((unsigned __int16)v17 > (unsigned __int16)v7) {
          uint64_t v20 = v7;
        }
        if ((unsigned __int16)v17 < (unsigned __int16)v7) {
          unsigned __int16 v19 = 0;
        }
        unsigned __int16 v63 = v19;
        unsigned __int16 v21 = v17 + HIWORD(v10) - 1;
        if ((unsigned __int16)(v7 + HIWORD(v7) - 1) <= v21)
        {
          int v23 = (unsigned __int16)v17 > (unsigned __int16)v7;
          unint64_t v24 = v7 >> 16;
          unsigned __int16 v61 = -1;
          unint64_t v62 = 0;
          LODWORD(v22) = 255;
        }
        else
        {
          unint64_t v22 = v7 >> 16;
          unsigned __int16 v61 = v17 + HIWORD(v10);
          unint64_t v62 = v7 + HIWORD(v7) - (v17 + HIWORD(v10));
          if ((unsigned __int16)v17 <= (unsigned __int16)v7) {
            int v23 = 1;
          }
          else {
            int v23 = 2;
          }
          unint64_t v24 = v7 >> 16;
        }
        unsigned int v25 = (BYTE4(v7) + BYTE2(v7) - 1);
        if (BYTE2(v17) <= BYTE2(v7))
        {
          unint64_t v28 = 0;
          unsigned __int16 v27 = 0;
          unsigned __int16 v59 = -1;
          LOWORD(v26) = 255;
        }
        else
        {
          unint64_t v26 = v7 >> 16;
          unsigned __int16 v27 = BYTE2(v17) - v24;
          ++v23;
          unint64_t v28 = HIWORD(v7);
          unsigned __int16 v59 = v7;
        }
        unsigned int v29 = (BYTE4(v17) + BYTE2(v17) - 1);
        if (v29 >= v25)
        {
          unint64_t v18 = 0;
          unsigned __int16 v31 = 0;
          LOBYTE(v30) = 0;
          unsigned __int16 v32 = -1;
          unsigned int v60 = 255;
        }
        else
        {
          unint64_t v30 = v7 >> 24;
          unsigned int v60 = v29 + 1;
          unsigned __int16 v31 = (BYTE4(v7) + BYTE2(v7) - 1) - (BYTE4(v17) + BYTE2(v17) - 1);
          ++v23;
          unsigned __int16 v32 = v7;
        }
        if (v23 == 3)
        {
          if ((unsigned __int16)v17 > (unsigned __int16)v7)
          {
            if ((unsigned __int16)(v7 + HIWORD(v7) - 1) > v21)
            {
              if (BYTE2(v17) > BYTE2(v7)) {
                *(unsigned char *)(a1 + 2) = BYTE4(v17) + BYTE2(v6);
              }
              *(_WORD *)(a1 + 4) = WORD2(v6) - WORD2(v17);
              return 1;
            }
            *(_WORD *)a1 = v6 + HIWORD(v10);
          }
          *(_WORD *)(a1 + 6) = HIWORD(v6) - HIWORD(v10);
          return 1;
        }
        int v33 = (BYTE4(v6) + BYTE2(v6) - 1);
        if (v23 != 2)
        {
          if (v23 == 1)
          {
            BOOL v34 = (unsigned __int16)(v7 + HIWORD(v7) - 1) > v21
               || (unsigned __int16)v17 > (unsigned __int16)v7;
            if (v34 && BYTE2(v6) == BYTE2(v7) && v33 == v25
              || (BYTE2(v17) <= BYTE2(v7) ? (BOOL v35 = v29 >= v25) : (BOOL v35 = 0),
                  v35 ? (int v36 = 0) : (int v36 = 1),
                  (unsigned __int16)(v6 + HIWORD(v6) - 1) == (unsigned __int16)(v7 + HIWORD(v7) - 1)
               && v36
               && (unsigned __int16)v6 == (unsigned __int16)v7))
            {
              unint64_t v37 = TSTCellRangeUnionCellRange(v6, v7);
              *(void *)a1 = 0xFFFFFFLL;
              *(void *)a2 = v37;
            }
            else
            {
              unint64_t v45 = (v18 << 48) | ((unint64_t)v31 << 32) | ((unint64_t)v30 << 24) | ((unint64_t)v60 << 16) | v32;
              if (BYTE2(v17) <= BYTE2(v7)) {
                unint64_t v46 = v45;
              }
              else {
                unint64_t v46 = (v28 << 48) | ((unint64_t)v27 << 32) | ((unint64_t)(unsigned __int16)v26 << 16) | v59;
              }
              if ((unsigned __int16)(v7 + HIWORD(v7) - 1) > v21) {
                unint64_t v46 = (v62 << 48) | ((unint64_t)v22 << 16) | v61;
              }
              unint64_t v47 = v20 & 0xFFFFFFFFFFFFLL | ((unint64_t)v63 << 48);
              if ((unsigned __int16)v17 <= (unsigned __int16)v7) {
                unint64_t v47 = v46;
              }
              *(void *)a2 = v47;
            }
          }
          return 1;
        }
        BOOL v38 = (unsigned __int16)(v7 + HIWORD(v7) - 1) <= v21;
        BOOL v39 = (unsigned __int16)v17 <= (unsigned __int16)v7;
        if ((unsigned __int16)v17 > (unsigned __int16)v7 && !v38)
        {
          *(void *)a2 = v20 & 0xFFFFFFFFFFFFLL | ((unint64_t)v63 << 48);
          unint64_t v40 = v62;
LABEL_76:
          unint64_t v41 = (v40 << 48) | ((unint64_t)v22 << 16) | v61;
LABEL_81:
          *a3 = v41;
          return 1;
        }
        unsigned int v42 = BYTE2(v17);
        BOOL v43 = v29 >= v25;
        BOOL v34 = v42 > BYTE2(v7);
        BOOL v44 = v42 <= BYTE2(v7);
        if (v34 && !v43)
        {
          *(void *)a2 = (v28 << 48) | ((unint64_t)v27 << 32) | ((unint64_t)(unsigned __int16)v26 << 16) | v59;
          unint64_t v41 = (v18 << 48) | ((unint64_t)v31 << 32) | ((unint64_t)v30 << 24) | ((unint64_t)v60 << 16) | v32;
          goto LABEL_81;
        }
        if (v39 || v43)
        {
          if (v38 || v43)
          {
            if (v44 || v38)
            {
              if (v39 || v44) {
                return 1;
              }
              if ((unsigned __int16)(v6 + HIWORD(v6) - 1) == (unsigned __int16)(v7 + HIWORD(v7) - 1))
              {
                *(void *)a2 = v6;
                *(unsigned char *)(a2 + 2) = v24;
                __int16 v49 = WORD2(v6) + BYTE2(v6) - v24;
LABEL_102:
                *(_WORD *)(a2 + 4) = v49;
                unint64_t v50 = v20 & 0xFFFFFFFFFFFFLL | ((unint64_t)v63 << 48);
LABEL_114:
                *a3 = v50;
                *(void *)a1 = 0xFFFFFFLL;
                return 1;
              }
              if (v33 == v25)
              {
                *(void *)a2 = v6;
                *(_WORD *)a2 = v7;
                __int16 v56 = v6 - v7 + HIWORD(v6);
                goto LABEL_122;
              }
              *(void *)a2 = v20 & 0xFFFFFFFFFFFFLL | ((unint64_t)v63 << 48);
              unint64_t v55 = v10 & 0xFFFF000000000000 | ((unint64_t)v27 << 32) | ((unint64_t)(unsigned __int16)v26 << 16);
LABEL_116:
              unint64_t v41 = v55 | (unsigned __int16)v6;
              goto LABEL_81;
            }
            if ((unsigned __int16)v6 == (unsigned __int16)v7)
            {
              *(void *)a2 = v6;
              *(unsigned char *)(a2 + 2) = v24;
              __int16 v51 = WORD2(v6) + BYTE2(v6) - v24;
              goto LABEL_109;
            }
            if (v33 == v25)
            {
              *(void *)a2 = v6;
              __int16 v56 = v62 + HIWORD(v6);
LABEL_122:
              *(_WORD *)(a2 + 6) = v56;
              unint64_t v53 = (v28 << 48) | ((unint64_t)v27 << 32) | ((unint64_t)(unsigned __int16)v26 << 16);
              unsigned __int16 v54 = v59;
              goto LABEL_110;
            }
            unint64_t v57 = v62;
            unint64_t v58 = ((unint64_t)v27 << 32) | ((unint64_t)(v28 - v62) << 48) | ((unint64_t)(unsigned __int16)v26 << 16) | v59;
LABEL_124:
            *(void *)a2 = v58;
            unint64_t v40 = v57;
            goto LABEL_76;
          }
          if ((unsigned __int16)v6 == (unsigned __int16)v7)
          {
            *(void *)a2 = v6;
            __int16 v51 = v31 + WORD2(v6);
LABEL_109:
            *(_WORD *)(a2 + 4) = v51;
            unint64_t v53 = (v62 << 48) | ((unint64_t)v22 << 16);
            unsigned __int16 v54 = v61;
LABEL_110:
            unint64_t v50 = v53 & 0xFFFFFFFFFFFF0000 | v54;
            goto LABEL_114;
          }
          if (BYTE2(v6) != BYTE2(v7))
          {
            unint64_t v57 = v62;
            unint64_t v58 = ((unint64_t)v31 << 32) | ((unint64_t)(v18 - v62) << 48) | ((unint64_t)v30 << 24) | ((unint64_t)v60 << 16) | v32;
            goto LABEL_124;
          }
          *(void *)a2 = v6;
          __int16 v52 = v62 + HIWORD(v6);
        }
        else
        {
          if ((unsigned __int16)(v6 + HIWORD(v6) - 1) == (unsigned __int16)(v7 + HIWORD(v7) - 1))
          {
            *(void *)a2 = v6;
            __int16 v49 = v31 + WORD2(v6);
            goto LABEL_102;
          }
          if (BYTE2(v6) != BYTE2(v7))
          {
            *(void *)a2 = v20 & 0xFFFFFFFFFFFFLL | ((unint64_t)v63 << 48);
            unint64_t v55 = v10 & 0xFFFF000000000000 | ((unint64_t)v31 << 32) | ((unint64_t)v30 << 24) | ((unint64_t)v60 << 16);
            goto LABEL_116;
          }
          *(void *)a2 = v6;
          *(_WORD *)a2 = v7;
          __int16 v52 = v6 - v7 + HIWORD(v6);
        }
        *(_WORD *)(a2 + 6) = v52;
        unint64_t v50 = (v18 << 48) | ((unint64_t)v31 << 32) | ((unint64_t)v30 << 24) | ((unint64_t)v60 << 16) | v32;
        goto LABEL_114;
      }
    }
  }
  return v16;
}

void sub_22379292C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_223793218(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_223793368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_223793530(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_2237936B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_223793CE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_223793F20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_2237946CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_223794A50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_223796330(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v7 - 72), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__17(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 48) = *(_DWORD *)(a2 + 48);
  return result;
}

void sub_22379749C(_Unwind_Exception *a1)
{
  MEMORY[0x223CB8F20](v1, 0x10A0C40ADE6F494);
  _Unwind_Resume(a1);
}

uint64_t TSTTableDataListAddObject(TSTTableDataList *a1, TSTTableDataObject *a2)
{
  mIDs = a1->mIDs;
  if (mIDs && (uint64_t v5 = [(TSTTableDataObjectKeyDict *)mIDs keyForObject:a2], v5))
  {
    uint64_t mNextID = v5;
    TSTTableDataListAddReferenceForKey((id *)&a1->super.super.isa, v5);
  }
  else
  {
    [(TSPObject *)a1 willModify];
    uint64_t mNextID = a1->mNextID;
    a1->uint64_t mNextID = mNextID + 1;
    [(TSTIntegerKeyDict *)a1->mData setObject:a2 forKey:mNextID];
    uint64_t v7 = a1->mIDs;
    if (v7) {
      [(TSTTableDataObjectKeyDict *)v7 setKey:mNextID forObject:a2];
    }
  }
  return mNextID;
}

uint64_t TSTTableDataListAddReferenceForKey(id *a1, uint64_t a2)
{
  [a1 willModify];
  uint64_t result = [a1[7] objectForKey:a2];
  uint64_t v5 = result;
  if (!result)
  {
    unint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableDataListAddReferenceForKey(TSTTableDataList *, TSTTableDataListKey)");
    uint64_t result = objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 1089, @"No object with key %u!", a2);
  }
  ++*(_DWORD *)(v5 + 8);
  return result;
}

void *TSTTableDataListPrintCFDictionary(const __CFDictionary *a1)
{
  CFIndex Count = CFDictionaryGetCount(a1);
  uint64_t v3 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
  CFDictionaryGetKeysAndValues(a1, v3, 0);
  uint64_t v4 = (void *)[NSString string];
  if (Count >= 1)
  {
    uint64_t v5 = (void **)v3;
    do
    {
      unint64_t v6 = *v5++;
      [v4 stringByAppendingString:objc_msgSend(NSString, "stringWithFormat:", @"%@ : %ld\n", objc_msgSend(v6, "description"), CFDictionaryGetValue(a1, v6))];
      --Count;
    }
    while (Count);
  }
  free(v3);
  return v4;
}

uint64_t TSTTableDataListAddString(TSTTableDataList *a1, uint64_t a2)
{
  if (a1->mListType != 1)
  {
    uint64_t v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTTableDataListKey TSTTableDataListAddString(TSTTableDataList *, NSString *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 810, @"Can only store strings in this list!");
  }
  unint64_t v6 = [[TSTTableDataString alloc] initObjectWithString:a2];
  uint64_t v7 = TSTTableDataListAddObject(a1, v6);

  return v7;
}

uint64_t TSTTableDataListAddConditionalStyleSet(TSTTableDataList *a1, uint64_t a2)
{
  if (a1->mListType != 9)
  {
    uint64_t v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTTableDataListKey TSTTableDataListAddConditionalStyleSet(TSTTableDataList *, TSTConditionalStyleSet *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 818, @"Can only store conditional styles in this list!");
  }
  unint64_t v6 = [[TSTTableDataConditionalStyleSet alloc] initObjectWithConditionalStyleSet:a2];
  uint64_t v7 = TSTTableDataListAddObject(a1, v6);

  return v7;
}

uint64_t TSTTableDataListAddCellFormat(TSTTableDataList *a1, uint64_t a2)
{
  if (*(_DWORD *)a2 == 266) {
    *(void *)(a2 + 16) = 0;
  }
  if (a1->mListType != 2)
  {
    uint64_t v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTTableDataListKey TSTTableDataListAddCellFormat(TSTTableDataList *, TSUFormatStruct, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 830, @"Can only store formats in this list!");
  }
  unint64_t v6 = [TSTTableDataFormat alloc];
  long long v7 = *(_OWORD *)(a2 + 16);
  v11[0] = *(_OWORD *)a2;
  v11[1] = v7;
  uint64_t v12 = *(void *)(a2 + 32);
  uint64_t v8 = [(TSTTableDataFormat *)v6 initObjectWithFormat:v11];
  uint64_t v9 = TSTTableDataListAddObject(a1, v8);

  return v9;
}

uint64_t TSTTableDataListAddStyle(TSTTableDataList *a1, uint64_t a2)
{
  if (a1->mListType != 4)
  {
    uint64_t v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTTableDataListKey TSTTableDataListAddStyle(TSTTableDataList *, TSSStyle *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 850, @"Can only store styles in this list!");
  }
  unint64_t v6 = [[TSTTableDataStyle alloc] initObjectWithStyle:a2];
  uint64_t v7 = TSTTableDataListAddObject(a1, v6);

  return v7;
}

uint64_t TSTTableDataListAddFormulaError(TSTTableDataList *a1, uint64_t a2)
{
  if (a1->mListType != 5)
  {
    uint64_t v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTTableDataListKey TSTTableDataListAddFormulaError(TSTTableDataList *, TSWPStorage *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 859, @"Can only store formula errors in this list!");
  }
  unint64_t v6 = [[TSTTableDataFormulaError alloc] initObjectWithFormulaError:a2];
  uint64_t v7 = TSTTableDataListAddObject(a1, v6);

  return v7;
}

uint64_t TSTTableDataListAddRichTextPayload(TSTTableDataList *a1, uint64_t a2)
{
  if (a1->mListType != 8)
  {
    uint64_t v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTTableDataListKey TSTTableDataListAddRichTextPayload(TSTTableDataList *, TSTRichTextPayload *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 868, @"Can only store text objects in this list!");
  }
  unint64_t v6 = [[TSTTableDataRichTextPayload alloc] initObjectWithRichTextPayload:a2];
  uint64_t v7 = TSTTableDataListAddObject(a1, v6);

  return v7;
}

uint64_t TSTTableDataListAddCommentStorage(TSTTableDataList *a1, uint64_t a2)
{
  if (a1->mListType != 10)
  {
    uint64_t v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTTableDataListKey TSTTableDataListAddCommentStorage(TSTTableDataList *, TSDCommentStorage *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 877, @"Can only store cell comment objects in this list!");
  }
  unint64_t v6 = [[TSTTableDataCommentStorage alloc] initObjectWithCommentStorage:a2];
  uint64_t v7 = TSTTableDataListAddObject(a1, v6);

  return v7;
}

uint64_t TSTTableDataListAddCustomFormat(TSTTableDataList *a1, uint64_t a2)
{
  if (a1->mListType != 6)
  {
    uint64_t v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTTableDataListKey TSTTableDataListAddCustomFormat(TSTTableDataList *, TSUCustomFormat *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 886, @"Can only store custom formats in this list!");
  }
  unint64_t v6 = [[TSTTableDataCustomFormat alloc] initObjectWithCustomFormat:a2];
  uint64_t v7 = TSTTableDataListAddObject(a1, v6);

  return v7;
}

uint64_t TSTTableDataListAddMultipleChoiceListFormat(TSTTableDataList *a1, uint64_t a2)
{
  if (a1->mListType != 7)
  {
    uint64_t v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTTableDataListKey TSTTableDataListAddMultipleChoiceListFormat(TSTTableDataList *, TSTPopUpMenuModel *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 895, @"Can only store pop up menu model in this list!");
  }
  unint64_t v6 = [[TSTTableDataMultipleChoiceList alloc] initObjectWithPopUpMenuModel:a2];
  uint64_t v7 = TSTTableDataListAddObject(a1, v6);

  return v7;
}

uint64_t TSTTableDataListGetStringForKey(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 48) != 1)
  {
    uint64_t v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "NSString *TSTTableDataListGetStringForKey(TSTTableDataList *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 904, @"Can only store strings in this list!");
  }
  uint64_t result = [*(id *)(a1 + 56) objectForKey:a2];
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

__n128 TSTTableDataListGetCellFormatForKey@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (*(_DWORD *)(a1 + 48) != 2)
  {
    unint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "TSUFormatStruct TSTTableDataListGetCellFormatForKey(TSTTableDataList *, TSTTableDataListKey)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 919, @"Can only store formats in this list!");
  }
  *(void *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_DWORD *)a3 = -1;
  uint64_t v8 = [*(id *)(a1 + 56) objectForKey:a2];
  if (v8)
  {
    __n128 result = *(__n128 *)(v8 + 16);
    long long v10 = *(_OWORD *)(v8 + 32);
    *(__n128 *)a3 = result;
    *(_OWORD *)(a3 + 16) = v10;
    *(void *)(a3 + 32) = *(void *)(v8 + 48);
  }
  return result;
}

uint64_t TSTTableDataListGetStyleForKey(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 48) != 4)
  {
    uint64_t v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "TSSStyle *TSTTableDataListGetStyleForKey(TSTTableDataList *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 951, @"Can only store styles in this list!");
  }
  uint64_t result = [*(id *)(a1 + 56) objectForKey:a2];
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

uint64_t TSTTableDataListGetConditionalStyleSetForKey(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 48) != 9)
  {
    uint64_t v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTConditionalStyleSet *TSTTableDataListGetConditionalStyleSetForKey(TSTTableDataList *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 966, @"Can only store conditional styles in this list!");
  }
  uint64_t result = [*(id *)(a1 + 56) objectForKey:a2];
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

uint64_t TSTTableDataListGetFormulaErrorForKey(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 48) != 5)
  {
    uint64_t v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "TSWPStorage *TSTTableDataListGetFormulaErrorForKey(TSTTableDataList *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 983, @"Can only store formulaErrors in this list!");
  }
  uint64_t result = [*(id *)(a1 + 56) objectForKey:a2];
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

uint64_t TSTTableDataListGetRichTextPayloadForKey(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 48) != 8)
  {
    uint64_t v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTRichTextPayload *TSTTableDataListGetRichTextPayloadForKey(TSTTableDataList *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 998, @"Can only store text storages in this list!");
  }
  uint64_t result = [*(id *)(a1 + 56) objectForKey:a2];
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

uint64_t TSTTableDataListGetCommentStorageForKey(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 48) != 10)
  {
    uint64_t v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "TSDCommentStorage *TSTTableDataListGetCommentStorageForKey(TSTTableDataList *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 1013, @"Can only store cell comment storage objects in this list!");
  }
  uint64_t result = [*(id *)(a1 + 56) objectForKey:a2];
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

uint64_t TSTTableDataListGetCustomFormatForKey(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 48) != 6)
  {
    uint64_t v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "TSUCustomFormat *TSTTableDataListGetCustomFormatForKey(TSTTableDataList *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 1028, @"Can only store custom formats in this list!");
  }
  uint64_t result = [*(id *)(a1 + 56) objectForKey:a2];
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

uint64_t TSTTableDataListGetMultipleChoiceListFormatForKey(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 48) != 7)
  {
    uint64_t v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTPopUpMenuModel *TSTTableDataListGetMultipleChoiceListFormatForKey(TSTTableDataList *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 1044, @"Can only store pop up menu model in this list!");
  }
  uint64_t result = [*(id *)(a1 + 56) objectForKey:a2];
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

uint64_t TSTTableDataListGetCount(uint64_t a1)
{
  return [*(id *)(a1 + 56) count];
}

uint64_t TSTTableDataListRefCountForKey(uint64_t a1, uint64_t a2)
{
  uint64_t result = [*(id *)(a1 + 56) objectForKey:a2];
  if (result) {
    return *(unsigned int *)(result + 8);
  }
  return result;
}

uint64_t TSTTableDataListRemoveReferenceForKey(uint64_t a1, uint64_t a2)
{
  [(id)a1 willModify];
  uint64_t v4 = (id)[*(id *)(a1 + 56) objectForKey:a2];
  if (v4)
  {
    int v5 = v4[2] - 1;
    v4[2] = v5;
    if (!v5)
    {
      long long v10 = v4;
      [*(id *)(a1 + 56) removeObjectForKey:a2];
      unint64_t v6 = *(void **)(a1 + 64);
      if (v6) {
        [v6 removeKeyForObject:v10];
      }
    }
    return MEMORY[0x270F9A758]();
  }
  else
  {
    uint64_t v7 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v8 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableDataListRemoveReferenceForKey(TSTTableDataList *, TSTTableDataListKey)");
    return objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 1099, @"No object with key %u!", a2);
  }
}

uint64_t TSTTableDataListTransform(void *a1, uint64_t a2, uint64_t a3)
{
  [a1 willModify];
  unint64_t v6 = (void *)a1[7];

  return [v6 transformWithFunction:a2 withState:a3];
}

uint64_t TSTTableDataListHasher()
{
  return 1;
}

uint64_t TSTTableDataListGetKeyForCustomFormat(TSTTableDataList *a1, TSUCustomFormat *a2)
{
  if (!a1->mIDs)
  {
    uint64_t v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTTableDataListKey TSTTableDataListGetKeyForCustomFormat(TSTTableDataList *, TSUCustomFormat *)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 1136, @"Can't do a reverse lookup on a list that doesn't support it!");
  }
  if (a1->mListType != 6)
  {
    unint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTTableDataListKey TSTTableDataListGetKeyForCustomFormat(TSTTableDataList *, TSUCustomFormat *)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 1137, @"Can only have custom formats in this list!");
  }
  id v8 = [[TSTTableDataCustomFormat alloc] initObjectWithCustomFormat:a2];
  mIDs = a1->mIDs;
  if (mIDs) {
    uint64_t v10 = [(TSTTableDataObjectKeyDict *)mIDs keyForObject:v8];
  }
  else {
    uint64_t v10 = 0;
  }

  return v10;
}

uint64_t TSTTableDumpTile(void *a1)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  NSLog((NSString *)@"%@", [a1 description]);
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  id v2 = (void *)a1[7];
  uint64_t result = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
  if (result)
  {
    uint64_t v4 = result;
    uint64_t v5 = *(void *)v8;
    do
    {
      uint64_t v6 = 0;
      do
      {
        if (*(void *)v8 != v5) {
          objc_enumerationMutation(v2);
        }
        TSTTableDumpTileRowInfo(*(void *)(*((void *)&v7 + 1) + 8 * v6++));
      }
      while (v4 != v6);
      uint64_t result = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
      uint64_t v4 = result;
    }
    while (result);
  }
  return result;
}

uint64_t TSTTableTileListRows(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  long long v6 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  uint64_t v1 = *(void **)(a1 + 56);
  uint64_t result = [v1 countByEnumeratingWithState:&v6 objects:v10 count:16];
  if (result)
  {
    uint64_t v3 = result;
    uint64_t v4 = *(void *)v7;
    do
    {
      uint64_t v5 = 0;
      do
      {
        if (*(void *)v7 != v4) {
          objc_enumerationMutation(v1);
        }
        NSLog((NSString *)@"%@", *(void *)(*((void *)&v6 + 1) + 8 * v5++));
      }
      while (v3 != v5);
      uint64_t result = [v1 countByEnumeratingWithState:&v6 objects:v10 count:16];
      uint64_t v3 = result;
    }
    while (result);
  }
  return result;
}

uint64_t TSTTableTileValidate(uint64_t a1)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  id obj = *(id *)(a1 + 56);
  uint64_t result = [obj countByEnumeratingWithState:&v23 objects:v27 count:16];
  if (result)
  {
    uint64_t v2 = result;
    unsigned __int16 v3 = 0;
    int v4 = 0;
    LOWORD(v5) = 0;
    unsigned __int8 v6 = 0;
    uint64_t v7 = *(void *)v24;
    do
    {
      int v21 = v4;
      uint64_t v8 = 0;
      do
      {
        if (*(void *)v24 != v7) {
          objc_enumerationMutation(obj);
        }
        uint64_t v9 = *(void *)(*((void *)&v23 + 1) + 8 * v8);
        if (*(unsigned __int16 *)(v9 + 536) <= (unsigned __int16)v5) {
          unsigned int v5 = (unsigned __int16)v5;
        }
        else {
          unsigned int v5 = *(unsigned __int16 *)(v9 + 536);
        }
        if (!*(unsigned char *)(v9 + 541)) {
          TSTTableTileRowInfoRecalculateMaxTileColumnIndex(*(void *)(*((void *)&v23 + 1) + 8 * v8));
        }
        unsigned int v10 = *(unsigned __int8 *)(v9 + 540);
        if (v10 > v6 && v10 != 255) {
          unsigned __int8 v6 = *(unsigned char *)(v9 + 540);
        }
        TSTTableTileRowInfoValidate(v9);
        v3 += *(_WORD *)(v9 + 538);
        ++v8;
      }
      while (v2 != v8);
      int v4 = v21 + v2;
      uint64_t result = [obj countByEnumeratingWithState:&v23 objects:v27 count:16];
      uint64_t v2 = result;
    }
    while (result);
  }
  else
  {
    unsigned __int16 v3 = 0;
    LOWORD(v4) = 0;
    unsigned int v5 = 0;
    unsigned __int8 v6 = 0;
  }
  if (v5 != *(unsigned __int16 *)(a1 + 50))
  {
    uint64_t v12 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v13 = [NSString stringWithUTF8String:"void TSTTableTileValidate(TSTTableTile *)"];
    uint64_t result = [v12 handleFailureInFunction:v13, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 903, @"max row in tile %@ does not match maximum row index in row infos stored in tile: %hu != %hu", a1, *(unsigned __int16 *)(a1 + 50), v5 file lineNumber description];
  }
  if (*(unsigned __int8 *)(a1 + 48) != v6)
  {
    unsigned int v14 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v15 = [NSString stringWithUTF8String:"void TSTTableTileValidate(TSTTableTile *)"];
    uint64_t result = [v14 handleFailureInFunction:v15, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 907, @"max row in tile %@ does not match maximum row index in row infos stored in tile: %hu != %hu", a1, *(unsigned __int8 *)(a1 + 48), v6 file lineNumber description];
  }
  if (*(unsigned __int16 *)(a1 + 64) != (unsigned __int16)v4)
  {
    uint64_t v16 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v17 = [NSString stringWithUTF8String:"void TSTTableTileValidate(TSTTableTile *)"];
    uint64_t result = [v16 handleFailureInFunction:v17, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 911, @"number of rows in tile %@ does not match number of row infos stored in tile: %hu != %hu", a1, *(unsigned __int16 *)(a1 + 64), (unsigned __int16)v4 file lineNumber description];
  }
  if (*(unsigned __int16 *)(a1 + 52) != v3)
  {
    unint64_t v18 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v19 = [NSString stringWithUTF8String:"void TSTTableTileValidate(TSTTableTile *)"];
    return [v18 handleFailureInFunction:v19, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 915, @"number of cells in tile %@ not consistent with row cell count: %hu != %hu", a1, *(unsigned __int16 *)(a1 + 52), v3 file lineNumber description];
  }
  return result;
}

TSTTableTileRowInfo *TSTTableTileRowInfoForTileRowIndex(TSTTableTile *a1, uint64_t a2, int a3)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  mRowInfos = a1->mRowInfos;
  uint64_t v7 = [(NSMutableArray *)mRowInfos countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v7)
  {
    uint64_t v8 = v7;
    uint64_t v9 = *(void *)v13;
LABEL_3:
    uint64_t v10 = 0;
    while (1)
    {
      if (*(void *)v13 != v9) {
        objc_enumerationMutation(mRowInfos);
      }
      uint64_t result = *(TSTTableTileRowInfo **)(*((void *)&v12 + 1) + 8 * v10);
      if (result->mTileRowIndex == a2) {
        break;
      }
      if (v8 == ++v10)
      {
        uint64_t v8 = [(NSMutableArray *)mRowInfos countByEnumeratingWithState:&v12 objects:v16 count:16];
        if (v8) {
          goto LABEL_3;
        }
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    if (a3)
    {
      [(TSPObject *)a1 willModify];
      return p_AddRowInfoWithRowIndex(a1, a2);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

TSTTableTileRowInfo *p_AddRowInfoWithRowIndex(TSTTableTile *a1, uint64_t a2)
{
  unsigned int v2 = a2;
  int v4 = [[TSTTableTileRowInfo alloc] initWithOwner:a1 tileRowIndex:a2];
  p_InsertRowInfoWithRowIndex(a1, v4, v2);

  return v4;
}

const void *TSTTableTileRowInfoForRowArrayIndex(uint64_t a1, CFIndex idx)
{
  return CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), idx);
}

UInt8 *TSTTableTileGetCellStorageRef(TSTTableTile *a1, unsigned int a2, uint64_t a3)
{
  if (!a1->mNumCells) {
    return 0;
  }
  int v4 = TSTTableTileRowInfoForTileRowIndex(a1, a3, 0);
  if (!v4) {
    return 0;
  }

  return TSTTableTileRowInfoCellStorageRefAtTileColumnIndex((uint64_t)v4, a2);
}

void TSTTableTileSetCell(TSTTableTile *a1, unsigned int a2, uint64_t a3, void *a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  [(TSPObject *)a1 willModify];
  uint64_t v8 = TSTTableTileRowInfoForTileRowIndex(a1, a3, 0);
  if (!v8)
  {
    uint64_t v8 = p_AddRowInfoWithRowIndex(a1, a3);
    if (!v8)
    {
      uint64_t v9 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v10 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableTileSetCell(TSTTableTile *, TSUColumnIndex, TSURowIndex, TSTCell *)");
      objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 374, @"Couldn't find row info for row index %hu", a3);
    }
  }
  mCellCFIndex Count = v8->mCellCount;
  TSTTableTileRowInfoSetCell(v8, a2, a4);
  unsigned int v12 = v8->mCellCount;
  if (v12 <= mCellCount)
  {
    if (v12 >= mCellCount) {
      goto LABEL_9;
    }
    __int16 v13 = -1;
  }
  else
  {
    __int16 v13 = 1;
  }
  a1->mNumCells += v13;
LABEL_9:
  if (a1->mMaxColumn <= a2)
  {
    if (a4)
    {
      a1->mMaxColumn = a2;
    }
    else
    {
      int v21 = v8;
      a1->mMaxColumn = 0;
      long long v22 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      mRowInfos = a1->mRowInfos;
      uint64_t v15 = [(NSMutableArray *)mRowInfos countByEnumeratingWithState:&v22 objects:v26 count:16];
      if (v15)
      {
        uint64_t v16 = v15;
        uint64_t v17 = *(void *)v23;
        do
        {
          for (uint64_t i = 0; i != v16; ++i)
          {
            if (*(void *)v23 != v17) {
              objc_enumerationMutation(mRowInfos);
            }
            uint64_t v19 = *(void *)(*((void *)&v22 + 1) + 8 * i);
            if (*(_WORD *)(v19 + 538))
            {
              if (!*(unsigned char *)(v19 + 541)) {
                TSTTableTileRowInfoRecalculateMaxTileColumnIndex(*(void *)(*((void *)&v22 + 1) + 8 * i));
              }
              unsigned int v20 = *(unsigned __int8 *)(v19 + 540);
              if (v20 != 255 && v20 > a1->mMaxColumn) {
                a1->mMaxColumn = v20;
              }
            }
          }
          uint64_t v16 = [(NSMutableArray *)mRowInfos countByEnumeratingWithState:&v22 objects:v26 count:16];
        }
        while (v16);
      }
      uint64_t v8 = v21;
    }
  }
  if (!v8->mCellCount) {
    p_RemoveRowInfo(a1, v8);
  }
}

void p_RemoveRowInfo(TSTTableTile *a1, TSTTableTileRowInfo *a2)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  mTileRowIndedouble x = a2->mTileRowIndex;
  if (!a2->mMaxTileColumnIndexValid) {
    TSTTableTileRowInfoRecalculateMaxTileColumnIndex((uint64_t)a2);
  }
  mMaxTileColumnIndedouble x = a2->mMaxTileColumnIndex;
  unsigned __int8 v6 = a2;
  [(NSMutableArray *)a1->mRowInfos removeObject:a2];
  --a1->mNumRows;
  a1->mNumCells -= a2->mCellCount;

  if (mTileRowIndex >= a1->mMaxRow)
  {
    unsigned int v20 = mMaxTileColumnIndex;
    a1->mMaxRow = 0;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    mRowInfos = a1->mRowInfos;
    uint64_t v8 = [(NSMutableArray *)mRowInfos countByEnumeratingWithState:&v21 objects:v25 count:16];
    if (v8)
    {
      uint64_t v9 = v8;
      uint64_t v10 = *(void *)v22;
      do
      {
        for (uint64_t i = 0; i != v9; ++i)
        {
          if (*(void *)v22 != v10) {
            objc_enumerationMutation(mRowInfos);
          }
          unsigned int v12 = *(unsigned __int16 *)(*(void *)(*((void *)&v21 + 1) + 8 * i) + 536);
          if (v12 > a1->mMaxRow) {
            a1->mMaxRow = v12;
          }
        }
        uint64_t v9 = [(NSMutableArray *)mRowInfos countByEnumeratingWithState:&v21 objects:v25 count:16];
      }
      while (v9);
    }
    mMaxTileColumnIndedouble x = v20;
  }
  if (mMaxTileColumnIndex != 255 && mMaxTileColumnIndex >= a1->mMaxColumn)
  {
    a1->mMaxColumn = 0;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    __int16 v13 = a1->mRowInfos;
    uint64_t v14 = [(NSMutableArray *)v13 countByEnumeratingWithState:&v21 objects:v25 count:16];
    if (v14)
    {
      uint64_t v15 = v14;
      uint64_t v16 = *(void *)v22;
      do
      {
        for (uint64_t j = 0; j != v15; ++j)
        {
          if (*(void *)v22 != v16) {
            objc_enumerationMutation(v13);
          }
          uint64_t v18 = *(void *)(*((void *)&v21 + 1) + 8 * j);
          if (*(_WORD *)(v18 + 538))
          {
            if (!*(unsigned char *)(v18 + 541)) {
              TSTTableTileRowInfoRecalculateMaxTileColumnIndex(*(void *)(*((void *)&v21 + 1) + 8 * j));
            }
            unsigned int v19 = *(unsigned __int8 *)(v18 + 540);
            if (v19 != 255 && v19 > a1->mMaxColumn) {
              a1->mMaxColumn = v19;
            }
          }
        }
        uint64_t v15 = [(NSMutableArray *)v13 countByEnumeratingWithState:&v21 objects:v25 count:16];
      }
      while (v15);
    }
  }
}

void TSTTableTileRemoveCell(TSTTableTile *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  if (a1->mMaxColumn < a2)
  {
    unsigned __int8 v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableTileRemoveCell(TSTTableTile *, TSUColumnIndex, TSURowIndex)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 408, @"column index too large");
  }
  if (a1->mMaxRow < a3)
  {
    uint64_t v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableTileRemoveCell(TSTTableTile *, TSUColumnIndex, TSURowIndex)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 412, @"row index too large");
  }
  uint64_t v10 = TSTTableTileRowInfoForTileRowIndex(a1, a3, 0);
  if (v10)
  {
    uint64_t v11 = v10;
    [(TSPObject *)a1 willModify];
    mCellCFIndex Count = v11->mCellCount;
    TSTTableTileRowInfoSetCell(v11, a2, 0);
    unsigned int v13 = v11->mCellCount;
    if (v13 <= mCellCount)
    {
      if (v13 >= mCellCount)
      {
LABEL_11:
        if (a1->mMaxColumn <= a2)
        {
          long long v22 = v11;
          a1->mMaxColumn = 0;
          long long v23 = 0u;
          long long v24 = 0u;
          long long v25 = 0u;
          long long v26 = 0u;
          mRowInfos = a1->mRowInfos;
          uint64_t v16 = [(NSMutableArray *)mRowInfos countByEnumeratingWithState:&v23 objects:v27 count:16];
          if (v16)
          {
            uint64_t v17 = v16;
            uint64_t v18 = *(void *)v24;
            do
            {
              for (uint64_t i = 0; i != v17; ++i)
              {
                if (*(void *)v24 != v18) {
                  objc_enumerationMutation(mRowInfos);
                }
                uint64_t v20 = *(void *)(*((void *)&v23 + 1) + 8 * i);
                if (*(_WORD *)(v20 + 538))
                {
                  if (!*(unsigned char *)(v20 + 541)) {
                    TSTTableTileRowInfoRecalculateMaxTileColumnIndex(*(void *)(*((void *)&v23 + 1) + 8 * i));
                  }
                  unsigned int v21 = *(unsigned __int8 *)(v20 + 540);
                  if (v21 != 255 && v21 > a1->mMaxColumn) {
                    a1->mMaxColumn = v21;
                  }
                }
              }
              uint64_t v17 = [(NSMutableArray *)mRowInfos countByEnumeratingWithState:&v23 objects:v27 count:16];
            }
            while (v17);
          }
          uint64_t v11 = v22;
        }
        if (!v11->mCellCount) {
          p_RemoveRowInfo(a1, v11);
        }
        return;
      }
      __int16 v14 = -1;
    }
    else
    {
      __int16 v14 = 1;
    }
    a1->mNumCells += v14;
    goto LABEL_11;
  }
}

uint64_t TSTTableTileInsertColumns(uint64_t a1, char a2, unsigned int a3, char a4)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  [(id)a1 willModify];
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  id obj = *(id *)(a1 + 56);
  uint64_t v8 = [obj countByEnumeratingWithState:&v18 objects:v22 count:16];
  if (v8)
  {
    uint64_t v9 = v8;
    unsigned __int8 v10 = 0;
    uint64_t v11 = *(void *)v19;
    do
    {
      for (uint64_t i = 0; i != v9; ++i)
      {
        if (*(void *)v19 != v11) {
          objc_enumerationMutation(obj);
        }
        unsigned int v13 = *(unsigned char **)(*((void *)&v18 + 1) + 8 * i);
        TSTTableTileRowInfoInsertColumns(v13, a2, a3, a4);
        if (!v13[541]) {
          TSTTableTileRowInfoRecalculateMaxTileColumnIndex((uint64_t)v13);
        }
        unsigned int v14 = v13[540];
        if (v14 > v10 && v14 != 255) {
          unsigned __int8 v10 = v13[540];
        }
      }
      uint64_t v9 = [obj countByEnumeratingWithState:&v18 objects:v22 count:16];
    }
    while (v9);
  }
  else
  {
    unsigned __int8 v10 = 0;
  }
  *(unsigned char *)(a1 + 48) = v10;
  return 0;
}

uint64_t TSTTableTileRemoveColumns(uint64_t a1, int a2, int a3)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  [(id)a1 willModify];
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  id obj = *(id *)(a1 + 56);
  uint64_t v6 = [obj countByEnumeratingWithState:&v18 objects:v22 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    unsigned __int8 v8 = 0;
    uint64_t v9 = *(void *)v19;
    do
    {
      for (uint64_t i = 0; i != v7; ++i)
      {
        if (*(void *)v19 != v9) {
          objc_enumerationMutation(obj);
        }
        uint64_t v11 = *(TSTTableTileRowInfo **)(*((void *)&v18 + 1) + 8 * i);
        mCellCFIndex Count = v11->mCellCount;
        TSTTableTileRowInfoRemoveColumns(v11, a2, a3);
        int v13 = v11->mCellCount - mCellCount;
        if (v13) {
          *(_WORD *)(a1 + 52) += v13;
        }
        if (!v11->mMaxTileColumnIndexValid) {
          TSTTableTileRowInfoRecalculateMaxTileColumnIndex((uint64_t)v11);
        }
        mMaxTileColumnIndedouble x = v11->mMaxTileColumnIndex;
        if (mMaxTileColumnIndex > v8 && mMaxTileColumnIndex != 255) {
          unsigned __int8 v8 = v11->mMaxTileColumnIndex;
        }
      }
      uint64_t v7 = [obj countByEnumeratingWithState:&v18 objects:v22 count:16];
    }
    while (v7);
  }
  else
  {
    unsigned __int8 v8 = 0;
  }
  *(unsigned char *)(a1 + 48) = v8;
  return 0;
}

void TSTTableTileMoveColumns(uint64_t a1, unsigned int a2, unsigned int a3, int a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  [(id)a1 willModify];
  if (*(_WORD *)(a1 + 64))
  {
    unsigned int v8 = *(unsigned __int8 *)(a1 + 48);
    if (v8 >= a2 || v8 >= a3)
    {
      unsigned __int8 v10 = malloc_type_malloc(0x57FFA8uLL, 0x40D695ABuLL);
      uint64_t v11 = (unsigned __int16 *)malloc_type_malloc(0x1FFFEuLL, 0x1000040BDFB0063uLL);
      long long v22 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      uint64_t v20 = a1;
      id obj = *(id *)(a1 + 56);
      uint64_t v12 = [obj countByEnumeratingWithState:&v22 objects:v26 count:16];
      if (v12)
      {
        uint64_t v13 = v12;
        unsigned __int8 v14 = 0;
        uint64_t v15 = *(void *)v23;
        do
        {
          for (uint64_t i = 0; i != v13; ++i)
          {
            if (*(void *)v23 != v15) {
              objc_enumerationMutation(obj);
            }
            uint64_t v17 = *(TSTTableTileRowInfo **)(*((void *)&v22 + 1) + 8 * i);
            TSTTableTileRowInfoMoveColumns(v17, a2, a3, a4, v10, v11);
            if (!v17->mMaxTileColumnIndexValid) {
              TSTTableTileRowInfoRecalculateMaxTileColumnIndex((uint64_t)v17);
            }
            mMaxTileColumnIndedouble x = v17->mMaxTileColumnIndex;
            if (mMaxTileColumnIndex > v14 && mMaxTileColumnIndex != 255) {
              unsigned __int8 v14 = v17->mMaxTileColumnIndex;
            }
          }
          uint64_t v13 = [obj countByEnumeratingWithState:&v22 objects:v26 count:16];
        }
        while (v13);
      }
      else
      {
        unsigned __int8 v14 = 0;
      }
      free(v10);
      free(v11);
      *(unsigned char *)(v20 + 48) = v14;
    }
  }
}

uint64_t TSTTableTileInsertRows(uint64_t a1, unsigned int a2, __int16 a3, int a4)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  [(id)a1 willModify];
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  uint64_t v7 = *(void **)(a1 + 56);
  uint64_t result = [v7 countByEnumeratingWithState:&v23 objects:v31 count:16];
  if (result)
  {
    uint64_t v9 = result;
    uint64_t v10 = *(void *)v24;
    do
    {
      uint64_t v11 = 0;
      do
      {
        if (*(void *)v24 != v10) {
          objc_enumerationMutation(v7);
        }
        uint64_t v12 = *(void *)(*((void *)&v23 + 1) + 8 * v11);
        unsigned int v13 = *(unsigned __int16 *)(v12 + 536);
        if (v13 == a2) {
          int v14 = a4;
        }
        else {
          int v14 = 1;
        }
        if (v13 >= a2 && v14 != 0)
        {
          __int16 v16 = v13 + a3;
          [*(id *)(*((void *)&v23 + 1) + 8 * v11) willModify];
          *(_WORD *)(v12 + 536) = v16;
        }
        ++v11;
      }
      while (v9 != v11);
      uint64_t result = [v7 countByEnumeratingWithState:&v23 objects:v31 count:16];
      uint64_t v9 = result;
    }
    while (result);
  }
  if (*(_WORD *)(a1 + 64))
  {
    *(_WORD *)(a1 + 50) = 0;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    uint64_t v17 = *(void **)(a1 + 56);
    uint64_t result = [v17 countByEnumeratingWithState:&v27 objects:v32 count:16];
    if (result)
    {
      uint64_t v18 = result;
      uint64_t v19 = *(void *)v28;
      do
      {
        uint64_t v20 = 0;
        do
        {
          if (*(void *)v28 != v19) {
            objc_enumerationMutation(v17);
          }
          unsigned int v21 = *(unsigned __int16 *)(*(void *)(*((void *)&v27 + 1) + 8 * v20) + 536);
          if (v21 > *(unsigned __int16 *)(a1 + 50)) {
            *(_WORD *)(a1 + 50) = v21;
          }
          ++v20;
        }
        while (v18 != v20);
        uint64_t result = [v17 countByEnumeratingWithState:&v27 objects:v32 count:16];
        uint64_t v18 = result;
      }
      while (result);
    }
  }
  return result;
}

void TSTTableTileRemoveRows(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  [(id)a1 willModify];
  if (*(_WORD *)(a1 + 64))
  {
    unsigned __int16 v6 = 0;
    __int16 v7 = 0;
    unsigned __int16 v8 = *(_WORD *)(a1 + 64) - 1;
    __int16 v27 = a3;
    unsigned int v9 = a3 + a2;
    do
    {
      ValueAtIndedouble x = (unsigned __int16 *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), (unsigned __int16)(v8 - v6));
      unsigned int v11 = ValueAtIndex[268];
      if (v11 >= a2)
      {
        uint64_t v12 = ValueAtIndex;
        if (v9 <= v11)
        {
          unsigned __int16 v13 = v11 - v27;
          [ValueAtIndex willModify];
          v12[268] = v13;
        }
        else
        {
          ++v7;
          *(_WORD *)(a1 + 52) -= ValueAtIndex[269];
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 56), (unsigned __int16)(v8 - v6));
        }
      }
      ++v6;
    }
    while (v6 <= v8);
    *(_WORD *)(a1 + 64) -= v7;
    if (*(_WORD *)(a1 + 64))
    {
      *(_WORD *)(a1 + 50) = 0;
      long long v28 = 0u;
      long long v29 = 0u;
      long long v30 = 0u;
      long long v31 = 0u;
      int v14 = *(void **)(a1 + 56);
      uint64_t v15 = [v14 countByEnumeratingWithState:&v28 objects:v32 count:16];
      if (v15)
      {
        uint64_t v16 = v15;
        uint64_t v17 = *(void *)v29;
        do
        {
          for (uint64_t i = 0; i != v16; ++i)
          {
            if (*(void *)v29 != v17) {
              objc_enumerationMutation(v14);
            }
            unsigned int v19 = *(unsigned __int16 *)(*(void *)(*((void *)&v28 + 1) + 8 * i) + 536);
            if (v19 > *(unsigned __int16 *)(a1 + 50)) {
              *(_WORD *)(a1 + 50) = v19;
            }
          }
          uint64_t v16 = [v14 countByEnumeratingWithState:&v28 objects:v32 count:16];
        }
        while (v16);
      }
      *(unsigned char *)(a1 + 48) = 0;
      long long v28 = 0u;
      long long v29 = 0u;
      long long v30 = 0u;
      long long v31 = 0u;
      uint64_t v20 = *(void **)(a1 + 56);
      uint64_t v21 = [v20 countByEnumeratingWithState:&v28 objects:v32 count:16];
      if (v21)
      {
        uint64_t v22 = v21;
        uint64_t v23 = *(void *)v29;
        do
        {
          for (uint64_t j = 0; j != v22; ++j)
          {
            if (*(void *)v29 != v23) {
              objc_enumerationMutation(v20);
            }
            uint64_t v25 = *(void *)(*((void *)&v28 + 1) + 8 * j);
            if (*(_WORD *)(v25 + 538))
            {
              if (!*(unsigned char *)(v25 + 541)) {
                TSTTableTileRowInfoRecalculateMaxTileColumnIndex(*(void *)(*((void *)&v28 + 1) + 8 * j));
              }
              unsigned int v26 = *(unsigned __int8 *)(v25 + 540);
              if (v26 != 255 && v26 > *(unsigned __int8 *)(a1 + 48)) {
                *(unsigned char *)(a1 + 48) = v26;
              }
            }
          }
          uint64_t v22 = [v20 countByEnumeratingWithState:&v28 objects:v32 count:16];
        }
        while (v22);
      }
    }
    else
    {
      *(_WORD *)(a1 + 50) = 0;
      *(unsigned char *)(a1 + 48) = 0;
    }
  }
}

void TSTTableTileYankRows(uint64_t a1, unsigned int a2, int a3, void *a4)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  [(id)a1 willModify];
  if (*(_WORD *)(a1 + 64))
  {
    unsigned __int16 v7 = 0;
    __int16 v8 = 0;
    unsigned __int16 v9 = *(_WORD *)(a1 + 64) - 1;
    do
    {
      ValueAtIndedouble x = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), (unsigned __int16)(v9 - v7));
      unsigned int v11 = (unsigned __int16)ValueAtIndex[268];
      if (v11 >= a2 && a3 + a2 > v11)
      {
        ++v8;
        *(_WORD *)(a1 + 52) -= ValueAtIndex[269];
        [a4 insertObject:ValueAtIndex atIndex:0];
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 56), (unsigned __int16)(v9 - v7));
      }
      ++v7;
    }
    while (v7 <= v9);
    *(_WORD *)(a1 + 64) -= v8;
    if (*(_WORD *)(a1 + 64))
    {
      *(_WORD *)(a1 + 50) = 0;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v29 = 0u;
      long long v30 = 0u;
      unsigned __int16 v13 = *(void **)(a1 + 56);
      uint64_t v14 = [v13 countByEnumeratingWithState:&v27 objects:v31 count:16];
      if (v14)
      {
        uint64_t v15 = v14;
        uint64_t v16 = *(void *)v28;
        do
        {
          for (uint64_t i = 0; i != v15; ++i)
          {
            if (*(void *)v28 != v16) {
              objc_enumerationMutation(v13);
            }
            unsigned int v18 = *(unsigned __int16 *)(*(void *)(*((void *)&v27 + 1) + 8 * i) + 536);
            if (v18 > *(unsigned __int16 *)(a1 + 50)) {
              *(_WORD *)(a1 + 50) = v18;
            }
          }
          uint64_t v15 = [v13 countByEnumeratingWithState:&v27 objects:v31 count:16];
        }
        while (v15);
      }
      *(unsigned char *)(a1 + 48) = 0;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v29 = 0u;
      long long v30 = 0u;
      unsigned int v19 = *(void **)(a1 + 56);
      uint64_t v20 = [v19 countByEnumeratingWithState:&v27 objects:v31 count:16];
      if (v20)
      {
        uint64_t v21 = v20;
        uint64_t v22 = *(void *)v28;
        do
        {
          for (uint64_t j = 0; j != v21; ++j)
          {
            if (*(void *)v28 != v22) {
              objc_enumerationMutation(v19);
            }
            uint64_t v24 = *(void *)(*((void *)&v27 + 1) + 8 * j);
            if (*(_WORD *)(v24 + 538))
            {
              if (!*(unsigned char *)(v24 + 541)) {
                TSTTableTileRowInfoRecalculateMaxTileColumnIndex(*(void *)(*((void *)&v27 + 1) + 8 * j));
              }
              unsigned int v25 = *(unsigned __int8 *)(v24 + 540);
              if (v25 != 255 && v25 > *(unsigned __int8 *)(a1 + 48)) {
                *(unsigned char *)(a1 + 48) = v25;
              }
            }
          }
          uint64_t v21 = [v19 countByEnumeratingWithState:&v27 objects:v31 count:16];
        }
        while (v21);
      }
    }
    else
    {
      *(_WORD *)(a1 + 50) = 0;
      *(unsigned char *)(a1 + 48) = 0;
    }
  }
}

unsigned __int8 *TSTTableTileYankRow(uint64_t a1, unsigned int a2)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  [(id)a1 willModify];
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  int v4 = *(void **)(a1 + 56);
  uint64_t v5 = [v4 countByEnumeratingWithState:&v27 objects:v35 count:16];
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)v28;
    while (2)
    {
      for (uint64_t i = 0; i != v6; ++i)
      {
        if (*(void *)v28 != v7) {
          objc_enumerationMutation(v4);
        }
        unsigned __int16 v9 = *(unsigned __int16 **)(*((void *)&v27 + 1) + 8 * i);
        if (v9[268] == a2)
        {
          *(_WORD *)(a1 + 52) -= v9[269];
          uint64_t v10 = v9;
          [*(id *)(a1 + 56) removeObject:v9];
          --*(_WORD *)(a1 + 64);
          if (v10)
          {
            if (*(unsigned __int16 *)(a1 + 50) <= a2)
            {
              unsigned int v11 = v10;
              *(_WORD *)(a1 + 50) = 0;
              long long v31 = 0u;
              long long v32 = 0u;
              long long v33 = 0u;
              long long v34 = 0u;
              uint64_t v12 = *(void **)(a1 + 56);
              uint64_t v13 = [v12 countByEnumeratingWithState:&v31 objects:v36 count:16];
              if (v13)
              {
                uint64_t v14 = v13;
                uint64_t v15 = *(void *)v32;
                do
                {
                  for (uint64_t j = 0; j != v14; ++j)
                  {
                    if (*(void *)v32 != v15) {
                      objc_enumerationMutation(v12);
                    }
                    unsigned int v17 = *(unsigned __int16 *)(*(void *)(*((void *)&v31 + 1) + 8 * j) + 536);
                    if (v17 > *(unsigned __int16 *)(a1 + 50)) {
                      *(_WORD *)(a1 + 50) = v17;
                    }
                  }
                  uint64_t v14 = [v12 countByEnumeratingWithState:&v31 objects:v36 count:16];
                }
                while (v14);
              }
              uint64_t v10 = v11;
            }
            if (!v10[541]) {
              TSTTableTileRowInfoRecalculateMaxTileColumnIndex((uint64_t)v10);
            }
            if (v10[540] >= *(unsigned __int8 *)(a1 + 48))
            {
              unsigned int v26 = v10;
              *(unsigned char *)(a1 + 48) = 0;
              long long v31 = 0u;
              long long v32 = 0u;
              long long v33 = 0u;
              long long v34 = 0u;
              unsigned int v18 = *(void **)(a1 + 56);
              uint64_t v19 = [v18 countByEnumeratingWithState:&v31 objects:v36 count:16];
              if (v19)
              {
                uint64_t v20 = v19;
                uint64_t v21 = *(void *)v32;
                do
                {
                  for (uint64_t k = 0; k != v20; ++k)
                  {
                    if (*(void *)v32 != v21) {
                      objc_enumerationMutation(v18);
                    }
                    uint64_t v23 = *(void *)(*((void *)&v31 + 1) + 8 * k);
                    if (*(_WORD *)(v23 + 538))
                    {
                      if (!*(unsigned char *)(v23 + 541)) {
                        TSTTableTileRowInfoRecalculateMaxTileColumnIndex(*(void *)(*((void *)&v31 + 1) + 8 * k));
                      }
                      unsigned int v24 = *(unsigned __int8 *)(v23 + 540);
                      if (v24 != 255 && v24 > *(unsigned __int8 *)(a1 + 48)) {
                        *(unsigned char *)(a1 + 48) = v24;
                      }
                    }
                  }
                  uint64_t v20 = [v18 countByEnumeratingWithState:&v31 objects:v36 count:16];
                }
                while (v20);
              }
              uint64_t v10 = v26;
            }
          }
          return v10;
        }
      }
      uint64_t v6 = [v4 countByEnumeratingWithState:&v27 objects:v35 count:16];
      if (v6) {
        continue;
      }
      break;
    }
  }
  uint64_t v10 = 0;
  return v10;
}

uint64_t TSTTableTileSpliceRow(TSTTableTile *a1, unsigned int a2, TSTTableTileRowInfo *a3)
{
  if (!a3)
  {
    uint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableTileSpliceRow(TSTTableTile *, TSURowIndex, TSTTableTileRowInfo *)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 703, @"Can't splice in a nil row!");
  }
  if ((TSTTableTile *)[(TSPContainedObject *)a3 owner] != a1)
  {
    __int16 v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableTileSpliceRow(TSTTableTile *, TSURowIndex, TSTTableTileRowInfo *)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 704, @"Tile doesn't own that row!");
  }
  [(TSPObject *)a1 willModify];

  return p_InsertRowInfoWithRowIndex(a1, a3, a2);
}

uint64_t p_InsertRowInfoWithRowIndex(TSTTableTile *a1, TSTTableTileRowInfo *a2, unsigned int a3)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  if ((TSTTableTile *)[(TSPContainedObject *)a2 owner] != a1)
  {
    uint64_t v5 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v6 = objc_msgSend(NSString, "stringWithUTF8String:", "void p_InsertRowInfoWithRowIndex(TSTTableTile *, TSTTableTileRowInfo *, TSURowIndex)");
    objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 253, @"Tile doesn't own that row!");
  }
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  uint64_t v23 = a1;
  mRowInfos = a1->mRowInfos;
  uint64_t v8 = [(NSMutableArray *)mRowInfos countByEnumeratingWithState:&v24 objects:v28 count:16];
  if (v8)
  {
    uint64_t v9 = v8;
    uint64_t v10 = *(void *)v25;
    uint64_t v11 = 0;
    while (2)
    {
      uint64_t v12 = 0;
      uint64_t v21 = v11;
      uint64_t v20 = v11 + v9;
      do
      {
        if (*(void *)v25 != v10) {
          objc_enumerationMutation(mRowInfos);
        }
        unsigned int v13 = *(unsigned __int16 *)(*(void *)(*((void *)&v24 + 1) + 8 * v12) + 536);
        if (v13 > a3)
        {
          uint64_t v16 = v21 + v12;
          goto LABEL_16;
        }
        if (v13 == a3)
        {
          uint64_t v14 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v15 = objc_msgSend(NSString, "stringWithUTF8String:", "void p_InsertRowInfoWithRowIndex(TSTTableTile *, TSTTableTileRowInfo *, TSURowIndex)");
          objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", v15, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 263, @"Duplicate row indices!");
        }
        ++v12;
      }
      while (v9 != v12);
      uint64_t v9 = [(NSMutableArray *)mRowInfos countByEnumeratingWithState:&v24 objects:v28 count:16];
      uint64_t v16 = v20;
      uint64_t v11 = v20;
      if (v9) {
        continue;
      }
      break;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
LABEL_16:
  [(TSPObject *)v23 willModify];
  uint64_t result = [(NSMutableArray *)v23->mRowInfos insertObject:a2 atIndex:v16];
  ++v23->mNumRows;
  v23->mNumCells += a2->mCellCount;
  if (v23->mMaxRow < a3) {
    v23->mMaxRow = a3;
  }
  if (!a2->mMaxTileColumnIndexValid) {
    uint64_t result = TSTTableTileRowInfoRecalculateMaxTileColumnIndex((uint64_t)a2);
  }
  mMaxTileColumnIndedouble x = a2->mMaxTileColumnIndex;
  if (mMaxTileColumnIndex != 255)
  {
    unsigned int mMaxColumn = v23->mMaxColumn;
    if (mMaxColumn == 255 || mMaxTileColumnIndex > mMaxColumn) {
      v23->unsigned int mMaxColumn = mMaxTileColumnIndex;
    }
  }
  return result;
}

BOOL TSTTableTileShouldSplitRows(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 64) > 0x1Fu;
}

BOOL TSTTableTileShouldMergeRows(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 64) < 4u;
}

BOOL TSTTableTilesShouldMergeRowsTogether(uint64_t a1, uint64_t a2)
{
  return *(unsigned __int16 *)(a2 + 64) + *(unsigned __int16 *)(a1 + 64) < 0x1D;
}

uint64_t TSTTableTileFindMidpointForRowSplit(uint64_t a1)
{
  if (*(unsigned __int16 *)(a1 + 64) <= 1u)
  {
    unsigned int v2 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v3 = [NSString stringWithUTF8String:"TSURowIndex TSTTableTileFindMidpointForRowSplit(TSTTableTile *)"];
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 747, @"Can't split a tile with out more than one row!");
  }
  unsigned int v4 = *(unsigned __int16 *)([*(id *)(a1 + 56) objectAtIndex:0] + 536);
  unsigned int v5 = *(unsigned __int16 *)(a1 + 64);
  int v6 = 1;
  if (v5 >= 2)
  {
    while (1)
    {
      ValueAtIndedouble x = (unsigned __int16 *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), (unsigned __int16)v6);
      unsigned int v8 = ValueAtIndex[268];
      if (v4 + 1 != v8) {
        break;
      }
      ++v6;
      unsigned int v5 = *(unsigned __int16 *)(a1 + 64);
      unsigned int v4 = ValueAtIndex[268];
      if (v5 <= (unsigned __int16)v6)
      {
        unsigned int v4 = ValueAtIndex[268];
        goto LABEL_10;
      }
    }
    if (v8 <= v4)
    {
      uint64_t v9 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v10 = [NSString stringWithUTF8String:"TSURowIndex TSTTableTileFindMidpointForRowSplit(TSTTableTile *)"];
      objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 768, @"Row indexes out of order in split!");
    }
    unsigned int v5 = *(unsigned __int16 *)(a1 + 64);
  }
LABEL_10:
  if ((unsigned __int16)v6 >= v5 >> 1)
  {
    LOWORD(v12) = v4;
  }
  else
  {
    unsigned __int16 v11 = v6;
    do
    {
      unsigned int v12 = *((unsigned __int16 *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), v11) + 268);
      if (v12 <= v4)
      {
        unsigned int v13 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v14 = [NSString stringWithUTF8String:"TSURowIndex TSTTableTileFindMidpointForRowSplit(TSTTableTile *)"];
        objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 779, @"Row indexes out of order in split!");
      }
      ++v6;
      ++v11;
      unsigned int v4 = v12;
    }
    while ((unsigned __int16)v6 < (*(unsigned __int16 *)(a1 + 64) >> 1));
  }
  return (unsigned __int16)v12;
}

TSTTableTile *TSTTableTileSplitRows(TSTTableTile *a1, unsigned int a2)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  [(TSPObject *)a1 willModify];
  unsigned int v4 = [[TSTTableTile alloc] initWithContext:[(TSPObject *)a1 context]];
  if (a1->mMaxRow <= a2) {
    id v5 = objc_alloc_init(MEMORY[0x263EFF980]);
  }
  else {
    id v5 = (id)[objc_alloc(MEMORY[0x263EFF980]) initWithCapacity:a1->mMaxRow - (unint64_t)a2];
  }
  int v6 = v5;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  mRowInfos = a1->mRowInfos;
  uint64_t v8 = [(NSMutableArray *)mRowInfos countByEnumeratingWithState:&v23 objects:v28 count:16];
  if (v8)
  {
    uint64_t v9 = v8;
    uint64_t v10 = *(void *)v24;
    do
    {
      for (uint64_t i = 0; i != v9; ++i)
      {
        if (*(void *)v24 != v10) {
          objc_enumerationMutation(mRowInfos);
        }
        if (*(unsigned __int16 *)(*(void *)(*((void *)&v23 + 1) + 8 * i) + 536) >= a2) {
          objc_msgSend(v6, "addObject:");
        }
      }
      uint64_t v9 = [(NSMutableArray *)mRowInfos countByEnumeratingWithState:&v23 objects:v28 count:16];
    }
    while (v9);
  }
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  uint64_t v12 = [v6 countByEnumeratingWithState:&v19 objects:v27 count:16];
  if (v12)
  {
    uint64_t v13 = v12;
    uint64_t v14 = *(void *)v20;
    do
    {
      for (uint64_t j = 0; j != v13; ++j)
      {
        if (*(void *)v20 != v14) {
          objc_enumerationMutation(v6);
        }
        uint64_t v16 = *(TSTTableTileRowInfo **)(*((void *)&v19 + 1) + 8 * j);
        unsigned __int16 v17 = v16->mTileRowIndex - a2;
        p_RemoveRowInfo(a1, v16);
        [(TSPContainedObject *)v16 setOwner:v4];
        [(TSPContainedObject *)v16 willModify];
        v16->mTileRowIndedouble x = v17;
        p_InsertRowInfoWithRowIndex(v4, v16, v17);
      }
      uint64_t v13 = [v6 countByEnumeratingWithState:&v19 objects:v27 count:16];
    }
    while (v13);
  }

  return v4;
}

uint64_t TSTTableTileMergeRows(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  [(id)a1 willModify];
  [(id)a2 willModify];
  if (*(unsigned __int16 *)(a1 + 50) >= a3)
  {
    int v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableTileMergeRows(TSTTableTile *, TSTTableTile *, TSURowIndex)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 841, @"Overlapping tiles in tile merge!");
  }
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  uint64_t v8 = *(void **)(a2 + 56);
  uint64_t v9 = [v8 countByEnumeratingWithState:&v26 objects:v31 count:16];
  if (v9)
  {
    uint64_t v10 = v9;
    uint64_t v11 = *(void *)v27;
    do
    {
      for (uint64_t i = 0; i != v10; ++i)
      {
        if (*(void *)v27 != v11) {
          objc_enumerationMutation(v8);
        }
        uint64_t v13 = *(_WORD **)(*((void *)&v26 + 1) + 8 * i);
        __int16 v14 = v13[268] + a3;
        [v13 willModify];
        v13[268] = v14;
      }
      uint64_t v10 = [v8 countByEnumeratingWithState:&v26 objects:v31 count:16];
    }
    while (v10);
  }
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  uint64_t v15 = *(void **)(a2 + 56);
  uint64_t v16 = [v15 countByEnumeratingWithState:&v22 objects:v30 count:16];
  if (v16)
  {
    uint64_t v17 = v16;
    uint64_t v18 = *(void *)v23;
    do
    {
      for (uint64_t j = 0; j != v17; ++j)
      {
        if (*(void *)v23 != v18) {
          objc_enumerationMutation(v15);
        }
        [*(id *)(*((void *)&v22 + 1) + 8 * j) setOwner:a1];
      }
      uint64_t v17 = [v15 countByEnumeratingWithState:&v22 objects:v30 count:16];
    }
    while (v17);
  }
  [*(id *)(a1 + 56) addObjectsFromArray:*(void *)(a2 + 56)];
  unsigned int v20 = *(unsigned __int8 *)(a1 + 48);
  if (v20 <= *(unsigned __int8 *)(a2 + 48)) {
    LOBYTE(v20) = *(unsigned char *)(a2 + 48);
  }
  *(unsigned char *)(a1 + 48) = v20;
  *(_WORD *)(a1 + 50) = *(_WORD *)(a2 + 50) + a3;
  *(_WORD *)(a1 + 52) += *(_WORD *)(a2 + 52);
  *(_WORD *)(a1 + 64) = [*(id *)(a1 + 56) count];
  uint64_t result = [*(id *)(a2 + 56) removeAllObjects];
  *(unsigned char *)(a2 + 48) = 0;
  *(_WORD *)(a2 + 50) = 0;
  *(_WORD *)(a2 + 52) = 0;
  *(_WORD *)(a2 + 64) = 0;
  return result;
}

uint64_t TSTTableSetDefaultRowHeight(double *a1, double a2)
{
  uint64_t result = [a1 willModify];
  a1[12] = a2;
  return result;
}

double TSTTableDefaultRowHeight(uint64_t a1)
{
  if (a1) {
    return *(double *)(a1 + 96);
  }
  else {
    return 10.0;
  }
}

uint64_t TSTTableSetDefaultColumnWidth(double *a1, double a2)
{
  uint64_t result = [a1 willModify];
  a1[13] = a2;
  return result;
}

double TSTTableDefaultColumnWidth(uint64_t a1)
{
  if (a1) {
    return *(double *)(a1 + 104);
  }
  else {
    return 0.0;
  }
}

id TSTTableMergeRangesForCellRegion(uint64_t a1, void *a2)
{
  if (a1) {
    uint64_t v3 = *(void *)(a1 + 48);
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = [a2 boundingCellRange];
  id v5 = TSTTableDataStoreMergeRangesForCellRange(v3, v4);
  id v6 = TSTTableDataStoreMergeRangesForCellRange(v3, v4);
  if (v6)
  {
    uint64_t v7 = (void *)[v5 iterator];
    if ([v7 hasNextMergeRegion])
    {
      do
      {
        uint64_t v8 = [v7 nextMergeRegion];
        if (([a2 intersectsCellRange:v8] & 1) == 0) {
          [v6 remove:v8];
        }
      }
      while (([v7 hasNextMergeRegion] & 1) != 0);
    }
  }
  return v6;
}

uint64_t TSTTableMerge(uint64_t a1, uint64_t a2)
{
  return TSTTableDataStoreMerge(*(void **)(a1 + 48), a2);
}

BOOL TSTTableCellIDIsLegal(uint64_t a1, int a2)
{
  return *(unsigned __int16 *)(a1 + 72) > (unsigned __int16)a2
      && *(unsigned __int16 *)(a1 + 74) > BYTE2(a2);
}

id TSTSetDefaultCellForTableArea(id *a1, int a2, void *a3)
{
  switch(a2)
  {
    case 0:

      id result = a3;
      *a1 = result;
      break;
    case 1:
    case 4:

      id result = a3;
      a1[1] = result;
      break;
    case 2:

      id result = a3;
      a1[2] = result;
      break;
    case 3:
    case 5:

      id result = a3;
      a1[3] = result;
      break;
    default:
      id v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTSetDefaultCellForTableArea(TSTDefaultCellBlock *, TSTTableArea, TSTCell *)");
      uint64_t v8 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"];
      id result = (id)[v6 handleFailureInFunction:v7 file:v8 lineNumber:1651 description:@"illegal table region"];
      break;
  }
  return result;
}

uint64_t TSTTableDefaultCellForCellID(unsigned __int16 *a1, int a2, uint64_t a3)
{
  if ((unsigned __int16)a2 >= a1[36] || BYTE2(a2) >= a1[37]) {
    return 3;
  }
  TSTCellCopy(objc_msgSend(a1, "defaultCellForTableArea:", objc_msgSend(a1, "tableAreaForCellID:", a2 & 0xFF000000 | (BYTE2(a2) << 16) | (unsigned __int16)a2)), a3);
  return 0;
}

BOOL TSTCellExistsAtCellID(uint64_t a1, int a2)
{
  return (unsigned __int16)a2 < *(unsigned __int16 *)(a1 + 72)
      && BYTE2(a2) < *(unsigned __int16 *)(a1 + 74)
      && TSTTableDataStoreCellExistsAtCellID(*(void *)(a1 + 48), a2 & 0xFF000000 | (BYTE2(a2) << 16) | (unsigned __int16)a2);
}

uint64_t TSTCellAtCellIDSuppressingFormula(uint64_t a1, int a2, void *a3, uint64_t a4)
{
  if ((unsigned __int16)a2 >= *(unsigned __int16 *)(a1 + 72)
    || BYTE2(a2) >= *(unsigned __int16 *)(a1 + 74))
  {
    return 3;
  }
  uint64_t v7 = TSTTableDataStoreCellStorageRefAtCellID(*(void *)(a1 + 48), a2 & 0xFF000000 | (BYTE2(a2) << 16) | (unsigned __int16)a2);
  if (!v7) {
    return 1000;
  }
  [a3 inflateFromStorageRef:v7 dataStore:*(void *)(a1 + 48) suppressingFormulaInflation:a4];
  return 0;
}

uint64_t TSTCellAtCellID(uint64_t a1, int a2, void *a3)
{
  return TSTCellAtCellIDSuppressingFormula(a1, a2, a3, 0);
}

uint64_t TSTTablePreflightSetCellAtCellID(uint64_t a1, uint64_t a2, int a3)
{
  int v4 = (unsigned __int16)a3;
  if ((unsigned __int16)a3 < *(unsigned __int16 *)(a1 + 72))
  {
    int v6 = BYTE2(a3);
    if (BYTE2(a3) < *(unsigned __int16 *)(a1 + 74))
    {
      unint64_t v8 = [(id)a1 range];
      unsigned int v9 = WORD2(v8) * HIWORD(v8);
      unsigned int v10 = objc_msgSend(+[TSTConfiguration sharedTableConfiguration](TSTConfiguration, "sharedTableConfiguration"), "maxNumberOfPopulatedCells");
      if (v9 < v10
        || (unsigned int v12 = v10,
            BOOL v13 = TSTTableDataStoreCellExistsAtCellID(*(void *)(a1 + 48), a3 & 0xFF000000 | (v6 << 16) | v4),
            !a2)
        || v13)
      {
        if (!a2) {
          return 0;
        }
      }
      else if (TSTTableDataStoreNumberOfPopulatedCells(*(void *)(a1 + 48)) >= v12)
      {
        return 1001;
      }
      uint64_t result = 0;
      int v14 = *(_DWORD *)(a2 + 104);
      switch(BYTE1(*(_DWORD *)(a2 + 8)))
      {
        case 2u:
          if (v14 & 0xFFFFFFFC) == 0x100 || (v14 - 262) < 9 && ((0x1BFu >> (v14 - 6))) {
            return 0;
          }
          BOOL v15 = (v14 - 268) >= 0xFFFFFFFB || (v14 & 0xFFFFFFF7) == 262;
          goto LABEL_33;
        case 3u:
        case 9u:
          uint64_t result = 0;
          if (v14 > 259)
          {
            if (v14 == 260 || v14 == 271) {
              return result;
            }
          }
          else if ((v14 + 1) < 3 || v14 == -999)
          {
            return result;
          }
          BOOL v16 = 0;
          switch(BYTE1(*(_DWORD *)(a2 + 8)))
          {
            case 3u:
            case 9u:
              BOOL v16 = v14 != 271;
              break;
            case 5u:
              goto LABEL_25;
            case 6u:
              goto LABEL_30;
            case 7u:
              goto LABEL_32;
            default:
              break;
          }
LABEL_36:
          NSLog((NSString *)@"%d", v16);
          uint64_t v17 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v18 = objc_msgSend(NSString, "stringWithUTF8String:", "TSUError TSTTablePreflightSetCellAtCellID(TSTTableModel *, TSTCell *, TSTCellID)");
          objc_msgSend(v17, "handleFailureInFunction:file:lineNumber:description:", v18, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 1782, @"Attempting to add invalid cell to the model");
          break;
        case 5u:
          uint64_t result = 0;
          if (v14 == 261 || v14 == 272) {
            return result;
          }
LABEL_25:
          BOOL v15 = v14 == 261 || v14 == 272;
          goto LABEL_33;
        case 6u:
          uint64_t result = 0;
          if (v14 == 1 || v14 == 263) {
            return result;
          }
LABEL_30:
          BOOL v15 = v14 == 263;
LABEL_33:
          BOOL v16 = !v15;
          goto LABEL_36;
        case 7u:
          if (v14 == 268) {
            return 0;
          }
LABEL_32:
          BOOL v15 = v14 == 268;
          goto LABEL_33;
        default:
          return result;
      }
      return 0;
    }
  }
  return 3;
}

uint64_t TSTTableSetCellAtCellID(uint64_t a1, void *a2, unsigned int a3)
{
  return TSTTableSetCellAtCellIDIgnoringFormula(a1, a2, a3);
}

uint64_t TSTTableSetCellAtCellIDIgnoringFormula(uint64_t a1, void *a2, unsigned int a3)
{
  unint64_t v5 = a3;
  uint64_t v6 = TSTTablePreflightSetCellAtCellID(a1, (uint64_t)a2, a3);
  if (!v6) {
    TSTTableDataStoreSetCellAtCellID(*(void **)(a1 + 48), a2, v5);
  }
  return v6;
}

uint64_t TSTTablePreflightSetCellsWithCellMap(uint64_t a1, void *a2)
{
  unint64_t v4 = [a2 count];
  unsigned int v5 = TSTTableDataStoreNumberOfPopulatedCells(*(void *)(a1 + 48));
  unsigned int v6 = objc_msgSend(+[TSTConfiguration sharedTableConfiguration](TSTConfiguration, "sharedTableConfiguration"), "maxNumberOfPopulatedCells");
  if (v4 + v5 < v6 || v4 == 0) {
    return 0;
  }
  unsigned int v8 = v6;
  uint64_t v9 = 0;
  for (unint64_t i = v4 - 1; ; --i)
  {
    unsigned int v11 = [a2 cellIDAtIndex:v9];
    uint64_t v12 = [a2 cellAtIndex:v9];
    unint64_t v4 = v4 & 0xFFFFFFFF00000000 | v11;
    v5 += (v12 != 0) & ~TSTTableDataStoreCellExistsAtCellID(*(void *)(a1 + 48), v4);
    if (v8 < v5) {
      break;
    }
    ++v9;
    if (i < v8 - v5 || i == 0) {
      return 0;
    }
  }
  return 1001;
}

uint64_t TSTTableSetCellsWithCellMap(uint64_t a1, void *a2)
{
  return TSTTableSetCellsWithCellMapIgnoringFormulas(a1, a2);
}

uint64_t TSTTableSetCellsWithCellMapIgnoringFormulas(uint64_t a1, void *a2)
{
  uint64_t v4 = TSTTablePreflightSetCellsWithCellMap(a1, a2);
  if (!v4) {
    TSTTableDataStoreSetCellsWithCellMap(*(void **)(a1 + 48), a2);
  }
  return v4;
}

uint64_t TSTCellAtCellIDHoldingReadLock(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  uint64_t v6 = a1;
  int v7 = a2;
  uint64_t v8 = a3;
  unsigned int v5 = 1;
  [a4 performRead:sel_p_fetchCellHoldingReadLock_returnCode_ withTarget:a1 argument:&v6 argument2:&v5];
  return v5;
}

void TSTTableGetFormatAtCellIDForFormulaReference(uint64_t a1@<X0>, int a2@<W1>, BOOL *a3@<X2>, void *a4@<X3>, uint64_t a5@<X8>)
{
  if ((unsigned __int16)a2 >= *(unsigned __int16 *)(a1 + 72)
    || BYTE2(a2) >= *(unsigned __int16 *)(a1 + 74))
  {
    *(void *)(a5 + 32) = 0;
    *(_OWORD *)a5 = TSUInvalidFormat;
    *(_OWORD *)(a5 + 16) = unk_22383BCD0;
    return;
  }
  unsigned int v9 = a2 & 0xFF000000 | (BYTE2(a2) << 16) | (unsigned __int16)a2;
  unsigned int v10 = (char *)TSTCellDictionaryCellAtCellID(*(void *)(a1 + 280), v9);
  if (v10)
  {
    if (a3) {
      *a3 = (*((_WORD *)v10 + 48) & 0x8010) == 0;
    }
    uint64_t v11 = *((void *)v10 + 17);
    long long v12 = *(_OWORD *)(v10 + 120);
    *(_OWORD *)a5 = *(_OWORD *)(v10 + 104);
    *(_OWORD *)(a5 + 16) = v12;
    *(void *)(a5 + 32) = v11;
    int v13 = *(_DWORD *)a5;
    if ((*(_DWORD *)a5 & 0xFFFFFFFE) != 0x108) {
      goto LABEL_13;
    }
    TSTCellGetFormatOfType(v10, *(_DWORD *)(a5 + 32), a5);
    goto LABEL_12;
  }
  TSTTableDataStoreGetFormatAtCellID(*(void *)(a1 + 48), v9, a3, 0, (uint64_t)&v16);
  long long v14 = v17;
  *(_OWORD *)a5 = v16;
  *(_OWORD *)(a5 + 16) = v14;
  *(void *)(a5 + 32) = v18;
  int v13 = *(_DWORD *)a5;
  if ((*(_DWORD *)a5 & 0xFFFFFFFE) == 0x108)
  {
    TSTTableDataStoreGetFormatForFormatTypeAtCellID(*(void *)(a1 + 48), v9, *(_DWORD *)(a5 + 32), 0, (uint64_t)&v16);
    long long v15 = v17;
    *(_OWORD *)a5 = v16;
    *(_OWORD *)(a5 + 16) = v15;
    *(void *)(a5 + 32) = v18;
LABEL_12:
    int v13 = *(_DWORD *)a5;
  }
LABEL_13:
  if (a4)
  {
    if (v13 == 270)
    {
      *a4 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)a1, "documentRoot"), "customFormatList"), "customFormatForKey:", *(unsigned int *)(a5 + 8));
      int v13 = *(_DWORD *)a5;
    }
    else
    {
      *a4 = 0;
    }
  }
  if ((v13 - 270) <= 2) {
    TSTTableDataStorePopulateCustomFormat(*(void **)(a1 + 48), a5, 0.0);
  }
}

uint64_t TSTTableNumberOfComments(void *a1)
{
  uint64_t v1 = objc_msgSend(*(id *)(objc_msgSend(a1, "dataStore") + 120), "object");

  return TSTTableDataListGetCount(v1);
}

UInt8 *TSTTableHasCommentStorageAtCellID(uint64_t a1, int a2)
{
  uint64_t result = TSTTableDataStoreCellStorageRefAtCellID(*(void *)(a1 + 48), a2);
  if (result) {
    return (UInt8 *)((result[5] >> 4) & 1);
  }
  return result;
}

UInt8 *TSTTableGetCommentStorageAtCellID(uint64_t a1, int a2)
{
  uint64_t result = TSTTableDataStoreCellStorageRefAtCellID(*(void *)(a1 + 48), a2);
  if (result)
  {
    uint64_t v4 = result;
    unsigned int v5 = objc_alloc_init(TSTCell);
    [(TSTCell *)v5 inflateFromStorageRef:v4 dataStore:*(void *)(a1 + 48)];
    if (v5) {
      mCommentStorage = v5->mPrivate.mCommentStorage;
    }
    else {
      mCommentStorage = 0;
    }
    int v7 = mCommentStorage;

    return (UInt8 *)v7;
  }
  return result;
}

uint64_t TSTTableSetCommentStorageAtCellID(uint64_t a1, TSDCommentStorage *a2, unsigned int a3)
{
  uint64_t v6 = objc_alloc_init(TSTCell);
  int v7 = TSTTableDataStoreCellStorageRefAtCellID(*(void *)(a1 + 48), a3);
  if (v7) {
    [(TSTCell *)v6 inflateFromStorageRef:v7 dataStore:*(void *)(a1 + 48)];
  }
  else {
    v6->mPrivate.mCommentStorageID = 0;
  }
  TSTCellSetCommentStorageClearingID((TSDCommentStorage *)v6, a2, 1);
  uint64_t v8 = TSTTableSetCellAtCellIDIgnoringFormula(a1, v6, a3);

  return v8;
}

uint64_t TSTTableRemoveCommentStorageAtCellID(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = objc_alloc_init(TSTCell);
  unsigned int v5 = TSTTableDataStoreCellStorageRefAtCellID(*(void *)(a1 + 48), a2);
  if (v5)
  {
    [(TSTCell *)v4 inflateFromStorageRef:v5 dataStore:*(void *)(a1 + 48)];
    mCommentStorage = v4->mPrivate.mCommentStorage;
    if (mCommentStorage)
    {

      v4->mPrivate.mCommentStorage = 0;
    }
    v4->mPrivate.mCommentStorageID = 0;
    uint64_t v7 = TSTTableSetCellAtCellIDIgnoringFormula(a1, v4, a2);
  }
  else
  {
    uint64_t v7 = 2;
  }

  return v7;
}

BOOL TSTTableHeaderInfoForRowIsNilOrEmpty(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = TSTTableDataStoreHeaderInfoForRow(*(void *)(a1 + 48), a2, 0, 0);
  if (!v2) {
    return 1;
  }
  if (*(double *)(v2 + 24) != 0.0 || *(_WORD *)(v2 + 34) || *(void *)(v2 + 8) || *(void *)(v2 + 16)) {
    return 0;
  }
  return *(unsigned char *)(v2 + 32) == 0;
}

BOOL TSTTableHeaderInfoForColumnIsNilOrEmpty(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = TSTTableDataStoreHeaderInfoForColumn(*(void *)(a1 + 48), a2, 0, 0);
  if (!v2) {
    return 1;
  }
  if (*(double *)(v2 + 24) != 0.0 || *(_WORD *)(v2 + 34) || *(void *)(v2 + 8) || *(void *)(v2 + 16)) {
    return 0;
  }
  return *(unsigned char *)(v2 + 32) == 0;
}

uint64_t TSTTableSetCellStyleAtRow(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = TSTTableDataStoreHeaderInfoForRow(*(void *)(a1 + 48), a3, 1, 1);
  if (!v6) {
    return 2;
  }
  uint64_t v7 = v6;
  *(void *)(v6 + 8) = a2;
  if (*(double *)(v7 + 24) == 0.0
    && !*(_WORD *)(v7 + 34)
    && !*(void *)(v7 + 8)
    && !*(void *)(v7 + 16)
    && !*(unsigned char *)(v7 + 32))
  {
    TSTTableDataStoreRemoveRowHeadersAtIndex(*(void *)(a1 + 48), a3, 1);
  }
  return 0;
}

uint64_t TSTTableSetTextStyleAtRow(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = TSTTableDataStoreHeaderInfoForRow(*(void *)(a1 + 48), a3, 1, 1);
  if (!v6) {
    return 2;
  }
  uint64_t v7 = v6;
  *(void *)(v6 + 16) = a2;
  if (*(double *)(v7 + 24) == 0.0
    && !*(_WORD *)(v7 + 34)
    && !*(void *)(v7 + 8)
    && !*(void *)(v7 + 16)
    && !*(unsigned char *)(v7 + 32))
  {
    TSTTableDataStoreRemoveRowHeadersAtIndex(*(void *)(a1 + 48), a3, 1);
  }
  return 0;
}

uint64_t TSTTableGetCellStyleAtRow(uint64_t *a1, uint64_t a2, unsigned char *a3)
{
  signed int v4 = a2;
  uint64_t v6 = TSTTableDataStoreHeaderInfoForRow(a1[6], a2, 0, 0);
  if (v6 && (uint64_t result = *(void *)(v6 + 8)) != 0)
  {
    *a3 = 0;
  }
  else
  {
    if (a3) {
      *a3 = 1;
    }
    if ([a1 numberOfHeaderRows] <= v4)
    {
      int v8 = [a1 numberOfRows];
      if ((int)(v8 - [a1 numberOfFooterRows]) >= v4)
      {
        return [a1 bodyCellStyle];
      }
      else
      {
        return [a1 footerRowCellStyle];
      }
    }
    else
    {
      return [a1 headerRowCellStyle];
    }
  }
  return result;
}

uint64_t TSTTableGetTextStyleAtRow(uint64_t *a1, uint64_t a2, unsigned char *a3)
{
  signed int v4 = a2;
  uint64_t v6 = TSTTableDataStoreHeaderInfoForRow(a1[6], a2, 0, 0);
  if (v6 && (uint64_t result = *(void *)(v6 + 16)) != 0)
  {
    *a3 = 0;
  }
  else
  {
    if (a3) {
      *a3 = 1;
    }
    if ([a1 numberOfHeaderRows] <= v4)
    {
      int v8 = [a1 numberOfRows];
      if ((int)(v8 - [a1 numberOfFooterRows]) >= v4)
      {
        return [a1 bodyTextStyle];
      }
      else
      {
        return [a1 footerRowTextStyle];
      }
    }
    else
    {
      return [a1 headerRowTextStyle];
    }
  }
  return result;
}

uint64_t TSTTableSetCellStyleAtColumn(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = TSTTableDataStoreHeaderInfoForColumn(*(void *)(a1 + 48), a3, 1, 1);
  if (!v6) {
    return 2;
  }
  uint64_t v7 = v6;
  *(void *)(v6 + 8) = a2;
  if (*(double *)(v7 + 24) == 0.0
    && !*(_WORD *)(v7 + 34)
    && !*(void *)(v7 + 8)
    && !*(void *)(v7 + 16)
    && !*(unsigned char *)(v7 + 32))
  {
    TSTTableDataStoreRemoveColumnHeadersAtIndex(*(void *)(a1 + 48), a3, 1);
  }
  return 0;
}

uint64_t TSTTableSetTextStyleAtColumn(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = TSTTableDataStoreHeaderInfoForColumn(*(void *)(a1 + 48), a3, 1, 1);
  if (!v6) {
    return 2;
  }
  uint64_t v7 = v6;
  *(void *)(v6 + 16) = a2;
  if (*(double *)(v7 + 24) == 0.0
    && !*(_WORD *)(v7 + 34)
    && !*(void *)(v7 + 8)
    && !*(void *)(v7 + 16)
    && !*(unsigned char *)(v7 + 32))
  {
    TSTTableDataStoreRemoveColumnHeadersAtIndex(*(void *)(a1 + 48), a3, 1);
  }
  return 0;
}

uint64_t TSTTableGetCellStyleAtColumn(uint64_t *a1, uint64_t a2, unsigned char *a3)
{
  unsigned int v4 = a2;
  uint64_t v6 = TSTTableDataStoreHeaderInfoForColumn(a1[6], a2, 0, 0);
  if (v6 && *(void *)(v6 + 8))
  {
    *a3 = 0;
    return *(void *)(v6 + 8);
  }
  else
  {
    if (a3) {
      *a3 = 1;
    }
    if ([a1 numberOfHeaderColumns] <= v4)
    {
      return [a1 bodyCellStyle];
    }
    else
    {
      return [a1 headerColumnCellStyle];
    }
  }
}

uint64_t TSTTableGetTextStyleAtColumn(uint64_t *a1, uint64_t a2, unsigned char *a3)
{
  unsigned int v4 = a2;
  uint64_t v6 = TSTTableDataStoreHeaderInfoForColumn(a1[6], a2, 0, 0);
  if (v6 && (uint64_t result = *(void *)(v6 + 16)) != 0)
  {
    *a3 = 0;
  }
  else
  {
    if (a3) {
      *a3 = 1;
    }
    if ([a1 numberOfHeaderColumns] <= v4)
    {
      return [a1 bodyTextStyle];
    }
    else
    {
      return [a1 headerColumnTextStyle];
    }
  }
  return result;
}

uint64_t TSTTableDefaultCellStyleForCellID(void *a1, unsigned int a2)
{
  uint64_t v3 = [a1 tableAreaForCellID:a2];

  return [a1 defaultCellStyleForTableArea:v3];
}

uint64_t TSTTableCellStyleForCellWithEmptyStyleAtCellID(uint64_t *a1, unsigned int a2, char *a3)
{
  __int16 v10 = 0;
  uint64_t CellStyleAtRow = TSTTableGetCellStyleAtRow(a1, (unsigned __int16)a2, (unsigned char *)&v10 + 1);
  uint64_t result = TSTTableGetCellStyleAtColumn(a1, BYTE2(a2), &v10);
  char v8 = v10;
  if (HIBYTE(v10)) {
    BOOL v9 = v10 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9)
  {
    if (!HIBYTE(v10))
    {
      uint64_t result = CellStyleAtRow;
      char v8 = 0;
    }
    if (a3) {
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t result = objc_msgSend(a1, "defaultCellStyleForTableArea:", objc_msgSend(a1, "tableAreaForCellID:", a2));
    if (a3)
    {
      char v8 = 1;
LABEL_12:
      *a3 = v8;
    }
  }
  return result;
}

uint64_t TSTTableDefaultTextStyleForCellID(void *a1, unsigned int a2)
{
  uint64_t v3 = [a1 tableAreaForCellID:a2];

  return [a1 defaultTextStyleForTableArea:v3];
}

uint64_t TSTTableTextStyleForCellWithEmptyStyleAtCellID(uint64_t *a1, unsigned int a2, char *a3)
{
  __int16 v10 = 0;
  uint64_t TextStyleAtRow = TSTTableGetTextStyleAtRow(a1, (unsigned __int16)a2, (unsigned char *)&v10 + 1);
  uint64_t result = TSTTableGetTextStyleAtColumn(a1, BYTE2(a2), &v10);
  char v8 = v10;
  if (HIBYTE(v10)) {
    BOOL v9 = v10 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9)
  {
    if (!HIBYTE(v10))
    {
      uint64_t result = TextStyleAtRow;
      char v8 = 0;
    }
    if (a3) {
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t result = objc_msgSend(a1, "defaultTextStyleForTableArea:", objc_msgSend(a1, "tableAreaForCellID:", a2));
    if (a3)
    {
      char v8 = 1;
LABEL_12:
      *a3 = v8;
    }
  }
  return result;
}

uint64_t TSTCellStyleIsEqualToDefaultCellStyleForCellID(void *a1, void *a2, unsigned int a3)
{
  uint64_t v4 = objc_msgSend(a1, "defaultCellStyleForTableArea:", objc_msgSend(a1, "tableAreaForCellID:", a3));
  if (!v4)
  {
    uint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "BOOL TSTCellStyleIsEqualToDefaultCellStyleForCellID(TSTTableModel *, TSTCellStyle *, TSTCellID)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2378, @"null cell style");
    if (a2) {
      goto LABEL_3;
    }
LABEL_7:
    char v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "BOOL TSTCellStyleIsEqualToDefaultCellStyleForCellID(TSTTableModel *, TSTCellStyle *, TSTCellID)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2383, @"null style");
    return 0;
  }
  if (!a2) {
    goto LABEL_7;
  }
LABEL_3:

  return [a2 isEqual:v4];
}

uint64_t TSTCellStyleIsEqualToDefaultTextStyleForCellID(void *a1, void *a2, unsigned int a3)
{
  uint64_t v4 = objc_msgSend(a1, "defaultTextStyleForTableArea:", objc_msgSend(a1, "tableAreaForCellID:", a3));
  if (!v4)
  {
    uint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "BOOL TSTCellStyleIsEqualToDefaultTextStyleForCellID(TSTTableModel *, TSWPParagraphStyle *, TSTCellID)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2392, @"null cell style");
    if (a2) {
      goto LABEL_3;
    }
LABEL_7:
    char v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "BOOL TSTCellStyleIsEqualToDefaultTextStyleForCellID(TSTTableModel *, TSWPParagraphStyle *, TSTCellID)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2397, @"null style");
    return 0;
  }
  if (!a2) {
    goto LABEL_7;
  }
LABEL_3:

  return [a2 isEqual:v4];
}

uint64_t TSTTableSetCellStyleAtCellID(uint64_t a1, TSTCellStyle *a2, unsigned int a3)
{
  uint64_t v6 = objc_alloc_init(TSTCell);
  uint64_t v7 = TSTTableDataStoreCellStorageRefAtCellID(*(void *)(a1 + 48), a3);
  if (v7) {
    [(TSTCell *)v6 inflateFromStorageRef:v7 dataStore:*(void *)(a1 + 48)];
  }
  else {
    v6->mPrivate.mCellStyleID = 0;
  }
  mCellStyle = v6->mPrivate.mCellStyle;
  if (mCellStyle != a2)
  {

    v6->mPrivate.mCellStyle = a2;
    v6->mPrivate.mCellStyleID = 0;
  }
  uint64_t v9 = TSTTableSetCellAtCellIDIgnoringFormula(a1, v6, a3);

  return v9;
}

uint64_t TSTTableSetTextStyleAtCellID(uint64_t a1, TSWPParagraphStyle *a2, unsigned int a3)
{
  uint64_t v6 = objc_alloc_init(TSTCell);
  uint64_t v7 = TSTTableDataStoreCellStorageRefAtCellID(*(void *)(a1 + 48), a3);
  if (v7) {
    [(TSTCell *)v6 inflateFromStorageRef:v7 dataStore:*(void *)(a1 + 48)];
  }
  else {
    v6->mPrivate.mTextStyleID = 0;
  }
  mTextStyle = v6->mPrivate.mTextStyle;
  if (mTextStyle != a2)
  {

    v6->mPrivate.mTextStyle = a2;
    v6->mPrivate.mTextStyleID = 0;
  }
  uint64_t v9 = TSTTableSetCellAtCellIDIgnoringFormula(a1, v6, a3);

  return v9;
}

uint64_t TSTTableGetCellStyleAtCellID(uint64_t *a1, unsigned int a2, char *a3)
{
  uint64_t v10 = 0;
  uint64_t v5 = a2;
  int CellStyleAtCellID = TSTTableDataStoreGetCellStyleAtCellID(a1[6], a2, &v10);
  uint64_t result = v10;
  if (CellStyleAtCellID) {
    BOOL v8 = 1;
  }
  else {
    BOOL v8 = v10 == 0;
  }
  if (v8) {
    return TSTTableCellStyleForCellWithEmptyStyleAtCellID(a1, v5, a3);
  }
  if (a3)
  {
    uint64_t v9 = objc_msgSend(a1, "defaultCellStyleForTableArea:", objc_msgSend(a1, "tableAreaForCellID:", v5));
    *a3 = [v9 isEqual:v10];
    return v10;
  }
  return result;
}

TSWPParagraphStyle *TSTTableGetTextStyleAtCellID(uint64_t *a1, unsigned int a2, char *a3)
{
  uint64_t v10 = 0;
  uint64_t v5 = a2;
  int TextStyleAtCellID = TSTTableDataStoreGetTextStyleAtCellID(a1[6], a2, &v10);
  uint64_t result = v10;
  if (TextStyleAtCellID) {
    BOOL v8 = 1;
  }
  else {
    BOOL v8 = v10 == 0;
  }
  if (v8) {
    return (TSWPParagraphStyle *)TSTTableTextStyleForCellWithEmptyStyleAtCellID(a1, v5, a3);
  }
  if (a3)
  {
    uint64_t v9 = objc_msgSend(a1, "defaultTextStyleForTableArea:", objc_msgSend(a1, "tableAreaForCellID:", v5));
    *a3 = [v9 isEqual:v10];
    return v10;
  }
  return result;
}

uint64_t TSTTableGetConditionalStyleSetAtCellID()
{
  return 0;
}

uint64_t TSTTableNumberOfCells(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 74) * *(unsigned __int16 *)(a1 + 72);
}

uint64_t TSTTableNumberOfPopulatedCells(uint64_t a1)
{
  return TSTTableDataStoreNumberOfPopulatedCells(*(void *)(a1 + 48));
}

uint64_t TSTTableNumberOfPopulatedCellsInRows(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = a3;
  if (!a3)
  {
    uint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "UInt32 TSTTableNumberOfPopulatedCellsInRows(TSTTableModel *, TSURowIndex, TSUColumnRowCount)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2615, @"Invalid count argument in TSTTableNumberPopulatedCellsInColumns");
  }
  unsigned int v8 = *(unsigned __int16 *)(a1 + 72);
  unsigned int v9 = v3 + a2;
  if (v8 <= a2 || v9 > v8)
  {
    uint64_t v11 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v12 = objc_msgSend(NSString, "stringWithUTF8String:", "UInt32 TSTTableNumberOfPopulatedCellsInRows(TSTTableModel *, TSURowIndex, TSUColumnRowCount)");
    objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2616, @"Bounds violation in TSTTableNumberPopulatedCellsInColumns");
  }
  if (v3)
  {
    uint64_t v3 = 0;
    do
    {
      uint64_t v13 = TSTTableDataStoreHeaderInfoForRow(*(void *)(a1 + 48), (unsigned __int16)a2, 0, 0);
      if (v13) {
        uint64_t v3 = v3 + *(unsigned __int16 *)(v13 + 34);
      }
      LOWORD(a2) = a2 + 1;
    }
    while (v9 > (unsigned __int16)a2);
  }
  return v3;
}

uint64_t TSTTableNumberOfPopulatedCellsInColumns(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = a3;
  if (!a3)
  {
    uint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "UInt32 TSTTableNumberOfPopulatedCellsInColumns(TSTTableModel *, TSUColumnIndex, TSUColumnRowCount)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2632, @"Invalid count argument in TSTTableNumberPopulatedCellsInColumns");
  }
  unsigned int v8 = *(unsigned __int16 *)(a1 + 74);
  unsigned int v9 = v3 + a2;
  if (a2 >= v8 || v9 > v8)
  {
    uint64_t v11 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v12 = objc_msgSend(NSString, "stringWithUTF8String:", "UInt32 TSTTableNumberOfPopulatedCellsInColumns(TSTTableModel *, TSUColumnIndex, TSUColumnRowCount)");
    objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2633, @"Bounds violation in TSTTableNumberPopulatedCellsInColumns");
  }
  if (v3)
  {
    uint64_t v3 = 0;
    do
    {
      uint64_t v13 = TSTTableDataStoreHeaderInfoForColumn(*(void *)(a1 + 48), a2, 0, 0);
      if (v13) {
        uint64_t v3 = v3 + *(unsigned __int16 *)(v13 + 34);
      }
      LOBYTE(a2) = a2 + 1;
    }
    while (v9 > a2);
  }
  return v3;
}

uint64_t TSTTableCellLeftOfCell(uint64_t *a1, unint64_t a2)
{
  unint64_t v2 = a2;
  unint64_t v4 = a2 >> 24;
  unint64_t v5 = TSTTableDataStoreMergeRangeAtCellID(a1[6], a2);
  unint64_t v6 = v2;
  if ((_WORD)v5 != 0xFFFF)
  {
    unint64_t v6 = v2;
    if ((v5 & 0xFF0000) != 0xFF0000)
    {
      if ((v5 & 0xFFFF00000000) == 0 || HIWORD(v5) == 0) {
        unint64_t v6 = v2;
      }
      else {
        unint64_t v6 = v5;
      }
    }
  }
  unint64_t v8 = v6 >> 16;
  unsigned __int8 v9 = [a1 range] >> 16;
  while (v8 > v9)
  {
    LOBYTE(v8) = v8 - 1;
    if (!TSTHidingActionForColumn((uint64_t)a1, v8)) {
      return (v8 << 16) | (v4 << 24) | (unsigned __int16)v2;
    }
  }
  LODWORD(v4) = 0;
  LOBYTE(v8) = -1;
  LOWORD(v2) = -1;
  return (v8 << 16) | (v4 << 24) | (unsigned __int16)v2;
}

uint64_t TSTTableMergeRangeAtCellID(uint64_t a1, unsigned int a2)
{
  return TSTTableDataStoreMergeRangeAtCellID(*(void *)(a1 + 48), a2);
}

BOOL TSTTableIsColumnHidden(uint64_t a1, uint64_t a2)
{
  return TSTHidingActionForColumn(a1, a2) != 0;
}

uint64_t TSTTableCellRightOfCell(uint64_t *a1, unint64_t a2)
{
  unsigned __int16 v2 = a2;
  unint64_t v4 = a2 >> 16;
  unint64_t v5 = a2 >> 24;
  unint64_t v6 = TSTTableDataStoreMergeRangeAtCellID(a1[6], a2);
  if ((_WORD)v6 != 0xFFFF && (v6 & 0xFF0000) != 0xFF0000 && HIWORD(v6) != 0 && (v6 & 0xFFFF00000000) != 0) {
    LODWORD(v4) = HIDWORD(v6) + WORD1(v6) + 255;
  }
  uint64_t v9 = [a1 range];
  unsigned int v10 = HIDWORD(v9) + WORD1(v9) + 255;
  while (v4 < v10)
  {
    LOBYTE(v4) = v4 + 1;
    if (!TSTHidingActionForColumn((uint64_t)a1, v4)) {
      return (v4 << 16) | (v5 << 24) | v2;
    }
  }
  LODWORD(v5) = 0;
  LOBYTE(v4) = -1;
  unsigned __int16 v2 = -1;
  return (v4 << 16) | (v5 << 24) | v2;
}

uint64_t TSTTableCellAboveCell(uint64_t *a1, unint64_t a2)
{
  unsigned __int16 v2 = a2;
  unint64_t v4 = a2 >> 16;
  unint64_t v5 = TSTTableDataStoreMergeRangeAtCellID(a1[6], a2);
  if ((_WORD)v5 != 0xFFFF && (v5 & 0xFF0000) != 0xFF0000 && (v5 & 0xFFFF00000000) != 0 && HIWORD(v5) != 0) {
    unsigned __int16 v2 = v5;
  }
  unsigned __int16 v7 = [a1 range];
  while (v2 > v7)
  {
    if (!TSTHidingActionForRow((uint64_t)a1, --v2)) {
      return v2 | ((unsigned __int16)v4 << 16);
    }
  }
  LOWORD(v4) = 255;
  unsigned __int16 v2 = -1;
  return v2 | ((unsigned __int16)v4 << 16);
}

BOOL TSTTableIsRowHidden(uint64_t a1, uint64_t a2)
{
  return TSTHidingActionForRow(a1, a2) != 0;
}

uint64_t TSTTableCellBelowCell(uint64_t *a1, unint64_t a2)
{
  unsigned __int16 v2 = a2;
  unint64_t v4 = a2 >> 16;
  unint64_t v5 = TSTTableDataStoreMergeRangeAtCellID(a1[6], a2);
  if ((_WORD)v5 != 0xFFFF && (v5 & 0xFF0000) != 0xFF0000 && HIWORD(v5) != 0 && (v5 & 0xFFFF00000000) != 0) {
    unsigned __int16 v2 = v5 + HIWORD(v5) - 1;
  }
  unint64_t v8 = [a1 range];
  int v9 = v8 + HIWORD(v8) - 1;
  while (v2 < (unsigned __int16)v9)
  {
    if (!TSTHidingActionForRow((uint64_t)a1, ++v2)) {
      return v2 | ((unsigned __int16)v4 << 16);
    }
  }
  LOWORD(v4) = 255;
  unsigned __int16 v2 = -1;
  return v2 | ((unsigned __int16)v4 << 16);
}

uint64_t TSTTableColumnLeftOfColumn(void *a1, unsigned __int8 a2)
{
  unsigned __int8 v4 = [a1 range] >> 16;
  while (a2 > v4)
  {
    if (!TSTHidingActionForColumn((uint64_t)a1, --a2)) {
      return a2;
    }
  }
  return -1;
}

uint64_t TSTTableColumnRightOfColumn(void *a1, unsigned __int8 a2)
{
  uint64_t v4 = [a1 range];
  unsigned int v5 = HIDWORD(v4) + WORD1(v4) + 255;
  while (a2 < v5)
  {
    if (!TSTHidingActionForColumn((uint64_t)a1, ++a2)) {
      return a2;
    }
  }
  return -1;
}

uint64_t TSTTableRowAboveRow(void *a1, unsigned __int16 a2)
{
  unsigned __int16 v4 = [a1 range];
  while (a2 > v4)
  {
    if (!TSTHidingActionForRow((uint64_t)a1, --a2)) {
      return a2;
    }
  }
  return (unsigned __int16)-1;
}

uint64_t TSTTableRowBelowRow(void *a1, unsigned __int16 a2)
{
  unint64_t v4 = [a1 range];
  int v5 = v4 + HIWORD(v4) - 1;
  while (a2 < (unsigned __int16)v5)
  {
    if (!TSTHidingActionForRow((uint64_t)a1, ++a2)) {
      return a2;
    }
  }
  return (unsigned __int16)-1;
}

double TSTTableHeightOfRow(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  if (a2 == 0xFFFF)
  {
    unint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "CGFloat TSTTableHeightOfRow(TSTTableModel *, TSURowIndex, BOOL *)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2799, @"Bad row index!");
  }
  uint64_t v8 = TSTTableDataStoreHeaderInfoForRow(*(void *)(a1 + 48), a2, 0, 0);
  if (v8 && *(double *)(v8 + 24) != 0.0)
  {
    if (a3) {
      *a3 = 0;
    }
    uint64_t v9 = v8 + 24;
  }
  else
  {
    if (a3) {
      *a3 = 1;
    }
    uint64_t v9 = a1 + 96;
  }
  return *(double *)v9;
}

double TSTTableWidthOfColumn(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  if (a2 == 255)
  {
    unint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "CGFloat TSTTableWidthOfColumn(TSTTableModel *, TSUColumnIndex, BOOL *)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2819, @"Bad column index!");
  }
  uint64_t v8 = TSTTableDataStoreHeaderInfoForColumn(*(void *)(a1 + 48), a2, 0, 0);
  if (v8 && *(double *)(v8 + 24) != 0.0)
  {
    if (a3) {
      *a3 = 0;
    }
    uint64_t v9 = v8 + 24;
  }
  else
  {
    if (a3) {
      *a3 = 1;
    }
    uint64_t v9 = a1 + 104;
  }
  return *(double *)v9;
}

uint64_t TSTTableSetHeightOfRow(uint64_t a1, uint64_t a2, double a3)
{
  if (a2 == 0xFFFF)
  {
    unint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableSetHeightOfRow(TSTTableModel *, TSURowIndex, CGFloat)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2839, @"Bad row index!");
  }
  if (a3 < 8.0 && a3 != 0.0) {
    a3 = 8.0;
  }
  uint64_t result = TSTTableDataStoreHeaderInfoForRow(*(void *)(a1 + 48), a2, 1, 1);
  uint64_t v10 = result;
  if (!result)
  {
    uint64_t v11 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v12 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableSetHeightOfRow(TSTTableModel *, TSURowIndex, CGFloat)");
    uint64_t result = objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2849, @"invalid nil value for '%s'", "hdr");
  }
  *(double *)(v10 + 24) = a3;
  if (*(double *)(v10 + 24) == 0.0
    && !*(_WORD *)(v10 + 34)
    && !*(void *)(v10 + 8)
    && !*(void *)(v10 + 16)
    && !*(unsigned char *)(v10 + 32))
  {
    uint64_t v13 = *(void *)(a1 + 48);
    return TSTTableDataStoreRemoveRowHeadersAtIndex(v13, a2, 1);
  }
  return result;
}

uint64_t TSTTableSetWidthOfColumn(uint64_t a1, uint64_t a2, double a3)
{
  if (a2 == 255)
  {
    unint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableSetWidthOfColumn(TSTTableModel *, TSUColumnIndex, CGFloat)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2860, @"Bad column index!");
  }
  if (a3 < 8.0 && a3 != 0.0) {
    a3 = 8.0;
  }
  uint64_t result = TSTTableDataStoreHeaderInfoForColumn(*(void *)(a1 + 48), a2, 1, 1);
  uint64_t v10 = result;
  if (!result)
  {
    uint64_t v11 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v12 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableSetWidthOfColumn(TSTTableModel *, TSUColumnIndex, CGFloat)");
    uint64_t result = objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2868, @"invalid nil value for '%s'", "hdr");
  }
  *(double *)(v10 + 24) = a3;
  if (*(double *)(v10 + 24) == 0.0
    && !*(_WORD *)(v10 + 34)
    && !*(void *)(v10 + 8)
    && !*(void *)(v10 + 16)
    && !*(unsigned char *)(v10 + 32))
  {
    uint64_t v13 = *(void *)(a1 + 48);
    return TSTTableDataStoreRemoveColumnHeadersAtIndex(v13, a2, 1);
  }
  return result;
}

uint64_t TSTTableComputeDefaultRowHeight(double *a1)
{
  uint64_t result = TSTTableComputeDefaultFontHeight(a1, 0);
  double v4 = v3;
  if (a1) {
    double v5 = a1[12];
  }
  else {
    double v5 = 10.0;
  }
  if (v4 > v5)
  {
    uint64_t result = [a1 willModify];
    a1[12] = v4;
  }
  return result;
}

uint64_t TSTTableComputeDefaultFontHeight(void *a1, uint64_t a2)
{
  uint64_t result = [a1 defaultCellForTableArea:a2];
  if (result)
  {
    double v3 = *(void **)(result + 56);
    double v4 = (void *)[*(id *)(result + 40) valueForProperty:904];
    TSWPFastCreateFontForStyle(0, v3, 0x64uLL);
    TSWPFontGetLineHeight();
    [v4 topInset];
    return [v4 bottomInset];
  }
  return result;
}

uint64_t TSTTableInsertRows(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  [(id)a1 willModify];
  uint64_t result = TSTTableDataStoreInsertRows(*(void *)(a1 + 48), a2, a3, a4);
  if (!result) {
    *(_WORD *)(a1 + 72) += a3;
  }
  return result;
}

uint64_t TSTTableInsertColumns(uint64_t a1, char a2, uint64_t a3, char a4)
{
  *(_WORD *)(a1 + 74) += a3;
  return 0;
}

uint64_t TSTTableRemoveRows(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return 0;
}

uint64_t TSTTableRemoveRowsIgnoringSize(uint64_t a1, unsigned int a2, uint64_t a3, unsigned int a4)
{
  [(id)a1 willModify];
  uint64_t v10 = [(id)a1 range];
  if (*(_WORD *)(a1 + 84))
  {
    unsigned __int16 v6 = a2;
    do
    {
      if (a3 + a2 <= v6) {
        break;
      }
      if (!*(_WORD *)(a1 + 88) && !*(_WORD *)(a1 + 92))
      {
        uint64_t v7 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v8 = objc_msgSend(NSString, "stringWithUTF8String:", "TSUError TSTTableRemoveRowsIgnoringSize(TSTTableModel *, TSURowIndex, TSUColumnRowCount, BOOL)");
        objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 3053, @"Either mNumberOfUserHiddenRows or mNumberOfFilteredRows should be larger than 0 when mNumberOfHiddenRows is larger than 0");
      }
      if (TSTHidingActionForRow(a1, v6))
      {
        --*(_WORD *)(a1 + 88);
        --*(_WORD *)(a1 + 84);
      }
      if ((TSTHidingActionForRow(a1, v6) & 2) != 0)
      {
        --*(_WORD *)(a1 + 92);
        --*(_WORD *)(a1 + 84);
      }
      ++v6;
    }
    while (*(_WORD *)(a1 + 84));
  }
  objc_msgSend((id)a1, "p_clearDataListEntriesInRange:ignoreSizeChecks:", v10 & 0xFFFFFFFF0000 | (a3 << 48) | a2, a4, v10);
  TSTTableDataStoreRemoveRows(*(TSTTableDataStore **)(a1 + 48), a2, a3);
  *(_WORD *)(a1 + 72) -= a3;
  return 0;
}

BOOL TSTTableIsRowHiddenForAction(uint64_t a1, uint64_t a2, int a3)
{
  return (TSTHidingActionForRow(a1, a2) & a3) != 0;
}

uint64_t TSTTableRemoveColumns(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return 0;
}

uint64_t TSTTableRemoveColumnsIgnoringSize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  [(id)a1 willModify];
  uint64_t v8 = [(id)a1 range];
  if (*(_WORD *)(a1 + 86))
  {
    unsigned __int8 v9 = a2;
    do
    {
      if ((int)a3 + (int)a2 <= v9) {
        break;
      }
      if (TSTHidingActionForColumn(a1, v9))
      {
        --*(_WORD *)(a1 + 90);
        --*(_WORD *)(a1 + 86);
      }
      ++v9;
    }
    while (*(_WORD *)(a1 + 86));
  }
  objc_msgSend((id)a1, "p_clearDataListEntriesInRange:ignoreSizeChecks:", v8 & 0xFFFF0000FF000000 | (a3 << 32) | ((unint64_t)a2 << 16) | (unsigned __int16)v8, a4);
  TSTTableDataStoreRemoveColumns(*(TSTTableDataStore **)(a1 + 48), a2, a3);
  *(_WORD *)(a1 + 74) -= a3;
  return 0;
}

void TSTTableUpdateMergeRegionsRightOrBelowAndIncludingIndex(uint64_t *a1, unsigned int a2, uint64_t a3, int a4, int a5)
{
  if (!a1 || !a3) {
    return;
  }
  int v39 = a3;
  if (a4)
  {
    unint64_t v9 = (unint64_t)a2 << 16;
    unsigned int v10 = (unsigned __int16)([a1 numberOfColumns] - a2);
    uint64_t v11 = [a1 numberOfRows];
    if (v10 >= 0xFF) {
      uint64_t v12 = 255;
    }
    else {
      uint64_t v12 = v10;
    }
    uint64_t v13 = v11 << 48;
    unint64_t v14 = v12 << 32;
  }
  else
  {
    unsigned int v15 = [a1 numberOfColumns];
    int v16 = [a1 numberOfRows];
    unint64_t v9 = a2;
    if (v15 >= 0xFF) {
      uint64_t v17 = 255;
    }
    else {
      uint64_t v17 = v15;
    }
    unint64_t v14 = (unint64_t)(v16 - a2) << 48;
    uint64_t v13 = v17 << 32;
  }
  id v18 = TSTTableDataStoreMergeRangesForCellRange(a1[6], v14 | v13 | v9);
  *(_DWORD *)&v40[8] = 0;
  unint64_t v41 = 0;
  unsigned int v42 = 0;
  long long v19 = (void *)[v18 iterator];
  *(void *)unint64_t v40 = a5 ^ 1u;
  BOOL v38 = &v42;
  while (objc_msgSend(v19, "hasNextMergeRegion", v38))
  {
    uint64_t v20 = [v19 nextMergeRegion];
    unint64_t v21 = v20;
    if (a4) {
      BOOL v22 = 1;
    }
    else {
      BOOL v22 = a2 > (unsigned __int16)v20;
    }
    if (v22) {
      int v23 = *(_DWORD *)v40;
    }
    else {
      int v23 = 0;
    }
    if (v23 != 1 || a4 == 1 && BYTE2(v20) >= a2)
    {
      TSTTableDataStoreUnmerge((void *)a1[6], v20);
      unint64_t v24 = v21 >> 16;
      unint64_t v25 = HIDWORD(v21);
      unint64_t v26 = HIWORD(v21);
      if (a4)
      {
        if (a2 > BYTE2(v21) && a2 <= (BYTE4(v21) + BYTE2(v21) - 1)) {
          LOWORD(v25) = WORD2(v21) + v39;
        }
        else {
          LOBYTE(v24) = BYTE2(v21) + v39;
        }
      }
      else
      {
        if (a2 <= (unsigned __int16)v21 || a2 > (unsigned __int16)(v21 + HIWORD(v21) - 1))
        {
          unsigned __int16 v27 = v21 + v39;
          goto LABEL_33;
        }
        unint64_t v26 = (v26 + v39);
      }
      unsigned __int16 v27 = v21;
LABEL_33:
      uint64_t v28 = v21 & 0xFF000000;
      if (v41 >= v42)
      {
        uint64_t v30 = ((uint64_t)v41 - *(void *)&v40[4]) >> 3;
        if ((unint64_t)(v30 + 1) >> 61) {
          std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v31 = ((uint64_t)v42 - *(void *)&v40[4]) >> 2;
        if (v31 <= v30 + 1) {
          unint64_t v31 = v30 + 1;
        }
        if ((unint64_t)v42 - *(void *)&v40[4] >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v32 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v32 = v31;
        }
        if (v32) {
          long long v33 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>((uint64_t)v38, v32);
        }
        else {
          long long v33 = 0;
        }
        long long v34 = (unint64_t *)&v33[8 * v30];
        *long long v34 = ((unint64_t)(unsigned __int16)v25 << 32) | (v26 << 48) | ((unint64_t)v24 << 16) | v27 | v28;
        long long v29 = (uint64_t *)(v34 + 1);
        BOOL v35 = v41;
        if (v41 != *(uint64_t **)&v40[4])
        {
          do
          {
            unint64_t v36 = *--v35;
            *--long long v34 = v36;
          }
          while (v35 != *(uint64_t **)&v40[4]);
          BOOL v35 = *(uint64_t **)&v40[4];
        }
        *(void *)&v40[4] = v34;
        unsigned int v42 = (uint64_t *)&v33[8 * v32];
        if (v35) {
          operator delete(v35);
        }
      }
      else
      {
        *unint64_t v41 = ((unint64_t)(unsigned __int16)v25 << 32) | (v26 << 48) | ((unint64_t)v24 << 16) | v27 | v28;
        long long v29 = v41 + 1;
      }
      unint64_t v41 = v29;
    }
  }
  uint64_t v37 = *(uint64_t **)&v40[4];
  if (*(uint64_t **)&v40[4] != v41)
  {
    do
      TSTTableDataStoreMerge((void *)a1[6], *v37++);
    while (v37 != v41);
    uint64_t v37 = *(uint64_t **)&v40[4];
  }
  if (v37) {
    operator delete(v37);
  }
}

void sub_2237A4380(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id TSTTableMergeRangesForCellRange(uint64_t a1, uint64_t a2)
{
  return TSTTableDataStoreMergeRangesForCellRange(*(void *)(a1 + 48), a2);
}

uint64_t TSTTableUnmerge(uint64_t a1, uint64_t a2)
{
  return TSTTableDataStoreUnmerge(*(void **)(a1 + 48), a2);
}

uint64_t TSTTableMoveMergeRegionsWithColumnsOrRows(uint64_t *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  if (a3 >= a2) {
    uint64_t v7 = a3 - a2;
  }
  else {
    uint64_t v7 = a2 - a3 + a4;
  }
  if (a3 >= a2) {
    uint64_t v8 = a2;
  }
  else {
    uint64_t v8 = a3;
  }
  if (a3 >= a2) {
    __int16 v9 = a4;
  }
  else {
    __int16 v9 = 0;
  }
  if (a5)
  {
    unint64_t v10 = (unint64_t)v8 << 16;
    uint64_t v11 = [a1 numberOfRows];
    if ((unsigned __int16)v7 >= 0xFFu) {
      uint64_t v12 = 255;
    }
    else {
      uint64_t v12 = (unsigned __int16)v7;
    }
    uint64_t v13 = v11 << 48;
    uint64_t v14 = v12 << 32;
  }
  else
  {
    unsigned int v15 = [a1 numberOfColumns];
    if (v15 >= 0xFF) {
      uint64_t v16 = 255;
    }
    else {
      uint64_t v16 = v15;
    }
    uint64_t v14 = v7 << 48;
    uint64_t v13 = v16 << 32;
    unint64_t v10 = v8;
  }
  uint64_t result = (uint64_t)TSTTableDataStoreMergeRangesForCellRange(a1[6], v13 | v14 | v10);
  if (result)
  {
    id v18 = (void *)result;
    long long v19 = (void *)[(id)result iterator];
    if ([v19 hasNextMergeRegion])
    {
      do
        TSTTableDataStoreUnmerge((void *)a1[6], [v19 nextMergeRegion]);
      while (([v19 hasNextMergeRegion] & 1) != 0);
    }
    uint64_t v20 = (void *)[v18 iterator];
    uint64_t result = [v20 hasNextMergeRegion];
    if (result)
    {
      __int16 v41 = a3 - v9 - a2;
      unsigned int v44 = a4 + a2;
      unsigned int v45 = v8 + (unsigned __int16)v7;
      uint64_t v40 = a4;
      int v21 = v8;
      do
      {
        unint64_t v22 = objc_msgSend(v20, "nextMergeRegion", v40);
        unint64_t v23 = v22;
        unint64_t v24 = v22 >> 16;
        if (a5)
        {
          unsigned int v25 = BYTE2(v22);
          if (BYTE2(v22) < v8)
          {
            unint64_t v26 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v8 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableMoveMergeRegionsWithColumnsOrRows(TSTTableModel *, TSUColumnOrRowIndex, TSUColumnOrRowIndex, TSUColumnRowCount, TSTCommandDirection)");
            uint64_t v27 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"];
            uint64_t v28 = v8;
            LODWORD(v8) = v21;
            [v26 handleFailureInFunction:v28 file:v27 lineNumber:3223 description:@"Merged cell range started before first row moved."];
          }
          if (v25 + WORD2(v23) > v45)
          {
            long long v29 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v8 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableMoveMergeRegionsWithColumnsOrRows(TSTTableModel *, TSUColumnOrRowIndex, TSUColumnOrRowIndex, TSUColumnRowCount, TSTCommandDirection)");
            uint64_t v30 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"];
            uint64_t v31 = v8;
            LODWORD(v8) = v21;
            [v29 handleFailureInFunction:v31 file:v30 lineNumber:3224 description:@"Merged cell range ended after last row moved."];
          }
          if (v25 < a2 || v25 >= v44)
          {
            if (a3 < a2) {
              LOBYTE(v24) = v25 + a4;
            }
            else {
              LOBYTE(v24) = v24 - v40;
            }
          }
          else
          {
            LOBYTE(v24) = v25 + v41;
          }
          unsigned __int16 v39 = v23;
        }
        else
        {
          unsigned int v32 = (unsigned __int16)v22;
          if ((unsigned __int16)v22 < v8)
          {
            uint64_t v8 = [MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v33 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableMoveMergeRegionsWithColumnsOrRows(TSTTableModel *, TSUColumnOrRowIndex, TSUColumnOrRowIndex, TSUColumnRowCount, TSTCommandDirection)");
            uint64_t v34 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"];
            BOOL v35 = (void *)v8;
            LODWORD(v8) = v21;
            [v35 handleFailureInFunction:v33 file:v34 lineNumber:3208 description:@"Merged cell range started before first row moved."];
          }
          if (v32 + HIWORD(v23) > v45)
          {
            unint64_t v36 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v8 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableMoveMergeRegionsWithColumnsOrRows(TSTTableModel *, TSUColumnOrRowIndex, TSUColumnOrRowIndex, TSUColumnRowCount, TSTCommandDirection)");
            uint64_t v37 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"];
            uint64_t v38 = v8;
            LODWORD(v8) = v21;
            [v36 handleFailureInFunction:v38 file:v37 lineNumber:3209 description:@"Merged cell range ended after last row moved."];
          }
          if (v32 < a2 || v32 >= v44)
          {
            unsigned __int16 v39 = v32 - a4;
            if (a3 < a2) {
              unsigned __int16 v39 = v32 + a4;
            }
          }
          else
          {
            unsigned __int16 v39 = v32 + v41;
          }
        }
        TSTTableDataStoreMerge((void *)a1[6], v23 & 0xFFFFFFFFFF000000 | v39 | ((unint64_t)v24 << 16));
        uint64_t result = [v20 hasNextMergeRegion];
      }
      while ((result & 1) != 0);
    }
  }
  return result;
}

void TSTTableMoveRows(void **a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
}

void TSTTableMoveColumns(void **a1, unsigned int a2, unsigned int a3, int a4)
{
}

void TSTTableSwapRows(void *a1, uint64_t a2, uint64_t a3)
{
  [a1 willModify];
  uint64_t v6 = a1[6];

  TSTTableDataStoreSwapRows(v6, a2, a3);
}

uint64_t TSTHidingActionForRow(uint64_t a1, uint64_t a2)
{
  if (a2 == 0xFFFF) {
    return 0;
  }
  if (*(_WORD *)(a1 + 84))
  {
    uint64_t result = TSTTableDataStoreHeaderInfoForRow(*(void *)(a1 + 48), a2, 0, 0);
    if (result) {
      return *(unsigned __int8 *)(result + 32);
    }
  }
  else
  {
    if (*(_WORD *)(a1 + 88) || *(_WORD *)(a1 + 92))
    {
      __int16 v9 = objc_msgSend(MEMORY[0x263F7C7F0], "currentHandler", v5, v4, v3, v2, v6, v7);
      uint64_t v10 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTHidingAction TSTHidingActionForRow(TSTTableModel *, TSURowIndex)");
      objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 3279, @"Both mNumberOfUserHiddenRows and mNumberOfFilteredRows should equal to 0 when mNumberOfHiddenRows is equal to 0");
    }
    return 0;
  }
  return result;
}

uint64_t TSTHidingActionForColumn(uint64_t a1, uint64_t a2)
{
  if (a2 == 255) {
    return 0;
  }
  if (*(_WORD *)(a1 + 86))
  {
    uint64_t result = TSTTableDataStoreHeaderInfoForColumn(*(void *)(a1 + 48), a2, 0, 0);
    if (result) {
      return *(unsigned __int8 *)(result + 32);
    }
  }
  else
  {
    if (*(_WORD *)(a1 + 90))
    {
      uint64_t v3 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v4 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTHidingAction TSTHidingActionForColumn(TSTTableModel *, TSUColumnIndex)");
      objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 3300, @"mNumberOfUserHiddenColumns should equal to 0 when mNumberOfHiddenColumns is equal to 0");
    }
    return 0;
  }
  return result;
}

uint64_t TSTTableNumHiddenRowsInCellRange(uint64_t a1, uint64_t a2)
{
  unsigned __int16 v2 = a2;
  unsigned int v3 = (unsigned __int16)(HIWORD(a2) + a2);
  if (v3 <= (unsigned __int16)a2)
  {
    return 0;
  }
  else
  {
    unsigned __int16 v5 = 0;
    do
    {
      if (TSTHidingActionForRow(a1, v2)) {
        ++v5;
      }
      ++v2;
    }
    while (v3 > v2);
  }
  return v5;
}

uint64_t TSTTableNumHiddenColumnsInCellRange(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = a2 >> 16;
  unsigned int v3 = (BYTE2(a2) + BYTE4(a2));
  if (v3 <= BYTE2(a2))
  {
    return 0;
  }
  else
  {
    unsigned __int16 v5 = 0;
    do
    {
      if (TSTHidingActionForColumn(a1, v2)) {
        ++v5;
      }
      LOBYTE(v2) = v2 + 1;
    }
    while (v3 > v2);
  }
  return v5;
}

TSTEphemeralCellMap *TSTEphemeralCellMapForOrderedCellIDs(uint64_t a1, int *a2, int a3)
{
  if (!a2)
  {
    uint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTEphemeralCellMap *TSTEphemeralCellMapForOrderedCellIDs(TSTTableModel *, TSTCellID *, int)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 3425, @"No cell id array given to TSTEphemeralCellMapForOrderedCellIDs!");
  }
  if (a3 <= 0)
  {
    uint64_t v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTEphemeralCellMap *TSTEphemeralCellMapForOrderedCellIDs(TSTTableModel *, TSTCellID *, int)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 3426, @"Need at least one cell ID in TSTEphemeralCellMapForOrderedCellIDs.");
  }
  uint64_t v10 = [[TSTEphemeralCellMap alloc] initWithCapacity:a3];
  uint64_t v11 = *a2;
  unint64_t v12 = a2[a3 - 1];
  unint64_t v13 = v12 >> 16;
  int v14 = v12 & 0xFF000000;
  int v15 = 0x10000;
  int v16 = 1;
  if (*(_WORD *)a2 == 0xFFFF || (v11 & 0xFF0000) == 0xFF0000)
  {
    LODWORD(v17) = a2[a3 - 1];
  }
  else
  {
    unint64_t v17 = v11 | 0x1000100000000;
    if ((_WORD)v12 == 0xFFFF || (v12 & 0xFF0000) == 0xFF0000)
    {
      unint64_t v13 = v17 >> 16;
      int v14 = v11 & 0xFF000000;
    }
    else
    {
      if ((unsigned __int16)*a2 == (unsigned __int16)v12)
      {
        unsigned int v18 = WORD1(v11);
        if (BYTE2(v11) <= BYTE2(v12) && BYTE2(v11) >= BYTE2(v12))
        {
          int v14 = v11 & 0xFF000000;
          int v15 = 0x10000;
          unint64_t v13 = v17 >> 16;
          goto LABEL_28;
        }
      }
      else
      {
        unsigned int v18 = WORD1(v11);
      }
      int v14 = 0;
      if (BYTE2(v12) <= BYTE2(v11)) {
        unsigned __int8 v19 = BYTE2(a2[a3 - 1]);
      }
      else {
        unsigned __int8 v19 = BYTE2(*a2);
      }
      unsigned int v20 = (unsigned __int16)a2[a3 - 1];
      if (BYTE2(v12) >= v18) {
        LOBYTE(v18) = BYTE2(a2[a3 - 1]);
      }
      BOOL v21 = v20 >= (unsigned __int16)v11;
      if (v20 <= (unsigned __int16)v11) {
        int v22 = a2[a3 - 1];
      }
      else {
        int v22 = *a2;
      }
      LOWORD(v17) = v22;
      if (v21) {
        LODWORD(v11) = a2[a3 - 1];
      }
      LOBYTE(v13) = v19;
      unsigned __int16 v23 = v18 - v19 + 1;
      int v15 = ((v11 - v22) << 16) + 0x10000;
      int v16 = v23;
    }
  }
LABEL_28:
  unint64_t v24 = v14 & 0xFF000000 | ((unint64_t)(v15 | v16) << 32) | ((unint64_t)v13 << 16) | (unsigned __int16)v17;
  unsigned int v25 = [[TSTCellIterator alloc] initWithTableModel:a1 range:v24];
  if (a3 >= 1)
  {
    int v26 = 0;
    do
    {
      if (!TSTCellIteratorGetNextCell(v25, v28)) {
        break;
      }
      if (((v29 ^ a2[v26]) & 0xFFFFFF) == 0)
      {
        unint64_t v24 = v24 & 0xFFFFFFFF00000000 | v29;
        [(TSTEphemeralCellMap *)v10 addCell:v30 andCellID:v24];
        ++v26;
      }
    }
    while (v26 < a3);
  }

  return v10;
}

BOOL TSTTableIsColumnHiddenForAction(uint64_t a1, uint64_t a2, int a3)
{
  return (TSTHidingActionForColumn(a1, a2) & a3) != 0;
}

BOOL TSTTableHasRowHiddenForActionInRange(_WORD *a1, unint64_t a2, int a3)
{
  if (!a1[42]) {
    return 0;
  }
  unsigned __int16 v4 = a2;
  unint64_t v6 = HIWORD(a2);
  if (!a1[44] && !a1[46])
  {
    uint64_t v7 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v8 = objc_msgSend(NSString, "stringWithUTF8String:", "BOOL TSTTableHasRowHiddenForActionInRange(TSTTableModel *, TSTCellRange, TSTHidingAction)");
    objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 3587, @"Either mNumberOfUserHiddenRows or mNumberOfFilteredRows should be larger than 0 when mNumberOfHiddenRows is larger than 0");
  }
  char v9 = 0;
  unsigned int v10 = v6 + v4;
  do
  {
    BOOL v11 = v10 > v4;
    if (v10 <= v4) {
      break;
    }
    if ((TSTHidingActionForRow((uint64_t)a1, v4) & a3) != 0) {
      char v9 = 1;
    }
    ++v4;
  }
  while ((v9 & 1) == 0);
  return v11;
}

uint64_t TSTTableHasRowShownInRange(_WORD *a1, unint64_t a2)
{
  if (!a1[42]) {
    return 1;
  }
  unsigned __int16 v2 = a2;
  unint64_t v4 = HIWORD(a2);
  if (!a1[44] && !a1[46])
  {
    unsigned __int16 v5 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v6 = objc_msgSend(NSString, "stringWithUTF8String:", "BOOL TSTTableHasRowShownInRange(TSTTableModel *, TSTCellRange)");
    objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 3603, @"Either mNumberOfUserHiddenRows or mNumberOfFilteredRows should be larger than 0 when mNumberOfHiddenRows is larger than 0");
  }
  char v7 = 0;
  unsigned int v8 = v4 + v2;
  do
  {
    BOOL v9 = v8 > v2;
    if (v8 <= v2) {
      break;
    }
    if (!TSTHidingActionForRow((uint64_t)a1, v2)) {
      char v7 = 1;
    }
    ++v2;
  }
  while ((v7 & 1) == 0);
  return v9;
}

BOOL TSTTableHasColumnHiddenForActionInRange(uint64_t a1, unint64_t a2, int a3)
{
  if (!*(_WORD *)(a1 + 86)) {
    return 0;
  }
  unsigned __int8 v4 = BYTE2(a2);
  unint64_t v6 = a2 >> 16;
  unint64_t v7 = HIDWORD(a2);
  if (!*(_WORD *)(a1 + 90))
  {
    unsigned int v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "BOOL TSTTableHasColumnHiddenForActionInRange(TSTTableModel *, TSTCellRange, TSTHidingAction)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 3620, @"mNumberOfUserHiddenColumns should be larger than 0 when mNumberOfHiddenColumns is larger than 0");
  }
  char v10 = 0;
  unsigned int v11 = v4 + (unsigned __int16)v7;
  do
  {
    BOOL v12 = v11 > v6;
    if (v11 <= v6) {
      break;
    }
    if ((TSTHidingActionForColumn(a1, v6) & a3) != 0) {
      char v10 = 1;
    }
    LOBYTE(v6) = v6 + 1;
  }
  while ((v10 & 1) == 0);
  return v12;
}

uint64_t TSTTableHasColumnShownInRange(uint64_t a1, unint64_t a2)
{
  if (!*(_WORD *)(a1 + 86)) {
    return 1;
  }
  unsigned __int8 v2 = BYTE2(a2);
  unint64_t v4 = a2 >> 16;
  unint64_t v5 = HIDWORD(a2);
  if (!*(_WORD *)(a1 + 90))
  {
    unint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "BOOL TSTTableHasColumnShownInRange(TSTTableModel *, TSTCellRange)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 3636, @"mNumberOfUserHiddenColumns should be larger than 0 when mNumberOfHiddenColumns is larger than 0");
  }
  char v8 = 0;
  unsigned int v9 = v2 + (unsigned __int16)v5;
  do
  {
    BOOL v10 = v9 > v4;
    if (v9 <= v4) {
      break;
    }
    if (!TSTHidingActionForColumn(a1, v4)) {
      char v8 = 1;
    }
    LOBYTE(v4) = v4 + 1;
  }
  while ((v8 & 1) == 0);
  return v10;
}

uint64_t TSTTableHasCellRangeHidden(_WORD *a1, unint64_t a2)
{
  if (!a1[43] && !a1[42]) {
    return 0;
  }
  unint64_t v4 = HIDWORD(a2);
  if (!a1[45] && !a1[44] && !a1[46])
  {
    unint64_t v5 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v6 = objc_msgSend(NSString, "stringWithUTF8String:", "BOOL TSTTableHasCellRangeHidden(TSTTableModel *, TSTCellRange)");
    [v5 handleFailureInFunction:v6, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 3654, @"mNumberOfUserHiddenColumns, mNumberOfUserHiddenRows or mNumberOfFilteredRows should be larger than 0 when mNumberOfHiddenColumns or mNumberOfHiddenColumns is larger than 0" file lineNumber description];
  }
  if (!(_WORD)v4) {
    return 1;
  }
  unint64_t v7 = a2 >> 16;
  unsigned int v8 = BYTE2(a2) + (unsigned __int16)v4;
  while (1)
  {
    if (!TSTHidingActionForColumn((uint64_t)a1, v7))
    {
      unsigned __int16 v9 = a2;
      if (HIWORD(a2)) {
        break;
      }
    }
LABEL_13:
    LOBYTE(v7) = v7 + 1;
    if (v8 <= v7) {
      return 1;
    }
  }
  while (1)
  {
    uint64_t result = TSTHidingActionForRow((uint64_t)a1, v9);
    if (!result) {
      return result;
    }
    if ((HIWORD(a2) + (unsigned __int16)a2) <= ++v9) {
      goto LABEL_13;
    }
  }
}

__CFString *TSTTableStringForCellAtCellID(uint64_t a1, __CFString *a2, int a3)
{
  if (a2)
  {
    return NSStringFromNativeTSTCell(a2);
  }
  else
  {
    unint64_t v5 = TSTTableDataStoreCellStorageRefAtCellID(*(void *)(a1 + 48), a3);
    if (!v5) {
      return 0;
    }
    if (v5[2] << 8 != 768)
    {
      unsigned int v11 = [[TSTCell alloc] initWithStorageRef:v5 dataStore:*(void *)(a1 + 48)];
      BOOL v12 = NSStringFromNativeTSTCell((__CFString *)v11);

      return v12;
    }
    if ((v5[4] & 0x10) == 0) {
      return 0;
    }
    Element = (unsigned int *)TSTCellStorageGetElement((uint64_t)v5, 16);
    if (!Element)
    {
      unint64_t v7 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v8 = [NSString stringWithUTF8String:"TSTTableDataListKey TSTCellStorageStringID(TSTCellStorage *)"];
      objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 401, @"Can't get string ID storage element!");
    }
    uint64_t v9 = *Element;
    if (!v9) {
      return 0;
    }
    uint64_t v10 = *(void *)(a1 + 48);
    return (__CFString *)TSTTableDataStoreGetStringForKey(v10, v9);
  }
}

uint64_t TSTTableGetFontColorForCell(uint64_t *a1, uint64_t a2, unsigned int a3)
{
  if (!a2 || (int TextStyleAtCellID = *(TSWPParagraphStyle **)(a2 + 56)) == 0) {
    int TextStyleAtCellID = TSTTableGetTextStyleAtCellID(a1, a3, 0);
  }
  uint64_t result = [(TSSStyle *)TextStyleAtCellID valueForProperty:18];
  if (!result)
  {
    unint64_t v5 = (void *)MEMORY[0x263F7C808];
    return [v5 blackColor];
  }
  return result;
}

uint64_t TSTTableRangeOfTableWithMerges(uint64_t a1)
{
  return TSTTableDataStoreRangeOfTableWithMerges(*(void *)(a1 + 48));
}

void *TSTTableMergeRangesPartiallyIntersectCellRange(uint64_t a1, uint64_t a2)
{
  return TSTTableDataStoreMergeRangesPartiallyIntersectCellRange(*(void *)(a1 + 48), a2);
}

uint64_t TSTTableCreateMergeRangesForCellRange(uint64_t a1, uint64_t a2)
{
  return TSTTableDataStoreCreateMergeRangesForCellRange(*(void *)(a1 + 48), a2);
}

unint64_t TSTTableExpandCellRangeToCoverMergedCells(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = a2;
  if (a1)
  {
    unint64_t v4 = a2;
    do
    {
      unint64_t v5 = objc_msgSend(TSTTableDataStoreMergeRangesForCellRange(*(void *)(a1 + 48), v2), "iterator");
      if ([v5 hasNextMergeRegion])
      {
        unint64_t v4 = v2;
        do
        {
          unint64_t v6 = [v5 nextMergeRegion];
          if ((_WORD)v6 == 0xFFFF
            || (v6 & 0xFF0000) == 0xFF0000
            || (unint64_t v7 = HIWORD(v6)) == 0
            || (v6 & 0xFFFF00000000) == 0)
          {
            unint64_t v8 = v4 >> 16;
            int v12 = v4 & 0xFF000000;
            unint64_t v9 = HIDWORD(v4);
            LOWORD(v6) = v4;
            unint64_t v7 = HIWORD(v4);
          }
          else if ((_WORD)v4 == 0xFFFF || (v4 & 0xFF0000) == 0xFF0000 || !HIWORD(v4) || (v4 & 0xFFFF00000000) == 0)
          {
            unint64_t v8 = v6 >> 16;
            int v12 = v6 & 0xFF000000;
            unint64_t v9 = HIDWORD(v6);
          }
          else if ((unsigned __int16)v6 <= (unsigned __int16)v4 {
                 && (unsigned __int16)(v6 + HIWORD(v6) - 1) >= (unsigned __int16)v4
          }
                 && (unint64_t v8 = v6 >> 16, BYTE2(v4) >= BYTE2(v6))
                 && (unint64_t v9 = HIDWORD(v6), v10 = (BYTE4(v6) + BYTE2(v6) - 1), v10 >= BYTE2(v4))
                 && v10 >= (BYTE4(v4) + BYTE2(v4) - 1)
                 && (unsigned __int16)(v6 + HIWORD(v6) - 1) >= (unsigned __int16)(v4 + HIWORD(v4) - 1))
          {
            int v12 = v6 & 0xFF000000;
          }
          else if ((unsigned __int16)v4 <= (unsigned __int16)v6 {
                 && (unsigned __int16)(v4 + HIWORD(v4) - 1) >= (unsigned __int16)v6
          }
                 && (unint64_t v8 = v4 >> 16, BYTE2(v6) >= BYTE2(v4))
                 && (unint64_t v9 = HIDWORD(v4), v11 = (BYTE4(v4) + BYTE2(v4) - 1), v11 >= BYTE2(v6))
                 && v11 >= (BYTE4(v6) + BYTE2(v6) - 1)
                 && (unsigned __int16)(v4 + HIWORD(v4) - 1) >= (unsigned __int16)(v6 + HIWORD(v6) - 1))
          {
            int v12 = v4 & 0xFF000000;
            LOWORD(v6) = v4;
            unint64_t v7 = HIWORD(v4);
          }
          else
          {
            int v12 = 0;
            if (BYTE2(v6) >= BYTE2(v4)) {
              LOWORD(v8) = BYTE2(v4);
            }
            else {
              LOWORD(v8) = BYTE2(v6);
            }
            __int16 v13 = v6;
            if ((unsigned __int16)v6 >= (unsigned __int16)v4) {
              __int16 v13 = v4;
            }
            __int16 v14 = v6 + HIWORD(v6);
            LOWORD(v6) = v13;
            LODWORD(v9) = (BYTE4(v6) + BYTE2(v6) - 1);
            if (v9 <= (BYTE4(v4) + BYTE2(v4) - 1)) {
              LOWORD(v9) = (BYTE4(v4) + BYTE2(v4) - 1);
            }
            unsigned int v15 = (unsigned __int16)(v14 - 1);
            if (v15 <= (unsigned __int16)(v4 + HIWORD(v4) - 1)) {
              LOWORD(v15) = v4 + HIWORD(v4) - 1;
            }
            LOWORD(v9) = v9 - v8 + 1;
            unint64_t v7 = (unsigned __int16)(v15 - v13 + 1);
          }
          unint64_t v4 = ((unint64_t)(unsigned __int16)v9 << 32) | (v7 << 48) | v12 & 0xFF000000 | ((unint64_t)v8 << 16) | (unsigned __int16)v6;
        }
        while (([v5 hasNextMergeRegion] & 1) != 0);
      }
      unint64_t v16 = v4 ^ v2;
      uint64_t v2 = v4;
    }
    while ((v16 & 0xFFFFFFFF00FFFFFFLL) != 0);
  }
  else
  {
    unint64_t v17 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v18 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTCellRange TSTTableExpandCellRangeToCoverMergedCells(TSTTableModel *, TSTCellRange)");
    objc_msgSend(v17, "handleFailureInFunction:file:lineNumber:description:", v18, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 3863, @"No table model!  Aborting expandCellRangeToCoverMergedCells:.  This is a bug in the calling code.");
    return v2;
  }
  return v4;
}

uint64_t TSTTableGetBackgroundFill()
{
  return 0;
}

uint64_t TSTTableGetBodyFill(void *a1)
{
  uint64_t v1 = (void *)[a1 bodyCellStyle];

  return [v1 valueForProperty:898];
}

uint64_t TSTTableGetHeaderColumnsFill(void *a1)
{
  uint64_t v1 = (void *)[a1 headerColumnCellStyle];

  return [v1 valueForProperty:898];
}

uint64_t TSTTableGetHeaderRowsFill(void *a1)
{
  uint64_t v1 = (void *)[a1 headerRowCellStyle];

  return [v1 valueForProperty:898];
}

uint64_t TSTTableGetFooterRowsFill(void *a1)
{
  uint64_t v1 = (void *)[a1 footerRowCellStyle];

  return [v1 valueForProperty:898];
}

uint64_t TSTTableGetRowFill(uint64_t *a1, uint64_t a2)
{
  char v4 = 0;
  uint64_t CellStyleAtRow = (void *)TSTTableGetCellStyleAtRow(a1, a2, &v4);
  if (v4) {
    return 0;
  }
  else {
    return [CellStyleAtRow valueForProperty:898];
  }
}

uint64_t TSTTableGetColumnFill(uint64_t *a1, uint64_t a2)
{
  char v4 = 0;
  CellStyleAtColumn = (void *)TSTTableGetCellStyleAtColumn(a1, a2, &v4);
  if (v4) {
    return 0;
  }
  else {
    return [CellStyleAtColumn valueForProperty:898];
  }
}

id TSTTableGetDefaultHorizontalBorderStroke(TSTTableModel *a1)
{
  if (![(TSSStyle *)[(TSTTableModel *)a1 tableStyle] intValueForProperty:796]) {
    return 0;
  }
  uint64_t v2 = [(TSTTableModel *)a1 tableStyle];

  return [(TSSStyle *)v2 valueForProperty:771];
}

id TSTTableGetDefaultVerticalBorderStroke(TSTTableModel *a1)
{
  if (![(TSSStyle *)[(TSTTableModel *)a1 tableStyle] intValueForProperty:796]) {
    return 0;
  }
  uint64_t v2 = [(TSTTableModel *)a1 tableStyle];

  return [(TSSStyle *)v2 valueForProperty:772];
}

uint64_t TSTTableGetDefaultBorderStroke(void *a1)
{
  if (!objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "intValueForProperty:", 796)) {
    return 0;
  }
  uint64_t v2 = (void *)[a1 tableStyle];

  return [v2 valueForProperty:771];
}

uint64_t TSTTableGetDefaultBodyColumnStroke(void *a1)
{
  if (!objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "intValueForProperty:", 788)) {
    return 0;
  }
  uint64_t v2 = (void *)[a1 tableStyle];

  return [v2 valueForProperty:774];
}

uint64_t TSTTableGetDefaultBodyRowStroke(void *a1)
{
  if (!objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "intValueForProperty:", 789)) {
    return 0;
  }
  uint64_t v2 = (void *)[a1 tableStyle];

  return [v2 valueForProperty:773];
}

uint64_t TSTTableGetDefaultHeaderColumnBorderStroke(void *a1)
{
  if (!objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "intValueForProperty:", 796)) {
    return 0;
  }
  uint64_t v2 = (void *)[a1 tableStyle];

  return [v2 valueForProperty:778];
}

uint64_t TSTTableGetDefaultHeaderColumnBodyColumnStroke(void *a1)
{
  uint64_t v1 = (void *)[a1 tableStyle];

  return [v1 valueForProperty:777];
}

uint64_t TSTTableGetDefaultHeaderColumnBodyRowStroke(void *a1)
{
  if (!objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "intValueForProperty:", 793)) {
    return 0;
  }
  uint64_t v2 = (void *)[a1 tableStyle];

  return [v2 valueForProperty:776];
}

uint64_t TSTTableGetDefaultHeaderColumnSeparatorStroke(void *a1)
{
  uint64_t v1 = (void *)[a1 tableStyle];

  return [v1 valueForProperty:775];
}

uint64_t TSTTableGetDefaultHeaderRowBorderStroke(void *a1)
{
  if (!objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "intValueForProperty:", 796)) {
    return 0;
  }
  uint64_t v2 = (void *)[a1 tableStyle];

  return [v2 valueForProperty:782];
}

uint64_t TSTTableGetDefaultHeaderRowBodyColumnStroke(void *a1)
{
  if (!objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "intValueForProperty:", 791)) {
    return 0;
  }
  uint64_t v2 = (void *)[a1 tableStyle];

  return [v2 valueForProperty:780];
}

uint64_t TSTTableGetDefaultHeaderRowBodyRowStroke(void *a1)
{
  uint64_t v1 = (void *)[a1 tableStyle];

  return [v1 valueForProperty:781];
}

uint64_t TSTTableGetDefaultHeaderRowSeparatorStroke(void *a1)
{
  uint64_t v1 = (void *)[a1 tableStyle];

  return [v1 valueForProperty:779];
}

uint64_t TSTTableGetDefaultFooterRowBorderStroke(void *a1)
{
  if (!objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "intValueForProperty:", 796)) {
    return 0;
  }
  uint64_t v2 = (void *)[a1 tableStyle];

  return [v2 valueForProperty:786];
}

uint64_t TSTTableGetDefaultFooterRowBodyColumnStroke(void *a1)
{
  if (!objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "intValueForProperty:", 795)) {
    return 0;
  }
  uint64_t v2 = (void *)[a1 tableStyle];

  return [v2 valueForProperty:784];
}

uint64_t TSTTableGetDefaultFooterRowBodyRowStroke(void *a1)
{
  uint64_t v1 = (void *)[a1 tableStyle];

  return [v1 valueForProperty:785];
}

uint64_t TSTTableGetDefaultFooterRowSeparatorStroke(void *a1)
{
  uint64_t v1 = (void *)[a1 tableStyle];

  return [v1 valueForProperty:783];
}

void *TSTTableGetDefaultStrokesForColumn(uint64_t *a1, uint64_t a2, void *a3, void *a4)
{
  if (a3) {
    *a3 = [MEMORY[0x263EFF9D0] null];
  }
  if (a4) {
    *a4 = [MEMORY[0x263EFF9D0] null];
  }
  char v10 = 0;
  uint64_t result = (void *)TSTTableGetCellStyleAtColumn(a1, a2, &v10);
  if (result && !v10)
  {
    unint64_t v9 = result;
    if (a3)
    {
      uint64_t result = (void *)[result valueForProperty:901];
      if (result) {
        *a3 = result;
      }
    }
    if (a4)
    {
      uint64_t result = (void *)[v9 valueForProperty:902];
      if (result) {
        *a4 = result;
      }
    }
  }
  return result;
}

void *TSTTableGetDefaultStrokesForRow(uint64_t *a1, uint64_t a2, void *a3, void *a4)
{
  if (a3) {
    *a3 = [MEMORY[0x263EFF9D0] null];
  }
  if (a4) {
    *a4 = [MEMORY[0x263EFF9D0] null];
  }
  char v10 = 0;
  uint64_t result = (void *)TSTTableGetCellStyleAtRow(a1, a2, &v10);
  if (result && !v10)
  {
    unint64_t v9 = result;
    if (a3)
    {
      uint64_t result = (void *)[result valueForProperty:899];
      if (result) {
        *a3 = result;
      }
    }
    if (a4)
    {
      uint64_t result = (void *)[v9 valueForProperty:900];
      if (result) {
        *a4 = result;
      }
    }
  }
  return result;
}

uint64_t p_setStrokeResult(uint64_t a1, int a2, void *a3, uint64_t *a4)
{
  uint64_t v6 = [a3 valueForProperty:a1];
  uint64_t result = [MEMORY[0x263EFF9D0] null];
  if (!a2) {
    goto LABEL_6;
  }
  if (v6 == result)
  {
    uint64_t result = 0;
    goto LABEL_6;
  }
  uint64_t result = v6;
  if (v6) {
LABEL_6:
  }
    *a4 = result;
  return result;
}

uint64_t TSTTableGetStrokesForCellID(uint64_t a1, unsigned int a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t a7)
{
  unint64_t v14 = TSTTableDataStoreMergeRangeAtCellID(*(void *)(a1 + 48), a2);

  return TSTTableGetStrokesForCellIDWithMergeRange(a1, a2, v14, a3, a4, a5, a6, a7);
}

uint64_t TSTTableGetStrokesForCellIDWithMergeRange(uint64_t a1, int a2, unint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t a8)
{
  uint64_t result = [MEMORY[0x263EFF9D0] null];
  if (a8)
  {
    unint64_t v17 = (unsigned int *)(a8 + 8);
    uint64_t v18 = *(void **)(a8 + 40);
    if (v18)
    {
      uint64_t v59 = result;
      unsigned __int8 v19 = a7;
      unint64_t v55 = a5;
      unsigned int v20 = *v17;
      goto LABEL_4;
    }
  }
  else
  {
    uint64_t v59 = result;
    uint64_t v32 = *(void *)(a1 + 48);
    uint64_t v33 = TSTTableDataStoreCellStorageRefAtCellID(v32, a2);
    if (v33)
    {
      uint64_t v34 = v33;
      if ((v33[4] & 2) != 0)
      {
        Element = (unsigned int *)TSTCellStorageGetElement((uint64_t)v33, 2);
        if (!Element)
        {
          unint64_t v58 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v56 = [NSString stringWithUTF8String:"TSTTableDataListKey TSTCellStorageStyleID(TSTCellStorage *)"];
          objc_msgSend(v58, "handleFailureInFunction:file:lineNumber:description:", v56, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 182, @"Can't get style ID storage element!");
        }
        uint64_t v36 = *Element;
        if (v36)
        {
          StyleForKeCGFloat y = TSTTableDataListGetStyleForKey([*(id *)(v32 + 72) object], v36);
          if (StyleForKey)
          {
            uint64_t v18 = (void *)StyleForKey;
            unsigned __int8 v19 = a7;
            unint64_t v55 = a5;
            unsigned int v20 = *((_DWORD *)v34 + 1);
LABEL_4:
            int v21 = (v20 >> 20) & 1;
            int v22 = (v20 >> 21) & 1;
            int v23 = (v20 >> 22) & 1;
            BOOL v24 = (v20 & 0x8000000) == 0;
            if ((v20 & 0x8000000) != 0) {
              int v25 = (v20 >> 23) & 1;
            }
            else {
              int v25 = 1;
            }
            int v57 = v25;
            if (v24) {
              int v26 = 1;
            }
            else {
              int v26 = v23;
            }
            if (v24) {
              int v27 = 1;
            }
            else {
              int v27 = v22;
            }
            if (v24) {
              int v28 = 1;
            }
            else {
              int v28 = v21;
            }
            uint64_t v29 = [v18 valueForProperty:899];
            uint64_t v30 = [MEMORY[0x263EFF9D0] null];
            if (v28)
            {
              if (v29 == v30)
              {
                uint64_t v30 = 0;
              }
              else
              {
                uint64_t v30 = v29;
                uint64_t v31 = v59;
                if (!v29)
                {
LABEL_31:
                  uint64_t v41 = [v18 valueForProperty:900];
                  uint64_t v42 = [MEMORY[0x263EFF9D0] null];
                  if (v27)
                  {
                    if (v41 == v42)
                    {
                      uint64_t v42 = 0;
                    }
                    else
                    {
                      uint64_t v42 = v41;
                      uint64_t v39 = v59;
                      if (!v41)
                      {
LABEL_37:
                        uint64_t v43 = [v18 valueForProperty:901];
                        uint64_t v44 = [MEMORY[0x263EFF9D0] null];
                        if (v26)
                        {
                          if (v43 == v44)
                          {
                            uint64_t v44 = 0;
                          }
                          else
                          {
                            uint64_t v44 = v43;
                            uint64_t v45 = v59;
                            if (!v43)
                            {
LABEL_43:
                              uint64_t v46 = v45;
                              uint64_t v47 = [v18 valueForProperty:902];
                              uint64_t result = [MEMORY[0x263EFF9D0] null];
                              uint64_t v38 = v31;
                              a7 = v19;
                              if (v57)
                              {
                                if (v47 == result)
                                {
                                  uint64_t result = 0;
                                }
                                else
                                {
                                  uint64_t result = v47;
                                  if (!v47)
                                  {
                                    a5 = v55;
                                    uint64_t result = v59;
LABEL_49:
                                    uint64_t v40 = v46;
                                    goto LABEL_50;
                                  }
                                }
                              }
                              a5 = v55;
                              goto LABEL_49;
                            }
                          }
                        }
                        uint64_t v45 = v44;
                        goto LABEL_43;
                      }
                    }
                  }
                  uint64_t v39 = v42;
                  goto LABEL_37;
                }
              }
            }
            uint64_t v31 = v30;
            goto LABEL_31;
          }
        }
      }
    }
    uint64_t result = v59;
  }
  uint64_t v38 = result;
  uint64_t v39 = result;
  uint64_t v40 = result;
LABEL_50:
  if ((_WORD)a3 != 0xFFFF && (a3 & 0xFF0000) != 0xFF0000 && HIWORD(a3) && (a3 & 0xFFFF00000000) != 0)
  {
    unint64_t v48 = a2 & 0xFF0000 | (unsigned __int16)(a2 - 1);
    if (!(_WORD)a2) {
      unint64_t v48 = 0xFFFFFFLL;
    }
    if ((unsigned __int16)a3 <= (unsigned __int16)v48
      && (unsigned __int16)(a3 + HIWORD(a3) - 1) >= (unsigned __int16)v48)
    {
      unint64_t v49 = v48 >> 16;
      if (v49 >= BYTE2(a3) && v49 <= (BYTE4(a3) + BYTE2(a3) - 1)) {
        uint64_t v38 = 0;
      }
    }
    unint64_t v50 = (unsigned __int16)(a2 + 1) | a2 & 0xFF0000u;
    if ((~(_WORD)a2 & 0xFFFE) == 0) {
      unint64_t v50 = 0xFFFFFFLL;
    }
    if ((unsigned __int16)a3 <= (unsigned __int16)v50
      && (unsigned __int16)(a3 + HIWORD(a3) - 1) >= (unsigned __int16)v50)
    {
      unint64_t v51 = v50 >> 16;
      if (v51 >= BYTE2(a3) && v51 <= (BYTE4(a3) + BYTE2(a3) - 1)) {
        uint64_t v39 = 0;
      }
    }
    unint64_t v52 = 0xFFFFFFLL;
    if ((*(void *)&a2 & 0xFF0000) != 0) {
      unint64_t v52 = (a2 + 16711680) & 0xFF0000 | (unsigned __int16)a2;
    }
    if ((unsigned __int16)a3 <= (unsigned __int16)v52
      && (unsigned __int16)(a3 + HIWORD(a3) - 1) >= (unsigned __int16)v52)
    {
      unint64_t v53 = v52 >> 16;
      if (v53 >= BYTE2(a3) && v53 <= (BYTE4(a3) + BYTE2(a3) - 1)) {
        uint64_t v40 = 0;
      }
    }
    unint64_t v54 = (a2 + 0x10000) & 0xFF0000 | (unsigned __int16)a2;
    if ((~a2 & 0xFE0000) == 0) {
      unint64_t v54 = 0xFFFFFFLL;
    }
    if ((unsigned __int16)a3 <= (unsigned __int16)v54
      && (unsigned __int16)(a3 + HIWORD(a3) - 1) >= (unsigned __int16)v54
      && (v54 >> 16) >= BYTE2(a3)
      && (v54 >> 16) <= (BYTE4(a3) + BYTE2(a3) - 1))
    {
      uint64_t result = 0;
    }
  }
  if (a4) {
    *a4 = v38;
  }
  if (a6) {
    *a6 = v39;
  }
  if (a7) {
    *a7 = result;
  }
  if (a5) {
    *a5 = v40;
  }
  return result;
}

BOOL TSTTableHasCellID(uint64_t a1, int a2)
{
  return *(unsigned __int16 *)(a1 + 72) > (unsigned __int16)a2
      && *(unsigned __int16 *)(a1 + 74) > BYTE2(a2);
}

void p_insertObjectInDictionary(const void *key, const void *value, CFMutableDictionaryRef theDict)
{
}

double TSTWidthHeightCache_Private::WHCCol::getMaxWidth(TSTWidthHeightCache_Private::WHCCol *this)
{
  if (*(void *)this != *((void *)this + 1)) {
    return **(double **)this;
  }
  double result = -1.0;
  if (!*((unsigned char *)this + 24)) {
    return 0.0;
  }
  return result;
}

uint64_t TSTWidthHeightCache_Private::WHCCol::setWidth(TSTWidthHeightCache_Private::WHCCol *this, int a2, double a3)
{
  *(double *)&long long v40 = a3;
  DWORD2(v40) = (__int16)a2;
  unint64_t v5 = *(void *)this;
  char v4 = (char *)*((void *)this + 1);
  if (*(char **)this == v4)
  {
    if (!*((unsigned char *)this + 24))
    {
      unint64_t v14 = (char *)this + 16;
      unint64_t v15 = *((void *)this + 2);
      if (v5 < v15)
      {
        *(_OWORD *)unint64_t v5 = v40;
        int v12 = (_OWORD *)(v5 + 16);
        goto LABEL_37;
      }
      uint64_t v16 = v15 - v5;
      uint64_t v17 = v16 >> 3;
      if ((unint64_t)(v16 >> 3) <= 1) {
        uint64_t v17 = 1;
      }
      if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v18 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v18 = v17;
      }
      unsigned __int8 v19 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLength>>((uint64_t)v14, v18);
      int v21 = &v19[16 * v20];
      *(_OWORD *)unsigned __int8 v19 = v40;
      int v12 = v19 + 16;
      int v23 = *(_DWORD **)this;
      int v22 = (_DWORD *)*((void *)this + 1);
      if (v22 != *(_DWORD **)this)
      {
        do
        {
          uint64_t v24 = *((void *)v22 - 2);
          v22 -= 4;
          int v25 = v22[2];
          *((void *)v19 - 2) = v24;
          v19 -= 16;
          *((_DWORD *)v19 + 2) = v25;
        }
        while (v22 != v23);
        int v22 = *(_DWORD **)this;
      }
      *(void *)this = v19;
      *((void *)this + 1) = v12;
      *((void *)this + 2) = v21;
      if (!v22) {
        goto LABEL_37;
      }
      int v26 = v22;
LABEL_36:
      operator delete(v26);
      goto LABEL_37;
    }
    return 0;
  }
  while (*(_DWORD *)(v5 + 8) != a2)
  {
    v5 += 16;
    if ((char *)v5 == v4)
    {
      unint64_t v5 = *((void *)this + 1);
      break;
    }
  }
  if ((char *)v5 == v4)
  {
LABEL_10:
    unint64_t v9 = *(char **)this;
    uint64_t v10 = (uint64_t)&v4[-*(void *)this];
    if (*((double *)v4 - 2) <= a3)
    {
      if (v10 == 160)
      {
        *((void *)this + 1) = v4 - 16;
        v4 -= 16;
      }
      while (v9 < v4 && *(double *)v9 > a3)
        v9 += 16;
      std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::insert((uint64_t)this, v9, (char *)&v40);
      return 1;
    }
    if ((unint64_t)v10 > 0x9F)
    {
      uint64_t result = 1;
      *((unsigned char *)this + 24) = 1;
      return result;
    }
    if (!*((unsigned char *)this + 24))
    {
      unint64_t v11 = *((void *)this + 2);
      if ((unint64_t)v4 < v11)
      {
        *(_OWORD *)char v4 = v40;
        int v12 = v4 + 16;
LABEL_37:
        *((void *)this + 1) = v12;
        return 1;
      }
      uint64_t v27 = v10 >> 4;
      unint64_t v28 = (v10 >> 4) + 1;
      unint64_t v29 = v11 - (void)v9;
      unint64_t v30 = (uint64_t)(v11 - (void)v9) >> 3;
      if (v30 <= v28) {
        uint64_t v31 = v27 + 1;
      }
      else {
        uint64_t v31 = v30;
      }
      if (v29 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v32 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v32 = v31;
      }
      uint64_t v33 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLength>>((uint64_t)this + 16, v32);
      uint64_t v34 = &v33[16 * v27];
      uint64_t v36 = &v33[16 * v35];
      *(_OWORD *)uint64_t v34 = v40;
      int v12 = v34 + 16;
      uint64_t v37 = *(_DWORD **)this;
      int v26 = (_DWORD *)*((void *)this + 1);
      if (v26 != *(_DWORD **)this)
      {
        do
        {
          uint64_t v38 = *((void *)v26 - 2);
          v26 -= 4;
          int v39 = v26[2];
          *((void *)v34 - 2) = v38;
          v34 -= 16;
          *((_DWORD *)v34 + 2) = v39;
        }
        while (v26 != v37);
        int v26 = *(_DWORD **)this;
      }
      *(void *)this = v34;
      *((void *)this + 1) = v12;
      *((void *)this + 2) = v36;
      if (!v26) {
        goto LABEL_37;
      }
      goto LABEL_36;
    }
    return 0;
  }
  if (*(double *)v5 != a3)
  {
    double v7 = *((double *)v4 - 2);
    unint64_t v8 = &v4[-v5 - 16];
    if (v4 != (char *)(v5 + 16)) {
      memmove((void *)v5, (const void *)(v5 + 16), (size_t)(v8 - 4));
    }
    char v4 = &v8[v5];
    *((void *)this + 1) = &v8[v5];
    if (v7 > a3) {
      return 0;
    }
    goto LABEL_10;
  }
  return 1;
}

char *std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::insert(uint64_t a1, char *__src, char *a3)
{
  unsigned int v3 = a3;
  char v4 = __src;
  uint64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    __int16 v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 4) + 1;
    if (v14 >> 60) {
      abort();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 4;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 3 > v14) {
      unint64_t v14 = v17 >> 3;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v18 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v31 = a1 + 16;
    if (v18) {
      unsigned __int8 v19 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLength>>(a1 + 16, v18);
    }
    else {
      unsigned __int8 v19 = 0;
    }
    int v21 = &v19[16 * v16];
    __p = v19;
    unint64_t v28 = v21;
    unint64_t v29 = v21;
    unint64_t v30 = &v19[16 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v23 = 1;
        }
        else {
          unint64_t v23 = v15 >> 3;
        }
        uint64_t v24 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLength>>(v8, v23);
        int v21 = &v24[16 * (v23 >> 2)];
        __p = v24;
        unint64_t v28 = v21;
        unint64_t v30 = &v24[16 * v25];
        if (v19) {
          operator delete(v19);
        }
      }
      else
      {
        unint64_t v22 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v22 = v16 + 1;
        }
        v21 -= 16 * (v22 >> 1);
        unint64_t v28 = v21;
      }
    }
    *(_OWORD *)int v21 = *(_OWORD *)v3;
    unint64_t v29 = v21 + 16;
    char v4 = (char *)std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v4);
    if (v29 != v28) {
      v29 += (v28 - v29 + 15) & 0xFFFFFFFFFFFFFFF0;
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else if (__src == v6)
  {
    *(_OWORD *)__src = *(_OWORD *)a3;
    *(void *)(a1 + 8) = __src + 16;
  }
  else
  {
    unint64_t v9 = __src + 16;
    uint64_t v10 = v6 - 16;
    unint64_t v11 = *(_OWORD **)(a1 + 8);
    while (v10 < v6)
    {
      long long v12 = *(_OWORD *)v10;
      v10 += 16;
      *v11++ = v12;
    }
    *(void *)(a1 + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-16 * ((v6 - v9) >> 4)], __src, v6 - v9 - 4);
    }
    if (v4 <= v3) {
      v3 += 16 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    uint64_t v20 = *(void *)v3;
    *((_DWORD *)v4 + 2) = *((_DWORD *)v3 + 2);
    *(void *)char v4 = v20;
  }
  return v4;
}

void sub_2237A9698(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TSTWidthHeightCache_Private::WHCCol::resetInvalid(uint64_t this)
{
  *(unsigned char *)(this + 24) = 0;
  return this;
}

uint64_t *TSTWidthHeightCache_Private::WHCCol::resetAfter(uint64_t **this, int a2)
{
  unsigned int v3 = *this;
  char v4 = this[1];
  v6[0] = MEMORY[0x263EF8330];
  v6[1] = 3221225472;
  v6[2] = ___ZN27TSTWidthHeightCache_Private6WHCCol10resetAfterEj_block_invoke;
  v6[3] = &__block_descriptor_36_e28_B16__0r__WHCWidthBucket_dI_8l;
  int v7 = a2;
  uint64_t result = std::remove_if[abi:nn180100]<std::__wrap_iter<TSTWidthHeightCache_Private::WHCWidthBucket *>,BOOL({block_pointer})(TSTWidthHeightCache_Private::WHCWidthBucket const&)>(v3, v4, (uint64_t)v6);
  if (this[1] != result) {
    this[1] = result;
  }
  return result;
}

uint64_t *std::remove_if[abi:nn180100]<std::__wrap_iter<TSTWidthHeightCache_Private::WHCWidthBucket *>,BOOL({block_pointer})(TSTWidthHeightCache_Private::WHCWidthBucket const&)>(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  if (a1 == a2) {
    return a2;
  }
  uint64_t v5 = (uint64_t)a1;
  while (((*(uint64_t (**)(uint64_t, uint64_t))(a3 + 16))(a3, v5) & 1) == 0)
  {
    v5 += 16;
    if ((uint64_t *)v5 == a2) {
      return a2;
    }
  }
  if ((uint64_t *)v5 == a2) {
    return a2;
  }
  for (unint64_t i = (uint64_t *)(v5 + 16); i != a2; i += 2)
  {
    if (((*(uint64_t (**)(uint64_t, uint64_t *))(a3 + 16))(a3, i) & 1) == 0)
    {
      uint64_t v7 = *i;
      *(_DWORD *)(v5 + 8) = *((_DWORD *)i + 2);
      *(void *)uint64_t v5 = v7;
      v5 += 16;
    }
  }
  return (uint64_t *)v5;
}

BOOL ___ZN27TSTWidthHeightCache_Private6WHCCol10resetAfterEj_block_invoke(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a1 + 32) <= *(_DWORD *)(a2 + 8);
}

uint64_t TSTWidthHeightCache_Private::WHCCol::resetAll(uint64_t this)
{
  *(void *)(this + 8) = *(void *)this;
  *(unsigned char *)(this + 24) = 0;
  return this;
}

uint64_t *TSTWidthHeightCache_Private::WHCCol::removeRowDataInRange(uint64_t **this, int a2, int a3)
{
  uint64_t result = *this;
  uint64_t v6 = this[1];
  if (v6 != result)
  {
    v8[0] = MEMORY[0x263EF8330];
    v8[1] = 3221225472;
    v8[2] = ___ZN27TSTWidthHeightCache_Private6WHCCol20removeRowDataInRangeEjj_block_invoke;
    v8[3] = &__block_descriptor_40_e28_B16__0r__WHCWidthBucket_dI_8l;
    int v9 = a2;
    int v10 = a3;
    uint64_t result = std::remove_if[abi:nn180100]<std::__wrap_iter<TSTWidthHeightCache_Private::WHCWidthBucket *>,BOOL({block_pointer})(TSTWidthHeightCache_Private::WHCWidthBucket const&)>(result, v6, (uint64_t)v8);
    if (this[1] != result) {
      this[1] = result;
    }
  }
  return result;
}

BOOL ___ZN27TSTWidthHeightCache_Private6WHCCol20removeRowDataInRangeEjj_block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a2 + 8);
  return *(_DWORD *)(a1 + 32) <= v2 && v2 < *(_DWORD *)(a1 + 36);
}

unint64_t *TSTWidthHeightCache_Private::WHCCol::moveRowIds(unint64_t *this, unsigned int a2, int a3, unsigned int a4)
{
  unsigned int v4 = a3 + a2;
  unint64_t v5 = *this;
  unint64_t v6 = this[1];
  if (a4 <= a2)
  {
    while (v5 < v6)
    {
      unsigned int v11 = *(_DWORD *)(v5 + 8);
      if (v11 >= a2 && v11 < v4) {
        *(_DWORD *)(v5 + 8) = a4 - a2 + v11;
      }
      v5 += 16;
    }
  }
  else
  {
    for (; v5 < v6; v5 += 16)
    {
      unsigned int v7 = *(_DWORD *)(v5 + 8);
      if (v7 < a2 || v7 >= v4)
      {
        if (v4 > v7 || v7 >= a4) {
          continue;
        }
        unsigned int v10 = v7 - a3;
      }
      else
      {
        unsigned int v10 = a4 - v4 + v7;
      }
      *(_DWORD *)(v5 + 8) = v10;
    }
  }
  return this;
}

uint64_t *TSTWidthHeightCache_Private::WHCCol::insertRows(uint64_t *this, int a2, int a3)
{
  uint64_t v3 = *this;
  uint64_t v4 = this[1];
  v5[0] = MEMORY[0x263EF8330];
  v5[1] = 3221225472;
  unint64_t v6 = ___ZN27TSTWidthHeightCache_Private6WHCCol10insertRowsEjj_block_invoke;
  unsigned int v7 = &__block_descriptor_40_e27_v16__0__WHCWidthBucket_dI_8l;
  int v8 = a3;
  int v9 = a2;
  while (v3 != v4)
  {
    this = (uint64_t *)v6((uint64_t)v5, v3);
    v3 += 16;
  }
  return this;
}

uint64_t ___ZN27TSTWidthHeightCache_Private6WHCCol10insertRowsEjj_block_invoke(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a2 + 8);
  if (v2 >= *(_DWORD *)(result + 32)) {
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(result + 36) + v2;
  }
  return result;
}

double TSTWidthHeightCache_Private::WHCRow::getMaxHeight(TSTWidthHeightCache_Private::WHCRow *this)
{
  uint64_t v1 = *((void *)this + 16);
  if (v1 != *((void *)this + 17)) {
    return *(double *)v1;
  }
  double result = -1.0;
  if (!*((unsigned char *)this + 160)) {
    return 0.0;
  }
  return result;
}

uint64_t TSTWidthHeightCache_Private::WHCRow::setHeight(TSTWidthHeightCache_Private::WHCRow *this, unsigned int a2, double a3)
{
  int v6 = TSTWidthHeightCache_NibArray::NibArray<8u>::get((uint64_t)this, a2);
  if ((v6 - 16) <= 0xFFFFFFFD)
  {
    uint64_t v8 = *((void *)this + 16);
    uint64_t v7 = *((void *)this + 17);
    uint64_t v9 = v8;
    if (v8 != v7)
    {
      while (*(unsigned __int8 *)(v9 + 8) != v6)
      {
        v9 += 16;
        if (v9 == v7)
        {
          uint64_t v9 = *((void *)this + 17);
          break;
        }
      }
    }
    if (*(double *)v9 == a3) {
      return 1;
    }
    uint64_t v10 = v8 + 16 * ((v9 - v8) >> 4);
    char v11 = *(unsigned char *)(v10 + 9) - 1;
    *(unsigned char *)(v10 + 9) = v11;
    if (!v11)
    {
      unint64_t v12 = *(unsigned __int8 *)(v10 + 8);
      if (v12 >= 0xE) {
        goto LABEL_31;
      }
      *((void *)this + 19) &= ~(1 << v12);
      uint64_t v13 = v7 - (v9 + 16);
      if (v7 != v9 + 16) {
        memmove((void *)v9, (const void *)(v9 + 16), v13 - 6);
      }
      *((void *)this + 17) = v9 + v13;
    }
    TSTWidthHeightCache_NibArray::NibArray<8u>::set((uint64_t)this, a2, 15);
  }
  unint64_t v14 = *((void *)this + 16);
  unint64_t v15 = *((void *)this + 17);
  if (v14 == v15)
  {
    if (!*((unsigned char *)this + 160))
    {
      unint64_t v19 = *((void *)this + 18);
      *((void *)this + 19) |= 1uLL;
      if (v14 >= v19)
      {
        uint64_t v26 = v19 - v14;
        uint64_t v27 = v26 >> 3;
        if ((unint64_t)(v26 >> 3) <= 1) {
          uint64_t v27 = 1;
        }
        if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v28 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v28 = v27;
        }
        unint64_t v29 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLength>>((uint64_t)this + 144, v28);
        uint64_t v31 = &v29[16 * v30];
        *(double *)unint64_t v29 = a3;
        *((_WORD *)v29 + 4) = 256;
        uint64_t v20 = v29 + 16;
        uint64_t v33 = (_WORD *)*((void *)this + 16);
        unint64_t v32 = (_WORD *)*((void *)this + 17);
        if (v32 != v33)
        {
          do
          {
            uint64_t v34 = *((void *)v32 - 2);
            v32 -= 8;
            __int16 v35 = v32[4];
            *((void *)v29 - 2) = v34;
            v29 -= 16;
            *((_WORD *)v29 + 4) = v35;
          }
          while (v32 != v33);
          unint64_t v32 = (_WORD *)*((void *)this + 16);
        }
        *((void *)this + 16) = v29;
        *((void *)this + 17) = v20;
        *((void *)this + 18) = v31;
        if (v32) {
          operator delete(v32);
        }
      }
      else
      {
        *(double *)unint64_t v14 = a3;
        *(_WORD *)(v14 + 8) = 256;
        uint64_t v20 = (char *)(v14 + 16);
      }
      *((void *)this + 17) = v20;
      uint64_t v16 = this;
      unsigned int v17 = a2;
      char v18 = 0;
      goto LABEL_47;
    }
    goto LABEL_26;
  }
  if (*(double *)(v15 - 16) <= a3)
  {
    if (v14 >= v15)
    {
      int v21 = (char *)*((void *)this + 16);
    }
    else
    {
      int v21 = (char *)*((void *)this + 16);
      while (*(double *)v21 > a3)
      {
        v21 += 16;
        if ((unint64_t)v21 >= v15) {
          goto LABEL_28;
        }
      }
      if (*(double *)v21 == a3)
      {
        TSTWidthHeightCache_NibArray::NibArray<8u>::set((uint64_t)this, a2, v21[8]);
        ++v21[9];
        return 1;
      }
      if (v15 - v14 == 224)
      {
        TSTWidthHeightCache_NibArray::NibArray<8u>::setValueToValue((uint64_t)this, *(unsigned __int8 *)(v15 - 8), 14, *(unsigned __int8 *)(v15 - 7), 0x100u);
        uint64_t v37 = *((void *)this + 17);
        uint64_t v38 = v37 - 16;
        if (v21 == (char *)(v37 - 16))
        {
          TSTWidthHeightCache_NibArray::NibArray<8u>::set((uint64_t)this, a2, v21[8]);
          *(double *)int v21 = a3;
          uint64_t v22 = 1;
          v21[9] = 1;
          return v22;
        }
        unint64_t v39 = *(unsigned __int8 *)(v37 - 8);
        if (v39 >= 0xE) {
          goto LABEL_31;
        }
        *((void *)this + 19) &= ~(1 << v39);
        *((void *)this + 17) = v38;
      }
    }
LABEL_28:
    uint64_t v23 = 0;
    unint64_t v24 = *((void *)this + 19);
    while (((v24 >> v23) & 1) != 0)
    {
      if (++v23 == 14) {
        goto LABEL_31;
      }
    }
    char v25 = v23;
    if (v23 < 0xEu)
    {
      uint64_t v22 = 1;
      *((void *)this + 19) = v24 | (1 << v23);
      v40.n128_f64[0] = a3;
      v40.n128_u8[8] = v23;
      v40.n128_u8[9] = 1;
      std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::insert((uint64_t)this + 128, v21, &v40);
      TSTWidthHeightCache_NibArray::NibArray<8u>::set((uint64_t)this, a2, v25);
      return v22;
    }
LABEL_31:
    abort();
  }
  if (v15 - v14 == 224)
  {
    uint64_t v16 = this;
    unsigned int v17 = a2;
    char v18 = 14;
LABEL_47:
    TSTWidthHeightCache_NibArray::NibArray<8u>::set((uint64_t)v16, v17, v18);
    return 1;
  }
  int v21 = (char *)*((void *)this + 17);
  if (!*((unsigned char *)this + 160)) {
    goto LABEL_28;
  }
LABEL_26:
  TSTWidthHeightCache_NibArray::NibArray<8u>::set((uint64_t)this, a2, 14);
  return 0;
}

uint64_t TSTWidthHeightCache_NibArray::NibArray<8u>::get(uint64_t a1, unsigned int a2)
{
  unsigned __int8 v2 = a2;
  if (a2 >= 0x100)
  {
    uint64_t v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = [NSString stringWithUTF8String:"uint8_t TSTWidthHeightCache_NibArray::NibArray<8>::get(uint) [log2NumElements = 8]"];
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTWidthHeightCache_NibArray.h"), 58, @"getting an element past the end of the nibble array.");
  }
  return (*(unsigned __int8 *)(a1 + (v2 >> 1)) >> (4 * (v2 & 1))) & 0xF;
}

uint64_t TSTWidthHeightCache_NibArray::NibArray<8u>::set(uint64_t result, unsigned int a2, char a3)
{
  unsigned __int8 v4 = a2;
  uint64_t v5 = result;
  if (a2 >= 0x100)
  {
    int v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTWidthHeightCache_NibArray::NibArray<8>::set(uint, uint8_t) [log2NumElements = 8]");
    double result = objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTWidthHeightCache_NibArray.h"), 50, @"setting an element past the end of the nibble array.");
  }
  *(unsigned char *)(v5 + (v4 >> 1)) = (0xF0u >> (4 * (v4 & 1))) & *(unsigned char *)(v5 + (v4 >> 1)) | ((a3 & 0xF) << (4 * (v4 & 1)));
  return result;
}

uint64_t TSTWidthHeightCache_NibArray::NibArray<8u>::setValueToValue(uint64_t a1, int a2, char a3, uint64_t a4, unsigned int a5)
{
  if (a5 >= 0x101)
  {
    uint64_t v10 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v11 = objc_msgSend(NSString, "stringWithUTF8String:", "uint TSTWidthHeightCache_NibArray::NibArray<8>::setValueToValue(uint8_t, uint8_t, uint, uint) [log2NumElements = 8]");
    objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTWidthHeightCache_NibArray.h"), 96, @"hint exceeds array length");
  }
  if (a5 >= 0x100) {
    int v12 = 256;
  }
  else {
    int v12 = a5;
  }
  if (!v12) {
    return 0;
  }
  uint64_t v13 = 0;
  unsigned int v14 = 0;
  while (1)
  {
    if (TSTWidthHeightCache_NibArray::NibArray<8u>::get(a1, v14) == a2)
    {
      TSTWidthHeightCache_NibArray::NibArray<8u>::set(a1, v14, a3);
      uint64_t v13 = (v13 + 1);
      if (v13 == a4) {
        break;
      }
    }
    if (v12 == ++v14) {
      return v13;
    }
  }
  return a4;
}

char *std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::insert(uint64_t a1, char *__src, __n128 *a3)
{
  unsigned __int8 v4 = __src;
  int v6 = *(char **)(a1 + 8);
  unint64_t v9 = *(void *)(a1 + 16);
  uint64_t v7 = a1 + 16;
  unint64_t v8 = v9;
  if ((unint64_t)v6 >= v9)
  {
    unsigned int v14 = *(unsigned char **)a1;
    unint64_t v15 = ((uint64_t)&v6[-*(void *)a1] >> 4) + 1;
    if (v15 >> 60) {
      abort();
    }
    uint64_t v16 = (__src - v14) >> 4;
    uint64_t v17 = v8 - (void)v14;
    if (v17 >> 3 > v15) {
      unint64_t v15 = v17 >> 3;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v18 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v15;
    }
    uint64_t v26 = v7;
    if (v18) {
      unint64_t v19 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLength>>(v7, v18);
    }
    else {
      unint64_t v19 = 0;
    }
    __p = v19;
    uint64_t v23 = &v19[16 * v16];
    unint64_t v24 = v23;
    char v25 = &v19[16 * v18];
    std::__split_buffer<TSTWidthHeightCache_Private::WHCHeightBucket>::push_back((__n128 **)&__p, a3);
    unsigned __int8 v4 = (char *)std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v4);
    if (v24 != v23) {
      v24 += (v23 - v24 + 15) & 0xFFFFFFFFFFFFFFF0;
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else if (__src == v6)
  {
    *(__n128 *)__src = *a3;
    *(void *)(a1 + 8) = __src + 16;
  }
  else
  {
    uint64_t v10 = __src + 16;
    uint64_t v11 = v6 - 16;
    int v12 = v6;
    while (v11 < v6)
    {
      long long v13 = *(_OWORD *)v11;
      v11 += 16;
      *(_OWORD *)int v12 = v13;
      v12 += 16;
    }
    *(void *)(a1 + 8) = v12;
    if (v6 != v10) {
      memmove(&v6[-16 * ((v6 - v10) >> 4)], __src, v6 - v10 - 6);
    }
    unint64_t v20 = a3->n128_u64[0];
    *((_WORD *)v4 + 4) = a3->n128_u16[4];
    *(void *)unsigned __int8 v4 = v20;
  }
  return v4;
}

void sub_2237AA1EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TSTWidthHeightCache_Private::WHCRow::getNumInvalid(TSTWidthHeightCache_Private::WHCRow *this)
{
  return *((unsigned __int8 *)this + 160);
}

uint64_t TSTWidthHeightCache_Private::WHCRow::getNextInvalid(TSTWidthHeightCache_Private::WHCRow *this, uint64_t a2)
{
  if (a2 <= 0xFF)
  {
    char v2 = 4 * a2;
    do
    {
      if (*((unsigned __int8 *)this + ((unint64_t)a2 >> 1)) >> (v2 & 4) == 14) {
        break;
      }
      a2 = (a2 + 1);
      v2 += 4;
    }
    while (a2 != 256);
  }
  return a2;
}

uint64_t TSTWidthHeightCache_Private::WHCRow::resetInvalid(TSTWidthHeightCache_Private::WHCRow *this)
{
  return TSTWidthHeightCache_NibArray::NibArray<8u>::setValueToValue((uint64_t)this, 14, 15, *((unsigned __int8 *)this + 160), 0x100u);
}

void TSTWidthHeightCache_Private::WHCRow::resetAll(TSTWidthHeightCache_Private::WHCRow *this)
{
  *(void *)&long long v2 = -1;
  *((void *)&v2 + 1) = -1;
  *((_OWORD *)this + 6) = v2;
  *((_OWORD *)this + 7) = v2;
  *((_OWORD *)this + 4) = v2;
  *((_OWORD *)this + 5) = v2;
  *((_OWORD *)this + 2) = v2;
  *((_OWORD *)this + 3) = v2;
  *(_OWORD *)this = v2;
  *((_OWORD *)this + 1) = v2;
  uint64_t v3 = (char *)this + 152;
  int v4 = 0;
  std::__fill_n[abi:nn180100]<false,std::__bitset<1ul,14ul>>((uint64_t)&v3, 0xEuLL);
  *((void *)this + 17) = *((void *)this + 16);
  *((unsigned char *)this + 160) = 0;
}

uint64_t TSTWidthHeightCache_Private::WHCRow::resetAfter(uint64_t this, unsigned int a2, unsigned int a3)
{
  if (a2 <= a3)
  {
    int v4 = (void *)this;
    while (1)
    {
      unsigned int v5 = a2;
      this = TSTWidthHeightCache_NibArray::NibArray<8u>::get((uint64_t)v4, a2);
      if (this == 14) {
        goto LABEL_14;
      }
      if (this != 15) {
        break;
      }
LABEL_15:
      LOBYTE(a2) = v5 + 1;
      if (a3 < (v5 + 1)) {
        return this;
      }
    }
    uint64_t v7 = (unsigned __int8 *)v4[16];
    int v6 = (unsigned __int8 *)v4[17];
    if (v7 != v6)
    {
      while (v7[8] != this)
      {
        v7 += 16;
        if (v7 == v6)
        {
          uint64_t v7 = (unsigned __int8 *)v4[17];
          break;
        }
      }
    }
    unsigned __int8 v8 = v7[9] - 1;
    v7[9] = v8;
    if (!v8)
    {
      if (this >= 0xE) {
        abort();
      }
      v4[19] &= ~(1 << this);
      int64_t v9 = v6 - (v7 + 16);
      if (v6 != v7 + 16) {
        memmove(v7, v7 + 16, v9 - 6);
      }
      v4[17] = &v7[v9];
    }
LABEL_14:
    this = TSTWidthHeightCache_NibArray::NibArray<8u>::set((uint64_t)v4, v5, 15);
    goto LABEL_15;
  }
  return this;
}

uint64_t TSTWidthHeightCache_Private::WHCRow::resetColDataInRange(uint64_t this, unsigned int a2, unsigned int a3)
{
  if (a2 < a3)
  {
    unsigned int v4 = a2;
    unsigned int v5 = (void *)this;
    while (1)
    {
      this = TSTWidthHeightCache_NibArray::NibArray<8u>::get((uint64_t)v5, v4);
      if (this == 14) {
        goto LABEL_14;
      }
      if (this != 15) {
        break;
      }
LABEL_15:
      if (++v4 == a3) {
        return this;
      }
    }
    uint64_t v7 = (unsigned __int8 *)v5[16];
    int v6 = (unsigned __int8 *)v5[17];
    if (v7 != v6)
    {
      while (v7[8] != this)
      {
        v7 += 16;
        if (v7 == v6)
        {
          uint64_t v7 = (unsigned __int8 *)v5[17];
          break;
        }
      }
    }
    unsigned __int8 v8 = v7[9] - 1;
    v7[9] = v8;
    if (!v8)
    {
      if (this >= 0xE) {
        abort();
      }
      v5[19] &= ~(1 << this);
      int64_t v9 = v6 - (v7 + 16);
      if (v6 != v7 + 16) {
        memmove(v7, v7 + 16, v9 - 6);
      }
      v5[17] = &v7[v9];
    }
LABEL_14:
    this = TSTWidthHeightCache_NibArray::NibArray<8u>::set((uint64_t)v5, v4, 15);
    goto LABEL_15;
  }
  return this;
}

void *TSTWidthHeightCache_Private::WHCRow::moveColIds(TSTWidthHeightCache_Private::WHCRow *this, unsigned int a2, int a3, unsigned int a4)
{
  return TSTWidthHeightCache_NibArray::NibArray<8u>::move((uint64_t)this, a2, a3 + a2, a4, 256);
}

void *TSTWidthHeightCache_NibArray::NibArray<8u>::move(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  LODWORD(v5) = a5;
  unsigned __int8 v8 = a2;
  int64_t v9 = (unsigned __int8 *)a1;
  v34[1] = *MEMORY[0x263EF8340];
  if (a2 >= 0x100)
  {
    uint64_t v10 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v11 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTWidthHeightCache_NibArray::NibArray<8>::move(uint, uint, uint, uint) [log2NumElements = 8]");
    a1 = objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTWidthHeightCache_NibArray.h"), 130, @"src begin index exceeds array ");
  }
  if (a3 >= 0x100)
  {
    int v12 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v13 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTWidthHeightCache_NibArray::NibArray<8>::move(uint, uint, uint, uint) [log2NumElements = 8]");
    a1 = objc_msgSend(v12, "handleFailureInFunction:file:lineNumber:description:", v13, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTWidthHeightCache_NibArray.h"), 133, @"src end index exceeds array");
  }
  int v14 = v8;
  unsigned int v15 = a3;
  if (v5 >= 0x101)
  {
    uint64_t v16 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v17 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTWidthHeightCache_NibArray::NibArray<8>::move(uint, uint, uint, uint) [log2NumElements = 8]");
    a1 = objc_msgSend(v16, "handleFailureInFunction:file:lineNumber:description:", v17, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTWidthHeightCache_NibArray.h"), 136, @"hint exceeds array length");
  }
  if (v5 >= 0x100) {
    unint64_t v5 = 256;
  }
  else {
    unint64_t v5 = v5;
  }
  uint64_t v18 = v15 - v14;
  if (v18 + a4 >= 0x101)
  {
    unint64_t v28 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v29 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTWidthHeightCache_NibArray::NibArray<8>::move(uint, uint, uint, uint) [log2NumElements = 8]");
    uint64_t v30 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTWidthHeightCache_NibArray.h"];
    return (void *)[v28 handleFailureInFunction:v29 file:v30 lineNumber:139 description:@"end of destination exceeds array length"];
  }
  else
  {
    uint64_t v19 = MEMORY[0x270FA5388](a1);
    unint64_t v20 = (char *)v34 - ((v5 + 15) & 0x1FFFFFFF0);
    MEMORY[0x270FA5388](v19);
    uint64_t v22 = (char *)v34 - v21;
    if (v5)
    {
      unint64_t v23 = 0;
      unint64_t v24 = v9;
      do
      {
        unsigned int v25 = *v24++;
        uint64_t v26 = &v20[v23];
        char *v26 = v25 & 0xF;
        v26[1] = v25 >> 4;
        v23 += 2;
      }
      while (v23 < v5);
    }
    memcpy(v22, &v20[v14], v15 - v14);
    if (a4 <= v15)
    {
      uint64_t v27 = a4;
      memmove(&v20[a4 + v18], &v20[a4], v14 - a4);
    }
    else
    {
      memmove(&v20[v14], &v20[v15], a4 - v15);
      uint64_t v27 = a4 - v18;
    }
    double result = memcpy(&v20[v27], v22, v15 - v14);
    if (v5)
    {
      uint64_t v32 = ((v5 - 1) >> 1) + 1;
      uint64_t v33 = v20 + 1;
      do
      {
        *v9++ = *(v33 - 1) | (16 * *v33);
        v33 += 2;
        --v32;
      }
      while (v32);
    }
  }
  return result;
}

uint64_t TSTWidthHeightCache_Private::WHCRow::insertCols(TSTWidthHeightCache_Private::WHCRow *this, int a2, unsigned int a3)
{
  return TSTWidthHeightCache_NibArray::NibArray<8u>::insert((uint64_t)this, a2, a3, 15);
}

uint64_t TSTWidthHeightCache_NibArray::NibArray<8u>::insert(uint64_t result, int a2, unsigned int a3, char a4)
{
  uint64_t v7 = result;
  unsigned int v8 = a3 + a2;
  if (a3 + a2 > 0xFF)
  {
    int64_t v9 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v10 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTWidthHeightCache_NibArray::NibArray<8>::insert(uint, uint, uint8_t) [log2NumElements = 8]");
    double result = objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTWidthHeightCache_NibArray.h"), 184, @"destination exceeds array bounds");
    if (!a2) {
      return result;
    }
    unsigned int v8 = 256;
  }
  else
  {
    if (!a2) {
      return result;
    }
    if ((v8 ^ a3))
    {
      int v11 = -a2;
      unsigned int v12 = 255;
      do
      {
        char v13 = TSTWidthHeightCache_NibArray::NibArray<8u>::get(v7, v11 + v12);
        TSTWidthHeightCache_NibArray::NibArray<8u>::set(v7, v12--, v13);
      }
      while (v12 >= v8);
    }
    else
    {
      memmove((void *)(result + (v8 >> 1)), (const void *)(result + (a3 >> 1)), (256 - v8) >> 1);
    }
  }

  return TSTWidthHeightCache_NibArray::NibArray<8u>::setRange(v7, a3, v8, a4);
}

uint64_t std::vector<TSTWidthHeightCache_Private::WHCCol>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 5)
  {
    if (a2 >> 59) {
      abort();
    }
    uint64_t v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:nn180100]<std::allocator<EQKit::OpticalKern::Edge::CGPointVector>>(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 32 * v6;
    std::vector<TSTWidthHeightCache_Private::WHCCol>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<TSTWidthHeightCache_Private::WHCCol>::~__split_buffer((uint64_t)v7);
  }
  return result;
}

void sub_2237AAA64(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TSTWidthHeightCache_Private::WHCCol>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<TSTWidthHeightCache_Private::WHCCol>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = (v3 - *a1) >> 5;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      uint64_t v6 = *a1 + 32 * a2;
      if (v3 != v6)
      {
        uint64_t v7 = a1[1];
        do
        {
          int64_t v9 = *(void **)(v7 - 32);
          v7 -= 32;
          unsigned int v8 = v9;
          if (v9)
          {
            *(void *)(v3 - 24) = v8;
            operator delete(v8);
          }
          uint64_t v3 = v7;
        }
        while (v7 != v6);
      }
      a1[1] = v6;
    }
  }
  else
  {
    unint64_t v5 = a2 - v4;
    std::vector<TSTWidthHeightCache_Private::WHCCol>::__append(a1, v5);
  }
}

void std::vector<TSTWidthHeightCache_Private::WHCRow>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0xCF3CF3CF3CF3CF3DLL * ((v3 - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<TSTWidthHeightCache_Private::WHCRow>::__append(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 168 * a2;
    while (v3 != v7)
    {
      unsigned int v8 = *(void **)(v3 - 40);
      if (v8)
      {
        *(void *)(v3 - 32) = v8;
        operator delete(v8);
      }
      v3 -= 168;
    }
    a1[1] = v7;
  }
}

char *std::vector<TSTWidthHeightCache_Private::WHCCol>::erase(uint64_t a1, char *a2, uint64_t a3)
{
  if (a2 != (char *)a3)
  {
    std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *>((int)&v12, a3, *(void *)(a1 + 8), a2);
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)(a1 + 8);
    if (v7 != v5)
    {
      uint64_t v8 = *(void *)(a1 + 8);
      do
      {
        uint64_t v10 = *(void **)(v8 - 32);
        v8 -= 32;
        int64_t v9 = v10;
        if (v10)
        {
          *(void *)(v7 - 24) = v9;
          operator delete(v9);
        }
        uint64_t v7 = v8;
      }
      while (v8 != v6);
    }
    *(void *)(a1 + 8) = v6;
  }
  return a2;
}

uint64_t std::vector<TSTWidthHeightCache_Private::WHCRow>::erase(uint64_t a1, uint64_t a2, long long *a3)
{
  if ((long long *)a2 != a3)
  {
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *,0>(a3, *(long long **)(a1 + 8), a2);
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)(a1 + 8);
    if (v7 != v5)
    {
      do
      {
        uint64_t v8 = *(void **)(v7 - 40);
        if (v8)
        {
          *(void *)(v7 - 32) = v8;
          operator delete(v8);
        }
        v7 -= 168;
      }
      while (v7 != v6);
    }
    *(void *)(a1 + 8) = v6;
  }
  return a2;
}

void sub_2237AB630(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<TSTWidthHeightCache_Private::WHCCol>::insert(uint64_t *a1, char *a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4 = a2;
  if (a3)
  {
    uint64_t v10 = a1[2];
    uint64_t v8 = (uint64_t)(a1 + 2);
    uint64_t v9 = v10;
    unint64_t v11 = *(void *)(v8 - 8);
    if (a3 <= (uint64_t)(v10 - v11) >> 5)
    {
      uint64_t v18 = v11 - (void)a2;
      uint64_t v19 = a3;
      if (a3 <= (uint64_t)(v11 - (void)a2) >> 5) {
        goto LABEL_15;
      }
      uint64_t v20 = 0;
      uint64_t v19 = v18 >> 5;
      unint64_t v21 = v11 + 32 * (a3 - (v18 >> 5));
      uint64_t v22 = 32 * a3 - 32 * (v18 >> 5);
      do
      {
        std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::vector((void *)(v11 + v20), a4);
        *(unsigned char *)(v11 + v20 + 24) = *(unsigned char *)(a4 + 24);
        v20 += 32;
      }
      while (v22 != v20);
      a1[1] = v21;
      if ((char *)v11 != v4)
      {
LABEL_15:
        std::vector<TSTWidthHeightCache_Private::WHCCol>::__move_range((uint64_t)a1, (uint64_t)v4, v11, (uint64_t)&v4[32 * a3]);
        if ((unint64_t)v4 <= a4)
        {
          if (a1[1] <= a4) {
            unint64_t v23 = 0;
          }
          else {
            unint64_t v23 = a3;
          }
          a4 += 32 * v23;
        }
        unint64_t v24 = v4;
        do
        {
          if (v24 != (char *)a4) {
            std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::__assign_with_size[abi:nn180100]<TSTWidthHeightCache_Private::WHCWidthBucket*,TSTWidthHeightCache_Private::WHCWidthBucket*>(v24, *(char **)a4, *(void *)(a4 + 8), (uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 4);
          }
          v24[24] = *(unsigned char *)(a4 + 24);
          v24 += 32;
          --v19;
        }
        while (v19);
      }
    }
    else
    {
      uint64_t v12 = *a1;
      unint64_t v13 = a3 + ((uint64_t)(v11 - *a1) >> 5);
      if (v13 >> 59) {
        abort();
      }
      uint64_t v14 = (uint64_t)&a2[-v12] >> 5;
      uint64_t v15 = v9 - v12;
      if (v15 >> 4 > v13) {
        unint64_t v13 = v15 >> 4;
      }
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v16 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v16 = v13;
      }
      uint64_t v32 = v8;
      if (v16) {
        uint64_t v17 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKit::OpticalKern::Edge::CGPointVector>>(v8, v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unsigned int v25 = &v17[32 * v14];
      v29[0] = v17;
      v29[1] = v25;
      uint64_t v30 = v25;
      uint64_t v31 = &v17[32 * v16];
      uint64_t v26 = 32 * a3;
      uint64_t v27 = &v25[32 * a3];
      do
      {
        std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::vector(v25, a4);
        v25[24] = *(unsigned char *)(a4 + 24);
        v25 += 32;
        v26 -= 32;
      }
      while (v26);
      uint64_t v30 = v27;
      unint64_t v4 = (char *)std::vector<TSTWidthHeightCache_Private::WHCCol>::__swap_out_circular_buffer(a1, v29, (uint64_t)v4);
      std::__split_buffer<TSTWidthHeightCache_Private::WHCCol>::~__split_buffer((uint64_t)v29);
    }
  }
  return v4;
}

void sub_2237AB824(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TSTWidthHeightCache_Private::WHCCol>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

char *std::vector<double>::insert(uint64_t a1, char *__src, unint64_t a3, char *a4)
{
  unint64_t v4 = __src;
  if (a3)
  {
    uint64_t v5 = a4;
    uint64_t v10 = *(void *)(a1 + 16);
    uint64_t v8 = a1 + 16;
    uint64_t v9 = v10;
    unint64_t v11 = *(char **)(v8 - 8);
    if (a3 <= (v10 - (uint64_t)v11) >> 3)
    {
      uint64_t v18 = v11 - __src;
      if (a3 <= (v11 - __src) >> 3)
      {
        unint64_t v21 = *(char **)(v8 - 8);
        uint64_t v20 = a3;
      }
      else
      {
        uint64_t v19 = 0;
        uint64_t v20 = v18 >> 3;
        unint64_t v21 = &v11[8 * (a3 - (v18 >> 3))];
        do
        {
          *(void *)&v11[v19] = *(void *)a4;
          v19 += 8;
        }
        while (8 * a3 - 8 * v20 != v19);
        *(void *)(a1 + 8) = v21;
        if (v11 == __src) {
          return v4;
        }
      }
      uint64_t v22 = &__src[8 * a3];
      unint64_t v23 = &v21[-8 * a3];
      unint64_t v24 = v21;
      if (v23 < v11)
      {
        unint64_t v24 = v21;
        do
        {
          uint64_t v25 = *(void *)v23;
          v23 += 8;
          *(void *)unint64_t v24 = v25;
          v24 += 8;
        }
        while (v23 < v11);
      }
      *(void *)(a1 + 8) = v24;
      if (v21 != v22) {
        memmove(&v21[-8 * ((v21 - v22) >> 3)], __src, v21 - v22);
      }
      if (v4 <= v5)
      {
        if (*(void *)(a1 + 8) <= (unint64_t)v5) {
          unint64_t v26 = 0;
        }
        else {
          unint64_t v26 = a3;
        }
        v5 += 8 * v26;
      }
      uint64_t v27 = v4;
      do
      {
        *(void *)uint64_t v27 = *(void *)v5;
        v27 += 8;
        --v20;
      }
      while (v20);
    }
    else
    {
      uint64_t v12 = *(unsigned char **)a1;
      unint64_t v13 = a3 + ((uint64_t)&v11[-*(void *)a1] >> 3);
      if (v13 >> 61) {
        abort();
      }
      uint64_t v14 = (__src - v12) >> 3;
      uint64_t v15 = v9 - (void)v12;
      if (v15 >> 2 > v13) {
        unint64_t v13 = v15 >> 2;
      }
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v16 = v13;
      }
      uint64_t v36 = v8;
      if (v16) {
        uint64_t v17 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLayoutContext *>>(v8, v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v28 = &v17[8 * v14];
      __p = v17;
      uint64_t v33 = v28;
      __int16 v35 = &v17[8 * v16];
      uint64_t v29 = 8 * a3;
      uint64_t v30 = &v28[8 * a3];
      do
      {
        *(void *)unint64_t v28 = *(void *)v5;
        v28 += 8;
        v29 -= 8;
      }
      while (v29);
      uint64_t v34 = v30;
      unint64_t v4 = std::vector<double>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v4);
      if (v34 != v33) {
        v34 += (v33 - v34 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      if (__p) {
        operator delete(__p);
      }
    }
  }
  return v4;
}

void sub_2237ABA38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_2237ABBF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

long long *std::vector<TSTWidthHeightCache_Private::WHCRow>::insert(uint64_t *a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v4 = *a1;
  uint64_t v5 = (a2 - *a1) / 168;
  uint64_t v6 = (long long *)(*a1 + 168 * v5);
  if (a3)
  {
    uint64_t v9 = (uint64_t)a1;
    uint64_t v12 = a1[2];
    uint64_t v10 = (uint64_t)(a1 + 2);
    uint64_t v11 = v12;
    unint64_t v13 = *(void *)(v10 - 8);
    if (0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(v12 - v13) >> 3) >= a3)
    {
      unint64_t v18 = 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(v13 - (void)v6) >> 3);
      unint64_t v19 = a3;
      if (a3 <= v18) {
        goto LABEL_15;
      }
      unint64_t v51 = v6;
      uint64_t v52 = v9;
      uint64_t v20 = 0;
      unint64_t v19 = v18;
      unint64_t v50 = v13 + 168 * (a3 - v18);
      uint64_t v21 = 168 * a3 - 168 * v18;
      do
      {
        uint64_t v22 = v13 + v20;
        long long v23 = *(_OWORD *)a4;
        long long v24 = *(_OWORD *)(a4 + 16);
        long long v25 = *(_OWORD *)(a4 + 48);
        *(_OWORD *)(v22 + 32) = *(_OWORD *)(a4 + 32);
        *(_OWORD *)(v22 + 48) = v25;
        *(_OWORD *)uint64_t v22 = v23;
        *(_OWORD *)(v22 + 16) = v24;
        long long v26 = *(_OWORD *)(a4 + 64);
        long long v27 = *(_OWORD *)(a4 + 80);
        long long v28 = *(_OWORD *)(a4 + 112);
        *(_OWORD *)(v22 + 96) = *(_OWORD *)(a4 + 96);
        *(_OWORD *)(v22 + 112) = v28;
        *(_OWORD *)(v22 + 64) = v26;
        *(_OWORD *)(v22 + 80) = v27;
        std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::vector((void *)(v13 + v20 + 128), a4 + 128);
        uint64_t v29 = *(void *)(a4 + 152);
        *(unsigned char *)(v22 + 160) = *(unsigned char *)(a4 + 160);
        *(void *)(v22 + 152) = v29;
        v20 += 168;
      }
      while (v21 != v20);
      uint64_t v6 = v51;
      uint64_t v9 = v52;
      *(void *)(v52 + 8) = v50;
      if ((long long *)v13 != v51)
      {
LABEL_15:
        std::vector<TSTWidthHeightCache_Private::WHCRow>::__move_range(v9, (uint64_t)v6, v13, (uint64_t)v6 + 168 * a3);
        if ((unint64_t)v6 <= a4)
        {
          if (*(void *)(v9 + 8) <= a4) {
            unint64_t v30 = 0;
          }
          else {
            unint64_t v30 = a3;
          }
          a4 += 168 * v30;
        }
        uint64_t v31 = v4 + 168 * v5 + 128;
        do
        {
          long long v32 = *(_OWORD *)a4;
          long long v33 = *(_OWORD *)(a4 + 16);
          long long v34 = *(_OWORD *)(a4 + 48);
          *(_OWORD *)(v31 - 96) = *(_OWORD *)(a4 + 32);
          *(_OWORD *)(v31 - 80) = v34;
          *(_OWORD *)(v31 - 128) = v32;
          *(_OWORD *)(v31 - 112) = v33;
          long long v35 = *(_OWORD *)(a4 + 64);
          long long v36 = *(_OWORD *)(a4 + 80);
          long long v37 = *(_OWORD *)(a4 + 112);
          *(_OWORD *)(v31 - 32) = *(_OWORD *)(a4 + 96);
          *(_OWORD *)(v31 - 16) = v37;
          *(_OWORD *)(v31 - 64) = v35;
          *(_OWORD *)(v31 - 48) = v36;
          if (v31 - 128 != a4) {
            std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::__assign_with_size[abi:nn180100]<TSTWidthHeightCache_Private::WHCHeightBucket*,TSTWidthHeightCache_Private::WHCHeightBucket*>((char *)v31, *(char **)(a4 + 128), *(void *)(a4 + 136), (uint64_t)(*(void *)(a4 + 136) - *(void *)(a4 + 128)) >> 4);
          }
          uint64_t v38 = *(void *)(a4 + 152);
          *(unsigned char *)(v31 + 32) = *(unsigned char *)(a4 + 160);
          *(void *)(v31 + 24) = v38;
          v31 += 168;
          --v19;
        }
        while (v19);
      }
    }
    else
    {
      unint64_t v14 = a3 - 0x30C30C30C30C30C3 * ((uint64_t)(v13 - v4) >> 3);
      if (v14 > 0x186186186186186) {
        abort();
      }
      unint64_t v15 = 0xCF3CF3CF3CF3CF3DLL * ((v11 - v4) >> 3);
      if (2 * v15 > v14) {
        unint64_t v14 = 2 * v15;
      }
      if (v15 >= 0xC30C30C30C30C3) {
        unint64_t v16 = 0x186186186186186;
      }
      else {
        unint64_t v16 = v14;
      }
      uint64_t v56 = v10;
      if (v16) {
        uint64_t v17 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<TSTWidthHeightCache_Private::WHCRow>>(v10, v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unint64_t v39 = &v17[168 * v5];
      v53[0] = v17;
      v53[1] = v39;
      unint64_t v54 = v39;
      unint64_t v55 = &v17[168 * v16];
      uint64_t v40 = 168 * a3;
      uint64_t v41 = &v39[168 * a3];
      do
      {
        long long v42 = *(_OWORD *)a4;
        long long v43 = *(_OWORD *)(a4 + 16);
        long long v44 = *(_OWORD *)(a4 + 48);
        *((_OWORD *)v39 + 2) = *(_OWORD *)(a4 + 32);
        *((_OWORD *)v39 + 3) = v44;
        *(_OWORD *)unint64_t v39 = v42;
        *((_OWORD *)v39 + 1) = v43;
        long long v45 = *(_OWORD *)(a4 + 64);
        long long v46 = *(_OWORD *)(a4 + 80);
        long long v47 = *(_OWORD *)(a4 + 112);
        *((_OWORD *)v39 + 6) = *(_OWORD *)(a4 + 96);
        *((_OWORD *)v39 + 7) = v47;
        *((_OWORD *)v39 + 4) = v45;
        *((_OWORD *)v39 + 5) = v46;
        std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::vector((void *)v39 + 16, a4 + 128);
        uint64_t v48 = *(void *)(a4 + 152);
        v39[160] = *(unsigned char *)(a4 + 160);
        *((void *)v39 + 19) = v48;
        v39 += 168;
        v40 -= 168;
      }
      while (v40);
      unint64_t v54 = v41;
      uint64_t v6 = std::vector<TSTWidthHeightCache_Private::WHCRow>::__swap_out_circular_buffer((long long **)v9, v53, v6);
      std::__split_buffer<TSTWidthHeightCache_Private::WHCRow>::~__split_buffer((uint64_t)v53);
    }
  }
  return v6;
}

void sub_2237ABF1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  std::__split_buffer<TSTWidthHeightCache_Private::WHCRow>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_2237AC158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, void **a16)
{
  a16 = (void **)&a12;
  std::vector<TSTWidthHeightCache_Private::WHCRow>::__destroy_vector::operator()[abi:nn180100](&a16);
  _Unwind_Resume(a1);
}

void sub_2237AC384(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, void **a16)
{
  a16 = (void **)&a12;
  std::vector<TSTWidthHeightCache_Private::WHCCol>::__destroy_vector::operator()[abi:nn180100](&a16);
  _Unwind_Resume(a1);
}

void sub_2237AD0D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void __Block_byref_object_copy__28(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__28(uint64_t a1)
{
}

uint64_t std::vector<TSTWidthHeightCache_Private::WHCRow>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (0xCF3CF3CF3CF3CF3DLL * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0x186186186186187) {
      abort();
    }
    uint64_t v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:nn180100]<std::allocator<TSTWidthHeightCache_Private::WHCRow>>(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 168 * v6;
    std::vector<TSTWidthHeightCache_Private::WHCRow>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<TSTWidthHeightCache_Private::WHCRow>::~__split_buffer((uint64_t)v7);
  }
  return result;
}

void sub_2237AD56C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TSTWidthHeightCache_Private::WHCRow>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::__fill_n[abi:nn180100]<false,std::__bitset<1ul,14ul>>(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = a2;
  int v4 = *(_DWORD *)(a1 + 8);
  uint64_t v5 = *(void **)a1;
  if (v4)
  {
    if ((64 - v4) >= a2) {
      unint64_t v6 = a2;
    }
    else {
      unint64_t v6 = (64 - v4);
    }
    *v5++ &= ~((0xFFFFFFFFFFFFFFFFLL >> (64 - v4 - v6)) & (-1 << v4));
    unint64_t v2 = a2 - v6;
    *(void *)a1 = v5;
  }
  unint64_t v7 = v2 >> 6;
  if (v2 >= 0x40) {
    bzero(v5, 8 * v7);
  }
  if ((v2 & 0x3F) != 0)
  {
    uint64_t v8 = &v5[v7];
    *(void *)a1 = v8;
    *v8 &= ~(0xFFFFFFFFFFFFFFFFLL >> -(v2 & 0x3F));
  }
}

_DWORD *std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  uint64_t v5 = *(_DWORD **)(a2 + 8);
  unint64_t v6 = (char *)*a1;
  unint64_t v7 = v5;
  if (*a1 != __src)
  {
    uint64_t v8 = __src;
    unint64_t v7 = *(_DWORD **)(a2 + 8);
    do
    {
      uint64_t v9 = *((void *)v8 - 2);
      v8 -= 16;
      int v10 = *((_DWORD *)v8 + 2);
      *((void *)v7 - 2) = v9;
      v7 -= 4;
      v7[2] = v10;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  uint64_t v11 = a1[1];
  uint64_t v12 = *(void *)(a2 + 16);
  int64_t v13 = v11 - __src;
  if (v11 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v13 - 4);
    unint64_t v7 = *(_DWORD **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v12 + v13;
  unint64_t v14 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v14;
  unint64_t v15 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v15;
  unint64_t v16 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v16;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

__n128 std::__split_buffer<TSTWidthHeightCache_Private::WHCHeightBucket>::push_back(__n128 **a1, __n128 *a2)
{
  int v4 = a1[2];
  if (v4 == a1[3])
  {
    uint64_t v5 = a1[1];
    uint64_t v6 = (char *)v5 - (char *)*a1;
    if (v5 <= *a1)
    {
      if (v4 == *a1) {
        unint64_t v16 = 1;
      }
      else {
        unint64_t v16 = ((char *)v4 - (char *)*a1) >> 3;
      }
      uint64_t v17 = (__n128 *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLength>>((uint64_t)a1[4], v16);
      unint64_t v19 = &v17[v16 >> 2];
      uint64_t v20 = a1[1];
      int v4 = v19;
      uint64_t v21 = (char *)a1[2] - (char *)v20;
      if (v21)
      {
        int v4 = (__n128 *)((char *)v19 + (v21 & 0xFFFFFFFFFFFFFFF0));
        uint64_t v22 = 16 * (v21 >> 4);
        long long v23 = (char *)&v17[v16 >> 2];
        do
        {
          long long v24 = (__int128)*v20++;
          *(_OWORD *)long long v23 = v24;
          v23 += 16;
          v22 -= 16;
        }
        while (v22);
      }
      long long v25 = *a1;
      *a1 = v17;
      a1[1] = v19;
      a1[2] = v4;
      a1[3] = &v17[v18];
      if (v25)
      {
        operator delete(v25);
        int v4 = a1[2];
      }
    }
    else
    {
      uint64_t v7 = v6 >> 4;
      BOOL v8 = v6 >> 4 < -1;
      uint64_t v9 = (v6 >> 4) + 2;
      if (v8) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = v7 + 1;
      }
      uint64_t v11 = -(v10 >> 1);
      uint64_t v12 = v10 >> 1;
      int64_t v13 = &v5[-v12];
      int64_t v14 = (char *)v4 - (char *)v5;
      if (v4 != v5)
      {
        memmove(&v5[-v12], v5, v14 - 6);
        int v4 = a1[1];
      }
      unint64_t v15 = &v4[v11];
      int v4 = (__n128 *)((char *)v13 + v14);
      a1[1] = v15;
      a1[2] = (__n128 *)((char *)v13 + v14);
    }
  }
  __n128 result = *a2;
  __n128 *v4 = *a2;
  ++a1[2];
  return result;
}

_WORD *std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  uint64_t v5 = *(_WORD **)(a2 + 8);
  uint64_t v6 = (char *)*a1;
  uint64_t v7 = v5;
  if (*a1 != __src)
  {
    BOOL v8 = __src;
    uint64_t v7 = *(_WORD **)(a2 + 8);
    do
    {
      uint64_t v9 = *((void *)v8 - 2);
      v8 -= 16;
      __int16 v10 = *((_WORD *)v8 + 4);
      *((void *)v7 - 2) = v9;
      v7 -= 8;
      v7[4] = v10;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  uint64_t v11 = a1[1];
  uint64_t v12 = *(void *)(a2 + 16);
  int64_t v13 = v11 - __src;
  if (v11 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v13 - 6);
    uint64_t v7 = *(_WORD **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v12 + v13;
  int64_t v14 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v14;
  unint64_t v15 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v15;
  unint64_t v16 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v16;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

uint64_t TSTWidthHeightCache_NibArray::NibArray<8u>::setRange(uint64_t result, unsigned int a2, unsigned int a3, char a4)
{
  LOBYTE(v6) = a2;
  uint64_t v7 = result;
  if (a2 >= 0x100)
  {
    BOOL v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTWidthHeightCache_NibArray::NibArray<8>::setRange(uint, uint, uint8_t) [log2NumElements = 8]");
    __n128 result = objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTWidthHeightCache_NibArray.h"), 78, @"begin exceeds array length");
  }
  unsigned int v6 = v6;
  if (a3 >= 0x101)
  {
    __int16 v10 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v11 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTWidthHeightCache_NibArray::NibArray<8>::setRange(uint, uint, uint8_t) [log2NumElements = 8]");
    __n128 result = objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTWidthHeightCache_NibArray.h"), 81, @"end exceeds array length");
  }
  if (a3 >= 0x100) {
    a3 = 256;
  }
  if (v6 < a3)
  {
    do
      __n128 result = TSTWidthHeightCache_NibArray::NibArray<8u>::set(v7, v6++, a4);
    while (a3 != v6);
  }
  return result;
}

void *std::vector<TSTWidthHeightCache_Private::WHCCol>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  unsigned int v6 = (void *)a2[1];
  if (v5 == *a1)
  {
    __n128 result = (void *)a2[1];
  }
  else
  {
    do
    {
      __n128 result = std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::vector(v6 - 4, v5 - 32);
      *((unsigned char *)v6 - 8) = *(unsigned char *)(v5 - 8);
      v5 -= 32;
      unsigned int v6 = result;
    }
    while (v5 != v4);
  }
  a2[1] = result;
  uint64_t v8 = *a1;
  *a1 = (uint64_t)result;
  a2[1] = v8;
  uint64_t v9 = a1[1];
  a1[1] = a2[2];
  a2[2] = v9;
  uint64_t v10 = a1[2];
  a1[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

void *std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(const void **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v5 = v3 - *(void *)a2;
  if (v3 != *(void *)a2)
  {
    std::vector<CGPoint>::__vallocate[abi:nn180100](a1, v5 >> 4);
    unsigned int v6 = (char *)a1[1];
    memmove(v6, v4, v5 - 4);
    a1[1] = &v6[v5];
  }
  return a1;
}

uint64_t std::__split_buffer<TSTWidthHeightCache_Private::WHCCol>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__split_buffer<TSTWidthHeightCache_Private::WHCCol>::__destruct_at_end[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != a2)
  {
    uint64_t v5 = *(void **)(v2 - 32);
    *(void *)(a1 + 16) = v2 - 32;
    if (v5)
    {
      *(void *)(v2 - 24) = v5;
      operator delete(v5);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 32;
    }
  }
}

uint64_t std::vector<TSTWidthHeightCache_Private::WHCCol>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(result - 8);
  if (a2 <= (v6 - v7) >> 5)
  {
    if (a2)
    {
      uint64_t v14 = 32 * a2;
      uint64_t v15 = v7 + 32 * a2;
      do
      {
        *(void *)uint64_t v7 = 0;
        *(void *)(v7 + 8) = 0;
        *(unsigned char *)(v7 + 24) = 0;
        *(void *)(v7 + 16) = 0;
        v7 += 32;
        v14 -= 32;
      }
      while (v14);
      uint64_t v7 = v15;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - *a1;
    unint64_t v9 = a2 + (v8 >> 5);
    if (v9 >> 59) {
      abort();
    }
    uint64_t v10 = v8 >> 5;
    uint64_t v11 = v5 - *a1;
    if (v11 >> 4 > v9) {
      unint64_t v9 = v11 >> 4;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v12 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    v19[4] = result;
    if (v12) {
      int64_t v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKit::OpticalKern::Edge::CGPointVector>>(result, v12);
    }
    else {
      int64_t v13 = 0;
    }
    unint64_t v16 = &v13[32 * v10];
    v19[0] = v13;
    v19[1] = v16;
    v19[3] = &v13[32 * v12];
    uint64_t v17 = 32 * a2;
    uint64_t v18 = &v16[32 * a2];
    do
    {
      *(void *)unint64_t v16 = 0;
      *((void *)v16 + 1) = 0;
      v16[24] = 0;
      *((void *)v16 + 2) = 0;
      v16 += 32;
      v17 -= 32;
    }
    while (v17);
    v19[2] = v18;
    std::vector<TSTWidthHeightCache_Private::WHCCol>::__swap_out_circular_buffer(a1, v19);
    return std::__split_buffer<TSTWidthHeightCache_Private::WHCCol>::~__split_buffer((uint64_t)v19);
  }
  return result;
}

void sub_2237ADEC0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TSTWidthHeightCache_Private::WHCCol>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<TSTWidthHeightCache_Private::WHCRow>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(v4 - 8);
  if (0xCF3CF3CF3CF3CF3DLL * ((v6 - v7) >> 3) >= a2)
  {
    std::vector<TSTWidthHeightCache_Private::WHCRow>::__construct_at_end((uint64_t)a1, a2);
  }
  else
  {
    unint64_t v8 = 0xCF3CF3CF3CF3CF3DLL * ((v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0x186186186186186) {
      abort();
    }
    unint64_t v10 = 0xCF3CF3CF3CF3CF3DLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0xC30C30C30C30C3) {
      unint64_t v11 = 0x186186186186186;
    }
    else {
      unint64_t v11 = v9;
    }
    uint64_t v17 = v4;
    if (v11) {
      unint64_t v12 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<TSTWidthHeightCache_Private::WHCRow>>(v4, v11);
    }
    else {
      unint64_t v12 = 0;
    }
    int64_t v13 = v12;
    uint64_t v14 = &v12[168 * v8];
    uint64_t v15 = v14;
    unint64_t v16 = &v12[168 * v11];
    std::__split_buffer<TSTWidthHeightCache_Private::WHCRow>::__construct_at_end((uint64_t)&v13, a2);
    std::vector<TSTWidthHeightCache_Private::WHCRow>::__swap_out_circular_buffer(a1, &v13);
    std::__split_buffer<TSTWidthHeightCache_Private::WHCRow>::~__split_buffer((uint64_t)&v13);
  }
}

void sub_2237AE008(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TSTWidthHeightCache_Private::WHCRow>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<TSTWidthHeightCache_Private::WHCRow>::__construct_at_end(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (a2)
  {
    uint64_t v4 = v3 + 168 * a2;
    uint64_t v5 = v3 + 152;
    uint64_t v6 = 168 * a2;
    do
    {
      *(unsigned char *)(v5 + 8) = 0;
      *(_OWORD *)(v5 - 8) = 0u;
      *(_OWORD *)(v5 - 24) = 0u;
      *(void *)&long long v7 = -1;
      *((void *)&v7 + 1) = -1;
      *(_OWORD *)(v5 - 152) = v7;
      *(_OWORD *)(v5 - 136) = v7;
      *(_OWORD *)(v5 - 120) = v7;
      *(_OWORD *)(v5 - ++*(_DWORD *)(this + 104) = v7;
      *(_OWORD *)(v5 - 88) = v7;
      *(_OWORD *)(v5 - 72) = v7;
      *(_OWORD *)(v5 - 56) = v7;
      *(_OWORD *)(v5 - 40) = v7;
      uint64_t v8 = v5;
      int v9 = 0;
      std::__fill_n[abi:nn180100]<false,std::__bitset<1ul,14ul>>((uint64_t)&v8, 0xEuLL);
      v5 += 168;
      v6 -= 168;
    }
    while (v6);
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 8);
  }
  *(void *)(a1 + 8) = v4;
}

void std::__split_buffer<TSTWidthHeightCache_Private::WHCRow>::__construct_at_end(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (a2)
  {
    uint64_t v4 = v3 + 168 * a2;
    uint64_t v5 = v3 + 152;
    uint64_t v6 = 168 * a2;
    do
    {
      *(unsigned char *)(v5 + 8) = 0;
      *(_OWORD *)(v5 - 8) = 0u;
      *(_OWORD *)(v5 - 24) = 0u;
      *(void *)&long long v7 = -1;
      *((void *)&v7 + 1) = -1;
      *(_OWORD *)(v5 - 152) = v7;
      *(_OWORD *)(v5 - 136) = v7;
      *(_OWORD *)(v5 - 120) = v7;
      *(_OWORD *)(v5 - ++*(_DWORD *)(this + 104) = v7;
      *(_OWORD *)(v5 - 88) = v7;
      *(_OWORD *)(v5 - 72) = v7;
      *(_OWORD *)(v5 - 56) = v7;
      *(_OWORD *)(v5 - 40) = v7;
      uint64_t v8 = v5;
      int v9 = 0;
      std::__fill_n[abi:nn180100]<false,std::__bitset<1ul,14ul>>((uint64_t)&v8, 0xEuLL);
      v5 += 168;
      v6 -= 168;
    }
    while (v6);
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 16);
  }
  *(void *)(a1 + 16) = v4;
}

uint64_t *std::vector<TSTWidthHeightCache_Private::WHCRow>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  uint64_t v4 = a2[1];
  if (v3 == *result)
  {
    uint64_t v5 = a2[1];
  }
  else
  {
    do
    {
      uint64_t v5 = v4 - 168;
      long long v6 = *(_OWORD *)(v3 - 168);
      long long v7 = *(_OWORD *)(v3 - 152);
      long long v8 = *(_OWORD *)(v3 - 136);
      *(_OWORD *)(v4 - 120) = *(_OWORD *)(v3 - 120);
      *(_OWORD *)(v4 - 136) = v8;
      *(_OWORD *)(v4 - 152) = v7;
      *(_OWORD *)(v4 - 168) = v6;
      long long v9 = *(_OWORD *)(v3 - 104);
      long long v10 = *(_OWORD *)(v3 - 88);
      long long v11 = *(_OWORD *)(v3 - 72);
      *(_OWORD *)(v4 - 56) = *(_OWORD *)(v3 - 56);
      *(_OWORD *)(v4 - 72) = v11;
      *(_OWORD *)(v4 - 88) = v10;
      *(_OWORD *)(v4 - ++*(_DWORD *)(this + 104) = v9;
      *(void *)(v4 - 32) = 0;
      *(void *)(v4 - 24) = 0;
      *(void *)(v4 - 40) = 0;
      *(_OWORD *)(v4 - 40) = *(_OWORD *)(v3 - 40);
      *(void *)(v4 - 24) = *(void *)(v3 - 24);
      *(void *)(v3 - 40) = 0;
      *(void *)(v3 - 32) = 0;
      *(void *)(v3 - 24) = 0;
      uint64_t v12 = *(void *)(v3 - 16);
      *(unsigned char *)(v4 - 8) = *(unsigned char *)(v3 - 8);
      *(void *)(v4 - 16) = v12;
      v3 -= 168;
      v4 -= 168;
    }
    while (v3 != v2);
  }
  a2[1] = v5;
  uint64_t v13 = *result;
  void *result = v5;
  a2[1] = v13;
  uint64_t v14 = result[1];
  result[1] = a2[2];
  a2[2] = v14;
  uint64_t v15 = result[2];
  result[2] = a2[3];
  a2[3] = v15;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<TSTWidthHeightCache_Private::WHCRow>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x186186186186187) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(168 * a2);
}

uint64_t std::__split_buffer<TSTWidthHeightCache_Private::WHCRow>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__split_buffer<TSTWidthHeightCache_Private::WHCRow>::__destruct_at_end[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != a2)
  {
    *(void *)(a1 + 16) = v2 - 168;
    uint64_t v5 = *(void **)(v2 - 40);
    if (v5)
    {
      *(void *)(v2 - 32) = v5;
      operator delete(v5);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 168;
    }
  }
}

uint64_t std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *>(int a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = a2;
  if (a2 != a3)
  {
    do
    {
      if ((char *)v5 != a4) {
        std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::__assign_with_size[abi:nn180100]<TSTWidthHeightCache_Private::WHCWidthBucket*,TSTWidthHeightCache_Private::WHCWidthBucket*>(a4, *(char **)v5, *(void *)(v5 + 8), (uint64_t)(*(void *)(v5 + 8) - *(void *)v5) >> 4);
      }
      a4[24] = *(unsigned char *)(v5 + 24);
      v5 += 32;
      a4 += 32;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

char *std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::__assign_with_size[abi:nn180100]<TSTWidthHeightCache_Private::WHCWidthBucket*,TSTWidthHeightCache_Private::WHCWidthBucket*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  long long v7 = result;
  uint64_t v8 = *((void *)result + 2);
  long long v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *long long v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 60) {
      abort();
    }
    uint64_t v10 = v8 >> 3;
    if (v8 >> 3 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = std::vector<CGPoint>::__vallocate[abi:nn180100](v7, v11);
    uint64_t v13 = (char *)v7[1];
    uint64_t v12 = (void **)(v7 + 1);
    long long v9 = v13;
LABEL_16:
    uint64_t v17 = a3 - (void)__src;
    if (v17)
    {
      size_t v18 = v17 - 4;
      unint64_t v19 = v9;
      uint64_t v20 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  uint64_t v12 = (void **)(result + 8);
  uint64_t v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 4;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  unint64_t v16 = &__src[16 * v15];
  if (v14 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v14 - v9 - 4);
    long long v9 = (char *)*v12;
  }
  uint64_t v17 = a3 - (void)v16;
  if (v17)
  {
    size_t v18 = v17 - 4;
    unint64_t v19 = v9;
    uint64_t v20 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v19, v20, v18);
  }
LABEL_19:
  char *v12 = &v9[v17];
  return result;
}

long long *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *,0>(long long *a1, long long *a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a1 == a2) {
    return a1;
  }
  uint64_t v5 = a2;
  do
  {
    long long v6 = *v4;
    long long v7 = v4[1];
    long long v8 = v4[3];
    *(_OWORD *)(a3 + 32) = v4[2];
    *(_OWORD *)(a3 + 48) = v8;
    *(_OWORD *)a3 = v6;
    *(_OWORD *)(a3 + 16) = v7;
    long long v9 = v4[4];
    long long v10 = v4[5];
    long long v11 = v4[7];
    *(_OWORD *)(a3 + 96) = v4[6];
    *(_OWORD *)(a3 + 112) = v11;
    *(_OWORD *)(a3 + 64) = v9;
    *(_OWORD *)(a3 + 80) = v10;
    std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::__move_assign(a3 + 128, (__n128 *)v4 + 8);
    uint64_t v12 = *((void *)v4 + 19);
    *(unsigned char *)(a3 + 160) = *((unsigned char *)v4 + 160);
    *(void *)(a3 + 152) = v12;
    a3 += 168;
    uint64_t v4 = (long long *)((char *)v4 + 168);
  }
  while (v4 != v5);
  return v5;
}

__n128 std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::__move_assign(uint64_t a1, __n128 *a2)
{
  uint64_t v4 = *(void **)a1;
  if (v4)
  {
    *(void *)(a1 + 8) = v4;
    operator delete(v4);
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
  __n128 result = *a2;
  *(__n128 *)a1 = *a2;
  *(void *)(a1 + 16) = a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  return result;
}

uint64_t std::vector<TSTWidthHeightCache_Private::WHCCol>::__move_range(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 8);
  unint64_t v7 = a2 + v6 - a4;
  uint64_t v8 = v6;
  if (v7 < a3)
  {
    unint64_t v10 = a2 + v6 - a4;
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::vector((void *)v8, v10);
      *(unsigned char *)(v8 + 24) = *(unsigned char *)(v10 + 24);
      v10 += 32;
      v8 += 32;
    }
    while (v10 < a3);
  }
  *(void *)(a1 + 8) = v8;
  return std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *>((uint64_t)&v12, a2, v7, v6);
}

void sub_2237AE644(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void *std::vector<TSTWidthHeightCache_Private::WHCCol>::__swap_out_circular_buffer(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v6 = (void *)a2[1];
  uint64_t v7 = *a1;
  uint64_t v8 = v6;
  if (v7 != a3)
  {
    uint64_t v9 = a3;
    unint64_t v10 = (void *)a2[1];
    do
    {
      uint64_t v8 = std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::vector(v10 - 4, v9 - 32);
      *((unsigned char *)v10 - 8) = *(unsigned char *)(v9 - 8);
      v9 -= 32;
      unint64_t v10 = v8;
    }
    while (v9 != v7);
  }
  a2[1] = v8;
  uint64_t v11 = a1[1];
  uint64_t v12 = a2[2];
  if (v11 != v3)
  {
    do
    {
      std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::vector((void *)v12, v3);
      *(unsigned char *)(v12 + 24) = *(unsigned char *)(v3 + 24);
      v3 += 32;
      v12 += 32;
    }
    while (v3 != v11);
    uint64_t v8 = (void *)a2[1];
  }
  a2[2] = v12;
  uint64_t v13 = *a1;
  *a1 = (uint64_t)v8;
  a2[1] = v13;
  uint64_t v14 = a1[1];
  a1[1] = a2[2];
  a2[2] = v14;
  uint64_t v15 = a1[2];
  a1[2] = a2[3];
  a2[3] = v15;
  *a2 = a2[1];
  return v6;
}

uint64_t std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 != a2)
  {
    uint64_t v7 = a3;
    do
    {
      if (v7 != a4) {
        std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::__assign_with_size[abi:nn180100]<TSTWidthHeightCache_Private::WHCWidthBucket*,TSTWidthHeightCache_Private::WHCWidthBucket*>((char *)(a4 - 32), *(char **)(v7 - 32), *(void *)(v7 - 24), (uint64_t)(*(void *)(v7 - 24) - *(void *)(v7 - 32)) >> 4);
      }
      *(unsigned char *)(a4 - 8) = *(unsigned char *)(v7 - 8);
      v7 -= 32;
      a4 -= 32;
    }
    while (v7 != a2);
  }
  return a3;
}

char *std::vector<double>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  uint64_t v5 = *(char **)(a2 + 8);
  uint64_t v6 = (char *)*a1;
  uint64_t v7 = v5;
  if (*a1 != __src)
  {
    uint64_t v8 = __src;
    uint64_t v7 = *(char **)(a2 + 8);
    do
    {
      uint64_t v9 = *((void *)v8 - 1);
      v8 -= 8;
      *((void *)v7 - 1) = v9;
      v7 -= 8;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  unint64_t v10 = a1[1];
  uint64_t v11 = *(void *)(a2 + 16);
  int64_t v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    uint64_t v7 = *(char **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v11 + v12;
  uint64_t v13 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v13;
  uint64_t v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v14;
  uint64_t v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v15;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

uint64_t std::vector<TSTWidthHeightCache_Private::WHCRow>::__move_range(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 8);
  unint64_t v7 = a2 + v6 - a4;
  uint64_t v8 = v6;
  if (v7 < a3)
  {
    unint64_t v9 = v7;
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      long long v10 = *(_OWORD *)v9;
      long long v11 = *(_OWORD *)(v9 + 16);
      long long v12 = *(_OWORD *)(v9 + 48);
      *(_OWORD *)(v8 + 32) = *(_OWORD *)(v9 + 32);
      *(_OWORD *)(v8 + 48) = v12;
      *(_OWORD *)uint64_t v8 = v10;
      *(_OWORD *)(v8 + 16) = v11;
      long long v13 = *(_OWORD *)(v9 + 64);
      long long v14 = *(_OWORD *)(v9 + 80);
      long long v15 = *(_OWORD *)(v9 + 112);
      *(_OWORD *)(v8 + 96) = *(_OWORD *)(v9 + 96);
      *(_OWORD *)(v8 + 112) = v15;
      *(_OWORD *)(v8 + 64) = v13;
      *(_OWORD *)(v8 + 80) = v14;
      *(void *)(v8 + 136) = 0;
      *(void *)(v8 + 144) = 0;
      *(void *)(v8 + 128) = 0;
      *(_OWORD *)(v8 + 128) = *(_OWORD *)(v9 + 128);
      *(void *)(v8 + 144) = *(void *)(v9 + 144);
      *(void *)(v9 + 128) = 0;
      *(void *)(v9 + 136) = 0;
      *(void *)(v9 + 144) = 0;
      uint64_t v16 = *(void *)(v9 + 152);
      *(unsigned char *)(v8 + 160) = *(unsigned char *)(v9 + 160);
      *(void *)(v8 + 152) = v16;
      v8 += 168;
      v9 += 168;
    }
    while (v9 < a3);
  }
  *(void *)(a1 + 8) = v8;
  return std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_backward_loop<std::_ClassicAlgPolicy>,std::__move_backward_trivial>,TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *,0>(a2, v7, v6);
}

long long *std::vector<TSTWidthHeightCache_Private::WHCRow>::__swap_out_circular_buffer(long long **a1, void *a2, long long *a3)
{
  __n128 result = (long long *)a2[1];
  uint64_t v5 = *a1;
  uint64_t v6 = result;
  if (*a1 != a3)
  {
    unint64_t v7 = a3;
    uint64_t v8 = a2[1];
    do
    {
      uint64_t v6 = (long long *)(v8 - 168);
      long long v9 = *(long long *)((char *)v7 - 168);
      long long v10 = *(long long *)((char *)v7 - 152);
      long long v11 = *(long long *)((char *)v7 - 136);
      *(_OWORD *)(v8 - 120) = *(long long *)((char *)v7 - 120);
      *(_OWORD *)(v8 - 136) = v11;
      *(_OWORD *)(v8 - 152) = v10;
      *(_OWORD *)(v8 - 168) = v9;
      long long v12 = *(long long *)((char *)v7 - 104);
      long long v13 = *(long long *)((char *)v7 - 88);
      long long v14 = *(long long *)((char *)v7 - 72);
      *(_OWORD *)(v8 - 56) = *(long long *)((char *)v7 - 56);
      *(_OWORD *)(v8 - 72) = v14;
      *(_OWORD *)(v8 - 88) = v13;
      *(_OWORD *)(v8 - ++*(_DWORD *)(this + 104) = v12;
      *(void *)(v8 - 32) = 0;
      *(void *)(v8 - 24) = 0;
      *(void *)(v8 - 40) = 0;
      *(_OWORD *)(v8 - 40) = *(long long *)((char *)v7 - 40);
      *(void *)(v8 - 24) = *((void *)v7 - 3);
      *((void *)v7 - 5) = 0;
      *((void *)v7 - 4) = 0;
      *((void *)v7 - 3) = 0;
      uint64_t v15 = *((void *)v7 - 2);
      *(unsigned char *)(v8 - 8) = *((unsigned char *)v7 - 8);
      *(void *)(v8 - 16) = v15;
      unint64_t v7 = (long long *)((char *)v7 - 168);
      v8 -= 168;
    }
    while (v7 != v5);
  }
  a2[1] = v6;
  uint64_t v16 = a1[1];
  uint64_t v17 = a2[2];
  if (v16 != a3)
  {
    do
    {
      long long v18 = *a3;
      long long v19 = a3[1];
      long long v20 = a3[3];
      *(_OWORD *)(v17 + 32) = a3[2];
      *(_OWORD *)(v17 + 48) = v20;
      *(_OWORD *)uint64_t v17 = v18;
      *(_OWORD *)(v17 + 16) = v19;
      long long v21 = a3[4];
      long long v22 = a3[5];
      long long v23 = a3[7];
      *(_OWORD *)(v17 + 96) = a3[6];
      *(_OWORD *)(v17 + 112) = v23;
      *(_OWORD *)(v17 + 64) = v21;
      *(_OWORD *)(v17 + 80) = v22;
      *(void *)(v17 + 136) = 0;
      *(void *)(v17 + 144) = 0;
      *(void *)(v17 + 128) = 0;
      *(_OWORD *)(v17 + 128) = a3[8];
      *(void *)(v17 + 144) = *((void *)a3 + 18);
      *((void *)a3 + 16) = 0;
      *((void *)a3 + 17) = 0;
      *((void *)a3 + 18) = 0;
      uint64_t v24 = *((void *)a3 + 19);
      *(unsigned char *)(v17 + 160) = *((unsigned char *)a3 + 160);
      *(void *)(v17 + 152) = v24;
      v17 += 168;
      a3 = (long long *)((char *)a3 + 168);
    }
    while (a3 != v16);
    uint64_t v6 = (long long *)a2[1];
  }
  a2[2] = v17;
  long long v25 = *a1;
  *a1 = v6;
  a2[1] = v25;
  long long v26 = a1[1];
  a1[1] = (long long *)a2[2];
  a2[2] = v26;
  long long v27 = a1[2];
  a1[2] = (long long *)a2[3];
  a2[3] = v27;
  *a2 = a2[1];
  return result;
}

void *std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(const void **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v5 = v3 - *(void *)a2;
  if (v3 != *(void *)a2)
  {
    std::vector<CGPoint>::__vallocate[abi:nn180100](a1, v5 >> 4);
    uint64_t v6 = (char *)a1[1];
    memmove(v6, v4, v5 - 6);
    a1[1] = &v6[v5];
  }
  return a1;
}

uint64_t std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_backward_loop<std::_ClassicAlgPolicy>,std::__move_backward_trivial>,TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a1)
  {
    uint64_t v6 = a2;
    do
    {
      long long v7 = *(_OWORD *)(v6 - 168);
      long long v8 = *(_OWORD *)(v6 - 152);
      long long v9 = *(_OWORD *)(v6 - 136);
      *(_OWORD *)(a3 - 120) = *(_OWORD *)(v6 - 120);
      *(_OWORD *)(a3 - 136) = v9;
      *(_OWORD *)(a3 - 152) = v8;
      *(_OWORD *)(a3 - 168) = v7;
      long long v10 = *(_OWORD *)(v6 - 104);
      long long v11 = *(_OWORD *)(v6 - 88);
      long long v12 = *(_OWORD *)(v6 - 72);
      *(_OWORD *)(a3 - 56) = *(_OWORD *)(v6 - 56);
      *(_OWORD *)(a3 - 72) = v12;
      *(_OWORD *)(a3 - 88) = v11;
      *(_OWORD *)(a3 - ++*(_DWORD *)(this + 104) = v10;
      std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::__move_assign(a3 - 40, (__n128 *)(v6 - 40));
      uint64_t v13 = *(void *)(v6 - 16);
      *(unsigned char *)(a3 - 8) = *(unsigned char *)(v6 - 8);
      *(void *)(a3 - 16) = v13;
      a3 -= 168;
      v6 -= 168;
    }
    while (v6 != a1);
  }
  return a2;
}

char *std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::__assign_with_size[abi:nn180100]<TSTWidthHeightCache_Private::WHCHeightBucket*,TSTWidthHeightCache_Private::WHCHeightBucket*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  long long v7 = result;
  uint64_t v8 = *((void *)result + 2);
  long long v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *long long v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 60) {
      abort();
    }
    uint64_t v10 = v8 >> 3;
    if (v8 >> 3 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    __n128 result = std::vector<CGPoint>::__vallocate[abi:nn180100](v7, v11);
    uint64_t v13 = (char *)v7[1];
    long long v12 = (void **)(v7 + 1);
    long long v9 = v13;
LABEL_16:
    uint64_t v17 = a3 - (void)__src;
    if (v17)
    {
      size_t v18 = v17 - 6;
      long long v19 = v9;
      long long v20 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  long long v12 = (void **)(result + 8);
  long long v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 4;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[16 * v15];
  if (v14 != v9)
  {
    __n128 result = (char *)memmove(*(void **)result, __src, v14 - v9 - 6);
    long long v9 = (char *)*v12;
  }
  uint64_t v17 = a3 - (void)v16;
  if (v17)
  {
    size_t v18 = v17 - 6;
    long long v19 = v9;
    long long v20 = v16;
LABEL_18:
    __n128 result = (char *)memmove(v19, v20, v18);
  }
LABEL_19:
  char *v12 = &v9[v17];
  return result;
}

void std::vector<TSTWidthHeightCache_Private::WHCRow>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<TSTWidthHeightCache_Private::WHCRow>::__clear[abi:nn180100]((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<TSTWidthHeightCache_Private::WHCRow>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 168)
  {
    uint64_t v4 = *(void **)(i - 40);
    if (v4)
    {
      *(void *)(i - 32) = v4;
      operator delete(v4);
    }
  }
  a1[1] = v2;
}

void std::vector<TSTWidthHeightCache_Private::WHCRow>::__assign_with_size[abi:nn180100]<std::__wrap_iter<TSTWidthHeightCache_Private::WHCRow*>,std::__wrap_iter<TSTWidthHeightCache_Private::WHCRow*>>(uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = *a1;
  if (0xCF3CF3CF3CF3CF3DLL * ((a1[2] - *a1) >> 3) >= a4)
  {
    if (0xCF3CF3CF3CF3CF3DLL * ((a1[1] - v8) >> 3) >= a4)
    {
      std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *>((uint64_t)&v17, a2, a3, v8);
      uint64_t v13 = v12;
      uint64_t v14 = a1[1];
      if (v14 != v12)
      {
        do
        {
          unint64_t v15 = *(void **)(v14 - 40);
          if (v15)
          {
            *(void *)(v14 - 32) = v15;
            operator delete(v15);
          }
          v14 -= 168;
        }
        while (v14 != v13);
      }
      a1[1] = v13;
    }
    else
    {
      uint64_t v11 = a2 + 8 * ((a1[1] - v8) >> 3);
      std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *>((uint64_t)&v16, a2, v11, v8);
      std::vector<TSTWidthHeightCache_Private::WHCRow>::__construct_at_end<std::__wrap_iter<TSTWidthHeightCache_Private::WHCRow*>,std::__wrap_iter<TSTWidthHeightCache_Private::WHCRow*>>(a1, v11, a3);
    }
  }
  else
  {
    std::vector<TSTWidthHeightCache_Private::WHCRow>::__vdeallocate(a1);
    if (a4 > 0x186186186186186) {
      abort();
    }
    unint64_t v9 = 0x9E79E79E79E79E7ALL * ((a1[2] - *a1) >> 3);
    if (v9 <= a4) {
      unint64_t v9 = a4;
    }
    if (0xCF3CF3CF3CF3CF3DLL * ((a1[2] - *a1) >> 3) >= 0xC30C30C30C30C3) {
      unint64_t v10 = 0x186186186186186;
    }
    else {
      unint64_t v10 = v9;
    }
    std::vector<TSTWidthHeightCache_Private::WHCRow>::__vallocate[abi:nn180100](a1, v10);
    std::vector<TSTWidthHeightCache_Private::WHCRow>::__construct_at_end<std::__wrap_iter<TSTWidthHeightCache_Private::WHCRow*>,std::__wrap_iter<TSTWidthHeightCache_Private::WHCRow*>>(a1, a2, a3);
  }
}

void *std::vector<TSTWidthHeightCache_Private::WHCRow>::__construct_at_end<std::__wrap_iter<TSTWidthHeightCache_Private::WHCRow*>,std::__wrap_iter<TSTWidthHeightCache_Private::WHCRow*>>(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result;
  uint64_t v4 = result[1];
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = a2 + v7;
      uint64_t v9 = v4 + v7;
      long long v10 = *(_OWORD *)(a2 + v7);
      long long v11 = *(_OWORD *)(a2 + v7 + 16);
      long long v12 = *(_OWORD *)(a2 + v7 + 48);
      *(_OWORD *)(v9 + 32) = *(_OWORD *)(a2 + v7 + 32);
      *(_OWORD *)(v9 + 48) = v12;
      *(_OWORD *)uint64_t v9 = v10;
      *(_OWORD *)(v9 + 16) = v11;
      long long v13 = *(_OWORD *)(a2 + v7 + 64);
      long long v14 = *(_OWORD *)(a2 + v7 + 80);
      long long v15 = *(_OWORD *)(a2 + v7 + 112);
      *(_OWORD *)(v9 + 96) = *(_OWORD *)(a2 + v7 + 96);
      *(_OWORD *)(v9 + 112) = v15;
      *(_OWORD *)(v9 + 64) = v13;
      *(_OWORD *)(v9 + 80) = v14;
      __n128 result = std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::vector((void *)(v4 + v7 + 128), a2 + v7 + 128);
      uint64_t v16 = *(void *)(a2 + v7 + 152);
      *(unsigned char *)(v9 + 160) = *(unsigned char *)(a2 + v7 + 160);
      *(void *)(v9 + 152) = v16;
      v7 += 168;
    }
    while (v8 + 168 != a3);
    v4 += v7;
  }
  v3[1] = v4;
  return result;
}

void sub_2237AEFD8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::vector<TSTWidthHeightCache_Private::WHCRow>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<TSTWidthHeightCache_Private::WHCRow>::__clear[abi:nn180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

char *std::vector<TSTWidthHeightCache_Private::WHCRow>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x186186186186187) {
    abort();
  }
  __n128 result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<TSTWidthHeightCache_Private::WHCRow>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[168 * v4];
  return result;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 == a3) {
    return a2;
  }
  uint64_t v5 = a3;
  uint64_t v6 = a2 + 136;
  do
  {
    uint64_t v7 = v6 - 136;
    long long v8 = *(_OWORD *)(v6 - 136);
    long long v9 = *(_OWORD *)(v6 - 120);
    long long v10 = *(_OWORD *)(v6 - 88);
    *(_OWORD *)(a4 + 32) = *(_OWORD *)(v6 - 104);
    *(_OWORD *)(a4 + 48) = v10;
    *(_OWORD *)a4 = v8;
    *(_OWORD *)(a4 + 16) = v9;
    long long v11 = *(_OWORD *)(v6 - 72);
    long long v12 = *(_OWORD *)(v6 - 56);
    long long v13 = *(_OWORD *)(v6 - 24);
    *(_OWORD *)(a4 + 96) = *(_OWORD *)(v6 - 40);
    *(_OWORD *)(a4 + 112) = v13;
    *(_OWORD *)(a4 + 64) = v11;
    *(_OWORD *)(a4 + 80) = v12;
    if (a4 != v6 - 136) {
      std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::__assign_with_size[abi:nn180100]<TSTWidthHeightCache_Private::WHCHeightBucket*,TSTWidthHeightCache_Private::WHCHeightBucket*>((char *)(a4 + 128), *(char **)(v6 - 8), *(void *)v6, (uint64_t)(*(void *)v6 - *(void *)(v6 - 8)) >> 4);
    }
    uint64_t v14 = *(void *)(v6 + 16);
    *(unsigned char *)(a4 + 160) = *(unsigned char *)(v6 + 24);
    *(void *)(a4 + 152) = v14;
    a4 += 168;
    v6 += 168;
  }
  while (v7 + 168 != v5);
  return v5;
}

uint64_t std::__copy_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 != a2)
  {
    uint64_t v7 = a3;
    do
    {
      long long v8 = *(_OWORD *)(v7 - 168);
      long long v9 = *(_OWORD *)(v7 - 152);
      long long v10 = *(_OWORD *)(v7 - 136);
      *(_OWORD *)(a4 - 120) = *(_OWORD *)(v7 - 120);
      *(_OWORD *)(a4 - 136) = v10;
      *(_OWORD *)(a4 - 152) = v9;
      *(_OWORD *)(a4 - 168) = v8;
      long long v11 = *(_OWORD *)(v7 - 104);
      long long v12 = *(_OWORD *)(v7 - 88);
      long long v13 = *(_OWORD *)(v7 - 72);
      *(_OWORD *)(a4 - 56) = *(_OWORD *)(v7 - 56);
      *(_OWORD *)(a4 - 72) = v13;
      *(_OWORD *)(a4 - 88) = v12;
      *(_OWORD *)(a4 - ++*(_DWORD *)(this + 104) = v11;
      if (a4 != v7) {
        std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::__assign_with_size[abi:nn180100]<TSTWidthHeightCache_Private::WHCHeightBucket*,TSTWidthHeightCache_Private::WHCHeightBucket*>((char *)(a4 - 40), *(char **)(v7 - 40), *(void *)(v7 - 32), (uint64_t)(*(void *)(v7 - 32) - *(void *)(v7 - 40)) >> 4);
      }
      uint64_t v14 = *(void *)(v7 - 16);
      *(unsigned char *)(a4 - 8) = *(unsigned char *)(v7 - 8);
      *(void *)(a4 - 16) = v14;
      v7 -= 168;
      a4 -= 168;
    }
    while (v7 != a2);
  }
  return a3;
}

void std::vector<TSTWidthHeightCache_Private::WHCCol>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<TSTWidthHeightCache_Private::WHCCol>::__clear[abi:nn180100]((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<TSTWidthHeightCache_Private::WHCCol>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  if (v2 != *a1)
  {
    uint64_t v4 = a1[1];
    do
    {
      uint64_t v6 = *(void **)(v4 - 32);
      v4 -= 32;
      uint64_t v5 = v6;
      if (v6)
      {
        *(void *)(v2 - 24) = v5;
        operator delete(v5);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

void std::vector<TSTWidthHeightCache_Private::WHCCol>::__assign_with_size[abi:nn180100]<std::__wrap_iter<TSTWidthHeightCache_Private::WHCCol*>,std::__wrap_iter<TSTWidthHeightCache_Private::WHCCol*>>(char **a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  long long v8 = *a1;
  if (a4 <= (a1[2] - *a1) >> 5)
  {
    unint64_t v12 = (a1[1] - v8) >> 5;
    if (v12 >= a4)
    {
      std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *>((int)&v21, a2, a3, v8);
      long long v15 = v14;
      uint64_t v16 = a1[1];
      if (v16 != v14)
      {
        char v17 = a1[1];
        do
        {
          long long v19 = (void *)*((void *)v17 - 4);
          v17 -= 32;
          size_t v18 = v19;
          if (v19)
          {
            *((void *)v16 - 3) = v18;
            operator delete(v18);
          }
          uint64_t v16 = v17;
        }
        while (v17 != v15);
      }
      a1[1] = v15;
    }
    else
    {
      uint64_t v13 = a2 + 32 * v12;
      std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *>((int)&v20, a2, v13, v8);
      std::vector<TSTWidthHeightCache_Private::WHCCol>::__construct_at_end<std::__wrap_iter<TSTWidthHeightCache_Private::WHCCol*>,std::__wrap_iter<TSTWidthHeightCache_Private::WHCCol*>>(a1, v13, a3);
    }
  }
  else
  {
    std::vector<TSTWidthHeightCache_Private::WHCCol>::__vdeallocate((uint64_t *)a1);
    if (a4 >> 59) {
      abort();
    }
    uint64_t v9 = a1[2] - *a1;
    uint64_t v10 = v9 >> 4;
    if (v9 >> 4 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v11 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    std::vector<TSDBrushVertexData>::__vallocate[abi:nn180100](a1, v11);
    std::vector<TSTWidthHeightCache_Private::WHCCol>::__construct_at_end<std::__wrap_iter<TSTWidthHeightCache_Private::WHCCol*>,std::__wrap_iter<TSTWidthHeightCache_Private::WHCCol*>>(a1, a2, a3);
  }
}

void *std::vector<TSTWidthHeightCache_Private::WHCCol>::__construct_at_end<std::__wrap_iter<TSTWidthHeightCache_Private::WHCCol*>,std::__wrap_iter<TSTWidthHeightCache_Private::WHCCol*>>(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result;
  uint64_t v4 = result[1];
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      __n128 result = std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::vector((void *)(v4 + v7), a2 + v7);
      *((unsigned char *)result + 24) = *(unsigned char *)(a2 + v7 + 24);
      v7 += 32;
    }
    while (a2 + v7 != a3);
    v4 += v7;
  }
  v3[1] = v4;
  return result;
}

void sub_2237AF47C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::vector<TSTWidthHeightCache_Private::WHCCol>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<TSTWidthHeightCache_Private::WHCCol>::__clear[abi:nn180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t std::__copy_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 != a2)
  {
    uint64_t v7 = a3;
    do
    {
      if (a4 != v7) {
        std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::__assign_with_size[abi:nn180100]<TSTWidthHeightCache_Private::WHCWidthBucket*,TSTWidthHeightCache_Private::WHCWidthBucket*>((char *)(a4 - 32), *(char **)(v7 - 32), *(void *)(v7 - 24), (uint64_t)(*(void *)(v7 - 24) - *(void *)(v7 - 32)) >> 4);
      }
      *(unsigned char *)(a4 - 8) = *(unsigned char *)(v7 - 8);
      v7 -= 32;
      a4 -= 32;
    }
    while (v7 != a2);
  }
  return a3;
}

void TSTEditingStateSetSelection(TSTEditingState *a1, TSTTableSelection *a2)
{
  [(TSPObject *)a1 willModify];
  mSelection = a1->mSelection;
  if (mSelection != a2)
  {

    a1->mSelection = (TSTTableSelection *)[(TSTTableSelection *)a2 copy];
    [(TSTEditingState *)a1 setSearchReference:0];
  }

  a1->mSelectionReflectingEditingState = 0;
}

TSTTableSelection *TSTEditingStateGetSelection(TSTEditingState *a1, int a2)
{
  uint64_t v4 = [(TSTEditingState *)a1 tableModel];
  if ((a2 & 1) == 0)
  {
    uint64_t v9 = 80;
    return *(TSTTableSelection **)((char *)&a1->super.super.isa + v9);
  }
  uint64_t v5 = v4;
  if (a1->mSelectionReflectingEditingState && ![(TSTEditingState *)a1 editingMode])
  {
    uint64_t v10 = [(TSTTableSelection *)a1->mSelectionReflectingEditingState cellRegion];
    if (![(TSTCellRegion *)v10 isRectangle]
      || (uint64_t v11 = [(TSTCellRegion *)v10 boundingCellRange],
          (([(TSTTableModel *)v5 range] ^ v11) & 0xFFFFFFFF00FFFFFFLL) != 0))
    {

      __n128 result = [[TSTTableSelection alloc] initWithTableModel:v5 selectionType:5];
      a1->mSelectionReflectingEditingState = result;
      return result;
    }
    goto LABEL_25;
  }
  __n128 result = a1->mSelection;
  if (result) {
    BOOL v7 = 1;
  }
  else {
    BOOL v7 = a2 == 0;
  }
  if (!v7)
  {
    if (!a1->mSelectionReflectingEditingState)
    {
      switch([(TSTEditingState *)a1 editingMode])
      {
        case 0:
          long long v8 = [[TSTTableSelection alloc] initWithTableModel:v5 selectionType:5];
          break;
        case 1:
          if (!a1->mSelection) {
            goto LABEL_25;
          }
          long long v8 = [[TSTTableSelection alloc] initWithTableModel:v5 startingRowIndex:(unsigned __int16)[(TSTCellRegion *)[(TSTTableSelection *)a1->mSelection cellRegion] boundingCellRange] numberOfRows:(unint64_t)[(TSTCellRegion *)[(TSTTableSelection *)a1->mSelection cellRegion] boundingCellRange] >> 48];
          break;
        case 2:
          if (!a1->mSelection) {
            goto LABEL_25;
          }
          long long v8 = [[TSTTableSelection alloc] initWithTableModel:v5 startingColumnIndex:([(TSTCellRegion *)[(TSTTableSelection *)a1->mSelection cellRegion] boundingCellRange] >> 16) numberOfColumns:(unsigned __int16)((unint64_t)[(TSTCellRegion *)[(TSTTableSelection *)a1->mSelection cellRegion] boundingCellRange] >> 32)];
          break;
        case 3:
        case 4:
        case 5:
          if (!a1->mSelection) {
            goto LABEL_25;
          }
          long long v8 = [[TSTTableSelection alloc] initWithTableModel:v5 cellRegion:[(TSTTableSelection *)a1->mSelection cellRegion] anchorCellID:[(TSTTableSelection *)a1->mSelection anchorCellID] cursorCellID:[(TSTTableSelection *)a1->mSelection cursorCellID]];
          break;
        case 6:
        case 9:
          if (!a1->mSelection) {
            goto LABEL_25;
          }
          long long v8 = [[TSTTableSelection alloc] initWithTableModel:v5 andCellID:[(TSTCellRegion *)[(TSTTableSelection *)a1->mSelection cellRegion] upperLeftCellID]];
          break;
        case 7:
        case 8:
          long long v8 = [[TSTTableSelection alloc] initWithTableModel:v5 andCellRange:0xFFFFFFLL];
          break;
        default:
          goto LABEL_25;
      }
      a1->mSelectionReflectingEditingState = v8;
    }
LABEL_25:
    uint64_t v9 = 88;
    return *(TSTTableSelection **)((char *)&a1->super.super.isa + v9);
  }
  return result;
}

unint64_t TSTAnimationSetKind(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 16) = a2;
  unint64_t result = TSTAnimationGetStageCountForChunkStyle((TSTTableModel *)[*(id *)(a1 + 8) tableModel], a2);
  *(_DWORD *)(a1 + 60) = 0;
  uint64_t v5 = (unsigned char *)(a1 + 60);
  *(void *)(a1 + 40) = result;
  *(_DWORD *)(a1 + 57) = 0;
  uint64_t v6 = (unsigned char *)(a1 + 57);
  *(void *)(a1 + 48) = 0;
  *(unsigned char *)(a1 + 56) = result < 2;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 64) = 0x10000;
  BOOL v7 = (unsigned char *)(a1 + 58);
  long long v8 = (unsigned char *)(a1 + 59);
  switch(a2)
  {
    case 2:
      goto LABEL_16;
    case 3:
      unsigned char *v6 = 1;
      goto LABEL_15;
    case 4:
      uint64_t v6 = (unsigned char *)(a1 + 58);
      goto LABEL_16;
    case 5:
      *BOOL v7 = 1;
      goto LABEL_15;
    case 6:
      uint64_t v6 = (unsigned char *)(a1 + 59);
      goto LABEL_16;
    case 7:
      *long long v8 = 1;
      goto LABEL_15;
    case 8:
      unsigned char *v6 = 1;
      goto LABEL_12;
    case 9:
      unsigned char *v6 = 1;
      *uint64_t v5 = 1;
      goto LABEL_15;
    case 10:
      *BOOL v7 = 1;
      goto LABEL_12;
    case 11:
      *BOOL v7 = 1;
      goto LABEL_14;
    case 12:
      *long long v8 = 1;
LABEL_12:
      uint64_t v6 = (unsigned char *)(a1 + 60);
      goto LABEL_16;
    case 13:
      *long long v8 = 1;
LABEL_14:
      *uint64_t v5 = 1;
LABEL_15:
      uint64_t v6 = (unsigned char *)(a1 + 63);
      goto LABEL_16;
    case 14:
      uint64_t v6 = (unsigned char *)(a1 + 61);
LABEL_16:
      unsigned char *v6 = 1;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t TSTAnimationGetStageCountForChunkStyle(TSTTableModel *a1, int a2)
{
  switch(a2)
  {
    case 0:
    case 1:
    case 14:
      return 1;
    case 2:
    case 3:
      return TSTAnimationGetNumberOfColumns(a1);
    case 4:
    case 5:
      return TSTAnimationGetNumberOfRows(a1);
    case 6:
    case 7:
      return TSTAnimationGetNumberOfCells(a1);
    case 8:
    case 9:
      uint64_t NumberOfColumns = TSTAnimationGetNumberOfColumns(a1);
      goto LABEL_15;
    case 10:
    case 11:
      uint64_t NumberOfColumns = TSTAnimationGetNumberOfRows(a1);
      goto LABEL_15;
    case 12:
    case 13:
      uint64_t NumberOfColumns = TSTAnimationGetNumberOfCells(a1);
LABEL_15:
      uint64_t result = NumberOfColumns + 1;
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t TSTAnimationAddCellRangesForColumnIndex(TSTAnimation *a1, TSTTableModel *a2, uint64_t a3)
{
  unsigned __int8 v5 = [(TSTTableModel *)a2 numberOfColumns];
  unsigned int v6 = [(TSTTableModel *)a2 numberOfRows];
  unint64_t v7 = v6;
  unsigned __int8 v46 = v5;
  if (!v5)
  {
    unint64_t v42 = 0;
    unsigned __int8 v20 = -1;
    unsigned __int16 v44 = -1;
    goto LABEL_26;
  }
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  unint64_t v10 = ((unint64_t)v6 << 16) | 1;
  unint64_t v45 = v10 << 32;
  unint64_t v41 = v10 << 8;
  unint64_t v42 = 0;
  unsigned __int16 v44 = -1;
  uint64_t v11 = 255;
  do
  {
    if (!v7)
    {
LABEL_21:
      int v19 = v9;
      uint64_t v9 = v11;
      goto LABEL_22;
    }
    uint64_t v12 = 0;
    unint64_t v13 = (unint64_t)v9 << 16;
    while (1)
    {
      unint64_t v14 = TSTTableExpandCellRangeToCoverMergedCells((uint64_t)a2, v13 | v12 | 0x1000100000000);
      unint64_t v15 = v14;
      if ((_WORD)v14 == 0xFFFF
        || ((v14 & 0xFF0000) != 0xFF0000 ? (BOOL v16 = HIWORD(v14) == 0) : (BOOL v16 = 1),
            !v16 ? (BOOL v17 = (v14 & 0xFFFF00000000) == 0) : (BOOL v17 = 1),
            v17))
      {
        size_t v18 = a2;
        unint64_t v15 = v45 | ((unint64_t)v9 << 16);
      }
      else
      {
        if ((v14 & 0xFFFFFF) != (v13 | v12)) {
          goto LABEL_20;
        }
        size_t v18 = a2;
      }
      if ((TSTTableHasCellRangeHidden(v18, v15) & 1) == 0) {
        break;
      }
LABEL_20:
      if (++v12 >= v7) {
        goto LABEL_21;
      }
    }
    if (v8 != a3)
    {
      ++v8;
      uint64_t v12 = 65534;
      goto LABEL_20;
    }
    unsigned __int16 v44 = 0;
    int v19 = 254;
    uint64_t v8 = a3;
    unint64_t v42 = v41;
LABEL_22:
    unsigned __int8 v20 = v9;
    uint64_t v11 = v9;
    uint64_t v9 = (v19 + 1);
  }
  while ((v19 + 1) < v46);
LABEL_26:
  if (v7)
  {
    uint64_t v21 = 0;
    unint64_t v22 = (unint64_t)v20 << 16;
    unint64_t v23 = v42 >> 24;
    BOOL v25 = (v42 & 0xFFFF00) == 0 || v23 == 0;
    unint64_t v26 = 0xFFFFFFLL;
    unsigned int v47 = (unsigned __int16)(v44 + v23 - 1);
    unint64_t v27 = 0xFFFFFFLL;
    while (1)
    {
      unint64_t v28 = TSTTableExpandCellRangeToCoverMergedCells((uint64_t)a2, v22 | v21 | 0x1000100000000);
      unint64_t v29 = v28;
      if ((_WORD)v28 == 0xFFFF
        || ((v28 & 0xFF0000) != 0xFF0000 ? (BOOL v30 = HIWORD(v28) == 0) : (BOOL v30 = 1),
            !v30 ? (BOOL v31 = (v28 & 0xFFFF00000000) == 0) : (BOOL v31 = 1),
            v31))
      {
        if ((_WORD)v27 == 0xFFFF)
        {
          unint64_t v27 = v22 | v21 | 0x1000100000000;
        }
        else
        {
          uint64_t v32 = v27 & 0xFF0000;
          BOOL v34 = (v27 & 0xFFFF00000000) != 0 && HIWORD(v27) != 0;
          BOOL v35 = !v34;
          if (v34) {
            uint64_t v36 = v27;
          }
          else {
            uint64_t v36 = v22 | v21 | 0x1000100000000;
          }
          if (v35) {
            uint64_t v37 = v26;
          }
          else {
            uint64_t v37 = v22 | v21 | 0x1000100000000;
          }
          if (v32 == 16711680) {
            unint64_t v27 = v22 | v21 | 0x1000100000000;
          }
          else {
            unint64_t v27 = v36;
          }
          if (v32 != 16711680) {
            unint64_t v26 = v37;
          }
        }
        goto LABEL_72;
      }
      [(TSTAnimation *)a1 addCellRange:TSTCellRangeUnionCellRange(v27, v26)];
      char v38 = v44 > (unsigned __int16)v29 || v25;
      if (v38) {
        goto LABEL_70;
      }
      unint64_t v27 = 0xFFFFFFLL;
      unint64_t v26 = 0xFFFFFFLL;
      if (v47 >= (unsigned __int16)v29)
      {
        if (v20 > BYTE2(v29)) {
          goto LABEL_70;
        }
        unint64_t v27 = 0xFFFFFFLL;
        unint64_t v26 = 0xFFFFFFLL;
        if ((v20 + BYTE1(v42) - 1) >= BYTE2(v29)) {
          break;
        }
      }
LABEL_72:
      if (v7 == ++v21) {
        goto LABEL_75;
      }
    }
    [(TSTAnimation *)a1 addCellRange:v29];
LABEL_70:
    unint64_t v27 = 0xFFFFFFLL;
    unint64_t v26 = 0xFFFFFFLL;
    goto LABEL_72;
  }
  unint64_t v27 = 0xFFFFFFLL;
  unint64_t v26 = 0xFFFFFFLL;
LABEL_75:
  unint64_t v39 = TSTCellRangeUnionCellRange(v27, v26);

  return [(TSTAnimation *)a1 addCellRange:v39];
}

uint64_t TSTAnimationAddCellRangesForRowIndex(TSTAnimation *a1, TSTTableModel *a2, uint64_t a3)
{
  unsigned int v5 = [(TSTTableModel *)a2 numberOfColumns];
  unsigned int v33 = [(TSTTableModel *)a2 numberOfRows];
  if (!v33)
  {
    unsigned int v9 = v5;
    unsigned __int16 v17 = -1;
    if ((_BYTE)v5) {
      goto LABEL_32;
    }
    goto LABEL_63;
  }
  uint64_t v6 = 0;
  int v7 = 0;
  if (v5 >= 0xFF) {
    uint64_t v8 = 255;
  }
  else {
    uint64_t v8 = v5;
  }
  unsigned int v9 = v5;
  __int16 v31 = -1;
  do
  {
    if (!v9)
    {
      int v16 = v7;
      goto LABEL_30;
    }
    uint64_t v10 = 0;
    while (1)
    {
      unint64_t v11 = TSTTableExpandCellRangeToCoverMergedCells((uint64_t)a2, (unsigned __int16)v7 | (unint64_t)(v10 << 16) | 0x1000100000000);
      unint64_t v12 = v11;
      if ((_WORD)v11 == 0xFFFF
        || ((v11 & 0xFF0000) != 0xFF0000 ? (BOOL v13 = HIWORD(v11) == 0) : (BOOL v13 = 1),
            !v13 ? (BOOL v14 = (v11 & 0xFFFF00000000) == 0) : (BOOL v14 = 1),
            v14))
      {
        unint64_t v15 = a2;
        unint64_t v12 = (v8 << 32) | (unsigned __int16)v7 | 0x1000000000000;
      }
      else
      {
        if (!v8
          || (unsigned __int16)v7 != (unsigned __int16)v11
          || (v8 - 1) < BYTE2(v11))
        {
          goto LABEL_21;
        }
        unint64_t v15 = a2;
      }
      if ((TSTTableHasCellRangeHidden(v15, v12) & 1) == 0) {
        break;
      }
LABEL_21:
      if (++v10 >= (unint64_t)v5)
      {
        int v16 = v7;
        goto LABEL_29;
      }
    }
    if (v6 != a3)
    {
      ++v6;
      uint64_t v10 = 254;
      goto LABEL_21;
    }
    int v16 = 65534;
    uint64_t v6 = a3;
    __int16 v31 = v7;
LABEL_29:
    unsigned int v9 = v5;
LABEL_30:
    int v7 = v16 + 1;
  }
  while (v33 > (unsigned __int16)(v16 + 1));
  unsigned __int16 v17 = v31;
  if (!v9)
  {
LABEL_63:
    uint64_t v19 = 0;
    uint64_t v18 = 0;
    uint64_t v22 = 0xFFFFFFLL;
    uint64_t v21 = 0xFFFFFFLL;
    goto LABEL_64;
  }
LABEL_32:
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = v17;
  uint64_t v21 = 0xFFFFFFLL;
  uint64_t v22 = 0xFFFFFFLL;
  uint64_t v23 = v9;
  do
  {
    unint64_t v24 = TSTTableExpandCellRangeToCoverMergedCells((uint64_t)a2, v20 | 0x1000100000000);
    unint64_t v25 = v24;
    if ((_WORD)v24 == 0xFFFF
      || ((v24 & 0xFF0000) != 0xFF0000 ? (BOOL v26 = HIWORD(v24) == 0) : (BOOL v26 = 1),
          !v26 ? (BOOL v27 = (v24 & 0xFFFF00000000) == 0) : (BOOL v27 = 1),
          v27))
    {
      if ((_WORD)v22 == 0xFFFF || (v22 & 0xFF0000) == 0xFF0000)
      {
        uint64_t v22 = v20;
        uint64_t v19 = 65537;
      }
      else
      {
        if ((_WORD)v19) {
          BOOL v28 = (v19 & 0xFFFFFFFFFFFF0000) == 0;
        }
        else {
          BOOL v28 = 1;
        }
        if (v28) {
          uint64_t v19 = 65537;
        }
        if (v28) {
          uint64_t v22 = v20;
        }
        if (!v28)
        {
          uint64_t v18 = 65537;
          uint64_t v21 = v20;
        }
      }
    }
    else
    {
      [(TSTAnimation *)a1 addCellRange:TSTCellRangeUnionCellRange(v22 | (v19 << 32), v21 | (v18 << 32))];
      if (v20 == (v25 & 0xFFFFFF)) {
        [(TSTAnimation *)a1 addCellRange:v25];
      }
      uint64_t v19 = 0;
      uint64_t v18 = 0;
      uint64_t v22 = 0xFFFFFFLL;
      uint64_t v21 = 0xFFFFFFLL;
    }
    v20 += 0x10000;
    --v23;
  }
  while (v23);
LABEL_64:
  unint64_t v29 = TSTCellRangeUnionCellRange(v22 | (v19 << 32), v21 | (v18 << 32));

  return [(TSTAnimation *)a1 addCellRange:v29];
}

unint64_t TSTAnimationAddCellRangeForCellIndex(TSTAnimation *a1, TSTTableModel *a2, uint64_t a3)
{
  unsigned __int8 v5 = [(TSTTableModel *)a2 numberOfColumns];
  unint64_t result = [(TSTTableModel *)a2 numberOfRows];
  if (!result) {
    return result;
  }
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t v15 = result;
  int v16 = v5;
  unint64_t v9 = (unint64_t)v5 << 16;
  while (!v16)
  {
LABEL_21:
    if (++v7 == v15) {
      return result;
    }
  }
  uint64_t v10 = 0;
  while (1)
  {
    unint64_t result = TSTTableExpandCellRangeToCoverMergedCells((uint64_t)a2, v10 | v7 | 0x1000100000000);
    uint64_t v11 = result;
    if ((_WORD)result != 0xFFFF)
    {
      BOOL v12 = (result & 0xFF0000) == 0xFF0000 || HIWORD(result) == 0;
      if (!v12 && (result & 0xFFFF00000000) != 0) {
        break;
      }
    }
    unint64_t result = TSTTableHasCellRangeHidden(a2, v10 | v7 | 0x1000100000000);
    if ((result & 1) == 0)
    {
      uint64_t v11 = v10 | v7 | 0x1000100000000;
      goto LABEL_16;
    }
LABEL_20:
    v10 += 0x10000;
    if (v9 == v10) {
      goto LABEL_21;
    }
  }
  if ((v10 | v7) != (result & 0xFFFFFF)) {
    goto LABEL_20;
  }
  unint64_t result = TSTTableHasCellRangeHidden(a2, result);
  if (result) {
    goto LABEL_20;
  }
LABEL_16:
  if (v8 != a3)
  {
    ++v8;
    goto LABEL_20;
  }

  return [(TSTAnimation *)a1 addCellRange:v11];
}

uint64_t TSTAnimationGetNumberOfColumns(TSTTableModel *a1)
{
  unsigned __int8 v2 = [(TSTTableModel *)a1 numberOfColumns];
  uint64_t v3 = [(TSTTableModel *)a1 numberOfRows];
  uint64_t v17 = v2;
  if (v2)
  {
    unsigned int v4 = v3;
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    uint64_t v16 = v3 << 48;
    unsigned int v7 = (unsigned __int16)(v3 - 1);
    while (!v4)
    {
LABEL_24:
      if (++v5 == v17) {
        return v6;
      }
    }
    unsigned __int16 v8 = 0;
    while (1)
    {
      unint64_t v9 = TSTTableExpandCellRangeToCoverMergedCells((uint64_t)a1, (v5 << 16) & 0xFFFF0000 | v8 | 0x1000100000000);
      unint64_t v10 = v9;
      if ((_WORD)v9 == 0xFFFF) {
        break;
      }
      BOOL v11 = (v9 & 0xFF0000) == 0xFF0000 || HIWORD(v9) == 0;
      if (v11 || (v9 & 0xFFFF00000000) == 0) {
        break;
      }
      if ((v16 | (v5 << 16) | 0x100000000uLL) >> 48 && v7 >= (unsigned __int16)v9 && v5 == BYTE2(v9))
      {
        BOOL v13 = a1;
        goto LABEL_15;
      }
LABEL_18:
      if (v4 <= ++v8) {
        goto LABEL_24;
      }
    }
    BOOL v13 = a1;
    unint64_t v10 = v16 | (v5 << 16) | 0x100000000;
LABEL_15:
    int HasCellRangeHidden = TSTTableHasCellRangeHidden(v13, v10);
    if (!HasCellRangeHidden) {
      unsigned __int16 v8 = -2;
    }
    v6 += HasCellRangeHidden ^ 1u;
    goto LABEL_18;
  }
  return 0;
}

uint64_t TSTAnimationGetNumberOfRows(TSTTableModel *a1)
{
  unsigned int v2 = [(TSTTableModel *)a1 numberOfColumns];
  unsigned int v3 = [(TSTTableModel *)a1 numberOfRows];
  if (v3)
  {
    uint64_t v4 = 0;
    uint64_t v5 = 0;
    if (v2 >= 0xFF) {
      uint64_t v6 = 255;
    }
    else {
      uint64_t v6 = v2;
    }
    uint64_t v15 = v3;
    while (!(_BYTE)v2)
    {
LABEL_27:
      if (++v4 == v15) {
        return v5;
      }
    }
    unsigned __int8 v7 = 0;
    while (1)
    {
      unint64_t v8 = TSTTableExpandCellRangeToCoverMergedCells((uint64_t)a1, v4 | ((unint64_t)v7 << 16) | 0x1000100000000);
      if ((unsigned __int16)v8 == 0xFFFFLL) {
        break;
      }
      unint64_t v9 = v8;
      BOOL v10 = (v8 & 0xFF0000) == 0xFF0000 || HIWORD(v8) == 0;
      if (v10 || (v8 & 0xFFFF00000000) == 0) {
        break;
      }
      if (v6 && v4 == (unsigned __int16)v8 && (v6 - 1) >= BYTE2(v8))
      {
        BOOL v12 = a1;
        goto LABEL_18;
      }
LABEL_21:
      if (++v7 >= v2) {
        goto LABEL_27;
      }
    }
    BOOL v12 = a1;
    unint64_t v9 = (v6 << 32) | v4 | 0x1000000000000;
LABEL_18:
    int HasCellRangeHidden = TSTTableHasCellRangeHidden(v12, v9);
    if (!HasCellRangeHidden) {
      unsigned __int8 v7 = -2;
    }
    v5 += HasCellRangeHidden ^ 1u;
    goto LABEL_21;
  }
  return 0;
}

uint64_t TSTAnimationGetNumberOfCells(TSTTableModel *a1)
{
  unsigned __int8 v2 = [(TSTTableModel *)a1 numberOfColumns];
  unsigned int v3 = [(TSTTableModel *)a1 numberOfRows];
  if (!v3) {
    return 0;
  }
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  int v6 = v2;
  uint64_t v7 = v3;
  unint64_t v8 = (unint64_t)v2 << 16;
  do
  {
    if (v6)
    {
      uint64_t v9 = 0;
      do
      {
        unint64_t v10 = v9 | v4 | 0x1000100000000;
        unint64_t v11 = TSTTableExpandCellRangeToCoverMergedCells((uint64_t)a1, v10);
        if ((_WORD)v11 == 0xFFFF
          || ((v11 & 0xFF0000) != 0xFF0000 ? (BOOL v12 = HIWORD(v11) == 0) : (BOOL v12 = 1),
              !v12 ? (BOOL v13 = (v11 & 0xFFFF00000000) == 0) : (BOOL v13 = 1),
              v13 || (unint64_t v10 = v11, (v9 | v4) == (v11 & 0xFFFFFF))))
        {
          v5 += TSTTableHasCellRangeHidden(a1, v10) ^ 1;
        }
        v9 += 0x10000;
      }
      while (v8 != v9);
    }
    ++v4;
  }
  while (v4 != v7);
  return v5;
}

void TSTTableDumpTileRowInfo(uint64_t a1)
{
  if (*(_WORD *)(a1 + 538))
  {
    MutableBytePtr = CFDataGetMutableBytePtr(*(CFMutableDataRef *)(a1 + 16));
    unint64_t v24 = objc_alloc_init(TSTCell);
    uint64_t v3 = 0;
    unsigned __int16 v4 = 0;
    do
    {
      if (*(unsigned __int16 *)(a1 + 538) == v4) {
        break;
      }
      uint64_t v5 = *(unsigned __int16 *)(a1 + 24 + 2 * v3);
      if (v5 != 0xFFFF)
      {
        int v6 = &MutableBytePtr[v5];
        TSTCellInflateFromStorageRef((uint64_t)v24, &MutableBytePtr[v5], 0);
        if (v24)
        {
          int mPrivate = (int)v24->mPrivate;
          uint64_t v8 = BYTE1(mPrivate);
          if (BYTE1(mPrivate) > 9u)
          {
LABEL_15:
            uint64_t v9 = @"<unknown cell type>";
          }
          else
          {
            uint64_t v9 = @"<empty>";
            switch(BYTE1(mPrivate))
            {
              case 1:
              case 4:
                goto LABEL_15;
              case 2:
                unint64_t v10 = NSString;
                if ((*(_DWORD *)&v24->mPrivate & 0xFB00) == 0x200 || BYTE1(mPrivate) == 7)
                {
                  mDate = v24->mPrivate.mValue.mDate;
                }
                else
                {
                  mDate = 0;
                  if (BYTE1(mPrivate))
                  {
                    uint64_t v22 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
                    uint64_t v20 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
                    objc_msgSend(v22, "handleFailureInFunction:file:lineNumber:description:", v20, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", v24);
                  }
                }
                uint64_t v9 = (__CFString *)objc_msgSend(v10, "stringWithFormat:", @"<number: %f>", mDate);
                break;
              case 3:
                uint64_t v9 = (__CFString *)[NSString stringWithFormat:@"<string: '%@'>", v24->mPrivate.mValue.mString.mString];
                break;
              case 5:
                uint64_t v9 = (__CFString *)[NSString stringWithFormat:@"<date: '%@'>", -[NSDate description](v24->mPrivate.mValue.mDate, "description")];
                break;
              case 6:
                BOOL v13 = NSString;
                if ((*(_DWORD *)&v24->mPrivate & 0xFB00) == 0x200 || BYTE1(mPrivate) == 7)
                {
                  uint64_t v15 = @"TRUE";
                  if (v24->mPrivate.mValue.mDouble == 0.0) {
                    uint64_t v15 = @"FALSE";
                  }
                }
                else
                {
                  if (BYTE1(mPrivate))
                  {
                    uint64_t v23 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
                    uint64_t v21 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
                    objc_msgSend(v23, "handleFailureInFunction:file:lineNumber:description:", v21, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", v24);
                  }
                  uint64_t v15 = @"FALSE";
                }
                uint64_t v9 = (__CFString *)[v13 stringWithFormat:@"<BOOL: '%@'>", v15];
                break;
              case 7:
                uint64_t v9 = (__CFString *)objc_msgSend(NSString, "stringWithFormat:", @"<duration: %f>", v24->mPrivate.mValue.mDate);
                break;
              case 8:
                uint64_t v16 = NSString;
                uint64_t v17 = @"<error>";
                goto LABEL_29;
              case 9:
                uint64_t v18 = NSString;
                uint64_t v19 = [(TSTRichTextPayload *)v24->mPrivate.mRichTextPayload string];
                uint64_t v16 = v18;
                uint64_t v17 = @"<rich text: '%@'>";
LABEL_29:
                uint64_t v9 = (__CFString *)objc_msgSend(v16, "stringWithFormat:", v17, v19);
                break;
              default:
                break;
            }
          }
        }
        else
        {
          uint64_t v8 = 0;
          uint64_t v9 = @"<empty>";
        }
        NSLog((NSString *)@"cell: column %d cell %p type %d [value %@]", v3, v6, v8, v9);
        ++v4;
      }
      ++v3;
    }
    while (v3 != 255);
  }
  else
  {
    NSLog((NSString *)@"<empty row>");
  }
}

size_t TSTTableTileRowInfoFlushableSize(uint64_t a1)
{
  unsigned __int8 v2 = (objc_class *)objc_opt_class();
  size_t InstanceSize = class_getInstanceSize(v2);
  CFDataRef v4 = *(const __CFData **)(a1 + 16);
  if (v4) {
    InstanceSize += CFDataGetLength(v4);
  }
  return InstanceSize;
}

uint64_t TSTTableTileRowInfoRecalculateMaxTileColumnIndex(uint64_t result)
{
  *(unsigned char *)(result + 540) = -1;
  unsigned int v1 = 254;
  while (*(__int16 *)(result + 24 + 2 * v1) == -1)
  {
    if (--v1 == -1) {
      goto LABEL_6;
    }
  }
  *(unsigned char *)(result + 540) = v1;
LABEL_6:
  *(unsigned char *)(result + 541) = 1;
  return result;
}

UInt8 *TSTTableTileRowInfoCellStorageRefAtTileColumnIndex(uint64_t a1, unsigned int a2)
{
  if (!*(_WORD *)(a1 + 538)) {
    return 0;
  }
  uint64_t v2 = *(unsigned __int16 *)(a1 + 24 + 2 * a2);
  if (v2 == 0xFFFF) {
    return 0;
  }
  else {
    return &CFDataGetMutableBytePtr(*(CFMutableDataRef *)(a1 + 16))[v2];
  }
}

void TSTTableTileRowInfoSetCell(TSTTableTileRowInfo *a1, unsigned int a2, void *a3)
{
  int v5 = a1->mStorageOffsets[a2];
  if (a3)
  {
    [(TSPContainedObject *)a1 willModify];
    if (v5 == 0xFFFF)
    {
      int v21 = TSTCellStorageHeaderFlagsForCell((uint64_t)a3);
      int v22 = TSTCellStorageFormatFlagsForCell(a3);
      unsigned int v23 = TSTCellStorageSizeForHeaderFlags(v21, v22);
      __int16 v24 = v23;
      CFIndex v25 = a1->mBufferSize + (unint64_t)v23;
      mStorageBuffer = a1->mStorageBuffer;
      if (v25) {
        BOOL v27 = mStorageBuffer == 0;
      }
      else {
        BOOL v27 = 0;
      }
      if (v27)
      {
        mStorageBuffer = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
        a1->mStorageBuffer = mStorageBuffer;
      }
      if (CFDataGetLength(mStorageBuffer) < v25)
      {
        CFDataSetLength(a1->mStorageBuffer, v25);
        a1->mBufferSize = v25;
      }
      MutableBytePtr = CFDataGetMutableBytePtr(a1->mStorageBuffer);
      unsigned int v29 = p_OffsetForInsert(a1, a2, MutableBytePtr);
      unsigned __int16 v30 = v29;
      if (!a1->mMaxTileColumnIndexValid)
      {
        a1->mMaxTileColumnIndedouble x = -1;
        int v31 = 254;
        while ((__int16)a1->mStorageOffsets[v31] == -1)
        {
          if (--v31 == -1) {
            goto LABEL_33;
          }
        }
        a1->mMaxTileColumnIndedouble x = v31;
LABEL_33:
        a1->mMaxTileColumnIndexValid = 1;
      }
      mMaxTileColumnIndedouble x = a1->mMaxTileColumnIndex;
      if (a1->mCellCount) {
        BOOL v33 = mMaxTileColumnIndex > a2;
      }
      else {
        BOOL v33 = 0;
      }
      if (v33)
      {
        uint64_t v34 = v29;
        memmove(&MutableBytePtr[v29 + v24], &MutableBytePtr[v29], a1->mBufferSize - ((v24 & ~(v24 >> 31)) + (unint64_t)v29));
        unsigned __int8 v35 = a2 + 1;
        do
        {
          int v36 = a1->mStorageOffsets[v35];
          if (v36 != 0xFFFF) {
            a1->mStorageOffsets[v35] = v36 + v24;
          }
          ++v35;
        }
        while (mMaxTileColumnIndex >= v35);
      }
      else
      {
        uint64_t v34 = v29;
      }
      TSTCellWriteStorageRef(a3, &MutableBytePtr[v34]);
      a1->mStorageOffsets[a2] = v30;
      ++a1->mCellCount;
      if (a1->mMaxTileColumnIndexValid)
      {
        unsigned int v37 = a1->mMaxTileColumnIndex;
        if (v37 == 255 || v37 < a2) {
          a1->mMaxTileColumnIndedouble x = a2;
        }
      }
    }
    else
    {
      uint64_t v7 = CFDataGetMutableBytePtr(a1->mStorageBuffer);
      uint64_t v8 = a1->mStorageOffsets[a2];
      uint64_t v9 = &v7[v8];
      TSTCellStorageVersionAssert(&v7[v8]);
      int v10 = TSTCellStorageHeaderFlagsForStorage((uint64_t)&v7[v8]);
      int v11 = TSTCellStorageFormatFlagsForStorage(&v7[v8]);
      int v12 = TSTCellStorageSizeForHeaderFlags(v10, v11);
      int v13 = TSTCellStorageHeaderFlagsForCell((uint64_t)a3);
      int v14 = TSTCellStorageFormatFlagsForCell(a3);
      int v15 = TSTCellStorageSizeForHeaderFlags(v13, v14);
      __int16 v16 = v15 - v12;
      if (v15 != v12)
      {
        int v17 = v16;
        if (v16 >= 1)
        {
          CFIndex v18 = a1->mBufferSize + v16;
          Mutable = a1->mStorageBuffer;
          if (!Mutable)
          {
            Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
            a1->mStorageBuffer = Mutable;
          }
          if (CFDataGetLength(Mutable) < v18)
          {
            CFDataSetLength(a1->mStorageBuffer, v18);
            a1->mBufferSize = v18;
          }
          uint64_t v7 = CFDataGetMutableBytePtr(a1->mStorageBuffer);
        }
        if (!a1->mMaxTileColumnIndexValid)
        {
          a1->mMaxTileColumnIndedouble x = -1;
          int v20 = 254;
          while ((__int16)a1->mStorageOffsets[v20] == -1)
          {
            if (--v20 == -1) {
              goto LABEL_51;
            }
          }
          a1->mMaxTileColumnIndedouble x = v20;
LABEL_51:
          a1->mMaxTileColumnIndexValid = 1;
        }
        unsigned int v39 = a1->mMaxTileColumnIndex;
        if (v39 > a2)
        {
          memmove(&v7[(unsigned __int16)(v12 + v8) + v17], &v7[(unsigned __int16)(v12 + v8)], a1->mBufferSize - ((v17 & ~(v17 >> 31)) + (unint64_t)(unsigned __int16)(v12 + v8)));
          unsigned __int8 v40 = a2 + 1;
          do
          {
            int v41 = a1->mStorageOffsets[v40];
            if (v41 != 0xFFFF) {
              a1->mStorageOffsets[v40] = v41 + v17;
            }
            ++v40;
          }
          while (v39 >= v40);
        }
        if (v17 < 0)
        {
          CFIndex v42 = a1->mBufferSize + (uint64_t)v17;
          long long v43 = a1->mStorageBuffer;
          if ((int)v42 >= 1 && v43 == 0)
          {
            long long v43 = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
            a1->mStorageBuffer = v43;
          }
          if (CFDataGetLength(v43) < v42)
          {
            CFDataSetLength(a1->mStorageBuffer, v42);
            a1->mBufferSize = v42;
          }
          uint64_t v7 = CFDataGetMutableBytePtr(a1->mStorageBuffer);
        }
        uint64_t v9 = &v7[v8];
      }
      TSTCellWriteStorageRef(a3, v9);
    }
  }
  else if (v5 != 0xFFFF)
  {
    p_RemoveCell(a1, a2);
  }
}

void p_RemoveCell(TSTTableTileRowInfo *a1, unsigned int a2)
{
  [(TSPContainedObject *)a1 willModify];
  uint64_t v4 = a1->mStorageOffsets[a2];
  if (v4 != 0xFFFF)
  {
    MutableBytePtr = CFDataGetMutableBytePtr(a1->mStorageBuffer);
    TSTCellStorageVersionAssert(&MutableBytePtr[v4]);
    int v6 = TSTCellStorageHeaderFlagsForStorage((uint64_t)&MutableBytePtr[v4]);
    int v7 = TSTCellStorageFormatFlagsForStorage(&MutableBytePtr[v4]);
    unsigned int v8 = TSTCellStorageSizeForHeaderFlags(v6, v7);
    unsigned int v9 = v8;
    if (!a1->mMaxTileColumnIndexValid)
    {
      a1->mMaxTileColumnIndedouble x = -1;
      int v10 = 254;
      while ((__int16)a1->mStorageOffsets[v10] == -1)
      {
        if (--v10 == -1) {
          goto LABEL_8;
        }
      }
      a1->mMaxTileColumnIndedouble x = v10;
LABEL_8:
      a1->mMaxTileColumnIndexValid = 1;
    }
    mMaxTileColumnIndedouble x = a1->mMaxTileColumnIndex;
    if (mMaxTileColumnIndex > a2)
    {
      memmove(&MutableBytePtr[(unsigned __int16)(v8 + v4) + (__int16)-(__int16)v8], &MutableBytePtr[(unsigned __int16)(v8 + v4)], a1->mBufferSize- (((__int16)-(__int16)v8 & ~((__int16)-(__int16)v8 >> 31))+ (unint64_t)(unsigned __int16)(v8 + v4)));
      unsigned __int8 v12 = a2 + 1;
      do
      {
        int v13 = a1->mStorageOffsets[v12];
        if (v13 != 0xFFFF) {
          a1->mStorageOffsets[v12] = v13 - v9;
        }
        ++v12;
      }
      while (mMaxTileColumnIndex >= v12);
    }
    CFIndex v14 = a1->mBufferSize - (unint64_t)v9;
    mStorageBuffer = a1->mStorageBuffer;
    if (v14 >= 1 && mStorageBuffer == 0)
    {
      mStorageBuffer = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
      a1->mStorageBuffer = mStorageBuffer;
    }
    if (CFDataGetLength(mStorageBuffer) < v14)
    {
      CFDataSetLength(a1->mStorageBuffer, v14);
      a1->mBufferSize = v14;
    }
    a1->mStorageOffsets[a2] = -1;
    --a1->mCellCount;
    if (a1->mMaxTileColumnIndexValid && a1->mMaxTileColumnIndex <= a2)
    {
      a1->mMaxTileColumnIndedouble x = -1;
      a1->mMaxTileColumnIndexValid = 0;
    }
  }
}

uint64_t TSTTableTileRowInfoInsertColumns(unsigned char *a1, char a2, unsigned int a3, char a4)
{
  uint64_t result = [a1 willModify];
  unsigned __int8 v9 = (a4 ^ 1) + a2;
  if (v9 + (_BYTE)a3 != 0xFF)
  {
    unint64_t v10 = 254;
    do
      *(_WORD *)&a1[2 * v10 + 24] = *(_WORD *)&a1[2 * v10 + 24 + -2 * a3];
    while (v10-- > (v9 + a3));
  }
  if (((a4 ^ 1) + a2) < (v9 + a3))
  {
    unsigned __int8 v12 = &a1[2 * v9];
    unint64_t v13 = (v9 + a3) - (unint64_t)v9;
    do
    {
      *((_WORD *)v12 + 12) = -1;
      v12 += 2;
      --v13;
    }
    while (v13);
  }
  a1[540] = -1;
  a1[541] = 0;
  return result;
}

void TSTTableTileRowInfoRemoveColumns(TSTTableTileRowInfo *a1, int a2, int a3)
{
  [(TSPContainedObject *)a1 willModify];
  if ((_BYTE)a3)
  {
    unsigned __int8 v6 = a2;
    do
    {
      if ((__int16)a1->mStorageOffsets[v6] != -1) {
        p_RemoveCell(a1, v6);
      }
      ++v6;
    }
    while (a2 + a3 > v6);
  }
  if (254 - a3 >= a2)
  {
    int v7 = a2;
    do
    {
      a1->mStorageOffsets[a2++] = a1->mStorageOffsets[v7 + a3];
      int v7 = a2;
    }
    while (254 - a3 >= a2);
  }
  if ((_BYTE)a3)
  {
    uint64_t v8 = ~(_BYTE)a3;
    do
      a1->mStorageOffsets[v8++] = -1;
    while (v8 != 255);
  }
  a1->mMaxTileColumnIndedouble x = -1;
  a1->mMaxTileColumnIndexValid = 0;
}

void TSTTableTileRowInfoMoveColumns(TSTTableTileRowInfo *a1, unsigned int a2, unsigned int a3, int a4, void *a5, unsigned __int16 *a6)
{
  [(TSPContainedObject *)a1 willModify];
  unsigned __int8 v12 = a3;
  if (a3 > a2)
  {
    if (a4 + a2 > a3)
    {
      unint64_t v13 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v14 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableTileRowInfoMoveColumns(TSTTableTileRowInfo *, TSUColumnIndex, TSUColumnIndex, TSUColumnRowCount, UInt8 *, UInt16 *)");
      objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTileRowInfo.mm"), 520, @"Move column ranges cannot overlap!");
    }
    unsigned __int8 v12 = a3 - a4;
  }
  if (a1->mCellCount)
  {
    if (!a1->mMaxTileColumnIndexValid)
    {
      a1->mMaxTileColumnIndedouble x = -1;
      unsigned int v15 = 254;
      while ((__int16)a1->mStorageOffsets[v15] == -1)
      {
        if (--v15 == -1) {
          goto LABEL_12;
        }
      }
      a1->mMaxTileColumnIndedouble x = v15;
LABEL_12:
      a1->mMaxTileColumnIndexValid = 1;
    }
    mMaxTileColumnIndedouble x = a1->mMaxTileColumnIndex;
    if (mMaxTileColumnIndex >= a3 || mMaxTileColumnIndex >= a2)
    {
      unint64_t v18 = a2;
      unint64_t v19 = (a2 + a4 - 1);
      do
      {
        unint64_t v20 = v18;
        uint64_t v21 = a1->mStorageOffsets[v18++];
      }
      while (v20 < v19 && v21 == 0xFFFF);
      __dst = a5;
      uint64_t v52 = a6;
      unsigned int size = a4;
      unsigned __int8 size_4 = v12;
      unsigned int v53 = a2;
      if (v21 == 0xFFFF
        || (unsigned __int8 v22 = v18 - 1, MutableBytePtr = CFDataGetMutableBytePtr(a1->mStorageBuffer), v19 < v22))
      {
        LOWORD(v24) = 0;
      }
      else
      {
        CFIndex v25 = MutableBytePtr;
        int v24 = 0;
        do
        {
          int v26 = a1->mStorageOffsets[v22];
          if (v26 != 0xFFFF)
          {
            if (v21 + (unsigned __int16)v24 != v26)
            {
              BOOL v27 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
              uint64_t v28 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTTableTileRowInfoRegion p_RegionForColumns(TSTTableTileRowInfo *, TSUColumnIndex, TSUColumnRowCount)");
              objc_msgSend(v27, "handleFailureInFunction:file:lineNumber:description:", v28, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTileRowInfo.mm"), 395, @"Storage region is out of sync!");
            }
            TSTCellStorageVersionAssert(&v25[v26]);
            int v29 = TSTCellStorageHeaderFlagsForStorage((uint64_t)&v25[v26]);
            int v30 = TSTCellStorageFormatFlagsForStorage(&v25[v26]);
            v24 += TSTCellStorageSizeForHeaderFlags(v29, v30);
          }
          ++v22;
        }
        while (v19 >= v22);
      }
      int v31 = CFDataGetMutableBytePtr(a1->mStorageBuffer);
      if ((_WORD)v24)
      {
        uint64_t v32 = v31;
        BOOL v33 = a5;
        if (!a5) {
          BOOL v33 = malloc_type_malloc((unsigned __int16)v24, 0x3D73AB96uLL);
        }
        memcpy(v33, &v32[v21], (unsigned __int16)v24);
        uint64_t v34 = v52;
        unsigned int v35 = size;
        if (!v52) {
          uint64_t v34 = (unsigned __int16 *)malloc_type_calloc(2uLL, size, 0xE86D943EuLL);
        }
        unsigned __int8 v36 = size_4;
        if ((_BYTE)size)
        {
          uint64_t v37 = 0;
          do
          {
            unsigned __int16 v38 = a1->mStorageOffsets[v53 + v37];
            if (v38 == 0xFFFF) {
              __int16 v39 = -1;
            }
            else {
              __int16 v39 = v38 - v21;
            }
            v34[v37++] = v39;
          }
          while (size != v37);
        }
      }
      else
      {
        BOOL v33 = 0;
        uint64_t v34 = 0;
        unsigned int v35 = size;
        unsigned __int8 v36 = size_4;
      }
      TSTTableTileRowInfoRemoveColumns(a1, v53, v35);
      TSTTableTileRowInfoInsertColumns(a1, v36, v35, 1);
      unsigned __int8 v40 = CFDataGetMutableBytePtr(a1->mStorageBuffer);
      unsigned int v41 = p_OffsetForInsert(a1, v36, v40);
      if (v33)
      {
        __int16 v42 = v41;
        unint64_t v54 = v34;
        long long v43 = &v40[v41];
        memmove(&v43[(__int16)v24], v43, a1->mBufferSize - (((__int16)v24 & ~((__int16)v24 >> 31)) + (unint64_t)v41));
        memcpy(v43, v33, (unsigned __int16)v24);
        uint64_t v44 = v35;
        if ((_BYTE)v35)
        {
          unint64_t v45 = (char *)a1 + 2 * size_4;
          do
          {
            if (*((__int16 *)v45 + 12) != -1)
            {
              unsigned __int8 v46 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
              uint64_t v47 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableTileRowInfoMoveColumns(TSTTableTileRowInfo *, TSUColumnIndex, TSUColumnIndex, TSUColumnRowCount, UInt8 *, UInt16 *)");
              objc_msgSend(v46, "handleFailureInFunction:file:lineNumber:description:", v47, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTileRowInfo.mm"), 580, @"Overwriting a column in move!");
            }
            int v48 = *v34;
            if (v48 != 0xFFFF)
            {
              *((_WORD *)v45 + 12) = v48 + v42;
              ++a1->mCellCount;
            }
            v45 += 2;
            ++v34;
            --v44;
          }
          while (v44);
        }
        if (size_4 + (_BYTE)size != 0xFF)
        {
          uint64_t v49 = (size_4 + size);
          do
          {
            int v50 = a1->mStorageOffsets[v49];
            if (v50 != 0xFFFF) {
              a1->mStorageOffsets[v49] = v50 + v24;
            }
            ++v49;
          }
          while (v49 != 255);
        }
        if (v33 != __dst) {
          free(v33);
        }
        if (v54 != v52) {
          free(v54);
        }
      }
      a1->mMaxTileColumnIndedouble x = -1;
      a1->mMaxTileColumnIndexValid = 0;
    }
  }
}

uint64_t p_OffsetForInsert(TSTTableTileRowInfo *a1, unsigned int a2, unsigned __int8 *a3)
{
  if (a2)
  {
    uint64_t v3 = a2;
    while (v3-- >= 1)
    {
      uint64_t v5 = a1->mStorageOffsets[v3];
      if (v5 != 0xFFFF)
      {
        unsigned __int8 v6 = &a3[v5];
        TSTCellStorageVersionAssert(&a3[v5]);
        int v7 = TSTCellStorageHeaderFlagsForStorage((uint64_t)v6);
        int v8 = TSTCellStorageFormatFlagsForStorage(v6);
        return (unsigned __int16)(TSTCellStorageSizeForHeaderFlags(v7, v8) + v5);
      }
    }
    return 0;
  }
  else
  {
    return 0;
  }
}

void sub_2237B5BE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void SFUtility::ObjcSharedPtr<NSObject>::reset(void **a1, void *a2)
{
  if (*a1 != a2)
  {
    id v4 = a2;
    uint64_t v5 = *a1;
    *a1 = a2;
  }
}

void *std::__hash_table<std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,TSTIntHasher,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::equal_to<unsigned int>,TSTIntHasher,true>,std::allocator<std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int const,SFUtility::ObjcSharedPtr<NSObject>>>(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
    unsigned __int8 v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == v6) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  unsigned __int8 v12 = (void *)(a1 + 16);
  unint64_t v10 = operator new(0x20uLL);
  void *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *(_DWORD *)a3;
  unint64_t v13 = *(void **)(a3 + 8);
  v10[3] = v13;
  id v14 = v13;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v16 = *(float *)(a1 + 32);
  if (!v7 || (float)(v16 * (float)v7) < v15)
  {
    BOOL v17 = 1;
    if (v7 >= 3) {
      BOOL v17 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v7);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v18;
    }
    std::__hash_table<std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::__unordered_map_hasher<EQKit::StemStretch::Key,std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::hash<EQKit::StemStretch::Key>,std::equal_to<EQKit::StemStretch::Key>,true>,std::__unordered_map_equal<EQKit::StemStretch::Key,std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::equal_to<EQKit::StemStretch::Key>,std::hash<EQKit::StemStretch::Key>,true>,std::allocator<std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>>>::__rehash<true>(a1, v20);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v21 = *(void *)a1;
  unsigned __int8 v22 = *(void **)(*(void *)a1 + 8 * v3);
  if (v22)
  {
    void *v10 = *v22;
LABEL_38:
    *unsigned __int8 v22 = v10;
    goto LABEL_39;
  }
  void *v10 = *v12;
  void *v12 = v10;
  *(void *)(v21 + 8 * v3) = v12;
  if (*v10)
  {
    unint64_t v23 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v23 >= v7) {
        v23 %= v7;
      }
    }
    else
    {
      v23 &= v7 - 1;
    }
    unsigned __int8 v22 = (void *)(*(void *)a1 + 8 * v23);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_2237B60A4(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<long long const,NSMutableArray * {__strong}>,void *>>>::operator()[abi:nn180100](v2, v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,TSTIntHasher,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::equal_to<unsigned int>,TSTIntHasher,true>,std::allocator<std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>>>::__erase_unique<unsigned int>(void *a1, unsigned int *a2)
{
  uint64_t result = std::__hash_table<std::__hash_value_type<unsigned int,std::pair<EQKit::Font::STIXCollection::StretchInfo,unsigned long>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::pair<EQKit::Font::STIXCollection::StretchInfo,unsigned long>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::pair<EQKit::Font::STIXCollection::StretchInfo,unsigned long>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::pair<EQKit::Font::STIXCollection::StretchInfo,unsigned long>>>>::find<unsigned int>(a1, a2);
  if (result)
  {
    std::__hash_table<std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,TSTIntHasher,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::equal_to<unsigned int>,TSTIntHasher,true>,std::allocator<std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>>>::erase(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,TSTIntHasher,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::equal_to<unsigned int>,TSTIntHasher,true>,std::allocator<std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>>>::erase(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  std::__hash_table<std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::__unordered_map_hasher<EQKit::StemStretch::Key,std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::hash<EQKit::StemStretch::Key>,std::equal_to<EQKit::StemStretch::Key>,true>,std::__unordered_map_equal<EQKit::StemStretch::Key,std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::equal_to<EQKit::StemStretch::Key>,std::hash<EQKit::StemStretch::Key>,true>,std::allocator<std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>>>::remove(a1, a2, (uint64_t)&__p);
  unint64_t v3 = (id *)__p;
  __p = 0;
  if (v3)
  {
    if (v6) {

    }
    operator delete(v3);
  }
  return v2;
}

void std::__hash_table<std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,TSTIntHasher,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::equal_to<unsigned int>,TSTIntHasher,true>,std::allocator<std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>>>::clear(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<long long const,NSMutableArray * {__strong}>,std::__unordered_map_hasher<long long const,std::__hash_value_type<long long const,NSMutableArray * {__strong}>,TSP::IdentifierHash,std::equal_to<long long const>,true>,std::__unordered_map_equal<long long const,std::__hash_value_type<long long const,NSMutableArray * {__strong}>,std::equal_to<long long const>,TSP::IdentifierHash,true>,std::allocator<std::__hash_value_type<long long const,NSMutableArray * {__strong}>>>::__deallocate_node(a1, *(id **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
}

double TSTTableBadgeCheckboxFrame(double a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, uint64_t a6, int a7, void *a8, uint64_t a9)
{
  double v25 = 0.0;
  float v15 = (void *)p_TSTTableBadgeCheckboxImageForScale(a7, &v25, a1);
  if (!v15)
  {
    float v16 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v17 = objc_msgSend(NSString, "stringWithUTF8String:", "CGRect TSTTableBadgeCheckboxFrame(TSTTableRep *, CGFloat, CGRect, BOOL, TSUImage **, CGSize *)");
    objc_msgSend(v16, "handleFailureInFunction:file:lineNumber:description:", v17, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableBadge.m"), 196, @"No checkbox image for rendering!");
  }
  [v15 size];
  double v20 = TSDMultiplySizeScalar(v18, v19, v25);
  uint64_t v22 = v21;
  v26.origin.double x = a2;
  v26.origin.CGFloat y = a3;
  v26.size.double width = a4;
  v26.size.CGFloat height = a5;
  double MidX = CGRectGetMidX(v26);
  v27.origin.double x = a2;
  v27.origin.CGFloat y = a3;
  v27.size.double width = a4;
  v27.size.CGFloat height = a5;
  CGRectGetMidY(v27);
  if (a8) {
    *a8 = v15;
  }
  if (a9)
  {
    *(double *)a9 = v20;
    *(void *)(a9 + 8) = v22;
  }
  return MidX - v20 * 0.5;
}

uint64_t p_TSTTableBadgeCheckboxImageForScale(int a1, double *a2, double a3)
{
  if (a1)
  {
    if (a3 > 0.5)
    {
      if (a3 <= 1.0)
      {
        uint64_t v5 = (void *)MEMORY[0x263F7C858];
        uint64_t v6 = TSTBundle();
        unint64_t v7 = @"TSTiOSCheckboxChecked12";
      }
      else
      {
        uint64_t v5 = (void *)MEMORY[0x263F7C858];
        uint64_t v6 = TSTBundle();
        if (a3 <= 1.5) {
          unint64_t v7 = @"TSTiOSCheckboxChecked18";
        }
        else {
          unint64_t v7 = @"TSTiOSCheckboxChecked24";
        }
      }
    }
    else
    {
      uint64_t v5 = (void *)MEMORY[0x263F7C858];
      uint64_t v6 = TSTBundle();
      unint64_t v7 = @"TSTiOSCheckboxChecked6";
    }
  }
  else if (a3 > 0.5)
  {
    if (a3 <= 1.0)
    {
      uint64_t v5 = (void *)MEMORY[0x263F7C858];
      uint64_t v6 = TSTBundle();
      unint64_t v7 = @"TSTiOSCheckboxUnchecked12";
    }
    else
    {
      uint64_t v5 = (void *)MEMORY[0x263F7C858];
      uint64_t v6 = TSTBundle();
      if (a3 <= 1.5) {
        unint64_t v7 = @"TSTiOSCheckboxUnchecked18";
      }
      else {
        unint64_t v7 = @"TSTiOSCheckboxUnchecked24";
      }
    }
  }
  else
  {
    uint64_t v5 = (void *)MEMORY[0x263F7C858];
    uint64_t v6 = TSTBundle();
    unint64_t v7 = @"TSTiOSCheckboxUnchecked6";
  }
  uint64_t result = [v5 imageNamed:v7 inBundle:v6];
  if (a2)
  {
    double v9 = 2.0;
    if (a3 > 0.5)
    {
      double v9 = 1.0;
      if (a3 > 1.0)
      {
        double v9 = 0.666666687;
        if (a3 > 1.5) {
          double v9 = 0.5;
        }
      }
    }
    *a2 = v9;
  }
  return result;
}

CGFloat TSTTableBadgeRatingsFrame(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  return a1;
}

BOOL TSTTableBadgeIsDrawingControlCell(BOOL result)
{
  if (result)
  {
    unsigned int v1 = *(_DWORD *)(result + 104) - 263;
    return v1 <= 4 && (v1 & 0xFFFFFFFB) == 0;
  }
  return result;
}

void TSTTableBadgeDrawCellControl(uint64_t a1, CGContext *a2, uint64_t a3, unsigned int a4, double a5, CGFloat a6, CGFloat a7, CGFloat a8, CGFloat a9)
{
  if (a3)
  {
    uint64_t v17 = (void *)a1;
    int v18 = *(_DWORD *)(a3 + 104);
    if ((v18 - 263) >= 5)
    {
      double v19 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v20 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableBadgeDrawCellControl(TSTTableRep *, CGContextRef, CGFloat, CGRect, TSTCell *, TSTCellID)");
      a1 = objc_msgSend(v19, "handleFailureInFunction:file:lineNumber:description:", v20, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableBadge.m"), 247, @"Can't render controls on a cell without controls!");
      int v18 = *(_DWORD *)(a3 + 104);
    }
    int v21 = BYTE1(*(_DWORD *)(a3 + 8));
    if (v18 == 267)
    {
      uint64_t FontColorForCell = TSTTableGetFontColorForCell((uint64_t *)[v17 tableModel], a3, a4);
      double v27 = 0.0;
      if (v21 == 2)
      {
        if ((*(_DWORD *)(a3 + 8) & 0xFB00) == 0x200 || BYTE1(*(_DWORD *)(a3 + 8)) == 7)
        {
          double v27 = *(double *)(a3 + 16);
        }
        else if (BYTE1(*(_DWORD *)(a3 + 8)))
        {
          int v29 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v30 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
          objc_msgSend(v29, "handleFailureInFunction:file:lineNumber:description:", v30, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", a3);
        }
      }
      unint64_t v31 = llround(v27);
      +[TSKStarRatingViewRenderer renderRating:intoContext:rect:style:showDots:color:](TSKStarRatingViewRenderer, "renderRating:intoContext:rect:style:showDots:color:", v31, a2, 0, 1, FontColorForCell, a6, a7, a8, a9);
    }
    else if (v18 == 263)
    {
      int v22 = v21 == 6 && *(double *)(a3 + 16) != 0.0;
      id v54 = 0;
      long long v53 = *MEMORY[0x263F001B0];
      double v32 = TSTTableBadgeCheckboxFrame(a5, a6, a7, a8, a9, a1, v22, &v54, (uint64_t)&v53);
      CGFloat v34 = v33;
      CGFloat v36 = v35;
      CGFloat v38 = v37;
      memset(&v52, 0, sizeof(v52));
      CGContextGetUserSpaceToDeviceSpaceTransform(&v52, a2);
      CGAffineTransform v51 = v52;
      v56.origin.CGFloat x = v32;
      v56.origin.CGFloat y = v34;
      v56.size.CGFloat width = v36;
      v56.size.CGFloat height = v38;
      CGRect v57 = CGRectApplyAffineTransform(v56, &v51);
      CGRect v58 = CGRectIntegral(v57);
      CGFloat x = v58.origin.x;
      CGFloat y = v58.origin.y;
      CGFloat width = v58.size.width;
      CGFloat height = v58.size.height;
      CGAffineTransform v51 = v52;
      CGAffineTransformInvert(&v50, &v51);
      v59.origin.CGFloat x = x;
      v59.origin.CGFloat y = y;
      v59.size.CGFloat width = width;
      v59.size.CGFloat height = height;
      CGRect v60 = CGRectApplyAffineTransform(v59, &v50);
      CGFloat v43 = v60.origin.x;
      CGFloat v44 = v60.origin.y;
      CGFloat v45 = v60.size.width;
      CGFloat v46 = v60.size.height;
      CGContextSaveGState(a2);
      v61.origin.CGFloat x = a6;
      v61.origin.CGFloat y = a7;
      v61.size.CGFloat width = a8;
      v61.size.CGFloat height = a9;
      CGContextClipToRect(a2, v61);
      v62.origin.CGFloat x = v43;
      v62.origin.CGFloat y = v44;
      v62.size.CGFloat width = v45;
      v62.size.CGFloat height = v46;
      CGFloat MinX = CGRectGetMinX(v62);
      v63.origin.CGFloat x = v43;
      v63.origin.CGFloat y = v44;
      v63.size.CGFloat width = v45;
      v63.size.CGFloat height = v46;
      CGFloat MaxY = CGRectGetMaxY(v63);
      CGContextTranslateCTM(a2, MinX, MaxY);
      CGContextScaleCTM(a2, 1.0, -1.0);
      uint64_t v49 = (CGImage *)[v54 CGImageForSize:a2 inContext:0 orLayer:v53];
      v64.origin.CGFloat x = TSDRectWithSize();
      CGContextDrawImage(a2, v64, v49);
      CGContextRestoreGState(a2);
    }
  }
  else
  {
    unint64_t v23 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v24 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableBadgeDrawCellControl(TSTTableRep *, CGContextRef, CGFloat, CGRect, TSTCell *, TSTCellID)");
    uint64_t v25 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableBadge.m"];
    [v23 handleFailureInFunction:v24 file:v25 lineNumber:247 description:@"Can't render controls on a cell without controls!"];
  }
}

void TSTTableBadgeCellErrorIndicatorFrame(double a1, double a2, double a3, double a4)
{
  double v4 = fmin(a3, a4) * 0.899999976;
  double v5 = 2.0;
  if (v4 >= 2.0)
  {
    if (v4 >= 4.0)
    {
      double v5 = 4.0;
      if (v4 >= 8.0)
      {
        double v5 = 8.0;
        if (v4 >= 16.0)
        {
          double v5 = 16.0;
          if (v4 >= 32.0) {
            double v5 = 32.0;
          }
        }
      }
    }
    double v6 = a1 + a3 * 0.5 - v5 * 0.5;
    TSDRoundedSize();
    TSDFlooredPoint(v6);
  }
}

void TSTTableBadgeDrawCellErrorIndicator(CGContext *a1, double a2, double a3, double a4, double a5, double a6)
{
  TSTTableBadgeCellErrorIndicatorFrame(a3, a4, a5, a6);
  tCGFloat x = v13;
  double v15 = v14;
  double v16 = v12;
  double v18 = v17;
  if (a2 <= 1.0)
  {
    double v19 = v12;
    if (a2 <= 0.5) {
      double v19 = v12 * 0.5;
    }
  }
  else
  {
    double v19 = v12 + v12;
  }
  uint64_t v20 = (void *)p_TSTTableBadgeErrorIndicatorImageForSize(v19);
  CGContextSaveGState(a1);
  v24.origin.CGFloat x = a3;
  v24.origin.CGFloat y = a4;
  v24.size.CGFloat width = a5;
  v24.size.CGFloat height = a6;
  CGContextClipToRect(a1, v24);
  CGContextTranslateCTM(a1, tx, v15 + v18);
  memset(&v23, 0, sizeof(v23));
  CGContextGetCTM(&v23, a1);
  v23.tCGFloat x = ceil(v23.tx) - v23.tx;
  v23.tCGFloat y = v23.ty - ceil(v23.ty);
  CGContextTranslateCTM(a1, v23.tx, v23.ty);
  CGContextScaleCTM(a1, 1.0, -1.0);
  int v21 = (CGImage *)objc_msgSend(v20, "CGImageForSize:inContext:orLayer:", a1, 0, v16, v18);
  v25.origin.CGFloat x = TSDRectWithSize();
  CGContextDrawImage(a1, v25, v21);
  CGContextRestoreGState(a1);
}

uint64_t p_TSTTableBadgeErrorIndicatorImageForSize(double a1)
{
  if (a1 >= 4.0)
  {
    if (a1 >= 8.0)
    {
      if (a1 >= 16.0)
      {
        if (a1 >= 32.0)
        {
          uint64_t v2 = (void *)MEMORY[0x263F7C858];
          uint64_t v3 = TSTBundle();
          if (a1 >= 64.0) {
            double v4 = @"TSTErrorMessageIcon-64";
          }
          else {
            double v4 = @"TSTErrorMessageIcon-32";
          }
        }
        else
        {
          uint64_t v2 = (void *)MEMORY[0x263F7C858];
          uint64_t v3 = TSTBundle();
          double v4 = @"TSTErrorMessageIcon-16";
        }
      }
      else
      {
        uint64_t v2 = (void *)MEMORY[0x263F7C858];
        uint64_t v3 = TSTBundle();
        double v4 = @"TSTErrorMessageIcon-8";
      }
    }
    else
    {
      uint64_t v2 = (void *)MEMORY[0x263F7C858];
      uint64_t v3 = TSTBundle();
      double v4 = @"TSTErrorMessageIcon-4";
    }
  }
  else
  {
    uint64_t v2 = (void *)MEMORY[0x263F7C858];
    uint64_t v3 = TSTBundle();
    double v4 = @"TSTErrorMessageIcon-2";
  }

  return [v2 imageNamed:v4 inBundle:v3];
}

CGPath *newTSTTableBadgeCellCommentBadgePath(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  CGFloat v8 = CGRectGetMaxX(*(CGRect *)&a1) + -9.0 + -1.0;
  v12.origin.CGFloat x = a1;
  v12.origin.CGFloat y = a2;
  v12.size.CGFloat width = a3;
  v12.size.CGFloat height = a4;
  CGFloat v9 = CGRectGetMinY(v12) + 1.0;
  Mutable = CGPathCreateMutable();
  CGPathMoveToPoint(Mutable, 0, v8, v9);
  CGPathAddLineToPoint(Mutable, 0, v8 + 9.0, v9);
  CGPathAddLineToPoint(Mutable, 0, v8 + 9.0, v9 + 9.0);
  CGPathAddLineToPoint(Mutable, 0, v8, v9);
  return Mutable;
}

void TSTTableBadgeDrawCellOverflowIndicator(CGContext *a1, double a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  if (objc_msgSend(+[TSTConfiguration sharedTableConfiguration](TSTConfiguration, "sharedTableConfiguration"), "showsCellOverflowIndicator"))
  {
    double v12 = TSDCGContextAssociatedScreenScale((uint64_t)a1);
    if (a2 >= 0.75)
    {
      double v14 = v12 * 12.5;
      double v15 = v12 * 2.5;
      double v16 = v12 * 11.0;
      double v17 = v12 * 7.0;
      if (a2 < 1.0) {
        double v18 = v12 * 5.0;
      }
      else {
        double v18 = v12 * 7.0;
      }
      if (a2 < 1.0) {
        double v17 = v12 * 5.0;
      }
      double v42 = v17;
      if (a2 < 1.0) {
        double v16 = v12 * 8.0;
      }
      double v43 = v16;
      double v44 = v18;
      if (a2 < 1.0) {
        double v19 = v12 * 3.0;
      }
      else {
        double v19 = v12 * 4.0;
      }
      if (a2 < 1.0) {
        double v20 = v12 * 6.0;
      }
      else {
        double v20 = v12 * 8.0;
      }
      double v37 = v19;
      double v39 = v20;
      if (a2 < 1.0) {
        double v13 = v12 * 8.0;
      }
      else {
        double v13 = v12 * 10.0;
      }
      if (a2 < 1.0)
      {
        double v15 = v12 * 1.5;
        double v14 = v12 * 9.5;
      }
      double v33 = v14;
      double v35 = v15;
    }
    else
    {
      double v33 = v12 * 7.5;
      double v35 = v12 * 1.5;
      double v13 = v12 * 6.0;
      double v42 = v12 * 4.0;
      double v43 = v12 * 6.0;
      double v44 = v12 * 3.0;
      double v37 = v12 * 3.0;
      double v39 = v12 * 5.0;
    }
    CGFloat v41 = 1.0 / a2;
    CGContextSaveGState(a1);
    v48.origin.CGFloat x = a3;
    v48.origin.double y = a4;
    v48.size.double width = a5;
    v48.size.CGFloat height = a6;
    CGContextClipToRect(a1, v48);
    memset(&v47, 0, sizeof(v47));
    CGContextGetCTM(&v47, a1);
    v47.tCGFloat x = ceil(v47.tx) - v47.tx;
    v47.tdouble y = v47.ty - ceil(v47.ty);
    CGAffineTransform v45 = v47;
    memset(&v46, 0, sizeof(v46));
    CGAffineTransformInvert(&v46, &v45);
    CGAffineTransform v45 = v47;
    v49.origin.CGFloat x = a3;
    v49.origin.double y = a4;
    v49.size.double width = a5;
    v49.size.CGFloat height = a6;
    CGRect v50 = CGRectApplyAffineTransform(v49, &v45);
    double y = v50.origin.y;
    double width = v12 * v46.c + v46.a * v12;
    CGFloat v22 = v50.origin.x + v50.size.width;
    v50.origin.CGFloat x = v50.origin.x + v50.size.width - v33;
    v50.origin.double y = v35 + v50.origin.y;
    CGAffineTransform v45 = v46;
    v50.size.double width = v13;
    v50.size.CGFloat height = v13;
    CGRect v51 = CGRectApplyAffineTransform(v50, &v45);
    CGFloat x = v51.origin.x;
    CGFloat v24 = v51.origin.y;
    CGFloat v25 = v51.size.width;
    CGFloat height = v51.size.height;
    v51.origin.CGFloat x = v22 - v39;
    v51.origin.double y = v37 + y;
    CGAffineTransform v45 = v46;
    v51.size.double width = v12;
    v51.size.CGFloat height = v44;
    CGRect v52 = CGRectApplyAffineTransform(v51, &v45);
    CGFloat v38 = v52.origin.y;
    CGFloat v40 = v52.origin.x;
    CGFloat v34 = v52.size.height;
    CGFloat v36 = v52.size.width;
    v52.origin.CGFloat x = v22 - v43;
    v52.origin.double y = v42 + y;
    CGAffineTransform v45 = v46;
    v52.size.double width = v44;
    v52.size.CGFloat height = v12;
    CGRect v53 = CGRectApplyAffineTransform(v52, &v45);
    CGFloat v27 = v53.origin.x;
    CGFloat v28 = v53.origin.y;
    CGFloat v29 = v53.size.width;
    CGFloat v30 = v53.size.height;
    CGContextSetLineWidth(a1, width);
    unint64_t v31 = TSDCreateRoundRectPathForRectWithRadius(x, v24, v25, height, v41);
    CGContextSaveGState(a1);
    CGContextSetStrokeColorWithColor(a1, (CGColorRef)objc_msgSend((id)objc_msgSend(MEMORY[0x263F7C808], "blackColor"), "CGColor"));
    CGContextSetFillColorWithColor(a1, (CGColorRef)objc_msgSend((id)objc_msgSend(MEMORY[0x263F7C808], "whiteColor"), "CGColor"));
    CGContextAddPath(a1, v31);
    CGContextDrawPath(a1, kCGPathFillStroke);
    CGContextRestoreGState(a1);
    CGContextSaveGState(a1);
    CGContextSetFillColorWithColor(a1, (CGColorRef)objc_msgSend((id)objc_msgSend(MEMORY[0x263F7C808], "blackColor"), "CGColor"));
    v54.origin.double y = v38;
    v54.origin.CGFloat x = v40;
    v54.size.CGFloat height = v34;
    v54.size.double width = v36;
    CGContextFillRect(a1, v54);
    v55.origin.CGFloat x = v27;
    v55.origin.double y = v28;
    v55.size.double width = v29;
    v55.size.CGFloat height = v30;
    CGContextFillRect(a1, v55);
    CGContextRestoreGState(a1);
    CGPathRelease(v31);
    CGContextRestoreGState(a1);
  }
}

double TSTTableBadgeCellWarningIndicatorFrame()
{
  return *MEMORY[0x263F001A8];
}

double TSTTableBadgeCheckboxSizeForScale(int a1, double a2, double a3)
{
  double v9 = 0.0;
  double v4 = (CGImage *)objc_msgSend((id)p_TSTTableBadgeCheckboxImageForScale(a1, &v9, a2), "CGImage");
  if (!v4) {
    return *MEMORY[0x263F001B0];
  }
  double v5 = v4;
  size_t Width = CGImageGetWidth(v4);
  double v7 = v9 / a3 * (double)Width;
  CGImageGetHeight(v5);
  return v7;
}

void TSTTableBadgeDrawHorizontalShadow(CGContext *a1, int a2, CGFloat a3, double a4, CGFloat a5, double a6, CGFloat a7)
{
  double v14 = TSDCGContextAssociatedScreenScale((uint64_t)a1);
  if (a2 == 2) {
    double v15 = a7;
  }
  else {
    double v15 = -0.0;
  }
  if (v14 == 1.0) {
    double v16 = (double *)&TSTTableBadgeShadowAlphaValues1x;
  }
  else {
    double v16 = (double *)&TSTTableBadgeShadowAlphaValues2x;
  }
  double v17 = a4 + a7 * 0.5;
  double v18 = a6 + a7 * 0.5;
  if (v14 == 1.0) {
    uint64_t v19 = 5;
  }
  else {
    uint64_t v19 = 10;
  }
  do
  {
    a5 = v15 + a5;
    CGContextSaveGState(a1);
    CGContextBeginPath(a1);
    CGContextMoveToPoint(a1, a3, v17);
    CGContextAddLineToPoint(a1, a5, v18);
    CGContextSetLineWidth(a1, a7);
    double v20 = (void *)[MEMORY[0x263F7C808] blackColor];
    double v21 = *v16++;
    CGContextSetStrokeColorWithColor(a1, (CGColorRef)objc_msgSend((id)objc_msgSend(v20, "colorWithAlphaComponent:", v21), "CGColor"));
    CGContextStrokePath(a1);
    CGContextRestoreGState(a1);
    double v17 = v17 + a7;
    double v18 = v18 + a7;
    --v19;
  }
  while (v19);
}

void TSTTableBadgeDrawVerticalShadow(CGContext *a1, int a2, double a3, CGFloat a4, double a5, CGFloat a6, CGFloat a7)
{
  double v14 = TSDCGContextAssociatedScreenScale((uint64_t)a1);
  if (a2 == 2) {
    double v15 = a7;
  }
  else {
    double v15 = -0.0;
  }
  if (v14 == 1.0) {
    double v16 = (double *)&TSTTableBadgeShadowAlphaValues1x;
  }
  else {
    double v16 = (double *)&TSTTableBadgeShadowAlphaValues2x;
  }
  double v17 = a3 + a7 * 0.5;
  double v18 = a5 + a7 * 0.5;
  if (v14 == 1.0) {
    uint64_t v19 = 5;
  }
  else {
    uint64_t v19 = 10;
  }
  do
  {
    CGContextSaveGState(a1);
    CGContextBeginPath(a1);
    CGContextMoveToPoint(a1, v17, a4);
    CGContextAddLineToPoint(a1, v18, a6);
    CGContextSetLineWidth(a1, a7);
    double v20 = (void *)[MEMORY[0x263F7C808] blackColor];
    double v21 = *v16++;
    CGContextSetStrokeColorWithColor(a1, (CGColorRef)objc_msgSend((id)objc_msgSend(v20, "colorWithAlphaComponent:", v21), "CGColor"));
    CGContextStrokePath(a1);
    CGContextRestoreGState(a1);
    double v17 = v17 + a7;
    double v18 = v18 + a7;
    a6 = v15 + a6;
    --v19;
  }
  while (v19);
}

uint64_t TSTTableBadgeContentsCenterInfoInit(uint64_t result, double a2, double a3, double a4, double a5, double a6, double a7)
{
  double v13 = (double *)result;
  if (!result)
  {
    double v14 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v15 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableBadgeContentsCenterInfoInit(TSTTableBadgeContentsCenterInfo *, CGFloat, CGFloat, CGFloat, CGFloat, CGFloat, CGFloat)");
    uint64_t result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", v15, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableBadge.m"), 738, @"invalid nil value for '%s'", "info");
  }
  v13[1] = a2;
  v13[2] = a3;
  v13[3] = a4;
  v13[4] = a5;
  v13[5] = a6;
  v13[6] = a7;
  return result;
}

uint64_t TSTTableDataStoreHeaderInfoForRow(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return [*(id *)(a1 + 40) headerForKey:a2 willModify:a3 createIfNotThere:a4];
}

uint64_t TSTTableDataStoreHeaderInfoForColumn(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  double v7 = (void *)[*(id *)(a1 + 48) object];

  return [v7 headerForKey:a2 willModify:a3 createIfNotThere:a4];
}

uint64_t privateRemoveIndexedItemsFromStorage(uint64_t result, uint64_t a2, int a3)
{
  if (a3)
  {
    uint64_t v3 = a2;
    double v4 = (void *)result;
    unsigned int v5 = a3 + a2;
    do
    {
      uint64_t result = [v4 removeHeaderForKey:v3];
      uint64_t v3 = (v3 + 1);
    }
    while (v3 < v5);
  }
  return result;
}

uint64_t TSTTableDataStoreRemoveRowHeadersAtIndex(uint64_t result, uint64_t a2, int a3)
{
  if (a3)
  {
    uint64_t v3 = a2;
    double v4 = *(void **)(result + 40);
    unsigned int v5 = a3 + a2;
    do
    {
      uint64_t result = [v4 removeHeaderForKey:v3];
      uint64_t v3 = (v3 + 1);
    }
    while (v3 < v5);
  }
  return result;
}

uint64_t TSTTableDataStoreShiftRowHeaderIndexes(TSTTableDataStore *a1, uint64_t a2, uint64_t a3)
{
  return [(TSTTableHeaderStorage *)a1->mRowHeaderStorage shiftKeysAtIndex:a2 amount:a3];
}

uint64_t TSTTableDataStoreShiftColumnHeaderIndexes(TSTTableDataStore *a1, uint64_t a2, uint64_t a3)
{
  id v5 = [(TSPLazyReference *)a1->mColumnHeaderStorageReference object];

  return [v5 shiftKeysAtIndex:a2 amount:a3];
}

uint64_t TSTTableDataStoreRemoveColumnHeadersAtIndex(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result = [*(id *)(a1 + 48) object];
  if (a3)
  {
    double v6 = (void *)result;
    unsigned int v7 = a3 + a2;
    do
    {
      uint64_t result = [v6 removeHeaderForKey:a2];
      a2 = (a2 + 1);
    }
    while (a2 < v7);
  }
  return result;
}

uint64_t TSTDataStoreDecrementColumnCellCount(uint64_t result, TSTTableHeaderInfo *a2)
{
  uint64_t v3 = result;
  unsigned __int16 mNumberOfCells = a2->mNumberOfCells;
  if (!mNumberOfCells)
  {
    id v5 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v6 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTDataStoreDecrementColumnCellCount(TSTTableDataStore *, TSTTableHeaderInfo *)");
    uint64_t result = objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 120, @"Can't drive column cell count below zero!");
    unsigned __int16 mNumberOfCells = a2->mNumberOfCells;
  }
  a2->unsigned __int16 mNumberOfCells = mNumberOfCells - 1;
  if (*(unsigned char *)(v3 + 156))
  {
    int v7 = *(_DWORD *)(v3 + 152);
    if (!v7)
    {
      CGFloat v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTDataStoreDecrementColumnCellCount(TSTTableDataStore *, TSTTableHeaderInfo *)");
      uint64_t result = objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 124, @"Can't drive cell count below zero!");
      int v7 = *(_DWORD *)(v3 + 152);
    }
    *(_DWORD *)(v3 + 152) = v7 - 1;
  }
  return result;
}

uint64_t TSTDataStoreIncrementColumnCellCount(uint64_t result, TSTTableHeaderInfo *a2)
{
  if (*(unsigned char *)(result + 156)) {
    ++*(_DWORD *)(result + 152);
  }
  ++a2->mNumberOfCells;
  return result;
}

void TSTDataStoreDecrementRowCellCount(TSTTableDataStore *a1, TSTTableHeaderInfo *a2)
{
  unsigned __int16 mNumberOfCells = a2->mNumberOfCells;
  if (!mNumberOfCells)
  {
    double v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTDataStoreDecrementRowCellCount(TSTTableDataStore *, TSTTableHeaderInfo *)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 140, @"Can't drive row cell count below zero!");
    unsigned __int16 mNumberOfCells = a2->mNumberOfCells;
  }
  a2->unsigned __int16 mNumberOfCells = mNumberOfCells - 1;
}

void TSTDataStoreIncrementRowCellCount(TSTTableDataStore *a1, TSTTableHeaderInfo *a2)
{
}

uint64_t TSTTableDataStoreDecrementCellCounts(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (TSTTableDataStore *)[*(id *)(a1 + 40) headerForKey:a3 willModify:1 createIfNotThere:1];
  int v7 = (TSTTableHeaderInfo *)v6;
  if (!v6)
  {
    CGFloat v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "TSUError TSTTableDataStoreDecrementCellCounts(TSTTableDataStore *, TSUColumnIndex, TSURowIndex)");
    uint64_t v6 = (TSTTableDataStore *)objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 154, @"invalid nil value for '%s'", "rowInfo");
  }
  TSTDataStoreDecrementRowCellCount(v6, v7);
  if (v7->mSize == 0.0 && !v7->mNumberOfCells && !v7->mCellStyle && !v7->mTextStyle && !v7->mHidingState) {
    [*(id *)(a1 + 40) removeHeaderForKey:a3];
  }
  unint64_t v10 = (TSTTableHeaderInfo *)objc_msgSend((id)objc_msgSend(*(id *)(a1 + 48), "object"), "headerForKey:willModify:createIfNotThere:", a2, 1, 1);
  TSTDataStoreDecrementColumnCellCount(a1, v10);
  if (v10->mSize == 0.0 && !v10->mNumberOfCells && !v10->mCellStyle && !v10->mTextStyle && !v10->mHidingState) {
    objc_msgSend((id)objc_msgSend(*(id *)(a1 + 48), "object"), "removeHeaderForKey:", a2);
  }
  return 0;
}

uint64_t TSTTableDataStoreIncrementCellCounts(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = [*(id *)(a1 + 40) headerForKey:a3 willModify:1 createIfNotThere:1];
  if (!v5)
  {
    uint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "TSUError TSTTableDataStoreIncrementCellCounts(TSTTableDataStore *, TSUColumnIndex, TSURowIndex)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 173, @"invalid nil value for '%s'", "rowInfo");
  }
  ++*(_WORD *)(v5 + 34);
  uint64_t v8 = objc_msgSend((id)objc_msgSend(*(id *)(a1 + 48), "object"), "headerForKey:willModify:createIfNotThere:", a2, 1, 1);
  if (*(unsigned char *)(a1 + 156)) {
    ++*(_DWORD *)(a1 + 152);
  }
  ++*(_WORD *)(v8 + 34);
  return 0;
}

uint64_t TSTTableDataStoreNumberOfPopulatedCells(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 156))
  {
    int v3 = 0;
    objc_msgSend((id)objc_msgSend(*(id *)(a1 + 48), "object"), "applyFunction:withState:willModify:", p_countCellsInColumn, &v3, 0);
    *(_DWORD *)(a1 + 152) = v3;
    *(unsigned char *)(a1 + 156) = 1;
  }
  return *(unsigned int *)(a1 + 152);
}

void p_countCellsInColumn(unsigned int a1, objc_object *a2, _DWORD *a3)
{
  *a3 += WORD1(a2[4].isa);
}

uint64_t TSTTableDataStoreNumberOfFormulas(uint64_t a1)
{
  return TSTTableDataListGetCount([*(id *)(a1 + 80) object]);
}

uint64_t p_findEmptyTiles(uint64_t result, unsigned int a2, void *a3)
{
  if (result)
  {
    unsigned int v4 = result;
    uint64_t result = objc_msgSend((id)objc_msgSend(*(id *)(*a3 + 32), "tileForID:", a2), "numRows");
    if (!result)
    {
      uint64_t v5 = (void *)a3[1];
      return [v5 addIndex:v4];
    }
  }
  return result;
}

id TSTDataStoreGetTileForRow(TSTTableDataStore *a1, unsigned int a2, unsigned __int16 *a3)
{
  uint64_t v4 = TSTTableRBTreeStripIDForCellIndex(&a1->mRowTileIndex->var0, a2, a3);
  mTileStorage = a1->mTileStorage;

  return [(TSTTileIDKeyDict *)mTileStorage tileForID:v4];
}

uint64_t p_TileForRowIndex(uint64_t a1, unsigned int a2, unsigned __int16 *a3, unsigned int *a4)
{
  unsigned int v6 = TSTTableRBTreeStripIDForCellIndex(*(unsigned __int16 **)(a1 + 24), a2, a3);
  uint64_t result = [*(id *)(a1 + 32) tileForID:v6];
  if (a4)
  {
    if (result) {
      *a4 = v6;
    }
  }
  return result;
}

id TSTDataStoreGetTileAtOrAfterRow(TSTTableDataStore *a1, unsigned int a2, unsigned __int16 *a3)
{
  unsigned int v6 = TSTTableRBFirstNodeGreaterThanOrEqualTo(&a1->mRowTileIndex->var0, a2);
  if (a2 && v6 == (unsigned __int16 *)&TSTTableRBTreeNil) {
    return 0;
  }
  if (a3) {
    *a3 = *v6;
  }
  uint64_t v8 = v6[1];
  mTileStorage = a1->mTileStorage;

  return [(TSTTileIDKeyDict *)mTileStorage tileForID:v8];
}

TSTTableTile *TSTDataStoreGetRowInfoForRow(TSTTableDataStore *a1, unsigned int a2)
{
  __int16 v2 = a2;
  unsigned __int16 v4 = -1;
  uint64_t result = [(TSTTileIDKeyDict *)a1->mTileStorage tileForID:TSTTableRBTreeStripIDForCellIndex(&a1->mRowTileIndex->var0, a2, &v4)];
  if (result) {
    return (TSTTableTile *)TSTTableTileRowInfoForTileRowIndex(result, (unsigned __int16)(v2 - v4), 0);
  }
  return result;
}

uint64_t TSTTableDataStoreIterateTiles(TSTTableDataStore *a1, TSTTableRBTreeNode_s *a2, void *a3, void (*a4)(TSTTableTile *, void *))
{
  do
  {
    unint64_t var2 = a2->var2;
    if (var2 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil) {
      TSTTableDataStoreIterateTiles(a1, var2, a3, a4);
    }
    id v9 = [(TSTTileIDKeyDict *)a1->mTileStorage tileForID:a2->var1];
    if (!v9)
    {
      unint64_t v10 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v11 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableDataStoreIterateTiles(TSTTableDataStore *, TSTTableRBTreeNode *, void *, void (*)(TSTTableTile *, void *))");
      objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 411, @"failure while iterating over tiles: error retrieving tile");
    }
    uint64_t result = ((uint64_t (*)(id, void *))a4)(v9, a3);
    a2 = a2->var3;
  }
  while (a2 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil);
  return result;
}

UInt8 *TSTTableDataStoreCellStorageRefAtCellID(uint64_t a1, int a2)
{
  unsigned __int16 v7 = 0;
  int v3 = (TSTTableTile *)objc_msgSend(*(id *)(a1 + 32), "tileForID:", TSTTableRBTreeStripIDForCellIndex(*(unsigned __int16 **)(a1 + 24), (unsigned __int16)a2, &v7));
  if (!v3)
  {
    unsigned __int16 v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTCellStorageRef TSTTableDataStoreCellStorageRefAtCellID(TSTTableDataStore *, TSTCellID)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 431, @"Failed to get tile for cell!");
  }
  return TSTTableTileGetCellStorageRef(v3, BYTE2(a2), (unsigned __int16)(a2 - v7));
}

BOOL TSTTableDataStoreCellExistsAtCellID(uint64_t a1, int a2)
{
  return TSTTableDataStoreCellStorageRefAtCellID(a1, a2) != 0;
}

uint64_t TSTTableDataStoreGetCellStyleAtCellID(uint64_t a1, int a2, uint64_t *a3)
{
  if (a3) {
    *a3 = 0;
  }
  uint64_t v5 = TSTTableDataStoreCellStorageRefAtCellID(a1, a2);
  if (!v5) {
    return 1000;
  }
  if ((v5[4] & 2) == 0) {
    return 0;
  }
  Element = (unsigned int *)TSTCellStorageGetElement((uint64_t)v5, 2);
  if (!Element)
  {
    uint64_t v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v9 = [NSString stringWithUTF8String:"TSTTableDataListKey TSTCellStorageStyleID(TSTCellStorage *)"];
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 182, @"Can't get style ID storage element!");
  }
  uint64_t result = 0;
  if (a3)
  {
    uint64_t v10 = *Element;
    if (v10)
    {
      StyleForKedouble y = TSTTableDataListGetStyleForKey([*(id *)(a1 + 72) object], v10);
      uint64_t result = 0;
      *a3 = StyleForKey;
    }
  }
  return result;
}

uint64_t TSTTableDataStoreGetTextStyleAtCellID(uint64_t a1, int a2, TSWPParagraphStyle **a3)
{
  if (a3) {
    *a3 = 0;
  }
  uint64_t v5 = TSTTableDataStoreCellStorageRefAtCellID(a1, a2);
  if (!v5) {
    return 1000;
  }
  unsigned int v6 = [[TSTCell alloc] initWithStorageRef:v5 dataStore:a1];
  if (a3)
  {
    if (v6) {
      mTextStyle = v6->mPrivate.mTextStyle;
    }
    else {
      mTextStyle = 0;
    }
    *a3 = mTextStyle;
  }

  return 0;
}

double TSTTableDataStoreGetFormatForFormatTypeAtCellID@<D0>(uint64_t a1@<X0>, int a2@<W1>, int a3@<W2>, UInt8 *a4@<X3>, uint64_t a5@<X8>)
{
  if (!a4)
  {
    a4 = TSTTableDataStoreCellStorageRefAtCellID(a1, a2);
    if (!a4) {
      goto LABEL_22;
    }
  }
  uint64_t v8 = 0;
  switch(a3)
  {
    case 254:
    case 260:
    case 263:
    case 267:
      goto LABEL_22;
    case 255:
      goto LABEL_15;
    case 256:
    case 258:
    case 259:
    case 262:
      uint64_t v8 = 1;
      break;
    case 257:
      uint64_t v8 = 8;
      break;
    case 261:
      uint64_t v8 = 2;
      break;
    case 264:
    case 265:
      uint64_t v8 = 16;
      break;
    case 266:
      uint64_t v8 = 128;
      break;
    case 268:
      uint64_t v8 = 4;
      break;
    case 269:
      uint64_t v8 = 64;
      break;
    case 270:
    case 271:
    case 272:
      uint64_t v8 = 32;
      break;
    default:
      if ((a3 + 1) < 3 || a3 == -999) {
        goto LABEL_22;
      }
      break;
  }
  if (((unsigned __int16)v8 & *((_WORD *)a4 + 5)) == 0) {
    goto LABEL_22;
  }
LABEL_15:
  ElementForFormat = (unsigned int *)TSTCellStorageGetElementForFormat((uint64_t)a4, v8);
  if (!ElementForFormat)
  {
    uint64_t v10 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v11 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTTableDataListKey TSTCellStorageFormatIDForFormatFlag(TSTCellStorage *, TSTCellStorageFormatFlags)");
    objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 269, @"Can't get format ID storage element!");
  }
  uint64_t v12 = *ElementForFormat;
  if (v12)
  {
    uint64_t v13 = [*(id *)(a1 + 104) object];
    *(void *)&double result = TSTTableDataListGetCellFormatForKey(v13, v12, a5).n128_u64[0];
  }
  else
  {
LABEL_22:
    *(void *)(a5 + 32) = 0;
    double result = *(double *)&TSUNotSetFormat;
    *(_OWORD *)a5 = TSUNotSetFormat;
    *(_OWORD *)(a5 + 16) = unk_22383BDF8;
  }
  return result;
}

double TSTTableDataStoreGetFormatAtCellID@<D0>(uint64_t a1@<X0>, int a2@<W1>, BOOL *a3@<X2>, UInt8 *a4@<X3>, uint64_t a5@<X8>)
{
  if (!a4)
  {
    a4 = TSTTableDataStoreCellStorageRefAtCellID(a1, a2);
    if (!a4) {
      goto LABEL_12;
    }
  }
  if (a3) {
    *a3 = (~*(void *)(a4 + 4) & 0x1000000004) != 0;
  }
  if ((a4[4] & 4) == 0) {
    goto LABEL_12;
  }
  Element = (unsigned int *)TSTCellStorageGetElement((uint64_t)a4, 4);
  if (!Element)
  {
    uint64_t v9 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v10 = [NSString stringWithUTF8String:"TSTTableDataListKey TSTCellStorageFormatID(TSTCellStorage *)"];
    objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 249, @"Can't get format ID storage element!");
  }
  uint64_t v11 = *Element;
  if (v11)
  {
    uint64_t v12 = [*(id *)(a1 + 104) object];
    *(void *)&double result = TSTTableDataListGetCellFormatForKey(v12, v11, a5).n128_u64[0];
  }
  else
  {
LABEL_12:
    *(void *)(a5 + 32) = 0;
    double result = *(double *)&TSUNotSetFormat;
    *(_OWORD *)a5 = TSUNotSetFormat;
    *(_OWORD *)(a5 + 16) = unk_22383BDF8;
  }
  return result;
}

__n128 p_TSTCellFormatForFormatFlag@<Q0>(void *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  if (a2 > 15)
  {
    if (a2 > 63)
    {
      if (a2 == 64)
      {
        if (a1)
        {
          unsigned __int16 v4 = (void *)a1[31];
          if (v4) {
            goto LABEL_10;
          }
        }
      }
      else if (a2 == 128)
      {
        if (a1)
        {
          unsigned __int16 v4 = (void *)a1[33];
          if (v4) {
            goto LABEL_10;
          }
        }
      }
    }
    else if (a2 == 16)
    {
      if (a1)
      {
        unsigned __int16 v4 = (void *)a1[27];
        if (v4) {
          goto LABEL_10;
        }
      }
    }
    else if (a2 == 32)
    {
      if (a1)
      {
        unsigned __int16 v4 = (void *)a1[29];
        if (v4)
        {
LABEL_10:
          [v4 getFormatStruct];
          return result;
        }
      }
    }
LABEL_34:
    *(void *)(a3 + 32) = 0;
    result.n128_u64[0] = TSUInvalidFormat;
    *(_OWORD *)a3 = TSUInvalidFormat;
    *(_OWORD *)(a3 + 16) = unk_22383BE20;
    return result;
  }
  switch(a2)
  {
    case 0:
      if (a1) {
        int v3 = (long long *)(a1 + 13);
      }
      else {
        int v3 = &TSUInvalidFormat;
      }
      __n128 result = (__n128)*v3;
      long long v6 = v3[1];
      *(_OWORD *)a3 = *v3;
      *(_OWORD *)(a3 + 16) = v6;
      *(void *)(a3 + 32) = *((void *)v3 + 4);
      break;
    case 1:
      if (!a1) {
        goto LABEL_34;
      }
      unsigned __int16 v4 = (void *)a1[19];
      if (!v4) {
        goto LABEL_34;
      }
      goto LABEL_10;
    case 2:
      if (a1)
      {
        unsigned __int16 v4 = (void *)a1[25];
        if (v4) {
          goto LABEL_10;
        }
      }
      goto LABEL_34;
    case 4:
      if (a1)
      {
        unsigned __int16 v4 = (void *)a1[23];
        if (v4) {
          goto LABEL_10;
        }
      }
      goto LABEL_34;
    case 8:
      if (a1)
      {
        unsigned __int16 v4 = (void *)a1[21];
        if (v4) {
          goto LABEL_10;
        }
      }
      goto LABEL_34;
    default:
      goto LABEL_34;
  }
  return result;
}

uint64_t p_TSTCellFormatIDForFormatFlag(unsigned int *a1, int a2)
{
  uint64_t result = 0;
  if (a2 > 15)
  {
    if (a2 > 63)
    {
      if (a2 == 64)
      {
        if (a1) {
          return a1[60];
        }
      }
      else
      {
        if (a2 != 128) {
          return result;
        }
        if (a1) {
          return a1[64];
        }
      }
    }
    else if (a2 == 16)
    {
      if (a1) {
        return a1[52];
      }
    }
    else
    {
      if (a2 != 32) {
        return result;
      }
      if (a1) {
        return a1[56];
      }
    }
    return 0;
  }
  switch(a2)
  {
    case 0:
      if (!a1) {
        return 0;
      }
      uint64_t result = a1[25];
      break;
    case 1:
      if (!a1) {
        return 0;
      }
      uint64_t result = a1[36];
      break;
    case 2:
      if (!a1) {
        return 0;
      }
      uint64_t result = a1[48];
      break;
    case 4:
      if (!a1) {
        return 0;
      }
      uint64_t result = a1[44];
      break;
    case 8:
      if (!a1) {
        return 0;
      }
      uint64_t result = a1[40];
      break;
    default:
      return result;
  }
  return result;
}

uint64_t p_UpdateDataListsForNewCell(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v5 = (id *)result;
  if (!a3)
  {
    uint64_t v11 = 0;
    uint64_t v7 = 0;
    goto LABEL_13;
  }
  uint64_t v6 = *(void *)(a3 + 4);
  if ((v6 & 0x10) != 0)
  {
    uint64_t result = TSTCellStorageGetElement(a3, 16);
    uint64_t v12 = (unsigned int *)result;
    if (!result)
    {
      uint64_t v13 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v14 = [NSString stringWithUTF8String:"TSTTableDataListKey TSTCellStorageStringID(TSTCellStorage *)"];
      uint64_t result = objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 401, @"Can't get string ID storage element!");
    }
    uint64_t v7 = *v12;
    uint64_t v6 = *(void *)(v3 + 4);
    if ((v6 & 0x200) != 0)
    {
LABEL_4:
      uint64_t result = TSTCellStorageGetElement(v3, 512);
      uint64_t v8 = (unsigned int *)result;
      if (!result)
      {
        uint64_t v9 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v10 = [NSString stringWithUTF8String:"TSTTableDataListKey TSTCellStorageRichTextPayloadID(TSTCellStorage *)"];
        uint64_t result = objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 357, @"Can't get formula error ID storage element!");
      }
      uint64_t v11 = *v8;
      if ((*(void *)(v3 + 4) & 0x1000) != 0) {
        goto LABEL_14;
      }
LABEL_13:
      uint64_t v15 = 0;
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v7 = 0;
    if ((v6 & 0x200) != 0) {
      goto LABEL_4;
    }
  }
  uint64_t v11 = 0;
  if ((v6 & 0x1000) == 0) {
    goto LABEL_13;
  }
LABEL_14:
  uint64_t result = TSTCellStorageGetElement(v3, 4096);
  double v16 = (unsigned int *)result;
  if (!result)
  {
    double v17 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v18 = v11;
    uint64_t v19 = [NSString stringWithUTF8String:"TSTTableDataListKey TSTCellStorageCommentStorageID(TSTCellStorage *)"];
    uint64_t v20 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"];
    uint64_t v21 = v19;
    uint64_t v11 = v18;
    uint64_t result = [v17 handleFailureInFunction:v21 file:v20 lineNumber:382 description:@"Can't get cell comment ID storage element!"];
  }
  uint64_t v15 = *v16;
LABEL_17:
  unsigned int v90 = v11;
  if (!a2 || (int v22 = *(_DWORD *)(a2 + 8), (v22 & 0xFF00) != 0x300))
  {
    if (v7) {
      uint64_t result = TSTTableDataListRemoveReferenceForKey([v5[8] object], v7);
    }
    if (!a2) {
      goto LABEL_84;
    }
    goto LABEL_62;
  }
  uint64_t v23 = *(unsigned int *)(a2 + 16);
  int v24 = BYTE1(v22);
  if (!v24)
  {
    BOOL v26 = v7 != v23;
    BOOL v27 = v7 != v23 && v7 != 0;
    CGFloat v25 = &stru_26D688A48;
    if (v23)
    {
LABEL_38:
      StringForKedouble y = TSTTableDataListGetStringForKey([v5[8] object], v23);
      if (StringForKey)
      {
        uint64_t result = [(__CFString *)v25 isEqualToString:StringForKey];
        if ((result & 1) == 0)
        {
          double v89 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v88 = objc_msgSend(NSString, "stringWithUTF8String:", "void p_UpdateDataListsForNewCell(TSTTableDataStore *, TSTCell *, TSTCellStorageRef, TSTCellID, CFUUIDRef, TSCECalculationEngine *)");
          uint64_t result = objc_msgSend(v89, "handleFailureInFunction:file:lineNumber:description:", v88, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 920, @"Corrupted string keys!");
        }
        if (v26)
        {
          uint64_t result = TSTTableDataListAddReferenceForKey((id *)[v5[8] object], v23);
          goto LABEL_60;
        }
        goto LABEL_51;
      }
      goto LABEL_56;
    }
    goto LABEL_56;
  }
  if (v24 != 9)
  {
    if (v24 == 3)
    {
      CGFloat v25 = *(__CFString **)(a2 + 24);
      goto LABEL_33;
    }
    CGFloat v29 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v30 = [NSString stringWithUTF8String:"NSString *TSTCellStringValue(TSTCell *)"];
    objc_msgSend(v29, "handleFailureInFunction:file:lineNumber:description:", v30, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, @"can't get string from non-string cell: %p", a2);
    if (v7) {
      BOOL v31 = v7 == v23;
    }
    else {
      BOOL v31 = 1;
    }
    BOOL v27 = !v31;
    if (v23) {
      goto LABEL_50;
    }
    CGFloat v25 = 0;
LABEL_56:
    uint64_t result = TSTTableDataListAddString((TSTTableDataList *)[v5[8] object], (uint64_t)v25);
    if (*(unsigned __int8 *)(a2 + 9) << 8 == 768)
    {
      *(_DWORD *)(a2 + 16) = result;
      goto LABEL_60;
    }
    uint64_t v39 = [MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v40 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellSetStringID(TSTCell *, TSTTableDataListKey)");
    uint64_t v34 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"];
    double v35 = @"can't set string ID on non-string cell: %p";
    uint64_t v87 = a2;
    CGFloat v36 = (void *)v39;
    uint64_t v37 = v40;
    uint64_t v38 = 958;
LABEL_59:
    uint64_t result = objc_msgSend(v36, "handleFailureInFunction:file:lineNumber:description:", v37, v34, v38, v35, v87);
LABEL_60:
    uint64_t v11 = v90;
    if (!v27) {
      goto LABEL_62;
    }
    goto LABEL_61;
  }
  CGFloat v25 = (__CFString *)[*(id *)(a2 + 72) string];
LABEL_33:
  BOOL v26 = v7 != v23;
  BOOL v27 = v7 != v23 && v7 != 0;
  if (!v23) {
    goto LABEL_56;
  }
  if (v25) {
    goto LABEL_38;
  }
LABEL_50:
  uint64_t result = TSTTableDataListGetStringForKey([v5[8] object], v23);
  if (!result)
  {
    uint64_t v32 = [MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v33 = objc_msgSend(NSString, "stringWithUTF8String:", "void p_UpdateDataListsForNewCell(TSTTableDataStore *, TSTCell *, TSTCellStorageRef, TSTCellID, CFUUIDRef, TSCECalculationEngine *)");
    uint64_t v34 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"];
    double v35 = @"Handed a bad string key!";
    CGFloat v36 = (void *)v32;
    uint64_t v37 = v33;
    uint64_t v38 = 930;
    goto LABEL_59;
  }
LABEL_51:
  uint64_t v11 = v90;
  if (v27) {
LABEL_61:
  }
    uint64_t result = TSTTableDataListRemoveReferenceForKey([v5[8] object], v7);
LABEL_62:
  CGFloat v41 = *(void **)(a2 + 72);
  uint64_t v42 = *(unsigned int *)(a2 + 64);
  if (!v41)
  {
    if (v42)
    {
      if (v11) {
        BOOL v47 = v11 == v42;
      }
      else {
        BOOL v47 = 1;
      }
      int v48 = !v47;
      uint64_t result = TSTTableDataListGetRichTextPayloadForKey([v5[12] object], v42);
      if (result)
      {
        if (v48) {
          goto LABEL_89;
        }
      }
      else
      {
        unint64_t v85 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v86 = objc_msgSend(NSString, "stringWithUTF8String:", "void p_UpdateDataListsForNewCell(TSTTableDataStore *, TSTCell *, TSTCellStorageRef, TSTCellID, CFUUIDRef, TSCECalculationEngine *)");
        uint64_t result = objc_msgSend(v85, "handleFailureInFunction:file:lineNumber:description:", v86, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 1075, @"Handed a bad text storage key!");
        if (v48) {
          goto LABEL_89;
        }
      }
      goto LABEL_90;
    }
LABEL_84:
    if (v11) {
      uint64_t result = TSTTableDataListRemoveReferenceForKey([v5[12] object], v11);
    }
    if (!a2) {
      goto LABEL_112;
    }
    goto LABEL_90;
  }
  if (v11) {
    BOOL v43 = v11 == v42;
  }
  else {
    BOOL v43 = 1;
  }
  char v44 = !v43;
  CGAffineTransform v45 = (TSTTableDataList *)[v5[12] object];
  if (!v42
    || (RichTextPayloadForKedouble y = TSTTableDataListGetRichTextPayloadForKey((uint64_t)v45, v42),
        CGAffineTransform v45 = (TSTTableDataList *)[v5[12] object],
        !RichTextPayloadForKey))
  {
    uint64_t result = TSTTableDataListAddRichTextPayload(v45, (uint64_t)v41);
    *(_DWORD *)(a2 + 64) = result;
    if ((v44 & 1) == 0) {
      goto LABEL_90;
    }
    goto LABEL_89;
  }
  if (v90 != v42)
  {
    uint64_t result = TSTTableDataListAddReferenceForKey((id *)&v45->super.super.isa, v42);
    if ((v44 & 1) == 0) {
      goto LABEL_90;
    }
LABEL_89:
    uint64_t result = TSTTableDataListRemoveReferenceForKey([v5[12] object], v90);
    goto LABEL_90;
  }
  uint64_t result = objc_msgSend(v41, "isEqual:", TSTTableDataListGetRichTextPayloadForKey((uint64_t)v45, v90));
  if ((result & 1) == 0)
  {
    int v70 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v71 = objc_msgSend(NSString, "stringWithUTF8String:", "void p_UpdateDataListsForNewCell(TSTTableDataStore *, TSTCell *, TSTCellStorageRef, TSTCellID, CFUUIDRef, TSCECalculationEngine *)");
    uint64_t result = objc_msgSend(v70, "handleFailureInFunction:file:lineNumber:description:", v71, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 1070, @"Corrupted rich text storage table!");
  }
LABEL_90:
  CGRect v49 = *(void **)(a2 + 88);
  uint64_t v50 = *(unsigned int *)(a2 + 80);
  if (!v49)
  {
    if (v50)
    {
      if (v15) {
        BOOL v55 = v15 == v50;
      }
      else {
        BOOL v55 = 1;
      }
      int v56 = !v55;
      uint64_t result = TSTTableDataListGetCommentStorageForKey([v5[15] object], v50);
      if (result)
      {
        if (v56) {
          goto LABEL_120;
        }
      }
      else
      {
        BOOL v72 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v73 = objc_msgSend(NSString, "stringWithUTF8String:", "void p_UpdateDataListsForNewCell(TSTTableDataStore *, TSTCell *, TSTCellStorageRef, TSTCellID, CFUUIDRef, TSCECalculationEngine *)");
        uint64_t result = objc_msgSend(v72, "handleFailureInFunction:file:lineNumber:description:", v73, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 1117, @"Handed a cell comment key!");
        if (v56) {
          goto LABEL_120;
        }
      }
      goto LABEL_121;
    }
LABEL_112:
    if (v15) {
      uint64_t result = TSTTableDataListRemoveReferenceForKey([v5[15] object], v15);
    }
    if (!a2)
    {
      CGRect v57 = 0;
      uint64_t v58 = 0;
      if (!v3) {
        goto LABEL_123;
      }
      goto LABEL_122;
    }
    goto LABEL_121;
  }
  if (v15) {
    BOOL v51 = v15 == v50;
  }
  else {
    BOOL v51 = 1;
  }
  char v52 = !v51;
  CGRect v53 = (TSTTableDataList *)[v5[15] object];
  if (!v50)
  {
    uint64_t v59 = (uint64_t)v49;
    goto LABEL_119;
  }
  CommentStorageForKedouble y = TSTTableDataListGetCommentStorageForKey((uint64_t)v53, v50);
  if (!CommentStorageForKey)
  {
    CGRect v53 = (TSTTableDataList *)[v5[15] object];
    uint64_t v59 = (uint64_t)v49;
LABEL_119:
    uint64_t result = TSTTableDataListAddCommentStorage(v53, v59);
    *(_DWORD *)(a2 + 80) = result;
    if ((v52 & 1) == 0) {
      goto LABEL_121;
    }
    goto LABEL_120;
  }
  if (v15 != v50)
  {
    uint64_t result = TSTTableDataListAddReferenceForKey((id *)[v5[15] object], v50);
    if ((v52 & 1) == 0) {
      goto LABEL_121;
    }
LABEL_120:
    uint64_t result = TSTTableDataListRemoveReferenceForKey([v5[15] object], v15);
    goto LABEL_121;
  }
  uint64_t result = [v49 isEqual:CommentStorageForKey];
  if ((result & 1) == 0)
  {
    uint64_t v68 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v69 = objc_msgSend(NSString, "stringWithUTF8String:", "void p_UpdateDataListsForNewCell(TSTTableDataStore *, TSTCell *, TSTCellStorageRef, TSTCellID, CFUUIDRef, TSCECalculationEngine *)");
    uint64_t result = objc_msgSend(v68, "handleFailureInFunction:file:lineNumber:description:", v69, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 1112, @"Corrupted cell comment table!");
  }
LABEL_121:
  CGRect v57 = *(void **)(a2 + 40);
  uint64_t v58 = *(unsigned int *)(a2 + 32);
  if (!v3)
  {
LABEL_123:
    uint64_t v60 = 0;
    goto LABEL_127;
  }
LABEL_122:
  if ((*(unsigned char *)(v3 + 4) & 2) == 0) {
    goto LABEL_123;
  }
  uint64_t result = TSTCellStorageGetElement(v3, 2);
  CGRect v61 = (unsigned int *)result;
  if (!result)
  {
    CGRect v62 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v63 = [NSString stringWithUTF8String:"TSTTableDataListKey TSTCellStorageStyleID(TSTCellStorage *)"];
    uint64_t result = objc_msgSend(v62, "handleFailureInFunction:file:lineNumber:description:", v63, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 182, @"Can't get style ID storage element!");
  }
  uint64_t v60 = *v61;
LABEL_127:
  if (v60) {
    BOOL v64 = v60 == v58;
  }
  else {
    BOOL v64 = 1;
  }
  int v65 = !v64;
  if (v57 || v58)
  {
    if (!v58) {
      goto LABEL_149;
    }
    if (!v57) {
      goto LABEL_150;
    }
    StyleForKedouble y = TSTTableDataListGetStyleForKey([v5[9] object], v58);
    if (StyleForKey)
    {
      uint64_t result = [v57 isEqual:StyleForKey];
      if ((result & 1) == 0)
      {
        double v91 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v67 = objc_msgSend(NSString, "stringWithUTF8String:", "void p_UpdateDataListsForNewCell(TSTTableDataStore *, TSTCell *, TSTCellStorageRef, TSTCellID, CFUUIDRef, TSCECalculationEngine *)");
        uint64_t result = objc_msgSend(v91, "handleFailureInFunction:file:lineNumber:description:", v67, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 1162, @"Corrupted style keys!");
      }
      if (v60 != v58) {
        uint64_t result = TSTTableDataListAddReferenceForKey((id *)[v5[9] object], v58);
      }
    }
    else
    {
LABEL_149:
      uint64_t result = TSTTableDataListAddStyle((TSTTableDataList *)[v5[9] object], (uint64_t)v57);
      *(_DWORD *)(a2 + 32) = result;
    }
  }
LABEL_150:
  if (v65) {
    uint64_t result = TSTTableDataListRemoveReferenceForKey([v5[9] object], v60);
  }
  if (v3)
  {
    if ((*(unsigned char *)(v3 + 4) & 0x80) != 0)
    {
      uint64_t result = TSTCellStorageGetElement(v3, 128);
      BOOL v76 = (unsigned int *)result;
      if (!result)
      {
        BOOL v77 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v78 = [NSString stringWithUTF8String:"TSTTableDataListKey TSTCellStorageTextStyleID(TSTCellStorage *)"];
        uint64_t result = objc_msgSend(v77, "handleFailureInFunction:file:lineNumber:description:", v78, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 201, @"Can't get style ID storage element!");
      }
      uint64_t v3 = *v76;
      if (a2) {
        goto LABEL_156;
      }
      goto LABEL_160;
    }
    uint64_t v3 = 0;
  }
  if (a2)
  {
LABEL_156:
    uint64_t v74 = *(unsigned int *)(a2 + 48);
    unint64_t v75 = *(void **)(a2 + 56);
    goto LABEL_161;
  }
LABEL_160:
  uint64_t v74 = 0;
  unint64_t v75 = 0;
LABEL_161:
  if (v3) {
    BOOL v79 = v3 == v74;
  }
  else {
    BOOL v79 = 1;
  }
  int v80 = !v79;
  if (v75 || v74)
  {
    if (!v74) {
      goto LABEL_180;
    }
    if (!v75) {
      goto LABEL_176;
    }
    uint64_t v81 = TSTTableDataListGetStyleForKey([v5[9] object], v74);
    if (!v81)
    {
LABEL_180:
      uint64_t result = TSTTableDataListAddStyle((TSTTableDataList *)[v5[9] object], (uint64_t)v75);
      *(_DWORD *)(a2 + 48) = result;
      if (!v80) {
        return result;
      }
      goto LABEL_177;
    }
    uint64_t result = [v75 isEqual:v81];
    if ((result & 1) == 0)
    {
      unsigned int v82 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v83 = objc_msgSend(NSString, "stringWithUTF8String:", "void p_UpdateDataListsForNewCell(TSTTableDataStore *, TSTCell *, TSTCellStorageRef, TSTCellID, CFUUIDRef, TSCECalculationEngine *)");
      uint64_t result = objc_msgSend(v82, "handleFailureInFunction:file:lineNumber:description:", v83, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 1205, @"Corrupted style keys!");
    }
    if (v3 != v74) {
      uint64_t result = TSTTableDataListAddReferenceForKey((id *)[v5[9] object], v74);
    }
  }
LABEL_176:
  if (!v80) {
    return result;
  }
LABEL_177:
  uint64_t v84 = [v5[9] object];

  return TSTTableDataListRemoveReferenceForKey(v84, v3);
}

uint64_t TSTTableDataStoreSetCellAtCellID(void *a1, void *a2, unint64_t a3)
{
  unsigned __int16 v3 = a3;
  unint64_t v6 = a3 >> 16;
  unsigned __int16 v16 = 0;
  uint64_t v7 = (TSTTableTile *)p_TileForRowIndex((uint64_t)a1, (unsigned __int16)a3, &v16, &v15);
  if (!v7)
  {
    uint64_t v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableDataStoreSetCellAtCellID(TSTTableDataStore *, TSTCell *, TSTCellID, CFUUIDRef, TSCECalculationEngine *, TSTConditionalStyleFormulaOwner *, BOOL)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 1308, @"Failed to get tile for cell!");
  }
  uint64_t v10 = (unsigned __int16)(v3 - v16);
  CellStorageRef = TSTTableTileGetCellStorageRef(v7, v6, v10);
  p_UpdateDataListsForNewCell((uint64_t)a1, (uint64_t)a2, (uint64_t)CellStorageRef);
  TSTTableTileSetCell(v7, v6, v10, a2);
  uint64_t result = TSTTableTileShouldSplitRows((uint64_t)v7);
  if (result)
  {
    __int16 v13 = v16;
    [a1 willModify];
    __int16 MidpointForRowSplit = TSTTableTileFindMidpointForRowSplit((uint64_t)v7);
    uint64_t result = p_SplitTileAtRowIndex((uint64_t)a1, v7, v13, MidpointForRowSplit + v13);
  }
  else if (!a2)
  {
    uint64_t result = TSTTableTileShouldMergeRows((uint64_t)v7);
    if (result) {
      uint64_t result = (uint64_t)p_MergeTileRows((uint64_t)a1, v7, v16, v15);
    }
    goto LABEL_11;
  }
  if (a2 && !CellStorageRef) {
    return TSTTableDataStoreIncrementCellCounts((uint64_t)a1, v6, v3);
  }
LABEL_11:
  if (!a2)
  {
    if (CellStorageRef) {
      return TSTTableDataStoreDecrementCellCounts((uint64_t)a1, v6, v3);
    }
  }
  return result;
}

unsigned __int16 *p_MergeTileRows(uint64_t a1, void *a2, unsigned int a3, unsigned int a4)
{
  [(id)a1 willModify];
  if (!TSTTableTileShouldMergeRows((uint64_t)a2))
  {
    uint64_t v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "void p_MergeTileRows(TSTTableDataStore *, TSTTableTile *, TSURowIndex, TSTTableTileID)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 269, @"Shouldn't merge a tile that doesn't want to merge!");
  }
  uint64_t result = TSTTableRBFirstNodeGreaterThanOrEqualTo(*(unsigned __int16 **)(a1 + 24), (unsigned __int16)(a3 + 1));
  if (result) {
    BOOL v11 = result == (unsigned __int16 *)&TSTTableRBTreeNil;
  }
  else {
    BOOL v11 = 1;
  }
  if (!v11)
  {
    uint64_t v12 = result;
    unsigned int v13 = *result;
    if ([a2 maxRow] + a3 >= v13)
    {
      uint64_t v14 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v15 = objc_msgSend(NSString, "stringWithUTF8String:", "void p_MergeTileRows(TSTTableDataStore *, TSTTableTile *, TSURowIndex, TSTTableTileID)");
      objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", v15, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 274, @"Tile rbtree is corrupt!");
    }
    unsigned __int16 v16 = *v12;
    uint64_t v17 = v12[1];
    uint64_t v18 = (void *)[*(id *)(a1 + 32) tileForID:v17];
    if (![v18 numRows]) {
      goto LABEL_12;
    }
    uint64_t result = (unsigned __int16 *)TSTTableTilesShouldMergeRowsTogether((uint64_t)a2, (uint64_t)v18);
    if (result)
    {
      TSTTableTileMergeRows((uint64_t)a2, (uint64_t)v18, (unsigned __int16)(v16 - a3));
LABEL_12:
      *(void *)(a1 + 24) = TSTTableRBTreeDelete(*(TSTTableRBTreeNode_s **)(a1 + 24), v12);
      uint64_t result = (unsigned __int16 *)[*(id *)(a1 + 32) removeTileForID:v17];
    }
  }
  if (a3)
  {
    uint64_t result = (unsigned __int16 *)TSTTableTileShouldMergeRows((uint64_t)a2);
    if (result)
    {
      unsigned __int16 v25 = a3 - 1;
      uint64_t v19 = objc_msgSend(*(id *)(a1 + 32), "tileForID:", TSTTableRBTreeStripIDForCellIndex(*(unsigned __int16 **)(a1 + 24), (unsigned __int16)(a3 - 1), &v25));
      uint64_t result = (unsigned __int16 *)TSTTableTilesShouldMergeRowsTogether(v19, (uint64_t)a2);
      if (result)
      {
        TSTTableTileMergeRows(v19, (uint64_t)a2, (unsigned __int16)(a3 - v25));
        uint64_t v20 = TSTTableRBTreeFind(*(unsigned __int16 **)(a1 + 24), a3);
        if (*v20 != a3)
        {
          uint64_t v21 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v22 = objc_msgSend(NSString, "stringWithUTF8String:", "void p_MergeTileRows(TSTTableDataStore *, TSTTableTile *, TSURowIndex, TSTTableTileID)");
          objc_msgSend(v21, "handleFailureInFunction:file:lineNumber:description:", v22, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 310, @"Found the wrong node (bad key)!");
        }
        if (v20[1] != (unsigned __int16)a4)
        {
          uint64_t v23 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v24 = objc_msgSend(NSString, "stringWithUTF8String:", "void p_MergeTileRows(TSTTableDataStore *, TSTTableTile *, TSURowIndex, TSTTableTileID)");
          objc_msgSend(v23, "handleFailureInFunction:file:lineNumber:description:", v24, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 311, @"Found the wrong node (bad value)!");
        }
        *(void *)(a1 + 24) = TSTTableRBTreeDelete(*(TSTTableRBTreeNode_s **)(a1 + 24), v20);
        return (unsigned __int16 *)[*(id *)(a1 + 32) removeTileForID:a4];
      }
    }
  }
  return result;
}

uint64_t TSTTableDataStoreSetCellsWithCellMap(void *a1, void *a2)
{
  unsigned __int16 v20 = -1;
  uint64_t result = [a2 count];
  uint64_t v19 = result;
  if (result)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    unsigned int v7 = 0xFFFF;
    do
    {
      int v8 = [a2 cellIDAtIndex:v6];
      uint64_t v9 = (void *)[a2 cellAtIndex:v6];
      if (!v5
        || ((v10 = v20, (unsigned __int16)v8 >= v20) ? (BOOL v11 = (unsigned __int16)v8 > v7) : (BOOL v11 = 1), v11))
      {
        uint64_t v5 = (TSTTableTile *)p_TileForRowIndex((uint64_t)a1, (unsigned __int16)v8, &v20, &v21);
        if (!v5)
        {
          uint64_t v12 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v13 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableDataStoreSetCellsWithCellMap(TSTTableDataStore *, id<TSTCellMap>, CFUUIDRef, TSCECalculationEngine *, TSTConditionalStyleFormulaOwner *, BOOL, BOOL)");
          objc_msgSend(v12, "handleFailureInFunction:file:lineNumber:description:", v13, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 1378, @"Failed to get a tile while setting a map!");
        }
        unsigned int v7 = [(TSTTableTile *)v5 maxRow];
        unsigned __int16 v10 = v20;
      }
      uint64_t v14 = (unsigned __int16)(v8 - v10);
      CellStorageRef = TSTTableTileGetCellStorageRef(v5, BYTE2(v8), v14);
      TSTTableTileSetCell(v5, BYTE2(v8), v14, v9);
      uint64_t result = TSTTableTileShouldSplitRows((uint64_t)v5);
      if (result)
      {
        __int16 v16 = v20;
        [a1 willModify];
        __int16 MidpointForRowSplit = TSTTableTileFindMidpointForRowSplit((uint64_t)v5);
        uint64_t result = p_SplitTileAtRowIndex((uint64_t)a1, v5, v16, MidpointForRowSplit + v16);
        uint64_t v5 = 0;
      }
      else if (!v9)
      {
        uint64_t result = TSTTableTileShouldMergeRows((uint64_t)v5);
        if (result)
        {
          unint64_t v18 = v18 & 0xFFFFFFFF00000000 | v21;
          uint64_t result = (uint64_t)p_MergeTileRows((uint64_t)a1, v5, v20, v21);
          uint64_t v5 = 0;
        }
LABEL_20:
        if (!v9)
        {
          if (CellStorageRef) {
            uint64_t result = TSTTableDataStoreDecrementCellCounts((uint64_t)a1, BYTE2(v8), (unsigned __int16)v8);
          }
        }
        goto LABEL_23;
      }
      if (!v9 || CellStorageRef) {
        goto LABEL_20;
      }
      uint64_t result = TSTTableDataStoreIncrementCellCounts((uint64_t)a1, BYTE2(v8), (unsigned __int16)v8);
LABEL_23:
      ++v6;
    }
    while (v19 != v6);
  }
  return result;
}

void *TSTTableDataStorePopulateCustomFormat(void *result, uint64_t a2, double a3)
{
  if ((*(_DWORD *)a2 - 270) <= 2)
  {
    uint64_t v5 = result;
    uint64_t v6 = [result documentRoot];
    if (v6
      && (unsigned int v7 = (void *)v6, (objc_opt_respondsToSelector() & 1) != 0)
      && (uint64_t result = objc_msgSend((id)objc_msgSend(v7, "customFormatList"), "customFormatForKey:", *(unsigned int *)(a2 + 8))) != 0|| (uint64_t result = (void *)v5[16]) != 0&& (uint64_t result = objc_msgSend(result, "customFormatForKey:", *(unsigned int *)(a2 + 8))) != 0)
    {
      if (*(_DWORD *)a2 == 270) {
        uint64_t result = (void *)TSUCustomFormat::formatByEvaluatingConditionsWithDouble((TSUCustomFormat *)result, a3);
      }
      else {
        uint64_t result = (void *)TSUCustomFormat::defaultFormatData((TSUCustomFormat *)result);
      }
      *(void *)(a2 + 16) = result;
    }
    else
    {
      *(void *)(a2 + 16) = 0;
    }
  }
  return result;
}

void TSTTableDataStoreResolveCellDataIDs(id *a1, uint64_t a2)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (a2)
  {
    if (*(unsigned __int8 *)(a2 + 9) << 8 == 768)
    {
      uint64_t v4 = *(unsigned int *)(a2 + 16);
      if (!v4)
      {
        uint64_t v5 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v6 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableDataStoreResolveCellDataIDs(TSTTableDataStore *, TSTCell *, BOOL, BOOL)");
        objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 1481, @"String cell has bad string!");
      }
      StringForKedouble y = (void *)TSTTableDataListGetStringForKey([a1[8] object], v4);
      int v8 = *(_DWORD *)(a2 + 8);
      if ((v8 & 0xFF00) == 0)
      {
        TSTCellClearValue(a2);
        *(unsigned char *)(a2 + 9) = 3;
        int v8 = *(_DWORD *)(a2 + 8);
      }
      if ((v8 & 0xFF00) == 0x300)
      {
        uint64_t v9 = *(void **)(a2 + 24);
        if (v9 != StringForKey)
        {

          *(void *)(a2 + 24) = StringForKey;
          int v10 = HIWORD(*(_DWORD *)(a2 + 8));
          uint64_t v11 = objc_msgSend(StringForKey, "rangeOfCharacterFromSet:", objc_msgSend(MEMORY[0x263F08708], "newlineCharacterSet"));
          __int16 v12 = v10 | 1;
          if (v11 == 0x7FFFFFFFFFFFFFFFLL) {
            __int16 v12 = v10 & 0xFFFE;
          }
          *(_WORD *)(a2 + 10) = v12;
        }
      }
      else
      {
        uint64_t v13 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v14 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellSetStringValueClearingID(TSTCell *, NSString *, BOOL)");
        objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 1003, @"can't set string on non-string cell: %p", a2);
      }
    }
    uint64_t v15 = *(unsigned int *)(a2 + 64);
    if (v15)
    {
      RichTextPayloadForKedouble y = (TSTRichTextPayload *)TSTTableDataListGetRichTextPayloadForKey([a1[12] object], v15);
      TSTCellSetRichTextPayloadClearingIDConvertToPlaintext((TSTRichTextPayload *)a2, RichTextPayloadForKey, 0, 1);
    }
    uint64_t v17 = *(unsigned int *)(a2 + 80);
    if (v17)
    {
      CommentStorageForKedouble y = (TSDCommentStorage *)TSTTableDataListGetCommentStorageForKey([a1[15] object], v17);
      TSTCellSetCommentStorageClearingID((TSDCommentStorage *)a2, CommentStorageForKey, 0);
    }
    uint64_t v19 = *(unsigned int *)(a2 + 32);
    if (v19)
    {
      StyleForKedouble y = TSTTableDataListGetStyleForKey([a1[9] object], v19);
      unsigned int v21 = *(void **)(a2 + 40);
      if (v21 != (void *)StyleForKey)
      {
        uint64_t v22 = (void *)StyleForKey;

        *(void *)(a2 + 40) = v22;
      }
    }
    uint64_t v23 = *(unsigned int *)(a2 + 48);
    if (v23)
    {
      uint64_t v24 = TSTTableDataListGetStyleForKey([a1[9] object], v23);
      unsigned __int16 v25 = *(void **)(a2 + 56);
      if (v25 != (void *)v24)
      {
        BOOL v26 = (void *)v24;

        *(void *)(a2 + 56) = v26;
      }
    }
    if ((*(_DWORD *)(a2 + 104) & 0xFFFFFFFE) == 0x108)
    {
      long long v27 = *(_OWORD *)(a2 + 120);
      long long v42 = *(_OWORD *)(a2 + 104);
      long long v43 = v27;
      int v28 = *(_DWORD *)(a2 + 136);
      if ((v28 - 256) <= 6 && ((1 << v28) & 0x4D) != 0)
      {
        int v30 = *(_DWORD *)(a2 + 140);
        uint64_t v41 = 0;
        long long v39 = 0u;
        long long v40 = 0u;
        BOOL v31 = *(void **)(a2 + 152);
        if (v31)
        {
          [v31 getFormatStruct];
          int v32 = v39;
          if (v28 == v39) {
            return;
          }
        }
        else
        {
          uint64_t v41 = 0;
          long long v39 = TSUInvalidFormat;
          long long v40 = unk_22383BE20;
          int v32 = -1;
        }
        if ((*(_WORD *)(a2 + 96) & 0x10) != 0)
        {
          v36[0] = v42;
          v36[1] = v43;
          int v37 = v32;
          int v38 = v30;
          TSTCellSetExplicitFormat(a2, (uint64_t)v36);
        }
        else
        {
          v33[0] = v42;
          v33[1] = v43;
          int v34 = v32;
          int v35 = v30;
          TSTCellSetImplicitFormat(a2, (uint64_t)v33);
        }
      }
    }
  }
}

id *TSTTableDataStoreClearDataListEntriesForCellStorageRef(id *result, TSTCellStorage *a2)
{
  if (a2)
  {
    unsigned __int16 v3 = result;
    if ((*((unsigned char *)&a2->var0 + 4) & 0x10) != 0)
    {
      uint64_t result = (id *)TSTCellStorageGetElement((uint64_t)a2, 16);
      uint64_t v4 = result;
      if (!result)
      {
        uint64_t v5 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v6 = [NSString stringWithUTF8String:"TSTTableDataListKey TSTCellStorageStringID(TSTCellStorage *)"];
        uint64_t result = (id *)objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 401, @"Can't get string ID storage element!");
      }
      uint64_t v7 = *(unsigned int *)v4;
      if (v7)
      {
        uint64_t result = (id *)TSTTableDataListRemoveReferenceForKey([v3[8] object], v7);
        if ((*((unsigned char *)&a2->var0 + 4) & 0x10) != 0)
        {
          uint64_t result = (id *)TSTCellStorageGetElement((uint64_t)a2, 16);
          *(_DWORD *)uint64_t result = 0;
        }
      }
    }
    if ((*((unsigned char *)&a2->var0 + 4) & 8) != 0)
    {
      uint64_t result = (id *)TSTCellStorageGetElement((uint64_t)a2, 8);
      int v8 = result;
      if (!result)
      {
        uint64_t v9 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v10 = [NSString stringWithUTF8String:"TSTTableDataListKey TSTCellStorageFormulaID(TSTCellStorage *)"];
        uint64_t result = (id *)objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 319, @"Can't get formula ID storage element!");
      }
      uint64_t v11 = *(unsigned int *)v8;
      if (v11)
      {
        uint64_t result = (id *)TSTTableDataListRemoveReferenceForKey([v3[10] object], v11);
        if ((*((unsigned char *)&a2->var0 + 4) & 8) != 0)
        {
          uint64_t result = (id *)TSTCellStorageGetElement((uint64_t)a2, 8);
          *(_DWORD *)uint64_t result = 0;
        }
      }
    }
    if (*((unsigned char *)&a2->var0 + 5))
    {
      uint64_t result = (id *)TSTCellStorageGetElement((uint64_t)a2, 256);
      __int16 v12 = result;
      if (!result)
      {
        uint64_t v13 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v14 = [NSString stringWithUTF8String:"TSTTableDataListKey TSTCellStorageFormulaErrorID(TSTCellStorage *)"];
        uint64_t result = (id *)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 338, @"Can't get formula error ID storage element!");
      }
      uint64_t v15 = *(unsigned int *)v12;
      if (v15)
      {
        uint64_t result = (id *)TSTTableDataListRemoveReferenceForKey([v3[11] object], v15);
        if (*((unsigned char *)&a2->var0 + 5))
        {
          uint64_t result = (id *)TSTCellStorageGetElement((uint64_t)a2, 256);
          *(_DWORD *)uint64_t result = 0;
        }
      }
    }
    if ((*((unsigned char *)&a2->var0 + 5) & 2) != 0)
    {
      uint64_t result = (id *)TSTCellStorageGetElement((uint64_t)a2, 512);
      __int16 v16 = result;
      if (!result)
      {
        uint64_t v17 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v18 = [NSString stringWithUTF8String:"TSTTableDataListKey TSTCellStorageRichTextPayloadID(TSTCellStorage *)"];
        uint64_t result = (id *)objc_msgSend(v17, "handleFailureInFunction:file:lineNumber:description:", v18, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 357, @"Can't get formula error ID storage element!");
      }
      uint64_t v19 = *(unsigned int *)v16;
      if (v19)
      {
        uint64_t result = (id *)TSTTableDataListRemoveReferenceForKey([v3[12] object], v19);
        if ((*((unsigned char *)&a2->var0 + 5) & 2) != 0)
        {
          uint64_t result = (id *)TSTCellStorageGetElement((uint64_t)a2, 512);
          *(_DWORD *)uint64_t result = 0;
        }
      }
    }
    if ((*((unsigned char *)&a2->var0 + 5) & 0x10) != 0)
    {
      uint64_t result = (id *)TSTCellStorageGetElement((uint64_t)a2, 4096);
      unsigned __int16 v20 = result;
      if (!result)
      {
        unsigned int v21 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v22 = [NSString stringWithUTF8String:"TSTTableDataListKey TSTCellStorageCommentStorageID(TSTCellStorage *)"];
        uint64_t result = (id *)objc_msgSend(v21, "handleFailureInFunction:file:lineNumber:description:", v22, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 382, @"Can't get cell comment ID storage element!");
      }
      uint64_t v23 = *(unsigned int *)v20;
      if (v23)
      {
        uint64_t result = (id *)TSTTableDataListRemoveReferenceForKey([v3[15] object], v23);
        if ((*((unsigned char *)&a2->var0 + 5) & 0x10) != 0)
        {
          uint64_t result = (id *)TSTCellStorageGetElement((uint64_t)a2, 4096);
          *(_DWORD *)uint64_t result = 0;
        }
      }
    }
    if ((*((unsigned char *)&a2->var0 + 4) & 2) != 0)
    {
      uint64_t result = (id *)TSTCellStorageGetElement((uint64_t)a2, 2);
      uint64_t v24 = result;
      if (!result)
      {
        unsigned __int16 v25 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v26 = [NSString stringWithUTF8String:"TSTTableDataListKey TSTCellStorageStyleID(TSTCellStorage *)"];
        uint64_t result = (id *)objc_msgSend(v25, "handleFailureInFunction:file:lineNumber:description:", v26, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 182, @"Can't get style ID storage element!");
      }
      uint64_t v27 = *(unsigned int *)v24;
      if (v27)
      {
        uint64_t result = (id *)TSTTableDataListRemoveReferenceForKey([v3[9] object], v27);
        if ((*((unsigned char *)&a2->var0 + 4) & 2) != 0)
        {
          uint64_t result = (id *)TSTCellStorageGetElement((uint64_t)a2, 2);
          *(_DWORD *)uint64_t result = 0;
        }
      }
    }
    if ((*((unsigned char *)&a2->var0 + 4) & 0x80) != 0)
    {
      uint64_t result = (id *)TSTCellStorageGetElement((uint64_t)a2, 128);
      int v28 = result;
      if (!result)
      {
        CGFloat v29 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v30 = [NSString stringWithUTF8String:"TSTTableDataListKey TSTCellStorageTextStyleID(TSTCellStorage *)"];
        uint64_t result = (id *)objc_msgSend(v29, "handleFailureInFunction:file:lineNumber:description:", v30, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 201, @"Can't get style ID storage element!");
      }
      uint64_t v31 = *(unsigned int *)v28;
      if (v31)
      {
        uint64_t result = (id *)TSTTableDataListRemoveReferenceForKey([v3[9] object], v31);
        if ((*((unsigned char *)&a2->var0 + 4) & 0x80) != 0)
        {
          uint64_t result = (id *)TSTCellStorageGetElement((uint64_t)a2, 128);
          *(_DWORD *)uint64_t result = 0;
        }
      }
    }
    if ((*((unsigned char *)&a2->var0 + 4) & 4) != 0)
    {
      uint64_t result = (id *)TSTCellStorageGetElement((uint64_t)a2, 4);
      int v32 = result;
      if (!result)
      {
        uint64_t v33 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v34 = [NSString stringWithUTF8String:"TSTTableDataListKey TSTCellStorageFormatID(TSTCellStorage *)"];
        uint64_t result = (id *)objc_msgSend(v33, "handleFailureInFunction:file:lineNumber:description:", v34, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 249, @"Can't get format ID storage element!");
      }
      uint64_t v35 = *(unsigned int *)v32;
      if (v35)
      {
        uint64_t result = (id *)TSTTableDataListRemoveReferenceForKey([v3[13] object], v35);
        if ((*((unsigned char *)&a2->var0 + 4) & 4) != 0)
        {
          uint64_t result = (id *)TSTCellStorageGetElement((uint64_t)a2, 4);
          *(_DWORD *)uint64_t result = 0;
        }
      }
    }
    if ((*((unsigned char *)&a2->var0 + 4) & 4) != 0)
    {
      uint64_t result = (id *)TSTCellStorageGetElement((uint64_t)a2, 4);
      CGFloat v36 = result;
      if (!result)
      {
        int v37 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v38 = [NSString stringWithUTF8String:"TSTTableDataListKey TSTCellStorageFormatID(TSTCellStorage *)"];
        uint64_t result = (id *)objc_msgSend(v37, "handleFailureInFunction:file:lineNumber:description:", v38, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 249, @"Can't get format ID storage element!");
      }
      uint64_t v39 = *(unsigned int *)v36;
      if (v39)
      {
        uint64_t result = (id *)TSTTableDataListRemoveReferenceForKey([v3[14] object], v39);
        if ((*((unsigned char *)&a2->var0 + 4) & 4) != 0)
        {
          uint64_t result = (id *)TSTCellStorageGetElement((uint64_t)a2, 4);
          *(_DWORD *)uint64_t result = 0;
        }
      }
    }
  }
  return result;
}

uint64_t TSTTableDataStoreAddTileAtID(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return [*(id *)(a1 + 32) setTile:a3 forID:a2];
}

uint64_t privateGetStorageObjectFromDictionary(const __CFDictionary *a1, int a2, void *a3)
{
  kedouble y = a2;
  Value = CFDictionaryGetValue(a1, &key);
  if (!Value) {
    return 2;
  }
  uint64_t v5 = Value;
  uint64_t result = 0;
  *a3 = v5;
  return result;
}

uint64_t TSTTableDataStoreInsertRows(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  [(id)a1 willModify];
  unsigned __int16 v11 = 0;
  uint64_t v8 = objc_msgSend(*(id *)(a1 + 32), "tileForID:", TSTTableRBTreeStripIDForCellIndex(*(unsigned __int16 **)(a1 + 24), a2, &v11));
  if (!v8) {
    return 2;
  }
  TSTTableTileInsertRows(v8, (unsigned __int16)(a2 - v11), a3, a4);
  uint64_t v9 = *(void *)(a1 + 24);
  if (a4)
  {
    TSTTableRBTreeShiftNodesAfter(v9, a2, a3);
  }
  else
  {
    LOWORD(a2) = a2 + 1;
    TSTTableRBTreeShiftNodesAtOrAfter(v9, (unsigned __int16)a2, a3);
  }
  [*(id *)(a1 + 40) shiftKeysAtIndex:(unsigned __int16)a2 amount:a3];
  return 0;
}

uint64_t privateInsertColumnsIntoTile(TSTTableTile *a1, char *a2)
{
  return TSTTableTileInsertColumns((uint64_t)a1, *a2, *((unsigned __int16 *)a2 + 1), a2[4]);
}

uint64_t TSTTableDataStoreInsertColumns(TSTTableDataStore *a1, char a2, uint64_t a3, char a4)
{
  [(TSPContainedObject *)a1 willModify];
  v9[0] = a2;
  char v11 = a4;
  __int16 v10 = a3;
  TSTTableDataStoreIterateTiles(a1, a1->mRowTileIndex, v9, (void (*)(TSTTableTile *, void *))privateInsertColumnsIntoTile);
  return objc_msgSend(-[TSPLazyReference object](a1->mColumnHeaderStorageReference, "object"), "shiftKeysAtIndex:amount:", ((a4 ^ 1) + a2), a3);
}

uint64_t p_updateColumnCellCountsForDeletionGivenTile(TSTTableDataStore *a1, TSTTableTile *a2, unsigned int a3, int a4)
{
  uint64_t result = [(TSTTableTile *)a2 numRows];
  if (result)
  {
    unsigned __int16 v8 = 0;
    unsigned __int16 v9 = [(TSTTableTile *)a2 numRows] - 1;
    int v10 = a3 + a4;
    do
    {
      uint64_t result = (uint64_t)TSTTableTileRowInfoForRowArrayIndex((uint64_t)a2, (unsigned __int16)(v9 - v8));
      unsigned int v11 = *(unsigned __int16 *)(result + 536);
      if (v11 >= a3 && v10 > (int)v11)
      {
        uint64_t v13 = result;
        if (*(_WORD *)(result + 538))
        {
          if (!*(unsigned char *)(result + 541)) {
            TSTTableTileRowInfoRecalculateMaxTileColumnIndex(result);
          }
          unsigned __int8 v14 = 0;
          unsigned int v15 = *(unsigned __int8 *)(v13 + 540);
          do
          {
            uint64_t result = (uint64_t)TSTTableTileRowInfoCellStorageRefAtTileColumnIndex(v13, v14);
            if (result)
            {
              uint64_t result = objc_msgSend(-[TSPLazyReference object](a1->mColumnHeaderStorageReference, "object"), "headerForKey:willModify:createIfNotThere:", v14, 1, 0);
              if (result) {
                uint64_t result = TSTDataStoreDecrementColumnCellCount((uint64_t)a1, (TSTTableHeaderInfo *)result);
              }
            }
            ++v14;
          }
          while (v15 >= v14);
        }
      }
      ++v8;
    }
    while (v8 <= v9);
  }
  return result;
}

uint64_t TSTTableDataStoreRemoveRows(TSTTableDataStore *a1, uint64_t a2, int a3)
{
  [(TSPContainedObject *)a1 willModify];
  unsigned __int16 v6 = a3 + a2;
  uint64_t v7 = &OBJC_IVAR___TSTSearchReference__cellID;
  unsigned __int16 v8 = &OBJC_IVAR___TSTSearchReference__cellID;
  if (a3)
  {
    unsigned int v34 = a3 + a2;
    int v35 = a3;
    unsigned __int16 v9 = a3;
    unsigned int v37 = a2;
    do
    {
      unsigned __int16 v40 = -1;
      int v10 = v8;
      uint64_t v11 = TSTTableRBTreeStripIDForCellIndex(*(unsigned __int16 **)((char *)&a1->super.super.isa + v8[53]), (unsigned __int16)(v6 - 1), &v40);
      __int16 v12 = [(TSTTileIDKeyDict *)a1->mTileStorage tileForID:v11];
      if (!v12)
      {
        uint64_t v13 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v14 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableDataStoreRemoveRows(TSTTableDataStore *, TSURowIndex, TSUColumnRowCount)");
        a2 = v37;
        objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 1841, @"Couldn't find a tile for row %hu!", (unsigned __int16)(v6 - 1));
      }
      unsigned int v15 = v40;
      if (v40 > (unsigned __int16)(v6 - 1))
      {
        __int16 v16 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v17 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableDataStoreRemoveRows(TSTTableDataStore *, TSURowIndex, TSUColumnRowCount)");
        a2 = v37;
        objc_msgSend(v16, "handleFailureInFunction:file:lineNumber:description:", v17, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 1842, @"Tile for row deletion doesn't match!");
        unsigned int v15 = v40;
      }
      unsigned __int16 v18 = v6 - v15;
      if (v15 <= a2) {
        unsigned __int16 v18 = v9;
      }
      BOOL v19 = a2 >= v15;
      unsigned int v20 = a2 - v15;
      if (v19) {
        unsigned int v21 = v20;
      }
      else {
        unsigned int v21 = 0;
      }
      int v22 = v18;
      p_updateColumnCellCountsForDeletionGivenTile(a1, v12, v21, v18);
      TSTTableTileRemoveRows((uint64_t)v12, v21, v22);
      if ([(TSTTableTile *)v12 numRows])
      {
        unsigned __int16 v8 = v10;
      }
      else
      {
        unsigned __int16 v8 = v10;
        uint64_t v23 = TSTTableRBTreeFind(*(unsigned __int16 **)((char *)&a1->super.super.isa + v10[53]), v40);
        *(Class *)((char *)&a1->super.super.isa + v10[53]) = (Class)TSTTableRBTreeDelete(*(TSTTableRBTreeNode_s **)((char *)&a1->super.super.isa+ v10[53]), v23);
        unint64_t v36 = v36 & 0xFFFFFFFF00000000 | v11;
        -[TSTTileIDKeyDict removeTileForID:](a1->mTileStorage, "removeTileForID:");
      }
      v9 -= v22;
      unsigned __int16 v6 = v40 + v21;
      TSTTableRBTreeShiftNodesAfter(*(uint64_t *)((char *)&a1->super.super.isa + v8[53]), v40, -v22);
    }
    while (v9);
    uint64_t v7 = &OBJC_IVAR___TSTSearchReference__cellID;
    mRowHeaderStorage = a1->mRowHeaderStorage;
    uint64_t v25 = a2;
    unsigned __int16 v6 = v34;
    a3 = v35;
    do
    {
      [(TSTTableHeaderStorage *)mRowHeaderStorage removeHeaderForKey:v25];
      uint64_t v25 = (v25 + 1);
    }
    while (v25 < v34);
  }
  [*(id *)((char *)&a1->super.super.isa + v7[47]) shiftKeysAtIndex:v6 amount:-a3];
  if ([(TSTTileIDKeyDict *)a1->mTileStorage tileForID:TSTTableRBTreeStripIDForCellIndex(*(unsigned __int16 **)((char *)&a1->super.super.isa + v8[53]), 0, 0)])
  {
    if (a2) {
      goto LABEL_20;
    }
LABEL_23:
    unsigned int v26 = 0xFFFF;
    goto LABEL_24;
  }
  uint64_t mNextRowStripID = a1->mNextRowStripID;
  a1->uint64_t mNextRowStripID = mNextRowStripID + 1;
  CGFloat v29 = [[TSTTableTile alloc] initWithContext:[(TSPObject *)[(TSPContainedObject *)a1 owner] context]];
  uint64_t v30 = (TSTTableRBTreeNode_s *)TSTTableRBTreeNewNode(0, mNextRowStripID);
  *(Class *)((char *)&a1->super.super.isa + v8[53]) = (Class)TSTTableRBTreeInsert(*(TSTTableRBTreeNode_s **)((char *)&a1->super.super.isa+ v8[53]), v30);
  [(TSTTileIDKeyDict *)a1->mTileStorage setTile:v29 forID:mNextRowStripID];

  if (!a2) {
    goto LABEL_23;
  }
LABEL_20:
  unsigned __int16 v39 = 0;
  unsigned int v26 = TSTTableRBTreeStripIDForCellIndex(*(unsigned __int16 **)((char *)&a1->super.super.isa + v8[53]), (unsigned __int16)(a2 - 1), &v39);
  id v27 = [(TSTTileIDKeyDict *)a1->mTileStorage tileForID:v26];
  if (TSTTableTileShouldMergeRows((uint64_t)v27)) {
    p_MergeTileRows((uint64_t)a1, v27, v39, v26);
  }
LABEL_24:
  unsigned __int16 v38 = 0;
  uint64_t result = TSTTableRBTreeStripIDForCellIndex(*(unsigned __int16 **)((char *)&a1->super.super.isa + v8[53]), a2, &v38);
  if (v26 != result)
  {
    unsigned int v32 = result;
    id v33 = [(TSTTileIDKeyDict *)a1->mTileStorage tileForID:result];
    uint64_t result = TSTTableTileShouldMergeRows((uint64_t)v33);
    if (result) {
      return (uint64_t)p_MergeTileRows((uint64_t)a1, v33, v38, v32);
    }
  }
  return result;
}

uint64_t privateRemoveColumnsFromTile(TSTTableTile *a1, unsigned __int16 *a2)
{
  return TSTTableTileRemoveColumns((uint64_t)a1, *(unsigned __int8 *)a2, a2[1]);
}

uint64_t TSTTableDataStoreRemoveColumns(TSTTableDataStore *a1, uint64_t a2, int a3)
{
  [(TSPContainedObject *)a1 willModify];
  v10[0] = a2;
  char v12 = 0;
  __int16 v11 = a3;
  TSTTableDataStoreIterateTiles(a1, a1->mRowTileIndex, v10, (void (*)(TSTTableTile *, void *))privateRemoveColumnsFromTile);
  uint64_t v6 = [(TSPLazyReference *)a1->mColumnHeaderStorageReference object];
  unsigned int v7 = a3 + a2;
  if (a3)
  {
    unsigned __int16 v8 = (void *)v6;
    do
    {
      [v8 removeHeaderForKey:a2];
      a2 = (a2 + 1);
    }
    while (a2 < v7);
  }
  objc_msgSend(-[TSPLazyReference object](a1->mColumnHeaderStorageReference, "object"), "shiftKeysAtIndex:amount:", v7, -a3);
  a1->mCellCountValid = 0;
  return TSTTableDataStoreNumberOfPopulatedCells((uint64_t)a1);
}

void TSTTableDataStoreMoveRows(void *a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  [a1 willModify];
  if (a3 > a2 && a4 + a2 > a3)
  {
    uint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableDataStoreMoveRows(TSTTableDataStore *, TSURowIndex, TSURowIndex, TSUColumnRowCount)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 1978, @"Move row ranges cannot overlap!");
  }
  __int16 v20 = -1;
  unsigned __int16 v8 = (TSTTableTile *)p_TileForRowIndex((uint64_t)a1, a2, (unsigned __int16 *)&v20, &v19);
  unsigned int v9 = a2;
  if (v8)
  {
    if ((unsigned __int16)v20 != a2)
    {
      p_SplitTileAtRowIndex((uint64_t)a1, v8, v20, a2);
      uint64_t v10 = p_TileForRowIndex((uint64_t)a1, a2, (unsigned __int16 *)&v20, &v19);
      unsigned int v9 = a2;
      if (!v10 || (unsigned __int16)v20 != a2)
      {
        __int16 v11 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v12 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableDataStoreMoveRows(TSTTableDataStore *, TSURowIndex, TSURowIndex, TSUColumnRowCount)");
        objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 1993, @"Tile tree isn't in the expected state after forced split!");
        unsigned int v9 = a2;
      }
    }
  }
  unsigned int v16 = a4 + v9;
  uint64_t v13 = (TSTTableTile *)p_TileForRowIndex((uint64_t)a1, (unsigned __int16)(a4 + v9), (unsigned __int16 *)&v20, &v19);
  if (v13)
  {
    if (v16 != (unsigned __int16)v20)
    {
      p_SplitTileAtRowIndex((uint64_t)a1, v13, v20, v16);
      if (!p_TileForRowIndex((uint64_t)a1, (unsigned __int16)v16, (unsigned __int16 *)&v20, &v19)
        || v16 != (unsigned __int16)v20)
      {
        uint64_t v14 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v15 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableDataStoreMoveRows(TSTTableDataStore *, TSURowIndex, TSURowIndex, TSUColumnRowCount)");
        objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", v15, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 2002, @"Tile tree isn't in the expected state after forced split!");
      }
    }
  }
  [MEMORY[0x263EFF980] arrayWithCapacity:a4];
  operator new();
}

void sub_2237BBD1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28)
{
  _Unwind_Resume(a1);
}

uint64_t p_SplitTileAtRowIndex(uint64_t a1, TSTTableTile *a2, __int16 a3, __int16 a4)
{
  [(id)a1 willModify];
  unsigned __int16 v8 = a4 - a3;
  uint64_t v9 = *(unsigned __int16 *)(a1 + 136);
  *(_WORD *)(a1 + 136) = v9 + 1;
  uint64_t v10 = TSTTableTileSplitRows(a2, v8);
  __int16 v11 = (TSTTableRBTreeNode_s *)TSTTableRBTreeNewNode(a4, v9);
  *(void *)(a1 + 24) = TSTTableRBTreeInsert(*(TSTTableRBTreeNode_s **)(a1 + 24), v11);
  uint64_t v12 = *(void **)(a1 + 32);

  return [v12 setTile:v10 forID:v9];
}

void p_moveColumnsInTile(unsigned __int16 a1, unsigned int a2, unsigned __int8 *a3)
{
  uint64_t v4 = [*(id *)(*(void *)a3 + 32) tileForID:a2];
  unsigned int v5 = a3[8];
  unsigned int v6 = a3[9];
  int v7 = *((unsigned __int16 *)a3 + 5);

  TSTTableTileMoveColumns(v4, v5, v6, v7);
}

void TSTTableDataStoreMoveColumns(void *a1, unsigned int a2, unsigned int a3, int a4)
{
  [a1 willModify];
  if (a3 > a2 && a4 + a2 > a3)
  {
    int v7 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v8 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableDataStoreMoveColumns(TSTTableDataStore *, TSUColumnIndex, TSUColumnIndex, TSUColumnRowCount)");
    objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 2178, @"Move column ranges cannot overlap!");
  }
  operator new();
}

void sub_2237BC0BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void TSTTableDataStoreSwapRows(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned __int16 v20 = -1;
  unsigned __int16 v19 = -1;
  unsigned int v6 = (TSTTableTile *)p_TileForRowIndex(a1, a2, &v20, &v18);
  uint64_t v7 = p_TileForRowIndex(a1, a3, &v19, &v17);
  uint64_t v8 = (TSTTableTile *)v7;
  if (!v6 || !v7)
  {
    uint64_t v9 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v10 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTTableDataStoreSwapRows(TSTTableDataStore *, TSURowIndex, TSURowIndex)");
    objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 2229, @"Can't get tiles for rows in swap!");
  }
  __int16 v11 = (TSTTableTileRowInfo *)TSTTableTileYankRow((uint64_t)v6, (unsigned __int16)(a2 - v20));
  uint64_t v12 = (TSTTableTileRowInfo *)TSTTableTileYankRow((uint64_t)v8, (unsigned __int16)(a3 - v19));
  if (v11)
  {
    [(TSPContainedObject *)v11 setOwner:v8];
    unsigned __int16 v13 = a3 - v19;
    [(TSPContainedObject *)v11 willModify];
    v11->mTileRowIndeCGFloat x = v13;
    TSTTableTileSpliceRow(v8, (unsigned __int16)(a3 - v19), v11);
  }
  if (v12)
  {
    [(TSPContainedObject *)v12 setOwner:v6];
    unsigned __int16 v14 = a2 - v20;
    [(TSPContainedObject *)v12 willModify];
    v12->mTileRowIndeCGFloat x = v14;
    TSTTableTileSpliceRow(v6, (unsigned __int16)(a2 - v20), v12);
  }
  id v15 = (id)[*(id *)(a1 + 40) headerForKey:a2 willModify:0 createIfNotThere:0];
  id v16 = (id)[*(id *)(a1 + 40) headerForKey:a3 willModify:0 createIfNotThere:0];
  [*(id *)(a1 + 40) removeHeaderForKey:a2];
  [*(id *)(a1 + 40) removeHeaderForKey:a3];
  if (v15) {
    [*(id *)(a1 + 40) setHeader:v15 forKey:a3];
  }
  if (v16) {
    [*(id *)(a1 + 40) setHeader:v16 forKey:a2];
  }
}

uint64_t TSTTableDataStoreGetReorganizeValuesForColumn(uint64_t a1, char a2, uint64_t a3)
{
  uint64_t v4 = a1;
  char v5 = a2;
  uint64_t v6 = a3;
  return TSTTableRBTreeApply(*(void *)(a1 + 24), (uint64_t (*)(uint64_t, uint64_t, uint64_t))p_ReorganizeValuesForTile, (uint64_t)&v4);
}

uint64_t p_ReorganizeValuesForTile(int a1, unsigned int a2, unsigned char *a3)
{
  uint64_t v101 = *MEMORY[0x263EF8340];
  char v5 = (void *)[*(id *)(*(void *)a3 + 32) tileForID:a2];
  long long v96 = 0u;
  long long v97 = 0u;
  long long v98 = 0u;
  long long v99 = 0u;
  id obj = (id)[v5 rowInfos];
  uint64_t result = [obj countByEnumeratingWithState:&v96 objects:v100 count:16];
  if (result)
  {
    uint64_t v7 = result;
    int v8 = a1;
    uint64_t v9 = &OBJC_IVAR___TSTSearchReference__cellID;
    int v92 = v8;
    uint64_t v93 = *(void *)v97;
    do
    {
      uint64_t v10 = 0;
      uint64_t v90 = v7;
      do
      {
        if (*(void *)v97 != v93) {
          objc_enumerationMutation(obj);
        }
        uint64_t v11 = *(void *)(*((void *)&v96 + 1) + 8 * v10);
        uint64_t v12 = *(void **)(*(void *)a3 + v9[62]);
        if (!v12
          || (v13 = [v12 mergedRangeForCellID:*(unsigned __int16 *)(v11 + 536) | ((unint64_t)a3[8] << 16)], (_WORD)v13 == 0xFFFF)|| ((v13 & 0xFF0000) != 0xFF0000 ? (v14 = HIWORD(v13) == 0) : (v14 = 1), !v14 ? (BOOL v15 = (v13 & 0xFFFF00000000) == 0) : (BOOL v15 = 1), v15))
        {
          LOBYTE(v25) = a3[8];
        }
        else
        {
          unint64_t v25 = v13 >> 16;
        }
        id v16 = TSTTableTileRowInfoCellStorageRefAtTileColumnIndex(v11, v25);
        if (v16)
        {
          unsigned int v17 = v16;
          uint64_t v18 = *((void *)a3 + 2);
          unsigned int v19 = *(unsigned __int16 *)(v11 + 536) + v92;
          unsigned __int16 v20 = (__int16 *)(v18 + 24 * v19);
          int v21 = HIBYTE(*(unsigned __int16 *)(v16 + 1));
          LOBYTE(v22) = HIBYTE(*(_WORD *)(v16 + 1));
          *unsigned __int16 v20 = HIBYTE(*(_WORD *)(v16 + 1)) | (*((unsigned __int8 *)v20 + 1) << 8);
          if (v21 == 2)
          {
            if ((v16[4] & 4) != 0)
            {
              Element = (unsigned int *)TSTCellStorageGetElement((uint64_t)v16, 4);
              if (!Element)
              {
                id v27 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
                uint64_t v28 = [NSString stringWithUTF8String:"TSTTableDataListKey TSTCellStorageFormatID(TSTCellStorage *)"];
                uint64_t v7 = v90;
                uint64_t v29 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"];
                uint64_t v30 = v28;
                uint64_t v9 = &OBJC_IVAR___TSTSearchReference__cellID;
                [v27 handleFailureInFunction:v30 file:v29 lineNumber:249 description:@"Can't get format ID storage element!"];
              }
              uint64_t v23 = *Element;
            }
            else
            {
              uint64_t v23 = 0;
            }
            uint64_t v95 = 0;
            memset(v94, 0, sizeof(v94));
            TSTTableDataListGetCellFormatForKey([*(id *)(*(void *)a3 + 104) object], v23, (uint64_t)v94);
            if (LODWORD(v94[0]) == 266)
            {
              *(unsigned char *)unsigned __int16 v20 = 10;
              uint64_t v24 = HIDWORD(v94[0]);
            }
            else
            {
              uint64_t v24 = 0;
            }
            __int16 v22 = *v20;
          }
          else
          {
            uint64_t v24 = 0;
          }
          switch((char)v22)
          {
            case 0:
              *unsigned __int16 v20 = v22;
              break;
            case 2:
              *unsigned __int16 v20 = v22 | 0x600;
              uint64_t v31 = 0;
              if ((v17[4] & 0x20) == 0) {
                goto LABEL_59;
              }
              unsigned int v32 = (uint64_t *)TSTCellStorageGetElement((uint64_t)v17, 32);
              if (v32) {
                goto LABEL_58;
              }
              uint64_t v33 = [MEMORY[0x263F7C7F0] currentHandler];
              uint64_t v34 = [NSString stringWithUTF8String:"double TSTCellStorageDoubleValue(TSTCellStorage *)"];
              uint64_t v35 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"];
              unint64_t v36 = (void *)v33;
              uint64_t v9 = &OBJC_IVAR___TSTSearchReference__cellID;
              uint64_t v37 = v34;
              uint64_t v38 = 420;
              goto LABEL_42;
            case 3:
              *unsigned __int16 v20 = v22 | 0x200;
              if ((v17[4] & 0x10) == 0) {
                goto LABEL_44;
              }
              unsigned __int16 v39 = (int *)TSTCellStorageGetElement((uint64_t)v17, 16);
              if (v39) {
                goto LABEL_67;
              }
              uint64_t v40 = [MEMORY[0x263F7C7F0] currentHandler];
              uint64_t v41 = [NSString stringWithUTF8String:"TSTTableDataListKey TSTCellStorageStringID(TSTCellStorage *)"];
              uint64_t v42 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"];
              long long v43 = (void *)v40;
              uint64_t v9 = &OBJC_IVAR___TSTSearchReference__cellID;
              uint64_t v44 = v41;
              uint64_t v45 = 401;
              CGAffineTransform v46 = @"Can't get string ID storage element!";
              goto LABEL_66;
            case 5:
              *unsigned __int16 v20 = v22 | 0x400;
              if (v17[2] << 8 != 1280)
              {
                uint64_t v62 = [MEMORY[0x263F7C7F0] currentHandler];
                uint64_t v63 = [NSString stringWithUTF8String:"double TSTCellStorageRawDateValue(TSTCellStorage *)"];
                uint64_t v64 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"];
                int v65 = (void *)v62;
                uint64_t v9 = &OBJC_IVAR___TSTSearchReference__cellID;
                [v65 handleFailureInFunction:v63 file:v64 lineNumber:439 description:@"Asked for date value from non-date cell."];
              }
              if ((v17[4] & 0x40) == 0)
              {
                uint64_t v66 = [MEMORY[0x263F7C7F0] currentHandler];
                uint64_t v67 = [NSString stringWithUTF8String:"double TSTCellStorageRawDateValue(TSTCellStorage *)"];
                uint64_t v68 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"];
                uint64_t v69 = (void *)v66;
                uint64_t v9 = &OBJC_IVAR___TSTSearchReference__cellID;
                [v69 handleFailureInFunction:v67 file:v68 lineNumber:440 description:@"No date content in date cell."];
              }
              unsigned int v32 = (uint64_t *)TSTCellStorageGetElement((uint64_t)v17, 64);
              if (v32) {
                goto LABEL_58;
              }
              uint64_t v70 = [MEMORY[0x263F7C7F0] currentHandler];
              uint64_t v71 = [NSString stringWithUTF8String:"double TSTCellStorageRawDateValue(TSTCellStorage *)"];
              uint64_t v35 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"];
              unint64_t v36 = (void *)v70;
              uint64_t v9 = &OBJC_IVAR___TSTSearchReference__cellID;
              uint64_t v37 = v71;
              uint64_t v38 = 442;
              CGRect v53 = @"Can't get date storage element!";
              goto LABEL_57;
            case 6:
              *unsigned __int16 v20 = v22 | 0x100;
              if (v17[2] << 8 != 1536)
              {
                uint64_t v72 = [MEMORY[0x263F7C7F0] currentHandler];
                uint64_t v73 = [NSString stringWithUTF8String:"BOOL TSTCellStorageBoolValue(TSTCellStorage *)"];
                uint64_t v74 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"];
                unint64_t v75 = (void *)v72;
                uint64_t v9 = &OBJC_IVAR___TSTSearchReference__cellID;
                [v75 handleFailureInFunction:v73 file:v74 lineNumber:427 description:@"Asked for BOOL value from non-BOOL cell."];
              }
              if ((v17[4] & 0x20) != 0)
              {
                BOOL v79 = (double *)TSTCellStorageGetElement((uint64_t)v17, 32);
                if (!v79)
                {
                  uint64_t v80 = [MEMORY[0x263F7C7F0] currentHandler];
                  uint64_t v81 = [NSString stringWithUTF8String:"BOOL TSTCellStorageBoolValue(TSTCellStorage *)"];
                  uint64_t v82 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"];
                  uint64_t v83 = (void *)v80;
                  uint64_t v9 = &OBJC_IVAR___TSTSearchReference__cellID;
                  [v83 handleFailureInFunction:v81 file:v82 lineNumber:432 description:@"Can't get has numbers storage element!"];
                }
                BOOL v76 = *v79 != 0.0;
              }
              else
              {
                BOOL v76 = 0;
              }
              *(unsigned char *)(v18 + 24 * v19 + 8) = v76;
              break;
            case 7:
              *unsigned __int16 v20 = v22 | 0x500;
              if (v17[2] << 8 != 1792)
              {
                uint64_t v47 = [MEMORY[0x263F7C7F0] currentHandler];
                uint64_t v48 = [NSString stringWithUTF8String:"double TSTCellStorageDurationValue(TSTCellStorage *)"];
                uint64_t v49 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"];
                uint64_t v50 = (void *)v47;
                uint64_t v9 = &OBJC_IVAR___TSTSearchReference__cellID;
                [v50 handleFailureInFunction:v48 file:v49 lineNumber:453 description:@"Asked for duration value from non-duration cell."];
              }
              uint64_t v31 = 0;
              if ((v17[4] & 0x20) == 0) {
                goto LABEL_59;
              }
              unsigned int v32 = (uint64_t *)TSTCellStorageGetElement((uint64_t)v17, 32);
              if (v32) {
                goto LABEL_58;
              }
              uint64_t v51 = [MEMORY[0x263F7C7F0] currentHandler];
              uint64_t v52 = [NSString stringWithUTF8String:"double TSTCellStorageDurationValue(TSTCellStorage *)"];
              uint64_t v35 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"];
              unint64_t v36 = (void *)v51;
              uint64_t v9 = &OBJC_IVAR___TSTSearchReference__cellID;
              uint64_t v37 = v52;
              uint64_t v38 = 458;
LABEL_42:
              CGRect v53 = @"Can't get has number storage element!";
LABEL_57:
              [v36 handleFailureInFunction:v37 file:v35 lineNumber:v38 description:v53];
LABEL_58:
              uint64_t v31 = *v32;
LABEL_59:
              *(void *)(v18 + 24 * v19 + 8) = v31;
              break;
            case 9:
              *unsigned __int16 v20 = v22 | 0x200;
              if ((v17[5] & 2) != 0)
              {
                unsigned __int16 v39 = (int *)TSTCellStorageGetElement((uint64_t)v17, 512);
                if (!v39)
                {
                  uint64_t v77 = [MEMORY[0x263F7C7F0] currentHandler];
                  uint64_t v78 = [NSString stringWithUTF8String:"TSTTableDataListKey TSTCellStorageRichTextPayloadID(TSTCellStorage *)"];
                  uint64_t v42 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"];
                  long long v43 = (void *)v77;
                  uint64_t v9 = &OBJC_IVAR___TSTSearchReference__cellID;
                  uint64_t v44 = v78;
                  uint64_t v45 = 357;
                  CGAffineTransform v46 = @"Can't get formula error ID storage element!";
LABEL_66:
                  [v43 handleFailureInFunction:v44 file:v42 lineNumber:v45 description:v46];
                }
LABEL_67:
                int v54 = *v39;
              }
              else
              {
LABEL_44:
                int v54 = 0;
              }
              *(_DWORD *)(v18 + 24 * v19 + 8) = v54;
              break;
            case 10:
              MultipleChoiceListFormatForKedouble y = (void *)TSTTableDataListGetMultipleChoiceListFormatForKey([*(id *)(*(void *)a3 + 112) object], v24);
              double v56 = 0.0;
              if ((v17[4] & 0x20) != 0)
              {
                CGRect v57 = (double *)TSTCellStorageGetElement((uint64_t)v17, 32);
                if (!v57)
                {
                  double v89 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
                  uint64_t v58 = [NSString stringWithUTF8String:"double TSTCellStorageDoubleValue(TSTCellStorage *)"];
                  uint64_t v7 = v90;
                  uint64_t v59 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"];
                  uint64_t v60 = v58;
                  uint64_t v9 = &OBJC_IVAR___TSTSearchReference__cellID;
                  [v89 handleFailureInFunction:v60 file:v59 lineNumber:420 description:@"Can't get has number storage element!"];
                }
                double v56 = *v57;
              }
              uint64_t v61 = (uint64_t)v56;
              switch([MultipleChoiceListFormatForKey valueTypeOfItemAtIndex:(uint64_t)v56])
              {
                case 0u:
                  *unsigned __int16 v20 = 0;
                  break;
                case 1u:
                  *unsigned __int16 v20 = 262;
                  *(unsigned char *)(v18 + 24 * v19 + 8) = [MultipleChoiceListFormatForKey BOOLeanAtIndex:v61];
                  break;
                case 2u:
                  *((unsigned char *)v20 + 1) = 2;
                  uint64_t v84 = v18 + 24 * v19;
                  *(_DWORD *)(v84 + 8) = v24;
                  *(void *)(v84 + 16) = v61;
                  break;
                case 3u:
                  *unsigned __int16 v20 = 1029;
                  objc_msgSend((id)objc_msgSend(MultipleChoiceListFormatForKey, "dateAtIndex:", v61), "timeIntervalSinceReferenceDate");
                  goto LABEL_59;
                case 4u:
                  *unsigned __int16 v20 = 1538;
                  [MultipleChoiceListFormatForKey numberAtIndex:v61];
                  goto LABEL_59;
                default:
                  uint64_t v85 = [MEMORY[0x263F7C7F0] currentHandler];
                  uint64_t v86 = objc_msgSend(NSString, "stringWithUTF8String:", "void p_ReorganizeValuesForTile(TSURowIndex, TSTTableTileStripID, void *)");
                  uint64_t v87 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"];
                  uint64_t v88 = (void *)v85;
                  uint64_t v9 = &OBJC_IVAR___TSTSearchReference__cellID;
                  [v88 handleFailureInFunction:v86 file:v87 lineNumber:2387 description:@"Unexpected value type found in TSCECellValue"];
                  break;
              }
              break;
            default:
              break;
          }
        }
        ++v10;
      }
      while (v7 != v10);
      uint64_t result = [obj countByEnumeratingWithState:&v96 objects:v100 count:16];
      uint64_t v7 = result;
    }
    while (result);
  }
  return result;
}

uint64_t privateDumpTile(unsigned int a1, unsigned int a2, id *a3)
{
  NSLog((NSString *)@"tile at row index %hu", a1);
  char v5 = (void *)[a3[4] tileForID:a2];

  return [v5 debugDump];
}

uint64_t privateDumpTiles(TSTTableDataStore *a1)
{
  return TSTTableRBTreeApply((uint64_t)a1->mRowTileIndex, (uint64_t (*)(uint64_t, uint64_t, uint64_t))privateDumpTile, (uint64_t)a1);
}

uint64_t privateValidateTile(uint64_t a1, void *a2)
{
  return [a2 validate];
}

uint64_t privateValidateTileStorage(void *a1, const char *a2)
{
  return [a1 applyFunction:privateValidateTile withState:0];
}

uint64_t privateValidateRowTileIndex(TSTTableDataStore *a1)
{
  return TSTTableRBTreeApply((uint64_t)a1->mRowTileIndex, (uint64_t (*)(uint64_t, uint64_t, uint64_t))p_validateTileCB, (uint64_t)a1);
}

uint64_t p_validateTileCB(unsigned __int16 a1, unsigned int a2, id *a3)
{
  uint64_t result = [a3[4] tileForID:a2];
  if (!result)
  {
    uint64_t v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "void p_validateTileCB(UInt16, UInt16, void *)");
    uint64_t v6 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"];
    return [v4 handleFailureInFunction:v5 file:v6 lineNumber:2449 description:@"No tile for valid strip ID!"];
  }
  return result;
}

TSTTableTileRowInfo *privateValidateRowHeader(unsigned __int16 *a1, unsigned __int16 *a2, void *a3)
{
  unsigned __int16 v12 = 0;
  uint64_t v4 = *a1;
  uint64_t v5 = (TSTTableTile *)objc_msgSend(*((id *)a3 + 4), "tileForID:", TSTTableRBTreeStripIDForCellIndex(*((unsigned __int16 **)a3 + 3), v4, &v12));
  if (!v5)
  {
    uint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "void privateValidateRowHeader(const void *, const void *, void *)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 2469, @"tile not found for index %d", v4);
  }
  uint64_t result = TSTTableTileRowInfoForTileRowIndex(v5, (unsigned __int16)(v4 - v12), 0);
  if (result)
  {
    uint64_t v9 = result;
    if (result->mCellCount != a2[17])
    {
      uint64_t v10 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v11 = objc_msgSend(NSString, "stringWithUTF8String:", "void privateValidateRowHeader(const void *, const void *, void *)");
      return (TSTTableTileRowInfo *)objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 2477, @"row info (%p) cell count and row header (%p) cell count do not match at row: %d", v9, a2, v4);
    }
  }
  return result;
}

unsigned char *privateCollectColumnCellCountsInTile(uint64_t a1, void *a2, uint64_t a3)
{
  __int16 v5 = [a2 numRows];
  uint64_t result = (unsigned char *)[a2 numRows];
  if (result)
  {
    unsigned __int16 v7 = 0;
    unsigned __int16 v8 = v5 - 1;
    do
    {
      uint64_t result = TSTTableTileRowInfoForRowArrayIndex((uint64_t)a2, (unsigned __int16)(v8 - v7));
      int v9 = *((unsigned __int16 *)result + 269);
      if (*((_WORD *)result + 269))
      {
        uint64_t v10 = (uint64_t)result;
        if (!result[541]) {
          TSTTableTileRowInfoRecalculateMaxTileColumnIndex((uint64_t)result);
        }
        unsigned __int8 v11 = 0;
        unsigned __int16 v12 = 0;
        unsigned int v13 = *(unsigned __int8 *)(v10 + 540);
        do
        {
          uint64_t result = TSTTableTileRowInfoCellStorageRefAtTileColumnIndex(v10, v11);
          if (result)
          {
            ++*(_WORD *)(a3 + 2 * v11);
            ++v12;
          }
          ++v11;
        }
        while (v13 >= v11 && v9 != v12);
      }
      ++v7;
    }
    while (v7 <= v8);
  }
  return result;
}

uint64_t privateValidateColumnCellCounts(TSTTableDataStore *a1)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  memset(v7, 0, 510);
  [(TSTTileIDKeyDict *)a1->mTileStorage applyFunction:privateCollectColumnCellCountsInTile withState:v7];
  for (uint64_t i = 0; i != 255; ++i)
  {
    uint64_t result = objc_msgSend(-[TSPLazyReference object](a1->mColumnHeaderStorageReference, "object"), "headerForKey:willModify:createIfNotThere:", i, 0, 0);
    if (result)
    {
      uint64_t v4 = result;
      if (*((unsigned __int16 *)v7 + i) != *(unsigned __int16 *)(result + 34))
      {
        __int16 v5 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v6 = [NSString stringWithUTF8String:"void privateValidateColumnCellCounts(TSTTableDataStore *)"];
        uint64_t result = objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 2531, @"info (%p) column counts do not match tile counts in column %d for dataStore %p", v4, i, a1);
      }
    }
  }
  return result;
}

uint64_t TSTTableDataStoreAddString(uint64_t a1, uint64_t a2)
{
  unsigned __int16 v3 = (TSTTableDataList *)[*(id *)(a1 + 64) object];

  return TSTTableDataListAddString(v3, a2);
}

uint64_t TSTTableDataStoreGetStringForKey(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = [*(id *)(a1 + 64) object];

  return TSTTableDataListGetStringForKey(v3, a2);
}

uint64_t TSTTableDataStoreAddStringReferenceForKey(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (id *)[*(id *)(a1 + 64) object];

  return TSTTableDataListAddReferenceForKey(v3, a2);
}

uint64_t TSTTableDataStoreRemoveStringReferenceForKey(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = [*(id *)(a1 + 64) object];

  return TSTTableDataListRemoveReferenceForKey(v3, a2);
}

BOOL TSTTableDataStoreHasMergeRanges(uint64_t a1)
{
  return [*(id *)(a1 + 144) count] != 0;
}

uint64_t TSTTableDataStoreMerge(void *a1, uint64_t a2)
{
  [a1 willModify];
  uint64_t v4 = (TSTMergeRegionMap *)a1[18];
  if (!v4)
  {
    uint64_t v4 = -[TSTMergeRegionMap initWithContext:]([TSTMergeRegionMap alloc], "initWithContext:", objc_msgSend((id)objc_msgSend(a1, "owner"), "context"));
    a1[18] = v4;
  }

  return [(TSTMergeRegionMap *)v4 insert:a2];
}

uint64_t TSTTableDataStoreUnmerge(void *a1, uint64_t a2)
{
  [a1 willModify];
  uint64_t v4 = (void *)a1[18];

  return [v4 remove:a2];
}

uint64_t TSTTableDataStoreApplyRowRemappingToMergeRanges(id *a1, uint64_t a2)
{
  [a1 willModify];
  id v4 = a1[18];
  if (v4 && [v4 count])
  {
    id v5 = [[TSTMergeRegionMap alloc] initRegionMapFromMap:a1[18] rowRemapping:a2];

    a1[18] = v5;
  }
  return 1;
}

uint64_t TSTTableDataStoreRangeOfTableWithMerges(uint64_t a1)
{
  unsigned int v1 = *(void **)(a1 + 144);
  if (v1) {
    return [v1 unionedMergeRange];
  }
  else {
    return 0xFFFFFFLL;
  }
}

uint64_t TSTTableDataStoreMergeRangeAtCellID(uint64_t a1, unsigned int a2)
{
  __int16 v2 = *(void **)(a1 + 144);
  if (v2) {
    return [v2 mergedRangeForCellID:a2];
  }
  else {
    return 0xFFFFFFLL;
  }
}

void *TSTTableDataStoreMergeRangesPartiallyIntersectCellRange(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void **)(a1 + 144);
  if (result) {
    return (void *)[result partiallyIntersectsCellRange:a2];
  }
  return result;
}

uint64_t TSTTableDataStoreMergedGridIndicesForDirection(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 144) mergedGridIndicesForDimension:a2];
}

uint64_t TSTTableDataStoreCreateMergeRangesForCellRange(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a1 + 144)) {
    return 0;
  }
  id v4 = [TSTMergeRegionMap alloc];
  uint64_t v5 = *(void *)(a1 + 144);

  return (uint64_t)[(TSTMergeRegionMap *)v4 initRegionMapFromMap:v5 intersectingRange:a2];
}

id TSTTableDataStoreMergeRangesForCellRange(uint64_t a1, uint64_t a2)
{
  MergeRangesForCellunint64_t Range = (void *)TSTTableDataStoreCreateMergeRangesForCellRange(a1, a2);

  return MergeRangesForCellRange;
}

uint64_t TSTTableDataStoreCopyAPasteboardCustomFormatToDoc(uint64_t a1, void *a2, uint64_t a3)
{
  if (!a2 || !*(void *)(a1 + 128) || (objc_opt_respondsToSelector() & 1) == 0) {
    return 0;
  }
  uint64_t v6 = (void *)[a2 customFormatList];
  uint64_t v7 = [*(id *)(a1 + 128) customFormatForKey:a3];
  if (!v7)
  {
    int v9 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v10 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTTableDataListKey TSTTableDataStoreCopyAPasteboardCustomFormatToDoc(TSTTableDataStore *, TSKDocumentRoot *, TSTTableDataListKey)");
    objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 2739, @"The pasteboard should have had every custom format.");
    return 0;
  }

  return [v6 addCustomFormat:v7 withOldKey:a3];
}

uint64_t TSTTableDataListPasteboardCustomFormatListCount(uint64_t a1)
{
  return [*(id *)(a1 + 128) count];
}

uint64_t TSTTableDataStoreAddConditionalStyle(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (TSTTableDataList *)[*(id *)(a1 + 56) object];

  return TSTTableDataListAddConditionalStyleSet(v3, a2);
}

uint64_t TSTTableDataStoreConditionalStyleForKey(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = [*(id *)(a1 + 56) object];

  return TSTTableDataListGetConditionalStyleSetForKey(v3, a2);
}

uint64_t TSTTableDataStoreConditionalStyleRefCountForKey(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = [*(id *)(a1 + 56) object];

  return TSTTableDataListRefCountForKey(v3, a2);
}

uint64_t p_upgradeTileRowInfos(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "i_upgradeTileRowInfosWithDataStore:");
}

uint64_t **std::__tree<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int const,SFUtility::ObjcSharedPtr<NSObject>>>(uint64_t **a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    unsigned int v7 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        unsigned int v9 = *((_DWORD *)v5 + 8);
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v8 = a1 + 1;
LABEL_10:
    uint64_t v10 = operator new(0x30uLL);
    v10[8] = *(_DWORD *)a3;
    unsigned __int8 v11 = *(void **)(a3 + 8);
    *((void *)v10 + 5) = v11;
    id v12 = v11;
    std::__tree<std::__value_type<std::string,unsigned short>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned short>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned short>>>::__insert_node_at(a1, (uint64_t)v8, v6, (uint64_t *)v10);
    return (uint64_t **)v10;
  }
  return v8;
}

void std::__tree<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>>>::destroy(a1, a2[1]);

    operator delete(a2);
  }
}

uint64_t TSTMasterLayoutInvalidateStrokeRange(TSTMasterLayout *a1, uint64_t a2)
{
  TSTMasterLayoutStrokesArrayRangeUpdate(a1);
  Tableuint64_t NumberOfColumns = TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1);
  __int16 TableNumberOfRows = TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1);
  unsigned int v6 = (unsigned __int16)a2;
  if ((unsigned __int16)(a2 + HIWORD(a2) - 1) >= (unsigned __int16)(TableNumberOfRows - 1)) {
    unsigned int v7 = (unsigned __int16)(TableNumberOfRows - 1);
  }
  else {
    unsigned int v7 = (unsigned __int16)(a2 + HIWORD(a2) - 1);
  }
  unsigned int v8 = BYTE2(a2);
  if ((TableNumberOfColumns - 1) >= (BYTE4(a2) + BYTE2(a2) - 1)) {
    unsigned int v9 = (BYTE4(a2) + BYTE2(a2) - 1);
  }
  else {
    unsigned int v9 = (TableNumberOfColumns - 1);
  }
  [(NSRecursiveLock *)a1->mStrokesLock lock];
  unsigned int v30 = v7 + 1;
  if ((unsigned __int16)a2 <= v7 + 1)
  {
    unsigned int v10 = (unsigned __int16)a2;
    do
    {
      if ((TSTMasterLayoutIsGridRowHidden(a1, v10) & 1) == 0)
      {
        if (v10 <= v7)
        {
          unsigned int v31 = v10;
          if (TSTMasterLayoutStrokeAdjustGridRowForVisibility(a1, 1, &v31))
          {
            objc_opt_class();
            unsigned int v11 = v31;
            [(NSMutableArray *)a1->mTopRowStrokes objectAtIndex:v31];
            uint64_t v12 = TSUDynamicCast();
            if (v12)
            {
              unsigned int v13 = (TSTStrokeRunArray *)v12;
              TSTStrokeRunArrayWriteLock(v12);
              DefaultStrokesForGridRow = (unsigned int *)TSTMasterLayoutGetDefaultStrokesForGridRow(a1, v11, 1);
              TSTStrokeRunArrayResetRange(v13, DefaultStrokesForGridRow, BYTE2(a2), v9 + 1);
              TSTStrokeRunArrayUnlock((uint64_t)v13);
              TSTStrokeRunArrayUnlock((uint64_t)DefaultStrokesForGridRow);
            }
          }
        }
        if (v10 > (unsigned __int16)a2)
        {
          unsigned int v31 = v10;
          if (TSTMasterLayoutStrokeAdjustGridRowForVisibility(a1, 0, &v31))
          {
            objc_opt_class();
            unsigned int v15 = v31;
            [(NSMutableArray *)a1->mBottomRowStrokes objectAtIndex:v31];
            uint64_t v16 = TSUDynamicCast();
            if (v16)
            {
              unsigned int v17 = (TSTStrokeRunArray *)v16;
              TSTStrokeRunArrayWriteLock(v16);
              uint64_t v18 = (unsigned int *)TSTMasterLayoutGetDefaultStrokesForGridRow(a1, v15, 0);
              TSTStrokeRunArrayResetRange(v17, v18, BYTE2(a2), v9 + 1);
              TSTStrokeRunArrayUnlock((uint64_t)v17);
              TSTStrokeRunArrayUnlock((uint64_t)v18);
            }
          }
        }
      }
      ++v10;
    }
    while (v7 + 2 != v10);
  }
  if (BYTE2(a2) <= v9 + 1)
  {
    unsigned int v19 = BYTE2(a2);
    do
    {
      if ((TSTMasterLayoutIsGridColumnHidden(a1, v19) & 1) == 0)
      {
        if (v19 <= v9)
        {
          unsigned int v31 = v19;
          if (TSTMasterLayoutStrokeAdjustGridColumnForVisibility(a1, 1, &v31))
          {
            objc_opt_class();
            unsigned int v20 = v31;
            [(NSMutableArray *)a1->mLeftColumnStrokes objectAtIndex:v31];
            uint64_t v21 = TSUDynamicCast();
            if (v21)
            {
              __int16 v22 = (TSTStrokeRunArray *)v21;
              TSTStrokeRunArrayWriteLock(v21);
              DefaultStrokesForGridColumn = (unsigned int *)TSTMasterLayoutGetDefaultStrokesForGridColumn(a1, v20, 1);
              TSTStrokeRunArrayResetRange(v22, DefaultStrokesForGridColumn, v6, v30);
              TSTStrokeRunArrayUnlock((uint64_t)v22);
              TSTStrokeRunArrayUnlock((uint64_t)DefaultStrokesForGridColumn);
            }
          }
        }
        if (v19 > v8)
        {
          unsigned int v31 = v19;
          if (TSTMasterLayoutStrokeAdjustGridColumnForVisibility(a1, 0, &v31))
          {
            objc_opt_class();
            unsigned int v24 = v31;
            [(NSMutableArray *)a1->mRightColumnStrokes objectAtIndex:v31];
            uint64_t v25 = TSUDynamicCast();
            if (v25)
            {
              unsigned int v26 = (TSTStrokeRunArray *)v25;
              TSTStrokeRunArrayWriteLock(v25);
              id v27 = (unsigned int *)TSTMasterLayoutGetDefaultStrokesForGridColumn(a1, v24, 0);
              TSTStrokeRunArrayResetRange(v26, v27, v6, v30);
              TSTStrokeRunArrayUnlock((uint64_t)v26);
              TSTStrokeRunArrayUnlock((uint64_t)v27);
            }
          }
        }
      }
      ++v19;
    }
    while (v9 + 2 != v19);
  }
  mStrokesLocuint64_t k = a1->mStrokesLock;

  return [(NSRecursiveLock *)mStrokesLock unlock];
}

uint64_t TSTMasterLayoutSetRange(_WORD *a1)
{
  a1[84] = objc_msgSend((id)objc_msgSend(a1, "tableModel"), "numberOfHeaderColumns");
  a1[92] = objc_msgSend((id)objc_msgSend(a1, "tableModel"), "numberOfHeaderRows");
  uint64_t result = objc_msgSend((id)objc_msgSend(a1, "tableModel"), "numberOfFooterRows");
  a1[93] = result;
  return result;
}

uint64_t TSTMasterLayoutGetRange(uint64_t a1)
{
  Tableuint64_t NumberOfColumns = TSTMasterLayoutGetTableNumberOfColumns(a1);
  return (TableNumberOfColumns << 32) | (TSTMasterLayoutGetTableNumberOfRows(a1) << 48);
}

uint64_t TSTMasterLayoutInvalidateStrokeDefaults(uint64_t a1)
{
  [(id)a1 invalidateBandedFill];
  [*(id *)(a1 + 240) lock];
  uint64_t v2 = *(void *)(a1 + 200);
  if (v2)
  {
    TSTTableStrokeDefaultsRelease(v2);
    *(void *)(a1 + 200) = 0;
  }
  uint64_t v3 = *(void **)(a1 + 240);

  return [v3 unlock];
}

uint64_t TSTMasterLayoutGetTableNumberOfHeaderRows(unsigned __int16 *a1)
{
  if ([a1 emptyFilteredTable]) {
    return 0;
  }
  else {
    return a1[92];
  }
}

uint64_t TSTMasterLayoutGetTableNumberOfHeaderColumns(unsigned __int16 *a1)
{
  if ([a1 emptyFilteredTable]) {
    return 0;
  }
  else {
    return a1[84];
  }
}

uint64_t TSTMasterLayoutGetTableNumberOfFooterRows(unsigned __int16 *a1)
{
  if ([a1 emptyFilteredTable]) {
    return 0;
  }
  else {
    return a1[93];
  }
}

uint64_t TSTMasterLayoutGetTableNumberOfColumns(uint64_t a1)
{
  if ([(id)a1 emptyFilteredTable])
  {
    LOWORD(v2) = 1;
  }
  else
  {
    int v3 = [(id)a1 isDynamicallyChangingRowOrColumnCount];
    unsigned int v4 = objc_msgSend((id)objc_msgSend((id)a1, "tableModel"), "numberOfColumns");
    LOWORD(v2) = v4;
    if (v3)
    {
      int64_t v2 = *(int *)(a1 + 364) + (unint64_t)v4;
      if (v2 < 1
        || ([(id)a1 emptyFilteredTable] & 1) == 0
        && v2 <= (unint64_t)*(unsigned __int16 *)(a1 + 168))
      {
        uint64_t v5 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v6 = [NSString stringWithUTF8String:"TSUColumnRowCount TSTMasterLayoutGetTableNumberOfColumns(TSTMasterLayout *)"];
        objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTMasterLayout.mm"), 799, @"Size invariants violated by dynamic add/remove");
      }
    }
  }
  return (unsigned __int16)v2;
}

uint64_t TSTMasterLayoutGetTableNumberOfRows(uint64_t a1)
{
  if ([(id)a1 emptyFilteredTable])
  {
    LOWORD(v2) = 1;
  }
  else
  {
    int v3 = [(id)a1 isDynamicallyChangingRowOrColumnCount];
    unsigned int v4 = objc_msgSend((id)objc_msgSend((id)a1, "tableModel"), "numberOfRows");
    LOWORD(v2) = v4;
    if (v3)
    {
      int64_t v2 = *(int *)(a1 + 508) + (unint64_t)v4;
      if (v2 < 1
        || (([(id)a1 emptyFilteredTable] & 1) == 0 ? (uint64_t v5 = *(unsigned __int16 *)(a1 + 184)) : (uint64_t v5 = 0),
            ([(id)a1 emptyFilteredTable] & 1) == 0 ? (uint64_t v6 = *(unsigned __int16 *)(a1 + 186)) : (uint64_t v6 = 0),
            v2 <= (unint64_t)(v6 + v5)))
      {
        unsigned int v7 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v8 = [NSString stringWithUTF8String:"TSUColumnRowCount TSTMasterLayoutGetTableNumberOfRows(TSTMasterLayout *)"];
        objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTMasterLayout.mm"), 823, @"Size invariants violated by dynamic add/remove");
      }
    }
  }
  return (unsigned __int16)v2;
}

uint64_t TSTMasterLayoutGetHeaderRowsRepeat(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 123);
}

double TSTMasterLayoutHeightOfRow(TSTMasterLayout *a1, uint64_t a2, char a3, char *a4, int a5, int a6)
{
  uint64_t v12 = [(TSTMasterLayout *)a1 tableModel];
  double v13 = TSTTableDefaultRowHeight((uint64_t)v12);
  int v14 = [(TSTMasterLayout *)a1 tableRowsBehavior];
  if (a6)
  {
    double v15 = 0.0;
    if ([(TSTHiddenRowsColumnsCache *)[(TSTMasterLayout *)a1 hiddenRowsColumnsCache] isRowHidden:a2])
    {
      return v15;
    }
  }
  if ((a3 & 1) == 0)
  {
    mDynamicRowSwapDelegate = a1->mDynamicRowSwapDelegate;
    if (mDynamicRowSwapDelegate) {
      a2 = [(TSTLayoutDynamicRowSwapProtocol *)mDynamicRowSwapDelegate rowForRowID:a2];
    }
  }
  double v17 = TSTMasterLayoutStrokeHeightOfGridRow(a1, a2, 0, 0xFFFFFFFF) * 0.5;
  double v18 = TSTMasterLayoutStrokeHeightOfGridRow(a1, (int)a2 + 1, 0, 0xFFFFFFFF) * 0.5;
  BOOL v19 = [(TSTMasterLayout *)a1 emptyFilteredTable];
  if (!a2 && v19)
  {
    if (a4) {
      *a4 = 1;
    }
    return v18 + v17 + a1->mTableDefaultFontHeightForArea[0];
  }
  if (![(TSTMasterLayout *)a1 isDynamicallyChangingRowOrColumnCount]
    || !a1->mDynamicResizingRows
    || ((int TableNumberOfRows = TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1),
         ![(TSTMasterLayout *)a1 emptyFilteredTable])
      ? (int mCachedNumberOfFooterRows = a1->mCachedNumberOfFooterRows)
      : (int mCachedNumberOfFooterRows = 0),
        TableNumberOfRows - mCachedNumberOfFooterRows - a1->mDynamicRowAdjustment > (int)a2
     || ((int v22 = TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1),
          ![(TSTMasterLayout *)a1 emptyFilteredTable])
       ? (int v23 = a1->mCachedNumberOfFooterRows)
       : (int v23 = 0),
         v22 - v23 <= (int)a2)))
  {
    uint64_t v29 = [(TSTMasterLayout *)a1 tableInfo];
    char v46 = 0;
    [(TSTWidthHeightCache *)[(TSTMasterLayout *)a1 widthHeightCache] getModelHeightForRow:a2];
    if (v30 == 0.0)
    {
      double v31 = TSTTableHeightOfRow((uint64_t)v12, a2, &v46);
      if (v14 != 3 || v46 == 0) {
        double v33 = v31;
      }
      else {
        double v33 = -1.0;
      }
      [(TSTWidthHeightCache *)[(TSTMasterLayout *)a1 widthHeightCache] setModelHeight:a2 forRow:v33];
    }
    else
    {
      double v33 = -1.0;
      if (v30 == -1.0) {
        char v46 = 1;
      }
      else {
        double v33 = v30;
      }
    }
    [(TSTWidthHeightCache *)[(TSTMasterLayout *)a1 widthHeightCache] getFitHeightForRow:a2];
    if (v14 == 1)
    {
      if (v34 == 0.0) {
        TSTTableComputeDefaultFontHeight(v12, 0);
      }
      BOOL v27 = v33 == v13;
      if (v34 >= v33 - (v17 + v18))
      {
        BOOL v27 = 1;
        BOOL v35 = 1;
        double mDynamicAddOrRemoveRowElementSize = v34;
LABEL_55:
        char v25 = vabdd_f64(v18 + v17 + v34, v33) < 0.01 || v35;
        if ([(TSTMasterLayout *)a1 isDynamicallyResizing:0 rowColIndex:a2]) {
          double mDynamicAddOrRemoveRowElementSize = mDynamicAddOrRemoveRowElementSize + a1->mDynamicResizingRowAdjustment;
        }
        double v28 = 1.0;
        if ([(TSTTableInfo *)v29 partitioner]
          && [(TSTTablePartitioner *)[(TSTTableInfo *)v29 partitioner] scaleIsValid])
        {
          [(TSTTablePartitioner *)[(TSTTableInfo *)v29 partitioner] scaleToFit];
          double v28 = v36;
        }
        goto LABEL_63;
      }
    }
    else
    {
      if (v14 == 3)
      {
        BOOL v27 = v33 == -1.0;
        if (v33 == -1.0) {
          double mDynamicAddOrRemoveRowElementSize = v34;
        }
        else {
          double mDynamicAddOrRemoveRowElementSize = v33;
        }
        BOOL v35 = v33 == -1.0;
        goto LABEL_55;
      }
      if (v34 == 0.0) {
        TSTTableComputeDefaultFontHeight(v12, 0);
      }
      BOOL v27 = 0;
    }
    BOOL v35 = 0;
    double mDynamicAddOrRemoveRowElementSize = v33;
    goto LABEL_55;
  }
  double mDynamicAddOrRemoveRowElementSize = a1->mDynamicAddOrRemoveRowElementSize;
  if ([(TSTMasterLayout *)a1 isDynamicallyResizing:0 rowColIndex:a2]) {
    double mDynamicAddOrRemoveRowElementSize = mDynamicAddOrRemoveRowElementSize + a1->mDynamicResizingRowAdjustment;
  }
  char v25 = 0;
  BOOL v27 = mDynamicAddOrRemoveRowElementSize == v13 && v14 != 2;
  double v28 = 1.0;
LABEL_63:
  double v37 = v17 + v18;
  if ((a5 & v27) == 0) {
    double v37 = -0.0;
  }
  double v38 = mDynamicAddOrRemoveRowElementSize + v37;
  if (a4) {
    *a4 = v25;
  }
  double v15 = v38 * v28;
  [(TSTMasterLayout *)a1 maximumPartitionSize];
  if (v40 != *MEMORY[0x263F001B0] || v39 != *(double *)(MEMORY[0x263F001B0] + 8))
  {
    [(TSTMasterLayout *)a1 maximumPartitionSize];
    double v42 = v41;
    if (![(TSTMasterLayout *)a1 emptyFilteredTable] && a1->mHeaderRowsRepeat)
    {
      unsigned int mCachedNumberOfHeaderRows = a1->mCachedNumberOfHeaderRows;
      if (mCachedNumberOfHeaderRows <= a2)
      {
        if (a1->mCachedNumberOfHeaderRows)
        {
          int v44 = 0;
          do
            double v42 = v42 - TSTMasterLayoutHeightOfRow(a1, (unsigned __int16)v44++, 0, 0, 1, 1);
          while (mCachedNumberOfHeaderRows > (unsigned __int16)v44);
        }
      }
    }
    if (v42 <= v15) {
      return v42;
    }
  }
  return v15;
}

double TSTMasterLayoutWidthOfColumn(uint64_t a1, uint64_t a2, char a3, unsigned char *a4, int a5)
{
  char v22 = 0;
  unsigned int v10 = (void *)[(id)a1 tableInfo];
  uint64_t v11 = [(id)a1 tableModel];
  int v12 = [(id)a1 emptyFilteredTable];
  if (!a2 && v12)
  {
    if (!objc_msgSend((id)objc_msgSend((id)a1, "tableModel"), "numberOfColumns")) {
      return 0.0;
    }
    unsigned __int8 v13 = 0;
    double v14 = 0.0;
    do
    {
      char v21 = 0;
      if (!TSTTableIsColumnHidden([(id)a1 tableModel], v13)) {
        double v14 = v14 + TSTTableWidthOfColumn([(id)a1 tableModel], v13, &v21);
      }
      ++v13;
    }
    while (objc_msgSend((id)objc_msgSend((id)a1, "tableModel"), "numberOfColumns") > v13);
    return v14;
  }
  if (a5)
  {
    double v14 = 0.0;
    if (objc_msgSend((id)objc_msgSend((id)a1, "hiddenRowsColumnsCache"), "isColumnHidden:", a2)) {
      return v14;
    }
  }
  if ((a3 & 1) == 0)
  {
    double v15 = *(void **)(a1 + 368);
    if (v15) {
      a2 = [v15 columnForColumnID:a2];
    }
  }
  if (![(id)a1 isDynamicallyChangingRowOrColumnCount]
    || !*(unsigned char *)(a1 + 450)
    || (int)(TSTMasterLayoutGetTableNumberOfColumns(a1) - *(_DWORD *)(a1 + 364)) > (int)a2)
  {
    objc_msgSend((id)objc_msgSend((id)a1, "widthHeightCache"), "getModelWidthForColumn:", a2);
    double v17 = v16;
    if (v16 <= 0.0)
    {
      double v17 = TSTTableWidthOfColumn(v11, a2, &v22);
      objc_msgSend((id)objc_msgSend((id)a1, "widthHeightCache"), "setModelWidth:forColumn:", a2, v17);
    }
    if (a4) {
      *a4 = 0;
    }
    if (![(id)a1 isDynamicallyResizing:1 rowColIndex:a2]) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }
  double v17 = *(double *)(a1 + 344);
  if ([(id)a1 isDynamicallyResizing:1 rowColIndex:a2]) {
LABEL_22:
  }
    double v17 = v17 + *(double *)(a1 + 464);
LABEL_23:
  double v18 = 1.0;
  if ([v10 partitioner]
    && objc_msgSend((id)objc_msgSend(v10, "partitioner"), "scaleIsValid"))
  {
    objc_msgSend((id)objc_msgSend(v10, "partitioner"), "scaleToFit");
    double v18 = v19;
  }
  return v17 * v18;
}

uint64_t TSTMasterLayoutSetHeaderColumnsRepeat(uint64_t result, char a2)
{
  *(unsigned char *)(result + 122) = a2;
  return result;
}

uint64_t TSTMasterLayoutSetHeaderRowsRepeat(uint64_t result, char a2)
{
  *(unsigned char *)(result + 123) = a2;
  return result;
}

uint64_t TSTMasterLayoutSetHeaderColumnsFrozen(uint64_t result, char a2)
{
  *(unsigned char *)(result + 120) = a2;
  return result;
}

uint64_t TSTMasterLayoutSetHeaderRowsFrozen(uint64_t result, char a2)
{
  *(unsigned char *)(result + 121) = a2;
  return result;
}

uint64_t TSTMasterLayoutGetRangeForHint(uint64_t a1, void *a2)
{
  if (!a2)
  {
    int v3 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v4 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTCellRange TSTMasterLayoutGetRangeForHint(TSTMasterLayout *, TSTLayoutHint *)");
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTMasterLayout.mm"), 553, @"invalid nil value for '%s'", "layoutHint");
  }

  return [a2 cellRange];
}

uint64_t TSTMasterLayoutGetHeaderColumnsFrozen(unsigned char *a1)
{
  if (([a1 isDynamicallyRepressingFrozenHeaders] & 1) != 0 || !a1[120]) {
    return 0;
  }
  else {
    return [a1 dynamicRepResize] ^ 1;
  }
}

uint64_t TSTMasterLayoutGetHeaderRowsFrozen(unsigned char *a1)
{
  if (([a1 isDynamicallyRepressingFrozenHeaders] & 1) != 0 || !a1[121]) {
    return 0;
  }
  else {
    return [a1 dynamicRepResize] ^ 1;
  }
}

uint64_t TSTMasterLayoutGetHeaderColumnsRepeat(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 122);
}

uint64_t TSTMasterLayoutSetTableNameEnabled(uint64_t result, int a2)
{
  if (*(unsigned __int8 *)(result + 124) != a2) {
    *(unsigned char *)(result + 124) = a2;
  }
  return result;
}

uint64_t TSTMasterLayoutGetTableNameEnabled(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 124);
}

uint64_t TSTMasterLayoutGetTableNumberOfNonHiddenFooterRows(_WORD *a1)
{
  if (([a1 emptyFilteredTable] & 1) != 0 || !a1[93])
  {
    return 0;
  }
  else
  {
    __int16 v2 = a1[93];
    return (unsigned __int16)(v2
                            - objc_msgSend((id)objc_msgSend(a1, "hiddenRowsColumnsCache"), "numberRowsHiddenInCellRange:", TSTMasterLayoutGetEntireFooterRowsCellRange(a1)));
  }
}

uint64_t TSTMasterLayoutGetEntireFooterRowsCellRange(unsigned __int16 *a1)
{
  if ([a1 emptyFilteredTable]) {
    return 0xFFFFFFLL;
  }
  uint64_t v2 = a1[93];
  if (!a1[93]) {
    return 0xFFFFFFLL;
  }
  Tableuint64_t NumberOfColumns = TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1);
  return (v2 << 48) | (TableNumberOfColumns << 32) | (unsigned __int16)(TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1)
                                                                      - v2);
}

uint64_t TSTMasterLayoutGetEntireHeaderColumnsCellRange(unsigned __int16 *a1)
{
  if ([a1 emptyFilteredTable]) {
    return 0xFFFFFFLL;
  }
  uint64_t v2 = a1[84];
  if (!a1[84]) {
    return 0xFFFFFFLL;
  }
  TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1);
  return (v2 << 32) | (TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1) << 48);
}

uint64_t TSTMasterLayoutGetEntireHeaderRowsCellRange(unsigned __int16 *a1)
{
  if ([a1 emptyFilteredTable]) {
    return 0xFFFFFFLL;
  }
  uint64_t v2 = a1[92];
  if (!a1[92]) {
    return 0xFFFFFFLL;
  }
  Tableuint64_t NumberOfColumns = TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1);
  TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1);
  return (v2 << 48) | (TableNumberOfColumns << 32);
}

unint64_t TSTMasterLayoutExpandCellRangeToCoverMergedCells(void *a1, unint64_t a2)
{
  if ([a1 emptyFilteredTable]) {
    return a2;
  }
  uint64_t v5 = [a1 tableModel];

  return TSTTableExpandCellRangeToCoverMergedCells(v5, a2);
}

uint64_t TSTMasterLayoutIsColumnHidden(void *a1, uint64_t a2)
{
  int v3 = (void *)[a1 hiddenRowsColumnsCache];

  return [v3 isColumnHidden:a2];
}

uint64_t TSTMasterLayoutIsRowHidden(void *a1, uint64_t a2)
{
  int v3 = (void *)[a1 hiddenRowsColumnsCache];

  return [v3 isRowHidden:a2];
}

double TSTMasterLayoutStrokeHeightOfGridRow(TSTMasterLayout *a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  [(NSRecursiveLock *)a1->mStrokesLock lock];
  StrokesForGridRow = TSTMasterLayoutGetStrokesForGridRow(a1, a2, 1, 0);
  unsigned int v9 = TSTMasterLayoutGetStrokesForGridRow(a1, a2, 0, 0);
  double v10 = TSTStrokeRunArrayMaxWidthForMergedHorizontalStrokes(StrokesForGridRow, v9, a3, a4);
  if (StrokesForGridRow) {
    TSTStrokeRunArrayUnlock((uint64_t)StrokesForGridRow);
  }
  if (v9) {
    TSTStrokeRunArrayUnlock((uint64_t)v9);
  }
  [(NSRecursiveLock *)a1->mStrokesLock unlock];
  return v10;
}

uint64_t TSTMasterLayoutFittingHeightOfRow(void *a1, uint64_t a2)
{
  int v3 = (void *)[a1 widthHeightCache];

  return [v3 getFitHeightForRow:a2];
}

double TSTMasterLayoutHeightOfRowIgnoringFitting(TSTMasterLayout *a1, uint64_t a2, unint64_t TableNumberOfRows)
{
  uint64_t v8 = [(TSTMasterLayout *)a1 tableModel];
  int v9 = [(TSTMasterLayout *)a1 tableRowsBehavior];
  mDynamicRowSwapDelegate = a1->mDynamicRowSwapDelegate;
  if (mDynamicRowSwapDelegate) {
    a2 = [(TSTLayoutDynamicRowSwapProtocol *)mDynamicRowSwapDelegate rowForRowID:a2];
  }
  double v50 = 0.0;
  double v51 = 0.0;
  if (TableNumberOfRows)
  {
    double v50 = TSTMasterLayoutStrokeHeightOfGridRow(a1, a2, 0, 0xFFFFFFFF) * 0.5;
    double v51 = TSTMasterLayoutStrokeHeightOfGridRow(a1, (int)a2 + 1, 0, 0xFFFFFFFF) * 0.5;
  }
  if ([(TSTMasterLayout *)a1 isDynamicallyChangingRowOrColumnCount]
    && a1->mDynamicResizingRows)
  {
    int TableNumberOfRows = TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1);
    int v11 = [(TSTMasterLayout *)a1 emptyFilteredTable] ? 0 : a1->mCachedNumberOfFooterRows;
    if ((int)TableNumberOfRows - v11 - a1->mDynamicRowAdjustment <= (int)a2)
    {
      double mDynamicAddOrRemoveRowElementSize = a1->mDynamicAddOrRemoveRowElementSize;
      double v49 = 1.0;
      goto LABEL_55;
    }
  }
  char v54 = 0;
  [(TSTWidthHeightCache *)[(TSTMasterLayout *)a1 widthHeightCache] getModelHeightForRow:a2];
  if (v12 == 0.0)
  {
    double v13 = TSTTableHeightOfRow(v8, a2, &v54);
    BOOL v14 = v54 != 0;
    BOOL v15 = v9 == 3;
    if (v14 && v15) {
      double v16 = -1.0;
    }
    else {
      double v16 = v13;
    }
    if (v14 && v15) {
      double mDynamicAddOrRemoveRowElementSize = 0.0;
    }
    else {
      double mDynamicAddOrRemoveRowElementSize = v13;
    }
    [(TSTWidthHeightCache *)[(TSTMasterLayout *)a1 widthHeightCache] setModelHeight:a2 forRow:v16];
  }
  else
  {
    double mDynamicAddOrRemoveRowElementSize = v12;
    double v16 = -1.0;
    if (v12 == -1.0)
    {
      char v54 = 1;
      double mDynamicAddOrRemoveRowElementSize = 0.0;
    }
    else
    {
      double v16 = v12;
    }
  }
  double v18 = [(TSTMasterLayout *)a1 tableInfo];
  double v49 = 1.0;
  if ([(TSTTableInfo *)v18 partitioner]
    && [(TSTTablePartitioner *)[(TSTTableInfo *)v18 partitioner] scaleIsValid])
  {
    [(TSTTablePartitioner *)[(TSTTableInfo *)v18 partitioner] scaleToFit];
    double v49 = v19;
  }
  if (v16 == -1.0)
  {
    Tableuint64_t NumberOfColumns = TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1);
    if (TableNumberOfColumns >= 0xFF) {
      uint64_t v21 = 255;
    }
    else {
      uint64_t v21 = TableNumberOfColumns;
    }
    char v22 = [[TSTLayoutCellIterator alloc] initWithMasterLayout:a1 range:a2 | (unint64_t)(v21 << 32) | 0x1000000000000 flags:16];
    if (!TSTLayoutCellIteratorGetNextCell((uint64_t)v22, &v52))
    {

      goto LABEL_54;
    }
    double mDynamicAddOrRemoveRowElementSize = 0.0;
    while (1)
    {
      unint64_t v4 = v4 & 0xFFFFFFFF00000000 | HIDWORD(v52);
      [(TSTMasterLayout *)a1 defaultPaddingForCellID:v4];
      double v24 = v23;
      double v26 = v25;
      unint64_t v3 = v3 & 0xFFFFFFFF00000000 | HIDWORD(v52);
      [(TSTMasterLayout *)a1 paddingForCellID:v3];
      double v30 = v29;
      double v32 = v31;
      double v33 = v24 + v26;
      double v34 = v29 + v27;
      double v35 = v34 <= v33 ? 0.0 : v34 - v33;
      if (!v53) {
        break;
      }
      if (*(unsigned __int8 *)(v53 + 9) << 8 != 1536)
      {
        long long v43 = *(void **)(v53 + 56);
LABEL_42:
        if ([v43 isVariation])
        {
          if (v53) {
            uint64_t v44 = *(void *)(v53 + 56);
          }
          else {
            uint64_t v44 = 0;
          }
          [(TSTMasterLayout *)a1 fontHeightOfParagraphStyle:v44];
          double v45 = v33 + v46;
        }
        else
        {
          double v45 = a1->mTableDefaultFontHeightForArea[0];
        }
        double v47 = v51 + v50 + v35 + v45;
        if (mDynamicAddOrRemoveRowElementSize <= v47) {
          double mDynamicAddOrRemoveRowElementSize = v47;
        }
        goto LABEL_50;
      }
      double v36 = v27;
      double v37 = v28;
      int TableNumberOfRows = TableNumberOfRows & 0xFFFFFFFF00000000 | HIDWORD(v52);
      id v38 = -[TSTMasterLayout newTextEngineForCell:atCellID:](a1, "newTextEngineForCell:atCellID:");
      double v39 = -[TSTTextEngineDelegate initWithPadding:verticalAlignment:]([TSTTextEngineDelegate alloc], "initWithPadding:verticalAlignment:", 0, v30, v32, v36, v37);
      [v38 setDelegate:v39];
      double v40 = objc_msgSend(v38, "layoutText:kind:minSize:maxSize:anchor:flags:", @"X", 5, 15, 8.0, 8.0, 4294967300.0, 4294967300.0, *MEMORY[0x263F00148], *(double *)(MEMORY[0x263F00148] + 8));
      [v38 setDelegate:0];
      [v40 typographicBoundsForCell];
      [v40 frameBounds];
      if (mDynamicAddOrRemoveRowElementSize <= v51 + v50 + v35 + v33 + v41)
      {
        [v40 typographicBoundsForCell];
        [v40 frameBounds];
        double mDynamicAddOrRemoveRowElementSize = v51 + v50 + v35 + v33 + v42;
      }

LABEL_50:
      if (!TSTLayoutCellIteratorGetNextCell((uint64_t)v22, &v52))
      {

        if (mDynamicAddOrRemoveRowElementSize != 0.0) {
          goto LABEL_55;
        }
LABEL_54:
        double mDynamicAddOrRemoveRowElementSize = v51 + v50 + a1->mTableDefaultFontHeightForArea[0];
        goto LABEL_55;
      }
    }
    long long v43 = 0;
    goto LABEL_42;
  }
LABEL_55:
  if ([(TSTMasterLayout *)a1 isDynamicallyResizing:0 rowColIndex:a2]) {
    double mDynamicAddOrRemoveRowElementSize = mDynamicAddOrRemoveRowElementSize + a1->mDynamicResizingRowAdjustment;
  }
  return v49 * mDynamicAddOrRemoveRowElementSize;
}

double TSTMasterLayoutSizeOfTextInColumn(void *a1)
{
  [a1 typographicBoundsForCell];
  double v3 = v2;
  [a1 frameBounds];
  return v3;
}

void TSTMasterLayoutFittingWidthForColumnDirect(TSTMasterLayout *a1, uint64_t a2)
{
  [(TSTWidthHeightCache *)[(TSTMasterLayout *)a1 widthHeightCache] getFitWidthForCol:a2];
  double v5 = v4;
  if (v4 == -1.0)
  {
    [(TSTWidthHeightCache *)[(TSTMasterLayout *)a1 widthHeightCache] resetColWidthsStartingWith:a2 andEndingWith:a2];
    TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1);
    [(TSTMasterLayout *)a1 addChangeDescriptorWithType:19 andCellRange:((unint64_t)a2 << 16) | (TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1) << 48) | 0x100000000];
  }
  if (v5 > 0.0)
  {
    double v6 = v5 + TSTMasterLayoutStrokeWidthOfGridColumn(a1, a2, 0, 0xFFFFFFFF) * 0.5;
    ceil(v6 + TSTMasterLayoutStrokeWidthOfGridColumn(a1, (int)a2 + 1, 0, 0xFFFFFFFF) * 0.5);
  }
}

uint64_t TSTMasterLayoutRemoveFittingWidthForColumnRange(void *a1, unsigned __int8 a2, char a3)
{
  double v5 = (void *)[a1 widthHeightCache];

  return [v5 resetColWidthsStartingWith:a2 andEndingWith:(a2 + a3 - 1)];
}

double TSTMasterLayoutStrokeWidthOfGridColumn(TSTMasterLayout *a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  [(NSRecursiveLock *)a1->mStrokesLock lock];
  StrokesForGridColumn = TSTMasterLayoutGetStrokesForGridColumn(a1, a2, 1, 0);
  int v9 = TSTMasterLayoutGetStrokesForGridColumn(a1, a2, 0, 0);
  double v10 = TSTStrokeRunArrayMaxWidthForMergedVerticalStrokes(StrokesForGridColumn, v9, a3, a4);
  if (StrokesForGridColumn) {
    TSTStrokeRunArrayUnlock((uint64_t)StrokesForGridColumn);
  }
  if (v9) {
    TSTStrokeRunArrayUnlock((uint64_t)v9);
  }
  [(NSRecursiveLock *)a1->mStrokesLock unlock];
  return v10;
}

uint64_t TSTMasterLayoutPurgeFittingWidths(void *a1)
{
  unsigned int v1 = (void *)[a1 widthHeightCache];

  return [v1 resetAllCol];
}

BOOL TSTMasterLayoutFittingWidthOfColumn(TSTMasterLayout *a1, uint64_t a2, double *a3)
{
  TSTMasterLayoutFittingWidthForColumnDirect(a1, a2);
  if (a3 && v4 > 0.0) {
    *a3 = v4;
  }
  return v4 > 0.0;
}

uint64_t TSTMasterLayoutRemoveFittingHeightForRow(void *a1, uint64_t a2)
{
  double v3 = (void *)[a1 widthHeightCache];

  return [v3 resetRowHeightsStartingWith:a2 andEndingWith:a2];
}

TSTStrokeRunArray *TSTMasterLayoutSetStrokeForGridColumn(TSTMasterLayout *a1, TSDStroke *a2, unsigned int a3, int a4, unsigned int a5, unsigned int a6)
{
  uint64_t result = TSTMasterLayoutGetStrokesForGridColumn(a1, a3, a4, 1);
  if (result)
  {
    uint64_t v10 = (uint64_t)result;
    TSTStrokeRunArrayInsertCustomStroke(result, a5, a6, a2);
    return (TSTStrokeRunArray *)TSTStrokeRunArrayUnlock(v10);
  }
  return result;
}

TSTStrokeRunArray *TSTMasterLayoutGetStrokesForGridColumn(TSTMasterLayout *a1, unsigned int a2, int a3, int a4)
{
  unsigned int v13 = a2;
  [(NSRecursiveLock *)a1->mStrokesLock lock];
  uint64_t v7 = 232;
  if (a3) {
    uint64_t v7 = 224;
  }
  uint64_t v8 = *(Class *)((char *)&a1->super.isa + v7);
  if (TSTMasterLayoutStrokeAdjustGridColumnForVisibility(a1, a3, &v13))
  {
    uint64_t v9 = v13;
    uint64_t v10 = (TSTStrokeRunArray *)[v8 objectAtIndex:v13];
    if (v10 == (TSTStrokeRunArray *)[MEMORY[0x263EFF9D0] null])
    {
      DefaultStrokesForGridColumn = TSTMasterLayoutGetDefaultStrokesForGridColumn(a1, v9, a3);
      uint64_t v10 = TSTStrokeRunArrayCopy((uint64_t)DefaultStrokesForGridColumn);
      TSTStrokeRunArrayUnlock((uint64_t)DefaultStrokesForGridColumn);
      [v8 replaceObjectAtIndex:v9 withObject:v10];
    }
    if (v10)
    {
      if (a4) {
        TSTStrokeRunArrayWriteLock((uint64_t)v10);
      }
      else {
        TSTStrokeRunArrayReadLock((uint64_t)v10);
      }
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  [(NSRecursiveLock *)a1->mStrokesLock unlock];
  return v10;
}

uint64_t TSTMasterLayoutStrokeAdjustGridColumnForVisibility(TSTMasterLayout *a1, int a2, unsigned int *a3)
{
  unint64_t v6 = *a3;
  uint64_t v7 = 232;
  if (a2) {
    uint64_t v7 = 224;
  }
  uint64_t v8 = *(Class *)((char *)&a1->super.isa + v7);
  if (a2)
  {
    if ([*(id *)((char *)&a1->super.isa + v7) count] > v6
      && [(TSTHiddenRowsColumnsCache *)[(TSTMasterLayout *)a1 hiddenRowsColumnsCache] isColumnHidden:v6])
    {
      LODWORD(v6) = [(TSTHiddenRowsColumnsCache *)[(TSTMasterLayout *)a1 hiddenRowsColumnsCache] nextVisibleColumn:v6];
    }
    unsigned int v9 = 255;
  }
  else
  {
    if (!v6) {
      goto LABEL_13;
    }
    uint64_t v10 = (v6 - 1);
    if ([(TSTHiddenRowsColumnsCache *)[(TSTMasterLayout *)a1 hiddenRowsColumnsCache] isColumnHidden:v10])
    {
      LODWORD(v6) = [(TSTHiddenRowsColumnsCache *)[(TSTMasterLayout *)a1 hiddenRowsColumnsCache] previousVisibleColumn:v10]+ 1;
    }
    unsigned int v9 = 256;
  }
  if (v6 >= v9) {
    return 0;
  }
LABEL_13:
  unint64_t v11 = [v8 count];
  uint64_t result = 0;
  char v13 = a2 ^ 1;
  if (v6) {
    char v13 = 0;
  }
  if ((v13 & 1) == 0 && v11 > v6)
  {
    if (a2 && [v8 count] - 1 == v6) {
      return 0;
    }
    *a3 = v6;
    return 1;
  }
  return result;
}

TSTStrokeRunArray *TSTMasterLayoutGetDefaultStrokesForGridColumn(TSTMasterLayout *a1, unsigned int a2, int a3)
{
  StrokeDefaults = TSTMasterLayoutGetStrokeDefaults(a1);
  if (![(TSTMasterLayout *)a1 emptyFilteredTable]
    && a1->mCachedNumberOfHeaderColumns
    && (![(TSTMasterLayout *)a1 emptyFilteredTable]
      ? (int mCachedNumberOfHeaderColumns = a1->mCachedNumberOfHeaderColumns)
      : (int mCachedNumberOfHeaderColumns = 0),
        mCachedNumberOfHeaderColumns == a2))
  {
    uint64_t v8 = TSTTableStrokeDefaultsForColumn((uint64_t)StrokeDefaults, a3 + a2);
    unsigned int v9 = v8;
    if ((a3 & 1) == 0)
    {
      TSTStrokeRunArrayWriteLock((uint64_t)v8);
      TSTStrokeRunArraySetEntireCustom((uint64_t)v9);
      TSTStrokeRunArrayUnlock((uint64_t)v9);
    }
  }
  else
  {
    unsigned int v9 = TSTTableStrokeDefaultsForColumn((uint64_t)StrokeDefaults, a2);
  }
  TSTStrokeRunArrayReadLock((uint64_t)v9);
  return v9;
}

TSTStrokeRunArray *TSTMasterLayoutGetMergedStrokesForGridColumn(TSTMasterLayout *a1, unsigned int a2)
{
  [(NSRecursiveLock *)a1->mStrokesLock lock];
  StrokesForGridColumn = TSTMasterLayoutGetStrokesForGridColumn(a1, a2, 1, 0);
  double v5 = TSTMasterLayoutGetStrokesForGridColumn(a1, a2, 0, 0);
  unint64_t v6 = TSTStrokeRunArrayMergeVerticalStrokes(StrokesForGridColumn, v5);
  if (StrokesForGridColumn) {
    TSTStrokeRunArrayUnlock((uint64_t)StrokesForGridColumn);
  }
  if (v5) {
    TSTStrokeRunArrayUnlock((uint64_t)v5);
  }
  [(NSRecursiveLock *)a1->mStrokesLock unlock];
  return v6;
}

TSTStrokeRunArray *TSTMasterLayoutSetStrokeForGridRow(TSTMasterLayout *a1, TSDStroke *a2, unsigned int a3, int a4, unsigned int a5, unsigned int a6)
{
  uint64_t result = TSTMasterLayoutGetStrokesForGridRow(a1, a3, a4, 1);
  if (result)
  {
    uint64_t v10 = (uint64_t)result;
    TSTStrokeRunArrayInsertCustomStroke(result, a5, a6, a2);
    return (TSTStrokeRunArray *)TSTStrokeRunArrayUnlock(v10);
  }
  return result;
}

TSTStrokeRunArray *TSTMasterLayoutGetStrokesForGridRow(TSTMasterLayout *a1, unsigned int a2, int a3, int a4)
{
  unsigned int v13 = a2;
  [(NSRecursiveLock *)a1->mStrokesLock lock];
  uint64_t v7 = 216;
  if (a3) {
    uint64_t v7 = 208;
  }
  uint64_t v8 = *(Class *)((char *)&a1->super.isa + v7);
  if (TSTMasterLayoutStrokeAdjustGridRowForVisibility(a1, a3, &v13))
  {
    uint64_t v9 = v13;
    uint64_t v10 = (TSTStrokeRunArray *)[v8 objectAtIndex:v13];
    if (v10 == (TSTStrokeRunArray *)[MEMORY[0x263EFF9D0] null])
    {
      uint64_t DefaultStrokesForGridRow = TSTMasterLayoutGetDefaultStrokesForGridRow(a1, v9, a3);
      uint64_t v10 = TSTStrokeRunArrayCopy(DefaultStrokesForGridRow);
      TSTStrokeRunArrayUnlock(DefaultStrokesForGridRow);
      [v8 replaceObjectAtIndex:v9 withObject:v10];
    }
    if (v10)
    {
      if (a4) {
        TSTStrokeRunArrayWriteLock((uint64_t)v10);
      }
      else {
        TSTStrokeRunArrayReadLock((uint64_t)v10);
      }
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  [(NSRecursiveLock *)a1->mStrokesLock unlock];
  return v10;
}

uint64_t TSTMasterLayoutStrokeAdjustGridRowForVisibility(TSTMasterLayout *a1, int a2, unsigned int *a3)
{
  unint64_t v6 = *a3;
  uint64_t v7 = 216;
  if (a2) {
    uint64_t v7 = 208;
  }
  uint64_t v8 = *(Class *)((char *)&a1->super.isa + v7);
  if (a2)
  {
    if ([*(id *)((char *)&a1->super.isa + v7) count] > v6
      && [(TSTHiddenRowsColumnsCache *)[(TSTMasterLayout *)a1 hiddenRowsColumnsCache] isRowHidden:(unsigned __int16)v6])
    {
      LODWORD(v6) = [(TSTHiddenRowsColumnsCache *)[(TSTMasterLayout *)a1 hiddenRowsColumnsCache] nextVisibleRow:(unsigned __int16)v6];
    }
    unsigned int v9 = 0xFFFF;
  }
  else
  {
    if (!v6) {
      goto LABEL_13;
    }
    uint64_t v10 = (unsigned __int16)(v6 - 1);
    if ([(TSTHiddenRowsColumnsCache *)[(TSTMasterLayout *)a1 hiddenRowsColumnsCache] isRowHidden:v10])
    {
      LODWORD(v6) = [(TSTHiddenRowsColumnsCache *)[(TSTMasterLayout *)a1 hiddenRowsColumnsCache] previousVisibleRow:v10]+ 1;
    }
    unsigned int v9 = 0x10000;
  }
  if (v6 >= v9) {
    return 0;
  }
LABEL_13:
  unint64_t v11 = [v8 count];
  uint64_t result = 0;
  char v13 = a2 ^ 1;
  if (v6) {
    char v13 = 0;
  }
  if ((v13 & 1) == 0 && v11 > v6)
  {
    if (a2 && [v8 count] - 1 == v6) {
      return 0;
    }
    *a3 = v6;
    return 1;
  }
  return result;
}

uint64_t TSTMasterLayoutGetDefaultStrokesForGridRow(TSTMasterLayout *a1, unsigned int a2, int a3)
{
  StrokeDefaults = TSTMasterLayoutGetStrokeDefaults(a1);
  if ([(TSTMasterLayout *)a1 emptyFilteredTable] || !a1->mCachedNumberOfHeaderRows)
  {
    int v8 = 0;
  }
  else
  {
    if ([(TSTMasterLayout *)a1 emptyFilteredTable]) {
      int mCachedNumberOfHeaderRows = 0;
    }
    else {
      int mCachedNumberOfHeaderRows = a1->mCachedNumberOfHeaderRows;
    }
    if (mCachedNumberOfHeaderRows == a2)
    {
      a2 += a3;
      int v8 = a3 ^ 1;
    }
    else
    {
      int v8 = 0;
    }
  }
  if (![(TSTMasterLayout *)a1 emptyFilteredTable] && a1->mCachedNumberOfFooterRows)
  {
    int TableNumberOfRows = TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1);
    int v10 = [(TSTMasterLayout *)a1 emptyFilteredTable] ? 0 : a1->mCachedNumberOfFooterRows;
    if (a2 == TableNumberOfRows - v10) {
      a2 -= a3 ^ 1;
    }
  }
  unint64_t v11 = TSTTableStrokeDefaultsForRow((uint64_t)StrokeDefaults, a2);
  uint64_t v12 = (uint64_t)v11;
  if (v8)
  {
    TSTStrokeRunArrayWriteLock((uint64_t)v11);
    TSTStrokeRunArraySetEntireCustom(v12);
    TSTStrokeRunArrayUnlock(v12);
  }
  TSTStrokeRunArrayReadLock(v12);
  return v12;
}

TSTStrokeRunArray *TSTMasterLayoutGetMergedStrokesForGridRow(TSTMasterLayout *a1, unsigned int a2)
{
  [(NSRecursiveLock *)a1->mStrokesLock lock];
  StrokesForGridRow = TSTMasterLayoutGetStrokesForGridRow(a1, a2, 1, 0);
  double v5 = TSTMasterLayoutGetStrokesForGridRow(a1, a2, 0, 0);
  unint64_t v6 = TSTStrokeRunArrayMergeHorizontalStrokes(StrokesForGridRow, v5);
  if (StrokesForGridRow) {
    TSTStrokeRunArrayUnlock((uint64_t)StrokesForGridRow);
  }
  if (v5) {
    TSTStrokeRunArrayUnlock((uint64_t)v5);
  }
  [(NSRecursiveLock *)a1->mStrokesLock unlock];
  return v6;
}

TSTStrokeRunArray *TSTMasterLayoutSetStrokesForCellID(TSTMasterLayout *a1, int a2, TSDStroke *a3, TSDStroke *a4, TSDStroke *a5, TSDStroke *a6)
{
  uint64_t result = (TSTStrokeRunArray *)[MEMORY[0x263EFF9D0] null];
  char v13 = (TSDStroke *)result;
  if (result != (TSTStrokeRunArray *)a3) {
    uint64_t result = TSTMasterLayoutSetStrokeForGridRow(a1, a3, (unsigned __int16)a2, 1, BYTE2(a2), BYTE2(a2) + 1);
  }
  if (v13 != a4) {
    uint64_t result = TSTMasterLayoutSetStrokeForGridRow(a1, a4, (unsigned __int16)a2 + 1, 0, BYTE2(a2), BYTE2(a2) + 1);
  }
  if (v13 != a6) {
    uint64_t result = TSTMasterLayoutSetStrokeForGridColumn(a1, a6, BYTE2(a2), 1, (unsigned __int16)a2, (unsigned __int16)a2 + 1);
  }
  if (v13 != a5)
  {
    return TSTMasterLayoutSetStrokeForGridColumn(a1, a5, BYTE2(a2) + 1, 0, (unsigned __int16)a2, (unsigned __int16)a2 + 1);
  }
  return result;
}

uint64_t TSTMasterLayoutSetStrokesValidForRange(TSTMasterLayout *a1, unint64_t a2)
{
  unsigned __int8 v4 = BYTE2(a2);
  unint64_t v5 = HIDWORD(a2);
  [(NSRecursiveLock *)a1->mStrokesLock lock];
  unint64_t v6 = [(NSMutableArray *)a1->mTopRowStrokes count];
  unint64_t v27 = [(NSMutableArray *)a1->mLeftColumnStrokes count];
  uint64_t v7 = BYTE2(a2);
  unsigned int v8 = (v5 + BYTE2(a2) - 1);
  unint64_t v9 = HIWORD(a2);
  if (v8 >= v4)
  {
    unint64_t v10 = 0;
    unsigned int v28 = v8 + 1;
    do
    {
      if ((TSTMasterLayoutIsGridRowHidden(a1, (unsigned __int16)a2 + v10) & 1) == 0
        && v6 > (unsigned __int16)a2 + v10)
      {
        if (v10 < v9)
        {
          StrokesForGridRow = TSTMasterLayoutGetStrokesForGridRow(a1, (unsigned __int16)a2 + v10, 1, 1);
          if (StrokesForGridRow)
          {
            uint64_t v12 = (uint64_t)StrokesForGridRow;
            TSTStrokeRunArraySetValid((uint64_t)StrokesForGridRow, BYTE2(a2), v28);
            TSTStrokeRunArrayUnlock(v12);
          }
        }
        if (v10)
        {
          char v13 = TSTMasterLayoutGetStrokesForGridRow(a1, (unsigned __int16)a2 + v10, 0, 1);
          if (v13)
          {
            uint64_t v14 = (uint64_t)v13;
            TSTStrokeRunArraySetValid((uint64_t)v13, BYTE2(a2), v28);
            TSTStrokeRunArrayUnlock(v14);
          }
        }
      }
      ++v10;
    }
    while (v9 + 1 != v10);
  }
  unsigned int v15 = (unsigned __int16)(a2 + HIWORD(a2) - 1);
  if (v15 >= (unsigned __int16)a2)
  {
    unint64_t v16 = 0;
    unsigned int v17 = (unsigned __int16)a2;
    unsigned int v18 = v15 + 1;
    unint64_t v19 = WORD2(a2);
    uint64_t v20 = WORD2(a2) + 1;
    do
    {
      if ((TSTMasterLayoutIsGridColumnHidden(a1, (int)v7 + (int)v16) & 1) == 0 && v27 > v7 + v16)
      {
        if (v16 < v19)
        {
          StrokesForGridColumn = TSTMasterLayoutGetStrokesForGridColumn(a1, (int)v7 + (int)v16, 1, 1);
          if (StrokesForGridColumn)
          {
            uint64_t v22 = (uint64_t)StrokesForGridColumn;
            TSTStrokeRunArraySetValid((uint64_t)StrokesForGridColumn, v17, v18);
            TSTStrokeRunArrayUnlock(v22);
          }
        }
        if (v16)
        {
          double v23 = TSTMasterLayoutGetStrokesForGridColumn(a1, (int)v7 + (int)v16, 0, 1);
          if (v23)
          {
            uint64_t v24 = (uint64_t)v23;
            TSTStrokeRunArraySetValid((uint64_t)v23, v17, v18);
            TSTStrokeRunArrayUnlock(v24);
          }
        }
      }
      ++v16;
    }
    while (v20 != v16);
  }
  mStrokesLocuint64_t k = a1->mStrokesLock;

  return [(NSRecursiveLock *)mStrokesLock unlock];
}

uint64_t TSTMasterLayoutIsGridRowHidden(void *a1, unsigned int a2)
{
  TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1);
  __int16 TableNumberOfRows = TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1);
  if (a2) {
    int v5 = objc_msgSend((id)objc_msgSend(a1, "hiddenRowsColumnsCache"), "isRowHidden:", (unsigned __int16)(a2 - 1));
  }
  else {
    int v5 = 1;
  }
  if (a2 <= (unsigned __int16)(TableNumberOfRows - 1)) {
    int v6 = objc_msgSend((id)objc_msgSend(a1, "hiddenRowsColumnsCache"), "isRowHidden:", (unsigned __int16)a2);
  }
  else {
    int v6 = 1;
  }
  return v5 & v6;
}

uint64_t TSTMasterLayoutIsGridColumnHidden(void *a1, unsigned int a2)
{
  Tableuint64_t NumberOfColumns = TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1);
  TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1);
  if (a2) {
    int v5 = objc_msgSend((id)objc_msgSend(a1, "hiddenRowsColumnsCache"), "isColumnHidden:", (a2 - 1));
  }
  else {
    int v5 = 1;
  }
  if (a2 <= (TableNumberOfColumns - 1)) {
    int v6 = objc_msgSend((id)objc_msgSend(a1, "hiddenRowsColumnsCache"), "isColumnHidden:", a2);
  }
  else {
    int v6 = 1;
  }
  return v5 & v6;
}

TSTMasterLayout *TSTMasterLayoutGetStrokesForCellID(TSTMasterLayout *result, int a2, void *a3, void *a4, void *a5, void *a6)
{
  unint64_t v10 = result;
  if (a3)
  {
    MergedStrokesForGridRow = (unsigned int *)TSTMasterLayoutGetMergedStrokesForGridRow(result, (unsigned __int16)a2);
    char v13 = TSTStrokeRunArrayLookupStroke(MergedStrokesForGridRow, BYTE2(a2));
    if (v13) {
      *a3 = *((id *)v13 + 1);
    }
    uint64_t result = (TSTMasterLayout *)TSTStrokeRunArrayUnlock((uint64_t)MergedStrokesForGridRow);
  }
  if (a5)
  {
    uint64_t v14 = (unsigned int *)TSTMasterLayoutGetMergedStrokesForGridRow(v10, (unsigned __int16)a2 + 1);
    unsigned int v15 = TSTStrokeRunArrayLookupStroke(v14, BYTE2(a2));
    if (v15) {
      *a5 = *((id *)v15 + 1);
    }
    uint64_t result = (TSTMasterLayout *)TSTStrokeRunArrayUnlock((uint64_t)v14);
  }
  if (a4)
  {
    MergedStrokesForGridColumn = (unsigned int *)TSTMasterLayoutGetMergedStrokesForGridColumn(v10, BYTE2(a2));
    unsigned int v17 = TSTStrokeRunArrayLookupStroke(MergedStrokesForGridColumn, (unsigned __int16)a2);
    if (v17) {
      *a4 = *((id *)v17 + 1);
    }
    uint64_t result = (TSTMasterLayout *)TSTStrokeRunArrayUnlock((uint64_t)MergedStrokesForGridColumn);
  }
  if (a6)
  {
    unsigned int v18 = (unsigned int *)TSTMasterLayoutGetMergedStrokesForGridColumn(v10, BYTE2(a2) + 1);
    unint64_t v19 = TSTStrokeRunArrayLookupStroke(v18, (unsigned __int16)a2);
    if (v19) {
      *a6 = *((id *)v19 + 1);
    }
    return (TSTMasterLayout *)TSTStrokeRunArrayUnlock((uint64_t)v18);
  }
  return result;
}

uint64_t TSTMasterLayoutGetStrokesForCellRange(TSTMasterLayout *a1, unint64_t a2, id *a3, id *a4, id *a5, id *a6)
{
  if (HIDWORD(a2) != 65537 || (unsigned __int16)a2 == 0xFFFFLL || (a2 & 0xFF0000) == 0xFF0000)
  {
    id v32 = 0;
    id v33 = 0;
    id v30 = 0;
    id v31 = 0;
    TSTMasterLayoutGetStrokesForCellID(a1, a2 & 0xFFFFFF, a3, a4, 0, 0);
    int v13 = (a2 + ((a2 >> 16) & 0xFF0000) + 16711680) & 0xFF0000;
    uint64_t result = (uint64_t)TSTMasterLayoutGetStrokesForCellID(a1, v13 | (unsigned __int16)(a2 + HIWORD(a2) - 1), 0, 0, a5, a6);
    if ((unint64_t)a3 | (unint64_t)a6) {
      uint64_t result = (uint64_t)TSTMasterLayoutGetStrokesForCellID(a1, v13 | (unsigned __int16)a2, &v33, 0, 0, &v30);
    }
    if ((unint64_t)a4 | (unint64_t)a5) {
      uint64_t result = (uint64_t)TSTMasterLayoutGetStrokesForCellID(a1, (unsigned __int16)(a2 + HIWORD(a2) - 1) | a2 & 0xFF0000, 0, &v32, &v31, 0);
    }
    if (a3 && v33)
    {
      double v14 = 0.0;
      double v15 = 0.0;
      if (*a3 && ([*a3 empty] & 1) == 0)
      {
        [*a3 width];
        double v15 = v16;
      }
      uint64_t result = objc_msgSend(v33, "empty", v30);
      if ((result & 1) == 0)
      {
        uint64_t result = [v33 width];
        double v14 = v17;
      }
      if (v15 < v14) {
        *a3 = v33;
      }
    }
    if (a4 && v32)
    {
      double v18 = 0.0;
      double v19 = 0.0;
      if (*a4 && ([*a4 empty] & 1) == 0)
      {
        [*a4 width];
        double v19 = v20;
      }
      uint64_t result = objc_msgSend(v32, "empty", v30);
      if ((result & 1) == 0)
      {
        uint64_t result = [v32 width];
        double v18 = v21;
      }
      if (v19 < v18) {
        *a4 = v32;
      }
    }
    if (a5 && v31)
    {
      double v22 = 0.0;
      double v23 = 0.0;
      if (*a5 && ([*a5 empty] & 1) == 0)
      {
        [*a5 width];
        double v23 = v24;
      }
      uint64_t result = objc_msgSend(v31, "empty", v30);
      if ((result & 1) == 0)
      {
        uint64_t result = [v31 width];
        double v22 = v25;
      }
      if (v23 < v22) {
        *a5 = v31;
      }
    }
    if (a6 && v30)
    {
      double v26 = 0.0;
      double v27 = 0.0;
      if (*a6 && ([*a6 empty] & 1) == 0)
      {
        [*a6 width];
        double v27 = v28;
      }
      uint64_t result = objc_msgSend(v30, "empty", v30);
      if ((result & 1) == 0)
      {
        uint64_t result = [v30 width];
        double v26 = v29;
      }
      if (v27 < v26) {
        *a6 = v30;
      }
    }
  }
  else
  {
    return (uint64_t)TSTMasterLayoutGetStrokesForCellID(a1, a2, a3, a4, a5, a6);
  }
  return result;
}

double TSTMasterLayoutContentSizeForCellRange(TSTMasterLayout *a1, unint64_t a2, char a3)
{
  double v6 = 0.0;
  if ((a2 & 0xFFFF00000000) != 0) {
    double v6 = TSTMasterLayoutContentWidthForCellRange(a1, a2, a3);
  }
  if (HIWORD(a2)) {
    TSTMasterLayoutContentHeightForCellRange(a1, a2, a3);
  }
  return v6;
}

double TSTMasterLayoutContentWidthForCellRange(TSTMasterLayout *a1, unint64_t a2, char a3)
{
  unsigned int v5 = HIDWORD(a2) + WORD1(a2) + 255;
  double v6 = 0.0;
  if (BYTE2(a2) <= (BYTE4(a2) + BYTE2(a2) - 1))
  {
    unint64_t v8 = a2 >> 16;
    do
    {
      double v6 = v6 + TSTMasterLayoutWidthOfColumn((uint64_t)a1, v8, a3, 0, 1);
      LODWORD(v8) = v8 + 1;
    }
    while (v8 <= v5);
  }
  unsigned int v9 = (unsigned __int16)a2;
  unsigned int v10 = (unsigned __int16)(a2 + HIWORD(a2) - 1) + 1;
  double v11 = TSTMasterLayoutStrokeWidthOfGridColumn(a1, BYTE2(a2), (unsigned __int16)a2, v10);
  Tableuint64_t NumberOfColumns = v5 + 1;
  if (TableNumberOfColumns >= TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1)) {
    Tableuint64_t NumberOfColumns = TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1);
  }
  return fmax(v6 - v11 * 0.5 - TSTMasterLayoutStrokeWidthOfGridColumn(a1, TableNumberOfColumns, v9, v10) * 0.5, 0.0);
}

double TSTMasterLayoutContentHeightForCellRange(TSTMasterLayout *a1, unint64_t a2, char a3)
{
  int v5 = a2 + HIWORD(a2) - 1;
  unsigned int v6 = (unsigned __int16)(a2 + HIWORD(a2) - 1);
  double v7 = 0.0;
  if (v6 >= (unsigned __int16)a2)
  {
    int v9 = a2;
    do
      double v7 = v7 + TSTMasterLayoutHeightOfRow(a1, (unsigned __int16)v9++, a3, 0, 1, 1);
    while ((unsigned __int16)v9 <= (unsigned __int16)v5);
  }
  unsigned int v10 = BYTE2(a2);
  if (BYTE2(a2) <= (BYTE4(a2) + BYTE2(a2) - 1)) {
    int v11 = (BYTE4(a2) + BYTE2(a2) - 1);
  }
  else {
    int v11 = BYTE2(a2);
  }
  unsigned int v12 = v11 + 1;
  double v13 = TSTMasterLayoutStrokeHeightOfGridRow(a1, (unsigned __int16)a2, BYTE2(a2), v11 + 1);
  unsigned int TableNumberOfRows = v6 + 1;
  if (v6 + 1 >= TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1)) {
    unsigned int TableNumberOfRows = TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1);
  }
  return fmax(v7 - v13 * 0.5 - TSTMasterLayoutStrokeHeightOfGridRow(a1, TableNumberOfRows, v10, v12) * 0.5, 0.0);
}

uint64_t TSTMasterLayoutUpdateStrokesForCell(TSTMasterLayout *a1, uint64_t a2, unsigned int a3)
{
  unsigned int v7 = [(TSTMasterLayout *)a1 modelCellIDForStrokesOfLayoutCellID:a3];
  uint64_t result = [(TSTHiddenRowsColumnsCache *)[(TSTMasterLayout *)a1 hiddenRowsColumnsCache] isRowHidden:(unsigned __int16)a3];
  if ((result & 1) == 0)
  {
    uint64_t result = [(TSTHiddenRowsColumnsCache *)[(TSTMasterLayout *)a1 hiddenRowsColumnsCache] isColumnHidden:BYTE2(a3)];
    if ((result & 1) == 0)
    {
      double v25 = 0;
      double v26 = 0;
      double v23 = 0;
      double v24 = 0;
      unint64_t v9 = TSTTableMergeRangeAtCellID((uint64_t)[(TSTMasterLayout *)a1 tableModel], v7);
      if (![(TSTMasterLayout *)a1 isDynamicallyChangingRowCount]) {
        goto LABEL_36;
      }
      unint64_t v10 = [(TSTTableModel *)[(TSTMasterLayout *)a1 tableModel] bodyRowRange];
      if (!HIWORD(v10)) {
        goto LABEL_36;
      }
      if ((v10 & 0xFFFF00000000) == 0) {
        goto LABEL_36;
      }
      if (!HIWORD(v9)) {
        goto LABEL_36;
      }
      if ((v9 & 0xFFFF00000000) == 0) {
        goto LABEL_36;
      }
      if ((unsigned __int16)v10 > (unsigned __int16)v9) {
        goto LABEL_36;
      }
      if ((unsigned __int16)(v10 + HIWORD(v10) - 1) < (unsigned __int16)v9) {
        goto LABEL_36;
      }
      if (BYTE2(v10) > BYTE2(v9)) {
        goto LABEL_36;
      }
      unsigned int v11 = (BYTE4(v10) + BYTE2(v10) - 1);
      if (v11 < BYTE2(v9)
        || v11 < (BYTE4(v9) + BYTE2(v9) - 1)
        || (unsigned __int16)(v10 + HIWORD(v10) - 1) < (unsigned __int16)(v9 + HIWORD(v9) - 1))
      {
        goto LABEL_36;
      }
      uint64_t v12 = [(TSTTableModel *)[(TSTMasterLayout *)a1 tableModel] bodyRowRange];
      __int16 v13 = [(TSTMasterLayout *)a1 dynamicRowAdjustment];
      unint64_t v14 = 0;
      uint64_t v15 = 16711680;
      uint64_t v16 = 0xFFFFLL;
      if ((_WORD)v9 != 0xFFFF)
      {
        unint64_t v17 = 0;
        if ((v9 & 0xFF0000) == 0xFF0000) {
          goto LABEL_35;
        }
        unint64_t v14 = 0;
        uint64_t v15 = 16711680;
        uint64_t v16 = 0xFFFFLL;
        if ((_WORD)v12 != 0xFFFF)
        {
          unint64_t v17 = 0;
          if ((v12 & 0xFF0000) != 0xFF0000)
          {
            unint64_t v14 = 0;
            uint64_t v15 = 16711680;
            uint64_t v16 = 0xFFFFLL;
            if ((v12 & 0xFFFF00000000) != 0)
            {
              __int16 v18 = v13 + HIWORD(v12);
              unint64_t v17 = 0;
              if (v13 + HIWORD(v12))
              {
                uint64_t v16 = 0;
                unsigned int v19 = BYTE2(v12);
                if (BYTE2(v9) > BYTE2(v12)) {
                  unsigned int v19 = BYTE2(v9);
                }
                if ((unsigned __int16)v9 <= (unsigned __int16)v12) {
                  uint64_t v20 = (unsigned __int16)v12;
                }
                else {
                  uint64_t v20 = (unsigned __int16)v9;
                }
                if ((BYTE4(v9) + BYTE2(v9) - 1) >= (BYTE4(v12) + BYTE2(v12) - 1)) {
                  unsigned int v21 = (BYTE4(v12) + BYTE2(v12) - 1);
                }
                else {
                  unsigned int v21 = (BYTE4(v9) + BYTE2(v9) - 1);
                }
                if ((unsigned __int16)(v9 + HIWORD(v9) - 1) >= (unsigned __int16)(v12 + v18 - 1)) {
                  unsigned int v22 = (unsigned __int16)(v12 + v18 - 1);
                }
                else {
                  unsigned int v22 = (unsigned __int16)(v9 + HIWORD(v9) - 1);
                }
                uint64_t v15 = 0;
                unint64_t v14 = 0;
                unint64_t v17 = 0;
                if (v20 <= v22 && v19 <= v21)
                {
                  unint64_t v17 = ((unint64_t)(v22 - v20) << 48) + 0x1000000000000;
                  unint64_t v14 = (unint64_t)(unsigned __int16)(v21 - v19 + 1) << 32;
                  uint64_t v15 = v19 << 16;
                  uint64_t v16 = v20;
                }
              }
              goto LABEL_35;
            }
            goto LABEL_34;
          }
LABEL_35:
          unint64_t v9 = v15 | v17 | v16 | v14;
LABEL_36:
          TSTTableGetStrokesForCellIDWithMergeRange((uint64_t)[(TSTMasterLayout *)a1 tableModel], v7, v9, (uint64_t *)&v26, (uint64_t *)&v24, (uint64_t *)&v25, (uint64_t *)&v23, a2);
          return (uint64_t)TSTMasterLayoutSetStrokesForCellID(a1, a3, v26, v25, v23, v24);
        }
      }
LABEL_34:
      unint64_t v17 = 0;
      goto LABEL_35;
    }
  }
  return result;
}

uint64_t TSTMasterLayoutPreviousVisibleRow(void *a1, uint64_t a2)
{
  double v3 = (void *)[a1 hiddenRowsColumnsCache];

  return [v3 previousVisibleRow:a2];
}

uint64_t TSTMasterLayoutPreviousVisibleColumn(void *a1, uint64_t a2)
{
  double v3 = (void *)[a1 hiddenRowsColumnsCache];

  return [v3 previousVisibleColumn:a2];
}

uint64_t TSTMasterLayoutMergeRangeAtCellID(void *a1, unsigned int a2)
{
  uint64_t v5 = 0xFFFFFFLL;
  if ([a1 dynamicContentDelegate]
    && ([a1 dynamicContentDelegate], (objc_opt_respondsToSelector() & 1) != 0)
    && objc_msgSend((id)objc_msgSend(a1, "dynamicContentDelegate"), "mergeRange:forCellID:", &v5, a2))
  {
    return v5;
  }
  else
  {
    return TSTTableMergeRangeAtCellID([a1 tableModel], a2);
  }
}

uint64_t TSTMasterLayoutIsRowHiddenWorker(void *a1, uint64_t a2)
{
  char v4 = [a1 isDynamicallyRevealingRowsCols:0 rowColIndex:a2];
  uint64_t result = 0;
  if ((v4 & 1) == 0)
  {
    if ([a1 isDynamicallyHidingRowsCols:0 rowColIndex:a2])
    {
      return 1;
    }
    else
    {
      char v6 = [a1 emptyFilteredTable];
      if (!a2 && (v6 & 1) != 0 || ([a1 processHiddenRowsForExport] & 1) != 0)
      {
        return 0;
      }
      else
      {
        uint64_t v7 = [a1 tableModel];
        return TSTHidingActionForRow(v7, a2);
      }
    }
  }
  return result;
}

uint64_t TSTMasterLayoutIsRowUserHidden(void *a1, uint64_t a2)
{
  double v3 = (void *)[a1 hiddenRowsColumnsCache];

  return [v3 isRowUserHidden:a2];
}

uint64_t TSTMasterLayoutIsColumnHiddenWorker(void *a1, uint64_t a2)
{
  if ([a1 isDynamicallyRevealingRowsCols:1 rowColIndex:a2]) {
    return 0;
  }
  uint64_t v4 = 1;
  if ([a1 isDynamicallyHidingRowsCols:1 rowColIndex:a2]) {
    return v4;
  }
  uint64_t v6 = [a1 tableModel];

  return TSTHidingActionForColumn(v6, a2);
}

BOOL TSTMasterLayoutIsEntireCellRangeHidden(void *a1, unint64_t a2)
{
  return objc_msgSend((id)objc_msgSend(a1, "hiddenRowsColumnsCache"), "numberRowsHiddenInCellRange:", a2) == HIWORD(a2)
      || objc_msgSend((id)objc_msgSend(a1, "hiddenRowsColumnsCache"), "numberColumnsHiddenInCellRange:", a2) == WORD2(a2);
}

uint64_t TSTMasterLayoutIsAnyPartOfCellRangeHidden(void *a1, unint64_t a2)
{
  uint64_t result = 0;
  if ((_WORD)a2 != 0xFFFF && (a2 & 0xFF0000) != 0xFF0000)
  {
    uint64_t result = 0;
    if (HIWORD(a2))
    {
      if ((a2 & 0xFFFF00000000) != 0)
      {
        if (objc_msgSend((id)objc_msgSend(a1, "hiddenRowsColumnsCache"), "anyRowsHiddenInCellRange:", a2))
        {
          return 1;
        }
        else
        {
          uint64_t v5 = (void *)[a1 hiddenRowsColumnsCache];
          return [v5 anyColumnsHiddenInCellRange:a2];
        }
      }
    }
  }
  return result;
}

uint64_t TSTMasterLayoutIsRowHiddenInCellRange(void *a1, unint64_t a2)
{
  if ((_WORD)a2 == 0xFFFF || (a2 & 0xFF0000) == 0xFF0000 || !HIWORD(a2) || (a2 & 0xFFFF00000000) == 0) {
    return 0;
  }
  double v3 = (void *)[a1 hiddenRowsColumnsCache];

  return [v3 anyRowsHiddenInCellRange:a2];
}

uint64_t TSTMasterLayoutIsRowUserHiddenInCellRange(void *a1, unint64_t a2)
{
  if ((_WORD)a2 == 0xFFFF || (a2 & 0xFF0000) == 0xFF0000 || !HIWORD(a2) || (a2 & 0xFFFF00000000) == 0) {
    return 0;
  }
  double v3 = (void *)[a1 hiddenRowsColumnsCache];

  return [v3 anyRowsUserHiddenInCellRange:a2];
}

uint64_t TSTMasterLayoutIsColumnHiddenInCellRange(void *a1, unint64_t a2)
{
  if ((_WORD)a2 == 0xFFFF || (a2 & 0xFF0000) == 0xFF0000 || !HIWORD(a2) || (a2 & 0xFFFF00000000) == 0) {
    return 0;
  }
  double v3 = (void *)[a1 hiddenRowsColumnsCache];

  return [v3 anyColumnsHiddenInCellRange:a2];
}

uint64_t TSTMasterLayoutNextVisibleRow(void *a1, uint64_t a2)
{
  double v3 = (void *)[a1 hiddenRowsColumnsCache];

  return [v3 nextVisibleRow:a2];
}

uint64_t TSTMasterLayoutNextVisibleColumn(void *a1, uint64_t a2)
{
  double v3 = (void *)[a1 hiddenRowsColumnsCache];

  return [v3 nextVisibleColumn:a2];
}

double TSTMasterLayoutDynamicResizeSave(uint64_t a1, unsigned char *a2, void *a3, void *a4, unsigned char *a5, void *a6, double *a7)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
LABEL_12:
    uint64_t v20 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v21 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTMasterLayoutDynamicResizeSave(TSTMasterLayout *, BOOL *, TSTCellRange *, CGFloat *, BOOL *, TSTCellRange *, CGFloat *)");
    objc_msgSend(v20, "handleFailureInFunction:file:lineNumber:description:", v21, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTMasterLayout.mm"), 3949, @"invalid nil value for '%s'", "resizingColumns");
    if (a3) {
      goto LABEL_4;
    }
    goto LABEL_13;
  }
  __int16 v18 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
  uint64_t v19 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTMasterLayoutDynamicResizeSave(TSTMasterLayout *, BOOL *, TSTCellRange *, CGFloat *, BOOL *, TSTCellRange *, CGFloat *)");
  objc_msgSend(v18, "handleFailureInFunction:file:lineNumber:description:", v19, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTMasterLayout.mm"), 3946, @"invalid nil value for '%s'", "masterLayout");
  if (!a2) {
    goto LABEL_12;
  }
LABEL_3:
  if (a3) {
    goto LABEL_4;
  }
LABEL_13:
  unsigned int v22 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
  uint64_t v23 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTMasterLayoutDynamicResizeSave(TSTMasterLayout *, BOOL *, TSTCellRange *, CGFloat *, BOOL *, TSTCellRange *, CGFloat *)");
  objc_msgSend(v22, "handleFailureInFunction:file:lineNumber:description:", v23, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTMasterLayout.mm"), 3950, @"invalid nil value for '%s'", "resizeColumnRange");
LABEL_4:
  if (!a4)
  {
    __int16 v13 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v14 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTMasterLayoutDynamicResizeSave(TSTMasterLayout *, BOOL *, TSTCellRange *, CGFloat *, BOOL *, TSTCellRange *, CGFloat *)");
    objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTMasterLayout.mm"), 3951, @"invalid nil value for '%s'", "resizeColumnAdjustment");
  }
  *a2 = *(unsigned char *)(a1 + 450);
  *a3 = *(void *)(a1 + 452);
  *a4 = *(void *)(a1 + 464);
  if (!a5)
  {
    uint64_t v15 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v16 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTMasterLayoutDynamicResizeSave(TSTMasterLayout *, BOOL *, TSTCellRange *, CGFloat *, BOOL *, TSTCellRange *, CGFloat *)");
    objc_msgSend(v15, "handleFailureInFunction:file:lineNumber:description:", v16, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTMasterLayout.mm"), 3957, @"invalid nil value for '%s'", "resizingRows");
  }
  if (!a6)
  {
    double v24 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v25 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTMasterLayoutDynamicResizeSave(TSTMasterLayout *, BOOL *, TSTCellRange *, CGFloat *, BOOL *, TSTCellRange *, CGFloat *)");
    objc_msgSend(v24, "handleFailureInFunction:file:lineNumber:description:", v25, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTMasterLayout.mm"), 3958, @"invalid nil value for '%s'", "resizeRowRange");
    if (a7) {
      goto LABEL_10;
    }
LABEL_15:
    double v26 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v27 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTMasterLayoutDynamicResizeSave(TSTMasterLayout *, BOOL *, TSTCellRange *, CGFloat *, BOOL *, TSTCellRange *, CGFloat *)");
    objc_msgSend(v26, "handleFailureInFunction:file:lineNumber:description:", v27, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTMasterLayout.mm"), 3959, @"invalid nil value for '%s'", "resizeRowAdjustment");
    goto LABEL_10;
  }
  if (!a7) {
    goto LABEL_15;
  }
LABEL_10:
  *a5 = *(unsigned char *)(a1 + 472);
  *a6 = *(void *)(a1 + 474);
  double result = *(double *)(a1 + 488);
  *a7 = result;
  return result;
}

uint64_t TSTMasterLayoutDynamicResizeRestore(uint64_t result, char a2, uint64_t a3, char a4, uint64_t a5, double a6, double a7)
{
  uint64_t v13 = result;
  uint64_t v14 = (void *)(result + 452);
  if (!result)
  {
    uint64_t v15 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v16 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTMasterLayoutDynamicResizeRestore(TSTMasterLayout *, BOOL, TSTCellRange, CGFloat, BOOL, TSTCellRange, CGFloat)");
    double result = objc_msgSend(v15, "handleFailureInFunction:file:lineNumber:description:", v16, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTMasterLayout.mm"), 3970, @"invalid nil value for '%s'", "masterLayout");
  }
  *(unsigned char *)(v13 + 450) = a2;
  *uint64_t v14 = a3;
  *(double *)(v13 + 464) = a6;
  *(unsigned char *)(v13 + 472) = a4;
  *(void *)((char *)v14 + 22) = a5;
  *(double *)(v13 + 488) = a7;
  return result;
}

void sub_2237C5D08(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t TSTMasterLayoutLock(uint64_t a1)
{
  return [*(id *)(a1 + 256) lock];
}

uint64_t TSTMasterLayoutStrokesArrayRangeUpdate(TSTMasterLayout *a1)
{
  [(NSRecursiveLock *)a1->mStrokesLock lock];
  Tableuint64_t NumberOfColumns = TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1);
  uint64_t v3 = TableNumberOfColumns + 1;
  unsigned int v4 = [(NSMutableArray *)a1->mLeftColumnStrokes count];
  unsigned int TableNumberOfRows = TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1);
  uint64_t v6 = TableNumberOfRows + 1;
  unsigned int v7 = [(NSMutableArray *)a1->mTopRowStrokes count];
  mDefaultStrokes = a1->mDefaultStrokes;
  if (mDefaultStrokes)
  {
    if (v3 != v4 || v6 != v7)
    {
      TSTTableStrokeDefaultsRelease((uint64_t)mDefaultStrokes);
      a1->mDefaultStrokes = 0;
    }
  }
  if (TableNumberOfColumns < v4)
  {
    unint64_t v32 = 0;
    uint64_t v29 = 0xFFFFLL;
    uint64_t v30 = 0;
    unint64_t v12 = 16711680;
  }
  else
  {
    if (v3 != v4)
    {
      if (v3 - v4 <= 1) {
        int v10 = 1;
      }
      else {
        int v10 = v3 - v4;
      }
      do
      {
        -[NSMutableArray addObject:](a1->mLeftColumnStrokes, "addObject:", [MEMORY[0x263EFF9D0] null]);
        -[NSMutableArray addObject:](a1->mRightColumnStrokes, "addObject:", [MEMORY[0x263EFF9D0] null]);
        --v10;
      }
      while (v10);
    }
    __int16 v11 = TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1);
    uint64_t v29 = 0;
    uint64_t v30 = TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1) << 48;
    unint64_t v32 = (unint64_t)(unsigned __int16)(v11 - (v4 - 1)) << 32;
    unint64_t v12 = (unint64_t)(v4 - 1) << 16;
  }
  unint64_t v35 = v12;
  if (TableNumberOfRows >= v7)
  {
    if (v6 != v7)
    {
      if (v6 - v7 <= 1) {
        int v14 = 1;
      }
      else {
        int v14 = v6 - v7;
      }
      do
      {
        -[NSMutableArray addObject:](a1->mTopRowStrokes, "addObject:", [MEMORY[0x263EFF9D0] null]);
        -[NSMutableArray addObject:](a1->mBottomRowStrokes, "addObject:", [MEMORY[0x263EFF9D0] null]);
        --v14;
      }
      while (v14);
    }
    uint64_t v34 = TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1) << 32;
    unint64_t v31 = (unint64_t)(TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1) - ((unsigned __int16)v7 - 1)) << 48;
    uint64_t v13 = (unsigned __int16)(v7 - 1);
  }
  else
  {
    unint64_t v31 = 0;
    uint64_t v34 = 16711680;
    uint64_t v13 = 0xFFFFLL;
  }
  uint64_t v33 = v13;
  if (v3 < v4)
  {
    uint64_t v15 = 0;
    do
    {
      objc_opt_class();
      [(NSMutableArray *)a1->mTopRowStrokes objectAtIndex:v15];
      uint64_t v16 = TSUDynamicCast();
      if (v16)
      {
        uint64_t v17 = v16;
        TSTStrokeRunArrayWriteLock(v16);
        TSTStrokeRunArrayTruncate(v17, TableNumberOfColumns);
        TSTStrokeRunArrayUnlock(v17);
      }
      objc_opt_class();
      [(NSMutableArray *)a1->mBottomRowStrokes objectAtIndex:v15];
      uint64_t v18 = TSUDynamicCast();
      if (v18)
      {
        uint64_t v19 = v18;
        TSTStrokeRunArrayWriteLock(v18);
        TSTStrokeRunArrayTruncate(v19, TableNumberOfColumns);
        TSTStrokeRunArrayUnlock(v19);
      }
      ++v15;
    }
    while (v6 != v15);
    if (v3 != v4)
    {
      if (v4 - v3 <= 1) {
        int v20 = 1;
      }
      else {
        int v20 = v4 - v3;
      }
      do
      {
        [(NSMutableArray *)a1->mLeftColumnStrokes removeLastObject];
        [(NSMutableArray *)a1->mRightColumnStrokes removeLastObject];
        --v20;
      }
      while (v20);
    }
  }
  if (v6 < v7)
  {
    uint64_t v21 = 0;
    do
    {
      objc_opt_class();
      [(NSMutableArray *)a1->mLeftColumnStrokes objectAtIndex:v21];
      uint64_t v22 = TSUDynamicCast();
      if (v22)
      {
        uint64_t v23 = v22;
        TSTStrokeRunArrayWriteLock(v22);
        TSTStrokeRunArrayTruncate(v23, TableNumberOfRows);
        TSTStrokeRunArrayUnlock(v23);
      }
      objc_opt_class();
      [(NSMutableArray *)a1->mRightColumnStrokes objectAtIndex:v21];
      uint64_t v24 = TSUDynamicCast();
      if (v24)
      {
        uint64_t v25 = v24;
        TSTStrokeRunArrayWriteLock(v24);
        TSTStrokeRunArrayTruncate(v25, TableNumberOfRows);
        TSTStrokeRunArrayUnlock(v25);
      }
      ++v21;
    }
    while (v3 != v21);
    if (v6 != v7)
    {
      if (v7 - v6 <= 1) {
        int v26 = 1;
      }
      else {
        int v26 = v7 - v6;
      }
      do
      {
        [(NSMutableArray *)a1->mTopRowStrokes removeLastObject];
        [(NSMutableArray *)a1->mBottomRowStrokes removeLastObject];
        --v26;
      }
      while (v26);
    }
  }
  uint64_t result = [(NSRecursiveLock *)a1->mStrokesLock unlock];
  if (TableNumberOfColumns >= v4 && v35 != 16711680 && v32 && (v29 | v30 | v35 | v32) >> 48) {
    uint64_t result = TSTMasterLayoutInvalidateStrokeRange(a1);
  }
  if (v33 != 0xFFFF)
  {
    unint64_t v28 = v33 | v31 | v34;
    if ((v28 & 0xFF0000) != 0xFF0000 && (v34 & 0xFFFF00000000) != 0 && HIWORD(v28))
    {
      return TSTMasterLayoutInvalidateStrokeRange(a1);
    }
  }
  return result;
}

uint64_t TSTMasterLayoutUnlock(uint64_t a1)
{
  return [*(id *)(a1 + 256) unlock];
}

void sub_2237C6564(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2237C7840(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
}

void __Block_byref_object_copy__29(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__29(uint64_t a1)
{
}

double TSTMasterLayoutApplyMinimumHorizontalInset(double a1)
{
  return fmax(a1, 2.0);
}

TSTTableStrokeDefaults *TSTMasterLayoutGetStrokeDefaults(TSTMasterLayout *a1)
{
  uint64_t result = a1->mDefaultStrokes;
  if (!result)
  {
    uint64_t v3 = [(TSTMasterLayout *)a1 tableModel];
    Tableuint64_t NumberOfColumns = TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1);
    unsigned int TableNumberOfRows = TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1);
    if ([(TSTMasterLayout *)a1 emptyFilteredTable]) {
      int mCachedNumberOfHeaderColumns = 0;
    }
    else {
      int mCachedNumberOfHeaderColumns = a1->mCachedNumberOfHeaderColumns;
    }
    if ([(TSTMasterLayout *)a1 emptyFilteredTable]) {
      int mCachedNumberOfHeaderRows = 0;
    }
    else {
      int mCachedNumberOfHeaderRows = a1->mCachedNumberOfHeaderRows;
    }
    if ([(TSTMasterLayout *)a1 emptyFilteredTable]) {
      int mCachedNumberOfFooterRows = 0;
    }
    else {
      int mCachedNumberOfFooterRows = a1->mCachedNumberOfFooterRows;
    }
    uint64_t result = (TSTTableStrokeDefaults *)TSTTableStrokeDefaultsCreate(v3, TableNumberOfColumns, TableNumberOfRows, mCachedNumberOfHeaderColumns, mCachedNumberOfHeaderRows, mCachedNumberOfFooterRows);
    a1->mDefaultStrokes = result;
  }
  return result;
}

id TSTCellCopy(uint64_t a1, uint64_t a2)
{
  if (a1 && a2)
  {
    memcpy((void *)(a2 + 8), (const void *)(a1 + 8), 0x110uLL);
    goto LABEL_5;
  }
  if (a2)
  {
LABEL_5:
    int v3 = *(unsigned __int8 *)(a2 + 9);
    if (v3 == 3)
    {
      uint64_t v4 = 24;
    }
    else
    {
      if (v3 != 5)
      {
LABEL_10:
        char v6 = 0;
        goto LABEL_12;
      }
      uint64_t v4 = 16;
    }
    id v5 = *(id *)(a2 + v4);
    goto LABEL_10;
  }
  char v6 = 1;
LABEL_12:
  id v7 = *(id *)(a2 + 40);
  id v8 = *(id *)(a2 + 56);
  id v9 = *(id *)(a2 + 72);
  id v10 = *(id *)(a2 + 88);
  id result = (id)TSUFormatStructRetain();
  if ((v6 & 1) == 0)
  {
    id v12 = *(id *)(a2 + 152);
    id v13 = *(id *)(a2 + 168);
    id v14 = *(id *)(a2 + 200);
    id v15 = *(id *)(a2 + 184);
    id v16 = *(id *)(a2 + 248);
    id v17 = *(id *)(a2 + 232);
    id v18 = *(id *)(a2 + 216);
    return *(id *)(a2 + 264);
  }
  return result;
}

double TSTCellClear(uint64_t a1)
{
  if (a1)
  {
    int v2 = *(_DWORD *)(a1 + 8);
    if ((v2 & 0xFF00) == 0x300)
    {

      *(void *)(a1 + 24) = 0;
      *(_DWORD *)(a1 + 16) = 0;
      int v2 = *(_DWORD *)(a1 + 8);
    }
    if ((v2 & 0xFF00) == 0x500)
    {

      *(void *)(a1 + 16) = 0;
    }
  }
  int v3 = *(void **)(a1 + 72);
  if (v3)
  {

    *(void *)(a1 + 72) = 0;
  }
  uint64_t v4 = *(void **)(a1 + 88);
  if (v4)
  {

    *(void *)(a1 + 88) = 0;
  }
  id v5 = *(void **)(a1 + 40);
  if (v5)
  {

    *(void *)(a1 + 40) = 0;
  }
  char v6 = *(void **)(a1 + 56);
  if (v6)
  {

    *(void *)(a1 + 56) = 0;
  }
  TSUFormatStructRelease();

  *(void *)(a1 + 152) = 0;
  *(_DWORD *)(a1 + 144) = 0;

  *(void *)(a1 + 168) = 0;
  *(_DWORD *)(a1 + 160) = 0;

  *(void *)(a1 + 200) = 0;
  *(_DWORD *)(a1 + 192) = 0;

  *(void *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 176) = 0;

  *(void *)(a1 + 216) = 0;
  *(_DWORD *)(a1 + 208) = 0;

  *(void *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 240) = 0;

  *(void *)(a1 + 232) = 0;
  *(_DWORD *)(a1 + 224) = 0;

  double result = 0.0;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + ++*(_DWORD *)(this + 104) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  id v8 = (_OWORD *)(a1 + 8);
  v8[16] = 0u;
  void v8[4] = 0u;
  v8[5] = 0u;
  v8[2] = 0u;
  v8[3] = 0u;
  v8[1] = 0u;
  return result;
}

void TSTCellInflateFromStorageRef(uint64_t a1, unsigned __int8 *a2, id *a3)
{
  TSTCellClear(a1);
  TSTCellStorageToCell(a2, a1);
  if (a3)
  {
    TSTTableDataStoreResolveCellDataIDs(a3, a1);
  }
}

{
  TSTCellInflateFromStorageRef(a1, a2, a3);
}

uint64_t TSUEqualFormatStructs(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 == *(_DWORD *)a2)
  {
    uint64_t result = 1;
    switch(v2)
    {
      case 0xFEu:
        return 1;
      case 0xFFu:
        goto LABEL_9;
      case 0x100u:
      case 0x101u:
      case 0x102u:
      case 0x103u:
        char v6 = *(void **)(a1 + 8);
        if (v6 != *(void **)(a2 + 8))
        {
          uint64_t result = objc_msgSend(v6, "isEqualToString:");
          if (!result) {
            return result;
          }
        }
        return ((*(_WORD *)(a2 + 16) ^ *(_WORD *)(a1 + 16)) & 0x1FFF) == 0;
      case 0x104u:
      case 0x107u:
      case 0x10Bu:
        return result;
      case 0x105u:
        uint64_t result = [*(id *)(a1 + 16) isEqualToString:*(void *)(a2 + 16)];
        if (!result) {
          return result;
        }
        char v14 = *(unsigned char *)(a2 + 8) ^ *(unsigned char *)(a1 + 8);
        BOOL v12 = (v14 & 2) == 0;
        BOOL v13 = (v14 & 1) == 0;
        return v13 && v12;
      case 0x106u:
        int v7 = *(unsigned __int8 *)(a1 + 8);
        int v8 = *(unsigned __int8 *)(a2 + 8);
        return v7 == v8;
      case 0x108u:
      case 0x109u:
        if (*(double *)(a1 + 8) != *(double *)(a2 + 8)
          || *(double *)(a1 + 16) != *(double *)(a2 + 16)
          || *(double *)(a1 + 24) != *(double *)(a2 + 24)
          || *(_DWORD *)(a1 + 32) != *(_DWORD *)(a2 + 32))
        {
          return 0;
        }
        char v11 = *(unsigned char *)(a2 + 36) ^ *(unsigned char *)(a1 + 36);
        BOOL v12 = (v11 & 0xC) == 0;
        BOOL v13 = (v11 & 3) == 0;
        return v13 && v12;
      case 0x10Au:
        if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
          return 0;
        }
        int v7 = *(_DWORD *)(a1 + 12);
        int v8 = *(_DWORD *)(a2 + 12);
        return v7 == v8;
      case 0x10Cu:
        if (*(_DWORD *)(a1 + 20) != *(_DWORD *)(a2 + 20)
          || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
          || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
        {
          return 0;
        }
        return ((*(unsigned __int8 *)(a2 + 8) ^ *(unsigned __int8 *)(a1 + 8)) & 1) == 0;
      case 0x10Du:
        int v16 = *(unsigned __int16 *)(a2 + 8);
        if ((unsigned __int16)v16 != *(_WORD *)(a1 + 8)) {
          return 0;
        }
        return (((v16 | (*(unsigned __int8 *)(a2 + 10) << 16)) ^ (*(unsigned __int16 *)(a1 + 8) | (*(unsigned __int8 *)(a1 + 10) << 16))) & 0x10000) == 0;
      case 0x10Eu:
      case 0x10Fu:
      case 0x110u:
        int v7 = *(_DWORD *)(a1 + 8);
        int v8 = *(_DWORD *)(a2 + 8);
        return v7 == v8;
      default:
        if (v2 < 2) {
          return result;
        }
LABEL_9:
        id v9 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v10 = objc_msgSend(NSString, "stringWithUTF8String:", "BOOL TSUEqualFormatStructs(TSUFormatStruct, TSUFormatStruct)");
        objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Binaries/AlderShared/install/Root/usr/local/include/TSFrameworks/TSUtility/TSUFormatUtilities.h"), 191, @"We should have dealt with any types earlier.");
        return 0;
    }
  }
  return 0;
}

double TSTCellDoubleValue(TSTCell *a1)
{
  if (a1)
  {
    int mPrivate = (int)a1->mPrivate;
    if ((mPrivate & 0xFB00) == 0x200 || BYTE1(mPrivate) == 7)
    {
      mDate = a1->mPrivate.mValue.mDate;
    }
    else
    {
      mDate = 0;
      if (BYTE1(mPrivate))
      {
        int v7 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v8 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
        objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", a1);
      }
    }
  }
  else
  {
    id v5 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v6 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
    objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 889, @"invalid nil value for '%s'", "cell");
    mDate = 0;
  }
  return *(double *)&mDate;
}

uint64_t TSTCellDateValue(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(unsigned char *)(result + 9))
    {
      if (*(unsigned char *)(result + 9) == 5) {
        return *(void *)(result + 16);
      }
      unsigned int v2 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v3 = [NSString stringWithUTF8String:"NSDate *TSTCellDateValue(TSTCell *)"];
      objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 1021, @"can't get date value from a non-date cell: %p", v1);
    }
    return 0;
  }
  return result;
}

void *TSTCellIsEqualForValidation(uint64_t a1, uint64_t a2)
{
  if (!a1 || !a2) {
    return (void *)(a1 == a2);
  }
  uint64_t result = (void *)[(id)a2 isCellContentsEqualToCell:a1];
  if (!result) {
    return result;
  }
  if ((*(_DWORD *)(a1 + 8) ^ *(_DWORD *)(a2 + 8)) > 0xFF) {
    return 0;
  }
  if ((*(_DWORD *)(a2 + 104) - 1) < 0xFFFFFFFE || *(_DWORD *)(a2 + 100))
  {
    if ((*(_DWORD *)(a1 + 104) - 1) >= 0xFFFFFFFE && !*(_DWORD *)(a1 + 100)) {
      return 0;
    }
    long long v5 = *(_OWORD *)(a1 + 120);
    v74[0] = *(_OWORD *)(a1 + 104);
    v74[1] = v5;
    uint64_t v75 = *(void *)(a1 + 136);
    long long v6 = *(_OWORD *)(a2 + 120);
    v72[0] = *(_OWORD *)(a2 + 104);
    v72[1] = v6;
    uint64_t v73 = *(void *)(a2 + 136);
    if ((TSUEqualFormatStructs((uint64_t)v74, (uint64_t)v72) & 1) == 0) {
      return 0;
    }
  }
  else if ((*(_DWORD *)(a1 + 104) - 1) < 0xFFFFFFFE || *(_DWORD *)(a1 + 100))
  {
    return 0;
  }
  int v7 = *(void **)(a2 + 152);
  if (v7 && ([v7 getFormatStruct], (v76 - 1) <= 0xFFFFFFFD))
  {
    uint64_t result = *(void **)(a1 + 152);
    if (!result) {
      return result;
    }
    [result getFormatStruct];
    if ((v76 - 1) > 0xFFFFFFFD) {
      return 0;
    }
    uint64_t v8 = *(void **)(a1 + 152);
    if (v8)
    {
      [v8 getFormatStruct];
    }
    else
    {
      uint64_t v71 = 0;
      v70[0] = TSUInvalidFormat;
      v70[1] = unk_22383BEB8;
    }
    uint64_t v25 = *(void **)(a2 + 152);
    if (v25)
    {
      [v25 getFormatStruct];
    }
    else
    {
      uint64_t v69 = 0;
      v68[0] = TSUInvalidFormat;
      v68[1] = unk_22383BEB8;
    }
    if ((TSUEqualFormatStructs((uint64_t)v70, (uint64_t)v68) & 1) == 0) {
      return 0;
    }
  }
  else
  {
    uint64_t v10 = *(void **)(a1 + 152);
    if (v10)
    {
      [v10 getFormatStruct];
      if ((v76 - 1) < 0xFFFFFFFE) {
        return 0;
      }
    }
  }
  char v11 = *(void **)(a2 + 168);
  if (v11 && ([v11 getFormatStruct], (v76 - 1) <= 0xFFFFFFFD))
  {
    uint64_t result = *(void **)(a1 + 168);
    if (!result) {
      return result;
    }
    [result getFormatStruct];
    if ((v76 - 1) > 0xFFFFFFFD) {
      return 0;
    }
    BOOL v12 = *(void **)(a1 + 168);
    if (v12)
    {
      [v12 getFormatStruct];
    }
    else
    {
      uint64_t v67 = 0;
      v66[0] = TSUInvalidFormat;
      v66[1] = unk_22383BEB8;
    }
    uint64_t v29 = *(void **)(a2 + 168);
    if (v29)
    {
      [v29 getFormatStruct];
    }
    else
    {
      uint64_t v65 = 0;
      v64[0] = TSUInvalidFormat;
      v64[1] = unk_22383BEB8;
    }
    if ((TSUEqualFormatStructs((uint64_t)v66, (uint64_t)v64) & 1) == 0) {
      return 0;
    }
  }
  else
  {
    BOOL v13 = *(void **)(a1 + 168);
    if (v13)
    {
      [v13 getFormatStruct];
      if ((v76 - 1) < 0xFFFFFFFE) {
        return 0;
      }
    }
  }
  char v14 = *(void **)(a2 + 200);
  if (v14 && ([v14 getFormatStruct], (v76 - 1) <= 0xFFFFFFFD))
  {
    uint64_t result = *(void **)(a1 + 200);
    if (!result) {
      return result;
    }
    [result getFormatStruct];
    if ((v76 - 1) > 0xFFFFFFFD) {
      return 0;
    }
    id v15 = *(void **)(a1 + 200);
    if (v15)
    {
      [v15 getFormatStruct];
    }
    else
    {
      uint64_t v63 = 0;
      v62[0] = TSUInvalidFormat;
      v62[1] = unk_22383BEB8;
    }
    uint64_t v33 = *(void **)(a2 + 200);
    if (v33)
    {
      [v33 getFormatStruct];
    }
    else
    {
      uint64_t v61 = 0;
      v60[0] = TSUInvalidFormat;
      v60[1] = unk_22383BEB8;
    }
    if ((TSUEqualFormatStructs((uint64_t)v62, (uint64_t)v60) & 1) == 0) {
      return 0;
    }
  }
  else
  {
    int v16 = *(void **)(a1 + 200);
    if (v16)
    {
      [v16 getFormatStruct];
      if ((v76 - 1) < 0xFFFFFFFE) {
        return 0;
      }
    }
  }
  id v17 = *(void **)(a2 + 184);
  if (v17 && ([v17 getFormatStruct], (v76 - 1) <= 0xFFFFFFFD))
  {
    uint64_t result = *(void **)(a1 + 184);
    if (!result) {
      return result;
    }
    [result getFormatStruct];
    if ((v76 - 1) > 0xFFFFFFFD) {
      return 0;
    }
    id v18 = *(void **)(a1 + 184);
    if (v18)
    {
      [v18 getFormatStruct];
    }
    else
    {
      uint64_t v59 = 0;
      v58[0] = TSUInvalidFormat;
      v58[1] = unk_22383BEB8;
    }
    unint64_t v35 = *(void **)(a2 + 184);
    if (v35)
    {
      [v35 getFormatStruct];
    }
    else
    {
      uint64_t v57 = 0;
      v56[0] = TSUInvalidFormat;
      v56[1] = unk_22383BEB8;
    }
    if ((TSUEqualFormatStructs((uint64_t)v58, (uint64_t)v56) & 1) == 0) {
      return 0;
    }
  }
  else
  {
    uint64_t v19 = *(void **)(a1 + 184);
    if (v19)
    {
      [v19 getFormatStruct];
      if ((v76 - 1) < 0xFFFFFFFE) {
        return 0;
      }
    }
  }
  int v20 = *(void **)(a2 + 216);
  if (v20 && ([v20 getFormatStruct], (v76 - 1) <= 0xFFFFFFFD))
  {
    uint64_t result = *(void **)(a1 + 216);
    if (!result) {
      return result;
    }
    [result getFormatStruct];
    if ((v76 - 1) > 0xFFFFFFFD) {
      return 0;
    }
    uint64_t v21 = *(void **)(a1 + 216);
    if (v21)
    {
      [v21 getFormatStruct];
    }
    else
    {
      uint64_t v55 = 0;
      v54[0] = TSUInvalidFormat;
      v54[1] = unk_22383BEB8;
    }
    double v36 = *(void **)(a2 + 216);
    if (v36)
    {
      [v36 getFormatStruct];
    }
    else
    {
      uint64_t v53 = 0;
      v52[0] = TSUInvalidFormat;
      v52[1] = unk_22383BEB8;
    }
    if ((TSUEqualFormatStructs((uint64_t)v54, (uint64_t)v52) & 1) == 0) {
      return 0;
    }
  }
  else
  {
    uint64_t v22 = *(void **)(a1 + 216);
    if (v22)
    {
      [v22 getFormatStruct];
      if ((v76 - 1) < 0xFFFFFFFE) {
        return 0;
      }
    }
  }
  uint64_t v23 = *(void **)(a2 + 232);
  if (v23 && ([v23 getFormatStruct], (v76 - 1) <= 0xFFFFFFFD))
  {
    uint64_t result = *(void **)(a1 + 232);
    if (!result) {
      return result;
    }
    [result getFormatStruct];
    if ((v76 - 1) > 0xFFFFFFFD) {
      return 0;
    }
    uint64_t v24 = *(void **)(a1 + 232);
    if (v24)
    {
      [v24 getFormatStruct];
    }
    else
    {
      uint64_t v51 = 0;
      v50[0] = TSUInvalidFormat;
      v50[1] = unk_22383BEB8;
    }
    double v37 = *(void **)(a2 + 232);
    if (v37)
    {
      [v37 getFormatStruct];
    }
    else
    {
      uint64_t v49 = 0;
      v48[0] = TSUInvalidFormat;
      v48[1] = unk_22383BEB8;
    }
    if ((TSUEqualFormatStructs((uint64_t)v50, (uint64_t)v48) & 1) == 0) {
      return 0;
    }
  }
  else
  {
    int v26 = *(void **)(a1 + 232);
    if (v26)
    {
      [v26 getFormatStruct];
      if ((v76 - 1) < 0xFFFFFFFE) {
        return 0;
      }
    }
  }
  uint64_t v27 = *(void **)(a2 + 248);
  if (v27 && ([v27 getFormatStruct], (v76 - 1) <= 0xFFFFFFFD))
  {
    uint64_t result = *(void **)(a1 + 248);
    if (!result) {
      return result;
    }
    [result getFormatStruct];
    if ((v76 - 1) > 0xFFFFFFFD) {
      return 0;
    }
    unint64_t v28 = *(void **)(a1 + 248);
    if (v28)
    {
      [v28 getFormatStruct];
    }
    else
    {
      uint64_t v47 = 0;
      v46[0] = TSUInvalidFormat;
      v46[1] = unk_22383BEB8;
    }
    id v38 = *(void **)(a2 + 248);
    if (v38)
    {
      [v38 getFormatStruct];
    }
    else
    {
      uint64_t v45 = 0;
      v44[0] = TSUInvalidFormat;
      v44[1] = unk_22383BEB8;
    }
    if ((TSUEqualFormatStructs((uint64_t)v46, (uint64_t)v44) & 1) == 0) {
      return 0;
    }
  }
  else
  {
    uint64_t v30 = *(void **)(a1 + 248);
    if (v30)
    {
      [v30 getFormatStruct];
      if ((v76 - 1) < 0xFFFFFFFE) {
        return 0;
      }
    }
  }
  unint64_t v31 = *(void **)(a2 + 264);
  if (v31 && ([v31 getFormatStruct], (v76 - 1) <= 0xFFFFFFFD))
  {
    uint64_t result = *(void **)(a1 + 264);
    if (!result) {
      return result;
    }
    [result getFormatStruct];
    if ((v76 - 1) > 0xFFFFFFFD) {
      return 0;
    }
    unint64_t v32 = *(void **)(a1 + 264);
    if (v32)
    {
      [v32 getFormatStruct];
    }
    else
    {
      uint64_t v43 = 0;
      v42[0] = TSUInvalidFormat;
      v42[1] = unk_22383BEB8;
    }
    double v39 = *(void **)(a2 + 264);
    if (v39)
    {
      [v39 getFormatStruct];
    }
    else
    {
      uint64_t v41 = 0;
      v40[0] = TSUInvalidFormat;
      v40[1] = unk_22383BEB8;
    }
    if ((TSUEqualFormatStructs((uint64_t)v42, (uint64_t)v40) & 1) == 0) {
      return 0;
    }
  }
  else
  {
    uint64_t v34 = *(void **)(a1 + 264);
    if (v34)
    {
      [v34 getFormatStruct];
      if ((v76 - 1) < 0xFFFFFFFE) {
        return 0;
      }
    }
  }
  if (*(unsigned __int16 *)(a2 + 96) != *(unsigned __int16 *)(a1 + 96)) {
    return 0;
  }
  return (void *)(*(unsigned __int8 *)(a1 + 272) == *(unsigned __int8 *)(a2 + 272));
}

void TSTCellClearValue(uint64_t a1)
{
  if (a1)
  {
    int v2 = *(_DWORD *)(a1 + 8);
    if ((v2 & 0xFF00) == 0x300)
    {

      *(void *)(a1 + 24) = 0;
      *(_DWORD *)(a1 + 16) = 0;
      int v2 = *(_DWORD *)(a1 + 8);
    }
    if ((v2 & 0xFF00) == 0x500)
    {

      *(void *)(a1 + 16) = 0;
      int v2 = *(_DWORD *)(a1 + 8);
    }
    if ((v2 & 0xFF00) == 0x900)
    {
      uint64_t v3 = *(void **)(a1 + 72);
      if (v3)
      {

        *(void *)(a1 + 72) = 0;
      }
      *(_DWORD *)(a1 + 64) = 0;
    }
  }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
}

uint64_t TSTCellClearAllFormats(uint64_t a1)
{
  if (a1)
  {

    *(void *)(a1 + 152) = 0;
    *(_DWORD *)(a1 + 144) = 0;

    *(void *)(a1 + 168) = 0;
    *(_DWORD *)(a1 + 160) = 0;

    *(void *)(a1 + 200) = 0;
    *(_DWORD *)(a1 + 192) = 0;

    *(void *)(a1 + 184) = 0;
    *(_DWORD *)(a1 + 176) = 0;

    *(void *)(a1 + 216) = 0;
    *(_DWORD *)(a1 + 208) = 0;

    *(void *)(a1 + 248) = 0;
    *(_DWORD *)(a1 + 240) = 0;

    *(void *)(a1 + 232) = 0;
    *(_DWORD *)(a1 + 224) = 0;

    *(void *)(a1 + 264) = 0;
    *(_DWORD *)(a1 + 256) = 0;
  }
  *(_WORD *)(a1 + 96) = 0;

  return TSTCellSetImplicitFormat(a1, (uint64_t)&TSUNotSetFormat);
}

uint64_t TSTCellSetImplicitFormat(uint64_t a1, uint64_t a2)
{
  long long v4 = *(_OWORD *)(a2 + 16);
  v9[0] = *(_OWORD *)a2;
  v9[1] = v4;
  uint64_t v10 = *(void *)(a2 + 32);
  TSTCellSetFormatClearingID(a1, (uint64_t)v9, 1);
  long long v5 = *(_OWORD *)(a2 + 16);
  v7[0] = *(_OWORD *)a2;
  v7[1] = v5;
  uint64_t v8 = *(void *)(a2 + 32);
  return TSTCellSetFormatFlagsFromFormat(a1, (int *)v7, 0, 1);
}

id TSTCellCopyJustStyleAndStrokes(uint64_t a1, uint64_t a2)
{
  long long v4 = *(void **)(a2 + 40);
  if (v4) {

  }
  long long v5 = *(void **)(a2 + 56);
  if (v5) {

  }
  *(_WORD *)(a2 + 10) = (*(_DWORD *)(a1 + 8) & 0x8F00000u) >> 16;
  *(void *)(a2 + 40) = *(id *)(a1 + 40);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 32);
  id result = *(id *)(a1 + 56);
  *(void *)(a2 + 56) = result;
  *(_DWORD *)(a2 + 48) = *(_DWORD *)(a1 + 48);
  *(unsigned char *)(a2 + 272) = *(unsigned char *)(a1 + 272);
  return result;
}

uint64_t TSTCellCopyAllFormats(uint64_t a1, uint64_t a2)
{
  TSTCellClearAllFormats(a2);
  if (!a1) {
    goto LABEL_90;
  }
  long long v4 = *(void **)(a1 + 248);
  if (v4)
  {
    [v4 getFormatStruct];
    if ((v72 - 1) <= 0xFFFFFFFD)
    {
      long long v5 = *(void **)(a1 + 248);
      if (v5)
      {
        [v5 getFormatStruct];
        if (!a2) {
          goto LABEL_13;
        }
      }
      else
      {
        uint64_t v65 = 0;
        long long v63 = TSUInvalidFormat;
        long long v64 = unk_22383BEB8;
        if (!a2) {
          goto LABEL_13;
        }
      }
      long long v72 = v63;
      long long v73 = v64;
      uint64_t v74 = v65;
      long long v6 = *(void **)(a2 + 248);
      if (v6)
      {
        [v6 getFormatStruct];
      }
      else
      {
        uint64_t v71 = 0;
        long long v69 = 0u;
        long long v70 = 0u;
      }
      if ((TSUEqualFormatStructs((uint64_t)&v72, (uint64_t)&v69) & 1) == 0)
      {

        id v7 = objc_alloc(MEMORY[0x263F7C850]);
        long long v66 = v63;
        long long v67 = v64;
        uint64_t v68 = v65;
        *(void *)(a2 + 248) = [v7 initWithTSUFormatFormatStruct:&v66];
        *(_DWORD *)(a2 + 240) = 0;
      }
    }
  }
LABEL_13:
  uint64_t v8 = *(void **)(a1 + 216);
  if (v8)
  {
    [v8 getFormatStruct];
    if ((v72 - 1) <= 0xFFFFFFFD)
    {
      id v9 = *(void **)(a1 + 216);
      if (v9)
      {
        [v9 getFormatStruct];
        if (!a2) {
          goto LABEL_24;
        }
      }
      else
      {
        uint64_t v62 = 0;
        long long v60 = TSUInvalidFormat;
        long long v61 = unk_22383BEB8;
        if (!a2) {
          goto LABEL_24;
        }
      }
      long long v72 = v60;
      long long v73 = v61;
      uint64_t v74 = v62;
      uint64_t v10 = *(void **)(a2 + 216);
      if (v10)
      {
        [v10 getFormatStruct];
      }
      else
      {
        uint64_t v71 = 0;
        long long v69 = 0u;
        long long v70 = 0u;
      }
      if ((TSUEqualFormatStructs((uint64_t)&v72, (uint64_t)&v69) & 1) == 0)
      {

        id v11 = objc_alloc(MEMORY[0x263F7C850]);
        long long v66 = v60;
        long long v67 = v61;
        uint64_t v68 = v62;
        *(void *)(a2 + 216) = [v11 initWithTSUFormatFormatStruct:&v66];
        *(_DWORD *)(a2 + 208) = 0;
      }
    }
  }
LABEL_24:
  BOOL v12 = *(void **)(a1 + 168);
  if (v12)
  {
    [v12 getFormatStruct];
    if ((v72 - 1) <= 0xFFFFFFFD)
    {
      BOOL v13 = *(void **)(a1 + 168);
      if (v13)
      {
        [v13 getFormatStruct];
        if (!a2) {
          goto LABEL_35;
        }
      }
      else
      {
        uint64_t v59 = 0;
        long long v57 = TSUInvalidFormat;
        long long v58 = unk_22383BEB8;
        if (!a2) {
          goto LABEL_35;
        }
      }
      long long v72 = v57;
      long long v73 = v58;
      uint64_t v74 = v59;
      char v14 = *(void **)(a2 + 168);
      if (v14)
      {
        [v14 getFormatStruct];
      }
      else
      {
        uint64_t v71 = 0;
        long long v69 = 0u;
        long long v70 = 0u;
      }
      if ((TSUEqualFormatStructs((uint64_t)&v72, (uint64_t)&v69) & 1) == 0)
      {

        id v15 = objc_alloc(MEMORY[0x263F7C850]);
        long long v66 = v57;
        long long v67 = v58;
        uint64_t v68 = v59;
        *(void *)(a2 + 168) = [v15 initWithTSUFormatFormatStruct:&v66];
        *(_DWORD *)(a2 + 160) = 0;
      }
    }
  }
LABEL_35:
  int v16 = *(void **)(a1 + 232);
  if (v16)
  {
    [v16 getFormatStruct];
    if ((v72 - 1) <= 0xFFFFFFFD)
    {
      id v17 = *(void **)(a1 + 232);
      if (v17)
      {
        [v17 getFormatStruct];
        if (!a2) {
          goto LABEL_46;
        }
      }
      else
      {
        uint64_t v56 = 0;
        long long v54 = TSUInvalidFormat;
        long long v55 = unk_22383BEB8;
        if (!a2) {
          goto LABEL_46;
        }
      }
      long long v72 = v54;
      long long v73 = v55;
      uint64_t v74 = v56;
      id v18 = *(void **)(a2 + 232);
      if (v18)
      {
        [v18 getFormatStruct];
      }
      else
      {
        uint64_t v71 = 0;
        long long v69 = 0u;
        long long v70 = 0u;
      }
      if ((TSUEqualFormatStructs((uint64_t)&v72, (uint64_t)&v69) & 1) == 0)
      {

        id v19 = objc_alloc(MEMORY[0x263F7C850]);
        long long v66 = v54;
        long long v67 = v55;
        uint64_t v68 = v56;
        *(void *)(a2 + 232) = [v19 initWithTSUFormatFormatStruct:&v66];
        *(_DWORD *)(a2 + 224) = 0;
      }
    }
  }
LABEL_46:
  int v20 = *(void **)(a1 + 200);
  if (v20)
  {
    [v20 getFormatStruct];
    if ((v72 - 1) <= 0xFFFFFFFD)
    {
      uint64_t v21 = *(void **)(a1 + 200);
      if (v21)
      {
        [v21 getFormatStruct];
        if (!a2) {
          goto LABEL_57;
        }
      }
      else
      {
        uint64_t v53 = 0;
        long long v51 = TSUInvalidFormat;
        long long v52 = unk_22383BEB8;
        if (!a2) {
          goto LABEL_57;
        }
      }
      long long v72 = v51;
      long long v73 = v52;
      uint64_t v74 = v53;
      uint64_t v22 = *(void **)(a2 + 200);
      if (v22)
      {
        [v22 getFormatStruct];
      }
      else
      {
        uint64_t v71 = 0;
        long long v69 = 0u;
        long long v70 = 0u;
      }
      if ((TSUEqualFormatStructs((uint64_t)&v72, (uint64_t)&v69) & 1) == 0)
      {

        id v23 = objc_alloc(MEMORY[0x263F7C850]);
        long long v66 = v51;
        long long v67 = v52;
        uint64_t v68 = v53;
        *(void *)(a2 + 200) = [v23 initWithTSUFormatFormatStruct:&v66];
        *(_DWORD *)(a2 + 192) = 0;
      }
    }
  }
LABEL_57:
  uint64_t v24 = *(void **)(a1 + 184);
  if (v24)
  {
    [v24 getFormatStruct];
    if ((v72 - 1) <= 0xFFFFFFFD)
    {
      uint64_t v25 = *(void **)(a1 + 184);
      if (v25)
      {
        [v25 getFormatStruct];
        if (!a2) {
          goto LABEL_68;
        }
      }
      else
      {
        uint64_t v50 = 0;
        long long v48 = TSUInvalidFormat;
        long long v49 = unk_22383BEB8;
        if (!a2) {
          goto LABEL_68;
        }
      }
      long long v72 = v48;
      long long v73 = v49;
      uint64_t v74 = v50;
      int v26 = *(void **)(a2 + 184);
      if (v26)
      {
        [v26 getFormatStruct];
      }
      else
      {
        uint64_t v71 = 0;
        long long v69 = 0u;
        long long v70 = 0u;
      }
      if ((TSUEqualFormatStructs((uint64_t)&v72, (uint64_t)&v69) & 1) == 0)
      {

        id v27 = objc_alloc(MEMORY[0x263F7C850]);
        long long v66 = v48;
        long long v67 = v49;
        uint64_t v68 = v50;
        *(void *)(a2 + 184) = [v27 initWithTSUFormatFormatStruct:&v66];
        *(_DWORD *)(a2 + 176) = 0;
      }
    }
  }
LABEL_68:
  unint64_t v28 = *(void **)(a1 + 264);
  if (v28)
  {
    [v28 getFormatStruct];
    if ((v72 - 1) <= 0xFFFFFFFD)
    {
      uint64_t v29 = *(void **)(a1 + 264);
      if (v29)
      {
        [v29 getFormatStruct];
        if (!a2) {
          goto LABEL_79;
        }
      }
      else
      {
        uint64_t v47 = 0;
        long long v45 = TSUInvalidFormat;
        long long v46 = unk_22383BEB8;
        if (!a2) {
          goto LABEL_79;
        }
      }
      long long v72 = v45;
      long long v73 = v46;
      uint64_t v74 = v47;
      uint64_t v30 = *(void **)(a2 + 264);
      if (v30)
      {
        [v30 getFormatStruct];
      }
      else
      {
        uint64_t v71 = 0;
        long long v69 = 0u;
        long long v70 = 0u;
      }
      if ((TSUEqualFormatStructs((uint64_t)&v72, (uint64_t)&v69) & 1) == 0)
      {

        id v31 = objc_alloc(MEMORY[0x263F7C850]);
        long long v66 = v45;
        long long v67 = v46;
        uint64_t v68 = v47;
        *(void *)(a2 + 264) = [v31 initWithTSUFormatFormatStruct:&v66];
        *(_DWORD *)(a2 + 256) = 0;
      }
    }
  }
LABEL_79:
  unint64_t v32 = *(void **)(a1 + 152);
  if (v32)
  {
    [v32 getFormatStruct];
    if ((v72 - 1) <= 0xFFFFFFFD)
    {
      uint64_t v33 = *(void **)(a1 + 152);
      if (v33)
      {
        [v33 getFormatStruct];
        if (!a2) {
          goto LABEL_90;
        }
      }
      else
      {
        uint64_t v44 = 0;
        long long v42 = TSUInvalidFormat;
        long long v43 = unk_22383BEB8;
        if (!a2) {
          goto LABEL_90;
        }
      }
      long long v72 = v42;
      long long v73 = v43;
      uint64_t v74 = v44;
      uint64_t v34 = *(void **)(a2 + 152);
      if (v34)
      {
        [v34 getFormatStruct];
      }
      else
      {
        uint64_t v71 = 0;
        long long v69 = 0u;
        long long v70 = 0u;
      }
      if ((TSUEqualFormatStructs((uint64_t)&v72, (uint64_t)&v69) & 1) == 0)
      {

        id v35 = objc_alloc(MEMORY[0x263F7C850]);
        long long v66 = v42;
        long long v67 = v43;
        uint64_t v68 = v44;
        *(void *)(a2 + 152) = [v35 initWithTSUFormatFormatStruct:&v66];
        *(_DWORD *)(a2 + 144) = 0;
      }
    }
  }
LABEL_90:
  double v36 = (long long *)(a1 + 104);
  if (!a1) {
    double v36 = &TSUInvalidFormat;
  }
  long long v37 = v36[1];
  v40[0] = *v36;
  v40[1] = v37;
  uint64_t v41 = *((void *)v36 + 4);
  uint64_t result = TSTCellSetFormatClearingID(a2, (uint64_t)v40, 1);
  if (a1) {
    __int16 v39 = *(_WORD *)(a1 + 96);
  }
  else {
    __int16 v39 = 0;
  }
  *(_WORD *)(a2 + 96) = v39;
  return result;
}

uint64_t TSTCellSetFormatClearingID(uint64_t a1, uint64_t a2, int a3)
{
  long long v6 = *(_OWORD *)(a2 + 16);
  long long v17 = *(_OWORD *)a2;
  long long v18 = v6;
  uint64_t v19 = *(void *)(a2 + 32);
  TSUFormatStructRetain();
  long long v7 = *(_OWORD *)(a1 + 120);
  long long v14 = *(_OWORD *)(a1 + 104);
  long long v15 = v7;
  uint64_t v16 = *(void *)(a1 + 136);
  TSUFormatStructRelease();
  long long v8 = *(_OWORD *)a2;
  long long v9 = *(_OWORD *)(a2 + 16);
  *(void *)(a1 + 136) = *(void *)(a2 + 32);
  *(_OWORD *)(a1 + 120) = v9;
  *(_OWORD *)(a1 + ++*(_DWORD *)(this + 104) = v8;
  if (a3) {
    *(_DWORD *)(a1 + 100) = 0;
  }
  long long v10 = *(_OWORD *)(a2 + 16);
  v12[0] = *(_OWORD *)a2;
  v12[1] = v10;
  uint64_t v13 = *(void *)(a2 + 32);
  return TSTCellSetCellFormatStructBasedOnType(a1, v12, a3);
}

uint64_t TSTCellImpliedFormatType(uint64_t a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = *(unsigned int *)(a1 + 104);
  if ((result + 1) <= 2)
  {
    int v3 = *(_DWORD *)(a1 + 8);
    if (BYTE1(v3) > 8u) {
      return 260;
    }
    else {
      return dword_22383BEF0[SBYTE1(v3)];
    }
  }
  return result;
}

unint64_t TSTCellHasFormatOfType(void *a1, int a2)
{
  unint64_t result = 0;
  switch(a2)
  {
    case 256:
    case 258:
    case 259:
    case 262:
      if (!a1) {
        goto LABEL_27;
      }
      unint64_t result = a1[19];
      if (result)
      {
        [(id)result getFormatStruct];
        int v4 = v12;
        goto LABEL_26;
      }
      break;
    case 257:
      if (!a1) {
        goto LABEL_27;
      }
      unint64_t result = a1[21];
      if (result)
      {
        [(id)result getFormatStruct];
        int v4 = v11;
        goto LABEL_26;
      }
      break;
    case 261:
      if (!a1) {
        goto LABEL_27;
      }
      unint64_t result = a1[25];
      if (result)
      {
        [(id)result getFormatStruct];
        int v4 = v10;
        goto LABEL_26;
      }
      break;
    case 264:
    case 265:
      if (!a1) {
        goto LABEL_27;
      }
      unint64_t result = a1[27];
      if (result)
      {
        [(id)result getFormatStruct];
        int v4 = v6;
        goto LABEL_26;
      }
      break;
    case 266:
      if (!a1) {
        goto LABEL_27;
      }
      unint64_t result = a1[33];
      if (result)
      {
        [(id)result getFormatStruct];
        int v4 = v5;
        goto LABEL_26;
      }
      break;
    case 268:
      if (!a1) {
        goto LABEL_27;
      }
      unint64_t result = a1[23];
      if (result)
      {
        [(id)result getFormatStruct];
        int v4 = v9;
        goto LABEL_26;
      }
      break;
    case 269:
      if (!a1) {
        goto LABEL_27;
      }
      unint64_t result = a1[31];
      if (result)
      {
        [(id)result getFormatStruct];
        int v4 = v7;
        goto LABEL_26;
      }
      break;
    case 270:
    case 271:
    case 272:
      if (a1)
      {
        unint64_t result = a1[29];
        if (result)
        {
          [(id)result getFormatStruct];
          int v4 = v8;
LABEL_26:
          unint64_t result = (v4 - 1) < 0xFFFFFFFE;
        }
      }
      else
      {
LABEL_27:
        unint64_t result = 0;
      }
      break;
    default:
      return result;
  }
  return result;
}

void *TSTCellGetFormatOfType(void *a1, int a2, uint64_t a3)
{
  unint64_t result = 0;
  switch(a2)
  {
    case 254:
    case 260:
    case 263:
    case 267:
      goto LABEL_29;
    case 255:
      return result;
    case 256:
    case 258:
    case 259:
    case 262:
      if (!a1) {
        goto LABEL_29;
      }
      int v6 = (void *)a1[19];
      if (v6)
      {
        [v6 getFormatStruct];
        *(_OWORD *)a3 = v23;
        *(_OWORD *)(a3 + 16) = v24;
        *(void *)(a3 + 32) = v25;
      }
      else
      {
        *(void *)(a3 + 32) = 0;
        *(_OWORD *)a3 = TSUInvalidFormat;
        *(_OWORD *)(a3 + 16) = unk_22383BEB8;
      }
      unint64_t result = (void *)a1[19];
      if (!result) {
        return result;
      }
      [result getFormatStruct];
      int v14 = v22;
      break;
    case 257:
      if (!a1) {
        goto LABEL_29;
      }
      int v9 = (void *)a1[21];
      if (v9)
      {
        [v9 getFormatStruct];
        *(_OWORD *)a3 = v23;
        *(_OWORD *)(a3 + 16) = v24;
        *(void *)(a3 + 32) = v25;
      }
      else
      {
        *(void *)(a3 + 32) = 0;
        *(_OWORD *)a3 = TSUInvalidFormat;
        *(_OWORD *)(a3 + 16) = unk_22383BEB8;
      }
      unint64_t result = (void *)a1[21];
      if (!result) {
        return result;
      }
      [result getFormatStruct];
      int v14 = v21;
      break;
    case 261:
      if (!a1) {
        goto LABEL_29;
      }
      int v10 = (void *)a1[25];
      if (v10)
      {
        [v10 getFormatStruct];
        *(_OWORD *)a3 = v23;
        *(_OWORD *)(a3 + 16) = v24;
        *(void *)(a3 + 32) = v25;
      }
      else
      {
        *(void *)(a3 + 32) = 0;
        *(_OWORD *)a3 = TSUInvalidFormat;
        *(_OWORD *)(a3 + 16) = unk_22383BEB8;
      }
      unint64_t result = (void *)a1[25];
      if (!result) {
        return result;
      }
      [result getFormatStruct];
      int v14 = v20;
      break;
    case 264:
    case 265:
      if (!a1) {
        goto LABEL_29;
      }
      int v8 = (void *)a1[27];
      if (v8)
      {
        [v8 getFormatStruct];
        *(_OWORD *)a3 = v23;
        *(_OWORD *)(a3 + 16) = v24;
        *(void *)(a3 + 32) = v25;
      }
      else
      {
        *(void *)(a3 + 32) = 0;
        *(_OWORD *)a3 = TSUInvalidFormat;
        *(_OWORD *)(a3 + 16) = unk_22383BEB8;
      }
      unint64_t result = (void *)a1[27];
      if (!result) {
        return result;
      }
      [result getFormatStruct];
      int v14 = v16;
      break;
    case 266:
      if (!a1) {
        goto LABEL_29;
      }
      int v11 = (void *)a1[33];
      if (v11)
      {
        [v11 getFormatStruct];
        *(_OWORD *)a3 = v23;
        *(_OWORD *)(a3 + 16) = v24;
        *(void *)(a3 + 32) = v25;
      }
      else
      {
        *(void *)(a3 + 32) = 0;
        *(_OWORD *)a3 = TSUInvalidFormat;
        *(_OWORD *)(a3 + 16) = unk_22383BEB8;
      }
      unint64_t result = (void *)a1[33];
      if (!result) {
        return result;
      }
      [result getFormatStruct];
      int v14 = v15;
      break;
    case 268:
      if (!a1) {
        goto LABEL_29;
      }
      int v12 = (void *)a1[23];
      if (v12)
      {
        [v12 getFormatStruct];
        *(_OWORD *)a3 = v23;
        *(_OWORD *)(a3 + 16) = v24;
        *(void *)(a3 + 32) = v25;
      }
      else
      {
        *(void *)(a3 + 32) = 0;
        *(_OWORD *)a3 = TSUInvalidFormat;
        *(_OWORD *)(a3 + 16) = unk_22383BEB8;
      }
      unint64_t result = (void *)a1[23];
      if (!result) {
        return result;
      }
      [result getFormatStruct];
      int v14 = v19;
      break;
    case 269:
      if (!a1) {
        goto LABEL_29;
      }
      uint64_t v13 = (void *)a1[31];
      if (v13)
      {
        [v13 getFormatStruct];
        *(_OWORD *)a3 = v23;
        *(_OWORD *)(a3 + 16) = v24;
        *(void *)(a3 + 32) = v25;
      }
      else
      {
        *(void *)(a3 + 32) = 0;
        *(_OWORD *)a3 = TSUInvalidFormat;
        *(_OWORD *)(a3 + 16) = unk_22383BEB8;
      }
      unint64_t result = (void *)a1[31];
      if (!result) {
        return result;
      }
      [result getFormatStruct];
      int v14 = v17;
      break;
    case 270:
    case 271:
    case 272:
      if (!a1) {
        goto LABEL_29;
      }
      int v7 = (void *)a1[29];
      if (v7)
      {
        [v7 getFormatStruct];
        *(_OWORD *)a3 = v23;
        *(_OWORD *)(a3 + 16) = v24;
        *(void *)(a3 + 32) = v25;
      }
      else
      {
        *(void *)(a3 + 32) = 0;
        *(_OWORD *)a3 = TSUInvalidFormat;
        *(_OWORD *)(a3 + 16) = unk_22383BEB8;
      }
      unint64_t result = (void *)a1[29];
      if (!result) {
        return result;
      }
      [result getFormatStruct];
      int v14 = v18;
      break;
    default:
      if ((a2 + 1) >= 3 && a2 != -999) {
        return result;
      }
LABEL_29:
      unint64_t result = 0;
      *(void *)(a3 + 32) = 0;
      *(_OWORD *)a3 = TSUInvalidFormat;
      *(_OWORD *)(a3 + 16) = unk_22383BEB8;
      return result;
  }
  return (void *)((v14 - 1) < 0xFFFFFFFE);
}

uint64_t TSTCellSetCellFormatStructBasedOnType(uint64_t result, long long *a2, int a3)
{
  uint64_t v4 = result;
  switch(*(_DWORD *)a2)
  {
    case 0x100:
    case 0x102:
    case 0x103:
    case 0x106:
      long long v42 = *a2;
      long long v43 = a2[1];
      uint64_t v44 = *((void *)a2 + 4);
      if (result)
      {
        long long v5 = a2[1];
        long long v51 = *a2;
        long long v52 = v5;
        uint64_t v53 = *((void *)a2 + 4);
        int v6 = *(void **)(result + 152);
        if (v6)
        {
          [v6 getFormatStruct];
        }
        else
        {
          uint64_t v50 = 0;
          long long v48 = 0u;
          long long v49 = 0u;
        }
        unint64_t result = TSUEqualFormatStructs((uint64_t)&v51, (uint64_t)&v48);
        if ((result & 1) == 0)
        {

          long long v45 = v42;
          long long v46 = v43;
          uint64_t v47 = v44;
          unint64_t result = [objc_alloc(MEMORY[0x263F7C850]) initWithTSUFormatFormatStruct:&v45];
          *(void *)(v4 + 152) = result;
          if (a3) {
            *(_DWORD *)(v4 + 144) = 0;
          }
        }
      }
      break;
    case 0x101:
      long long v39 = *a2;
      long long v40 = a2[1];
      uint64_t v41 = *((void *)a2 + 4);
      if (result)
      {
        long long v11 = a2[1];
        long long v51 = *a2;
        long long v52 = v11;
        uint64_t v53 = *((void *)a2 + 4);
        int v12 = *(void **)(result + 168);
        if (v12)
        {
          [v12 getFormatStruct];
        }
        else
        {
          uint64_t v50 = 0;
          long long v48 = 0u;
          long long v49 = 0u;
        }
        unint64_t result = TSUEqualFormatStructs((uint64_t)&v51, (uint64_t)&v48);
        if ((result & 1) == 0)
        {

          long long v45 = v39;
          long long v46 = v40;
          uint64_t v47 = v41;
          unint64_t result = [objc_alloc(MEMORY[0x263F7C850]) initWithTSUFormatFormatStruct:&v45];
          *(void *)(v4 + 168) = result;
          if (a3) {
            *(_DWORD *)(v4 + 160) = 0;
          }
        }
      }
      break;
    case 0x105:
      long long v36 = *a2;
      long long v37 = a2[1];
      uint64_t v38 = *((void *)a2 + 4);
      if (result)
      {
        long long v13 = a2[1];
        long long v51 = *a2;
        long long v52 = v13;
        uint64_t v53 = *((void *)a2 + 4);
        int v14 = *(void **)(result + 200);
        if (v14)
        {
          [v14 getFormatStruct];
        }
        else
        {
          uint64_t v50 = 0;
          long long v48 = 0u;
          long long v49 = 0u;
        }
        unint64_t result = TSUEqualFormatStructs((uint64_t)&v51, (uint64_t)&v48);
        if ((result & 1) == 0)
        {

          long long v45 = v36;
          long long v46 = v37;
          uint64_t v47 = v38;
          unint64_t result = [objc_alloc(MEMORY[0x263F7C850]) initWithTSUFormatFormatStruct:&v45];
          *(void *)(v4 + 200) = result;
          if (a3) {
            *(_DWORD *)(v4 + 192) = 0;
          }
        }
      }
      break;
    case 0x108:
    case 0x109:
      long long v24 = *a2;
      long long v25 = a2[1];
      uint64_t v26 = *((void *)a2 + 4);
      if (result)
      {
        long long v9 = a2[1];
        long long v51 = *a2;
        long long v52 = v9;
        uint64_t v53 = *((void *)a2 + 4);
        int v10 = *(void **)(result + 216);
        if (v10)
        {
          [v10 getFormatStruct];
        }
        else
        {
          uint64_t v50 = 0;
          long long v48 = 0u;
          long long v49 = 0u;
        }
        unint64_t result = TSUEqualFormatStructs((uint64_t)&v51, (uint64_t)&v48);
        if ((result & 1) == 0)
        {

          long long v45 = v24;
          long long v46 = v25;
          uint64_t v47 = v26;
          unint64_t result = [objc_alloc(MEMORY[0x263F7C850]) initWithTSUFormatFormatStruct:&v45];
          *(void *)(v4 + 216) = result;
          if (a3) {
            *(_DWORD *)(v4 + 208) = 0;
          }
        }
      }
      break;
    case 0x10A:
      long long v21 = *a2;
      long long v22 = a2[1];
      uint64_t v23 = *((void *)a2 + 4);
      if (result)
      {
        long long v15 = a2[1];
        long long v51 = *a2;
        long long v52 = v15;
        uint64_t v53 = *((void *)a2 + 4);
        int v16 = *(void **)(result + 264);
        if (v16)
        {
          [v16 getFormatStruct];
        }
        else
        {
          uint64_t v50 = 0;
          long long v48 = 0u;
          long long v49 = 0u;
        }
        unint64_t result = TSUEqualFormatStructs((uint64_t)&v51, (uint64_t)&v48);
        if ((result & 1) == 0)
        {

          long long v45 = v21;
          long long v46 = v22;
          uint64_t v47 = v23;
          unint64_t result = [objc_alloc(MEMORY[0x263F7C850]) initWithTSUFormatFormatStruct:&v45];
          *(void *)(v4 + 264) = result;
          if (a3) {
            *(_DWORD *)(v4 + 256) = 0;
          }
        }
      }
      break;
    case 0x10C:
      long long v33 = *a2;
      long long v34 = a2[1];
      uint64_t v35 = *((void *)a2 + 4);
      if (result)
      {
        long long v17 = a2[1];
        long long v51 = *a2;
        long long v52 = v17;
        uint64_t v53 = *((void *)a2 + 4);
        int v18 = *(void **)(result + 184);
        if (v18)
        {
          [v18 getFormatStruct];
        }
        else
        {
          uint64_t v50 = 0;
          long long v48 = 0u;
          long long v49 = 0u;
        }
        unint64_t result = TSUEqualFormatStructs((uint64_t)&v51, (uint64_t)&v48);
        if ((result & 1) == 0)
        {

          long long v45 = v33;
          long long v46 = v34;
          uint64_t v47 = v35;
          unint64_t result = [objc_alloc(MEMORY[0x263F7C850]) initWithTSUFormatFormatStruct:&v45];
          *(void *)(v4 + 184) = result;
          if (a3) {
            *(_DWORD *)(v4 + 176) = 0;
          }
        }
      }
      break;
    case 0x10D:
      long long v27 = *a2;
      long long v28 = a2[1];
      uint64_t v29 = *((void *)a2 + 4);
      if (result)
      {
        long long v19 = a2[1];
        long long v51 = *a2;
        long long v52 = v19;
        uint64_t v53 = *((void *)a2 + 4);
        int v20 = *(void **)(result + 248);
        if (v20)
        {
          [v20 getFormatStruct];
        }
        else
        {
          uint64_t v50 = 0;
          long long v48 = 0u;
          long long v49 = 0u;
        }
        unint64_t result = TSUEqualFormatStructs((uint64_t)&v51, (uint64_t)&v48);
        if ((result & 1) == 0)
        {

          long long v45 = v27;
          long long v46 = v28;
          uint64_t v47 = v29;
          unint64_t result = [objc_alloc(MEMORY[0x263F7C850]) initWithTSUFormatFormatStruct:&v45];
          *(void *)(v4 + 248) = result;
          if (a3) {
            *(_DWORD *)(v4 + 240) = 0;
          }
        }
      }
      break;
    case 0x10E:
    case 0x10F:
    case 0x110:
      long long v30 = *a2;
      long long v31 = a2[1];
      uint64_t v32 = *((void *)a2 + 4);
      if (result)
      {
        long long v7 = a2[1];
        long long v51 = *a2;
        long long v52 = v7;
        uint64_t v53 = *((void *)a2 + 4);
        int v8 = *(void **)(result + 232);
        if (v8)
        {
          [v8 getFormatStruct];
        }
        else
        {
          uint64_t v50 = 0;
          long long v48 = 0u;
          long long v49 = 0u;
        }
        unint64_t result = TSUEqualFormatStructs((uint64_t)&v51, (uint64_t)&v48);
        if ((result & 1) == 0)
        {

          long long v45 = v30;
          long long v46 = v31;
          uint64_t v47 = v32;
          unint64_t result = [objc_alloc(MEMORY[0x263F7C850]) initWithTSUFormatFormatStruct:&v45];
          *(void *)(v4 + 232) = result;
          if (a3) {
            *(_DWORD *)(v4 + 224) = 0;
          }
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t TSTCellMostRecentlySetNumberFormatType(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 96) >> 11) & 3;
}

uint64_t TSTCellMostRecentlySetDateFormatType(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 96) >> 13) & 1;
}

uint64_t TSTCellMostRecentlySetTextFormatType(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 96) >> 14) & 1;
}

uint64_t TSTCellSetFormatFlagsFromFormat(uint64_t result, int *a2, int a3, int a4)
{
  int v4 = *a2;
  if (result) {
    int v5 = *(_DWORD *)(result + 104);
  }
  else {
    int v5 = -1;
  }
  if (v4 == v5)
  {
    if (a3) {
      __int16 v6 = 16;
    }
    else {
      __int16 v6 = 0;
    }
    *(_WORD *)(result + 96) = *(_WORD *)(result + 96) & 0xFFEF | v6;
  }
  switch(v4)
  {
    case 256:
    case 258:
    case 259:
    case 262:
      __int16 v7 = *(_WORD *)(result + 96) & 0xFFFE | a3;
      *(_WORD *)(result + 96) = v7;
      if (a4)
      {
        __int16 v8 = v7 & 0xE7FF;
        break;
      }
      return result;
    case 257:
      if (a3) {
        __int16 v12 = 2;
      }
      else {
        __int16 v12 = 0;
      }
      __int16 v13 = *(_WORD *)(result + 96) & 0xFFFD | v12;
      *(_WORD *)(result + 96) = v13;
      if (a4)
      {
        __int16 v8 = v13 & 0xE7FF | 0x800;
        break;
      }
      return result;
    case 260:
      if (a4)
      {
        __int16 v8 = *(_WORD *)(result + 96) & 0xBFFF;
        break;
      }
      return result;
    case 261:
      if (a3) {
        __int16 v14 = 8;
      }
      else {
        __int16 v14 = 0;
      }
      __int16 v15 = *(_WORD *)(result + 96) & 0xFFF7 | v14;
      *(_WORD *)(result + 96) = v15;
      if (a4)
      {
        __int16 v8 = v15 & 0xDFFF;
        break;
      }
      return result;
    case 264:
    case 265:
      __int16 v9 = *(_WORD *)(result + 96) & 0xFFBF;
      BOOL v10 = a3 == 0;
      __int16 v11 = 64;
      goto LABEL_27;
    case 266:
      __int16 v9 = *(_WORD *)(result + 96) & 0xFBFF;
      BOOL v10 = a3 == 0;
      __int16 v11 = 1024;
      goto LABEL_27;
    case 268:
      __int16 v9 = *(_WORD *)(result + 96) & 0xFFFB;
      BOOL v10 = a3 == 0;
      __int16 v11 = 4;
LABEL_27:
      if (v10) {
        __int16 v11 = 0;
      }
      __int16 v8 = v9 | v11;
      break;
    case 269:
      if (a3) {
        __int16 v16 = 512;
      }
      else {
        __int16 v16 = 0;
      }
      __int16 v17 = *(_WORD *)(result + 96) & 0xFDFF | v16;
      *(_WORD *)(result + 96) = v17;
      if (!a4) {
        return result;
      }
      __int16 v8 = v17 & 0xE7FF | 0x1000;
      break;
    case 270:
      if (a3) {
        __int16 v18 = 256;
      }
      else {
        __int16 v18 = 0;
      }
      __int16 v19 = *(_WORD *)(result + 96) & 0xFEFF | v18;
      *(_WORD *)(result + 96) = v19;
      if (!a4) {
        return result;
      }
      __int16 v8 = v19 | 0x1800;
      break;
    case 271:
      if (a3) {
        __int16 v22 = 256;
      }
      else {
        __int16 v22 = 0;
      }
      __int16 v23 = *(_WORD *)(result + 96) & 0xFEFF | v22;
      *(_WORD *)(result + 96) = v23;
      if (!a4) {
        return result;
      }
      __int16 v8 = v23 | 0x4000;
      break;
    case 272:
      if (a3) {
        __int16 v20 = 256;
      }
      else {
        __int16 v20 = 0;
      }
      __int16 v21 = *(_WORD *)(result + 96) & 0xFEFF | v20;
      *(_WORD *)(result + 96) = v21;
      if (!a4) {
        return result;
      }
      __int16 v8 = v21 | 0x2000;
      break;
    default:
      return result;
  }
  *(_WORD *)(result + 96) = v8;
  return result;
}

uint64_t TSTCellSetExplicitFormat(uint64_t a1, uint64_t a2)
{
  long long v4 = *(_OWORD *)(a2 + 16);
  v9[0] = *(_OWORD *)a2;
  v9[1] = v4;
  uint64_t v10 = *(void *)(a2 + 32);
  TSTCellSetFormatClearingID(a1, (uint64_t)v9, 1);
  long long v5 = *(_OWORD *)(a2 + 16);
  v7[0] = *(_OWORD *)a2;
  v7[1] = v5;
  uint64_t v8 = *(void *)(a2 + 32);
  return TSTCellSetFormatFlagsFromFormat(a1, (int *)v7, 1, 1);
}

uint64_t TSTCellSetImplicitFormatForFormulaResult(uint64_t a1, uint64_t a2, int a3)
{
  long long v6 = *(_OWORD *)(a2 + 16);
  v12[0] = *(_OWORD *)a2;
  v12[1] = v6;
  uint64_t v13 = *(void *)(a2 + 32);
  TSTCellSetFormatClearingID(a1, (uint64_t)v12, 1);
  long long v7 = *(_OWORD *)(a2 + 16);
  v10[0] = *(_OWORD *)a2;
  v10[1] = v7;
  uint64_t v11 = *(void *)(a2 + 32);
  uint64_t result = TSTCellSetFormatFlagsFromFormat(a1, (int *)v10, 0, 0);
  if (a3) {
    __int16 v9 = 0x8000;
  }
  else {
    __int16 v9 = 0;
  }
  *(_WORD *)(a1 + 96) = v9 & 0x8000 | *(_WORD *)(a1 + 96) & 0x7FFF;
  return result;
}

__CFString *NSStringFromNativeTSTCell(__CFString *result)
{
  p_int info = (long long *)&result[3].info;
  if (!result) {
    p_int info = &TSUInvalidFormat;
  }
  long long v2 = p_info[1];
  long long v43 = *p_info;
  long long v44 = v2;
  uint64_t v45 = *((void *)p_info + 4);
  if (result)
  {
    uint64_t v3 = (uint64_t)result;
    int info = result->info;
    if (BYTE1(info) > 9u)
    {
LABEL_12:
      long long v5 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v6 = [NSString stringWithUTF8String:"NSString *NSStringFromNativeTSTCell(TSTCell *)"];
      objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.mm"), 1081, @"Impossible cell value type reached.", v39);
      return 0;
    }
    else
    {
      uint64_t result = 0;
      switch(BYTE1(info))
      {
        case 1:
        case 4:
          goto LABEL_12;
        case 2:
          if (v43 == 262 || (v43 & 0xFFFFFFFC) == 0x100)
          {
            if ((info & 0xFB00) != 0x200 && BYTE1(info) != 7)
            {
              if (BYTE1(info))
              {
                long long v25 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
                uint64_t v26 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
                objc_msgSend(v25, "handleFailureInFunction:file:lineNumber:description:", v26, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", v3);
              }
            }
          }
          else
          {
            if ((v43 - 264) < 2)
            {
              uint64_t v42 = 0;
              long long v40 = 0u;
              long long v41 = 0u;
              LODWORD(v40) = -1;
              TSTCellGetFormatOfType((void *)v3, v45, (uint64_t)&v40);
            }
            else
            {
              if (v43 == 270)
              {
                if ((void)v44)
                {
                  TSTCellDoubleValue((TSTCell *)v3);
                  return (__CFString *)TSUFormatCustomStringFromDouble();
                }
                long long v36 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
                uint64_t v37 = [NSString stringWithUTF8String:"NSString *NSStringFromNativeTSTCell(TSTCell *)"];
                objc_msgSend(v36, "handleFailureInFunction:file:lineNumber:description:", v37, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.mm"), 985, @"Custom format has not been populated!");
              }
              else if (v43 == 269)
              {
                TSTCellDoubleValue((TSTCell *)v3);
                return (__CFString *)TSUFormatBaseStringFromDouble();
              }
              LODWORD(v40) = 256;
              uint64_t v38 = ((*MEMORY[0x263F7C948] & 7) << 8) | 0xFD;
              *((void *)&v40 + 1) = 0;
              *(void *)&long long v41 = v38;
            }
            TSTCellDoubleValue((TSTCell *)v3);
          }
          return (__CFString *)TSUFormatStructStringFromDouble();
        case 3:
          if (v43 != 271) {
            return *(__CFString **)(v3 + 24);
          }
          if ((void)v44 && *(void *)(v44 + 8))
          {
            uint64_t v7 = *(void *)(v3 + 24);
            return (__CFString *)MEMORY[0x270F79958](v7);
          }
          __int16 v21 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v22 = [NSString stringWithUTF8String:"NSString *NSStringFromNativeTSTCell(TSTCell *)"];
          objc_msgSend(v21, "handleFailureInFunction:file:lineNumber:description:", v22, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.mm"), 972, @"Custom format string has not been populated!");
          int v23 = *(unsigned __int8 *)(v3 + 9);
          if (!*(unsigned char *)(v3 + 9)) {
            return &stru_26D688A48;
          }
          if (v23 == 9)
          {
LABEL_56:
            long long v24 = *(void **)(v3 + 72);
            return (__CFString *)[v24 string];
          }
          if (v23 == 3) {
            return *(__CFString **)(v3 + 24);
          }
          uint64_t v32 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v33 = [NSString stringWithUTF8String:"NSString *TSTCellStringValue(TSTCell *)"];
          objc_msgSend(v32, "handleFailureInFunction:file:lineNumber:description:", v33, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, @"can't get string from non-string cell: %p", v3);
          return 0;
        case 5:
          if (v43 != 272)
          {
            if (v43 == 261)
            {
              uint64_t v8 = v44;
              if ((BYTE8(v43) & 2) != 0)
              {
                uint64_t v9 = [MEMORY[0x263F7C820] datePortionOfDateTimeFormatString:(void)v44];
              }
              else
              {
                if ((BYTE8(v43) & 1) == 0) {
                  goto LABEL_68;
                }
                uint64_t v9 = [MEMORY[0x263F7C820] timePortionOfDateTimeFormatString:(void)v44];
              }
              uint64_t v8 = v9;
LABEL_68:
              if (*(unsigned char *)(v3 + 9))
              {
                if (*(unsigned char *)(v3 + 9) == 5)
                {
                  uint64_t v19 = *(void *)(v3 + 16);
LABEL_73:
                  uint64_t v20 = v8;
                  goto LABEL_81;
                }
                long long v30 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
                uint64_t v31 = [NSString stringWithUTF8String:"NSDate *TSTCellDateValue(TSTCell *)"];
                objc_msgSend(v30, "handleFailureInFunction:file:lineNumber:description:", v31, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 1021, @"can't get date value from a non-date cell: %p", v3);
              }
              uint64_t v19 = 0;
              goto LABEL_73;
            }
            goto LABEL_64;
          }
          if ((void)v44 && *(void *)(v44 + 8))
          {
            uint64_t v19 = TSTCellDateValue(v3);
            uint64_t v20 = *(void *)(v44 + 8);
            goto LABEL_81;
          }
          long long v27 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v28 = [NSString stringWithUTF8String:"NSString *NSStringFromNativeTSTCell(TSTCell *)"];
          objc_msgSend(v27, "handleFailureInFunction:file:lineNumber:description:", v28, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.mm"), 1044, @"Custom format string has not been populated!");
          if (*(unsigned char *)(v3 + 9))
          {
            if (*(unsigned char *)(v3 + 9) == 5)
            {
LABEL_64:
              uint64_t v29 = *(void *)(v3 + 16);
              goto LABEL_80;
            }
            long long v34 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v35 = [NSString stringWithUTF8String:"NSDate *TSTCellDateValue(TSTCell *)"];
            objc_msgSend(v34, "handleFailureInFunction:file:lineNumber:description:", v35, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 1021, @"can't get date value from a non-date cell: %p", v3);
          }
          uint64_t v29 = 0;
LABEL_80:
          uint64_t v20 = [MEMORY[0x263F7C820] defaultDateTimeFormat];
          uint64_t v19 = v29;
LABEL_81:
          uint64_t result = (__CFString *)MEMORY[0x270F79830](v19, v20);
          break;
        case 6:
          if ((info & 0xFB00) == 0x200 || BYTE1(info) == 7)
          {
            if (*(double *)(v3 + 16) != 0.0)
            {
              uint64_t v11 = (void *)TSTBundle();
              __int16 v12 = @"TRUE";
              goto LABEL_41;
            }
          }
          else if (BYTE1(info))
          {
            __int16 v14 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v15 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
            objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", v15, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", v3);
          }
          uint64_t v11 = (void *)TSTBundle();
          __int16 v12 = @"FALSE";
LABEL_41:
          return (__CFString *)[v11 localizedStringForKey:v12 value:&stru_26D688A48 table:@"TSTables"];
        case 7:
          unint64_t v16 = *(void *)(v3 + 16);
          if (*(unsigned char *)(v3 + 112))
          {
            TSUDurationFormatterDurationUnitsNecessaryToFullyDisplayDuration();
            TSUDurationFormatterMaxDurationUnitInUnits();
            TSUDurationFormatterMinDurationUnitInUnits();
          }
          uint64_t v17 = TSUDurationFormatterFormatFromDurationUnits();
          v18.n128_u64[0] = v16;
          return (__CFString *)MEMORY[0x270F79878](v17, v18);
        case 9:
          goto LABEL_56;
        default:
          return result;
      }
    }
  }
  return result;
}

__CFString *NSStringForUnderlyingValueWithTSTCell(__CFString *result)
{
  if (result) {
    p_int info = (long long *)&result[3].info;
  }
  else {
    p_int info = &TSUInvalidFormat;
  }
  if (result)
  {
    long long v2 = result;
    int info = result->info;
    if (BYTE1(info))
    {
      if (BYTE1(info) != 2) {
        goto LABEL_12;
      }
      int v4 = *(_DWORD *)p_info;
      int v5 = *((_DWORD *)p_info + 8);
      if ((v4 & 0xFFFFFFFE) != 0x108) {
        int v5 = v4;
      }
      if ((v5 | 4) == 0x106)
      {
        LODWORD(v8) = 256;
        unint64_t v9 = ((unint64_t)(*MEMORY[0x263F7C948] & 7) << 8) | 0xFD;
        if ((result->info & 0xFB00) != 0x200)
        {
          uint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v7 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
          objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", v2, v8, 0, v9);
        }
        return (__CFString *)TSUFormatStructStringFromDouble();
      }
      else
      {
LABEL_12:
        return NSStringForEditingWithTSTCell((TSTCell *)result);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

__CFString *NSStringForEditingWithTSTCell(TSTCell *a1)
{
  p_mCurrentCellFormat = ($F03D4CA5AAEDD23196D77D4402B24C2D *)&TSUInvalidFormat;
  if (a1) {
    p_mCurrentCellFormat = &a1->mPrivate.mCellFormats.mCurrentCellFormat;
  }
  long long v3 = *(_OWORD *)&p_mCurrentCellFormat->var0.mMultipleChoiceListFormatStruct.mData;
  long long v24 = *(_OWORD *)&p_mCurrentCellFormat->mFormatType;
  long long v25 = v3;
  uint64_t v26 = *((void *)&p_mCurrentCellFormat->var0.mMultipleChoiceListFormatStruct + 3);
  if ((v24 & 0xFFFFFFFE) == 0x108) {
    TSTCellGetFormatOfType(a1, v26, (uint64_t)&v24);
  }
  if (a1)
  {
    int mPrivate = (int)a1->mPrivate;
    if (BYTE1(mPrivate) > 9u)
    {
LABEL_15:
      uint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v7 = [NSString stringWithUTF8String:"NSString *NSStringForEditingWithTSTCell(TSTCell *)"];
      objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.mm"), 1243, @"Impossible cell value type reached.");
      return 0;
    }
    else
    {
      uint64_t result = 0;
      switch(BYTE1(mPrivate))
      {
        case 1:
        case 4:
          goto LABEL_15;
        case 2:
          if (v24 == 256)
          {
            LOWORD(v25) = v25 & 0xF800 | 0xFD;
            if ((mPrivate & 0xFB00) != 0x200 && BYTE1(mPrivate) != 7)
            {
              if (BYTE1(mPrivate))
              {
                uint64_t v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
                uint64_t v9 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
                objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", a1);
              }
            }
          }
          else if ((v24 - 270) > 2)
          {
            switch((int)v24)
            {
              case 257:
                __int16 v19 = v25 & 0xE800;
                goto LABEL_46;
              case 258:
                __int16 v19 = v25 & 0xF800;
LABEL_46:
                LOWORD(v25) = v19 | 0xFD;
                goto LABEL_47;
              case 259:
              case 262:
                goto LABEL_47;
              case 260:
              case 261:
                goto LABEL_42;
              default:
                if (v24 == 269) {
                  goto LABEL_47;
                }
LABEL_42:
                if ((v24 - 263) <= 4) {
                  goto LABEL_8;
                }
                uint64_t v20 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
                uint64_t v21 = [NSString stringWithUTF8String:"NSString *NSStringForEditingWithTSTCell(TSTCell *)"];
                objc_msgSend(v20, "handleFailureInFunction:file:lineNumber:description:", v21, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.mm"), 1202, @"Attempting to display unknown number format in editor. Defaulting to decimal type");
LABEL_47:
                TSTCellDoubleValue(a1);
                break;
            }
          }
          else
          {
            LODWORD(v22) = 256;
            unint64_t v23 = ((unint64_t)(*MEMORY[0x263F7C948] & 7) << 8) | 0xFD;
            if ((*(_DWORD *)&a1->mPrivate & 0xFB00) != 0x200 && BYTE1(mPrivate) != 7 && BYTE1(mPrivate))
            {
              __int16 v12 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
              uint64_t v13 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
              objc_msgSend(v12, "handleFailureInFunction:file:lineNumber:description:", v13, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", a1, v22, 0, v23);
            }
          }
          uint64_t result = (__CFString *)TSUFormatStructStringFromDouble();
          break;
        case 3:
          uint64_t result = (__CFString *)a1->mPrivate.mValue.mString.mString;
          break;
        case 5:
          mDate = a1->mPrivate.mValue.mDate;
          uint64_t v11 = TSUShortestCompleteDateTimeFormat();
          uint64_t result = (__CFString *)MEMORY[0x270F79830](mDate, v11);
          break;
        case 6:
        case 9:
LABEL_8:
          uint64_t result = NSStringFromNativeTSTCell((__CFString *)a1);
          break;
        case 7:
          __int16 v14 = a1->mPrivate.mValue.mDate;
          if ((*(_WORD *)&a1->mPrivate.mCellFormats & 0x10) != 0)
          {
            uint64_t v17 = TSUDurationFormatterFormatFromDurationUnits();
            v18.n128_u64[0] = (unint64_t)v14;
            uint64_t result = (__CFString *)MEMORY[0x270F79888](v17, v18);
          }
          else
          {
            TSUDurationFormatterDurationUnitsNecessaryToFullyDisplayDuration();
            TSUDurationFormatterMaxDurationUnitInUnits();
            TSUDurationFormatterMinDurationUnitInUnits();
            uint64_t v15 = TSUDurationFormatterFormatFromDurationUnits();
            v16.n128_u64[0] = (unint64_t)v14;
            uint64_t result = (__CFString *)MEMORY[0x270F79878](v15, v16);
          }
          break;
        case 8:
          return result;
        default:
          goto LABEL_11;
      }
    }
  }
  else
  {
LABEL_11:
    if (v24 == 258) {
      return @"%";
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t TSTCellCustomFormatString(uint64_t a1)
{
  uint64_t v1 = &TSUInvalidFormat;
  if (a1) {
    uint64_t v1 = (long long *)(a1 + 104);
  }
  if ((*(_DWORD *)v1 - 270) < 3) {
    return *(void *)(*((void *)v1 + 2) + 8);
  }
  long long v3 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
  uint64_t v4 = [NSString stringWithUTF8String:"NSString *TSTCellCustomFormatString(TSTCell *)"];
  objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.mm"), 1253, @"Can't get a custom format string for a non-custom format.");
  return 0;
}

id TSTCellRichTextStorageForLayout(uint64_t a1)
{
  if (!a1 || *(unsigned __int8 *)(a1 + 9) << 8 != 2304) {
    return 0;
  }
  long long v2 = (void *)[*(id *)(a1 + 72) storage];
  id v3 = v2;
  if (*(_DWORD *)(a1 + 104) == 271)
  {
    id v3 = (id)objc_msgSend(v2, "copyWithContext:", objc_msgSend(v2, "context"));
    uint64_t v4 = *(void *)(a1 + 120);
    uint64_t v5 = [*(id *)(v4 + 8) rangeOfString:objc_msgSend(NSString, "stringWithFormat:", @"%C", (unsigned __int16)*MEMORY[0x263F7C908])];
    uint64_t v6 = [*(id *)(v4 + 8) substringToIndex:v5];
    uint64_t v7 = [*(id *)(v4 + 8) substringFromIndex:v5 + 1];
    if (v6) {
      [v3 insertString:v6 atCharIndex:0 undoTransaction:0];
    }
    if (v7) {
      objc_msgSend(v3, "insertString:atCharIndex:undoTransaction:", v7, objc_msgSend(v3, "length"), 0);
    }
  }
  return v3;
}

void *TSTCellFormatUsesAccountingStyle(void *result)
{
  uint64_t v1 = &TSUInvalidFormat;
  if (result) {
    uint64_t v1 = (long long *)(result + 13);
  }
  int v2 = *(_DWORD *)v1;
  if ((*(_DWORD *)v1 - 264) >= 2)
  {
    unint64_t v3 = *((void *)v1 + 2);
    if (v2 == 270)
    {
      if (v3) {
        return (void *)((*(unsigned __int8 *)(v3 + 56) >> 1) & 1);
      }
      uint64_t v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v5 = [NSString stringWithUTF8String:"BOOL TSUFormatGetCustomNumberFormatUseAccountingStyle(const TSUFormatStruct)"];
      objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Binaries/AlderShared/install/Root/usr/local/include/TSFrameworks/TSUtility/TSUFormatTypes.h"), 635, @"Custom format is not correctly populated.");
    }
    else if (v2 == 257)
    {
      return (void *)((v3 >> 12) & 1);
    }
    return 0;
  }
  if (*((_DWORD *)v1 + 8) != 257) {
    return 0;
  }
  if (result)
  {
    uint64_t result = (void *)result[21];
    if (result)
    {
      objc_msgSend(result, "getFormatStruct", (unsigned __int128)0);
      return 0;
    }
  }
  return result;
}

BOOL p_defaultAlignmentForTableWritingDirection(TSTTableModel *a1)
{
  return [(TSSStyle *)[(TSTTableModel *)a1 tableStyle] intValueForProperty:798] == 1;
}

void *TSTCellTextProperties(uint64_t a1, void *a2, unsigned int a3, BOOL *a4, _DWORD *a5, _DWORD *a6, uint64_t *a7)
{
  if (a5)
  {
    if (!a1
      || (*(unsigned __int8 *)(a1 + 9) << 8 != 2304
       || (__int16 v14 = objc_msgSend((id)objc_msgSend(*(id *)(a1 + 72), "storage"), "paragraphStyleAtCharIndex:effectiveRange:", 0, 0)) == 0)&& (__int16 v14 = *(void **)(a1 + 56)) == 0)
    {
      __int16 v14 = (void *)TSTTableDefaultTextStyleForCellID(a2, a3);
    }
    if (a4) {
      goto LABEL_12;
    }
LABEL_10:
    if (!a6 && !a7) {
      goto LABEL_29;
    }
    goto LABEL_12;
  }
  __int16 v14 = 0;
  if (!a4) {
    goto LABEL_10;
  }
LABEL_12:
  if (a1 && (int CellStyleAtCellID = *(void **)(a1 + 40)) != 0
    || (int CellStyleAtCellID = (void *)TSTTableGetCellStyleAtCellID((uint64_t *)a2, a3, 0)) != 0)
  {
    if (a6)
    {
      *a6 = 1;
      int v16 = [CellStyleAtCellID intValueForProperty:903];
      if (v16 != 0x80000000) {
        *a6 = v16;
      }
    }
    if (a4)
    {
      if ((*a4 = 0, a1) && ((int v17 = *(unsigned __int8 *)(a1 + 9), v17 == 3) || v17 == 9)
        || *(_DWORD *)(a1 + 100) && *(_DWORD *)(a1 + 104) == 266)
      {
        int v18 = [CellStyleAtCellID intValueForProperty:896];
        if (v18 != 0x80000000) {
          *a4 = v18 != 0;
        }
      }
    }
    if (a7)
    {
      uint64_t v19 = [CellStyleAtCellID valueForProperty:904];
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        *a7 = v19;
      }
    }
  }
LABEL_29:
  if (a5)
  {
    if (v14)
    {
      *a5 = objc_msgSend((id)objc_msgSend(a2, "tableStyle"), "intValueForProperty:", 798) == 1;
      int v20 = [v14 intValueForProperty:86];
      if (v20 != 0x80000000)
      {
        *a5 = v20;
        if (v20 == 4)
        {
          int v21 = [v14 intValueForProperty:44];
          if (v21 == 1)
          {
            *a5 = 1;
          }
          else if (!v21)
          {
            *a5 = 0;
          }
        }
        else if (v20 == 3 && a4)
        {
          *a4 = 1;
        }
      }
    }
  }
  uint64_t result = TSTCellFormatUsesAccountingStyle((void *)a1);
  if (result)
  {
    if (a5) {
      *a5 = 0;
    }
    if (a4) {
      *a4 = 0;
    }
  }
  return result;
}

uint64_t TSTCellGetCellFill(void *a1)
{
  if (a1) {
    a1 = (void *)a1[5];
  }
  return [a1 valueForProperty:898];
}

void *TSTCellGetCellFillAndIsDefault(void *a1, void *a2, uint64_t a3, char *a4)
{
  if (a1) {
    a1 = (void *)a1[5];
  }
  uint64_t v6 = (void *)[a1 valueForProperty:898];
  if (!v6 || (uint64_t v7 = v6, ([v6 isEqual:a2] & 1) != 0))
  {
    if (!a4) {
      return a2;
    }
    char v8 = 1;
    uint64_t v7 = a2;
    goto LABEL_9;
  }
  if (a4)
  {
    char v8 = 0;
LABEL_9:
    *a4 = v8;
  }
  return v7;
}

TSTRichTextPayload *TSTCellSetRichTextPayloadClearingIDConvertToPlaintext(TSTRichTextPayload *result, TSTRichTextPayload *a2, int a3, int a4)
{
  uint64_t v7 = (uint64_t)result;
  if (!a2)
  {
    char v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellSetRichTextPayloadClearingIDConvertToPlaintext(TSTCell *, TSTRichTextPayload *, BOOL, BOOL)");
    uint64_t result = (TSTRichTextPayload *)objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.mm"), 1907, @"expected rich text payload but didn't get it");
  }
  int v10 = *(_DWORD *)(v7 + 8);
  if ((v10 & 0xFF00) != 0x900 || *(TSTRichTextPayload **)(v7 + 72) != a2)
  {
    if (!a4)
    {
LABEL_8:
      if ((v10 & 0xFF00) == 0x900) {
        int v11 = *(_DWORD *)(v7 + 64);
      }
      else {
        int v11 = 0;
      }
      TSTCellClearValue(v7);
      *(unsigned char *)(v7 + 9) = 9;
      uint64_t result = a2;
      *(void *)(v7 + 72) = result;
      if (a3) {
        *(_DWORD *)(v7 + 64) = 0;
      }
      else {
        *(_DWORD *)(v7 + 64) = v11;
      }
      return result;
    }
    if ([(TSTRichTextPayload *)a2 requiresRichText])
    {
      int v10 = *(_DWORD *)(v7 + 8);
      goto LABEL_8;
    }
    TSTCellClearValue(v7);
    *(unsigned char *)(v7 + 9) = 3;
    TSTCellSetStringValueClearingID((TSTCell *)v7, (NSString *)[(TSTRichTextPayload *)a2 string], a3);
    uint64_t result = [(TSWPStorage *)[(TSTRichTextPayload *)a2 storage] paragraphStyleAtCharIndex:0 effectiveRange:0];
    __int16 v12 = *(TSTRichTextPayload **)(v7 + 56);
    if (v12 != result)
    {
      uint64_t v13 = result;

      uint64_t result = v13;
      *(void *)(v7 + 56) = result;
      *(_DWORD *)(v7 + 48) = 0;
    }
  }
  return result;
}

void TSTCellSetStringValueClearingID(TSTCell *a1, NSString *a2, int a3)
{
  if (!a1 || (int mPrivate = (int)a1->mPrivate, (mPrivate & 0xFF00) == 0))
  {
    TSTCellClearValue((uint64_t)a1);
    int mPrivate = *(_DWORD *)&a1->mPrivate & 0xFFFF00FF | 0x300;
    *(_DWORD *)&a1->int mPrivate = mPrivate;
  }
  if ((mPrivate & 0xFF00) == 0x300)
  {
    mString = a1->mPrivate.mValue.mString.mString;
    if (mString != a2)
    {

      a1->mPrivate.mValue.mString.mString = a2;
      int v8 = HIWORD(*(_DWORD *)&a1->mPrivate);
      uint64_t v9 = -[NSString rangeOfCharacterFromSet:](a2, "rangeOfCharacterFromSet:", [MEMORY[0x263F08708] newlineCharacterSet]);
      __int16 v10 = v8 | 1;
      if (v9 == 0x7FFFFFFFFFFFFFFFLL) {
        __int16 v10 = v8 & 0xFFFE;
      }
      *((_WORD *)&a1->mPrivate + 1) = v10;
      if (a3) {
        a1->mPrivate.mValue.mString.mID = 0;
      }
    }
  }
  else
  {
    int v11 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v12 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellSetStringValueClearingID(TSTCell *, NSString *, BOOL)");
    objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 1003, @"can't set string on non-string cell: %p", a1);
  }
}

TSDCommentStorage *TSTCellSetCommentStorageClearingID(TSDCommentStorage *result, TSDCommentStorage *a2, int a3)
{
  uint64_t v5 = result;
  if (!a2)
  {
    uint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellSetCommentStorageClearingID(TSTCell *, TSDCommentStorage *, BOOL)");
    uint64_t result = (TSDCommentStorage *)objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.mm"), 1952, @"expected cell comment but didn't get it");
  }
  int v8 = (TSDCommentStorage *)*((void *)v5 + 11);
  if (v8 != a2)
  {

    uint64_t result = a2;
    *((void *)v5 + 11) = result;
    if (a3) {
      *((_DWORD *)v5 + 20) = 0;
    }
  }
  return result;
}

uint64_t TSTCellCoerceCellToFormat(TSTCell *a1, int a2)
{
  if (a1 && (int mPrivate = (int)a1->mPrivate, (mPrivate & 0xFF00) != 0))
  {
    int v5 = BYTE1(mPrivate) - 2;
    int mFormatType = a1->mPrivate.mCellFormats.mCurrentCellFormat.mFormatType;
    switch(v5)
    {
      case 0:
        if ((mFormatType & 0xFFFFFFFC) != 0x100
          && (mFormatType - 262) >= 6
          && (mFormatType - 269) >= 2)
        {
          goto LABEL_25;
        }
        break;
      case 1:
      case 7:
        if (mFormatType > 259)
        {
          if (mFormatType != 260 && mFormatType != 271) {
            goto LABEL_25;
          }
        }
        else if ((mFormatType + 1) >= 3 && mFormatType != -999)
        {
          goto LABEL_25;
        }
        break;
      case 3:
        if (mFormatType != 261 && mFormatType != 272) {
          goto LABEL_25;
        }
        break;
      case 4:
        if (mFormatType != 1 && mFormatType != 263) {
          goto LABEL_25;
        }
        break;
      case 5:
        if (mFormatType != 268)
        {
LABEL_25:
          int v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v9 = objc_msgSend(NSString, "stringWithUTF8String:", "BOOL TSTCellCoerceCellToFormat(TSTCell *, TSUFormatType)");
          objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.mm"), 1987, @"Attempting to coerce a cell with mismatched format and value types");
          uint64_t v10 = 0;
          int v11 = -1;
          unint64_t v12 = 0;
          switch(*((unsigned char *)&a1->mPrivate + 1))
          {
            case 2:
              uint64_t v10 = 0;
              unint64_t v12 = ((unint64_t)(*MEMORY[0x263F7C948] & 7) << 8) | 0xFD;
              int v11 = 256;
              break;
            case 3:
            case 9:
              uint64_t v10 = 0;
              unint64_t v12 = 0;
              int v11 = 260;
              break;
            case 5:
              unint64_t v12 = TSUDefaultDateTimeFormat();
              uint64_t v10 = 0;
              int v11 = 261;
              break;
            case 6:
              uint64_t v10 = 0;
              unint64_t v12 = 0;
              int v11 = 1;
              break;
            case 7:
              unint64_t v12 = ((unint64_t)*MEMORY[0x263F7C938] << 32) | 4;
              uint64_t v10 = 0x1000000001;
              int v11 = 268;
              break;
            default:
              break;
          }
          v15[0] = v11;
          v15[1] = 0;
          uint64_t v16 = v10;
          unint64_t v17 = v12;
          uint64_t v18 = 0;
          uint64_t v19 = 0;
          TSTCellSetImplicitFormat((uint64_t)a1, (uint64_t)v15);
        }
        break;
      default:
        break;
    }
    switch(a2)
    {
      case 256:
        uint64_t result = TSTCellCoerceCellToDecimalFormat((uint64_t)a1);
        break;
      case 257:
        uint64_t result = TSTCellCoerceCellToCurrencyFormat((uint64_t)a1);
        break;
      case 258:
        uint64_t result = TSTCellCoerceCellToPercentageFormat((uint64_t)a1);
        break;
      case 259:
        uint64_t result = TSTCellCoerceCellToScientificFormat((uint64_t)a1);
        break;
      case 260:
        uint64_t result = TSTCellCoerceCellToTextFormat(a1);
        break;
      case 261:
        uint64_t result = TSTCellCoerceCellToDateTimeFormat((uint64_t)a1);
        break;
      case 262:
        uint64_t result = TSTCellCoerceCellToFractionFormat((uint64_t)a1);
        break;
      case 263:
        uint64_t result = TSTCellCoerceCellToCheckboxFormat((uint64_t)a1);
        break;
      case 264:
        uint64_t v13 = a1;
        int v14 = 264;
        goto LABEL_59;
      case 265:
        uint64_t v13 = a1;
        int v14 = 265;
LABEL_59:
        uint64_t result = p_TSTCellCoerceCellToControlFormat((uint64_t)v13, v14);
        break;
      case 267:
        uint64_t result = TSTCellCoerceCellToRatingFormat((uint64_t)a1);
        break;
      case 268:
        uint64_t result = TSTCellCoerceCellToDurationFormat((uint64_t)a1);
        break;
      case 269:
        uint64_t result = TSTCellCoerceCellToBaseFormat((uint64_t)a1);
        break;
      case 270:
        uint64_t result = TSTCellCoerceCellToCustomNumberFormat((uint64_t)a1);
        break;
      case 271:
        uint64_t result = TSTCellCoerceCellToCustomTextFormat((__CFString *)a1);
        break;
      case 272:
        uint64_t result = TSTCellCoerceCellToCustomDateTimeFormat((uint64_t)a1);
        break;
      default:
        uint64_t result = 0;
        break;
    }
  }
  else
  {
    return TSTCellCoerceEmptyCellToFormat((uint64_t)a1, a2);
  }
  return result;
}

BOOL TSTCellCoerceEmptyCellToFormat(uint64_t a1, int a2)
{
  if (a1) {
    int v4 = *(_DWORD *)(a1 + 104);
  }
  else {
    int v4 = -1;
  }
  if (v4 != a2)
  {
    unint64_t v5 = 0;
    int v6 = 0;
    long long v24 = 0uLL;
    int v7 = -1;
    unsigned int v8 = 0;
    uint64_t v9 = 0;
    switch(a2)
    {
      case 254:
      case 266:
      case 270:
      case 271:
      case 272:
        goto LABEL_11;
      case 255:
        break;
      case 256:
        if (TSTCellCoerceCellToDecimalFormat(a1)) {
          return v4 != a2;
        }
        int v6 = 0;
        unsigned int v8 = 0;
        unint64_t v5 = 0;
        uint64_t v9 = ((unint64_t)(*MEMORY[0x263F7C948] & 7) << 8) | 0xFD;
        int v7 = 256;
        break;
      case 257:
        if (TSTCellCoerceCellToCurrencyFormat(a1)) {
          return v4 != a2;
        }
        uint64_t v13 = TSUDefaultFormatStructCurrency();
        uint64_t v9 = v14;
        unsigned int v8 = v13 & 0xFF000000;
        unint64_t v5 = (unint64_t)v13 & 0xFFFFFFFF00000000;
        int v6 = v13 & 0xFFFFFF;
        int v7 = 257;
        break;
      case 258:
        if (TSTCellCoerceCellToPercentageFormat(a1)) {
          return v4 != a2;
        }
        int v6 = 0;
        unsigned int v8 = 0;
        unint64_t v5 = 0;
        uint64_t v9 = ((unint64_t)(*MEMORY[0x263F7C948] & 7) << 8) | 0xFD;
        int v7 = 258;
        break;
      case 259:
        if (TSTCellCoerceCellToScientificFormat(a1)) {
          return v4 != a2;
        }
        int v6 = 0;
        unsigned int v8 = 0;
        unint64_t v5 = 0;
        uint64_t v9 = ((unint64_t)(*MEMORY[0x263F7C948] & 7) << 8) | 0xFD;
        int v7 = 259;
        break;
      case 260:
        int v6 = 0;
        unsigned int v8 = 0;
        unint64_t v5 = 0;
        uint64_t v9 = 0;
        int v7 = 260;
        break;
      case 261:
        uint64_t v9 = TSUDefaultDateTimeFormat();
        int v6 = 0;
        unsigned int v8 = 0;
        unint64_t v5 = 0;
        int v7 = 261;
        break;
      case 262:
        if (TSTCellCoerceCellToFractionFormat(a1)) {
          return v4 != a2;
        }
        unsigned int v8 = 0;
        unint64_t v5 = 0;
        uint64_t v9 = 0;
        int v6 = *MEMORY[0x263F7C940];
        int v7 = 262;
        break;
      case 263:
        TSTCellClearValue(a1);
        int v6 = 0;
        unsigned int v8 = 0;
        unint64_t v5 = 0;
        uint64_t v9 = 0;
        *(unsigned char *)(a1 + 9) = 6;
        *(void *)(a1 + 16) = 0;
        int v7 = 263;
        break;
      case 264:
      case 265:
        TSTCellClearValue(a1);
        *(unsigned char *)(a1 + 9) = 2;
        double v10 = 50.0;
        if (a2 == 264) {
          double v10 = 1.0;
        }
        *(double *)(a1 + 16) = v10;
        long long v24 = xmmword_22383BEE0;
        v19[3] = 0;
        v19[4] = 0;
        unint64_t v11 = ((unint64_t)(*MEMORY[0x263F7C948] & 7) << 8) | 0xFD;
        long long v20 = 0x100uLL;
        unint64_t v21 = v11;
        uint64_t v22 = 0;
        uint64_t v23 = 0;
        TSTCellSetCellFormatStructBasedOnType(a1, &v20, 1);
        v19[0] = 256;
        v19[1] = 0;
        v19[2] = v11;
        TSTCellSetFormatFlagsFromFormat(a1, (int *)v19, 1, 1);
        int v6 = 0;
        unsigned int v8 = 0;
        uint64_t v9 = 0x4059000000000000;
        unint64_t v5 = 0x3FF0000000000000;
        goto LABEL_12;
      case 267:
        TSTCellClearValue(a1);
        int v6 = 0;
        unsigned int v8 = 0;
        unint64_t v5 = 0;
        uint64_t v9 = 0;
        *(unsigned char *)(a1 + 9) = 2;
        *(void *)(a1 + 16) = 0;
        int v7 = 267;
        break;
      case 268:
        unsigned int v8 = 0;
        uint64_t v9 = ((unint64_t)*MEMORY[0x263F7C938] << 32) | 4;
        int v7 = 268;
        unint64_t v5 = 0x1000000000;
        int v6 = 1;
        break;
      case 269:
        if (TSTCellCoerceCellToBaseFormat(a1)) {
          return v4 != a2;
        }
        unsigned int v8 = 0;
        unint64_t v5 = 0;
        uint64_t v9 = 0;
        if (*MEMORY[0x263F7C930]) {
          int v6 = 65546;
        }
        else {
          int v6 = 10;
        }
        int v7 = 269;
        break;
      default:
        if ((a2 + 1) >= 3)
        {
          unsigned int v8 = 0;
          uint64_t v9 = 0;
          if (a2 != -999) {
            break;
          }
        }
LABEL_11:
        int v6 = 0;
        unsigned int v8 = 0;
        unint64_t v5 = 0;
        uint64_t v9 = 0;
LABEL_12:
        int v7 = a2;
        break;
    }
    v15[0] = v7;
    v15[1] = 0;
    unint64_t v16 = v5 | v8 | v6;
    uint64_t v17 = v9;
    long long v18 = v24;
    TSTCellSetImplicitFormat(a1, (uint64_t)v15);
  }
  return v4 != a2;
}

uint64_t TSTCellCoerceCellToDecimalFormat(uint64_t result)
{
  double v25 = 0.0;
  if (result)
  {
    uint64_t v1 = result;
    uint64_t result = 0;
    int v2 = (*MEMORY[0x263F7C948] & 7) << 8;
    unsigned int v3 = v2 | 0xFD;
    __int16 v4 = *(_WORD *)(v1 + 120);
    switch(*(_DWORD *)(v1 + 104))
    {
      case 0x101:
        unsigned int v3 = v4 & 0xF00 | 0xFD;
        goto LABEL_3;
      case 0x102:
        unsigned int v3 = v4 & 0xFFF;
        goto LABEL_3;
      case 0x103:
        unsigned int v3 = *(_WORD *)(v1 + 120) | v2;
        goto LABEL_3;
      case 0x104:
      case 0x10F:
        int v10 = *(unsigned __int8 *)(v1 + 9);
        if (*(unsigned char *)(v1 + 9))
        {
          if (v10 == 9)
          {
            [*(id *)(v1 + 72) string];
          }
          else if (v10 != 3)
          {
            unint64_t v21 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v22 = [NSString stringWithUTF8String:"NSString *TSTCellStringValue(TSTCell *)"];
            objc_msgSend(v21, "handleFailureInFunction:file:lineNumber:description:", v22, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, @"can't get string from non-string cell: %p", v1);
          }
        }
        int v24 = -999;
        if (TSUGetNumberValueAndTypeFromString())
        {
          unsigned int v3 = v2 | 0xFD;
          goto LABEL_12;
        }
        return 0;
      case 0x106:
      case 0x107:
      case 0x108:
      case 0x109:
      case 0x10D:
      case 0x10E:
LABEL_3:
        int v5 = *(_DWORD *)(v1 + 8);
        if ((v5 & 0xFB00) == 0x200 || BYTE1(v5) == 7)
        {
          double v7 = *(double *)(v1 + 16);
        }
        else
        {
          double v7 = 0.0;
          if (BYTE1(v5))
          {
            unsigned int v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v9 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
            objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", v1);
          }
        }
        double v25 = v7;
        goto LABEL_12;
      case 0x10B:
        int v11 = *(_DWORD *)(v1 + 8);
        if ((v11 & 0xFB00) != 0x200 && BYTE1(v11) != 7)
        {
          if (BYTE1(v11))
          {
            uint64_t v17 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v18 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
            objc_msgSend(v17, "handleFailureInFunction:file:lineNumber:description:", v18, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", v1);
          }
LABEL_48:
          double v25 = 0.0;
          goto LABEL_12;
        }
        double v13 = *(double *)(v1 + 16);
        double v25 = v13;
        if (v13 > 5.0)
        {
          double v25 = 5.0;
          goto LABEL_12;
        }
        if (v13 < 0.0) {
          goto LABEL_48;
        }
LABEL_12:
        v23[0] = 256;
        v23[1] = 0;
        v23[2] = v3;
        v23[3] = 0;
        v23[4] = 0;
        TSTCellSetImplicitFormat(v1, (uint64_t)v23);
        if (*(unsigned char *)(v1 + 9))
        {
          TSTCellClearValue(v1);
          *(unsigned char *)(v1 + 9) = 2;
          *(double *)(v1 + 16) = v25;
        }
        uint64_t result = 1;
        break;
      case 0x10C:
        int v14 = *(_DWORD *)(v1 + 8);
        if ((v14 & 0xFB00) == 0x200 || BYTE1(v14) == 7)
        {
          double v16 = *(double *)(v1 + 16);
        }
        else
        {
          double v16 = 0.0;
          if (BYTE1(v14))
          {
            uint64_t v19 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v20 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
            objc_msgSend(v19, "handleFailureInFunction:file:lineNumber:description:", v20, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", v1);
          }
        }
        double v25 = v16 / 86400.0;
        goto LABEL_12;
      default:
        return result;
    }
  }
  return result;
}

uint64_t TSTCellCoerceCellToCurrencyFormat(uint64_t a1)
{
  CFStringRef currencyCode = 0;
  uint64_t v51 = 0;
  long long v49 = 0uLL;
  CFLocaleRef v2 = (const __CFLocale *)TSUGetCurrentLocale();
  Value = (__CFString *)CFLocaleGetValue(v2, (CFLocaleKey)*MEMORY[0x263EFFCB8]);
  if (Value) {
    __int16 v4 = Value;
  }
  else {
    __int16 v4 = @"USD";
  }
  int32_t defaultFractionDigits = 0;
  int DecimalInfoForCurrencyCode = CFNumberFormatterGetDecimalInfoForCurrencyCode(v4, &defaultFractionDigits, 0);
  int v6 = v4;
  if (DecimalInfoForCurrencyCode) {
    __int16 v7 = defaultFractionDigits;
  }
  else {
    __int16 v7 = 2;
  }
  if (a1)
  {
    uint64_t v8 = 0;
    __int16 v9 = *MEMORY[0x263F7C948];
    unsigned __int16 v10 = v7 & 0xF8FF | ((*MEMORY[0x263F7C948] & 7) << 8);
    CFStringRef v11 = v6;
    uint64_t v12 = *(void *)(a1 + 120);
    switch(*(_DWORD *)(a1 + 104))
    {
      case 0x100:
      case 0x102:
        int v18 = *(_DWORD *)(a1 + 8);
        if ((v18 & 0xFB00) == 0x200 || (int v19 = BYTE1(v18), v19 == 7))
        {
          uint64_t v20 = *(void *)(a1 + 16);
        }
        else
        {
          uint64_t v20 = 0;
          if (v19)
          {
            unint64_t v21 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v22 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
            objc_msgSend(v21, "handleFailureInFunction:file:lineNumber:description:", v22, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", a1);
          }
        }
        uint64_t v51 = v20;
        unsigned __int16 v10 = v12 & 0xF00 | v7;
        goto LABEL_56;
      case 0x103:
      case 0x106:
      case 0x107:
      case 0x108:
      case 0x109:
      case 0x10D:
        int v13 = *(_DWORD *)(a1 + 8);
        if ((v13 & 0xFB00) == 0x200 || (int v14 = BYTE1(v13), v14 == 7))
        {
          uint64_t v15 = *(void *)(a1 + 16);
        }
        else
        {
          uint64_t v15 = 0;
          if (v14)
          {
            double v16 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v17 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
            objc_msgSend(v16, "handleFailureInFunction:file:lineNumber:description:", v17, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", a1);
          }
        }
        uint64_t v51 = v15;
        goto LABEL_56;
      case 0x104:
      case 0x10F:
        int v23 = *(unsigned __int8 *)(a1 + 9);
        if (*(unsigned char *)(a1 + 9))
        {
          if (v23 == 9)
          {
            [*(id *)(a1 + 72) string];
          }
          else if (v23 != 3)
          {
            uint64_t v33 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v34 = [NSString stringWithUTF8String:"NSString *TSTCellStringValue(TSTCell *)"];
            objc_msgSend(v33, "handleFailureInFunction:file:lineNumber:description:", v34, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, @"can't get string from non-string cell: %p", a1);
          }
        }
        int32_t defaultFractionDigits = -999;
        if (!TSUGetNumberValueAndTypeFromString() || defaultFractionDigits == -999) {
          goto LABEL_44;
        }
        if (defaultFractionDigits == 1)
        {
          int32_t v48 = 0;
          int v35 = CFNumberFormatterGetDecimalInfoForCurrencyCode(currencyCode, &v48, 0);
          __int16 v36 = v48;
          if (v48 >= 0xFF) {
            __int16 v36 = 255;
          }
          if (!v35) {
            __int16 v36 = 2;
          }
          unsigned __int16 v10 = v36 | ((v9 & 7) << 8);
          CFStringRef v11 = currencyCode;
        }
        goto LABEL_56;
      case 0x10B:
        int v24 = *(_DWORD *)(a1 + 8);
        if ((v24 & 0xFB00) != 0x200)
        {
          int v25 = BYTE1(v24);
          if (v25 != 7)
          {
            if (v25)
            {
              uint64_t v26 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
              uint64_t v27 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
              objc_msgSend(v26, "handleFailureInFunction:file:lineNumber:description:", v27, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", a1);
            }
LABEL_55:
            uint64_t v51 = 0;
            goto LABEL_56;
          }
        }
        double v37 = *(double *)(a1 + 16);
        uint64_t v51 = *(void *)&v37;
        if (v37 > 5.0)
        {
          uint64_t v51 = 0x4014000000000000;
          goto LABEL_56;
        }
        if (v37 < 0.0) {
          goto LABEL_55;
        }
LABEL_56:
        v46[0] = 257;
        v46[1] = v11;
        _OWORD v46[2] = v10;
        long long v47 = v49;
        TSTCellSetImplicitFormat(a1, (uint64_t)v46);
        if (*(unsigned char *)(a1 + 9))
        {
          TSTCellClearValue(a1);
          *(unsigned char *)(a1 + 9) = 2;
          *(void *)(a1 + 16) = v51;
        }
        uint64_t v8 = 1;
        break;
      case 0x10E:
        int v28 = *(_DWORD *)(a1 + 8);
        if ((v28 & 0xFB00) == 0x200 || (int v29 = BYTE1(v28), v29 == 7))
        {
          uint64_t v30 = *(void *)(a1 + 16);
        }
        else
        {
          uint64_t v30 = 0;
          if (v29)
          {
            uint64_t v31 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v32 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
            objc_msgSend(v31, "handleFailureInFunction:file:lineNumber:description:", v32, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", a1);
          }
        }
        uint64_t v51 = v30;
        if (v12)
        {
          if (*(void *)(v12 + 16)) {
            CFStringRef v11 = *(CFStringRef *)(v12 + 16);
          }
          __int16 v38 = (*(unsigned char *)(v12 + 56) & 3) << 11;
        }
        else
        {
          uint64_t v39 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v40 = [NSString stringWithUTF8String:"NSString *TSUFormatGetCustomNumberFormatCurrencyCode(const TSUFormatStruct)"];
          objc_msgSend(v39, "handleFailureInFunction:file:lineNumber:description:", v40, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Binaries/AlderShared/install/Root/usr/local/include/TSFrameworks/TSUtility/TSUFormatTypes.h"), 604, @"Custom format is not correctly populated.");
          long long v41 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v42 = [NSString stringWithUTF8String:"BOOL TSUFormatGetCustomNumberFormatUseAccountingStyle(const TSUFormatStruct)"];
          objc_msgSend(v41, "handleFailureInFunction:file:lineNumber:description:", v42, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Binaries/AlderShared/install/Root/usr/local/include/TSFrameworks/TSUtility/TSUFormatTypes.h"), 635, @"Custom format is not correctly populated.");
          long long v43 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v44 = [NSString stringWithUTF8String:"BOOL TSUFormatGetCustomNumberFormatShowThousandsSeparator(const TSUFormatStruct)"];
          objc_msgSend(v43, "handleFailureInFunction:file:lineNumber:description:", v44, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Binaries/AlderShared/install/Root/usr/local/include/TSFrameworks/TSUtility/TSUFormatTypes.h"), 625, @"Custom format is not correctly populated.");
          __int16 v38 = 0;
        }
        v10 |= v38;
        goto LABEL_56;
      default:
        break;
    }
  }
  else
  {
LABEL_44:
    uint64_t v8 = 0;
  }
  if (currencyCode) {

  }
  return v8;
}

uint64_t TSTCellCoerceCellToPercentageFormat(uint64_t result)
{
  uint64_t v35 = 0;
  if (result)
  {
    uint64_t v1 = result;
    uint64_t result = 0;
    int v2 = (*MEMORY[0x263F7C948] & 7) << 8;
    unsigned int v3 = v2 | 0xFD;
    __int16 v4 = *(_WORD *)(v1 + 120);
    switch(*(_DWORD *)(v1 + 104))
    {
      case 0x100:
        int v11 = *(_DWORD *)(v1 + 8);
        if ((v11 & 0xFB00) == 0x200 || BYTE1(v11) == 7)
        {
          uint64_t v13 = *(void *)(v1 + 16);
        }
        else
        {
          uint64_t v13 = 0;
          if (BYTE1(v11))
          {
            int v25 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v26 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
            objc_msgSend(v25, "handleFailureInFunction:file:lineNumber:description:", v26, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", v1);
          }
        }
        uint64_t v35 = v13;
        unsigned int v3 = v4 & 0xFFF;
        goto LABEL_12;
      case 0x101:
        int v14 = *(_DWORD *)(v1 + 8);
        if ((v14 & 0xFB00) == 0x200 || BYTE1(v14) == 7)
        {
          uint64_t v16 = *(void *)(v1 + 16);
        }
        else
        {
          uint64_t v16 = 0;
          if (BYTE1(v14))
          {
            uint64_t v27 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v28 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
            objc_msgSend(v27, "handleFailureInFunction:file:lineNumber:description:", v28, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", v1);
          }
        }
        uint64_t v35 = v16;
        unsigned int v3 = v4 & 0xF00 | 0xFD;
        goto LABEL_12;
      case 0x103:
        int v17 = *(_DWORD *)(v1 + 8);
        if ((v17 & 0xFB00) == 0x200 || BYTE1(v17) == 7)
        {
          uint64_t v19 = *(void *)(v1 + 16);
        }
        else
        {
          uint64_t v19 = 0;
          if (BYTE1(v17))
          {
            int v29 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v30 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
            objc_msgSend(v29, "handleFailureInFunction:file:lineNumber:description:", v30, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", v1);
          }
        }
        uint64_t v35 = v19;
        unsigned int v3 = v4 | v2;
        goto LABEL_12;
      case 0x104:
      case 0x10F:
        int v10 = *(unsigned __int8 *)(v1 + 9);
        if (*(unsigned char *)(v1 + 9))
        {
          if (v10 == 9)
          {
            [*(id *)(v1 + 72) string];
          }
          else if (v10 != 3)
          {
            int v23 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v24 = [NSString stringWithUTF8String:"NSString *TSTCellStringValue(TSTCell *)"];
            objc_msgSend(v23, "handleFailureInFunction:file:lineNumber:description:", v24, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, @"can't get string from non-string cell: %p", v1);
          }
        }
        int v34 = -999;
        if (TSUGetNumberValueAndTypeFromString()) {
          goto LABEL_12;
        }
        return 0;
      case 0x106:
      case 0x107:
      case 0x108:
      case 0x109:
      case 0x10D:
      case 0x10E:
        int v5 = *(_DWORD *)(v1 + 8);
        if ((v5 & 0xFB00) == 0x200 || BYTE1(v5) == 7)
        {
          uint64_t v7 = *(void *)(v1 + 16);
        }
        else
        {
          uint64_t v7 = 0;
          if (BYTE1(v5))
          {
            uint64_t v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v9 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
            objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", v1);
          }
        }
        uint64_t v35 = v7;
        goto LABEL_12;
      case 0x10B:
        int v20 = *(_DWORD *)(v1 + 8);
        if ((v20 & 0xFB00) != 0x200 && BYTE1(v20) != 7)
        {
          if (BYTE1(v20))
          {
            uint64_t v31 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v32 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
            objc_msgSend(v31, "handleFailureInFunction:file:lineNumber:description:", v32, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", v1);
          }
LABEL_62:
          uint64_t v35 = 0;
          goto LABEL_63;
        }
        double v22 = *(double *)(v1 + 16);
        uint64_t v35 = *(void *)&v22;
        if (v22 > 5.0)
        {
          uint64_t v35 = 0x4014000000000000;
          goto LABEL_63;
        }
        if (v22 < 0.0) {
          goto LABEL_62;
        }
LABEL_63:
        unsigned int v3 = v2;
LABEL_12:
        v33[0] = 258;
        v33[1] = 0;
        _OWORD v33[2] = v3;
        v33[3] = 0;
        v33[4] = 0;
        TSTCellSetImplicitFormat(v1, (uint64_t)v33);
        if (*(unsigned char *)(v1 + 9))
        {
          TSTCellClearValue(v1);
          *(unsigned char *)(v1 + 9) = 2;
          *(void *)(v1 + 16) = v35;
        }
        uint64_t result = 1;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t TSTCellCoerceCellToDurationFormat(uint64_t a1)
{
  double v19 = 0.0;
  if (!a1) {
    return 0;
  }
  uint64_t v2 = 0;
  if ((*(_DWORD *)(a1 + 104) - 256) <= 0xF)
  {
    int v3 = 1 << *(unsigned char *)(a1 + 104);
    if ((v3 & 0x4301) != 0)
    {
      int v4 = *(_DWORD *)(a1 + 8);
      if ((v4 & 0xFB00) == 0x200 || BYTE1(v4) == 7)
      {
        double v6 = *(double *)(a1 + 16) * 86400.0;
      }
      else
      {
        double v6 = 0.0;
        if (BYTE1(v4))
        {
          uint64_t v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v9 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
          objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", a1);
        }
      }
      double v19 = v6;
      goto LABEL_18;
    }
    if ((v3 & 0x8010) != 0)
    {
      int v7 = *(unsigned __int8 *)(a1 + 9);
      if (*(unsigned char *)(a1 + 9))
      {
        if (v7 == 9)
        {
          [*(id *)(a1 + 72) string];
        }
        else if (v7 != 3)
        {
          uint64_t v12 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v13 = [NSString stringWithUTF8String:"NSString *TSTCellStringValue(TSTCell *)"];
          objc_msgSend(v12, "handleFailureInFunction:file:lineNumber:description:", v13, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, @"can't get string from non-string cell: %p", a1);
        }
      }
      int v17 = 1;
      int v18 = 0;
      if (TSUDurationFormatterTimeIntervalFromStringWithCompactStyleStartUnit())
      {
        TSUDurationFormatterMaxDurationUnitInUnits();
        TSUDurationFormatterMinDurationUnitInUnits();
LABEL_18:
        unint64_t v10 = (unint64_t)*MEMORY[0x263F7C938] << 32;
        uint64_t v2 = 1;
        TSUDurationFormatterDurationUnitsNecessaryToFullyDisplayDuration();
        unsigned int v11 = TSUDurationFormatterMaxDurationUnitInUnits();
        v15[0] = 268;
        v15[1] = (TSUDurationFormatterMinDurationUnitInUnits() << 32) | 1;
        _DWORD v15[2] = v10 | v11;
        v15[3] = 0;
        v15[4] = 0;
        TSTCellSetImplicitFormat(a1, (uint64_t)v15);
        TSTCellClearValue(a1);
        *(unsigned char *)(a1 + 9) = 7;
        *(double *)(a1 + 16) = v19;
        return v2;
      }
      int v16 = -999;
      TSUGetNumberValueAndTypeFromString();
      return 0;
    }
  }
  return v2;
}

uint64_t TSTCellCoerceCellToScientificFormat(uint64_t result)
{
  uint64_t v25 = 0;
  if (result)
  {
    uint64_t v1 = result;
    uint64_t result = 0;
    unsigned int v2 = ((*MEMORY[0x263F7C948] & 7) << 8) | 0xFD;
    switch(*(_DWORD *)(v1 + 104))
    {
      case 0x100:
      case 0x102:
        int v8 = (*MEMORY[0x263F7C948] & 7) << 8;
        int v9 = *(unsigned __int8 *)(v1 + 120);
        int v10 = *(_DWORD *)(v1 + 8);
        if ((v10 & 0xFB00) == 0x200 || BYTE1(v10) == 7)
        {
          uint64_t v12 = *(void *)(v1 + 16);
        }
        else
        {
          uint64_t v12 = 0;
          if (BYTE1(v10))
          {
            int v17 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v18 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
            objc_msgSend(v17, "handleFailureInFunction:file:lineNumber:description:", v18, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", v1);
          }
        }
        uint64_t v25 = v12;
        unsigned int v2 = v9 | v8;
        goto LABEL_41;
      case 0x101:
      case 0x106:
      case 0x107:
      case 0x108:
      case 0x109:
      case 0x10D:
      case 0x10E:
        int v3 = *(_DWORD *)(v1 + 8);
        if ((v3 & 0xFB00) == 0x200 || BYTE1(v3) == 7)
        {
          uint64_t v5 = *(void *)(v1 + 16);
        }
        else
        {
          uint64_t v5 = 0;
          if (BYTE1(v3))
          {
            double v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v7 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
            objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", v1);
          }
        }
        uint64_t v25 = v5;
        goto LABEL_41;
      case 0x104:
      case 0x10F:
        int v13 = *(unsigned __int8 *)(v1 + 9);
        if (*(unsigned char *)(v1 + 9))
        {
          if (v13 == 9)
          {
            [*(id *)(v1 + 72) string];
          }
          else if (v13 != 3)
          {
            double v19 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v20 = [NSString stringWithUTF8String:"NSString *TSTCellStringValue(TSTCell *)"];
            objc_msgSend(v19, "handleFailureInFunction:file:lineNumber:description:", v20, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, @"can't get string from non-string cell: %p", v1);
          }
        }
        int v24 = -999;
        if (TSUGetNumberValueAndTypeFromString()) {
          goto LABEL_41;
        }
        return 0;
      case 0x10B:
        int v14 = *(_DWORD *)(v1 + 8);
        if ((v14 & 0xFB00) != 0x200 && BYTE1(v14) != 7)
        {
          if (BYTE1(v14))
          {
            unint64_t v21 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v22 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
            objc_msgSend(v21, "handleFailureInFunction:file:lineNumber:description:", v22, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", v1);
          }
LABEL_40:
          uint64_t v25 = 0;
          goto LABEL_41;
        }
        double v16 = *(double *)(v1 + 16);
        uint64_t v25 = *(void *)&v16;
        if (v16 > 5.0)
        {
          uint64_t v25 = 0x4014000000000000;
          goto LABEL_41;
        }
        if (v16 < 0.0) {
          goto LABEL_40;
        }
LABEL_41:
        v23[0] = 259;
        v23[1] = 0;
        v23[2] = v2;
        v23[3] = 0;
        v23[4] = 0;
        TSTCellSetImplicitFormat(v1, (uint64_t)v23);
        if (*(unsigned char *)(v1 + 9))
        {
          TSTCellClearValue(v1);
          *(unsigned char *)(v1 + 9) = 2;
          *(void *)(v1 + 16) = v25;
        }
        uint64_t result = 1;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t TSTCellCoerceCellToFractionFormat(uint64_t result)
{
  uint64_t v23 = 0;
  if (!result) {
    return result;
  }
  uint64_t v1 = result;
  uint64_t result = 0;
  if ((*(_DWORD *)(v1 + 104) - 256) > 0xF) {
    return result;
  }
  if (((1 << *(unsigned char *)(v1 + 104)) & 0x638F) != 0)
  {
    int v2 = *(_DWORD *)(v1 + 8);
    if ((v2 & 0xFB00) == 0x200 || BYTE1(v2) == 7)
    {
      uint64_t v4 = *(void *)(v1 + 16);
    }
    else
    {
      uint64_t v4 = 0;
      if (BYTE1(v2))
      {
        uint64_t v5 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v6 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
        objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", v1);
      }
    }
    uint64_t v23 = v4;
    goto LABEL_13;
  }
  if (((1 << *(unsigned char *)(v1 + 104)) & 0x8010) != 0)
  {
    int v8 = *(unsigned __int8 *)(v1 + 9);
    if (*(unsigned char *)(v1 + 9))
    {
      if (v8 == 9)
      {
        [*(id *)(v1 + 72) string];
      }
      else if (v8 != 3)
      {
        int v14 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v15 = [NSString stringWithUTF8String:"NSString *TSTCellStringValue(TSTCell *)"];
        objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", v15, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, @"can't get string from non-string cell: %p", v1);
      }
    }
    int v22 = -999;
    if ((TSUGetNumberValueAndTypeFromString() & 1) == 0) {
      return 0;
    }
    goto LABEL_13;
  }
  if (*(_DWORD *)(v1 + 104) != 267) {
    return result;
  }
  int v9 = *(_DWORD *)(v1 + 8);
  if ((v9 & 0xFB00) != 0x200)
  {
    int v10 = BYTE1(v9);
    if (v10 != 7)
    {
      if (v10)
      {
        unsigned int v11 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v12 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
        objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", v1);
      }
      goto LABEL_35;
    }
  }
  double v13 = *(double *)(v1 + 16);
  uint64_t v23 = *(void *)&v13;
  if (v13 <= 5.0)
  {
    if (v13 < 0.0) {
LABEL_35:
    }
      uint64_t v23 = 0;
  }
  else
  {
    uint64_t v23 = 0x4014000000000000;
  }
LABEL_13:
  int v7 = *MEMORY[0x263F7C940];
  uint64_t v16 = 262;
  int v17 = v7;
  uint64_t v18 = 0;
  uint64_t v20 = 0;
  uint64_t v19 = 0;
  int v21 = 0;
  TSTCellSetImplicitFormat(v1, (uint64_t)&v16);
  if (*(unsigned char *)(v1 + 9))
  {
    TSTCellClearValue(v1);
    *(unsigned char *)(v1 + 9) = 2;
    *(void *)(v1 + 16) = v23;
  }
  return 1;
}

uint64_t TSTCellCoerceCellToRatingFormat(uint64_t result)
{
  double v22 = 0.0;
  if (!result) {
    return result;
  }
  uint64_t v1 = result;
  uint64_t result = 0;
  if ((*(_DWORD *)(v1 + 104) - 256) > 0xF) {
    return result;
  }
  if (((1 << *(unsigned char *)(v1 + 104)) & 0x634F) != 0)
  {
    int v2 = *(_DWORD *)(v1 + 8);
    if ((v2 & 0xFB00) != 0x200 && BYTE1(v2) != 7)
    {
      if (BYTE1(v2))
      {
        uint64_t v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v5 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
        objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", v1);
      }
      goto LABEL_19;
    }
    double v22 = *(double *)(v1 + 16);
    if (v22 <= 5.0)
    {
      if (v22 < 0.0) {
LABEL_19:
      }
        double v22 = 0.0;
    }
    else
    {
      double v22 = 5.0;
    }
LABEL_20:
    int v17 = 267;
    long long v18 = 0u;
    long long v19 = 0u;
    int v20 = 0;
    TSTCellSetImplicitFormat(v1, (uint64_t)&v17);
    if (*(unsigned char *)(v1 + 9))
    {
      TSTCellClearValue(v1);
      *(unsigned char *)(v1 + 9) = 2;
      *(double *)(v1 + 16) = v22;
    }
    return 1;
  }
  if (((1 << *(unsigned char *)(v1 + 104)) & 0x8010) == 0)
  {
    if (*(_DWORD *)(v1 + 104) != 263) {
      return result;
    }
    int v8 = *(_DWORD *)(v1 + 8);
    if ((v8 & 0xFB00) == 0x200 || (int v9 = BYTE1(v8), v9 == 7))
    {
      double v10 = *(double *)(v1 + 16);
    }
    else
    {
      double v10 = 0.0;
      if (v9)
      {
        unsigned int v11 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v12 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
        objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", v1);
      }
    }
    double v22 = v10;
    goto LABEL_20;
  }
  int v6 = *(unsigned __int8 *)(v1 + 9);
  if (*(unsigned char *)(v1 + 9))
  {
    if (v6 == 9)
    {
      int v7 = (__CFString *)[*(id *)(v1 + 72) string];
    }
    else if (v6 == 3)
    {
      int v7 = *(__CFString **)(v1 + 24);
    }
    else
    {
      double v13 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v14 = [NSString stringWithUTF8String:"NSString *TSTCellStringValue(TSTCell *)"];
      objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, @"can't get string from non-string cell: %p", v1);
      int v7 = 0;
    }
  }
  else
  {
    int v7 = &stru_26D688A48;
  }
  int v21 = -999;
  TSUGetNumberValueAndTypeFromString();
  if ((unint64_t)[(__CFString *)v7 length] > 4)
  {
    uint64_t v15 = 5;
  }
  else
  {
    uint64_t v15 = [(__CFString *)v7 length];
    if (v15 < 1)
    {
      uint64_t v15 = 0;
LABEL_39:
      double v22 = (double)v15;
      goto LABEL_20;
    }
  }
  uint64_t v16 = 0;
  while ([(__CFString *)v7 characterAtIndex:v16] == 42)
  {
    if (v15 == ++v16) {
      goto LABEL_39;
    }
  }
  return 0;
}

uint64_t TSTCellCoerceCellToCheckboxFormat(uint64_t result)
{
  uint64_t v27 = 0;
  if (!result) {
    return result;
  }
  uint64_t v1 = result;
  int v2 = *(_DWORD *)(result + 104);
  if ((v2 - 256) > 0xF) {
    goto LABEL_22;
  }
  int v3 = 1 << *(_DWORD *)(result + 104);
  if ((v3 & 0x6B4F) == 0)
  {
    if ((v3 & 0x8010) != 0)
    {
      int v10 = *(unsigned __int8 *)(result + 9);
      if (*(unsigned char *)(result + 9))
      {
        if (v10 == 9)
        {
          unsigned int v11 = (__CFString *)[*(id *)(result + 72) string];
        }
        else if (v10 == 3)
        {
          unsigned int v11 = *(__CFString **)(result + 24);
        }
        else
        {
          uint64_t v16 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v17 = [NSString stringWithUTF8String:"NSString *TSTCellStringValue(TSTCell *)"];
          objc_msgSend(v16, "handleFailureInFunction:file:lineNumber:description:", v17, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, @"can't get string from non-string cell: %p", v1);
          unsigned int v11 = 0;
        }
      }
      else
      {
        unsigned int v11 = &stru_26D688A48;
      }
      long long v18 = (void *)[(__CFString *)v11 uppercaseString];
      if (objc_msgSend(v18, "isEqual:", objc_msgSend((id)TSTBundle(), "localizedStringForKey:value:table:", @"TRUE", &stru_26D688A48, @"TSTables")))
      {
        BOOL v6 = 1;
        goto LABEL_13;
      }
      if (objc_msgSend(v18, "isEqual:", objc_msgSend((id)TSTBundle(), "localizedStringForKey:value:table:", @"FALSE", &stru_26D688A48, @"TSTables")))goto LABEL_12; {
      int v19 = *(unsigned __int8 *)(v1 + 9);
      }
      if (*(unsigned char *)(v1 + 9))
      {
        if (v19 == 9)
        {
          [*(id *)(v1 + 72) string];
        }
        else if (v19 != 3)
        {
          int v20 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v21 = [NSString stringWithUTF8String:"NSString *TSTCellStringValue(TSTCell *)"];
          objc_msgSend(v20, "handleFailureInFunction:file:lineNumber:description:", v21, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, @"can't get string from non-string cell: %p", v1);
        }
      }
      int v26 = -999;
      TSUGetNumberValueAndTypeFromString();
      return 0;
    }
LABEL_22:
    if (v2 == 1)
    {
      int v12 = *(_DWORD *)(result + 8);
      if ((v12 & 0xFF00) == 0x600)
      {
        int v13 = BYTE1(v12);
        if (v13)
        {
          if (v13 == 6) {
            goto LABEL_9;
          }
          uint64_t v14 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v15 = [NSString stringWithUTF8String:"BOOL TSTCellBoolValue(TSTCell *)"];
          objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", v15, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 925, @"can't get BOOL value from non-BOOL cell: %p", v1);
        }
LABEL_12:
        BOOL v6 = 0;
        goto LABEL_13;
      }
    }
    return 0;
  }
  int v4 = *(_DWORD *)(result + 8);
  if ((v4 & 0xFB00) != 0x200 && BYTE1(v4) != 7)
  {
    if (BYTE1(v4))
    {
      int v7 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v8 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
      objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", v1);
    }
    goto LABEL_12;
  }
LABEL_9:
  BOOL v6 = *(double *)(result + 16) != 0.0;
LABEL_13:
  int v22 = 263;
  long long v23 = 0u;
  long long v24 = 0u;
  int v25 = 0;
  TSTCellSetImplicitFormat(v1, (uint64_t)&v22);
  TSTCellClearValue(v1);
  *(unsigned char *)(v1 + 9) = 6;
  double v9 = 0.0;
  if (v6) {
    double v9 = 1.0;
  }
  *(double *)(v1 + 16) = v9;
  return 1;
}

uint64_t TSTCellCoerceCellToTextFormat(TSTCell *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = 0;
  if ((a1->mPrivate.mCellFormats.mCurrentCellFormat.mFormatType - 256) > 0x10) {
    return v2;
  }
  if (((1 << LOBYTE(a1->mPrivate.mCellFormats.mCurrentCellFormat.mFormatType)) & 0x177EF) != 0)
  {
    mString = (NSString *)NSStringFromNativeTSTCell((__CFString *)a1);
    if (mString) {
      goto LABEL_5;
    }
    return 0;
  }
  int mPrivate = (int)a1->mPrivate;
  if (a1->mPrivate.mCellFormats.mCurrentCellFormat.mFormatType == 267)
  {
    if ((*(_DWORD *)&a1->mPrivate & 0xFB00) == 0x200 || BYTE1(mPrivate) == 7)
    {
      double mDouble = a1->mPrivate.mValue.mDouble;
      mString = (NSString *)[MEMORY[0x263F089D8] stringWithString:&stru_26D688A48];
      if (mDouble > 0.0)
      {
        double v8 = 0.0;
        do
        {
          [(NSString *)mString appendString:@"*"];
          double v8 = v8 + 1.0;
        }
        while (v8 < mDouble);
      }
      goto LABEL_5;
    }
    if (BYTE1(mPrivate))
    {
      int v10 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v11 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
      objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", a1);
    }
    int v12 = (NSString *)[MEMORY[0x263F089D8] stringWithString:&stru_26D688A48];
    goto LABEL_32;
  }
  if (a1->mPrivate.mCellFormats.mCurrentCellFormat.mFormatType != 271) {
    return v2;
  }
  if ((*(_DWORD *)&a1->mPrivate & 0xFF00) == 0x900) {
    goto LABEL_13;
  }
  int v9 = BYTE1(mPrivate);
  if (!v9)
  {
    mString = (NSString *)&stru_26D688A48;
    goto LABEL_5;
  }
  if (v9 == 9)
  {
    int v12 = [(TSTRichTextPayload *)a1->mPrivate.mRichTextPayload string];
LABEL_32:
    mString = v12;
    goto LABEL_5;
  }
  if (v9 != 3)
  {
    int v13 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v14 = [NSString stringWithUTF8String:"NSString *TSTCellStringValue(TSTCell *)"];
    objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, @"can't get string from non-string cell: %p", a1);
LABEL_13:
    mString = 0;
    goto LABEL_5;
  }
  mString = a1->mPrivate.mValue.mString.mString;
LABEL_5:
  int v15 = 260;
  long long v16 = 0u;
  long long v17 = 0u;
  int v18 = 0;
  TSTCellSetImplicitFormat((uint64_t)a1, (uint64_t)&v15);
  if (!mString) {
    return 1;
  }
  TSTCellClearValue((uint64_t)a1);
  *((unsigned char *)&a1->mPrivate + 1) = 3;
  uint64_t v2 = 1;
  TSTCellSetStringValueClearingID(a1, mString, 1);
  return v2;
}

uint64_t TSTCellCoerceCellToStepperFormat(uint64_t a1)
{
  return p_TSTCellCoerceCellToControlFormat(a1, 264);
}

uint64_t TSTCellCoerceCellToSliderFormat(uint64_t a1)
{
  return p_TSTCellCoerceCellToControlFormat(a1, 265);
}

uint64_t TSTCellCoerceCellToMultipleChoiceListFormat()
{
  return 0;
}

uint64_t TSTCellCoerceCellToDateTimeFormat(uint64_t a1)
{
  id v19 = 0;
  long long v17 = 0uLL;
  uint64_t v2 = TSUDefaultDateTimeFormat();
  uint64_t v18 = v2;
  if (!a1) {
    goto LABEL_16;
  }
  int v3 = *(_DWORD *)(a1 + 104);
  if (v3 == 260) {
    goto LABEL_5;
  }
  if (v3 == 272)
  {
    uint64_t v6 = v2;
    if (*(unsigned char *)(a1 + 9))
    {
      if (*(unsigned char *)(a1 + 9) == 5)
      {
        int v7 = *(void **)(a1 + 16);
LABEL_27:
        id v8 = v7;
        goto LABEL_28;
      }
      uint64_t v11 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v12 = [NSString stringWithUTF8String:"NSDate *TSTCellDateValue(TSTCell *)"];
      objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 1021, @"can't get date value from a non-date cell: %p", a1);
    }
    int v7 = 0;
    goto LABEL_27;
  }
  if (v3 != 271)
  {
    a1 = 0;
LABEL_16:
    id v8 = 0;
    goto LABEL_31;
  }
LABEL_5:
  if (TSTCellHasFormatOfType((void *)a1, 261))
  {
    int v4 = *(void **)(a1 + 200);
    if (v4) {
      [v4 getFormatStruct];
    }
  }
  int v5 = *(unsigned __int8 *)(a1 + 9);
  if (*(unsigned char *)(a1 + 9))
  {
    if (v5 == 9)
    {
      [*(id *)(a1 + 72) string];
    }
    else if (v5 != 3)
    {
      int v9 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v10 = [NSString stringWithUTF8String:"NSString *TSTCellStringValue(TSTCell *)"];
      objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, @"can't get string from non-string cell: %p", a1);
    }
  }
  id v8 = (id)TSUCreateDateFromStringWithPreferredFormat();
  if (!v8)
  {
    a1 = 0;
    goto LABEL_31;
  }
  if ([v19 length])
  {
    uint64_t v6 = (uint64_t)v19;
    uint64_t v18 = (uint64_t)v19;
  }
  else
  {
    uint64_t v6 = v18;
  }
LABEL_28:
  v15[0] = 261;
  v15[1] = 0;
  _DWORD v15[2] = v6;
  long long v16 = v17;
  TSTCellSetImplicitFormat(a1, (uint64_t)v15);
  TSTCellClearValue(a1);
  *(unsigned char *)(a1 + 9) = 5;
  id v13 = *(id *)(a1 + 16);
  if (v13 != v8)
  {

    *(void *)(a1 + 16) = v8;
  }
  a1 = 1;
LABEL_31:
  if (v19) {

  }
  return a1;
}

uint64_t TSTCellCoerceCellToCustomNumberFormat(uint64_t result)
{
  double v25 = 0.0;
  if (result)
  {
    uint64_t v1 = result;
    uint64_t result = 0;
    switch(*(_DWORD *)(v1 + 104))
    {
      case 0x100:
      case 0x101:
      case 0x102:
      case 0x103:
      case 0x106:
      case 0x107:
      case 0x108:
      case 0x109:
      case 0x10D:
      case 0x10E:
        int v2 = *(_DWORD *)(v1 + 8);
        if ((v2 & 0xFB00) == 0x200 || BYTE1(v2) == 7)
        {
          double v4 = *(double *)(v1 + 16);
        }
        else
        {
          double v4 = 0.0;
          if (BYTE1(v2))
          {
            int v5 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v6 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
            objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", v1);
          }
        }
        double v25 = v4;
        goto LABEL_12;
      case 0x104:
      case 0x10F:
        int v7 = *(unsigned __int8 *)(v1 + 9);
        if (*(unsigned char *)(v1 + 9))
        {
          if (v7 == 9)
          {
            [*(id *)(v1 + 72) string];
          }
          else if (v7 != 3)
          {
            long long v16 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v17 = [NSString stringWithUTF8String:"NSString *TSTCellStringValue(TSTCell *)"];
            objc_msgSend(v16, "handleFailureInFunction:file:lineNumber:description:", v17, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, @"can't get string from non-string cell: %p", v1);
          }
        }
        int v24 = -999;
        if (TSUGetNumberValueAndTypeFromString()) {
          return 0;
        }
        else {
          return 0;
        }
      case 0x10B:
        int v11 = *(_DWORD *)(v1 + 8);
        if ((v11 & 0xFB00) != 0x200 && BYTE1(v11) != 7)
        {
          if (BYTE1(v11))
          {
            uint64_t v18 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v19 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
            objc_msgSend(v18, "handleFailureInFunction:file:lineNumber:description:", v19, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", v1);
          }
LABEL_45:
          double v25 = 0.0;
          goto LABEL_12;
        }
        double v13 = *(double *)(v1 + 16);
        double v25 = v13;
        if (v13 > 5.0)
        {
          double v25 = 5.0;
          goto LABEL_12;
        }
        if (v13 < 0.0) {
          goto LABEL_45;
        }
LABEL_12:
        int v20 = 270;
        long long v21 = 0u;
        long long v22 = 0u;
        int v23 = 0;
        TSTCellSetImplicitFormat(v1, (uint64_t)&v20);
        if (*(unsigned char *)(v1 + 9))
        {
          TSTCellClearValue(v1);
          *(unsigned char *)(v1 + 9) = 2;
          *(double *)(v1 + 16) = v25;
        }
        uint64_t result = 1;
        break;
      case 0x10C:
        int v8 = *(_DWORD *)(v1 + 8);
        if ((v8 & 0xFB00) == 0x200 || BYTE1(v8) == 7)
        {
          double v10 = *(double *)(v1 + 16);
        }
        else
        {
          double v10 = 0.0;
          if (BYTE1(v8))
          {
            uint64_t v14 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
            uint64_t v15 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
            objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", v15, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", v1);
          }
        }
        double v25 = v10 / 86400.0;
        goto LABEL_12;
      default:
        return result;
    }
  }
  return result;
}

uint64_t TSTCellCoerceCellToCustomTextFormat(__CFString *a1)
{
  if (!a1 || (LODWORD(a1[3].info) - 256) > 0x10) {
    return 0;
  }
  if (((1 << LOBYTE(a1[3].info)) & 0x17FEF) != 0)
  {
LABEL_4:
    length = (NSString *)NSStringFromNativeTSTCell(a1);
    if (length) {
      goto LABEL_5;
    }
    return 0;
  }
  int v5 = BYTE1(LODWORD(a1->info));
  if (LODWORD(a1[3].info) == 260)
  {
    if (v5 != 9) {
      goto LABEL_4;
    }
  }
  else if (v5 != 9)
  {
    if (!BYTE1(LODWORD(a1->info)))
    {
      length = (NSString *)&stru_26D688A48;
      goto LABEL_5;
    }
    if (v5 == 3)
    {
      length = (NSString *)a1->length;
      goto LABEL_5;
    }
    uint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = [NSString stringWithUTF8String:"NSString *TSTCellStringValue(TSTCell *)"];
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, @"can't get string from non-string cell: %p", a1);
  }
  length = 0;
LABEL_5:
  int v8 = 271;
  long long v9 = 0u;
  long long v10 = 0u;
  int v11 = 0;
  TSTCellSetImplicitFormat((uint64_t)a1, (uint64_t)&v8);
  if (!length) {
    return 1;
  }
  TSTCellClearValue((uint64_t)a1);
  BYTE1(a1->info) = 3;
  uint64_t v3 = 1;
  TSTCellSetStringValueClearingID((TSTCell *)a1, length, 1);
  return v3;
}

uint64_t TSTCellCoerceCellToCustomDateTimeFormat(uint64_t result)
{
  if (!result) {
    return result;
  }
  uint64_t v1 = result;
  uint64_t result = 0;
  int v2 = *(_DWORD *)(v1 + 104);
  if (v2 > 270)
  {
    if (v2 != 271)
    {
      if (v2 != 272) {
        return result;
      }
      goto LABEL_8;
    }
  }
  else if (v2 != 260)
  {
    if (v2 != 261) {
      return result;
    }
LABEL_8:
    if (*(unsigned char *)(v1 + 9))
    {
      if (*(unsigned char *)(v1 + 9) == 5)
      {
        uint64_t v3 = 0;
        double v4 = *(void **)(v1 + 16);
LABEL_21:
        int v11 = 272;
        long long v12 = 0u;
        long long v13 = 0u;
        int v14 = 0;
        TSTCellSetImplicitFormat(v1, (uint64_t)&v11);
        TSTCellClearValue(v1);
        *(unsigned char *)(v1 + 9) = 5;
        long long v10 = *(void **)(v1 + 16);
        if (v10 != v4)
        {

          *(void *)(v1 + 16) = v4;
        }
        if (v3) {
          CFRelease(v3);
        }
        return 1;
      }
      uint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v7 = [NSString stringWithUTF8String:"NSDate *TSTCellDateValue(TSTCell *)"];
      objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 1021, @"can't get date value from a non-date cell: %p", v1);
    }
    double v4 = 0;
    uint64_t v3 = 0;
    goto LABEL_21;
  }
  int v5 = *(unsigned __int8 *)(v1 + 9);
  if (*(unsigned char *)(v1 + 9))
  {
    if (v5 == 9)
    {
      [*(id *)(v1 + 72) string];
    }
    else if (v5 != 3)
    {
      int v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v9 = [NSString stringWithUTF8String:"NSString *TSTCellStringValue(TSTCell *)"];
      objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, @"can't get string from non-string cell: %p", v1);
    }
  }
  uint64_t v15 = 0;
  uint64_t result = TSUCreateDateFromString();
  double v4 = (void *)result;
  uint64_t v3 = (const void *)result;
  if (result) {
    goto LABEL_21;
  }
  return result;
}

uint64_t TSTCellCoerceCellToBaseFormat(uint64_t result)
{
  uint64_t v27 = 0;
  if (*MEMORY[0x263F7C930]) {
    int v1 = 65546;
  }
  else {
    int v1 = 10;
  }
  if (!result) {
    return result;
  }
  uint64_t v2 = result;
  uint64_t result = 0;
  if ((*(_DWORD *)(v2 + 104) - 256) > 0xF) {
    return result;
  }
  if (((1 << *(unsigned char *)(v2 + 104)) & 0x43CF) != 0)
  {
    int v3 = *(_DWORD *)(v2 + 8);
    if ((v3 & 0xFB00) == 0x200 || BYTE1(v3) == 7)
    {
      uint64_t v5 = *(void *)(v2 + 16);
    }
    else
    {
      uint64_t v5 = 0;
      if (BYTE1(v3))
      {
        uint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v7 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
        objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", v2);
      }
    }
    __int16 v8 = 0;
    uint64_t v27 = v5;
    goto LABEL_16;
  }
  if (((1 << *(unsigned char *)(v2 + 104)) & 0x8010) != 0)
  {
    int v9 = *(unsigned __int8 *)(v2 + 9);
    if (*(unsigned char *)(v2 + 9))
    {
      if (v9 == 9)
      {
        [*(id *)(v2 + 72) string];
      }
      else if (v9 != 3)
      {
        int v14 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v15 = [NSString stringWithUTF8String:"NSString *TSTCellStringValue(TSTCell *)"];
        objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", v15, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, @"can't get string from non-string cell: %p", v2);
      }
    }
    int v26 = -999;
    if (!TSUGetNumberValueAndTypeFromString()) {
      return 0;
    }
    unsigned int v16 = TSUNumberOfDecimalPlacesInNumericString();
    LOBYTE(v8) = v16;
    if (v16 >= (unint64_t)(unsigned __int16)*MEMORY[0x263F7C950]) {
      __int16 v8 = *MEMORY[0x263F7C950];
    }
    __int16 v8 = v8;
    goto LABEL_16;
  }
  if (*(_DWORD *)(v2 + 104) != 267) {
    return result;
  }
  int v10 = *(_DWORD *)(v2 + 8);
  if ((v10 & 0xFB00) != 0x200)
  {
    int v11 = BYTE1(v10);
    if (v11 != 7)
    {
      if (v11)
      {
        long long v12 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v13 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
        objc_msgSend(v12, "handleFailureInFunction:file:lineNumber:description:", v13, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", v2);
      }
LABEL_41:
      __int16 v8 = 0;
      uint64_t v27 = 0;
      goto LABEL_16;
    }
  }
  double v17 = *(double *)(v2 + 16);
  uint64_t v27 = *(void *)&v17;
  if (v17 <= 5.0)
  {
    if (v17 >= 0.0)
    {
      __int16 v8 = 0;
      goto LABEL_16;
    }
    goto LABEL_41;
  }
  __int16 v8 = 0;
  uint64_t v27 = 0x4014000000000000;
LABEL_16:
  uint64_t v18 = 269;
  __int16 v19 = v1;
  char v20 = BYTE2(v1);
  int v21 = 0;
  char v22 = 0;
  __int16 v23 = v8;
  v25[0] = 0;
  uint64_t v24 = 0;
  *(void *)((char *)v25 + 6) = 0;
  TSTCellSetImplicitFormat(v2, (uint64_t)&v18);
  if (*(unsigned char *)(v2 + 9))
  {
    TSTCellClearValue(v2);
    *(unsigned char *)(v2 + 9) = 2;
    *(void *)(v2 + 16) = v27;
  }
  return 1;
}

__CFString *TSUDefaultFormatStructCurrency(void)
{
  CFLocaleRef v0 = (const __CFLocale *)TSUGetCurrentLocale();
  Value = (__CFString *)CFLocaleGetValue(v0, (CFLocaleKey)*MEMORY[0x263EFFCB8]);
  if (Value) {
    uint64_t v2 = Value;
  }
  else {
    uint64_t v2 = @"USD";
  }
  int32_t defaultFractionDigits = 0;
  CFNumberFormatterGetDecimalInfoForCurrencyCode(v2, &defaultFractionDigits, 0);
  return v2;
}

uint64_t p_TSTCellCoerceCellToControlFormat(uint64_t a1, int a2)
{
  if (!a1) {
    return 0;
  }
  uint64_t v3 = 0;
  int v4 = *(_DWORD *)(a1 + 104);
  switch(v4)
  {
    case 256:
    case 257:
    case 258:
    case 259:
    case 262:
    case 269:
      int v6 = *(_DWORD *)(a1 + 8);
      if ((v6 & 0xFB00) == 0x200 || BYTE1(v6) == 7)
      {
        uint64_t v8 = 0;
        int v9 = 0;
        double v10 = *(double *)(a1 + 16);
      }
      else
      {
        double v10 = 0.0;
        if (BYTE1(v6))
        {
          int v11 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v12 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
          objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", a1);
        }
        uint64_t v8 = 0;
        int v9 = 0;
      }
      goto LABEL_49;
    case 260:
    case 271:
      uint64_t v3 = 0;
      if (!TSTCellCoerceTextCellToBestNumberFormatUsingSpares(a1, 0)) {
        return v3;
      }
      int v13 = *(_DWORD *)(a1 + 8);
      if ((v13 & 0xFB00) == 0x200 || BYTE1(v13) == 7)
      {
        double v10 = *(double *)(a1 + 16);
      }
      else
      {
        double v10 = 0.0;
        if (BYTE1(v13))
        {
          uint64_t v30 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v31 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
          objc_msgSend(v30, "handleFailureInFunction:file:lineNumber:description:", v31, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", a1);
        }
      }
      uint64_t v8 = 0;
      int v9 = 0;
      int v4 = *(_DWORD *)(a1 + 104);
LABEL_49:
      unsigned int v24 = -1;
      goto LABEL_50;
    case 263:
    case 270:
      int v15 = *(_DWORD *)(a1 + 8);
      int v16 = BYTE1(v15);
      if ((v15 & 0xFB00) != 0x200 && BYTE1(v15) != 7) {
        goto LABEL_37;
      }
      double v10 = *(double *)(a1 + 16);
      goto LABEL_39;
    case 264:
    case 265:
      if (v4 == a2) {
        return 0;
      }
      double v25 = *(double *)(a1 + 112);
      double v26 = *(double *)(a1 + 120);
      double v27 = *(double *)(a1 + 128);
      int v4 = *(_DWORD *)(a1 + 136);
      int v28 = *(_DWORD *)(a1 + 8);
      if ((v28 & 0xFB00) == 0x200 || BYTE1(v28) == 7)
      {
        int v9 = 0;
        uint64_t v8 = 0;
        double v10 = *(double *)(a1 + 16);
      }
      else
      {
        double v10 = 0.0;
        if (BYTE1(v28))
        {
          int v34 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v35 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
          objc_msgSend(v34, "handleFailureInFunction:file:lineNumber:description:", v35, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", a1);
        }
        int v9 = 0;
        uint64_t v8 = 0;
      }
      unsigned int v24 = -1;
      goto LABEL_70;
    case 267:
      int v18 = *(_DWORD *)(a1 + 8);
      int v16 = BYTE1(v18);
      if ((v18 & 0xFB00) == 0x200 || BYTE1(v18) == 7)
      {
        double v20 = *(double *)(a1 + 16);
        double v21 = 0.0;
        if (v20 >= 0.0) {
          double v21 = *(double *)(a1 + 16);
        }
        if (v20 <= 5.0) {
          double v10 = v21;
        }
        else {
          double v10 = 5.0;
        }
      }
      else
      {
LABEL_37:
        double v10 = 0.0;
        if (v16)
        {
          char v22 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v23 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
          objc_msgSend(v22, "handleFailureInFunction:file:lineNumber:description:", v23, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", a1);
        }
      }
LABEL_39:
      uint64_t v8 = ((*MEMORY[0x263F7C948] & 7) << 8) | 0xFD;
      int v9 = 1;
      unsigned int v24 = 256;
      int v4 = 256;
LABEL_50:
      TSTCellClearValue(a1);
      *(unsigned char *)(a1 + 9) = 2;
      if (v10 <= -1.0)
      {
        double v25 = round(v10);
        double v26 = 0.0;
        double v27 = 1.0;
        double v10 = v25;
      }
      else if (v10 >= 0.0)
      {
        double v25 = 0.0;
        double v27 = 1.0;
        if (v10 == 0.0)
        {
          double v26 = 1.0;
          double v10 = 1.0;
        }
        else if (v10 <= 0.0 || v10 >= 1.0)
        {
          if (v10 >= 1.0)
          {
            double v26 = round(v10);
            double v10 = v26;
          }
          else
          {
            double v26 = 100.0;
            double v25 = 1.0;
          }
        }
        else
        {
          double v33 = 2.0;
          if (v4 != 262) {
            double v33 = (double)(unint64_t)TSUNumberOfDecimalPlacesInValue();
          }
          double v26 = 1.0;
          double v27 = 1.0 / __exp10(v33);
        }
      }
      else
      {
        double v32 = 2.0;
        if (v4 != 262) {
          double v32 = (double)(unint64_t)TSUNumberOfDecimalPlacesInValue();
        }
        double v25 = -1.0;
        double v26 = 0.0;
        double v27 = 1.0 / __exp10(v32);
      }
LABEL_70:
      unsigned int v36 = *(_DWORD *)(a1 + 8);
      if ((v36 & 0xFF00) == 0)
      {
        TSTCellClearValue(a1);
        unsigned int v36 = *(_DWORD *)(a1 + 8) & 0xFFFF00FF | 0x200;
        *(_DWORD *)(a1 + 8) = v36;
      }
      if ((v36 & 0xFF00) == 0x200)
      {
        *(double *)(a1 + 16) = v10;
      }
      else
      {
        double v37 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v38 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellSetDoubleValue(TSTCell *, double)");
        objc_msgSend(v37, "handleFailureInFunction:file:lineNumber:description:", v38, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 912, @"can't set value to non-value cell: %p", a1);
      }
      v49[0] = a2;
      v49[1] = 0;
      double v50 = v25;
      double v51 = v26;
      double v52 = v27;
      int v53 = v4;
      int v54 = 0;
      TSTCellSetImplicitFormat(a1, (uint64_t)v49);
      if (v9)
      {
        long long v45 = v24;
        uint64_t v46 = v8;
        uint64_t v47 = 0;
        uint64_t v48 = 0;
        uint64_t v3 = 1;
        TSTCellSetCellFormatStructBasedOnType(a1, &v45, 1);
        v40[0] = v24;
        v40[1] = 0;
        uint64_t v41 = 0;
        uint64_t v42 = v8;
        uint64_t v43 = 0;
        uint64_t v44 = 0;
        TSTCellSetFormatFlagsFromFormat(a1, v40, 1, 1);
      }
      else
      {
        uint64_t v3 = 1;
      }
      break;
    default:
      return v3;
  }
  return v3;
}

uint64_t TSTCellCoerceTextCellToBestNumberFormatUsingSpares(uint64_t a1, unsigned int a2)
{
  if (!a1 || (int v4 = *(_DWORD *)(a1 + 104), v4 != 271) && v4 != 260)
  {
    int v7 = 0;
    return v7 | a2;
  }
  int v5 = *(unsigned __int8 *)(a1 + 9);
  if (*(unsigned char *)(a1 + 9))
  {
    if (v5 == 9)
    {
      int v6 = (NSString *)[*(id *)(a1 + 72) string];
    }
    else if (v5 == 3)
    {
      int v6 = *(NSString **)(a1 + 24);
    }
    else
    {
      uint64_t v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v9 = [NSString stringWithUTF8String:"NSString *TSTCellStringValue(TSTCell *)"];
      objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, @"can't get string from non-string cell: %p", a1);
      int v6 = 0;
    }
  }
  else
  {
    int v6 = (NSString *)&stru_26D688A48;
  }
  double v10 = -[NSString stringByTrimmingCharactersInSet:](v6, "stringByTrimmingCharactersInSet:", [MEMORY[0x263F08708] whitespaceAndNewlineCharacterSet]);
  int v56 = -999;
  id v54 = 0;
  uint64_t v55 = 0;
  if (TSTCellHasFormatOfType((void *)a1, 257))
  {
    int v11 = *(void **)(a1 + 168);
    if (v11) {
      [v11 getFormatStruct];
    }
  }
  int v7 = TSUGetNumberValueAndTypeFromStringWithCurrencyCode();
  if (v7)
  {
    int v12 = TSUFormatTypeFromTSUNumberValueType();
    TSTCellClearValue(a1);
    *(unsigned char *)(a1 + 9) = 2;
    uint64_t v13 = v55;
    *(void *)(a1 + 16) = v55;
    uint64_t v53 = 0;
    long long v51 = 0u;
    long long v52 = 0u;
    LODWORD(v51) = -1;
    __int16 v14 = *(_WORD *)(a1 + 96);
    if (v12 == 257)
    {
      if ((v14 & 2) == 0)
      {
        CFLocaleRef v15 = (const __CFLocale *)TSUGetCurrentLocale();
        Value = (__CFString *)CFLocaleGetValue(v15, (CFLocaleKey)*MEMORY[0x263EFFCB8]);
        if (Value) {
          double v17 = Value;
        }
        else {
          double v17 = @"USD";
        }
        int32_t defaultFractionDigits = 0;
        int DecimalInfoForCurrencyCode = CFNumberFormatterGetDecimalInfoForCurrencyCode(v17, &defaultFractionDigits, 0);
        __int16 v19 = v17;
        if (DecimalInfoForCurrencyCode) {
          uint64_t v20 = defaultFractionDigits;
        }
        else {
          uint64_t v20 = 2;
        }
        unint64_t v21 = v20 & 0xFFFFFFFFFFFFF8FFLL | ((unint64_t)(*MEMORY[0x263F7C948] & 7) << 8);
        *((void *)&v51 + 1) = v19;
        *(void *)&long long v52 = v21;
        LODWORD(v51) = 257;
        if (v54) {
          *((void *)&v51 + 1) = v54;
        }
        TSUGetCurrentLocale();
        if (TSUIsGroupingSeparatorUsedInNumericString())
        {
          LOWORD(v21) = v21 | 0x800;
          LOWORD(v52) = v21;
        }
        if ([(NSString *)v10 characterAtIndex:0] == 40)
        {
          LOWORD(v21) = v21 & 0xF8FF | 0x200;
          LOWORD(v52) = v21;
        }
        if (a2)
        {
          __int16 v22 = 253;
          if ((v55 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
          {
            TSUGetCurrentLocale();
            int v23 = TSUNumberOfDecimalPlacesInNumericString();
            if (TSUNumberOfDecimalPlacesInValue() == v23) {
              __int16 v22 = 253;
            }
            else {
              __int16 v22 = v23;
            }
          }
          LOWORD(v52) = v21 & 0xFF00 | v22;
        }
        v47[0] = v51;
        v47[1] = v52;
        uint64_t v48 = v53;
        unsigned int v24 = (int *)v47;
        goto LABEL_60;
      }
      TSTCellGetFormatOfType((void *)a1, 257, (uint64_t)&v51);
      if (v54) {
        *((void *)&v51 + 1) = v54;
      }
      v49[0] = v51;
      v49[1] = v52;
      uint64_t v50 = v53;
      double v25 = v49;
LABEL_45:
      TSTCellSetExplicitFormat(a1, (uint64_t)v25);
      goto LABEL_61;
    }
    if (v14)
    {
      TSTCellGetFormatOfType((void *)a1, v12, (uint64_t)&v51);
      v45[0] = v51;
      v45[1] = v52;
      uint64_t v46 = v53;
      double v25 = v45;
      goto LABEL_45;
    }
    if (v12 == 256)
    {
      if ((v14 & 2) != 0)
      {
        TSTCellGetFormatOfType((void *)a1, 257, (uint64_t)&v51);
        v43[0] = v51;
        v43[1] = v52;
        uint64_t v44 = v53;
        double v25 = v43;
        goto LABEL_45;
      }
LABEL_47:
      unint64_t v26 = (unint64_t)(*MEMORY[0x263F7C948] & 7) << 8;
      __int16 v27 = 253;
      *(void *)&long long v52 = v26 | 0xFD;
      LODWORD(v51) = v12;
      if ((v13 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        TSUGetCurrentLocale();
        int v28 = TSUNumberOfDecimalPlacesInNumericString();
        unint64_t v29 = TSUNumberOfDecimalPlacesInValue();
        unint64_t v30 = v29 - 2;
        if (v29 <= 1) {
          unint64_t v30 = 0;
        }
        if (v12 != 258) {
          unint64_t v30 = v29;
        }
        if (v30 == v28) {
          __int16 v27 = 253;
        }
        else {
          __int16 v27 = v28;
        }
      }
      __int16 v31 = v27 | v26;
      LOWORD(v52) = v27 | v26;
      TSUGetCurrentLocale();
      if (TSUIsGroupingSeparatorUsedInNumericString())
      {
        v31 |= 0x800u;
        LOWORD(v52) = v31;
      }
      if ([(NSString *)v10 characterAtIndex:0] == 40) {
        LOWORD(v52) = v31 & 0xF8FF | 0x200;
      }
      v41[0] = v51;
      v41[1] = v52;
      uint64_t v42 = v53;
      unsigned int v24 = (int *)v41;
      goto LABEL_60;
    }
    if ((v12 & 0xFFFFFFFC) == 0x100) {
      goto LABEL_47;
    }
    if (v12 == 262)
    {
      if (a2)
      {
        TSTCellClearValue(a1);
        *(unsigned char *)(a1 + 9) = 3;
        TSTCellSetStringValueClearingID((TSTCell *)a1, v6, 1);
        int v40 = 0;
        long long v39 = 0u;
        long long v38 = 0u;
        int v37 = 260;
        unsigned int v24 = &v37;
      }
      else
      {
        DWORD2(v51) = *MEMORY[0x263F7C940];
        LODWORD(v51) = 262;
        uint64_t v36 = v53;
        v35[0] = v51;
        v35[1] = v52;
        unsigned int v24 = (int *)v35;
      }
LABEL_60:
      TSTCellSetImplicitFormat(a1, (uint64_t)v24);
      goto LABEL_61;
    }
    double v33 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v34 = objc_msgSend(NSString, "stringWithUTF8String:", "BOOL TSTCellCoerceTextCellToBestNumberFormatUsingSpares(TSTCell *, BOOL)");
    objc_msgSend(v33, "handleFailureInFunction:file:lineNumber:description:", v34, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.mm"), 3998, @"unexpected format type");
  }
LABEL_61:
  if (v54) {

  }
  return v7 | a2;
}

BOOL TSTCellCoerceStepperSliderToRootFormatType(void *a1)
{
  int v1 = &TSUInvalidFormat;
  if (a1) {
    int v1 = (long long *)(a1 + 13);
  }
  unsigned int v2 = *(_DWORD *)v1 & 0xFFFFFFFE;
  if (v2 == 264)
  {
    TSTCellGetFormatOfType(a1, *((_DWORD *)v1 + 8), (uint64_t)v5);
    TSTCellSetExplicitFormat((uint64_t)a1, (uint64_t)v5);
  }
  return v2 == 264;
}

uint64_t TSTCellCoerceControlCellToNonControlType(uint64_t result)
{
  if (result)
  {
    int v1 = *(_DWORD *)(result + 104);
    if ((v1 - 263) > 4)
    {
      return 0;
    }
    else
    {
      if ((v1 - 264) < 2)
      {
        TSTCellCoerceStepperSliderToRootFormatType((void *)result);
      }
      else if (v1 == 267)
      {
        TSTCellCoerceCellToDecimalFormat(result);
      }
      else if (v1 == 263)
      {
        TSTCellSetImplicitFormat(result, (uint64_t)&TSUNotSetFormat);
      }
      return 1;
    }
  }
  return result;
}

uint64_t TSTCellHasExplicitFormatOfType(uint64_t a1, int a2)
{
  uint64_t result = 0;
  switch(a2)
  {
    case 256:
    case 258:
    case 259:
    case 262:
      if (!a1) {
        goto LABEL_34;
      }
      int v4 = *(void **)(a1 + 152);
      if (!v4) {
        goto LABEL_34;
      }
      [v4 getFormatStruct];
      if ((v12 - 1) > 0xFFFFFFFD) {
        goto LABEL_34;
      }
      uint64_t result = *(_WORD *)(a1 + 96) & 1;
      break;
    case 257:
      if (!a1) {
        goto LABEL_34;
      }
      int v7 = *(void **)(a1 + 168);
      if (!v7) {
        goto LABEL_34;
      }
      [v7 getFormatStruct];
      if ((v12 - 1) > 0xFFFFFFFD) {
        goto LABEL_34;
      }
      uint64_t result = (*(unsigned __int16 *)(a1 + 96) >> 1) & 1;
      break;
    case 261:
      if (!a1) {
        goto LABEL_34;
      }
      uint64_t v8 = *(void **)(a1 + 200);
      if (!v8) {
        goto LABEL_34;
      }
      [v8 getFormatStruct];
      if ((v12 - 1) > 0xFFFFFFFD) {
        goto LABEL_34;
      }
      uint64_t result = (*(unsigned __int16 *)(a1 + 96) >> 3) & 1;
      break;
    case 264:
    case 265:
      if (!a1) {
        goto LABEL_34;
      }
      int v6 = *(void **)(a1 + 216);
      if (!v6) {
        goto LABEL_34;
      }
      [v6 getFormatStruct];
      if ((v12 - 1) > 0xFFFFFFFD) {
        goto LABEL_34;
      }
      uint64_t result = (*(unsigned __int16 *)(a1 + 96) >> 6) & 1;
      break;
    case 266:
      if (!a1) {
        goto LABEL_34;
      }
      uint64_t v9 = *(void **)(a1 + 264);
      if (!v9) {
        goto LABEL_34;
      }
      [v9 getFormatStruct];
      if ((v12 - 1) > 0xFFFFFFFD) {
        goto LABEL_34;
      }
      uint64_t result = (*(unsigned __int16 *)(a1 + 96) >> 10) & 1;
      break;
    case 268:
      if (!a1) {
        goto LABEL_34;
      }
      double v10 = *(void **)(a1 + 184);
      if (!v10) {
        goto LABEL_34;
      }
      [v10 getFormatStruct];
      if ((v12 - 1) > 0xFFFFFFFD) {
        goto LABEL_34;
      }
      uint64_t result = (*(unsigned __int16 *)(a1 + 96) >> 2) & 1;
      break;
    case 269:
      if (!a1) {
        goto LABEL_34;
      }
      int v11 = *(void **)(a1 + 248);
      if (!v11) {
        goto LABEL_34;
      }
      [v11 getFormatStruct];
      if ((v12 - 1) > 0xFFFFFFFD) {
        goto LABEL_34;
      }
      uint64_t result = (*(unsigned __int16 *)(a1 + 96) >> 9) & 1;
      break;
    case 270:
    case 271:
    case 272:
      if (a1
        && (int v5 = *(void **)(a1 + 232)) != 0
        && ([v5 getFormatStruct], (v12 - 1) <= 0xFFFFFFFD))
      {
        uint64_t result = HIBYTE(*(unsigned __int16 *)(a1 + 96)) & 1;
      }
      else
      {
LABEL_34:
        uint64_t result = 0;
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t TSTCellCoerceCellToFormatUsingSpares(uint64_t a1, int a2)
{
  uint64_t v34 = 0;
  long long v32 = 0u;
  long long v33 = 0u;
  int v4 = -1;
  LODWORD(v32) = -1;
  if (TSTCellHasFormatOfType((void *)a1, a2))
  {
    TSTCellGetFormatOfType((void *)a1, a2, (uint64_t)&v32);
    if (v32 == a2)
    {
      int HasExplicitFormatOfType = TSTCellHasExplicitFormatOfType(a1, a2);
      int v4 = a2;
    }
    else
    {
      int HasExplicitFormatOfType = 0;
      uint64_t v34 = 0;
      long long v32 = TSUInvalidFormat;
      long long v33 = unk_22383BEB8;
    }
  }
  else
  {
    int HasExplicitFormatOfType = 0;
  }
  uint64_t v6 = TSTCellCoerceCellToFormat((TSTCell *)a1, a2);
  uint64_t v7 = v6;
  if (v4 != -1 && v6)
  {
    if ((a2 & 0xFFFFFFFE) != 0x108) {
      goto LABEL_36;
    }
    if ((v34 - 256) <= 6 && ((1 << v34) & 0x4D) != 0)
    {
      if (a1 && (uint64_t v8 = *(void **)(a1 + 152)) != 0)
      {
        [v8 getFormatStruct];
        int v9 = v31;
      }
      else
      {
        int v9 = -1;
      }
      LODWORD(v34) = v9;
    }
    if (a1)
    {
      int v10 = *(_DWORD *)(a1 + 8);
      if ((v10 & 0xFB00) == 0x200 || (int v11 = BYTE1(v10), v11 == 7))
      {
        double v12 = *(double *)(a1 + 16);
      }
      else
      {
        double v12 = 0.0;
        if (v11)
        {
          uint64_t v13 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v14 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
          objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, @"can't get value from non-value cell: %p", a1);
        }
      }
    }
    else
    {
      CFLocaleRef v15 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v16 = [NSString stringWithUTF8String:"double TSTCellDoubleValue(TSTCell *)"];
      objc_msgSend(v15, "handleFailureInFunction:file:lineNumber:description:", v16, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 889, @"invalid nil value for '%s'", "cell");
      double v12 = 0.0;
    }
    double v17 = *((double *)&v32 + 1);
    long long v18 = v33;
    if ((v4 & 0xFFFFFFFE) != 0x108)
    {
      __int16 v19 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v20 = objc_msgSend(NSString, "stringWithUTF8String:", "double TSUFormatRecomputedControlValue(double, TSUFormatStruct)");
      objc_msgSend(v19, "handleFailureInFunction:file:lineNumber:description:", v20, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Binaries/AlderShared/install/Root/usr/local/include/TSFrameworks/TSUtility/TSUFormatTypes.h"), 779, @"Expected a stepper or slider format.");
    }
    if (v17 < v12)
    {
      if (*(double *)&v18 <= v12
        || (double v17 = v17 + *((double *)&v18 + 1) * round((v12 - v17) / *((double *)&v18 + 1)), v17 > *(double *)&v18))
      {
        double v17 = *(double *)&v18;
      }
    }
    if (a1)
    {
      unsigned int v21 = *(_DWORD *)(a1 + 8);
      if ((v21 & 0xFF00) != 0)
      {
LABEL_34:
        if ((v21 & 0xFF00) != 0x200)
        {
          unsigned int v24 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v25 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellSetDoubleValue(TSTCell *, double)");
          objc_msgSend(v24, "handleFailureInFunction:file:lineNumber:description:", v25, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 912, @"can't set value to non-value cell: %p", a1);
          if (HasExplicitFormatOfType) {
            goto LABEL_37;
          }
          goto LABEL_39;
        }
        *(double *)(a1 + 16) = v17;
LABEL_36:
        if (HasExplicitFormatOfType)
        {
LABEL_37:
          v29[0] = v32;
          v29[1] = v33;
          uint64_t v30 = v34;
          TSTCellSetExplicitFormat(a1, (uint64_t)v29);
          return v7;
        }
LABEL_39:
        v27[0] = v32;
        v27[1] = v33;
        uint64_t v28 = v34;
        TSTCellSetImplicitFormat(a1, (uint64_t)v27);
        return v7;
      }
    }
    else
    {
      __int16 v22 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v23 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellSetDoubleValue(TSTCell *, double)");
      objc_msgSend(v22, "handleFailureInFunction:file:lineNumber:description:", v23, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 904, @"invalid nil value for '%s'", "cell");
    }
    TSTCellClearValue(a1);
    unsigned int v21 = *(_DWORD *)(a1 + 8) & 0xFFFF00FF | 0x200;
    *(_DWORD *)(a1 + 8) = v21;
    goto LABEL_34;
  }
  return v7;
}

uint64_t TSTCellCoerceTextCellToNumberFormatWithSeparatorFixing(uint64_t a1, int a2)
{
  if (a1 && (int v4 = *(unsigned __int8 *)(a1 + 9), *(unsigned char *)(a1 + 9)))
  {
    if (v4 == 9)
    {
      int v5 = (__CFString *)[*(id *)(a1 + 72) string];
    }
    else if (v4 == 3)
    {
      int v5 = *(__CFString **)(a1 + 24);
    }
    else
    {
      uint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      uint64_t v7 = [NSString stringWithUTF8String:"NSString *TSTCellStringValue(TSTCell *)"];
      objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, @"can't get string from non-string cell: %p", a1);
      int v5 = 0;
    }
  }
  else
  {
    int v5 = &stru_26D688A48;
  }
  TSUGetCurrentLocale();
  uint64_t result = TSUIsGroupingSeparatorUsedInNumericString();
  if (result)
  {
    CFLocaleRef v9 = (const __CFLocale *)TSUGetCurrentLocale();
    int v10 = (NSString *)[(__CFString *)v5 stringByReplacingOccurrencesOfString:CFLocaleGetValue(v9, (CFLocaleKey)*MEMORY[0x263EFFCE0]) withString:&stru_26D688A48];
    int v11 = objc_alloc_init(TSTCell);
    TSTCellCopy(a1, (uint64_t)v11);
    TSTCellSetStringValueClearingID(v11, v10, 1);
    uint64_t result = TSTCellCoerceCellToFormat(v11, a2);
    if (result)
    {
      p_int mFormatType = (long long *)&v11->mPrivate.mCellFormats.mCurrentCellFormat.mFormatType;
      if (!v11) {
        p_int mFormatType = &TSUInvalidFormat;
      }
      if (*(_DWORD *)p_mFormatType != 259 && (*(_DWORD *)p_mFormatType & 0xFFFFFFFC) == 0x100)
      {
        __int16 v13 = *((_WORD *)p_mFormatType + 8) | 0x800;
        int v14 = *(_DWORD *)p_mFormatType;
        uint64_t v15 = *(void *)((char *)p_mFormatType + 4);
        int v16 = *((_DWORD *)p_mFormatType + 3);
        __int16 v17 = v13;
        *(_OWORD *)long long v18 = *(long long *)((char *)p_mFormatType + 18);
        *(void *)&v18[14] = *((void *)p_mFormatType + 4);
        TSTCellSetImplicitFormat((uint64_t)v11, (uint64_t)&v14);
      }
      TSTCellCopy((uint64_t)v11, a1);
      return 1;
    }
  }
  return result;
}

uint64_t TSTCellCreateWithCellAndSetFormulaError(TSTCell *a1, TSWPStorage *a2)
{
  uint64_t v3 = objc_alloc_init(TSTCell);
  uint64_t v4 = (uint64_t)v3;
  if (a1) {
    TSTCellCopy((uint64_t)a1, (uint64_t)v3);
  }
  else {
    TSTCellSetImplicitFormat((uint64_t)v3, (uint64_t)&TSUNotSetFormat);
  }
  int v5 = *(void **)(v4 + 72);
  if (v5)
  {

    *(void *)(v4 + 72) = 0;
  }
  *(_DWORD *)(v4 + 64) = 0;
  TSTCellClearValue(v4);
  *(unsigned char *)(v4 + 9) = 8;
  if ((*(_DWORD *)(v4 + 104) - 263) <= 4) {
    TSTCellSetImplicitFormat(v4, (uint64_t)&TSUNotSetFormat);
  }
  return v4;
}

uint64_t TSTCellCreateWithCellAndSetFormula(uint64_t a1)
{
  unsigned int v2 = objc_alloc_init(TSTCell);
  uint64_t v3 = (uint64_t)v2;
  if (a1) {
    TSTCellCopy(a1, (uint64_t)v2);
  }
  else {
    TSTCellSetImplicitFormat((uint64_t)v2, (uint64_t)&TSUNotSetFormat);
  }
  uint64_t v4 = *(void **)(v3 + 72);
  if (v4)
  {

    *(void *)(v3 + 72) = 0;
  }
  *(_DWORD *)(v3 + 64) = 0;
  TSTCellClearValue(v3);
  *(_DWORD *)(v3 + 8) &= 0xFFFF00FF;
  if ((*(_DWORD *)(v3 + 104) - 263) <= 4) {
    TSTCellSetImplicitFormat(v3, (uint64_t)&TSUNotSetFormat);
  }
  return v3;
}

TSTCell *TSTCellCreateWithCellAndSetBoolean(uint64_t a1, int a2)
{
  uint64_t v4 = objc_alloc_init(TSTCell);
  if (a1) {
    TSTCellCopy(a1, (uint64_t)v4);
  }
  mRichTextPayload = v4->mPrivate.mRichTextPayload;
  if (mRichTextPayload)
  {

    v4->mPrivate.mRichTextPayload = 0;
  }
  v4->mPrivate.mRichTextPayloadID = 0;
  int mFormatType = v4->mPrivate.mCellFormats.mCurrentCellFormat.mFormatType;
  TSTCellClearValue((uint64_t)v4);
  unsigned int mPrivate = *(_DWORD *)&v4->mPrivate & 0xFFFF00FF | 0x600;
  *(_DWORD *)&v4->unsigned int mPrivate = mPrivate;
  if (mFormatType != 263)
  {
    int v15 = 0;
    long long v14 = 0u;
    long long v13 = 0u;
    int v12 = 263;
    TSTCellSetImplicitFormat((uint64_t)v4, (uint64_t)&v12);
    unsigned int mPrivate = v4->mPrivate;
  }
  if ((mPrivate & 0xFF00) == 0)
  {
    TSTCellClearValue((uint64_t)v4);
    unsigned int mPrivate = *(_DWORD *)&v4->mPrivate & 0xFFFF00FF | 0x600;
    *(_DWORD *)&v4->unsigned int mPrivate = mPrivate;
  }
  if ((mPrivate & 0xFF00) == 0x600)
  {
    double v8 = 0.0;
    if (a2) {
      double v8 = 1.0;
    }
    v4->mPrivate.mValue.double mDouble = v8;
  }
  else
  {
    CFLocaleRef v9 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v10 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellSetBoolValue(TSTCell *, BOOL)");
    objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 939, @"can't set BOOL value to non-BOOL cell: %p", v4);
  }
  return v4;
}

TSTCell *TSTCellCreateWithCellAndSetDate(uint64_t a1, NSDate *a2)
{
  uint64_t v4 = objc_alloc_init(TSTCell);
  if (a1) {
    TSTCellCopy(a1, (uint64_t)v4);
  }
  mRichTextPayload = v4->mPrivate.mRichTextPayload;
  if (mRichTextPayload)
  {

    v4->mPrivate.mRichTextPayload = 0;
  }
  v4->mPrivate.mRichTextPayloadID = 0;
  int mFormatType = v4->mPrivate.mCellFormats.mCurrentCellFormat.mFormatType;
  if (mFormatType == 272 || mFormatType == 261)
  {
    TSTCellClearValue((uint64_t)v4);
    *((unsigned char *)&v4->mPrivate + 1) = 5;
    goto LABEL_19;
  }
  mDateFormatRef = v4->mPrivate.mCellFormats.mDateFormatRef;
  if (!mDateFormatRef
    || ([(TSUFormatReferenceObject *)mDateFormatRef getFormatStruct],
        (v22 - 1) > 0xFFFFFFFD))
  {
    if (TSTCellCoerceCellToFormat(v4, 261)) {
      goto LABEL_19;
    }
    TSTCellClearValue((uint64_t)v4);
    *((unsigned char *)&v4->mPrivate + 1) = 5;
    int v15 = 261;
    uint64_t v16 = 0;
    uint64_t v17 = TSUDefaultDateTimeFormat();
    CFLocaleRef v9 = &v15;
    goto LABEL_17;
  }
  TSTCellClearValue((uint64_t)v4);
  *((unsigned char *)&v4->mPrivate + 1) = 5;
  uint64_t v24 = 0;
  long long v22 = 0u;
  long long v23 = 0u;
  double v8 = v4->mPrivate.mCellFormats.mDateFormatRef;
  if (v8)
  {
    [(TSUFormatReferenceObject *)v8 getFormatStruct];
  }
  else
  {
    uint64_t v24 = 0;
    long long v22 = TSUInvalidFormat;
    long long v23 = unk_22383BEB8;
  }
  if ((*(_WORD *)&v4->mPrivate.mCellFormats & 8) == 0)
  {
    v18[0] = v22;
    v18[1] = v23;
    uint64_t v19 = v24;
    CFLocaleRef v9 = (int *)v18;
LABEL_17:
    TSTCellSetImplicitFormat((uint64_t)v4, (uint64_t)v9);
    goto LABEL_19;
  }
  v20[0] = v22;
  v20[1] = v23;
  uint64_t v21 = v24;
  TSTCellSetExplicitFormat((uint64_t)v4, (uint64_t)v20);
LABEL_19:
  unsigned int mPrivate = v4->mPrivate;
  if ((mPrivate & 0xFF00) == 0)
  {
    TSTCellClearValue((uint64_t)v4);
    unsigned int mPrivate = *(_DWORD *)&v4->mPrivate & 0xFFFF00FF | 0x500;
    *(_DWORD *)&v4->unsigned int mPrivate = mPrivate;
  }
  if ((mPrivate & 0xFF00) == 0x500)
  {
    mDate = v4->mPrivate.mValue.mDate;
    if (mDate != a2)
    {

      v4->mPrivate.mValue.mDate = a2;
    }
  }
  else
  {
    int v12 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v13 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellSetDateValue(TSTCell *, NSDate *)");
    objc_msgSend(v12, "handleFailureInFunction:file:lineNumber:description:", v13, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 1038, @"can't set date value on a non-date cell: %p", v4);
  }
  return v4;
}

TSTCell *TSTCellCreateWithCellAndSetDuration(uint64_t a1, double a2)
{
  uint64_t v4 = objc_alloc_init(TSTCell);
  if (a1) {
    TSTCellCopy(a1, (uint64_t)v4);
  }
  mRichTextPayload = v4->mPrivate.mRichTextPayload;
  if (mRichTextPayload)
  {

    v4->mPrivate.mRichTextPayload = 0;
  }
  v4->mPrivate.mRichTextPayloadID = 0;
  if (v4->mPrivate.mCellFormats.mCurrentCellFormat.mFormatType == 268)
  {
    TSTCellClearValue((uint64_t)v4);
    *((unsigned char *)&v4->mPrivate + 1) = 7;
    goto LABEL_18;
  }
  mDurationFormatRef = v4->mPrivate.mCellFormats.mDurationFormatRef;
  if (!mDurationFormatRef
    || ([(TSUFormatReferenceObject *)mDurationFormatRef getFormatStruct],
        (v21 - 1) > 0xFFFFFFFD))
  {
    if (TSTCellCoerceCellToFormat(v4, 268)) {
      goto LABEL_18;
    }
    TSTCellClearValue((uint64_t)v4);
    *((unsigned char *)&v4->mPrivate + 1) = 7;
    unint64_t v8 = ((unint64_t)*MEMORY[0x263F7C938] << 32) | 4;
    int v14 = 268;
    uint64_t v15 = 0x1000000001;
    unint64_t v16 = v8;
    CFLocaleRef v9 = &v14;
    goto LABEL_16;
  }
  TSTCellClearValue((uint64_t)v4);
  *((unsigned char *)&v4->mPrivate + 1) = 7;
  uint64_t v23 = 0;
  long long v21 = 0u;
  long long v22 = 0u;
  uint64_t v7 = v4->mPrivate.mCellFormats.mDurationFormatRef;
  if (v7)
  {
    [(TSUFormatReferenceObject *)v7 getFormatStruct];
  }
  else
  {
    uint64_t v23 = 0;
    long long v21 = TSUInvalidFormat;
    long long v22 = unk_22383BEB8;
  }
  if ((*(_WORD *)&v4->mPrivate.mCellFormats & 4) == 0)
  {
    v17[0] = v21;
    v17[1] = v22;
    uint64_t v18 = v23;
    CFLocaleRef v9 = (int *)v17;
LABEL_16:
    TSTCellSetImplicitFormat((uint64_t)v4, (uint64_t)v9);
    goto LABEL_18;
  }
  v19[0] = v21;
  v19[1] = v22;
  uint64_t v20 = v23;
  TSTCellSetExplicitFormat((uint64_t)v4, (uint64_t)v19);
LABEL_18:
  unsigned int mPrivate = v4->mPrivate;
  if ((mPrivate & 0xFF00) == 0)
  {
    TSTCellClearValue((uint64_t)v4);
    unsigned int mPrivate = *(_DWORD *)&v4->mPrivate & 0xFFFF00FF | 0x700;
    *(_DWORD *)&v4->unsigned int mPrivate = mPrivate;
  }
  if ((mPrivate & 0xFF00) == 0x700)
  {
    v4->mPrivate.mValue.double mDouble = a2;
  }
  else
  {
    int v11 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v12 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellSetDurationValue(TSTCell *, NSTimeInterval)");
    objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 1080, @"can't set duration value on a non-duration cell: %p", v4);
  }
  return v4;
}

TSTCell *TSTCellCreateWithCellAndSetText(uint64_t a1, NSString *a2)
{
  uint64_t v4 = objc_alloc_init(TSTCell);
  if (a1) {
    TSTCellCopy(a1, (uint64_t)v4);
  }
  mRichTextPayload = v4->mPrivate.mRichTextPayload;
  if (mRichTextPayload)
  {

    v4->mPrivate.mRichTextPayload = 0;
  }
  v4->mPrivate.mRichTextPayloadID = 0;
  int mFormatType = v4->mPrivate.mCellFormats.mCurrentCellFormat.mFormatType;
  if (mFormatType == 271 || mFormatType == 260)
  {
    TSTCellClearValue((uint64_t)v4);
    *((unsigned char *)&v4->mPrivate + 1) = 3;
  }
  else
  {
    TSTCellClearValue((uint64_t)v4);
    *((unsigned char *)&v4->mPrivate + 1) = 3;
    long long v9 = 0u;
    long long v10 = 0u;
    int v11 = 0;
    int v8 = 260;
    TSTCellSetImplicitFormat((uint64_t)v4, (uint64_t)&v8);
  }
  TSTCellSetStringValueClearingID(v4, a2, 1);
  return v4;
}

TSTCell *TSTCellCreateWithCellAndSetNumber(uint64_t a1, double mMinimum)
{
  uint64_t v4 = objc_alloc_init(TSTCell);
  if (a1) {
    TSTCellCopy(a1, (uint64_t)v4);
  }
  mRichTextPayload = v4->mPrivate.mRichTextPayload;
  if (mRichTextPayload)
  {

    v4->mPrivate.mRichTextPayload = 0;
  }
  p_mCurrentCellFormat = &v4->mPrivate.mCellFormats.mCurrentCellFormat;
  int mFormatType = v4->mPrivate.mCellFormats.mCurrentCellFormat.mFormatType;
  v4->mPrivate.mRichTextPayloadID = 0;
  unsigned int v8 = mFormatType - 256;
  if (v8 > 0xE) {
    goto LABEL_18;
  }
  if (((1 << v8) & 0x604D) != 0)
  {
    TSTCellClearValue((uint64_t)v4);
    *((unsigned char *)&v4->mPrivate + 1) = 2;
    goto LABEL_43;
  }
  if (((1 << v8) & 0x300) != 0)
  {
    if (v4->mPrivate.mCellFormats.mCurrentCellFormat.var0.mControlFormatStruct.mDisplayFormatType == 257)
    {
      int v9 = *((_DWORD *)&v4->mPrivate.mCellFormats.mCurrentCellFormat.var0.mMultipleChoiceListFormatStruct + 7);
      long long v10 = *(_OWORD *)&v4->mPrivate.mCellFormats.mCurrentCellFormat.var0.mMultipleChoiceListFormatStruct.mData;
      if ((*(_WORD *)&v4->mPrivate.mCellFormats & 0x10) != 0)
      {
        v34[0] = *(_OWORD *)&p_mCurrentCellFormat->mFormatType;
        v34[1] = v10;
        int v35 = 256;
        int v36 = v9;
        TSTCellSetExplicitFormat((uint64_t)v4, (uint64_t)v34);
      }
      else
      {
        v31[0] = *(_OWORD *)&p_mCurrentCellFormat->mFormatType;
        v31[1] = v10;
        int v32 = 256;
        int v33 = v9;
        TSTCellSetImplicitFormat((uint64_t)v4, (uint64_t)v31);
      }
      mNumberFormatRef = v4->mPrivate.mCellFormats.mNumberFormatRef;
      if (!mNumberFormatRef)
      {
LABEL_28:
        unint64_t v17 = ((unint64_t)(*MEMORY[0x263F7C948] & 7) << 8) | 0xFD;
        LODWORD(v42) = 256;
        *((void *)&v42 + 1) = 0;
        *(void *)&long long v43 = v17;
        if (mNumberFormatRef)
        {
          [(TSUFormatReferenceObject *)mNumberFormatRef getFormatStruct];
        }
        else
        {
          uint64_t v41 = 0;
          memset(v40, 0, sizeof(v40));
        }
        if ((TSUEqualFormatStructs((uint64_t)&v42, (uint64_t)v40) & 1) == 0)
        {

          id v18 = objc_alloc(MEMORY[0x263F7C850]);
          int v37 = 256;
          uint64_t v38 = 0;
          unint64_t v39 = v17;
          v4->mPrivate.mCellFormats.mNumberFormatRef = (TSUFormatReferenceObject *)[v18 initWithTSUFormatFormatStruct:&v37];
          v4->mPrivate.mCellFormats.mNumberFormatID = 0;
        }
        goto LABEL_33;
      }
      [(TSUFormatReferenceObject *)mNumberFormatRef getFormatStruct];
      if ((v42 - 1) >= 0xFFFFFFFE)
      {
        mNumberFormatRef = v4->mPrivate.mCellFormats.mNumberFormatRef;
        goto LABEL_28;
      }
    }
LABEL_33:
    TSTCellClearValue((uint64_t)v4);
    *((unsigned char *)&v4->mPrivate + 1) = 2;
    double mMaximum = v4->mPrivate.mCellFormats.mCurrentCellFormat.var0.mControlFormatStruct.mMaximum;
    if (mMaximum >= mMinimum) {
      double mMaximum = mMinimum;
    }
    if (v4->mPrivate.mCellFormats.mCurrentCellFormat.var0.mControlFormatStruct.mMinimum <= mMaximum) {
      mMinimum = mMaximum;
    }
    else {
      mMinimum = v4->mPrivate.mCellFormats.mCurrentCellFormat.var0.mControlFormatStruct.mMinimum;
    }
    goto LABEL_43;
  }
  if (v8 != 11)
  {
LABEL_18:
    uint64_t v12 = v4->mPrivate.mCellFormats.mNumberFormatRef;
    if (v12
      && ([(TSUFormatReferenceObject *)v12 getFormatStruct], (v42 - 1) <= 0xFFFFFFFD))
    {
      TSTCellClearValue((uint64_t)v4);
      *((unsigned char *)&v4->mPrivate + 1) = 2;
      uint64_t v44 = 0;
      long long v42 = 0u;
      long long v43 = 0u;
      uint64_t v13 = v4->mPrivate.mCellFormats.mNumberFormatRef;
      if (v13)
      {
        [(TSUFormatReferenceObject *)v13 getFormatStruct];
      }
      else
      {
        uint64_t v44 = 0;
        long long v42 = TSUInvalidFormat;
        long long v43 = unk_22383BEB8;
      }
      if (*(_WORD *)&v4->mPrivate.mCellFormats)
      {
        v29[0] = v42;
        v29[1] = v43;
        uint64_t v30 = v44;
        TSTCellSetExplicitFormat((uint64_t)v4, (uint64_t)v29);
        goto LABEL_43;
      }
      v27[0] = v42;
      v27[1] = v43;
      uint64_t v28 = v44;
      uint64_t v15 = (int *)v27;
    }
    else
    {
      if (TSTCellCoerceCellToFormat(v4, 256)) {
        goto LABEL_43;
      }
      TSTCellClearValue((uint64_t)v4);
      *((unsigned char *)&v4->mPrivate + 1) = 2;
      uint64_t v14 = ((*MEMORY[0x263F7C948] & 7) << 8) | 0xFD;
      int v24 = 256;
      uint64_t v25 = 0;
      uint64_t v26 = v14;
      uint64_t v15 = &v24;
    }
    TSTCellSetImplicitFormat((uint64_t)v4, (uint64_t)v15);
    goto LABEL_43;
  }
  TSTCellClearValue((uint64_t)v4);
  *((unsigned char *)&v4->mPrivate + 1) = 2;
  double v11 = 5.0;
  if (mMinimum <= 5.0) {
    double v11 = mMinimum;
  }
  if (v11 >= 0.0) {
    mMinimum = v11;
  }
  else {
    mMinimum = 0.0;
  }
LABEL_43:
  unsigned int mPrivate = v4->mPrivate;
  if ((mPrivate & 0xFF00) == 0)
  {
    TSTCellClearValue((uint64_t)v4);
    unsigned int mPrivate = *(_DWORD *)&v4->mPrivate & 0xFFFF00FF | 0x200;
    *(_DWORD *)&v4->unsigned int mPrivate = mPrivate;
  }
  if ((mPrivate & 0xFF00) == 0x200)
  {
    v4->mPrivate.mValue.double mDouble = mMinimum;
  }
  else
  {
    long long v21 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v22 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellSetDoubleValue(TSTCell *, double)");
    objc_msgSend(v21, "handleFailureInFunction:file:lineNumber:description:", v22, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 912, @"can't set value to non-value cell: %p", v4);
  }
  return v4;
}

TSTCell *TSTCellCreateWithCellAndSetCurrency(uint64_t a1, double mMinimum)
{
  uint64_t v4 = objc_alloc_init(TSTCell);
  if (a1) {
    TSTCellCopy(a1, (uint64_t)v4);
  }
  mRichTextPayload = v4->mPrivate.mRichTextPayload;
  if (mRichTextPayload)
  {

    v4->mPrivate.mRichTextPayload = 0;
  }
  p_mCurrentCellFormat = &v4->mPrivate.mCellFormats.mCurrentCellFormat;
  int mFormatType = v4->mPrivate.mCellFormats.mCurrentCellFormat.mFormatType;
  v4->mPrivate.mRichTextPayloadID = 0;
  if ((mFormatType - 264) >= 2)
  {
    if (mFormatType == 257)
    {
      TSTCellClearValue((uint64_t)v4);
      *((unsigned char *)&v4->mPrivate + 1) = 2;
      goto LABEL_46;
    }
    mCurrencyFormatRef = v4->mPrivate.mCellFormats.mCurrencyFormatRef;
    if (mCurrencyFormatRef
      && ([(TSUFormatReferenceObject *)mCurrencyFormatRef getFormatStruct],
          (defaultFractionDigits - 1) <= 0xFFFFFFFD))
    {
      TSTCellClearValue((uint64_t)v4);
      *((unsigned char *)&v4->mPrivate + 1) = 2;
      uint64_t v56 = 0;
      long long defaultFractionDigits = 0u;
      long long v55 = 0u;
      double v11 = v4->mPrivate.mCellFormats.mCurrencyFormatRef;
      if (v11)
      {
        [(TSUFormatReferenceObject *)v11 getFormatStruct];
      }
      else
      {
        uint64_t v56 = 0;
        long long defaultFractionDigits = TSUInvalidFormat;
        long long v55 = unk_22383BEB8;
      }
      if ((*(_WORD *)&v4->mPrivate.mCellFormats & 2) != 0)
      {
        v41[0] = defaultFractionDigits;
        v41[1] = v55;
        uint64_t v42 = v56;
        TSTCellSetExplicitFormat((uint64_t)v4, (uint64_t)v41);
        goto LABEL_46;
      }
      v39[0] = defaultFractionDigits;
      v39[1] = v55;
      uint64_t v40 = v56;
      uint64_t v19 = (int *)v39;
    }
    else
    {
      if (TSTCellCoerceCellToFormat(v4, 257)) {
        goto LABEL_46;
      }
      TSTCellClearValue((uint64_t)v4);
      *((unsigned char *)&v4->mPrivate + 1) = 2;
      CFLocaleRef v12 = (const __CFLocale *)TSUGetCurrentLocale();
      Value = (__CFString *)CFLocaleGetValue(v12, (CFLocaleKey)*MEMORY[0x263EFFCB8]);
      if (Value) {
        uint64_t v14 = Value;
      }
      else {
        uint64_t v14 = @"USD";
      }
      LODWORD(defaultFractionDigits) = 0;
      int DecimalInfoForCurrencyCode = CFNumberFormatterGetDecimalInfoForCurrencyCode(v14, (int32_t *)&defaultFractionDigits, 0);
      unint64_t v16 = v14;
      uint64_t v17 = defaultFractionDigits;
      if (!DecimalInfoForCurrencyCode) {
        uint64_t v17 = 2;
      }
      unint64_t v18 = v17 & 0xFFFFFFFFFFFFF8FFLL | ((*MEMORY[0x263F7C948] & 7) << 8);
      int v36 = 257;
      int v37 = v16;
      unint64_t v38 = v18;
      uint64_t v19 = &v36;
    }
    TSTCellSetImplicitFormat((uint64_t)v4, (uint64_t)v19);
    goto LABEL_46;
  }
  if (v4->mPrivate.mCellFormats.mCurrentCellFormat.var0.mControlFormatStruct.mDisplayFormatType != 257)
  {
    int v8 = *((_DWORD *)&v4->mPrivate.mCellFormats.mCurrentCellFormat.var0.mMultipleChoiceListFormatStruct + 7);
    long long v9 = *(_OWORD *)&v4->mPrivate.mCellFormats.mCurrentCellFormat.var0.mMultipleChoiceListFormatStruct.mData;
    if ((*(_WORD *)&v4->mPrivate.mCellFormats & 0x10) != 0)
    {
      v46[0] = *(_OWORD *)&p_mCurrentCellFormat->mFormatType;
      v46[1] = v9;
      int v47 = 257;
      int v48 = v8;
      TSTCellSetExplicitFormat((uint64_t)v4, (uint64_t)v46);
    }
    else
    {
      v43[0] = *(_OWORD *)&p_mCurrentCellFormat->mFormatType;
      v43[1] = v9;
      int v44 = 257;
      int v45 = v8;
      TSTCellSetImplicitFormat((uint64_t)v4, (uint64_t)v43);
    }
    uint64_t v20 = v4->mPrivate.mCellFormats.mCurrencyFormatRef;
    if (!v20
      || ([(TSUFormatReferenceObject *)v20 getFormatStruct],
          (defaultFractionDigits - 1) >= 0xFFFFFFFE))
    {
      CFLocaleRef v21 = (const __CFLocale *)TSUGetCurrentLocale();
      uint64_t v22 = (__CFString *)CFLocaleGetValue(v21, (CFLocaleKey)*MEMORY[0x263EFFCB8]);
      uint64_t v23 = v22 ? v22 : @"USD";
      LODWORD(defaultFractionDigits) = 0;
      int v24 = CFNumberFormatterGetDecimalInfoForCurrencyCode(v23, (int32_t *)&defaultFractionDigits, 0);
      uint64_t v25 = v23;
      uint64_t v26 = v25;
      uint64_t v27 = v24 ? defaultFractionDigits : 2;
      unint64_t v28 = v27 & 0xFFFFFFFFFFFFF8FFLL | ((unint64_t)(*MEMORY[0x263F7C948] & 7) << 8);
      LODWORD(defaultFractionDigits) = 257;
      *((void *)&defaultFractionDigits + 1) = v25;
      *(void *)&long long v55 = v28;
      unint64_t v29 = v4->mPrivate.mCellFormats.mCurrencyFormatRef;
      if (v29)
      {
        [(TSUFormatReferenceObject *)v29 getFormatStruct];
      }
      else
      {
        uint64_t v53 = 0;
        memset(v52, 0, sizeof(v52));
      }
      if ((TSUEqualFormatStructs((uint64_t)&defaultFractionDigits, (uint64_t)v52) & 1) == 0)
      {

        id v30 = objc_alloc(MEMORY[0x263F7C850]);
        int v49 = 257;
        uint64_t v50 = v26;
        unint64_t v51 = v28;
        v4->mPrivate.mCellFormats.mCurrencyFormatRef = (TSUFormatReferenceObject *)[v30 initWithTSUFormatFormatStruct:&v49];
        v4->mPrivate.mCellFormats.mCurrencyFormatID = 0;
      }
    }
  }
  TSTCellClearValue((uint64_t)v4);
  *((unsigned char *)&v4->mPrivate + 1) = 2;
  double mMaximum = v4->mPrivate.mCellFormats.mCurrentCellFormat.var0.mControlFormatStruct.mMaximum;
  if (mMaximum >= mMinimum) {
    double mMaximum = mMinimum;
  }
  if (v4->mPrivate.mCellFormats.mCurrentCellFormat.var0.mControlFormatStruct.mMinimum <= mMaximum) {
    mMinimum = mMaximum;
  }
  else {
    mMinimum = v4->mPrivate.mCellFormats.mCurrentCellFormat.var0.mControlFormatStruct.mMinimum;
  }
LABEL_46:
  unsigned int mPrivate = v4->mPrivate;
  if ((mPrivate & 0xFF00) == 0)
  {
    TSTCellClearValue((uint64_t)v4);
    unsigned int mPrivate = *(_DWORD *)&v4->mPrivate & 0xFFFF00FF | 0x200;
    *(_DWORD *)&v4->unsigned int mPrivate = mPrivate;
  }
  if ((mPrivate & 0xFF00) == 0x200)
  {
    v4->mPrivate.mValue.double mDouble = mMinimum;
  }
  else
  {
    int v33 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v34 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTCellSetDoubleValue(TSTCell *, double)");
    objc_msgSend(v33, "handleFailureInFunction:file:lineNumber:description:", v34, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 912, @"can't set value to non-value cell: %p", v4);
  }
  return v4;
}

void sub_2237D427C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_2237D4750(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v7 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_2237D48F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v7 - 64), 8);
  _Unwind_Resume(a1);
}

void *TSTCellIteratorGetNextCell(void *a1, const char *a2)
{
  if (a1) {
    return (void *)[a1 getNext:a2];
  }
  return a1;
}

uint64_t TSTCellIteratorCellIsStyleOnly(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 32);
}

uint64_t TSTCellIteratorCellIsCommentStorageOnly(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 33);
}

uint64_t TSTCellIteratorCellStylePointer(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    return *(void *)(v1 + 40);
  }
  else {
    return 0;
  }
}

uint64_t TSTCellIteratorTextStylePointer(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    return *(void *)(v1 + 56);
  }
  else {
    return 0;
  }
}

uint64_t TSTCellIteratorGetCell(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t TSTCellIteratorCellHasFormula(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1) {
    return (*(unsigned __int8 *)(v1 + 4) >> 3) & 1;
  }
  else {
    return 0;
  }
}

uint64_t TSTCellIteratorCellHasCustomFormat(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1 && (unint64_t v2 = *(void *)(v1 + 4), (v2 & 4) != 0)) {
    return (v2 >> 53) & 1;
  }
  else {
    return 0;
  }
}

uint64_t TSTCellIteratorCellHasCommentStorage(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1) {
    return (*(unsigned __int8 *)(v1 + 5) >> 4) & 1;
  }
  else {
    return 0;
  }
}

uint64_t TSTCellIteratorValueTypeOfCell(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1) {
    return *(unsigned __int8 *)(v1 + 2);
  }
  else {
    return 0;
  }
}

void *TSTCellIteratorExpandCell(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void **)(a1 + 88);
  *(void *)(a2 + 8) = result;
  uint64_t v4 = *(void *)(a2 + 16);
  if (v4) {
    return (void *)[result inflateFromStorageRef:v4 dataStore:*(void *)(a1 + 32)];
  }
  return result;
}

void *TSTCellIteratorExpandCellForLayout(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void **)(a1 + 88);
  *(void *)(a2 + 8) = result;
  uint64_t v4 = *(void *)(a2 + 16);
  if (v4) {
    return (void *)[result inflateFromStorageRef:v4 dataStore:*(void *)(a1 + 32) suppressingFormulaInflation:1];
  }
  return result;
}

uint64_t TSTLayoutSpaceSetGridRange(uint64_t result, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(_DWORD *)(result + 24);
  unsigned int v4 = *(_DWORD *)(result + 28);
  unsigned int v5 = *(_DWORD *)(result + 32);
  unsigned int v6 = *(_DWORD *)(result + 36);
  if (a2 != -1
    && a3 != -1
    && a2 <= a3
    && HIDWORD(a2) != -1
    && HIDWORD(a3) != -1
    && HIDWORD(a2) <= HIDWORD(a3)
    || (v3 != -1 ? (BOOL v7 = v5 == -1) : (BOOL v7 = 1),
        !v7 ? (BOOL v8 = v3 > v5) : (BOOL v8 = 1),
        !v8 ? (BOOL v9 = v4 == -1) : (BOOL v9 = 1),
        !v9 ? (BOOL v10 = v6 == -1) : (BOOL v10 = 1),
        !v10 ? (BOOL v11 = v4 > v6) : (BOOL v11 = 1),
        !v11))
  {
    if (a2 != v3 || HIDWORD(a2) != v4 || a3 != v5 || HIDWORD(a3) != v6)
    {
      *(void *)(result + 24) = a2;
      *(void *)(result + 32) = a3;
      *(unsigned char *)(result + 20) = 1;
    }
  }
  return result;
}

uint64_t TSTLayoutSpaceGetGridRange(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 24);
  if (!a1) {
    uint64_t v1 = &TSTGridRangeEmpty;
  }
  return *(void *)v1;
}

unint64_t TSTLayoutSpaceGetRange(uint64_t a1)
{
  if (!a1) {
    return 0xFFFFFFLL;
  }
  uint64_t v1 = *(void *)(a1 + 24);
  uint64_t v2 = *(void *)(a1 + 32);
  if (HIDWORD(v1) == -1 || HIDWORD(v2) == -1 || HIDWORD(v1) > HIDWORD(v2)) {
    unint64_t v5 = 0;
  }
  else {
    unint64_t v5 = ((v2 - (v1 & 0xFFFFFFFF00000000)) & 0xFFFFFFFF00000000 | (v2 - v1 + 1)) + 0x100000000;
  }
  if (v1 == -1 || v2 == -1 || v1 > v2) {
    unint64_t v8 = 0;
  }
  else {
    unint64_t v8 = v5;
  }
  unint64_t v9 = (unint64_t)v1 << 16;
  if (v1 == -1) {
    unint64_t v9 = 16711680;
  }
  return v9 & 0xFFFFFFFFFFFF0000 | WORD2(v1) | (((v8 >> 16) & 0xFFFF0000 | v8) << 32);
}

unint64_t TSTLayoutSpaceGetHeaderRowsGridRange(uint64_t a1)
{
  int TableNumberOfHeaderRows = TSTMasterLayoutGetTableNumberOfHeaderRows((unsigned __int16 *)[(id)a1 masterLayout]);
  if (!TableNumberOfHeaderRows) {
    goto LABEL_18;
  }
  unsigned int v3 = *(_DWORD *)(a1 + 32);
  unsigned int v4 = TableNumberOfHeaderRows - 1;
  if (v3 == -1)
  {
    uint64_t v6 = -1;
    goto LABEL_15;
  }
  uint64_t v5 = *(void *)(a1 + 24);
  uint64_t v6 = -1;
  if (v5 == -1)
  {
LABEL_15:
    uint64_t v7 = -1;
    goto LABEL_16;
  }
  uint64_t v7 = -1;
  if (v5 <= v3 && HIDWORD(v5) != -1)
  {
    LODWORD(v8) = *(_DWORD *)(a1 + 36);
    if (v8 != -1 && HIDWORD(v5) <= v8 && v3 >= v5)
    {
      if (v4 >= v8) {
        uint64_t v8 = v8;
      }
      else {
        uint64_t v8 = v4;
      }
      if (v8 >= HIDWORD(v5))
      {
        uint64_t v7 = v3 | (unint64_t)(v8 << 32);
        uint64_t v6 = *(void *)(a1 + 24);
      }
    }
  }
LABEL_16:
  if [(id)a1 isMain] && (objc_msgSend((id)a1, "headerRowsRepeat"))
  {
LABEL_18:
    unint64_t v9 = 0xFFFFFFFF00000000;
    LODWORD(v10) = -1;
    return v9 | v10;
  }
  if ([(id)a1 layoutSpaceType] == 6)
  {
    uint64_t v10 = *(void *)(a1 + 24);
    unint64_t v9 = v10 & 0xFFFFFFFF00000000;
    return v9 | v10;
  }
  unint64_t v9 = 0xFFFFFFFF00000000;
  LODWORD(v10) = -1;
  if (v6 != -1 && v7 != -1 && v6 <= v7)
  {
    LODWORD(v10) = -1;
    if (HIDWORD(v6) != -1 && HIDWORD(v7) != -1 && HIDWORD(v6) <= HIDWORD(v7))
    {
      if (TSTLayoutIsPartitionAlongTop((void *)[(id)a1 layout]))
      {
        unint64_t v9 = 0;
        LODWORD(v10) = *(_DWORD *)(a1 + 24);
        return v9 | v10;
      }
      goto LABEL_18;
    }
  }
  return v9 | v10;
}

uint64_t TSTLayoutSpaceGetFooterRowsGridRange(uint64_t a1)
{
  int TableNumberOfFooterRows = TSTMasterLayoutGetTableNumberOfFooterRows((unsigned __int16 *)[(id)a1 masterLayout]);
  if (!TableNumberOfFooterRows) {
    return -1;
  }
  int v3 = TableNumberOfFooterRows;
  PartitionNonHeaderRowCellunint64_t Range = TSTLayoutGetPartitionNonHeaderRowCellRange((void *)[(id)a1 layout]);
  int v5 = (unsigned __int16)PartitionNonHeaderRowCellRange;
  if ((unsigned __int16)PartitionNonHeaderRowCellRange == 0xFFFF) {
    int v5 = -1;
  }
  int v6 = v5 + ((unint64_t)((HIDWORD(PartitionNonHeaderRowCellRange) << 16) - 0x100000000) >> 32);
  uint64_t v7 = *(void *)(a1 + 32);
  int v8 = HIWORD(PartitionNonHeaderRowCellRange) ? v6 : -1;
  if (v8 + v3 != HIDWORD(v7)) {
    return -1;
  }
  int v9 = BYTE2(PartitionNonHeaderRowCellRange);
  if (BYTE2(PartitionNonHeaderRowCellRange) == 255) {
    LODWORD(v10) = -1;
  }
  else {
    LODWORD(v10) = BYTE2(PartitionNonHeaderRowCellRange);
  }
  unsigned int v11 = WORD2(PartitionNonHeaderRowCellRange) + v10 - 1;
  unsigned int v12 = *(_DWORD *)(a1 + 24);
  if (!WORD2(PartitionNonHeaderRowCellRange)) {
    unsigned int v11 = -1;
  }
  uint64_t result = -1;
  if (v12 <= v7 && v7 != -1 && v12 != -1)
  {
    unsigned int v14 = *(_DWORD *)(a1 + 28);
    if (v14 <= HIDWORD(v7) && HIDWORD(v7) != -1 && v14 != -1 && v9 != 255 && v11 != -1 && v10 <= v11)
    {
      LODWORD(v15) = v8 + 1;
      if (v15 <= HIDWORD(v7) && v15 != -1)
      {
        uint64_t v10 = v12 <= v10 ? v10 : v12;
        unsigned int v16 = v7 >= v11 ? v11 : *(void *)(a1 + 32);
        if (v10 <= v16)
        {
          if (v14 <= v15) {
            uint64_t v15 = v15;
          }
          else {
            uint64_t v15 = v14;
          }
          if (v15 <= HIDWORD(v7)) {
            return v10 | (v15 << 32);
          }
        }
      }
    }
  }
  return result;
}

unint64_t TSTLayoutSpaceGetHeaderColumnsGridRange(uint64_t a1)
{
  int TableNumberOfHeaderColumns = TSTMasterLayoutGetTableNumberOfHeaderColumns((unsigned __int16 *)[(id)a1 masterLayout]);
  if (!TableNumberOfHeaderColumns) {
    goto LABEL_18;
  }
  unsigned int v3 = TableNumberOfHeaderColumns - 1;
  unsigned int v4 = *(_DWORD *)(a1 + 36);
  if (v4 == -1)
  {
    uint64_t v6 = -1;
LABEL_15:
    unint64_t v8 = -1;
    goto LABEL_16;
  }
  uint64_t v5 = *(void *)(a1 + 24);
  uint64_t v6 = -1;
  if (v5 == -1) {
    goto LABEL_15;
  }
  LODWORD(v7) = *(_DWORD *)(a1 + 32);
  if (v7 == -1) {
    goto LABEL_15;
  }
  unint64_t v8 = -1;
  if (v5 <= v7 && HIDWORD(v5) != -1 && HIDWORD(v5) <= v4)
  {
    if (v3 >= v7) {
      uint64_t v7 = v7;
    }
    else {
      uint64_t v7 = v3;
    }
    if (v7 >= v5 && v4 >= HIDWORD(v5))
    {
      unint64_t v8 = v7 | ((unint64_t)v4 << 32);
      uint64_t v6 = *(void *)(a1 + 24);
    }
  }
LABEL_16:
  if [(id)a1 isMain] && (objc_msgSend((id)a1, "headerColumnsRepeat"))
  {
LABEL_18:
    unint64_t v9 = 0xFFFFFFFF00000000;
    uint64_t v10 = 0xFFFFFFFFLL;
    return v9 | v10;
  }
  if ([(id)a1 layoutSpaceType] == 5)
  {
    unint64_t v9 = *(void *)(a1 + 24) & 0xFFFFFFFF00000000;
    uint64_t v10 = *(void *)(a1 + 24);
    return v9 | v10;
  }
  unint64_t v9 = 0xFFFFFFFF00000000;
  uint64_t v10 = 0xFFFFFFFFLL;
  if (v6 != -1 && v8 != -1 && v6 <= v8)
  {
    uint64_t v10 = 0xFFFFFFFFLL;
    if (HIDWORD(v6) != -1 && HIDWORD(v8) != -1 && HIDWORD(v6) <= HIDWORD(v8))
    {
      if (TSTLayoutIsPartitionAlongLeft((void *)[(id)a1 layout]))
      {
        uint64_t v10 = 0;
        unint64_t v9 = (unint64_t)*(unsigned int *)(a1 + 28) << 32;
        return v9 | v10;
      }
      goto LABEL_18;
    }
  }
  return v9 | v10;
}

unint64_t TSTLayoutSpaceGetTopLeftCornerGridRange(void *a1)
{
  int TableNumberOfHeaderColumns = TSTMasterLayoutGetTableNumberOfHeaderColumns((unsigned __int16 *)[a1 masterLayout]);
  int TableNumberOfHeaderRows = TSTMasterLayoutGetTableNumberOfHeaderRows((unsigned __int16 *)[a1 masterLayout]);
  unint64_t v4 = 0xFFFFFFFF00000000;
  uint64_t v5 = 0xFFFFFFFFLL;
  if (TableNumberOfHeaderColumns)
  {
    if (TableNumberOfHeaderRows)
    {
      HeaderColumnsGridunint64_t Range = TSTLayoutSpaceGetHeaderColumnsGridRange((uint64_t)a1);
      uint64_t v8 = v7;
      HeaderRowsGridunint64_t Range = TSTLayoutSpaceGetHeaderRowsGridRange((uint64_t)a1);
      unint64_t v4 = 0xFFFFFFFF00000000;
      uint64_t v5 = 0xFFFFFFFFLL;
      if (HeaderColumnsGridRange != -1
        && v8 != -1
        && HeaderColumnsGridRange <= v8)
      {
        uint64_t v5 = 0xFFFFFFFFLL;
        if (HIDWORD(HeaderColumnsGridRange) != -1
          && HIDWORD(v8) != -1
          && HIDWORD(HeaderColumnsGridRange) <= HIDWORD(v8))
        {
          uint64_t v5 = 0xFFFFFFFFLL;
          if (HeaderRowsGridRange != -1 && v10 != -1 && HeaderRowsGridRange <= v10)
          {
            uint64_t v5 = 0xFFFFFFFFLL;
            if (HIDWORD(HeaderRowsGridRange) != -1 && v11 != -1 && HIDWORD(HeaderRowsGridRange) <= v11)
            {
              uint64_t v5 = 0;
              unint64_t v4 = 0;
            }
          }
        }
      }
    }
  }
  return v4 | v5;
}

unint64_t TSTLayoutSpaceGetBottomLeftCornerGridRange(void *a1)
{
  if (TSTMasterLayoutGetTableNumberOfFooterRows((unsigned __int16 *)[a1 masterLayout])
    && TSTMasterLayoutGetTableNumberOfHeaderColumns((unsigned __int16 *)[a1 masterLayout]))
  {
    HeaderColumnsGridunint64_t Range = TSTLayoutSpaceGetHeaderColumnsGridRange((uint64_t)a1);
    uint64_t v4 = v3;
    FooterRowsGridunint64_t Range = TSTLayoutSpaceGetFooterRowsGridRange((uint64_t)a1);
    unint64_t v8 = 0xFFFFFFFF00000000;
    uint64_t v9 = 0xFFFFFFFFLL;
    if (FooterRowsGridRange != -1 && v6 != -1 && FooterRowsGridRange <= v6)
    {
      uint64_t v9 = 0xFFFFFFFFLL;
      if (HIDWORD(FooterRowsGridRange) != -1 && v7 != -1 && HIDWORD(FooterRowsGridRange) <= v7)
      {
        uint64_t v9 = 0xFFFFFFFFLL;
        if (HeaderColumnsGridRange != -1
          && v4 != -1
          && HeaderColumnsGridRange <= v4)
        {
          uint64_t v9 = 0xFFFFFFFFLL;
          if (HIDWORD(HeaderColumnsGridRange) != -1
            && HIDWORD(v4) != -1
            && HIDWORD(HeaderColumnsGridRange) <= HIDWORD(v4))
          {
            uint64_t v9 = 0;
            unint64_t v8 = FooterRowsGridRange & 0xFFFFFFFF00000000;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v8 = 0xFFFFFFFF00000000;
    uint64_t v9 = 0xFFFFFFFFLL;
  }
  return v8 | v9;
}

unint64_t TSTLayoutSpaceGetBodyGridRange(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 24);
  HeaderColumnsGridunint64_t Range = TSTLayoutSpaceGetHeaderColumnsGridRange(a1);
  if (HeaderColumnsGridRange == -1
    || v4 == -1
    || HeaderColumnsGridRange > v4
    || (HIDWORD(HeaderColumnsGridRange) <= v5 ? (BOOL v6 = v5 == -1) : (BOOL v6 = 1),
        !v6 ? (BOOL v7 = HIDWORD(HeaderColumnsGridRange) == -1) : (BOOL v7 = 1),
        v7))
  {
    unsigned int v8 = v2;
  }
  else
  {
    unsigned int v8 = v4 + 1;
  }
  HeaderRowsGridunint64_t Range = TSTLayoutSpaceGetHeaderRowsGridRange(a1);
  if (HeaderRowsGridRange == -1
    || v10 == -1
    || HeaderRowsGridRange > v10
    || (HIDWORD(HeaderRowsGridRange) <= v11 ? (BOOL v12 = v11 == -1) : (BOOL v12 = 1),
        !v12 ? (BOOL v13 = HIDWORD(HeaderRowsGridRange) == -1) : (BOOL v13 = 1),
        v13))
  {
    unint64_t v14 = HIDWORD(v2);
  }
  else
  {
    LODWORD(v14) = v11 + 1;
  }
  TSTLayoutSpaceGetFooterRowsGridRange(a1);
  return v8 | ((unint64_t)v14 << 32);
}

unint64_t TSTLayoutSpaceExpandGridRange(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = HIDWORD(a2);
  uint64_t v3 = (_DWORD *)(a1 + 24);
  if (!a1) {
    uint64_t v3 = &TSTGridRangeEmpty;
  }
  if (a2 <= *v3) {
    unsigned int v4 = a2;
  }
  else {
    unsigned int v4 = a2 - 1;
  }
  if (HIDWORD(a2) > v3[1]) {
    LODWORD(v2) = HIDWORD(a2) - 1;
  }
  return v4 | ((unint64_t)v2 << 32);
}

unint64_t TSTLayoutSpaceExpandRange(uint64_t a1, int a2)
{
  unsigned int v2 = BYTE2(a2);
  if (BYTE2(a2) == 255) {
    unsigned int v2 = -1;
  }
  if ((unsigned __int16)a2 == 0xFFFF) {
    unsigned int v3 = -1;
  }
  else {
    unsigned int v3 = (unsigned __int16)a2;
  }
  unint64_t v4 = TSTLayoutSpaceExpandGridRange(a1, v2 | ((unint64_t)v3 << 32));
  if (HIDWORD(v4) == -1 || HIDWORD(v5) == -1 || HIDWORD(v4) > HIDWORD(v5)) {
    unint64_t v8 = 0;
  }
  else {
    unint64_t v8 = ((v5 - (v4 & 0xFFFFFFFF00000000)) & 0xFFFFFFFF00000000 | (v5 - v4 + 1)) + 0x100000000;
  }
  if (v4 == -1 || v5 == -1 || v4 > v5) {
    unint64_t v8 = 0;
  }
  unint64_t v11 = (unint64_t)v4 << 16;
  if (v4 == -1) {
    unint64_t v11 = 16711680;
  }
  return v11 & 0xFFFFFFFFFFFF0000 | WORD2(v4) | (((v8 >> 16) & 0xFFFF0000 | v8) << 32);
}

_DWORD *TSTLayoutSpaceContainsGridRange(_DWORD *result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    unsigned int v3 = result[6];
    unsigned int v4 = result[8];
    if (v3 == -1 || v4 == -1 || v3 > v4) {
      return 0;
    }
    unsigned int v7 = result[7];
    unsigned int v8 = result[9];
    BOOL v9 = v7 == -1 || v8 == -1;
    if (v9 || v7 > v8)
    {
      return 0;
    }
    else
    {
      BOOL v13 = HIDWORD(a2) != -1 && HIDWORD(a3) != -1 && HIDWORD(a2) <= HIDWORD(a3);
      if (a2 > a3) {
        BOOL v13 = 0;
      }
      if (a3 == -1) {
        BOOL v13 = 0;
      }
      if (a2 == -1) {
        BOOL v13 = 0;
      }
      BOOL v14 = v3 <= a2 && v13;
      if (v7 > HIDWORD(a2)) {
        BOOL v14 = 0;
      }
      BOOL v15 = a3 <= v4 && v14;
      if (HIDWORD(a3) <= v8) {
        return (_DWORD *)v15;
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

BOOL TSTLayoutSpaceIntersectsCellRange(BOOL result, unint64_t a2)
{
  if (!result) {
    return result;
  }
  unint64_t Range = TSTLayoutSpaceGetRange(result);
  unint64_t v4 = 0;
  uint64_t v5 = 16711680;
  uint64_t v6 = 0xFFFFLL;
  if ((_WORD)Range == 0xFFFF) {
    goto LABEL_24;
  }
  unint64_t v7 = 0;
  if ((Range & 0xFF0000) == 0xFF0000) {
    goto LABEL_25;
  }
  unint64_t v4 = 0;
  uint64_t v5 = 16711680;
  uint64_t v6 = 0xFFFFLL;
  if (!HIWORD(Range)) {
    goto LABEL_24;
  }
  unint64_t v7 = 0;
  if ((Range & 0xFFFF00000000) == 0) {
    goto LABEL_25;
  }
  unint64_t v4 = 0;
  uint64_t v5 = 16711680;
  uint64_t v6 = 0xFFFFLL;
  if ((_WORD)a2 == 0xFFFF)
  {
LABEL_24:
    unint64_t v7 = 0;
    goto LABEL_25;
  }
  unint64_t v7 = 0;
  if ((a2 & 0xFF0000) != 0xFF0000)
  {
    unint64_t v4 = 0;
    uint64_t v5 = 16711680;
    uint64_t v6 = 0xFFFFLL;
    if (HIWORD(a2))
    {
      unint64_t v7 = 0;
      if ((a2 & 0xFFFF00000000) != 0)
      {
        uint64_t v6 = 0;
        if (BYTE2(Range) <= BYTE2(a2)) {
          unsigned int v8 = BYTE2(a2);
        }
        else {
          unsigned int v8 = BYTE2(Range);
        }
        if ((unsigned __int16)Range <= (unsigned __int16)a2) {
          uint64_t v9 = (unsigned __int16)a2;
        }
        else {
          uint64_t v9 = (unsigned __int16)Range;
        }
        if ((BYTE4(Range) + BYTE2(Range) - 1) >= (BYTE4(a2)
                                                                                                 + BYTE2(a2)
                                                                                                 - 1))
          unsigned int v10 = (BYTE4(a2) + BYTE2(a2) - 1);
        else {
          unsigned int v10 = (BYTE4(Range) + BYTE2(Range) - 1);
        }
        unsigned int v11 = (unsigned __int16)(a2 + HIWORD(a2) - 1);
        if ((unsigned __int16)(Range + HIWORD(Range) - 1) < v11) {
          unsigned int v11 = (unsigned __int16)(Range + HIWORD(Range) - 1);
        }
        uint64_t v5 = 0;
        unint64_t v4 = 0;
        unint64_t v7 = 0;
        if (v9 <= v11 && v8 <= v10)
        {
          unint64_t v7 = ((unint64_t)(v11 - v9) << 48) + 0x1000000000000;
          unint64_t v4 = (unint64_t)(unsigned __int16)(v10 - v8 + 1) << 32;
          uint64_t v5 = v8 << 16;
          uint64_t v6 = v9;
        }
      }
      goto LABEL_25;
    }
    goto LABEL_24;
  }
LABEL_25:
  uint64_t result = 0;
  unint64_t v12 = v5 | v7 | v6 | v4;
  if ((_WORD)v12 != 0xFFFF && (v12 & 0xFF0000) != 0xFF0000)
  {
    BOOL v14 = (v12 & 0xFFFF00000000) == 0;
    unint64_t v13 = HIWORD(v12);
    BOOL v14 = v14 || v13 == 0;
    return !v14;
  }
  return result;
}

_DWORD *TSTLayoutSpaceIntersectsGridRange(_DWORD *result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    unsigned int v3 = result[6];
    unsigned int v4 = result[8];
    BOOL v6 = v3 == -1 || v4 == -1 || v3 > v4;
    if (v6) {
      return 0;
    }
    unsigned int v7 = result[7];
    unsigned int v8 = result[9];
    BOOL v9 = v7 == -1 || v8 == -1;
    if (v9 || v7 > v8) {
      return 0;
    }
    uint64_t result = 0;
    if (a2 == -1) {
      return result;
    }
    if (a3 == -1) {
      return result;
    }
    if (a2 > a3) {
      return result;
    }
    uint64_t result = 0;
    if (HIDWORD(a2) == -1 || HIDWORD(a3) == -1 || HIDWORD(a2) > HIDWORD(a3)) {
      return result;
    }
    if (v3 <= a2) {
      unsigned int v3 = a2;
    }
    if (v4 >= a3) {
      unsigned int v4 = a3;
    }
    if (v3 > v4) {
      return 0;
    }
    if (v8 >= HIDWORD(a3)) {
      unsigned int v11 = HIDWORD(a3);
    }
    else {
      unsigned int v11 = v8;
    }
    if (v7 <= HIDWORD(a2)) {
      unsigned int v7 = HIDWORD(a2);
    }
    BOOL v6 = v7 > v11;
    int v12 = v7 > v11;
    int v13 = !v6;
    return (_DWORD *)(v13 & ~v12);
  }
  return result;
}

uint64_t TSTLayoutSpaceIntersectionCellRange(uint64_t a1, unint64_t a2)
{
  if (!a1) {
    return 0xFFFFFFLL;
  }
  unint64_t Range = TSTLayoutSpaceGetRange(a1);
  unint64_t v4 = 0;
  uint64_t v5 = 16711680;
  uint64_t v6 = 0xFFFFLL;
  if ((_WORD)Range == 0xFFFF) {
    goto LABEL_25;
  }
  unint64_t v7 = 0;
  if ((Range & 0xFF0000) == 0xFF0000) {
    return v5 | v7 | v6 | v4;
  }
  unint64_t v4 = 0;
  uint64_t v5 = 16711680;
  uint64_t v6 = 0xFFFFLL;
  if (!HIWORD(Range)) {
    goto LABEL_25;
  }
  unint64_t v7 = 0;
  if ((Range & 0xFFFF00000000) == 0) {
    return v5 | v7 | v6 | v4;
  }
  unint64_t v4 = 0;
  uint64_t v5 = 16711680;
  uint64_t v6 = 0xFFFFLL;
  if ((_WORD)a2 == 0xFFFF)
  {
LABEL_25:
    unint64_t v7 = 0;
    return v5 | v7 | v6 | v4;
  }
  unint64_t v7 = 0;
  if ((a2 & 0xFF0000) != 0xFF0000)
  {
    unint64_t v4 = 0;
    uint64_t v5 = 16711680;
    uint64_t v6 = 0xFFFFLL;
    if (HIWORD(a2))
    {
      unint64_t v7 = 0;
      if ((a2 & 0xFFFF00000000) != 0)
      {
        uint64_t v6 = 0;
        if (BYTE2(Range) <= BYTE2(a2)) {
          unsigned int v8 = BYTE2(a2);
        }
        else {
          unsigned int v8 = BYTE2(Range);
        }
        if ((unsigned __int16)Range <= (unsigned __int16)a2) {
          uint64_t v9 = (unsigned __int16)a2;
        }
        else {
          uint64_t v9 = (unsigned __int16)Range;
        }
        if ((BYTE4(Range) + BYTE2(Range) - 1) >= (BYTE4(a2)
                                                                                                 + BYTE2(a2)
                                                                                                 - 1))
          unsigned int v10 = (BYTE4(a2) + BYTE2(a2) - 1);
        else {
          unsigned int v10 = (BYTE4(Range) + BYTE2(Range) - 1);
        }
        unsigned int v11 = (unsigned __int16)(a2 + HIWORD(a2) - 1);
        if ((unsigned __int16)(Range + HIWORD(Range) - 1) < v11) {
          unsigned int v11 = (unsigned __int16)(Range + HIWORD(Range) - 1);
        }
        uint64_t v5 = 0;
        unint64_t v4 = 0;
        unint64_t v7 = 0;
        if (v9 <= v11 && v8 <= v10)
        {
          unint64_t v7 = ((unint64_t)(v11 - v9) << 48) + 0x1000000000000;
          unint64_t v4 = (unint64_t)(unsigned __int16)(v10 - v8 + 1) << 32;
          uint64_t v5 = v8 << 16;
          uint64_t v6 = v9;
        }
      }
      return v5 | v7 | v6 | v4;
    }
    goto LABEL_25;
  }
  return v5 | v7 | v6 | v4;
}

uint64_t TSTLayoutSpaceIntersectionGridRange(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return -1;
  }
  LODWORD(v3) = a1[6];
  unsigned int v4 = a1[8];
  BOOL v5 = v3 == -1 || v4 == -1;
  if (v5 || v3 > v4) {
    return -1;
  }
  LODWORD(v7) = a1[7];
  unsigned int v8 = a1[9];
  BOOL v9 = v7 == -1 || v8 == -1;
  if (v9 || v7 > v8) {
    return -1;
  }
  uint64_t result = -1;
  if (a2 != -1
    && a3 != -1
    && a2 <= a3
    && HIDWORD(a2) != -1
    && HIDWORD(a3) != -1
    && HIDWORD(a2) <= HIDWORD(a3))
  {
    uint64_t v3 = v3 <= a2 ? a2 : v3;
    unsigned int v12 = v4 >= a3 ? a3 : v4;
    if (v3 <= v12)
    {
      if (v8 >= HIDWORD(a3)) {
        unsigned int v13 = HIDWORD(a3);
      }
      else {
        unsigned int v13 = v8;
      }
      if (v7 <= HIDWORD(a2)) {
        uint64_t v7 = HIDWORD(a2);
      }
      else {
        uint64_t v7 = v7;
      }
      if (v7 <= v13) {
        return v3 | (v7 << 32);
      }
    }
  }
  return result;
}

uint64_t TSTLayoutSpaceIntersectsRowGridRange(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    unsigned int v3 = *(_DWORD *)(result + 24);
    uint64_t v4 = *(void *)(result + 32);
    BOOL v6 = v3 == -1 || v4 == -1 || v3 > v4;
    if (v6) {
      return 0;
    }
    unsigned int v7 = *(_DWORD *)(result + 28);
    unint64_t v8 = (unint64_t)(v4 + 0x100000000) >> 32;
    BOOL v9 = v7 == -1 || v8 == -1;
    if (v9 || v7 > v8) {
      return 0;
    }
    uint64_t result = 0;
    if (a2 == -1) {
      return result;
    }
    if (a3 == -1) {
      return result;
    }
    if (a2 > a3) {
      return result;
    }
    uint64_t result = 0;
    if (HIDWORD(a2) == -1 || HIDWORD(a3) == -1 || HIDWORD(a2) > HIDWORD(a3)) {
      return result;
    }
    if (v3 <= a2) {
      unsigned int v3 = a2;
    }
    if (v4 >= a3) {
      LODWORD(v4) = a3;
    }
    if (v3 > v4) {
      return 0;
    }
    if (v8 >= HIDWORD(a3)) {
      unsigned int v11 = HIDWORD(a3);
    }
    else {
      unsigned int v11 = v8;
    }
    if (v7 <= HIDWORD(a2)) {
      unsigned int v7 = HIDWORD(a2);
    }
    BOOL v6 = v7 > v11;
    int v12 = v7 > v11;
    int v13 = !v6;
    return v13 & ~v12;
  }
  return result;
}

_DWORD *TSTLayoutSpaceIntersectsColumnGridRange(_DWORD *result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    unsigned int v3 = result[6];
    unsigned int v4 = result[8] + 1;
    if (v3 == -1 || result[8] == -2 || v4 < v3) {
      return 0;
    }
    unsigned int v7 = result[7];
    unsigned int v8 = result[9];
    BOOL v9 = v7 == -1 || v8 == -1;
    BOOL v10 = v9 || v7 > v8;
    if (v10) {
      return 0;
    }
    uint64_t result = 0;
    if (a2 == -1) {
      return result;
    }
    if (a3 == -1) {
      return result;
    }
    if (a2 > a3) {
      return result;
    }
    uint64_t result = 0;
    if (HIDWORD(a2) == -1 || HIDWORD(a3) == -1 || HIDWORD(a2) > HIDWORD(a3)) {
      return result;
    }
    if (v3 <= a2) {
      unsigned int v3 = a2;
    }
    if (v4 >= a3) {
      unsigned int v4 = a3;
    }
    if (v3 > v4) {
      return 0;
    }
    if (v8 >= HIDWORD(a3)) {
      unsigned int v11 = HIDWORD(a3);
    }
    else {
      unsigned int v11 = v8;
    }
    if (v7 <= HIDWORD(a2)) {
      unsigned int v7 = HIDWORD(a2);
    }
    BOOL v10 = v7 > v11;
    int v12 = v7 > v11;
    int v13 = !v10;
    return (_DWORD *)(v13 & ~v12);
  }
  return result;
}

uint64_t TSTLayoutSpaceIntersectionRowGridRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return -1;
  }
  LODWORD(v3) = *(_DWORD *)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  BOOL v5 = v3 == -1 || v4 == -1;
  if (v5 || v3 > v4) {
    return -1;
  }
  LODWORD(v8) = *(_DWORD *)(a1 + 28);
  uint64_t result = -1;
  if (v8 != -1)
  {
    unint64_t v9 = (unint64_t)(v4 + 0x100000000) >> 32;
    BOOL v10 = v9 == -1 || v8 > v9;
    if (!v10
      && a2 != -1
      && a3 != -1
      && a2 <= a3
      && HIDWORD(a2) != -1
      && HIDWORD(a3) != -1
      && HIDWORD(a2) <= HIDWORD(a3))
    {
      uint64_t v3 = v3 <= a2 ? a2 : v3;
      unsigned int v11 = v4 >= a3 ? a3 : v4;
      if (v3 <= v11)
      {
        if (v9 >= HIDWORD(a3)) {
          unsigned int v12 = HIDWORD(a3);
        }
        else {
          unsigned int v12 = (unint64_t)(v4 + 0x100000000) >> 32;
        }
        if (v8 <= HIDWORD(a2)) {
          uint64_t v8 = HIDWORD(a2);
        }
        else {
          uint64_t v8 = v8;
        }
        if (v8 <= v12) {
          return v3 | (v8 << 32);
        }
      }
    }
  }
  return result;
}

uint64_t TSTLayoutSpaceIntersectionColumnGridRange(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return -1;
  }
  LODWORD(v3) = a1[6];
  unsigned int v4 = a1[8] + 1;
  BOOL v5 = v3 == -1 || a1[8] == -2;
  if (v5 || v4 < v3) {
    return -1;
  }
  LODWORD(v7) = a1[7];
  unsigned int v8 = a1[9];
  BOOL v9 = v7 == -1 || v8 == -1;
  if (v9 || v7 > v8) {
    return -1;
  }
  uint64_t result = -1;
  if (a2 != -1
    && a3 != -1
    && a2 <= a3
    && HIDWORD(a2) != -1
    && HIDWORD(a3) != -1
    && HIDWORD(a2) <= HIDWORD(a3))
  {
    uint64_t v3 = v3 <= a2 ? a2 : v3;
    unsigned int v12 = v4 >= a3 ? a3 : v4;
    if (v3 <= v12)
    {
      if (v8 >= HIDWORD(a3)) {
        unsigned int v13 = HIDWORD(a3);
      }
      else {
        unsigned int v13 = v8;
      }
      if (v7 <= HIDWORD(a2)) {
        uint64_t v7 = HIDWORD(a2);
      }
      else {
        uint64_t v7 = v7;
      }
      if (v7 <= v13) {
        return v3 | (v7 << 32);
      }
    }
  }
  return result;
}

uint64_t TSTLayoutSpaceGetGridRangeForLayoutRect(TSTLayoutSpace *a1, double a2, double a3, double a4, double a5)
{
  double TableRectForLayoutRect = TSTLayoutSpaceGetTableRectForLayoutRect(a1, *(CGRect *)&a2);

  return TSTLayoutSpaceGetGridRangeForTableRect(a1, *(CGRect *)&TableRectForLayoutRect);
}

double TSTLayoutSpaceGetTableRectForLayoutRect(TSTLayoutSpace *a1, CGRect a2)
{
  double height = a2.size.height;
  double width = a2.size.width;
  double TablePointForLayoutPoint = TSTLayoutSpaceGetTablePointForLayoutPoint(a1, a2.origin);

  return TSDRectWithOriginAndSize(v4, TablePointForLayoutPoint, v6, width, height);
}

uint64_t TSTLayoutSpaceGetGridRangeForTableRect(TSTLayoutSpace *a1, CGRect a2)
{
  CGFloat height = a2.size.height;
  CGFloat width = a2.size.width;
  CGFloat y = a2.origin.y;
  CGFloat x = a2.origin.x;
  v33.origin.CGFloat x = TSTLayoutSpaceGetFrame((uint64_t)a1);
  v34.origin.CGFloat x = TSTLayoutSpaceGetTableRectForLayoutRect(a1, v33);
  CGFloat v7 = v34.origin.x;
  CGFloat v8 = v34.origin.y;
  CGFloat v9 = v34.size.width;
  CGFloat v10 = v34.size.height;
  double MinX = CGRectGetMinX(v34);
  v35.origin.CGFloat x = v7;
  v35.origin.CGFloat y = v8;
  v35.size.CGFloat width = v9;
  v35.size.CGFloat height = v10;
  double MaxX = CGRectGetMaxX(v35);
  v36.origin.CGFloat x = v7;
  v36.origin.CGFloat y = v8;
  v36.size.CGFloat width = v9;
  v36.size.CGFloat height = v10;
  double MinY = CGRectGetMinY(v36);
  v37.origin.CGFloat x = v7;
  v37.origin.CGFloat y = v8;
  v37.size.CGFloat width = v9;
  v37.size.CGFloat height = v10;
  double MaxY = CGRectGetMaxY(v37);
  v38.origin.CGFloat x = x;
  v38.origin.CGFloat y = y;
  v38.size.CGFloat width = width;
  v38.size.CGFloat height = height;
  double v12 = CGRectGetMinX(v38);
  v39.origin.CGFloat x = x;
  v39.origin.CGFloat y = y;
  v39.size.CGFloat width = width;
  v39.size.CGFloat height = height;
  double v13 = CGRectGetMaxX(v39);
  v40.origin.CGFloat x = x;
  v40.origin.CGFloat y = y;
  v40.size.CGFloat width = width;
  v40.size.CGFloat height = height;
  double v14 = CGRectGetMinY(v40);
  v41.origin.CGFloat x = x;
  v41.origin.CGFloat y = y;
  v41.size.CGFloat width = width;
  v41.size.CGFloat height = height;
  double v15 = CGRectGetMaxY(v41);
  if (v12 >= MinX) {
    double v16 = v12;
  }
  else {
    double v16 = MinX;
  }
  if (MaxX >= v13) {
    double v17 = v13;
  }
  else {
    double v17 = MaxX;
  }
  if (v14 >= MinY) {
    double v18 = v14;
  }
  else {
    double v18 = MinY;
  }
  if (MaxY >= v15) {
    double v19 = v15;
  }
  else {
    double v19 = MaxY;
  }
  if (v16 > v17)
  {
    LODWORD(GridColumnForTableCoordinate) = -1;
LABEL_24:
    LODWORD(v21) = -1;
    goto LABEL_25;
  }
  uint64_t GridColumnForTableCoordinate = TSTLayoutSpaceGetGridColumnForTableCoordinate(a1, v16);
  if (GridColumnForTableCoordinate == -1) {
    goto LABEL_24;
  }
  uint64_t v21 = TSTLayoutSpaceGetGridColumnForTableCoordinate(a1, v17);
  if (v21 == -1 || ![(TSTLayoutSpace *)a1 layoutDirectionIsLeftToRight])
  {
    if (![(TSTLayoutSpace *)a1 layoutDirectionIsLeftToRight]
      && TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, GridColumnForTableCoordinate) + 0.00999999978 > v16)
    {
      p_mGridunint64_t Range = &a1->mGridRange;
      if (!a1) {
        p_mGridunint64_t Range = ($FC6C44E672DFCBD714A302CF0DF56F45 *)&TSTGridRangeEmpty;
      }
      if (GridColumnForTableCoordinate >= p_mGridRange->topLeft.column) {
        LODWORD(GridColumnForTableCoordinate) = GridColumnForTableCoordinate + 1;
      }
      else {
        LODWORD(GridColumnForTableCoordinate) = -1;
      }
    }
  }
  else if (TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, v21) + 0.00999999978 < v17)
  {
    uint64_t v22 = &a1->mGridRange;
    if (!a1) {
      uint64_t v22 = ($FC6C44E672DFCBD714A302CF0DF56F45 *)&TSTGridRangeEmpty;
    }
    if (v21 <= v22->bottomRight.column) {
      LODWORD(v21) = v21 + 1;
    }
    else {
      LODWORD(v21) = -1;
    }
  }
LABEL_25:
  if (v18 > v19 || (uint64_t v23 = TSTLayoutSpaceGetGridRowForTableCoordinate(a1, v18), v23 == -1))
  {
    uint64_t v24 = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v24 = v23;
    uint64_t GridRowForTableCoordinate = TSTLayoutSpaceGetGridRowForTableCoordinate(a1, v19);
    if (GridRowForTableCoordinate != -1) {
      TSTLayoutSpaceGetTableCoordinateForGridRow(a1, GridRowForTableCoordinate);
    }
  }
  if ([(TSTLayoutSpace *)a1 layoutDirectionIsLeftToRight]) {
    uint64_t v27 = GridColumnForTableCoordinate;
  }
  else {
    uint64_t v27 = v21;
  }
  return v27 | (v24 << 32);
}

unint64_t TSTLayoutSpaceGetRangeForLayoutRect(TSTLayoutSpace *a1, double a2, double a3, double a4, double a5)
{
  v21.origin.CGFloat x = TSTLayoutSpaceGetTableRectForLayoutRect(a1, *(CGRect *)&a2);
  uint64_t GridRangeForTableRect = TSTLayoutSpaceGetGridRangeForTableRect(a1, v21);
  unint64_t v8 = 0;
  BOOL v13 = GridRangeForTableRect == -1
     || v7 == -1
     || GridRangeForTableRect > v7
     || HIDWORD(GridRangeForTableRect) == -1
     || HIDWORD(v7) == -1
     || HIDWORD(GridRangeForTableRect) > HIDWORD(v7);
  if (v13) {
    unsigned int v14 = v7;
  }
  else {
    unsigned int v14 = v7 - 1;
  }
  if (v13) {
    unint64_t v15 = v7;
  }
  else {
    unint64_t v15 = (v7 & 0xFFFFFFFF00000000 | (v7 - 1)) - 0x100000000;
  }
  if (GridRangeForTableRect != -1 && v14 != -1 && v14 >= GridRangeForTableRect)
  {
    if (HIDWORD(GridRangeForTableRect) == -1)
    {
      unint64_t v8 = 0;
    }
    else
    {
      unint64_t v16 = HIDWORD(v15);
      unint64_t v17 = ((v15 - (GridRangeForTableRect & 0xFFFFFFFF00000000)) & 0xFFFFFFFF00000000 | (v15 - GridRangeForTableRect + 1))
          + 0x100000000;
      if (HIDWORD(GridRangeForTableRect) <= v16) {
        unint64_t v18 = v17;
      }
      else {
        unint64_t v18 = 0;
      }
      if (v16 == -1) {
        unint64_t v8 = 0;
      }
      else {
        unint64_t v8 = v18;
      }
    }
  }
  unint64_t v19 = (unint64_t)GridRangeForTableRect << 16;
  if (GridRangeForTableRect == -1) {
    unint64_t v19 = 16711680;
  }
  return v19 & 0xFFFFFFFFFFFF0000 | WORD2(GridRangeForTableRect) | (((v8 >> 16) & 0xFFFF0000 | v8) << 32);
}

unint64_t TSTLayoutSpaceGetNearestRangeForLayoutRect(TSTLayoutSpace *a1, double a2, double a3, double a4, double a5)
{
  unint64_t RangeForLayoutRect = TSTLayoutSpaceGetRangeForLayoutRect(a1, a2, a3, a4, a5);
  unint64_t v11 = RangeForLayoutRect;
  if ((_WORD)RangeForLayoutRect == 0xFFFF
    || (RangeForLayoutRect & 0xFF0000) == 0xFF0000
    || !HIWORD(RangeForLayoutRect)
    || (RangeForLayoutRect & 0xFFFF00000000) == 0)
  {
    double Frame = TSTLayoutSpaceGetFrame((uint64_t)a1);
    if (!TSDIntersectsRect(a2, a3, a4, a5, Frame, v13, v14, v15))
    {
      unint64_t Range = TSTLayoutSpaceGetRange((uint64_t)a1);
      FrameForunint64_t Range = TSTLayoutSpaceGetFrameForRange(a1, Range);
      CGFloat v19 = v18;
      CGFloat v21 = v20;
      CGFloat v23 = v22;
      double v24 = TSDClampPointInRect();
      double v42 = v25;
      double v43 = v24;
      v44.origin.CGFloat x = a2;
      v44.origin.CGFloat y = a3;
      v44.size.CGFloat width = a4;
      v44.size.CGFloat height = a5;
      CGRectGetMaxX(v44);
      v45.size.CGFloat width = a4;
      rect_8.origin.CGFloat x = a2;
      rect_8.origin.CGFloat y = a3;
      v45.origin.CGFloat x = a2;
      v45.origin.CGFloat y = a3;
      rect_8.size.CGFloat width = a4;
      rect_8.size.CGFloat height = a5;
      v45.size.CGFloat height = a5;
      CGRectGetMaxY(v45);
      double v26 = TSDClampPointInRect();
      double v27 = TSDRectWithPoints(v43, v42, v26);
      double v31 = v27;
      double v32 = v28;
      double v33 = v29;
      double v34 = v30;
      if (v30 == 0.0)
      {
        double MaxY = CGRectGetMaxY(*(CGRect *)&v27);
        v46.origin.CGFloat x = FrameForRange;
        v46.origin.CGFloat y = v19;
        v46.size.CGFloat width = v21;
        v46.size.CGFloat height = v23;
        if (MaxY == CGRectGetMaxY(v46)) {
          double v32 = v32 + -1.0;
        }
        double v34 = 1.0;
      }
      if (v33 == 0.0)
      {
        v47.origin.CGFloat x = v31;
        v47.origin.CGFloat y = v32;
        v47.size.CGFloat width = v33;
        v47.size.CGFloat height = v34;
        double MaxX = CGRectGetMaxX(v47);
        v48.origin.CGFloat x = FrameForRange;
        v48.origin.CGFloat y = v19;
        v48.size.CGFloat width = v21;
        v48.size.CGFloat height = v23;
        if (MaxX == CGRectGetMaxX(v48)) {
          double v31 = v31 + -1.0;
        }
        double v33 = 1.0;
      }
      unint64_t v37 = TSTLayoutSpaceGetRangeForLayoutRect(a1, v31, v32, v33, v34);
      unint64_t v11 = v37;
      if ((_WORD)v37 == 0xFFFF || (v37 & 0xFF0000) == 0xFF0000 || !HIWORD(v37) || (v37 & 0xFFFF00000000) == 0)
      {
        CGRect v38 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v39 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTCellRange TSTLayoutSpaceGetNearestRangeForLayoutRect(TSTLayoutSpace *, CGRect)");
        [v38 handleFailureInFunction:v39, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"), 794, @"Failed to get nearest cell range from space %@ for layout rect %@", a1, NSStringFromCGRect(rect_8) file lineNumber description];
      }
    }
  }
  return v11;
}

double TSTLayoutSpaceGetFrame(uint64_t a1)
{
  unsigned int v2 = (double *)(a1 + 304);
  uint64_t v3 = (double *)(a1 + 312);
  uint64_t v4 = (double *)(a1 + 320);
  BOOL v5 = (double *)(a1 + 328);
  if (CGRectIsEmpty(*(CGRect *)(a1 + 304)))
  {
    unint64_t v6 = *(void *)(a1 + 24);
    uint64_t v7 = *(void *)(a1 + 32);
    unint64_t v8 = (double *)MEMORY[0x263F001A8];
    BOOL v10 = v6 == -1 || v7 == -1 || v6 > v7;
    if (!v10 && HIDWORD(v6) != -1 && HIDWORD(v7) != -1 && HIDWORD(v6) <= HIDWORD(v7))
    {
      FrameForGridunint64_t Range = TSTLayoutSpaceGetFrameForGridRange((TSTLayoutSpace *)a1, v6, v7);
      double v13 = v12;
      double v15 = v14;
      double v17 = v16;
      if ([(id)a1 isMain]
        && [(id)a1 headerRowsRepeat]
        && objc_msgSend((id)objc_msgSend((id)a1, "bundle"), "repeatHeaderRowsSpace"))
      {
        TSTLayoutSpaceGetFrame();
        double v17 = v17 + v13 - v18;
        double v13 = v18;
      }
      if ([(id)a1 isMain]
        && [(id)a1 headerColumnsRepeat]
        && objc_msgSend((id)objc_msgSend((id)a1, "bundle"), "repeatHeaderColumnsSpace"))
      {
        double Frame = TSTLayoutSpaceGetFrame();
        double v15 = v15 + FrameForGridRange - Frame;
        FrameForGridunint64_t Range = Frame;
      }
      *unsigned int v2 = FrameForGridRange;
      *uint64_t v3 = v13;
      unint64_t v8 = v2;
      double *v4 = v15;
      *BOOL v5 = v17;
    }
  }
  else
  {
    unint64_t v8 = v2;
  }
  return *v8;
}

double TSTLayoutSpaceGetFrameForRange(TSTLayoutSpace *a1, unint64_t a2)
{
  unsigned int v2 = BYTE2(a2);
  if (BYTE2(a2) == 255) {
    unsigned int v2 = -1;
  }
  uint64_t v3 = WORD2(a2) + v2 - 1;
  if (!WORD2(a2)) {
    uint64_t v3 = 0xFFFFFFFFLL;
  }
  if ((unsigned __int16)a2 == 0xFFFF) {
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v4 = (unsigned __int16)a2;
  }
  unint64_t v5 = v2 | ((unint64_t)v4 << 32);
  uint64_t v6 = ((a2 >> 16) & 0xFFFF00000000) + (v4 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0) {
    uint64_t v6 = 0xFFFFFFFF00000000;
  }
  return TSTLayoutSpaceGetFrameForGridRange(a1, v5, v3 | v6);
}

unint64_t TSTLayoutSpaceGetRangeIntersectingLayoutRect(TSTLayoutSpace *a1, double a2, double a3, double a4, double a5)
{
  double TableRectForLayoutRect = TSTLayoutSpaceGetTableRectForLayoutRect(a1, *(CGRect *)&a2);
  CGFloat v8 = v7;
  CGFloat v10 = v9;
  CGFloat v12 = v11;
  v38.origin.CGFloat x = TSTLayoutSpaceGetFrame((uint64_t)a1);
  v43.origin.CGFloat x = TSTLayoutSpaceGetTableRectForLayoutRect(a1, v38);
  v43.origin.CGFloat y = v13;
  v43.size.CGFloat width = v14;
  v43.size.CGFloat height = v15;
  v39.origin.CGFloat x = TableRectForLayoutRect;
  v39.origin.CGFloat y = v8;
  v39.size.CGFloat width = v10;
  v39.size.CGFloat height = v12;
  CGRect v40 = CGRectIntersection(v39, v43);
  CGFloat x = v40.origin.x;
  CGFloat y = v40.origin.y;
  CGFloat width = v40.size.width;
  CGFloat height = v40.size.height;
  uint64_t GridRangeForTableRect = TSTLayoutSpaceGetGridRangeForTableRect(a1, v40);
  unint64_t v22 = v20;
  p_mGridunint64_t Range = &a1->mGridRange;
  if (!a1) {
    p_mGridunint64_t Range = ($FC6C44E672DFCBD714A302CF0DF56F45 *)&TSTGridRangeEmpty;
  }
  $3C36844D3994842D9102894F8152D7DE topLeft = p_mGridRange->topLeft;
  $3C36844D3994842D9102894F8152D7DE bottomRight = p_mGridRange->bottomRight;
  BOOL v30 = *(void *)&p_mGridRange->topLeft == -1
     || bottomRight.column == -1
     || topLeft.column > bottomRight.column
     || topLeft.row == -1
     || bottomRight.row == -1
     || topLeft.row > bottomRight.row;
  unsigned int column = bottomRight.column + 1;
  if (v30)
  {
    unsigned int column = bottomRight.column;
    HIDWORD(v32) = bottomRight.row;
  }
  else
  {
    unint64_t v32 = (*(void *)&bottomRight & 0xFFFFFFFF00000000 | (bottomRight.column + 1)) + 0x100000000;
  }
  if (v20 != -1 && column > v20)
  {
    double TableCoordinateForGridColumn = TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, v20);
    v41.origin.CGFloat x = x;
    v41.origin.CGFloat y = y;
    v41.size.CGFloat width = width;
    v41.size.CGFloat height = height;
    if (TableCoordinateForGridColumn == CGRectGetMaxX(v41)) {
      unint64_t v22 = (v22 + 1) | v22 & 0xFFFFFFFF00000000;
    }
  }
  if (HIDWORD(v22) != -1 && HIDWORD(v22) < HIDWORD(v32))
  {
    double TableCoordinateForGridRow = TSTLayoutSpaceGetTableCoordinateForGridRow(a1, HIDWORD(v22));
    v42.origin.CGFloat x = x;
    v42.origin.CGFloat y = y;
    v42.size.CGFloat width = width;
    v42.size.CGFloat height = height;
    if (TableCoordinateForGridRow == CGRectGetMaxY(v42)) {
      v22 += 0x100000000;
    }
  }
  if (GridRangeForTableRect <= v22
    && GridRangeForTableRect != -1
    && v22 != -1
    && HIDWORD(GridRangeForTableRect) <= HIDWORD(v22)
    && HIDWORD(GridRangeForTableRect) != -1
    && HIDWORD(v22) != -1)
  {
    unint64_t v22 = (v22 & 0xFFFFFFFF00000000 | (v22 - 1)) - 0x100000000;
  }
  unint64_t v35 = 0;
  if (GridRangeForTableRect != -1
    && v22 != -1
    && GridRangeForTableRect <= v22)
  {
    unint64_t v35 = 0;
    if (HIDWORD(GridRangeForTableRect) != -1 && HIDWORD(v22) != -1 && HIDWORD(GridRangeForTableRect) <= HIDWORD(v22)) {
      unint64_t v35 = ((v22 - (GridRangeForTableRect & 0xFFFFFFFF00000000)) & 0xFFFFFFFF00000000 | (v22 - GridRangeForTableRect + 1))
    }
          + 0x100000000;
  }
  unint64_t v36 = (unint64_t)GridRangeForTableRect << 16;
  if (GridRangeForTableRect == -1) {
    unint64_t v36 = 16711680;
  }
  return v36 & 0xFFFFFFFFFFFF0000 | WORD2(GridRangeForTableRect) | (((v35 >> 16) & 0xFFFF0000 | v35) << 32);
}

double TSTLayoutSpaceGetTableCoordinateForGridColumn(TSTLayoutSpace *a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "CGFloat TSTLayoutSpaceGetTableCoordinateForGridColumn(TSTLayoutSpace *, TSTGridColumn)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"), 3165, @"space should be non-NULL");
  }
  if (a2 == -1
    || (a1->mGridRange.topLeft.column <= a2
      ? (BOOL v6 = a1->mGridRange.bottomRight.column + 1 >= a2)
      : (BOOL v6 = 0),
        !v6))
  {
    double v7 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v8 = objc_msgSend(NSString, "stringWithUTF8String:", "CGFloat TSTLayoutSpaceGetTableCoordinateForGridColumn(TSTLayoutSpace *, TSTGridColumn)");
    uint64_t v9 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"];
    unsigned int column = a1->mGridRange.topLeft.column;
    uint64_t row = a1->mGridRange.topLeft.row;
    $3C36844D3994842D9102894F8152D7DE bottomRight = a1->mGridRange.bottomRight;
    CGFloat v13 = NSString;
    if ((row & column) == 0xFFFFFFFF)
    {
      CGFloat v15 = @"{invalid, invalid}";
    }
    else
    {
      if (column == -1)
      {
        uint64_t v14 = [NSString stringWithFormat:@"{invalid, %u}", a1->mGridRange.topLeft.row, v23];
      }
      else if (row == -1)
      {
        uint64_t v14 = [NSString stringWithFormat:@"{%u, invalid}", a1->mGridRange.topLeft.column, v23];
      }
      else
      {
        uint64_t v14 = [NSString stringWithFormat:@"{%u, %u}", a1->mGridRange.topLeft.column, row];
      }
      CGFloat v15 = (__CFString *)v14;
    }
    if ((bottomRight.row & bottomRight.column) == -1)
    {
      double v16 = @"{invalid, invalid}";
    }
    else if (bottomRight.column == -1)
    {
      double v16 = (__CFString *)[NSString stringWithFormat:@"{invalid, %u}", HIDWORD(*(unint64_t *)&bottomRight), v23];
    }
    else if (bottomRight.row == -1)
    {
      double v16 = (__CFString *)[NSString stringWithFormat:@"{%u, invalid}", bottomRight, v23];
    }
    else
    {
      double v16 = (__CFString *)[NSString stringWithFormat:@"{%u, %u}", bottomRight, HIDWORD(*(unint64_t *)&bottomRight)];
    }
    [v7 handleFailureInFunction:v8, v9, 3167, @"column %u not in gridRange %@", a2, objc_msgSend(v13, "stringWithFormat:", @"{%@->%@}", v15, v16) file lineNumber description];
  }
  if (!a1->mBodyColumnCoordinates && !a1->mHeaderRowColumnCoordinates)
  {
    double v17 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v18 = objc_msgSend(NSString, "stringWithUTF8String:", "CGFloat TSTLayoutSpaceGetTableCoordinateForGridColumn(TSTLayoutSpace *, TSTGridColumn)");
    objc_msgSend(v17, "handleFailureInFunction:file:lineNumber:description:", v18, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"), 3169, @"Body column coordinates and header row column coordinates have not been filled.");
  }
  mHeaderRowColumnCoordinates = a1->mHeaderRowColumnCoordinates;
  if (mHeaderRowColumnCoordinates && TSTCoordinateArrayContainsIndex((uint64_t)mHeaderRowColumnCoordinates, a2)) {
    p_mHeaderRowColumnCoordinates = &a1->mHeaderRowColumnCoordinates;
  }
  else {
    p_mHeaderRowColumnCoordinates = &a1->mBodyColumnCoordinates;
  }
  uint64_t v21 = (uint64_t)*p_mHeaderRowColumnCoordinates;

  return TSTCoordinateArrayGetCoordinate(v21, a2);
}

double TSTLayoutSpaceGetTableCoordinateForGridRow(TSTLayoutSpace *a1, uint64_t a2)
{
  if (a2 == -1
    || a1->mGridRange.topLeft.row > a2
    || a1->mGridRange.bottomRight.row + 1 < a2)
  {
    uint64_t v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "CGFloat TSTLayoutSpaceGetTableCoordinateForGridRow(TSTLayoutSpace *, TSTGridRow)");
    uint64_t v6 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"];
    unsigned int column = a1->mGridRange.topLeft.column;
    uint64_t row = a1->mGridRange.topLeft.row;
    $3C36844D3994842D9102894F8152D7DE bottomRight = a1->mGridRange.bottomRight;
    CGFloat v10 = NSString;
    if ((row & column) == 0xFFFFFFFF)
    {
      CGFloat v12 = @"{invalid, invalid}";
    }
    else
    {
      if (column == -1)
      {
        uint64_t v11 = [NSString stringWithFormat:@"{invalid, %u}", a1->mGridRange.topLeft.row, v20];
      }
      else if (row == -1)
      {
        uint64_t v11 = [NSString stringWithFormat:@"{%u, invalid}", a1->mGridRange.topLeft.column, v20];
      }
      else
      {
        uint64_t v11 = [NSString stringWithFormat:@"{%u, %u}", a1->mGridRange.topLeft.column, row];
      }
      CGFloat v12 = (__CFString *)v11;
    }
    if ((bottomRight.row & bottomRight.column) == -1)
    {
      CGFloat v13 = @"{invalid, invalid}";
    }
    else if (bottomRight.column == -1)
    {
      CGFloat v13 = (__CFString *)[NSString stringWithFormat:@"{invalid, %u}", HIDWORD(*(unint64_t *)&bottomRight), v20];
    }
    else if (bottomRight.row == -1)
    {
      CGFloat v13 = (__CFString *)[NSString stringWithFormat:@"{%u, invalid}", bottomRight, v20];
    }
    else
    {
      CGFloat v13 = (__CFString *)[NSString stringWithFormat:@"{%u, %u}", bottomRight, HIDWORD(*(unint64_t *)&bottomRight)];
    }
    [v4 handleFailureInFunction:v5, v6, 3209, @"row %u not in gridRange %@", a2, objc_msgSend(v10, "stringWithFormat:", @"{%@->%@}", v12, v13) file lineNumber description];
  }
  if (!a1->mBodyRowCoordinates && !a1->mHeaderColumnRowCoordinates)
  {
    uint64_t v14 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v15 = objc_msgSend(NSString, "stringWithUTF8String:", "CGFloat TSTLayoutSpaceGetTableCoordinateForGridRow(TSTLayoutSpace *, TSTGridRow)");
    objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", v15, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"), 3211, @"Body row coordinates and header column row coordinates have not been filled.");
  }
  mHeaderColumnRowCoordinates = a1->mHeaderColumnRowCoordinates;
  if (mHeaderColumnRowCoordinates && TSTCoordinateArrayContainsIndex((uint64_t)mHeaderColumnRowCoordinates, a2)) {
    p_mHeaderColumnRowCoordinates = &a1->mHeaderColumnRowCoordinates;
  }
  else {
    p_mHeaderColumnRowCoordinates = &a1->mBodyRowCoordinates;
  }
  uint64_t v18 = (uint64_t)*p_mHeaderColumnRowCoordinates;

  return TSTCoordinateArrayGetCoordinate(v18, a2);
}

double TSTLayoutSpaceGetLayoutCoordinateForGridColumn(TSTLayoutSpace *a1, uint64_t a2)
{
  double TableCoordinateForGridColumn = TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, a2);
  uint64_t v4 = 0;

  return TSTLayoutSpaceGetLayoutPointForTablePoint(a1, *(CGPoint *)&TableCoordinateForGridColumn);
}

double TSTLayoutSpaceGetLayoutPointForTablePoint(TSTLayoutSpace *a1, CGPoint a2)
{
  double y = a2.y;
  double x = a2.x;
  unsigned int GridColumnForTableCoordinate = TSTLayoutSpaceGetGridColumnForTableCoordinate(a1, a2.x);
  uint64_t GridRowForTableCoordinate = TSTLayoutSpaceGetGridRowForTableCoordinate(a1, y);
  return x
       + TSTLayoutSpaceGetLayoutOffsetForGridPoint(a1, GridColumnForTableCoordinate | (unint64_t)(GridRowForTableCoordinate << 32));
}

double TSTLayoutSpaceGetLayoutCoordinateForGridRow(TSTLayoutSpace *a1, uint64_t a2)
{
  v5.double y = TSTLayoutSpaceGetTableCoordinateForGridRow(a1, a2);
  v5.double x = 0.0;
  TSTLayoutSpaceGetLayoutPointForTablePoint(a1, v5);
  return v3;
}

double TSTLayoutSpaceGetFrameForGridRange(TSTLayoutSpace *a1, unint64_t a2, uint64_t a3)
{
  double TableCoordinateForGridColumn = TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, a2);
  double TableCoordinateForGridRow = TSTLayoutSpaceGetTableCoordinateForGridRow(a1, HIDWORD(a2));
  double v8 = TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, (a3 + 1));
  double v9 = TSTLayoutSpaceGetTableCoordinateForGridRow(a1, (HIDWORD(a3) + 1));
  BOOL v10 = [(TSTLayoutSpace *)a1 layoutDirectionIsLeftToRight];
  if (v10) {
    double v11 = TableCoordinateForGridColumn;
  }
  else {
    double v11 = v8;
  }
  if (v10) {
    double v12 = v8;
  }
  else {
    double v12 = TableCoordinateForGridColumn;
  }
  double v13 = v12 - v11;
  double v14 = TableCoordinateForGridRow;
  double LayoutPointForTablePoint = TSTLayoutSpaceGetLayoutPointForTablePoint(a1, *(CGPoint *)&v11);

  return TSDRectWithOriginAndSize(v15, LayoutPointForTablePoint, v17, v13, v9 - TableCoordinateForGridRow);
}

double TSTLayoutSpaceGetContentFrameForGridRange(TSTLayoutSpace *a1, unint64_t a2, unint64_t a3)
{
  long long v5 = 0u;
  memset(v4, 0, sizeof(v4));
  TSTLayoutSpaceGetFrameSpecForGridRange(a1, a2, a3, 0, 0, (double *)v4);
  return *(double *)v4 + *(double *)&v5 * 0.5;
}

double TSTLayoutSpaceGetFrameSpecForGridRange@<D0>(TSTLayoutSpace *a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, int a4@<W3>, double *a5@<X4>, double *a6@<X8>)
{
  double v12 = [(TSTLayoutSpace *)a1 masterLayout];
  double v13 = v12;
  if (a5)
  {
    double v14 = *a5;
    double v15 = *a5;
    double v16 = *a5;
    double v17 = *a5;
  }
  else
  {
    double v17 = TSTMasterLayoutStrokeHeightOfGridRow(v12, HIDWORD(a2), a2, (int)a3 + 1);
    if (a4 == 1)
    {
      double v15 = TSTMasterLayoutStrokeWidthOfGridColumn(v13, a2, HIDWORD(a2), HIDWORD(a3) + 1);
      double v16 = v17;
    }
    else
    {
      double v16 = TSTMasterLayoutStrokeHeightOfGridRow(v13, HIDWORD(a3) + 1, a2, (int)a3 + 1);
      double v18 = TSTMasterLayoutStrokeWidthOfGridColumn(v13, a2, HIDWORD(a2), HIDWORD(a3) + 1);
      double v15 = v18;
      if (a4 == 2)
      {
        double v14 = v18;
        goto LABEL_11;
      }
    }
    double v14 = v15;
    double v15 = TSTMasterLayoutStrokeWidthOfGridColumn(v13, (int)a3 + 1, HIDWORD(a2), HIDWORD(a3) + 1);
  }
  if (a4 != 2)
  {
    if (a4 == 1) {
      uint64_t v19 = TSTLayoutSpaceIntersectionRowGridRange((uint64_t)a1, a2, a3);
    }
    else {
      uint64_t v19 = TSTLayoutSpaceIntersectionGridRange(a1, a2, a3);
    }
    unint64_t v21 = v19;
    unint64_t v23 = v20;
    double TableCoordinateForGridColumn = TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, v19);
    double v24 = TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, (v23 + 1));
    goto LABEL_14;
  }
LABEL_11:
  unint64_t v21 = TSTLayoutSpaceIntersectionColumnGridRange(a1, a2, a3);
  unint64_t v23 = v22;
  double v24 = TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, v21);
  double TableCoordinateForGridColumn = v24;
LABEL_14:
  double v26 = v24;
  if ([(TSTLayoutSpace *)a1 layoutDirectionIsLeftToRight]) {
    goto LABEL_34;
  }
  p_mGridunint64_t Range = &a1->mGridRange;
  if (!a1) {
    p_mGridunint64_t Range = ($FC6C44E672DFCBD714A302CF0DF56F45 *)&TSTGridRangeEmpty;
  }
  $3C36844D3994842D9102894F8152D7DE topLeft = p_mGridRange->topLeft;
  $3C36844D3994842D9102894F8152D7DE bottomRight = p_mGridRange->bottomRight;
  BOOL v30 = topLeft.column == -1 || bottomRight.column == -1;
  BOOL v31 = v30 || topLeft.column > bottomRight.column;
  unint64_t v32 = HIDWORD(*(unint64_t *)&topLeft);
  unint64_t v33 = HIDWORD(*(unint64_t *)&bottomRight);
  BOOL v34 = v31 || v32 == -1;
  BOOL v35 = v34 || v33 == -1;
  if (v35 || v32 > v33)
  {
LABEL_34:
    double v50 = v14;
    double v14 = v15;
    double v51 = TableCoordinateForGridColumn;
    double TableCoordinateForGridColumn = v26;
  }
  else
  {
    double v50 = v15;
    double v51 = v26;
  }
  double TableCoordinateForGridRow = TSTLayoutSpaceGetTableCoordinateForGridRow(a1, HIDWORD(v21));
  double v38 = TableCoordinateForGridRow;
  if (a4 != 1) {
    double v38 = TSTLayoutSpaceGetTableCoordinateForGridRow(a1, (HIDWORD(v23) + 1));
  }
  if (v21 > a2)
  {
    int v39 = a2;
    do
      double v51 = v51 - TSTMasterLayoutWidthOfColumn((uint64_t)v13, v39++, 0, 0, 1);
    while (v21 != v39);
  }
  if ((int)v23 + 1 < (a3 + 1))
  {
    int v40 = v23;
    do
      double TableCoordinateForGridColumn = TableCoordinateForGridColumn
                                   + TSTMasterLayoutWidthOfColumn((uint64_t)v13, ++v40, 0, 0, 1);
    while (a3 != v40);
  }
  unint64_t v41 = HIDWORD(a2);
  if (HIDWORD(a2) < HIDWORD(v21))
  {
    do
    {
      double TableCoordinateForGridRow = TableCoordinateForGridRow
                                - TSTMasterLayoutHeightOfRow(v13, (unsigned __int16)v41, 0, 0, 1, 1);
      LODWORD(v41) = v41 + 1;
    }
    while (HIDWORD(v21) != v41);
  }
  unint64_t v42 = HIDWORD(v23);
  unint64_t v43 = HIDWORD(a3);
  if (HIDWORD(v23) + 1 < (v43 + 1))
  {
    do
    {
      LODWORD(v42) = v42 + 1;
      double v38 = v38 + TSTMasterLayoutHeightOfRow(v13, (unsigned __int16)v42, 0, 0, 1, 1);
    }
    while (v43 != v42);
  }
  double LayoutOffsetForGridPoint = TSTLayoutSpaceGetLayoutOffsetForGridPoint(a1, a2);
  double v45 = v51 + LayoutOffsetForGridPoint;
  double v47 = TableCoordinateForGridRow + v46;
  double result = TableCoordinateForGridColumn + LayoutOffsetForGridPoint;
  *a6 = v45;
  a6[1] = TableCoordinateForGridRow + v46;
  double v49 = v38 + v46;
  a6[2] = v45;
  a6[3] = v49;
  a6[4] = result;
  a6[5] = v47;
  a6[6] = result;
  a6[7] = v49;
  a6[8] = v17;
  a6[9] = v16;
  a6[10] = v50;
  a6[11] = v14;
  return result;
}

double TSTLayoutSpaceGetStrokeFrameForGridRange(TSTLayoutSpace *a1, unint64_t a2, unint64_t a3)
{
  long long v5 = 0u;
  memset(v4, 0, sizeof(v4));
  TSTLayoutSpaceGetFrameSpecForGridRange(a1, a2, a3, 0, 0, (double *)v4);
  return *(double *)v4 - *(double *)&v5 * 0.5;
}

double TSTLayoutSpaceGetContentFrameForRange(TSTLayoutSpace *a1, unint64_t a2)
{
  unsigned int v2 = BYTE2(a2);
  if (BYTE2(a2) == 255) {
    unsigned int v2 = -1;
  }
  uint64_t v3 = WORD2(a2) + v2 - 1;
  if (!WORD2(a2)) {
    uint64_t v3 = 0xFFFFFFFFLL;
  }
  if ((unsigned __int16)a2 == 0xFFFF) {
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v4 = (unsigned __int16)a2;
  }
  unint64_t v5 = v2 | ((unint64_t)v4 << 32);
  uint64_t v6 = ((a2 >> 16) & 0xFFFF00000000) + (v4 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0) {
    uint64_t v6 = 0xFFFFFFFF00000000;
  }
  return TSTLayoutSpaceGetContentFrameForGridRange(a1, v5, v3 | v6);
}

double TSTLayoutSpaceGetStrokeFrameForRange(TSTLayoutSpace *a1, unint64_t a2)
{
  unsigned int v2 = BYTE2(a2);
  if (BYTE2(a2) == 255) {
    unsigned int v2 = -1;
  }
  uint64_t v3 = WORD2(a2) + v2 - 1;
  if (!WORD2(a2)) {
    uint64_t v3 = 0xFFFFFFFFLL;
  }
  if ((unsigned __int16)a2 == 0xFFFF) {
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v4 = (unsigned __int16)a2;
  }
  unint64_t v5 = v2 | ((unint64_t)v4 << 32);
  uint64_t v6 = ((a2 >> 16) & 0xFFFF00000000) + (v4 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0) {
    uint64_t v6 = 0xFFFFFFFF00000000;
  }
  return TSTLayoutSpaceGetStrokeFrameForGridRange(a1, v5, v3 | v6);
}

double TSTLayoutSpaceGetHeaderColumnsWidth(TSTLayoutSpace *a1)
{
  HeaderColumnsGridunint64_t Range = TSTLayoutSpaceGetHeaderColumnsGridRange((uint64_t)a1);
  if (HeaderColumnsGridRange == -1
    || v3 == -1
    || HeaderColumnsGridRange > v3
    || HIDWORD(HeaderColumnsGridRange) == -1
    || v4 == -1
    || HIDWORD(HeaderColumnsGridRange) > v4)
  {
    return 0.0;
  }
  uint64_t v5 = v3 + 1;

  return TSTLayoutSpaceGetRawTableCoordinateForGridColumn(a1, v5);
}

double TSTLayoutSpaceGetRawTableCoordinateForGridColumn(TSTLayoutSpace *a1, uint64_t a2)
{
  if (!a1)
  {
    unsigned int v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "CGFloat TSTLayoutSpaceGetRawTableCoordinateForGridColumn(TSTLayoutSpace *, TSTGridColumn)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"), 3186, @"space should be non-NULL");
  }
  if (a2 == -1
    || (a1->mGridRange.topLeft.column <= a2
      ? (BOOL v6 = a1->mGridRange.bottomRight.column + 1 >= a2)
      : (BOOL v6 = 0),
        !v6))
  {
    double v7 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v8 = objc_msgSend(NSString, "stringWithUTF8String:", "CGFloat TSTLayoutSpaceGetRawTableCoordinateForGridColumn(TSTLayoutSpace *, TSTGridColumn)");
    uint64_t v9 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"];
    unsigned int column = a1->mGridRange.topLeft.column;
    uint64_t row = a1->mGridRange.topLeft.row;
    $3C36844D3994842D9102894F8152D7DE bottomRight = a1->mGridRange.bottomRight;
    double v13 = NSString;
    if ((row & column) == 0xFFFFFFFF)
    {
      double v15 = @"{invalid, invalid}";
    }
    else
    {
      if (column == -1)
      {
        uint64_t v14 = [NSString stringWithFormat:@"{invalid, %u}", a1->mGridRange.topLeft.row, v23];
      }
      else if (row == -1)
      {
        uint64_t v14 = [NSString stringWithFormat:@"{%u, invalid}", a1->mGridRange.topLeft.column, v23];
      }
      else
      {
        uint64_t v14 = [NSString stringWithFormat:@"{%u, %u}", a1->mGridRange.topLeft.column, row];
      }
      double v15 = (__CFString *)v14;
    }
    if ((bottomRight.row & bottomRight.column) == -1)
    {
      double v16 = @"{invalid, invalid}";
    }
    else if (bottomRight.column == -1)
    {
      double v16 = (__CFString *)[NSString stringWithFormat:@"{invalid, %u}", HIDWORD(*(unint64_t *)&bottomRight), v23];
    }
    else if (bottomRight.row == -1)
    {
      double v16 = (__CFString *)[NSString stringWithFormat:@"{%u, invalid}", bottomRight, v23];
    }
    else
    {
      double v16 = (__CFString *)[NSString stringWithFormat:@"{%u, %u}", bottomRight, HIDWORD(*(unint64_t *)&bottomRight)];
    }
    [v7 handleFailureInFunction:v8, v9, 3188, @"column %u not in gridRange %@", a2, objc_msgSend(v13, "stringWithFormat:", @"{%@->%@}", v15, v16) file lineNumber description];
  }
  if (!a1->mBodyColumnCoordinates && !a1->mHeaderRowColumnCoordinates)
  {
    double v17 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v18 = objc_msgSend(NSString, "stringWithUTF8String:", "CGFloat TSTLayoutSpaceGetRawTableCoordinateForGridColumn(TSTLayoutSpace *, TSTGridColumn)");
    objc_msgSend(v17, "handleFailureInFunction:file:lineNumber:description:", v18, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"), 3190, @"Body column coordinates and header row column coordinates have not been filled.");
  }
  mHeaderRowColumnCoordinates = a1->mHeaderRowColumnCoordinates;
  if (mHeaderRowColumnCoordinates && TSTCoordinateArrayContainsIndex((uint64_t)mHeaderRowColumnCoordinates, a2)) {
    p_mHeaderRowColumnCoordinates = &a1->mHeaderRowColumnCoordinates;
  }
  else {
    p_mHeaderRowColumnCoordinates = &a1->mBodyColumnCoordinates;
  }
  uint64_t v21 = (uint64_t)*p_mHeaderRowColumnCoordinates;

  return TSTCoordinateArrayGetRawCoordinate(v21, a2);
}

double TSTLayoutSpaceGetHeaderRowsHeight(TSTLayoutSpace *a1)
{
  HeaderRowsGridunint64_t Range = TSTLayoutSpaceGetHeaderRowsGridRange((uint64_t)a1);
  if (HeaderRowsGridRange == -1
    || v3 == -1
    || HeaderRowsGridRange > v3
    || HIDWORD(HeaderRowsGridRange) == -1
    || v4 == -1
    || HIDWORD(HeaderRowsGridRange) > v4)
  {
    return 0.0;
  }

  return TSTLayoutSpaceGetTableCoordinateForGridRow(a1, v4 + 1);
}

double TSTLayoutSpaceGetStrokeFrame(uint64_t a1)
{
  [(id)a1 lockForRead];
  if (CGRectIsEmpty(*(CGRect *)(a1 + 368)))
  {
    unint64_t v2 = *(void *)(a1 + 24);
    unint64_t v3 = *(void *)(a1 + 32);
    BOOL v4 = v2 == -1 || v3 == -1;
    BOOL v5 = v4 || v2 > v3;
    BOOL v6 = v5 || HIDWORD(v2) == -1;
    BOOL v7 = v6 || HIDWORD(v3) == -1;
    if (!v7 && HIDWORD(v2) <= HIDWORD(v3))
    {
      StrokeFrameForGridunint64_t Range = TSTLayoutSpaceGetStrokeFrameForGridRange((TSTLayoutSpace *)a1, v2, v3);
      double v11 = v10;
      double v13 = v12;
      double v15 = v14;
      if ([(id)a1 isMain]
        && [(id)a1 headerRowsRepeat]
        && objc_msgSend((id)objc_msgSend((id)a1, "bundle"), "repeatHeaderRowsSpace"))
      {
        TSTLayoutSpaceGetStrokeFrame();
        double v15 = v15 + v11 - v16;
        double v11 = v16;
      }
      if ([(id)a1 isMain]
        && [(id)a1 headerColumnsRepeat]
        && objc_msgSend((id)objc_msgSend((id)a1, "bundle"), "repeatHeaderColumnsSpace"))
      {
        Strokedouble Frame = TSTLayoutSpaceGetStrokeFrame();
        double v13 = v13 + StrokeFrameForGridRange - StrokeFrame;
        StrokeFrameForGridunint64_t Range = StrokeFrame;
      }
      *(double *)(a1 + 368) = StrokeFrameForGridRange;
      *(double *)(a1 + 376) = v11;
      *(double *)(a1 + 384) = v13;
      *(double *)(a1 + 392) = v15;
    }
  }
  double v18 = *(double *)(a1 + 368);
  [(id)a1 unlock];
  return v18;
}

double TSTLayoutSpaceGetFrameForTableNameBorder(TSTLayoutSpace *a1)
{
  if (![(TSTLayoutSpace *)a1 isMain])
  {
    unint64_t v2 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v3 = [NSString stringWithUTF8String:"CGRect TSTLayoutSpaceGetFrameForTableNameBorder(TSTLayoutSpace *)"];
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"), 1034, @"this API is intended to run on the main space");
  }
  double v4 = *MEMORY[0x263F001A8];
  TSTLayoutGetTableNameHeight((uint64_t)[(TSTLayoutSpace *)a1 layout]);
  if (v5 > 0.0)
  {
    p_mGridunint64_t Range = &a1->mGridRange;
    if (!a1) {
      p_mGridunint64_t Range = ($FC6C44E672DFCBD714A302CF0DF56F45 *)&TSTGridRangeEmpty;
    }
    unsigned int column = p_mGridRange->bottomRight.column;
    v12.double x = TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, 0);
    v12.double y = 0.0;
    double LayoutPointForTablePoint = TSTLayoutSpaceGetLayoutPointForTablePoint(a1, v12);
    v13.double x = TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, column + 1);
    v13.double y = 0.0;
    double v9 = TSTLayoutSpaceGetLayoutPointForTablePoint(a1, v13);
    v14.double y = TSTLayoutSpaceGetTableCoordinateForGridRow(a1, 0);
    v14.double x = 0.0;
    if ([(TSTLayoutSpace *)a1 layoutDirectionIsLeftToRight])
    {
      return LayoutPointForTablePoint;
    }
    else
    {
      return v9;
    }
  }
  return v4;
}

double TSTLayoutSpaceGetStrokeFrameForTableNameBorder(TSTLayoutSpace *a1)
{
  if (![(TSTLayoutSpace *)a1 isMain])
  {
    unint64_t v2 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v3 = [NSString stringWithUTF8String:"CGRect TSTLayoutSpaceGetStrokeFrameForTableNameBorder(TSTLayoutSpace *)"];
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"), 1062, @"this API is intended to run on the main space");
  }
  double v4 = *MEMORY[0x263F001A8];
  double v5 = [(TSTLayoutSpace *)a1 layout];
  TSTLayoutGetTableNameHeight((uint64_t)v5);
  if (v6 > 0.0)
  {
    p_$3C36844D3994842D9102894F8152D7DE topLeft = (unint64_t *)&a1->mGridRange.topLeft;
    if (!a1) {
      p_$3C36844D3994842D9102894F8152D7DE topLeft = (unint64_t *)&TSTGridRangeEmpty;
    }
    unint64_t v8 = *p_topLeft;
    unint64_t v9 = p_topLeft[1];
    double v10 = TSTLayoutTableNameBorderStrokeWidth(v5);
    long long v13 = 0u;
    long long v14 = 0u;
    memset(v12, 0, sizeof(v12));
    TSTLayoutSpaceGetFrameSpecForGridRange(a1, v8, v9, 0, 0, (double *)v12);
    long long v14 = v13;
    return *(double *)v12 - v10 * 0.5;
  }
  return v4;
}

double TSTLayoutSpaceGetAlignedStrokeFrameForTableNameBorder(TSTLayoutSpace *a1)
{
  if (![(TSTLayoutSpace *)a1 isMain])
  {
    unint64_t v2 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v3 = [NSString stringWithUTF8String:"CGRect TSTLayoutSpaceGetAlignedStrokeFrameForTableNameBorder(TSTLayoutSpace *)"];
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"), 1098, @"this API is intended to run on the main space");
  }
  double v4 = *MEMORY[0x263F001A8];
  double v5 = [(TSTLayoutSpace *)a1 layout];
  TSTLayoutGetTableNameHeight((uint64_t)v5);
  if (v6 > 0.0)
  {
    p_$3C36844D3994842D9102894F8152D7DE topLeft = (unint64_t *)&a1->mGridRange.topLeft;
    if (!a1) {
      p_$3C36844D3994842D9102894F8152D7DE topLeft = (unint64_t *)&TSTGridRangeEmpty;
    }
    unint64_t v8 = *p_topLeft;
    unint64_t v9 = p_topLeft[1];
    double v10 = TSTLayoutTableNameBorderStrokeWidth(v5);
    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    memset(v12, 0, sizeof(v12));
    TSTLayoutSpaceGetFrameSpecForGridRange(a1, v8, v9, 0, 0, (double *)v12);
    TSTLayoutSpaceGetAlignFrameSpec(a1, (double *)v12);
    long long v14 = v13;
    return *(double *)v12 - v10 * 0.5;
  }
  return v4;
}

double TSTLayoutSpaceGetLayoutPointForCanvasPoint(uint64_t a1, double a2, double a3)
{
  *(void *)&double result = *(_OWORD *)&vaddq_f64(*(float64x2_t *)(a1 + 136), vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)(a1 + 120), a3), *(float64x2_t *)(a1 + 104), a2));
  return result;
}

double TSTLayoutSpaceGetCanvasPointForLayoutPoint(uint64_t a1, double a2, double a3)
{
  *(void *)&double result = *(_OWORD *)&vaddq_f64(*(float64x2_t *)(a1 + 88), vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)(a1 + 72), a3), *(float64x2_t *)(a1 + 56), a2));
  return result;
}

double TSTLayoutSpaceGetLayoutRectForCanvasRect(uint64_t a1, double a2, double a3, double a4, double a5)
{
  long long v5 = *(_OWORD *)(a1 + 120);
  *(_OWORD *)&v7.a = *(_OWORD *)(a1 + 104);
  *(_OWORD *)&v7.c = v5;
  *(_OWORD *)&v7.tdouble x = *(_OWORD *)(a1 + 136);
  *(void *)&double result = (unint64_t)CGRectApplyAffineTransform(*(CGRect *)&a2, &v7);
  return result;
}

double TSTLayoutSpaceGetCanvasRectForLayoutRect(uint64_t a1, double a2, double a3, double a4, double a5)
{
  long long v5 = *(_OWORD *)(a1 + 72);
  *(_OWORD *)&v7.a = *(_OWORD *)(a1 + 56);
  *(_OWORD *)&v7.c = v5;
  *(_OWORD *)&v7.tdouble x = *(_OWORD *)(a1 + 88);
  *(void *)&double result = (unint64_t)CGRectApplyAffineTransform(*(CGRect *)&a2, &v7);
  return result;
}

uint64_t TSTLayoutSpaceGetGridRangeForCanvasRect(uint64_t a1, double a2, double a3, double a4, double a5)
{
  long long v6 = *(_OWORD *)(a1 + 120);
  *(_OWORD *)&v8.a = *(_OWORD *)(a1 + 104);
  *(_OWORD *)&v8.c = v6;
  *(_OWORD *)&v8.tdouble x = *(_OWORD *)(a1 + 136);
  CGRect v9 = CGRectApplyAffineTransform(*(CGRect *)&a2, &v8);
  v10.origin.double x = TSTLayoutSpaceGetTableRectForLayoutRect((TSTLayoutSpace *)a1, v9);
  return TSTLayoutSpaceGetGridRangeForTableRect((TSTLayoutSpace *)a1, v10);
}

double TSTLayoutSpaceGetCanvasFrameForGridRange(uint64_t a1, unint64_t a2, uint64_t a3)
{
  v7.origin.double x = TSTLayoutSpaceGetFrameForGridRange((TSTLayoutSpace *)a1, a2, a3);
  long long v4 = *(_OWORD *)(a1 + 72);
  *(_OWORD *)&v6.a = *(_OWORD *)(a1 + 56);
  *(_OWORD *)&v6.c = v4;
  *(_OWORD *)&v6.tdouble x = *(_OWORD *)(a1 + 88);
  *(void *)&double result = (unint64_t)CGRectApplyAffineTransform(v7, &v6);
  return result;
}

double TSTLayoutSpaceGetCanvasFrameForCellRange(uint64_t a1, unint64_t a2)
{
  unsigned int v3 = BYTE2(a2);
  if (BYTE2(a2) == 255) {
    unsigned int v3 = -1;
  }
  uint64_t v4 = WORD2(a2) + v3 - 1;
  if (!WORD2(a2)) {
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  if ((unsigned __int16)a2 == 0xFFFF) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = (unsigned __int16)a2;
  }
  unint64_t v6 = v3 | ((unint64_t)v5 << 32);
  uint64_t v7 = ((a2 >> 16) & 0xFFFF00000000) + (v5 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0) {
    uint64_t v7 = 0xFFFFFFFF00000000;
  }
  v11.origin.double x = TSTLayoutSpaceGetFrameForGridRange((TSTLayoutSpace *)a1, v6, v4 | v7);
  long long v8 = *(_OWORD *)(a1 + 72);
  *(_OWORD *)&v10.a = *(_OWORD *)(a1 + 56);
  *(_OWORD *)&v10.c = v8;
  *(_OWORD *)&v10.tdouble x = *(_OWORD *)(a1 + 88);
  *(void *)&double result = (unint64_t)CGRectApplyAffineTransform(v11, &v10);
  return result;
}

double TSTLayoutSpaceGetCanvasFrame(uint64_t a1)
{
  v5.origin.double x = TSTLayoutSpaceGetFrame(a1);
  long long v2 = *(_OWORD *)(a1 + 72);
  *(_OWORD *)&v4.a = *(_OWORD *)(a1 + 56);
  *(_OWORD *)&v4.c = v2;
  *(_OWORD *)&v4.tdouble x = *(_OWORD *)(a1 + 88);
  *(void *)&double result = (unint64_t)CGRectApplyAffineTransform(v5, &v4);
  return result;
}

double TSTLayoutSpaceGetCanvasStrokeFrameForGridRange(uint64_t a1, unint64_t a2, unint64_t a3)
{
  [(id)a1 lockForRead];
  v10.origin.double x = TSTLayoutSpaceGetStrokeFrameForGridRange((TSTLayoutSpace *)a1, a2, a3);
  long long v6 = *(_OWORD *)(a1 + 72);
  *(_OWORD *)&v9.a = *(_OWORD *)(a1 + 56);
  *(_OWORD *)&v9.c = v6;
  *(_OWORD *)&v9.tdouble x = *(_OWORD *)(a1 + 88);
  *(void *)&double v7 = (unint64_t)CGRectApplyAffineTransform(v10, &v9);
  [(id)a1 unlock];
  return v7;
}

double TSTLayoutSpaceGetCanvasStrokeFrame(uint64_t a1)
{
  v5.origin.double x = TSTLayoutSpaceGetStrokeFrame(a1);
  long long v2 = *(_OWORD *)(a1 + 72);
  *(_OWORD *)&v4.a = *(_OWORD *)(a1 + 56);
  *(_OWORD *)&v4.c = v2;
  *(_OWORD *)&v4.tdouble x = *(_OWORD *)(a1 + 88);
  *(void *)&double result = (unint64_t)CGRectApplyAffineTransform(v5, &v4);
  return result;
}

double TSTLayoutSpaceGetLayoutRectForOtherLayoutSpaceRect(uint64_t a1, uint64_t a2, double result, double a4, double a5, double a6)
{
  if (a2 != a1)
  {
    uint64_t v12 = v6;
    uint64_t v13 = v7;
    long long v9 = *(_OWORD *)(a2 + 72);
    *(_OWORD *)&v11.a = *(_OWORD *)(a2 + 56);
    *(_OWORD *)&v11.c = v9;
    *(_OWORD *)&v11.tdouble x = *(_OWORD *)(a2 + 88);
    CGRect v14 = CGRectApplyAffineTransform(*(CGRect *)&result, &v11);
    long long v10 = *(_OWORD *)(a1 + 120);
    *(_OWORD *)&v11.a = *(_OWORD *)(a1 + 104);
    *(_OWORD *)&v11.c = v10;
    *(_OWORD *)&v11.tdouble x = *(_OWORD *)(a1 + 136);
    *(void *)&double result = (unint64_t)CGRectApplyAffineTransform(v14, &v11);
  }
  return result;
}

CGFloat TSTLayoutSpaceGetCanvasPositionForGridColumn(TSTLayoutSpace *a1, uint64_t a2)
{
  return a1->mTransformToCanvas.tx
       + a1->mTransformToCanvas.c * 0.0
       + a1->mTransformToCanvas.a * TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, a2);
}

CGFloat TSTLayoutSpaceGetCanvasPositionForGridRow(TSTLayoutSpace *a1, uint64_t a2)
{
  return a1->mTransformToCanvas.ty
       + TSTLayoutSpaceGetTableCoordinateForGridRow(a1, a2) * a1->mTransformToCanvas.d
       + a1->mTransformToCanvas.b * 0.0;
}

uint64_t TSTLayoutSpaceGetGridPointHitByCanvasPoint(uint64_t a1, int a2, double a3, CGFloat a4)
{
  if (a2)
  {
    double point = a3;
    TSTLayoutGetColumnTabsCanvasFrame((void *)[(id)a1 layout]);
    v13.double x = point;
    v13.double y = a4;
    BOOL v6 = CGRectContainsPoint(v15, v13);
    a3 = point;
    double v7 = -31.0;
    if (v6) {
      goto LABEL_6;
    }
    TSTLayoutGetRowTabsCanvasFrame(objc_msgSend((id)a1, "layout", point));
    v14.double x = point;
    v14.double y = a4;
    BOOL v8 = CGRectContainsPoint(v16, v14);
    a3 = point;
    if (v8) {
      a3 = -31.0;
    }
  }
  double v7 = a4;
LABEL_6:
  float64x2_t v9 = vaddq_f64(*(float64x2_t *)(a1 + 136), vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)(a1 + 120), v7), *(float64x2_t *)(a1 + 104), a3));

  return TSTLayoutSpaceGetGridPointHitByLayoutPoint((TSTLayoutSpace *)a1, v9.f64[0], v9.f64[1]);
}

uint64_t TSTLayoutSpaceGetGridPointHitByLayoutPoint(TSTLayoutSpace *a1, double a2, double a3)
{
  double TablePointForLayoutPoint = TSTLayoutSpaceGetTablePointForLayoutPoint(a1, *(CGPoint *)&a2);
  double v6 = v5;
  v16.origin.CGFloat x = TSTLayoutSpaceGetFrame((uint64_t)a1);
  v17.origin.CGFloat x = TSTLayoutSpaceGetTableRectForLayoutRect(a1, v16);
  CGFloat x = v17.origin.x;
  CGFloat y = v17.origin.y;
  CGFloat width = v17.size.width;
  CGFloat height = v17.size.height;
  if (TablePointForLayoutPoint + 0.00000011920929 >= CGRectGetMinX(v17)) {
    uint64_t GridColumnForTableCoordinate = TSTLayoutSpaceGetGridColumnForTableCoordinate(a1, TablePointForLayoutPoint);
  }
  else {
    uint64_t GridColumnForTableCoordinate = 0xFFFFFFFFLL;
  }
  v18.origin.CGFloat x = x;
  v18.origin.CGFloat y = y;
  v18.size.CGFloat width = width;
  v18.size.CGFloat height = height;
  CGFloat MinY = CGRectGetMinY(v18);
  uint64_t v13 = 0xFFFFFFFF00000000;
  if (v6 + 0.00000011920929 >= MinY) {
    uint64_t v13 = TSTLayoutSpaceGetGridRowForTableCoordinate(a1, v6) << 32;
  }
  uint64_t v14 = 0xFFFFFFFFLL;
  if (a1->mGridRange.bottomRight.column >= GridColumnForTableCoordinate) {
    uint64_t v14 = GridColumnForTableCoordinate;
  }
  if (a1->mGridRange.bottomRight.row < HIDWORD(v13)) {
    uint64_t v13 = 0xFFFFFFFF00000000;
  }
  return v13 | v14;
}

double TSTLayoutSpaceGetTablePointForLayoutPoint(TSTLayoutSpace *a1, CGPoint a2)
{
  double y = a2.y;
  double x = a2.x;
  [(TSTLayoutSpace *)a1 tableOffset];
  double v6 = x - v5;
  if ((TSTLayoutIsPartitionAlongLeft([(TSTLayoutSpace *)a1 layout]) & 1) == 0
    && v6 > TSTLayoutSpaceGetHeaderColumnsWidth(a1))
  {
    double BodyTranslationX = TSTLayoutSpaceGetBodyTranslationX(a1);
    double v6 = v6 + BodyTranslationX - TSTLayoutSpaceGetHeaderColumnsWidth(a1);
  }
  [(TSTLayoutSpace *)a1 tableOffset];
  double v9 = y - v8;
  if ((TSTLayoutIsPartitionAlongTop([(TSTLayoutSpace *)a1 layout]) & 1) == 0
    && v9 > TSTLayoutSpaceGetHeaderRowsHeight(a1))
  {
    TSTLayoutSpaceGetBodyTranslationY(a1);
    TSTLayoutSpaceGetHeaderRowsHeight(a1);
  }
  return v6;
}

uint64_t TSTLayoutSpaceGetVisibleRange(TSTLayoutSpace *a1)
{
  if (!a1) {
    return 0xFFFFFFLL;
  }
  if ([(TSTLayoutSpace *)a1 layoutSpaceType] == 1
    || [(TSTLayoutSpace *)a1 layoutSpaceType] == 4)
  {
    return TSTLayoutSpaceGetRange((uint64_t)a1);
  }
  if ([(TSTLayoutSpace *)a1 layoutSpaceType] != 6
    && [(TSTLayoutSpace *)a1 layoutSpaceType] != 5)
  {
    Visibleunint64_t Range = TSTLayoutGetVisibleRange([(TSTLayoutSpace *)a1 layout]);
    unint64_t v5 = VisibleRange >> 16;
    unint64_t v6 = HIWORD(VisibleRange);
    unint64_t Range = TSTLayoutSpaceGetRange((uint64_t)a1);
    if ([(TSTLayoutSpace *)a1 layoutSpaceType] == 2)
    {
      LOWORD(v8) = WORD2(VisibleRange) + BYTE2(VisibleRange);
      unsigned __int16 v9 = VisibleRange;
      LOBYTE(v5) = 0;
    }
    else
    {
      unint64_t v8 = HIDWORD(VisibleRange);
      if ([(TSTLayoutSpace *)a1 layoutSpaceType] == 3)
      {
        unint64_t v6 = (unsigned __int16)(HIWORD(VisibleRange) + VisibleRange);
        unsigned __int16 v9 = 0;
      }
      else
      {
        unsigned __int16 v9 = VisibleRange;
      }
    }
    unint64_t v10 = 0;
    uint64_t v11 = 16711680;
    uint64_t v12 = 0xFFFFLL;
    if (v9 != 0xFFFF)
    {
      unint64_t v13 = 0;
      if ((unint64_t)v5 << 16 == 16711680) {
        return v11 | v13 | v12 | v10;
      }
      unint64_t v10 = 0;
      uint64_t v11 = 16711680;
      uint64_t v12 = 0xFFFFLL;
      if ((unint64_t)(unsigned __int16)v8 << 32)
      {
        unint64_t v14 = VisibleRange & 0xFF000000 | (v6 << 48) | ((unint64_t)(unsigned __int16)v8 << 32);
        unint64_t v15 = v14 | ((unint64_t)v5 << 16);
        unint64_t v13 = 0;
        if (!HIWORD(v15)) {
          return v11 | v13 | v12 | v10;
        }
        unint64_t v10 = 0;
        uint64_t v11 = 16711680;
        uint64_t v12 = 0xFFFFLL;
        if ((_WORD)Range != 0xFFFF)
        {
          unint64_t v13 = 0;
          if ((Range & 0xFF0000) != 0xFF0000)
          {
            unint64_t v10 = 0;
            uint64_t v11 = 16711680;
            uint64_t v12 = 0xFFFFLL;
            if (HIWORD(Range))
            {
              unint64_t v13 = 0;
              if ((Range & 0xFFFF00000000) != 0)
              {
                uint64_t v12 = 0;
                unsigned int v16 = v5 <= BYTE2(Range) ? BYTE2(Range) : v5;
                uint64_t v17 = v9 <= (unsigned __int16)Range ? (unsigned __int16)Range : v9;
                unsigned int v18 = (BYTE4(v14) + BYTE2(v15) - 1) >= (BYTE4(Range) + BYTE2(Range) - 1)
                    ? (BYTE4(Range) + BYTE2(Range) - 1)
                    : (BYTE4(v14) + BYTE2(v15) - 1);
                unsigned int v19 = (unsigned __int16)(v6 + v9 - 1) >= (unsigned __int16)(Range + HIWORD(Range) - 1)
                    ? (unsigned __int16)(Range + HIWORD(Range) - 1)
                    : (unsigned __int16)(v6 + v9 - 1);
                uint64_t v11 = 0;
                unint64_t v10 = 0;
                unint64_t v13 = 0;
                if (v17 <= v19 && v16 <= v18)
                {
                  unint64_t v13 = ((unint64_t)(v19 - v17) << 48) + 0x1000000000000;
                  unint64_t v10 = (unint64_t)(unsigned __int16)(v18 - v16 + 1) << 32;
                  uint64_t v11 = v16 << 16;
                  uint64_t v12 = v17;
                }
              }
              return v11 | v13 | v12 | v10;
            }
            goto LABEL_41;
          }
          return v11 | v13 | v12 | v10;
        }
      }
    }
LABEL_41:
    unint64_t v13 = 0;
    return v11 | v13 | v12 | v10;
  }
  unsigned int v3 = [(TSTLayoutSpace *)a1 layout];

  return TSTLayoutGetVisibleRangeForSpace(v3, a1);
}

uint64_t TSTLayoutSpaceGetVisibleRangeForRect(TSTLayoutSpace *a1, double a2, double a3, double a4, double a5)
{
  if (!a1) {
    return 0xFFFFFFLL;
  }
  unint64_t RangeForLayoutRect = TSTLayoutSpaceGetRangeForLayoutRect(a1, a2, a3, a4, a5);
  Visibleunint64_t Range = TSTLayoutSpaceGetVisibleRange(a1);
  unint64_t v8 = 0;
  uint64_t v9 = 16711680;
  uint64_t v10 = 0xFFFFLL;
  if ((_WORD)RangeForLayoutRect == 0xFFFF) {
    goto LABEL_25;
  }
  unint64_t v11 = 0;
  if ((RangeForLayoutRect & 0xFF0000) == 0xFF0000) {
    goto LABEL_26;
  }
  unint64_t v8 = 0;
  uint64_t v9 = 16711680;
  uint64_t v10 = 0xFFFFLL;
  if (!HIWORD(RangeForLayoutRect)) {
    goto LABEL_25;
  }
  unint64_t v11 = 0;
  if ((RangeForLayoutRect & 0xFFFF00000000) == 0) {
    goto LABEL_26;
  }
  unint64_t v8 = 0;
  uint64_t v9 = 16711680;
  uint64_t v10 = 0xFFFFLL;
  if ((_WORD)VisibleRange == 0xFFFF)
  {
LABEL_25:
    unint64_t v11 = 0;
    goto LABEL_26;
  }
  unint64_t v11 = 0;
  if ((VisibleRange & 0xFF0000) != 0xFF0000)
  {
    unint64_t v8 = 0;
    uint64_t v9 = 16711680;
    uint64_t v10 = 0xFFFFLL;
    if (HIWORD(VisibleRange))
    {
      unint64_t v11 = 0;
      if ((VisibleRange & 0xFFFF00000000) != 0)
      {
        uint64_t v10 = 0;
        if (BYTE2(RangeForLayoutRect) <= BYTE2(VisibleRange)) {
          unsigned int v12 = BYTE2(VisibleRange);
        }
        else {
          unsigned int v12 = BYTE2(RangeForLayoutRect);
        }
        if ((unsigned __int16)RangeForLayoutRect <= (unsigned __int16)VisibleRange) {
          uint64_t v13 = (unsigned __int16)VisibleRange;
        }
        else {
          uint64_t v13 = (unsigned __int16)RangeForLayoutRect;
        }
        if ((BYTE4(RangeForLayoutRect) + BYTE2(RangeForLayoutRect) - 1) >= (BYTE4(VisibleRange) + BYTE2(VisibleRange) - 1)) {
          unsigned int v14 = (BYTE4(VisibleRange) + BYTE2(VisibleRange) - 1);
        }
        else {
          unsigned int v14 = (BYTE4(RangeForLayoutRect) + BYTE2(RangeForLayoutRect) - 1);
        }
        unsigned int v15 = (unsigned __int16)(VisibleRange + HIWORD(VisibleRange) - 1);
        if ((unsigned __int16)(RangeForLayoutRect + HIWORD(RangeForLayoutRect) - 1) < v15) {
          unsigned int v15 = (unsigned __int16)(RangeForLayoutRect + HIWORD(RangeForLayoutRect) - 1);
        }
        uint64_t v9 = 0;
        unint64_t v8 = 0;
        unint64_t v11 = 0;
        if (v13 <= v15 && v12 <= v14)
        {
          unint64_t v11 = ((unint64_t)(v15 - v13) << 48) + 0x1000000000000;
          unint64_t v8 = (unint64_t)(unsigned __int16)(v14 - v12 + 1) << 32;
          uint64_t v9 = v12 << 16;
          uint64_t v10 = v13;
        }
      }
      goto LABEL_26;
    }
    goto LABEL_25;
  }
LABEL_26:
  unint64_t v16 = v9 | v11 | v10 | v8;
  if ((_WORD)v16 == 0xFFFF || (v16 & 0xFF0000) == 0xFF0000 || !HIWORD(v16) || (v16 & 0xFFFF00000000) == 0) {
    return VisibleRange;
  }
  return v16;
}

void TSTLayoutSpaceGetVisibleFrameForRange(uint64_t a1, unint64_t a2)
{
  unsigned int v3 = BYTE2(a2);
  if (BYTE2(a2) == 255) {
    unsigned int v3 = -1;
  }
  uint64_t v4 = WORD2(a2) + v3 - 1;
  if (!WORD2(a2)) {
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  if ((unsigned __int16)a2 == 0xFFFF) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = (unsigned __int16)a2;
  }
  unint64_t v6 = v3 | ((unint64_t)v5 << 32);
  uint64_t v7 = ((a2 >> 16) & 0xFFFF00000000) + (v5 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0) {
    uint64_t v7 = 0xFFFFFFFF00000000;
  }
  CanvasFrameForGridunint64_t Range = TSTLayoutSpaceGetCanvasFrameForGridRange(a1, v6, v4 | v7);
  CGFloat v10 = v9;
  CGFloat v12 = v11;
  CGFloat v14 = v13;
  v22.origin.double x = TSTLayoutGetCanvasVisibleRect([(id)a1 layout]);
  v22.origin.double y = v15;
  v22.size.CGFloat width = v16;
  v22.size.CGFloat height = v17;
  v20.origin.double x = CanvasFrameForGridRange;
  v20.origin.double y = v10;
  v20.size.CGFloat width = v12;
  v20.size.CGFloat height = v14;
  CGRect v21 = CGRectIntersection(v20, v22);
  long long v18 = *(_OWORD *)(a1 + 120);
  *(_OWORD *)&v19.a = *(_OWORD *)(a1 + 104);
  *(_OWORD *)&v19.c = v18;
  *(_OWORD *)&v19.tdouble x = *(_OWORD *)(a1 + 136);
  CGRectApplyAffineTransform(v21, &v19);
}

void TSTLayoutSpaceGetVisibleStrokeFrameForRange(uint64_t a1, unint64_t a2)
{
  unsigned int v3 = BYTE2(a2);
  if (BYTE2(a2) == 255) {
    unsigned int v3 = -1;
  }
  uint64_t v4 = WORD2(a2) + v3 - 1;
  if (!WORD2(a2)) {
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  if ((unsigned __int16)a2 == 0xFFFF) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = (unsigned __int16)a2;
  }
  unint64_t v6 = v3 | ((unint64_t)v5 << 32);
  uint64_t v7 = ((a2 >> 16) & 0xFFFF00000000) + (v5 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0) {
    uint64_t v7 = 0xFFFFFFFF00000000;
  }
  CanvasStrokeFrameForGridunint64_t Range = TSTLayoutSpaceGetCanvasStrokeFrameForGridRange(a1, v6, v4 | v7);
  CGFloat v10 = v9;
  CGFloat v12 = v11;
  CGFloat v14 = v13;
  v22.origin.double x = TSTLayoutGetCanvasVisibleRect([(id)a1 layout]);
  v22.origin.double y = v15;
  v22.size.CGFloat width = v16;
  v22.size.CGFloat height = v17;
  v20.origin.double x = CanvasStrokeFrameForGridRange;
  v20.origin.double y = v10;
  v20.size.CGFloat width = v12;
  v20.size.CGFloat height = v14;
  CGRect v21 = CGRectIntersection(v20, v22);
  long long v18 = *(_OWORD *)(a1 + 120);
  *(_OWORD *)&v19.a = *(_OWORD *)(a1 + 104);
  *(_OWORD *)&v19.c = v18;
  *(_OWORD *)&v19.tdouble x = *(_OWORD *)(a1 + 136);
  CGRectApplyAffineTransform(v21, &v19);
}

void TSTLayoutSpaceGetVisibleAlignedStrokeFrameForRange(uint64_t a1, unint64_t a2)
{
  unsigned int v3 = BYTE2(a2);
  if (BYTE2(a2) == 255) {
    unsigned int v3 = -1;
  }
  uint64_t v4 = WORD2(a2) + v3 - 1;
  if (!WORD2(a2)) {
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  if ((unsigned __int16)a2 == 0xFFFF) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = (unsigned __int16)a2;
  }
  unint64_t v6 = v3 | ((unint64_t)v5 << 32);
  uint64_t v7 = ((a2 >> 16) & 0xFFFF00000000) + (v5 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0) {
    uint64_t v7 = 0xFFFFFFFF00000000;
  }
  v18.origin.CGFloat x = TSTLayoutSpaceGetAlignedStrokeFrameForGridRange((TSTLayoutSpace *)a1, v6, v4 | v7);
  long long v8 = *(_OWORD *)(a1 + 72);
  *(_OWORD *)&v17.a = *(_OWORD *)(a1 + 56);
  *(_OWORD *)&v17.c = v8;
  *(_OWORD *)&v17.tCGFloat x = *(_OWORD *)(a1 + 88);
  CGRect v19 = CGRectApplyAffineTransform(v18, &v17);
  CGFloat x = v19.origin.x;
  CGFloat y = v19.origin.y;
  CGFloat width = v19.size.width;
  CGFloat height = v19.size.height;
  v22.origin.CGFloat x = TSTLayoutGetCanvasVisibleRect([(id)a1 layout]);
  v22.origin.CGFloat y = v13;
  v22.size.CGFloat width = v14;
  v22.size.CGFloat height = v15;
  v20.origin.CGFloat x = x;
  v20.origin.CGFloat y = y;
  v20.size.CGFloat width = width;
  v20.size.CGFloat height = height;
  CGRect v21 = CGRectIntersection(v20, v22);
  long long v16 = *(_OWORD *)(a1 + 120);
  *(_OWORD *)&v17.a = *(_OWORD *)(a1 + 104);
  *(_OWORD *)&v17.c = v16;
  *(_OWORD *)&v17.tCGFloat x = *(_OWORD *)(a1 + 136);
  CGRectApplyAffineTransform(v21, &v17);
}

double TSTLayoutSpaceGetAlignedStrokeFrameForGridRange(TSTLayoutSpace *a1, unint64_t a2, unint64_t a3)
{
  long long v6 = 0u;
  memset(v5, 0, sizeof(v5));
  TSTLayoutSpaceGetFrameSpecForGridRange(a1, a2, a3, 0, 0, (double *)v5);
  TSTLayoutSpaceGetAlignFrameSpec(a1, (double *)v5);
  return *(double *)v5 - *(double *)&v6 * 0.5;
}

__n128 TSTLayoutSpaceSetUserSpaceToDeviceSpaceTransform(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  long long v4 = a2[1];
  *(_OWORD *)(a1 + 184) = a2[2];
  *(_OWORD *)(a1 + 168) = v4;
  *(_OWORD *)(a1 + 152) = v3;
  long long v5 = a2[1];
  *(_OWORD *)&v9.a = *a2;
  *(_OWORD *)&v9.c = v5;
  *(_OWORD *)&v9.tCGFloat x = a2[2];
  CGAffineTransformInvert(&v10, &v9);
  long long v6 = *(_OWORD *)&v10.c;
  *(_OWORD *)(a1 + 200) = *(_OWORD *)&v10.a;
  *(_OWORD *)(a1 + 216) = v6;
  *(_OWORD *)(a1 + 232) = *(_OWORD *)&v10.tx;
  __n128 result = *(__n128 *)MEMORY[0x263F001A8];
  long long v8 = *(_OWORD *)(MEMORY[0x263F001A8] + 16);
  *(_OWORD *)(a1 + 336) = *MEMORY[0x263F001A8];
  *(_OWORD *)(a1 + 352) = v8;
  *(__n128 *)(a1 + 400) = result;
  *(_OWORD *)(a1 + 416) = v8;
  return result;
}

__n128 TSTLayoutSpaceGetTransformToDevice@<Q0>(TSTLayoutSpace *a1@<X0>, uint64_t a2@<X8>)
{
  long long v2 = *(_OWORD *)&a1->mTransformToDevice.c;
  *(_OWORD *)a2 = *(_OWORD *)&a1->mTransformToDevice.a;
  *(_OWORD *)(a2 + 16) = v2;
  __n128 result = *(__n128 *)&a1->mTransformToDevice.tx;
  *(__n128 *)(a2 + 32) = result;
  return result;
}

__n128 TSTLayoutSpaceGetTransformFromDevice@<Q0>(TSTLayoutSpace *a1@<X0>, uint64_t a2@<X8>)
{
  long long v2 = *(_OWORD *)&a1->mTransformFromDevice.c;
  *(_OWORD *)a2 = *(_OWORD *)&a1->mTransformFromDevice.a;
  *(_OWORD *)(a2 + 16) = v2;
  __n128 result = *(__n128 *)&a1->mTransformFromDevice.tx;
  *(__n128 *)(a2 + 32) = result;
  return result;
}

CGFloat TSTLayoutSpaceGetAlignedRectForLayoutRect(double *a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5)
{
  if ([a1 drawPreventAntialias])
  {
    v13.origin.CGFloat x = a2;
    v13.origin.CGFloat y = a3;
    v13.size.CGFloat width = a4;
    v13.size.CGFloat height = a5;
    double MinX = CGRectGetMinX(v13);
    v14.origin.CGFloat x = a2;
    v14.origin.CGFloat y = a3;
    v14.size.CGFloat width = a4;
    v14.size.CGFloat height = a5;
    double MinY = CGRectGetMinY(v14);
    v15.origin.CGFloat x = a2;
    v15.origin.CGFloat y = a3;
    v15.size.CGFloat width = a4;
    v15.size.CGFloat height = a5;
    CGRectGetMaxX(v15);
    v16.origin.CGFloat x = a2;
    v16.origin.CGFloat y = a3;
    v16.size.CGFloat width = a4;
    v16.size.CGFloat height = a5;
    CGRectGetMaxY(v16);
    return a1[29]
         + floor(a1[24] + MinY * a1[22] + a1[20] * MinX + 0.00000011920929) * a1[27]
         + a1[25] * floor(a1[23] + MinY * a1[21] + a1[19] * MinX + 0.00000011920929);
  }
  return a2;
}

void TSTLayoutSpaceAlignRect(double *a1, CGFloat *a2)
{
  *a2 = TSTLayoutSpaceGetAlignedRectForLayoutRect(a1, *a2, a2[1], a2[2], a2[3]);
  *((void *)a2 + 1) = v3;
  *((void *)a2 + 2) = v4;
  *((void *)a2 + 3) = v5;
}

double TSTLayoutSpaceGetAlignedPointForLayoutPoint(double *a1, double a2, double a3)
{
  if ([a1 drawPreventAntialias]) {
    return a1[29]
  }
         + floor(a1[24] + a3 * a1[22] + a1[20] * a2 + 0.00000011920929) * a1[27]
         + a1[25] * floor(a1[23] + a3 * a1[21] + a1[19] * a2 + 0.00000011920929);
  return a2;
}

void TSTLayoutSpaceAlignLayoutPoint(double *a1, double *a2)
{
  *a2 = TSTLayoutSpaceGetAlignedPointForLayoutPoint(a1, *a2, a2[1]);
  *((void *)a2 + 1) = v3;
}

double TSTLayoutSpaceStrokeWidthForDrawing(double a1, double a2)
{
  return a2;
}

void TSTLayoutSpaceAlignStrokeCoordinates(TSTLayoutSpace *a1, double *a2, CGPoint *a3, double *a4)
{
  if ([(TSTLayoutSpace *)a1 drawPreventAntialias])
  {
    double v57 = 0.0;
    double v58 = 0.0;
    double v8 = *a2;
    double v9 = a2[1];
    double y = a3->y;
    if (*a2 == a3->x)
    {
      if (v9 >= y)
      {
        double v11 = *a4;
        CGFloat v12 = NSStringFromCGPoint(*(CGPoint *)&v8);
        CGRect v13 = NSStringFromCGPoint(*a3);
        NSLog((NSString *)@"WARNING: vertical stroke(%f %@ => %@) length <= 0.0", *(void *)&v11, v12, v13);
        a3->double y = a2[1] + 1.0;
      }
      TSTLayoutSpaceAlignStrokeWidth(a1, *a4, &v57, &v58);
      double v14 = v57;
      *a4 = v57;
      double v15 = a2[1];
      double b = a1->mTransformToDevice.b;
      double d = a1->mTransformToDevice.d;
      tCGFloat x = a1->mTransformToDevice.tx;
      tdouble y = a1->mTransformToDevice.ty;
      double v20 = ty + a3->y * d + b * *a2;
      double v21 = floor(tx + v15 * a1->mTransformToDevice.c + a1->mTransformToDevice.a * *a2 - v58 * 0.5 + 0.00000011920929);
      double v22 = floor(ty + v15 * d + b * *a2 + 0.00000011920929);
      if (v21 <= 0.0 && *a2 >= 0.0 && tx >= -1.0) {
        double v21 = 0.0;
      }
      double v25 = a1->mTransformFromDevice.b;
      double v26 = a1->mTransformFromDevice.d;
      double v27 = a1->mTransformFromDevice.ty;
      double v28 = v27 + v22 * v26 + v25 * v21;
      double v29 = v27 + floor(v20 + 0.00000011920929) * v26 + v25 * v21;
      double v30 = v14 * 0.5
          + a1->mTransformFromDevice.tx
          + v22 * a1->mTransformFromDevice.c
          + a1->mTransformFromDevice.a * v21;
      double v31 = v30;
    }
    else
    {
      if (v9 != y) {
        return;
      }
      if (v8 >= a3->x)
      {
        double v32 = *a4;
        unint64_t v33 = NSStringFromCGPoint(*(CGPoint *)&v8);
        BOOL v34 = NSStringFromCGPoint(*a3);
        NSLog((NSString *)@"WARNING: horizontal stroke(%f %@ => %@) length <= 0.0", *(void *)&v32, v33, v34);
        a3->CGFloat x = *a2 + 1.0;
      }
      double v35 = *a4;
      if (*a4 >= 0.0)
      {
        double v36 = 0.0;
        double v37 = 0.0;
        if (*a4 > 0.0)
        {
          double v38 = v35 * a1->mTransformToDevice.c + a1->mTransformToDevice.a * v35;
          double v39 = fabs(v35 * a1->mTransformToDevice.d + a1->mTransformToDevice.b * v35);
          double v40 = floor(v39 + 0.00000011920929);
          if (v39 >= 1.0) {
            double v41 = v40;
          }
          else {
            double v41 = 1.0;
          }
          double v37 = a1->mTransformFromDevice.d * v41 + a1->mTransformFromDevice.b * v38;
          double v36 = v41 * 0.5;
        }
      }
      else
      {
        NSLog((NSString *)@"WARNING: stroke width %f < 0.0", *(void *)a4);
        double v36 = 0.0;
        double v37 = 0.0;
      }
      *a4 = v37;
      double v42 = a2[1];
      double a = a1->mTransformToDevice.a;
      double v44 = a1->mTransformToDevice.tx;
      double v45 = a1->mTransformToDevice.ty;
      double v46 = v42 * a1->mTransformToDevice.c;
      double v47 = v44 + v46 + a * a3->x;
      double v48 = floor(v44 + v46 + a * *a2 + 0.00000011920929);
      double v49 = floor(v45 + v42 * a1->mTransformToDevice.d + a1->mTransformToDevice.b * *a2 - v36 + 0.00000011920929);
      if (v49 > 0.0 || v42 < 0.0 || v45 < -1.0) {
        double v52 = v49;
      }
      else {
        double v52 = 0.0;
      }
      double v53 = floor(v47 + 0.00000011920929);
      double v54 = a1->mTransformFromDevice.a;
      double v55 = a1->mTransformFromDevice.tx;
      CGFloat v56 = a1->mTransformFromDevice.c * v52;
      double v30 = v55 + v56 + v54 * v48;
      double v31 = v55 + v56 + v54 * v53;
      double v28 = v37 * 0.5
          + a1->mTransformFromDevice.ty
          + a1->mTransformFromDevice.d * v52
          + a1->mTransformFromDevice.b * v48;
      double v29 = v28;
    }
    *a2 = v30;
    a2[1] = v28;
    a3->CGFloat x = v31;
    a3->double y = v29;
  }
}

void TSTLayoutSpaceAlignStrokeWidth(TSTLayoutSpace *a1, double a2, double *a3, double *a4)
{
  if (a2 < 0.0)
  {
    NSLog((NSString *)@"WARNING: stroke width %f < 0.0", *(void *)&a2);
LABEL_8:
    *a4 = 0.0;
    double v11 = 0.0;
    goto LABEL_9;
  }
  if (a2 <= 0.0) {
    goto LABEL_8;
  }
  double v6 = a1->mTransformToDevice.c * a2 + a1->mTransformToDevice.a * a2;
  double v7 = a1->mTransformToDevice.d * a2 + a1->mTransformToDevice.b * a2;
  double v8 = fabs(v6);
  double v9 = floor(v8 + 0.00000011920929);
  if (v8 >= 1.0) {
    double v10 = v9;
  }
  else {
    double v10 = 1.0;
  }
  *a4 = v10;
  double v11 = v7 * a1->mTransformFromDevice.c + a1->mTransformFromDevice.a * v10;
LABEL_9:
  *a3 = v11;
}

CGFloat TSTLayoutSpaceGetAlignedFrameForGridRange(TSTLayoutSpace *a1, unint64_t a2, uint64_t a3)
{
  FrameForGridunint64_t Range = TSTLayoutSpaceGetFrameForGridRange(a1, a2, a3);

  return TSTLayoutSpaceGetAlignedRectForLayoutRect((double *)a1, FrameForGridRange, v5, v6, v7);
}

double TSTLayoutSpaceGetAlignedContentFrameForGridRange(TSTLayoutSpace *a1, unint64_t a2, unint64_t a3)
{
  long long v6 = 0u;
  memset(v5, 0, sizeof(v5));
  TSTLayoutSpaceGetFrameSpecForGridRange(a1, a2, a3, 0, 0, (double *)v5);
  TSTLayoutSpaceGetAlignFrameSpec(a1, (double *)v5);
  return *(double *)v5 + *(double *)&v6 * 0.5;
}

double TSTLayoutSpaceGetAlignedStrokeFrameForCellRange(TSTLayoutSpace *a1, unint64_t a2)
{
  unsigned int v2 = BYTE2(a2);
  if (BYTE2(a2) == 255) {
    unsigned int v2 = -1;
  }
  uint64_t v3 = WORD2(a2) + v2 - 1;
  if (!WORD2(a2)) {
    uint64_t v3 = 0xFFFFFFFFLL;
  }
  if ((unsigned __int16)a2 == 0xFFFF) {
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v4 = (unsigned __int16)a2;
  }
  unint64_t v5 = v2 | ((unint64_t)v4 << 32);
  uint64_t v6 = ((a2 >> 16) & 0xFFFF00000000) + (v4 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0) {
    uint64_t v6 = 0xFFFFFFFF00000000;
  }
  return TSTLayoutSpaceGetAlignedStrokeFrameForGridRange(a1, v5, v3 | v6);
}

double TSTLayoutSpaceGetAlignedStrokeLineForRowGridRange(TSTLayoutSpace *a1, unint64_t a2, unint64_t a3)
{
  long long v6 = 0u;
  memset(v5, 0, sizeof(v5));
  TSTLayoutSpaceGetFrameSpecForGridRange(a1, a2, a3, 1, 0, (double *)v5);
  TSTLayoutSpaceGetAlignFrameSpec(a1, (double *)v5);
  return *(double *)v5 - *(double *)&v6 * 0.5;
}

double TSTLayoutSpaceGetAlignedStrokeLineForColumnGridRange(TSTLayoutSpace *a1, unint64_t a2, unint64_t a3)
{
  long long v6 = 0u;
  memset(v5, 0, sizeof(v5));
  TSTLayoutSpaceGetFrameSpecForGridRange(a1, a2, a3, 2, 0, (double *)v5);
  TSTLayoutSpaceGetAlignFrameSpec(a1, (double *)v5);
  return *(double *)v5 - *(double *)&v6 * 0.5;
}

TSDBezierPath *TSTLayoutSpaceGetAlignedStrokeFramePathForGridRange(TSTLayoutSpace *a1, unint64_t a2, unint64_t a3, _OWORD *a4, int a5, CGFloat a6)
{
  unint64_t v67 = HIDWORD(a2);
  unint64_t v7 = a3;
  unint64_t v63 = HIDWORD(a3);
  if (a2 == -1
    || a3 == -1
    || a2 > a3
    || HIDWORD(a2) == -1
    || HIDWORD(a3) == -1)
  {
    unsigned int v65 = a3;
    unint64_t v66 = HIDWORD(a3);
  }
  else
  {
    unint64_t v66 = HIDWORD(a3);
    unsigned int v65 = a3;
    if (HIDWORD(a2) <= HIDWORD(a3))
    {
      unint64_t v8 = (a3 & 0xFFFFFFFF00000000) + 0x100000000;
      unsigned int v65 = a3 + 1;
      unint64_t v66 = HIDWORD(v8);
      unint64_t v7 = v8 & 0xFFFFFFFF00000000 | (a3 + 1);
    }
  }
  double v9 = malloc_type_malloc(0x10uLL, 0x1000040451B5BE8uLL);
  *double v9 = a2;
  v9[1] = v7;
  int v10 = 1;
  int v11 = 1;
  do
  {
    unsigned int v12 = v11 - 1;
    if ((v11 - 1) > 1)
    {
      if (a3 == a2) {
        break;
      }
    }
    else if (v63 == v67)
    {
      int v13 = 2;
      goto LABEL_45;
    }
    int v69 = v11;
    switch(v11)
    {
      case 3:
        CGRect v16 = [(TSTLayoutSpace *)a1 masterLayout];
        unsigned int v17 = v67;
        break;
      case 2:
        double v14 = [(TSTLayoutSpace *)a1 masterLayout];
        unsigned int v15 = v65;
        goto LABEL_20;
      case 1:
        double v14 = [(TSTLayoutSpace *)a1 masterLayout];
        unsigned int v15 = a2;
LABEL_20:
        MergedStrokesForGridColumn = TSTMasterLayoutGetMergedStrokesForGridColumn(v14, v15);
        unsigned int v19 = v66;
        unsigned int v20 = v67;
        goto LABEL_23;
      default:
        CGRect v16 = [(TSTLayoutSpace *)a1 masterLayout];
        unsigned int v17 = v66;
        break;
    }
    MergedStrokesForGridColumn = TSTMasterLayoutGetMergedStrokesForGridRow(v16, v17);
    unsigned int v19 = v65;
    unsigned int v20 = a2;
LABEL_23:
    unsigned int v21 = v20;
    v73[0] = 0;
    NextStroke = TSTStrokeRunArrayGetNextStroke((uint64_t)MergedStrokesForGridColumn, v20, v19, v73);
    if (NextStroke)
    {
      uint64_t v23 = NextStroke;
      double v24 = 0.0;
      unsigned int v25 = -1;
      uint64_t v71 = MergedStrokesForGridColumn;
      while (1)
      {
        [*((id *)v23 + 1) width];
        double v27 = v26;
        unsigned int v28 = v23[1] >= v19 ? v19 : v23[1];
        if (v25 != -1)
        {
          if (v26 == v24)
          {
            double v27 = v24;
            goto LABEL_43;
          }
          if (v10 >= 1) {
            break;
          }
        }
LABEL_43:
        uint64_t v23 = TSTStrokeRunArrayGetNextStroke((uint64_t)MergedStrokesForGridColumn, v21, v19, v73);
        unsigned int v25 = v28;
        double v24 = v27;
        if (!v23) {
          goto LABEL_44;
        }
      }
      uint64_t v29 = 0;
      uint64_t v30 = 0;
      while (1)
      {
        if (v12 > 1)
        {
          if (LODWORD(v9[v29]) >= v25 || v25 >= LODWORD(v9[v29 + 1])) {
            goto LABEL_41;
          }
          int v31 = v10 + 1;
          double v9 = malloc_type_realloc(v9, 16 * (v10 + 1), 0x1000040451B5BE8uLL);
          unint64_t v33 = &v9[2 * v10];
          _OWORD *v33 = *(_OWORD *)&v9[v29];
          LODWORD(v9[v29 + 1]) = v25;
        }
        else
        {
          if (HIDWORD(v9[v29]) >= v25 || v25 >= HIDWORD(v9[v29 + 1])) {
            goto LABEL_41;
          }
          int v31 = v10 + 1;
          double v9 = malloc_type_realloc(v9, 16 * (v10 + 1), 0x1000040451B5BE8uLL);
          double v32 = &v9[2 * v10];
          *double v32 = *(_OWORD *)&v9[v29];
          HIDWORD(v9[v29 + 1]) = v25;
          unint64_t v33 = (_OWORD *)((char *)v32 + 4);
        }
        int v10 = v31;
        *(_DWORD *)unint64_t v33 = v25;
LABEL_41:
        ++v30;
        v29 += 2;
        if (v30 >= v10)
        {
          MergedStrokesForGridColumn = v71;
          goto LABEL_43;
        }
      }
    }
LABEL_44:
    TSTStrokeRunArrayUnlock((uint64_t)MergedStrokesForGridColumn);
    int v13 = v69;
LABEL_45:
    int v11 = v13 + 1;
  }
  while (v13 < 4);
  if (v10 < 1)
  {
    uint64_t v59 = 0;
  }
  else
  {
    uint64_t v34 = 0;
    double v35 = 0;
    double v36 = *MEMORY[0x263F00148];
    do
    {
      double v37 = &v9[v34];
      uint64_t v38 = v9[v34];
      uint64_t v39 = v9[v34 + 1];
      BOOL v44 = v38 == -1
         || v39 == -1
         || v38 > v39
         || HIDWORD(v38) == -1
         || HIDWORD(v39) == -1
         || HIDWORD(v38) > HIDWORD(v39);
      unint64_t v45 = v9[v34];
      if (v44) {
        unint64_t v46 = v9[v34 + 1];
      }
      else {
        unint64_t v46 = (v39 & 0xFFFFFFFF00000000 | (v39 - 1)) - 0x100000000;
      }
      *double v37 = v38;
      v37[1] = v46;
      AlignedStrokeFrameForGridunint64_t Range = TSTLayoutSpaceGetAlignedStrokeFrameForGridRange(a1, v45, v46);
      double y = v48;
      double width = v50;
      double height = v52;
      if (a5)
      {
        if (!(v34 * 8)) {
          double v36 = TSTLayoutSpaceGetAlignedStrokeFrameForGridRange(a1, a2, a3);
        }
        AlignedStrokeFrameForGridunint64_t Range = TSDSubtractPoints(AlignedStrokeFrameForGridRange, y, v36);
        double y = v54;
      }
      if (a6 != 0.0)
      {
        v74.origin.CGFloat x = AlignedStrokeFrameForGridRange;
        v74.origin.double y = y;
        v74.size.double width = width;
        v74.size.double height = height;
        CGRect v75 = CGRectInset(v74, a6, a6);
        AlignedStrokeFrameForGridunint64_t Range = v75.origin.x;
        double y = v75.origin.y;
        double width = v75.size.width;
        double height = v75.size.height;
      }
      if (a4)
      {
        long long v55 = a4[1];
        *(_OWORD *)&v72.double a = *a4;
        *(_OWORD *)&v72.c = v55;
        *(_OWORD *)&v72.tCGFloat x = a4[2];
        double v56 = AlignedStrokeFrameForGridRange;
        *(double *)&long long v55 = y;
        double v57 = width;
        double v58 = height;
        CGRect v76 = CGRectApplyAffineTransform(*(CGRect *)((char *)&v55 - 8), &v72);
        AlignedStrokeFrameForGridunint64_t Range = v76.origin.x;
        double y = v76.origin.y;
        double width = v76.size.width;
        double height = v76.size.height;
      }
      uint64_t v59 = +[TSDBezierPath bezierPathWithRect:](TSDBezierPath, "bezierPathWithRect:", AlignedStrokeFrameForGridRange, y, width, height);
      if (v35) {
        uint64_t v59 = [(TSDBezierPath *)v35 uniteWithBezierPath:v59];
      }
      v34 += 2;
      double v35 = v59;
    }
    while (2 * v10 != v34);
  }
  free(v9);
  return v59;
}

TSDBezierPath *TSTLayoutSpaceGetAlignedStrokeFramePathForCellRange(TSTLayoutSpace *a1, unint64_t a2, _OWORD *a3, int a4, CGFloat a5)
{
  unsigned int v5 = BYTE2(a2);
  if (BYTE2(a2) == 255) {
    unsigned int v5 = -1;
  }
  uint64_t v6 = WORD2(a2) + v5 - 1;
  if (!WORD2(a2)) {
    uint64_t v6 = 0xFFFFFFFFLL;
  }
  if ((unsigned __int16)a2 == 0xFFFF) {
    uint64_t v7 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v7 = (unsigned __int16)a2;
  }
  unint64_t v8 = v5 | ((unint64_t)v7 << 32);
  uint64_t v9 = ((a2 >> 16) & 0xFFFF00000000) + (v7 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0) {
    uint64_t v9 = 0xFFFFFFFF00000000;
  }
  return TSTLayoutSpaceGetAlignedStrokeFramePathForGridRange(a1, v8, v6 | v9, a3, a4, a5);
}

uint64_t TSTLayoutSpaceGetAlignedMaskStrokeFramePathForGridRange(TSTLayoutSpace *a1, long long *a2)
{
  int v4 = [(TSTLayoutSpace *)a1 layoutSpaceType];
  Visibleunint64_t Range = TSTLayoutSpaceGetVisibleRange(a1);
  uint64_t v6 = 0;
  if ((_WORD)VisibleRange != 0xFFFF && (VisibleRange & 0xFF0000) != 0xFF0000)
  {
    uint64_t v6 = 0;
    if (HIWORD(VisibleRange))
    {
      if ((VisibleRange & 0xFFFF00000000) != 0)
      {
        if (BYTE2(VisibleRange) == 255) {
          uint64_t v7 = 0xFFFFFFFFLL;
        }
        else {
          uint64_t v7 = BYTE2(VisibleRange);
        }
        if (WORD2(VisibleRange)) {
          uint64_t v8 = WORD2(VisibleRange) + v7 - 1;
        }
        else {
          uint64_t v8 = 0xFFFFFFFFLL;
        }
        uint64_t v9 = (unsigned __int16)VisibleRange;
        if (((VisibleRange >> 16) & 0xFFFF00000000) != 0) {
          unint64_t v10 = ((VisibleRange >> 16) & 0xFFFF00000000)
        }
              + ((unint64_t)(unsigned __int16)VisibleRange << 32)
              - 0x100000000;
        else {
          unint64_t v10 = 0xFFFFFFFF00000000;
        }
        AlignedStrokeFramePathForGridunint64_t Range = TSTLayoutSpaceGetAlignedStrokeFramePathForGridRange(a1, v7 | ((unint64_t)(unsigned __int16)VisibleRange << 32), v8 | v10, a2, 0, 0.0);
        switch(v4)
        {
          case 3:
            v47.origin.CGFloat x = TSTLayoutSpaceGetAlignedOverrideFrameForGridRange(a1, v10 | v7, v8 | v10, 0.0);
            CGFloat x = v47.origin.x;
            CGFloat y = v47.origin.y;
            CGFloat width = v47.size.width;
            CGFloat height = v47.size.height;
            double MaxX = CGRectGetMaxX(v47);
            v48.origin.CGFloat x = x;
            v48.origin.CGFloat y = y;
            v48.size.CGFloat width = width;
            v48.size.CGFloat height = height;
            CGRectGetMaxY(v48);
            double v17 = TSDRectWithPoints(-100000.0, -100000.0, MaxX);
            double v19 = v28 + 100000.0;
            long long v29 = a2[1];
            long long v38 = *a2;
            long long v39 = v29;
            long long v40 = a2[2];
            double v22 = (CGAffineTransform *)&v38;
            break;
          case 2:
            v49.origin.CGFloat x = TSTLayoutSpaceGetAlignedOverrideFrameForGridRange(a1, v8 | (v9 << 32), v8 | v10, 0.0);
            CGFloat v30 = v49.origin.x;
            CGFloat v31 = v49.origin.y;
            CGFloat v32 = v49.size.width;
            CGFloat v33 = v49.size.height;
            double v34 = CGRectGetMaxX(v49);
            v50.origin.CGFloat x = v30;
            v50.origin.CGFloat y = v31;
            v50.size.CGFloat width = v32;
            v50.size.CGFloat height = v33;
            CGRectGetMaxY(v50);
            double v17 = TSDRectWithPoints(-100000.0, -100000.0, v34);
            double v20 = v35 + 100000.0;
            long long v36 = a2[1];
            *(_OWORD *)&v41.double a = *a2;
            *(_OWORD *)&v41.c = v36;
            *(_OWORD *)&v41.tCGFloat x = a2[2];
            double v22 = &v41;
            break;
          case 1:
            v45.origin.CGFloat x = TSTLayoutSpaceGetAlignedOverrideFrameForGridRange(a1, v8 | v10, v8 | v10, 0.0);
            CGFloat v12 = v45.origin.x;
            CGFloat v13 = v45.origin.y;
            CGFloat v14 = v45.size.width;
            CGFloat v15 = v45.size.height;
            double v16 = CGRectGetMaxX(v45);
            v46.origin.CGFloat x = v12;
            v46.origin.CGFloat y = v13;
            v46.size.CGFloat width = v14;
            v46.size.CGFloat height = v15;
            CGRectGetMaxY(v46);
            double v17 = TSDRectWithPoints(-100000.0, -100000.0, v16);
            long long v21 = a2[1];
            long long v42 = *a2;
            long long v43 = v21;
            long long v44 = a2[2];
            double v22 = (CGAffineTransform *)&v42;
            break;
          default:
            CGRect v51 = *(CGRect *)*(void *)&MEMORY[0x263F001A8];
            return (uint64_t)-[TSDBezierPath uniteWithBezierPath:](AlignedStrokeFramePathForGridRange, "uniteWithBezierPath:", +[TSDBezierPath bezierPathWithRect:](TSDBezierPath, "bezierPathWithRect:", v51.origin.x, v51.origin.y, v51.size.width, v51.size.height, v38, v39, v40, *(void *)&v41.a, *(void *)&v41.b, *(void *)&v41.c, *(void *)&v41.d, *(void *)&v41.tx, *(void *)&v41.ty, v42,
                                v43,
                                v44));
        }
        CGRect v51 = CGRectApplyAffineTransform(*(CGRect *)&v17, v22);
        return (uint64_t)-[TSDBezierPath uniteWithBezierPath:](AlignedStrokeFramePathForGridRange, "uniteWithBezierPath:", +[TSDBezierPath bezierPathWithRect:](TSDBezierPath, "bezierPathWithRect:", v51.origin.x, v51.origin.y, v51.size.width, v51.size.height, v38, v39, v40, *(void *)&v41.a, *(void *)&v41.b, *(void *)&v41.c, *(void *)&v41.d, *(void *)&v41.tx, *(void *)&v41.ty, v42,
                            v43,
                            v44));
      }
    }
  }
  return v6;
}

double TSTLayoutSpaceGetAlignedOverrideFrameForGridRange(TSTLayoutSpace *a1, unint64_t a2, unint64_t a3, double a4)
{
  double v8 = a4;
  *(_OWORD *)uint64_t v7 = 0u;
  memset(v6, 0, sizeof(v6));
  TSTLayoutSpaceGetFrameSpecForGridRange(a1, a2, a3, 0, &v8, (double *)v6);
  TSTLayoutSpaceGetAlignFrameSpec(a1, (double *)v6);
  return *(double *)v6 - v7[0] * 0.5;
}

TSDBezierPath *TSTLayoutSpaceGetAlignedStrokeLinePathForRowGridRange(TSTLayoutSpace *a1, uint64_t a2, unint64_t a3, _OWORD *a4, int a5, CGFloat a6)
{
  uint64_t v9 = a2;
  MergedStrokesForGridRow = TSTMasterLayoutGetMergedStrokesForGridRow([(TSTLayoutSpace *)a1 masterLayout], HIDWORD(a2));
  unsigned int v11 = a3 + 1;
  double v12 = *MEMORY[0x263F00148];
  v50[0] = 0;
  uint64_t v45 = (uint64_t)MergedStrokesForGridRow;
  NextStroke = TSTStrokeRunArrayGetNextStroke((uint64_t)MergedStrokesForGridRow, v9, (int)a3 + 1, v50);
  if (NextStroke)
  {
    CGFloat v14 = NextStroke;
    CGFloat v15 = 0;
    unint64_t v46 = v9 & 0xFFFFFFFF00000000;
    double v16 = -1.0;
    char v17 = 1;
    LODWORD(v18) = v9;
    unsigned int v44 = v9;
    do
    {
      [*((id *)v14 + 1) width];
      double v20 = v19;
      unsigned int v21 = v14[1];
      if (*v14 > v9) {
        LODWORD(v9) = *v14;
      }
      if (v21 >= v11) {
        unsigned int v22 = v11;
      }
      else {
        unsigned int v22 = v14[1];
      }
      uint64_t v23 = v22 - 1;
      double v24 = v15;
      while (1)
      {
        unint64_t v25 = v16 == v20 ? a3 & 0xFFFFFFFF00000000 | v23 : a3;
        a3 = v16 < 0.0 ? a3 & 0xFFFFFFFF00000000 | v23 : v25;
        uint64_t v18 = v16 < 0.0 ? v9 : v18;
        double v26 = v16 < 0.0 ? v20 : v16;
        if (v26 == v20 && v11 > v21) {
          break;
        }
        AlignedStrokeLineForRowGridunint64_t Range = TSTLayoutSpaceGetAlignedStrokeLineForRowGridRange(a1, v46 | v18, a3);
        double v31 = v30;
        double v33 = v32;
        if (a5)
        {
          if (v17) {
            double v12 = AlignedStrokeLineForRowGridRange;
          }
          AlignedStrokeLineForRowGridunint64_t Range = TSDSubtractPoints(AlignedStrokeLineForRowGridRange, v29, v12);
          char v17 = 0;
        }
        if (a6 != 0.0)
        {
          double v34 = v31;
          double v35 = v33;
          *(CGRect *)&AlignedStrokeLineForRowGridunint64_t Range = CGRectInset(*(CGRect *)&AlignedStrokeLineForRowGridRange, a6, a6);
          double v31 = v36;
          double v33 = v37;
        }
        if (a4)
        {
          long long v38 = a4[1];
          *(_OWORD *)&v49.double a = *a4;
          *(_OWORD *)&v49.c = v38;
          *(_OWORD *)&v49.tCGFloat x = a4[2];
          double v39 = v31;
          *(double *)&long long v38 = v33;
          *(CGRect *)&AlignedStrokeLineForRowGridunint64_t Range = CGRectApplyAffineTransform(*(CGRect *)&AlignedStrokeLineForRowGridRange, &v49);
          double v31 = v40;
          double v33 = v41;
        }
        long long v42 = +[TSDBezierPath bezierPathWithRect:](TSDBezierPath, "bezierPathWithRect:", AlignedStrokeLineForRowGridRange, v29, v31, v33);
        CGFloat v15 = v42;
        if (v24)
        {
          double v24 = [(TSDBezierPath *)v24 uniteWithBezierPath:v42];
          double v16 = -1.0;
          CGFloat v15 = v24;
          if (v26 == v20) {
            goto LABEL_39;
          }
        }
        else
        {
          double v16 = -1.0;
          double v24 = v42;
          if (v26 == v20) {
            goto LABEL_39;
          }
        }
      }
      CGFloat v15 = v24;
      double v16 = v26;
LABEL_39:
      LODWORD(v9) = v44;
      CGFloat v14 = TSTStrokeRunArrayGetNextStroke(v45, v44, v11, v50);
    }
    while (v14);
  }
  else
  {
    CGFloat v15 = 0;
  }
  TSTStrokeRunArrayUnlock(v45);
  return v15;
}

TSDBezierPath *TSTLayoutSpaceGetAlignedStrokeLinePathForColumnGridRange(TSTLayoutSpace *a1, unint64_t a2, unint64_t a3, _OWORD *a4, int a5, CGFloat a6)
{
  unint64_t v8 = a3;
  unsigned int v9 = a2;
  unint64_t v10 = HIDWORD(a2);
  unint64_t v11 = HIDWORD(a3);
  MergedStrokesForGridColumn = TSTMasterLayoutGetMergedStrokesForGridColumn([(TSTLayoutSpace *)a1 masterLayout], a2);
  unsigned int v13 = v11 + 1;
  double v14 = *MEMORY[0x263F00148];
  v52[0] = 0;
  uint64_t v47 = (uint64_t)MergedStrokesForGridColumn;
  NextStroke = TSTStrokeRunArrayGetNextStroke((uint64_t)MergedStrokesForGridColumn, v10, (int)v11 + 1, v52);
  if (NextStroke)
  {
    double v16 = NextStroke;
    char v17 = 0;
    uint64_t v48 = v9;
    double v18 = -1.0;
    char v19 = 1;
    LODWORD(v20) = v10;
    unsigned int v46 = v10;
    do
    {
      [*((id *)v16 + 1) width];
      double v22 = v21;
      unsigned int v23 = v16[1];
      if (*v16 > v10) {
        LODWORD(v10) = *v16;
      }
      if (v23 >= v13) {
        unsigned int v24 = v13;
      }
      else {
        unsigned int v24 = v16[1];
      }
      unint64_t v25 = (unint64_t)(v24 - 1) << 32;
      double v26 = v17;
      while (1)
      {
        unint64_t v27 = v18 == v22 ? v8 | v25 : v8;
        unint64_t v8 = v18 < 0.0 ? v8 | v25 : v27;
        uint64_t v20 = v18 < 0.0 ? v10 : v20;
        double v28 = v18 < 0.0 ? v22 : v18;
        if (v28 == v22 && v13 > v23) {
          break;
        }
        AlignedStrokeLineForColumnGridunint64_t Range = TSTLayoutSpaceGetAlignedStrokeLineForColumnGridRange(a1, v48 | (v20 << 32), v8);
        double v33 = v32;
        double v35 = v34;
        if (a5)
        {
          if (v19) {
            double v14 = AlignedStrokeLineForColumnGridRange;
          }
          AlignedStrokeLineForColumnGridunint64_t Range = TSDSubtractPoints(AlignedStrokeLineForColumnGridRange, v31, v14);
          char v19 = 0;
        }
        if (a6 != 0.0)
        {
          double v36 = v33;
          double v37 = v35;
          *(CGRect *)&AlignedStrokeLineForColumnGridunint64_t Range = CGRectInset(*(CGRect *)&AlignedStrokeLineForColumnGridRange, a6, a6);
          double v33 = v38;
          double v35 = v39;
        }
        if (a4)
        {
          long long v40 = a4[1];
          *(_OWORD *)&v51.double a = *a4;
          *(_OWORD *)&v51.c = v40;
          *(_OWORD *)&v51.tCGFloat x = a4[2];
          double v41 = v33;
          *(double *)&long long v40 = v35;
          *(CGRect *)&AlignedStrokeLineForColumnGridunint64_t Range = CGRectApplyAffineTransform(*(CGRect *)&AlignedStrokeLineForColumnGridRange, &v51);
          double v33 = v42;
          double v35 = v43;
        }
        unsigned int v44 = +[TSDBezierPath bezierPathWithRect:](TSDBezierPath, "bezierPathWithRect:", AlignedStrokeLineForColumnGridRange, v31, v33, v35);
        char v17 = v44;
        if (v26)
        {
          double v26 = [(TSDBezierPath *)v26 uniteWithBezierPath:v44];
          double v18 = -1.0;
          char v17 = v26;
          if (v28 == v22) {
            goto LABEL_39;
          }
        }
        else
        {
          double v18 = -1.0;
          double v26 = v44;
          if (v28 == v22) {
            goto LABEL_39;
          }
        }
      }
      char v17 = v26;
      double v18 = v28;
LABEL_39:
      LODWORD(v10) = v46;
      double v16 = TSTStrokeRunArrayGetNextStroke(v47, v46, v13, v52);
    }
    while (v16);
  }
  else
  {
    char v17 = 0;
  }
  TSTStrokeRunArrayUnlock(v47);
  return v17;
}

CGFloat TSTLayoutSpaceGetAlignedFrame(uint64_t a1)
{
  if (!CGRectIsEmpty(*(CGRect *)(a1 + 336))) {
    return *(double *)(a1 + 336);
  }
  CGFloat result = TSTLayoutSpaceGetAlignedFrameForGridRange((TSTLayoutSpace *)a1, *(void *)(a1 + 24), *(void *)(a1 + 32));
  *(CGFloat *)(a1 + 336) = result;
  *(void *)(a1 + 344) = v3;
  *(void *)(a1 + 352) = v4;
  *(void *)(a1 + 360) = v5;
  return result;
}

double TSTLayoutSpaceGetAlignedStrokeFrame(uint64_t a1)
{
  if (!CGRectIsEmpty(*(CGRect *)(a1 + 400))) {
    return *(double *)(a1 + 400);
  }
  double result = TSTLayoutSpaceGetAlignedStrokeFrameForGridRange((TSTLayoutSpace *)a1, *(void *)(a1 + 24), *(void *)(a1 + 32));
  *(double *)(a1 + 400) = result;
  *(void *)(a1 + 408) = v3;
  *(void *)(a1 + 416) = v4;
  *(void *)(a1 + 424) = v5;
  return result;
}

void TSTLayoutSpaceDrawSingleStroke(void *a1, CGContext *a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6, double a7, double a8, double a9, double a10, CGFloat a11, CGFloat a12, CGFloat a13, CGFloat a14)
{
  char v26 = [a1 empty];
  if (a7 <= 0.0 || (v26 & 1) != 0) {
    return;
  }
  id v48 = (id)[a1 mutableCopy];
  [v48 setWidth:a7];
  int v27 = [a1 solid];
  int v28 = [a1 dontClearBackground];
  if (a8 < 1.0)
  {
    double rect = a6;
    objc_msgSend((id)objc_msgSend(a1, "color"), "alphaComponent");
    double v30 = v29;
    double v31 = (void *)[a1 color];
    double v32 = 1.0 - a8;
    if (v30 >= 1.0) {
      uint64_t v33 = [MEMORY[0x263F7C808] whiteColor];
    }
    else {
      uint64_t v33 = [MEMORY[0x263F7C808] clearColor];
    }
    objc_msgSend(v48, "setColor:", (id)objc_msgSend(v31, "newBlendedColorWithFraction:ofColor:", v33, v32));
    a6 = rect;
  }
  if ((v27 ^ 1 | v28) == 1)
  {
    CGContextSaveGState(a2);
    if (v27)
    {
      if (!v28) {
        goto LABEL_19;
      }
    }
    else
    {
      double v35 = a7 * 0.5;
      if (a3 == a5)
      {
        double v36 = a3 - v35;
        v50.origin.CGFloat x = a11;
        v50.origin.CGFloat y = a12;
        v50.size.CGFloat width = a13;
        v50.size.CGFloat height = a14;
        CGFloat MinY = CGRectGetMinY(v50);
        double v38 = v36;
        double v39 = a4;
        double v40 = a7;
        a7 = a6 - a4;
        a4 = MinY;
      }
      else
      {
        double recta = a4 - v35;
        double v40 = a5 - a3;
        v51.origin.CGFloat x = a11;
        v51.origin.CGFloat y = a12;
        v51.size.CGFloat width = a13;
        v51.size.CGFloat height = a14;
        CGFloat MinX = CGRectGetMinX(v51);
        double v39 = recta;
        double v38 = a3;
        a3 = MinX;
      }
      double v42 = v38;
      double v43 = v40;
      double v44 = a7;
      CGContextClipToRect(a2, *(CGRect *)(&v39 - 1));
      if (!v28) {
        goto LABEL_19;
      }
    }
    CGContextSetBlendMode(a2, kCGBlendModeNormal);
LABEL_19:
    Mutable = CGPathCreateMutable();
    CGPathMoveToPoint(Mutable, 0, a3, a4);
    CGPathAddLineToPoint(Mutable, 0, a5, a6);
    [v48 paintPath:Mutable inContext:a2];
    CGPathRelease(Mutable);
    CGContextRestoreGState(a2);
    goto LABEL_20;
  }
  double v34 = CGPathCreateMutable();
  CGPathMoveToPoint(v34, 0, a3, a4);
  CGPathAddLineToPoint(v34, 0, a5, a6);
  [v48 paintPath:v34 inContext:a2];
  CGPathRelease(v34);
LABEL_20:
}

void TSTLayoutSpaceDrawStrokes(TSTLayoutSpace *a1, uint64_t a2, uint64_t a3, int a4, CGContext *a5)
{
  unsigned int v9 = [(TSTLayoutSpace *)a1 masterLayout];
  CGContextSaveGState(a5);
  c = a5;
  CGContextSetBlendMode(a5, kCGBlendModeCopy);
  p_mGridunint64_t Range = ($FC6C44E672DFCBD714A302CF0DF56F45 *)&TSTGridRangeEmpty;
  if (a1) {
    p_mGridunint64_t Range = &a1->mGridRange;
  }
  $3C36844D3994842D9102894F8152D7DE topLeft = p_mGridRange->topLeft;
  unint64_t bottomRight = (unint64_t)p_mGridRange->bottomRight;
  if (topLeft.column != -1
    && bottomRight != -1
    && topLeft.column <= bottomRight
    && topLeft.row != -1
    && HIDWORD(bottomRight) != -1
    && topLeft.row <= HIDWORD(bottomRight))
  {
    unint64_t bottomRight = (bottomRight & 0xFFFFFFFF00000000 | (bottomRight + 1)) + 0x100000000;
  }
  uint64_t v18 = -1;
  if (a2 == -1 || a3 == -1)
  {
    uint64_t v19 = -1;
  }
  else
  {
    uint64_t v19 = -1;
    if (a2 <= a3
      && HIDWORD(a2) != -1
      && HIDWORD(a3) != -1
      && HIDWORD(a2) <= HIDWORD(a3)
      && topLeft.column != -1
      && bottomRight != -1
      && topLeft.column <= bottomRight)
    {
      unint64_t v20 = HIDWORD(*(unint64_t *)&topLeft);
      if (topLeft.row != -1)
      {
        unint64_t v21 = HIDWORD(bottomRight);
        if (HIDWORD(bottomRight) != -1 && topLeft.row <= HIDWORD(bottomRight))
        {
          $3C36844D3994842D9102894F8152D7DE topLeft = a2 <= topLeft.column
                  ? ($3C36844D3994842D9102894F8152D7DE)topLeft.column
                  : ($3C36844D3994842D9102894F8152D7DE)a2;
          unint64_t bottomRight = a3 >= bottomRight ? bottomRight : a3;
          if (topLeft.column <= bottomRight)
          {
            unint64_t v22 = HIDWORD(a3) >= v21 ? v21 : HIDWORD(a3);
            uint64_t v23 = HIDWORD(a2) <= v20 ? v20 : HIDWORD(a2);
            if (v23 <= v22)
            {
              uint64_t v19 = bottomRight | (v22 << 32);
              uint64_t v18 = *(void *)&topLeft | (v23 << 32);
            }
          }
        }
      }
    }
  }
  unint64_t v52 = v18;
  unint64_t Range = TSTMasterLayoutGetRange((uint64_t)[(TSTLayoutSpace *)a1 masterLayout]);
  unint64_t v25 = Range;
  if (BYTE2(Range) == 255) {
    unsigned int v26 = -1;
  }
  else {
    unsigned int v26 = BYTE2(Range);
  }
  if (WORD2(Range)) {
    int v27 = WORD2(Range) + v26 - 1;
  }
  else {
    int v27 = -1;
  }
  if ((unsigned __int16)Range == 0xFFFF) {
    unsigned int v28 = -1;
  }
  else {
    unsigned int v28 = (unsigned __int16)Range;
  }
  unint64_t v50 = (unint64_t)((HIDWORD(Range) << 16) - 0x100000000) >> 32;
  if (TSTMasterLayoutIsColumnHidden(v9, v26)) {
    uint64_t v29 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v29 = v26;
  }
  int PartitionFirstBodyColumn = TSTLayoutGetPartitionFirstBodyColumn([(TSTLayoutSpace *)a1 layout]);
  if (!TSTMasterLayoutGetTableNumberOfHeaderColumns((unsigned __int16 *)v9)
    || TSTMasterLayoutIsColumnHidden(v9, PartitionFirstBodyColumn))
  {
    int PartitionFirstBodyColumn = -1;
  }
  if (TSTMasterLayoutIsColumnHidden(v9, v27)) {
    int v31 = -1;
  }
  else {
    int v31 = PartitionFirstBodyColumn;
  }
  unsigned int v47 = v31;
  if (TSTMasterLayoutIsRowHidden(v9, (unsigned __int16)v28)) {
    uint64_t v32 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v32 = v28;
  }
  int PartitionFirstBodyRow = TSTLayoutGetPartitionFirstBodyRow([(TSTLayoutSpace *)a1 layout]);
  if (!TSTMasterLayoutGetTableNumberOfHeaderRows((unsigned __int16 *)v9)
    || TSTMasterLayoutIsRowHidden(v9, (unsigned __int16)PartitionFirstBodyRow))
  {
    int PartitionFirstBodyRow = -1;
  }
  unsigned int v48 = PartitionFirstBodyRow;
  uint64_t v34 = HIDWORD(v52);
  int v35 = v28 + v50;
  unsigned int PartitionLastBodyRow = TSTLayoutGetPartitionLastBodyRow([(TSTLayoutSpace *)a1 layout]);
  if (!TSTMasterLayoutGetTableNumberOfFooterRows((unsigned __int16 *)v9)
    || !TSTMasterLayoutGetTableNumberOfNonHiddenFooterRows(v9)
    || TSTMasterLayoutIsRowHidden(v9, (unsigned __int16)(PartitionLastBodyRow + 1)))
  {
    unsigned int PartitionLastBodyRow = -1;
  }
  uint64_t v36 = (v27 + 1);
  if (HIWORD(v25)) {
    int v37 = v35;
  }
  else {
    int v37 = -1;
  }
  if (TSTMasterLayoutIsRowHidden(v9, (unsigned __int16)v37)) {
    uint64_t v38 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v38 = (v37 + 1);
  }
  if (v52 <= v19)
  {
    char v39 = 0;
    char v44 = 0;
    char v51 = 0;
    uint64_t v40 = v52;
    do
    {
      if (v29 == v40)
      {
        char v39 = 1;
      }
      else if (v36 == v40)
      {
        char v51 = 1;
      }
      else if (v47 == v40)
      {
        char v44 = 1;
      }
      else
      {
        TSTLayoutSpaceDrawColumnStroke(a1, v40, v52, v19, a4, c, 0);
      }
      uint64_t v40 = (v40 + 1);
    }
    while (v40 <= v19);
  }
  else
  {
    char v51 = 0;
    char v44 = 0;
    char v39 = 0;
  }
  if (HIDWORD(v52) <= HIDWORD(v19))
  {
    char v42 = 0;
    char v41 = 0;
    char v43 = 0;
    char v49 = 0;
    do
    {
      if (v32 == v34)
      {
        char v42 = 1;
      }
      else if (v38 == v34)
      {
        char v49 = 1;
      }
      else if (v48 == v34)
      {
        char v41 = 1;
      }
      else if (PartitionLastBodyRow == v34)
      {
        char v43 = 1;
      }
      else
      {
        TSTLayoutSpaceDrawRowStroke(a1, v34, v52, v19, a4, c, 0);
      }
      uint64_t v34 = (v34 + 1);
    }
    while (v34 <= HIDWORD(v19));
  }
  else
  {
    char v49 = 0;
    char v43 = 0;
    char v41 = 0;
    char v42 = 0;
  }
  if (v44) {
    TSTLayoutSpaceDrawColumnStroke(a1, v47, v52, v19, a4, c, [(TSTLayoutSpace *)a1 layoutSpaceType] - 1 < 2);
  }
  if (v41) {
    TSTLayoutSpaceDrawRowStroke(a1, v48, v52, v19, a4, c, ([(TSTLayoutSpace *)a1 layoutSpaceType] & 0xFFFFFFFD) == 1);
  }
  if (v43) {
    TSTLayoutSpaceDrawRowStroke(a1, PartitionLastBodyRow, v52, v19, a4, c, 0);
  }
  if (v39) {
    TSTLayoutSpaceDrawColumnStroke(a1, v29, v52, v19, a4, c, 0);
  }
  if (v51) {
    TSTLayoutSpaceDrawColumnStroke(a1, v36, v52, v19, a4, c, 0);
  }
  if (v42) {
    TSTLayoutSpaceDrawRowStroke(a1, v32, v52, v19, a4, c, 0);
  }
  if (v49) {
    TSTLayoutSpaceDrawRowStroke(a1, v38, v52, v19, a4, c, 0);
  }

  CGContextRestoreGState(c);
}

uint64_t TSTLayoutSpaceDrawColumnStroke(TSTLayoutSpace *a1, uint64_t a2, unint64_t a3, unint64_t a4, int a5, CGContext *a6, int a7)
{
  unsigned int v13 = [(TSTLayoutSpace *)a1 masterLayout];
  if ([(TSTLayoutSpace *)a1 drawPreventAntialias]) {
    AlignedStrokedouble Frame = TSTLayoutSpaceGetAlignedStrokeFrame((uint64_t)a1);
  }
  else {
    AlignedStrokedouble Frame = TSTLayoutSpaceGetStrokeFrame((uint64_t)a1);
  }
  CGFloat v62 = v15;
  CGFloat v63 = AlignedStrokeFrame;
  CGFloat v60 = v17;
  double v61 = v16;
  v88.CGFloat x = TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, a2);
  v88.CGFloat y = 0.0;
  double LayoutPointForTablePoint = TSTLayoutSpaceGetLayoutPointForTablePoint(a1, v88);
  uint64_t result = TSTMasterLayoutIsGridColumnHidden(v13, a2);
  if ((result & 1) == 0)
  {
    unint64_t v20 = HIDWORD(a3);
    unint64_t v21 = HIDWORD(a4);
    CGRect v76 = v13;
    MergedStrokesForGridColumn = TSTMasterLayoutGetMergedStrokesForGridColumn(v13, a2);
    v87[0] = 0;
    NextStroke = TSTStrokeRunArrayGetNextStroke((uint64_t)MergedStrokesForGridColumn, v20, HIDWORD(a4), v87);
    if (NextStroke)
    {
      unsigned int v24 = NextStroke;
      if (a2) {
        unsigned int v25 = a2 - 1;
      }
      else {
        unsigned int v25 = 0;
      }
      unsigned int v74 = a2 + 1;
      unsigned int v75 = v25;
      unsigned int v65 = MergedStrokesForGridColumn;
      int v64 = a7;
      while (1)
      {
        unsigned int v26 = (void *)*((void *)v24 + 1);
        [v26 width];
        double v28 = v27;
        CGFloat v86 = v27;
        unsigned int v29 = v24[1];
        uint64_t v30 = *v24 <= v20 ? v20 : *v24;
        uint64_t v31 = v29 >= v21 ? v21 : v29;
        v89.CGFloat y = TSTLayoutSpaceGetTableCoordinateForGridRow(a1, v30);
        v89.CGFloat x = 0.0;
        TSTLayoutSpaceGetLayoutPointForTablePoint(a1, v89);
        double v33 = v32;
        CGFloat v84 = LayoutPointForTablePoint;
        double v85 = v32;
        v90.CGFloat y = TSTLayoutSpaceGetTableCoordinateForGridRow(a1, v31);
        v90.CGFloat x = 0.0;
        double v34 = TSTLayoutSpaceGetLayoutPointForTablePoint(a1, v90);
        double v36 = v35;
        v83.CGFloat x = LayoutPointForTablePoint;
        v83.CGFloat y = v35;
        char v37 = objc_msgSend(v26, "empty", v34);
        char v38 = a7 ? 0 : v37;
        if ((v38 & 1) == 0 && v33 != v36) {
          break;
        }
LABEL_61:
        unsigned int v24 = TSTStrokeRunArrayGetNextStroke((uint64_t)MergedStrokesForGridColumn, v20, v21, v87);
        if (!v24) {
          return TSTStrokeRunArrayUnlock((uint64_t)MergedStrokesForGridColumn);
        }
      }
      double v78 = v28;
      if ([(TSTLayoutSpace *)a1 drawBlackAndWhite])
      {
        char v39 = (void *)[v26 mutableCopy];
        objc_msgSend(v39, "setColor:", objc_msgSend(MEMORY[0x263F7C808], "blackColor"));
      }
      else
      {
        if (([v26 solid] & 1) != 0 || -[TSTMasterLayout tableEnvironment](v76, "tableEnvironment") != 1)
        {
          char v39 = 0;
          goto LABEL_28;
        }
        char v39 = (void *)[v26 mutableCopy];
        double v28 = 1.0;
        [v39 setWidth:1.0];
        CGFloat v86 = 1.0;
      }
      unsigned int v26 = v39;
LABEL_28:
      double v81 = 0.0;
      double v82 = 0.0;
      TSTLayoutSpaceAlignStrokeWidth(a1, v28, &v82, &v81);
      uint64_t v40 = (double *)MEMORY[0x263F001B0];
      v93.origin.CGFloat x = TSDRectWithOriginAndSize(v41, LayoutPointForTablePoint, v33, *MEMORY[0x263F001B0], *(double *)(MEMORY[0x263F001B0] + 8));
      CGFloat v42 = -v81;
      CGRect v94 = CGRectInset(v93, -v81, -v81);
      CGFloat x = v94.origin.x;
      CGFloat width = v94.size.width;
      CGFloat y = v94.origin.y;
      recCGAffineTransform t2 = v94.size.height;
      double v77 = v36;
      v95.origin.CGFloat x = TSDRectWithOriginAndSize(v44, LayoutPointForTablePoint, v36, *v40, v40[1]);
      CGRect v96 = CGRectInset(v95, v42, v42);
      CGFloat v72 = v96.origin.y;
      CGFloat v73 = v96.origin.x;
      CGFloat height = v96.size.height;
      CGFloat v71 = v96.size.width;
      ClipBoundingBoCGFloat x = CGContextGetClipBoundingBox(a6);
      CGFloat v45 = ClipBoundingBox.origin.x;
      CGFloat v46 = ClipBoundingBox.origin.y;
      CGFloat v47 = ClipBoundingBox.size.width;
      CGFloat v48 = ClipBoundingBox.size.height;
      v91.CGFloat x = LayoutPointForTablePoint;
      v91.CGFloat y = v33;
      if (CGRectContainsPoint(ClipBoundingBox, v91)) {
        goto LABEL_30;
      }
      v98.origin.CGFloat x = v45;
      v98.origin.CGFloat y = v46;
      v98.size.CGFloat width = v47;
      v98.size.CGFloat height = v48;
      v101.origin.CGFloat x = x;
      v101.size.CGFloat width = width;
      v101.origin.CGFloat y = y;
      v101.size.CGFloat height = rect2;
      double v49 = 0.0;
      if (CGRectIntersectsRect(v98, v101)) {
LABEL_30:
      }
        double v49 = TSTMasterLayoutStrokeHeightOfGridRow(v76, v30, v75, v74);
      v99.origin.CGFloat x = v45;
      v99.origin.CGFloat y = v46;
      v99.size.CGFloat width = v47;
      v99.size.CGFloat height = v48;
      v92.CGFloat x = LayoutPointForTablePoint;
      v92.CGFloat y = v77;
      if (CGRectContainsPoint(v99, v92)) {
        goto LABEL_33;
      }
      v100.origin.CGFloat x = v45;
      v100.origin.CGFloat y = v46;
      v100.size.CGFloat width = v47;
      v100.size.CGFloat height = v48;
      v102.origin.CGFloat y = v72;
      v102.origin.CGFloat x = v73;
      v102.size.CGFloat height = height;
      v102.size.CGFloat width = v71;
      double v50 = 0.0;
      if (CGRectIntersectsRect(v100, v102)) {
LABEL_33:
      }
        double v50 = TSTMasterLayoutStrokeHeightOfGridRow(v76, v31, v75, v74);
      a7 = v64;
      if (v49 > 0.0 && ((*((unsigned __int8 *)v24 + 24) >> 2) & 3u) - 1 <= 1)
      {
        double v80 = 0.0;
        TSTLayoutSpaceAlignStrokeWidth(a1, v49, &v80, &v79);
        int v51 = (*((unsigned __int8 *)v24 + 24) >> 2) & 3;
        if (v51 == 2)
        {
          double v52 = v80;
          double v53 = 0.5;
          goto LABEL_40;
        }
        if (v51 == 1)
        {
          double v52 = v80;
          double v53 = -0.5;
LABEL_40:
          double v85 = v33 + v52 * v53;
        }
      }
      if (v50 <= 0.0 || ((*((unsigned __int8 *)v24 + 24) >> 4) & 3u) - 1 > 1) {
        goto LABEL_48;
      }
      double v80 = 0.0;
      TSTLayoutSpaceAlignStrokeWidth(a1, v50, &v80, &v79);
      int v54 = (*((unsigned __int8 *)v24 + 24) >> 4) & 3;
      if (v54 == 2)
      {
        double v55 = v80;
        double v56 = -0.5;
      }
      else
      {
        if (v54 != 1) {
          goto LABEL_48;
        }
        double v55 = v80;
        double v56 = 0.5;
      }
      v83.CGFloat y = v77 + v55 * v56;
LABEL_48:
      if ([(TSTLayoutSpace *)a1 drawPreventAntialias])
      {
        TSTLayoutSpaceAlignStrokeCoordinates(a1, &v84, &v83, &v86);
        [(TSTLayoutSpace *)a1 viewScale];
        if (v57 < 0.330000013) {
          CGFloat v86 = v78;
        }
      }
      if (a5)
      {
        objc_msgSend((id)objc_msgSend(v26, "color"), "alphaComponent");
        if (v58 > 0.0)
        {
          CGContextSaveGState(a6);
          CGContextBeginPath(a6);
          CGContextMoveToPoint(a6, v84, v85);
          CGContextAddLineToPoint(a6, v83.x, v83.y);
          CGContextSetLineWidth(a6, v86);
          CGContextSetBlendMode(a6, kCGBlendModeClear);
          CGContextStrokePath(a6);
          CGContextRestoreGState(a6);
        }
      }
      else if (([v26 empty] & 1) == 0)
      {
        TSTLayoutSpaceDrawSingleStroke(v26, a6, v84, v85, v83.x, v83.y, v86, v78, v61, v59, v63, v62, v61, v60);
      }
      if (v64 == 1)
      {
        CGFloat v84 = v84 + v86 * 0.5;
        v83.CGFloat x = v86 * 0.5 + v83.x;
        TSTTableBadgeDrawVerticalShadow(a6, 1, v84, v85, v83.x, v83.y, a1->mTransformFromDevice.a + a1->mTransformFromDevice.c);
      }
      if (v39) {

      }
      MergedStrokesForGridColumn = v65;
      goto LABEL_61;
    }
    return TSTStrokeRunArrayUnlock((uint64_t)MergedStrokesForGridColumn);
  }
  return result;
}

uint64_t TSTLayoutSpaceDrawRowStroke(TSTLayoutSpace *a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5, CGContext *a6, int a7)
{
  unsigned int v13 = [(TSTLayoutSpace *)a1 masterLayout];
  if ([(TSTLayoutSpace *)a1 drawPreventAntialias]) {
    AlignedStrokedouble Frame = TSTLayoutSpaceGetAlignedStrokeFrame((uint64_t)a1);
  }
  else {
    AlignedStrokedouble Frame = TSTLayoutSpaceGetStrokeFrame((uint64_t)a1);
  }
  CGFloat v59 = v15;
  CGFloat v60 = AlignedStrokeFrame;
  CGFloat v57 = v17;
  double v58 = v16;
  v84.CGFloat y = TSTLayoutSpaceGetTableCoordinateForGridRow(a1, a2);
  v84.CGFloat x = 0.0;
  TSTLayoutSpaceGetLayoutPointForTablePoint(a1, v84);
  double v19 = v18;
  uint64_t result = TSTMasterLayoutIsGridRowHidden(v13, a2);
  if ((result & 1) == 0)
  {
    CGFloat v73 = v13;
    MergedStrokesForGridRow = TSTMasterLayoutGetMergedStrokesForGridRow(v13, a2);
    v83[0] = 0;
    NextStroke = TSTStrokeRunArrayGetNextStroke((uint64_t)MergedStrokesForGridRow, a3, a4, v83);
    if (NextStroke)
    {
      uint64_t v23 = NextStroke;
      if (a2) {
        unsigned int v24 = a2 - 1;
      }
      else {
        unsigned int v24 = 0;
      }
      unsigned int v71 = a2 + 1;
      unsigned int v72 = v24;
      CGFloat v62 = MergedStrokesForGridRow;
      int v61 = a7;
      while (1)
      {
        unsigned int v25 = (void *)*((void *)v23 + 1);
        [v25 width];
        double v27 = v26;
        CGFloat v82 = v26;
        unsigned int v28 = v23[1];
        uint64_t v29 = *v23 <= a3 ? a3 : *v23;
        uint64_t v30 = v28 >= a4 ? a4 : v28;
        v85.CGFloat x = TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, v29);
        v85.CGFloat y = 0.0;
        double LayoutPointForTablePoint = TSTLayoutSpaceGetLayoutPointForTablePoint(a1, v85);
        double v80 = LayoutPointForTablePoint;
        CGFloat v81 = v19;
        v86.CGFloat x = TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, v30);
        v86.CGFloat y = 0.0;
        double v32 = TSTLayoutSpaceGetLayoutPointForTablePoint(a1, v86);
        v79.CGFloat x = v32;
        v79.CGFloat y = v19;
        if ([(TSTLayoutSpace *)a1 layoutDirectionIsLeftToRight])
        {
          double v33 = v32;
          double v32 = LayoutPointForTablePoint;
        }
        else
        {
          double v80 = v32;
          v79.CGFloat x = LayoutPointForTablePoint;
          double v33 = LayoutPointForTablePoint;
        }
        char v34 = [v25 empty];
        char v35 = a7 ? 0 : v34;
        if ((v35 & 1) == 0 && v32 != v33) {
          break;
        }
LABEL_64:
        uint64_t v23 = TSTStrokeRunArrayGetNextStroke((uint64_t)MergedStrokesForGridRow, a3, a4, v83);
        if (!v23) {
          return TSTStrokeRunArrayUnlock((uint64_t)MergedStrokesForGridRow);
        }
      }
      double v74 = v27;
      if ([(TSTLayoutSpace *)a1 drawBlackAndWhite])
      {
        double v36 = (void *)[v25 mutableCopy];
        objc_msgSend(v36, "setColor:", objc_msgSend(MEMORY[0x263F7C808], "blackColor"));
      }
      else
      {
        if (([v25 solid] & 1) != 0 || -[TSTMasterLayout tableEnvironment](v73, "tableEnvironment") != 1)
        {
          double v36 = 0;
          goto LABEL_31;
        }
        double v36 = (void *)[v25 mutableCopy];
        double v27 = 1.0;
        [v36 setWidth:1.0];
        CGFloat v82 = 1.0;
      }
      unsigned int v25 = v36;
LABEL_31:
      double v77 = 0.0;
      double v78 = 0.0;
      TSTLayoutSpaceAlignStrokeWidth(a1, v27, &v78, &v77);
      char v37 = (double *)MEMORY[0x263F001B0];
      v89.origin.CGFloat x = TSDRectWithOriginAndSize(v38, v32, v19, *MEMORY[0x263F001B0], *(double *)(MEMORY[0x263F001B0] + 8));
      CGFloat v39 = -v77;
      CGRect v90 = CGRectInset(v89, -v77, -v77);
      CGFloat x = v90.origin.x;
      CGFloat width = v90.size.width;
      CGFloat y = v90.origin.y;
      recCGAffineTransform t2 = v90.size.height;
      point.CGFloat x = v33;
      v91.origin.CGFloat x = TSDRectWithOriginAndSize(v41, v33, v19, *v37, v37[1]);
      CGRect v92 = CGRectInset(v91, v39, v39);
      CGFloat v69 = v92.origin.y;
      CGFloat v70 = v92.origin.x;
      CGFloat height = v92.size.height;
      CGFloat v68 = v92.size.width;
      ClipBoundingBoCGFloat x = CGContextGetClipBoundingBox(a6);
      CGFloat v42 = ClipBoundingBox.origin.x;
      CGFloat v43 = ClipBoundingBox.origin.y;
      CGFloat v44 = ClipBoundingBox.size.width;
      CGFloat v45 = ClipBoundingBox.size.height;
      v87.CGFloat x = v32;
      v87.CGFloat y = v19;
      if (CGRectContainsPoint(ClipBoundingBox, v87)) {
        goto LABEL_33;
      }
      v94.origin.CGFloat x = v42;
      v94.origin.CGFloat y = v43;
      v94.size.CGFloat width = v44;
      v94.size.CGFloat height = v45;
      v97.origin.CGFloat x = x;
      v97.size.CGFloat width = width;
      v97.origin.CGFloat y = y;
      v97.size.CGFloat height = rect2;
      double v46 = 0.0;
      if (CGRectIntersectsRect(v94, v97)) {
LABEL_33:
      }
        double v46 = TSTMasterLayoutStrokeWidthOfGridColumn(v73, v29, v72, v71);
      v95.origin.CGFloat x = v42;
      v95.origin.CGFloat y = v43;
      v95.size.CGFloat width = v44;
      v95.size.CGFloat height = v45;
      v88.CGFloat x = point.x;
      v88.CGFloat y = v19;
      if (CGRectContainsPoint(v95, v88)) {
        goto LABEL_36;
      }
      v96.origin.CGFloat x = v42;
      v96.origin.CGFloat y = v43;
      v96.size.CGFloat width = v44;
      v96.size.CGFloat height = v45;
      v98.origin.CGFloat y = v69;
      v98.origin.CGFloat x = v70;
      v98.size.CGFloat height = height;
      v98.size.CGFloat width = v68;
      double v47 = 0.0;
      if (CGRectIntersectsRect(v96, v98)) {
LABEL_36:
      }
        double v47 = TSTMasterLayoutStrokeWidthOfGridColumn(v73, v30, v72, v71);
      a7 = v61;
      if (v46 > 0.0 && ((*((unsigned __int8 *)v23 + 24) >> 2) & 3u) - 1 <= 1)
      {
        double v76 = 0.0;
        TSTLayoutSpaceAlignStrokeWidth(a1, v46, &v76, &point.y);
        int v48 = (*((unsigned __int8 *)v23 + 24) >> 2) & 3;
        if (v48 == 2)
        {
          double v49 = v76;
          double v50 = 0.5;
          goto LABEL_43;
        }
        if (v48 == 1)
        {
          double v49 = v76;
          double v50 = -0.5;
LABEL_43:
          double v80 = v32 + v49 * v50;
        }
      }
      if (v47 <= 0.0 || ((*((unsigned __int8 *)v23 + 24) >> 4) & 3u) - 1 > 1) {
        goto LABEL_51;
      }
      double v76 = 0.0;
      TSTLayoutSpaceAlignStrokeWidth(a1, v47, &v76, &point.y);
      int v51 = (*((unsigned __int8 *)v23 + 24) >> 4) & 3;
      if (v51 == 2)
      {
        double v52 = v76;
        double v53 = -0.5;
      }
      else
      {
        if (v51 != 1) {
          goto LABEL_51;
        }
        double v52 = v76;
        double v53 = 0.5;
      }
      v79.CGFloat x = point.x + v52 * v53;
LABEL_51:
      if ([(TSTLayoutSpace *)a1 drawPreventAntialias])
      {
        TSTLayoutSpaceAlignStrokeCoordinates(a1, &v80, &v79, &v82);
        [(TSTLayoutSpace *)a1 viewScale];
        if (v54 < 0.330000013) {
          CGFloat v82 = v74;
        }
      }
      if (a5)
      {
        objc_msgSend((id)objc_msgSend(v25, "color"), "alphaComponent");
        if (v55 > 0.0)
        {
          CGContextSaveGState(a6);
          CGContextBeginPath(a6);
          CGContextMoveToPoint(a6, v80, v81);
          CGContextAddLineToPoint(a6, v79.x, v79.y);
          CGContextSetLineWidth(a6, v82);
          CGContextSetBlendMode(a6, kCGBlendModeClear);
          CGContextStrokePath(a6);
          CGContextRestoreGState(a6);
        }
      }
      else if (([v25 empty] & 1) == 0)
      {
        TSTLayoutSpaceDrawSingleStroke(v25, a6, v80, v81, v79.x, v79.y, v82, v74, v58, v56, v60, v59, v58, v57);
      }
      if (v61 == 1)
      {
        CGFloat v81 = v81 + v82 * 0.5;
        v79.CGFloat y = v82 * 0.5 + v79.y;
        TSTTableBadgeDrawHorizontalShadow(a6, 1, v80, v81, v79.x, v79.y, a1->mTransformFromDevice.a + a1->mTransformFromDevice.c);
      }
      if (v36) {

      }
      MergedStrokesForGridRow = v62;
      goto LABEL_64;
    }
    return TSTStrokeRunArrayUnlock((uint64_t)MergedStrokesForGridRow);
  }
  return result;
}

uint64_t TSTLayoutSpaceGetBoundsGridRange(TSTLayoutSpace *a1)
{
  return 0;
}

uint64_t TSTLayoutSpaceCreateRowCoordinates(void *a1, unint64_t a2, unint64_t a3, void *a4, char *a5)
{
  unint64_t v10 = [TSTCoordinateArray alloc];
  unint64_t v11 = HIDWORD(a3);
  if (a2 == -1 || a3 == -1 || a2 > a3)
  {
    unint64_t v12 = HIDWORD(a2);
  }
  else
  {
    unint64_t v12 = HIDWORD(a2);
    if (v11 >= HIDWORD(a2) && v11 != -1 && HIDWORD(a2) != -1)
    {
      int v15 = v11 - HIDWORD(a2) + 1;
      goto LABEL_14;
    }
  }
  int v15 = 0;
LABEL_14:
  uint64_t v16 = [(TSTCoordinateArray *)v10 initWithCount:(v15 + 1) atOffset:v12];
  double v17 = (void *)[a1 layout];
  char v26 = 0;
  if ([a1 headerRowsRepeat]
    && (char v18 = [a1 isMain], HIDWORD(a2))
    && (v18 & 1) != 0
    || (double v19 = 0.0, [a1 headerRowsRepeat])
    && [a1 layoutSpaceType] == 5)
  {
    unint64_t v20 = TSTLayoutGetPartitionHeaderRowsCellRange(v17) >> 48;
    if (v20)
    {
      int v21 = 0;
      double v19 = 0.0;
      do
        double v19 = v19 + TSTLayoutHeightOfRow((double *)v17, (unsigned __int16)v21++, &v26, 1, 1);
      while (v20 != v21);
    }
    else
    {
      double v19 = 0.0;
    }
  }
  if (TSTMasterLayoutGetTableNumberOfRows([v17 masterLayout]) - 1 <= v11) {
    LODWORD(v11) = TSTMasterLayoutGetTableNumberOfRows([v17 masterLayout]) - 1;
  }
  for (; v12 <= v11; LODWORD(v12) = v12 + 1)
  {
    TSTCoordinateArraySetCoordinate(v16, v12, v19);
    double v22 = TSTLayoutHeightOfRow((double *)v17, (unsigned __int16)v12, &v26, 1, 1);
    if (v22 == 0.0) {
      TSTCoordinateArraySetIndexHidden(v16, v12);
    }
    double v19 = v19 + v22;
  }
  double v23 = TSTCoordinateArraySetCoordinate(v16, v12, v19);
  if (a5)
  {
    if (a4) {
      char v24 = objc_msgSend(a4, "isEqual:", v16, v23) ^ 1;
    }
    else {
      char v24 = 1;
    }
    *a5 = v24;
  }
  return v16;
}

uint64_t TSTLayoutSpaceCreateColumnCoordinates(void *a1, uint64_t a2, uint64_t a3, void *a4, char *a5)
{
  unint64_t v10 = [TSTCoordinateArray alloc];
  if (a2 == -1
    || a3 == -1
    || a3 < a2
    || (HIDWORD(a2) <= HIDWORD(a3) ? (BOOL v11 = HIDWORD(a3) == -1) : (BOOL v11 = 1),
        !v11 ? (BOOL v12 = HIDWORD(a2) == -1) : (BOOL v12 = 1),
        v12))
  {
    int v13 = 0;
  }
  else
  {
    int v13 = a3 - a2 + 1;
  }
  uint64_t v14 = [(TSTCoordinateArray *)v10 initWithCount:(v13 + 1) atOffset:a2];
  int v15 = (void *)[a1 layout];
  char v25 = 0;
  if ([a1 headerColumnsRepeat]
    && (char v16 = [a1 isMain], a2)
    && (v16 & 1) != 0
    || (double v17 = 0.0, [a1 headerColumnsRepeat])
    && [a1 layoutSpaceType] == 6)
  {
    PartitionHeaderColumnsCellunint64_t Range = TSTLayoutGetPartitionHeaderColumnsCellRange(v15);
    unsigned int v19 = WORD2(PartitionHeaderColumnsCellRange);
    if (WORD2(PartitionHeaderColumnsCellRange))
    {
      int v20 = 0;
      double v17 = 0.0;
      do
        double v17 = v17 + private_LayoutWidthOfColumn(v15, v20++, 0, &v25);
      while (v19 > v20);
    }
    else
    {
      double v17 = 0.0;
    }
  }
  if (TSTMasterLayoutGetTableNumberOfColumns([v15 masterLayout]) - 1 <= a3) {
    LODWORD(a3) = TSTMasterLayoutGetTableNumberOfColumns([v15 masterLayout]) - 1;
  }
  for (; a2 <= a3; LODWORD(a2) = a2 + 1)
  {
    TSTCoordinateArraySetCoordinate(v14, a2, v17);
    double v21 = private_LayoutWidthOfColumn(v15, a2, 0, &v25);
    if (v21 == 0.0) {
      TSTCoordinateArraySetIndexHidden(v14, a2);
    }
    double v17 = v17 + v21;
  }
  double v22 = TSTCoordinateArraySetCoordinate(v14, a2, v17);
  if (a5)
  {
    if (a4) {
      char v23 = objc_msgSend(a4, "isEqual:", v14, v22) ^ 1;
    }
    else {
      char v23 = 1;
    }
    *a5 = v23;
  }
  return v14;
}

$3C36844D3994842D9102894F8152D7DE TSTLayoutSpaceGetExtendedBodyGridRange(TSTLayoutSpace *a1)
{
  $3C36844D3994842D9102894F8152D7DE topLeft = a1->mGridRange.topLeft;
  TSTLayoutSpaceGetFooterRowsGridRange((uint64_t)a1);
  return topLeft;
}

double TSTLayoutSpaceGetLayoutOffsetForGridPoint(TSTLayoutSpace *a1, unint64_t a2)
{
  double v4 = *MEMORY[0x263F00148];
  uint64_t v5 = [(TSTLayoutSpace *)a1 layout];
  if (a2 > 0xFFFFFFFEFFFFFFFFLL || a2 == 0xFFFFFFFFLL) {
    goto LABEL_19;
  }
  PartitionNonHeaderRowCellunint64_t Range = TSTLayoutGetPartitionNonHeaderRowCellRange(v5);
  if (BYTE2(PartitionNonHeaderRowCellRange) == 255) {
    unsigned int v7 = -1;
  }
  else {
    unsigned int v7 = BYTE2(PartitionNonHeaderRowCellRange);
  }
  unsigned int v8 = (unsigned __int16)PartitionNonHeaderRowCellRange;
  if ((unsigned __int16)PartitionNonHeaderRowCellRange == 0xFFFF) {
    unsigned int v8 = -1;
  }
  if (v7 <= a2)
  {
    if (WORD2(PartitionNonHeaderRowCellRange)
      && WORD2(PartitionNonHeaderRowCellRange) + v7 - 1 < a2
      && v8 > HIDWORD(a2))
    {
      if (![(TSTLayoutSpace *)a1 layoutDirectionIsLeftToRight]) {
        goto LABEL_21;
      }
      goto LABEL_18;
    }
    if (v8 > HIDWORD(a2))
    {
LABEL_18:
      double BodyTranslationX = TSTLayoutSpaceGetBodyTranslationX(a1);
      double v4 = v4 - (BodyTranslationX - TSTLayoutSpaceGetHeaderColumnsWidth(a1));
      goto LABEL_21;
    }
LABEL_19:
    double v10 = TSTLayoutSpaceGetBodyTranslationX(a1);
    double v4 = v4 - (v10 - TSTLayoutSpaceGetHeaderColumnsWidth(a1));
LABEL_20:
    TSTLayoutSpaceGetBodyTranslationY(a1);
    TSTLayoutSpaceGetHeaderRowsHeight(a1);
    goto LABEL_21;
  }
  if (v8 <= HIDWORD(a2) || ![(TSTLayoutSpace *)a1 layoutDirectionIsLeftToRight]) {
    goto LABEL_20;
  }
LABEL_21:
  [(TSTLayoutSpace *)a1 tableOffset];
  return v4 + v11;
}

double TSTLayoutSpaceGetBodyTranslationX(TSTLayoutSpace *a1)
{
  BodyGridunint64_t Range = TSTLayoutSpaceGetBodyGridRange((uint64_t)a1);
  if ([(TSTLayoutSpace *)a1 headerColumnsRepeat]
    && ([(TSTLayoutSpace *)a1 isMain] || [(TSTLayoutSpace *)a1 layoutSpaceType] == 6))
  {
    return 0.0;
  }

  return TSTLayoutSpaceGetRawTableCoordinateForGridColumn(a1, BodyGridRange);
}

double TSTLayoutSpaceGetBodyTranslationY(TSTLayoutSpace *a1)
{
  BodyGridunint64_t Range = TSTLayoutSpaceGetBodyGridRange((uint64_t)a1);
  if ([(TSTLayoutSpace *)a1 headerRowsRepeat]
    && ([(TSTLayoutSpace *)a1 isMain] || [(TSTLayoutSpace *)a1 layoutSpaceType] == 5))
  {
    return 0.0;
  }

  return TSTLayoutSpaceGetTableCoordinateForGridRow(a1, HIDWORD(BodyGridRange));
}

uint64_t TSTLayoutSpaceGetGridColumnForTableCoordinate(TSTLayoutSpace *a1, double a2)
{
  if (!a1)
  {
    double v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTGridColumn TSTLayoutSpaceGetGridColumnForTableCoordinate(TSTLayoutSpace *, CGFloat)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"), 3230, @"space should not be NULL");
  }
  if (!a1->mBodyColumnCoordinates && !a1->mHeaderRowColumnCoordinates)
  {
    uint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTGridColumn TSTLayoutSpaceGetGridColumnForTableCoordinate(TSTLayoutSpace *, CGFloat)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"), 3233, @"Body column coordinates and header row column coordinates have not been filled.");
  }
  mHeaderRowColumnCoordinates = a1->mHeaderRowColumnCoordinates;
  if (!mHeaderRowColumnCoordinates
    || (uint64_t result = TSTCoordinateArrayLookup(mHeaderRowColumnCoordinates, a2), result == -1))
  {
    mBodyColumnCoordinates = a1->mBodyColumnCoordinates;
    return TSTCoordinateArrayLookup(mBodyColumnCoordinates, a2);
  }
  return result;
}

uint64_t TSTLayoutSpaceGetGridRowForTableCoordinate(TSTLayoutSpace *a1, double a2)
{
  if (!a1)
  {
    double v4 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v5 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTGridRow TSTLayoutSpaceGetGridRowForTableCoordinate(TSTLayoutSpace *, CGFloat)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"), 3252, @"space should not be NULL");
  }
  if (!a1->mBodyRowCoordinates && !a1->mHeaderColumnRowCoordinates)
  {
    uint64_t v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTGridRow TSTLayoutSpaceGetGridRowForTableCoordinate(TSTLayoutSpace *, CGFloat)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"), 3254, @"Body row coordinates and header column row coordinates have not been filled.");
  }
  mHeaderColumnRowCoordinates = a1->mHeaderColumnRowCoordinates;
  if (!mHeaderColumnRowCoordinates
    || (uint64_t result = TSTCoordinateArrayLookup(mHeaderColumnRowCoordinates, a2), result == -1))
  {
    mBodyRowCoordinates = a1->mBodyRowCoordinates;
    return TSTCoordinateArrayLookup(mBodyRowCoordinates, a2);
  }
  return result;
}

double TSTLayoutSpaceGetAlignFrameSpec(TSTLayoutSpace *a1, double *a2)
{
  long long v14 = *(_OWORD *)a2;
  v13.CGFloat x = *(double *)&v14 + 1.0;
  v13.CGFloat y = *((CGFloat *)&v14 + 1);
  TSTLayoutSpaceAlignStrokeCoordinates(a1, (double *)&v14, &v13, a2 + 8);
  long long v12 = *(_OWORD *)a2;
  *(void *)&v11.CGFloat x = v12;
  v11.CGFloat y = *((double *)&v12 + 1) + 1.0;
  TSTLayoutSpaceAlignStrokeCoordinates(a1, (double *)&v12, &v11, a2 + 10);
  long long v10 = *((_OWORD *)a2 + 1);
  v9.CGFloat x = *(double *)&v10 + 1.0;
  v9.CGFloat y = *((CGFloat *)&v10 + 1);
  TSTLayoutSpaceAlignStrokeCoordinates(a1, (double *)&v10, &v9, a2 + 9);
  long long v8 = *((_OWORD *)a2 + 2);
  *(void *)&v7.CGFloat x = v8;
  v7.CGFloat y = *((double *)&v8 + 1) + 1.0;
  TSTLayoutSpaceAlignStrokeCoordinates(a1, (double *)&v8, &v7, a2 + 11);
  uint64_t v4 = *((void *)&v14 + 1);
  *(void *)a2 = v12;
  *((void *)a2 + 1) = v4;
  double result = *(double *)&v8;
  uint64_t v6 = *((void *)&v10 + 1);
  *((void *)a2 + 6) = v8;
  *((void *)a2 + 7) = v6;
  return result;
}

uint64_t *std::__tree<TSUColumnRowRect,TSTCellRangeRowMajorLess,std::allocator<TSUColumnRowRect>>::__emplace_unique_key_args<TSUColumnRowRect,TSUColumnRowRect const&>(uint64_t **a1, unsigned __int16 *a2, uint64_t *a3)
{
  uint64_t v5 = std::__tree<TSUColumnRowRect,TSTCellRangeRowMajorLess,std::allocator<TSUColumnRowRect>>::__find_equal<TSUColumnRowRect>((uint64_t)a1, &v9, a2);
  uint64_t v6 = (uint64_t *)*v5;
  if (!*v5)
  {
    CGPoint v7 = (uint64_t **)v5;
    uint64_t v6 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v6 + 26) = *a3;
    std::__tree<std::__value_type<std::string,unsigned short>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned short>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned short>>>::__insert_node_at(a1, v9, v7, v6);
  }
  return v6;
}

uint64_t *std::__tree<TSUColumnRowRect,TSTCellRangeRowMajorLess,std::allocator<TSUColumnRowRect>>::__find_equal<TSUColumnRowRect>(uint64_t a1, void *a2, unsigned __int16 *a3)
{
  uint64_t v5 = *(uint64_t **)(a1 + 8);
  double result = (uint64_t *)(a1 + 8);
  uint64_t v4 = v5;
  if (v5)
  {
    unsigned int v6 = *a3;
    unsigned int v7 = *((unsigned __int8 *)a3 + 2);
    do
    {
      while (1)
      {
        long long v8 = v4;
        unsigned int v9 = *((unsigned __int16 *)v4 + 13);
        unsigned int v10 = *((unsigned __int8 *)v8 + 28);
        BOOL v11 = v7 < v10;
        if (v6 != v9) {
          BOOL v11 = v6 < v9;
        }
        if (!v11) {
          break;
        }
        uint64_t v4 = (uint64_t *)*v8;
        double result = v8;
        if (!*v8) {
          goto LABEL_15;
        }
      }
      BOOL v12 = v10 < v7;
      if (v6 == v9) {
        BOOL v13 = v12;
      }
      else {
        BOOL v13 = v9 < v6;
      }
      if (!v13) {
        break;
      }
      double result = v8 + 1;
      uint64_t v4 = (uint64_t *)v8[1];
    }
    while (v4);
  }
  else
  {
    long long v8 = result;
  }
LABEL_15:
  *a2 = v8;
  return result;
}

uint64_t *std::__tree<TSUColumnRowRect,TSTCellRangeColumnMajorLess,std::allocator<TSUColumnRowRect>>::__emplace_unique_key_args<TSUColumnRowRect,TSUColumnRowRect const&>(uint64_t **a1, unsigned __int16 *a2, uint64_t *a3)
{
  uint64_t v5 = std::__tree<TSUColumnRowRect,TSTCellRangeColumnMajorLess,std::allocator<TSUColumnRowRect>>::__find_equal<TSUColumnRowRect>((uint64_t)a1, &v9, a2);
  unsigned int v6 = (uint64_t *)*v5;
  if (!*v5)
  {
    unsigned int v7 = (uint64_t **)v5;
    unsigned int v6 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v6 + 26) = *a3;
    std::__tree<std::__value_type<std::string,unsigned short>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned short>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned short>>>::__insert_node_at(a1, v9, v7, v6);
  }
  return v6;
}

uint64_t *std::__tree<TSUColumnRowRect,TSTCellRangeColumnMajorLess,std::allocator<TSUColumnRowRect>>::__find_equal<TSUColumnRowRect>(uint64_t a1, void *a2, unsigned __int16 *a3)
{
  uint64_t v5 = *(uint64_t **)(a1 + 8);
  double result = (uint64_t *)(a1 + 8);
  uint64_t v4 = v5;
  if (v5)
  {
    unsigned int v6 = *((unsigned __int8 *)a3 + 2);
    unsigned int v7 = *a3;
    do
    {
      while (1)
      {
        long long v8 = v4;
        unsigned int v9 = *((unsigned __int8 *)v4 + 28);
        unsigned int v10 = *((unsigned __int16 *)v8 + 13);
        BOOL v11 = v7 < v10;
        if (v6 != v9) {
          BOOL v11 = v6 < v9;
        }
        if (!v11) {
          break;
        }
        uint64_t v4 = (uint64_t *)*v8;
        double result = v8;
        if (!*v8) {
          goto LABEL_15;
        }
      }
      BOOL v12 = v10 < v7;
      if (v6 == v9) {
        BOOL v13 = v12;
      }
      else {
        BOOL v13 = v9 < v6;
      }
      if (!v13) {
        break;
      }
      double result = v8 + 1;
      uint64_t v4 = (uint64_t *)v8[1];
    }
    while (v4);
  }
  else
  {
    long long v8 = result;
  }
LABEL_15:
  *a2 = v8;
  return result;
}

void TSTTableInitDefaultHeightAndWidth(TSTTableInfo *a1, double a2, double a3)
{
  unsigned int v6 = [(TSTTableInfo *)a1 tableModel];
  unsigned int v7 = [(TSTTableModel *)v6 numberOfRows];
  double v8 = a3 / (double)[(TSTTableModel *)v6 numberOfColumns];
  TSTTableComputeDefaultFontHeight(v6, 0);
  double v10 = v9;
  if (v8 < 8.0) {
    double v8 = 8.0;
  }
  TSTTableSetDefaultRowHeight((double *)v6, v9);
  TSTTableSetDefaultColumnWidth((double *)v6, v8);
  if (a2 / (double)v7 <= v10)
  {
    BOOL v11 = 1;
  }
  else
  {
    double v10 = a2 / (double)v7;
    BOOL v11 = v7 == 0;
  }
  if (!v11)
  {
    int v12 = 0;
    do
      TSTTableSetHeightOfRow((uint64_t)v6, (unsigned __int16)v12++, v10);
    while (v7 > (unsigned __int16)v12);
  }
  if (v10 * (double)v7 != a2)
  {
    BOOL v13 = [TSDInfoGeometry alloc];
    [(TSDInfoGeometry *)[(TSDDrawableInfo *)a1 geometry] position];
    long long v14 = -[TSDInfoGeometry initWithPosition:size:](v13, "initWithPosition:size:");
    [(TSTTableInfo *)a1 setGeometry:v14 resizeInternal:0];
  }
}

BOOL TSTLayoutSetTabsVisible(uint64_t a1, int a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 385);
  if (v2 != a2) {
    *(unsigned char *)(a1 + 385) = a2;
  }
  return v2 != a2;
}

uint64_t TSTLayoutSetPartitionRange(void *a1)
{
  uint64_t RangeForHint = TSTMasterLayoutGetRangeForHint([a1 masterLayout], objc_msgSend(a1, "layoutHint"));
  unint64_t v3 = RangeForHint;
  if (BYTE2(RangeForHint) == 255) {
    unsigned int v4 = -1;
  }
  else {
    unsigned int v4 = BYTE2(RangeForHint);
  }
  if (WORD2(RangeForHint)) {
    uint64_t v5 = WORD2(RangeForHint) + v4 - 1;
  }
  else {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  uint64_t v6 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");
  if ((unsigned __int16)v3 == 0xFFFF) {
    uint64_t v7 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v7 = (unsigned __int16)v3;
  }
  unint64_t v8 = v4 | ((unint64_t)v7 << 32);
  uint64_t v9 = ((v3 >> 16) & 0xFFFF00000000) + (v7 << 32) - 0x100000000;
  if (((v3 >> 16) & 0xFFFF00000000) == 0) {
    uint64_t v9 = 0xFFFFFFFF00000000;
  }

  return TSTLayoutSpaceSetGridRange(v6, v8, v5 | v9);
}

uint64_t TSTLayoutInvalidateLayoutSpaceTableOffsets(void *a1)
{
  uint64_t v1 = (void *)[a1 spaceBundle];

  return [v1 invalidateTableOffsets];
}

double TSTLayoutGetRenderingFrameOutset(double a1, double a2, double a3, double a4)
{
  *(void *)&double result = (unint64_t)CGRectInset(*(CGRect *)&a1, -1.0, -1.0);
  return result;
}

double TSTLayoutGetRenderingFrame(void *a1, void *a2)
{
  uint64_t v4 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");
  uint64_t v5 = v4;
  if (!a2) {
    a2 = (void *)v4;
  }
  v16.origin.CGFloat x = TSTLayoutSpaceGetStrokeFrame((uint64_t)a2);
  CGRect v17 = CGRectInset(v16, -1.0, -1.0);
  CGFloat x = v17.origin.x;
  double y = v17.origin.y;
  CGFloat width = v17.size.width;
  double height = v17.size.height;
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  double v11 = -0.0;
  if (v10 > 0.0) {
    double v11 = v10;
  }
  v18.size.double height = height + v11;
  v18.origin.double y = y - fmax(v10, 0.0);
  v18.origin.CGFloat x = x;
  v18.size.CGFloat width = width;
  *(void *)&double v12 = (unint64_t)CGRectIntegral(v18);
  if ([a2 isFrozen])
  {
    Renderingdouble Frame = TSTLayoutGetRenderingFrame(a1, v5);
    double v14 = v12 - RenderingFrame;
    if (RenderingFrame >= v12) {
      double v14 = 0.0;
    }
    return v12 - v14;
  }
  return v12;
}

uint64_t TSTLayoutGetSpace(void *a1)
{
  uint64_t v1 = (void *)[a1 spaceBundle];

  return [v1 space];
}

uint64_t TSTLayoutGetTableNameHeight(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 387)) {
    return [*(id *)(a1 + 304) invalidateTableNameHeight];
  }
  objc_msgSend((id)objc_msgSend((id)a1, "masterLayout"), "tableNameHeight");
  return objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)a1, "spaceBundle"), "space"), "viewScale");
}

uint64_t TSTLayoutInvalidateLayoutSpaceCoordinates(void *a1)
{
  uint64_t v1 = (void *)[a1 spaceBundle];

  return [v1 invalidateCoordinates];
}

double TSTLayoutGetStrokeFrame(void *a1)
{
  uint64_t v1 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");

  return TSTLayoutSpaceGetStrokeFrame(v1);
}

uint64_t TSTLayoutUpdateTransformToCanvas(void *a1)
{
  [a1 frameInRoot];
  memset(&v8, 0, sizeof(v8));
  CGAffineTransformMakeTranslation(&v8, v2, v3);
  uint64_t v4 = (void *)[a1 spaceBundle];
  v6[0] = MEMORY[0x263EF8330];
  v6[1] = 3221225472;
  v6[2] = __TSTLayoutUpdateTransformToCanvas_block_invoke;
  v6[3] = &__block_descriptor_80_e24_B16__0__TSTLayoutSpace_8l;
  CGAffineTransform v7 = v8;
  return [v4 performActionOnEachLayoutSpace:v6];
}

uint64_t TSTLayoutSetNeedsDisplayInCanvasRect(TSTLayout *a1, CGRect a2)
{
  double LayoutRectForCanvasRect = TSTLayoutSpaceGetLayoutRectForCanvasRect((uint64_t)[(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space], a2.origin.x, a2.origin.y, a2.size.width, a2.size.height);

  return [(TSTLayout *)a1 setNeedsDisplayInRect:LayoutRectForCanvasRect];
}

void *TSTLayoutInvalidateCellRangeAndFittingRange(void *a1)
{
  objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "invalidateCoordinates");
  objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "invalidateTableOffsets");
  objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "invalidateCoordinates");
  [a1 invalidateChildren];
  [a1 invalidate];
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "cellIDToWPColumnCache"), "removeAllObjects");
  double result = (void *)[a1 containedTextEditingLayout];
  if (result)
  {
    return (void *)[result invalidateSize];
  }
  return result;
}

uint64_t TSTLayoutInvalidateRows(void *a1)
{
  objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "invalidateCoordinates");
  [a1 invalidateChildren];

  return [a1 invalidate];
}

uint64_t TSTLayoutInvalidateCell(void *a1, unsigned int a2)
{
  uint64_t v4 = objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "cellIDToWPColumnCache");
  HIDWORD(v5) = a2;
  LODWORD(v5) = a2;
  objc_msgSend(v4, "removeObjectForKey:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", (v5 >> 16) & 0xFFFF00FF));
  objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "addChangeDescriptor:", +[TSTChangeDescriptor changeDescriptorWithType:cellRange:](TSTChangeDescriptor, "changeDescriptorWithType:cellRange:", 33, a2 | 0x1000100000000));
  objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "invalidateCoordinates");
  objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "invalidateTableOffsets");
  [a1 invalidateChildren];

  return [a1 invalidate];
}

uint64_t TSTLayoutInvalidateColumns(void *a1)
{
  objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "invalidateCoordinates");
  objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "invalidateTableOffsets");
  [a1 invalidateChildren];

  return [a1 invalidate];
}

uint64_t TSTLayoutInvalidateContentRange(void *a1, unint64_t a2)
{
  int v4 = BYTE2(a2);
  if (BYTE2(a2) == 255) {
    unsigned int v5 = -1;
  }
  else {
    unsigned int v5 = BYTE2(a2);
  }
  int v6 = (unsigned __int16)a2;
  if (WORD2(a2)) {
    unsigned int v7 = WORD2(a2) + v5 - 1;
  }
  else {
    unsigned int v7 = -1;
  }
  if ((unsigned __int16)a2 == 0xFFFF) {
    unsigned int v8 = -1;
  }
  else {
    unsigned int v8 = (unsigned __int16)a2;
  }
  unsigned int v9 = v8 + ((unint64_t)((HIDWORD(a2) << 16) - 0x100000000) >> 32);
  Gridunint64_t Range = TSTLayoutSpaceGetGridRange(objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"));
  if (HIWORD(a2)) {
    unsigned int v13 = v9;
  }
  else {
    unsigned int v13 = -1;
  }
  unint64_t v14 = -1;
  if (v4 == 255 || v7 == -1)
  {
    uint64_t v15 = -1;
  }
  else
  {
    uint64_t v15 = -1;
    if (v5 <= v7
      && v6 != 0xFFFF
      && v13 != -1
      && v8 <= v13
      && GridRange != -1
      && v11 != -1
      && GridRange <= v11
      && HIDWORD(GridRange) != -1
      && v12 != -1
      && HIDWORD(GridRange) <= v12)
    {
      uint64_t v16 = v5 <= GridRange ? GridRange : v5;
      uint64_t v17 = v7 >= v11 ? v11 : v7;
      if (v16 <= v17)
      {
        uint64_t v18 = v13 >= v12 ? v12 : v13;
        uint64_t v19 = v8 <= HIDWORD(GridRange) ? HIDWORD(GridRange) : v8;
        if (v19 <= v18)
        {
          uint64_t v15 = v17 | (v18 << 32);
          unint64_t v14 = v16 | (v19 << 32);
        }
      }
    }
  }
  FrameForGridunint64_t Range = TSTLayoutSpaceGetFrameForGridRange((TSTLayoutSpace *)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), v14, v15);

  return [a1 setNeedsDisplayInRect:FrameForGridRange];
}

double TSTLayoutWidthOfColumn(double *a1, uint64_t a2, unsigned char *a3)
{
  return TSTMasterLayoutWidthOfColumn([a1 masterLayout], a2, 0, a3, 1) * a1[51];
}

double private_LayoutWidthOfColumn(void *a1, uint64_t a2, char a3, unsigned char *a4)
{
  uint64_t v7 = [a1 masterLayout];

  return TSTMasterLayoutWidthOfColumn(v7, a2, a3, a4, 1);
}

double TSTLayoutHeightOfRow(double *a1, uint64_t a2, char *a3, int a4, int a5)
{
  return TSTMasterLayoutHeightOfRow((TSTMasterLayout *)[a1 masterLayout], a2, 0, a3, a4, a5) * a1[52];
}

uint64_t TSTLayoutGetPartitionRange(void *a1)
{
  uint64_t v2 = [a1 masterLayout];
  CGFloat v3 = (void *)[a1 layoutHint];

  return TSTMasterLayoutGetRangeForHint(v2, v3);
}

BOOL TSTLayoutExtendedPartitionRangeContainsCellID(void *a1, int a2)
{
  unint64_t RangeForHint = TSTMasterLayoutGetRangeForHint([a1 masterLayout], objc_msgSend(a1, "layoutHint"));
  if (HIWORD(RangeForHint)
    && (RangeForHint & 0xFFFF00000000) != 0
    && (unsigned __int16)RangeForHint <= (unsigned __int16)a2
    && (unsigned __int16)(RangeForHint + HIWORD(RangeForHint) - 1) >= (unsigned __int16)a2
    && BYTE2(a2) >= BYTE2(RangeForHint)
    && BYTE2(a2) <= (BYTE4(RangeForHint) + BYTE2(RangeForHint) - 1))
  {
    return 1;
  }
  PartitionHeaderColumnsCellunint64_t Range = TSTLayoutGetPartitionHeaderColumnsCellRange(a1);
  if (HIWORD(PartitionHeaderColumnsCellRange))
  {
    if ((PartitionHeaderColumnsCellRange & 0xFFFF00000000) != 0
      && (unsigned __int16)PartitionHeaderColumnsCellRange <= (unsigned __int16)a2
      && (unsigned __int16)(PartitionHeaderColumnsCellRange + HIWORD(PartitionHeaderColumnsCellRange) - 1) >= (unsigned __int16)a2
      && BYTE2(a2) >= BYTE2(PartitionHeaderColumnsCellRange)
      && BYTE2(a2) <= (BYTE4(PartitionHeaderColumnsCellRange)
                                                    + BYTE2(PartitionHeaderColumnsCellRange)
                                                    - 1))
    {
      return 1;
    }
  }
  PartitionHeaderRowsCellunint64_t Range = TSTLayoutGetPartitionHeaderRowsCellRange(a1);
  if (HIWORD(PartitionHeaderRowsCellRange))
  {
    if ((PartitionHeaderRowsCellRange & 0xFFFF00000000) != 0
      && (unsigned __int16)PartitionHeaderRowsCellRange <= (unsigned __int16)a2
      && (unsigned __int16)(PartitionHeaderRowsCellRange + HIWORD(PartitionHeaderRowsCellRange) - 1) >= (unsigned __int16)a2
      && BYTE2(a2) >= BYTE2(PartitionHeaderRowsCellRange)
      && BYTE2(a2) <= (BYTE4(PartitionHeaderRowsCellRange)
                                                    + BYTE2(PartitionHeaderRowsCellRange)
                                                    - 1))
    {
      return 1;
    }
  }
  PartitionHeaderCornerCellunint64_t Range = TSTLayoutGetPartitionHeaderCornerCellRange(a1);
  uint64_t v8 = 0;
  if (HIWORD(PartitionHeaderCornerCellRange) && (PartitionHeaderCornerCellRange & 0xFFFF00000000) != 0) {
    return (unsigned __int16)PartitionHeaderCornerCellRange <= (unsigned __int16)a2
  }
        && (unsigned __int16)(PartitionHeaderCornerCellRange + HIWORD(PartitionHeaderCornerCellRange) - 1) >= (unsigned __int16)a2
        && BYTE2(a2) >= BYTE2(PartitionHeaderCornerCellRange)
        && BYTE2(a2) <= (BYTE4(PartitionHeaderCornerCellRange)
                                                      + BYTE2(PartitionHeaderCornerCellRange)
                                                      - 1);
  return v8;
}

uint64_t TSTLayoutGetPartitionHeaderColumnsCellRange(void *a1)
{
  uint64_t v2 = (unsigned __int16 *)[a1 masterLayout];
  uint64_t TableNumberOfHeaderColumns = TSTMasterLayoutGetTableNumberOfHeaderColumns(v2);
  if (!TableNumberOfHeaderColumns)
  {
    LODWORD(v6) = 0;
LABEL_10:
    unint64_t v7 = 0;
    uint64_t v9 = 16711680;
    unsigned __int16 v5 = -1;
    return (TableNumberOfHeaderColumns << 32) | (v7 << 48) | (v6 << 24) | v9 | v5;
  }
  if ((objc_msgSend((id)objc_msgSend(a1, "layoutHint"), "cacheHintID") & 0xFF0000) != 0
    && !objc_msgSend((id)objc_msgSend(a1, "tableModel"), "repeatingHeaderColumnsEnabled"))
  {
    LODWORD(v6) = 0;
    uint64_t TableNumberOfHeaderColumns = 0;
    goto LABEL_10;
  }
  unint64_t RangeForHint = TSTMasterLayoutGetRangeForHint((uint64_t)v2, (void *)[a1 layoutHint]);
  unsigned __int16 v5 = RangeForHint;
  unint64_t v6 = RangeForHint >> 24;
  unint64_t v7 = HIWORD(RangeForHint);
  if ((_WORD)RangeForHint
    || !objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), "headerRowsRepeat"))
  {
    uint64_t v9 = 0;
  }
  else
  {
    unsigned __int16 TableNumberOfHeaderRows = TSTMasterLayoutGetTableNumberOfHeaderRows(v2);
    uint64_t v9 = 0;
    unsigned __int16 v5 = TableNumberOfHeaderRows;
    unint64_t v7 = (unsigned __int16)(v7 - TableNumberOfHeaderRows);
  }
  return (TableNumberOfHeaderColumns << 32) | (v7 << 48) | (v6 << 24) | v9 | v5;
}

unint64_t TSTLayoutGetPartitionHeaderRowsCellRange(void *a1)
{
  uint64_t v2 = (unsigned __int16 *)[a1 masterLayout];
  uint64_t TableNumberOfHeaderRows = TSTMasterLayoutGetTableNumberOfHeaderRows(v2);
  if (!TableNumberOfHeaderRows)
  {
    LODWORD(v6) = 0;
    LOWORD(v7) = 0;
LABEL_10:
    LOBYTE(v5) = -1;
    uint64_t v10 = 0xFFFFLL;
    return ((unint64_t)(unsigned __int16)v7 << 32) | (TableNumberOfHeaderRows << 48) | (v6 << 24) | ((unint64_t)v5 << 16) | v10;
  }
  if ((unsigned __int16)objc_msgSend((id)objc_msgSend(a1, "layoutHint"), "cacheHintID")
    && !objc_msgSend((id)objc_msgSend(a1, "tableModel"), "repeatingHeaderRowsEnabled"))
  {
    LODWORD(v6) = 0;
    LOWORD(v7) = 0;
    uint64_t TableNumberOfHeaderRows = 0;
    goto LABEL_10;
  }
  unint64_t RangeForHint = TSTMasterLayoutGetRangeForHint((uint64_t)v2, (void *)[a1 layoutHint]);
  unint64_t v5 = RangeForHint >> 16;
  unint64_t v6 = RangeForHint >> 24;
  unint64_t v7 = HIDWORD(RangeForHint);
  if ((RangeForHint & 0xFF0000) != 0
    || (__int16 v8 = WORD2(RangeForHint),
        !objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), "headerColumnsRepeat")))
  {
    uint64_t v10 = 0;
  }
  else
  {
    __int16 TableNumberOfHeaderColumns = TSTMasterLayoutGetTableNumberOfHeaderColumns(v2);
    uint64_t v10 = 0;
    LOBYTE(v5) = TableNumberOfHeaderColumns;
    LOWORD(v7) = v8 - TableNumberOfHeaderColumns;
  }
  return ((unint64_t)(unsigned __int16)v7 << 32) | (TableNumberOfHeaderRows << 48) | (v6 << 24) | ((unint64_t)v5 << 16) | v10;
}

uint64_t TSTLayoutGetPartitionHeaderCornerCellRange(void *a1)
{
  PartitionHeaderRowsCellunint64_t Range = TSTLayoutGetPartitionHeaderRowsCellRange(a1);
  PartitionHeaderColumnsCellunint64_t Range = TSTLayoutGetPartitionHeaderColumnsCellRange(a1);
  uint64_t v4 = 0;
  uint64_t v5 = 0xFFFFFFLL;
  if ((_WORD)PartitionHeaderRowsCellRange == 0xFFFF) {
    goto LABEL_23;
  }
  unint64_t v6 = 0;
  if ((PartitionHeaderRowsCellRange & 0xFF0000) == 0xFF0000) {
    return v6 | v4 | v5;
  }
  uint64_t v4 = 0;
  uint64_t v5 = 0xFFFFFFLL;
  if (!HIWORD(PartitionHeaderRowsCellRange))
  {
LABEL_23:
    unint64_t v6 = 0;
    return v6 | v4 | v5;
  }
  unint64_t v6 = 0;
  if ((PartitionHeaderRowsCellRange & 0xFFFF00000000) != 0)
  {
    uint64_t v5 = 0xFFFFFFLL;
    if ((_WORD)PartitionHeaderColumnsCellRange == 0xFFFF)
    {
      uint64_t v4 = 0;
      unint64_t v6 = 0;
    }
    else
    {
      unint64_t v7 = PartitionHeaderRowsCellRange & 0xFFFF000000000000;
      uint64_t v8 = PartitionHeaderColumnsCellRange & 0xFF0000;
      uint64_t v9 = PartitionHeaderColumnsCellRange & 0xFFFF00000000;
      uint64_t v10 = 0xFFFFFFLL;
      unint64_t v11 = HIWORD(PartitionHeaderColumnsCellRange);
      if ((PartitionHeaderColumnsCellRange & 0xFFFF00000000) != 0)
      {
        uint64_t v12 = 0;
      }
      else
      {
        uint64_t v9 = 0;
        unint64_t v7 = 0;
        uint64_t v12 = 0xFFFFFFLL;
      }
      BOOL v13 = v11 == 0;
      if (v11)
      {
        unint64_t v14 = v7;
      }
      else
      {
        uint64_t v9 = 0;
        unint64_t v14 = 0;
      }
      if (!v13) {
        uint64_t v10 = v12;
      }
      BOOL v15 = v8 == 16711680;
      if (v8 == 16711680) {
        uint64_t v4 = 0;
      }
      else {
        uint64_t v4 = v9;
      }
      if (v8 == 16711680) {
        unint64_t v6 = 0;
      }
      else {
        unint64_t v6 = v14;
      }
      if (!v15) {
        uint64_t v5 = v10;
      }
    }
  }
  return v6 | v4 | v5;
}

BOOL TSTLayoutExtendedPartitionRangeIntersectsCellRange(void *a1, unint64_t a2)
{
  int v4 = ~a2;
  unint64_t RangeForHint = TSTMasterLayoutGetRangeForHint([a1 masterLayout], objc_msgSend(a1, "layoutHint"));
  BOOL v6 = (*(void *)&v4 & 0xFF0000) != 0 && (unsigned __int16)v4 != 0;
  if (v6)
  {
    unint64_t v7 = 0;
    uint64_t v8 = 16711680;
    uint64_t v9 = 0xFFFFLL;
    if (HIWORD(a2))
    {
      unint64_t v10 = 0;
      if ((a2 & 0xFFFF00000000) == 0) {
        goto LABEL_27;
      }
      unint64_t v7 = 0;
      uint64_t v8 = 16711680;
      uint64_t v9 = 0xFFFFLL;
      if ((_WORD)RangeForHint != 0xFFFF)
      {
        unint64_t v10 = 0;
        if ((RangeForHint & 0xFF0000) == 0xFF0000) {
          goto LABEL_27;
        }
        unint64_t v7 = 0;
        uint64_t v8 = 16711680;
        uint64_t v9 = 0xFFFFLL;
        if (HIWORD(RangeForHint))
        {
          unint64_t v10 = 0;
          if ((RangeForHint & 0xFFFF00000000) != 0)
          {
            uint64_t v9 = 0;
            if (BYTE2(a2) <= BYTE2(RangeForHint)) {
              unsigned int v11 = BYTE2(RangeForHint);
            }
            else {
              unsigned int v11 = BYTE2(a2);
            }
            if ((unsigned __int16)a2 <= (unsigned __int16)RangeForHint) {
              uint64_t v12 = (unsigned __int16)RangeForHint;
            }
            else {
              uint64_t v12 = (unsigned __int16)a2;
            }
            if ((BYTE4(a2) + BYTE2(a2) - 1) >= (BYTE4(RangeForHint)
                                                                                               + BYTE2(RangeForHint)
                                                                                               - 1))
              unsigned int v13 = (BYTE4(RangeForHint) + BYTE2(RangeForHint) - 1);
            else {
              unsigned int v13 = (BYTE4(a2) + BYTE2(a2) - 1);
            }
            unsigned int v14 = (unsigned __int16)(RangeForHint + HIWORD(RangeForHint) - 1);
            if ((unsigned __int16)(a2 + HIWORD(a2) - 1) < v14) {
              unsigned int v14 = (unsigned __int16)(a2 + HIWORD(a2) - 1);
            }
            uint64_t v8 = 0;
            unint64_t v7 = 0;
            unint64_t v10 = 0;
            if (v12 <= v14 && v11 <= v13)
            {
              unint64_t v10 = ((unint64_t)(v14 - v12) << 48) + 0x1000000000000;
              unint64_t v7 = (unint64_t)(unsigned __int16)(v13 - v11 + 1) << 32;
              uint64_t v8 = v11 << 16;
              uint64_t v9 = v12;
            }
          }
          goto LABEL_27;
        }
      }
    }
    unint64_t v10 = 0;
  }
  else
  {
    unint64_t v7 = 0;
    unint64_t v10 = 0;
    uint64_t v8 = 16711680;
    uint64_t v9 = 0xFFFFLL;
  }
LABEL_27:
  unint64_t v15 = v8 | v10 | v9 | v7;
  if ((_WORD)v15 != 0xFFFF && (v15 & 0xFF0000) != 0xFF0000 && HIWORD(v15) && (v15 & 0xFFFF00000000) != 0) {
    return 1;
  }
  PartitionHeaderColumnsCellunint64_t Range = TSTLayoutGetPartitionHeaderColumnsCellRange(a1);
  unint64_t v17 = 0;
  if (!v6)
  {
    unint64_t v20 = 0;
    uint64_t v18 = 16711680;
    uint64_t v19 = 0xFFFFLL;
    goto LABEL_54;
  }
  uint64_t v18 = 16711680;
  uint64_t v19 = 0xFFFFLL;
  if (!HIWORD(a2)) {
    goto LABEL_53;
  }
  unint64_t v20 = 0;
  if ((a2 & 0xFFFF00000000) == 0) {
    goto LABEL_54;
  }
  unint64_t v17 = 0;
  uint64_t v18 = 16711680;
  uint64_t v19 = 0xFFFFLL;
  if ((_WORD)PartitionHeaderColumnsCellRange == 0xFFFF) {
    goto LABEL_53;
  }
  unint64_t v20 = 0;
  if ((PartitionHeaderColumnsCellRange & 0xFF0000) == 0xFF0000) {
    goto LABEL_54;
  }
  unint64_t v17 = 0;
  uint64_t v18 = 16711680;
  uint64_t v19 = 0xFFFFLL;
  if (!HIWORD(PartitionHeaderColumnsCellRange))
  {
LABEL_53:
    unint64_t v20 = 0;
    goto LABEL_54;
  }
  unint64_t v20 = 0;
  if ((PartitionHeaderColumnsCellRange & 0xFFFF00000000) != 0)
  {
    uint64_t v19 = 0;
    if (BYTE2(a2) <= BYTE2(PartitionHeaderColumnsCellRange)) {
      unsigned int v21 = BYTE2(PartitionHeaderColumnsCellRange);
    }
    else {
      unsigned int v21 = BYTE2(a2);
    }
    if ((unsigned __int16)a2 <= (unsigned __int16)PartitionHeaderColumnsCellRange) {
      uint64_t v22 = (unsigned __int16)PartitionHeaderColumnsCellRange;
    }
    else {
      uint64_t v22 = (unsigned __int16)a2;
    }
    if ((BYTE4(a2) + BYTE2(a2) - 1) >= (BYTE4(PartitionHeaderColumnsCellRange)
                                                                                       + BYTE2(PartitionHeaderColumnsCellRange)
                                                                                       - 1))
      unsigned int v23 = (BYTE4(PartitionHeaderColumnsCellRange) + BYTE2(PartitionHeaderColumnsCellRange) - 1);
    else {
      unsigned int v23 = (BYTE4(a2) + BYTE2(a2) - 1);
    }
    unsigned int v24 = (unsigned __int16)(PartitionHeaderColumnsCellRange + HIWORD(PartitionHeaderColumnsCellRange) - 1);
    if ((unsigned __int16)(a2 + HIWORD(a2) - 1) < v24) {
      unsigned int v24 = (unsigned __int16)(a2 + HIWORD(a2) - 1);
    }
    uint64_t v18 = 0;
    unint64_t v17 = 0;
    unint64_t v20 = 0;
    if (v22 <= v24 && v21 <= v23)
    {
      unint64_t v20 = ((unint64_t)(v24 - v22) << 48) + 0x1000000000000;
      unint64_t v17 = (unint64_t)(unsigned __int16)(v23 - v21 + 1) << 32;
      uint64_t v18 = v21 << 16;
      uint64_t v19 = v22;
    }
  }
LABEL_54:
  unint64_t v25 = v18 | v20 | v19 | v17;
  if ((_WORD)v25 != 0xFFFF && (v25 & 0xFF0000) != 0xFF0000 && HIWORD(v25) && (v25 & 0xFFFF00000000) != 0) {
    return 1;
  }
  PartitionHeaderRowsCellunint64_t Range = TSTLayoutGetPartitionHeaderRowsCellRange(a1);
  unint64_t v27 = 0;
  if (v6)
  {
    uint64_t v28 = 16711680;
    uint64_t v29 = 0xFFFFLL;
    if (HIWORD(a2))
    {
      unint64_t v30 = 0;
      if ((a2 & 0xFFFF00000000) == 0) {
        goto LABEL_81;
      }
      unint64_t v27 = 0;
      uint64_t v28 = 16711680;
      uint64_t v29 = 0xFFFFLL;
      if ((_WORD)PartitionHeaderRowsCellRange != 0xFFFF)
      {
        unint64_t v30 = 0;
        if ((PartitionHeaderRowsCellRange & 0xFF0000) == 0xFF0000) {
          goto LABEL_81;
        }
        unint64_t v27 = 0;
        uint64_t v28 = 16711680;
        uint64_t v29 = 0xFFFFLL;
        if (HIWORD(PartitionHeaderRowsCellRange))
        {
          unint64_t v30 = 0;
          if ((PartitionHeaderRowsCellRange & 0xFFFF00000000) != 0)
          {
            uint64_t v29 = 0;
            if (BYTE2(a2) <= BYTE2(PartitionHeaderRowsCellRange)) {
              unsigned int v31 = BYTE2(PartitionHeaderRowsCellRange);
            }
            else {
              unsigned int v31 = BYTE2(a2);
            }
            if ((unsigned __int16)a2 <= (unsigned __int16)PartitionHeaderRowsCellRange) {
              uint64_t v32 = (unsigned __int16)PartitionHeaderRowsCellRange;
            }
            else {
              uint64_t v32 = (unsigned __int16)a2;
            }
            if ((BYTE4(a2) + BYTE2(a2) - 1) >= (BYTE4(PartitionHeaderRowsCellRange)
                                                                                               + BYTE2(PartitionHeaderRowsCellRange)
                                                                                               - 1))
              unsigned int v33 = (BYTE4(PartitionHeaderRowsCellRange) + BYTE2(PartitionHeaderRowsCellRange) - 1);
            else {
              unsigned int v33 = (BYTE4(a2) + BYTE2(a2) - 1);
            }
            unsigned int v34 = (unsigned __int16)(PartitionHeaderRowsCellRange + HIWORD(PartitionHeaderRowsCellRange) - 1);
            if ((unsigned __int16)(a2 + HIWORD(a2) - 1) < v34) {
              unsigned int v34 = (unsigned __int16)(a2 + HIWORD(a2) - 1);
            }
            uint64_t v28 = 0;
            unint64_t v27 = 0;
            unint64_t v30 = 0;
            if (v32 <= v34 && v31 <= v33)
            {
              unint64_t v30 = ((unint64_t)(v34 - v32) << 48) + 0x1000000000000;
              unint64_t v27 = (unint64_t)(unsigned __int16)(v33 - v31 + 1) << 32;
              uint64_t v28 = v31 << 16;
              uint64_t v29 = v32;
            }
          }
          goto LABEL_81;
        }
      }
    }
    unint64_t v30 = 0;
  }
  else
  {
    unint64_t v30 = 0;
    uint64_t v28 = 16711680;
    uint64_t v29 = 0xFFFFLL;
  }
LABEL_81:
  unint64_t v35 = v28 | v30 | v29 | v27;
  if ((_WORD)v35 != 0xFFFF && (v35 & 0xFF0000) != 0xFF0000 && HIWORD(v35) && (v35 & 0xFFFF00000000) != 0) {
    return 1;
  }
  PartitionHeaderCornerCellunint64_t Range = TSTLayoutGetPartitionHeaderCornerCellRange(a1);
  unint64_t v38 = 0;
  if (!v6)
  {
    unint64_t v41 = 0;
    uint64_t v39 = 16711680;
    uint64_t v40 = 0xFFFFLL;
    goto LABEL_109;
  }
  uint64_t v39 = 16711680;
  uint64_t v40 = 0xFFFFLL;
  if (!HIWORD(a2)) {
    goto LABEL_108;
  }
  unint64_t v41 = 0;
  if ((a2 & 0xFFFF00000000) == 0) {
    goto LABEL_109;
  }
  unint64_t v38 = 0;
  uint64_t v39 = 16711680;
  uint64_t v40 = 0xFFFFLL;
  if ((_WORD)PartitionHeaderCornerCellRange == 0xFFFF)
  {
LABEL_108:
    unint64_t v41 = 0;
    goto LABEL_109;
  }
  unint64_t v41 = 0;
  if ((PartitionHeaderCornerCellRange & 0xFF0000) != 0xFF0000)
  {
    unint64_t v38 = 0;
    uint64_t v39 = 16711680;
    uint64_t v40 = 0xFFFFLL;
    if (HIWORD(PartitionHeaderCornerCellRange))
    {
      unint64_t v41 = 0;
      if ((PartitionHeaderCornerCellRange & 0xFFFF00000000) != 0)
      {
        uint64_t v40 = 0;
        if (BYTE2(a2) <= BYTE2(PartitionHeaderCornerCellRange)) {
          unsigned int v42 = BYTE2(PartitionHeaderCornerCellRange);
        }
        else {
          unsigned int v42 = BYTE2(a2);
        }
        if ((unsigned __int16)a2 <= (unsigned __int16)PartitionHeaderCornerCellRange) {
          uint64_t v43 = (unsigned __int16)PartitionHeaderCornerCellRange;
        }
        else {
          uint64_t v43 = (unsigned __int16)a2;
        }
        if ((BYTE4(a2) + BYTE2(a2) - 1) >= (BYTE4(PartitionHeaderCornerCellRange)
                                                                                           + BYTE2(PartitionHeaderCornerCellRange)
                                                                                           - 1))
          unsigned int v44 = (BYTE4(PartitionHeaderCornerCellRange) + BYTE2(PartitionHeaderCornerCellRange) - 1);
        else {
          unsigned int v44 = (BYTE4(a2) + BYTE2(a2) - 1);
        }
        unsigned int v45 = (unsigned __int16)(PartitionHeaderCornerCellRange + HIWORD(PartitionHeaderCornerCellRange) - 1);
        if ((unsigned __int16)(a2 + HIWORD(a2) - 1) < v45) {
          unsigned int v45 = (unsigned __int16)(a2 + HIWORD(a2) - 1);
        }
        uint64_t v39 = 0;
        unint64_t v38 = 0;
        unint64_t v41 = 0;
        if (v43 <= v45 && v42 <= v44)
        {
          unint64_t v41 = ((unint64_t)(v45 - v43) << 48) + 0x1000000000000;
          unint64_t v38 = (unint64_t)(unsigned __int16)(v44 - v42 + 1) << 32;
          uint64_t v39 = v42 << 16;
          uint64_t v40 = v43;
        }
      }
      goto LABEL_109;
    }
    goto LABEL_108;
  }
LABEL_109:
  BOOL result = 0;
  unint64_t v46 = v39 | v41 | v40 | v38;
  if ((_WORD)v46 != 0xFFFF && (v46 & 0xFF0000) != 0xFF0000)
  {
    BOOL v48 = (v46 & 0xFFFF00000000) == 0;
    unint64_t v47 = HIWORD(v46);
    BOOL v48 = v48 || v47 == 0;
    return !v48;
  }
  return result;
}

uint64_t TSTLayoutGetPartitionFirstBodyColumn(void *a1)
{
  uint64_t v2 = (unsigned __int16 *)[a1 masterLayout];
  unsigned int v3 = (TSTMasterLayoutGetRangeForHint((uint64_t)v2, (void *)[a1 layoutHint]) >> 16);
  LODWORD(result) = TSTMasterLayoutGetTableNumberOfHeaderColumns(v2);
  if (v3 <= result) {
    return result;
  }
  else {
    return v3;
  }
}

uint64_t TSTLayoutGetPartitionLastBodyColumn(void *a1)
{
  uint64_t RangeForHint = TSTMasterLayoutGetRangeForHint([a1 masterLayout], objc_msgSend(a1, "layoutHint"));
  return (BYTE4(RangeForHint) + BYTE2(RangeForHint) - 1);
}

uint64_t TSTLayoutGetPartitionFirstBodyRow(void *a1)
{
  uint64_t v2 = (unsigned __int16 *)[a1 masterLayout];
  unsigned int RangeForHint = (unsigned __int16)TSTMasterLayoutGetRangeForHint((uint64_t)v2, (void *)[a1 layoutHint]);
  LODWORD(result) = TSTMasterLayoutGetTableNumberOfHeaderRows(v2);
  if (RangeForHint <= result) {
    return result;
  }
  else {
    return RangeForHint;
  }
}

uint64_t TSTLayoutGetPartitionLastBodyRow(void *a1)
{
  uint64_t v2 = (unsigned __int16 *)[a1 masterLayout];
  uint64_t RangeForHint = TSTMasterLayoutGetRangeForHint([a1 masterLayout], objc_msgSend(a1, "layoutHint"));
  unsigned int v4 = (unsigned __int16)(RangeForHint + HIWORD(RangeForHint) - 1);
  LOWORD(result) = TSTMasterLayoutGetEntireFooterRowsCellRange(v2);
  if (v4 >= (unsigned __int16)result) {
    return (unsigned __int16)result;
  }
  else {
    return v4;
  }
}

unint64_t TSTLayoutGetPartitionNonHeaderRowCellRange(void *a1)
{
  uint64_t v2 = (unsigned __int16 *)[a1 masterLayout];
  unint64_t RangeForHint = TSTMasterLayoutGetRangeForHint((uint64_t)v2, (void *)[a1 layoutHint]);
  unsigned int v4 = RangeForHint;
  unint64_t v5 = RangeForHint >> 16;
  unint64_t v6 = HIDWORD(RangeForHint);
  unint64_t v7 = HIWORD(RangeForHint);
  unsigned int TableNumberOfHeaderColumns = TSTMasterLayoutGetTableNumberOfHeaderColumns(v2);
  unsigned int TableNumberOfHeaderRows = TSTMasterLayoutGetTableNumberOfHeaderRows(v2);
  if ((unsigned __int16)v4 >= TableNumberOfHeaderRows) {
    unint64_t v10 = v7;
  }
  else {
    unint64_t v10 = v7 - TableNumberOfHeaderRows;
  }
  if ((unsigned __int16)v4 >= TableNumberOfHeaderRows) {
    unsigned __int16 v11 = v4;
  }
  else {
    unsigned __int16 v11 = TableNumberOfHeaderRows;
  }
  if (BYTE2(v4) >= TableNumberOfHeaderColumns) {
    unsigned __int16 v12 = v6;
  }
  else {
    unsigned __int16 v12 = v6 - TableNumberOfHeaderColumns;
  }
  unint64_t v13 = (v10 << 48) | ((unint64_t)v12 << 32) | v4;
  if (BYTE2(v4) >= TableNumberOfHeaderColumns) {
    unsigned __int8 v14 = v5;
  }
  else {
    unsigned __int8 v14 = TableNumberOfHeaderColumns;
  }
  return v13 & 0xFFFFFFFFFF000000 | ((unint64_t)v14 << 16) | v11;
}

unint64_t TSTLayoutGetPartitionBodyCellRange(void *a1)
{
  uint64_t v2 = (unsigned __int16 *)[a1 masterLayout];
  unint64_t RangeForHint = TSTMasterLayoutGetRangeForHint((uint64_t)v2, (void *)[a1 layoutHint]);
  unsigned int v4 = RangeForHint;
  unint64_t v5 = RangeForHint >> 16;
  unint64_t v6 = HIDWORD(RangeForHint);
  unint64_t v7 = HIWORD(RangeForHint);
  unsigned int TableNumberOfHeaderColumns = TSTMasterLayoutGetTableNumberOfHeaderColumns(v2);
  unsigned int TableNumberOfHeaderRows = TSTMasterLayoutGetTableNumberOfHeaderRows(v2);
  if ((unsigned __int16)v4 >= TableNumberOfHeaderRows) {
    unsigned int v10 = 0;
  }
  else {
    unsigned int v10 = TableNumberOfHeaderRows;
  }
  if ((unsigned __int16)v4 >= TableNumberOfHeaderRows) {
    unsigned int v11 = v4;
  }
  else {
    unsigned int v11 = TableNumberOfHeaderRows;
  }
  unsigned int v12 = v7 - v10;
  int TableNumberOfFooterRows = TSTMasterLayoutGetTableNumberOfFooterRows(v2);
  int TableNumberOfRows = TSTMasterLayoutGetTableNumberOfRows((uint64_t)v2);
  if ((unsigned __int16)v12 + (unsigned __int16)v11 <= (unsigned __int16)(TableNumberOfRows
                                                                                       - TableNumberOfFooterRows))
    uint64_t v15 = v12;
  else {
    uint64_t v15 = TableNumberOfRows - TableNumberOfFooterRows - v11;
  }
  if (BYTE2(v4) >= TableNumberOfHeaderColumns) {
    unsigned __int16 v16 = v6;
  }
  else {
    unsigned __int16 v16 = v6 - TableNumberOfHeaderColumns;
  }
  unint64_t v17 = ((unint64_t)v16 << 32) | (v15 << 48) | v4;
  if (BYTE2(v4) >= TableNumberOfHeaderColumns) {
    unsigned __int8 v18 = v5;
  }
  else {
    unsigned __int8 v18 = TableNumberOfHeaderColumns;
  }
  return v17 & 0xFFFFFFFFFF000000 | ((unint64_t)v18 << 16) | (unsigned __int16)v11;
}

uint64_t TSTLayoutGetPartitionFooterRowsCellRange(void *a1)
{
  uint64_t v2 = (unsigned __int16 *)[a1 masterLayout];
  EntireFooterRowsCellunint64_t Range = TSTMasterLayoutGetEntireFooterRowsCellRange(v2);
  unint64_t v4 = HIWORD(EntireFooterRowsCellRange);
  if (!HIWORD(EntireFooterRowsCellRange)) {
    return 0xFFFFFFLL;
  }
  unint64_t v6 = EntireFooterRowsCellRange;
  unint64_t RangeForHint = TSTMasterLayoutGetRangeForHint((uint64_t)v2, (void *)[a1 layoutHint]);
  unint64_t v8 = 0;
  uint64_t v9 = 16711680;
  uint64_t v10 = 0xFFFFLL;
  if ((_WORD)RangeForHint == 0xFFFF) {
    goto LABEL_24;
  }
  unint64_t v11 = 0;
  if ((RangeForHint & 0xFF0000) == 0xFF0000) {
    return v9 | v11 | v10 | v8;
  }
  unint64_t v8 = 0;
  uint64_t v9 = 16711680;
  uint64_t v10 = 0xFFFFLL;
  if (!HIWORD(RangeForHint))
  {
LABEL_24:
    unint64_t v11 = 0;
    return v9 | v11 | v10 | v8;
  }
  unint64_t v11 = 0;
  if ((RangeForHint & 0xFFFF00000000) != 0)
  {
    unint64_t v8 = 0;
    uint64_t v9 = 16711680;
    uint64_t v10 = 0xFFFFLL;
    if ((v6 & 0xFFFF00000000) != 0 && (unsigned __int16)v6 != 0xFFFFLL)
    {
      unint64_t v11 = 0;
      if ((v6 & 0xFF0000) != 0xFF0000)
      {
        uint64_t v10 = 0;
        if (BYTE2(RangeForHint) <= BYTE2(v6)) {
          unsigned int v12 = BYTE2(v6);
        }
        else {
          unsigned int v12 = BYTE2(RangeForHint);
        }
        if ((unsigned __int16)RangeForHint <= (unsigned __int16)v6) {
          uint64_t v13 = (unsigned __int16)v6;
        }
        else {
          uint64_t v13 = (unsigned __int16)RangeForHint;
        }
        if ((BYTE4(RangeForHint) + BYTE2(RangeForHint) - 1) >= (BYTE4(v6) + BYTE2(v6) - 1)) {
          unsigned int v14 = (BYTE4(v6) + BYTE2(v6) - 1);
        }
        else {
          unsigned int v14 = (BYTE4(RangeForHint) + BYTE2(RangeForHint) - 1);
        }
        unsigned int v15 = (unsigned __int16)(v6 + v4 - 1);
        if ((unsigned __int16)(RangeForHint + HIWORD(RangeForHint) - 1) < v15) {
          unsigned int v15 = (unsigned __int16)(RangeForHint + HIWORD(RangeForHint) - 1);
        }
        uint64_t v9 = 0;
        unint64_t v8 = 0;
        unint64_t v11 = 0;
        if (v13 <= v15 && v12 <= v14)
        {
          unint64_t v11 = ((unint64_t)(v15 - v13) << 48) + 0x1000000000000;
          unint64_t v8 = (unint64_t)(unsigned __int16)(v14 - v12 + 1) << 32;
          uint64_t v9 = v12 << 16;
          uint64_t v10 = v13;
        }
      }
      return v9 | v11 | v10 | v8;
    }
    goto LABEL_24;
  }
  return v9 | v11 | v10 | v8;
}

uint64_t TSTLayoutIsPartitionAlongTop(void *a1)
{
  return objc_msgSend((id)objc_msgSend(a1, "layoutHint"), "partitionPosition") & 1;
}

uint64_t TSTLayoutIsPartitionAlongBottom(void *a1)
{
  return (objc_msgSend((id)objc_msgSend(a1, "layoutHint"), "partitionPosition") >> 1) & 1;
}

uint64_t TSTLayoutIsPartitionAlongLeft(void *a1)
{
  return (objc_msgSend((id)objc_msgSend(a1, "layoutHint"), "partitionPosition") >> 2) & 1;
}

uint64_t TSTLayoutIsPartitionAlongRight(void *a1)
{
  return (objc_msgSend((id)objc_msgSend(a1, "layoutHint"), "partitionPosition") >> 3) & 1;
}

BOOL TSTLayoutIsPartitionPaginated(void *a1)
{
  return (~objc_msgSend((id)objc_msgSend(a1, "layoutHint"), "partitionPosition") & 0xF) != 0;
}

uint64_t TSTLayoutGetFrozenHeaderColumnsSpace(void *a1)
{
  uint64_t v1 = (void *)[a1 spaceBundle];

  return [v1 frozenHeaderColumnsSpace];
}

uint64_t TSTLayoutGetFrozenHeaderRowsSpace(void *a1)
{
  uint64_t v1 = (void *)[a1 spaceBundle];

  return [v1 frozenHeaderRowsSpace];
}

uint64_t TSTLayoutGetFrozenHeaderCornerSpace(void *a1)
{
  uint64_t v1 = (void *)[a1 spaceBundle];

  return [v1 frozenHeaderCornerSpace];
}

uint64_t TSTLayoutGetRepeatHeaderColumnsSpace(void *a1)
{
  uint64_t v1 = (void *)[a1 spaceBundle];

  return [v1 repeatHeaderColumnsSpace];
}

uint64_t TSTLayoutGetRepeatHeaderRowsSpace(void *a1)
{
  uint64_t v1 = (void *)[a1 spaceBundle];

  return [v1 repeatHeaderRowsSpace];
}

uint64_t TSTLayoutGetRepeatHeaderCornerSpace(void *a1)
{
  uint64_t v1 = (void *)[a1 spaceBundle];

  return [v1 repeatHeaderCornerSpace];
}

double TSTLayoutGetAlignedMaskRectForSpace(TSTLayout *a1, void *a2)
{
  [a2 lockForRead];
  AlignedStrokedouble Frame = TSTLayoutSpaceGetAlignedStrokeFrame((uint64_t)a2);
  double CanvasRectForLayoutRect = TSTLayoutSpaceGetCanvasRectForLayoutRect((uint64_t)a2, AlignedStrokeFrame, v5, v6, v7);
  double v10 = v9;
  double v63 = v11;
  double rect = v12;
  double FrozenHeadersTabOffset = TSTLayoutGetFrozenHeadersTabOffset(a1);
  double v62 = v13;
  unsigned int v14 = (double *)MEMORY[0x263F00148];
  double v16 = *MEMORY[0x263F00148];
  double v15 = *(double *)(MEMORY[0x263F00148] + 8);
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  double v61 = v17;
  int FrozenHeaderColumnsFloating = TSTLayoutGetFrozenHeaderColumnsFloating(a1);
  int FrozenHeaderRowsFloating = TSTLayoutGetFrozenHeaderRowsFloating(a1);
  if ([(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] frozenHeaderColumnsSpace]&& FrozenHeaderColumnsFloating&& ([(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space] == a2|| [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] frozenHeaderRowsSpace] == a2))
  {
    double x = a1->mCanvasVisibleRect.origin.x;
    CGFloat v58 = v10;
    Aligneddouble Frame = TSTLayoutSpaceGetAlignedFrame((uint64_t)[(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] frozenHeaderColumnsSpace]);
    double v51 = v22;
    double v52 = v21;
    CGFloat v23 = CanvasRectForLayoutRect;
    double v25 = v24;
    double v56 = AlignedStrokeFrame;
    double v26 = TSTLayoutSpaceGetAlignedStrokeFrame((uint64_t)[(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] frozenHeaderColumnsSpace]);
    double v27 = v25 + AlignedFrame - v26;
    double CanvasRectForLayoutRect = v23;
    uint64_t v28 = [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] frozenHeaderColumnsSpace];
    double v29 = v27;
    double v10 = v58;
    TSTLayoutSpaceGetCanvasRectForLayoutRect(v28, v26, v52, v29, v51);
    double v31 = FrozenHeadersTabOffset + x + v30;
    v65.origin.double x = v23;
    v65.origin.double y = v58;
    v65.size.CGFloat width = v63;
    v65.size.double height = rect;
    double v16 = v31 - CGRectGetMinX(v65);
    AlignedStrokedouble Frame = v56;
  }
  if ([(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] frozenHeaderRowsSpace])
  {
    int v32 = FrozenHeaderRowsFloating;
  }
  else
  {
    int v32 = 0;
  }
  if (v32 == 1
    && ([(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space] == a2
     || [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] frozenHeaderColumnsSpace] == a2))
  {
    double y = a1->mCanvasVisibleRect.origin.y;
    CGFloat v33 = TSTLayoutSpaceGetAlignedFrame((uint64_t)[(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] frozenHeaderRowsSpace]);
    double v53 = v34;
    double v55 = v33;
    CGFloat v59 = v10;
    double v36 = v35;
    CGFloat v37 = CanvasRectForLayoutRect;
    double v39 = v38;
    TSTLayoutSpaceGetAlignedStrokeFrame((uint64_t)[(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] frozenHeaderRowsSpace]);
    double v40 = AlignedStrokeFrame;
    double v42 = v41;
    double v43 = v39 + v36 - v41;
    double CanvasRectForLayoutRect = v37;
    uint64_t v44 = [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] frozenHeaderRowsSpace];
    double v45 = v42;
    AlignedStrokedouble Frame = v40;
    double v46 = v43;
    double v10 = v59;
    TSTLayoutSpaceGetCanvasRectForLayoutRect(v44, v55, v45, v53, v46);
    v66.size.CGFloat width = v63;
    double v48 = v62 + v61 + y + v47;
    v66.origin.double x = v37;
    v66.origin.double y = v59;
    v66.size.double height = rect;
    double v15 = v48 - CGRectGetMinY(v66);
  }
  if (v16 != *v14 || v15 != v14[1]) {
    AlignedStrokedouble Frame = TSTLayoutSpaceGetLayoutRectForCanvasRect((uint64_t)a2, CanvasRectForLayoutRect + v16, v10 + v15, v63 - v16, rect - v15);
  }
  [a2 unlock];
  return AlignedStrokeFrame;
}

double TSTLayoutGetFrozenHeadersTabOffset(TSTLayout *a1)
{
  double v2 = *MEMORY[0x263F00148];
  [[(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space] viewScale];
  if (a1->mTabsVisible)
  {
    double v4 = v3;
    TSTLayoutGetTopLeftTabCanvasFrame((double *)a1);
    v14.origin.CGFloat x = TSTLayoutSpaceGetLayoutRectForCanvasRect((uint64_t)[(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space], v5, v6, v7, v8);
    CGFloat x = v14.origin.x;
    CGFloat y = v14.origin.y;
    CGFloat width = v14.size.width;
    CGFloat height = v14.size.height;
    double v2 = 6.0 / v4 + CGRectGetWidth(v14);
    v15.origin.CGFloat x = x;
    v15.origin.CGFloat y = y;
    v15.size.CGFloat width = width;
    v15.size.CGFloat height = height;
    CGRectGetHeight(v15);
  }
  return v2;
}

uint64_t TSTLayoutGetFrozenHeaderColumnsFloating(TSTLayout *a1)
{
  uint64_t result = objc_msgSend(+[TSTConfiguration sharedTableConfiguration](TSTConfiguration, "sharedTableConfiguration"), "supportsFrozenHeaders");
  if (result)
  {
    BOOL v3 = [(TSTLayout *)a1 inFindReplaceMode];
    BOOL v4 = [(TSTLayout *)a1 isZoomedEditing];
    uint64_t v5 = [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space];
    double FrozenHeadersTabOffset = TSTLayoutGetFrozenHeadersTabOffset(a1);
    CanvasStrokedouble Frame = TSTLayoutSpaceGetCanvasStrokeFrame(v5);
    uint64_t result = 0;
    if (!v3 && !v4)
    {
      double v8 = CanvasStrokeFrame;
      uint64_t result = TSTLayoutGetFrozenHeadersBodyVisible(a1);
      if (result) {
        return v8 < FrozenHeadersTabOffset + a1->mCanvasVisibleRect.origin.x;
      }
    }
  }
  return result;
}

uint64_t TSTLayoutGetFrozenHeaderRowsFloating(TSTLayout *a1)
{
  uint64_t result = objc_msgSend(+[TSTConfiguration sharedTableConfiguration](TSTConfiguration, "sharedTableConfiguration"), "supportsFrozenHeaders");
  if (result)
  {
    BOOL v3 = [(TSTLayout *)a1 inFindReplaceMode];
    BOOL v4 = [(TSTLayout *)a1 isZoomedEditing];
    int v5 = [(TSTEditingState *)[(TSTTableInfo *)[(TSTLayout *)a1 tableInfo] editingState] editingMode];
    uint64_t v6 = [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space];
    TSTLayoutGetFrozenHeadersTabOffset(a1);
    double v8 = v7;
    if (a1->mTableNameVisible) {
      TSTLayoutGetCanvasStrokeFrameForTableName(a1);
    }
    else {
      TSTLayoutSpaceGetCanvasStrokeFrame(v6);
    }
    double v10 = v9;
    uint64_t result = 0;
    if (!v3 && !v4 && v5 != 7)
    {
      uint64_t result = TSTLayoutGetFrozenHeadersBodyVisible(a1);
      if (result) {
        return v10 < v8 + a1->mCanvasVisibleRect.origin.y;
      }
    }
  }
  return result;
}

double TSTLayoutGetCanvasVisibleRect(uint64_t a1)
{
  return *(double *)(a1 + 320);
}

uint64_t __TSTLayoutUpdateTransformToCanvas_block_invoke(_OWORD *a1, void *a2)
{
  long long v2 = a1[3];
  v4[0] = a1[2];
  v4[1] = v2;
  v4[2] = a1[4];
  [a2 setTransformToCanvas:v4];
  return 0;
}

double TSTLayoutGetTransformToCanvas@<D0>(void *a1@<X0>, _OWORD *a2@<X8>)
{
  BOOL v3 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");
  if (v3)
  {
    [v3 transformToCanvas];
  }
  else
  {
    double result = 0.0;
    a2[1] = 0u;
    a2[2] = 0u;
    *a2 = 0u;
  }
  return result;
}

double TSTLayoutGetTransformToDevice@<D0>(void *a1@<X0>, _OWORD *a2@<X8>)
{
  BOOL v3 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");
  if (v3)
  {
    [v3 transformToDevice];
  }
  else
  {
    double result = 0.0;
    a2[1] = 0u;
    a2[2] = 0u;
    *a2 = 0u;
  }
  return result;
}

uint64_t TSTLayoutSetViewScale(void *a1, double a2)
{
  BOOL v3 = (void *)[a1 spaceBundle];
  v5[0] = MEMORY[0x263EF8330];
  v5[1] = 3221225472;
  void v5[2] = __TSTLayoutSetViewScale_block_invoke;
  v5[3] = &__block_descriptor_40_e24_B16__0__TSTLayoutSpace_8l;
  *(double *)&v5[4] = a2;
  return [v3 performActionOnEachLayoutSpace:v5];
}

uint64_t __TSTLayoutSetViewScale_block_invoke(uint64_t a1, void *a2)
{
  return 0;
}

uint64_t TSTLayoutGetViewScale(void *a1)
{
  uint64_t v1 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");

  return [v1 viewScale];
}

double TSTLayoutGetRectForCanvasRect(void *a1, double a2, double a3, double a4, double a5)
{
  uint64_t v9 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");

  return TSTLayoutSpaceGetLayoutRectForCanvasRect(v9, a2, a3, a4, a5);
}

double TSTLayoutGetPointForCanvasPoint(void *a1, double a2, double a3)
{
  uint64_t v5 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");

  return TSTLayoutSpaceGetLayoutPointForCanvasPoint(v5, a2, a3);
}

double TSTLayoutGetCanvasRectForRect(void *a1, double a2, double a3, double a4, double a5)
{
  uint64_t v9 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");

  return TSTLayoutSpaceGetCanvasRectForLayoutRect(v9, a2, a3, a4, a5);
}

double TSTLayoutGetCanvasPointForPoint(void *a1, double a2, double a3)
{
  uint64_t v5 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");

  return TSTLayoutSpaceGetCanvasPointForLayoutPoint(v5, a2, a3);
}

double TSTLayoutGetCanvasFrame(void *a1)
{
  uint64_t v1 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");

  return TSTLayoutSpaceGetCanvasFrame(v1);
}

double TSTLayoutGetCanvasStrokeFrame(void *a1)
{
  uint64_t v1 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");

  return TSTLayoutSpaceGetCanvasStrokeFrame(v1);
}

uint64_t TSTLayoutGetTabsVisible(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 385);
}

void TSTLayoutGetTopLeftTabCanvasFrame(double *a1)
{
  uint64_t v2 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");
  AlignedStrokedouble Frame = TSTLayoutGetAlignedStrokeFrame(a1);
  double v5 = v4;
  double v7 = v6;
  double v9 = v8;
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), "viewScale");
  double v11 = v10;
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  double v33 = v12;
  double v13 = v5 - v12;
  double CanvasRectForLayoutRect = TSTLayoutSpaceGetCanvasRectForLayoutRect(v2, AlignedStrokeFrame - 31.0 / v11, v13 - 31.0 / v11, 25.0 / v11, 25.0 / v11);
  double v16 = v15;
  double v17 = TSTLayoutSpaceGetCanvasRectForLayoutRect(v2, AlignedStrokeFrame, v13, v7, v9);
  double v22 = a1[40];
  double v21 = a1[41];
  if (CanvasRectForLayoutRect < v22)
  {
    CGFloat v23 = v17;
    CGFloat v24 = v18;
    CGFloat v25 = v19;
    CGFloat v26 = v20;
    CGFloat MaxX = CGRectGetMaxX(*(CGRect *)&v17);
    double v18 = v24;
    double v20 = v26;
    double v19 = v25;
    BOOL v28 = v22 < MaxX;
    double v17 = v23;
    if (!v28)
    {
      v34.origin.CGFloat x = v23;
      v34.origin.CGFloat y = v24;
      v34.size.CGFloat width = v25;
      v34.size.CGFloat height = v26;
      CGRectGetMaxX(v34);
      double v18 = v24;
      double v20 = v26;
      double v19 = v25;
      double v17 = v23;
    }
  }
  if (v16 < v21)
  {
    CGFloat v29 = v17;
    CGFloat v30 = v18;
    CGFloat v31 = v19;
    CGFloat v32 = v20;
    if (v21 >= v33 + CGRectGetMaxY(*(CGRect *)&v17))
    {
      v35.origin.CGFloat x = v29;
      v35.origin.CGFloat y = v30;
      v35.size.CGFloat width = v31;
      v35.size.CGFloat height = v32;
      CGRectGetMaxY(v35);
    }
  }
}

double TSTLayoutGetAlignedStrokeFrame(void *a1)
{
  uint64_t v6 = 0;
  double v7 = (double *)&v6;
  uint64_t v8 = 0x5012000000;
  double v9 = __Block_byref_object_copy__30;
  double v10 = __Block_byref_object_dispose__30;
  double v11 = &unk_22389B221;
  long long v1 = *(_OWORD *)(MEMORY[0x263F001A0] + 16);
  long long v12 = *MEMORY[0x263F001A0];
  long long v13 = v1;
  uint64_t v2 = (void *)[a1 spaceBundle];
  v5[0] = MEMORY[0x263EF8330];
  v5[1] = 3221225472;
  void v5[2] = __TSTLayoutGetAlignedStrokeFrame_block_invoke;
  v5[3] = &unk_2646B3B60;
  v5[4] = &v6;
  [v2 performActionOnEachLayoutSpace:v5];
  double v3 = v7[6];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_2237E6C14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

double TSTLayoutGetTopRightTabCanvasFrame(double *a1)
{
  uint64_t v2 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");
  AlignedStrokedouble Frame = TSTLayoutGetAlignedStrokeFrame(a1);
  double v5 = v4;
  double v7 = v6;
  double v9 = v8;
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), "viewScale");
  double v11 = v10;
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  double v13 = v5 - v12;
  if (objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "isDynamicallyColumnTabResizing"))
  {
    objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "dynamicColumnTabSize");
    double v7 = v14;
  }
  v29.origin.CGFloat x = AlignedStrokeFrame;
  v29.origin.CGFloat y = v13;
  v29.size.CGFloat width = v7;
  v29.size.CGFloat height = v9;
  CGFloat MaxX = CGRectGetMaxX(v29);
  double CanvasRectForLayoutRect = TSTLayoutSpaceGetCanvasRectForLayoutRect(v2, 6.0 / v11 + MaxX, v13 + -31.0 / v11, 25.0 / v11, 25.0 / v11);
  double v18 = v17;
  double v19 = TSTLayoutSpaceGetCanvasRectForLayoutRect(v2, AlignedStrokeFrame, v13, v7, v9);
  double v23 = a1[41];
  if (v18 < v23)
  {
    CGFloat v24 = v19;
    CGFloat v25 = v20;
    CGFloat v26 = v21;
    CGFloat v27 = v22;
    if (v23 >= CGRectGetMaxY(*(CGRect *)&v19))
    {
      v30.origin.CGFloat x = v24;
      v30.origin.CGFloat y = v25;
      v30.size.CGFloat width = v26;
      v30.size.CGFloat height = v27;
      CGRectGetMaxY(v30);
    }
  }
  return CanvasRectForLayoutRect;
}

double TSTLayoutGetBottomLeftTabCanvasFrame(double *a1)
{
  uint64_t v2 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");
  AlignedStrokedouble Frame = TSTLayoutGetAlignedStrokeFrame(a1);
  double v5 = v4;
  double v7 = v6;
  double v9 = v8;
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), "viewScale");
  double v11 = v10;
  if (objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "isDynamicallyRowTabResizing"))
  {
    objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "dynamicRowTabSize");
    double v9 = v12;
  }
  v25.origin.CGFloat x = AlignedStrokeFrame;
  v25.origin.CGFloat y = v5;
  v25.size.CGFloat width = v7;
  v25.size.CGFloat height = v9;
  CGFloat MaxY = CGRectGetMaxY(v25);
  double CanvasRectForLayoutRect = TSTLayoutSpaceGetCanvasRectForLayoutRect(v2, AlignedStrokeFrame + -31.0 / v11, 6.0 / v11 + MaxY, 25.0 / v11, 25.0 / v11);
  double v15 = TSTLayoutSpaceGetCanvasRectForLayoutRect(v2, AlignedStrokeFrame, v5, v7, v9);
  double v19 = a1[40];
  if (CanvasRectForLayoutRect < v19)
  {
    CGFloat v20 = v15;
    CGFloat v21 = v16;
    CGFloat v22 = v17;
    CGFloat v23 = v18;
    double CanvasRectForLayoutRect = a1[40];
    if (v19 >= CGRectGetMaxX(*(CGRect *)&v15))
    {
      v26.origin.CGFloat x = v20;
      v26.origin.CGFloat y = v21;
      v26.size.CGFloat width = v22;
      v26.size.CGFloat height = v23;
      return CGRectGetMaxX(v26);
    }
  }
  return CanvasRectForLayoutRect;
}

double TSTLayoutGetBottomRightTabCanvasFrame(void *a1)
{
  uint64_t v2 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");
  AlignedStrokedouble Frame = TSTLayoutGetAlignedStrokeFrame(a1);
  CGFloat v5 = v4;
  CGFloat v7 = v6;
  CGFloat v9 = v8;
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), "viewScale");
  double v11 = v10;
  if (objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "isDynamicallyColumnTabResizing"))
  {
    objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "dynamicColumnTabSize");
    CGFloat v7 = v12;
  }
  if (objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "isDynamicallyRowTabResizing"))
  {
    objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "dynamicRowTabSize");
    CGFloat v9 = v13;
  }
  v18.origin.CGFloat x = AlignedStrokeFrame;
  v18.origin.CGFloat y = v5;
  v18.size.CGFloat width = v7;
  v18.size.CGFloat height = v9;
  double v14 = 6.0 / v11 + CGRectGetMaxX(v18);
  v19.origin.CGFloat x = AlignedStrokeFrame;
  v19.origin.CGFloat y = v5;
  v19.size.CGFloat width = v7;
  v19.size.CGFloat height = v9;
  double v15 = 6.0 / v11 + CGRectGetMaxY(v19);

  return TSTLayoutSpaceGetCanvasRectForLayoutRect(v2, v14, v15, 25.0 / v11, 25.0 / v11);
}

double TSTLayoutGetColumnTabsRangeFrame(TSTLayout *a1, unint64_t a2)
{
  [[(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space] viewScale];
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  AlignedOverrideFrameForunint64_t Range = *MEMORY[0x263F001A8];
  if (HIWORD(a2) && (a2 & 0xFFFF00000000) != 0) {
    AlignedOverrideFrameForunint64_t Range = TSTLayoutGetAlignedOverrideFrameForRange(a1, a2, 1.0);
  }
  TSTLayoutGetVisibleRect((double *)a1);
  return AlignedOverrideFrameForRange;
}

double TSTLayoutGetAlignedOverrideFrameForRange(TSTLayout *a1, unint64_t a2, double a3)
{
  unsigned int v3 = BYTE2(a2);
  if (BYTE2(a2) == 255) {
    unsigned int v3 = -1;
  }
  uint64_t v4 = WORD2(a2) + v3 - 1;
  if (!WORD2(a2)) {
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  if ((unsigned __int16)a2 == 0xFFFF) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = (unsigned __int16)a2;
  }
  unint64_t v6 = v3 | ((unint64_t)v5 << 32);
  uint64_t v7 = ((a2 >> 16) & 0xFFFF00000000) + (v5 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0) {
    uint64_t v7 = 0xFFFFFFFF00000000;
  }
  v9[0] = MEMORY[0x263EF8330];
  v9[1] = 3221225472;
  _OWORD v9[2] = __TSTLayoutGetAlignedOverrideFrameForGridRange_block_invoke;
  v9[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__32__0__TSTLayoutSpace_8______II____II__16l;
  *(double *)&v9[4] = a3;
  return TSTLayoutGetArbitraryRectAcrossSpacesForGridRange(a1, v6, v4 | v7, (uint64_t)v9);
}

double TSTLayoutGetVisibleRect(double *a1)
{
  double v1 = a1[40];
  double v2 = a1[41];
  double v3 = a1[42];
  double v4 = a1[43];
  uint64_t v5 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");

  return TSTLayoutSpaceGetLayoutRectForCanvasRect(v5, v1, v2, v3, v4);
}

void TSTLayoutGetColumnTabsCanvasFrame(void *a1)
{
}

void TSTLayoutGetColumnTabsCanvasFrameAndAdjustment(void *a1, double *a2)
{
  AlignedStrokedouble Frame = TSTLayoutGetAlignedStrokeFrame(a1);
  double v6 = v5;
  double v8 = v7;
  CGFloat v36 = v9;
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), "viewScale");
  double v11 = v10;
  uint64_t v12 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  double v14 = v13;
  if (objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "isDynamicallyColumnTabResizing"))
  {
    objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "dynamicColumnTabSize");
    double v8 = v15;
  }
  double v16 = 2.0 / v11;
  double v17 = AlignedStrokeFrame - 2.0 / v11;
  double v18 = v6 - v14;
  double v33 = v11;
  double v19 = 29.0 / v11;
  CGFloat v35 = v6;
  double v20 = v18 - 29.0 / v11;
  double v21 = 2.0 / v11 + 2.0;
  CGFloat v22 = v8;
  double v23 = v21 + v8;
  double VisibleRect = TSTLayoutGetVisibleRect((double *)a1);
  double v26 = v25;
  double v27 = VisibleRect - (v17 - v19);
  BOOL v28 = v17 - v19 < VisibleRect;
  double v29 = 0.0;
  if (v28) {
    double v29 = v27;
  }
  double v34 = v29;
  double v30 = v23 - v29;
  double v31 = -0.0;
  if (v28) {
    double v31 = v27;
  }
  double v32 = v31;
  if (v20 < v16 + v25)
  {
    v37.origin.CGFloat x = AlignedStrokeFrame;
    v37.origin.CGFloat y = v35;
    v37.size.CGFloat height = v36;
    v37.size.CGFloat width = v22;
    double v20 = v16 + v26;
    if (v26 >= CGRectGetMaxY(v37))
    {
      v38.origin.CGFloat x = AlignedStrokeFrame;
      v38.origin.CGFloat y = v35;
      v38.size.CGFloat height = v36;
      v38.size.CGFloat width = v22;
      double v20 = v16 + CGRectGetMaxY(v38);
    }
  }
  if (v30 <= 0.0)
  {
    if (!a2) {
      return;
    }
    goto LABEL_14;
  }
  TSTLayoutSpaceGetCanvasRectForLayoutRect(v12, v17 + v32, v20, v30, 22.0 / v33);
  if (a2) {
LABEL_14:
  }
    *a2 = v34;
}

void TSTLayoutGetRowTabsRangeFrame(TSTLayout *a1, unint64_t a2)
{
  if (HIWORD(a2) && (a2 & 0xFFFF00000000) != 0) {
    TSTLayoutGetAlignedOverrideFrameForRange(a1, a2, 1.0);
  }
  TSTLayoutGetVisibleRect((double *)a1);
}

void TSTLayoutGetRowTabsCanvasFrame(void *a1)
{
}

void TSTLayoutGetRowTabsCanvasFrameAndAdjustment(void *a1, double *a2)
{
  AlignedStrokedouble Frame = TSTLayoutGetAlignedStrokeFrame(a1);
  double v6 = v5;
  CGFloat v32 = v7;
  double v9 = v8;
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), "viewScale");
  double v11 = v10;
  uint64_t v12 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  double v14 = v13;
  if (objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "isDynamicallyRowTabResizing"))
  {
    objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "dynamicRowTabSize");
    double v9 = v15;
  }
  unsigned int v16 = TSTMasterLayoutGetTableNumberOfRows([a1 masterLayout]) >> 4;
  if (v16 <= 0x270) {
    double v17 = 24.0;
  }
  else {
    double v17 = 28.0;
  }
  if (v16 <= 0x270) {
    double v18 = 1.0;
  }
  else {
    double v18 = -3.0;
  }
  double v30 = v17;
  CGFloat v31 = v6;
  double v19 = AlignedStrokeFrame - (v17 + 6.0) / v11;
  double v33 = v14 + 2.0 / v11 + 2.0 + v9;
  double v34 = v6 - v14 - 2.0 / v11;
  double VisibleRect = TSTLayoutGetVisibleRect((double *)a1);
  double v22 = v21;
  double v23 = v18 / v11;
  CGFloat v24 = v9;
  double v25 = VisibleRect + v23;
  if (v19 < VisibleRect + v23)
  {
    double v26 = VisibleRect;
    v35.origin.CGFloat x = AlignedStrokeFrame;
    v35.origin.CGFloat y = v31;
    v35.size.CGFloat width = v32;
    v35.size.CGFloat height = v24;
    double v19 = v25;
    if (v26 >= CGRectGetMaxX(v35))
    {
      v36.origin.CGFloat x = AlignedStrokeFrame;
      v36.origin.CGFloat y = v31;
      v36.size.CGFloat width = v32;
      v36.size.CGFloat height = v24;
      double v19 = v23 + CGRectGetMaxX(v36);
    }
  }
  double v27 = v34 + -29.0 / v11;
  double v28 = v22 - v27;
  if (v27 >= v22) {
    double v29 = 0.0;
  }
  else {
    double v29 = v22 - v27;
  }
  if (v33 - v29 <= 0.0)
  {
    if (!a2) {
      return;
    }
    goto LABEL_21;
  }
  if (v27 >= v22) {
    double v28 = -0.0;
  }
  TSTLayoutSpaceGetCanvasRectForLayoutRect(v12, v19, v34 + v28, v30 / v11, v33 - v29);
  if (a2) {
LABEL_21:
  }
    *a2 = v29;
}

double TSTLayoutGetTextLayerFrame(TSTLayout *a1)
{
  double Frame = TSTLayoutSpaceGetFrame((uint64_t)[(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space]);
  double v4 = v3;
  double v6 = v5;
  double v8 = v7;
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  double v10 = v4 - v9;
  double v11 = [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space];

  return TSTLayoutSpaceGetCanvasRectForLayoutRect((uint64_t)v11, Frame, v10, v6, v8);
}

double TSTLayoutGetFrame(void *a1)
{
  uint64_t v1 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");

  return TSTLayoutSpaceGetFrame(v1);
}

void TSTLayoutGetTabsWidthOffset(void *a1)
{
  double Frame = TSTLayoutSpaceGetFrame(objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"));
  double v4 = v3;
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  double v6 = v4 - v5;
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), "viewScale");
  TSTLayoutSpaceGetCanvasRectForLayoutRect(objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), (Frame + -31.0) / v7, (v6 + -31.0) / v7, 25.0 / v7, 25.0 / v7);
}

void TSTLayoutGetTabsHeightOffset(void *a1)
{
  double Frame = TSTLayoutSpaceGetFrame(objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"));
  double v4 = v3;
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  double v6 = v4 - v5;
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), "viewScale");
  TSTLayoutSpaceGetCanvasRectForLayoutRect(objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), (Frame + -31.0) / v7, (v6 + -31.0) / v7, 25.0 / v7, 25.0 / v7);
}

double TSTLayoutGetCanvasFrozenHeaderColumnsOffset(TSTLayout *a1)
{
  uint64_t v2 = [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space];
  double x = a1->mCanvasVisibleRect.origin.x;
  if (a1->mTabsVisible) {
    double FrozenHeadersTabOffset = TSTLayoutGetFrozenHeadersTabOffset(a1);
  }
  else {
    double FrozenHeadersTabOffset = *MEMORY[0x263F00148];
  }
  double v5 = x + FrozenHeadersTabOffset;
  TSTLayoutSpaceGetCanvasStrokeFrame(v2);
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  return v5;
}

double TSTLayoutGetCanvasFrozenHeaderRowsOffset(TSTLayout *a1)
{
  uint64_t v2 = [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space];
  if (a1->mTabsVisible) {
    TSTLayoutGetFrozenHeadersTabOffset(a1);
  }
  CanvasStrokedouble Frame = TSTLayoutSpaceGetCanvasStrokeFrame(v2);
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  return CanvasStrokeFrame;
}

double TSTLayoutGetCanvasFrozenHeaderCornerOffset(TSTLayout *a1)
{
  uint64_t v2 = [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space];
  double x = a1->mCanvasVisibleRect.origin.x;
  double y = a1->mCanvasVisibleRect.origin.y;
  if (a1->mTabsVisible)
  {
    double FrozenHeadersTabOffset = TSTLayoutGetFrozenHeadersTabOffset(a1);
  }
  else
  {
    double FrozenHeadersTabOffset = *MEMORY[0x263F00148];
    double v6 = *(double *)(MEMORY[0x263F00148] + 8);
  }
  CanvasStrokedouble Frame = x + FrozenHeadersTabOffset;
  double v8 = y + v6;
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  double v10 = v8 + v9;
  if (CanvasStrokeFrame < TSTLayoutSpaceGetCanvasStrokeFrame(v2)) {
    CanvasStrokedouble Frame = TSTLayoutSpaceGetCanvasStrokeFrame(v2);
  }
  TSTLayoutSpaceGetCanvasStrokeFrame(v2);
  if (v10 < v11) {
    TSTLayoutSpaceGetCanvasStrokeFrame(v2);
  }
  return CanvasStrokeFrame;
}

CGAffineTransform *TSTLayoutGetFrozenHeaderColumnsTransformToLayout@<X0>(TSTLayout *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space];
  double CanvasFrozenHeaderColumnsOffset = TSTLayoutGetCanvasFrozenHeaderColumnsOffset(a1);
  double LayoutPointForCanvasPoint = TSTLayoutSpaceGetLayoutPointForCanvasPoint(v4, CanvasFrozenHeaderColumnsOffset, v6);
  double v8 = fmax(LayoutPointForCanvasPoint - TSTLayoutSpaceGetAlignedStrokeFrame(v4), 0.0);
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;

  return CGAffineTransformMakeTranslation((CGAffineTransform *)a2, v8, 0.0);
}

CGAffineTransform *TSTLayoutGetFrozenTableNameTransformToLayout@<X0>(TSTLayout *a1@<X0>, CGAffineTransform *a2@<X8>)
{
  double AlignedStrokeFrameForTableNameBorder = TSTLayoutSpaceGetAlignedStrokeFrameForTableNameBorder([(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space]);
  TSTLayoutSpaceGetCanvasRectForLayoutRect((uint64_t)[(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space], AlignedStrokeFrameForTableNameBorder, v5, v6, v7);
  double v9 = a1->mCanvasVisibleRect.origin.y - v8;
  if (a1->mTabsVisible)
  {
    TSTLayoutGetFrozenHeadersTabOffset(a1);
    double v9 = v9 + v10;
  }
  double v11 = fmax(v9, 0.0);

  return CGAffineTransformMakeTranslation(a2, 0.0, v11);
}

double TSTLayoutGetAlignedStrokeFrameForTableNameBorder(void *a1)
{
  uint64_t v1 = (TSTLayoutSpace *)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");

  return TSTLayoutSpaceGetAlignedStrokeFrameForTableNameBorder(v1);
}

CGAffineTransform *TSTLayoutGetFrozenHeaderRowsTransformToLayout@<X0>(TSTLayout *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space];
  double CanvasFrozenHeaderRowsOffset = TSTLayoutGetCanvasFrozenHeaderRowsOffset(a1);
  TSTLayoutSpaceGetLayoutPointForCanvasPoint(v4, CanvasFrozenHeaderRowsOffset, v6);
  double v8 = v7;
  TSTLayoutSpaceGetAlignedStrokeFrame(v4);
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  double v10 = v8 - v9;
  BOOL v11 = v8 - v9 < 0.0;
  double v12 = 0.0;
  if (!v11) {
    double v12 = v10;
  }

  return CGAffineTransformMakeTranslation((CGAffineTransform *)a2, 0.0, v12);
}

CGAffineTransform *TSTLayoutGetFrozenHeaderCornerTransformToLayout@<X0>(TSTLayout *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space];
  double CanvasFrozenHeaderCornerOffset = TSTLayoutGetCanvasFrozenHeaderCornerOffset(a1);
  double LayoutPointForCanvasPoint = TSTLayoutSpaceGetLayoutPointForCanvasPoint(v4, CanvasFrozenHeaderCornerOffset, v6);
  double v9 = v8;
  double v10 = LayoutPointForCanvasPoint - TSTLayoutSpaceGetAlignedStrokeFrame(v4);
  if (v10 < 0.0) {
    double v10 = 0.0;
  }
  double v12 = v9 - v11;
  if (v12 < 0.0) {
    double v12 = 0.0;
  }
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;

  return CGAffineTransformMakeTranslation((CGAffineTransform *)a2, v10, v12);
}

BOOL TSTLayoutGetFrozenHeadersBodyVisible(TSTLayout *a1)
{
  uint64_t v2 = [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space];
  double x = a1->mCanvasVisibleRect.origin.x;
  double y = a1->mCanvasVisibleRect.origin.y;
  CGFloat width = a1->mCanvasVisibleRect.size.width;
  CGFloat height = a1->mCanvasVisibleRect.size.height;
  double FrozenHeadersTabOffset = TSTLayoutGetFrozenHeadersTabOffset(a1);
  double v9 = v8;
  double v10 = x + TSTLayoutSpaceGetHeaderColumnsWidth(v2) + FrozenHeadersTabOffset;
  double HeaderRowsHeight = TSTLayoutSpaceGetHeaderRowsHeight(v2);
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  double v13 = y + v9 + HeaderRowsHeight + v12;
  CanvasStrokedouble Frame = TSTLayoutSpaceGetCanvasStrokeFrame((uint64_t)v2);
  double v18 = v10;
  double v19 = v13;
  CGFloat v20 = width;
  CGFloat v21 = height;

  return CGRectIntersectsRect(*(CGRect *)&CanvasStrokeFrame, *(CGRect *)&v18);
}

uint64_t TSTLayoutGetFrozenHeaderColumnsEnabled(void *a1)
{
  uint64_t result = objc_msgSend(+[TSTConfiguration sharedTableConfiguration](TSTConfiguration, "sharedTableConfiguration"), "supportsFrozenHeaders");
  if (result)
  {
    double v3 = (unsigned __int16 *)[a1 masterLayout];
    EntireHeaderColumnsCellunint64_t Range = TSTMasterLayoutGetEntireHeaderColumnsCellRange(v3);
    BOOL IsEntireCellRangeHidden = TSTMasterLayoutIsEntireCellRangeHidden(v3, EntireHeaderColumnsCellRange);
    if ((objc_msgSend((id)objc_msgSend(a1, "layoutHint"), "partitionPosition") & 1) != 0
      && (objc_msgSend((id)objc_msgSend(a1, "layoutHint"), "partitionPosition") & 4) != 0)
    {
      uint64_t result = TSTMasterLayoutGetHeaderColumnsFrozen(v3);
      if (result) {
        return TSTMasterLayoutGetTableNumberOfHeaderColumns(v3) && !IsEntireCellRangeHidden;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t TSTLayoutGetTableNameVisible(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 387);
}

double TSTLayoutGetCanvasStrokeFrameForTableName(void *a1)
{
  uint64_t v2 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");
  double StrokeFrameForTableNameBorder = TSTLayoutSpaceGetStrokeFrameForTableNameBorder((TSTLayoutSpace *)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"));

  return TSTLayoutSpaceGetCanvasRectForLayoutRect(v2, StrokeFrameForTableNameBorder, v4, v5, v6);
}

uint64_t TSTLayoutGetFrozenHeaderRowsEnabled(void *a1)
{
  uint64_t result = objc_msgSend(+[TSTConfiguration sharedTableConfiguration](TSTConfiguration, "sharedTableConfiguration"), "supportsFrozenHeaders");
  if (result)
  {
    double v3 = (unsigned __int16 *)[a1 masterLayout];
    EntireHeaderRowsCellunint64_t Range = TSTMasterLayoutGetEntireHeaderRowsCellRange(v3);
    BOOL IsEntireCellRangeHidden = TSTMasterLayoutIsEntireCellRangeHidden(v3, EntireHeaderRowsCellRange);
    if ((objc_msgSend((id)objc_msgSend(a1, "layoutHint"), "partitionPosition") & 1) != 0
      && (objc_msgSend((id)objc_msgSend(a1, "layoutHint"), "partitionPosition") & 4) != 0)
    {
      uint64_t result = TSTMasterLayoutGetHeaderRowsFrozen(v3);
      if (result) {
        return TSTMasterLayoutGetTableNumberOfHeaderRows(v3) && !IsEntireCellRangeHidden;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

unint64_t TSTLayoutSetCanvasVisibleRect(uint64_t a1, double a2, double a3, double a4, double a5)
{
  *(double *)(a1 + 320) = a2;
  *(double *)(a1 + 328) = a3;
  *(double *)(a1 + 336) = a4;
  *(double *)(a1 + 344) = a5;
  v30.origin.double x = TSTLayoutGetVisibleAlignedStrokeFrame((void *)a1);
  CGFloat v6 = *(double *)(a1 + 352);
  CGFloat v7 = *(double *)(a1 + 360);
  CGFloat v8 = *(double *)(a1 + 368);
  CGFloat v9 = *(double *)(a1 + 376);
  *(CGRect *)(a1 + 352) = v30;
  CGRect v31 = CGRectIntegral(v30);
  double x = v31.origin.x;
  double y = v31.origin.y;
  double width = v31.size.width;
  double height = v31.size.height;
  v31.origin.double x = v6;
  v31.origin.double y = v7;
  v31.size.double width = v8;
  v31.size.double height = v9;
  CGRect v32 = CGRectIntegral(v31);
  CGFloat v14 = v32.origin.x;
  CGFloat v15 = v32.origin.y;
  CGFloat v16 = v32.size.width;
  CGFloat v17 = v32.size.height;
  if (CGRectIsEmpty(v32))
  {
    objc_msgSend((id)a1, "setNeedsDisplayInRect:", x, y, width, height);
  }
  else
  {
    v33.origin.double x = x;
    v33.origin.double y = y;
    v33.size.double width = width;
    v33.size.double height = height;
    CGFloat rect = height;
    double MinX = CGRectGetMinX(v33);
    v34.origin.double x = v14;
    v34.origin.double y = v15;
    v34.size.double width = v16;
    v34.size.double height = v17;
    if (MinX < CGRectGetMinX(v34)) {
      [(id)a1 setNewCanvasRevealedHorizontally:1];
    }
    v35.origin.double x = x;
    v35.origin.double y = y;
    v35.size.double width = width;
    v35.size.double height = rect;
    double MinY = CGRectGetMinY(v35);
    v36.origin.double x = v14;
    v36.origin.double y = v15;
    v36.size.double width = v16;
    v36.size.double height = v17;
    if (MinY < CGRectGetMinY(v36)) {
      [(id)a1 setNewCanvasRevealedVertically:1];
    }
    v37.origin.double x = x;
    v37.origin.double y = y;
    v37.size.double width = width;
    v37.size.double height = rect;
    double MaxX = CGRectGetMaxX(v37);
    v38.origin.double x = v14;
    v38.origin.double y = v15;
    v38.size.double width = v16;
    v38.size.double height = v17;
    if (MaxX > CGRectGetMaxX(v38)) {
      [(id)a1 setNewCanvasRevealedHorizontally:1];
    }
    v39.origin.double x = x;
    v39.origin.double y = y;
    v39.size.double width = width;
    v39.size.double height = rect;
    double MaxY = CGRectGetMaxY(v39);
    v40.origin.double x = v14;
    v40.origin.double y = v15;
    v40.size.double width = v16;
    v40.size.double height = v17;
    if (MaxY > CGRectGetMaxY(v40)) {
      [(id)a1 setNewCanvasRevealedVertically:1];
    }
  }
  unint64_t result = [(id)a1 containedTextEditingLayout];
  if (result)
  {
    unint64_t result = [(id)a1 editingSpillingTextRange];
    if ((_WORD)result != 0xFFFF && (result & 0xFF0000) != 0xFF0000)
    {
      if (HIWORD(result))
      {
        if ((result & 0xFFFF00000000) != 0)
        {
          if ((TSTLayoutGetFrozenHeaderColumnsEnabled((void *)a1) & 1) != 0
            || (unint64_t result = TSTLayoutGetFrozenHeaderRowsEnabled((void *)a1), result))
          {
            objc_msgSend((id)objc_msgSend((id)a1, "containedTextEditingLayout"), "invalidateSize");
            long long v23 = *(_OWORD *)(MEMORY[0x263F001A8] + 16);
            *(_OWORD *)(a1 + 512) = *MEMORY[0x263F001A8];
            *(_OWORD *)(a1 + 528) = v23;
            CGFloat v24 = +[TSTChangeDescriptor changeDescriptorWithType:strokeRange:](TSTChangeDescriptor, "changeDescriptorWithType:strokeRange:", 27, [(id)a1 editingSpillingTextRange]);
            objc_msgSend((id)objc_msgSend((id)a1, "masterLayout"), "addChangeDescriptor:", v24);
            uint64_t v25 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)a1, "layoutController"), "canvas"), "accessController");
            uint64_t v26 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)a1, "layoutController"), "canvas"), "changeNotifier");
            uint64_t v27 = [(id)a1 tableInfo];
            return +[TSKBroadcast asyncNotificationWithAccessController:v25 changeNotifier:v26 changeKind:1 details:v24 changeSource:v27];
          }
        }
      }
    }
  }
  return result;
}

double TSTLayoutGetVisibleAlignedStrokeFrame(void *a1)
{
  uint64_t v5 = 0;
  CGFloat v6 = (double *)&v5;
  uint64_t v7 = 0x5012000000;
  CGFloat v8 = __Block_byref_object_copy__30;
  CGFloat v9 = __Block_byref_object_dispose__30;
  double v10 = &unk_22389B221;
  long long v1 = *(_OWORD *)(MEMORY[0x263F001A8] + 16);
  long long v11 = *MEMORY[0x263F001A8];
  long long v12 = v1;
  objc_msgSend((id)objc_msgSend(a1, "spaceBundle", MEMORY[0x263EF8330], 3221225472, __TSTLayoutGetVisibleAlignedStrokeFrame_block_invoke, &unk_2646B3AF8, a1, &v5), "performActionOnEachLayoutSpace:", &v4);
  double v2 = v6[6];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_2237E83E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

double TSTLayoutGetPreviousVisibleStrokeFrame(uint64_t a1)
{
  return *(double *)(a1 + 352);
}

double *TSTLayoutSetPreviousVisibleStrokeFrame(double *result, double a2, double a3, double a4, double a5)
{
  result[44] = a2;
  result[45] = a3;
  result[46] = a4;
  result[47] = a5;
  return result;
}

unint64_t TSTLayoutGetVisibleRange(void *a1)
{
  double v2 = (TSTLayoutSpace *)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");

  return TSTLayoutGetVisibleRangeForSpace((double *)a1, v2);
}

unint64_t TSTLayoutGetVisibleRangeForSpace(double *a1, TSTLayoutSpace *a2)
{
  double LayoutRectForCanvasRect = TSTLayoutSpaceGetLayoutRectForCanvasRect((uint64_t)a2, a1[40], a1[41], a1[42], a1[43]);

  return TSTLayoutSpaceGetRangeIntersectingLayoutRect(a2, LayoutRectForCanvasRect, v4, v5, v6);
}

unint64_t TSTLayoutGetVisiblePartOfRange(double *a1, unint64_t a2)
{
  __int16 v3 = ~(_WORD)a2;
  VisibleRangeForuint64_t Space = TSTLayoutGetVisibleRangeForSpace(a1, (TSTLayoutSpace *)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"));
  unint64_t v5 = 0;
  uint64_t v6 = 16711680;
  uint64_t v7 = 0xFFFFLL;
  if (!v3) {
    goto LABEL_23;
  }
  unint64_t v8 = 0;
  if ((a2 & 0xFF0000) == 0xFF0000) {
    return v6 | v8 | v7 | v5;
  }
  unint64_t v5 = 0;
  uint64_t v6 = 16711680;
  uint64_t v7 = 0xFFFFLL;
  if (!HIWORD(a2)) {
    goto LABEL_23;
  }
  unint64_t v8 = 0;
  if ((a2 & 0xFFFF00000000) == 0) {
    return v6 | v8 | v7 | v5;
  }
  unint64_t v5 = 0;
  uint64_t v6 = 16711680;
  uint64_t v7 = 0xFFFFLL;
  if ((_WORD)VisibleRangeForSpace == 0xFFFF) {
    goto LABEL_23;
  }
  unint64_t v8 = 0;
  if ((VisibleRangeForSpace & 0xFF0000) == 0xFF0000) {
    return v6 | v8 | v7 | v5;
  }
  unint64_t v5 = 0;
  uint64_t v6 = 16711680;
  uint64_t v7 = 0xFFFFLL;
  if (!HIWORD(VisibleRangeForSpace))
  {
LABEL_23:
    unint64_t v8 = 0;
    return v6 | v8 | v7 | v5;
  }
  unint64_t v8 = 0;
  if ((VisibleRangeForSpace & 0xFFFF00000000) != 0)
  {
    uint64_t v7 = 0;
    if (BYTE2(a2) <= BYTE2(VisibleRangeForSpace)) {
      unsigned int v9 = BYTE2(VisibleRangeForSpace);
    }
    else {
      unsigned int v9 = BYTE2(a2);
    }
    if ((unsigned __int16)a2 <= (unsigned __int16)VisibleRangeForSpace) {
      uint64_t v10 = (unsigned __int16)VisibleRangeForSpace;
    }
    else {
      uint64_t v10 = (unsigned __int16)a2;
    }
    if ((BYTE4(a2) + BYTE2(a2) - 1) >= (BYTE4(VisibleRangeForSpace)
                                                                                       + BYTE2(VisibleRangeForSpace)
                                                                                       - 1))
      unsigned int v11 = (BYTE4(VisibleRangeForSpace) + BYTE2(VisibleRangeForSpace) - 1);
    else {
      unsigned int v11 = (BYTE4(a2) + BYTE2(a2) - 1);
    }
    unsigned int v12 = (unsigned __int16)(VisibleRangeForSpace + HIWORD(VisibleRangeForSpace) - 1);
    if ((unsigned __int16)(a2 + HIWORD(a2) - 1) < v12) {
      unsigned int v12 = (unsigned __int16)(a2 + HIWORD(a2) - 1);
    }
    uint64_t v6 = 0;
    unint64_t v5 = 0;
    unint64_t v8 = 0;
    if (v10 <= v12 && v9 <= v11)
    {
      unint64_t v8 = ((unint64_t)(v12 - v10) << 48) + 0x1000000000000;
      unint64_t v5 = (unint64_t)(unsigned __int16)(v11 - v9 + 1) << 32;
      uint64_t v6 = v9 << 16;
      uint64_t v7 = v10;
    }
  }
  return v6 | v8 | v7 | v5;
}

__n128 __Block_byref_object_copy__30(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 48);
  long long v3 = *(_OWORD *)(a2 + 64);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

uint64_t __TSTLayoutGetVisibleAlignedStrokeFrame_block_invoke(uint64_t a1, TSTLayoutSpace *a2)
{
  if (![(TSTLayoutSpace *)a2 isRepeat])
  {
    [(TSTLayoutSpace *)a2 lockForRead];
    VisibleRangeForuint64_t Space = TSTLayoutGetVisibleRangeForSpace(*(double **)(a1 + 32), a2);
    if (HIWORD(VisibleRangeForSpace)) {
      BOOL v5 = (VisibleRangeForSpace & 0xFFFF00000000) == 0;
    }
    else {
      BOOL v5 = 1;
    }
    if (!v5)
    {
      if (BYTE2(VisibleRangeForSpace) == 255) {
        unsigned int v6 = -1;
      }
      else {
        unsigned int v6 = BYTE2(VisibleRangeForSpace);
      }
      uint64_t v7 = WORD2(VisibleRangeForSpace) + v6 - 1;
      if (!WORD2(VisibleRangeForSpace)) {
        uint64_t v7 = 0xFFFFFFFFLL;
      }
      if ((unsigned __int16)VisibleRangeForSpace == 0xFFFF) {
        uint64_t v8 = 0xFFFFFFFFLL;
      }
      else {
        uint64_t v8 = (unsigned __int16)VisibleRangeForSpace;
      }
      unint64_t v9 = v6 | ((unint64_t)v8 << 32);
      uint64_t v10 = ((VisibleRangeForSpace >> 16) & 0xFFFF00000000) + (v8 << 32) - 0x100000000;
      if (((VisibleRangeForSpace >> 16) & 0xFFFF00000000) == 0) {
        uint64_t v10 = 0xFFFFFFFF00000000;
      }
      AlignedStrokeFrameForGridunint64_t Range = TSTLayoutSpaceGetAlignedStrokeFrameForGridRange(a2, v9, v7 | v10);
      CGFloat v13 = v12;
      CGFloat v15 = v14;
      CGFloat v17 = v16;
      IsEmptdouble y = CGRectIsEmpty(*(CGRect *)(*(void *)(*(void *)(a1 + 40) + 8) + 48));
      uint64_t v19 = *(void *)(*(void *)(a1 + 40) + 8);
      if (IsEmpty)
      {
        *(double *)(v19 + 48) = AlignedStrokeFrameForGridRange;
        *(CGFloat *)(v19 + 56) = v13;
        *(CGFloat *)(v19 + 64) = v15;
        *(CGFloat *)(v19 + 72) = v17;
      }
      else
      {
        v21.origin.double x = AlignedStrokeFrameForGridRange;
        v21.origin.double y = v13;
        v21.size.double width = v15;
        v21.size.double height = v17;
        *(CGRect *)(*(void *)(*(void *)(a1 + 40) + 8) + 48) = CGRectUnion(*(CGRect *)(v19 + 48), v21);
      }
    }
    [(TSTLayoutSpace *)a2 unlock];
  }
  return 0;
}

void *TSTLayoutGetVisibleLayoutSpaces(TSTLayout *a1)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  if ([(TSTMasterLayout *)[(TSTLayout *)a1 masterLayout] isDynamicallyRepressingFrozenHeaders])
  {
    uint64_t v2 = 0;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
  }
  else
  {
    uint64_t v9 = [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] frozenHeaderRowsSpace];
    uint64_t v2 = [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] frozenHeaderColumnsSpace];
  }
  uint64_t v10 = [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] repeatHeaderCornerSpace];
  uint64_t v11 = [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] repeatHeaderRowsSpace];
  uint64_t v12 = [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] repeatHeaderColumnsSpace];
  uint64_t v13 = [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space];
  long long v3 = (void *)[MEMORY[0x263EFF980] arrayWithCapacity:7];
  for (uint64_t i = 0; i != 56; i += 8)
  {
    uint64_t v5 = *(uint64_t *)((char *)&v8 + i);
    if (!v5) {
      continue;
    }
    int v6 = [*(id *)((char *)&v8 + i) layoutSpaceType];
    if (v6 == 3)
    {
      if (TSTLayoutGetFrozenHeaderRowsFloating(a1)) {
        goto LABEL_13;
      }
    }
    else
    {
      if (v6 == 2)
      {
        if ((TSTLayoutGetFrozenHeaderColumnsFloating(a1) & 1) == 0) {
          continue;
        }
LABEL_13:
        [v3 addObject:v5];
        continue;
      }
      if (v6 != 1
        || TSTLayoutGetFrozenHeaderColumnsFloating(a1)
        && (TSTLayoutGetFrozenHeaderRowsFloating(a1) & 1) != 0)
      {
        goto LABEL_13;
      }
    }
  }
  return v3;
}

uint64_t TSTLayoutGetCellIDHitByCanvasPoint(TSTLayout *a1, CGFloat a2, double a3)
{
  long long v3 = a1;
  uint64_t v120 = *MEMORY[0x263EF8340];
  uint64_t v101 = [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space];
  VisibleLayoutSpaces = TSTLayoutGetVisibleLayoutSpaces(v3);
  if (v3->mTableNameVisible
    && ![(TSTMasterLayout *)[(TSTLayout *)v3 masterLayout] isDynamicallyRepressingFrozenHeaders])
  {
    if (TSTLayoutGetFrozenHeaderRowsEnabled(v3))
    {
      if (TSTLayoutGetFrozenHeaderRowsFloating(v3))
      {
        uint64_t v5 = [(TSTLayoutSpaceBundle *)[(TSTLayout *)v3 spaceBundle] frozenHeaderRowsSpace];
        if (v5)
        {
          uint64_t v6 = v5;
          memset(&v118, 0, sizeof(v118));
          TSTLayoutGetFrozenHeaderRowsTransformToLayout(v3, (uint64_t)&v118);
          TSTLayoutGetCanvasFrameForFrozenTableName(v3);
          double v8 = v7;
          v122.origin.CGFloat x = TSTLayoutSpaceGetCanvasFrame(v6);
          CGAffineTransform v117 = v118;
          CGRect v123 = CGRectApplyAffineTransform(v122, &v117);
          if (a3 < CGRectGetMinY(v123) && a3 > v8) {
            return 0xFFFFFFLL;
          }
        }
      }
    }
  }
  long long v115 = 0u;
  long long v116 = 0u;
  long long v113 = 0u;
  long long v114 = 0u;
  uint64_t v10 = [VisibleLayoutSpaces countByEnumeratingWithState:&v113 objects:v119 count:16];
  if (!v10)
  {
    LOWORD(v103) = -1;
    LOBYTE(v++*(_DWORD *)(this + 104) = -1;
    return (unsigned __int16)v103 | (v104 << 16);
  }
  uint64_t v11 = v10;
  uint64_t v12 = *(void *)v114;
  float64x2_t rect_8 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&a2, 0);
  int v103 = -1;
  int v104 = -1;
  rect_24 = v3;
  while (2)
  {
    uint64_t v13 = 0;
    do
    {
      if (*(void *)v114 != v12) {
        objc_enumerationMutation(VisibleLayoutSpaces);
      }
      uint64_t v14 = *(void **)(*((void *)&v113 + 1) + 8 * v13);
      if (!v14) {
        goto LABEL_32;
      }
      Gridunint64_t Range = TSTLayoutSpaceGetGridRange(*(void *)(*((void *)&v113 + 1) + 8 * v13));
      BOOL v18 = GridRange == -1 || v16 == -1;
      BOOL v19 = v18 || GridRange > v16;
      BOOL v20 = v19 || HIDWORD(GridRange) == -1;
      BOOL v21 = v20 || v17 == -1;
      if (v21 || HIDWORD(GridRange) > v17) {
        goto LABEL_32;
      }
      int v23 = [v14 layoutSpaceType];
      if (v23)
      {
        int v24 = v23;
        float64x2_t v25 = *(float64x2_t *)MEMORY[0x263F000D0];
        float64x2_t v26 = *(float64x2_t *)(MEMORY[0x263F000D0] + 16);
        float64x2_t v27 = *(float64x2_t *)(MEMORY[0x263F000D0] + 32);
        int v28 = 1;
        uint64_t v29 = (uint64_t)v14;
        switch(v23)
        {
          case 1:
            TSTLayoutGetFrozenHeaderCornerTransformToLayout(v3, (uint64_t)v112);
            CGRect v30 = (CGAffineTransform *)v112;
            goto LABEL_55;
          case 2:
            TSTLayoutGetFrozenHeaderColumnsTransformToLayout(v3, (uint64_t)v111);
            CGRect v30 = (CGAffineTransform *)v111;
            goto LABEL_55;
          case 3:
            TSTLayoutGetFrozenHeaderRowsTransformToLayout(v3, (uint64_t)&v110);
            CGRect v30 = &v110;
LABEL_55:
            CGAffineTransformInvert(&v118, v30);
            float64x2_t v25 = *(float64x2_t *)&v118.a;
            float64x2_t v26 = *(float64x2_t *)&v118.c;
            int v28 = 1;
            uint64_t v29 = v101;
            float64x2_t v27 = *(float64x2_t *)&v118.tx;
            break;
          case 5:
          case 6:
            break;
          default:
            int v28 = 0;
            uint64_t v29 = (uint64_t)v14;
            break;
        }
        float64x2_t v38 = vaddq_f64(v27, vmlaq_f64(vmulq_n_f64(v26, a3), rect_8, v25));
        int v105 = v28;
        if (v3->mTabsVisible)
        {
          if (v24 == 3)
          {
            float64x2_t v107 = v38;
            TSTLayoutGetRowTabsCanvasFrameAndAdjustment((void *)[v14 layout], 0);
            uint64_t v43 = 0;
          }
          else
          {
            if (v24 != 2) {
              goto LABEL_65;
            }
            float64x2_t v107 = v38;
            TSTLayoutGetColumnTabsCanvasFrameAndAdjustment((void *)[v14 layout], 0);
            uint64_t v43 = 1;
          }
          v121.CGFloat x = a2;
          v121.CGFloat y = a3;
          BOOL v44 = CGRectContainsPoint(*(CGRect *)&v39, v121);
          double v45 = (double *)((unint64_t)&v109 | (8 * v43));
          float64x2_t v109 = v107;
          double v46 = *v45;
          if (v44) {
            double v46 = -31.0;
          }
          *double v45 = v46;
          float64x2_t v38 = v109;
        }
LABEL_65:
        double v47 = v38.f64[1];
        double v108 = v38.f64[0];
        uint64_t GridPointHitByCanvasPoint = TSTLayoutSpaceGetGridPointHitByCanvasPoint(v29, 0, v38.f64[0], v38.f64[1]);
        uint64_t v49 = TSTLayoutSpaceGetGridRange((uint64_t)v14);
        uint64_t v51 = v50;
        if (v24 == 4)
        {
          double Frame = TSTLayoutSpaceGetFrame(v101);
          double rect = TSTLayoutSpaceGetCanvasRectForLayoutRect(v101, Frame, v53, v54, v55);
          CGFloat v57 = v56;
          CGFloat v59 = v58;
          CGFloat v61 = v60;
          double v62 = TSTLayoutSpaceGetFrame((uint64_t)v14);
          double CanvasRectForLayoutRect = TSTLayoutSpaceGetCanvasRectForLayoutRect((uint64_t)v14, v62, v63, v64, v65);
          CGFloat v68 = v67;
          CGFloat v70 = v69;
          CGFloat v72 = v71;
          uint64_t v73 = TSTLayoutSpaceGetGridRange((uint64_t)v14);
          uint64_t v75 = v74;
          v124.origin.CGFloat x = CanvasRectForLayoutRect;
          v124.origin.CGFloat y = v68;
          v124.size.CGFloat width = v70;
          v124.size.CGFloat height = v72;
          CGFloat MaxX = CGRectGetMaxX(v124);
          unsigned int v77 = HIDWORD(GridPointHitByCanvasPoint);
          if (v108 <= MaxX)
          {
            v125.origin.CGFloat x = CanvasRectForLayoutRect;
            v125.origin.CGFloat y = v68;
            v125.size.CGFloat width = v70;
            v125.size.CGFloat height = v72;
            if (v108 >= CGRectGetMinX(v125)
              || (v126.origin.CGFloat x = rect,
                  v126.origin.CGFloat y = v57,
                  v126.size.CGFloat width = v59,
                  v126.size.CGFloat height = v61,
                  CGFloat MinX = CGRectGetMinX(v126),
                  unsigned int v77 = HIDWORD(GridPointHitByCanvasPoint),
                  v108 <= MinX))
            {
              v127.origin.CGFloat x = CanvasRectForLayoutRect;
              v127.origin.CGFloat y = v68;
              v127.size.CGFloat width = v70;
              v127.size.CGFloat height = v72;
              CGFloat MaxY = CGRectGetMaxY(v127);
              unsigned int v77 = HIDWORD(GridPointHitByCanvasPoint);
              if (v47 <= MaxY)
              {
                if (GridPointHitByCanvasPoint == -1
                  && HIDWORD(GridPointHitByCanvasPoint) != -1
                  && HIDWORD(v73) <= HIDWORD(GridPointHitByCanvasPoint))
                {
                  if (HIDWORD(v75) < HIDWORD(GridPointHitByCanvasPoint))
                  {
                    if (v105) {
                      unsigned int v89 = 0;
                    }
                    else {
                      unsigned int v89 = GridPointHitByCanvasPoint;
                    }
                    unsigned int v77 = HIDWORD(GridPointHitByCanvasPoint);
                    goto LABEL_98;
                  }
                  unsigned int v88 = 0;
                  unsigned int v89 = 0;
                  unsigned int v77 = HIDWORD(GridPointHitByCanvasPoint);
                  if ((v105 & 1) == 0) {
                    goto LABEL_98;
                  }
LABEL_93:
                  if (v77 == -1) {
                    unsigned int v77 = 0;
                  }
                  unsigned int v89 = v88;
LABEL_98:
                  BOOL v94 = v89 == -1
                     || v49 > v89
                     || v51 < v89
                     || v77 == -1
                     || v77 < HIDWORD(v49)
                     || v77 > HIDWORD(v51);
                  long long v3 = rect_24;
                  if (!v94)
                  {
                    if (GridPointHitByCanvasPoint == -1) {
                      int v97 = 16711680;
                    }
                    else {
                      int v97 = GridPointHitByCanvasPoint << 16;
                    }
                    return v97 & 0xFFFF0000 | WORD2(GridPointHitByCanvasPoint);
                  }
                  goto LABEL_32;
                }
                unsigned int v77 = (v75 >= GridPointHitByCanvasPoint) - 1;
                if (GridPointHitByCanvasPoint == -1
                  || v73 > GridPointHitByCanvasPoint)
                {
                  unsigned int v77 = -1;
                }
                if (HIDWORD(GridPointHitByCanvasPoint) != -1) {
                  unsigned int v77 = HIDWORD(GridPointHitByCanvasPoint);
                }
              }
            }
          }
        }
        else
        {
          unsigned int v77 = HIDWORD(GridPointHitByCanvasPoint);
          if ((v24 - 5) <= 1)
          {
            v128.origin.CGFloat x = TSTLayoutSpaceGetCanvasFrame((uint64_t)v14);
            CGFloat x = v128.origin.x;
            CGFloat y = v128.origin.y;
            CGFloat width = v128.size.width;
            CGFloat height = v128.size.height;
            if (v108 > CGRectGetMaxX(v128)
              || (v129.origin.CGFloat x = x,
                  v129.origin.CGFloat y = y,
                  v129.size.CGFloat width = width,
                  v129.size.CGFloat height = height,
                  CGFloat v87 = CGRectGetMaxY(v129),
                  unsigned int v77 = HIDWORD(GridPointHitByCanvasPoint),
                  v47 > v87))
            {
              long long v3 = rect_24;
              goto LABEL_32;
            }
          }
        }
        if ((v105 & 1) == 0)
        {
          unsigned int v89 = GridPointHitByCanvasPoint;
          goto LABEL_98;
        }
        if (GridPointHitByCanvasPoint == -1)
        {
          unsigned int v89 = 0;
          goto LABEL_98;
        }
        unsigned int v88 = GridPointHitByCanvasPoint;
        goto LABEL_93;
      }
      unint64_t v31 = TSTLayoutSpaceGetGridPointHitByCanvasPoint((uint64_t)v14, v3->mTabsVisible, a2, a3);
      unint64_t v32 = HIDWORD(v31);
      if (v31 > 0xFFFFFFFEFFFFFFFFLL || v31 == 0xFFFFFFFFLL)
      {
        if (v31 == 0xFFFFFFFFLL) {
          int v96 = 16711680;
        }
        else {
          int v96 = v31 << 16;
        }
        return v96 & 0xFFFF0000 | (unsigned __int16)v32;
      }
      if (v31 != -1 && v104 == -1) {
        int v35 = v31;
      }
      else {
        int v35 = v104;
      }
      int v36 = v103;
      if (HIDWORD(v31) != -1 && v103 == -1) {
        int v36 = HIDWORD(v31);
      }
      int v103 = v36;
      int v104 = v35;
LABEL_32:
      ++v13;
    }
    while (v11 != v13);
    uint64_t v95 = [VisibleLayoutSpaces countByEnumeratingWithState:&v113 objects:v119 count:16];
    uint64_t v11 = v95;
    if (v95) {
      continue;
    }
    return (unsigned __int16)v103 | (v104 << 16);
  }
}

double TSTLayoutGetCanvasFrameForFrozenTableName(TSTLayout *a1)
{
  double FrameForFrozenTableName = TSTLayoutGetFrameForFrozenTableName(a1);
  double v4 = v3;
  double v6 = v5;
  double v8 = v7;
  uint64_t v9 = [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space];

  return TSTLayoutSpaceGetCanvasRectForLayoutRect(v9, FrameForFrozenTableName, v4, v6, v8);
}

uint64_t TSTLayoutGetCellIDNearbyCanvasPoint(TSTLayout *a1)
{
  TSTLayoutSpaceGetCanvasFrame((uint64_t)[(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space]);
  double v2 = TSDClampPointInRect();

  return TSTLayoutGetCellIDHitByCanvasPoint(a1, v2, v3);
}

uint64_t TSTLayoutColumnGridlineNearCanvasPoint(TSTLayout *a1, double *a2, CGFloat a3, double a4)
{
  unsigned int CellIDHitByCanvasPoint = TSTLayoutGetCellIDHitByCanvasPoint(a1, a3, a4);
  unsigned int v8 = BYTE2(CellIDHitByCanvasPoint);
  if (BYTE2(CellIDHitByCanvasPoint) == 255)
  {
    if (a2) {
      *a2 = 1.79769313e308;
    }
    LOBYTE(v9) = -1;
    return v9;
  }
  unsigned int v10 = CellIDHitByCanvasPoint;
  unsigned int v11 = CellIDHitByCanvasPoint & 0xFF000000;
  uint64_t RangeForHint = TSTMasterLayoutGetRangeForHint((uint64_t)[(TSTLayout *)a1 masterLayout], [(TSTLayout *)a1 layoutHint]);
  v23.origin.CGFloat x = TSTLayoutGetCanvasFrameForRange(a1, v11 & 0xFFFF0000 | (v8 << 16) | (unsigned __int16)RangeForHint | 0x1000100000000);
  CGFloat x = v23.origin.x;
  CGFloat y = v23.origin.y;
  CGFloat width = v23.size.width;
  CGFloat height = v23.size.height;
  double v17 = a3 - CGRectGetMinX(v23);
  v24.origin.CGFloat x = x;
  v24.origin.CGFloat y = y;
  v24.size.CGFloat width = width;
  v24.size.CGFloat height = height;
  double v18 = CGRectGetMaxX(v24) - a3;
  if ([(TSTLayout *)a1 layoutDirectionIsLeftToRight])
  {
    if (v17 < v18 && v8 > BYTE2(RangeForHint))
    {
      if (a2) {
        *a2 = v17;
      }
      BOOL v19 = [(TSTLayout *)a1 masterLayout];
      return TSTMasterLayoutPreviousVisibleColumn(v19, (BYTE2(v10) - 1));
    }
LABEL_20:
    unsigned int v9 = HIWORD(v10);
    if (a2) {
      *a2 = v18;
    }
    return v9;
  }
  if (v17 >= v18 || v8 >= (BYTE4(RangeForHint) + BYTE2(RangeForHint) - 1)) {
    goto LABEL_20;
  }
  if (a2) {
    *a2 = v17;
  }
  BOOL v21 = [(TSTLayout *)a1 masterLayout];

  return TSTMasterLayoutNextVisibleColumn(v21, (BYTE2(v10) + 1));
}

double TSTLayoutGetCanvasFrameForRange(TSTLayout *a1, unint64_t a2)
{
  unsigned int v2 = BYTE2(a2);
  if (BYTE2(a2) == 255) {
    unsigned int v2 = -1;
  }
  uint64_t v3 = WORD2(a2) + v2 - 1;
  if (!WORD2(a2)) {
    uint64_t v3 = 0xFFFFFFFFLL;
  }
  if ((unsigned __int16)a2 == 0xFFFF) {
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v4 = (unsigned __int16)a2;
  }
  unint64_t v5 = v2 | ((unint64_t)v4 << 32);
  uint64_t v6 = ((a2 >> 16) & 0xFFFF00000000) + (v4 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0) {
    uint64_t v6 = 0xFFFFFFFF00000000;
  }
  return TSTLayoutGetArbitraryRectAcrossSpacesForGridRange(a1, v5, v3 | v6, (uint64_t)&__block_literal_global_82);
}

uint64_t TSTLayoutRowGridlineNearCanvasPoint(TSTLayout *a1, double *a2, CGFloat a3, double a4)
{
  int CellIDHitByCanvasPoint = TSTLayoutGetCellIDHitByCanvasPoint(a1, a3, a4);
  unsigned int v8 = (unsigned __int16)CellIDHitByCanvasPoint;
  if ((unsigned __int16)CellIDHitByCanvasPoint == 0xFFFF)
  {
    if (a2) {
      *a2 = 1.79769313e308;
    }
    LOWORD(v9) = -1;
    return (unsigned __int16)v9;
  }
  int v9 = CellIDHitByCanvasPoint;
  uint64_t RangeForHint = TSTMasterLayoutGetRangeForHint((uint64_t)[(TSTLayout *)a1 masterLayout], [(TSTLayout *)a1 layoutHint]);
  unsigned __int16 v11 = RangeForHint;
  v22.origin.CGFloat x = TSTLayoutGetCanvasFrameForRange(a1, v9 & 0xFF00FFFF | (BYTE2(RangeForHint) << 16) | 0x1000100000000);
  CGFloat x = v22.origin.x;
  CGFloat y = v22.origin.y;
  CGFloat width = v22.size.width;
  CGFloat height = v22.size.height;
  double v16 = a4 - CGRectGetMinY(v22);
  v23.origin.CGFloat x = x;
  v23.origin.CGFloat y = y;
  v23.size.CGFloat width = width;
  v23.size.CGFloat height = height;
  double v17 = CGRectGetMaxY(v23) - a4;
  if (v16 >= v17 || v8 <= v11)
  {
    if (a2) {
      *a2 = v17;
    }
    return (unsigned __int16)v9;
  }
  if (a2) {
    *a2 = v16;
  }
  BOOL v20 = [(TSTLayout *)a1 masterLayout];

  return TSTMasterLayoutPreviousVisibleRow(v20, (unsigned __int16)(v9 - 1));
}

double TSTLayoutGetCanvasFrameForGridRange(TSTLayout *a1, unint64_t a2, uint64_t a3)
{
  return TSTLayoutGetArbitraryRectAcrossSpacesForGridRange(a1, a2, a3, (uint64_t)&__block_literal_global_82);
}

double TSTLayoutGetArbitraryRectAcrossSpacesForGridRange(TSTLayout *a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  double v7 = *MEMORY[0x263F001A0];
  double v8 = *(double *)(MEMORY[0x263F001A0] + 8);
  CGFloat v9 = *(double *)(MEMORY[0x263F001A0] + 16);
  CGFloat v10 = *(double *)(MEMORY[0x263F001A0] + 24);
  VisibleLayoutSpaces = TSTLayoutGetVisibleLayoutSpaces(a1);
  long long v36 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  uint64_t v12 = [VisibleLayoutSpaces countByEnumeratingWithState:&v36 objects:v40 count:16];
  if (!v12) {
    return v7;
  }
  uint64_t v13 = v12;
  unint64_t v14 = HIDWORD(a2);
  uint64_t v15 = *(void *)v37;
  uint64_t v31 = 0;
  do
  {
    for (uint64_t i = 0; i != v13; ++i)
    {
      if (*(void *)v37 != v15) {
        objc_enumerationMutation(VisibleLayoutSpaces);
      }
      double v17 = *(_DWORD **)(*((void *)&v36 + 1) + 8 * i);
      if (TSTLayoutSpaceIntersectsGridRange(v17, a2 | (v14 << 32), a3))
      {
        uint64_t v18 = TSTLayoutSpaceIntersectionGridRange(v17, a2 | (v14 << 32), a3);
        double x = (*(double (**)(uint64_t, _DWORD *, uint64_t, uint64_t))(a4 + 16))(a4, v17, v18, v19);
        double y = v21;
        double width = v23;
        double height = v25;
        switch([v17 layoutSpaceType])
        {
          case 0u:
            goto LABEL_12;
          case 1u:
            memset(&v35, 0, sizeof(v35));
            TSTLayoutGetFrozenHeaderCornerTransformToLayout(a1, (uint64_t)&v35);
            CGAffineTransform v32 = v35;
            v42.origin.double x = x;
            v42.origin.double y = y;
            v42.size.double width = width;
            v42.size.double height = height;
            CGRect v43 = CGRectApplyAffineTransform(v42, &v32);
            double x = v43.origin.x;
            double y = v43.origin.y;
            double width = v43.size.width;
            double height = v43.size.height;
            uint64_t v31 = 0x100000001;
            goto LABEL_12;
          case 2u:
            memset(&v35, 0, sizeof(v35));
            TSTLayoutGetFrozenHeaderColumnsTransformToLayout(a1, (uint64_t)&v35);
            CGAffineTransform v34 = v35;
            v44.origin.double x = x;
            v44.origin.double y = y;
            v44.size.double width = width;
            v44.size.double height = height;
            CGRect v45 = CGRectApplyAffineTransform(v44, &v34);
            double x = v45.origin.x;
            double y = v45.origin.y;
            double width = v45.size.width;
            double height = v45.size.height;
            TSTLayoutSpaceGetGridRange((uint64_t)v17);
            LODWORD(a2) = v27 + 1;
            BYTE4(v31) = 1;
            goto LABEL_12;
          case 3u:
            memset(&v35, 0, sizeof(v35));
            TSTLayoutGetFrozenHeaderRowsTransformToLayout(a1, (uint64_t)&v35);
            CGAffineTransform v33 = v35;
            v46.origin.double x = x;
            v46.origin.double y = y;
            v46.size.double width = width;
            v46.size.double height = height;
            CGRect v47 = CGRectApplyAffineTransform(v46, &v33);
            double x = v47.origin.x;
            double y = v47.origin.y;
            double width = v47.size.width;
            double height = v47.size.height;
            TSTLayoutSpaceGetGridRange((uint64_t)v17);
            unint64_t v14 = (v28 + 1);
            LOBYTE(v31) = 1;
            goto LABEL_12;
          default:
            if (TSTLayoutSpaceContainsGridRange(v17, a2 | (v14 << 32), a3)) {
              return x;
            }
LABEL_12:
            v48.origin.double x = v7;
            v48.origin.double y = v8;
            v48.size.double width = v9;
            v48.size.double height = v10;
            if (CGRectIsNull(v48))
            {
              double v7 = x;
              double v8 = y;
              CGFloat v9 = width;
              CGFloat v10 = height;
            }
            else
            {
              if ((BYTE4(v31) & (x < v7)) == 1)
              {
                double width = width - (v7 - x);
                if (width >= 0.0)
                {
                  double x = x + v7 - x;
                }
                else
                {
                  double x = *MEMORY[0x263F001A0];
                  double y = *(double *)(MEMORY[0x263F001A0] + 8);
                  double width = *(double *)(MEMORY[0x263F001A0] + 16);
                  double height = *(double *)(MEMORY[0x263F001A0] + 24);
                }
              }
              if ((v31 & (y < v8)) == 1)
              {
                double height = height - (v8 - y);
                if (height >= 0.0)
                {
                  double y = y + v8 - y;
                }
                else
                {
                  double x = *MEMORY[0x263F001A0];
                  double y = *(double *)(MEMORY[0x263F001A0] + 8);
                  double width = *(double *)(MEMORY[0x263F001A0] + 16);
                  double height = *(double *)(MEMORY[0x263F001A0] + 24);
                }
              }
              v49.origin.double x = v7;
              v49.origin.double y = v8;
              v49.size.double width = v9;
              v49.size.double height = v10;
              v51.origin.double x = x;
              v51.origin.double y = y;
              v51.size.double width = width;
              v51.size.double height = height;
              CGRect v50 = CGRectUnion(v49, v51);
              double v7 = v50.origin.x;
              double v8 = v50.origin.y;
              CGFloat v9 = v50.size.width;
              CGFloat v10 = v50.size.height;
            }
            break;
        }
      }
    }
    uint64_t v13 = [VisibleLayoutSpaces countByEnumeratingWithState:&v36 objects:v40 count:16];
    double x = v7;
  }
  while (v13);
  return x;
}

double __TSTLayoutGetCanvasFrameForGridRange_block_invoke(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  return TSTLayoutSpaceGetCanvasFrameForGridRange(a2, a3, a4);
}

double TSTLayoutGetFrameForGridRange(TSTLayout *a1, unint64_t a2, uint64_t a3)
{
  ArbitraryRectAcrossSpacesForGridunint64_t Range = TSTLayoutGetArbitraryRectAcrossSpacesForGridRange(a1, a2, a3, (uint64_t)&__block_literal_global_82);
  double v6 = v5;
  double v8 = v7;
  double v10 = v9;
  uint64_t v11 = [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space];

  return TSTLayoutSpaceGetLayoutRectForCanvasRect(v11, ArbitraryRectAcrossSpacesForGridRange, v6, v8, v10);
}

double TSTLayoutGetFrameForRange(TSTLayout *a1, unint64_t a2)
{
  CanvasFrameForunint64_t Range = TSTLayoutGetCanvasFrameForRange(a1, a2);
  double v5 = v4;
  double v7 = v6;
  double v9 = v8;
  uint64_t v10 = [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space];

  return TSTLayoutSpaceGetLayoutRectForCanvasRect(v10, CanvasFrameForRange, v5, v7, v9);
}

double TSTLayoutGetBoundsForCellRange(TSTLayout *a1, unint64_t a2)
{
  __int16 v4 = ~(_WORD)a2;
  unint64_t v5 = [(TSTTableModel *)[(TSTLayout *)a1 tableModel] range];
  unint64_t v6 = 0;
  uint64_t v7 = 16711680;
  uint64_t v8 = 0xFFFFLL;
  if (!v4) {
    goto LABEL_23;
  }
  unint64_t v9 = 0;
  if ((a2 & 0xFF0000) == 0xFF0000) {
    goto LABEL_24;
  }
  unint64_t v6 = 0;
  uint64_t v7 = 16711680;
  uint64_t v8 = 0xFFFFLL;
  if (!HIWORD(a2)) {
    goto LABEL_23;
  }
  unint64_t v9 = 0;
  if ((a2 & 0xFFFF00000000) == 0) {
    goto LABEL_24;
  }
  unint64_t v6 = 0;
  uint64_t v7 = 16711680;
  uint64_t v8 = 0xFFFFLL;
  if ((_WORD)v5 == 0xFFFF) {
    goto LABEL_23;
  }
  unint64_t v9 = 0;
  if ((v5 & 0xFF0000) == 0xFF0000) {
    goto LABEL_24;
  }
  unint64_t v6 = 0;
  uint64_t v7 = 16711680;
  uint64_t v8 = 0xFFFFLL;
  if (!HIWORD(v5))
  {
LABEL_23:
    unint64_t v9 = 0;
    goto LABEL_24;
  }
  unint64_t v9 = 0;
  if ((v5 & 0xFFFF00000000) != 0)
  {
    uint64_t v8 = 0;
    if (BYTE2(a2) <= BYTE2(v5)) {
      unsigned int v10 = BYTE2(v5);
    }
    else {
      unsigned int v10 = BYTE2(a2);
    }
    if ((unsigned __int16)a2 <= (unsigned __int16)v5) {
      uint64_t v11 = (unsigned __int16)v5;
    }
    else {
      uint64_t v11 = (unsigned __int16)a2;
    }
    if ((BYTE4(a2) + BYTE2(a2) - 1) >= (BYTE4(v5) + BYTE2(v5) - 1)) {
      unsigned int v12 = (BYTE4(v5) + BYTE2(v5) - 1);
    }
    else {
      unsigned int v12 = (BYTE4(a2) + BYTE2(a2) - 1);
    }
    unsigned int v13 = (unsigned __int16)(v5 + HIWORD(v5) - 1);
    if ((unsigned __int16)(a2 + HIWORD(a2) - 1) < v13) {
      unsigned int v13 = (unsigned __int16)(a2 + HIWORD(a2) - 1);
    }
    uint64_t v7 = 0;
    unint64_t v6 = 0;
    unint64_t v9 = 0;
    if (v11 <= v13 && v10 <= v12)
    {
      unint64_t v9 = ((unint64_t)(v13 - v11) << 48) + 0x1000000000000;
      unint64_t v6 = (unint64_t)(unsigned __int16)(v12 - v10 + 1) << 32;
      uint64_t v7 = v10 << 16;
      uint64_t v8 = v11;
    }
  }
LABEL_24:
  unint64_t v14 = v7 | v9 | v8 | v6;
  if ((_WORD)v14 == 0xFFFF) {
    return *MEMORY[0x263F001A8];
  }
  BOOL v15 = (v14 & 0xFF0000) == 0xFF0000 || HIWORD(v14) == 0;
  if (v15 || (v14 & 0xFFFF00000000) == 0) {
    return *MEMORY[0x263F001A8];
  }
  if (BYTE2(v14) == 255) {
    unsigned int v18 = -1;
  }
  else {
    unsigned int v18 = BYTE2(v14);
  }
  uint64_t v19 = WORD2(v14) + v18 - 1;
  if (!WORD2(v14)) {
    uint64_t v19 = 0xFFFFFFFFLL;
  }
  uint64_t v20 = (unsigned __int16)v14;
  unint64_t v21 = v18 | ((unint64_t)(unsigned __int16)v14 << 32);
  uint64_t v22 = (v14 >> 16) & 0xFFFF00000000;
  BOOL v15 = v22 == 0;
  uint64_t v23 = v22 + (v20 << 32) - 0x100000000;
  if (v15) {
    uint64_t v23 = 0xFFFFFFFF00000000;
  }
  return TSTLayoutGetFrameForGridRange(a1, v21, v19 | v23);
}

double TSTLayoutGetScrollBoundsForCellRange(TSTLayout *a1, unint64_t a2)
{
  v48.origin.double x = TSTLayoutGetBoundsForCellRange(a1, a2);
  double x = v48.origin.x;
  double y = v48.origin.y;
  CGFloat width = v48.size.width;
  double height = v48.size.height;
  if (!CGRectIsEmpty(v48))
  {
    uint64_t v8 = [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] frozenHeaderRowsSpace];
    uint64_t v9 = [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] frozenHeaderColumnsSpace];
    if (v8 | v9)
    {
      uint64_t v10 = v9;
      TSTLayoutGetTopLeftTabCanvasFrame((double *)a1);
      TSTLayoutSpaceGetLayoutRectForCanvasRect((uint64_t)[(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space], v11, v12, v13, v14);
      double v44 = v16;
      if (v8)
      {
        double v17 = v15;
        unint64_t v18 = TSTLayoutSpaceIntersectionCellRange(v8, a2);
        if ((_WORD)v18 == 0xFFFF || (v18 & 0xFF0000) == 0xFF0000 || !HIWORD(v18) || (v18 & 0xFFFF00000000) == 0)
        {
          double v43 = v17;
          double Frame = TSTLayoutSpaceGetFrame(v8);
          CGFloat v21 = v20;
          CGFloat v23 = v22;
          CGFloat v25 = v24;
          memset(&v47, 0, sizeof(v47));
          TSTLayoutGetFrozenHeaderRowsTransformToLayout(a1, (uint64_t)&v47);
          CGAffineTransform v46 = v47;
          v49.origin.double x = Frame;
          v49.origin.double y = v21;
          v49.size.CGFloat width = v23;
          v49.size.double height = v25;
          CGRect v50 = CGRectApplyAffineTransform(v49, &v46);
          double v26 = v50.size.height;
          double MaxY = CGRectGetMaxY(v50);
          v51.origin.double x = x;
          v51.origin.double y = y;
          v51.size.CGFloat width = width;
          v51.size.double height = height;
          if (MaxY > CGRectGetMinY(v51))
          {
            TSTLayoutGetTableNameHeight((uint64_t)a1);
            double v29 = v43 + v26 + v28;
            double y = y - v29;
            double height = height + v29;
          }
        }
      }
      if (v10)
      {
        unint64_t v30 = TSTLayoutSpaceIntersectionCellRange(v10, a2);
        if ((_WORD)v30 == 0xFFFF || (v30 & 0xFF0000) == 0xFF0000 || !HIWORD(v30) || (v30 & 0xFFFF00000000) == 0)
        {
          double v31 = TSTLayoutSpaceGetFrame(v10);
          CGFloat v33 = v32;
          CGFloat v35 = v34;
          CGFloat v37 = v36;
          memset(&v47, 0, sizeof(v47));
          TSTLayoutGetFrozenHeaderColumnsTransformToLayout(a1, (uint64_t)&v47);
          CGAffineTransform v45 = v47;
          v52.origin.double x = v31;
          v52.origin.double y = v33;
          v52.size.CGFloat width = v35;
          v52.size.double height = v37;
          CGRect v53 = CGRectApplyAffineTransform(v52, &v45);
          double v38 = v53.size.width;
          double MaxX = CGRectGetMaxX(v53);
          v54.origin.double x = x;
          v54.origin.double y = y;
          v54.size.CGFloat width = width;
          v54.size.double height = height;
          BOOL v40 = MaxX <= CGRectGetMinX(v54);
          double v41 = 0.0;
          if (!v40) {
            double v41 = v44 + v38;
          }
          return x - v41;
        }
      }
    }
  }
  return x;
}

double TSTLayoutGetCanvasStrokeFrameForGridRange(TSTLayout *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  double x = *MEMORY[0x263F001A0];
  CGFloat y = *(double *)(MEMORY[0x263F001A0] + 8);
  CGFloat width = *(double *)(MEMORY[0x263F001A0] + 16);
  CGFloat height = *(double *)(MEMORY[0x263F001A0] + 24);
  VisibleLayoutSpaces = TSTLayoutGetVisibleLayoutSpaces(a1);
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  uint64_t v10 = [VisibleLayoutSpaces countByEnumeratingWithState:&v25 objects:v29 count:16];
  if (v10)
  {
    uint64_t v11 = v10;
    uint64_t v12 = *(void *)v26;
    while (2)
    {
      for (uint64_t i = 0; i != v11; ++i)
      {
        if (*(void *)v26 != v12) {
          objc_enumerationMutation(VisibleLayoutSpaces);
        }
        double v14 = *(_DWORD **)(*((void *)&v25 + 1) + 8 * i);
        if (TSTLayoutSpaceIntersectsGridRange(v14, a2, a3))
        {
          unint64_t v15 = TSTLayoutSpaceIntersectionGridRange(v14, a2, a3);
          CanvasStrokeFrameForGridunint64_t Range = TSTLayoutSpaceGetCanvasStrokeFrameForGridRange((uint64_t)v14, v15, v16);
          CGFloat v19 = v18;
          CGFloat v21 = v20;
          CGFloat v23 = v22;
          if (TSTLayoutSpaceContainsGridRange(v14, a2, a3)) {
            return CanvasStrokeFrameForGridRange;
          }
          v31.origin.double x = x;
          v31.origin.CGFloat y = y;
          v31.size.CGFloat width = width;
          v31.size.CGFloat height = height;
          if (CGRectIsNull(v31))
          {
            double x = CanvasStrokeFrameForGridRange;
            CGFloat y = v19;
            CGFloat width = v21;
            CGFloat height = v23;
          }
          else
          {
            v32.origin.double x = x;
            v32.origin.CGFloat y = y;
            v32.size.CGFloat width = width;
            v32.size.CGFloat height = height;
            v34.origin.double x = CanvasStrokeFrameForGridRange;
            v34.origin.CGFloat y = v19;
            v34.size.CGFloat width = v21;
            v34.size.CGFloat height = v23;
            CGRect v33 = CGRectUnion(v32, v34);
            double x = v33.origin.x;
            CGFloat y = v33.origin.y;
            CGFloat width = v33.size.width;
            CGFloat height = v33.size.height;
          }
        }
      }
      uint64_t v11 = [VisibleLayoutSpaces countByEnumeratingWithState:&v25 objects:v29 count:16];
      if (v11) {
        continue;
      }
      break;
    }
  }
  return x;
}

double TSTLayoutGetStrokeFrameForGridRange(TSTLayout *a1, uint64_t a2, uint64_t a3)
{
  CanvasStrokeFrameForGridunint64_t Range = TSTLayoutGetCanvasStrokeFrameForGridRange(a1, a2, a3);
  double v6 = v5;
  double v8 = v7;
  double v10 = v9;
  uint64_t v11 = [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space];

  return TSTLayoutSpaceGetLayoutRectForCanvasRect(v11, CanvasStrokeFrameForGridRange, v6, v8, v10);
}

double TSTLayoutGetCanvasStrokeFrameForRange(TSTLayout *a1, unint64_t a2)
{
  unsigned int v2 = BYTE2(a2);
  if (BYTE2(a2) == 255) {
    unsigned int v2 = -1;
  }
  uint64_t v3 = WORD2(a2) + v2 - 1;
  if (!WORD2(a2)) {
    uint64_t v3 = 0xFFFFFFFFLL;
  }
  if ((unsigned __int16)a2 == 0xFFFF) {
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v4 = (unsigned __int16)a2;
  }
  unint64_t v5 = v2 | ((unint64_t)v4 << 32);
  uint64_t v6 = ((a2 >> 16) & 0xFFFF00000000) + (v4 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0) {
    uint64_t v6 = 0xFFFFFFFF00000000;
  }
  return TSTLayoutGetCanvasStrokeFrameForGridRange(a1, v5, v3 | v6);
}

double TSTLayoutGetStrokeFrameForRange(TSTLayout *a1, unint64_t a2)
{
  CanvasStrokeFrameForunint64_t Range = TSTLayoutGetCanvasStrokeFrameForRange(a1, a2);
  double v5 = v4;
  double v7 = v6;
  double v9 = v8;
  uint64_t v10 = [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space];

  return TSTLayoutSpaceGetLayoutRectForCanvasRect(v10, CanvasStrokeFrameForRange, v5, v7, v9);
}

double TSTLayoutGetContentFrameForRange(TSTLayout *a1, unint64_t a2)
{
  unsigned int v2 = BYTE2(a2);
  if (BYTE2(a2) == 255) {
    unsigned int v2 = -1;
  }
  uint64_t v3 = WORD2(a2) + v2 - 1;
  if (!WORD2(a2)) {
    uint64_t v3 = 0xFFFFFFFFLL;
  }
  if ((unsigned __int16)a2 == 0xFFFF) {
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v4 = (unsigned __int16)a2;
  }
  unint64_t v5 = v2 | ((unint64_t)v4 << 32);
  uint64_t v6 = ((a2 >> 16) & 0xFFFF00000000) + (v4 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0) {
    uint64_t v6 = 0xFFFFFFFF00000000;
  }
  return TSTLayoutGetArbitraryRectAcrossSpacesForGridRange(a1, v5, v3 | v6, (uint64_t)&__block_literal_global_67);
}

double TSTLayoutGetContentFrameForGridRange(TSTLayout *a1, unint64_t a2, uint64_t a3)
{
  return TSTLayoutGetArbitraryRectAcrossSpacesForGridRange(a1, a2, a3, (uint64_t)&__block_literal_global_67);
}

double __TSTLayoutGetContentFrameForGridRange_block_invoke(uint64_t a1, TSTLayoutSpace *a2, unint64_t a3, unint64_t a4)
{
  return TSTLayoutSpaceGetContentFrameForGridRange(a2, a3, a4);
}

double TSTLayoutGetAlignedOverrideFrameForGridRange(TSTLayout *a1, unint64_t a2, uint64_t a3, double a4)
{
  v5[0] = MEMORY[0x263EF8330];
  v5[1] = 3221225472;
  void v5[2] = __TSTLayoutGetAlignedOverrideFrameForGridRange_block_invoke;
  v5[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__32__0__TSTLayoutSpace_8______II____II__16l;
  *(double *)&v5[4] = a4;
  return TSTLayoutGetArbitraryRectAcrossSpacesForGridRange(a1, a2, a3, (uint64_t)v5);
}

double __TSTLayoutGetAlignedOverrideFrameForGridRange_block_invoke(uint64_t a1, TSTLayoutSpace *a2, unint64_t a3, unint64_t a4)
{
  return TSTLayoutSpaceGetAlignedOverrideFrameForGridRange(a2, a3, a4, *(double *)(a1 + 32));
}

uint64_t __TSTLayoutGetAlignedStrokeFrame_block_invoke(uint64_t a1, void *a2)
{
  if (([a2 isFrozen] & 1) == 0)
  {
    AlignedStrokedouble Frame = TSTLayoutSpaceGetAlignedStrokeFrame((uint64_t)a2);
    CGFloat v6 = v5;
    CGFloat v8 = v7;
    CGFloat v10 = v9;
    BOOL IsNull = CGRectIsNull(*(CGRect *)(*(void *)(*(void *)(a1 + 32) + 8) + 48));
    uint64_t v12 = *(void *)(*(void *)(a1 + 32) + 8);
    if (IsNull)
    {
      *(double *)(v12 + 48) = AlignedStrokeFrame;
      *(CGFloat *)(v12 + 56) = v6;
      *(CGFloat *)(v12 + 64) = v8;
      *(CGFloat *)(v12 + 72) = v10;
    }
    else
    {
      v14.origin.double x = AlignedStrokeFrame;
      v14.origin.CGFloat y = v6;
      v14.size.CGFloat width = v8;
      v14.size.CGFloat height = v10;
      *(CGRect *)(*(void *)(*(void *)(a1 + 32) + 8) + 48) = CGRectUnion(*(CGRect *)(v12 + 48), v14);
    }
  }
  return 0;
}

double TSTLayoutGetAlignedStrokeFrameForRange(TSTLayout *a1, unint64_t a2)
{
  unsigned int v2 = BYTE2(a2);
  if (BYTE2(a2) == 255) {
    unsigned int v2 = -1;
  }
  uint64_t v3 = WORD2(a2) + v2 - 1;
  if (!WORD2(a2)) {
    uint64_t v3 = 0xFFFFFFFFLL;
  }
  if ((unsigned __int16)a2 == 0xFFFF) {
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v4 = (unsigned __int16)a2;
  }
  unint64_t v5 = v2 | ((unint64_t)v4 << 32);
  uint64_t v6 = ((a2 >> 16) & 0xFFFF00000000) + (v4 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0) {
    uint64_t v6 = 0xFFFFFFFF00000000;
  }
  return TSTLayoutGetAlignedStrokeFrameForGridRange(a1, v5, v3 | v6, 0);
}

double TSTLayoutGetAlignedStrokeFrameForGridRange(TSTLayout *a1, unint64_t a2, uint64_t a3, int a4)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  double v7 = *MEMORY[0x263F001A0];
  double v8 = *(double *)(MEMORY[0x263F001A0] + 8);
  CGFloat v9 = *(double *)(MEMORY[0x263F001A0] + 16);
  CGFloat v10 = *(double *)(MEMORY[0x263F001A0] + 24);
  long long v43 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  id obj = TSTLayoutGetVisibleLayoutSpaces(a1);
  uint64_t v11 = [obj countByEnumeratingWithState:&v43 objects:v47 count:16];
  if (v11)
  {
    uint64_t v12 = v11;
    char v37 = 0;
    char v13 = 0;
    unint64_t v14 = HIDWORD(a2);
    uint64_t v15 = *(void *)v44;
    while (1)
    {
      for (uint64_t i = 0; i != v12; ++i)
      {
        if (*(void *)v44 != v15) {
          objc_enumerationMutation(obj);
        }
        double v17 = *(TSTLayoutSpace **)(*((void *)&v43 + 1) + 8 * i);
        if (a4 == 2)
        {
          if (!TSTLayoutSpaceIntersectsColumnGridRange(*(_DWORD **)(*((void *)&v43 + 1) + 8 * i), a2 | (v14 << 32), a3))continue; {
          unint64_t v24 = TSTLayoutSpaceIntersectionColumnGridRange(v17, a2 | (v14 << 32), a3);
          }
          AlignedStrokeLineForColumnGridunint64_t Range = TSTLayoutSpaceGetAlignedStrokeLineForColumnGridRange(v17, v24, v25);
        }
        else if (a4 == 1)
        {
          if (!TSTLayoutSpaceIntersectsRowGridRange(*(void *)(*((void *)&v43 + 1) + 8 * i), a2 | (v14 << 32), a3))continue; {
          unint64_t v18 = TSTLayoutSpaceIntersectionRowGridRange((uint64_t)v17, a2 | (v14 << 32), a3);
          }
          AlignedStrokeLineForColumnGridunint64_t Range = TSTLayoutSpaceGetAlignedStrokeLineForRowGridRange(v17, v18, v19);
        }
        else
        {
          if (!TSTLayoutSpaceIntersectsGridRange(*(_DWORD **)(*((void *)&v43 + 1) + 8 * i), a2 | (v14 << 32), a3))continue; {
          unint64_t v26 = TSTLayoutSpaceIntersectionGridRange(v17, a2 | (v14 << 32), a3);
          }
          AlignedStrokeLineForColumnGridunint64_t Range = TSTLayoutSpaceGetAlignedStrokeFrameForGridRange(v17, v26, v27);
        }
        double x = AlignedStrokeLineForColumnGridRange;
        double y = v21;
        double width = v22;
        double height = v23;
        int v32 = [(TSTLayoutSpace *)v17 layoutSpaceType];
        if (v32 == 1)
        {
          memset(&v42, 0, sizeof(v42));
          TSTLayoutGetFrozenHeaderCornerTransformToLayout(a1, (uint64_t)&v42);
          CGAffineTransform v39 = v42;
          v51.origin.double x = x;
          v51.origin.double y = y;
          v51.size.double width = width;
          v51.size.double height = height;
          CGRect v52 = CGRectApplyAffineTransform(v51, &v39);
          double x = v52.origin.x;
          double y = v52.origin.y;
          double width = v52.size.width;
          double height = v52.size.height;
          char v37 = 1;
        }
        else
        {
          if (v32 != 3)
          {
            if (v32 == 2)
            {
              memset(&v42, 0, sizeof(v42));
              TSTLayoutGetFrozenHeaderColumnsTransformToLayout(a1, (uint64_t)&v42);
              CGAffineTransform v41 = v42;
              v49.origin.double x = x;
              v49.origin.double y = y;
              v49.size.double width = width;
              v49.size.double height = height;
              CGRect v50 = CGRectApplyAffineTransform(v49, &v41);
              double x = v50.origin.x;
              double y = v50.origin.y;
              double width = v50.size.width;
              double height = v50.size.height;
              TSTLayoutSpaceGetGridRange((uint64_t)v17);
              LODWORD(a2) = v33 + 1;
              char v37 = 1;
            }
            else if ([(TSTLayoutSpace *)v17 isRepeat] {
                   && (TSTLayoutSpaceContainsGridRange(v17, a2 | (v14 << 32), a3) & 1) != 0)
            }
            {
              return x;
            }
            goto LABEL_21;
          }
          memset(&v42, 0, sizeof(v42));
          TSTLayoutGetFrozenHeaderRowsTransformToLayout(a1, (uint64_t)&v42);
          CGAffineTransform v40 = v42;
          v53.origin.double x = x;
          v53.origin.double y = y;
          v53.size.double width = width;
          v53.size.double height = height;
          CGRect v54 = CGRectApplyAffineTransform(v53, &v40);
          double x = v54.origin.x;
          double y = v54.origin.y;
          double width = v54.size.width;
          double height = v54.size.height;
          TSTLayoutSpaceGetGridRange((uint64_t)v17);
          unint64_t v14 = (v34 + 1);
        }
        char v13 = 1;
LABEL_21:
        v55.origin.double x = v7;
        v55.origin.double y = v8;
        v55.size.double width = v9;
        v55.size.double height = v10;
        if (CGRectIsNull(v55))
        {
          double v7 = x;
          double v8 = y;
          CGFloat v9 = width;
          CGFloat v10 = height;
        }
        else
        {
          if ((v37 & (x < v7)) == 1)
          {
            double width = width - (v7 - x);
            if (width >= 0.0)
            {
              double x = x + v7 - x;
            }
            else
            {
              double x = *MEMORY[0x263F001A0];
              double y = *(double *)(MEMORY[0x263F001A0] + 8);
              double width = *(double *)(MEMORY[0x263F001A0] + 16);
              double height = *(double *)(MEMORY[0x263F001A0] + 24);
            }
          }
          if ((v13 & (y < v8)) == 1)
          {
            double height = height - (v8 - y);
            if (height >= 0.0)
            {
              double y = y + v8 - y;
            }
            else
            {
              double x = *MEMORY[0x263F001A0];
              double y = *(double *)(MEMORY[0x263F001A0] + 8);
              double width = *(double *)(MEMORY[0x263F001A0] + 16);
              double height = *(double *)(MEMORY[0x263F001A0] + 24);
            }
          }
          v56.origin.double x = v7;
          v56.origin.double y = v8;
          v56.size.double width = v9;
          v56.size.double height = v10;
          v58.origin.double x = x;
          v58.origin.double y = y;
          v58.size.double width = width;
          v58.size.double height = height;
          CGRect v57 = CGRectUnion(v56, v58);
          double v7 = v57.origin.x;
          double v8 = v57.origin.y;
          CGFloat v9 = v57.size.width;
          CGFloat v10 = v57.size.height;
        }
      }
      uint64_t v12 = [obj countByEnumeratingWithState:&v43 objects:v47 count:16];
      double x = v7;
      if (!v12) {
        return x;
      }
    }
  }
  return v7;
}

TSDBezierPath *TSTLayoutGetAlignedStrokeFramePathForRange(TSTLayout *a1, unint64_t a2, int a3, void *a4, CGFloat a5, CGFloat a6)
{
  unsigned int v6 = BYTE2(a2);
  if (BYTE2(a2) == 255) {
    unsigned int v6 = -1;
  }
  uint64_t v7 = WORD2(a2) + v6 - 1;
  if (!WORD2(a2)) {
    uint64_t v7 = 0xFFFFFFFFLL;
  }
  if ((unsigned __int16)a2 == 0xFFFF) {
    uint64_t v8 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v8 = (unsigned __int16)a2;
  }
  unint64_t v9 = v6 | ((unint64_t)v8 << 32);
  uint64_t v10 = ((a2 >> 16) & 0xFFFF00000000) + (v8 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0) {
    uint64_t v10 = 0xFFFFFFFF00000000;
  }
  return TSTLayoutGetAlignedStrokeFramePathForGridRange(a1, v9, v7 | v10, 0, a3, a4, a5, a6);
}

TSDBezierPath *TSTLayoutGetAlignedStrokeFramePathForGridRange(TSTLayout *a1, unint64_t a2, uint64_t a3, int a4, int a5, void *a6, CGFloat a7, CGFloat a8)
{
  uint64_t v87 = *MEMORY[0x263EF8340];
  long long v15 = *(_OWORD *)(MEMORY[0x263F000D0] + 16);
  long long v84 = *MEMORY[0x263F000D0];
  long long v85 = v15;
  memset(&v83, 0, sizeof(v83));
  CGAffineTransformMakeScale(&v83, a7, a7);
  uint64_t v52 = a3;
  if (a5)
  {
    AlignedStrokeFrameForGridunint64_t Range = TSTLayoutGetAlignedStrokeFrameForGridRange(a1, a2, a3, a4);
    float64x2_t v18 = vaddq_f64(*(float64x2_t *)&v83.tx, vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)&v83.c, v17), *(float64x2_t *)&v83.a, AlignedStrokeFrameForGridRange));
  }
  else
  {
    float64x2_t v18 = (float64x2_t)vdupq_n_s64(0xC0F86A0000000000);
  }
  float64x2_t v49 = v18;
  long long v79 = 0u;
  long long v80 = 0u;
  long long v81 = 0u;
  long long v82 = 0u;
  id obj = TSTLayoutGetVisibleLayoutSpaces(a1);
  uint64_t v57 = [obj countByEnumeratingWithState:&v79 objects:v86 count:16];
  if (!v57) {
    return 0;
  }
  int v47 = a5;
  uint64_t v48 = a6;
  uint64_t v19 = 0;
  int v55 = 0;
  CGRect v50 = 0;
  double v20 = 0;
  uint64_t v56 = *(void *)v80;
  unint64_t v58 = HIDWORD(a2);
  uint64_t v21 = v52;
  int v51 = a4;
  do
  {
    for (uint64_t i = 0; i != v57; ++i)
    {
      if (*(void *)v80 != v56) {
        objc_enumerationMutation(obj);
      }
      double v23 = *(TSTLayoutSpace **)(*((void *)&v79 + 1) + 8 * i);
      int v24 = [(TSTLayoutSpace *)v23 layoutSpaceType];
      if (a4 == 2)
      {
        if (!TSTLayoutSpaceIntersectsColumnGridRange(v23, a2 | (v58 << 32), v21)) {
          goto LABEL_22;
        }
        unint64_t v28 = TSTLayoutSpaceIntersectionColumnGridRange(v23, a2 | (v58 << 32), v21);
        AlignedStrokeLinePathForColumnGridunint64_t Range = TSTLayoutSpaceGetAlignedStrokeLinePathForColumnGridRange(v23, v28, v29, &v83, 0, a8);
LABEL_17:
        int v32 = AlignedStrokeLinePathForColumnGridRange;
        switch(v24)
        {
          case 1:
            TSTLayoutGetFrozenHeaderCornerTransformToLayout(a1, (uint64_t)&v76);
            long long v84 = v76;
            long long v85 = v77;
            v69[0] = v76;
            v69[1] = v77;
            v69[2] = vmulq_n_f64(v78, a7);
            [(TSDBezierPath *)v32 transformUsingAffineTransform:v69];
            uint64_t v38 = 1;
            goto LABEL_60;
          case 2:
            int v33 = v20;
            TSTLayoutGetFrozenHeaderColumnsTransformToLayout(a1, (uint64_t)&v76);
            long long v84 = v76;
            long long v85 = v77;
            v73[0] = v76;
            v73[1] = v77;
            double v74 = v78.f64[0] * a7;
            float64_t v75 = v78.f64[1];
            [(TSDBezierPath *)v32 transformUsingAffineTransform:v73];
            TSTLayoutSpaceGetGridRange((uint64_t)v23);
            int v35 = 0;
            unint64_t v34 = (v41 + 1);
            int v37 = 1;
            uint64_t v38 = 1;
            if ((v55 & 1) == 0)
            {
              int v24 = 0;
              goto LABEL_28;
            }
            break;
          case 3:
            int v33 = v20;
            unint64_t v34 = a2;
            TSTLayoutGetFrozenHeaderRowsTransformToLayout(a1, (uint64_t)&v76);
            long long v84 = v76;
            long long v85 = v77;
            v70[0] = v76;
            v70[1] = v77;
            float64_t v71 = v78.f64[0];
            double v72 = v78.f64[1] * a7;
            [(TSDBezierPath *)v32 transformUsingAffineTransform:v70];
            TSTLayoutSpaceGetGridRange((uint64_t)v23);
            int v35 = 0;
            unint64_t v58 = (v36 + 1);
            int v37 = 1;
            uint64_t v38 = 1;
            if ((v19 & 1) == 0)
            {
              int v24 = 1;
              uint64_t v38 = 0;
LABEL_28:
              a2 = v34;
              uint64_t v21 = v52;
LABEL_59:
              double v20 = v33;
              a4 = v51;
LABEL_60:
              int v55 = v24;
              if (v20)
              {
                double v20 = [(TSDBezierPath *)v20 uniteWithBezierPath:v32];
                uint64_t v19 = v38;
              }
              else
              {
                uint64_t v19 = v38;
                double v20 = v32;
              }
              continue;
            }
            break;
          default:
            if (v24)
            {
              uint64_t v38 = v19;
              int v24 = v55;
              goto LABEL_60;
            }
            if (((v19 | v55) & 1) == 0)
            {
              uint64_t v38 = v19;
              int v24 = v55;
              goto LABEL_60;
            }
            int v33 = v20;
            unint64_t v34 = a2;
            int v35 = 1;
            int v37 = v55;
            uint64_t v38 = v19;
            break;
        }
        v88.origin.double x = TSTLayoutGetAlignedMaskRectForSpace(a1, [(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space]);
        CGAffineTransform v68 = v83;
        CGRect v89 = CGRectApplyAffineTransform(v88, &v68);
        double x = v89.origin.x;
        double width = v89.size.width;
        if (!v35 || (v38 & 1) == 0)
        {
          if (v24 != 3) {
            goto LABEL_38;
          }
          if ((v38 & 1) == 0)
          {
            char v45 = v35 & v37;
            uint64_t v21 = v52;
            if ((v45 & 1) == 0)
            {
LABEL_55:
              int v24 = v37;
LABEL_56:
              if ([(TSDBezierPath *)v32 isEmpty]) {
                int v32 = 0;
              }
              a2 = v34;
              goto LABEL_59;
            }
LABEL_54:
            int v32 = [(TSDBezierPath *)v32 subtractBezierPath:+[TSDBezierPath bezierPathWithRect:TSDRectWithPoints(-100000.0, -100000.0, x + width)]];
            goto LABEL_55;
          }
        }
        int v32 = [(TSDBezierPath *)v32 subtractBezierPath:+[TSDBezierPath bezierPathWithRect:TSDRectWithPoints(-100000.0, -100000.0, v89.origin.x)]];
LABEL_38:
        if (v35 & v37)
        {
          uint64_t v21 = v52;
        }
        else
        {
          BOOL v44 = v24 == 2;
          int v24 = (v24 != 2) & v37;
          uint64_t v21 = v52;
          if (!v44 || ((v37 ^ 1) & 1) != 0) {
            goto LABEL_56;
          }
        }
        goto LABEL_54;
      }
      if (a4 != 1)
      {
        if (!TSTLayoutSpaceIntersectsGridRange(v23, a2 | (v58 << 32), v21)) {
          goto LABEL_22;
        }
        unint64_t v30 = TSTLayoutSpaceIntersectionGridRange(v23, a2 | (v58 << 32), v21);
        AlignedStrokeLinePathForColumnGridunint64_t Range = TSTLayoutSpaceGetAlignedStrokeFramePathForGridRange(v23, v30, v31, &v83, 0, a8);
        goto LABEL_17;
      }
      if (TSTLayoutSpaceIntersectsRowGridRange((uint64_t)v23, a2 | (v58 << 32), v21))
      {
        uint64_t v25 = TSTLayoutSpaceIntersectionRowGridRange((uint64_t)v23, a2 | (v58 << 32), v21);
        AlignedStrokeLinePathForColumnGridunint64_t Range = TSTLayoutSpaceGetAlignedStrokeLinePathForRowGridRange(v23, v25, v26, &v83, 0, a8);
        goto LABEL_17;
      }
LABEL_22:
      if ([(TSTLayoutSpace *)v23 isFrozen])
      {
        AlignedMaskStrokeFramePathForGridunint64_t Range = (void *)TSTLayoutSpaceGetAlignedMaskStrokeFramePathForGridRange(v23, (long long *)&v83);
        if (v24 == 3)
        {
          TSTLayoutGetFrozenHeaderRowsTransformToLayout(a1, (uint64_t)&v76);
          long long v84 = v76;
          long long v85 = v77;
          v62[0] = v76;
          v62[1] = v77;
          float64_t v63 = v78.f64[0];
          double v64 = v78.f64[1] * a7;
          CGAffineTransform v40 = v62;
        }
        else if (v24 == 2)
        {
          TSTLayoutGetFrozenHeaderColumnsTransformToLayout(a1, (uint64_t)&v76);
          long long v84 = v76;
          long long v85 = v77;
          v65[0] = v76;
          v65[1] = v77;
          double v66 = v78.f64[0] * a7;
          float64_t v67 = v78.f64[1];
          CGAffineTransform v40 = v65;
        }
        else
        {
          TSTLayoutGetFrozenHeaderCornerTransformToLayout(a1, (uint64_t)&v76);
          long long v84 = v76;
          long long v85 = v77;
          v61[0] = v76;
          v61[1] = v77;
          v61[2] = vmulq_n_f64(v78, a7);
          CGAffineTransform v40 = v61;
        }
        [AlignedMaskStrokeFramePathForGridRange transformUsingAffineTransform:v40];
        if (AlignedMaskStrokeFramePathForGridRange)
        {
          if (([AlignedMaskStrokeFramePathForGridRange isEmpty] & 1) == 0)
          {
            if (v50) {
              CGRect v50 = (void *)[v50 uniteWithBezierPath:AlignedMaskStrokeFramePathForGridRange];
            }
            else {
              CGRect v50 = AlignedMaskStrokeFramePathForGridRange;
            }
          }
        }
      }
    }
    uint64_t v57 = [obj countByEnumeratingWithState:&v79 objects:v86 count:16];
  }
  while (v57);
  if (v20)
  {
    if (v47)
    {
      CGAffineTransformMakeTranslation(&v60, -v49.f64[0], -v49.f64[1]);
      [(TSDBezierPath *)v20 transformUsingAffineTransform:&v60];
      CGAffineTransformMakeTranslation(&v59, -v49.f64[0], -v49.f64[1]);
      [v50 transformUsingAffineTransform:&v59];
    }
    if (v48) {
      *uint64_t v48 = v50;
    }
  }
  return v20;
}

double TSTLayoutGetAlignedContentFrameForRange(TSTLayout *a1, unint64_t a2)
{
  unsigned int v2 = BYTE2(a2);
  if (BYTE2(a2) == 255) {
    unsigned int v2 = -1;
  }
  uint64_t v3 = WORD2(a2) + v2 - 1;
  if (!WORD2(a2)) {
    uint64_t v3 = 0xFFFFFFFFLL;
  }
  if ((unsigned __int16)a2 == 0xFFFF) {
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v4 = (unsigned __int16)a2;
  }
  unint64_t v5 = v2 | ((unint64_t)v4 << 32);
  uint64_t v6 = ((a2 >> 16) & 0xFFFF00000000) + (v4 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0) {
    uint64_t v6 = 0xFFFFFFFF00000000;
  }
  return TSTLayoutGetArbitraryRectAcrossSpacesForGridRange(a1, v5, v3 | v6, (uint64_t)&__block_literal_global_72);
}

double TSTLayoutGetAlignedContentFrameForGridRange(TSTLayout *a1, unint64_t a2, uint64_t a3)
{
  return TSTLayoutGetArbitraryRectAcrossSpacesForGridRange(a1, a2, a3, (uint64_t)&__block_literal_global_72);
}

double __TSTLayoutGetAlignedContentFrameForGridRange_block_invoke(uint64_t a1, TSTLayoutSpace *a2, unint64_t a3, unint64_t a4)
{
  return TSTLayoutSpaceGetAlignedContentFrameForGridRange(a2, a3, a4);
}

void sub_2237EB5AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
}

void __Block_byref_object_copy__73(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__74(uint64_t a1)
{
}

BOOL TSTLayoutTableNameHitByCanvasPoint(TSTLayout *a1, double a2, double a3)
{
  if (!a1->mTableNameVisible) {
    return 0;
  }
  double FrameForTableName = TSTLayoutGetFrameForTableName(a1);
  CGFloat y = v7;
  double width = v9;
  CGFloat height = v11;
  if (TSTLayoutGetFrozenHeaderRowsEnabled(a1))
  {
    if (TSTLayoutGetFrozenHeaderRowsFloating(a1))
    {
      memset(&v20, 0, sizeof(v20));
      TSTLayoutGetFrozenTableNameTransformToLayout(a1, &v20);
      CGAffineTransform v19 = v20;
      v22.origin.double x = FrameForTableName;
      v22.origin.CGFloat y = y;
      v22.size.double width = width;
      v22.size.CGFloat height = height;
      CGRect v23 = CGRectApplyAffineTransform(v22, &v19);
      double FrameForTableName = v23.origin.x;
      CGFloat y = v23.origin.y;
      double width = v23.size.width;
      CGFloat height = v23.size.height;
    }
  }
  TSTLayoutGetRowTabsRangeFrame(a1, [(TSTTableModel *)[(TSTLayout *)a1 tableModel] range]);
  double v14 = FrameForTableName - v13;
  CGFloat v15 = FrameForTableName - v14;
  CGFloat v16 = width + v14;
  v21.double x = TSTLayoutSpaceGetLayoutPointForCanvasPoint((uint64_t)[(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space], a2, a3);
  v21.CGFloat y = v17;
  v24.origin.double x = v15;
  v24.origin.CGFloat y = y;
  v24.size.double width = v16;
  v24.size.CGFloat height = height;
  return CGRectContainsPoint(v24, v21);
}

double TSTLayoutGetFrameForTableName(void *a1)
{
  long long v2 = *(_OWORD *)(MEMORY[0x263F001A8] + 16);
  long long v12 = *MEMORY[0x263F001A8];
  long long v13 = v2;
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  if (v3 <= 0.0) {
    return *(double *)&v12;
  }
  double v4 = v3;
  unint64_t v5 = (TSTLayoutSpace *)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");
  Gridunint64_t Range = TSTLayoutSpaceGetGridRange((uint64_t)v5);
  FrameForGridunint64_t Range = TSTLayoutSpaceGetFrameForGridRange(v5, GridRange, v7);
  *(double *)&long long v12 = FrameForGridRange;
  *((double *)&v12 + 1) = v9 - v4;
  *(void *)&long long v13 = v10;
  *((double *)&v13 + 1) = v4;
  TSTLayoutSpaceAlignRect((double *)v5, (CGFloat *)&v12);
  return FrameForGridRange;
}

BOOL TSTLayoutTableNameChromeHitByCanvasPoint(TSTLayout *a1, double a2, double a3)
{
  if (!a1->mTableNameVisible) {
    return 0;
  }
  double FrameForTableName = TSTLayoutGetFrameForTableName(a1);
  CGFloat y = v7;
  CGFloat v10 = v9;
  CGFloat height = v11;
  if (TSTLayoutGetFrozenHeaderRowsEnabled(a1))
  {
    if (TSTLayoutGetFrozenHeaderRowsFloating(a1))
    {
      memset(&v20, 0, sizeof(v20));
      TSTLayoutGetFrozenTableNameTransformToLayout(a1, &v20);
      CGAffineTransform v19 = v20;
      v22.origin.double x = FrameForTableName;
      v22.origin.CGFloat y = y;
      v22.size.double width = v10;
      v22.size.CGFloat height = height;
      CGRect v23 = CGRectApplyAffineTransform(v22, &v19);
      CGFloat y = v23.origin.y;
      CGFloat height = v23.size.height;
    }
  }
  TSTLayoutGetRowTabsRangeFrame(a1, [(TSTTableModel *)[(TSTLayout *)a1 tableModel] range]);
  CGFloat v14 = v13;
  CGFloat v16 = v15;
  v21.double x = TSTLayoutSpaceGetLayoutPointForCanvasPoint((uint64_t)[(TSTLayoutSpaceBundle *)[(TSTLayout *)a1 spaceBundle] space], a2, a3);
  v21.CGFloat y = v17;
  v24.origin.double x = v14;
  v24.origin.CGFloat y = y;
  v24.size.double width = v16;
  v24.size.CGFloat height = height;
  return CGRectContainsPoint(v24, v21);
}

uint64_t TSTLayoutTableNameBorderEnabled(unsigned char *a1)
{
  if (!a1[387]) {
    return 0;
  }
  long long v1 = (void *)[a1 tableModel];
  if (![v1 tableNameBorderEnabled]) {
    return 0;
  }

  return [v1 hasTableBorder];
}

double TSTLayoutTableNameBorderStrokeWidth(unsigned char *a1)
{
  if (!a1[387]) {
    return 0.0;
  }
  long long v2 = (void *)[a1 tableModel];
  if (![v2 tableNameBorderEnabled] || !objc_msgSend(v2, "hasTableBorder")) {
    return 0.0;
  }
  double v3 = objc_msgSend((id)objc_msgSend(a1, "tableModel"), "tableNameBorderStroke");

  [v3 width];
  return result;
}

void TSTLayoutGetVisibleRectForTableName(unsigned char *a1)
{
  if (a1[387])
  {
    double FrameForTableName = TSTLayoutGetFrameForTableName(a1);
    CGFloat v4 = v3;
    CGFloat v6 = v5;
    CGFloat v8 = v7;
    v13.origin.double x = TSTLayoutGetVisibleRect((double *)a1);
    v13.origin.CGFloat y = v9;
    v13.size.double width = v10;
    v13.size.CGFloat height = v11;
    v12.origin.double x = FrameForTableName;
    v12.origin.CGFloat y = v4;
    v12.size.double width = v6;
    v12.size.CGFloat height = v8;
    CGRectIntersection(v12, v13);
  }
}

double TSTLayoutGetFrameForTableNameBorder(void *a1)
{
  long long v1 = (TSTLayoutSpace *)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");

  return TSTLayoutSpaceGetFrameForTableNameBorder(v1);
}

double TSTLayoutGetStrokeFrameForTableNameBorder(void *a1)
{
  long long v1 = (TSTLayoutSpace *)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");

  return TSTLayoutSpaceGetStrokeFrameForTableNameBorder(v1);
}

double TSTLayoutGetCanvasFrameForTableName(void *a1)
{
  uint64_t v2 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");
  double FrameForTableName = TSTLayoutGetFrameForTableName(a1);

  return TSTLayoutSpaceGetCanvasRectForLayoutRect(v2, FrameForTableName, v4, v5, v6);
}

double TSTLayoutGetFrameForFrozenTableName(TSTLayout *a1)
{
  double FrameForTableName = TSTLayoutGetFrameForTableName(a1);
  CGFloat v4 = v3;
  CGFloat v6 = v5;
  CGFloat v8 = v7;
  if (TSTLayoutGetFrozenHeaderRowsEnabled(a1) && TSTLayoutGetFrozenHeaderRowsFloating(a1))
  {
    memset(&v11, 0, sizeof(v11));
    TSTLayoutGetFrozenTableNameTransformToLayout(a1, &v11);
    CGAffineTransform v10 = v11;
    v12.origin.double x = FrameForTableName;
    v12.origin.CGFloat y = v4;
    v12.size.double width = v6;
    v12.size.CGFloat height = v8;
    *(void *)&double FrameForTableName = (unint64_t)CGRectApplyAffineTransform(v12, &v10);
  }
  return FrameForTableName;
}

uint64_t TSTLayoutCellLeftOfCell(void *a1, uint64_t a2, int a3)
{
  uint64_t v29 = [a1 tableModel];
  if ((a2 & 0xFF0000) == 0) {
    return 0xFFFFFFLL;
  }
  uint64_t v7 = (a2 << 16) & 0xFF00000000 | (unsigned __int16)a2 | 0x1000000000000;
  if (a3) {
    uint64_t v8 = 293;
  }
  else {
    uint64_t v8 = 261;
  }
  CGFloat v9 = [[TSTLayoutCellIterator alloc] initWithLayout:a1 range:v7 flags:v8];
  uint64_t v10 = 0xFFFFFFLL;
  CGAffineTransform v11 = &stru_26D688A48;
  unint64_t v12 = 0x263F7C000uLL;
  while (TSTLayoutCellIteratorGetNextCell((uint64_t)v9, &v32))
  {
    uint64_t v13 = v33;
    if (!v33)
    {
      uint64_t v31 = 0;
      goto LABEL_15;
    }
    int v14 = *(_DWORD *)(v33 + 8);
    if ((v14 & 0xFF00) == 0)
    {
      uint64_t v31 = 0;
      if (*(unsigned char *)(v33 + 9))
      {
LABEL_20:
        if ((_WORD)v10 == 0xFFFF || (v10 & 0xFF0000) == 0xFF0000)
        {
          float64x2_t v18 = (void *)[a1 masterLayout];
          unint64_t v3 = v3 & 0xFFFFFFFF00000000 | HIDWORD(v32);
          unint64_t v19 = TSTTableMergeRangeAtCellID(v29, [v18 modelCellIDForLayoutCellID:v3]);
          if ((_WORD)v19 != 0xFFFF && (v19 & 0xFF0000) != 0xFF0000)
          {
            if ((v19 & 0xFFFF00000000) != 0 && HIWORD(v19) != 0) {
              uint64_t v10 = HIDWORD(v32);
            }
            else {
              uint64_t v10 = v10;
            }
          }
        }
        goto LABEL_38;
      }
LABEL_15:
      if (objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "isDynamicallyChangingContent"))
      {
        CGFloat v17 = objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "dynamicContentDelegate");
        unint64_t v30 = v30 & 0xFFFFFFFF00000000 | HIDWORD(v32);
        if (objc_msgSend(v17, "cell:forCellID:", &v31)) {
          uint64_t v10 = HIDWORD(v32);
        }
        else {
          uint64_t v10 = v10;
        }
      }
      goto LABEL_20;
    }
    if ((*(_DWORD *)(v33 + 8) & 0xFF00) != 0x300) {
      goto LABEL_37;
    }
    int v15 = BYTE1(v14);
    if (v15)
    {
      if (v15 == 9)
      {
        CGFloat v16 = (__CFString *)[*(id *)(v33 + 72) string];
      }
      else if (v15 == 3)
      {
        CGFloat v16 = *(__CFString **)(v33 + 24);
      }
      else
      {
        CGRect v22 = (void *)[*(id *)(v12 + 2032) currentHandler];
        unint64_t v23 = v12;
        CGRect v24 = v11;
        uint64_t v25 = [NSString stringWithUTF8String:"NSString *TSTCellStringValue(TSTCell *)"];
        uint64_t v26 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"];
        uint64_t v27 = v25;
        CGAffineTransform v11 = v24;
        unint64_t v12 = v23;
        objc_msgSend(v22, "handleFailureInFunction:file:lineNumber:description:", v27, v26, 972, @"can't get string from non-string cell: %p", v13);
        CGFloat v16 = 0;
      }
    }
    else
    {
      CGFloat v16 = v11;
    }
    if ([(__CFString *)v16 length]) {
LABEL_37:
    }
      uint64_t v10 = HIDWORD(v32);
LABEL_38:
    if ((_WORD)v10 != 0xFFFF && (v10 & 0xFF0000) != 0xFF0000) {
      break;
    }
  }

  return v10;
}

uint64_t TSTLayoutCellRightOfCell(void *a1, int a2, int a3)
{
  uint64_t v29 = [a1 tableModel];
  if (BYTE2(a2) >= (int)(TSTMasterLayoutGetTableNumberOfColumns([a1 masterLayout]) - 1)) {
    return 0xFFFFFFLL;
  }
  LODWORD(v7) = (unsigned __int16)(TSTMasterLayoutGetTableNumberOfColumns([a1 masterLayout]) + ~BYTE2(a2));
  if (v7 >= 0xFF) {
    uint64_t v7 = 255;
  }
  else {
    uint64_t v7 = v7;
  }
  if (a3) {
    uint64_t v8 = 289;
  }
  else {
    uint64_t v8 = 257;
  }
  CGFloat v9 = [[TSTLayoutCellIterator alloc] initWithLayout:a1 range:(a2 + 0x10000) & 0xFF0000 | (unint64_t)(unsigned __int16)a2 | (v7 << 32) | 0x1000000000000 flags:v8];
  uint64_t v10 = 0xFFFFFFLL;
  CGAffineTransform v11 = &stru_26D688A48;
  unint64_t v12 = 0x263F7C000uLL;
  while (TSTLayoutCellIteratorGetNextCell((uint64_t)v9, &v32))
  {
    uint64_t v13 = v33;
    if (!v33)
    {
      uint64_t v31 = 0;
      goto LABEL_18;
    }
    int v14 = *(_DWORD *)(v33 + 8);
    if ((v14 & 0xFF00) == 0)
    {
      uint64_t v31 = 0;
      if (*(unsigned char *)(v33 + 9))
      {
LABEL_23:
        if ((_WORD)v10 == 0xFFFF || (v10 & 0xFF0000) == 0xFF0000)
        {
          float64x2_t v18 = (void *)[a1 masterLayout];
          unint64_t v3 = v3 & 0xFFFFFFFF00000000 | HIDWORD(v32);
          unint64_t v19 = TSTTableMergeRangeAtCellID(v29, [v18 modelCellIDForLayoutCellID:v3]);
          if ((_WORD)v19 != 0xFFFF && (v19 & 0xFF0000) != 0xFF0000)
          {
            if ((v19 & 0xFFFF00000000) != 0 && HIWORD(v19) != 0) {
              uint64_t v10 = HIDWORD(v32);
            }
            else {
              uint64_t v10 = v10;
            }
          }
        }
        goto LABEL_41;
      }
LABEL_18:
      if (objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "isDynamicallyChangingContent"))
      {
        CGFloat v17 = objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "dynamicContentDelegate");
        unint64_t v30 = v30 & 0xFFFFFFFF00000000 | HIDWORD(v32);
        if (objc_msgSend(v17, "cell:forCellID:", &v31)) {
          uint64_t v10 = HIDWORD(v32);
        }
        else {
          uint64_t v10 = v10;
        }
      }
      goto LABEL_23;
    }
    if ((*(_DWORD *)(v33 + 8) & 0xFF00) != 0x300) {
      goto LABEL_40;
    }
    int v15 = BYTE1(v14);
    if (v15)
    {
      if (v15 == 9)
      {
        CGFloat v16 = (__CFString *)[*(id *)(v33 + 72) string];
      }
      else if (v15 == 3)
      {
        CGFloat v16 = *(__CFString **)(v33 + 24);
      }
      else
      {
        CGRect v22 = (void *)[*(id *)(v12 + 2032) currentHandler];
        unint64_t v23 = v12;
        CGRect v24 = v11;
        uint64_t v25 = [NSString stringWithUTF8String:"NSString *TSTCellStringValue(TSTCell *)"];
        uint64_t v26 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"];
        uint64_t v27 = v25;
        CGAffineTransform v11 = v24;
        unint64_t v12 = v23;
        objc_msgSend(v22, "handleFailureInFunction:file:lineNumber:description:", v27, v26, 972, @"can't get string from non-string cell: %p", v13);
        CGFloat v16 = 0;
      }
    }
    else
    {
      CGFloat v16 = v11;
    }
    if ([(__CFString *)v16 length]) {
LABEL_40:
    }
      uint64_t v10 = HIDWORD(v32);
LABEL_41:
    if ((_WORD)v10 != 0xFFFF && (v10 & 0xFF0000) != 0xFF0000) {
      break;
    }
  }

  return v10;
}

uint64_t TSTLayoutGetCellStyleAtCellID(void *a1, unint64_t a2, char *a3)
{
  int v4 = a2;
  unsigned __int16 v6 = a2;
  unint64_t v7 = a2 >> 16;
  uint64_t v8 = (void *)[a1 tableModel];
  if (objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "isDynamicallyChangingRowOrColumnCount"))
  {
    if ([v8 numberOfRows] <= (unsigned __int16)v4) {
      unsigned __int16 v6 = [v8 numberOfRows];
    }
    if ([v8 numberOfColumns] <= v7) {
      LOBYTE(v7) = [v8 numberOfColumns];
    }
  }

  return TSTTableGetCellStyleAtCellID((uint64_t *)v8, v4 & 0xFF000000 | v6 | (v7 << 16), a3);
}

void sub_2237EE0B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__98(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  return result;
}

void sub_2237EE228(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t TSTLayoutStarRatingForCanvasPoint(TSTLayout *a1, unint64_t a2, double a3)
{
  CanvasFrameForunint64_t Range = TSTLayoutGetCanvasFrameForRange(a1, a2);
  double v6 = (a3 - CanvasFrameForRange) / v5;
  if (v6 < 0.0700000003) {
    return 0;
  }
  if (v6 < 0.200000003) {
    return 1;
  }
  if (v6 < 0.400000006) {
    return 2;
  }
  if (v6 < 0.600000024) {
    return 3;
  }
  if (v6 >= 0.800000012) {
    return 5;
  }
  return 4;
}

uint64_t ___ZL28TSTLayoutUpdateFrozenHeadersP9TSTLayout_block_invoke(uint64_t a1, void *a2)
{
  [a2 setViewScale:*(double *)(a1 + 32)];
  long long v4 = *(_OWORD *)(a1 + 56);
  v8[0] = *(_OWORD *)(a1 + 40);
  v8[1] = v4;
  v8[2] = *(_OWORD *)(a1 + 72);
  [a2 setTransformToCanvas:v8];
  long long v5 = *(_OWORD *)(a1 + 104);
  v7[0] = *(_OWORD *)(a1 + 88);
  v7[1] = v5;
  _OWORD v7[2] = *(_OWORD *)(a1 + 120);
  TSTLayoutSpaceSetUserSpaceToDeviceSpaceTransform((uint64_t)a2, v7);
  return 0;
}

uint64_t ___ZL28TSTLayoutUpdateRepeatHeadersP9TSTLayout_block_invoke(uint64_t a1, void *a2)
{
  [a2 setHeaderRowsRepeat:*(unsigned __int8 *)(a1 + 136)];
  [a2 setHeaderColumnsRepeat:*(unsigned __int8 *)(a1 + 137)];
  [a2 setViewScale:*(double *)(a1 + 32)];
  long long v4 = *(_OWORD *)(a1 + 56);
  v8[0] = *(_OWORD *)(a1 + 40);
  v8[1] = v4;
  v8[2] = *(_OWORD *)(a1 + 72);
  [a2 setTransformToCanvas:v8];
  long long v5 = *(_OWORD *)(a1 + 104);
  v7[0] = *(_OWORD *)(a1 + 88);
  v7[1] = v5;
  _OWORD v7[2] = *(_OWORD *)(a1 + 120);
  TSTLayoutSpaceSetUserSpaceToDeviceSpaceTransform((uint64_t)a2, v7);
  return 0;
}

id TSTStrokeRunSet(id result, int a2, int a3, TSDStroke *a4, char a5, int a6)
{
  uint64_t v10 = (uint64_t)result;
  CGAffineTransform v11 = (TSDStroke *)*((void *)result + 1);
  if (v11 != a4)
  {

    *(void *)(v10 + 8) = a4;
    uint64_t v13 = 0;
    if (a4 && ![(TSDStroke *)a4 empty])
    {
      [(TSDStroke *)a4 width];
      uint64_t v13 = v14;
    }
    *(void *)(v10 + 16) = v13;
    __n128 result = *(id *)(v10 + 8);
  }
  *(_DWORD *)uint64_t v10 = a2;
  *(_DWORD *)(v10 + 4) = a3;
  if (a6) {
    char v15 = 2;
  }
  else {
    char v15 = 0;
  }
  *(unsigned char *)(v10 + 24) = v15 | a5 | *(unsigned char *)(v10 + 24) & 0xFC;
  return result;
}

uint64_t TSTStrokeRunArrayGetStrokeRun(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 24) <= a2) {
    return 0;
  }
  else {
    return *(void *)(a1 + 40) + 32 * a2;
  }
}

uint64_t TSTStrokeRunArrayGetCount(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 24);
  }
  return result;
}

TSTStrokeRunArray *TSTStrokeRunArrayCopy(uint64_t a1)
{
  if (a1) {
    uint64_t v1 = *(unsigned int *)(a1 + 24);
  }
  else {
    uint64_t v1 = 0;
  }
  uint64_t v2 = [[TSTStrokeRunArray alloc] initWithCount:v1];
  unint64_t v3 = v2;
  if (v1)
  {
    memcpy(v2->mStrokes, *(const void **)(a1 + 40), 32 * v1);
    unint64_t v4 = 0;
    uint64_t v5 = 8;
    do
    {
      if (v4 < v3->mCount && (mStrokes = v3->mStrokes) != 0)
      {
        id v7 = *(id *)((char *)&mStrokes->var0 + v5);
      }
      else
      {
        uint64_t v8 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v9 = [NSString stringWithUTF8String:"TSTStrokeRunArray *TSTStrokeRunArrayCopy(TSTStrokeRunArray *)"];
        objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTStrokeRunArray.mm"), 176, @"NULL strokeRun");
      }
      ++v4;
      v5 += 32;
    }
    while (v1 != v4);
  }
  if (a1)
  {
    v3->mHasCustomStrokes = *(unsigned char *)(a1 + 8);
    v3->mMaxsize_t Width = *(double *)(a1 + 16);
  }
  return v3;
}

unsigned int *TSTStrokeRunArrayGetNextStroke(uint64_t a1, unsigned int a2, unsigned int a3, _DWORD *a4)
{
  if (!a1) {
    return 0;
  }
  uint64_t v4 = *a4;
  if (!v4)
  {
    uint64_t v6 = *(unsigned int *)(a1 + 32);
    if (v6 >= *(_DWORD *)(a1 + 24))
    {
      *(_DWORD *)(a1 + 32) = 0;
      LODWORD(v6) = *a4;
    }
    else if (v6)
    {
      if (*(_DWORD *)(*(void *)(a1 + 40) + 32 * v6) <= a2) {
        *a4 = v6;
      }
      else {
        LODWORD(v6) = 0;
      }
    }
    while (*(_DWORD *)(a1 + 24) > v6)
    {
      uint64_t v5 = *(unsigned int **)(a1 + 40);
      if (!v5) {
        return v5;
      }
      uint64_t v7 = v6;
      *(_DWORD *)(a1 + 32) = v6;
      LODWORD(v6) = *a4 + 1;
      *a4 = v6;
      v5 += 8 * v7;
      if (v5[1] > a2) {
        goto LABEL_14;
      }
    }
    return 0;
  }
  if (v4 >= *(_DWORD *)(a1 + 24)) {
    return 0;
  }
  uint64_t v5 = (unsigned int *)(*(void *)(a1 + 40) + 32 * v4);
  *(_DWORD *)(a1 + 32) = v4;
  ++*a4;
LABEL_14:
  if (*v5 >= a3 || v5[1] <= a2) {
    return 0;
  }
  return v5;
}

unsigned int *TSTStrokeRunArrayLookupStroke(unsigned int *result, unsigned int a2)
{
  int v3 = 0;
  if (result)
  {
    __n128 result = TSTStrokeRunArrayGetNextStroke((uint64_t)result, a2, a2 + 1, &v3);
    if (!result || *result > a2 || result[1] <= a2) {
      return 0;
    }
  }
  return result;
}

TSTStrokeRunArray *TSTStrokeRunArrayCreateWithArguments(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = a1;
  int v3 = [[TSTStrokeRunArray alloc] initWithCount:a1];
  if (v2)
  {
    unint64_t v4 = 0;
    uint64_t v5 = (int *)a2;
    unint64_t v19 = (TSDStroke **)(a2 + 8);
    int v6 = *v5;
    uint64_t v7 = v2;
    while (1)
    {
      int v8 = v6;
      uint64_t v9 = v19;
      uint64_t v10 = *v19;
      v19 += 2;
      CGAffineTransform v11 = v4 >= v3->mCount ? 0 : &v3->mStrokes[v4];
      int v6 = *((_DWORD *)v9 + 2);
      TSTStrokeRunSet(v11, v8, v6, v10, 0, 0);
      mMaxsize_t Width = v3->mMaxWidth;
      if (v10) {
        break;
      }
      double v15 = 0.0;
      if (mMaxWidth > 0.0) {
        goto LABEL_12;
      }
LABEL_15:
      v3->mMaxsize_t Width = v15;
      if (++v4 == v7) {
        return v3;
      }
    }
    BOOL v13 = [(TSDStroke *)v10 empty];
    double v14 = 0.0;
    if (!v13) {
      [(TSDStroke *)v10 width];
    }
    if (mMaxWidth <= v14)
    {
      BOOL v16 = [(TSDStroke *)v10 empty];
      double v15 = 0.0;
      if (!v16) {
        [(TSDStroke *)v10 width];
      }
      goto LABEL_15;
    }
    mMaxsize_t Width = v3->mMaxWidth;
LABEL_12:
    double v15 = mMaxWidth;
    goto LABEL_15;
  }
  return v3;
}

TSTStrokeRunArray *TSTStrokeRunArrayCreateWithStroke(TSDStroke *a1, int a2, int a3)
{
  int v6 = [[TSTStrokeRunArray alloc] initWithCount:1];
  uint64_t v7 = v6;
  if (v6->mCount) {
    mStrokes = v6->mStrokes;
  }
  else {
    mStrokes = 0;
  }
  TSTStrokeRunSet(mStrokes, a2, a3, a1, 0, 0);
  double v9 = 0.0;
  if ([(TSDStroke *)a1 pattern])
  {
    uint64_t v10 = [(TSDStrokePattern *)[(TSDStroke *)a1 pattern] patternType];
    if (a1)
    {
      if (v10 != 2)
      {
        [(TSDStroke *)a1 width];
        double v9 = v11;
      }
    }
  }
  v7->mMaxsize_t Width = v9;
  return v7;
}

TSTStrokeRunArray *TSTStrokeRunArrayInsertDefaultStroke(TSTStrokeRunArray *a1, unsigned int a2, unsigned int a3, TSDStroke *a4)
{
  insertedouble d = p_TSTStrokeRunArrayInsertStroke(a1, a2, a3, a4, 0, 0);
  p_updateStrokeRunArrayMetadata((uint64_t)inserted);
  return a1;
}

TSTStrokeRunArray *p_TSTStrokeRunArrayInsertStroke(TSTStrokeRunArray *a1, unsigned int var0, unsigned int var1, TSDStroke *a4, int a5, int a6)
{
  mMaxsize_t Width = a1->mMaxWidth;
  if (!a4)
  {
    double v13 = 0.0;
    if (mMaxWidth <= 0.0) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  BOOL v11 = [(TSDStroke *)a4 empty];
  double v12 = 0.0;
  if (!v11) {
    [(TSDStroke *)a4 width];
  }
  if (mMaxWidth > v12)
  {
    mMaxsize_t Width = a1->mMaxWidth;
LABEL_7:
    double v13 = mMaxWidth;
    goto LABEL_10;
  }
  BOOL v14 = [(TSDStroke *)a4 empty];
  double v13 = 0.0;
  if (!v14) {
    [(TSDStroke *)a4 width];
  }
LABEL_10:
  a1->mMaxsize_t Width = v13;
  unsigned int v87 = 0;
  NextStroke = TSTStrokeRunArrayGetNextStroke((uint64_t)a1, var0, var0 + 1, &v87);
  if (!NextStroke)
  {
    if (!v87
      || ((v24 = v87 - 1, a1->mCount <= v24) ? (CGAffineTransform v20 = 0) : (CGAffineTransform v20 = &a1->mStrokes[v24]),
          v20->var1 != var0
       || (char v33 = *((unsigned char *)v20 + 24), ((v33 & 1) == 0) == a5)
       || ((v33 & 2) == 0) == a6
       || (unint64_t var2 = (TSDStroke *)v20->var2, var2 != a4) && ![(TSDStroke *)var2 isEqualToStroke:a4]))
    {
      mCFIndex Count = a1->mCount;
      BOOL v36 = mCount != 0;
      unsigned int v37 = mCount - 1;
      if (v36) {
        unsigned int v38 = v37;
      }
      else {
        unsigned int v38 = 0;
      }
      TSTStrokeRunArrayExpand(a1, v38, 1u);
      unsigned int v39 = a1->mCount;
      if (v39)
      {
        CGAffineTransform v40 = &a1->mStrokes[v39 - 1];
LABEL_62:
        int v54 = var0;
        int v55 = var1;
        uint64_t v56 = a4;
        char v57 = a5;
        int v58 = a6;
LABEL_63:
        TSTStrokeRunSet(v40, v54, v55, v56, v57, v58);
        return a1;
      }
LABEL_61:
      CGAffineTransform v40 = 0;
      goto LABEL_62;
    }
    goto LABEL_37;
  }
  BOOL v16 = (TSTStrokeRun *)NextStroke;
  unsigned int v17 = *NextStroke;
  if (*NextStroke <= var0)
  {
    char v18 = *((unsigned char *)NextStroke + 24);
    if (((v18 & 1) == 0) != a5 && ((v18 & 2) == 0) != a6)
    {
      unint64_t v19 = (TSDStroke *)*((void *)NextStroke + 1);
      if (v19 == a4)
      {
        unsigned int var0 = v17;
        goto LABEL_44;
      }
      if ([(TSDStroke *)v19 isEqualToStroke:a4])
      {
        CGAffineTransform v20 = v16;
LABEL_37:
        unsigned int var0 = v20->var0;
        BOOL v16 = v20;
        goto LABEL_44;
      }
    }
  }
  unsigned int v21 = v87;
  uint64_t v22 = v87 - 2;
  if (v87 >= 2)
  {
    if (a1->mCount > v22 && (mStrokes = a1->mStrokes) != 0)
    {
      CGAffineTransform v20 = &mStrokes[v22];
    }
    else
    {
      uint64_t v25 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
      int v26 = a6;
      int v27 = a5;
      uint64_t v28 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTStrokeRunArray *p_TSTStrokeRunArrayInsertStroke(TSTStrokeRunArray *, TSTGridIndex, TSTGridIndex, TSDStroke *, BOOL, BOOL)");
      uint64_t v29 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTStrokeRunArray.mm"];
      uint64_t v30 = v28;
      a5 = v27;
      a6 = v26;
      [v25 handleFailureInFunction:v30 file:v29 lineNumber:427 description:@"previousStrokeRun must be non-NULL"];
      CGAffineTransform v20 = 0;
    }
    if (v20->var1 == var0)
    {
      char v31 = *((unsigned char *)v20 + 24);
      if (((v31 & 1) == 0) != a5 && ((v31 & 2) == 0) != a6)
      {
        uint64_t v32 = (TSDStroke *)v20->var2;
        if (v32 == a4 || [(TSDStroke *)v32 isEqualToStroke:a4])
        {
          unsigned int v87 = v21 - 1;
          goto LABEL_37;
        }
      }
    }
  }
LABEL_44:
  unsigned int v41 = v16->var0;
  uint64_t v42 = v87;
  uint64_t v43 = v87 - 1;
  if (v41 >= var1)
  {
    TSTStrokeRunArrayExpand(a1, v87 - 1, 1u);
    if (a1->mCount > v43)
    {
      CGAffineTransform v40 = &a1->mStrokes[v43];
      goto LABEL_62;
    }
    goto LABEL_61;
  }
  unsigned int v44 = a1->mCount;
  int v84 = a5;
  if (v87 >= v44)
  {
    unsigned int v53 = v87;
  }
  else
  {
    *(void *)CGAffineTransform v83 = v87 - 1;
    uint64_t v45 = 0;
    uint64_t v46 = v87;
    while (1)
    {
      int v47 = a1->mStrokes;
      a1->mLastLookup = v42 + v45;
      if (!v47) {
        break;
      }
      unsigned int v48 = v47[v46].var0;
      if (v48 >= var1)
      {
        if (v48 != var1
          || (char v49 = *((unsigned char *)&v47[v46] + 24), ((v49 & 1) == 0) == a5)
          || ((v49 & 2) == 0) == a6
          || (CGRect v50 = &v47[v46], v51 = (TSDStroke *)v47[v46].var2, v51 != a4)
          && (v52 = [(TSDStroke *)v51 isEqualToStroke:a4], unsigned int v44 = a1->mCount, !v52))
        {
LABEL_58:
          unsigned int v53 = v42 + v45;
          goto LABEL_67;
        }
        if (var1 <= v50->var1) {
          var1 = v50->var1;
        }
        a5 = v84;
      }
      ++v45;
      ++v46;
      if (v42 + v45 >= (unint64_t)v44) {
        goto LABEL_58;
      }
    }
    unsigned int v53 = v42 + v45 + 1;
LABEL_67:
    uint64_t v43 = *(void *)v83;
  }
  uint64_t v60 = v53 - 1;
  if (v44 <= v43) {
    CGFloat v61 = 0;
  }
  else {
    CGFloat v61 = &a1->mStrokes[v43];
  }
  *(_DWORD *)CGAffineTransform v83 = a6;
  if (v44 > v60 && (double v62 = a1->mStrokes) != 0)
  {
    int v63 = 0;
    double v64 = &v62[v60];
  }
  else
  {
    double v65 = objc_msgSend(MEMORY[0x263F7C7F0], "currentHandler", *(void *)v83);
    uint64_t v66 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTStrokeRunArray *p_TSTStrokeRunArrayInsertStroke(TSTStrokeRunArray *, TSTGridIndex, TSTGridIndex, TSDStroke *, BOOL, BOOL)");
    objc_msgSend(v65, "handleFailureInFunction:file:lineNumber:description:", v66, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTStrokeRunArray.mm"), 509, @"lastStrokeRun should be non-NULL");
    double v64 = 0;
    int v63 = 1;
  }
  char v67 = *((unsigned char *)v61 + 24);
  if (((v67 & 1) == 0) != v84 && ((v67 & 2) == 0) != *(_DWORD *)v83)
  {
    CGAffineTransform v68 = (TSDStroke *)v61->var2;
    if ((v68 == a4 || [(TSDStroke *)v68 isEqualToStroke:a4]) && v61 == v64)
    {
      if (var1 > v61->var1) {
        v61->var1 = var1;
      }
      return a1;
    }
  }
  unsigned int v69 = v64->var1;
  if (var0 > v61->var0)
  {
    if (v69 > var1)
    {
      if (v42 == v53)
      {
        TSTStrokeRunArrayExpand(a1, v43, 2u);
        int v71 = *(_DWORD *)v83;
        if (a1->mCount <= v43) {
          goto LABEL_100;
        }
      }
      else
      {
        int v71 = *(_DWORD *)v83;
        if (v60 != v42)
        {
          uint64_t v70 = (v60 - v43 - 2);
          if (v60 - v43 != 2) {
            TSTStrokeRunArrayShrink(a1, v42, v70);
          }
          goto LABEL_119;
        }
        TSTStrokeRunArrayExpand(a1, v43, 1u);
        if (a1->mCount <= v43) {
          goto LABEL_100;
        }
      }
      double v74 = a1->mStrokes;
      if (v74)
      {
        CGFloat v61 = &v74[v43];
LABEL_119:
        if (v63)
        {
          long long v79 = objc_msgSend(MEMORY[0x263F7C7F0], "currentHandler", v70);
          uint64_t v80 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTStrokeRunArray *p_TSTStrokeRunArrayInsertStroke(TSTStrokeRunArray *, TSTGridIndex, TSTGridIndex, TSDStroke *, BOOL, BOOL)");
          objc_msgSend(v79, "handleFailureInFunction:file:lineNumber:description:", v80, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTStrokeRunArray.mm"), 634, @"lastStrokeRun should be non-NULL");
        }
        v61->var1 = var0;
        if (a1->mCount <= v42) {
          long long v81 = 0;
        }
        else {
          long long v81 = &a1->mStrokes[v42];
        }
        TSTStrokeRunSet(v81, var0, var1, a4, v84, v71);
        if (a1->mCount <= (v42 + 1) || (long long v82 = a1->mStrokes) == 0) {
          p_TSTStrokeRunArrayInsertStroke();
        }
        v82[(v42 + 1)].unsigned int var0 = var1;
        return a1;
      }
LABEL_100:
      float64_t v75 = objc_msgSend(MEMORY[0x263F7C7F0], "currentHandler", *(void *)v83);
      uint64_t v76 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTStrokeRunArray *p_TSTStrokeRunArrayInsertStroke(TSTStrokeRunArray *, TSTGridIndex, TSTGridIndex, TSDStroke *, BOOL, BOOL)");
      objc_msgSend(v75, "handleFailureInFunction:file:lineNumber:description:", v76, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTStrokeRunArray.mm"), 633, @"firstStrokeRun should be non-NULL");
      CGFloat v61 = 0;
      goto LABEL_119;
    }
    if (v42 == v53)
    {
      TSTStrokeRunArrayExpand(a1, v43, 1u);
      unsigned int v73 = a1->mCount;
      if (v73 <= v43) {
        CGFloat v61 = 0;
      }
      else {
        CGFloat v61 = &a1->mStrokes[v43];
      }
      if (v73 <= v42)
      {
        double v64 = 0;
LABEL_128:
        if (v61 == v64)
        {
LABEL_130:
          CGAffineTransform v40 = v61;
          char v57 = v84;
          int v54 = var0;
          int v55 = var1;
          uint64_t v56 = a4;
          int v58 = *(_DWORD *)v83;
          goto LABEL_63;
        }
LABEL_129:
        v61->var1 = var0;
        CGFloat v61 = v64;
        goto LABEL_130;
      }
    }
    else
    {
      if (v60 == v42) {
        goto LABEL_128;
      }
      TSTStrokeRunArrayShrink(a1, v42, v60 - v42);
      if (a1->mCount <= v42)
      {
        double v64 = 0;
        goto LABEL_129;
      }
    }
    double v64 = &a1->mStrokes[v42];
    goto LABEL_128;
  }
  if (v69 > var1)
  {
    if (v42 == v53)
    {
      TSTStrokeRunArrayExpand(a1, v43, 1u);
      unsigned int v72 = a1->mCount;
      if (v72 <= v43) {
        CGFloat v61 = 0;
      }
      else {
        CGFloat v61 = &a1->mStrokes[v43];
      }
    }
    else
    {
      if (v60 == v42) {
        goto LABEL_110;
      }
      TSTStrokeRunArrayShrink(a1, v42, v60 - v42);
      unsigned int v72 = a1->mCount;
    }
    if (v72 <= v42) {
      double v64 = 0;
    }
    else {
      double v64 = &a1->mStrokes[v42];
    }
LABEL_110:
    TSTStrokeRunSet(v61, var0, var1, a4, v84, *(int *)v83);
    if (v64 != v61)
    {
      if (!v64)
      {
        long long v77 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
        uint64_t v78 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTStrokeRunArray *p_TSTStrokeRunArrayInsertStroke(TSTStrokeRunArray *, TSTGridIndex, TSTGridIndex, TSDStroke *, BOOL, BOOL)");
        objc_msgSend(v77, "handleFailureInFunction:file:lineNumber:description:", v78, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTStrokeRunArray.mm"), 564, @"lastStrokeRun should be non-NULL");
      }
      v64->unsigned int var0 = var1;
    }
    return a1;
  }
  TSTStrokeRunSet(v61, var0, var1, a4, v84, *(int *)v83);
  if (v53 != v42) {
    TSTStrokeRunArrayShrink(a1, v42, v60 - v43);
  }
  return a1;
}

uint64_t p_updateStrokeRunArrayMetadata(uint64_t result)
{
  double v1 = 0.0;
  if (!result || (uint64_t v2 = *(unsigned int *)(result + 24), !v2))
  {
    LOBYTE(v5) = 0;
    goto LABEL_21;
  }
  unint64_t v3 = 0;
  unint64_t v4 = 0;
  int v5 = 0;
  uint64_t v6 = 24;
  do
  {
    if (v3 < *(unsigned int *)(result + 24))
    {
      uint64_t v7 = *(void *)(result + 40);
      if (v7)
      {
        int v8 = (double *)(v7 + v6);
        unsigned __int8 v9 = *(unsigned char *)v8;
        double v10 = *(v8 - 1);
        if (v1 <= v10) {
          double v1 = *(v8 - 1);
        }
        if (v4)
        {
          double v11 = v4[2];
          if (v11 > v10)
          {
            *((unsigned char *)v4 + 24) = (_BYTE)v4[3] & 0xCF | 0x10;
            char v12 = *(unsigned char *)v8 & 0xF3 | 8;
LABEL_16:
            unint64_t v4 = v8 - 3;
            v5 |= (v9 & 2) >> 1;
            *(unsigned char *)int v8 = v12;
            goto LABEL_17;
          }
          char v13 = *((unsigned char *)v4 + 24);
          if (v11 == v10)
          {
            *((unsigned char *)v4 + 24) = v13 | 0x30;
            char v12 = *(unsigned char *)v8 | 0xC;
            goto LABEL_16;
          }
          *((unsigned char *)v4 + 24) = v13 & 0xCF | 0x20;
          LOBYTE(v4) = *(unsigned char *)v8 & 0xF7;
        }
        else
        {
          unint64_t v4 = (double *)(v9 & 0xF7);
        }
        char v12 = v4 | 4;
        goto LABEL_16;
      }
    }
LABEL_17:
    ++v3;
    v6 += 32;
  }
  while (v2 != v3);
  if (v4) {
    *((unsigned char *)v4 + 24) = (_BYTE)v4[3] & 0xCF | 0x10;
  }
LABEL_21:
  *(unsigned char *)(result + 8) = v5 & 1;
  *(double *)(result + 16) = v1;
  return result;
}

TSTStrokeRunArray *TSTStrokeRunArrayInsertCustomStroke(TSTStrokeRunArray *a1, unsigned int a2, unsigned int a3, TSDStroke *a4)
{
  insertedouble d = p_TSTStrokeRunArrayInsertStroke(a1, a2, a3, a4, 0, 1);
  inserted->mHasCustomStrokes = 1;
  p_updateStrokeRunArrayMetadata((uint64_t)inserted);
  return a1;
}

unsigned int *TSTStrokeRunArrayGetStrokeAtIndex(unsigned int *a1, unsigned int a2)
{
  __n128 result = TSTStrokeRunArrayLookupStroke(a1, a2);
  if (result) {
    return (unsigned int *)*((void *)result + 1);
  }
  return result;
}

uint64_t TSTStrokeRunArraySetValid(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (!result) {
    return result;
  }
  int v5 = (TSTStrokeRunArray *)result;
  unsigned int v13 = 0;
  NextStroke = TSTStrokeRunArrayGetNextStroke(result, a2, a3, &v13);
  if (!NextStroke) {
    return p_updateStrokeRunArrayMetadata((uint64_t)v5);
  }
  while (1)
  {
    unsigned int v7 = *((unsigned __int8 *)NextStroke + 24);
    if (v7) {
      goto LABEL_12;
    }
    unsigned int v8 = NextStroke[1];
    unsigned int v9 = *NextStroke <= a2 ? a2 : *NextStroke;
    double v10 = (TSDStroke *)*((void *)NextStroke + 1);
    int v11 = (v7 >> 1) & 1;
    if (v8 > a3) {
      break;
    }
    p_TSTStrokeRunArrayInsertStroke(v5, v9, v8, v10, 1, v11);
    if (v8 != -1)
    {
      if (v8 >= a3) {
        return p_updateStrokeRunArrayMetadata((uint64_t)v5);
      }
      unsigned int v13 = 0;
      NextStroke = TSTStrokeRunArrayGetNextStroke((uint64_t)v5, v8, a3, &v13);
      if (!NextStroke) {
        return p_updateStrokeRunArrayMetadata((uint64_t)v5);
      }
      goto LABEL_14;
    }
LABEL_12:
    unsigned int v12 = v13;
    if (v13 >= v5->mCount) {
      return p_updateStrokeRunArrayMetadata((uint64_t)v5);
    }
    NextStroke = &v5->mStrokes[v13].var0;
    v5->mLastLookup = v13;
    unsigned int v13 = v12 + 1;
    if (!NextStroke) {
      return p_updateStrokeRunArrayMetadata((uint64_t)v5);
    }
LABEL_14:
    if (*NextStroke >= a3) {
      return p_updateStrokeRunArrayMetadata((uint64_t)v5);
    }
  }
  p_TSTStrokeRunArrayInsertStroke(v5, v9, a3, v10, 1, v11);
  return p_updateStrokeRunArrayMetadata((uint64_t)v5);
}

uint64_t TSTStrokeRunArraySetEntireCustom(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(unsigned int *)(result + 24);
    if (v1)
    {
      unint64_t v2 = 0;
      uint64_t v3 = 24;
      do
      {
        if (v2 < *(unsigned int *)(result + 24))
        {
          uint64_t v4 = *(void *)(result + 40);
          if (v4) {
            *(unsigned char *)(v4 + v3) |= 2u;
          }
        }
        ++v2;
        v3 += 32;
      }
      while (v1 != v2);
    }
  }
  *(unsigned char *)(result + 8) = 1;
  return result;
}

uint64_t TSTStrokeRunArrayResetRange(TSTStrokeRunArray *a1, unsigned int *a2, unsigned int a3, unsigned int a4)
{
  if (!a1 || (mCFIndex Count = a1->mCount) == 0 || (mStrokes = a1->mStrokes) == 0) {
    TSTStrokeRunArrayResetRange_cold_1();
  }
  unsigned int var1 = mStrokes[mCount - 1].var1;
  if (var1 >= a3) {
    unsigned int v10 = a3;
  }
  else {
    unsigned int v10 = var1;
  }
  do
  {
    while (1)
    {
      int v11 = TSTStrokeRunArrayLookupStroke((unsigned int *)a1, v10);
      unsigned int v12 = TSTStrokeRunArrayLookupStroke(a2, v10);
      unsigned int v13 = v12;
      if (!v11) {
        break;
      }
      unsigned int v14 = v11[1];
      if (v14 >= v12[1]) {
        unsigned int v14 = v12[1];
      }
      if (v14 >= a4) {
        unsigned int v15 = a4;
      }
      else {
        unsigned int v15 = v14;
      }
      if (v10 >= v15)
      {
        unsigned int v13 = 0;
        goto LABEL_25;
      }
      BOOL v16 = (TSDStroke *)*((void *)v12 + 1);
      if ((v12[6] & 2) != 0)
      {
        insertedouble d = p_TSTStrokeRunArrayInsertStroke(a1, v10, v15, v16, 0, 1);
        a1->mHasCustomStrokes = 1;
        p_updateStrokeRunArrayMetadata((uint64_t)inserted);
        a1->mHasCustomStrokes = 1;
      }
      else
      {
        unsigned int v17 = p_TSTStrokeRunArrayInsertStroke(a1, v10, v15, v16, 0, 0);
        p_updateStrokeRunArrayMetadata((uint64_t)v17);
      }
      unsigned int v10 = v15;
    }
    if (v12)
    {
      unsigned int v18 = v12[1];
      unint64_t v19 = (TSDStroke *)*((void *)v12 + 1);
      if ((v12[6] & 2) != 0)
      {
        uint64_t v22 = p_TSTStrokeRunArrayInsertStroke(a1, v10, v18, v19, 0, 1);
        a1->mHasCustomStrokes = 1;
        p_updateStrokeRunArrayMetadata((uint64_t)v22);
        a1->mHasCustomStrokes = 1;
      }
      else
      {
        CGAffineTransform v20 = p_TSTStrokeRunArrayInsertStroke(a1, v10, v18, v19, 0, 0);
        p_updateStrokeRunArrayMetadata((uint64_t)v20);
      }
      unsigned int v10 = v13[1];
    }
LABEL_25:
    ;
  }
  while (v13);

  return p_updateStrokeRunArrayMetadata((uint64_t)a1);
}

uint64_t TSTStrokeRunArrayTruncate(uint64_t a1, unsigned int a2)
{
  unsigned int v12 = 0;
  NextStroke = TSTStrokeRunArrayGetNextStroke(a1, a2 - 1, a2, &v12);
  int v5 = 0;
  if (NextStroke)
  {
    unsigned int v6 = v12;
    do
    {
      unsigned int v7 = NextStroke[1];
      if (v7 != a2)
      {
        if (v7 <= a2 || *NextStroke >= a2)
        {
          TSTStrokeRunSet(NextStroke, 0, 0, 0, 0, 0);
          ++v5;
        }
        else
        {
          NextStroke[1] = a2;
        }
      }
      unsigned int v9 = *(_DWORD *)(a1 + 24);
      if (v9 <= v6) {
        break;
      }
      uint64_t v10 = *(void *)(a1 + 40);
      NextStroke = (unsigned int *)(v10 + 32 * v6++);
    }
    while (v10);
  }
  else
  {
    unsigned int v9 = *(_DWORD *)(a1 + 24);
  }
  *(_DWORD *)(a1 + 24) = v9 - v5;

  return p_updateStrokeRunArrayMetadata(a1);
}

TSTStrokeRunArray *TSTStrokeRunArrayMergeHorizontalStrokes(TSTStrokeRunArray *a1, TSTStrokeRunArray *a2)
{
  return p_TSTStrokeRunArrayMergeStrokes(a2, a1);
}

TSTStrokeRunArray *p_TSTStrokeRunArrayMergeStrokes(TSTStrokeRunArray *a1, TSTStrokeRunArray *a2)
{
  if (!a1) {
    goto LABEL_11;
  }
  if (!a2)
  {
LABEL_12:
    uint64_t v4 = TSTStrokeRunArrayCopy((uint64_t)a1);
    pthread_rwlock_wrlock(&v4->mRWLock);
    return v4;
  }
  if (!a1->mHasCustomStrokes)
  {
LABEL_11:
    a1 = a2;
    goto LABEL_12;
  }
  BOOL mHasCustomStrokes = a2->mHasCustomStrokes;
  uint64_t v4 = TSTStrokeRunArrayCopy((uint64_t)a1);
  pthread_rwlock_wrlock(&v4->mRWLock);
  if (mHasCustomStrokes)
  {
    mCFIndex Count = a2->mCount;
    if (mCount)
    {
      uint64_t v6 = 0;
      for (unint64_t i = 0; i < mCount; ++i)
      {
        unsigned int v8 = &a2->mStrokes[v6];
        if ((*((unsigned char *)v8 + 24) & 2) != 0)
        {
          p_TSTStrokeRunArrayInsertStroke(v4, v8->var0, v8->var1, (TSDStroke *)v8->var2, *((unsigned char *)v8 + 24) & 1, 1);
          mCFIndex Count = a2->mCount;
        }
        ++v6;
      }
    }
    p_updateStrokeRunArrayMetadata((uint64_t)v4);
  }
  return v4;
}

TSTStrokeRunArray *TSTStrokeRunArrayMergeVerticalStrokes(TSTStrokeRunArray *a1, TSTStrokeRunArray *a2)
{
  return p_TSTStrokeRunArrayMergeStrokes(a2, a1);
}

double TSTStrokeRunArrayMaxWidthForMergedHorizontalStrokes(TSTStrokeRunArray *a1, TSTStrokeRunArray *a2, unsigned int a3, unsigned int a4)
{
  return p_TSTStrokeRunArrayMaxWidthForMergedStrokes(a2, a1, a3, a4);
}

double p_TSTStrokeRunArrayMaxWidthForMergedStrokes(TSTStrokeRunArray *a1, TSTStrokeRunArray *a2, unsigned int a3, unsigned int a4)
{
  if (!a2)
  {
    double v8 = 0.0;
    if (!a1) {
      goto LABEL_10;
    }
    mMaxsize_t Width = a1->mMaxWidth;
    if (mMaxWidth < 0.0) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  double v8 = a2->mMaxWidth;
  if (!a1)
  {
    if (v8 <= 0.0) {
      double v8 = 0.0;
    }
    goto LABEL_10;
  }
  mMaxsize_t Width = a1->mMaxWidth;
  if (v8 <= mMaxWidth) {
LABEL_7:
  }
    double v8 = mMaxWidth;
LABEL_10:
  NextStroke = 0;
  int v11 = 0;
  uint64_t v21 = 0;
  LOBYTE(v12) = 1;
  double v13 = 0.0;
  LOBYTE(v14) = 1;
  do
  {
    if (v12)
    {
      NextStroke = TSTStrokeRunArrayGetNextStroke((uint64_t)a2, a3, a4, (_DWORD *)&v21 + 1);
      if (!v14)
      {
LABEL_13:
        if (!NextStroke) {
          goto LABEL_28;
        }
        goto LABEL_17;
      }
    }
    else if (!v14)
    {
      goto LABEL_13;
    }
    int v11 = TSTStrokeRunArrayGetNextStroke((uint64_t)a1, a3, a4, &v21);
    if (!NextStroke) {
      goto LABEL_28;
    }
LABEL_17:
    if (v11)
    {
      unsigned int v15 = NextStroke[1];
      unsigned int v16 = v11[1];
      if (v15 >= v16) {
        unsigned int v17 = v11[1];
      }
      else {
        unsigned int v17 = NextStroke[1];
      }
      unsigned int v18 = NextStroke;
      if ((v11[6] & 2) != 0)
      {
        if ((NextStroke[6] & 2) != 0) {
          unsigned int v18 = NextStroke;
        }
        else {
          unsigned int v18 = v11;
        }
      }
      if (v13 <= *((double *)v18 + 2)) {
        double v13 = *((double *)v18 + 2);
      }
      BOOL v12 = v15 <= v16;
      goto LABEL_37;
    }
LABEL_28:
    if (NextStroke)
    {
      unsigned int v17 = NextStroke[1];
      if (v13 <= *((double *)NextStroke + 2)) {
        double v13 = *((double *)NextStroke + 2);
      }
      if (!v11)
      {
        BOOL v14 = 0;
        BOOL v12 = 1;
        goto LABEL_38;
      }
      unsigned int v16 = v11[1];
      BOOL v12 = 1;
    }
    else
    {
      if (!v11) {
        return v13;
      }
      BOOL v12 = 0;
      unsigned int v16 = v11[1];
      if (v13 <= *((double *)v11 + 2)) {
        double v13 = *((double *)v11 + 2);
      }
      unsigned int v17 = v11[1];
    }
LABEL_37:
    BOOL v14 = v16 == v17;
LABEL_38:
    if (!v12 && !v14) {
      break;
    }
  }
  while (v13 < v8 && v17 < a4);
  return v13;
}

double TSTStrokeRunArrayMaxWidthForMergedVerticalStrokes(TSTStrokeRunArray *a1, TSTStrokeRunArray *a2, unsigned int a3, unsigned int a4)
{
  return p_TSTStrokeRunArrayMaxWidthForMergedStrokes(a2, a1, a3, a4);
}

uint64_t TSTStrokeRunArrayWriteLock(uint64_t a1)
{
  return pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 48));
}

uint64_t TSTStrokeRunArrayReadLock(uint64_t a1)
{
  return pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 48));
}

uint64_t TSTStrokeRunArrayUnlock(uint64_t a1)
{
  return pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 48));
}

id TSTStrokeRunArrayExpand(TSTStrokeRunArray *a1, unsigned int a2, unsigned int a3)
{
  mCFIndex Count = a1->mCount;
  unsigned int v7 = mCount + a3;
  if (mCount + a3 > a1->mAllocCount)
  {
    a1->mAllocCFIndex Count = v7;
    a1->mStrokes = (TSTStrokeRun *)malloc_type_realloc(a1->mStrokes, 32 * (mCount + a3), 0x1080040D89E363BuLL);
    mCFIndex Count = a1->mCount;
  }
  BOOL v8 = mCount >= a2;
  unsigned int v9 = mCount - a2;
  if (v9 != 0 && v8)
  {
    memmove(&a1->mStrokes[a3 + a2], &a1->mStrokes[a2], 32 * v9);
    if (a3 >= 2)
    {
      uint64_t v10 = &a1->mStrokes[a2 + 1];
      *(_OWORD *)&v10->unsigned int var0 = 0u;
      *(_OWORD *)&v10->var3 = 0u;
    }
  }
  a1->mCFIndex Count = v7;
  if (v7 > a2 && (mStrokes = a1->mStrokes) != 0)
  {
    id var2 = mStrokes[a2].var2;
    return var2;
  }
  else
  {
    BOOL v14 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v15 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTStrokeRunArrayExpand(TSTStrokeRunArray *, unsigned int, unsigned int)");
    uint64_t v16 = [NSString stringWithUTF8String:"/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTStrokeRunArray.mm"];
    return (id)[v14 handleFailureInFunction:v15 file:v16 lineNumber:334 description:@"NULL strokeRun"];
  }
}

uint64_t TSTStrokeRunArrayShrink(TSTStrokeRunArray *a1, unsigned int a2, unsigned int a3)
{
  if (a3)
  {
    uint64_t v6 = a3;
    unsigned int v7 = a2;
    do
    {
      if (a1->mCount <= v7) {
        BOOL v8 = 0;
      }
      else {
        BOOL v8 = &a1->mStrokes[v7];
      }
      TSTStrokeRunSet(v8, 0, 0, 0, 0, 0);
      ++v7;
      --v6;
    }
    while (v6);
  }
  unsigned int v9 = a1->mCount - a3;
  a1->mCFIndex Count = v9;
  BOOL v10 = v9 >= a2;
  unsigned int v11 = v9 - a2;
  if (v11 != 0 && v10) {
    memmove(&a1->mStrokes[a2], &a1->mStrokes[a3 + a2], 32 * v11);
  }

  return p_updateStrokeRunArrayMetadata((uint64_t)a1);
}

void p_TSTStrokeRunArrayInsertStroke()
{
  CFLocaleRef v0 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
  uint64_t v1 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTStrokeRunArray *p_TSTStrokeRunArrayInsertStroke(TSTStrokeRunArray *, TSTGridIndex, TSTGridIndex, TSDStroke *, BOOL, BOOL)");
  objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", v1, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTStrokeRunArray.mm"), 647, @"lastStrokeRun should be non-NULL");
  __break(1u);
}

void TSTStrokeRunArrayResetRange_cold_1()
{
  CFLocaleRef v0 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
  uint64_t v1 = objc_msgSend(NSString, "stringWithUTF8String:", "void TSTStrokeRunArrayResetRange(TSTStrokeRunArray *, TSTStrokeRunArray *, TSTGridIndex, TSTGridIndex)");
  objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", v1, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTStrokeRunArray.mm"), 798, @"invalid nil value for '%s'", "strokeRun");
  __break(1u);
}

void sub_2237F1B44(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2237F1C54(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2237F1D58(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t **std::__hash_table<std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>,std::__unordered_map_hasher<TSUColumnRowCoordinate,std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>,TSTCellIDHasher,std::equal_to<TSUColumnRowCoordinate>,true>,std::__unordered_map_equal<TSUColumnRowCoordinate,std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>,std::equal_to<TSUColumnRowCoordinate>,TSTCellIDHasher,true>,std::allocator<std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>>>::find<TSUColumnRowCoordinate>(void *a1, int *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  int v3 = *a2;
  unint64_t v4 = BYTE2(*a2) | ((unint64_t)(unsigned __int16)*a2 << 8);
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v2);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    unint64_t v6 = BYTE2(v3) | ((unint64_t)(unsigned __int16)*a2 << 8);
    if (v4 >= *(void *)&v2) {
      unint64_t v6 = v4 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v6 = v4 & (*(void *)&v2 + 0xFFFFFFLL);
  }
  unsigned int v7 = *(uint64_t ****)(*a1 + 8 * v6);
  if (!v7) {
    return 0;
  }
  __n128 result = *v7;
  if (*v7)
  {
    int v9 = BYTE2(v3);
    do
    {
      unint64_t v10 = (unint64_t)result[1];
      if (v10 == v4)
      {
        if (*((unsigned __int16 *)result + 8) == (unsigned __int16)*a2 && *((unsigned __int8 *)result + 18) == v9) {
          return result;
        }
      }
      else
      {
        if (v5.u32[0] > 1uLL)
        {
          if (v10 >= *(void *)&v2) {
            v10 %= *(void *)&v2;
          }
        }
        else
        {
          v10 &= *(void *)&v2 - 1;
        }
        if (v10 != v6) {
          return 0;
        }
      }
      __n128 result = (uint64_t **)*result;
    }
    while (result);
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>,std::__unordered_map_hasher<TSUColumnRowCoordinate,std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>,TSTCellIDHasher,std::equal_to<TSUColumnRowCoordinate>,true>,std::__unordered_map_equal<TSUColumnRowCoordinate,std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>,std::equal_to<TSUColumnRowCoordinate>,TSTCellIDHasher,true>,std::allocator<std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>>>::__emplace_unique_key_args<TSUColumnRowCoordinate,std::piecewise_construct_t const&,std::tuple<TSUColumnRowCoordinate const&>,std::tuple<>>(uint64_t a1, _DWORD *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = BYTE2(*a2) | ((unint64_t)(unsigned __int16)*a2 << 8);
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = BYTE2(*a2) | ((unint64_t)(unsigned __int16)*a2 << 8);
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = v7 & (v8 + 0xFFFFFF);
    }
    unint64_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      unsigned int v11 = *v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v7)
          {
            if (*((unsigned __int16 *)v11 + 8) == (unsigned __int16)*a2
              && *((unsigned __int8 *)v11 + 18) == BYTE2(*a2))
            {
              return v11;
            }
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4) {
              break;
            }
          }
          unsigned int v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
  unsigned int v11 = operator new(0x18uLL);
  *unsigned int v11 = 0;
  v11[1] = v7;
  *((_DWORD *)v11 + 4) = **a4;
  *((_DWORD *)v11 + 5) = 0;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    BOOL v16 = 1;
    if (v8 >= 3) {
      BOOL v16 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v8);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    std::__hash_table<std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::__unordered_map_hasher<EQKit::StemStretch::Key,std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::hash<EQKit::StemStretch::Key>,std::equal_to<EQKit::StemStretch::Key>,true>,std::__unordered_map_equal<EQKit::StemStretch::Key,std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::equal_to<EQKit::StemStretch::Key>,std::hash<EQKit::StemStretch::Key>,true>,std::allocator<std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>>>::__rehash<true>(a1, v19);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v20 = *(void *)a1;
  uint64_t v21 = *(void **)(*(void *)a1 + 8 * v4);
  if (v21)
  {
    *unsigned int v11 = *v21;
LABEL_42:
    *uint64_t v21 = v11;
    goto LABEL_43;
  }
  *unsigned int v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v11;
  *(void *)(v20 + 8 * v4) = a1 + 16;
  if (*v11)
  {
    unint64_t v22 = *(void *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v22 >= v8) {
        v22 %= v8;
      }
    }
    else
    {
      v22 &= v8 - 1;
    }
    uint64_t v21 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_42;
  }
LABEL_43:
  ++*(void *)(a1 + 24);
  return v11;
}

void sub_2237F5CF8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>,std::__unordered_map_hasher<TSUColumnRowCoordinate,std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>,TSTCellIDHasher,std::equal_to<TSUColumnRowCoordinate>,true>,std::__unordered_map_equal<TSUColumnRowCoordinate,std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>,std::equal_to<TSUColumnRowCoordinate>,TSTCellIDHasher,true>,std::allocator<std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>>>::__erase_unique<TSUColumnRowCoordinate>(void *a1, int *a2)
{
  __n128 result = (uint64_t *)std::__hash_table<std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>,std::__unordered_map_hasher<TSUColumnRowCoordinate,std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>,TSTCellIDHasher,std::equal_to<TSUColumnRowCoordinate>,true>,std::__unordered_map_equal<TSUColumnRowCoordinate,std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>,std::equal_to<TSUColumnRowCoordinate>,TSTCellIDHasher,true>,std::allocator<std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>>>::find<TSUColumnRowCoordinate>(a1, a2);
  if (result)
  {
    std::__hash_table<std::__hash_value_type<unsigned int,std::pair<EQKit::Font::STIXCollection::StretchInfo,unsigned long>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::pair<EQKit::Font::STIXCollection::StretchInfo,unsigned long>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::pair<EQKit::Font::STIXCollection::StretchInfo,unsigned long>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::pair<EQKit::Font::STIXCollection::StretchInfo,unsigned long>>>>::erase(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

void sub_2237F5E80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__31(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__31(uint64_t a1)
{
}

uint64_t TSTCoordinateArraySetIndexHidden(uint64_t a1, unsigned int a2)
{
  return [*(id *)(a1 + 32) removeIndex:a2];
}

BOOL TSTCoordinateArrayContainsIndex(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  BOOL v3 = a2 >= v2;
  unsigned int v4 = a2 - v2;
  return v3 && v4 < *(_DWORD *)(a1 + 12);
}

double TSTCoordinateArraySetCoordinate(uint64_t a1, unsigned int a2, double result)
{
  unsigned int v3 = *(_DWORD *)(a1 + 8);
  BOOL v4 = a2 >= v3;
  unsigned int v5 = a2 - v3;
  if (v4)
  {
    unsigned int v6 = *(_DWORD *)(a1 + 12);
    if (v5 < v6)
    {
      unint64_t v7 = *(double **)(a1 + 16);
      v7[v5] = result;
      if (v5 == v6 - 1)
      {
        v7[v5 + 1] = result;
        __n128 result = (result - *v7) / (double)v5;
        *(double *)(a1 + 24) = result;
      }
    }
  }
  return result;
}

double TSTCoordinateArrayGetCoordinate(uint64_t a1, unsigned int a2)
{
  if (a1)
  {
    unsigned int v2 = *(_DWORD *)(a1 + 8);
    double result = 0.0;
    BOOL v4 = a2 >= v2;
    unsigned int v5 = a2 - v2;
    if (v4 && v5 < *(_DWORD *)(a1 + 12))
    {
      if (*(unsigned char *)(a1 + 40)) {
        return *(double *)(*(void *)(a1 + 16) + 8 * v5);
      }
      else {
        return *(double *)(a1 + 48) - *(double *)(*(void *)(a1 + 16) + 8 * v5);
      }
    }
  }
  else
  {
    unsigned int v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "CGFloat TSTCoordinateArrayGetCoordinate(TSTCoordinateArray *, TSTGridIndex)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCoordinateArray.mm"), 120, @"invalid nil value for '%s'", "coordinateArray");
    return 0.0;
  }
  return result;
}

double TSTCoordinateArrayGetRawCoordinate(uint64_t a1, unsigned int a2)
{
  if (a1)
  {
    unsigned int v2 = *(_DWORD *)(a1 + 8);
    double result = 0.0;
    BOOL v4 = a2 >= v2;
    unsigned int v5 = a2 - v2;
    if (v4 && v5 < *(_DWORD *)(a1 + 12)) {
      return *(double *)(*(void *)(a1 + 16) + 8 * v5);
    }
  }
  else
  {
    unsigned int v6 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", "CGFloat TSTCoordinateArrayGetRawCoordinate(TSTCoordinateArray *, TSTGridIndex)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCoordinateArray.mm"), 144, @"invalid nil value for '%s'", "coordinateArray");
    return 0.0;
  }
  return result;
}

uint64_t TSTCoordinateArrayLookup(TSTCoordinateArray *a1, double a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  double v2 = a2;
  if (!a1->mLayoutDirectionIsLeftToRight) {
    double v2 = a1->mTableWidth - a2;
  }
  mCoordinates = a1->mCoordinates;
  if (v2 <= *mCoordinates) {
    return a1->mOffset;
  }
  if (v2 > mCoordinates[a1->mCount - 1] + 0.00999999978) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v7 = ((v2 - *mCoordinates) / a1->mAverage);
  double v8 = mCoordinates[v7];
  if (v2 >= v8) {
    unsigned int v9 = ((v2 - *mCoordinates) / a1->mAverage);
  }
  else {
    unsigned int v9 = 0;
  }
  if (v2 >= v8) {
    unsigned int v10 = a1->mCount - 1;
  }
  else {
    unsigned int v10 = ((v2 - *mCoordinates) / a1->mAverage);
  }
  if (v2 < v8 || v2 > mCoordinates[v7 + 1] + 0.00999999978) {
    goto LABEL_20;
  }
  char v11 = [(NSMutableIndexSet *)a1->mVisibleIndices containsIndex:a1->mOffset + v7];
  uint64_t v5 = a1->mOffset + v7;
  if ((v11 & 1) == 0) {
    uint64_t v5 = TSTCoordinateArrayVisibleGridIndexForHiddenGridIndex(a1, v5);
  }
  if (v5 == -1)
  {
LABEL_20:
    uint64_t v5 = 0xFFFFFFFFLL;
    while (v9 <= v10)
    {
      unsigned int v12 = (v10 + v9) >> 1;
      if (v2 >= mCoordinates[v12])
      {
        unsigned int v9 = v12 + 1;
        if (v2 <= mCoordinates[v12 + 1] + 0.00999999978) {
          uint64_t v5 = a1->mOffset + v12;
        }
      }
      else
      {
        unsigned int v10 = v12 - 1;
      }
    }
    if (([(NSMutableIndexSet *)a1->mVisibleIndices containsIndex:v5] & 1) == 0) {
      uint64_t v5 = TSTCoordinateArrayVisibleGridIndexForHiddenGridIndex(a1, v5);
    }
  }
  if (a1->mLayoutDirectionIsLeftToRight && v5 == a1->mCount + a1->mOffset - 1) {
    return [(NSMutableIndexSet *)a1->mVisibleIndices indexLessThanIndex:v5];
  }
  return v5;
}

uint64_t TSTCoordinateArrayVisibleGridIndexForHiddenGridIndex(TSTCoordinateArray *a1, unsigned int a2)
{
  double Coordinate = TSTCoordinateArrayGetCoordinate((uint64_t)a1, a2);
  mVisibleIndices = a1->mVisibleIndices;
  if (Coordinate <= 0.0) {
    return [(NSMutableIndexSet *)mVisibleIndices indexGreaterThanIndex:a2];
  }
  else {
    return [(NSMutableIndexSet *)mVisibleIndices indexLessThanIndex:a2];
  }
}

void sub_2237F6E44(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2237F7020(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t p_setStrokeColors(TSSPropertyMap *a1, uint64_t a2, NSArray *a3)
{
  if (a3)
  {
    uint64_t v5 = (int *)((char *)&s_TableStyleStrokeColors + 16 * a2);
    id v6 = [(NSArray *)a3 objectAtIndex:*v5];
    id v7 = [(NSArray *)a3 objectAtIndex:v5[1]];
    id v8 = [(NSArray *)a3 objectAtIndex:v5[2]];
    id v9 = [(NSArray *)a3 objectAtIndex:v5[3]];
  }
  else
  {
    id v6 = (id)[MEMORY[0x263F7C808] colorWithRed:0.838999987 green:0.838999987 blue:0.838999987 alpha:1.0];
    id v7 = v6;
    id v9 = v6;
    id v8 = v6;
  }
  [(TSSPropertyMap *)a1 setObject:+[TSDStroke strokeWithColor:v6 width:1.0] forProperty:771];
  [(TSSPropertyMap *)a1 setObject:+[TSDStroke strokeWithColor:v6 width:1.0] forProperty:772];
  [(TSSPropertyMap *)a1 setObject:+[TSDStroke strokeWithColor:v6 width:1.0] forProperty:773];
  [(TSSPropertyMap *)a1 setObject:+[TSDStroke strokeWithColor:v6 width:1.0] forProperty:774];
  [(TSSPropertyMap *)a1 setObject:+[TSDStroke strokeWithColor:v7 width:1.0] forProperty:778];
  [(TSSPropertyMap *)a1 setObject:+[TSDStroke strokeWithColor:v7 width:1.0] forProperty:782];
  [(TSSPropertyMap *)a1 setObject:+[TSDStroke strokeWithColor:v7 width:1.0] forProperty:781];
  [(TSSPropertyMap *)a1 setObject:+[TSDStroke strokeWithColor:v7 width:1.0] forProperty:780];
  [(TSSPropertyMap *)a1 setObject:+[TSDStroke strokeWithColor:v7 width:1.0] forProperty:776];
  [(TSSPropertyMap *)a1 setObject:+[TSDStroke strokeWithColor:v7 width:1.0] forProperty:777];
  [(TSSPropertyMap *)a1 setObject:+[TSDStroke strokeWithColor:v9 width:1.0] forProperty:786];
  [(TSSPropertyMap *)a1 setObject:+[TSDStroke strokeWithColor:v9 width:1.0] forProperty:785];
  [(TSSPropertyMap *)a1 setObject:+[TSDStroke strokeWithColor:v9 width:1.0] forProperty:784];
  [(TSSPropertyMap *)a1 setObject:+[TSDStroke strokeWithColor:v8 width:1.0] forProperty:779];
  [(TSSPropertyMap *)a1 setObject:+[TSDStroke strokeWithColor:v8 width:1.0] forProperty:775];
  [(TSSPropertyMap *)a1 setObject:+[TSDStroke strokeWithColor:v8 width:1.0] forProperty:783];
  [(TSSPropertyMap *)a1 setIntValue:1 forProperty:788];
  [(TSSPropertyMap *)a1 setIntValue:1 forProperty:789];
  [(TSSPropertyMap *)a1 setIntValue:1 forProperty:790];
  [(TSSPropertyMap *)a1 setIntValue:1 forProperty:792];
  [(TSSPropertyMap *)a1 setIntValue:1 forProperty:796];
  [(TSSPropertyMap *)a1 setIntValue:1 forProperty:794];
  [(TSSPropertyMap *)a1 setIntValue:1 forProperty:793];
  [(TSSPropertyMap *)a1 setIntValue:1 forProperty:791];

  return [(TSSPropertyMap *)a1 setIntValue:1 forProperty:795];
}

void sub_2237F8398(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_2237F8484(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_2237F88B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

uint64_t std::__tree<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>>>::__erase_unique<unsigned int>(uint64_t a1, unsigned int *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  unsigned int v3 = *a2;
  uint64_t v4 = a1 + 8;
  do
  {
    unsigned int v5 = *(_DWORD *)(v2 + 32);
    BOOL v6 = v5 >= v3;
    if (v5 >= v3) {
      id v7 = (uint64_t *)v2;
    }
    else {
      id v7 = (uint64_t *)(v2 + 8);
    }
    if (v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 8 || v3 < *(_DWORD *)(v4 + 32)) {
    return 0;
  }
  std::__tree<std::__value_type<EQKit::ILayoutOffset::Kind,EQKit::ILayoutOffset>,std::__map_value_compare<EQKit::ILayoutOffset::Kind,std::__value_type<EQKit::ILayoutOffset::Kind,EQKit::ILayoutOffset>,std::less<EQKit::ILayoutOffset::Kind>,true>,std::allocator<std::__value_type<EQKit::ILayoutOffset::Kind,EQKit::ILayoutOffset>>>::erase((uint64_t **)a1, v4);
  return 1;
}

void *TSTTableStrokeDefaultsCreate(void *a1, unsigned int a2, unsigned int a3, int a4, int a5, int a6)
{
  unsigned int v12 = malloc_type_calloc(0xC0uLL, 1uLL, 0x44CB0A38uLL);
  double v13 = v12;
  if (a5 + a6 + 1 > a3) {
    int v14 = a5 + a6 + 1;
  }
  else {
    int v14 = a3;
  }
  if (a4 + 1 > a2) {
    unsigned int v15 = a4 + 1;
  }
  else {
    unsigned int v15 = a2;
  }
  void *v12 = a1;
  unsigned int v36 = v15;
  int v37 = a5;
  if (!v15)
  {
    unint64_t v23 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v24 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTTableStrokeDefaults *TSTTableStrokeDefaultsCreate(TSTTableModel *, TSTGridColumnCount, TSTGridRowCount, TSTGridColumnCount, TSTGridRowCount, TSTGridRowCount)");
    objc_msgSend(v23, "handleFailureInFunction:file:lineNumber:description:", v24, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableStrokeDefaults.mm"), 77, @"numberOfColumns is zero");
    if (v14) {
      goto LABEL_9;
    }
LABEL_11:
    uint64_t v25 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
    uint64_t v26 = objc_msgSend(NSString, "stringWithUTF8String:", "TSTTableStrokeDefaults *TSTTableStrokeDefaultsCreate(TSTTableModel *, TSTGridColumnCount, TSTGridRowCount, TSTGridColumnCount, TSTGridRowCount, TSTGridRowCount)");
    objc_msgSend(v25, "handleFailureInFunction:file:lineNumber:description:", v26, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableStrokeDefaults.mm"), 78, @"numberOfRows is zero");
    goto LABEL_9;
  }
  if (!v14) {
    goto LABEL_11;
  }
LABEL_9:
  DefaultBorderStroke = (void *)TSTTableGetDefaultBorderStroke(a1);
  DefaultBodyColumnStroke = (void *)TSTTableGetDefaultBodyColumnStroke(a1);
  DefaultBodyRowStroke = (void *)TSTTableGetDefaultBodyRowStroke(a1);
  DefaultHeaderColumnBorderStroke = (void *)TSTTableGetDefaultHeaderColumnBorderStroke(a1);
  DefaultHeaderColumnBodyColumnStroke = (void *)TSTTableGetDefaultHeaderColumnBodyColumnStroke(a1);
  DefaultHeaderColumnBodyRowStroke = (void *)TSTTableGetDefaultHeaderColumnBodyRowStroke(a1);
  DefaultHeaderColumnSeparatorStroke = (void *)TSTTableGetDefaultHeaderColumnSeparatorStroke(a1);
  DefaultHeaderRowBorderStroke = (void *)TSTTableGetDefaultHeaderRowBorderStroke(a1);
  DefaultHeaderRowBodyColumnStroke = (void *)TSTTableGetDefaultHeaderRowBodyColumnStroke(a1);
  DefaultHeaderRowBodyRowStroke = (void *)TSTTableGetDefaultHeaderRowBodyRowStroke(a1);
  DefaultHeaderRowSeparatorStroke = (void *)TSTTableGetDefaultHeaderRowSeparatorStroke(a1);
  DefaultFooterRowBorderStroke = (void *)TSTTableGetDefaultFooterRowBorderStroke(a1);
  DefaultFooterRowBodyColumnStroke = (void *)TSTTableGetDefaultFooterRowBodyColumnStroke(a1);
  DefaultFooterRowBodyRowStroke = (void *)TSTTableGetDefaultFooterRowBodyRowStroke(a1);
  DefaultFooterRowSeparatorStroke = (void *)TSTTableGetDefaultFooterRowSeparatorStroke(a1);
  *((_DWORD *)v13 + 2) = v36;
  *((_DWORD *)v13 + 3) = v14;
  *((_DWORD *)v13 + 4) = a4;
  *((_DWORD *)v13 + 5) = v37;
  *((_DWORD *)v13 + 6) = a6;
  *((_DWORD *)v13 + 7) = v14 - a6;
  v13[4] = DefaultBorderStroke;
  v13[5] = DefaultBodyColumnStroke;
  v13[6] = DefaultBodyRowStroke;
  v13[7] = DefaultHeaderColumnBorderStroke;
  v13[8] = DefaultHeaderColumnBodyColumnStroke;
  v13[9] = DefaultHeaderColumnBodyRowStroke;
  v13[10] = DefaultHeaderColumnSeparatorStroke;
  v13[11] = DefaultHeaderRowBorderStroke;
  v13[12] = DefaultHeaderRowBodyColumnStroke;
  v13[13] = DefaultHeaderRowBodyRowStroke;
  v13[14] = DefaultHeaderRowSeparatorStroke;
  v13[15] = DefaultFooterRowBodyColumnStroke;
  v13[16] = DefaultFooterRowBodyRowStroke;
  v13[17] = DefaultFooterRowBorderStroke;
  v13[18] = DefaultFooterRowSeparatorStroke;
  *((_DWORD *)v13 + 40) = 60;
  v13[21] = malloc_type_calloc(8uLL, 0x3CuLL, 0x9453EB97uLL);
  v13[22] = malloc_type_calloc(8uLL, (*((_DWORD *)v13 + 2) + 1), 0x7E253C94uLL);
  *(void *)v13[22] = [MEMORY[0x263EFF9D0] null];
  *(void *)(v13[22] + 8 * *((unsigned int *)v13 + 4)) = [MEMORY[0x263EFF9D0] null];
  *(void *)(v13[22] + 8 * *((unsigned int *)v13 + 2)) = [MEMORY[0x263EFF9D0] null];
  v13[23] = malloc_type_calloc(8uLL, (*((_DWORD *)v13 + 3) + 1), 0xBA41484BuLL);
  *(void *)v13[23] = [MEMORY[0x263EFF9D0] null];
  *(void *)(v13[23] + 8 * *((unsigned int *)v13 + 5)) = [MEMORY[0x263EFF9D0] null];
  *(void *)(v13[23] + 8 * *((unsigned int *)v13 + 7)) = [MEMORY[0x263EFF9D0] null];
  *(void *)(v13[23] + 8 * *((unsigned int *)v13 + 3)) = [MEMORY[0x263EFF9D0] null];
  return v13;
}

void TSTTableStrokeDefaultsRelease(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void **)(a1 + 168);
    if (v2)
    {
      int v3 = *(_DWORD *)(a1 + 160);
      if (v3)
      {
        unsigned int v4 = v3 - 1;
        do
        {
          uint64_t v5 = v4;

          *(void *)(*(void *)(a1 + 168) + 8 * v4--) = 0;
        }
        while (v5);
        uint64_t v2 = *(void **)(a1 + 168);
      }
      free(v2);
    }

    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 40) = 0;

    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + 56) = 0;

    *(void *)(a1 + 64) = 0;
    *(void *)(a1 + 72) = 0;

    *(void *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;

    *(void *)(a1 + 96) = 0;
    *(void *)(a1 + ++*(_DWORD *)(this + 104) = 0;

    *(void *)(a1 + 112) = 0;
    *(void *)(a1 + 120) = 0;

    *(void *)(a1 + 128) = 0;
    *(void *)(a1 + 136) = 0;

    *(void *)(a1 + 144) = 0;
    if (*(void *)(a1 + 176))
    {
      unsigned int v6 = 0;
      do
      {
        uint64_t v7 = v6;
        uint64_t v8 = *(void *)(*(void *)(a1 + 176) + 8 * v6);
        if (v8 && v8 != [MEMORY[0x263EFF9D0] null])
        {

          *(void *)(*(void *)(a1 + 176) + 8 * v7) = 0;
        }
        unsigned int v6 = v7 + 1;
      }
      while ((v7 + 1) <= *(_DWORD *)(a1 + 8));
      free(*(void **)(a1 + 176));
    }
    if (*(void *)(a1 + 184))
    {
      unsigned int v9 = 0;
      do
      {
        uint64_t v10 = v9;
        uint64_t v11 = *(void *)(*(void *)(a1 + 184) + 8 * v9);
        if (v11 && v11 != [MEMORY[0x263EFF9D0] null])
        {

          *(void *)(*(void *)(a1 + 184) + 8 * v10) = 0;
        }
        unsigned int v9 = v10 + 1;
      }
      while ((v10 + 1) <= *(_DWORD *)(a1 + 12));
      free(*(void **)(a1 + 184));
    }
    free((void *)a1);
  }
}

TSTStrokeRunArray *TSTTableStrokeDefaultsForColumn(uint64_t a1, unsigned int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 8);
  if (v3 >= a2) {
    uint64_t v4 = a2;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t v5 = [MEMORY[0x263EFF9D0] null];
  uint64_t v6 = *(void *)(a1 + 176);
  if (v6)
  {
    uint64_t v7 = *(void *)(v6 + 8 * v4);
    if (!v7)
    {
      *(void *)(*(void *)(a1 + 176) + 8 * v4) = [MEMORY[0x263EFF9D0] null];
      uint64_t v29 = 0;
      TSTTableGetDefaultStrokesForColumn(*(uint64_t **)a1, v4, &v29, 0);
      uint64_t v8 = v29;
      if (v8 == (TSDStroke *)[MEMORY[0x263EFF9D0] null]) {
        TSTTableGetDefaultStrokesForColumn(*(uint64_t **)a1, (v4 - 1), 0, &v29);
      }
      unsigned int v9 = v29;
      if (v9 != (TSDStroke *)[MEMORY[0x263EFF9D0] null])
      {
        *(void *)(*(void *)(a1 + 176) + 8 * v4) = TSTStrokeRunArrayCreateWithStroke(v29, 0, *(_DWORD *)(a1 + 12));
        id v10 = *(id *)(*(void *)(a1 + 176) + 8 * v4);
      }
      uint64_t v7 = *(void *)(*(void *)(a1 + 176) + 8 * v4);
    }
  }
  else
  {
    uint64_t v7 = v5;
  }
  if (v7 == [MEMORY[0x263EFF9D0] null])
  {
    if (*(_DWORD *)(a1 + 160) == 2)
    {
      uint64_t v23 = *(void *)(a1 + 32);
      uint64_t v24 = *(unsigned int *)(a1 + 12);
      double v13 = (TSTTableStrokeDefaults *)a1;
      unsigned int v14 = 0;
LABEL_15:
      uint64_t v15 = 1;
      return TSTTableStrokeDefaultsStrokeArray(v13, v14, v15, v11, v12, 0, v23, v24, v25, v26, v27, v28);
    }
    unsigned int v17 = *(_DWORD *)(a1 + 16);
    int v16 = *(_DWORD *)(a1 + 20);
    if (v17)
    {
      if (v16)
      {
        if (v4)
        {
          if (v4 >= v17)
          {
            if (v4 == v17)
            {
              if (*(_DWORD *)(a1 + 24))
              {
                uint64_t v27 = *(void *)(a1 + 120);
                uint64_t v28 = *(unsigned int *)(a1 + 12);
                uint64_t v25 = *(void *)(a1 + 80);
                uint64_t v26 = *(unsigned int *)(a1 + 28);
                uint64_t v23 = *(void *)(a1 + 96);
                uint64_t v24 = *(unsigned int *)(a1 + 20);
                double v13 = (TSTTableStrokeDefaults *)a1;
                unsigned int v14 = 4;
                goto LABEL_65;
              }
              uint64_t v25 = *(void *)(a1 + 80);
              uint64_t v26 = *(unsigned int *)(a1 + 12);
              uint64_t v23 = *(void *)(a1 + 96);
              uint64_t v24 = *(unsigned int *)(a1 + 20);
              double v13 = (TSTTableStrokeDefaults *)a1;
              unsigned int v14 = 5;
            }
            else
            {
              int v20 = *(_DWORD *)(a1 + 24);
              if (v4 >= *(_DWORD *)(a1 + 8))
              {
                if (v20)
                {
                  uint64_t v27 = *(void *)(a1 + 136);
                  uint64_t v28 = *(unsigned int *)(a1 + 12);
                  uint64_t v25 = *(void *)(a1 + 32);
                  uint64_t v26 = *(unsigned int *)(a1 + 28);
                  uint64_t v23 = *(void *)(a1 + 88);
                  uint64_t v24 = *(unsigned int *)(a1 + 20);
                  double v13 = (TSTTableStrokeDefaults *)a1;
                  unsigned int v14 = 8;
                  goto LABEL_65;
                }
                uint64_t v25 = *(void *)(a1 + 32);
                uint64_t v26 = *(unsigned int *)(a1 + 12);
                uint64_t v23 = *(void *)(a1 + 88);
                uint64_t v24 = *(unsigned int *)(a1 + 20);
                double v13 = (TSTTableStrokeDefaults *)a1;
                unsigned int v14 = 9;
              }
              else
              {
                if (v20)
                {
                  uint64_t v27 = *(void *)(a1 + 120);
                  uint64_t v28 = *(unsigned int *)(a1 + 12);
                  uint64_t v25 = *(void *)(a1 + 40);
                  uint64_t v26 = *(unsigned int *)(a1 + 28);
                  uint64_t v23 = *(void *)(a1 + 96);
                  uint64_t v24 = *(unsigned int *)(a1 + 20);
                  double v13 = (TSTTableStrokeDefaults *)a1;
                  unsigned int v14 = 6;
                  goto LABEL_65;
                }
                uint64_t v25 = *(void *)(a1 + 40);
                uint64_t v26 = *(unsigned int *)(a1 + 12);
                uint64_t v23 = *(void *)(a1 + 96);
                uint64_t v24 = *(unsigned int *)(a1 + 20);
                double v13 = (TSTTableStrokeDefaults *)a1;
                unsigned int v14 = 7;
              }
            }
          }
          else
          {
            if (*(_DWORD *)(a1 + 24))
            {
              uint64_t v27 = *(void *)(a1 + 120);
              uint64_t v28 = *(unsigned int *)(a1 + 12);
              uint64_t v25 = *(void *)(a1 + 64);
              uint64_t v26 = *(unsigned int *)(a1 + 28);
              uint64_t v23 = *(void *)(a1 + 96);
              uint64_t v24 = *(unsigned int *)(a1 + 20);
              double v13 = (TSTTableStrokeDefaults *)a1;
              unsigned int v14 = 2;
LABEL_65:
              uint64_t v15 = 3;
              return TSTTableStrokeDefaultsStrokeArray(v13, v14, v15, v11, v12, 0, v23, v24, v25, v26, v27, v28);
            }
            uint64_t v25 = *(void *)(a1 + 64);
            uint64_t v26 = *(unsigned int *)(a1 + 12);
            uint64_t v23 = *(void *)(a1 + 96);
            uint64_t v24 = *(unsigned int *)(a1 + 20);
            double v13 = (TSTTableStrokeDefaults *)a1;
            unsigned int v14 = 3;
          }
        }
        else
        {
          if (*(_DWORD *)(a1 + 24))
          {
            uint64_t v27 = *(void *)(a1 + 136);
            uint64_t v28 = *(unsigned int *)(a1 + 12);
            uint64_t v25 = *(void *)(a1 + 56);
            uint64_t v26 = *(unsigned int *)(a1 + 28);
            uint64_t v23 = *(void *)(a1 + 88);
            uint64_t v24 = *(unsigned int *)(a1 + 20);
            double v13 = (TSTTableStrokeDefaults *)a1;
            unsigned int v14 = 0;
            goto LABEL_65;
          }
          uint64_t v25 = *(void *)(a1 + 56);
          uint64_t v26 = *(unsigned int *)(a1 + 12);
          uint64_t v23 = *(void *)(a1 + 88);
          uint64_t v24 = *(unsigned int *)(a1 + 20);
          double v13 = (TSTTableStrokeDefaults *)a1;
          unsigned int v14 = 1;
        }
      }
      else if (v4)
      {
        if (v4 >= v17)
        {
          if (v4 == v17)
          {
            if (!*(_DWORD *)(a1 + 24))
            {
              uint64_t v23 = *(void *)(a1 + 80);
              uint64_t v24 = *(unsigned int *)(a1 + 12);
              double v13 = (TSTTableStrokeDefaults *)a1;
              unsigned int v14 = 15;
              goto LABEL_15;
            }
            uint64_t v25 = *(void *)(a1 + 120);
            uint64_t v26 = *(unsigned int *)(a1 + 12);
            uint64_t v23 = *(void *)(a1 + 80);
            uint64_t v24 = *(unsigned int *)(a1 + 28);
            double v13 = (TSTTableStrokeDefaults *)a1;
            unsigned int v14 = 14;
          }
          else
          {
            int v21 = *(_DWORD *)(a1 + 24);
            if (v4 >= *(_DWORD *)(a1 + 8))
            {
              if (!v21)
              {
                uint64_t v23 = *(void *)(a1 + 32);
                uint64_t v24 = *(unsigned int *)(a1 + 12);
                double v13 = (TSTTableStrokeDefaults *)a1;
                unsigned int v14 = 19;
                goto LABEL_15;
              }
              uint64_t v25 = *(void *)(a1 + 136);
              uint64_t v26 = *(unsigned int *)(a1 + 12);
              uint64_t v23 = *(void *)(a1 + 32);
              uint64_t v24 = *(unsigned int *)(a1 + 28);
              double v13 = (TSTTableStrokeDefaults *)a1;
              unsigned int v14 = 18;
            }
            else
            {
              if (!v21)
              {
                uint64_t v23 = *(void *)(a1 + 40);
                uint64_t v24 = *(unsigned int *)(a1 + 12);
                double v13 = (TSTTableStrokeDefaults *)a1;
                unsigned int v14 = 17;
                goto LABEL_15;
              }
              uint64_t v25 = *(void *)(a1 + 120);
              uint64_t v26 = *(unsigned int *)(a1 + 12);
              uint64_t v23 = *(void *)(a1 + 40);
              uint64_t v24 = *(unsigned int *)(a1 + 28);
              double v13 = (TSTTableStrokeDefaults *)a1;
              unsigned int v14 = 16;
            }
          }
        }
        else
        {
          if (!*(_DWORD *)(a1 + 24))
          {
            uint64_t v23 = *(void *)(a1 + 64);
            uint64_t v24 = *(unsigned int *)(a1 + 12);
            double v13 = (TSTTableStrokeDefaults *)a1;
            unsigned int v14 = 13;
            goto LABEL_15;
          }
          uint64_t v25 = *(void *)(a1 + 120);
          uint64_t v26 = *(unsigned int *)(a1 + 12);
          uint64_t v23 = *(void *)(a1 + 64);
          uint64_t v24 = *(unsigned int *)(a1 + 28);
          double v13 = (TSTTableStrokeDefaults *)a1;
          unsigned int v14 = 12;
        }
      }
      else
      {
        if (!*(_DWORD *)(a1 + 24))
        {
          uint64_t v23 = *(void *)(a1 + 56);
          uint64_t v24 = *(unsigned int *)(a1 + 12);
          double v13 = (TSTTableStrokeDefaults *)a1;
          unsigned int v14 = 11;
          goto LABEL_15;
        }
        uint64_t v25 = *(void *)(a1 + 136);
        uint64_t v26 = *(unsigned int *)(a1 + 12);
        uint64_t v23 = *(void *)(a1 + 56);
        uint64_t v24 = *(unsigned int *)(a1 + 28);
        double v13 = (TSTTableStrokeDefaults *)a1;
        unsigned int v14 = 10;
      }
    }
    else if (v16)
    {
      if (v4)
      {
        int v18 = *(_DWORD *)(a1 + 24);
        if (v4 >= *(_DWORD *)(a1 + 8))
        {
          if (v18)
          {
            uint64_t v27 = *(void *)(a1 + 136);
            uint64_t v28 = *(unsigned int *)(a1 + 12);
            uint64_t v25 = *(void *)(a1 + 32);
            uint64_t v26 = *(unsigned int *)(a1 + 28);
            uint64_t v23 = *(void *)(a1 + 88);
            uint64_t v24 = *(unsigned int *)(a1 + 20);
            double v13 = (TSTTableStrokeDefaults *)a1;
            unsigned int v14 = 24;
            goto LABEL_65;
          }
          uint64_t v25 = *(void *)(a1 + 32);
          uint64_t v26 = *(unsigned int *)(a1 + 12);
          uint64_t v23 = *(void *)(a1 + 88);
          uint64_t v24 = *(unsigned int *)(a1 + 20);
          double v13 = (TSTTableStrokeDefaults *)a1;
          unsigned int v14 = 25;
        }
        else
        {
          if (v18)
          {
            uint64_t v27 = *(void *)(a1 + 120);
            uint64_t v28 = *(unsigned int *)(a1 + 12);
            uint64_t v25 = *(void *)(a1 + 40);
            uint64_t v26 = *(unsigned int *)(a1 + 28);
            uint64_t v23 = *(void *)(a1 + 96);
            uint64_t v24 = *(unsigned int *)(a1 + 20);
            double v13 = (TSTTableStrokeDefaults *)a1;
            unsigned int v14 = 22;
            goto LABEL_65;
          }
          uint64_t v25 = *(void *)(a1 + 40);
          uint64_t v26 = *(unsigned int *)(a1 + 12);
          uint64_t v23 = *(void *)(a1 + 96);
          uint64_t v24 = *(unsigned int *)(a1 + 20);
          double v13 = (TSTTableStrokeDefaults *)a1;
          unsigned int v14 = 23;
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 24))
        {
          uint64_t v27 = *(void *)(a1 + 136);
          uint64_t v28 = *(unsigned int *)(a1 + 12);
          uint64_t v25 = *(void *)(a1 + 32);
          uint64_t v26 = *(unsigned int *)(a1 + 28);
          uint64_t v23 = *(void *)(a1 + 88);
          uint64_t v24 = *(unsigned int *)(a1 + 20);
          double v13 = (TSTTableStrokeDefaults *)a1;
          unsigned int v14 = 20;
          goto LABEL_65;
        }
        uint64_t v25 = *(void *)(a1 + 32);
        uint64_t v26 = *(unsigned int *)(a1 + 12);
        uint64_t v23 = *(void *)(a1 + 88);
        uint64_t v24 = *(unsigned int *)(a1 + 20);
        double v13 = (TSTTableStrokeDefaults *)a1;
        unsigned int v14 = 21;
      }
    }
    else if (v4)
    {
      int v19 = *(_DWORD *)(a1 + 24);
      if (v4 >= *(_DWORD *)(a1 + 8))
      {
        if (!v19)
        {
          uint64_t v23 = *(void *)(a1 + 32);
          uint64_t v24 = *(unsigned int *)(a1 + 12);
          double v13 = (TSTTableStrokeDefaults *)a1;
          unsigned int v14 = 31;
          goto LABEL_15;
        }
        uint64_t v25 = *(void *)(a1 + 136);
        uint64_t v26 = *(unsigned int *)(a1 + 12);
        uint64_t v23 = *(void *)(a1 + 32);
        uint64_t v24 = *(unsigned int *)(a1 + 28);
        double v13 = (TSTTableStrokeDefaults *)a1;
        unsigned int v14 = 30;
      }
      else
      {
        if (!v19)
        {
          uint64_t v23 = *(void *)(a1 + 40);
          uint64_t v24 = *(unsigned int *)(a1 + 12);
          double v13 = (TSTTableStrokeDefaults *)a1;
          unsigned int v14 = 29;
          goto LABEL_15;
        }
        uint64_t v25 = *(void *)(a1 + 120);
        uint64_t v26 = *(unsigned int *)(a1 + 12);
        uint64_t v23 = *(void *)(a1 + 40);
        uint64_t v24 = *(unsigned int *)(a1 + 28);
        double v13 = (TSTTableStrokeDefaults *)a1;
        unsigned int v14 = 28;
      }
    }
    else
    {
      if (!*(_DWORD *)(a1 + 24))
      {
        uint64_t v23 = *(void *)(a1 + 32);
        uint64_t v24 = *(unsigned int *)(a1 + 12);
        double v13 = (TSTTableStrokeDefaults *)a1;
        unsigned int v14 = 27;
        goto LABEL_15;
      }
      uint64_t v25 = *(void *)(a1 + 136);
      uint64_t v26 = *(unsigned int *)(a1 + 12);
      uint64_t v23 = *(void *)(a1 + 32);
      uint64_t v24 = *(unsigned int *)(a1 + 28);
      double v13 = (TSTTableStrokeDefaults *)a1;
      unsigned int v14 = 26;
    }
    uint64_t v15 = 2;
    return TSTTableStrokeDefaultsStrokeArray(v13, v14, v15, v11, v12, 0, v23, v24, v25, v26, v27, v28);
  }
  return (TSTStrokeRunArray *)v7;
}

TSTStrokeRunArray *TSTTableStrokeDefaultsStrokeArray(TSTTableStrokeDefaults *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  if (*((_DWORD *)a1 + 40) <= a2) {
    return 0;
  }
  uint64_t v6 = *(TSTStrokeRunArray **)(*((void *)a1 + 21) + 8 * a2);
  if (!v6)
  {
    uint64_t v7 = a2;
    uint64_t v6 = TSTStrokeRunArrayCreateWithArguments(a3, (uint64_t)&a4);
    uint64_t v8 = v6;
    *(void *)(*((void *)a1 + 21) + 8 * v7) = v6;
  }
  return v6;
}

TSTStrokeRunArray *TSTTableStrokeDefaultsForRow(uint64_t a1, unsigned int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 12);
  if (v3 >= a2) {
    uint64_t v4 = a2;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t v5 = [MEMORY[0x263EFF9D0] null];
  uint64_t v6 = *(void *)(a1 + 184);
  if (v6)
  {
    uint64_t v7 = *(void *)(v6 + 8 * v4);
    if (!v7)
    {
      *(void *)(*(void *)(a1 + 184) + 8 * v4) = [MEMORY[0x263EFF9D0] null];
      uint64_t v27 = 0;
      TSTTableGetDefaultStrokesForRow(*(uint64_t **)a1, (unsigned __int16)v4, &v27, 0);
      uint64_t v8 = v27;
      if (v8 == (TSDStroke *)[MEMORY[0x263EFF9D0] null]) {
        TSTTableGetDefaultStrokesForRow(*(uint64_t **)a1, (unsigned __int16)(v4 - 1), 0, &v27);
      }
      unsigned int v9 = v27;
      if (v9 != (TSDStroke *)[MEMORY[0x263EFF9D0] null])
      {
        *(void *)(*(void *)(a1 + 184) + 8 * v4) = TSTStrokeRunArrayCreateWithStroke(v27, 0, *(_DWORD *)(a1 + 8));
        id v10 = *(id *)(*(void *)(a1 + 184) + 8 * v4);
      }
      uint64_t v7 = *(void *)(*(void *)(a1 + 184) + 8 * v4);
    }
  }
  else
  {
    uint64_t v7 = v5;
  }
  if (v7 == [MEMORY[0x263EFF9D0] null])
  {
    if (*(_DWORD *)(a1 + 160) == 2)
    {
      uint64_t v23 = *(void *)(a1 + 32);
      uint64_t v24 = *(unsigned int *)(a1 + 8);
      double v13 = (TSTTableStrokeDefaults *)a1;
      unsigned int v14 = 1;
      goto LABEL_15;
    }
    int v17 = *(_DWORD *)(a1 + 16);
    unsigned int v18 = *(_DWORD *)(a1 + 20);
    if (v18)
    {
      if (!v17)
      {
        if (v4)
        {
          if (v4 >= v18)
          {
            if (v4 != v18)
            {
              if (*(_DWORD *)(a1 + 24))
              {
                unsigned int v22 = *(_DWORD *)(a1 + 28);
                if (v4 == v22)
                {
                  uint64_t v23 = *(void *)(a1 + 144);
                  uint64_t v24 = *(unsigned int *)(a1 + 8);
                  double v13 = (TSTTableStrokeDefaults *)a1;
                  unsigned int v14 = 43;
                  goto LABEL_15;
                }
                if (v4 >= *(_DWORD *)(a1 + 12))
                {
                  uint64_t v23 = *(void *)(a1 + 136);
                  uint64_t v24 = *(unsigned int *)(a1 + 8);
                  double v13 = (TSTTableStrokeDefaults *)a1;
                  unsigned int v14 = 45;
                  goto LABEL_15;
                }
                if (v4 > v22)
                {
                  uint64_t v23 = *(void *)(a1 + 128);
                  uint64_t v24 = *(unsigned int *)(a1 + 8);
                  double v13 = (TSTTableStrokeDefaults *)a1;
                  unsigned int v14 = 58;
                  goto LABEL_15;
                }
              }
              else if (v4 >= *(_DWORD *)(a1 + 12))
              {
                uint64_t v23 = *(void *)(a1 + 32);
                uint64_t v24 = *(unsigned int *)(a1 + 8);
                double v13 = (TSTTableStrokeDefaults *)a1;
                unsigned int v14 = 46;
                goto LABEL_15;
              }
              uint64_t v23 = *(void *)(a1 + 48);
              uint64_t v24 = *(unsigned int *)(a1 + 8);
              double v13 = (TSTTableStrokeDefaults *)a1;
              unsigned int v14 = 44;
              goto LABEL_15;
            }
            uint64_t v23 = *(void *)(a1 + 112);
            uint64_t v24 = *(unsigned int *)(a1 + 8);
            double v13 = (TSTTableStrokeDefaults *)a1;
            unsigned int v14 = 42;
          }
          else
          {
            uint64_t v23 = *(void *)(a1 + 104);
            uint64_t v24 = *(unsigned int *)(a1 + 8);
            double v13 = (TSTTableStrokeDefaults *)a1;
            unsigned int v14 = 41;
          }
        }
        else
        {
          uint64_t v23 = *(void *)(a1 + 88);
          uint64_t v24 = *(unsigned int *)(a1 + 8);
          double v13 = (TSTTableStrokeDefaults *)a1;
          unsigned int v14 = 40;
        }
LABEL_15:
        uint64_t v15 = 1;
        return TSTTableStrokeDefaultsStrokeArray(v13, v14, v15, v11, v12, 0, v23, v24, v25, v26);
      }
      if (!v4)
      {
        uint64_t v23 = *(void *)(a1 + 88);
        uint64_t v24 = *(unsigned int *)(a1 + 8);
        double v13 = (TSTTableStrokeDefaults *)a1;
        unsigned int v14 = 32;
        goto LABEL_15;
      }
      if (v4 < v18)
      {
        uint64_t v23 = *(void *)(a1 + 104);
        uint64_t v24 = *(unsigned int *)(a1 + 8);
        double v13 = (TSTTableStrokeDefaults *)a1;
        unsigned int v14 = 33;
        goto LABEL_15;
      }
      if (v4 == v18)
      {
        uint64_t v23 = *(void *)(a1 + 112);
        uint64_t v24 = *(unsigned int *)(a1 + 8);
        double v13 = (TSTTableStrokeDefaults *)a1;
        unsigned int v14 = 34;
        goto LABEL_15;
      }
      if (*(_DWORD *)(a1 + 24))
      {
        unsigned int v21 = *(_DWORD *)(a1 + 28);
        if (v4 == v21)
        {
          uint64_t v23 = *(void *)(a1 + 144);
          uint64_t v24 = *(unsigned int *)(a1 + 8);
          double v13 = (TSTTableStrokeDefaults *)a1;
          unsigned int v14 = 35;
          goto LABEL_15;
        }
        if (v4 >= *(_DWORD *)(a1 + 12))
        {
          uint64_t v23 = *(void *)(a1 + 136);
          uint64_t v24 = *(unsigned int *)(a1 + 8);
          double v13 = (TSTTableStrokeDefaults *)a1;
          unsigned int v14 = 38;
          goto LABEL_15;
        }
        if (v4 > v21)
        {
          uint64_t v23 = *(void *)(a1 + 128);
          uint64_t v24 = *(unsigned int *)(a1 + 8);
          double v13 = (TSTTableStrokeDefaults *)a1;
          unsigned int v14 = 36;
          goto LABEL_15;
        }
        goto LABEL_67;
      }
      if (v4 < *(_DWORD *)(a1 + 12))
      {
LABEL_67:
        uint64_t v25 = *(void *)(a1 + 48);
        uint64_t v26 = *(unsigned int *)(a1 + 8);
        uint64_t v23 = *(void *)(a1 + 72);
        uint64_t v24 = *(unsigned int *)(a1 + 16);
        double v13 = (TSTTableStrokeDefaults *)a1;
        unsigned int v14 = 37;
        goto LABEL_68;
      }
      uint64_t v25 = *(void *)(a1 + 32);
      uint64_t v26 = *(unsigned int *)(a1 + 8);
      uint64_t v23 = *(void *)(a1 + 56);
      uint64_t v24 = *(unsigned int *)(a1 + 16);
      double v13 = (TSTTableStrokeDefaults *)a1;
      unsigned int v14 = 39;
    }
    else
    {
      if (!v17)
      {
        if (!v4)
        {
          uint64_t v23 = *(void *)(a1 + 32);
          uint64_t v24 = *(unsigned int *)(a1 + 8);
          double v13 = (TSTTableStrokeDefaults *)a1;
          unsigned int v14 = 53;
          goto LABEL_15;
        }
        if (*(_DWORD *)(a1 + 24))
        {
          unsigned int v20 = *(_DWORD *)(a1 + 28);
          if (v4 == v20)
          {
            uint64_t v23 = *(void *)(a1 + 144);
            uint64_t v24 = *(unsigned int *)(a1 + 8);
            double v13 = (TSTTableStrokeDefaults *)a1;
            unsigned int v14 = 54;
            goto LABEL_15;
          }
          if (v4 >= *(_DWORD *)(a1 + 12))
          {
            uint64_t v23 = *(void *)(a1 + 136);
            uint64_t v24 = *(unsigned int *)(a1 + 8);
            double v13 = (TSTTableStrokeDefaults *)a1;
            unsigned int v14 = 56;
            goto LABEL_15;
          }
          if (v4 > v20)
          {
            uint64_t v23 = *(void *)(a1 + 128);
            uint64_t v24 = *(unsigned int *)(a1 + 8);
            double v13 = (TSTTableStrokeDefaults *)a1;
            unsigned int v14 = 59;
            goto LABEL_15;
          }
        }
        else if (v4 >= *(_DWORD *)(a1 + 12))
        {
          uint64_t v23 = *(void *)(a1 + 32);
          uint64_t v24 = *(unsigned int *)(a1 + 8);
          double v13 = (TSTTableStrokeDefaults *)a1;
          unsigned int v14 = 57;
          goto LABEL_15;
        }
        uint64_t v23 = *(void *)(a1 + 48);
        uint64_t v24 = *(unsigned int *)(a1 + 8);
        double v13 = (TSTTableStrokeDefaults *)a1;
        unsigned int v14 = 55;
        goto LABEL_15;
      }
      if (v4)
      {
        if (*(_DWORD *)(a1 + 24))
        {
          unsigned int v19 = *(_DWORD *)(a1 + 28);
          if (v4 == v19)
          {
            uint64_t v23 = *(void *)(a1 + 144);
            uint64_t v24 = *(unsigned int *)(a1 + 8);
            double v13 = (TSTTableStrokeDefaults *)a1;
            unsigned int v14 = 48;
            goto LABEL_15;
          }
          if (v4 >= *(_DWORD *)(a1 + 12))
          {
            uint64_t v23 = *(void *)(a1 + 136);
            uint64_t v24 = *(unsigned int *)(a1 + 8);
            double v13 = (TSTTableStrokeDefaults *)a1;
            unsigned int v14 = 51;
            goto LABEL_15;
          }
          if (v4 > v19)
          {
            uint64_t v23 = *(void *)(a1 + 128);
            uint64_t v24 = *(unsigned int *)(a1 + 8);
            double v13 = (TSTTableStrokeDefaults *)a1;
            unsigned int v14 = 49;
            goto LABEL_15;
          }
        }
        else if (v4 >= *(_DWORD *)(a1 + 12))
        {
          uint64_t v25 = *(void *)(a1 + 32);
          uint64_t v26 = *(unsigned int *)(a1 + 8);
          uint64_t v23 = *(void *)(a1 + 56);
          uint64_t v24 = *(unsigned int *)(a1 + 16);
          double v13 = (TSTTableStrokeDefaults *)a1;
          unsigned int v14 = 52;
          goto LABEL_68;
        }
        uint64_t v25 = *(void *)(a1 + 48);
        uint64_t v26 = *(unsigned int *)(a1 + 8);
        uint64_t v23 = *(void *)(a1 + 72);
        uint64_t v24 = *(unsigned int *)(a1 + 16);
        double v13 = (TSTTableStrokeDefaults *)a1;
        unsigned int v14 = 50;
        goto LABEL_68;
      }
      uint64_t v25 = *(void *)(a1 + 32);
      uint64_t v26 = *(unsigned int *)(a1 + 8);
      uint64_t v23 = *(void *)(a1 + 56);
      uint64_t v24 = *(unsigned int *)(a1 + 16);
      double v13 = (TSTTableStrokeDefaults *)a1;
      unsigned int v14 = 47;
    }
LABEL_68:
    uint64_t v15 = 2;
    return TSTTableStrokeDefaultsStrokeArray(v13, v14, v15, v11, v12, 0, v23, v24, v25, v26);
  }
  return (TSTStrokeRunArray *)v7;
}

BOOL TSTLayoutCellIteratorGetNextCell(uint64_t a1, void *a2)
{
  uint64_t v4 = (void *)[(id)a1 masterLayout];
  int v5 = *(unsigned __int16 *)(a1 + 186);
  unint64_t v6 = *(void *)(a1 + 120);
  unint64_t v7 = v6 + HIWORD(v6) - 1;
  unsigned int v38 = HIDWORD(v6) + WORD1(v6) + 255;
  uint64_t v8 = [v4 isDynamicallyChangingContent];
  int v39 = [v4 isDynamicallyHidingRowsCols];
  char v33 = a2;
  unsigned int v9 = a2;
  uint64_t v10 = v8;
  v9[1] = 0;
  *((_DWORD *)++v9 - 1) = 0xFFFFFF;
  v9[1] = 0;
  _OWORD v9[2] = 0xFFFFFFLL;
  uint64_t v29 = v9;
  signed int v32 = v5 - 1;
  int v11 = 0;
  uint64_t v12 = &OBJC_IVAR___TSTSearchReference__cellID;
  unint64_t v30 = v6 >> 16;
  char v31 = v4;
  while (1)
  {
    unsigned int v13 = *(unsigned __int16 *)(a1 + 128);
    if (v13 > (unsigned __int16)v7) {
      return v13 <= (unsigned __int16)v7;
    }
    if (!*(unsigned char *)(a1 + v12[408]))
    {
      *(unsigned char *)(a1 + 185) = TSTCellIteratorGetNextCell((void *)a1, (const char *)(a1 + 144));
      *(unsigned char *)(a1 + v12[408]) = 1;
    }
    if (v39) {
      v11 |= [v4 isDynamicallyHidingRowsCols:1 rowColIndex:*(unsigned __int8 *)(a1 + 130)];
    }
    if ((v10 | v11))
    {
      id v40 = 0;
      if (v10)
      {
        unsigned int v14 = (void *)[v4 dynamicContentDelegate];
        unint64_t v34 = v34 & 0xFFFFFFFF00000000 | *(unsigned int *)(a1 + 128);
        if (objc_msgSend(v14, "cell:forCellID:", &v40)) {
          goto LABEL_13;
        }
      }
      else if (v11)
      {
        id v40 = +[TSTCell cell];
LABEL_13:
        TSTCellClear(*(void *)(a1 + 136));
        TSTCellCopy((uint64_t)v40, *(void *)(a1 + 136));
        v33[1] = *(void *)(a1 + 136);
        uint64_t v15 = *(unsigned int *)(a1 + 128);
        *((_DWORD *)v33 + 1) = v15;
        unint64_t v35 = v35 & 0xFFFFFFFF00000000 | v15;
        v33[3] = TSTMasterLayoutMergeRangeAtCellID(v4, v15);
        if (*(unsigned char *)(a1 + 185) && ((*(_DWORD *)(a1 + 148) ^ *(_DWORD *)(a1 + 128)) & 0xFFFFFF) == 0) {
          *(unsigned char *)(a1 + 185) = TSTCellIteratorGetNextCell((void *)a1, (const char *)(a1 + 144));
        }
        int v16 = 1;
LABEL_35:
        uint64_t v12 = &OBJC_IVAR___TSTSearchReference__cellID;
        goto LABEL_36;
      }
    }
    if (*(unsigned __int16 *)(a1 + 128) >= *(unsigned __int16 *)(a1 + 190)
      || *(unsigned __int16 *)(a1 + 188) <= *(unsigned __int8 *)(a1 + 130))
    {
      if ([v4 isDynamicallyChangingRowOrColumnCount])
      {
        int v37 = v11;
        uint64_t v17 = v10;
        unint64_t v18 = v7;
        unsigned int v19 = *(unsigned __int16 *)(a1 + 128);
        unsigned __int8 v20 = *(unsigned char *)(a1 + 130);
        uint64_t v21 = *(unsigned __int8 *)(a1 + 131);
        if (v19 >= [*(id *)(a1 + 8) numberOfRows])
        {
          __int16 v22 = [*(id *)(a1 + 8) numberOfRows];
          LOWORD(v19) = v22 + ~(unsigned __int16)[*(id *)(a1 + 8) numberOfFooterRows];
        }
        unsigned int v23 = *(unsigned __int8 *)(a1 + 130);
        if ([*(id *)(a1 + 8) numberOfColumns] <= v23) {
          unsigned __int8 v20 = [*(id *)(a1 + 8) numberOfColumns] - 1;
        }
        unint64_t v24 = (v21 << 24) | ((unint64_t)v20 << 16) | (unsigned __int16)v19;
        unint64_t v36 = v24 | v36 & 0xFFFFFFFF00000000;
        uint64_t v10 = v17;
        if (TSTCellAtCellID(*(void *)(a1 + 8), v24, *(void **)(a1 + 136)))
        {
          int v16 = 0;
        }
        else
        {
          uint64_t v25 = *(void *)(a1 + 136);
          TSTCellClearValue(v25);
          *(_DWORD *)(v25 + 8) &= 0xFFFF00FF;
          v33[1] = *(void *)(a1 + 136);
          *((_DWORD *)v33 + 1) = *(_DWORD *)(a1 + 128);
          int v16 = 1;
        }
        unint64_t v7 = v18;
        uint64_t v4 = v31;
        int v11 = v37;
        goto LABEL_35;
      }
    }
    else if (*(unsigned char *)(a1 + 185) && ((*(_DWORD *)(a1 + 148) ^ *(_DWORD *)(a1 + 128)) & 0xFFFFFF) == 0)
    {
      if (([(id)a1 dontExpandCellRefs] & 1) == 0 && *(void *)(a1 + 152))
      {
        TSTCellClear(*(void *)(a1 + 136));
        TSTCellCopy(*(void *)(a1 + 152), *(void *)(a1 + 136));
        *uint64_t v29 = *(void *)(a1 + 136);
      }
      _OWORD v33[2] = *(void *)(a1 + 160);
      *((_DWORD *)v33 + 1) = *(_DWORD *)(a1 + 148);
      v33[3] = *(void *)(a1 + 168);
      *(unsigned char *)(a1 + 185) = TSTCellIteratorGetNextCell((void *)a1, (const char *)(a1 + 144));
      int v16 = 1;
      goto LABEL_36;
    }
    int v16 = 0;
LABEL_36:
    int v26 = [(id)a1 rowWalkDirection];
    unsigned int v27 = *(unsigned __int8 *)(a1 + 130);
    if (v26)
    {
      if (*(unsigned char *)(a1 + 130) && v27 > *(unsigned __int8 *)(a1 + 122))
      {
        *(unsigned char *)(a1 + 130) = v27 - 1;
        if (v16) {
          return v13 <= (unsigned __int16)v7;
        }
      }
      else
      {
        *(unsigned char *)(a1 + 130) = v38;
LABEL_47:
        ++*(_WORD *)(a1 + 128);
        if (v16) {
          return v13 <= (unsigned __int16)v7;
        }
      }
    }
    else
    {
      if (v32 <= (int)v27 || v27 >= v38)
      {
        *(unsigned char *)(a1 + 130) = v30;
        goto LABEL_47;
      }
      *(unsigned char *)(a1 + 130) = v27 + 1;
      if (v16) {
        return v13 <= (unsigned __int16)v7;
      }
    }
  }
}

uint64_t TSTLayoutCellIteratorValueTypeOfCell(uint64_t a1)
{
  if (*(void *)(a1 + 16)) {
    return TSTCellIteratorValueTypeOfCell(a1);
  }
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    return *(unsigned __int8 *)(v2 + 9);
  }
  else {
    return 0;
  }
}

uint64_t TSTLayoutCellIteratorExpandCell(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a2 + 8) && ((*(_DWORD *)(a1 + 128) ^ *(_DWORD *)(a2 + 4)) & 0xFFFFFF) == 0) {
    return (uint64_t)TSTCellIteratorExpandCellForLayout(a1, a2);
  }
  return a1;
}

uint64_t TSABundle()
{
  if (TSABundle::onceToken != -1) {
    dispatch_once(&TSABundle::onceToken, &__block_literal_global_84);
  }
  return TSABundle::bundle;
}

uint64_t __TSABundle_block_invoke()
{
  uint64_t result = [MEMORY[0x263F086E0] bundleForClass:objc_opt_class()];
  TSABundle::bundle = result;
  return result;
}

void sub_2237FBFAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 80), 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__32(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__32(uint64_t a1)
{
}

void sub_2237FC090(_Unwind_Exception *a1)
{
}

__CFString *TSABuildVersionHistoryPrefix()
{
  return @"T";
}

uint64_t TSABuildVersionString()
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  uint64_t v0 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x263F086E0], "mainBundle"), "bundlePath"), "stringByAppendingPathComponent:", @"Contents"), "stringByAppendingPathComponent:", @"version.plist");
  if (!objc_msgSend((id)objc_msgSend(MEMORY[0x263F08850], "defaultManager"), "fileExistsAtPath:", v0)
    || ((uint64_t v1 = (void *)[NSDictionary dictionaryWithContentsOfFile:v0],
         uint64_t v2 = [v1 objectForKey:@"CFBundleShortVersionString"],
         uint64_t v3 = [v1 objectForKey:@"CFBundleVersion"],
         uint64_t v4 = [v1 objectForKey:@"BuildVersion"],
         v2)
      ? (BOOL v5 = v3 == 0)
      : (BOOL v5 = 1),
        !v5 ? (BOOL v6 = v4 == 0) : (BOOL v6 = 1),
        v6
     || (unint64_t v7 = (void *)[NSString stringWithFormat:@"%@-%@-%@", v2, v3, v4]) == 0))
  {
    uint64_t v8 = objc_msgSend((id)objc_msgSend(MEMORY[0x263F086E0], "mainBundle"), "pathForResource:ofType:", @"BuildVersion", @"plist");
    unint64_t v7 = objc_msgSend((id)objc_msgSend(NSDictionary, "dictionaryWithContentsOfFile:", v8), "objectForKey:", @"build");
    if (!v7)
    {
      uint64_t v9 = objc_msgSend((id)objc_msgSend(MEMORY[0x263F086E0], "mainBundle"), "pathForResource:ofType:inDirectory:", @"Root", @"plist", @"Settings.bundle");
      uint64_t v10 = (void *)[NSDictionary dictionaryWithContentsOfFile:v9];
      if (!v10
        || (uint64_t v11 = (void *)[v10 objectForKey:@"PreferenceSpecifiers"]) == 0
        || (uint64_t v12 = v11,
            long long v30 = 0u,
            long long v31 = 0u,
            long long v28 = 0u,
            long long v29 = 0u,
            (uint64_t v13 = [v11 countByEnumeratingWithState:&v28 objects:v32 count:16]) == 0))
      {
LABEL_27:
        [0 isEqualToString:@"Local Build"];
LABEL_28:
        uint64_t v24 = objc_msgSend((id)objc_msgSend(MEMORY[0x263F086E0], "mainBundle"), "bundlePath");
        if (!v24
          || (v25 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x263F08850], "defaultManager"), "attributesOfItemAtPath:error:", v24, 0), "fileModificationDate")) == 0|| (unint64_t v7 = objc_msgSend(NSString, "stringWithFormat:", @"local build-%@", v25)) == 0)
        {
          int v26 = (void *)[[NSString alloc] initWithCString:"Nov 10 2024" encoding:4];
          unint64_t v7 = (void *)[NSString stringWithFormat:@"local build-%@", v26];
        }
        return [@"T" stringByAppendingString:v7];
      }
      uint64_t v14 = v13;
      uint64_t v15 = *(void *)v29;
LABEL_15:
      uint64_t v16 = 0;
      while (1)
      {
        if (*(void *)v29 != v15) {
          objc_enumerationMutation(v12);
        }
        uint64_t v17 = *(void **)(*((void *)&v28 + 1) + 8 * v16);
        if (objc_msgSend((id)objc_msgSend(v17, "objectForKey:", @"Key"), "isEqualToString:", @"TSABuildID"))break; {
        if (v14 == ++v16)
        }
        {
          uint64_t v14 = [v12 countByEnumeratingWithState:&v28 objects:v32 count:16];
          if (v14) {
            goto LABEL_15;
          }
          goto LABEL_27;
        }
      }
      unint64_t v18 = (void *)[v17 objectForKey:@"Titles"];
      if (!v18) {
        goto LABEL_27;
      }
      unsigned int v19 = v18;
      if (![v18 count]) {
        goto LABEL_27;
      }
      unint64_t v7 = (void *)[v19 objectAtIndex:0];
      uint64_t v20 = [v7 rangeOfString:@"-"];
      if (v20 != 0x7FFFFFFFFFFFFFFFLL)
      {
        uint64_t v21 = v20;
        if (v20 == [v7 length] - 1)
        {
          __int16 v22 = (void *)[MEMORY[0x263F7C7F0] currentHandler];
          uint64_t v23 = [NSString stringWithUTF8String:"NSString *TSABuildVersionString()"];
          objc_msgSend(v22, "handleFailureInFunction:file:lineNumber:description:", v23, objc_msgSend(NSString, "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/application/common/TSADocumentRoot.mm"), 2536, @"Not expecting to find a build version string with the only hyphen as the last character");
        }
        else
        {
          unint64_t v7 = (void *)[v7 substringFromIndex:v21 + 1];
        }
      }
      if (([v7 isEqualToString:@"Local Build"] & 1) != 0 || !v7) {
        goto LABEL_28;
      }
    }
  }
  return [@"T" stringByAppendingString:v7];
}

NSArray *TSAUpdateBuildVersionHistory(NSArray *a1)
{
  uint64_t v1 = a1;
  if (!a1) {
    uint64_t v1 = (NSArray *)[MEMORY[0x263EFF8C0] array];
  }
  uint64_t v2 = TSABuildVersionString();
  objc_opt_class();
  [(NSArray *)v1 lastObject];
  if (([(id)TSUDynamicCast() isEqualToString:v2] & 1) != 0 || !v2) {
    return v1;
  }

  return [(NSArray *)v1 arrayByAddingObject:v2];
}

void sub_2238012BC(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

CFTimeInterval CACurrentMediaTime(void)
{
  MEMORY[0x270EFB790]();
  return result;
}

CATransform3D *__cdecl CATransform3DConcat(CATransform3D *__return_ptr retstr, CATransform3D *a, CATransform3D *b)
{
  return (CATransform3D *)MEMORY[0x270EFB8F0](retstr, a, b);
}

uint64_t CATransform3DInterpolate()
{
  return MEMORY[0x270EFB910]();
}

BOOL CATransform3DIsIdentity(CATransform3D *t)
{
  return MEMORY[0x270EFB928](t);
}

CATransform3D *__cdecl CATransform3DMakeAffineTransform(CATransform3D *__return_ptr retstr, CGAffineTransform *m)
{
  return (CATransform3D *)MEMORY[0x270EFB930](retstr, m);
}

CATransform3D *__cdecl CATransform3DMakeRotation(CATransform3D *__return_ptr retstr, CGFloat angle, CGFloat x, CGFloat y, CGFloat z)
{
  return (CATransform3D *)MEMORY[0x270EFB938](retstr, angle, x, y, z);
}

CATransform3D *__cdecl CATransform3DMakeScale(CATransform3D *__return_ptr retstr, CGFloat sx, CGFloat sy, CGFloat sz)
{
  return (CATransform3D *)MEMORY[0x270EFB948](retstr, sx, sy, sz);
}

CATransform3D *__cdecl CATransform3DMakeTranslation(CATransform3D *__return_ptr retstr, CGFloat tx, CGFloat ty, CGFloat tz)
{
  return (CATransform3D *)MEMORY[0x270EFB950](retstr, tx, ty, tz);
}

CATransform3D *__cdecl CATransform3DRotate(CATransform3D *__return_ptr retstr, CATransform3D *t, CGFloat angle, CGFloat x, CGFloat y, CGFloat z)
{
  return (CATransform3D *)MEMORY[0x270EFB960](retstr, t, angle, x, y, z);
}

CATransform3D *__cdecl CATransform3DScale(CATransform3D *__return_ptr retstr, CATransform3D *t, CGFloat sx, CGFloat sy, CGFloat sz)
{
  return (CATransform3D *)MEMORY[0x270EFB970](retstr, t, sx, sy, sz);
}

CATransform3D *__cdecl CATransform3DTranslate(CATransform3D *__return_ptr retstr, CATransform3D *t, CGFloat tx, CGFloat ty, CGFloat tz)
{
  return (CATransform3D *)MEMORY[0x270EFB978](retstr, t, tx, ty, tz);
}

CCCryptorStatus CCCryptorCreate(CCOperation op, CCAlgorithm alg, CCOptions options, const void *key, size_t keyLength, const void *iv, CCCryptorRef *cryptorRef)
{
  return MEMORY[0x270ED78C8](*(void *)&op, *(void *)&alg, *(void *)&options, key, keyLength, iv, cryptorRef);
}

CCCryptorStatus CCCryptorFinal(CCCryptorRef cryptorRef, void *dataOut, size_t dataOutAvailable, size_t *dataOutMoved)
{
  return MEMORY[0x270ED78E8](cryptorRef, dataOut, dataOutAvailable, dataOutMoved);
}

size_t CCCryptorGetOutputLength(CCCryptorRef cryptorRef, size_t inputLength, BOOL final)
{
  return MEMORY[0x270ED7930](cryptorRef, inputLength, final);
}

CCCryptorStatus CCCryptorRelease(CCCryptorRef cryptorRef)
{
  return MEMORY[0x270ED7940](cryptorRef);
}

CCCryptorStatus CCCryptorUpdate(CCCryptorRef cryptorRef, const void *dataIn, size_t dataInLength, void *dataOut, size_t dataOutAvailable, size_t *dataOutMoved)
{
  return MEMORY[0x270ED7950](cryptorRef, dataIn, dataInLength, dataOut, dataOutAvailable, dataOutMoved);
}

void CCHmacFinal(CCHmacContext *ctx, void *macOut)
{
}

void CCHmacInit(CCHmacContext *ctx, CCHmacAlgorithm algorithm, const void *key, size_t keyLength)
{
}

void CCHmacUpdate(CCHmacContext *ctx, const void *data, size_t dataLength)
{
}

unsigned __int8 *__cdecl CC_SHA1(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return (unsigned __int8 *)MEMORY[0x270ED7AF0](data, *(void *)&len, md);
}

int CC_SHA1_Final(unsigned __int8 *md, CC_SHA1_CTX *c)
{
  return MEMORY[0x270ED7AF8](md, c);
}

int CC_SHA1_Init(CC_SHA1_CTX *c)
{
  return MEMORY[0x270ED7B00](c);
}

int CC_SHA1_Update(CC_SHA1_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x270ED7B08](c, data, *(void *)&len);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  MEMORY[0x270EE4278]();
  return result;
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return (CFArrayRef)MEMORY[0x270EE42F0](allocator, values, numValues, callBacks);
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  return (CFArrayRef)MEMORY[0x270EE42F8](allocator, theArray);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x270EE4300](allocator, capacity, callBacks);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x270EE4320](theArray);
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x270EE4338](theArray, range.location, range.length, value);
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x270EE4360](theArray, idx);
}

void CFArrayInsertValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
}

void CFArrayRemoveAllValues(CFMutableArrayRef theArray)
{
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
}

CFAttributedStringRef CFAttributedStringCreate(CFAllocatorRef alloc, CFStringRef str, CFDictionaryRef attributes)
{
  return (CFAttributedStringRef)MEMORY[0x270EE43B0](alloc, str, attributes);
}

CFMutableAttributedStringRef CFAttributedStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableAttributedStringRef)MEMORY[0x270EE43C0](alloc, maxLength);
}

CFTypeRef CFAttributedStringGetAttribute(CFAttributedStringRef aStr, CFIndex loc, CFStringRef attrName, CFRange *effectiveRange)
{
  return (CFTypeRef)MEMORY[0x270EE43E0](aStr, loc, attrName, effectiveRange);
}

CFTypeRef CFAttributedStringGetAttributeAndLongestEffectiveRange(CFAttributedStringRef aStr, CFIndex loc, CFStringRef attrName, CFRange inRange, CFRange *longestEffectiveRange)
{
  return (CFTypeRef)MEMORY[0x270EE43E8](aStr, loc, attrName, inRange.location, inRange.length, longestEffectiveRange);
}

CFIndex CFAttributedStringGetLength(CFAttributedStringRef aStr)
{
  return MEMORY[0x270EE4400](aStr);
}

CFStringRef CFAttributedStringGetString(CFAttributedStringRef aStr)
{
  return (CFStringRef)MEMORY[0x270EE4408](aStr);
}

void CFAttributedStringReplaceString(CFMutableAttributedStringRef aStr, CFRange range, CFStringRef replacement)
{
}

void CFAttributedStringSetAttribute(CFMutableAttributedStringRef aStr, CFRange range, CFStringRef attrName, CFTypeRef value)
{
}

void CFAttributedStringSetAttributes(CFMutableAttributedStringRef aStr, CFRange range, CFDictionaryRef replacement, Boolean clearOtherAttributes)
{
}

CFTypeRef CFAutorelease(CFTypeRef arg)
{
  return (CFTypeRef)MEMORY[0x270EE4440](arg);
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x270EE4530](BOOLean);
}

void CFCharacterSetAddCharactersInRange(CFMutableCharacterSetRef theSet, CFRange theRange)
{
}

void CFCharacterSetAddCharactersInString(CFMutableCharacterSetRef theSet, CFStringRef theString)
{
}

CFMutableCharacterSetRef CFCharacterSetCreateMutable(CFAllocatorRef alloc)
{
  return (CFMutableCharacterSetRef)MEMORY[0x270EE4730](alloc);
}

CFCharacterSetRef CFCharacterSetCreateWithCharactersInString(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFCharacterSetRef)MEMORY[0x270EE4748](alloc, theString);
}

CFCharacterSetRef CFCharacterSetGetPredefined(CFCharacterSetPredefinedSet theSetIdentifier)
{
  return (CFCharacterSetRef)MEMORY[0x270EE4750](theSetIdentifier);
}

Boolean CFCharacterSetIsCharacterMember(CFCharacterSetRef theSet, UniChar theChar)
{
  return MEMORY[0x270EE4760](theSet, theChar);
}

Boolean CFCharacterSetIsLongCharacterMember(CFCharacterSetRef theSet, UTF32Char theChar)
{
  return MEMORY[0x270EE4768](theSet, *(void *)&theChar);
}

void CFCharacterSetRemoveCharactersInRange(CFMutableCharacterSetRef theSet, CFRange theRange)
{
}

void CFCharacterSetUnion(CFMutableCharacterSetRef theSet, CFCharacterSetRef theOtherSet)
{
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableDataRef)MEMORY[0x270EE47E0](allocator, capacity);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x270EE4820](theData);
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  return (UInt8 *)MEMORY[0x270EE4830](theData);
}

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x270EE48F0](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x270EE4908](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x270EE4920](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x270EE4928](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x270EE4930](theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x270EE4958](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x270EE4968](theDict, key, value);
}

void CFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
}

void CFDictionaryReplaceValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x270EE4998](cf1, cf2);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x270EE4A30](cf);
}

CFHashCode CFHash(CFTypeRef cf)
{
  return MEMORY[0x270EE4A48](cf);
}

CFLocaleRef CFLocaleCopyCurrent(void)
{
  return (CFLocaleRef)MEMORY[0x270EE4A60]();
}

CFLocaleRef CFLocaleCreate(CFAllocatorRef allocator, CFLocaleIdentifier localeIdentifier)
{
  return (CFLocaleRef)MEMORY[0x270EE4A80](allocator, localeIdentifier);
}

CFLocaleRef CFLocaleGetSystem(void)
{
  return (CFLocaleRef)MEMORY[0x270EE4AC0]();
}

CFTypeRef CFLocaleGetValue(CFLocaleRef locale, CFLocaleKey key)
{
  return (CFTypeRef)MEMORY[0x270EE4AD0](locale, key);
}

Boolean CFNumberFormatterGetDecimalInfoForCurrencyCode(CFStringRef currencyCode, int32_t *defaultFractionDigits, double *roundingIncrement)
{
  return MEMORY[0x270EE4C18](currencyCode, defaultFractionDigits, roundingIncrement);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x270EE4E10](cf);
}

void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
}

CFRunLoopRef CFRunLoopGetMain(void)
{
  return (CFRunLoopRef)MEMORY[0x270EE4E68]();
}

void CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void *block)
{
}

CFRunLoopRunResult CFRunLoopRunInMode(CFRunLoopMode mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled)
{
  return MEMORY[0x270EE4ED0](mode, returnAfterSourceHandled, seconds);
}

CFRunLoopSourceRef CFRunLoopSourceCreate(CFAllocatorRef allocator, CFIndex order, CFRunLoopSourceContext *context)
{
  return (CFRunLoopSourceRef)MEMORY[0x270EE4EE0](allocator, order, context);
}

void CFRunLoopSourceInvalidate(CFRunLoopSourceRef source)
{
}

void CFRunLoopSourceSignal(CFRunLoopSourceRef source)
{
}

void CFRunLoopWakeUp(CFRunLoopRef rl)
{
}

void CFSetAddValue(CFMutableSetRef theSet, const void *value)
{
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  return (CFMutableSetRef)MEMORY[0x270EE4F60](allocator, capacity, callBacks);
}

CFIndex CFSetGetCount(CFSetRef theSet)
{
  return MEMORY[0x270EE4F70](theSet);
}

void CFSetRemoveValue(CFMutableSetRef theSet, const void *value)
{
}

void CFStringCapitalize(CFMutableStringRef theString, CFLocaleRef locale)
{
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x270EE5048](theString1, theString2, compareOptions);
}

unint64_t CFStringConvertEncodingToNSStringEncoding(CFStringEncoding encoding)
{
  return MEMORY[0x270EE5068](*(void *)&encoding);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFStringRef)MEMORY[0x270EE5098](alloc, theString);
}

CFMutableStringRef CFStringCreateMutableWithExternalCharactersNoCopy(CFAllocatorRef alloc, UniChar *chars, CFIndex numChars, CFIndex capacity, CFAllocatorRef externalCharactersAllocator)
{
  return (CFMutableStringRef)MEMORY[0x270EE50C0](alloc, chars, numChars, capacity, externalCharactersAllocator);
}

CFStringRef CFStringCreateWithCharacters(CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars)
{
  return (CFStringRef)MEMORY[0x270EE50F8](alloc, chars, numChars);
}

CFStringRef CFStringCreateWithCharactersNoCopy(CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x270EE5100](alloc, chars, numChars, contentsDeallocator);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x270EE5180](theString, *(void *)&encoding);
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  return MEMORY[0x270EE5190](theString, idx);
}

void CFStringGetCharacters(CFStringRef theString, CFRange range, UniChar *buffer)
{
}

const UniChar *__cdecl CFStringGetCharactersPtr(CFStringRef theString)
{
  return (const UniChar *)MEMORY[0x270EE51A0](theString);
}

CFIndex CFStringGetHyphenationLocationBeforeIndex(CFStringRef string, CFIndex location, CFRange limitRange, CFOptionFlags options, CFLocaleRef locale, UTF32Char *character)
{
  return MEMORY[0x270EE51C0](string, location, limitRange.location, limitRange.length, options, locale, character);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x270EE51D8](theString);
}

CFRange CFStringGetRangeOfComposedCharactersAtIndex(CFStringRef theString, CFIndex theIndex)
{
  CFIndex v2 = MEMORY[0x270EE5200](theString, theIndex);
  result.length = v3;
  result.location = v2;
  return result;
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return MEMORY[0x270EE5228](theString, prefix);
}

CFStringTokenizerTokenType CFStringTokenizerAdvanceToNextToken(CFStringTokenizerRef tokenizer)
{
  return MEMORY[0x270EE5278](tokenizer);
}

CFStringRef CFStringTokenizerCopyBestStringLanguage(CFStringRef string, CFRange range)
{
  return (CFStringRef)MEMORY[0x270EE5280](string, range.location, range.length);
}

CFTypeRef CFStringTokenizerCopyCurrentTokenAttribute(CFStringTokenizerRef tokenizer, CFOptionFlags attribute)
{
  return (CFTypeRef)MEMORY[0x270EE5288](tokenizer, attribute);
}

CFStringTokenizerRef CFStringTokenizerCreate(CFAllocatorRef alloc, CFStringRef string, CFRange range, CFOptionFlags options, CFLocaleRef locale)
{
  return (CFStringTokenizerRef)MEMORY[0x270EE5290](alloc, string, range.location, range.length, options, locale);
}

CFRange CFStringTokenizerGetCurrentTokenRange(CFStringTokenizerRef tokenizer)
{
  CFIndex v1 = MEMORY[0x270EE52A0](tokenizer);
  result.length = v2;
  result.location = v1;
  return result;
}

CFStringTokenizerTokenType CFStringTokenizerGoToTokenAtIndex(CFStringTokenizerRef tokenizer, CFIndex index)
{
  return MEMORY[0x270EE52A8](tokenizer, index);
}

Boolean CFStringTransform(CFMutableStringRef string, CFRange *range, CFStringRef transform, Boolean reverse)
{
  return MEMORY[0x270EE52B8](string, range, transform, reverse);
}

void CFStringUppercase(CFMutableStringRef theString, CFLocaleRef locale)
{
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return (CFStringRef)MEMORY[0x270EE5328](anURL, pathStyle);
}

CFStringRef CFURLCreateStringByAddingPercentEscapes(CFAllocatorRef allocator, CFStringRef originalString, CFStringRef charactersToLeaveUnescaped, CFStringRef legalURLCharactersToBeEscaped, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x270EE53D0](allocator, originalString, charactersToLeaveUnescaped, legalURLCharactersToBeEscaped, *(void *)&encoding);
}

CFStringRef CFURLCreateStringByReplacingPercentEscapes(CFAllocatorRef allocator, CFStringRef originalString, CFStringRef charactersToLeaveEscaped)
{
  return (CFStringRef)MEMORY[0x270EE53D8](allocator, originalString, charactersToLeaveEscaped);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x270EE53F0](allocator, filePath, pathStyle, isDirectory);
}

CFURLRef CFURLCreateWithFileSystemPathRelativeToBase(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x270EE53F8](allocator, filePath, pathStyle, isDirectory, baseURL);
}

CFUUIDRef CFUUIDCreate(CFAllocatorRef alloc)
{
  return (CFUUIDRef)MEMORY[0x270EE5470](alloc);
}

CFStringRef CFUUIDCreateString(CFAllocatorRef alloc, CFUUIDRef uuid)
{
  return (CFStringRef)MEMORY[0x270EE5488](alloc, uuid);
}

CGAffineTransform *__cdecl CGAffineTransformConcat(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t1, CGAffineTransform *t2)
{
  return (CGAffineTransform *)MEMORY[0x270EE5960](retstr, t1, t2);
}

BOOL CGAffineTransformEqualToTransform(CGAffineTransform *t1, CGAffineTransform *t2)
{
  return MEMORY[0x270EE5970](t1, t2);
}

CGAffineTransform *__cdecl CGAffineTransformInvert(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t)
{
  return (CGAffineTransform *)MEMORY[0x270EE5978](retstr, t);
}

BOOL CGAffineTransformIsIdentity(CGAffineTransform *t)
{
  return MEMORY[0x270EE5980](t);
}

CGAffineTransform *__cdecl CGAffineTransformMakeRotation(CGAffineTransform *__return_ptr retstr, CGFloat angle)
{
  return (CGAffineTransform *)MEMORY[0x270EE5998](retstr, angle);
}

CGAffineTransform *__cdecl CGAffineTransformMakeScale(CGAffineTransform *__return_ptr retstr, CGFloat sx, CGFloat sy)
{
  return (CGAffineTransform *)MEMORY[0x270EE59A8](retstr, sx, sy);
}

CGAffineTransform *__cdecl CGAffineTransformMakeTranslation(CGAffineTransform *__return_ptr retstr, CGFloat tx, CGFloat ty)
{
  return (CGAffineTransform *)MEMORY[0x270EE59B0](retstr, tx, ty);
}

CGAffineTransform *__cdecl CGAffineTransformRotate(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t, CGFloat angle)
{
  return (CGAffineTransform *)MEMORY[0x270EE59C0](retstr, t, angle);
}

CGAffineTransform *__cdecl CGAffineTransformScale(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t, CGFloat sx, CGFloat sy)
{
  return (CGAffineTransform *)MEMORY[0x270EE59C8](retstr, t, sx, sy);
}

CGAffineTransform *__cdecl CGAffineTransformTranslate(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t, CGFloat tx, CGFloat ty)
{
  return (CGAffineTransform *)MEMORY[0x270EE59D8](retstr, t, tx, ty);
}

CGContextRef CGBitmapContextCreate(void *data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef space, uint32_t bitmapInfo)
{
  return (CGContextRef)MEMORY[0x270EE59E8](data, width, height, bitsPerComponent, bytesPerRow, space, *(void *)&bitmapInfo);
}

CGImageRef CGBitmapContextCreateImage(CGContextRef context)
{
  return (CGImageRef)MEMORY[0x270EE59F8](context);
}

CGContextRef CGBitmapContextCreateWithData(void *data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef space, uint32_t bitmapInfo, CGBitmapContextReleaseDataCallback releaseCallback, void *releaseInfo)
{
  return (CGContextRef)MEMORY[0x270EE5A10](data, width, height, bitsPerComponent, bytesPerRow, space, *(void *)&bitmapInfo, releaseCallback);
}

size_t CGBitmapContextGetBytesPerRow(CGContextRef context)
{
  return MEMORY[0x270EE5A38](context);
}

void *__cdecl CGBitmapContextGetData(CGContextRef context)
{
  return (void *)MEMORY[0x270EE5A48](context);
}

CGColorRef CGColorCreate(CGColorSpaceRef space, const CGFloat *components)
{
  return (CGColorRef)MEMORY[0x270EE5B50](space, components);
}

CGColorRef CGColorCreateCopy(CGColorRef color)
{
  return (CGColorRef)MEMORY[0x270EE5B58](color);
}

CGColorRef CGColorCreateCopyByMatchingToColorSpace(CGColorSpaceRef a1, CGColorRenderingIntent intent, CGColorRef color, CFDictionaryRef options)
{
  return (CGColorRef)MEMORY[0x270EE5B60](a1, *(void *)&intent, color, options);
}

CGColorRef CGColorCreateCopyWithAlpha(CGColorRef color, CGFloat alpha)
{
  return (CGColorRef)MEMORY[0x270EE5B68](color, alpha);
}

BOOL CGColorEqualToColor(CGColorRef color1, CGColorRef color2)
{
  return MEMORY[0x270EE5B98](color1, color2);
}

CGFloat CGColorGetAlpha(CGColorRef color)
{
  MEMORY[0x270EE5BC0](color);
  return result;
}

CGColorSpaceRef CGColorGetColorSpace(CGColorRef color)
{
  return (CGColorSpaceRef)MEMORY[0x270EE5BC8](color);
}

const CGFloat *__cdecl CGColorGetComponents(CGColorRef color)
{
  return (const CGFloat *)MEMORY[0x270EE5BD0](color);
}

CFTypeID CGColorGetTypeID(void)
{
  return MEMORY[0x270EE5BF8]();
}

void CGColorRelease(CGColorRef color)
{
}

CGColorRef CGColorRetain(CGColorRef color)
{
  return (CGColorRef)MEMORY[0x270EE5C20](color);
}

CGColorSpaceRef CGColorSpaceCreateDeviceRGB(void)
{
  return (CGColorSpaceRef)MEMORY[0x270EE5C68]();
}

CGColorSpaceRef CGColorSpaceCreateWithName(CFStringRef name)
{
  return (CGColorSpaceRef)MEMORY[0x270EE5CA8](name);
}

CGColorSpaceModel CGColorSpaceGetModel(CGColorSpaceRef space)
{
  return MEMORY[0x270EE5D08](space);
}

BOOL CGColorSpaceIsWideGamutRGB(CGColorSpaceRef a1)
{
  return MEMORY[0x270EE5D58](a1);
}

void CGColorSpaceRelease(CGColorSpaceRef space)
{
}

CGColorSpaceRef CGColorSpaceRetain(CGColorSpaceRef space)
{
  return (CGColorSpaceRef)MEMORY[0x270EE5D68](space);
}

void CGContextAddCurveToPoint(CGContextRef c, CGFloat cp1x, CGFloat cp1y, CGFloat cp2x, CGFloat cp2y, CGFloat x, CGFloat y)
{
}

void CGContextAddEllipseInRect(CGContextRef c, CGRect rect)
{
}

void CGContextAddLineToPoint(CGContextRef c, CGFloat x, CGFloat y)
{
}

void CGContextAddPath(CGContextRef c, CGPathRef path)
{
}

void CGContextAddQuadCurveToPoint(CGContextRef c, CGFloat cpx, CGFloat cpy, CGFloat x, CGFloat y)
{
}

void CGContextAddRect(CGContextRef c, CGRect rect)
{
}

void CGContextBeginPage(CGContextRef c, const CGRect *mediaBox)
{
}

void CGContextBeginPath(CGContextRef c)
{
}

void CGContextBeginTransparencyLayer(CGContextRef c, CFDictionaryRef auxiliaryInfo)
{
}

void CGContextBeginTransparencyLayerWithRect(CGContextRef c, CGRect rect, CFDictionaryRef auxInfo)
{
}

void CGContextClearRect(CGContextRef c, CGRect rect)
{
}

void CGContextClip(CGContextRef c)
{
}

void CGContextClipToMask(CGContextRef c, CGRect rect, CGImageRef mask)
{
}

void CGContextClipToRect(CGContextRef c, CGRect rect)
{
}

void CGContextClipToRects(CGContextRef c, const CGRect *rects, size_t count)
{
}

void CGContextClosePath(CGContextRef c)
{
}

void CGContextConcatCTM(CGContextRef c, CGAffineTransform *transform)
{
}

CGPoint CGContextConvertPointToDeviceSpace(CGContextRef c, CGPoint point)
{
  MEMORY[0x270EE5E78](c, (__n128)point, *(__n128 *)&point.y);
  result.CGFloat y = v3;
  result.double x = v2;
  return result;
}

CGPoint CGContextConvertPointToUserSpace(CGContextRef c, CGPoint point)
{
  MEMORY[0x270EE5E80](c, (__n128)point, *(__n128 *)&point.y);
  result.CGFloat y = v3;
  result.double x = v2;
  return result;
}

CGRect CGContextConvertRectToDeviceSpace(CGContextRef c, CGRect rect)
{
  MEMORY[0x270EE5E88](c, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  result.size.CGFloat height = v5;
  result.size.double width = v4;
  result.origin.CGFloat y = v3;
  result.origin.double x = v2;
  return result;
}

CGRect CGContextConvertRectToUserSpace(CGContextRef c, CGRect rect)
{
  MEMORY[0x270EE5E90](c, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  result.size.CGFloat height = v5;
  result.size.double width = v4;
  result.origin.CGFloat y = v3;
  result.origin.double x = v2;
  return result;
}

CGSize CGContextConvertSizeToDeviceSpace(CGContextRef c, CGSize size)
{
  MEMORY[0x270EE5E98](c, (__n128)size, *(__n128 *)&size.height);
  result.CGFloat height = v3;
  result.double width = v2;
  return result;
}

CGSize CGContextConvertSizeToUserSpace(CGContextRef c, CGSize size)
{
  MEMORY[0x270EE5EA0](c, (__n128)size, *(__n128 *)&size.height);
  result.CGFloat height = v3;
  result.double width = v2;
  return result;
}

void CGContextDrawImage(CGContextRef c, CGRect rect, CGImageRef image)
{
}

void CGContextDrawLayerInRect(CGContextRef context, CGRect rect, CGLayerRef layer)
{
}

void CGContextDrawLinearGradient(CGContextRef c, CGGradientRef gradient, CGPoint startPoint, CGPoint endPoint, CGGradientDrawingOptions options)
{
}

void CGContextDrawPDFPage(CGContextRef c, CGPDFPageRef page)
{
}

void CGContextDrawPath(CGContextRef c, CGPathDrawingMode mode)
{
}

void CGContextDrawShading(CGContextRef c, CGShadingRef shading)
{
}

void CGContextDrawTiledImage(CGContextRef c, CGRect rect, CGImageRef image)
{
}

void CGContextEOClip(CGContextRef c)
{
}

void CGContextEOFillPath(CGContextRef c)
{
}

void CGContextEndPage(CGContextRef c)
{
}

void CGContextEndTransparencyLayer(CGContextRef c)
{
}

void CGContextFillEllipseInRect(CGContextRef c, CGRect rect)
{
}

void CGContextFillPath(CGContextRef c)
{
}

void CGContextFillRect(CGContextRef c, CGRect rect)
{
}

void CGContextFlush(CGContextRef c)
{
}

CGAffineTransform *__cdecl CGContextGetCTM(CGAffineTransform *__return_ptr retstr, CGContextRef c)
{
  return (CGAffineTransform *)MEMORY[0x270EE5FC0](retstr, c);
}

CGRect CGContextGetClipBoundingBox(CGContextRef c)
{
  MEMORY[0x270EE5FC8](c);
  result.size.CGFloat height = v4;
  result.size.double width = v3;
  result.origin.CGFloat y = v2;
  result.origin.double x = v1;
  return result;
}

CGAffineTransform *__cdecl CGContextGetUserSpaceToDeviceSpaceTransform(CGAffineTransform *__return_ptr retstr, CGContextRef c)
{
  return (CGAffineTransform *)MEMORY[0x270EE6040](retstr, c);
}

void CGContextMoveToPoint(CGContextRef c, CGFloat x, CGFloat y)
{
}

void CGContextRelease(CGContextRef c)
{
}

void CGContextReplacePathWithStrokedPath(CGContextRef c)
{
}

void CGContextRestoreGState(CGContextRef c)
{
}

CGContextRef CGContextRetain(CGContextRef c)
{
  return (CGContextRef)MEMORY[0x270EE6088](c);
}

void CGContextRotateCTM(CGContextRef c, CGFloat angle)
{
}

void CGContextSaveGState(CGContextRef c)
{
}

void CGContextScaleCTM(CGContextRef c, CGFloat sx, CGFloat sy)
{
}

void CGContextSetAllowsFontSmoothing(CGContextRef c, BOOL allowsFontSmoothing)
{
}

void CGContextSetAllowsFontSubpixelQuantization(CGContextRef c, BOOL allowsFontSubpixelQuantization)
{
}

void CGContextSetAlpha(CGContextRef c, CGFloat alpha)
{
}

void CGContextSetBlendMode(CGContextRef c, CGBlendMode mode)
{
}

void CGContextSetFillColorWithColor(CGContextRef c, CGColorRef color)
{
}

void CGContextSetFlatness(CGContextRef c, CGFloat flatness)
{
}

void CGContextSetGrayFillColor(CGContextRef c, CGFloat gray, CGFloat alpha)
{
}

void CGContextSetInterpolationQuality(CGContextRef c, CGInterpolationQuality quality)
{
}

void CGContextSetLineCap(CGContextRef c, CGLineCap cap)
{
}

void CGContextSetLineDash(CGContextRef c, CGFloat phase, const CGFloat *lengths, size_t count)
{
}

void CGContextSetLineJoin(CGContextRef c, CGLineJoin join)
{
}

void CGContextSetLineWidth(CGContextRef c, CGFloat width)
{
}

void CGContextSetMiterLimit(CGContextRef c, CGFloat limit)
{
}

void CGContextSetRGBFillColor(CGContextRef c, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha)
{
}

void CGContextSetRGBStrokeColor(CGContextRef c, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha)
{
}

void CGContextSetShadow(CGContextRef c, CGSize offset, CGFloat blur)
{
}

void CGContextSetShadowWithColor(CGContextRef c, CGSize offset, CGFloat blur, CGColorRef color)
{
}

void CGContextSetShouldAntialias(CGContextRef c, BOOL shouldAntialias)
{
}

void CGContextSetShouldSmoothFonts(CGContextRef c, BOOL shouldSmoothFonts)
{
}

void CGContextSetShouldSubpixelQuantizeFonts(CGContextRef c, BOOL shouldSubpixelQuantizeFonts)
{
}

void CGContextSetStrokeColorWithColor(CGContextRef c, CGColorRef color)
{
}

void CGContextSetTextDrawingMode(CGContextRef c, CGTextDrawingMode mode)
{
}

void CGContextSetTextMatrix(CGContextRef c, CGAffineTransform *t)
{
}

void CGContextSetTextPosition(CGContextRef c, CGFloat x, CGFloat y)
{
}

void CGContextStrokePath(CGContextRef c)
{
}

void CGContextStrokeRect(CGContextRef c, CGRect rect)
{
}

void CGContextStrokeRectWithWidth(CGContextRef c, CGRect rect, CGFloat width)
{
}

void CGContextTranslateCTM(CGContextRef c, CGFloat tx, CGFloat ty)
{
}

CGDataConsumerRef CGDataConsumerCreateWithCFData(CFMutableDataRef data)
{
  return (CGDataConsumerRef)MEMORY[0x270EE6298](data);
}

void CGDataConsumerRelease(CGDataConsumerRef consumer)
{
}

CGDataProviderRef CGDataProviderCreateSequential(void *info, const CGDataProviderSequentialCallbacks *callbacks)
{
  return (CGDataProviderRef)MEMORY[0x270EE62C8](info, callbacks);
}

CGDataProviderRef CGDataProviderCreateWithCFData(CFDataRef data)
{
  return (CGDataProviderRef)MEMORY[0x270EE62D0](data);
}

CGDataProviderRef CGDataProviderCreateWithData(void *info, const void *data, size_t size, CGDataProviderReleaseDataCallback releaseData)
{
  return (CGDataProviderRef)MEMORY[0x270EE62E0](info, data, size, releaseData);
}

CGDataProviderRef CGDataProviderCreateWithFilename(const char *filename)
{
  return (CGDataProviderRef)MEMORY[0x270EE62E8](filename);
}

CGDataProviderRef CGDataProviderCreateWithURL(CFURLRef url)
{
  return (CGDataProviderRef)MEMORY[0x270EE62F0](url);
}

void CGDataProviderRelease(CGDataProviderRef provider)
{
}

CGFontRef CGFontCreateWithDataProvider(CGDataProviderRef provider)
{
  return (CGFontRef)MEMORY[0x270EE6430](provider);
}

int CGFontGetAscent(CGFontRef font)
{
  return MEMORY[0x270EE6440](font);
}

int CGFontGetDescent(CGFontRef font)
{
  return MEMORY[0x270EE6450](font);
}

BOOL CGFontGetGlyphAdvances(CGFontRef font, const CGGlyph *glyphs, size_t count, int *advances)
{
  return MEMORY[0x270EE6468](font, glyphs, count, advances);
}

int CGFontGetUnitsPerEm(CGFontRef font)
{
  return MEMORY[0x270EE64B0](font);
}

void CGFontRelease(CGFontRef font)
{
}

CGFontRef CGFontRetain(CGFontRef font)
{
  return (CGFontRef)MEMORY[0x270EE6528](font);
}

CGFunctionRef CGFunctionCreate(void *info, size_t domainDimension, const CGFloat *domain, size_t rangeDimension, const CGFloat *range, const CGFunctionCallbacks *callbacks)
{
  return (CGFunctionRef)MEMORY[0x270EE6530](info, domainDimension, domain, rangeDimension, range, callbacks);
}

void CGFunctionRelease(CGFunctionRef function)
{
}

CGGradientRef CGGradientCreateWithColors(CGColorSpaceRef space, CFArrayRef colors, const CGFloat *locations)
{
  return (CGGradientRef)MEMORY[0x270EE6690](space, colors, locations);
}

void CGGradientRelease(CGGradientRef gradient)
{
}

CGImageRef CGImageCreate(size_t width, size_t height, size_t bitsPerComponent, size_t bitsPerPixel, size_t bytesPerRow, CGColorSpaceRef space, CGBitmapInfo bitmapInfo, CGDataProviderRef provider, const CGFloat *decode, BOOL shouldInterpolate, CGColorRenderingIntent intent)
{
  return (CGImageRef)MEMORY[0x270EE6738](width, height, bitsPerComponent, bitsPerPixel, bytesPerRow, space, *(void *)&bitmapInfo, provider);
}

CGImageRef CGImageCreateCopy(CGImageRef image)
{
  return (CGImageRef)MEMORY[0x270EE6740](image);
}

void CGImageDestinationAddImage(CGImageDestinationRef idst, CGImageRef image, CFDictionaryRef properties)
{
}

CGImageDestinationRef CGImageDestinationCreateWithData(CFMutableDataRef data, CFStringRef type, size_t count, CFDictionaryRef options)
{
  return (CGImageDestinationRef)MEMORY[0x270EF4F20](data, type, count, options);
}

CGImageDestinationRef CGImageDestinationCreateWithURL(CFURLRef url, CFStringRef type, size_t count, CFDictionaryRef options)
{
  return (CGImageDestinationRef)MEMORY[0x270EF4F38](url, type, count, options);
}

BOOL CGImageDestinationFinalize(CGImageDestinationRef idst)
{
  return MEMORY[0x270EF4F48](idst);
}

void CGImageDestinationSetProperties(CGImageDestinationRef idst, CFDictionaryRef properties)
{
}

CGImageAlphaInfo CGImageGetAlphaInfo(CGImageRef image)
{
  return MEMORY[0x270EE6778](image);
}

size_t CGImageGetBitsPerComponent(CGImageRef image)
{
  return MEMORY[0x270EE6790](image);
}

size_t CGImageGetBitsPerPixel(CGImageRef image)
{
  return MEMORY[0x270EE67A0](image);
}

size_t CGImageGetBytesPerRow(CGImageRef image)
{
  return MEMORY[0x270EE67C0](image);
}

CGColorSpaceRef CGImageGetColorSpace(CGImageRef image)
{
  return (CGColorSpaceRef)MEMORY[0x270EE67D8](image);
}

CGDataProviderRef CGImageGetDataProvider(CGImageRef image)
{
  return (CGDataProviderRef)MEMORY[0x270EE67E8](image);
}

size_t CGImageGetHeight(CGImageRef image)
{
  return MEMORY[0x270EE6800](image);
}

BOOL CGImageGetShouldInterpolate(CGImageRef image)
{
  return MEMORY[0x270EE6848](image);
}

size_t CGImageGetWidth(CGImageRef image)
{
  return MEMORY[0x270EE6868](image);
}

CGImageRef CGImageMaskCreate(size_t width, size_t height, size_t bitsPerComponent, size_t bitsPerPixel, size_t bytesPerRow, CGDataProviderRef provider, const CGFloat *decode, BOOL shouldInterpolate)
{
  return (CGImageRef)MEMORY[0x270EE6888](width, height, bitsPerComponent, bitsPerPixel, bytesPerRow, provider, decode, shouldInterpolate);
}

void CGImageRelease(CGImageRef image)
{
}

CGImageRef CGImageRetain(CGImageRef image)
{
  return (CGImageRef)MEMORY[0x270EE6908](image);
}

CFDictionaryRef CGImageSourceCopyPropertiesAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  return (CFDictionaryRef)MEMORY[0x270EF5000](isrc, index, options);
}

CGImageRef CGImageSourceCreateImageAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  return (CGImageRef)MEMORY[0x270EF5018](isrc, index, options);
}

CGImageRef CGImageSourceCreateThumbnailAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  return (CGImageRef)MEMORY[0x270EF5028](isrc, index, options);
}

CGImageSourceRef CGImageSourceCreateWithData(CFDataRef data, CFDictionaryRef options)
{
  return (CGImageSourceRef)MEMORY[0x270EF5030](data, options);
}

CGImageSourceRef CGImageSourceCreateWithDataProvider(CGDataProviderRef provider, CFDictionaryRef options)
{
  return (CGImageSourceRef)MEMORY[0x270EF5038](provider, options);
}

CGImageSourceRef CGImageSourceCreateWithURL(CFURLRef url, CFDictionaryRef options)
{
  return (CGImageSourceRef)MEMORY[0x270EF5040](url, options);
}

CGImageSourceStatus CGImageSourceGetStatus(CGImageSourceRef isrc)
{
  return MEMORY[0x270EF5058](isrc);
}

CFStringRef CGImageSourceGetType(CGImageSourceRef isrc)
{
  return (CFStringRef)MEMORY[0x270EF5068](isrc);
}

CGLayerRef CGLayerCreateWithContext(CGContextRef context, CGSize size, CFDictionaryRef auxiliaryInfo)
{
  return (CGLayerRef)MEMORY[0x270EE6960](context, auxiliaryInfo, (__n128)size, *(__n128 *)&size.height);
}

CGContextRef CGLayerGetContext(CGLayerRef layer)
{
  return (CGContextRef)MEMORY[0x270EE6968](layer);
}

void CGLayerRelease(CGLayerRef layer)
{
}

void CGPDFContextClose(CGContextRef context)
{
}

CGContextRef CGPDFContextCreate(CGDataConsumerRef consumer, const CGRect *mediaBox, CFDictionaryRef auxiliaryInfo)
{
  return (CGContextRef)MEMORY[0x270EE6A80](consumer, mediaBox, auxiliaryInfo);
}

CGPDFDocumentRef CGPDFDocumentCreateWithProvider(CGDataProviderRef provider)
{
  return (CGPDFDocumentRef)MEMORY[0x270EE6B90](provider);
}

CGPDFPageRef CGPDFDocumentGetPage(CGPDFDocumentRef document, size_t pageNumber)
{
  return (CGPDFPageRef)MEMORY[0x270EE6C00](document, pageNumber);
}

void CGPDFDocumentRelease(CGPDFDocumentRef document)
{
}

CGRect CGPDFPageGetBoxRect(CGPDFPageRef page, CGPDFBox box)
{
  MEMORY[0x270EE6D80](page, *(void *)&box);
  result.size.CGFloat height = v5;
  result.size.double width = v4;
  result.origin.CGFloat y = v3;
  result.origin.double x = v2;
  return result;
}

int CGPDFPageGetRotationAngle(CGPDFPageRef page)
{
  return MEMORY[0x270EE6DA8](page);
}

void CGPathAddArc(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x, CGFloat y, CGFloat radius, CGFloat startAngle, CGFloat endAngle, BOOL clockwise)
{
}

void CGPathAddArcToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x1, CGFloat y1, CGFloat x2, CGFloat y2, CGFloat radius)
{
}

void CGPathAddCurveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat cp1x, CGFloat cp1y, CGFloat cp2x, CGFloat cp2y, CGFloat x, CGFloat y)
{
}

void CGPathAddEllipseInRect(CGMutablePathRef path, const CGAffineTransform *m, CGRect rect)
{
}

void CGPathAddLineToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x, CGFloat y)
{
}

void CGPathAddPath(CGMutablePathRef path1, const CGAffineTransform *m, CGPathRef path2)
{
}

void CGPathAddQuadCurveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat cpx, CGFloat cpy, CGFloat x, CGFloat y)
{
}

void CGPathAddRect(CGMutablePathRef path, const CGAffineTransform *m, CGRect rect)
{
}

void CGPathApply(CGPathRef path, void *info, CGPathApplierFunction function)
{
}

void CGPathCloseSubpath(CGMutablePathRef path)
{
}

BOOL CGPathContainsPoint(CGPathRef path, const CGAffineTransform *m, CGPoint point, BOOL eoFill)
{
  return MEMORY[0x270EE6FD0](path, m, eoFill, (__n128)point, *(__n128 *)&point.y);
}

CGPathRef CGPathCreateCopy(CGPathRef path)
{
  return (CGPathRef)MEMORY[0x270EE6FD8](path);
}

CGPathRef CGPathCreateCopyByStrokingPath(CGPathRef path, const CGAffineTransform *transform, CGFloat lineWidth, CGLineCap lineCap, CGLineJoin lineJoin, CGFloat miterLimit)
{
  return (CGPathRef)MEMORY[0x270EE6FF0](path, transform, *(void *)&lineCap, *(void *)&lineJoin, lineWidth, miterLimit);
}

CGPathRef CGPathCreateCopyByTransformingPath(CGPathRef path, const CGAffineTransform *transform)
{
  return (CGPathRef)MEMORY[0x270EE7008](path, transform);
}

CGMutablePathRef CGPathCreateMutable(void)
{
  return (CGMutablePathRef)MEMORY[0x270EE7030]();
}

CGMutablePathRef CGPathCreateMutableCopy(CGPathRef path)
{
  return (CGMutablePathRef)MEMORY[0x270EE7038](path);
}

CGPathRef CGPathCreateWithRect(CGRect rect, const CGAffineTransform *transform)
{
  return (CGPathRef)MEMORY[0x270EE7058](transform, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

BOOL CGPathEqualToPath(CGPathRef path1, CGPathRef path2)
{
  return MEMORY[0x270EE7068](path1, path2);
}

CGRect CGPathGetBoundingBox(CGPathRef path)
{
  MEMORY[0x270EE7070](path);
  result.size.CGFloat height = v4;
  result.size.double width = v3;
  result.origin.CGFloat y = v2;
  result.origin.double x = v1;
  return result;
}

CGPoint CGPathGetCurrentPoint(CGPathRef path)
{
  MEMORY[0x270EE7078](path);
  result.CGFloat y = v2;
  result.double x = v1;
  return result;
}

CGRect CGPathGetPathBoundingBox(CGPathRef path)
{
  MEMORY[0x270EE7090](path);
  result.size.CGFloat height = v4;
  result.size.double width = v3;
  result.origin.CGFloat y = v2;
  result.origin.double x = v1;
  return result;
}

BOOL CGPathIsEmpty(CGPathRef path)
{
  return MEMORY[0x270EE70C8](path);
}

void CGPathMoveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x, CGFloat y)
{
}

void CGPathRelease(CGPathRef path)
{
}

CGPathRef CGPathRetain(CGPathRef path)
{
  return (CGPathRef)MEMORY[0x270EE7108](path);
}

CGRect CGRectApplyAffineTransform(CGRect rect, CGAffineTransform *t)
{
  MEMORY[0x270EE7168](t, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  result.size.CGFloat height = v5;
  result.size.double width = v4;
  result.origin.CGFloat y = v3;
  result.origin.double x = v2;
  return result;
}

BOOL CGRectContainsPoint(CGRect rect, CGPoint point)
{
  return MEMORY[0x270EE7170]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height, (__n128)point, *(__n128 *)&point.y);
}

BOOL CGRectContainsRect(CGRect rect1, CGRect rect2)
{
  return MEMORY[0x270EE7180]((__n128)rect1.origin, *(__n128 *)&rect1.origin.y, (__n128)rect1.size, *(__n128 *)&rect1.size.height, (__n128)rect2.origin, *(__n128 *)&rect2.origin.y, (__n128)rect2.size, *(__n128 *)&rect2.size.height);
}

void CGRectDivide(CGRect rect, CGRect *slice, CGRect *remainder, CGFloat amount, CGRectEdge edge)
{
}

BOOL CGRectEqualToRect(CGRect rect1, CGRect rect2)
{
  return MEMORY[0x270EE71A0]((__n128)rect1.origin, *(__n128 *)&rect1.origin.y, (__n128)rect1.size, *(__n128 *)&rect1.size.height, (__n128)rect2.origin, *(__n128 *)&rect2.origin.y, (__n128)rect2.size, *(__n128 *)&rect2.size.height);
}

CGFloat CGRectGetHeight(CGRect rect)
{
  MEMORY[0x270EE71A8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMaxX(CGRect rect)
{
  MEMORY[0x270EE71C0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMaxY(CGRect rect)
{
  MEMORY[0x270EE71D0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMidX(CGRect rect)
{
  MEMORY[0x270EE71D8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMidY(CGRect rect)
{
  MEMORY[0x270EE71F0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMinX(CGRect rect)
{
  MEMORY[0x270EE71F8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMinY(CGRect rect)
{
  MEMORY[0x270EE7210]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetWidth(CGRect rect)
{
  MEMORY[0x270EE7218]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGRect CGRectInset(CGRect rect, CGFloat dx, CGFloat dy)
{
  MEMORY[0x270EE7228]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height, dx, dy);
  result.size.CGFloat height = v6;
  result.size.double width = v5;
  result.origin.CGFloat y = v4;
  result.origin.double x = v3;
  return result;
}

CGRect CGRectIntegral(CGRect rect)
{
  MEMORY[0x270EE7230]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  result.size.CGFloat height = v4;
  result.size.double width = v3;
  result.origin.CGFloat y = v2;
  result.origin.double x = v1;
  return result;
}

CGRect CGRectIntersection(CGRect r1, CGRect r2)
{
  MEMORY[0x270EE7238]((__n128)r1.origin, *(__n128 *)&r1.origin.y, (__n128)r1.size, *(__n128 *)&r1.size.height, (__n128)r2.origin, *(__n128 *)&r2.origin.y, (__n128)r2.size, *(__n128 *)&r2.size.height);
  result.size.CGFloat height = v5;
  result.size.double width = v4;
  result.origin.CGFloat y = v3;
  result.origin.double x = v2;
  return result;
}

BOOL CGRectIntersectsRect(CGRect rect1, CGRect rect2)
{
  return MEMORY[0x270EE7250]((__n128)rect1.origin, *(__n128 *)&rect1.origin.y, (__n128)rect1.size, *(__n128 *)&rect1.size.height, (__n128)rect2.origin, *(__n128 *)&rect2.origin.y, (__n128)rect2.size, *(__n128 *)&rect2.size.height);
}

BOOL CGRectIsEmpty(CGRect rect)
{
  return MEMORY[0x270EE7260]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

BOOL CGRectIsInfinite(CGRect rect)
{
  return MEMORY[0x270EE7268]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

BOOL CGRectIsNull(CGRect rect)
{
  return MEMORY[0x270EE7270]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

CGRect CGRectOffset(CGRect rect, CGFloat dx, CGFloat dy)
{
  MEMORY[0x270EE7280]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height, dx, dy);
  result.size.CGFloat height = v6;
  result.size.double width = v5;
  result.origin.CGFloat y = v4;
  result.origin.double x = v3;
  return result;
}

CGRect CGRectStandardize(CGRect rect)
{
  MEMORY[0x270EE7288]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  result.size.CGFloat height = v4;
  result.size.double width = v3;
  result.origin.CGFloat y = v2;
  result.origin.double x = v1;
  return result;
}

CGRect CGRectUnion(CGRect r1, CGRect r2)
{
  MEMORY[0x270EE7290]((__n128)r1.origin, *(__n128 *)&r1.origin.y, (__n128)r1.size, *(__n128 *)&r1.size.height, (__n128)r2.origin, *(__n128 *)&r2.origin.y, (__n128)r2.size, *(__n128 *)&r2.size.height);
  result.size.CGFloat height = v5;
  result.size.double width = v4;
  result.origin.CGFloat y = v3;
  result.origin.double x = v2;
  return result;
}

CGShadingRef CGShadingCreateAxial(CGColorSpaceRef space, CGPoint start, CGPoint end, CGFunctionRef function, BOOL extendStart, BOOL extendEnd)
{
  return (CGShadingRef)MEMORY[0x270EE72E8](space, function, extendStart, extendEnd, (__n128)start, *(__n128 *)&start.y, (__n128)end, *(__n128 *)&end.y);
}

CGShadingRef CGShadingCreateRadial(CGColorSpaceRef space, CGPoint start, CGFloat startRadius, CGPoint end, CGFloat endRadius, CGFunctionRef function, BOOL extendStart, BOOL extendEnd)
{
  return (CGShadingRef)MEMORY[0x270EE72F0](space, function, extendStart, extendEnd, (__n128)start, *(__n128 *)&start.y, startRadius, (__n128)end, *(__n128 *)&end.y, endRadius);
}

void CGShadingRelease(CGShadingRef shading)
{
}

CGShadingRef CGShadingRetain(CGShadingRef shading)
{
  return (CGShadingRef)MEMORY[0x270EE7328](shading);
}

const AudioStreamBasicDescription *__cdecl CMAudioFormatDescriptionGetStreamBasicDescription(CMAudioFormatDescriptionRef desc)
{
  return (const AudioStreamBasicDescription *)MEMORY[0x270EE7998](desc);
}

CFPropertyListRef CMFormatDescriptionGetExtension(CMFormatDescriptionRef desc, CFStringRef extensionKey)
{
  return (CFPropertyListRef)MEMORY[0x270EE7AF0](desc, extensionKey);
}

FourCharCode CMFormatDescriptionGetMediaSubType(CMFormatDescriptionRef desc)
{
  return MEMORY[0x270EE7B10](desc);
}

CMTime *__cdecl CMTimeClampToRange(CMTime *__return_ptr retstr, CMTime *time, CMTimeRange *range)
{
  return (CMTime *)MEMORY[0x270EE7DA8](retstr, time, range);
}

int32_t CMTimeCompare(CMTime *time1, CMTime *time2)
{
  return MEMORY[0x270EE7DD0](time1, time2);
}

Float64 CMTimeGetSeconds(CMTime *time)
{
  MEMORY[0x270EE7E08](time);
  return result;
}

CMTime *__cdecl CMTimeMakeWithSeconds(CMTime *__return_ptr retstr, Float64 seconds, int32_t preferredTimescale)
{
  return (CMTime *)MEMORY[0x270EE7E38](retstr, *(void *)&preferredTimescale, seconds);
}

CMTimeRange *__cdecl CMTimeRangeMake(CMTimeRange *__return_ptr retstr, CMTime *start, CMTime *duration)
{
  return (CMTimeRange *)MEMORY[0x270EE7EF8](retstr, start, duration);
}

CMVideoDimensions CMVideoFormatDescriptionGetDimensions(CMVideoFormatDescriptionRef videoDesc)
{
  return (CMVideoDimensions)MEMORY[0x270EE7FD0](videoDesc);
}

CTFontCollectionRef CTFontCollectionCreateFromAvailableFonts(CFDictionaryRef options)
{
  return (CTFontCollectionRef)MEMORY[0x270EE99F8](options);
}

CFArrayRef CTFontCollectionCreateMatchingFontDescriptors(CTFontCollectionRef collection)
{
  return (CFArrayRef)MEMORY[0x270EE9A00](collection);
}

CFCharacterSetRef CTFontCopyCharacterSet(CTFontRef font)
{
  return (CFCharacterSetRef)MEMORY[0x270EE9A10](font);
}

CFStringRef CTFontCopyFamilyName(CTFontRef font)
{
  return (CFStringRef)MEMORY[0x270EE9A28](font);
}

CFArrayRef CTFontCopyFeatures(CTFontRef font)
{
  return (CFArrayRef)MEMORY[0x270EE9A38](font);
}

CTFontDescriptorRef CTFontCopyFontDescriptor(CTFontRef font)
{
  return (CTFontDescriptorRef)MEMORY[0x270EE9A40](font);
}

CFStringRef CTFontCopyFullName(CTFontRef font)
{
  return (CFStringRef)MEMORY[0x270EE9A48](font);
}

CGFontRef CTFontCopyGraphicsFont(CTFontRef font, CTFontDescriptorRef *attributes)
{
  return (CGFontRef)MEMORY[0x270EE9A50](font, attributes);
}

CFStringRef CTFontCopyPostScriptName(CTFontRef font)
{
  return (CFStringRef)MEMORY[0x270EE9A78](font);
}

CTFontRef CTFontCreateCopyWithAttributes(CTFontRef font, CGFloat size, const CGAffineTransform *matrix, CTFontDescriptorRef attributes)
{
  return (CTFontRef)MEMORY[0x270EE9AB8](font, matrix, attributes, size);
}

CTFontRef CTFontCreateCopyWithSymbolicTraits(CTFontRef font, CGFloat size, const CGAffineTransform *matrix, CTFontSymbolicTraits symTraitValue, CTFontSymbolicTraits symTraitMask)
{
  return (CTFontRef)MEMORY[0x270EE9AC0](font, matrix, *(void *)&symTraitValue, *(void *)&symTraitMask, size);
}

CTFontRef CTFontCreateForString(CTFontRef currentFont, CFStringRef string, CFRange range)
{
  return (CTFontRef)MEMORY[0x270EE9AC8](currentFont, string, range.location, range.length);
}

CGPathRef CTFontCreatePathForGlyph(CTFontRef font, CGGlyph glyph, const CGAffineTransform *matrix)
{
  return (CGPathRef)MEMORY[0x270EE9AD0](font, glyph, matrix);
}

CTFontRef CTFontCreateUIFontForLanguage(CTFontUIFontType uiType, CGFloat size, CFStringRef language)
{
  return (CTFontRef)MEMORY[0x270EE9AD8](*(void *)&uiType, language, size);
}

CTFontRef CTFontCreateWithFontDescriptor(CTFontDescriptorRef descriptor, CGFloat size, const CGAffineTransform *matrix)
{
  return (CTFontRef)MEMORY[0x270EE9AE0](descriptor, matrix, size);
}

CTFontRef CTFontCreateWithGraphicsFont(CGFontRef graphicsFont, CGFloat size, const CGAffineTransform *matrix, CTFontDescriptorRef attributes)
{
  return (CTFontRef)MEMORY[0x270EE9AF0](graphicsFont, matrix, attributes, size);
}

CTFontRef CTFontCreateWithName(CFStringRef name, CGFloat size, const CGAffineTransform *matrix)
{
  return (CTFontRef)MEMORY[0x270EE9AF8](name, matrix, size);
}

CFTypeRef CTFontDescriptorCopyAttribute(CTFontDescriptorRef descriptor, CFStringRef attribute)
{
  return (CFTypeRef)MEMORY[0x270EE9B08](descriptor, attribute);
}

CFTypeRef CTFontDescriptorCopyLocalizedAttribute(CTFontDescriptorRef descriptor, CFStringRef attribute, CFStringRef *language)
{
  return (CFTypeRef)MEMORY[0x270EE9B18](descriptor, attribute, language);
}

CTFontDescriptorRef CTFontDescriptorCreateCopyWithAttributes(CTFontDescriptorRef original, CFDictionaryRef attributes)
{
  return (CTFontDescriptorRef)MEMORY[0x270EE9B20](original, attributes);
}

CFArrayRef CTFontDescriptorCreateMatchingFontDescriptors(CTFontDescriptorRef descriptor, CFSetRef mandatoryAttributes)
{
  return (CFArrayRef)MEMORY[0x270EE9B50](descriptor, mandatoryAttributes);
}

CTFontDescriptorRef CTFontDescriptorCreateWithAttributes(CFDictionaryRef attributes)
{
  return (CTFontDescriptorRef)MEMORY[0x270EE9B60](attributes);
}

CTFontDescriptorRef CTFontDescriptorCreateWithNameAndSize(CFStringRef name, CGFloat size)
{
  return (CTFontDescriptorRef)MEMORY[0x270EE9B70](name, size);
}

BOOL CTFontDescriptorMatchFontDescriptorsWithProgressHandler(CFArrayRef descriptors, CFSetRef mandatoryAttributes, CTFontDescriptorProgressHandler progressBlock)
{
  return MEMORY[0x270EE9BC8](descriptors, mandatoryAttributes, progressBlock);
}

void CTFontDrawGlyphs(CTFontRef font, const CGGlyph *glyphs, const CGPoint *positions, size_t count, CGContextRef context)
{
}

double CTFontGetAdvancesForGlyphs(CTFontRef font, CTFontOrientation orientation, const CGGlyph *glyphs, CGSize *advances, CFIndex count)
{
  MEMORY[0x270EE9BE0](font, *(void *)&orientation, glyphs, advances, count);
  return result;
}

CGFloat CTFontGetAscent(CTFontRef font)
{
  MEMORY[0x270EE9BE8](font);
  return result;
}

CGRect CTFontGetBoundingBox(CTFontRef font)
{
  MEMORY[0x270EE9BF0](font);
  result.size.CGFloat height = v4;
  result.size.double width = v3;
  result.origin.CGFloat y = v2;
  result.origin.double x = v1;
  return result;
}

CGRect CTFontGetBoundingRectsForGlyphs(CTFontRef font, CTFontOrientation orientation, const CGGlyph *glyphs, CGRect *boundingRects, CFIndex count)
{
  MEMORY[0x270EE9BF8](font, *(void *)&orientation, glyphs, boundingRects, count);
  result.size.CGFloat height = v8;
  result.size.double width = v7;
  result.origin.CGFloat y = v6;
  result.origin.double x = v5;
  return result;
}

CGFloat CTFontGetCapHeight(CTFontRef font)
{
  MEMORY[0x270EE9C00](font);
  return result;
}

CGFloat CTFontGetDescent(CTFontRef font)
{
  MEMORY[0x270EE9C10](font);
  return result;
}

BOOL CTFontGetGlyphsForCharacters(CTFontRef font, const UniChar *characters, CGGlyph *glyphs, CFIndex count)
{
  return MEMORY[0x270EE9C28](font, characters, glyphs, count);
}

CGFloat CTFontGetLeading(CTFontRef font)
{
  MEMORY[0x270EE9C38](font);
  return result;
}

CGFloat CTFontGetSize(CTFontRef font)
{
  MEMORY[0x270EE9C40](font);
  return result;
}

CGFloat CTFontGetSlantAngle(CTFontRef font)
{
  MEMORY[0x270EE9C50](font);
  return result;
}

CFStringEncoding CTFontGetStringEncoding(CTFontRef font)
{
  return MEMORY[0x270EE9C58](font);
}

CTFontSymbolicTraits CTFontGetSymbolicTraits(CTFontRef font)
{
  return MEMORY[0x270EE9C60](font);
}

CFTypeID CTFontGetTypeID(void)
{
  return MEMORY[0x270EE9C70]();
}

CGFloat CTFontGetUnderlinePosition(CTFontRef font)
{
  MEMORY[0x270EE9C78](font);
  return result;
}

CGFloat CTFontGetUnderlineThickness(CTFontRef font)
{
  MEMORY[0x270EE9C80](font);
  return result;
}

void CTFontGetVerticalTranslationsForGlyphs(CTFontRef font, const CGGlyph *glyphs, CGSize *translations, CFIndex count)
{
}

CGFloat CTFontGetXHeight(CTFontRef font)
{
  MEMORY[0x270EE9CA0](font);
  return result;
}

BOOL CTFontManagerRegisterGraphicsFont(CGFontRef font, CFErrorRef *error)
{
  return MEMORY[0x270EE9CE0](font, error);
}

BOOL CTFontManagerUnregisterGraphicsFont(CGFontRef font, CFErrorRef *error)
{
  return MEMORY[0x270EE9CF0](font, error);
}

CTLineRef CTLineCreateJustifiedLine(CTLineRef line, CGFloat justificationFactor, double justificationWidth)
{
  return (CTLineRef)MEMORY[0x270EE9D60](line, justificationFactor, justificationWidth);
}

CTLineRef CTLineCreateTruncatedLine(CTLineRef line, double width, CTLineTruncationType truncationType, CTLineRef truncationToken)
{
  return (CTLineRef)MEMORY[0x270EE9D68](line, *(void *)&truncationType, truncationToken, width);
}

CTLineRef CTLineCreateWithAttributedString(CFAttributedStringRef attrString)
{
  return (CTLineRef)MEMORY[0x270EE9D70](attrString);
}

void CTLineDraw(CTLineRef line, CGContextRef context)
{
}

CGRect CTLineGetBoundsWithOptions(CTLineRef line, CTLineBoundsOptions options)
{
  MEMORY[0x270EE9DB0](line, options);
  result.size.CGFloat height = v5;
  result.size.double width = v4;
  result.origin.CGFloat y = v3;
  result.origin.double x = v2;
  return result;
}

CFIndex CTLineGetGlyphCount(CTLineRef line)
{
  return MEMORY[0x270EE9DB8](line);
}

CFArrayRef CTLineGetGlyphRuns(CTLineRef line)
{
  return (CFArrayRef)MEMORY[0x270EE9DC0](line);
}

CGRect CTLineGetImageBounds(CTLineRef line, CGContextRef context)
{
  MEMORY[0x270EE9DC8](line, context);
  result.size.CGFloat height = v5;
  result.size.double width = v4;
  result.origin.CGFloat y = v3;
  result.origin.double x = v2;
  return result;
}

CGFloat CTLineGetOffsetForStringIndex(CTLineRef line, CFIndex charIndex, CGFloat *secondaryOffset)
{
  MEMORY[0x270EE9DD0](line, charIndex, secondaryOffset);
  return result;
}

double CTLineGetPenOffsetForFlush(CTLineRef line, CGFloat flushFactor, double flushWidth)
{
  MEMORY[0x270EE9DD8](line, flushFactor, flushWidth);
  return result;
}

CFIndex CTLineGetStringIndexForPosition(CTLineRef line, CGPoint position)
{
  return MEMORY[0x270EE9DE8](line, (__n128)position, *(__n128 *)&position.y);
}

CFRange CTLineGetStringRange(CTLineRef line)
{
  CFIndex v1 = MEMORY[0x270EE9DF0](line);
  result.length = v2;
  result.location = v1;
  return result;
}

double CTLineGetTrailingWhitespaceWidth(CTLineRef line)
{
  MEMORY[0x270EE9DF8](line);
  return result;
}

double CTLineGetTypographicBounds(CTLineRef line, CGFloat *ascent, CGFloat *descent, CGFloat *leading)
{
  MEMORY[0x270EE9E00](line, ascent, descent, leading);
  return result;
}

CTParagraphStyleRef CTParagraphStyleCreate(const CTParagraphStyleSetting *settings, size_t settingCount)
{
  return (CTParagraphStyleRef)MEMORY[0x270EE9E18](settings, settingCount);
}

CTRunDelegateRef CTRunDelegateCreate(const CTRunDelegateCallbacks *callbacks, void *refCon)
{
  return (CTRunDelegateRef)MEMORY[0x270EE9E30](callbacks, refCon);
}

void CTRunDraw(CTRunRef run, CGContextRef context, CFRange range)
{
}

void CTRunGetAdvances(CTRunRef run, CFRange range, CGSize *buffer)
{
}

CFDictionaryRef CTRunGetAttributes(CTRunRef run)
{
  return (CFDictionaryRef)MEMORY[0x270EE9E50](run);
}

CFIndex CTRunGetGlyphCount(CTRunRef run)
{
  return MEMORY[0x270EE9E68](run);
}

void CTRunGetGlyphs(CTRunRef run, CFRange range, CGGlyph *buffer)
{
}

CGRect CTRunGetImageBounds(CTRunRef run, CGContextRef context, CFRange range)
{
  MEMORY[0x270EE9E80](run, context, range.location, range.length);
  result.size.CGFloat height = v6;
  result.size.double width = v5;
  result.origin.CGFloat y = v4;
  result.origin.double x = v3;
  return result;
}

void CTRunGetPositions(CTRunRef run, CFRange range, CGPoint *buffer)
{
}

CTRunStatus CTRunGetStatus(CTRunRef run)
{
  return MEMORY[0x270EE9E98](run);
}

void CTRunGetStringIndices(CTRunRef run, CFRange range, CFIndex *buffer)
{
}

CFRange CTRunGetStringRange(CTRunRef run)
{
  CFIndex v1 = MEMORY[0x270EE9EB8](run);
  result.length = v2;
  result.location = v1;
  return result;
}

CGAffineTransform *__cdecl CTRunGetTextMatrix(CGAffineTransform *__return_ptr retstr, CTRunRef run)
{
  return (CGAffineTransform *)MEMORY[0x270EE9EC0](retstr, run);
}

double CTRunGetTypographicBounds(CTRunRef run, CFRange range, CGFloat *ascent, CGFloat *descent, CGFloat *leading)
{
  MEMORY[0x270EE9ED0](run, range.location, range.length, ascent, descent, leading);
  return result;
}

CTTextTabRef CTTextTabCreate(CTTextAlignment alignment, double location, CFDictionaryRef options)
{
  return (CTTextTabRef)MEMORY[0x270EE9EE8](alignment, options, location);
}

double CTTextTabGetLocation(CTTextTabRef tab)
{
  MEMORY[0x270EE9EF0](tab);
  return result;
}

CTLineRef CTTypesetterCreateLine(CTTypesetterRef typesetter, CFRange stringRange)
{
  return (CTLineRef)MEMORY[0x270EE9EF8](typesetter, stringRange.location, stringRange.length);
}

CTLineRef CTTypesetterCreateLineWithOffset(CTTypesetterRef typesetter, CFRange stringRange, double offset)
{
  return (CTLineRef)MEMORY[0x270EE9F00](typesetter, stringRange.location, stringRange.length, offset);
}

CTTypesetterRef CTTypesetterCreateWithAttributedString(CFAttributedStringRef string)
{
  return (CTTypesetterRef)MEMORY[0x270EE9F08](string);
}

CFIndex CTTypesetterSuggestClusterBreakWithOffset(CTTypesetterRef typesetter, CFIndex startIndex, double width, double offset)
{
  return MEMORY[0x270EE9F18](typesetter, startIndex, width, offset);
}

CFIndex CTTypesetterSuggestLineBreakWithOffset(CTTypesetterRef typesetter, CFIndex startIndex, double width, double offset)
{
  return MEMORY[0x270EE9F28](typesetter, startIndex, width, offset);
}

id MTLCreateSystemDefaultDevice(void)
{
  return (id)MEMORY[0x270EF5E20]();
}

uint64_t NSExpandedRange()
{
  return MEMORY[0x270F797B0]();
}

NSRange NSIntersectionRange(NSRange range1, NSRange range2)
{
  NSUInteger v2 = MEMORY[0x270EF2AF8](range1.location, range1.length, range2.location, range2.length);
  result.length = v3;
  result.location = v2;
  return result;
}

uint64_t NSIntersectionRangeInclusive()
{
  return MEMORY[0x270F797B8]();
}

void NSLog(NSString *format, ...)
{
}

NSArray *__cdecl NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory directory, NSSearchPathDomainMask domainMask, BOOL expandTilde)
{
  return (NSArray *)MEMORY[0x270EF2BD8](directory, domainMask, expandTilde);
}

SEL NSSelectorFromString(NSString *aSelectorName)
{
  return (SEL)MEMORY[0x270EF2BE8](aSelectorName);
}

uint64_t NSStringForTSUFormatType()
{
  return MEMORY[0x270F797C0]();
}

NSString *__cdecl NSStringFromCGAffineTransform(CGAffineTransform *transform)
{
  return (NSString *)MEMORY[0x270F05E90](transform);
}

NSString *__cdecl NSStringFromCGPoint(CGPoint point)
{
  return (NSString *)MEMORY[0x270F05E98]((__n128)point, *(__n128 *)&point.y);
}

NSString *__cdecl NSStringFromCGRect(CGRect rect)
{
  return (NSString *)MEMORY[0x270F05EA0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

NSString *__cdecl NSStringFromCGSize(CGSize size)
{
  return (NSString *)MEMORY[0x270F05EA8]((__n128)size, *(__n128 *)&size.height);
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return (NSString *)MEMORY[0x270EF2C08](aClass);
}

NSString *__cdecl NSStringFromRange(NSRange range)
{
  return (NSString *)MEMORY[0x270EF2C28](range.location, range.length);
}

NSString *__cdecl NSStringFromSelector(SEL aSelector)
{
  return (NSString *)MEMORY[0x270EF2C38](aSelector);
}

uint64_t NSStringFromUIGestureRecognizerState()
{
  return MEMORY[0x270F797C8]();
}

NSRange NSUnionRange(NSRange range1, NSRange range2)
{
  NSUInteger v2 = MEMORY[0x270EF2C58](range1.location, range1.length, range2.location, range2.length);
  result.length = v3;
  result.location = v2;
  return result;
}

void NSZoneFree(NSZone *zone, void *ptr)
{
}

void *__cdecl NSZoneMalloc(NSZone *zone, NSUInteger size)
{
  return (void *)MEMORY[0x270EF2C80](zone, size);
}

void *__cdecl NSZoneRealloc(NSZone *zone, void *ptr, NSUInteger size)
{
  return (void *)MEMORY[0x270EF2C88](zone, ptr, size);
}

uint64_t SFUEqualCryptoKeys()
{
  return MEMORY[0x270F797D0]();
}

uint64_t TSUBitmapGetAlignedBytesPerRow()
{
  return MEMORY[0x270F797D8]();
}

uint64_t TSUCFTypeCast()
{
  return MEMORY[0x270F797E0]();
}

uint64_t TSUCGColorCreateDeviceRGB()
{
  return MEMORY[0x270F797E8]();
}

uint64_t TSUCGColorCreateRandomRGB()
{
  return MEMORY[0x270F797F0]();
}

uint64_t TSUCGImagePNGRepresentation()
{
  return MEMORY[0x270F797F8]();
}

uint64_t TSUCheckedDynamicCast()
{
  return MEMORY[0x270F79800]();
}

uint64_t TSUClamp()
{
  return MEMORY[0x270F79808]();
}

uint64_t TSUClassAndProtocolCast()
{
  return MEMORY[0x270F79810]();
}

uint64_t TSUCreateCheckerBoardColor()
{
  return MEMORY[0x270F79818]();
}

uint64_t TSUCreateDateFromString()
{
  return MEMORY[0x270F79820]();
}

uint64_t TSUCreateDateFromStringWithPreferredFormat()
{
  return MEMORY[0x270F79828]();
}

uint64_t TSUDefaultDateTimeFormat()
{
  return MEMORY[0x270F79838]();
}

uint64_t TSUDeviceGrayColorSpace()
{
  return MEMORY[0x270F79840]();
}

uint64_t TSUDeviceRGBColorSpace()
{
  return MEMORY[0x270F79848]();
}

uint64_t TSUDistance()
{
  return MEMORY[0x270F79850]();
}

uint64_t TSUDurationFormatterDurationUnitsNecessaryToFullyDisplayDuration()
{
  return MEMORY[0x270F79858]();
}

uint64_t TSUDurationFormatterFormatFromDurationUnits()
{
  return MEMORY[0x270F79860]();
}

uint64_t TSUDurationFormatterMaxDurationUnitInUnits()
{
  return MEMORY[0x270F79868]();
}

uint64_t TSUDurationFormatterMinDurationUnitInUnits()
{
  return MEMORY[0x270F79870]();
}

uint64_t TSUDurationFormatterTimeIntervalFromStringWithCompactStyleStartUnit()
{
  return MEMORY[0x270F79880]();
}

uint64_t TSUDynamicCast()
{
  return MEMORY[0x270F79890]();
}

uint64_t TSUFindFirstResponderView()
{
  return MEMORY[0x270F79898]();
}

uint64_t TSUFormatStructHash()
{
  return MEMORY[0x270F798A8]();
}

uint64_t TSUFormatStructRelease()
{
  return MEMORY[0x270F798B0]();
}

uint64_t TSUFormatStructRetain()
{
  return MEMORY[0x270F798B8]();
}

uint64_t TSUFractionalPart()
{
  return MEMORY[0x270F798C0]();
}

uint64_t TSUGetCurrentLocale()
{
  return MEMORY[0x270F798C8]();
}

uint64_t TSUGetNumberValueAndTypeFromString()
{
  return MEMORY[0x270F798D0]();
}

uint64_t TSUGetNumberValueAndTypeFromStringWithCurrencyCode()
{
  return MEMORY[0x270F798D8]();
}

uint64_t TSUHasCJKLanguage()
{
  return MEMORY[0x270F798E8]();
}

uint64_t TSUHash()
{
  return MEMORY[0x270F798F8]();
}

uint64_t TSUHashWithSeed()
{
  return MEMORY[0x270F79900]();
}

uint64_t TSUImageOrientationTransform()
{
  return MEMORY[0x270F79908]();
}

uint64_t TSUIntersectionRangeWithEdge()
{
  return MEMORY[0x270F79910]();
}

uint64_t TSUIsGroupingSeparatorUsedInNumericString()
{
  return MEMORY[0x270F79918]();
}

uint64_t TSULink()
{
  return MEMORY[0x270F79920]();
}

uint64_t TSULogErrorInFunction()
{
  return MEMORY[0x270F79928]();
}

uint64_t TSUMix()
{
  return MEMORY[0x270F79930]();
}

uint64_t TSUMixFloats()
{
  return MEMORY[0x270F79938]();
}

uint64_t TSUMixPoints()
{
  return MEMORY[0x270F79940]();
}

uint64_t TSUMixRects()
{
  return MEMORY[0x270F79948]();
}

uint64_t TSUMixSizes()
{
  return MEMORY[0x270F79950]();
}

uint64_t TSUNumberOfDecimalPlacesInNumericString()
{
  return MEMORY[0x270F79960]();
}

uint64_t TSUNumberOfDecimalPlacesInValue()
{
  return MEMORY[0x270F79968]();
}

uint64_t TSUObjectReferenceDescription()
{
  return MEMORY[0x270F79970]();
}

uint64_t TSUOpen()
{
  return MEMORY[0x270F79978]();
}

uint64_t TSUP3ColorSpace()
{
  return MEMORY[0x270F79980]();
}

uint64_t TSUPadUI()
{
  return MEMORY[0x270F79988]();
}

uint64_t TSUPhoneUI()
{
  return MEMORY[0x270F79990]();
}

uint64_t TSUPointIsFinite()
{
  return MEMORY[0x270F79998]();
}

uint64_t TSUProtocolCast()
{
  return MEMORY[0x270F799A0]();
}

uint64_t TSURandom()
{
  return MEMORY[0x270F799A8]();
}

uint64_t TSURandomBetween()
{
  return MEMORY[0x270F799B0]();
}

uint64_t TSURectWithSize()
{
  return MEMORY[0x270F799B8]();
}

uint64_t TSURound()
{
  return MEMORY[0x270F799C0]();
}

uint64_t TSUScreenScale()
{
  return MEMORY[0x270F799C8]();
}

uint64_t TSUShortestCompleteDateTimeFormat()
{
  return MEMORY[0x270F799D0]();
}

uint64_t TSUShrinkSizeToFitInSize()
{
  return MEMORY[0x270F799D8]();
}

uint64_t TSUStatusBarIsLandscape()
{
  return MEMORY[0x270F799E0]();
}

uint64_t TSUSubtractPoints()
{
  return MEMORY[0x270F799E8]();
}

uint64_t TSUSupportsTextInteraction()
{
  return MEMORY[0x270F799F0]();
}

BOOL UIAccessibilityIsClosedCaptioningEnabled(void)
{
  return MEMORY[0x270F05F08]();
}

BOOL UIAccessibilityIsVoiceOverRunning(void)
{
  return MEMORY[0x270F05F58]();
}

void UIGraphicsBeginImageContextWithOptions(CGSize size, BOOL opaque, CGFloat scale)
{
}

void UIGraphicsEndImageContext(void)
{
}

CGContextRef UIGraphicsGetCurrentContext(void)
{
  return (CGContextRef)MEMORY[0x270F06030]();
}

UIImage *UIGraphicsGetImageFromCurrentImageContext(void)
{
  return (UIImage *)MEMORY[0x270F06038]();
}

void UIGraphicsPopContext(void)
{
}

void UIGraphicsPushContext(CGContextRef context)
{
}

Boolean UTTypeConformsTo(CFStringRef inUTI, CFStringRef inConformsToUTI)
{
  return MEMORY[0x270EE8548](inUTI, inConformsToUTI);
}

CFStringRef UTTypeCreatePreferredIdentifierForTag(CFStringRef inTagClass, CFStringRef inTag, CFStringRef inConformingToUTI)
{
  return (CFStringRef)MEMORY[0x270EE8580](inTagClass, inTag, inConformingToUTI);
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x270ED7CD8](aBlock);
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Block_release(const void *aBlock)
{
}

NSDictionary *_NSDictionaryOfVariableBindings(NSString *commaSeparatedKeysString, id firstValue, ...)
{
  return (NSDictionary *)MEMORY[0x270EF2C98](commaSeparatedKeysString, firstValue);
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

uint64_t TSUFormatInit(void)
{
  return MEMORY[0x270F799F8]();
}

uint64_t TSUFormatBaseStringFromDouble()
{
  return MEMORY[0x270F79A00]();
}

uint64_t TSUFormatCustomStringFromDouble()
{
  return MEMORY[0x270F79A08]();
}

uint64_t TSUFormatStructStringFromDouble()
{
  return MEMORY[0x270F79A10]();
}

uint64_t TSUFormatTypeFromTSUNumberValueType()
{
  return MEMORY[0x270F79A18]();
}

uint64_t TSUCustomFormat::formatName(TSUCustomFormat *this)
{
  return MEMORY[0x270F79A20](this);
}

uint64_t TSUCustomFormat::setFormatName(TSUCustomFormat *this, NSString *a2)
{
  return MEMORY[0x270F79A28](this, a2);
}

uint64_t TSUCustomFormat::customFormatIsEqual(TSUCustomFormat *this, TSUCustomFormat *a2)
{
  return MEMORY[0x270F79A30](this, a2);
}

void TSUCustomFormat::TSUCustomFormat(TSUCustomFormat *this, const TSUCustomFormat *a2)
{
}

void TSUCustomFormat::~TSUCustomFormat(TSUCustomFormat *this)
{
}

uint64_t TSUFormat::TSUFormat()
{
  return MEMORY[0x270F79A50]();
}

void TSUFormat::~TSUFormat(TSUFormat *this)
{
}

uint64_t TSUCustomFormat::defaultFormatData(TSUCustomFormat *this)
{
  return MEMORY[0x270F79A60](this);
}

uint64_t TSUCustomFormat::formatByEvaluatingConditionsWithDouble(TSUCustomFormat *this, double a2)
{
  return MEMORY[0x270F79A68](this, a2);
}

uint64_t TSUFormat::isEqual(TSUFormat *this, const TSUFormat *a2)
{
  return MEMORY[0x270F79A70](this, a2);
}

uint64_t std::stringbuf::str()
{
  return MEMORY[0x270F98268]();
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x270F982E8](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x270F982F8](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x270F98330](this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x270F98428](this);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x270F98458](__n);
}

std::string *__cdecl std::string::erase(std::string *this, std::string::size_type __pos, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x270F98480](this, __pos, __n);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x270F98498](this, __s);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x270F984A0](this, __s, __n);
}

std::string *__cdecl std::string::assign(std::string *this, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x270F984B8](this, __s);
}

void std::string::resize(std::string *this, std::string::size_type __n, std::string::value_type __c)
{
}

std::string *__cdecl std::string::basic_string(std::string *this, const std::string *__str, std::string::size_type __pos, std::string::size_type __n, std::allocator<char> *__a)
{
  return (std::string *)MEMORY[0x270F98548](this, __str, __pos, __n, __a);
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x270F98560](this, __str);
}

uint64_t std::istream::peek()
{
  return MEMORY[0x270F98670]();
}

uint64_t std::istream::~istream()
{
  return MEMORY[0x270F986D0]();
}

uint64_t std::istream::operator>>()
{
  return MEMORY[0x270F986E0]();
}

{
  return MEMORY[0x270F986E8]();
}

{
  return MEMORY[0x270F986F0]();
}

{
  return MEMORY[0x270F98700]();
}

{
  return MEMORY[0x270F98708]();
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x270F98758]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x270F98760]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x270F98790]();
}

uint64_t std::iostream::~basic_iostream()
{
  return MEMORY[0x270F98870]();
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x270F988A8]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x270F988B0]();
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
}

uint64_t std::__sort<std::__less<unsigned int,unsigned int> &,unsigned int *>()
{
  return MEMORY[0x270F98BF0]();
}

void std::locale::~locale(std::locale *this)
{
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x270F98DE8]();
}

void std::terminate(void)
{
}

void operator delete[]()
{
  while (1)
    ;
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete(void *__p, const std::nothrow_t *a2)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void operator new[]()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz, const std::nothrow_t *a2)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x270F98EC0](thrown_size);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x270F98ED8](a1);
}

void __cxa_end_catch(void)
{
}

void __cxa_free_exception(void *a1)
{
}

void __cxa_guard_abort(__guard *a1)
{
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x270F98F10](a1);
}

void __cxa_guard_release(__guard *a1)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

int *__error(void)
{
  return (int *)MEMORY[0x270ED7DC0]();
}

double __exp10(double a1)
{
  MEMORY[0x270ED7DC8](a1);
  return result;
}

int __fpclassifyd(double a1)
{
  return MEMORY[0x270ED7DE8](a1);
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x270ED7E28](*(void *)&a1, a2);
}

__double2 __sincos_stret(double a1)
{
  MEMORY[0x270ED7E88](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

__float2 __sincosf_stret(float a1)
{
  MEMORY[0x270ED7E90](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void abort(void)
{
}

long double acos(long double __x)
{
  MEMORY[0x270ED8588](__x);
  return result;
}

float acosf(float a1)
{
  MEMORY[0x270ED8598](a1);
  return result;
}

long double asin(long double __x)
{
  MEMORY[0x270ED8610](__x);
  return result;
}

long double atan2(long double __y, long double __x)
{
  MEMORY[0x270ED86A8](__y, __x);
  return result;
}

void *__cdecl bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  return (void *)MEMORY[0x270ED8798](__key, __base, __nel, __width, __compar);
}

void bzero(void *a1, size_t a2)
{
}

BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)
{
  return MEMORY[0x270F9A400](cls, name, imp, types);
}

BOOL class_conformsToProtocol(Class cls, Protocol *protocol)
{
  return MEMORY[0x270F9A420](cls, protocol);
}

size_t class_getInstanceSize(Class cls)
{
  return MEMORY[0x270F9A468](cls);
}

const char *__cdecl class_getName(Class cls)
{
  return (const char *)MEMORY[0x270F9A480](cls);
}

Class class_getSuperclass(Class cls)
{
  return (Class)MEMORY[0x270F9A490](cls);
}

int close(int a1)
{
  return MEMORY[0x270ED8F18](*(void *)&a1);
}

long double cos(long double __x)
{
  MEMORY[0x270ED9128](__x);
  return result;
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_barrier_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

BOOL dispatch_data_apply(dispatch_data_t data, dispatch_data_applier_t applier)
{
  return MEMORY[0x270ED92B8](data, applier);
}

dispatch_data_t dispatch_data_create(const void *buffer, size_t size, dispatch_queue_t queue, dispatch_block_t destructor)
{
  return (dispatch_data_t)MEMORY[0x270ED92D0](buffer, size, queue, destructor);
}

dispatch_data_t dispatch_data_create_concat(dispatch_data_t data1, dispatch_data_t data2)
{
  return (dispatch_data_t)MEMORY[0x270ED92E0](data1, data2);
}

dispatch_data_t dispatch_data_create_subrange(dispatch_data_t data, size_t offset, size_t length)
{
  return (dispatch_data_t)MEMORY[0x270ED92F0](data, offset, length);
}

size_t dispatch_data_get_size(dispatch_data_t data)
{
  return MEMORY[0x270ED9300](data);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x270ED9318](identifier, flags);
}

void *__cdecl dispatch_get_specific(const void *key)
{
  return (void *)MEMORY[0x270ED9320](key);
}

void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x270ED9340]();
}

void dispatch_group_enter(dispatch_group_t group)
{
}

void dispatch_group_leave(dispatch_group_t group)
{
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x270ED9378](group, timeout);
}

void dispatch_io_barrier(dispatch_io_t channel, dispatch_block_t barrier)
{
}

void dispatch_io_close(dispatch_io_t channel, dispatch_io_close_flags_t flags)
{
}

dispatch_io_t dispatch_io_create(dispatch_io_type_t type, dispatch_fd_t fd, dispatch_queue_t queue, void *cleanup_handler)
{
  return (dispatch_io_t)MEMORY[0x270ED9390](type, *(void *)&fd, queue, cleanup_handler);
}

void dispatch_io_write(dispatch_io_t channel, off_t offset, dispatch_data_t data, dispatch_queue_t queue, dispatch_io_handler_t io_handler)
{
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x270ED9460](label, attr);
}

void dispatch_queue_set_specific(dispatch_queue_t queue, const void *key, void *context, dispatch_function_t destructor)
{
}

void dispatch_release(dispatch_object_t object)
{
}

void dispatch_resume(dispatch_object_t object)
{
}

void dispatch_retain(dispatch_object_t object)
{
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x270ED94B8](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x270ED94C8](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x270ED94D0](dsema, timeout);
}

void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue)
{
}

void dispatch_suspend(dispatch_object_t object)
{
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x270ED95A8](when, delta);
}

long double exp2(long double __x)
{
  MEMORY[0x270ED9860](__x);
  return result;
}

float exp2f(float a1)
{
  MEMORY[0x270ED9868](a1);
  return result;
}

long double fmod(long double __x, long double __y)
{
  MEMORY[0x270ED99D0](__x, __y);
  return result;
}

float fmodf(float a1, float a2)
{
  MEMORY[0x270ED99D8](a1, a2);
  return result;
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x270ED9A08](a1, a2);
}

void free(void *a1)
{
}

long double frexp(long double __x, int *__e)
{
  MEMORY[0x270ED9A68](__e, __x);
  return result;
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x270ED9B88](__ptr, __size, __nitems, __stream);
}

int getrlimit(int a1, rlimit *a2)
{
  return MEMORY[0x270ED9D48](*(void *)&a1, a2);
}

long double hypot(long double __x, long double __y)
{
  MEMORY[0x270ED9E58](__x, __y);
  return result;
}

long double ldexp(long double __x, int __e)
{
  MEMORY[0x270EDA028](*(void *)&__e, __x);
  return result;
}

float ldexpf(float a1, int a2)
{
  MEMORY[0x270EDA030](*(void *)&a2, a1);
  return result;
}

long double log(long double __x)
{
  MEMORY[0x270EDA0A8](__x);
  return result;
}

long double log2(long double __x)
{
  MEMORY[0x270EDA0D8](__x);
  return result;
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x270EDA288](info);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA388](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA390](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA3A0](ptr, size, type_id);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x270EDA458](__s, *(void *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x270EDA468](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x270EDA470](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x270EDA488](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x270EDA498](__b, *(void *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
}

int mergesort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  return MEMORY[0x270EDA4C0](__base, __nel, __width, __compar);
}

long double nextafter(long double __x, long double __y)
{
  MEMORY[0x270EDA710](__x, __y);
  return result;
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x270F9A528](a1);
}

id objc_allocWithZone(Class a1)
{
  return (id)MEMORY[0x270F9A538](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x270F9A540]();
}

Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)
{
  return (Class)MEMORY[0x270F9A550](superclass, name, extraBytes);
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x270F9A568](a1);
}

{
  MEMORY[0x270F9A570](context);
}

{
  return (void *)MEMORY[0x270F9A588]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A590](a1);
}

id objc_begin_catch(void *exc_buf)
{
  return (id)MEMORY[0x270F9A598](exc_buf);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x270F9A5A8]();
}

void objc_copyStruct(void *dest, const void *src, ptrdiff_t size, BOOL atomic, BOOL hasStrong)
{
}

void objc_copyWeak(id *to, id *from)
{
}

void objc_destroyWeak(id *location)
{
}

void objc_end_catch(void)
{
}

void objc_enumerationMutation(id obj)
{
}

void objc_exception_rethrow(void)
{
}

void objc_exception_throw(id exception)
{
}

id objc_getAssociatedObject(id object, const void *key)
{
  return (id)MEMORY[0x270F9A648](object, key);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x270F9A678](self, _cmd, offset, atomic);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x270F9A688](location, val);
}

id objc_loadWeak(id *location)
{
  return (id)MEMORY[0x270F9A6A0](location);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x270F9A6B0](location);
}

id objc_msgSend(id a1, SEL a2, ...)
{
  return (id)MEMORY[0x270F9A6D0](a1, a2);
}

id objc_msgSendSuper(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x270F9A6D8](a1, a2);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x270F9A6E8](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x270F9A6F8]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x270F9A700]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x270F9A710]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x270F9A728]();
}

void objc_registerClassPair(Class cls)
{
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x270F9A870](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x270F9A880](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A888](a1);
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A890](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x270F9A898](a1);
}

void objc_setAssociatedObject(id object, const void *key, id value, void *policy)
{
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_atomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_nonatomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_storeStrong(id *location, id obj)
{
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x270F9A9F8](location, obj);
}

int objc_sync_enter(id obj)
{
  return MEMORY[0x270F9AA18](obj);
}

int objc_sync_exit(id obj)
{
  return MEMORY[0x270F9AA20](obj);
}

void objc_terminate(void)
{
}

id objc_unsafeClaimAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x270F9AA38](a1);
}

Class object_getClass(id a1)
{
  return (Class)MEMORY[0x270F9AA40](a1);
}

const char *__cdecl object_getClassName(id a1)
{
  return (const char *)MEMORY[0x270F9AA48](a1);
}

Class object_setClass(id a1, Class a2)
{
  return (Class)MEMORY[0x270F9AA70](a1, a2);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x270EDA9D0](oslog, type);
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

long double pow(long double __x, long double __y)
{
  MEMORY[0x270EDACF8](__x, __y);
  return result;
}

float powf(float a1, float a2)
{
  MEMORY[0x270EDAD00](a1, a2);
  return result;
}

int printf(const char *a1, ...)
{
  return MEMORY[0x270EDAD20](a1);
}

int pthread_main_np(void)
{
  return MEMORY[0x270EDAF40]();
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x270EDAF50](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x270EDAF58](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x270EDAF60](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x270EDAF70](a1);
}

int pthread_mutexattr_destroy(pthread_mutexattr_t *a1)
{
  return MEMORY[0x270EDAF78](a1);
}

int pthread_mutexattr_init(pthread_mutexattr_t *a1)
{
  return MEMORY[0x270EDAF80](a1);
}

int pthread_mutexattr_settype(pthread_mutexattr_t *a1, int a2)
{
  return MEMORY[0x270EDAF98](a1, *(void *)&a2);
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return MEMORY[0x270EDAFA0](a1, a2);
}

int pthread_rwlock_destroy(pthread_rwlock_t *a1)
{
  return MEMORY[0x270EDAFC8](a1);
}

int pthread_rwlock_init(pthread_rwlock_t *a1, const pthread_rwlockattr_t *a2)
{
  return MEMORY[0x270EDAFD0](a1, a2);
}

int pthread_rwlock_rdlock(pthread_rwlock_t *a1)
{
  return MEMORY[0x270EDAFD8](a1);
}

int pthread_rwlock_unlock(pthread_rwlock_t *a1)
{
  return MEMORY[0x270EDAFF0](a1);
}

int pthread_rwlock_wrlock(pthread_rwlock_t *a1)
{
  return MEMORY[0x270EDAFF8](a1);
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x270EDB010]();
}

int putchar(int a1)
{
  return MEMORY[0x270EDB090](*(void *)&a1);
}

int puts(const char *a1)
{
  return MEMORY[0x270EDB098](a1);
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
}

void qsort_b(void *__base, size_t __nel, size_t __width, void *__compar)
{
}

uint64_t random(void)
{
  return MEMORY[0x270EDB0E8]();
}

void *__cdecl reallocf(void *__ptr, size_t __size)
{
  return (void *)MEMORY[0x270EDB158](__ptr, __size);
}

int rmdir(const char *a1)
{
  return MEMORY[0x270EDB268](a1);
}

const char *__cdecl sel_getName(SEL sel)
{
  return (const char *)MEMORY[0x270F9AAE0](sel);
}

BOOL sel_isEqual(SEL lhs, SEL rhs)
{
  return MEMORY[0x270F9AAF0](lhs, rhs);
}

int setrlimit(int a1, const rlimit *a2)
{
  return MEMORY[0x270EDB428](*(void *)&a1, a2);
}

long double sin(long double __x)
{
  MEMORY[0x270EDB4E8](__x);
  return result;
}

float sinf(float a1)
{
  MEMORY[0x270EDB4F0](a1);
  return result;
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x270EDB510](__str, __size, __format);
}

int sqlite3_blob_bytes(sqlite3_blob *a1)
{
  return MEMORY[0x270F9B508](a1);
}

int sqlite3_blob_close(sqlite3_blob *a1)
{
  return MEMORY[0x270F9B510](a1);
}

int sqlite3_blob_read(sqlite3_blob *a1, void *Z, int N, int iOffset)
{
  return MEMORY[0x270F9B520](a1, Z, *(void *)&N, *(void *)&iOffset);
}

void srandom(unsigned int a1)
{
}

int sscanf(const char *a1, const char *a2, ...)
{
  return MEMORY[0x270EDB560](a1, a2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return (char *)MEMORY[0x270EDB5A8](__s, *(void *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x270EDB5B0](__s1, __s2);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x270EDB5D8](*(void *)&__errnum);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x270EDB610](__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x270EDB638](__s1, __s2, __n);
}

long double tan(long double __x)
{
  MEMORY[0x270EDB810](__x);
  return result;
}

UCharDirection u_charDirection(UChar32 c)
{
  return MEMORY[0x270F994D8](*(void *)&c);
}

int32_t u_getIntPropertyValue(UChar32 c, UProperty which)
{
  return MEMORY[0x270F99500](*(void *)&c, *(void *)&which);
}

UBlockCode ublock_getCode(UChar32 c)
{
  return MEMORY[0x270F99608](*(void *)&c);
}

int unlink(const char *a1)
{
  return MEMORY[0x270EDB9A8](a1);
}

int vasprintf(char **a1, const char *a2, va_list a3)
{
  return MEMORY[0x270EDBA58](a1, a2, a3);
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return MEMORY[0x270EDBC30](*(void *)&__fd, __buf, __nbyte);
}

const xmlChar *__cdecl xmlBufferContent(const xmlBuffer *buf)
{
  return (const xmlChar *)MEMORY[0x270F9BB40](buf);
}

xmlBufferPtr xmlBufferCreate(void)
{
  return (xmlBufferPtr)MEMORY[0x270F9BB48]();
}

void xmlBufferFree(xmlBufferPtr buf)
{
}

xmlNodePtr xmlDocGetRootElement(const xmlDoc *doc)
{
  return (xmlNodePtr)MEMORY[0x270F9BC50](doc);
}

void xmlFreeDoc(xmlDocPtr cur)
{
}

xmlExternalEntityLoader xmlGetExternalEntityLoader(void)
{
  return (xmlExternalEntityLoader)MEMORY[0x270F9BCE8]();
}

xmlAttrPtr xmlHasNsProp(const xmlNode *node, const xmlChar *name, const xmlChar *nameSpace)
{
  return (xmlAttrPtr)MEMORY[0x270F9BD38](node, name, nameSpace);
}

xmlAttrPtr xmlHasProp(const xmlNode *node, const xmlChar *name)
{
  return (xmlAttrPtr)MEMORY[0x270F9BD40](node, name);
}

int xmlNodeBufGetContent(xmlBufferPtr buffer, const xmlNode *cur)
{
  return MEMORY[0x270F9BF10](buffer, cur);
}

int xmlNodeIsText(const xmlNode *node)
{
  return MEMORY[0x270F9BF40](node);
}

xmlChar *__cdecl xmlNodeListGetString(xmlDocPtr doc, const xmlNode *list, int inLine)
{
  return (xmlChar *)MEMORY[0x270F9BF48](doc, list, *(void *)&inLine);
}

xmlDocPtr xmlReadMemory(const char *buffer, int size, const char *URL, const char *encoding, int options)
{
  return (xmlDocPtr)MEMORY[0x270F9BFE0](buffer, *(void *)&size, URL, encoding, *(void *)&options);
}

xmlEntityPtr xmlSAX2GetEntity(void *ctx, const xmlChar *name)
{
  return (xmlEntityPtr)MEMORY[0x270F9C010](ctx, name);
}

xmlDocPtr xmlSAXParseMemory(xmlSAXHandlerPtr sax, const char *buffer, int size, int recovery)
{
  return (xmlDocPtr)MEMORY[0x270F9C030](sax, buffer, *(void *)&size, *(void *)&recovery);
}

int xmlSAXVersion(xmlSAXHandler *hdlr, int version)
{
  return MEMORY[0x270F9C038](hdlr, *(void *)&version);
}

xmlNsPtr xmlSearchNsByHref(xmlDocPtr doc, xmlNodePtr node, const xmlChar *href)
{
  return (xmlNsPtr)MEMORY[0x270F9C0C8](doc, node, href);
}

void xmlSetExternalEntityLoader(xmlExternalEntityLoader f)
{
}

int xmlSubstituteEntitiesDefault(int val)
{
  return MEMORY[0x270F9C188](*(void *)&val);
}

xmlXPathObjectPtr xmlXPathEvalExpression(const xmlChar *str, xmlXPathContextPtr ctxt)
{
  return (xmlXPathObjectPtr)MEMORY[0x270F9C3D8](str, ctxt);
}

void xmlXPathFreeContext(xmlXPathContextPtr ctxt)
{
}

void xmlXPathFreeObject(xmlXPathObjectPtr obj)
{
}

xmlXPathContextPtr xmlXPathNewContext(xmlDocPtr doc)
{
  return (xmlXPathContextPtr)MEMORY[0x270F9C458](doc);
}

int xmlXPathRegisterNs(xmlXPathContextPtr ctxt, const xmlChar *prefix, const xmlChar *ns_uri)
{
  return MEMORY[0x270F9C538](ctxt, prefix, ns_uri);
}